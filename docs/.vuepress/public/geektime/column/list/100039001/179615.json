{"id":179615,"title":"22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？","content":"<p>今天，我们讲最后一个设计原则：迪米特法则。尽管它不像SOLID、KISS、DRY原则那样，人尽皆知，但它却非常实用。利用这个原则，能够帮我们实现代码的“高内聚、松耦合”。今天，我们就围绕下面几个问题，并结合两个代码实战案例，来深入地学习这个法则。</p><ul>\n<li>什么是“高内聚、松耦合”？</li>\n<li>如何利用迪米特法则来实现“高内聚、松耦合”？</li>\n<li>有哪些代码设计是明显违背迪米特法则的？对此又该如何重构？</li>\n</ul><p>话不多说，让我们开始今天的学习吧！</p><h2>何为“高内聚、松耦合”？</h2><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，在前面的章节中，我们已经多次提到过这个设计思想。很多设计原则都以实现代码的“高内聚、松耦合”为目的，比如单一职责原则、基于接口而非实现编程等。</p><p>实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类，甚至是函数，也可以应用到不同的开发场景中，比如微服务、框架、组件、类库等。为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。</p><p>在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。</p><!-- [[[read_end]]] --><p><strong>那到底什么是“高内聚”呢？</strong></p><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。对于这一点，你可以回过头再去看下专栏的<a href=\"https://time.geekbang.org/column/article/171771?utm_source=PC&amp;utm_medium=geektime&amp;utm_term=pc_interstitial_5\">第15讲</a>。</p><p><strong>我们再来看一下，什么是“松耦合”？</strong></p><p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合。</p><p><strong>最后，我们来看一下，“内聚”和“耦合”之间的关系。</strong></p><p>前面也提到，“高内聚”有助于“松耦合”，同理，“低内聚”也会导致“紧耦合”。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”。</p><p><img src=\"https://static001.geekbang.org/resource/image/62/3c/62275095f1f5817cad8a9ca129a6ec3c.jpg?wh=1933*1363\" alt=\"\"></p><p>图中左边部分的代码设计中，类的粒度比较小，每个类的职责都比较单一。相近的功能都放到了一个类中，不相近的功能被分割到了多个类中。这样类更加独立，代码的内聚性更好。因为职责单一，所以每个类被依赖的类就会比较少，代码低耦合。一个类的修改，只会影响到一个依赖类的代码改动。我们只需要测试这一个依赖类是否还能正常工作就行了。</p><p>图中右边部分的代码设计中，类粒度比较大，低内聚，功能大而全，不相近的功能放到了一个类中。这就导致很多其他类都依赖这个类。当我们修改这个类的某一个功能代码的时候，会影响依赖它的多个类。我们需要测试这三个依赖类，是否还能正常工作。这也就是所谓的“牵一发而动全身”。</p><p>除此之外，从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。</p><h2>“迪米特法则”理论描述</h2><p>迪米特法则的英文翻译是：Law of Demeter，缩写是LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。</p><p>关于这个设计原则，我们先来看一下它最原汁原味的英文定义：</p><blockquote>\n<p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p>\n</blockquote><p>我们把它直译成中文，就是下面这个样子：</p><blockquote>\n<p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p>\n</blockquote><p>我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，要想灵活地应用到实际的开发中，需要有实战经验的积累。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下。注意，为了统一讲解，我把定义描述中的“模块”替换成了“类”。</p><blockquote>\n<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。</p>\n</blockquote><p>从上面的描述中，我们可以看出，迪米特法则包含前后两部分，这两部分讲的是两件事情，我用两个实战案例分别来解读一下。</p><h2>理论解读与代码实战一</h2><p>我们先来看这条原则中的前半部分，<strong>“不该有直接依赖关系的类之间，不要有依赖”。</strong>我举个例子解释一下。</p><p>这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter类负责底层网络通信，根据请求获取数据；HtmlDownloader类用来通过URL获取网页；Document表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：</p><pre><code>public class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(HtmlRequest htmlRequest) {\n      //...\n    }\n}\n\npublic class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  public Html downloadHtml(String url) {\n    Byte[] rawHtml = transporter.send(new HtmlRequest(url));\n    return new Html(rawHtml);\n  }\n}\n\npublic class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url) {\n    this.url = url;\n    HtmlDownloader downloader = new HtmlDownloader();\n    this.html = downloader.downloadHtml(url);\n  }\n  //...\n}\n</code></pre><p>这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，有比较多的设计缺陷。你可以先试着思考一下，看看都有哪些缺陷，然后再来看我下面的讲解。</p><p><strong>首先，我们来看NetworkTransporter类。</strong>作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载HTML，所以，我们不应该直接依赖太具体的发送对象HtmlRequest。从这一点上讲，NetworkTransporter类的设计违背迪米特法则，依赖了不该有直接依赖关系的HtmlRequest类。</p><p>我们应该如何进行重构，让NetworkTransporter类满足迪米特法则呢？我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的HtmlRequest对象就相当于钱包，HtmlRequest里的address和content对象就相当于钱。我们应该把address和content交给NetworkTransporter，而非是直接把HtmlRequest交给NetworkTransporter。根据这个思路，NetworkTransporter重构之后的代码如下所示：</p><pre><code>public class NetworkTransporter {\n    // 省略属性和其他方法...\n    public Byte[] send(String address, Byte[] data) {\n      //...\n    }\n}\n</code></pre><p><strong>我们再来看HtmlDownloader类。</strong>这个类的设计没有问题。不过，我们修改了NetworkTransporter的send()函数的定义，而这个类用到了send()函数，所以我们需要对它做相应的修改，修改后的代码如下所示：</p><pre><code>public class HtmlDownloader {\n  private NetworkTransporter transporter;//通过构造函数或IOC注入\n  \n  // HtmlDownloader这里也要有相应的修改\n  public Html downloadHtml(String url) {\n    HtmlRequest htmlRequest = new HtmlRequest(url);\n    Byte[] rawHtml = transporter.send(\n      htmlRequest.getAddress(), htmlRequest.getContent().getBytes());\n    return new Html(rawHtml);\n  }\n}\n</code></pre><p><strong>最后，我们来看下Document类。</strong>这个类的问题比较多，主要有三点。第一，构造函数中的downloader.downloadHtml()逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。代码的可测试性我们后面会讲到，这里你先知道有这回事就可以了。第二，HtmlDownloader对象在构造函数中通过new来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。第三，从业务含义上来讲，Document网页文档没必要依赖HtmlDownloader类，违背了迪米特法则。</p><p>虽然Document类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题。修改之后的代码如下所示：</p><pre><code>public class Document {\n  private Html html;\n  private String url;\n  \n  public Document(String url, Html html) {\n    this.html = html;\n    this.url = url;\n  }\n  //...\n}\n\n// 通过一个工厂方法来创建Document\npublic class DocumentFactory {\n  private HtmlDownloader downloader;\n  \n  public DocumentFactory(HtmlDownloader downloader) {\n    this.downloader = downloader;\n  }\n  \n  public Document createDocument(String url) {\n    Html html = downloader.downloadHtml(url);\n    return new Document(url, html);\n  }\n}\n</code></pre><h2>理论解读与代码实战二</h2><p>现在，我们再来看一下这条原则中的后半部分：“有依赖关系的类之间，尽量只依赖必要的接口”。我们还是结合一个例子来讲解。下面这段代码非常简单，Serialization类负责对象的序列化和反序列化。提醒你一下，有个类似的例子在之前的第15节课中讲过，你可以结合着一块儿看一下。</p><pre><code>public class Serialization {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    //...\n    return serializedResult;\n  }\n  \n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    //...\n    return deserializedResult;\n  }\n}\n</code></pre><p>单看这个类的设计，没有一点问题。不过，如果我们把它放到一定的应用场景里，那就还有继续优化的空间。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。那基于迪米特法则后半部分“有依赖关系的类之间，尽量只依赖必要的接口”，只用到序列化操作的那部分类不应该依赖反序列化接口。同理，只用到反序列化操作的那部分类不应该依赖序列化接口。</p><p>根据这个思路，我们应该将Serialization类拆分为两个更小粒度的类，一个只负责序列化（Serializer类），一个只负责反序列化（Deserializer类）。拆分之后，使用序列化操作的类只需要依赖Serializer类，使用反序列化操作的类只需要依赖Deserializer类。拆分之后的代码如下所示：</p><pre><code>public class Serializer {\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n}\n\npublic class Deserializer {\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n</code></pre><p>不知道你有没有看出来，尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。高内聚要求相近的功能要放到同一个类中，这样可以方便功能修改的时候，修改的地方不至于过于分散。对于刚刚这个例子来说，如果我们修改了序列化的实现方式，比如从JSON换成了XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，这种设计思路的代码改动范围变大了。</p><p>如果我们既不想违背高内聚的设计思想，也不想违背迪米特法则，那我们该如何解决这个问题呢？实际上，通过引入两个接口就能轻松解决这个问题，具体的代码如下所示。实际上，我们在<a href=\"https://time.geekbang.org/column/article/177442\">第18节课</a>中讲到“接口隔离原则”的时候，第三个例子就使用了类似的实现思路，你可以结合着一块儿来看。</p><pre><code>public interface Serializable {\n  String serialize(Object object);\n}\n\npublic interface Deserializable {\n  Object deserialize(String text);\n}\n\npublic class Serialization implements Serializable, Deserializable {\n  @Override\n  public String serialize(Object object) {\n    String serializedResult = ...;\n    ...\n    return serializedResult;\n  }\n  \n  @Override\n  public Object deserialize(String str) {\n    Object deserializedResult = ...;\n    ...\n    return deserializedResult;\n  }\n}\n\npublic class DemoClass_1 {\n  private Serializable serializer;\n  \n  public Demo(Serializable serializer) {\n    this.serializer = serializer;\n  }\n  //...\n}\n\npublic class DemoClass_2 {\n  private Deserializable deserializer;\n  \n  public Demo(Deserializable deserializer) {\n    this.deserializer = deserializer;\n  }\n  //...\n}\n</code></pre><p>尽管我们还是要往DemoClass_1的构造函数中，传入包含序列化和反序列化的Serialization实现类，但是，我们依赖的Serializable接口只包含序列化操作，DemoClass_1无法使用Serialization类中的反序列化接口，对反序列化操作无感知，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。</p><p>实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。有些同学之前问，新的设计模式和设计原则是怎么创造出来的，实际上，就是在大量的实践中，针对开发痛点总结归纳出来的套路。</p><h2>辩证思考与灵活应用</h2><p>对于实战二最终的设计思路，你有没有什么不同的观点呢？</p><p>整个类只包含序列化和反序列化两个操作，只用到序列化操作的使用者，即便能够感知到仅有的一个反序列化函数，问题也不大。那为了满足迪米特法则，我们将一个非常简单的类，拆分出两个接口，是否有点过度设计的意思呢？</p><p>设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。</p><p>对于刚刚这个Serialization类来说，只包含两个操作，确实没有太大必要拆分成两个接口。但是，如果我们对Serialization类添加更多的功能，实现更多更好用的序列化、反序列化函数，我们来重新考虑一下这个问题。修改之后的具体的代码如下：</p><pre><code>public class Serializer { // 参看JSON的接口定义\n  public String serialize(Object object) { //... }\n  public String serializeMap(Map map) { //... }\n  public String serializeList(List list) { //... }\n  \n  public Object deserialize(String objectString) { //... }\n  public Map deserializeMap(String mapString) { //... }\n  public List deserializeList(String listString) { //... }\n}\n</code></pre><p>在这种场景下，第二种设计思路要更好些。因为基于之前的应用场景来说，大部分代码只需要用到序列化的功能。对于这部分使用者，没必要了解反序列化的“知识”，而修改之后的Serialization类，反序列化的“知识”，从一个函数变成了三个。一旦任一反序列化操作有代码改动，我们都需要检查、测试所有依赖Serialization类的代码是否还能正常工作。为了减少耦合和测试工作量，我们应该按照迪米特法则，将反序列化和序列化的功能隔离开来。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.如何理解“高内聚、松耦合”？</strong></p><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。</p><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动也不会或者很少导致依赖类的代码改动。</p><p><strong>2.如何理解“迪米特法则”？</strong></p><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p><h2>课堂讨论</h2><p>在今天的讲解中，我们提到了“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？</p><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":164612,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1577060295,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"1513405548487","product_id":100039001,"comment_content":"目的都是实现高内聚低耦合，但是出发的角度不一样，单一职责是从自身提供的功能出发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归。","like_count":353,"discussions":[{"author":{"id":1358609,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bb/11/7069b8eb.jpg","nickname":"炫炫","note":"","ucode":"FDC7A0C6E08B02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":267850,"discussion_content":"不与陌生人说话","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1589700650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178715,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fc/5b/4b92d745.jpg","nickname":"命中水","note":"","ucode":"2D4431A9CC67EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320882,"discussion_content":"高手说话就是简单明了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604497456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","nickname":"布拉姆","note":"","ucode":"479FF27D73BCAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383029,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625835338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2153325,"avatar":"","nickname":"Geek_9dc8d3","note":"","ucode":"4C8D3E307CE866","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303546,"discussion_content":"学到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599294566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155275,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","nickname":"张三丰","note":"","ucode":"3A6215A40B3B21","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209208,"discussion_content":"透彻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584619593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165382,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1577232524,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"916405266572","product_id":100039001,"comment_content":"1.单一职责原则\t<br>适用对象:模块，类，接口 <br>侧重点:高内聚，低耦合\t<br>思考角度:自身<br><br>2.接口隔离原则<br>适用对象:接口，函数\t<br>侧重点:低耦合\t<br>思考角度:调用者<br><br>3.基于接口而非实现编程 <br>适用对象:接口，抽象类\t<br>侧重点:低耦合 <br>思考角度:调用者<br><br>4.迪米特法则\t<br>适用对象:模块，类\t<br>侧重点:低耦合\t<br>思考角度:类关系","like_count":214,"discussions":[{"author":{"id":1625233,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","nickname":"CoderArthur","note":"","ucode":"5B591914F0F67C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348984,"discussion_content":"1.单一职责原则\n适用对象: 模块，类，接口\n白话：职责太多，容易被依赖（高耦合），以后维护，容易牵一发而动全身。（易维护性）\n\n2.接口隔离原则\n适用对象:接口，函数\n白话：有些是不需要让你知道的，避免调用者需要了解的太多（最小知识原则）。有些是不能让你知道的，属于权限问题，需要隔离开来。\n\n3.基于接口而非实现编程\n适用对象: 接口，抽象类\n白话：易维护和可扩展性问题。业务不稳定，于是依赖相对稳定的接口。\n\n4.迪米特法则\n适用对象:模块，类\n白话：这个只是原则，不是说从谁的角度考虑吧。只要符合这个原则，就能做到高内聚、低耦合。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1612834235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1731543,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6b/d7/8872624a.jpg","nickname":"xmeng","note":"","ucode":"C0CA2182BA3B4B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282665,"discussion_content":"简单、明了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592041055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587173,"discussion_content":"稳","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662867087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2829494,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/2c/b6/61b1d6be.jpg","nickname":"阿卡","note":"","ucode":"04F3C90DF51A5D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585260,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661424443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2843250,"avatar":"","nickname":"张华","note":"","ucode":"0C92864C8BB705","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535686,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638517070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066102,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/76/a86cfd2a.jpg","nickname":"Akira","note":"","ucode":"A0BFD54A95012D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530612,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637112387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2611236,"avatar":"https://static001.geekbang.org/account/avatar/00/27/d8/24/5238947d.jpg","nickname":"烟酒店老板","note":"","ucode":"A632F085299CDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384373,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626530211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1163504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","nickname":"Jiantao","note":"","ucode":"444580EC5EF109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370927,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619581198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1723580,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/4c/bc/d9ef313e.jpg","nickname":"。","note":"","ucode":"BFEF2648FE8A85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347278,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612186105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043293,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/5d/2467ad6c.jpg","nickname":"木心","note":"","ucode":"538A3B9B214BF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335835,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608347805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005574,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/06/6a9c089b.jpg","nickname":"Lee大树","note":"","ucode":"3C2012F6D21698","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328810,"discussion_content":"精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606230555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164635,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1577063527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"242095232103","product_id":100039001,"comment_content":"“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，它们之间的区别和联系吗？<br>区别:<br>高内聚、松耦合:是一个重要的设计思想,能够有效地提高代码的可读性和可维护性,缩小功能改动导致的代码改动范围.<br>单一职责原则:A class or module should have a single reponsibility.提供的功能上要单一.<br>接口隔离原则:Clients should not be forced to depend upon interfaces that they do not use.与外部关系上只依赖需要的抽象.<br>基于接口而非实现编程:Program to an interface, not an implementation.是一条比较抽象、泛化的设计思想,为了提高代码的灵活性&#47;扩展性&#47;可维护性.<br>迪米特法则:Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.每个单元只该依赖与它关系密切的单元,最少知道,只与关系密切的单一交互.<br>联系:<br>职责越单一越容易做到接口隔离,也越容易做到最少知道的迪米特法则.<br>基于抽象编程抽象的知识越顶层越脱离具体实现,相对知道的内容就越少,也容易实现迪米特法则.<br>接口隔离原则与迪米特法则都强调只依赖需要的部分,接口隔离原则是相对偏上层来说的,迪米特法则是相对偏具体实现来说的.<br>单一职责原则&#47;接口隔离原则&#47;基于接口而非实现编程&#47;迪米特法则都以实现代码的&quot;高内聚、松耦合&quot;为目的,提高代码的可读性和可维护性,缩小功能改动导致的代码改动范围,降低风险.","like_count":57},{"had_liked":false,"id":164646,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1577065034,"is_pvip":true,"discussion_count":24,"race_medal":0,"score":"173375756874","product_id":100039001,"comment_content":"关于LoD，请记住一条：方法中不要使用ChainMethods。<br><br>坏的实践：<br>Amount = customer.orders().last().totals().amount()<br>和<br>orders = customer.orders()<br>lastOders = orders.last()<br>totals = lastOders.totals()<br>amount = totals.amount()<br><br>上面的例子中，chain中的方法改变会影响很多地方。这里注意区别建造者模式和pipeline管道，这两种的chain中的方法不易改变。<br><br>出现这样的代码，需要考虑可能是设计或实现出了问题。<br><br>LoD如何使用：<br>一个类C中的方法只能调用：<br>1、C中其他实例方法<br>2、它自己的参数方法<br>3、它创建对象的方法<br>4、不要调用全局变量（包括可变对象、可变单例）<br>例如：<br>class HtmlDownloader{<br>  Html html;<br>  public void downloadHtml(Transporter trans, String url){<br>    if(checkUrl(url)){&#47;&#47; ok 自己的实例方法<br>      &#47;&#47; return<br>    }<br>    rawData = trans.send(uri);&#47;&#47; ok 参数对象的方法<br>    Html html = createHtml(rawData); &#47;&#47; ok 它创建的对象<br>    html.save();&#47;&#47; ok  它创建对象的方法<br>  )<br>  private boolean checkUrl(String url){<br>    &#47;&#47; check<br>  }<br>}<br><br>参考：<br>The Pragmatic Programmer 1st edition and 2nd edition<br>","like_count":40,"discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309445,"discussion_content":"对于 Method Chaining，我没有看明白为什么说是一种“坏的实践”，我看了所有的评论，包括 StackOverflow 上的讨论，我觉的 Method Chaining 更像是一种语法糖，一般的说法是可以增加代码的可读性，但是会降低代码的可调试性。另外，好像主要的质疑是对于 “.” 这个符号的误用。\n\nAmount = customer.orders().last().totals().amount()\n\n这个代码很像是 Ruby on Rails 里面的，我觉的如果几个方法都已经有单元测试，那么 Method Chaining 也没有什么特别不合适的地方。\n\n请指教","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601291598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032257,"avatar":"http://thirdwx.qlogo.cn/mmopen/PiajxSqBRaELOTE1EpAicIdCsQfKa1oERdBk9a5Kcu84l9ibcng1lJ0Nd7ZlMmMXgiasc5xibvdejcDMHQQhSfcHpajZ7ny9ZNHjLJh77I2UOlkI/132","nickname":"柏丞","note":"","ucode":"5F46104C7316DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361431,"discussion_content":"方法链自己调用自己的方法，个人觉得没啥问题，不会扩散，比如builder模型。但如果引入其他对象就挺混乱了，不够内聚，不喜欢遇到这样的代码。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616669258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338088,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/e8/4bb87c34.jpg","nickname":"月马穿关","note":"","ucode":"2CE20CA1EB827D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177165,"discussion_content":"辣么大大 有blog吗 我去关注","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582082854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1533352,"avatar":"https://static001.geekbang.org/account/avatar/00/17/65/a8/6431f8b0.jpg","nickname":"Kang","note":"","ucode":"6FD3642D6455AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305428,"discussion_content":"代码整洁之道里面提到火车失事就是这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599920567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136352,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/e0/91e485b9.jpg","nickname":"弋言","note":"","ucode":"507418B211EC07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289938,"discussion_content":"每次看完第一件事就是来看你的评论😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594276017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1136352,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/e0/91e485b9.jpg","nickname":"弋言","note":"","ucode":"507418B211EC07","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290011,"discussion_content":"我要努力留言🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594301571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":289938,"ip_address":""},"score":290011,"extra":""}]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":106102,"discussion_content":"这次来晚了，还好晚的不多。你这些参考资源的源头是？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577513726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":106199,"discussion_content":"加油！一起跟上进度。像这门课我会找一本“骨架”书，例如大话设计模式，一些概念我能随时翻。争哥专栏里讲的一些内容，我不熟悉的我去google找源头，看一些英文的技术博客，可能一个点要看好几篇文章，例如搜LoD best practice之类的。你也看Medium吧，上面的文章质量很高。我搜索的一些结果都指向了那里。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1577521316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":106102,"ip_address":""},"score":106199,"extra":""},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":106824,"discussion_content":"哈，明白了。我学习力还不够，找的资源不多，努力起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577544279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":106199,"ip_address":""},"score":106824,"extra":""}]},{"author":{"id":1003992,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/51/d8/71ef5aa1.jpg","nickname":"ChenJz","note":"","ucode":"AF2F8D9015BE5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":103946,"discussion_content":"明白你的意思。你举的那个反例，我还是想不到什么办法去优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577407694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100220,"discussion_content":"（我还没读您提到的这本书：The Pragmatic Programmer）另外还有一点， 4、不要调用全局变量（包括可变对象、可变单例）  -- 这个点不能理解。如果不要调用全局变量，那我们是不是就不要定义他了？如果我们可以定义但不能用，那又该如何理解和使用呢？多谢啦！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577242956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100280,"discussion_content":"可以这样理解：\n首先，全局变量（data可以理解成对象）在程序各处都能被调用，会造成了耦合。\n其次，如果它是可变对象，就很危险。因为你可能不知道谁（程序哪里或者其他同事）改了这个对象，例如一个极端的列子：\npublic static final String[] IPs = new String[] {&#34;xxx&#34;,&#34;xxx&#34;};\nIPs看似是不可变的，但数组的内容是可变的，我可以重新赋值IPs[0] = &#34;123&#34;。\n最后，测试时，你需要初始化这个全局对象，才可以测试用到这个全局对象的方法，增加了测试难度。\n举了三点，当然还有其他的问题。全局变量的定义要扩展成全局对象（封装后）也不建议使用。\n\n\n\n\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577246877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100220,"ip_address":""},"score":100280,"extra":""},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":100348,"discussion_content":"谢谢回复。您的例子我能理解，但不排除有些情况是我们希望全局对象被改变的。比如IPs的数组他的初始值是一个默认可用服务器的地址，当发生某些事件之后，IPs中的某些元素会被更新成从数据库中取出来的（或其他某个耗时操作之后得到的）最新可用的服务器地址。这种情况是不是用全局对象就比较合适？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577252499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100280,"ip_address":""},"score":100348,"extra":""},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100417,"discussion_content":"就别说“您”了 😂。我觉得如果有足够好的理由使用，那么就用它！尽信书不如无书。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577258497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100348,"ip_address":""},"score":100417,"extra":""}]},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100217,"discussion_content":"你好辣么大，关注已久。 此处请教一个问题， 关于chain method. 假设现在我有一个订单类，在用户尚未付款来查看订单详情的时候，除了订单当中购买的商品信息，比如List<Product>. 之外，我还需要显示这个订单一次性付款是多少钱（order.payinfull.totalPrice）， 各种分期付款的方式各是多少钱（order.installments.get(index).totalPrice）. 请问这种情况您有什么建议来改进吗？ 谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577242853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":100426,"discussion_content":"具体业务我不是很了解，并且水平有限，担心会给出错误的建议。如果说错了，请见谅。我们试着这么考虑，这种表示以后会不会改变。我的意思是有没有些产品不能分期付款？可不可以信用卡付款？信用卡有没有手续费？分期付款的期限如何（3，6，9，12月）？商品会不会打折？打折后的总额怎么算？会不会有促销或者满减？优惠券能不能和满减组合使用？积分能不能换💰？换钱后总额怎么算？ 如果以后这些业务场景出现代码的修改范围会有多大？会不会跨团队？如果实现的内聚程度高，修改时会不会容易些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577259222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100217,"ip_address":""},"score":100426,"extra":""},{"author":{"id":1238221,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","nickname":"Rain","note":"","ucode":"6A270D922A3B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":100434,"discussion_content":"谢谢回复，我懂你的意思啦！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577259988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":100426,"ip_address":""},"score":100434,"extra":""}]},{"author":{"id":1197925,"avatar":"https://static001.geekbang.org/account/avatar/00/12/47/65/cce8eb34.jpg","nickname":"nimil","note":"","ucode":"19933068972746","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98900,"discussion_content":"这个定义是不是和lamda表达式类似","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577190444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98154,"discussion_content":"再感受一下这样的风格：List<File> files = Arrays.stream(dir.listFiles()).filter(x -> x.getName().endsWith(&#34;jpg&#34;))\n          .sorted((x,y)->Long.compare(y.lastModified(), x.lastModified())\n          ).collect(Collectors.toList());","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577147721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1750703,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/af/9347b9ac.jpg","nickname":"Liam","note":"","ucode":"EC9DAD04D8B6CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":306673,"discussion_content":"我感觉这样挺好理解的！过滤 排序 转成集合！不知道问题出在哪里？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600345038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":98154,"ip_address":""},"score":306673,"extra":""}]},{"author":{"id":1443663,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","nickname":"陈迎春","note":"","ucode":"2870BA6D6E5B1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96637,"discussion_content":"请教下ChinaMethods是什么意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577082714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1443663,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","nickname":"陈迎春","note":"","ucode":"2870BA6D6E5B1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96647,"discussion_content":" 方法链，简单的理解就是 a.f1().f2().f3()... 这种方式。stackoverflow有相关的讨论：https://stackoverflow.com/questions/1103985/method-chaining-why-is-it-a-good-practice-or-not","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577083470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96637,"ip_address":""},"score":96647,"extra":""},{"author":{"id":1443663,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIang00R9vkklnkFCLhzRysNfocr0sLnCdoZwOT3UkulAPefk5BDvd0PfIeQSODSQg1DjKWUmJOaA/132","nickname":"陈迎春","note":"","ucode":"2870BA6D6E5B1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":98024,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577116868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96647,"ip_address":""},"score":98024,"extra":""},{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":279710,"discussion_content":"这个帖子好精彩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591402768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":96647,"ip_address":""},"score":279710,"extra":""}]}]},{"had_liked":false,"id":180012,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1582165263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"66006674703","product_id":100039001,"comment_content":"看一遍，真的不行，每次看都有新收获！","like_count":15},{"had_liked":false,"id":164924,"user_name":"LiuHu","can_delete":false,"product_type":"c1","uid":1039768,"ip_address":"","ucode":"284E2025C554BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/98/883c42b4.jpg","comment_is_top":false,"comment_ctime":1577112612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61706654756","product_id":100039001,"comment_content":"“高内聚、松耦合” 是衡量好代码的标准之一，为了实现这样的目标，我们需要遵循如下原则：<br>“基于接口而非实现编程”，接口本身就是一层抽象，接口是稳定的，实现是易变的，强调的是基于契约编程，这样能够隔离变化。实现细节代码的变化，不影依赖该接口的对象，到从而达到松耦合的目的。<br>“迪米特法则”，定义的是发布的接口（类、模块等）能不能依赖，如何依赖的问题。使用者去除不必要的依赖，只依赖必要的接口。这样即使接口一旦发生变化，需要了解这一变化的类就会比较少，达到松耦合的目的。<br>“接口隔离原则”，从使用者的角度考虑如何设计接口，让使用者只依赖必要的接口，不会被迫依赖不用的接口。这样即使接口一旦发生变化，需要了解这一变化的类就会比较少，这样就能符合 “迪米特法则” 。<br>“单一职责原则”，针对模块、类、接口的设计，将功能相关性很强的代码抽取到一起，达到高内聚的目标。","like_count":14},{"had_liked":false,"id":261753,"user_name":"王大喵","can_delete":false,"product_type":"c1","uid":1109528,"ip_address":"","ucode":"C14AAE3ED964DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","comment_is_top":false,"comment_ctime":1605513668,"is_pvip":false,"replies":[{"id":"96134","content":"������","user_name":"作者回复","comment_id":261753,"uid":"1190123","ip_address":"","utype":1,"ctime":1606701264,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"35965252036","product_id":100039001,"comment_content":"联系：<br>“接口隔离原则”是客户端不应该被强迫依赖不需要的接口，和“迪米特法则”中的有限知识异曲同工，接口簇会更加“单一职责”实现方式“基于接口而非实现编程”，达到的目的是高内聚，松耦合。<br><br>区别：<br>1. 各种原则最终的目的是为了实现“高内聚、松耦合”。<br>2. 单一职责原则 主要是指导类和模块，避免大而全，提高内聚性。<br>3. 接口隔离和迪米特(最小知识)主要指导“松耦合”，解耦使用方的依赖。<br>4. 基于接口而非实现编程：主要是解耦接口和实现，是指导思想，提高扩展性。","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509595,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012371,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/72/93/46895883.jpg","nickname":"terryking","note":"","ucode":"39433F06D6BEF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559132,"discussion_content":"这个总结很到位，不过各种原则都是用来解决指导开闭原则实施的;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648620392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164911,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1577110263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31641881335","product_id":100039001,"comment_content":"课后讨论：代码的最终目的是高内聚、松耦合的。而为了达到这个目的，就需要利用到迪米特法则。而迪米特法则的实现，又需要利用单一职责将单个类定义职责单一化，并且为了解决多个类之间的关系，又需要用到基于接口编程而非实现编程。这样类与类之间就相当于契约化，也就是不关心类的具体实现。","like_count":7},{"had_liked":false,"id":246653,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1599446710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14484348598","product_id":100039001,"comment_content":"一不小心就能用到一个牛逼的原则，如果没有这些归纳总结的话，永远都不知道自己究竟有多牛逼。<br>是不是觉得迪米特法则和之前的原则很像，当然很像了，毕竟他们都是为了实现“高内聚，低耦合”。<br>【单一职责原则】是从自身功能出发，实现高内聚，低耦合<br>【接口隔离原则】和【基于接口而非实现编程】是从调用者出发，实现低耦合<br>【迪米特法则 】是从关系出发，实现低耦合","like_count":3},{"had_liked":false,"id":232758,"user_name":"HYH","can_delete":false,"product_type":"c1","uid":1103960,"ip_address":"","ucode":"F2A339CC9AC594","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/58/1f5f7aed.jpg","comment_is_top":false,"comment_ctime":1594110391,"is_pvip":false,"replies":[{"id":"85963","content":"你的设计也可以的。设计本身没有最优解，合理、能自圆其说就可以了。总体上来讲，我这个例子是为了展示尽量减少类之间的耦合。","user_name":"作者回复","comment_id":232758,"uid":"1190123","ip_address":"","utype":1,"ctime":1594174033,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"14479012279","product_id":100039001,"comment_content":"老师您好，请问一下Document的修改为什么会使用到Factory的方式去产生？我对这一步的修改没有很大的感受，我这里的认知是Document只是单纯对文件的操作，那是不是可以透过HtmlDownloader实现相关取得文件的接口，像是IDownloader之类的名称，并直接回传Document这个类(亦或者对此类做其它的延伸)，未来也可以实现其它像是json等其他格式的downloader，不知道我这个想法是不是可行？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500763,"discussion_content":"你的设计也可以的。设计本身没有最优解，合理、能自圆其说就可以了。总体上来讲，我这个例子是为了展示尽量减少类之间的耦合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594174033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":536974,"discussion_content":"但是你前面说了，发送请求，send方法，都可能其他方式，那下载器也不应该依赖具体实现，应该是接口，极有可能多种下载方式吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638925406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":500763,"ip_address":""},"score":536974,"extra":""}]}]},{"had_liked":false,"id":166602,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1577514850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14462416738","product_id":100039001,"comment_content":"高内聚-低耦合<br>单一职责-自身功能出发<br>迪米特法则  类与类之间关系<br>接口而非实现编程-依赖必要的抽象","like_count":3},{"had_liked":false,"id":166137,"user_name":"戒惜舍得","can_delete":false,"product_type":"c1","uid":1454225,"ip_address":"","ucode":"694FE967317710","user_header":"https://static001.geekbang.org/account/avatar/00/16/30/91/5f770e29.jpg","comment_is_top":false,"comment_ctime":1577408625,"is_pvip":false,"replies":[{"id":"64837","content":"咋这么能抬杠呢 你说我问你怎么相近 你能回答上来吗 这个也没法量化 设计模式不是算法 什么都能定量 更多的是教你思想 你自己去感受","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1577666842,"ip_address":"","comment_id":166137,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14462310513","product_id":100039001,"comment_content":"相近的功能。 怎么算相近啊。学晕了。","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479413,"discussion_content":"咋这么能抬杠呢 你说我问你怎么相近 你能回答上来吗 这个也没法量化 设计模式不是算法 什么都能定量 更多的是教你思想 你自己去感受","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577666842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2715388,"avatar":"","nickname":"Geek8535","note":"","ucode":"D1919541632C95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537355,"discussion_content":"如果是2个妹子你肯定秒知道如何知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639041607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165221,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1577182858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14462084746","product_id":100039001,"comment_content":"老师讲的真棒👍","like_count":3},{"had_liked":false,"id":164738,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1577084858,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14461986746","product_id":100039001,"comment_content":"如果说高内聚、松耦合等价于&quot;中国特色社会主义&quot;, 那么“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”这几个原则就像是在说如何才能做到做到这样的社会?  答案就是我们要&quot;倡导富强、民主、文明、和谐, 自由、平等、公正、法治，爱国、敬业、诚信、友善&quot;","like_count":3,"discussions":[{"author":{"id":1992059,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/65/7b/058d17f3.jpg","nickname":"耶low","note":"","ucode":"4CCEB741583544","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394201,"discussion_content":"你这部级起步吧😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631782442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259775,"user_name":"Geek_809561","can_delete":false,"product_type":"c1","uid":2037722,"ip_address":"","ucode":"94FA67AEFB6CA0","user_header":"","comment_is_top":false,"comment_ctime":1604830288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10194764880","product_id":100039001,"comment_content":"单一职责原则：模块,类，方法等功能要单一。功能越单一的类，对外部依赖越少。高内聚。<br><br>接口隔离原则： 调用者调用被调用者的方法或功能的时候，这个方法或者功能的粒度要小，职责要单一。高内聚<br><br>单一职责和接口隔离的区别是：一个是偏向于整体的（类，模块，接口的）设计，而接口隔离知识对接口的设计。相同点都是要求单一职责，高内聚。<br><br>基于接口而非实现编程：将接口和实现分离。调用者只需要知道被调用者抽象出来的方法或功能，并不需要知道具体的细节是怎么执行的。降低了调用者和被调用者之间的耦合度。更偏向于整体的抽象思想。<br>接口隔离与基于接口而非实现编程：一个是对具体接口的要求，（单一），一个是要求将具体的行为和功能抽象化，为后续被调用的整体替换做准备。<br>迪米特法则：又叫做最少知识法则，降低调用者与被调用者之间的耦合度。调用者只关于自己必须知道的知识（没有就实现不了的）。","like_count":2},{"had_liked":false,"id":216870,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1589358218,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10179292810","product_id":100039001,"comment_content":"感觉NetworkTransporter这个例子举的不好... <br>本身获取HTML确实可以通过通过HtmlRequest, 现在非得把他拆成一个地址和content, 那么地址和content分别传入什么呢? 这样做HtmlRequest这个类就没有存在的意义了.<br>下面document例子我比较认可. 确实document类只要把html字符串传进来即可, 至于谁去加载字符串这个不归他管","like_count":2,"discussions":[{"author":{"id":1316758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","nickname":"Richard","note":"","ucode":"893F958B9DD161","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345263,"discussion_content":"我也跟你有同感，有点强制通用的意思，其实从场景出发这里就是解析HTML，我看应该把NetworkTranspoter改成HtmlRequestTranspoter，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611708131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1483671,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a3/97/ca8057a4.jpg","nickname":"Mona432","note":"","ucode":"3F02C646C8DC83","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310641,"discussion_content":"就是实现NetworkTransporter与HtmlRequest的解耦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601966652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202829,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586074833,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"10176009425","product_id":100039001,"comment_content":"对LOD迪米特法则的形象理解：不要探究朋友的隐私，要与陌生人保持距离。😂","like_count":2},{"had_liked":false,"id":166172,"user_name":"ismind","can_delete":false,"product_type":"c1","uid":1138710,"ip_address":"","ucode":"7AADD673ED3BC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/16/d1dd4972.jpg","comment_is_top":false,"comment_ctime":1577410897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167345489","product_id":100039001,"comment_content":"前几天没抽出时间，今天补上。<br>1，感觉还是要做笔记，现在才知道要做一下笔记，不然前面学的基本上只是留个大概的印象，效率低<br>2，感觉开始有难度了，综合性更高了，开始加速了么？哈哈<br>课后思考：<br>1，这五个原则与思想，联系就是：都是为了提高代码的可读性、扩展性、灵活性等，这也是这些原则产生的原因之一，我觉得应该把握这个主要的目的，再去应用这些原则或者设计模式，否则单纯为了使用这些原则，那很可能适得其反，我又想起那句话：“不忘初心方得始终”，学习设计模式也要这样吧。<br>老师的代码实战二，简单的序列化使用LOD原则，感觉过度设计了，不过一看后面功能变复杂了，觉得设计才合理。<br>2，区别：应该是关注点不同吧，“高内聚、低耦合”关注的是类，也就是考虑类与类之间的关系；单一职责则是关注前几天没抽出时间，今天补上。<br>1，感觉还是要做笔记，现在才知道要做一下笔记，不然前面学的基本上只是留个大概的印象，效率低<br>2，感觉开始有难度了，综合性更高了，开始加速了么？哈哈<br>课后思考：<br>1，这五个原则与思想，联系就是：都是为了提高代码的可读性、扩展性、灵活性等，这也是这些原则产生的原因之一，我觉得应该把握这个主要的目的，再去应用这些原则或者设计模式，否则单纯为了使用这些原则，那很可能适得其反，我又想起那句话：“不忘初心方得始终”，学习设计模式也要这样吧。<br>老师的代码实战二，简单的序列化使用LOD原则，感觉过度设计了，不过一看后面功能变复杂了，觉得设计才合理。<br>2，区别：应该是关注点不同吧，“高内聚、低耦合”关注的是类，也就是考虑类与类之间的关系；单一职责则是关注某一个类或者函数的功能是否单一；接口隔离则关注不要依赖不需要的接口；基于接口而非实现编程就考虑将实现替换为接口。<br>自己感觉这些还没有彻底理解，只是大概知道，感觉离掌握与熟悉还有一段距离。","like_count":2},{"had_liked":false,"id":164599,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1577058194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166992786","product_id":100039001,"comment_content":"打卡<br>所有的设计原则都相辅相成","like_count":2},{"had_liked":false,"id":322984,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637679287,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5932646583","product_id":100039001,"comment_content":"高内聚，低耦合就是分门别类别掺和。 迪米特法则就是别和陌生人说话，只和熟人说话。调用过程中应该尽量解耦，尽量考虑使用。参考rule of three","like_count":1},{"had_liked":false,"id":276160,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1611818066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5906785362","product_id":100039001,"comment_content":"1.单一职责原则<br>适用对象:模块，类，接口<br>侧重点:高内聚，低耦合<br>思考角度:自身<br><br>2.接口隔离原则<br>适用对象:接口，函数<br>侧重点:低耦合<br>思考角度:调用者<br><br>3.基于接口而非实现编程<br>适用对象:接口，抽象类<br>侧重点:低耦合<br>思考角度:调用者<br><br>4.迪米特法则<br>适用对象:模块，类<br>侧重点:低耦合<br>思考角度:类关系","like_count":1},{"had_liked":false,"id":193437,"user_name":"@%初%@","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1584892751,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5879860047","product_id":100039001,"comment_content":"感觉上面的代码还是有问题：<br>1. document就是一个纯粹的文档基类，为什么要依赖html，那么asp，jsp的网页不能解析？？？<br>","like_count":1,"discussions":[{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264914,"discussion_content":"对, 所以要看细粒度..不是全部代码都不能有多余的依赖关系, 太追求细节的话, 写出来的代码太复杂了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589357960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187718,"user_name":"Buring","can_delete":false,"product_type":"c1","uid":1651664,"ip_address":"","ucode":"0AAEA64C63C2F6","user_header":"https://static001.geekbang.org/account/avatar/00/19/33/d0/962ebe2e.jpg","comment_is_top":false,"comment_ctime":1584198555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879165851","product_id":100039001,"comment_content":"我的理解就是：<br>高内聚、低耦合：他强调的是不同的方法、类、模块之间的关系网的问题，是以一个上帝视角来观察的<br>单一职责原则：他强调的是某一个具体方法或者类或者模块，他们主要关注自己本身的实现代码是否相对独立，从而不会“自作多情”的把别人做的事再做一遍<br>接口隔离原则：在单一职责的基础之上，在给调用者提供api接口时，能让调用者很清晰的知道当前所依赖的接口有哪些接口，好比序列化的调用者只想要看到序列化接口，而不希望反序列化的接口也暴露<br>迪米特法则：在争哥总结的迪米特里，前者(尽量不依赖)，我觉得在真实业务系统还是很难做到的，因为业务错综复杂，所有的接口都可能被很多地方引用到，但是对于第二点(只依赖必要的接口)，很多时候还是可以尽量满足的，它其实就是接口隔离原则的体现<br>基于接口而非实现：基于接口而非实现，是上面所有原则的基石！","like_count":1},{"had_liked":false,"id":173116,"user_name":"Treasure","can_delete":false,"product_type":"c1","uid":1177602,"ip_address":"","ucode":"4211ECEB347C3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","comment_is_top":false,"comment_ctime":1579426766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874394062","product_id":100039001,"comment_content":"单一职责原则：一个类，只有一个引起它变化的原因。<br>接口隔离原则：不应该强迫用户依赖它们不需要的方法。（调用者）<br>迪米特法则   ：强调类之间的关系，依赖应该最小花。（模块&#47;类 的依赖关系）<br>基于接口编程而非实现编程：通用原则，一个比较笼统的思想。<br>都是为了实现高内聚，低耦合。","like_count":1},{"had_liked":false,"id":164865,"user_name":"blacknhole","can_delete":false,"product_type":"c1","uid":1098286,"ip_address":"","ucode":"271682FFE28F25","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","comment_is_top":false,"comment_ctime":1577102675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872069971","product_id":100039001,"comment_content":"对耦合的含义或理解方式有些不同看法：<br><br>1，与其从依赖关系来谈松耦合，说它是依赖关系简单清晰，不如从功能的相关性来谈，说它是无关功能不放在一个类中。这时，高内聚的含义就只是相关或相近功能放在一个类中了。<br><br>类之间的依赖关系，在类的设计完成之后，是无法选择和改变的，除非重新设计类。比如，类之间应该依赖时，在不改变类的设计的前提下，无法刻意不依赖或减少依赖。依赖关系简单清晰，只是在对高内聚和松耦合的适度追求之下，设计并实现类之后，自然产生的一个结果。<br><br>2，高内聚和松耦合，都是用来指导类本身的设计的。并非用松耦合来指导类之间依赖关系的设计。换句话说，类之间依赖关系的设计应该包含在类本身的设计之中（事实上，只有类的设计，而不存在什么类之间依赖关系的设计，见下文）。<br><br>在设计一个类时，应该考虑它与其他类的关系，以达到这个类的适度内聚和耦合。在这里，内聚是从功能相关的角度来观察类——有关的功能是不是放在一起了，耦合是从功能无关的相反角度来观察类——无关的功能是不是分散开来了。<br><br>依赖关系是类的设计完成之后，对类之间相关性的描述，有关就叫有依赖关系，无关就叫无依赖关系。所以，并不存在什么对依赖关系的设计，依赖关系是类的设计完成之后的一个自然结果。<br><br>3，这样的理解，对类的设计来说才是更有指导意义的，也才能使概念的边界足够清晰，从而使内聚与耦合的本质更易被准确理解。","like_count":1},{"had_liked":false,"id":164650,"user_name":"逆风星痕","can_delete":false,"product_type":"c1","uid":1420482,"ip_address":"","ucode":"1E18E46E8DA58E","user_header":"https://static001.geekbang.org/account/avatar/00/15/ac/c2/aec60ae2.jpg","comment_is_top":false,"comment_ctime":1577065796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872033092","product_id":100039001,"comment_content":"感觉所有设计原则和模式，都是为了代码的可读性，复用和扩展而总结出来的。好多原则可能是针对某个场景下提高代码的复用和扩展，这样有时也会辅助其他原则。迪米特原则描述类之间的关系，尽量减少依赖，但也需要类遵循单一职责原则。设计代码的时候，可以根据自己的目的，从参考相应原则的设计","like_count":1},{"had_liked":false,"id":164619,"user_name":"再见孙悟空","can_delete":false,"product_type":"c1","uid":1025518,"ip_address":"","ucode":"57E12A2F9CD915","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/ee/6bbac848.jpg","comment_is_top":false,"comment_ctime":1577061566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872028862","product_id":100039001,"comment_content":"“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”都是为了实现 “高内聚、低耦合”的手段。做到了接口隔离，一般情况下职责也比较单一，基于接口而非实现编程，往往也会降低耦合性。有的时候使用了迪米特法则或者单一职责原则，可能会破坏高内聚原则，这种情况就要具体分析场景，以及使用接口来实现。","like_count":1},{"had_liked":false,"id":164605,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1577058998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872026294","product_id":100039001,"comment_content":"接口隔离感觉就是为了迪米特法则的应用，接口隔离开不需要依赖的类，只引入需要的接口和方法。<br><br>高内聚低耦合，是针对具体的实现类的，实现类实现多个接口，相似的功能都在同一个实现类中完成。<br><br>接口的隔离又保证对外只暴露了调用方需要的方法，外部也不能直接看到不需要的方法。代码结构也更加整洁，逻辑更清晰","like_count":1},{"had_liked":false,"id":358122,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"浙江","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1663921062,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663921062","product_id":100039001,"comment_content":"单一职责原则：一个类只实现一个业务逻辑，不同业务放到不同类<br>基于接口而非实现编程：类之间的依赖，以依赖接口为主，那实现有变动的时候，扩展性好<br>接口隔离原则：不同功能用不同的接口（实现），不要放到一个接口。有点类似单一职责原则<br>高内聚，松耦合：减少不能功能类之间的依赖，这点需要基于接口而非实现原则，而且依赖的越少越好；尽量保持一个类的独立性，这点类似于单一职责原则<br>迪米特法则：有点类似于松耦合，就是类之间尽量不依赖，如果有依赖，也是依赖最小实现","like_count":0},{"had_liked":false,"id":357443,"user_name":"Leo.","can_delete":false,"product_type":"c1","uid":2365468,"ip_address":"广东","ucode":"C876295B3ACCF2","user_header":"https://static001.geekbang.org/account/avatar/00/24/18/1c/70b34d04.jpg","comment_is_top":false,"comment_ctime":1663255878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663255878","product_id":100039001,"comment_content":"定义（自己的理解）：<br>● 高内聚、低耦合：将相似功能的代码（关系紧密）放到同一个类中，使得类的依赖结构清晰，被依赖的类修改不会导致依赖类大幅度改动。<br>● 单一职责原则：一个类或一个模块只负责完成一个功能（职责）<br>● 接口隔离原则：将一组功能拆分，隔离开来，使得各个功能使用者只依赖自己需要的功能代码<br>● 基于接口而非实现编程：也叫基于抽象而非实现编程，使用者依赖抽象接口而非具体实现.，目的是为了提高代码的灵活性，通用性。包含一些设计接口，抽象类的具体建议：命名要足够抽象通用，不要包含具体实现；跟具体实现有关的方法不要定义在接口...<br>● 迪米特法则：不该依赖就不要依赖，能少依赖就少依赖。减少代码之间的耦合（知道得越少，要操心就越少），避免牵一发而动全身。<br><br>关系：<br>● 写出高内聚、低耦合的代码是最终目的。<br>● 适度地使用单一职责原则，使得一个类只负责完成一个职责，结果就是一个类中只包含相近功能的代码，不同功能的代码在不同的类（高内聚）。但如果过度拆分，会破坏代码的内聚性<br>● 接口隔离原则要求我们把一组功能拆分并隔离开来，使得功能使用者只依赖他们需要的部分，有助于我们达成低耦合的目的<br>● 基于接口而非实现编程，也叫基于抽象而非实现编程，是一种面向对象思想，要求我们有抽象意识，编码时，使用者依赖抽象接口而非具体实现，使得代码更灵活、通用。当修改具体实现时，由于使用方只依赖抽象接口而不依赖实现，因此使用方不需要感知具体实现的变化，符合低耦合的思想。同时也符合迪米特法则，使用方只依赖抽象接口，不知道具体实现，因此就不需要操心具体实现的变化<br>● 迪米特法则，要求我们不该依赖就不要依赖，能少依赖就少依赖，因为知道得越少，要操心的东西就越少，符合低耦合的思想。","like_count":0},{"had_liked":false,"id":351407,"user_name":"英雄","can_delete":false,"product_type":"c1","uid":1546612,"ip_address":"","ucode":"D1033C83C6CDE9","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/74/0203bf17.jpg","comment_is_top":false,"comment_ctime":1657771859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657771859","product_id":100039001,"comment_content":"HtmlDownloader是不是不符合依赖倒置原则，高层模块不依赖底层模块？","like_count":0},{"had_liked":false,"id":349300,"user_name":"Geek_02cc48","can_delete":false,"product_type":"c1","uid":3004321,"ip_address":"","ucode":"264B787809476D","user_header":"","comment_is_top":false,"comment_ctime":1655874587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655874587","product_id":100039001,"comment_content":"看不懂啊","like_count":0},{"had_liked":false,"id":343023,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1650598358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650598358","product_id":100039001,"comment_content":"讲得挺好的，高内聚，低耦合。一般做java的同学比较清楚吧","like_count":0},{"had_liked":false,"id":338230,"user_name":"Echo","can_delete":false,"product_type":"c1","uid":1878585,"ip_address":"","ucode":"1542D4B4154CA9","user_header":"","comment_is_top":false,"comment_ctime":1647363107,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647363107","product_id":100039001,"comment_content":"作为一个写js的前端，表示我太难了，java的例子基本上看不懂。","like_count":0},{"had_liked":false,"id":337367,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1646791819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646791819","product_id":100039001,"comment_content":"迪米特法则实现高内聚，松耦合。<br>单一职责原则有助于写出高内聚的代码。<br>接口隔离原则，基于接口而非实现编程，有助于代码的松耦合。","like_count":0},{"had_liked":false,"id":329106,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1641121927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641121927","product_id":100039001,"comment_content":"思考题：<br>“高内聚、松耦合”是写代码的一个总体指导思想，其他的原则都是实现这个思想的一些具体方法。<br>“单一职责原则”强调模块、类的功能要单一，不相关的功能不应该被纳入，这是实现高内聚的一种方式；<br>“接口隔离原则”用于指导接口设计，强调只设计被调用者调用的接口，与此无关的接口不应该被设计，它是单一职责原则的一种体现，并提供了判断接口职责是否单一的一种判断标准；<br>“迪米特法则”用于指导类之间的依赖关系设计，它强调类与类之间的依赖，应尽量只依赖必要的接口，没有直接依赖关系的类之间不应该出现依赖关系，它体现的是松耦合的设计思想，同时，迪米特法则也蕴含了“单一职责原则”和“接口隔离原则”这两类原则的设计思想。","like_count":0},{"had_liked":false,"id":328145,"user_name":"InHero","can_delete":false,"product_type":"c1","uid":2634637,"ip_address":"","ucode":"F1D09AA0EBABDF","user_header":"https://static001.geekbang.org/account/avatar/00/28/33/8d/767a13ec.jpg","comment_is_top":false,"comment_ctime":1640573822,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1640573822","product_id":100039001,"comment_content":"这个依赖有限关系接口的代码看的可以说是醍醐灌顶啊 ","like_count":0},{"had_liked":false,"id":325895,"user_name":"cloydlau","can_delete":false,"product_type":"c1","uid":1069785,"ip_address":"","ucode":"C21E29ABC754F2","user_header":"","comment_is_top":false,"comment_ctime":1639217685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639217685","product_id":100039001,"comment_content":"用 TS 实现了一下序列化那块的代码：<br><br>interface Serializable {<br>  serialize: (object: object) =&gt; string<br>}<br><br>interface Deserializable {<br>  deserialize: (text: string) =&gt; object<br>}<br><br>class Serialization implements Serializable, Deserializable {<br>  serialize (object: object): string {<br>    return JSON.stringify(object)<br>  }<br><br>  deserialize (text: string): object {<br>    return JSON.parse(text)<br>  }<br>}<br><br>class DemoClass1 {<br>  serializer: Serializable<br><br>  constructor (serializer: Serializable) {<br>    this.serializer = serializer<br>  }<br>}<br><br>class DemoClass2 {<br>  deserializer: Deserializable<br><br>  constructor (deserializer: Deserializable) {<br>    this.deserializer = deserializer<br>  }<br>}<br><br>const demoClass1 = new DemoClass1(new Serialization())<br>const demoClass2 = new DemoClass2(new Serialization())<br><br>console.log(demoClass1.serializer.serialize({}))<br>console.log(demoClass1.serializer.deserialize(&#39;{}&#39;)) &#47;&#47; TS2551: Property &#39;deserialize&#39; does not exist on type &#39;Serializable&#39;. <br><br>console.log(demoClass2.deserializer.deserialize(&#39;{}&#39;))<br>console.log(demoClass2.deserializer.serialize({})) &#47;&#47; TS2551: Property &#39;serialize&#39; does not exist on type &#39;Deserializable&#39;.","like_count":0},{"had_liked":false,"id":325325,"user_name":"天亮前说晚安","can_delete":false,"product_type":"c1","uid":1541014,"ip_address":"","ucode":"1D82EE562A7C71","user_header":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","comment_is_top":false,"comment_ctime":1638925281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638925281","product_id":100039001,"comment_content":"作者的第一个例子，最后的结果就不满足法则。改造后依然问题很大，Document对象可以认为是复杂对象，但是DocumentFactory不应该依赖HtmlDownloder，因为这是具体实现，非接口；第二前面讲到send方法都可能非HtmlRequest，那下载器也可能多个。应该抽离出Downloader接口，DocumentFactory依赖接口。","like_count":0},{"had_liked":false,"id":323708,"user_name":"HomeyLiu","can_delete":false,"product_type":"c1","uid":1330141,"ip_address":"","ucode":"EF4CCB92C369B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","comment_is_top":false,"comment_ctime":1638109340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638109340","product_id":100039001,"comment_content":"    public Byte[] send(String address, Byte[] data) {<br>      &#47;&#47;...<br>    }<br>address 是啥东西?Byte[] data又是啥东西,<br>不是下载网页吗?怎么像发送网页.","like_count":0},{"had_liked":false,"id":323073,"user_name":"二小","can_delete":false,"product_type":"c1","uid":1593919,"ip_address":"","ucode":"5377CB552237B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/3f/c8b40efe.jpg","comment_is_top":false,"comment_ctime":1637720080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637720080","product_id":100039001,"comment_content":"为什么拆分两个接口之后，修改序列化方式从JSON换成其他方式不是还要修改所有实现吗？","like_count":0},{"had_liked":false,"id":322482,"user_name":"米大王","can_delete":false,"product_type":"c1","uid":1097996,"ip_address":"","ucode":"6D6B644A528F9F","user_header":"https://static001.geekbang.org/account/avatar/00/10/c1/0c/8b83e19b.jpg","comment_is_top":false,"comment_ctime":1637410263,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637410263","product_id":100039001,"comment_content":"目的都是提高扩展性，高内聚、低耦合，只是手段（出发角度）不同：<br>1. 单一职责原则以及对扩展开放，对修改关闭原则是从功能的角度出发；<br>2. 迪米特原则从类之间的关系出发（不该依赖的不依赖，要依赖的最小必要依赖）；<br>3. 接口隔离原则是从接口调用者的角度出发；<br>5. 里式替换原则是从类的继承关系角度出发。<br><br>提高代码可维护性、可读性的设计原则：<br>1. 控制反转<br>2. KISS、YAGNI<br>3. DRY<br><br>-----<br><br>&gt; 目的都是实现高内聚低耦合，但是出发的角度不一样，单一职责是从自身提供的功能出发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归。<br>","like_count":0},{"had_liked":false,"id":313571,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1632530019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632530019","product_id":100039001,"comment_content":"迪米特法则<br>高内聚，松耦合，主要主要针对类与类之间。功能类似的方法尽量放到一个类里面，没有关联的类不相互依赖，有关联的尽量用接口。","like_count":0},{"had_liked":false,"id":311905,"user_name":"manx00","can_delete":false,"product_type":"c1","uid":1014356,"ip_address":"","ucode":"CA086E73F179E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/54/497b1764.jpg","comment_is_top":false,"comment_ctime":1631527057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631527057","product_id":100039001,"comment_content":"“第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。”<br><br>这里说使用new违背了基于接口而非实现编程。那么HtmlDownloader.downloadHtml 里面的为啥没问题：new HtmlRequest(url);","like_count":0},{"had_liked":false,"id":298584,"user_name":"Labin","can_delete":false,"product_type":"c1","uid":2155890,"ip_address":"","ucode":"13659DF0F364C1","user_header":"https://static001.geekbang.org/account/avatar/00/20/e5/72/211a4768.jpg","comment_is_top":false,"comment_ctime":1624204845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624204845","product_id":100039001,"comment_content":"第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。<br><br>这里修改完之后，Document类不也是还依赖了HtmlDownloader吗？","like_count":0},{"had_liked":false,"id":296383,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1622948948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622948948","product_id":100039001,"comment_content":"“单一职责原则”、“接口隔离原则”、“基于接口而非实现编程”这些原则的目的其实就是，让代码“高内聚、松耦合”，方便对修改关闭，对扩展开放","like_count":0},{"had_liked":false,"id":292182,"user_name":"栾~龟虽寿！","can_delete":false,"product_type":"c1","uid":1504671,"ip_address":"","ucode":"219B38C08979FE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","comment_is_top":false,"comment_ctime":1620713906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620713906","product_id":100039001,"comment_content":"打卡，工厂模式，不会 ","like_count":0},{"had_liked":false,"id":290708,"user_name":"Dunk","can_delete":false,"product_type":"c1","uid":1691447,"ip_address":"","ucode":"A8F5AB98382719","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/37/6ed137b9.jpg","comment_is_top":false,"comment_ctime":1619695893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619695893","product_id":100039001,"comment_content":"1.高内聚，低耦合：强调类的设计上要保持功能单一，一定程度上与单一职责原则重复；类与类之间的关系应保持简单清晰。<br>2.单一职责原则：强调类、函数的设计上保持功能的彼此独立，减少相互重合。<br>3.接口隔离原则：接口的定义应当彼此分离，不要相互重合。","like_count":0},{"had_liked":false,"id":290240,"user_name":"学员203","can_delete":false,"product_type":"c1","uid":2559640,"ip_address":"","ucode":"63E4B7E3A7E140","user_header":"","comment_is_top":false,"comment_ctime":1619445081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619445081","product_id":100039001,"comment_content":"请问一下，工程创建文档时做了下载功能，又创建文档，这个对于工厂是不是不符合单一职责了？","like_count":0},{"had_liked":false,"id":281695,"user_name":"Emanon","can_delete":false,"product_type":"c1","uid":2430910,"ip_address":"","ucode":"B986F8BB226FB1","user_header":"https://static001.geekbang.org/account/avatar/00/25/17/be/d7d58b48.jpg","comment_is_top":false,"comment_ctime":1614849673,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1614849673","product_id":100039001,"comment_content":"感觉把序列化和反序列化隔离开来并不好。因为序列化和反序列化在逻辑实现是上高度耦合的。应该把它们放到一起来达到对内高内聚，对外低耦合的效果。","like_count":0,"discussions":[{"author":{"id":1012815,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/74/4f/7975c7ee.jpg","nickname":"胡敏And","note":"","ucode":"8FA14B27F47F92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377228,"discussion_content":"这样就很难达到最小知识了吧，拆分成两个接口更加合适，一个类去实现这两个接口，也算是做到了内聚吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622554816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280436,"user_name":"Amber","can_delete":false,"product_type":"c1","uid":2358638,"ip_address":"","ucode":"650FE5C46CCD1C","user_header":"https://static001.geekbang.org/account/avatar/00/23/fd/6e/1913dbb6.jpg","comment_is_top":false,"comment_ctime":1614217087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614217087","product_id":100039001,"comment_content":"“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”<br>高内聚松耦合，是设计总则或目标，比较抽象，难以知道直到具体编码，但需要时刻牢记，同时包含了模块和关系两方面。模块功能要聚合，模块之间关系要松散。<br>单一职责是模块设计要内聚。功能要单一，便于复用。<br>接口隔离，是对模块功能的分类和抽象，将模块提供的能力安功能分组，抽象为稳定接口，这么做是为了避免耦合。<br>基于接口而非实现，是给使用者提的建议，依赖稳定抽象而非易变的实现。为独立变化做好准备。<br>迪米特法则，隶属于设计总则，纲领范畴，接近思想。","like_count":0},{"had_liked":false,"id":280315,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1614158515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614158515","product_id":100039001,"comment_content":"迪米特原则，实现基础是“高内聚，低耦合”，可以理解是集合了单一职责原则和接口隔离原则。","like_count":0},{"had_liked":false,"id":272957,"user_name":"Geek_897ea4","can_delete":false,"product_type":"c1","uid":1708328,"ip_address":"","ucode":"864B05054D686A","user_header":"","comment_is_top":false,"comment_ctime":1610365080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610365080","product_id":100039001,"comment_content":"相辅相成，只有融汇贯通才能很好的利用。总而言之，如果业务非常简单，就没必要考虑使用太多的设计模式，如果相对复杂。可以一点一点的使用，从最简单的开始做。","like_count":0},{"had_liked":false,"id":266702,"user_name":"落尘","can_delete":false,"product_type":"c1","uid":1802622,"ip_address":"","ucode":"7B76B94CA301D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/7e/fb688b5c.jpg","comment_is_top":false,"comment_ctime":1607443689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607443689","product_id":100039001,"comment_content":"“迪米特法则”是指导如何写出“高内聚、松耦合”的代码的原则。<br>更关注高内聚：“单一职责原则”表示一个“类&#47;函数”只负责一件事，应该将相近的功能尽量放在一起。<br>更关注松耦合：“接口隔离原则”要求不能暴露用户&#47;调用者不需要的功能。“基于接口而非实现编程”强调的是一种松耦合的思想。","like_count":0},{"had_liked":false,"id":252940,"user_name":"@许还真","can_delete":false,"product_type":"c1","uid":1099324,"ip_address":"","ucode":"6D754D5AE44CEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","comment_is_top":false,"comment_ctime":1602521323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602521323","product_id":100039001,"comment_content":"例子很棒","like_count":0},{"had_liked":false,"id":252242,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1602210851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602210851","product_id":100039001,"comment_content":"LOD:减少依赖数量（非必要不要建立依赖），降低依赖程度（通过接口而非实例表现依赖，接口隔离）。<br>针对课后问题，我是这么理解：<br>1、高内聚低耦合是最宽泛的原则，单一职责，接口隔离，基于接口而非实现都是实现高内聚低耦合的一种策略。<br>2、接口隔离原则，基于接口而非实现，单一职责也是迪米特法则的应有之意。减少类的依赖关系必然要求单一职责：如果一个类包含了太多的功能，就可能造成冗余的依赖关系。降低类的依赖程度，可以通过通过接口而非实现编程，接口隔离原则两条规则来实现。<br>3、迪米特法则强调的偏向于低耦合，但我们知道低耦合与高内聚是一体两面，从这个角度说，迪米特法则是高内聚低耦合原则的一种实现策略。<br>所以整体上近似有如下的关系：<br>高内聚低耦合-&gt;迪米特法则-&gt;单一职责，接口隔离，基于接口而非实现","like_count":0},{"had_liked":false,"id":251501,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1601620315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601620315","product_id":100039001,"comment_content":"为了代码的可或扩展性，主要思想需要实现高内聚、低耦合，单一职责是高内聚，接口隔离是低耦合，基于接口而非实现编程是低耦合，迪米特法则，两部分都有。","like_count":0},{"had_liked":false,"id":250960,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1601292026,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1601292026","product_id":100039001,"comment_content":"想知道如何把第一个场景中的代码组合起来，形成一个相对完整的调用。试着写了一小段程序，抛转引玉<br><br>public class DocumentDemo {<br>    public static void main(String[] args)  {<br>        string url = “”;<br>        string address = “”;<br>        Byte[] content = new Byte()[10] ;<br>        HtmlDownloader downloader = new HtmlDownloader(new NetworkTransporter(address, content));<br>        DocumentFactory factory = new DocumentFactory(downloader);<br>        Document document = factory.createDocument(url)<br>    }<br>}<br><br>第二个场景，其实和接口隔离原则比较类似，在多个序列化、反序列的化的场景中，代码确实显得更“漂亮”一些。<br><br>我觉得“高内聚、松耦合”不仅仅在迪米特法则这里突出，而应该是所有八个理论，或者说八个软件设计原则的核心思想。<br><br>相比较而言，“单一职责”更强调高内聚，“接口隔离”突出松耦合，“基于接口编程”也更侧重松耦合，而“迪米特法则”则平衡了“高内聚、低耦合”。","like_count":0},{"had_liked":false,"id":250293,"user_name":"笨鸟","can_delete":false,"product_type":"c1","uid":1236320,"ip_address":"","ucode":"68029ADA76AA5A","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/60/a6a4f79a.jpg","comment_is_top":false,"comment_ctime":1601014652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601014652","product_id":100039001,"comment_content":"高内聚,低耦合是目的,“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”是实现目的的方法","like_count":0},{"had_liked":false,"id":247678,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1599791895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599791895","product_id":100039001,"comment_content":"高内聚，低耦合：<br>迪米特法则要求只需要依赖自己需要的接口。<br>接口隔离原则可以将接口的功能细分，粒度降低，接口隔离正是为了满足迪米特法则的要求。<br>同时单一职责原则确保每个接口的功能单一，提高内聚性。<br>迪米特法则依赖于依赖倒置原则，面向接口和抽象类编程，因为接口抽象类中的代码属于上层代码，相对来说比较稳定，而实现相对来说变化比较频繁，<br>开闭原则可以确保底层实现能够灵活的切换，而不需要修改被依赖的对象。<br>李氏替换原则使得接口抽象类的实现符合上层定义的规范，替换接口或抽象类的时候可以保证功能不变。<br><br>ps:DRY原则、KISS原则、YAGNI原则目前还不确定是否和提高代码“高内聚，低耦合”有直接的关系！！","like_count":0},{"had_liked":false,"id":246212,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599209855,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599209855","product_id":100039001,"comment_content":"“高内聚、松耦合”：指导类的设计、职责分配，又是指导类之间关系的设计。<br>1、类自身：<br>1）“单一职责原则”：实现高内聚、松耦合的一种方式。每个类只有一个职责。<br>2）“接口隔离原则”：从使用者角度去考虑，被调用方职责是否单一。<br><br>2、类之间关系：<br>1）“基于接口而非实现编程”：实现松耦合。类之间的依赖通过关系，通过接口来实现。<br>2）“迪米特法则”：实现高内聚、松耦合的方式之一。类之间的关系设计考量。<br>","like_count":0},{"had_liked":false,"id":245955,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1599120757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599120757","product_id":100039001,"comment_content":"高内聚和低耦合是对代码设计好坏的一种衡量标准。而接口隔离、面向接口编程、迪米特、单一职责都是用来指导我们设计出”高内聚和低耦合“的类。","like_count":0},{"had_liked":false,"id":243935,"user_name":"Geek_6d4513","can_delete":false,"product_type":"c1","uid":2140839,"ip_address":"","ucode":"29B86212B52C60","user_header":"","comment_is_top":false,"comment_ctime":1598331720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598331720","product_id":100039001,"comment_content":"非常接地气，赞赞赞！","like_count":0},{"had_liked":false,"id":241654,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1597382486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597382486","product_id":100039001,"comment_content":"单一职责和接口隔离是实现迪米特法则的重要手段。迪米特法则是更高层次的指导思想","like_count":0},{"had_liked":false,"id":240253,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1065986,"ip_address":"","ucode":"3D3D10273BED18","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/02/5c8e4b81.jpg","comment_is_top":false,"comment_ctime":1596811376,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596811376","product_id":100039001,"comment_content":"<br>高内聚，松耦合  所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。<br><br>单一职责原则-强调类的职责清晰，只做一件事，强调是高内聚<br>接口隔离原则-强调调用者不要依赖自己不依赖的接口，强调减少接口耦合，是松耦合<br>基于接口而非实现编程--强调基于锲约而非具体实现类，减少具体实现类耦合，是松耦合<br>迪米特法则-强调能不依赖就不依赖，减少外部依赖，是松耦合<br>","like_count":0},{"had_liked":false,"id":238703,"user_name":"汉江","can_delete":false,"product_type":"c1","uid":1788647,"ip_address":"","ucode":"01622D984B8F9B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","comment_is_top":false,"comment_ctime":1596265407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596265407","product_id":100039001,"comment_content":"我在想假设有些类 既要用到系列化，还要用到反序列化 那怎么搞呢  ","like_count":0},{"had_liked":false,"id":235804,"user_name":"夜空咏叹调","can_delete":false,"product_type":"c1","uid":1189074,"ip_address":"","ucode":"CC9350BCF218CD","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d2/a5e272ce.jpg","comment_is_top":false,"comment_ctime":1595207337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595207337","product_id":100039001,"comment_content":"高内聚，松耦合是程序开发中都应该遵守的原则。迪米特法则则是没有逻辑关联的类之间不应该有任何联系，有逻辑关联的类之间应该只通过接口进行关联。","like_count":0},{"had_liked":false,"id":231282,"user_name":"大强","can_delete":false,"product_type":"c1","uid":1737397,"ip_address":"","ucode":"D5C64C5A01B25D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/82/b5/a6049a26.jpg","comment_is_top":false,"comment_ctime":1593626329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593626329","product_id":100039001,"comment_content":"内聚指的是类的相关功能聚合在一起，功能相近或者叫本类的应该有的方法，应该内聚在一起，无关的不要写在一起。单一职责是指导高内聚的一种思想。耦合指的是类之间的依赖关系，高度耦合说明类的依赖关系严重，依赖的多了，任何一个环节有问题，会引发连锁反应，降低风险的方法就是松耦合，实现松耦合的方法有接口隔离原则”“基于接口而非实现编程”“迪米特法则”。接口隔离原则”“基于接口而非实现编程”“迪米特法则”，这三个原则都是站在代码的创建者角度看待问题，如何设计高内聚松耦合的代码","like_count":0},{"had_liked":false,"id":230585,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1593423246,"is_pvip":false,"replies":[{"id":"86375","content":"“很有可能还是需要用到外部对象来解决问题”能举个例子吗？<br>“ 这种情况是不是需要做类扩展，在扩展中再具体引用HtmlRequest” 也可以直接改这个类~，不过还是没太懂你的意思~","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594602054,"ip_address":"","comment_id":230585,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1593423246","product_id":100039001,"comment_content":"我想知道假如 <br><br>Public class NetworkTransporter { <br>   &#47;&#47; 省略属性和其他方法...    <br> public Byte[] send(HtmlRequest htmlRequest) {      <br><br>   &#47;&#47;...    }}<br>中的send 方法，必须需要HtmelRequest 才能实现功能呢？ 老师修改后，参数上看起来是不依赖外部对象了，但是在很多其他实际操作时，很有可能还是需要用到外部对象来解决问题。 这种情况是不是需要做类扩展，在扩展中再具体引用HtmlRequest ?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499946,"discussion_content":"“很有可能还是需要用到外部对象来解决问题”能举个例子吗？\n“ 这种情况是不是需要做类扩展，在扩展中再具体引用HtmlRequest” 也可以直接改这个类~，不过还是没太懂你的意思~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594602054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1354013,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","nickname":"大方方","note":"","ucode":"621AD8F1485753","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291971,"discussion_content":"谢谢老师回复 我发现留言回复居然在web版上看不到，手机上才看到您的回复。\n关于我的问题，很抱歉没描述清楚。我在您后面的那个transaction的类重构过程中学找到答案了，类似把必须要引用单例的函数方法修改 ，和单例类解耦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595035893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224545,"user_name":"马球先生","can_delete":false,"product_type":"c1","uid":1119609,"ip_address":"","ucode":"858C2CE0E494C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/79/efde2a69.jpg","comment_is_top":false,"comment_ctime":1591436636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591436636","product_id":100039001,"comment_content":"接口隔离原则：从接口的设计方面来看 要设计小接口 功能单一的 不要设计大而全的接口<br>迪米特法则：从接口的使用者方面来看 用小接口 不需要的接口不用","like_count":0},{"had_liked":false,"id":219185,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589963026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589963026","product_id":100039001,"comment_content":"我们的目标就是 “高内聚 低耦合” 所以我们遵循迪米特法则，而迪米特法则要基于类的单一职责和基于接口编程而非实现。","like_count":0},{"had_liked":false,"id":211001,"user_name":"Obed","can_delete":false,"product_type":"c1","uid":1399904,"ip_address":"","ucode":"8717488DD14AB4","user_header":"https://static001.geekbang.org/account/avatar/00/15/5c/60/3754399d.jpg","comment_is_top":false,"comment_ctime":1587879932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587879932","product_id":100039001,"comment_content":"最小知识,单一职责,接口隔离,基于接口而非实现编程 都是为了实现 -&gt; 高内聚,低耦合<br>最小知识 更侧重于 低耦合<br>单一职责 更侧重 高内聚<br>接口隔离在前面的课程中分成了三个维度<br>1.一组Api <br>2.一个Api<br>3.OOP中的接口概念<br>其中1,3感觉与最小知识原则类似,<br>个人理解 其中的差别是 最小知识原则更多的是给调用者的限制:调用者应该只依赖于有限的类的有限的接口.而接口隔离法则更多的是给实现者的限制:提供接口的一方所提供的接口需要隔离<br>而接口隔离的第二个维度 是从接口角度去讲单一职责原则<br>基于接口而非实现编程 是强调我们需要有一种抽象思维,面向抽象编程 面向&quot;稳定&quot;编程,将不稳定的实现分离  就如 在最小知识原则中,类应该依赖有限的类,而对这些依赖的类,我们编写时要有抽象的思维<br><br>以上是个人见解 欢迎讨论,指正","like_count":0},{"had_liked":false,"id":207945,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1587220312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587220312","product_id":100039001,"comment_content":"我觉得高内聚低耦合是面向对象设计的一个终极目标，下面的几个原则呢都是实现这个目标的方法，但是他们互相之间也是有包含的，比如说单一职责原则能够确保迪米特法则中的前半段要求，针对接口而非实现的编程，又能够保证迪米特法则中的后半段要求。","like_count":0},{"had_liked":false,"id":207449,"user_name":"70","can_delete":false,"product_type":"c1","uid":1081899,"ip_address":"","ucode":"A5884B2BDDAB70","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/2b/cf93c499.jpg","comment_is_top":false,"comment_ctime":1587087678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587087678","product_id":100039001,"comment_content":"接口隔离原则可以用来判断职责是否单一；基于接口而非实现编程：接口不应该依赖具体的实现，具体的实现应该依赖于接口，其实接口就是就是对于实现的最小认知，符合迪米特法则的最小认知。高内聚是将统一职责的聚合到一起，符合单一职责原则，低耦合是将依赖以最少知道进行依赖，基于接口编程中的接口即是最少知道的。各种原则间相辅相成，共同以高内聚，低耦合为实现目标","like_count":0},{"had_liked":false,"id":206014,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1586773230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586773230","product_id":100039001,"comment_content":"高内聚，相同功能的放在同一个类里面，修改的时候方便集中修改，代码也就容易维护<br><br>迪米拉:就是把不同的方法不要放在一起，减少依赖。<br>解决高内聚和迪米拉冲突的方法，建几个接口，接口包含高内聚的分类的几个方法，然后实现类继承这几个接口。。。。(这也就是接口隔离原则)<br><br><br>当然迪米拉也不是无脑吧不同的方法不要放在一起，这还是要有个度。如果一个类里面就两个方法，就没必要去强拆弄复杂；同理，如果有多个可惜再细分，一些方法可以组成一个群，那么就可以用迪米拉了。","like_count":0},{"had_liked":false,"id":205380,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1586603586,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586603586","product_id":100039001,"comment_content":"【设计模式笔记23】20200411<br>本质上单一职责原则、基于接口而非实现编程和迪米特法则都是为了写出可维护和可读性性好的代码。单一职责也说的是类本身的功能要单一，基于接口而非实现编程是实现上要依赖抽象，依赖抽象是为了应对变化，就像都是生产开关，只要开关本身的功能能实现就可以了，不同厂家的开关就是实现，迪米特法则说的是类与类之间的关系，只依赖必要的类，不需要依赖的放到其他类。","like_count":0},{"had_liked":false,"id":205263,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1586578906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586578906","product_id":100039001,"comment_content":"基于接口而非实现编程：接口是稳定的，而实现是易变的。通过依赖接口来编程，在实现改变的时候，需要更换为另外一个实现类，那此时依赖类的代码不需要调整。<br>迪米特法则：不需要依赖的接口和类就不要依赖，有依赖关系的话，只依赖必要的接口。 依赖必要的接口，这一点跟接口隔离原则很像的；单一指责原则就是将相近的类放在一个类中，函数中。这几个原则都是为了高内聚，低耦合","like_count":0},{"had_liked":false,"id":202826,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586074625,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586074625","product_id":100039001,"comment_content":"思考题：区别就是每个原则都有自己的关注角度。联系就是这些原则都是为了提高代码的可读性与可维护性的。这里的可读性，个人感觉称为可理解性会更适当一些。","like_count":0},{"had_liked":false,"id":201339,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585753199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585753199","product_id":100039001,"comment_content":"高内聚：把功能类似的方法和类放到一起。<br>低耦合：类和类之间的依赖关系清晰明了，不会过度依赖。<br>迪米特法则：不该直接有依赖关系之间的类，就不要依赖。有依赖关系，尽量只依赖必要的接口。","like_count":0},{"had_liked":false,"id":200837,"user_name":"Six","can_delete":false,"product_type":"c1","uid":1220617,"ip_address":"","ucode":"E297BB638B2BD9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","comment_is_top":false,"comment_ctime":1585659532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585659532","product_id":100039001,"comment_content":"高内聚、松耦合是一种设计思想，写出的代码要符合这种思想离不开“单一职责原则”“接口隔离原则”“基于接口而非实现编程”,“迪米特法则”。<br>而单一职责原则 指导的是模块，类，方法设计要单一。是实现“高内聚”的一种法则<br>&quot;接口隔离原则&quot;在不同的角度有不同的理解，在一组接口设计中只提供给高层调用者依赖的方法,而在方法设计中,方法实现只存在该方法实现的必要逻辑。本质上还是实现高内聚<br>“基于接口而非实现编程”是基于面向对象多态思想，从而让代码易扩展，易复用。而如果作为高层调用者来说，只依赖接口而非实现。这样就符合“松耦合”<br>而“迪米特法则”则是综合了“单一职责”，“接口隔离原则”，“基于接口而非实现编程”。<br><br>结论<br>“单一职责”，“接口隔离原则”，“基于接口而非实现编程”<br>促成了“高内聚、松耦合” <br>“迪米特法则”则是体现了“高内聚、松耦合”<br>","like_count":0},{"had_liked":false,"id":200784,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585650512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585650512","product_id":100039001,"comment_content":"相互矛盾，相互影响，相互促进，但是对软件开发的易扩展，易维护，灵活性相辅相成","like_count":0},{"had_liked":false,"id":197905,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585403077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585403077","product_id":100039001,"comment_content":"说实话我一直记不住迪米特法则的含义，直到昨天给一个同事讨论我说如非必要不要把一个类过度暴露给其他类使用，我不知道专业术语怎么说，今天看到最小知识原则我就秒懂，我想表达的就是这个意思，虽然这个法则更适用于接口层次","like_count":0},{"had_liked":false,"id":196546,"user_name":"黑客时间","can_delete":false,"product_type":"c1","uid":1831324,"ip_address":"","ucode":"7E22D76EECAC4D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f1/9c/cd12361d.jpg","comment_is_top":false,"comment_ctime":1585292544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585292544","product_id":100039001,"comment_content":"高内聚，低耦合是目的，其他的设计原则都是为了实现高内聚，低耦合的目的","like_count":0},{"had_liked":false,"id":194776,"user_name":"然","can_delete":false,"product_type":"c1","uid":1347648,"ip_address":"","ucode":"43B7D3896D706B","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/40/dfa19744.jpg","comment_is_top":false,"comment_ctime":1585105212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585105212","product_id":100039001,"comment_content":"迪米特法则：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口","like_count":0},{"had_liked":false,"id":190894,"user_name":"BestKF02","can_delete":false,"product_type":"c1","uid":1337753,"ip_address":"","ucode":"74356EAB5351CE","user_header":"https://static001.geekbang.org/account/avatar/00/14/69/99/a817330d.jpg","comment_is_top":false,"comment_ctime":1584706406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584706406","product_id":100039001,"comment_content":"讲得非常棒，越看越有精神了 ^==^","like_count":0},{"had_liked":false,"id":189055,"user_name":"嘻哈","can_delete":false,"product_type":"c1","uid":1402535,"ip_address":"","ucode":"AEE1512822A399","user_header":"https://static001.geekbang.org/account/avatar/00/15/66/a7/5b7a7523.jpg","comment_is_top":false,"comment_ctime":1584450817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584450817","product_id":100039001,"comment_content":"软件工程提倡“高内聚、低耦合”，那么，可简单认为“高内聚、低耦合”是一个“纲”。而“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”这些内容是服务于这个“纲”，可认为这原则都是为了提高“高内聚、低耦合”的不同形式实现罢了。<br>单一设计原则提高功能单一或者尽可能的将相同功能组合在一起，那么这就提高了 内聚性<br>接口隔离原则即是将一组接口功能&#47;用途相同的接口放在一起，是接口化的单一设计原则，同样提高了内聚性<br>基于接口编程而非实现编程利用多态，将功能插拔到另一个类中，即使发生变化，也会做出很少修改，降低了类之间的依赖，这样就降低不同模块之间的耦合性<br>迪米特法则是指不要依赖没有依赖关系，即使有依赖，也要依赖最小（接口），同样描述类与类之间的关系，目的降低依赖性，实际就是松耦合<br>所以，这些知识都是在“高内聚、松耦合”的框架下以不同形式（自身设计、依赖设计）服务这个框架，目的就是提高软件系统的内聚和降低耦合","like_count":0},{"had_liked":false,"id":188319,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1584339513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584339513","product_id":100039001,"comment_content":"感觉思想都差不多，只是看问题的角度不一样。要达到的目的也是一样的，就像每个人对相同的东西都有不同的理解。","like_count":0},{"had_liked":false,"id":187703,"user_name":"yan","can_delete":false,"product_type":"c1","uid":1667264,"ip_address":"","ucode":"BA33B672798AEE","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/c0/b365a317.jpg","comment_is_top":false,"comment_ctime":1584195559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584195559","product_id":100039001,"comment_content":"单一职责原则：类、接口或模块自身，只完成一个职责或者功能，避免设计一个大而全的类。<br>接口隔离原则：侧重于接口的设计，提供了判断接口职责是否单一的标准。仅提供外部需要的接口。<br>基于接口而非实现编程：强调抽象意识，提高代码的灵活性和可扩展性。<br>迪米特法则：强调类与类之间的依赖关系，只依赖需要的接口和类。不需要的不要依赖。<br>","like_count":0},{"had_liked":false,"id":181737,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582625733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582625733","product_id":100039001,"comment_content":"首先是联系,我认为,单一职责原则,是从设计者的角度,设计类的功能,从而保证高内聚,而接口隔离原则,则是在调用者的来说,是类和类之间解耦,上层系统和下层系统依赖于接口,基于接口而非实现编程,则是开发者的角度来说,我们需要将具体的实现细节封装起来,只暴露出抽象的接口,让调用者和被调用者足够解耦,迪米特法则,本质上来说,就是说明高内聚,低耦合.其中我认为迪米特原则和接口隔离原则有异曲同工之妙,都是只将调用者需要的功能进行暴露<br>区别则是,上面的每一种设计原则,其实是从不同的角度去体现了高内聚,松耦合的原则,具体含义有所不同","like_count":0},{"had_liked":false,"id":181701,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582620417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582620417","product_id":100039001,"comment_content":"”高内聚、松耦合“ 是分别从类本身和类间关系分析的；<br>单一职责原则和高内聚是互相契合的；<br>接口隔离原则和松耦合也是互相契合的；<br>”基于接口而非实现“则是一种可行的操作，可以去实现上述的两个原则和”高内聚、松耦合“的特点。","like_count":0},{"had_liked":false,"id":179119,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1581922972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581922972","product_id":100039001,"comment_content":"“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？<br><br>高内聚，松耦合：把功能相关的放在一个类中，不相关的不放在一起。<br><br>单一职责原则：每个类或模块只干一件事情，保持功能单一。<br><br>接口隔离原则：跟单一职责类似，但是仅仅局限于接口，一个接口只干一件事情。<br><br>基于接口而非实现编程：依赖抽象，不依赖具体。<br><br>迪尔米特法则：不该有依赖关系的类之间，不能有依赖；该有依赖关系的类之间，尽量依赖必要的接口。<br><br><br><br>如有理解错的，望大佬们纠正！<br>","like_count":0},{"had_liked":false,"id":177401,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1581388429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581388429","product_id":100039001,"comment_content":"“高内聚、松耦合原则”：使用了“单一职责原则”实现高内聚。使用“接口隔离原则”实现低耦合。<br><br>“单一职责原则”：一个类只做一件事情。<br><br>“接口隔离原则”：使用“单一职责原则”，一个接口的功能尽量单一。<br><br>“基于接口而非实现编程”：类与类之间只依赖于接口，而非实现。<br><br>“迪米特法则”：使用“基于接口而非实现编程”，类与类之间只依赖于接口，而非实现。使用“高内聚、松耦合”，有关联关系的才会内聚再一起。","like_count":0},{"had_liked":false,"id":176959,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1581236645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581236645","product_id":100039001,"comment_content":"一个设计良好的软件看上去是高内聚，低耦合的。每一个模块得职责足够单一， 从逻辑上足够一致，并且提供的功能根据接口隔离原则切分得更细。模块之间的依赖做到了最小化，并且模块的依赖是根据接口去描述的，只依赖所必须的接口。","like_count":0},{"had_liked":false,"id":176957,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1581236122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581236122","product_id":100039001,"comment_content":"“高内聚、松耦合” 描述了模块本身与模块之间的性质<br>“单一职责原则” 描述了模块本身的性质<br>“接口隔离原则” 描述了模块应该以一种怎样的方式提供接口，即提供最小化依赖<br>“基于接口而非实现编程” 描述了模块的开发过程<br>迪米特法则 与接口隔离原则类似，不过是从调用者的角度去看该如何做到最小化依赖<br><br><br>“迪米特法则”<br><br><br>","like_count":0},{"had_liked":false,"id":175788,"user_name":"STAND ALONE COMPLEX","can_delete":false,"product_type":"c1","uid":1595002,"ip_address":"","ucode":"2AC2F9B0A6D823","user_header":"https://static001.geekbang.org/account/avatar/00/18/56/7a/60c3d6a5.jpg","comment_is_top":false,"comment_ctime":1580827607,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580827607","product_id":100039001,"comment_content":"王老师，您好！对于最后一个例子，我有个疑问，Serializable只负责序列化，Deserializable只负责反序列化，Serialization接口实现这两个接口，我们无论是序列化还是反序列化时，实际用到的都是Serialization接口实现类，那么如果在Spring中定义Spring Bean时，需要定义Serializable和Deserializable的两个接口的Bean，但他们实际引用的都是Serialization接口实现类，总觉得对于一个实现类定义了两个Bean，只是接口不同，这样很别扭，实际开发中，这种情况又是怎样做的呢？","like_count":0,"discussions":[{"author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295624,"discussion_content":"我也有这样的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596265801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172417,"user_name":"沐夜星光","can_delete":false,"product_type":"c1","uid":1447220,"ip_address":"","ucode":"22F699E237B179","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","comment_is_top":false,"comment_ctime":1579172979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579172979","product_id":100039001,"comment_content":"序列和反序列的类通过interface拆分成两个类后，两个类的实现不是相互依赖的吗？两个类必定一起改动的吧，没有减少测试工作量啊。","like_count":0},{"had_liked":false,"id":168858,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1578202435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578202435","product_id":100039001,"comment_content":"打卡<br>高内聚:指导类本身设计，相同功能放到同一个类中，不同功能，放到不同类中。<br>松耦合:指导类与类之间的设计，类与类之间的依赖关系简单，清晰。<br>迪米特法则:不该有直接依赖关系的类之间，不要有依赖，有依赖关系的类，尽量只依赖必要的接口。","like_count":0},{"had_liked":false,"id":167104,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1577692333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577692333","product_id":100039001,"comment_content":"高内聚: 相同的功能尽量放到同一个类中 用于指导类的设计<br>松耦合:  类与类之间的依赖关系 简单而清晰，不会因为改动一个类而影响另外一个类 用于指导类与类之间的设计<br>单一职责原则: 不光是类 可以是模块，函数 甚至是框架 让功能尽量单一 指导范围更广<br>基于接口而非实现编程: 两个方面 1. 扩展性 2. 隔离职责<br>迪米特法则: 不该有直接依赖关系的类之间，不要有依赖关系，就算是要依赖也要依赖与必要的接口 减少代码的耦合性<br>他们之间的联系在于都是为了 高内聚 低耦合，区别如以上整理","like_count":0},{"had_liked":false,"id":166836,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1577610104,"is_pvip":false,"replies":[{"id":"64855","content":"使用组合能不能解决复用问题呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1577669773,"ip_address":"","comment_id":166836,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1577610104","product_id":100039001,"comment_content":"老师 我有一个问题：在项目开发中，我写了一个类A 里面定义了一个方法，后来又写了一个类B 发现在B里面要用到A里面定义的那个方法(基本上一模一样)，但是A跟B本身是两个不相关的类 这个时候要怎么解决? PS:这个方法不能算作是工具类，只是一段数据集的处理逻辑 那是否是搞一个抽象类 然后让A和B继承这个抽象类 把那个方法写进抽象类里?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479648,"discussion_content":"使用组合能不能解决复用问题呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577669773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1464006,"avatar":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","nickname":"斐波那契","note":"","ucode":"85E2EBC01392B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109307,"discussion_content":"使用组合貌似改动有点大 不想就为了十几行逻辑就整那么复杂 其他同事肯定不会同意这么干的 课程里也说了 不要尝试别人不熟悉的东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577681866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166666,"user_name":"志振爱咋滴咋滴","can_delete":false,"product_type":"c1","uid":1237624,"ip_address":"","ucode":"E7A5049920C101","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/78/9241b7b2.jpg","comment_is_top":false,"comment_ctime":1577539793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577539793","product_id":100039001,"comment_content":"单一职责原则体现在高内聚的部分，一个类只做一件事，修改时也只需修改一个地方，避免影响<br>接口隔离也是基于单一职责，针对让接口更加独立而互不影响<br>基于接口而非实现编程，则是针对调用者的方便程度，避免修改底层代码的时候影响到了上层的调用者<br>迪米特法则则更像是利用接口隔离原则的下层实现部分的使用，减少依赖接口的数量来实现<br>彼此直接都是针对一个部分的具体操作，有上层和下层的考量，有调用者和实现者的考量<br>但其目的，都是为了实现高内聚，低耦合的设计目标。","like_count":0},{"had_liked":false,"id":166568,"user_name":"prowu","can_delete":false,"product_type":"c1","uid":1000532,"ip_address":"","ucode":"F7866D8DEA0FBB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/54/7e40e592.jpg","comment_is_top":false,"comment_ctime":1577504140,"is_pvip":false,"replies":[{"id":"65157","content":"这个也要具体问题具体分析 跟我们讲的vo bo很像","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1577952241,"ip_address":"","comment_id":166568,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1577504140","product_id":100039001,"comment_content":"一直有一个消息结构与程序内部数据结构取舍的问题：程序内部是否直接复用消息协议的结构？比如：通讯消息使用的是protobuf协议，那程序内部的逻辑是直接使用protobuf的数据结构，还是自己在定义一套结构体？如果直接使用protobuf协议，那程序就紧耦合于协议了（这边就是与protobuf绑在一起了），如果自己在定义一套结构体，那就要多一层协议与内部结构的转换。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479542,"discussion_content":"这个也要具体问题具体分析 跟我们讲的vo bo很像","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577952241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000532,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/54/7e40e592.jpg","nickname":"prowu","note":"","ucode":"F7866D8DEA0FBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114069,"discussion_content":"在您的工程实践经验中，能几个例子吗？其实是想学习和借鉴下您对这类问题的把握和权衡的思路。谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577955256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166130,"user_name":"ChenJz","can_delete":false,"product_type":"c1","uid":1003992,"ip_address":"","ucode":"AF2F8D9015BE5D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/d8/71ef5aa1.jpg","comment_is_top":false,"comment_ctime":1577408046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577408046","product_id":100039001,"comment_content":"在类与类之间的关系中，要做到最小依赖。例如，我只想知道钱包里面有多少钱，你只需要告诉我钱的数量即可，而不是把整个钱包传给我让我去找。其实在日常开发中我们也遇到这种问题，有些人会把整个大对象给你，美其名曰为了以后得扩展，你需要什么就在里面取就好了，万一之后需求会改动，也能满足。","like_count":0},{"had_liked":false,"id":165757,"user_name":"麻婆豆腐","can_delete":false,"product_type":"c1","uid":1731885,"ip_address":"","ucode":"F371FE05D081D6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6d/2d/de41f9cf.jpg","comment_is_top":false,"comment_ctime":1577318886,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577318886","product_id":100039001,"comment_content":"单一职责原则，主要指导类，模块接口的设计，要求是功能单一，<br>接口隔离原则，主要是接口的设计，并且判断标准是调用是否使用了接口的全部功能，如果没有则不单一<br>迪米特法则，主要是高内聚松耦合中的松耦合，让类之间的依赖清晰，减少非必须的依赖，尽量依赖必要的接口","like_count":0},{"had_liked":false,"id":165491,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1577244952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577244952","product_id":100039001,"comment_content":"设计模式_22:<br># 作业<br>我认为，“高内聚，松耦合”更加底层，其他的原则更像是不同方向的应用。<br><br># 感想：<br>“高内聚，松耦合”，好像是每一个学过计算机课程的人都熟记的概念，很多人也会在简历中写这一点，但是不同的人对于原则的理解程度是不同的，这些差异来自与信息量：<br>今天聊到设计原则是怎么来的，就是来自于之前的实践经验，发现并使用原则真实地解决了当时的问题，然后原则以“高内聚，松耦合”这样极简的文字流传下来，而其他的信息量全部丢失。<br>我们都有过这样的经历，真正地实践后，犯错后，发现自己真正理解了一个道理，虽然你早已听说过它。<br><br>其实实践的过程，就是信息量补充的过程；想要真正地理解这些原则，依然需要经历这些实践，需要这些信息量。","like_count":0},{"had_liked":false,"id":165262,"user_name":"小毅","can_delete":false,"product_type":"c1","uid":1016799,"ip_address":"","ucode":"5651C740D68038","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","comment_is_top":false,"comment_ctime":1577190437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577190437","product_id":100039001,"comment_content":"对于第一个例子我个人觉得将NetworkTransporter 类的send方法对应的HtmlRequest中属性拉平，还不如调整更为贴切的名字～ 对于公共方法过多的参数其实不太好维护～","like_count":0},{"had_liked":false,"id":164904,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1577108835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577108835","product_id":100039001,"comment_content":"个人觉得，单一职责原则、接口隔离原则、基于接口而非实现编程、迪米特法则都是实现高内聚和低耦合在不同角度的更加落地的思考。高内聚、低耦合是一个顶层目标，而这些原则是这个目标的不同角度的思考，比如接口隔离原则，基于接口而非实现编程是从接口的角度来思考。单一职责原则是从模块、类的角度来思考。而迪米特法则强调units之间不该有的关系就不要有，最好关系是清清楚楚，明明白白的。","like_count":0},{"had_liked":false,"id":164881,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1577104322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577104322","product_id":100039001,"comment_content":"同: 都是为了保证代码的稳定性，在变化的情况下，影响最小，不过各自纬度可能不同。<br>单一职责原则: 基于功能点，要结合业务来考虑是否职责是否单一<br>基于接口而非实现编程: 是基于变化的点，为了应对变化<br>“接口隔离原则”和“迪米特法则”: 没太区分开。我目前理解是一样的，在于对调用方的关系上面，做到无关的不用理解。<br>“高内聚、松耦合”: 是总的原则，类似于纲领，这个没太理解，总是挂嘴上，但是感觉有点模糊?<br><br>提问:<br>类似与序列化类的问题，代码的重构是渐进的。比如一开始，<br>class A{<br>    &#47;&#47;序列化<br>    a();<br>    &#47;&#47;反序列化<br>    b();<br>}<br>当有一天，有3个序列化和3个反序列化方法的时候，准备拆分了，就像文中一样，实现两个接口，代码重构一下即可以让每个调用方知道最少，符合迪米特法则,应用内部修改确实没什么问题。但是比如dubbo服务，如果一开始没拆开，后面想拆开。又要考虑向前兼容的问题，目前的做法就是class A 实现2个接口，新增6个方法，有2个和原来的序列化反序列化一样，标记旧的过期。通常还有什么更好的办法么？","like_count":0},{"had_liked":false,"id":164817,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1237655,"ip_address":"","ucode":"088A8DA0A16BDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","comment_is_top":false,"comment_ctime":1577095306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577095306","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":164734,"user_name":"yes","can_delete":false,"product_type":"c1","uid":1386201,"ip_address":"","ucode":"612BF6884ED6CC","user_header":"https://static001.geekbang.org/account/avatar/00/15/26/d9/f7e96590.jpg","comment_is_top":false,"comment_ctime":1577083802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577083802","product_id":100039001,"comment_content":"我认为所有的设计原则和设计模式都是为了达到高内聚、松耦合的目的，而设计原则是指导思想，设计模式是前人根据设计原则再结合常见痛点得出的具体落地方案。<br><br>按照指导思想设计出来的代码就是会符合高内聚、松耦合。<br><br>指导思想之间也是相辅相成的。<br><br>单一职责思考的角度是功能方面，一个类一个模块职责单一，而迪米特法则考虑的是最小化依赖原则，也就是在职责单一的情况下再深挖，尽可能的减少类之间的依赖关系，以达到松耦合的目的。<br><br>并且在这个过程中我们肯定选择的是基于接口而非实现编程，依赖抽象而不是依赖实现。在这种情况下再考虑最小化依赖原则，我们肯定是想剥除接口里面一些此场景下不需要的方法，因此接口隔离原则就运用上了。<br><br>也就是说平日我们开发中需要时刻的想着这几种原则，它们分别从不同的角度来指导我们。但是盲目的运用是没必要的，一个再也简单两三个方法纷纷运用上这些原则，就过犹不及了，要想着KISS。<br><br>代码是持续改进、不断重构的。","like_count":0},{"had_liked":false,"id":164726,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1577083055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577083055","product_id":100039001,"comment_content":"课堂讨论：<br><br>在今天的讲解中，我们提到了“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？<br><br><br><br>Answer:<br><br>1.高内聚与单一职责原则：<br><br>​    高内聚形容类聚焦于本身的职责，是单一职责原则的具体体现。换句话说，遵守了单一职责原则而设计出的类，具有高内聚的特性。<br><br><br><br>2.松耦合与接口隔离原则：<br><br>​    低耦合形容类尽可能少的依赖其他类（接口），是接口隔离原则的具体体现。如果遵守接口隔离原则，就能设计出松耦合的类。<br><br><br><br>3.基于接口而非实现编程与迪米特法则<br><br>​    基于接口而非实现编程是一种面向对象设计思想，通过接口依赖而非具体类依赖的方式达到类之间松耦合的目的。<br><br>​    此思想一定意义上沉淀为迪米特法则：解耦类之间的依赖关系，能不依赖的，就不要依赖；必须依赖的，要依赖接口，而不依赖实现。总而言之：基于接口而非实现编程是形而上的飘渺思想，迪米特法则是萃取思想精华的戒律清规。在每日的修行中：遵守戒律，参悟思想，才能有所精进。","like_count":0},{"had_liked":false,"id":164711,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1577079926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577079926","product_id":100039001,"comment_content":"打卡～<br>1.不该有直接依赖关系的类之间，不要有依赖；<br>2.有依赖关系的类之间，尽量只依赖必要的接口。<br>","like_count":0},{"had_liked":false,"id":164679,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1577071265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577071265","product_id":100039001,"comment_content":"高内聚:指将将相近的功能封装在一个类或者模块中，不要包含语义不相干的功能，是类或者模块本身的设计原则<br>松耦合:是模块与模块、类与类之间的依赖关系。依赖的模块只包含我依赖的功能，没有附件功能。尽量让依赖关系成线性<br><br>单一职责:是实现高内聚与松耦合的编程手段。每一个api，每一个类，每一个模块的职责要尽可能的单一<br>基于接口编程:多而小的接口相互组合，让松耦合变得更加容易实现","like_count":0},{"had_liked":false,"id":164671,"user_name":"Askerlve","can_delete":false,"product_type":"c1","uid":1178535,"ip_address":"","ucode":"BF29F9A8674507","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/a7/12c90699.jpg","comment_is_top":false,"comment_ctime":1577069927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577069927","product_id":100039001,"comment_content":"打卡，把自己知道的有层次的讲出来，让人易懂，真是一门学问呢～","like_count":0},{"had_liked":false,"id":164661,"user_name":"evolution","can_delete":false,"product_type":"c1","uid":1088402,"ip_address":"","ucode":"105C59822BF75B","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/92/c0863297.jpg","comment_is_top":false,"comment_ctime":1577067981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577067981","product_id":100039001,"comment_content":"理论解读与代码实战二的解决办法，让我一下子明白了框架源码为何那么写","like_count":0},{"had_liked":false,"id":164653,"user_name":"哈喽沃德","can_delete":false,"product_type":"c1","uid":1749033,"ip_address":"","ucode":"7620366C16826B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b0/29/7ab573f4.jpg","comment_is_top":false,"comment_ctime":1577066263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577066263","product_id":100039001,"comment_content":"期待看设计模式的讲解","like_count":0},{"had_liked":false,"id":164647,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1577065283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577065283","product_id":100039001,"comment_content":"这些设计原则之间有时候看似矛盾，实则相互制衡，这应该是告诉我们代码设计讲究一个平衡。这个平衡就是可维护，可扩展，可读性。","like_count":0},{"had_liked":false,"id":164634,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1577063510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577063510","product_id":100039001,"comment_content":"打卡 需要思考下","like_count":0},{"had_liked":false,"id":164631,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1577063338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577063338","product_id":100039001,"comment_content":"对于讨论题我是这样理解的:<br>“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则” 都是意在指导我们写的代码变的 “高内聚、松耦合”。 以编写类的角度，在我看来这么多的原则中比较核心的点是，职责单一和面向接口这两点，同时考验个人对业务的抽象能力。<br><br>总结一下设计原则的学习感受吧:<br>整体来说有些收获，对设计原则有了一个整体的认识，但仍需巩固，后面应该会整理一个笔记出来。<br>在应用方面仍有些模糊，感觉原则方面只是起到一个指导方向的作用，实际编写代码的过程中还是经验和业务作为主导，多应用多总结吧。","like_count":0},{"had_liked":false,"id":164630,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1577063227,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1577063227","product_id":100039001,"comment_content":"这几个概念“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”共性很明显，主要说下区别。它们强调的重点有所不同，“高内聚，低耦合”强调的是整体架构设计，包括类本身的设计以及类与类关系的设计，可以理解为是我们软件设计的目标。“单一职责原则”是强调“类&#47;模块&#47;函数”本身的设计，告诉我们对于个体应该如何设计。“接口隔离原则”强调类与类之间的设计，强调它们应该依赖于接口。“基于接口而非实现编程”强调的也是类之间的设计，是一种具体的设计方法，基于组合的方法。“迪米特法则”强调的是类与类和类之间的设计，是实现高内聚低耦合的具体指导方法。","like_count":0},{"had_liked":false,"id":164617,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1577061081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577061081","product_id":100039001,"comment_content":"文中:高内聚有助于松耦合，松耦合又需要高内聚的支持。  感觉这句话说的两点应该是一个意思吧，都是在说松耦合是基于高内聚来实现的","like_count":0},{"had_liked":false,"id":164612,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1577060295,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"1513405548487","product_id":100039001,"comment_content":"目的都是实现高内聚低耦合，但是出发的角度不一样，单一职责是从自身提供的功能出发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归。","like_count":353,"discussions":[{"author":{"id":1476490,"avatar":"https://static001.geekbang.org/account/avatar/00/16/87/8a/07ab933c.jpg","nickname":"璀璨星空","note":"","ucode":"CE6324C4261A52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384157,"discussion_content":"不能从代码层面看，出发点是行为","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626405967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144462,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/8e/cf43b065.jpg","nickname":"Lee","note":"","ucode":"314D7BCB5C7C24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371150,"discussion_content":"同感，比起观察者模式，我觉得更像门面模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619664919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165382,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1008315,"ip_address":"","ucode":"816B3792ECC50A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/bb/323a3133.jpg","comment_is_top":false,"comment_ctime":1577232524,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"916405266572","product_id":100039001,"comment_content":"1.单一职责原则\t<br>适用对象:模块，类，接口 <br>侧重点:高内聚，低耦合\t<br>思考角度:自身<br><br>2.接口隔离原则<br>适用对象:接口，函数\t<br>侧重点:低耦合\t<br>思考角度:调用者<br><br>3.基于接口而非实现编程 <br>适用对象:接口，抽象类\t<br>侧重点:低耦合 <br>思考角度:调用者<br><br>4.迪米特法则\t<br>适用对象:模块，类\t<br>侧重点:低耦合\t<br>思考角度:类关系","like_count":214},{"had_liked":false,"id":164635,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1577063527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"242095232103","product_id":100039001,"comment_content":"“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，它们之间的区别和联系吗？<br>区别:<br>高内聚、松耦合:是一个重要的设计思想,能够有效地提高代码的可读性和可维护性,缩小功能改动导致的代码改动范围.<br>单一职责原则:A class or module should have a single reponsibility.提供的功能上要单一.<br>接口隔离原则:Clients should not be forced to depend upon interfaces that they do not use.与外部关系上只依赖需要的抽象.<br>基于接口而非实现编程:Program to an interface, not an implementation.是一条比较抽象、泛化的设计思想,为了提高代码的灵活性&#47;扩展性&#47;可维护性.<br>迪米特法则:Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.每个单元只该依赖与它关系密切的单元,最少知道,只与关系密切的单一交互.<br>联系:<br>职责越单一越容易做到接口隔离,也越容易做到最少知道的迪米特法则.<br>基于抽象编程抽象的知识越顶层越脱离具体实现,相对知道的内容就越少,也容易实现迪米特法则.<br>接口隔离原则与迪米特法则都强调只依赖需要的部分,接口隔离原则是相对偏上层来说的,迪米特法则是相对偏具体实现来说的.<br>单一职责原则&#47;接口隔离原则&#47;基于接口而非实现编程&#47;迪米特法则都以实现代码的&quot;高内聚、松耦合&quot;为目的,提高代码的可读性和可维护性,缩小功能改动导致的代码改动范围,降低风险.","like_count":57},{"had_liked":false,"id":164646,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1577065034,"is_pvip":true,"discussion_count":24,"race_medal":0,"score":"173375756874","product_id":100039001,"comment_content":"关于LoD，请记住一条：方法中不要使用ChainMethods。<br><br>坏的实践：<br>Amount = customer.orders().last().totals().amount()<br>和<br>orders = customer.orders()<br>lastOders = orders.last()<br>totals = lastOders.totals()<br>amount = totals.amount()<br><br>上面的例子中，chain中的方法改变会影响很多地方。这里注意区别建造者模式和pipeline管道，这两种的chain中的方法不易改变。<br><br>出现这样的代码，需要考虑可能是设计或实现出了问题。<br><br>LoD如何使用：<br>一个类C中的方法只能调用：<br>1、C中其他实例方法<br>2、它自己的参数方法<br>3、它创建对象的方法<br>4、不要调用全局变量（包括可变对象、可变单例）<br>例如：<br>class HtmlDownloader{<br>  Html html;<br>  public void downloadHtml(Transporter trans, String url){<br>    if(checkUrl(url)){&#47;&#47; ok 自己的实例方法<br>      &#47;&#47; return<br>    }<br>    rawData = trans.send(uri);&#47;&#47; ok 参数对象的方法<br>    Html html = createHtml(rawData); &#47;&#47; ok 它创建的对象<br>    html.save();&#47;&#47; ok  它创建对象的方法<br>  )<br>  private boolean checkUrl(String url){<br>    &#47;&#47; check<br>  }<br>}<br><br>参考：<br>The Pragmatic Programmer 1st edition and 2nd edition<br>","like_count":40,"discussions":[{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241282,"discussion_content":"这样存在意义远大于笼统的概括，每种设计模式都有特定的设计意图，界限不清晰的话，人类思维的效率会大打折扣的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587397533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180012,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1582165263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"66006674703","product_id":100039001,"comment_content":"看一遍，真的不行，每次看都有新收获！","like_count":15},{"had_liked":false,"id":164924,"user_name":"LiuHu","can_delete":false,"product_type":"c1","uid":1039768,"ip_address":"","ucode":"284E2025C554BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/98/883c42b4.jpg","comment_is_top":false,"comment_ctime":1577112612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61706654756","product_id":100039001,"comment_content":"“高内聚、松耦合” 是衡量好代码的标准之一，为了实现这样的目标，我们需要遵循如下原则：<br>“基于接口而非实现编程”，接口本身就是一层抽象，接口是稳定的，实现是易变的，强调的是基于契约编程，这样能够隔离变化。实现细节代码的变化，不影依赖该接口的对象，到从而达到松耦合的目的。<br>“迪米特法则”，定义的是发布的接口（类、模块等）能不能依赖，如何依赖的问题。使用者去除不必要的依赖，只依赖必要的接口。这样即使接口一旦发生变化，需要了解这一变化的类就会比较少，达到松耦合的目的。<br>“接口隔离原则”，从使用者的角度考虑如何设计接口，让使用者只依赖必要的接口，不会被迫依赖不用的接口。这样即使接口一旦发生变化，需要了解这一变化的类就会比较少，这样就能符合 “迪米特法则” 。<br>“单一职责原则”，针对模块、类、接口的设计，将功能相关性很强的代码抽取到一起，达到高内聚的目标。","like_count":14},{"had_liked":false,"id":261753,"user_name":"王大喵","can_delete":false,"product_type":"c1","uid":1109528,"ip_address":"","ucode":"C14AAE3ED964DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/18/65e89d9c.jpg","comment_is_top":false,"comment_ctime":1605513668,"is_pvip":false,"replies":[{"id":"96134","content":"������","user_name":"作者回复","comment_id":261753,"uid":"1190123","ip_address":"","utype":1,"ctime":1606701264,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"35965252036","product_id":100039001,"comment_content":"联系：<br>“接口隔离原则”是客户端不应该被强迫依赖不需要的接口，和“迪米特法则”中的有限知识异曲同工，接口簇会更加“单一职责”实现方式“基于接口而非实现编程”，达到的目的是高内聚，松耦合。<br><br>区别：<br>1. 各种原则最终的目的是为了实现“高内聚、松耦合”。<br>2. 单一职责原则 主要是指导类和模块，避免大而全，提高内聚性。<br>3. 接口隔离和迪米特(最小知识)主要指导“松耦合”，解耦使用方的依赖。<br>4. 基于接口而非实现编程：主要是解耦接口和实现，是指导思想，提高扩展性。","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509595,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012371,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/72/93/46895883.jpg","nickname":"terryking","note":"","ucode":"39433F06D6BEF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559132,"discussion_content":"这个总结很到位，不过各种原则都是用来解决指导开闭原则实施的;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648620392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164911,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1577110263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31641881335","product_id":100039001,"comment_content":"课后讨论：代码的最终目的是高内聚、松耦合的。而为了达到这个目的，就需要利用到迪米特法则。而迪米特法则的实现，又需要利用单一职责将单个类定义职责单一化，并且为了解决多个类之间的关系，又需要用到基于接口编程而非实现编程。这样类与类之间就相当于契约化，也就是不关心类的具体实现。","like_count":7},{"had_liked":false,"id":246653,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1599446710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14484348598","product_id":100039001,"comment_content":"一不小心就能用到一个牛逼的原则，如果没有这些归纳总结的话，永远都不知道自己究竟有多牛逼。<br>是不是觉得迪米特法则和之前的原则很像，当然很像了，毕竟他们都是为了实现“高内聚，低耦合”。<br>【单一职责原则】是从自身功能出发，实现高内聚，低耦合<br>【接口隔离原则】和【基于接口而非实现编程】是从调用者出发，实现低耦合<br>【迪米特法则 】是从关系出发，实现低耦合","like_count":3},{"had_liked":false,"id":232758,"user_name":"HYH","can_delete":false,"product_type":"c1","uid":1103960,"ip_address":"","ucode":"F2A339CC9AC594","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/58/1f5f7aed.jpg","comment_is_top":false,"comment_ctime":1594110391,"is_pvip":false,"replies":[{"id":"85963","content":"你的设计也可以的。设计本身没有最优解，合理、能自圆其说就可以了。总体上来讲，我这个例子是为了展示尽量减少类之间的耦合。","user_name":"作者回复","comment_id":232758,"uid":"1190123","ip_address":"","utype":1,"ctime":1594174033,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"14479012279","product_id":100039001,"comment_content":"老师您好，请问一下Document的修改为什么会使用到Factory的方式去产生？我对这一步的修改没有很大的感受，我这里的认知是Document只是单纯对文件的操作，那是不是可以透过HtmlDownloader实现相关取得文件的接口，像是IDownloader之类的名称，并直接回传Document这个类(亦或者对此类做其它的延伸)，未来也可以实现其它像是json等其他格式的downloader，不知道我这个想法是不是可行？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500763,"discussion_content":"你的设计也可以的。设计本身没有最优解，合理、能自圆其说就可以了。总体上来讲，我这个例子是为了展示尽量减少类之间的耦合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594174033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1541014,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","nickname":"天亮前说晚安","note":"","ucode":"1D82EE562A7C71","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":536974,"discussion_content":"但是你前面说了，发送请求，send方法，都可能其他方式，那下载器也不应该依赖具体实现，应该是接口，极有可能多种下载方式吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638925406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":500763,"ip_address":""},"score":536974,"extra":""}]}]},{"had_liked":false,"id":166602,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1577514850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14462416738","product_id":100039001,"comment_content":"高内聚-低耦合<br>单一职责-自身功能出发<br>迪米特法则  类与类之间关系<br>接口而非实现编程-依赖必要的抽象","like_count":3},{"had_liked":false,"id":166137,"user_name":"戒惜舍得","can_delete":false,"product_type":"c1","uid":1454225,"ip_address":"","ucode":"694FE967317710","user_header":"https://static001.geekbang.org/account/avatar/00/16/30/91/5f770e29.jpg","comment_is_top":false,"comment_ctime":1577408625,"is_pvip":false,"replies":[{"id":"64837","content":"咋这么能抬杠呢 你说我问你怎么相近 你能回答上来吗 这个也没法量化 设计模式不是算法 什么都能定量 更多的是教你思想 你自己去感受","user_name":"作者回复","comment_id":166137,"uid":"1190123","ip_address":"","utype":1,"ctime":1577666842,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"14462310513","product_id":100039001,"comment_content":"相近的功能。 怎么算相近啊。学晕了。","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479413,"discussion_content":"咋这么能抬杠呢 你说我问你怎么相近 你能回答上来吗 这个也没法量化 设计模式不是算法 什么都能定量 更多的是教你思想 你自己去感受","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577666842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2715388,"avatar":"","nickname":"Geek8535","note":"","ucode":"D1919541632C95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537355,"discussion_content":"如果是2个妹子你肯定秒知道如何知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639041607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165221,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1577182858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14462084746","product_id":100039001,"comment_content":"老师讲的真棒👍","like_count":3},{"had_liked":false,"id":164738,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1577084858,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14461986746","product_id":100039001,"comment_content":"如果说高内聚、松耦合等价于&quot;中国特色社会主义&quot;, 那么“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”这几个原则就像是在说如何才能做到做到这样的社会?  答案就是我们要&quot;倡导富强、民主、文明、和谐, 自由、平等、公正、法治，爱国、敬业、诚信、友善&quot;","like_count":3,"discussions":[{"author":{"id":1992059,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/65/7b/058d17f3.jpg","nickname":"耶low","note":"","ucode":"4CCEB741583544","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394201,"discussion_content":"你这部级起步吧😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631782442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259775,"user_name":"Geek_809561","can_delete":false,"product_type":"c1","uid":2037722,"ip_address":"","ucode":"94FA67AEFB6CA0","user_header":"","comment_is_top":false,"comment_ctime":1604830288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10194764880","product_id":100039001,"comment_content":"单一职责原则：模块,类，方法等功能要单一。功能越单一的类，对外部依赖越少。高内聚。<br><br>接口隔离原则： 调用者调用被调用者的方法或功能的时候，这个方法或者功能的粒度要小，职责要单一。高内聚<br><br>单一职责和接口隔离的区别是：一个是偏向于整体的（类，模块，接口的）设计，而接口隔离知识对接口的设计。相同点都是要求单一职责，高内聚。<br><br>基于接口而非实现编程：将接口和实现分离。调用者只需要知道被调用者抽象出来的方法或功能，并不需要知道具体的细节是怎么执行的。降低了调用者和被调用者之间的耦合度。更偏向于整体的抽象思想。<br>接口隔离与基于接口而非实现编程：一个是对具体接口的要求，（单一），一个是要求将具体的行为和功能抽象化，为后续被调用的整体替换做准备。<br>迪米特法则：又叫做最少知识法则，降低调用者与被调用者之间的耦合度。调用者只关于自己必须知道的知识（没有就实现不了的）。","like_count":2},{"had_liked":false,"id":216870,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1589358218,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10179292810","product_id":100039001,"comment_content":"感觉NetworkTransporter这个例子举的不好... <br>本身获取HTML确实可以通过通过HtmlRequest, 现在非得把他拆成一个地址和content, 那么地址和content分别传入什么呢? 这样做HtmlRequest这个类就没有存在的意义了.<br>下面document例子我比较认可. 确实document类只要把html字符串传进来即可, 至于谁去加载字符串这个不归他管","like_count":2,"discussions":[{"author":{"id":1316758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","nickname":"Richard","note":"","ucode":"893F958B9DD161","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345263,"discussion_content":"我也跟你有同感，有点强制通用的意思，其实从场景出发这里就是解析HTML，我看应该把NetworkTranspoter改成HtmlRequestTranspoter，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611708131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1483671,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a3/97/ca8057a4.jpg","nickname":"Mona432","note":"","ucode":"3F02C646C8DC83","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310641,"discussion_content":"就是实现NetworkTransporter与HtmlRequest的解耦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601966652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202829,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586074833,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"10176009425","product_id":100039001,"comment_content":"对LOD迪米特法则的形象理解：不要探究朋友的隐私，要与陌生人保持距离。😂","like_count":2},{"had_liked":false,"id":166172,"user_name":"ismind","can_delete":false,"product_type":"c1","uid":1138710,"ip_address":"","ucode":"7AADD673ED3BC4","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/16/d1dd4972.jpg","comment_is_top":false,"comment_ctime":1577410897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167345489","product_id":100039001,"comment_content":"前几天没抽出时间，今天补上。<br>1，感觉还是要做笔记，现在才知道要做一下笔记，不然前面学的基本上只是留个大概的印象，效率低<br>2，感觉开始有难度了，综合性更高了，开始加速了么？哈哈<br>课后思考：<br>1，这五个原则与思想，联系就是：都是为了提高代码的可读性、扩展性、灵活性等，这也是这些原则产生的原因之一，我觉得应该把握这个主要的目的，再去应用这些原则或者设计模式，否则单纯为了使用这些原则，那很可能适得其反，我又想起那句话：“不忘初心方得始终”，学习设计模式也要这样吧。<br>老师的代码实战二，简单的序列化使用LOD原则，感觉过度设计了，不过一看后面功能变复杂了，觉得设计才合理。<br>2，区别：应该是关注点不同吧，“高内聚、低耦合”关注的是类，也就是考虑类与类之间的关系；单一职责则是关注前几天没抽出时间，今天补上。<br>1，感觉还是要做笔记，现在才知道要做一下笔记，不然前面学的基本上只是留个大概的印象，效率低<br>2，感觉开始有难度了，综合性更高了，开始加速了么？哈哈<br>课后思考：<br>1，这五个原则与思想，联系就是：都是为了提高代码的可读性、扩展性、灵活性等，这也是这些原则产生的原因之一，我觉得应该把握这个主要的目的，再去应用这些原则或者设计模式，否则单纯为了使用这些原则，那很可能适得其反，我又想起那句话：“不忘初心方得始终”，学习设计模式也要这样吧。<br>老师的代码实战二，简单的序列化使用LOD原则，感觉过度设计了，不过一看后面功能变复杂了，觉得设计才合理。<br>2，区别：应该是关注点不同吧，“高内聚、低耦合”关注的是类，也就是考虑类与类之间的关系；单一职责则是关注某一个类或者函数的功能是否单一；接口隔离则关注不要依赖不需要的接口；基于接口而非实现编程就考虑将实现替换为接口。<br>自己感觉这些还没有彻底理解，只是大概知道，感觉离掌握与熟悉还有一段距离。","like_count":2},{"had_liked":false,"id":164599,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1577058194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166992786","product_id":100039001,"comment_content":"打卡<br>所有的设计原则都相辅相成","like_count":2},{"had_liked":false,"id":322984,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1637679287,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5932646583","product_id":100039001,"comment_content":"高内聚，低耦合就是分门别类别掺和。 迪米特法则就是别和陌生人说话，只和熟人说话。调用过程中应该尽量解耦，尽量考虑使用。参考rule of three","like_count":1},{"had_liked":false,"id":276160,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1611818066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5906785362","product_id":100039001,"comment_content":"1.单一职责原则<br>适用对象:模块，类，接口<br>侧重点:高内聚，低耦合<br>思考角度:自身<br><br>2.接口隔离原则<br>适用对象:接口，函数<br>侧重点:低耦合<br>思考角度:调用者<br><br>3.基于接口而非实现编程<br>适用对象:接口，抽象类<br>侧重点:低耦合<br>思考角度:调用者<br><br>4.迪米特法则<br>适用对象:模块，类<br>侧重点:低耦合<br>思考角度:类关系","like_count":1},{"had_liked":false,"id":193437,"user_name":"@%初%@","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1584892751,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5879860047","product_id":100039001,"comment_content":"感觉上面的代码还是有问题：<br>1. document就是一个纯粹的文档基类，为什么要依赖html，那么asp，jsp的网页不能解析？？？<br>","like_count":1,"discussions":[{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264914,"discussion_content":"对, 所以要看细粒度..不是全部代码都不能有多余的依赖关系, 太追求细节的话, 写出来的代码太复杂了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589357960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187718,"user_name":"Buring","can_delete":false,"product_type":"c1","uid":1651664,"ip_address":"","ucode":"0AAEA64C63C2F6","user_header":"https://static001.geekbang.org/account/avatar/00/19/33/d0/962ebe2e.jpg","comment_is_top":false,"comment_ctime":1584198555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879165851","product_id":100039001,"comment_content":"我的理解就是：<br>高内聚、低耦合：他强调的是不同的方法、类、模块之间的关系网的问题，是以一个上帝视角来观察的<br>单一职责原则：他强调的是某一个具体方法或者类或者模块，他们主要关注自己本身的实现代码是否相对独立，从而不会“自作多情”的把别人做的事再做一遍<br>接口隔离原则：在单一职责的基础之上，在给调用者提供api接口时，能让调用者很清晰的知道当前所依赖的接口有哪些接口，好比序列化的调用者只想要看到序列化接口，而不希望反序列化的接口也暴露<br>迪米特法则：在争哥总结的迪米特里，前者(尽量不依赖)，我觉得在真实业务系统还是很难做到的，因为业务错综复杂，所有的接口都可能被很多地方引用到，但是对于第二点(只依赖必要的接口)，很多时候还是可以尽量满足的，它其实就是接口隔离原则的体现<br>基于接口而非实现：基于接口而非实现，是上面所有原则的基石！","like_count":1},{"had_liked":false,"id":173116,"user_name":"Treasure","can_delete":false,"product_type":"c1","uid":1177602,"ip_address":"","ucode":"4211ECEB347C3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","comment_is_top":false,"comment_ctime":1579426766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874394062","product_id":100039001,"comment_content":"单一职责原则：一个类，只有一个引起它变化的原因。<br>接口隔离原则：不应该强迫用户依赖它们不需要的方法。（调用者）<br>迪米特法则   ：强调类之间的关系，依赖应该最小花。（模块&#47;类 的依赖关系）<br>基于接口编程而非实现编程：通用原则，一个比较笼统的思想。<br>都是为了实现高内聚，低耦合。","like_count":1},{"had_liked":false,"id":164865,"user_name":"blacknhole","can_delete":false,"product_type":"c1","uid":1098286,"ip_address":"","ucode":"271682FFE28F25","user_header":"https://static001.geekbang.org/account/avatar/00/10/c2/2e/c4a527d9.jpg","comment_is_top":false,"comment_ctime":1577102675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872069971","product_id":100039001,"comment_content":"对耦合的含义或理解方式有些不同看法：<br><br>1，与其从依赖关系来谈松耦合，说它是依赖关系简单清晰，不如从功能的相关性来谈，说它是无关功能不放在一个类中。这时，高内聚的含义就只是相关或相近功能放在一个类中了。<br><br>类之间的依赖关系，在类的设计完成之后，是无法选择和改变的，除非重新设计类。比如，类之间应该依赖时，在不改变类的设计的前提下，无法刻意不依赖或减少依赖。依赖关系简单清晰，只是在对高内聚和松耦合的适度追求之下，设计并实现类之后，自然产生的一个结果。<br><br>2，高内聚和松耦合，都是用来指导类本身的设计的。并非用松耦合来指导类之间依赖关系的设计。换句话说，类之间依赖关系的设计应该包含在类本身的设计之中（事实上，只有类的设计，而不存在什么类之间依赖关系的设计，见下文）。<br><br>在设计一个类时，应该考虑它与其他类的关系，以达到这个类的适度内聚和耦合。在这里，内聚是从功能相关的角度来观察类——有关的功能是不是放在一起了，耦合是从功能无关的相反角度来观察类——无关的功能是不是分散开来了。<br><br>依赖关系是类的设计完成之后，对类之间相关性的描述，有关就叫有依赖关系，无关就叫无依赖关系。所以，并不存在什么对依赖关系的设计，依赖关系是类的设计完成之后的一个自然结果。<br><br>3，这样的理解，对类的设计来说才是更有指导意义的，也才能使概念的边界足够清晰，从而使内聚与耦合的本质更易被准确理解。","like_count":1},{"had_liked":false,"id":164650,"user_name":"逆风星痕","can_delete":false,"product_type":"c1","uid":1420482,"ip_address":"","ucode":"1E18E46E8DA58E","user_header":"https://static001.geekbang.org/account/avatar/00/15/ac/c2/aec60ae2.jpg","comment_is_top":false,"comment_ctime":1577065796,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872033092","product_id":100039001,"comment_content":"感觉所有设计原则和模式，都是为了代码的可读性，复用和扩展而总结出来的。好多原则可能是针对某个场景下提高代码的复用和扩展，这样有时也会辅助其他原则。迪米特原则描述类之间的关系，尽量减少依赖，但也需要类遵循单一职责原则。设计代码的时候，可以根据自己的目的，从参考相应原则的设计","like_count":1},{"had_liked":false,"id":164619,"user_name":"再见孙悟空","can_delete":false,"product_type":"c1","uid":1025518,"ip_address":"","ucode":"57E12A2F9CD915","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/ee/6bbac848.jpg","comment_is_top":false,"comment_ctime":1577061566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872028862","product_id":100039001,"comment_content":"“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”都是为了实现 “高内聚、低耦合”的手段。做到了接口隔离，一般情况下职责也比较单一，基于接口而非实现编程，往往也会降低耦合性。有的时候使用了迪米特法则或者单一职责原则，可能会破坏高内聚原则，这种情况就要具体分析场景，以及使用接口来实现。","like_count":1},{"had_liked":false,"id":164605,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1577058998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872026294","product_id":100039001,"comment_content":"接口隔离感觉就是为了迪米特法则的应用，接口隔离开不需要依赖的类，只引入需要的接口和方法。<br><br>高内聚低耦合，是针对具体的实现类的，实现类实现多个接口，相似的功能都在同一个实现类中完成。<br><br>接口的隔离又保证对外只暴露了调用方需要的方法，外部也不能直接看到不需要的方法。代码结构也更加整洁，逻辑更清晰","like_count":1},{"had_liked":false,"id":358122,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"浙江","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1663921062,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663921062","product_id":100039001,"comment_content":"单一职责原则：一个类只实现一个业务逻辑，不同业务放到不同类<br>基于接口而非实现编程：类之间的依赖，以依赖接口为主，那实现有变动的时候，扩展性好<br>接口隔离原则：不同功能用不同的接口（实现），不要放到一个接口。有点类似单一职责原则<br>高内聚，松耦合：减少不能功能类之间的依赖，这点需要基于接口而非实现原则，而且依赖的越少越好；尽量保持一个类的独立性，这点类似于单一职责原则<br>迪米特法则：有点类似于松耦合，就是类之间尽量不依赖，如果有依赖，也是依赖最小实现","like_count":0},{"had_liked":false,"id":357443,"user_name":"Leo.","can_delete":false,"product_type":"c1","uid":2365468,"ip_address":"广东","ucode":"C876295B3ACCF2","user_header":"https://static001.geekbang.org/account/avatar/00/24/18/1c/70b34d04.jpg","comment_is_top":false,"comment_ctime":1663255878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663255878","product_id":100039001,"comment_content":"定义（自己的理解）：<br>● 高内聚、低耦合：将相似功能的代码（关系紧密）放到同一个类中，使得类的依赖结构清晰，被依赖的类修改不会导致依赖类大幅度改动。<br>● 单一职责原则：一个类或一个模块只负责完成一个功能（职责）<br>● 接口隔离原则：将一组功能拆分，隔离开来，使得各个功能使用者只依赖自己需要的功能代码<br>● 基于接口而非实现编程：也叫基于抽象而非实现编程，使用者依赖抽象接口而非具体实现.，目的是为了提高代码的灵活性，通用性。包含一些设计接口，抽象类的具体建议：命名要足够抽象通用，不要包含具体实现；跟具体实现有关的方法不要定义在接口...<br>● 迪米特法则：不该依赖就不要依赖，能少依赖就少依赖。减少代码之间的耦合（知道得越少，要操心就越少），避免牵一发而动全身。<br><br>关系：<br>● 写出高内聚、低耦合的代码是最终目的。<br>● 适度地使用单一职责原则，使得一个类只负责完成一个职责，结果就是一个类中只包含相近功能的代码，不同功能的代码在不同的类（高内聚）。但如果过度拆分，会破坏代码的内聚性<br>● 接口隔离原则要求我们把一组功能拆分并隔离开来，使得功能使用者只依赖他们需要的部分，有助于我们达成低耦合的目的<br>● 基于接口而非实现编程，也叫基于抽象而非实现编程，是一种面向对象思想，要求我们有抽象意识，编码时，使用者依赖抽象接口而非具体实现，使得代码更灵活、通用。当修改具体实现时，由于使用方只依赖抽象接口而不依赖实现，因此使用方不需要感知具体实现的变化，符合低耦合的思想。同时也符合迪米特法则，使用方只依赖抽象接口，不知道具体实现，因此就不需要操心具体实现的变化<br>● 迪米特法则，要求我们不该依赖就不要依赖，能少依赖就少依赖，因为知道得越少，要操心的东西就越少，符合低耦合的思想。","like_count":0},{"had_liked":false,"id":351407,"user_name":"英雄","can_delete":false,"product_type":"c1","uid":1546612,"ip_address":"","ucode":"D1033C83C6CDE9","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/74/0203bf17.jpg","comment_is_top":false,"comment_ctime":1657771859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657771859","product_id":100039001,"comment_content":"HtmlDownloader是不是不符合依赖倒置原则，高层模块不依赖底层模块？","like_count":0},{"had_liked":false,"id":349300,"user_name":"Geek_02cc48","can_delete":false,"product_type":"c1","uid":3004321,"ip_address":"","ucode":"264B787809476D","user_header":"","comment_is_top":false,"comment_ctime":1655874587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655874587","product_id":100039001,"comment_content":"看不懂啊","like_count":0},{"had_liked":false,"id":343023,"user_name":"顺势而为","can_delete":false,"product_type":"c1","uid":2757858,"ip_address":"","ucode":"FE7D688D24823E","user_header":"https://static001.geekbang.org/account/avatar/00/2a/14/e2/f6f1627c.jpg","comment_is_top":false,"comment_ctime":1650598358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650598358","product_id":100039001,"comment_content":"讲得挺好的，高内聚，低耦合。一般做java的同学比较清楚吧","like_count":0},{"had_liked":false,"id":338230,"user_name":"Echo","can_delete":false,"product_type":"c1","uid":1878585,"ip_address":"","ucode":"1542D4B4154CA9","user_header":"","comment_is_top":false,"comment_ctime":1647363107,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647363107","product_id":100039001,"comment_content":"作为一个写js的前端，表示我太难了，java的例子基本上看不懂。","like_count":0},{"had_liked":false,"id":337367,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1646791819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646791819","product_id":100039001,"comment_content":"迪米特法则实现高内聚，松耦合。<br>单一职责原则有助于写出高内聚的代码。<br>接口隔离原则，基于接口而非实现编程，有助于代码的松耦合。","like_count":0},{"had_liked":false,"id":329106,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1641121927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641121927","product_id":100039001,"comment_content":"思考题：<br>“高内聚、松耦合”是写代码的一个总体指导思想，其他的原则都是实现这个思想的一些具体方法。<br>“单一职责原则”强调模块、类的功能要单一，不相关的功能不应该被纳入，这是实现高内聚的一种方式；<br>“接口隔离原则”用于指导接口设计，强调只设计被调用者调用的接口，与此无关的接口不应该被设计，它是单一职责原则的一种体现，并提供了判断接口职责是否单一的一种判断标准；<br>“迪米特法则”用于指导类之间的依赖关系设计，它强调类与类之间的依赖，应尽量只依赖必要的接口，没有直接依赖关系的类之间不应该出现依赖关系，它体现的是松耦合的设计思想，同时，迪米特法则也蕴含了“单一职责原则”和“接口隔离原则”这两类原则的设计思想。","like_count":0},{"had_liked":false,"id":328145,"user_name":"InHero","can_delete":false,"product_type":"c1","uid":2634637,"ip_address":"","ucode":"F1D09AA0EBABDF","user_header":"https://static001.geekbang.org/account/avatar/00/28/33/8d/767a13ec.jpg","comment_is_top":false,"comment_ctime":1640573822,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1640573822","product_id":100039001,"comment_content":"这个依赖有限关系接口的代码看的可以说是醍醐灌顶啊 ","like_count":0},{"had_liked":false,"id":325895,"user_name":"cloydlau","can_delete":false,"product_type":"c1","uid":1069785,"ip_address":"","ucode":"C21E29ABC754F2","user_header":"","comment_is_top":false,"comment_ctime":1639217685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639217685","product_id":100039001,"comment_content":"用 TS 实现了一下序列化那块的代码：<br><br>interface Serializable {<br>  serialize: (object: object) =&gt; string<br>}<br><br>interface Deserializable {<br>  deserialize: (text: string) =&gt; object<br>}<br><br>class Serialization implements Serializable, Deserializable {<br>  serialize (object: object): string {<br>    return JSON.stringify(object)<br>  }<br><br>  deserialize (text: string): object {<br>    return JSON.parse(text)<br>  }<br>}<br><br>class DemoClass1 {<br>  serializer: Serializable<br><br>  constructor (serializer: Serializable) {<br>    this.serializer = serializer<br>  }<br>}<br><br>class DemoClass2 {<br>  deserializer: Deserializable<br><br>  constructor (deserializer: Deserializable) {<br>    this.deserializer = deserializer<br>  }<br>}<br><br>const demoClass1 = new DemoClass1(new Serialization())<br>const demoClass2 = new DemoClass2(new Serialization())<br><br>console.log(demoClass1.serializer.serialize({}))<br>console.log(demoClass1.serializer.deserialize(&#39;{}&#39;)) &#47;&#47; TS2551: Property &#39;deserialize&#39; does not exist on type &#39;Serializable&#39;. <br><br>console.log(demoClass2.deserializer.deserialize(&#39;{}&#39;))<br>console.log(demoClass2.deserializer.serialize({})) &#47;&#47; TS2551: Property &#39;serialize&#39; does not exist on type &#39;Deserializable&#39;.","like_count":0},{"had_liked":false,"id":325325,"user_name":"天亮前说晚安","can_delete":false,"product_type":"c1","uid":1541014,"ip_address":"","ucode":"1D82EE562A7C71","user_header":"https://static001.geekbang.org/account/avatar/00/17/83/96/73ff13a0.jpg","comment_is_top":false,"comment_ctime":1638925281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638925281","product_id":100039001,"comment_content":"作者的第一个例子，最后的结果就不满足法则。改造后依然问题很大，Document对象可以认为是复杂对象，但是DocumentFactory不应该依赖HtmlDownloder，因为这是具体实现，非接口；第二前面讲到send方法都可能非HtmlRequest，那下载器也可能多个。应该抽离出Downloader接口，DocumentFactory依赖接口。","like_count":0},{"had_liked":false,"id":323708,"user_name":"HomeyLiu","can_delete":false,"product_type":"c1","uid":1330141,"ip_address":"","ucode":"EF4CCB92C369B4","user_header":"https://static001.geekbang.org/account/avatar/00/14/4b/dd/41614582.jpg","comment_is_top":false,"comment_ctime":1638109340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638109340","product_id":100039001,"comment_content":"    public Byte[] send(String address, Byte[] data) {<br>      &#47;&#47;...<br>    }<br>address 是啥东西?Byte[] data又是啥东西,<br>不是下载网页吗?怎么像发送网页.","like_count":0},{"had_liked":false,"id":323073,"user_name":"二小","can_delete":false,"product_type":"c1","uid":1593919,"ip_address":"","ucode":"5377CB552237B2","user_header":"https://static001.geekbang.org/account/avatar/00/18/52/3f/c8b40efe.jpg","comment_is_top":false,"comment_ctime":1637720080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637720080","product_id":100039001,"comment_content":"为什么拆分两个接口之后，修改序列化方式从JSON换成其他方式不是还要修改所有实现吗？","like_count":0},{"had_liked":false,"id":322482,"user_name":"米大王","can_delete":false,"product_type":"c1","uid":1097996,"ip_address":"","ucode":"6D6B644A528F9F","user_header":"https://static001.geekbang.org/account/avatar/00/10/c1/0c/8b83e19b.jpg","comment_is_top":false,"comment_ctime":1637410263,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637410263","product_id":100039001,"comment_content":"目的都是提高扩展性，高内聚、低耦合，只是手段（出发角度）不同：<br>1. 单一职责原则以及对扩展开放，对修改关闭原则是从功能的角度出发；<br>2. 迪米特原则从类之间的关系出发（不该依赖的不依赖，要依赖的最小必要依赖）；<br>3. 接口隔离原则是从接口调用者的角度出发；<br>5. 里式替换原则是从类的继承关系角度出发。<br><br>提高代码可维护性、可读性的设计原则：<br>1. 控制反转<br>2. KISS、YAGNI<br>3. DRY<br><br>-----<br><br>&gt; 目的都是实现高内聚低耦合，但是出发的角度不一样，单一职责是从自身提供的功能出发，迪米特法则是从关系出发，针对接口而非实现编程是使用者的角度，殊途同归。<br>","like_count":0},{"had_liked":false,"id":313571,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1632530019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632530019","product_id":100039001,"comment_content":"迪米特法则<br>高内聚，松耦合，主要主要针对类与类之间。功能类似的方法尽量放到一个类里面，没有关联的类不相互依赖，有关联的尽量用接口。","like_count":0},{"had_liked":false,"id":311905,"user_name":"manx00","can_delete":false,"product_type":"c1","uid":1014356,"ip_address":"","ucode":"CA086E73F179E2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/54/497b1764.jpg","comment_is_top":false,"comment_ctime":1631527057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631527057","product_id":100039001,"comment_content":"“第二，HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。”<br><br>这里说使用new违背了基于接口而非实现编程。那么HtmlDownloader.downloadHtml 里面的为啥没问题：new HtmlRequest(url);","like_count":0},{"had_liked":false,"id":298584,"user_name":"Labin","can_delete":false,"product_type":"c1","uid":2155890,"ip_address":"","ucode":"13659DF0F364C1","user_header":"https://static001.geekbang.org/account/avatar/00/20/e5/72/211a4768.jpg","comment_is_top":false,"comment_ctime":1624204845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624204845","product_id":100039001,"comment_content":"第三，从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。<br><br>这里修改完之后，Document类不也是还依赖了HtmlDownloader吗？","like_count":0},{"had_liked":false,"id":296383,"user_name":"李金鹏","can_delete":false,"product_type":"c1","uid":1445362,"ip_address":"","ucode":"8FCCA5B8BD8DDD","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/f2/3865fe28.jpg","comment_is_top":false,"comment_ctime":1622948948,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622948948","product_id":100039001,"comment_content":"“单一职责原则”、“接口隔离原则”、“基于接口而非实现编程”这些原则的目的其实就是，让代码“高内聚、松耦合”，方便对修改关闭，对扩展开放","like_count":0},{"had_liked":false,"id":292182,"user_name":"栾~龟虽寿！","can_delete":false,"product_type":"c1","uid":1504671,"ip_address":"","ucode":"219B38C08979FE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","comment_is_top":false,"comment_ctime":1620713906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620713906","product_id":100039001,"comment_content":"打卡，工厂模式，不会 ","like_count":0},{"had_liked":false,"id":290708,"user_name":"Dunk","can_delete":false,"product_type":"c1","uid":1691447,"ip_address":"","ucode":"A8F5AB98382719","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/37/6ed137b9.jpg","comment_is_top":false,"comment_ctime":1619695893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619695893","product_id":100039001,"comment_content":"1.高内聚，低耦合：强调类的设计上要保持功能单一，一定程度上与单一职责原则重复；类与类之间的关系应保持简单清晰。<br>2.单一职责原则：强调类、函数的设计上保持功能的彼此独立，减少相互重合。<br>3.接口隔离原则：接口的定义应当彼此分离，不要相互重合。","like_count":0},{"had_liked":false,"id":290240,"user_name":"学员203","can_delete":false,"product_type":"c1","uid":2559640,"ip_address":"","ucode":"63E4B7E3A7E140","user_header":"","comment_is_top":false,"comment_ctime":1619445081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619445081","product_id":100039001,"comment_content":"请问一下，工程创建文档时做了下载功能，又创建文档，这个对于工厂是不是不符合单一职责了？","like_count":0},{"had_liked":false,"id":281695,"user_name":"Emanon","can_delete":false,"product_type":"c1","uid":2430910,"ip_address":"","ucode":"B986F8BB226FB1","user_header":"https://static001.geekbang.org/account/avatar/00/25/17/be/d7d58b48.jpg","comment_is_top":false,"comment_ctime":1614849673,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1614849673","product_id":100039001,"comment_content":"感觉把序列化和反序列化隔离开来并不好。因为序列化和反序列化在逻辑实现是上高度耦合的。应该把它们放到一起来达到对内高内聚，对外低耦合的效果。","like_count":0,"discussions":[{"author":{"id":1012815,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/74/4f/7975c7ee.jpg","nickname":"胡敏And","note":"","ucode":"8FA14B27F47F92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377228,"discussion_content":"这样就很难达到最小知识了吧，拆分成两个接口更加合适，一个类去实现这两个接口，也算是做到了内聚吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622554816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280436,"user_name":"Amber","can_delete":false,"product_type":"c1","uid":2358638,"ip_address":"","ucode":"650FE5C46CCD1C","user_header":"https://static001.geekbang.org/account/avatar/00/23/fd/6e/1913dbb6.jpg","comment_is_top":false,"comment_ctime":1614217087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614217087","product_id":100039001,"comment_content":"“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”<br>高内聚松耦合，是设计总则或目标，比较抽象，难以知道直到具体编码，但需要时刻牢记，同时包含了模块和关系两方面。模块功能要聚合，模块之间关系要松散。<br>单一职责是模块设计要内聚。功能要单一，便于复用。<br>接口隔离，是对模块功能的分类和抽象，将模块提供的能力安功能分组，抽象为稳定接口，这么做是为了避免耦合。<br>基于接口而非实现，是给使用者提的建议，依赖稳定抽象而非易变的实现。为独立变化做好准备。<br>迪米特法则，隶属于设计总则，纲领范畴，接近思想。","like_count":0},{"had_liked":false,"id":280315,"user_name":"DreamHeng","can_delete":false,"product_type":"c1","uid":1599490,"ip_address":"","ucode":"5562BFD8375138","user_header":"https://static001.geekbang.org/account/avatar/00/18/68/02/2d394d89.jpg","comment_is_top":false,"comment_ctime":1614158515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614158515","product_id":100039001,"comment_content":"迪米特原则，实现基础是“高内聚，低耦合”，可以理解是集合了单一职责原则和接口隔离原则。","like_count":0},{"had_liked":false,"id":272957,"user_name":"Geek_897ea4","can_delete":false,"product_type":"c1","uid":1708328,"ip_address":"","ucode":"864B05054D686A","user_header":"","comment_is_top":false,"comment_ctime":1610365080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610365080","product_id":100039001,"comment_content":"相辅相成，只有融汇贯通才能很好的利用。总而言之，如果业务非常简单，就没必要考虑使用太多的设计模式，如果相对复杂。可以一点一点的使用，从最简单的开始做。","like_count":0},{"had_liked":false,"id":266702,"user_name":"落尘","can_delete":false,"product_type":"c1","uid":1802622,"ip_address":"","ucode":"7B76B94CA301D7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/81/7e/fb688b5c.jpg","comment_is_top":false,"comment_ctime":1607443689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607443689","product_id":100039001,"comment_content":"“迪米特法则”是指导如何写出“高内聚、松耦合”的代码的原则。<br>更关注高内聚：“单一职责原则”表示一个“类&#47;函数”只负责一件事，应该将相近的功能尽量放在一起。<br>更关注松耦合：“接口隔离原则”要求不能暴露用户&#47;调用者不需要的功能。“基于接口而非实现编程”强调的是一种松耦合的思想。","like_count":0},{"had_liked":false,"id":252940,"user_name":"@许还真","can_delete":false,"product_type":"c1","uid":1099324,"ip_address":"","ucode":"6D754D5AE44CEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/3c/8ab9deb0.jpg","comment_is_top":false,"comment_ctime":1602521323,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602521323","product_id":100039001,"comment_content":"例子很棒","like_count":0},{"had_liked":false,"id":252242,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1602210851,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602210851","product_id":100039001,"comment_content":"LOD:减少依赖数量（非必要不要建立依赖），降低依赖程度（通过接口而非实例表现依赖，接口隔离）。<br>针对课后问题，我是这么理解：<br>1、高内聚低耦合是最宽泛的原则，单一职责，接口隔离，基于接口而非实现都是实现高内聚低耦合的一种策略。<br>2、接口隔离原则，基于接口而非实现，单一职责也是迪米特法则的应有之意。减少类的依赖关系必然要求单一职责：如果一个类包含了太多的功能，就可能造成冗余的依赖关系。降低类的依赖程度，可以通过通过接口而非实现编程，接口隔离原则两条规则来实现。<br>3、迪米特法则强调的偏向于低耦合，但我们知道低耦合与高内聚是一体两面，从这个角度说，迪米特法则是高内聚低耦合原则的一种实现策略。<br>所以整体上近似有如下的关系：<br>高内聚低耦合-&gt;迪米特法则-&gt;单一职责，接口隔离，基于接口而非实现","like_count":0},{"had_liked":false,"id":251501,"user_name":"Ilearning99","can_delete":false,"product_type":"c1","uid":1989119,"ip_address":"","ucode":"7901836A2C47EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/qOdqzmC507sibL6sichNSDaVmyoMKibEIqHWpic4CftgOQnoA3QKeRPwic9j1Ha8MLtzzqzfSRavR9GWMju09SMADUg/132","comment_is_top":false,"comment_ctime":1601620315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601620315","product_id":100039001,"comment_content":"为了代码的可或扩展性，主要思想需要实现高内聚、低耦合，单一职责是高内聚，接口隔离是低耦合，基于接口而非实现编程是低耦合，迪米特法则，两部分都有。","like_count":0},{"had_liked":false,"id":250960,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1601292026,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1601292026","product_id":100039001,"comment_content":"想知道如何把第一个场景中的代码组合起来，形成一个相对完整的调用。试着写了一小段程序，抛转引玉<br><br>public class DocumentDemo {<br>    public static void main(String[] args)  {<br>        string url = “”;<br>        string address = “”;<br>        Byte[] content = new Byte()[10] ;<br>        HtmlDownloader downloader = new HtmlDownloader(new NetworkTransporter(address, content));<br>        DocumentFactory factory = new DocumentFactory(downloader);<br>        Document document = factory.createDocument(url)<br>    }<br>}<br><br>第二个场景，其实和接口隔离原则比较类似，在多个序列化、反序列的化的场景中，代码确实显得更“漂亮”一些。<br><br>我觉得“高内聚、松耦合”不仅仅在迪米特法则这里突出，而应该是所有八个理论，或者说八个软件设计原则的核心思想。<br><br>相比较而言，“单一职责”更强调高内聚，“接口隔离”突出松耦合，“基于接口编程”也更侧重松耦合，而“迪米特法则”则平衡了“高内聚、低耦合”。","like_count":0},{"had_liked":false,"id":250293,"user_name":"笨鸟","can_delete":false,"product_type":"c1","uid":1236320,"ip_address":"","ucode":"68029ADA76AA5A","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/60/a6a4f79a.jpg","comment_is_top":false,"comment_ctime":1601014652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601014652","product_id":100039001,"comment_content":"高内聚,低耦合是目的,“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”是实现目的的方法","like_count":0},{"had_liked":false,"id":247678,"user_name":"Younger Ku","can_delete":false,"product_type":"c1","uid":1323102,"ip_address":"","ucode":"D157DC38BDB515","user_header":"https://static001.geekbang.org/account/avatar/00/14/30/5e/c42bc33f.jpg","comment_is_top":false,"comment_ctime":1599791895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599791895","product_id":100039001,"comment_content":"高内聚，低耦合：<br>迪米特法则要求只需要依赖自己需要的接口。<br>接口隔离原则可以将接口的功能细分，粒度降低，接口隔离正是为了满足迪米特法则的要求。<br>同时单一职责原则确保每个接口的功能单一，提高内聚性。<br>迪米特法则依赖于依赖倒置原则，面向接口和抽象类编程，因为接口抽象类中的代码属于上层代码，相对来说比较稳定，而实现相对来说变化比较频繁，<br>开闭原则可以确保底层实现能够灵活的切换，而不需要修改被依赖的对象。<br>李氏替换原则使得接口抽象类的实现符合上层定义的规范，替换接口或抽象类的时候可以保证功能不变。<br><br>ps:DRY原则、KISS原则、YAGNI原则目前还不确定是否和提高代码“高内聚，低耦合”有直接的关系！！","like_count":0},{"had_liked":false,"id":246212,"user_name":"宇天飞","can_delete":false,"product_type":"c1","uid":1126444,"ip_address":"","ucode":"3FB37D1E2DAA61","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/2c/06375913.jpg","comment_is_top":false,"comment_ctime":1599209855,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1599209855","product_id":100039001,"comment_content":"“高内聚、松耦合”：指导类的设计、职责分配，又是指导类之间关系的设计。<br>1、类自身：<br>1）“单一职责原则”：实现高内聚、松耦合的一种方式。每个类只有一个职责。<br>2）“接口隔离原则”：从使用者角度去考虑，被调用方职责是否单一。<br><br>2、类之间关系：<br>1）“基于接口而非实现编程”：实现松耦合。类之间的依赖通过关系，通过接口来实现。<br>2）“迪米特法则”：实现高内聚、松耦合的方式之一。类之间的关系设计考量。<br>","like_count":0},{"had_liked":false,"id":245955,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1599120757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599120757","product_id":100039001,"comment_content":"高内聚和低耦合是对代码设计好坏的一种衡量标准。而接口隔离、面向接口编程、迪米特、单一职责都是用来指导我们设计出”高内聚和低耦合“的类。","like_count":0},{"had_liked":false,"id":243935,"user_name":"Geek_6d4513","can_delete":false,"product_type":"c1","uid":2140839,"ip_address":"","ucode":"29B86212B52C60","user_header":"","comment_is_top":false,"comment_ctime":1598331720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598331720","product_id":100039001,"comment_content":"非常接地气，赞赞赞！","like_count":0},{"had_liked":false,"id":241654,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1597382486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597382486","product_id":100039001,"comment_content":"单一职责和接口隔离是实现迪米特法则的重要手段。迪米特法则是更高层次的指导思想","like_count":0},{"had_liked":false,"id":240253,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1065986,"ip_address":"","ucode":"3D3D10273BED18","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/02/5c8e4b81.jpg","comment_is_top":false,"comment_ctime":1596811376,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596811376","product_id":100039001,"comment_content":"<br>高内聚，松耦合  所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中。所谓松耦合指的是，在代码中，类与类之间的依赖关系简单清晰。<br><br>单一职责原则-强调类的职责清晰，只做一件事，强调是高内聚<br>接口隔离原则-强调调用者不要依赖自己不依赖的接口，强调减少接口耦合，是松耦合<br>基于接口而非实现编程--强调基于锲约而非具体实现类，减少具体实现类耦合，是松耦合<br>迪米特法则-强调能不依赖就不依赖，减少外部依赖，是松耦合<br>","like_count":0},{"had_liked":false,"id":238703,"user_name":"汉江","can_delete":false,"product_type":"c1","uid":1788647,"ip_address":"","ucode":"01622D984B8F9B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","comment_is_top":false,"comment_ctime":1596265407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596265407","product_id":100039001,"comment_content":"我在想假设有些类 既要用到系列化，还要用到反序列化 那怎么搞呢  ","like_count":0},{"had_liked":false,"id":235804,"user_name":"夜空咏叹调","can_delete":false,"product_type":"c1","uid":1189074,"ip_address":"","ucode":"CC9350BCF218CD","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d2/a5e272ce.jpg","comment_is_top":false,"comment_ctime":1595207337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595207337","product_id":100039001,"comment_content":"高内聚，松耦合是程序开发中都应该遵守的原则。迪米特法则则是没有逻辑关联的类之间不应该有任何联系，有逻辑关联的类之间应该只通过接口进行关联。","like_count":0},{"had_liked":false,"id":231282,"user_name":"大强","can_delete":false,"product_type":"c1","uid":1737397,"ip_address":"","ucode":"D5C64C5A01B25D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/82/b5/a6049a26.jpg","comment_is_top":false,"comment_ctime":1593626329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593626329","product_id":100039001,"comment_content":"内聚指的是类的相关功能聚合在一起，功能相近或者叫本类的应该有的方法，应该内聚在一起，无关的不要写在一起。单一职责是指导高内聚的一种思想。耦合指的是类之间的依赖关系，高度耦合说明类的依赖关系严重，依赖的多了，任何一个环节有问题，会引发连锁反应，降低风险的方法就是松耦合，实现松耦合的方法有接口隔离原则”“基于接口而非实现编程”“迪米特法则”。接口隔离原则”“基于接口而非实现编程”“迪米特法则”，这三个原则都是站在代码的创建者角度看待问题，如何设计高内聚松耦合的代码","like_count":0},{"had_liked":false,"id":230585,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1593423246,"is_pvip":false,"replies":[{"id":"86375","content":"“很有可能还是需要用到外部对象来解决问题”能举个例子吗？<br>“ 这种情况是不是需要做类扩展，在扩展中再具体引用HtmlRequest” 也可以直接改这个类~，不过还是没太懂你的意思~","user_name":"作者回复","comment_id":230585,"uid":"1190123","ip_address":"","utype":1,"ctime":1594602054,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1593423246","product_id":100039001,"comment_content":"我想知道假如 <br><br>Public class NetworkTransporter { <br>   &#47;&#47; 省略属性和其他方法...    <br> public Byte[] send(HtmlRequest htmlRequest) {      <br><br>   &#47;&#47;...    }}<br>中的send 方法，必须需要HtmelRequest 才能实现功能呢？ 老师修改后，参数上看起来是不依赖外部对象了，但是在很多其他实际操作时，很有可能还是需要用到外部对象来解决问题。 这种情况是不是需要做类扩展，在扩展中再具体引用HtmlRequest ?","like_count":0,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370684,"discussion_content":"感觉这种方式是最容易记住的方式. 另外一种高效的学习方式就是把自己学会的设计讲解给别人听, 教是最快的学","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619509508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224545,"user_name":"马球先生","can_delete":false,"product_type":"c1","uid":1119609,"ip_address":"","ucode":"858C2CE0E494C5","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/79/efde2a69.jpg","comment_is_top":false,"comment_ctime":1591436636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591436636","product_id":100039001,"comment_content":"接口隔离原则：从接口的设计方面来看 要设计小接口 功能单一的 不要设计大而全的接口<br>迪米特法则：从接口的使用者方面来看 用小接口 不需要的接口不用","like_count":0},{"had_liked":false,"id":219185,"user_name":"师哥","can_delete":false,"product_type":"c1","uid":1333376,"ip_address":"","ucode":"A86CD1661D370F","user_header":"https://static001.geekbang.org/account/avatar/00/14/58/80/c9e232b6.jpg","comment_is_top":false,"comment_ctime":1589963026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589963026","product_id":100039001,"comment_content":"我们的目标就是 “高内聚 低耦合” 所以我们遵循迪米特法则，而迪米特法则要基于类的单一职责和基于接口编程而非实现。","like_count":0},{"had_liked":false,"id":211001,"user_name":"Obed","can_delete":false,"product_type":"c1","uid":1399904,"ip_address":"","ucode":"8717488DD14AB4","user_header":"https://static001.geekbang.org/account/avatar/00/15/5c/60/3754399d.jpg","comment_is_top":false,"comment_ctime":1587879932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587879932","product_id":100039001,"comment_content":"最小知识,单一职责,接口隔离,基于接口而非实现编程 都是为了实现 -&gt; 高内聚,低耦合<br>最小知识 更侧重于 低耦合<br>单一职责 更侧重 高内聚<br>接口隔离在前面的课程中分成了三个维度<br>1.一组Api <br>2.一个Api<br>3.OOP中的接口概念<br>其中1,3感觉与最小知识原则类似,<br>个人理解 其中的差别是 最小知识原则更多的是给调用者的限制:调用者应该只依赖于有限的类的有限的接口.而接口隔离法则更多的是给实现者的限制:提供接口的一方所提供的接口需要隔离<br>而接口隔离的第二个维度 是从接口角度去讲单一职责原则<br>基于接口而非实现编程 是强调我们需要有一种抽象思维,面向抽象编程 面向&quot;稳定&quot;编程,将不稳定的实现分离  就如 在最小知识原则中,类应该依赖有限的类,而对这些依赖的类,我们编写时要有抽象的思维<br><br>以上是个人见解 欢迎讨论,指正","like_count":0},{"had_liked":false,"id":207945,"user_name":"拉普达","can_delete":false,"product_type":"c1","uid":1930686,"ip_address":"","ucode":"0E524C0D99B2A0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/75/be/6f3ab95e.jpg","comment_is_top":false,"comment_ctime":1587220312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587220312","product_id":100039001,"comment_content":"我觉得高内聚低耦合是面向对象设计的一个终极目标，下面的几个原则呢都是实现这个目标的方法，但是他们互相之间也是有包含的，比如说单一职责原则能够确保迪米特法则中的前半段要求，针对接口而非实现的编程，又能够保证迪米特法则中的后半段要求。","like_count":0},{"had_liked":false,"id":207449,"user_name":"70","can_delete":false,"product_type":"c1","uid":1081899,"ip_address":"","ucode":"A5884B2BDDAB70","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/2b/cf93c499.jpg","comment_is_top":false,"comment_ctime":1587087678,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587087678","product_id":100039001,"comment_content":"接口隔离原则可以用来判断职责是否单一；基于接口而非实现编程：接口不应该依赖具体的实现，具体的实现应该依赖于接口，其实接口就是就是对于实现的最小认知，符合迪米特法则的最小认知。高内聚是将统一职责的聚合到一起，符合单一职责原则，低耦合是将依赖以最少知道进行依赖，基于接口编程中的接口即是最少知道的。各种原则间相辅相成，共同以高内聚，低耦合为实现目标","like_count":0},{"had_liked":false,"id":206014,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1586773230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586773230","product_id":100039001,"comment_content":"高内聚，相同功能的放在同一个类里面，修改的时候方便集中修改，代码也就容易维护<br><br>迪米拉:就是把不同的方法不要放在一起，减少依赖。<br>解决高内聚和迪米拉冲突的方法，建几个接口，接口包含高内聚的分类的几个方法，然后实现类继承这几个接口。。。。(这也就是接口隔离原则)<br><br><br>当然迪米拉也不是无脑吧不同的方法不要放在一起，这还是要有个度。如果一个类里面就两个方法，就没必要去强拆弄复杂；同理，如果有多个可惜再细分，一些方法可以组成一个群，那么就可以用迪米拉了。","like_count":0},{"had_liked":false,"id":205380,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1586603586,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586603586","product_id":100039001,"comment_content":"【设计模式笔记23】20200411<br>本质上单一职责原则、基于接口而非实现编程和迪米特法则都是为了写出可维护和可读性性好的代码。单一职责也说的是类本身的功能要单一，基于接口而非实现编程是实现上要依赖抽象，依赖抽象是为了应对变化，就像都是生产开关，只要开关本身的功能能实现就可以了，不同厂家的开关就是实现，迪米特法则说的是类与类之间的关系，只依赖必要的类，不需要依赖的放到其他类。","like_count":0},{"had_liked":false,"id":205263,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1586578906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586578906","product_id":100039001,"comment_content":"基于接口而非实现编程：接口是稳定的，而实现是易变的。通过依赖接口来编程，在实现改变的时候，需要更换为另外一个实现类，那此时依赖类的代码不需要调整。<br>迪米特法则：不需要依赖的接口和类就不要依赖，有依赖关系的话，只依赖必要的接口。 依赖必要的接口，这一点跟接口隔离原则很像的；单一指责原则就是将相近的类放在一个类中，函数中。这几个原则都是为了高内聚，低耦合","like_count":0},{"had_liked":false,"id":202826,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586074625,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586074625","product_id":100039001,"comment_content":"思考题：区别就是每个原则都有自己的关注角度。联系就是这些原则都是为了提高代码的可读性与可维护性的。这里的可读性，个人感觉称为可理解性会更适当一些。","like_count":0},{"had_liked":false,"id":201339,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1585753199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585753199","product_id":100039001,"comment_content":"高内聚：把功能类似的方法和类放到一起。<br>低耦合：类和类之间的依赖关系清晰明了，不会过度依赖。<br>迪米特法则：不该直接有依赖关系之间的类，就不要依赖。有依赖关系，尽量只依赖必要的接口。","like_count":0},{"had_liked":false,"id":200837,"user_name":"Six","can_delete":false,"product_type":"c1","uid":1220617,"ip_address":"","ucode":"E297BB638B2BD9","user_header":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","comment_is_top":false,"comment_ctime":1585659532,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585659532","product_id":100039001,"comment_content":"高内聚、松耦合是一种设计思想，写出的代码要符合这种思想离不开“单一职责原则”“接口隔离原则”“基于接口而非实现编程”,“迪米特法则”。<br>而单一职责原则 指导的是模块，类，方法设计要单一。是实现“高内聚”的一种法则<br>&quot;接口隔离原则&quot;在不同的角度有不同的理解，在一组接口设计中只提供给高层调用者依赖的方法,而在方法设计中,方法实现只存在该方法实现的必要逻辑。本质上还是实现高内聚<br>“基于接口而非实现编程”是基于面向对象多态思想，从而让代码易扩展，易复用。而如果作为高层调用者来说，只依赖接口而非实现。这样就符合“松耦合”<br>而“迪米特法则”则是综合了“单一职责”，“接口隔离原则”，“基于接口而非实现编程”。<br><br>结论<br>“单一职责”，“接口隔离原则”，“基于接口而非实现编程”<br>促成了“高内聚、松耦合” <br>“迪米特法则”则是体现了“高内聚、松耦合”<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493344,"discussion_content":"多看几遍就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588041909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200784,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1585650512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585650512","product_id":100039001,"comment_content":"相互矛盾，相互影响，相互促进，但是对软件开发的易扩展，易维护，灵活性相辅相成","like_count":0},{"had_liked":false,"id":197905,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585403077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585403077","product_id":100039001,"comment_content":"说实话我一直记不住迪米特法则的含义，直到昨天给一个同事讨论我说如非必要不要把一个类过度暴露给其他类使用，我不知道专业术语怎么说，今天看到最小知识原则我就秒懂，我想表达的就是这个意思，虽然这个法则更适用于接口层次","like_count":0},{"had_liked":false,"id":196546,"user_name":"黑客时间","can_delete":false,"product_type":"c1","uid":1831324,"ip_address":"","ucode":"7E22D76EECAC4D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/f1/9c/cd12361d.jpg","comment_is_top":false,"comment_ctime":1585292544,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585292544","product_id":100039001,"comment_content":"高内聚，低耦合是目的，其他的设计原则都是为了实现高内聚，低耦合的目的","like_count":0},{"had_liked":false,"id":194776,"user_name":"然","can_delete":false,"product_type":"c1","uid":1347648,"ip_address":"","ucode":"43B7D3896D706B","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/40/dfa19744.jpg","comment_is_top":false,"comment_ctime":1585105212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585105212","product_id":100039001,"comment_content":"迪米特法则：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口","like_count":0},{"had_liked":false,"id":190894,"user_name":"BestKF02","can_delete":false,"product_type":"c1","uid":1337753,"ip_address":"","ucode":"74356EAB5351CE","user_header":"https://static001.geekbang.org/account/avatar/00/14/69/99/a817330d.jpg","comment_is_top":false,"comment_ctime":1584706406,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584706406","product_id":100039001,"comment_content":"讲得非常棒，越看越有精神了 ^==^","like_count":0},{"had_liked":false,"id":189055,"user_name":"嘻哈","can_delete":false,"product_type":"c1","uid":1402535,"ip_address":"","ucode":"AEE1512822A399","user_header":"https://static001.geekbang.org/account/avatar/00/15/66/a7/5b7a7523.jpg","comment_is_top":false,"comment_ctime":1584450817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584450817","product_id":100039001,"comment_content":"软件工程提倡“高内聚、低耦合”，那么，可简单认为“高内聚、低耦合”是一个“纲”。而“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”这些内容是服务于这个“纲”，可认为这原则都是为了提高“高内聚、低耦合”的不同形式实现罢了。<br>单一设计原则提高功能单一或者尽可能的将相同功能组合在一起，那么这就提高了 内聚性<br>接口隔离原则即是将一组接口功能&#47;用途相同的接口放在一起，是接口化的单一设计原则，同样提高了内聚性<br>基于接口编程而非实现编程利用多态，将功能插拔到另一个类中，即使发生变化，也会做出很少修改，降低了类之间的依赖，这样就降低不同模块之间的耦合性<br>迪米特法则是指不要依赖没有依赖关系，即使有依赖，也要依赖最小（接口），同样描述类与类之间的关系，目的降低依赖性，实际就是松耦合<br>所以，这些知识都是在“高内聚、松耦合”的框架下以不同形式（自身设计、依赖设计）服务这个框架，目的就是提高软件系统的内聚和降低耦合","like_count":0},{"had_liked":false,"id":188319,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1584339513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584339513","product_id":100039001,"comment_content":"感觉思想都差不多，只是看问题的角度不一样。要达到的目的也是一样的，就像每个人对相同的东西都有不同的理解。","like_count":0},{"had_liked":false,"id":187703,"user_name":"yan","can_delete":false,"product_type":"c1","uid":1667264,"ip_address":"","ucode":"BA33B672798AEE","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/c0/b365a317.jpg","comment_is_top":false,"comment_ctime":1584195559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584195559","product_id":100039001,"comment_content":"单一职责原则：类、接口或模块自身，只完成一个职责或者功能，避免设计一个大而全的类。<br>接口隔离原则：侧重于接口的设计，提供了判断接口职责是否单一的标准。仅提供外部需要的接口。<br>基于接口而非实现编程：强调抽象意识，提高代码的灵活性和可扩展性。<br>迪米特法则：强调类与类之间的依赖关系，只依赖需要的接口和类。不需要的不要依赖。<br>","like_count":0},{"had_liked":false,"id":181737,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1582625733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582625733","product_id":100039001,"comment_content":"首先是联系,我认为,单一职责原则,是从设计者的角度,设计类的功能,从而保证高内聚,而接口隔离原则,则是在调用者的来说,是类和类之间解耦,上层系统和下层系统依赖于接口,基于接口而非实现编程,则是开发者的角度来说,我们需要将具体的实现细节封装起来,只暴露出抽象的接口,让调用者和被调用者足够解耦,迪米特法则,本质上来说,就是说明高内聚,低耦合.其中我认为迪米特原则和接口隔离原则有异曲同工之妙,都是只将调用者需要的功能进行暴露<br>区别则是,上面的每一种设计原则,其实是从不同的角度去体现了高内聚,松耦合的原则,具体含义有所不同","like_count":0},{"had_liked":false,"id":181701,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1582620417,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582620417","product_id":100039001,"comment_content":"”高内聚、松耦合“ 是分别从类本身和类间关系分析的；<br>单一职责原则和高内聚是互相契合的；<br>接口隔离原则和松耦合也是互相契合的；<br>”基于接口而非实现“则是一种可行的操作，可以去实现上述的两个原则和”高内聚、松耦合“的特点。","like_count":0},{"had_liked":false,"id":179119,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1581922972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581922972","product_id":100039001,"comment_content":"“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？<br><br>高内聚，松耦合：把功能相关的放在一个类中，不相关的不放在一起。<br><br>单一职责原则：每个类或模块只干一件事情，保持功能单一。<br><br>接口隔离原则：跟单一职责类似，但是仅仅局限于接口，一个接口只干一件事情。<br><br>基于接口而非实现编程：依赖抽象，不依赖具体。<br><br>迪尔米特法则：不该有依赖关系的类之间，不能有依赖；该有依赖关系的类之间，尽量依赖必要的接口。<br><br><br><br>如有理解错的，望大佬们纠正！<br>","like_count":0},{"had_liked":false,"id":177401,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1581388429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581388429","product_id":100039001,"comment_content":"“高内聚、松耦合原则”：使用了“单一职责原则”实现高内聚。使用“接口隔离原则”实现低耦合。<br><br>“单一职责原则”：一个类只做一件事情。<br><br>“接口隔离原则”：使用“单一职责原则”，一个接口的功能尽量单一。<br><br>“基于接口而非实现编程”：类与类之间只依赖于接口，而非实现。<br><br>“迪米特法则”：使用“基于接口而非实现编程”，类与类之间只依赖于接口，而非实现。使用“高内聚、松耦合”，有关联关系的才会内聚再一起。","like_count":0},{"had_liked":false,"id":176959,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1581236645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581236645","product_id":100039001,"comment_content":"一个设计良好的软件看上去是高内聚，低耦合的。每一个模块得职责足够单一， 从逻辑上足够一致，并且提供的功能根据接口隔离原则切分得更细。模块之间的依赖做到了最小化，并且模块的依赖是根据接口去描述的，只依赖所必须的接口。","like_count":0},{"had_liked":false,"id":176957,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1581236122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581236122","product_id":100039001,"comment_content":"“高内聚、松耦合” 描述了模块本身与模块之间的性质<br>“单一职责原则” 描述了模块本身的性质<br>“接口隔离原则” 描述了模块应该以一种怎样的方式提供接口，即提供最小化依赖<br>“基于接口而非实现编程” 描述了模块的开发过程<br>迪米特法则 与接口隔离原则类似，不过是从调用者的角度去看该如何做到最小化依赖<br><br><br>“迪米特法则”<br><br><br>","like_count":0},{"had_liked":false,"id":175788,"user_name":"STAND ALONE COMPLEX","can_delete":false,"product_type":"c1","uid":1595002,"ip_address":"","ucode":"2AC2F9B0A6D823","user_header":"https://static001.geekbang.org/account/avatar/00/18/56/7a/60c3d6a5.jpg","comment_is_top":false,"comment_ctime":1580827607,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1580827607","product_id":100039001,"comment_content":"王老师，您好！对于最后一个例子，我有个疑问，Serializable只负责序列化，Deserializable只负责反序列化，Serialization接口实现这两个接口，我们无论是序列化还是反序列化时，实际用到的都是Serialization接口实现类，那么如果在Spring中定义Spring Bean时，需要定义Serializable和Deserializable的两个接口的Bean，但他们实际引用的都是Serialization接口实现类，总觉得对于一个实现类定义了两个Bean，只是接口不同，这样很别扭，实际开发中，这种情况又是怎样做的呢？","like_count":0,"discussions":[{"author":{"id":1788647,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/4a/e7/6c16af5d.jpg","nickname":"汉江","note":"","ucode":"01622D984B8F9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295624,"discussion_content":"我也有这样的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596265801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172417,"user_name":"沐夜星光","can_delete":false,"product_type":"c1","uid":1447220,"ip_address":"","ucode":"22F699E237B179","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","comment_is_top":false,"comment_ctime":1579172979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579172979","product_id":100039001,"comment_content":"序列和反序列的类通过interface拆分成两个类后，两个类的实现不是相互依赖的吗？两个类必定一起改动的吧，没有减少测试工作量啊。","like_count":0},{"had_liked":false,"id":168858,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1578202435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578202435","product_id":100039001,"comment_content":"打卡<br>高内聚:指导类本身设计，相同功能放到同一个类中，不同功能，放到不同类中。<br>松耦合:指导类与类之间的设计，类与类之间的依赖关系简单，清晰。<br>迪米特法则:不该有直接依赖关系的类之间，不要有依赖，有依赖关系的类，尽量只依赖必要的接口。","like_count":0},{"had_liked":false,"id":167104,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1577692333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577692333","product_id":100039001,"comment_content":"高内聚: 相同的功能尽量放到同一个类中 用于指导类的设计<br>松耦合:  类与类之间的依赖关系 简单而清晰，不会因为改动一个类而影响另外一个类 用于指导类与类之间的设计<br>单一职责原则: 不光是类 可以是模块，函数 甚至是框架 让功能尽量单一 指导范围更广<br>基于接口而非实现编程: 两个方面 1. 扩展性 2. 隔离职责<br>迪米特法则: 不该有直接依赖关系的类之间，不要有依赖关系，就算是要依赖也要依赖与必要的接口 减少代码的耦合性<br>他们之间的联系在于都是为了 高内聚 低耦合，区别如以上整理","like_count":0},{"had_liked":false,"id":166836,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1577610104,"is_pvip":false,"replies":[{"id":"64855","content":"使用组合能不能解决复用问题呢","user_name":"作者回复","comment_id":166836,"uid":"1190123","ip_address":"","utype":1,"ctime":1577669773,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1577610104","product_id":100039001,"comment_content":"老师 我有一个问题：在项目开发中，我写了一个类A 里面定义了一个方法，后来又写了一个类B 发现在B里面要用到A里面定义的那个方法(基本上一模一样)，但是A跟B本身是两个不相关的类 这个时候要怎么解决? PS:这个方法不能算作是工具类，只是一段数据集的处理逻辑 那是否是搞一个抽象类 然后让A和B继承这个抽象类 把那个方法写进抽象类里?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479648,"discussion_content":"使用组合能不能解决复用问题呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577669773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1464006,"avatar":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","nickname":"斐波那契","note":"","ucode":"85E2EBC01392B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109307,"discussion_content":"使用组合貌似改动有点大 不想就为了十几行逻辑就整那么复杂 其他同事肯定不会同意这么干的 课程里也说了 不要尝试别人不熟悉的东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577681866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166666,"user_name":"志振爱咋滴咋滴","can_delete":false,"product_type":"c1","uid":1237624,"ip_address":"","ucode":"E7A5049920C101","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/78/9241b7b2.jpg","comment_is_top":false,"comment_ctime":1577539793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577539793","product_id":100039001,"comment_content":"单一职责原则体现在高内聚的部分，一个类只做一件事，修改时也只需修改一个地方，避免影响<br>接口隔离也是基于单一职责，针对让接口更加独立而互不影响<br>基于接口而非实现编程，则是针对调用者的方便程度，避免修改底层代码的时候影响到了上层的调用者<br>迪米特法则则更像是利用接口隔离原则的下层实现部分的使用，减少依赖接口的数量来实现<br>彼此直接都是针对一个部分的具体操作，有上层和下层的考量，有调用者和实现者的考量<br>但其目的，都是为了实现高内聚，低耦合的设计目标。","like_count":0},{"had_liked":false,"id":166568,"user_name":"prowu","can_delete":false,"product_type":"c1","uid":1000532,"ip_address":"","ucode":"F7866D8DEA0FBB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/54/7e40e592.jpg","comment_is_top":false,"comment_ctime":1577504140,"is_pvip":false,"replies":[{"id":"65157","content":"这个也要具体问题具体分析 跟我们讲的vo bo很像","user_name":"作者回复","comment_id":166568,"uid":"1190123","ip_address":"","utype":1,"ctime":1577952241,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1577504140","product_id":100039001,"comment_content":"一直有一个消息结构与程序内部数据结构取舍的问题：程序内部是否直接复用消息协议的结构？比如：通讯消息使用的是protobuf协议，那程序内部的逻辑是直接使用protobuf的数据结构，还是自己在定义一套结构体？如果直接使用protobuf协议，那程序就紧耦合于协议了（这边就是与protobuf绑在一起了），如果自己在定义一套结构体，那就要多一层协议与内部结构的转换。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479542,"discussion_content":"这个也要具体问题具体分析 跟我们讲的vo bo很像","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577952241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1000532,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/54/7e40e592.jpg","nickname":"prowu","note":"","ucode":"F7866D8DEA0FBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114069,"discussion_content":"在您的工程实践经验中，能几个例子吗？其实是想学习和借鉴下您对这类问题的把握和权衡的思路。谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577955256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166130,"user_name":"ChenJz","can_delete":false,"product_type":"c1","uid":1003992,"ip_address":"","ucode":"AF2F8D9015BE5D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/d8/71ef5aa1.jpg","comment_is_top":false,"comment_ctime":1577408046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577408046","product_id":100039001,"comment_content":"在类与类之间的关系中，要做到最小依赖。例如，我只想知道钱包里面有多少钱，你只需要告诉我钱的数量即可，而不是把整个钱包传给我让我去找。其实在日常开发中我们也遇到这种问题，有些人会把整个大对象给你，美其名曰为了以后得扩展，你需要什么就在里面取就好了，万一之后需求会改动，也能满足。","like_count":0},{"had_liked":false,"id":165757,"user_name":"麻婆豆腐","can_delete":false,"product_type":"c1","uid":1731885,"ip_address":"","ucode":"F371FE05D081D6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/6d/2d/de41f9cf.jpg","comment_is_top":false,"comment_ctime":1577318886,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577318886","product_id":100039001,"comment_content":"单一职责原则，主要指导类，模块接口的设计，要求是功能单一，<br>接口隔离原则，主要是接口的设计，并且判断标准是调用是否使用了接口的全部功能，如果没有则不单一<br>迪米特法则，主要是高内聚松耦合中的松耦合，让类之间的依赖清晰，减少非必须的依赖，尽量依赖必要的接口","like_count":0},{"had_liked":false,"id":165491,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1577244952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577244952","product_id":100039001,"comment_content":"设计模式_22:<br># 作业<br>我认为，“高内聚，松耦合”更加底层，其他的原则更像是不同方向的应用。<br><br># 感想：<br>“高内聚，松耦合”，好像是每一个学过计算机课程的人都熟记的概念，很多人也会在简历中写这一点，但是不同的人对于原则的理解程度是不同的，这些差异来自与信息量：<br>今天聊到设计原则是怎么来的，就是来自于之前的实践经验，发现并使用原则真实地解决了当时的问题，然后原则以“高内聚，松耦合”这样极简的文字流传下来，而其他的信息量全部丢失。<br>我们都有过这样的经历，真正地实践后，犯错后，发现自己真正理解了一个道理，虽然你早已听说过它。<br><br>其实实践的过程，就是信息量补充的过程；想要真正地理解这些原则，依然需要经历这些实践，需要这些信息量。","like_count":0},{"had_liked":false,"id":165262,"user_name":"小毅","can_delete":false,"product_type":"c1","uid":1016799,"ip_address":"","ucode":"5651C740D68038","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/hg9Tsg2iaBeG6Q5mxiczjw1ph0OvhKziblEIiaOxg4gwQ0Dgia7Fw7pDQ0mM8AL5SJAm2Yavk1RmBJrFd9jKPBQRkOw/132","comment_is_top":false,"comment_ctime":1577190437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577190437","product_id":100039001,"comment_content":"对于第一个例子我个人觉得将NetworkTransporter 类的send方法对应的HtmlRequest中属性拉平，还不如调整更为贴切的名字～ 对于公共方法过多的参数其实不太好维护～","like_count":0},{"had_liked":false,"id":164904,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1577108835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577108835","product_id":100039001,"comment_content":"个人觉得，单一职责原则、接口隔离原则、基于接口而非实现编程、迪米特法则都是实现高内聚和低耦合在不同角度的更加落地的思考。高内聚、低耦合是一个顶层目标，而这些原则是这个目标的不同角度的思考，比如接口隔离原则，基于接口而非实现编程是从接口的角度来思考。单一职责原则是从模块、类的角度来思考。而迪米特法则强调units之间不该有的关系就不要有，最好关系是清清楚楚，明明白白的。","like_count":0},{"had_liked":false,"id":164881,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1577104322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577104322","product_id":100039001,"comment_content":"同: 都是为了保证代码的稳定性，在变化的情况下，影响最小，不过各自纬度可能不同。<br>单一职责原则: 基于功能点，要结合业务来考虑是否职责是否单一<br>基于接口而非实现编程: 是基于变化的点，为了应对变化<br>“接口隔离原则”和“迪米特法则”: 没太区分开。我目前理解是一样的，在于对调用方的关系上面，做到无关的不用理解。<br>“高内聚、松耦合”: 是总的原则，类似于纲领，这个没太理解，总是挂嘴上，但是感觉有点模糊?<br><br>提问:<br>类似与序列化类的问题，代码的重构是渐进的。比如一开始，<br>class A{<br>    &#47;&#47;序列化<br>    a();<br>    &#47;&#47;反序列化<br>    b();<br>}<br>当有一天，有3个序列化和3个反序列化方法的时候，准备拆分了，就像文中一样，实现两个接口，代码重构一下即可以让每个调用方知道最少，符合迪米特法则,应用内部修改确实没什么问题。但是比如dubbo服务，如果一开始没拆开，后面想拆开。又要考虑向前兼容的问题，目前的做法就是class A 实现2个接口，新增6个方法，有2个和原来的序列化反序列化一样，标记旧的过期。通常还有什么更好的办法么？","like_count":0},{"had_liked":false,"id":164817,"user_name":"Kang","can_delete":false,"product_type":"c1","uid":1237655,"ip_address":"","ucode":"088A8DA0A16BDE","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","comment_is_top":false,"comment_ctime":1577095306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577095306","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":164734,"user_name":"yes","can_delete":false,"product_type":"c1","uid":1386201,"ip_address":"","ucode":"612BF6884ED6CC","user_header":"https://static001.geekbang.org/account/avatar/00/15/26/d9/f7e96590.jpg","comment_is_top":false,"comment_ctime":1577083802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577083802","product_id":100039001,"comment_content":"我认为所有的设计原则和设计模式都是为了达到高内聚、松耦合的目的，而设计原则是指导思想，设计模式是前人根据设计原则再结合常见痛点得出的具体落地方案。<br><br>按照指导思想设计出来的代码就是会符合高内聚、松耦合。<br><br>指导思想之间也是相辅相成的。<br><br>单一职责思考的角度是功能方面，一个类一个模块职责单一，而迪米特法则考虑的是最小化依赖原则，也就是在职责单一的情况下再深挖，尽可能的减少类之间的依赖关系，以达到松耦合的目的。<br><br>并且在这个过程中我们肯定选择的是基于接口而非实现编程，依赖抽象而不是依赖实现。在这种情况下再考虑最小化依赖原则，我们肯定是想剥除接口里面一些此场景下不需要的方法，因此接口隔离原则就运用上了。<br><br>也就是说平日我们开发中需要时刻的想着这几种原则，它们分别从不同的角度来指导我们。但是盲目的运用是没必要的，一个再也简单两三个方法纷纷运用上这些原则，就过犹不及了，要想着KISS。<br><br>代码是持续改进、不断重构的。","like_count":0},{"had_liked":false,"id":164726,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1577083055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577083055","product_id":100039001,"comment_content":"课堂讨论：<br><br>在今天的讲解中，我们提到了“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？<br><br><br><br>Answer:<br><br>1.高内聚与单一职责原则：<br><br>​    高内聚形容类聚焦于本身的职责，是单一职责原则的具体体现。换句话说，遵守了单一职责原则而设计出的类，具有高内聚的特性。<br><br><br><br>2.松耦合与接口隔离原则：<br><br>​    低耦合形容类尽可能少的依赖其他类（接口），是接口隔离原则的具体体现。如果遵守接口隔离原则，就能设计出松耦合的类。<br><br><br><br>3.基于接口而非实现编程与迪米特法则<br><br>​    基于接口而非实现编程是一种面向对象设计思想，通过接口依赖而非具体类依赖的方式达到类之间松耦合的目的。<br><br>​    此思想一定意义上沉淀为迪米特法则：解耦类之间的依赖关系，能不依赖的，就不要依赖；必须依赖的，要依赖接口，而不依赖实现。总而言之：基于接口而非实现编程是形而上的飘渺思想，迪米特法则是萃取思想精华的戒律清规。在每日的修行中：遵守戒律，参悟思想，才能有所精进。","like_count":0},{"had_liked":false,"id":164711,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1577079926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577079926","product_id":100039001,"comment_content":"打卡～<br>1.不该有直接依赖关系的类之间，不要有依赖；<br>2.有依赖关系的类之间，尽量只依赖必要的接口。<br>","like_count":0},{"had_liked":false,"id":164679,"user_name":"pines","can_delete":false,"product_type":"c1","uid":1200708,"ip_address":"","ucode":"7B925605B36B4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/44/de7f2b98.jpg","comment_is_top":false,"comment_ctime":1577071265,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577071265","product_id":100039001,"comment_content":"高内聚:指将将相近的功能封装在一个类或者模块中，不要包含语义不相干的功能，是类或者模块本身的设计原则<br>松耦合:是模块与模块、类与类之间的依赖关系。依赖的模块只包含我依赖的功能，没有附件功能。尽量让依赖关系成线性<br><br>单一职责:是实现高内聚与松耦合的编程手段。每一个api，每一个类，每一个模块的职责要尽可能的单一<br>基于接口编程:多而小的接口相互组合，让松耦合变得更加容易实现","like_count":0},{"had_liked":false,"id":164671,"user_name":"Askerlve","can_delete":false,"product_type":"c1","uid":1178535,"ip_address":"","ucode":"BF29F9A8674507","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/a7/12c90699.jpg","comment_is_top":false,"comment_ctime":1577069927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577069927","product_id":100039001,"comment_content":"打卡，把自己知道的有层次的讲出来，让人易懂，真是一门学问呢～","like_count":0},{"had_liked":false,"id":164661,"user_name":"evolution","can_delete":false,"product_type":"c1","uid":1088402,"ip_address":"","ucode":"105C59822BF75B","user_header":"https://static001.geekbang.org/account/avatar/00/10/9b/92/c0863297.jpg","comment_is_top":false,"comment_ctime":1577067981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577067981","product_id":100039001,"comment_content":"理论解读与代码实战二的解决办法，让我一下子明白了框架源码为何那么写","like_count":0},{"had_liked":false,"id":164653,"user_name":"哈喽沃德","can_delete":false,"product_type":"c1","uid":1749033,"ip_address":"","ucode":"7620366C16826B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b0/29/7ab573f4.jpg","comment_is_top":false,"comment_ctime":1577066263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577066263","product_id":100039001,"comment_content":"期待看设计模式的讲解","like_count":0},{"had_liked":false,"id":164647,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1577065283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577065283","product_id":100039001,"comment_content":"这些设计原则之间有时候看似矛盾，实则相互制衡，这应该是告诉我们代码设计讲究一个平衡。这个平衡就是可维护，可扩展，可读性。","like_count":0},{"had_liked":false,"id":164634,"user_name":"小畅","can_delete":false,"product_type":"c1","uid":1322880,"ip_address":"","ucode":"D031CC07CD564E","user_header":"","comment_is_top":false,"comment_ctime":1577063510,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577063510","product_id":100039001,"comment_content":"打卡 需要思考下","like_count":0},{"had_liked":false,"id":164631,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1577063338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577063338","product_id":100039001,"comment_content":"对于讨论题我是这样理解的:<br>“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则” 都是意在指导我们写的代码变的 “高内聚、松耦合”。 以编写类的角度，在我看来这么多的原则中比较核心的点是，职责单一和面向接口这两点，同时考验个人对业务的抽象能力。<br><br>总结一下设计原则的学习感受吧:<br>整体来说有些收获，对设计原则有了一个整体的认识，但仍需巩固，后面应该会整理一个笔记出来。<br>在应用方面仍有些模糊，感觉原则方面只是起到一个指导方向的作用，实际编写代码的过程中还是经验和业务作为主导，多应用多总结吧。","like_count":0},{"had_liked":false,"id":164630,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1577063227,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1577063227","product_id":100039001,"comment_content":"这几个概念“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”共性很明显，主要说下区别。它们强调的重点有所不同，“高内聚，低耦合”强调的是整体架构设计，包括类本身的设计以及类与类关系的设计，可以理解为是我们软件设计的目标。“单一职责原则”是强调“类&#47;模块&#47;函数”本身的设计，告诉我们对于个体应该如何设计。“接口隔离原则”强调类与类之间的设计，强调它们应该依赖于接口。“基于接口而非实现编程”强调的也是类之间的设计，是一种具体的设计方法，基于组合的方法。“迪米特法则”强调的是类与类和类之间的设计，是实现高内聚低耦合的具体指导方法。","like_count":0},{"had_liked":false,"id":164617,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1577061081,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577061081","product_id":100039001,"comment_content":"文中:高内聚有助于松耦合，松耦合又需要高内聚的支持。  感觉这句话说的两点应该是一个意思吧，都是在说松耦合是基于高内聚来实现的","like_count":0}]}