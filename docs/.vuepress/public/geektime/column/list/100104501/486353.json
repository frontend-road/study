{"id":486353,"title":"13｜高性能网络实战（下）：如何完善负载均衡器？","content":"<p>你好，我是倪朋飞。</p><p>上一讲，我带你使用 sockops 和 sk_msg 等套接字 eBPF 程序，在内核态对套接字进行转发，提升了负载均衡的性能。</p><p>对于网络优化来说，除了套接字 eBPF 程序，XDP 程序和 TC 程序也可以用来优化网络的性能。特别是 XDP 程序，由于它在 Linux 内核协议栈之前就可以处理网络包，在负载均衡、防火墙等需要高性能网络的场景中已经得到大量的应用。</p><p>XDP 程序在内核协议栈初始化之前运行，这也就意味着在 XDP 程序中，你并不能像在 sockops 等程序中那样直接获得套接字的详细信息。使用 XDP 程序加速负载均衡，通常也就意味着需要从头开发一个负载均衡程序。这是不是说 XDP 的使用就特别复杂，需要重新实现内核协议栈的很多逻辑呢？不要担心，<strong>XDP 处理过的数据包还可以正常通过内核协议栈继续处理，所以你只需要在 XDP 程序中实现最核心的网络逻辑就可以了</strong>。</p><p>今天，我就以 XDP 程序为例，带你继续优化和完善负载均衡器的性能。</p><h2>案例准备</h2><p>跟上一讲类似，为了方便环境的重现，负载均衡器、Web 服务器以及客户端都还是运行在容器中，它们的 IP 和 MAC 等基本信息如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/15/e923026f577f7b991be2610734f9e415.jpg?wh=1920x1706\" alt=\"图片\"><br>\n执行下面的命令，启动这几个容器：</p><pre><code class=\"language-bash\"># Webserver\ndocker run -itd --name=http1 --hostname=http1 feisky/webserver\ndocker run -itd --name=http2 --hostname=http2 feisky/webserver\n\n# Client\ndocker run -itd --name=client alpine\n\n# LB\ndocker run -itd --name=lb --privileged -v /sys/kernel/debug:/sys/kernel/debug alpine\n</code></pre><!-- [[[read_end]]] --><blockquote>\n<p>小提示：在默认安装的 Docker 环境中，假如你没有运行其他容器，运行上述命令后得到的 IP 地址跟图中是相同的。</p>\n</blockquote><p>注意，我们把作为负载均衡器的 Nginx 换成了基于 alpine 镜像的 SHELL 容器，并且以特权容器的方式运行，以便有足够的权限加载并运行 XDP 程序。</p><p>把 XDP 程序放入容器中，除了容易复现案例环境之外，在开发和调试 XDP 程序的过程中也不会影响主机的网络（否则，错误的 XDP 程序可能导致主机网络中断，进而也会影响远程 SSH 连接）。</p><p>由于负载均衡容器只启动了一个 SHELL 环境，并没有运行真正的负载均衡服务。此时，访问负载均衡器的 TCP 80 端口会直接失败。你可以运行下面的命令到客户端容器中验证（<code>/ #</code> 后的命令表示在容器终端中运行）：</p><pre><code class=\"language-bash\">docker exec -it client sh\n/ # apk add curl --update\n/ # curl \"http://172.17.0.5\"\ncurl: (7) Failed to connect to 172.17.0.5 port 80 after 1 ms: Connection refused\n</code></pre><p>案例所需的容器环境启动完毕后，接下来我们再来看看，如何使用 XDP 开发一个负载均衡服务。由于需要把 XDP 字节码放到容器中运行，本着最小依赖的原则，我们将使用 libbpf 作为 XDP 的基础库，这样只需要把编译后的二进制文件放入容器中即可运行。</p><h2>如何用 XDP 开发一个负载均衡器？</h2><p>还记得我在<a href=\"https://time.geekbang.org/column/article/484372\"> 08 讲</a> 中提到过的基于 libbpf 开发 eBPF 程序的基本步骤吗？不记得也没关系，我们再来回顾一下。 libbpf 的使用通常分为以下几步：</p><ol>\n<li>开发 eBPF 程序，并把源文件命名为 <code>&lt;程序名&gt;.bpf.c</code>；</li>\n<li>编译 eBPF 程序为字节码，然后再调用&nbsp;<code>bpftool gen skeleton</code>&nbsp;为 eBPF 字节码生成脚手架头文件；</li>\n<li>开发用户态程序，引入生成的脚手架头文件后，加载 eBPF 程序并挂载到相应的内核事件中。</li>\n</ol><p>接下来，我们就按这几个步骤来开发 XDP 负载均衡程序。</p><h3>开发 XDP eBPF 程序</h3><p>第一步是开发一个运行在内核态的 eBPF 程序。参考内核中 BPF_PROG_TYPE_XDP 程序类型的<a href=\"https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf_types.h#L11\">定义格式</a>，它的参数类型为 <a href=\"https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L5283\">struct xdp_md</a>：</p><pre><code class=\"language-c++\">#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)\n\nBPF_PROG_TYPE(BPF_PROG_TYPE_XDP, xdp,\n       struct xdp_md, struct xdp_buff)\n</code></pre><p>因而，你就可以使用如下的格式来定义这个 XDP 程序：</p><pre><code class=\"language-c++\">SEC(\"xdp\")\nint xdp_proxy(struct xdp_md *ctx)\n{\n  // TODO: 添加XDP负载均衡逻辑\n}\n</code></pre><p>这段代码中，<code>SEC(\"xdp\")</code> 表示程序的类型为 XDP 程序。你可以在 libbpf 中 <a href=\"https://github.com/libbpf/libbpf/blob/master/src/libbpf.c#L8599-L8675\">section_defs</a>找到所有 eBPF 程序类型对应的段名称格式。</p><p>参考 <code>linux/bpf.h</code> 头文件中 <a href=\"https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L5283\">struct xdp_md</a> 的定义格式，你可以发现，它比上一讲用到的 <a href=\"https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L5506\">struct bpf_sock_ops</a> 简单多了，只包含了如下的几个字段：</p><pre><code class=\"language-c++\">struct xdp_md {\n  __u32 data;\n  __u32 data_end;\n  __u32 data_meta;\n  /* Below access go through struct xdp_rxq_info */\n  __u32 ingress_ifindex; /* rxq-&gt;dev-&gt;ifindex */\n  __u32 rx_queue_index;  /* rxq-&gt;queue_index  */\n  __u32 egress_ifindex;  /* txq-&gt;dev-&gt;ifindex */\n};\n</code></pre><p>从 <code>struct xdp_md</code> 的定义中你可以看到，所有的字段都是整型数值，其中前三个表示数据指针信息（包括开始位置、结束位置、元数据位置），而后三个表示关联网卡的信息（包括入口网卡、入口网卡队列以及出口网卡的编号）。</p><p>由于 <code>struct xdp_md</code> 中并不包含 skb 数据结构，在 XDP 程序中，你只能通过 <code>data</code> 和 <code>data_end</code> 这两个指针去访问网络报文数据。而要想利用原始网络数据指针来访问网络数据，就需要你了解 TCP/IP 网络报文的基本格式。</p><p>为了方便你理解，我画了一张图，标记了以太网头、IP 头以及 TCP 头等相对于 <code>struct xdp_md</code> 中数据指针的位置关系：</p><p><img src=\"https://static001.geekbang.org/resource/image/yy/91/yy7887570f06c1d075eb31701924e791.jpg?wh=1920x577\" alt=\"图片\"><br>\n有了这些对应关系，要访问 TCP/IP 协议某一层的头结构，就可以使用开始指针 <code>data</code> 再加上它之前所有头结构大小的偏移。</p><p>比如，对于以太网头，它的位置跟开始位置 <code>data</code> 是相同的，因而你就可以使用下面的方式，把它转换为指针格式进行访问：</p><pre><code class=\"language-c++\">void *data = (void *)(long)ctx-&gt;data;\nvoid *data_end = (void *)(long)ctx-&gt;data_end;\n\nstruct ethhdr *eth = data;\nif (data + sizeof(struct ethhdr) &gt; data_end)\n{\n  return XDP_ABORTED;\n}\n</code></pre><p>为了帮助 eBPF 校验器验证数据访问的合法性，在访问以太网头数据结构 <code>struct ethhdr</code> 之前，你需要检查数据指针是否越界。如果检查失败，就要返回一个错误（这儿返回的 <code>XDP_ABORTED</code> 表示丢弃数据包并记录错误行为以便排错）。</p><p>了解了太网头的访问格式之后，IP 头的访问也是类似的。在开始指针 <code>data</code> 之后加上太网头数据结构的长度偏移，就是 IP 头所指向的位置。拿到 IP 头之后，你还可以对网络数据进行初步的校验，比如忽略 IPv6、UDP 等我们不关心的数据，只处理 TCP 数据包，代码如下：</p><pre><code class=\"language-c++\">struct iphdr *iph = data + sizeof(struct ethhdr);\nif (data + sizeof(struct ethhdr) + sizeof(struct iphdr) &gt; data_end)\n{\n  return XDP_ABORTED;\n}\n\nif (eth-&gt;h_proto != bpf_htons(ETH_P_IP))\n{\n  return XDP_PASS;\n}\n\nif (iph-&gt;protocol != IPPROTO_TCP)\n{\n  return XDP_PASS;\n}\n</code></pre><p>这段代码中返回的 <code>XDP_PASS</code> 表示把网络包传递给内核协议栈，内核协议栈接收到网络包后，按正常流程继续处理。</p><p>进行了基本的校验之后，再接下来就是实现负载均衡的逻辑了。由于我们想要实现的是一个四层负载均衡，试想一下，负载均衡器收到客户端的请求之后，需要把目的地址（包括 IP 和 MAC）替换成后端 Webserver 的地址，再重新发到内核协议栈中继续处理。</p><p>参考内核中<a href=\"https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/if_ether.h#L165\">以太网头</a>和 <a href=\"https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/ip.h#L86\">IP 头</a>的定义格式， IP 地址都是以 <code>__be16</code> 类型的大端格式存储，而 MAC 地址则是以字符数组 <code>unsigned char h_dest[6]</code> 的形式存储。因而，MAC 地址可以直接通过数据下标进行访问，而我们案例开始时列出的 IP 地址，还需要先转换为 <code>__be16</code> 格式的大端存储格式。</p><p>如果你还不熟悉 IP 地址的转换方法，那可以参考下面的程序，调用 <code>inet_addr()</code> 库函数帮你完成转换：</p><pre><code class=\"language-c++\">#include &lt;stdio.h&gt;\n#include &lt;arpa/inet.h&gt;\n\nint main() {\n  unsigned int a1 = inet_addr(\"172.17.0.2\");\n  unsigned int a2 = inet_addr(\"172.17.0.3\");\n  unsigned int a3 = inet_addr(\"172.17.0.4\");\n  unsigned int a4 = inet_addr(\"172.17.0.5\");\n  printf(\"0x%x 0x%x 0x%x 0x%x\\n\", a1, a2, a3, a4);\n}\n</code></pre><p>为了方便你理解接下来的程序，我把转换后的容器地址信息整理成了一个表格，你可以在后续的开发和问题排查过程中参考：</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/bb/d31389c380dc3dddf2128495d35b6ebb.jpg?wh=2284x1510\" alt=\"\"></p><p>接下来，就是负载均衡的实现过程了，也就是根据请求的来源，把目的地址修改为 Webserver 的地址。下面的代码展示的就是一个最简单的负载均衡实现逻辑：</p><pre><code class=\"language-c++\">/* 1. 常量定义 */\n#define CLIENT_IP 0x40011ac\n#define LOADBALANCER_IP 0x50011ac\n#define ENDPOINT1_IP 0x20011ac\n#define ENDPOINT2_IP 0x30011ac\n#define CLIENT_MAC_SUFFIX 0x04\n#define LOADBALANCER_MAC_SUFFIX 0x05\n#define ENDPOINT1_MAC_SUFFIX 0x02\n#define ENDPOINT2_MAC_SUFFIX 0x03\n\n/* 2. 从客户端发送过来的请求，目的地址改为后端 Webserver 的地址 */\nif (iph-&gt;saddr == CLIENT_IP)\n{\n  iph-&gt;daddr = ENDPOINT1_IP;\n  eth-&gt;h_dest[5] = ENDPOINT1_MAC_SUFFIX; /* Only need to update the last byte */\n\n  /* 模拟从两个Webserver随机选择 */\n  if ((bpf_ktime_get_ns() &amp; 0x1) == 0x1)\n  {\n    iph-&gt;daddr = ENDPOINT2_IP;\n    eth-&gt;h_dest[5] = ENDPOINT2_MAC_SUFFIX;\n  }\n}\nelse /* 3. 反之，目的地址改为客户端 */\n{\n  iph-&gt;daddr = CLIENT_IP;\n  eth-&gt;h_dest[5] = CLIENT_MAC_SUFFIX;\n}\n\n/* 4. 修改原地址为LB地址 */\niph-&gt;saddr = LOADBALANCER_IP;\neth-&gt;h_source[5] = LOADBALANCER_MAC_SUFFIX;\n</code></pre><p>这段代码中各部分的含义如下：</p><ul>\n<li>第 1 部分，将容器地址信息定义为常量，方便后续引用和理解。注意，MAC 地址是一个包含6 个元素的数组，而前 5 个元素的值都是相同的。因而，在更新目的 MAC 地址时，只需要更新最后一个元素即可。所以，常量定义里面也只包含了最后一个字节的值。</li>\n<li>第 2 部分，对于从客户端发送过来的请求，将目的地址改为后端 Webserver 的地址。由于只有两个后端 Webserver，这儿使用时间戳最后一位的值模拟它们的随机选择过程。</li>\n<li>第 3 部分，对于从 Webserver 发送过来的响应，目的地址改为客户端地址。</li>\n<li>第 4 部分，将原地址都改为负载均衡器的地址。</li>\n</ul><p>到这里， eBPF 程序是不是已经开发好了呢？其实，如果你了解过 IP 协议的基本原理，你就知道还有一个步骤也是非常重要的：由于修改了 IP 头的数据，IP 头的校验和（checksum）就需要重新计算，否则网络包会被内核直接丢弃。</p><p>如果你不熟悉 IP 头校验和的计算方法也没关系，你可以很容易从成熟的开源项目中查找到相关的计算方法。比如，参考 Facebook 开源的 <a href=\"https://github.com/facebookincubator/katran/blob/main/katran/lib/bpf/csum_helpers.h#L30\">Katran</a>，你可以定义如下的 <code>ipv4_csum()</code> 函数来计算校验和：</p><pre><code class=\"language-c++\">static __always_inline __u16 csum_fold_helper(__u64 csum)\n{\n  int i;\n#pragma unroll\n  for (i = 0; i &lt; 4; i++)\n  {\n  if (csum &gt;&gt; 16)\n    csum = (csum &amp; 0xffff) + (csum &gt;&gt; 16);\n  }\n  return ~csum;\n}\n\nstatic __always_inline __u16 ipv4_csum(struct iphdr *iph)\n{\n  iph-&gt;check = 0;\n  unsigned long long csum = bpf_csum_diff(0, 0, (unsigned int *)iph, sizeof(struct iphdr), 0);\n  return csum_fold_helper(csum);\n}\n</code></pre><p>关于校验和的具体算法，你可以参考 TCP/IP 协议相关的原理书籍（如《TCP/IP详解》）来理解，这里我就不详细展开了。</p><p>有了校验和的计算方法之后，最后更新 IP 头的 checksum，再返回 <code>XDP_TX</code> 把数据包从原网卡发送出去，交给内核去转发就可以了。下面展示的就是更新校验和的实现方法：</p><pre><code class=\"language-c++\">SEC(\"xdp\")\nint xdp_proxy(struct xdp_md *ctx)\n{\n  ...\n  /* 重新计算校验和 */\n  iph-&gt;check = ipv4_csum(iph);\n\n  /* 把数据包从原网卡发送出去 */\n  return XDP_TX;\n}\n</code></pre><p>把上述代码保存到一个文件 <code>xdp-proxy.bpf.c</code> 中，就完成了 XDP eBPF 程序的开发（你还可以在 <a href=\"https://github.com/feiskyer/ebpf-apps/blob/main/loadbalancer/xdp/xdp-proxy.bpf.c\">GitHub</a> 中找到完整的代码）。</p><h3>编译并生成脚手架头文件</h3><p>有了 XDP 程序之后，接下来的第二步就比较简单了。我们只需要执行下面的 <code>clang</code> 命令，把 XDP 程序编译成字节码，再执行 <code>bpftool gen skeleton</code> 命令生成脚手架头文件即可：</p><pre><code class=\"language-bash\">clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I/usr/include/x86_64-linux-gnu -I. -c xdp-proxy.bpf.c -o xdp-proxy.bpf.o\nbpftool gen skeleton xdp-proxy.bpf.o &gt; xdp-proxy.skel.h\n</code></pre><h3>开发用户态程序</h3><p>对于第三步用户态程序的开发，它的基本流程跟 <a href=\"https://time.geekbang.org/column/article/484372\">08 讲</a> 中的内核跟踪案例是类似的，也是需要引入脚手架头文件、增大 RLIMIT_MEMLOCK、初始化并加载 BPF 字节码，最后再挂载 XDP 程序这几个步骤。忽略错误处理步骤，最核心的实现步骤如下所示：</p><pre><code class=\"language-c++\">// 1. 引入脚手架头文件\n#include \"xdp-proxy.skel.h\"\n\n// C语言主函数\nint main(int argc, char **argv)\n{\n    // 2. 增大 RLIMIT_MEMLOCK（默认值通常太小，不足以存入BPF映射的内容）\n    struct rlimit rlim_new = {\n      .rlim_cur = RLIM_INFINITY,\n      .rlim_max = RLIM_INFINITY,\n    };\n    err = setrlimit(RLIMIT_MEMLOCK, &amp;rlim_new);\n\n    // 3. 初始化BPF程序\n    struct xdp_proxy_bpf *obj = xdp_proxy_bpf__open();\n\n    // 4. 加载BPF字节码\n    err = xdp_proxy_bpf__load(obj);\n\n    // 5. TODO: 挂载XDP程序到eth0网卡\n}\n</code></pre><p>这段代码中，前面 4 个步骤跟<a href=\"https://time.geekbang.org/column/article/484372\"> 08 讲</a> 中的<a href=\"https://time.geekbang.org/column/article/484372\">内核跟踪案例</a>是一样的，这儿不再详细展开。</p><p>而对于第 5 步的挂载过程，我在<a href=\"https://time.geekbang.org/column/article/483364\"> 06 讲</a> 中曾经提到，你可以使用 <code>ip link</code> 命令来挂载 XDP 程序。当时讲到的是在主机中挂载 XDP 的步骤，而在容器中的步骤其实也是一样的（注意，在容器中的虚拟网卡上，只支持以通用模式挂载）。</p><p>下面的代码展示的就是把 XDP 字节码复制到负载均衡容器并挂载到 eth0 网卡的过程：</p><pre><code class=\"language-bash\"># 复制字节码到容器中\ndocker cp xdp-proxy.bpf.o lb:/\n\n# 在容器中安装iproute2命令行工具\ndocker exec -it lb apk add iproute2 --update\n\n# 在容器中挂载XDP程序到eth0网卡\ndocker exec -it lb ip link set dev eth0 xdpgeneric object xdp-proxy.bpf.o sec xdp\n</code></pre><p>除了使用命令行工具之外，你还可以在用户态程序中调用库函数来挂载 XDP 程序，从而避免引入额外的命令行工具依赖（比如，不再需要安装 iproute2 系统工具）。</p><p>libbpf 提供了一个 <code>bpf_set_link_xdp_fd(int ifindex, int fd, __u32 flags)</code> 函数，可用于把 XDP 程序挂载到网卡。这个函数需要网卡序号和 XDP 程序文件描述符作为参数，查询这些参数并挂载 XDP 的过程如下所示：</p><pre><code class=\"language-c++\">    unsigned int ifindex = if_nametoindex(\"eth0\");\n    int prog_id = bpf_program__fd(obj-&gt;progs.xdp_proxy);\n    err = bpf_set_link_xdp_fd(ifindex, prog_id, XDP_FLAGS_UPDATE_IF_NOEXIST|XDP_FLAGS_SKB_MODE);\n</code></pre><p>这段代码中，挂载参数标志 <code>XDP_FLAGS_SKB_MODE</code> 等同于 <code>ip link</code> 命令中的 <code>xdpgeneric</code>，表示以通用模式挂载。</p><p>把上述代码保存到 <code>xdp-proxy.c</code> 文件中（你还可以在 <a href=\"https://github.com/feiskyer/ebpf-apps/blob/main/loadbalancer/xdp/xdp-proxy.c\">GitHub</a> 中找到完整的代码），再执行下面的编译命令，就可以将其编译为静态链接的可执行文件。采用静态链接的一个好处是容易在容器中分发，只需要把最终的二进制文件放入容器中即可运行，不再需要安装额外的依赖环境。</p><pre><code class=\"language-bash\">clang -g -O2 -Wall -I. -c xdp-proxy.c -o xdp-proxy.o\nclang -Wall -O2 -g xdp-proxy.o -static -lbpf -lelf -lz -o xdp-proxy\n</code></pre><p>到这里，完整的 eBPF 程序就开发好了。它是不是可以正常工作呢？如果可以正常工作，性能又会怎么样？接下来，我们把它放到容器中测试一下看看。</p><h3>性能测试</h3><p>在终端中执行下面的 docker 命令，把 XDP 程序复制到负载均衡容器中，并执行 XDP 程序：</p><pre><code class=\"language-bash\"># 复制XDP程序到容器\ndocker cp xdp-proxy lb:/\n\n# 在容器中加载XDP程序\ndocker exec -it lb /xdp-proxy\n</code></pre><p>然后，进入客户端容器终端中，执行 <code>apk</code> 命令安装 <code>curl</code> 和 <code>wrk</code> 工具，接着再使用 <code>curl</code> 访问负载均衡器：</p><pre><code class=\"language-bash\">docker exec -it client sh\n\n# (以下命令运行在client容器中)\n/ # curl \"http://172.17.0.5\"\n</code></pre><p>如果你看到 <code>Hostname: http1</code> 或者 <code>Hostname: http12</code> 的输出，说明 XDP 已经成功运行，并且它的负载均衡功能也是正常的。</p><p>接下来，继续在客户端容器终端中执行 <code>wrk</code> 命令，给负载均衡器做个性能测试：</p><pre><code class=\"language-bash\"># (以下命令运行在client容器中)\n\n# 安装wrk工具\n/ # apk add curl wrk --update\n\n# 执行性能测试\n/ # wrk -c100 \"http://172.17.0.5\"\n</code></pre><p>稍等一会，你会看到如下的输出（在你的环境下可能看到不同数值，具体的性能指标取决于运行环境和配置）：</p><pre><code class=\"language-bash\">Running 10s test @ http://172.17.0.5\n  2 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     6.37ms   11.17ms 295.43ms   98.97%\n    Req/Sec     9.09k   422.06    10.09k    75.00%\n  180889 requests in 10.02s, 31.39MB read\nRequests/sec:  18048.65\nTransfer/sec:      3.13MB\n</code></pre><p>从输出中你可以看到，平均每秒请求数是 18048，每个线程的平均延迟是 6.37ms。回顾一下 <a href=\"https://time.geekbang.org/column/article/485702?cid=100104501\">12 讲</a> 中的套接字 eBPF 程序的性能测试结果，它的平均每秒请求数是 15300，而每个线程的平均延迟是 6.88ms。这说明，相比套接字程序，XDP 程序在平均每秒请求数上提升了 18%。</p><p>最后，不要忘记清理今天的案例环境。由于所有服务都运行在容器中，我们只需要执行下面的命令，删除今天创建的所有容器，即可完成清理工作：</p><pre><code class=\"language-bash\">docker rm -f lb client http1 http2\n</code></pre><h2>小结</h2><p>今天，我带你使用 libbpf 开发了一个基于 XDP 的负载均衡服务。</p><p>XDP 程序在网络驱动程序刚刚收到数据包的时候触发执行。由于还未分配内核 SKB 数据结构，XDP 程序只能根据 TCP/IP 协议的封包格式，从原始网络包中提取所需协议层的数据，进而再按照需要进行改写或转发。XDP 程序修改过的数据包可以转发给相同或不同的网卡，再交给内核协议栈继续处理；或者，跟处理逻辑无关的包不做任何处理，直接交给内核协议栈进行处理。</p><p>今天的案例把 XDP 程序挂载到了容器的虚拟网卡上，由于采用了通用模式挂载，它的执行过程其实还是在内核中运行的。在实际生产环境中，你可以以原生模式或卸载模式把 XDP 程序挂载到支持 XDP 的网卡上，从而获得最优的网络性能。</p><h2>思考题</h2><p>最后，我想邀请你来聊一聊：</p><ol>\n<li>在今天的案例中，我们把 XDP 程序挂载到了负载均衡容器中的网卡上。如果把它直接挂载到主机的 eth0 网卡，会有什么样的现象？</li>\n<li>针对今天的负载均衡场景，还有哪些方法可以进一步优化 XDP 程序的性能？</li>\n</ol><p>期待你在留言区和我讨论，也欢迎把这节课分享给你的同事、朋友。让我们一起在实战中演练，在交流中进步。</p>","neighbors":{"left":{"article_title":"12｜高性能网络实战（上）：如何开发一个负载均衡器？","id":485702},"right":{"article_title":"大咖助场｜李程远：谈谈eBPF在云原生中的纵与横","id":492456}},"comments":[{"had_liked":false,"id":334324,"user_name":"莫名","can_delete":false,"product_type":"c1","uid":1007254,"ip_address":"","ucode":"E28F2602BA25DD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","comment_is_top":false,"comment_ctime":1644888935,"is_pvip":false,"replies":[{"id":122219,"content":"非常赞的答案👍 如果能把这些思路再都实现了就更好了😊","user_name":"作者回复","user_name_real":"编辑","uid":1001282,"ctime":1645019082,"ip_address":"","comment_id":334324,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"1. 挂在宿主机的 eth0 网卡，会导致宿主机网络受影响，最直接的影响是来自外部的 ssh 连接异常，之后再执行 ssh 也登不进宿主机。（原因是源 IP 不是 CLIENT_IP 时将目的 IP 直接修改为 CLIENT_IP，源 IP 无论如何均修改为 LOADBALANCER_IP，进来的数据包无法正常被接收与响应）\n\n2. 目前的实现有些 hardcode，不利于扩展，负载均衡器通常运行配置多个 vip，每个 vip 对应若干真正的后端服务。觉得改进措施可以用 BPF map 类型存储，最好有个文本格式的配置文件，程序加载前解析这个配置文件，填充 BPF map。xdp 程序中根据 key（比如 vip 或者 UUID）查找真正的后端服务，如果能够找到则从中读取 IP、Mac 等信息。","like_count":15,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551460,"discussion_content":"非常赞的答案👍 如果能把这些思路再都实现了就更好了😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645019083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336182,"user_name":"L33K","can_delete":false,"product_type":"c1","uid":1046063,"ip_address":"","ucode":"2F8E105F44E347","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/2f/d3f1dae6.jpg","comment_is_top":false,"comment_ctime":1645975935,"is_pvip":false,"replies":[{"id":122899,"content":"嗯 XDP是有一些限制的，具体可以参考这个PPT： https:&#47;&#47;lpc.events&#47;event&#47;11&#47;contributions&#47;939&#47;attachments&#47;771&#47;1551&#47;xdp-multi-buff.pdf","user_name":"作者回复","user_name_real":"编辑","uid":1001282,"ctime":1646047472,"ip_address":"","comment_id":336182,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"如果一个上层的大包被拆成一个多个包发过来，目前这种负载均衡方式是不是可能就有问题了？","like_count":3,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553742,"discussion_content":"嗯 XDP是有一些限制的，具体可以参考这个PPT： https://lpc.events/event/11/contributions/939/attachments/771/1551/xdp-multi-buff.pdf","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646047472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367533,"user_name":"Aiolos","can_delete":false,"product_type":"c1","uid":3173598,"ip_address":"英国","ucode":"D00DE9E6A0F2F4","user_header":"https://static001.geekbang.org/account/avatar/00/30/6c/de/693fce23.jpg","comment_is_top":false,"comment_ctime":1675307940,"is_pvip":false,"replies":[{"id":134630,"content":"很有可能是用了虚拟机导致的。案例中使用的是通用挂载模式，实际生产中使用原生模式或卸载模式才能获得比较好的加速效果。","user_name":"作者回复","user_name_real":"编辑","uid":1001282,"ctime":1677499927,"ip_address":"上海","comment_id":367533,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"原生nginx和sock_ops+sk_msg优化均是2000QPS，但是使用XDP优化后降到了400QPS，请问这是什么原因，如何修正","like_count":1,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606941,"discussion_content":"很有可能是用了虚拟机导致的。案例中使用的是通用挂载模式，实际生产中使用原生模式或卸载模式才能获得比较好的加速效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677499928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334634,"user_name":"codejw","can_delete":false,"product_type":"c1","uid":1201492,"ip_address":"","ucode":"8D12EE69A4DA4C","user_header":"https://static001.geekbang.org/account/avatar/00/12/55/54/97419b60.jpg","comment_is_top":false,"comment_ctime":1645025167,"is_pvip":false,"replies":[{"id":122633,"content":"如果是不同的网卡，多次调用挂载和加载的函数或者用 ip link set 命令都可以。但如果想挂载多个XDP程序到相同的网卡，那就需要5.10新增的freplace类型，具体细节可以参考 https:&#47;&#47;lpc.events&#47;event&#47;7&#47;contributions&#47;671&#47;attachments&#47;561&#47;992&#47;xdp-multiprog.pdf","user_name":"作者回复","user_name_real":"编辑","uid":1001282,"ctime":1645618507,"ip_address":"","comment_id":334634,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"老师，如果有多个xdp程序如何挂载呢，我有多个.o都挂载到xdp","like_count":1,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552869,"discussion_content":"如果是不同的网卡，多次调用挂载和加载的函数或者用 ip link set 命令都可以。但如果想挂载多个XDP程序到相同的网卡，那就需要5.10新增的freplace类型，具体细节可以参考 https://lpc.events/event/7/contributions/671/attachments/561/992/xdp-multiprog.pdf","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645618507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336394,"user_name":"yuan","can_delete":false,"product_type":"c1","uid":1173752,"ip_address":"","ucode":"C6995865D13E1B","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/f8/2c1958b6.jpg","comment_is_top":false,"comment_ctime":1646127116,"is_pvip":false,"replies":[{"id":122997,"content":"缺少依赖库，参考根目录的Readme把依赖库安装一下","user_name":"作者回复","user_name_real":"编辑","uid":1001282,"ctime":1646225338,"ip_address":"","comment_id":336394,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"老师好，我用如下命令编译静态链接的可执行文件时报错了，代码用的是github中的代码，请问有啥思路吗？\n命令：clang -Wall -O2 -g xdp-proxy-v2.o -static -lbpf -lelf -lz -o xdp-proxy-v2\n结果：&#47;usr&#47;bin&#47;ld: cannot find -lbpf\n&#47;usr&#47;bin&#47;ld: cannot find -lelf\n&#47;usr&#47;bin&#47;ld: cannot find -lz\n&#47;usr&#47;bin&#47;ld: cannot find -lc\nclang-13: error: linker command failed with exit code 1 (use -v to see invocation)\n\n另外用ip link挂载也不行\n命令：sudo ip link set dev eth0 xdpgeneric object xdp-proxy-v2.bpf.o sec xdp\n结果：\nBTF debug data section &#39;.BTF&#39; rejected: Invalid argument (22)!\n - Length:       1817\nVerifier analysis:\n... ...\nProg section &#39;xdp&#39; rejected: Permission denied (13)!\n - Type:         6\n - Instructions: 151 (0 over limit)\n - License:      GPL\n\nVerifier analysis:\n... ...\nprocessed 25 insns (limit 1000000) max_states_per_insn 0 total_states 1 peak_states 1 mark_read 1\n\nError fetching program&#47;map!\n\n内核版本信息如下：\n5.14.10-300.fc35.x86_64\nFedora release 35 (Thirty Five)","like_count":0,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554132,"discussion_content":"缺少依赖库，参考根目录的Readme把依赖库安装一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646225338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2620407,"avatar":"https://static001.geekbang.org/account/avatar/00/27/fb/f7/88ab6f83.jpg","nickname":"进击的Lancelot","note":"","ucode":"3BCC355801DC61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589721,"discussion_content":"这个问题发生的原因主要是因为创建出来的 bpf map 在容器中不可访问，有两个解决方法，一个是不要使用 v2 的版本，用 v1 不带 map 的版本就可以在容器中挂载 xdp，第二个方法，就是用 nsenter 进入到容器的 network namespace 当中，然后再加载 xdp 程序，操作过程：\n```bash\n# 找到 lb 的 pid\n$ sudo docker inspect lb | grep -i pid\n$ sudo nsenter -t ${pid} -n\n$ ip link set dev eth0 xdpgeneric object xdp-proxy.bpf.o sec xdp\n```","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1665283738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344551,"user_name":"乌拉呆zyb","can_delete":false,"product_type":"c1","uid":2649439,"ip_address":"","ucode":"D324583C9CE2EF","user_header":"https://static001.geekbang.org/account/avatar/00/28/6d/5f/a937f7f1.jpg","comment_is_top":false,"comment_ctime":1651645705,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"倪老师，请问为什么将XDP eBPF程序挂载上去之后，优化效果反而大大地下降了？优化前 Requests&#47;sec 是7500左右；XDP优化后 Requests&#47;sec 是250 左右；代码都是github上的代码；两个版本的都试过了，都是反向优化，不知道为啥 ^~^","like_count":4,"discussions":[{"author":{"id":2959301,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/27/c5/d4d00da2.jpg","nickname":"为了维护世界和平","note":"","ucode":"A7254895BA8B68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580585,"discussion_content":"我也有这样的疑问，速度反而慢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658280184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351889,"user_name":"为了维护世界和平","can_delete":false,"product_type":"c1","uid":2959301,"ip_address":"","ucode":"A7254895BA8B68","user_header":"https://static001.geekbang.org/account/avatar/00/2d/27/c5/d4d00da2.jpg","comment_is_top":false,"comment_ctime":1658280319,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"倪老师你好，使用XDP 速度慢了，这大概什么原因呢\n&#47; # wrk -c100 &quot;http:&#47;&#47;172.17.0.5&quot;\nRunning 10s test @ http:&#47;&#47;172.17.0.5\n  2 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +&#47;- Stdev\n    Latency   272.26ms  386.46ms   1.70s    86.32%\n    Req&#47;Sec   122.51     90.04   580.00     73.65%\n  2483 requests in 10.06s, 441.31KB read\n  Socket errors: connect 0, read 0, write 0, timeout 53\nRequests&#47;sec:    246.73\nTransfer&#47;sec:     43.85KB\n","like_count":2},{"had_liked":false,"id":346719,"user_name":"aith","can_delete":false,"product_type":"c1","uid":2350328,"ip_address":"","ucode":"271057D21C2107","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erBT5LK5f0w6MHCyX7Tuc1aytDlSazDkFPibwZ113Luz8qLviccotz4k3oIePQzrZhHEBWSDKUIjw7A/132","comment_is_top":false,"comment_ctime":1653378554,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"XDP程序把数据包随机调度到某个Webserver，没有会话保持，会不会导致同一次请求的数据包，发送到不同的后端Webserver上面,从而不能正常相应？","like_count":2,"discussions":[{"author":{"id":1665832,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/pJJpwhFRpXm1NFJ8HuiapckC8IibS0eHY99XqnAUtpicHXDdiajK3ObthbnenMTwRDGgvfv86LPEjKq06wzd9o8sHQ/132","nickname":"Geek_c0ea3b","note":"","ucode":"3F054407CDCF40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590169,"discussion_content":"肯定会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665562893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344571,"user_name":"乌拉呆zyb","can_delete":false,"product_type":"c1","uid":2649439,"ip_address":"","ucode":"D324583C9CE2EF","user_header":"https://static001.geekbang.org/account/avatar/00/28/6d/5f/a937f7f1.jpg","comment_is_top":false,"comment_ctime":1651652530,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"倪老师，还想请教您一个问题： 加载XDP eBPF程序后，curl &quot;http:&#47;&#47;172.17.0.5&quot; 测试正常，有负载均衡能力；但 wrk -c 100 &quot;http:&#47;&#47;172.17.0.5&quot; 的测试结果中有Socker errors的连接超时的报错如下：\n&#47; # wrk -c 100 &quot;http:&#47;&#47;172.17.0.5&quot;\nRunning 10s test @ http:&#47;&#47;172.17.0.5\n  2 threads and 100 connections\n  Thread Stats   Avg      Stdev     Max   +&#47;- Stdev\n    Latency   274.75ms  384.76ms   1.70s    86.88%\n    Req&#47;Sec   127.44     86.42   530.00     69.19%\n  2640 requests in 10.09s, 469.22KB read\n  Socket errors: connect 0, read 0, write 0, timeout 56\nRequests&#47;sec:    261.64\nTransfer&#47;sec:     46.50KB\n&#47; # ","like_count":2,"discussions":[{"author":{"id":1342730,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7d/0a/332fa5f7.jpg","nickname":"许式佩","note":"","ucode":"A4391CA492B7F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595491,"discussion_content":"超时是没有会话机制导致的吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670147423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2959301,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/27/c5/d4d00da2.jpg","nickname":"为了维护世界和平","note":"","ucode":"A7254895BA8B68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580586,"discussion_content":"我的输出也是这样的数量级，速度慢了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658280218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372643,"user_name":"Bachue Zhou","can_delete":false,"product_type":"c1","uid":1494491,"ip_address":"上海","ucode":"3175754775CA32","user_header":"https://static001.geekbang.org/account/avatar/00/16/cd/db/7467ad23.jpg","comment_is_top":false,"comment_ctime":1681378415,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100104501,"comment_content":"这个程序对 libbpf 的版本要求很高啊，我这边用的是 Ubuntu 22.04 都不行，很多 symbol 找不到的。","like_count":1,"discussions":[{"author":{"id":3867215,"avatar":"","nickname":"Geek_6acaf8","note":"","ucode":"1306723C3B23D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639847,"discussion_content":"最后怎么解决的哇，我现在也卡在这里了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710947810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340157,"user_name":"林靖","can_delete":false,"product_type":"c1","uid":1232564,"ip_address":"","ucode":"A1F79AAEF091B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/b4/bb5d7f90.jpg","comment_is_top":false,"comment_ctime":1648633673,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100104501,"comment_content":"倪都你好，我参考tc-bpf手册编译了一个tc程序，源码如下：\n#include &lt;linux&#47;bpf.h&gt;\n\n           #ifndef __section\n           # define __section(x)  __attribute__((section(x), used))\n           #endif\n\n           __section(&quot;classifier&quot;) int cls_main(struct __sk_buff *skb)\n           {\n                   return -1;\n           }\n\n           char __license[] __section(&quot;license&quot;) = &quot;GPL&quot;;\n编译完用tc加载的时候报如下错误：\ntc filter add dev eth0 parent 1: bpf obj bcc.o verbose flowid 1:1 skip_sw\nlibbpf: loading bcc.o\nlibbpf: elf: section(3) classifier, size 24, link 0, flags 6, type=1\nlibbpf: elf: section(4) license, size 4, link 0, flags 3, type=1\nlibbpf: license of bcc.o is GPL\nlibbpf: elf: section(5) .eh_frame, size 48, link 0, flags 2, type=1\nlibbpf: elf: skipping unrecognized data section(5) .eh_frame\nlibbpf: elf: section(6) .rel.eh_frame, size 16, link 7, flags 0, type=9\nlibbpf: elf: skipping relo section(6) .rel.eh_frame for section(5) .eh_frame\nlibbpf: elf: section(7) .symtab, size 96, link 1, flags 0, type=2\nlibbpf: looking for externs among 4 symbols...\nlibbpf: collected 0 externs total\nobject file doesn&#39;t contain sec classifier\nUnable to load program\n\n这个问题是怎么回事，找了一下午都没有发现问题出在哪\n","like_count":1},{"had_liked":false,"id":388823,"user_name":"Geek_6acaf8","can_delete":false,"product_type":"c1","uid":3867215,"ip_address":"江苏","ucode":"1306723C3B23D5","user_header":"","comment_is_top":false,"comment_ctime":1710934715,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100104501,"comment_content":"xdp-proxy-v2.c:78:2: warning: implicit declaration of function &#39;LIBBPF_OPTS&#39; is invalid in C99 [-Wimplicit-function-declaration]\n        LIBBPF_OPTS(bpf_xdp_attach_opts, attach_opts);\n        ^\nxdp-proxy-v2.c:78:14: error: use of undeclared identifier &#39;bpf_xdp_attach_opts&#39;\n        LIBBPF_OPTS(bpf_xdp_attach_opts, attach_opts);\n                    ^\nxdp-proxy-v2.c:78:35: error: use of undeclared identifier &#39;attach_opts&#39;\n        LIBBPF_OPTS(bpf_xdp_attach_opts, attach_opts);\n                                         ^\nxdp-proxy-v2.c:79:8: warning: implicit declaration of function &#39;bpf_xdp_attach&#39; is invalid in C99 [-Wimplicit-function-declaration]\n        err = bpf_xdp_attach(ifindex, prog_id, xdp_flags, &amp;attach_opts);\n              ^\nxdp-proxy-v2.c:79:53: error: use of undeclared identifier &#39;attach_opts&#39;\n        err = bpf_xdp_attach(ifindex, prog_id, xdp_flags, &amp;attach_opts);\n                                                           ^\nxdp-proxy-v2.c:91:2: warning: implicit declaration of function &#39;bpf_xdp_detach&#39; is invalid in C99 [-Wimplicit-function-declaration]\n        bpf_xdp_detach(ifindex, xdp_flags, &amp;attach_opts);\n        ^\nxdp-proxy-v2.c:91:38: error: use of undeclared identifier &#39;attach_opts&#39;\n        bpf_xdp_detach(ifindex, xdp_flags, &amp;attach_opts);\n在编译二进制文件的时候总是报错，之前的依赖也都安装了","like_count":0},{"had_liked":false,"id":345844,"user_name":"Geek_5aa343","can_delete":false,"product_type":"c1","uid":2635369,"ip_address":"","ucode":"535F96029C1EB7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pNKoOAa1QXibrykHNXibW4tyaIIhicocPGXtcVnEianCyOQY9bl0P2JQ3wSialUaolcLVEWycCEBz1Oe4Tj4yghH9yw/132","comment_is_top":false,"comment_ctime":1652627580,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100104501,"comment_content":"libbpf中的section_defs链接更新下：https:&#47;&#47;github.com&#47;libbpf&#47;libbpf&#47;blob&#47;master&#47;src&#47;libbpf.c#L9003-L9080","like_count":0},{"had_liked":false,"id":340159,"user_name":"林靖","can_delete":false,"product_type":"c1","uid":1232564,"ip_address":"","ucode":"A1F79AAEF091B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/b4/bb5d7f90.jpg","comment_is_top":false,"comment_ctime":1648634817,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100104501,"comment_content":"我知道了 应该是我iproute2有问题","like_count":0}]}