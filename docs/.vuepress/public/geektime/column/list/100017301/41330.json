{"id":41330,"title":"09 | 队列：队列在线程池等有限资源池中的应用","content":"<p>我们知道，CPU资源是有限的，任务的处理速度与线程个数并不是线性正相关。相反，过多的线程反而会导致CPU频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><p><strong><span class=\"orange\">当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</span></strong></p><p>实际上，这些问题并不复杂，其底层的数据结构就是我们今天要学的内容，队列（queue）。</p><h2>如何理解“队列”？</h2><p>队列这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。<strong>先进者先出，这就是典型的“<strong><strong>队列</strong></strong>”</strong>。</p><p>我们知道，栈只支持两个基本操作：<strong>入栈push()<strong>和</strong>出栈pop()</strong>。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：<strong>入队enqueue()</strong>，放一个数据到队列尾部；<strong>出队dequeue()</strong>，从队列头部取一个元素。</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/3e/9eca53f9b557b1213c5d94b94e9dce3e.jpg?wh=1142*800\" alt=\"\"></p><p>所以，队列跟栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p><p>队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；Java concurrent并发包利用ArrayBlockingQueue来实现公平锁等。</p><!-- [[[read_end]]] --><h2>顺序队列和链式队列</h2><p>我们知道了，队列跟栈一样，也是一种抽象的数据结构。它具有先进先出的特性，支持在队尾插入元素，在队头删除元素，那究竟该如何实现一个队列呢？</p><p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的栈叫作顺序栈，用链表实现的栈叫作链式栈。同样，用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><p>我们先来看下基于数组的实现方法。我用Java语言实现了一下，不过并不包含Java语言的高级语法，而且我做了比较详细的注释，你应该可以看懂。</p><pre><code>// 用数组实现的队列\npublic class ArrayQueue {\n  // 数组：items，数组大小：n\n  private String[] items;\n  private int n = 0;\n  // head表示队头下标，tail表示队尾下标\n  private int head = 0;\n  private int tail = 0;\n\n  // 申请一个大小为capacity的数组\n  public ArrayQueue(int capacity) {\n    items = new String[capacity];\n    n = capacity;\n  }\n\n  // 入队\n  public boolean enqueue(String item) {\n    // 如果tail == n 表示队列已经满了\n    if (tail == n) return false;\n    items[tail] = item;\n    ++tail;\n    return true;\n  }\n\n  // 出队\n  public String dequeue() {\n    // 如果head == tail 表示队列为空\n    if (head == tail) return null;\n    // 为了让其他语言的同学看的更加明确，把--操作放到单独一行来写了\n    String ret = items[head];\n    ++head;\n    return ret;\n  }\n}\n</code></pre><p>比起栈的数组实现，队列的数组实现稍微有点儿复杂，但是没关系。我稍微解释一下实现思路，你很容易就能明白了。</p><p>对于栈来说，我们只需要一个<strong>栈顶指针</strong>就可以了。但是队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。</p><p>你可以结合下面这张图来理解。当a、b、c、d依次入队之后，队列中的head指针指向下标为0的位置，tail指针指向下标为4的位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/cb/5c0ec42eb797e8a7d48c9dbe89dc93cb.jpg?wh=1142*385\" alt=\"\"></p><p>当我们调用两次出队操作之后，队列中head指针指向下标为2的位置，tail指针仍然指向下标为4的位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/de/0d/dea27f2c505dd8d0b6b86e262d03430d.jpg?wh=1142*385\" alt=\"\"></p><p>你肯定已经发现了，随着不停地进行入队、出队操作，head和tail都会持续往后移动。当tail移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这个问题该如何解决呢？</p><p>你是否还记得，在数组那一节，我们也遇到过类似的问题，就是数组的删除操作会导致数组中的数据不连续。你还记得我们当时是怎么解决的吗？对，用<strong>数据搬移</strong>！但是，每次进行出队操作都相当于删除数组下标为0的数据，要搬移整个队列中的数据，这样出队操作的时间复杂度就会从原来的O(1)变为O(n)。能不能优化一下呢？</p><p>实际上，我们在出队时可以不用搬移数据。如果没有空闲空间了，我们只需要在入队时，再集中触发一次数据的搬移操作。借助这个思想，出队函数dequeue()保持不变，我们稍加改造一下入队函数enqueue()的实现，就可以轻松解决刚才的问题了。下面是具体的代码：</p><pre><code>   // 入队操作，将item放入队尾\n  public boolean enqueue(String item) {\n    // tail == n表示队列末尾没有空间了\n    if (tail == n) {\n      // tail ==n &amp;&amp; head==0，表示整个队列都占满了\n      if (head == 0) return false;\n      // 数据搬移\n      for (int i = head; i &lt; tail; ++i) {\n        items[i-head] = items[i];\n      }\n      // 搬移完之后重新更新head和tail\n      tail -= head;\n      head = 0;\n    }\n    \n    items[tail] = item;\n    ++tail;\n    return true;\n  }\n</code></pre><p>从代码中我们看到，当队列的tail指针移动到数组的最右边后，如果有新的数据入队，我们可以将head到tail之间的数据，整体搬移到数组中0到tail-head的位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/09/c7/094ba7722eeec46ead58b40c097353c7.jpg?wh=1142*639\" alt=\"\"></p><p>这种实现思路中，出队操作的时间复杂度仍然是O(1)，但入队操作的时间复杂度还是O(1)吗？你可以用我们第3节、第4节讲的算法复杂度分析方法，自己试着分析一下。</p><p>接下来，我们再来看下<strong>基于链表的队列实现方法</strong>。</p><p>基于链表的实现，我们同样需要两个指针：head指针和tail指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。我将具体的代码放到GitHub上，你可以自己试着实现一下，然后再去GitHub上跟我实现的代码对比下，看写得对不对。</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/93/c916fe2212f8f543ddf539296444d393.jpg?wh=1142*639\" alt=\"\"></p><h2>循环队列</h2><p>我们刚才用数组来实现队列的时候，在tail==n时，会有数据搬移操作，这样入队操作性能就会受到影响。那有没有办法能够避免数据搬移呢？我们来看看循环队列的解决思路。</p><p>循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。我画了一张图，你可以直观地感受一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/58/90/58ba37bb4102b87d66dffe7148b0f990.jpg?wh=1142*639\" alt=\"\"></p><p>我们可以发现，图中这个队列的大小为8，当前head=4，tail=7。当有一个新的元素a入队时，我们放入下标为7的位置。但这个时候，我们并不把tail更新为8，而是将其在环中后移一位，到下标为0的位置。当再有一个元素b入队时，我们将b放入下标为0的位置，然后tail加1更新为1。所以，在a，b依次入队之后，循环队列中的元素就变成了下面的样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/71/80/71a41effb54ccea9dd463bde1b6abe80.jpg?wh=1142*639\" alt=\"\"></p><p>通过这样的方法，我们成功避免了数据搬移操作。看起来不难理解，但是循环队列的代码实现难度要比前面讲的非循环队列难多了。要想写出没有bug的循环队列的实现代码，我个人觉得，最关键的是，<strong>确定好队空和队满的判定条件</strong>。</p><p>在用数组实现的非循环队列中，队满的判断条件是tail == n，队空的判断条件是head == tail。那针对循环队列，如何判断队空和队满呢？</p><p>队列为空的判断条件仍然是head == tail。但队列满的判断条件就稍微有点复杂了。我画了一张队列满的图，你可以看一下，试着总结一下规律。</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/ec/3d81a44f8c42b3ceee55605f9aeedcec.jpg?wh=1142*640\" alt=\"\"></p><p>就像我图中画的队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，<strong>(tail+1)%n=head</strong>。</p><p>你有没有发现，当队列满时，图中的tail指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。</p><p>Talk is cheap，如果还是没怎么理解，那就show you code吧。</p><pre><code>public class CircularQueue {\n  // 数组：items，数组大小：n\n  private String[] items;\n  private int n = 0;\n  // head表示队头下标，tail表示队尾下标\n  private int head = 0;\n  private int tail = 0;\n\n  // 申请一个大小为capacity的数组\n  public CircularQueue(int capacity) {\n    items = new String[capacity];\n    n = capacity;\n  }\n\n  // 入队\n  public boolean enqueue(String item) {\n    // 队列满了\n    if ((tail + 1) % n == head) return false;\n    items[tail] = item;\n    tail = (tail + 1) % n;\n    return true;\n  }\n\n  // 出队\n  public String dequeue() {\n    // 如果head == tail 表示队列为空\n    if (head == tail) return null;\n    String ret = items[head];\n    head = (head + 1) % n;\n    return ret;\n  }\n}\n</code></pre><h2>阻塞队列和并发队列</h2><p>前面讲的内容理论比较多，看起来很难跟实际的项目开发扯上关系。确实，队列这种数据结构很基础，平时的业务开发不大可能从零实现一个队列，甚至都不会直接用到。而一些具有特殊特性的队列应用却比较广泛，比如阻塞队列和并发队列。</p><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/eb/5ef3326181907dea0964f612890185eb.jpg?wh=1141*499\" alt=\"\"></p><p>你应该已经发现了，上述的定义就是一个“生产者-消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者-消费者模型”！</p><p>这种基于阻塞队列实现的“生产者-消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p><p>而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/67/9f539cc0f1edc20e7fa6559193898067.jpg?wh=1142*599\" alt=\"\"></p><p>前面我们讲了阻塞队列，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？</p><p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。在实战篇讲Disruptor的时候，我会再详细讲并发队列的应用。</p><h2>解答开篇</h2><p>队列的知识就讲完了，我们现在回过来看下开篇的问题。线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</p><p>我们一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？</p><p>我们希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。我们前面说过，队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求又有什么区别呢？</p><p>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</p><p>而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</p><p>除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。<strong>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</strong></p><h2>内容小结</h2><p>今天我们讲了一种跟栈很相似的数据结构，队列。关于队列，你能掌握下面的内容，这节就没问题了。</p><p>队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。</p><p>循环队列是我们这节的重点。要想写出没有bug的循环队列实现代码，关键要确定好队空和队满的判定条件，具体的代码你要能写出来。</p><p>除此之外，我们还讲了几种高级的队列结构，阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。</p><h2>课后思考</h2><ol>\n<li>\n<p>除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？</p>\n</li>\n<li>\n<p>今天讲到并发队列，关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢？</p>\n</li>\n</ol><p>欢迎留言和我分享，我会第一时间给你反馈。</p><hr><p><span class=\"orange\">我已将本节内容相关的详细代码更新到GitHub，<a href=\"https://github.com/wangzheng0822/algo\">戳此</a>即可查看。</span></p>","neighbors":{"left":{"article_title":"08 | 栈：如何实现浏览器的前进和后退功能？","id":41222},"right":{"article_title":"10 |  递归：如何用三行代码找到“最终推荐人”？","id":41440}},"comments":[{"had_liked":false,"id":31209,"user_name":"城","can_delete":false,"product_type":"c1","uid":1035315,"ip_address":"","ucode":"32C4FCE1944000","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/33/19f150d9.jpg","comment_is_top":true,"comment_ctime":1539132392,"is_pvip":false,"replies":[{"id":"11228","content":"👍","user_name":"作者回复","comment_id":31209,"uid":"1190123","ip_address":"","utype":1,"ctime":1539135287,"user_name_real":"gg"}],"discussion_count":35,"race_medal":0,"score":"9.2233736404167004e+18","product_id":100017301,"comment_content":"1.分布式应用中的消息队列，也是一种队列结构<br>2.考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。<br>个人浅见，请批评指正","like_count":373,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426257,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539135287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1059993,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2c/99/4df1ce56.jpg","nickname":"陈亮","note":"","ucode":"C3F3B40C50C81F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76709,"discussion_content":"第二点我不是很认同，判断是否发生变化和入队出对是两步操作，如何保证在他两中间没有数据写入呢？","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1575848910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1713885,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/26/dd/9b764dc7.jpg","nickname":"zard_sakai","note":"","ucode":"1466C541F9FB26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1059993,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2c/99/4df1ce56.jpg","nickname":"陈亮","note":"","ucode":"C3F3B40C50C81F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294559,"discussion_content":"这就涉及到ABA问题了，可以考虑使用带时间戳的原子类","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595927642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":76709,"ip_address":""},"score":294559,"extra":""},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1713885,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/26/dd/9b764dc7.jpg","nickname":"zard_sakai","note":"","ucode":"1466C541F9FB26","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312637,"discussion_content":"这不是ABA问题。他说的是原子性问题，因为不是同一步操作。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602754332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294559,"ip_address":""},"score":312637,"extra":""},{"author":{"id":1339586,"avatar":"https://static001.geekbang.org/account/avatar/00/14/70/c2/0df5cc71.jpg","nickname":"Melon","note":"","ucode":"8E4A96B3BA0239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1059993,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2c/99/4df1ce56.jpg","nickname":"陈亮","note":"","ucode":"C3F3B40C50C81F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370896,"discussion_content":"&#34;比较tail是否发生变化，如果否，则允许入队&#34;这是一次cas操作，是要确保原子性的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1619575844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":76709,"ip_address":""},"score":370896,"extra":""}]},{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237887,"discussion_content":"个人理解:CAS本质是以轮询的方式竞争细粒度的资源来操作数据,这里说的无锁指的是不使用用在对象中的重量级锁.\n会用多个小的队列先来存储请求的数据和请求顺序,然后多个小的队列再按照CAS竞争的方式向大的队列提交小队列中的内容,这样提交时一次性就可以提交多份请求到最终的大队列中,而且也大大减少了竞争的次数,这也是用空间换时间的一种方式,用更多的内存来换取更高的处理效率.","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1587195045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379534,"discussion_content":"这个想法赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623942606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":237887,"ip_address":""},"score":379534,"extra":""},{"author":{"id":1599768,"avatar":"https://static001.geekbang.org/account/avatar/00/18/69/18/ca8a5c22.jpg","nickname":"收","note":"","ucode":"EC3338DB7AEF34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571594,"discussion_content":"类似于资源请求，总有一个先后顺序。先将操作入多个小队列，然后小队列之间争夺大队列资源。本质上是将对一个资源争用分摊到多个资源的争用（加入到小队列需要争锁资源）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652282531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":237887,"ip_address":""},"score":571594,"extra":""}]},{"author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26569,"discussion_content":"C++ 11 无锁队列开源函数库：concurrentqueue，c# 无锁队列系统库：System.Collections.Concurrent","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1570608708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448864,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","nickname":"徐帅","note":"","ucode":"BDF904280E2330","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":259792,"discussion_content":"哪都有你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588817599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":26569,"ip_address":""},"score":259792,"extra":""}]},{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3118,"discussion_content":"cas也是一种锁，操作系统提供的原子锁，性能比比互斥锁要高","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1564202311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1466335,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5f/df/3c4881f0.jpg","nickname":"Geek","note":"","ucode":"1B8EB2C26DE4EC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138580,"discussion_content":"只用cas应该无法实现，Java的无锁队列ConcurrentLinkedQueue使用cas+不变式来保证的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579254352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227107,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b9/63/a3b11794.jpg","nickname":"麦抠","note":"","ucode":"875DEA26F38BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2863,"discussion_content":"乐观锁","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1563981568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210386,"avatar":"https://static001.geekbang.org/account/avatar/00/12/78/12/7df38a54.jpg","nickname":"helloworld2018","note":"","ucode":"2AE40C0DF5A9F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2854,"discussion_content":"对吗？检查完入队的时候发生变化呢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1563973191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1187545,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1e/d9/cb12e020.jpg","nickname":"豆豆","note":"","ucode":"F38848C82F7520","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1210386,"avatar":"https://static001.geekbang.org/account/avatar/00/12/78/12/7df38a54.jpg","nickname":"helloworld2018","note":"","ucode":"2AE40C0DF5A9F7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69082,"discussion_content":"重试","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575259105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2854,"ip_address":""},"score":69082,"extra":""}]},{"author":{"id":1125133,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2b/0d/f4e7245a.jpg","nickname":"黑桃","note":"","ucode":"16B4DD54806CB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557257,"discussion_content":"关于入队，精准的描述应该是：在入队前，获取tail位置，入队时进行cas设置，cas成功则本次成功，否则本次失败；也就是说，入队时不仅要判断tail位置，还要修改，当然这就是cas操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647742395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1468554,"avatar":"https://static001.geekbang.org/account/avatar/00/16/68/8a/af8e49a8.jpg","nickname":"纪老猴子","note":"","ucode":"05962FE7279802","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403474,"discussion_content":"无锁队列底层重要的数据结构一般是原子变量，没有原子变量在多线程环境中会有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634088216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2350349,"avatar":"","nickname":"Geek_8dcb83","note":"","ucode":"27C7B06D5A4B4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336098,"discussion_content":"遇到aba咋办啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608476890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":2106861,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/ed/6a6476e8.jpg","nickname":"Ⅳ","note":"","ucode":"13CAFF851E409E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2350349,"avatar":"","nickname":"Geek_8dcb83","note":"","ucode":"27C7B06D5A4B4F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339957,"discussion_content":"要解决aba实际上还是得加版本号利用乐观锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609848315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336098,"ip_address":""},"score":339957,"extra":""},{"author":{"id":1803215,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/83/cf/1f3b5b17.jpg","nickname":"Jaden~お張嘉楽","note":"","ucode":"FA2737D6A1D2C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2350349,"avatar":"","nickname":"Geek_8dcb83","note":"","ucode":"27C7B06D5A4B4F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373364,"discussion_content":"小白：啥是ＡＢＡ呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620706223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336098,"ip_address":""},"score":373364,"extra":""},{"author":{"id":2094925,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f7/4d/09554c96.jpg","nickname":"iron bo","note":"","ucode":"4BFB1331637AA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1803215,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/83/cf/1f3b5b17.jpg","nickname":"Jaden~お張嘉楽","note":"","ucode":"FA2737D6A1D2C9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373684,"discussion_content":"当线程1观察到此时指针指向A，线程A开始处理，线程2把指针指向了B，然后又指向了A，线程1执行完后观察到指针还是指向A，所以认为没有并发冲突，但实际指针是发生了变化的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620825532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":373364,"ip_address":""},"score":373684,"extra":""}]},{"author":{"id":1721895,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/46/27/eb318d12.jpg","nickname":"Geek_4b6813","note":"","ucode":"ED10C17BE368B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66600,"discussion_content":"第二点不太认同 检查tail的位置实际上不能并发访问的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575088933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":9,"child_discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1721895,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/46/27/eb318d12.jpg","nickname":"Geek_4b6813","note":"","ucode":"ED10C17BE368B4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70072,"discussion_content":"为什么呢？这里用考虑ABA问题吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575307220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":66600,"ip_address":""},"score":70072,"extra":""},{"author":{"id":1721895,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/46/27/eb318d12.jpg","nickname":"Geek_4b6813","note":"","ucode":"ED10C17BE368B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109192,"discussion_content":"除非你保证你检查和写入队尾的操作是原子性的\n不然这个检查没有什么意义 \n想象一下a线程入队前获取到tail等于8，入队时在获取一下tail发现也是8.  此时if判断通过，线程a马上就要把数据插入队尾了。但是此时发生了线程调度。切换到了另一个线程b\n线程b检查tail发现是8，然后完成插入。这个时候在切换成a线程，a线程会完成之前的操作，继续在tail=8的位置插入数据，覆盖掉b线程写的数据。就出现了丢失修改。\n\n除非你能保证获取tail并把数据入队这个操作是个原子性操作，不然这一步毫无意义。","likes_number":31,"is_delete":false,"is_hidden":false,"ctime":1577672954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70072,"ip_address":""},"score":109192,"extra":""},{"author":{"id":1188023,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","nickname":"Eternal","note":"","ucode":"EA6FE7CC98F740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190548,"discussion_content":"需要考虑ABA问题的，","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582957579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70072,"ip_address":""},"score":190548,"extra":""}]}]},{"had_liked":false,"id":31402,"user_name":"wean","can_delete":false,"product_type":"c1","uid":1239735,"ip_address":"","ucode":"3E069F95C25EAD","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/b7/1f7316e6.jpg","comment_is_top":true,"comment_ctime":1539172710,"is_pvip":false,"replies":[{"id":"11438","content":"👍","user_name":"作者回复","comment_id":31402,"uid":"1190123","ip_address":"","utype":1,"ctime":1539270159,"user_name_real":"gg"}],"discussion_count":5,"race_medal":0,"score":"9.2233724507108004e+18","product_id":100017301,"comment_content":"队列也是一种“操作受限”的线性表，只支持两种基本操作：入队和出队。<br><br>队列的应用非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层的系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。<br><br>关于如何实现无锁并发队列<br>可以使用 cas + 数组的方式实现。<br><br>队列的其他应用<br>分布式消息队列，如 kafka 也是一种队列。","like_count":96,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426323,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539270159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1737112,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKoiaQjaxOgcsPTYtfOB1zmduPianpaVQZgES7icTpNFzWwaPFIIia6aIibib0wJZOAibetoID62Ihzy0nibQ/132","nickname":"Robert","note":"","ucode":"8F0611B7DF4A67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239339,"discussion_content":"Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。\n这句话有个疑问？这里的ArrayBlockingQueue是不是应该是AbstractBlockingQueue？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587294928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1070213,"avatar":"https://static001.geekbang.org/account/avatar/00/10/54/85/081804f7.jpg","nickname":"逍遥","note":"","ucode":"95C583EF780159","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7908,"discussion_content":"老师，请问下您的github地址是多少啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567726951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1257099,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2e/8b/ea0a1585.jpg","nickname":"Joker","note":"","ucode":"9662D56F5EA546","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1070213,"avatar":"https://static001.geekbang.org/account/avatar/00/10/54/85/081804f7.jpg","nickname":"逍遥","note":"","ucode":"95C583EF780159","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9539,"discussion_content":"每篇文章结束都有github的入口，你仔细看一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568184033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7908,"ip_address":""},"score":9539,"extra":""},{"author":{"id":1070213,"avatar":"https://static001.geekbang.org/account/avatar/00/10/54/85/081804f7.jpg","nickname":"逍遥","note":"","ucode":"95C583EF780159","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1257099,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2e/8b/ea0a1585.jpg","nickname":"Joker","note":"","ucode":"9662D56F5EA546","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10965,"discussion_content":"嗯，已经找到了，是我不够认真，多谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568345042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9539,"ip_address":""},"score":10965,"extra":""}]}]},{"had_liked":false,"id":31222,"user_name":"花见笑","can_delete":false,"product_type":"c1","uid":1219485,"ip_address":"","ucode":"8A5122BC11E695","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/9d/d487c368.jpg","comment_is_top":true,"comment_ctime":1539133554,"is_pvip":false,"replies":[{"id":"11241","content":"👍","user_name":"作者回复","comment_id":31222,"uid":"1190123","ip_address":"","utype":1,"ctime":1539137071,"user_name_real":"gg"}],"discussion_count":4,"race_medal":0,"score":"9.2233724120561009e+18","product_id":100017301,"comment_content":"循环队列的长度设定需要对并发数据有一定的预测，否则会丢失太多请求。","like_count":87,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426259,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539137071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926991,"avatar":"","nickname":"刘博","note":"","ucode":"1E97481807BB48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264662,"discussion_content":"队列元素设置成链表，一环套一环，可以实现环形队列无限存储，相当于hashmap的数组连城了环，不过时间复杂度也会提升，想到了思维发散一下。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589342295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1076768,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6e/20/a0740b7d.jpg","nickname":"刘智敏","note":"","ucode":"83D3DE25192DD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1926991,"avatar":"","nickname":"刘博","note":"","ucode":"1E97481807BB48","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569265,"discussion_content":"那还有必要用循环队列么，直接无限路队就好了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651387689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":264662,"ip_address":""},"score":569265,"extra":""}]},{"author":{"id":1637933,"avatar":"https://static001.geekbang.org/account/avatar/00/18/fe/2d/e23fc6ee.jpg","nickname":"深水蓝","note":"","ucode":"3E3B195DE54DE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571816,"discussion_content":"循环队列也可以想顺序队列一样，队满的时候重新申请一个大数组作为队列的环。如果有必要回收内存，也可以在队长度小于一定程度后重新申请一个小数组。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652420559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":31686,"user_name":"公众号：小鹿动画学编程","can_delete":false,"product_type":"c1","uid":1235540,"ip_address":"","ucode":"2450C1AA6CB5DB","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/54/6d062f1d.jpg","comment_is_top":false,"comment_ctime":1539264938,"is_pvip":false,"replies":[{"id":"11490","content":"😂","user_name":"作者回复","comment_id":31686,"uid":"1190123","ip_address":"","utype":1,"ctime":1539310718,"user_name_real":"gg"}],"discussion_count":50,"race_medal":0,"score":"3347318788522","product_id":100017301,"comment_content":"王争老师，为了更好的区分队列和栈，小鹿给大家一个更好的口诀。<br>“吃多了拉就是队列，吃多了吐就是栈”。哈哈！","like_count":780,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426466,"discussion_content":"😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131536,"discussion_content":"循环队列就是吃自己拉的","likes_number":45,"is_delete":false,"is_hidden":false,"ctime":1578841701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1240629,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/35/5647c7e5.jpg","nickname":"市集养猫者","note":"","ucode":"D44FF82C51C617","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135261,"discussion_content":"魔鬼哈哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1579080928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":131536,"ip_address":""},"score":135261,"extra":""},{"author":{"id":1019807,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/9f/e49b68ea.jpg","nickname":"幽弥狂","note":"","ucode":"5AECEA7D6ADF33","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217909,"discussion_content":"魔鬼","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585583817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":131536,"ip_address":""},"score":217909,"extra":""}]},{"author":{"id":1026894,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/4e/82e9657c.jpg","nickname":"jeff","note":"","ucode":"68456DD035BDF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330634,"discussion_content":"不严谨 吐不能保证 后进先出","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1606660701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122304,"avatar":"https://static001.geekbang.org/account/avatar/00/20/62/40/faf9a818.jpg","nickname":"吃茫茫","note":"","ucode":"D9781EDA5CC825","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318769,"discussion_content":"你写的代码怎么有股味道！","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1603847280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1437839,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f0/8f/e1fc5338.jpg","nickname":"麦兜爸爸","note":"","ucode":"AE735BF94826E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213621,"discussion_content":"非常反感这类的恶趣味","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1585109651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1973965,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIh0pqaia3PpSks7ib6OBORStk9EMuibQSVWmXtwpQHQOcdibmh4VJzrpcvxOuCyG45I0puNHUulVENRQ/132","nickname":"李吉玉","note":"","ucode":"5BA744B972B5EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337488,"discussion_content":"有味道的一个评论","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1608947051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1901476,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/03/a4/d39c747c.jpg","nickname":"以帅服人的珂哥","note":"","ucode":"1A94CA2D7980B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291610,"discussion_content":"先吃馒头后吃鸡蛋，能保证先拉出来鸡蛋，或者先吐出来馒头吗😂","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1594887944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2357167,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f7/af/e2c53d5a.jpg","nickname":"@之一","note":"","ucode":"CE886AE1FB6B4F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380990,"discussion_content":"我yue了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1624856921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1631948,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epHSfL8MzZJkDnJJvgPpXTbIkthGkU4CKvZIQscn52NQkex2bDnYbgHAda6picENk7EvyhjAuXzFTg/132","nickname":"Geek_d3431c","note":"","ucode":"67A820B0BE8EF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48046,"discussion_content":"残忍，不敢直视栈和队列。😂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573444087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1291529,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b5/09/874f7275.jpg","nickname":"G~旖旎中子","note":"","ucode":"9E15D7CF3AC78D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":34666,"discussion_content":"人才","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1571213031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1146041,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7c/b9/864afbed.jpg","nickname":"宋兵乙","note":"","ucode":"3C9C9572CD6ADB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8952,"discussion_content":"你是魔鬼吗？哈哈哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568112423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1614875,"avatar":"https://static001.geekbang.org/account/avatar/00/18/a4/1b/0d7b9ee1.jpg","nickname":"了凡","note":"","ucode":"E0D53803C5702B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383845,"discussion_content":"有味到的评论","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626252054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2557346,"avatar":"https://static001.geekbang.org/account/avatar/00/27/05/a2/24d5e88e.jpg","nickname":"king🐳","note":"","ucode":"88DA7981062AB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379354,"discussion_content":"你可真是个机灵鬼","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623842765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035563,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/2b/636a3bd3.jpg","nickname":"陈思敏捷","note":"","ucode":"1AD4A2E52DC6DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359161,"discussion_content":"鬼才啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616124251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2445352,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/OHbDdelsu57BYPr2Nak32oMVq8b2OOx9rMhZXuWbMwmDnla31FK0IODreSfQCiaVhUJK4slJW6ichUYUoq84Kwhg/132","nickname":"Geek_368e95","note":"","ucode":"936C239BC0BCED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350797,"discussion_content":"肚子里不搅拌吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614008054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253936,"avatar":"https://static001.geekbang.org/account/avatar/00/13/22/30/e430d991.jpg","nickname":"如果","note":"","ucode":"D995C2CBD554FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328593,"discussion_content":"哈哈哈哈哈哈，这个是高手","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606187888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1934969,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/86/79/066a062a.jpg","nickname":"非同凡想","note":"","ucode":"713FD449A49D5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238331,"discussion_content":"人才","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587218943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","nickname":"o0oi1i","note":"","ucode":"D1F6AD4AAEAFBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237674,"discussion_content":"神比喻🐂拜","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587177300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1756555,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/8b/71b356ec.jpg","nickname":"【K E D E】","note":"","ucode":"6206DD40FA7364","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":118748,"discussion_content":"那双向循环队列","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578189006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1618781,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b3/5d/a97e5045.jpg","nickname":"小宽宽与他的白日梦","note":"","ucode":"C16F595EE4E11A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1756555,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/8b/71b356ec.jpg","nickname":"【K E D E】","note":"","ucode":"6206DD40FA7364","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129704,"discussion_content":"吃屎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578729156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":118748,"ip_address":""},"score":129704,"extra":""},{"author":{"id":1022267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/3b/791d0f5e.jpg","nickname":"王先森","note":"","ucode":"1AF1A395107479","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1756555,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/8b/71b356ec.jpg","nickname":"【K E D E】","note":"","ucode":"6206DD40FA7364","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213810,"discussion_content":"又吃又拉 不耽误","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585124412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":118748,"ip_address":""},"score":213810,"extra":""}]},{"author":{"id":1760077,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/db/4d/8dec7917.jpg","nickname":"迪","note":"","ucode":"57EF0AF897A8B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65574,"discussion_content":"硬核理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575013561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55799,"discussion_content":"理解可以。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574399852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1527522,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4e/e2/3ccf97df.jpg","nickname":"ponyxiao","note":"","ucode":"4E5F01DA025183","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44996,"discussion_content":"印象深刻。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572999543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109204,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ec/d4/1e628174.jpg","nickname":"听雨轩","note":"","ucode":"A96D5CFCF784CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":32640,"discussion_content":"太强了吧这也","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571054312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220552,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","nickname":"Geek_b617bf","note":"","ucode":"9BAFC3B184B1D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24543,"discussion_content":"老铁牛逼","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570173375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1189290,"avatar":"https://static001.geekbang.org/account/avatar/00/12/25/aa/ced0170d.jpg","nickname":"杨宝强","note":"","ucode":"B2352D7EA24F31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5706,"discussion_content":"是个狠人 哈哈哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566443071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5479,"discussion_content":"形象生动的比喻","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566293568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179298,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/a2/5252a278.jpg","nickname":"对方正在输入。。。","note":"","ucode":"7B0DEB4D9B43D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5048,"discussion_content":"哈哈哈哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565915091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2689813,"avatar":"https://static001.geekbang.org/account/avatar/00/29/0b/15/d2b7d7be.jpg","nickname":"BCool","note":"","ucode":"E6C2B78F379988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534761,"discussion_content":"阻塞队列就是便秘咯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638273142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1329680,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4a/10/365ea684.jpg","nickname":"聪明的傻孩子","note":"","ucode":"14AB5B07E18DBC","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534349,"discussion_content":"解释得很棒，下次不准在吃饭的时候说了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638169687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383580,"discussion_content":"大佬为何如此优秀！哈哈哈哈 有味道的评论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626167295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317847,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/d7/868d26ce.jpg","nickname":"songhyunmin","note":"","ucode":"D5A98668CD8532","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352318,"discussion_content":"这比喻太牛逼了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614681127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482839,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/57/3a729755.jpg","nickname":"灯盖","note":"","ucode":"0F8455A593D60C","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311670,"discussion_content":"魔鬼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602459776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1848539,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/LqGZd83zp1y9fpbliaSgGh5qib5eGzU41xibTzib06ZAlaiaJibkJB89JuVEozCScUsVK90jpq7Na30AHDngQzI7YwiaA/132","nickname":"星朝","note":"","ucode":"DFCF2512D6DAE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305649,"discussion_content":"这个太…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600047131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2019569,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d0/f1/9e033d0d.jpg","nickname":"大坤Onion","note":"","ucode":"4439236F90E0FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305204,"discussion_content":"好活","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599815845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1124665,"avatar":"https://static001.geekbang.org/account/avatar/00/11/29/39/be9d2e88.jpg","nickname":"边际革命","note":"","ucode":"EC15C0AE4D487A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298988,"discussion_content":"真特么低俗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597499531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235495,"avatar":"https://static001.geekbang.org/account/avatar/00/12/da/27/a1618737.jpg","nickname":"1KG","note":"","ucode":"857C432444EBCC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289500,"discussion_content":"恶趣味","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594125690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147979,"avatar":"https://static001.geekbang.org/account/avatar/00/11/84/4b/e4738ba8.jpg","nickname":"delete is create","note":"","ucode":"A8C751219A7746","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288350,"discussion_content":"没必要 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593736689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1292347,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/mOFw06icwoIWeYqMibAtFvDRchHTwysiaztEoJQKjREYqYXdsDsrDhSRNuR9k9VdWZV4Rl1fPzIHoib1AfDTG1iadibg/132","nickname":"Geek_724b7a","note":"","ucode":"B478C21F9F6EFD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277823,"discussion_content":"这个比喻是不恰当的，因为不论是吐（栈）或者拉（队），出来的东西和吃（入）的东西（元素）是不一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591108967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1112210,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/92/eaafff96.jpg","nickname":"Amos","note":"","ucode":"61DB72D99AF9EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1292347,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/mOFw06icwoIWeYqMibAtFvDRchHTwysiaztEoJQKjREYqYXdsDsrDhSRNuR9k9VdWZV4Rl1fPzIHoib1AfDTG1iadibg/132","nickname":"Geek_724b7a","note":"","ucode":"B478C21F9F6EFD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":278816,"discussion_content":"其实也是可以的 ，狗吃屎拉屎，狗吃屎吐屎。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1591238091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277823,"ip_address":""},"score":278816,"extra":""}]},{"author":{"id":1243897,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fa/f9/f4ca4080.jpg","nickname":"高旭瑞","note":"","ucode":"284335282EE526","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263491,"discussion_content":"人才，真的形象，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589208989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1143100,"avatar":"https://static001.geekbang.org/account/avatar/00/11/71/3c/adf514f7.jpg","nickname":"猪猪","note":"","ucode":"F3E14A91CFBDBF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207453,"discussion_content":"牛批","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584497953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":5,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021914,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/97/da/bc97c787.jpg","nickname":"云中鹤","note":"","ucode":"6F9F885E55B870","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":170156,"discussion_content":"人才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581672923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117530,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0d/5a/e60f4125.jpg","nickname":"camel","note":"","ucode":"D0D698CD74388F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73635,"discussion_content":"塞多了吐更合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575563676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181835,"avatar":"https://static001.geekbang.org/account/avatar/00/12/08/8b/1b7d0463.jpg","nickname":"晴空万里","note":"","ucode":"6470D4B84A4D8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71823,"discussion_content":"你这个我在马士兵的Struts视频里面听过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575460637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1597934,"avatar":"https://static001.geekbang.org/account/avatar/00/18/61/ee/f930ee87.jpg","nickname":"IQ游侠","note":"","ucode":"F5EAD9421E370D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66406,"discussion_content":"精辟👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575046338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65748,"discussion_content":"666！高才！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575026342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":6,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":31331,"user_name":"DebugDog","can_delete":false,"product_type":"c1","uid":1027798,"ip_address":"","ucode":"1664D37CE03B9D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","comment_is_top":false,"comment_ctime":1539152393,"is_pvip":true,"replies":[{"id":"11314","content":"你这个思路挺巧妙的 👍 我暂时还没有想到破绽","user_name":"作者回复","comment_id":31331,"uid":"1190123","ip_address":"","utype":1,"ctime":1539222736,"user_name_real":"gg"}],"discussion_count":35,"race_medal":0,"score":"1320094112265","product_id":100017301,"comment_content":"老师，循环队列的数组实现，在您的代码中，入队时会空留出一个位置，而且我感觉不太好理解。我定义一个记录队列大小的值size，当这个值与数组大小相等时，表示队列已满，当tail达到最底时，size不等于数组大小时，tail就指向数组第一个位置。当出队时，size—，入队时size++","like_count":307,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426297,"discussion_content":"你这个思路挺巧妙的 👍 我暂时还没有想到破绽","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2464744,"avatar":"https://static001.geekbang.org/account/avatar/00/25/9b/e8/4f0173ef.jpg","nickname":"OldFriend","note":"","ucode":"33B88002F684C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356080,"discussion_content":"加判断量就需要新增一部分内存，而且每次出入队就需要多做一次累加或者累减（多线程肯定需要对此加锁，但我们先忽略多线程）\n累加累减就会增加运行时间，相比于浪费一个内存。\n所以通过空间换时间，浪费一个内存，可以让性能更佳。而增加一个判断量，假设这个的内存消耗被原先浪费内存的不浪费所抵消，换来的也只有运行时间，所以增加一个判断量，显然不太合适","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1615527658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1644011,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/WhoLIb4HZtuwErPetUjHj9JVOYFibDXDAcIic3K0CSzJp4zibe1cemraIq1S8YSN5KSCJcUdicm9f4aKTwZHxFBwTw/132","nickname":"Geek_112e68","note":"","ucode":"82843584C97F43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38145,"discussion_content":"Java并发队列ArrayBlockingQueue就是这个思路实现的","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1571735202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138114,"discussion_content":"单线程可以，多线程就有问题了","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1579224780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162591,"discussion_content":"多线程下保证size的变化也是线程安全的就可以了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580998928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":138114,"ip_address":""},"score":162591,"extra":""},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164234,"discussion_content":"同时维护队列和这个变量，显然很繁琐","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581164393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":162591,"ip_address":""},"score":164234,"extra":""}]},{"author":{"id":1313967,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0c/af/0e4e90de.jpg","nickname":"西贝","note":"","ucode":"C70487174D7D24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":140897,"discussion_content":"是不是也可以不留空位，队列满的判断条件不变，对判断队列空的时候加上条件queue[head]!=null呢","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1579364253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2359879,"avatar":"https://static001.geekbang.org/account/avatar/00/24/02/47/7e46532e.jpg","nickname":"夕阳晴天","note":"","ucode":"5FE26575A57B56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1313967,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0c/af/0e4e90de.jpg","nickname":"西贝","note":"","ucode":"C70487174D7D24","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342330,"discussion_content":"还是为性能考虑，如果加这个的话，就必须在每次出队时置空原来的位置。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610636998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":140897,"ip_address":""},"score":342330,"extra":""}]},{"author":{"id":1116188,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/1c/ef15e661.jpg","nickname":" 臣馟飞扬","note":"","ucode":"F2F882B7678055","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53045,"discussion_content":"循环队列：\nclass MyCircularDeque {\n    int[] queueArr;\n    int front = 0;\n    int rear = 0;\n    int size = 0;\n    int capacity = 0;\n\n    /** Initialize your data structure here. Set the size of the deque to be k. */\n    public MyCircularDeque(int k) {\n        capacity = k;\n        queueArr = new int[capacity];        \n    }\n   \n    \n    /** Adds an item at the rear of Deque. Return true if the operation is successful. */\n    public boolean insertLast(int value) {\n        if (isFull()) {\n            return false;\n        }\n\n        queueArr[rear] = value;\n        rear = (rear + 1) % capacity;\n        size++;\n        return true;\n    }\n    \n    /** Deletes an item from the front of Deque. Return true if the operation is successful. */\n    public boolean deleteFront() {\n        if (isEmpty()) {\n            return false;\n        }\n\n        front = (front + 1) % capacity;\n        size--;\n        return true;\n    }\n    \n    \n    /** Get the front item from the deque. */\n    public int getFront() {\n        if (isEmpty()) {\n            return -1;\n        } \n\n        return queueArr[front];\n    }\n    \n    /** Get the last item from the deque. */\n    public int getRear() {\n        if (isEmpty()) {\n            return -1;\n        } \n\n        return queueArr[rear];\n    }\n    \n    /** Checks whether the circular deque is empty or not. */\n    public boolean isEmpty() {\n        return front == rear &amp;&amp; size == 0;\n    }\n    \n    /** Checks whether the circular deque is full or not. */\n    public boolean isFull() {\n        return front == rear &amp;&amp; size == capacity;\n    }\n}","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574127305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1249136,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","nickname":"张飞online","note":"","ucode":"C9787E4B35888C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42925,"discussion_content":"明显考虑欠缺，用同一变量要考虑互斥性，队列实际90%是多个线程操作，你如何保证，加锁影响效率","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1572829007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1249136,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","nickname":"张飞online","note":"","ucode":"C9787E4B35888C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70074,"discussion_content":"可以具体讲讲你说的这个“互斥性”这个场景下如何解读嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575307585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":42925,"ip_address":""},"score":70074,"extra":""},{"author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231055,"discussion_content":"你想一下，你在入队的时候需要维护tail和size两个变量。并且这两个变量的变化必须是原子性的，不然就会出现A线程志行了tail++，而B线程去获取的时候，size还等于0的情况","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586785846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70074,"ip_address":""},"score":231055,"extra":""},{"author":{"id":1181473,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/21/b3394aa2.jpg","nickname":"Robot","note":"","ucode":"7215462D5AC0FA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":240532,"discussion_content":"看下ArrayBlockingQueue的实现就知道了，对于tail和size的更改都是在获到锁的情况下进行的，没你说的这种情况发生的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587371950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":231055,"ip_address":""},"score":240532,"extra":""}]},{"author":{"id":2696381,"avatar":"","nickname":"一直在滑行","note":"","ucode":"4A7181C284534A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384554,"discussion_content":"其实这两种主要的差别就是：\n(tail + 1) % n == head（不需要增加额外的变量，但会浪费一个控件）\nsize == n(需要增加额外的变量，但是没有空间浪费)\n所以二者在空间效率上是一样的，时间效率上也基本相同。\n但是因为多增加一个size变量在并行开发时就需要多维护一个变量。因此从这方面来考虑前者应该是要小优一点的。\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1626664164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2690896,"avatar":"","nickname":"Geek_882cf0","note":"","ucode":"5538DE48B3978E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2696381,"avatar":"","nickname":"一直在滑行","note":"","ucode":"4A7181C284534A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386855,"discussion_content":"如果队列的数据类型是引用类型，单个变量占用了很大的堆内存，那就不是等价的了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627865431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384554,"ip_address":""},"score":386855,"extra":""},{"author":{"id":1123554,"avatar":"https://static001.geekbang.org/account/avatar/00/11/24/e2/e5110db5.jpg","nickname":"MIAN-勉","note":"","ucode":"AE938038C2E7D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2696381,"avatar":"","nickname":"一直在滑行","note":"","ucode":"4A7181C284534A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412195,"discussion_content":"按照(tail + 1) % n == head ，会有一个元素空间的位置是空的，定义长度是10的数组，但只能装9个，最后一个是null, 这样合理么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636099162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384554,"ip_address":""},"score":412195,"extra":""}]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312645,"discussion_content":"普通考虑可以。但是如果涉及并发，需要控制size的原子累加操作。多了一个锁或者原子操作。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602754721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324110,"discussion_content":"如果由并发，老师代码也有并发问题，不是一样的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605058609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312645,"ip_address":""},"score":324110,"extra":""},{"author":{"id":2343086,"avatar":"https://static001.geekbang.org/account/avatar/00/23/c0/ae/e5e62510.jpg","nickname":"徐志超-Klaus","note":"","ucode":"CF26B39965F2A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331698,"discussion_content":"不一样，用size的话，出队列多了一次cas，牺牲4个字节来提升效率哪怕一点点，还是挺划算的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606956122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324110,"ip_address":""},"score":331698,"extra":""}]},{"author":{"id":2197931,"avatar":"https://static001.geekbang.org/account/avatar/00/21/89/ab/1faae46e.jpg","nickname":"Update","note":"","ucode":"F1995809BAE3CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311940,"discussion_content":"应该是出于性能考虑，以牺牲一个空间的代价，减少出队，入队时的判断。我感觉和数组的下标为什么是从0而不是从1开始，是一个道理的。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602548487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1093819,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b0/bb/fc698888.jpg","nickname":"leozhang","note":"","ucode":"DAC9015821DAF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28843,"discussion_content":"多一个 size 记录队列的大小，编码回更容易也更好理解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1570714202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23218,"discussion_content":"思路大致理解，对于tail和head的位置的保存估计比较繁琐吧，请show your code哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1569771318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2792413,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/9b/dd/97a690a2.jpg","nickname":"倔强","note":"","ucode":"4C588A1E7C0F7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399827,"discussion_content":"大话数据结构里说因为按正常情况设置的话，队列满时，front==tail和队列空时的front==tail会无法区分。所以得想办法区分，方法有两种。\n第一种是设置一个标志变量flag，当front==tail，flag=0时，说明队列为空。当front==tail且flag=1时为队列满。\n第二种便是保留一个元素空间。\n他说得挺像第一种的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633076059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2446981,"avatar":"https://static001.geekbang.org/account/avatar/00/25/56/85/6da913fa.jpg","nickname":"LIFE l=new LIFE()","note":"","ucode":"729BACA3B7FD42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350980,"discussion_content":"我自己实现的就有这个，尤其是链表加上这个会省很多事","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614087403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1571460,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fa/84/f01d203a.jpg","nickname":"Simple life","note":"","ucode":"1902D7F72FB43F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177443,"discussion_content":"入队时会空留出一个位置是什么意思","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582107172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72324,"discussion_content":"对于老师文中的正常的队列，tail 位置也是不保存数据的，那么tail 到底 存不存数据呢？还是示情况而定？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575473634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/cd/59d9fb36.jpg","nickname":"王同学","note":"","ucode":"F1D9F19366F1AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70548,"discussion_content":"如果按照这种思路来说，那么循环队列就不会浪费一个存储空间，所以循环队列到底会不会浪费一个单位的存储空间？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575366853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1108731,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/wIWrciav7DRkOaD7vUtr084sxprq2U4obfH1ibls4RIsAw5foQlDGIt98x1RHATznNbh0iasibWV2Y7I7QpyFJ4TVA/132","nickname":"Wipeher","note":"","ucode":"A5D7451D95F42C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1336525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/cd/59d9fb36.jpg","nickname":"王同学","note":"","ucode":"F1D9F19366F1AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293703,"discussion_content":"额外的保存size也占用一个空间，只不过原来n使用n-1，改良后n+1使用n而已","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1595645884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70548,"ip_address":""},"score":293703,"extra":""}]},{"author":{"id":1115302,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/a6/18c4f73c.jpg","nickname":"Airsaid","note":"","ucode":"5B90BC0044F376","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41839,"discussion_content":"根据这位老哥的思路实现的 Kotlin 代码：\n\nclass CycleQueue(private val capacity: Int) {\n\n  private val items = arrayOfNulls<String>(capacity)\n\n  private var size = 0\n  private var head = 0\n  private var tail = 0\n\n  fun enqueue(item: String): Boolean {\n    // 队已满\n    if (isFull()) {\n      return false\n    }\n\n    // 存储到队列的尾部\n    items[tail] = item\n    tail = (tail + 1) % capacity\n    size ++\n\n    return true\n  }\n\n  fun dequeue(): String? {\n    // 空队列\n    if (isEmpty()) {\n      return null\n    }\n\n    // 获取并移除队头数据\n    val item = items[head]\n    head = (head + 1) % capacity\n    size --\n\n    return item\n  }\n\n  fun isEmpty(): Boolean {\n    return size == 0\n  }\n\n  fun isFull(): Boolean {\n    return size == capacity\n  }\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572518228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2322244,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/mxxEd3scP7RUgoh9oXWqUZDU5fIabDIh0ALAcvGZy4GXJYiazicd2ARGodujqU77fbGHatPyZMdVSQ04Y0qNDWaA/132","nickname":"zzzzzc","note":"","ucode":"9F58C0BD30E300","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353672,"discussion_content":"这种方式依然要解决head与tail指针的周期性冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615187947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1093819,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b0/bb/fc698888.jpg","nickname":"leozhang","note":"","ucode":"DAC9015821DAF1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28840,"discussion_content":"public class CycleArrayQueue {\n\n    private  static  String [] queue;\n    private static  int size;\n    private static  int head;\n    private static  int tail;\n\n\n\n    public CycleArrayQueue(int length) {\n        queue = new String[length];\n    }\n\n    /**\n     *   0|1|2|3|4|5|6|7|\n     *           t     h\n     *\n     */\n    private void  enqueue(String key){\n\n        if (size>=queue.length){\n            throw  new RuntimeException();\n        }\n        queue[tail]=key;\n        //把 tail 向后移动;\n        if (tail==queue.length-1){\n            tail=0;\n        }else {\n            tail++;\n        }\n\n        size++;\n    }\n\n\n\n    /**\n     *   0|1|2|3|4|5|6|7|\n     *           t     h\n     *\n     */\n    private void dequeue(){\n\n        if (size==0){\n            throw  new RuntimeException();\n        }\n\n        //说明把 head 对应的节点删除掉，出队\n\n\n        queue[head]=null;\n\n        if (head==queue.length-1){\n            head=0;\n        }else {\n            head++;\n        }\n        size--;\n\n    }\n }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570714162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24143,"discussion_content":"多一个++和--操作。各有好处吧确实省了一个内存，多跑了几条指令。如果需要并发的话，你的size可能就不太好处理了。case没法保证原子性。size和(对队头或队尾)操作的原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570017056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1210699,"avatar":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","nickname":"-W.LI-","note":"","ucode":"3556786538664F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70077,"discussion_content":"多线程的情况下，肯定是要加锁，但是文中的方法是否也存在原子性问题呢？(入队、出队操作和head、tail指针移动之间的原子性)","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575308090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":24143,"ip_address":""},"score":70077,"extra":""},{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132661,"avatar":"https://static001.geekbang.org/account/avatar/00/11/48/75/02b4366a.jpg","nickname":"乘坐Tornado的线程魔法师","note":"","ucode":"C4C9915866E769","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324115,"discussion_content":"赞同你，好像不使用size变量就没了并发问题似的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605059084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":70077,"ip_address":""},"score":324115,"extra":""}]}]},{"had_liked":false,"id":38411,"user_name":"樱小路依然","can_delete":false,"product_type":"c1","uid":1269957,"ip_address":"","ucode":"DBA9FF68015FE5","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","comment_is_top":false,"comment_ctime":1542032550,"is_pvip":false,"replies":[{"id":"13815","content":"👍","user_name":"作者回复","comment_id":38411,"uid":"1190123","ip_address":"","utype":1,"ctime":1542074325,"user_name_real":"gg"}],"discussion_count":16,"race_medal":0,"score":"718801570982","product_id":100017301,"comment_content":"循环队列：队列满的表达式<br>这里讲一下，这个表达式是怎么来的。在一般情况下，我们可以看出来，当队列满时，tail+1=head。但是，有个特殊情况，就是tail=n-1，而head=0时，这时候，tail+1=n，而head=0，所以用(tail+1)%n == n%n == 0。而且，tail+1最大的情况就是 n ，不会大于 n，这样，tail+1 除了最大情况，不然怎么余 n 都是 tail+1 本身，也就是 head。这样，表达式就出现了。","like_count":167,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428694,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542074325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008395,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/0b/ad56aeb4.jpg","nickname":"二进制之路","note":"","ucode":"67C84B013147B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162164,"discussion_content":"只有一种场景需要进行求余，其他都只要加1即可。从效率上讲，这样判断处理更高效：\n    public boolean isFull() {\n        return nextIndex(tail) == head;\n    }\n\n    private int nextIndex(int index) {\n        return ++index == n ? 0 : index;\n    }","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1580966809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65751,"discussion_content":"恩 循环队列中，head  和 tail ，再移位 +1的时候，都要做越界判断，也就是 %n !","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575026446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398577,"avatar":"https://static001.geekbang.org/account/avatar/00/15/57/31/6772744d.jpg","nickname":"ちよくん","note":"","ucode":"B71E9B16E4408F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129575,"discussion_content":"这个还要得益于起始点是0的好处","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578715319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241363,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/13/0ecff761.jpg","nickname":"陈春求","note":"","ucode":"AAF95F699A6BDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383353,"discussion_content":"谢谢分享，根据您的解释，我重新整理了一下：\n当队列满时，如果head = 0，那么tail+1 = n，所以tail+1的最大值只能是等于 n ，不会大于 n。为了在计算时让tail+1的值不大于n，可以用tail+1对n取余，所以就有(tail+1)%n -> n%n -> 0 == head，最终得出(tail+1)%n=head","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626066230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299347,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d3/93/c3fb8566.jpg","nickname":"ProcessIsTheKey","note":"","ucode":"BE02EFD75F7D98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551510,"discussion_content":"解释很合理清晰，我想了半天，只会用if判断解决问题...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645027226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2792413,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/9b/dd/97a690a2.jpg","nickname":"倔强","note":"","ucode":"4C588A1E7C0F7C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399829,"discussion_content":"%n,不是范围从0~n-1吗？我还是没理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633076229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2714281,"avatar":"https://static001.geekbang.org/account/avatar/00/29/6a/a9/f58a4e28.jpg","nickname":"Fougère Royale","note":"","ucode":"AB375809A8AAB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387541,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628237654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2094043,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f3/db/3b540ba1.jpg","nickname":"Aii","note":"","ucode":"A2D8709CE7563D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342205,"discussion_content":"秒啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610614560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1957632,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqZGr575z4WfctOy5wcuNqbUFgdLErXyicWgyBvE8ZETgFsj2vfcKkRicMxet5UjM09mIpCxo99xpXA/132","nickname":"123-sky","note":"","ucode":"2B269A3CBF4382","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290028,"discussion_content":"十分感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594306080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1995224,"avatar":"","nickname":"xiaohash","note":"","ucode":"7A5FD2C22909E3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275948,"discussion_content":"看完解释豁然开朗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590774829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1730875,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/69/3b/7111598b.jpg","nickname":"Coutinho","note":"","ucode":"5D52969F8FB3DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269768,"discussion_content":"非常感谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589947894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/d2/32d3545a.jpg","nickname":"A.Windy","note":"","ucode":"254868B270F26D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84082,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576486254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063057,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKKW55c5xKo05Jys69d8B0NyaGaicyR6PM72s6xQkV7PDx2Rubu6YDn0icwlg48iaUIWdnpXWLIH2bkg/132","nickname":"大元","note":"","ucode":"3206E8E5FC25B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53993,"discussion_content":"了然了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574247635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1691517,"avatar":"https://static001.geekbang.org/account/avatar/00/19/cf/7d/d9085aaa.jpg","nickname":"punnpkin","note":"","ucode":"E635BD016D892F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52519,"discussion_content":"讲得很清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574060384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1564431,"avatar":"https://static001.geekbang.org/account/avatar/00/17/df/0f/0c483c62.jpg","nickname":"黑夜的骑士","note":"","ucode":"1351B67A3D2C3F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1978,"discussion_content":"感谢解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563158837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31802,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1539305469,"is_pvip":false,"replies":[{"id":"11474","content":"👍","user_name":"作者回复","comment_id":31802,"uid":"1190123","ip_address":"","utype":1,"ctime":1539310183,"user_name_real":"gg"}],"discussion_count":6,"race_medal":0,"score":"289302114301","product_id":100017301,"comment_content":"队列实现<br>一、数组实现<br>public class ArrayQueue {<br>&#47;&#47;存储数据的数组<br>private String[] items;<br>&#47;&#47;记录数组容量<br>private int n;<br>private int size;<br>&#47;&#47;head记录队头索引，tail记录队尾索引<br>private int head = 0;<br>private int tail = 0;<br>&#47;&#47;申请一个指定容量的队列<br>public ArrayQueue(int capacity){<br>items = new String[capacity];<br>n = capacity;<br>}<br>&#47;*<br>* 入队：<br>* 1.堆满的时，入队失败<br>* 1.1频繁出入队，造成数组使用不连续<br>* 1.2在入队的时候，集中触发进行数据搬移<br>* 2.在末尾插入数据，注意tail指向队尾元素的索引+1<br>*&#47;<br>public boolean enqueue(String item){<br>&#47;&#47;表示队满<br>if(head == 0 &amp;&amp; tail == n)<br>return false;<br>&#47;&#47;表示需要数据搬移<br>else if(head != 0 &amp;&amp; tail == n){<br>for (int i = head; i &lt; tail; i++) {<br>items[i-head] = items[i];<br>}<br>head = 0;<br>tail = tail - head;<br>}<br>&#47;&#47;将数据加入队列<br>items[tail++] = item;<br>size++;<br>return true;<br>}<br>&#47;&#47;出队：1.队空时，出队失败;2.出队，head索引+1<br>public String dequeue(){<br>String res = null;<br>if(head == tail) return res;<br>res = items[head++];<br>size--;<br>return res;<br>}<br>}<br>二、循环队列<br>public class LoopArrayQueue {<br>&#47;&#47;存储数据的数组<br>private String[] items;<br>&#47;&#47;记录数组容量<br>private int n;<br>private int size = 0;<br>&#47;&#47;head记录队头索引，tail记录队尾索引<br>private int head = 0;<br>private int tail = 0;<br>&#47;&#47;申请一个指定容量的队列<br>public LoopArrayQueue(int capacity){<br>items = new String[capacity];<br>n = capacity;<br>}<br>&#47;&#47;入队：关键在于队满的条件<br>public boolean enqueue(String item){<br>if ((tail + 1) % n == head) return false;<br>items[tail] = item;<br>tail = (tail + 1) % n;<br>size++;<br>return true;<br>}<br>&#47;&#47;出队：关键在于队空的条件<br>public String dequeue(){<br>String res = null;<br>if(head == tail) return res;<br>res = items[head];<br>head = (head + 1) % n;<br>size--;<br>return res;<br>}<br>}<br>三、链表实现<br>public class LinkedQueue {<br>&#47;&#47;定义一个节点类<br>private class Node{<br>String value;<br>Node next;<br>}<br>&#47;&#47;记录队列元素个数<br>private int size = 0;<br>&#47;&#47;head指向队头结点，tail指向队尾节点<br>private Node head;<br>private Node tail;<br>&#47;&#47;申请一个队列<br>public LinkedQueue(){}<br>&#47;&#47;入队<br>public boolean enqueue(String item){<br>Node newNode = new Node();<br>newNode.value = item;<br>if (size == 0) head = newNode; <br>else tail.next = newNode;<br>tail = newNode;<br>size++;<br>return true;<br>}<br>&#47;&#47;出队<br>public String dequeue(){<br>String res = null;<br>if(size == 0) return res;<br>if(size == 1) tail = null;<br>res = head.value;<br>head = head.next;<br>size--;<br>return res;<br>}<br>}","like_count":67,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426512,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1697762,"avatar":"https://static001.geekbang.org/account/avatar/00/19/e7/e2/dede857d.jpg","nickname":"蔡","note":"","ucode":"8245623EF689F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36092,"discussion_content":"数组实现 迁徙那块代码应该先 tail = tail - head 然后head = 0","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1571320475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592262,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epvkictDzeEouAWt4nSElejxogC67AVIaAKia2Q9oibE0G4NDoqiavHeEH9vEjdhibibMv43WTia3icP9OnpA/132","nickname":"不会唱歌的麦霸","note":"","ucode":"6559C9CB4D5963","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327986,"discussion_content":"链表实现那块  if (size == 0) head = newNode; 后面应该加上 if (size == 0) head = newNode; tail = newNode; 得初始化一下tail吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606035499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108731,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/wIWrciav7DRkOaD7vUtr084sxprq2U4obfH1ibls4RIsAw5foQlDGIt98x1RHATznNbh0iasibWV2Y7I7QpyFJ4TVA/132","nickname":"Wipeher","note":"","ucode":"A5D7451D95F42C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293704,"discussion_content":"链表那块，实现循环队列有想法没？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595645960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056488,"avatar":"","nickname":"alask.lu","note":"","ucode":"872F0D9193513B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289879,"discussion_content":"bingo","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594256993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066430,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/be/c04a40ce.jpg","nickname":"3W1H","note":"","ucode":"F6B4864128103C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43549,"discussion_content":"size == 1逻辑是啥意思哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572881074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125902,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1566270227,"is_pvip":false,"replies":[{"id":"47248","content":"完全正确！","user_name":"作者回复","comment_id":125902,"uid":"1190123","ip_address":"","utype":1,"ctime":1566774062,"user_name_real":"王争"}],"discussion_count":4,"race_medal":0,"score":"272149209875","product_id":100017301,"comment_content":"在正常情况下，队列的入队和出队操作时间复杂度都是O(1)，在进行“数据搬移”改造的情况下，入队的时间复杂度我是这么分析的：<br><br>如果队尾没有满，可以直接入队，时间复杂度为O(1)。<br><br>如果队尾已满的情况下，就必须进行数据搬移了，tail=n,搬移的时间复杂度为O(n).<br><br>总体情况来看，tail的可能是0~n的任意值，在0~n-1的时候队列入队的时间复杂度都是O(1)，不需要搬移直接入队即可；只有当tail=n的时候时间复杂度才迅速飙升为O(n)，即需要进行n次搬移，此时n次的搬移如果均摊到0~n-1这n次上，其实总体的均摊复杂度还是O(1)。<br>老师，我分析的是否正确？","like_count":63,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463741,"discussion_content":"完全正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566774062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1834181,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/fc/c5/ff8b770e.jpg","nickname":"BugBean","note":"","ucode":"B51232281AD9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264325,"discussion_content":"有种特殊情况就是当tail==n时，频繁地出队和入队，这时每次入队都要数据搬迁，复杂度为O(n)。虽然计算均摊复杂度时不应该把这种特殊情况考虑进去，但是对于队列的应用场景生产者-消费者来说，频繁的出入还是很常见的哈，个人观点，望指正","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1589298081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1834181,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/fc/c5/ff8b770e.jpg","nickname":"BugBean","note":"","ucode":"B51232281AD9BC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":272308,"discussion_content":"感觉一次数据搬移后，接下来n-size次入队都不需要搬移，请问你说每次都需要是什么意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590285334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":264325,"ip_address":""},"score":272308,"extra":""},{"author":{"id":1371809,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ee/a1/2fed3067.jpg","nickname":"Pucca","note":"","ucode":"AE37B8727C85E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316109,"discussion_content":"就是n-size等于1时，频繁的enqueue*1+搬移+dequeue*1+enqueue*1+搬移。。。循环","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603360318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":272308,"ip_address":""},"score":316109,"extra":""}]}]},{"had_liked":false,"id":31801,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1539305375,"is_pvip":false,"replies":[{"id":"11473","content":"👍","user_name":"作者回复","comment_id":31801,"uid":"1190123","ip_address":"","utype":1,"ctime":1539310163,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"267827277727","product_id":100017301,"comment_content":"总结<br>一、什么是队列？<br>1.先进者先出，这就是典型的“队列”结构。<br>2.支持两个操作：入队enqueue()，放一个数据到队尾；出队dequeue()，从队头取一个元素。<br>3.所以，和栈一样，队列也是一种操作受限的线性表。<br>二、如何实现队列？<br>1.队列API<br>public interface Queue&lt;T&gt; {<br>public void enqueue(T item); &#47;&#47;入队<br>public T dequeue(); &#47;&#47;出队<br>public int size(); &#47;&#47;统计元素数量<br>public boolean isNull(); &#47;&#47;是否为空<br>}<br>2.数组实现（顺序队列）：见下一条留言<br>3.链表实现（链式队列）：见下一条留言<br>4.循环队列（基于数组）：见下一条留言<br>三、队列有哪些常见的应用？<br>1.阻塞队列<br>1）在队列的基础上增加阻塞操作，就成了阻塞队列。<br>2）阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回。<br>3）从上面的定义可以看出这就是一个“生产者-消费者模型”。这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，比如配置几个消费者，来应对一个生产者。<br>2.并发队列<br>1）在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列。<br>2）并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作。<br>3）实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。<br>3.线程池资源枯竭是的处理<br>在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。<br>四、思考<br>1.除了线程池这种池结构会用到队列排队请求，还有哪些类似线程池结构或者场景中会用到队列的排队请求呢？<br>2.今天讲到并发队列，关于如何实现无锁的并发队列，网上有很多讨论。对这个问题，你怎么看？","like_count":62,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426511,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539310163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35743,"user_name":"阿阳","can_delete":false,"product_type":"c1","uid":1165817,"ip_address":"","ucode":"20A35FB86B1C5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/f9/39492855.jpg","comment_is_top":false,"comment_ctime":1540780647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"220584112743","product_id":100017301,"comment_content":"这里我真心给老师点赞。每节课都是由易到难，由基础到实战场景。比如这一节，先讲解队列的基本性质和实现方式，并做了对比；更重要的是，后面讲到了阻塞队列和并发队列，这个和平时开发遇到的场景类似，理论联系实际，又有代码的实现。<br>作为老程序员，这次学习数据结构与算法，不再迷惘，反而激发了学习兴趣。真心感谢老师！","like_count":51},{"had_liked":false,"id":33534,"user_name":"asule","can_delete":false,"product_type":"c1","uid":1244075,"ip_address":"","ucode":"FCF276911D05C1","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/ab/23dd1ece.jpg","comment_is_top":false,"comment_ctime":1539822735,"is_pvip":false,"replies":[{"id":"12096","content":"😄 是的","user_name":"作者回复","comment_id":33534,"uid":"1190123","ip_address":"","utype":1,"ctime":1539856573,"user_name_real":"gg"}],"discussion_count":7,"race_medal":0,"score":"211993220239","product_id":100017301,"comment_content":"很多同学都提到循环队列增加flag来避免浪费最后一个存储空间，那是不是flag本身也需要一个存储空间？","like_count":49,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426985,"discussion_content":"😄 是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539856573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121142,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1b/76/e927da9f.jpg","nickname":"晴天","note":"","ucode":"2FF5257193FC0A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79765,"discussion_content":"如果数组中存的不是 int 类型的值，用 int 类型做 size 计数，其实就省存储空间了","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1576110746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003515,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4f/fb/10366b97.jpg","nickname":"Henry","note":"","ucode":"54AFE9C99B31B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508,"discussion_content":"有道理，之前还想不通的，为啥要留下一个空位。如果不留空位的话需要一个变量来记录数组的长度，长度等于最大限制的时候就认为满了。但是维护这个变量也是需要存储空间的，倒不如直接用作者这个方式更好。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1561626643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1482915,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","nickname":"业余爱好者","note":"","ucode":"A890935A982988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60962,"discussion_content":"老铁真相","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574767361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1451253,"avatar":"https://static001.geekbang.org/account/avatar/00/16/24/f5/9178e11e.jpg","nickname":"step by step","note":"","ucode":"FE66757211878A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1336,"discussion_content":"asule和我的昵称一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562567252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2358638,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fd/6e/1913dbb6.jpg","nickname":"Amber","note":"","ucode":"650FE5C46CCD1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343594,"discussion_content":"空间换时间的思路。数据结构有讲解。\n多了一个空间，但是实现和效率都简单了，降低了抽象惩罚程度。\n类似的思路在链表，队列，冒泡排序中都有影子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611106451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1304586,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e8/0a/16a3609e.jpg","nickname":"逝光无痕","note":"","ucode":"0FBC0FF4613703","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307975,"discussion_content":"隐式变显式了🤗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600819805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31220,"user_name":"老司机","can_delete":false,"product_type":"c1","uid":1256721,"ip_address":"","ucode":"D226BBE43DA804","user_header":"","comment_is_top":false,"comment_ctime":1539133438,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"211992530942","product_id":100017301,"comment_content":"循环队列真的是比较牛逼的思路，尤其是linux内核源码的kfifo的实现，无论是取模运算转换成取与运算，还是考虑head，tail的溢出，牛逼","like_count":49,"discussions":[{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379536,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623943266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581352,"avatar":"https://static001.geekbang.org/account/avatar/00/18/21/28/4c13599a.jpg","nickname":"〈😐ノ","note":"","ucode":"A4EBDCE5EF943A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356263,"discussion_content":" N=2^k (k>=1)\nnum%N = num&amp;(N-1)\n ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615558105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111114,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqMtj8cibc3UmW5gTmnMtNxIl7Bibo0Fvs9SYwaIhfoNXtHEGvedcaxyicUys7ycLR7TKz08CKAia46pw/132","nickname":"自由檬","note":"","ucode":"7FFC8AD061A776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335676,"discussion_content":"打卡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608269687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2046036,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/sOuSC65kXWdWBAIIs6uXAD41Ed8Wo8tib81LLVOQJ2oK23TgPDy6x0PGmp7rXwLR3BHOicaKx1zib1DyfpCITK3dw/132","nickname":"GeekYanger","note":"","ucode":"E674B7D25261CC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289252,"discussion_content":"打卡，取模运算可以转换成与运算，但是与的值是有讲究的，必须是全1的这种。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594041298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":36470,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1541122266,"is_pvip":false,"replies":[{"id":"12952","content":"😄","user_name":"作者回复","comment_id":36470,"uid":"1190123","ip_address":"","utype":1,"ctime":1541123716,"user_name_real":"gg"}],"discussion_count":6,"race_medal":0,"score":"186224715994","product_id":100017301,"comment_content":"Q: 「Talk is cheap. Show me the code」怎么翻译比较好？<br><br>A: 屁话少说，放码过来。","like_count":43,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427879,"discussion_content":"😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541123716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239504,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e9/d0/af96c86a.jpg","nickname":"A米fans1111","note":"","ucode":"99BE48333DD919","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7911,"discussion_content":"有趣的灵魂，和对问题的洞察力，比记住一些碎片的套路，粗浅的学过一轮xxx   重要的多。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1567728772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355541,"discussion_content":"光说不练假把式，码到功成薪水来...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615449827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2008802,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/a6/e2/465eaa08.jpg","nickname":"Jimmy Chen","note":"","ucode":"B9912576885A5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413583,"discussion_content":"少罗嗦，上码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636516825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1978489,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/30/79/fcb94f00.jpg","nickname":"李书生","note":"","ucode":"096CEC01DFFCCD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292362,"discussion_content":"别bb，用代码说话","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595205426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1901476,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/03/a4/d39c747c.jpg","nickname":"以帅服人的珂哥","note":"","ucode":"1A94CA2D7980B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291615,"discussion_content":"别 BB,上代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594888246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31144,"user_name":"蝴蝶","can_delete":false,"product_type":"c1","uid":1193167,"ip_address":"","ucode":"8019924D99182F","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","comment_is_top":false,"comment_ctime":1539106848,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"147567994912","product_id":100017301,"comment_content":"这种实现思路中，出队操作的时间复杂度仍然是 O(1)，但入队操作的时间复杂度还是 O(1) 吗想了一下，考虑到head可能等于1,2,n-1,经过计算，觉得均摊和平均时间复杂度还是O(1),对么？","like_count":34,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65752,"discussion_content":"？？？环形队列吗？没有数据搬移操作啊，也就是 和 数据规模n无关，只要操作一次就好了。。当然是 O(1)了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575026571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4118,"discussion_content":"表示赞同。感觉入队时的情况比较多，不知道能否用均摊分析的方法。就直接计算了下加权平均时间复杂度，就是将所有的情况都列举出来，每种情况出现的概率都一样，最终计算的算法执行次数是，两个n^2的多项式相除，所以还是O(1)复杂度","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565143798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1986864,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/51/30/e1b329f1.jpg","nickname":"Ecmi++","note":"","ucode":"F3ED68AFF4CB39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258142,"discussion_content":"应该可以用均摊分析的方法，复杂度还是O(1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588652652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31308,"user_name":"Peter丶桥","can_delete":false,"product_type":"c1","uid":1242178,"ip_address":"","ucode":"42FA32F51BEA74","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/42/da9233eb.jpg","comment_is_top":false,"comment_ctime":1539146208,"is_pvip":false,"replies":[{"id":"11315","content":"行的","user_name":"作者回复","comment_id":31308,"uid":"1190123","ip_address":"","utype":1,"ctime":1539222753,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"121798230496","product_id":100017301,"comment_content":"老师要是有时间对课后问题集中式做下解答就好了","like_count":28,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426287,"discussion_content":"行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":33474,"user_name":"我以为你不看","can_delete":false,"product_type":"c1","uid":1240585,"ip_address":"","ucode":"BDBB01689EED97","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/09/c2923d39.jpg","comment_is_top":false,"comment_ctime":1539790857,"is_pvip":false,"replies":[{"id":"12099","content":"循环队列不行的 不然无法区分队空和队满","user_name":"作者回复","comment_id":33474,"uid":"1190123","ip_address":"","utype":1,"ctime":1539856941,"user_name_real":"gg"}],"discussion_count":6,"race_medal":0,"score":"113208940553","product_id":100017301,"comment_content":"一直想不明白为什么队列要空出一个空的格不存数据，不是可以直接入队存在tail里，tail＋＋再比较是否超出容量吗。","like_count":26,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426972,"discussion_content":"循环队列不行的 不然无法区分队空和队满","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539856941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2409475,"avatar":"https://static001.geekbang.org/account/avatar/00/24/c4/03/b5ff525d.jpg","nickname":"素质青年","note":"","ucode":"8E4C81A8648B66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342066,"discussion_content":"你问了我想问的问题 ","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1610589469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2237812,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/gGOGcSH4AcC6iaeVcibEsuKdkRMPWia5G1OQY9Bm5n9pR7HFWEmtWeK9S3RhibDf8ePibx7RsCRl2Ng6MOPL0ry9vHA/132","nickname":"Geek_71d8b8","note":"","ucode":"C767E902AE874B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361104,"discussion_content":"用一个额外的遍历count来记录队列中的个数，入队+1，出队-1，head和tail指针到队尾就置为0下标，从头开始循环，空间全部利用。在入队和出队前都用count作为队满队空的判断，这样是否可行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616593723,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2879848,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/f1/68/a37036a1.jpg","nickname":"酱萝卜干","note":"","ucode":"6AA054B8C44F09","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2237812,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/gGOGcSH4AcC6iaeVcibEsuKdkRMPWia5G1OQY9Bm5n9pR7HFWEmtWeK9S3RhibDf8ePibx7RsCRl2Ng6MOPL0ry9vHA/132","nickname":"Geek_71d8b8","note":"","ucode":"C767E902AE874B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554449,"discussion_content":"不用置为0 从头循环。 直接用count判断是否队满队空就行。head和taila一直往后走。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646384953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":361104,"ip_address":""},"score":554449,"extra":""}]},{"author":{"id":1154935,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9f/77/3a8fb89f.jpg","nickname":"活水","note":"","ucode":"8A93734B62AF04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46949,"discussion_content":"tail一直指向，最后一个元素的下一位，单向链表，最后一个tail节点越界了，但不访问，没有关系，顺序队列和链式队列都可以这么理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573228005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239504,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e9/d0/af96c86a.jpg","nickname":"A米fans1111","note":"","ucode":"99BE48333DD919","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7910,"discussion_content":"香侬大神说，消除不确定性的唯一方式是数据。\n从这个角度来讲，省500字","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567728505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34023,"user_name":"火火火","can_delete":false,"product_type":"c1","uid":1115878,"ip_address":"","ucode":"B9B3E4CC87CE8D","user_header":"https://static001.geekbang.org/account/avatar/00/11/06/e6/8c643d02.jpg","comment_is_top":false,"comment_ctime":1539952546,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"78849363874","product_id":100017301,"comment_content":"您尽管更新，我按顺序看。本来就是队列啊","like_count":18},{"had_liked":false,"id":76017,"user_name":"HunterYuan","can_delete":false,"product_type":"c1","uid":1015256,"ip_address":"","ucode":"F8900C33D29AA7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/d8/d7c77764.jpg","comment_is_top":false,"comment_ctime":1552524199,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"70272000935","product_id":100017301,"comment_content":"思考题：<br>1. 在网卡的收发数据包操作，linux内核协议栈采用循环队列的方式进行处理。<br>2.linux内核态ruc和用户态urcu实现了无锁并发访问共享数据，非常适合于读多写少的场景。其核心思想是，拷贝复制链表数据，原子操作移动链表指针，实现真正的无锁操作。","like_count":16,"discussions":[{"author":{"id":1518842,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2c/fa/d9ef3e77.jpg","nickname":"牛仔很忙。","note":"","ucode":"5037849220E48D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579553,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657524964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2621412,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ff/e4/927547a9.jpg","nickname":"无名无姓","note":"","ucode":"487BD5AA2CD305","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390888,"discussion_content":"高手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630120311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1154935,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9f/77/3a8fb89f.jpg","nickname":"活水","note":"","ucode":"8A93734B62AF04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46944,"discussion_content":"那有没有可能去读的时候已经出队了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573227785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31277,"user_name":"最初的印象","can_delete":false,"product_type":"c1","uid":1228852,"ip_address":"","ucode":"4DD68307FA274E","user_header":"https://static001.geekbang.org/account/avatar/00/12/c0/34/0574bb44.jpg","comment_is_top":false,"comment_ctime":1539141844,"is_pvip":false,"replies":[{"id":"11316","content":"等我有空了吧 最近有点忙","user_name":"作者回复","comment_id":31277,"uid":"1190123","ip_address":"","utype":1,"ctime":1539222827,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"70258618580","product_id":100017301,"comment_content":"能不能写下阻塞队列和并发队列的代码","like_count":16,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426275,"discussion_content":"等我有空了吧 最近有点忙","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2035702,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0f/f6/609ded9f.jpg","nickname":"tingting","note":"","ucode":"61E6B0C4EC59C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589902,"discussion_content":"阻塞队列和并发队列的实现可以参考一下go语言中的channel的底层代码。 不过跟老师说的无锁CAS并发队列实现不同，channel的实现是使用一把大锁来保证的线程安全。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665389069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"新加坡"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35958,"user_name":"djane","can_delete":false,"product_type":"c1","uid":1249032,"ip_address":"","ucode":"5315AA246AFDD8","user_header":"","comment_is_top":false,"comment_ctime":1540872225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61670414369","product_id":100017301,"comment_content":"【笔记】<br>一、如何理解“队列”？<br>1、队列是一种操作受限的线性表数据结构。<br>2、队列最大的特点就是先进先出。<br>3、最基本的操作：入队 enqueue()，放一个数据到队列尾部；出队 dequeue()，从队列头部取一个元素。<br><br>二、顺序队列和链式队列<br>1、用数组实现的队列叫顺序队列，用链表实现的队列叫链式队列。<br>2、队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。<br>3、随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。<br>       实际上，我们在出队时可以不用搬移数据。如果没有空闲空间了，只需要在入队时，再集中触发一次数据的搬移操作。出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。<br>4、基于链表的实现，同样需要两个指针：head 指针和 tail 指针。分别指向链表的第一个结点和最后一个结点。入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next。<br><br>三、循环队列<br>1、循环队列，原本数组是有头有尾的，是一条直线。把首尾相连，扳成了一个环。<br>2、在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，需要像环一样的循环队列。<br>3、要想写出没有 bug 的循环队列的实现代码，最关键的是，确定好队空和队满的判定条件。<br>1）队列为空的判断条件仍然是 head == tail。<br>2）当队满时，(tail+1)%n=head。 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。<br><br>四、阻塞队列和并发队列<br>1、阻塞队列<br>1）阻塞队列就是在队列基础上增加了阻塞操作。<br>2）在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。<br>3）基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。<br><br>2、并发队列<br>1）线程安全的队列，叫作并发队列。<br>2）最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。<br>3）实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。<br><br>五、线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？<br>一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<br>1、基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。<br>2、基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。<br>（除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。）<br><br>【思考】<br>一、1、像windows操作系统的消息队列，略高级一些带有优先级。还有qt中的信号与槽函数机制，使用connect链接，其中的参数就是设置为把窗口界面消息放到消息队列，然后一次取出。比如优先级消息，窗口系统关闭，优先级高，则就直接执行关闭操作。<br>2、sockets网络连接队列。<br>3、数据库连接队列。<br>4、一种集群操作，很多客户端像服务端请求资源，处理高并发大量请求。把这些请求放到队列中。<br>5、分布式应用中的消息队列，也是一种队列结构。<br>二、考虑使用CAS实现无锁队列，则在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。","like_count":14},{"had_liked":false,"id":70657,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1551157726,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"44500830686","product_id":100017301,"comment_content":"@计科一班的引入size做边界判断并不见得比较好。出入队多了一步计算不说，竞量的判断还需要原子操作来保证线程安全。对比老师的代码，有一定性能损失。","like_count":10,"discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162641,"discussion_content":"移动指针也需要线程安全的，所以多个size没有区别。除非是要榨干性能的情况下才需要考虑size变化损失的性能的，否则没必要在意那点开销。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581000348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1209523,"avatar":"https://static001.geekbang.org/account/avatar/00/12/74/b3/b96a4ed7.jpg","nickname":"king5699","note":"","ucode":"0D5D851084A6E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145916,"discussion_content":"引入size，是以时间换空间。老师是以空间换时间。一般情况应该是空间没有时间值钱","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579588943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1108731,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/wIWrciav7DRkOaD7vUtr084sxprq2U4obfH1ibls4RIsAw5foQlDGIt98x1RHATznNbh0iasibWV2Y7I7QpyFJ4TVA/132","nickname":"Wipeher","note":"","ucode":"A5D7451D95F42C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1209523,"avatar":"https://static001.geekbang.org/account/avatar/00/12/74/b3/b96a4ed7.jpg","nickname":"king5699","note":"","ucode":"0D5D851084A6E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293709,"discussion_content":"多个size一样占用空间啊，为什么会觉得多个size是0空间呢，不过就是让循环队列最后一个空间可以使用，再多个空间保存size，n->n-1变成了n+1到n而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595646445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":145916,"ip_address":""},"score":293709,"extra":""}]}]},{"had_liked":false,"id":52527,"user_name":"LeonardRon","can_delete":false,"product_type":"c1","uid":1026808,"ip_address":"","ucode":"1B3ACC61DE1877","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/f8/4b89254e.jpg","comment_is_top":false,"comment_ctime":1545405533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44495078493","product_id":100017301,"comment_content":"tail称为尾后元素下标是不是更方便理解？即表示的尾元素的下一个位置（结合C++ STL 里的称呼）","like_count":10},{"had_liked":false,"id":31919,"user_name":"oldman","can_delete":false,"product_type":"c1","uid":1133711,"ip_address":"","ucode":"6BACE2832B4429","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/8f/a90b3969.jpg","comment_is_top":false,"comment_ctime":1539329661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44489002621","product_id":100017301,"comment_content":"使用列表实现队列和循环队列，我用python实现了一遍，各位看官一起交流。<br>https:&#47;&#47;github.com&#47;lipeng1991&#47;testdemo&#47;blob&#47;master&#47;38_array_implementation_queue.py<br>https:&#47;&#47;github.com&#47;lipeng1991&#47;testdemo&#47;blob&#47;master&#47;39_array_implementation_loop_queue.py","like_count":10},{"had_liked":false,"id":31390,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1539169669,"is_pvip":false,"replies":[{"id":"11310","content":"行的呢 我抽空集中答疑一下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539222418,"ip_address":"","comment_id":31390,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40193875333","product_id":100017301,"comment_content":"老师，课后习题有空讲解一下理解呀！每次看评论，有的还是不太明白的地方","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426320,"discussion_content":"行的呢 我抽空集中答疑一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162785,"user_name":"热心市民小侯","can_delete":false,"product_type":"c1","uid":1347767,"ip_address":"","ucode":"0F7D64B5F7193B","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/b7/711aa6f9.jpg","comment_is_top":false,"comment_ctime":1576589427,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35936327795","product_id":100017301,"comment_content":"LeetCode上的622题就是循环队列，其中如何获取队尾元素，也挺有意思，题目链接：<br>https:&#47;&#47;leetcode-cn.com&#47;problems&#47;design-circular-queue&#47;<br>然后关于线程池如何设置队列大小，老师可否讲一下？","like_count":8,"discussions":[{"author":{"id":1526428,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epMicvN0PDCMibmBvwAyoScCjjgfLBWaQwGic9ialXObicxKib9X0T0gx02gL4jqvibEr1FRzMaiaicN8cgEBg/132","nickname":"Geek_ac4080","note":"","ucode":"E2C480962E6CEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290056,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594312011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31294,"user_name":"liyghting","can_delete":false,"product_type":"c1","uid":1108970,"ip_address":"","ucode":"439794ECEEFD26","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/ea/7d00f657.jpg","comment_is_top":false,"comment_ctime":1539143769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31603914841","product_id":100017301,"comment_content":"队列可用于资源有限的场景，比如卖火车票，抢购等","like_count":7},{"had_liked":false,"id":46193,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1543882978,"is_pvip":false,"replies":[{"id":"16520","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543887321,"ip_address":"","comment_id":46193,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27313686754","product_id":100017301,"comment_content":"把该讲内容总结为几个问题, 大家复习的时候可以先尝试回答这些问题检查自己的掌握程度:<br>\t1. 队列是如何定义的? 有哪些基本操作, 时间复杂度各是多少?<br>\t2. 顺序队列和链式队列各是如何实现的?<br>\t3. 顺序队列如何做数据迁移?<br>\t4. 循环队列的定义是什么,如何代码实现?<br>\t5. 阻塞队列和并发队列的概念各是怎么样的, 如何实现, 有什么样的应用场景?<br><br>","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431367,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543887321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203791,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586267038,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"23061103518","product_id":100017301,"comment_content":"理论一听就懂，代码一看就会，但是一动手就废😂。","like_count":5},{"had_liked":false,"id":139309,"user_name":"徐帅","can_delete":false,"product_type":"c1","uid":1448864,"ip_address":"","ucode":"BDF904280E2330","user_header":"https://static001.geekbang.org/account/avatar/00/16/1b/a0/7c7d1b4a.jpg","comment_is_top":false,"comment_ctime":1570608703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23045445183","product_id":100017301,"comment_content":"C++ 11 无锁队列开源函数库：concurrentqueue，c# 无锁队列系统库：System.Collections.Concurrent","like_count":5},{"had_liked":false,"id":45201,"user_name":"starichat","can_delete":false,"product_type":"c1","uid":1237296,"ip_address":"","ucode":"4DD0C21C7AA803","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/30/d5183ce9.jpg","comment_is_top":false,"comment_ctime":1543560280,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"23018396760","product_id":100017301,"comment_content":"CAS 原子操作能具体解释下是什么意思，怎么进行的吗？","like_count":5,"discussions":[{"author":{"id":1033240,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkwbyTYtSCx6Qc7cQPnnRWv38Jybh3etziaPmuP8gHcgS6FMxcdftrKgWiamH6fc2iciaicDKDVEwcEibQ/132","nickname":"sami","note":"","ucode":"9A66FCA00D8A37","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60749,"discussion_content":"Compare and swap，操作系统底层支持的一个命令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574751675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1154935,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9f/77/3a8fb89f.jpg","nickname":"活水","note":"","ucode":"8A93734B62AF04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46953,"discussion_content":"如果两个相同的元素入队呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573228075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1235253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d9/35/1d4270d6.jpg","nickname":"GeorgeMR","note":"","ucode":"1511A6AB3AC8FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1154935,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9f/77/3a8fb89f.jpg","nickname":"活水","note":"","ucode":"8A93734B62AF04","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390910,"discussion_content":"额外增加一个 versionNo 的判断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630136504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":46953,"ip_address":""},"score":390910,"extra":""}]},{"author":{"id":1220552,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","nickname":"Geek_b617bf","note":"","ucode":"9BAFC3B184B1D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24544,"discussion_content":"修改前比较一下原值,符合预期才修改,否则认为是被别人改过了.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570173957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36600,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1541167458,"is_pvip":false,"replies":[{"id":"13113","content":"普通队列不会浪费的 满的时候tail指向n 而不是n-1 <br>数组中所有的位置都有数据","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541383958,"ip_address":"","comment_id":36600,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23016003938","product_id":100017301,"comment_content":"tail指向存有元素的后一位，由于tail没有存储数据，当tail == n时队列已满，普通队列是不是也会浪费一个空间？","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427930,"discussion_content":"普通队列不会浪费的 满的时候tail指向n 而不是n-1 \n数组中所有的位置都有数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541383958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72334,"discussion_content":"但是老师文中 画的普通队列 tail 位置也是没有存储数据的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575473800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35545,"user_name":"roc","can_delete":false,"product_type":"c1","uid":1068263,"ip_address":"","ucode":"7F861184C52CB1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/e7/28fb0ddb.jpg","comment_is_top":false,"comment_ctime":1540647626,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23015484106","product_id":100017301,"comment_content":"数组循环队列go语言版<br><br>type CircularQueue struct {<br>\titems         []string<br>\thead, tail, n int<br>}<br><br>func NewCircularQueue(capacity int) *CircularQueue {<br>\treturn &amp;CircularQueue{<br>\t\titems: make([]string, capacity),<br>\t\tn:     capacity,<br>\t}<br>}<br><br>func (q *CircularQueue) Enqueue(item string) bool {<br>\tif (q.tail+1)%q.n == q.head { &#47;&#47; full<br>\t\treturn false<br>\t}<br>\tq.items[q.tail] = item<br>\tq.tail = (q.tail + 1) % q.n<br>\treturn true<br>}<br><br>func (q *CircularQueue) Dequeue() (string, bool) {<br>\tif q.head == q.tail {<br>\t\treturn &quot;&quot;, false<br>\t}<br>\titem := q.items[q.head]<br>\tq.head = (q.head + 1) % q.n<br>\treturn item, true<br>}<br>","like_count":5,"discussions":[{"author":{"id":2666247,"avatar":"https://static001.geekbang.org/account/avatar/00/28/af/07/4553214d.jpg","nickname":"书有径","note":"","ucode":"887B0414A8E87A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392785,"discussion_content":"mark\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631117816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32506,"user_name":"静觅","can_delete":false,"product_type":"c1","uid":1237102,"ip_address":"","ucode":"1B44469E63DDFD","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/6e/62719b08.jpg","comment_is_top":false,"comment_ctime":1539594147,"is_pvip":false,"replies":[{"id":"11851","content":"是的👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539606807,"ip_address":"","comment_id":32506,"utype":1}],"discussion_count":4,"race_medal":0,"score":"23014430627","product_id":100017301,"comment_content":"队列满的条件head=(tail+1)%capacity，在满足该条件的if里面执行对tail位置的入队操作，同时设置一个flag表示队列满，在下一次调用enqueue可以先判断flag，如果队列满，则直接返回，在调用dequeue后，修改flag，这样感觉可以避免循环队列的一个空间的浪费","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426798,"discussion_content":"是的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539606807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162646,"discussion_content":"flag不也占空间吗？我觉得(tail+1)%n==head &amp;&amp; tail==n-1来判定队满就足够了，也不会浪费空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581000601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1441789,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ff/fd/df112fd1.jpg","nickname":"南瓜","note":"","ucode":"0E2F515E085595","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363532,"discussion_content":"tail=n-1不一定是队列满了，因为head不一定是0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617207081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":162646,"ip_address":""},"score":363532,"extra":""},{"author":{"id":2309626,"avatar":"","nickname":"Geek_459ad9","note":"","ucode":"01F853CFABB511","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384346,"discussion_content":"flag就一个bool变量.但不用flag就是占用一个数组类型的空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626510432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":162646,"ip_address":""},"score":384346,"extra":""}]}]},{"had_liked":false,"id":31513,"user_name":"我是谁","can_delete":false,"product_type":"c1","uid":1073487,"ip_address":"","ucode":"D6C67E29D62EA9","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/4f/e0b71e72.jpg","comment_is_top":false,"comment_ctime":1539221087,"is_pvip":false,"replies":[{"id":"11388","content":"👍 你get到了精髓","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539256916,"ip_address":"","comment_id":31513,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23014057567","product_id":100017301,"comment_content":"入队操作的时间复杂度应该跟入队和出队的速度有关吧，具体分析有点晕。。。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426381,"discussion_content":"👍 你get到了精髓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539256916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162661,"discussion_content":"对于普通队列来说，应该是tail移动到n时的次数多寡决定了数据迁移的频率，从而影响入队操作的速度。\n循环队列不存在数据迁移，所以入队操作速度是恒定的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581001309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31238,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1539134903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23013971383","product_id":100017301,"comment_content":"感觉入队时head为1，2...n-1的概率都是1&#47;n-1,而每种情况对应的复杂度为n-1...,1，所以复杂度为O(n),不知道对不","like_count":5},{"had_liked":false,"id":110744,"user_name":"pythonista","can_delete":false,"product_type":"c1","uid":1493954,"ip_address":"","ucode":"CE117439281B93","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/c2/abd584db.jpg","comment_is_top":false,"comment_ctime":1562323437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18742192621","product_id":100017301,"comment_content":"广度优先遍历也用到了队列","like_count":4},{"had_liked":false,"id":31984,"user_name":"博金","can_delete":false,"product_type":"c1","uid":1173559,"ip_address":"","ucode":"86C2542E007E55","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/37/1ea4de97.jpg","comment_is_top":false,"comment_ctime":1539349337,"is_pvip":false,"replies":[{"id":"11592","content":"👍 回答的很好！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539401588,"ip_address":"","comment_id":31984,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18719218521","product_id":100017301,"comment_content":"对于第一个思考题:<br>1.像windows操作系统的消息队列，略高级一些带有优先级。还有qt中的信号与槽函数机制，使用connect链接，其中的参数就是设置为把窗口界面消息放到消息队列，然后一次取出。比如优先级消息，窗口系统关闭，优先级高，则就直接执行关闭操作。<br>2.sockets网络连接队列。<br>3.数据库连接队列。<br>4.还有一种集群操作，很多客户端像服务端请求资源，处理高并发大量请求。把这些请求放到队列中。","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426594,"discussion_content":"👍 回答的很好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31266,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1539140032,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18719009216","product_id":100017301,"comment_content":"队列是一种先进先出的数据结构，跟栈类似，队列是一种操作受限的线性表。<br><br>队列同样可以由数组和链表来实现。<br><br>队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。<br><br>## 顺序队列<br>顺序队列存在一个问题， tail 指针移动到数组最大下标时，即使数组中还有空闲空间，也无法继续往队列中添加数据了。<br><br>解决方法是在入队列时，如果没有空闲空间，就触发一次搬运，将 head 到 tail 之间的数据，整体搬运到数组的 0 到 tail - head 位置。<br><br>## 链式队列<br>链式队列与顺序队列的区别是没有容量限制，在请求排队的场景下，如果排队的请求数量过多，请求处理的响应时间会过长。<br><br>## 循环队列<br>循环队列是为了解决顺序队列在 tail == n 时，需要数据搬运操作的问题。<br><br>队列为空时可以根据 head == tail 来判断。循环队列满时，tail 指针位置不存储数据，所以队满判断公式为：<br><br>(tail + 1) % n = head<br><br>## 阻塞和并发队列<br>阻塞队列在队列为空的时候，从队头取数据会被阻塞，直到队列中有数据才会返回；如果队列已经满了，插入数据操作会被阻塞，直到队列中有空闲的位置后再插入，然后再返回。<br><br>在考虑线程安全时，需要用到并发队列，并发队列同一时刻只允许一个插入操作，但是允许多个读操作。","like_count":4},{"had_liked":false,"id":31253,"user_name":"Mr.Panda","can_delete":false,"product_type":"c1","uid":1238864,"ip_address":"","ucode":"655A3013B5E849","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/50/d476ed6c.jpg","comment_is_top":false,"comment_ctime":1539137228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18719006412","product_id":100017301,"comment_content":"常规操作，看一遍，再看一遍，做思考总结，再实现一遍","like_count":4},{"had_liked":false,"id":252829,"user_name":"图图","can_delete":false,"product_type":"c1","uid":1834176,"ip_address":"","ucode":"0A0E3EF0206EC0","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKT7Exm9wh9wtiax9JPOjCMApEsfUQ8rxh7nib0UywJdFOsqnhsGQJYzpB5eAfasmNoaDOGic5vy8wmQ/132","comment_is_top":false,"comment_ctime":1602496063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14487397951","product_id":100017301,"comment_content":"为什么没有关于队列的leetcode 题推荐","like_count":3},{"had_liked":false,"id":208223,"user_name":"luffy","can_delete":false,"product_type":"c1","uid":1244950,"ip_address":"","ucode":"702034E116A99F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/16/b0ab9a73.jpg","comment_is_top":false,"comment_ctime":1587304410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14472206298","product_id":100017301,"comment_content":"golang的chan就是一种就是一种阻塞队列，并且是并发安全的，且用在数据库连接池的设计或者轮询请求非常方便。","like_count":3},{"had_liked":false,"id":172339,"user_name":"Zhaoyang","can_delete":false,"product_type":"c1","uid":1037190,"ip_address":"","ucode":"131D83AC2566D2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/86/b5d72c87.jpg","comment_is_top":false,"comment_ctime":1579157555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14464059443","product_id":100017301,"comment_content":"循环队列，我想到了MySQL里面的redo log了，就是用的这种数据结构。","like_count":3},{"had_liked":false,"id":145336,"user_name":"李飞","can_delete":false,"product_type":"c1","uid":1179622,"ip_address":"","ucode":"4B23FF72AA4BA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/e6/4b0ddfcf.jpg","comment_is_top":false,"comment_ctime":1572253302,"is_pvip":false,"replies":[{"id":"56465","content":"不需要的，因为再用到这个空间的时候，会直接被覆盖掉。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572487733,"ip_address":"","comment_id":145336,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14457155190","product_id":100017301,"comment_content":"老师写的循环队列，出队的时候，head往后+1后移动一位后，出队的数据不需要清除吗？","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472342,"discussion_content":"不需要的，因为再用到这个空间的时候，会直接被覆盖掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572487733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36606,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1541170105,"is_pvip":false,"replies":[{"id":"13114","content":"一个小时时间不多 我当年学的时候要花一个礼拜","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541384013,"ip_address":"","comment_id":36606,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14426071993","product_id":100017301,"comment_content":"这一节认真看了一个多小时，最终全部理解了，基础比较薄弱，问了些比较傻的问题，请王争老师见谅哈，收获很多，谢谢您！","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427934,"discussion_content":"一个小时时间不多 我当年学的时候要花一个礼拜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541384013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162655,"discussion_content":"刚看不行，还得练。把几个队列都实现一遍，自测过了，那就差不多了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581001017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31403,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1539172811,"is_pvip":false,"replies":[{"id":"11308","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539222380,"ip_address":"","comment_id":31403,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14424074699","product_id":100017301,"comment_content":"Spark在处理job的时候，可以配置使用FIFO或者Fair模式","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426324,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31235,"user_name":"天若有情天亦老","can_delete":false,"product_type":"c1","uid":1172029,"ip_address":"","ucode":"57F0B7D524C0CF","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/3d/9a52946b.jpg","comment_is_top":false,"comment_ctime":1539134666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14424036554","product_id":100017301,"comment_content":"AQS是利用队列实现的","like_count":3},{"had_liked":false,"id":50949,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1545092971,"is_pvip":false,"replies":[{"id":"18321","content":"涉及到线程方面的技术了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545096924,"ip_address":"","comment_id":50949,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10135027563","product_id":100017301,"comment_content":"阻塞的时候这个线程等待操作是怎么实现的？while循环拿吗？","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433197,"discussion_content":"涉及到线程方面的技术了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545096924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282496,"discussion_content":"有两种方案。1. whileTRUE 循环，不停的通过cas进行重试，直到成功。，类似自旋锁。2. 通过lock.newcondition，在满了的时候，当前线程会释放锁进入等待状态\nJAVA里的arrayBLOCKINGQUEUE就是第二种方式实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591995381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41340,"user_name":"Doggy","can_delete":false,"product_type":"c1","uid":1235269,"ip_address":"","ucode":"85215B0FA3816A","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/45/82d4de0b.jpg","comment_is_top":false,"comment_ctime":1542766829,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10132701421","product_id":100017301,"comment_content":"老师，关于那个复杂度分析的能解释一下吗，比较在意复杂度的分析，因为比较薄弱。个人觉得存在一个极端情况，如果队列长度为N，队列已经满了。此时出队一个元素，再入队，就需要N - 1次搬移，但是也只够一次O(1)的入队。这样均摊是做不到的。<br>假如有k个数据，队列总长度为N，那么如果在tail没有到顶时，复杂度为O(1)。但是如果到顶，需要搬移k次，但也只够N - K次入队操作(k &gt; N &#47; 2)，无法均摊完全。但是感觉情况考虑的还不是很完全，所以想请教一下老师。","like_count":2},{"had_liked":false,"id":31970,"user_name":"张勇","can_delete":false,"product_type":"c1","uid":1234450,"ip_address":"","ucode":"B08F8E7F802D81","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/12/6a5e6841.jpg","comment_is_top":false,"comment_ctime":1539345512,"is_pvip":false,"replies":[{"id":"11589","content":"哈哈，你自己写吧，python脚本语言执行效率可能确实没有c c++这种高 但也不会差别太大","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539401546,"ip_address":"","comment_id":31970,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10129280104","product_id":100017301,"comment_content":"老师，可以用python写代码吗，大家都说python运行慢。","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426586,"discussion_content":"哈哈，你自己写吧，python脚本语言执行效率可能确实没有c c++这种高 但也不会差别太大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539401546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239504,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e9/d0/af96c86a.jpg","nickname":"A米fans1111","note":"","ucode":"99BE48333DD919","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7912,"discussion_content":"比java强就好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567728981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31558,"user_name":"筑梦之队","can_delete":false,"product_type":"c1","uid":1256746,"ip_address":"","ucode":"42C7B6B41755C2","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/2a/af9a74dd.jpg","comment_is_top":false,"comment_ctime":1539228453,"is_pvip":true,"replies":[{"id":"11413","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539268842,"ip_address":"","comment_id":31558,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10129163045","product_id":100017301,"comment_content":"我实现了一个无需浪费一个空间，而只需要添加一个int类型的变量用来记录当前的总数量即可，这样如果存储的数据类型的长度大于int的长度，那么就可以节约空间；但如果存储的数据类型小于int那反而是浪费空间了。<br> 1 #!&#47;usr&#47;bin&#47;bash<br>  2<br>  3 class Queue:<br>  4     def __init__(self, capacity):<br>  5         self.capacity = capacity<br>  6         self.queue = [None] * self.capacity<br>  7         self.head = 0<br>  8         self.tail = 0<br>  9         self.count = 0<br> 10     <br> 11     def enqueue(self, data):<br> 12         if self.count == self.capacity:<br> 13             print(&quot;There is no space for new data&quot;)<br> 14             return<br> 15         <br> 16         self.queue[self.tail] = data<br> 17         self.tail = (self.tail + 1) % self.capacity<br> 18         self.count = self.count + 1<br> 19         print(&quot;enqueue:&quot;, self.head, self.tail, data, self.count)<br> 20     <br> 21     def dequeue(self):<br> 22         if self.count == 0:<br> 23             print(&quot;There is no data in queue&quot;)<br> 24             return<br> 25 <br> 26         data = self.queue[self.head]<br> 27         self.head = (self.head + 1) % self.capacity<br> 28         self.count = self.count - 1<br> 29         print(&quot;dequeue:&quot;, data)<br> 30         return data<br>","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426401,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539268842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317847,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/d7/868d26ce.jpg","nickname":"songhyunmin","note":"","ucode":"D5A98668CD8532","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352443,"discussion_content":"你这是bash？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614739021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31138,"user_name":"易水寒","can_delete":false,"product_type":"c1","uid":1238961,"ip_address":"","ucode":"F5D8127ED4754E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e7/b1/5c63be67.jpg","comment_is_top":false,"comment_ctime":1539102393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10129036985","product_id":100017301,"comment_content":"用到队列的还有连接池，比如数据库连接池，应该也是用到了。获取锁时也有用到，java中的AQS，synchronized可能也是用队列来存储锁请求的线程。","like_count":2},{"had_liked":false,"id":310313,"user_name":"T------T","can_delete":false,"product_type":"c1","uid":2270365,"ip_address":"","ucode":"AC68D88893FAD7","user_header":"https://static001.geekbang.org/account/avatar/00/22/a4/9d/95900f70.jpg","comment_is_top":false,"comment_ctime":1630589495,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5925556791","product_id":100017301,"comment_content":" CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。<br>    CAS 的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS 就是在一个循环里不断的做cas 操作，直到成功为止<br>    ![cb33c564496dd5181346676f8e39787d.png](en-resource:&#47;&#47;database&#47;1981:1)","like_count":1},{"had_liked":false,"id":304421,"user_name":"Geek_962f6d","can_delete":false,"product_type":"c1","uid":2705451,"ip_address":"","ucode":"5C9D1499BF10EA","user_header":"","comment_is_top":false,"comment_ctime":1627397002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5922364298","product_id":100017301,"comment_content":"上面的代码种的tail指向的下一个要插入的位置，而不是队列中最后一个元素。(开发中经常因为+1，-1的问题弄错，写出bug，有感而发）","like_count":1},{"had_liked":false,"id":293585,"user_name":"JayMe_DotDot","can_delete":false,"product_type":"c1","uid":1902591,"ip_address":"","ucode":"813CB9AF5744BE","user_header":"https://static001.geekbang.org/account/avatar/00/1d/07/ff/3b508125.jpg","comment_is_top":false,"comment_ctime":1621437672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5916404968","product_id":100017301,"comment_content":"数组队列，只在无法入队时进行数据迁移，根据这个思路，时间复杂度为O(1)。但是如果这个数组队列一直都处于排满状态或者基本排满状态的话，那入队的时间复杂度就直接降为了O(n)。<br>不知道对不对","like_count":1},{"had_liked":false,"id":208789,"user_name":"Try","can_delete":false,"product_type":"c1","uid":1030763,"ip_address":"","ucode":"061798B86E1A7A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/6b/782f9a74.jpg","comment_is_top":false,"comment_ctime":1587438497,"is_pvip":false,"replies":[{"id":"78046","content":"iPad Paper","user_name":"编辑回复","user_name_real":"王锦","uid":"1058895","ctime":1587440855,"ip_address":"","comment_id":208789,"utype":2}],"discussion_count":1,"race_medal":0,"score":"5882405793","product_id":100017301,"comment_content":"老师的手绘图真好看，能方便感知是用什么软件吗？","like_count":1,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492623,"discussion_content":"iPad Paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587440855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205605,"user_name":"yoummg","can_delete":false,"product_type":"c1","uid":1067856,"ip_address":"","ucode":"1B809CFDD7A508","user_header":"https://static001.geekbang.org/account/avatar/00/10/4b/50/fdecd51a.jpg","comment_is_top":false,"comment_ctime":1586683078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881650374","product_id":100017301,"comment_content":"队列 先进先出<br>队列 VS 栈<br><br>现实应用：redis 的list ，MQ<br>CAS实现无锁队列，@城回答很好，学习了。<br>入队前，先获取tail位置，入队时，比较tail是否发生变化，如果否，则入队，反之则失败。<br>出队获取head位置，进行cas比较。","like_count":1},{"had_liked":false,"id":161005,"user_name":"俗人or诗","can_delete":false,"product_type":"c1","uid":1357122,"ip_address":"","ucode":"C23CCA8B5BE8A8","user_header":"https://static001.geekbang.org/account/avatar/00/14/b5/42/21ed2f7b.jpg","comment_is_top":false,"comment_ctime":1576076812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871044108","product_id":100017301,"comment_content":"1、db连接池和redis连接池<br>2、可以利用CAS、Fetch And Add、Test-and-set来实现；在入队时，获取该队列的tail值（尾指针），如果tail不再是尾指针，那就有进程占用队列，等待入队后，tail值回归尾指针；如果是的话，那就改变尾指针，入队，后续释放指针。","like_count":1},{"had_liked":false,"id":132662,"user_name":"huangzehao","can_delete":false,"product_type":"c1","uid":1386934,"ip_address":"","ucode":"8A6530D82B48E3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/jqDSNBHmPbPGayjtXrm9iciccSKbfg6g8oMgXc147jib4HjoUK1RINorZYfBuiaQBibqJIrQRVG77PKGS0dW5PVAAicw/132","comment_is_top":false,"comment_ctime":1568187675,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5863154971","product_id":100017301,"comment_content":"除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？<br><br>回答：队列作用是有限资源池在短时间内面对外界大量请求的一个过渡处理，如线程池处理请求，数据库连接池处理请求，秒杀活动，各种消息队列如Kafka等","like_count":1},{"had_liked":false,"id":114581,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1563345371,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5858312667","product_id":100017301,"comment_content":"关于循环队列有一个空间无法使用且不使用flag的解决方法，我写了段code，验证下来暂无问题，请老师和大家拍砖。<br>import org.junit.Assert;<br><br>public class LoopQueue&lt;T&gt; {<br>    private int n;<br>    private T[] items;<br>    private int head;<br>    private int tail;<br><br>    public LoopQueue(int capacity) {<br>        this.n=capacity;<br>        items = (T[]) new Object[capacity];<br>        this.tail=0;<br>        this.head=0;<br>    }<br><br>    public boolean enqueue(T data) {<br>        if (n&lt;=0 || data==null) {<br>            return false;<br>        }<br>        &#47;&#47; if head and tail is same, meanwhile, data is not empty, then the queue is full<br>        if (head==tail &amp;&amp; items[(tail+1)%n]!=null) {<br>            return false;<br>        }<br>        items[tail]=data;<br>        tail=(tail+1)%n;<br><br>        return true;<br>    }<br><br>    public T dequeue() {<br>        if (n&lt;=0) {<br>            return null;<br>        }<br>        &#47;&#47; if head and tail is same, meanwhile, data is empty, then the queue is empty<br>        if (head==tail &amp;&amp; items[head]==null) {<br>            return null;<br>        }<br>        T data = items[head];<br>        head=(head+1)%n;<br>        return data;<br>    }<br><br>    public static void main(String[] args) {<br>        LoopQueue&lt;Integer&gt; loopQueue = new LoopQueue(7);<br>        &#47;&#47; empty queue dequeue testing<br>        Assert.assertTrue(loopQueue.dequeue()==null);<br>        &#47;&#47; full queue enqueue testing<br>        for (int i=0;i&lt;7;i++) {<br>            loopQueue.enqueue(i);<br>        }<br>        Assert.assertTrue(loopQueue.enqueue(11)==false);<br>        &#47;&#47; dequeue normally<br>        Assert.assertTrue(loopQueue.dequeue()==0);<br>        &#47;&#47; enqueue normally<br>        Assert.assertTrue(loopQueue.enqueue(11));<br>        &#47;&#47; dequeue until queue is empty<br>        int data = -1;<br>        for (int i=0;i&lt;7;i++) {<br>            data = loopQueue.dequeue();<br>        }<br>        Assert.assertTrue(data==11);<br>    }<br>}","like_count":1},{"had_liked":false,"id":105571,"user_name":"杭州吴彦祖","can_delete":false,"product_type":"c1","uid":1486065,"ip_address":"","ucode":"96EE9F08CE927D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIYk2Bq2JiaGicewame4yMI52vz1pqljWHNDktuwTQGOzicRpGKNY3OTYc2UFUQm1my100QcdmFA6Kibw/132","comment_is_top":false,"comment_ctime":1561033465,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5856000761","product_id":100017301,"comment_content":"数据出队后，可以不进行数据搬移，队头和队尾的数据可以可以通过items[head % n] 和 items[tail % n]访问。","like_count":1,"discussions":[{"author":{"id":1480819,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaU7yVx9WnPfnpJBwGCCLWBy9SvkVQRMxmOBxyZTqRYFgPEEYa0pfUHAek6TNEp6SdFRwumUycSeCL7DaM6FotQ/132","nickname":"DMY","note":"","ucode":"22C16ED954FC3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52340,"discussion_content":"这样可能有个问题，很多次操作之后head和tail指针的数值超过int最大值，就会出现问题。还是把头尾指针改为求余的值比较好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574041396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103223,"user_name":"陈悬高","can_delete":false,"product_type":"c1","uid":1065981,"ip_address":"","ucode":"457213A8351202","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/fd/908706cc.jpg","comment_is_top":false,"comment_ctime":1560399499,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855366795","product_id":100017301,"comment_content":"提两点建议：<br><br>1. tail 应该理解为数组中下一个可用槽位（slot）的索引。<br><br>2. 通过维护一个表示队列中元素数量的实例变量 n，我们可以方便地检测到队列已满或为空。","like_count":1},{"had_liked":false,"id":80391,"user_name":"wgg9696","can_delete":false,"product_type":"c1","uid":1402167,"ip_address":"","ucode":"B59488988122F2","user_header":"https://static001.geekbang.org/account/avatar/00/15/65/37/abc7a5bf.jpg","comment_is_top":false,"comment_ctime":1553654729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5848622025","product_id":100017301,"comment_content":"关于最开始的数组搬移的入队时间复杂度，个人想法如下：<br>最好时间复杂度：O(1)：对应直接插入 或者 满了但是无法搬移<br>最坏时间复杂度：O(n):  满了，并且前面只剩一个位置，需要搬移n-1个元素<br>平均时间复杂度：<br>一共有以下几种情况：直接插入（操作次数一次），满了无法插入且无法搬移（操作次数一次），满了可以搬移（对应有1到n-1操作次数），假设这些情况概率都相等<br>平均时间复杂度 = (1 + 1 + 1 +....+n-1)&#47;(1+1+n-1) = O(n) <br>均摊时间复杂度：因为搬移次数和出队有关，无法判定，一定存在多次O(1) + 一次O(n)的情况，所以不适用该复杂度分析方法。<br><br>请老师点评，想法是否正确。","like_count":1},{"had_liked":false,"id":45125,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1543548055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838515351","product_id":100017301,"comment_content":"#include &lt;iostream&gt;<br>#include &lt;string&gt;<br><br>using namespace std;<br>&#47;***<br> * 1 队列 O<br> * 2 循环队列实现 0<br> * ***&#47;<br>template &lt;typename T&gt; class queueUse{<br>    public:<br>        queueUse(T *arr,int len):array(arr),length(len),head(arr),tail(arr){}<br>        T *head;<br>        T *tail;<br>        T *array;<br>        bool cir_enqueue(const T&amp; element);<br>        bool cir_dequeue();<br>        int length;<br>        int counthead = 0;<br>        int count = 0;<br>    private:<br>        queueUse&amp; operator=(const queueUse&amp;);<br>        queueUse(const queueUse&amp;);<br>};<br>&#47;&#47; 循环队列，其实只是处理入队和出队 队满，队空 head和tail的指向问题的问题<br>template&lt;typename T&gt; bool queueUse&lt;T&gt;::cir_enqueue(const T&amp; element){<br>    if(tail+sizeof(T) == head){ &#47;&#47; 始终有一个空的tail指向 判断队满<br>        cout &lt;&lt; &quot;queue is full&quot; &lt;&lt; endl;<br>        return false;<br>    }<br>    *tail = element;<br>    ++count;<br>    tail = array+((count)%length)*sizeof(T); &#47;&#47; tail往后延伸，但是得求余获得位置，一般求余后得到的是一个循环<br>    return true;<br>}<br><br>template&lt;typename T&gt; bool queueUse&lt;T&gt;::cir_dequeue(){<br>    if(head == tail){<br>        cout &lt;&lt; &quot;queue is empty&quot; &lt;&lt; endl;<br>        return false;<br>    }<br>    cout &lt;&lt; *head &lt;&lt; endl;<br>    *head = NULL;<br>    ++counthead;<br>    ++head;<br>    if(counthead == length){ &#47;&#47; 因为head一直都是按顺序指向下一个，所以一直都是结束后从0开始出队列<br>        head = array;<br>        counthead = 0;<br>    }<br>    return true;<br>}<br>","like_count":1},{"had_liked":false,"id":40981,"user_name":"L","can_delete":false,"product_type":"c1","uid":1237556,"ip_address":"","ucode":"0BDC32D02DB267","user_header":"https://static001.geekbang.org/account/avatar/00/12/e2/34/0c2c1200.jpg","comment_is_top":false,"comment_ctime":1542708075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5837675371","product_id":100017301,"comment_content":"如何能想到是根据取模来判断队列空或队列满啊。。太巧妙了吧。<br>还有就是python或者go用数组实现队列的话，都得一个init方法，目的是使用一个初始值填充整个数组，不然入列出列时直接取下标会报错。  -- 可是这样相当于队列没数据底层数组就装满了，有点难以接受…","like_count":1},{"had_liked":false,"id":39502,"user_name":"sunddenly","can_delete":false,"product_type":"c1","uid":1274149,"ip_address":"","ucode":"C635552E2E97E6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/KqZeIjNOVQJnsIFkDBWl5zRxcD1DCfVL6h3R5tw3EUcQUIoUmSxxjt9JK1tZmQ0JcNtmFXVZNW6OADycDGxmag/132","comment_is_top":false,"comment_ctime":1542291661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5837258957","product_id":100017301,"comment_content":"请教一下，链式队列不能用cas实现无锁队列么","like_count":1},{"had_liked":false,"id":33687,"user_name":"coulson","can_delete":false,"product_type":"c1","uid":1125035,"ip_address":"","ucode":"ADBC6AEED866FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/ab/6b2475e9.jpg","comment_is_top":false,"comment_ctime":1539853174,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5834820470","product_id":100017301,"comment_content":"这行代码不是很理解：tail = (tail + 1) % n；<br>我换成 if (tail == n - 1) tail = 0;else tail++;似乎也可以。<br>不知道对不对？","like_count":1,"discussions":[{"author":{"id":1257099,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2e/8b/ea0a1585.jpg","nickname":"Joker","note":"","ucode":"9662D56F5EA546","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9543,"discussion_content":"head和tail都是随着入队出队不断移动的，有可能满队的时候，tail 在3，head在4，不知道我这么说你能不能理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568184660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32488,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1539588645,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834555941","product_id":100017301,"comment_content":"看完感觉眼界开阔了很多，队列的应用还是蛮多的。<br>那个复杂度分析的感觉不好分析啊<br>在tail 没有到达尾部的时候，入队时间是O(1)，后面如果出队数目不多的话，感觉会频繁触发数据搬移，时间复杂度怎么算？","like_count":1},{"had_liked":false,"id":32271,"user_name":"AAS","can_delete":false,"product_type":"c1","uid":1009116,"ip_address":"","ucode":"E76555887A6F57","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/dc/f298552a.jpg","comment_is_top":false,"comment_ctime":1539508571,"is_pvip":false,"replies":[{"id":"11744","content":"是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528114,"ip_address":"","comment_id":32271,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834475867","product_id":100017301,"comment_content":"老师，我不太理解为什么tail指针要指向队列最后一个元素位置+1的位置，而不是直接指向最后一个元素的位置。是为了判断条件写得更容易理解而牺牲空间？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426709,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32197,"user_name":"芋头","can_delete":false,"product_type":"c1","uid":1262215,"ip_address":"","ucode":"7980B54AA2EFB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/87/69158080.jpg","comment_is_top":false,"comment_ctime":1539482014,"is_pvip":false,"replies":[{"id":"11750","content":"你说的没错 这样就无法区分队空和队满了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528506,"ip_address":"","comment_id":32197,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834449310","product_id":100017301,"comment_content":"老师好，我有一个小问题想不通，为什么循环队列最后要浪费一个存储空间，如果判定head和tail相等也可以判定队满，是不是因为这样做的话就没法知道在head和tail相等的时候队列是空还是满？请老师帮忙解答一下","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426677,"discussion_content":"你说的没错 这样就无法区分队空和队满了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31969,"user_name":"喵吉豆豆","can_delete":false,"product_type":"c1","uid":1144651,"ip_address":"","ucode":"1F3322FF5EDF58","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/4b/ede8aa13.jpg","comment_is_top":false,"comment_ctime":1539345388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834312684","product_id":100017301,"comment_content":"解了好多循环队列的bug，都不是老师这种标准型，每次都得在草稿纸上画好久，真希望写出那些代码的人都来看看老师的课，不要再自创错漏百出的循环队列了。","like_count":1},{"had_liked":false,"id":31721,"user_name":"SunshlnW","can_delete":false,"product_type":"c1","uid":1211252,"ip_address":"","ucode":"7B82BBC5F30633","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg","comment_is_top":false,"comment_ctime":1539270279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834237575","product_id":100017301,"comment_content":"关于并发队列的无界非阻塞队列，http:&#47;&#47;www.importnew.com&#47;25668.html","like_count":1},{"had_liked":false,"id":31469,"user_name":"后端进阶","can_delete":false,"product_type":"c1","uid":1125656,"ip_address":"","ucode":"480F48F5378307","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/18/918eaecf.jpg","comment_is_top":false,"comment_ctime":1539193942,"is_pvip":false,"replies":[{"id":"11426","content":"出队不怎么对 有个bug","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539269867,"ip_address":"","comment_id":31469,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5834161238","product_id":100017301,"comment_content":"一个基于链表的链式队列：<br>public class LinkedQueue {<br>    private Node head = null;<br>    private Node tail = null;<br>    private static class Node {<br>        int value;<br>        Node next;<br>        public Node(int value) {<br>            this.value = value;<br>            this.next = null;<br>        }<br>    }<br><br>    public boolean enqueue(int value) {<br>        Node newNode = new Node(value);<br>        if (head == null) {<br>            head = newNode;<br>            tail = newNode;<br>        } else {<br>            tail.next = newNode;<br>            tail = newNode;<br>        }<br>        return true;<br>    }<br><br>    public int dequeue() {<br>        if (head == null) {<br>            return -1;<br>        }<br>        Node node = head.next;<br>        int value = node.value;<br>        head = node;<br>        return value;<br>    }<br>}<br>","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426356,"discussion_content":"出队不怎么对 有个bug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539269867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1834181,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/fc/c5/ff8b770e.jpg","nickname":"BugBean","note":"","ucode":"B51232281AD9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264327,"discussion_content":"活抓蔡徐坤哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589298198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31450,"user_name":"头晕的小骚年","can_delete":false,"product_type":"c1","uid":1234200,"ip_address":"","ucode":"EDA4B89BAA33F1","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/18/7f3b1af2.jpg","comment_is_top":false,"comment_ctime":1539183343,"is_pvip":false,"replies":[{"id":"11430","content":"留言区有同学提出了解决方案 你可以看下","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539269948,"ip_address":"","comment_id":31450,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5834150639","product_id":100017301,"comment_content":"自己尝试了一下不让循环队列有空的存储空间，结果发现很难实现。难道循环队列注定要有一个空的存储空间吗？有没有办法不让循环队列有一个空的存储空间。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426347,"discussion_content":"留言区有同学提出了解决方案 你可以看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539269948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48751,"discussion_content":"使用一个 size 变量，计算并记录当前循环队列已存储元素个数，这就可以区别队列满和空的状态。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573522980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31406,"user_name":"lpccwin","can_delete":false,"product_type":"c1","uid":1107596,"ip_address":"","ucode":"745F3875550C13","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/8c/53e683bd.jpg","comment_is_top":false,"comment_ctime":1539173635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834140931","product_id":100017301,"comment_content":"我觉得是每种都是1&#47;n，然后每种的操作分别是1、2...n，然后算法是1&#47;n *(1+2+...+n) 加权平均算法得到结果O(n)","like_count":1},{"had_liked":false,"id":31397,"user_name":"钢","can_delete":false,"product_type":"c1","uid":1106184,"ip_address":"","ucode":"A49848BF63A579","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/08/3dc76043.jpg","comment_is_top":false,"comment_ctime":1539172015,"is_pvip":false,"replies":[{"id":"11309","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539222392,"ip_address":"","comment_id":31397,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5834139311","product_id":100017301,"comment_content":"redis的消息队列以及redis的管道技术都用到队列","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426321,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31272,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539140867,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834108163","product_id":100017301,"comment_content":"内存池","like_count":1},{"had_liked":false,"id":31267,"user_name":"飞羽","can_delete":false,"product_type":"c1","uid":1241451,"ip_address":"","ucode":"6779BCE78AA636","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/6b/c95dab3c.jpg","comment_is_top":false,"comment_ctime":1539140233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834107529","product_id":100017301,"comment_content":"课后思考<br>1. 作为一个前端开发，首先能想到的比较典型的场景就是事件队列、WebScoket连接池、动画队列这三个。<br>2. 暂时没啥思路，等大神的回答","like_count":1},{"had_liked":false,"id":31219,"user_name":"花见笑","can_delete":false,"product_type":"c1","uid":1219485,"ip_address":"","ucode":"8A5122BC11E695","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/9d/d487c368.jpg","comment_is_top":false,"comment_ctime":1539133346,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834100642","product_id":100017301,"comment_content":"排队抢购应该可以用队列这种模型来处理，被抢购商品数量固定，刚好和数组队列长度是固定的特性暗合，抢购需要快速响应而数组队列的特性之一就是队有空余时快速响应，没有空余时直接拒绝请求因为商品被抢购完了。","like_count":1},{"had_liked":false,"id":31150,"user_name":"favorlm","can_delete":false,"product_type":"c1","uid":1120997,"ip_address":"","ucode":"CFD52127AA6E1D","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","comment_is_top":false,"comment_ctime":1539127105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5834094401","product_id":100017301,"comment_content":"恍然大悟，再看一遍。","like_count":1},{"had_liked":false,"id":360228,"user_name":"码狐","can_delete":false,"product_type":"c1","uid":1234879,"ip_address":"新加坡","ucode":"A4666D3AF30D6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d7/bf/9d8984b7.jpg","comment_is_top":false,"comment_ctime":1666322232,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1666322232","product_id":100017301,"comment_content":"1. 操作系统 cpu 获取 task 执行也是使用的队列<br>2. 并发问题的核心在于资源的竞争，完全无所的队列除非是绑定 task 到单个固定的 cpu 这样所有的操作确实无需加锁也能保证数据安全。并发场景还是要按照业务需求确定是使用自旋锁、读写锁还是其他。","like_count":0},{"had_liked":false,"id":359272,"user_name":"tingting","can_delete":false,"product_type":"c1","uid":2035702,"ip_address":"新加坡","ucode":"61E6B0C4EC59C5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0f/f6/609ded9f.jpg","comment_is_top":false,"comment_ctime":1665388566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665388566","product_id":100017301,"comment_content":"go语言中channel的底层实现用到了循环队列(存储数据)还有等待队列(receiver &amp; sender goroutine排队), 不过底层数据结构没有实现无锁并发，而是加了一把大锁。 ","like_count":0},{"had_liked":false,"id":358268,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664158055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664158055","product_id":100017301,"comment_content":"总结：<br>1. 队列的特性：先进先出<br>2. 队列的组成<br>3. 队列的使用：线程池<br>思考：<br>1. 消息队列<br>2. cas","like_count":0},{"had_liked":false,"id":357876,"user_name":"微尘","can_delete":false,"product_type":"c1","uid":1667439,"ip_address":"北京","ucode":"F9CB2CEE9F19B9","user_header":"https://static001.geekbang.org/account/avatar/00/19/71/6f/07e1452a.jpg","comment_is_top":false,"comment_ctime":1663727453,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1663727453","product_id":100017301,"comment_content":"环形队列(先改变值，后操作数组)<br>队列(后改变值，先操作数组)<br>(tail+1)%n=head","like_count":0},{"had_liked":false,"id":357344,"user_name":"🐻","can_delete":false,"product_type":"c1","uid":1043072,"ip_address":"北京","ucode":"534EDAD496A0E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/80/8759e4c1.jpg","comment_is_top":false,"comment_ctime":1663166088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663166088","product_id":100017301,"comment_content":"Linux Server端处理TCP 连接时，有两个队列。全连接队列和半连接队列。<br><br>Server端收到 syn 包后，将相关信息放入半连接队列，并返回ack+ syn。<br><br>收到客户端的ack 之后，再讲信息从半连接队列拿出，放入全连接队列中。<br><br><br>cas 无锁队列。cas的含义是 compare and swap。每次更新tail指针的时候，先将指针指向的值和之前存储的快照值比较，如果值没有变，也更新指针。如果值变了，则从新获取快照，重新判断。","like_count":0},{"had_liked":false,"id":355641,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1661583500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661583500","product_id":100017301,"comment_content":"队列，排列，先进先出<br>- enqueue 入站<br>- dequeue 出站","like_count":0},{"had_liked":false,"id":352031,"user_name":"罗杰.菲の樂","can_delete":false,"product_type":"c1","uid":2016408,"ip_address":"","ucode":"63590706846EEA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","comment_is_top":false,"comment_ctime":1658337543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658337543","product_id":100017301,"comment_content":"我认为文中的Circular Queue浪费了一个存储空间，并不理想，这里给出改进以后的实现。<br>```<br>class MyCircularQueue {<br><br>    private int[] items; <br>    private int n = 0;<br>    private int size = 0;<br><br>    private int head = 0;<br>    private int tail = -1;<br><br>    public MyCircularQueue(int k) {<br>        items = new int[k];<br>        n = k;<br>    }<br><br>    public boolean enQueue(int value) {<br>        if (isFull()) {<br>            return false;<br>        }<br><br>        tail = (tail + 1) % n;<br>        items[tail] = value;<br>        size++;<br>        return true;<br>    }<br><br>    public boolean deQueue() {<br>        if (isEmpty()) {<br>            return false;<br>        }<br><br>        head = (head + 1) % n;<br>        size--;<br>        return true;<br>    }<br><br>    public int Front() {<br>        if (isEmpty()) {<br>            return -1;<br>        }<br><br>        return items[head];<br>    }<br>    <br>    public int Rear() {<br>        if (isEmpty()) {<br>            return -1;<br>        }<br><br>        return items[tail];<br>    }<br> <br>    public boolean isEmpty() {<br>        return size == 0;<br>    }<br><br>    public boolean isFull() {<br>        return size == n;<br>    }<br>}<br>```","like_count":0},{"had_liked":false,"id":347899,"user_name":"Molyt","can_delete":false,"product_type":"c1","uid":2283490,"ip_address":"","ucode":"9CCF7A18B2C547","user_header":"https://static001.geekbang.org/account/avatar/00/22/d7/e2/5e5cc8f3.jpg","comment_is_top":false,"comment_ctime":1654566908,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654566908","product_id":100017301,"comment_content":"老师的GitHub是多少呀（新人）","like_count":0},{"had_liked":false,"id":347456,"user_name":"达叔灬","can_delete":false,"product_type":"c1","uid":2404887,"ip_address":"","ucode":"5CCBAF13548F02","user_header":"https://static001.geekbang.org/account/avatar/00/24/b2/17/3161b49c.jpg","comment_is_top":false,"comment_ctime":1654053118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654053118","product_id":100017301,"comment_content":"重学队列 发现 redis 的 repl_backlog_buffer 环形缓冲区 也是一个循环队列","like_count":0},{"had_liked":false,"id":347394,"user_name":"Vivion","can_delete":false,"product_type":"c1","uid":1242310,"ip_address":"","ucode":"C62C4F46B8EB4D","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/c6/aed9e44a.jpg","comment_is_top":false,"comment_ctime":1653988261,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653988261","product_id":100017301,"comment_content":"CPU - 不同线程 - netty 中请求线程池与待处理请求队列<br>CPU - 不同进程 - MQ<br>网络、文件 I&#47;O - 读取缓冲区","like_count":0},{"had_liked":false,"id":346582,"user_name":"Link","can_delete":false,"product_type":"c1","uid":2017303,"ip_address":"","ucode":"004613427C7CAA","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c8/17/05caa195.jpg","comment_is_top":false,"comment_ctime":1653262848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653262848","product_id":100017301,"comment_content":"实现一遍受益匪浅","like_count":0},{"had_liked":false,"id":344045,"user_name":"徐若愚","can_delete":false,"product_type":"c1","uid":2847807,"ip_address":"","ucode":"205631D30BD2E4","user_header":"","comment_is_top":false,"comment_ctime":1651206489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651206489","product_id":100017301,"comment_content":"public class LockFreeQueue {<br>    &#47;&#47; LockFreeQueue<br>    private static final Integer EMPTY = null;<br>    private final AtomicReferenceArray array;<br>    private AtomicInteger head;<br>    private AtomicInteger tail;<br><br>    public LockFreeQueue(int cap) {<br>        array = new AtomicReferenceArray (cap);<br>        head = new AtomicInteger(0);<br>        tail = new AtomicInteger(0);<br>    }<br><br>    public boolean enqueue(int data) {<br>        int index = (tail.get() + 1) % array.length();<br>        if (index == head.get() % array.length()) return false;<br><br>        while (!array.compareAndSet(index, EMPTY, data)) {<br>            return enqueue(data);<br>        }<br>        tail.incrementAndGet();<br>        return true;<br>    }<br><br>    public Integer dequeue() {<br>        if (head.get() == tail.get()) return null;<br>        int index = (tail.get() + 1) % array.length();<br>        Integer element = (Integer) array.get(index);<br>        if (element == null) return dequeue(); &#47;&#47; 其他线程出队<br>        while (!array.compareAndSet(index, element, EMPTY)) {<br>            return dequeue();<br>        }<br>        head.incrementAndGet();<br>        return element;<br>    }<br><br>    public void print() {<br>        StringBuffer sb = new StringBuffer();<br>        for (int i = 0; i &lt; array.length(); i++) {<br>            if (i == head.get() || array.get(i) == null) {<br>                continue;<br>            }<br>            sb.append(array.get(i)).append(&quot;,&quot;);<br>        }<br>        sb.deleteCharAt(sb.length() - 1);<br>        System.out.println(sb.toString());<br>    }<br>}","like_count":0},{"had_liked":false,"id":344044,"user_name":"徐若愚","can_delete":false,"product_type":"c1","uid":2847807,"ip_address":"","ucode":"205631D30BD2E4","user_header":"","comment_is_top":false,"comment_ctime":1651206482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651206482","product_id":100017301,"comment_content":"大家这么积极，我也补一个LockFreeQueue吧","like_count":0},{"had_liked":false,"id":342416,"user_name":"Siri","can_delete":false,"product_type":"c1","uid":1074834,"ip_address":"","ucode":"40CCD539F19D4C","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/92/f1f83d8b.jpg","comment_is_top":false,"comment_ctime":1650253076,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650253076","product_id":100017301,"comment_content":"go语言中 channel内部的ring buffer就是通过环形队列来实现的","like_count":0},{"had_liked":false,"id":340454,"user_name":"Geek_b7eb88","can_delete":false,"product_type":"c1","uid":1573715,"ip_address":"","ucode":"0EB46381D9B1CB","user_header":"","comment_is_top":false,"comment_ctime":1648820956,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648820956","product_id":100017301,"comment_content":"iOS中的RunLoop事件处理，Flutter中的非阻塞调用，应该都是用的队列这种结构吧。作为一个移动端只能说点这些了。[Facepalm]","like_count":0},{"had_liked":false,"id":340244,"user_name":"R","can_delete":false,"product_type":"c1","uid":1248638,"ip_address":"","ucode":"165F104B71EAF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/7e/2f709bdf.jpg","comment_is_top":false,"comment_ctime":1648694321,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648694321","product_id":100017301,"comment_content":"用链表实现队列，为什么不选择在队头插入，队头删除呢？感觉会更直观些","like_count":0},{"had_liked":false,"id":337169,"user_name":"201202077","can_delete":false,"product_type":"c1","uid":2881261,"ip_address":"","ucode":"2FB173EB6A9A2E","user_header":"","comment_is_top":false,"comment_ctime":1646658878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646658878","product_id":100017301,"comment_content":"队列的线程安全不是很清楚需要后面再看看","like_count":0},{"had_liked":false,"id":336236,"user_name":"其实特仑苏就是一瓶牛奶","can_delete":false,"product_type":"c1","uid":2333829,"ip_address":"","ucode":"B2F6E8E96BA62A","user_header":"https://static001.geekbang.org/account/avatar/00/23/9c/85/0e9f445a.jpg","comment_is_top":false,"comment_ctime":1646024205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646024205","product_id":100017301,"comment_content":"顺序队列：<br>入队操作，当队列为空队列时，将队头指针以及队尾指针同时指向数组首地址，当数组没有额外的存储空间时，拒绝数据进入队列中，此时，入队操作的时间复杂度为O(1)；<br>出队操作，当队列为空队列时，抛出异常，当队列非空时，只需要将队头指针自加 1 ，此时，出队的时间复杂度仍为O(1)","like_count":0},{"had_liked":false,"id":336232,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1646018730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646018730","product_id":100017301,"comment_content":"队列的特点是： 入口和出口在两端， 有入队和出队两种操作， 先入队者先出。<br>队列根据实现方式可以分为： <br>顺序队列   (双指针 + 数据搬移)<br>链式队列 （双指针 + dummyHead）<br><br>循环队列： 可以解决顺序队列的数据搬移问题, 用 % size 来进行入队和出队的位置更新，可以留一个位置来判断队列是否已满 或者 记录队列长度来判断；<br><br>高级队列结构有：<br><br>阻塞队列：实现了 “生产者-消费者” 模型<br>并发队列：通过加锁或者或者循环队列 + CAS 原子操作实现","like_count":0},{"had_liked":false,"id":335014,"user_name":"何以见得","can_delete":false,"product_type":"c1","uid":1237254,"ip_address":"","ucode":"E47FF878E707B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/06/c64246ee.jpg","comment_is_top":false,"comment_ctime":1645256464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645256464","product_id":100017301,"comment_content":"循环牺牲最后一个空间来实现判断队满，在实际开发中我们就完全不要这个空间了吗？或者可以用来做一些什么其他的再利用吗？","like_count":0},{"had_liked":false,"id":334539,"user_name":"uwoerla","can_delete":false,"product_type":"c1","uid":1111425,"ip_address":"","ucode":"A457D4F6A346FB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/81/26bc1bfb.jpg","comment_is_top":false,"comment_ctime":1644994174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644994174","product_id":100017301,"comment_content":"解决文章里队列满了，但是 tail 指向的是 null 的问题<br>&#47;**<br> * 基于数组实现的环形队列<br> *&#47;<br>public class CircularQueueBasedArray {<br>  &#47;&#47; 数组：items，数组大小：n<br>  private String[] items;<br>  private int n = 0;<br>  &#47;&#47; head表示队首下标，tail表示队尾下标<br>  private int head = 0;<br>  private int tail = -1;<br><br>  &#47;&#47; 申请一个大小为capacity的数组<br>  public CircularQueueBasedArray(int capacity) {<br>    items = new String[capacity];<br>    n = capacity;<br>  }<br><br>  &#47;&#47; 入队<br>  public boolean enqueue(String item) {<br>    &#47;&#47; 队列满了<br>    if (tail&gt;-1 &amp;&amp; (tail + 1) % n == head) return false;<br>    tail = (++tail) % n;<br>    items[tail] = item;<br>    return true;<br>  }<br><br>  &#47;&#47; 出队<br>  public String dequeue() {<br>    String ret = items[head];<br>    if(ret!=null){<br>      &#47;&#47; 出队后设置原队首下标对应的值为null<br>      items[head] = null;<br>      if(head == tail){<br>        &#47;&#47; 队列里只有一个元素，出队后队列里就没有元素了<br>        head = 0;<br>        tail = -1;<br>      }else {<br>        &#47;&#47; 移动队首下标<br>        head = (head + 1) % n;<br>      }<br>    }<br>    return ret;<br>  }<br>}","like_count":0},{"had_liked":false,"id":332125,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1643030487,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1643030487","product_id":100017301,"comment_content":"其实本质上还是tail和head两个指针提供的信息不够。我有两个思路<br>第一个是空出一个位置按照老师的操作<br>另一个就是多用一个信息变量size表示当前队列的长度，拿它和队列的大小来进行比较","like_count":0},{"had_liked":false,"id":329114,"user_name":"sanyu.h","can_delete":false,"product_type":"c1","uid":1281834,"ip_address":"","ucode":"E4851BF6E2FB17","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yjPribEvEjfucxIXMz37icztGulgcuBAEQllOWKypiamntLLxkRIb20L7CQ2MVJxSt2KpyXW4dLpgL9YjbkDe9pAQ/132","comment_is_top":false,"comment_ctime":1641128890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641128890","product_id":100017301,"comment_content":"如果队列的长度可以被表示长度的变量类型的溢出值整除，就不需要浪费这个空间了。<br>需要如下修改：<br>1. int n 改成 “unsigned int n；”，这是队列的大小，用无符号类型；且n的值必须可以被unsigned int类型的溢出值（32位是4294967296，64位是18446744073709551616）整除；<br>2. tail更新不再是tail = (tail + 1) % n， 而是tal = tail + 1；<br>3. bool isFull {return (tail - head) == n; }<br>4. bool isEmpty { return tail == head; }","like_count":0},{"had_liked":false,"id":328313,"user_name":"Geek_db13bf","can_delete":false,"product_type":"c1","uid":2853527,"ip_address":"","ucode":"22D8DA47B1E190","user_header":"","comment_is_top":false,"comment_ctime":1640663278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640663278","product_id":100017301,"comment_content":"循环队列中提到的浪费数组的一个存储空间意思是如果我申请的数组大小是8，只能存储7个数据吗？","like_count":0},{"had_liked":false,"id":327300,"user_name":"Geek_db13bf","can_delete":false,"product_type":"c1","uid":2853527,"ip_address":"","ucode":"22D8DA47B1E190","user_header":"","comment_is_top":false,"comment_ctime":1640054267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640054267","product_id":100017301,"comment_content":"大佬，这个画图工具用的是啥","like_count":0},{"had_liked":false,"id":323876,"user_name":"Tina","can_delete":false,"product_type":"c1","uid":2851354,"ip_address":"","ucode":"8D6D9F6E3D0A99","user_header":"https://static001.geekbang.org/account/avatar/00/2b/82/1a/30676c2e.jpg","comment_is_top":false,"comment_ctime":1638191112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638191112","product_id":100017301,"comment_content":"队列也是一种操作受限的线性表，先进先出，后进后出，就像生活中的排队一样。<br>队列的应用非常广泛，尤其是一些具有额外特性的队列：循环队列，阻塞队列，并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。<br>实现：<br>要实现队列，可以使用数组和链表，分别叫做顺序队列和链式队列。<br>用数组实现：主要是入队和出队两个操作，要注意判断队满和队空的条件。当入队加到数组末尾时，要判对队头是否在0位置，否则要进行数据搬移，整体往前挪。<br>循环队列：顾名思义，就是围成一个圈，也是有两个指针，头指针指向头节点，尾指针指向尾节点后面一个，所以队列满时有一个存储空间是空着的，为了方便判断队满和对空，这时要额外注意判断对空是head==tail，而队满是(tail+1)%n == head.<br>链式队列：用链表来实现，也需要两个指针。<br><br>阻塞队列：就是“生产者-消费者模型”的原型，当队列为空时想要取数据就会阻塞，直到队列中有数据；队列满时想要添加数据也会阻塞，当队列又有额外的空间时才可以继续添加。<br><br>并发队列：多线程安全的队列。最直接的方式就是在入队和出队的方法上加锁，但是这种方式锁粒度大，并发度低。同一时刻仅允许一个存或者取操作。基于数组的循环队列，可以使用CAS原子操作，可以实现高效的并发队列。所以，循环队列比链式队列应用更广泛。<br><br>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？<br>有两种方式，一种是非阻塞方式，线程池满时，直接拒绝请求；另一种是阻塞的方式，将请求排队，等到有空闲的线程时，再处理排队的请求。<br>对于基于链表实现的排队请求，可以实现支持无限排队的无界队列，但也会导致排队的请求过多，响应时间过长，对于响应时间比较敏感的系统不合适。<br>基于数组实现的有界队列，队列的大小有限，线程池中排队的请求超过队列大小时，便会被拒绝，适合对响应时间比较敏感的系统。但是，队列的大小要设置一个合理值，太大就响应时间过长，太短了就无法充分利用系统资源，造成浪费。<br><br>除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？  还有分布式应用中的消息队列。<br>今天讲到并发队列，关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢？使用CAS实现无锁并发序列。<br>","like_count":0},{"had_liked":false,"id":321167,"user_name":"Wilson","can_delete":false,"product_type":"c1","uid":1007140,"ip_address":"","ucode":"3ADBE962C67B8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/24/040855d3.jpg","comment_is_top":false,"comment_ctime":1636698398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636698398","product_id":100017301,"comment_content":"&#47;**<br> * Kotlin数组实现队列<br> * @property size Int<br> * @property items Array&lt;String&gt;<br> * @property count Int<br> * @property head Int<br> * @constructor<br> *&#47;<br>class ArrayQueue(var size: Int) {<br>    var items: Array&lt;String&gt; = Array&lt;String&gt;(size, { &quot;&quot; })<br>    var count: Int = 0<br>    var head: Int = 0<br><br>    fun enqueue(item: String): Boolean {<br>        if (count == size) {<br>            if (head == 0) return false<br>&#47;&#47;            数据搬移<br>            for (i in head..count) {<br>                items[i - head] = items[i]<br>            }<br>            count -= head<br>            head = 0<br><br>        }<br>        items[count] = item<br>        ++count<br>        return true<br>    }<br><br>    fun dequeue(): String? {<br>        if (head == count) return null<br>        val value = items[head]<br>        ++head<br>        return value<br>    }<br>}","like_count":0},{"had_liked":false,"id":316139,"user_name":"Qiubh","can_delete":false,"product_type":"c1","uid":1072658,"ip_address":"","ucode":"3BC33EC44F2FDE","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/12/c0c4d6f2.jpg","comment_is_top":false,"comment_ctime":1634177875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634177875","product_id":100017301,"comment_content":"public class CircularQueue {<br><br>\tprivate String[] items;<br><br>\tprivate int n = 0;<br><br>\tprivate int head = 0;<br><br>\tprivate int tail = 0;<br><br>\tprivate int size = 0;<br><br>\tpublic CircularQueue(int capacity) {<br>\t\titems = new String[capacity];<br>\t\tn = capacity;<br>\t}<br><br>\t&#47;** 入队 *&#47;<br>\tpublic boolean enqueue(String item) {<br>\t\t&#47;**如果队列已满*&#47;<br>\t\tif (size == n) {<br>\t\t\treturn false;<br>\t\t}<br>\t\titems[tail] = item;<br>\t\ttail = (tail + 1) % n;<br>\t\tsize++;<br>\t\treturn true;<br>\t}<br><br>\t&#47;** 出队 *&#47;<br>\tpublic String dequeue() {<br>\t\tif (size == 0) {<br>\t\t\treturn null;<br>\t\t}<br>\t\tString ret = items[head];<br>\t\thead = (head + 1) % n;<br>\t\tsize--;<br>\t\treturn ret;<br>\t}<br><br><br>}<br>这样不浪费一个空间，不行吗？","like_count":0},{"had_liked":false,"id":314745,"user_name":"Geek_c311eb","can_delete":false,"product_type":"c1","uid":1906736,"ip_address":"","ucode":"EF4D7C0A9BB89E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/gq1EeEEFPQibTRnCaZKZSEyLmfRpMianfxr5Jib0HW24GcDnE24xEAsiby9N0jPemrSkCulm453I6qiabloqjoOGc7Q/132","comment_is_top":false,"comment_ctime":1633397202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633397202","product_id":100017301,"comment_content":"顺序队列：<br>package com.queue;<br><br>&#47;&#47;用数组实现队列<br>public class ArrayQueue {<br><br>\tprivate String[] items;<br>\tprivate int n = 0;<br><br>\tprivate int head = 0;<br>\tprivate int tail = 0;<br><br>\tpublic ArrayQueue(int capacity) {<br>\t\titems = new String[capacity];<br>\t\tn = capacity;<br>\t}<br><br>\t&#47;*<br>\t * 入队<br>\t *&#47;<br>&#47;&#47;\tpublic boolean enqueue(String item) {<br>&#47;&#47;\t\tif(tail == n) return false;<br>&#47;&#47;\t\titems[tail] = item;<br>&#47;&#47;\t\t++tail;<br>&#47;&#47;\t\treturn true;<br>&#47;&#47;\t}<br>\tpublic boolean enqueue(String item) {<br>\t\tif (tail == n) {<br>\t\t\t&#47;&#47; tail==n&amp;&amp;head==0 表示队列已满<br>\t\t\tif (head == 0)<br>\t\t\t\treturn false;<br>\t\t\t&#47;&#47; 数据搬移<br>\t\t\tfor (int i = head; i &lt; tail; i++) {<br>\t\t\t\titems[i - head] = items[i];<br>\t\t\t}<br>\t\t\t&#47;&#47; 搬移完后重新更新head和tail<br>\t\t\ttail -= head;<br>\t\t\thead = 0;<br>\t\t}<br>\t\titems[tail] = item;<br>\t\t++tail;<br>\t\treturn true;<br>\t}<br><br>\t&#47;*<br>\t * 出队<br>\t *&#47;<br>\tpublic String deQueue() {<br>\t\tif (head == tail)<br>\t\t\treturn null;<br>\t\tString ret = items[head];<br>\t\t++head;<br>\t\treturn ret;<br>\t}<br>}<br>循环队列：<br>package com.queue;<br>&#47;*<br> * 循环队列<br> *&#47;<br>public class CircularQueue {<br>\t<br>\tprivate String items[];<br>\tprivate int n;<br>\t<br>\tprivate int head = 0;<br>\tprivate int tail = 0;<br>\t<br>\t&#47;&#47;申请一个大小为n的数组空间<br>\tpublic CircularQueue(int capacity) {<br>\t\titems = new String[capacity];<br>\t\tn = capacity;<br>\t}<br>\t&#47;*<br>\t * 入队<br>\t *&#47;<br>\tpublic boolean enqueue(String item) {<br>\t\tif((tail + 1) %n == head) return false;<br>\t\titems[tail + 1] = item;<br>\t\t++tail;<br>\t\treturn true;<br>\t}<br>\t&#47;*<br>\t * 出队<br>\t *&#47;<br>\tpublic String dequeue() {<br>\t\t&#47;&#47;队空<br>\t\tif(head == tail) return null;<br>\t\tString ret = items[head];<br>\t\t++head;<br>\t\treturn ret;<br>\t}<br>}<br><br>","like_count":0},{"had_liked":false,"id":314454,"user_name":"倔强","can_delete":false,"product_type":"c1","uid":2792413,"ip_address":"","ucode":"4C588A1E7C0F7C","user_header":"https://static001.geekbang.org/account/avatar/00/2a/9b/dd/97a690a2.jpg","comment_is_top":false,"comment_ctime":1633077308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633077308","product_id":100017301,"comment_content":"老师，%n的范围是0~n-1吧，就像%2范围是0~1.","like_count":0},{"had_liked":false,"id":314403,"user_name":"Geek1372","can_delete":false,"product_type":"c1","uid":2715312,"ip_address":"","ucode":"53157C4CB29040","user_header":"","comment_is_top":false,"comment_ctime":1632998168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632998168","product_id":100017301,"comment_content":"老师您好，dequeue 时需要将 head 位置数组的引用设为 null，否则数组中的强引用，未释放可能会导致内存泄漏","like_count":0},{"had_liked":false,"id":314258,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1632917260,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632917260","product_id":100017301,"comment_content":"队列也是操作受限的线性表，特征是先进先出。现实中有很多场景符合先进先出的规律，所以队列的应用非常广泛。队列只有简单的出队和入队操作，时间复杂度都是O(1)。<br><br>只要底层数据结构是数组，就会涉及到扩容和数据搬移，所以用数组实现的栈和队列随着数据量的增大都需要进行扩容。","like_count":0},{"had_liked":false,"id":311128,"user_name":"Dale","can_delete":false,"product_type":"c1","uid":1242602,"ip_address":"","ucode":"AD19A33FE5EEDF","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/ea/5f046856.jpg","comment_is_top":false,"comment_ctime":1631081562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631081562","product_id":100017301,"comment_content":"感觉这里的“循环队列”，没有真正形成“环”这个意思，更像只是给一个普通的队列，设置了一个最大长度而已。","like_count":0},{"had_liked":false,"id":310621,"user_name":"灵野","can_delete":false,"product_type":"c1","uid":2748661,"ip_address":"","ucode":"A27475F0F5EB67","user_header":"https://static001.geekbang.org/account/avatar/00/29/f0/f5/2f71e7e9.jpg","comment_is_top":false,"comment_ctime":1630805584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630805584","product_id":100017301,"comment_content":"为啥没队列的推荐题目","like_count":0},{"had_liked":false,"id":309151,"user_name":"🌴林子洛","can_delete":false,"product_type":"c1","uid":2744724,"ip_address":"","ucode":"DE0C88D16AADF8","user_header":"https://static001.geekbang.org/account/avatar/00/29/e1/94/2c5e62d1.jpg","comment_is_top":false,"comment_ctime":1629962078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629962078","product_id":100017301,"comment_content":"思考题有点不懂了呀。。线程池还没了解","like_count":0},{"had_liked":false,"id":309086,"user_name":"托马斯赵四","can_delete":false,"product_type":"c1","uid":2712653,"ip_address":"","ucode":"F9FA980A9F8A1C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/kBKTRyV4wnhV4YN9iaFgKYIJ4451n0zIiazFumcSpCXdEDhdexgc8PQdrDEmy4BCOUgsUlibicEwQlGo6K5Nibv7SEg/132","comment_is_top":false,"comment_ctime":1629939106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629939106","product_id":100017301,"comment_content":"nodejs的事件轮询与kafka的轮询机制也是排队队列的基础上实现的<br>使用链式队列来实现无锁队列？？","like_count":0},{"had_liked":false,"id":308995,"user_name":"15652825355","can_delete":false,"product_type":"c1","uid":2280639,"ip_address":"","ucode":"4186B4AEB101DB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqs5jaG6dMPpYCeZAbiawyMPe4ib1xCiccdbdOeox1OeJqUVbnOul5TVBibFWR8eibRW2R6T4amibeOTVuw/132","comment_is_top":false,"comment_ctime":1629884020,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629884020","product_id":100017301,"comment_content":"iOS中的多线程,并发队列,串行队列,主队列","like_count":0},{"had_liked":false,"id":308113,"user_name":"李叶","can_delete":false,"product_type":"c1","uid":1470449,"ip_address":"","ucode":"41B33FA8526E48","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/f1/35f9f16f.jpg","comment_is_top":false,"comment_ctime":1629418092,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629418092","product_id":100017301,"comment_content":"队列应用于线程池，消息队列，判空判满是关键","like_count":0},{"had_liked":false,"id":307139,"user_name":"while (1)等;","can_delete":false,"product_type":"c1","uid":1061991,"ip_address":"","ucode":"BAEC7258D65B69","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/67/06a7f9be.jpg","comment_is_top":false,"comment_ctime":1628906223,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628906223","product_id":100017301,"comment_content":"“循环队列会浪费一个数组的存储空间。”，队列满时，tail也等于head不可以吗？空的时候tail=head<br>=nil，满的时候tail=head<br>=具体的值","like_count":0},{"had_liked":false,"id":306230,"user_name":"dog_brother","can_delete":false,"product_type":"c1","uid":1619597,"ip_address":"","ucode":"9F64D3C6D815FB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er6OV33jHia3U9LYlZEx2HrpsELeh3KMlqFiaKpSAaaZeBttXRAVvDXUgcufpqJ60bJWGYGNpT7752w/132","comment_is_top":false,"comment_ctime":1628446641,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628446641","product_id":100017301,"comment_content":"分享一个链接，推荐给C++的同学看，关于STL中deque的实现<br>https:&#47;&#47;www.zhihu.com&#47;question&#47;360025286","like_count":0},{"had_liked":false,"id":306176,"user_name":"Geek_26c95d","can_delete":false,"product_type":"c1","uid":1466617,"ip_address":"","ucode":"AA1F4E9548439F","user_header":"https://static001.geekbang.org/account/avatar/00/16/60/f9/0417a5dc.jpg","comment_is_top":false,"comment_ctime":1628418856,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628418856","product_id":100017301,"comment_content":"关于循环队列 判满和判空 是不是通过维护一个变量size（当前队列元素个数）更方便。判满 size=capaticy、判空 size=0。这样循环队列也不会出现有一个位置被浪费的问题了。","like_count":0},{"had_liked":false,"id":304677,"user_name":"弗拉门戈","can_delete":false,"product_type":"c1","uid":1326281,"ip_address":"","ucode":"557C138B0E6F9B","user_header":"https://static001.geekbang.org/account/avatar/00/14/3c/c9/105f93a5.jpg","comment_is_top":false,"comment_ctime":1627546940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627546940","product_id":100017301,"comment_content":"老师，我测试了，第二段代码。<br> items[tail] = item;    <br> ++tail; <br>这两行代码是不是需要换一个位置。在队列没有满的情况。会有一个数据丢失。","like_count":0},{"had_liked":false,"id":301144,"user_name":"红尘","can_delete":false,"product_type":"c1","uid":1445504,"ip_address":"","ucode":"CCCD5736755DF5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/gVfU7icdia3o5ZNaHjaWAdgkSYIpU1rdhIlVYiahYCvRlDZu2K6oPSvVobNjzwZbUaiayQcKjicZ44WjfWJCj5xdlPA/132","comment_is_top":false,"comment_ctime":1625552306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625552306","product_id":100017301,"comment_content":"队列<br>队列与栈相反，队列是先进先出<br>队列的区分<br>1：采用数组实现的队列， 叫做顺序队列<br>2：采用链表实现的队列，叫做链式队列<br>将数据放入队列尾部，叫做入队，将数据从队列头部取出，叫做出队<br>队列和栈一样，都是一种受限的线性表数据结构。<br>除了顺序队列和链式队列以外还分为，循环队列，阻塞队列，并发队列。<br>实现队列会采用两个指针，一个指向对头，一个指向队尾，入队将队尾指针+1，出队也将对头指针+1，这样比较了数组扩容，或者生成新的链表。<br>普通队列（顺序队列，链式队列），入队的话，当还有用于时间的时候，直接插入数组尾部，当数组没有空余时间的时候，就会进行扩容，会触发一次数组的搬移工作。<br>循环队列：采用循环链表实现，也可以采用数组实现，主要是注意的是临界问题，循环数组的队尾下标一直不会存放元素，当队尾下标=对头下标，表示当前循环数组为空，因为队尾下标一直不会存放元素，所以当满足公式 （队尾下标+1）%n = 对头下标，表示就在队尾，就会进行扩容操作，<br>阻塞队列：简单来说就是，当队列没有数据的时候，出队操作会进行阻塞，当队列满了的时候出队操作也会进行阻塞，就和golang里面的管道类似<br>并发队列：因为当同时多个线程进行入队和出队的时候，容易产生并发问题，所以为了解决这个问题，在出队或者入队的时候加上锁，这样的话就形成了一个高效的并发队列。<br>线程池中没有空闲的线程时，有两种处理方式，非阻塞的处理方式，直接拒绝请求，第二种，采用阻塞的处理方式的时候，将任务资源进行排队，新建一个队列进行排队请求，但是也是一个有界的队列，这个时候也有两种情况，第一种，当有界队列没有满的时候，直接放行，第二种情况，当有界队列满了之后，直接拒绝新的任务请求","like_count":0},{"had_liked":false,"id":300352,"user_name":"up","can_delete":false,"product_type":"c1","uid":2667806,"ip_address":"","ucode":"7D1C25BBBEBCDB","user_header":"https://static001.geekbang.org/account/avatar/00/28/b5/1e/0e42696c.jpg","comment_is_top":false,"comment_ctime":1625125618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625125618","product_id":100017301,"comment_content":"golang 里面的channel 相当于阻塞队列，并且是并发安全的。","like_count":0},{"had_liked":false,"id":300076,"user_name":"草履虫","can_delete":false,"product_type":"c1","uid":1955304,"ip_address":"","ucode":"DE0917664B00EA","user_header":"https://static001.geekbang.org/account/avatar/00/1d/d5/e8/ac41cf5c.jpg","comment_is_top":false,"comment_ctime":1624976502,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624976502","product_id":100017301,"comment_content":"请问老师：循环队列判断队空和队满，假如用taill === head &amp;&amp; tail.next !== null 的时候队满；taill ===head &amp;&amp; tail.next === null 的时候队空，是否可以啊，或者有什么破绽？","like_count":0},{"had_liked":false,"id":297369,"user_name":"海崖","can_delete":false,"product_type":"c1","uid":2552745,"ip_address":"","ucode":"9D42E0B0D30A56","user_header":"https://static001.geekbang.org/account/avatar/00/26/f3/a9/bb9d8450.jpg","comment_is_top":false,"comment_ctime":1623488340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623488340","product_id":100017301,"comment_content":"叮~打卡<br>还可以通过队列实现网络消息队列。","like_count":0},{"had_liked":false,"id":296347,"user_name":"小Y","can_delete":false,"product_type":"c1","uid":1739621,"ip_address":"","ucode":"24A43BB71805F8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8b/65/0f1f9a10.jpg","comment_is_top":false,"comment_ctime":1622909479,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1622909479","product_id":100017301,"comment_content":"我想问个有点蠢的问题，( :<br>是不是在我们的设计或者观念中<br>队列就没有扩容的这种操作了？<br>比如想使用无界队列，就一般基于链表实现，如果是基于数组实现的队列，就默认我们是有界的队列了？","like_count":0,"discussions":[{"author":{"id":2573820,"avatar":"","nickname":"Geek_57fcf1","note":"","ucode":"443D98C591CDAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381604,"discussion_content":"即便是数组队列，也能实现动态扩容吧，具体实现难道不是看个人需求吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625141294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1739621,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8b/65/0f1f9a10.jpg","nickname":"小Y","note":"","ucode":"24A43BB71805F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2573820,"avatar":"","nickname":"Geek_57fcf1","note":"","ucode":"443D98C591CDAD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385725,"discussion_content":"也是哈，嘿嘿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627228367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381604,"ip_address":""},"score":385725,"extra":""}]}]},{"had_liked":false,"id":295967,"user_name":"下雨天","can_delete":false,"product_type":"c1","uid":1413399,"ip_address":"","ucode":"FB3851E3A79C3B","user_header":"https://static001.geekbang.org/account/avatar/00/15/91/17/89c3d249.jpg","comment_is_top":false,"comment_ctime":1622685580,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622685580","product_id":100017301,"comment_content":"入队的时候，用tail = (tail+1) % len(数组长度)  是不是更简洁一些","like_count":0},{"had_liked":false,"id":291789,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1940562,"ip_address":"","ucode":"67C86E09BA6E4B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9c/52/dc770378.jpg","comment_is_top":false,"comment_ctime":1620480409,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620480409","product_id":100017301,"comment_content":"老师，我在leetcode上做作业了哦，太开心啦。其实我发现加了size不会影响内存效率，反正我加了，而且我的内存消耗还是比较少的。代码放上，请王老师多指教！<br><br>class MyCircularQueue {<br><br>    private int head;<br>    private int tail;<br>    private int[] data;<br>    private int len;<br>    private int count;<br><br><br>    public MyCircularQueue(int k) {<br>        head = 0;<br>        tail = 0;<br>        len = k;<br>        count = 0;<br>        data = new int[k];   <br><br>    }<br>    <br>    public boolean enQueue(int value) {<br>        if(isFull())    return false;<br>        else{<br>                data[tail] = value;<br>                tail=(tail+1)%len;<br>                count++;<br>                return true;<br>        }<br>        <br>    }<br>    <br>    public boolean deQueue() {<br>        if(isEmpty()) return false;<br>        else{<br>            head=(head+1)%len;<br>            count--;<br>            return true;<br>        }<br>    }<br>    <br>    public int Front() {<br>        if(isEmpty()) return -1;<br>        else{           <br>            return data[head];<br>        }<br>    }<br>    <br>    public int Rear() {<br>        if(isEmpty()) return -1;<br>        else return data[(tail+len-1)%len];<br>        <br>    }<br>    <br>    public boolean isEmpty() {<br><br>        if( count==0)<br>            return true;<br>        else <br>            return false; <br>              <br><br>    }<br>    <br>    public boolean isFull() {<br>        if(count == len)<br>            return true;<br>        else <br>            return false;    <br><br>    }<br>}<br><br>&#47;**<br> * Your MyCircularQueue object will be instantiated and called as such:<br> * MyCircularQueue obj = new MyCircularQueue(k);<br> * boolean param_1 = obj.enQueue(value);<br> * boolean param_2 = obj.deQueue();<br> * int param_3 = obj.Front();<br> * int param_4 = obj.Rear();<br> * boolean param_5 = obj.isEmpty();<br> * boolean param_6 = obj.isFull();<br> *&#47;","like_count":0},{"had_liked":false,"id":290943,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1619869995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619869995","product_id":100017301,"comment_content":"1. 分布式应用中的消息队列是队列结构。<br>2. 使用CAS实现无锁队列，在入队之前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之本次入队失败。出队则是获取head位置，进行cas<br>","like_count":0},{"had_liked":false,"id":290244,"user_name":"颜桦","can_delete":false,"product_type":"c1","uid":1099576,"ip_address":"","ucode":"1CD7250E052B32","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/38/d1a50cd6.jpg","comment_is_top":false,"comment_ctime":1619446462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619446462","product_id":100017301,"comment_content":"果然是一回生两回熟，第一次没看懂的第二次秒懂，感谢老师👨‍🏫","like_count":0},{"had_liked":false,"id":289619,"user_name":"你好，阳光","can_delete":false,"product_type":"c1","uid":2145095,"ip_address":"","ucode":"1A2F487C57F7D9","user_header":"https://static001.geekbang.org/account/avatar/00/20/bb/47/b60ae3eb.jpg","comment_is_top":false,"comment_ctime":1619101140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619101140","product_id":100017301,"comment_content":"课后思考：1.我知道的还有数据库连接池、 Web服务器的请求连接池 2. 原先不知道，看了精选留言之后知道CAS可以实现无锁并发队列，基本思想就是在入队、出队前和入队、出队时检查队列的head和tail指针有无变动","like_count":0},{"had_liked":false,"id":289283,"user_name":"Geek_bethel","can_delete":false,"product_type":"c1","uid":2541943,"ip_address":"","ucode":"C6313699A95B02","user_header":"https://static001.geekbang.org/account/avatar/00/26/c9/77/bf372419.jpg","comment_is_top":false,"comment_ctime":1618968423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618968423","product_id":100017301,"comment_content":"小结：<br>队列跟栈一样，也是一种操作受限的线性表数据结构。<br>队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个:<br>入队enqueue()，放一个数据到 队列尾部;<br>出队dequeue()，从队列头部取一个元素。<br><br>用数组实现的队列叫作顺序队列， 用链表实现的队列叫作链式队列。<br><br>循环队列，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。<br>要想写出没有bug的循环队列的实现代码，最关键的是，确定好队空和队满的判定条件。<br><br>阻塞队列其实就是在队列基础上增加了阻塞操作。<br>简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回;<br>如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。<br>我们可以使用阻塞队列，轻松实现一个“生产者-消费者模型”! 这种基于阻塞队列实现的“生产者-消费者模型”，可以有效地协调生产和消费的速度。<br><br>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。<br>实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。<br>&gt; CAS：compare and swap ，修改前比较一下原值，符合预期才修改，否则认为是被修改过了。操作系统底层支持的一个命令。<br>","like_count":0},{"had_liked":false,"id":289236,"user_name":"达叔灬","can_delete":false,"product_type":"c1","uid":2404887,"ip_address":"","ucode":"5CCBAF13548F02","user_header":"https://static001.geekbang.org/account/avatar/00/24/b2/17/3161b49c.jpg","comment_is_top":false,"comment_ctime":1618929397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618929397","product_id":100017301,"comment_content":"redis就是结合多路复用IO和事件队列的方式来达到单线程的高效。","like_count":0},{"had_liked":false,"id":288244,"user_name":"张知信","can_delete":false,"product_type":"c1","uid":2144474,"ip_address":"","ucode":"7C896BB3214B3D","user_header":"https://static001.geekbang.org/account/avatar/00/20/b8/da/42284f64.jpg","comment_is_top":false,"comment_ctime":1618377728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618377728","product_id":100017301,"comment_content":"什么是队列？先进先出的一种数据结构，支持入队 (enqueue) 和出队 (dequeue)，和栈相同是一种操作受限的线性表。<br>如何实现队列？数组实现，顺序队列；链表实现，链式队列。<br>循环队列。关键在于如何确定队为空和已满。<br>阻塞队列。生产者消费者模型，并发安全。<br>还有哪些场景用到队列排队请求呢？Java中Synchronized锁，内部实现也用到了一个入口等待队列和一个条件变量等待队列。<br>无锁并发。cas+自旋。","like_count":0},{"had_liked":false,"id":287732,"user_name":"imeteors","can_delete":false,"product_type":"c1","uid":1504435,"ip_address":"","ucode":"D1765B12B71A48","user_header":"https://static001.geekbang.org/account/avatar/00/16/f4/b3/071b69d1.jpg","comment_is_top":false,"comment_ctime":1618128686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618128686","product_id":100017301,"comment_content":"王老师，栈和队列是用数组实现还是链表实现多啊，性能上都一样吧？","like_count":0},{"had_liked":false,"id":286683,"user_name":"kdb_reboot","can_delete":false,"product_type":"c1","uid":1003594,"ip_address":"","ucode":"4C56FCA563FCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/50/4a/04fef27f.jpg","comment_is_top":false,"comment_ctime":1617499905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617499905","product_id":100017301,"comment_content":"温故知新，换工作了，接触dpdk，它的消息是通过共享队列传递的，通过CAS控制并发","like_count":0},{"had_liked":false,"id":285697,"user_name":"C","can_delete":false,"product_type":"c1","uid":2526224,"ip_address":"","ucode":"AC53CB00A8F5C8","user_header":"https://static001.geekbang.org/account/avatar/00/26/8c/10/7f402cb1.jpg","comment_is_top":false,"comment_ctime":1616983575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616983575","product_id":100017301,"comment_content":"没学过JAVA，public String dequeue() {<br>    &#47;&#47; 如果head == tail 表示队列为空<br>    if (head == tail) return null;<br>    String ret = items[head];<br>    head = (head + 1) % n;<br>    return ret;<br>  }<br>}这一段中为什么是返回ret","like_count":0},{"had_liked":false,"id":284437,"user_name":"zhangdroid","can_delete":false,"product_type":"c1","uid":1120940,"ip_address":"","ucode":"6254CEAEC274D3","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/ac/cec17283.jpg","comment_is_top":false,"comment_ctime":1616249174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616249174","product_id":100017301,"comment_content":"关于无锁实现并发队列，主要是用CAS原子操作，一般是用AotmicInterger保存队列指针来实现线程安全，这样可以提高并发性能。Java中大名鼎鼎的AQS框架（Doug lea大神开发）就实现了这一套线程安全的同步操作器，其中主要利用了双端队列和CAS原子操作（Unsafe）。顺便说一下，ReentrantLock就是利用了AQS来实现的。","like_count":0},{"had_liked":false,"id":283307,"user_name":"你看这是几","can_delete":false,"product_type":"c1","uid":1343836,"ip_address":"","ucode":"372DE61D5BA002","user_header":"https://static001.geekbang.org/account/avatar/00/14/81/5c/39e54eb3.jpg","comment_is_top":false,"comment_ctime":1615700161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615700161","product_id":100017301,"comment_content":"项目的github地址是什么呀？？？","like_count":0},{"had_liked":false,"id":283109,"user_name":"付寒宇Bazinga","can_delete":false,"product_type":"c1","uid":1676937,"ip_address":"","ucode":"D24D7185447A33","user_header":"https://static001.geekbang.org/account/avatar/00/19/96/89/3876a4b8.jpg","comment_is_top":false,"comment_ctime":1615549437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615549437","product_id":100017301,"comment_content":"| 我们先来看下基于数组的实现方法。<br><br>hi 这的实现有个疑问，一直入队，出队，持续增加 head 和 tail 那么这不是后续就无法继续入队了么？ n 不变的情况下只能入队和出队，队列是不能反复利用的么...","like_count":0},{"had_liked":false,"id":282682,"user_name":"24隋心所欲","can_delete":false,"product_type":"c1","uid":1342000,"ip_address":"","ucode":"1B8B2789F68C94","user_header":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","comment_is_top":false,"comment_ctime":1615363635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615363635","product_id":100017301,"comment_content":"Java 提供的专门的阻塞队列实现：<br><br>* 接口：BlockQueue 和 BlockingDeque<br>* 基于数组的实现类：ArrayBlockingQueue<br>* 基于链表的实现类：LinkedBlockingQueue 和 LinkedBlockingDeque<br>* 基于堆的实现类：PriorityBlockingQueue","like_count":0},{"had_liked":false,"id":280761,"user_name":"张Dave","can_delete":false,"product_type":"c1","uid":2440338,"ip_address":"","ucode":"0E8B6FDEB7505B","user_header":"https://static001.geekbang.org/account/avatar/00/25/3c/92/81fa306d.jpg","comment_is_top":false,"comment_ctime":1614350077,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1614350077","product_id":100017301,"comment_content":"老师，还有阻塞并发队列没有讲解呢？","like_count":0},{"had_liked":false,"id":280286,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614151745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614151745","product_id":100017301,"comment_content":"java-循环队列<br>public class CirculateQueue {<br><br>    static String[] arr = new String[8];<br>    static int tail = 0;<br>    static int head = 0;<br>    static int size = 0;&#47;&#47;标记<br><br>    public static void main(String[] args) {<br>        for (int i = 0; i &lt; 10; i++) {<br>            enqueue1(i + &quot;&quot;);<br>        }<br>        System.out.println(Arrays.toString(arr));<br>        dequeue1();<br>        enqueue1(11 + &quot;&quot;);<br>        enqueue1(12 + &quot;&quot;);<br>        dequeue1();<br>        dequeue1();<br>        enqueue(13 + &quot;&quot;);<br>        System.out.println(Arrays.toString(arr));<br>        System.out.println(&quot;head:&quot; + head);<br>        System.out.println(&quot;tail:&quot; + tail);<br>    }<br><br>    static void enqueue1(String val) {<br>        if (size == arr.length) {&#47;&#47;队满<br>            return;<br>        }<br>        if (tail == arr.length &amp;&amp; size &lt; arr.length) {<br>            tail = 0;<br>        }<br>        arr[tail] = val;<br>        size++;<br>        tail = (tail + 1) % arr.length; &#47;&#47;保持环形<br>    }<br><br>    static void dequeue1() {<br>        if (size == 0) {&#47;&#47;队空<br>            return;<br>        }<br>        size--;<br>        head = (head + 1) % arr.length; &#47;&#47;保持环形<br>    }<br>&#47;&#47;----------------------☆☆☆----------------------<br><br>    static void enqueue(String val) {<br>        if ((tail + 1) % arr.length == head) {&#47;&#47;队满<br>            return;<br>        }<br>        arr[tail] = val;<br>        tail = (tail + 1) % arr.length; &#47;&#47;保持环形<br>    }<br><br>    static void dequeue() {<br>        if (head == tail) {&#47;&#47;队空<br>            return;<br>        }<br>        size--;<br>        head = (head + 1) % arr.length; &#47;&#47;保持环形<br>    }<br>    &#47;*☆☆☆上面是按评论中的方法：使用一个标记字段，入队时加1，出队时减1，判断队空队满只需要比较标记字段和总容量即可，这样不用浪费一个数组的存储空间。<br>    * 运行结果：<br>        [0, 1, 2, 3, 4, 5, 6, 7]<br>        [11, 13, 2, 3, 4, 5, 6, 7]<br>        head:3<br>        tail:2<br>    * ☆☆☆下面是按老师讲的方法：当队列满时，tail指针的位置上是没有存储数据的。因为如果存了的话，就有head==tail了，就无法区分队空和队满了。所以，循环队列会浪费一个数组的存储空间。<br>    * 运行结果：<br>        [0, 1, 2, 3, 4, 5, 6, null]<br>        [13, 1, 2, 3, 4, 5, 6, 11]<br>        head:3<br>        tail:1<br>    * *&#47;<br>}<br>","like_count":0},{"had_liked":false,"id":279999,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614050002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614050002","product_id":100017301,"comment_content":"java-链式队列<br>public class LinkedQueue {<br>    static class ListNode {<br>        int val;<br>        ListNode next;<br><br>        public ListNode(int val) {<br>            this.val = val;<br>        }<br>    }<br><br>    static ListNode head = null;<br>    static ListNode tail = null;<br><br>    public static void main(String[] args) {<br>        for (int i = 0; i &lt; 10; i++) {<br>            enqueue(head, i);<br>        }<br>        print(head);<br>        dequeue();<br>        dequeue();<br>        enqueue(head, 11);<br>        enqueue(head, 12);<br>        dequeue();<br>        enqueue(head, 13);<br>        System.out.println(&quot;\\nhead:&quot; + head.val);<br>        System.out.println(&quot;tail:&quot; + tail.val);<br>        print(head);<br>    }<br><br>    static void enqueue(ListNode node, int val) {<br>        ListNode newNode = new ListNode(val);<br>        if (node == null) {<br>            node = newNode;<br>        } else if (node.next == null) {<br>            node.next = newNode;<br>            tail = node.next;<br>        } else {<br>            enqueue(node.next, val);<br>        }<br>        head = node;<br>    }<br><br>    static void dequeue() {<br>        if (head == tail) {<br>            return;<br>        }<br>        head = head.next;<br>    }<br><br>    static void print(ListNode node) {<br>        System.out.print(&quot;--&gt;&quot; + node.val);<br>        if (node.next != null) {<br>            print(node.next);<br>        }<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":279990,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1614048526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614048526","product_id":100017301,"comment_content":"java-顺序队列<br>public class ArrayQueue {<br>    static String[] arr = new String[5];<br>    static int head = 0;<br>    static int tail = 0;&#47;&#47;指向数组最后一个元素的下一个槽位<br><br>    public static void main(String[] args) {<br>        for (int i = 1; i &lt;= 5; i++) {<br>            enqueue(i + &quot;&quot;);<br>        }<br><br>        dequeue();<br>        dequeue();<br>        enqueue(&quot;11&quot;);<br>        enqueue(&quot;12&quot;);<br>        enqueue(&quot;13&quot;);<br>        dequeue();<br>        enqueue(&quot;14&quot;);<br>        dequeue();<br>        dequeue();<br>        enqueue(&quot;15&quot;);<br>        System.out.println(Arrays.toString(arr));<br>        System.out.println(&quot;head:&quot; + head + &quot;,tail:&quot; + tail);<br>    }<br><br>    public static void enqueue(String val) {<br>         if (tail == arr.length &amp;&amp; head &gt; 0) {<br>            for (int i = 0; i &lt; tail - head; i++) {<br>                arr[i] = arr[head - 0 + i];&#47;&#47;可省略-0<br>            }<br><br>            &#47;&#47;老师的for循环<br>&#47;&#47;             for (int i = head; i &lt; tail; i++) {<br>&#47;&#47;                 arr[i - head] = arr[i];<br>&#47;&#47;             }<br><br>            tail -= head - 0;&#47;&#47;可省略-0<br>            head = 0;<br>        }<br>        if (tail &lt; arr.length) {<br>            arr[tail] = val;<br>            tail++;<br>        }<br>    }<br><br>    public static void dequeue() {<br>        if (head == tail) {<br>            return;<br>        }<br>        head++;<br>    }<br>}","like_count":0},{"had_liked":false,"id":279864,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1613986817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613986817","product_id":100017301,"comment_content":"总结：<br>1.栈只支持两个基本操作：入栈 push()和出栈 pop()。<br>队列最基本的操作也是两个：入队enqueue()，放一个数据到队列尾部；出队dequeue()，从队列头部取一个元素。<br>队列跟栈一样，也是一种操作受限的线性表数据结构。<br>应用：高性能队列Disruptor、Linux环形缓存，都用到了循环并发队列；Java concurrent并发包利用ArrayBlockingQueue实现公平锁。<br><br>2.队列的实现：<br>基于数组的队列实现方法：(顺序队列)<br>需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。<br>head=0,tail=最后一个元素的下一个位置。随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。<br>当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。这时使用数据搬移，将head到tail之间的数据，整体搬移到数组中0到tail-head的位置。<br><br>基于链表的队列实现方法：(链式队列)<br>需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。<br>入队时，tail-&gt;next= new_node, tail = tail-&gt;next；（追加节点，移动tail指针）<br>出队时，head = head-&gt;next（移动head指针）<br><br>3.队列种类：<br>1).循环队列：<br>关键点：确定好队空和队满的判定条件<br>队空：head == tail。<br>队满：(tail+1)%n=head。（n为数组大小）<br>这里讲一下，这个表达式是怎么来的。在一般情况下，我们可以看出来，当队列满时，tail+1=head。（评论：樱小路依然）<br>但是，有个特殊情况就是tail=n-1，而head=0时，这时候，tail+1=n，而head=0，所以用(tail+1)%n == n%n == 0。<br>而且，tail+1最大的情况就是 n ，不会大于 n，这样，tail+1 除了最大情况，不然怎么余n都是tail+1本身，也就是head。<br>当队列满时，tail 指向的位置实际上是没有存储数据的。因为如果存了的话，就有head==tail了，就无法区分队空和队满了。所以，循环队列会浪费一个数组的存储空间。<br>也可以使用也一个标记字段，入队时加1，出队时减1，判断队空队满只需要比较标记字段和总容量即可，这样不用浪费一个数组空间。<br><br>2).阻塞队列（“生产者 - 消费者模型”）<br>阻塞队列其实就是在队列基础上增加了阻塞操作。<br>简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；<br>如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。<br><br>3).并发队列<br>在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题。<br>线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。<br>实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。<br><br>4).线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？<br>有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<br>基于链表的实现方式：可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。<br>基于数组实现的有界队列（bounded queue）：队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。<br>设置一个合理的队列大小是非常有讲究的，队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。<br>队列除了应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。<br>实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。<br><br>5.复杂度分析（评论：J.Spring）<br>在正常情况下，队列的入队和出队操作时间复杂度都是O(1)，在进行“数据搬移”改造的情况下，入队的时间复杂度分析：<br>如果队尾没有满，直接入队，时间复杂度为O(1)。<br>如果队尾已满，数据搬移，tail=n,搬移的时间复杂度为O(n)。均摊复杂度是O(1)。<br>感谢老师！","like_count":0},{"had_liked":false,"id":278428,"user_name":"骑着驴读着书的谢小夕","can_delete":false,"product_type":"c1","uid":1625340,"ip_address":"","ucode":"56F0A469B630A2","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/fc/92646317.jpg","comment_is_top":false,"comment_ctime":1612940068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612940068","product_id":100017301,"comment_content":"最近刚看了一个用循环队列实现的 共享内存的无锁访问","like_count":0},{"had_liked":false,"id":273436,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":2217714,"ip_address":"","ucode":"DEE2032A6C48D6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erBWCaFC3KbRDpjxMEhgZJFGo0q1twv9gicsUF5Qmu57X3bVt4wn1GV5ibhL2xlrGDuza7HhDiaMdxEg/132","comment_is_top":false,"comment_ctime":1610595096,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610595096","product_id":100017301,"comment_content":"循环队列 leetcode 622<br>class MyCircularQueue {<br>    int* queue;<br>    int len;<br>    int head;<br>    int tail;<br>    int count;<br>public:<br>    MyCircularQueue(int k) {<br>        queue = new int[k];<br>        len  = k;<br>        head = 0;<br>        tail = -1;<br>        count = 0;<br>    }<br>    <br>    bool enQueue(int value) {<br>        if (count == len)<br>        {<br>            return false;<br>        }<br><br>        tail = (tail + 1) % len;<br>        queue[tail] = value;<br>        ++count;<br>        return true;<br>    }<br>    <br>    bool deQueue() {<br>        if (count == 0)<br>        {<br>            return false;<br>        }<br><br>        head = (head + 1) % len;<br>        --count;<br>        return true;<br>    }<br>    <br>    int Front() {<br>        if (count == 0)<br>        {<br>            return -1;<br>        }<br>        return queue[head];<br>    }<br>    <br>    int Rear() {<br>        if (count == 0)<br>        {<br>            return -1;<br>        }<br>        return queue[tail];<br>    }<br>    <br>    bool isEmpty() {<br>        return count == 0;<br>    }<br>    <br>    bool isFull() {<br>        return count == len;<br>    }<br>};","like_count":0},{"had_liked":false,"id":268879,"user_name":"bowen","can_delete":false,"product_type":"c1","uid":1073569,"ip_address":"","ucode":"B0979D12090C7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/a1/f2ddc098.jpg","comment_is_top":false,"comment_ctime":1608386744,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608386744","product_id":100017301,"comment_content":"队列和栈一样是一种操作受限的数据结构，操作有入队enqueue和出队dequeue，队列可以用数组和链表实现，队列程序的核心特点就是需要头指针head和尾指针tail，队列的类型有循环队列，阻塞队列，并发队列等。<br>循环队列的实现难点在于判断队列满，队空head等于tail，队满时head和tail差一个，即tail+1等于head，但是由于是循环队列，所以要考虑tail下标最大的情况，所以队满的判断条件是(tail+1)%n==head<br>阻塞队列就是队满时阻塞入队，队空时阻塞出队<br>并发队列就是线程安全的队列，加锁会降低并发性能，而使用原子操作的数组队列可以实现高性能的并发<br>队列的应用有线程池的排队，还有网络通信的消息队列，这个我用过","like_count":0},{"had_liked":false,"id":268677,"user_name":"Geek_c293e4","can_delete":false,"product_type":"c1","uid":2055952,"ip_address":"","ucode":"39F8EF5C703639","user_header":"","comment_is_top":false,"comment_ctime":1608291018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608291018","product_id":100017301,"comment_content":"ArrayBlockingQueue的实现和文中的循环队列实现很类似，区别点<br>①ArrayBlockingQueue有一个单独的变量count记录队列中的数据量。如果count等于数组的长度，则判断已经满了。ReentrantLock保证count的安全性。<br>②ArrayBlockingQueue也没有数据的copy，只是加了一个写索引和一个读索引，如果 ++index == items.length，则重置为0，继续进行写入或读取。","like_count":0},{"had_liked":false,"id":267639,"user_name":"heyman","can_delete":false,"product_type":"c1","uid":1173894,"ip_address":"","ucode":"92EF9EF1B1B1B3","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/86/d34800a4.jpg","comment_is_top":false,"comment_ctime":1607852379,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607852379","product_id":100017301,"comment_content":"循环队列的构造函数，应该是这样才对吧：<br>items = new String[capacity + 1];<br>n = capacity + 1;","like_count":0},{"had_liked":false,"id":267183,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1607644402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607644402","product_id":100017301,"comment_content":"思考题：<br>1. 当服务器达到了请求处理上限时，有新的请求进来，这个新的请求就会排队，一旦超过了请求队列的大小，就会直接拒绝请求。","like_count":0},{"had_liked":false,"id":265463,"user_name":"晓周","can_delete":false,"product_type":"c1","uid":1188198,"ip_address":"","ucode":"F0F6871F8A8ADE","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/66/986f68f1.jpg","comment_is_top":false,"comment_ctime":1606905490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606905490","product_id":100017301,"comment_content":"循环队列的tai里为什么不能存储数据？","like_count":0},{"had_liked":false,"id":258854,"user_name":"gerry pang","can_delete":false,"product_type":"c1","uid":1068169,"ip_address":"","ucode":"54BD1D8DE1DBBF","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/89/e698c0a9.jpg","comment_is_top":false,"comment_ctime":1604568050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604568050","product_id":100017301,"comment_content":"老师文章中将“设置一个合理的队列大小，也是非常有讲究的”<br>对于这个问题，对于生产环境下您是如何估算一个合理（阻塞&#47;循环）队列大小呢，您估算时候的依据那些因素？","like_count":0},{"had_liked":false,"id":256367,"user_name":"Rancher","can_delete":false,"product_type":"c1","uid":1143268,"ip_address":"","ucode":"A5D01DF55D497E","user_header":"https://static001.geekbang.org/account/avatar/00/11/71/e4/0f7610a5.jpg","comment_is_top":false,"comment_ctime":1603610607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603610607","product_id":100017301,"comment_content":"我想问问 作者这个画图工具用的是什么，感觉很好看呀<br>","like_count":0},{"had_liked":false,"id":254242,"user_name":"郑思雨","can_delete":false,"product_type":"c1","uid":1474579,"ip_address":"","ucode":"F1F4B08FC94E7D","user_header":"https://static001.geekbang.org/account/avatar/00/16/80/13/df2a0ced.jpg","comment_is_top":false,"comment_ctime":1603090064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603090064","product_id":100017301,"comment_content":"无锁并发队列通常使用循环CAS算法进行判断，在队列为空，或队列已满的情况下，如果发生高并发，会对CPU造成很大的压力，同时浪费了CPU资源。可以依据场景，增加重试次数，超出重试次数，给出失败的提示。","like_count":0},{"had_liked":false,"id":252673,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1602429770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602429770","product_id":100017301,"comment_content":"实现了一个用循环链表实现的循环队列：<br>https:&#47;&#47;github.com&#47;kolinkuang&#47;algo-demos&#47;blob&#47;master&#47;queue&#47;circularLinkedListQueue.js","like_count":0},{"had_liked":false,"id":252535,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1602342680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602342680","product_id":100017301,"comment_content":"V8 Event Loop 中的宏任务跟微任务队列应该就是非阻塞性的循环队列。","like_count":0},{"had_liked":false,"id":251089,"user_name":"gaooakenshield","can_delete":false,"product_type":"c1","uid":2153598,"ip_address":"","ucode":"D5F3E2A12DE6D1","user_header":"https://static001.geekbang.org/account/avatar/00/20/dc/7e/4315166d.jpg","comment_is_top":false,"comment_ctime":1601361122,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601361122","product_id":100017301,"comment_content":"王争老师我有个问题，为什么head是指向队头元素的指针，tail却是指向队尾元素的下一个位置呢，tail指向队尾元素会有什么问题呢","like_count":0},{"had_liked":false,"id":250582,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1601139161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601139161","product_id":100017301,"comment_content":"阻塞队列中的阻塞操作如何理解？比如入队列的时候队列是空的，那么当前线程会被刮挂起吗？怎么挂起的呢？","like_count":0},{"had_liked":false,"id":248566,"user_name":"GEEKBANG_7745681","can_delete":false,"product_type":"c1","uid":1702547,"ip_address":"","ucode":"9668855F627CFD","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eruzEDjGnUFZz8ehoKKwy1IZKsPQ9ANkcZt0QMk1Uxuvx5FVlAYoiaaKoaKia99ticTib5sUkxsPduD4A/132","comment_is_top":false,"comment_ctime":1600223814,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600223814","product_id":100017301,"comment_content":"王争老师你好，在用数组实现队列的时候，搬移数据的地方，我认为您的代码不够严谨，在将head到tail之间的数据搬移到0 到tail-head的位置时候，需要将tail-head后原有的数据做清空处理，否则当没有入队列的情况时，全部出列时，会出现脏数据<br>","like_count":0},{"had_liked":false,"id":247751,"user_name":"WilliamVector","can_delete":false,"product_type":"c1","uid":1898112,"ip_address":"","ucode":"E0D3C3D4FCB7C9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/80/85ec2c2a.jpg","comment_is_top":false,"comment_ctime":1599817391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599817391","product_id":100017301,"comment_content":"【要点】<br>1、理解队列，队列最大的特点就是先进先出，主要的两个操作是入队和出队。跟栈一样，它既可以用数组来实现，也可以用链表来实现。用数组实现的叫顺序队列，用链表实现的叫链式队列。<br>2、循环队列，要想写出没有 bug 的循环队列的实现代码，最关键的是，确定好队空和队满的判定条件。队列为空的判断条件是 head == tail。当队列满时，tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。<br>3、阻塞队列，在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。使用阻塞队列，轻松实现一个“生产者 - 消费者模型”。<br>4、并发队列，线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。<br>5、关于线程池。基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。而基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。<br>【思考】<br>1、分布式消息队列，如kafka、rebbitmq、emqtt等。以及Android的Handler机制等<br>无锁机制的实现是基于CPU提供的一种原子操作CAS（Compare and Swap），CAS是这样工作的，它会原子地将一块内存的值与一个给定的值进行比较，如果它们相等就用新值替换返回true，否则什么也不做直接返回false。参考：http:&#47;&#47;blog.chinaunix.net&#47;uid-24692715-id-5759333.html","like_count":0},{"had_liked":false,"id":245939,"user_name":"coderli","can_delete":false,"product_type":"c1","uid":2160594,"ip_address":"","ucode":"E7A8D6C95E6FFA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7SFdnXQerohmd3jllgckaGdqUD1EWsbaGQqV20uSiayBLWNPTnGWpic31lxKpoc8dJMDcShqdsYSw/132","comment_is_top":false,"comment_ctime":1599115536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599115536","product_id":100017301,"comment_content":"判断对满的()tail+1)%n==head,就是看tail的下一个结点是不是head,如果是就说明队满","like_count":0},{"had_liked":false,"id":245499,"user_name":"dpjin","can_delete":false,"product_type":"c1","uid":1539183,"ip_address":"","ucode":"0383D8003E6C14","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pHPfugzib71JdXkKxRITCzdD46DYcDYHImoYeibHdyu4hLWOBXh7OLllx247vKJvWIcu18dxWOTAtv8AaRB8opvQ/132","comment_is_top":false,"comment_ctime":1598960703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598960703","product_id":100017301,"comment_content":"golang 实现普通队列和循环队列<br>package main<br><br>import &quot;fmt&quot;<br><br>type Node struct {<br>\tdata int<br>\tnext *Node<br>}<br><br>type LinkedList struct {<br>\theadNode *Node<br>\ttailNode *Node<br>\tlength   int<br>\tcount    int<br>}<br><br>func NewQueue(length int) *LinkedList {<br>\treturn &amp;LinkedList{length: length}<br>}<br><br>&#47;&#47; 入队<br>func (l *LinkedList) Push(data int) bool {<br>\tif l.count == l.length{<br>\t\tl.tailNode = nil<br>\t\treturn false<br>\t}<br>\tnode := &amp;Node{data: data}<br>\tif l.headNode == nil{<br>\t\tl.headNode = node<br>\t}else{<br>\t\tl.tailNode.next = node<br>\t}<br>\tl.tailNode = node<br>\tl.count++<br>\treturn true<br>}<br><br>&#47;&#47; 循环队列入队<br>func (l *LinkedList) LoopPush(data int) bool {<br>\tif l.count == l.length{<br>\t\tl.tailNode = nil<br>\t\treturn false<br>\t}<br>\tnode := &amp;Node{data: data, next: l.headNode}<br>\tif l.headNode == nil{<br>\t\tl.headNode = node<br>\t}else{<br>\t\tl.tailNode.next = node<br>\t}<br>\tl.tailNode = node<br>\tl.count++<br>\treturn true<br>}<br><br>&#47;&#47; 出对<br>func (l *LinkedList) Pop() int {<br>\tif l.count == 0 {<br>\t\treturn 0<br>\t}<br>\tres := l.headNode.data<br>\tl.headNode = l.headNode.next<br>\tl.count--<br>\treturn res<br>}","like_count":0},{"had_liked":false,"id":245250,"user_name":"剑影梦残","can_delete":false,"product_type":"c1","uid":1284481,"ip_address":"","ucode":"A5C5DAA49F6996","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/XSnxM4uP67mVu7ZtPxWqUIvFH15pibGt1rFd34EiblN6NFfgKEKBuibLlI1kUjOIfbY56icwBibn6MmXzSEXm7AHicdQ/132","comment_is_top":false,"comment_ctime":1598875648,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598875648","product_id":100017301,"comment_content":"1.使用循环队列来避免搬迁数据 2.阻塞队列考虑并发数量关系，可以多个消费者对应一个生产者。3.CAS来实现无锁队列，通过判断tail位置在入队时是否发生改变。出队时判断head位置是否发生改变","like_count":0},{"had_liked":false,"id":244227,"user_name":"夜空咏叹调","can_delete":false,"product_type":"c1","uid":1189074,"ip_address":"","ucode":"CC9350BCF218CD","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d2/a5e272ce.jpg","comment_is_top":false,"comment_ctime":1598434547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598434547","product_id":100017301,"comment_content":"老师，我有个疑问，在环形队列dequeue()方法里，head位置改变的时候，是否没必要用(head+1)%n，而直接用head++就行，因为我理解在出队的情况下head&lt;=tail的，而tail=head情况在一开始就排除了，head+1极端情况是刚好等于tail，而tail这个时候一定是没有超过n的，因为没必要去和n取模，不知道能否解答一下。","like_count":0},{"had_liked":false,"id":243798,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598278994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598278994","product_id":100017301,"comment_content":"用到队列操作的一个典型应用就是消息中间件，然后就是一种特殊情况需要对某一类特定消息有顺序的读取时会在内存中生成队列，将消息放入队列排成顺序。<br>无锁并发就是在出队入队通过自旋CAS对入队，出队请求进行判断，如果成功就进行入队或出队操作， 失败就继续尝试<br>","like_count":0},{"had_liked":false,"id":243212,"user_name":"Jiantao","can_delete":false,"product_type":"c1","uid":1163504,"ip_address":"","ucode":"444580EC5EF109","user_header":"https://static001.geekbang.org/account/avatar/00/11/c0/f0/1aabc056.jpg","comment_is_top":false,"comment_ctime":1597994734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597994734","product_id":100017301,"comment_content":"#cp#总结<br>一、什么是队列？<br>1.先进者先出，这就是典型的“队列”结构。<br>2.支持两个操作：入队enqueue()，放一个数据到队尾；出队dequeue()，从队头取一个元素。<br>3.所以，和栈一样，队列也是一种操作受限的线性表。<br>二、如何实现队列？<br>1.队列API<br>public interface Queue&lt;T&gt; {<br>public void enqueue(T item); &#47;&#47;入队<br>public T dequeue(); &#47;&#47;出队<br>public int size(); &#47;&#47;统计元素数量<br>public boolean isNull(); &#47;&#47;是否为空<br>}<br>2.数组实现（顺序队列）：见下一条留言<br>3.链表实现（链式队列）：见下一条留言<br>4.循环队列（基于数组）：见下一条留言<br>三、队列有哪些常见的应用？<br>1.阻塞队列<br>1）在队列的基础上增加阻塞操作，就成了阻塞队列。<br>2）阻塞队列就是在队列为空的时候，从队头取数据会被阻塞，因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后在返回。<br>3）从上面的定义可以看出这就是一个“生产者-消费者模型”。这种基于阻塞队列实现的“生产者-消费者模型”可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了，这时生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续生产。不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据处理效率，比如配置几个消费者，来应对一个生产者。<br>2.并发队列<br>1）在多线程的情况下，会有多个线程同时操作队列，这时就会存在线程安全问题。能够有效解决线程安全问题的队列就称为并发队列。<br>2）并发队列简单的实现就是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或取操作。<br>3）实际上，基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。<br>3.线程池资源枯竭是的处理<br>在资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。<br>四、思考<br>1.除了线程池这种池结构会用到队列排队请求，还有哪些类似线程池结构或者场景中会用到队列的排队请求呢？<br>2.今天讲到并发队列，关于如何实现无锁的并发队列，网上有很多讨论。对这个问题，你怎么看？","like_count":0},{"had_liked":false,"id":243202,"user_name":"随风","can_delete":false,"product_type":"c1","uid":1476862,"ip_address":"","ucode":"037CE3554D8AB9","user_header":"https://static001.geekbang.org/account/avatar/00/16/88/fe/c18a85fe.jpg","comment_is_top":false,"comment_ctime":1597992077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597992077","product_id":100017301,"comment_content":"第一个例子出队后没有处理n和tail，就算队列为空了下次还是无法入队了啊？","like_count":0},{"had_liked":false,"id":241144,"user_name":"西电","can_delete":false,"product_type":"c1","uid":2063037,"ip_address":"","ucode":"95BD4CE9D93018","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7a/bd/1f461acf.jpg","comment_is_top":false,"comment_ctime":1597201094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597201094","product_id":100017301,"comment_content":"判断环形队列已满的方法:若tail 加一等于head， if(head == addOnece(tail)) ； 加法函数自定义，加到头了转到0","like_count":0},{"had_liked":false,"id":240626,"user_name":"Geek_216fd5","can_delete":false,"product_type":"c1","uid":1602049,"ip_address":"","ucode":"EA6804E9E974B3","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLb5UK2u6RyS48ia8H2lUSlUyQEaBiclDlqpbQUWqTWeuf3Djl3ruHRN3U37GXYuWAfAW5d1xkm6F7w/132","comment_is_top":false,"comment_ctime":1597021216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597021216","product_id":100017301,"comment_content":"class ArrayQueue(object):<br>    def __init__(self, capacity):<br>        self.arrayQueue = list(&#39;-&#39;*capacity)<br>        self._head = 0<br>        self._tail = 0<br>        self.capacity = capacity<br>        self.occupied = 0<br>    # 新来的直接按顺序坐在空位上<br>    # 已经落座的人不用往前挪位置<br>    def enQueue(self, item):<br>        if self.occupied &lt; self.capacity:<br>            if self._tail == self.capacity:<br>                self._tail = 0<br>            print(self._tail)<br>            self.arrayQueue[self._tail] = &#39;A&#39;<br>            self._tail += 1<br>            self.occupied += 1<br>        else:<br>            print(&#39;queue full!&#39;)<br><br>    def dequeue(self):<br>        if self.occupied &gt; 0:<br>            if self._head == self.occupied:<br>                self._head = 0<br>            self.arrayQueue[self._head] = &#39;-&#39;<br>            self._head +=1<br>            self.occupied -= 1<br>        else :<br>            print(&#39;empty&#39;)<br><br><br><br>    def displayQueue(self):<br><br>        print(&#39;&#39;.join(str(i) for i in self.arrayQueue))<br><br><br><br>if __name__ == &#39;__main__&#39;:<br>    capacity = 10<br>    hotelQueue = ArrayQueue(capacity)<br>    deltaStr = &#39;&#39;<br>    while deltaStr != &quot;init9&quot;:<br>        deltaStr = input(&#39;please input init9 to exit or delta num to the queue!&#39;)<br>        if int(deltaStr) &gt; 0:<br>            for i in range(0, int(deltaStr)):<br>                hotelQueue.enQueue(&#39;A&#39;)<br>            hotelQueue.displayQueue()<br>        elif int(deltaStr) &lt; 0:<br>            for i in range(0, -int(deltaStr)):<br>                hotelQueue.dequeue()<br>            hotelQueue.displayQueue()<br>        else:<br>            deltaStr = input(&#39;please input init9 to exit or delta num to the queue!&#39;)<br>","like_count":0},{"had_liked":false,"id":240145,"user_name":"衍虚","can_delete":false,"product_type":"c1","uid":2093100,"ip_address":"","ucode":"4A7F7F53EA5A3E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f0/2c/a373fac5.jpg","comment_is_top":false,"comment_ctime":1596770581,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596770581","product_id":100017301,"comment_content":"Class里加一个跟踪当前queue大小的attr，同时实现了一下全利用的功能<br><br>public class CircularQueue {<br>    private String[] items;<br>    private int capacity = 0;<br>    private int size = 0;<br>    private int head = 0;<br>    private int tail = 0;<br><br>    public CircularQueue(int cap){<br>        items = new String[cap];<br>        capacity = cap;<br>        size = 0;<br>    }<br><br>    public boolean enqueue(String item){<br>        if (size &gt;= capacity) {<br>            return false;<br>        } else {<br>            items[tail] = item;<br>            tail = (tail + 1) % capacity;<br>            size++;<br>            return true;<br>        }<br>    }<br>    <br>    public String dequeue(){<br>        if (size == 0) {<br>            return null;<br>        } else {<br>            String ret = items[head];<br>            size--;<br>            head = (head + 1) % capacity;<br>            return ret;<br>        }<br>    }<br><br>    public void printQueue(){<br>        int i = head;<br>        if(size == capacity){<br>            System.out.printf(&quot;%s &quot;, items[i]);<br>            i = (i+1) % capacity;<br>        }<br>        for(; i!=tail; i = (i+1)%capacity){<br>            System.out.printf(&quot;%s &quot;, items[i]);<br>        }<br>        System.out.println(&quot;&quot;);<br>    }<br>","like_count":0},{"had_liked":false,"id":239741,"user_name":"新安","can_delete":false,"product_type":"c1","uid":1876592,"ip_address":"","ucode":"CA2E1304FCAC6A","user_header":"https://static001.geekbang.org/account/avatar/00/1c/a2/70/98cfd56b.jpg","comment_is_top":false,"comment_ctime":1596630590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596630590","product_id":100017301,"comment_content":"基于链表实现队列:<br>public class ListNode {<br><br>    public Integer value;<br><br>    public ListNode next;<br><br>    public ListNode(Integer value) {<br>        this.value = value;<br>    }<br><br>}<br><br>public class LinkedListQueue {<br><br>    public ListNode head;<br><br>    public ListNode tail;<br><br>    &#47;**<br>     *  入队列<br>     * @param item<br>     * @return<br>     *&#47;<br>    public boolean enqueue(Integer item) {<br>        ListNode node = new ListNode(item);<br>        if (this.head == null) {<br>            head = node;<br>            tail = node;<br>        } else {<br>            tail.next = node;<br>            tail = node;<br>        }<br>        return true;<br>    }<br><br>    &#47;**<br>     * 出队列<br>     * @return<br>     *&#47;<br>    public ListNode dequeue() {<br>        ListNode dequeueNode = head;<br>        head = head.next;<br>        return dequeueNode;<br>    }<br><br>}","like_count":0},{"had_liked":false,"id":239561,"user_name":"jack","can_delete":false,"product_type":"c1","uid":1898292,"ip_address":"","ucode":"A2253AC8570C5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jibauP3icEFic4w56L2ddVghL7h2gGKhFdW8lBfE9rpwwRgzUKkLFY9wb4w70AXz7retME96a6EBRTA0LvSLn0ib8A/132","comment_is_top":false,"comment_ctime":1596587936,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596587936","product_id":100017301,"comment_content":"分布式应用中的消息队列，也是一种队列结构。","like_count":0},{"had_liked":false,"id":239449,"user_name":"Henry Liao","can_delete":false,"product_type":"c1","uid":1635174,"ip_address":"","ucode":"EA8407D15E2CC6","user_header":"https://static001.geekbang.org/account/avatar/00/18/f3/66/5d7ba082.jpg","comment_is_top":false,"comment_ctime":1596534127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596534127","product_id":100017301,"comment_content":"关于CAS 并发队列相关的知识，google些文章完全看不懂，老师能讲解一下吗，有没有通俗易懂的文章推荐","like_count":0},{"had_liked":false,"id":237383,"user_name":"BADTZ-MARU 🍪","can_delete":false,"product_type":"c1","uid":1325267,"ip_address":"","ucode":"358FAA1C9F5721","user_header":"https://static001.geekbang.org/account/avatar/00/14/38/d3/07585dc8.jpg","comment_is_top":false,"comment_ctime":1595815145,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595815145","product_id":100017301,"comment_content":"我想问一下，对循环队列，如果每次入队执行的tail%n的动作，出队同理，判断队满就是tail - head == n，然后每次入队，出队都是执行的tail++, head++，指针不重置，这样是不是可以不浪费那个位置","like_count":0},{"had_liked":false,"id":236995,"user_name":"Wipeher","can_delete":false,"product_type":"c1","uid":1108731,"ip_address":"","ucode":"A5D7451D95F42C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/wIWrciav7DRkOaD7vUtr084sxprq2U4obfH1ibls4RIsAw5foQlDGIt98x1RHATznNbh0iasibWV2Y7I7QpyFJ4TVA/132","comment_is_top":false,"comment_ctime":1595645734,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595645734","product_id":100017301,"comment_content":"有几个想法，就是循环队列是否可以链表实现，无锁并发队列是否也可以用链表实现","like_count":0},{"had_liked":false,"id":236741,"user_name":"李孟","can_delete":false,"product_type":"c1","uid":1006768,"ip_address":"","ucode":"AD2349CB12F130","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/b0/77e5f8c8.jpg","comment_is_top":false,"comment_ctime":1595514864,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1595514864","product_id":100017301,"comment_content":"   &#47;**<br>     * 循环队列<br>     * 入队<br>     * @param item 值<br>     *&#47;<br>    public void cycleEnqueue(String item){<br>        if(((tail+1) &amp; (n-1)) == head){<br>            return;<br>        }<br>        items[tail] = item;<br>        tail = (tail+1) &amp; (n-1);<br>    }<br><br>    &#47;**<br>     * 循环出队<br>     * 出队<br>     *&#47;<br>    public String cycleDequeue(){<br>        if(head == tail) return null;<br>        String item = items[head];<br>        head = (head+1)&amp;(n-1);<br>        return item;<br>    }","like_count":0},{"had_liked":false,"id":234667,"user_name":"williamcai","can_delete":false,"product_type":"c1","uid":1158294,"ip_address":"","ucode":"B158F52C2D39BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg","comment_is_top":false,"comment_ctime":1594771335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594771335","product_id":100017301,"comment_content":"针对第一个问题，我想到大学食堂排队吃饭的场景，打饭的窗口就10个，能同时并发处理10个，大家排成10个队伍，毕竟食堂空间有限，当10个队伍都晒满了，后面的人直接拒在食堂们之外。<br>针对第二个问题，并发队列加锁性能会下降，并发度降低，不加锁并发度高，但是线程不安全，这是一个矛盾问题，要在这之间寻找平衡","like_count":0},{"had_liked":false,"id":234635,"user_name":"Merry","can_delete":false,"product_type":"c1","uid":1024036,"ip_address":"","ucode":"E2A114E10814BA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a0/24/68c679c8.jpg","comment_is_top":false,"comment_ctime":1594738738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594738738","product_id":100017301,"comment_content":"思考1:SPOOLING技术、进程调度算法、二叉树的层次遍历会用到队列","like_count":0},{"had_liked":false,"id":232814,"user_name":"Adams","can_delete":false,"product_type":"c1","uid":1450626,"ip_address":"","ucode":"6E149B3E76BCD9","user_header":"https://static001.geekbang.org/account/avatar/00/16/22/82/36e3c5d8.jpg","comment_is_top":false,"comment_ctime":1594123542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594123542","product_id":100017301,"comment_content":"思路理科了，第二段顺序队列如队列的代码我感觉有点想不通，数据迁移那段代码的判断难道不应该是i&lt;=tail么，我拿head=2,tail=4反复试了几遍","like_count":0},{"had_liked":false,"id":232254,"user_name":"FD","can_delete":false,"product_type":"c1","uid":2052521,"ip_address":"","ucode":"ED396BD322489E","user_header":"https://static001.geekbang.org/account/avatar/00/1f/51/a9/741b5ad9.jpg","comment_is_top":false,"comment_ctime":1593936052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593936052","product_id":100017301,"comment_content":"数组实现的循环队列，添加一个变量cur表示当前队列元素的个数，判断满的条件改成if(tail==head &amp;&amp; cur==n )，不就可以不浪费一个存储单元吗？","like_count":0},{"had_liked":false,"id":231477,"user_name":"憎爱不关心","can_delete":false,"product_type":"c1","uid":1133580,"ip_address":"","ucode":"A868ACB200C798","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/0c/ada45f25.jpg","comment_is_top":false,"comment_ctime":1593683197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593683197","product_id":100017301,"comment_content":"1.游戏中的消息队列<br>2.不熟悉Java，不知道怎么实现","like_count":0},{"had_liked":false,"id":230203,"user_name":"Geek_dd8b2b","can_delete":false,"product_type":"c1","uid":1988075,"ip_address":"","ucode":"CBEF7C39075A96","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJX4ZU53F8hBHicctluqK6Ef3U0ib40bq1vFyAvqV0wu3GaPuWbj967OdMT7k0gl3OMxsfopvbk9veQ/132","comment_is_top":false,"comment_ctime":1593310213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593310213","product_id":100017301,"comment_content":"正在刷leetcode的探索 队列，然后就二刷了这篇，发现王老师的环形队列真的有助于理解如何计算队列满的时候，","like_count":0},{"had_liked":false,"id":229117,"user_name":"Geek_e68053","can_delete":false,"product_type":"c1","uid":2044920,"ip_address":"","ucode":"53AA5F0627FEEC","user_header":"","comment_is_top":false,"comment_ctime":1592899926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592899926","product_id":100017301,"comment_content":"对与数组队列，移动元素不是最好的方案，作者应该给出最好的方案","like_count":0},{"had_liked":false,"id":228699,"user_name":"Geek_5ab375","can_delete":false,"product_type":"c1","uid":2017446,"ip_address":"","ucode":"A508D91ACBC234","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/icK2dToXWiaDx4giaXsrlpA5Ka4duq1ELzHmZbT2gPHtPoibT1eolSSAH2T9V4ncSfWw7hiaK6TjSPohSzUOxLn4aRA/132","comment_is_top":false,"comment_ctime":1592789535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592789535","product_id":100017301,"comment_content":"++head会不会造成频繁申请空间和gc","like_count":0},{"had_liked":false,"id":227073,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1592275615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592275615","product_id":100017301,"comment_content":"1.Android 的 OKHTTP 中有用到有界队列来处理请求；","like_count":0},{"had_liked":false,"id":225630,"user_name":"Geek_849f9f","can_delete":false,"product_type":"c1","uid":2027473,"ip_address":"","ucode":"67601F35A91999","user_header":"","comment_is_top":false,"comment_ctime":1591801865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591801865","product_id":100017301,"comment_content":"异步发布任务到消息队列","like_count":0},{"had_liked":false,"id":221783,"user_name":"七月","can_delete":false,"product_type":"c1","uid":1988043,"ip_address":"","ucode":"876EE5EAEC9DC4","user_header":"https://static001.geekbang.org/account/avatar/00/1e/55/cb/9c23f47d.jpg","comment_is_top":false,"comment_ctime":1590590999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590590999","product_id":100017301,"comment_content":"内存池，应该算是一种队列，一种资源有限情况。我遇到更多是有加锁的队列，无锁并发队列还是挺感兴趣","like_count":0},{"had_liked":false,"id":221685,"user_name":"KangShan","can_delete":false,"product_type":"c1","uid":1082000,"ip_address":"","ucode":"07497A7AC92238","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/90/e4a08b0e.jpg","comment_is_top":false,"comment_ctime":1590566143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590566143","product_id":100017301,"comment_content":"不明白环形队列 为什么一定要让尾部空一个不能填充，让其填充 tail 与 head 指针重合也没关系，至于是否队空队满的情况直接判空就行了呀？<br><br>```java<br>private int size;<br>    private int head = 0, tail = 0;<br>    private Object[] elements;<br><br>    public CycleQueue(int size) {<br>        this.size = size;<br>        elements = new Object[size];<br>    }<br><br>    public boolean push(E e) {<br>        if (elements[tail] == null) {<br>            elements[tail] = e;<br>            tail = (tail + 1) % size;<br>            return true;<br>        } else {<br>            return false;<br>        }<br>    }<br><br>    public E pop() {<br>        if (elements[head] != null) {<br>            E element = (E) elements[head];<br>            elements[head] = null;<br>            head = (head + 1) % size;<br>            return element;<br>        } else {<br>            return null;<br>        }<br>    }<br>```","like_count":0},{"had_liked":false,"id":220351,"user_name":"Geek_py hang","can_delete":false,"product_type":"c1","uid":1915167,"ip_address":"","ucode":"E1DABF14C9176B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/39/1f/579ae900.jpg","comment_is_top":false,"comment_ctime":1590225562,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590225562","product_id":100017301,"comment_content":"先进先出，库存管理","like_count":0},{"had_liked":false,"id":218882,"user_name":"guan0078","can_delete":false,"product_type":"c1","uid":1090467,"ip_address":"","ucode":"53B15FF3752A40","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/a3/804fb3e9.jpg","comment_is_top":false,"comment_ctime":1589892509,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589892509","product_id":100017301,"comment_content":"1. 最常用的就是消息队列。发邮件、站内信、发短信等都是这种实现方式。采用的是阻塞队列。<br>2. 无锁并发队列说实话没仔细研究过，也是看过一些文章后才大致了解了。基本思路是采用CAS的方式，入队判断tail是否发生改动，变化的话可以直接返回，或者等待到下次循环继续判断tail是否有改动，直到判断tail没有改动，则入队。这种主要检查当A执行入栈时，tail指针位置已经发生改变的情况。","like_count":0},{"had_liked":false,"id":217609,"user_name":"iris","can_delete":false,"product_type":"c1","uid":1986106,"ip_address":"","ucode":"8D54D1DBEA6F64","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4e/3a/1932100c.jpg","comment_is_top":false,"comment_ctime":1589546947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589546947","product_id":100017301,"comment_content":"队列：一种基本的数据结构，先进先出，只有两种操作“入队”和“出队”。<br>队列的常见应用：<br>1、阻塞队列：当队列满时阻塞入队操作，当队列空时阻塞出队操作<br>2、并发队列：“基于数组的循环队列利用CAS原子操作，可以实现非常高效的并发队列”这句话我还要学习学习，不怎么看得懂","like_count":0},{"had_liked":false,"id":216246,"user_name":"高旭瑞","can_delete":false,"product_type":"c1","uid":1243897,"ip_address":"","ucode":"284335282EE526","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/f9/f4ca4080.jpg","comment_is_top":false,"comment_ctime":1589209203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589209203","product_id":100017301,"comment_content":"循环队列，读空了，就是readIndex追上writeIndex了，写满了就是writeIndex套圈追上readIndex了。<br>这个追readIndex和writeIndex都不等于size-1时，表现为读空：readIndex+1=writeIndex，写满是writeIndex+1 = readIndex。","like_count":0},{"had_liked":false,"id":215726,"user_name":"豪豪豪豪","can_delete":false,"product_type":"c1","uid":1906479,"ip_address":"","ucode":"BD1A4B3E4D21F4","user_header":"https://static001.geekbang.org/account/avatar/00/1d/17/2f/ea285ab5.jpg","comment_is_top":false,"comment_ctime":1589086974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589086974","product_id":100017301,"comment_content":"可以两个指针不断的在队列中循环 去除掉所有的数组搬移","like_count":0},{"had_liked":false,"id":214609,"user_name":"Geek_bb2310","can_delete":false,"product_type":"c1","uid":1926508,"ip_address":"","ucode":"022885B257DEB3","user_header":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","comment_is_top":false,"comment_ctime":1588772564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588772564","product_id":100017301,"comment_content":"我突然想起电影人体蜈蚣，。。。。。。。。。。","like_count":0},{"had_liked":false,"id":214067,"user_name":"Geek_fa5cb8","can_delete":false,"product_type":"c1","uid":1648729,"ip_address":"","ucode":"D71C177A139658","user_header":"","comment_is_top":false,"comment_ctime":1588649304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588649304","product_id":100017301,"comment_content":"队列是先进先出的数据结构，凡是对这种操作顺序是FIFO的模式都可以采用队列，<br>解决队列的数据搬移O(N)的时间复杂度，就可以采用循环队列<br>循环队列设计主要注意的是队列的判空和队列满的判断<br>队列空:tail=n,队列满 (tail+1)%n=head<br>","like_count":0},{"had_liked":false,"id":213256,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588341782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588341782","product_id":100017301,"comment_content":"学习笔记: 队列和栈对于我来说是典型好理解但不会用的数据结构<br>1. 队列分为顺序队列和链式队列<br>2. 顺序队列入队是会出现数据搬移操作，循环队列能解决该问题<br>3.循环队列用的比较多，循环队列+CAS原子操作可以高效实现并发队列<br>4. 循环队列实现的关键在于队满的判断。<br>入队：判断是否队满 (tail+1)%n = head; 没满则入队；queue[tai]l = data; tail = (tail+1)%n;<br>出队：判断队空 tail == head ？如果不空，则head = (head +1)%n<br>循环队列有一个位置是不存数据的。<br>4. 队列用于任何资源有限的场景，排队请求资源，如线程池、数据库的连接池？<br>5. 本节课陌生概念：<br>    数据库的连接池。<br>    阻塞队列<br>    并发队列（循环队列+CAS原子操作）<br>    入队、出队方法加锁<br>课后思考题力不从心了：<br>类似于线程池的：windows软件的消息队列<br>无锁并发队列：完全不懂","like_count":0},{"had_liked":false,"id":213069,"user_name":"严丹","can_delete":false,"product_type":"c1","uid":1798204,"ip_address":"","ucode":"96FA634D06C3FD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/70/3c/a002615b.jpg","comment_is_top":false,"comment_ctime":1588296042,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588296042","product_id":100017301,"comment_content":"通过阻塞队列的讲解，终于能够和java高并发中的线程池处理策略联系起来，为什么直接拒绝？为什么排队分为有限、无限等待？","like_count":0},{"had_liked":false,"id":210773,"user_name":"hailowell","can_delete":false,"product_type":"c1","uid":1195572,"ip_address":"","ucode":"557DCAB01710AB","user_header":"","comment_is_top":false,"comment_ctime":1587823794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587823794","product_id":100017301,"comment_content":"环形队列 初始化时头下标和尾下标相等<br>之后判断队空是头尾下标相等，队满的判断是尾下标下一次移动就会和头下标相等<br>使用这个判断不会浪费一个空间 同时出队时不用清空本来的数据，使用时直接覆盖就好","like_count":0},{"had_liked":false,"id":208248,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1587308210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587308210","product_id":100017301,"comment_content":"「在用数组实现的非循环队列中，队满的判断条件是 tail == n，队空的判断条件是 head == tail。那针对循环队列，如何判断队空和队满呢？」 <br>tail与head指向同一位置时，可以通过判断当前节点的值是否为空，来判断是否为对空或对满吧","like_count":0},{"had_liked":false,"id":208216,"user_name":"海盗船长","can_delete":false,"product_type":"c1","uid":1363634,"ip_address":"","ucode":"ECB28BA21A4113","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/b2/1f914527.jpg","comment_is_top":false,"comment_ctime":1587303270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587303270","product_id":100017301,"comment_content":"计算网络中数据的传输都会用到队列。","like_count":0},{"had_liked":false,"id":207838,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1587194467,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587194467","product_id":100017301,"comment_content":"1.除了线程池这种池结构会用到队列排队请求，你还知道有哪些类似的池结构或者场景中会用到队列的排队请求呢？<br>消息队列<br>2.今天讲到并发队列，关于如何实现无锁并发队列，网上有非常多的讨论。对这个问题，你怎么看呢？<br>会用多个小的队列先来存储请求的数据和请求顺序,然后多个小的队列再按照CAS的方式向大的队列提交小队列中的内容,这样提交时一次性就可以提交多份请求到最终的大队列中,而且也大大减少了竞争的次数,这也是用空间换时间的一种方式,用更多的内存来换取更高的处理效率.","like_count":0},{"had_liked":false,"id":207798,"user_name":"罗盖","can_delete":false,"product_type":"c1","uid":1357135,"ip_address":"","ucode":"1B098D4CA6096A","user_header":"https://static001.geekbang.org/account/avatar/00/14/b5/4f/10c694db.jpg","comment_is_top":false,"comment_ctime":1587181834,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1587181834","product_id":100017301,"comment_content":"为什么循环队列需要多出一个位置不存储任何数据？","like_count":0,"discussions":[{"author":{"id":1357135,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/4f/10c694db.jpg","nickname":"罗盖","note":"","ucode":"1B098D4CA6096A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239056,"discussion_content":"如果没有多出一个位置，当循环队列中为空和满时front=tail无法区分，加上一个空白，为空时front=tail,满队列时(tail+1)%n=front","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587269422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207770,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1587177201,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587177201","product_id":100017301,"comment_content":"两个问题完全超出了自己的知识范围😭","like_count":0},{"had_liked":false,"id":207748,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1587174226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587174226","product_id":100017301,"comment_content":"是不是可以在heas==tail时把指针同时移到头部，并且在入队时满了搬移数据？","like_count":0},{"had_liked":false,"id":207217,"user_name":"马翼","can_delete":false,"product_type":"c1","uid":1963766,"ip_address":"","ucode":"11C8D7AA4F2D79","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f6/f6/149d9150.jpg","comment_is_top":false,"comment_ctime":1587025982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587025982","product_id":100017301,"comment_content":"1.判断队列满的条件除了文中所提到的(tail + 1) % n == head，还可以设置标识位flag。<br>2.%n是为了处理当tail为n-1的特殊情况，其他情况应该通过tail + 1 == head可以解决。","like_count":0},{"had_liked":false,"id":206033,"user_name":"梅端","can_delete":false,"product_type":"c1","uid":1525335,"ip_address":"","ucode":"FEC08731457770","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/57/fe38a6db.jpg","comment_is_top":false,"comment_ctime":1586776658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586776658","product_id":100017301,"comment_content":"还是第一次听说循环队列，感觉又涨知识了","like_count":0},{"had_liked":false,"id":204675,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1586440294,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586440294","product_id":100017301,"comment_content":"Golang 的 channel 用到了阻塞式的并发队列，多协程从同一个 channel 中读取或写入数据。","like_count":0},{"had_liked":false,"id":201716,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585823996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585823996","product_id":100017301,"comment_content":"&lt;?php<br>&#47;&#47; 循环队列<br>class CircularQueue {<br>\tprivate $n = 0; &#47;&#47; 循环队列长度<br>\tprivate $head = 0;&#47;&#47; 队头下标<br>\tprivate $tail = 0;&#47;&#47; 队尾下标<br>\tprivate $items=[]; &#47;&#47; 保存队列数据<br>\t<br>\t&#47;&#47; 初始化队列长度<br>\tpublic function __construct($capacity) {<br>\t\t$this-&gt;n=$capacity;<br>\t}<br>\t<br>\t&#47;&#47; 入队<br>\tpublic function enqueue($item) {<br>\t\t&#47;&#47; 队列满了<br>\t\tif(($this-&gt;tail + 1) % $this-&gt;n == $this-&gt;head ) {<br>\t\t\techo &quot;队列已满&lt;br&gt;&quot;;<br>\t\t\treturn false;<br>\t\t} else {<br>\t\t\t$this-&gt;items[$this-&gt;tail] = $item;<br>\t\t\t$this-&gt;tail = ($this-&gt;tail + 1) % $this-&gt;n;<br>\t\t\treturn true;<br>\t\t}<br>\t}<br>\t<br>\t&#47;&#47; 出队<br>\tpublic function dequeue() {<br>\t\tif ($this-&gt;head == $this-&gt;tail) {<br>\t\t\techo &quot;队列为空&lt;br&gt;&quot;;<br>\t\t\treturn null;<br>\t\t} else {<br>\t\t\t$ret =  $this-&gt;items[$this-&gt;head];<br>\t\t\t$this-&gt;head = ($this-&gt;head + 1) % $this-&gt;n;<br>\t\t\treturn $ret;<br>\t\t}<br>\t}<br>\t<br>}<br><br>$circularQueue = new CircularQueue(5);<br>$circularQueue-&gt;enqueue(1);<br>$circularQueue-&gt;enqueue(2);<br>$circularQueue-&gt;enqueue(3);<br>$circularQueue-&gt;enqueue(4);<br>$circularQueue-&gt;enqueue(5);<br>echo $circularQueue-&gt;dequeue();<br>echo &quot;&lt;br&gt;&quot;;<br>$circularQueue-&gt;enqueue(6);<br>echo $circularQueue-&gt;dequeue();<br>echo &quot;&lt;br&gt;&quot;;<br>echo $circularQueue-&gt;dequeue();<br>echo &quot;&lt;br&gt;&quot;;<br>echo $circularQueue-&gt;dequeue();<br>echo &quot;&lt;br&gt;&quot;;<br>echo $circularQueue-&gt;dequeue();<br>echo &quot;&lt;br&gt;&quot;;<br>echo $circularQueue-&gt;dequeue();<br>echo &quot;&lt;br&gt;&quot;;<br>echo $circularQueue-&gt;dequeue();<br>echo &quot;&lt;br&gt;&quot;;<br><br>","like_count":0},{"had_liked":false,"id":200588,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585621320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585621320","product_id":100017301,"comment_content":"1. redis的底层实现也是用队列才实现的。<br>2. 可以参考AQS的底层实现","like_count":0},{"had_liked":false,"id":200063,"user_name":"yezi","can_delete":false,"product_type":"c1","uid":1935780,"ip_address":"","ucode":"B2E5CC51D37C44","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AiaYGqeT5oDEUaRq2vVLOIesrnPwJH3VfN8tb3CZlAbxW9QYo6TfPqUS8c4ibAyibsn1955GK3EOJsjFFKXRbSYvA/132","comment_is_top":false,"comment_ctime":1585538831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585538831","product_id":100017301,"comment_content":"队列的应用很广，广度优先搜索","like_count":0},{"had_liked":false,"id":196423,"user_name":"雷小鸿","can_delete":false,"product_type":"c1","uid":1368897,"ip_address":"","ucode":"424DC9A532FFD7","user_header":"https://static001.geekbang.org/account/avatar/00/14/e3/41/bd0e3a04.jpg","comment_is_top":false,"comment_ctime":1585280361,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585280361","product_id":100017301,"comment_content":"循环满的表达式理解：如果不是循环那肯定tail跑到最后等于队列长度n就满了，但是循环当tail跑到n是能回去0的位置的就是循环再来一次。当这个0的位置上是head那就满了，但是你不能head=tail+1 那咋办嘛取余呀，就是head=（tail+1）%n","like_count":0},{"had_liked":false,"id":196164,"user_name":"Geek_55e386","can_delete":false,"product_type":"c1","uid":1795793,"ip_address":"","ucode":"5A727F1323C2D0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zxkns28cIAUZIt3WjDb8G26qiccT84d9GMr9ZpbYR60TU1ibqSj9NoYVHlJvGF1kOltkqNDmEfJCqPuYVkue3WHg/132","comment_is_top":false,"comment_ctime":1585240930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585240930","product_id":100017301,"comment_content":"只用了disrupter。知道是环形，cas，单线程。所以快。今天才算明白为啥环形就快了。<br>因为环形减少了空间不足的问题，空间一直可以重复使用","like_count":0},{"had_liked":false,"id":195912,"user_name":"隆隆","can_delete":false,"product_type":"c1","uid":1219087,"ip_address":"","ucode":"F34E9A81BFC2DF","user_header":"https://static001.geekbang.org/account/avatar/00/12/9a/0f/35ca8d44.jpg","comment_is_top":false,"comment_ctime":1585223733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585223733","product_id":100017301,"comment_content":"循环队列判断空满能否用当前元素总数量和数组长度比较？数组元素总数量为0，空队列，元素总数量和数组长度相等，队列满","like_count":0},{"had_liked":false,"id":194896,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1585117794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585117794","product_id":100017301,"comment_content":"1.消息队列，另外网游的排队等待系统也是这样的<br>2.无锁队列 用 cas  + 数组?","like_count":0},{"had_liked":false,"id":194523,"user_name":"进击的鱼儿","can_delete":false,"product_type":"c1","uid":1334770,"ip_address":"","ucode":"9B6CF26A8BCA8F","user_header":"https://static001.geekbang.org/account/avatar/00/14/5d/f2/785169e9.jpg","comment_is_top":false,"comment_ctime":1585064965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585064965","product_id":100017301,"comment_content":"循环队列可以使用head指针加一个count计数来实现，这样就不用浪费数组一个空间了","like_count":0},{"had_liked":false,"id":191178,"user_name":"雨落千木的时节","can_delete":false,"product_type":"c1","uid":1796430,"ip_address":"","ucode":"A268063299F0D6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/4e/7ef7604b.jpg","comment_is_top":false,"comment_ctime":1584752784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584752784","product_id":100017301,"comment_content":"大学里的数据结构课程上学过循环队列一直都看不懂tail 和head在队列满时的关系，学习了老师的课程后终于明白了","like_count":0},{"had_liked":false,"id":191174,"user_name":"雨落千木的时节","can_delete":false,"product_type":"c1","uid":1796430,"ip_address":"","ucode":"A268063299F0D6","user_header":"https://static001.geekbang.org/account/avatar/00/1b/69/4e/7ef7604b.jpg","comment_is_top":false,"comment_ctime":1584752584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584752584","product_id":100017301,"comment_content":"java中的线程池使用的也是队列，一般用blockingqueue,在队列满之后回有相应的丢弃策略","like_count":0},{"had_liked":false,"id":190802,"user_name":"汪明","can_delete":false,"product_type":"c1","uid":1185062,"ip_address":"","ucode":"0F53CBB8E0DFA8","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/26/6fd09625.jpg","comment_is_top":false,"comment_ctime":1584693286,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584693286","product_id":100017301,"comment_content":"绘图工具用的啥，挺好用的看上去，分享一下","like_count":0,"discussions":[{"author":{"id":1111683,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f6/83/ef27d86c.jpg","nickname":"Crazy","note":"","ucode":"C044527140CEC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219839,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585816194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190750,"user_name":"宋强","can_delete":false,"product_type":"c1","uid":1564605,"ip_address":"","ucode":"119A0B00ABDA7B","user_header":"","comment_is_top":false,"comment_ctime":1584689848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584689848","product_id":100017301,"comment_content":"ring 的实现里面，数组[n-1]这个位置的空间是不是没法用上。因为(tail+1) % n == head, return false.","like_count":0},{"had_liked":false,"id":190555,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1584668497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584668497","product_id":100017301,"comment_content":"打卡9","like_count":0},{"had_liked":false,"id":190205,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1584614221,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584614221","product_id":100017301,"comment_content":"来历：大家都给我好好排队<br><br>自身特点：先进者先出，这就是典型的“队列”<br><br>适合解决的问题：对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队<br><br>实际的应用场景：消费者-生产者模型，线程池，分布式消息队列kafaka","like_count":0},{"had_liked":false,"id":189726,"user_name":"wholly","can_delete":false,"product_type":"c1","uid":1089235,"ip_address":"","ucode":"3CB7D06CC6C670","user_header":"https://static001.geekbang.org/account/avatar/00/10/9e/d3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1584543104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584543104","product_id":100017301,"comment_content":"队列先进先出，中间件中大部分消息队列基本都是基于队列实现的，比如messagebroker，kafka等等；原子操作队列我觉得也叫免锁队列，可以提升处理性能。<br>重点掌握入队，出队的实现，针对应用场景较多的循环队列，阻塞队列，并发队列等，要在实践项目中多实践。","like_count":0},{"had_liked":false,"id":189170,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1584463044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584463044","product_id":100017301,"comment_content":"无锁编程，貌似有原子操作,cas,还有两个队列实现？","like_count":0},{"had_liked":false,"id":186822,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1583934197,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1583934197","product_id":100017301,"comment_content":"数据库连接池结构，也算是一张队列吧","like_count":0},{"had_liked":false,"id":186111,"user_name":"重新来过","can_delete":false,"product_type":"c1","uid":1254138,"ip_address":"","ucode":"27CC35140B63F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/22/fa/671d2937.jpg","comment_is_top":false,"comment_ctime":1583759466,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583759466","product_id":100017301,"comment_content":"“基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点“，老师，我查资料说tail指针指向队尾的下一个元素，和上面描述不同？ ","like_count":0},{"had_liked":false,"id":185973,"user_name":"谭方敏","can_delete":false,"product_type":"c1","uid":1710960,"ip_address":"","ucode":"728DC7ECB7C902","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1b/70/547042ee.jpg","comment_is_top":false,"comment_ctime":1583735237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583735237","product_id":100017301,"comment_content":"队列，一种受限的线性数据结构，只能进队和出队，原理是先进先出。<br>队列因实现方式的不同（原来栈的话只需要栈顶top指针，而队列则需要head和tail指针），可以分为顺序队列和链式队列，也有变种循环队列。<br>以及在多线程和并发环境下出现的阻塞队列(队列空了，阻塞，不能取；队列满了，阻塞，不能插入)和并发队列（线程安全）。<br><br>用到队列的还有消息队列，比如kafka，rabbitmq，或者rocketmq等。<br><br>并发队列用到的锁，也比较多，c++里面会用cas原子来控制，或者用条件变量等来协助达到无锁的效果。。。。","like_count":0},{"had_liked":false,"id":183905,"user_name":"4!!","can_delete":false,"product_type":"c1","uid":1487663,"ip_address":"","ucode":"188445590D97DF","user_header":"https://static001.geekbang.org/account/avatar/00/16/b3/2f/867b94d8.jpg","comment_is_top":false,"comment_ctime":1583159776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583159776","product_id":100017301,"comment_content":"chrome浏览器渲染进程中有个消息队列，也是队列结构；<br>保存了来自各方的任务，包括HTML解析、CSS解析、JavaScript 执行、交互事件、网络请求等；<br>页面循环系统会从消息队列按顺序取出任务执行。","like_count":0},{"had_liked":false,"id":183128,"user_name":"Eternal","can_delete":false,"product_type":"c1","uid":1188023,"ip_address":"","ucode":"EA6FE7CC98F740","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/b7/bdb3bcf0.jpg","comment_is_top":false,"comment_ctime":1582957468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582957468","product_id":100017301,"comment_content":"队列排队请求应用的场景：Java并发库中的线程池，MySql中的连接池；Java并发库中AQS锁中用队列实现公平锁；","like_count":0},{"had_liked":false,"id":178728,"user_name":"起而行","can_delete":false,"product_type":"c1","uid":1131399,"ip_address":"","ucode":"4F116B0B740776","user_header":"https://static001.geekbang.org/account/avatar/00/11/43/87/7604d7a4.jpg","comment_is_top":false,"comment_ctime":1581805634,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581805634","product_id":100017301,"comment_content":"1.在两个进程间异步传输数据，IO缓冲<br>2.消费者生产者例子，打印机中:打印文件和待打印的文件，电话呼叫中心:接电话和排队等电话的人<br>3.宽度优先搜索<br><br>第二个问题，利用CAS操作来实现","like_count":0},{"had_liked":false,"id":177765,"user_name":"一只独立特行的猪","can_delete":false,"product_type":"c1","uid":1473358,"ip_address":"","ucode":"52263607CCBE6F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/4e/73a9deec.jpg","comment_is_top":false,"comment_ctime":1581494460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581494460","product_id":100017301,"comment_content":"看过几次队列的代码，以前都是一知半解，一直都没有搞清楚tail指针，仔细研究了循环队列后，最后搞明白了。tail指针指向的地址是不存数据了，入队的时候，先把当前的额tail指针指向的地址写个数据，然后在样tail指针加1。","like_count":0},{"had_liked":false,"id":177497,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1581405475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581405475","product_id":100017301,"comment_content":"老师我查了一下, 循环队列主要是解决顺序队列&quot;假溢出&quot;的问题, 就是在tail到追到, 但是从0到head这段数据正常的逻辑来说是空的,这个时候数组其实没有满,但是已经达到满的条件了.循环队列可以有效解决这个问题, 请问这个说的对不对呀","like_count":0},{"had_liked":false,"id":177492,"user_name":"王jojo","can_delete":false,"product_type":"c1","uid":1812840,"ip_address":"","ucode":"1ABE7FA2614F86","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","comment_is_top":false,"comment_ctime":1581404163,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581404163","product_id":100017301,"comment_content":"看了循环队列的代码, 好像是队列满的情况直接跳过,那如果正常队列不考虑满的情况, 不也和循环队列一样了?请问老师有什么区别呀?","like_count":0},{"had_liked":false,"id":177182,"user_name":"ethan","can_delete":false,"product_type":"c1","uid":1443388,"ip_address":"","ucode":"CD95B810DB62C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/VY2Uy4zckWjtBYsddWlql5sjJM1W9sM91dz60qn1w1FyNCiaxUt8oI37Mdftz5y0hiaw6vVaUPtGY2Yfbgtlr53Q/132","comment_is_top":false,"comment_ctime":1581315991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581315991","product_id":100017301,"comment_content":"为什么循环队列是ail = (tail + 1) % n; tail不是一直小于n的吗，直接用tail = tail+1;不可以吗","like_count":0},{"had_liked":false,"id":175382,"user_name":"_关旭_","can_delete":false,"product_type":"c1","uid":1009052,"ip_address":"","ucode":"ADEB7BBC54035B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/9c/5c94692c.jpg","comment_is_top":false,"comment_ctime":1580700490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580700490","product_id":100017301,"comment_content":"请问循环队列的设计，为什么要浪费一个空间呢，想不明白","like_count":0},{"had_liked":false,"id":173028,"user_name":"柏拉图","can_delete":false,"product_type":"c1","uid":1135009,"ip_address":"","ucode":"8FC1C9F9F09223","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/a1/c7556bfc.jpg","comment_is_top":false,"comment_ctime":1579413060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579413060","product_id":100017301,"comment_content":"网络协议栈处理中也大量使用了队列数据结构","like_count":0},{"had_liked":false,"id":170888,"user_name":"板栗","can_delete":false,"product_type":"c1","uid":1239741,"ip_address":"","ucode":"35B8B2CB2E0214","user_header":"https://static001.geekbang.org/account/avatar/00/12/ea/bd/aba4b2c9.jpg","comment_is_top":false,"comment_ctime":1578750831,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578750831","product_id":100017301,"comment_content":"栈   | 先进后出,后进先出   入栈push() 出栈pop()<br>---- | -----------------------------------------<br>队列 | 先进先出,后进后出   入队enqueue() 出队dequeue()<br><br>顺序队列(数组) &#47;链式队列(链表)<br><br>基于数组的队列实现.<br>队列实现需要 head 和 tail 两个指针<br>出队时head+1  入队时tail+1<br>在内存中的位置会发生偏移 =&gt; 每次出队的时候进行数据搬移=&gt;在空间不足时候进行数据搬移 <br><br>在空间不足的时候 入队只有在队列满的时候 会触发时间复杂度为O(n)的搬移运算.均摊之后,时间复杂度仍可以看做O(1)<br><br>基于链表的队列实现方法<br>需要 head 和 tail 两个指针<br>入队时 tail-&gt;next=&gt;new_node,tail = tail-&gt;next  队尾元素的next 指向新节点,队尾指针(tail)指向新的节点<br>出队时 head = head-&gt;next  队首指针(head) 指向head的下一个节点<br><br>循环队列<br>确定好队空和队满的判定条件。<br><br>阻塞队列<br>阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。<br><br>并发队列<br>线程安全的队列我们叫作并发队列。","like_count":0},{"had_liked":false,"id":169315,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1578313763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578313763","product_id":100017301,"comment_content":"总结：<br>1、队列是先进先出的操作受限的线性表数据结构，具有enqueue()和dequeue()两个基本操作。<br>2、队列可以用链表和数组实现，数组实现的叫顺序队列，链表实现的叫链式队列。<br>3、一个队列需要两个指针head和tail。head指向队列中最早加入的元素，tail指向最晚加入元素的后一个位置（也就是下个入队的元素保存的位置）<br>4、入队时，如果队列不为满，将需要入队的元素存放在tail位置，tail向后移动一个位置。出队时，head向后移动一个位置。<br>5、对于普通顺序队列如果tail已经到达了数组的上限，但队列没有满，就将现有元素搬移至数组头部。该操作的均摊时间复杂度为O(1)。<br>6、为了避免数据搬移，可以采用循环队列的方式。循环队列中，每一次head向后移动的操作变为head=(head+1)%n，tail同理。循环队列判断队空的条件同普通顺序队列为head==tail，但判断队满的条件为(tail+1)%n==head。循环队列会浪费一个数组存储空间。<br>7、实际应用中，还有阻塞队列、并发队列等更高级的队列。","like_count":0},{"had_liked":false,"id":168772,"user_name":"ganyichao","can_delete":false,"product_type":"c1","uid":1636474,"ip_address":"","ucode":"E16E82E1256FF3","user_header":"","comment_is_top":false,"comment_ctime":1578154448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578154448","product_id":100017301,"comment_content":"不是很理解，为什么循环队列那一段代码head和tail为什么要做取余处理","like_count":0},{"had_liked":false,"id":168193,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1640973,"ip_address":"","ucode":"2C0D1D26853DB3","user_header":"https://static001.geekbang.org/account/avatar/00/19/0a/0d/7bac5bcb.jpg","comment_is_top":false,"comment_ctime":1578031288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578031288","product_id":100017301,"comment_content":"rabbitMQ","like_count":0},{"had_liked":false,"id":168191,"user_name":"瓜瓜","can_delete":false,"product_type":"c1","uid":1053853,"ip_address":"","ucode":"2E98377E48399E","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/9d/19dcdd42.jpg","comment_is_top":false,"comment_ctime":1578031071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578031071","product_id":100017301,"comment_content":"阻塞队列，感觉没说太清楚。<br>是指队列本身是阻塞的，然后把访问队列的请求放入另外一个队列了。<br>还是指访问一个有限资源的时候，我的请求是个阻塞队列，当发现资源不够的时候就在阻塞队列中等待。","like_count":0},{"had_liked":false,"id":168186,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1640973,"ip_address":"","ucode":"2C0D1D26853DB3","user_header":"https://static001.geekbang.org/account/avatar/00/19/0a/0d/7bac5bcb.jpg","comment_is_top":false,"comment_ctime":1578030484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578030484","product_id":100017301,"comment_content":"数组队列的代码，表示队列满的情况不应该是tail == n-1吗？n是数组的空间大小","like_count":0},{"had_liked":false,"id":160639,"user_name":"浑浑噩噩cium","can_delete":false,"product_type":"c1","uid":1617939,"ip_address":"","ucode":"358C0BCFF62B40","user_header":"https://static001.geekbang.org/account/avatar/00/18/b0/13/5cb3459c.jpg","comment_is_top":false,"comment_ctime":1575991193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575991193","product_id":100017301,"comment_content":"head = (head + 1) % n; 这个处理非常妙，保证了head在[0~n)之间;<br>我这边是利用无符号数据类型值范围，但是很局限性<br>template&lt;typename T&gt;<br>class myqueue2<br>{<br>public:<br>    myqueue2():que(nullptr),head(0),tail(0)<br>    {<br>        que=new T[256];   &#47;&#47;unsigned char 范围[0,255]<br>    }<br>    ~myqueue2()<br>    {<br>        delete [] que;<br>    }<br><br>    bool get(T&amp;t)<br>    {<br>        if(head==tail)<br>            return false;<br>        t=que[head];<br>        head++;<br>        return true;<br>    }<br><br>    bool put(T&amp;t)<br>    {<br>        if(tail+1==head)<br>            return false;<br>        que[tail]=t;<br>        tail++;    <br>        return true;<br>    }<br>private:<br>    T*que;<br>    unsigned char head;&#47;&#47;0~255<br>    unsigned char tail;<br>};","like_count":0},{"had_liked":false,"id":159702,"user_name":"茶没喝完","can_delete":false,"product_type":"c1","uid":1644104,"ip_address":"","ucode":"D72D88C42A1258","user_header":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","comment_is_top":false,"comment_ctime":1575732049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575732049","product_id":100017301,"comment_content":"感谢老师","like_count":0},{"had_liked":false,"id":159489,"user_name":"Rickieslove","can_delete":false,"product_type":"c1","uid":1751095,"ip_address":"","ucode":"47A1A53F2E1FAE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/37/d22456d5.jpg","comment_is_top":false,"comment_ctime":1575636301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575636301","product_id":100017301,"comment_content":"分别使用数组，链表实现了循环队列，又用链表yy了一个无限队列，感兴趣的同学可以看这里：https:&#47;&#47;github.com&#47;NightKing92&#47;Boy_next_door&#47;tree&#47;master&#47;src&#47;learn&#47;queue","like_count":0},{"had_liked":false,"id":159176,"user_name":"Allen_","can_delete":false,"product_type":"c1","uid":1677187,"ip_address":"","ucode":"CA5E00E4644CD5","user_header":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","comment_is_top":false,"comment_ctime":1575552531,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575552531","product_id":100017301,"comment_content":"循环队列不能用cap和len来决定吗？比如加一个变量是len，记录当前有多少个，判断时候就比较容易了。","like_count":0},{"had_liked":false,"id":159173,"user_name":"Ronnyz","can_delete":false,"product_type":"c1","uid":1488280,"ip_address":"","ucode":"9F34527B1D343D","user_header":"https://static001.geekbang.org/account/avatar/00/16/b5/98/ffaf2aca.jpg","comment_is_top":false,"comment_ctime":1575552074,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575552074","product_id":100017301,"comment_content":"利用CAS原子操作来实现无锁的数据结构","like_count":0},{"had_liked":false,"id":158922,"user_name":"技术修行者","can_delete":false,"product_type":"c1","uid":1013147,"ip_address":"","ucode":"28CA41A1214D6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/9b/611e74ab.jpg","comment_is_top":false,"comment_ctime":1575498218,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1575498218","product_id":100017301,"comment_content":"思维导图：https:&#47;&#47;mubu.com&#47;doc&#47;vVB1gYGYO0<br><br>CAS：Compare and Swap，可以用CAS的思想来实现无锁并发队列。","like_count":0},{"had_liked":false,"id":158843,"user_name":"日月焕星辰","can_delete":false,"product_type":"c1","uid":1644586,"ip_address":"","ucode":"E60D2188D73418","user_header":"https://static001.geekbang.org/account/avatar/00/19/18/2a/7a12c412.jpg","comment_is_top":false,"comment_ctime":1575463584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575463584","product_id":100017301,"comment_content":" class QueueList<br>    {<br>        public int[] a;<br>        public int n=0;<br><br>        public int head=0;<br>        public int tail=0;<br><br>        public QueueList()<br>        {<br><br>        }<br><br>        public QueueList(int n)<br>        {<br>            a = new int[n];<br>            this.n = n;<br>            head = 0;<br>            tail = 0;<br>        }<br><br>        public bool EnQueue(int value)<br>        {<br>            if (tail == n) return false;<br><br>            a[tail] = value;<br>            ++tail;<br>            return true;<br>        }<br><br>        public int DeQueue()<br>        {<br>            if (head == tail) return -1;<br><br>            int temp = a[head];<br>            ++head;<br>            return temp;<br>        }<br>    }<br><br>    class QueueLinkNode<br>    {<br>        public int data;<br>        public QueueLinkNode next;<br><br>        public QueueLinkNode() { }<br><br>        public QueueLinkNode(int data)<br>        {<br>            this.data = data;<br>            next = null;<br>        }<br>    }<br><br>    class QueueLink<br>    {<br>        public QueueLinkNode head;<br>        public QueueLinkNode tail;<br><br>        public QueueLink(QueueLinkNode head,QueueLinkNode tail)<br>        {<br>            this.head = head;<br>            this.tail = tail;<br>        }<br><br>        public bool EnQueue(int value)<br>        {<br><br>            QueueLinkNode q = new QueueLinkNode(value);<br>            if (tail == null)<br>                tail = q;<br>            else<br>            {<br>                tail.next = q;<br>                tail = q;<br>            }<br><br>            return true;<br>        }<br><br>        public int DeQueue()<br>        {<br>            if (head == tail) return -1;<br><br>            QueueLinkNode p = new QueueLinkNode();<br>            p = head;<br>            QueueLinkNode q = new QueueLinkNode();<br>            while (p.next != null)<br>            {<br>                q = p;<br>                p = p.next;<br>            }<br><br>            return q.data;<br>        }<br>    }","like_count":0},{"had_liked":false,"id":158831,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1575461021,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575461021","product_id":100017301,"comment_content":"（1）先进先出，只有两个基本的操作，入队和出队，和栈一样，也是一种操作受限的线性表数据结构。<br>\t<br>（2）队列作为一种非常基础的数据结构，应用的非常广泛，特别是具有特殊性的队列：如循环队列，阻塞队列，并发队列……在很多偏底层系统，框架，中间件的开发中，起着关键性作用，如高性能队列Disruptor,linux环形缓存，都用到了循环并发队列；Java concurrent并发包利用ArrayBlockingQueue来实现公平锁。<br>\t<br>（3）顺序队列和链式队列<br>\t1，和栈相同，队列用数组实现叫顺序队列，用链表实现叫链式队列。<br>\t2，和栈不同，栈只需要一个栈顶指针，但队列需要两个指针：一个head指针，指向对头；一个tail指针，指向队尾。<br>\t3，顺序队列：<br>\t\t当tail移动到最右边时，即使数组中还有空间性空间，也无法继续往队列中添加数据了。<br>\t\t数据搬移，在出队时不用做数据搬移，如果没有空间空间，只需在入队时，在集中触发一次数据的搬移操作。<br>\t<br>\t4，链表队列：<br>\t\t入队时：tail -&gt; next = new_node，tail = tail -&gt; next;<br>\t\t出队时：head = head -&gt; next<br>（4）循环队列<br>\t1，可以避免数据迁移，但实现要复杂些。关键在于确定好队列空和队列满的判定条件。<br>2，当队列满时：（tail+1）%n=head 成立，循环队列会浪费一个数组的存储空间。<br><br>（5）阻塞队列和并发队列<br>\t阻塞对列：在队列为空时，从队头取数据会被阻塞，直到队列中有了数据才能被返回。如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后在插入数据，然后再返回。<br><br>\t并发队列：是线程安全的队列，<br>（1）最简单直接的实现方式是直接在enqueue()，dequeue()方法上加锁，但锁粒度大并发度会比较低，同一时刻仅能一个存或取的操作。<br>（2）基于循环队列，利用CAS原子操作，可以实现非常高效的并发队列。<br>\t\t\t<br>","like_count":0},{"had_liked":false,"id":158198,"user_name":"春和景明","can_delete":false,"product_type":"c1","uid":1272482,"ip_address":"","ucode":"A27970A276ECD6","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/a2/f9efd9dc.jpg","comment_is_top":false,"comment_ctime":1575345838,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575345838","product_id":100017301,"comment_content":"老师， 当出队的时候，不需要把出队的元素从队列中删除吗？","like_count":0},{"had_liked":false,"id":158140,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1575337617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575337617","product_id":100017301,"comment_content":"1.消息处理采用队列<br>2.使用CAS实现无锁队列","like_count":0},{"had_liked":false,"id":158019,"user_name":"晨风破晓","can_delete":false,"product_type":"c1","uid":1321464,"ip_address":"","ucode":"F2BC46428A97B5","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/f8/561c5be1.jpg","comment_is_top":false,"comment_ctime":1575298378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575298378","product_id":100017301,"comment_content":"队列：是一种线性表数据结构，具有先进先出的特点，队头出队，队尾入队。同栈一样，数组实现的队列叫顺序队列，链表实现的叫链式队列。栈只有一个栈顶指针，而队列有头指针head和尾指针tail。<br>顺序队列：队满标识：tail = n，队空标识：head = tail，出队和入队的过程，指针都向后移，当tail 移到最末，队列即使为空也无法插入数据。解决方案：在入队时搬移数据，将head ～ tail 之间的数据搬移到 0 ～ tail - head之间。出队时间复杂度保持 O(1)<br>链式队列：入队：tail-&gt;next = new_node  tail = tail-&gt;next，出队：head = head-&gt;next<br>循环队列：能避免数据搬移，队满标识：head = tail，队空标识：(tail + 1)%n = head<br>阻塞队列：队列为空时从队头取数据会被阻塞，队列满时从队尾入队也会阻塞，典型应用场景：生产者-消费者模型<br>并发队列：多个线程同时操作一个队列，线程安全的队列。实现方法：最直接简单的就是enqueue和dequeue的方法加锁，循环队列可使用CAS原子操作。","like_count":0},{"had_liked":false,"id":157891,"user_name":"httvc","can_delete":false,"product_type":"c1","uid":1328883,"ip_address":"","ucode":"3E21CC740976B0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLeocOtQchqJhmQjrSLVvkIfGmhK1STust04THMVxWB0ibGMWOaKWJKnSgb6PbEHELXknGdEbHSkjQ/132","comment_is_top":false,"comment_ctime":1575277946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575277946","product_id":100017301,"comment_content":"王争老师，我看这节数据搬移哪里，代码 &#47;&#47; 搬移完之后重新更新head和tail      tail -= head;      head = 0;<br>这个我觉得tail还得在加1，不然他加入的时候会把最后一个数给覆盖了。","like_count":0},{"had_liked":false,"id":157564,"user_name":"克","can_delete":false,"product_type":"c1","uid":1069206,"ip_address":"","ucode":"6DDFBB05E0F4E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/50/96/18612c89.jpg","comment_is_top":false,"comment_ctime":1575195895,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575195895","product_id":100017301,"comment_content":"Java中对于多线程共享资源的竞争， 大名鼎鼎的AQS。<br>实现无锁队列：使用数组存储，使用CAS操作head和tail下标。性能至上，CPU缓存友好，无锁。","like_count":0},{"had_liked":false,"id":157493,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1575177325,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1575177325","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":157461,"user_name":"big智慧","can_delete":false,"product_type":"c1","uid":1202616,"ip_address":"","ucode":"272C32E19EAE1A","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/b8/2a4624c3.jpg","comment_is_top":false,"comment_ctime":1575169275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575169275","product_id":100017301,"comment_content":"打卡Day7：<br>1、日期：<br>* 2019年12月01日<br><br>2、是什么<br>* 队列是一种操作受限的线性表数据结构。支持入队和出队操作。<br>* 在有限资源下公平的做到先进先服务<br><br>3、什么场景可以用<br>* 阻塞队列：在队列为空时，出队的操作就会被阻塞，在队列满时，入队的操作就会被阻塞。在队列满时，根据场景需要可以选择拒绝任务请求或者将请求排队。 <br>* 并发队列：多线程操作队列时，线程安全的队列  <br>4、敏捷模式-看板方法中在制品数量限额WIP的思路 <br>* 根据开发人数确定最多可以同时处理5个任务，就在白板栏设定最大任务数的上限，在达到最大任务数后，等某个任务处理完成后在做“入队”操作。<br>* 如果发现某环节长期处于最大任务数，则可以考虑增加“消费者”，可以有效的发现并尝试解决瓶颈。  <br>5、关注点：<br>* 有限资源、阻塞","like_count":0},{"had_liked":false,"id":157418,"user_name":"刘丶小备","can_delete":false,"product_type":"c1","uid":1102106,"ip_address":"","ucode":"F4D5EF592B7030","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/1a/3564c9da.jpg","comment_is_top":false,"comment_ctime":1575155915,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575155915","product_id":100017301,"comment_content":"思考题：<br>1.数据库连接池，很多消息队列也会用到。<br>2.可以考虑使用CAS","like_count":0},{"had_liked":false,"id":157250,"user_name":"浅夏","can_delete":false,"product_type":"c1","uid":1417176,"ip_address":"","ucode":"8E1F54025C865A","user_header":"https://static001.geekbang.org/account/avatar/00/15/9f/d8/62030082.jpg","comment_is_top":false,"comment_ctime":1575097534,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575097534","product_id":100017301,"comment_content":"在线程池中使用无界队列，首先可能会导致过多的请求排队，请求处理的响应时间过长，使用不当还可能造成OOM","like_count":0},{"had_liked":false,"id":157212,"user_name":"浅夏","can_delete":false,"product_type":"c1","uid":1417176,"ip_address":"","ucode":"8E1F54025C865A","user_header":"https://static001.geekbang.org/account/avatar/00/15/9f/d8/62030082.jpg","comment_is_top":false,"comment_ctime":1575083295,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1575083295","product_id":100017301,"comment_content":"请教一下，实际工作中，双端队列的应用场景是啥样子的","like_count":0},{"had_liked":false,"id":157081,"user_name":"Swing","can_delete":false,"product_type":"c1","uid":1330065,"ip_address":"","ucode":"55FCA9ECEFBBEB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","comment_is_top":false,"comment_ctime":1575026797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575026797","product_id":100017301,"comment_content":"Android中的 MsgQueue 机制，最典型的 阻塞式队列了","like_count":0},{"had_liked":false,"id":157068,"user_name":"秀秀","can_delete":false,"product_type":"c1","uid":1145162,"ip_address":"","ucode":"9D4D327324570B","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/4a/10348395.jpg","comment_is_top":false,"comment_ctime":1575023887,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575023887","product_id":100017301,"comment_content":"用数组实现的队列代码中enqueue  是不是应该判断 tail == n-1<br>```<br>&#47;&#47; 入队 public boolean enqueue(String item) { &#47;&#47; 如果tail == n 表示队列已经满了 if (tail == n-1) return false; items[tail] = item; ++tail; return true; }<br>```","like_count":0},{"had_liked":false,"id":156853,"user_name":"大海","can_delete":false,"product_type":"c1","uid":1001446,"ip_address":"","ucode":"20913D0265971B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/e6/67b0b711.jpg","comment_is_top":false,"comment_ctime":1574988476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574988476","product_id":100017301,"comment_content":"Web应用中，接口并发有限时，需要使用队列进行处理。","like_count":0},{"had_liked":false,"id":154667,"user_name":"着迷","can_delete":false,"product_type":"c1","uid":1716801,"ip_address":"","ucode":"429F1D4015A195","user_header":"https://static001.geekbang.org/account/avatar/00/1a/32/41/c1a7840b.jpg","comment_is_top":false,"comment_ctime":1574504536,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574504536","product_id":100017301,"comment_content":"今天主要学习了基本队列的实现和高级队列的概念：<br>1、基本队列的实现可以用数组和链表的方式实现：<br>（1）使用数组实现的环形队列在入队时不需要移动数组元素，但是有长度限制，适合用在对响应时间敏感的场景，其中环形队列实现需要注意出队时队列为空、入队时，队列满的情况。<br>（2）使用链表实现的队列长度上没有限制，适合用在可以长时间排队的场景中。<br>2、高级队列<br>（1）阻塞队列，在入队时，如果队满，在出队时，如果队空，主线会一直等待<br>（2）并发队列，线程安全的队列，高并发使用场景","like_count":0},{"had_liked":false,"id":154457,"user_name":"编程界的小学生","can_delete":false,"product_type":"c1","uid":1593289,"ip_address":"","ucode":"4A5BE9A5E877FA","user_header":"https://static001.geekbang.org/account/avatar/00/18/4f/c9/9f51fd27.jpg","comment_is_top":false,"comment_ctime":1574434550,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574434550","product_id":100017301,"comment_content":"1.mq肯定用了，redis的blpop操作底层是不是也是线程安全的阻塞队列呢？<br>2.cas，并发高的情况下一定比synchronized效率高。","like_count":0},{"had_liked":false,"id":153271,"user_name":"Pikaman","can_delete":false,"product_type":"c1","uid":1234463,"ip_address":"","ucode":"2CBB15B2979A8F","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/1f/a927583c.jpg","comment_is_top":false,"comment_ctime":1574210105,"is_pvip":false,"replies":[{"id":"59143","content":"为啥呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1574334223,"ip_address":"","comment_id":153271,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574210105","product_id":100017301,"comment_content":"循环对列队满条件 (tail+1)%n=head 有误吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475105,"discussion_content":"为啥呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574334223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151350,"user_name":"握不住手中沙","can_delete":false,"product_type":"c1","uid":1097132,"ip_address":"","ucode":"F194E47C4D42C9","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/ac/49494ed8.jpg","comment_is_top":false,"comment_ctime":1573703921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573703921","product_id":100017301,"comment_content":"思考题：<br>1、用到队列的情况包括线程池，数据库连接池这种资源稀缺但是请求量的情况，还有就是现在经常用的消息队列，使用生产者和消费者的模式，生成者将数据放入队列，消费者根据情况对数据进行消费<br>2、无锁实现队列可考虑采用CAS的方式，在数据插入前先获取tail的位置，在插入时判断tail的位置是否为前一次取得的位置，如果相等则进行入队，否则不能入队；出队的时候判断读取head的位置是否为当前队列head的位置，如果相等说明队列未进行过出队操作，此时可执行出队，否则不可执行出队","like_count":0},{"had_liked":false,"id":147134,"user_name":"黄振宇","can_delete":false,"product_type":"c1","uid":1686397,"ip_address":"","ucode":"976BC7B46DA419","user_header":"https://static001.geekbang.org/account/avatar/00/19/bb/7d/26340713.jpg","comment_is_top":false,"comment_ctime":1572823407,"is_pvip":false,"replies":[{"id":"57069","content":"阻塞队列的意思是：一个线程可以等着这个队列有数据，一有数据就消费。业务含义比单纯的队列更丰富些。当然，底层还是会用到你说的基础的数据结构：队列。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572949092,"ip_address":"","comment_id":147134,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572823407","product_id":100017301,"comment_content":"老师，阻塞队列不就是一个普通的类似基于数组实现的队列吗？当队列中为空时，无法取数据。当队列满的时候也无法插入了，因为事先知道数组的大小啦啊。所以当满了的时候也无法插入。这不就是阻塞队列吗？好像和普通的队列没啥区别啊？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473162,"discussion_content":"阻塞队列的意思是：一个线程可以等着这个队列有数据，一有数据就消费。业务含义比单纯的队列更丰富些。当然，底层还是会用到你说的基础的数据结构：队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572949092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146610,"user_name":"Geek_cd1ae5","can_delete":false,"product_type":"c1","uid":1686659,"ip_address":"","ucode":"FC04584868CE1A","user_header":"https://static001.geekbang.org/account/avatar/00/19/bc/83/b2f62092.jpg","comment_is_top":false,"comment_ctime":1572582143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572582143","product_id":100017301,"comment_content":"出队操作的时间复杂度仍然是 O(1)，但入队操作的时间复杂度还是 O(1) 吗？你可以用我们第 3 节、第 4 节讲的算法复杂度分析方法，自己试着分析一下。<br><br>我感觉是O(n) ，但均摊是O(1)。不知道对不对","like_count":0},{"had_liked":false,"id":144456,"user_name":"wend","can_delete":false,"product_type":"c1","uid":1014096,"ip_address":"","ucode":"45EE220931FE91","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJyzUm3M4HMj0wXv8Pr34OhOiaFJjFMSjVKnaJoOWR9Uo1T4RBI4MYtguolJgOwb6eKsAUOq4MGlrw/132","comment_is_top":false,"comment_ctime":1571927349,"is_pvip":false,"replies":[{"id":"55981","content":"是的，很多都是用cas来实现的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572230305,"ip_address":"","comment_id":144456,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571927349","product_id":100017301,"comment_content":"使用队列的场景很多，网络请求框架，Android的handler机制，下载管理器。<br><br>无锁并发了解不多，也是利用CAS实现？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471948,"discussion_content":"是的，很多都是用cas来实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572230305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143941,"user_name":"无名","can_delete":false,"product_type":"c1","uid":1110113,"ip_address":"","ucode":"2D2E877CF97138","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/61/68462a07.jpg","comment_is_top":false,"comment_ctime":1571811110,"is_pvip":false,"replies":[{"id":"55990","content":"看着没错啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572230830,"ip_address":"","comment_id":143941,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571811110","product_id":100017301,"comment_content":"判断队满：(tail+1)%capacity==head<br><br>当capacity=1时，是错误的。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471753,"discussion_content":"看着没错啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572230830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143655,"user_name":"高坤","can_delete":false,"product_type":"c1","uid":1689197,"ip_address":"","ucode":"9BCD93629F7B76","user_header":"https://static001.geekbang.org/account/avatar/00/19/c6/6d/65ec48f1.jpg","comment_is_top":false,"comment_ctime":1571752612,"is_pvip":false,"replies":[{"id":"55991","content":"https:&#47;&#47;github.com&#47;wangzheng0822","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572230872,"ip_address":"","comment_id":143655,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571752612","product_id":100017301,"comment_content":"请问下老师的github地址是多少？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471636,"discussion_content":"https://github.com/wangzheng0822","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572230872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142719,"user_name":"世界","can_delete":false,"product_type":"c1","uid":1042147,"ip_address":"","ucode":"F3144DADADDE9B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e6/e3/dcbb9f87.jpg","comment_is_top":false,"comment_ctime":1571476122,"is_pvip":false,"replies":[{"id":"55218","content":"不 是n 你再看下文章","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571618219,"ip_address":"","comment_id":142719,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571476122","product_id":100017301,"comment_content":"[我们刚才用数组来实现队列的时候，在 tail==n 时]<br>应该是tail==n-1 ？n表示数组大小<br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471243,"discussion_content":"不 是n 你再看下文章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571618219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142032,"user_name":"向科","can_delete":false,"product_type":"c1","uid":1294797,"ip_address":"","ucode":"6EFC2C4FB11A24","user_header":"https://static001.geekbang.org/account/avatar/00/13/c1/cd/cdb510ae.jpg","comment_is_top":false,"comment_ctime":1571281179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571281179","product_id":100017301,"comment_content":"8086CPU 6字节的指令队列，也是一种队列结构","like_count":0},{"had_liked":false,"id":142026,"user_name":"向科","can_delete":false,"product_type":"c1","uid":1294797,"ip_address":"","ucode":"6EFC2C4FB11A24","user_header":"https://static001.geekbang.org/account/avatar/00/13/c1/cd/cdb510ae.jpg","comment_is_top":false,"comment_ctime":1571280185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571280185","product_id":100017301,"comment_content":"DHCP IP地址，像是一种队列结构","like_count":0},{"had_liked":false,"id":140766,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1571045318,"is_pvip":false,"replies":[{"id":"54526","content":"没错的。不过看队列是怎么实现的了，你说的这个方式是用最简单的数组来实现的吧。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571094162,"ip_address":"","comment_id":140766,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571045318","product_id":100017301,"comment_content":"时间复杂度分析那个：我的思考是，如果入队的速度远大于出队，则说明队列总是在不够用的边缘徘徊，会频繁的数据搬移，时间复杂度是O（n）。相反，则说明队列大部分情况下比较空，则搬移次数占比很少，时间复杂度为O（1）。不知理解是否有误？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470546,"discussion_content":"没错的。不过看队列是怎么实现的了，你说的这个方式是用最简单的数组来实现的吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571094162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140757,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571043691,"is_pvip":false,"replies":[{"id":"54520","content":"😁，你可以看看java并发包的源码吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1571093903,"ip_address":"","comment_id":140757,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571043691","product_id":100017301,"comment_content":"并发队列的实现原理是加锁，阻塞队列的底层实现原理是如何实现的呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470541,"discussion_content":"😁，你可以看看java并发包的源码吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571093903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140724,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1571038190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571038190","product_id":100017301,"comment_content":"队列有一个写指针，有一个读指针，两者配合实现先进先出的需求。用链表实现较为简便，如果用数组实现，不断的读和写之后，读写直接的区间就会平移，会造成空间的浪费，要修正空间浪费，就要平移元素，代价高昂。这个时候，循环队列应运而生，既保证了空间的有效利用，又避免了链表的指针，是固定大小队列的最佳选择。<br>阻塞队列是在队列为空的时候加入读的阻塞操作，让队列自动响应消费者，可以配置多个消费者和一个生产者来让生产者和消费者配合。","like_count":0},{"had_liked":false,"id":138206,"user_name":"Lance","can_delete":false,"product_type":"c1","uid":1686840,"ip_address":"","ucode":"CCE52F86EEBBED","user_header":"https://static001.geekbang.org/account/avatar/00/19/bd/38/6d436088.jpg","comment_is_top":false,"comment_ctime":1570093212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570093212","product_id":100017301,"comment_content":"队列(先进先出)，用数组实现的队列叫做顺序队列，用单向链表实现的队列叫做链式队列。<br>数组实现的队列会有容量限制，当队列满了需要进行数据搬移操作，针对该问题可以通过循环队列的方式解决，但是循环队列会浪费数组一个存储空间。<br><br>循环队列最关键是需要确定好队列为空以及队列满的判定条件 <br>队满：(tail+1)%n==head <br>队空：tail==head<br><br>队列的应用场景：阻塞队列(生产者-消费者模型)，并发队列(基于数组的循环队列，利用CAS原子操作可以实现高效的并发队列)<br><br>对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过&quot;队列&quot;这种数据结构来实现请求排队。","like_count":0},{"had_liked":false,"id":138085,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1570016757,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570016757","product_id":100017301,"comment_content":"无锁队列，在并发冲突大的情况下。是不是不太好效果。cas需要重试很多次","like_count":0},{"had_liked":false,"id":137906,"user_name":"姜川","can_delete":false,"product_type":"c1","uid":1684311,"ip_address":"","ucode":"0F8A349623EAB5","user_header":"https://static001.geekbang.org/account/avatar/00/19/b3/57/2d92cf9a.jpg","comment_is_top":false,"comment_ctime":1569913420,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569913420","product_id":100017301,"comment_content":"看了队列后，翻阅Java中Queue，发现其含有LinkedQueue、ArrayQueue，分别用链表和数组实现的","like_count":0},{"had_liked":false,"id":137067,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1569588940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569588940","product_id":100017301,"comment_content":"『在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。』这个数据搬移的问题只存在于顺序队列吧，如果是链式队列，不存在数据搬移问题呀。即便不是循环队列。","like_count":0},{"had_liked":false,"id":135223,"user_name":"Tom.G","can_delete":false,"product_type":"c1","uid":1206034,"ip_address":"","ucode":"7929B45C1A51F8","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/12/5c6eb568.jpg","comment_is_top":false,"comment_ctime":1569070385,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569070385","product_id":100017301,"comment_content":"环形队列，最后一个避免浪费存储空间<br>public class MyCircularQueue {<br><br>\tprivate int[] circularQueue;<br>\tprivate int head = 0;<br>\tprivate int tail = 0;<br><br>\tprivate int size = 0;<br><br>\t&#47;** Initialize your data structure here. Set the size of the queue to be k. *&#47;<br>\tpublic MyCircularQueue(int k) {<br>\t\tcircularQueue = new int[k];<br><br>\t\tfor (int i = 0; i &lt; k; i++) {<br>\t\t\tcircularQueue[i] = -1;<br>\t\t}<br>\t}<br><br>\t&#47;**<br>\t * Insert an element into the circular queue. Return true if the operation is<br>\t * successful.<br>\t *&#47;<br>\tpublic boolean enQueue(int value) {<br>\t\tif (size == circularQueue.length) {<br>\t\t\treturn false;<br>\t\t}<br><br>\t\tcircularQueue[tail] = value;<br>\t\ttail = (tail + 1) % circularQueue.length;<br>\t\tsize++;<br><br>\t\treturn true;<br>\t}<br><br>\t&#47;**<br>\t * Delete an element from the circular queue. Return true if the operation is<br>\t * successful.<br>\t *&#47;<br>\tpublic boolean deQueue() {<br>\t\tif (size == 0) {<br>\t\t\treturn false;<br>\t\t}<br><br>\t\tcircularQueue[head] = -1;<br>\t\thead = (head + 1) % circularQueue.length;<br>\t\tsize--;<br><br>\t\treturn true;<br>\t}<br><br>\t&#47;** Get the front item from the queue. *&#47;<br>\tpublic int Front() {<br>\t\treturn circularQueue[head];<br>\t}<br><br>\t&#47;** Get the last item from the queue. *&#47;<br>\tpublic int Rear() {<br>\t\treturn circularQueue[(tail - 1 + circularQueue.length) % circularQueue.length];<br>\t}<br><br>\t&#47;** Checks whether the circular queue is empty or not. *&#47;<br>\tpublic boolean isEmpty() {<br>\t\treturn size == 0;<br>\t}<br><br>\t&#47;** Checks whether the circular queue is full or not. *&#47;<br>\tpublic boolean isFull() {<br>\t\treturn size == circularQueue.length;<br>\t}<br>}<br>","like_count":0},{"had_liked":false,"id":134205,"user_name":"David","can_delete":false,"product_type":"c1","uid":1023472,"ip_address":"","ucode":"1C76747719CD3B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/f0/6c34b90f.jpg","comment_is_top":false,"comment_ctime":1568774820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568774820","product_id":100017301,"comment_content":"1.数据库连接池。消费者处理能力有限的情况下需要排队处理的场景，消费处理需要保证顺序的处理场景。<br>2.无锁通过CAS实现","like_count":0},{"had_liked":false,"id":132520,"user_name":"胡永","can_delete":false,"product_type":"c1","uid":1200543,"ip_address":"","ucode":"6C8BA1E0BED9C0","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/9f/1840385e.jpg","comment_is_top":false,"comment_ctime":1568160832,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568160832","product_id":100017301,"comment_content":"今天学到的是队列的概念：先进先出，数组实现是顺序队列，链表实现的是链式队列，还有循环队列，阻塞队列等，看大家的回复我就放心了，小白还是要多看几遍，多多练习了，回顾了下忘记了并发队列，第一遍就先把整体概念过一遍，总结出概念体系，然后第二遍再自己手动写代码，不知道我这种方法好还是放慢看的速度，每次课程的代码都实现一遍好。","like_count":0},{"had_liked":false,"id":132067,"user_name":"廖成林","can_delete":false,"product_type":"c1","uid":1358798,"ip_address":"","ucode":"CCBC3DED9EBF2A","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/ce/951a0751.jpg","comment_is_top":false,"comment_ctime":1568018108,"is_pvip":false,"replies":[{"id":"50975","content":"ipad paper","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568410998,"ip_address":"","comment_id":132067,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568018108","product_id":100017301,"comment_content":"老师 你好，想问下画图工具是什么","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466744,"discussion_content":"ipad paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568410998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1358798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bb/ce/951a0751.jpg","nickname":"廖成林","note":"","ucode":"CCBC3DED9EBF2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109820,"discussion_content":"多谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577712386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130231,"user_name":"海贼王","can_delete":false,"product_type":"c1","uid":1239233,"ip_address":"","ucode":"9F35793FAA3F5E","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/c1/e2cc1d04.jpg","comment_is_top":false,"comment_ctime":1567409663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567409663","product_id":100017301,"comment_content":"文中提出出队的操作时间复杂度仍为O(1)，分析剋采用链表一节中的摊还分析法，针对某一次复杂的操作平均分摊到其他正常的操作中，相当于每次入队一个数据，都要移动一个数据，所以时间复杂度依旧是O(1)","like_count":0},{"had_liked":false,"id":124434,"user_name":"六一","can_delete":false,"product_type":"c1","uid":1302721,"ip_address":"","ucode":"3EA05EABBA9138","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/c1/50acf7f5.jpg","comment_is_top":false,"comment_ctime":1565882603,"is_pvip":false,"replies":[{"id":"47252","content":"你可以先对tail进行cas，然后拿到这样空位票，假设下标是x，然后再add到x位置，这样就没人跟你强了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566775198,"ip_address":"","comment_id":124434,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565882603","product_id":100017301,"comment_content":"老师，有个问题求解答一下，最后一个思考题，利用CAS和数组实现并发队列，比方是入队操作，虽然可以利用CAS更新tail，但是在这之前有一个数组的add操作，更新tail是原子操作，但是add操作+tail更新并不是原子操作啊，我觉得始终会有多线程问题，求解😊","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463173,"discussion_content":"你可以先对tail进行cas，然后拿到这样空位票，假设下标是x，然后再add到x位置，这样就没人跟你强了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566775198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123425,"user_name":"auko","can_delete":false,"product_type":"c1","uid":1516010,"ip_address":"","ucode":"7E3AA25B2D250F","user_header":"https://static001.geekbang.org/account/avatar/00/17/21/ea/2cfb9144.jpg","comment_is_top":false,"comment_ctime":1565674218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565674218","product_id":100017301,"comment_content":"if(tail = head &amp;&amp; item[head+1]！= null)<br>作为循环队列队满的判断可行吗<br><br>正常的入队出队也不会多后面那一次运算","like_count":0},{"had_liked":false,"id":123370,"user_name":"走马","can_delete":false,"product_type":"c1","uid":1251016,"ip_address":"","ucode":"EEFE8F7590FFA4","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/c8/980776fc.jpg","comment_is_top":false,"comment_ctime":1565662749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565662749","product_id":100017301,"comment_content":"public static class CircleQueue<br>    {<br>        private int head;<br>        private int tail;<br>        private int[] dt;<br><br>        public CircleQueue(int len)<br>        {<br>            dt=new int[len];<br>            tail=head=0;<br>        }<br><br>        public boolean enqueue(int value)<br>        {<br>            if(tail==dt.length)<br>                tail=0;<br>            if(tail==head)<br>                return false;<br>            dt[tail++]=value;<br>            return true;<br>        }<br><br>        public int dequeue()<br>        {<br>            if(head==dt.length)<br>                head=0;<br>            if(head==tail)<br>                return -1;<br>            return dt[head++];<br>        }<br>    }","like_count":0},{"had_liked":false,"id":122078,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1565280269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565280269","product_id":100017301,"comment_content":"1、Android 的消息队列有用到队列；<br>2、使用 CAS 加失败重试，CAS 会传入三个值。第一个值是要修改的变量，第二个值是期望的值，第三个值是要修改的值。<br>    入队的时候，判断下 hail 是否是期望的值，不是的话，CAS 失败，那么重新读取 hail，再次判断；<br>    出队也是一样的操作；","like_count":0},{"had_liked":false,"id":121442,"user_name":"城南花未开","can_delete":false,"product_type":"c1","uid":1192121,"ip_address":"","ucode":"B66F354F41D095","user_header":"https://static001.geekbang.org/account/avatar/00/12/30/b9/0002529a.jpg","comment_is_top":false,"comment_ctime":1565140455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565140455","product_id":100017301,"comment_content":"循环队列的代码。比如，初始化大小为5，实际输出的结果只有4：<br>  CircularQueue circularQueue = new CircularQueue(5);<br><br>        circularQueue.enqueue(&quot;1&quot;);<br>        circularQueue.enqueue(&quot;2&quot;);<br>        circularQueue.enqueue(&quot;3&quot;);<br>        circularQueue.enqueue(&quot;4&quot;);<br>        circularQueue.enqueue(&quot;5&quot;);<br>circularQueue.printAll();<br>解决的方式是：<br> public CircularQueue(int capacity) {<br>        items = new String[capacity];<br>        n = capacity + 1;<br>    }","like_count":0},{"had_liked":false,"id":121233,"user_name":"Ares","can_delete":false,"product_type":"c1","uid":1323178,"ip_address":"","ucode":"290D252FABCB1D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEL2wE4k0RxhvTOFu179WngoHIOQvIyoltqZlA1MHMlv7ALDWKyx4dOOLc9zcMuzdRbIAiahvcSQ0aA/132","comment_is_top":false,"comment_ctime":1565081919,"is_pvip":false,"replies":[{"id":"44737","content":"你可以再看下文章，就是要浪费一个存储位置的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565219899,"ip_address":"","comment_id":121233,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1565081919","product_id":100017301,"comment_content":"Circlequeue的入队方法似乎有问题，假如创建一个5位容量的队列，放tail计算到4的时候，其实刚好是最后队列最后一个直，但是判断里用(tail+1）%n提前就把能入队的return false 导致最末的直入队不了了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461693,"discussion_content":"你可以再看下文章，就是要浪费一个存储位置的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565219899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1323178,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEL2wE4k0RxhvTOFu179WngoHIOQvIyoltqZlA1MHMlv7ALDWKyx4dOOLc9zcMuzdRbIAiahvcSQ0aA/132","nickname":"Ares","note":"","ucode":"290D252FABCB1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4147,"discussion_content":"修改如下\nclass CircularQueue {\n\tprivate String[] items;\n\tprivate int n;\n\tprivate int tail = 0;\n\tprivate int head = 0;\n\n\tpublic CircularQueue(int capacity) {\n\t\titems = new String[capacity];\n\t\tn = capacity;\n\t}\n\n\tpublic boolean enqueue(String item) {\n\t\tif ( (tail + 1) % n == head ) { \n\t\t\tif (items[tail] == null) {\n\t\t\t\titems[tail] = item;\n\t\t\t}\n\t\t\tif ((tail+1) == n)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn false; \n\t\t}\n\n\t\tif (items[tail] != null) {\n\t\t\ttail = (tail + 1) % n;\n\t\t}\n\n\t\titems[tail] = item;\n\t\ttail = (tail + 1) % n;\n\t\treturn true;\n\t}\n\n\tpublic String dequeue() {\n\t\tif (head == tail) return null;\n\t\tString ret = items[head];\n\t\titems[head] = null;\n\t\thead = (head + 1) % n;\n\t\tif ((tail + 1) == n)\n\t\t{\n\t\t\ttail = (tail + 1) % n;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic String getItem(int i) {\n\t\treturn items[(head + i) % n];\t\n\t}\n\n\tpublic void getItems() {\n\t\tfor(String i : items) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n\n\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565167038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116878,"user_name":"RuiClear","can_delete":false,"product_type":"c1","uid":1513951,"ip_address":"","ucode":"D67461C5053A03","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er5GnyD0t2QibS8P4flibTY49Zj5ww9vngGeicvqscc3Fsf8ibrvGMPZfCgjiaYH15Iib1xibNVia039clg3A/132","comment_is_top":false,"comment_ctime":1563933627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563933627","product_id":100017301,"comment_content":"循环队列不浪费一个空间的实现，不知道对不对，望各位大佬和老师指正<br><br>public class CircularQueue {<br>    private int head=0;<br>    private int tail=0;<br>    &#47;&#47;总大小<br>    private int size =10;<br>    &#47;&#47;当前队列总元素<br>    private int count = 0;<br>    private String[] queue = new String[size];<br><br><br><br>    public void put(String s){<br>        if(count == size){<br>            System.out.println(&quot;queue已满&quot;);<br>            return;<br>        }<br>        System.out.println(s);<br>        queue[tail] = s;<br>        tail = (tail+1)%size;<br>        count++;<br>    }<br><br>    public String pop(){<br>        if(count == 0){<br>            System.out.println(&quot;queue为空&quot;);<br>            return null;<br>        }<br>        String s = queue[head];<br>        head = (head+1)%size;<br>        count--;<br>        return s;<br>    }<br>}","like_count":0},{"had_liked":false,"id":115549,"user_name":"拾柒","can_delete":false,"product_type":"c1","uid":1601018,"ip_address":"","ucode":"A9C4A076943D36","user_header":"https://static001.geekbang.org/account/avatar/00/18/6d/fa/1ada7ac2.jpg","comment_is_top":false,"comment_ctime":1563618805,"is_pvip":false,"replies":[{"id":"42292","content":"不是的，你可以看看留言里的其他讨论，有提到。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563746278,"ip_address":"","comment_id":115549,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563618805","product_id":100017301,"comment_content":"老师，我个问题请教一下，tail必须指向一个元素为空的位置吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459155,"discussion_content":"不是的，你可以看看留言里的其他讨论，有提到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563746278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115383,"user_name":"一笔一画","can_delete":false,"product_type":"c1","uid":1495254,"ip_address":"","ucode":"2B9BC8ADF97106","user_header":"https://static001.geekbang.org/account/avatar/00/16/d0/d6/f335954b.jpg","comment_is_top":false,"comment_ctime":1563548735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563548735","product_id":100017301,"comment_content":"排队就是为了保序","like_count":0},{"had_liked":false,"id":115243,"user_name":"🐒🐱🐭🐮🐯🐰🐶","can_delete":false,"product_type":"c1","uid":1189080,"ip_address":"","ucode":"52426AE36A9A39","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/d8/aa41d743.jpg","comment_is_top":false,"comment_ctime":1563517164,"is_pvip":false,"replies":[{"id":"42204","content":"你具体指文章里的哪一步分内容呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563575379,"ip_address":"","comment_id":115243,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563517164","product_id":100017301,"comment_content":"老师 为什么tail 指向空 为什么不是最后一个数据（如果数组中有数据），","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459024,"discussion_content":"你具体指文章里的哪一步分内容呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563575379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115023,"user_name":"tong467","can_delete":false,"product_type":"c1","uid":1560667,"ip_address":"","ucode":"544F6FB2C5A936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJjw7KXibCGnibOm3O73xCGyCzdmgKuc017X8IQZCdNvAWxoWxHSgMTLgd7rGs1LCBPaU5oHbO16F0A/132","comment_is_top":false,"comment_ctime":1563456097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563456097","product_id":100017301,"comment_content":"class ArrayQueue {<br><br>    private int length;<br>    private Object[] array;<br><br>    private int head;<br>    private int size;<br><br><br>    public ArrayQueue(int length) {<br>        this.length = length;<br>        array = new Object[length];<br>    }<br><br>    public synchronized boolean enqueue(Object obj) {<br>        if (size == length) {<br>            System.out.println(&quot;队列已满&quot;);<br>            return false;<br>        }<br>        System.out.println(obj + &quot;被写入队列&quot;);<br>        int current = head + size &gt; length - 1 ? head + size - length : head + size;<br>        array[current] = obj;<br>        size++;<br>        return true;<br>    }<br><br>    public synchronized Object dequeue() {<br>        Object result = null;<br>        if (size != 0) {<br>            size--;<br>            if (head == length - 1) {<br>                head = 0;<br>                result = array[length - 1];<br>            } else {<br>                result = array[head++];<br>            }<br>        }<br>        System.out.println(result + &quot;被取出队列&quot;);<br>        return result;<br>    }<br>}<br>我是采用记录头节点和队列里面数据长度来使用循环队列的，不需要多余的空间，我也不知道对不，麻烦老师指点下。","like_count":0},{"had_liked":false,"id":114606,"user_name":"之城","can_delete":false,"product_type":"c1","uid":1252519,"ip_address":"","ucode":"12451253E366A2","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/a7/6a837523.jpg","comment_is_top":false,"comment_ctime":1563348617,"is_pvip":false,"replies":[{"id":"42197","content":"是的，我文章中的判定方式是这样子的。 ","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563573852,"ip_address":"","comment_id":114606,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563348617","product_id":100017301,"comment_content":"循环队列的大小为 8，按照老师的说法：(tail+1)%n=head时队满。也就是满的时候只能放7个咯？必须有一个时空着的对吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458745,"discussion_content":"是的，我文章中的判定方式是这样子的。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563573852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114534,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1563330324,"is_pvip":false,"replies":[{"id":"42196","content":"好像不行。因为即便是空了，内存中存储的也不一定是null","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563573827,"ip_address":"","comment_id":114534,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563330324","product_id":100017301,"comment_content":"对于循环队列会浪费一个存储点的问题，出了增加flag记录当前数据个数，我还想到可否用tail==head &amp;&amp; queue[(tail+1)%n]==null来判空？即首位碰头时队列中tail的下一个节点是否还有数据，如果有，说明队满，如果没有说明队空。思路和flag那个一样，只不过把事先存储变成了实时计算。人在地铁上，到公司验证下再来回复。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458709,"discussion_content":"好像不行。因为即便是空了，内存中存储的也不一定是null","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563573827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113408,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1562999439,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562999439","product_id":100017301,"comment_content":"算法_009# 作业<br>1. 消息队列，推送队列等。<br>2. 之前从事移动端的开发，没有实战过高并发的处理，对于无锁并发的思考是，这个操作一定是CPU执行的最小单位，不能被再次分割。了解了CAS原子操作，果然是类似的原理。<br><br>隐性作业：非循环数组队列中，存在数据搬移的情况，摊还分析法，平均是时间复杂度是O(1)<br><br># 内容<br>队列：先进先出。<br>应用场景：资源有限时的解决方案。<br>基于数组的循环队列，思路很棒，要掌握实现。<br><br># 感想<br>看到环形队列这里很有感触：人类抽象思考能力让人敬佩。<br>其实环形队列是我们逻辑上的概念，物理上并不是环形的，显示一个线性排列，a[length-1]并没有挨着a[0]，但我们可以用算法来实现相应的效果，达到目的。当然，计算机并不知道我们把它当做了环来处理。","like_count":0},{"had_liked":false,"id":113240,"user_name":"波拉拉","can_delete":false,"product_type":"c1","uid":1122121,"ip_address":"","ucode":"586F66351219E8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/49/e4ab004b.jpg","comment_is_top":false,"comment_ctime":1562922929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562922929","product_id":100017301,"comment_content":"Android中的Handler整个机制都涉及到队列","like_count":0},{"had_liked":false,"id":112690,"user_name":"　　","can_delete":false,"product_type":"c1","uid":1560563,"ip_address":"","ucode":"0D736D44A24C56","user_header":"https://static001.geekbang.org/account/avatar/00/17/cf/f3/48fc6781.jpg","comment_is_top":false,"comment_ctime":1562807135,"is_pvip":false,"replies":[{"id":"41568","content":"list缓存应该不是并发队列，因为redis操作是单线程的，不需要并发。另一个问题，答案应该是yes。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563232899,"ip_address":"","comment_id":112690,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562807135","product_id":100017301,"comment_content":"老师，您好，我想询问您一个问题，关于最后提到的并发队列，在redis服务的list类型缓存中，是不是用到的就是并发队列？还是说 现在大部分存在的队列服务都有并发队列这种模式？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457859,"discussion_content":"list缓存应该不是并发队列，因为redis操作是单线程的，不需要并发。另一个问题，答案应该是yes。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563232899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112135,"user_name":"逍遥","can_delete":false,"product_type":"c1","uid":1070213,"ip_address":"","ucode":"95C583EF780159","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/85/081804f7.jpg","comment_is_top":false,"comment_ctime":1562673170,"is_pvip":false,"replies":[{"id":"40808","content":"实现思路很多，可以轮训、或者使用信号量等等。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562712097,"ip_address":"","comment_id":112135,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562673170","product_id":100017301,"comment_content":"我想问一下阻塞队列就是添加阻塞动作，那到底是怎么实现的呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457594,"discussion_content":"实现思路很多，可以轮训、或者使用信号量等等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562712097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111049,"user_name":"Mr.Durden","can_delete":false,"product_type":"c1","uid":1194054,"ip_address":"","ucode":"C8469D8A3F1FD1","user_header":"https://static001.geekbang.org/account/avatar/00/12/38/46/b6159f7c.jpg","comment_is_top":false,"comment_ctime":1562432639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562432639","product_id":100017301,"comment_content":"基础不是很扎实，但是也试着通过老师课程所学的知识分析一下，以及提出一下我的观点。队列长度为n,当tail到达队尾的时候会进行数据搬移，即tail == n,head可能的情况为0～tail种，所以迁移数据所需的次数为0~n,n时队列没有进行过dequeue的情况，0是dequeue次数等于enqueue的情况，即队列出队入队次数相同都等于n,数据已经写到队列尾部，但是head和tail需要重置，队列中没有数据，所以时间复杂度是O(0) ,O(1),O(2)...O(n-1),O(n)&#47;n,O((0+n)*n&#47;2n) = O(n&#47;2),就是O(n),而发生的频率是n次入队后进行一次，均摊以后是O(1)的时间复杂度，最优的情况是O(1)即进行了n次入队和n次出队只重置tail和head最坏情况是O(n),入队n次没有出队","like_count":0},{"had_liked":false,"id":110831,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562370076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562370076","product_id":100017301,"comment_content":"队列的本质是提供一个先进先出的容器，在树和图的广度优先搜索有直接的应用。先来的先处理就形成了由近及远的结构。<br>西周的分封制度应该是按照血缘和功劳两个因素排个队列，然后给封地加公侯伯子男标签的算法吧。","like_count":0},{"had_liked":false,"id":110828,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1562368446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562368446","product_id":100017301,"comment_content":"不循环队列在入队的时候做搬移做不到均摊复杂度O(1),具体的情况如下，队列从开始不断插入到全满，然后再删除一个，插入一个，不断地重复一次删除一次插入，这个时候每次插入都要O(n）。","like_count":0},{"had_liked":false,"id":110214,"user_name":"cellphone峰","can_delete":false,"product_type":"c1","uid":1477273,"ip_address":"","ucode":"F09214B4F37161","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/99/f50df019.jpg","comment_is_top":false,"comment_ctime":1562208864,"is_pvip":false,"replies":[{"id":"40130","content":"应该是你理解错了，自己再看下吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562281566,"ip_address":"","comment_id":110214,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562208864","product_id":100017301,"comment_content":"不知道是不是我理解错了，那个数据搬移应该是搬到0到tail-head-1把？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456778,"discussion_content":"应该是你理解错了，自己再看下吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562281566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110074,"user_name":"你在不远的未来","can_delete":false,"product_type":"c1","uid":1318404,"ip_address":"","ucode":"5B34C8BD03B71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/04/f902047e.jpg","comment_is_top":false,"comment_ctime":1562166973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562166973","product_id":100017301,"comment_content":"kafka队列，在单个节点上也算是顺序队列，消费的时候通过offset指针来管理。","like_count":0},{"had_liked":false,"id":108545,"user_name":"蔡大少","can_delete":false,"product_type":"c1","uid":1014103,"ip_address":"","ucode":"46FB0BF4BFB75F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/57/59e6747a.jpg","comment_is_top":false,"comment_ctime":1561797624,"is_pvip":false,"replies":[{"id":"39394","content":"可以的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561937359,"ip_address":"","comment_id":108545,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561797624","product_id":100017301,"comment_content":"循环队列也可以用链表结构吧，队列满直接就是tail-&gt;next==header吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456035,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561937359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108154,"user_name":"李文武","can_delete":false,"product_type":"c1","uid":1490660,"ip_address":"","ucode":"71BEE4083ECD0F","user_header":"https://static001.geekbang.org/account/avatar/00/16/be/e4/4fe3caa0.jpg","comment_is_top":false,"comment_ctime":1561687455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561687455","product_id":100017301,"comment_content":"哈哈，应该是看每排的排号而不是电影票上的东西","like_count":0},{"had_liked":false,"id":107607,"user_name":"小k","can_delete":false,"product_type":"c1","uid":1304236,"ip_address":"","ucode":"AE0C5ADEB489F5","user_header":"https://static001.geekbang.org/account/avatar/00/13/e6/ac/5b99aa18.jpg","comment_is_top":false,"comment_ctime":1561563557,"is_pvip":false,"replies":[{"id":"38959","content":"嗯嗯 也可以的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1561599112,"ip_address":"","comment_id":107607,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561563557","product_id":100017301,"comment_content":"老师，环型队列外加一个已用used字段<br>入队时加1，出队时减1<br>判断队空队满只需要比较used和总长度大小即可，而且也不用空一个队了吧<br>这样会不会简便而且易理解些呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455586,"discussion_content":"嗯嗯 也可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561599112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105511,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561018999,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561018999","product_id":100017301,"comment_content":"队列按实现方式分类：顺序队列；链式队列<br>队列按特性分类：循环队列；阻塞队列；并发队列<br>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？<br>第一种，非阻塞地直接拒绝任务请求<br>第二种，是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理，可以考虑用队列及其变种<br>对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队<br>队列的应用：资源池中等待排队（如线程池、连接池、网络请求队列、消息队列）","like_count":0},{"had_liked":false,"id":104953,"user_name":"小白菜","can_delete":false,"product_type":"c1","uid":1568340,"ip_address":"","ucode":"ACD1267D329B96","user_header":"https://static001.geekbang.org/account/avatar/00/17/ee/54/dac0a6b6.jpg","comment_is_top":false,"comment_ctime":1560881976,"is_pvip":false,"replies":[{"id":"38002","content":"自己去找找吧，leetcode上都有标签的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560899868,"ip_address":"","comment_id":104953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560881976","product_id":100017301,"comment_content":"老师您好，请问这一讲对应的LeetCode题目有没有啊？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454500,"discussion_content":"自己去找找吧，leetcode上都有标签的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560899868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104544,"user_name":"时光剪影","can_delete":false,"product_type":"c1","uid":1093159,"ip_address":"","ucode":"CC6F24C30AE3E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ae/27/3dfcc699.jpg","comment_is_top":false,"comment_ctime":1560774904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560774904","product_id":100017301,"comment_content":"队列是先进先出的线性表。<br><br>基本操作：入队，出队<br><br>实现方式：基于数组，称为顺序队列。比如arrayblockingqueue <br> 基于链表，称为链式队列 如linkedblockingqueue <br><br>基于链表的实现方式有：<br>循环队列：首尾相连，队满时会浪费一个元素的存储空间tail指向的是空<br>队空判断：head==tail<br>队满判断：(tail +1)%len ==head<br>head所在位置：（head +1)%len<br>Tail所在位置：（tail +1)%len<br><br>阻塞队列：队列为空时，阻塞出队操作；队列为满时，阻塞入队操作；<br><br>并发队列：基于数组的循环队列+cas操作<br><br>线程池的线程都处于忙碌状态，对于新请求的处理姿势<br>阻塞：将请求排队，以某种规则被后面空闲出来的线程处理。<br>直接拒绝。<br><br>基于链表的无界队列：无限排队<br>基于数组的有界队列：能接收的请求个数有限<br>","like_count":0},{"had_liked":false,"id":104283,"user_name":"Bufan","can_delete":false,"product_type":"c1","uid":1387704,"ip_address":"","ucode":"A5EC0391C412DE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eriaIgoPa8abNTaUm7o6oa6mvL9iagRTdD1vhovWPyfiaS82f409Sz3kMFzYLNa4ibnHagA7M33l8XnIQ/132","comment_is_top":false,"comment_ctime":1560725569,"is_pvip":false,"replies":[{"id":"38007","content":"javascript中的数组类型底层就不是我们这里说的数据结构中的数组的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560900194,"ip_address":"","comment_id":104283,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560725569","product_id":100017301,"comment_content":"Javascript的数组感觉天然支持队列，不用再自己实现了吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454203,"discussion_content":"javascript中的数组类型底层就不是我们这里说的数据结构中的数组的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560900194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100358,"user_name":"☆星月夜","can_delete":false,"product_type":"c1","uid":1215506,"ip_address":"","ucode":"22BCA9807D0BD4","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/12/ccf8d2ca.jpg","comment_is_top":false,"comment_ctime":1559534727,"is_pvip":false,"replies":[{"id":"36277","content":"也可以不浪费的，有很多实现方法，我只是讲了其中的一种。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559613080,"ip_address":"","comment_id":100358,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559534727","product_id":100017301,"comment_content":"老师您好，想问您一下，您说环形数组会浪费一个存储空间，据我所知，disruptor的环形数组是不需要浪费一个存储空间的啊，他保证多消费者的最大消费序号小于多生产者的最小序号，来避免覆盖问题，不需要浪费一个存储空间啊","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":452515,"discussion_content":"也可以不浪费的，有很多实现方法，我只是讲了其中的一种。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559613080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":99164,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1546967,"ip_address":"","ucode":"64FE6FF3BAF061","user_header":"https://static001.geekbang.org/account/avatar/00/17/9a/d7/c49875d5.jpg","comment_is_top":false,"comment_ctime":1559173637,"is_pvip":false,"replies":[{"id":"35629","content":"是的，有利有弊！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559176876,"ip_address":"","comment_id":99164,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1559173637","product_id":100017301,"comment_content":"老师，用链表实现循环队列怎么样，就不存在有一个元素为空的情况吧，不过链表本身需要额外开销存储链表指针","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451998,"discussion_content":"是的，有利有弊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559176876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98300,"user_name":"山鷹·China","can_delete":false,"product_type":"c1","uid":1146178,"ip_address":"","ucode":"1A13AAC813C1C8","user_header":"https://static001.geekbang.org/account/avatar/00/11/7d/42/c324a7de.jpg","comment_is_top":false,"comment_ctime":1558951329,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558951329","product_id":100017301,"comment_content":"初步实现了一个c语言的无锁环形队列，还没有详细的测试。老师您看看对不对、有没有bug<br><br><br>typedef struct circular_queue_s {<br>    void **data;<br>    int32_t head;<br>    int32_t tail;<br>    size_t size;<br>} circular_queue_t;<br><br>circular_queue_t *queue_create(size_t size);<br>void queue_destroy(circular_queue_t *queue);<br>int queue_enqueue(circular_queue_t *queue, void *data);<br>void *queue_dequeue(circular_queue_t *queue);<br>int queue_full(circular_queue_t *queue);<br><br>circular_queue_t *queue_create(size_t size) {<br>    circular_queue_t *queue;<br>    void *p;<br><br>    p = NULL;<br>    queue = NULL;<br><br>    p = malloc(size * sizeof(void*));<br>    if (p == NULL) <br>        goto clean;<br><br>    queue = (circular_queue_t *)malloc(sizeof(circular_queue_t));<br>    if (queue == NULL) <br>        goto clean;<br><br>    queue-&gt;size = size;<br>    queue-&gt;head = 0;<br>    queue-&gt;tail = 0;<br>    queue-&gt;data = (void **)p;<br><br>    return queue;<br><br>clean:<br>    if (p) {<br>        free(p);<br>        p = NULL;<br>    }<br>    if (queue) {<br>        free(queue);<br>        queue = NULL;<br>    }<br>    return queue;<br>}<br><br>int queue_enqueue(circular_queue_t *queue, void *data) {<br>    if (queue_full(queue)) <br>        return 1;<br><br>    while (1) { <br>        queue-&gt;data[queue-&gt;tail] = data;<br>        if (__sync_bool_compare_and_swap(&amp;queue-&gt;data[queue-&gt;tail], queue-&gt;data[queue-&gt;tail], data)) { &#47;&#47; CAS<br>            break;<br>        }<br>    }<br>    <br>    queue-&gt;tail = (queue-&gt;tail + 1) % queue-&gt;size;<br><br>    return 0;<br>}<br><br>void *queue_dequeue(circular_queue_t *queue) {<br>    void *ret;<br><br>    ret = NULL;<br><br>    if (queue-&gt;head == queue-&gt;tail) <br>        return NULL;<br><br>    ret = queue-&gt;data[queue-&gt;head];<br>    queue-&gt;head = (queue-&gt;head + 1) % queue-&gt;size;<br>    return ret;<br>}<br><br>int queue_full(circular_queue_t *queue) {<br><br>    if ((queue-&gt;tail + 1) % queue-&gt;size == queue-&gt;head) <br>        return 1;<br><br>    return 0;<br>}<br><br>void queue_destroy(circular_queue_t *queue) {<br>    if (queue == NULL)<br>        return;<br>    if (queue-&gt;data) {<br>        free(queue-&gt;data);<br>        queue-&gt;data = NULL;<br>    }<br>    free(queue);<br>    queue = NULL;<br>}","like_count":0},{"had_liked":false,"id":98021,"user_name":"Geek_213736","can_delete":false,"product_type":"c1","uid":1539153,"ip_address":"","ucode":"1B130CB52D9088","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL5cyRVutbpBbjfk3vgGTSuiar5cDJibo1uz7jrDmJCiaNf2uwnoibrhwYX9nmaQzaomF4cKiavWskX3MA/132","comment_is_top":false,"comment_ctime":1558875647,"is_pvip":false,"replies":[{"id":"35216","content":"是的","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559007232,"ip_address":"","comment_id":98021,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558875647","product_id":100017301,"comment_content":"在老师提供的循环队里代码里面，    <br>def dequeue(self) -&gt; Optional[str]:<br>        if self._head != self._tail:<br>            item = self._items[self._head]<br>            self._head = (self._head + 1) % self._capacity<br>如果要弹出一个值，但是弹出的值并没有从self._items[]里面删除吧？只是这个self._head的值+1了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451521,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559007232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":97730,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1558757321,"is_pvip":true,"replies":[{"id":"35211","content":"1. 思路不错<br>2. 自己研究下吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1559006778,"ip_address":"","comment_id":97730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558757321","product_id":100017301,"comment_content":"老师我有几点疑问请教：<br>1. 用数组实现的循环队列是否也可以定义成动态长度的队列，大体思路是：当队列满时将队列中的元素重新拷贝到新的内存，不满时继续使用循环队列，这样既满足了不浪费之前pop掉的数组内存，而且pop和push的时间复杂度都为O(1)，不知道这种思路对不对？请老师和各位大佬指点。<br>2.然后我想了解一下像c++ queue中是如何实现这种动态队列的呢？使用链表吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451388,"discussion_content":"1. 思路不错\n2. 自己研究下吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1559006778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94501,"user_name":"10^100个邱怡霖","can_delete":false,"product_type":"c1","uid":1517246,"ip_address":"","ucode":"414414618FA93A","user_header":"https://static001.geekbang.org/account/avatar/00/17/26/be/c7249aea.jpg","comment_is_top":false,"comment_ctime":1557827149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557827149","product_id":100017301,"comment_content":"我不是很理解，循环队列假设数组大小为3，那存入第二次后，tail=2, head=0, 存入第三次之前就会判定满了啊。","like_count":0},{"had_liked":false,"id":94166,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1557736103,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1557736103","product_id":100017301,"comment_content":"1.数据库连接池，还有双11或者别的活动场景下对应一款爆款商品的下单，在做处理的时候也可以将用户的请求作为排队队列请求进行处理<br>2.无锁并发队列  可以通过cas + 数组实现","like_count":0},{"had_liked":false,"id":91328,"user_name":"W.P","can_delete":false,"product_type":"c1","uid":1498861,"ip_address":"","ucode":"E4CC3AD5F8DB7F","user_header":"https://static001.geekbang.org/account/avatar/00/16/de/ed/9c968078.jpg","comment_is_top":false,"comment_ctime":1556981073,"is_pvip":false,"replies":[{"id":"33067","content":"如果队列大小是2，你可以试着往里添加些数据，看下你的两个判定条件是否对呢？","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557279748,"ip_address":"","comment_id":91328,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556981073","product_id":100017301,"comment_content":"循环队列中 tail 为什么不能指向最后1个有值元素，如果指向最后1个有值元素时，<br>head == tail 时表示为空<br>tail.next == head 时，表示为满<br>可以吗？还是没明白为什么非得要tail要占用1个空位... ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448888,"discussion_content":"如果队列大小是2，你可以试着往里添加些数据，看下你的两个判定条件是否对呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557279748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90917,"user_name":"段斌","can_delete":false,"product_type":"c1","uid":1173578,"ip_address":"","ucode":"B5A85C6AF139B4","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/4a/c2a539a0.jpg","comment_is_top":false,"comment_ctime":1556722637,"is_pvip":false,"replies":[{"id":"32882","content":"一致性hash算法","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557186254,"ip_address":"","comment_id":90917,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556722637","product_id":100017301,"comment_content":"大规模数据分布中的分片函数用的consistent hash是环队列吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448720,"discussion_content":"一致性hash算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557186254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90386,"user_name":"我叫我自己","can_delete":false,"product_type":"c1","uid":1506507,"ip_address":"","ucode":"7075B12170BDBB","user_header":"https://static001.geekbang.org/account/avatar/00/16/fc/cb/9e2f5110.jpg","comment_is_top":false,"comment_ctime":1556506348,"is_pvip":false,"replies":[{"id":"33064","content":"先要tail-&gt;next=new node；然后tail=new node;或者tail=tail-&gt;next;两者是等价的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1557279443,"ip_address":"","comment_id":90386,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1556506348","product_id":100017301,"comment_content":"老师，链式队列入队时，tail＝new node不就行了吗，为什么还需要对tail-＞next进行操作呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448502,"discussion_content":"先要tail-&amp;gt;next=new node；然后tail=new node;或者tail=tail-&amp;gt;next;两者是等价的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557279443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":89804,"user_name":"张晟","can_delete":false,"product_type":"c1","uid":1332192,"ip_address":"","ucode":"77EBEAB9DD9ED6","user_header":"https://static001.geekbang.org/account/avatar/00/14/53/e0/2b8fd02d.jpg","comment_is_top":false,"comment_ctime":1556268609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556268609","product_id":100017301,"comment_content":"并发队里和阻塞队列与golang中的有缓冲通道和无缓冲通道很像呀，都是FIFO， 而且通道空或满的时候可以阻塞接收方或发送发，底层思想都很相近","like_count":0},{"had_liked":false,"id":89694,"user_name":"TimberTang","can_delete":false,"product_type":"c1","uid":1079131,"ip_address":"","ucode":"FE9804F49F7FC0","user_header":"https://static001.geekbang.org/account/avatar/00/10/77/5b/5d4606ec.jpg","comment_is_top":false,"comment_ctime":1556245164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556245164","product_id":100017301,"comment_content":"mark-坚持","like_count":0},{"had_liked":false,"id":89689,"user_name":"Geek_44ea90","can_delete":false,"product_type":"c1","uid":1466062,"ip_address":"","ucode":"72722FC2F089A9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/I2V15qJ6m2Av80vrgbqKPZ3dNragW2sYBTMj0YCjh05ic5IIumUpNibSHEOD8vz5CSNib3kRd6bbmDFGb9oB2X5Mw/132","comment_is_top":false,"comment_ctime":1556244482,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556244482","product_id":100017301,"comment_content":"@计科一班 当循环数组内未存储数据，tail指针未指向循环数组，也就是删除第一个数据时，需要同时删除整个循环队列，小白勿喷。","like_count":0},{"had_liked":false,"id":89457,"user_name":"陛下","can_delete":false,"product_type":"c1","uid":1502609,"ip_address":"","ucode":"0EE22B4A1904F6","user_header":"https://static001.geekbang.org/account/avatar/00/16/ed/91/5dece756.jpg","comment_is_top":false,"comment_ctime":1556178524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556178524","product_id":100017301,"comment_content":"现在分布式消息中间件，大部分都是基于队列结构的；<br>无锁并发队列，可以在 head和tail 值上做判断","like_count":0},{"had_liked":false,"id":87369,"user_name":"叫我宫城大人","can_delete":false,"product_type":"c1","uid":1500930,"ip_address":"","ucode":"B12019AE4EBC5F","user_header":"https://static001.geekbang.org/account/avatar/00/16/e7/02/5b1fc277.jpg","comment_is_top":false,"comment_ctime":1555578243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555578243","product_id":100017301,"comment_content":"AbstractQueuedSynchronizer 内部维护的就是一个 基于链表线程安全的队列。ArrayBlockingQueue 也是用了 ReentrantLock 来实现阻塞操作。<br><br>关于“计科一班”那个将 tail 指向最后一个元素的下标而不是最后一个空元素。我觉得这种实现在并发上 CAS 处理并不容易（排除使用 synchronized 和 lock 方案），因为多出来的 size 与 head、tail 具有一致性关系（判断队列是否为空），不太好用 CAS 一致性处理。<br><br>个人拙见，还望老师点评。","like_count":0},{"had_liked":false,"id":82909,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1411645,"ip_address":"","ucode":"BF590964828F8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/8a/3d/5f29e927.jpg","comment_is_top":false,"comment_ctime":1554347099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554347099","product_id":100017301,"comment_content":"4.4笔记<br>4.4<br>队列，一种操作受限的线性表结构，尾部入队，头部出队，特点是先进先出(顺序线性表)<br>1.队列实现<br>顺序队列，链式队列<br>2.入队出队操作<br>初始化head=tail=0，用head出队，tail入队，但是当tail到达内存末尾，但是head并不在原点(内存中还有空闲位置，但是没法插入了)<br>注:<br>方法一，类似数组删除操作，有空隙不连续，这种情况都用数据搬移即刻解决，而且不用每次入队都保证连续，只需要到达内存尾部才触发一次数据搬移操作(整体平移到原点)<br>方法二，循环队列直接避免数据搬移，循环队列长度设定需要对并发数据有一定的预测(否则丢失太多请求)，但最关键的是，判断队空队满的判定情况(专门牺牲一个内存区别空满)<br>head==tail;(空就是收尾只差为0)<br>tail==n;(满到达内存尾部)<br>head==tail;(空就是收尾只差为0)<br>(tail+1)%n=head;(满牺牲一个，专门区分空满状态，顺便可用存大小)<br>3.阻塞队列和并发队列<br>阻塞队列:在队列基础上，增加了阻塞功能，空则阻塞出队，满则阻塞入队，轻松实现生产者-消费者模型(一可协调生产消费速度，二可协调消费生产者个数，如一生产多消费)，也引出多线程问题，保证线程安全问题，可用并发队列实现<br>并发队列:a.直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作;b.基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链表队列应用更广的原因。<br>4.经典问题线程池<br>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理，有哪些策略？各种处理策略又是如何实现的呢？<br>答:一般有两种处理策略。<br>第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。<br>若用非阻塞处理，那如何存储排队的请求呢？<br>答:希望公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求，队列有基于链表和基于数组这两种实现方式。<br>链表数组队列应用区别？<br>答:关键看对响应时间要求<br>基于链表实现的无界队列（unbounded queue），但是过多的请求排队等待，请求处理的响应时间过长。<br>基于数组实现的有界队列（bounded queue），线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。这时候设置一个合理的队列长度非常重要，太大等待长，太小浪费资源<br>注:大部分资源有限的场景，在没有空闲资源时，基本都使用队列实现请求排队<br>5.其他应用<br>数据库连接池，消息队列<br>5.生活小秘招区别栈和队列<br>吃多了拉就是队列，吃多了吐就是栈，talk is cheap,show me the code(屁话少说，放马过来)","like_count":0},{"had_liked":false,"id":81795,"user_name":"天下行走","can_delete":false,"product_type":"c1","uid":1462449,"ip_address":"","ucode":"73A4CD8BB91235","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLfrbMvhKQYhxP6ziaHaj4KUNRzst8u7BZsWUsazK8oTLXcNH6sDGITl6icy3IiaGFe9Iiae12LuTrF1g/132","comment_is_top":false,"comment_ctime":1554037486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554037486","product_id":100017301,"comment_content":"大家没有发现精髓都是在tail指向下一位吗，不管是单向的还是循环队列；开始总想设置tail指向当前最后一个元素，初始值tail=head=-1，表示开始都没有元素加入，然后发现实现起来还奇怪，有没有类似想法的？","like_count":0},{"had_liked":false,"id":79741,"user_name":"___","can_delete":false,"product_type":"c1","uid":1229519,"ip_address":"","ucode":"B0BA5A1413798C","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/cf/573a0fdc.jpg","comment_is_top":false,"comment_ctime":1553529302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553529302","product_id":100017301,"comment_content":"消息队列<br><br>队列采取数据迁移的情况，最好时间复杂度O(1),最坏O(n),均摊O(1)，对吗😃<br><br>希望能尽快看到cas那章","like_count":0},{"had_liked":false,"id":79548,"user_name":"樊大静","can_delete":false,"product_type":"c1","uid":1104272,"ip_address":"","ucode":"EE899C8794FBD0","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/90/10eefa97.jpg","comment_is_top":false,"comment_ctime":1553506431,"is_pvip":false,"replies":[{"id":"29095","content":"不 是小于号的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553562800,"ip_address":"","comment_id":79548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553506431","product_id":100017301,"comment_content":"用数据搬移那里应该是i&lt;=tail吧？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444537,"discussion_content":"不 是小于号的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553562800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":79403,"user_name":"高健宇","can_delete":false,"product_type":"c1","uid":1396745,"ip_address":"","ucode":"6A7E90CEE248AD","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/09/57be9ecf.jpg","comment_is_top":false,"comment_ctime":1553476397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553476397","product_id":100017301,"comment_content":"CircularQueue.printAll 打印时会报 数组下标越界<br>System.out.print(items[i] + &quot; &quot;);<br>&#47;&#47;调整后<br>System.out.print(items[i%n] + &quot; &quot;);","like_count":0},{"had_liked":false,"id":79152,"user_name":"麦芒小蚱蜢","can_delete":false,"product_type":"c1","uid":1270410,"ip_address":"","ucode":"5EC406B13B798E","user_header":"https://static001.geekbang.org/account/avatar/00/13/62/8a/28abe548.jpg","comment_is_top":false,"comment_ctime":1553388929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553388929","product_id":100017301,"comment_content":"1、在一些高并发系统设计中，可以通过队列这种数据结构来进行流量削峰，保护系统不被压垮<br>2、课堂中的思考问题：使用数组实现的顺序队列，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，这时候需要进行数据搬移。仅考虑入队时，没有出队的情况。假设队列中有n个元素，那最坏情况下，head指针在下标为1的位置，tail指针在n-1的位置，一次入队总共需要进行（n-1）次搬移操作，所以最坏情况下时间复杂度为O(n)，最好情况时间复杂度为O（1）。不知道我分析的是否正确","like_count":0},{"had_liked":false,"id":79023,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1553326031,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1553326031","product_id":100017301,"comment_content":"1. 基于链表的循环队列：连线、移动指针；<br>2. 基于数组的循环列表：队空和队满的判断条件","like_count":0},{"had_liked":false,"id":78694,"user_name":"莫问流年","can_delete":false,"product_type":"c1","uid":1249663,"ip_address":"","ucode":"23140E031AED4B","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/7f/80d56c1c.jpg","comment_is_top":false,"comment_ctime":1553219634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553219634","product_id":100017301,"comment_content":"1.运用到队列的地方<br>Kafka、RocketMQ等消息中间件<br>数据库连接池<br>http server请求处理<br>2.CAS无锁并发队列<br>入队(或出队)时，分别检查tail(或head)指向的位置是否变化。如果位置不变，则正常入队；如果位置变化，说明操作了脏数据，本次尝试失败。","like_count":0},{"had_liked":false,"id":78517,"user_name":"Geek_32772e","can_delete":false,"product_type":"c1","uid":1446158,"ip_address":"","ucode":"2850EF64F4775F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoribOUgcicu1sOqZZVtPqpSDSS43vicxW0GesxQeBRjUC47CzulKSzYNj2aMg9YOZDdjPdAZxS3jNcQ/132","comment_is_top":false,"comment_ctime":1553164279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553164279","product_id":100017301,"comment_content":"yarn的公平调度方式可以参考下","like_count":0},{"had_liked":false,"id":76774,"user_name":"tuyu","can_delete":false,"product_type":"c1","uid":1448863,"ip_address":"","ucode":"B235325B541408","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/BIRpwViaN51yynIeFonD7QRlwDCVtKibrG956NTxzEqibOZZVjhMMgibOPmd3VicfYxpknZsic1oJq8KicZvXkmmiajuQg/132","comment_is_top":false,"comment_ctime":1552706114,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552706114","product_id":100017301,"comment_content":"哈哈,看作者的思路就像看一本武林秘籍,突然看到一个让我恍然大悟的一行,就像给我一剑,像电视剧一样,领悟大河剑法,领悟领悟就吐血了。","like_count":0},{"had_liked":false,"id":73851,"user_name":"nullz","can_delete":false,"product_type":"c1","uid":1156066,"ip_address":"","ucode":"A9D997C41D6DE3","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/e2/d2cf7a81.jpg","comment_is_top":false,"comment_ctime":1552015931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552015931","product_id":100017301,"comment_content":"循环队列这样实现可以吗：当队列满时，tail-head==size，队列为空时，head==tail<br>public class CyclicQueue {<br>    private int size;<br>    private int head;<br>    private int tail;<br>    private int[] array;<br>    public CyclicQueue(int size) {<br>        this.size = size;<br>        this.head = 0;<br>        this.tail = 0;<br>        this.array = new int[size];<br>    }<br><br>    public boolean enqueue(int val) {<br>        if(tail - head == size) {<br>            return false;<br>        }<br>        array[tail % size] = val;<br>        tail++;<br>        return true;<br>    }<br><br>    public boolean dequeue() {<br>        if (tail == head) {<br>            return false;<br>        }<br>        array[head % size] = 0;<br>        head++;<br>        return true;<br>    }<br>}","like_count":0},{"had_liked":false,"id":72411,"user_name":"浩","can_delete":false,"product_type":"c1","uid":1394346,"ip_address":"","ucode":"BD7FE280C83152","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKoGnC6068nQia1bOiaPxMRmkOQsaDsw5ib2drXic4gKOLzIFyZnnFm4uJ6KniboKG1nQD3J15y4d3QxLA/132","comment_is_top":false,"comment_ctime":1551615463,"is_pvip":false,"replies":[{"id":"26270","content":"说的没错！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551666249,"ip_address":"","comment_id":72411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551615463","product_id":100017301,"comment_content":"老师，对于链式队列，如果基于带头节点的链表实现的话，可以记录目前的链表节点数，然后，在入队之前判断目前的队列节点数是否已经达到头节点中记录的限制，这样也可以实现对队列长度的控制，对吧？所以，对文中讲到链式队列","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441578,"discussion_content":"说的没错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551666249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":71827,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551445568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551445568","product_id":100017301,"comment_content":"日常学习。。坚持下去","like_count":0},{"had_liked":false,"id":71275,"user_name":"qdnjqfch","can_delete":false,"product_type":"c1","uid":1435144,"ip_address":"","ucode":"DD3E5FD94CFDE9","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/08/87a6f32b.jpg","comment_is_top":false,"comment_ctime":1551315422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551315422","product_id":100017301,"comment_content":"android中的广播发送机制，也是通过队列实现的","like_count":0},{"had_liked":false,"id":69416,"user_name":"cnhjq","can_delete":false,"product_type":"c1","uid":1285923,"ip_address":"","ucode":"C9913D5F069EF4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoMlOBZg2HYWh4Fu5dCXlmHmQ67YG9H3hbjBwuicltia18flYHiaYZ2c1aqNsPVp8Ttqo5Qc8NiaEvFZg/132","comment_is_top":false,"comment_ctime":1550738351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550738351","product_id":100017301,"comment_content":"滑动时间窗口也可以认为是一种循环队列结构","like_count":0},{"had_liked":false,"id":67712,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1550227681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550227681","product_id":100017301,"comment_content":"回头看看java的阻塞队列实现","like_count":0},{"had_liked":false,"id":66045,"user_name":"母鸡啊","can_delete":false,"product_type":"c1","uid":1368194,"ip_address":"","ucode":"7C7F0C8C59F0B0","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/82/5eb76481.jpg","comment_is_top":false,"comment_ctime":1549859475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549859475","product_id":100017301,"comment_content":"有个地方不太懂，为什么队列的尾指针指向的不是队列abcd的最后一个元素d，而是最后一个元素d的下一个元素呢?","like_count":0},{"had_liked":false,"id":65648,"user_name":"Pre-Y","can_delete":false,"product_type":"c1","uid":1396900,"ip_address":"","ucode":"A13D13A37F3ABC","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg","comment_is_top":false,"comment_ctime":1549535030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549535030","product_id":100017301,"comment_content":"今日份的打卡。<br>还是得多写写代码啊😂上半学期才刚学的，码起来就不顺溜了눈_눈","like_count":0},{"had_liked":false,"id":65447,"user_name":"Java知其所以然","can_delete":false,"product_type":"c1","uid":1085200,"ip_address":"","ucode":"DC17FC7A7E42D1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8f/10/f9151d58.jpg","comment_is_top":false,"comment_ctime":1549363848,"is_pvip":false,"replies":[{"id":"24298","content":"😄 你说的没错. aba问题实际上也有相应的解决方案。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550542786,"ip_address":"","comment_id":65447,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549363848","product_id":100017301,"comment_content":"CAS 存在 ABA  问题，所以操作链表的话会有问题。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438454,"discussion_content":"😄 你说的没错. aba问题实际上也有相应的解决方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63375,"user_name":"Grug","can_delete":false,"product_type":"c1","uid":1219953,"ip_address":"","ucode":"12E52DAE381CBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/9d/71/ecb50958.jpg","comment_is_top":false,"comment_ctime":1548335726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548335726","product_id":100017301,"comment_content":"请教下--环形队列有个疑问：判断队列满的时候，tail.next==head，这样判断OK吗？ 当这样的时候，队列满，block住不允许添加（防止覆盖数据）。这样判断队列满可以吗？","like_count":0},{"had_liked":false,"id":61378,"user_name":"Aaaaaaaaaaayou","can_delete":false,"product_type":"c1","uid":1073601,"ip_address":"","ucode":"67BA315B87587D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/c1/93031a2a.jpg","comment_is_top":false,"comment_ctime":1547687770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547687770","product_id":100017301,"comment_content":"有个问题，入队时，通过 cas 来判断队尾决定是否入队，但是 cas 和入队还是两个操作啊。","like_count":0},{"had_liked":false,"id":59537,"user_name":"hiyanxu","can_delete":false,"product_type":"c1","uid":1221750,"ip_address":"","ucode":"FA46A318154812","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/76/585dc6b3.jpg","comment_is_top":false,"comment_ctime":1547384009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547384009","product_id":100017301,"comment_content":"老师，不知道可不可以这样：<br>假如我默认当每个结点的数据为0时，表示该结点为空，这样：<br>队列已满：tail == head &amp;&amp; q-&gt;arr[q-&gt;tail] != 0（即两个指针重合，且不为空） 时，表示队列已满；<br>队列为空：tail == head &amp;&amp; q-&gt;arr[q-&gt;tail] != 0（即两个指针重合，且为空）时，表示队列为空。<br>请教师批评指正哈，谢谢。","like_count":0},{"had_liked":false,"id":58793,"user_name":"danvid","can_delete":false,"product_type":"c1","uid":1270415,"ip_address":"","ucode":"84C50611B1DEA5","user_header":"https://static001.geekbang.org/account/avatar/00/13/62/8f/c0f40d98.jpg","comment_is_top":false,"comment_ctime":1547194490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547194490","product_id":100017301,"comment_content":"多用一个flag空间每次出入队都减少了一次判断，不留flag的可以这样<br>public class CircularQueue&lt;E&gt; {<br>    &#47;**<br>     * 队列大小<br>     *&#47;<br>    private int size=0;<br>    &#47;**<br>     * 队尾<br>     *&#47;<br>    private int tail=0;<br>    &#47;**<br>     * 队头<br>     *&#47;<br>    private int head=0;<br>    &#47;**<br>     * 数据<br>     *&#47;<br>    private Object[] elementData;<br><br>    public CircularQueue(int capacity) {<br>        this.elementData = new Object[capacity];<br>    }<br><br>    &#47;**<br>     * 出队<br>     * @return<br>     *&#47;<br>    public E dequeue(){<br>        if(size==0){<br>            return null;<br>        }<br>        Object element=elementData[head];<br>        elementData[head]=null;<br>        if (head==this.elementData.length-1){<br>            head=0;<br>        }else {<br>            head++;<br>        }<br>        size--;<br>        return (E)element;<br>    }<br><br>    &#47;**<br>     * 入队<br>     * @param element<br>     * @return<br>     *&#47;<br>    public boolean enqueue(E element){<br>        if(size==elementData.length){<br>            return false;<br>        }<br>        this.elementData[tail]=element;<br>        if (tail==this.elementData.length-1){<br>            tail=0;<br>        }else {<br>            tail++;<br>        }<br>        size++;<br>        return true;<br>    }<br><br>    @Override<br>    public String toString() {<br>        return &quot;CircularQueue{&quot; +<br>                &quot;size=&quot; + size +<br>                &quot;, tail=&quot; + tail +<br>                &quot;, head=&quot; + head +<br>                &quot;, elementData=&quot; + Arrays.toString(elementData) +<br>                &#39;}&#39;;<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":57607,"user_name":"君不得闲","can_delete":false,"product_type":"c1","uid":1101581,"ip_address":"","ucode":"718AA2C9B410BB","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/0d/f4150547.jpg","comment_is_top":false,"comment_ctime":1546847112,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1546847112","product_id":100017301,"comment_content":"有个问题向请教老师就是tail所代表的队尾下标，这里的队尾指的是队尾一个空的待放数据的位置，还是队列的最后一个元素，我看代码表示的应该是前者","like_count":0},{"had_liked":false,"id":57516,"user_name":"黄淮江客.","can_delete":false,"product_type":"c1","uid":1247553,"ip_address":"","ucode":"4D40181BA767DC","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/41/d1928f5c.jpg","comment_is_top":false,"comment_ctime":1546826613,"is_pvip":false,"replies":[{"id":"21853","content":"嗯嗯是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1547708932,"ip_address":"","comment_id":57516,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546826613","product_id":100017301,"comment_content":"说到可动态扩容队列，那不是还有涉及内存申请和释放的问题吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435620,"discussion_content":"嗯嗯是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1547708932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56329,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1546422728,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1546422728","product_id":100017301,"comment_content":"循环队列，满的判断条件，(tail+1)% n=head。<br>阻塞队列，并发队列。","like_count":0},{"had_liked":false,"id":55500,"user_name":"尼古拉斯·D·兔子","can_delete":false,"product_type":"c1","uid":1027869,"ip_address":"","ucode":"8293C64A97ADED","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/1d/408b641f.jpg","comment_is_top":false,"comment_ctime":1546220483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546220483","product_id":100017301,"comment_content":"抢火车票就是一个队列，至于第三方的什么加速包，我理解应该也是实现了一个优先级队列，加速包越多，优先级越高，进而优先匹配服务器资源，且向12306发送请求的间隔更短，从而实现更大可能抢票。","like_count":0},{"had_liked":false,"id":53396,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1545638384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545638384","product_id":100017301,"comment_content":"老师，阻塞队列C++代码<br>void put(const value_type&amp; item) {<br>        std::unqiue_lock&lt;std::mutex&gt; lock(mutex_);                                                                                                                                 while (full()) {<br>            not_full_.wait(lock);                                                                                                                                                  }<br>        container_.push(item);                                                                                                                                                     not_empty_.notify_one();<br>    }        <br>这个lock锁不用unlock解锁吗，看官方文档还是要unlock的                                                                                                                                                                  ","like_count":0},{"had_liked":false,"id":53090,"user_name":"CathyLin","can_delete":false,"product_type":"c1","uid":1240546,"ip_address":"","ucode":"F7CDFF5E1A235F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/e2/0e1c6c5a.jpg","comment_is_top":false,"comment_ctime":1545582073,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545582073","product_id":100017301,"comment_content":"首先回答一下课中的顺序队列的数据搬移的复杂度。<br>我觉得和上一节栈的数据搬移的复杂度分析差不多。入队的复杂度我觉得可以通过之前那一张讲的摊还分析法，得到搬移虽然要 O(n)，但是可以均摊到后面的插入操作中去，所以复杂度我觉得是 O(1)。[如果有错误的话，还请老师指教，谢谢～]<br><br>最后两个思考题都不太会，只能看看评论区里面大神们的回复了= =<br><br>笔记：<br>先进先出，FIFO。<br>也是只有两个操作，入队和出队。<br><br>顺序队列 &amp; 链式队列<br>用数组实现的叫顺序队列，用链表实现的叫链式队列。<br><br>顺序队列<br>栈：只需要一个栈顶指针就可以了。<br>队列：需要一个头指针 head，指向队头，一个尾指针 tail，指向队尾。<br>入队：tail ++<br>出队：head ++<br>入队的时候可能会出现后面塞不下，然后前面还有空余的情况。<br>How to deal with this?<br>\t- 数据搬移<br><br>将 head - tail 之间的数据搬移到 0 - (tail-head+1)，然后更新 head 和 tail 的位置。然后再利用 tail++ 就可以塞入新的数据了。<br><br>在这种实现思路中，出队的复杂度依旧是 O(1)，入队的复杂度我觉得可以通过之前那一张讲的摊还分析法，得到搬移虽然要 O(n)，但是可以均摊到后面的插入操作中去，所以复杂度我觉得是 O(1)。<br><br>链式队列<br>入队：tail-&gt;next = newNode;  tail = tail-&gt;next<br>出队：head = head-&gt;next<br><br>循环队列<br>刚刚那种数据搬移会有点低效。所以可以用循环队列的方法来解决问题。<br>要注意的是判断队空和队满的情况。<br>队空的话：head==tail<br>队满：(tail+1) % n == head<br>当队满的时候，会空出来一个位置，图中 tail 所指向的位置实际上是不存储数据的。所以循环队列会浪费一个存储空间。<br><br>阻塞队列 &amp; 并发队列<br>阻塞队列其实就是在队列的操作中加上了阻塞的操作。简单来说，就是在队列为空时，在队首取数据会被阻塞；在队列满了后，在队尾加数据也会被阻塞。<br><br>其实就是一个“生产者-消费者”模型。它可以有效的协调消费和生产的速度。<br><br>还可以有多个线程同时操作队列。这时候会存在线程安全问题，线程安全的队列我们叫并发队列。<br><br>开篇问题<br>当线程池中没有空闲线程，但是有新任务请求线程资源时，线程池应该怎样处理？<br>1）非阻塞，直接拒绝❌<br>2）阻塞，将请求排队处理。<br>     a. 链式队列，它是无边界的队列，可以支持无限排队。(unbounded queue) 但是会导致等待时间过长，请求处理的响应时间过长。<br>     b. 基于数组的有界队列。(bounded queue) 大小有限，但是响应时间快。<br><br>对于大部分资源有限的请求场景，都可以用队列来实现。","like_count":0},{"had_liked":false,"id":53050,"user_name":"坑坑","can_delete":false,"product_type":"c1","uid":1221707,"ip_address":"","ucode":"CC5A357B21393C","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/4b/a522594f.jpg","comment_is_top":false,"comment_ctime":1545575961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545575961","product_id":100017301,"comment_content":"王老师,想向您请教一下: 既然是先进先出,那么对于non-dynamic的顺序队列用一个变量来记录当前存储的位置(如下面的代码),不需要同时记录head和tail吧?一直没有想通这里,恳请老师不吝赐教~<br>public class ArrayQueue&lt;T&gt; {<br>\tprivate T[] items;<br>        &#47;&#47; 记录当前下标,初始化为0<br>\tprivate int count = 0;<br>\tprivate int capacity;<br><br>\tpublic ArrayQueue(int capacity) {<br>\t\tthis.items = (T[]) new Object[capacity];<br>\t\tthis.capacity = capacity;<br>\t}<br><br>\tpublic boolean push(T item) {<br>\t\tif (capacity == count) {<br>\t\t\treturn false;<br>\t\t}<br>\t\titems[count] = item;<br>\t\tcount++;<br>\t\treturn true;<br>\t}<br><br>\tpublic T pop() {<br>               &#47;&#47; 当count=0 表示队列已空<br>\t\tif (0 == count) {<br>\t\t\treturn null;<br>\t\t}<br>\t\tT item = this.items[count - 1];<br>\t\tcount--;<br>\t\treturn item;<br>\t}<br><br>\tpublic void printAll() {<br>\t\tfor (int i = 0; i &lt; count; i++) {<br>\t\t\tSystem.out.print(this.items[i]);<br>\t\t}<br>\t\tSystem.out.println(&quot;---&quot;);<br>\t}<br>}","like_count":0},{"had_liked":false,"id":52833,"user_name":"孑","can_delete":false,"product_type":"c1","uid":1321396,"ip_address":"","ucode":"C83AC0ECFE0B5C","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/b4/f95e8e9e.jpg","comment_is_top":false,"comment_ctime":1545537183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545537183","product_id":100017301,"comment_content":"1想到了数据库连接池，消息队列MQ<br>2没想到","like_count":0},{"had_liked":false,"id":51799,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1545264105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545264105","product_id":100017301,"comment_content":"golang的channel的底层实现也是个环形链表，我以前还奇怪为毛是环形链表，现在略懂了，谢谢老师让我以后出去多了一个吹牛逼的技能","like_count":0},{"had_liked":false,"id":51577,"user_name":"逾清风","can_delete":false,"product_type":"c1","uid":1275452,"ip_address":"","ucode":"B23D93E57C916D","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/3c/c65912b7.jpg","comment_is_top":false,"comment_ctime":1545202729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545202729","product_id":100017301,"comment_content":"王老师，队列这节课GitHub上的python代码有错误（09_queue&#47;circular_queue.py）。在每次enqueue的时候使用了append用法，这个用法是每次在list最后添加一个元素，list 的长度一直在增长，因此不能构成循环链表。<br>我的思路：定义队列长度，初始化self._items=[None]*self._capacity， 然后每次enqueue的操作变为：self._items[self._tail] = item,   self._tail = (self._tail+1) % self.capacity，来实现循环队列。My GitHub：https:&#47;&#47;github.com&#47;xuguangshu&#47;Myalgorithm&#47;tree&#47;master&#47;09_queue<br>谢谢！","like_count":0},{"had_liked":false,"id":51142,"user_name":"keshawn","can_delete":false,"product_type":"c1","uid":1319270,"ip_address":"","ucode":"CFCC24F58D1651","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/66/f9125286.jpg","comment_is_top":false,"comment_ctime":1545120463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545120463","product_id":100017301,"comment_content":"贴一个自己实现的循环数组队列：<br>public class CycleArrayQueue&lt;T&gt; implements Queue&lt;T&gt; {<br><br>    private static final int DEFAULT_SIZE = 16;<br><br>    private Object[] items;<br><br>    private int header;<br><br>    private int tail;<br><br>    public CycleArrayQueue() {<br>        items = new Object[DEFAULT_SIZE];<br>    }<br><br>    public CycleArrayQueue(int size) {<br>        items = new Object[size];<br>    }<br><br>    @Override<br>    public Boolean enqueue(T t) {<br>        if (isFull()) return Boolean.FALSE;<br>        items[tail++] = t;<br>        tail = tail % items.length;<br>        return Boolean.TRUE;<br>    }<br><br>    private boolean isFull() {<br>        &#47;&#47; tail的下一位应该是header，因为队列是循环的，所以取余<br>        return (tail + 1) % items.length == header;<br>    }<br><br>    @Override<br>    @SuppressWarnings(&quot;unchecked&quot;)<br>    public T dequeue() {<br>        if (header == tail) return null;<br>        T date = (T) items[header];<br>        items[header] = null;<br>        header = ++header % items.length;<br>        return date;<br>    }<br>}","like_count":0},{"had_liked":false,"id":50684,"user_name":"海军陆战队","can_delete":false,"product_type":"c1","uid":1134101,"ip_address":"","ucode":"EEB5336AE4E980","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/15/189686da.jpg","comment_is_top":false,"comment_ctime":1545029530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545029530","product_id":100017301,"comment_content":"Java 中的 ExecutorService 内部也使用了队列，当没有可用线程用于处理提交的任务时，将任务放到队列中等待","like_count":0},{"had_liked":false,"id":49082,"user_name":"被吹落的风","can_delete":false,"product_type":"c1","uid":1242309,"ip_address":"","ucode":"AF62645E386A7B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/c5/39f2acfd.jpg","comment_is_top":false,"comment_ctime":1544600548,"is_pvip":false,"replies":[{"id":"17731","content":"效率就低了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544666364,"ip_address":"","comment_id":49082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544600548","product_id":100017301,"comment_content":"顺序队列在出列的时候为什么不能够直接删除该条数据（数组永远删除第一条，后面自动往前移）？入队的时候再往回继续追加，这样也能避免循环队列的复杂逻辑计算了，当然，这样会有一定的数据迁移的问题。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432478,"discussion_content":"效率就低了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544666364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48462,"user_name":"eason","can_delete":false,"product_type":"c1","uid":1340823,"ip_address":"","ucode":"0B4D5627AAE4CF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlSe5wRWM6EnVpVOkmJ9HoBpBaqgQK7ZYlAsVl40CVs0picrma5Aq90ffiaAUBHra1Idag4KyBSCXA/132","comment_is_top":false,"comment_ctime":1544448514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544448514","product_id":100017301,"comment_content":"activeMq中的消息队列也算一种队列。不清楚数据库连接池是否也算一种队列。<br><br>CAS实现无锁队列，入队是判断tail节点是否变化，是的话入队。出队时获取head节点","like_count":0},{"had_liked":false,"id":48270,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544408252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544408252","product_id":100017301,"comment_content":"没有听过的名词<br>CAS,compare and swap的缩写，中文翻译成比较并交换。<br><br>来历：队列嘛，排队嘛，先进先出（是一种受限的线性数据结构）<br>特点：数组队列，链式队列------两个的主要区别是否有一个长度限制<br>适合解决的问题：循环（循环并发队列）-----成功避开数组队列中的数据搬移工作;阻塞、并发<br>实际应用：线程池队列<br><br>问答：1、android中 handler message队列<br>2、看评论中很多人使用CAS,第一次听说CAS;","like_count":0},{"had_liked":false,"id":46401,"user_name":"咕咕","can_delete":false,"product_type":"c1","uid":1153140,"ip_address":"","ucode":"D0A4CCE145A4F2","user_header":"https://static001.geekbang.org/account/avatar/00/11/98/74/2460c70a.jpg","comment_is_top":false,"comment_ctime":1543916069,"is_pvip":false,"replies":[{"id":"16584","content":"iPad Paper","user_name":"编辑回复","user_name_real":"郭蕾","uid":"1000473","ctime":1543916096,"ip_address":"","comment_id":46401,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1543916069","product_id":100017301,"comment_content":"你好,请问下,文章中的插图是用什么软件画的呢","like_count":0,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431446,"discussion_content":"iPad Paper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543916096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46189,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1543882461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543882461","product_id":100017301,"comment_content":"20181204思考题: <br>1. 消息队列就是一种排队请求.","like_count":0},{"had_liked":false,"id":46108,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1543848270,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543848270","product_id":100017301,"comment_content":"关于队列<br><br>队列特点：先进先出、只能一头进一头出；（同栈一样也是一种受限制的线性数据结构）<br><br>用数组实现的队列叫做顺序队列，用链表实现的队列叫做链式队列。重点掌握链式队列中的循环队列。<br><br>特殊应用队列有：阻塞队列和并发队列。 阻塞队列即当队列满了后就无法进去新的数据，需要有出才能有进。并发队列即多线程时需要考虑对一个队列的上锁问题。<br><br>当线程池已满，又有新的资源请求线程时如何处理？一般两种，一种直接拒绝请求。一种是请求排队，当有空闲线程后按照排队依次处理，此时就要用到队列，此时又有两种队列可选，一种基于链表，一种基于数组，两种各有利弊，需选择合适的。其实，对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过队列来实现排队请求。","like_count":0},{"had_liked":false,"id":44619,"user_name":"dongdong","can_delete":false,"product_type":"c1","uid":1305580,"ip_address":"","ucode":"25CB9FC6AE7737","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/UqxY58hlwdaypDeLwsjSBfBe2Q7YhZyJniaPEf7Ws7tneSzgQ6js6Uh0KT5FjCBIRUCGyVZ0zsvBUPVz2bK2YWQ/132","comment_is_top":false,"comment_ctime":1543464642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543464642","product_id":100017301,"comment_content":"PHP数组实现队列<br>&lt;?php<br>&#47;**<br> * Created by PhpStorm.<br> * User: Administrator<br> * Date: 2018&#47;11&#47;28<br> * Time: 16:16<br> *&#47;<br><br>class arrayQue<br>{<br>    private $array = [];  &#47;&#47;队列数组<br>    private $largeNum = 0; &#47;&#47;队列容量<br>    private $head = 0;  &#47;&#47;队列头标<br>    private $tail = 0;  &#47;&#47;队列尾标<br>    &#47;**<br>     * 初始化变量<br>     *&#47;<br>    public function __construct($array,$largeNum,$head,$tail)<br>    {<br>        $this-&gt;array = $array;<br>        $this-&gt;num   = $largeNum;<br>        $this-&gt;head  = $head;<br>        $this-&gt;tail  = $tail;<br>    }<br>    <br>    public function enqueue($item){<br>        &#47;&#47;tail = num 队列末尾没有空间<br>        if($this-&gt;tail == $this-&gt;num){<br>            &#47;&#47;if tail=num &amp;&amp; head=0 表示队列都占满了<br>            if($this-&gt;head == 0) return false;<br>            &#47;&#47;数据搬移<br>            for ($i=$this-&gt;head;$i&lt;$this-&gt;tail;++$i){<br>                $this-&gt;array[$i-$this-&gt;head] = $this-&gt;array[$i];<br>            }<br>            &#47;&#47;var_dump($this-&gt;array);<br>        }<br>        $this-&gt;array[$this-&gt;tail] = $item;<br>        ++$this-&gt;tail;<br>        var_dump($this-&gt;array);<br>        return true;<br>    }<br><br>    &#47;&#47;出队列<br>    public function dequeue(){<br>        &#47;&#47;头和尾相等，队列中为空<br>        if($this-&gt;head == $this-&gt;tail) return null;<br>        $ret = $this-&gt;array[&quot;$this-&gt;head&quot;];<br>        ++$this-&gt;head;<br>        return $ret;<br>    }<br>}","like_count":0},{"had_liked":false,"id":44224,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1543388985,"is_pvip":false,"replies":[{"id":"15770","content":"看看留言吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543403510,"ip_address":"","comment_id":44224,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543388985","product_id":100017301,"comment_content":"王老师你好，为什么循环队列的实现中，要浪费一个空间，这个地方不太明白，望指教！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430685,"discussion_content":"看看留言吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543403510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43240,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1543198610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543198610","product_id":100017301,"comment_content":"有人说“队列是吃多了拉，栈是吃多了吐，也不是那么好记嘛！不如换个说法好记点，队列有肛，这口进另一口出，栈无肛，这口进这口出。","like_count":0},{"had_liked":false,"id":42453,"user_name":"Jay_he","can_delete":false,"product_type":"c1","uid":1132216,"ip_address":"","ucode":"F9D2F64544CDF2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtg22VEsXWcGCQoK2rAd12JZPqG0sgkqk1osQmxZsjHYPI5Ezsiaic7FM3tgyXwuMmtKmt2LZoZ7bQ/132","comment_is_top":false,"comment_ctime":1542956773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542956773","product_id":100017301,"comment_content":"用数组实现队列时，当队列满的时候为什么不做扩容呢？","like_count":0},{"had_liked":false,"id":41981,"user_name":"Jeff","can_delete":false,"product_type":"c1","uid":1316265,"ip_address":"","ucode":"B5C07DA4877388","user_header":"https://static001.geekbang.org/account/avatar/00/14/15/a9/800757d8.jpg","comment_is_top":false,"comment_ctime":1542885844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542885844","product_id":100017301,"comment_content":"自己实现了下无锁循环队列：<br>public class MyQueue {<br>    private int capacity;<br>    private String[] queue;<br>    private AtomicInteger head = new AtomicInteger(0);<br>    private AtomicInteger tail = new AtomicInteger(0);<br><br>    public MyQueue(int n){<br>        queue = new String[n];<br>        capacity = n;<br>    }<br>    public boolean intoQueue(String str){<br>        int oldTail;<br>        int newTail;<br>        &#47;&#47;原子操作<br>        do {<br>            oldTail = tail.intValue();<br>            &#47;&#47;队列满<br>            if ((oldTail + 1) % capacity == head.intValue()) {<br>                return false;<br>            }<br>            newTail = (oldTail + 1) % capacity;<br>        }while (!tail.compareAndSet(oldTail,newTail));<br>        queue[oldTail] = str;<br>        System.out.println(&quot;into target=&quot; + oldTail);<br>        return true;<br>    }<br><br>    public String outQueue(){<br>        int oldHead;<br>        int newHead;<br>        &#47;&#47;原子操作<br>        do{<br>            oldHead = head.intValue();<br>            &#47;&#47;队列空<br>            if (tail.intValue()==oldHead){<br>                return null;<br>            }<br>            newHead = (oldHead+1)%capacity;<br>        }while (!head.compareAndSet(oldHead,newHead));<br>        System.out.println(&quot;head=&quot;+oldHead);<br>        String tmp = queue[oldHead];<br>        return tmp;<br>    }<br>}","like_count":0},{"had_liked":false,"id":40972,"user_name":"Martin ","can_delete":false,"product_type":"c1","uid":1186025,"ip_address":"","ucode":"6BF9FE945D396A","user_header":"https://static001.geekbang.org/account/avatar/00/12/18/e9/4242ee4a.jpg","comment_is_top":false,"comment_ctime":1542706773,"is_pvip":false,"replies":[{"id":"14802","content":"多加一个数据 所以tail要加一<br>判断满不满的条件是拿tail与head比较 你再看下文章","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542765934,"ip_address":"","comment_id":40972,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542706773","product_id":100017301,"comment_content":"王老师有几个问题：<br> 1.在循环队列的时候,在tail = (tail+1)%n , 这个怎么理解呢？<br>   * +1是因为会始终多一个空间的意思吗？<br>   *  模N==0意思就是他就是代表他已经存满一圈了吗？<br><br> 2.阻塞队列和并发队列什么时候说呢?感觉很重要，很多框架都在使用。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429664,"discussion_content":"多加一个数据 所以tail要加一\n判断满不满的条件是拿tail与head比较 你再看下文章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542765934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40823,"user_name":"。。。","can_delete":false,"product_type":"c1","uid":1267092,"ip_address":"","ucode":"F4D90A500B66D3","user_header":"https://static001.geekbang.org/account/avatar/00/13/55/94/cefb8a05.jpg","comment_is_top":false,"comment_ctime":1542679635,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542679635","product_id":100017301,"comment_content":"无锁队列 先获取 head 或 tail Node temp = head; 然后 casHead(temp, temp.next); 成功就将 temp 返回 失败就while 再取; tail 同理","like_count":0},{"had_liked":false,"id":40090,"user_name":"zhStark","can_delete":false,"product_type":"c1","uid":1238043,"ip_address":"","ucode":"25E97E74A37AF0","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/1b/73e0f5f1.jpg","comment_is_top":false,"comment_ctime":1542472881,"is_pvip":false,"replies":[{"id":"14493","content":"会的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542589408,"ip_address":"","comment_id":40090,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542472881","product_id":100017301,"comment_content":"之后会不会讲优先队列呢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429367,"discussion_content":"会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542589408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39518,"user_name":"活的精彩","can_delete":false,"product_type":"c1","uid":1200661,"ip_address":"","ucode":"A076FBCC9C7AD8","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/15/268a4a6f.jpg","comment_is_top":false,"comment_ctime":1542294254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542294254","product_id":100017301,"comment_content":"这种实现思路中，出队操作的时间复杂度仍然是 O(1)，但入队操作的时间复杂度还是 O(1) 吗？<br>时间复杂度是o(n)吧？","like_count":0},{"had_liked":false,"id":39185,"user_name":"蓝色理想","can_delete":false,"product_type":"c1","uid":1015043,"ip_address":"","ucode":"43C8D83DC19A17","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/03/4e71c307.jpg","comment_is_top":false,"comment_ctime":1542205536,"is_pvip":false,"replies":[{"id":"14044","content":"可以忽略 因为专栏面对的是不同层次的同学 可能会有些外延的知识 跟数据结构和算法没太多直接的关系。可以忽略","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542247185,"ip_address":"","comment_id":39185,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542205536","product_id":100017301,"comment_content":"Cas什么意思啊？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428957,"discussion_content":"可以忽略 因为专栏面对的是不同层次的同学 可能会有些外延的知识 跟数据结构和算法没太多直接的关系。可以忽略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542247185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38173,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1153239,"ip_address":"","ucode":"459D3303717703","user_header":"https://static001.geekbang.org/account/avatar/00/11/98/d7/7f7a0e6f.jpg","comment_is_top":false,"comment_ctime":1541983315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541983315","product_id":100017301,"comment_content":"jdk自带的基于优先级队列的线程池在实践过程中会出现低优先级任务一直得不到处理，出现所谓的饿死情况，不知道王老师和各位同学能否提供些改进的思路","like_count":0},{"had_liked":false,"id":38068,"user_name":"lcp","can_delete":false,"product_type":"c1","uid":1147461,"ip_address":"","ucode":"3C9975BFF7654E","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/45/981ac8ab.jpg","comment_is_top":false,"comment_ctime":1541916632,"is_pvip":false,"replies":[{"id":"13709","content":"如果tail=n-1 head=0呢？而且判断条件是tail+1==head吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541986755,"ip_address":"","comment_id":38068,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541916632","product_id":100017301,"comment_content":"环形队列，如果用数组实现，为什么需要对n求余？tail-1 == head判断是否队列满的话会有什么问题？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428589,"discussion_content":"如果tail=n-1 head=0呢？而且判断条件是tail+1==head吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541986755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37757,"user_name":"inNovation","can_delete":false,"product_type":"c1","uid":1026063,"ip_address":"","ucode":"C150C5C9186D2A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/0f/9f657edc.jpg","comment_is_top":false,"comment_ctime":1541724849,"is_pvip":false,"replies":[{"id":"13594","content":"很多语言默认不支持的 而且也无法完全避免堆栈溢出","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541728700,"ip_address":"","comment_id":37757,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541724849","product_id":100017301,"comment_content":"防止栈溢出上.有些语言会对尾递归做优化，所以 如果可以写尾递归最好了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428478,"discussion_content":"很多语言默认不支持的 而且也无法完全避免堆栈溢出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541728700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37676,"user_name":"Quasimodo","can_delete":false,"product_type":"c1","uid":1232165,"ip_address":"","ucode":"38408011C5517D","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/25/5684bf48.jpg","comment_is_top":false,"comment_ctime":1541673750,"is_pvip":false,"replies":[{"id":"13591","content":"😄 就当没看见 别纠结这点不重要的东西  专栏的读者分各个层次 作为小白 就选择看懂基础的就好 日后随着开发经验的增多 再回过头来看","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541728275,"ip_address":"","comment_id":37676,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541673750","product_id":100017301,"comment_content":"谁能告诉我这个小白，你们说的CAS是啥吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428444,"discussion_content":"😄 就当没看见 别纠结这点不重要的东西  专栏的读者分各个层次 作为小白 就选择看懂基础的就好 日后随着开发经验的增多 再回过头来看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541728275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37424,"user_name":"花仙子","can_delete":false,"product_type":"c1","uid":1249216,"ip_address":"","ucode":"9840BF416F1F0F","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/c0/e6151cce.jpg","comment_is_top":false,"comment_ctime":1541581636,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541581636","product_id":100017301,"comment_content":"循环队列用数组实现时，判断队列已满的条件可不可以是，tail &lt; head且tail + 1 == head, 并上head == 0且tail == n,两种情况，因为是环形，当head &lt; tail时，当尾巴追上头部时就说明满了。","like_count":0},{"had_liked":false,"id":37030,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1541426428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541426428","product_id":100017301,"comment_content":"针对上面@王威人同学的思路，实现下面的代码：<br>public class SimpleLoopQueue&lt;E&gt; implements Queue&lt;E&gt; {<br><br>    private E[] data;<br><br>    &#47;**<br>     * 指向第一个元素的索引<br>     *&#47;<br>    private int head;<br><br>    &#47;**<br>     * 指向最后一个元素的索引<br>     *&#47;<br>    private int tail;<br><br>    &#47;**<br>     * 元素个数<br>     *&#47;<br>    private int size;<br><br>    public SimpleLoopQueue(int capacity) {<br>        this.data = (E[]) new Object[capacity];<br>        this.head = 0;<br>        this.tail = 0;<br>    }<br><br>    public SimpleLoopQueue() {<br>        this(8);<br>    }<br><br><br>    &#47;**<br>     * 入队<br>     *<br>     * @param e<br>     *&#47;<br>    @Override<br>    public void enqueue(E e) {<br>        if (size == data.length - 1) {<br>            throw new IllegalArgumentException(&quot;循环队列已满&quot;);<br>        }<br>        if (tail == data.length - 1) {<br>            tail = 0;<br>        } else {<br>            tail++;<br>        }<br>        data[tail] = e;<br>        size++;<br>    }<br><br>    &#47;**<br>     * 出队<br>     *<br>     * @return<br>     *&#47;<br>    @Override<br>    public E dequeue() {<br>        if (isEmpty()) {<br>            throw new IllegalArgumentException(&quot;循环队列为空&quot;);<br>        }<br>        E ret = data[head];<br>        size--;<br>        head++;<br>        return ret;<br>    }<br><br>    &#47;**<br>     * 获取队首元素<br>     *<br>     * @return<br>     *&#47;<br>    @Override<br>    public E getFront() {<br>        if (isEmpty()) {<br>            throw new IllegalArgumentException(&quot;循环队列为空&quot;);<br>        }<br>        return data[head];<br>    }<br><br>    &#47;**<br>     * 获取队列元素个数<br>     *<br>     * @return<br>     *&#47;<br>    @Override<br>    public int getSize() {<br>        return size;<br>    }<br><br>    &#47;**<br>     * 判断队列是否为空<br>     *<br>     * @return<br>     *&#47;<br>    @Override<br>    public boolean isEmpty() {<br>        return head == tail;<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":36999,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1541415961,"is_pvip":false,"replies":[{"id":"13250","content":"加油💪","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541467968,"ip_address":"","comment_id":36999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541415961","product_id":100017301,"comment_content":"最近在仔细的理解老师的课程，可能进度跟不上最新的，我会加油，不会囫囵吞枣的学习。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428117,"discussion_content":"加油💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541467968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36997,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1541415838,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541415838","product_id":100017301,"comment_content":"数组实现的队列也可以无限扩容，思路就是类似于Java的ArrayList，当数组空间不够，直接申请一个原先数组2倍或者其他倍数的新的数组。","like_count":0},{"had_liked":false,"id":36914,"user_name":"七仔","can_delete":false,"product_type":"c1","uid":1220226,"ip_address":"","ucode":"BD3F5943383E56","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/82/4ca45468.jpg","comment_is_top":false,"comment_ctime":1541386302,"is_pvip":false,"replies":[{"id":"13267","content":"没感觉草率 不好意思！","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1541468475,"ip_address":"","comment_id":36914,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541386302","product_id":100017301,"comment_content":"环形对列判断队列满给出的结果真是草率，没有一点过程，直接就是发现这样，所以这样，这样讲算法真的没意思，算法不是直接从天上掉下来的，希望作者能虚心接受。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428084,"discussion_content":"没感觉草率 不好意思！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541468475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35828,"user_name":"小老鼠","can_delete":false,"product_type":"c1","uid":1257460,"ip_address":"","ucode":"C663A0C863A515","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/f4/2dede51a.jpg","comment_is_top":false,"comment_ctime":1540817218,"is_pvip":false,"replies":[{"id":"12835","content":"是的呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540951097,"ip_address":"","comment_id":35828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540817218","product_id":100017301,"comment_content":"LoadRunner 的基于Web并发测试，若当一个事务系统最多可以处理的并发数为10000个，当再上来了十个并发数，Web服务器是不是通过队例来排队的？另外队伍的长度是不是由web server决定？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427680,"discussion_content":"是的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540951097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35629,"user_name":"我就是我","can_delete":false,"product_type":"c1","uid":1117184,"ip_address":"","ucode":"F3B36692941FC9","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/00/b0b95590.jpg","comment_is_top":false,"comment_ctime":1540717697,"is_pvip":false,"replies":[{"id":"12674","content":"不可以的 你自己几个例子画画看看","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540740113,"ip_address":"","comment_id":35629,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540717697","product_id":100017301,"comment_content":"循环队列：队列满了<br>if ((tail + 1) % n == head） return false;<br>这个直接判断  (tail + 1）== head 是不是就可以了?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427605,"discussion_content":"不可以的 你自己几个例子画画看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540740113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35231,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1540470246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540470246","product_id":100017301,"comment_content":"您好，看了这章节的课程，对于这个循环队列我觉得非常的实用，所以，我自己动手实践了一个环形无锁的并发队列，希望得到老师您的指正，谢谢！<br><br>代码我也上传了git<br>https:&#47;&#47;github.com&#47;kkzfl22&#47;datastruct.git<br>欢迎大家一起讨论！<br><br>&#47;**<br> * 并发循环队列，使用数组来实现<br> *<br> * @author kkzfl<br> * @version 0.0.1<br> * @date 2018&#47;10&#47;24<br> *&#47;<br>public class ArrayBlockCircleQueue {<br><br>  &#47;** 数据类型 *&#47;<br>  private int[] data;<br><br>  &#47;** 当前写入的位置 *&#47;<br>  private final AtomicInteger tail;<br><br>  &#47;** 头位置 *&#47;<br>  private final AtomicInteger head;<br><br>  &#47;** 容量 *&#47;<br>  private int capacity;<br><br>  public ArrayBlockCircleQueue(int capacity) {<br>    this.data = new int[capacity];<br>    this.tail = new AtomicInteger(0);<br>    this.head = new AtomicInteger(0);<br>    this.capacity = capacity;<br>  }<br><br>  public void print() {<br>    System.out.print(Arrays.toString(data));<br>  }<br><br>  &#47;**<br>   * 放入数据<br>   *<br>   * @param value 值信息<br>   *&#47;<br>  public boolean push(int value) {<br>    &#47;&#47; 检查是否队列已经满,即当下一个存储的值为道节点，即为队列已经满了<br>    if ((tail.get() + 1) % capacity == head.get()) {<br>      return false;<br>    }<br><br>    int tailValue = tail.get();<br>    int updValue = (tailValue + 1) % capacity;<br><br>    if (tail.compareAndSet(tailValue, updValue)) {<br>      this.data[tailValue] = value;<br>      return true;<br>    }<br><br>    return false;<br>  }<br><br>  &#47;**<br>   * 从循环队列中获取数据<br>   *<br>   * @return 结果值<br>   *&#47;<br>  public int pop() {<br>    &#47;&#47; 首先检查队列是否为空<br>    if (tail.get() == head.get()) {<br>      return -1;<br>    }<br><br>    int popBefore = head.get();<br>    int popAfter = (popBefore + 1) % capacity;<br><br>    if (head.compareAndSet(popBefore, popAfter)) {<br>      int value = this.data[popBefore];<br>      return value;<br>    }<br><br>    return -1;<br>  }<br>}<br><br>","like_count":0},{"had_liked":false,"id":35212,"user_name":"Grit","can_delete":false,"product_type":"c1","uid":1026524,"ip_address":"","ucode":"509CB733D6DA56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a9/dc/e02990c3.jpg","comment_is_top":false,"comment_ctime":1540461556,"is_pvip":false,"replies":[{"id":"12571","content":"两种写法一样<br>第二个问题没看出有啥毛病啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540516013,"ip_address":"","comment_id":35212,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540461556","product_id":100017301,"comment_content":" 为啥是++tail;不是tail++,<br>数据搬移那块代码和图中的数据代入对不上啊i=head=3;i&lt;8;++i;items[i-head]=items[1] 把下标为4的元素放到了下标为1的位置？<br>求解","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427479,"discussion_content":"两种写法一样\n第二个问题没看出有啥毛病啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540516013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35201,"user_name":"ForzaJuve","can_delete":false,"product_type":"c1","uid":1047302,"ip_address":"","ucode":"E090D83AE78EE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/06/0e6b6365.jpg","comment_is_top":false,"comment_ctime":1540458254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540458254","product_id":100017301,"comment_content":"队列就像我们实际生活中的排队买票的队列场景一样，最重要的特点就是先进先出<br>跟栈一样，也是一种操作受限的线性表数据结构。<br><br>队列用数组和链表的两种实现方式<br>循环队列的介绍以及实现，循环队列可避免数据搬移，当队满时，(tail+1)%n=head<br>阻塞队列可以轻松实现一个生产者消费者模型<br>大部分资源有限的场景，当没有空闲资源的时候，基本都可以用队列来实现，比如线程池请求排队<br>在直播软件中送礼物的场景就是一个队列的场景，先送的礼物先播放，只有两个礼物轨道，后送的排队等待。","like_count":0},{"had_liked":false,"id":34634,"user_name":"王伟zzz","can_delete":false,"product_type":"c1","uid":1023443,"ip_address":"","ucode":"F2BADC0EA6CD6A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/d3/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1540226964,"is_pvip":false,"replies":[{"id":"12314","content":"不懂php 呼唤其他小伙伴回答","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540255361,"ip_address":"","comment_id":34634,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540226964","product_id":100017301,"comment_content":"请教 php的function 方法可以加方法锁吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427277,"discussion_content":"不懂php 呼唤其他小伙伴回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540255361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34255,"user_name":"李靖峰","can_delete":false,"product_type":"c1","uid":1139247,"ip_address":"","ucode":"AA4DE3E91A1FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/2f/6fe8ee9e.jpg","comment_is_top":false,"comment_ctime":1540048772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540048772","product_id":100017301,"comment_content":"golang的channel就是阻塞+并发队列","like_count":0},{"had_liked":false,"id":34040,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1539961726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539961726","product_id":100017301,"comment_content":"队列: 实现方式有数组（顺序队列）、链表（链式队列）。<br><br>顺序队列涉及到数据移位操作，当入队到最后一位时再进行移数据，时间复杂度均摊后只有o1了。循环队列更好，根本不用移位。<br>链式队列是无限队列，但其实不适合响应时间较低的程序。<br><br>除此之外还有阻塞队列，线程池就是当线程没有空闲时，利用阻塞队列排队等待的请求。这个在请求框架中真的用的很多。还有就是并发队列，这个会涉及到 生产-消费 模型，可以有多个线程去取队列中的任务，但是需要锁来控制，这个又是一个很大的技术方向。<br><br>细细想来，队列在底层用的真不少，Handler里就有用消息队列。","like_count":0},{"had_liked":false,"id":33774,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1539878508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539878508","product_id":100017301,"comment_content":"Mark 一下，学习完毕。关于最后的两个思考题，看了同学们的发言，知道了队列应用场景还有如 分布式消息队列、Redis消息队列等，无锁并发队列还可以利用 CAS 原子操作来实现。。","like_count":0},{"had_liked":false,"id":33562,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1539825858,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1539825858","product_id":100017301,"comment_content":"循环队列的队满的判断可以理解为，tail的下一个节点是不是head。tail的下一个节点是(tail + 1) % n。","like_count":0},{"had_liked":false,"id":33468,"user_name":"大坏蛋","can_delete":false,"product_type":"c1","uid":1240376,"ip_address":"","ucode":"E5728F85273D14","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/38/217ecccb.jpg","comment_is_top":false,"comment_ctime":1539789437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539789437","product_id":100017301,"comment_content":"入队操作最好时间复杂度O(1)，最坏时间复杂度O(n)，最坏情况，紧接着有k次O(1)时间复杂度的数据搬移操作，均摊时间复杂度O(1).<br>希望老师答疑，谢谢！","like_count":0},{"had_liked":false,"id":32780,"user_name":"诺木人","can_delete":false,"product_type":"c1","uid":1057640,"ip_address":"","ucode":"3962DDB413B644","user_header":"https://static001.geekbang.org/account/avatar/00/10/23/68/6099a0f1.jpg","comment_is_top":false,"comment_ctime":1539696483,"is_pvip":false,"replies":[{"id":"11937","content":"那应该是几？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539701371,"ip_address":"","comment_id":32780,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539696483","product_id":100017301,"comment_content":"循环队列中  （3+1）% 8 = 4 这个计算是求余吧？应该不是4哈","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426891,"discussion_content":"那应该是几？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539701371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32681,"user_name":"林","can_delete":false,"product_type":"c1","uid":1079783,"ip_address":"","ucode":"BFB14F03283C70","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKY0SBAOch2S7wadCRFKTT5fBtXCvsa46svoTj2MWoQ9YRrujZuq4wEHjS9dCEzPcrWHNSYgUkNVw/0","comment_is_top":false,"comment_ctime":1539662153,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539662153","product_id":100017301,"comment_content":"循环队列的代码写的太帅了","like_count":0},{"had_liked":false,"id":32640,"user_name":"行走着的宋公子","can_delete":false,"product_type":"c1","uid":1002416,"ip_address":"","ucode":"3FA47B1580A327","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/b0/2ae78627.jpg","comment_is_top":false,"comment_ctime":1539655455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539655455","product_id":100017301,"comment_content":"React 中setState是队列","like_count":0},{"had_liked":false,"id":32629,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1539652170,"is_pvip":false,"replies":[{"id":"11948","content":"移动指针就够了 没必要显示的删除啊","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539703259,"ip_address":"","comment_id":32629,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539652170","product_id":100017301,"comment_content":"a,b,c,d入队，然后a，b出队，实际上a,b仍然在数组中吧？  只是指针右移了，第二张图是不是不恰当？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426843,"discussion_content":"移动指针就够了 没必要显示的删除啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539703259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32609,"user_name":"大鱼","can_delete":false,"product_type":"c1","uid":1063966,"ip_address":"","ucode":"56DFE1B066A32C","user_header":"https://static001.geekbang.org/account/avatar/00/10/3c/1e/f0434e80.jpg","comment_is_top":false,"comment_ctime":1539642446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539642446","product_id":100017301,"comment_content":"环形队列如果元素的个数是2的倍数,计算可用长度的高效算法是 ((cb-&gt;iWrite - cb-&gt;iRead) &amp; (cb-&gt;iSize - 1));<br>下面是我基于c的实现<br>ringb.h<br>```c<br>#ifndef _RINGB_H  <br>#define _RINGB_H  <br>#include &quot;project.h&quot;<br><br> typedef struct {<br>     uint8_t  *buf;<br>     uint8_t  iSize;<br>     uint8_t  iRead;<br>     uint8_t  iWrite;<br> } ringbf_t;<br> <br> uint8_t bfLength(ringbf_t *cb);<br> uint8_t bfRead(ringbf_t *cb, uint8_t *ch);<br> uint8_t bfWrite(ringbf_t *cb, uint8_t c);<br> void bfInit(ringbf_t *cb, uint8_t *pool, uint8_t iSize);<br>#endif &#47;* _RINGB_H *&#47; <br>```<br>``` c<br>#include &quot;ringb.h&quot;<br>#include &quot;assert.h&quot;<br><br>uint8_t bfLength(ringbf_t* cb)<br>{<br>    return ((cb-&gt;iWrite - cb-&gt;iRead) &amp; (cb-&gt;iSize - 1));<br>}<br><br>uint8_t bfWrite(ringbf_t* cb, uint8_t c)<br>{<br>    if (bfLength(cb) == (cb-&gt;iSize - 1)) {<br>        return false;<br>    }<br><br>    cb-&gt;buf[cb-&gt;iWrite] = c;<br>    cb-&gt;iWrite = (cb-&gt;iWrite + 1) &amp; (cb-&gt;iSize - 1);<br>    return true;<br>}<br><br>uint8_t bfRead(ringbf_t* cb, uint8_t* ch)<br>{<br>    if (bfLength(cb) == 0) {<br>        return false;<br>    }<br>    * ch = cb-&gt;buf[cb-&gt;iRead];<br>    cb-&gt;iRead = (cb-&gt;iRead + 1) &amp; (cb-&gt;iSize - 1);<br>    <br>    return true;<br>}<br><br>void bfInit(ringbf_t* cb, uint8_t* pool, uint8_t iSize)<br>{<br>    assert((iSize &gt; 1) &amp;&amp; (0 == (iSize &amp; (iSize - 1))));<br>    cb-&gt;buf = pool;<br>    cb-&gt;iSize = iSize;<br><br>}<br><br>```","like_count":0},{"had_liked":false,"id":32504,"user_name":"静觅","can_delete":false,"product_type":"c1","uid":1237102,"ip_address":"","ucode":"1B44469E63DDFD","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/6e/62719b08.jpg","comment_is_top":false,"comment_ctime":1539593835,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539593835","product_id":100017301,"comment_content":"循环队列满的判断条件head=(tail+1)%capacity，在这个if里面完成tail这个浪费的空间的入队操作，同时设置一个flag表示队满，再次调用enqueue先判断flag如果队列满，则直接返回，在dequeue中出队后修改flag，感觉这样可以避免一个空间的浪费","like_count":0},{"had_liked":false,"id":32378,"user_name":"咖啡猫口里的咖啡猫🐱","can_delete":false,"product_type":"c1","uid":1036565,"ip_address":"","ucode":"FE2441B3A40375","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d1/15/7d47de48.jpg","comment_is_top":false,"comment_ctime":1539563239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539563239","product_id":100017301,"comment_content":"为什么数组实现的队列不能循环只要把下标index处理好不就行了吗，为什么arraylist这种数组实现才用systemcopy,不理解，感觉控制好index就行了","like_count":0},{"had_liked":false,"id":32288,"user_name":"liu","can_delete":false,"product_type":"c1","uid":1129567,"ip_address":"","ucode":"DA9F9FBD96A9A0","user_header":"https://static001.geekbang.org/account/avatar/00/11/3c/5f/cc30c10c.jpg","comment_is_top":false,"comment_ctime":1539512302,"is_pvip":false,"replies":[{"id":"11742","content":"自己百度下吧 ","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528016,"ip_address":"","comment_id":32288,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539512302","product_id":100017301,"comment_content":"老师，CAS是什么？不太明白","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426714,"discussion_content":"自己百度下吧 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32266,"user_name":"kaoker","can_delete":false,"product_type":"c1","uid":1115225,"ip_address":"","ucode":"499060AE9A4B2C","user_header":"","comment_is_top":false,"comment_ctime":1539506012,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539506012","product_id":100017301,"comment_content":"1.rabbitmq 消息队列<br>2.compare and swap...乐观锁策略,队列还要好好想想","like_count":0},{"had_liked":false,"id":32253,"user_name":"我能走多远","can_delete":false,"product_type":"c1","uid":1240465,"ip_address":"","ucode":"07DF5D5DADFA3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","comment_is_top":false,"comment_ctime":1539499759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539499759","product_id":100017301,"comment_content":"顺序循环队列，当队列满时，图中的 tail 指向的位置实际上不会存储空闲...<br>可以增加一个变量num。报文当前循环队列存储的数据大小；可以通过num = 0；队列为0，num= size（队列大小）时，队列满；这样就不会浪费一个空间。变量num可能就增加了一个空间。","like_count":0},{"had_liked":false,"id":32198,"user_name":"Mr.钧👻","can_delete":false,"product_type":"c1","uid":1249939,"ip_address":"","ucode":"D781E030E79245","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/93/3470fc43.jpg","comment_is_top":false,"comment_ctime":1539482290,"is_pvip":false,"replies":[{"id":"11749","content":"你觉得应该指向哪里呢？3吗？也可以的，看你怎么实现的了。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528461,"ip_address":"","comment_id":32198,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539482290","product_id":100017301,"comment_content":"请问，为什么当数组实现的队列中有a b c d四个值的时候，tail是指向索引为4的空间呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426678,"discussion_content":"你觉得应该指向哪里呢？3吗？也可以的，看你怎么实现的了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32160,"user_name":"sarahsnow","can_delete":false,"product_type":"c1","uid":1249446,"ip_address":"","ucode":"63D0832C4F75CA","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/a6/564f9143.jpg","comment_is_top":false,"comment_ctime":1539446655,"is_pvip":false,"replies":[{"id":"11758","content":"反正是入不了队了 至于是否报错 看你自己的需求吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539528896,"ip_address":"","comment_id":32160,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539446655","product_id":100017301,"comment_content":"用数组实现队列时，如果队列满时，队列总长等于数组长度，是否入队操作就会报错?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426659,"discussion_content":"反正是入不了队了 至于是否报错 看你自己的需求吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539528896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32127,"user_name":"学渣！！！","can_delete":false,"product_type":"c1","uid":1224654,"ip_address":"","ucode":"A224265D9E7CCC","user_header":"https://static001.geekbang.org/account/avatar/00/12/af/ce/d7ae8da9.jpg","comment_is_top":false,"comment_ctime":1539424532,"is_pvip":false,"replies":[{"id":"11763","content":"你这样子的话，队列空和满的判断条件就一样的，不信你自己写写看","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539529259,"ip_address":"","comment_id":32127,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539424532","product_id":100017301,"comment_content":"public boolean enqueue(String item){<br>    &#47;&#47;队列满了<br>   if((tail+1)%n == head) return false;<br>   items[tail] = item;<br>   tail = (tail+1)%n;<br>   return true;<br>}<br>老师，有一点不太明白，为什么循环队列的最后一个结点不能存值呢？<br>我可以先给它赋值： items[tail] = item;<br>然后再进行判断队列是否满，这样最后一个结点是不是也可以保存值了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426645,"discussion_content":"你这样子的话，队列空和满的判断条件就一样的，不信你自己写写看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539529259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32103,"user_name":"乌龙","can_delete":false,"product_type":"c1","uid":1169924,"ip_address":"","ucode":"FD73990DEBA862","user_header":"https://static001.geekbang.org/account/avatar/00/11/da/04/3a83e840.jpg","comment_is_top":false,"comment_ctime":1539416379,"is_pvip":false,"replies":[{"id":"11767","content":"leetcode上练习吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539529428,"ip_address":"","comment_id":32103,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539416379","product_id":100017301,"comment_content":"请问，每节课后，没有习题加以巩固吗？谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426635,"discussion_content":"leetcode上练习吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539529428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32070,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1539402019,"is_pvip":false,"replies":[{"id":"11771","content":"你能具体讲讲如何做到的head = tail = -1吗？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539529884,"ip_address":"","comment_id":32070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539402019","product_id":100017301,"comment_content":"老师你好，LeetCode 上循环队列的数组实现 head = tail = -1 代表为空，队列满的时最后一个也可以存数据。但是文中的循环队列最后一个位置不能存数据，哪种实现更加“官方”呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426625,"discussion_content":"你能具体讲讲如何做到的head = tail = -1吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539529884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32062,"user_name":"黑boy","can_delete":false,"product_type":"c1","uid":1109144,"ip_address":"","ucode":"9CD3C498A6E1D0","user_header":"https://static001.geekbang.org/account/avatar/00/10/ec/98/e8ebdec7.jpg","comment_is_top":false,"comment_ctime":1539399765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539399765","product_id":100017301,"comment_content":"1. 最近在写一个任务调度module，main submit 到message queue，各个worker从消息队列中消费数据。<br>2. cas，入队列时cas判断 tail 是否发生变化，如果没有发生变化则入队列，出队列时，判断对象换成head。","like_count":0},{"had_liked":false,"id":32051,"user_name":"肖小强","can_delete":false,"product_type":"c1","uid":1245065,"ip_address":"","ucode":"A929A8D1DAD3C4","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/89/32e3f682.jpg","comment_is_top":false,"comment_ctime":1539395819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539395819","product_id":100017301,"comment_content":"老师，改造的入队函数enqueue()，只看那个for循环，时间复杂度不应该也是O(n)吗？","like_count":0},{"had_liked":false,"id":32030,"user_name":"A_阿海","can_delete":false,"product_type":"c1","uid":1239200,"ip_address":"","ucode":"5594C992D7E6E9","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/a0/c2daafdb.jpg","comment_is_top":false,"comment_ctime":1539393680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539393680","product_id":100017301,"comment_content":"老师在讲解每个数据结构的时候用实际情况扩展延伸的方式很好，对队列，线程池的理解又加强了一分，而不只是纯粹讲队列这个概念。","like_count":0},{"had_liked":false,"id":31938,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1539334637,"is_pvip":false,"replies":[{"id":"11610","content":"并发队列的实现方式很多，你说的信号量算是一种","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539403477,"ip_address":"","comment_id":31938,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539334637","product_id":100017301,"comment_content":"在计算机显卡驱动中也使用到了队列，是循环队列，上层把GPU cmd传入到ring buffer,显卡会从这段地址读取并运行的。<br>至于并发队列，它的实现是基于底层的mutex semaphore 吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426572,"discussion_content":"并发队列的实现方式很多，你说的信号量算是一种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539403477,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31907,"user_name":"杨智晓 ✟","can_delete":false,"product_type":"c1","uid":1024263,"ip_address":"","ucode":"E3B56F4A38F63D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/07/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539327275,"is_pvip":false,"replies":[{"id":"11602","content":"看起来没问题","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539402459,"ip_address":"","comment_id":31907,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539327275","product_id":100017301,"comment_content":"这样写循环队列有问题吗？不知道会不会有严重bug<br>public class MyQueue {<br><br>    private String[] items;<br><br>    private int head = 0;<br>    private int tail = 0;<br>    private int size = 0;<br>    private int n = 8;<br><br>    public MyQueue(int capacity) {<br>        n = capacity;<br>        items = new String[n];<br>    }<br><br>    public boolean enqueue(String item) {<br>        &#47;&#47; 队满<br>        if (size == n) {<br>            return false;<br>        }<br>        items[tail] = item;<br>        tail = (tail + 1) % n;<br>        size++;<br>        return true;<br>    }<br><br>    public String dequeue() {<br>        &#47;&#47; 队空<br>        if (size == 0) {<br>            return null;<br>        }<br>        String item = items[head];<br>        items[head] = null;<br>        head = (head + 1) % n;<br>        size--;<br>        return item;<br>    }<br>}<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426558,"discussion_content":"看起来没问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539402459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31901,"user_name":"山野刁民","can_delete":false,"product_type":"c1","uid":1191795,"ip_address":"","ucode":"3371E25F6AEFBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/2f/73/00a56a7d.jpg","comment_is_top":false,"comment_ctime":1539325780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539325780","product_id":100017301,"comment_content":"记录下，数组类型的循环队列：<br>数组长度：n，<br>出队操作（记录次数）：iHead，<br>入队操作（同上）：iTail，<br>出队位置：head=iHead%n，<br>入队位置：tail=iTail%n，<br>对空：iHead==iTail，<br>队满：iTail-iHead==n，<br>入队时，先要判断是否队满，0&lt;iTail-iHead&lt;n是正常，tail位置赋值，iTail++，<br>出队时，先要判断是否队空，iHead&lt;iTail是正常，head位置出队，iHead++，<br>如果iHead,iTail过大，可以在每次iHead==n时重新重置下，将tail赋值给iTail，head赋值给iHead，也可以都减n道理一样，没有变量存head和tail用减更好<br>这样的思路话应该可以不用浪费一个位置吧","like_count":0},{"had_liked":false,"id":31900,"user_name":"杨智晓 ✟","can_delete":false,"product_type":"c1","uid":1024263,"ip_address":"","ucode":"E3B56F4A38F63D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/07/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1539325655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539325655","product_id":100017301,"comment_content":"我在想，可不可以这样，n是总数，size是当前数量，每次enqueue就size+1，dequeue就size--，用size==0来判断队空，size==n来判断队满，其他不变，这样可行吗？","like_count":0},{"had_liked":false,"id":31869,"user_name":"h…","can_delete":false,"product_type":"c1","uid":1052539,"ip_address":"","ucode":"E713F11CBA6AB0","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/7b/7c043069.jpg","comment_is_top":false,"comment_ctime":1539315978,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539315978","product_id":100017301,"comment_content":"发现评论区很多大神，看看很有价值，哈哈","like_count":0},{"had_liked":false,"id":31843,"user_name":"Mollmy","can_delete":false,"product_type":"c1","uid":1240282,"ip_address":"","ucode":"8FB950A8B2C804","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/da/903dc59d.jpg","comment_is_top":false,"comment_ctime":1539310249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539310249","product_id":100017301,"comment_content":"循环队列初始head和tail设为-1，在出队的时候会导致空，所以出队后判断一下，空则将head和tail都设为-1，入队的时候判断下head为-1的话就设为0，这样循环队列就放满了","like_count":0},{"had_liked":false,"id":31720,"user_name":"SunshlnW","can_delete":false,"product_type":"c1","uid":1211252,"ip_address":"","ucode":"7B82BBC5F30633","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/74/63563202.jpg","comment_is_top":false,"comment_ctime":1539270248,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539270248","product_id":100017301,"comment_content":"关于并发队列的无界非阻塞队列。","like_count":0},{"had_liked":false,"id":31692,"user_name":"罗爱军","can_delete":false,"product_type":"c1","uid":1114611,"ip_address":"","ucode":"62D5529DDDA8DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/01/f3/233f1287.jpg","comment_is_top":false,"comment_ctime":1539266155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539266155","product_id":100017301,"comment_content":"对于老师说的数组队列满的时候入队操作的时间复杂度，我认为是O（n），比如队列长度定义为n，如果每次出队m个单位，那么没m个插入就需要进行一次数据的搬移，m的取值范围为（1～n），按照概率时间复杂度为O（n&#47;2），也就是O（n）","like_count":0},{"had_liked":false,"id":31689,"user_name":"张飞online","can_delete":false,"product_type":"c1","uid":1249136,"ip_address":"","ucode":"C9787E4B35888C","user_header":"https://static001.geekbang.org/account/avatar/00/13/0f/70/759b1567.jpg","comment_is_top":false,"comment_ctime":1539265256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539265256","product_id":100017301,"comment_content":"对于环形队列，加1后相等我们认为队列为慢，那是否可以我们用俩个线程去操作这个队列，一个入队，一个出队，是否是线程安全的","like_count":0},{"had_liked":false,"id":31688,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1241346,"ip_address":"","ucode":"B8E39F3E61A36E","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/02/862b6faa.jpg","comment_is_top":false,"comment_ctime":1539265009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539265009","product_id":100017301,"comment_content":"代码建议直接到 GitHub 上交流。留言区没有代码高亮和缩进，看代码瞎眼……","like_count":0},{"had_liked":false,"id":31654,"user_name":"牵手约定","can_delete":false,"product_type":"c1","uid":1249461,"ip_address":"","ucode":"01AF328FDDD38C","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/b5/0813608c.jpg","comment_is_top":false,"comment_ctime":1539254650,"is_pvip":false,"replies":[{"id":"11405","content":"Android我不怎么了解 不好意思 可能帮不到你","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539268651,"ip_address":"","comment_id":31654,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539254650","product_id":100017301,"comment_content":"Android的handler机制是吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426451,"discussion_content":"Android我不怎么了解 不好意思 可能帮不到你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539268651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31618,"user_name":"安静的boy","can_delete":false,"product_type":"c1","uid":1196475,"ip_address":"","ucode":"F5F44B75228A85","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/bb/21ce60d2.jpg","comment_is_top":false,"comment_ctime":1539246658,"is_pvip":false,"replies":[{"id":"11377","content":"判断条件不一样的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539255823,"ip_address":"","comment_id":31618,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539246658","product_id":100017301,"comment_content":"关于循环队列我有一个问题，当队满的时候，tail指向的位置其实是没有元素的，还可以再插入一个元素。为什么此时就是队满了呢？在顺序队列中，我看您判断队满的条件就是tail == n，此时数组中已经被填满了元素。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426431,"discussion_content":"判断条件不一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539255823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31572,"user_name":"丨落灬小莫","can_delete":false,"product_type":"c1","uid":1180850,"ip_address":"","ucode":"0BF6AC6DF24F6B","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b2/002398d6.jpg","comment_is_top":false,"comment_ctime":1539234095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539234095","product_id":100017301,"comment_content":"RE:凭实力写bug<br><br>时间复杂度不能简单的看，但是均摊复杂度是很有必要的，简单的用 ArrayList 举例子吧<br>ArrayList 的 add() 方法，最坏情况下是 O(n),一般情况下 是 O(1),你即不能简单的说他是 O(n),也不能简单的说他是 O(1), 这个时候引入均摊复杂度就很有必要了 <br>假如你的 list 的size 是 100，当你执行 49 次 add()，每次操作都是 O(1), 第50次需要扩容，所以第50次的操作是O(n),假设 O(1) 的执行时间为1秒，那你操作50次的总时间是 100s, 平均一下 每次操作是2s,<br>2s 意味着你第50次操作的时间均摊给每次 add() 方法1s，所以均摊下来还是一个常数级的操作，而不能说 add() 方法是 O(n) 级别的","like_count":0},{"had_liked":false,"id":31562,"user_name":"Dwyane","can_delete":false,"product_type":"c1","uid":1110081,"ip_address":"","ucode":"FD5B9DF96A5BDB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/41/f6153c7a.jpg","comment_is_top":false,"comment_ctime":1539229427,"is_pvip":false,"replies":[{"id":"11385","content":"我觉得要反过来 说最好 最坏情况下的复杂度就好了 均摊复杂度很难分析","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539256668,"ip_address":"","comment_id":31562,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539229427","product_id":100017301,"comment_content":"原文中“我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。这种实现思路中，出队操作的时间复杂度仍然是 O(1)，但入队操作的时间复杂度还是 O(1) 吗？”<br>答：一般情况下，我们会说它的时间复杂度为0(n)，毕竟运行了n条数组赋值语句，但采用摊还分析法，它的时间复杂度为O(1)，并不需要计算最好、最坏时间复杂度。   <br><br>老师你觉得对吗？<br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426403,"discussion_content":"我觉得要反过来 说最好 最坏情况下的复杂度就好了 均摊复杂度很难分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539256668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31542,"user_name":"凭实力写bug","can_delete":false,"product_type":"c1","uid":1235611,"ip_address":"","ucode":"6F772551F18935","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/9b/e0ef47df.jpg","comment_is_top":false,"comment_ctime":1539224455,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539224455","product_id":100017301,"comment_content":"个人认为时间复杂度不能使用均摊复杂度，而是要使用最坏复杂度，假设最好情况下执行速度是0.5s，没一百次会有一次最坏情况执行速度是1分钟，平均下来差不多是1s，当时在最坏复杂度的时候用户就会觉得你这个很卡，不能那平均复杂度来麻痹自己，而是要看最坏复杂度，如果最坏复杂度过高要决解","like_count":0},{"had_liked":false,"id":31540,"user_name":"云","can_delete":false,"product_type":"c1","uid":1066629,"ip_address":"","ucode":"138F855329C281","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/85/6090b202.jpg","comment_is_top":false,"comment_ctime":1539224399,"is_pvip":false,"replies":[{"id":"11417","content":"哈哈 没事的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539268944,"ip_address":"","comment_id":31540,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539224399","product_id":100017301,"comment_content":"谢谢老师，已经看到github上的代码了，其实老师在周末福利的时候已经把github的地址告诉我们了，一看到0822突然就想起来了，是我太不认真了。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426391,"discussion_content":"哈哈 没事的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539268944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31537,"user_name":"QLing","can_delete":false,"product_type":"c1","uid":1245000,"ip_address":"","ucode":"9D3DDA939B72AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/48/67342109.jpg","comment_is_top":false,"comment_ctime":1539223966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539223966","product_id":100017301,"comment_content":"基本上每篇都有在说边界值的处理，原理我们懂了，正常情况下代码逻辑比较好理清，但边界值总有忽略，没有考虑到位的地方，需要认真的思考处理才能真正使代码健壮。","like_count":0},{"had_liked":false,"id":31526,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539222433,"is_pvip":false,"replies":[{"id":"11387","content":"是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539256842,"ip_address":"","comment_id":31526,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539222433","product_id":100017301,"comment_content":"哦，入队的时候只有从head开始遍历到某个next指针为空的情况，增加了复杂度，增加一个tail是减少复杂度","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426385,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539256842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31518,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1539221735,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1539221735","product_id":100017301,"comment_content":"均摊分析下来入队是O(1),前面n-1次入队操作都是O(1)，最后一次数据搬移操作是O(n),平均下来是O(1)","like_count":0},{"had_liked":false,"id":31509,"user_name":"western","can_delete":false,"product_type":"c1","uid":1215550,"ip_address":"","ucode":"21BCB130722780","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/3e/e767c15f.jpg","comment_is_top":false,"comment_ctime":1539220975,"is_pvip":false,"replies":[{"id":"11391","content":"disruptor？实战篇会讲","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539256994,"ip_address":"","comment_id":31509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539220975","product_id":100017301,"comment_content":"为什么disrupter的长度只能是2的n次方","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426379,"discussion_content":"disruptor？实战篇会讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539256994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31508,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1539220801,"is_pvip":false,"replies":[{"id":"11389","content":"是的 我们实战篇会讲","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539256966,"ip_address":"","comment_id":31508,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539220801","product_id":100017301,"comment_content":"Disruptor 我在学习storm的时候，记得底层有个这个disruptir是一个非常高效的无锁环形队列,号称可以每秒处理600万条数据","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426378,"discussion_content":"是的 我们实战篇会讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539256966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31499,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1539218908,"is_pvip":false,"replies":[{"id":"11419","content":"如果这段代码都看起来费劲 那是要提高一下代码能力了哦","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539269126,"ip_address":"","comment_id":31499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539218908","product_id":100017301,"comment_content":"Re 粑粑麻麻<br>----<br>数组扩容队列，循环操作，我真是看了半天，要是写成item[i] =item[i+header]是不是更容易理解，前提是for循环从0开始，小于tail减去header<br>----<br>说的是数据搬移那个循环吧？这个地方我也看了半天，我也觉得你这种好理解。<br><br>int len = tail - head;<br>for ( int i = 0; i &lt; len; i++) {<br>  item[ i] = item[ head+ i];<br>}<br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426375,"discussion_content":"如果这段代码都看起来费劲 那是要提高一下代码能力了哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539269126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31491,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1539218484,"is_pvip":false,"replies":[{"id":"11420","content":"算是 👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539269188,"ip_address":"","comment_id":31491,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539218484","product_id":100017301,"comment_content":"思考题1，对象池算吗？初始化的时候创建N个对象，常驻内存。当需要的时候从对象池里面取一个对象，用完之后放回来.如果取的时候没有对象可用，那就让他入队-enqueue, 取到之后让他出队-dequeue. 应用对象池的好处是，一次创建多次重用，避免这类对象因频繁创建回收而导致内存抖动。<br><br>跑题了，大牛哥请来指正，谢谢！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426370,"discussion_content":"算是 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539269188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31485,"user_name":"Rain","can_delete":false,"product_type":"c1","uid":1238221,"ip_address":"","ucode":"6A270D922A3B9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/cd/5363c8fa.jpg","comment_is_top":false,"comment_ctime":1539217569,"is_pvip":false,"replies":[{"id":"11422","content":"不哦，我的意思是，如果tail==n了，那就无法往里放数据了，即便head==n。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539269539,"ip_address":"","comment_id":31485,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539217569","product_id":100017301,"comment_content":"这个地方有点问题吧？如果tail == n == head 呢？队列为空吧？<br>----<br>在用数组实现的非循环队列中，队满的判断条件是 tail == n，队空的判断条件是 head == tail。<br>----<br>应该是:<br>队满的判断条件是 tail == n，&lt; head = 0 &gt;.<br><br>老师，我说的对吗？<br><br>类似这样的问题我总是很纠结，想了半天才过来评论。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426365,"discussion_content":"不哦，我的意思是，如果tail==n了，那就无法往里放数据了，即便head==n。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539269539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31465,"user_name":"郑金锋","can_delete":false,"product_type":"c1","uid":1119335,"ip_address":"","ucode":"BC940BF8FCC81F","user_header":"https://static001.geekbang.org/account/avatar/00/11/14/67/5d375419.jpg","comment_is_top":false,"comment_ctime":1539188988,"is_pvip":false,"replies":[{"id":"11305","content":"可以的 理解的很对","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539222192,"ip_address":"","comment_id":31465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539188988","product_id":100017301,"comment_content":"循环队列会浪费一个存储空间，如文中例子，初始化长度8，而实际上只能存7个值，现实应用的时候是不是会有误解？是不是可以在初始化的时候，默认把长度加1","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426354,"discussion_content":"可以的 理解的很对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31455,"user_name":"凌","can_delete":false,"product_type":"c1","uid":1257995,"ip_address":"","ucode":"41369B360C794F","user_header":"https://static001.geekbang.org/account/avatar/00/13/32/0b/81ae214b.jpg","comment_is_top":false,"comment_ctime":1539183932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539183932","product_id":100017301,"comment_content":"入队操作的时间复杂度最差情况下每次都要移动n-1次，所以是O(n-1)？<br>看了dpdk的无锁循环队列，队列长度是2的幂次方，因为索引是unsigned 32bits的所以溢出了也不会出错，如（uint32_t）5-65535 = 6。<br><br>","like_count":0},{"had_liked":false,"id":31443,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539180553,"is_pvip":false,"replies":[{"id":"11306","content":"入队咋办呢？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539222269,"ip_address":"","comment_id":31443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539180553","product_id":100017301,"comment_content":"刚刚我在实践用链表实现队列的时候，其实想想我们应该不必需要tail指针，因为当链表中的某一个节点的next指针为空时，就表示是尾节点了，我们出队列操作只需要移动head即可！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426340,"discussion_content":"入队咋办呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31417,"user_name":"我的心里只有工作","can_delete":false,"product_type":"c1","uid":1238185,"ip_address":"","ucode":"488DD6F9590EB8","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/a9/117fe480.jpg","comment_is_top":false,"comment_ctime":1539175174,"is_pvip":false,"replies":[{"id":"11307","content":"不是一样的嘛？","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539222359,"ip_address":"","comment_id":31417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539175174","product_id":100017301,"comment_content":"数组扩容队列，循环操作，我真是看了半天，要是写成item[i] =item[i+header]是不是更容易理解，前提是for循环从0开始，小于tail减去header","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426328,"discussion_content":"不是一样的嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31356,"user_name":"云","can_delete":false,"product_type":"c1","uid":1066629,"ip_address":"","ucode":"138F855329C281","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/85/6090b202.jpg","comment_is_top":false,"comment_ctime":1539157463,"is_pvip":false,"replies":[{"id":"11313","content":"你github上搜wangzheng0822","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539222599,"ip_address":"","comment_id":31356,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539157463","product_id":100017301,"comment_content":"老师讲的干货满满，老师的github地址是啥啊？想去看看老师写的代码。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426304,"discussion_content":"你github上搜wangzheng0822","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539222599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31330,"user_name":"华林","can_delete":false,"product_type":"c1","uid":1020238,"ip_address":"","ucode":"70A82E86FD78D5","user_header":"","comment_is_top":false,"comment_ctime":1539152041,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539152041","product_id":100017301,"comment_content":"关于数组实现循环队列会导致空一个空间的问题，那我们是否能直接用一个参数来标记队列是否满了，入队加一，出队减一，如果等于 items 的长度 n，就说明满了","like_count":0},{"had_liked":false,"id":31309,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1539146362,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539146362","product_id":100017301,"comment_content":"数组队列进行数据搬移的时候，看着是将原来位置值复制到新位置了，原来内存地址中还是有数据的，只是下次存储的时候将指定内存地址的值覆盖了，是这样么？","like_count":0},{"had_liked":false,"id":31278,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1539141850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539141850","product_id":100017301,"comment_content":"还有就是搬移数据的入队操作 按照摊还法算下来复杂度应该是O(1)吧","like_count":0},{"had_liked":false,"id":31261,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1539138373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539138373","product_id":100017301,"comment_content":"阻塞队列  内部已经用了 wait  肯定加了锁  本质就是并发队列 不知道我理解有错吗","like_count":0},{"had_liked":false,"id":31257,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1238703,"ip_address":"","ucode":"C5EB025A9D1301","user_header":"https://static001.geekbang.org/account/avatar/00/12/e6/af/e94ef6d8.jpg","comment_is_top":false,"comment_ctime":1539137764,"is_pvip":false,"replies":[{"id":"11260","content":"不需要的 可以上github上看看代码就清楚了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1539146587,"ip_address":"","comment_id":31257,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539137764","product_id":100017301,"comment_content":"老师，请问链式队列出队的时候要进行数据搬移吗，如果搬移又是怎样处理呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426267,"discussion_content":"不需要的 可以上github上看看代码就清楚了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539146587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}