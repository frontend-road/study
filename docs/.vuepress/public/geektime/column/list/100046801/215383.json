{"id":215383,"title":"13 | MySQL主从数据库同步是如何实现的？","content":"<p>你好，我是李玥。</p><p>回顾我们之前讲MySQL相关的几节课程，你会发现主从同步有多重要。解决数据可靠性的问题需要用到主从同步；解决MySQL服务高可用要用到主从同步；应对高并发的时候，还是要用到主从同步。</p><p>我们在运维MySQL集群时，遇到的很多常见的问题，比如说，为什么从节点故障会影响到主节点？为什么主从切换之后丢数据了？为什么明明没有更新数据，客户端读到的数据还是变来变去的？这些都和主从同步的配置有密切的关系。</p><p>你不但要理解MySQL主从同步的原理，还要掌握一些相关配置的含义，才能正确地配置你的集群，知道集群在什么情况下会有什么样的行为，可能会出现什么样的问题，并且知道该如何解决。</p><p>今天这节课我们就来详细讲一下，MySQL的主从同步是怎么实现的，以及如何来正确地配置主从同步。</p><h2>如何配置MySQL的主从同步？</h2><p>当客户端提交一个事务到MySQL的集群，直到客户端收到集群返回成功响应，在这个过程中，MySQL集群需要执行很多操作：主库需要提交事务、更新存储引擎中的数据、把Binlog写到磁盘上、给客户端返回响应、把Binlog复制到所有从库上、每个从库需要把复制过来的Binlog写到暂存日志中、回放这个Binlog、更新存储引擎中的数据、给主库返回复制成功的响应。</p><!-- [[[read_end]]] --><p>这些操作的时序非常重要，这里面的“时序”，说的就是这些操作的先后顺序。同样的操作，因为时序不同，对应用程序来说，有很大的差异。比如说，如果先复制Binlog，等Binlog复制到从节点上之后，主节点再去提交事务，这种情况下，从节点的Binlog一直和主节点是同步的，任何情况下主节点宕机也不会丢数据。但如果把这个时序倒过来，先提交事务再复制Binlog，性能就会非常好，但是存在丢数据的风险。</p><p>MySQL提供了几个参数来配置这个时序，我们先看一下默认情况下的时序是什么样的。</p><p>默认情况下，MySQL采用异步复制的方式，执行事务操作的线程不会等复制Binlog的线程。具体的时序你可以看下面这个图：</p><p><img src=\"https://static001.geekbang.org/resource/image/63/3f/6359155a64c1a62cb5fe23f10946d23f.jpg?wh=1142*423\" alt=\"\"></p><p>MySQL主库在收到客户端提交事务的请求之后，会先写入Binlog，然后再提交事务，更新存储引擎中的数据，事务提交完成后，给客户端返回操作成功的响应。同时，从库会有一个专门的复制线程，从主库接收Binlog，然后把Binlog写到一个中继日志里面，再给主库返回复制成功的响应。</p><p>从库还有另外一个回放Binlog的线程，去读中继日志，然后回放Binlog更新存储引擎中的数据，这个过程和我们今天讨论的主从复制关系不大，所以我并没有在图中画出来。<strong>提交事务和复制这两个流程在不同的线程中执行，互相不会等待，这是异步复制。</strong></p><p>掌握了异步复制的时序之后，我们就很容易理解之前几节课中讲到的一些问题的原因了。比如说，在异步复制的情况下，为什么主库宕机存在丢数据的风险？为什么读写分离存在读到脏数据的问题？产生这些问题，都是因为<strong>异步复制它没有办法保证数据能第一时间复制到从库上。</strong></p><p>与异步复制相对的就是同步复制。同步复制的时序和异步复制基本是一样的，唯一的区别是，什么时候给客户端返回响应。异步复制时，主库提交事务之后，就会给客户端返回响应；而同步复制时，主库在提交事务的时候，会等待数据复制到所有从库之后，再给客户端返回响应。</p><p>同步复制这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</p><p>为了解决这个问题，MySQL从5.7版本开始，增加一种半同步复制（Semisynchronous Replication）的方式。异步复制是，事务线程完全不等复制响应；同步复制是，事务线程要等待所有的复制响应；半同步复制介于二者之间，事务线程不用等着所有的复制成功响应，只要一部分复制响应回来之后，就可以给客户端返回了。</p><p>比如说，一主二从的集群，配置成半同步复制，只要数据成功复制到任意一个从库上，主库的事务线程就直接返回了。这种半同步复制的方式，它兼顾了异步复制和同步复制的优点。如果主库宕机，至少还有一个从库有最新的数据，不存在丢数据的风险。并且，半同步复制的性能也还凑合，也能提供高可用保证，从库宕机也不会影响主库提供服务。所以，半同步复制这种折中的复制方式，也是一种不错的选择。</p><p>接下来我跟你说一下，在实际应用过程中，选择半同步复制需要特别注意的几个问题。</p><p>配置半同步复制的时候，有一个重要的参数“rpl_semi_sync_master_wait_slave_count”，含义是：“至少等待数据复制到几个从节点再返回”。这个数量配置的越大，丢数据的风险越小，但是集群的性能和可用性就越差。最大可以配置成和从节点的数量一样，这样就变成了同步复制。</p><p>一般情况下，配成默认值1也就够了，这样性能损失最小，可用性也很高，只要还有一个从库活着，就不影响主库读写。丢数据的风险也不大，只有在恰好主库和那个有最新数据的从库一起坏掉的情况下，才有可能丢数据。</p><p>另外一个重要的参数是“rpl_semi_sync_master_wait_point”，这个参数控制主库执行事务的线程，是在提交事务之前（AFTER_SYNC）等待复制，还是在提交事务之后（AFTER_COMMIT）等待复制。默认是AFTER_SYNC，也就是先等待复制，再提交事务，这样完全不会丢数据。AFTER_COMMIT具有更好的性能，不会长时间锁表，但还是存在宕机丢数据的风险。</p><p>另外，虽然我们配置了同步或者半同步复制，并且要等待复制成功后再提交事务，还是有一种特别容易被忽略、可能存在丢数据风险的情况。</p><p>如果说，主库提交事务的线程等待复制的时间超时了，这种情况下事务仍然会被正常提交。并且，MySQL会自动降级为异步复制模式，直到有足够多（rpl_semi_sync_master_wait_no_slave）的从库追上主库，才能恢复成半同步复制。如果这个期间主库宕机，仍然存在丢数据的风险。</p><h2>复制状态机：所有分布式存储都是这么复制数据的</h2><p>在MySQL中，无论是复制还是备份恢复，依赖的都是全量备份和Binlog，全量备份相当于备份那一时刻的一个数据快照，Binlog则记录了每次数据更新的变化，也就是操作日志。我们这节课讲主从同步，也就是数据复制，虽然讲的都是MySQL，但是你要知道，这种基于“快照+操作日志”的方法，不是MySQL特有的。</p><p>比如说，Redis Cluster中，它的全量备份称为Snapshot，操作日志叫backlog，它的主从复制方式几乎和MySQL是一模一样的。</p><p>我再给你举个例子，之前我们讲过的Elasticsearch，它是一个内存数据库，读写都在内存中，那它是怎么保证数据可靠性的呢？对，它用的是translog，它备份和恢复数据的原理和实现方式也是完全一样的。这些什么什么log，都是不同的马甲儿而已，<strong>几乎所有的存储系统和数据库，都是用这一套方法来解决备份恢复和数据复制问题的</strong>。</p><p>既然这些存储系统他们实现数据复制的方法是完全一样的，那这几节课我们讲的MySQL主从复制时，讲到的那些问题、丢数据的风险，对于像Redis Cluster、ES或者其他分布式存储也都是一样存在的。那我们讲的，如何应对的方法、注意事项、最佳实践，这些也都是可以照搬的。</p><p>这一套方法其实是有理论基础的，叫做<a href=\"https://en.wikipedia.org/wiki/State_machine_replication\">复制状态机(Replication State Machine)</a>，我能查到的最早的出处是1978年Lamport的一篇论文<a href=\"http://lamport.azurewebsites.net/pubs/implementation.pdf\">《The Implementation of Reliable Distributed Multiprocess Systems》</a>。</p><p>1978年啊，同学，那时候我们都还没出生呢！这么老的技术到今天仍然在被广泛地应用！无论应用技术发展的多快，实际上解决问题的方法，或者说是理论基础，一直是没什么变化的。所以，你在不断学习新的应用技术的同时，还需要多思考、总结和沉淀，这样会让你学习新技术的时候更快更轻松。</p><h2>小结</h2><p>最后，那为了便于你理解复制状态机，我们把这套方法再抽象总结一下。任何一个存储系统，无论它存储的是什么数据，用什么样的数据结构，都可以抽象成一个状态机。</p><p>存储系统中的数据称为状态（也就是MySQL中的数据），状态的全量备份称为快照（Snapshot），就像给数据拍个照片一样。我们按照顺序记录更新存储系统的每条操作命令，就是操作日志（Commit Log，也就是MySQL中的Binlog）。你可以对照下面这张图来理解上面这些抽象的概念。</p><p><img src=\"https://static001.geekbang.org/resource/image/83/7a/83e34a8b9d4f81391e327172e5a2497a.jpg?wh=1142*446\" alt=\"\"></p><p>复制数据的时候，只要基于一个快照，按照顺序执行快照之后的所有操作日志，就可以得到一个完全一样的状态。在从节点持续地从主节点上复制操作日志并执行，就可以让从节点上的状态数据和主节点保持同步。</p><p>主从同步做数据复制时，一般可以采用几种复制策略。性能最好的方法是异步复制，主节点上先记录操作日志，再更新状态数据，然后异步把操作日志复制到所有从节点上，并在从节点执行操作日志，得到和主节点相同的状态数据。</p><p>异步复制的劣势是，可能存在主从延迟，如果主节点宕机，可能会丢数据。另外一种常用的策略是半同步复制，主节点等待操作日志最少成功复制到N个从节点上之后，再更新状态，这种方式在性能、高可用和数据可靠性几个方面都比较平衡，很多分布式存储系统默认采用的都是这种方式。</p><h2>思考题</h2><p>课后请你想一下，复制状态机除了用于数据库的备份和复制以外，在计算机技术领域，还有哪些地方也用到了复制状态机？欢迎你在留言区与我讨论。</p><p>感谢你的阅读，如果你觉得今天的内容对你有帮助，也欢迎把它分享给你的朋友。</p>","neighbors":{"left":{"article_title":"12 | MySQL如何应对高并发（二）：读写分离","id":215330},"right":{"article_title":"14 | 订单数据越来越多，数据库越来越慢该怎么办？","id":215815}},"comments":[{"had_liked":false,"id":195428,"user_name":"李玥","can_delete":false,"product_type":"c1","uid":1501046,"ip_address":"","ucode":"B19E91EE248591","user_header":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","comment_is_top":true,"comment_ctime":1585187462,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"9.2233721629939999e+18","product_id":100046801,"comment_content":"Hi，我是李玥。<br><br>这里回顾一下上节课的思考题：<br><br>课后请你对照你现在负责开发或者维护的系统来分享一下，你的系统实施读写分离的具体方案是什么样的？比如，如何分离读写数据库请求？如何解决主从延迟带来的数据一致性问题？欢迎你在留言区与我讨论。<br><br>课后很多小伙伴在留言区对这个问题做了回复，分离读写请求大多数采用的是代理或者Sharding-JDBC这两种方案。那解决主从延迟，没有完全避免延迟的方法，但至少要做到能够监控主从延迟，当延迟太大的时候，采用一些降级方案。比如说，把重要业务的读请求切回主库，暂停一些不重要的业务，甚至限流等等。","like_count":30,"discussions":[{"author":{"id":1008933,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/65/25/c6de04bc.jpg","nickname":"斜月浮云","note":"","ucode":"25CECBB175DA02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304795,"discussion_content":"这节课，用的最经典的两个栗子：docker，git。将复制状态机用到了极致。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599663934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204732,"user_name":"夏目","can_delete":false,"product_type":"c1","uid":1212750,"ip_address":"","ucode":"67C075A01CF4D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","comment_is_top":false,"comment_ctime":1586446651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"91780759867","product_id":100046801,"comment_content":"redis在重启时现在也可以采用这种策略，RDB快照加上aof日志恢复数据","like_count":22},{"had_liked":false,"id":195305,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1585166407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"66009675847","product_id":100046801,"comment_content":"最典型的应当是VMware:其实复制技术不仅仅在linux系统的中间件存储 mysql、redis、ES上使用，Windows的sql server同样适用了此技术。","like_count":16},{"had_liked":false,"id":195617,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1585205163,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"44534878123","product_id":100046801,"comment_content":"MySQL 启用半同步复制，需要登录MySQL安装插件(或者修改配置文件)<br>Linux： install plugin rpl_semi_sync_master soname &#39;semisync_master_so&#39; (window 是 dll)<br>从库使用的是 semisync_slave.so 文件<br><br>这时候MySQL 会自动去 安装目录的 lib&#47;plugin 文件夹下去找","like_count":10},{"had_liked":false,"id":196325,"user_name":"Wiggins","can_delete":false,"product_type":"c1","uid":1078222,"ip_address":"","ucode":"021EE98CF0E4EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/73/ce/23bd3997.jpg","comment_is_top":false,"comment_ctime":1585272678,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31650043750","product_id":100046801,"comment_content":"读完mysql实战45讲再读老师的文章感觉又复习了一遍 老师的文章很清晰 更加偏向实战中的配置了","like_count":8,"discussions":[{"author":{"id":1667714,"avatar":"https://static001.geekbang.org/account/avatar/00/19/72/82/24fb9d18.jpg","nickname":"慕然","note":"","ucode":"8622102560A80F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407888,"discussion_content":"大佬，mysql实战45讲。这课怎么样呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635145134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1622022,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJia6zEsh2u119zJicmq7wApvnricZEKiawaZicice1cOzujWdFicFwPtavlHiaVpCNgCpxBtdl7ynd3y0wkQ/132","nickname":"james_xu","note":"","ucode":"12E50291F5BA89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1667714,"avatar":"https://static001.geekbang.org/account/avatar/00/19/72/82/24fb9d18.jpg","nickname":"慕然","note":"","ucode":"8622102560A80F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":410503,"discussion_content":"非常推荐，我看了两遍，偶尔还会去复习下。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635695859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":407888,"ip_address":""},"score":410503,"extra":""}]}]},{"had_liked":false,"id":195640,"user_name":"渐渐迷失","can_delete":false,"product_type":"c1","uid":1319264,"ip_address":"","ucode":"9CEB5D11B4B5CC","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/60/b21da12a.jpg","comment_is_top":false,"comment_ctime":1585208612,"is_pvip":false,"replies":[{"id":"74408","content":"建议你还是在MQ的课程中去提问，这样也便于其它同学查看。虽然课程已经更新完结，但我还是会关注并回答留言区的问题。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1585272519,"ip_address":"","comment_id":195640,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27355012388","product_id":100046801,"comment_content":"老师你好<br>之前学mq的时候您课讲完了，我才进入学习的，有好些问题还不会，追过来问问可以吗","like_count":7,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489132,"discussion_content":"建议你还是在MQ的课程中去提问，这样也便于其它同学查看。虽然课程已经更新完结，但我还是会关注并回答留言区的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585272519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200490,"user_name":"渔夫","can_delete":false,"product_type":"c1","uid":1019289,"ip_address":"","ucode":"6BF08FD8923E45","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/99/f886543d.jpg","comment_is_top":false,"comment_ctime":1585612811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23060449291","product_id":100046801,"comment_content":"目前主流前端技术的状态管理也是这个状态机机制：state + action = next state","like_count":5},{"had_liked":false,"id":213506,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1588436451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14473338339","product_id":100046801,"comment_content":"基于事件朔源的应用程序，就是用snapshot + 事件来快速恢复对象的状态。","like_count":3},{"had_liked":false,"id":326998,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1639822558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5934789854","product_id":100046801,"comment_content":"思考题：<br>复制状态机的思想也用于数据同步，当把一批频繁变化的数据从一个地方同步到另一个地方时，先对数据做一个初始化的全量同步，相当于给数据拍一个快照，然后给数据加一个时间戳字段，记录下拍快照时的时间戳，每当数据发生增、删、改时，时间戳也发生改变，根据时间戳的变化，只需要把时间戳大于快照时间戳的数据进行增量同步即可，这种思想算不是复制状态机，请老师指正。","like_count":1},{"had_liked":false,"id":287572,"user_name":"夜辉","can_delete":false,"product_type":"c1","uid":1886331,"ip_address":"","ucode":"9421385F51FF9E","user_header":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","comment_is_top":false,"comment_ctime":1618035755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5913003051","product_id":100046801,"comment_content":"redis持久化存储方式：rdb 和 aof<br>后面还出了一种二者混合的方式<br>","like_count":1},{"had_liked":false,"id":196127,"user_name":"image","can_delete":false,"product_type":"c1","uid":1039069,"ip_address":"","ucode":"A45BFF284F8933","user_header":"https://static001.geekbang.org/account/avatar/00/0f/da/dd/1e5e7b0c.jpg","comment_is_top":false,"comment_ctime":1585237738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880205034","product_id":100046801,"comment_content":"fork and write，典型有docker镜像，linux fork都和复制状态机有关系，这也是一种基本的构建模式","like_count":2},{"had_liked":false,"id":336743,"user_name":"DonaldTrumpppppppppp","can_delete":false,"product_type":"c1","uid":2063923,"ip_address":"","ucode":"211B1A25C53172","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er4rbCWDxib3FHibYBouTwZqZBH6h5IgvjibEiaBv4Ceekib9SYg0peBBlFGu8hDuGvwjKp6LNznvEAibYw/132","comment_is_top":false,"comment_ctime":1646332310,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646332310","product_id":100046801,"comment_content":"老师好，现在有个问题急需您指点。一主一备时，半同步模式下，主节点退化为异步同步模式后，从节点恢复后但未和主同步一致的情况下，主挂了，备升级为主。这时出现不一致的情况该如何处理？ ","like_count":0},{"had_liked":false,"id":327730,"user_name":"ALEX","can_delete":false,"product_type":"c1","uid":1336783,"ip_address":"","ucode":"02031DD9EADFE9","user_header":"https://static001.geekbang.org/account/avatar/00/14/65/cf/f4305170.jpg","comment_is_top":false,"comment_ctime":1640254911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640254911","product_id":100046801,"comment_content":"git commit log 加上本地副本","like_count":0},{"had_liked":false,"id":294840,"user_name":"Ling","can_delete":false,"product_type":"c1","uid":1323264,"ip_address":"","ucode":"F16F675C1D1EA9","user_header":"https://static001.geekbang.org/account/avatar/00/14/31/00/b5fd38df.jpg","comment_is_top":false,"comment_ctime":1622107686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622107686","product_id":100046801,"comment_content":"- rpl_semi_sync_master_timeout<br>  为了防止半同步复制在没有收到确认的情况下发生堵塞，如果主库在`rpl_semi_sync_master_timeout`毫秒超时之前没有收到确认，将恢复到异步复制<br>  以毫秒为单位，默认值是10000(10秒)。<br><br>- rpl_semi_sync_master_wait_for_slave_count<br>  在继续处理事务之前，必须接收的副本确认的数量；<br>  越小，需要等待确认的从节点越少，性能越好；<br>  MySQL默认值是`1`；阿里云的一主一备高可用版RDS，配置该值为`1`<br><br>- rpl_semi_sync_master_wait_no_slave<br>  当前存活从节点数小于`rpl_semi_sync_master_wait_for_slave_count`中配置的值时，是否还需要等待`rpl_semi_sync_master_timeout`中配置的超时时间；<br>  环境：如果配置的`rpl_semi_sync_master_wait_for_slave_count`是2，但是当前只有一个从节点<br>  如果配置为`ON`：主库还是会等待`rpl_semi_sync_master_timeout`秒后超时，然后切换为`异步复制`<br>  如果配置为`OFF`：立刻变为`异步复制`<br>  MySQL默认该值为`ON`，阿里云的一主一备高可用版RDS，配置该值为`OFF`","like_count":1},{"had_liked":false,"id":288115,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1618306228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618306228","product_id":100046801,"comment_content":"感谢老师深入浅出的分享 看过这篇后 对于redis mongodb kafka mysql这些存储介质豁然开朗。原来一天学完存储介质真的不是梦","like_count":0},{"had_liked":false,"id":278436,"user_name":"flyCoder","can_delete":false,"product_type":"c1","uid":1074897,"ip_address":"","ucode":"82FB7B60775978","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/d1/8664c464.jpg","comment_is_top":false,"comment_ctime":1612941002,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1612941002","product_id":100046801,"comment_content":"半同步复制，主节点挂了，怎么样保证数据的完整性呢？ 从节点之间会相互复制吗？","like_count":0,"discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367259,"discussion_content":"会选择ISR列表里最全的那个做恢复，如果不放心就把binlog拿过来做回放。顺便说一句，binlog是严格有序的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618306146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276974,"user_name":"innocent","can_delete":false,"product_type":"c1","uid":1197455,"ip_address":"","ucode":"368659A0DDE7E4","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/8f/a56b2214.jpg","comment_is_top":false,"comment_ctime":1612201258,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612201258","product_id":100046801,"comment_content":"Raft协议也用到了复制状态机","like_count":0},{"had_liked":false,"id":267450,"user_name":"疯码","can_delete":false,"product_type":"c1","uid":1228313,"ip_address":"","ucode":"7FF11EC80439EA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vQiadbkZYR239J80hjekw7jzY9vy6otLKPNDSuz2lruDiaXlKGkcsX5wwiaFevicgqV8odlRG4UITiadDF3fgicrHPcw/132","comment_is_top":false,"comment_ctime":1607750247,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607750247","product_id":100046801,"comment_content":"游戏同步。从同一基础状态开始，各客户端施加同样的操作 得到同样的结果。","like_count":1},{"had_liked":false,"id":255337,"user_name":"亚林","can_delete":false,"product_type":"c1","uid":1018972,"ip_address":"","ucode":"4A5A6D24314B79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","comment_is_top":false,"comment_ctime":1603325629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603325629","product_id":100046801,"comment_content":"学好数学建模课程的重要性","like_count":0},{"had_liked":false,"id":242827,"user_name":"家乐","can_delete":false,"product_type":"c1","uid":1301941,"ip_address":"","ucode":"94F8720B59F221","user_header":"https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJia90ErsTQtNDNeyTWNwWjicERicXj72b4xgbvru2IkUdrLxrgJb5lCrTaiaW2iaX3mOYiaV8vYo3voWlg/132","comment_is_top":false,"comment_ctime":1597849816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597849816","product_id":100046801,"comment_content":"个人理解，复制状态机在分布式技术领域，如存储，计算，协议一样通用。大致都会记录一个执行快照，对比各节点状态已完成一致性检验，冲突检测等功能。","like_count":0},{"had_liked":false,"id":242039,"user_name":"肖雄","can_delete":false,"product_type":"c1","uid":1887133,"ip_address":"","ucode":"D6A92519623EF9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIxEuD0ytJhQYiceS3EZbyE8M3nQ7fWyTFnAm6Vjo5F8P8utfTw4fkWlqJeNEGJfQyXAgnap18gk1w/132","comment_is_top":false,"comment_ctime":1597569844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597569844","product_id":100046801,"comment_content":"kafka的leader节点和follow节点同步","like_count":0},{"had_liked":false,"id":207048,"user_name":"闫冬","can_delete":false,"product_type":"c1","uid":1109691,"ip_address":"","ucode":"1725E869D5A3D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/bb/7afd6824.jpg","comment_is_top":false,"comment_ctime":1586999627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586999627","product_id":100046801,"comment_content":"这篇收获满满","like_count":0},{"had_liked":false,"id":201208,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1585733104,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585733104","product_id":100046801,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":199940,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1585502882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585502882","product_id":100046801,"comment_content":"复制状态机！原来这个理论这么强大！第一次听说，非常激动！感谢老师！","like_count":0},{"had_liked":false,"id":195827,"user_name":"渐渐迷失","can_delete":false,"product_type":"c1","uid":1319264,"ip_address":"","ucode":"9CEB5D11B4B5CC","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/60/b21da12a.jpg","comment_is_top":false,"comment_ctime":1585217499,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585217499","product_id":100046801,"comment_content":"我之前关于mq的发言上墙了 我就直接问了 之前mq的课程 讲生产者和消费者源码尤其namedservice部分讲透了  我还想了解下 mq在集群模式下 队列怎么分布，rocketmq 是否有镜像队列，脑裂后怎么处理，mq 集群对比es和redis这种读远大于写的集群有什么特点 求解答或者知识链接","like_count":0,"discussions":[{"author":{"id":1025239,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","nickname":"Aliliin","note":"","ucode":"61F9A09BB6650F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214823,"discussion_content":"同样问？\n我到现在也只理解到，redis缓存和mq的区别是：mp 处理那些不需要第一时间给用户的业务，redis 则偏向实时返给用户数据的业务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585235512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195394,"user_name":"hhhh","can_delete":false,"product_type":"c1","uid":1256101,"ip_address":"","ucode":"9E87017424B382","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/a5/625c0a2e.jpg","comment_is_top":false,"comment_ctime":1585185151,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585185151","product_id":100046801,"comment_content":"老师您讲过的消息队列应该也是这种模式","like_count":0},{"had_liked":false,"id":195342,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1585182154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585182154","product_id":100046801,"comment_content":"老师带我们一起飞","like_count":0},{"had_liked":false,"id":195317,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1585178629,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585178629","product_id":100046801,"comment_content":"mongodb写大多数节点，和这个半同步有点一样，","like_count":0}]}