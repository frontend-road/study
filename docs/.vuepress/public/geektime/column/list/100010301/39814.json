{"id":39814,"title":"25 | 循环优化","content":"<p>在许多应用程序中，循环都扮演着非常重要的角色。为了提升循环的运行效率，研发编译器的工程师提出了不少面向循环的编译优化方式，如循环无关代码外提，循环展开等。</p>\n<p>今天，我们便来了解一下，Java虚拟机中的即时编译器都应用了哪些面向循环的编译优化。</p>\n<h2>循环无关代码外提</h2>\n<p>所谓的循环无关代码（Loop-invariant Code），指的是循环中值不变的表达式。如果能够在不改变程序语义的情况下，将这些循环无关代码提出循环之外，那么程序便可以避免重复执行这些表达式，从而达到性能提升的效果。</p>\n<pre><code>int foo(int x, int y, int[] a) {\n  int sum = 0;\n  for (int i = 0; i &lt; a.length; i++) {\n    sum += x * y + a[i];\n  }\n  return sum;\n}\n// 对应的字节码\nint foo(int, int, int[]);\n  Code:\n     0: iconst_0\n     1: istore 4\n     3: iconst_0\n     4: istore 5\n     6: goto 25\n// 循环体开始\n     9: iload 4        // load sum\n    11: iload_1        // load x\n    12: iload_2        // load y\n    13: imul           // x*y\n    14: aload_3        // load a\n    15: iload 5        // load i\n    17: iaload         // a[i]\n    18: iadd           // x*y + a[i]\n    19: iadd           // sum + (x*y + a[i])\n    20: istore 4       // sum = sum + (x*y + a[i])\n    22: iinc 5, 1      // i++\n    25: iload 5        // load i\n    27: aload_3        // load a\n    28: arraylength    // a.length\n    29: if_icmplt 9    // i &lt; a.length\n// 循环体结束\n    32: iload 4\n    34: ireturn\n</code></pre>\n<p>举个例子，在上面这段代码中，循环体中的表达式<code>x*y</code>，以及循环判断条件中的<code>a.length</code>均属于循环不变代码。前者是一个整数乘法运算，而后者则是内存访问操作，读取数组对象<code>a</code>的长度。（数组的长度存放于数组对象的对象头中，可通过arraylength指令来访问。）</p>\n<p>理想情况下，上面这段代码经过循环无关代码外提之后，等同于下面这一手工优化版本。</p>\n<pre><code>int fooManualOpt(int x, int y, int[] a) {\n  int sum = 0;\n  int t0 = x * y;\n  int t1 = a.length;\n  for (int i = 0; i &lt; t1; i++) {\n    sum += t0 + a[i];\n  }\n  return sum;\n}\n</code></pre>\n<p>我们可以看到，无论是乘法运算<code>x*y</code>，还是内存访问<code>a.length</code>，现在都在循环之前完成。原本循环中需要执行这两个表达式的地方，现在直接使用循环之前这两个表达式的执行结果。</p><!-- [[[read_end]]] -->\n<p>在Sea-of-Nodes IR的帮助下，循环无关代码外提的实现并不复杂。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/69/e6/6963da28cb3cf42cc43e4268a8f002e6.png?wh=920*1498\" alt=\"\" /></p>\n<p>上图我截取了Graal为前面例子中的<code>foo</code>方法所生成的IR图（局部）。其中B2基本块位于循环之前，B3基本块为循环头。</p>\n<p><code>x*y</code>所对应的21号乘法节点，以及<code>a.length</code>所对应的47号读取节点，均不依赖于循环体中生成的数据，而且都为浮动节点。节点调度算法会将它们放置于循环之前的B2基本块中，从而实现这些循环无关代码的外提。</p>\n<pre><code>0x02f0: mov edi,ebx  // ebx存放着x*y的结果\n0x02f2: add edi,DWORD PTR [r8+r9*4+0x10]\n                     // [r8+r9*4+0x10]即a[i]\n                     // r8指向a，r9d存放着i\n0x02f7: add eax,edi  // eax存放着sum\n0x02f9: inc r9d      // i++\n0x02fc: cmp r9d,r10d // i &lt; a.length\n                     // r10d存放着a.length\n0x02ff: jl 0x02f0\n</code></pre>\n<p>上面这段机器码是<code>foo</code>方法的编译结果中的循环。这里面没有整数乘法指令，也没有读取数组长度的内存访问指令。它们的值已在循环之前计算好了，并且分别保存在寄存器<code>ebx</code>以及<code>r10d</code>之中。在循环之中，代码直接使用寄存器<code>ebx</code>以及<code>r10d</code>所保存的值，而不用在循环中反复计算。</p>\n<p>从生成的机器码中可以看出，除了<code>x*y</code>和<code>a.length</code>的外提之外，即时编译器还外提了int数组加载指令<code>iaload</code>所暗含的null检测（null check）以及下标范围检测（range check）。</p>\n<p>如果将<code>iaload</code>指令想象成一个接收数组对象以及下标作为参数，并且返回对应数组元素的方法，那么它的伪代码如下所示：</p>\n<pre><code>int iaload(int[] arrayRef, int index) {\n  if (arrayRef == null) { // null检测\n    throw new NullPointerException();\n  }\n  if (index &lt; 0 || index &gt;= arrayRef.length) { // 下标范围检测\n    throw new ArrayIndexOutOfBoundsException();\n  }\n  return arrayRef[index];\n}\n</code></pre>\n<p><code>foo</code>方法中的null检测属于循环无关代码。这是因为它始终检测作为输入参数的int数组是否为null，而这与第几次循环无关。</p>\n<p>为了更好地阐述具体的优化，我精简了原来的例子，并将<code>iaload</code>展开，最终形成如下所示的代码。</p>\n<pre><code>int foo(int[] a) {\n  int sum = 0;\n  for (int i = 0; i &lt; a.length; i++) {\n    if (a == null) { // null check\n      throw new NullPointerException();\n    }\n    if (i &lt; 0 || i &gt;= a.length) { // range check\n      throw new ArrayIndexOutOfBoundsException();\n    }\n    sum += a[i];\n  }\n  return sum;\n}\n</code></pre>\n<p>在这段代码中，null检测涉及了控制流依赖，因而无法通过Sea-of-Nodes IR转换以及节点调度来完成外提。</p>\n<p>在C2中，null检测的外提是通过额外的编译优化，也就是循环预测（Loop Prediction，对应虚拟机参数<code>-XX:+UseLoopPredicate</code>）来实现的。该优化的实际做法是在循环之前插入同样的检测代码，并在命中的时候进行去优化。这样一来，循环中的检测代码便会被归纳并消除掉。</p>\n<pre><code>int foo(int[] a) {\n  int sum = 0;\n  if (a == null) {\n    deoptimize(); // never returns\n  }\n  for (int i = 0; i &lt; a.length; i++) {\n    if (a == null) { // now evluate to false\n      throw new NullPointerException();\n    }\n    if (i &lt; 0 || i &gt;= a.length) { // range check\n      throw new ArrayIndexOutOfBoundsException();\n    }\n    sum += a[i];\n  }\n  return sum;\n}\n</code></pre>\n<p>除了null检测之外，其他循环无关检测都能够按照这种方式外提至循环之前。甚至是循环有关的下标范围检测，都能够借助循环预测来外提，只不过具体的转换要复杂一些。</p>\n<p>之所以说下标范围检测是循环有关的，是因为在我们的例子中，该检测的主体是循环控制变量<code>i</code>（检测它是否在<code>[0, a.length)</code>之间），它的值将随着循环次数的增加而改变。</p>\n<p>由于外提该下标范围检测之后，我们无法再引用到循环变量<code>i</code>，因此，即时编译器需要转换检测条件。具体的转换方式如下所示：</p>\n<pre><code>for (int i = INIT; i &lt; LIMIT; i += STRIDE) {\n  if (i &lt; 0 || i &gt;= a.length) { // range check\n    throw new ArrayIndexOutOfBoundsException();\n  }\n  sum += a[i];\n}\n----------\n// 经过下标范围检测外提之后：\nif (INIT &lt; 0 || IMAX &gt;= a.length) {\n  // IMAX是i所能达到的最大值，注意它不一定是LIMIT-1\n  detopimize(); // never returns\n}\nfor (int i = INIT; i &lt; LIMIT; i += STRIDE) {\n  sum += a[i]; // 不包含下标范围检测\n}\n</code></pre>\n<h2>循环展开</h2>\n<p>另外一项非常重要的循环优化是循环展开（Loop Unrolling）。它指的是在循环体中重复多次循环迭代，并减少循环次数的编译优化。</p>\n<pre><code>int foo(int[] a) {\n  int sum = 0;\n  for (int i = 0; i &lt; 64; i++) {\n    sum += (i % 2 == 0) ? a[i] : -a[i];\n  }\n  return sum;\n}\n</code></pre>\n<p>举个例子，上面的代码经过一次循环展开之后将形成下面的代码：</p>\n<pre><code>int foo(int[] a) {\n  int sum = 0;\n  for (int i = 0; i &lt; 64; i += 2) { // 注意这里的步数是2\n    sum += (i % 2 == 0) ? a[i] : -a[i];\n    sum += ((i + 1) % 2 == 0) ? a[i + 1] : -a[i + 1];\n  }\n  return sum;\n}\n</code></pre>\n<p>在C2中，只有计数循环（Counted Loop）才能被展开。所谓的计数循环需要满足如下四个条件。</p>\n<ol>\n<li>维护一个循环计数器，并且基于计数器的循环出口只有一个（但可以有基于其他判断条件的出口）。</li>\n<li>循环计数器的类型为int、short或者char（即不能是byte、long，更不能是float或者double）。</li>\n<li>每个迭代循环计数器的增量为常数。</li>\n<li>循环计数器的上限（增量为正数）或下限（增量为负数）是循环无关的数值。</li>\n</ol>\n<pre><code>for (int i = START; i &lt; LIMIT; i += STRIDE) { .. }\n// 等价于\nint i = START;\nwhile (i &lt; LIMIT) {\n  ..\n  i += STRIDE;\n}\n</code></pre>\n<p>在上面两种循环中，只要<code>LIMIT</code>是循环无关的数值，<code>STRIDE</code>是常数，而且循环中除了<code>i &lt; LIMIT</code>之外没有其他基于循环变量<code>i</code>的循环出口，那么C2便会将该循环识别为计数循环。</p>\n<p>循环展开的缺点显而易见：它可能会增加代码的冗余度，导致所生成机器码的长度大幅上涨。</p>\n<p>不过，随着循环体的增大，优化机会也会不断增加。一旦循环展开能够触发进一步的优化，总体的代码复杂度也将降低。比如前面的例子经过循环展开之后便可以进一步优化为如下所示的代码：</p>\n<pre><code>int foo(int[] a) {\n  int sum = 0;\n  for (int i = 0; i &lt; 64; i += 2) {\n    sum += a[i];\n    sum += -a[i + 1];\n  }\n  return sum;\n}\n</code></pre>\n<p>循环展开有一种特殊情况，那便是完全展开（Full Unroll）。当循环的数目是固定值而且非常小时，即时编译器会将循环全部展开。此时，原本循环中的循环判断语句将不复存在，取而代之的是若干个顺序执行的循环体。</p>\n<pre><code>int foo(int[] a) {\n  int sum = 0;\n  for (int i = 0; i &lt; 4; i++) {\n    sum += a[i];\n  }\n  return sum;\n}\n</code></pre>\n<p>举个例子，上述代码将被完全展开为下述代码：</p>\n<pre><code>int foo(int[] a) {\n  int sum = 0;\n  sum += a[0];\n  sum += a[1];\n  sum += a[2];\n  sum += a[3];\n  return sum;\n}\n</code></pre>\n<p>即时编译器会在循环体的大小与循环展开次数之间做出权衡。例如，对于仅迭代三次（或以下）的循环，即时编译器将进行完全展开；对于循环体IR节点数目超过阈值的循环，即时编译器则不会进行任何循环展开。</p>\n<h2>其他循环优化</h2>\n<p>除了循环无关代码外提以及循环展开之外，即时编译器还有两个比较重要的循环优化技术：循环判断外提（loop unswitching）以及循环剥离（loop peeling）。</p>\n<p>循环判断外提指的是将循环中的if语句外提至循环之前，并且在该if语句的两个分支中分别放置一份循环代码。</p>\n<pre><code>int foo(int[] a) {\n  int sum = 0;\n  for (int i = 0; i &lt; a.length; i++) {\n    if (a.length &gt; 4) {\n      sum += a[i];\n    }\n  }\n  return sum;\n}\n</code></pre>\n<p>举个例子，上面这段代码经过循环判断外提之后，将变成下面这段代码：</p>\n<pre><code>int foo(int[] a) {\n  int sum = 0;\n  if (a.length &gt; 4) {\n    for (int i = 0; i &lt; a.length; i++) {\n      sum += a[i];\n    }\n  } else {\n    for (int i = 0; i &lt; a.length; i++) {\n    }\n  }\n  return sum;\n}\n// 进一步优化为：\nint foo(int[] a) {\n  int sum = 0;\n  if (a.length &gt; 4) {\n    for (int i = 0; i &lt; a.length; i++) {\n      sum += a[i];\n    }\n  }\n  return sum;\n}\n</code></pre>\n<p>循环判断外提与循环无关检测外提所针对的代码模式比较类似，都是循环中的if语句。不同的是，后者在检查失败时会抛出异常，中止当前的正常执行路径；而前者所针对的是更加常见的情况，即通过if语句的不同分支执行不同的代码逻辑。</p>\n<p>循环剥离指的是将循环的前几个迭代或者后几个迭代剥离出循环的优化方式。一般来说，循环的前几个迭代或者后几个迭代都包含特殊处理。通过将这几个特殊的迭代剥离出去，可以使原本的循环体的规律性更加明显，从而触发进一步的优化。</p>\n<pre><code>int foo(int[] a) {\n  int j = 0;\n  int sum = 0;\n  for (int i = 0; i &lt; a.length; i++) {\n    sum += a[j];\n    j = i;\n  }\n  return sum;\n}\n</code></pre>\n<p>举个例子，上面这段代码剥离了第一个迭代后，将变成下面这段代码：</p>\n<pre><code>int foo(int[] a) {\n  int sum = 0;\n  if (0 &lt; a.length) {\n    sum += a[0];\n    for (int i = 1; i &lt; a.length; i++) {\n      sum += a[i - 1];\n    }\n  }\n  return sum;\n}\n</code></pre>\n<h2>总结与实践</h2>\n<p>今天我介绍了即时编译器所使用的循环优化。</p>\n<p>循环无关代码外提将循环中值不变的表达式，或者循环无关检测外提至循环之前，以避免在循环中重复进行冗余计算。前者是通过Sea-of-Nodes IR以及节点调度来共同完成的，而后者则是通过一个独立优化 —— 循环预测来完成的。循环预测还可以外提循环有关的数组下标范围检测。</p>\n<p>循环展开是一种在循环中重复多次迭代，并且相应地减少循环次数的优化方式。它是一种以空间换时间的优化方式，通过增大循环体来获取更多的优化机会。循环展开的特殊形式是完全展开，将原本的循环转换成若干个循环体的顺序执行。</p>\n<p>此外，我还简单地介绍了另外两种循环优化方式：循环判断外提以及循环剥离。</p>\n<p>今天的实践环节，我们来看这么一段代码：</p>\n<pre><code>void foo(byte[] dst, byte[] src) {\n  for (int i = 0; i &lt; dst.length; i++) {\n    dst[i] = src[i];\n  }\n}\n</code></pre>\n<p>上面这段代码经过循环展开变成下面这段代码。请问你能想到进一步优化的机会吗？<br />\n（提示：数组元素在内存中的分布是连续的。假设<code>dst[0]</code>位于0x1000，那么<code>dst[1]</code>位于0x1001。）</p>\n<pre><code>void foo(byte[] dst, byte[] src) {\n  for (int i = 0; i &lt; dst.length - 4; i += 4) {\n    dst[i] = src[i];\n    dst[i + 1] = src[i + 1];\n    dst[i + 2] = src[i + 2];\n    dst[i + 3] = src[i + 3];\n  }\n  ... // post-loop\n}\n\n</code></pre>\n<p></p>\n","comments":[{"had_liked":false,"id":24734,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1537190088,"is_pvip":false,"replies":[{"id":"9150","content":"对的。在程序语义不改变的情况下，编译器会尽可能地减少生成代码的工作量。","user_name":"作者回复","comment_id":24734,"uid":"1176688","ip_address":"","utype":1,"ctime":1537258865,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"108911372488","product_id":100010301,"comment_content":"现在浏览器终于也可以写留言了，非常好！希望能将和老师相互的讨论的功能也开开，否则，不能进行对话，讲某些问题的效果不太好！<br><br>循环优化，站在编译器的角度来作出的优化动作，老师介绍了几种方式，经过听讲，我感觉万变不离其宗，优化的核心关键点还是少做一些事情，当然，事情少做了，作用不能减！<br><br>1：循环无关码外提——将循环内的某些无关代码外移，减少某些程序的反复执行<br>2：循环展开——减少循环条件的判断，针对循环次数少的循环<br>3：循环判断外提——减少每次循环的都进行判断次数<br>4：循环剥离——将不通用的处理起来稍微费劲一些的动作，放在循环外处理<br><br>总之，要做减法！<br>性能优化的核心点：<br>1：让做的快的做<br>2：如果不能实现，则让做的快的做多一点，做的慢的少做一些<br>3：取巧，事情少做了，但是目的依旧能够达到","like_count":26,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424097,"discussion_content":"对的。在程序语义不改变的情况下，编译器会尽可能地减少生成代码的工作量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537258865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25562,"user_name":"Geek_488a8e","can_delete":false,"product_type":"c1","uid":1184696,"ip_address":"","ucode":"2B767F53DB902F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erozFScHpVRM5OCwMW7giaM13NE7gN5iatw9Ozwu93ibRZZjmSmcfzBLSXs8tYtwW7Q2E8eUdy9lGl5A/132","comment_is_top":false,"comment_ctime":1537363506,"is_pvip":false,"replies":[{"id":"9351","content":"Good to know","user_name":"作者回复","comment_id":25562,"uid":"1176688","ip_address":"","utype":1,"ctime":1537434475,"user_name_real":"郑雨迪"}],"discussion_count":3,"race_medal":0,"score":"91731676722","product_id":100010301,"comment_content":"这些都是DSP代码典型的优化方法，目的是防止打断CPU的指令流水，提高指令处理的并行度","like_count":22,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424345,"discussion_content":"Good to know","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537434475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115128,"avatar":"https://static001.geekbang.org/account/avatar/00/11/03/f8/f98df0a7.jpg","nickname":"vaccywen","note":"","ucode":"077FDB50831921","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215797,"discussion_content":"专业！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585384084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1303813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/05/fc769d45.jpg","nickname":"Geek_zhw","note":"","ucode":"AABE15F9895613","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274851,"discussion_content":"高手在民间\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590627192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25150,"user_name":"Len","can_delete":false,"product_type":"c1","uid":1022767,"ip_address":"","ucode":"53C623CE17973F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/2f/b7a3625e.jpg","comment_is_top":false,"comment_ctime":1537256935,"is_pvip":true,"replies":[{"id":"9162","content":"赞想法！会的。","user_name":"作者回复","comment_id":25150,"uid":"1176688","ip_address":"","utype":1,"ctime":1537261040,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"53076864487","product_id":100010301,"comment_content":"老师，如果有这样一段代码：<br><br>for( ... ) {<br>   sum += x + y + a[i];<br>}<br><br>借助 Sea-of-Nodes IR 能把「x + y」表达式外提出去。<br><br>但，如果表达式变成如下：<br><br>sum += x + a[i] + y;<br><br>也能借助 IR 外提 「x + y」吗？","like_count":13,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424203,"discussion_content":"赞想法！会的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537261040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24758,"user_name":"一个坏人","can_delete":false,"product_type":"c1","uid":1032305,"ip_address":"","ucode":"4AF05BF008095A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/71/c83d8b15.jpg","comment_is_top":false,"comment_ctime":1537191976,"is_pvip":true,"replies":[{"id":"9151","content":"很多情况下是的。但也要考虑编译器没有预算来做优化的情况(比如循环太大)。<br><br>一般来说，应用代码更应注重可读性。","user_name":"作者回复","comment_id":24758,"uid":"1176688","ip_address":"","utype":1,"ctime":1537259016,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"18717061160","product_id":100010301,"comment_content":"是不是写应用系统的时候没必要按照优化方式写，编译器反正会优化？！","like_count":5,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424103,"discussion_content":"很多情况下是的。但也要考虑编译器没有预算来做优化的情况(比如循环太大)。\n\n一般来说，应用代码更应注重可读性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537259016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165497,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1577245804,"is_pvip":false,"replies":[{"id":"65538","content":"哈哈，确实像","user_name":"作者回复","comment_id":165497,"uid":"1176688","ip_address":"","utype":1,"ctime":1578265355,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"5872213100","product_id":100010301,"comment_content":"有点像小学四则运算里运用提公因式法等技巧来使计算简单。","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479184,"discussion_content":"哈哈，确实像","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578265355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140129,"user_name":"无言的约定","can_delete":false,"product_type":"c1","uid":1128953,"ip_address":"","ucode":"5E8046EB6B7956","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/f9/acfb9a48.jpg","comment_is_top":false,"comment_ctime":1570838185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865805481","product_id":100010301,"comment_content":"for (int i = INIT; i &lt; LIMIT; i += STRIDE) {<br>  if (i &lt; 0 || i &gt;= a.length) { &#47;&#47; range check<br>    throw new ArrayIndexOutOfBoundsException();<br>  }<br>  sum += a[i];<br>}<br>----------<br>&#47;&#47; 经过下标范围检测外提之后：<br>if (INIT &lt; 0 || IMAX &gt;= a.length) {<br>  &#47;&#47; IMAX 是 i 所能达到的最大值，注意它不一定是 LIMIT-1<br>  detopimize(); &#47;&#47; never returns<br>}<br>for (int i = INIT; i &lt; LIMIT; i += STRIDE) {<br>  sum += a[i]; &#47;&#47; 不包含下标范围检测<br>}<br>老师，这个IMAX该如何初始化？","like_count":1},{"had_liked":false,"id":44246,"user_name":"天之蓝","can_delete":false,"product_type":"c1","uid":1181299,"ip_address":"","ucode":"39A9AD005F71C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/73/d3bd607b.jpg","comment_is_top":false,"comment_ctime":1543393655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5838360951","product_id":100010301,"comment_content":"请教两个问题，循环展开那个例子如果64是65是不是就越界了？实践的代码如果length为6按条件只会循环一次那下标为4、5的不就执行不到了吗？","like_count":1},{"had_liked":false,"id":24571,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1537147571,"is_pvip":false,"replies":[{"id":"9019","content":"对的！不叫强度削弱，叫向量化，下一篇讲","user_name":"作者回复","comment_id":24571,"uid":"1176688","ip_address":"","utype":1,"ctime":1537175005,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"5832114867","product_id":100010301,"comment_content":"这样展开后有一个强度削弱的机会，四个byte的赋值合并成一个int？","like_count":2,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":424039,"discussion_content":"对的！不叫强度削弱，叫向量化，下一篇讲","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1537175005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239970,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1596703597,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596703597","product_id":100010301,"comment_content":"可以的，第一次就按到有人通过编译后的指令查找重复的，优化循环，厉害了。","like_count":0},{"had_liked":false,"id":209053,"user_name":"小羊","can_delete":false,"product_type":"c1","uid":1000877,"ip_address":"","ucode":"50239B7052BFD2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epgKOrnIOAjzXJgb0f0ljTZLeqrMXYaHic1MKQnPbAzxSKgYxd7K2DlqRW8SibTkwV2MAUZ4OlgRnNw/132","comment_is_top":false,"comment_ctime":1587482896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587482896","product_id":100010301,"comment_content":"想起之前看的 duff装置 了","like_count":0},{"had_liked":false,"id":114257,"user_name":"Yoph","can_delete":false,"product_type":"c1","uid":1050702,"ip_address":"","ucode":"48E676BA29EC3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/08/4e/87e40222.jpg","comment_is_top":false,"comment_ctime":1563262342,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1563262342","product_id":100010301,"comment_content":"这些优化全都是即时编译器做的，解释器的执行过程中有相关的优化吗？","like_count":0,"discussions":[{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284962,"discussion_content":"解释执行不会生成IR图，基本分析不出来啥。看下字节码就行了，优化不多","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592701418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":30491,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1538885765,"is_pvip":false,"replies":[{"id":"11052","content":"对的，如果是常量长度，而且小于4，那么完全展开就行了。","user_name":"作者回复","comment_id":30491,"uid":"1176688","ip_address":"","utype":1,"ctime":1538987786,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1538885765","product_id":100010301,"comment_content":"请问老师，实践环节的循环展开后的数组越界，编译器是怎么处理的？是不是当length小于4，循环完全展开就可以了，实际上这个展开有一个隐含的假定，即length大于4的情况。","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426022,"discussion_content":"对的，如果是常量长度，而且小于4，那么完全展开就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538987786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28657,"user_name":"白三岁","can_delete":false,"product_type":"c1","uid":1109892,"ip_address":"","ucode":"39594C357FEA1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/84/a0ffbd8b.jpg","comment_is_top":false,"comment_ctime":1538121151,"is_pvip":false,"replies":[{"id":"10320","content":"观察到位！这个主要是为了避免访问越界。你可以假定length为3，再看看这段代码。","user_name":"作者回复","comment_id":28657,"uid":"1176688","ip_address":"","utype":1,"ctime":1538125415,"user_name_real":"郑雨迪"}],"discussion_count":1,"race_medal":0,"score":"1538121151","product_id":100010301,"comment_content":"实践环节的代码，由于i++相应的变成了i+4。前面的判断条件dst.length就不应该减4了吧。","like_count":0,"discussions":[{"author":{"id":1176688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/70/2f61fa20.jpg","nickname":"郑雨迪","note":"","ucode":"F7CA1AE501EAFF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425340,"discussion_content":"观察到位！这个主要是为了避免访问越界。你可以假定length为3，再看看这段代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1538125415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25490,"user_name":"杨春鹏","can_delete":false,"product_type":"c1","uid":1172056,"ip_address":"","ucode":"518F38232F97B5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/58/8c8897c8.jpg","comment_is_top":false,"comment_ctime":1537343750,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537343750","product_id":100010301,"comment_content":"循环展开优化，如何防止出现数组下边越界？<br>Length=3n+2，每次循环展开n,n+1,n+2,当第n次循环结束的时候，下标开始从3n+1、3n+2、3n+3，那么访问3n+2与3n+3对应值时，就会出现数组越界。","like_count":0}]}