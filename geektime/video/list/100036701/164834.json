{"id":164834,"title":"36 | Netty编码中易错点解析","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/geek_netty\">https://gitee.com/geektime-geekbang/geek_netty</a></p>","comments":[{"had_liked":false,"id":159872,"user_name":"学习","can_delete":false,"product_type":"c3","uid":1729768,"ip_address":"","ucode":"5DE149E5906255","user_header":"","comment_is_top":false,"comment_ctime":1575814959,"is_pvip":false,"replies":[{"id":61503,"content":"读保证自上而下，写保证自下而上就行了，读与写之间其实顺序无所谓，但是一般为了好看对称，我们是一组一组写。案例中的顺序功能是没有问题的，只是让你产生了疑惑。\n你提出的这个不懂，我觉得我可以改下，但是如果我改了，或许你就没有这个问题了，哈哈，所以我要考虑下好看与教学效果之间做个平衡。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1576202869,"ip_address":"","comment_id":159872,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，handler的顺序那里还是没太懂，为什么两个encodeHandler放在frameDecodeHandler后面呢","like_count":10,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477193,"discussion_content":"读保证自上而下，写保证自下而上就行了，读与写之间其实顺序无所谓，但是一般为了好看对称，我们是一组一组写。案例中的顺序功能是没有问题的，只是让你产生了疑惑。\n你提出的这个不懂，我觉得我可以改下，但是如果我改了，或许你就没有这个问题了，哈哈，所以我要考虑下好看与教学效果之间做个平衡。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576202869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1076487,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIKoEicqUZTJly55qoUXRmK4wia7YbnibsMncJaO6tKgKAQNJRfpMsibvfeiaukIibsCsuaic8QjQ3gOoTGA/132","nickname":"张可夫斯基","note":"","ucode":"3B8DF6D98583F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375594,"discussion_content":"得在评论区才能真正学习到吗？！ 差评","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621760024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152235,"user_name":"夷，这也可以","can_delete":false,"product_type":"c3","uid":1487004,"ip_address":"","ucode":"09D87564352730","user_header":"https://static001.geekbang.org/account/avatar/00/16/b0/9c/0afabca6.jpg","comment_is_top":false,"comment_ctime":1573934070,"is_pvip":false,"replies":[{"id":59053,"content":"对于tcp大多如此的，但是有一种情况，就是如果你接受到数据，立马就转走，像路由器一样，那这个时候，你的处理就不需要那么多层次的编解码了，因为你不做处理，只是二转手，就像快递员一样，不会拆你的快递一样，就是给你转走；\n不是这种情况下，大多都需要4+1, 4是2组：1组处理粘包：1组处理转化给用户好用&#47;存储。最后那个1业务处理。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574300884,"ip_address":"","comment_id":152235,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，我问个比较业余的问题，因为你这个案例完全是基于tcp协议来的，所以第一次和第二次编解码也是自定义。客服端和服务端都是必须是同一套编解码。netty对其他协议的支持(http、mqtt等)就是根据消息协议的格式约定，实现数据的第一次和第二次编解码。当然也可能把第一次和第二次统一封装成一个编码类方便api调用。不过底层数据传输走的还是这几个步骤。也就是netty都可以看做4+1的处理方式来实现各种协议的网络传输处理。不知道理解的对不对？","like_count":4,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474762,"discussion_content":"对于tcp大多如此的，但是有一种情况，就是如果你接受到数据，立马就转走，像路由器一样，那这个时候，你的处理就不需要那么多层次的编解码了，因为你不做处理，只是二转手，就像快递员一样，不会拆你的快递一样，就是给你转走；\n不是这种情况下，大多都需要4+1, 4是2组：1组处理粘包：1组处理转化给用户好用/存储。最后那个1业务处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574300884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810156,"avatar":"","nickname":"poordickey","note":"","ucode":"2A436EC813AF97","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342874,"discussion_content":"老师应该按照顺序来排列  不然很容易误导   至于怎么排列好看是写代码风格的问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610862539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152069,"user_name":"zpzeng","can_delete":false,"product_type":"c3","uid":1697579,"ip_address":"","ucode":"BC53D95766FE7C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epOLt1slWbKAtNR9yjAfvrM73hlOQpe2Zzptah7jN3relYAhDudicALnysGfAPL0RjVdzhS7Y2Kbmg/132","comment_is_top":false,"comment_ctime":1573869093,"is_pvip":false,"replies":[{"id":59059,"content":"你这个感觉很好，我也是这么判断的，除了这点之外，你分2种情况看：别人写的和自己要写的，如果是别人写的，你看它可标记成@sharable了。如果自己写的，自己最清楚了，主要看可有线程安全和是否符合自己的需求，比如你统计整个系统的，一般都要做成共享的，如果你统计单一连接的，你肯定就是非共享的，不管用哪种方式去看，自己去实际分析代码最准确。其中就有你说的那个小方法，就是看那个类可有成员变量，如果一个没有，十有八九都可以共享。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574302305,"ip_address":"","comment_id":152069,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师，对于channelHandler是否共享有没有什么一般性原则，判断依据。我感觉demo里Server端的几个Handler都没有对传入的参数引用做保存，修改操作，我觉得并发没问题，那是不是就可以全部都共享。","like_count":2,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474705,"discussion_content":"你这个感觉很好，我也是这么判断的，除了这点之外，你分2种情况看：别人写的和自己要写的，如果是别人写的，你看它可标记成@sharable了。如果自己写的，自己最清楚了，主要看可有线程安全和是否符合自己的需求，比如你统计整个系统的，一般都要做成共享的，如果你统计单一连接的，你肯定就是非共享的，不管用哪种方式去看，自己去实际分析代码最准确。其中就有你说的那个小方法，就是看那个类可有成员变量，如果一个没有，十有八九都可以共享。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574302305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151723,"user_name":"鱼向北游","can_delete":false,"product_type":"c3","uid":1439908,"ip_address":"","ucode":"580EC7DCE57E9A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/IPdZZXuHVMibwfZWmm7NiawzeEFGsaRoWjhuN99iaoj5amcRkiaOePo6rH1KJ3jictmNlic4OibkF4I20vOGfwDqcBxfA/132","comment_is_top":false,"comment_ctime":1573781888,"is_pvip":false,"replies":[{"id":58355,"content":"客户端常见，服务器端见的少些，还是看具体需求，但是一定要搞清楚两者之间区别，否则要不多绕了一圈，要不就搞出问题了。当然有很多时候也不出问题，这里列出来的意思就是让大家要搞清楚这两个不一样，写的时候，小心点，如果用好了，能节约调用。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1573786618,"ip_address":"","comment_id":151723,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"感觉channel.writeandflush也挺常见呀，有时候接的消息为了解耦是直接放队列，然后消费调rpc，等rpc返回的时候一般找的都是channel呀，再用writeandflush写出去，好像那时候就没ctx了","like_count":2,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474589,"discussion_content":"客户端常见，服务器端见的少些，还是看具体需求，但是一定要搞清楚两者之间区别，否则要不多绕了一圈，要不就搞出问题了。当然有很多时候也不出问题，这里列出来的意思就是让大家要搞清楚这两个不一样，写的时候，小心点，如果用好了，能节约调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573786618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1370304,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLNgTWpN9vEUMZ77xTkiaPibX8E22c2L5GTmkgyP4cajbNiap5zEp28HicvA8eOCQqYo7YDsAhuafict2Q/132","nickname":"Geek_lbv7gj","note":"","ucode":"0CD6F332407936","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534062,"discussion_content":"我们就是这么做的，解耦后，但是发消息并不是在read放大里面，所以这个不会死循环","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638085442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1850248,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erZCyXaP2gbxwFHxvtnyaaF2Pyy5KkSMsk9kh7SJl8icp1CD6wicb6VJibiblGibbpDo6IuHrdST6AnWQg/132","nickname":"Geek_1cc6d1","note":"","ucode":"3E083616DD0742","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347227,"discussion_content":"客户端就没有死循环的问题了么？为什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612178440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305153,"user_name":"zhangtnty","can_delete":false,"product_type":"c3","uid":1180553,"ip_address":"","ucode":"3C9A14BD7CF432","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/89/e1621a01.jpg","comment_is_top":false,"comment_ctime":1627864604,"is_pvip":false,"replies":[{"id":113841,"content":"嗯，确实容易误导入。以前我也犯过类似的错：很多JAR立马的类名字一样，有天选错了.....","user_name":"作者回复","user_name_real":"傅健","uid":1638649,"ctime":1632966752,"ip_address":"","comment_id":305153,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"对于老师的示例，还有个非常不起眼但很难排查到的错误：\n示例里定义的:MessageConfigFrameDecoder,MessageConfigFrameEncoder,MessageConfigProtocolEncoder,MessageConfigProtocolDecoder这四个类在Client端和Server端名称一致，会造成：Client端用了Server端的，Server端用了Client端的。结果是启动Client时无任何报错，在Server端就是收不到Read信息，所以还是建议对应名称应该有所区分。","like_count":1,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524298,"discussion_content":"嗯，确实容易误导入。以前我也犯过类似的错：很多JAR立马的类名字一样，有天选错了.....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632966752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151578,"user_name":"Gary","can_delete":false,"product_type":"c3","uid":1218372,"ip_address":"","ucode":"12265D6A578113","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/44/3929e620.jpg","comment_is_top":false,"comment_ctime":1573743400,"is_pvip":false,"replies":[{"id":58346,"content":"这个问题很好，其实是风格问题，你说的那样也可以，但是现在大多都是按照我那样的写法写，因为体现一对一对的感觉，很清晰，如果按照你想要的那种写法，其实让别人看到的是那种业务逻辑处理的感觉了，然后读者还要去读去找，看看你是不是一对一对的了。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1573786159,"ip_address":"","comment_id":151578,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师您好，为什么注册时inboundhandler中夹着outboundhandler，不是先写完inboundhandler再写outboubdhandler?","like_count":1,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474541,"discussion_content":"这个问题很好，其实是风格问题，你说的那样也可以，但是现在大多都是按照我那样的写法写，因为体现一对一对的感觉，很清晰，如果按照你想要的那种写法，其实让别人看到的是那种业务逻辑处理的感觉了，然后读者还要去读去找，看看你是不是一对一对的了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573786159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1467281,"avatar":"https://static001.geekbang.org/account/avatar/00/16/63/91/05f491f1.jpg","nickname":"lm a cat","note":"","ucode":"8269EB2082BD43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115541,"discussion_content":"\n我看代码如果用cxt往外写out不能再最后，写时候直接是cxt. prev往前找的，会找不到最后out","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578018359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053078,"avatar":"https://static001.geekbang.org/account/avatar/00/10/11/96/2aa4debe.jpg","nickname":"林培凯","note":"","ucode":"2834C594AEE3FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54918,"discussion_content":"我觉得也有可能是因为，这种编排顺序在InboundHandler处理的时候直接调用ctx.write能走到排在前面的OutboundHandler的缘故。所以是先写一个InboundHandler 在写 OutboundHandlerhandler 之后是剩下的InboundHandler 。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574325360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193574,"user_name":"yang","can_delete":false,"product_type":"c3","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1584929591,"is_pvip":false,"replies":[{"id":79269,"content":"加油，主要还是自己练习一遍。不然貌似懂了不定真正理解的。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1588634347,"ip_address":"","comment_id":193574,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"之前看到第二章编解码就坚持不下去了。\n看到评论又重新从第四章开始看，第四张看是看完了。\n先跟着老师把第四张做完，再继续其他。\n前三章需要实践一些再去看，会更有效果。\n无论如何，老师讲的很好，加油！","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488590,"discussion_content":"加油，主要还是自己练习一遍。不然貌似懂了不定真正理解的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588634347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178250,"user_name":"密码123456","can_delete":false,"product_type":"c3","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1581643437,"is_pvip":false,"replies":[{"id":69665,"content":"速度还可以！","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1582003336,"ip_address":"","comment_id":178250,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"看完了一章，然后一口气行云流水写下来。写了1小时。调试4小时。::&gt;_&lt;::","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483727,"discussion_content":"速度还可以！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582003336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167836,"user_name":"AAA","can_delete":false,"product_type":"c3","uid":1192714,"ip_address":"","ucode":"5FE1F047BF2A7E","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/0a/2b10c687.jpg","comment_is_top":false,"comment_ctime":1577947451,"is_pvip":false,"replies":[{"id":65168,"content":"你这样说不是割裂了请求处理和响应了么？而且你说的不对吧。\n请求是先解码，解出最终的业务请求，然后执行，然后再编码，作为响应发送回去。\n就像在U型滑道上单向玩板车一样，是一个连续的过程。\n","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1577955555,"ip_address":"","comment_id":167836,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师,handler顺序问题是不是处理请求的时候是顺序处理响应是倒序的,因为处理请求的时候是先拼装消息体再Encode,而处理响应是先Decode再解析消息体,是这样吗?","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480018,"discussion_content":"你这样说不是割裂了请求处理和响应了么？而且你说的不对吧。\n请求是先解码，解出最终的业务请求，然后执行，然后再编码，作为响应发送回去。\n就像在U型滑道上单向玩板车一样，是一个连续的过程。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577955555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167315,"user_name":"虹炎","can_delete":false,"product_type":"c3","uid":1600615,"ip_address":"","ucode":"9E28ACEBFB26D5","user_header":"https://static001.geekbang.org/account/avatar/00/18/6c/67/07bcc58f.jpg","comment_is_top":false,"comment_ctime":1577762047,"is_pvip":false,"replies":[{"id":65080,"content":"参考这个实现：io.netty.handler.codec.LengthFieldBasedFrameDecoder#decode(io.netty.channel.ChannelHandlerContext, io.netty.buffer.ByteBuf)\n\n首先，你这样做，netty不知道你是故意的，所以他认为这个数据还没有传完，所以会等你第二个正确的数据过来的时候，把你第二个数据（或部分，反正一共900字节）合并前面的100字节当第一个数据来处理，说是处理，还是传给你业务层，这个时候，一般你肯定会出错的（比如你做json解析肯定抛异常了），因为这个数据不是完整正确的。所以这个时候下步怎么走，要看你的io.netty.channel.ChannelHandler#exceptionCaught\n怎么实现了。\n这种情况，很难恢复回来了，所以可以直接在这个方法的实现中，直接把连接断掉。\n\n你后面的问题，所以你要做授权（后面一章的内容）等防范，如果都授权过了。那别人就没有机会来发送这种数据。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1577929495,"ip_address":"","comment_id":167315,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100036701,"comment_content":"老师我问的第三个问题，如果我发送数据的数据长度length写为1000byte,实际传数据100个byte. netty怎么处理这种传输的数据呢？ 我第一次发送数据是故意这样做，第二次以后，就发送正确的数据，netty是不是就会报错了，如果用LengthFieldBasedFrameDecoder。netty怎么处理，别人知道协议后，故意发送这种不符合要求的数据攻击呢。","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479822,"discussion_content":"参考这个实现：io.netty.handler.codec.LengthFieldBasedFrameDecoder#decode(io.netty.channel.ChannelHandlerContext, io.netty.buffer.ByteBuf)\n\n首先，你这样做，netty不知道你是故意的，所以他认为这个数据还没有传完，所以会等你第二个正确的数据过来的时候，把你第二个数据（或部分，反正一共900字节）合并前面的100字节当第一个数据来处理，说是处理，还是传给你业务层，这个时候，一般你肯定会出错的（比如你做json解析肯定抛异常了），因为这个数据不是完整正确的。所以这个时候下步怎么走，要看你的io.netty.channel.ChannelHandler#exceptionCaught\n怎么实现了。\n这种情况，很难恢复回来了，所以可以直接在这个方法的实现中，直接把连接断掉。\n\n你后面的问题，所以你要做授权（后面一章的内容）等防范，如果都授权过了。那别人就没有机会来发送这种数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577929495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166660,"user_name":"虹炎","can_delete":false,"product_type":"c3","uid":1600615,"ip_address":"","ucode":"9E28ACEBFB26D5","user_header":"https://static001.geekbang.org/account/avatar/00/18/6c/67/07bcc58f.jpg","comment_is_top":false,"comment_ctime":1577538913,"is_pvip":false,"replies":[{"id":64861,"content":"1 你的理解对的；\n2 长度体现在OrderFrameDecoder里面，它继承了netty自带的LengthFieldBasedFrameDecoder，能处理长度相关的事情。如果忘记原理，可以参考第二章的粘包、半包那一节再看一遍。\n3 等于半包了，会把数据先buffer下，然后等待后面的900字节，完整后再解析出来。\n4 是整个，但是前面readInt、readLong等已经读走了部分数据，后面的tostring()返回的其实是readable的数据。\n","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1577672899,"ip_address":"","comment_id":166660,"utype":1}],"discussion_count":5,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"1，frame=length，version，opCode，streamld，operation&#47;operation result\nlength=version，opCode，streamld，operation&#47;operation result\n我理解length表示version，opCode，streamld，operation&#47;operation result 总字节数。\n我在代码中没有看到length值的设置。还是我理解错了呢？\n2，因为不知到length大小（我理解的发送的数据总字节数），public class OrderFrameDecoder extends LengthFieldBasedFrameDecoder。LengthFieldBasedFrameDecoder类怎么知道数据有没有接收完呢？它应该不知道数据的边界啊。\n3，如果我发送数据的数据长度length写为1000byte,实际传数据100个byte. netty怎么处理这种\n传输的数据呢？\n4，public void encode(ByteBuf byteBuf) {\n        byteBuf.writeInt(messageHeader.getVersion());\n        byteBuf.writeLong(messageHeader.getStreamId());\n        byteBuf.writeInt(messageHeader.getOpCode());\n        byteBuf.writeBytes(JsonUtil.toJson(messageBody).getBytes());\n    }\n\n    public void decode(ByteBuf msg) {\n        int version = msg.readInt();\n        long streamId = msg.readLong();\n        int opCode = msg.readInt();\n        MessageHeader messageHeader = new MessageHeader();\n        messageHeader.setVersion(version);\n        messageHeader.setOpCode(opCode);\n        messageHeader.setStreamId(streamId);\n        this.messageHeader = messageHeader;\n        Class&lt;T&gt; bodyClazz = getMessageBodyDecodeClass(opCode);\n        T body = JsonUtil.fromJson(msg.toString(Charset.forName(&quot;UTF-8&quot;)), bodyClazz);\n        this.messageBody = body;\n    }\n老师： JsonUtil.fromJson(msg.toString(Charset.forName(&quot;UTF-8&quot;))，这里的msg怎么没有包含\nversion,streamId,opCode呢。虽然读索引往后走了，我感觉msg应该还是整个ByteBuf啊，包含\nversion,streamId,opCode数据。怎么回事呢？怎么反序化就成功了呢？期待老师的解答。","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479574,"discussion_content":"1 你的理解对的；\n2 长度体现在OrderFrameDecoder里面，它继承了netty自带的LengthFieldBasedFrameDecoder，能处理长度相关的事情。如果忘记原理，可以参考第二章的粘包、半包那一节再看一遍。\n3 等于半包了，会把数据先buffer下，然后等待后面的900字节，完整后再解析出来。\n4 是整个，但是前面readInt、readLong等已经读走了部分数据，后面的tostring()返回的其实是readable的数据。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577672899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1444978,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eryISBbUnI2TMKAwVltOd5tLdbQDunvubib8hzoTjOfORmBp4ib2RDvGlUFpydSoLHkEa2CeJJ4j1rQ/132","nickname":"有个不可","note":"","ucode":"D8B8C0796C9A7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":108662,"discussion_content":"AbstractByteBuf中readInt()后readerIndex += 4；然后调用toString(Charset.forName(&#34;UTF-8&#34;)时，底层调用ByteBufUtil.decodeString(this, index, length, charset);会从readerIndex后读取长度为(writerIndex - readerIndex)的byte[]，然后转String返回。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577633165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1600615,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6c/67/07bcc58f.jpg","nickname":"虹炎","note":"","ucode":"9E28ACEBFB26D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1444978,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eryISBbUnI2TMKAwVltOd5tLdbQDunvubib8hzoTjOfORmBp4ib2RDvGlUFpydSoLHkEa2CeJJ4j1rQ/132","nickname":"有个不可","note":"","ucode":"D8B8C0796C9A7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109791,"discussion_content":"厉害了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577711322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":108662,"ip_address":"","group_id":0},"score":109791,"extra":""},{"author":{"id":1274464,"avatar":"https://static001.geekbang.org/account/avatar/00/13/72/60/288023be.jpg","nickname":"YU","note":"","ucode":"4EE45D6FC2862F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1600615,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6c/67/07bcc58f.jpg","nickname":"虹炎","note":"","ucode":"9E28ACEBFB26D5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277006,"discussion_content":"建议debug下源码，底层设置了长度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590981039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":109791,"ip_address":"","group_id":0},"score":277006,"extra":""}]},{"author":{"id":1600615,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6c/67/07bcc58f.jpg","nickname":"虹炎","note":"","ucode":"9E28ACEBFB26D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109784,"discussion_content":"老师我问的第三个问题，如果我发送数据的数据长度length写为1000byte,实际传数据100个byte. netty怎么处理这种传输的数据呢？ 我第一次发送数据是故意这样做，第二次以后，就发送正确的数据，netty是不是就会报错了。netty怎么处理知道协议后，故意发送这种不符合要求的数据攻击呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577711180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166656,"user_name":"虹炎","can_delete":false,"product_type":"c3","uid":1600615,"ip_address":"","ucode":"9E28ACEBFB26D5","user_header":"https://static001.geekbang.org/account/avatar/00/18/6c/67/07bcc58f.jpg","comment_is_top":false,"comment_ctime":1577537371,"is_pvip":false,"replies":[{"id":64857,"content":"体现在OrderFrameDecoder里面，它继承了netty自带的LengthFieldBasedFrameDecoder，能处理长度相关的事情。如果忘记原理，可以参考第二章再看一遍。","user_name":"作者回复","user_name_real":"stroller","uid":1638649,"ctime":1577672308,"ip_address":"","comment_id":166656,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"frame=length，version，opCode，streamld，operation&#47;operation result.\nlength = version，opCode，streamld，operation&#47;operation result.  通过之前的例子，这里的length不是表示\nversion，opCode，streamld，operation&#47;operation result 的总字节长度吗？老师的demo,我没发现length体现在\n哪里啊?求解答。\n\n","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479572,"discussion_content":"体现在OrderFrameDecoder里面，它继承了netty自带的LengthFieldBasedFrameDecoder，能处理长度相关的事情。如果忘记原理，可以参考第二章再看一遍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577672308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153765,"user_name":"夷，这也可以","can_delete":false,"product_type":"c3","uid":1487004,"ip_address":"","ucode":"09D87564352730","user_header":"https://static001.geekbang.org/account/avatar/00/16/b0/9c/0afabca6.jpg","comment_is_top":false,"comment_ctime":1574304160,"is_pvip":false,"replies":[{"id":59080,"content":"是的，你说的对的，我感觉你很理解了，看需求，比如你不需要根据信息里面的内容做判断（比如），你就直接中转扔出去，但是像快递那个例子，你要看下编号什么的，那就做一层解码，然后扔出去，所以说做几层看业务需求，大多都是二层。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574304801,"ip_address":"","comment_id":153765,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"有一种情况，就是如果你接受到数据，立马就转走，像路由器一样，那这个时候，你的处理就不需要那么多层次的编解码了，因为你不做处理，只是二转手，就像快递员一样，不会拆你的快递一样，就是给你转走； \n老师这种情况一般是1层编解码还是不需要？我的一个疑问是，路由转发也是有一定规则的，这个规则的判断也是需要对信息识别的，那还是要编解码呀？还是说传输过程中也有类似快递单号那样特殊消息(这个特殊消息是否需要编解码呢？)能帮我们，理解不到位，请老师指教！","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475265,"discussion_content":"是的，你说的对的，我感觉你很理解了，看需求，比如你不需要根据信息里面的内容做判断（比如），你就直接中转扔出去，但是像快递那个例子，你要看下编号什么的，那就做一层解码，然后扔出去，所以说做几层看业务需求，大多都是二层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574304801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153160,"user_name":"Gary","can_delete":false,"product_type":"c3","uid":1218372,"ip_address":"","ucode":"12265D6A578113","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/44/3929e620.jpg","comment_is_top":false,"comment_ctime":1574171299,"is_pvip":false,"replies":[{"id":59049,"content":"是的，有其他人也反映顺序的设置是否像你说的那样更合理，当时考虑是说netty的案例真的挺简单的，上来直接说，缺乏一点基础的人，肯定觉得很晕，不知道在讲什么，所以就故意把顺序颠倒过来，这样可能更适合新手，但是也出现一些有经验的人，觉得这样的设计没有先案例后原理的好，所以只能建议反过来再看一遍，因为确实有的时候，一次看不明白，就需要翻书对照着看，好在总时长不长，就当复习也可以。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574300526,"ip_address":"","comment_id":153160,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"也许是个人对java刚接触不久，一直从事c++开发的原因，感觉应该从第四章开始学，学完了用法示例再看前面的原理和源码分析效果更好。","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475064,"discussion_content":"是的，有其他人也反映顺序的设置是否像你说的那样更合理，当时考虑是说netty的案例真的挺简单的，上来直接说，缺乏一点基础的人，肯定觉得很晕，不知道在讲什么，所以就故意把顺序颠倒过来，这样可能更适合新手，但是也出现一些有经验的人，觉得这样的设计没有先案例后原理的好，所以只能建议反过来再看一遍，因为确实有的时候，一次看不明白，就需要翻书对照着看，好在总时长不长，就当复习也可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574300526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152594,"user_name":"小不点","can_delete":false,"product_type":"c3","uid":1351860,"ip_address":"","ucode":"C307D44A185C34","user_header":"https://static001.geekbang.org/account/avatar/00/14/a0/b4/5173f1af.jpg","comment_is_top":false,"comment_ctime":1574047461,"is_pvip":false,"replies":[{"id":59047,"content":"你快坚持到底了，哈哈","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574300370,"ip_address":"","comment_id":152594,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"呦西，学到了学到了，周三再见了。。。","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474868,"discussion_content":"你快坚持到底了，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574300370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151782,"user_name":"十年","can_delete":false,"product_type":"c3","uid":1115805,"ip_address":"","ucode":"A246C22CD6E5F2","user_header":"https://static001.geekbang.org/account/avatar/00/11/06/9d/3c121a1c.jpg","comment_is_top":false,"comment_ctime":1573790809,"is_pvip":false,"replies":[{"id":59055,"content":"可以的，业务层就是我们自己的业务逻辑了，随便怎么搞都可以。","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1574301177,"ip_address":"","comment_id":151782,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师，请问业务处理层，一般会使用spring管理bean，集成mybatis吗？","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474613,"discussion_content":"可以的，业务层就是我们自己的业务逻辑了，随便怎么搞都可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574301177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151071,"user_name":"吃饭饭","can_delete":false,"product_type":"c3","uid":1231549,"ip_address":"","ucode":"95CFA07CDA2957","user_header":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","comment_is_top":false,"comment_ctime":1573650534,"is_pvip":false,"replies":[{"id":58168,"content":"是的，处理的逻辑在netty自己的类里面：LengthFieldBasedFrameDecoder，可以回看12-13节内容。参考io.netty.handler.codec.LengthFieldBasedFrameDecoder#decode(io.netty.channel.ChannelHandlerContext, io.netty.buffer.ByteBuf)","user_name":"作者回复","user_name_real":"Geek_9bc307","uid":1638649,"ctime":1573659135,"ip_address":"","comment_id":151071,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"有个地方不明白：我们自定义的消息包含 Body 和 Header，为了解决粘包和半包需要添加一个 Length 字段，但是我没找到处理这个实际处理的地方呢，难道仅仅设置一个  lengthFieldLength = 2 就可以实现解析自定义的消息吗？","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474353,"discussion_content":"是的，处理的逻辑在netty自己的类里面：LengthFieldBasedFrameDecoder，可以回看12-13节内容。参考io.netty.handler.codec.LengthFieldBasedFrameDecoder#decode(io.netty.channel.ChannelHandlerContext, io.netty.buffer.ByteBuf)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573659135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281856,"user_name":"毛开头","can_delete":false,"product_type":"c3","uid":1181304,"ip_address":"","ucode":"BC14DF90D801D3","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/78/8f5435e3.jpg","comment_is_top":false,"comment_ctime":1614927889,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"老师 如果我要读取串口设备发出的数据 能不能不要解码 直接读取byte数组","like_count":0},{"had_liked":false,"id":247423,"user_name":"xinnong","can_delete":false,"product_type":"c3","uid":1005415,"ip_address":"","ucode":"3C1F1EB93FBA5B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/67/01d1580f.jpg","comment_is_top":false,"comment_ctime":1599705399,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"请问我的理解是否正确？\nFrameDecoder(1)                                            FrameEncoder(5)\n          ProtocolDecoder(2)                  ProtocolEncoder(4)\n                                     Handler(3)\nhandler顺序的理解：\n1、(1)(2)(3)的顺序是固定的，从上到下\n2、(3)(4)(5)的顺序是固定的，从下到上\n3、(2)和(4)(5)的顺序是不固定的，只要保证前两条的顺序即可，比如下面两种排列都合法：\n（1）\n      （2）                \n                                                        （4）\n                                            （5）\n                   （3）\n（1）       \n                                                        （4）\n                                            （5）\n             （2）\n                   （3）","like_count":0},{"had_liked":false,"id":217960,"user_name":"GaGi","can_delete":false,"product_type":"c3","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1589682649,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100036701,"comment_content":"V字型的技巧，这个很可以，之前先从按顺序看，现在再逆序回去前面看，很可以；\n建议有字幕比较好，这个实战视频听的时候还是得反应下才get到","like_count":0}]}