{"id":607435,"title":"21｜采集引擎：实战接口抽象与模拟浏览器访问","content":"<p>你好，我是郑建勋。</p><p>我们知道，接口是实现功能模块化、构建复杂程序强有力的手段。在上一节课，我介绍了接口的最佳实践和原理。这一节课，让我们在爬虫程序中实战接口，对采集引擎完成接口抽象。</p><h2>接口抽象</h2><p>在<a href=\"https://time.geekbang.org/column/article/606005\">第19讲</a>，我们已经将爬取网站信息的代码封装为了fetch函数，完成了第一轮的功能抽象。但是随着爬取的网站越来越复杂，加上服务器本身的反爬机制等原因，我们需要用到不同的爬取技术。例如后面会讲到的模拟浏览器访问、代理访问等。要想比较容易地切换不同的爬取方法，用模块化的方式对功能进行组合、测试，我们可以很容易地想到可以对爬取网站数据的代码模块进行接口抽象。</p><h3>实战接口</h3><p>具体的做法，我们首先要创建一个新的文件夹，将package命名为collect，把它作为我们的采取引擎。之后所有和爬取相关的代码都会放在这个目录下。</p><pre><code class=\"language-plain\">mkdir collect\ntouch collect/collect.go\n</code></pre><p>接着我们要定义一个Fetcher接口，内部有一个方法签名Get，参数为网站的URL。后面我们还将对函数的方法签名进行改变，也会添加其他方法签名，比如用于控制超时的Context参数等。不过要知道的是，在Go语言中，对接口的变更是非常轻量的，我们不用提前费劲去设计。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">type Fetcher interface {\n\tGet(url string) ([]byte, error)\n}\n</code></pre><p>接下来，我们要定义一个结构体BaseFetch，用最基本的爬取逻辑实现Fetcher接口：</p><pre><code class=\"language-plain\">func (BaseFetch) Get(url string) ([]byte, error) {\n\tresp, err := http.Get(url)\n\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn nil, err\n\t}\n\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tfmt.Printf(\"Error status code:%d\", resp.StatusCode)\n\t}\n\tbodyReader := bufio.NewReader(resp.Body)\n\te := DeterminEncoding(bodyReader)\n\tutf8Reader := transform.NewReader(bodyReader, e.NewDecoder())\n\treturn ioutil.ReadAll(utf8Reader)\n}\n</code></pre><p>在main.go中定义一个类型为BaseFetch的结构体，用接口Fetcher接收并调用Get方法，这样就完成了使用接口来实现基本爬取的逻辑。</p><pre><code class=\"language-plain\">var f collect.Fetcher = collect.BaseFetch{}\nbody, err := f.Get(url)\n</code></pre><h3>模拟浏览器访问</h3><p>上面BaseFetch的Get函数是比较简单的，但有时我们需要对爬取进行更复杂的处理。例如我们用上面的代码去爬取豆瓣读书网站上的页面，则会失败。</p><pre><code class=\"language-plain\">url := \"https://book.douban.com/subject/1007305/\"\nvar f collect.Fetcher= collect.BaseFetch{}\nbody, err := f.Get(url)\n</code></pre><p>报错为<code>Error status code:418</code> ，服务器会返回一个不正常的状态码，并且没有正常的HTML内容。</p><p>为什么这个网站可以通过浏览器正常访问，但是通过程序却不行呢？这二者的区别在哪里？</p><p>显然，豆瓣现在有一些反爬机制阻止了我们对服务器的访问。如果我们使用浏览器的开发者工具（一般在windows下为F12快捷键），或者通过wireshark等抓包工具查看数据包，会看到浏览器自动在HTTP Header中设置了很多内容，其中比较重要的一个就是<strong>User-Agent字段，它可以表明当前正在使用的应用程序、设备类型和操作系统的类型与版本。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/61/80/61f4c891a54b3fe453e343505bda0780.png?wh=1920x967\" alt=\"图片\"></p><p>大多数浏览器使用<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent\">以下格式</a>发送<strong>User-Agent：</strong></p><pre><code class=\"language-plain\">Mozilla/5.0 (操作系统信息) 运行平台(运行平台细节) &lt;扩展信息&gt;\n</code></pre><p>我当前的Chrome（谷歌浏览器）发送的信息如下：</p><pre><code class=\"language-plain\">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36\n</code></pre><p>其中，Mozilla/5.0由于历史原因，是现在的主流浏览器都会发送的。</p><p><code>Macintosh; Intel Mac OS X 10_15_7</code> 代表当前操作系统的版本号。</p><p><code>AppleWebKit/537.36</code>  是在 Apple 设备上使用的 Web 渲染引擎标识符。</p><p><code>KHTML</code>是在 Safari 和 Chrome 上使用的引擎。</p><p><code>Chrome/103.0.0.0  Safari/537.36</code> 指代浏览器的名字和版本号。</p><p><strong>使用不同的浏览器、设备，User-Agent都会略有不同。</strong>不同应用程序的User-Agent参考如下：</p><pre><code class=\"language-plain\">Lynx: Lynx/2.8.8pre.4 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/2.12.23\n\nWget: Wget/1.15 (linux-gnu)\n\nCurl: curl/7.35.0\n\nSamsung Galaxy Note 4: Mozilla/5.0 (Linux; Android 6.0.1; SAMSUNG SM-N910F Build/MMB29M) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/4.0 Chrome/44.0.2403.133 Mobile Safari/537.36\n\nApple iPhone: Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1\n\nApple iPad: Mozilla/5.0 (iPad; CPU OS 8_4_1 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12H321 Safari/600.1.4\n\nMicrosoft Internet Explorer 11 / IE 11: Mozilla/5.0 (compatible, MSIE 11, Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko\n</code></pre><p><strong>有时候，我们的爬虫服务需要动态生成 User-Agent 列表，方便在测试、或者在使用代理大量请求单一网站时，动态设置不同的User-Agent（我会在后面的课程中给出相关的代码）。</strong></p><p>因为有些服务器会检测User-Agent，以此识别请求是否是特定的应用程序发出的，阻止爬虫机器人访问服务器。而使用正确的User-Agent会让我们的请求看起来更有“人性”，让我们能够更自由地从目标网站收集数据。</p><p>接下来我们就来实验一下。如下所示，我们创建一个新的结构体BrowserFetch并让其实现Fetcher接口。为了能够设置 HTTP 请求头，我们不能够再使用简单的http.Get方法了。</p><p>我们首先要创建一个HTTP客户端http.Client，然后通过http.NewRequest创建一个请求。在请求中调用req.Header.Set设置User-Agent请求头。最后调用client.Do完成HTTP请求。</p><pre><code class=\"language-plain\">type BrowserFetch struct {\n}\n\n//模拟浏览器访问\nfunc (BrowserFetch) Get(url string) ([]byte, error) {\n\tclient := &amp;http.Client{}\n\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"get url failed:%v\", err)\n\t}\n\n\treq.Header.Set(\"User-Agent\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36\")\n\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbodyReader := bufio.NewReader(resp.Body)\n\te := DeterminEncoding(bodyReader)\n\tutf8Reader := transform.NewReader(bodyReader, e.NewDecoder())\n\treturn ioutil.ReadAll(utf8Reader)\n}\n</code></pre><p>其实http.Get方法之所以简单，只是对上面这些步骤完成了封装。如下所示，http.Get会默认生成内置的http.Client，创建请求NewRequest，并调用client.Do函数，client.Do最终会调用Transport.roundTrip函数发送请求。</p><pre><code class=\"language-plain\">var DefaultClient = &amp;Client{}\nfunc Get(url string) (resp *Response, err error) {\n\treturn DefaultClient.Get(url)\n}\n\nfunc (c *Client) Get(url string) (resp *Response, err error) {\n\treq, err := NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn c.Do(req)\n}\n\n</code></pre><p>现在我们只要在main函数中将采集引擎替换为collect.BrowserFetch，就可以轻松获取到豆瓣网站中的内容了。</p><pre><code class=\"language-plain\">func main() {\n\turl := \"https://book.douban.com/subject/1007305/\"\n\tvar f collect.Fetcher = collect.BrowserFetch{}\n\tbody, err := f.Get(url)\n\tif err != nil {\n\t\tfmt.Println(\"read content failed:%v\", err)\n\t\treturn\n\t}\n\tfmt.Println(string(body))\n}\n</code></pre><h3>远程访问浏览器</h3><p>仅仅在请求头中传递User-Agent是不够的。正如我们之前提到过的，浏览器引擎会对HTML与CSS文件进行渲染，并且执行JavaScript脚本，还可能会完成一些实时推送、异步调用工作。这导致内容会被延迟展示，无法直接通过简单的http.Get方法获取到数据。</p><p>更进一步的，有些数据需要进行用户交互，例如我们需要点击某些按钮才能获得这些信息。这就迫切地需要我们具有模拟浏览器的能力，或者更简单一点：直接操作浏览器，让浏览器来帮助我们爬取数据。</p><p>要借助浏览器的能力实现自动化爬取，目前依靠的技术有以下三种：</p><ul>\n<li>借助浏览器驱动协议（WebDriver protocol）远程与浏览器交互；</li>\n<li>借助谷歌开发者工具协议（CDP，Chrome DevTools Protocol）远程与浏览器交互；</li>\n<li>在浏览器应用程序中注入要执行的JavaScript，典型的工具有Cypress， TestCafe。</li>\n</ul><p>由于第三种技术通常只用于测试，所以下面我们就重点来说说前面两种技术。</p><h4><strong>Webdriver Protocol</strong></h4><p>Webdriver协议是操作浏览器的一种远程控制协议。借助Webdriver协议完成爬虫的框架或库有Selenium，WebdriverIO，Nightwatch，其中最知名的就是Selenium。<a href=\"https://www.selenium.dev/documentation/webdriver/getting_started/install_library/\">Selenium</a> 为每一种语言（例如Java、Python、Ruby等）都准备了一个对应的clinet库，它整合了不同浏览器的驱动（这些驱动由浏览器厂商提供，例如谷歌浏览器的驱动和火狐浏览器的驱动）。</p><p>Selenium通过 <a href=\"https://www.w3.org/TR/webdriver1/\">W3C 约定的 WebDriver 协议</a>与指定的浏览器驱动进行通信，之后浏览器驱动操作特定浏览器，从而实现开发者操作浏览器的目的。由于 Selenium 整合了不同的浏览器驱动，因此它对于不同的浏览器都具有良好的兼容性。</p><h4>Chrome DevTools Protocol</h4><p>第二种远程与浏览器交互的协议叫做<a href=\"https://chromedevtools.github.io/devtools-protocol/\">Chrome DevTools Protocol</a>（谷歌开发者工具协议）。顾名思义，该协议最初是由谷歌开发者工具团队维护的，负责调试、操作浏览器的协议。目前，现代大多数浏览器都支持谷歌开发者工具协议。我们经常使用到的谷歌浏览器的开发者工具（快捷键CTRL + SHIFT + I 或者 F12）就是使用这个协议来操作浏览器的。</p><p>查看谷歌开发者工具与浏览器交互的协议的方式是，打开谷歌浏览器，在开发者工具 →设置→ 实验中勾选 Protocol Monitor（协议监视器）。</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/4b/fddcc0df96472974ee9db23b29d3d64b.png?wh=1920x998\" alt=\"图片\"></p><p>接下来，我们要重启开发者工具，在右侧点击更多工具，这样就可以看到协议监视器面板了。面板中有开发者工具通过协议与浏览器交互的细节。</p><p><img src=\"https://static001.geekbang.org/resource/image/ed/44/ed222cd2ef88af365dcae3d14c631d44.png?wh=1920x1197\" alt=\"图片\"></p><p>与Selenium需要与浏览器驱动进行交互不同的是，Chrome DevTools协议直接通过Web Socket协议与浏览器暴露的API进行通信，这使得 Chrome DevTools 协议操作浏览器变得更快。</p><p>所以，相比Selenium，我更推荐使用Chrome DevTools协议来访问浏览器。Selenium 4虽然已经提供了对于Chrome DevTools协议的支持，但是它目前还没有对Go的官方的Client库。</p><p>在Go中实现了Chrome DevTools协议的知名第三方库是<a href=\"https://github.com/chromedp/chromedp\">chromedp</a>。它的操作简单，也不需要额外的依赖。借助<a href=\"https://github.com/chromedp/chromedp\">chromedp</a> 提供的能力与浏览器交互，我们就具有了许多灵活的能力，例如截屏、模拟鼠标点击、提交表单、下载/上传文件等。<a href=\"https://github.com/chromedp/chromedp\">chromedp</a> 的一些操作样例你可以参考<a href=\"https://github.com/chromedp/examples\">example代码库</a>。</p><p>这里我模拟鼠标点击事件，给你做一个演示。假设我们访问<a href=\"https://pkg.go.dev/time\">Go time 包的说明文档</a>，例如After函数，会发现下图的参考代码是折叠的。</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/dc/8eba17f2288ac4f75b707a0dd63e1bdc.png?wh=1920x1199\" alt=\"图片\"></p><p>通过鼠标点击，折叠的代码可以展示出time.After函数的参考代码。</p><p><img src=\"https://static001.geekbang.org/resource/image/54/9b/54cd4cf8e5a0fa819579654bd93fb59b.png?wh=1920x1171\" alt=\"图片\"></p><p>我们经常面临这种情况，即需要完成一些交互才能获取到对应的数据。要模拟上面的完整操作，代码如下所示：</p><pre><code class=\"language-plain\">package main\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/chromedp/chromedp\"\n)\n\nfunc main() {\n\t// 1、创建谷歌浏览器实例\n\tctx, cancel := chromedp.NewContext(\n\t\tcontext.Background(),\n\t)\n\tdefer cancel()\n\n\t// 2、设置context超时时间\n\tctx, cancel = context.WithTimeout(ctx, 15*time.Second)\n\tdefer cancel()\n\n\t// 3、爬取页面，等待某一个元素出现,接着模拟鼠标点击，最后获取数据\n\tvar example string\n\terr := chromedp.Run(ctx,\n\t\tchromedp.Navigate(`https://pkg.go.dev/time`),\n\t\tchromedp.WaitVisible(`body &gt; footer`),\n\t\tchromedp.Click(`#example-After`, chromedp.NodeVisible),\n\t\tchromedp.Value(`#example-After textarea`, &amp;example),\n\t)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(\"Go's time.After example:\\\\n%s\", example)\n}\n</code></pre><p>解释一下。<strong>首先我们导入了chromedp库，并调用chromedp.NewContext为我们创建了一个浏览器的实例。</strong>它的实现原理非常简单，即查找当前系统指定路径下指定的谷歌应用程序，并默认用无头模式（Headless模式）启动谷歌浏览器实例。通过无头模式，我们肉眼不会看到谷歌浏览器窗口的打开过程，但它确实已经在后台运行了。</p><pre><code class=\"language-plain\">func findExecPath() string {\n\tvar locations []string\n\tswitch runtime.GOOS {\n\tcase \"darwin\":\n\t\tlocations = []string{\n\t\t\t// Mac\n\t\t\t\"/Applications/Chromium.app/Contents/MacOS/Chromium\",\n\t\t\t\"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome\",\n\t\t}\n\tcase \"windows\":\n\t\tlocations = []string{\n\t\t\t// Windows\n\t\t\t\"chrome\",\n\t\t\t\"chrome.exe\", // in case PATHEXT is misconfigured\n\t\t\t`C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe`,\n\t\t\t`C:\\\\Program Files\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe`,\n\t\t\tfilepath.Join(os.Getenv(\"USERPROFILE\"), `AppData\\\\Local\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe`),\n\t\t\tfilepath.Join(os.Getenv(\"USERPROFILE\"), `AppData\\\\Local\\\\Chromium\\\\Application\\\\chrome.exe`),\n\t\t}\n\tdefault:\n\t\tlocations = []string{\n\t\t\t// Unix-like\n\t\t\t\"headless_shell\",\n\t\t\t...\n\t\t}\n\t}\n</code></pre><p>所以说，当前程序能够运行的重要前提是在指定路径中存在谷歌浏览器程序。当然，一般我们系统中可浏览的谷歌浏览器的大小都是比较大的，所以chromedp还好心地为我们提供了一个包含了无头谷歌浏览器的应用程序的镜像：<a href=\"https://hub.docker.com/r/chromedp/headless-shell/\">headless-shell</a>。</p><p><strong>第二步，用 context.WithTimeout 设置当前爬取数据的超时时间，这里我们设置成了15s。</strong></p><p><strong>第三步，chromedp.Run执行多个action，chromedp中抽象了action和task两种行为。</strong>其中，action指的是爬取、等待、点击、获取数据这样的行为。而task指的是一个任务，task是多个action的集合。因此，chromedp.Run会将多个action封装为一个任务，并依次执行。</p><pre><code class=\"language-plain\">func Run(ctx context.Context, actions ...Action) error {\n\t...\n\treturn Tasks(actions).Do(cdp.WithExecutor(ctx, c.Target))\n}\n</code></pre><ul>\n<li>chromedp.Navigate指的是爬取指定的网址：<a href=\"https://pkg.go.dev/time\">https://pkg.go.dev/time</a>。</li>\n<li>chromedp.WaitVisible指的是“等待当前标签可见”，其参数使用的是CSS选择器的形式。在这个例子中，body &gt; footer标签可见，代表正文已经加载完毕。</li>\n<li>chromedp.Click指的是“模拟对某一个标签的点击事件”。</li>\n<li>chromedp.Value用于获取指定标签的数据。<br>\n最终代码执行结果如下，这样我们就成功获取到了time.After的代码示例。</li>\n</ul><pre><code class=\"language-plain\">2022/10/24 17:26:46 Go's time.After example:\npackage main\n\nimport (\n        \"fmt\"\n        \"time\"\n)\n\nvar c chan int\n\nfunc handle(int) {}\n\nfunc main() {\n        select {\n        case m := &lt;-c:\n                handle(m)\n        case &lt;-time.After(10 * time.Second):\n                fmt.Println(\"timed out\")\n        }\n}\n</code></pre><p>在后面的课程中，我们还会对<a href=\"https://github.com/chromedp/chromedp\">chromedp</a>进行封装，实现我们定义的采集引擎的接口。你也可以先试着使用<a href=\"https://github.com/chromedp/chromedp\">chromedp</a>来构建一下自己的采集引擎。<br>\n可以看到，接口在这里再次发挥了巨大作用。只要合理地组合设计，我们的程序就可以很方便地切换任何的采集引擎。不管是用原生还是模拟浏览器方式，不管是使用Selenium、chromedp的方式，亦或是未来新的采集方式，都不会破坏我们其他模块的代码。</p><h2>空接口</h2><p>好了，前面我们介绍的接口都是带有方法签名的。其实还有一类特殊的接口不带任何的方法签名，被称为空接口。我们在后面的项目中还会频繁使用到它。</p><p>任何类型都隐式实现了空接口。正如Go的创始人Rob Pike所说：“Empty interface say nothing”，空接口并没有任何的含义，既然如此，空接口有什么作用呢？</p><p>由于Go是强类型的语言，使用空接口可以为外界提供一个更加通用的能力。然而在处理接口的过程中却需要默默承受解析空接口带来的痛苦。通过使用空接口，常见的fmt.Println函数提供了打印任何类型的功能。</p><pre><code class=\"language-plain\">func Println(a ...interface{}) (n int, err error) {\n\treturn Fprintln(os.Stdout, a...)\n}\n</code></pre><p>如果不使用空接口，那么每一个类型都需要实现一个对应的Println函数，是非常不方便的。</p><p><strong>不过，空接口带来便利的同时，也意味着我们必须在内部解析接口的类型，并对不同的类型进行相应的处理。</strong>以fmt.Println为例，Println函数内部通过检测接口的具体类型来调用不同的处理函数。如果是自定义类型，还需要使用反射、递归等手段完成复杂类型的打印功能。</p><pre><code class=\"language-plain\">func (p *pp) printArg(arg interface{}, verb rune) {\n\t\tswitch f := arg.(type) {\n\t\t\tcase bool:\n\t\t\t\tp.fmtBool(f, verb)\n\t\t\tcase float32:\n\t\t\t\tp.fmtFloat(float64(f), 32, verb)\n\t\t\tcase float64:\n\t\t\t\tp.fmtFloat(f, 64, verb)\n\t\t\tcase complex64:\n\t\t\t\tp.fmtComplex(complex128(f), 64, verb)\n\t\t\t....\n}\n</code></pre><p>类似的API设计还有用于序列化与反序列化的JSON标准库等。</p><pre><code class=\"language-plain\">func Marshal(v interface{}) ([]byte, error) {\n\te := newEncodeState()\n\n\terr := e.marshal(v, encOpts{escapeHTML: true})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbuf := append([]byte(nil), e.Bytes()...)\n\n\tencodeStatePool.Put(e)\n\n\treturn buf, nil\n}\n</code></pre><p>JSON标准库内部使用了反射来判断接口中存储的实际类型，以此分配不同的序列化器。</p><pre><code class=\"language-plain\">func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {\n\t...\t\n\tswitch t.Kind() {\n\t\tcase reflect.Bool:\n\t\t\treturn boolEncoder\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\treturn intEncoder\n\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\t\treturn uintEncoder\n\t\t\t...\n\n}\n</code></pre><p><strong>除此之外，对于跨服务调用的API，使用空接口可以提高它们的扩展性。因为在这种场景下，修改API的成本通常比较高，服务器需要改造并发布新的SDK，客服端还需要适配新的SDK并联调测试。</strong></p><p>如下所示，在Info结构体中增加扩展类型 <code>map[string]interface{}</code>，新的功能如果需要传递新的信息，当前服务甚至可以不用修改API。</p><pre><code class=\"language-plain\">type info struct{\n  ExtraData               map[string]interface{}        `json:\"extra_data\"` \n  ...\n}\n</code></pre><p>在后面的课程中我们还会看到，由于爬虫爬取的数据是多种多样的，我们也会用空接口来实现数据存储的拓展性。</p><p>可以看出，空接口为API带来了扩展性和灵活性，但是也为模块的内部处理增加了额外的成本。因为API内部处理空接口时使用了大量的反射，而反射通常比较消耗性能。在实际项目中，当我们JSON序列化一个复杂的结构体时，有时候会有上百毫秒的耗时。</p><h3>空接口与反射</h3><p>空接口是实现反射的基础，因为空接口中会存储动态类型的信息，这为我们提供了复杂、意想不到的处理能力和灵活性。我们可以获取结构体变量内部的方法名、属性名，能够动态地检查函数或方法的参数个数和返回值个数，也可以在运行时通过函数名动态调用函数。这些能力不使用反射都无法做到。</p><p>举一个例子，假如现在有一个 Student 结构体：</p><pre><code class=\"language-plain\">type Student struct {\n\tAge int\n\tName string\n}\n</code></pre><p>如果我们希望写一个可以将该结构体转换为SQL语句的函数，按照过去的实现方式，可以为这个结构体添加一个CreateSQL方法：</p><pre><code class=\"language-plain\">func (s*Student) CreateSQL() string{\n\tsql := fmt.Sprintf(\"insert into student values(%d, %s)\", s.Age, s.Name)\n\treturn sql\n}\n</code></pre><p>这样当调用CreateSQL方法时，可以生成一条SQL语句：</p><pre><code class=\"language-plain\">func main() {\n\to := Student{\n\t\tAge: 20,\n\t\tName: \"jonson\",\n\t}\n\tfmt.Println(o.CreateSQL())\n}\n</code></pre><p>结果打印为：</p><pre><code class=\"language-plain\">insert into student values(20, jonson)\n</code></pre><p>但是，假如我们的其他结构体也有相同的需求呢？很显然，按照之前学过的知识，我们可以为每个类型都添加一个CreateSQL方法，并生成一个接口：</p><pre><code class=\"language-plain\">type SQL interface{\n\tfunc CreateSQL() string\n}\n</code></pre><p>这种方法在项目初期，以及结构体类型简单的时候是比较方便的。但是如果项目中定义的类型非常多，而且可能当前类型还没有被创建出来（需要运行时创建，或者通过远程过程调用触发），我们就要书写很多逻辑相同的重复代码。有没有一种更加简单通用的办法可以解决这一类问题呢？如果可以在运行时探测到结构体变量中的方法名就好了。</p><p>这恰恰就是反射为我们提供的便利。如下所示，我们可以将上面的场景改造成反射的形式。在createQuery函数中，我们可以传递任何的结构体类型，该函数会遍历结构体中所有的字段，并构造Query字符串。</p><pre><code class=\"language-plain\">func createQuery(q interface{}) string{\n\t// 判断类型为结构体\n\tif reflect.ValueOf(q).Kind() == reflect.Struct {\n\t\t// 获取结构体名字\n\t\tt := reflect.TypeOf(q).Name()\n\t\t// 查询语句\n\t\tquery := fmt.Sprintf(\"insert into %s values(\", t)\n\t\tv := reflect.ValueOf(q)\n\t\t// 遍历结构体字段\n\t\tfor i := 0; i &lt; v.NumField(); i++ {\n\t\t\t// 判断结构体类型\n\t\t\tswitch v.Field(i).Kind() {\n\t\t\tcase reflect.Int:\n\t\t\t\tif i == 0 {\n\t\t\t\t\tquery = fmt.Sprintf(\"%s%d\", query, v.Field(i).Int())\n\t\t\t\t} else {\n\t\t\t\t\tquery = fmt.Sprintf(\"%s, %d\", query, v.Field(i).Int())\n\t\t\t\t}\n\t\t\tcase reflect.String:\n\t\t\t\tif i == 0 {\n\t\t\t\t\tquery = fmt.Sprintf(\"%s\\\\\"%s\\\\\"\", query, v.Field(i).String())\n\t\t\t\t} else {\n\t\t\t\t\tquery = fmt.Sprintf(\"%s, \\\\\"%s\\\\\"\", query, v.Field(i).String())\n\t\t\t\t}\n\t\t\t\t...\n\t\t\t}\n\t\t}\n\t\tquery = fmt.Sprintf(\"%s)\", query)\n\t\tfmt.Println(query)\n\t\treturn query\n\t}\n}\n</code></pre><p>现在，假设我们新建了一个Trade结构体，任意结构体都可以通过createQuery方法完成构建过程。</p><pre><code class=\"language-plain\">type Trade struct {\n\ttradeId int\n\tPrice int\n}\n\nfunc main(){\n\tcreateQuery(Student{Age: 20, Name: \"jonson\",})\n\tcreateQuery(Trade{tradeId: 123, Price: 456,})\n}\n</code></pre><p>结果输出为：</p><pre><code class=\"language-plain\">insert into Student values(20, \"jonson\")\ninsert into Trade values(123, 456)\n</code></pre><p>通过反射，我们动态获取到了结构体中字段的名字，这样就可以灵活生成SQL语句了。<br>\n如果我们把上面这个例子中的函数改造为递归，然后处理更多的类型，这个函数将更加具备通用性，甚至可以作为一个好用的第三方库了。</p><h2>接口的陷阱</h2><p>刚才我们说了接口的很多好处，但是由于接口的特性和内部实现，使用接口时也容易出现几类经典的错误。</p><p><strong>第一类错误是，当接口中存储的是值，但是结构体是指针时，接口动态调用无法编译通过。</strong>如下所示：</p><pre><code class=\"language-plain\">type Binary struct {\n\tuint64\n}\ntype Stringer interface {\n\tString() string\n}\nfunc (i *Binary) String() string {\n\treturn \"hello world\"\n}\nfunc main(){\n\ta:= Binary{54}\n\tb := Stringer(a)\n\tb.String()\n}\n</code></pre><p>Go 语言在编译时阻止了这样的写法，原因在于这种写法会让人产生困惑。如果转换为接口的是值， 那么由于内存逃逸，在转换为接口时必定已经把值拷贝到了堆区。因此如果允许这种写法存在，那么即便看起来在方法中修改了接口中的值，却无法修改原始值，这非常容易引起误解。</p><p><strong>第二类错误是将类型切片转换为接口切片。</strong>如下所示：</p><pre><code class=\"language-plain\">func foo() []interface{} {\n\treturn []int{1,2,3}\n}\n</code></pre><p>这种情况仍然会在编译时报错：</p><pre><code class=\"language-plain\">cannot use []int literal (type []int) as type []interface {} in return argument\n</code></pre><p>Go 语言禁止了这种写法，就像前面所说的，批量转换为接口是效率非常低的操作。因为每个元素都需要完成内存逃逸的额外开销。</p><p><strong>接口的第三类陷阱涉及接口与nil之间的关系。当接口为nil时，接口中的动态类型itab和动态类型值data必须都为nil，初学者常常会在这个问题上犯错。</strong>例如在下面的foo函数中，由于返回的err没有任何动态类型和动态值，因此err等于nil。</p><pre><code class=\"language-plain\">func foo() error {\n\tvar err error // nil\n\treturn err\n}\nfunc main() {\n\terr := foo()\n\tfmt.Println(err == nil) // true\n}\n</code></pre><p>然而，如果在foo函数中将错误类型定义为自定义类型，例如*os.PathError ，我们会发现err不等于nil。</p><pre><code class=\"language-plain\">func foo() error {\n\tvar err *os.PathError \n\treturn err\n}\nfunc main() {\n\terr := foo()\n\tfmt.Println(err != nil) // true\n}\n</code></pre><p>这是因为当接口为nil时，代表接口中的动态类型和动态类型值都为nil，而当前由于接口error具有动态类型*os.PathError，接口的内部结构体itab不为空。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/91/2fb59aa910354e519df6070080cf3d91.jpg?wh=1920x752\" alt=\"图片\"></p><p>避免这一问题需要谨慎地使用自定义的Error作为定义，而更多的使用内置的errors.New或fmt.Errorf来生成和包裹错误。我在之后的课程还会详细介绍错误处理的最佳实践。</p><h2>总结</h2><p>这节课，我们通过一个模拟浏览器访问的案例实战了采集引擎的抽象。<strong>由于User-Agent标识了应用程序的类型和版本，所以我们将User-Agent设置成了真实浏览器的值，绕过了这个例子中服务器的反爬机制。</strong>不过这只是众多反爬机制中最简单的一种，通过对采集引擎接口的抽象，我们能够比较轻松地实现采集引擎的切换，并进行模块化的测试。</p><p>带方法的接口帮助我们完成了功能的模块化，而不带方法的空接口则增加了API的扩展性。同时，空接口是反射实现的基础，有了它我们才能有“获取字段名”、“通过函数名动态调用方法”这样复杂灵活的能力，因此空接口在一些基础库、RPC框架中的应用也非常广泛。</p><p>不过空接口带给我们的扩展性也有一定的代价，那就是它的内部需要解析繁琐的多种类型，使用反射导致效率变低。</p><h2>课后题</h2><p>最后，我也给你留一道思考题。</p><p>如果一个网站需要登录才可以访问，我们应该如何实现自动登录的能力？</p><p>欢迎你在留言区与我交流讨论，我们下节课再见！</p>","neighbors":{"left":{"article_title":"20｜面向组合：接口的使用场景与底层原理","id":606752},"right":{"article_title":"22｜优雅地离场: Context超时控制与原理","id":608112}},"comments":[{"had_liked":false,"id":363345,"user_name":"哈哈哈哈哈","can_delete":false,"product_type":"c1","uid":2828322,"ip_address":"北京","ucode":"0350A8A8A3DD74","user_header":"https://static001.geekbang.org/account/avatar/00/2b/28/22/ebc770dc.jpg","comment_is_top":false,"comment_ctime":1669555923,"is_pvip":false,"replies":[{"id":132248,"content":"https:&#47;&#47;github.com&#47;dreamerjackson&#47;crawler,注意看文中指明的tag分支","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1670265118,"ip_address":"北京","comment_id":363345,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"麻烦发个全部代码链接。小白，一段一段代码看着不是很懂","like_count":4,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595657,"discussion_content":"https://github.com/dreamerjackson/crawler,注意看文中指明的tag分支","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670265118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1793879,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5f/57/791d0f5e.jpg","nickname":"Geek_8ed998","note":"","ucode":"1C164836354665","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614488,"discussion_content":"你文中有指明tag吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681806932,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363429,"user_name":"Realm","can_delete":false,"product_type":"c1","uid":1081299,"ip_address":"北京","ucode":"30CBEBE619D1A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/d3/b5896293.jpg","comment_is_top":false,"comment_ctime":1669678865,"is_pvip":true,"replies":[{"id":132243,"content":"“接口中存储的是值”指的是接口中存储的已经并不是原始数据的引用了，如下代码会报错\ntype adder interface {\n\tAdd()\n}\ntype M struct{}\n\nfunc (m *M) Add() {\n\n}\nfunc main() {\n\tvar m adder = M{}\n\tm.Add()\n}\n# command-line-arguments\n.&#47;1_print.go:21:6: cannot use M{} (type M) as type adder in assignment:\n        M does not implement adder (Add method has pointer receiver)\n","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1670264953,"ip_address":"北京","comment_id":363429,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"&quot;第一类错误是，当接口中存储的是值，但是结构体是指针时，接口动态调用无法编译通过。&quot; 接口中存储的是值，结构体是指针，这句能展开说说吗？不是特别明白。","like_count":1,"discussions":[{"author":{"id":1793879,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5f/57/791d0f5e.jpg","nickname":"Geek_8ed998","note":"","ucode":"1C164836354665","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":614675,"discussion_content":"这个作者解释问题没有toni bai说的直白，这个就是M的指针类型实现了Add方法，但M类型并没有实现Add方法，所以赋值给adder接口的时候是不行的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1681867839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595652,"discussion_content":"“接口中存储的是值”指的是接口中存储的已经并不是原始数据的引用了，如下代码会报错\ntype adder interface {\n\tAdd()\n}\ntype M struct{}\n\nfunc (m *M) Add() {\n\n}\nfunc main() {\n\tvar m adder = M{}\n\tm.Add()\n}\n# command-line-arguments\n./1_print.go:21:6: cannot use M{} (type M) as type adder in assignment:\n        M does not implement adder (Add method has pointer receiver)\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1670264953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3200112,"avatar":"https://static001.geekbang.org/account/avatar/00/30/d4/70/e3e770a7.jpg","nickname":"空语","note":"","ucode":"EEA342A5A3F5E1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":601527,"discussion_content":"感觉可以加上正确的写法作为对比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675258053,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":595652,"ip_address":"江苏","group_id":0},"score":601527,"extra":""}]},{"author":{"id":2829568,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/icpJJI5qPlVwaZoOk6zKicZVTibMV6ia4WKpea7DKfc4TUnx01k9nd9ibgpniajEjQ5K3ZsTHjIpUPwgumd13y5IQVOA/132","nickname":"Geek_b2c23b","note":"","ucode":"0B7EEB4DCF2CD3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602454,"discussion_content":"这里var m adder =&amp;M{} 不是理所当然的吗？虽然本质都是拷贝的值，但一个是变量值，一个是地址，想要修改原始变量值，必然需要传入地址。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675756864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363378,"user_name":"shuff1e","can_delete":false,"product_type":"c1","uid":1756280,"ip_address":"北京","ucode":"85601271951B5A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep075ibtmxMf3eOYlBJ96CE9TEelLUwePaLqp8M75gWHEcM3za0voylA0oe9y3NiaboPB891rypRt7w/132","comment_is_top":false,"comment_ctime":1669609563,"is_pvip":false,"replies":[{"id":132245,"content":"try my best~","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1670265032,"ip_address":"北京","comment_id":363378,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"老哥，更新速度能不能快些？","like_count":1,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595654,"discussion_content":"try my best~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670265032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364623,"user_name":"叶绘落","can_delete":false,"product_type":"c1","uid":1652234,"ip_address":"广东","ucode":"81A249CC67B9A9","user_header":"https://static001.geekbang.org/account/avatar/00/19/36/0a/a14b6af4.jpg","comment_is_top":false,"comment_ctime":1671202108,"is_pvip":false,"replies":[{"id":134142,"content":"这里是解释chromedp库默认查找当前系统指定路径下指定的谷歌应用程序，这个函数findExecPath就是实现该功能的","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1676216804,"ip_address":"北京","comment_id":364623,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"\n文中有一段代码\n\nfunc findExecPath() string\n...\n\n看起来与文章内容毫无关联，不知道为何贴上来。\n","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603467,"discussion_content":"这里是解释chromedp库默认查找当前系统指定路径下指定的谷歌应用程序，这个函数findExecPath就是实现该功能的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676216804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172050,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/52/56dbb738.jpg","nickname":"牙小木","note":"","ucode":"E5C12D37A62949","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625838,"discussion_content":"的确东一榔头西一棒子，不知道为啥要贴这个，而不贴其他的。\n可以在代码里加入 \nctxChrome,cancel:=chromedp.NewExecAllocator(ctxBG)，这个NewExecAllocator里已经包括了findExecPath","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692250091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363732,"user_name":"吹口哨yu","can_delete":false,"product_type":"c1","uid":1608364,"ip_address":"北京","ucode":"271BE88C4124FE","user_header":"https://static001.geekbang.org/account/avatar/00/18/8a/ac/a44b4b3f.jpg","comment_is_top":false,"comment_ctime":1670075153,"is_pvip":false,"replies":[{"id":132240,"content":"结构体比较简单的时候就还无所谓，比较复杂的结构体是建议用指针的","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1670264069,"ip_address":"北京","comment_id":363732,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"为啥 BaseFetch 的 Get 写成  func (BaseFetch) Get(...)，\n而不写成 func (b *BaseFetch) Get(...) ?\n","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595649,"discussion_content":"结构体比较简单的时候就还无所谓，比较复杂的结构体是建议用指针的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670264069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363388,"user_name":"Calabash","can_delete":false,"product_type":"c1","uid":1139055,"ip_address":"北京","ucode":"810CAD6DB3608C","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/6f/eba9a7bd.jpg","comment_is_top":false,"comment_ctime":1669618675,"is_pvip":false,"replies":[{"id":132247,"content":"https:&#47;&#47;github.com&#47;dreamerjackson&#47;crawler,注意看文中指明的tag分支","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1670265113,"ip_address":"北京","comment_id":363388,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"代码在哪里","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595656,"discussion_content":"https://github.com/dreamerjackson/crawler,注意看文中指明的tag分支","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670265113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363344,"user_name":"哈哈哈哈哈","can_delete":false,"product_type":"c1","uid":2828322,"ip_address":"北京","ucode":"0350A8A8A3DD74","user_header":"https://static001.geekbang.org/account/avatar/00/2b/28/22/ebc770dc.jpg","comment_is_top":false,"comment_ctime":1669555799,"is_pvip":false,"replies":[{"id":132246,"content":"https:&#47;&#47;github.com&#47;dreamerjackson&#47;crawler,注意看文中指明的tag分支","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1670265108,"ip_address":"北京","comment_id":363344,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"utf8Reader := transform.NewReader(bodyReader, e.NewDecoder())，”transform.NewReader“这是从哪冒出来的。本人刚学，原文中不方便贴出全部代码，麻烦贴个链接我慢慢看。","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595655,"discussion_content":"https://github.com/dreamerjackson/crawler,注意看文中指明的tag分支","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670265108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127799,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/77/95e95b32.jpg","nickname":"木杉","note":"","ucode":"85651CBDDF7EDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595148,"discussion_content":"golang.org/x/text/transform","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669785862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2828322,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/28/22/ebc770dc.jpg","nickname":"哈哈哈哈哈","note":"","ucode":"0350A8A8A3DD74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1127799,"avatar":"https://static001.geekbang.org/account/avatar/00/11/35/77/95e95b32.jpg","nickname":"木杉","note":"","ucode":"85651CBDDF7EDC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595199,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669816358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":595148,"ip_address":"陕西","group_id":0},"score":595199,"extra":""}]}]},{"had_liked":false,"id":363306,"user_name":"范飞扬","can_delete":false,"product_type":"c1","uid":2721761,"ip_address":"北京","ucode":"A665DF46833A81","user_header":"https://static001.geekbang.org/account/avatar/00/29/87/e1/b3edcc09.jpg","comment_is_top":false,"comment_ctime":1669515685,"is_pvip":false,"replies":[{"id":132259,"content":"可以直接看最新的main分支","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1670266379,"ip_address":"北京","comment_id":363306,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"tag是多少？","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595668,"discussion_content":"可以直接看最新的main分支","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670266379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363290,"user_name":"奕","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"北京","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1669467026,"is_pvip":false,"replies":[{"id":132252,"content":"在容器里面集成无头的谷歌浏览器就好了，是很小的","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1670265336,"ip_address":"北京","comment_id":363290,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"使用 chromedp 必须要单独安装 Chrome 浏览器吗？内部能不能直接集成？在服务器上是不能直接安装的","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595661,"discussion_content":"在容器里面集成无头的谷歌浏览器就好了，是很小的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670265336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109522,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/12/77ddaeb8.jpg","nickname":"Yabo","note":"","ucode":"D193B6AB9686D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594887,"discussion_content":"不用吧，之前用过 chromedp ，直接在 dockerfile 里安装 chromium 就可以用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669528881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363360,"user_name":"徐海浪","can_delete":false,"product_type":"c1","uid":1078528,"ip_address":"广东","ucode":"21801C420D0610","user_header":"https://static001.geekbang.org/account/avatar/00/10/75/00/618b20da.jpg","comment_is_top":false,"comment_ctime":1669594488,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"如果一个网站需要登录才可以访问，我们应该如何实现自动登录的能力？\n1、通常都有验证码，先获取验证码图片，然后识别为文字，然后带用户名密码及验证码请求登录接口。\n2、有的是滑块，可以使用webdriver调用浏览器来完成; 其他生物识别的，可以用弹出浏览器然后人工登录后继续。\n登录成功后保存cookie给后续的浏览器使用。","like_count":4},{"had_liked":false,"id":363395,"user_name":"0mfg","can_delete":false,"product_type":"c1","uid":1393948,"ip_address":"北京","ucode":"D83530DB25D25A","user_header":"","comment_is_top":false,"comment_ctime":1669625814,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"敲一遍跑一遍基本学会反射了，createQuery进本人调试可正常运行版本\n\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;reflect&quot;\n)\n\ntype Student struct {\n\tName string\n\tAge  int\n}\n\ntype Trade struct {\n\ttradeId int\n\tPrice   int\n}\n\nfunc createQuery(q interface{}) string {\n\tvar query string\n\tif reflect.TypeOf(q).Kind() == reflect.Struct { &#47;&#47;如果q是结构体\n\t\tt := reflect.TypeOf(q).Name()\n\t\tquery = fmt.Sprintf(&quot;insert into %s values(&quot;, t) &#47;&#47;拼接出insert into student values(\n\t\tv := reflect.ValueOf(q)\n\n\t\tfor i := 0; i &lt; v.NumField(); i++ {\n\t\t\tswitch v.Field(i).Kind() {\n\t\t\tcase reflect.Int:\n\t\t\t\tif i == 0 {\n\t\t\t\t\tquery = fmt.Sprintf(&quot;%s%d&quot;, query, v.Field(i).Int()) &#47;&#47;拼接出insert into student values(20\n\t\t\t\t} else {\n\t\t\t\t\tquery = fmt.Sprintf(&quot;%s, %d&quot;, query, v.Field(i).Int()) &#47;&#47;拼接出insert into student values(jonson, 20)\n\t\t\t\t}\n\t\t\tcase reflect.String:\n\t\t\t\tif i == 0 {\n\t\t\t\t\tquery = fmt.Sprintf(&quot;%s%s&quot;, query, v.Field(i).String()) &#47;&#47;拼接出insert into student values(jonson\n\t\t\t\t} else {\n\t\t\t\t\tquery = fmt.Sprintf(&quot;%s, %s&quot;, query, v.Field(i).String()) &#47;&#47;拼接出insert into student values(20, jonson\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tquery = fmt.Sprintf(&quot;%s)&quot;, query)\n\t\tfmt.Println(query)\n\t}\n\treturn query\n}\n\nfunc main() {\n\tcreateQuery(Student{Name: &quot;jonson&quot;, Age: 20})\n\tcreateQuery(Trade{tradeId: 123, Price: 456})\n}\n","like_count":2},{"had_liked":false,"id":391053,"user_name":"斯蒂芬.赵","can_delete":false,"product_type":"c1","uid":1200179,"ip_address":"山东","ucode":"AA0FF2DA654418","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/33/9dcd30c4.jpg","comment_is_top":false,"comment_ctime":1717147602,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"使用chromedp模拟浏览器行为，是不是很耗cpu，假设有10个链接，通过携程并发去爬，cpu一下就打满了，这种咋解决\n","like_count":1},{"had_liked":false,"id":375102,"user_name":"Beng吓咔啦咔","can_delete":false,"product_type":"c1","uid":2981277,"ip_address":"重庆","ucode":"9B1942EFFCB126","user_header":"https://static001.geekbang.org/account/avatar/00/2d/7d/9d/ced762c5.jpg","comment_is_top":false,"comment_ctime":1684915867,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"文中哪有注明tag分支，找了几遍没有看到","like_count":1},{"had_liked":false,"id":364813,"user_name":"Geek_c16d38","can_delete":false,"product_type":"c1","uid":2726606,"ip_address":"中国台湾","ucode":"A8B1EB366FCD98","user_header":"","comment_is_top":false,"comment_ctime":1671531048,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"這一節有代碼嗎？在那一個分支？","like_count":1},{"had_liked":false,"id":391135,"user_name":"Geek_992417","can_delete":false,"product_type":"c1","uid":3864787,"ip_address":"贵州","ucode":"07965ED72DB186","user_header":"","comment_is_top":false,"comment_ctime":1717404954,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"chromedp对比playwright如何呢，还有哪些类似的好用的库呢","like_count":0},{"had_liked":false,"id":379649,"user_name":"牙小木","can_delete":false,"product_type":"c1","uid":1172050,"ip_address":"北京","ucode":"E5C12D37A62949","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/52/56dbb738.jpg","comment_is_top":false,"comment_ctime":1692248229,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"关于sql反射的，已经自测成功\n```\npackage main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;log&quot;\n\t&quot;reflect&quot;\n)\n\ntype SQL interface{\n\tCreateSQL(o interface{}) string\n}\n\ntype dynamicCreate struct {\n\n}\n\ntype Student struct {\n\tname string\n\tage int\n\taddress string\n}\ntype Trade struct {\n\ttradeId int\n\tprice int\n\taddress string\n}\nfunc main() {\n\n\ts1:=Student{\n\t\tname: &quot;zhangsan&quot;,\n\t\tage:  3,\n\t\taddress:&quot;上海&quot;,\n\t}\n\tt1:=Trade{\n\t\ttradeId: 8712411,\n\t\tprice: 998,\n\t\taddress:&quot;北京&quot;,\n\t}\n\n\tdc:=&amp;dynamicCreate{}\n\tsql:=SQL(dc)\n\ts1Sql:=sql.CreateSQL(s1)\n\tt1Sql:=sql.CreateSQL(t1)\n\tfmt.Println(s1Sql)\n\tfmt.Println(t1Sql)\n}\n\nfunc (dynamicCreate )CreateSQL(o interface{}) string {\n\tvar query string\n\t&#47;&#47;如果obj 为struct\n\tif reflect.ValueOf(o).Kind()==reflect.Struct{\n\t\t&#47;&#47;获取结构体的名字\n\t\toName:= reflect.TypeOf(o).Name()\n\t\t&#47;&#47;拼接sql语句\n\t\tquery:=fmt.Sprintf(&quot;INSERT INTO %s values(&quot;,oName)\n\t\tv:=reflect.ValueOf(o)\n\t\tfor i:=0;i&lt;v.NumField();i++{\n\t\t\t&#47;&#47;判断结构体字段的类型\n\t\t\tswitch v.Field(i).Kind() {\n\t\t\tcase reflect.Int:\n\t\t\t\tif i==0{\n\t\t\t\t\t&#47;&#47;这里有个对之前query string的嵌入\n\t\t\t\t\tquery=fmt.Sprintf(&quot;%s%d&quot;,query,v.Field(i).Int())\n\t\t\t\t}else{\n\t\t\t\t\tquery = fmt.Sprintf(&quot;%s, %d&quot;, query, v.Field(i).Int())\n\t\t\t\t}\n\t\t\tcase reflect.String:\n\t\t\t\tif i==0{\n\t\t\t\t\tquery=fmt.Sprintf(&quot;%s %q&quot;, query, v.Field(i).String())\n\t\t\t\t}else{\n\t\t\t\t\tquery = fmt.Sprintf(&quot;%s, %q&quot;, query, v.Field(i).String())\n\t\t\t\t}\n\t\t\t}\n\t\t\t&#47;&#47;...\n\t\t}\n\t\tquery=fmt.Sprintf(&quot;%s)&quot;,query)\n\t\treturn query\n\t}\n\tlog.Fatalf(&quot;o kind is %v\\n&quot;,reflect.ValueOf(o).Kind())\n\treturn query\n}\n\n\n```","like_count":0},{"had_liked":false,"id":379639,"user_name":"牙小木","can_delete":false,"product_type":"c1","uid":1172050,"ip_address":"北京","ucode":"E5C12D37A62949","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/52/56dbb738.jpg","comment_is_top":false,"comment_ctime":1692242401,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"这里是抓取go.dev网站中click内容的代码\n```\npackage main\n\nimport (\n\t&quot;context&quot;\n\t&quot;github.com&#47;chromedp&#47;chromedp&quot;\n\t&quot;log&quot;\n\t&quot;time&quot;\n)\n&#47;&#47;模拟chrome的相关事件\n&#47;&#47;https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;607435?screen=full\nfunc main() {\n\n\t&#47;&#47;创建实例\n\tctxBG:=context.Background()\n\tctxChrome,cancel:=chromedp.NewExecAllocator(ctxBG)\n\n\t&#47;&#47;设置超时时间，如果这里传入的是ctxChrome，那么系统会有一个打开 浏览器的窗口页面\n\tctx,cancel:=chromedp.NewContext(ctxBG)\n\tdefer cancel()\n\tctxChrome,cancel=context.WithTimeout(ctx, 10*time.Second)\n\tvar example string\n\terr:=chromedp.Run(ctxChrome,\n\t\tchromedp.Navigate(`https:&#47;&#47;pkg.go.dev&#47;time`),\n\t\tchromedp.WaitVisible(`body &gt; footer`),&#47;&#47;类似于 window.onload，及页面加载完成之后\n\t\tchromedp.Click(`#example-After`, chromedp.NodeVisible),&#47;&#47;模拟此元素点击事件\n\t\tchromedp.Value(`#example-After textarea`, &amp;example),&#47;&#47;获取指定的元素内容\n\t)\n\tif err!=nil{\n\t\tlog.Fatal(err)\n\t}\n\tlog.Printf(&quot;Go&#39;s time.After example:\\\\n%s&quot;, example)\n}\n\n\n```","like_count":0},{"had_liked":false,"id":379635,"user_name":"牙小木","can_delete":false,"product_type":"c1","uid":1172050,"ip_address":"北京","ucode":"E5C12D37A62949","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/52/56dbb738.jpg","comment_is_top":false,"comment_ctime":1692239981,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"提个建议：\n如果贴代码，那就保证上下文代码的完整性、连贯性，\n如果本节代码已经打了tag，那就文尾告知下tag的地址","like_count":0},{"had_liked":false,"id":373338,"user_name":"爱编程的运维","can_delete":false,"product_type":"c1","uid":2535502,"ip_address":"广东","ucode":"696DBA399CCFA3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/4faqHgQSawd4VzAtSv0IWDddm9NucYWibRpxejWPH5RUO310qv8pAFmc0rh0Qu6QiahlTutGZpia8VaqP2w6icybiag/132","comment_is_top":false,"comment_ctime":1682407741,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"老师您好，我最近在搞一个拨测项目，需要对网站做性能检测，类似腾讯云拨测这种\n用户会输入一个网站地址，例如：www.baidu.com\n我要如何请求这个地址，然后可以获取这个地址异步加载的所有请求、请求方法、http状态码、耗时等这些数据？\n类似浏览器打开开发者模式的控制台看到的数据一样？","like_count":0},{"had_liked":false,"id":363300,"user_name":"无笔秀才","can_delete":false,"product_type":"c1","uid":1123152,"ip_address":"北京","ucode":"DCFA10866A8E5B","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/50/1f5154fe.jpg","comment_is_top":false,"comment_ctime":1669502711,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"需要登录 就带上cookie 啊","like_count":0}]}