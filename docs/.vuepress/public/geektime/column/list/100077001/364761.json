{"id":364761,"title":"01｜Spring Bean 定义常见错误","content":"<p>你好，我是傅健。</p><p>从导读中我们已知，Spring 的核心是围绕 Bean 进行的。不管是 Spring Boot 还是 Spring Cloud，只要名称中带有Spring关键字的技术都脱离不了 Bean，而要使用一个 Bean 少不了要先定义出来，所以<strong>定义一个Bean 就变得格外重要了</strong>。</p><p>当然，对于这么重要的工作，Spring 自然给我们提供了很多简单易用的方式。然而，这种简单易用得益于 Spring 的“<strong>约定大于配置</strong>”，但我们往往不见得会对所有的约定都了然于胸，所以仍然会在 Bean 的定义上犯一些经典的错误。</p><p>接下来我们就来了解下那些经典错误以及它们背后的原理，你也可以对照着去看看自己是否也曾犯过，后来又是如何解决的。</p><h2>案例 1：隐式扫描不到 Bean 的定义</h2><p>在构建 Web 服务时，我们常使用 Spring Boot 来快速构建。例如，使用下面的包结构和相关代码来完成一个简易的 Web 版 HelloWorld：</p><p><img src=\"https://static001.geekbang.org/resource/image/63/48/63f7d08fb89653e12b9946c4dca31c48.png?wh=375*93\" alt=\"\"></p><p>其中，负责启动程序的 Application 类定义如下：</p><pre><code>package com.spring.puzzle.class1.example1.application\n//省略 import\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre><p>提供接口的 HelloWorldController 代码如下：</p><pre><code>package com.spring.puzzle.class1.example1.application\n//省略 import\n@RestController\npublic class HelloWorldController {\n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi(){\n         return &quot;helloworld&quot;;\n    };\n}\n</code></pre><p>上述代码即可实现一个简单的功能：访问<a href=\"http://localhost:8080/hi\">http://localhost:8080/hi</a> 返回helloworld。两个关键类位于同一个包（即 application）中。其中 HelloWorldController 因为添加了@RestController，最终被识别成一个 Controller 的 Bean。</p><!-- [[[read_end]]] --><p>但是，假设有一天，当我们需要添加多个类似的 Controller，同时又希望用更清晰的包层次和结构来管理时，我们可能会去单独建立一个独立于 application 包之外的 Controller 包，并调整类的位置。调整后结构示意如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/f6/30/f6080f4e2b10e7f54e79040b8362c230.png?wh=405*115\" alt=\"\"></p><p>实际上，我们没有改变任何代码，只是改变了包的结构，但是我们会发现这个 Web 应用失效了，即不能识别出 HelloWorldController 了。也就是说，我们找不到 HelloWorldController 这个 Bean 了。这是为何？</p><h3>案例解析</h3><p>要了解 HelloWorldController 为什么会失效，就需要先了解之前是如何生效的。对于 Spring Boot 而言，关键点在于 Application.java 中使用了 SpringBootApplication 注解。而这个注解继承了另外一些注解，具体定义如下：</p><pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n//省略非关键代码\n}\n</code></pre><p>从定义可以看出，SpringBootApplication开启了很多功能，其中一个关键功能就是 ComponentScan，参考其配置如下：</p><blockquote>\n<p>@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class)</p>\n</blockquote><p>当 Spring Boot 启动时，ComponentScan 的启用意味着会去扫描出所有定义的 Bean，那么扫描什么位置呢？这是由 ComponentScan 注解的 basePackages 属性指定的，具体可参考如下定义：</p><pre><code>public @interface ComponentScan {\n\n/**\n * Base packages to scan for annotated components.\n * &lt;p&gt;{@link #value} is an alias for (and mutually exclusive with) this\n * attribute.\n * &lt;p&gt;Use {@link #basePackageClasses} for a type-safe alternative to\n * String-based package names.\n */\n@AliasFor(&quot;value&quot;)\nString[] basePackages() default {};\n//省略其他非关键代码\n}\n</code></pre><p>而在我们的案例中，我们直接使用的是 SpringBootApplication 注解定义的 ComponentScan，它的 basePackages 没有指定，所以默认为空（即{}）。此时扫描的是什么包？这里不妨带着这个问题去调试下（调试位置参考 ComponentScanAnnotationParser#parse 方法），调试视图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/75/c6/75a8abe6d5854f4f4a8d6c9a5655f3c6.png?wh=1153*476\" alt=\"\"></p><p>从上图可以看出，当 basePackages 为空时，扫描的包会是 declaringClass 所在的包，在本案例中，declaringClass 就是 Application.class，所以扫描的包其实就是它所在的包，即com.spring.puzzle.class1.example1.application。</p><p>对比我们重组包结构前后，我们自然就找到了这个问题的根源：在调整前，HelloWorldController 在扫描范围内，而调整后，它已经远离了扫描范围（不和 Application.java 一个包了），虽然代码没有一丝丝改变，但是这个功能已经失效了。</p><p>所以，综合来看，这个问题是因为我们不够了解 Spring Boot 的默认扫描规则引起的。我们仅仅享受了它的便捷，但是并未了解它背后的故事，所以稍作变化，就可能玩不转了。</p><h3>问题修正</h3><p>针对这个案例，有了源码的剖析，我们可以快速找到解决方案了。当然了，我们所谓的解决方案肯定不是说把 HelloWorldController 移动回原来的位置，而是<strong>真正去满足需求</strong>。在这里，真正解决问题的方式是显式配置@ComponentScan。具体修改方式如下：</p><pre><code>@SpringBootApplication\n@ComponentScan(&quot;com.spring.puzzle.class1.example1.controller&quot;)\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n</code></pre><p>通过上述修改，我们显式指定了扫描的范围为com.spring.puzzle.class1.example1.controller。不过需要注意的是，显式指定后，默认的扫描范围（即com.spring.puzzle.class1.example1.application）就不会被添加进去了。另外，我们也可以使用@ComponentScans 来修复问题，使用方式如下：</p><blockquote>\n<p>@ComponentScans(value = { @ComponentScan(value = \"com.spring.puzzle.class1.example1.controller\") })</p>\n</blockquote><p>顾名思义，可以看出 ComponentScans 相比较 ComponentScan 多了一个s，支持多个包的扫描范围指定。</p><p>此时，细心的你可能会发现：如果对源码缺乏了解，很容易会顾此失彼。以 ComponentScan 为例，原有的代码扫描了默认包而忽略了其它包；而<strong>一旦显式指定其它包，原来的默认扫描包就被忽略了。</strong></p><h2>案例 2：定义的 Bean 缺少隐式依赖</h2><p>初学 Spring 时，我们往往不能快速转化思维。例如，在程序开发过程中，有时候，一方面我们把一个类定义成 Bean，同时又觉得这个 Bean 的定义除了加了一些 Spring 注解外，并没有什么不同。所以在后续使用时，有时候我们会不假思索地去随意定义它，例如我们会写出下面这样的代码：</p><pre><code>@Service\npublic class ServiceImpl {\n\n    private String serviceName;\n\n    public ServiceImpl(String serviceName){\n        this.serviceName = serviceName;\n    }\n\n}\n</code></pre><p>ServiceImpl 因为标记为@Service而成为一个 Bean。另外我们ServiceImpl 显式定义了一个构造器。但是，上面的代码不是永远都能正确运行的，有时候会报下面这种错误：</p><blockquote>\n<p>Parameter 0 of constructor in com.spring.puzzle.class1.example2.ServiceImpl required a bean of type 'java.lang.String' that could not be found.</p>\n</blockquote><p>那这种错误是怎么发生的呢？下面我们来分析一下。</p><h3>案例解析</h3><p>当创建一个 Bean 时，调用的方法是 AbstractAutowireCapableBeanFactory#createBeanInstance。它主要包含两大基本步骤：寻找构造器和通过反射调用构造器创建实例。对于这个案例，最核心的代码执行，你可以参考下面的代码片段：</p><pre><code>// Candidate constructors for autowiring?\nConstructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);\nif (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||\n      mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {\n   return autowireConstructor(beanName, mbd, ctors, args);\n}\n</code></pre><p>Spring 会先执行 determineConstructorsFromBeanPostProcessors 方法来获取构造器，然后通过 autowireConstructor 方法带着构造器去创建实例。很明显，在本案例中只有一个构造器，所以非常容易跟踪这个问题。</p><p>autowireConstructor 方法要创建实例，不仅需要知道是哪个构造器，还需要知道构造器对应的参数，这点从最后创建实例的方法名也可以看出，参考如下（即 ConstructorResolver#instantiate）：</p><pre><code>private Object instantiate(\n      String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt; constructorToUse, Object[] argsToUse) \n</code></pre><p>那么上述方法中存储构造参数的 argsToUse 如何获取呢？换言之，当我们已经知道构造器ServiceImpl(String serviceName)，要创建出 ServiceImpl 实例，如何确定 serviceName 的值是多少？</p><p>很明显，这里是在使用 Spring，我们<strong>不能直接显式使用 new 关键字来创建实例</strong>。Spring只能是去寻找依赖来作为构造器调用参数。</p><p>那么这个参数如何获取呢？可以参考下面的代码片段（即 ConstructorResolver#autowireConstructor）：</p><pre><code>argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,\n      getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);\n</code></pre><p>我们可以调用 createArgumentArray 方法来构建调用构造器的参数数组，而这个方法的最终实现是从 BeanFactory 中获取 Bean，可以参考下述调用：</p><pre><code>return this.beanFactory.resolveDependency(\n      new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);\n</code></pre><p>如果用调试视图，我们则可以看到更多的信息：</p><p><img src=\"https://static001.geekbang.org/resource/image/51/a3/5113cfc71ec8dab37e254c5c5e9abba3.png?wh=1356*494\" alt=\"\"></p><p>如图所示，上述的调用即是根据参数来寻找对应的 Bean，在本案例中，如果找不到对应的 Bean 就会抛出异常，提示装配失败。</p><h3>问题修正</h3><p>从源码级别了解了错误的原因后，现在反思为什么会出现这个错误。追根溯源，正如开头所述，因为不了解很多隐式的规则：我们定义一个类为 Bean，如果再显式定义了构造器，那么这个 Bean 在构建时，会自动根据构造器参数定义寻找对应的 Bean，然后反射创建出这个 Bean。</p><p>了解了这个隐式规则后，解决这个问题就简单多了。我们可以直接定义一个能让 Spring 装配给 ServiceImpl 构造器参数的 Bean，例如定义如下：</p><pre><code>//这个bean装配给ServiceImpl的构造器参数“serviceName”\n@Bean\npublic String serviceName(){\n    return &quot;MyServiceName&quot;;\n}\n</code></pre><p>再次运行程序，发现一切正常了。</p><p>所以，我们在使用 Spring 时，<strong>不要总想着定义的Bean 也可以在非 Spring 场合直接用 new 关键字显式使用，这种思路是不可取的</strong>。</p><p>另外，类似的，假设我们不了解 Spring 的隐式规则，在修正问题后，我们可能写出更多看似可以运行的程序，代码如下：</p><pre><code>@Service\npublic class ServiceImpl {\n    private String serviceName;\n    public ServiceImpl(String serviceName){\n        this.serviceName = serviceName;\n    }\n    public ServiceImpl(String serviceName, String otherStringParameter){\n        this.serviceName = serviceName;\n    }\n}\n</code></pre><p>如果我们仍用非 Spring 的思维去审阅这段代码，可能不会觉得有什么问题，毕竟 String 类型可以自动装配了，无非就是增加了一个 String 类型的参数而已。</p><p>但是如果你了解 Spring 内部是用反射来构建 Bean 的话，就不难发现问题所在：存在两个构造器，都可以调用时，到底应该调用哪个呢？最终 Spring 无从选择，只能尝试去调用默认构造器，而这个默认构造器又不存在，所以测试这个程序它会出错。</p><h2>案例 3：原型 Bean 被固定</h2><p>接下来，我们再来看另外一个关于 Bean 定义不生效的案例。在定义 Bean 时，有时候我们会使用原型 Bean，例如定义如下：</p><pre><code>@Service\n@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\npublic class ServiceImpl {\n}\n</code></pre><p>然后我们按照下面的方式去使用它：</p><pre><code>@RestController\npublic class HelloWorldController {\n\n    @Autowired\n    private ServiceImpl serviceImpl;\n\n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi(){\n         return &quot;helloworld, service is : &quot; + serviceImpl;\n    };\n}\n</code></pre><p>结果，我们会发现，不管我们访问多少次<a href=\"http://localhost:8080/hi\">http://localhost:8080/hi</a>，访问的结果都是不变的，如下：</p><blockquote>\n<p>helloworld, service is : com.spring.puzzle.class1.example3.error.ServiceImpl@4908af</p>\n</blockquote><p>很明显，这很可能和我们定义 ServiceImpl 为原型 Bean 的初衷背道而驰，如何理解这个现象呢？</p><h3>案例解析</h3><p>当一个属性成员 serviceImpl 声明为@Autowired 后，那么在创建 HelloWorldController 这个 Bean 时，会先使用构造器反射出实例，然后来装配各个标记为@Autowired 的属性成员（装配方法参考 AbstractAutowireCapableBeanFactory#populateBean）。</p><p>具体到执行过程，它会使用很多 BeanPostProcessor 来做完成工作，其中一种是 AutowiredAnnotationBeanPostProcessor，它会通过 DefaultListableBeanFactory#findAutowireCandidates 寻找到 ServiceImpl 类型的 Bean，然后设置给对应的属性（即 serviceImpl成员）。</p><p>关键执行步骤可参考 AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject：</p><pre><code>protected void inject(Object bean, @Nullable String beanName, @Nullable PropertyValues pvs) throws Throwable {\n   Field field = (Field) this.member;\n   Object value;\n   //寻找“bean”\n   if (this.cached) {\n      value = resolvedCachedArgument(beanName, this.cachedFieldValue);\n   }\n   else {\n     //省略其他非关键代码\n     value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);\n   }\n   if (value != null) {\n      //将bean设置给成员字段\n      ReflectionUtils.makeAccessible(field);\n      field.set(bean, value);\n   }\n}\n</code></pre><p>待我们寻找到要自动注入的 Bean 后，即可通过反射设置给对应的field。这个field的执行只发生了一次，所以后续就固定起来了，它并不会因为 ServiceImpl 标记了 SCOPE_PROTOTYPE 而改变。</p><p>所以，<strong>当一个单例的Bean，使用 autowired 注解标记其属性时，你一定要注意这个属性值会被固定下来。</strong></p><h3>问题修正</h3><p>通过上述源码分析，我们可以知道要修正这个问题，肯定是不能将 ServiceImpl 的 Bean 固定到属性上的，而应该是每次使用时都会重新获取一次。所以这里我提供了两种修正方式：</p><p><strong>1. 自动注入 Context</strong></p><p>即自动注入 ApplicationContext，然后定义 getServiceImpl() 方法，在方法中获取一个新的 ServiceImpl 类型实例。修正代码如下：</p><pre><code>@RestController\npublic class HelloWorldController {\n\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi(){\n         return &quot;helloworld, service is : &quot; + getServiceImpl();\n    };\n \n    public ServiceImpl getServiceImpl(){\n        return applicationContext.getBean(ServiceImpl.class);\n    }\n\n}\n</code></pre><p><strong>2. 使用 Lookup 注解</strong></p><p>类似修正方法 1，也添加一个 getServiceImpl 方法，不过这个方法是被 Lookup 标记的。修正代码如下：</p><pre><code>@RestController\npublic class HelloWorldController {\n \n    @RequestMapping(path = &quot;hi&quot;, method = RequestMethod.GET)\n    public String hi(){\n         return &quot;helloworld, service is : &quot; + getServiceImpl();\n    };\n\n    @Lookup\n    public ServiceImpl getServiceImpl(){\n        return null;\n    }  \n\n}\n</code></pre><p>通过这两种修正方式，再次测试程序，我们会发现结果已经符合预期（每次访问这个接口，都会创建新的 Bean）。</p><p>这里我们不妨再拓展下，讨论下 Lookup 是如何生效的。毕竟在修正代码中，我们看到getServiceImpl方法的实现返回值是 null，这或许很难说服自己。</p><p>首先，我们可以通过调试方式看下方法的执行，参考下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/3d/91/3d0e125b9d9e0711489d3a6aeff88c91.png?wh=1330*246\" alt=\"\"></p><p>从上图我们可以看出，我们最终的执行因为标记了 Lookup 而走入了 CglibSubclassingInstantiationStrategy.LookupOverrideMethodInterceptor，这个方法的关键实现参考 LookupOverrideMethodInterceptor#intercept：</p><pre><code>private final BeanFactory owner;\n\npublic Object intercept(Object obj, Method method, Object[] args, MethodProxy mp) throws Throwable {\n   LookupOverride lo = (LookupOverride) getBeanDefinition().getMethodOverrides().getOverride(method);\n   Assert.state(lo != null, &quot;LookupOverride not found&quot;);\n   Object[] argsToUse = (args.length &gt; 0 ? args : null);  // if no-arg, don't insist on args at all\n   if (StringUtils.hasText(lo.getBeanName())) {\n      return (argsToUse != null ? this.owner.getBean(lo.getBeanName(), argsToUse) :\n            this.owner.getBean(lo.getBeanName()));\n   }\n   else {\n      return (argsToUse != null ? this.owner.getBean(method.getReturnType(), argsToUse) :\n            this.owner.getBean(method.getReturnType()));\n   }\n}\n</code></pre><p>我们的方法调用最终并没有走入案例代码实现的return null语句，而是通过 BeanFactory 来获取 Bean。所以从这点也可以看出，其实<strong>在我们的 getServiceImpl 方法实现中，随便怎么写都行，这不太重要。</strong></p><p>例如，我们可以使用下面的实现来测试下这个结论：</p><pre><code>@Lookup\npublic ServiceImpl getServiceImpl(){\n    //下面的日志会输出么？\n    log.info(&quot;executing this method&quot;);\n    return null;\n}  \n</code></pre><p>以上代码，添加了一行代码输出日志。测试后，我们会发现并没有日志输出。这也验证了，当使用 Lookup 注解一个方法时，这个方法的具体实现已并不重要。</p><p>再回溯下前面的分析，为什么我们走入了CGLIB 搞出的类，这是因为我们有方法标记了 Lookup。我们可以从下面的这段代码得到验证，参考 SimpleInstantiationStrategy#instantiate：</p><pre><code>@Override\npublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {\n   // Don't override the class with CGLIB if no overrides.\n   if (!bd.hasMethodOverrides()) {\n      //\n      return BeanUtils.instantiateClass(constructorToUse);\n   }\n   else {\n      // Must generate CGLIB subclass.\n      return instantiateWithMethodInjection(bd, beanName, owner);\n   }\n}\n</code></pre><p>在上述代码中，当 hasMethodOverrides 为 true 时，则使用 CGLIB。而在本案例中，这个条件的成立在于解析HelloWorldController 这个 Bean 时，我们会发现有方法标记了 Lookup，此时就会添加相应方法到属性methodOverrides 里面去（此过程由 AutowiredAnnotationBeanPostProcessor#determineCandidateConstructors 完成）。</p><p>添加后效果图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/f0/bc917a82f62e8686a3c4eca64f89yyf0.png?wh=847*243\" alt=\"\"></p><p>以上即为 Lookup 的一些关键实现思路。还有很多细节，例如CGLIB子类如何产生，无法一一解释，有兴趣的话，可以进一步深入研究，留言区等你。</p><h2>重点回顾</h2><p>这节课我们介绍了3个关于Bean定义的经典错误，并分析了其背后原理。</p><p>不难发现，要使用好Spring，就<strong>一定要了解它的一些潜规则</strong>，例如默认扫描Bean的范围、自动装配构造器等等。如果我们不了解这些规则，大多情况下虽然也能工作，但是稍微变化，则可能完全失效，例如在案例1中，我们也只是把Controller从一个包移动到另外一个包，接口就失效了。</p><p>另外，通过这三个案例的分析，我们也能感受到<strong>Spring的很多实现是通过反射来完成的</strong>，了解了这点，对于理解它的源码实现会大有帮助。例如在案例2中，为什么定义了多个构造器就可能报错，因为使用反射方式来创建实例必须要明确使用的是哪一个构造器。</p><p>最后，我想说，在Spring框架中，解决问题的方式往往有多种，不要拘泥于套路。就像案例3，使用ApplicationContext和Lookup注解，都能解决原型 Bean 被固定的问题一样。</p><h2>思考题</h2><p>在案例 2 中，显示定义构造器，这会发生根据构造器参数寻找对应 Bean 的行为。这里请你思考一个问题，假设寻找不到对应的 Bean，一定会如案例 2 那样直接报错么？</p><p>尝试解决一下，我们留言区见！</p>","comments":[{"had_liked":false,"id":289339,"user_name":"许金亮","can_delete":false,"product_type":"c1","uid":1118348,"ip_address":"","ucode":"72CDEB5C7B2F2F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/8c/8e95e21e.jpg","comment_is_top":false,"comment_ctime":1618982570,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"186302576298","product_id":100077001,"comment_content":"案例 3：原型 Bean 被固定<br>service可以使用scope注解的proxyMode，设置成target_class，这样注入到controller的bean就是代理对象了，每次都会从beanfactory里面重新拿过<br>@Scope(value = &quot;prototype&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)","like_count":44,"discussions":[{"author":{"id":2793255,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/9f/27/4a98f281.jpg","nickname":"山楂糖","note":"","ucode":"D42144BE6D608B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561909,"discussion_content":"测试是可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649744110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306315,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ee/cb/4bd24e0f.jpg","nickname":"官人","note":"","ucode":"ECEF55B08E252B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382379,"discussion_content":"这种写法意义在于字节码原型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625550451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1540949,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq2piba1sNXUiavwyHmS0zHPp6XA4ohooO48Gvy9T9SEz61Pe4BJHX53xkYpYCqdCticNAZWiaZ7DFAzA/132","nickname":"kaneg","note":"","ucode":"F3333D5DDC5B61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371556,"discussion_content":"看上去这种方法更简洁，这种方法是官方推荐的方法吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619843739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1519547,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2f/bb/4236d712.jpg","nickname":"itschenxiang","note":"","ucode":"7D90194AC52435","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1540949,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq2piba1sNXUiavwyHmS0zHPp6XA4ohooO48Gvy9T9SEz61Pe4BJHX53xkYpYCqdCticNAZWiaZ7DFAzA/132","nickname":"kaneg","note":"","ucode":"F3333D5DDC5B61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391093,"discussion_content":"官方文档（Spring5）中使用的是@Lookup注解，作者提到的两种方法应该是推荐使用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630293516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":371556,"ip_address":""},"score":391093,"extra":""}]},{"author":{"id":1122971,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/9b/e948d5c3.jpg","nickname":"Nightwish","note":"","ucode":"29CC83987C6134","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370752,"discussion_content":"这样配置就能搞定，原理是啥？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619524869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291443,"user_name":"点点","can_delete":false,"product_type":"c1","uid":1208869,"ip_address":"","ucode":"8200B4F5BDDE47","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/25/2471fd9f.jpg","comment_is_top":false,"comment_ctime":1620289315,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"78929700643","product_id":100077001,"comment_content":"@Scope(value=ConfigurableBeanFactory.SCOPE_PROTOTYPE)这个是说在每次注入的时候回自动创建一个新的bean实例<br><br>@Scope(value=ConfigurableBeanFactory.SCOPE_SINGLETON)单例模式，在整个应用中只能创建一个实例<br><br>@Scope(value=WebApplicationContext.SCOPE_GLOBAL_SESSION)全局session中的一般不常用<br><br>@Scope(value=WebApplicationContext.SCOPE_APPLICATION)在一个web应用中只创建一个实例<br><br>@Scope(value=WebApplicationContext.SCOPE_REQUEST)在一个请求中创建一个实例<br><br>@Scope(value=WebApplicationContext.SCOPE_SESSION)每次创建一个会话中创建一个实例<br><br>里面还有个属性<br><br>proxyMode=ScopedProxyMode.INTERFACES创建一个JDK代理模式<br><br>proxyMode=ScopedProxyMode.TARGET_CLASS基于类的代理模式<br><br>proxyMode=ScopedProxyMode.NO（默认）不进行代理","like_count":18,"discussions":[{"author":{"id":1812807,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg","nickname":"御风","note":"","ucode":"51C8212BE06364","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379825,"discussion_content":"这里要注意的是singleton作用域和GOF设计模式中的单例是完全不同的，单例设计模式表示一个ClassLoader中 只有一个class存在，而这里的singleton则表示一个容器对应一个bean，也就是说当一个bean被标识为singleton时 候，spring的IOC容器中只会存在一个该bean。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624177061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297772,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1623768769,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48868409025","product_id":100077001,"comment_content":"亲测：<br>1、@ComponentScan可以多个同时使用，且都生效。效果等同于@ComponentScans<br>2、@ComponentScans不能与@ComponentScan一起使用","like_count":11,"discussions":[{"author":{"id":2112229,"avatar":"https://static001.geekbang.org/account/avatar/00/20/3a/e5/1a1b08ad.jpg","nickname":"乘风","note":"","ucode":"D25976CDD1D39B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589560,"discussion_content":"@ComponentScan 里面有一个注解是@Repeatable","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665125991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"重庆"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291741,"user_name":"Geek_ca230e","can_delete":false,"product_type":"c1","uid":2339517,"ip_address":"","ucode":"E57DAEFB34F0DC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PQxKfm8F19icfBichibEoTJvLCZtatEZyytCWrCKhia5zBgFNO57nYHUzpp51CPByic6VeEE8nCiaW8YUWxwr8do14Vw/132","comment_is_top":false,"comment_ctime":1620456177,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31685227249","product_id":100077001,"comment_content":"案例1 也可以用这样的方式显示指定扫描包：@SpringBootApplication(scanBasePackages = {&quot;com.xxx.xxxxx&quot;,&quot;com.xxx.xxx&quot;})","like_count":7,"discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539275,"discussion_content":"这是正确的方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639654361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289379,"user_name":"Sway","can_delete":false,"product_type":"c1","uid":1112020,"ip_address":"","ucode":"9D62965B31C849","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/d4/15a5c91f.jpg","comment_is_top":false,"comment_ctime":1618992410,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"23093828890","product_id":100077001,"comment_content":"想咨询一下，是怎么通过 ComponentScan 注解，找到 ComponentScanAnnotationParser 这个类的？在看其他的项目时，看到很多注解，但是想了解它具体做了什么工作，却无从下手。 （ 很可能项目并不能跑起来去 DEBUG ）","like_count":5,"discussions":[{"author":{"id":1254493,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","nickname":"听雨","note":"","ucode":"252754F9FCFF0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409290,"discussion_content":"写死的，在ConfigurationClassParser#doProcessConfigurationClass里使用过滤出标注了@ComponentScan注解的类，然后调用ComponentScanAnnotationParser#parse解析","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1635410152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667496,"avatar":"https://static001.geekbang.org/account/avatar/00/19/71/a8/3b5d9ced.jpg","nickname":"许德安","note":"","ucode":"0D12E7C6AF2701","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376931,"discussion_content":"`ComponentScanAnnotationParser`和`ComponentScan`在同一个包下，而且名字重合，自然就想到他们是相关的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1622430033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122971,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/9b/e948d5c3.jpg","nickname":"Nightwish","note":"","ucode":"29CC83987C6134","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370755,"discussion_content":"我也想知道怎么通过注解了解它的工作原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619524927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2350678,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/RjSuUnGcHiafDvunkGzygJB21PS3NicTDd5XMiat4RN3LqR2Cq51b0fgUWJ8FaHoiaaibwWYl6PF5gddDiaUOcelk4oQ/132","nickname":"Geek_92ec9e","note":"","ucode":"1B1ECE5E9D8E17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370222,"discussion_content":"反射吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619336085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289296,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1618971093,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18798840277","product_id":100077001,"comment_content":"问题：<br>1、关于用@ComponentScan修正那段代码，是不是少写了ComponentScan<br>2、JDK 1.8已经支持Repeatable注解，那是不是就不需要用@ComponentScans注解了，直接添加多个@ComponentScan注解就行<br>思考题：可以给构造器的参数添加@Autowired(required = false)就不会报错了","like_count":4,"discussions":[{"author":{"id":1213643,"avatar":"https://static001.geekbang.org/account/avatar/00/12/84/cb/f04d632a.jpg","nickname":"gaohw","note":"","ucode":"6C30D86909FDE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373738,"discussion_content":"我感觉这个是可行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620859719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346875,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1653484931,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14538386819","product_id":100077001,"comment_content":"今日收获<br>①  Spring默认扫描包是application类（@SpringBootApplication）所在的包，通过@ComponentScans或@ComponentScan直接可以指定需要扫码的包；<br><br><br>②  Bean的定义缺少隐式依赖；<br><br>@Service<br>public class ServiceImpl {<br>    <br>    private String serviceName；<br>    public ServiceImpl(String serviceName){<br>        this.serviceName = serviceName;<br>    }<br><br>}<br>      1）上述代码中的serviceName如果不是Spring容器的Bean创建ServiceIml  Bean时会报错，因为Spring创建Bean时会调用AbstractAutowireCapableBeanFactory#createBeanInstance，他主要是通过反射获取构造器，通过构造器创建Bean，此时获取到的构造器是一个携带参数的构造，为了获取此构造器的参数serviceName，会从Spring容器中去获取，获取不到则报错；<br>      2）需要Spring管理的类不能有多个构造函数，因为Spring在创建Bean时无法确定该调用那个构造函数，会报错；<br><br>③  原型Bean被固定；<br>      1）被@Autowired修饰的成员变量会在所属Bean被创建后，执行BeanPostProcessor给属性注入值，只注入一次，因为对于被@Autowired修饰的原型Bean，每次想获取到一个全新的Bean，是不能达到目的的；<br>       2）对于原型Bean每次想获取到一个全新的Bean可以从AppliactionContext获取，或者通过@LookUp注解获取，示例代码如下；<br>    @Lookup<br>    public ServiceImpl getServiceImpl(){<br>        return null;<br>    }  <br>被@LookUp注解修饰的方法本身实现不重要<br><br><br>","like_count":4},{"had_liked":false,"id":290302,"user_name":"jzhongchen","can_delete":false,"product_type":"c1","uid":1745949,"ip_address":"","ucode":"B78FD795DB752F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a4/1d/81e93f87.jpg","comment_is_top":false,"comment_ctime":1619492176,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14504394064","product_id":100077001,"comment_content":"案例 3：原型 Bean 被固定<br>设置scope为prototype的bean是每次调用的时候会产生一个新的bean，案例中由于controller没有设置scope，默认为singleton。每次请求的时候controller是同一个对象，当然service不会变。如果把controller的scope设置为prototype的话，就能够实现每次请求的时候service是一个新对象。<br>lookup注解以前没有听说过，还是第一次看到。","like_count":4,"discussions":[{"author":{"id":1122971,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/9b/e948d5c3.jpg","nickname":"Nightwish","note":"","ucode":"29CC83987C6134","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370756,"discussion_content":"这样做感觉有点削足适履的意思，controller原本单例就可以满足需要，没必要去改成原型","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1619525107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1745949,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/a4/1d/81e93f87.jpg","nickname":"jzhongchen","note":"","ucode":"B78FD795DB752F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1122971,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/9b/e948d5c3.jpg","nickname":"Nightwish","note":"","ucode":"29CC83987C6134","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370870,"discussion_content":"确实是，下来我也专门了解了一下lookup，这个注解就是专门解决这个问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619571841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":370756,"ip_address":""},"score":370870,"extra":""}]},{"author":{"id":2353023,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPK6DZqNE1YZmght5wicmXS9wrB2YSPdCgs8XZhvAHCCVInGt2CcF3t5owevHomzliamkrIRrLugnw/132","nickname":"郎思明","note":"","ucode":"16A6DA0FBEA0E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570701,"discussion_content":"案例3的意思应该是要controller是单例 但是service是多例","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651885113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289670,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1619138780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10209073372","product_id":100077001,"comment_content":"对于案例3: 最近项目中，我使用构造器模式，构造器scop指定的为prototype；通过autowired去注入构造器；我感觉我自己就踩坑了...在测试过程中由于没有多线程去使用构造器，数据看不出来，待会去增加一个日志看下，是否返回都是同一个对象。","like_count":2},{"had_liked":false,"id":346487,"user_name":"Oishi上好佳。","can_delete":false,"product_type":"c1","uid":2766742,"ip_address":"","ucode":"CAD2E247463E68","user_header":"https://static001.geekbang.org/account/avatar/00/2a/37/96/9f4f4658.jpg","comment_is_top":false,"comment_ctime":1653193847,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5948161143","product_id":100077001,"comment_content":"用的SpringBoot2.6.7版本，第二个案例，按照老师的写法，会报循环依赖，重新提供个类，专门用来注册这个 serviceName 即可。","like_count":1},{"had_liked":false,"id":341676,"user_name":"Geek_13168b","can_delete":false,"product_type":"c1","uid":2973196,"ip_address":"","ucode":"5D88422AEE0347","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGtG01ksyBtjxfvS0A93enaCumrnrgZILWnHkIg2x80CqoXcibLWSdVIDkplictKCNmJBZl8dONyibw/132","comment_is_top":false,"comment_ctime":1649765145,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5944732441","product_id":100077001,"comment_content":"新版本的spring，对于案例二已经不能运行了，在项目运行之前就会报错","like_count":1,"discussions":[{"author":{"id":2766742,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/37/96/9f4f4658.jpg","nickname":"Oishi上好佳。","note":"","ucode":"CAD2E247463E68","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573062,"discussion_content":"是不是要加上无参构造才可以正常运行？但是我试着加了无参构造之后，感觉只执行了无參的，不走有參的了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653189806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337138,"user_name":"安迪密恩","can_delete":false,"product_type":"c1","uid":1331611,"ip_address":"","ucode":"A6F3F67CF8E6F8","user_header":"https://static001.geekbang.org/account/avatar/00/14/51/9b/ccea47d9.jpg","comment_is_top":false,"comment_ctime":1646643018,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5941610314","product_id":100077001,"comment_content":"短短一篇专栏，补齐了5个知识点。太值了。","like_count":1},{"had_liked":false,"id":290190,"user_name":"哦吼掉了","can_delete":false,"product_type":"c1","uid":1232599,"ip_address":"","ucode":"1F89B1BA1EEF52","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/d7/8168e1bf.jpg","comment_is_top":false,"comment_ctime":1619424676,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5914391972","product_id":100077001,"comment_content":"@Service<br>public class TestService {<br>    private String serviceName;<br>    &#47;&#47; spring创建bean时,如果存在多个构造,会选无参构造。<br>    public TestService() {<br>    }<br><br>    public TestService(String serviceName) {<br>        this.serviceName = serviceName;<br>    }<br><br>    public String doSomething() {<br>        return serviceName;<br>    }<br>}","like_count":1},{"had_liked":false,"id":289916,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1619262721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5914230017","product_id":100077001,"comment_content":"不错解决了我之前的一个疑问","like_count":1},{"had_liked":false,"id":355339,"user_name":"云韵","can_delete":false,"product_type":"c1","uid":1025622,"ip_address":"浙江","ucode":"3DE26DBAAAEDE6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/56/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1661306418,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1661306418","product_id":100077001,"comment_content":"老师，你是根据这个@ComponentScan 注解的 basePackages() 就定位到 ComponentScanAnnotationParser#parse 这个方法的呢","like_count":0},{"had_liked":false,"id":352129,"user_name":"浮石沉木","can_delete":false,"product_type":"c1","uid":2223167,"ip_address":"","ucode":"D585768321B84A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mQddXC7nRiaKHTwdficicTB3bH0q5ic5UoSab51Omic7eyLBz0SNcvbLpQnNib7zP1yJFm7xxx4ia81iahfibRVnbTwHmhw/132","comment_is_top":false,"comment_ctime":1658394053,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1658394053","product_id":100077001,"comment_content":"老师我项目启动类也没加@ComponentScan，但是可以识别非启动类目录下的对象","like_count":0,"discussions":[{"author":{"id":2402801,"avatar":"https://static001.geekbang.org/account/avatar/00/24/a9/f1/791d0f5e.jpg","nickname":"程志强","note":"","ucode":"5FDBC60AD960E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589866,"discussion_content":"还真没遇到过这种状况，是不是启动类上没有加，但是其他配置配上加了，感觉不应该的啊，要不就是 lib包里面的类中有commonScan进行路径扫描了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665372907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345570,"user_name":"懵逼猴","can_delete":false,"product_type":"c1","uid":1204947,"ip_address":"","ucode":"BDC748A96AC316","user_header":"https://static001.geekbang.org/account/avatar/00/12/62/d3/663de972.jpg","comment_is_top":false,"comment_ctime":1652407958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652407958","product_id":100077001,"comment_content":"@lookup是不是也可以用来获取当前类被代理的实例，从而解决自身应用的问题？","like_count":0},{"had_liked":false,"id":345061,"user_name":"Geek_f19eb2","can_delete":false,"product_type":"c1","uid":2727697,"ip_address":"","ucode":"34EAAB72A07B5E","user_header":"","comment_is_top":false,"comment_ctime":1651996047,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651996047","product_id":100077001,"comment_content":"lookup注解学到了","like_count":0},{"had_liked":false,"id":342076,"user_name":"hackjavaer","can_delete":false,"product_type":"c1","uid":1531590,"ip_address":"","ucode":"092E8F1F49B03A","user_header":"https://static001.geekbang.org/account/avatar/00/17/5e/c6/24198c51.jpg","comment_is_top":false,"comment_ctime":1650004627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650004627","product_id":100077001,"comment_content":"回答下文章最后的问题，我尝试了下，如果构造参数是数组或者List ,Map的集合类型，那么也会自动构造一个对应类型的数组或者List，Map出来","like_count":0},{"had_liked":false,"id":332105,"user_name":"子夜枯灯","can_delete":false,"product_type":"c1","uid":1359678,"ip_address":"","ucode":"5D84BFE7832038","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/3e/cdc36608.jpg","comment_is_top":false,"comment_ctime":1643017777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643017777","product_id":100077001,"comment_content":"感谢讲师，手敲案例代码已上传GitHub。地址是：git@github.com:ziyekudeng&#47;geekbang_springDemo.git","like_count":0},{"had_liked":false,"id":326166,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1639402576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639402576","product_id":100077001,"comment_content":"老师讲课的这思路确实很好啊！从问题描述到源码剖析。但是我这边有两个问题还是想请教老师：<br>1. Spring源码很多，所以即便很多时候我想去debug看源码也是有心无力，那我觉得对于新手来说比较棘手的问题就是我怎么知道哪个类是重要的类？<br>2. 接上面的问题，我怎么知道这个类的哪个方法是我期望能帮我解决问题的方法？<br>希望老师能讲一下您是怎么从0到1阅读源码的。","like_count":0},{"had_liked":false,"id":319220,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1635683082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635683082","product_id":100077001,"comment_content":"那个bean隐式依赖的例子看不太懂","like_count":0},{"had_liked":false,"id":318447,"user_name":"Growing Quiet","can_delete":false,"product_type":"c1","uid":1483115,"ip_address":"","ucode":"ADA66BF76802B6","user_header":"https://static001.geekbang.org/account/avatar/00/16/a1/6b/f5f94a6f.jpg","comment_is_top":false,"comment_ctime":1635301108,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635301108","product_id":100077001,"comment_content":"案例二 对象有状态 实际大部分情况下没有状态","like_count":0},{"had_liked":false,"id":318445,"user_name":"Growing Quiet","can_delete":false,"product_type":"c1","uid":1483115,"ip_address":"","ucode":"ADA66BF76802B6","user_header":"https://static001.geekbang.org/account/avatar/00/16/a1/6b/f5f94a6f.jpg","comment_is_top":false,"comment_ctime":1635301040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635301040","product_id":100077001,"comment_content":"案例一 很常见","like_count":0},{"had_liked":false,"id":315380,"user_name":"恒星","can_delete":false,"product_type":"c1","uid":2715095,"ip_address":"","ucode":"C17DD00239780D","user_header":"","comment_is_top":false,"comment_ctime":1633871443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633871443","product_id":100077001,"comment_content":"回答问题，如果spring容器中已经存在构造器中需要的bean，就不会报注入bean的时候缺失参数依赖的错误","like_count":0},{"had_liked":false,"id":290397,"user_name":"Nightwish","can_delete":false,"product_type":"c1","uid":1122971,"ip_address":"","ucode":"29CC83987C6134","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/9b/e948d5c3.jpg","comment_is_top":false,"comment_ctime":1619525293,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619525293","product_id":100077001,"comment_content":"课程里的示例代码有上传吗？地址是多少","like_count":0,"discussions":[{"author":{"id":1125560,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2c/b8/fcaca637.jpg","nickname":"郭硕","note":"","ucode":"DE7B8F1AEF4087","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382412,"discussion_content":"课程介绍里提到了：https://github.com/jiafu1115/springissue","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625561400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290320,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1619496024,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1619496024","product_id":100077001,"comment_content":"弱弱问一句，案例2的修改方法不会引起循环依赖吗？","like_count":0,"discussions":[{"author":{"id":1331611,"avatar":"https://static001.geekbang.org/account/avatar/00/14/51/9b/ccea47d9.jpg","nickname":"安迪密恩","note":"","ucode":"A6F3F67CF8E6F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554842,"discussion_content":"加@Lazy","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646641946,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1230417,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c6/51/e39b5828.jpg","nickname":"刘鹏","note":"","ucode":"44F3D4DB3F5678","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381838,"discussion_content":"如果把属性的@Bean定义在service里面会循环依赖，放在其他类中定义就不会了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625232972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290198,"user_name":"哦吼掉了","can_delete":false,"product_type":"c1","uid":1232599,"ip_address":"","ucode":"1F89B1BA1EEF52","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/d7/8168e1bf.jpg","comment_is_top":false,"comment_ctime":1619427113,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1619427113","product_id":100077001,"comment_content":"很好奇为啥大佬们看到个注解就能找到相关的解析类，ex: @Lookup 对应CglibSubclassingInstantiationStrategy 如果让我自己猜，估计debug会打在@Lookup方法里面，然后一直debug不出来为啥。","like_count":0,"discussions":[{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372554,"discussion_content":"看调用栈，然后debug","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620375553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289613,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1100750,"ip_address":"","ucode":"768098DBDBE333","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/ce/d9e00eb5.jpg","comment_is_top":false,"comment_ctime":1619099723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619099723","product_id":100077001,"comment_content":"@听雨  &quot;2、JDK 1.8已经支持Repeatable注解，那是不是就不需要用@ComponentScans注解了，直接添加多个@ComponentScan注解就行&quot;<br><br>---------------<br>方案可行","like_count":0},{"had_liked":false,"id":289300,"user_name":"小不点","can_delete":false,"product_type":"c1","uid":1351860,"ip_address":"","ucode":"C307D44A185C34","user_header":"https://static001.geekbang.org/account/avatar/00/14/a0/b4/5173f1af.jpg","comment_is_top":false,"comment_ctime":1618973909,"is_pvip":false,"replies":[{"id":"105070","content":"你这个昵称我还记得，多谢支持！这个肯定也类似，源码分析类的课程都差不多，要多看二篇！不行就对着github上的案例自己调试下。","user_name":"作者回复","user_name_real":"傅健","uid":"1638649","ctime":1619133844,"ip_address":"","comment_id":289300,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1618973909","product_id":100077001,"comment_content":"先马后看，从Netty过来的，Netty篇章反复看了好久才算整明白，希望这次也一样","like_count":0,"discussions":[{"author":{"id":1638649,"avatar":"https://static001.geekbang.org/account/avatar/00/19/00/f9/44a3e5bd.jpg","nickname":"傅健","note":"","ucode":"5EA8BB26F5B036","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518879,"discussion_content":"你这个昵称我还记得，多谢支持！这个肯定也类似，源码分析类的课程都差不多，要多看二篇！不行就对着github上的案例自己调试下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619133844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1359678,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/3e/cdc36608.jpg","nickname":"子夜枯灯","note":"","ucode":"5D84BFE7832038","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548058,"discussion_content":"请问GitHub上的案例地址是多少？谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643014287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}