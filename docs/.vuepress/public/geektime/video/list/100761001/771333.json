{"id":771333,"title":"06｜接口类型的联合与交叉","content":"","comments":[{"had_liked":false,"id":390322,"user_name":"westfall","can_delete":false,"product_type":"c3","uid":1632773,"ip_address":"中国香港","ucode":"F3F5CB7DF695FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/ea/05/9976b871.jpg","comment_is_top":false,"comment_ctime":1715098463,"is_pvip":false,"replies":[{"id":141950,"content":"先记住一个OOP的基本特性，就是：子类的实例可以赋值给父类。这是继承性决定的，也就是说：鸟是动物，决定了bird可以赋给Animal的实例x。例如：\n```\n&#47;&#47; 注意类型T相当于Animal类型\nlet x: Animal = new Bird();\n```\n但上述赋值发生之后，请问x是什么类型？x是它声明的类型Animal，还是它赋值后的实体类型Bird？在强类型系统中，除非显式转换，x的类型总是按声明的Animal来理解的——这也是“静态类型系统”的本意。所以，无论这里的x是赋值了bird还是horse，它在后续的运算中，都只是理解为显式声明的Animal类型。这也就是你尝试存取x1.wings时会报错的原因。\n\nTS会提供一种“类型收窄”的技术，使JS逻辑中（注意这里是JS逻辑）的类型识别在特定的上下文中可以将实例的类型——例如这里的x&#47;x1——识别为“收窄后的类型”。这个要在第13讲中才讲。而所谓“收窄”，就是让JS在执行过程中将x&#47;x1的类型识别为“更具体”的类型，从而完成你上述的取值（或向x1.wings成员赋值）的操作。例如：\n```\n&#47;&#47; 声明守护函数isBird()\nfunction isBird(x) ...\n\n&#47;&#47; 类型识别与收窄（第13讲）\nif (isBird(x1)) {\n  console.log(x1.wing); &#47;&#47; success\n}\n```\n\nNOTE1：“子类的实例可以赋值给父类”同样可以放到子类型兼容的概念中去讲，这也是“子类型可以赋给父类型（例如将字符串字面量赋给string类型）”的原因。同样，这个逻辑，也就是“更具体的类型可以赋给更抽象的类型”的原因，鸟（bird）是一个更具体的“动物（Animal）”，又或者“生物”或“物”是相对于动物更抽象的数据概念，或类型。\n\nNOTE2: 类型T与类型Animal本质上还是有些不同的。事实上因为类型T是通过Omit&lt;&gt;计算出来的，所以它与Bird&#47;Horse并没有显式的继承关系，在做兼容性计算时用的是“结构性兼容”。如果是Animal类型，并用extends声明过与Bird&#47;Horse的继承性关系，那么计算时会是“子类型兼容”。——尽管在这个例子中，这两种处理方法的结果一致，但概念上还是不同的。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1715155677,"ip_address":"河南","comment_id":390322,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"```\ninterface Bird {\n    weight: number;\n    wings: number;\n}\n\ninterface Horse {\n    weight: number;\n    id: string;\n}\n\ntype T = Omit&lt;Bird | Horse, never&gt;;\n\nlet bird: Bird = {\n    weight: 10,\n    wings: 2\n}\n\nlet x1: T = bird;\nconsole.log(x1.wing);\n```\n请问老师，倒数第二行 T 的类型是 \n```\ntype T = {\n    weight: number;\n}\n```\n把 bird 赋给 x1 没有 TS 类型错误，但是最后一行取 x1.wings 报错：&quot;Property &#39;wings&#39; does not exist on type &#39;T&#39;&quot;\n赋值的时候不报错，取值的时候报错，这里是不是有点点矛盾呢？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644291,"discussion_content":"先记住一个OOP的基本特性，就是：子类的实例可以赋值给父类。这是继承性决定的，也就是说：鸟是动物，决定了bird可以赋给Animal的实例x。例如：\n```\n// 注意类型T相当于Animal类型\nlet x: Animal = new Bird();\n```\n但上述赋值发生之后，请问x是什么类型？x是它声明的类型Animal，还是它赋值后的实体类型Bird？在强类型系统中，除非显式转换，x的类型总是按声明的Animal来理解的——这也是“静态类型系统”的本意。所以，无论这里的x是赋值了bird还是horse，它在后续的运算中，都只是理解为显式声明的Animal类型。这也就是你尝试存取x1.wings时会报错的原因。\n\nTS会提供一种“类型收窄”的技术，使JS逻辑中（注意这里是JS逻辑）的类型识别在特定的上下文中可以将实例的类型——例如这里的x/x1——识别为“收窄后的类型”。这个要在第13讲中才讲。而所谓“收窄”，就是让JS在执行过程中将x/x1的类型识别为“更具体”的类型，从而完成你上述的取值（或向x1.wings成员赋值）的操作。例如：\n```\n// 声明守护函数isBird()\nfunction isBird(x) ...\n\n// 类型识别与收窄（第13讲）\nif (isBird(x1)) {\n  console.log(x1.wing); // success\n}\n```\n\nNOTE1：“子类的实例可以赋值给父类”同样可以放到子类型兼容的概念中去讲，这也是“子类型可以赋给父类型（例如将字符串字面量赋给string类型）”的原因。同样，这个逻辑，也就是“更具体的类型可以赋给更抽象的类型”的原因，鸟（bird）是一个更具体的“动物（Animal）”，又或者“生物”或“物”是相对于动物更抽象的数据概念，或类型。\n\nNOTE2: 类型T与类型Animal本质上还是有些不同的。事实上因为类型T是通过Omit&lt;&gt;计算出来的，所以它与Bird/Horse并没有显式的继承关系，在做兼容性计算时用的是“结构性兼容”。如果是Animal类型，并用extends声明过与Bird/Horse的继承性关系，那么计算时会是“子类型兼容”。——尽管在这个例子中，这两种处理方法的结果一致，但概念上还是不同的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715155677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"河南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395995,"user_name":"zgy","can_delete":false,"product_type":"c3","uid":1387798,"ip_address":"上海","ucode":"05EA6845199250","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/16/b525a71d.jpg","comment_is_top":false,"comment_ctime":1732629272,"is_pvip":false,"replies":[{"id":143786,"content":"好像没有这个限制啊","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1732695173,"ip_address":"江苏","comment_id":395995,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"我记得以前interface好像不能用与联合类型和交叉类型，只有type可以。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654437,"discussion_content":"好像没有这个限制啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732695173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395775,"user_name":"郑俊毅","can_delete":false,"product_type":"c3","uid":3022939,"ip_address":"重庆","ucode":"12C9ADC4A29ECD","user_header":"","comment_is_top":false,"comment_ctime":1732023324,"is_pvip":false,"replies":[{"id":143754,"content":"这个赋值时对字面量（对象）的兼容性检查，并不算是类型兼容问题。——所以在TS的出错提示中是“对象字面量只能指定已知属性（ts2353）”。下面这个例子说明”obj3字面量的类型”，是可以赋给obj2的，注意obj2使用了let变量。\n```\nlet  obj2 : PartialPoint1; &#47;&#47; = { y:2 }\n\nlet obj3 = {\n  x:1,\n  y:2,\n  z:3,\n}\nobj2 = obj3;\n```\n\n注意其中的obj2用的类型是PartialPoint1 ，也可以不赋初值。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1732397214,"ip_address":"江苏","comment_id":395775,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"type PartialPointX = { x: number, z:number, };\ntype PartialPointY = { y: number, x:number };\ntype PartialPoint = PartialPointX | PartialPointY; \ntype PartialPoint1 = Omit&lt;PartialPoint,never&gt;; \nconst  obj1 : PartialPoint = {\n  x:1,\n  y:2,\n  z:3,\n}\nconst  obj2 : PartialPoint1 = {\n  x:1,\n  y:2,\n  z:3,\n}\nobj2 会报错，因为此时PartialPoint1=  {\n    x: number;\n}，为什么导致和obj1不一致呢？为什么obj1就不报错呢？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654300,"discussion_content":"这个赋值时对字面量（对象）的兼容性检查，并不算是类型兼容问题。——所以在TS的出错提示中是“对象字面量只能指定已知属性（ts2353）”。下面这个例子说明”obj3字面量的类型”，是可以赋给obj2的，注意obj2使用了let变量。\n```\nlet  obj2 : PartialPoint1; // = { y:2 }\n\nlet obj3 = {\n  x:1,\n  y:2,\n  z:3,\n}\nobj2 = obj3;\n```\n\n注意其中的obj2用的类型是PartialPoint1 ，也可以不赋初值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1732397214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395049,"user_name":"杨浩","can_delete":false,"product_type":"c3","uid":1333606,"ip_address":"湖南","ucode":"4D51BD8452BF04","user_header":"https://static001.geekbang.org/account/avatar/00/14/59/66/e2839938.jpg","comment_is_top":false,"comment_ctime":1729170639,"is_pvip":false,"replies":[{"id":143453,"content":"在第3讲的课件中，有专门关于概念的解释。对于TypeScript中如何理解结构类型和名义类型有帮助，建议你阅读一下。在课程里面，我是尽量不去详细的讲述和辨析概念的，因为时间有限。课件跟视频中的PPT略有不同，加上了专门的概念页和QA页。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1729247900,"ip_address":"江苏","comment_id":395049,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"我是一个只有js初学者，这几节课学晕了。\nTypeScript 是结构化的类型系统，核心原则是类型检查基于对象的属性和行为，“鸭子类型”或“结构类型”\n  - 结构化的类型系统中，如果两个对象具有相同的结构，则认为它们是相同类型的\n  - 鸭子类型：如果它看起来像鸭子，走起来像鸭子，那它就是鸭子\n我的理解就是无论是 | 还是 &amp; ，TypeScript 判断类型是否有问题都是基于这个 结构化的类型系统来的。\n\n有同感的可以看看官网的入门教程：结构化的类型系统\nhttps:&#47;&#47;www.typescriptlang.org&#47;zh&#47;docs&#47;handbook&#47;typescript-in-5-minutes.html#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9Fstructural-type-system","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652611,"discussion_content":"在第3讲的课件中，有专门关于概念的解释。对于TypeScript中如何理解结构类型和名义类型有帮助，建议你阅读一下。在课程里面，我是尽量不去详细的讲述和辨析概念的，因为时间有限。课件跟视频中的PPT略有不同，加上了专门的概念页和QA页。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1729247900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":652612,"discussion_content":"补充一下，第6讲的课件也是有QA的。：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1729247938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390555,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1715656524,"is_pvip":false,"replies":[{"id":142073,"content":"GOOD! \n\n首先，你的理解和结论都是对的。只不过本课程考虑到内容的组织问题，有些东西是放在靠后一些的章节中去讲的，所以某些内容在现在主要讲的就是个“现象”，而先略去了背后的理论部分。\n\n你指出的计算类型与结果类型是一个大的部分，这得到第15讲之后才被讨论，而且也不是用的计算&#47;结果这样的概念，而是提出了“表达式类型”，并在上面用到了惰性求值的语言概念。本课程在这方面的体系性，与很多网上可见的资料不同，在后面的学习中你可能需要留意。\n\n关于类型收窄的问题则是第13讲的内容，在那一讲里面会指出收窄与交叉之间的关系，以及它在联合类型中的应用。\n\n最后，“^?”的确是一非常有趣的技巧，我还是第一次见呢。赞的呀👍","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1715743806,"ip_address":"江苏","comment_id":390555,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"interface A {\n  leg: number;\n  weight:number;\n  wings: number;\n}\ninterface B {\n  leg: number;\n  weight:number;\n  id: string;\n}\n&#47;&#47; 联合、交叉的结果是计算类型，不是结果类型\ntype C = A | B;\n&#47;&#47;   ^?\ntype D = A &amp; B;\n&#47;&#47;   ^?\n&#47;&#47; 使用Omit后C这个交叉类型变成了结果类型\ntype E = Omit&lt;C, never&gt;;\n&#47;&#47;   ^?\nconst a: A = {\n  leg: 1,\n  weight: 2,\n  wings: 1,\n}\nconst b: B = {\n  leg: 1,\n  weight: 2,\n  id: &#39;2&#39;\n}\nconst d: D = {\n  leg: 1,\n  weight: 2,\n  wings: 1,\n  id: &#39;2&#39;,\n}\n&#47;&#47; 变量c在被赋值时, 右侧既可以是 a(interface A) 也可以是 b(interface B), 更能是 d(type D)\n&#47;&#47; 在被使用时  C 这个计算类型 会被 类型收窄 变成 E (E 只包含了 A 与 B 的公共部分, 所以 E 可以看作是A与B的父类) 以达到安全调用的目的\n&#47;&#47; 这个就是所谓的子类可以赋值给父类\nlet c: C = a;\nc = b;\nc = d;\n&#47;&#47; 但是在使用 c的属性时，c 的类型会被收窄为 E\nconsole.log(c.leg)\nconsole.log(c.weight)\n\nconsole.log(c.id) &#47;&#47; Property &#39;id&#39; does not exist on type &#39;C&#39;. 由于 Property &#39;id&#39; does not exist on type &#39;A&#39;\nconsole.log(c.wings) &#47;&#47; Property &#39;wings&#39; does not exist on type &#39;C&#39; 由于 Property &#39;id&#39; does not exist on type &#39;B&#39;\n\n&#47;&#47; 此时可以通过断言来安全调用\nconsole.log(&#39;wings&#39; in c ? c.wings : void 0);&#47;&#47; 如果 wings 这个属性存在于 c 中，则 c 可以被视为 interface A\nconsole.log(&#39;id&#39; in c ? c.id : void 0); &#47;&#47; 如果 id 这个属性存在于 c 中，则 c 可以被视为 interface B\n\n分享一个技巧:\n在https:&#47;&#47;www.typescriptlang.org&#47;play 中 \ntype C = A | B;\n&#47;&#47;   ^? \n此处的 &#47;&#47; ^? 可以显示C的具体类型","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645062,"discussion_content":"GOOD! \n\n首先，你的理解和结论都是对的。只不过本课程考虑到内容的组织问题，有些东西是放在靠后一些的章节中去讲的，所以某些内容在现在主要讲的就是个“现象”，而先略去了背后的理论部分。\n\n你指出的计算类型与结果类型是一个大的部分，这得到第15讲之后才被讨论，而且也不是用的计算/结果这样的概念，而是提出了“表达式类型”，并在上面用到了惰性求值的语言概念。本课程在这方面的体系性，与很多网上可见的资料不同，在后面的学习中你可能需要留意。\n\n关于类型收窄的问题则是第13讲的内容，在那一讲里面会指出收窄与交叉之间的关系，以及它在联合类型中的应用。\n\n最后，“^?”的确是一非常有趣的技巧，我还是第一次见呢。赞的呀👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715743806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645066,"discussion_content":"另外补充一点，“&#39;wings&#39; in c ? c.wings ...”这里的用法可不是“断言”，这仍然是类型守护的一种应用。通常来说，写成”&#39;wings&#39; in c &amp;&amp; c.wings“会更便利一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715745525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1160078,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","nickname":"Jack Q","note":"","ucode":"A7DBC311884FFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":645089,"discussion_content":"谢谢老师指正.我之前对类型断言、类型守卫的认知是有问题的.\n重新复习了下类型断言 Type Assertions 和 类型收窄 Narrowing\n类型断言:\nlet word: any = &#34;this is a string&#34;;\n// 尖括号语法\nlet word1: number = (&lt;string&gt;someValue).length;\n// as 语法\nlet word2: number = (someValue as string).length;\n用于告诉编译器你比它更了解变量的类型。它不会在运行时进行任何检查或转换，只是在编译阶段帮助编译器理解代码的意图\n场景:用于明确类型（即编译器无法推断或推断错误时）\n\n类型收窄:\n类型守卫: typeof 、=== 、 in 、 instanceof、返回满足 params is Type（type predicate 类型谓词）形式定义的断言函数\n控制流分析: if else \\ switch case\n不知道算是控制流分析 还是类型守卫的 :  赋值(Assignments)\n类型收窄是通过类型检查和控制流分析逐步将变量的类型从宽泛的联合类型或其他复杂类型缩小到更具体的类型。\n场景:用于通过检查逻辑逐步明确类型（即处理联合类型和复杂类型）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715771219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645066,"ip_address":"广东","group_id":0},"score":645089,"extra":""}]}]},{"had_liked":false,"id":390483,"user_name":"Neu","can_delete":false,"product_type":"c3","uid":1901854,"ip_address":"北京","ucode":"48F8C312B94999","user_header":"https://static001.geekbang.org/account/avatar/00/1d/05/1e/02245834.jpg","comment_is_top":false,"comment_ctime":1715430413,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":2,"score":2,"product_id":100761001,"comment_content":"联合A|B，既可以是A，也可以是B，但不能是其他 交叉A&amp;B，必须是同时具有A和B的所有属性的新类型","like_count":0}]}