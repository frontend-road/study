{"id":109201,"title":"26 | 答疑课堂：模块四热点问题解答","content":"<p>你好，我是刘超。</p><p>本周我们结束了“JVM性能监测及调优”的学习，这一期答疑课堂我精选了模块四中 11 位同学的留言，进行集中解答，希望也能对你有所帮助。另外，我想为坚持跟到现在的同学点个赞，期待我们能有更多的技术交流，共同成长。</p><h2><a href=\"https://time.geekbang.org/column/article/106203\">第20讲</a></h2><p><img src=\"https://static001.geekbang.org/resource/image/31/3a/31a205290c3b2391f115ee77f511a43a.jpeg?wh=1125*1306\" alt=\"\"></p><p>很多同学都问到了类似“黑夜里的猫\"问到的问题，所以我来集中回复一下。JVM的内存模型只是一个规范，方法区也是一个规范，一个逻辑分区，并不是一个物理空间，我们这里说的字符串常量放在堆内存空间中，是指实际的物理空间。</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/01/2ac5ee0c9a6fe67ce8f896be75d05f01.jpeg?wh=1125*1218\" alt=\"\"></p><p>文灏的问题和上一个类似，一同回复一下。元空间是属于方法区的，方法区只是一个逻辑分区，而元空间是具体实现。所以类的元数据是存放在元空间，逻辑上属于方法区。</p><h2><a href=\"https://time.geekbang.org/column/article/106953\">第21讲</a></h2><p><img src=\"https://static001.geekbang.org/resource/image/f2/76/f2fa07e388f5a3dbe84bb12bfea5ee76.jpeg?wh=1125*1164\" alt=\"\"></p><p>Liam同学，目前Hotspot虚拟机暂时不支持栈上分配对象。W.LI同学的留言值得参考，所以这里一同贴出来了。</p><p><img src=\"https://static001.geekbang.org/resource/image/20/f2/20e59cb2df51bd171d41c81e074821f2.jpeg?wh=1080*2566\" alt=\"\"></p><h2><a href=\"https://time.geekbang.org/column/article/107396\">第22讲</a></h2><p><img src=\"https://static001.geekbang.org/resource/image/09/25/09ada15236e8ceeef2558d6ab7505425.jpeg?wh=1125*4041\" alt=\"\"></p><p>非常赞，Region这块，Jxin同学讲解得很到位。这里我再总结下CMS和G1的一些知识点。</p><p>CMS垃圾收集器是基于标记清除算法实现的，目前主要用于老年代垃圾回收。CMS收集器的GC周期主要由7个阶段组成，其中有两个阶段会发生stop-the-world，其它阶段都是并发执行的。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/50/aa/500c2f0e112ced378fd49a09c61c5caa.jpg?wh=1276*1132\" alt=\"\"></p><p>G1垃圾收集器是基于标记整理算法实现的，是一个分代垃圾收集器，既负责年轻代，也负责老年代的垃圾回收。</p><p>跟之前各个分代使用连续的虚拟内存地址不一样，G1使用了一种  Region  方式对堆内存进行了划分，同样也分年轻代、老年代，但每一代使用的是N个不连续的Region内存块，每个Region占用一块连续的虚拟内存地址。</p><p>在G1中，还有一种叫 Humongous  区域，用于存储特别大的对象。G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代的YoungGC中被回收掉。</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/be/f832278afd5cdb94decd1f6826056dbe.jpg?wh=868*578\" alt=\"\"></p><p>G1分为Young GC、Mix GC以及Full GC。</p><p>G1 Young GC主要是在Eden区进行，当Eden区空间不足时，则会触发一次Young GC。将Eden区数据移到Survivor空间时，如果Survivor空间不足，则会直接晋升到老年代。此时Survivor的数据也会晋升到老年代。Young GC的执行是并行的，期间会发生STW。</p><p>当堆空间的占用率达到一定阈值后会触发G1 Mix GC（阈值由命令参数-XX:InitiatingHeapOccupancyPercent设定，默认值45），Mix GC主要包括了四个阶段，其中只有并发标记阶段不会发生STW，其它阶段均会发生STW。</p><p><img src=\"https://static001.geekbang.org/resource/image/b8/2f/b8090ff2c7ddf54fb5f6e3c19a36d32f.jpg?wh=2536*1032\" alt=\"\"></p><p>G1和CMS主要的区别在于：</p><ul>\n<li>CMS主要集中在老年代的回收，而G1集中在分代回收，包括了年轻代的Young GC以及老年代的Mix GC；</li>\n<li>G1使用了Region方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生；</li>\n<li>在初始化标记阶段，搜索可达对象使用到的Card Table，其实现方式不一样。</li>\n</ul><p>这里我简单解释下Card Table，在垃圾回收的时候都是从Root开始搜索，这会先经过年轻代再到老年代，也有可能老年代引用到年轻代对象，如果发生Young GC，除了从年轻代扫描根对象之外，还需要再从老年代扫描根对象，确认引用年轻代对象的情况。</p><p><strong>这种属于跨代处理，非常消耗性能。</strong>为了避免在回收年轻代时跨代扫描整个老年代，CMS和G1都用到了Card Table来记录这些引用关系。只是G1在Card Table的基础上引入了RSet，每个Region初始化时，都会初始化一个RSet，RSet记录了其它Region中的对象引用本Region对象的关系。</p><p>除此之外，CMS和G1在解决并发标记时漏标的方式也不一样，CMS使用的是Incremental Update算法，而G1使用的是SATB算法。</p><p>首先，我们要了解在并发标记中，G1和CMS都是基于三色标记算法来实现的：</p><ul>\n<li>黑色：根对象，或者对象和对象中的子对象都被扫描；</li>\n<li>灰色：对象本身被扫描，但还没扫描对象中的子对象；</li>\n<li>白色：不可达对象。</li>\n</ul><p>基于这种标记有一个漏标的问题，也就是说，当一个白色标记对象，在垃圾回收被清理掉时，正好有一个对象引用了该白色标记对象，此时由于被回收掉了，就会出现对象丢失的问题。</p><p>为了避免上述问题，CMS采用了Incremental Update算法，只要在写屏障（write barrier）里发现一个白对象的引用被赋值到一个黑对象的字段里，那就把这个白对象变成灰色的。而在G1中，采用的是SATB算法，该算法认为开始时所有能遍历到的对象都是需要标记的，即认为都是活的。</p><p>G1具备Pause Prediction Model ，即停顿预测模型。用户可以设定整个GC过程中期望的停顿时间，用参数-XX:MaxGCPauseMillis可以指定一个G1收集过程的目标停顿时间，默认值200ms。</p><p>G1会根据这个模型统计出来的历史数据，来预测一次垃圾回收所需要的Region数量，通过控制Region数来控制目标停顿时间的实现。</p><p><img src=\"https://static001.geekbang.org/resource/image/91/b4/915e9793981a278112087f0c880b96b4.jpeg?wh=1125*1386\" alt=\"\"></p><p>Liam提出的这两个问题都非常好。</p><p>不管什么GC，都会发送stop-the-world，区别是发生的时间长短。而这个时间跟垃圾收集器又有关系，Serial、PartNew、Parallel Scavenge收集器无论是串行还是并行，都会挂起用户线程，而CMS和G1在并发标记时，是不会挂起用户线程的，但其它时候一样会挂起用户线程，stop the world 的时间相对来说就小很多了。</p><p>Major Gc 在很多参考资料中是等价于 Full GC的，我们也可以发现很多性能监测工具中只有Minor GC 和 Full GC。一般情况下，一次Full GC将会对年轻代、老年代、元空间以及堆外内存进行垃圾回收。触发Full GC的原因有很多：</p><ul>\n<li>当年轻代晋升到老年代的对象大小，并比目前老年代剩余的空间大小还要大时，会触发Full GC；</li>\n<li>当老年代的空间使用率超过某阈值时，会触发Full GC；</li>\n<li>当元空间不足时（JDK1.7永久代不足），也会触发Full GC；</li>\n<li>当调用System.gc()也会安排一次Full GC。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/a8/24/a8a506a512922609669b4073d0dbc224.jpeg?wh=1125*2314\" alt=\"\"></p><p>接下来解答 ninghtmare 的提问。我们可以通过  jstat -gc pid interval  查看每次GC之后，具体每一个分区的内存使用率变化情况。我们可以通过JVM的设置参数，来查看垃圾收集器的具体设置参数，使用的方式有很多，例如  jcmd pid VM.flags 就可以查看到相关的设置参数。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/2e/26d688a3af534fb00fe3b89d261e5c2e.jpg?wh=1926*190\" alt=\"\"></p><p>这里附上第22讲中，我总结的各个设置参数对应的垃圾收集器图表。</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/56/e29c9ac3e53ffbc8a5648644a87d6256.jpeg?wh=1896*702\" alt=\"\"></p><h2><a href=\"https://time.geekbang.org/column/article/108139\">第23讲</a></h2><p><img src=\"https://static001.geekbang.org/resource/image/bb/76/bb92ec845c715f9d36a6ce48a0c7d276.jpeg?wh=1125*2227\" alt=\"\"></p><p>我又不乱来同学的留言真是没有乱来，细节掌握得很好！</p><p>前提是老年代有足够接受这些对象的空间，才会进行分配担保。如果老年代剩余空间小于每次Minor GC晋升到老年代的平均值，则会发起一次  Full GC。</p><p><img src=\"https://static001.geekbang.org/resource/image/28/20/2838514b87e62d69bf51d7a7f12a0c20.jpeg?wh=1125*2271\" alt=\"\"></p><p>看到这里，我发现爱提问的同学始终爱提问，非常鼓励啊，技术是需要交流的，也欢迎你有任何疑问，随时留言给我，我会知无不尽。</p><p>现在回答W.LI同学的问题。这个会根据我们创建对象占用的内存使用率，合理分配内存，并不仅仅考虑对象晋升的问题，还会综合考虑回收停顿时间等因素。针对某些特殊场景，我们可以手动来调优配置。</p><h2><a href=\"https://time.geekbang.org/column/article/108582\">第24讲</a></h2><p><img src=\"https://static001.geekbang.org/resource/image/10/24/1080a8574a1a1ded35b736ccbec40524.jpeg?wh=1125*1164\" alt=\"\"></p><p>下面解答Geek_75b4cd同学的问题。</p><p>我们知道，ThreadLocal是基于ThreadLocalMap实现的，这个Map的Entry继承了WeakReference，而Entry对象中的key使用了WeakReference封装，也就是说Entry中的key是一个弱引用类型，而弱引用类型只能存活在下次GC之前。</p><p>如果一个线程调用ThreadLocal的set设置变量，当前ThreadLocalMap则会新增一条记录，但由于发生了一次垃圾回收，此时的key值就会被回收，而value值依然存在内存中，由于当前线程一直存在，所以value值将一直被引用。.</p><p>这些被垃圾回收掉的key就会一直存在一条引用链的关系：Thread --&gt; ThreadLocalMap–&gt;Entry–&gt;Value。这条引用链会导致Entry不会被回收，Value也不会被回收，但Entry中的key却已经被回收的情况发生，从而造成内存泄漏。</p><p>我们只需要在使用完该key值之后，将value值通过remove方法remove掉，就可以防止内存泄漏了。</p><p><img src=\"https://static001.geekbang.org/resource/image/8d/9a/8da35d95d5b31e3f0a582dbd4d47fd9a.jpeg?wh=1125*1252\" alt=\"\"></p><p>最后一个问题来自于WL同学。</p><p>内存泄漏是指不再使用的对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。例如，我在<a href=\"https://time.geekbang.org/column/article/97215\">第03讲</a>中说到的，Java6中substring方法就可能会导致内存泄漏。</p><p>当调用substring方法时会调用new string构造函数，此时会复用原来字符串的char数组，而如果我们仅仅是用substring获取一小段字符，而在原本string字符串非常大的情况下，substring的对象如果一直被引用，由于substring里的char数组仍然指向原字符串，此时string字符串也无法回收，从而导致内存泄露。</p><p>内存溢出则是发生了OutOfMemoryException，内存溢出的情况有很多，例如堆内存空间不足，栈空间不足，还有方法区空间不足等都会导致内存溢出。</p><p>内存泄漏与内存溢出的关系：内存泄漏很容易导致内存溢出，但内存溢出不一定是内存泄漏导致的。</p><p>今天的答疑就到这里，<span class=\"orange\">如果你还有其它问题，请在留言区中提出，</span>我会一一解答。最后欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他加入讨论。</p><p></p>","comments":[{"had_liked":false,"id":130042,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1567359932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"139006313404","product_id":100028001,"comment_content":"这是一门神课","like_count":33},{"had_liked":false,"id":119249,"user_name":"Nu11PointerEx","can_delete":false,"product_type":"c1","uid":1177802,"ip_address":"","ucode":"D5C19A98F894B7","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/ca/1a1e190a.jpg","comment_is_top":false,"comment_ctime":1564543290,"is_pvip":false,"replies":[{"id":"44111","content":"如果线程没有销毁，也就是说该key值依然存在引用，即使是弱引用，也不会被回收掉。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564800099,"ip_address":"","comment_id":119249,"utype":1}],"discussion_count":4,"race_medal":0,"score":"23039379770","product_id":100028001,"comment_content":"刘老师,我有个疑问，文中指出弱引用只能存活再下次GC之前，那假如线程在步骤A设置了threadlocal的值,然后需要在步骤B读出来，但是在AB之间发生了GC,这样会不会导致在步骤B中无法取到对应的值","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460807,"discussion_content":"如果线程没有销毁，也就是说该key值依然存在引用，即使是弱引用，也不会被回收掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564800099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926759,"avatar":"","nickname":"赵玉闯","note":"","ucode":"82E85AC08206EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230755,"discussion_content":"我觉得既然你还要读，说明还存在一个对ThreadLocal变量的强引用，要不然你怎么读啊","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586769234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591965,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0F94uoYZQicTtcnDBmbhtc7kZDhKowk41K0G8pZib78swFWv9St1l2fUXX9OakMcmVUAYrLhlEZcQ/132","nickname":"Geek_f9c1a9","note":"","ucode":"147BE9F15BCC56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591971,"discussion_content":"步骤A还存在着对ThreadLocal的强引用，就不会被回收掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666967364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302972,"discussion_content":"存在强引用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599101771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115444,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1563589818,"is_pvip":false,"replies":[{"id":"43561","content":"对的，调用wait之后，会进入到WaitSet队列，当调用notify之后，默认策略是将其从WaitSet队列转至EntryList队列中，再尝试获取锁。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564452241,"ip_address":"","comment_id":115444,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18743459002","product_id":100028001,"comment_content":"老师好!最近正好在看多线程编程指南。有个东西没搞明白。<br>我自己写了个demo把所有线程都在临界区调用wait方法，wait方法后是sleep方法。我在主线程调用了notifyall()，在临界区内打印了所有线程的状态，notifyall()之前都是waiting，之后都是blocked。出了临界区之后又打印了一次，发现有一个是timed_waiting，别的还是blocked。<br>从表现来看<br>notifyall():wait-&gt;blocked<br>调用notifyall()的线程出临界区释放锁锁:<br>竞争到锁定blocked-&gt;runnable，别的还是blocked。<br>之前老师说notifyall()在出临界区的时候调用比较好，可以防止被唤醒的阻塞状态线程，竞争不到锁再次阻塞。<br>notifyall是本地方法看不到实现。我想确认下<br>notifyall的逻辑是:唤醒waiting线程-&gt;尝试获取锁-&gt;获取不到blocked?<br>还是:所有waiting状态线程-&gt;blocked状态进去锁池队列。(只有在有线程释放锁的时候(出临界区)才会从锁池队列拿一个线程尝试获取锁)。我比较倾向于第二种。没看源码希望老师帮忙解惑下，我特意翻了之前的课在那边也留言了，老师在这回复就好了谢谢老师","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459113,"discussion_content":"对的，调用wait之后，会进入到WaitSet队列，当调用notify之后，默认策略是将其从WaitSet队列转至EntryList队列中，再尝试获取锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564452241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118166,"user_name":"Stalary","can_delete":false,"product_type":"c1","uid":1101749,"ip_address":"","ucode":"F69AFF7C958D31","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/b5/d1ec6a7d.jpg","comment_is_top":false,"comment_ctime":1564281873,"is_pvip":false,"replies":[{"id":"43394","content":"是的，如果我们的线程在使用ThreadLocal的set之后就立刻销毁了，此时之前set的线程的key值通过垃圾回收回收掉，此时value则会存在内存泄漏，而马上又有下一个线程使用ThreadLocal的set，则会清除之前key为null的value，这种情况下是不会出现内存泄漏的。<br><br>也就是ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。<br><br>我们可以使用set之后，sleep下该线程，等待其他请求都一起使用完了set，这样很容易重现内存中的一部分对象无法回收掉。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564365850,"ip_address":"","comment_id":118166,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14449183761","product_id":100028001,"comment_content":"老师，ThreadLocal使用的时候我存储了一些请求相关的东西，没有使用remove，但是一次请求结束就会自动释放掉了吧，是不是不会出现内存泄漏？还是没太明白出现内存泄漏的场景，线程不都是工作完就会释放掉了吗","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460286,"discussion_content":"是的，如果我们的线程在使用ThreadLocal的set之后就立刻销毁了，此时之前set的线程的key值通过垃圾回收回收掉，此时value则会存在内存泄漏，而马上又有下一个线程使用ThreadLocal的set，则会清除之前key为null的value，这种情况下是不会出现内存泄漏的。\n\n也就是ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。\n\n我们可以使用set之后，sleep下该线程，等待其他请求都一起使用完了set，这样很容易重现内存中的一部分对象无法回收掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564365850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263932,"avatar":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","nickname":"静静聆听","note":"","ucode":"0A8600CB928EFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333722,"discussion_content":"老师说的有点不对，我补充下，线程回收掉后，threadlocal整个对象也会被回收，不会内存泄露，\nthreadlocal这个对象是被当前线程引用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607603746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1139455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/62/ff/f71034e9.jpg","nickname":"悟空WuKong","note":"","ucode":"49AFD2B048C1BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44170,"discussion_content":"使用线程池的时候，核心线程是不会销毁的，这种情况下是不是必须要手动remove来清楚value","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572936987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115395,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1563557049,"is_pvip":false,"replies":[{"id":"42361","content":"好的，可以考虑。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563760818,"ip_address":"","comment_id":115395,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14448458937","product_id":100028001,"comment_content":"老师cms和g1能不能加餐讲详细一点 因为互联网公司 cms和g1问的非常多","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459086,"discussion_content":"好的，可以考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563760818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132505,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1568157494,"is_pvip":false,"replies":[{"id":"50689","content":"不行，只是原来的引用置为null了，但堆中的字符串对象依然不会被回收掉","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568165106,"ip_address":"","comment_id":132505,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10158092086","product_id":100028001,"comment_content":"老师，jdk1.6的substring导致内存泄漏的问题。大字符串截取完之后，我们直接把原大字符串的引用置为null，可以解决这个内存泄漏的问题吗？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466977,"discussion_content":"不行，只是原来的引用置为null了，但堆中的字符串对象依然不会被回收掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568165106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115880,"user_name":"ヾ(◍°∇°◍)ﾉﾞ","can_delete":false,"product_type":"c1","uid":1044175,"ip_address":"","ucode":"89545632BDA56E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOBwR7MCVqwZbPA5RQ2mjUjd571jUXUcBCE7lY5vSMibWn8D5S4PzDZMaAhRPdnRBqYbVOBTJibhJg/132","comment_is_top":false,"comment_ctime":1563761162,"is_pvip":false,"replies":[{"id":"43108","content":"是的，对象的引用也被指向新的地址。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564109599,"ip_address":"","comment_id":115880,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10153695754","product_id":100028001,"comment_content":"java的垃圾回收使用的是复制算法和标记整理算法，这样对象的内存是变化的吧？那么引用它的栈上的地址也会变掉吗？如果是的话如果hashmap的key如果没有自己实现hashcode的话，是不是就会引起了内存泄漏和程序错乱","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459328,"discussion_content":"是的，对象的引用也被指向新的地址。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564109599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115563,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1563627545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10153562137","product_id":100028001,"comment_content":"抛砖引玉了，感谢老师的知无不尽。( ´◔‸◔`)","like_count":2},{"had_liked":false,"id":132804,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568243029,"is_pvip":false,"replies":[{"id":"51109","content":"我们可以读取大部分读写中间件实现源码，可以发现ThreadLocal使用的最为频繁，通常是通过ThreadLocal来获取当前线程的操作类型来实现读写数据源的切换。<br><br>在使用完之后实现remove操作，可以规避风险。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568534088,"ip_address":"","comment_id":132804,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5863210325","product_id":100028001,"comment_content":"我们的项目中ThreadLocal使用的蛮多的，使用原因是因为接口调用链长不想修改方法生命，但有些参数要透传就用ThreadLocal来透传参数。<br>老师能否介绍一下题ThreadLocal的最佳实践？什么场景下会使用？有什么坑需要填？怎么规避风险？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467127,"discussion_content":"我们可以读取大部分读写中间件实现源码，可以发现ThreadLocal使用的最为频繁，通常是通过ThreadLocal来获取当前线程的操作类型来实现读写数据源的切换。\n\n在使用完之后实现remove操作，可以规避风险。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568534088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763335,"avatar":"","nickname":"Geek_373e87","note":"","ucode":"9DBAD30E4ED24A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275946,"discussion_content":"一般用来维护全局上下文，也可以用来维护traceId等。需要注意的就是内存泄露问题，在finally中remove下，还有TL对象要设置为不可变对象，因为它是key。如果引用变了，就没法找到原来的value了。在线程池使用时一定要remove","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590772996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1061786,"avatar":"https://static001.geekbang.org/account/avatar/00/10/33/9a/a323b2f1.jpg","nickname":"悠悠小竹子","note":"","ucode":"A5E6731D28EBF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224532,"discussion_content":"使用threadlock传递参数本身就是坑，维护火葬场啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586313658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132560,"user_name":"行则将至","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","comment_is_top":false,"comment_ctime":1568166001,"is_pvip":false,"replies":[{"id":"50988","content":"升级版本就好了，现在基本都是基于1.8版本了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568423330,"ip_address":"","comment_id":132560,"utype":1}],"discussion_count":2,"race_medal":1,"score":"5863133297","product_id":100028001,"comment_content":"老师，jdk1.6的substring的内存泄漏问题。除了升级jdk版本，您有没有其他的办法。我在网上搜了一下，没有看到啥好办法","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467008,"discussion_content":"升级版本就好了，现在基本都是基于1.8版本了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568423330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2243285,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOD0m6ibmDGTRmfMCW2oNTEGpibMkIRLFibzhTT5uHr0RFIFsCmW8zFsw2N3Pl7bxDZs8RQS4pr6ibhg/132","nickname":"aaa","note":"","ucode":"BE2FDB7D73122D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361608,"discussion_content":"加一个空字符串。利用字符串拼接技术，会创建一个新对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616718218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116168,"user_name":"Mq","can_delete":false,"product_type":"c1","uid":1178359,"ip_address":"","ucode":"041F572AFAB275","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/f7/91ac44c5.jpg","comment_is_top":false,"comment_ctime":1563796755,"is_pvip":false,"replies":[{"id":"43118","content":"如果线程还存活，此时get是能获取到的，因为还存在强引用。如果线程生命周期已经结束，则ThreadLocal的线程本地变量将会失去引用，我们知道ThreadLocal是成员变量，如果key值没有设置为弱引用，则结束生命周期的线程变量依然会存在ThreadLocal中。<br>所以，当线程生命周期结束，ThreadLocal的key又为了弱引用，key值就会在垃圾回收期被回收掉。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564118811,"ip_address":"","comment_id":116168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858764051","product_id":100028001,"comment_content":"老师threadlocal的entry不回收是因为value吗，另外我不理解jvm怎么知道我这次gc的时候key就可以回收，会不会出现我多次get的时候有一次就取不到了","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459420,"discussion_content":"如果线程还存活，此时get是能获取到的，因为还存在强引用。如果线程生命周期已经结束，则ThreadLocal的线程本地变量将会失去引用，我们知道ThreadLocal是成员变量，如果key值没有设置为弱引用，则结束生命周期的线程变量依然会存在ThreadLocal中。\n所以，当线程生命周期结束，ThreadLocal的key又为了弱引用，key值就会在垃圾回收期被回收掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564118811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115854,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1563758772,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5858726068","product_id":100028001,"comment_content":"超哥，有问题请教下：<br>1）曾经被问到一个问题，就是java多线程分配内存的时候是如何控制并发冲突的那？<br>2）能不能结合代码把java内存创建的过程讲一次，比如成员变量的引用是在哪里分配的（我理解是堆上），堆上还是栈上，临时变量那，通过这种整体的讲解会对我们印象比较深刻。","like_count":1,"discussions":[{"author":{"id":1763335,"avatar":"","nickname":"Geek_373e87","note":"","ucode":"9DBAD30E4ED24A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275944,"discussion_content":"TLAB和CAS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590772295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099053,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","nickname":"GaGi","note":"","ucode":"CC8D22E1DD8CA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256426,"discussion_content":"第一个问题，是使用TLAB预分配堆内存来解决","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588479321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213385,"user_name":"ty_young","can_delete":false,"product_type":"c1","uid":1284337,"ip_address":"","ucode":"EB1D5DB0AE7B33","user_header":"","comment_is_top":false,"comment_ctime":1588400257,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588400257","product_id":100028001,"comment_content":"老师您好，card table只是老年代才维护的吧，那G1垃圾收集器的RSet也是只维护老年代的引用么(老年代引用年轻代和老年代引用老年代)","like_count":0,"discussions":[{"author":{"id":1763335,"avatar":"","nickname":"Geek_373e87","note":"","ucode":"9DBAD30E4ED24A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275945,"discussion_content":"不，cms的只是年轻代维护的。首先要理解为啥要维护卡表。是为了解决跨代引用问题，如果年轻代引用了老年代对象，在可达性分析的时候就要遍历全部老年代，才能知道，所以在年轻代维护了卡表，指向一个老年代的内存地址，只需要遍历一点空间就行了。而老年代引用了年轻代对象是不太可能的，年轻代被引用对象一定会晋升到老年代。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590772696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212649,"user_name":"ty_young","can_delete":false,"product_type":"c1","uid":1284337,"ip_address":"","ucode":"EB1D5DB0AE7B33","user_header":"","comment_is_top":false,"comment_ctime":1588169804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588169804","product_id":100028001,"comment_content":"求老师把cms，g1讲得详细点，求加餐","like_count":0},{"had_liked":false,"id":174002,"user_name":"asura","can_delete":false,"product_type":"c1","uid":1105148,"ip_address":"","ucode":"4AF66C19B4AE65","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/fc/5c3ad841.jpg","comment_is_top":false,"comment_ctime":1579863448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579863448","product_id":100028001,"comment_content":"每次看完课程，课后评论也会看完。大家看问题的角度不同，思考纬度也不同，着实学到了很多 👍。感谢老师的热情回答！","like_count":0},{"had_liked":false,"id":145079,"user_name":"ty_young","can_delete":false,"product_type":"c1","uid":1284337,"ip_address":"","ucode":"EB1D5DB0AE7B33","user_header":"","comment_is_top":false,"comment_ctime":1572182285,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572182285","product_id":100028001,"comment_content":"真的受益颇多，谢谢老师","like_count":0}]}