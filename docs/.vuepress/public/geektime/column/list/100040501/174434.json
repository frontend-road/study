{"id":174434,"title":"05 | 容器汇编 II：需要函数对象的容器","content":"<p>你好，我是吴咏炜。</p><p>上一讲我们学习了 C++ 的序列容器和两个容器适配器，今天我们继续讲完剩下的标准容器（<span class=\"orange\">[1]</span>）。</p><h2>函数对象及其特化</h2><p>在讲容器之前，我们需要首先来讨论一下两个重要的函数对象，<code>less</code> 和 <code>hash</code>。</p><p>我们先看一下 <code>less</code>，小于关系。在标准库里，通用的 <code>less</code> 大致是这样定义的：</p><pre><code class=\"language-c++\">template &lt;class T&gt;\nstruct less\n  : binary_function&lt;T, T, bool&gt; {\n  bool operator()(const T&amp; x,\n                  const T&amp; y) const\n  {\n    return x &lt; y;\n  }\n};\n</code></pre><p>也就是说，<code>less</code> 是一个函数对象，并且是个二元函数，执行对任意类型的值的比较，返回布尔类型。作为函数对象，它定义了函数调用运算符（<code>operator()</code>），并且缺省行为是对指定类型的对象进行 <code>&lt;</code> 的比较操作。</p><p>有点平淡无奇，是吧？原因是因为这个缺省实现在大部分情况下已经够用，我们不太需要去碰它。在需要大小比较的场合，C++ 通常默认会使用 <code>less</code>，包括我们今天会讲到的若干容器和排序算法 <code>sort</code>。如果我们需要产生相反的顺序的话，则可以使用 <code>greater</code>，大于关系。</p><p>计算哈希值的函数对象 <code>hash</code> 就不一样了。它的目的是把一个某种类型的值转换成一个无符号整数哈希值，类型为 <code>size_t</code>。它没有一个可用的默认实现。对于常用的类型，系统提供了需要的特化 <span class=\"orange\">[2]</span>，类似于：</p><!-- [[[read_end]]] --><pre><code class=\"language-c++\">template &lt;class T&gt; struct hash;\n\ntemplate &lt;&gt;\nstruct hash&lt;int&gt;\n  : public unary_function&lt;int, size_t&gt; {\n  size_t operator()(int v) const\n    noexcept\n  {\n    return static_cast&lt;size_t&gt;(v);\n  }\n};\n</code></pre><p>这当然是一个极其简单的例子。更复杂的类型，如指针或者 <code>string</code> 的特化，都会更复杂。要点是，对于每个类，类的作者都可以提供 <code>hash</code> 的特化，使得对于不同的对象值，函数调用运算符都能得到尽可能均匀分布的不同数值。</p><p>我们用下面这个例子来加深一下理解：</p><pre><code class=\"language-c++\">#include &lt;algorithm&gt;   // std::sort\n#include &lt;functional&gt;  // std::less/greater/hash\n#include &lt;iostream&gt;    // std::cout/endl\n#include &lt;string&gt;      // std::string\n#include &lt;vector&gt;      // std::vector\n#include \"output_container.h\"\n\nusing namespace std;\n\nint main()\n{\n  // 初始数组\n  vector&lt;int&gt; v{13, 6, 4, 11, 29};\n  cout &lt;&lt; v &lt;&lt; endl;\n\n  // 从小到大排序\n  sort(v.begin(), v.end());\n  cout &lt;&lt; v &lt;&lt; endl;\n\n  // 从大到小排序\n  sort(v.begin(), v.end(),\n       greater&lt;int&gt;());\n  cout &lt;&lt; v &lt;&lt; endl;\n\n  cout &lt;&lt; hex;\n\n  auto hp = hash&lt;int*&gt;();\n  cout &lt;&lt; \"hash(nullptr)  = \"\n       &lt;&lt; hp(nullptr) &lt;&lt; endl;\n  cout &lt;&lt; \"hash(v.data()) = \"\n       &lt;&lt; hp(v.data()) &lt;&lt; endl;\n  cout &lt;&lt; \"v.data()       = \"\n       &lt;&lt; static_cast&lt;void*&gt;(v.data())\n       &lt;&lt; endl;\n\n  auto hs = hash&lt;string&gt;();\n  cout &lt;&lt; \"hash(\\\"hello\\\")  = \"\n       &lt;&lt; hs(string(\"hello\")) &lt;&lt; endl;\n  cout &lt;&lt; \"hash(\\\"hellp\\\")  = \"\n       &lt;&lt; hs(string(\"hellp\")) &lt;&lt; endl;\n}\n</code></pre><p>在 MSVC 下的某次运行结果如下所示：</p><blockquote>\n<p><code>{ 13, 6, 4, 11, 29 }</code><br>\n<code>{ 4, 6, 11, 13, 29 }</code><br>\n<code>{ 29, 13, 11, 6, 4 }</code><br>\n<code>hash(nullptr)  = a8c7f832281a39c5</code><br>\n<code>hash(v.data()) = 7a0bdfd7df0923d2</code><br>\n<code>v.data()       = 000001EFFB10EAE0</code><br>\n<code>hash(\"hello\")  = a430d84680aabd0b</code><br>\n<code>hash(\"hellp\")  = a430e54680aad322</code></p>\n</blockquote><p>可以看到，在这个实现里，空指针的哈希值是一个非零的数值，指针的哈希值也和指针的数值不一样。要注意不同的实现处理的方式会不一样。事实上，我的测试结果是 GCC、Clang 和 MSVC 对常见类型的哈希方式都各有不同。</p><p>在上面的例子里，我们同时可以看到，这两个函数对象的值不重要。我们甚至可以认为，每个 <code>less</code>（或 <code>greater</code> 或 <code>hash</code>）对象都是等价的。关键在于其类型。以 <code>sort</code> 为例，第三个参数的类型确定了其排序行为。</p><p>对于容器也是如此，函数对象的类型确定了容器的行为。</p><h2>priority_queue</h2><p><code>priority_queue</code> 也是一个容器适配器。上一讲没有和其他容器适配器一起讲的原因就在于它用到了比较函数对象（默认是 <code>less</code>）。它和 <code>stack</code> 相似，支持 <code>push</code>、<code>pop</code>、<code>top</code> 等有限的操作，但容器内的顺序既不是后进先出，也不是先进先出，而是（部分）排序的结果。在使用缺省的 <code>less</code> 作为其 <code>Compare</code> 模板参数时，最大的数值会出现在容器的“顶部”。如果需要最小的数值出现在容器顶部，则可以传递 <code>greater</code> 作为其 <code>Compare</code> 模板参数。</p><p>下面的代码可以演示其功能：</p><pre><code class=\"language-c++\">#include &lt;functional&gt;  // std::greater\n#include &lt;iostream&gt;    // std::cout/endl\n#include &lt;memory&gt;      // std::pair\n#include &lt;queue&gt;       // std::priority_queue\n#include &lt;vector&gt;      // std::vector\n#include \"output_container.h\"\n\nusing namespace std;\n\nint main()\n{\n  priority_queue&lt;\n    pair&lt;int, int&gt;,\n    vector&lt;pair&lt;int, int&gt;&gt;,\n    greater&lt;pair&lt;int, int&gt;&gt;&gt;\n    q;\n  q.push({1, 1});\n  q.push({2, 2});\n  q.push({0, 3});\n  q.push({9, 4});\n  while (!q.empty()) {\n    cout &lt;&lt; q.top() &lt;&lt; endl;\n    q.pop();\n  }\n}\n</code></pre><p>输出为：</p><blockquote>\n<p><code>(0, 3)</code><br>\n<code>(1, 1)</code><br>\n<code>(2, 2)</code><br>\n<code>(9, 4)</code></p>\n</blockquote><h2>关联容器</h2><p>关联容器有 <code>set</code>（集合）、<code>map</code>（映射）、<code>multiset</code>（多重集）和 <code>multimap</code>（多重映射）。跳出 C++ 的语境，<code>map</code>（映射）的更常见的名字是关联数组和字典 <span class=\"orange\">[3]</span>，而在 JSON 里直接被称为对象（object）。在 C++ 外这些容器常常是无序的；在 C++ 里关联容器则被认为是有序的。</p><p>我们可以通过以下的 xeus-cling 交互来体会一下。</p><pre><code class=\"language-c++\">#include &lt;functional&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\nusing namespace std;\n</code></pre><pre><code class=\"language-c++\">set&lt;int&gt; s{1, 1, 1, 2, 3, 4};\n</code></pre><pre><code class=\"language-c++\">s\n</code></pre><blockquote>\n<p><code>{ 1, 2, 3, 4 }</code></p>\n</blockquote><pre><code class=\"language-c++\">multiset&lt;int, greater&lt;int&gt;&gt; ms{1, 1, 1, 2, 3, 4};\n</code></pre><pre><code class=\"language-c++\">ms\n</code></pre><blockquote>\n<p><code>{ 4, 3, 2, 1, 1, 1 }</code></p>\n</blockquote><pre><code class=\"language-c++\">map&lt;string, int&gt; mp{\n  {\"one\", 1},\n  {\"two\", 2},\n  {\"three\", 3},\n  {\"four\", 4}\n};\n</code></pre><pre><code class=\"language-c++\">mp\n</code></pre><blockquote>\n<p><code>{ \"four\" =&gt; 4, \"one\" =&gt; 1, \"three\" =&gt; 3, \"two\" =&gt; 2 }</code></p>\n</blockquote><pre><code class=\"language-c++\">mp.insert({\"four\", 4});\n</code></pre><pre><code class=\"language-c++\">mp\n</code></pre><blockquote>\n<p><code>{ \"four\" =&gt; 4, \"one\" =&gt; 1, \"three\" =&gt; 3, \"two\" =&gt; 2 }</code></p>\n</blockquote><pre><code class=\"language-c++\">mp.find(\"four\") == mp.end()\n</code></pre><blockquote>\n<p><code>false</code></p>\n</blockquote><pre><code class=\"language-c++\">mp.find(\"five\") == mp.end()\n</code></pre><blockquote>\n<p><code>(bool) true</code></p>\n</blockquote><pre><code class=\"language-c++\">mp[\"five\"] = 5;\n</code></pre><pre><code class=\"language-c++\">mp\n</code></pre><blockquote>\n<p><code>{ \"five\" =&gt; 5, \"four\" =&gt; 4, \"one\" =&gt; 1, \"three\" =&gt; 3, \"two\" =&gt; 2 }</code></p>\n</blockquote><pre><code class=\"language-c++\">multimap&lt;string, int&gt; mmp{\n  {\"one\", 1},\n  {\"two\", 2},\n  {\"three\", 3},\n  {\"four\", 4}\n};\n</code></pre><pre><code class=\"language-c++\">mmp\n</code></pre><blockquote>\n<p><code>{ \"four\" =&gt; 4, \"one\" =&gt; 1, \"three\" =&gt; 3, \"two\" =&gt; 2 }</code></p>\n</blockquote><pre><code class=\"language-c++\">mmp.insert({\"four\", -4});\n</code></pre><pre><code class=\"language-c++\">mmp\n</code></pre><blockquote>\n<p><code>{ \"four\" =&gt; 4, \"four\" =&gt; -4, \"one\" =&gt; 1, \"three\" =&gt; 3, \"two\" =&gt; 2 }</code></p>\n</blockquote><p>可以看到，关联容器是一种有序的容器。名字带“multi”的允许键重复，不带的不允许键重复。<code>set</code> 和 <code>multiset</code> 只能用来存放键，而 <code>map</code> 和 <code>multimap</code> 则存放一个个键值对。</p><p>与序列容器相比，关联容器没有前、后的概念及相关的成员函数，但同样提供 <code>insert</code>、<code>emplace</code> 等成员函数。此外，关联容器都有 <code>find</code>、<code>lower_bound</code>、<code>upper_bound</code> 等查找函数，结果是一个迭代器：</p><ul>\n<li><code>find(k)</code> 可以找到任何一个等价于查找键 k 的元素（<code>!(x &lt; k || k &lt; x)</code>）</li>\n<li><code>lower_bound(k)</code> 找到第一个不小于查找键 k 的元素（<code>!(x &lt; k)</code>）</li>\n<li><code>upper_bound(k)</code> 找到第一个大于查找键 k 的元素（<code>k &lt; x</code>）</li>\n</ul><pre><code class=\"language-c++\">mp.find(\"four\")-&gt;second\n</code></pre><blockquote>\n<p><code>4</code></p>\n</blockquote><pre><code class=\"language-c++\">mp.lower_bound(\"four\")-&gt;second\n</code></pre><blockquote>\n<p><code>4</code></p>\n</blockquote><pre><code class=\"language-c++\">(--mp.upper_bound(\"four\"))-&gt;second\n</code></pre><blockquote>\n<p><code>4</code></p>\n</blockquote><pre><code class=\"language-c++\">mmp.lower_bound(\"four\")-&gt;second\n</code></pre><blockquote>\n<p><code>4</code></p>\n</blockquote><pre><code class=\"language-c++\">(--mmp.upper_bound(\"four\"))-&gt;second\n</code></pre><blockquote>\n<p><code>-4</code></p>\n</blockquote><p>如果你需要在 <code>multimap</code> 里精确查找满足某个键的区间的话，建议使用 <code>equal_range</code>，可以一次性取得上下界（半开半闭）。如下所示：</p><pre><code class=\"language-c++\">#include &lt;tuple&gt;\nmultimap&lt;string, int&gt;::iterator\n  lower, upper;\nstd::tie(lower, upper) =\n  mmp.equal_range(\"four\");\n</code></pre><pre><code class=\"language-c++\">(lower != upper)  // 检测区间非空\n</code></pre><blockquote>\n<p><code>true</code></p>\n</blockquote><pre><code class=\"language-c++\">lower-&gt;second\n</code></pre><blockquote>\n<p><code>4</code></p>\n</blockquote><pre><code class=\"language-c++\">(--upper)-&gt;second\n</code></pre><blockquote>\n<p><code>-4</code></p>\n</blockquote><p>如果在声明关联容器时没有提供比较类型的参数，缺省使用 <code>less</code> 来进行排序。如果键的类型提供了比较算符 <code>&lt;</code> 的重载，我们不需要做任何额外的工作。否则，我们就需要对键类型进行 <code>less</code> 的特化，或者提供一个其他的函数对象类型。</p><p>对于自定义类型，我推荐尽量使用标准的 <code>less</code> 实现，通过重载 <code>&lt;</code>（及其他标准比较运算符）对该类型的对象进行排序。存储在关联容器中的键一般应满足严格弱序关系（strict weak ordering；<span class=\"orange\">[4]</span>），即：</p><ul>\n<li>对于任何该类型的对象 x：<code>!(x &lt; x)</code>（非自反）</li>\n<li>对于任何该类型的对象 x 和 y：如果 <code>x &lt; y</code>，则 <code>!(y &lt; x)</code>（非对称）</li>\n<li>对于任何该类型的对象 x、y 和 z：如果 <code>x &lt; y</code> 并且 <code>y &lt; z</code>，则 <code>x &lt; z</code>（传递性）</li>\n<li>对于任何该类型的对象 x、y 和 z：如果 x 和 y 不可比（<code>!(x &lt; y)</code> 并且 <code>!(y &lt; x)</code>）并且 y 和 z 不可比，则 x 和 z 不可比（不可比的传递性）</li>\n</ul><p>大部分情况下，类型是可以满足这些条件的，不过：</p><ul>\n<li>如果类型没有一般意义上的大小关系（如复数），我们一定要别扭地定义一个大小关系吗？</li>\n<li>通过比较来进行查找、插入和删除，复杂度为对数 O(log(n))，有没有达到更好的性能的方法？</li>\n</ul><h2>无序关联容器</h2><p>从 C++11 开始，每一个关联容器都有一个对应的无序关联容器，它们是：</p><ul>\n<li><code>unordered_set</code></li>\n<li><code>unordered_map</code></li>\n<li><code>unordered_multiset</code></li>\n<li><code>unordered_multimap</code></li>\n</ul><p>这些容器和关联容器非常相似，主要的区别就在于它们是“无序”的。这些容器不要求提供一个排序的函数对象，而要求一个可以计算哈希值的函数对象。你当然可以在声明容器对象时手动提供这样一个函数对象类型，但更常见的情况是，我们使用标准的 <code>hash</code> 函数对象及其特化。</p><p>下面是一个示例（这次我们暂不使用 xeus-cling，因为它在输出复数时有限制，不能显示其数值）：</p><pre><code class=\"language-c++\">#include &lt;complex&gt;        // std::complex\n#include &lt;iostream&gt;       // std::cout/endl\n#include &lt;unordered_map&gt;  // std::unordered_map\n#include &lt;unordered_set&gt;  // std::unordered_set\n#include \"output_container.h\"\n\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nstruct complex_hash {\n  size_t\n  operator()(const complex&lt;T&gt;&amp; v) const\n    noexcept\n  {\n    hash&lt;T&gt; h;\n    return h(v.real()) + h(v.imag());\n  }\n};\n\nint main()\n{\n  unordered_set&lt;int&gt; s{\n    1, 1, 2, 3, 5, 8, 13, 21\n  };\n  cout &lt;&lt; s &lt;&lt; endl;\n\n  unordered_map&lt;\n    complex&lt;double&gt;, double,\n    complex_hash&lt;double&gt;&gt;\n    umc{{{1.0, 1.0}, 1.4142},\n        {{3.0, 4.0}, 5.0}};\n  cout &lt;&lt; umc &lt;&lt; endl;\n}\n</code></pre><p>输出可能是（顺序不能保证）：</p><blockquote>\n<p><code>{ 21, 5, 8, 3, 13, 2, 1 }</code><br>\n<code>{ (3,4) =&gt; 5, (1,1) =&gt; 1.4142 }</code></p>\n</blockquote><p>请注意我们在 <code>std</code> 名空间中添加了特化，这是少数用户可以向 <code>std</code> 名空间添加内容的情况之一。正常情况下，向 <code>std</code> 名空间添加声明或定义是禁止的，属于未定义行为。</p><p>从实际的工程角度，无序关联容器的主要优点在于其性能。关联容器和 <code>priority_queue</code> 的插入和删除操作，以及关联容器的查找操作，其复杂度都是 O(log(n))，而无序关联容器的实现使用哈希表 <span class=\"orange\">[5]</span>，可以达到平均 O(1)！但这取决于我们是否使用了一个好的哈希函数：在哈希函数选择不当的情况下，无序关联容器的插入、删除、查找性能可能成为最差情况的 O(n)，那就比关联容器糟糕得多了。</p><h2>array</h2><p>我们讲的最后一个容器是 C 数组的替代品。C 数组在 C++ 里继续存在，主要是为了保留和 C 的向后兼容性。C 数组本身和 C++ 的容器相差是非常大的：</p><ul>\n<li>C 数组没有 <code>begin</code> 和 <code>end</code> 成员函数（虽然可以使用全局的 <code>begin</code> 和 <code>end</code> 函数）</li>\n<li>C 数组没有 <code>size</code> 成员函数（得用一些模板技巧来获取其长度）</li>\n<li>C 数组作为参数有退化行为，传递给另外一个函数后那个函数不再能获得 C 数组的长度和结束位置</li>\n</ul><p>在 C 的年代，大家有时候会定义这样一个宏来获得数组的长度：</p><pre><code class=\"language-c++\">#define ARRAY_LEN(a) \\\n  (sizeof(a) / sizeof((a)[0]))\n</code></pre><p>如果在一个函数内部对数组参数使用这个宏，结果肯定是错的。现在 GCC 会友好地发出警告：</p><pre><code class=\"language-c++\">void test(int a[8])\n{\n  cout &lt;&lt; ARRAY_LEN(a) &lt;&lt; endl;\n}\n</code></pre><blockquote>\n<p>warning: sizeof on array function parameter will return size of ‘int *’ instead of ‘int [8]’ [-Wsizeof-array-argument]<br>\n&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; ARRAY_LEN(a) &lt;&lt; endl;</p>\n</blockquote><p>C++17 直接提供了一个 <code>size</code> 方法，可以用于提供数组长度，并且在数组退化成指针的情况下会直接失败：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;  // std::cout/endl\n#include &lt;iterator&gt;  // std::size\n\nvoid test(int arr[])\n{\n  // 不能编译\n  // std::cout &lt;&lt; std::size(arr)\n  //           &lt;&lt; std::endl;\n}\n\nint main()\n{\n  int arr[] = {1, 2, 3, 4, 5};\n  std::cout &lt;&lt; \"The array length is \"\n            &lt;&lt; std::size(arr)\n            &lt;&lt; std::endl;\n  test(arr);\n}\n</code></pre><p>此外，C 数组也没有良好的复制行为。你无法用 C 数组作为 <code>map</code> 或 <code>unordered_map</code> 的键类型。下面的代码演示了失败行为：</p><pre><code class=\"language-c++\">#include &lt;map&gt;  // std::map\n\ntypedef char mykey_t[8];\n\nint main()\n{\n  std::map&lt;mykey_t, int&gt; mp;\n  mykey_t mykey{\"hello\"};\n  mp[mykey] = 5;\n  // 轰，大段的编译错误\n}\n</code></pre><p>如果不用 C 数组的话，我们该用什么来替代呢？</p><p>我们有三个可以考虑的选项：</p><ul>\n<li>如果数组较大的话，应该考虑 <code>vector</code>。<code>vector</code> 有最大的灵活性和不错的性能。</li>\n<li>对于字符串数组，当然应该考虑 <code>string</code>。</li>\n<li>如果数组大小固定（C 的数组在 C++ 里本来就是大小固定的）并且较小的话，应该考虑 <code>array</code>。<code>array</code> 保留了 C 数组在栈上分配的特点，同时，提供了 <code>begin</code>、<code>end</code>、<code>size</code> 等通用成员函数。</li>\n</ul><p><code>array</code> 可以避免 C 数组的种种怪异行径。上面的失败代码，如果使用 <code>array</code> 的话，稍作改动就可以通过编译：</p><pre><code class=\"language-c++\">#include &lt;array&gt;     // std::array\n#include &lt;iostream&gt;  // std::cout/endl\n#include &lt;map&gt;       // std::map\n#include \"output_container.h\"\n\ntypedef std::array&lt;char, 8&gt; mykey_t;\n\nint main()\n{\n  std::map&lt;mykey_t, int&gt; mp;\n  mykey_t mykey{\"hello\"};\n  mp[mykey] = 5;  // OK\n  std::cout &lt;&lt; mp &lt;&lt; std::endl;\n}\n</code></pre><p>输出则是意料之中的：</p><blockquote>\n<p><code>{ hello =&gt; 5 }</code></p>\n</blockquote><h2>内容小结</h2><p>本讲介绍了 C++ 的两个常用的函数对象，<code>less</code> 和 <code>hash</code>；然后介绍了用到这两个函数对象的容器适配器、关联容器和无序关联容器；最后，通过例子展示了为什么我们应当避免 C 数组而考虑使用 <code>array</code>。通过这两讲，我们已经完整地了解了 C++ 提供的标准容器。</p><h2>课后思考</h2><p>请思考一下：</p><ol>\n<li>为什么大部分容器都提供了 <code>begin</code>、<code>end</code> 等方法？</li>\n<li>为什么容器没有继承一个公用的基类？</li>\n</ol><p>欢迎留言和我交流你的看法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “Containers library”. <a href=\"https://en.cppreference.com/w/cpp/container\">https://en.cppreference.com/w/cpp/container</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “容器库”. <a href=\"https://zh.cppreference.com/w/cpp/container\">https://zh.cppreference.com/w/cpp/container</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “Explicit (full) template specialization”. <a href=\"https://en.cppreference.com/w/cpp/language/template_specialization\">https://en.cppreference.com/w/cpp/language/template_specialization</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “显式（全）模板特化”. <a href=\"https://zh.cppreference.com/w/cpp/language/template_specialization\">https://zh.cppreference.com/w/cpp/language/template_specialization</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “Associative array”. <a href=\"https://en.wikipedia.org/wiki/Associative_array\">https://en.wikipedia.org/wiki/Associative_array</a> </span></p><p><span class=\"reference\">[3a] 维基百科, “关联数组”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84\">https://zh.wikipedia.org/zh-cn/关联数组</a> </span></p><p><span class=\"reference\">[4] Wikipedia, “Weak ordering”. <a href=\"https://en.wikipedia.org/wiki/Weak_ordering\">https://en.wikipedia.org/wiki/Weak_ordering</a> </span></p><p><span class=\"reference\">[5] Wikipedia, “Hash table”. <a href=\"https://en.wikipedia.org/wiki/Hash_table\">https://en.wikipedia.org/wiki/Hash_table</a> </span></p><p><span class=\"reference\">[5a] 维基百科, “哈希表”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%93%88%E5%B8%8C%E8%A1%A8\">https://zh.wikipedia.org/zh-cn/哈希表</a> </span></p>","neighbors":{"left":{"article_title":"04 | 容器汇编 I：比较简单的若干容器","id":173167},"right":{"article_title":"06 | 异常：用还是不用，这是个问题","id":175579}},"comments":[{"had_liked":false,"id":159553,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1575682239,"is_pvip":false,"replies":[{"id":60975,"content":"基本正确。\n\n2 实际上还是因为这儿继承真的没啥用。有了泛型，继承基本是种浪费。而且，继承用基类的指针或引用才有用，而C++里的容器类一般都是当值类型来用的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575687534,"ip_address":"","comment_id":159553,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1. 首先是为了遍历容器方便，其次为了保证std接口的一致性\n2. 我认为是没有必要的，因为，如果用类的继承一般会产生虚函数，这也就导致多存储一个虚函数表，在内存上产生了不必要的浪费。","like_count":25},{"had_liked":false,"id":160212,"user_name":"皓首不倦","can_delete":false,"product_type":"c1","uid":1144626,"ip_address":"","ucode":"FA7D282DD40D83","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","comment_is_top":false,"comment_ctime":1575892501,"is_pvip":false,"replies":[{"id":61134,"content":"一，正确。\n\n二，问题还在于C++的值语义。如果你用一个 AbstractMap来访问map和unordered_map，你只能用引用或指针，并不方便。而且，map和unordered_map的模板参数还不一样，通用的话反而成了阉割版……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575896803,"ip_address":"","comment_id":160212,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师您好 \n第一个问题个人觉得提供出头尾迭代器目的主要是提供给STL算法库用，STL算法库实现是只认迭代器的，这样的设计可以避免算法实现和具体容器类型的强耦合\n第二个问题个人觉得是因为各种容器API和功能上差异比价大，难以做一层比较通用的抽象，但是像map和unordered_map这样功能比较相近的容器我觉的还是可以做一层抽象的，像Java中TreeMap和HashMap就同时实现了Map接口，做了一层抽象，其实我也一直没有弄懂C++为什么没有向Java一样对功能相近的容器做一层接口的抽象层，老师能帮我解答下吗？\n","like_count":11,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477095,"discussion_content":"基本正确。\n\n2 实际上还是因为这儿继承真的没啥用。有了泛型，继承基本是种浪费。而且，继承用基类的指针或引用才有用，而C++里的容器类一般都是当值类型来用的。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575687534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1609948,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/dc/44ce2f23.jpg","nickname":"氕氘氚","note":"","ucode":"6B5477BF23AA4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":578819,"discussion_content":"怎么理解：有了泛型，继承基本是种浪费。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657027837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":477095,"ip_address":"","group_id":0},"score":578819,"extra":""}]},{"author":{"id":1219496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","nickname":"geraltlaush","note":"","ucode":"B9BBD1EFAAE5A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162111,"discussion_content":"设计模式尽量使用组合，不使用继承，Go语言就很好地做到了，数据成员和函数操作分离，直接在语法层面直观的展示出来，C++的设计模式里经常需基类还带一些数据成员给实现的子类继承，在Go语言里面直接就没有继承，想用公共成员，单独定义一个类，把这些需要继承的公共的成员放进去，实现接口的类直接包括这个类成员就可以了，使用的时候看来还像继承一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580960157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159601,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1575701822,"is_pvip":true,"replies":[{"id":60992,"content":"是，也必须满足。标准里明确这么要求了。\n\n如果你传了 less_equal 这样的条件，结果可能是正确，也可能是错误，也可能是程序崩溃。具体发生什么，取决于排序算法的实现。出了问题，就是调用者的锅，不是 sort 的 bug。\n\n以冒泡排序为例，我试了一下，如果是用检验有没有交换来决定是否退出排序，那么，在元素有重复的情况下使用 less_equal 来排序，会导致死循环。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575723525,"ip_address":"","comment_id":159601,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"既然关联容器的key需要满足strict weak ordering，那么sort的比较函数是不是也需要满足？比如sort(v.begin(), v.end(), less_equal&lt;int&gt;());是否可行？","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477296,"discussion_content":"一，正确。\n\n二，问题还在于C++的值语义。如果你用一个 AbstractMap来访问map和unordered_map，你只能用引用或指针，并不方便。而且，map和unordered_map的模板参数还不一样，通用的话反而成了阉割版……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575896803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144626,"avatar":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","nickname":"皓首不倦","note":"","ucode":"FA7D282DD40D83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77253,"discussion_content":"感谢老师回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575898127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160630,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1757384,"ip_address":"","ucode":"76BBA994C40F23","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL41RCmZy6An5SLXPmXU6ea5yvweBGPicedqQ0xjuaYp1PY1CSlUuNwgV3BNpbWzdJwXlWZAVicrtPg/132","comment_is_top":false,"comment_ctime":1575989753,"is_pvip":false,"replies":[{"id":61307,"content":"不会也不可以。这些容器适配器不提供遍历的迭代器就是不允许像你描述这样的任意访问。（迭代器就是广义指针。）","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576023210,"ip_address":"","comment_id":160630,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"想问一下，priority_queue这种，如果通过指针持有某个对象，然后传入比较函数，那么如果更新指针指向对象的值，priority_queue是否会更新？如果不会，有方法能够使它更新吗？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477115,"discussion_content":"是，也必须满足。标准里明确这么要求了。\n\n如果你传了 less_equal 这样的条件，结果可能是正确，也可能是错误，也可能是程序崩溃。具体发生什么，取决于排序算法的实现。出了问题，就是调用者的锅，不是 sort 的 bug。\n\n以冒泡排序为例，我试了一下，如果是用检验有没有交换来决定是否退出排序，那么，在元素有重复的情况下使用 less_equal 来排序，会导致死循环。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575723525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159796,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575792310,"is_pvip":false,"replies":[{"id":61036,"content":"不是。哈希是哈希，哈希可能有冲突的，相同哈希值也要看键是相同还是不同，来决定是覆盖还是加一项。去看一下数据结构里面的哈希。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575803697,"ip_address":"","comment_id":159796,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师你好，那为什么unodered_map会使用到operator==的呢？\n我感觉他不是应该把数据转到hash值，然后保存起来，也感觉没有比较的过程，哪个地方体现了==这个运算符呀？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477438,"discussion_content":"不会也不可以。这些容器适配器不提供遍历的迭代器就是不允许像你描述这样的任意访问。（迭代器就是广义指针。）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576023210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159394,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1575613801,"is_pvip":false,"replies":[{"id":60952,"content":"哈哈，是这样的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575632617,"ip_address":"","comment_id":159394,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1、begin、end是迭代器，主要用于对不同类型的容器提供统一的遍历容器的辅助\n\n2不同容器内存分配方式不同，实现不同，基类方法无法做到统一，非要用继承只能定义虚函数\n多用组合、少用继承（抖个机灵）","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477174,"discussion_content":"不是。哈希是哈希，哈希可能有冲突的，相同哈希值也要看键是相同还是不同，来决定是覆盖还是加一项。去看一下数据结构里面的哈希。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575803697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75992,"discussion_content":"OK，谢谢老师的指点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575803773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159312,"user_name":"李义盛","can_delete":false,"product_type":"c1","uid":1762459,"ip_address":"","ucode":"2C79848BCF545D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","comment_is_top":false,"comment_ctime":1575597866,"is_pvip":false,"replies":[{"id":60918,"content":"算是一个点。真要继承，不会更好用，因为容器的接口差异往往很小，这儿多一个，那儿少一个，要多少接口才能表达啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575610231,"ip_address":"","comment_id":159312,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"2.继承是强耦合。 继承导致关系混乱。","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477035,"discussion_content":"哈哈，是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575632617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159535,"user_name":"贾陆华","can_delete":false,"product_type":"c1","uid":1321408,"ip_address":"","ucode":"2722C422077EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","comment_is_top":false,"comment_ctime":1575673328,"is_pvip":false,"replies":[{"id":60971,"content":"1. 哈，还真是的。典型的拷贝粘贴错误……\n\n2. 想一想，C++ 里到处是半开半闭区间。右界一直是会超出有效范围的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575687083,"ip_address":"","comment_id":159535,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1. 看到一个注释笔误，是从大到小吧\n  &#47;&#47;  从小到大排序\n  sort(v.begin(), v.end(),\n       greater&lt;int&gt;());\n  cout &lt;&lt; v &lt;&lt; endl;\n\n2. map.lower_bound(k)默认代表的意思是找到第一个x，x不小于k，map.upper_bound(k)默认是找到第一个x，x大于k，为什么不是x小于k，upper_bound字面意思不是上界吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477090,"discussion_content":"1. 哈，还真是的。典型的拷贝粘贴错误……\n\n2. 想一想，C++ 里到处是半开半闭区间。右界一直是会超出有效范围的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575687083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321408,"avatar":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","nickname":"贾陆华","note":"","ucode":"2722C422077EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74802,"discussion_content":"明白了，其实是为了从找到的第一个值，可能会向结尾处遍历，这样才能结束遍历","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575688817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356197,"user_name":"爱笑的布谷鸟","can_delete":false,"product_type":"c1","uid":2842894,"ip_address":"上海","ucode":"75E9DDB93E5D24","user_header":"","comment_is_top":false,"comment_ctime":1662034339,"is_pvip":false,"replies":[{"id":129783,"content":"weak_ptr里你要获取指针都得去lock一下，你该怎么去算哈希值和判断相等？不能算哈希值和判断相等，你以后怎么做查询？","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1662370643,"ip_address":"上海","comment_id":356197,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问老师，为什么 weak_ptr 不能作为 unordered_x 容器的 key？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477090,"discussion_content":"1. 哈，还真是的。典型的拷贝粘贴错误……\n\n2. 想一想，C++ 里到处是半开半闭区间。右界一直是会超出有效范围的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575687083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321408,"avatar":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","nickname":"贾陆华","note":"","ucode":"2722C422077EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":74802,"discussion_content":"明白了，其实是为了从找到的第一个值，可能会向结尾处遍历，这样才能结束遍历","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575688817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220285,"user_name":"Geek_24c4df","can_delete":false,"product_type":"c1","uid":2010573,"ip_address":"","ucode":"BD66D0854804A7","user_header":"","comment_is_top":false,"comment_ctime":1590220702,"is_pvip":false,"replies":[{"id":81354,"content":"{1.0, 1.0} 可以用来构造一个复数（1 + i），{{1.0, 1.0}, 1.4142} 是 unordered_map 里的一项。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590247864,"ip_address":"","comment_id":220285,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看不懂下面用法\nunordered_map&lt;complex&lt;double&gt;, double&gt;    umc{{{1.0, 1.0}, 1.4142},   {{3.0, 4.0}, 5.0}};  为什么键里面还要套一层大括号数据\n","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496112,"discussion_content":"{1.0, 1.0} 可以用来构造一个复数（1 + i），{{1.0, 1.0}, 1.4142} 是 unordered_map 里的一项。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590247864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159553,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1575682239,"is_pvip":false,"replies":[{"id":60975,"content":"基本正确。\n\n2 实际上还是因为这儿继承真的没啥用。有了泛型，继承基本是种浪费。而且，继承用基类的指针或引用才有用，而C++里的容器类一般都是当值类型来用的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575687534,"ip_address":"","comment_id":159553,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1. 首先是为了遍历容器方便，其次为了保证std接口的一致性\n2. 我认为是没有必要的，因为，如果用类的继承一般会产生虚函数，这也就导致多存储一个虚函数表，在内存上产生了不必要的浪费。","like_count":25,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477095,"discussion_content":"基本正确。\n\n2 实际上还是因为这儿继承真的没啥用。有了泛型，继承基本是种浪费。而且，继承用基类的指针或引用才有用，而C++里的容器类一般都是当值类型来用的。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1575687534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1609948,"avatar":"https://static001.geekbang.org/account/avatar/00/18/90/dc/44ce2f23.jpg","nickname":"氕氘氚","note":"","ucode":"6B5477BF23AA4A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":578819,"discussion_content":"怎么理解：有了泛型，继承基本是种浪费。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657027837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":477095,"ip_address":"","group_id":0},"score":578819,"extra":""}]},{"author":{"id":1219496,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","nickname":"geraltlaush","note":"","ucode":"B9BBD1EFAAE5A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":162111,"discussion_content":"设计模式尽量使用组合，不使用继承，Go语言就很好地做到了，数据成员和函数操作分离，直接在语法层面直观的展示出来，C++的设计模式里经常需基类还带一些数据成员给实现的子类继承，在Go语言里面直接就没有继承，想用公共成员，单独定义一个类，把这些需要继承的公共的成员放进去，实现接口的类直接包括这个类成员就可以了，使用的时候看来还像继承一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580960157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160212,"user_name":"皓首不倦","can_delete":false,"product_type":"c1","uid":1144626,"ip_address":"","ucode":"FA7D282DD40D83","user_header":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","comment_is_top":false,"comment_ctime":1575892501,"is_pvip":false,"replies":[{"id":61134,"content":"一，正确。\n\n二，问题还在于C++的值语义。如果你用一个 AbstractMap来访问map和unordered_map，你只能用引用或指针，并不方便。而且，map和unordered_map的模板参数还不一样，通用的话反而成了阉割版……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575896803,"ip_address":"","comment_id":160212,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师您好 \n第一个问题个人觉得提供出头尾迭代器目的主要是提供给STL算法库用，STL算法库实现是只认迭代器的，这样的设计可以避免算法实现和具体容器类型的强耦合\n第二个问题个人觉得是因为各种容器API和功能上差异比价大，难以做一层比较通用的抽象，但是像map和unordered_map这样功能比较相近的容器我觉的还是可以做一层抽象的，像Java中TreeMap和HashMap就同时实现了Map接口，做了一层抽象，其实我也一直没有弄懂C++为什么没有向Java一样对功能相近的容器做一层接口的抽象层，老师能帮我解答下吗？\n","like_count":11,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477296,"discussion_content":"一，正确。\n\n二，问题还在于C++的值语义。如果你用一个 AbstractMap来访问map和unordered_map，你只能用引用或指针，并不方便。而且，map和unordered_map的模板参数还不一样，通用的话反而成了阉割版……","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575896803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144626,"avatar":"https://static001.geekbang.org/account/avatar/00/11/77/32/02416d97.jpg","nickname":"皓首不倦","note":"","ucode":"FA7D282DD40D83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77253,"discussion_content":"感谢老师回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575898127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159601,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1575701822,"is_pvip":true,"replies":[{"id":60992,"content":"是，也必须满足。标准里明确这么要求了。\n\n如果你传了 less_equal 这样的条件，结果可能是正确，也可能是错误，也可能是程序崩溃。具体发生什么，取决于排序算法的实现。出了问题，就是调用者的锅，不是 sort 的 bug。\n\n以冒泡排序为例，我试了一下，如果是用检验有没有交换来决定是否退出排序，那么，在元素有重复的情况下使用 less_equal 来排序，会导致死循环。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575723525,"ip_address":"","comment_id":159601,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"既然关联容器的key需要满足strict weak ordering，那么sort的比较函数是不是也需要满足？比如sort(v.begin(), v.end(), less_equal&lt;int&gt;());是否可行？","like_count":7,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477115,"discussion_content":"是，也必须满足。标准里明确这么要求了。\n\n如果你传了 less_equal 这样的条件，结果可能是正确，也可能是错误，也可能是程序崩溃。具体发生什么，取决于排序算法的实现。出了问题，就是调用者的锅，不是 sort 的 bug。\n\n以冒泡排序为例，我试了一下，如果是用检验有没有交换来决定是否退出排序，那么，在元素有重复的情况下使用 less_equal 来排序，会导致死循环。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575723525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160630,"user_name":"啦啦啦","can_delete":false,"product_type":"c1","uid":1757384,"ip_address":"","ucode":"76BBA994C40F23","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL41RCmZy6An5SLXPmXU6ea5yvweBGPicedqQ0xjuaYp1PY1CSlUuNwgV3BNpbWzdJwXlWZAVicrtPg/132","comment_is_top":false,"comment_ctime":1575989753,"is_pvip":false,"replies":[{"id":61307,"content":"不会也不可以。这些容器适配器不提供遍历的迭代器就是不允许像你描述这样的任意访问。（迭代器就是广义指针。）","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576023210,"ip_address":"","comment_id":160630,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"想问一下，priority_queue这种，如果通过指针持有某个对象，然后传入比较函数，那么如果更新指针指向对象的值，priority_queue是否会更新？如果不会，有方法能够使它更新吗？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477438,"discussion_content":"不会也不可以。这些容器适配器不提供遍历的迭代器就是不允许像你描述这样的任意访问。（迭代器就是广义指针。）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576023210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159796,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575792310,"is_pvip":false,"replies":[{"id":61036,"content":"不是。哈希是哈希，哈希可能有冲突的，相同哈希值也要看键是相同还是不同，来决定是覆盖还是加一项。去看一下数据结构里面的哈希。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575803697,"ip_address":"","comment_id":159796,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师你好，那为什么unodered_map会使用到operator==的呢？\n我感觉他不是应该把数据转到hash值，然后保存起来，也感觉没有比较的过程，哪个地方体现了==这个运算符呀？","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477174,"discussion_content":"不是。哈希是哈希，哈希可能有冲突的，相同哈希值也要看键是相同还是不同，来决定是覆盖还是加一项。去看一下数据结构里面的哈希。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575803697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75992,"discussion_content":"OK，谢谢老师的指点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575803773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159394,"user_name":"中年男子","can_delete":false,"product_type":"c1","uid":1039204,"ip_address":"","ucode":"027C86B3370150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/64/06d54a80.jpg","comment_is_top":false,"comment_ctime":1575613801,"is_pvip":false,"replies":[{"id":60952,"content":"哈哈，是这样的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575632617,"ip_address":"","comment_id":159394,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1、begin、end是迭代器，主要用于对不同类型的容器提供统一的遍历容器的辅助\n\n2不同容器内存分配方式不同，实现不同，基类方法无法做到统一，非要用继承只能定义虚函数\n多用组合、少用继承（抖个机灵）","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477035,"discussion_content":"哈哈，是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575632617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159312,"user_name":"李义盛","can_delete":false,"product_type":"c1","uid":1762459,"ip_address":"","ucode":"2C79848BCF545D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e4/9b/fcb4b8b7.jpg","comment_is_top":false,"comment_ctime":1575597866,"is_pvip":false,"replies":[{"id":60918,"content":"算是一个点。真要继承，不会更好用，因为容器的接口差异往往很小，这儿多一个，那儿少一个，要多少接口才能表达啊。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575610231,"ip_address":"","comment_id":159312,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"2.继承是强耦合。 继承导致关系混乱。","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477007,"discussion_content":"算是一个点。真要继承，不会更好用，因为容器的接口差异往往很小，这儿多一个，那儿少一个，要多少接口才能表达啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575610231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159535,"user_name":"贾陆华","can_delete":false,"product_type":"c1","uid":1321408,"ip_address":"","ucode":"2722C422077EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/29/c0/86fa3e92.jpg","comment_is_top":false,"comment_ctime":1575673328,"is_pvip":false,"replies":[{"id":60971,"content":"1. 哈，还真是的。典型的拷贝粘贴错误……\n\n2. 想一想，C++ 里到处是半开半闭区间。右界一直是会超出有效范围的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575687083,"ip_address":"","comment_id":159535,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"1. 看到一个注释笔误，是从大到小吧\n  &#47;&#47;  从小到大排序\n  sort(v.begin(), v.end(),\n       greater&lt;int&gt;());\n  cout &lt;&lt; v &lt;&lt; endl;\n\n2. map.lower_bound(k)默认代表的意思是找到第一个x，x不小于k，map.upper_bound(k)默认是找到第一个x，x大于k，为什么不是x小于k，upper_bound字面意思不是上界吗？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477007,"discussion_content":"算是一个点。真要继承，不会更好用，因为容器的接口差异往往很小，这儿多一个，那儿少一个，要多少接口才能表达啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575610231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356197,"user_name":"爱笑的布谷鸟","can_delete":false,"product_type":"c1","uid":2842894,"ip_address":"上海","ucode":"75E9DDB93E5D24","user_header":"","comment_is_top":false,"comment_ctime":1662034339,"is_pvip":false,"replies":[{"id":129783,"content":"weak_ptr里你要获取指针都得去lock一下，你该怎么去算哈希值和判断相等？不能算哈希值和判断相等，你以后怎么做查询？","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1662370643,"ip_address":"上海","comment_id":356197,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"请问老师，为什么 weak_ptr 不能作为 unordered_x 容器的 key？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586604,"discussion_content":"weak_ptr里你要获取指针都得去lock一下，你该怎么去算哈希值和判断相等？不能算哈希值和判断相等，你以后怎么做查询？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662370643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220285,"user_name":"Geek_24c4df","can_delete":false,"product_type":"c1","uid":2010573,"ip_address":"","ucode":"BD66D0854804A7","user_header":"","comment_is_top":false,"comment_ctime":1590220702,"is_pvip":false,"replies":[{"id":81354,"content":"{1.0, 1.0} 可以用来构造一个复数（1 + i），{{1.0, 1.0}, 1.4142} 是 unordered_map 里的一项。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590247864,"ip_address":"","comment_id":220285,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看不懂下面用法\nunordered_map&lt;complex&lt;double&gt;, double&gt;    umc{{{1.0, 1.0}, 1.4142},   {{3.0, 4.0}, 5.0}};  为什么键里面还要套一层大括号数据\n","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586604,"discussion_content":"weak_ptr里你要获取指针都得去lock一下，你该怎么去算哈希值和判断相等？不能算哈希值和判断相等，你以后怎么做查询？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662370643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164154,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1576896556,"is_pvip":false,"replies":[{"id":62411,"content":"声明一个模板 hash，其有一个类型参数。编译器知道了 hash 是一个类模板之后，下面才能进行特化。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576911999,"ip_address":"","comment_id":164154,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，\ntemplate &lt;class T&gt; struct hash;\n这一句的作用是什么呀？","like_count":1},{"had_liked":false,"id":159398,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575614662,"is_pvip":false,"replies":[{"id":60953,"content":"一、前面正确。关于map错了。可以迭代，并且现在erase已经返回迭代器了（C++98时不行）。\n\n二、跟这个关系不大。OO语言里也是推荐继承接口而不是实现的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575632982,"ip_address":"","comment_id":159398,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"第一问 大概是因为可以通过begin()方法的返回值迭代到end() 就像数组或者链表 等等都可以从头遍历到尾 这也是为啥子 有些线性容器 删除以后返回的是下一个元素的迭代器 而map set这种容器无法通过迭代器进行迭代 所以调用erase函数返回void\n第二问 大概是因为各个容器的存储方式不太一样吧 所以导致操作不一样 像priority_queue 和queue他们的操作方式就不一样 queue插入或者删除元素只需要移动指针或者下标就行  但是priority_queue 优先级队列 又称为堆 增加删除操作都涉及到一个堆化过程 维持 最小或者最大值在堆顶","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478660,"discussion_content":"声明一个模板 hash，其有一个类型参数。编译器知道了 hash 是一个类模板之后，下面才能进行特化。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576911999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159356,"user_name":"方阳","can_delete":false,"product_type":"c1","uid":1232080,"ip_address":"","ucode":"C8A5CA2422E38E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIsDF3jO1gFeBOboW1eRbeic7wC9Lh1v5wNWUAKcWGogfQicCVic3ic5YzLnKATo79icZzibIbs6kHLPx7Q/132","comment_is_top":false,"comment_ctime":1575605655,"is_pvip":false,"replies":[{"id":60951,"content":"好，基本正确。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575632588,"ip_address":"","comment_id":159356,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"1.方便算法遍历容器\n2.容器内部也有一些继承和复合，容器是独立的组件，没必要继承公用基类。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477036,"discussion_content":"一、前面正确。关于map错了。可以迭代，并且现在erase已经返回迭代器了（C++98时不行）。\n\n二、跟这个关系不大。OO语言里也是推荐继承接口而不是实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575632982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159329,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1575600094,"is_pvip":false,"replies":[{"id":60919,"content":"1 是激发大家思考，现在多想想就行了。\n\n2 这也算是个点。我再等等其他回答。😊","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575610355,"ip_address":"","comment_id":159329,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"1、为algorithm服务\n2、继承必然要用虚函数，性能有损失","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477022,"discussion_content":"好，基本正确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575632588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159302,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575597058,"is_pvip":false,"replies":[{"id":60917,"content":"我还真希望更新慢点呢，但编辑不肯啊……写文字、造例子都挺花力气的。\n\n第 4、5 讲应该还好吧，烧脑的东西不多。再往下可能会又比较干些，尤其到了模板元编程的部分。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575610093,"ip_address":"","comment_id":159302,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"又更新一课，之前还有同学说更新慢，现在看，是更新太快了，因为都是干货，每一课都要花大力气学","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477005,"discussion_content":"我还真希望更新慢点呢，但编辑不肯啊……写文字、造例子都挺花力气的。\n\n第 4、5 讲应该还好吧，烧脑的东西不多。再往下可能会又比较干些，尤其到了模板元编程的部分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575610093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396408,"user_name":"rtl.","can_delete":false,"product_type":"c1","uid":2416395,"ip_address":"广东","ucode":"7E4E58548BA853","user_header":"https://static001.geekbang.org/account/avatar/00/24/df/0b/7f14e6fd.jpg","comment_is_top":false,"comment_ctime":1734321159,"is_pvip":false,"replies":[{"id":143914,"content":"关联容器通常使用红黑树实现，但并没有规定不能用其他方式。\n\n主要是画出来意义不很大，并不能对理解它们有很大帮助，尤其是关联容器的情况。无序关联容器画出来有一定意义，但对目前这讲里描述的内容也没什么大帮助。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1734362952,"ip_address":"上海","comment_id":396408,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"为什么这一篇不做容器的内存分布图了，有序关联容器的底层是红黑树吧？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477005,"discussion_content":"我还真希望更新慢点呢，但编辑不肯啊……写文字、造例子都挺花力气的。\n\n第 4、5 讲应该还好吧，烧脑的东西不多。再往下可能会又比较干些，尤其到了模板元编程的部分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575610093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351742,"user_name":"shibo","can_delete":false,"product_type":"c1","uid":1363215,"ip_address":"","ucode":"003A5780BB0AFE","user_header":"","comment_is_top":false,"comment_ctime":1658144644,"is_pvip":false,"replies":[{"id":127924,"content":"你试试不就知道了？\n\n看来你C语法不过关啊？从 Java过来的？😝","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1658189882,"ip_address":"","comment_id":351742,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"typedef char mykey_t[8];\n这些错了吧，应该是typedef char[8] mykey_t ?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655197,"discussion_content":"关联容器通常使用红黑树实现，但并没有规定不能用其他方式。\n\n主要是画出来意义不很大，并不能对理解它们有很大帮助，尤其是关联容器的情况。无序关联容器画出来有一定意义，但对目前这讲里描述的内容也没什么大帮助。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734362952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337370,"user_name":"水月","can_delete":false,"product_type":"c1","uid":2344034,"ip_address":"","ucode":"78FC68615016DB","user_header":"https://static001.geekbang.org/account/avatar/00/23/c4/62/269aae3f.jpg","comment_is_top":false,"comment_ctime":1646792718,"is_pvip":false,"replies":[{"id":123316,"content":"不太懂你的意思。我们这里首先没有重载，只有对 hash 类模板的特化。其次，在标准库的实现里，是用拉链方式来实现无序关联容器的，哈希值冲突的键会串成一个链表。用户需要避免这种情况，但如果真发生了，用户没有什么可做的——只能回到代码改进 hash 的特化了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1646841499,"ip_address":"","comment_id":337370,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，像HashTable这类容器，重载了Hash函数之后还需要给散列冲突也准备一个重载吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580443,"discussion_content":"你试试不就知道了？\n\n看来你C语法不过关啊？从 Java过来的？😝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658189882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313164,"user_name":"太阳","can_delete":false,"product_type":"c1","uid":2085640,"ip_address":"","ucode":"24B8E951956789","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d3/08/ffd93029.jpg","comment_is_top":false,"comment_ctime":1632300068,"is_pvip":false,"replies":[{"id":113756,"content":"那段本来就是示意，不是让你运行的。\n\n失败的原因估计是因为 unary_function 没有定义。这是在 C++17 之前 STL 里定义的一个类模板。你可能没有 using namespace std;，也可能是标准开到了 17，编译器不让用这个了。整个把继承部分删掉试试。\n\n有其他问题请新提问题，不要使用回复（我收不到回复的通知）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1632809881,"ip_address":"","comment_id":313164,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"第二段代码（hsah模板）g++编译报错","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555308,"discussion_content":"不太懂你的意思。我们这里首先没有重载，只有对 hash 类模板的特化。其次，在标准库的实现里，是用拉链方式来实现无序关联容器的，哈希值冲突的键会串成一个链表。用户需要避免这种情况，但如果真发生了，用户没有什么可做的——只能回到代码改进 hash 的特化了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646841499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200697,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1510495,"ip_address":"","ucode":"C6FC61A90F202B","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg","comment_is_top":false,"comment_ctime":1585639417,"is_pvip":false,"replies":[{"id":75157,"content":"C++98 到 C++17 的所有容器都在这里了。还额外加了跟 string 的简单比较。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585661675,"ip_address":"","comment_id":200697,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"请问除了这两讲中讲到的容器，STL中还有其他容器存在吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527254,"discussion_content":"那段本来就是示意，不是让你运行的。\n\n失败的原因估计是因为 unary_function 没有定义。这是在 C++17 之前 STL 里定义的一个类模板。你可能没有 using namespace std;，也可能是标准开到了 17，编译器不让用这个了。整个把继承部分删掉试试。\n\n有其他问题请新提问题，不要使用回复（我收不到回复的通知）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632809881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164154,"user_name":"robonix","can_delete":false,"product_type":"c1","uid":1212323,"ip_address":"","ucode":"866EC82EDA455B","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/a3/23540579.jpg","comment_is_top":false,"comment_ctime":1576896556,"is_pvip":false,"replies":[{"id":62411,"content":"声明一个模板 hash，其有一个类型参数。编译器知道了 hash 是一个类模板之后，下面才能进行特化。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1576911999,"ip_address":"","comment_id":164154,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，\ntemplate &lt;class T&gt; struct hash;\n这一句的作用是什么呀？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478660,"discussion_content":"声明一个模板 hash，其有一个类型参数。编译器知道了 hash 是一个类模板之后，下面才能进行特化。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576911999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159398,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1575614662,"is_pvip":false,"replies":[{"id":60953,"content":"一、前面正确。关于map错了。可以迭代，并且现在erase已经返回迭代器了（C++98时不行）。\n\n二、跟这个关系不大。OO语言里也是推荐继承接口而不是实现的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575632982,"ip_address":"","comment_id":159398,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"第一问 大概是因为可以通过begin()方法的返回值迭代到end() 就像数组或者链表 等等都可以从头遍历到尾 这也是为啥子 有些线性容器 删除以后返回的是下一个元素的迭代器 而map set这种容器无法通过迭代器进行迭代 所以调用erase函数返回void\n第二问 大概是因为各个容器的存储方式不太一样吧 所以导致操作不一样 像priority_queue 和queue他们的操作方式就不一样 queue插入或者删除元素只需要移动指针或者下标就行  但是priority_queue 优先级队列 又称为堆 增加删除操作都涉及到一个堆化过程 维持 最小或者最大值在堆顶","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477036,"discussion_content":"一、前面正确。关于map错了。可以迭代，并且现在erase已经返回迭代器了（C++98时不行）。\n\n二、跟这个关系不大。OO语言里也是推荐继承接口而不是实现的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575632982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159356,"user_name":"方阳","can_delete":false,"product_type":"c1","uid":1232080,"ip_address":"","ucode":"C8A5CA2422E38E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIsDF3jO1gFeBOboW1eRbeic7wC9Lh1v5wNWUAKcWGogfQicCVic3ic5YzLnKATo79icZzibIbs6kHLPx7Q/132","comment_is_top":false,"comment_ctime":1575605655,"is_pvip":false,"replies":[{"id":60951,"content":"好，基本正确。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575632588,"ip_address":"","comment_id":159356,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"1.方便算法遍历容器\n2.容器内部也有一些继承和复合，容器是独立的组件，没必要继承公用基类。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477022,"discussion_content":"好，基本正确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575632588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159329,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1575600094,"is_pvip":false,"replies":[{"id":60919,"content":"1 是激发大家思考，现在多想想就行了。\n\n2 这也算是个点。我再等等其他回答。😊","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575610355,"ip_address":"","comment_id":159329,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"1、为algorithm服务\n2、继承必然要用虚函数，性能有损失","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477014,"discussion_content":"1 是激发大家思考，现在多想想就行了。\n\n2 这也算是个点。我再等等其他回答。😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575610355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159302,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1575597058,"is_pvip":false,"replies":[{"id":60917,"content":"我还真希望更新慢点呢，但编辑不肯啊……写文字、造例子都挺花力气的。\n\n第 4、5 讲应该还好吧，烧脑的东西不多。再往下可能会又比较干些，尤其到了模板元编程的部分。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575610093,"ip_address":"","comment_id":159302,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"又更新一课，之前还有同学说更新慢，现在看，是更新太快了，因为都是干货，每一课都要花大力气学","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477014,"discussion_content":"1 是激发大家思考，现在多想想就行了。\n\n2 这也算是个点。我再等等其他回答。😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575610355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396408,"user_name":"rtl.","can_delete":false,"product_type":"c1","uid":2416395,"ip_address":"广东","ucode":"7E4E58548BA853","user_header":"https://static001.geekbang.org/account/avatar/00/24/df/0b/7f14e6fd.jpg","comment_is_top":false,"comment_ctime":1734321159,"is_pvip":false,"replies":[{"id":143914,"content":"关联容器通常使用红黑树实现，但并没有规定不能用其他方式。\n\n主要是画出来意义不很大，并不能对理解它们有很大帮助，尤其是关联容器的情况。无序关联容器画出来有一定意义，但对目前这讲里描述的内容也没什么大帮助。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1734362952,"ip_address":"上海","comment_id":396408,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"为什么这一篇不做容器的内存分布图了，有序关联容器的底层是红黑树吧？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655197,"discussion_content":"关联容器通常使用红黑树实现，但并没有规定不能用其他方式。\n\n主要是画出来意义不很大，并不能对理解它们有很大帮助，尤其是关联容器的情况。无序关联容器画出来有一定意义，但对目前这讲里描述的内容也没什么大帮助。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1734362952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351742,"user_name":"shibo","can_delete":false,"product_type":"c1","uid":1363215,"ip_address":"","ucode":"003A5780BB0AFE","user_header":"","comment_is_top":false,"comment_ctime":1658144644,"is_pvip":false,"replies":[{"id":127924,"content":"你试试不就知道了？\n\n看来你C语法不过关啊？从 Java过来的？😝","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1658189882,"ip_address":"","comment_id":351742,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"typedef char mykey_t[8];\n这些错了吧，应该是typedef char[8] mykey_t ?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580443,"discussion_content":"你试试不就知道了？\n\n看来你C语法不过关啊？从 Java过来的？😝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658189882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337370,"user_name":"水月","can_delete":false,"product_type":"c1","uid":2344034,"ip_address":"","ucode":"78FC68615016DB","user_header":"https://static001.geekbang.org/account/avatar/00/23/c4/62/269aae3f.jpg","comment_is_top":false,"comment_ctime":1646792718,"is_pvip":false,"replies":[{"id":123316,"content":"不太懂你的意思。我们这里首先没有重载，只有对 hash 类模板的特化。其次，在标准库的实现里，是用拉链方式来实现无序关联容器的，哈希值冲突的键会串成一个链表。用户需要避免这种情况，但如果真发生了，用户没有什么可做的——只能回到代码改进 hash 的特化了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1646841499,"ip_address":"","comment_id":337370,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，像HashTable这类容器，重载了Hash函数之后还需要给散列冲突也准备一个重载吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555308,"discussion_content":"不太懂你的意思。我们这里首先没有重载，只有对 hash 类模板的特化。其次，在标准库的实现里，是用拉链方式来实现无序关联容器的，哈希值冲突的键会串成一个链表。用户需要避免这种情况，但如果真发生了，用户没有什么可做的——只能回到代码改进 hash 的特化了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646841499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313164,"user_name":"太阳","can_delete":false,"product_type":"c1","uid":2085640,"ip_address":"","ucode":"24B8E951956789","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d3/08/ffd93029.jpg","comment_is_top":false,"comment_ctime":1632300068,"is_pvip":false,"replies":[{"id":113756,"content":"那段本来就是示意，不是让你运行的。\n\n失败的原因估计是因为 unary_function 没有定义。这是在 C++17 之前 STL 里定义的一个类模板。你可能没有 using namespace std;，也可能是标准开到了 17，编译器不让用这个了。整个把继承部分删掉试试。\n\n有其他问题请新提问题，不要使用回复（我收不到回复的通知）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1632809881,"ip_address":"","comment_id":313164,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"第二段代码（hsah模板）g++编译报错","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527254,"discussion_content":"那段本来就是示意，不是让你运行的。\n\n失败的原因估计是因为 unary_function 没有定义。这是在 C++17 之前 STL 里定义的一个类模板。你可能没有 using namespace std;，也可能是标准开到了 17，编译器不让用这个了。整个把继承部分删掉试试。\n\n有其他问题请新提问题，不要使用回复（我收不到回复的通知）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632809881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200697,"user_name":"hello","can_delete":false,"product_type":"c1","uid":1510495,"ip_address":"","ucode":"C6FC61A90F202B","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/5f/4cbcbfb9.jpg","comment_is_top":false,"comment_ctime":1585639417,"is_pvip":false,"replies":[{"id":75157,"content":"C++98 到 C++17 的所有容器都在这里了。还额外加了跟 string 的简单比较。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585661675,"ip_address":"","comment_id":200697,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"请问除了这两讲中讲到的容器，STL中还有其他容器存在吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490107,"discussion_content":"C++98 到 C++17 的所有容器都在这里了。还额外加了跟 string 的简单比较。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585661675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178553,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1581740053,"is_pvip":false,"replies":[{"id":69276,"content":"都很靠拢了。可以学完之后去看一下参考答案。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581752969,"ip_address":"","comment_id":178553,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1 迭代器，分配器，适配器，算法，仿函数 ，容器。  begin和end应该算是迭代器部分\n2 曾经想实现一个多态版的容器，后来发现很多接口不一致，行为也不一致，虽然Mycontainer实现list和vector的多态，但总感觉别扭  ","like_count":0},{"had_liked":false,"id":159669,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575724459,"is_pvip":false,"replies":[{"id":61022,"content":"正如错误信息提示的，你的类没有定义相等比较。把定义改成下面这样子就可以了（完整起见，我也加了 != 的定义）：\n\ntemplate &lt;typename T&gt;\nclass Test {\npublic:\n    T a_t;\n    bool operator==(const Test&amp; rhs) const\n    {\n        return a_t == rhs.a_t;\n    }\n    bool operator!=(const Test&amp; rhs) const\n    {\n        return !operator==(rhs);\n    }\n};\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575783042,"ip_address":"","comment_id":159669,"utype":1}],"discussion_count":4,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师你好，我在使用无序容器unordered_map时，key是使用了我自定义的类型，所以需要对hash进行特化，但是我编译的时候出了问题：\n“&#47;usr&#47;include&#47;c++&#47;7&#47;bits&#47;stl_function.h:356:20: error: no match for ‘operator==’ (operand types are ‘const Test&lt;int&gt;’ and ‘const Test&lt;int&gt;’)\n       { return __x == __y; }”\n\n测试代码如下：\n&lt;code&gt;\ntemplate &lt;typename T&gt; class Test;\n\nnamespace std {\n    template &lt;typename T&gt;\n    struct hash&lt;Test&lt;T&gt;&gt; {\n        size_t operator()(const Test&lt;T&gt;&amp; v) const noexcept {\n            hash&lt;T&gt; h;\n            return h(v.a_t);\n        }\n    };\n\n}  &#47;&#47; namespace std\n\ntemplate &lt;typename T&gt;\nclass Test {\npublic:\n    T a_t;\n};\n\nint main()\n{\n    Test&lt;int&gt; test;\n    unordered_map&lt;Test&lt;int&gt;, int&gt; ump_test{{test, 1}};\n\n    return 1;\n}\n&lt;code_end&gt;","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483874,"discussion_content":"都很靠拢了。可以学完之后去看一下参考答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581752969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159552,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1575682044,"is_pvip":false,"replies":[{"id":60970,"content":"超出范围，在此处我们是不在乎的——我们不需要一个正确的数值。哈希值本来就是有冲撞的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575686923,"ip_address":"","comment_id":159552,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，我又有问题了！\n、、、\ntemplate &lt;typename T&gt;\nstruct hash&lt;complex&lt;T&gt;&gt; {  \nsize_t  operator()(const complex&lt;T&gt;&amp; v) const    noexcept  { \n   hash&lt;T&gt; h;    \n   return h(v.real()) + h(v.imag());  \n}\n};\n、、、\n这段代码会不会出现问题呢？因为h(v.real())和h(v.imag())的范围都是size_t，他两个和的取值应该超出了size_t的取值范围，因此是否需要进行处理一下呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477139,"discussion_content":"正如错误信息提示的，你的类没有定义相等比较。把定义改成下面这样子就可以了（完整起见，我也加了 != 的定义）：\n\ntemplate &amp;lt;typename T&amp;gt;\nclass Test {\npublic:\n    T a_t;\n    bool operator==(const Test&amp;amp; rhs) const\n    {\n        return a_t == rhs.a_t;\n    }\n    bool operator!=(const Test&amp;amp; rhs) const\n    {\n        return !operator==(rhs);\n    }\n};\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575783042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75878,"discussion_content":"老师你好，那为什么unodered_map会使用到operator==的呢？\n我感觉他不是应该把数据转到hash值，然后保存起来，也感觉没有比较的过程，哪个地方体现了==这个运算符呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575792239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75874,"discussion_content":"嗯嗯，明白了。谢谢老师的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575792034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75145,"discussion_content":"请问老师，为什么会出现这个问题呢？\n谢谢老师的答复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575724533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159242,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1575591092,"is_pvip":false,"replies":[{"id":60899,"content":"同学动作很快，但有点调皮啊。😄","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575595488,"ip_address":"","comment_id":159242,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1. 因为统一要为迭代器服务\n2. 等大佬们！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477094,"discussion_content":"超出范围，在此处我们是不在乎的——我们不需要一个正确的数值。哈希值本来就是有冲撞的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575686923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164158,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1576897019,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"《现代C++实战31讲》容器汇编二：需要函数对象的容器\n\n一、函数对象及其特化\n1.俩个函数对象less 和 hash\n2.less 二元函数，执行对任意类型的比较值，返回布尔类型，调用运算符 ( operator() )而且缺省行为是指定类型对象 &lt; 的比较\n3.sort 排序默认使用 less 从大到小使用 greater\n4.hush 目的是把一个某种类型的值转化为一个无符号的整数 hush 值 (还没有用过hush)\n二、priority_queue\n1.不遵守一般 queue 规则，有序的队列，可以 less(顺排) 和 greater(逆排) \n三、关联性容器\n1.关联性容器有set(集合)、map(映射)、multiset(多重集)、multimap(多重映射)。C++外这些都是无序的，C++里这些都是有序的\n2.关联性容器带 mult i的字段是允许重复键，不带是不允许\n3.关联系容器没有 insert、emplace等成员函数，但都提供find(找到等价键值元素)、lower_bound(找到第一个不小于查询键值元素)、upper_bound(找到第一个不大于查询键值元素)等查询的函数。\n4.在multimap 里精确查找满足某个区间使用 equal_range\n四、无序关联容器\n1.C++11开始每一个关联容器都有一个无序关联容器他们是unordred_set、unordered_map、unordered_multiset、unordered_multimap\n2.有序的关联容器包括(priority_queue)的插入和删除操作以及关联性容器查找操作复杂度都是O(log(n)) 而无序可以平均达到O(1)(必须使用恰当)\n五、array\n1.C数组没有begin 和 end 成员函数(可以使用全局的)\n2.C数组没有size成员函数\n3.C数组作为参数传递时，不会获取C数组长度和结束位置\n课后思考\n1.为什么大部分容器都提供了begin、end等方法\n答：不同容器内部实现方式不同，实现的遍历方式不同，都能提供begin、end的方法也是为了提供统一的调用方法\n2.为什么容器没有继承一个公用的基类\n答：不同容器内部实现方式不同(包括存储方式)，虽然外部接口都是相同的方法调用，但是接口内部实现机制都是不同的，如果非要使用基类，那基类也只能定义虚函数，还不如现在，在实现的时候就做了统一接口，还少一层构造\n","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476992,"discussion_content":"同学动作很快，但有点调皮啊。😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575595488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178553,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1581740053,"is_pvip":false,"replies":[{"id":69276,"content":"都很靠拢了。可以学完之后去看一下参考答案。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1581752969,"ip_address":"","comment_id":178553,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1 迭代器，分配器，适配器，算法，仿函数 ，容器。  begin和end应该算是迭代器部分\n2 曾经想实现一个多态版的容器，后来发现很多接口不一致，行为也不一致，虽然Mycontainer实现list和vector的多态，但总感觉别扭  ","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483874,"discussion_content":"都很靠拢了。可以学完之后去看一下参考答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581752969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159669,"user_name":"lyfei","can_delete":false,"product_type":"c1","uid":1757471,"ip_address":"","ucode":"31ACC702BE6FEA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","comment_is_top":false,"comment_ctime":1575724459,"is_pvip":false,"replies":[{"id":61022,"content":"正如错误信息提示的，你的类没有定义相等比较。把定义改成下面这样子就可以了（完整起见，我也加了 != 的定义）：\n\ntemplate &lt;typename T&gt;\nclass Test {\npublic:\n    T a_t;\n    bool operator==(const Test&amp; rhs) const\n    {\n        return a_t == rhs.a_t;\n    }\n    bool operator!=(const Test&amp; rhs) const\n    {\n        return !operator==(rhs);\n    }\n};\n","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575783042,"ip_address":"","comment_id":159669,"utype":1}],"discussion_count":4,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师你好，我在使用无序容器unordered_map时，key是使用了我自定义的类型，所以需要对hash进行特化，但是我编译的时候出了问题：\n“&#47;usr&#47;include&#47;c++&#47;7&#47;bits&#47;stl_function.h:356:20: error: no match for ‘operator==’ (operand types are ‘const Test&lt;int&gt;’ and ‘const Test&lt;int&gt;’)\n       { return __x == __y; }”\n\n测试代码如下：\n&lt;code&gt;\ntemplate &lt;typename T&gt; class Test;\n\nnamespace std {\n    template &lt;typename T&gt;\n    struct hash&lt;Test&lt;T&gt;&gt; {\n        size_t operator()(const Test&lt;T&gt;&amp; v) const noexcept {\n            hash&lt;T&gt; h;\n            return h(v.a_t);\n        }\n    };\n\n}  &#47;&#47; namespace std\n\ntemplate &lt;typename T&gt;\nclass Test {\npublic:\n    T a_t;\n};\n\nint main()\n{\n    Test&lt;int&gt; test;\n    unordered_map&lt;Test&lt;int&gt;, int&gt; ump_test{{test, 1}};\n\n    return 1;\n}\n&lt;code_end&gt;","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477139,"discussion_content":"正如错误信息提示的，你的类没有定义相等比较。把定义改成下面这样子就可以了（完整起见，我也加了 != 的定义）：\n\ntemplate &amp;lt;typename T&amp;gt;\nclass Test {\npublic:\n    T a_t;\n    bool operator==(const Test&amp;amp; rhs) const\n    {\n        return a_t == rhs.a_t;\n    }\n    bool operator!=(const Test&amp;amp; rhs) const\n    {\n        return !operator==(rhs);\n    }\n};\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575783042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75878,"discussion_content":"老师你好，那为什么unodered_map会使用到operator==的呢？\n我感觉他不是应该把数据转到hash值，然后保存起来，也感觉没有比较的过程，哪个地方体现了==这个运算符呀？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575792239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75874,"discussion_content":"嗯嗯，明白了。谢谢老师的回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575792034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757471,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d1/1f/2cd395eb.jpg","nickname":"lyfei","note":"","ucode":"31ACC702BE6FEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":75145,"discussion_content":"请问老师，为什么会出现这个问题呢？\n谢谢老师的答复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575724533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159552,"user_name":"糖","can_delete":false,"product_type":"c1","uid":1542834,"ip_address":"","ucode":"784DDA19104392","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJzP9yB6eIRRyVNe3iab0gXB6yOeaNRHGx6raTQz2grfE5N2LWl6uIj1mrSU7nxiaEzeSLp6xAkE3iaQ/132","comment_is_top":false,"comment_ctime":1575682044,"is_pvip":false,"replies":[{"id":60970,"content":"超出范围，在此处我们是不在乎的——我们不需要一个正确的数值。哈希值本来就是有冲撞的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575686923,"ip_address":"","comment_id":159552,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"老师，我又有问题了！\n、、、\ntemplate &lt;typename T&gt;\nstruct hash&lt;complex&lt;T&gt;&gt; {  \nsize_t  operator()(const complex&lt;T&gt;&amp; v) const    noexcept  { \n   hash&lt;T&gt; h;    \n   return h(v.real()) + h(v.imag());  \n}\n};\n、、、\n这段代码会不会出现问题呢？因为h(v.real())和h(v.imag())的范围都是size_t，他两个和的取值应该超出了size_t的取值范围，因此是否需要进行处理一下呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477094,"discussion_content":"超出范围，在此处我们是不在乎的——我们不需要一个正确的数值。哈希值本来就是有冲撞的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575686923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159242,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1575591092,"is_pvip":false,"replies":[{"id":60899,"content":"同学动作很快，但有点调皮啊。😄","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1575595488,"ip_address":"","comment_id":159242,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"1. 因为统一要为迭代器服务\n2. 等大佬们！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476992,"discussion_content":"同学动作很快，但有点调皮啊。😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575595488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164158,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1576897019,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"《现代C++实战31讲》容器汇编二：需要函数对象的容器\n\n一、函数对象及其特化\n1.俩个函数对象less 和 hash\n2.less 二元函数，执行对任意类型的比较值，返回布尔类型，调用运算符 ( operator() )而且缺省行为是指定类型对象 &lt; 的比较\n3.sort 排序默认使用 less 从大到小使用 greater\n4.hush 目的是把一个某种类型的值转化为一个无符号的整数 hush 值 (还没有用过hush)\n二、priority_queue\n1.不遵守一般 queue 规则，有序的队列，可以 less(顺排) 和 greater(逆排) \n三、关联性容器\n1.关联性容器有set(集合)、map(映射)、multiset(多重集)、multimap(多重映射)。C++外这些都是无序的，C++里这些都是有序的\n2.关联性容器带 mult i的字段是允许重复键，不带是不允许\n3.关联系容器没有 insert、emplace等成员函数，但都提供find(找到等价键值元素)、lower_bound(找到第一个不小于查询键值元素)、upper_bound(找到第一个不大于查询键值元素)等查询的函数。\n4.在multimap 里精确查找满足某个区间使用 equal_range\n四、无序关联容器\n1.C++11开始每一个关联容器都有一个无序关联容器他们是unordred_set、unordered_map、unordered_multiset、unordered_multimap\n2.有序的关联容器包括(priority_queue)的插入和删除操作以及关联性容器查找操作复杂度都是O(log(n)) 而无序可以平均达到O(1)(必须使用恰当)\n五、array\n1.C数组没有begin 和 end 成员函数(可以使用全局的)\n2.C数组没有size成员函数\n3.C数组作为参数传递时，不会获取C数组长度和结束位置\n课后思考\n1.为什么大部分容器都提供了begin、end等方法\n答：不同容器内部实现方式不同，实现的遍历方式不同，都能提供begin、end的方法也是为了提供统一的调用方法\n2.为什么容器没有继承一个公用的基类\n答：不同容器内部实现方式不同(包括存储方式)，虽然外部接口都是相同的方法调用，但是接口内部实现机制都是不同的，如果非要使用基类，那基类也只能定义虚函数，还不如现在，在实现的时候就做了统一接口，还少一层构造\n","like_count":10}]}