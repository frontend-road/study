{"id":209084,"title":"22 | 栈与单调栈：最大矩形面积","content":"<p>你好，我是胡光，欢迎回来。</p><p>上节课我们讲了单调队列这种具有单调性的结构，并且说明了单调队列适合：维护<strong>队列处理顺序</strong>中的区间最大值，并且我还提到单调队列只是一个铺垫，搞清楚了单调队列的内容，才能更好地学习新的数据结构。</p><p>今天我将带你学习一种队列和单调队列的兄弟数据结构，它的性质也很有趣，就是：栈与单调栈。学习这个数据结构的时候呢，我还是要再次强调一下那句话：数据结构，就是定义一种性质，并且维护这种性质。</p><h2>今日任务</h2><p>在正式开始学习之前呢，先来看一下今天这 10 分钟的任务吧。</p><p>假设有一面木板墙，每块木板的宽度都是 1，你现在想在木板墙上，沿着平行于地面的方向，切割出一块矩形区域。问题来了，如果给出了每一块木板的高度，那么如何切出面积最大的矩形区域？矩形木板墙如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/84/13/84e7e0de54973648e444b780d245ae13.jpg?wh=3533*1951\" alt=\"\" title=\"图1： 木板墙示意图\"><br>\n如你所见，图中有 7 块木板，每块木板的高度分别为：2、1、4、5、1、3、3。经过尝试，我们发现最大矩形就是红色阴影部分所示，也就是切割了高度为 4和5 两块木板，形成了一个高度为4，宽度为2的矩形区域，这个最大面积为 8。</p><p>显而易见的结论：就是<strong>切下来的最大的矩形，一定是以最大矩形所在区域最短那块木板作为其高度值</strong>。如果不是这样的话，我们就可以提升一点点高度，让切下来的部分更大一点儿。</p><!-- [[[read_end]]] --><p>有了如上这个结论，我们就可以枚举每一块木板，每次都以当前木板作为高度，就是把当前这块木板，当成是切出来的矩形区域中的最矮的木板，然后向左边和右边分别做延伸，切出此时的最大矩形区域。当把所有木板都试过一遍后，我们在所有枚举结果中比较出最大值，这个最大值就是我们要求的最大矩形面积。如果木板的个数为  n，那这种做法的时间复杂度接近于 $O(n^2)$。</p><p>而今天，我要给你讲的方法，能将这个时间复杂度降低到 $O(n)$，这种结构方法就像我们上次讲的单调队列一样有趣。接下来，就让我们一点点地揭开这个结构神秘的面纱。</p><h2>必知必会，查缺补漏</h2><p>想要完成今天这个任务呢，你必须掌握接下来我要教给你的一个新的数据结构：单调栈。</p><h4>1.栈：维护一种完全包含关系的结构</h4><p>首先让我们来认识一下最简单的栈结构，所谓栈结构，你可以想象成只有一个口的羽毛球桶，羽毛球只能从唯一的一个口放入和取出。我们把编号1、2、3三个羽毛球按顺序放进球桶后，如果想取出来，那么这些球被取出来的顺序一定是编号3、2、1。也就是说后放入的羽毛球，在取出的时候，会最先被取出来，它们放入和取出的顺序是相反的。</p><p>如果说，上一节我们学习的队列结构是<strong>先进先出</strong>的结构，那么今天我们学习的栈就是一种<strong>后进先出</strong>的结构。栈和队列一样，都是计算机中，用来规范处理顺序的基础结构。</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/6e/ddd9b4e82dd7e48ffdc57b08644cb26e.jpg?wh=4266*2493\" alt=\"\" title=\"图2： 栈结构示意图\"><br>\n图中所示，入栈顺序分别是 蓝、绿、红，那么出栈顺序就一定是红、绿、蓝。图中每一个颜色的方块上标注的数字，就是每一个方块入栈及出栈的顺序。</p><p>从示意图中，我们还可以观察到一个有趣的事情，在顺序上而言，红色方块被绿色方块包裹着，绿色方块被蓝色方块包裹着。这种结构，像是程序的调用过程，如果把蓝色方块，看成是主函数的话，那么绿色方块就是主函数中调用的一个函数 A，红色方块就是 A 函数中调用的另外一个函数 B，三个函数调用的顺序是主函数、函数 A、函数 B。</p><p>而它们的执行结束顺序恰恰是相反的，首先是 函数 B 结束，然后是 函数 A 结束，最后是主函数结束。实际上，我们计算机用来维护函数执行的底层系统，就是用的这种栈结构。</p><p>你可以认为，栈结构本身维护的是一种完全包含关系。其实函数之间的运行，就是一种完全包含关系，只要在主函数中调用函数 B，那么函数 B 一定在主函数结束之前结束，这就可以视为是主函数包含函数 B。</p><h4>2.单调栈：<strong>维护最近大于或小于关系的结构</strong></h4><p>我们了解了最简单的栈结构以后，接下来，就来让我们学习一种栈的升级产物：单调栈。理解单调栈的最简单方法，就是基于对单调队列的理解去学习它。如果你单调队列还没有掌握，那我建议你再好好看一看上节课中关于单调队列的相关内容。</p><p>我先问你一个问题，队列结构和栈结构到底有什么区别？你可能会说，它们唯一的区别就是，队列是从一端进另外一端出，栈是在同一端进出。</p><p>那我再问你一个问题，堵住出口的单调队列，和栈有什么区别？你会发现，好像没什么区别了，单调队列为了维护单调性，在入队列的时候，也会将违反单调性的元素弹出，所以，这就相当于栈的从同一端进出。</p><p>好了，如果你明白这些问题，我可以明确地告诉你：堵住出口的单调队列，就是我们今天要学习的“单调栈”。</p><p>既然堵住了单调队列的出口，那么这种所谓单调栈的结构，就再也维护不了区间最大值了。那它维护的是什么呢？让我们以单调递减栈为例。<br>\n<img src=\"https://static001.geekbang.org/resource/image/37/a6/372c236ecc02ccff691a300785fc35a6.jpg?wh=1610*1833\" alt=\"\" title=\"图3： 单调栈示意图\"><br>\n如图所示，这是我假设的一种单调栈中元素的情况：序列第 12 号元素入栈以后，单调栈中只剩下了 4 个元素，从栈底到栈顶，值分别为23、18、15 和 9，分别对应了原序列的第 2 号、第 5 号，第 9 号 以及 第 12 号。</p><p>关于单调栈性质的思考，我们只需要重点关注栈顶的 12 号元素和 9 号元素之间的关系即可。如果 12 号元素入栈以后，为了保持栈中的单调递减性，它最终放在了 9 号元素上面，那说明什么呢？是不是说明从 9 号元素到 12 号之间的元素值，均小于 12 号元素值呢？也就是说，10号、11 号这两个元素的值，我们虽然不知道具体是多少，可这两个元素的值，肯定比 9 号元素小，甚至也比 12 号元素小。否则，按照单调栈的入栈规则，12 号元素和 9 号元素就不可能在栈中相邻。</p><p>其实，说到这里，你应该已经对单调栈的性质有所感觉了。如果我们将一个元素压入单调递减栈，那么这个元素会落在离它最近，且比它大的元素上面。就像上面的例子中，当12号元素入栈以后，它落在了9号元素上面，说明从 12 号元素向前找，9 号元素是第一个比 12 号元素值大的元素。</p><p><strong>如果说单调队列是维护区间最值的高效结构，单调栈就是维护最近大于或小于关系的高效结构</strong>。如果想要维护最近大于关系，就建立一个单调递减栈，然后将每个元素依次入栈，在这个过程中，我们就可以统计得到每一个元素之前离它最近的，且大于它的元素。那要是想维护最近小于关系呢？就建立一个单调递增栈就好了！</p><p>至此，我们就掌握了单调栈的基本性质了。</p><h2>一起动手，搞事情</h2><p>今天的思考题呢，跟括号匹配有关系。任务很简单，就是给你一串括号序列，括号序列中可能包含小括号()，中括号[] 或者 大括号{}，你需要写程序，判断这个括号序列是否合法。只要括号之间，没有交错重叠的情况，就是合法的括号序列。</p><p>下列给出了一些合法的序列的示例：</p><pre><code>({})\n[]([]){()}\n</code></pre><p>下面是一些非法的括号序列的示例：</p><pre><code>([)]\n(((){}\n</code></pre><p>通过观察括号序列，你会发现合法的括号序列，其实就是一种完全包含的结构，关于这种结构合法性的判断，和我们今天讲的栈结构有什么关系呢？开动你聪明的大脑，思考一下吧！</p><h2>最大矩形面积</h2><p>最后我们回到今天的任务，先来回顾一下之前所说的解题过程：我们通过枚举每一块木板作为切割出的木板墙的高度，每次都需要向左边和右边分别做查找，一直找到一块高度小于当前木板高度的位置，这样就确定了切割木板墙的长度。</p><p>以图1中高度为4的木板为例，我们通过向左延伸查找，发现左边第一块就比它短，这样就确定了向左延伸的长度是0；往右延伸查找，发现第二块木板比它短，也就是向右延伸的长度是1。说到这里，你会发现，上面这个过程，不就是我们之前所说的，维护最近小于关系么！只需要建立一个单调递增栈，就可以完成这个任务！</p><p>下面，是一份我给出的示例代码：</p><pre><code>#define MAX_N 1000\n#define max(a, b) ((a) &gt; (b) ？ (a) : (b))\nint s[MAX_N + 5], top;\nint l[MAX_N + 5], r[MAX_N + 5];\nint max_matrix_area(int *h, int n) {\n    h[0] = h[n + 1] = -1;\n    top = -1, s[++top] = 0;\n    // 找到每一块木板，左边第一块比其矮的木板编号\n    for (int i = 1; i &lt;= n; i++) {\n        while (top &gt;= 0 &amp;&amp; h[s[top]] &gt;= h[i]) --top;\n        l[i] = s[top];\n        s[++top] = i;\n    }\n    // 找到每一块木板，右边第一块比其矮的木板编号\n    top = -1, s[++top] = n + 1;\n    for (int i = n; i &gt;= 1; i--) {\n        while (top &gt;= 0 &amp;&amp; h[s[top]] &gt;= h[i]) --top;\n        r[i] = s[top];\n        s[++top] = i;\n    }\n    // 在所有木板中，找到面积最大的矩形\n    int ans = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        ans = max(ans, (r[i] - l[r] - 1) * h[i]);\n    }\n    return ans;\n}\n</code></pre><p>如上代码所示，max_matrix_area 函数传入两个参数，木板高度数组首地址 h，和木板数量 n。代码中的 s 数组，后续的作用就是模拟单调栈，top 代表了栈顶元素的下标。</p><p>你需要注意的是，代码中假设木板的编号是从 1 到 n 的，然后，在数组的 0 位 及 n + 1 位分别加入两块高度为 -1 的虚拟木板，这是边界控制的一种技巧。也就是说，在每块木板向左搜索的时候，最远也就搜索到 0 号位就停止了，向右搜索的时候呢，最远搜索到 n + 1 位也就停止了。通过加入虚拟木板，代码中就少了相关的边界条件判断，这是一种很实用的技巧，你一定要理解和掌握。</p><h2>课程小结</h2><p>以上就是我们今天要学习的单调栈的内容，关于单调栈，其实你只需要对比着单调队列进行学习和记忆即可，记住以下两点：</p><ol>\n<li>单调栈是用来维护最近大于或小于关系的数据结构。</li>\n<li>单调栈就是堵住出口的单调队列，所以其时间复杂度与单调队列一致，平均到每个处理元素上，都是 $O(1)$ 的时间复杂度。</li>\n</ol><p>好了，单调栈的知识，就讲到这里了。我是胡光，我们下期见。</p>","neighbors":{"left":{"article_title":"21 | 队列与单调队列：滑动区间最大值","id":208100},"right":{"article_title":"23 | 深入理解：容斥原理与递推算法","id":209604}},"comments":[{"had_liked":false,"id":185642,"user_name":"宋不肥","can_delete":false,"product_type":"c1","uid":1240126,"ip_address":"","ucode":"32B34AF579C91C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","comment_is_top":false,"comment_ctime":1583654012,"is_pvip":false,"replies":[{"id":"71714","content":"不错！你理解的很到位！","user_name":"作者回复","comment_id":185642,"uid":"1374625","ip_address":"","utype":1,"ctime":1583660730,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"14468555900","product_id":100043901,"comment_content":"作业打卡：<br>#define MAX 1000<br>char stack[MAX];<br>int top = 0;<br>int f(char* s){<br>    if( s == NULL )<br>        return false;<br>    for( int i=0; s[i]!=&#39;\\0&#39;; i++)<br>    {<br>        if(s[i]==&#39;(&#39; || s[i]==&#39;[&#39; || s[i]==&#39;{&#39;) <br>            stack[++top] = s[i];<br>        else if( (s[i]==&#39;)&#39;&amp;&amp;stack[top]==&#39;(&#39;) || (s[i]==&#39;]&#39;&amp;&amp;stack[top]==&#39;[&#39;) || (s[i]==&#39;}&#39;&amp;&amp;stack[top]==&#39;{&#39;) ) <br>            top--;<br>        else    <br>            return -1;<br>    }<br>    if( top == 0 )  <br>        return 0;<br>    return -1;\t<br>}<br>其实上一节和这一节都是用到了两个数组，分别处理值和对应的输入数据的下标，相当于维护了一个单调性的函数映射。而且还是一个分区间的分段函数，其实想通了这个示例代码就很好看了，数组和链表（指针或引用）是最基础的数据结构，其他数据结构也是通过结构体或类来吧数组和链表进行新的组合，而数组和链表在权衡随机访问和插入的时间复杂度和空间复杂度，对cpu缓存的友好性等适用不同的生产环境。但对同一组数据进行这种多个数组的操作，其实都是在模拟函数了，就和我们平时在实验室做数学推导一个道理了，把变量（数组）做好注释，把公式写出来或者画个图就好理解了。","like_count":3,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486447,"discussion_content":"不错！你理解的很到位！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583660730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253024,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1602569620,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1602569620","product_id":100043901,"comment_content":"茶艺师学编程<br><br>思考题<br><br>我也是想了很久才明白，这样的完全包含的序列，要用单调栈来解决，就像是在玩俄罗斯方块，配对的消失（离开栈），合法的序列在进入这个栈后为“空”，不合法的还是会有东西剩下。<br><br>代码如下：<br><br>#include &lt;stdio.h&gt;<br>#define A (a[i] == &#39;(&#39;)<br>#define AA ((a[i-1] == &#39;(&#39; ) &amp;&amp; ( a[i] == &#39;)&#39;))<br>#define B (a[i] == &#39;[&#39;)<br>#define BB ((a[i-1] == &#39;[&#39; ) &amp;&amp; ( a[i] == &#39;]&#39;))<br>#define C (a[i] == &#39;{&#39;)<br>#define CC ((a[i-1] == &#39;{&#39; ) &amp;&amp; ( a[i] == &#39;}&#39;))<br><br>char a[500] = {0};<br><br>int test(char *a){<br>\tint b[1000] = {0};<br>\tint top = 0;<br>\tfor (int i = 0; a[i] != &#39;\\0&#39; ; i++){<br>\t\tif( A || B || C){<br>\t\t\tb[++top] = i;<br>\t\t\tif( AA || BB || CC){<br>\t\t\t\ttop -= 2;<br>\t\t\t}<br>\t\t}<br>\t}<br>\treturn top;<br>\t<br>}<br><br>int main(){<br>\tputs(&quot;please input:&quot;);<br>\tscanf(&quot;%c&quot;, &amp;a);<br>\tint c = 0;<br>\tc = test(a);<br>\tif ( c == 0 )puts(&quot;该序列是合法的。&quot;);<br>\telse puts(&quot;该序列不合法。&quot;);<br>\treturn 0; <br>\t<br>}","like_count":0},{"had_liked":false,"id":252778,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1602484476,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1602484476","product_id":100043901,"comment_content":"茶艺师学编程<br><br>课文例子 完整可运行代码：<br><br>#include &lt;stdio.h&gt;<br>#define MAX_N 1000<br>#define max(a, b) ((a) &gt; (b) ? (a) : (b))<br><br>int s[MAX_N + 5], top;<br>int l[MAX_N + 5], r[MAX_N + 5];<br>int max_matrix_area (int *h, int n){<br>\th[0] = h[n + 1] = -1;<br>\ttop = -1, s[++top] = 0;<br>\tfor (int i = 1; i &lt;= n; i++){<br>\t\twhile (top &gt;= 0 &amp;&amp; h[s[top]] &gt;= h[i])--top;<br>\t\tl[i] = s[top];<br>\t\ts[++top] = i;<br>\t}<br>\ttop = -1, s[++top] = n + 1;<br>\tfor (int i = n; i &gt;= 1; i--){<br>\t\twhile (top &gt;=0 &amp;&amp; h[s[top]] &gt;= h[i])--top;<br>\t\tr[i] = s[top];<br>\t\ts[++top] = i;<br>\t}<br>\tint ans = 0;<br>\tfor (int i = 1; i &lt;= n; i++){<br>\t\tans = max(ans, (r[i] - l[i] - 1) * h[i] );<br>\t} <br>\treturn ans;<br>} <br><br>int main(){<br>\tint h[7] = {2, 1, 4, 5, 1, 3, 3};<br>\tint n = 7;<br>\tint a;<br>\ta = max_matrix_area(h, n);<br>\tprintf(&quot;最大面积为：%d&quot;, a);<br>\treturn 0;<br>} ","like_count":1},{"had_liked":false,"id":207984,"user_name":"1043","can_delete":false,"product_type":"c1","uid":1485365,"ip_address":"","ucode":"AAA69CC175AEE3","user_header":"https://static001.geekbang.org/account/avatar/00/16/aa/35/1a4884f9.jpg","comment_is_top":false,"comment_ctime":1587226485,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1587226485","product_id":100043901,"comment_content":"有入口、有出口，先进先出效率高；有入口，入口即出口，先进后出&#47;后进先出效率高。只有一个口子就不能考虑两边同时进行的状态，解决单向问题如果不能环回流动就只能先进后出或者后进先出。<br>当然怎么做都会把问题解决，但是就像胡老师刚开始就说的把一个水缸打满，用一桶一桶的提回来和一勺子一勺的盛回来的效率是不一样的。问题小、算法高仅能体现思维水平不同，问题大、用算法解决实际问题的时空复杂度简洁就不是仅仅体现思维水平的问题了，大问题用小问题是堆不出来——多少辆马车加一起也得不到一架火箭，那就是天壤之别了。","like_count":0},{"had_liked":false,"id":186530,"user_name":"Hunter Liu","can_delete":false,"product_type":"c1","uid":1474463,"ip_address":"","ucode":"BD1FD203A295DC","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/9f/ca7b20cd.jpg","comment_is_top":false,"comment_ctime":1583858582,"is_pvip":false,"replies":[{"id":"72087","content":"perfect！","user_name":"作者回复","comment_id":186530,"uid":"1374625","ip_address":"","utype":1,"ctime":1583935836,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"1583858582","product_id":100043901,"comment_content":"括号的左半部分是入栈，右半部分是出栈，符合这个规律的就是合法序列，否则就是非法的。","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486791,"discussion_content":"perfect！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583935836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185450,"user_name":"🤪HappyJoo","can_delete":false,"product_type":"c1","uid":1234591,"ip_address":"","ucode":"96E1858F06BABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","comment_is_top":false,"comment_ctime":1583585265,"is_pvip":false,"replies":[{"id":"71710","content":"yes，你是对的，另外你太皮了。-_-|||，还我的美梦。","user_name":"作者回复","comment_id":185450,"uid":"1374625","ip_address":"","utype":1,"ctime":1583659511,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"1583585265","product_id":100043901,"comment_content":"老师，第二行：#define max(a, b) ((a) &gt; (b) : (a) : (b)) <br>应该是：#define max(a, b) ((a) &gt; (b) ？ (a) : (b))<br>老师你快醒醒啊，周六了不用工作了！！","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486364,"discussion_content":"yes，你是对的，另外你太皮了。-_-|||，还我的美梦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583659511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185443,"user_name":"🤪HappyJoo","can_delete":false,"product_type":"c1","uid":1234591,"ip_address":"","ucode":"96E1858F06BABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/9f/0213e8a0.jpg","comment_is_top":false,"comment_ctime":1583584179,"is_pvip":false,"replies":[{"id":"71711","content":"醒了，第6行是 h！<br>代码的话，只是对于思想的一种直白翻译。弄清操作顺序，再对应到代码即可。","user_name":"作者回复","comment_id":185443,"uid":"1374625","ip_address":"","utype":1,"ctime":1583659839,"user_name_real":"胡炜燚"}],"discussion_count":1,"race_medal":0,"score":"1583584179","product_id":100043901,"comment_content":"Leetcode 题号：有效的括号--20、柱状图中最大的矩形--84。<br>好久以前用python做过第一题，现在早忘了哈哈~<br><br>思考：<br>1，加入数组两端的‘-1’就是传说中的哨兵技巧，加入哨兵可以减少边界条件的判断，简化编程难度（JKSJ-数据结构与算法之美，第7讲）。<br><br>2，道理我都懂，单调队列单调栈很好理解，唯一的问题，就是代码看不懂（bonehead! bonehead!)！啊！中间一段时间没看，突然就懂了！！！厉害了！<br><br>3，老师，你快醒醒！第6行，应该是 h 吧哈哈！","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486363,"discussion_content":"醒了，第6行是 h！\n代码的话，只是对于思想的一种直白翻译。弄清操作顺序，再对应到代码即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583659839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185299,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1583555215,"is_pvip":true,"replies":[{"id":"71709","content":"对，不是单调栈的题目。就是一道纯的理解栈性质的题目。","user_name":"作者回复","comment_id":185299,"uid":"1374625","ip_address":"","utype":1,"ctime":1583659471,"user_name_real":"胡炜燚"}],"discussion_count":2,"race_medal":0,"score":"1583555215","product_id":100043901,"comment_content":"有效括号这个就是 leetcode  https:&#47;&#47;leetcode-cn.com&#47;problems&#47;valid-parentheses&#47; 这道题，但是没有用到单调栈的性质啊","like_count":0,"discussions":[{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486319,"discussion_content":"对，不是单调栈的题目。就是一道纯的理解栈性质的题目。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583659471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504671,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f5/9f/1509d389.jpg","nickname":"栾~龟虽寿！","note":"","ucode":"219B38C08979FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199822,"discussion_content":"你说的很好，这个加深了我的理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583630554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}