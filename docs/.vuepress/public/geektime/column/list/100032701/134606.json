{"id":134606,"title":"18 | 防人之心不可无：检查数据的有效性","content":"<p>你好，我是盛延敏，这里是网络编程实战第18讲，欢迎回来。</p><p>在前面一讲中，我们仔细分析了引起故障的原因，并且已经知道为了应对可能出现的各种故障，必须在程序中做好防御工作。</p><p>在这一讲里，我们继续前面的讨论，看一看为了增强程序的健壮性，我们还需要准备什么。</p><h2>对端的异常状况</h2><p>在前面的第11讲以及第17讲中，我们已经初步接触过一些防范对端异常的方法，比如，通过read等调用时，可以通过对EOF的判断，随时防范对方程序崩溃。</p><pre><code>int nBytes = recv(connfd, buffer, sizeof(buffer), 0);\nif (nBytes == -1) {\n    error(1, errno, &quot;error read message&quot;);\n} else if (nBytes == 0) {\n    error(1, 0, &quot;client closed \\n&quot;);\n}\n</code></pre><p>你可以看到这一个程序中的第4行，当调用read函数返回0字节时，实际上就是操作系统内核返回EOF的一种反映。如果是服务器端同时处理多个客户端连接，一般这里会调用shutdown关闭连接的这一端。</p><p>上一讲也讲到了，不是每种情况都可以通过读操作来感知异常，比如，服务器完全崩溃，或者网络中断的情况下，此时，如果是阻塞套接字，会一直阻塞在read等调用上，没有办法感知套接字的异常。</p><p>其实有几种办法来解决这个问题。</p><p>第一个办法是给套接字的read操作设置超时，如果超过了一段时间就认为连接已经不存在。具体的代码片段如下：</p><pre><code>struct timeval tv;\ntv.tv_sec = 5;\ntv.tv_usec = 0;\nsetsockopt(connfd, SOL_SOCKET, SO_RCVTIMEO, (const char *) &amp;tv, sizeof tv);\n\nwhile (1) {\n    int nBytes = recv(connfd, buffer, sizeof(buffer), 0);\n    if (nBytes == -1) {\n        if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            printf(&quot;read timeout\\n&quot;);\n            onClientTimeout(connfd);\n        } else {\n            error(1, errno, &quot;error read message&quot;);\n        }\n    } else if (nBytes == 0) {\n        error(1, 0, &quot;client closed \\n&quot;);\n    }\n    ...\n}\n</code></pre><p>这个代码片段在第4行调用setsockopt函数，设置了套接字的读操作超时，超时时间为在第1-3行设置的5秒，当然在这里这个时间值是“拍脑袋”设置的，比较科学的设置方法是通过一定的统计之后得到一个比较合理的值。关键之处在读操作返回异常的第9-11行，根据出错信息是<code>EAGAIN</code>或者<code>EWOULDBLOCK</code>，判断出超时，转而调用<code>onClientTimeout</code>函数来进行处理。</p><!-- [[[read_end]]] --><p>这个处理方式虽然比较简单，却很实用，很多FTP服务器端就是这么设计的。连接这种FTP服务器之后，如果FTP的客户端没有续传的功能，在碰到网络故障或服务器崩溃时就会挂断。</p><p>第二个办法是第12讲中提到的办法，添加对连接是否正常的检测。如果连接不正常，需要从当前read阻塞中返回并处理。</p><p>还有一个办法，前面第12讲也提到过，那就是利用多路复用技术自带的超时能力，来完成对套接字I/O的检查，如果超过了预设的时间，就进入异常处理。</p><pre><code>struct timeval tv;\ntv.tv_sec = 5;\ntv.tv_usec = 0;\n\nFD_ZERO(&amp;allreads);\nFD_SET(socket_fd, &amp;allreads);\nfor (;;) {\n    readmask = allreads;\n    int rc = select(socket_fd + 1, &amp;readmask, NULL, NULL, &amp;tv);\n    if (rc &lt; 0) {\n      error(1, errno, &quot;select failed&quot;);\n    }\n    if (rc == 0) {\n      printf(&quot;read timeout\\n&quot;);\n      onClientTimeout(socket_fd);\n    }\n ...   \n}\n</code></pre><p>这段代码使用了select多路复用技术来对套接字进行I/O事件的轮询，程序的13行是到达超时后的处理逻辑，调用<code>onClientTimeout</code>函数来进行超时后的处理。</p><h2>缓冲区处理</h2><p>一个设计良好的网络程序，应该可以在随机输入的情况下表现稳定。不仅是这样，随着互联网的发展，网络安全也愈发重要，我们编写的网络程序能不能在黑客的刻意攻击之下表现稳定，也是一个重要考量因素。</p><p>很多黑客程序，会针对性地构建出一定格式的网络协议包，导致网络程序产生诸如缓冲区溢出、指针异常的后果，影响程序的服务能力，严重的甚至可以夺取服务器端的控制权，随心所欲地进行破坏活动，比如著名的SQL注入，就是通过针对性地构造出SQL语句，完成对数据库敏感信息的窃取。</p><p>所以，在网络程序的编写过程中，我们需要时时刻刻提醒自己面对的是各种复杂异常的场景，甚至是别有用心的攻击者，保持“防人之心不可无”的警惕。</p><p>那么程序都有可能出现哪几种漏洞呢？</p><h3>第一个例子</h3><pre><code>char Response[] = &quot;COMMAND OK&quot;;\nchar buffer[128];\n\nwhile (1) {\n    int nBytes = recv(connfd, buffer, sizeof(buffer), 0);\n    if (nBytes == -1) {\n        error(1, errno, &quot;error read message&quot;);\n    } else if (nBytes == 0) {\n        error(1, 0, &quot;client closed \\n&quot;);\n    }\n\n    buffer[nBytes] = '\\0';\n    if (strcmp(buffer, &quot;quit&quot;) == 0) {\n        printf(&quot;client quit\\n&quot;);\n        send(socket, Response, sizeof(Response), 0);\n    }\n\n    printf(&quot;received %d bytes: %s\\n&quot;, nBytes, buffer);\n}\n</code></pre><p>这段代码从连接套接字中获取字节流，并且判断了出差和EOF情况，如果对端发送来的字符是“quit”就回应“COMAAND OK”的字符流，乍看上去一切正常。</p><p>但仔细看一下，这段代码很有可能会产生下面的结果。</p><pre><code>char buffer[128];\nbuffer[128] = '\\0';\n</code></pre><p>通过recv读取的字符数为128时，就会这样的结果。因为buffer的大小只有128字节，最后的赋值环节，产生了缓冲区溢出的问题。</p><p>所谓缓冲区溢出，是指计算机程序中出现的一种内存违规操作。本质是计算机程序向缓冲区填充的数据，超出了原本缓冲区设置的大小限制，导致了数据覆盖了内存栈空间的其他合法数据。这种覆盖破坏了原来程序的完整性，使用过游戏修改器的同学肯定知道，如果不小心修改错游戏数据的内存空间，很可能导致应用程序产生如“Access violation”的错误，导致应用程序崩溃。</p><p>我们可以对这个程序稍加修改，主要的想法是留下buffer里的一个字节，以容纳后面的<code>'\\0'</code>。</p><pre><code>int nBytes = recv(connfd, buffer, sizeof(buffer)-1, 0);\n</code></pre><p>这个例子里面，还昭示了一个有趣的现象。你会发现我们发送过去的字符串，调用的是<code>sizeof</code>，那也就意味着，Response字符串中的<code>'\\0'</code>是被发送出去的，而我们在接收字符时，则假设没有<code>'\\0'</code>字符的存在。</p><p>为了统一，我们可以改成如下的方式，使用strlen的方式忽略最后一个<code>'\\0'</code>字符。</p><pre><code>send(socket, Response, strlen(Response), 0);\n</code></pre><h3>第二个例子</h3><p>第16讲中提到了对变长报文解析的两种手段，一个是使用特殊的边界符号，例如HTTP使用的回车换行符；另一个是将报文信息的长度编码进入消息。</p><p>在实战中，我们也需要对这部分报文长度保持警惕。</p><pre><code>size_t read_message(int fd, char *buffer, size_t length) {\n    u_int32_t msg_length;\n    u_int32_t msg_type;\n    int rc;\n\n    rc = readn(fd, (char *) &amp;msg_length, sizeof(u_int32_t));\n    if (rc != sizeof(u_int32_t))\n        return rc &lt; 0 ? -1 : 0;\n    msg_length = ntohl(msg_length);\n\n    rc = readn(fd, (char *) &amp;msg_type, sizeof(msg_type));\n    if (rc != sizeof(u_int32_t))\n        return rc &lt; 0 ? -1 : 0;\n\n    if (msg_length &gt; length) {\n        return -1;\n    }\n\n    /* Retrieve the record itself */\n    rc = readn(fd, buffer, msg_length);\n    if (rc != msg_length)\n        return rc &lt; 0 ? -1 : 0;\n    return rc;\n}\n</code></pre><p>在进行报文解析时，第15行对实际的报文长度<code>msg_length</code>和应用程序分配的缓冲区大小进行了比较，如果报文长度过大，导致缓冲区容纳不下，直接返回-1表示出错。千万不要小看这部分的判断，试想如果没有这个判断，对方程序发送出来的消息体，可能构建出一个非常大的<code>msg_length</code>，而实际发送的报文本体长度却没有这么大，这样后面的读取操作就不会成功，如果应用程序实际缓冲区大小比<code>msg_length</code>小，也产生了缓冲区溢出的问题。</p><pre><code>struct {\n    u_int32_t message_length;\n    u_int32_t message_type;\n    char data[128];\n} message;\n\nint n = 65535;\nmessage.message_length = htonl(n);\nmessage.message_type = 1;\nchar buf[128] = &quot;just for fun\\0&quot;;\nstrncpy(message.data, buf, strlen(buf));\nif (send(socket_fd, (char *) &amp;message,\n         sizeof(message.message_length) + sizeof(message.message_type) + strlen(message.data), 0) &lt; 0)\n    error(1, errno, &quot;send failure&quot;);\n</code></pre><p>就是这样一段发送端“不小心”构造的一个程序，消息的长度“不小心”被设置为65535长度，实际发送的报文数据为“just for fun”。在去掉实际的报文长度<code>msg_length</code>和应用程序分配的缓冲区大小做比较之后，服务器端一直阻塞在read调用上，这是因为服务器端误认为需要接收65535大小的字节。</p><h3>第三个例子</h3><p>如果我们需要开发一个函数，这个函数假设报文的分界符是换行符（\\n），一个简单的想法是每次读取一个字符，判断这个字符是不是换行符。</p><p>这里有一个这样的函数，这个函数的最大问题是工作效率太低，要知道每次调用recv函数都是一次系统调用，需要从用户空间切换到内核空间，上下文切换的开销对于高性能来说最好是能省则省。</p><pre><code>size_t readline(int fd, char *buffer, size_t length) {\n    char *buf_first = buffer;\n\n    char c;\n    while (length &gt; 0 &amp;&amp; recv(fd, &amp;c, 1, 0) == 1) {\n        *buffer++ = c;\n        length--;\n        if (c == '\\n') {\n            *buffer = '\\0';\n            return buffer - buf_first;\n        }\n    }\n\n    return -1;\n}\n</code></pre><p>于是，就有了第二个版本，这个函数一次性读取最多512字节到临时缓冲区，之后将临时缓冲区的字符一个一个拷贝到应用程序最终的缓冲区中，这样的做法明显效率会高很多。</p><pre><code>size_t readline(int fd, char *buffer, size_t length) {\n    char *buf_first = buffer;\n    static char *buffer_pointer;\n    int nleft = 0;\n    static char read_buffer[512];\n    char c;\n\n    while (length-- &gt; 0) {\n        if (nleft &lt;= 0) {\n            int nread = recv(fd, read_buffer, sizeof(read_buffer), 0);\n            if (nread &lt; 0) {\n                if (errno == EINTR) {\n                    length++;\n                    continue;\n                }\n                return -1;\n            }\n            if (nread == 0)\n                return 0;\n            buffer_pointer = read_buffer;\n            nleft = nread;\n        }\n        c = *buffer_pointer++;\n        *buffer++ = c;\n        nleft--;\n        if (c == '\\n') {\n            *buffer = '\\0';\n            return buffer - buf_first;\n        }\n    }\n    return -1;\n}\n</code></pre><p>这个程序的主循环在第8行，通过对length变量的判断，试图解决缓冲区长度溢出问题；第9行是判断临时缓冲区的字符有没有被全部拷贝完，如果被全部拷贝完，就会再次尝试读取最多512字节；第20-21行在读取字符成功之后，重置了临时缓冲区读指针、临时缓冲区待读的字符个数；第23-25行则是在拷贝临时缓冲区字符，每次拷贝一个字符，并移动临时缓冲区读指针，对临时缓冲区待读的字符个数进行减1操作。在程序的26-28行，判断是否读到换行符，如果读到则将应用程序最终缓冲区截断，返回最终读取的字符个数。</p><p>这个程序运行起来可能很久都没有问题，但是，它还是有一个微小的瑕疵，这个瑕疵很可能会造成线上故障。</p><p>为了讲清这个故障，我们假设这样调用， 输入的字符为<code>012345678\\n</code>。</p><pre><code>//输入字符为: 012345678\\n\nchar buf[10]\nreadline(fd, buf, 10)\n</code></pre><p>当读到最后一个\\n字符时，length为1，问题是在第26行和27行，如果读到了换行符，就会增加一个字符串截止符，这显然越过了应用程序缓冲区的大小。</p><p>这是正确的程序，这里最关键的是需要先对length进行处理，再去判断length的大小是否可以容纳下字符。</p><pre><code>size_t readline(int fd, char *buffer, size_t length) {\n    char *buf_first = buffer;\n    static char *buffer_pointer;\n    int nleft = 0;\n    static char read_buffer[512];\n    char c;\n\n    while (--length&gt; 0) {\n        if (nleft &lt;= 0) {\n            int nread = recv(fd, read_buffer, sizeof(read_buffer), 0);\n            if (nread &lt; 0) {\n                if (errno == EINTR) {\n                    length++;\n                    continue;\n                }\n                return -1;\n            }\n            if (nread == 0)\n                return 0;\n            buffer_pointer = read_buffer;\n            nleft = nread;\n        }\n        c = *buffer_pointer++;\n        *buffer++ = c;\n        nleft--;\n        if (c == '\\n') {\n            *buffer = '\\0';\n            return buffer - buf_first;\n        }\n    }\n    return -1;\n}\n</code></pre><h2>总结</h2><p>今天的内容到这里就结束了。让我们总结一下： 在网络编程中，是否做好了对各种异常边界的检测，将决定我们的程序在恶劣情况下的稳定性，所以，我们一定要时刻提醒自己做好应对各种复杂情况的准备，这里的异常情况包括缓冲区溢出、指针错误、连接超时检测等。</p><h2>思考题</h2><p>和往常一样，给你留两道思考题吧。</p><p>第一道，我们在读数据的时候，一般都需要给应用程序最终缓冲区分配大小，这个大小有什么讲究吗？</p><p>第二道，你能分析一下，我们文章中的例子所分配的缓冲是否可以换成动态分配吗？比如调用malloc函数来分配缓冲区？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","neighbors":{"left":{"article_title":"17 | TCP并不总是“可靠”的？","id":132639},"right":{"article_title":"19丨提高篇答疑：如何理解TCP四次挥手？","id":135735}},"comments":[{"had_liked":false,"id":132827,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1568248558,"is_pvip":false,"replies":[{"id":"51629","content":"👍","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568887726,"ip_address":"","comment_id":132827,"utype":1}],"discussion_count":1,"race_medal":0,"score":"117532365550","product_id":100032701,"comment_content":"1，最终缓冲区的大小应该比预计接收的数据大小大一些，预防缓冲区溢出。2，完全可以动态分配，但是要记得在return前释放缓冲区","like_count":28,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467139,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568887726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231368,"user_name":"郑祖煌","can_delete":false,"product_type":"c1","uid":1469608,"ip_address":"","ucode":"49A0D2E3279826","user_header":"https://static001.geekbang.org/account/avatar/00/16/6c/a8/1922a0f5.jpg","comment_is_top":false,"comment_ctime":1593658142,"is_pvip":false,"replies":[{"id":"85729","content":"回答的这么赞，我还能说啥呢 :)","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1593954453,"ip_address":"","comment_id":231368,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74608102174","product_id":100032701,"comment_content":"(1).第一道，我们在读数据的时候，一般都需要给应用程序最终缓冲区分配大小，这个大小有什么讲究吗？ 有讲究的。如果分配的太小，那就会频繁的从用户太切换到内核态，这样其实非常损耗CPU的时间。同时如果设置的太大的话，那就会长期阻塞在read或者recv函数上，造成可以先服务或者先完成的内容没完成。再次，也得比实际的数据稍微大一些以免缓冲区溢出，边界的问题要想办法做好的调整。。<br>(2). 第二道，你能分析一下，我们文章中的例子所分配的缓冲是否可以换成动态分配吗？比如调用 malloc 函数来分配缓冲区？是可以动态分配，就是new的话要记得及时的去delete，以免造成内存泄露。","like_count":18,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500276,"discussion_content":"回答的这么赞，我还能说啥呢 :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593954453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170805,"user_name":"超大红细胞","can_delete":false,"product_type":"c1","uid":1780519,"ip_address":"","ucode":"08FA6FE03A8C27","user_header":"https://static001.geekbang.org/account/avatar/00/1b/2b/27/9676d6b3.jpg","comment_is_top":false,"comment_ctime":1578728369,"is_pvip":false,"replies":[{"id":"68056","content":"👍","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1580628249,"ip_address":"","comment_id":170805,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53118335921","product_id":100032701,"comment_content":"一开始不理解为什么设置了 timeout 的 recv 会返回 EAGAIN 错误，在我的知识体系中 EAGAIN 一般出现在非阻塞的 socket 中，后来 man 了一下 SO_RCVTIMEO，发现确实如此，给后面的同学提个醒：<br>Specify the receiving or sending timeouts until reporting an error. The argument is a  struct timeval. If an input or output function blocks for this period of time, and data has been sent or received, the return value of that function will be the amount of data transferred; if no data has been transferred and the timeout has been reached then -1 is returned with errno set to  EAGAIN or  EWOULDBLOCK, or  EINPROGRESS (for  connect(2)) just as if the socket was specified to be nonblocking. <br>总之一句话，SO_RCVTIMEO 会导致 recv 返回 EAGAIN","like_count":13,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481117,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580628249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133325,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1568517057,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18748386241","product_id":100032701,"comment_content":"第一问:<br>不能太小也不能太大  太小了频繁的用户态和内核态切换,太大了读不够容易阻塞,就算不阻塞也容易浪费<br>第二问:<br>如果用malloc频繁的申请和释放也不太好 容易造成碎片<br>","like_count":4,"discussions":[{"author":{"id":2224386,"avatar":"https://static001.geekbang.org/account/avatar/00/21/f1/02/96082034.jpg","nickname":"Guchen","note":"","ucode":"9BD34F616F167A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317382,"discussion_content":"太大了没有读不够阻塞这一说，read指定的nbytes只是说每次最多读多少字节，而不是必须读满这些字节才返回。\nread读阻塞/非阻塞socket，只要接收缓冲区有数据，那就立刻返回;两者差别在于，当接受缓冲区无数据时，前者会阻塞在read调用上，后者会立刻返回-1并设置errno为EAGIN/EWOULDBLOCK。\n我觉得太大主要是会浪费栈空间，因为每次read不一定会返回这么多数据","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603538614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1803259,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","nickname":"linker","note":"","ucode":"6C5799F2FC2C82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210988,"discussion_content":"第一个问题，那就需要反复调试得到一个相对最佳值，太大了造成栈溢出\n第二个问题，一个是造成碎片，另一个容易出问题（一旦忘了释放）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584796852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132508,"user_name":"yusuf","can_delete":false,"product_type":"c1","uid":1170784,"ip_address":"","ucode":"9F32149B2ADDA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/60/eae432c6.jpg","comment_is_top":false,"comment_ctime":1568158204,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14453060092","product_id":100032701,"comment_content":"1、大小一般为2的多少次方<br>2、不能换成动态分配。在read中需要sizeof指明接受数据的最大长度，malloc返回的是一个指针，求指针的sizeof时返回的是指针所占内存大小（32位为4，64位为8），跟实际数据的大小不一致","like_count":3,"discussions":[{"author":{"id":1258295,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/37/94746ab7.jpg","nickname":"笛声何处","note":"","ucode":"A8E67932357888","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9582,"discussion_content":"可以换成动态分配，read中指明长度不一定要用sizeof","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1568192787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1659177,"avatar":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","nickname":"凉人。","note":"","ucode":"4DB16004A62015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117319,"discussion_content":"动态分配理解不够，这应该会一直扩容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578108239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170784,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/60/eae432c6.jpg","nickname":"yusuf","note":"","ucode":"9F32149B2ADDA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9612,"discussion_content":"感觉应该是不能的。动态分配一般是说用多少字节就分配多少字节，read会同时返回字节数和数据。如果先动态分配的话，不知道后面read读取的字节数，就没法申请恰到好处的空间；而如果read后动态分配的话，能知道read的字节数，但对应的数据又无法保存下来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568195931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132789,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1568219836,"is_pvip":false,"replies":[{"id":"51631","content":"是的，如果是这样，只能说我们双方的通信协议没有得到严格的遵守。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568887803,"ip_address":"","comment_id":132789,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10158154428","product_id":100032701,"comment_content":"老师，第二个例子中，及时加上了msg_length和缓冲区length的大小比较，如果msg_length写得很大（但小于length）而实际数据没有那么大时，服务器也会阻塞在read上吧？所以说判断msg_length&lt;=length并不能接read阻塞的问题呀，只能解内存溢出的问题。","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467119,"discussion_content":"是的，如果是这样，只能说我们双方的通信协议没有得到严格的遵守。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568887803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287646,"user_name":"黄毅","can_delete":false,"product_type":"c1","uid":1159363,"ip_address":"","ucode":"201C9FD58CF90B","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/c3/e1e2c097.jpg","comment_is_top":false,"comment_ctime":1618066916,"is_pvip":false,"replies":[{"id":"104493","content":"这要看你的程序是怎么设计的，如果是预先读取了512字节，那确实200后的数据，你得想办法重新&quot;缓冲&quot;起来，以便和后面的数据拼凑成完整意义的字节流；如果你是一个一个字节读的，知道读到\\n，那么则不必了。<br><br>一般情况下，我们是用缓冲来做这件事情，你可以跳到后面的Buffer设计部分，通过指针来指向当前消费的位置，和数据读取的位置做一个比较，就可以不用每次重新生成动态分配的buffer。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1618140504,"ip_address":"","comment_id":287646,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5913034212","product_id":100032701,"comment_content":"关于思考题的第二个问题，有个疑问，如果通过动态分配read_buffer，假设recv能读取512个字节，进一步假设第200个字符是\\n，那么在read_line退出前能delete吗？如果delete的话，会不会第201到512字节的数据丢失？","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518378,"discussion_content":"这要看你的程序是怎么设计的，如果是预先读取了512字节，那确实200后的数据，你得想办法重新&amp;quot;缓冲&amp;quot;起来，以便和后面的数据拼凑成完整意义的字节流；如果你是一个一个字节读的，知道读到\\n，那么则不必了。\n\n一般情况下，我们是用缓冲来做这件事情，你可以跳到后面的Buffer设计部分，通过指针来指向当前消费的位置，和数据读取的位置做一个比较，就可以不用每次重新生成动态分配的buffer。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618140504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346465,"user_name":"无名氏","can_delete":false,"product_type":"c1","uid":1256121,"ip_address":"","ucode":"584E697AE276AB","user_header":"https://static001.geekbang.org/account/avatar/00/13/2a/b9/2bf8cc89.jpg","comment_is_top":false,"comment_ctime":1653172712,"is_pvip":false,"replies":[{"id":"126587","content":"你细品：<br>int nBytes = recv(connfd, buffer, sizeof(buffer), 0);<br>int nBytes = recv(connfd, buffer, sizeof(buffer)-1, 0);","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1653808135,"ip_address":"","comment_id":346465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653172712","product_id":100032701,"comment_content":"临时缓存区，那个“微小瑕疵”，前后两段程序程序没有区别啊😄？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574035,"discussion_content":"你细品：\nint nBytes = recv(connfd, buffer, sizeof(buffer), 0);\nint nBytes = recv(connfd, buffer, sizeof(buffer)-1, 0);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653808135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340308,"user_name":"纪神籽","can_delete":false,"product_type":"c1","uid":1409466,"ip_address":"","ucode":"442F0120F98894","user_header":"https://static001.geekbang.org/account/avatar/00/15/81/ba/b8ed949a.jpg","comment_is_top":false,"comment_ctime":1648733755,"is_pvip":true,"replies":[{"id":"124555","content":"你说的没错，是需要把剩下的412字节保存下来的。这个例子只是对readline该注意的事项进行了模拟分析。","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1648989914,"ip_address":"","comment_id":340308,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648733755","product_id":100032701,"comment_content":"第三个例子有点疑问，如果第一次调用readline，读取512字节，查到第100字节是换行符，然后就返回结果，这样子剩下的412字节不就会丢失了。是不是应该先把上次readline的数据处理完在进行新的recv。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559825,"discussion_content":"你说的没错，是需要把剩下的412字节保存下来的。这个例子只是对readline该注意的事项进行了模拟分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648989914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318888,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1635474339,"is_pvip":false,"replies":[{"id":"115707","content":"读取的时候，是一次性尝试读取最多 512 字节。<br>最外面的length循环实际上控制的是拷贝临时缓冲区字符的工作。<br>所以，还是读取一次。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1635669385,"ip_address":"","comment_id":318888,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635474339","product_id":100032701,"comment_content":"第三个例子修改后的版本，如果length为10发送的也是012345678\\n一共10个，由于--length,所以一次最多读9个，要读完完整的消息，需要读两次吧","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529416,"discussion_content":"读取的时候，是一次性尝试读取最多 512 字节。\n最外面的length循环实际上控制的是拷贝临时缓冲区字符的工作。\n所以，还是读取一次。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635669385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305869,"user_name":"吃猫的鱼","can_delete":false,"product_type":"c1","uid":2007786,"ip_address":"","ucode":"DC15372C47A0CD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/a2/ea/8f913dfa.jpg","comment_is_top":false,"comment_ctime":1628214790,"is_pvip":false,"replies":[{"id":"111680","content":"这个例子的假设就是\\n为报文的分界符。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1629636962,"ip_address":"","comment_id":305869,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628214790","product_id":100032701,"comment_content":"第三个例子中，如果recv读取出的数据格式如下 “xxx\\n yyy\\n”，然后length=4，此时在不就只读出 “xxx\\n”，但是下一次调用recv，“yyy\\n”没被应用就被丢弃了。。。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524543,"discussion_content":"这个例子的假设就是\\n为报文的分界符。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629636962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286756,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1617552861,"is_pvip":false,"replies":[{"id":"104486","content":"不会啊，因为readline这个函数是被反复调用的，所以会读到第二行(也就是第二个换行符)。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1618136099,"ip_address":"","comment_id":286756,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617552861","product_id":100032701,"comment_content":"原文：<br>这个函数一次性读取最多 512 字节到临时缓冲区，之后将临时缓冲区的字符一个一个拷贝到应用程序最终的缓冲区中。<br>在程序的 26-28 行，判断是否读到换行符，如果读到则将应用程序最终缓冲区截断，返回最终读取的字符个数。<br><br><br>问题：<br>假设 client 在一个连接中，发了2次请求：<br>第一次发了1000个字符(包含换行符)；<br>第二次发了24个字符(包含换行符)。<br>对端 server 在 socket 缓冲区，每次都读取 512 个字符。读到换行就截断。那第二次请求的24个字符不就被截断丢弃了，应用程序再也读不到这24字符了。<br>请问老师，会出现这种情况么？谢谢","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518080,"discussion_content":"不会啊，因为readline这个函数是被反复调用的，所以会读到第二行(也就是第二个换行符)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618136099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276192,"user_name":"郭晓朋","can_delete":false,"product_type":"c1","uid":2368802,"ip_address":"","ucode":"7D6FAEB1C5FB2A","user_header":"","comment_is_top":false,"comment_ctime":1611826510,"is_pvip":false,"replies":[{"id":"100427","content":"你是说样例的readline程序有问题么？","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1612101808,"ip_address":"","comment_id":276192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1611826510","product_id":100032701,"comment_content":"你好，对于最后一个例子我感觉好像有问题，--length这种写法会读不到012345678\\n这个字符串的，最终导致读到的字符串没有结束符\\0。length--导致越界的原因是*buffer++ = c;。不应该先执行buffer++，应该放到if语句之后。","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514625,"discussion_content":"你是说样例的readline程序有问题么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612101808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235864,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1595228237,"is_pvip":false,"replies":[{"id":"87599","content":"原来问题在这啊。<br><br>不会啊，可以继续调用recv函数来读下一个512字节。在网络字节流处理中，循环读取是一个常见的技巧。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1595679868,"ip_address":"","comment_id":235864,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1595228237","product_id":100032701,"comment_content":"“第二个版本，这个函数一次性读取最多 512 字节到临时缓冲区，之后将临时缓冲区的字符一个一个拷贝到应用程序最终的缓冲区中“   老师，针对第二个版本，我有个问题，如果“\\n”之后还会有内容，当调用recv函数后，假如返回512个字符，但是程序只取了“\\n”之前的字符串，那“\\n”之后的内容是不是就是丢弃了。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501855,"discussion_content":"原来问题在这啊。\n\n不会啊，可以继续调用recv函数来读下一个512字节。在网络字节流处理中，循环读取是一个常见的技巧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595679868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1471387,"avatar":"https://static001.geekbang.org/account/avatar/00/16/73/9b/67a38926.jpg","nickname":"keepgoing","note":"","ucode":"A2FE0687FB17E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296084,"discussion_content":"这个同学的意思是read_buffer中\\n之后的数据是不是就直接丢弃了，其实没有，因为这个变量是static","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596447769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1471387,"avatar":"https://static001.geekbang.org/account/avatar/00/16/73/9b/67a38926.jpg","nickname":"keepgoing","note":"","ucode":"A2FE0687FB17E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364701,"discussion_content":"感谢，明白了，从socket读取的数据，只要不释放 read_buffer，数据仍在 read_buffer中。下次再调用 read_line 函数就好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617553348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296084,"ip_address":""},"score":364701,"extra":""}]}]},{"had_liked":false,"id":235863,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1595228041,"is_pvip":false,"replies":[{"id":"87598","content":"没看懂问题.....","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1595679749,"ip_address":"","comment_id":235863,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595228041","product_id":100032701,"comment_content":"“第二个版本，这个函数一次性读取最多 512 字节到临时缓冲区，之后将临时缓冲区的字符一个一个拷贝到应用程序最终的缓冲区中。“ ","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501854,"discussion_content":"没看懂问题.....","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595679749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235772,"user_name":"YC","can_delete":false,"product_type":"c1","uid":2029526,"ip_address":"","ucode":"487213D7B37601","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/d6/9ebe565c.jpg","comment_is_top":false,"comment_ctime":1595186614,"is_pvip":false,"replies":[{"id":"87597","content":"注意是增加一个\\0哦，原来的换行符还是会读取的，所以会溢出的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1595679670,"ip_address":"","comment_id":235772,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595186614","product_id":100032701,"comment_content":"<br>&#47;&#47;输入字符为: 012345678\\n<br>char buf[10]<br>readline(fd, buf, 10)<br><br>为什么会溢出呢？不应该刚刚好填满buffer嘛。<br>0123456789\\n才会溢出吧","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501828,"discussion_content":"注意是增加一个\\0哦，原来的换行符还是会读取的，所以会溢出的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595679670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170975,"user_name":"lupguo","can_delete":false,"product_type":"c1","uid":1009098,"ip_address":"","ucode":"1B55A01DF78647","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/ca/38dcd55a.jpg","comment_is_top":false,"comment_ctime":1578807998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578807998","product_id":100032701,"comment_content":"课后题，我的理解是应用程序缓冲区大小设置，如果是预分配buffer情况，应该根据程序场景来的。这个buffer是通过recv系统调用从内核空间将数据拷贝到用户空间，如果buffer过小，会导致需要多次系统调用的开销，过大又会导致用户空间浪费，因此需要选择合适大小；第二个是可以选择动态malloc，只是需要注意释放，否则会有内存泄露的风险；当然也可以基于gc机制来统一回收！","like_count":1},{"had_liked":false,"id":164436,"user_name":"满怀","can_delete":false,"product_type":"c1","uid":1483113,"ip_address":"","ucode":"EFAC662A37D684","user_header":"https://static001.geekbang.org/account/avatar/00/16/a1/69/0ddda908.jpg","comment_is_top":false,"comment_ctime":1576989691,"is_pvip":false,"replies":[{"id":"63897","content":"抱歉，这段时间一直忙，贴下你的代码链接","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1577603981,"ip_address":"","comment_id":164436,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576989691","product_id":100032701,"comment_content":"老师能帮我看一下代码吗 我把这段时间学习到的 整合在一起 现在执行的时候出了一点问题 分析不出错误原因","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478766,"discussion_content":"抱歉，这段时间一直忙，贴下你的代码链接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577603981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1483113,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a1/69/0ddda908.jpg","nickname":"满怀","note":"","ucode":"EFAC662A37D684","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":107755,"discussion_content":"已经解决啦～麻烦老师了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577604575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154780,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1574562051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574562051","product_id":100032701,"comment_content":"😅读完好像明白了，其实应该没明白，因为，课后思考题，答不上来！<br><br>在网络编程中，是否做好了对各种异常边界的检测，将决定我们的程序在恶劣情况下的稳定性，所以，我们一定要时刻提醒自己做好应对各种复杂情况的准备，这里的异常情况包括缓冲区溢出、指针错误、连接超时检测等。","like_count":1},{"had_liked":false,"id":148594,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1573035699,"is_pvip":false,"replies":[{"id":"57488","content":"是这样，声明了一个128字节的数组，但是实际使用的时候，对第129个元素进行了赋值操作，相当于访问了一个没有声明的内存地址，导致产生访问错误，程序会退出。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1573283108,"ip_address":"","comment_id":148594,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573035699","product_id":100032701,"comment_content":"但仔细看一下，这段代码很有可能会产生下面的结果。   下面贴的是两句代码变量声明和赋值，并不是所谓的结果，求解","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473545,"discussion_content":"是这样，声明了一个128字节的数组，但是实际使用的时候，对第129个元素进行了赋值操作，相当于访问了一个没有声明的内存地址，导致产生访问错误，程序会退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573283108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148592,"user_name":"王盛武","can_delete":false,"product_type":"c1","uid":1182516,"ip_address":"","ucode":"DE7EF246D3DCE8","user_header":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","comment_is_top":false,"comment_ctime":1573035415,"is_pvip":false,"replies":[{"id":"57487","content":"<br>char buffer[128];<br>buffer[128] = &#39;\\0&#39;;<br><br>文稿中给出了，变成缓冲区溢出了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1573282976,"ip_address":"","comment_id":148592,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573035415","product_id":100032701,"comment_content":"通过 recv 读取的字符数为 128 时，就会是文稿中的结果。   结果是什么？文稿里并没给出相关结果","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473544,"discussion_content":"\nchar buffer[128];\nbuffer[128] = &amp;#39;\\0&amp;#39;;\n\n文稿中给出了，变成缓冲区溢出了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573282976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133033,"user_name":"一周思进","can_delete":false,"product_type":"c1","uid":1032125,"ip_address":"","ucode":"00BE5402479B16","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/bd/0c40979f.jpg","comment_is_top":false,"comment_ctime":1568331786,"is_pvip":false,"replies":[{"id":"51627","content":"嗯，是需要抽象一个buffer对象来做的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568887628,"ip_address":"","comment_id":133033,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568331786","product_id":100032701,"comment_content":"判断是否换行也可以直接strstr判断吧？<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;YvfZMO2gCjHWmrNRGpdibA<br>我觉得这两种方式的问题就是把后面读取的数据丢弃了，这对于tcp通信可能存在问题吧？<br>在想后面是不是得换成全局循环缓冲区读写？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467227,"discussion_content":"嗯，是需要抽象一个buffer对象来做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568887628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132802,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1568242677,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568242677","product_id":100032701,"comment_content":"第一题。是不是跟结构体字节对齐一样的意思。数据比如是2的倍数 可以方便cpu处理？<br>第二题  可以是动态内存 有时候应用层分包可以自定义几m一个包 甚至更大 而栈上分配空间是有限的 平均都在2到4m的样子 如果在栈上分配缓冲区 可能你的程序会根据平台不同选择性崩溃，而在堆上则没有这个问题唯一需要注意的是内存泄漏问题 c++有智能指针可以避免，java应该更方便吧 它的内存回收不是很厉害的嘛","like_count":0},{"had_liked":false,"id":132747,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1568212237,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"1568212237","product_id":100032701,"comment_content":"我觉得不能用动态分配，如果程序崩溃了，内存还没回收会内存溢出吧","like_count":0,"discussions":[{"author":{"id":2355978,"avatar":"https://static001.geekbang.org/account/avatar/00/23/f3/0a/1314ae1f.jpg","nickname":"Sincostan","note":"","ucode":"92473175750E30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338453,"discussion_content":"确实建议这位同学补习一下操作系统","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609293944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032125,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bf/bd/0c40979f.jpg","nickname":"一周思进","note":"","ucode":"00BE5402479B16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10873,"discussion_content":"程序崩溃，申请的资源系统都会回收的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568332073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1622329,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","nickname":"Steiner","note":"","ucode":"232C1C75207A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1032125,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bf/bd/0c40979f.jpg","nickname":"一周思进","note":"","ucode":"00BE5402479B16","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":11052,"discussion_content":"不会，请参考c++RAII","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568355324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":10873,"ip_address":""},"score":11052,"extra":""},{"author":{"id":1101405,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/5d/5297717a.jpg","nickname":"初见","note":"","ucode":"06D7952CED37D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1622329,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","nickname":"Steiner","note":"","ucode":"232C1C75207A1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12459,"discussion_content":"程序崩溃，进程都没了，当然会被回收呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568534279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":11052,"ip_address":""},"score":12459,"extra":""},{"author":{"id":1622329,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","nickname":"Steiner","note":"","ucode":"232C1C75207A1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1101405,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/5d/5297717a.jpg","nickname":"初见","note":"","ucode":"06D7952CED37D3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12727,"discussion_content":"https://mp.weixin.qq.com/s/fM9fM1UhLhFWHJyKhFyhrg\n\nhttps://mp.weixin.qq.com/s/m44zVWMvactsLPjKsFnlSg\n\n建议学好指针٩̋(๑˃́ꇴ˂̀๑)中秋快乐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568565326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":12459,"ip_address":""},"score":12727,"extra":""}]}]}]}