{"id":296541,"title":"03｜Mutex：4种易错场景大盘点","content":"<p>你好，我是鸟窝。</p><p>上一讲，我带你一起领略了Mutex的架构演进之美，现在我们已经清楚Mutex的实现细节了。当前Mutex的实现貌似非常复杂，其实主要还是针对饥饿模式和公平性问题，做了一些额外处理。但是，我们在第一讲中已经体验过了，Mutex使用起来还是非常简单的，毕竟，它只有Lock和Unlock两个方法，使用起来还能复杂到哪里去？</p><p>正常使用Mutex时，确实是这样的，很简单，基本不会有什么错误，即使出现错误，也是在一些复杂的场景中，比如跨函数调用Mutex或者是在重构或者修补Bug时误操作。但是，我们使用Mutex时，确实会出现一些Bug，比如说忘记释放锁、重入锁、复制已使用了的Mutex等情况。那在这一讲中，我们就一起来看看使用Mutex常犯的几个错误，做到“Bug提前知，后面早防范”。</p><h1>常见的4种错误场景</h1><p>我总结了一下，使用Mutex常见的错误场景有4类，分别是Lock/Unlock不是成对出现、Copy已使用的Mutex、重入和死锁。下面我们一一来看。</p><h2>Lock/Unlock不是成对出现</h2><p>Lock/Unlock没有成对出现，就意味着会出现死锁的情况，或者是因为Unlock一个未加锁的Mutex而导致panic。</p><!-- [[[read_end]]] --><p>我们先来看看缺少Unlock的场景，常见的有三种情况：</p><ol>\n<li>代码中有太多的if-else分支，可能在某个分支中漏写了Unlock；</li>\n<li>在重构的时候把Unlock给删除了；</li>\n<li>Unlock误写成了Lock。</li>\n</ol><p>在这种情况下，锁被获取之后，就不会被释放了，这也就意味着，其它的goroutine永远都没机会获取到锁。</p><p>我们再来看缺少Lock的场景，这就很简单了，一般来说就是误操作删除了Lock。 比如先前使用Mutex都是正常的，结果后来其他人重构代码的时候，由于对代码不熟悉，或者由于开发者的马虎，把Lock调用给删除了，或者注释掉了。比如下面的代码，mu.Lock()一行代码被删除了，直接Unlock一个未加锁的Mutex会panic：</p><pre><code>func foo() {\n    var mu sync.Mutex\n    defer mu.Unlock()\n    fmt.Println(&quot;hello world!&quot;)\n}\n</code></pre><p>运行的时候panic：</p><p><img src=\"https://static001.geekbang.org/resource/image/55/4f/5597316079a8fa37abef2a82bdac7b4f.png?wh=831*189\" alt=\"\"></p><h2>Copy已使用的Mutex</h2><p>第二种误用是Copy已使用的Mutex。在正式分析这个错误之前，我先交代一个小知识点，那就是Package sync的同步原语在使用后是不能复制的。我们知道Mutex是最常用的一个同步原语，那它也是不能复制的。为什么呢？</p><p>原因在于，Mutex是一个有状态的对象，它的state字段记录这个锁的状态。如果你要复制一个已经加锁的Mutex给一个新的变量，那么新的刚初始化的变量居然被加锁了，这显然不符合你的期望，因为你期望的是一个零值的Mutex。关键是在并发环境下，你根本不知道要复制的Mutex状态是什么，因为要复制的Mutex是由其它goroutine并发访问的，状态可能总是在变化。</p><p>当然，你可能说，你说的我都懂，你的警告我都记下了，但是实际在使用的时候，一不小心就踩了这个坑，我们来看一个例子。</p><pre><code>type Counter struct {\n    sync.Mutex\n    Count int\n}\n\n\nfunc main() {\n    var c Counter\n    c.Lock()\n    defer c.Unlock()\n    c.Count++\n    foo(c) // 复制锁\n}\n\n// 这里Counter的参数是通过复制的方式传入的\nfunc foo(c Counter) {\n    c.Lock()\n    defer c.Unlock()\n    fmt.Println(&quot;in foo&quot;)\n}\n</code></pre><p>第12行在调用foo函数的时候，调用者会复制Mutex变量c作为foo函数的参数，不幸的是，复制之前已经使用了这个锁，这就导致，复制的Counter是一个带状态Counter。</p><p>怎么办呢？Go在运行时，有<strong>死锁的检查机制</strong>（<a href=\"https://golang.org/src/runtime/proc.go?h=checkdead#L4345\">checkdead()</a>  方法），它能够发现死锁的goroutine。这个例子中因为复制了一个使用了的Mutex，导致锁无法使用，程序处于死锁的状态。程序运行的时候，死锁检查机制能够发现这种死锁情况并输出错误信息，如下图中错误信息以及错误堆栈：</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/ee/cfb7a4a0e744c5ff534a676fd830d0ee.png?wh=777*251\" alt=\"\"></p><p>你肯定不想运行的时候才发现这个因为复制Mutex导致的死锁问题，那么你怎么能够及时发现问题呢？可以使用<strong>vet工具</strong>，把检查写在Makefile文件中，在持续集成的时候跑一跑，这样可以及时发现问题，及时修复。我们可以使用go vet检查这个Go文件：</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/b8/fa56520yy37009ca58d6640a933f01b8.png?wh=665*94\" alt=\"\"></p><p>你看，使用这个工具就可以发现Mutex复制的问题，错误信息显示得很清楚，是在调用foo函数的时候发生了lock value复制的情况，还告诉我们出问题的代码行数以及copy lock导致的错误。</p><p>那么，vet工具是怎么发现Mutex复制使用问题的呢？我带你简单分析一下。</p><p>检查是通过<a href=\"https://github.com/golang/tools/blob/master/go/analysis/passes/copylock/copylock.go\">copylock</a>分析器静态分析实现的。这个分析器会分析函数调用、range遍历、复制、声明、函数返回值等位置，有没有锁的值copy的情景，以此来判断有没有问题。可以说，只要是实现了Locker接口，就会被分析。我们看到，下面的代码就是确定什么类型会被分析，其实就是实现了Lock/Unlock两个方法的Locker接口：</p><pre><code>var lockerType *types.Interface\n\t\n\t// Construct a sync.Locker interface type.\n\tfunc init() {\n\t\tnullary := types.NewSignature(nil, nil, nil, false) // func()\n\t\tmethods := []*types.Func{\n\t\t\ttypes.NewFunc(token.NoPos, nil, &quot;Lock&quot;, nullary),\n\t\t\ttypes.NewFunc(token.NoPos, nil, &quot;Unlock&quot;, nullary),\n\t\t}\n\t\tlockerType = types.NewInterface(methods, nil).Complete()\n\t}\n</code></pre><p>其实，有些没有实现Locker接口的同步原语（比如WaitGroup），也能被分析。我先卖个关子，后面我们会介绍这种情况是怎么实现的。</p><h2>重入</h2><p>接下来，我们来讨论“重入”这个问题。在说这个问题前，我先解释一下个概念，叫“可重入锁”。</p><p>如果你学过Java，可能会很熟悉ReentrantLock，就是可重入锁，这是Java并发包中非常常用的一个同步原语。它的基本行为和互斥锁相同，但是加了一些扩展功能。</p><p>如果你没接触过Java，也没关系，这里只是提一下，帮助会Java的同学对比来学。那下面我来具体讲解可重入锁是咋回事儿。</p><p>当一个线程获取锁时，如果没有其它线程拥有这个锁，那么，这个线程就成功获取到这个锁。之后，如果其它线程再请求这个锁，就会处于阻塞等待的状态。但是，如果拥有这把锁的线程再请求这把锁的话，不会阻塞，而是成功返回，所以叫可重入锁（有时候也叫做递归锁）。只要你拥有这把锁，你可以可着劲儿地调用，比如通过递归实现一些算法，调用者不会阻塞或者死锁。</p><p>了解了可重入锁的概念，那我们来看Mutex使用的错误场景。划重点了：<strong>Mutex不是可重入的锁。</strong></p><p>想想也不奇怪，因为Mutex的实现中没有记录哪个goroutine拥有这把锁。理论上，任何goroutine都可以随意地Unlock这把锁，所以没办法计算重入条件，毕竟，“臣妾做不到啊”！</p><p>所以，一旦误用Mutex的重入，就会导致报错。下面是一个误用Mutex的重入例子：</p><pre><code>func foo(l sync.Locker) {\n    fmt.Println(&quot;in foo&quot;)\n    l.Lock()\n    bar(l)\n    l.Unlock()\n}\n\n\nfunc bar(l sync.Locker) {\n    l.Lock()\n    fmt.Println(&quot;in bar&quot;)\n    l.Unlock()\n}\n\n\nfunc main() {\n    l := &amp;sync.Mutex{}\n    foo(l)\n}\n</code></pre><p>写完这个Mutex重入的例子后，运行一下，你会发现类似下面的错误。程序一直在请求锁，但是一直没有办法获取到锁，结果就是Go运行时发现死锁了，没有其它地方能够释放锁让程序运行下去，你通过下面的错误堆栈信息就能定位到哪一行阻塞请求锁：</p><p><img src=\"https://static001.geekbang.org/resource/image/0b/79/0bc98ef74c15d9640806d52bf030f979.png?wh=855*299\" alt=\"\"></p><p>学到这里，你可能要问了，虽然标准库Mutex不是可重入锁，但是如果我就是想要实现一个可重入锁，可以吗？</p><p>可以，那我们就自己实现一个。这里的关键就是，实现的锁要能记住当前是哪个goroutine持有这个锁。我来提供两个方案。</p><ul>\n<li>方案一：通过hacker的方式获取到goroutine id，记录下获取锁的goroutine id，它可以实现Locker接口。</li>\n<li>方案二：调用Lock/Unlock方法时，由goroutine提供一个token，用来标识它自己，而不是我们通过hacker的方式获取到goroutine id，但是，这样一来，就不满足Locker接口了。</li>\n</ul><p>可重入锁（递归锁）解决了代码重入或者递归调用带来的死锁问题，同时它也带来了另一个好处，就是我们可以要求，只有持有锁的goroutine才能unlock这个锁。这也很容易实现，因为在上面这两个方案中，都已经记录了是哪一个goroutine持有这个锁。</p><p>下面我们具体来看这两个方案怎么实现。</p><p><strong>方案一</strong>：<strong>goroutine id</strong></p><p>这个方案的关键第一步是获取goroutine id，方式有两种，分别是简单方式和hacker方式。</p><p>简单方式，就是通过runtime.Stack方法获取栈帧信息，栈帧信息里包含goroutine id。你可以看看上面panic时候的贴图，goroutine id明明白白地显示在那里。runtime.Stack方法可以获取当前的goroutine信息，第二个参数为true会输出所有的goroutine信息，信息的格式如下：</p><pre><code>goroutine 1 [running]:\nmain.main()\n        ....../main.go:19 +0xb1\n</code></pre><p>第一行格式为goroutine xxx，其中xxx就是goroutine id，你只要解析出这个id即可。解析的方法可以采用下面的代码：</p><pre><code>func GoID() int {\n    var buf [64]byte\n    n := runtime.Stack(buf[:], false)\n    // 得到id字符串\n    idField := strings.Fields(strings.TrimPrefix(string(buf[:n]), &quot;goroutine &quot;))[0]\n    id, err := strconv.Atoi(idField)\n    if err != nil {\n        panic(fmt.Sprintf(&quot;cannot get goroutine id: %v&quot;, err))\n    }\n    return id\n}\n</code></pre><p>了解了简单方式，接下来我们来看hacker的方式，这也是我们方案一采取的方式。</p><p>首先，我们获取运行时的g指针，反解出对应的g的结构。每个运行的goroutine结构的g指针保存在当前goroutine的一个叫做TLS对象中。</p><p>第一步：我们先获取到TLS对象；</p><p>第二步：再从TLS中获取goroutine结构的g指针；</p><p>第三步：再从g指针中取出goroutine id。</p><p>需要注意的是，不同Go版本的goroutine的结构可能不同，所以需要根据Go的<a href=\"https://github.com/golang/go/blob/89f687d6dbc11613f715d1644b4983905293dd33/src/runtime/runtime2.go#L412\">不同版本</a>进行调整。当然了，如果想要搞清楚各个版本的goroutine结构差异，所涉及的内容又过于底层而且复杂，学习成本太高。怎么办呢？我们可以重点关注一些库。我们没有必要重复发明轮子，直接使用第三方的库来获取goroutine id就可以了。</p><p>好消息是现在已经有很多成熟的方法了，可以支持多个Go版本的goroutine id，给你推荐一个常用的库：<a href=\"https://github.com/petermattis/goid\">petermattis/goid</a>。</p><p>知道了如何获取goroutine id，接下来就是最后的关键一步了，我们实现一个可以使用的可重入锁：</p><pre><code>// RecursiveMutex 包装一个Mutex,实现可重入\ntype RecursiveMutex struct {\n    sync.Mutex\n    owner     int64 // 当前持有锁的goroutine id\n    recursion int32 // 这个goroutine 重入的次数\n}\n\nfunc (m *RecursiveMutex) Lock() {\n    gid := goid.Get()\n    // 如果当前持有锁的goroutine就是这次调用的goroutine,说明是重入\n    if atomic.LoadInt64(&amp;m.owner) == gid {\n        m.recursion++\n        return\n    }\n    m.Mutex.Lock()\n    // 获得锁的goroutine第一次调用，记录下它的goroutine id,调用次数加1\n    atomic.StoreInt64(&amp;m.owner, gid)\n    m.recursion = 1\n}\n\nfunc (m *RecursiveMutex) Unlock() {\n    gid := goid.Get()\n    // 非持有锁的goroutine尝试释放锁，错误的使用\n    if atomic.LoadInt64(&amp;m.owner) != gid {\n        panic(fmt.Sprintf(&quot;wrong the owner(%d): %d!&quot;, m.owner, gid))\n    }\n    // 调用次数减1\n    m.recursion--\n    if m.recursion != 0 { // 如果这个goroutine还没有完全释放，则直接返回\n        return\n    }\n    // 此goroutine最后一次调用，需要释放锁\n    atomic.StoreInt64(&amp;m.owner, -1)\n    m.Mutex.Unlock()\n}\n</code></pre><p>上面这段代码你可以拿来即用。我们一起来看下这个实现，真是非常巧妙，它相当于给Mutex打一个补丁，解决了记录锁的持有者的问题。可以看到，我们用owner字段，记录当前锁的拥有者goroutine的id；recursion 是辅助字段，用于记录重入的次数。</p><p>有一点，我要提醒你一句，尽管拥有者可以多次调用Lock，但是也必须调用相同次数的Unlock，这样才能把锁释放掉。这是一个合理的设计，可以保证Lock和Unlock一一对应。</p><p><strong>方案二</strong>：<strong>token</strong></p><p>方案一是用goroutine id做goroutine的标识，我们也可以让goroutine自己来提供标识。不管怎么说，Go开发者不期望你利用goroutine id做一些不确定的东西，所以，他们没有暴露获取goroutine id的方法。</p><p>下面的代码是第二种方案。调用者自己提供一个token，获取锁的时候把这个token传入，释放锁的时候也需要把这个token传入。通过用户传入的token替换方案一中goroutine id，其它逻辑和方案一一致。</p><pre><code>// Token方式的递归锁\ntype TokenRecursiveMutex struct {\n    sync.Mutex\n    token     int64\n    recursion int32\n}\n\n// 请求锁，需要传入token\nfunc (m *TokenRecursiveMutex) Lock(token int64) {\n    if atomic.LoadInt64(&amp;m.token) == token { //如果传入的token和持有锁的token一致，说明是递归调用\n        m.recursion++\n        return\n    }\n    m.Mutex.Lock() // 传入的token不一致，说明不是递归调用\n    // 抢到锁之后记录这个token\n    atomic.StoreInt64(&amp;m.token, token)\n    m.recursion = 1\n}\n\n// 释放锁\nfunc (m *TokenRecursiveMutex) Unlock(token int64) {\n    if atomic.LoadInt64(&amp;m.token) != token { // 释放其它token持有的锁\n        panic(fmt.Sprintf(&quot;wrong the owner(%d): %d!&quot;, m.token, token))\n    }\n    m.recursion-- // 当前持有这个锁的token释放锁\n    if m.recursion != 0 { // 还没有回退到最初的递归调用\n        return\n    }\n    atomic.StoreInt64(&amp;m.token, 0) // 没有递归调用了，释放锁\n    m.Mutex.Unlock()\n}\n\n</code></pre><h2>死锁</h2><p>接下来，我们来看第四种错误场景：死锁。</p><p>我先解释下什么是死锁。两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或系统产生了死锁。</p><p>我们来分析一下死锁产生的必要条件。如果你想避免死锁，只要破坏这四个条件中的一个或者几个，就可以了。</p><ol>\n<li><strong>互斥</strong>： 至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放。</li>\n<li><strong>持有和等待</strong>：goroutine持有一个资源，并且还在请求其它goroutine持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思。</li>\n<li><strong>不可剥夺</strong>：资源只能由持有它的goroutine来释放。</li>\n<li><strong>环路等待</strong>：一般来说，存在一组等待进程，P={P1，P2，…，PN}，P1等待P2持有的资源，P2等待P3持有的资源，依此类推，最后是PN等待P1持有的资源，这就形成了一个环路等待的死结。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/4a/d5/4ace1eecf856ef80607yyb6f7a45abd5.jpg?wh=2106*1597\" alt=\"\"></p><p>你看，死锁问题还真是挺有意思的，所以有很多人研究这个事儿。一个经典的死锁问题就是<a href=\"https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98\">哲学家就餐问题</a>，我不做介绍了，你可以点击链接进一步了解。其实，死锁问题在现实生活中也比比皆是。</p><p>举个例子。有一次我去派出所开证明，派出所要求物业先证明我是本物业的业主，但是，物业要我提供派出所的证明，才能给我开物业证明，结果就陷入了死锁状态。你可以把派出所和物业看成两个goroutine，派出所证明和物业证明是两个资源，双方都持有自己的资源而要求对方的资源，而且自己的资源自己持有，不可剥夺。</p><p>这是一个最简单的只有两个goroutine相互等待的死锁的例子，转化成代码如下：</p><pre><code>package main\n\n\nimport (\n    &quot;fmt&quot;\n    &quot;sync&quot;\n    &quot;time&quot;\n)\n\n\nfunc main() {\n    // 派出所证明\n    var psCertificate sync.Mutex\n    // 物业证明\n    var propertyCertificate sync.Mutex\n\n\n    var wg sync.WaitGroup\n    wg.Add(2) // 需要派出所和物业都处理\n\n\n    // 派出所处理goroutine\n    go func() {\n        defer wg.Done() // 派出所处理完成\n\n\n        psCertificate.Lock()\n        defer psCertificate.Unlock()\n\n\n        // 检查材料\n        time.Sleep(5 * time.Second)\n        // 请求物业的证明\n        propertyCertificate.Lock()\n        propertyCertificate.Unlock()\n    }()\n\n\n    // 物业处理goroutine\n    go func() {\n        defer wg.Done() // 物业处理完成\n\n\n        propertyCertificate.Lock()\n        defer propertyCertificate.Unlock()\n\n\n        // 检查材料\n        time.Sleep(5 * time.Second)\n        // 请求派出所的证明\n        psCertificate.Lock()\n        psCertificate.Unlock()\n    }()\n\n\n    wg.Wait()\n    fmt.Println(&quot;成功完成&quot;)\n}\n</code></pre><p>这个程序没有办法运行成功，因为派出所的处理和物业的处理是一个环路等待的死结。</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/f4/3ea07805dea9d33d5a5c1a8244a7ccf4.png?wh=854*262\" alt=\"\"></p><p>Go运行时，有死锁探测的功能，能够检查出是否出现了死锁的情况，如果出现了，这个时候你就需要调整策略来处理了。</p><p>你可以引入一个第三方的锁，大家都依赖这个锁进行业务处理，比如现在政府推行的一站式政务服务中心。或者是解决持有等待问题，物业不需要看到派出所的证明才给开物业证明，等等。</p><p>好了，到这里，我给你讲了使用Mutex常见的4类问题。你是不是觉得，哎呀，这几类问题也太不应该了吧，真的会有人犯这么基础的错误吗？</p><p>还真是有。虽然Mutex使用起来很简单，但是，仍然可能出现使用错误的问题。而且，就连一些经验丰富的开发人员，也会出现一些Mutex使用的问题。接下来，我就带你围观几个非常流行的Go开发项目，看看这些错误是怎么产生和修复的。</p><h1>流行的Go开发项目踩坑记</h1><h2>Docker</h2><p>Docker 容器是一个开源的应用容器引擎，开发者可以以统一的方式，把他们的应用和依赖包打包到一个可移植的容器中，然后发布到任何安装了docker引擎的服务器上。</p><p>Docker是使用Go开发的，也算是Go的一个杀手级产品了，它的Mutex相关的Bug也不少，我们来看几个典型的Bug。</p><h3>issue 36114</h3><p>Docker的<a href=\"https://github.com/moby/moby/pull/36114/files\">issue 36114</a> 是一个死锁问题。</p><p>原因在于，hotAddVHDsAtStart方法执行的时候，执行了加锁svm操作。但是，在其中调用hotRemoveVHDsAtStart方法时，这个hotRemoveVHDsAtStart方法也是要加锁svm的。很不幸，Go标准库中的Mutex是不可重入的，所以，代码执行到这里，就出现了死锁的现象。</p><p><img src=\"https://static001.geekbang.org/resource/image/da/8c/dac838666ee09c98dd9ac5db479aae8c.png?wh=1206*654\" alt=\"\"></p><p>针对这个问题，解决办法就是，再提供一个不需要锁的hotRemoveVHDsNoLock方法，避免Mutex的重入。</p><h3>issue 34881</h3><p><a href=\"https://github.com/moby/moby/pull/34881/files\">issue 34881</a>本来是修复Docker的一个简单问题，如果节点在初始化的时候，发现自己不是一个swarm mananger，就快速返回，这个修复就几行代码，你看出问题来了吗？</p><p><img src=\"https://static001.geekbang.org/resource/image/bf/34/bf78904a947d4228dc006fff94f97334.png?wh=897*325\" alt=\"\"></p><p>在第34行，节点发现不满足条件就返回了，但是，c.mu这个锁没有释放！为什么会出现这个问题呢？其实，这是在重构或者添加新功能的时候经常犯的一个错误，因为不太了解上下文，或者是没有仔细看函数的逻辑，从而导致锁没有被释放。现在的Docker当然已经没有这个问题了。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/f1/1c7a5f8e12f642d82aac8045c046c6f1.png?wh=690*170\" alt=\"\"></p><p>这样的issue还有很多，我就不一一列举了。我给你推荐几个关于Mutex的issue或者pull request，你可以关注一下，分别是36840、37583、35517、35482、33305、32826、30696、29554、29191、28912、26507等。</p><h2>Kubernetes</h2><h3>issue 72361</h3><p>issue 72361 增加Mutex为了保护资源。这是为了解决data race问题而做的一个修复，修复方法也很简单，使用互斥锁即可，这也是我们解决data race时常用的方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/21/31/2171a7a0de179904ceba463026ee7231.png?wh=755*375\" alt=\"\"></p><h3>issue 45192</h3><p><a href=\"https://github.com/kubernetes/kubernetes/pull/45192/files\">issue 45192</a>也是一个返回时忘记Unlock的典型例子，和 docker issue 34881犯的错误都是一样的。</p><p>两大知名项目的开发者都犯了这个错误，所以，你就可以知道，引入这个Bug是多么容易，记住晁老师这句话：<strong>保证Lock/Unlock成对出现，尽可能采用defer mutex.Unlock的方式，把它们成对、紧凑地写在一起</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/ba/61/ba0f7671fd64951a47365e46ab68db61.png?wh=985*429\" alt=\"\"></p><p>除了这些，我也建议你关注一下其它的Mutex相关的issue，比如 71617、70605等。</p><h2><strong>gRPC</strong></h2><p>gRPC是Google发起的一个开源远程过程调用 （Remote procedure call）系统。该系统基于 HTTP/2 协议传输，使用Protocol Buffers 作为接口描述语言。它提供Go语言的实现。</p><p>即使是Google官方出品的系统，也有一些Mutex的issue。</p><h3>issue 795</h3><p><a href=\"https://github.com/grpc/grpc-go/pull/795\">issue 795</a>是一个你可能想不到的bug，那就是将Unlock误写成了Lock。</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/f0/b6e97a6938586e95c3427e693eb712f0.png?wh=580*223\" alt=\"\"></p><p>关于这个项目，还有一些其他的为了保护共享资源而添加Mutex的issue，比如1318、2074、2542等。</p><h2>etcd</h2><p>etcd是一个非常知名的分布式一致性的 key-value 存储技术， 被用来做配置共享和服务发现。</p><h2>issue 10419</h2><p><a href=\"https://github.com/etcd-io/etcd/pull/10419/files\">issue 10419</a>是一个锁重入导致的问题。 Store方法内对请求了锁，而调用的Compact的方法内又请求了锁，这个时候，会导致死锁，一直等待，解决办法就是提供不需要加锁的Compact方法。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/7f/5fed22fb735c107d130477562c28477f.png?wh=878*344\" alt=\"\"></p><h1>总结</h1><p>这节课，我们学习了Mutex的一些易错场景，而且，我们还分析了流行的Go开源项目的错误，我也给你分享了我自己在开发中的经验总结。需要强调的是，<strong>手误和重入导致的死锁，是最常见的使用Mutex的Bug</strong>。</p><p>Go死锁探测工具只能探测整个程序是否因为死锁而冻结了，不能检测出一组goroutine死锁导致的某一块业务冻结的情况。你还可以通过Go运行时自带的死锁检测工具，或者是第三方的工具（比如<a href=\"https://github.com/sasha-s/go-deadlock\">go-deadlock</a>、<a href=\"https://github.com/dominikh/go-tools\">go-tools</a>）进行检查，这样可以尽早发现一些死锁的问题。不过，有些时候，死锁在某些特定情况下才会被触发，所以，如果你的测试或者短时间的运行没问题，不代表程序一定不会有死锁问题。</p><p>并发程序最难跟踪调试的就是很难重现，因为并发问题不是按照我们指定的顺序执行的，由于计算机调度的问题和事件触发的时机不同，死锁的Bug可能会在极端的情况下出现。通过搜索日志、查看日志，我们能够知道程序有异常了，比如某个流程一直没有结束。这个时候，可以通过Go pprof工具分析，它提供了一个block profiler监控阻塞的goroutine。除此之外，我们还可以查看全部的goroutine的堆栈信息，通过它，你可以查看阻塞的groutine究竟阻塞在哪一行哪一个对象上了。</p><h1>思考题</h1><p>查找知名的数据库系统TiDB的issue，看看有没有Mutex相关的issue，看看它们都是哪些相关的Bug。</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","comments":[{"had_liked":false,"id":253754,"user_name":"Junes","can_delete":false,"product_type":"c1","uid":1354665,"ip_address":"","ucode":"CD2E829C868970","user_header":"https://static001.geekbang.org/account/avatar/00/14/ab/a9/590d6f02.jpg","comment_is_top":false,"comment_ctime":1602856799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"224941156191","product_id":100061801,"comment_content":"分享一个我觉得很有项目借鉴意义的PR吧：<br><br>https:&#47;&#47;github.com&#47;pingcap&#47;tidb&#47;pull&#47;20381&#47;files <br><br>这个问题是在当前的函数中Lock，然后在调用的函数中Unlock。这种方式会导致，如果运行子函数时panic了，而外部又有recover机制不希望程序崩溃，就触发不到Unlock，引起死锁。<br><br>PR中加了个recover处理，并且判断recover有error才Unlock，这是一种处理方法。<br><br>理想的设计，是将子函数的Unlock挪到与Lock平级的代码，或者不进行recover处理，Let it panic后修复问题。但大型项目项目经常会因为逻辑错综复杂或者各种历史原因，不好改动吧，这种处理方式虽然不好看，但能解决问题，有时候也挺无奈的~","like_count":53},{"had_liked":false,"id":253984,"user_name":"Remember九离","can_delete":false,"product_type":"c1","uid":1237327,"ip_address":"","ucode":"97EE6E6344689F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","comment_is_top":false,"comment_ctime":1603003533,"is_pvip":false,"replies":[{"id":"92757","content":"赞。其他读者可以关注这位朋友的整理","user_name":"作者回复","comment_id":253984,"uid":"1066613","ip_address":"","utype":1,"ctime":1603011629,"user_name_real":"鸟窝"}],"discussion_count":3,"race_medal":0,"score":"66027512973","product_id":100061801,"comment_content":"第三课代码整理:https:&#47;&#47;github.com&#47;wuqinqiang&#47;Go_Concurrency&#47;tree&#47;main&#47;class_3","like_count":16,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507238,"discussion_content":"赞。其他读者可以关注这位朋友的整理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603011629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237327,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","nickname":"Remember九离","note":"","ucode":"97EE6E6344689F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375657,"discussion_content":"地址错了一个字母，是\nhttps://github.com/wuqinqiang/Go_Concurrency","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621787271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2233985,"avatar":"","nickname":"东风","note":"","ucode":"BB8594F7A660BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313343,"discussion_content":"给你，奥利给！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603036461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257948,"user_name":"iamjohnnyzhuang","can_delete":false,"product_type":"c1","uid":1015327,"ip_address":"","ucode":"E694C1828907F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/1f/b1d458a9.jpg","comment_is_top":false,"comment_ctime":1604220970,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"61733763114","product_id":100061801,"comment_content":"买这个课程本来没报多大希望，没想到看看几节下来太赞了，不仅说到了一些技术的实现细节，同时给出的让我们业务开发避免的经验、排查方法也十分有借鉴价值","like_count":14,"discussions":[{"author":{"id":1241757,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/9d/26ea1126.jpg","nickname":"Jesse Rau","note":"","ucode":"9BDA1552A57010","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320383,"discussion_content":"原来我不是唯一这么想的。 :-)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604345142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065849,"avatar":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","nickname":"test","note":"","ucode":"9A4973E591DD12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376526,"discussion_content":"俺也一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622174291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1067505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/49/f1/3d3b02fd.jpg","nickname":"onmyway","note":"","ucode":"452276A5B783AD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331817,"discussion_content":"俺也一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606986506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200231,"avatar":"https://static001.geekbang.org/account/avatar/00/12/50/67/29ad08bc.jpg","nickname":"梦里是谁🌚","note":"","ucode":"0050BC150EDBF4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325609,"discussion_content":"原来我也不是唯一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605361602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253674,"user_name":"buckwheat","can_delete":false,"product_type":"c1","uid":1466067,"ip_address":"","ucode":"3FE4251F6BD2B9","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/d3/e4d2ae68.jpg","comment_is_top":false,"comment_ctime":1602827742,"is_pvip":false,"discussion_count":3,"race_medal":1,"score":"31667598814","product_id":100061801,"comment_content":"看了一眼tidb关于mutex的issue，发现大部问题都出现在Unlock的时机上面，尤其是涉及到多个锁的时候，把Lock和Unlock放到两个方法里面就非常容易出现这种情况。tidb出现data race的issue要比dead lock的要多的多。老师，业务复杂时，在涉及到链式加锁时有没有什么好的办法避免死锁呢？","like_count":7,"discussions":[{"author":{"id":1713473,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIYML5ZzlzYzMDNPSo25ZicwU6LNbOGqQ1ItY4X9dZqOK00GUv1eTlWbYolvYczx4cmTdqNicBmtfkw/132","nickname":"Geek_cba546","note":"","ucode":"200CD29B405A76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383768,"discussion_content":"同问，请老师指教","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626234305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241757,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/9d/26ea1126.jpg","nickname":"Jesse Rau","note":"","ucode":"9BDA1552A57010","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320382,"discussion_content":"頂你上去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604345091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315989,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603343351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255981,"user_name":"pony","can_delete":false,"product_type":"c1","uid":1021530,"ip_address":"","ucode":"B72FA864CDD286","user_header":"https://static001.geekbang.org/account/avatar/00/0f/96/5a/846a09f7.jpg","comment_is_top":false,"comment_ctime":1603494342,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23078330822","product_id":100061801,"comment_content":"老师讲解的很仔细，对mutex使用错误场景都列举了<br>补充点：Go语言核心36讲的解锁一个未加锁的mutex 导致的panic，无法被recover()捕获","like_count":5,"discussions":[{"author":{"id":2730577,"avatar":"","nickname":"kdocs服务组2","note":"","ucode":"F1B0D5EB2E4B31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530954,"discussion_content":"咋说，具体点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637195409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253653,"user_name":"打奥特曼的小怪兽","can_delete":false,"product_type":"c1","uid":1060596,"ip_address":"","ucode":"DE9FF2D598BED2","user_header":"https://static001.geekbang.org/account/avatar/00/10/2e/f4/1e4d6941.jpg","comment_is_top":false,"comment_ctime":1602819447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23077655927","product_id":100061801,"comment_content":"这个课程看起来很有意思","like_count":5},{"had_liked":false,"id":253630,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1602815893,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18782685077","product_id":100061801,"comment_content":"在 TiDB Pull requests 已经 closed 的搜索 deadlock 关键字发现好多，例如 https:&#47;&#47;github.com&#47;pingcap&#47;tidb&#47;pull&#47;500，问题的原因在于释放的位置有问题。","like_count":4,"discussions":[{"author":{"id":1629565,"avatar":"https://static001.geekbang.org/account/avatar/00/18/dd/7d/5d3ab033.jpg","nickname":"不求闻达","note":"","ucode":"B265859B9566D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318664,"discussion_content":"TIDB是这几年出来的关系型数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603801578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254122,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1603069374,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"14487971262","product_id":100061801,"comment_content":"简单易懂 列举知名开源项目漏洞来对应自己的总结 太棒了👏","like_count":3},{"had_liked":false,"id":253726,"user_name":"Stony.修行僧","can_delete":false,"product_type":"c1","uid":1061277,"ip_address":"","ucode":"0F2368F7D93E4A","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/9d/daad92d2.jpg","comment_is_top":false,"comment_ctime":1602844979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14487746867","product_id":100061801,"comment_content":"活捉一只大佬，写的真好，感觉编程语言里面锁技术是精髓之一","like_count":3},{"had_liked":false,"id":279881,"user_name":"阿牛","can_delete":false,"product_type":"c1","uid":1073236,"ip_address":"","ucode":"DC8C189FCF3289","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/54/b3eb605b.jpg","comment_is_top":false,"comment_ctime":1613990147,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10203924739","product_id":100061801,"comment_content":"Mutex常见四种错误场景<br>1、Lock&#47;Unlock不是成对出现<br>2、Copy已使用的Mutex<br>3、重入<br>4、死锁","like_count":2},{"had_liked":false,"id":262249,"user_name":"David","can_delete":false,"product_type":"c1","uid":1136236,"ip_address":"","ucode":"8277D3CE881053","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/6c/042a2e41.jpg","comment_is_top":false,"comment_ctime":1605673666,"is_pvip":false,"replies":[{"id":"95150","content":"如果都按照你的设计，是没问题的，但是很多情况下业务比较复杂，会出现a,b,c,b,e,f,c,e,g这样的调用关系，如果a和e都使用了锁，就可能出现重入问题。<br>也许你觉得这样的错误不可能出现，但是看看大项目中，这种问题还真就出现了","user_name":"作者回复","comment_id":262249,"uid":"1066613","ip_address":"","utype":1,"ctime":1605676418,"user_name_real":"鸟窝"}],"discussion_count":3,"race_medal":0,"score":"10195608258","product_id":100061801,"comment_content":"个人理解：我觉得go里面的可重入锁，有点鸡肋，这也是go官方没有实现的原因吧。第一，如果我加了互斥锁，说明这临界区的资源都是某个groutine独享，那何必要在临界区里面再去请求锁呢，不是多此一举吗，第二，就拿递归来说，我们完全可以把加在递归函数里面的锁，提取到调用递归之前，这样就可以避免递归函数加锁的情况。这是我的个人理解。在redis里面有分布式锁，会出现一个持有锁的线程再次加锁的情况，但是呢，和这里的使用情况还是不一样，redis一般加锁，都会加个有效期(担心忘记释放锁，造成死锁)，这个有效期时间长度，不能太大于程序执行时间，这样如果锁来不及释放的时候可能会影响性能，所以一般有效期都和程序执行时间差不多。但是有时候，出现执行时间长超过了有效期的时候，需要续期，才有再次请求锁。以上是我个人理解，如果老师看到评论，可以点评一下我的思维是否有问题","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509748,"discussion_content":"如果都按照你的设计，是没问题的，但是很多情况下业务比较复杂，会出现a,b,c,b,e,f,c,e,g这样的调用关系，如果a和e都使用了锁，就可能出现重入问题。\n也许你觉得这样的错误不可能出现，但是看看大项目中，这种问题还真就出现了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605676418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1109522,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ee/12/77ddaeb8.jpg","nickname":"Yabo","note":"","ucode":"D193B6AB9686D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330773,"discussion_content":"墨菲定律：有可能发生的事情一定会发生","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606706313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136236,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/6c/042a2e41.jpg","nickname":"David","note":"","ucode":"8277D3CE881053","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326786,"discussion_content":"当然redis本身没有什么可重入锁，只能自己通过客户端实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605675918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259993,"user_name":"消逝文字","can_delete":false,"product_type":"c1","uid":2070541,"ip_address":"","ucode":"F6722D8AF38F52","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/vRoYUplibtKY2YFg7icP8A7SBSicAuhxz2mxgY6kibzaKRO8c1PXpNskGJB2Z3WfFoRaX5nh8oztib0NOr5qNdibCyaw/132","comment_is_top":false,"comment_ctime":1604904372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10194838964","product_id":100061801,"comment_content":"真是想不到，知名的开源项目里面居然也会有一些我们编码时常犯的低级错误","like_count":3},{"had_liked":false,"id":254991,"user_name":"gitxuzan","can_delete":false,"product_type":"c1","uid":1081566,"ip_address":"","ucode":"B0E20F892DA716","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/de/c6191045.jpg","comment_is_top":false,"comment_ctime":1603246190,"is_pvip":false,"replies":[{"id":"92949","content":"这个可以等atomic那一讲出来再了解","user_name":"作者回复","comment_id":254991,"uid":"1066613","ip_address":"","utype":1,"ctime":1603248441,"user_name_real":"鸟窝"}],"discussion_count":3,"race_medal":0,"score":"10193180782","product_id":100061801,"comment_content":"有个地方不明白， 为什么源码里面需要用atomic 原子操作和直接赋值有什么区别","like_count":2,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507580,"discussion_content":"这个可以等atomic那一讲出来再了解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603248441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2536820,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","nickname":"友","note":"","ucode":"972A4333A8B101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388466,"discussion_content":"可以了解下汇编，直接赋值不一定是原子的，可能会有多条指令，比如 *xxx = x  那么会有多条指令， 比如先从栈帧指针xxx偏移量获取 那么会先把&amp;xxx的中存的内存地址读到寄存器，然后再间接寻址到值 再赋值给准确的变量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628774243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1081566,"avatar":"https://static001.geekbang.org/account/avatar/00/10/80/de/c6191045.jpg","nickname":"gitxuzan","note":"","ucode":"B0E20F892DA716","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315901,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603335140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253851,"user_name":"roseduan","can_delete":false,"product_type":"c1","uid":1246451,"ip_address":"","ucode":"5BB69BB9D329EC","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/f3/a3ff8a58.jpg","comment_is_top":false,"comment_ctime":1602918988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10192853580","product_id":100061801,"comment_content":"将 Unlock 误写成了 Lock，哈哈哈，原来这些大佬也会犯低级错误","like_count":2},{"had_liked":false,"id":340833,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1649170770,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5944138066","product_id":100061801,"comment_content":"能把并发的课程讲得这么深入浅出，老师的功底可见一斑~","like_count":1},{"had_liked":false,"id":276360,"user_name":"校歌","can_delete":false,"product_type":"c1","uid":2054611,"ip_address":"","ucode":"CD257668BB1A33","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKBENQekdV3e9XwRQ5kpO9Y9d81sEMm52qcwJWbFbWbW2rniaTFYCChoR0ibZ0E3soQqod9rvfmBibmQ/132","comment_is_top":false,"comment_ctime":1611898245,"is_pvip":true,"replies":[{"id":"100313","content":"👍🏻","user_name":"作者回复","comment_id":276360,"uid":"1066613","ip_address":"","utype":1,"ctime":1611966933,"user_name_real":"鸟窝"}],"discussion_count":1,"race_medal":1,"score":"5906865541","product_id":100061801,"comment_content":"Tidb在用mutex的时候特意改成了defer 这种方式，https:&#47;&#47;github.com&#47;pingcap&#47;tidb&#47;pull&#47;19072，<br>不过找了个比较老的issue，https:&#47;&#47;github.com&#47;pingcap&#47;tidb&#47;pull&#47;5171 ，lock和unlock还是没有统一用defer的方式，这个以后可能成为隐患吧。","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514678,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611966933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269602,"user_name":"Fan","can_delete":false,"product_type":"c1","uid":1115232,"ip_address":"","ucode":"3BF28670FD9407","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","comment_is_top":false,"comment_ctime":1608712528,"is_pvip":false,"replies":[{"id":"97761","content":"加油！！！","user_name":"作者回复","comment_id":269602,"uid":"1066613","ip_address":"","utype":1,"ctime":1608718712,"user_name_real":"鸟窝"}],"discussion_count":2,"race_medal":0,"score":"5903679824","product_id":100061801,"comment_content":"看了前三节，这门课写的太棒了。继续打卡。","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512333,"discussion_content":"加油！！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608718712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115232,"avatar":"https://static001.geekbang.org/account/avatar/00/11/04/60/64d166b6.jpg","nickname":"Fan","note":"","ucode":"3BF28670FD9407","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337438,"discussion_content":"已经刷完一遍，写得太棒，准备二刷，把知识点整理系统梳理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608905552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265741,"user_name":"科科","can_delete":false,"product_type":"c1","uid":1647304,"ip_address":"","ucode":"7DAE6FE781172E","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","comment_is_top":false,"comment_ctime":1606999487,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5901966783","product_id":100061801,"comment_content":"大佬也有写错的时候，不能说完全避免问题，但一定要学习如何解决问题","like_count":1},{"had_liked":false,"id":255076,"user_name":"虫子樱桃","can_delete":false,"product_type":"c1","uid":1226331,"ip_address":"","ucode":"F8244A9E9BC5A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/b6/5b/4486e4f9.jpg","comment_is_top":false,"comment_ctime":1603262905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898230201","product_id":100061801,"comment_content":"跟这个很类似 https:&#47;&#47;medium.com&#47;@bytecraze.com&#47;recursive-locking-in-go-9c1c2a106a38","like_count":1},{"had_liked":false,"id":354432,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"北京","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1660383158,"is_pvip":true,"replies":[{"id":"129135","content":"👍🏻","user_name":"作者回复","comment_id":354432,"uid":"1066613","ip_address":"北京","utype":1,"ctime":1660964923,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1660383158","product_id":100061801,"comment_content":"打卡<br><br>作业：<br><br>https:&#47;&#47;github.com&#47;pingcap&#47;tidb&#47;issues&#47;27725  <br>","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584605,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660964923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351652,"user_name":"echo","can_delete":false,"product_type":"c1","uid":2794917,"ip_address":"","ucode":"50D1D6B0ECD803","user_header":"https://static001.geekbang.org/account/avatar/00/2a/a5/a5/ad715d22.jpg","comment_is_top":false,"comment_ctime":1658053264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658053264","product_id":100061801,"comment_content":"同志们 我又来了","like_count":0},{"had_liked":false,"id":341509,"user_name":"taro","can_delete":false,"product_type":"c1","uid":2658985,"ip_address":"","ucode":"69971AF9FE4857","user_header":"","comment_is_top":false,"comment_ctime":1649666529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649666529","product_id":100061801,"comment_content":"对owner&#47;token的操作为什么要用原子操作呢？多个goroutine读取或者写入owner&#47;token的值会影响可重入锁的运行效果吗？","like_count":0},{"had_liked":false,"id":333906,"user_name":"echo","can_delete":false,"product_type":"c1","uid":2794917,"ip_address":"","ucode":"50D1D6B0ECD803","user_header":"https://static001.geekbang.org/account/avatar/00/2a/a5/a5/ad715d22.jpg","comment_is_top":false,"comment_ctime":1644575253,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644575253","product_id":100061801,"comment_content":"打开","like_count":0},{"had_liked":false,"id":326582,"user_name":"Bynow","can_delete":false,"product_type":"c1","uid":2735072,"ip_address":"","ucode":"1E4F3ADD65CF18","user_header":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","comment_is_top":false,"comment_ctime":1639570646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639570646","product_id":100061801,"comment_content":"go vet 为什么无法检查 goroutine 里的锁问题？","like_count":0},{"had_liked":false,"id":309307,"user_name":"李金狗","can_delete":false,"product_type":"c1","uid":1605237,"ip_address":"","ucode":"9A38CA646B06C3","user_header":"https://static001.geekbang.org/account/avatar/00/18/7e/75/3e6bdc4c.jpg","comment_is_top":false,"comment_ctime":1630039739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630039739","product_id":100061801,"comment_content":"写了一个库 https:&#47;&#47;github.com&#47;longlihale&#47;goid 获取 goid 的欢迎大家使用～ ","like_count":0},{"had_liked":false,"id":303013,"user_name":"、荒唐_戏_","can_delete":false,"product_type":"c1","uid":1149297,"ip_address":"","ucode":"BF6E05A94272E4","user_header":"https://static001.geekbang.org/account/avatar/00/11/89/71/03a99e56.jpg","comment_is_top":false,"comment_ctime":1626516649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626516649","product_id":100061801,"comment_content":"docker 第二个锁问题，遇到相同的，当时排查了一天多。搞到凌晨一点，没搞定，第二天中午十一点发现依赖的同事开发的库有这个问题， 发现原因的时候想死的心都有了","like_count":0},{"had_liked":false,"id":271625,"user_name":"David","can_delete":false,"product_type":"c1","uid":1136236,"ip_address":"","ucode":"8277D3CE881053","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/6c/042a2e41.jpg","comment_is_top":false,"comment_ctime":1609740815,"is_pvip":false,"replies":[{"id":"98518","content":"第11行未加锁","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1609754975,"ip_address":"","comment_id":271625,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1609740815","product_id":100061801,"comment_content":"您好老师，在设计可重入锁的时候，在lock方法中，<br>\t&#47;&#47; 延用mutex的加锁机制<br>\tm.Mutex.Lock()<br>\tatomic.StoreInt64(&amp;m.owner, gid)<br>这个地方有必要 使用atomic吗？<br>      <br><br>其次，如果有必要，为什么  m.recursion = 1  不用了呢<br>我个人认为，在锁里面，好像是没必要使用的吧","like_count":1,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512979,"discussion_content":"第11行未加锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609754975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554075,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/6BNrtko7d9ZXic04QhUuQic7N9XEVFtXciaHNlYMVvIic8bv4k52GmFRuYotiaJpjGiaj35rCdhWcFojKsgFIvZ5XlMA/132","nickname":"Geek_7f28ff","note":"","ucode":"DEC79BC88B72FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378582,"discussion_content":"老师，11行未加锁，和这里有什么关系，这里已经Lock了，那是随便读写，都不会影响啊，老师能不能详细点，没看明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623294002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264914,"user_name":"Yabo","can_delete":false,"product_type":"c1","uid":1109522,"ip_address":"","ucode":"D193B6AB9686D9","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/12/77ddaeb8.jpg","comment_is_top":false,"comment_ctime":1606706359,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606706359","product_id":100061801,"comment_content":"记住重点：保证 Lock&#47;Unlock 成对出现，尽可能采用 defer mutex.Unlock 的方式，把它们成对、紧凑地写在一起。","like_count":0},{"had_liked":false,"id":264769,"user_name":"王麒","can_delete":false,"product_type":"c1","uid":1265260,"ip_address":"","ucode":"330017C5A911B6","user_header":"https://static001.geekbang.org/account/avatar/00/13/4e/6c/71020c59.jpg","comment_is_top":false,"comment_ctime":1606639738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606639738","product_id":100061801,"comment_content":"在defer性能提升之后现在我是否可以简单地在每一个lock后面接一个defer unlock来避免遗漏unlock或者函数返回导致unlock未执行的情况呢？","like_count":0},{"had_liked":false,"id":263862,"user_name":"Geek_771dd0","can_delete":false,"product_type":"c1","uid":1207372,"ip_address":"","ucode":"FC8F77F7D75EE9","user_header":"https://static001.geekbang.org/account/avatar/00/12/6c/4c/d87bb144.jpg","comment_is_top":false,"comment_ctime":1606283611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606283611","product_id":100061801,"comment_content":"func (m *TokenRecursiveMutex) Lock(token int64) {<br>if atomic.LoadInt64(&amp;m.token)==token{<br>m.recursion++<br>return<br>}<br>m.Mutex.Lock()<br>atomic.StoreInt64(&amp;m.token,token)<br>m.recursion = 1<br>}<br>这个方法在使用同一个struct和token并发调用的情况下也会造成重复加锁的问题吧，是否应该在进入方法时加上互斥锁，在退出时释放？","like_count":0},{"had_liked":false,"id":257700,"user_name":"niceshot","can_delete":false,"product_type":"c1","uid":1312493,"ip_address":"","ucode":"2C2BBC07A6E02D","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/ed/5a167dda.jpg","comment_is_top":false,"comment_ctime":1604066938,"is_pvip":false,"replies":[{"id":"93894","content":"第二次不就阻塞在这里了么？","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604219993,"ip_address":"","comment_id":257700,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1604066938","product_id":100061801,"comment_content":"func (m *TokenRecursiveMutex) Lock(token int64)  {<br>\tif atomic.LoadInt64(&amp;m.token)==token{<br>\t\tm.recursion++<br>\t\treturn<br>\t}<br>\tm.Mutex.Lock()<br>\tatomic.StoreInt64(&amp;m.token,token)<br>\tm.recursion = 1<br>}<br>这里如果调用者提供前后两次两个不同的token Mutex.Lock()不就调用两次了吗","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508421,"discussion_content":"第二次不就阻塞在这里了么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604219993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1312493,"avatar":"https://static001.geekbang.org/account/avatar/00/14/06/ed/5a167dda.jpg","nickname":"niceshot","note":"","ucode":"2C2BBC07A6E02D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319987,"discussion_content":"对对傻住了 谢谢回复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604222028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255182,"user_name":"niceshot","can_delete":false,"product_type":"c1","uid":1312493,"ip_address":"","ucode":"2C2BBC07A6E02D","user_header":"https://static001.geekbang.org/account/avatar/00/14/06/ed/5a167dda.jpg","comment_is_top":false,"comment_ctime":1603277067,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1603277067","product_id":100061801,"comment_content":"可重入锁到底有什么作用呢？","like_count":0,"discussions":[{"author":{"id":1050946,"avatar":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","nickname":"Hurt","note":"","ucode":"DCE7428CCF08EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324782,"discussion_content":"Docker 的issue 36114 是一个死锁问题。 老师不是举例子了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605170301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1312493,"avatar":"https://static001.geekbang.org/account/avatar/00/14/06/ed/5a167dda.jpg","nickname":"niceshot","note":"","ucode":"2C2BBC07A6E02D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1050946,"avatar":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","nickname":"Hurt","note":"","ucode":"DCE7428CCF08EF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325015,"discussion_content":"我对这个不是很明白 我的意思在lock内部继续lock是基于什么考虑 外部不是已经lock了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605222686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324782,"ip_address":""},"score":325015,"extra":""}]}]},{"had_liked":false,"id":255003,"user_name":"Jasper","can_delete":false,"product_type":"c1","uid":1202174,"ip_address":"","ucode":"A07ABF45D39089","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/fe/beab006d.jpg","comment_is_top":false,"comment_ctime":1603248505,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603248505","product_id":100061801,"comment_content":"感觉大佬们犯的错误都是我会犯的，哈哈哈。老师讲的简单易懂，注释也很全面。加油加油。","like_count":0},{"had_liked":false,"id":254734,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1603177871,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603177871","product_id":100061801,"comment_content":"保证 Lock&#47;Unlock 成对出现","like_count":0},{"had_liked":false,"id":254330,"user_name":"小龙虾","can_delete":false,"product_type":"c1","uid":1141385,"ip_address":"","ucode":"A6DFC7DD17E297","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/89/3cac9f83.jpg","comment_is_top":false,"comment_ctime":1603101053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603101053","product_id":100061801,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":254135,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1603070877,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603070877","product_id":100061801,"comment_content":"老师讲的真好，跟着老师一路打怪~","like_count":0},{"had_liked":false,"id":253725,"user_name":"星亦辰","can_delete":false,"product_type":"c1","uid":1284592,"ip_address":"","ucode":"B0388FBFFDEE7E","user_header":"https://static001.geekbang.org/account/avatar/00/13/99/f0/d9343049.jpg","comment_is_top":false,"comment_ctime":1602844945,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602844945","product_id":100061801,"comment_content":"A-&gt;B-&gt;C-&gt;A 典型的死锁了 ","like_count":0},{"had_liked":false,"id":253621,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1602813657,"is_pvip":false,"replies":[{"id":"92628","content":"又看到你打卡了","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1602820323,"ip_address":"","comment_id":253621,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602813657","product_id":100061801,"comment_content":"更新地好快，上一讲的源码还没消化完，新的一讲又出了……","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507127,"discussion_content":"又看到你打卡了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602820323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}