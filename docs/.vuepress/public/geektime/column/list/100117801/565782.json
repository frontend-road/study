{"id":565782,"title":"20｜RISC-V指令精讲（五）：原子指令实现与调试","content":"<p>你好，我是LMOS。</p><p>通过前面的课程，我们学过了RISC-V的各种跳转指令以及这些指令的各种变形，并且了解了它们的机器编码。</p><p>今天，我们开始学习RISC-V下的原子指令，原子指令是RISC-V的指令扩展，命名为 ‘A’。这个扩展指令中包含两部分，分别是LR/SC指令和AMO指令。</p><p>我们先搞明白为什么需要原子指令，什么情况用得上它们。再分别学习和对比LR/SC指令与AMO指令，另外，我还会让你知道这些指令各自的使用场景是什么。</p><p>课程代码你可以从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson20\">这里</a>下载。话不多说，让我们直接开始吧。</p><h3>为什么需要原子指令</h3><p>你对学生时代上的物理课还有什么印象么？那时候我们就接触过“原子”这个概念了。“原子”是物质的最小组成，即原子是不可分割的。虽然到现在科学家已经发现在原子内部有更小的成分，但是在广义上原子仍然保持“不可分割”的语义。</p><p>那么在芯片中的原子指令是什么呢？它延续了“不可分割”这个含义，表示<strong>该指令的执行是不可分割的，完成的操作不会被其它外部事件打断。</strong></p><p>我们结合一段代码，来了解原子指令的具体作用和使用场景。</p><pre><code class=\"language-plain\">//全局变量A\nint A = 0;\n//线程A执行的函数\nvoid thread_a()\n{\n    A++;\n    printf(\"ThreadA A is:%d\\n\"，A);\n    return;\n}\n//线程B执行的函数\nvoid thread_b()\n{\n    A++;\n    printf(\"ThreadB A is:%d\\n\"，A);\n    return;\n}\n</code></pre><!-- [[[read_end]]] --><p>以上两个函数，分别由不同的线程运行，都是对全局变量A加1后打印出来。让我们暂停一下想想看，你认为程序的打印结果是什么？</p><p>也许你的判断是两种情况，即输出A值1、 2；A值：2、2。但你把代码跑一下试试，就会发现结果出乎意料。除了前面两种情况，还多了一个可能：A值：1、1。这就很奇怪了，为什么出现这种情况呢？</p><p>原因便是A++不是原子指令实现的不可分割操作，它可以转化为后面这样的CPU指令形式。</p><pre><code class=\"language-plain\">load reg，A\t  #加载A变量到寄存器\nAdd reg，1\t  #对寄存器+1\nstore A，reg   #储存寄存器到A变量\n</code></pre><p>我们已经看到了，A++被转换成了三条指令，有可能线程A执行了上面第一行指令，线程B也执行了上面第一行指令，这时就会出现线程A、B都输出1的情况。其本质原因是，这三条指令是独立、可分割的。</p><p>解决这个问题的方案不止一种。我们可以使用操作系统的<strong>线程同步机制，</strong>让线程A和线程B串行执行，即thread_a函数执行完成了，再执行thread_b函数。另一种方案是使用原子指令，<strong>利用原子指令来保证对变量A执行的操作</strong>，也就是加载、计算、储存这三步是不可分割的，即一条指令能原子地完成这三大步骤。</p><p>现实中，小到多个线程共享全局变量，大到多个程序访问同一个文件，都需要保证数据的一致性。对于变量可以使用原子指令，而文件可以利用原子指令实现文件锁，来同步各个进程对文件的读写。这就是原子指令存在的价值。</p><p>为了实现这些原子操作，一款CPU在设计实现时，就要考虑提供完成这些功能的指令，RISC-V也不例外，原子指令是现代CPU中不可或缺的一种指令，除非你的CPU是单个核心，没有cache，且不运行操作系统。显然，RISC-V架构的CPU，不是那种类型的CPU。</p><p>搞清楚了为什么需要原子指令，我们接下来就去看看，RISC-V究竟提供了哪些原子指令？</p><h3>LR/SC指令</h3><p>首先RISC-V提供了LR/SC指令。这虽然是两条指令，但却是一对好“搭档”，它们需要配合才能实现原子操作，缺一不可。看到后面，你就会知道这是为什么了，我们先从这两条指令用在哪里说起。</p><p>在原子的比较并交换操作中，常常会用到LR/SC指令，这个操作在各种加锁算法中应用广泛。我们先来看看这两条指令各自执行了什么操作。</p><p>LR指令是个缩写，全名是Load Reserved，即保留加载；而SC指令的缩写展开是Store Conditional，即条件存储。</p><p>我们先来看看它们在汇编代码中的书写形式，如下所示：</p><pre><code class=\"language-plain\">lr.{w/d}.{aqrl} rd，(rs1)\n#lr是保留加载指令\n#{可选内容}W（32位）、D（64位）\n#aqrl为内存顺序，一般使用默认的\n#rd为目标寄存器\n#rs1为源寄存器1\n    \nsc.{w/d}.{aqrl} rd，rs2，(rs1)\n#sc是条件储存指令\n#{可选内容}W（32位）、D（64位）\n#aqrl为内存顺序，一般使用默认的\n#rd为目标寄存器\n#rs1为源寄存器1\n#rs2为源寄存器2\n</code></pre><p>上述代码中，rd、rs1、rs2可以是任何通用寄存器。“{}\"中的内容不是必须填写的，汇编器能根据当前的运行环境自动设置。</p><p>LR指令和SC指令完成的操作，用伪代码可以这样描述：</p><pre><code class=\"language-plain\">//lr指令\nrd = [rs1]\nreservation_set(cur_hart)\n//sc指令\nif (is_reserved(rs1)) {\n    *rs1 = rs2\n    rd = 0\n} else\n    rd = 1\nclean_reservation_set(cur_hart)\n</code></pre><p>观察上述伪代码，我们先看看LR指令做了什么：rs1寄存器的数据就是内存地址，指定了LR指令从哪里读取数据。LR会从该地址上加载一个32位或者64位的数据，存放到rd寄存器中。这个地址需要32位或者64位对齐，加载之后会设置当前CPU hart（RISC-V中的核心）读取该地址的保留位。</p><p>而SC指令则是先判断rs1中对应地址里的保留位（reservation set）有没有被设置。如果被设置了，则把rs2的数据写入rs1为地址上的内存中，并在rd中写入0；否则将向rd中写入一个非零值，这个值并不一定是1，最后清除当前对应CPU hart（RISC-V中的核心）在该地址上设置的保留位。</p><p>从上面的描述，我们发现，SC指令不一定执行成功，只有满足后面这四个条件，它才能执行成功：</p><p>1.LR和SC指令成对地访问相同的地址。<br>\n2.LR和SC指令之间没有任何其它的写操作（来自任何一个hart）访问同样的地址。<br>\n3.LR和SC指令之间没有任何中断与异常发生。<br>\n4.LR和SC指令之间没有执行MRET指令。</p><p>而这些条件正是LR/SC指令保持原子性的关键所在。</p><p>下面我们一起写代码验证一下。为了方便调试，我们的代码组织结构还是从写一个main.c文件开始，然后在其中写上main函数，因为这是链接器所需要的。接着我们写一个lrsc.S文件，并在里面用汇编写上lrsc_ins函数，这些操作在前面课程中我们已经反复做过了。</p><p>代码如下所示：</p><pre><code class=\"language-plain\">.globl lrsc_ins\n#a0内存地址\n#a1预期值\n#a2所需值\n#a0返回值，如果成功，则为0！否则为1\nlrsc_ins:\ncas:\n    lr.w t0，(a0)       #加载以前的值\n    bne t0，a1，fail    #不相等则跳转到fail\n    sc.w a0，a2，(a0)   #尝试更新\n    jr ra               #返回\nfail:\n    li a0，1            #a0 = 1\n    jr ra               #返回\n</code></pre><p>这样，lrsc_ins函数就写好了。</p><p>我结合上面的代码再带你理解一下：这个函数首先通过LR指令把a0中的数据（也就是地址信息）加载到t0中，如果t0和a1不相等，则跳转到fail处，将a0置1并返回；否则继续顺序执行，通过SC指令将a2的数据写入到a0为地址的内存中，写入成功则将a0置0，不成功则置为非零。SC指令执行成功与否，要看是否满足上面那4个条件，最后返回。</p><p>我们在main.c文件中声明一下这两个函数并调用它，再用VSCode打开工程目录，按下“F5”键调试一下，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/63/yy/63dd2d2589ac474ceb0e85125013e7yy.jpg?wh=1920x1021\" alt=\"图片\"></p><p>上图是执行“lr.w t0，(a0)”指令后的状态。下一步我们将执行bne比较指令，继续做两步单步调试，目的是执行SC指令，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/65/5e442ac8534cb7fde44f1093ae975c65.jpg?wh=1920x1021\" alt=\"图片\"></p><p>上图是执行“sc.w a0，a2，(a0)”指令后的状态。由于SC指令执行时满足上述四大条件，所以SC会把a2的内容写入a0为地址的内存中，并将a0置0，最后返回到main函数中，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c0/0a/c061912fd5d68b00bc456ce040ce980a.jpg?wh=1920x1021\" alt=\"图片\"></p><p>上图描述的过程是，main函数调用lrsc_ins函数后，然后调用printf输出返回的结果，在终端中的输出为result:0，val:1。这个结果在我们的预料之中，也验证了LR/SC指令正如我们前面所描述的那样。</p><p>通过这种LR/SC指令的组合，确实可以实现原子的比较并交换的操作，在计算机行业中也称为<strong>CAS指令</strong>。这种CAS指令是实现系统中各种同步锁的基础设施，这也是为什么我在写代码时，同时使用lrsc_ins和cas两个标号的用意。</p><p>我们再看一个例子加深印象，代码如下所示：</p><pre><code class=\"language-plain\">int cas(int* lock, int cmp, int lockval); // 声明cas函数\nint lock = 0;\n//初始化锁\nvoid LockInit(int* lock)\n{\n    *lock = 0;\n    return;\n}\n//加锁\nint Lock(int* lock)\n{\n    int status;\n    status = cas(lock, 0, 1);\n    if(status == 0)\n    {\n        return 1;//加锁成功\n    }\n    return 0; //加锁失败\n}\n//解锁\nint UnLock(int* lock)\n{\n    int status;\n    status = cas(lock, 1, 0);\n    if(status == 0)\n    {\n        return 1;//解锁成功\n    }\n    return 0; //解锁失败\n}\n</code></pre><p>上述代码是一个加解锁的例子，返回1表示加、解锁操作成功；返回0表示加、解锁操作失败；lock为0表示解锁状态，为1则表示上锁状态。加、解锁操作最关键的点在于<strong>这个操作是原子的，不能被打断，而这正是LR/SC指令的作用所在。</strong></p><p>经过刚刚的调试，LR/SC指令的功能细节我们已经心中有数了。现在我们继续一起看看它的二进制数据。</p><p>打开终端，切换到工程目录下，输入命令：riscv64-unknown-elf-objdump -d ./main.elf &gt; ./main.ins，就会得到main.elf的反汇编数据文件main.ins。我们打开这个文件，就会看到它们的二进制数据，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/39/0b/39559e50b805e88c4facd4e94e2d950b.jpg?wh=1920x1021\" alt=\"图片\"></p><p>我们一起看看上图中的反汇编代码，这里编译器为了节约内存，使用了一些压缩指令，也就是RISC-V的C类扩展指令。</p><p>比如ret的机器码是0x8082，li a0，1的机器码为0x4505，它们只占用16位编码，即二字节。</p><p>上图机器码与汇编语句的对应关系如下表所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/17/f477aab470a5bc4219c3c8ab0yy0f317.jpg?wh=1920x765\" alt=\"图片\"></p><p>让我们继续一起来拆分一下LR、SC指令的各位段的数据，看看它是如何编码的。对照后面的示意图你更容易理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/13/74/13c2d631c9d0474c399d0b4233652974.jpg?wh=1920x1064\" alt=\"图片\"></p><p>LR/SC指令的操作码和功能码都是相同的，它们俩是靠27位~31位来区分的。其它的寄存器位段在前面的课程中已经介绍得相当详细了，而aq-rl位段是用来设置计算储存顺序的，使用默认的就行，这里我们就不深入研究了。</p><h3>AMO指令</h3><p>前面，我们通过例子演示了LR/SC指令如何实现锁的功能。基于此，我们给操作对象加锁，就能执行更多逻辑上的“原子”操作。但这方式也存在问题，实现起来很复杂，对于单体变量，使用这种方式代价很大。</p><p>因此AMO类的指令应运而生。这也是一类原子指令，它们相比LR/SC指令用起来更方便。因为也属于原子指令，所以每个指令完成的操作同样是不可分割，不能被外部事件打断的。</p><p><strong> AMO 是 Atomic Memory Operation 的缩写，即原子内存操作。AMO 指令又分为几类，分别是原子交换指令、原子加法指令、原子逻辑指令和原子取大小值指令。</strong></p><p>大部分调试指令的操作，我们都在前几节课里学过了，这里我们不再深入调试，只是用这些指令来写一些可执行的代码，方便我们了解其原理就行了。调试过程和前面的一样。你自己有兴趣可以自己动手调试。</p><p>首先我们来看看原子交换指令，它能执行寄存器和内存中的数据交换，并保证该操作的原子性，其汇编代码形式如下所示：</p><pre><code class=\"language-plain\">amoswap.{w/d}.{aqrl} rd,rs2,(rs1)\n#amoswap是原子交换指令\n#{可选内容}W（32位）、D（64位）\n#aqrl为内存顺序，一般使用默认的\n#rd为目标寄存器\n#rs1为源寄存器1\n#rs2为源寄存器2 \n</code></pre><p>上述代码中rd、rs1、rs2可以是任何通用寄存器。“{}\"中的可以不必填写，汇编器能根据当前的运行环境自动设置。</p><p>我们用伪代码来描述一下amoswap指令完成的操作，你会看得更清楚。</p><pre><code class=\"language-plain\">//amoswap\nrd = *rs1\n*rs1 = rs2\n</code></pre><p>观察上述伪代码，amoswap指令是把rs1中的数据当成内存地址，加载了该地址上一个32位或者64位的数据到rd寄存器中。然后把rs2中的数据，写入到rs1指向的内存单元中，实现rs2与内存单元的数据交换，该地址需要32位或者64位对齐。这两步操作是原子的、不可分割的。</p><p>下面，我们在工程目录中建立一个amo.S文件，并在其中用汇编写上amoswap_ins函数，代码如下所示：</p><pre><code class=\"language-plain\">.globl amoswap_ins\n#a0内存地址\n#a1将要交换的值\n#a0返回值\namoswap_ins:\n    amoswap.w a0, a1, (a0)  #原子交换a0=[a0]=a1\n    jr ra                   #返回\n</code></pre><p>我们直接看代码里的amoswap_ins函数，其中amoswap指令的作用是，把a0地址处的内存值读取到a0中，然后把a1的值写入a0中的地址处的内存中，完成了原子交换操作。你可以自己进入工程调试一下。</p><p>接着我们来看看原子加法指令，这类指令能把寄存器和内存中的数据相加，并把相加结果写到内存里，然后返回内存原有的值。原子加法指令的汇编代码形式如下所示。</p><pre><code class=\"language-plain\">amoadd.{w/d}.{aqrl} rd,rs2,(rs1)\n#amoadd是原子加法指令\n#{可选内容}W（32位）、D（64位）\n#aqrl为内存顺序，一般使用默认的\n#rd为目标寄存器\n#rs1为源寄存器1\n#rs2为源寄存器2 \n</code></pre><p>上述代码中除了指令符和原子交换指令不同，其它都是一样的，amoadd指令完成的操作用伪代码描述如下：</p><pre><code class=\"language-plain\">//amoadd\nrd = *rs1\n*rs1 = *rs1 + rs2\n</code></pre><p>我们观察一下amoadd指令都做了什么。它把rs1中的数据当成了内存地址，先把该地址上一个32位或者64位的数据，读到rd寄存器中。然后把rs2的数据与rs1指向的内存单元里的数据相加，结果写入到该地址的内存单元中，该地址仍需要32位或者64位对齐。这两步操作是不可分割的。</p><p>下面我们在amo.S文件中用汇编写上amoadd_ins函数，代码如下：</p><pre><code class=\"language-plain\">.globl amoadd_ins\n#a0内存地址\n#a1相加的值\n#a0返回值\namoadd_ins:\n    amoadd.w a0, a1, (a0)  #原子相加a0=[a0] [a0]=[a0] + a1\n    jr ra                  #返回\n</code></pre><p>上述代码中，amoadd_ins函数中的amoadd指令，把a0中的地址处的内存值读取到a0中，然后把a1的值与a0中的地址处的内存中的数据相加，结果写入该地址的内存单元中，这操作是原子执行的，完成了原子加法操作。指令的调试你可以课后自己练一练。</p><p>我们继续研究原子逻辑操作指令，一共有三条，分别是原子与、原子或、原子异或。它们和之前的逻辑指令功能相同，只不过它们在保证原子性的同时，还能直接对内存地址中的数据进行操作。</p><p>原子逻辑操作指令的汇编代码形式如下所示：</p><pre><code class=\"language-plain\">amoand.{w/d}.{aqrl} rd,rs2,(rs1)\namoor.{w/d}.{aqrl} rd,rs2,(rs1)\namoxor.{w/d}.{aqrl} rd,rs2,(rs1)\n#amoand是原子按位与指令\n#amoor是原子按位或指令\n#amoxor是原子按位异或指令\n#{可选内容}W（32位）、D（64位）\n#aqrl为内存顺序，一般使用默认的\n#rd为目标寄存器\n#rs1为源寄存器1\n#rs2为源寄存器2 \n</code></pre><p>上述代码中三条指令，除了指令符不同，其它是一样的，rd、rs1、rs2可以是任何通用寄存器。“{}\"中的可以不必填写，汇编器能根据当前的运行环境自动设置。</p><p>amoand、amoor、amoxor三条指令各自完成的操作，我们分别用伪代码描述一下，如下所示：</p><pre><code class=\"language-plain\">//amoand\nrd = *rs1\n*rs1 = *rs1 &amp; rs2\n//amoor\nrd = *rs1\n*rs1 = *rs1 | rs2\n//amoxor\nrd = *rs1\n*rs1 = *rs1 ^ rs2\n</code></pre><p>上面的伪代码中，都是把rs1中数据当成地址，把该地址内存单元中的数据读取到rd中，然后进行相应的按位与、或、异或操作，最后把结果写入该地址的内存单元中。这些操作是不可分割的，且地址必须对齐到处理器位宽。</p><p>下面我们在amo.S文件中用汇编写上三个函数，代码如下：</p><pre><code class=\"language-plain\">.globl amoand_ins\n#a0内存地址\n#a1相与的值\n#a0返回值\namoand_ins:\n    amoand.w a0, a1, (a0)   #原子相与a0 = [a0] [a0] = [a0] &amp; a1\n    jr ra                   #返回\n\n.globl amoor_ins\n#a0内存地址\n#a1相或的值\n#a0返回值\namoor_ins:\n    amoor.w a0, a1, (a0)    #原子相或a0 = [a0] [a0] = [a0] | a1\n    jr ra                   #返回\n\n.globl amoxor_ins\n#a0内存地址\n#a1相异或的值\n#a0返回值\namoxor_ins:\n    amoxor.w a0, a1, (a0)   #原子相异或a0 = [a0] [a0] = [a0] ^ a1\n    jr ra                   #返回\n</code></pre><p>这段代码中，amoand_ins、amoor_ins、amoxor_ins三个函数，都是把a0中数据作为地址，把该地址内存单元中的值读取到a0中。然后，再对a1的值与该地址内存单元中的数据进行与、或、异或操作，把结果写入该地址的内存单元中，这样就完成了原子与、或、异或操作。调试的思路和前面指令一样，我就不重复了。</p><p>最后，我们来看看原子取大小值的指令，它包括无符号数和有符号数版本，一共是四条指令，分别是：原子有符号取大值指令、原子无符号取大值指令、原子有符号取小值指令、原子无符号取小值指令。</p><p>汇编代码形式如下所示：</p><pre><code class=\"language-plain\">amomax.{w/d}.{aqrl} rd,rs2,(rs1)\namomaxu.{w/d}.{aqrl} rd,rs2,(rs1)\namomin.{w/d}.{aqrl} rd,rs2,(rs1)\namominu.{w/d}.{aqrl} rd,rs2,(rs1)\n#amomax是原子有符号取大值指令\n#amomaxu是原子无符号取大值指令\n#amomin是原子有符号取小值指令\n#amominu是原子无符号取小值指令\n#{可选内容}W（32位）、D（64位）\n#aqrl为内存顺序，一般使用默认的\n#rd为目标寄存器\n#rs1为源寄存器1\n#rs2为源寄存器2 \n</code></pre><p>上述代码中四条指令，除了指令符不同，其它内容是一样的。</p><p>我们用伪代码来描述一下amomax、amomaxu、amomin、amominu四条指令各自完成的操作，形式如下：</p><pre><code class=\"language-plain\">max(a,b)\n{\n    if(a &gt; b)\n        return a;\n    else\n        return b;\n}\nmin(a,b)\n{\n    if(a &lt; b)\n        return a;\n    else\n        return b;\n}\nexts(a)\n{\n    return 扩展符号(a)\n}\n//amomax\nrd = *rs1\n*rs1 = max(exts(*rs1),exts(rs2))\n//amomaxu\nrd = *rs1\n*rs1 = *rs1 = max(*rs1,rs2)\n//amomin\nrd = *rs1\n*rs1 = min(exts(*rs1),exts(rs2))\n//amominu\nrd = *rs1\n*rs1 = *rs1 = min(*rs1,rs2)\n</code></pre><p>观察上面的伪代码，我们可以看到max函数可以返回两数之间的大数、min函数可以返回两数之间的小数，exts函数负责处理数据的符号。</p><p>我们对比学习这几条指令，理解起来更容易。上面的amomax、amomaxu指令都是把rs1中数据当成地址，把该地址内存单元中的数据读取到rd中，然后与rs2进行比较。最后，把两者之间大的那个数值写入该地址的内存单元中，区别是比较时的数据有无符号。</p><p>而amomin、amominu指令则是把rs1中数据当成地址，把该地址内存单元中的数据读取到rd中，然后与rs2进行比较，最后把两者之间小的数值写入该地址的内存单元中。这两个指令的区别同样是比较时的数据有无符号。</p><p>下面我们在amo.S文件中用汇编写上四个函数，代码如下所示：</p><pre><code class=\"language-plain\">.globl amomax_ins\n#a0内存地址\n#a1相比的值\n#a0返回值\namomax_ins:\n    amomax.w a0, a1, (a0)   #原子相与a0 = [a0] [a0] = max([a0] , a1)\n    jr ra                   #返回\n\n.globl amomaxu_ins\n#a0内存地址\n#a1相比的值\n#a0返回值\namomaxu_ins:\n    amomaxu.w a0, a1, (a0)   #原子相与a0 = [a0] [a0] = maxu([a0] , a1)\n    jr ra                   #返回\n\n.globl amomin_ins\n#a0内存地址\n#a1相比的值\n#a0返回值\namomin_ins:\n    amomin.w a0, a1, (a0)   #原子相与a0 = [a0] [a0] = min([a0] , a1)\n    jr ra                   #返回\n\n.globl amominu_ins\n#a0内存地址\n#a1相比的值\n#a0返回值\namominu_ins:\n    amominu.w a0, a1, (a0)   #原子相与a0 = [a0] [a0] = minu([a0] , a1)\n    jr ra                    #返回\n</code></pre><p>上述代码中，amomax_ins、amomaxu_ins、amomin_ins、amominu_ins四个函数，都是把a0中数据作为地址，把该地址内存单元中的值读取到a0中，然后把a1的值与该地址内存单元中的数据进行比较操作，结果取大或者取小，最后把结果写入该地址的内存单元中，这些操作都是原子执行的、不可分割。你可以自己进入工程调试一下。</p><p>下面我们一起把这些amo指令进行测试，相关代码我已经帮你写好了，我们工程项目按下“F5”来调试。下面是指令调用后的打印结果截图，你可以对照一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/98/d446903195a61cc8fddd5f9326e53a98.jpg?wh=1920x1021\" alt=\"图片\"></p><p>截图中的输出与我们预期的结果分毫不差，这说明我们用相关指令编写的汇编函数所完成的功能是正确无误的。</p><p>至此，关于RISC-V所有的原子指令，一共有11条指令，我们就全部学完了。这些指令分别完成不同的功能，重要的是它们的原子特性，特别是AMO类指令，在处理一些全局共享的单体变量时相当有用。</p><h3>重点回顾</h3><p>现在我们一起来回顾一下今天所学内容。</p><p>首先，我们讨论了为什么一款芯片需要有原子指令，从这里入手来了解原子指令的特性，它具有操作不可分割性。所以，原子指令是现代高级通用芯片里不可缺少的，是系统软件或者应用软件现实共享数据保护，维护共享数据一致性的重要基础依赖设施。</p><p>RISC-V的原子指令中包含两部分，分别是LR/SC指令和AMO指令。</p><p>LR/SC指令必须成对使用，才能达到原子效果，在执行LR指令的同时，处理器会设置相应的标志位，用于监控其内存地址上有没有其它hart访问，有没有产生中断异常，有没有执行MRET指令。只要发生上述情况里的一种，就会导致SC指令执行失败。通过这样的规则，才能确保LR与SC指令之间的操作是原子的。</p><p>不过，有时候LR/SC指令用起来还是挺复杂的，所以AMO类指令（即原子内存操作）应运而生。RISC-V提供了一系列AMO类指令，它们是原子交换指令、原子加法指令、原子逻辑指令、原子取大小指令，这些指令相比LR、SC指令，使用起来更加方便。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/14/81306a794e7d25434da842a490dea514.jpg?wh=1920x1741\" alt=\"图片\"></p><h3>思考题</h3><p>请你尝试用LR、SC指令实现自旋锁。</p><p>期待你在留言区记录自己的收获，或者向我提问。如果觉得这节课还不错，别忘了推荐给身边更多朋友，跟他一起学习进步。</p>","comments":[{"had_liked":false,"id":356897,"user_name":"苏流郁宓","can_delete":false,"product_type":"c1","uid":2729645,"ip_address":"湖北","ucode":"AD07BD9CE03047","user_header":"https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg","comment_is_top":false,"comment_ctime":1662689278,"is_pvip":false,"replies":[{"id":129925,"content":"是的  ","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1662884645,"ip_address":"湖北","comment_id":356897,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"原子指令模式（要么都执行，要么就只能返回到都不执行），随着cpu单核逼近物理极限，那么 相比于冯诺依曼结构 （原子模式随着核增多，维护数据一致浪费时间越多） 哈佛结构有没有它的优点？在多核模式下 部分领域优于冯诺依曼结构的？","like_count":2,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587207,"discussion_content":"是的  ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662884645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366560,"user_name":"Bean","can_delete":false,"product_type":"c1","uid":2743176,"ip_address":"陕西","ucode":"B953896F73126A","user_header":"https://static001.geekbang.org/account/avatar/00/29/db/88/cc6078eb.jpg","comment_is_top":false,"comment_ctime":1673926447,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"老师好，有个地方不是很明白\n代码中：\namoadd.w a0, a1, (a0)  #原子相加a0=[a0] [a0]=[a0] + a1\n\n翻译后的两条指令，执行过程是否有先后顺序？\n如果有先后顺序，那么执行 a0=[a0] 时，是否a0的值已经更新，之后的 [a0]=[a0] + a1 是按照赋值(更新)后 a0 的值作为寻址地址，进行操作？","like_count":0}]}