{"id":180225,"title":"13丨软件设计的里氏替换原则：正方形可以继承长方形吗？","content":"<p>我们都知道，面向对象编程语言有三大特性：封装、继承、多态。这几个特性也许可以很快就学会，但是如果想要用好，可能要花非常多的时间。</p><p>通俗地说，接口（抽象类）的多个实现就是多态。多态可以让程序在编程时面向接口进行编程，在运行期绑定具体类，从而使得类之间不需要直接耦合，就可以关联组合，构成一个更强大的整体对外服务。绝大多数设计模式其实都是利用多态的特性玩的把戏，前面两篇学习的开闭原则和依赖倒置原则也是利用多态的特性。正是多态使得编程有时候像变魔术，如果能用好多态，可以说掌握了大多数的面向对象编程技巧。</p><p>封装是面向对象语言提供的特性，将属性和方法封装在类里面。用好封装的关键是，知道应该将哪些属性和方法封装在某个类里。一个方法应该封装进A类里，还是B类里？这个问题其实就是如何进行对象的设计。深入研究进去，里面也有大量的学问。</p><p>继承似乎比多态和封装要简单一些，但实践中，继承的误用也很常见。</p><h2>里氏替换原则</h2><p>关于如何设计类的继承关系，怎样使继承不违反开闭原则，实际上有一个关于继承的设计原则，叫里氏替换原则。这个原则说：若对每个类型T1的对象o1，都存在一个类型T2的对象o2，使得在所有针对T2编写的程序P中，用o1替换o2后，程序P的行为功能不变，则T1是T2的子类型。</p><!-- [[[read_end]]] --><p>上面这句话比较学术，通俗地说就是：<strong>子类型必须能够替换掉它们的基类型</strong>。</p><p>再稍微详细点说，就是：程序中，所有使用基类的地方，都应该可以用子类代替。</p><p>语法上，任何类都可以被继承。但是一个继承是否合理，从继承关系本身是看不出来的，需要把继承放在应用场景的上下文中去判断，使用基类的地方，是否可以用子类代替？</p><p>这里有一个马的继承设计：</p><p><img src=\"https://static001.geekbang.org/resource/image/98/e7/984d7307bb1af311ba1bbcd92dee15e7.png?wh=404*300\" alt=\"\"></p><p>白马和小马驹都是马，所以都继承了马。这样的继承是不是合理呢？我们需要放到应用场景中：</p><p><img src=\"https://static001.geekbang.org/resource/image/4e/e6/4ec36b118e23d98732a68d26bb5a2de6.png?wh=764*318\" alt=\"\"></p><p>在这个场景中，是人骑马。根据这里的关系，继承了马的白马和小马驹，应该都可以代替马。白马代替马当然没有问题，人可以骑白马，但是小马驹代替马可能就不合适了，因为小马驹还没长好，无法被人骑。</p><p>那么很显然，作为子类的白马可以替换掉基类马，但是小马不能替换马，因此小马继承马就不太合适了，违反了里氏替换原则。</p><h2>一个违反里氏替换规则的例子</h2><p>我们再看这样一段代码：</p><pre><code>void drawShape(Shape shape) {\n    if (shape.type == Shape.Circle ) {\n        drawCircle((Circle) shape);\n    } else if (shape.type == Shape.Square) {\n        drawSquare((Square) shape);\n    } else {\n        ……\n    }\n}\n</code></pre><p>这里Circle和Square继承了基类Shape，然后在应用的方法中，根据输入Shape对象类型进行判断，根据对象类型选择不同的绘图函数将图形画出来。这种写法的代码既常见又糟糕，它同时违反了开闭原则和里氏替换原则。</p><p>首先看到这样的if/else代码，就可以判断违反了开闭原则：当增加新的Shape类型的时候，必须修改这个方法，增加else if代码。</p><p>其次也因为同样的原因违反了里氏替换原则：当增加新的Shape类型的时候，如果没有修改这个方法，没有增加else if代码，那么这个新类型就无法替换基类Shape。</p><p>要解决这个问题其实也很简单，只需要在基类Shape中定义draw方法，所有Shape的子类，Circle、Square都实现这个方法就可以了：</p><pre><code>public abstract Shape{\n  public abstract void draw();\n}\n</code></pre><p>上面那段drawShape()代码也就可以变得更简单：</p><pre><code>void drawShape(Shape shape) {\n  shape.draw();\n}\n</code></pre><p>这段代码既满足开闭原则：增加新的类型不需要修改任何代码。也满足里氏替换原则：在使用基类的这个方法中，可以用子类替换，程序正常运行。</p><h2>正方形可以继承长方形吗？</h2><p>一个继承设计是否违反里氏替换原则，需要在具体场景中考察。我们再看一个例子，假设我们现在有一个长方形的类，类定义如下：</p><pre><code>public class Rectangle {\n    private double width;\n    private double height;\n    public void setWidth(double w) { width = w; }\n    public void setHeight(double h) { height = h; }\n    public double getWidth() { return width; }\n    public double getHeight() { return height; }\n    public double calculateArea() {return width * height;}\n}\n</code></pre><p>这个类满足我们的应用场景，在程序中多个地方被使用，一切良好。但是现在，我们有个新需求，我们还需要一个正方形。</p><p>通常，我们判断一个继承是否合理，会使用“IS A”进行判断，类B可以继承类A，我们就说类B IS A 类A，比如白马IS A 马，轿车 IS A 车。</p><p>那正方形是不是IS A长方形呢？通常我们会说，正方形是一种特殊的长方形，是长和宽相等的长方形，从这个角度讲，那么正方形IS A长方形，也就是可以继承长方形。</p><p>具体实现上，我们只需要在设置长方形的长或宽的时候，同时设置长和宽就可以了，如下：</p><pre><code>public class Square extends Rectangle {\n    public void setWidth(double w) {\n        width = height = w;\n    }\n    public void setHeight(double h) {\n        height = width = w;\n    }\n}\n</code></pre><p>这个正方形类设计看起来很正常，用起来似乎也没有问题。但是，真的没有问题吗？</p><p>继承是否合理我们需要用里氏替换原则来判断。之前也说过，是否合理并不是从继承的设计本身看，而是从应用场景的角度看。如果在应用场景中，也就是在程序中，子类可以替换父类，那么继承就是合理的，如果不能替换，那么继承就是不合理的。</p><p>这个长方形的使用场景是什么样的呢，我们看使用代码：</p><pre><code>void testArea(Rectangle rect) {\n    rect.setWidth(3);\n    rect.setHeight(4);\n    assert 12 == rect.calculateArea(); \n}\n</code></pre><p>显然，在这个场景中，如果用子类Square替换父类Rectangle，计算面积calculateArea将返回16，而不是12，程序是不能正确运行的，这样的继承不满足里氏替换原则，是不合适的继承。</p><h2>子类不能比父类更严格</h2><p>类的公有方法其实是对使用者的一个契约，使用者按照这个契约使用类，并期望类按照契约运行，返回合理的值。</p><p>当子类继承父类的时候，根据里氏替换原则，使用者可以在使用父类的地方使用子类替换，那么从契约的角度，子类的契约就不能比父类更严格，否则使用者在用子类替换父类的时候，就会因为更严格的契约而失败。</p><p>在上面这个例子中，正方形继承了长方形，但是正方形有比长方形更严格的契约，即正方形要求长和宽是一样的。因为正方形有比长方形更严格的契约，那么在使用长方形的地方，正方形因为更严格的契约而无法替换长方形。</p><p>我们开头小马继承马的例子也是如此，小马比马有更严格的要求，即不能骑，那么小马继承马就是不合适的。</p><p>在类的继承中，如果父类方法的访问控制是protected，那么子类override这个方法的时候，可以改成是public，但是不能改成private。因为private的访问控制比protected更严格，能使用父类protected方法的地方，不能用子类的private方法替换，否则就是违反里氏替换原则的。相反，如果子类方法的访问控制改成public就没问题，即子类可以有比父类更宽松的契约。同样，子类override父类方法的时候，不能将父类的public方法改成protected，否则会出现编译错误。</p><p>通常说来，子类比父类的契约更严格，都是违反里氏替换原则的。</p><p>子类不应该比父类更严格，这个原则看起来既合理又简单，但是在实际中，如果你不严谨地审视自己的设计，是很可能违背里氏替换原则的。</p><p>在JDK中，类Properties继承自类Hashtable，类Stack继承自Vector。</p><p><img src=\"https://static001.geekbang.org/resource/image/48/c4/489a0c187c2f89ca7aee52cba59816c4.png?wh=456*241\" alt=\"\"></p><p>这样的设计，其实是违反里氏替换原则的。Properties要求处理的数据类型是String，而它的父类Hashtable要求处理的数据类型是Object，子类比父类的契约更严格；Stack是一个栈数据结构，数据只能后进先出，而它的父类Vector是一个线性表，子类比父类的契约更严格。</p><p>这两个类都是从JDK1就已经存在的，我想，如果能够重新再来，JDK的工程师一定不会这样设计。这也从另一个方面说明，不恰当的继承是很容易就发生的，设计继承的时候，需要更严谨的审视。</p><h2>小结</h2><p>实践中，当你继承一个父类仅仅是为了复用父类中的方法的时候，那么很有可能你离错误的继承已经不远了。一个类如果不是为了被继承而设计，那么最好就不要继承它。粗暴一点地说，如果不是抽象类或者接口，最好不要继承它。</p><p>如果你确实需要使用一个类的方法，最好的办法是组合这个类而不是继承这个类，这就是人们通常说的<strong>组合优于继承</strong>。比如这样：</p><pre><code>Class A{\n public Element query(int id){...}\n public void modify(Element e){...}\n}\n\nClass B{\n  private A a;\n  public Element select(int id){\n    a.query(id);\n  } \n   public void modify(Element e){\n     a.modify(e);\n   }\n}\n</code></pre><p>如果类B需要使用类A的方法，这时候不要去继承类A，而是去组合类A，也能达到使用类A方法的效果。这其实就是<strong>对象适配器模式</strong>了，使用这个模式的话，类B不需要继承类A，一样可以拥有类A的方法，同时还有更大的灵活性，比如可以改变方法的名称以适应应用接口的需要。</p><p>当然，继承接口或者抽象类也并不保证你的继承设计就是正确的，最好的方法还是用里氏替换原则检查一下你的设计：使用父类的地方是不是可以用子类替换？</p><p>违反里氏替换原则不仅仅发生在设计继承的地方，也可能发生在使用父类和子类的地方，错误的使用方法，也可能导致程序违反里氏替换原则，使子类无法替换父类。</p><h2>思考题</h2><p>下面给你留一道思考题吧。</p><p>父类中有抽象方法f，抛出异常AException：</p><pre><code>public abstract void f() throws AException;\n</code></pre><p>子类override父类这个方法后，想要将抛出的异常改为BException，那么BException应该是AException的父类还是子类？</p><p>为什么呢？请你用里氏替换原则说明，并在评论区写下你的思考，我会和你一起交流，也欢迎你把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","comments":[{"had_liked":false,"id":163999,"user_name":"俊杰","can_delete":false,"product_type":"c1","uid":1020008,"ip_address":"","ucode":"197C1CB1D48CB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/68/511fc1e5.jpg","comment_is_top":false,"comment_ctime":1576843881,"is_pvip":false,"replies":[{"id":"62451","content":"√","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1576983672,"ip_address":"","comment_id":163999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"169080568425","product_id":100040201,"comment_content":"BException应该是AException的子类，否则当使用子类替换父类后，抛出的BException无法被catch(AException e)语句捕获","like_count":40,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478612,"discussion_content":"√","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576983672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164277,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1576921294,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"61706463438","product_id":100040201,"comment_content":"里氏替换原则 要求子类可以无缝的替换父类，比父类更松。<br><br>但是在实际的开发中，往往是子类比父类更加严格，细化到适合使用在某一应用场景下，目的性越来越明确<br><br>父类的设计只是一个比较宽松的限制，子类继承然后重写在某一具体场景下的逻辑","like_count":15,"discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308491,"discussion_content":"虽然“子类比父类更加严格”在日常的开发中比较常见，但我倾向于认为，这可能是一种误用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600961306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292675,"discussion_content":"我也很疑惑 感觉老师可以再讲充分一些 为什么正方形不能继承长方形","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595304117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2820632,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/0a/18/cdfd70ad.jpg","nickname":"LetMeCode","note":"","ucode":"AD6D729D42BB44","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":580463,"discussion_content":"正方形只要1条边长，长方形有2个。所以正方形比长方形 &#34;小&#34;,无法转为长方形","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658194801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292675,"ip_address":""},"score":580463,"extra":""}]},{"author":{"id":1185295,"avatar":"https://static001.geekbang.org/account/avatar/00/12/16/0f/0cd4d657.jpg","nickname":"蓝色基因","note":"","ucode":"C9ADCF38BA05FF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553953,"discussion_content":"的确，我在实际开发中也是如此，比如，做一个第三方绑定的功能，基类是抽象类，名为3rdPartyAccountBinding，具体到各个第三方，则更为具体，比如：MeituanAccountBinding，QqAccountBinding，完看了这节课，完全违法了这个原则，要好好省事一下了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646143075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1185295,"avatar":"https://static001.geekbang.org/account/avatar/00/12/16/0f/0cd4d657.jpg","nickname":"蓝色基因","note":"","ucode":"C9ADCF38BA05FF","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":589117,"discussion_content":"个人认为具体化不一定违反LSP，如你上面的场景，基类作为抽象类并没有实现，具体实现是由具体的各个第三方类实现的，在运行期根据实际的子类运行绑定，基类作为抽象类，没有实例化的可能，也不会违反LSP。这种情况，相当于基类只是提供了方法的契约，定义了入参和出参等，而子类必须实现该契约，并且必须遵守该契约。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1664430292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553953,"ip_address":"上海"},"score":589117,"extra":""}]},{"author":{"id":2418763,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e8/4b/8ddf36b0.jpg","nickname":"程同学","note":"","ucode":"622B71D5A2DA5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343478,"discussion_content":"嗯，里氏替换原则较反常识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611057731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163738,"user_name":"观弈道人","can_delete":false,"product_type":"c1","uid":1016905,"ip_address":"","ucode":"F3BB619A33C605","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","comment_is_top":false,"comment_ctime":1576784459,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27346588235","product_id":100040201,"comment_content":"BException应该是AAexception的子类","like_count":6,"discussions":[{"author":{"id":1039475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dc/73/9ab38243.jpg","nickname":"xiaoxionga","note":"","ucode":"2BB02B54C31EBF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91154,"discussion_content":"应该是父类。子类比较“严格”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576814362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1039475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dc/73/9ab38243.jpg","nickname":"xiaoxionga","note":"","ucode":"2BB02B54C31EBF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308492,"discussion_content":"可以写段代码试一下\n\npublic class LiskovSubstitution {\n    public abstract class Parent {\n        public abstract void f() throws AException;\n    }\n\n    public class Child extends Parent {\n        @Override\n        public void f() throws BException {\n            System.out.println(&#34;Child&#34;);\n        }\n    }\n\n    class AException extends Exception {\n    }\n\n    class BException extends AException {\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600961340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":91154,"ip_address":""},"score":308492,"extra":""}]}]},{"had_liked":false,"id":175068,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1580545345,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23055381825","product_id":100040201,"comment_content":"子类<br>根据里氏变换，父类比子类更严格<br>=&gt; 子类的方法严格性小于父类的<br>=&gt; AException 严格性 大于 BException<br>=&gt; AException 是 BException的父类","like_count":5},{"had_liked":false,"id":163792,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1576803675,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18756672859","product_id":100040201,"comment_content":"BExpection应该是AExpection的父类，子类不能比父类抛的更广，否则，使用父类的地方没法处理","like_count":4,"discussions":[{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91057,"discussion_content":"那不是应该BException应该是AException的子类吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576807577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163832,"user_name":"陈小龙 Cheney","can_delete":false,"product_type":"c1","uid":1328689,"ip_address":"","ucode":"4B721FE4DDB2F4","user_header":"https://static001.geekbang.org/account/avatar/00/14/46/31/cb061c09.jpg","comment_is_top":false,"comment_ctime":1576808913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14461710801","product_id":100040201,"comment_content":"BException应该是AException的子类。<br>因为子类必须能够替换掉父类，因此子类抛出的异常，原先处理父类的代码必须能够处理。那么子类抛出的BEception就应当是AEception的子类，才能被处理父类异常的代码正确处理。<br>","like_count":3},{"had_liked":false,"id":169168,"user_name":"难得糊涂ck","can_delete":false,"product_type":"c1","uid":1255826,"ip_address":"","ucode":"9C9E248E4F1A6F","user_header":"https://static001.geekbang.org/account/avatar/00/13/29/92/131296a8.jpg","comment_is_top":false,"comment_ctime":1578283118,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10168217710","product_id":100040201,"comment_content":"我觉得白马和小马驹集成马没有任何问题，关键是少了一个接口 - 是否可以骑乘<br>显然白马可以<br>小马驹不可以","like_count":3,"discussions":[{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589119,"discussion_content":"白马和小马驹可以继承马的各种属性和行为（不包括骑乘），通过继承体现共性，但是小白驹无法被骑乘，可以通过接口隔离体现差异，通过合理的设计，不一定和LSP不冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664430731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164802,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1577093191,"is_pvip":false,"replies":[{"id":"62808","content":"亲，不建议继承具体类呢，优先考虑组合而不是继承具体类~","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1577099367,"ip_address":"","comment_id":164802,"utype":1}],"discussion_count":5,"race_medal":0,"score":"10167027783","product_id":100040201,"comment_content":"老师你看一下，能不能长方形继承正方形，既然正向不行，那就反向操作。<br>正方形作为父类，它更严格，长方形作为继承，正方形获取边长getLong（），长方形是getLong（String <br> type）。","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478898,"discussion_content":"亲，不建议继承具体类呢，优先考虑组合而不是继承具体类~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577099367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1933191,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kLy68licCYb9N4dzLWqOqAiaiaDqWSQpFYen2f5wqtwQtxj6T0cerE1icJUMeF2o7ZGtoicKCGAxqwUYrebkq5aCjng/132","nickname":"豁豁哒","note":"","ucode":"1ED540DD2AA822","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236653,"discussion_content":"长方形和正方形都继承（或者实现）四边形不行吗？我怎么感觉设计模式这个东西，没有一个放之四海而皆准的标准呢？比如这个例子，看着懂了，感觉也说明白了，其实遇到问题还是不会解决","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587113000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1933191,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kLy68licCYb9N4dzLWqOqAiaiaDqWSQpFYen2f5wqtwQtxj6T0cerE1icJUMeF2o7ZGtoicKCGAxqwUYrebkq5aCjng/132","nickname":"豁豁哒","note":"","ucode":"1ED540DD2AA822","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308496,"discussion_content":"长方形和正方形都继承四边形应该可以，但是四边形本身很难提取公共的属性和方法。如果不是长方形或者正方形，长和高的定义都会遇到问题，算面积和周长更困难。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600961633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":236653,"ip_address":""},"score":308496,"extra":""}]},{"author":{"id":1933191,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kLy68licCYb9N4dzLWqOqAiaiaDqWSQpFYen2f5wqtwQtxj6T0cerE1icJUMeF2o7ZGtoicKCGAxqwUYrebkq5aCjng/132","nickname":"豁豁哒","note":"","ucode":"1ED540DD2AA822","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236661,"discussion_content":"我现在遇到一个问题，要对接两种邮箱推送系统，两者需要的参数大致相同，可以提取公共的东西，发送邮件的方式不相同，我想屏蔽发送邮件的方式，一直没想到合适的方案，用适配器吧，感觉也行，用策略吧，感觉也行，不知道怎么做了，后期还要进行扩展，比如我想使用责任链模式在刚才的基础上串联起来所有的发送邮件实现类。这个让我一个小白无从下手啊！求老师和各位大佬指导。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587113499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1933191,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/kLy68licCYb9N4dzLWqOqAiaiaDqWSQpFYen2f5wqtwQtxj6T0cerE1icJUMeF2o7ZGtoicKCGAxqwUYrebkq5aCjng/132","nickname":"豁豁哒","note":"","ucode":"1ED540DD2AA822","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308494,"discussion_content":"不知道你最后是如何实现的，我觉得可能适配器模式应该能解决，而且比较简单。但是策略模式应该也可以用，看具体的情况了，有点像开闭原则那一节的例子，其实几个设计模式都可以用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600961545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":236661,"ip_address":""},"score":308494,"extra":""}]}]},{"had_liked":false,"id":279918,"user_name":"pinteressante","can_delete":false,"product_type":"c1","uid":1007569,"ip_address":"","ucode":"C17A89E655CC84","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/d1/faf32296.jpg","comment_is_top":false,"comment_ctime":1614000264,"is_pvip":false,"replies":[{"id":"101802","content":"继承的关键词是extends，就是“扩展”的意思。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1614216701,"ip_address":"","comment_id":279918,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5908967560","product_id":100040201,"comment_content":"这个概念从理解上来说还是比较混沌和违反直觉的. 子类这里的子从字面上理解就是小, 又很容易联想到子集的概念,而一个集合的子集是小于等于自己的. <br>那么里氏替换原则讲到可以用&quot;子类不能比父类更严格&quot;就会让人在理解上产生困惑:<br>1. 如果可以替换我干嘛要用子类呢?换句话说,如果只是同级别的类干嘛要产生父子关系,直接定义不就好了?或者说,定义了一些类,抽取他们的共性变成父类,这不就又成了里氏替换原则的反例了么?<br>2. 如果我目的就是为了缩小范围而不是扩大范围或者范围不变,我定义子类难道还&quot;犯错了&quot;吗?<br>3. 常见的场景是什么呢?<br>","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515923,"discussion_content":"继承的关键词是extends，就是“扩展”的意思。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614216701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272526,"user_name":"pinteressante","can_delete":false,"product_type":"c1","uid":1007569,"ip_address":"","ucode":"C17A89E655CC84","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5f/d1/faf32296.jpg","comment_is_top":false,"comment_ctime":1610113349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5905080645","product_id":100040201,"comment_content":"只有反例, 这里可以列举一个正例吗? 想知道子类大于父类的正确案例.","like_count":1},{"had_liked":false,"id":172771,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1579279868,"is_pvip":false,"replies":[{"id":"67027","content":"不违法，抽象方法的正确用法。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1579316643,"ip_address":"","comment_id":172771,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5874247164","product_id":100040201,"comment_content":"满满的干货<br><br>子类不能抛出比父类无法catch的异常-因此应该要是AException子类<br><br>现实开发中往往经常看到，不同的子类实现了不同的具体方法，而父类只是一个抽象方法。<br>在方法入口处传入用父类作为形参来接受参数，而在其中又调用父类.abstractMethod();<br><br>class abstracr A{<br>    void abstract f();<br>}<br><br>class X extneds A {<br>    void f(){<br>        pribt(&quot;x&quot;);<br>    }<br>}<br><br>class Y extends A {<br>    void f(){<br>        print(&quot;y&quot;);<br>    }<br>}<br><br>&#47;&#47; test(A a);<br><br>void test(A a){<br>    a.f();<br>}<br><br>老师，这个test(A a); 的使用 ，或者这两个类 X Y, 有违反里氏替换原则吗? (手机输入的)","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481845,"discussion_content":"不违法，抽象方法的正确用法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579316643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164570,"user_name":"Citizen Z","can_delete":false,"product_type":"c1","uid":1125104,"ip_address":"","ucode":"9CA547640A8629","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/f0/41590e10.jpg","comment_is_top":false,"comment_ctime":1577028908,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5871996204","product_id":100040201,"comment_content":"假如 AException extends BException<br><br>Father f = new Child();<br>try {<br>    father.f();  &#47;&#47; throws BException<br>}<br>catch (AException e) {<br>}<br>&#47;&#47; BException escaped<br><br>所以应该是子类应继承父类 Exception，收敛错误，否则子类看起来突破了父类语义范围，即“使用父类的地方将无法使用其他子类”","like_count":1},{"had_liked":false,"id":351783,"user_name":"LetMeCode","can_delete":false,"product_type":"c1","uid":2820632,"ip_address":"","ucode":"AD6D729D42BB44","user_header":"https://static001.geekbang.org/account/avatar/00/2b/0a/18/cdfd70ad.jpg","comment_is_top":false,"comment_ctime":1658194880,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658194880","product_id":100040201,"comment_content":"没有很深的代码功底领悟不出来这些内容，很有收获，感谢老师！","like_count":0},{"had_liked":false,"id":349905,"user_name":"java小霸王","can_delete":false,"product_type":"c1","uid":1168540,"ip_address":"","ucode":"7094BCD9F25E1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/9c/030e80d3.jpg","comment_is_top":false,"comment_ctime":1656420779,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1656420779","product_id":100040201,"comment_content":"什么场景适合用继承呢","like_count":0,"discussions":[{"author":{"id":1168540,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d4/9c/030e80d3.jpg","nickname":"java小霸王","note":"","ucode":"7094BCD9F25E1E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579849,"discussion_content":"抽象类，或者为了具有基类特性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657712813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333999,"user_name":"蝴蝶","can_delete":false,"product_type":"c1","uid":1193167,"ip_address":"","ucode":"8019924D99182F","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/cf/0a316b48.jpg","comment_is_top":false,"comment_ctime":1644660280,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644660280","product_id":100040201,"comment_content":"我觉得是子类.","like_count":0},{"had_liked":false,"id":298422,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":2425556,"ip_address":"","ucode":"5E57A0FE948966","user_header":"https://static001.geekbang.org/account/avatar/00/25/02/d4/1e0bb504.jpg","comment_is_top":false,"comment_ctime":1624093819,"is_pvip":false,"replies":[{"id":"108329","content":"protected 是的。<br>PS：private方法子类不可见，也就不存在override。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1624240645,"ip_address":"","comment_id":298422,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1624093819","product_id":100040201,"comment_content":"在类的继承中，如果父类方法的访问控制是 protected，那么子类 override 这个方法的时候，可以改成是 public，但是不能改成 private。因为 private 的访问控制比 protected 更严格，能使用父类 protected 方法的地方，不能用子类的 private 方法替换，否则就是违反里氏替换原则的。<br><br>想问下，这个针对protected继承或者private继承也适用的吗？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522133,"discussion_content":"protected 是的。\nPS：private方法子类不可见，也就不存在override。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624240645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280543,"user_name":"雨天","can_delete":false,"product_type":"c1","uid":1056406,"ip_address":"","ucode":"FD9FB404ECA463","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/96/3162d51f.jpg","comment_is_top":false,"comment_ctime":1614245113,"is_pvip":false,"replies":[{"id":"101896","content":"1 违反原则很可能意味着你的程序设计不良（也不是绝对），而不是不能运行。<br>2 子类替换父类是用来验证继承设计是否良好，不是真的要把代码中的父类替换了。。。没有意义啊。。。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1614318929,"ip_address":"","comment_id":280543,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1614245113","product_id":100040201,"comment_content":"老师,请教两个问题<br>1.里氏替换原则是关注程序能正常运行,还是系统的逻辑不变(行为功能不变);如果只是程序能正常运行的话,基本上可以说里氏替换原则很难被违反;毕竟基类能被调用的方法,子类一定有;但是如果逻辑不变的话,则子类不能重写父类的非抽象方法?<br>2.void drawShape(Shape shape) { shape.draw();}中如果用Square直接替换Shape肯定也是不行的;这样的话,就不能接受Circle,即没有多态;这是不是和里式替换有点矛盾?","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516129,"discussion_content":"1 违反原则很可能意味着你的程序设计不良（也不是绝对），而不是不能运行。\n2 子类替换父类是用来验证继承设计是否良好，不是真的要把代码中的父类替换了。。。没有意义啊。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614318929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589121,"discussion_content":"LSP的替换是运行时替换，不是设计时替换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664431104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259071,"user_name":"BIZ_DATA_3","can_delete":false,"product_type":"c1","uid":1655763,"ip_address":"","ucode":"CC39E6E8805CB1","user_header":"","comment_is_top":false,"comment_ctime":1604626634,"is_pvip":false,"replies":[{"id":"94417","content":"小结里讲了，使用适配器模式，用组合而不是继承","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1604891034,"ip_address":"","comment_id":259071,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604626634","product_id":100040201,"comment_content":"&quot;这两个类都是从 JDK1 就已经存在的，我想，如果能够重新再来，JDK 的工程师一定不会这样设计。这也从另一个方面说明，不恰当的继承是很容易就发生的，设计继承的时候，需要更严谨的审视。&quot;<br><br>李老师能否能够给一些更合理的设计，这样更容易让读者理解","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508834,"discussion_content":"小结里讲了，使用适配器模式，用组合而不是继承","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604891034,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258504,"user_name":"花树","can_delete":false,"product_type":"c1","uid":1542107,"ip_address":"","ucode":"810A5B42EEE264","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/db/c132ef37.jpg","comment_is_top":false,"comment_ctime":1604466144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604466144","product_id":100040201,"comment_content":"文中有一处：这样的设计，其实是违反里氏替换原则的。Properties 要求处理的数据类型是 String，而它的父类 Hashtable 要求处理的数据类型是 Object，子类比父类的契约更严格<br><br>那这里，如果使用父类的地方都可以使用子类这个原则来想，object可以接受一个string的变量，如果反过来父类真的用string来接受object是不是就出大事了。所以父类有时是不是不能太严格。","like_count":0},{"had_liked":false,"id":250180,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1600962170,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1600962170","product_id":100040201,"comment_content":"再次膜拜李老师的举例子能力，小马的例子很好的说明了里氏替换规则。<br><br>正方形不能继承长方形的例子有点诡异，不过从“子类不能比父类更严格”的标准来说，也没有什么奇怪的。可能应该更多的考虑组合，或者是面向接口编程什么的，而不是一说面向对象，就想着继承。<br><br>在没有看到留言之前，我觉的子类抛出的异常 BException 应该是 AException 的父类。后来简单的写了一段代码，发现自己想多了。<br><br>public class LiskovSubstitution {<br>    public abstract class Parent {<br>        public abstract void f() throws AException;<br>    }<br><br>    public class Child extends Parent {<br>        @Override<br>        public void f() throws BException {<br>            System.out.println(&quot;Child&quot;);<br>        }<br>    }<br><br>    class AException extends Exception {<br>    }<br><br>    class BException extends AException {<br>    }<br>}<br><br>如果改变 AException 和 BException 的继承关系，那么很有可能会得到 “cannot override f()” 的报错信息。<br><br>其实我觉的写代码有意思的地方就在于可以验证自己的想法。","like_count":0},{"had_liked":false,"id":247129,"user_name":"老炮","can_delete":false,"product_type":"c1","uid":2103593,"ip_address":"","ucode":"4FDFAD31BB393E","user_header":"https://static001.geekbang.org/account/avatar/00/20/19/29/e5af775c.jpg","comment_is_top":false,"comment_ctime":1599615620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599615620","product_id":100040201,"comment_content":"人骑马的例子，我觉得的是调用者不合理，而不是小马不能继承马。","like_count":1},{"had_liked":false,"id":245176,"user_name":"vega","can_delete":false,"product_type":"c1","uid":1748242,"ip_address":"","ucode":"5872FDA0974091","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJPNsfvnqsB8eTbKgzwIOhcKkzCTUSoAyujl8MtiazpP07zUfboOaWJaZK2jfRVH6S2ibXEc7WIibufA/132","comment_is_top":false,"comment_ctime":1598855630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598855630","product_id":100040201,"comment_content":"显然是B是A的子类,不然try catch的时候会抓不住","like_count":0},{"had_liked":false,"id":205705,"user_name":"微凉","can_delete":false,"product_type":"c1","uid":1178156,"ip_address":"","ucode":"F6BD0AE11AE224","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/2c/9a0c45e6.jpg","comment_is_top":false,"comment_ctime":1586704896,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586704896","product_id":100040201,"comment_content":"BException应该是AException的子类，否则BException抛出的异常无法被AException所捕获。","like_count":0},{"had_liked":false,"id":175095,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1580556027,"is_pvip":false,"replies":[{"id":"68151","content":"笔误，谢谢指正~","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1580695554,"ip_address":"","comment_id":175095,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1580556027","product_id":100040201,"comment_content":"栈stack的数据存储特点是FILO，先进后出吧。","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482622,"discussion_content":"笔误，谢谢指正~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580695554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1810649,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a0/d9/49578be1.jpg","nickname":"陈衎","note":"","ucode":"8A6535DDB4B611","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220329,"discussion_content":"先进后出不就是后进先出哇","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585844442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1424264,"avatar":"https://static001.geekbang.org/account/avatar/00/15/bb/88/2d4b475c.jpg","nickname":"黄老板","note":"","ucode":"7C420E7FDFEA17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200060,"discussion_content":"后进先出和先进后出的语意是一样的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583653562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171667,"user_name":"晴天","can_delete":false,"product_type":"c1","uid":1100637,"ip_address":"","ucode":"9796E0EF8DD9A8","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/5d/f3b20f07.jpg","comment_is_top":false,"comment_ctime":1578988384,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1578988384","product_id":100040201,"comment_content":"我有一个疑问，\b关于子类契约应该比父类宽松的疑惑，比如父类是Object，子类是String，这个时候String可以替换掉Object，但是子类不是更严格吗？反过来，如果子类是Object，父类是String，String能做的，Object不一定能做啊。。","like_count":1,"discussions":[{"author":{"id":1066430,"avatar":"https://static001.geekbang.org/account/avatar/00/10/45/be/c04a40ce.jpg","nickname":"3W1H","note":"","ucode":"F6B4864128103C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194039,"discussion_content":"你这个就不是继承 继承必须参数和返回值完全相同 即方法签名相同！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583165838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194395,"avatar":"https://static001.geekbang.org/account/avatar/00/12/39/9b/fc21f943.jpg","nickname":"睡浴缸的人","note":"","ucode":"AAA7476707D82F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":139905,"discussion_content":"因为子类型必须能够替换掉它们的基类型","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579328545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170789,"user_name":"学习学个屁","can_delete":false,"product_type":"c1","uid":1049017,"ip_address":"","ucode":"DF2D61E6FB2FCE","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","comment_is_top":false,"comment_ctime":1578718730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578718730","product_id":100040201,"comment_content":"根据里氏替换原则，使用者可以在使用父类的地方使用子类替换，那么从契约的角度，子类的契约就不能比父类更严格，否则使用者在用子类替换父类的时候，就会因为更严格的契约而失败。<br><br>子类 override 父类这个方法后，想要将抛出的异常改为 BException<br>所以 BException 是AE的子类 才能去替换<br><br>","like_count":0},{"had_liked":false,"id":167159,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1577701865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577701865","product_id":100040201,"comment_content":"懂了，哈哈哈，BException应该是AException的子类，子类不能抛出父类捕获不到异常","like_count":0},{"had_liked":false,"id":166722,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1577575910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577575910","product_id":100040201,"comment_content":"思考题<br>BException 要是AException子类或者相同，否则原来catch AException的地方就会捕获不到异常而破坏里氏替换原则。 throw exception和返回一个对象类似。","like_count":0},{"had_liked":false,"id":166721,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1577575401,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577575401","product_id":100040201,"comment_content":"里氏替换原则是抽象原则的落地，也就是设计的时候用的是基类，运行的时候使用的是派生类，要求派生类必须完全能够覆盖基类的情景，所有用到基类的地方替换成派生类，程序可以运行无碍。而且派生类和基类的关系是is a 关系，只有这两者都满足，可以考虑使用继承（个人对非接口基础持保留态度）。正方形能不能作为长方形的子类取决于两者提供的公有接口。子类提供的服务不能少于父类，子类返回的类型不能比父类更上层（继承链条中的层次），子类消耗的类型不能比父类更下层（继承链条中的层次）。","like_count":1},{"had_liked":false,"id":165762,"user_name":"丁丁历险记","can_delete":false,"product_type":"c1","uid":1661704,"ip_address":"","ucode":"A43829E454C067","user_header":"https://static001.geekbang.org/account/avatar/00/19/5b/08/b0b0db05.jpg","comment_is_top":false,"comment_ctime":1577319601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577319601","product_id":100040201,"comment_content":"笔记<br>子类不应有比父类更严格的契约。  里氏替换原则。","like_count":0},{"had_liked":false,"id":164395,"user_name":"　扬帆丶启航　","can_delete":false,"product_type":"c1","uid":1235282,"ip_address":"","ucode":"4079D0889CD86C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d9/52/73351eab.jpg","comment_is_top":false,"comment_ctime":1576978273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576978273","product_id":100040201,"comment_content":"按照按照里氏替换的原则，BException是AException的父类，这样才能满足在各个情况下都能替换抽象类的方法，如果是AException的子类，可能在某些情况，不满足BException","like_count":0},{"had_liked":false,"id":164275,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1576921105,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576921105","product_id":100040201,"comment_content":"LSP(里氏替换原则) 应该还要求参数和返回值也要一致的，要不然子类没办法替换父类","like_count":0},{"had_liked":false,"id":163924,"user_name":"lifuz","can_delete":false,"product_type":"c1","uid":1253093,"ip_address":"","ucode":"A9DCD323CAAE3E","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/e5/1cd00a9d.jpg","comment_is_top":false,"comment_ctime":1576828715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576828715","product_id":100040201,"comment_content":"BException 应该是AException 的父类，用集合的概念，BException 是大集合，包含AException这个小集合，再按照里式替换原则子类不能比父类更严格，即只能用更大的集合，不能用它的子集","like_count":0},{"had_liked":false,"id":163766,"user_name":"Geek_robert","can_delete":false,"product_type":"c1","uid":1693952,"ip_address":"","ucode":"0DB92D7E022928","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/zWLzhGrHubcMJnNFz0s0atWPHSic57FsC5vDtZL1TDtDq6Zg9bdFRE4L3ap5rTNG1aUnHvErOSGyaIfIs1ZjgAQ/132","comment_is_top":false,"comment_ctime":1576801363,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1576801363","product_id":100040201,"comment_content":"课程越来越好了","like_count":0,"discussions":[{"author":{"id":1400962,"avatar":"https://static001.geekbang.org/account/avatar/00/15/60/82/9a43504b.jpg","nickname":"[耶]友超","note":"","ucode":"890572F77C3670","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91343,"discussion_content":"一直都很好","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576828273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}