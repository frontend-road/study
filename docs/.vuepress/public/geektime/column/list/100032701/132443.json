{"id":132443,"title":"16 | 如何理解TCP的“流”？","content":"<p>你好，我是盛延敏，这里是网络编程实战第16讲，欢迎回来。</p><p>上一讲我们讲到了使用SO_REUSEADDR套接字选项，可以让服务器满足快速重启的需求。在这一讲里，我们回到数据的收发这个主题，谈一谈如何理解TCP的数据流特性。</p><h2>TCP是一种流式协议</h2><p>在前面的章节中，我们讲的都是单个客户端-服务器的例子，可能会给你造成一种错觉，好像TCP是一种应答形式的数据传输过程，比如发送端一次发送network和program这样的报文，在前面的例子中，我们看到的结果基本是这样的：</p><p>发送端：network ----&gt; 接收端回应：Hi, network</p><p>发送端：program -----&gt; 接收端回应：Hi, program</p><p>这其实是一个假象，之所以会这样，是因为网络条件比较好，而且发送的数据也比较少。</p><p>为了让大家理解TCP数据是流式的这个特性，我们分别从发送端和接收端来阐述。</p><p>我们知道，在发送端，当我们调用send函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中，至于什么时候真正被发送，取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件。也就是说，我们不能假设每次send调用发送的数据，都会作为一个整体完整地被发送出去。</p><!-- [[[read_end]]] --><p>如果我们考虑实际网络传输过程中的各种影响，假设发送端陆续调用send函数先后发送network和program报文，那么实际的发送很有可能是这个样子的。</p><p>第一种情况，一次性将network和program在一个TCP分组中发送出去，像这样：</p><pre><code>...xxxnetworkprogramxxx...\n</code></pre><p>第二种情况，program的部分随network在一个TCP分组中发送出去，像这样：</p><p>TCP分组1：</p><pre><code>...xxxxxnetworkpro\n</code></pre><p>TCP分组2：</p><pre><code>gramxxxxxxxxxx...\n</code></pre><p>第三种情况，network的一部分随TCP分组被发送出去，另一部分和program一起随另一个TCP分组发送出去，像这样。</p><p>TCP分组1：</p><pre><code>...xxxxxxxxxxxnet\n</code></pre><p>TCP分组2：</p><pre><code>workprogramxxx...\n</code></pre><p>实际上类似的组合可以枚举出无数种。不管是哪一种，核心的问题就是，我们不知道network和program这两个报文是如何进行TCP分组传输的。换言之，我们在发送数据的时候，不应该假设“数据流和TCP分组是一种映射关系”。就好像在前面，我们似乎觉得network这个报文一定对应一个TCP分组，这是完全不正确的。</p><p>如果我们再来看客户端，数据流的特征更明显。</p><p>我们知道，接收端缓冲区保留了没有被取走的数据，随着应用程序不断从接收端缓冲区读出数据，接收端缓冲区就可以容纳更多新的数据。如果我们使用recv从接收端缓冲区读取数据，发送端缓冲区的数据是以字节流的方式存在的，无论发送端如何构造TCP分组，接收端最终收到的字节流总是像下面这样：</p><pre><code>xxxxxxxxxxxxxxxxxnetworkprogramxxxxxxxxxxxx\n</code></pre><p>关于接收端字节流，有两点需要注意：</p><p>第一，这里netwrok和program的顺序肯定是会保持的，也就是说，先调用send函数发送的字节，总在后调用send函数发送字节的前面，这个是由TCP严格保证的；</p><p>第二，如果发送过程中有TCP分组丢失，但是其后续分组陆续到达，那么TCP协议栈会缓存后续分组，直到前面丢失的分组到达，最终，形成可以被应用程序读取的数据流。</p><h2>网络字节排序</h2><p>我们知道计算机最终保存和传输，用的都是0101这样的二进制数据，字节流在网络上的传输，也是通过二进制来完成的。</p><p>从二进制到字节是通过编码完成的，比如著名的ASCII编码，通过一个字节8个比特对常用的西方字母进行了编码。</p><p>这里有一个有趣的问题，如果需要传输数字，比如0x0201，对应的二进制为0000001000000001，那么两个字节的数据到底是先传0x01，还是相反？</p><p><img src=\"https://static001.geekbang.org/resource/image/79/e6/79ada2f154205f5170cf8e69bf9f59e6.png?wh=3291*881\" alt=\"\"><br>\n在计算机发展的历史上，对于如何存储这个数据没有形成标准。比如这里讲到的问题，不同的系统就会有两种存法，一种是将0x02高字节存放在起始地址，这个叫做<strong>大端字节序</strong>（Big-Endian）。另一种相反，将0x01低字节存放在起始地址，这个叫做<strong>小端字节序</strong>（Little-Endian）。</p><p>但是在网络传输中，必须保证双方都用同一种标准来表达，这就好比我们打电话时说的是同一种语言，否则双方不能顺畅地沟通。这个标准就涉及到了网络字节序的选择问题，对于网络字节序，必须二选一。我们可以看到网络协议使用的是大端字节序，我个人觉得大端字节序比较符合人类的思维习惯，你可以想象手写一个多位数字，从开始往小位写，自然会先写大位，比如写12, 1234，这个样子。</p><p>为了保证网络字节序一致，POSIX标准提供了如下的转换函数：</p><pre><code>uint16_t htons (uint16_t hostshort)\nuint16_t ntohs (uint16_t netshort)\nuint32_t htonl (uint32_t hostlong)\nuint32_t ntohl (uint32_t netlong)\n</code></pre><p>这里函数中的n代表的就是network，h代表的是host，s表示的是short，l表示的是long，分别表示16位和32位的整数。</p><p>这些函数可以帮助我们在主机（host）和网络（network）的格式间灵活转换。当使用这些函数时，我们并不需要关心主机到底是什么样的字节顺序，只要使用函数给定值进行网络字节序和主机字节序的转换就可以了。</p><p>你可以想象，如果碰巧我们的系统本身是大端字节序，和网络字节序一样，那么使用上述所有的函数进行转换的时候，结果都仅仅是一个空实现，直接返回。</p><p>比如这样：</p><pre><code># if __BYTE_ORDER == __BIG_ENDIAN\n/* The host byte order is the same as network byte order,\n   so these functions are all just identity.  */\n# define ntohl(x) (x)\n# define ntohs(x) (x)\n# define htonl(x) (x)\n# define htons(x) (x)\n</code></pre><h2>报文读取和解析</h2><p>应该看到，报文是以字节流的形式呈现给应用程序的，那么随之而来的一个问题就是，应用程序如何解读字节流呢？</p><p>这就要说到报文格式和解析了。报文格式实际上定义了字节的组织形式，发送端和接收端都按照统一的报文格式进行数据传输和解析，这样就可以保证彼此能够完成交流。</p><p>只有知道了报文格式，接收端才能针对性地进行报文读取和解析工作。</p><p>报文格式最重要的是如何确定报文的边界。常见的报文格式有两种方法，一种是发送端把要发送的报文长度预先通过报文告知给接收端；另一种是通过一些特殊的字符来进行边界的划分。</p><h2>显式编码报文长度</h2><h3>报文格式</h3><p>下面我们来看一个例子，这个例子是把要发送的报文长度预先通过报文告知接收端：</p><p><img src=\"https://static001.geekbang.org/resource/image/33/15/33805892d57843a1f22830d8636e1315.png?wh=1304*146\" alt=\"\"><br>\n由图可以看出，这个报文的格式很简单，首先4个字节大小的消息长度，其目的是将真正发送的字节流的大小显式通过报文告知接收端，接下来是4个字节大小的消息类型，而真正需要发送的数据则紧随其后。</p><h3>发送报文</h3><p>发送端的程序如下：</p><pre><code>int main(int argc, char **argv) {\n    if (argc != 2) {\n        error(1, 0, &quot;usage: tcpclient &lt;IPaddress&gt;&quot;);\n    }\n\n    int socket_fd;\n    socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in server_addr;\n    bzero(&amp;server_addr, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(SERV_PORT);\n    inet_pton(AF_INET, argv[1], &amp;server_addr.sin_addr);\n\n    socklen_t server_len = sizeof(server_addr);\n    int connect_rt = connect(socket_fd, (struct sockaddr *) &amp;server_addr, server_len);\n    if (connect_rt &lt; 0) {\n        error(1, errno, &quot;connect failed &quot;);\n    }\n\n    struct {\n        u_int32_t message_length;\n        u_int32_t message_type;\n        char buf[128];\n    } message;\n\n    int n;\n\n    while (fgets(message.buf, sizeof(message.buf), stdin) != NULL) {\n        n = strlen(message.buf);\n        message.message_length = htonl(n);\n        message.message_type = 1;\n        if (send(socket_fd, (char *) &amp;message, sizeof(message.message_length) + sizeof(message.message_type) + n, 0) &lt;\n            0)\n            error(1, errno, &quot;send failure&quot;);\n\n    }\n    exit(0);\n}\n</code></pre><p>程序的1-20行是常规的创建套接字和地址，建立连接的过程。我们重点往下看，21-25行就是图示的报文格式转化为结构体，29-37行从标准输入读入数据，分别对消息长度、类型进行了初始化，注意这里使用了htonl函数将字节大小转化为了网络字节顺序，这一点很重要。最后我们看到23行实际发送的字节流大小为消息长度4字节，加上消息类型4字节，以及标准输入的字符串大小。</p><h3>解析报文：程序</h3><p>下面给出的是服务器端的程序，和客户端不一样的是，服务器端需要对报文进行解析。</p><pre><code>static int count;\n\nstatic void sig_int(int signo) {\n    printf(&quot;\\nreceived %d datagrams\\n&quot;, count);\n    exit(0);\n}\n\n\nint main(int argc, char **argv) {\n    int listenfd;\n    listenfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in server_addr;\n    bzero(&amp;server_addr, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(SERV_PORT);\n\n    int on = 1;\n    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));\n\n    int rt1 = bind(listenfd, (struct sockaddr *) &amp;server_addr, sizeof(server_addr));\n    if (rt1 &lt; 0) {\n        error(1, errno, &quot;bind failed &quot;);\n    }\n\n    int rt2 = listen(listenfd, LISTENQ);\n    if (rt2 &lt; 0) {\n        error(1, errno, &quot;listen failed &quot;);\n    }\n\n    signal(SIGPIPE, SIG_IGN);\n\n    int connfd;\n    struct sockaddr_in client_addr;\n    socklen_t client_len = sizeof(client_addr);\n\n    if ((connfd = accept(listenfd, (struct sockaddr *) &amp;client_addr, &amp;client_len)) &lt; 0) {\n        error(1, errno, &quot;bind failed &quot;);\n    }\n\n    char buf[128];\n    count = 0;\n\n    while (1) {\n        int n = read_message(connfd, buf, sizeof(buf));\n        if (n &lt; 0) {\n            error(1, errno, &quot;error read message&quot;);\n        } else if (n == 0) {\n            error(1, 0, &quot;client closed \\n&quot;);\n        }\n        buf[n] = 0;\n        printf(&quot;received %d bytes: %s\\n&quot;, n, buf);\n        count++;\n    }\n\n    exit(0);\n\n}\n</code></pre><p>这个程序1-41行创建套接字，等待连接建立部分和前面基本一致。我们重点看42-55行的部分。45-55行循环处理字节流，调用read_message函数进行报文解析工作，并把报文的主体通过标准输出打印出来。</p><h3>解析报文：readn函数</h3><p>在了解read_message工作原理之前，我们先来看第5讲就引入的一个函数：readn。这里一定要强调的是readn函数的语义，<strong>读取报文预设大小的字节</strong>，readn调用会一直循环，尝试读取预设大小的字节，如果接收缓冲区数据空，readn函数会阻塞在那里，直到有数据到达。</p><pre><code>size_t readn(int fd, void *buffer, size_t length) {\n    size_t count;\n    ssize_t nread;\n    char *ptr;\n\n    ptr = buffer;\n    count = length;\n    while (count &gt; 0) {\n        nread = read(fd, ptr, count);\n\n        if (nread &lt; 0) {\n            if (errno == EINTR)\n                continue;\n            else\n                return (-1);\n        } else if (nread == 0)\n            break;                /* EOF */\n\n        count -= nread;\n        ptr += nread;\n    }\n    return (length - count);        /* return &gt;= 0 */\n}\n</code></pre><p>readn函数中使用count来表示还需要读取的字符数，如果count一直大于0，说明还没有满足预设的字符大小，循环就会继续。第9行通过read函数来服务最多count个字符。11-17行针对返回值进行出错判断，其中返回值为0的情形是EOF，表示对方连接终止。19-20行要读取的字符数减去这次读到的字符数，同时移动缓冲区指针，这样做的目的是为了确认字符数是否已经读取完毕。</p><h3>解析报文: read_message函数</h3><p>有了readn函数作为基础，我们再看一下read_message对报文的解析处理：</p><pre><code>size_t read_message(int fd, char *buffer, size_t length) {\n    u_int32_t msg_length;\n    u_int32_t msg_type;\n    int rc;\n\n    rc = readn(fd, (char *) &amp;msg_length, sizeof(u_int32_t));\n    if (rc != sizeof(u_int32_t))\n        return rc &lt; 0 ? -1 : 0;\n    msg_length = ntohl(msg_length);\n\n    rc = readn(fd, (char *) &amp;msg_type, sizeof(msg_type));\n    if (rc != sizeof(u_int32_t))\n        return rc &lt; 0 ? -1 : 0;\n\n    if (msg_length &gt; length) {\n        return -1;\n    }\n\n    rc = readn(fd, buffer, msg_length);\n    if (rc != msg_length)\n        return rc &lt; 0 ? -1 : 0;\n    return rc;\n}\n</code></pre><p>在这个函数中，第6行通过调用readn函数获取4个字节的消息长度数据，紧接着，第11行通过调用readn函数获取4个字节的消息类型数据。第15行判断消息的长度是不是太大，如果大到本地缓冲区不能容纳，则直接返回错误；第19行调用readn一次性读取已知长度的消息体。</p><h3>实验</h3><p>我们依次启动作为报文解析的服务器一端，以及作为报文发送的客户端。我们看到，每次客户端发送的报文都可以被服务器端解析出来，在标准输出上的结果验证了这一点。</p><pre><code>$./streamserver\nreceived 8 bytes: network\nreceived 5 bytes: good\n</code></pre><pre><code>$./streamclient\nnetwork\ngood\n</code></pre><h2>特殊字符作为边界</h2><p>前面我提到了两种报文格式，另外一种报文格式就是通过设置特殊字符作为报文边界。HTTP是一个非常好的例子。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/5a/6d91c7c2a0224f5d4bad32a0f488765a.png?wh=942*324\" alt=\"\"><br>\nHTTP通过设置回车符、换行符作为HTTP报文协议的边界。</p><p>下面的read_line函数就是在尝试读取一行数据，也就是读到回车符<code>\\r</code>，或者读到回车换行符<code>\\r\\n</code>为止。这个函数每次尝试读取一个字节，第9行如果读到了回车符<code>\\r</code>，接下来在11行的“观察”下看有没有换行符，如果有就在第12行读取这个换行符；如果没有读到回车符，就在第16-17行将字符放到缓冲区，并移动指针。</p><pre><code>int read_line(int fd, char *buf, int size) {\n    int i = 0;\n    char c = '\\0';\n    int n;\n\n    while ((i &lt; size - 1) &amp;&amp; (c != '\\n')) {\n        n = recv(fd, &amp;c, 1, 0);\n        if (n &gt; 0) {\n            if (c == '\\r') {\n                n = recv(fd, &amp;c, 1, MSG_PEEK);\n                if ((n &gt; 0) &amp;&amp; (c == '\\n'))\n                    recv(fd, &amp;c, 1, 0);\n                else\n                    c = '\\n';\n            }\n            buf[i] = c;\n            i++;\n        } else\n            c = '\\n';\n    }\n    buf[i] = '\\0';\n\n    return (i);\n}\n</code></pre><h2>总结</h2><p>和我们预想的不太一样，TCP数据流特性决定了字节流本身是没有边界的，一般我们通过显式编码报文长度的方式，以及选取特殊字符区分报文边界的方式来进行报文格式的设计。而对报文解析的工作就是要在知道报文格式的情况下，有效地对报文信息进行还原。</p><h2>思考题</h2><p>和往常一样，这里给你留两道思考题，供你消化今天的内容。</p><p>第一道题关于HTTP的报文格式，我们看到，既要处理只有回车的情景，也要处理同时有回车和换行的情景，你知道造成这种情况的原因是什么吗？</p><p>第二道题是，我们这里讲到的报文格式，和TCP分组的报文格式，有什么区别和联系吗？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，与他们一起交流一下这两个问题吧。</p>","comments":[{"had_liked":false,"id":131676,"user_name":"iron_man","can_delete":false,"product_type":"c1","uid":1099883,"ip_address":"","ucode":"C0053A59442910","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/6b/0f3876ef.jpg","comment_is_top":false,"comment_ctime":1567843615,"is_pvip":false,"replies":[{"id":"50786","content":"非常好的问题。<br><br>我们在网络传输中，一个常见的方法是把0-9这样的数字，直接用ASCII码作为字符发送出去，在这种情况下，你可以理解成发送出去的都是字符类型的数据，因为是字符类型的数据，就没有所谓的网络顺序了；而如果作为一个数据型数据，比如125，这时候可能就要作为一个4字节的整型数据进行传输，那么就会有字节序的问题了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568189872,"ip_address":"","comment_id":131676,"utype":1}],"discussion_count":3,"race_medal":0,"score":"216316208415","product_id":100032701,"comment_content":"一直有个疑问，趁这堂课向老师请教一下，前面客户端发送消息时，消息长度转成网络序了，后面的消息为何没有转成网络序，如果消息里面含有数字呢？如果消息里面全是字符呢？","like_count":50,"discussions":[{"author":{"id":1145650,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7b/32/60089a62.jpg","nickname":"杨领well","note":"","ucode":"3974A03855168C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8420,"discussion_content":"因为字符只占一个字节，不受字节序的影响。而长度大于一个字节，因此会受到字节序的影响。如果消息里面含有数字(大于1字节的变量)也是需要转化字节序的。如果消息里面只有单字节字符，就不需要转化字节序。","likes_number":21,"is_delete":false,"is_hidden":false,"ctime":1568003664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466568,"discussion_content":"非常好的问题。\n\n我们在网络传输中，一个常见的方法是把0-9这样的数字，直接用ASCII码作为字符发送出去，在这种情况下，你可以理解成发送出去的都是字符类型的数据，因为是字符类型的数据，就没有所谓的网络顺序了；而如果作为一个数据型数据，比如125，这时候可能就要作为一个4字节的整型数据进行传输，那么就会有字节序的问题了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568189872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2639943,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/8oQ7n5tkeHsOSoyvqFpp6MSCRZicmLVCK73xgAPeh4cas0iaPP2lbzy3xwnVt5Na4PRiaXgIatIoKrShiclXDcnqUg/132","nickname":"Geek_a8b030","note":"","ucode":"A69F282C513FF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411304,"discussion_content":"文中的消息类型是整型，为啥也没有转","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635900132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131422,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1567746548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65992255988","product_id":100032701,"comment_content":"第一个是不是跟windows文本换行与linux文本换行的字符不同有关 windows上好像是一个换行符一个回车符 linux是一个换行符","like_count":15},{"had_liked":false,"id":131430,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1567750846,"is_pvip":false,"replies":[{"id":"50808","content":"我觉得是我错了，应该都需要的，因为我定义的MESSAGE_TYPE是一个int型值。好提醒，能pull一个PR过来么？要不我自己来吧。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568194434,"ip_address":"","comment_id":131430,"utype":1}],"discussion_count":6,"race_medal":0,"score":"48812391102","product_id":100032701,"comment_content":"message.message_length = htonl( n );<br>message.message_type = 1;<br>我在自己写代码实现的时候突然想起这两句代码为什么一个需要htonl一个不需要呢？<br>","like_count":11,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466447,"discussion_content":"我觉得是我错了，应该都需要的，因为我定义的MESSAGE_TYPE是一个int型值。好提醒，能pull一个PR过来么？要不我自己来吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568194434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2902752,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJaaRiaBo5xtYPib3az6lBtSG8ibebDUVGgSMRPD3nGn9hr0Iz8dDZXxMzsUV2M7uiaicBg9HdBxcSFic7g/132","nickname":"Geek_b83fff","note":"","ucode":"AFA20C90BCBF02","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":571691,"discussion_content":"这里都不需要吧，结构体内存连续，你发送的时候不是已经转为char*字符串了吗？ 从来么见过应用层业务结构体还这么转的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652349103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":466447,"ip_address":""},"score":571691,"extra":""}]},{"author":{"id":1170784,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/60/eae432c6.jpg","nickname":"yusuf","note":"","ucode":"9F32149B2ADDA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8310,"discussion_content":"个人感觉message_type也得需要htonl才对","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567911354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1214303,"avatar":"https://static001.geekbang.org/account/avatar/00/12/87/5f/6bf8b74a.jpg","nickname":"Kepler","note":"","ucode":"0C9CA3DB8B3CF0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8375,"discussion_content":"就一个1，1个字节可以保存的，有啥好转的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567958316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1192218,"avatar":"https://static001.geekbang.org/account/avatar/00/12/31/1a/fd82b2d5.jpg","nickname":"刘士涛","note":"","ucode":"6D83F766D189E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1214303,"avatar":"https://static001.geekbang.org/account/avatar/00/12/87/5f/6bf8b74a.jpg","nickname":"Kepler","note":"","ucode":"0C9CA3DB8B3CF0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":206322,"discussion_content":"int 4个字节","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584376639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":8375,"ip_address":""},"score":206322,"extra":""}]},{"author":{"id":1177315,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","nickname":"沉淀的梦想","note":"","ucode":"BCB7C26F9D214B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8138,"discussion_content":"看老师的服务端代码里似乎没有对message_type的内容进行任何处理，可能是这个原因就没有进行转换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567792567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137549,"user_name":"JasonZhi","can_delete":false,"product_type":"c1","uid":1282818,"ip_address":"","ucode":"6C23DCD592636D","user_header":"https://static001.geekbang.org/account/avatar/00/13/93/02/fcab58d1.jpg","comment_is_top":false,"comment_ctime":1569772632,"is_pvip":true,"replies":[{"id":"53865","content":"我理解所谓的粘包是数据报文的边界确定不清晰，造成报文解析的时候有overlap，数据解析不对。<br><br>这个具体的解法讲义里也都有涉及到，通过合理设置报文边界，接收端缓冲报文并在解析时注意上下文，一般不会有大的问题。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570697759,"ip_address":"","comment_id":137549,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27339576408","product_id":100032701,"comment_content":"老师，针对粘包问题会有相关的讲解吗？经常会听说相关的名词，但是还是不太懂具体是怎么样的。","like_count":6,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469145,"discussion_content":"我理解所谓的粘包是数据报文的边界确定不清晰，造成报文解析的时候有overlap，数据解析不对。\n\n这个具体的解法讲义里也都有涉及到，通过合理设置报文边界，接收端缓冲报文并在解析时注意上下文，一般不会有大的问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570697759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1247180,"avatar":"https://static001.geekbang.org/account/avatar/00/13/07/cc/6601c339.jpg","nickname":"陈平","note":"","ucode":"8FFDE00E4BCDAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30140,"discussion_content":"粘包不会造成接受到的数据混乱吗？我面试碰到好几次别人问这个问题，我都懵逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570801376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1033066,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/6a/3272e095.jpg","nickname":"李春恒","note":"","ucode":"F2DCA19EC66DC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1247180,"avatar":"https://static001.geekbang.org/account/avatar/00/13/07/cc/6601c339.jpg","nickname":"陈平","note":"","ucode":"8FFDE00E4BCDAB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":92749,"discussion_content":"老师的文稿里不是介绍了处理方式了嘛，\n如基于特定字符分割数据包，\n基于长度分割数据包，\n对于java系的来说，netty应该都不陌生，提供的解决半包粘包的方式如下：\n定长：fixedlengthframedecoder\n固定分隔符：delimiterbasedframedecoder\n固定字段存长度方式：lengthfieldbasedframedecoder\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576857838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":30140,"ip_address":""},"score":92749,"extra":""}]}]},{"had_liked":false,"id":131873,"user_name":"wyf2317","can_delete":false,"product_type":"c1","uid":1236837,"ip_address":"","ucode":"7F3E61A6188B39","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ub4icibeRLzff8Nf6ORsolib9KHtmeu3d4cCCAFd3Xgah3v78WfDYQB7WKq9iaIPXPwHBxw7mkBP9wYxDGMT9m1Rbw/132","comment_is_top":false,"comment_ctime":1567946391,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"23042782871","product_id":100032701,"comment_content":"1. windos 和mac linux 的换行不一样。\\r 或\\r\\n<br>2. 所属的层级不一样，应用层和网络层 <br>但本质上就是人为预定的对二进制数据序列化的方式，没有太大的差别，都是通信协议。","like_count":5},{"had_liked":false,"id":131546,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1567788820,"is_pvip":false,"replies":[{"id":"50788","content":"1.如果是字符类型数据，肯定是从a到f这样的顺序拷贝到发送缓冲区发送的；<br>2.网络中没有高地址或者低地址，网络中传输的是一个字节流，就像你例子里的abcdef....这样的顺序字节流；<br>3.不会。对于数据型的数据如int需要调研htonl来转换，对于字符类型的数据，不需要转换。因为字符类型的数据，本质是ASCII编码，而int类型的数据则需要决定顺序。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568190107,"ip_address":"","comment_id":131546,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23042625300","product_id":100032701,"comment_content":"老师，关于网络序和主机序，我有3个问题想要请教一下：<br>1.在数据发送的时候，是先发送内存中高地址的数据，还是先发内存中低地址的数据？比如char* sendline=&quot;abcdef&quot;，是从a到f的顺序去发，还是从f到a的顺序去发。<br>2.接受的时候，是现接受到的是网络序中的高地址，还是低地址？<br>3.socket接口，如read，send这些函数，会自动帮我们完成主机序和网络序之间的转换吗，还是必须要自己去转？我看老师你有些数据显式调用了htonl()，有些没有，这是为什么呢？<br>谢谢老师。","like_count":5,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466511,"discussion_content":"1.如果是字符类型数据，肯定是从a到f这样的顺序拷贝到发送缓冲区发送的；\n2.网络中没有高地址或者低地址，网络中传输的是一个字节流，就像你例子里的abcdef....这样的顺序字节流；\n3.不会。对于数据型的数据如int需要调研htonl来转换，对于字符类型的数据，不需要转换。因为字符类型的数据，本质是ASCII编码，而int类型的数据则需要决定顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568190107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8211,"discussion_content":"第一个问题，你是指网络发送吧，是按照a到f顺序发送。\n第二个问题，不管接收到高地址还是低地址，调研ntohs函数完成转换。\n第三个问题，需要在调用send方法前调用htons完成本地字节到网络字节转换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567833280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131446,"user_name":"张立华","can_delete":false,"product_type":"c1","uid":1231713,"ip_address":"","ucode":"173B938DD9478A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/61/b62d8a3b.jpg","comment_is_top":false,"comment_ctime":1567754896,"is_pvip":false,"replies":[{"id":"50807","content":"赞。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568194291,"ip_address":"","comment_id":131446,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18747624080","product_id":100032701,"comment_content":"我的操作系统是：centos 7.4 64位操作系统。<br><br>short int = 258;<br><br>258=0x0102<br><br>x的地址是（每次运行地址不一样）： 0x7fffffffe33e<br><br>258在内存中：<br><br>低位\t\t\t\t\t 高位\t\t\t\t\t\t <br>0x7fffffffe33e\t\t\t0x7fffffffe33f<br>00000010\t\t\t\t00000001<br><br>也就是说，在我的linux电脑上，内存的数据，是小端字节序<br><br>可以写个简单的程序，用gdb调试下，通过 x命令查看内存","like_count":4,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466457,"discussion_content":"赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568194291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2109519,"avatar":"https://static001.geekbang.org/account/avatar/00/20/30/4f/8684040d.jpg","nickname":"Jason °","note":"","ucode":"77AE294DE60497","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376085,"discussion_content":"这个方法有点笨了……定义一个int类型的变量赋值1，然后用char类型指针去读，读到1就是小端，读到0就是大端","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621952271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184728,"user_name":"Richard","can_delete":false,"product_type":"c1","uid":1316758,"ip_address":"","ucode":"893F958B9DD161","user_header":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","comment_is_top":false,"comment_ctime":1583392335,"is_pvip":false,"replies":[{"id":"71701","content":"我的意思是，数字可以直接按照二级制进行编码，也可以按照ASCII来进行字符编码，如果是按照字符来进行编码，我认为是没有字节顺序的，只需要把接收到的byte流按照编码格式进行解码即可。<br><br>你的理解是对的，编码解码是需要应用程序来完成的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1583657478,"ip_address":"","comment_id":184728,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14468294223","product_id":100032701,"comment_content":"老师您好，您在第一位留言中有如下回答：“我们在网络传输中，一个常见的方法是把0-9这样的数字，直接用ASCII码作为字符发送出去，在这种情况下，你可以理解成发送出去的都是字符类型的数据，因为是字符类型的数据，就没有所谓的网络顺序了”。我对此有些疑问，要说现在网络上普遍以UTF-8编码进行传输的话（而UTF-8是单字节码元，因此字节序无关），我能理解您说的“无所谓网络顺序“，但是如果以其他编码方式传输字符呢？所以我有两个问题：<br>1. 如过通信两端采用UTF-16、UFT-32这些多字节码元编码方式传输是否存在字节序问题？<br>2.字符集编码是否是socket要考虑的问题？我理解socket只负责传输字节流，编码解码由通信两端完成，不知是否正确？","like_count":3,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486110,"discussion_content":"我的意思是，数字可以直接按照二级制进行编码，也可以按照ASCII来进行字符编码，如果是按照字符来进行编码，我认为是没有字节顺序的，只需要把接收到的byte流按照编码格式进行解码即可。\n\n你的理解是对的，编码解码是需要应用程序来完成的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583657478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179479,"user_name":"supermouse","can_delete":false,"product_type":"c1","uid":1321860,"ip_address":"","ucode":"88072D5F881827","user_header":"https://static001.geekbang.org/account/avatar/00/14/2b/84/07f0c0d6.jpg","comment_is_top":false,"comment_ctime":1582012808,"is_pvip":false,"replies":[{"id":"71044","content":"对于第一个，确实在服务器端要考虑的，因为你不知道你的客户端是谁。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1583053591,"ip_address":"","comment_id":179479,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14466914696","product_id":100032701,"comment_content":"思考题第一题：本来想说是因为Unix下的文件的行尾只有\\n，而Windows下的文件行尾是\\r\\n，但是发现老师的代码里考虑的“\\r”和“\\r\\n”这两种情况。所以这一题的答案是考虑到操作系统不同吗？<br>思考题第二题：区别的话应该是所属层级不同吧，我们自己定义的报文格式是用于应用层，而TCP分组的报文格式是用于传输层；而联系就在于，我们自己定义的报文格式是包含在TCP分组的报文格式中的，即TCP分组报文去掉消息头之后，得到的消息体的格式就是我们自己定义的报文格式","like_count":3,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484276,"discussion_content":"对于第一个，确实在服务器端要考虑的，因为你不知道你的客户端是谁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583053591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131516,"user_name":"卫江","can_delete":false,"product_type":"c1","uid":1101226,"ip_address":"","ucode":"DE2F7A6916F1A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/cd/aa/33d48789.jpg","comment_is_top":false,"comment_ctime":1567776980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14452678868","product_id":100032701,"comment_content":"问题1，window与linux平台对于回车换行的编码不一致。<br>问题2，协议本质来说就是大家协商好，便于沟通的内容形式。所以，tcp与我们自定义的协议本质来说没有什么不用，区别只是针对的业务不同而已！","like_count":3},{"had_liked":false,"id":230830,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1593506131,"is_pvip":false,"replies":[{"id":"85725","content":"正解。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1593953929,"ip_address":"","comment_id":230830,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10183440723","product_id":100032701,"comment_content":"为什么需要进行端序转换？<br>因为数据传输、存储的最小单位是字节，<br>当我想传输的数据需要一个以上字节才能表示的时候，比如int 类型的 123,<br>这时接收端收到的是按顺序的四个字节,<br>他需要知道如何用这四个字节来还原成一个int,<br>端序转换指定了这个方法，<br>当然，如果传输的是一个字节就能表示的char类型,就不需要转换了<br><br>","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500052,"discussion_content":"正解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593953929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2089568,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/e2/60/d804bc22.jpg","nickname":"kkkkk","note":"","ucode":"465692C8792BE1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557016,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647608737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172090,"user_name":"xupeng1644","can_delete":false,"product_type":"c1","uid":1596906,"ip_address":"","ucode":"B3110D74266886","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83errIIarFicghpKamvkUaJmGdIV488iaOUyUqcTwbQ6IeRS40ZFfIOfb369fgleydAT8pkucHuj2x45A/132","comment_is_top":false,"comment_ctime":1579086506,"is_pvip":false,"replies":[{"id":"68047","content":"我认为你是对的，type类型确实也需要转为网络字节顺序。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1580625923,"ip_address":"","comment_id":172090,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10169021098","product_id":100032701,"comment_content":"老师 客户端发送message时 为什么不将messsage_type也转换成网络字节序 而只将message_length转换成网络字节序       ","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481616,"discussion_content":"我认为你是对的，type类型确实也需要转为网络字节顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580625923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159805,"user_name":"zjstone","can_delete":false,"product_type":"c1","uid":1302675,"ip_address":"","ucode":"4013E324D7B523","user_header":"https://static001.geekbang.org/account/avatar/00/13/e0/93/b79a44b8.jpg","comment_is_top":false,"comment_ctime":1575794798,"is_pvip":false,"replies":[{"id":"63948","content":"你有什么更好的思路么？多次read调用在网络程序开发中很正常。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1577605686,"ip_address":"","comment_id":159805,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10165729390","product_id":100032701,"comment_content":"<br>read_line函数用很多次read操作，效率很低，老师应该发个高效率的版本：)","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477178,"discussion_content":"你有什么更好的思路么？多次read调用在网络程序开发中很正常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577605686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231392,"user_name":"饭","can_delete":false,"product_type":"c1","uid":1610573,"ip_address":"","ucode":"B3F1702D4DE604","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","comment_is_top":false,"comment_ctime":1593663607,"is_pvip":false,"replies":[{"id":"85731","content":"这是编码问题，不是网络协议栈的问题。像你说的，可以用UTF-8编码，也可以使用GBK，如果你仔细研究他们，你会发现普遍的现象是，数字、常用字母都是遵循ASCII编码的，也就是8个bit，一个字节就可以搞定，而中文字符一般都是3个字节或以上。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1593954785,"ip_address":"","comment_id":231392,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5888630903","product_id":100032701,"comment_content":"我们在网络传输中，一个常见的方法是把0-9这样的数字，直接用ASCII码作为字符发送出去，在这种情况下，你可以理解成发送出去的都是字符类型的数据，<br><br>老师，对这段回答，再加上我们项目现在划分微服务，我一直有疑问。我们服务间现在都是用grpc，而不用基于http的restful服务。因为考虑字符文本传输效率是最低的，体积大。比如本例当中125，如果作为数字传输，不是明显1个字节就可以了，如果用asc要3个字节，如果作为中文unicode，好像6个字节。<br>而我们传输的 数据对象中，既有字符类型字段(有中文文本)，也有数字字段。这种情况下，协议栈是怎么传输的了，整体作为字符传送？","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500280,"discussion_content":"这是编码问题，不是网络协议栈的问题。像你说的，可以用UTF-8编码，也可以使用GBK，如果你仔细研究他们，你会发现普遍的现象是，数字、常用字母都是遵循ASCII编码的，也就是8个bit，一个字节就可以搞定，而中文字符一般都是3个字节或以上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593954785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1610573,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","nickname":"饭","note":"","ucode":"B3F1702D4DE604","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289019,"discussion_content":"好的，明白了，几个字节是应用层通过编码决定的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593957761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201575,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1585806752,"is_pvip":false,"replies":[{"id":"75770","content":"这就要仔细设置报文了，你没有注意到回车和换行符在http里都是要escape掉么？也就是转义掉，以避免和真正用来做报文分隔的字符冲突了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1586075829,"ip_address":"","comment_id":201575,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880774048","product_id":100032701,"comment_content":"有点疑惑  对于两种方案，不管是数字还是换行符，都有可能在报文的内容中出现，怎么区分是报文正文还是分隔符呢","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490367,"discussion_content":"这就要仔细设置报文了，你没有注意到回车和换行符在http里都是要escape掉么？也就是转义掉，以避免和真正用来做报文分隔的字符冲突了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586075829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147163,"user_name":"林林","can_delete":false,"product_type":"c1","uid":1613227,"ip_address":"","ucode":"7B6318B971E430","user_header":"https://static001.geekbang.org/account/avatar/00/18/9d/ab/6589d91a.jpg","comment_is_top":false,"comment_ctime":1572829497,"is_pvip":false,"replies":[{"id":"57477","content":"是的。实际上就是这样。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1573281585,"ip_address":"","comment_id":147163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5867796793","product_id":100032701,"comment_content":"老师，关于大小端的问题，服务端和客户端互相发包的情况下，为了安全起见，是不是都应该统一进行大小端处理？比如发包都得先转成大端数据，收包再转成机器的顺序？(无论是字符数据还是数值数据)","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473173,"discussion_content":"是的。实际上就是这样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573281585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131421,"user_name":"Brave Shine","can_delete":false,"product_type":"c1","uid":1222003,"ip_address":"","ucode":"CBB1BAF89DB936","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/73/3ddc7c77.jpg","comment_is_top":false,"comment_ctime":1567746416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5862713712","product_id":100032701,"comment_content":"1. linux和windows在编码http层面的不同？<br>2. tcp的分组报文是传输层在协议栈层面怎么发tcp包的规范，这里指的是应用层报文","like_count":1},{"had_liked":false,"id":131403,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1567740243,"is_pvip":false,"replies":[{"id":"50810","content":"你们这么狠的，用0来作为边界符？0作为字符串截止符是有自己特殊含义的，不过，你们开心就好。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568194593,"ip_address":"","comment_id":131403,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5862707539","product_id":100032701,"comment_content":"第1问:<br>大胆猜测因为http是以回车换行作为分界符但是在程序在编码过程中有可能随时只产生一个回车符<br>第2问:<br>tcp分组格式 是tcp层面的东西 而本文提到的报文是应用层方面的东西,联系在于tcp层面的分组可能导致数据流出现意想不到的情况,只有通过应用层处理成想要的情况<br><br>我记得之前公司解析字节流的时候是以字符0作为结束符,通过字符0 分割出一段数据流 然后通过类型转换 比如( char* ) pbuff转换成字符串或者其他类型的数据,编码的时候也是把数据的编码进去最后添加一个字符0","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466434,"discussion_content":"你们这么狠的，用0来作为边界符？0作为字符串截止符是有自己特殊含义的，不过，你们开心就好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568194593,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360973,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"安徽","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1667046328,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1667046328","product_id":100032701,"comment_content":"老师，这里讲的报文格式，报文的读取与解析，可以被理解为是序列化与反序列化吗？<br><br>“将对象的类型、属性类型、属性值一一按照固定的格式写到二进制字节流中来完成序列化，再按照固定的格式一一读出对象的类型、属性类型、属性值，通过这些信息重新创建出一个新的对象，来完成反序列化。”","like_count":0},{"had_liked":false,"id":350231,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1656672688,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656672688","product_id":100032701,"comment_content":"一般都是利用特殊符号作为边界(http)。或者是利用利用位数作为边界（mqtt）","like_count":0},{"had_liked":false,"id":338317,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1647422092,"is_pvip":true,"replies":[{"id":"124145","content":"系统函数知道自己主机的所有信息，操作系统&#47;cpu&#47;大端还是小端，所以我们只管直接调用就好。","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1648297920,"ip_address":"","comment_id":338317,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1647422092","product_id":100032701,"comment_content":"老师同学好，文中&quot;我们并不需要关心主机到底是什么样的字节顺序，只要使用函数给定值进行网络字节序和主机字节序的转换就可以了。&quot;，不太明白为什么，这里的给定值，比如，端口号5678【不是以二进制存储到内存中？如何知道系统是采用大端字节序还是小端？】，直接使用函数进行处理即可？ ","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558436,"discussion_content":"系统函数知道自己主机的所有信息，操作系统/cpu/大端还是小端，所以我们只管直接调用就好。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648297920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558474,"discussion_content":"好的～ 谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648339777,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338314,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1647421092,"is_pvip":true,"replies":[{"id":"124144","content":"没有上下文，不过我猜不是指的网络字节序。","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1648297869,"ip_address":"","comment_id":338314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647421092","product_id":100032701,"comment_content":"老师同学好，看到另外专栏的老师的文章内容：<br><br>此外，UTF-8 的编码单元为一个字节（也就是一次编解码一个字节），所以我们在处理 UTF-8 方案表示的 Unicode 字符的时候，就不需要像 UTF-32 方案那样考虑字节序问题了。相对于 UTF-32 方案，UTF-8 方案的空间利用率也是最高的。<br><br>UTF-8 的编码不考虑字节序？不是很明白。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558435,"discussion_content":"没有上下文，不过我猜不是指的网络字节序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648297869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338308,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1647420565,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647420565","product_id":100032701,"comment_content":"我去，越看越懵，需要好好消化下～","like_count":0},{"had_liked":false,"id":335494,"user_name":"淡C","can_delete":false,"product_type":"c1","uid":2696647,"ip_address":"","ucode":"046DE6F5301044","user_header":"https://static001.geekbang.org/account/avatar/00/29/25/c7/edd74dfb.jpg","comment_is_top":false,"comment_ctime":1645540392,"is_pvip":false,"replies":[{"id":"122803","content":"就是通过将msg_length 设置为字符串的长度达到的。<br>n = strlen(message.data);<br>message.message_length = htonl(n);<br>","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1645882332,"ip_address":"","comment_id":335494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645540392","product_id":100032701,"comment_content":"那个u_int32_t msg_length是如何指向消息长度的;","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553417,"discussion_content":"就是通过将msg_length 设置为字符串的长度达到的。\nn = strlen(message.data);\nmessage.message_length = htonl(n);\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645882332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326437,"user_name":"Mandone","can_delete":false,"product_type":"c1","uid":1116017,"ip_address":"","ucode":"FE236389CEF200","user_header":"https://static001.geekbang.org/account/avatar/00/11/07/71/d3049207.jpg","comment_is_top":false,"comment_ctime":1639530458,"is_pvip":true,"replies":[{"id":"118846","content":"TCP的流是一个&quot;抽象&quot;概念，http body的stream是http协议具象化的内容。","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1639829383,"ip_address":"","comment_id":326437,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639530458","product_id":100032701,"comment_content":"这里面的流和http中post请求时携带的body体中的流是一回事吗","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539750,"discussion_content":"TCP的流是一个&#34;抽象&#34;概念，http body的stream是http协议具象化的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639829383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286029,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1617112752,"is_pvip":false,"replies":[{"id":"104132","content":"1.确实需要处理的，我记得改过的；<br>2.不会的，socket是每条连接有自己的传输通道；<br>3.同一个请求一定是相同的套接字啊(accept之后的)，所以不会串的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1617542804,"ip_address":"","comment_id":286029,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617112752","product_id":100032701,"comment_content":"原文：最后我们看到 23 行实际发送的字节流大小为消息长度 4 字节，加上消息类型 4 字节，以及标准输入的字符串大小。<br>这里是 33 行吧。<br><br>原文：注意这里使用了 htonl 函数将字节大小转化为了网络字节顺序，这一点很重要。<br>1. 为什么很重要呀？为啥 type 字段不需要转换：message.message_type = htonl(1)？<br><br>2. 显式编码报文长度的方式，socket 会不会读取到其他连接请求剩余的数据（比如开启了 net.ipv4.tcp_tw_reuse），导致解析之后的字符错误了？<br><br>3. http 的回车换行符为报文协议边界，每次读取一行的数据，如何辨别哪几行数据是同一个请求的呀？<br><br>谢谢老师","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517848,"discussion_content":"1.确实需要处理的，我记得改过的；\n2.不会的，socket是每条连接有自己的传输通道；\n3.同一个请求一定是相同的套接字啊(accept之后的)，所以不会串的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617542804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273018,"user_name":"卡布猴纸","can_delete":false,"product_type":"c1","uid":2132724,"ip_address":"","ucode":"5B1ADE66ACB53C","user_header":"https://static001.geekbang.org/account/avatar/00/20/8a/f4/a4243808.jpg","comment_is_top":false,"comment_ctime":1610414472,"is_pvip":false,"replies":[{"id":"99525","content":"结构化，又非对齐，这个格式有例子么？可以不用这么复杂么 ","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1610891793,"ip_address":"","comment_id":273018,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610414472","product_id":100032701,"comment_content":"老师你好，如果结构体不是严格的对齐方式。那么在结构体中会出现空洞，用来结构体对齐。这样的话，除了通过结构#pragma pack(1)取消对齐，保证结构体是紧凑的。对于结构化的非对齐的数据传输的处理方式怎么处理比较好","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513461,"discussion_content":"结构化，又非对齐，这个格式有例子么？可以不用这么复杂么 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610891793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230840,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1593508309,"is_pvip":false,"replies":[{"id":"85726","content":"正解。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1593953967,"ip_address":"","comment_id":230840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593508309","product_id":100032701,"comment_content":"为什么像&quot;abcdef&quot;这样的字符串不需要端序转换，因为字符串的本质是char类型的数组，虽然发送的时候可能会被分割成很多段，但是每个段都有相应的序号，接收端只要按照序号从小到大一组装，还是原来的字符串，这个段与段之间的顺序是由tcp协议栈保证的","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500053,"discussion_content":"正解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593953967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230819,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1593503687,"is_pvip":false,"replies":[{"id":"85724","content":"可以这么理解。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1593953916,"ip_address":"","comment_id":230819,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593503687","product_id":100032701,"comment_content":"哦，是调用read或者recv读取的时候会移动协议栈接收缓冲区的指针是吗？这样每次都是在上一次的后面开始读取的","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500050,"discussion_content":"可以这么理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593953916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230804,"user_name":"衬衫的价格是19美元","can_delete":false,"product_type":"c1","uid":1397631,"ip_address":"","ucode":"655F925451F772","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","comment_is_top":false,"comment_ctime":1593499562,"is_pvip":false,"replies":[{"id":"85723","content":"因为这是我们自定义的应用层协议，我们知道按照 msg_legth-&gt;msg_type-&gt;data这样的方式来获取数据。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1593953894,"ip_address":"","comment_id":230804,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1593499562","product_id":100032701,"comment_content":"read_message里面第6行调用readn读取4个字节的msg_length， 11行又调用readn读取4个字节的msg_type,读取msg_type的时候协议栈是怎么知道要从第4个字节开始的呢？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500044,"discussion_content":"因为这是我们自定义的应用层协议，我们知道按照 msg_legth-&amp;gt;msg_type-&amp;gt;data这样的方式来获取数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593953894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397631,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVUskibDnhMt5MCIJ8227HWkeg2wEEyewps8GuWhWaY5fy7Ya56bu2ktMlxdla3K29Wqia9efCkWaQ/132","nickname":"衬衫的价格是19美元","note":"","ucode":"655F925451F772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287651,"discussion_content":"应该是协议栈的接收缓冲区有一个指向当前读取位置的指针，每次就从这个位置向后偏移就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593503970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191726,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1584792813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584792813","product_id":100032701,"comment_content":"第一个问题使用由于不同的操作能识别的换行符不同导致。<br>第二问题层次不一样，tcp是内核层，四层，今天讲的是应用层","like_count":0},{"had_liked":false,"id":154688,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1574511378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574511378","product_id":100032701,"comment_content":"本文核心观点：<br>1：TCP 数据是流式的——0&#47;1的组合——符合规范的直流电——符合规范的交流电<br>2：在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中，至于什么时候真正被发送，取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件。也就是说，我们不能假设每次 send 调用发送的数据，都会作为一个整体完整地被发送出去。<br>3：接收端缓冲区保留了没有被取走的数据，随着应用程序不断从接收端缓冲区读出数据，接收端缓冲区就可以容纳更多新的数据。如果我们使用 recv 从接收端缓冲区读取数据，发送端缓冲区的数据是以字节流的方式存在的，无论发送端如何构造 TCP 分组，接收端最终受到的字节流总是有序的完整的，这些都有TCP严格保证。<br>4：数据存储有大小端之别，只要统一就行，网络传输字节序使用大端<br>5：都是0&#47;1咋区分数据的边界，常用方式有两种，一是标明字节长度，二是使用特殊分隔符","like_count":0},{"had_liked":false,"id":146406,"user_name":"chs","can_delete":false,"product_type":"c1","uid":1618711,"ip_address":"","ucode":"BE4B6A19317400","user_header":"https://static001.geekbang.org/account/avatar/00/18/b3/17/19ea024f.jpg","comment_is_top":false,"comment_ctime":1572514645,"is_pvip":false,"replies":[{"id":"56657","content":"这个对我们来说是透明的，不过你可以理解成先发送数据长度，再发送数据类型，最后是数据本身。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1572575236,"ip_address":"","comment_id":146406,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572514645","product_id":100032701,"comment_content":"老师请问这个客户端协议的发送顺序是怎样的？是按照协议里字段的定义顺序发送即先发送数据长度然后发送数据类型最后是发送数据？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472849,"discussion_content":"这个对我们来说是透明的，不过你可以理解成先发送数据长度，再发送数据类型，最后是数据本身。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572575236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142884,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1571575015,"is_pvip":false,"replies":[{"id":"55597","content":"好问题，这个在实际设计应用层协议的，是要着重考虑避免的，就是说边界的划分，应该是有限的，http的协议有head和body的区分，处理的好是可以分段处理的。比如先处理head，再处理body部分。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1571846150,"ip_address":"","comment_id":142884,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571575015","product_id":100032701,"comment_content":"我想到一个问题，倘若发送端send一个很大的buf,而接收端如果只能接收定长的buf的话就不能一次性处理，这个时候是不是要像文中那样自定义一个结构体包含buf长度和buf来构成一个通信协议来达成一次性处理<br>http又是怎么处理这种情况的，他是一次性还是分段呢","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471310,"discussion_content":"好问题，这个在实际设计应用层协议的，是要着重考虑避免的，就是说边界的划分，应该是有限的，http的协议有head和body的区分，处理的好是可以分段处理的。比如先处理head，再处理body部分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571846150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135856,"user_name":"Edison","can_delete":false,"product_type":"c1","uid":1135701,"ip_address":"","ucode":"734A561F363720","user_header":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","comment_is_top":false,"comment_ctime":1569289096,"is_pvip":false,"replies":[{"id":"52320","content":"你写编译一下我这里的例子，看看是否能正确运行。<br><br>你也可以把你的例子贴上来，大家一起分析。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569463489,"ip_address":"","comment_id":135856,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1569289096","product_id":100032701,"comment_content":"老师，我在Linux平台下，照着你的程序写了一遍，客户端发数据，但是好像服务端不能够把数据包给解析出来。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468360,"discussion_content":"你写编译一下我这里的例子，看看是否能正确运行。\n\n你也可以把你的例子贴上来，大家一起分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569463489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135701,"avatar":"https://static001.geekbang.org/account/avatar/00/11/54/55/613ddc42.jpg","nickname":"Edison","note":"","ucode":"734A561F363720","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21291,"discussion_content":"后来运行成功了，服务端在调用accept函数那个地方出了问题，但是又出现了一个新的小问题，我们服务端在解析数据包时，读取message_length，这个值很大，并不是实际的数据包长度值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569463842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134331,"user_name":"甘远林","can_delete":false,"product_type":"c1","uid":1178148,"ip_address":"","ucode":"36048DAB42DC13","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/24/e1329796.jpg","comment_is_top":false,"comment_ctime":1568809049,"is_pvip":false,"replies":[{"id":"51603","content":"关键是我们不知道对方机器的型号，是不是大小端一样的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568884692,"ip_address":"","comment_id":134331,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568809049","product_id":100032701,"comment_content":"大小端问题，如果两边机器的大小端一样，这样两边都不转也没问题吧","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467704,"discussion_content":"关键是我们不知道对方机器的型号，是不是大小端一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568884692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132730,"user_name":"有点意思","can_delete":false,"product_type":"c1","uid":1399454,"ip_address":"","ucode":"67F55604E8A548","user_header":"https://static001.geekbang.org/account/avatar/00/15/5a/9e/8f2ccc1d.jpg","comment_is_top":false,"comment_ctime":1568205956,"is_pvip":true,"replies":[{"id":"51633","content":"是解析完的四字节长度为0，还是读到了0？如果提取的长度为0，说明写入的就是0啊，这个要看下发送端发的数据是否对的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568887924,"ip_address":"","comment_id":132730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568205956","product_id":100032701,"comment_content":"老师好<br>问题是这样的：<br>客户端这边有两个线程：<br>一个线程采集网卡流量存到环形缓冲区，另外一个线程从环形缓冲区读取并发送<br>格式是：四字节长度+具体内容<br>服务端收到后，根据提取到的长度去读取具体内容<br>但是在程序运行了一段时间后，发现服务端处理报文出错了，原因是提取的长度是0,<br>现在想到的是遇到这种特殊情况，直接断开连接在连，但是总感觉这样处理不好，有点应付差事一样<br>我现在有个疑问  出现这种情况是不是一定是服务端拆包的逻辑或者客户端组包的逻辑出了问题 除此之外不会再有其他原因了<br>使用原生socket在两台机子间发送接收大数据量的网卡流量 是不是一定能做到可靠没问题？<br>","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467092,"discussion_content":"是解析完的四字节长度为0，还是读到了0？如果提取的长度为0，说明写入的就是0啊，这个要看下发送端发的数据是否对的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568887924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132708,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1568197725,"is_pvip":false,"replies":[{"id":"51638","content":"我其实觉得本地端口不需要，数据是需要的。就是双方通信的那个部分是需要的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568888690,"ip_address":"","comment_id":132708,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568197725","product_id":100032701,"comment_content":"这个字节序转换是不是IP地址，端口，数据都要啊","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467079,"discussion_content":"我其实觉得本地端口不需要，数据是需要的。就是双方通信的那个部分是需要的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568888690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132705,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1568197420,"is_pvip":false,"replies":[{"id":"51752","content":"感觉是整型数越界了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568960414,"ip_address":"","comment_id":132705,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568197420","product_id":100032701,"comment_content":"当我用htonl(999999999)时netstat -tanlp 显示的IP地址是0.0.0.0，数字小一点再试一次是127.0.0.1 当初地址绑定是就是127.0.0.01，这是怎么回事","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467078,"discussion_content":"感觉是整型数越界了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568960414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132581,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1568168248,"is_pvip":false,"replies":[{"id":"50776","content":"我猜是和int,long的大小有关系，int早期是2个字节，现在一般是4个字节，而long在32位操作系统上是4个字节，64位操作系统是8个字节。<br><br>我不知道你为什么每次调用都不一样，我这里每次都显示一个固定的值。<br><br><br>","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568188588,"ip_address":"","comment_id":132581,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568168248","product_id":100032701,"comment_content":"我想问一下，当我把端口设置为htons(2000)时，调用netstat -tanlp 发现端口在2000。当我把端口设置为htonl((uint32_t)2000)时 却是一个随机的整数，每次调用都不一样，这是怎么回事。<br>","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467020,"discussion_content":"我猜是和int,long的大小有关系，int早期是2个字节，现在一般是4个字节，而long在32位操作系统上是4个字节，64位操作系统是8个字节。\n\n我不知道你为什么每次调用都不一样，我这里每次都显示一个固定的值。\n\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568188588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131799,"user_name":"yusuf","can_delete":false,"product_type":"c1","uid":1170784,"ip_address":"","ucode":"9F32149B2ADDA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/60/eae432c6.jpg","comment_is_top":false,"comment_ctime":1567911220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567911220","product_id":100032701,"comment_content":"第一个问题是因为windows系统下的回车是\\r\\n，而类UNIX系统下的回车是\\n","like_count":0},{"had_liked":false,"id":131539,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1567787031,"is_pvip":false,"replies":[{"id":"50789","content":"没看懂问题，哪个struct?可以贴具体的代码么?","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568190178,"ip_address":"","comment_id":131539,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567787031","product_id":100032701,"comment_content":"老师，你这里的struct不会有内存对齐的操作吗？这样struct的大小信息和和自行的位置信息会不会就不对了呀？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466510,"discussion_content":"没看懂问题，哪个struct?可以贴具体的代码么?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568190178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1618828,"avatar":"","nickname":"面向工资编程","note":"","ucode":"07F797F021BDD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242909,"discussion_content":"内存对齐自己的理解是系统分配内存时候的位置不可能是某些位置（可以认为起点不同），这个和 struct 里面字段的大小没有关系，一个字节的 field 还是一个字节","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587507339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131463,"user_name":"Chao","can_delete":false,"product_type":"c1","uid":1108745,"ip_address":"","ucode":"DD7742F5537521","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/09/ba5f0135.jpg","comment_is_top":false,"comment_ctime":1567758493,"is_pvip":false,"replies":[{"id":"50806","content":"MSL是TCP分组中的存活时间，这个问题我放在这一期答疑吧。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568194243,"ip_address":"","comment_id":131463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567758493","product_id":100032701,"comment_content":"老师 我什么时候答疑<br>最大分组 MSL 是 TCP 分组在网络中存活的最长时间这个问题","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466466,"discussion_content":"MSL是TCP分组中的存活时间，这个问题我放在这一期答疑吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568194243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131409,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1567741384,"is_pvip":false,"replies":[{"id":"50809","content":"是的呀，我在文稿里提到应用层决定了么？如果有，得赶紧给出指出来啊。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568194515,"ip_address":"","comment_id":131409,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567741384","product_id":100032701,"comment_content":"网络字节序大端小端问题 具体是大端还是小端应该不是应用层决定的吧 我们只需要发送和接收的时候通过hton* 和ntoh*函数进行转换就可以用了吧？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466437,"discussion_content":"是的呀，我在文稿里提到应用层决定了么？如果有，得赶紧给出指出来啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568194515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131408,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":false,"comment_ctime":1567741242,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567741242","product_id":100032701,"comment_content":"回答第一个问题，应该是历史原因吧？<br>回答第二个问题，这里讲的是应用程序层面的报文格式，tcp分组报文格式是协议层面的。应用层面的报文在先发送到协议栈，然后在协议栈以tcp分组报文发送出去。","like_count":0},{"had_liked":false,"id":131376,"user_name":"Geek_007","can_delete":false,"product_type":"c1","uid":1467182,"ip_address":"","ucode":"C80107538EAA7F","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/2e/e49116d1.jpg","comment_is_top":false,"comment_ctime":1567733408,"is_pvip":false,"replies":[{"id":"50813","content":"如果你真要这么干，你确定不会乱么? 一般我们不推荐这么做。从理论上说，确实是可以，不过流的分割就真的成问题了。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568194901,"ip_address":"","comment_id":131376,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1567733408","product_id":100032701,"comment_content":"老师，如果有多个进程都在对一个socket fd进行write操作，一个要写abc,一个要写123。会不会最终发出去的流是ab1c23。这样是不是靠长度和分割符的方式就无效了。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466421,"discussion_content":"如果你真要这么干，你确定不会乱么? 一般我们不推荐这么做。从理论上说，确实是可以，不过流的分割就真的成问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568194901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7956,"discussion_content":"胸弟,你这个就涉及到进程同步了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567740297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1467182,"avatar":"https://static001.geekbang.org/account/avatar/00/16/63/2e/e49116d1.jpg","nickname":"Geek_007","note":"","ucode":"C80107538EAA7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274687,"discussion_content":"我在想，那h2的多路复用是怎么做到的呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590599611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7956,"ip_address":""},"score":274687,"extra":""}]},{"author":{"id":1236766,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","nickname":"传说中的成大大","note":"","ucode":"103543D6E706BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7958,"discussion_content":"而且属于开发人员的逻辑错误了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567740333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131368,"user_name":"_你说了不算","can_delete":false,"product_type":"c1","uid":1185159,"ip_address":"","ucode":"212F890565FE5C","user_header":"https://static001.geekbang.org/account/avatar/00/12/15/87/d22d8c3e.jpg","comment_is_top":false,"comment_ctime":1567732492,"is_pvip":false,"replies":[{"id":"50817","content":"加油~","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568195115,"ip_address":"","comment_id":131368,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1567732492","product_id":100032701,"comment_content":"非计算机专业出身的Java程序员看的一知半解，周末好好消化一下。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466416,"discussion_content":"加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568195115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131350,"user_name":"(￣_￣ )","can_delete":false,"product_type":"c1","uid":1133366,"ip_address":"","ucode":"8B6E2EF240D4AD","user_header":"https://static001.geekbang.org/account/avatar/00/11/4b/36/ed40fb3a.jpg","comment_is_top":false,"comment_ctime":1567729013,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567729013","product_id":100032701,"comment_content":"可能是因为windows下编码换行符号是0d0a吧","like_count":0}]}