{"id":113675,"title":"08 | 答疑解惑（一） : 网关如何接收服务端的秒杀结果？","content":"<p>你好，我是李玥。</p><p>我们的“消息队列高手课”专栏自从上线到现在，同学们的学习热情和参与度都非常高。每一节课都有很多同学留言评论，这些留言里有总结知识分享收获的，有提出精彩问题的，还有给自己加油打气立Flag的，竟然还有说老师长得像黄渤的。我又仔细去看了一下配图，还是真挺像的。下次老师和极客时间的设计师小姐姐说一样，让她们照着吴彦祖来P图。</p><p>同学们每一条的留言我都认真看过，大部分留言我都给出了回复。在基础篇的最后一节课，我来统一解答一下大家都比较关注的一些问题。</p><h2>1. 网关如何接收服务端的秒杀结果？</h2><p>在《<a href=\"https://time.geekbang.org/column/article/109572\">01 | 为什么需要消息队列？</a>》这节课里面，我们举了一个秒杀的例子，这个例子是用来说明消息队列是如何来实现异步处理的。课后很多同学留言提问，网关在发送消息之后，是如何来接收后端服务的秒杀结果，又如何来给APP返回响应的呢？</p><p>在解答这个问题之前，我需要先说一下，实际生产环境中的秒杀系统，远比我们举的这个例子复杂得多，实现方案也是多种多样的，不是说一定要按照我们这个例子的方式来实现。</p><p>在这个例子中，网关接收后端服务秒杀结果，实现的方式也不只一种，这里我给大家提供一个比较简单的方案。</p><p>比如说，用Java语言来举例子：</p><!-- [[[read_end]]] --><pre><code>public class RequestHandler {\n  \n  // ID生成器\n  @Inject\n  private IdGenerator idGenerator;\n  // 消息队列生产者\n  @Inject\n  private Producer producer;\n  // 保存秒杀结果的Map\n  @Inject\n  private Map&lt;Long, Result&gt; results;\n\n  // 保存mutex的Map\n  private Map&lt;Long, Object&gt; mutexes = new ConcurrentHashMap&lt;&gt;();\n  // 这个网关实例的ID\n  @Inject\n  private long myId;\n\n  @Inject\n  private long timeout;\n\n  // 在这里处理APP的秒杀请求\n  public Response onRequest(Request request) {\n    // 获取一个进程内唯一的UUID作为请求id\n    Long uuid = idGenerator.next();\n    try {\n\n      Message msg = composeMsg(request, uuid, myId);\n\n      // 生成一个mutex，用于等待和通知\n      Object mutex = new Object();\n      mutexes.put(uuid, mutex)\n\n      // 发消息\n      producer.send(msg);\n\n      // 等待后端处理\n      synchronized(mutex) {\n        mutex.wait(timeout);\n      }\n\n      // 查询秒杀结果\n      Result result = results.remove(uuid);\n\n      // 检查秒杀结果并返回响应\n      if(null != result &amp;&amp; result.success()){\n        return Response.success();\n      }\n\n    } catch (Throwable ignored) {}\n    finally {\n      mutexes.remove(uuid);\n    }\n    // 返回秒杀失败\n    return Response.fail();\n  }\n\n  // 在这里处理后端服务返回的秒杀结果\n  public void onResult(Result result) {\n\n    Object mutex = mutexes.get(result.uuid());\n    if(null != mutex) { // 如果查询不到，说明已经超时了，丢弃result即可。\n      // 登记秒杀结果\n      results.put(result.uuid(), result);\n      // 唤醒处理APP请求的线程\n      synchronized(mutex) {\n        mutex.notify();\n      }\n    }\n  }\n}\n</code></pre><p>在这个方案中，网关在收到APP的秒杀请求后，直接给消息队列发消息。至于消息的内容，并不一定是APP请求的Request，只要包含足够的字段就行了，比如用户ID、设备ID、请求时间等等。另外，还需要包含这个请求的ID和网关的ID，这些后面我们会用到。</p><p>如果发送消息失败，可以直接给APP返回秒杀失败结果，成功发送消息之后，线程就阻塞等待秒杀结果。这里面不可能无限等待下去，需要设定一个等待的超时时间。</p><p>等待结束之后，去存放秒杀结果的Map中查询是否有返回的秒杀结果，如果有就构建Response，给APP返回秒杀结果，如果没有，按秒杀失败处理。</p><p>这是处理APP请求的线程，接下来我们来看一下，网关如何来接收从后端秒杀服务返回的秒杀结果。</p><p>我们可以选择用RPC的方式来返回秒杀结果，这里网关节点是RPC服务端，后端服务为客户端。之前网关发出去的消息中包含了网关的ID，后端服务可以通过这个网关ID来找到对应的网关实例，秒杀结果中需要包含请求ID，这个请求ID也是从消息中获取的。</p><p>网关收到后端服务的秒杀结果之后，用请求ID为Key，把这个结果保存到秒杀结果的Map中，然后通知对应的处理APP请求的线程，结束等待。我刚刚说过，处理APP请求的线程，在结束等待之后，会去秒杀的结果Map中查询这个结果，然后再给APP返回响应。</p><p>我把这个处理过程的流程图放在这里，便于你理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/31/51/310c2802ba1018c08665da8af4800251.jpg?wh=3980*2988\" alt=\"\"><br>\n这个解决方案还不是一个性能最优的方案，处理APP请求的线程需要同步等待秒杀结果。后面课程中我们会专门来讲，如何使用异步方式来提升程序的性能。</p><h2>2. 详解RocketMQ和Kafka的消息模型</h2><p>我在看《<a href=\"http://time.geekbang.org/column/article/110459\">03 | 消息模型：主题和队列有什么区别？</a>》这节课的留言时发现，不少同学对RocketMQ和kafka的消息模型理解的还不是很透彻，这两个消息队列产品的消息模型是一样的，我在这里，再把这个模型相关的概念，通过一个例子详细地说一说。</p><p>假设有一个主题MyTopic，我们为主题创建5个队列，分布到2个Broker中。</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/2f/dd3f4c5e40f58b62c2d89554b579a72f.jpg?wh=3591*732\" alt=\"\"></p><p>先说消息生产这一端，假设我们有3个生产者实例：Produer0，Produer1和Producer2。</p><p>这3个生产者是如何对应到2个Broker的，又是如何对应到5个队列的呢？这个很简单，<strong>不用对应，随便发</strong>。每个生产者可以在5个队列中轮询发送，也可以随机选一个队列发送，或者只往某个队列发送，这些都可以。比如Producer0要发5条消息，可以都发到队列Q0里面，也可以5个队列每个队列发一条。</p><p>然后说消费端，很多同学没有搞清楚消费组、消费者和队列这几个概念的对应关系。</p><p>每个消费组就是一份订阅，它要消费主题MyTopic下，所有队列的全部消息。注意，队列里的消息并不是消费掉就没有了，这里的“消费”，只是去队列里面读了消息，并没有删除，消费完这条消息还是在队列里面。</p><p>多个消费组在消费同一个主题时，消费组之间是互不影响的。比如我们有2个消费组：G0和G1。G0消费了哪些消息，G1是不知道的，也不用知道。G0消费过的消息，G1还可以消费。即使G0积压了很多消息，对G1来说也没有任何影响。</p><p>然后我们再说消费组的内部，一个消费组中可以包含多个消费者的实例。比如说消费组G1，包含了2个消费者C0和C1，那这2个消费者又是怎么和主题MyTopic的5个队列对应的呢？</p><p>由于消费确认机制的限制，这里面有一个原则是，在同一个消费组里面，每个队列只能被一个消费者实例占用。至于如何分配，这里面有很多策略，我就不展开说了。总之保证每个队列分配一个消费者就行了。比如，我们可以让消费者C0消费Q0，Q1和Q2，C1消费Q3和Q4，如果C0宕机了，会触发重新分配，这时候C1同时消费全部5个队列。</p><p>再强调一下，队列占用只是针对消费组内部来说的，对于其他的消费组来说是没有影响的。比如队列Q2被消费组G1的消费者C1占用了，对于消费组G2来说，是完全没有影响的，G2也可以分配它的消费者来占用和消费队列Q2。</p><p>最后说一下消费位置，每个消费组内部维护自己的一组消费位置，每个队列对应一个消费位置。消费位置在服务端保存，并且，<strong>消费位置和消费者是没有关系的</strong>。每个消费位置一般就是一个整数，记录这个消费组中，这个队列消费到哪个位置了，这个位置之前的消息都成功消费了，之后的消息都没有消费或者正在消费。</p><p>我把咱们这个例子的消费位置整理成下面的表格，便于你理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/85/2c78c72078002444e758f9dde1386585.jpg?wh=3588*2517\" alt=\"\"></p><p>你可以看到，这个表格中并没有消费者这一列，也就是说消费者和消费位置是没有关系的。</p><h2>3. 如何实现单个队列的并行消费？</h2><p>下面说一下《<a href=\"http://time.geekbang.org/column/article/110459\">03 | 消息模型：主题和队列有什么区别？</a>》这节课的思考题：如果不要求严格顺序，如何实现单个队列的并行消费？关于这个问题，有很多的实现方式，在JMQ（京东自研的消息队列产品）中，它实现的思路是这样的。</p><p>比如说，队列中当前有10条消息，对应的编号是0-9，当前的消费位置是5。同时来了三个消费者来拉消息，把编号为5、6、7的消息分别给三个消费者，每人一条。过了一段时间，三个消费成功的响应都回来了，这时候就可以把消费位置更新为8了，这样就实现并行消费。</p><p>这是理想的情况。还有可能编号为6、7的消息响应回来了，编号5的消息响应一直回不来，怎么办？这个位置5就是一个消息空洞。为了避免位置5把这个队列卡住，可以先把消费位置5这条消息，复制到一个特殊重试队列中，然后依然把消费位置更新为8，继续消费。再有消费者来拉消息的时候，优先把重试队列中的那条消息给消费者就可以了。</p><p>这是并行消费的一种实现方式。需要注意的是，并行消费开销还是很大的，不应该作为一个常规的，提升消费并发的手段，如果消费慢需要增加消费者的并发数，还是需要扩容队列数。</p><h2>4. 如何保证消息的严格顺序？</h2><p>很多同学在留言中问，怎么来保证消息的严格顺序？我们多次提到过，主题层面是无法保证严格顺序的，只有在队列上才能保证消息的严格顺序。</p><p>如果说，你的业务必须要求全局严格顺序，就只能把消息队列数配置成1，生产者和消费者也只能是一个实例，这样才能保证全局严格顺序。</p><p>大部分情况下，我们并不需要全局严格顺序，只要保证局部有序就可以满足要求了。比如，在传递账户流水记录的时候，只要保证每个账户的流水有序就可以了，不同账户之间的流水记录是不需要保证顺序的。</p><p>如果需要保证局部严格顺序，可以这样来实现。在发送端，我们使用账户ID作为Key，采用一致性哈希算法计算出队列编号，指定队列来发送消息。一致性哈希算法可以保证，相同Key的消息总是发送到同一个队列上，这样可以保证相同Key的消息是严格有序的。如果不考虑队列扩容，也可以用队列数量取模的简单方法来计算队列编号。</p><h2>写在最后</h2><p>在留言中，很多同学留言提出来，能不能讲一讲某个消息队列的某个功能具体如何配置。我的建议是，你先不要太关注功能、API和配置这些细节，在学习如何使用消息队列的过程中，要保持一定的高度来学习。</p><p>因为使用消息队列，大部分的难点在宏观架构层面，要解决这些难点，你需要掌握消息队列宏观层面上的实现原理和最佳实践，这样，无论你使用什么消息队列，都可以做到游刃有余。在选定了合适的消息队列产品，准备写代码之前，再去文档中查看这些细节都来得及。</p><p>所以，我们专栏的“基础篇”讲消息队列的使用，更多讲的是一些通用的原理。这节课是我们消息队列高手课“基础篇”的最后一节课，完整基础篇的学习后，意味着你已经是一个使用消息队列的小达人了。</p><p>在“进阶篇”中，我们将把学习重点从“如何使用”转为“如何实现”，在学习消息队列的实现技术时，你反而要专注到每一个技术点上，深入下去，把每个细节都要搞清楚、学透。课程的深度、难度也会逐步加强，当然你获得的经验值也会更多。</p><p>希望大家一如既往坚持学习，多思考，多练习，跟老师一起打怪升级，成为真正的高手。</p><p>感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给你的朋友。</p><p></p>","neighbors":{"left":{"article_title":"07 | 消息积压了该如何处理？","id":113401},"right":{"article_title":"09 | 学习开源代码该如何入手？","id":115519}},"comments":[{"had_liked":false,"id":121777,"user_name":"大龄小学生","can_delete":false,"product_type":"c1","uid":1057111,"ip_address":"","ucode":"AA7860B88FB0F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/57/ee02ef41.jpg","comment_is_top":true,"comment_ctime":1565223058,"is_pvip":false,"replies":[{"id":"44893","content":"你要的图来了。我在文中补充了一个流程图，便于同学们理解。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565326283,"ip_address":"","comment_id":121777,"utype":1}],"discussion_count":3,"race_medal":0,"score":"9.2233722145137009e+18","product_id":100032301,"comment_content":"老师，一图胜千言，来点图吧。","like_count":41,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461939,"discussion_content":"你要的图来了。我在文中补充了一个流程图，便于同学们理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565326283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133947,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIaOAxRlZjFkGfRBn420LuAcyWkMrpq5iafGdqthX5icJPjql0ibZOAdafaqbfvw4ZpVzDmsaYglVXDw/132","nickname":"唐朝农民","note":"","ucode":"6F8F43C6652225","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4328,"discussion_content":"赞同，我觉得 主题，Broker，消费组，队列，消费者之间的关系也是，我之前就见到一张描述Kafka这几个概念的图很好理解，不过现在忘了，尴尬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565316044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212378,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7f/da/73778db7.jpg","nickname":"侯鹏₁₈₆₁₄₀₉₂₄₁₉","note":"","ucode":"BB85A8993B4DBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4199,"discussion_content":"赞同，那个秒杀的案例，如果画个流程图就太棒了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1565224939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121842,"user_name":"linqw","can_delete":false,"product_type":"c1","uid":1134138,"ip_address":"","ucode":"09DCFE98C54DD8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","comment_is_top":false,"comment_ctime":1565232770,"is_pvip":false,"replies":[{"id":"44758","content":"我认真的看了同学的对于秒杀的理解，技术上都没什么问题。<br><br>从业务角度，老师有一些不同的看法。<br><br>对于秒杀这种场景，宏观上的设计应该是倾向于利用有限的资源处理短时间内海量的请求，保证服务不宕机。有少量请求处理出错（注意是后端错误，用户不可见）或消息丢失，是可以接受的。<br><br>毕竟秒杀拼的就是运气，某个用户秒杀请求在处理的时候丢失，和处理成功但没秒到，对于用户来说都是运气不好而已。<br><br>基于这样的设计理念，很多保证数据可靠性的做法都可以牺牲掉，用于换取系统更大的吞吐量比较划算。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565239926,"ip_address":"","comment_id":121842,"utype":1}],"discussion_count":2,"race_medal":0,"score":"276443139714","product_id":100032301,"comment_content":"学习完网关答疑篇，写下自己的理解和疑惑，老师有空帮忙看下哦<br>1、秒杀的理解:<br>APP--发送秒杀请求--》网关（也是RPC服务端，和配置中心保持长连接，比如nacos，将其路由和配置信息定时的发送给配置中心，配置中心对其进行管理，定时的清除宕机的网关路由信息，如超过一定时间没有接收到网关的心跳包）--》将其APP请求做一定的封装，增加网关id和网关实例中唯一的请求id发送给消息队列，为了保证消息不丢失，网关对其发送消息出现的异常进行处理，如超时异常，直接返回秒杀失败，网关发送消息的这个过程中可能涉及到分布式事务，使用消息队列的分布式事务进行处理，然后网关需要等待一段时间，等待秒杀服务端使用RPC调用网关实例的接收秒杀结果，为此创建一个新对象，将其请求id做为key，新对象做为value放入CurrentMap中，调用新对象的超时wait方法进行等待秒杀结果--发送封装的APP请求，包含网关id和请求id--》消息队列接收APP请求消息，为了保证消息不丢失，开启Sync_Flush参数将消息保存到磁盘，并且为了防止一台机器磁盘出问题，集群需要2台机器都有消息才确认请求--从消息队列中拉取消息--》秒杀服务端，为了低延迟执行风控、预占库存，拿到消息中网关id，从本地路由中查询网关id的实例信息，如果获取不到调用网关实例时，需先从配置中心获取到网关的路由信息，秒杀服务端也需和配置中心保持长连接，定时的从配置中心拉取网关的路由信息，保存到本地，使用RPC调用网关实例的接收秒杀结果的方法，为了保证消息不丢失，先执行消费逻辑，再响应消息队列，如果根据网关id获取不到网关实例，或者确认消息队列超时或出现异常，秒杀服务端回滚事务，此过程也涉及到分布式事务，为了防止消费重复消息，接口的幂等性，将请求id和网关id做为唯一键。也为了防止消息积压，消息队列中的主题队列和消费组中的消费者一一对应，保证消息被快速消费。<br>2、秒杀异步，APP发送请求给网关，网关接收请求后将请求做一定的封装（包括请求id，网关id，账户id），然后发送到消息队列中，响应APP请求，无需等待后需的流程，然后秒杀成功以否直接返回，后续流程处理完使用短信的形式告知用户是否秒杀成功，不知道这样做法是否可行。<br>3、最近在撸rocketmq的源码，搞了namesrv、logging、logappend模块，想成为commiter，立个flag，等后续JMQ出来，撸其源码，也想成为commiter，道阻且长，持续进化。","like_count":64,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461971,"discussion_content":"我认真的看了同学的对于秒杀的理解，技术上都没什么问题。\n\n从业务角度，老师有一些不同的看法。\n\n对于秒杀这种场景，宏观上的设计应该是倾向于利用有限的资源处理短时间内海量的请求，保证服务不宕机。有少量请求处理出错（注意是后端错误，用户不可见）或消息丢失，是可以接受的。\n\n毕竟秒杀拼的就是运气，某个用户秒杀请求在处理的时候丢失，和处理成功但没秒到，对于用户来说都是运气不好而已。\n\n基于这样的设计理念，很多保证数据可靠性的做法都可以牺牲掉，用于换取系统更大的吞吐量比较划算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565239926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134138,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/3a/86196508.jpg","nickname":"linqw","note":"","ucode":"09DCFE98C54DD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4228,"discussion_content":"理解老师的意思，在其有限的资源的基础上，在业务可以接受的范围内，资源用来处理主要的流程，如秒杀是为了保证高吞吐量，低延迟，可以牺牲一些可靠性，对用户来说也是秒杀失败。继续跟着老师盘个痛快，跳出来看全景，钻进源码看本质，mq搞清楚，当做是今年的礼物，mq封号斗罗走起，啦啦啦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565242528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121770,"user_name":"滴流乱转小胖儿","can_delete":false,"product_type":"c1","uid":1231250,"ip_address":"","ucode":"4689236E65FE4E","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/92/6361802a.jpg","comment_is_top":false,"comment_ctime":1565222100,"is_pvip":false,"replies":[{"id":"44754","content":"谢谢你，蔡徐坤同学。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565239027,"ip_address":"","comment_id":121770,"utype":1}],"discussion_count":8,"race_medal":0,"score":"151889077460","product_id":100032301,"comment_content":"mq界，吴彦祖老师你好，感谢分享","like_count":35,"discussions":[{"author":{"id":1663762,"avatar":"https://static001.geekbang.org/account/avatar/00/19/63/12/5a22fcc7.jpg","nickname":"第四范式","note":"","ucode":"61ECDC7C834CAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302750,"discussion_content":"老师，你怎么骂人呀。手动狗头","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1599020735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461935,"discussion_content":"谢谢你，蔡徐坤同学。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1565239027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1452244,"avatar":"https://static001.geekbang.org/account/avatar/00/16/28/d4/c110612d.jpg","nickname":"星汉当空","note":"","ucode":"C9F11CA5442E43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4613,"discussion_content":"你们真像魔教中人","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1565597250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1763976,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ea/88/b651ef77.jpg","nickname":"朱子七","note":"","ucode":"5EB46A502F4EEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288396,"discussion_content":"哈哈，吴亦凡路过。。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593741504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2956682,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/rvQxUmekECjyZu1RwbUguBWpBcQuKywQPtiaxNVFJSib07QMZnNUr8MnRF3RYEsn6MhgGFJibwlrVomibEicYMiaia7ZQ/132","nickname":"Geek_a8ce05","note":"","ucode":"C1D4002C48568F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1763976,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ea/88/b651ef77.jpg","nickname":"朱子七","note":"","ucode":"5EB46A502F4EEA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588724,"discussion_content":"大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664018140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":288396,"ip_address":"广东"},"score":588724,"extra":""}]},{"author":{"id":2014573,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","nickname":"SharpBB","note":"","ucode":"D30C5B798B8E8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572951,"discussion_content":"老师 不能骂人哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653099583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2252648,"avatar":"https://static001.geekbang.org/account/avatar/00/22/5f/68/8e4407c7.jpg","nickname":"💡","note":"","ucode":"8AB762A8CDFEF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541327,"discussion_content":"谢谢你，蔡徐坤","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640331834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023101,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","nickname":"study的程序员","note":"","ucode":"E5AE9037D24429","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372218,"discussion_content":"彭于晏路过。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620227362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134880,"user_name":"摩云神雕","can_delete":false,"product_type":"c1","uid":1109552,"ip_address":"","ucode":"446CA7AEFF2731","user_header":"https://static001.geekbang.org/account/avatar/00/10/ee/30/fc095d86.jpg","comment_is_top":false,"comment_ctime":1568946053,"is_pvip":false,"replies":[{"id":"51841","content":"多个消费组的时候，确实有你说的问题，partition数量需要兼顾所有消费者。一般的做法都是照顾消费最慢的那个消费组，按照它的速度和消费者数量来确定partition数量。<br><br>大部分MQ都支持动态扩容，增加分区数量，分区数量变更后，会重新分配消费者和分区对应关系，对生产基本没什么影响。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1569024692,"ip_address":"","comment_id":134880,"utype":1}],"discussion_count":5,"race_medal":0,"score":"108943128453","product_id":100032301,"comment_content":"请教下老师，topic的partition数 是根据什么确定的？<br><br>我理解partition的设置 是为了一个消费组中多个消费者并行消费的，<br>那么partition数根据什么设定呢？ 根据消费者数 和 broker机器的性能吗<br><br>假设我现在的kafka有 3个broker节点，<br>创建了一个topic， partition值设为5， <br>然后我的一个消费组中有5个消费者， 正好一个消费者 消费一个partition，<br><br>后续， 这个消费组 我又想加2个消费者，<br>呢partition数 也调成7 是吧？<br><br>但是， 我这个topic 可能被好几个消费组消费的，<br>你消费组A扩展了消费者数， 想扩展partition数，<br>但是 我消费组B没这个需求啊， 怎么办？<br><br>这个topic是消费组A、B、C、D大家共同订阅的， <br>就因为 你A组加了几个消费者， <br>我就去改这个topic的partition数吗？  这里没太想通；<br><br>另外，在生产环境中 改了partition数，会造成什么影响？","like_count":25,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467940,"discussion_content":"多个消费组的时候，确实有你说的问题，partition数量需要兼顾所有消费者。一般的做法都是照顾消费最慢的那个消费组，按照它的速度和消费者数量来确定partition数量。\n\n大部分MQ都支持动态扩容，增加分区数量，分区数量变更后，会重新分配消费者和分区对应关系，对生产基本没什么影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569024692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327156,"discussion_content":"就存在了有5个partition，但有7个消费者，也就是有两个消费者一直在空闲么？求老师讲解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605756074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332142,"discussion_content":"是的，没毛病","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607073984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327156,"ip_address":""},"score":332142,"extra":""},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575618,"discussion_content":"没那么多并发你搞这么多实例干嘛，钱多的慌？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654958653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327156,"ip_address":""},"score":575618,"extra":""}]},{"author":{"id":1346998,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8d/b6/55ba741a.jpg","nickname":"wiliam","note":"","ucode":"FF15363E72887A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50176,"discussion_content":"这个问题很好，也解答了我想问的，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573690658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":131065,"user_name":"虢國技醬","can_delete":false,"product_type":"c1","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1567619962,"is_pvip":false,"replies":[{"id":"49331","content":"是的，这时候就会有一个消费者没有干活的机会。<br><br>至于，如何分配队列与消费者的关系，不同的消息队列处理也不一样，有的消息队列是绑定队列与消费者，这样有一个消费者一直闲着，其它二个一直干活。<br><br>也有的消息队列是分时绑定，也就是你干一会儿，我干一会儿，但任何时刻，都会有一个消费者处于闲着的状态。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1567648949,"ip_address":"","comment_id":131065,"utype":1}],"discussion_count":2,"race_medal":0,"score":"104646835066","product_id":100032301,"comment_content":"&quot;同一个消费组内，每个队列只能被一个消费者实例占用&quot;<br>我在想：如果队列只有两个Q1和Q2，但是G1中有三个消费者实例C1，C2和C3；那会不会有一个消费者实例一直在偷懒（没有干活的机会，😂）。<br>对于这种情况会报错？还是说内部会有机制队列的占用是换着分配给消费者实例的（不是某个实例一直占用）？","like_count":24,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466270,"discussion_content":"是的，这时候就会有一个消费者没有干活的机会。\n\n至于，如何分配队列与消费者的关系，不同的消息队列处理也不一样，有的消息队列是绑定队列与消费者，这样有一个消费者一直闲着，其它二个一直干活。\n\n也有的消息队列是分时绑定，也就是你干一会儿，我干一会儿，但任何时刻，都会有一个消费者处于闲着的状态。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1567648949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327157,"discussion_content":"谢谢，解答了我的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605756114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":125842,"user_name":"木木木","can_delete":false,"product_type":"c1","uid":1240679,"ip_address":"","ucode":"5EBC11AB704EF2","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/67/d6d9499e.jpg","comment_is_top":false,"comment_ctime":1566264599,"is_pvip":false,"replies":[{"id":"46235","content":"扩容后只需要等一会儿，确保扩容之前的消息都消费完成了（不确定的话可以等久一点儿也没关系）再消费新分区的数据就可以了，生产不需要停。<br><br>因为一致性哈希可以保证单调性：如果已经有一些内容通过哈希分派到了相应的分区中，又有新的分区加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的分区中去，而不会被映射到旧的分区集合中的其他分区","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566266093,"ip_address":"","comment_id":125842,"utype":1}],"discussion_count":1,"race_medal":0,"score":"74580708631","product_id":100032301,"comment_content":"关于有序性还有疑惑，即使采用了一致性hash，无论扩容还是缩容队列，对分配相邻队列的用户部分还是有影响的，难道要等这些队列消费完了，阻止生产者发消息吗？感觉不具有可操作性","like_count":18,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463716,"discussion_content":"扩容后只需要等一会儿，确保扩容之前的消息都消费完成了（不确定的话可以等久一点儿也没关系）再消费新分区的数据就可以了，生产不需要停。\n\n因为一致性哈希可以保证单调性：如果已经有一些内容通过哈希分派到了相应的分区中，又有新的分区加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的分区中去，而不会被映射到旧的分区集合中的其他分区","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566266093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121948,"user_name":"大魔王汪汪","can_delete":false,"product_type":"c1","uid":1010680,"ip_address":"","ucode":"4B205CB52FC95F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","comment_is_top":false,"comment_ctime":1565254904,"is_pvip":false,"replies":[{"id":"44798","content":"同学那不是像，消息队列就是个分布式存储系统。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565274666,"ip_address":"","comment_id":121948,"utype":1}],"discussion_count":2,"race_medal":0,"score":"53104862456","product_id":100032301,"comment_content":"看了几期，感觉分布式消息队列的设计方案和分布式存储系统的设计方案很类似，如果再加上事务处理，存储细节方案应该更像了","like_count":12,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462019,"discussion_content":"同学那不是像，消息队列就是个分布式存储系统。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565274666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1590424,"avatar":"","nickname":"coder farmers","note":"","ucode":"B553E33BFB3FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339629,"discussion_content":"卧槽，消息队列就是个分布式存储系统","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609749321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123657,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1565741360,"is_pvip":false,"replies":[{"id":"45348","content":"这个案例中，你说的这种情况是有可能存在的。<br><br>是否需要补偿，也无所谓对错，总体效果是一样的。秒杀的目的就是从众多秒杀用户中公平的选择n个用户，补偿或不补偿，影响的只是这n个用户是谁的问题。<br><br>所以这是一个架构选择的问题。<br><br>我建议是不用补偿，按失败处理，锁定的库存超时未支付后会自动释放，好处是比较简单。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565746080,"ip_address":"","comment_id":123657,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48810381616","product_id":100032301,"comment_content":"秒杀这个案例中，超时之后不需要补偿机制吗，对于下游服务来说很可能以及成功了","like_count":11,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462760,"discussion_content":"这个案例中，你说的这种情况是有可能存在的。\n\n是否需要补偿，也无所谓对错，总体效果是一样的。秒杀的目的就是从众多秒杀用户中公平的选择n个用户，补偿或不补偿，影响的只是这n个用户是谁的问题。\n\n所以这是一个架构选择的问题。\n\n我建议是不用补偿，按失败处理，锁定的库存超时未支付后会自动释放，好处是比较简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565746080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1736650,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyuuhxu0HH4cIKCClCqx0LTurCCYWmNcFwfTWV5te5afsibp2yuDmC9mibEHx0Xy8QlvqvMWWcAib8g/132","nickname":"我的喵","note":"","ucode":"A7435BDBDD2587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570712,"discussion_content":"有没有一种可能：显示用户秒杀失败，但是订单管理页是可以看到秒杀成功未支付的订单的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651886482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122191,"user_name":"大白先生","can_delete":false,"product_type":"c1","uid":1615335,"ip_address":"","ucode":"7EF709EF8FFE6B","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/e7/ed0a0131.jpg","comment_is_top":false,"comment_ctime":1565314355,"is_pvip":false,"replies":[{"id":"44895","content":"会有这种情况。但无需特殊处理。<br><br>一般秒杀成功后，还有后续的支付流程。<br><br>有些用户秒杀成功也不会支付。你说的这种情况与“秒杀成功不支付”一并处理就行了。一般都是有一个支付超时，超过这个时限还没支付，就取消这个秒杀资格，自动释放库存。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565326700,"ip_address":"","comment_id":122191,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44514987315","product_id":100032301,"comment_content":"老师，在秒杀场景中，后端服务通过调用onResult方法来放入秒杀结果，有没有可能有一种情况，就是秒杀成功了，但是获取mutex是空，这样的活，会不会前段接收了秒杀失败的提示，但是库存扣减成功了","like_count":10,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462139,"discussion_content":"会有这种情况。但无需特殊处理。\n\n一般秒杀成功后，还有后续的支付流程。\n\n有些用户秒杀成功也不会支付。你说的这种情况与“秒杀成功不支付”一并处理就行了。一般都是有一个支付超时，超过这个时限还没支付，就取消这个秒杀资格，自动释放库存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565326700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1222966,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a9/36/d054c979.jpg","nickname":"G.S.K","note":"","ucode":"88217F9289EB48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291021,"discussion_content":"有同样疑问，看了老师的答案后明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594683739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147183,"user_name":"托尼斯威特","can_delete":false,"product_type":"c1","uid":1729060,"ip_address":"","ucode":"98A1035527292E","user_header":"https://static001.geekbang.org/account/avatar/00/1a/62/24/07e2507c.jpg","comment_is_top":false,"comment_ctime":1572833947,"is_pvip":false,"replies":[{"id":"57130","content":"首先强调一下，并不是“每个队列只要一个单线程消费者”，而是“每个队列只能被一个消费者实例占用。”<br><br>rocketMQ的MessageListenerConcurrently，和我们上面讲的内容也不矛盾，它这个并行消费是完全在客户端实现的。大致的原理就是：<br><br>1. 客户端从服务端的某个队列读取一批消息；<br>2. 分发给客户端的多个线程消费；<br>3. 都消费成功后，给服务端返回消费成功确认。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1573007843,"ip_address":"","comment_id":147183,"utype":1}],"discussion_count":5,"race_medal":1,"score":"40227539611","product_id":100032301,"comment_content":"刚开始学习 RocketMQ. Consumer可以register的MessageListener 有两种: MessageListenerOrderly 和 MessageListenerConcurrently.  <br>这和老师讲的, RocketMQ 每个queue只要一个单线程消费者矛盾吗?","like_count":9,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473185,"discussion_content":"首先强调一下，并不是“每个队列只要一个单线程消费者”，而是“每个队列只能被一个消费者实例占用。”\n\nrocketMQ的MessageListenerConcurrently，和我们上面讲的内容也不矛盾，它这个并行消费是完全在客户端实现的。大致的原理就是：\n\n1. 客户端从服务端的某个队列读取一批消息；\n2. 分发给客户端的多个线程消费；\n3. 都消费成功后，给服务端返回消费成功确认。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573007843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1182383,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/af/6f244997.jpg","nickname":"lee","note":"","ucode":"CD672BDB1B58F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325479,"discussion_content":"MessageListenerConcurrently的主题，如果要求每个消费者实例保证严格有序是不是消费者实例里面必须只有一个线程呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605326435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1729060,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/62/24/07e2507c.jpg","nickname":"托尼斯威特","note":"","ucode":"98A1035527292E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1182383,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/af/6f244997.jpg","nickname":"lee","note":"","ucode":"CD672BDB1B58F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":325570,"discussion_content":"虽然这种情况应该用Ordely, 不过是个好问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605351726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325479,"ip_address":""},"score":325570,"extra":""},{"author":{"id":1182383,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/af/6f244997.jpg","nickname":"lee","note":"","ucode":"CD672BDB1B58F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1729060,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/62/24/07e2507c.jpg","nickname":"托尼斯威特","note":"","ucode":"98A1035527292E","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":326288,"discussion_content":"是我写错了 应该是Orderly的主题，如果要求每个消费者实例保证严格有序是不是消费者实例里面必须只有一个线程呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605576129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325570,"ip_address":""},"score":326288,"extra":""},{"author":{"id":2322960,"avatar":"","nickname":"董董","note":"","ucode":"F4839D1C0078B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1182383,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0a/af/6f244997.jpg","nickname":"lee","note":"","ucode":"CD672BDB1B58F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":327161,"discussion_content":"如果是Orderly主题，一个消费者单次拉一个数据，拉的一个数据你可以用多线程处理「代码内部逻辑，一个消息需要发优惠券与发短信这是两个操作可以用多线程处理」，但是最后肯定会有一个ack，但是消息之间的处理还是有序的，需要等到ack之后下一条消息才会被pull出来","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605756545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326288,"ip_address":""},"score":327161,"extra":""}]}]},{"had_liked":false,"id":126820,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1566483414,"is_pvip":false,"replies":[{"id":"46935","content":"消息什么时候删除取决于消息队列的配置，比如Kafka默认就是超过多长时间后就自动删除了。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566522947,"ip_address":"","comment_id":126820,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40221189078","product_id":100032301,"comment_content":"消息一直在队列里不删除？","like_count":9,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464184,"discussion_content":"消息什么时候删除取决于消息队列的配置，比如Kafka默认就是超过多长时间后就自动删除了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566522947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1597566,"avatar":"https://static001.geekbang.org/account/avatar/00/18/60/7e/9e61c349.jpg","nickname":"骑猪飞翔","note":"","ucode":"9754362861F2B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404637,"discussion_content":"今天生产的消息明天新来一个消费者能消费到昨天的消息吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634368523,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121734,"user_name":"haha","can_delete":false,"product_type":"c1","uid":1036122,"ip_address":"","ucode":"1F018DC1DFEEE4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/5a/ce1011b1.jpg","comment_is_top":false,"comment_ctime":1565194268,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"40219899932","product_id":100032301,"comment_content":"七夕不过节，继续学习 —— 谁让我是单身狗呢","like_count":9,"discussions":[{"author":{"id":2032840,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","nickname":"Javatar","note":"","ucode":"E216645CDF632C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332143,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607074163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1617257,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ad/69/ea32993e.jpg","nickname":"cjj","note":"","ucode":"E25A7D4B7FB634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4394,"discussion_content":"咱一起学：)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565350118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160232,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1575895705,"is_pvip":false,"replies":[{"id":"61573","content":"其实这些最基础的算法和数据结构的应用是非常广泛的，只是为了方便，被很多中间件或者底层系统给封装后，对一般的业务开发人员就不可见了。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1576299040,"ip_address":"","comment_id":160232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35935634073","product_id":100032301,"comment_content":"说到一致性哈希算法，王争老师的算法课程里专门有一课讲一致性哈希，跟李玥老师的课互相印证，算法就落地了","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477305,"discussion_content":"其实这些最基础的算法和数据结构的应用是非常广泛的，只是为了方便，被很多中间件或者底层系统给封装后，对一般的业务开发人员就不可见了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576299040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146965,"user_name":"切糕","can_delete":false,"product_type":"c1","uid":1185409,"ip_address":"","ucode":"DCD3C14CAC4ED3","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/81/77f84354.jpg","comment_is_top":false,"comment_ctime":1572745741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35932484109","product_id":100032301,"comment_content":"我是看了rocketMQ源码后在看了一遍，受益匪浅","like_count":9},{"had_liked":false,"id":121855,"user_name":"猿人谷","can_delete":false,"product_type":"c1","uid":1100149,"ip_address":"","ucode":"85106C7FB14C43","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/75/62ce2d69.jpg","comment_is_top":false,"comment_ctime":1565235114,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"35924973482","product_id":100032301,"comment_content":"这篇答疑解惑，虽然简短，但绝对的诚意十足。希望多出这种答疑解惑的章节，毕竟评论区里很多留言的问题非常有代表性，对代表性的问题出这种答疑解惑的章节，学到的更多，也更能体现大家的参与度。","like_count":8},{"had_liked":false,"id":121985,"user_name":"skyun","can_delete":false,"product_type":"c1","uid":1002658,"ip_address":"","ucode":"38097F3FF1045C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/a2/00241866.jpg","comment_is_top":false,"comment_ctime":1565264472,"is_pvip":false,"replies":[{"id":"44792","content":"a1：这个只能关闭重试队列。<br>a2: consumer rebalance不会影响到消费顺序，因为对于单个队列来说，无论是不是rebalance，都是串行消费的。<br>a3：这个无需担心，也不用做任何处理，消息队列自身可以保证即使broker宕机发生切换，依然保证队列中消息的顺序不会变。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565274137,"ip_address":"","comment_id":121985,"utype":1}],"discussion_count":4,"race_medal":0,"score":"27335068248","product_id":100032301,"comment_content":"关于顺序消息还是有点疑问，考虑一下几个场景：<br>1、消息消费失败进入了重试队列；<br>2、增加或减少了消费者组里的消费者个数，导致consumer与queue之间的对应关系重新映射；<br>3、broker节点故障或者超时导致投递失败，业务上重新选择broker投递<br>这几种场景下，即使在投递时通过selector进行选择了queue，我想依旧会导致消息的乱序，请教下老师，这对在这些场景下，得分别采用怎么样的方式来保证消息的有序性。问题有点多，麻烦老师了","like_count":6,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462044,"discussion_content":"a1：这个只能关闭重试队列。\na2: consumer rebalance不会影响到消费顺序，因为对于单个队列来说，无论是不是rebalance，都是串行消费的。\na3：这个无需担心，也不用做任何处理，消息队列自身可以保证即使broker宕机发生切换，依然保证队列中消息的顺序不会变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565274137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":531983,"discussion_content":"啊 那如果消息消费失败了，岂不是后面的消息全部卡住了。这么看，真正实现单队列的有序成本也很高呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637488002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":462044,"ip_address":""},"score":531983,"extra":"{\"user_type\":1}"},{"author":{"id":1272996,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6c/a4/7f7c1955.jpg","nickname":"死磕郎一世","note":"","ucode":"86C1197C3FB2A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112676,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fa/64/457325e6.jpg","nickname":"Sam Fu","note":"","ucode":"EA285A4943271F","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":554156,"discussion_content":"没办法啊，你严格要求消费顺序，如果跳过失败的消息，那就不能保证有序性了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646229559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":531983,"ip_address":""},"score":554156,"extra":""}]},{"author":{"id":2845349,"avatar":"","nickname":"李文博","note":"","ucode":"C238A840DA60DE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539389,"discussion_content":"a3，这个是怎么保证的，假设在消费主的broker的c消息时挂了，备机只同步到A消息了，这样消息的顺序不就变了吗。我们消费了ABA消息了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639705298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126369,"user_name":"vi","can_delete":false,"product_type":"c1","uid":1504664,"ip_address":"","ucode":"943CADFE6C1A6A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIBabuBHlohpGYRDt4mwWghVDztHyRnC9SfyYnENUZNbCe8m05qQn0cHdiazU4eKmMtSQ0bHicwLLQ/132","comment_is_top":false,"comment_ctime":1566373853,"is_pvip":false,"replies":[{"id":"46817","content":"想要增加消费并发，可以考虑exchange把消息平均的分摊到多个消费队列中。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566435117,"ip_address":"","comment_id":126369,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23041210333","product_id":100032301,"comment_content":"李sir，一个迟来的学生，刚刚看到这里，对于rabbitmq来说，没有消费组队列，只有exchange转送到相应的对列中，要想提高并发，看到的方法可以设置多线程消息，好像变成了单个对列并行消息的模式，会不会也有文中所说的这个问题，rabbitmq还可以通过设置prefetch来缓存一定的数目，是不是就相当于增加每个消费者的队列数来解决并发的问题了","like_count":5,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463955,"discussion_content":"想要增加消费并发，可以考虑exchange把消息平均的分摊到多个消费队列中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566435117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504664,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIBabuBHlohpGYRDt4mwWghVDztHyRnC9SfyYnENUZNbCe8m05qQn0cHdiazU4eKmMtSQ0bHicwLLQ/132","nickname":"vi","note":"","ucode":"943CADFE6C1A6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5741,"discussion_content":"rabbitmq一般是通过什么方式来完成的呢？1.通过配置可以搞定么或者2.对于同一类消息，创建几个队列q1，q2,q3,q4，消费者各自绑定这几个队列，发消息时再通过一定算法比如hash平分到这几个队列中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566457850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":222265,"user_name":"Geek_821c96","can_delete":false,"product_type":"c1","uid":1092407,"ip_address":"","ucode":"B07B528F2E12C6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ab/37/455d6a8d.jpg","comment_is_top":false,"comment_ctime":1590731504,"is_pvip":false,"replies":[{"id":"82355","content":"这是个选择的问题，无所谓哪个更好。使用Redis持久化秒杀请求后，引入了复杂度和故障点，系统维护更困难了，但提升了请求的成功率，秒杀服务变为无状态服务代码逻辑也更简单。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1591150232,"ip_address":"","comment_id":222265,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18770600688","product_id":100032301,"comment_content":"老师，你好。<br>秒杀结果的map是不是可以替换成Redis更好些？","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496733,"discussion_content":"这是个选择的问题，无所谓哪个更好。使用Redis持久化秒杀请求后，引入了复杂度和故障点，系统维护更困难了，但提升了请求的成功率，秒杀服务变为无状态服务代码逻辑也更简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591150232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122020,"user_name":"大白先生","can_delete":false,"product_type":"c1","uid":1615335,"ip_address":"","ucode":"7EF709EF8FFE6B","user_header":"https://static001.geekbang.org/account/avatar/00/18/a5/e7/ed0a0131.jpg","comment_is_top":false,"comment_ctime":1565269792,"is_pvip":false,"replies":[{"id":"44791","content":"我们不是在考虑如何来实现并行消费么？就不能再遵循现有的串行消费的限制了呀。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565273658,"ip_address":"","comment_id":122020,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18745138976","product_id":100032301,"comment_content":"对于这句话我不是很理解，还请老师帮忙解答。“队列中当前有 10 条消息，对应的编号是 0-9，当前的消费位置是 5。同时来了三个消费者来拉消息，把编号为 5、6、7 的消息分别给三个消费者，每人一条。”一个消费队列在一个消费组内不是只有一个消费者可以消费消息么，怎么能够同时来拉消息。如果您说的三个消费者是三个消费组的话，每个消费组维护自己的消费位置都是5，那么消费的都会是编号5的消息呀。","like_count":4,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462060,"discussion_content":"我们不是在考虑如何来实现并行消费么？就不能再遵循现有的串行消费的限制了呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565273658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019351,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/d7/886e9563.jpg","nickname":"张高","note":"","ucode":"9E5EB8675E4956","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5580,"discussion_content":"消费5 6 7三个消费者的是同一个组。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566359736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5523,"discussion_content":"哈哈，这个问题难为老师啦！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566344788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143054,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1571624648,"is_pvip":false,"replies":[{"id":"55376","content":"关于如何保证严格顺序的问题，我们在这节课中也有讲到哦。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1571706995,"ip_address":"","comment_id":143054,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14456526536","product_id":100032301,"comment_content":"如果有一台机器宕机了，而宕机前某个队列记录的是这个账户的流水账，宕机后这个账户的流水账可能会转移到其他的队列，这个时候怎么保证这个账户的流水账是有序的呢？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471363,"discussion_content":"关于如何保证严格顺序的问题，我们在这节课中也有讲到哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571706995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134145,"user_name":"肥low","can_delete":false,"product_type":"c1","uid":1043480,"ip_address":"","ucode":"A158AFAAB8C742","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","comment_is_top":false,"comment_ctime":1568767198,"is_pvip":false,"replies":[{"id":"51437","content":"你提这两个问题的原因都是没有搞清楚队列和队列的副本这两个概念。<br><br>队列是一个逻辑概念，一个主题包含多个队列，这个好理解。<br><br>为了保证消息数据可靠性，在Broker集群中，每个队列一般都有多个副本，同一个队列的多个副本里面的数据是一样的。<br><br>就像HDFS，每个文件都有3个副本，你通过它的API访问的时候，你是看不见副本的，一个文件就是一个文件。<br><br>如果你直接去存放HDFS文件的服务器上去用操作系统的命令去看，你就可以看到文件的多个副本。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1568769953,"ip_address":"","comment_id":134145,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14453669086","product_id":100032301,"comment_content":"老师，我有点疑问<br><br>1. 你之前在回复区说一条消息只会发送到一个队列，现在又说也可以发到多个队列，有点矛盾，这样不就肯定存在重复消息的可能了么<br>2. 这篇中的例子中，两个broker被分配了不同的队列，那在“如何保证消息不丢失”那篇中你说多个broker的情况下可以设置成生产消息后最少2个broker正确应答才能算发送成功，那两个broker中的队列应该保持高度一致才对啊<br><br>完全蒙圈了😂","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467630,"discussion_content":"你提这两个问题的原因都是没有搞清楚队列和队列的副本这两个概念。\n\n队列是一个逻辑概念，一个主题包含多个队列，这个好理解。\n\n为了保证消息数据可靠性，在Broker集群中，每个队列一般都有多个副本，同一个队列的多个副本里面的数据是一样的。\n\n就像HDFS，每个文件都有3个副本，你通过它的API访问的时候，你是看不见副本的，一个文件就是一个文件。\n\n如果你直接去存放HDFS文件的服务器上去用操作系统的命令去看，你就可以看到文件的多个副本。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568769953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043480,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","nickname":"肥low","note":"","ucode":"A158AFAAB8C742","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14564,"discussion_content":"多谢老师o(^o^)o","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568771301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043480,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/18/bf7254d3.jpg","nickname":"肥low","note":"","ucode":"A158AFAAB8C742","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":14563,"discussion_content":"多谢老师o(^o^)o","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568771301,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124965,"user_name":"康师傅","can_delete":false,"product_type":"c1","uid":1154203,"ip_address":"","ucode":"7D71E93E8B41AA","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/9b/eec0d41f.jpg","comment_is_top":false,"comment_ctime":1566029628,"is_pvip":false,"replies":[{"id":"45894","content":"可以使用RocketMQ的服务端过滤功能，正好可以满足你这个需求。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566121394,"ip_address":"","comment_id":124965,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14450931516","product_id":100032301,"comment_content":"如果一个topic中有多个消费者，但每个消费者可能只需要其中的一部分数据，一种可行的方案是消费者消费全量消息，然后自行过滤；另一种方式是生产者将这些消息进行分类，不同类别的消息分别对应不同的topic，但这样可能会出现N多的topic，topic太多是否又会出现随机io太多导致性能问题，另外对生产端的编码也不友好，每种消息都要感知发到哪个topic中<br><br>这种情况下应该如何取舍<br>","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463384,"discussion_content":"可以使用RocketMQ的服务端过滤功能，正好可以满足你这个需求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566121394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124915,"user_name":"发条橙子 。","can_delete":false,"product_type":"c1","uid":1259218,"ip_address":"","ucode":"ED076F4534FFED","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","comment_is_top":false,"comment_ctime":1566014342,"is_pvip":false,"replies":[{"id":"45892","content":"JSR是一个标准，Spring是JSR的一个实现，并做了很多的扩展。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566121261,"ip_address":"","comment_id":124915,"utype":1}],"discussion_count":4,"race_medal":0,"score":"14450916230","product_id":100032301,"comment_content":"老师，我的疑问点有些偏 。 我看老师依赖注入用的是JSR330的注释 Inject ， 但实际上和spring自身的 Autowired 注释功能相同， 所以我平时都是直接用 spring 自带的注释。 请问老师使用 JSR330 提供的注释是有什么讲究莫","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463356,"discussion_content":"JSR是一个标准，Spring是JSR的一个实现，并做了很多的扩展。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566121261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575620,"discussion_content":"说明京东不是用的spring","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654959013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1835642,"avatar":"","nickname":"叶子","note":"","ucode":"41131155D75B09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225341,"discussion_content":"这种情况基本上不可能发生😀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586355930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147711,"avatar":"https://static001.geekbang.org/account/avatar/00/11/83/3f/bc2ea80d.jpg","nickname":"陌.寒哲","note":"","ucode":"B7079FF211D712","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98741,"discussion_content":"这就是面向接口编程的思路，使用Inject注解，带来的好处是将来如果万一要换别的依赖注入机制，这些就不用改了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577184479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122228,"user_name":"sswzfly","can_delete":false,"product_type":"c1","uid":1198806,"ip_address":"","ucode":"6B8889325FAFA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/d6/eba8d83c.jpg","comment_is_top":false,"comment_ctime":1565319605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14450221493","product_id":100032301,"comment_content":"我是消息队列小达人了","like_count":3},{"had_liked":false,"id":121950,"user_name":"明日","can_delete":false,"product_type":"c1","uid":1003917,"ip_address":"","ucode":"348899EC65AE8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/8d/09f28606.jpg","comment_is_top":false,"comment_ctime":1565255571,"is_pvip":false,"replies":[{"id":"44796","content":"严格的说，ACI都没实现，只有D实现了。<br><br>放宽点儿限制的话，或者考虑实际效果的话，A（原子性）绝大多数情况下还是可以保证的，即“要么都成功，要么都失败”。C（一致性）通过补偿，大部分情况下也可以保证最终一致。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565274605,"ip_address":"","comment_id":121950,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14450157459","product_id":100032301,"comment_content":"老师，关于事务消息的ACID那个问题没有提到，能不能找机会说下你的看法？个人的看法是没有实现隔离性，一致性只能保证最终一致，而原子操作和持久化可以通过各种手段实现。","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462020,"discussion_content":"严格的说，ACI都没实现，只有D实现了。\n\n放宽点儿限制的话，或者考虑实际效果的话，A（原子性）绝大多数情况下还是可以保证的，即“要么都成功，要么都失败”。C（一致性）通过补偿，大部分情况下也可以保证最终一致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565274605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003917,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/51/8d/09f28606.jpg","nickname":"明日","note":"","ucode":"348899EC65AE8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4294,"discussion_content":"谢谢老师回复，简单看了rabbitmq文档也是类似的说明，看来万事总是难两全。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565279793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121793,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1565225097,"is_pvip":false,"replies":[{"id":"44755","content":"我觉得是Kafka吧，功能足够复杂，而且老外写代码的脑回路和我们不大一样。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565239180,"ip_address":"","comment_id":121793,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14450126985","product_id":100032301,"comment_content":"相对来说，哪一个消息队列的学习成本较高？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461948,"discussion_content":"我觉得是Kafka吧，功能足够复杂，而且老外写代码的脑回路和我们不大一样。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565239180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1495355,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d1/3b/03d21d78.jpg","nickname":"奎因","note":"","ucode":"1A191B66ECF899","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5309,"discussion_content":"我也觉得老外的代码逻辑有点奇葩，可能是开源项目看多了，每次看到难以理解的逻辑我就认为是老外写的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566168051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124273,"user_name":"一杯敬月光","can_delete":false,"product_type":"c1","uid":1308687,"ip_address":"","ucode":"94C801115C41C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIPy34APc2QAOxvRWuZWLBrZZ134Qs89K0icGye4HLacic1ekZnu2s80gMRDF5hmmu8LD0mhDsleRVg/132","comment_is_top":false,"comment_ctime":1565849011,"is_pvip":false,"replies":[{"id":"45723","content":"Kafka的分区选择器是可以配置的，默认情况下，如果不传入key，采用轮询算法，传入key的话，按照key做普通hash，然后哈希值与分区总数取模，计算出分区号。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565918092,"ip_address":"","comment_id":124273,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10155783603","product_id":100032301,"comment_content":"老师，把消息传入kafka的函数中，参数key本身的实现是普通hash还是一致性hash？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463093,"discussion_content":"Kafka的分区选择器是可以配置的，默认情况下，如果不传入key，采用轮询算法，传入key的话，按照key做普通hash，然后哈希值与分区总数取模，计算出分区号。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565918092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122242,"user_name":"微微一笑","can_delete":false,"product_type":"c1","uid":1250327,"ip_address":"","ucode":"CFA7ABE81D0B99","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/17/8763dced.jpg","comment_is_top":false,"comment_ctime":1565321434,"is_pvip":false,"replies":[{"id":"44894","content":"你可以再看一下这课的文本，我补充了一个流程图。<br><br>对于你说的这个情况，是不会出现的。因为，后端服务返回的秒杀结果，只会存放在Map中，并不会直接返回APP。<br><br>给APP返回结果的，只能是处理APP请求的那个线程。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565326493,"ip_address":"","comment_id":122242,"utype":1}],"discussion_count":5,"race_medal":0,"score":"10155256026","product_id":100032301,"comment_content":"老师好，看了秒杀的代码，有点疑问：<br>等待后端超过timeout设置的时间点，且没有秒杀结果，finally代码块中会remove掉这个请求id，并返回用户秒杀失败；若在remove之前，后端服务返回了秒杀结果并秒杀成功，在非常极致的情况下，会不会出现用户看到秒杀失败，系统却秒杀成功的情况发生呢？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462170,"discussion_content":"你可以再看一下这课的文本，我补充了一个流程图。\n\n对于你说的这个情况，是不会出现的。因为，后端服务返回的秒杀结果，只会存放在Map中，并不会直接返回APP。\n\n给APP返回结果的，只能是处理APP请求的那个线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565326493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","nickname":"饭粒","note":"","ucode":"4C3220B0D43997","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42597,"discussion_content":"这描述的和楼上 @Liam 同学是一样的问题吧，感觉那里老师的解答更准确。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572706331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1315147,"avatar":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","nickname":"xfan","note":"","ucode":"48ED8D498D7F56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41309,"discussion_content":"我个人认为是有可能的，因为超时时已经秒杀成功了，但此时还没有收到后端的返回。这个时候也是合理的，为什么呢，只少不多，对商家来说不能亏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572398512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133711,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/8f/a90b3969.jpg","nickname":"oldman","note":"","ucode":"6BACE2832B4429","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4765,"discussion_content":"接这位同学的提问，这个处理顺序也必须是顺序的吧，我指的是比如1，2，3，4四个秒杀请求，现在都在挂起状态等待秒杀结果，如果这个时间2的结果回来了唤起了1的处理进程，那是不是1的结果还没处理完呢就已经宣告1秒杀失败了，这个时间如果1的后台处理又完成了该怎么办呢老师，求解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565707410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1133711,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/8f/a90b3969.jpg","nickname":"oldman","note":"","ucode":"6BACE2832B4429","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":105896,"discussion_content":"这里是会有一个map存请求id和锁的对应关系，所以请求2返回的时候会拿它的请求id找到它对应的锁唤醒2线程。所以1不会被唤醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577497981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4765,"ip_address":""},"score":105896,"extra":""}]}]},{"had_liked":false,"id":122160,"user_name":"ykkk88","can_delete":false,"product_type":"c1","uid":1068585,"ip_address":"","ucode":"A1BCFC2F0D1022","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/29/1be3dd40.jpg","comment_is_top":false,"comment_ctime":1565312356,"is_pvip":false,"replies":[{"id":"44896","content":"就是这样的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565326757,"ip_address":"","comment_id":122160,"utype":1}],"discussion_count":1,"race_medal":2,"score":"10155246948","product_id":100032301,"comment_content":"用一致性hash来确定producer 也是为了扩容后 之前的key还是分到之前的partition吧？要是不用一致性hash就会分散到其他分区？","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462126,"discussion_content":"就是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565326757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122125,"user_name":"miniluo","can_delete":false,"product_type":"c1","uid":1397339,"ip_address":"","ucode":"5735B6DEE7902B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/FheCgo4Ovibo0L1vAGgMdZkzQMm1GUMHMMqQ8aglufXaD2hW9z96DjQicAam723jOCZwXVmiaNiaaq4PLsf4COibZ5A/132","comment_is_top":false,"comment_ctime":1565308159,"is_pvip":false,"replies":[{"id":"44963","content":"A1：一般不回滚了，当做秒杀失败处理。<br><br>A2：如果需要严格顺序，就只能关闭重试队列。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565420744,"ip_address":"","comment_id":122125,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10155242751","product_id":100032301,"comment_content":"老师我有2个疑问需要麻烦您解答。<br>Q1、文中秒杀，等待网关响应时timeout，而此时后端又刚好在消费该请求，那怎么timeout是否需要通知回滚？<br>Q2、有同学提到按顺序执行的队列，执行某消息失败，则将该消息放入重试队列。若顺序执行非常严格的业务场景，例如审批流程；怎么确保顺序结果是正确的？盼回，谢谢","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462113,"discussion_content":"A1：一般不回滚了，当做秒杀失败处理。\n\nA2：如果需要严格顺序，就只能关闭重试队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565420744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216530,"user_name":"陆老师","can_delete":false,"product_type":"c1","uid":1203293,"ip_address":"","ucode":"0EA27C4755FF4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5c/5d/974b033f.jpg","comment_is_top":false,"comment_ctime":1589277700,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884244996","product_id":100032301,"comment_content":"但是有个疑问，等待超时但后端秒杀服务处理成功了，前端显示秒杀失败，但是秒杀成功就生成订单了呀，用户看到不就懵逼了么","like_count":1},{"had_liked":false,"id":161204,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1576146386,"is_pvip":false,"replies":[{"id":"61576","content":"这块儿不同的MQ的实现是不一样的，比如Kafka，它有一个协调者的角色，专门负责做这个事情。配对没有什么特殊的规则，确保所有的队列都能尽量均匀的分给所有的consumer就好了。<br><br>","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1576299451,"ip_address":"","comment_id":161204,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871113682","product_id":100032301,"comment_content":"系统什么时候给 customer 和 消息队列 做的配对 这个配对规则是什么样的？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477642,"discussion_content":"这块儿不同的MQ的实现是不一样的，比如Kafka，它有一个协调者的角色，专门负责做这个事情。配对没有什么特殊的规则，确保所有的队列都能尽量均匀的分给所有的consumer就好了。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576299451,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139192,"user_name":"幼儿编程教学","can_delete":false,"product_type":"c1","uid":1237199,"ip_address":"","ucode":"F13F3150E6CAE9","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/cf/43f201f2.jpg","comment_is_top":false,"comment_ctime":1570584741,"is_pvip":false,"replies":[{"id":"53665","content":"如果可以牺牲这两点，当然是可以并行消费的，吞吐量可以大幅提升。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1570594459,"ip_address":"","comment_id":139192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5865552037","product_id":100032301,"comment_content":"因为要保持有序，且要ack，所以无法并行吧。如果，这2点都不需要呢？那是否能单个队列多个消费者并行?性能大幅提升?毕竟，队列数量，不容易临时调整吧?","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469838,"discussion_content":"如果可以牺牲这两点，当然是可以并行消费的，吞吐量可以大幅提升。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570594459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126823,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1566484003,"is_pvip":false,"replies":[{"id":"46938","content":"队列","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1566522977,"ip_address":"","comment_id":126823,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5861451299","product_id":100032301,"comment_content":"订阅模型中，消息的发送方称为发布者（Publisher），消息的接收方称为订阅者（Subscriber），服务端存放消息的容器称为主题（Topic）。发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个动作，同时还可以认为是主题在消费时的一个逻辑副本，每份订阅中，订阅者都可以接收到主题的所有消息。<br><br>那么消息到底存储在主题里还是队列里？？？？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464185,"discussion_content":"队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566522977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043738,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","nickname":"asdf100","note":"","ucode":"39D8D71453E575","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5919,"discussion_content":"如果是保存在队列里的话，如果订阅者多的话，有消息时候将消息分发到每个队列里，然后每个订阅者在消费自己的队列吗？\n订阅后主题后再有新消息时可以消费，那订阅前的消息能不能消费？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566536402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122002,"user_name":"Mark Yao","can_delete":false,"product_type":"c1","uid":1091768,"ip_address":"","ucode":"0535CEB691F618","user_header":"https://static001.geekbang.org/account/avatar/00/10/a8/b8/73ef30ed.jpg","comment_is_top":false,"comment_ctime":1565267222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860234518","product_id":100032301,"comment_content":"受益老师说的先宏观在微观深入，同时做事不需要整体有序，达到局部有序即可。","like_count":1},{"had_liked":false,"id":121953,"user_name":"朱振光","can_delete":false,"product_type":"c1","uid":1622591,"ip_address":"","ucode":"132631BA843436","user_header":"https://static001.geekbang.org/account/avatar/00/18/c2/3f/42fc8939.jpg","comment_is_top":false,"comment_ctime":1565256173,"is_pvip":false,"replies":[{"id":"44795","content":"可以通过exchange路由到多个消费队列来变相实现，具体可以看下文档：<br><br>https:&#47;&#47;www.rabbitmq.com&#47;tutorials&#47;tutorial-three-python.html","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565274411,"ip_address":"","comment_id":121953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5860223469","product_id":100032301,"comment_content":"rabbitmq可以实现类似topic和消费组的概念吗？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462022,"discussion_content":"可以通过exchange路由到多个消费队列来变相实现，具体可以看下文档：\n\nhttps://www.rabbitmq.com/tutorials/tutorial-three-python.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565274411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121827,"user_name":"Loren","can_delete":false,"product_type":"c1","uid":1270750,"ip_address":"","ucode":"4DF8A106C984F3","user_header":"https://static001.geekbang.org/account/avatar/00/13/63/de/91fada7a.jpg","comment_is_top":false,"comment_ctime":1565230011,"is_pvip":false,"replies":[{"id":"44757","content":"这个synchronized是必须加的，你可以看一下wait的JavaDoc。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565239363,"ip_address":"","comment_id":121827,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5860197307","product_id":100032301,"comment_content":"      &#47;&#47; 等待后端处理<br>      synchronized(mutex) {<br>        mutex.wait(timeout);<br>      } 这个是不是不用加锁？","like_count":1,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461965,"discussion_content":"这个synchronized是必须加的，你可以看一下wait的JavaDoc。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565239363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375911,"discussion_content":"wait方法只能在synchronized关键字内部使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621866571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121735,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1565194422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5860161718","product_id":100032301,"comment_content":"老师说的没错，学习要先有一个宏观的认识，然后再去深入细节。<br>我去了解了下公司用的nsq，其实设计都是大同小异，就是名称不一样，比如消费者队列，它称之为channel，但是含义是一样的。<br>","like_count":1},{"had_liked":false,"id":357695,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"上海","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1663569348,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663569348","product_id":100032301,"comment_content":"想问下，消息队列是一条了，但是队列上的消息顺序颠倒了，这种情况怎么处理啊？<br>","like_count":0},{"had_liked":false,"id":352105,"user_name":"Geek_eca226","can_delete":false,"product_type":"c1","uid":3021110,"ip_address":"","ucode":"E738A5618F3218","user_header":"","comment_is_top":false,"comment_ctime":1658387323,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658387323","product_id":100032301,"comment_content":"在另一位老师的课上说，微服务网关比如springcloud gateway，去处理业务逻辑是不太好的吧，感觉网关只做一个路由和转发比较好","like_count":0},{"had_liked":false,"id":348326,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1654961520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654961520","product_id":100032301,"comment_content":"秒杀代码网关是rpc 的服务端， 后端是客户端，不在一个机器上，如何使用synchronized 等待唤醒？","like_count":0},{"had_liked":false,"id":348321,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1654957696,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654957696","product_id":100032301,"comment_content":"老师，可以讲讲tag 是啥","like_count":0},{"had_liked":false,"id":346389,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1653099524,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653099524","product_id":100032301,"comment_content":"rocketmq和kafka消息模型<br>\t生产者发送给topic的队列 如果有多个生产者 不用管是哪个队列 随便发<br>\t搞清楚消费组和消费者 每个消费组都可以消费完整的全队列消息<br>\t\t但消费组里的消费者存在竞争关系 消费者不会重复消费队列消息<br>\t\t消费后维护的offset只针对消费组 消费组内部各个消费者之间的offset是不做区分的<br>如何实现单队列并行消费<br>\t其实很简单 10条消息 三个消费者 osffset是5<br>\t\t那么接下来就是567 各分给三个消费者消费即可 <br>\t\t\t消费成功 offset变为8<br>\t\t消费失败 不如6失败<br>\t\t\t总不能一直等吧 将6对应的消息复制进一个特殊的重试队列中去<br>\t\t\t依然把消费位置改为8 等到新的消费者过来 优先去重试队列消费即可<br>\t但是要注意并行消费开销很大 不作为常规方案使用<br>如何保证顺序消费<br>\t在topic层面无法保证顺序 但是我们可以在队列层面保证局部有序<br>\t可以以用户id作为key 通过一致性hash算法得到队列编号<br>\t\t这样相同的key都会发送到同一个对列上<br>\t\t\t那么对于那个用户来说 必定是有序的<br>\t\t关键点就在于放入同一个队列 如果是不同队列 就很容易造成后来的消息在前 先发的消息在后的情况了","like_count":0},{"had_liked":false,"id":343632,"user_name":"钢牙大人","can_delete":false,"product_type":"c1","uid":1056680,"ip_address":"","ucode":"E0CEEEF4D4ADF3","user_header":"https://static001.geekbang.org/account/avatar/00/10/1f/a8/254595df.jpg","comment_is_top":false,"comment_ctime":1650962170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650962170","product_id":100032301,"comment_content":"赞！","like_count":0},{"had_liked":false,"id":334951,"user_name":"Geek2014","can_delete":false,"product_type":"c1","uid":2028957,"ip_address":"","ucode":"9EB356D8DF287E","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/9d/104bb8ea.jpg","comment_is_top":false,"comment_ctime":1645197382,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1645197382","product_id":100032301,"comment_content":"看代码也是用Java写的，运行Java servelet 的不一般都是tomcat，秒杀场景下，tomacat 可以允许同时那么多线程在等待么","like_count":0,"discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555678,"discussion_content":"第一节课说了，消息队列还可以用来做流量控制。比如说用来实现令牌桶，网关处理app请求时先获取令牌，令牌数量可以按网关处理能力设置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647020154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325339,"user_name":"友","can_delete":false,"product_type":"c1","uid":2536820,"ip_address":"","ucode":"972A4333A8B101","user_header":"https://static001.geekbang.org/account/avatar/00/26/b5/74/cd80b9f4.jpg","comment_is_top":false,"comment_ctime":1638927052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638927052","product_id":100032301,"comment_content":"冲 我已经是小达人了 (狗头)","like_count":0},{"had_liked":false,"id":322414,"user_name":"豆花羹","can_delete":false,"product_type":"c1","uid":1522220,"ip_address":"","ucode":"57D8F64988C305","user_header":"https://static001.geekbang.org/account/avatar/00/17/3a/2c/683ae4af.jpg","comment_is_top":false,"comment_ctime":1637377271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637377271","product_id":100032301,"comment_content":"文章中提到producer可以只往一个队列里面发送呢，这样不会造成负载不均衡吗？","like_count":0},{"had_liked":false,"id":322070,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1637155599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637155599","product_id":100032301,"comment_content":"我还是没理解队列模型和主题模型的区别：单纯两个模型貌似听懂了【一对一或者一对多的问题】，但是为什么说RabbitMq是队列模型呢？exchange不就相当于是个主题吗？<br><br>ps：我并不太了解RabbitMQ,RocketMq,kafka。<br>","like_count":0},{"had_liked":false,"id":282756,"user_name":"滴滴滴滴","can_delete":false,"product_type":"c1","uid":1308213,"ip_address":"","ucode":"964869D9E14250","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/35/2ba91a0a.jpg","comment_is_top":false,"comment_ctime":1615389314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615389314","product_id":100032301,"comment_content":"秒杀的场景限流就好了啊，mq在这里属实多余，可以换个方案来距离","like_count":0},{"had_liked":false,"id":282754,"user_name":"滴滴滴滴","can_delete":false,"product_type":"c1","uid":1308213,"ip_address":"","ucode":"964869D9E14250","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/35/2ba91a0a.jpg","comment_is_top":false,"comment_ctime":1615389224,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615389224","product_id":100032301,"comment_content":"秒杀那个场景限流就好了啊，mq在这里的作用也是限流，加个mq在这里不复杂吗？","like_count":0},{"had_liked":false,"id":269524,"user_name":"老大不小","can_delete":false,"product_type":"c1","uid":1295609,"ip_address":"","ucode":"35BCDD3CB13467","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","comment_is_top":false,"comment_ctime":1608692050,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608692050","product_id":100032301,"comment_content":"老师好，文中有几句话没整明白，还请老师指点！<br>“最后说一下消费位置，每个消费组内部维护自己的一组消费位置，每个队列对应一个消费位置。消费位置在服务端保存，并且，消费位置和消费者是没有关系的。每个消费位置一般就是一个整数，记录这个消费组中，这个队列消费到哪个位置了，这个位置之前的消息都成功消费了，之后的消息都没有消费或者正在消费。”<br>这段话的意思是这样理解的吗？队列的消费位置信息保存在broker中，是以消费组维度进行维护的，消费者每返回ack，broker都会更新offset值。<br>","like_count":0},{"had_liked":false,"id":265965,"user_name":"Javatar","can_delete":false,"product_type":"c1","uid":2032840,"ip_address":"","ucode":"E216645CDF632C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","comment_is_top":false,"comment_ctime":1607079777,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607079777","product_id":100032301,"comment_content":"老师我问的可能有点跑题了，但还是想问一下，<br><br>rabbitmq是不是可以多个consumer消费同一个queue？<br><br>代码中会配置：<br>&lt;rabbit:listener-container id=&quot;xxxContainer&quot; connection-factory=&quot;connectionFactory&quot; concurrency=&quot;4&quot;&gt; <br>会指定concurrency，<br>这个concurrency我看了rabbit的官方文档，表示的确是会起多个线程消费消息，那这样的话是rabbitmq或者spring做了并发的处理么？求李sir解答","like_count":0},{"had_liked":false,"id":265387,"user_name":"风","can_delete":false,"product_type":"c1","uid":1147929,"ip_address":"","ucode":"AFDBEFA49F269E","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/19/7ed2ffa6.jpg","comment_is_top":false,"comment_ctime":1606885508,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606885508","product_id":100032301,"comment_content":"老师,关于秒杀有个问题想问您，对于网关等待后端处理秒杀请求超时,但是后台成功处理秒杀请求的情况下,订单应该怎么处理？如果按照秒杀成功的逻辑来的话,那用户那边就会&quot;莫名&quot;出现秒杀成功形成的订单？这种情况也是允许的吗？","like_count":0},{"had_liked":false,"id":265079,"user_name":"程序员马称","can_delete":false,"product_type":"c1","uid":1313565,"ip_address":"","ucode":"97CA62BF9AA10E","user_header":"https://static001.geekbang.org/account/avatar/00/14/0b/1d/4e80cd22.jpg","comment_is_top":false,"comment_ctime":1606754148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606754148","product_id":100032301,"comment_content":"老师以及各位同学, 如果深入研究一门mq, 大家推荐rocket 还是 kafka","like_count":0},{"had_liked":false,"id":264971,"user_name":"半个菠萝蜜","can_delete":false,"product_type":"c1","uid":1087488,"ip_address":"","ucode":"F548BC61CA9BDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/98/00/beef9f34.jpg","comment_is_top":false,"comment_ctime":1606724798,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606724798","product_id":100032301,"comment_content":"老师说到每个消费组内部维护一组消费位置， 消费组包含多个消费者，也就是不同的节点。 <br>我的疑问是：<br>1. 消费位置是需要在多个消费者之间同步的吗？<br>2. 如果只是消费者C1记录自己对应的队列Q1位置，当C1挂掉，其他消费者怎么知道Q1位置的？","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375913,"discussion_content":"消费位置保存在了broker里面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621866667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257636,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1604046901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604046901","product_id":100032301,"comment_content":"topic 就像游戏里面的副本。而消费组就是组队进入副本打怪的玩家。队列就是副本里面的怪，要不没人一个怪，要不就是来个boss 一剑秒图。","like_count":0},{"had_liked":false,"id":250718,"user_name":"Spring4J","can_delete":false,"product_type":"c1","uid":1645430,"ip_address":"","ucode":"06F056085A2564","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","comment_is_top":false,"comment_ctime":1601201101,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601201101","product_id":100032301,"comment_content":"“这个解决方案还不是一个性能最优的方案，处理 APP 请求的线程需要同步等待秒杀结果。后面课程中我们会专门来讲，如何使用异步方式来提升程序的性能。”，这个地方该怎么异步呢，秒杀结果都还没产生，如何响应客户端？<br>","like_count":0},{"had_liked":false,"id":250126,"user_name":"Geek_fdbd6d","can_delete":false,"product_type":"c1","uid":1504246,"ip_address":"","ucode":"DF018AFAC30629","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIkkg9icSGleYF17wA2pOEuIWDjDdUSaluLES8D031O20nQ3bsIjRicnrolpEhXUsemWtEemOmQTG6A/132","comment_is_top":false,"comment_ctime":1600943055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600943055","product_id":100032301,"comment_content":"老师好，我对1个队列解决并行消费得问题不是很理解，我理解得rocketMq1个主题对应多个队列，然后将消费者分组，每个组就是一个消费模块得水平扩容，消费组消费效率互不影响，消费组水平扩容可以同时消费多个队列，提高消费得处理能力；但是如果1个队列解决并行问题，如何解决消费组如何全量得消费消息呢","like_count":0},{"had_liked":false,"id":250016,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1600906936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600906936","product_id":100032301,"comment_content":"消费位置与消费组应该是有关系的，如果只在队列记录一个消费位置，怎么能够确定所有消费组的消费进度，RocketMQ是有记录消费组的消费位置的","like_count":0},{"had_liked":false,"id":249387,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1600618651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600618651","product_id":100032301,"comment_content":"高屋建瓴，先宏观后微观，掌握事物的第一性原理，这是学习的通用脉络。","like_count":0},{"had_liked":false,"id":238133,"user_name":"坏坏的举哥","can_delete":false,"product_type":"c1","uid":1084636,"ip_address":"","ucode":"98D1BAA79DC0C0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQsyr2Ge5iaKwEUQibeWDAa9sU5w3xmbBTBa4u9mibkKTia2DfDVdRCKL69rYradbmxBzQsPsNrPBic8A/132","comment_is_top":false,"comment_ctime":1596077439,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596077439","product_id":100032301,"comment_content":"想问下，既然一个队列只能让同一个消费组的一个消费实例去拉取消息消费，那么队列并发时，怎么会让多个消费者去拉取多条消息的？如果这儿多个消费者是指的同一个消费组，那不是和上面的不是矛盾了？如果不是，不同消费组的消费实例去拉取多条消息时，那应该这几条消息都给这几个实例一份啊，而不是每个一条消息？忘有人解答下哈","like_count":0,"discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309158,"discussion_content":"老师的问题是如何实现单个队列的并行消费，是让我们自己去思考该怎么实现，可能有些mq是并没有提供这个功能的，真有这个需求，就要自己去改源代码。明白了没\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601200641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237665,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1595918313,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595918313","product_id":100032301,"comment_content":"记得之前工作中，遇到一个问题，本地开了个服务，测试环境部署了个服务，然后本地服务模拟发消息和接收消息的过程，弄了几遍，发现，队列中数据，每次都是，只能消费一半队列中的数据，其他一半的队列中的数据，怎么也消费不掉，排查半天原因，原来，那一半不能消费的队列，是因为测试环境的实例占用了，然后测试环境消费了一下，另一半队列的数据都消费完了<br>然后为了验证自己的想法，本地启动俩个服务，加测试环境一个服务，发现队列被平均分成了三份，在本地的一个服务发消息，消息会固定的放在这个服务分配的那几个队列上，相当于这三个服务是在一个消费组下的三个消费实例，而每个消费实例对应几个自己的队列，不会出现，俩个消费实例对应一个队列","like_count":0},{"had_liked":false,"id":234685,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1594773763,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594773763","product_id":100032301,"comment_content":"一致性哈希的例子很妙","like_count":0},{"had_liked":false,"id":210799,"user_name":"Fly55","can_delete":false,"product_type":"c1","uid":1251563,"ip_address":"","ucode":"FFA9D5C6EDD6F4","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/eb/fd0b4a1f.jpg","comment_is_top":false,"comment_ctime":1587826543,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1587826543","product_id":100032301,"comment_content":"使用ha+keepalived搭建的rabbitmq镜像集群，spring boot集成rabbitmq访问vip的时候，消息也发送成功，但回调函数ack为false，但切换为到单点访问就为true。有遇到的吗，求解","like_count":0},{"had_liked":false,"id":209932,"user_name":"77","can_delete":false,"product_type":"c1","uid":1946562,"ip_address":"","ucode":"C57A8443814F7A","user_header":"","comment_is_top":false,"comment_ctime":1587637320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587637320","product_id":100032301,"comment_content":"老师，上面讲的单个队列并行消费里面，再有消费者来拉消息的时候，优先把重试队列中的那条消息给消费者，这之后的offset是怎么设置的是+3呢还是+2呢","like_count":0},{"had_liked":false,"id":207862,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1587199072,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587199072","product_id":100032301,"comment_content":"本人是MQ的小白，今天根据RabbitMQ官网的指引，写了其中 Worker Queue 的Demo，这里分享一下，如有错误，希望老师指正一下。<br>RabbitMQ 的模型是队列模型，消费者在 channel 中会有 Prefetch 设置，即批量拉取处理。在MQ积压了大量数据时，同时有多个消费者，MQ会根据Prefetch的设置(默认250)，按段分配积压的消息。譬如：积压了消息1-1000，有两个消费者时，消费者A会负责消费1-250，消费者B会负责消费251-500.<br><br>RabbitMQ 会保证每个消息只会被成功消费一次，但在大数据量的情况下，会通过Prefetch进行并行消费，增加吞吐量。","like_count":0},{"had_liked":false,"id":203043,"user_name":"黄平","can_delete":false,"product_type":"c1","uid":1142708,"ip_address":"","ucode":"2207224A09735C","user_header":"https://static001.geekbang.org/account/avatar/00/11/6f/b4/4aefe4c0.jpg","comment_is_top":false,"comment_ctime":1586118291,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586118291","product_id":100032301,"comment_content":"一个队列只对应一个消费者，为什么并行消费那块一个队列可以对应多个消费者？","like_count":0,"discussions":[{"author":{"id":1931524,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/79/04/748ee8c9.jpg","nickname":"想出家的小和尚","note":"","ucode":"7C079ADC43577F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251215,"discussion_content":"应该是自研的解决方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588074119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199034,"user_name":"Chocolate","can_delete":false,"product_type":"c1","uid":1013822,"ip_address":"","ucode":"242CF0E3C10E97","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/3e/c39d86f1.jpg","comment_is_top":false,"comment_ctime":1585477117,"is_pvip":false,"replies":[{"id":"74808","content":"是的，你的理解是没问题的。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1585531582,"ip_address":"","comment_id":199034,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585477117","product_id":100032301,"comment_content":"老师，你好，文章中有提到消费位置在服务端保存，我看源码中，如果是集群消息，消费位置在 broker 中保存，如果是广播消息，消费位置在消费端处自己保存，请问下老师我理解的对吗？文章的服务端指的是 broker 吗。","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489782,"discussion_content":"是的，你的理解是没问题的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585531582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185826,"user_name":"seg-上海","can_delete":false,"product_type":"c1","uid":1760320,"ip_address":"","ucode":"46BA8DCB06ED5E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBllicLBj61g1ibmCeWzLYpQYEteTOtAAAypoIg6CD19ibXQBbM09VsME9Ta1G8ubwk0ibjiacItavibaeg/132","comment_is_top":false,"comment_ctime":1583685691,"is_pvip":false,"replies":[{"id":"71952","content":"会的，某些消费者消费慢确实会阻塞住一些队列。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1583821356,"ip_address":"","comment_id":185826,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583685691","product_id":100032301,"comment_content":"文中提到：“我们可以让消费者 C0 消费 Q0，Q1 和 Q2，C1 消费 Q3 和 Q4，如果 C0 宕机了，会触发重新分配，这时候 C1 同时消费全部 5 个队列“，有个两疑问就是，若C0并没有宕机，只是他消费在消费Q0队列时比较慢，会导致 Q1 Q2中的消息阻塞吗（因为之前根据某种策略，C1是与Q0 Q1 Q2对应的）？与此同时C1此时是空闲，C1会不会去消费Q1和Q2队列中的消息呢？若不消费岂不是浪费来C1这个实例","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486516,"discussion_content":"会的，某些消费者消费慢确实会阻塞住一些队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583821356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174939,"user_name":"灿烂明天","can_delete":false,"product_type":"c1","uid":1322455,"ip_address":"","ucode":"07DA56B0680D0C","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/d7/74fc8f38.jpg","comment_is_top":false,"comment_ctime":1580466082,"is_pvip":false,"replies":[{"id":"68333","content":"你是指队列中最多能保存多少条消息么？","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1580863887,"ip_address":"","comment_id":174939,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580466082","product_id":100032301,"comment_content":"老师你好，我想问下队列的容量设置多大比较好？是容量，不是队列数量","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482575,"discussion_content":"你是指队列中最多能保存多少条消息么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580863887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1322455,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/d7/74fc8f38.jpg","nickname":"灿烂明天","note":"","ucode":"07DA56B0680D0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161657,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580913716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170679,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1578663199,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1578663199","product_id":100032301,"comment_content":"JMQ支持事务消息么，目前开源版的rocketmq貌似对事务消息支持不完整","like_count":0},{"had_liked":false,"id":164504,"user_name":"刘志兵","can_delete":false,"product_type":"c1","uid":1441734,"ip_address":"","ucode":"A90C2FA49EDC23","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/c6/8b5cbe97.jpg","comment_is_top":false,"comment_ctime":1577013248,"is_pvip":false,"replies":[{"id":"62876","content":"你指的是主题中队列的数量么？一般来说设置成与消费者的实例数量一致的时候，有最佳消费性能。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1577149824,"ip_address":"","comment_id":164504,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577013248","product_id":100032301,"comment_content":"老师，队列大小设置多少合适，是根据一个消费组内的实例数来确定吗，上限有没有限制，比如我有1000个实例的话，能不能把队列设为1000，保证每个实例对应一个队列","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478792,"discussion_content":"你指的是主题中队列的数量么？一般来说设置成与消费者的实例数量一致的时候，有最佳消费性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577149824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137798,"user_name":"榴芒科技","can_delete":false,"product_type":"c1","uid":1312485,"ip_address":"","ucode":"EC297012B1B942","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DwZUsQhia0wIWNEfeGZ2srQWzVC04JjLFDwgmicpnNF3mUPdRJD6U6vviceJqMxGYUGtxaiaZWltyNtQ5fZhia7YN3w/132","comment_is_top":false,"comment_ctime":1569855987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569855987","product_id":100032301,"comment_content":"rabbitmq的work模式 不就是通过扩容消费者的方式来解决消息积压的么？","like_count":0},{"had_liked":false,"id":135971,"user_name":"王莹","can_delete":false,"product_type":"c1","uid":1203920,"ip_address":"","ucode":"0A6F91068A13E8","user_header":"https://static001.geekbang.org/account/avatar/00/12/5e/d0/e676ac19.jpg","comment_is_top":false,"comment_ctime":1569318409,"is_pvip":false,"replies":[{"id":"52147","content":"这种方法是可行的，但其实PHP是可以调用C&#47;C++类库的，也就是说可以用C或者C++的客户端。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1569375757,"ip_address":"","comment_id":135971,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569318409","product_id":100032301,"comment_content":"PHP对接Rocket问题：<br>背景：单位项目N多个，主要是Java，个别是PHP，Python，有一些历史项目需要重构改造为前台业务对接中台业务，需要消息队列整合起来，其中PHP项目没有合适的PHP客户端，考虑到对性能要求不要，只需要系统解耦，用Java实现Rocket代理如何？<br>PlantUML设计如下：<br>@startuml<br>title: RocketMQ PHP代理<br>participant PHP<br>participant Proxy<br>participant RocketMQ<br><br>== 生产消息 ==<br>PHP -&gt; Proxy: sendMsg&#47;Rest&#47;Req<br>activate PHP<br>Proxy -&gt; RocketMQ: sendMsg(Sync模式)<br>RocketMQ --&gt; Proxy: sendMsg(Sync模式)&#47;ACK<br>Proxy --&gt; PHP: sendMsg&#47;Rest&#47;Res<br>PHP -&gt; PHP: 更新标识位为 1:已发送<br>activate PHP<br>deactivate PHP<br>deactivate PHP<br><br>== 消费消息 ==<br>Proxy -&gt; RocketMQ: long pull<br>RocketMQ -&gt; Proxy: push<br>activate Proxy<br>Proxy -&gt; PHP: pushMsg(Msg)&#47;Rest&#47;Req<br>activate PHP<br>PHP -&gt; PHP: 消费消息（保证幂等性）<br>activate PHP<br>deactivate PHP<br>PHP --&gt; Proxy: pushMsg(Msg)&#47;Rest&#47;Res<br>deactivate PHP<br>Proxy --&gt; RocketMQ: ACK<br>deactivate Proxy<br><br>@enduml<br>","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468407,"discussion_content":"这种方法是可行的，但其实PHP是可以调用C/C++类库的，也就是说可以用C或者C++的客户端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569375757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126814,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1566483198,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566483198","product_id":100032301,"comment_content":"每个消费组就是一份订阅，它要消费主题 MyTopic 下，所有队列的全部消息。注意，队列里的消息并不是消费掉就没有了，这里的“消费”，只是去队列里面读了消息，并没有删除，消费完这条消息还是在队列里面。<br><br>理解：所有消息是保存在主题下面的队列里","like_count":0},{"had_liked":false,"id":126186,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1566346932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566346932","product_id":100032301,"comment_content":"老师这节答疑真棒，越来越觉得老师像吴彦祖啦！<br>值得反复品味!<br>一图胜千言，如果之后老师的图上来了，那在我心目中老师就是吴彦祖","like_count":0},{"had_liked":false,"id":123081,"user_name":"monalisali","can_delete":false,"product_type":"c1","uid":1299521,"ip_address":"","ucode":"1FDEC87C133E28","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJbh5FQajwKhNlMrkoSklPpOXBtEYXCLvuWibhfWIS9QxHWDqzhEHJzEdmtUiaiaqFjfpsr2LwgNGpbQ/132","comment_is_top":false,"comment_ctime":1565602300,"is_pvip":false,"replies":[{"id":"45257","content":"具体是哪方面呢？","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565655580,"ip_address":"","comment_id":123081,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565602300","product_id":100032301,"comment_content":"重来没接触过消息队列，老师讲的是好，不过看了一遍文章还是有点云里雾里。老师能推荐一点针对小白的资料，看完后再看这个课程是不是会更有效果？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462528,"discussion_content":"具体是哪方面呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565655580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122910,"user_name":"Smile","can_delete":false,"product_type":"c1","uid":1125189,"ip_address":"","ucode":"0617032294DC43","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/45/e8f64725.jpg","comment_is_top":false,"comment_ctime":1565572748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565572748","product_id":100032301,"comment_content":"在同一个消费组里面，每个队列只能被一个消费者实例占用。可以理解为，可以是队列里的前五条消息由消费者A占用，另外五条由消费者B占用，","like_count":0},{"had_liked":false,"id":122436,"user_name":"马成","can_delete":false,"product_type":"c1","uid":1486895,"ip_address":"","ucode":"664F2BAA2E0F0B","user_header":"https://static001.geekbang.org/account/avatar/00/16/b0/2f/e2096905.jpg","comment_is_top":false,"comment_ctime":1565366960,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1565366960","product_id":100032301,"comment_content":"这个补充很棒啊，前面的疑惑阔然开朗","like_count":0},{"had_liked":false,"id":122409,"user_name":"z.l","can_delete":false,"product_type":"c1","uid":1181055,"ip_address":"","ucode":"805CC5784D3F76","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/7f/d35ab9a1.jpg","comment_is_top":false,"comment_ctime":1565359402,"is_pvip":false,"replies":[{"id":"44962","content":"不需要，超时之后如果查询不到结果，直接认为秒杀失败即可。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565420711,"ip_address":"","comment_id":122409,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565359402","product_id":100032301,"comment_content":"      &#47;&#47; 等待后端处理<br>      synchronized(mutex) {<br>        mutex.wait(timeout);<br>      }<br>  <br>请问下这里wait()不用包含在while(true)循环中吗 ？<br> ","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462238,"discussion_content":"不需要，超时之后如果查询不到结果，直接认为秒杀失败即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565420711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122378,"user_name":"苏超","can_delete":false,"product_type":"c1","uid":1025718,"ip_address":"","ucode":"46D659C89BA8C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/b6/27412d76.jpg","comment_is_top":false,"comment_ctime":1565352619,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1565352619","product_id":100032301,"comment_content":"学习了并发课程，发现第一个例子就是异步转同步的一个例子😄","like_count":0},{"had_liked":false,"id":122156,"user_name":"ykkk88","can_delete":false,"product_type":"c1","uid":1068585,"ip_address":"","ucode":"A1BCFC2F0D1022","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/29/1be3dd40.jpg","comment_is_top":false,"comment_ctime":1565312240,"is_pvip":false,"replies":[{"id":"44897","content":"首先，就pulsar的成熟度和稳定性来说，肯定是可以用在生产环境中的。<br><br>但是否适合你的业务场景，需要根据实际情况来考虑。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565326864,"ip_address":"","comment_id":122156,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1565312240","product_id":100032301,"comment_content":"老师觉得pulsar怎么样呢 生产环境可以尝试么","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462123,"discussion_content":"首先，就pulsar的成熟度和稳定性来说，肯定是可以用在生产环境中的。\n\n但是否适合你的业务场景，需要根据实际情况来考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565326864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122053,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1565275887,"is_pvip":true,"replies":[{"id":"44891","content":"是冲突的，一般通过配置选择是否开启并行消费。","user_name":"作者回复","user_name_real":"李玥","uid":"1501046","ctime":1565326094,"ip_address":"","comment_id":122053,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565275887","product_id":100032301,"comment_content":"老师前面说的保证每个队列只分配一个消费者，和实现单个队列的并行消费这里会不会冲突，还是这里可以另外配置改变这种分配策略？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462076,"discussion_content":"是冲突的，一般通过配置选择是否开启并行消费。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565326094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122017,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1565269433,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565269433","product_id":100032301,"comment_content":"打卡中","like_count":0},{"had_liked":false,"id":121997,"user_name":"oscarwin","can_delete":false,"product_type":"c1","uid":1131956,"ip_address":"","ucode":"492430BA342593","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b4/ec66d499.jpg","comment_is_top":false,"comment_ctime":1565266739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565266739","product_id":100032301,"comment_content":"学习消息队列要从一定的高度来学，这句话不能同意的更多了。希望看完老师的课程，自己能尝试实现一个消息队列。","like_count":0},{"had_liked":false,"id":121867,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1565236691,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565236691","product_id":100032301,"comment_content":"跟老师一起打怪升级，成为真正的高手。","like_count":0},{"had_liked":false,"id":121837,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1565231418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565231418","product_id":100032301,"comment_content":"JMQ把消息空洞放在特殊位置的操作像极了AWS SQS的sqs dead letter queue，不知道是不是用的同一种设计思路？","like_count":0},{"had_liked":false,"id":121831,"user_name":"陈泽坛","can_delete":false,"product_type":"c1","uid":1394861,"ip_address":"","ucode":"C81B402868E9E2","user_header":"https://static001.geekbang.org/account/avatar/00/15/48/ad/8be724da.jpg","comment_is_top":false,"comment_ctime":1565230395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565230395","product_id":100032301,"comment_content":"^_^    打卡          <br>老师讲得很好很清晰，感谢","like_count":0},{"had_liked":false,"id":121814,"user_name":"木小柒","can_delete":false,"product_type":"c1","uid":1000802,"ip_address":"","ucode":"947439CDD0B5B1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/45/62/3c6041e7.jpg","comment_is_top":false,"comment_ctime":1565227538,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565227538","product_id":100032301,"comment_content":"你已经是一个使用消息队列的小达人了。","like_count":0},{"had_liked":false,"id":121790,"user_name":"侯鹏₁₈₆₁₄₀₉₂₄₁₉","can_delete":false,"product_type":"c1","uid":1212378,"ip_address":"","ucode":"BB85A8993B4DBB","user_header":"https://static001.geekbang.org/account/avatar/00/12/7f/da/73778db7.jpg","comment_is_top":false,"comment_ctime":1565224998,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565224998","product_id":100032301,"comment_content":"秒杀的案例，老师如果画个流程图就太好了","like_count":0},{"had_liked":false,"id":121782,"user_name":"nimil","can_delete":false,"product_type":"c1","uid":1197925,"ip_address":"","ucode":"19933068972746","user_header":"https://static001.geekbang.org/account/avatar/00/12/47/65/cce8eb34.jpg","comment_is_top":false,"comment_ctime":1565223936,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565223936","product_id":100032301,"comment_content":"小达人，zzz","like_count":0},{"had_liked":false,"id":121771,"user_name":"白小白","can_delete":false,"product_type":"c1","uid":1400416,"ip_address":"","ucode":"143F1C8294818A","user_header":"https://static001.geekbang.org/account/avatar/00/15/5e/60/1c13626b.jpg","comment_is_top":false,"comment_ctime":1565222213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565222213","product_id":100032301,"comment_content":"讲真，跟着学到现在，收获还是挺多的。感谢老师😄","like_count":0},{"had_liked":false,"id":121762,"user_name":"后端学长","can_delete":false,"product_type":"c1","uid":1178011,"ip_address":"","ucode":"7E82F2B5930CD5","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/9b/dc074a7e.jpg","comment_is_top":false,"comment_ctime":1565221236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565221236","product_id":100032301,"comment_content":"关注细节往往缺少宏观的认知，我们要先有一个宏观的认知，再去深入了解具体的实现细节，比如说老师第一讲中讲了消息队列的应用场景 异部，解耦，削峰。这就是消息队列应用场景的宏观思想，对消息队列应用场景有了宏观的认知，拿本文的秒杀其实就是削峰的一种应用场景。","like_count":0},{"had_liked":false,"id":121756,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1565220879,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565220879","product_id":100032301,"comment_content":"继续打卡09","like_count":0}]}