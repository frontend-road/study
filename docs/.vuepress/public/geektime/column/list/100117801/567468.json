{"id":567468,"title":"22｜RISC-V指令精讲（七）：访存指令实现与调试","content":"<p>你好，我是LMOS。</p><p>上节课我们说了RISC-V是加载储存体系结构的典型，只有加载指令和储存指令才有资格访问内存。</p><p>计算机运算完成的结果，一开始会放在寄存器中，但最终归宿还是内存，此时就需要存储指令发挥作用了。这节课我们就来看看RISC-V提供的存储指令，一共有三条，分别是储存字节指令、储存双字节指令和储存字指令。</p><p>课程的代码你可以从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson21~22\">这里</a>下载。话不多说，咱们进入正题。</p><h2>储存字节指令：sb指令</h2><p>我们先从储存字节指令，即sb指令学起。</p><p>这个指令存储的字节单位是一个字节，也就是8位数据。说得再具体一些，这个指令会把一个通用寄存器里的低[7:0]位，储存到特定地址的内存单元里。而这个特定地址，要由另一个通用寄存器和一个立即数之和来决定。</p><p>储存字节指令的汇编代码，书写形式如下所示：</p><pre><code class=\"language-plain\">sb rs2,imm(rs1)\n#sb 储存字节指令\n#rs2 源寄存器2\n#rs1 源寄存器1\n#imm 立即数（-2048~2047）\n</code></pre><p><strong>上述代码中rs1和rs2可以是任何通用寄存器。立即数imm为12位二进制数据，其范围是-2048~2047。</strong>因为rs1、rs2以及立即数imm的规定，对后面的sh指令和sw指令同样适用，后面我就不重复说了。</p><p>sb指令完成的操作用伪代码描述是这样的：</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">（[rs1+imm]）= rs2[7:0]\n</code></pre><p>我来为你解释一下伪代码执行的操作。首先取得rs2寄存器第0位到第7位这8位数据，即一个字节。然后，把这个字节数据储存到rs1+imm为地址的内存单元中。</p><p>接着是代码验证环节，为了方便调试，我们在工程目录下新建一个store.S文件，并在其中用汇编写上sb_ins函数。代码如下所示：</p><pre><code class=\"language-plain\">.text\n.globl sb_ins\n#a0内存地址\n#a1储存的值\nsb_ins:\n    sb a1, 0(a0)       #储存a1低8位到a0+0地址处\n    jr ra              #返回\n</code></pre><p>sb_ins函数我已经帮你写好了，只有两条指令，第一条指令把a1寄存器的低8位数据，储存到a0+0地址处的内存单元中，第二条指令就返回了。</p><p>现在，我们一起用VSCode打开工程目录，把断点打在“sb a1, 0(a0) ”指令处，按下“F5”键调试一下，效果如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/16/ee3b74d78ce8bbf597f9e9d1998dd216.jpg?wh=1920x1023\" alt=\"图片\"></p><p>图片里对应的是刚刚执行完sb a1，0(a0)指令之后，执行jr ra指令之前的状态。这时候a0寄存器中的值是0x20a80，这是byte变量的地址，a1是0x80，正是十进制数据128。</p><p>我们继续单步调试，返回到main函数中执行printf函数，打印一下byte变量的值，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/7c/8ab29e03646a8b7824e515aa6980b07c.jpg?wh=1920x1023\" alt=\"图片\"></p><p>从图中可以看到，byte变量的初始值为-5。调用sb_ins函数时，我们把byte的地址强制为无符号整数传给sb_ins函数第一个参数，把整数128传给sb_ins函数第二个参数。</p><p>C语言调用规范告诉我们，sb_ins函数会通过a0、a1寄存器传递第一个、第二个参数，之后printf函数输出byte变量的值为128，这证明了sb指令是正常工作的。</p><h2>储存双字节指令：sh指令</h2><p>接下来要说的是储存半字指令，也是储存双字节指令。它可以把一个通用寄存器中的低[15:0]位，一共16位的数据（即两个字节），储存到特定地址的内存单元中，这个地址由另一个通用寄存器与一个立即数之和决定。</p><p>储存半字指令的汇编代码，书写形式是这样的：</p><pre><code class=\"language-plain\">sh rs2,imm(rs1)\n#sh 储存半字指令\n#rs2 源寄存器2\n#rs1 源寄存器1\n#imm 立即数（-2048~2047）\n</code></pre><p>sh指令完成的操作用伪代码描述如下所示：</p><pre><code class=\"language-plain\">（[rs1+imm]）= rs2[15:0]\n</code></pre><p>我来为你解释一下，上面的伪代码执行了怎样的操作。首先取得rs2的第0位到第15位的数据。然后把这两个字节（16位数据）的数据，储存到rs1+imm这个地址的内存单元中。</p><p>好，咱们写个代码来验证一下。在store.S文件中，用汇编写上sh_ins函数。代码如下所示：</p><pre><code class=\"language-plain\">.globl sh_ins\n#a0内存地址\n#a1储存的值\nsh_ins:\n    sh a1, 0(a0)       #储存a1低16位到a0+0地址处\n    jr ra              #返回\n</code></pre><p>与sb_ins函数一样，sh_ins函数只有两条指令，但第一条指令是把a1寄存器的低16位数据，储存到a0+0地址处的内存单元中，第二条指令同样是返回指令。</p><p>现在我们一起用VSCode打开工程目录，在“sh a1, 0(a0) ”指令处打上断点，按“F5”键调试的截图如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/3e/ca2946638e7a271e917d95037bb3be3e.jpg?wh=1920x1023\" alt=\"图片\"></p><p>图片对应的是刚刚执行完sh a1,0(a0)指令之后，执行jr ra指令之前的状态，a0寄存器中的值是half变量的地址，a1寄存器中的值是0xa5a5。</p><p>我们继续进行单步调试，返回到main函数中执行printf函数，打印一下half变量的值。</p><p><img src=\"https://static001.geekbang.org/resource/image/69/d3/691291f67fa032aebe3eb45a84e043d3.jpg?wh=1920x1023\" alt=\"图片\"></p><p>如上图所示，half变量的初始值为-1。随后调用sh_ins函数，我们把half的地址强制为无符号整数传给sh_ins函数第一个参数，再把整数0xa5a5传给sh_ins函数第二个参数，之后printf函数输出half变量的值为0xa5a5。这证明了sh指令工作正常。</p><h2>储存字指令：sw指令</h2><p>最后，我们来学习一下储存字指令，就是储存32位四字节指令，也是最常用的储存指令，它是把一个32位的通用寄存器，储存到特定地址的内存单元中，这个地址由另一个通用寄存器与一个立即数之和决定。</p><p>储存字指令的汇编代码书写形式如下所示：</p><pre><code class=\"language-plain\">sw rs2,imm(rs1)\n#sw 储存字指令\n#rs2 源寄存器2\n#rs1 源寄存器1\n#imm 立即数（-2048~2047）\n</code></pre><p>上述代码中rs1和rs2可以是任何通用寄存器。立即数imm为12位二进制数据，其范围是-2048~2047。</p><p>然后我们看看sw指令完成的操作，对应的伪代码描述如下：</p><pre><code class=\"language-plain\">（[rs1+imm]）= rs2\n</code></pre><p>这段伪代码执行的操作就是把rs2的32位数据，即四个字节数据，储存到rs1+imm为地址的内存单元中。</p><p>下面我们一起写代码验证一下，在store.S文件中，用汇编写上sw_ins函数。代码如下：</p><pre><code class=\"language-plain\">.globl sw_ins\n#a0内存地址\n#a1储存的值\nsw_ins:\n    sw a1, 0(a0)       #储存a1到a0+0地址处\n    jr ra              #返回\n</code></pre><p>sw_ins函数只有两条指令，第一条指令是把a1寄存器储存到a0+0地址处的内存单元中，第二条指令同样是返回指令。</p><p>毕竟眼见为实，咱们调试观察一下。用VSCode打开工程目录，在“sw a1, 0(a0) ”指令处打上断点，按下“F5”键调试，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/01/b2d982461bbbe87685e54a2cec3b8e01.jpg?wh=1920x1023\" alt=\"图片\"></p><p>上图是刚刚执行完sw a1,0(a0)指令之后，执行jr ra指令之前的状态。a0寄存器中的值是word变量的地址，a1寄存器中的值是0，执行完这个sw_ins函数后，word变量的值应该变为0了。</p><p>我们继续单步调试，执行返回到main函数中执行printf函数，打印一下word变量的值，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/9c/7f261940269dd4edce593c91d3211f9c.jpg?wh=1920x1023\" alt=\"图片\"></p><p>可以看到图中word变量的初始值为0xfffffffff，随后调用sw_ins函数，我们把word变量的地址强制为无符号整数传给sw_ins函数第一个参数，把整数0传给sw_ins函数第二个参数，之后printf函数输出word变量的值确实为0。这证明了sw指令工作正常。</p><p>我们已经对sb、sh、sw指令进行了调试，了解了它们的功能，现在我们继续一起看看sb_ins、sh_ins、sw_ins函数的二进制数据。</p><p>打开终端，切换到该工程目录下，输入命令：riscv64-unknown-elf-objdump -d ./main.elf &gt; ./main.ins，就会得到main.elf的反汇编数据文件main.ins，我们打开这个文件，就会看到上述这些函数的二进制数据，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/45/bc/45f7c8f9cf9558fb6143318bd89c0abc.jpg?wh=1920x1023\" alt=\"图片\"></p><p>可以看到，在图片里的反汇编代码中不但有伪指令，还有两个字节的压缩指令。编译器为了节约内存，所以会把指令压缩。比如说ret的机器码是0x8082，sw a1,0(a0)机器码是0xc10c，它们只占用16位编码，即二字节。</p><p>截图里五条加载指令的机器码与指令的对应关系，你可以参考后面这张表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/46/68/4641362093d8794fc2f400d66ce3ec68.jpg?wh=1920x717\" alt=\"图片\"></p><p>我画了示意图，帮你拆分一下sb、sh、sw指令各位段的数据，这样更容易看清楚它们是如何编码的。如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/14/82/14a4aa40d4bc9691394d02460bec0f82.jpg?wh=1920x1467\" alt=\"图片\"></p><p>对照上图可以看到，sb、sh、sw指令的功能码都不一样，借此就能区分它们。而这些储存指令的操作码都相同，立即数也相同（都是0），这和我们编写的代码有关。</p><p>我还想提示你注意一下sw指令，图片里的情况跟反汇编出来的数据可能不一致，原因是编译器使用了压缩指令。图片里我还原的是sw a1,0(a0)正常的编码。</p><p>你可以手动在sw_ins函数中，插入0x00b52023这个数据进行验证。怎么插入这个数据使之变成一条指令呢？参考<a href=\"https://time.geekbang.org/column/article/565772\">上节课</a>还原lw指令的讲解，我相信你这次自己也能搞定它。</p><p>关于RISC-V的三条储存指令已经介绍完了，它们可以将字节、双字节、四字节储存到内存中去。实现了保存运算指令运算结果的功能，给高级语言实现各种类型的变量，提供了基础。</p><h2>重点回顾</h2><p>今天我们一口气学完了三条储存指令。有了三条储存指令，加上我们上节课学过的五条加载指令，就构成了RISC-V的访存指令。</p><p>RISC-V提供的储存字节指令、储存半字指令和储存字指令。储存指令可以把寄存器的运算结果，或者其他数据储存到特定的内存空间中。储存单位可以是一个字节、两个字节，或者四个字节。有了这些指令，不同大小、位宽的数据处理起来都很方便。</p><p>运算指令的运算结果，要通过储存指令保存到内存中，这也给高级语言实现各种类型的变量，打下了基础。</p><p>我照例用导图梳理了这节课的要点，你可以做个参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/d0/3e11da000389d18458e20039ae4c46d0.jpg?wh=2968x2113\" alt=\"\"></p><h2>思考题</h2><p>为什么三条储存指令，不需要处理数据符号问题呢？</p><p>期待你在留言区跟我互动，也可以记录一下自己的收获。如果觉得课程还不错，也别忘了分享给更多朋友。</p>","neighbors":{"left":{"article_title":"21｜RISC-V指令精讲（六）：加载指令实现与调试","id":565772},"right":{"article_title":"23｜内存地址空间：程序中地址的三种产生方式","id":568387}},"comments":[{"had_liked":false,"id":357251,"user_name":"苏流郁宓","can_delete":false,"product_type":"c1","uid":2729645,"ip_address":"湖北","ucode":"AD07BD9CE03047","user_header":"https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg","comment_is_top":false,"comment_ctime":1663119983,"is_pvip":false,"replies":[{"id":"130135","content":"改了 重复了 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1663395980,"ip_address":"湖北","comment_id":357251,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5958087279","product_id":100117801,"comment_content":"好像上一节问过，储存字节指令，双字节指令，字指令。数据符号可以通过指令翻译来实现，没必要在储存环节特意把有符号和无符号数据分开储存的啊","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587935,"discussion_content":"改了 重复了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663395980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1673990,"avatar":"https://static001.geekbang.org/account/avatar/00/19/8b/06/fb3be14a.jpg","nickname":"TableBear","note":"","ucode":"A2C0562EEA2725","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587520,"discussion_content":"终于等来了课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663128141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357512,"user_name":"LockedX","can_delete":false,"product_type":"c1","uid":1683139,"ip_address":"湖北","ucode":"19B82B910FC67F","user_header":"https://static001.geekbang.org/account/avatar/00/19/ae/c3/d930693b.jpg","comment_is_top":false,"comment_ctime":1663322659,"is_pvip":false,"replies":[{"id":"130124","content":"嗯 嗯  是的 ","user_name":"作者回复","user_name_real":"编辑","uid":"1345199","ctime":1663395512,"ip_address":"湖北","comment_id":357512,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1663322659","product_id":100117801,"comment_content":"既然加载指令已经解决了符号数的问题，存储就不用管这个问题，就存储二进制数据就可以啦","like_count":0,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587923,"discussion_content":"嗯 嗯  是的 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663395512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}