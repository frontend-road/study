{"id":485632,"title":"13 | 什么是“协程思维模型”？","content":"<p>你好，我是朱涛。</p><p>学完基础篇以后，相信现在你对Kotlin的基础语法和特性都有了全面的认识。那么从今天开始，我们就要进入一个新的模块，一起来学习Kotlin当中<strong>最重要、最难学</strong>，也是最受期待的特性——协程。</p><h2>为什么协程如此重要？</h2><p><strong>协程是Kotlin对比Java的最大优势</strong>，这也是我说协程是Kotlin中最重要特性的主要原因。虽说Java也在计划着实现自己的协程：<a href=\"https://openjdk.java.net/projects/loom/\">Loom</a>，不过这个毕竟还处于相当初级的阶段。而Kotlin的协程，可以帮我们极大地<strong>简化异步、并发编程、优化软件架构</strong>。通过协程，我们不仅可以提高开发效率，还能提高代码的可读性，由此也就可以降低代码出错的概率。</p><p>不过，遗憾的是，Kotlin协程在业界的普及率并不高。因为，你如果对协程没有足够的认识，贸然在生产环境里使用协程，一定会遇到各种各样的问题，并要为之付出昂贵的代价（典型的反面例子就是滥用GlobalScope，导致大量的计算资源浪费以及出现生命周期错乱的问题）。</p><p>Kotlin的协程就是这样，表面上看，它的语法很简单，但行为模式却让人难以捉摸。举个简单的例子，同样是5行代码，普通的程序，这5行代码的运行顺序一般会是1、2、3、4、5；但对于协程来说，代码执行顺序可能会是1、4、5、3、2这样错乱的。如果我们不能在脑子里建立协程的思维模型，那我们将很难理解协程的行为模式。</p><!-- [[[read_end]]] --><p>所以说，协程也是一个典型的“<strong>易学难精</strong>”的框架。</p><p>如果你之前尝试过自学Kotlin协程，你一定会跟我有相似的体会：要记住协程的几个API很容易，困难的是形成一套完整的协程知识体系。不过，我想告诉你的是：形成知识体系也不算什么，更难的是建立一个具体的协程思维模型，来辅助自己理解协程背后的运行机制；甚至，建立协程思维模型也没什么了不起，更难的是理解协程背后的设计理念。</p><p>换句话说，如果我们能站在Kotlin协程设计者的角度，去评判、欣赏它背后的设计理念，并且能体会到协程设计的精妙之处，那才算是达到了最高的境界。</p><p>那么，学习Kotlin协程，到底意味着什么呢？</p><p>其实，学习协程，相当于一次<strong>编程思维的升级</strong>。协程思维，它与我们常见的线程思维迥然不同，当我们能够用协程的思维来分析问题以后，<strong>线程当中某些棘手的问题在协程面前都会变成小菜一碟</strong>。因此，我们相当于多了一种解决问题的手段。</p><p>另外，学习Kotlin协程，也相当于为我们打开了一扇新世界的大门，当我们对Kotlin协程有了透彻的认识以后，再去看C#、Python、Dart、JS、Golang、Rust、C++20、Java Loom当中的“类协程”概念，就会觉得无比亲切。这时候我们就会发现：<strong>原来协程的世界是如此广阔</strong>。</p><p>到这里，相信你已经认识到了Kotlin协程的重要性，也知道了学习协程的好处了。</p><p>不过，在正式开始学习Kotlin协程之前，我想先给你打一剂“预防针”：这个部分的学习难度会比前面基础篇更大，虽然我还是会尽量用简单直白的方式来向你介绍协程，但由于它本身是一种颠覆性的技术，因此，刚开始肯定是会有些难以接受的。在这里，我也建议你在遇到问题的时候多思考，并去反复琢磨和理解课程当中的知识点与示例代码。</p><p>好，接下来，我们先来了解一下协程的发展史，这会有助于我们理解协程到底是个什么东西。</p><h2>什么是协程？</h2><p>Kotlin的协程，是2017年初在1.1版本加入进来的，那时协程还只是实验性的（Experimental）；等到2018年底，Kotlin更新到1.3版本的时候，协程才成为Kotlin的正式特性；接着又过了一年，到2019年Kotlin协程才推出Flow相关的API。我们常说Kotlin是一门年轻的语言，那么Kotlin协程这个特性，就更加显得年轻了。毕竟从它正式推出到现在，也才三年多。</p><p>虽然Kotlin协程很年轻，但“协程”这个概念本身并不年轻。早在1967年的 <a href=\"https://zh.wikipedia.org/wiki/Simula\">Simula语言</a>当中，就已经出现了协程。不过，在之后的几十年里，协程并没有被推广开，后续涌现出的C、C++、Java之类的语言，更多的是使用线程来进行异步和并发。直到2012年左右，C#重新拾起了协程这个特性，实现了async、await、yield。之后，JavaScript、Python、Kotlin等语言才继续跟进实现了对应的协程。</p><p><img src=\"https://static001.geekbang.org/resource/image/55/4e/5570b21ba1cd63103ae5bfaf579a434e.jpg?wh=2000x900\" alt=\"\"></p><p>很多人在刚开始接触协程的时候，都觉得协程很难学，因为从学校一路学习C、Java过来以后，我们只知道线程是什么，对协程根本没有任何概念。</p><p>其实，如果要用简单的语言来描述协程的话，我们可以将其称为：“互相<strong>协</strong>作的<strong>程</strong>序”。</p><p><img src=\"https://static001.geekbang.org/resource/image/12/6a/121f70df4206972e88de427ef5157f6a.jpg?wh=2000x448\" alt=\"\"></p><p>为了帮你弄清楚普通的程序（Routine）与协程（Coroutine）之间的差异，我们来看一个具体的例子。</p><pre><code class=\"language-plain\">fun main() {\n    val list = getList()\n    printList(list)\n}\n\nfun getList(): List&lt;Int&gt; {\n    val list = mutableListOf&lt;Int&gt;()\n    println(\"Add 1\")\n    list.add(1)\n    println(\"Add 2\")\n    list.add(2)\n    println(\"Add 3\")\n    list.add(3)\n    println(\"Add 4\")\n    list.add(4)\n\n    return list\n}\n\nfun printList(list: List&lt;Int&gt;) {\n    val i = list[0]\n    println(\"Get$i\")\n    val j = list[1]\n    println(\"Get$j\")\n    val k = list[2]\n    println(\"Get$k\")\n    val m = list[3]\n    println(\"Get$m\")\n}\n\n/* 运行结果：\nAdd 1\nAdd 2\nAdd 3\nAdd 4\nGet1\nGet2\nGet3\nGet4\n*/\n</code></pre><p>以上代码非常简单，程序会先运行getList()，然后再运行printList()。从运行的结果我们可以看出来，程序是按照顺序执行的，这没什么特别的。这就是一个典型的<strong>普通程序</strong>的例子。</p><p>下面让我们来看一个<strong>协程</strong>的例子。</p><pre><code class=\"language-plain\">// 看不懂代码没关系，目前咱们只需要关心代码的执行结果\nfun main() = runBlocking {\n    val sequence = getSequence()\n    printSequence(sequence)\n}\n\nfun getSequence() = sequence {\n    println(\"Add 1\")\n    yield(1)\n    println(\"Add 2\")\n    yield(2)\n    println(\"Add 3\")\n    yield(3)\n    println(\"Add 4\")\n    yield(4)\n}\n\nfun printSequence(sequence: Sequence&lt;Int&gt;) {\n    val iterator = sequence.iterator()\n    val i = iterator.next()\n    println(\"Get$i\")\n    val j = iterator.next()\n    println(\"Get$j\")\n    val k = iterator.next()\n    println(\"Get$k\")\n    val m = iterator.next()\n    println(\"Get$m\")\n}\n\n/*\n输出结果：\nAdd 1\nGet1\nAdd 2\nGet2\nAdd 3\nGet3\nAdd 4\nGet4\n*/\n</code></pre><p>这段代码做的事情和前面的代码其实差不多，只是我们是借助了Kotlin当中的Sequence来实现的。这次，我们从程序的运行结果会发现，getSequence()与printSequence()这两个函数，它们是交替执行的。为了方便你理解，我用一张图来描述它们之间的调用顺序。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/2c/a3caffed1ced7663c0595c9ce2800a2c.png?wh=1287x418\" alt=\"图片\"></p><p>这段程序，给人的感觉就像是两位彬彬有礼的绅士，每个人执行一会代码以后，就会<strong>让出执行权</strong>给对方，让对方执行一会。这样的运行模式，就好像两个人在<strong>协作</strong>一样。</p><p>而对应的，前面的getList()和printList()的执行流程则完全不一样，getList()执行完以后，才会轮到printList()来执行。</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/7d/a1052f9ce56bb228e82da4cc4218137d.png?wh=1271x732\" alt=\"图片\"></p><p>这两种迥然不同的代码运行方式，其实就是协程与普通程序之间最大的差异。</p><ul>\n<li>普通程序在被调用以后，只会在末尾的地方返回，并且只会返回一次，比如前面的getList()函数；而协程则不受此限制，协程的代码可以在任意yield的地方挂起（Suspend）让出执行权，然后等到合适的时机再恢复（Resume）。在这个情况下，yield是代表了“让步”的意思。</li>\n<li>普通程序需要一次性收集完所有的值，然后统一返回；而协程则可以每次只返回（yield）一个值，比如我们前面写的getSequence()方法。在这个情况下，yield既有“让步”的意思，也有“<strong>产出</strong>”的意思。它不仅能让出执行权，还同时产生一个值，比如前面的yield(1)，就代表产出的值为1。</li>\n</ul><p>除了yield以外，我们也可以借助Kotlin协程当中的Channel来实现类似的代码模式：</p><pre><code class=\"language-plain\">// 看不懂代码没关系，目前咱们只需要关心代码的执行结果\nfun main() = runBlocking {\n    val channel = getProducer(this)\n    testConsumer(channel)\n}\n\nfun getProducer(scope: CoroutineScope) = scope.produce {\n    println(\"Send:1\")\n    send(1)\n    println(\"Send:2\")\n    send(2)\n    println(\"Send:3\")\n    send(3)\n    println(\"Send:4\")\n    send(4)\n}\n\nsuspend fun testConsumer(channel: ReceiveChannel&lt;Int&gt;) {\n    delay(100)\n    val i = channel.receive()\n    println(\"Receive$i\")\n    delay(100)\n    val j = channel.receive()\n    println(\"Receive$j\")\n    delay(100)\n    val k = channel.receive()\n    println(\"Receive$k\")\n    delay(100)\n    val m = channel.receive()\n    println(\"Receive$m\")\n}\n\n/*\n输出结果：\nSend:1\nReceive1\nSend:2\nReceive2\nSend:3\nReceive3\nSend:4\nReceive4\n*/\n</code></pre><p>可见，以上代码中的getProducer()和testConsumer()之间，它们也是交替执行的。</p><p>所以，<strong>从广义上来讲，协程就代表了“互相协作的程序”。</strong>这样的标准，几乎适用于所有语言的协程。不管是Python的协程还是C#的协程，还是其他语言的协程，它们都是以这样的模式来实现的。而且，很多语言的协程都支持yield。理解了这一点以后，将来不管你是遇到Python的协程，还是其他语言的协程也好，相信你也可以很快地把Kotlin协程当中的概念迁移过去。</p><p>聊完广义的协程以后，我们再来看看Kotlin协程的另外两个概念：协程、协程框架。<strong>注意</strong>，这是两个不一样的概念，前者是代表了程序当中被创建的协程；后者，则是一个整体的框架。</p><h2>如何理解Kotlin的协程？</h2><p>在Kotlin当中，协程是一个独立的框架。跟Kotlin的反射库类似，协程并不是直接集成在标准库当中的。如果我们想要使用Kotlin的协程，就必须手动进行依赖：</p><pre><code class=\"language-groovy\">implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.0'\n</code></pre><p>Kotlin官方之所以将协程作为一个单独的框架独立出来，也是为了减小标准库的体积，给开发者更多的灵活性。另外，Kotlin协程框架也是开源的，我们可以去GitHub上去浏览它的<a href=\"https://github.com/Kotlin/kotlinx.coroutines\">源代码</a>。在这里，我们可以找到许多前沿的信息，也可以跟世界顶级的开发者交流。</p><p>业界一直有一种说法：<strong>Kotlin协程其实就是一个封装的线程框架</strong>。如果我们站在框架的层面来看的话，这种说法也有一定道理：协程框架将线程池进一步封装，对开发者暴露出统一的协程API。</p><p>不过，这种说法无法解释另一个语境下的问题，让我们来看一个代码例子。</p><pre><code class=\"language-plain\">// 代码中一共启动了两个线程\nfun main() {\n    println(Thread.currentThread().name)\n    thread {\n        println(Thread.currentThread().name)\n        Thread.sleep(100)\n    }\n    Thread.sleep(1000L)\n}\n\n/*\n输出结果：\nmain\nThread-0\n*/\n</code></pre><p>上面这段代码的逻辑很简单，就是在main函数当中启动了一个新的线程。“代码中一共启动了两个线程”，这句话的意思也很容易理解：main()函数本身会启动一个主线程main，然后在 <code>thread{}</code> 当中，又启动了一个新的线程“Thread-0”。所以，以上代码一共会启动两个线程。这没什么问题，关键是下一个例子：</p><pre><code class=\"language-plain\">// 代码中一共启动了两个协程\nfun main() = runBlocking {\n    println(Thread.currentThread().name)\n\n    launch {\n        println(Thread.currentThread().name)\n        delay(100L)\n    }\n\n    Thread.sleep(1000L)\n}\n\n/*\n输出结果：\nmain @coroutine#1\nmain @coroutine#2\n\n这里要配置特殊的VM参数：-Dkotlinx.coroutines.debug\n这样一来，Thread.currentThread().name就能会包含：协程的名字@coroutine#1\n*/\n</code></pre><p>在这段代码的注释当中，有这样一句话：<strong>代码中一共启动了两个协程</strong>。请问，这个语境下的“两个协程”，到底是什么？通过程序的输出结果，我们可以看到，main函数当中出现了两个协程，一个是“coroutine#1”，一个是“coroutine#2”。</p><p>那么，这里的“协程”，到底是什么呢？它看起来好像跟Java的线程有点类似，但又好像是两个完全不一样的东西。这其实就是很多初学者会困扰的地方。</p><p>Kotlin的协程，它要比线程更加抽象，因为Java的线程，我们起码可以找到Thread的源代码，同时，线程也是操作系统当中的一个概念，所以理解起来并不困难。而Kotlin的协程则没有类似的知识点可以建立关联。所以，我自己在学习Kotlin协程的时候，做法就是建立起<strong>协程的思维模型</strong>（Mental Model）。</p><p>很多人可能不太理解思维模型到底是什么，它在有些语境下，也被称为<a href=\"https://zh.wikipedia.org/wiki/%E5%BF%83%E6%99%BA%E6%A8%A1%E5%9E%8B\">心智模型</a>。人为了理解真实世界的运作规律，会自然而然地在脑子里建立起对应的模型。举个例子，我们为了理解公司内部的组织架构，经常会在脑子里建立一个类似这样的树状思维模型：</p><p><img src=\"https://static001.geekbang.org/resource/image/38/a1/38d10ff8262caacae94733d77a6f88a1.jpg?wh=2000x1055\" alt=\"\"></p><p>那么，我们该如何为Kotlin的协程建立思维模型呢？其实，Kotlin的协程，我们可以将其想象成一个“更加轻量的线程”。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/62/dfab62d3f0c8558de5768e359fcb0462.png?wh=1920x1080\" alt=\"图片\"></p><p>从包含关系上看，协程跟线程的关系，有点像线程与进程的关系，毕竟协程不可能脱离线程运行。所以，协程可以理解为<strong>运行在线程当中的、更加轻量的Task</strong>。</p><h3>协程的轻量</h3><p>那么，协程的轻量，到底意味着什么呢？我们可以先来看一段这样的代码：</p><pre><code class=\"language-plain\">// 仅用作研究，工作中别这么写\nfun main() {\n    repeat(1000_000_000) {\n        thread {\n            Thread.sleep(1000000)\n        }\n    }\n\n    Thread.sleep(10000L)\n}\n\n/*\n输出结果：\nException in thread \"main\" java.lang.OutOfMemoryError: unable to create new native thread\n    at java.lang.Thread.start0(Native Method)\n    at java.lang.Thread.start(Thread.java:717)\n    at kotlin.concurrent.ThreadsKt.thread(Thread.kt:42)\n    at kotlin.concurrent.ThreadsKt.thread$default(Thread.kt:20)\n*/\n</code></pre><p>在上面的代码中，我们尝试启动10亿个线程，这样的代码运行在大部分的机器上都是会因为内存不足等原因而异常退出的。而如果我们将代码改用协程来实现的话，结果会怎样呢？</p><pre><code class=\"language-plain\">// 仅用作研究，工作中别这么写\nfun main() = runBlocking {\n    repeat(1000_000_000) {\n        launch {\n            delay(1000000)\n        }\n    }\n\n    delay(10000L)\n}\n\n/*\n运行结果：\n正常\n*/\n</code></pre><p>在这段代码中，我们启动了10亿个协程。由于协程是非常轻量的，所以代码不会因为内存不足而异常退出。</p><blockquote>\n<p>注意：虽然协程非常轻量，但在工作当中，我们也应该尽量避免写出类似上面这样的代码。</p>\n</blockquote><p>另外，协程虽然运行在线程之上，但协程并不会和某个线程绑定，在某些情况下，协程是可以在不同的线程之间切换的。我们可以来看看下面的代码：</p><pre><code class=\"language-plain\">fun main() = runBlocking(Dispatchers.IO) {\n    repeat(3) {\n        launch {\n            repeat(3) {\n                println(Thread.currentThread().name)\n                delay(100)\n            }\n        }\n    }\n\n    delay(5000L)\n}\n\n/*\n输出结果：\nDefaultDispatcher-worker-3 @coroutine#2\nDefaultDispatcher-worker-2 @coroutine#3\nDefaultDispatcher-worker-4 @coroutine#4\nDefaultDispatcher-worker-1 @coroutine#2 // 线程切换了\nDefaultDispatcher-worker-4 @coroutine#4\nDefaultDispatcher-worker-2 @coroutine#3\nDefaultDispatcher-worker-2 @coroutine#2 // 线程切换了\nDefaultDispatcher-worker-1 @coroutine#4\nDefaultDispatcher-worker-4 @coroutine#3\n\n*/\n</code></pre><p>以上代码的运行结果是随机的，这里以我运行的结果来分析的话，可以看到，“coroutine#2”的三次执行，每一次都在不同的线程上。第一次，它在“worker-3”执行，第二次在“worker-1”执行，第三次在“worker-2”执行。</p><p>这时候，我们就可以进一步更新脑海中的思维模型了。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/a9/d89e8744663d45635a5125829a9037a9.gif?wh=1080x608\" alt=\"图片\"></p><p>让我们来做个小结：</p><ul>\n<li>协程，可以理解为更加轻量的线程，成千上万个协程可以同时运行在一个线程当中；</li>\n<li>协程，其实是运行在线程当中的轻量的Task；</li>\n<li>协程，不会与特定的线程绑定，它可以在不同的线程之间灵活切换。</li>\n</ul><h3>协程的“非阻塞”</h3><p>另外，协程对比线程还有一个特点，那就是<strong>非阻塞</strong>（Non Blocking），而线程则往往是阻塞式的。这个概念有点抽象，我们来看个具体的例子：</p><pre><code class=\"language-plain\">fun main() {\n    repeat(3) {\n        Thread.sleep(1000L)\n        println(\"Print-1:${Thread.currentThread().name}\")\n    }\n\n    repeat(3) {\n        Thread.sleep(900L)\n        println(\"Print-2:${Thread.currentThread().name}\")\n    }\n}\n\n/*\n输出结果：\nPrint-1:main\nPrint-1:main\nPrint-1:main\nPrint-2:main\nPrint-2:main\nPrint-2:main\n*/\n</code></pre><p>在上面的代码里有两个repeat，第一个repeat当中，我们每次调用sleep()方法，让线程休眠1秒钟，而第二个repeat当中，我们每次只休眠0.9秒。由于线程的sleep()方法是阻塞式的，所以程序的执行流程是线性的。也就是说，“Print-1”会连续输出三次，然后“Print-2”会连续输出三次。即使Print-2休眠的时间更短。</p><p>让我们来看看协程代码的表现有哪些不一样：</p><pre><code class=\"language-plain\">fun main() = runBlocking {\n    launch {\n        repeat(3) {\n            delay(1000L)\n            println(\"Print-1:${Thread.currentThread().name}\")\n        }\n    }\n\n    launch {\n        repeat(3) {\n            delay(900L)\n            println(\"Print-2:${Thread.currentThread().name}\")\n        }\n    }\n    delay(3000L)\n}\n\n/*\n输出结果：\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\n*/\n</code></pre><p>在上面的代码中，我们用协程实现了类似的逻辑，但这次的执行结果却完全不一样。可以看到，Print-2和Print-1是交替输出的，“coroutine#2”、“coroutine#3”这两个协程是并行的（Concurrent）。同时，由于协程的delay()方法是非阻塞的，所以，即使Print-1会先执行delay(1000L)，但它也并不会阻塞Print-2的delay(900L)的运行。</p><p>而如果我们将代码中的delay修改成sleep，程序的运行结果就会不一样。</p><pre><code class=\"language-plain\">fun main() = runBlocking {\n    launch {\n        repeat(3) {\n            Thread.sleep(1000L)\n            println(\"Print-1:${Thread.currentThread().name}\")\n        }\n    }\n\n    launch {\n        repeat(3) {\n            Thread.sleep(900L)\n            println(\"Print-2:${Thread.currentThread().name}\")\n        }\n    }\n    delay(3000L)\n}\n\n/*\n输出结果：\nPrint-1:main @coroutine#2\nPrint-1:main @coroutine#2\nPrint-1:main @coroutine#2\nPrint-2:main @coroutine#3\nPrint-2:main @coroutine#3\nPrint-2:main @coroutine#3\n*/\n</code></pre><p>由此可见，Kotlin协程的“非阻塞”其实<strong>只是语言层面</strong>的，当我们调用JVM层面的Thread.sleep()的时候，它仍然会变成阻塞式的。与此同时，这也意味着我们在协程当中应该尽量避免出现阻塞式的行为。尽量使用delay，而不是sleep。</p><p>那么，我们该如何理解Kotlin协程的“非阻塞”？答案是：<strong>挂起和恢复</strong>。这两个能力也是协程才拥有的特殊能力，普通的程序是不具备的。</p><p>挂起和恢复，初学者看到这两个概念可能会比较陌生。它俩的字面意思我们都能看懂，但当发生在程序世界里之后，就无法理解了，因为我们根本就看不见，也摸不着。那怎么办呢？</p><p>我的做法还是：<strong>建立思维模型</strong>。</p><p>对于执行在普通线程当中的程序来说，如果我们站在CPU的角度上看，最终它会以类似这样的方式执行：</p><p><img src=\"https://static001.geekbang.org/resource/image/dd/bc/dd4cfa1246e6141262a9de48d31dbcbc.gif?wh=1080x358\" alt=\"图片\"></p><p>这时候，当某个任务发生了阻塞行为的时候，比如sleep，当前执行的Task就会阻塞后面所有任务的执行。就像下面这张动图所展示的一样：</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/41/e862e19363f44c56a01709643791ee41.gif?wh=1080x346\" alt=\"图片\"></p><p><strong>那么，协程是如何通过挂起和恢复来实现非阻塞的呢？</strong></p><p>大部分的语言当中都会存在一个类似“调度中心”的东西，它会来实现Task任务的执行和调度。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/f9/f28fa6fb2ba6d147de33ccb649969cf9.png?wh=1920x937\" alt=\"图片\"></p><p>而协程除了拥有“调度中心”以外，对于每个协程的Task，还会多出一个类似“抓手”“挂钩”的东西，可以方便我们对它进行“挂起和恢复”。协程任务的总体执行流程，大致会像下图描述的这样：</p><p><img src=\"https://static001.geekbang.org/resource/image/50/26/50ayycf2b8d015cf8cef7dcde541ae26.gif?wh=1080x499\" alt=\"图片\"></p><p>通过对比可以看出，线程的sleep之所以是阻塞式的，是因为它会阻挡后续Task的执行。而协程之所以是非阻塞式的，是因为它可以支持挂起和恢复。当Task由于某种原因被挂起后，后续的Task并不会因此被阻塞。</p><p>这时候，如果我们回过头再来看之前的代码，相信也会有新的体会：</p><pre><code class=\"language-plain\">fun main() = runBlocking {\n    launch {\n        repeat(3) {\n            delay(1000L)\n            println(\"Print-1:${Thread.currentThread().name}\")\n        }\n    }\n\n    launch {\n        repeat(3) {\n            delay(900L)\n            println(\"Print-2:${Thread.currentThread().name}\")\n        }\n    }\n    delay(3000L)\n}\n\n/*\n输出结果：\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\nPrint-2:main @coroutine#3\nPrint-1:main @coroutine#2\n*/\n</code></pre><h2>小结</h2><p>好了，到这里，我们今天的内容就差不多结束了。这节课我并没有给你介绍任何具体的协程API，而是先带你建立协程的思维模型，目的就是让你在这个过程中，真正理解协程的核心概念，并建立起一个清晰的认知，从而为后面API的学习打下基础。毕竟，磨刀不误砍柴工嘛！</p><p>那么在学完这节课之后，你也需要掌握以下几个要点：</p><ul>\n<li>广义的协程，可以理解为“互相协作的程序”，也就是“Cooperative-routine”。</li>\n<li>协程框架，是独立于Kotlin标准库的一套框架，它封装了Java的线程，对开发者暴露了协程的API。</li>\n<li>程序当中运行的“协程”，可以理解为<strong>轻量的线程</strong>；</li>\n<li>一个线程当中，可以运行成千上万个协程；</li>\n<li>协程，也可以理解为运行在线程当中的<strong>非阻塞的Task</strong>；</li>\n<li>协程，通过<strong>挂起和恢复</strong>的能力，实现了“非阻塞”；</li>\n<li>协程不会与特定的线程绑定，它可以在不同的线程之间灵活切换，而这其实也是通过“挂起和恢复”来实现的。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/bd/9d/bd90de594f1209631cec647a876eee9d.jpg?wh=2000x716\" alt=\"\"></p><p>说实话，学习协程，真的不是一件容易的事情。如果这节课我不介绍协程的思维模型，一上来就介绍协程的API，你一定会觉得云里雾里、找不着方向。所以，也请你不要轻视这节课的重要性，一定要充分理解本节课的内容，再去学习后面的知识点。</p><p>下节课开始，我会正式介绍Kotlin协程相关的API，同时，也会进一步完善我们的协程思维模型。</p><h2>思考题</h2><p>有人说：协程会比线程更加高效，请问你认同这种说法吗？为什么？ 欢迎在留言区分享你的看法和见解，也欢迎你把今天的内容分享给更多的朋友，我们一起交流探讨。</p>","comments":[{"had_liked":false,"id":335452,"user_name":"曾帅","can_delete":false,"product_type":"c1","uid":1234319,"ip_address":"","ucode":"322F049DA9284D","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/8f/d0874a01.jpg","comment_is_top":false,"comment_ctime":1645523101,"is_pvip":false,"replies":[{"id":"122573","content":"2019年的时候，我跟扔物线大佬同台做技术分享的时候，我们曾经在群里讨论过这个问题。“Kotlin协程在JVM上面是线程的封装”这没有错，这也是本质，谁都无法否认。<br><br>但是，这样的思维对我们学习Kotlin协程没有帮助，因为它过于底层，脱离了Kotlin的范畴。Java是不是二进制机器码的封装？当然是啦！但这个思路，能辅助我们学好Java的泛型吗？不能。<br><br>泛型是Java里才有的概念，机器码是感知不到的，因为“机器码”已经脱离了Java本身的范畴。同理，Kotlin协程是Kotlin才有的概念，JVM感知不到，因为它已经脱离了Kotlin的范畴。<br><br>换句话说，如果我们非要把Kotlin的协程类比成JVM的线程，我们就根本无法理解它的：“协作模式”、“非阻塞”、“挂起和恢复”、“结构化并发”、“冷数据流”、“异常处理机制”。<br><br>要知道，这都是Kotlin创造出来的概念啊，跟JVM一点关系都没有啊！所以，“Kotlin协程是JVM线程框架”这句话作为初步印象是可以的，但如果我们想要把Kotlin协程弄明白，还是要老老实实的去写Kotlin程序、读Kotlin的源码。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645593195,"ip_address":"","comment_id":335452,"utype":1}],"discussion_count":5,"race_medal":0,"score":"160559313053","product_id":100103401,"comment_content":"之前看过另一位大佬 扔物线 说过的一个点，这里也想请教一下。就是运行在 JVM 上的 Kotlin 协程，本质上就是线程的封装，因为 JVM 上是没有协程这种东西。所以文章中说的一些概念，在 JVM 上运行的 Kotlin 来说，可能不适用。","like_count":38,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552769,"discussion_content":"2019年的时候，我跟扔物线大佬同台做技术分享的时候，我们曾经在群里讨论过这个问题。“Kotlin协程在JVM上面是线程的封装”这没有错，这也是本质，谁都无法否认。\n\n但是，这样的思维对我们学习Kotlin协程没有帮助，因为它过于底层，脱离了Kotlin的范畴。Java是不是二进制机器码的封装？当然是啦！但这个思路，能辅助我们学好Java的泛型吗？不能。\n\n泛型是Java里才有的概念，机器码是感知不到的，因为“机器码”已经脱离了Java本身的范畴。同理，Kotlin协程是Kotlin才有的概念，JVM感知不到，因为它已经脱离了Kotlin的范畴。\n\n换句话说，如果我们非要把Kotlin的协程类比成JVM的线程，我们就根本无法理解它的：“协作模式”、“非阻塞”、“挂起和恢复”、“结构化并发”、“冷数据流”、“异常处理机制”。\n\n要知道，这都是Kotlin创造出来的概念啊，跟JVM一点关系都没有啊！所以，“Kotlin协程是JVM线程框架”这句话作为初步印象是可以的，但如果我们想要把Kotlin协程弄明白，还是要老老实实的去写Kotlin程序、读Kotlin的源码。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1645593195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1181334,"avatar":"https://static001.geekbang.org/account/avatar/00/12/06/96/4273bb09.jpg","nickname":"遥远的救世主","note":"","ucode":"4CC436479CAA21","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":573578,"discussion_content":"茅塞顿开，高屋建瓴","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1653524814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":552769,"ip_address":""},"score":573578,"extra":""},{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":591985,"discussion_content":"“同理，Kotlin协程是Kotlin才有的概念，JVM感知不到，因为它已经脱离了Kotlin的范畴。”\n\n最后打错了吧，脱离了 JVM 的范畴~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667006596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":552769,"ip_address":"河北"},"score":591985,"extra":""}]},{"author":{"id":1006789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","nickname":"梁中华","note":"","ucode":"52FE40242CBAD0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557307,"discussion_content":"我的理解是，凡是能支持suspend和resume的操作的，都可以充分利用协程，否则还是利用java的线程池，基本没法提升性能。只要Kotlin的编程模型能提供真实的、基于事件的的suspend和resume异步操作，就是真正的协程。就是netty充分利用NIO中epoll实现异步编程一样，如果协程，netty的异步编程最终还是会变成基于线程池的同步操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647760048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020838,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","nickname":"Renext","note":"","ucode":"3C4418F7E86CD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553196,"discussion_content":"说的好，受教了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645759848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333780,"user_name":"$Kotlin","can_delete":false,"product_type":"c1","uid":2148188,"ip_address":"","ucode":"098E9C8F60D865","user_header":"https://static001.geekbang.org/account/avatar/00/20/c7/5c/94cb3a1a.jpg","comment_is_top":false,"comment_ctime":1644510692,"is_pvip":false,"replies":[{"id":"121941","content":"感谢认可，看到我的课程能真的帮到你，我也非常高兴。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644561361,"ip_address":"","comment_id":333780,"utype":1}],"discussion_count":1,"race_medal":0,"score":"139083464164","product_id":100103401,"comment_content":"我已经在网上看了一周的协程资料了，在这里第一次看见这个抓手的思维模型，思路一下子就打开了，太强了。","like_count":33,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550475,"discussion_content":"感谢认可，看到我的课程能真的帮到你，我也非常高兴。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644561361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333823,"user_name":"focus on","can_delete":false,"product_type":"c1","uid":1130223,"ip_address":"","ucode":"DA5267BBA78367","user_header":"https://static001.geekbang.org/account/avatar/00/11/3e/ef/4a8d3f89.jpg","comment_is_top":false,"comment_ctime":1644549327,"is_pvip":false,"replies":[{"id":"121931","content":"我用PPT动画一帧帧做的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644560558,"ip_address":"","comment_id":333823,"utype":1}],"discussion_count":1,"race_medal":0,"score":"83248927951","product_id":100103401,"comment_content":"请问文章中的动图是用什么软件制作的呢？","like_count":20,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550464,"discussion_content":"我用PPT动画一帧帧做的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644560558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338934,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1647813802,"is_pvip":false,"replies":[{"id":"124012","content":"这个同学的解释也很透彻。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648030607,"ip_address":"","comment_id":338934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61777355946","product_id":100103401,"comment_content":"个人觉得把协程看做是封装的线程的看法帮助不大，线程是操作系统的概念，编程语言只是封装实现，让任务能够方便的被操作系统调度，调度是操作系统的事情，编程语言基本不管。协程是编程语言级别的任务，最终的调度可能是一个线程，也可能是共享的线程库，也可能是多个不同的线程，从线程角度很难理解协程的非阻塞，也无法理解协程之间的协同。我觉得把协程理解为编程语言级别的任务异步任务管理比较合适。虽然最终任务还是要给CPU执行，编译器（包括运行器）承担了大部分的分配调度责任。如果任务是CPU密集的，协程能提高的效率不多，毕竟CPU就这么多，操作系统的线程就是为这种场景设计的。如果任务是IO密集的，当年设计操作系统的时候，可没有想到会有那么多IO并发。协程比线程多出了线程内部异步的能力，让任务在CPU和IO之间不断调度轮转，可以充分利用CPU和IO设备，进而提高效率。Android程序和很多调用其他微服务的api都是IO很多的任务，协程能够提高效率。<br>","like_count":15,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557958,"discussion_content":"这个同学的解释也很透彻。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648030607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333806,"user_name":"ACE_Killer09","can_delete":false,"product_type":"c1","uid":1618019,"ip_address":"","ucode":"4ED9D2A521A237","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqQVYE1EfqibdyNsnjFibHW4jee0Q3qMMeRhqqVQUn5Ix9fFl3Zfzf0xpdrGypxHUmBCyiczfyEaPoWA/132","comment_is_top":false,"comment_ctime":1644545055,"is_pvip":false,"replies":[{"id":"121940","content":"感谢这位同学的补充，之前代码没看懂的同学可以看看。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644561087,"ip_address":"","comment_id":333806,"utype":1}],"discussion_count":7,"race_medal":0,"score":"23119381535","product_id":100103401,"comment_content":"repeat(3) { launch { repeat(3) { println(Thread.currentThread().name) delay(100) } } }<br><br>repeat 是重复，launch是 创建协程。重复创建3个协程，每个协程执行3次，执行的内容是 打印协程执行时所在的线程。<br><br>结果说明同一个协程 可以再不同的线程上执行。","like_count":6,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550474,"discussion_content":"感谢这位同学的补充，之前代码没看懂的同学可以看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644561087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550897,"discussion_content":"这位同学解释的，应该是这段代码。\n```\nfun main() = runBlocking(Dispatchers.IO) {\n    repeat(3) {\n        launch {\n            repeat(3) {\n                println(Thread.currentThread().name)\n                delay(100)\n            }\n        }\n    }\n\n    delay(5000L)\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644802585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121447,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/a7/630d82b4.jpg","nickname":"紫羽","note":"","ucode":"5CF45802D526DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550684,"discussion_content":"有个疑惑 ，此时不是只有主线程在运行吗，它是怎么跑到其他线程执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644670098,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1121447,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1c/a7/630d82b4.jpg","nickname":"紫羽","note":"","ucode":"5CF45802D526DA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550753,"discussion_content":"结果说明的是：多个协程可以运行在同一个线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644725792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550684,"ip_address":""},"score":550753,"extra":""}]},{"author":{"id":1329756,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4a/5c/a786deb5.jpg","nickname":"提醒圈圈去看书","note":"","ucode":"86F5E3C4E2978A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550503,"discussion_content":"请教一下，第一个repeat创建了三个线程吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644571828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1329756,"avatar":"https://static001.geekbang.org/account/avatar/00/14/4a/5c/a786deb5.jpg","nickname":"提醒圈圈去看书","note":"","ucode":"86F5E3C4E2978A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550754,"discussion_content":"并没有创建线程，这位同学前面的分析没问题，后面的结论并没有对应上。结果说明的是：多个协程可以运行在同一个线程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644725831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550503,"ip_address":""},"score":550754,"extra":""},{"author":{"id":1618019,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqQVYE1EfqibdyNsnjFibHW4jee0Q3qMMeRhqqVQUn5Ix9fFl3Zfzf0xpdrGypxHUmBCyiczfyEaPoWA/132","nickname":"ACE_Killer09","note":"","ucode":"4ED9D2A521A237","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":550907,"discussion_content":"以上代码的运行结果是随机的，这里以我运行的结果来分析的话，可以看到，“coroutine#2”的三次执行，每一次都在不同的线程上。第一次，它在“worker-3”执行，第二次在“worker-1”执行，第三次在“worker-2”执行。\n// ==== 我觉得这2个结论 应该都是对的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644809242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550754,"ip_address":""},"score":550907,"extra":""}]}]},{"had_liked":false,"id":344346,"user_name":"如浴春风","can_delete":false,"product_type":"c1","uid":1891545,"ip_address":"","ucode":"FFB2EEAF8D3076","user_header":"https://static001.geekbang.org/account/avatar/00/1c/dc/d9/f1f763ba.jpg","comment_is_top":false,"comment_ctime":1651483636,"is_pvip":false,"replies":[{"id":"125932","content":"感谢这位同学的补充，推荐其他同学也看看。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1652024971,"ip_address":"","comment_id":344346,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14536385524","product_id":100103401,"comment_content":"「协程的“非阻塞”」那里，“阻塞”的概念可以可能会有同学存在跟我一样困扰。<br><br>其实可以这样理解：<br><br>如果在同一个 CoroutineContext 里调用了一个 suspend 方法，当前协程的顺序执行流会被“阻塞”，等待该 suspend 方法执行结束后回到原位置继续执行。但该协程所依赖的线程并不会被“阻塞”，有可能会被调度到执行其他协程任务。—— 这种的应用场景是，可以将各种回调通过封装，避免了回调地狱，同时使得代码逻辑更符合阅读习惯。<br><br>不得不说，作者的协程图示真形象！恳切建议其他同学一起细细揣摩下。","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571005,"discussion_content":"感谢这位同学的补充，推荐其他同学也看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652024971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344086,"user_name":"_","can_delete":false,"product_type":"c1","uid":2134590,"ip_address":"","ucode":"11CD0FADDECCDE","user_header":"https://static001.geekbang.org/account/avatar/00/20/92/3e/82ab7967.jpg","comment_is_top":false,"comment_ctime":1651227166,"is_pvip":false,"replies":[{"id":"125627","content":"加油 :）","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651244928,"ip_address":"","comment_id":344086,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14536129054","product_id":100103401,"comment_content":"《深入理解JVM虚拟机》中提到过“协程”是“用户级线程”，不过这是从操作系统效率角度来称呼它，所以反而不太容易让“人”理解。而将“Kotlin协程”理解为“线程级Task”这种从上到下的角度要直观的多！大佬讲的很棒！👍🏻","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568869,"discussion_content":"加油 :）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651244928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333804,"user_name":"Geek_0d808c","can_delete":false,"product_type":"c1","uid":2384070,"ip_address":"","ucode":"1E061CA6AFB93E","user_header":"","comment_is_top":false,"comment_ctime":1644543799,"is_pvip":false,"replies":[{"id":"121939","content":"说得很好！线程和协程，其实在特定场景下才有可比性。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644561027,"ip_address":"","comment_id":333804,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14529445687","product_id":100103401,"comment_content":"在处理高并发，轻量任务的前提下，协程少了，线程创建的系统调用，上下文切换等时间，以及线程内存开销，是线程的复用，所以特定场景下，代价更小。","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550473,"discussion_content":"说得很好！线程和协程，其实在特定场景下才有可比性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644561027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353457,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"美国","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1659458639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5954425935","product_id":100103401,"comment_content":"协程会比线程更加高效的说法，基本等效于线程比进程更加高效。","like_count":1},{"had_liked":false,"id":349783,"user_name":"爱学习的蓝莓","can_delete":false,"product_type":"c1","uid":2929548,"ip_address":"","ucode":"7DCD19B3C5802F","user_header":"https://static001.geekbang.org/account/avatar/00/2c/b3/8c/461b6e65.jpg","comment_is_top":false,"comment_ctime":1656322662,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5951289958","product_id":100103401,"comment_content":"想请教下老师：既然协程是轻量级线程，那它是否能代替大部分线程的工作，有没有某些场景更适合使用线程而不适合用协程呢？","like_count":1},{"had_liked":false,"id":336260,"user_name":"Renext","can_delete":false,"product_type":"c1","uid":1020838,"ip_address":"","ucode":"3C4418F7E86CD6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","comment_is_top":false,"comment_ctime":1646039841,"is_pvip":false,"replies":[{"id":"122957","content":"第29讲的时候，我会解释哈~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646136011,"ip_address":"","comment_id":336260,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5941007137","product_id":100103401,"comment_content":"为什么协程可以在线程直接灵活切换呢？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553934,"discussion_content":"第29讲的时候，我会解释哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646136011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333819,"user_name":"7Promise","can_delete":false,"product_type":"c1","uid":2879220,"ip_address":"","ucode":"BF7C7F042E51F3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/f4/27a5080a.jpg","comment_is_top":false,"comment_ctime":1644548302,"is_pvip":false,"replies":[{"id":"121932","content":"嗯，不错的理解。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644560611,"ip_address":"","comment_id":333819,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5939515598","product_id":100103401,"comment_content":"协程可以在适当的时机挂起和恢复，一个协程在挂起等待时，另外的协程也可以工作，比阻塞的线程更节省资源。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550465,"discussion_content":"嗯，不错的理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644560611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333778,"user_name":"$Kotlin","can_delete":false,"product_type":"c1","uid":2148188,"ip_address":"","ucode":"098E9C8F60D865","user_header":"https://static001.geekbang.org/account/avatar/00/20/c7/5c/94cb3a1a.jpg","comment_is_top":false,"comment_ctime":1644510513,"is_pvip":false,"replies":[{"id":"121934","content":"嗯，说的很棒，主要还是看使用十分合理。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644560699,"ip_address":"","comment_id":333778,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5939477809","product_id":100103401,"comment_content":"协程比乱用线程要高效，和合理使用线程池效率一致。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550467,"discussion_content":"嗯，说的很棒，主要还是看使用十分合理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644560699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359944,"user_name":"夏帆","can_delete":false,"product_type":"c1","uid":3033735,"ip_address":"广东","ucode":"D4C9DCD01E85AD","user_header":"https://static001.geekbang.org/account/avatar/00/2e/4a/87/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1666084762,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666084762","product_id":100103401,"comment_content":"其实协程本身也是线程，只不过是用户级的线程。协程需要接触内核级线程（这才是我们传统意义的线程），才可以到内核运行，所以看起来就好像协程一直在搭载不同线程一样","like_count":0},{"had_liked":false,"id":347772,"user_name":"BUG君","can_delete":false,"product_type":"c1","uid":1143211,"ip_address":"","ucode":"B7513F37026E5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/71/ab/b19a1ba2.jpg","comment_is_top":false,"comment_ctime":1654415881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654415881","product_id":100103401,"comment_content":"文章中提到的“协程不可能脱离线程运行”这句话感觉不是很准确，其实协程是可以直接运行在进程中的，比如unix，只不过现代语言都会为每一个进程启动这个主线程，所以在现代语言中可以理解为协程必然会运行在线程中。","like_count":0},{"had_liked":false,"id":340829,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1649168113,"is_pvip":false,"replies":[{"id":"124726","content":"runBlocking算一个，launch重复了3次就有3个，一共4个。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649435829,"ip_address":"","comment_id":340829,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649168113","product_id":100103401,"comment_content":"fun main() = runBlocking(Dispatchers.IO) { repeat(3) { launch { repeat(3) { println(Thread.currentThread().name) delay(100) } } } delay(5000L)}<br><br>这个我们怎么看都是启动了 2 个协程呀","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560788,"discussion_content":"runBlocking算一个，launch重复了3次就有3个，一共4个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649435830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338840,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1647760294,"is_pvip":true,"replies":[{"id":"124023","content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648031550,"ip_address":"","comment_id":338840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647760294","product_id":100103401,"comment_content":"<br>&#47;&#47; 仅用作研究，工作中别这么写<br>fun main() = runBlocking {<br>    repeat(1000_000_000) {<br>        launch {<br>            delay(1000000)<br>        }<br>    }<br><br>    delay(10000L)<br>}<br><br>如果没有delay()这个支持suspend得到方法，直接用sleep(), 也是没法创建1亿个协程的。即使能创建1亿协程，最终也会有1亿个线程对应。所以suspend才是关键。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557969,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648031550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336745,"user_name":"山河入梦","can_delete":false,"product_type":"c1","uid":1480185,"ip_address":"","ucode":"6B8C4896012092","user_header":"https://static001.geekbang.org/account/avatar/00/16/95/f9/0d4801ce.jpg","comment_is_top":false,"comment_ctime":1646348923,"is_pvip":false,"replies":[{"id":"123156","content":"确实不存在绝对的优劣。其实也看特定场景。某些场景下线程会更适合、某些场景下协程会更合适。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646581492,"ip_address":"","comment_id":336745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646348923","product_id":100103401,"comment_content":"我觉得协程并没有比线程更加的高效，虽然协程有“轻量”，“非阻塞”等特性，但是它本质上是对线程的封装。我的理解是协程比线程更加的便捷","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554760,"discussion_content":"确实不存在绝对的优劣。其实也看特定场景。某些场景下线程会更适合、某些场景下协程会更合适。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646581492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336259,"user_name":"Renext","can_delete":false,"product_type":"c1","uid":1020838,"ip_address":"","ucode":"3C4418F7E86CD6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","comment_is_top":false,"comment_ctime":1646039643,"is_pvip":false,"replies":[{"id":"122956","content":"你的思考很有深度，其实，等你学完源码篇，就能找到答案了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646135956,"ip_address":"","comment_id":336259,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1646039643","product_id":100103401,"comment_content":"通过老师的思维模型，我是明白了挂起与恢复是个什么过程。但还是有三个问题不明白：<br>1-关于一个任务是阻塞的还是非阻塞到底是什么决定的呢？<br>2-逻辑上理解了协程，但协程框架内具体是怎么实现的？还是不太明白<br>3-协程更加轻量到底是怎么实现的？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553933,"discussion_content":"你的思考很有深度，其实，等你学完源码篇，就能找到答案了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646135956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1020838,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","nickname":"Renext","note":"","ucode":"3C4418F7E86CD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":553940,"discussion_content":"好的👌🏻谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646138412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553933,"ip_address":""},"score":553940,"extra":""}]}]},{"had_liked":false,"id":335117,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1645342759,"is_pvip":false,"replies":[{"id":"122402","content":"多个协程运行在一个线程也是可以做到的哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645369806,"ip_address":"","comment_id":335117,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645342759","product_id":100103401,"comment_content":"所以到底为啥一个线程中能运行成千上万的协程？<br>还是说这个问题被选择性忽略了一个前提：底层并不是只有一个线程，而是要有一个线程池。<br><br>就像我之所以能在辛辛苦苦、省吃俭用奋斗一年后，买名车买豪宅，不是因为我攒了 10 万块，而是我老爸又给我了 1 个亿 ...","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552261,"discussion_content":"多个协程运行在一个线程也是可以做到的哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645369806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334915,"user_name":"陈","can_delete":false,"product_type":"c1","uid":1531763,"ip_address":"","ucode":"8AEF8530530311","user_header":"https://static001.geekbang.org/account/avatar/00/17/5f/73/a9346146.jpg","comment_is_top":false,"comment_ctime":1645180323,"is_pvip":true,"replies":[{"id":"122406","content":"嗯，也看使用场景，IO密集型的任务，协程非阻塞会占优势一些。","user_name":"作者回复","comment_id":334915,"uid":"1180670","ip_address":"","utype":1,"ctime":1645369952,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1645180323","product_id":100103401,"comment_content":"感觉使用协程可以更充分地使用cpu时间片，减少了线程频繁切换的额外开销","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552265,"discussion_content":"嗯，也看使用场景，IO密集型的任务，协程非阻塞会占优势一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645369952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334759,"user_name":"夜班同志","can_delete":false,"product_type":"c1","uid":1192938,"ip_address":"","ucode":"19941F1537EB7B","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/ea/373d8e6b.jpg","comment_is_top":false,"comment_ctime":1645105170,"is_pvip":false,"replies":[{"id":"122303","content":"没错，要根据实际应用场景来分析。","user_name":"作者回复","comment_id":334759,"uid":"1180670","ip_address":"","utype":1,"ctime":1645151544,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1645105170","product_id":100103401,"comment_content":"觉得要看应用，如果是需要异步协程还是需要线程，这种情况只是简化异步写法，如果是实现类似生产者消费者模式，协程更高效","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551842,"discussion_content":"没错，要根据实际应用场景来分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645151544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334301,"user_name":"开飞机的老舒克","can_delete":false,"product_type":"c1","uid":1231517,"ip_address":"","ucode":"7DD15B40DCF6A7","user_header":"https://static001.geekbang.org/account/avatar/00/12/ca/9d/8646083b.jpg","comment_is_top":false,"comment_ctime":1644854555,"is_pvip":true,"replies":[{"id":"122167","content":"操作系统和CPU其实对协程无感知的。具体细节我会在后面的源码篇提到哈。","user_name":"作者回复","comment_id":334301,"uid":"1180670","ip_address":"","utype":1,"ctime":1644938770,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644854555","product_id":100103401,"comment_content":"个人感觉协程只是对于开发者使用更友好，API用起来更加灵活一些，至于和线程哪个更高效也要看具体的场景，感觉和线程池对比更合理些，线程池的策略也是根据场景不同采取不同的方案，例如线程的数量根据cpu型或者io型任务来定。<br>另请教老师一个问题，一个线程中能运行成千上万的协程，在操作系统层面cpu是如何调度的？应该是根据不同策略协程在多个的线程调度更加高效吧，那是不是也是类似线程池的策略？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551244,"discussion_content":"操作系统和CPU其实对协程无感知的。具体细节我会在后面的源码篇提到哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644938770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334023,"user_name":"jim","can_delete":false,"product_type":"c1","uid":1491946,"ip_address":"","ucode":"C12DB0F2B570F6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Urc67zDC8R6dh9U1ZFTF36icXewM1seehvOUYUs4hyWSsFzS5WQc2RcrE1Mzs8qtgib5SM5wFrVh22QcQd0JUUBw/132","comment_is_top":false,"comment_ctime":1644676862,"is_pvip":false,"replies":[{"id":"122098","content":"感谢你的认可。课程能帮到你，我也很高兴，我们一起加油~","user_name":"作者回复","comment_id":334023,"uid":"1180670","ip_address":"","utype":1,"ctime":1644852276,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644676862","product_id":100103401,"comment_content":"非常的精彩，比很多书籍强很多。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551024,"discussion_content":"感谢你的认可。课程能帮到你，我也很高兴，我们一起加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644852276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334011,"user_name":"夜月","can_delete":false,"product_type":"c1","uid":1121740,"ip_address":"","ucode":"0C05F42E94F76C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Iofqk26ibmjFxAZKRibgUmwc9p5RDDArr9Jt0NTrwTKOhtPTuuia77OxOwyEUpeqp2fvU5HPpY8sK0vBejJNA3ib3w/132","comment_is_top":false,"comment_ctime":1644668175,"is_pvip":false,"replies":[{"id":"122004","content":"嗯，所以，协程更适合执行非阻塞的任务。像你说的这种情况，我们可以根据不同的情况（CPU密集型、IO密集型），让协程工作在线程池上。","user_name":"作者回复","comment_id":334011,"uid":"1180670","ip_address":"","utype":1,"ctime":1644724459,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644668175","product_id":100103401,"comment_content":"我想到一个可能是低效的情况：<br>特殊情况下，假设协称的调度器里只有一个线程执行任务的话，如果有一个耗时比较长的协程先执行了，那么后面的协程是不是都需要等待了，这有时候也会导致延时高，或者卡顿的情况吧；<br>相反线程就不会出现这种情况。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550748,"discussion_content":"嗯，所以，协程更适合执行非阻塞的任务。像你说的这种情况，我们可以根据不同的情况（CPU密集型、IO密集型），让协程工作在线程池上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644724459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333950,"user_name":"面无表情的生鱼片","can_delete":false,"product_type":"c1","uid":1110076,"ip_address":"","ucode":"C71B9DD25C9018","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/3c/d72b0d26.jpg","comment_is_top":false,"comment_ctime":1644635203,"is_pvip":false,"replies":[{"id":"122003","content":"对于案例中的代码，其实并不会涉及到切换线程，所以一定是在main线程阻塞，不过我们也有办法写出线程切换的代码，这个后面会提到。<br><br>另外，感谢你的建议，给代码块标上 id，这个我会考虑的。","user_name":"作者回复","comment_id":333950,"uid":"1180670","ip_address":"","utype":1,"ctime":1644724288,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644635203","product_id":100103401,"comment_content":"老师好，我在 协程的非阻塞 内容下关于把协程中 delay 换成 Thread.sleep 有个疑问，因为前文说协程有可能切换线程来执行，所以这里的输出是不是并不一定和示例里面的结果一致？<br>（建议老师给代码块标上 id，这样比较好对应起来）","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550747,"discussion_content":"对于案例中的代码，其实并不会涉及到切换线程，所以一定是在main线程阻塞，不过我们也有办法写出线程切换的代码，这个后面会提到。\n\n另外，感谢你的建议，给代码块标上 id，这个我会考虑的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644724288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333807,"user_name":"Renext","can_delete":false,"product_type":"c1","uid":1020838,"ip_address":"","ucode":"3C4418F7E86CD6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","comment_is_top":false,"comment_ctime":1644545846,"is_pvip":false,"replies":[{"id":"121933","content":"嗯，这么说也没错，不管是协程还是线程，都只是技术，关键还是看开发者的能力，还有具体应用场景。","user_name":"作者回复","comment_id":333807,"uid":"1180670","ip_address":"","utype":1,"ctime":1644560654,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644545846","product_id":100103401,"comment_content":"我的理解：协程本质是封装线程的框架，底层还是线程，效率并没有超越线程。只是让我们程序员使用的得更方便而已","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550466,"discussion_content":"嗯，这么说也没错，不管是协程还是线程，都只是技术，关键还是看开发者的能力，还有具体应用场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644560654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333794,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1644540310,"is_pvip":false,"replies":[{"id":"121938","content":"这两个都是协程的优势，不可否认。不过技术其实是中立的，更多还是看使用技术的人。<br><br>欢迎其他同学一起来讨论。","user_name":"作者回复","comment_id":333794,"uid":"1180670","ip_address":"","utype":1,"ctime":1644560987,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1644540310","product_id":100103401,"comment_content":"思考题回答<br>我认为协程的确会比线程高效，从两个方面体现，<br>1. 开发更高效，在编写异步任务的代码时，用线程往往需要用回调，回调本身就是容易出错的，尤其涉及到回调地狱。对于Android，还要考虑回调里是否需要切回主线程。而用协程的话编写起来就像全部同步的单线程编程一样，代码清晰，逻辑更符合人脑思维。<br>2. 执行更高效，多线程编程中往往会有线程的切换，这个切换会有性能损耗。而多个协程可以绑定在一个线程中，所以协程切换的损耗就要比线程小。<br>个人理解，不一定到位，希望和其他同学一起","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550472,"discussion_content":"这两个都是协程的优势，不可否认。不过技术其实是中立的，更多还是看使用技术的人。\n\n欢迎其他同学一起来讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644560987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339841,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","nickname":"白乾涛","note":"","ucode":"0C704B0B90C8D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552192,"discussion_content":"你这观点有失偏颇，按你这思维模型，C 比 Java 高效，难道是因为 C 只有一个字母？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645342336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333792,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1644539919,"is_pvip":false,"replies":[{"id":"121937","content":"这个问题三言两语很难讲清楚，等学完本课程以后，相信你自己就能得出答案了。","user_name":"作者回复","comment_id":333792,"uid":"1180670","ip_address":"","utype":1,"ctime":1644560781,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644539919","product_id":100103401,"comment_content":"关于第一个协程示例有个疑问：1. yield挂起之后，怎么恢复的。2. getSequence 和print 在同一个协程里运行，为什么挂起后还能执行print 呢？麻烦老师指点一下","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550470,"discussion_content":"这个问题三言两语很难讲清楚，等学完本课程以后，相信你自己就能得出答案了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644560782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333787,"user_name":"Renext","can_delete":false,"product_type":"c1","uid":1020838,"ip_address":"","ucode":"3C4418F7E86CD6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","comment_is_top":false,"comment_ctime":1644536365,"is_pvip":false,"replies":[{"id":"121936","content":"同学来的好早！","user_name":"作者回复","comment_id":333787,"uid":"1180670","ip_address":"","utype":1,"ctime":1644560730,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644536365","product_id":100103401,"comment_content":"先占个沙发","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550469,"discussion_content":"同学来的好早！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644560730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333782,"user_name":"êｗěｎ","can_delete":false,"product_type":"c1","uid":1066707,"ip_address":"","ucode":"5000233111BEFA","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d3/e25d104a.jpg","comment_is_top":false,"comment_ctime":1644511168,"is_pvip":true,"replies":[{"id":"121935","content":"没错，这也是协程的一大优势。","user_name":"作者回复","comment_id":333782,"uid":"1180670","ip_address":"","utype":1,"ctime":1644560714,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644511168","product_id":100103401,"comment_content":"当协程阻塞了，底层的线程可以去执行其他的任务，资源充分利用了。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550468,"discussion_content":"没错，这也是协程的一大优势。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644560714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333779,"user_name":"$Kotlin","can_delete":false,"product_type":"c1","uid":2148188,"ip_address":"","ucode":"098E9C8F60D865","user_header":"https://static001.geekbang.org/account/avatar/00/20/c7/5c/94cb3a1a.jpg","comment_is_top":false,"comment_ctime":1644510565,"is_pvip":false,"replies":[{"id":"121942","content":"嗯，没错。<br><br>PS：从你的留言时间，能看出是凌晨第一时间来看的更新，对吧？加油哈！一分耕耘一分收获，总有一天，量变会产生质变。","user_name":"作者回复","comment_id":333779,"uid":"1180670","ip_address":"","utype":1,"ctime":1644561506,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644510565","product_id":100103401,"comment_content":"协程比乱用线程要高效，和合理使用线程池效率一致。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550476,"discussion_content":"嗯，没错。\n\nPS：从你的留言时间，能看出是凌晨第一时间来看的更新，对吧？加油哈！一分耕耘一分收获，总有一天，量变会产生质变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644561507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}