{"id":80457,"title":"春节7天练 | Day 2：栈、队列和递归","content":"<p>你好，我是王争。初二好！</p><p>为了帮你巩固所学，真正掌握数据结构和算法，我整理了数据结构和算法中，必知必会的30个代码实现，分7天发布出来，供你复习巩固所用。今天是第二篇。</p><p>和昨天一样，你可以花一点时间，来完成测验。测验完成后，你可以根据结果，回到相应章节，有针对性地进行复习。</p><hr><h2>关于栈、队列和递归的几个必知必会的代码实现</h2><h3>栈</h3><ul>\n<li>\n<p>用数组实现一个顺序栈</p>\n</li>\n<li>\n<p>用链表实现一个链式栈</p>\n</li>\n<li>\n<p>编程模拟实现一个浏览器的前进、后退功能</p>\n</li>\n</ul><h3>队列</h3><ul>\n<li>\n<p>用数组实现一个顺序队列</p>\n</li>\n<li>\n<p>用链表实现一个链式队列</p>\n</li>\n<li>\n<p>实现一个循环队列</p>\n</li>\n</ul><h3>递归</h3><ul>\n<li>\n<p>编程实现斐波那契数列求值f(n)=f(n-1)+f(n-2)</p>\n</li>\n<li>\n<p>编程实现求阶乘n!</p>\n</li>\n<li>\n<p>编程实现一组数据集合的全排列</p>\n</li>\n</ul><h2>对应的LeetCode练习题（@Smallfly 整理）</h2><h3>栈</h3><ul>\n<li>Valid Parentheses（有效的括号）</li>\n</ul><p>英文版：<a href=\"https://leetcode.com/problems/valid-parentheses/\">https://leetcode.com/problems/valid-parentheses/</a></p><p>中文版：<a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">https://leetcode-cn.com/problems/valid-parentheses/</a></p><ul>\n<li>Longest Valid Parentheses（最长有效的括号）</li>\n</ul><p>英文版：<a href=\"https://leetcode.com/problems/longest-valid-parentheses/\">https://leetcode.com/problems/longest-valid-parentheses/</a></p><!-- [[[read_end]]] --><p>中文版：<a href=\"https://leetcode-cn.com/problems/longest-valid-parentheses/\">https://leetcode-cn.com/problems/longest-valid-parentheses/</a></p><ul>\n<li>Evaluate Reverse Polish Notatio（逆波兰表达式求值）</li>\n</ul><p>英文版：<a href=\"https://leetcode.com/problems/evaluate-reverse-polish-notation/\">https://leetcode.com/problems/evaluate-reverse-polish-notation/</a></p><p>中文版：<a href=\"https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/\">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/</a></p><h3>队列</h3><ul>\n<li>Design Circular Deque（设计一个双端队列）</li>\n</ul><p>英文版：<a href=\"https://leetcode.com/problems/design-circular-deque/\">https://leetcode.com/problems/design-circular-deque/</a></p><p>中文版：<a href=\"https://leetcode-cn.com/problems/design-circular-deque/\">https://leetcode-cn.com/problems/design-circular-deque/</a></p><ul>\n<li>Sliding Window Maximum（滑动窗口最大值）</li>\n</ul><p>英文版：<a href=\"https://leetcode.com/problems/sliding-window-maximum/\">https://leetcode.com/problems/sliding-window-maximum/</a></p><p>中文版：<a href=\"https://leetcode-cn.com/problems/sliding-window-maximum/\">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><h3>递归</h3><ul>\n<li>Climbing Stairs（爬楼梯）</li>\n</ul><p>英文版：<a href=\"https://leetcode.com/problems/climbing-stairs/\">https://leetcode.com/problems/climbing-stairs/</a></p><p>中文版：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">https://leetcode-cn.com/problems/climbing-stairs/</a></p><hr><p>昨天的第一篇，是关于数组和链表的，如果你错过了，点击文末的“<span class=\"orange\">上一篇</span>”，即可进入测试。</p><p>祝你取得好成绩！明天见！</p>","neighbors":{"left":{"article_title":"春节7天练 | Day 1：数组和链表","id":80456},"right":{"article_title":"春节7天练 | Day 3：排序和二分查找","id":80458}},"comments":[{"had_liked":false,"id":65459,"user_name":"李皮皮皮皮皮","can_delete":false,"product_type":"c1","uid":1200281,"ip_address":"","ucode":"3BF1DEE4A12359","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/99/44378317.jpg","comment_is_top":false,"comment_ctime":1549372936,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"44499045896","product_id":100017301,"comment_content":"基础数据结构和算法是基石，灵活运用是解题的关键。栈，队列这些数据结构说到底就是给顺序表添加约束，更便于解决某一类问题。学习中培养算法的设计思想是非常关键的。而且思想是可以通用的。之前读《暗时间》一书，收获颇深。书中介绍之正推反推我在做程序题时竟出奇的好用。","like_count":11,"discussions":[{"author":{"id":1128420,"avatar":"https://static001.geekbang.org/account/avatar/00/11/37/e4/5d7a32c6.jpg","nickname":"creasylai19","note":"","ucode":"F9B04060FCFD3F","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582475,"discussion_content":"《暗时间》那本书我也觉得收获很大，哈哈。好多年前看的了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659440938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66080,"user_name":"Abner","can_delete":false,"product_type":"c1","uid":1191257,"ip_address":"","ucode":"F8D34433833D7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/59/b515a473.jpg","comment_is_top":false,"comment_ctime":1549872734,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14434774622","product_id":100017301,"comment_content":"java用数组实现一个顺序栈<br>代码如下：<br>package stack;<br><br>public class ArrayStack {<br><br>    private String[] data;<br>    private int count;<br>    private int size;<br><br>    public ArrayStack(int n) {<br>        this.data = new String[n];<br>        this.count = 0;<br>        this.size = n;<br>    }<br>    <br>    public boolean push(String value) {<br>        if (count == size) {<br>            return false;<br>        } else {<br>            data[count] = value;<br>            count++;<br>            return true;<br>        }<br>    }<br><br>    public String pop() {<br>        if (count == 0) {<br>            return null;<br>        } else {<br>            count--;<br>            return data[count];<br>        }<br>    }<br>}<br>","like_count":3},{"had_liked":false,"id":66098,"user_name":"Abner","can_delete":false,"product_type":"c1","uid":1191257,"ip_address":"","ucode":"F8D34433833D7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/59/b515a473.jpg","comment_is_top":false,"comment_ctime":1549877054,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10139811646","product_id":100017301,"comment_content":"java用递归实现斐波那契数列<br>代码如下：<br>package recursion;<br><br>public class Fib {<br><br>    public long calFib(long n) {<br>        if (n == 0 || n == 1) {<br>            return 1;<br>        } else {<br>            return calFib(n - 1) + calFib(n - 2);<br>        }<br>    }<br>    <br>    public static void main(String[] args) {<br>        Fib fib = new Fib();<br>        long result = fib.calFib(5);<br>        System.out.println(result);<br>    }<br>}<br>","like_count":2},{"had_liked":false,"id":66016,"user_name":"kai","can_delete":false,"product_type":"c1","uid":1018452,"ip_address":"","ucode":"443ED92B59AB8C","user_header":"","comment_is_top":false,"comment_ctime":1549851920,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10139786512","product_id":100017301,"comment_content":"1. 编程实现斐波那契数列求值 f(n)=f(n-1)+f(n-2）<br>public class Fibonacci {<br>    public static int fib(int n) {<br>        if (n &lt;= 0) {<br>            return 0;<br>        }<br>        if (n == 1) {<br>            return 1;<br>        }<br><br>        return  fib(n-1) + fib(n-2);<br>    }<br>}<br><br>2. Climbing Stairs（爬楼梯）<br>public class ClimbStairs {<br>    public int climbFloor(int n) {<br>        if (n == 1 || n == 2) {<br>            return n;<br>        }<br><br>        return climbFloor(n - 1) + climbFloor(n - 2);<br>    }<br><br>    public int climbFloorIter(int n) {<br>        if (n == 1 || n == 2) {<br>            return n;<br>        }<br><br>        int jump1 = 1;<br>        int jump2 = 2;<br>        int jumpN = 0;<br><br>        for (int i = 3; i &lt;= n; i++) {<br>            jumpN = jump1 + jump2;<br><br>            jump1 = jump2;<br>            jump2 = jumpN;<br>        }<br><br>        return jumpN;<br>    }<br>}<br><br>3. Sliding Window Maximum（滑动窗口最大值)<br>import java.util.ArrayList;<br>import java.util.LinkedList;<br><br>public class MaxNumOfSlidingWindow {<br>    public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size)<br>    {<br>        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();<br><br>        if (num == null || num.length &lt;= 0 || size &lt;= 0 || size &gt; num.length) {<br>            return res;<br>        }<br><br>        LinkedList&lt;Integer&gt; qMax = new LinkedList&lt;&gt;();  &#47;&#47; 双端队列：左端更新max,右端添加数据<br><br>        int left = 0;<br><br>        for (int right = 0; right &lt; num.length; right++) {<br>            &#47;&#47; 更新右端数据<br>            while (!qMax.isEmpty() &amp;&amp; num[qMax.peekLast()] &lt;= num[right]) {<br>                qMax.pollLast();<br>            }<br><br>            qMax.addLast(right);<br><br>            &#47;&#47; 更新max：如果max的索引不在窗口内,则更新<br>            if (qMax.peekFirst() == right - size) {<br>                qMax.pollFirst();<br>            }<br><br>            &#47;&#47; 待窗口达到size，输出max<br>            if (right &gt;= size-1) {<br>                res.add(num[qMax.peekFirst()]);<br>                left++;<br>            }<br>        }<br><br>        return res;<br>    }<br>}","like_count":2},{"had_liked":false,"id":168309,"user_name":"何沛","can_delete":false,"product_type":"c1","uid":1477145,"ip_address":"","ucode":"5673C580982710","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/19/a54761af.jpg","comment_is_top":false,"comment_ctime":1578044975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5873012271","product_id":100017301,"comment_content":"用数组实现一个顺序队列<br>&#47;**<br> * @author hepei<br> * @date 2020&#47;1&#47;3 17:12<br> **&#47;<br>public class ArrayQueue {<br><br>    private int[] data;<br>    private int head;<br>    private int tail;<br><br>    public ArrayQueue(int[] data) {<br>        this.data = data;<br>    }<br><br>    <br>    public void enqueue(int v) {<br>        if (tail == data.length &amp;&amp; head == 0) {<br>            return;<br>        }<br>        if (tail == data.length &amp;&amp; head &gt; 0) {<br>            for (int i = 0; i &lt; tail - head; i++) {<br>                data[i] = data[i + head];<br>            }<br>            tail = tail - head;<br>            head = 0;<br>        }<br>        data[tail] = v;<br>        tail++;<br>    }<br><br>    public int dequeue() {<br>        if (tail == 0||head==tail) {<br>            return -1;<br>        }<br>        int r = data[head];<br>        head++;<br>        return r;<br>    }<br><br>    public void display() {<br>        for (int i = head; i &lt; tail; i++) {<br>            System.out.print( data[i] + &quot; &quot; );<br>        }<br>    }<br><br>    public static void main(String[] args) {<br>        ArrayQueue queue = new ArrayQueue( new int[5] );<br>        queue.enqueue( 1 );<br>        queue.enqueue( 2 );<br>        queue.enqueue( 3 );<br>        queue.enqueue( 4 );<br>        queue.enqueue( 5 );<br>        queue.dequeue();<br>        queue.dequeue();<br>        queue.dequeue();<br>        queue.dequeue();<br>        queue.enqueue( 6 );<br>        queue.enqueue( 7 );<br>        queue.display();<br>    }<br><br>}","like_count":0},{"had_liked":false,"id":66508,"user_name":"Abner","can_delete":false,"product_type":"c1","uid":1191257,"ip_address":"","ucode":"F8D34433833D7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/59/b515a473.jpg","comment_is_top":false,"comment_ctime":1549950391,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5844917687","product_id":100017301,"comment_content":"java用链表实现一个链式栈<br>代码如下：<br>package stack;<br><br>public class LinkedStack {<br>    <br>    private Node top = null;<br>    <br>    public static class Node {<br>        <br>        private String data;<br>        private Node next;<br>        <br>        public Node(String data, Node next) {<br>            this.data = data;<br>            this.next = next;<br>        }<br>        <br>        public String getData() {<br>            return data;<br>        }<br>    }<br>    <br>    public void push(String item) {<br>        Node newNode = new Node(item, null);<br>        if (top == null) {<br>            top = newNode;<br>        } else {<br>            newNode.next = top;<br>            top = newNode;<br>        }<br>    }<br>    <br>    public String pop() {<br>        if (top == null) {<br>            return null;<br>        }<br>        String value = top.data;<br>        top = top.next;<br>        return value;<br>    }<br>    <br>    public void printAll() {<br>        Node pNode = top;<br>        while (pNode != null) {<br>            System.out.print(pNode.data + &quot; &quot;);<br>            pNode = pNode.next;<br>        }<br>        System.out.println();<br>    }<br>    <br>    public static void main(String[] args) {<br>        LinkedStack linkedStack = new LinkedStack();<br>        linkedStack.push(&quot;haha&quot;);<br>        linkedStack.push(&quot;nihao&quot;);<br>        linkedStack.printAll();<br>    }<br>}<br>","like_count":1},{"had_liked":false,"id":66091,"user_name":"Abner","can_delete":false,"product_type":"c1","uid":1191257,"ip_address":"","ucode":"F8D34433833D7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/59/b515a473.jpg","comment_is_top":false,"comment_ctime":1549876050,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5844843346","product_id":100017301,"comment_content":"java用递归实现求解n!<br>代码如下：<br>package recursion;<br><br>public class Fac {<br><br>    public long calFac(long n) {<br>        if (n == 0) {<br>            return 1;<br>        } <br>        return calFac(n - 1) * n;<br>    }<br><br>    public static void main(String[] args) {<br>        Fac fac = new Fac();<br>        long result = fac.calFac(10);<br>        System.out.println(result);<br>    }<br>}","like_count":2},{"had_liked":false,"id":66087,"user_name":"Abner","can_delete":false,"product_type":"c1","uid":1191257,"ip_address":"","ucode":"F8D34433833D7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/59/b515a473.jpg","comment_is_top":false,"comment_ctime":1549875058,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5844842354","product_id":100017301,"comment_content":"java用数组实现一个顺序队列<br>代码如下：<br>package queue;<br><br>public class ArrayQueue {<br>    <br>    private String[] data;<br>    private int size;<br>    private int head;<br>    private int tail;<br>    <br>    public ArrayQueue(int capacity) {<br>        data = new String[capacity];<br>        size = capacity;<br>        head = 0;<br>        tail = 0;<br>    }<br>    <br>    public boolean enqueue(String value) {<br>        if (tail == size) {<br>            return false;<br>        }<br>        data[tail] = value;<br>        tail++;<br>        return true;<br>    }<br><br>    public String dequeue() {<br>        if (tail == 0) {<br>            return null;<br>        }<br>        String value = data[head];<br>        head++;<br>        return value;<br>    }<br>}<br>","like_count":1},{"had_liked":false,"id":65726,"user_name":"ALAN","can_delete":false,"product_type":"c1","uid":1240164,"ip_address":"","ucode":"70E3B1C730E63F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/64/7403c694.jpg","comment_is_top":false,"comment_ctime":1549606477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5844573773","product_id":100017301,"comment_content":"import java.util.Arrays;<br><br>&#47;**<br> * <br> *Stack 1 solution<br> *&#47;<br>public class StackArray {<br><br>\tpublic Object[] arr = new Object[10];<br>\tpublic int count;<br><br>\tpublic void push(Object ele) {<br>\t\tif (count == arr.length) { &#47;&#47; expand size<br>\t\t\tarr = Arrays.copyOf(arr, arr.length * 2);<br>\t\t}<br>\t\tarr[count] = ele;<br>\t\tcount++;<br>\t}<br><br>\tpublic Object pop() {<br>\t\tif (count == 0)<br>\t\t\treturn null;<br>\t\tif (count &lt; arr.length &#47; 2) {<br>\t\t\tarr = Arrays.copyOf(arr, arr.length &#47; 2);<br>\t\t}<br>\t\treturn arr[--count];<br><br>\t}<br>}<br><br>&#47;**<br> * <br> *Stack 2 solution<br> *&#47;<br>class StackLinked {<br>\tNode head;<br>\tNode tail;<br><br>\tpublic void push(Object ele) {<br><br>\t\tif (head == null) {<br>\t\t\thead = new Node(ele);<br>\t\t\ttail = head;<br>\t\t} else {<br>\t\t\tNode node = new Node(ele);<br>\t\t\ttail.next = node;<br>\t\t\tnode.prev = tail;<br>\t\t\ttail = node;<br>\t\t}<br>\t}<br><br>\tpublic Object pop() {<br>\t\tif (tail == null)<br>\t\t\treturn null;<br>\t\tNode node = tail;<br>\t\tif (tail == head) {<br>\t\t\thead = null;<br>\t\t\ttail = null;<br>\t\t} else<br>\t\t\ttail = tail.prev;<br>\t\treturn node;<br><br>\t}<br>}<br>class Node {<br>\tNode prev;<br>\tNode next;<br>\tObject value;<br><br>\tpublic Node(Object ele) {<br>\t\tvalue = ele;<br>\t}<br>}","like_count":1},{"had_liked":false,"id":65539,"user_name":"TryTs","can_delete":false,"product_type":"c1","uid":1036276,"ip_address":"","ucode":"1DD1E974D461A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/f4/26b95f0b.jpg","comment_is_top":false,"comment_ctime":1549438159,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5844405455","product_id":100017301,"comment_content":"之前有个类似的题，走楼梯，装苹果，就是把苹果装入盘子，可以分为有一个盘子为空（递归），和全部装满没有空的情况，找出状态方程，递归就可以列出来了。我觉得最关键是要列出状态方程，之前老师类似于说的不需要关注特别细节，不要想把每一步都要想明白，快速排序与递归排序之类的算法，之前总是想把很细节的弄懂，却发现理解有困难。","like_count":1},{"had_liked":false,"id":278967,"user_name":"风行者","can_delete":false,"product_type":"c1","uid":2311468,"ip_address":"","ucode":"711C6964AE936C","user_header":"https://static001.geekbang.org/account/avatar/00/23/45/2c/1916cf2f.jpg","comment_is_top":false,"comment_ctime":1613489670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613489670","product_id":100017301,"comment_content":"递归写法的话简单加一层缓存就可以有很大的性能提升了，不用动态规划也可以做<br>class Solution:<br>    cache = {}<br>    def climbStairs(self, n: int) -&gt; int:<br>        if self.cache.__contains__(n):<br>            return self.cache[n]<br>        else:<br>            self.cache[n]=(self.climbStairs(n-2)+self.climbStairs(n-1) if n&gt;2 else n)<br>            return self.cache[n]","like_count":0},{"had_liked":false,"id":140269,"user_name":"Hxz","can_delete":false,"product_type":"c1","uid":1493253,"ip_address":"","ucode":"AF2DC1F6B2D7BC","user_header":"","comment_is_top":false,"comment_ctime":1570867653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570867653","product_id":100017301,"comment_content":"我用js写的题解都放在了https:&#47;&#47;github.com&#47;abchexuzheng&#47;algorithm-for-js这里，前端学算法的小伙伴们可以看看一起学习下哈","like_count":0},{"had_liked":false,"id":132524,"user_name":"Geek_18b741","can_delete":false,"product_type":"c1","uid":1368496,"ip_address":"","ucode":"097BA0C2F44150","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlztvlBgajZMEph8AvkP2pfoqNCGtYSalIKgrCbCg0MWDZJgJwqVRfWA6cgIoZicL6dKibfK0zjsWg/132","comment_is_top":false,"comment_ctime":1568161292,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568161292","product_id":100017301,"comment_content":"再做Climbing Stairs这个题目的时候，提交了两个版本的代码。理论上来说内存应该是有区别的，但是LeetCode给的结果，内存大小却没有什么区别。请帮忙看看。<br>&#47;**<br>     * 动态规划<br>     * @param n<br>     * @return<br>     *&#47;<br>    public int climbStairsV3(int n) {<br>        if(n==1) return 1;<br>        int[] dp = new int[n+1];<br>        dp[1]=1;<br>        dp[2]=2;<br>        for(int i=3;i&lt;=n;i++){<br>            dp[i]=dp[i-1]+dp[i-2];<br>        }<br>        return dp[n];<br>    }<br><br>    &#47;**<br>     * 节省内存的动态规划，但实际LeetCode反馈出来的内存并不少<br>     * @param n<br>     * @return<br>     *&#47;<br>    public int climbStairsV4(int n) {<br>        if(n==1) return 1;<br>        int num1 =1;<br>        int num2 =2;<br>        int num3=0;<br>        for(int i=3;i&lt;=n;i++){<br>            num3=num1+num2;<br>            num1=num2;<br>            num2=num3;<br>        }<br>        return num2;<br>    }","like_count":0},{"had_liked":false,"id":127872,"user_name":"猫猫","can_delete":false,"product_type":"c1","uid":1518041,"ip_address":"","ucode":"46E5356348DA36","user_header":"https://static001.geekbang.org/account/avatar/00/17/29/d9/4358d6fb.jpg","comment_is_top":false,"comment_ctime":1566802966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566802966","product_id":100017301,"comment_content":"全排列js <br>&#47;&#47;9.一组数据集合的全排列 回溯（暴力枚举）<br>let count = 1<br><br>function permutation(nums, result = []) {<br>  if (nums.length == 0) {<br>    console.log(`${count}:${result}`)<br>    count++<br>    return<br>  }<br>  for (let i = 0; i &lt; nums.length; i++) {<br>    permutation(nums.filter((value, index) =&gt; index != i), [...result, nums[i]])<br>  }<br>}","like_count":0},{"had_liked":false,"id":96725,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1558493484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558493484","product_id":100017301,"comment_content":"练完打卡","like_count":0},{"had_liked":false,"id":69181,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1550674102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550674102","product_id":100017301,"comment_content":"有意思, 递归的 LeeCode 题目, 使用简单粗暴的回溯法并没有办法通过, 还是得使用动态规划求解","like_count":0},{"had_liked":false,"id":68634,"user_name":"hopeful","can_delete":false,"product_type":"c1","uid":1187507,"ip_address":"","ucode":"EF02AFDD93589E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg","comment_is_top":false,"comment_ctime":1550563342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550563342","product_id":100017301,"comment_content":"#一组数据集合的全排列<br>def f(start , b):<br>    a = list(b)<br>    if start==len(a):<br>        print(b)<br>    else:<br>        for i in range(start , len(a)):<br>            a[start] , a[i] = a[i] , a[start]<br>            c = tuple(a)<br>            f(start+1 , c)<br>            a[start] , a[i] = a[i] , a[start]","like_count":0},{"had_liked":false,"id":67757,"user_name":"hopeful","can_delete":false,"product_type":"c1","uid":1187507,"ip_address":"","ucode":"EF02AFDD93589E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg","comment_is_top":false,"comment_ctime":1550242844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550242844","product_id":100017301,"comment_content":"#实现快速排序、归并排序<br>#---------快排(三数取中)---------<br>def QuickSort():<br>    array = Array(10000)<br>    qsort(0 , len(array)-1 , array)<br>    return array<br>def qsort(start , end , array):<br>    if start &lt; end:<br>        key = partation(array , start , end)<br>        qsort(start , key-1 , array)<br>        qsort(key+1 , end , array)<br>def swap(array , start , end):<br>    temp = array[start]<br>    array[start] = array[end]<br>    array[end] = temp<br>def change(array , start , mid , end):<br>    if array[start] &gt; array[mid]:<br>        swap(array , start , mid)<br>    if array[start]&gt;array[end]:<br>        swap(array , start , end)<br>    if array[mid] &gt; array[end]:<br>        swap(array , mid , end)<br>    swap(array , mid , start)<br>def partation(array , start , end):<br>    #mid = int((start+end)&#47;2)<br>    #change(array , start , mid , end)<br>    temp = array[start]<br>    while start &lt; end :<br>        while start&lt;end and array[end]&lt;=temp:<br>            end-=1<br>        swap(array , start , end)<br>        while start&lt;end and array[start]&gt;=temp:<br>            start+=1<br>        swap(array , start , end)<br>    return start<br>#---------------归并------------<br>def merge(a , b):<br>    c = []<br>    i = 0<br>    j = 0<br>    while i&lt;len(a) and j&lt;len(b):<br>        if a[i] &gt; b[j]:<br>            c.append(a[i])<br>            i+=1<br>        else:<br>            c.append(b[j])<br>            j+=1<br>    if i&gt;=len(a):<br>        for k in range(j , len(b)):<br>            c.append(b[k])<br>    if j&gt;=len(b):<br>        for k in range(i , len(a)):<br>            c.append(a[k])<br>    return c<br>def devide(array):<br>    if len(array) == 1:<br>        return array<br>    else:<br>        mid = int((0 + len(array)) &#47; 2)<br>        leftArray = devide(array[0:mid])<br>        rightArray = devide(array[mid:len(array)])<br>        return merge(leftArray , rightArray)<br>def mergesort():<br>    array = Array(100)<br>    m = devide(array)<br>    return m","like_count":0},{"had_liked":false,"id":67754,"user_name":"hopeful","can_delete":false,"product_type":"c1","uid":1187507,"ip_address":"","ucode":"EF02AFDD93589E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg","comment_is_top":false,"comment_ctime":1550242666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550242666","product_id":100017301,"comment_content":"#冒泡、选择、插入排序<br>import random<br>import time<br>def Array(n):<br>    a = []<br>    for i in range(n):<br>        a.append(random.randint(0 , n))<br>    return a<br>#插入排序<br>def insert():<br>    array = Array(100)<br>    time_start=time.time()<br>    for i in range(1 , len(array)):<br>        for j in range(i , 0 , -1):<br>            if array[j] &gt; array[j-1]:<br>                temp = array[j]<br>                array[j] = array[j-1]<br>                array[j-1] = temp<br>            else:<br>                break<br>    time_end=time.time()<br>    print(array)<br>    print(&#39;totally cost&#39;,time_end-time_start)<br>def select():<br>    array = Array(100)<br>    time_start=time.time()<br>    for i in range(len(array)):<br>        for j in range(i+1 , len(array)):<br>            if array[j] &gt; array[i]:<br>                temp = array[j]<br>                array[j] = array[i]<br>                array[i] = temp<br>    time_end=time.time()<br>    print(array)<br>    print(&#39;totally cost&#39;,time_end-time_start)<br>def bubble():<br>    array = Array(100)<br>    time_start=time.time()<br>    for i in range(len(array)-1 , 0 , -1):<br>        flag = False<br>        for j in range(i):<br>            if array[j] &gt; array[j+1]:<br>                temp = array[j]<br>                array[j] = array[j+1]<br>                array[j+1] = temp<br>                flag = True<br>        if not flag:<br>            break<br>    time_end=time.time()<br>    print(array)<br>    print(&#39;totally cost&#39;,time_end-time_start)","like_count":0},{"had_liked":false,"id":67562,"user_name":"hopeful","can_delete":false,"product_type":"c1","uid":1187507,"ip_address":"","ucode":"EF02AFDD93589E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg","comment_is_top":false,"comment_ctime":1550197670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550197670","product_id":100017301,"comment_content":"&#47;&#47;阶乘n!<br>def f(n):<br>    if(n&lt;=1):<br>        return 1<br>    else:<br>        return f(n-1)*n","like_count":0},{"had_liked":false,"id":67561,"user_name":"hopeful","can_delete":false,"product_type":"c1","uid":1187507,"ip_address":"","ucode":"EF02AFDD93589E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg","comment_is_top":false,"comment_ctime":1550197244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550197244","product_id":100017301,"comment_content":"&#47;&#47;斐波那契数列<br>def f(n):<br>    if(n&lt;=0):<br>        return 0<br>    elif(n==1):<br>        return 1<br>    else:<br>        return f(n-1)+f(n-2)","like_count":0},{"had_liked":false,"id":67558,"user_name":"hopeful","can_delete":false,"product_type":"c1","uid":1187507,"ip_address":"","ucode":"EF02AFDD93589E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg","comment_is_top":false,"comment_ctime":1550196846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550196846","product_id":100017301,"comment_content":"&#47;&#47;数组实现顺序队列<br>public class MyQueue {<br>\t<br>\tprivate Object[] object;<br>\tprivate int count;<br>\t<br>\tMyQueue(int size){<br>\t\tthis.object = new Object[size];<br>\t\tcount = 0;<br>\t}<br><br>\t@Override<br>\tpublic Object pop() {<br>\t\t&#47;&#47; TODO Auto-generated method stub<br>\t\tif(count==0) {<br>\t\t\treturn null;<br>\t\t}else {<br>\t\t\tObject temp = object[0];<br>\t\t\tcount--;<br>\t\t\tfor (int i = object.length-1; i &gt; 0 ; i--) {<br>\t\t\t\tobject[i-1] = object[i];<br>\t\t\t}<br>\t\t\treturn temp;<br>\t\t}<br>\t}<br><br>\t@Override<br>\tpublic void push(Object h) {<br>\t\t&#47;&#47; TODO Auto-generated method stub<br>\t\tif( (count+1) &gt;= object.length) {<br>\t\t\tObject[] ob = new Object[2*object.length];<br>\t\t\tSystem.arraycopy(object, 0, ob, 0, count);<br>\t\t\tthis.object = ob;<br>\t\t}<br>\t\tobject[count] = h;<br>\t\tcount++;<br>\t}<br><br>\t@Override<br>\tpublic Object getFirst() {<br>\t\t&#47;&#47; TODO Auto-generated method stub<br>\t\tif(count==0) <br>\t\t\treturn null;<br>\t\telse <br>\t\t\treturn object[0];<br>\t}<br><br>\t@Override<br>\tpublic Object getLast() {<br>\t\t&#47;&#47; TODO Auto-generated method stub<br>\t\tif(count==0) <br>\t\t\treturn null;<br>\t\telse <br>\t\t\treturn object[count-1];<br>\t}<br><br>\t@Override<br>\tpublic boolean empty() {<br>\t\t&#47;&#47; TODO Auto-generated method stub<br>\t\tif(count==0) {<br>\t\t\treturn true;<br>\t\t}else<br>\t\t\treturn false;<br>\t}<br><br>\t@Override<br>\tpublic int size() {<br>\t\t&#47;&#47; TODO Auto-generated method stub<br>\t\treturn count;<br>\t}<br><br>}<br>","like_count":0},{"had_liked":false,"id":67497,"user_name":"hopeful","can_delete":false,"product_type":"c1","uid":1187507,"ip_address":"","ucode":"EF02AFDD93589E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg","comment_is_top":false,"comment_ctime":1550162959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550162959","product_id":100017301,"comment_content":"&#47;&#47;用链表实现顺序栈<br>#include&lt;stdlib.h&gt;  <br>#define true        1  <br>#define false       0  <br>#define ok          1  <br>#define error       0  <br>#define infeasible  1  <br>#define overflow    0<br>#define stack_size  50  <br>typedef struct{  <br>    int *base;  <br>    int *top;  <br>    int stacksize;  <br>}sqstack;  <br><br>&#47;&#47;构造一个空栈  <br>int create_stack(sqstack *s)  <br>{  <br>    s-&gt;base=(int *)malloc(5*sizeof(int));  &#47;&#47;开始分配50个整形空间  <br>    if(!s-&gt;base) exit(overflow);  <br>    s-&gt;top=s-&gt;base;  <br>    s-&gt;stacksize=5;  <br>    return 0;  <br>}  <br><br>&#47;&#47;插入新元素为栈顶元素  <br>int stack_push(sqstack *s)  <br>{  <br>    int e;  <br>    if(s-&gt;top - s-&gt;base&gt;=5)<br>\t{                            &#47;&#47;栈满 ，追加存储空间  <br>        s-&gt;base = (int *)realloc(s-&gt;base,(5+1)*sizeof(int));  <br>    if(!s-&gt;base) exit(overflow);&#47;&#47;存储分配失败  <br>    s-&gt;top = s-&gt;base + 5;&#47;&#47;新扩充空间后的栈顶指针位置  <br>    s-&gt;stacksize += 1;  <br>    }  <br>    printf(&quot;请输入要入栈的值:&quot;);  <br>    scanf(&quot;%d&quot;,&amp;e);  <br>    *s-&gt;top++ = e;  <br>    return 0;  <br>}  <br><br>&#47;&#47;出栈  <br>int stack_pop(sqstack *s)  <br>{  <br>    if(s-&gt;base == s-&gt;top) {printf(&quot;栈为空！不能出栈！&quot;); return error;}  <br>    --s-&gt;top;  <br>    return 0;  <br>}  <br><br>&#47;&#47;打印栈  <br>int stack_top(sqstack *s)  <br>{  <br>    int *w;  <br>    printf(&quot;The stack is :&quot;);  <br>    w=s-&gt;base;  <br>    while(w!=s-&gt;top)<br>\t{  <br>        printf(&quot; %d   &quot;,*w++);  <br>    }  <br>    printf(&quot;\\n&quot;);  <br>}  ","like_count":0},{"had_liked":false,"id":67496,"user_name":"hopeful","can_delete":false,"product_type":"c1","uid":1187507,"ip_address":"","ucode":"EF02AFDD93589E","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/b3/25b7984c.jpg","comment_is_top":false,"comment_ctime":1550162811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550162811","product_id":100017301,"comment_content":"&#47;&#47;数组实现顺序栈<br>public class MyStack {<br>\tObject[] object;<br>\tprivate int count;<br>\tMyStack(int size){<br>\t\tthis.object = new Object[size];<br>\t\tcount = 0;<br>\t}<br>\tpublic void push(Object h) {<br>\t\tif( (count+1) &gt;= object.length) {<br>\t\t\tObject[] ob = new Object[2*object.length];<br>\t\t\tSystem.arraycopy(object, 0, ob, 0, count);<br>\t\t\tthis.object = ob;<br>\t\t}<br>\t\tobject[count] = h;<br>\t\tcount++;<br>\t}<br>\tpublic Object pop() {<br>\t\tif(count==0) {<br>\t\t\treturn null;<br>\t\t}else {<br>\t\t\tcount--;<br>\t\t\treturn object[count-1];<br>\t\t}<br>\t}<br>\tpublic Object peek() {<br>\t\tif(count==0) {<br>\t\t\treturn null;<br>\t\t}else {<br>\t\t\treturn object[count-1];<br>\t\t}<br>\t}<br>\tpublic void removeAll() {<br>\t\twhile(count!=0) {<br>\t\t\tthis.pop();<br>\t\t\tcount--;<br>\t\t}<br>\t}<br>\tpublic boolean empty() {<br>\t\tif(count==0) {<br>\t\t\treturn true;<br>\t\t}else<br>\t\t\treturn false;<br>\t}<br>\tpublic int getCount() {<br>\t\treturn this.count;<br>\t}","like_count":0},{"had_liked":false,"id":67254,"user_name":"TryTs","can_delete":false,"product_type":"c1","uid":1036276,"ip_address":"","ucode":"1DD1E974D461A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/f4/26b95f0b.jpg","comment_is_top":false,"comment_ctime":1550115670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550115670","product_id":100017301,"comment_content":"递归爬楼梯<br><br>#include&lt;iostream&gt;<br>using namespace std;<br>int floor(int n){<br>\tif(n == 0) return 1;<br>\telse if(n == 1) return 1;<br>\telse return floor(n - 1) + floor(n - 2);<br>}<br>int main(){<br>\tint n;<br>\tcin&gt;&gt;n;<br>\tcout&lt;&lt;floor(n)&lt;&lt;endl;<br>}","like_count":0},{"had_liked":false,"id":66650,"user_name":"Abner","can_delete":false,"product_type":"c1","uid":1191257,"ip_address":"","ucode":"F8D34433833D7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/59/b515a473.jpg","comment_is_top":false,"comment_ctime":1549974034,"is_pvip":true,"replies":[{"id":"24737","content":"感谢您参与春节七天练的活动，为了表彰你在活动中的优秀表现，赠送您99元专栏通用阅码，我们会在3个工作日之内完成礼品发放，如有问题请咨询小明同学，微信geektime002。","user_name":"编辑回复","user_name_real":"王锦","uid":"1058895","ctime":1550804341,"ip_address":"","comment_id":66650,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1549974034","product_id":100017301,"comment_content":"java实现一个循环队列<br>代码如下：<br>package queue;<br><br>public class CircularQueue {<br>    <br>    private String[] data;<br>    private int size;<br>    private int head;<br>    private int tail;<br>    <br>    public CircularQueue(int capacity) {<br>        data = new String[capacity];<br>        size = capacity;<br>        head = 0;<br>        tail = 0;<br>    }<br>    <br>    public boolean enqueue(String item) {<br>        if ((tail + 1) % size == head) {<br>            return false;<br>        }<br>        data[tail] = item;<br>        tail = (tail + 1) % size;<br>        return true;<br>    }<br><br>    public String dequeue() {<br>        if (head == tail) {<br>            return null;<br>        }<br>        String value = data[head];<br>        head = (head + 1) % size;<br>        return value;<br>    }<br><br>    public void printAll() {<br>        if (0 == size) {<br>            return ;<br>        }<br>        for (int i = head;i % size != tail;i++) {<br>            System.out.print(data[i] + &quot; &quot;);<br>        }<br>        System.out.println();<br>    }<br>    <br>    public static void main(String[] args) {<br>        CircularQueue circularQueue = new CircularQueue(5);<br>        circularQueue.enqueue(&quot;hello1&quot;);<br>        circularQueue.enqueue(&quot;hello2&quot;);<br>        circularQueue.enqueue(&quot;hello3&quot;);<br>        circularQueue.enqueue(&quot;hello4&quot;);<br>        circularQueue.dequeue();<br>        circularQueue.printAll();<br>    }<br>}<br>","like_count":0,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438855,"discussion_content":"感谢您参与春节七天练的活动，为了表彰你在活动中的优秀表现，赠送您99元专栏通用阅码，我们会在3个工作日之内完成礼品发放，如有问题请咨询小明同学，微信geektime002。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550804341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":66633,"user_name":"Abner","can_delete":false,"product_type":"c1","uid":1191257,"ip_address":"","ucode":"F8D34433833D7F","user_header":"https://static001.geekbang.org/account/avatar/00/12/2d/59/b515a473.jpg","comment_is_top":false,"comment_ctime":1549970996,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1549970996","product_id":100017301,"comment_content":"java实现一个链式队列<br>代码如下：<br>package queue;<br><br>public class LinkedQueue {<br>    <br>    private Node head = null;<br>    private Node tail = null;<br>    <br>    public static class Node {<br>        <br>        private String data;<br>        private Node next;<br>        <br>        public Node(String data, Node next) {<br>            this.data = data;<br>            this.next = next;<br>        }<br>        <br>        public String getData() {<br>            return data;<br>        }<br>    }<br>    <br>    public void enqueue(String item) {<br>        if (tail == null) {<br>            Node newNode = new Node(item, null);<br>            head = newNode;<br>            tail = newNode;<br>        } else {<br>            tail.next = new Node(item, null);<br>            tail = tail.next;<br>        }<br>        <br>    }<br><br>    public String dequeue() {<br>        if (head == null) {<br>            return null;<br>        } else {<br>            String value = head.data;<br>            head = head.next;<br>            if (head == null) {<br>                tail = null;<br>            }<br>            return value;<br>        }<br>    }<br><br>    public void printAll() {<br>        Node pNode = head;<br>        while (pNode != null) {<br>            System.out.print(pNode.data + &quot; &quot;);<br>            pNode = pNode.next;<br>        }<br>        System.out.println();<br>    }<br>    <br>    public static void main(String[] args) {<br>        LinkedQueue linkedQueue = new LinkedQueue();<br>        linkedQueue.enqueue(&quot;hello&quot;);<br>        linkedQueue.enqueue(&quot;nihao&quot;);<br>        linkedQueue.dequeue();<br>        linkedQueue.printAll();<br>    }<br><br>}<br>","like_count":0},{"had_liked":false,"id":65937,"user_name":"神盾局闹别扭","can_delete":false,"product_type":"c1","uid":1006804,"ip_address":"","ucode":"0255AEB1EE73FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/d4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1549784428,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549784428","product_id":100017301,"comment_content":"Valid parentheses c++实现<br><br>class Solution {<br>   <br>\tenum ParentheseStatus {<br>\t\tinvalid = 0,<br>\t\tsameTypeofParenthese = 1,<br>\t\tdifferentTypeofParenthese = 2<br>\t};<br>\tchar a[3] = {&#39;(&#39;, &#39;[&#39;, &#39;{&#39; };<br>\tchar b[3] = {&#39;)&#39;, &#39;]&#39;, &#39;}&#39; };<br><br>\tParentheseStatus Checkparenthese(char strStartParenthese, char strEndParenthese) {<br>\t\tint idx = 0;<br>\t\tfor (; idx &lt; 3; idx++)<br>\t\t{<br>\t\t\tif (strStartParenthese == a[idx])<br>\t\t\t\tbreak;<br>\t\t}<br>\t\tif (idx == 3)<br>\t\t\treturn invalid;<br>\t\treturn  (b[idx] == strEndParenthese)? sameTypeofParenthese: differentTypeofParenthese;<br>\t}<br>public:<br>\tbool isValid(string s) {<br><br>\t\tstack&lt;char&gt; st;<br>\t\tint len = s.length();<br>\t\tfor (int idx = 0; idx &lt; len; idx++)<br>\t\t{<br>\t\t\tif (!st.empty()) {<br>\t\t\t\tParentheseStatus emRt = Checkparenthese(st.top(), s[idx]);<br>\t\t\t\tif (invalid == emRt)<br>\t\t\t\t\treturn false;<br>\t\t\t\tif (sameTypeofParenthese == emRt) {<br>\t\t\t\t\tst.pop();<br>\t\t\t\t}<br>\t\t\t\telse<br>\t\t\t\t\tst.push(s[idx]);<br>\t\t\t}<br>\t\t\telse<br>\t\t\t\tst.push(s[idx]);<br>\t\t}<br><br>\t\treturn (st.empty() ? true : false);<br><br>\t}<br>};","like_count":0},{"had_liked":false,"id":65887,"user_name":"yingyingqin","can_delete":false,"product_type":"c1","uid":1244276,"ip_address":"","ucode":"D75A0C4DDC5F08","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQyP4WVaRJVZcYD5h0GhEgzdML1qGyDBibu21TsiaDHxBx8knCzrClsoh9ZZwjurLGgvsprP6QW9qQ/132","comment_is_top":false,"comment_ctime":1549724392,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549724392","product_id":100017301,"comment_content":"全排列 C++实现<br>void digui(vector&lt;int&gt; res, int i,vector&lt;int&gt; curres)<br>{<br>\tif (i == res.size())<br>\t{<br>\t\tfor (auto ci : curres)<br>\t\t\tcout &lt;&lt; ci &lt;&lt; &quot; &quot;;<br>\t\tcout &lt;&lt; endl;<br>\t\treturn;<br>\t}<br><br>\tfor (int k = i; k &lt; res.size(); k++)<br>\t{<br>\t\tint temp = res[k];<br>\t\tres[k] = res[i];<br>\t\tres[i] = temp;<br>\t\tcurres.push_back(res[i]);<br>\t\tdigui(res, i + 1,curres);<br>\t\tcurres.pop_back();<br>\t}<br>}<br><br>void quanpailie(vector&lt;int&gt; res)<br>{&#47;&#47;全排列<br>\tvector&lt;int&gt; curres;<br>\tdigui(res, 0, curres);<br>}<br><br>循环队列 C++实现<br>class cyclequeue{<br>public:<br>\tcyclequeue(){<br>\t}<br>\tbool insert(int num){<br>\t\tif ((curend+1)%100 == curfirst)<br>\t\t{<br>\t\t\tcout &lt;&lt; &quot;the queue all used.&quot; &lt;&lt; endl;<br>\t\t\treturn false;<br>\t\t}<br>\t\tarrque[curend] = num;<br>\t\tcurend = (curend + 1) % 100;<br>\t\treturn true;<br>\t}<br><br>\tint deque()<br>\t{<br>\t\tif (curfirst == curend)<br>\t\t{<br>\t\t\tcout &lt;&lt; &quot;there is nothing in queue.&quot; &lt;&lt; endl;<br>\t\t\treturn -1;<br>\t\t}<br>\t\telse<br>\t\t{<br>\t\t\tint temp = arrque[curfirst];<br>\t\t\tcurfirst = (curfirst + 1) % 100;<br>\t\t\treturn temp;<br>\t\t}<br>\t<br>\t}<br><br>private:<br>\tint arrque[100];&#47;&#47;申请一个大小为100的数组<br>\tint curfirst = 0;&#47;&#47;当前队列队头元素所在位置<br>\tint curend = 0;&#47;&#47;当前队列队尾元素所在位置<br>};<br>","like_count":0},{"had_liked":false,"id":65872,"user_name":"神盾局闹别扭","can_delete":false,"product_type":"c1","uid":1006804,"ip_address":"","ucode":"0255AEB1EE73FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/d4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1549712845,"is_pvip":false,"replies":[{"id":"24724","content":"感谢您参与春节七天练的活动，为了表彰你在活动中的优秀表现，赠送您99元专栏通用阅码，我们会在3个工作日之内完成礼品发放，如有问题请咨询小明同学，微信geektime002。","user_name":"编辑回复","user_name_real":"王锦","uid":"1058895","ctime":1550803944,"ip_address":"","comment_id":65872,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1549712845","product_id":100017301,"comment_content":"全排列实现：<br>void Dopermute(char *pstr, char *pBegin)<br>{<br>\tif (*pBegin == &#39;\\0&#39;)<br>\t\tprintf(&quot;%s\\n&quot;, pstr);<br><br>\tfor (char *pCur = pBegin; *pCur != &#39;\\0&#39;; pCur++)<br>\t{<br><br>\t\tchar temp = *pBegin;<br>\t\t*pBegin = *pCur;<br>\t\t*pCur = temp;<br><br>\t\tDopermute_v2(pstr, pBegin + 1);<br><br>\t\ttemp = *pBegin;<br>\t\t*pBegin = *pCur;<br>\t\t*pCur = temp;<br><br>\t}<br>}<br>void Permute(char* pstr)<br>{<br>\tif (pstr == nullptr)<br>\t\treturn;<br>\tDopermute(pstr, pstr);<br>}","like_count":0,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438620,"discussion_content":"感谢您参与春节七天练的活动，为了表彰你在活动中的优秀表现，赠送您99元专栏通用阅码，我们会在3个工作日之内完成礼品发放，如有问题请咨询小明同学，微信geektime002。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550803944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65852,"user_name":"molybdenum","can_delete":false,"product_type":"c1","uid":1251208,"ip_address":"","ucode":"DA24BDFCFF416C","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/88/be4fe19e.jpg","comment_is_top":false,"comment_ctime":1549701226,"is_pvip":false,"replies":[{"id":"24286","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550542043,"ip_address":"","comment_id":65852,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1549701226","product_id":100017301,"comment_content":"老师新年好 这是我的作业<br><br>https:&#47;&#47;blog.csdn.net&#47;github_38313296&#47;article&#47;details&#47;86819684","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438612,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550542043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65847,"user_name":"你看起来很好吃","can_delete":false,"product_type":"c1","uid":1188854,"ip_address":"","ucode":"F9079138EC3D7C","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/f6/1ef70cab.jpg","comment_is_top":false,"comment_ctime":1549699755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549699755","product_id":100017301,"comment_content":"爬楼梯python代码实现，需要使用散列表存储已经计算过的数字，这样可以降低时间复杂度，否则Leetcode会报超时错误：<br>class Solution:<br>    def __init__(self):<br>        self.buf = {1:1, 2:2}<br>        <br>    def climbStairs(self, n: &#39;int&#39;) -&gt; &#39;int&#39;:<br>        if n in self.buf:<br>            return self.buf[n]<br><br>        res = self.climbStairs(n-1) + self.climbStairs(n-2)<br>        self.buf[n] = res<br>        <br>        return res","like_count":0},{"had_liked":false,"id":65842,"user_name":"你看起来很好吃","can_delete":false,"product_type":"c1","uid":1188854,"ip_address":"","ucode":"F9079138EC3D7C","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/f6/1ef70cab.jpg","comment_is_top":false,"comment_ctime":1549697992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549697992","product_id":100017301,"comment_content":"设计双端队列python代码：<br>class MyCircularDeque:<br><br>    def __init__(self, k: &#39;int&#39;):<br>        self.data = [-1] * k<br>        self.capacity = k<br>        self.real_cap = 0<br>        self.__front, self.__rear = 0, 1<br><br>    def insertFront(self, value: &#39;int&#39;) -&gt; &#39;bool&#39;:<br>        if self.real_cap == self.capacity:<br>            return False    # deque is full now<br>        else:<br>            self.real_cap += 1<br>            self.data[self.__front] = value<br>            self.__front = (self.__front - 1 + self.capacity) % self.capacity<br>            <br>        return True<br>        <br><br>    def insertLast(self, value: &#39;int&#39;) -&gt; &#39;bool&#39;:<br>        if self.real_cap == self.capacity:<br>            return False<br>        else:<br>            self.real_cap += 1<br>            self.data[self.__rear] = value<br>            self.__rear = (self.__rear + 1 + self.capacity) % self.capacity<br>        <br>        return True<br>        <br><br>    def deleteFront(self) -&gt; &#39;bool&#39;:<br>        if self.isEmpty():<br>            return False<br>        else:<br>            self.real_cap -= 1<br>            self.__front = (self.__front + 1 + self.capacity) % self.capacity<br>            self.data[self.__front] = -1<br>        <br>        return True<br>        <br><br>    def deleteLast(self) -&gt; &#39;bool&#39;:<br>        if self.isEmpty():<br>            return False<br>        else:<br>            self.real_cap -= 1<br>            self.__rear = (self.__rear - 1 + self.capacity) % self.capacity<br>            self.data[self.__rear] = -1<br>        <br>        return True<br>        <br><br>    def getFront(self) -&gt; &#39;int&#39;:<br>        return self.data[(self.__front + 1 + self.capacity) % self.capacity]<br>        <br><br>    def getRear(self) -&gt; &#39;int&#39;:<br>        return self.data[(self.__rear - 1 + self.capacity) % self.capacity]<br>        <br><br>    def isEmpty(self) -&gt; &#39;bool&#39;:<br>        return self.real_cap == 0<br>        <br><br>    def isFull(self) -&gt; &#39;bool&#39;:<br>        return self.real_cap == self.capacity","like_count":0},{"had_liked":false,"id":65834,"user_name":"你看起来很好吃","can_delete":false,"product_type":"c1","uid":1188854,"ip_address":"","ucode":"F9079138EC3D7C","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/f6/1ef70cab.jpg","comment_is_top":false,"comment_ctime":1549693949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549693949","product_id":100017301,"comment_content":"逆波兰表达式python实现，时间复杂度O(n), 空间复杂度O(1)，<br><br>class Solution:<br>    def evalRPN(self, tokens: &#39;List[str]&#39;) -&gt; &#39;int&#39;:<br>        data = []<br><br>        opera = {&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;&#47;&#39;}<br>        for item in tokens:<br>            if item in opera:<br>                if item == &#39;+&#39;:<br>                    r = data.pop() + data.pop()<br>                    data.append(r)<br>                elif item == &#39;-&#39;:<br>                    a, b = data.pop(), data.pop()<br>                    data.append(b - a)<br>                elif item == &#39;*&#39;:<br>                    a, b = data.pop(), data.pop()<br>                    data.append(b * a)<br>                elif item == &#39;&#47;&#39;:<br>                    a, b = data.pop(), data.pop()<br>                    data.append(int(b &#47;a))<br>            else:<br>                data.append(int(item))<br><br><br>        return data.pop()","like_count":0},{"had_liked":false,"id":65823,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1549688413,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1549688413","product_id":100017301,"comment_content":"1.维护一个栈，顺序遍历括号序列，若与栈首括号匹配成功，则出栈并遍历下一个括号。遍历完毕后若栈为空则返回true。<br><br>2.我比较笨，用空间降低逻辑复杂度吧。申请长度为n的bool数组S，初始化全为false，记录匹配成功的情况。遍历括号字符串A，若当前字符与栈首对应的字符不匹配，或栈为空，则将字符在A数组中的下标入栈。若字符与栈首对应的字符匹配，则出栈，并将它们在A中下标对应S中的位置设置为true。遍历A结束后，再扫一遍S，输出连续true最长的位数。<br><br>3.读取字符，若为数字则入栈，若为运算符则连续出栈两次，根据运算符计算，将结果入栈。输出最终结果即可。<br><br>4.用数组实现循环双端队列。<br><br>5.每个窗口计算一次最大值，时间复杂度O（nk）。感觉有更好的方法，其实只要通过队列维护每个窗口的最大值，以及最大值右侧的次大值即可（实现细节需要打磨），这样时间复杂度为O（n）。<br><br>6.寻找递归公式<br>f（0）= 0；<br>f（1）= 1；<br>f（2）= 2；<br>f（3）= 2+1；<br>f（n）= f（n-1）+ f（n-2）；｛n大于2｝","like_count":0},{"had_liked":false,"id":65733,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1549609663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549609663","product_id":100017301,"comment_content":"package com.jxyang.test.geek.day2;<br>&#47;&#47;爬梯子、斐波那契数列<br>class Solution {<br>    public int climbStairs(int n) {<br>        if(n&lt;=0){<br>            return 0;<br>        }else if(n&lt;2){<br>            return 1;<br>        }<br>        int[] status = new int[n+1];<br>        status[0]=1;<br>        status[1]=1;<br>        for(int i =2;i&lt;=n;i++){<br>            status[i] = status[i-1]+status[i-2];<br>        }<br>        return status[n];<br>    }<br><br>    public static void main(String[] args) {<br>        Solution solution = new Solution();<br>        System.out.println(solution.climbStairs(2));<br>        System.out.println(solution.climbStairs(3));<br><br>    }<br>}","like_count":0},{"had_liked":false,"id":65680,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1549556053,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549556053","product_id":100017301,"comment_content":"全排列<br>import java.util.ArrayList;<br>import java.util.List;<br><br>&#47;&#47;全排列<br>public class FullPermutation {<br>    public static void main(String[] args) {<br>        FullPermutation full = new FullPermutation();<br>        int[] arr = {1,2,3,4};<br>        full.printAllSort(arr);<br>    }<br><br>    public void printAllSort(int[] arr) {<br>        if(arr==null || arr.length==0){<br>            return;<br>        }<br>        if(arr.length==1){<br>            System.out.println(arr[0]);<br>        }<br><br>        List&lt;List&lt;Integer&gt;&gt; result = _printAllSort(arr);<br>        for(List list :result){<br>            System.out.println(list);<br>        }<br>    }<br><br>    private List&lt;List&lt;Integer&gt;&gt; _printAllSort(int[] tmpArr) {<br>        &#47;&#47;结束条件<br>        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();<br>        if(tmpArr.length==2){<br>            List&lt;Integer&gt; subList = new ArrayList&lt;&gt;();<br>            List&lt;Integer&gt; subList2 = new ArrayList&lt;&gt;();<br>            subList.add(tmpArr[0]);<br>            subList.add(tmpArr[1]);<br>            subList2.add(tmpArr[1]);<br>            subList2.add(tmpArr[0]);<br>            result.add(subList);<br>            result.add(subList2);<br>            return result;<br>        }<br>        &#47;&#47;当前层处理<br>        for(int i=0;i&lt;tmpArr.length;i++){<br>            &#47;&#47;顺序拿出一个参数，其余交给下一层处理<br>            int tmp = tmpArr[i];<br>            int[] arr = new int[tmpArr.length - 1];<br>            int offset = 0;<br>            for(int j=0;j&lt;tmpArr.length;j++){<br>                if(i!=j){<br>                    arr[offset] = tmpArr[j];<br>                    offset++;<br>                }<br>            }<br>            List&lt;List&lt;Integer&gt;&gt; nextLevelResult = _printAllSort(arr);<br>            &#47;&#47;处理下一层结果（当前值加到结果的前面、后面）<br>            for(List&lt;Integer&gt; nextList:nextLevelResult){<br>                List&lt;Integer&gt; appendList = new ArrayList&lt;&gt;();<br>                appendList.add(tmp);<br>                appendList.addAll(nextList);<br>                result.add(appendList);<br>           &#47;*     nextList.add(tmp);<br>                result.add(nextList);*&#47;<br><br>            }<br>        }<br>        return result;<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":65679,"user_name":"你看起来很好吃","can_delete":false,"product_type":"c1","uid":1188854,"ip_address":"","ucode":"F9079138EC3D7C","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/f6/1ef70cab.jpg","comment_is_top":false,"comment_ctime":1549555943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549555943","product_id":100017301,"comment_content":"有效的括号python代码实现：<br>class Solution:<br>    def isValid(self, s):<br>        &quot;&quot;&quot;<br>        :type s: str<br>        :rtype: bool<br>        &quot;&quot;&quot;<br>        stack = []<br>        paren_map = {&#39;)&#39;:&#39;(&#39;, &#39;]&#39;:&#39;[&#39;, &#39;}&#39;:&#39;{&#39;}<br>        <br>        for item in s:<br>            if item in [&#39;(&#39;, &#39;[&#39;, &#39;{&#39;]:<br>                stack.append(item)<br>            else:<br>                if not stack:<br>                    return False<br>                elif paren_map[item] != stack.pop():<br>                    return False<br>        return not stack<br><br>这题使用栈是没有问题的，我觉得最巧妙的一点就是对匹配的符号建立字典，通过字典去栈里查找，这样效率最高","like_count":0},{"had_liked":false,"id":65587,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1549465356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549465356","product_id":100017301,"comment_content":"package com.jxyang.test.geek.day2;<br>&#47;&#47;链表实现栈<br>public class LinkStock&lt;T&gt; {<br>    private Node&lt;T&gt; head;<br>    public static void main(String[] args) {<br>        LinkStock&lt;Integer&gt; stock = new LinkStock&lt;Integer&gt;();<br>        stock.push(1).push(2).push(3).push(4).push(5);<br>        Integer tmp =null;<br>        while ((tmp = stock.pop())!=null){<br>            System.out.println(tmp);<br>        }<br>    }<br>    public LinkStock&lt;T&gt; push(T val){<br>        if(val!=null){<br>            Node tmp = new Node(val);<br>            tmp.setNext(head);<br>            head = tmp;<br>        }<br>        return this;<br>    }<br>    public T pop(){<br>        if(head==null){<br>            return null;<br>        }else{<br>            Node&lt;T&gt; tmp = head;<br>            head = head.getNext();<br>            return tmp.getValue();<br>        }<br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":65586,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1549465343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549465343","product_id":100017301,"comment_content":"import java.util.ArrayList;<br><br>&#47;&#47;数组实现队列,固定大小，暂时未实现扩容<br>public class ArrayQueue&lt;T&gt; {<br>    private Object[] arr;<br>    private int capacity;<br>    private int head = 0;<br>    private int tail = 0;<br>    public ArrayQueue(){<br>        this(16);&#47;&#47;默认初始化16个<br>    }<br>    public ArrayQueue(int capacity){<br>        assert capacity&gt;0;<br>        this.capacity = capacity;<br>        this.arr = new Object[capacity];<br>    }<br>    public void offer(T val){<br>        if(head-capacity == tail){<br>            &#47;&#47;没空间了<br>            throw new RuntimeException(&quot;queue is full&quot;);<br>        }<br>        arr[(head+1)%capacity] = val;<br>        head++;<br>    }<br>    public T poll(){<br>        if(tail == head){<br>            &#47;&#47;没空间了<br>            throw new RuntimeException(&quot;queue is empty&quot;);<br>        }<br>        T tmp = (T)arr[(tail+1)%capacity];<br>        tail++;<br>        return tmp;<br>    }<br><br>    public static void main(String[] args) {<br>        ArrayQueue queue = new ArrayQueue(3);<br>        queue.offer(1);queue.offer(2);queue.offer(3);<br>        &#47;&#47;queue.offer(4);&#47;&#47;报错<br>        System.out.println(queue.poll());<br>        System.out.println(queue.poll());<br>        System.out.println(queue.poll());<br>        &#47;&#47;System.out.println(queue.poll());&#47;&#47;报错<br><br>    }<br>}<br>","like_count":0},{"had_liked":false,"id":65583,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1549464665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549464665","product_id":100017301,"comment_content":"自己手动实现一个双端队列，其实只要会自己写实现一个链表，思路基本是一致的。用好头尾指针就可以解决一切问题，因为代码太长，就只贴上核心部分了，<br>&#47;&#47; 双端队列<br>private static class DequeNode{<br>        int val;<br>        DequeNode prev;<br>        DequeNode next;<br><br>        DequeNode(int val){<br>            this.val = val;<br>        }<br>    }<br><br>private DequeNode head;<br>    private DequeNode tail;<br>    private int length;<br>    private int size = 0;<br><br>public boolean insertFront(int value) {<br>        if (isFull()){<br>            return false;<br>        }<br>        DequeNode newNode = new DequeNode(value);<br>        if (isEmpty()){<br>            head = tail = newNode;<br>        } else {<br>            newNode.next = head;<br>            head.prev = newNode;<br>            head = newNode;<br>        }<br>        this.size++;<br>        return true;<br>    }<br><br>    public boolean insertLast(int value) {<br>        if (isFull()){<br>            return false;<br>        }<br>        DequeNode newNode = new DequeNode(value);<br>        if (isEmpty()){<br>            head = tail = newNode;<br>        } else {<br>            newNode.prev = tail;<br>            tail.next = newNode;<br>            tail = newNode;<br>        }<br>        this.size++;<br>        return true;<br>    }<br><br>    public boolean deleteFront() {<br>        if (isEmpty()){<br>            return false;<br>        }<br>        head = head.next;<br>        if (head != null){<br>            head.prev = null;<br>        }<br>        this.size--;<br>        return true;<br>    }<br><br>    public boolean deleteLast() {<br>        if (isEmpty()){<br>            return false;<br>        }<br>        tail = tail.prev;<br>        if (tail != null){<br>            tail.next = null;<br>        }<br>        this.size--;<br>        return true;<br>    }","like_count":0},{"had_liked":false,"id":65581,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1549464537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549464537","product_id":100017301,"comment_content":"&#47;&#47; 有效的括号<br>public boolean isValid(String s) {<br>        Map&lt;Character,Character&gt; map = new HashMap&lt;&gt;();<br>        map.put(&#39;)&#39;,&#39;(&#39;);<br>        map.put(&#39;]&#39;,&#39;[&#39;);<br>        map.put(&#39;}&#39;,&#39;{&#39;);<br>        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();<br>        for (int i = 0;i&lt;s.length();i++){<br>            Character c1 = s.charAt(i);<br>            Character c2 = map.get(c1);<br>            if (c2 == null){<br>                stack.push(c1);<br>            }else if(stack.isEmpty() || !c2.equals(stack.pop())){<br>                return false;<br>            }<br><br>        }<br>        return stack.isEmpty();<br>    }<br><br>&#47;&#47; 爬楼梯<br>public int climbStairs(int n) {<br>        if(n &lt;= 1){<br>            return 1;<br>        }else if(n == 2){<br>            return 2;<br>        }else {<br>            int one = 1;<br>            int two = 2;<br>            int sum = 0;<br>            for(int i = 2;i&lt;n;i++){<br>                sum = one + two;<br>                one = two;<br>                two = sum;<br>            }<br>            return sum;<br>        }<br>    }<br>","like_count":0},{"had_liked":false,"id":65560,"user_name":"黄丹","can_delete":false,"product_type":"c1","uid":1245295,"ip_address":"","ucode":"29C209F0D78996","user_header":"https://static001.geekbang.org/account/avatar/00/13/00/6f/aacb013d.jpg","comment_is_top":false,"comment_ctime":1549454987,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549454987","product_id":100017301,"comment_content":"王争老师新年快乐呀，我今天走亲戚去啦，队列的两题还没做TaT。下面放上栈和递归的四题的解题思路和代码<br>栈是一种受限制的线性表，只允许在栈顶进行操作（插入，取出，取值），Java已经为我们封装了一个这样的数据结构Stack, 对应的函数是（push,pop,peak）<br>1.\tValid Parentheses（有效的括号）<br>解题思路：使用栈来做,遍历字符数组，当遇到 {,(,[ 时就入栈，当遇到 ],),} 时就出栈，如果栈为空或者取出的字符不匹配时，这表明不是有效的括号，返回false，当字符数组遍历完后，如果栈为空，代表这是有效括号，返回true，否则返回false。<br>代码：<br>https:&#47;&#47;github.com&#47;yyxd&#47;leetcode&#47;blob&#47;master&#47;src&#47;leetcode&#47;stack&#47;Problem20_ValidParentheses.java<br><br>2.\tLongest Valid Parentheses（最长有效括号）<br>解题思路：这一题我是用栈做的，但也可以用队列来做，复杂度也是O(n)，这里的小trick是将数组的下标入栈，当”)”匹配到”(”时，可以利用数组下标来计算当前有效括号的长度，<br>代码：https:&#47;&#47;github.com&#47;yyxd&#47;leetcode&#47;blob&#47;master&#47;src&#47;leetcode&#47;stack&#47;Problem32_LongestValidParentheses.java<br><br>3.\tEvaluate Reverse Polish Notation（逆波兰表达式求值）<br>解题思路：这一题是很中规中矩的用栈去做，将操作数始终放在栈顶，遇到操作符时取出栈顶的两个操作数进行相应操作，之前写过一个编译器，解析四元式时进行计算就是讲操作数放在栈顶进行操作的。<br>代码：https:&#47;&#47;github.com&#47;yyxd&#47;leetcode&#47;blob&#47;master&#47;src&#47;leetcode&#47;stack&#47;Problem150_EvlRPN.java<br><br>4.\tClimbing Stairs（爬楼梯）<br>解题思路：想到达第n级台阶时，可以选择从第n-1级台阶向上迈一步，也可以选择从第n-2级台阶向上迈两步，因此到达第n级台阶时有f(n) = f(n-1)+f(n-2)级台阶，这就和斐波那契数列一样。可以用递归做也可以用动态规划做。<br>代码很简单就不放了<br><br>","like_count":0},{"had_liked":false,"id":65558,"user_name":"mgxian","can_delete":false,"product_type":"c1","uid":1014806,"ip_address":"","ucode":"7B7E77E6A83B87","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/16/4d1e5cc1.jpg","comment_is_top":false,"comment_ctime":1549452194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549452194","product_id":100017301,"comment_content":"阶乘 go 语言实现<br>package main<br><br>import &quot;fmt&quot;<br><br>func factorial(n int) int {<br>\tif n == 0 || n == 1 {<br>\t\treturn 1<br>\t}<br>\treturn n * factorial(n-1)<br>}<br><br>func main() {<br>\tfmt.Println(factorial(5))<br>}<br>","like_count":0},{"had_liked":false,"id":65551,"user_name":"ext4","can_delete":false,"product_type":"c1","uid":1180826,"ip_address":"","ucode":"FC881AECAC1974","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/9a/f2c0a206.jpg","comment_is_top":false,"comment_ctime":1549447941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549447941","product_id":100017301,"comment_content":"有效的括号<br>class Solution {<br>public:<br>    bool isValid(string s) {<br>        if (s.length() == 0) {<br>            return true;<br>        }<br>        stack&lt;char&gt; stk;<br>        for (int i = 0; i &lt; s.length(); i++) {<br>            switch (s[i]) {<br>                case &#39;(&#39;:<br>                case &#39;[&#39;: <br>                case &#39;{&#39;: {<br>                    stk.push(s[i]);<br>                    break;<br>                }<br>                case &#39;)&#39;: {<br>                    if (stk.empty() || stk.top() != &#39;(&#39;) {<br>                        return false;<br>                    }<br>                    stk.pop();<br>                    break;<br>                }<br>                case &#39;]&#39;: {<br>                    if (stk.empty() || stk.top() != &#39;[&#39;) {<br>                        return false;<br>                    }<br>                    stk.pop();<br>                    break;<br>                }<br>                case &#39;}&#39;: {<br>                    if (stk.empty() || stk.top() != &#39;{&#39;) {<br>                        return false;<br>                    }<br>                    stk.pop();<br>                    break;<br>                }<br>            }<br>        }<br>        return stk.size() == 0;<br>    }<br>};","like_count":0},{"had_liked":false,"id":65548,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1549445060,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1549445060","product_id":100017301,"comment_content":"第二题，最长有效括号，首先一遍遍历，得到每个(匹配的)的下标，没有匹配的为0，然后对这个中间结果去看最长一段中间不含0的即可，o(n)的时空复杂度。","like_count":0},{"had_liked":false,"id":65546,"user_name":"虎虎❤️","can_delete":false,"product_type":"c1","uid":1086535,"ip_address":"","ucode":"157F261E80291A","user_header":"https://static001.geekbang.org/account/avatar/00/10/94/47/75875257.jpg","comment_is_top":false,"comment_ctime":1549443765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549443765","product_id":100017301,"comment_content":"循环队列<br>public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; {<br><br>    private E[] data;<br>    private int front, tail;<br>    private int size;  <br><br>    public LoopQueue(int capacity){<br>        data = (E[])new Object[capacity + 1];<br>        front = 0;<br>        tail = 0;<br>        size = 0;<br>    }<br><br><br>    @Override<br>    public boolean isEmpty(){<br>        return front == tail;<br>    }<br><br>    @Override<br>    public int getSize(){<br>        return size;<br>    }<br><br>    @Override<br>    public void enqueue(E e){<br><br>        if((tail + 1) % data.length == front)<br>            resize(getCapacity() * 2);<br><br>        data[tail] = e;<br>        tail = (tail + 1) % data.length;<br>        size ++;<br>    }<br><br>    @Override<br>    public E dequeue(){<br><br>        if(isEmpty())<br>            throw new IllegalArgumentException(&quot;Cannot dequeue from an empty queue.&quot;);<br><br>        E ret = data[front];<br>        data[front] = null;<br>        front = (front + 1) % data.length;<br>        size --;<br>        if(size == getCapacity() &#47; 4 &amp;&amp; getCapacity() &#47; 2 != 0)<br>            resize(getCapacity() &#47; 2);<br>        return ret;<br>    }<br><br>    @Override<br>    public E getFront(){<br>        if(isEmpty())<br>            throw new IllegalArgumentException(&quot;Queue is empty.&quot;);<br>        return data[front];<br>    }<br><br>    private void resize(int newCapacity){<br><br>        E[] newData = (E[])new Object[newCapacity + 1];<br>        for(int i = 0 ; i &lt; size ; i ++)<br>            newData[i] = data[(i + front) % data.length];<br><br>        data = newData;<br>        front = 0;<br>        tail = size;<br>    }<br>}","like_count":0},{"had_liked":false,"id":65530,"user_name":"C_love","can_delete":false,"product_type":"c1","uid":1043613,"ip_address":"","ucode":"F268D1867C90C0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/9d/4d705f03.jpg","comment_is_top":false,"comment_ctime":1549431452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549431452","product_id":100017301,"comment_content":"Longest Valid Parentheses<br><br>class Solution {<br>    &#47;**<br>     * Time and space complexity: O(n)<br>     *<br>     * @param s input string<br>     *&#47;<br>    public int longestValidParentheses(String s) {<br>        if (s == null) {<br>            return 0;<br>        }<br>        <br>        int start = -1;<br>        int max = 0;<br>        <br>        final Stack&lt;Integer&gt; indices = new Stack&lt;&gt;();<br>        for (int i = 0; i &lt; s.length(); i++) {<br>            final char c = s.charAt(i);<br>            if (c == &#39;(&#39;) {<br>                indices.push(i);<br>            } else {<br>                if (indices.isEmpty()) {<br>                    start = i;<br>                } else {<br>                    indices.pop();<br>                    if (indices.isEmpty()) {<br>                        max = Math.max(max, i - start);<br>                    } else {<br>                        max = Math.max(max, i - indices.peek());<br>                    }<br>                }<br>            }<br>        }<br>        return max;<br>    }<br>}","like_count":0},{"had_liked":false,"id":65525,"user_name":"TryTs","can_delete":false,"product_type":"c1","uid":1036276,"ip_address":"","ucode":"1DD1E974D461A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/f4/26b95f0b.jpg","comment_is_top":false,"comment_ctime":1549430118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549430118","product_id":100017301,"comment_content":"个人理解链表与数组都是数据结构基础中的基础，许多复杂的数据结构图，散列表跳表这些数据结构在老师的讲解之下这些数据结构一个个更加形象起来，再加上老师应用的场景，更好的理解。","like_count":0},{"had_liked":false,"id":65520,"user_name":"C_love","can_delete":false,"product_type":"c1","uid":1043613,"ip_address":"","ucode":"F268D1867C90C0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/9d/4d705f03.jpg","comment_is_top":false,"comment_ctime":1549427732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549427732","product_id":100017301,"comment_content":"class Solution {<br>    private static final Map&lt;Character, Character&gt; PAIRS = new HashMap&lt;&gt;(3);<br>    static {<br>        PAIRS.put(&#39;(&#39;, &#39;)&#39;);<br>        PAIRS.put(&#39;[&#39;, &#39;]&#39;);<br>        PAIRS.put(&#39;{&#39;, &#39;}&#39;);<br>    }<br>    <br>    &#47;**<br>     * Time complexity: O(n)<br>     * Space complexity: O(n)<br>     *<br>     * @param s input string<br>     *&#47;<br>    public boolean isValid(String s) {<br>        if (s == null) {<br>            return true;<br>        }<br>        if (s.length() % 2 == 1) {<br>            return false;<br>        }<br>        <br>        final Stack&lt;Character&gt; left = new Stack&lt;&gt;();<br>        for (final char c : s.toCharArray()) {<br>            if (PAIRS.containsKey(c)) {<br>                left.push(c);<br>            } else if (left.isEmpty() || c != PAIRS.get(left.pop())) {<br>                return false;<br>            }<br>        }<br>        return left.isEmpty();<br>    }<br>}","like_count":0},{"had_liked":false,"id":65507,"user_name":"菜菜","can_delete":false,"product_type":"c1","uid":1243536,"ip_address":"","ucode":"888AC33663B774","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/90/f90903e5.jpg","comment_is_top":false,"comment_ctime":1549421574,"is_pvip":false,"replies":[{"id":"24751","content":"感谢您参与春节七天练的活动，为了表彰你在活动中的优秀表现，赠送您10元无门槛优惠券，我们会在3个工作日之内完成礼品发放，如有问题请咨询小明同学，微信geektime002。","user_name":"编辑回复","user_name_real":"王锦","uid":"1058895","ctime":1550805050,"ip_address":"","comment_id":65507,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1549421574","product_id":100017301,"comment_content":"求斐波那契数列，当然最经典的算法就是递归，但是递归的效率非常低，因为中间过车会计算大量重复的子节点。在《剑指Offer》一书中，提到了一个自下而上计算的方法。我们知道f(0)=0,f(1)=1,再计算f(2),f(3)一直到f(n)。这样，时间复杂度就是O(n)。","like_count":0,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438480,"discussion_content":"感谢您参与春节七天练的活动，为了表彰你在活动中的优秀表现，赠送您10元无门槛优惠券，我们会在3个工作日之内完成礼品发放，如有问题请咨询小明同学，微信geektime002。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550805050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65469,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1549380056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549380056","product_id":100017301,"comment_content":"其实爬楼梯的原理就是斐波拉契数列，代码写出来都是一毛一样的呀","like_count":0}]}