{"id":771132,"title":"24｜构造基于语义的自动化脚本","content":"<p>你好，我是徐昊，今天我们来继续学习AI时代的软件工程。</p><p>上节课我们讲解了使用大语言模型（Large Language Model，LLM）辅助软件开发的两个核心知识过程，即技术方案的应用以及软件质量的保证，以及如何通过LLM消除团队中的认知分歧，从而提高团队的整体效率。</p><p>对比<a href=\"https://time.geekbang.org/column/article/766281\">第16节课</a>我们讲述的测试驱动AI开发，就会发现，测试驱动AI开发关注于个人与LLM交互，以及知识是如何从人传递到LLM的。而消除认知分歧，最需要关注这两个方面——知识如何在人与人之间传递，以及LLM是如何辅助这一过程的。</p><p>然而无论是辅助个人还是辅助团队，我们都需要用到基于语言的自动化脚本来加速工作。那么，这节课，我们来学习一些常用技巧，帮助我们更有效地构造自动化脚本。</p><h2>补充上下文</h2><p>正如我们最开始在开篇词里介绍的一样，想要获得更高质量的结果，关键在于补充上下文。我们在前面的课程里，已经介绍了很多提示词技巧可以有效补充上下文。让我们简单复习一下，比如，结构化自然语言。</p><p>看一个简单的例子，现在有一个雇员的数据表，有两种不同的雇员，全职或者兼职。雇员按照不同的类型，有不同的计算工资的办法。全职按工资（SALARY）计算，兼职按时薪（HOURLY_RATE）计算。结构如下：</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">CREATE TABLE EMPLOYEE (\n    ID BIGINT(19) NOT NULL PRIMARY KEY,\n    NAME VARCHAR(255),\n    TYPE VARCHAR(255),\n    SALARY INTEGER(10) NOT NULL,\n    HOURLY_RATE INTEGER(10) NOT NULL\n);\n</code></pre><p>因为上下文的缺失，我们直接询问ChatGPT可能得不到我们想要的结果。比如，我们想知道所有雇员的工资，ChatGPT并不能给出我们预期的答案：</p><p><img src=\"https://static001.geekbang.org/resource/image/ac/cf/ac942e99d919ab465b447dafbc4dd3cf.jpg?wh=1900x809\" alt=\"\"></p><p>而我们只需要稍微补充一下上下文，结果就会有很大的不同，比如：</p><pre><code class=\"language-plain\">CREATE TABLE EMPLOYEE (\nID BIGINT(19) NOT NULL PRIMARY KEY,\nNAME VARCHAR(255),\nTYPE VARCHAR(255), — 取值为P或F，P是兼职，F是全职\nSALARY INTEGER(10) NOT NULL, — 全职工资以此为准\nHOURLY_RATE INTEGER(10) NOT NULL — 兼职工资为时薪\n);\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/6b/35/6bd114448e747dc3961d6f6857118035.jpg?wh=1900x1160\" alt=\"\"></p><p>对于绝大多数场景，只要补充足够的上下文，都能得到更好的结果，而且LLM的表现也会更加稳定。如果对于表结构的标注不够，也可以增加业务的场景和应用的背景说明。类似的场景，还有Text2API，你可以课后自行验证。</p><p>除此之外，另一个让LLM结果更加稳定的办法是零样本（zero shots example）或少样本学习（few shots example），这个也是我们之前学习过的技法。</p><p>比如，上面的例子中，通过TYPE字段区分，在同一个表中存在一族对象的信息，这是一个常用的模式，叫做单表继承映射（Single Table Inheritance）。单表继承映射是处理对象继承结构持久化时常用的模式。对于单表映射的SQL查询，实现方法有很多，除了使用case表达式外，我们还可以使用union all，甚至其他的更复杂的方式来完成。</p><p>通常我们会倾向于使用某一种固定的方式，但是LLM并不一定会在每一个场景下，都返回我们期待的模式。这时候，我们就需要使用少样本学习，将LLM的返回结果，固定在我们期望的模式中。</p><pre><code class=\"language-plain\">SCHEMA\n=======\nCREATE TABLE EMPLOYEE (\n  ID BIGINT(19) NOT NULL PRIMARY KEY,\n  NAME VARCHAR(255),\n  TYPE VARCHAR(255), — 取值为P或F，P是全职，F是兼职\n  SALARY INTEGER(10) NOT NULL, — 全职工资以此为准\n  HOURLY_RATE INTEGER(10) NOT NULL — 兼职工资为时薪\n);\n\n如果使用single table inheritance，我们会在该表的SCHEMA中，使用TYPE作为子类型的区分标志。遇到single table inheritance时，我们要使用CASE语句，完成对于类型的筛选。\n\n比如，当SCHEMA为:\n\nCREATE TABLE WHOLE_OBJECT_TREE(\n  ID BIGINT(19) NOT NULL PRIMARY KEY,\n  TYPE VARCHAR(255) — 取值为A或B\n)\n\n查询的SQL为：\n  SELECT …\n    CASE\n      WHEN TYPE=’A' THEN …\n      WHEN TYPE=‘B’ THEN …\n    END …\n   …\n   \n任务\n====\n查找所有员工工资的SQL是什么？\n</code></pre><p>你会发现这个提示词得到的结果非常稳定，而去掉少样本学习的部分，在多次执行时，它的结果就会有很大差别，比如下面是我得到的另一种结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/32/64/324c004753b6f19a45407d47dd741364.jpg?wh=1900x1650\" alt=\"\"></p><h2>转换生成内容</h2><p>除了提供足够的上下文和零样本/少样本学习外，指定LLM生成一种更为稳定的输出，也可以让最终的结果更为可控。一个常见的例子是单元测试的数据准备。比如，我们使用上面例子中的schema生成测试数据。一个直接的做法是让LLM直接生成灌注测试数据的代码。</p><pre><code class=\"language-plain\">SCHEMA\n======\nCREATE TABLE EMPLOYEE (\nID BIGINT(19) NOT NULL PRIMARY KEY,\nNAME VARCHAR(255),\nTYPE VARCHAR(255), — 取值为P或F，P是兼职，F是全职\nSALARY INTEGER(10) NOT NULL, — 全职工资以此为准\nHOURLY_RATE INTEGER(10) NOT NULL — 兼职工资为时薪\n);\n\n任务\n====\n请按照上述schema，生成测试数据，要求生成5个全职和5个兼职员工。\n全职员工薪水从8000-12000不等，兼职时薪不低于50，不高于150. \n使用JUnit和JDBC作为技术栈\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/67/36/6792e050f66174e53d77ce3edc7ea736.jpg?wh=1900x319\" alt=\"\"></p><pre><code class=\"language-plain\">import org.junit.jupiter.api.Test;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.util.Random;\n\npublic class TestDataGenerator {\n  // JDBC连接信息，请根据你的实际数据库配置修改\n  private static final String URL = \"jdbc:mysql://localhost:3306/database_name\";\n  private static final String USERNAME = \"your_username\";\n  private static final String PASSWORD = \"your_password\";\n\n  @Test\n  public void generateTestData() {\n    try (Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD)) {\n      // 生成5个全职员工\n      for (int i = 1; i &lt;= 5; i++) {\n        String name = \"FullTimeEmployee_\" + i;\n        int salary = getRandomNumberInRange(8000, 12000);\n        insertEmployee(connection, name, \"F\", salary, 0);\n      }\n      // 生成5个兼职员工\n      for (int i = 1; i &lt;= 5; i++) {\n        String name = \"PartTimeEmployee_\" + i;\n        int hourlyRate = getRandomNumberInRange(50, 150);\n        insertEmployee(connection, name, \"P\", 0, hourlyRate);\n      }\n    } catch (SQLException e) {\n      e.printStackTrace();\n    }\n  }\n  \n  private void insertEmployee(Connection connection, String name, String type, int salary, int hourlyRate) throws SQLException {\n    String sql = \"INSERT INTO EMPLOYEE (NAME, TYPE, SALARY, HOURLY_RATE) VALUES (?, ?, ?, ?)\";\n    try (PreparedStatement statement = connection.prepareStatement(sql)) {\n      statement.setString(1, name);\n      statement.setString(2, type);\n      statement.setInt(3, salary);\n      statement.setInt(4, hourlyRate);\n      statement.executeUpdate();\n    }\n  }\n\n  private int getRandomNumberInRange(int min, int max) {\n    Random r = new Random();\n    return r.nextInt((max - min) + 1) + min;\n  }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/80/24/804249c57fd36baf1955b963311df524.jpg?wh=1900x364\" alt=\"\"></p><p>我们可以看到，LLM以代码的形式，生成了测试数据准备的代码。而如果我们希望为不同场景再次生成数据准备测试代码时，很难保证LLM会生成一样的代码。那我们也就很难保证，它生成结果的一致性。</p><p>但是如果我们只让LLM生成数据，那么它的稳定性就会得到很大提高。比如：</p><pre><code class=\"language-plain\">SCHEMA\n======\nCREATE TABLE EMPLOYEE (\nID BIGINT(19) NOT NULL PRIMARY KEY,\nNAME VARCHAR(255),\nTYPE VARCHAR(255), — 取值为P或F，P是兼职，F是全职\nSALARY INTEGER(10) NOT NULL, — 全职工资以此为准\nHOURLY_RATE INTEGER(10) NOT NULL — 兼职工资为时薪\n);\n任务\n====\n请按照上述schema，生成csv格式的测试数据，要求生成5个全职和5个兼职员工。\n全职员工薪水从8000-12000不等，兼职时薪不低于50，不高于150.\ncsv的格式如下\nname,type,salary,hourly_rate\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/e3/3d/e38be2d98c8fc17eb4d9ff9b4dda293d.jpg?wh=1900x1714\" alt=\"\"></p><p>然后我们可以使用数据驱动的测试风格，将这些数据灌入我们要的测试中。</p><pre><code class=\"language-plain\">SCHEMA\n======\nCREATE TABLE EMPLOYEE (\n  ID BIGINT(19) NOT NULL PRIMARY KEY,\n  NAME VARCHAR(255),\n  TYPE VARCHAR(255), — 取值为P或F，P是兼职，F是全职\n  SALARY INTEGER(10) NOT NULL, — 全职工资以此为准\n  HOURLY_RATE INTEGER(10) NOT NULL — 兼职工资为时薪\n);\n\n任务\n====\n编写一个JUnit准备测试数据的方法，按照如下csv的格式，将数据插入上述schema。\nname,type,salary,hourly_rate\ncsv文件由指定路径读入。\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/ed/ba/edb115c4b880bdb202e63db2e98a1fba.jpg?wh=1920x308\" alt=\"\"></p><pre><code class=\"language-plain\">import org.junit.Before;\nimport org.junit.Test;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic class TestDataPreparationTest {\n  private static final String JDBC_URL = \"jdbc:mysql://localhost:3306/your_database_name\";\n  private static final String USERNAME = \"your_username\";\n  private static final String PASSWORD = \"your_password\";\n  \n  @Before\n  public void setUp() {\n    // Your setup code, e.g., initializing database connection\n  }\n\n  @Test\n  public void testDataInsertion() {\n    String csvFilePath = \"path/to/your/csv/file.csv\";\n    try (Connection connection = DriverManager.getConnection(JDBC_URL, USERNAME, PASSWORD);\n      BufferedReader reader = new BufferedReader(new FileReader(csvFilePath))) {\n      String line;\n      while ((line = reader.readLine()) != null) {\n        String[] data = line.split(\",\");\n        String name = data[0].trim();\n        String type = data[1].trim();\n        int salary = Integer.parseInt(data[2].trim());\n        int hourlyRate = Integer.parseInt(data[3].trim());\n        insertEmployee(connection, name, type, salary, hourlyRate);\n      }\n    } catch (IOException | SQLException e) {\n      e.printStackTrace();\n    }\n  }\n\n  private void insertEmployee(Connection connection, String name, String type, int salary, int hourlyRate) throws SQLException {\n    String sql = \"INSERT INTO EMPLOYEE (NAME, TYPE, SALARY, HOURLY_RATE) VALUES (?, ?, ?, ?)\";\n    try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {\n      preparedStatement.setString(1, name);\n      preparedStatement.setString(2, type);\n      preparedStatement.setInt(3, salary);\n      preparedStatement.setInt(4, hourlyRate);\n      preparedStatement.executeUpdate();\n    }\n  }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/81/e8/815389c39a9938cfd10915836a9c06e8.jpg?wh=1556x572\" alt=\"\"></p><p>在后续的测试生成中，我们可以通过少样本学习，让LLM继续使用insertEmployee完成数据的准备。这时LLM只需要专注于生成csv格式的数据即可。比起代码，生成csv具有更高的稳定性和一致性。数据驱动风格的代码也更适合由LLM辅助开发。</p><h2>小结</h2><p>当我们与LLM交互时，有一个奇妙的心理预期，当我们处于复杂的认知模式时（Complex），我们对于LLM返回的结果是最满意的。<strong>因为我们对于要解决的问题十分懵懂，LLM返回的结果只要对我们稍有启迪，我们就会非常满意</strong>。</p><p>比如，对于一个完全不了解的技术栈，哪怕是非常简单的功能，当LLM返回的代码可以达成一定功能时，我们就会惊讶于LLM的能力。其实这倒不是LLM有多么厉害，而是我们自己太菜了而已。我们菜到甚至无法正确判断LLM产生结果的质量。</p><p>而当我们处在清晰认知模式（Clear）时，我们又对LLM产生的结果异常地苛刻。因为此时我们对于要解决的问题，以及问题的解决方案有准确的认知，我们不光知道要解决的问题是什么，而且对于如何解决也有明确的期待。此时，我们就可以一眼看出LLM生成结果的成色。那么自然，对于LLM的结果也就没有那么满意了。</p><p>所以我们可以听到很多关于LLM截然相反的讨论，有人因为它给予我们启迪和思考，给予高度的赞扬，也有尝试将LLM用于实际工作屡屡碰壁，最后决定这东西没有什么太大用途。<strong>当然，我们现在知道，这是因为不同的认知行为模式造成的，在不同的认知行为模式下，LLM能够发挥的作用也不尽相同。</strong></p><p>所以当我们尝试通过大语言模型构造自动化脚本时，一方面我们不希望LLM像传统脚本一样，只能处理有限的情况。另一方面，我们又希望它能在更多的场景下，给出符合我们预期的答案，这就是使用LLM构造自动化脚本的核心难点。</p><p>而截止到现在（2024年4月），解决LLM自动化脚本问题时，比较常用的技巧无非是：</p><ul>\n<li>补充上下文让LLM更好地理解问题域；</li>\n<li>零样本/少样本学习以固定LLM的生成习惯；</li>\n<li>由数据驱动简化LLM生成目标。</li>\n</ul><h2>思考题</h2><p>试想一个可以通过数据驱动简化LLM生成的例子。</p><p>欢迎在留言区分享你的想法，我会让编辑置顶一些优质回答供大家学习讨论。</p>","neighbors":{"left":{"article_title":"23｜团队开发的核心模式","id":770627},"right":{"article_title":"25｜工具与框架","id":771190}},"comments":[{"had_liked":false,"id":390248,"user_name":"6点无痛早起学习的和尚","can_delete":false,"product_type":"c1","uid":1703256,"ip_address":"北京","ucode":"33A8A1CDA103F9","user_header":"https://static001.geekbang.org/account/avatar/00/19/fd/58/1af629c7.jpg","comment_is_top":false,"comment_ctime":1714899072,"is_pvip":false,"replies":[{"id":141931,"content":"写逻辑不给例子 就是零样本 给例子就是少样本","user_name":"作者回复","user_name_real":"编辑","uid":2537798,"ctime":1714953496,"ip_address":"浙江","comment_id":390248,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"这里有一个问题，比如要写一个测试代码，投喂给 LLM 的测试策略（stub、mock等等），这些是不是都可以归为零样本&#47;少样本？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644072,"discussion_content":"写逻辑不给例子 就是零样本 给例子就是少样本","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1714953496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390163,"user_name":"术子米德","can_delete":false,"product_type":"c1","uid":1898023,"ip_address":"浙江","ucode":"382EA7E2AF0B56","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","comment_is_top":false,"comment_ctime":1714521208,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100755401,"comment_content":"🤔☕️🤔☕️🤔\n【R】自动化脚本：一方面突破传统脚本、怎么写就那么点效果，另一方面放到更多场景、给出预期答案。\n技巧：补充上下文、零样本&#47;少样本学习、数据驱动。\n【.I.】问题在我面前，我懵懂Complex状态，一股脑儿扔给大模型，生成的内容中，只要对我有启发，我就很开心。任务列表在我面前，我清晰Clear状态，就是自己懒得动手干，稍作整理扔给大模型，生成的内容中，哪怕一点点偏差，我心里就会泛嘀咕，这么笨。\n【Q】系统里的某个模块（如：类似MQ的消息通讯模块），它以C&#47;C++的API接口供其它模块调用，跟CRUD类的测试是否有不同的关注点，提示词技巧是否有差别？ 这样的模块的单元测试，若想LLM协助设计，哪些方面有别于CRUD类的测试？\n— by 术子米德@2024年5月1日","like_count":0}]}