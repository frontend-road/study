{"id":287819,"title":"19 | 波动的响应延迟：如何应对变慢的Redis？（下）","content":"<p>你好，我是蒋德钧。</p><p>上节课，我介绍了判断Redis变慢的两种方法，分别是响应延迟和基线性能。除此之外，我还给你分享了从Redis的自身命令操作层面排查和解决问题的两种方案。</p><p>但是，如果在排查时，你发现Redis没有执行大量的慢查询命令，也没有同时删除大量过期keys，那么，我们是不是就束手无策了呢？</p><p>当然不是！我还有很多“锦囊妙计”，准备在这节课分享给你呢！</p><p>如果上节课的方法不管用，那就说明，你要关注影响性能的其他机制了，也就是文件系统和操作系统。</p><p>Redis会持久化保存数据到磁盘，这个过程要依赖文件系统来完成，所以，文件系统将数据写回磁盘的机制，会直接影响到Redis持久化的效率。而且，在持久化的过程中，Redis也还在接收其他请求，持久化的效率高低又会影响到Redis处理请求的性能。</p><p>另一方面，Redis是内存数据库，内存操作非常频繁，所以，操作系统的内存机制会直接影响到Redis的处理效率。比如说，如果Redis的内存不够用了，操作系统会启动swap机制，这就会直接拖慢Redis。</p><p>那么，接下来，我再从这两个层面，继续给你介绍，如何进一步解决Redis变慢的问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/06/cd026801924e197f5c79828c368cd706.jpg?wh=4242*3039\" alt=\"\"></p><h2>文件系统：AOF模式</h2><p>你可能会问，Redis是个内存数据库，为什么它的性能还和文件系统有关呢？</p><!-- [[[read_end]]] --><p>我在前面讲过，为了保证数据可靠性，Redis会采用AOF日志或RDB快照。其中，AOF日志提供了三种日志写回策略：no、everysec、always。这三种写回策略依赖文件系统的两个系统调用完成，也就是write和fsync。</p><p>write只要把日志记录写到内核缓冲区，就可以返回了，并不需要等待日志实际写回到磁盘；而fsync需要把日志记录写回到磁盘后才能返回，时间较长。下面这张表展示了三种写回策略所执行的系统调用。</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/a4/9f1316094001ca64c8dfca37c2c49ea4.jpg?wh=2720*598\" alt=\"\"></p><p>当写回策略配置为everysec和always时，Redis需要调用fsync把日志写回磁盘。但是，这两种写回策略的具体执行情况还不太一样。</p><p>在使用everysec时，Redis允许丢失一秒的操作记录，所以，Redis主线程并不需要确保每个操作记录日志都写回磁盘。而且，fsync的执行时间很长，如果是在Redis主线程中执行fsync，就容易阻塞主线程。所以，当写回策略配置为everysec时，Redis会使用后台的子线程异步完成fsync的操作。</p><p>而对于always策略来说，Redis需要确保每个操作记录日志都写回磁盘，如果用后台子线程异步完成，主线程就无法及时地知道每个操作是否已经完成了，这就不符合always策略的要求了。所以，always策略并不使用后台子线程来执行。</p><p>另外，在使用AOF日志时，为了避免日志文件不断增大，Redis会执行AOF重写，生成体量缩小的新的AOF日志文件。AOF重写本身需要的时间很长，也容易阻塞Redis主线程，所以，Redis使用子进程来进行AOF重写。</p><p>但是，这里有一个潜在的风险点：AOF重写会对磁盘进行大量IO操作，同时，fsync又需要等到数据写到磁盘后才能返回，所以，当AOF重写的压力比较大时，就会导致fsync被阻塞。虽然fsync是由后台子线程负责执行的，但是，主线程会监控fsync的执行进度。</p><p>当主线程使用后台子线程执行了一次fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的fsync还没有执行完，那么它就会阻塞。所以，如果后台子线程执行的fsync频繁阻塞的话（比如AOF重写占用了大量的磁盘IO带宽），主线程也会阻塞，导致Redis性能变慢。</p><p>为了帮助你理解，我再画一张图来展示下在磁盘压力小和压力大的时候，fsync后台子线程和主线程受到的影响。</p><p><img src=\"https://static001.geekbang.org/resource/image/2a/a6/2a47b3f6fd7beaf466a675777ebd28a6.jpg?wh=3000*1557\" alt=\"\"></p><p>好了，说到这里，你已经了解了，由于fsync后台子线程和AOF重写子进程的存在，主IO线程一般不会被阻塞。但是，如果在重写日志时，AOF重写子进程的写入量比较大，fsync线程也会被阻塞，进而阻塞主线程，导致延迟增加。现在，我来给出排查和解决建议。</p><p>首先，你可以检查下Redis配置文件中的appendfsync配置项，该配置项的取值表明了Redis实例使用的是哪种AOF日志写回策略，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/ba/e9/ba770d1f25ffae79a101c13b9f8aa9e9.jpg?wh=2738*601\" alt=\"\"></p><p>如果AOF写回策略使用了everysec或always配置，请先确认下业务方对数据可靠性的要求，明确是否需要每一秒或每一个操作都记日志。有的业务方不了解Redis AOF机制，很可能就直接使用数据可靠性最高等级的always配置了。其实，在有些场景中（例如Redis用于缓存），数据丢了还可以从后端数据库中获取，并不需要很高的数据可靠性。</p><p>如果业务应用对延迟非常敏感，但同时允许一定量的数据丢失，那么，可以把配置项no-appendfsync-on-rewrite设置为yes，如下所示：</p><pre><code>no-appendfsync-on-rewrite yes\n</code></pre><p>这个配置项设置为yes时，表示在AOF重写时，不进行fsync操作。也就是说，Redis实例把写命令写到内存后，不调用后台线程进行fsync操作，就可以直接返回了。当然，如果此时实例发生宕机，就会导致数据丢失。反之，如果这个配置项设置为no（也是默认配置），在AOF重写时，Redis实例仍然会调用后台线程进行fsync操作，这就会给实例带来阻塞。</p><p>如果的确需要高性能，同时也需要高可靠数据保证，我建议你考虑<strong>采用高速的固态硬盘作为AOF日志的写入设备。</strong></p><p>高速固态盘的带宽和并发度比传统的机械硬盘的要高出10倍及以上。在AOF重写和fsync后台线程同时执行时，固态硬盘可以提供较为充足的磁盘IO资源，让AOF重写和fsync后台线程的磁盘IO资源竞争减少，从而降低对Redis的性能影响。</p><h2>操作系统：swap</h2><p>如果Redis的AOF日志配置只是no，或者就没有采用AOF模式，那么，还会有什么问题导致性能变慢吗？</p><p>接下来，我就再说一个潜在的瓶颈：<strong>操作系统的内存swap</strong>。</p><p>内存swap是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制，涉及到磁盘的读写，所以，一旦触发swap，无论是被换入数据的进程，还是被换出数据的进程，其性能都会受到慢速磁盘读写的影响。</p><p>Redis是内存数据库，内存使用量大，如果没有控制好内存的使用量，或者和其他内存需求大的应用一起运行了，就可能受到swap的影响，而导致性能变慢。</p><p>这一点对于Redis内存数据库而言，显得更为重要：正常情况下，Redis的操作是直接通过访问内存就能完成，一旦swap被触发了，Redis的请求操作需要等到磁盘数据读写完成才行。而且，和我刚才说的AOF日志文件读写使用fsync线程不同，swap触发后影响的是Redis主IO线程，这会极大地增加Redis的响应时间。</p><p>说到这儿，我想给你分享一个我曾经遇到过的因为swap而导致性能降低的例子。</p><p>在正常情况下，我们运行的一个实例完成5000万个GET请求时需要300s，但是，有一次，这个实例完成5000万GET请求，花了将近4个小时的时间。经过问题复现，我们发现，当时Redis处理请求用了近4小时的情况下，该实例所在的机器已经发生了swap。从300s到4个小时，延迟增加了将近48倍，可以看到swap对性能造成的严重影响。</p><p>那么，什么时候会触发swap呢？</p><p>通常，触发swap的原因主要是<strong>物理机器内存不足</strong>，对于Redis而言，有两种常见的情况：</p><ul>\n<li>Redis实例自身使用了大量的内存，导致物理机器的可用内存不足；</li>\n<li>和Redis实例在同一台机器上运行的其他进程，在进行大量的文件读写操作。文件读写本身会占用系统内存，这会导致分配给Redis实例的内存量变少，进而触发Redis发生swap。</li>\n</ul><p>针对这个问题，我也给你提供一个解决思路：<strong>增加机器的内存或者使用Redis集群</strong>。</p><p>操作系统本身会在后台记录每个进程的swap使用情况，即有多少数据量发生了swap。你可以先通过下面的命令查看Redis的进程号，这里是5332。</p><pre><code>$ redis-cli info | grep process_id\nprocess_id: 5332\n</code></pre><p>然后，进入Redis所在机器的/proc目录下的该进程目录中：</p><pre><code>$ cd /proc/5332\n</code></pre><p>最后，运行下面的命令，查看该Redis进程的使用情况。在这儿，我只截取了部分结果：</p><pre><code>$cat smaps | egrep '^(Swap|Size)'\nSize: 584 kB\nSwap: 0 kB\nSize: 4 kB\nSwap: 4 kB\nSize: 4 kB\nSwap: 0 kB\nSize: 462044 kB\nSwap: 462008 kB\nSize: 21392 kB\nSwap: 0 kB\n</code></pre><p>每一行Size表示的是Redis实例所用的一块内存大小，而Size下方的Swap和它相对应，表示这块Size大小的内存区域有多少已经被换出到磁盘上了。如果这两个值相等，就表示这块内存区域已经完全被换出到磁盘了。</p><p>作为内存数据库，Redis本身会使用很多大小不一的内存块，所以，你可以看到有很多Size行，有的很小，就是4KB，而有的很大，例如462044KB。<strong>不同内存块被换出到磁盘上的大小也不一样</strong>，例如刚刚的结果中的第一个4KB内存块，它下方的Swap也是4KB，这表示这个内存块已经被换出了；另外，462044KB这个内存块也被换出了462008KB，差不多有462MB。</p><p>这里有个重要的地方，我得提醒你一下，当出现百MB，甚至GB级别的swap大小时，就表明，此时，Redis实例的内存压力很大，很有可能会变慢。所以，swap的大小是排查Redis性能变慢是否由swap引起的重要指标。</p><p>一旦发生内存swap，最直接的解决方法就是<strong>增加机器内存</strong>。如果该实例在一个Redis切片集群中，可以增加Redis集群的实例个数，来分摊每个实例服务的数据量，进而减少每个实例所需的内存量。</p><p>当然，如果Redis实例和其他操作大量文件的程序（例如数据分析程序）共享机器，你可以将Redis实例迁移到单独的机器上运行，以满足它的内存需求量。如果该实例正好是Redis主从集群中的主库，而从库的内存很大，也可以考虑进行主从切换，把大内存的从库变成主库，由它来处理客户端请求。</p><h2>操作系统：内存大页</h2><p>除了内存swap，还有一个和内存相关的因素，即内存大页机制（Transparent Huge Page, THP），也会影响Redis性能。</p><p>Linux内核从2.6.38开始支持内存大页机制，该机制支持2MB大小的内存页分配，而常规的内存页分配是按4KB的粒度来执行的。</p><p>很多人都觉得：“Redis是内存数据库，内存大页不正好可以满足Redis的需求吗？而且在分配相同的内存量时，内存大页还能减少分配次数，不也是对Redis友好吗?”</p><p>其实，系统的设计通常是一个取舍过程，我们称之为trade-off。很多机制通常都是优势和劣势并存的。Redis使用内存大页就是一个典型的例子。</p><p>虽然内存大页可以给Redis带来内存分配方面的收益，但是，不要忘了，Redis为了提供数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，所以，此时，Redis主线程仍然可以接收客户端写请求。客户端的写请求可能会修改正在进行持久化的数据。在这一过程中，Redis就会采用写时复制机制，也就是说，一旦有数据要被修改，Redis并不会直接修改内存中的数据，而是将这些数据拷贝一份，然后再进行修改。</p><p>如果采用了内存大页，那么，即使客户端请求只修改100B的数据，Redis也需要拷贝2MB的大页。相反，如果是常规内存页机制，只用拷贝4KB。两者相比，你可以看到，当客户端请求修改或新写入数据较多时，内存大页机制将导致大量的拷贝，这就会影响Redis正常的访存操作，最终导致性能变慢。</p><p>那该怎么办呢？很简单，关闭内存大页，就行了。</p><p>首先，我们要先排查下内存大页。方法是：在Redis实例运行的机器上执行如下命令:</p><pre><code>cat /sys/kernel/mm/transparent_hugepage/enabled\n</code></pre><p>如果执行结果是always，就表明内存大页机制被启动了；如果是never，就表示，内存大页机制被禁止。</p><p>在实际生产环境中部署时，我建议你不要使用内存大页机制，操作也很简单，只需要执行下面的命令就可以了：</p><pre><code>echo never /sys/kernel/mm/transparent_hugepage/enabled\n</code></pre><h2>小结</h2><p>这节课，我从文件系统和操作系统两个维度，给你介绍了应对Redis变慢的方法。</p><p>为了方便你应用，我给你梳理了一个包含9个检查点的Checklist，希望你在遇到Redis性能变慢时，按照这些步骤逐一检查，高效地解决问题。</p><ol>\n<li>获取Redis实例在当前环境下的基线性能。</li>\n<li>是否用了慢查询命令？如果是的话，就使用其他命令替代慢查询命令，或者把聚合计算命令放在客户端做。</li>\n<li>是否对过期key设置了相同的过期时间？对于批量删除的key，可以在每个key的过期时间上加一个随机数，避免同时删除。</li>\n<li>是否存在bigkey？ 对于bigkey的删除操作，如果你的Redis是4.0及以上的版本，可以直接利用异步线程机制减少主线程阻塞；如果是Redis 4.0以前的版本，可以使用SCAN命令迭代删除；对于bigkey的集合查询和聚合操作，可以使用SCAN命令在客户端完成。</li>\n<li>Redis AOF配置级别是什么？业务层面是否的确需要这一可靠性级别？如果我们需要高性能，同时也允许数据丢失，可以将配置项no-appendfsync-on-rewrite设置为yes，避免AOF重写和fsync竞争磁盘IO资源，导致Redis延迟增加。当然， 如果既需要高性能又需要高可靠性，最好使用高速固态盘作为AOF日志的写入盘。</li>\n<li>Redis实例的内存使用是否过大？发生swap了吗？如果是的话，就增加机器内存，或者是使用Redis集群，分摊单机Redis的键值对数量和内存压力。同时，要避免出现Redis和其他内存需求大的应用共享机器的情况。</li>\n<li>在Redis实例的运行环境中，是否启用了透明大页机制？如果是的话，直接关闭内存大页机制就行了。</li>\n<li>是否运行了Redis主从集群？如果是的话，把主库实例的数据量大小控制在2~4GB，以免主从复制时，从库因加载大的RDB文件而阻塞。</li>\n<li>是否使用了多核CPU或NUMA架构的机器运行Redis实例？使用多核CPU时，可以给Redis实例绑定物理核；使用NUMA架构时，注意把Redis实例和网络中断处理程序运行在同一个CPU Socket上。</li>\n</ol><p>实际上，影响系统性能的因素还有很多，这两节课给你讲的都是应对最常见问题的解决方案。</p><p>如果你遇到了一些特殊情况，也不要慌，我再给你分享一个小技巧：仔细检查下有没有恼人的“邻居”，具体点说，就是Redis所在的机器上有没有一些其他占内存、磁盘IO和网络IO的程序，比如说数据库程序或者数据采集程序。如果有的话，我建议你将这些程序迁移到其他机器上运行。</p><p>为了保证Redis高性能，我们需要给Redis充足的计算、内存和IO资源，给它提供一个“安静”的环境。</p><h2>每课一问</h2><p>这两节课，我向你介绍了系统性定位、排查和解决Redis变慢的方法。所以，我想请你聊一聊，你遇到过Redis变慢的情况吗？如果有的话，你是怎么解决的呢？</p><p>欢迎你在留言区分享一下自己的经验，如果觉得今天的内容对你有所帮助，也欢迎分享给你的朋友或同事，我们下节课见。</p>","neighbors":{"left":{"article_title":"18 | 波动的响应延迟：如何应对变慢的Redis？（上）","id":286549},"right":{"article_title":"20 | 删除数据后，为什么内存占用率还是很高？","id":289140}},"comments":[{"had_liked":false,"id":249385,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1600617961,"is_pvip":true,"discussion_count":34,"race_medal":0,"score":"1899976162793","product_id":100056701,"comment_content":"关于如何分析、排查、解决Redis变慢问题，我总结的checklist如下：<br><br>1、使用复杂度过高的命令（例如SORT&#47;SUION&#47;ZUNIONSTORE&#47;KEYS），或一次查询全量数据（例如LRANGE key 0 N，但N很大）<br><br>分析：a) 查看slowlog是否存在这些命令 b) Redis进程CPU使用率是否飙升（聚合运算命令导致）<br><br>解决：a) 不使用复杂度过高的命令，或用其他方式代替实现（放在客户端做） b) 数据尽量分批查询（LRANGE key 0 N，建议N&lt;=100，查询全量数据建议使用HSCAN&#47;SSCAN&#47;ZSCAN）<br><br>2、操作bigkey<br><br>分析：a) slowlog出现很多SET&#47;DELETE变慢命令（bigkey分配内存和释放内存变慢） b) 使用redis-cli -h $host -p $port --bigkeys扫描出很多bigkey<br><br>解决：a) 优化业务，避免存储bigkey b) Redis 4.0+可开启lazy-free机制<br><br>3、大量key集中过期<br><br>分析：a) 业务使用EXPIREAT&#47;PEXPIREAT命令 b) Redis info中的expired_keys指标短期突增<br><br>解决：a) 优化业务，过期增加随机时间，把时间打散，减轻删除过期key的压力 b) 运维层面，监控expired_keys指标，有短期突增及时报警排查<br><br>4、Redis内存达到maxmemory<br><br>分析：a) 实例内存达到maxmemory，且写入量大，淘汰key压力变大 b) Redis info中的evicted_keys指标短期突增<br><br>解决：a) 业务层面，根据情况调整淘汰策略（随机比LRU快） b) 运维层面，监控evicted_keys指标，有短期突增及时报警 c) 集群扩容，多个实例减轻淘汰key的压力<br><br>5、大量短连接请求<br><br>分析：Redis处理大量短连接请求，TCP三次握手和四次挥手也会增加耗时<br><br>解决：使用长连接操作Redis<br><br>6、生成RDB和AOF重写fork耗时严重<br><br>分析：a) Redis变慢只发生在生成RDB和AOF重写期间 b) 实例占用内存越大，fork拷贝内存页表越久 c) Redis info中latest_fork_usec耗时变长<br><br>解决：a) 实例尽量小 b) Redis尽量部署在物理机上 c) 优化备份策略（例如低峰期备份） d) 合理配置repl-backlog和slave client-output-buffer-limit，避免主从全量同步 e) 视情况考虑关闭AOF f) 监控latest_fork_usec耗时是否变长<br><br>7、AOF使用awalys机制<br><br>分析：磁盘IO负载变高<br><br>解决：a) 使用everysec机制 b) 丢失数据不敏感的业务不开启AOF<br><br>8、使用Swap<br><br>分析：a) 所有请求全部开始变慢 b) slowlog大量慢日志 c) 查看Redis进程是否使用到了Swap<br><br>解决：a) 增加机器内存 b) 集群扩容 c) Swap使用时监控报警<br><br>9、进程绑定CPU不合理<br><br>分析：a) Redis进程只绑定一个CPU逻辑核 b) NUMA架构下，网络中断处理程序和Redis进程没有绑定在同一个Socket下<br><br>解决：a) Redis进程绑定多个CPU逻辑核 b) 网络中断处理程序和Redis进程绑定在同一个Socket下<br><br>10、开启透明大页机制<br><br>分析：生成RDB和AOF重写期间，主线程处理写请求耗时变长（拷贝内存副本耗时变长）<br><br>解决：关闭透明大页机制<br><br>11、网卡负载过高<br><br>分析：a) TCP&#47;IP层延迟变大，丢包重传变多 b) 是否存在流量过大的实例占满带宽<br><br>解决：a) 机器网络资源监控，负载过高及时报警 b) 提前规划部署策略，访问量大的实例隔离部署<br><br>总之，Redis的性能与CPU、内存、网络、磁盘都息息相关，任何一处发生问题，都会影响到Redis的性能。<br><br>主要涉及到的包括业务使用层面和运维层面：业务人员需要了解Redis基本的运行原理，使用合理的命令、规避bigke问题和集中过期问题。运维层面需要DBA提前规划好部署策略，预留足够的资源，同时做好监控，这样当发生问题时，能够及时发现并尽快处理。","like_count":443,"discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378011,"discussion_content":"关于如何分析、排查、解决 Redis 变慢问题，我新写了篇文章，基本覆盖了会遇到的所有性能问题，应该对大家很有帮助，《Redis为什么变慢了？一文讲透如何排查Redisi性能问题》：https://mp.weixin.qq.com/s/Qc4t_-_pL4w8VlSoJhRDcg","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1622995953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2124243,"avatar":"https://static001.geekbang.org/account/avatar/00/20/69/d3/97510c5b.jpg","nickname":"荐哥 | 周优军","note":"","ucode":"5DDD9CC85A2E6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":579986,"discussion_content":"课代表终于开课了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657789345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378011,"ip_address":""},"score":579986,"extra":""}]},{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340906,"discussion_content":"送你一朵小红花","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1610197721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1434423,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e3/37/c132802f.jpg","nickname":"WESTWALL","note":"","ucode":"295A030F9D3BF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406872,"discussion_content":"老师+课代表才是完整的课","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1634863304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377158,"discussion_content":"起始这里的问题可以扩展到很多点 因为本质上redis是部署在linux上的。那么作为一个内存数据库必然受制于两个因素 一是内存分配 二是数据持久化。\n\n我们先来看 内存分配。之前老师解释过内存分配redis用的jmalloc 这种特性会造成一定的数据碎片 另外与free结合使用时 实际上是内存标记回收所以内存碎片是天然存在的。\n\n再来看数据持久化 此处用的是fork &amp;&amp; fsync &amp;&amp; write。fsync毫无疑问是write through的 而write显然是write back。 这两种模式自身的问题就不做讨论了 毕竟不是linux课程。所以因为文件系统自身机制如ext3 ext4等之类的问题依然会限制redis子进程落盘 导致主进程监控时期卡顿","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1622532367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1129709,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3c/ed/9b42e3e2.jpg","nickname":"面向运气开发","note":"","ucode":"F23361FB85D02C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320251,"discussion_content":"课代表好！请教一下 第五条如何监控短连接 redis支持吗？还是得用Linux工具","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604301956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2148214,"avatar":"https://static001.geekbang.org/account/avatar/00/20/c7/76/9c6dc09c.jpg","nickname":"say goodbye","note":"","ucode":"51A88796DD77CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545810,"discussion_content":"准备拿这个吊打面试官了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642056732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2185166,"avatar":"https://static001.geekbang.org/account/avatar/00/21/57/ce/ad3c3954.jpg","nickname":"鹅鹅鹅","note":"","ucode":"6AFA3FCC7B5AEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374895,"discussion_content":"牛逼斯科拉","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621404744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3201606,"avatar":"","nickname":"Geek_c5eb91","note":"","ucode":"650C7D09442F51","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590836,"discussion_content":"靓仔，能否借一步再说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666097522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3065276,"avatar":"","nickname":"Geek_b3b8da","note":"","ucode":"5461CD95B1D764","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590006,"discussion_content":"我准备把这个背会了去吊打面试官去哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665459882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207977,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6e/a9/e7b9e92e.jpg","nickname":"蜗牛漫步","note":"","ucode":"825F27BAF9A194","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574728,"discussion_content":"点赞收藏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654306836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2911084,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6b/6c/3e80afaf.jpg","nickname":"HappyHasson","note":"","ucode":"B84CC43E349CFA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554779,"discussion_content":"请教： \n“分析：a) 业务使用EXPIREAT/PEXPIREAT命令 b) Redis info中的expired_keys指标短期突增\n\n解决：a) 优化业务，过期增加随机时间，把时间打散，减轻删除过期key的压力”\n\n这里的将时间打散，打散的时间区间应该为多大，怎么选择？1s？10s等等？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646615666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553514,"discussion_content":"厉害，mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645942382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114878,"avatar":"https://static001.geekbang.org/account/avatar/00/11/02/fe/d539b96b.jpg","nickname":"曹翔","note":"","ucode":"B4D8B42DFB535C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549642,"discussion_content":"建议写掘金小册","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644160227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238337,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/41/ffe533ba.jpg","nickname":"尚帝","note":"","ucode":"6F1703FD5A23A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541236,"discussion_content":"总结牛B","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640309869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236156,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dc/bc/3c5a1634.jpg","nickname":"Loyalty","note":"","ucode":"C23EE6878580C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407580,"discussion_content":"厉害厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635065169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363903,"discussion_content":"收藏了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617324111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180028,"avatar":"https://static001.geekbang.org/account/avatar/00/12/01/7c/836cf29e.jpg","nickname":"Yang.🍭","note":"","ucode":"3A09F586CBC571","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362320,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616919643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2049478,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/45/c6/ba5176a6.jpg","nickname":"从不卖萌","note":"","ucode":"E9B7B1C8FAFE0B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350666,"discussion_content":"太牛皮了..膜拜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613971574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243429,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/25/576088ef.jpg","nickname":"轩月","note":"","ucode":"E5277B5718CA30","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347083,"discussion_content":"每节课估计看课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612148524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2172420,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/r2nR7Zkl5RP7LobsNKJ6wmmtyXrh4alNSAOldx1y1PSeFB1J2I14HE4I0BCgicPhubIOibPZAENzEpHEWTFjMNqg/132","nickname":"董董","note":"","ucode":"C222E275545158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342789,"discussion_content":"大佬，大量key集中过期会阻塞主线程么，之前的课说的会，但是4.0之后不是使用异步进行删除了么，怎么还会阻塞主线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610810503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2172420,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/r2nR7Zkl5RP7LobsNKJ6wmmtyXrh4alNSAOldx1y1PSeFB1J2I14HE4I0BCgicPhubIOibPZAENzEpHEWTFjMNqg/132","nickname":"董董","note":"","ucode":"C222E275545158","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342795,"discussion_content":"4.0+版本需要打开lazy-free，不阻塞主线程。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1610811612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342789,"ip_address":""},"score":342795,"extra":""},{"author":{"id":1022411,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/cb/8964faab.jpg","nickname":"-只是小小配角_","note":"","ucode":"EFC1CD54A23F39","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2172420,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/r2nR7Zkl5RP7LobsNKJ6wmmtyXrh4alNSAOldx1y1PSeFB1J2I14HE4I0BCgicPhubIOibPZAENzEpHEWTFjMNqg/132","nickname":"董董","note":"","ucode":"C222E275545158","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348886,"discussion_content":"我的认识：Redis的定期删除机制会自动扫描过期的key并删除数据释放内存，但大量key过期的时候，定期删除机制判断出过期key的量大于总key的25%时，会持续的进行删除过期key，这个过程如果持续时间过长，对主线程的内存操作会有影响，这应该是阻塞的原因吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612769331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342789,"ip_address":""},"score":348886,"extra":""},{"author":{"id":1101762,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/c2/a5b3ceaf.jpg","nickname":"helloworld","note":"","ucode":"003700A99A910B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":349014,"discussion_content":"课代表,我看了你上节课的总结,如果大了集中过期的是String 类型的大 key,他们的内存是连续的,释放的代价小,所以即使开启了 lazy-free,释放内存的操作也是在主线程执行的吧,这样就会导致主线程阻塞了.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612849620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342795,"ip_address":""},"score":349014,"extra":""}]},{"author":{"id":1620364,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b9/8c/b3820a21.jpg","nickname":"沉寂","note":"","ucode":"824ADCCB511019","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339379,"discussion_content":"厉害👍🏻\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609651497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319863,"discussion_content":"课代表~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604147735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2136414,"avatar":"https://static001.geekbang.org/account/avatar/00/20/99/5e/33481a74.jpg","nickname":"Lemon","note":"","ucode":"E52BB361B69825","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307524,"discussion_content":"搬好小板凳来评论区补课了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600676229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1312184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","nickname":"JulyRemember","note":"","ucode":"9E3D5D60D82999","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307472,"discussion_content":"还是想问下你们生产怎么使用redis命令啊，我们生产机器都没有权限，还是买的阿里云，只能出现问题到运维那看吧，redis的监控还是可以在阿里云看到的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600662485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1312184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","nickname":"JulyRemember","note":"","ucode":"9E3D5D60D82999","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307519,"discussion_content":"我记得可以开放有限的命令出来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600674954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307472,"ip_address":""},"score":307519,"extra":""},{"author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1312184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","nickname":"JulyRemember","note":"","ucode":"9E3D5D60D82999","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307612,"discussion_content":"没有就问他们拿，他们不给就让他们查问题。付费了还跟他们客气什么","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1600696280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307472,"ip_address":""},"score":307612,"extra":""},{"author":{"id":1998835,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/7f/f3/010d9634.jpg","nickname":"Owen Zhang","note":"","ucode":"48D2063B87AD8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1811495,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","nickname":"小袁","note":"","ucode":"3F5D8721F577D9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343619,"discussion_content":"说是这样说，但遇到紧急事件，让他们查花时间啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611112326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307612,"ip_address":""},"score":343619,"extra":""}]}]},{"had_liked":false,"id":249422,"user_name":"꧁子华宝宝萌萌哒꧂","can_delete":false,"product_type":"c1","uid":1165662,"ip_address":"","ucode":"3E5BBAF15064B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/c9/5e/b79e6d5d.jpg","comment_is_top":false,"comment_ctime":1600653481,"is_pvip":false,"discussion_count":3,"race_medal":1,"score":"83205032105","product_id":100056701,"comment_content":"<br>echo never &#47;sys&#47;kernel&#47;mm&#47;transparent_hugepage&#47;enabled <br>这个是不是得改成<br>echo never &gt; &#47;sys&#47;kernel&#47;mm&#47;transparent_hugepage&#47;enabled<br>这样？","like_count":20,"discussions":[{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307793,"discussion_content":"对","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600761044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581902,"discussion_content":"怎么改回来？ able？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659064298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2340552,"avatar":"https://static001.geekbang.org/account/avatar/00/23/b6/c8/35948bf5.jpg","nickname":"林蓝","note":"","ucode":"36E4445613E1C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585359,"discussion_content":"echo always &gt; /sys/kernel/mm/transparent_hugepage/enabled","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661499677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":581902,"ip_address":"北京"},"score":585359,"extra":""}]}]},{"had_liked":false,"id":249871,"user_name":"王世艺","can_delete":false,"product_type":"c1","uid":1899435,"ip_address":"","ucode":"04DA844568766B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fb/ab/c0c29cda.jpg","comment_is_top":false,"comment_ctime":1600838904,"is_pvip":true,"discussion_count":5,"race_medal":0,"score":"61730381048","product_id":100056701,"comment_content":"看了下，貌似是这样<br>redis 有一个aof_buf缓存,用来缓存新的aof操作信息。<br>正常情况下主线程每次循环都是先将aof_buff write，然后aof_buf是清空，<br>主线程会用去fsync，已经write的内容。<br>刷盘当时aways的情况下，主线程去直接调用redis_fsync。<br>但是当策略是EVERYSEC时，主线程会用aof_background_fsync中的bioCreateBackgroundJob(BIO_AOF_FSYNC,(void*)(long)fd,NULL,NULL);创建子线程去完成。<br><br>但是当io压力大的时候，也就是aof_buf有积压是。主线程在EVERYSEC模式下回去判断。是否有aofwrite在执行，并超过2s<br>如果超过2s主线程不会return，继续将aof_buf write<br>代码：nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));<br>但是因为子线程在aof_fd上fsync，所以write aof_fd的请求会被堵塞,这里write全是主线程在操作，堵塞直到fsync完成，能改变文件描述符（aof_fd）,主线程才可以继续响应请求","like_count":15,"discussions":[{"author":{"id":2131606,"avatar":"","nickname":"Geek_da4cfb","note":"","ucode":"DB59B24A249713","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321065,"discussion_content":"求大神解释一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604538918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2131606,"avatar":"","nickname":"Geek_da4cfb","note":"","ucode":"DB59B24A249713","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321063,"discussion_content":"没看懂呀𓀤𓀤𓀤","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604538905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320398,"discussion_content":"不知道我这样说的对不对，在everysec模式下，当aof_buff内的数据很多，也就是每秒产生的写操作很多，主线程会判断后台子进程的写操作是否有执行超过两秒的，有的话主线程就不会再启动一个后台子进程。我这里有个问题，就是无论什么时候，写入aof日志的后台子进程是只有一个还是会每秒创建一个。按楼主说的是写入aof日志的进程只会有一个，但子进程执行超过1秒但没超过两秒，则主线程还是会return。那这时候出现宕机是会丢失两秒的数据吗？还有子进程执行超过两秒，主线程就会阻塞子进程，自己来完成aof的日志写入。这里的aof_fd我可以理解为aof日志文件吗，那子进程写入都超过两秒了，主线程插手怎么保证数据不重复写入？怎么保证数据写入的准确性？还有主线程自己去写入aof日志了，那这时候redis对外的请求是不响应的，有什么方法优化吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604362699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1812201,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLm8skz4F7FGGBTXWUMia6qVEc00BddeXapicv5FkAx62GmOnUNEcE4scSR60AmappQoNdIQhccKsBA/132","nickname":"末日，成欢","note":"","ucode":"BBAEBB9C93558A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559735,"discussion_content":"只有1个线程， 但是会有一个队列， 相当于有一个线程在监控这个队列， 如果队列有了数据， 就执行aof日志文件同步刷盘。\n当执行aof文件追加时，一般情况写先放变动情况到放到aof_buf，然后将aof_buf的数据写到aof_fd描述符中， 在将aof_fd同步或异步刷盘， 当发生日志重写是，此时磁盘压力较大， fsync刷盘会被阻塞，redis会判断， 如果发生重写时， 队列中的数量是否超过1， 如果超过1 还小于2s, 就直接返回， 等待下一次写日志或者定时任务， 而如果已经超过了2s, 就必须要执行了， 否则就会出现数据丢失太多了， 所以说在日志重写时，会丢失的数据就变成了2s. 这里无法保证的。  还有你说的子进程写入超过两秒， 这里不是写入。 后台线程只是刷盘， 进程是重写aof文件， ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648898443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320398,"ip_address":""},"score":559735,"extra":""}]},{"author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320397,"discussion_content":"不知道我这样说的对不对，在everysec模式下，当aof_buff内的数据很多，也就是每秒产生的写操作很多，主线程会判断后台子进程的写操作是否有执行超过两秒的，有的话主线程就不会再启动一个后台子进程。我这里有个问题，就是无论什么时候，写入aof日志的后台子进程是只有一个还是会每秒创建一个。按楼主说的是写入aof日志的进程只会有一个，但子进程执行超过1秒但没超过两秒，则主线程还是会return。那这时候出现宕机是会丢失两秒的数据吗？还有子进程执行超过两秒，主线程就会阻塞子进程，自己来完成aof的日志写入。这里的aof_fd我可以理解为aof日志文件吗，那子进程写入都超过两秒了，主线程插手怎么保证数据不重复写入？怎么保证数据写入的准确性？还有主线程自己去写入aof日志了，那这时候redis对外的请求是不响应的，有什么方法优化吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604362682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249405,"user_name":"yeek","can_delete":false,"product_type":"c1","uid":1020629,"ip_address":"","ucode":"A1C71023113CB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","comment_is_top":false,"comment_ctime":1600649943,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"44550322903","product_id":100056701,"comment_content":"如果redis是独立部署，那么当内存不足时，淘汰策略和操作系统的swap机制 哪个会优先执行？<br><br>曾遇到过线上触发内存淘汰的场景，并未观察当时的swap情况，感谢老师的建议","like_count":10,"discussions":[{"author":{"id":1316758,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/96/846fc11b.jpg","nickname":"Richard","note":"","ucode":"893F958B9DD161","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333831,"discussion_content":"我认为这两者并不确定，因为淘汰是redis自己负责，而swap是操作系统提供的机制，redis只是认为自己有max_memory的内存可用，至于这里面的内存块哪些被swap了，redis是不知道也不需要关心的，它只要维护好自己霸占的那一块内存就行。而操作系统就要统筹全局，如果机器内存吃紧，它会选择一些不常用的内存swap到磁盘。而redis在访问这些被swap的数据时它是不知道被交换到磁盘的，这时后续的操作由操作系统内核负责，这个机制叫缺页处理，内核发现数据不在内存就会出发缺页中断，去磁盘读取数据到page cache，之后再copy到用户空间内存，然后再通知发起读调用的用户线程，而这一段时间通常就是我们说的io调用引起线程阻塞进而被调度出cpu的过程。","likes_number":26,"is_delete":false,"is_hidden":false,"ctime":1607646325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377159,"discussion_content":"两个是并行的 一个是redis进程 一个是操作系统。redis是操作系统上的一个进程而已","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622532474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1388092,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2e/3c/eae43616.jpg","nickname":"sid","note":"","ucode":"3D1F9169A19D29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311264,"discussion_content":"redis.conf配置文件中搜索maxmemory，有默认redis能使用的最大内存配置","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602294905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577471,"discussion_content":"操作系统肯定对应用程序透明啊, redis根本不知道有什么swap, 无感知","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656133918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277461,"user_name":"小可","can_delete":false,"product_type":"c1","uid":1006735,"ip_address":"","ucode":"8834AF621FA67D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","comment_is_top":false,"comment_ctime":1612423067,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35972161435","product_id":100056701,"comment_content":"redis变慢问题优化自我总结：<br>1.cpu：redis实例绑定同一个cpu物理核；网络中断和redis实例绑定同一个cpu socket<br>2.内存：关闭大内存页，观察swap，增加物理内存<br>3.磁盘：数据丢失容忍度aof策略选择；AOF使用SDD<br>4.操作：集合操作，bigkey删除，返回集合改为SCAN多次操作<br>5.过期：过期时间加随机数<br>6.监控：基线性能--intrinsic-latency; monitor; ;latency","like_count":8},{"had_liked":false,"id":304998,"user_name":"花儿少年","can_delete":false,"product_type":"c1","uid":1318540,"ip_address":"","ucode":"CFE4F64243673B","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","comment_is_top":false,"comment_ctime":1627740828,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23102577308","product_id":100056701,"comment_content":"之前出现过redis变慢的问题，导致系统整体变慢，系统大概几小时内30%的请求都很慢，基本到不可用的情况了。<br>具体情况是某同学(我)在新业务的时候添加了一个新的key，由于符合hash的特性于是直接使用了redission 的map，上线后由于逻辑问题并没有执行到，但是由于仅仅是缓存嘛，业务也没问题，后来由于另外的项目中覆盖到这个case发现有问题，然后就把逻辑修复了。<br>上线后redis集群的proxy节点的一两个节点cpu使用率飙高，但是没想明白为啥，所以也没回滚，然后第二天中午流量变大了，就会有更多的proxy节点cpu使用率100%，这个时候业务就开始大量报警了，因为接口开始部分超时，然后紧急把那块缓存的代码删除发布上线，然后系统就恢复了。<br>过程讲完了，接下来说原因，先说下redis集群的架构，流量经过proxy节点分发给redis，业务仅感知到一个vip节点，那么这种情况下，proxy节点就需要对客户端的请求进行保序的操作，这也就是说先到的请求没返回时，后来的请求也不能返回；redisson的map实现是加入了lua脚本的，同时代码里对单个key设置了过期时间，导致整个脚本很复杂很消耗性能，那么redis本身就会变慢，但是不是很明显，同时加上proxy节点，返回到客户端就很慢了，同时加上proxy保序的特点，更加剧了耗时。redis是分片的，所以量小的时只有少部分节点受影响，但是量大时所有的分片上都有这种慢请求，拖慢了整体的性能。。<br>血泪教训，使用不熟悉的类库时，一定要多看看源码，对公司的产品的特性要熟悉，对隐患要及时止损，想着问题不大也没回滚，简直天真。<br>不过redisson真的好用。yyds","like_count":6},{"had_liked":false,"id":249403,"user_name":"yeek","can_delete":false,"product_type":"c1","uid":1020629,"ip_address":"","ucode":"A1C71023113CB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","comment_is_top":false,"comment_ctime":1600649461,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"18780518645","product_id":100056701,"comment_content":"当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞。所以，如果后台子线程执行的 fsync 频繁阻塞的话（比如 AOF 重写占用了大量的磁盘 IO 带宽），主线程也会阻塞，导致 Redis 性能变慢。<br><br><br>这段没懂，redis主线程和后台子线程之间有状态通信吗？主线程调用fsync对子线程而言是任务队列的方式还是同步调用的方式？ 我去看看源码吧……","like_count":4,"discussions":[{"author":{"id":1388092,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2e/3c/eae43616.jpg","nickname":"sid","note":"","ucode":"3D1F9169A19D29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311273,"discussion_content":"主线程使用后台子线程执行fsync。\n当下一次主线程又要让子线程执行fsync的时候，会检查上次的fsync是否完毕，如果没有完毕，主线程会阻塞。\n影响子线程fsync的最大因素就是磁盘I/O，因此当存在其他任务和fsync竞争磁盘I/O的时候，就会影响到主线程（阻塞）。学到这里，我们都知道，redis用到磁盘I/O的地方有RDB和AOF。\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602295721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581903,"discussion_content":"线程间通信","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659065632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196293,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/05/5ba603f2.jpg","nickname":"小李子","note":"","ucode":"C5593E33CA6F4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345017,"discussion_content":"子线程堵了就堵了，主线程监控就监控，为什么要把自己也给堵了，这里的确没讲清楚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611640120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1196293,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/05/5ba603f2.jpg","nickname":"小李子","note":"","ucode":"C5593E33CA6F4C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577472,"discussion_content":"子线程堵了你不管啊? 磁盘都写不过来了你还继续在那处理业务啊?  那就甭管磁盘了呗, 不持久化?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656134078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":345017,"ip_address":""},"score":577472,"extra":""}]},{"author":{"id":1589208,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTITcwicqBDYzXtLibUtian172tPs7rJpqG1Vab4oGjnguA9ziaYjDCILSGaS6qRiakvRdUEhdmSG0BGPKw/132","nickname":"大饶Raysir","note":"","ucode":"0AFA191420A30D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312411,"discussion_content":"我的理解是同步，主线程同步调用fsync后，子线程异步执行IO任务时，由于AOF重写导致磁盘IO带宽打满，子线程的IO任务就会阻塞。此时主线程通过对子线程的监控机制，发现子线程阻塞，然后阻塞自身。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602679707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249397,"user_name":"东","can_delete":false,"product_type":"c1","uid":1043947,"ip_address":"","ucode":"0FF5018422CEA9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/eb/88cac7a5.jpg","comment_is_top":false,"comment_ctime":1600648420,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14485550308","product_id":100056701,"comment_content":"“8. 是否运行了 Redis 主从集群？如果是的话，把主库实例的数据量大小控制在 2~4GB，以免主从复制时，从库因加载大的 RDB 文件而阻塞。” 这个2~4G的经验值和主库的内存大小无关吗？比如主从库内存都是64G， 这个主库数据量依然是2~4G？","like_count":3,"discussions":[{"author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307761,"discussion_content":"涉及到fork时会不会阻塞的问题，和机器的实际内存无关，这么说来大内存意义不大","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1600752586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315663,"user_name":"日落黄昏下","can_delete":false,"product_type":"c1","uid":1464032,"ip_address":"","ucode":"A97725B81D86BC","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/e0/d34f57b3.jpg","comment_is_top":false,"comment_ctime":1633939667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5928906963","product_id":100056701,"comment_content":"除了aof重写可能造成堵塞，在aof everysec时，如果发现此时正在进行fsync，并且超过2s时，会堵塞主线程等待。可监控aof-pending-bio-fsync和aof-delay-fsync信息，并且会有aof fsync is taking too long 的日志。","like_count":1},{"had_liked":false,"id":306836,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1628739672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923706968","product_id":100056701,"comment_content":"对于Swap机制,关闭应该是最方便的解决方案,包括在Kubernetes集群中,对于部署的节点也是要求关闭swap的,关闭方式如下swapoff -a","like_count":1},{"had_liked":false,"id":286448,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1617324464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912291760","product_id":100056701,"comment_content":"Redis 变慢？按（老师 + Kaito）一波操作下来不快也得快！","like_count":1},{"had_liked":false,"id":354402,"user_name":"Geek_b14c55","can_delete":false,"product_type":"c1","uid":2027632,"ip_address":"浙江","ucode":"C98EAEC045F13D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/MOuCWWOnoQjOr8KjicQ84R7xu6DRcfDv3VAuHseGJ1gxXicKJboA24vOcrcJickTJPwFAU38VuwCGGkGq7f8WkTIg/132","comment_is_top":false,"comment_ctime":1660361336,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1660361336","product_id":100056701,"comment_content":"不使用复杂度过高的命令，或用其他方式代替实现（放在客户端做） ，麻烦请问一下大家，这个客户端指的是应用程序吗","like_count":0,"discussions":[{"author":{"id":1527581,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/270T9KAFd4oCxXXB1giaMDaJuTQVib8gPt77VkM5dbS3hW60kwTNnxMYpVibwWVdnASCrymBbwT7HI77URia0KUylw/132","nickname":"Geek_7ee455","note":"","ucode":"76C69F26B0F653","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585143,"discussion_content":"是的，例如取交集，你可以用java在内存里做，而不用redis的命令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661341939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350390,"user_name":"卡尔","can_delete":false,"product_type":"c1","uid":2887573,"ip_address":"","ucode":"B3F5506B938986","user_header":"https://static001.geekbang.org/account/avatar/00/2c/0f/95/275d534e.jpg","comment_is_top":false,"comment_ctime":1656872795,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656872795","product_id":100056701,"comment_content":"aof的everysec策略下，子线程会导致主线程阻塞我说下个人观点。<br>作者的意思是在 ererysec下，子线程每秒去fsync，但是主线程会监测该子线程的fsync的执行情况。有个策略就是，若是主线程发现已过2s（也就是上次没执行完）了，子线程的上一次的fsync还没有执行完成，主线程就会阻塞，直到子线程当前的fsync完成，才返回。<br>当然影响 子线程的fsync，导致其变慢的因素是磁盘io的效率较低，当然影响磁盘io效率的有很多，其中aof重写占据大量的磁盘io资源就是其中之一。","like_count":0},{"had_liked":false,"id":346638,"user_name":"Geek_9adefb","can_delete":false,"product_type":"c1","uid":2980933,"ip_address":"","ucode":"DE7D4E98F892AE","user_header":"","comment_is_top":false,"comment_ctime":1653308954,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1653308954","product_id":100056701,"comment_content":"主从同步期间，从节点能接受客户端请求吗","like_count":0,"discussions":[{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577474,"discussion_content":"要看哪个阶段, 从库已经在加载rdb了就不行了  在主线程操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656134201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342040,"user_name":"毛薛强","can_delete":false,"product_type":"c1","uid":1788083,"ip_address":"","ucode":"DF632A3A881D0C","user_header":"https://static001.geekbang.org/account/avatar/00/1b/48/b3/fdefc913.jpg","comment_is_top":false,"comment_ctime":1649987683,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649987683","product_id":100056701,"comment_content":"no-appendfsync-on-rewrite no 的时候不调用fsync，但是会调用write吧，如果调用了write，那么实例宕机是不会丢数据的，只有服务器宕机才会丢数据，应该是这样的吧","like_count":0},{"had_liked":false,"id":331335,"user_name":"Geek_0bba55","can_delete":false,"product_type":"c1","uid":2088137,"ip_address":"","ucode":"3B647E1EB3C707","user_header":"","comment_is_top":false,"comment_ctime":1642555819,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1642555819","product_id":100056701,"comment_content":"大内存那里有个点不明白:Redis是单线程操作，不存在并发问题，为什么还要用写时复制的？","like_count":0,"discussions":[{"author":{"id":1413864,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ib7YEKkLKotibRicGez0ZnydE9iczo8SMQlpkHNJeEFvzrJNMZZQKEhJHqd8lBG724jWZvSVO4deWARw4FzM5ibBJ4w/132","nickname":"zzsstt","note":"","ucode":"BA7F2BC4BCB169","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547724,"discussion_content":"这个是linux系统里面fork机制一部分，RDB文件生成过程时是通过Redis进程fork出新的子进程处理的，这一块可以看第05篇文章的内容，和下面评论里面提到的对fork的解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642839993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327324,"user_name":"树心","can_delete":false,"product_type":"c1","uid":1589523,"ip_address":"","ucode":"6C329F0FF798B9","user_header":"https://static001.geekbang.org/account/avatar/00/18/41/13/ab14ad25.jpg","comment_is_top":false,"comment_ctime":1640066373,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1640066373","product_id":100056701,"comment_content":"透明大页和标准大页的区别是什么？","like_count":0},{"had_liked":false,"id":313277,"user_name":"贺子","can_delete":false,"product_type":"c1","uid":2076283,"ip_address":"","ucode":"A64DC9D9CF7CCD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/ae/7b/47200692.jpg","comment_is_top":false,"comment_ctime":1632362889,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632362889","product_id":100056701,"comment_content":"老师说的关闭大叶的命令是关闭透明大叶的命令吧","like_count":0},{"had_liked":false,"id":296111,"user_name":"manatee","can_delete":false,"product_type":"c1","uid":1041112,"ip_address":"","ucode":"708D90E7A265BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e2/d8/f0562ede.jpg","comment_is_top":false,"comment_ctime":1622767980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622767980","product_id":100056701,"comment_content":"请问老师如何判断是否有bigkey存在？当前库中有约4000万个key","like_count":0},{"had_liked":false,"id":296003,"user_name":"Architect","can_delete":false,"product_type":"c1","uid":1311766,"ip_address":"","ucode":"6CA6BC22AB3213","user_header":"https://static001.geekbang.org/account/avatar/00/14/04/16/91e82e9e.jpg","comment_is_top":false,"comment_ctime":1622700461,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1622700461","product_id":100056701,"comment_content":"多大的key算bigkey？","like_count":0,"discussions":[{"author":{"id":1721699,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/45/63/005d03b2.jpg","nickname":"QD账号","note":"","ucode":"C0C8ECA5AB3A20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572868,"discussion_content":"返回数据的时候是redis阻塞的吗？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653019726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318540,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1e/8c/450fe5cb.jpg","nickname":"花儿少年","note":"","ucode":"CFE4F64243673B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386715,"discussion_content":"一般认为几百kb就比较大了，1mb就要好久返回了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627740949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295654,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1622532382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622532382","product_id":100056701,"comment_content":"其实这里的问题可以扩展到很多点 因为本质上redis是部署在linux上的。那么作为一个内存数据库必然受制于两个因素 一是内存分配 二是数据持久化。<br><br>我们先来看 内存分配。之前老师解释过内存分配redis用的jmalloc 这种特性会造成一定的数据碎片 另外与free结合使用时 实际上是内存标记回收所以内存碎片是天然存在的。<br><br>再来看数据持久化 此处用的是fork &amp;&amp; fsync &amp;&amp; write。fsync毫无疑问是write through的 而write显然是write back。 这两种模式自身的问题就不做讨论了 毕竟不是linux课程。所以因为文件系统自身机制如ext3 ext4等之类的问题依然会限制redis子进程落盘 导致主进程监控时期卡顿","like_count":0},{"had_liked":false,"id":294933,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1622157644,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622157644","product_id":100056701,"comment_content":"老师的总结太棒了","like_count":0},{"had_liked":false,"id":289327,"user_name":"Geek_e0c185","can_delete":false,"product_type":"c1","uid":2363997,"ip_address":"","ucode":"094D3ED137C437","user_header":"","comment_is_top":false,"comment_ctime":1618977585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618977585","product_id":100056701,"comment_content":"内存页表写时复制技术主线程只需要复制改动的数据即可，老师说内存大页在写实复制时会复制内存大页的所有数据，会不会有矛盾？还是说内存页表和内存大页的写时复制需要复制的数据不一样？","like_count":0},{"had_liked":false,"id":285306,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1616730172,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1616730172","product_id":100056701,"comment_content":"没有发现慢查询，也没有同时删除大量的 keys，那么接下来呢？<br><br>作为 Redis 菜鸟，我觉得大多数情况下，AOF 写回策略不需要 always 的配置。<br><br>高速固态硬盘 SSD 已经成为性能优化的“杀手锏”，如果不差钱……<br><br>操作系统内存 swap 被触发之后，会影响 Redis 主 IO 线程，那么延续上面 SSD 的思路，加大内存应该可以解决部分问题。<br><br>对于关闭内存大页机制的办法，我在 macOS 上没有找到 &#47;sys&#47;kernel 目录。<br><br>小结中的 9 个检查点 Checklist，让我觉得专栏物超所值。课代表 @kaito 令人发指的给出了 11 个检查点，让我有了秘籍在手，天下我有的感觉。<br><br>对于课后题，没有遇到过 Redis 变慢的情况，如果以后遇到了，就回到这篇专栏文章，应该能找到线索。<br><br>虽然暂时没有接触或者运维业务中的 Redis ，但是这个专栏同时也讲了很多操作系统、底层架构方面的内容，学海无涯。","like_count":0},{"had_liked":false,"id":284828,"user_name":"Geek_mysql45","can_delete":false,"product_type":"c1","uid":2084379,"ip_address":"","ucode":"DECFFE89B49974","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7MkIibc8UBwDt7dNeeNmx9IMqmI98Do8icxZcmfsMk99ibeXUo9ficwR1dxF5CrDHJ55603icCpKF7cxw/132","comment_is_top":false,"comment_ctime":1616488306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616488306","product_id":100056701,"comment_content":"这一节老师总结的定位思路很清晰明了，学习了。果然还是要对redis各方面机制都了解后，才能遇到问题不抓耳挠腮，心中有redis系统架构，再去看问题就有了方向。","like_count":0},{"had_liked":false,"id":284528,"user_name":"陌兮","can_delete":false,"product_type":"c1","uid":1415619,"ip_address":"","ucode":"00CE47CAECD5CD","user_header":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","comment_is_top":false,"comment_ctime":1616320210,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1616320210","product_id":100056701,"comment_content":"&quot;如果既需要高性能又需要高可靠性，最好使用高速固态盘作为 AOF 日志的写入盘。&quot;<br>老师，这一段有点疑惑，既然redis会存在频繁的aof文件重写，那么使用ssd盘作为aof的写入盘就会频繁的刷新磁盘数据。对于ssd这种有刷盘次数限制的存储硬盘来说，那不是很快就报废了？还有一个问题想要请教下：关于aof写盘是否为磁盘顺写？感觉如果是顺序写和顺序读，使用普通的机械硬盘也是可以用的吧？","like_count":0},{"had_liked":false,"id":284013,"user_name":"风含叶","can_delete":false,"product_type":"c1","uid":1162800,"ip_address":"","ucode":"7AE8D3963343AB","user_header":"https://static001.geekbang.org/account/avatar/00/11/be/30/1154657e.jpg","comment_is_top":false,"comment_ctime":1616037263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616037263","product_id":100056701,"comment_content":"看完这篇有一种 醍醐灌顶的 感觉","like_count":0},{"had_liked":false,"id":275998,"user_name":"樱小路依然","can_delete":false,"product_type":"c1","uid":1269957,"ip_address":"","ucode":"DBA9FF68015FE5","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","comment_is_top":false,"comment_ctime":1611740664,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1611740664","product_id":100056701,"comment_content":"虽然没遇到过redis变慢的问题,但是我之前工作中遇到过 rocketmq 由于过多使用swap导致卡死的问题,当时经过排查问题后,由于内存充足,没有其他应用同机部署,所以当时的处理方式是将 swap 关闭了,没有深究问题原因","like_count":0,"discussions":[{"author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370017,"discussion_content":"可能是某一个 cpu 内存不足，用上了 swap","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619253107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272724,"user_name":"雨果跨境","can_delete":false,"product_type":"c1","uid":1453146,"ip_address":"","ucode":"87173F7DCBA0C5","user_header":"","comment_is_top":false,"comment_ctime":1610254638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610254638","product_id":100056701,"comment_content":"程序上有些可以使用pipline减少多次请求 算是一种吗","like_count":0},{"had_liked":false,"id":272637,"user_name":"雪狼🇨🇳👣","can_delete":false,"product_type":"c1","uid":1011364,"ip_address":"","ucode":"EC807126C34D66","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/a4/c93e70f9.jpg","comment_is_top":false,"comment_ctime":1610182281,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610182281","product_id":100056701,"comment_content":"关闭了aof和rdb，只当作缓存使用，但是实际使用过程中还是会遇到响应延迟有波动的情况，一个空的redis的db，对同一个key每秒查询一次，实际结果应该是返回空数据，正常情况下响应时间在几ms，但是有时候会波动到800ms以上。<br>redis和查询的代码部署在同一台机器上，通过127.0.0.1连接的。<br>因为redis里实际存的数据是空的，所以应该和查询耗时&amp;swap都没什么关系吧？<br>然后既然aof和rdb都关闭了，那应该跟写磁盘也没什么关系？<br>还有什么可能导致这种响应的波动呢？<br>脚本里会定时读写mysql数据库，mysql库部署在其他机器上，所以会产生网络IO，这个对本地的redis的响应可能有影响吗？<br>","like_count":0},{"had_liked":false,"id":265626,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1606964275,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606964275","product_id":100056701,"comment_content":"Redis性能问题排查思路<br>1.基线性能<br>2.慢查询和阻塞命令（keys)<br>3.key删除<br>4.持久化<br>5.大内存页<br>6.内存不足","like_count":0},{"had_liked":false,"id":264973,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1300285,"ip_address":"","ucode":"A99C9C890F95E4","user_header":"https://static001.geekbang.org/account/avatar/00/13/d7/3d/a076faf1.jpg","comment_is_top":false,"comment_ctime":1606725397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606725397","product_id":100056701,"comment_content":" 两种配置项<br>1、appendfsync everysec 和 no-appendfsync-on-rewrite yes<br>2、appendfsync no 和 no-appendfsync-on-rewrite no<br><br>这两种会有区别吗？我理解的是 都不会调用fsync","like_count":0},{"had_liked":false,"id":260635,"user_name":"数学汤家凤","can_delete":false,"product_type":"c1","uid":2029485,"ip_address":"","ucode":"DE84E777C384AD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","comment_is_top":false,"comment_ctime":1605075279,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605075279","product_id":100056701,"comment_content":"关掉swap，不使用 AOF、RDB，简简单单当个缓存用","like_count":0},{"had_liked":false,"id":258391,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1604407615,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604407615","product_id":100056701,"comment_content":"问题：如果该实例在一个 Redis 切片集群中，可以增加 Redis 集群的实例个数，来分摊每个实例服务的数据量，进而减少每个实例所需的内存量。<br>这里增加实例，是指通过增加物理机器来部署实例吧？","like_count":0},{"had_liked":false,"id":256878,"user_name":"天下","can_delete":false,"product_type":"c1","uid":2106744,"ip_address":"","ucode":"B33770BF714AC8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ico1JZVibIW4431SMBG9EIH7Gu4nweILy8kPXAtibWwZ2hQcuHUoFR1Y2Zg66hXY94xRbdkiaNRAIDBEkSunOtpibKA/132","comment_is_top":false,"comment_ctime":1603771298,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603771298","product_id":100056701,"comment_content":"收获满满！！","like_count":0},{"had_liked":false,"id":250089,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1600930904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600930904","product_id":100056701,"comment_content":"有时候需要内存大页怎么办？如何判断是否需要启用内存大页机制呢？","like_count":0},{"had_liked":false,"id":250077,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1600926827,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1600926827","product_id":100056701,"comment_content":"请问下老师什么样的key叫bigkey呢？","like_count":0,"discussions":[{"author":{"id":1388092,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2e/3c/eae43616.jpg","nickname":"sid","note":"","ucode":"3D1F9169A19D29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311266,"discussion_content":"value占用内存使用量大的key。\n课代表前面说了，查看实例中的bigkey，可以执行命令\nredis-cli -h ${host} -p ${pt} -a {password} --bigkeys 来查看 （如果redis没有设置密码的话，-a参数可以不加）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602295239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249759,"user_name":"Sunny","can_delete":false,"product_type":"c1","uid":1067570,"ip_address":"","ucode":"FE57B69A9CF91D","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/32/23db38ab.jpg","comment_is_top":false,"comment_ctime":1600780806,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1600780806","product_id":100056701,"comment_content":"set&#47;list 类型算bigkey 吗？ 考虑到主从库同步的时候，操作这个类型很耗时，求证下。","like_count":0,"discussions":[{"author":{"id":1388092,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2e/3c/eae43616.jpg","nickname":"sid","note":"","ucode":"3D1F9169A19D29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311269,"discussion_content":"是不是bigkey不是看数据类型，本质是看你这个key的value存了多少数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602295318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249752,"user_name":"王世艺","can_delete":false,"product_type":"c1","uid":1899435,"ip_address":"","ucode":"04DA844568766B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fb/ab/c0c29cda.jpg","comment_is_top":false,"comment_ctime":1600779538,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1600779538","product_id":100056701,"comment_content":"当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞<br><br>老师这段代码逻辑在哪里","like_count":0,"discussions":[{"author":{"id":1108924,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/bc/6ccac4bb.jpg","nickname":"武文文武","note":"","ucode":"5288366646A15B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364273,"discussion_content":"server. c或者aof. c，可以搜索关键字:  write ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617428257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249604,"user_name":"云学","can_delete":false,"product_type":"c1","uid":1027233,"ip_address":"","ucode":"366AE90BA06356","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a1/43d83698.jpg","comment_is_top":false,"comment_ctime":1600702533,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600702533","product_id":100056701,"comment_content":"除了绑定cpu也可以提升redis进程静态优先级，得到更多cpu调度","like_count":0},{"had_liked":false,"id":249567,"user_name":"土豆白菜","can_delete":false,"product_type":"c1","uid":1029749,"ip_address":"","ucode":"D1551C729D33E0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b6/75/32c19395.jpg","comment_is_top":false,"comment_ctime":1600693984,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600693984","product_id":100056701,"comment_content":"老师会讲布隆过滤器吗？","like_count":0},{"had_liked":false,"id":249421,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1600653377,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600653377","product_id":100056701,"comment_content":"可以再仔细分析一下，在虚拟机上部署REDIS实例时，由于虚拟化软件本身的内存管理算法导致的SWAP分析过程和在物理机上部署时的不同么？","like_count":0}]}