{"id":646774,"title":"13｜JDBC访问框架：如何抽取JDBC模板并隔离数据库？","content":"<p>你好，我是郭屹，今天我们继续手写MiniSpring。从这节课开始我们进入MiniSpring一个全新的部分：JdbcTemplate。</p><p>到现在为止，我们的MiniSpring已经成了一个相对完整的简易容器，具备了基本的IoC和MVC功能。现在我们就要在这个简易容器的基础之上，继续添加新的特性。首先就是<strong>数据访问的特性</strong>，这是任何一个应用系统的基本功能，所以我们先实现它。这之后，我们的MiniSpring就基本落地了，你真的可以以它为框架进行编程了。</p><p>我们还是先从标准的JDBC程序开始探讨。</p><h2>JDBC通用流程</h2><p>在Java体系中，数据访问的规范是JDBC，也就是Java Database Connectivity，想必你已经熟悉或者至少听说过，一个简单而典型的JDBC程序大致流程是怎样的呢？我们一步步来看，每一步我也会给你放上一两个代码示例帮助你理解。</p><p>第一步，加载数据库驱动程序。</p><pre><code class=\"language-plain\">\tClass.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");\n</code></pre><p>或者直接new Driver();也可以。</p><p>这是第一步，因为JDBC只是提供了一个访问的API，具体访问数据库的工作是由不同厂商提供的数据库driver来实现的，Java只是规定了这个通用流程。对同一种数据库，可以有不同的driver，我们也可以自己按照协议实现一个driver，我自己就曾在1996年实现了中国第一个JDBC Driver。</p><!-- [[[read_end]]] --><p>这里我多提一句，Java的这种设计很是巧妙，让应用程序的API与对应厂商的SPI分隔开了，它们可以各自独立进化，这是通过一种叫“桥接模式”的办法达到的。这节课你就能切身感受到这种模式的应用效果了。</p><p>第二步，获取数据库连接。</p><pre><code class=\"language-plain\">\tcon = DriverManager.getConnection(\"jdbc:sqlserver://localhost:1433;databasename=DEMO;user=testuser;password=test;\");\n</code></pre><p>getConnection()方法的几个参数，分别表示数据库URL、登录数据库的用户名和密码。　<br>\n这个时候，我们利用底层driver的功能建立了对数据库的连接。不过要注意了，建立和断开连接的过程是很费时间的，所以后面我们会利用数据库连接池技术来提高性能。</p><p>第三步，通过Connection对象创建Statement对象，比如下面这两条。</p><pre><code class=\"language-plain\">\tstmt = con.createStatement(sql);&nbsp;\n</code></pre><pre><code class=\"language-plain\">\tstmt = con.prepareStatement(sql);\n</code></pre><p>Statement是对一条SQL命令的包装。</p><p>第四步，使用Statement执行SQL语句，还可以获取返回的结果集ResultSet。</p><pre><code class=\"language-plain\">\trs = stmt.executeQuery();\n</code></pre><pre><code class=\"language-plain\">stmt.executeUpdate();\n</code></pre><p>第五步，操作ResultSet结果集，形成业务对象，执行业务逻辑。</p><pre><code class=\"language-plain\">\tUser rtnUser = null;\n\tif (rs.next()) {\n\t\trtnUser = new User();\n\t\trtnUser.setId(rs.getInt(\"id\"));\n\t\trtnUser.setName(rs.getString(\"name\"));\n\t}\n</code></pre><p>第六步，回收数据库资源，关闭数据库连接，释放资源。</p><pre><code class=\"language-plain\">\trs.close();\n\tstmt.close();\n\tcon.cloase();\n</code></pre><p>这个数据访问的套路或者定式，初学Java的程序员都比较熟悉。写多了JDBC程序，我们会发现Java里面访问数据的程序结构都是类似的，不一样的只是具体的SQL语句，然后还有一点就是执行完SQL语句之后，每个业务对结果的处理是不同的。只要稍微用心思考一下，你就会想到应该把它做成一个模板，方便之后使用，自然会去抽取JdbcTemplate。</p><h2>抽取JdbcTemplate</h2><p>抽取的基本思路是<strong>动静分离，将固定的套路作为模板定下来，变化的部分让子类重写</strong>。这是常用的设计模式，基于这个思路，我们考虑提供一个JdbcTemplate抽象类，实现基本的JDBC访问框架。</p><p>以数据查询为例，我们可以在这个框架中，让应用程序员传入具体要执行的SQL语句，并把返回值的处理逻辑设计成一个模板方法让应用程序员去具体实现。</p><pre><code class=\"language-plain\">package com.minis.jdbc.core;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\n\npublic abstract class JdbcTemplate {\n\tpublic JdbcTemplate() {\n\t}\n\tpublic Object query(String sql) {\n\t\tConnection con = null;\n\t\tPreparedStatement stmt = null;\n\t\tResultSet rs = null;\n\t\tObject rtnObj = null;\n\t\t\n\t\ttry {\n\t\t\tClass.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");\n\t\t\tcon = DriverManager.getConnection(\"jdbc:sqlserver://localhost:1433;databasename=DEMO;user=sa;password=Sql2016;\");\n\n\t\t\tstmt = con.prepareStatement(sql);\n\t\t\trs = stmt.executeQuery();\n\t\t\t\n\t\t\t//调用返回数据处理方法，由程序员自行实现\n\t\t\trtnObj = doInStatement(rs);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\trs.close();\n\t\t\t\tstmt.close();\n\t\t\t\tcon.close();\n\t\t\t} catch (Exception e) {\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn rtnObj;\n\t}\n\n\tprotected abstract&nbsp; Object doInStatement(ResultSet rs);\n}\n\n</code></pre><p>通过上述代码我们可以看到，query()里面的代码都是模式化的，SQL语句作为参数传进来，最后处理SQL返回数据的业务代码，留给应用程序员自己实现，就是这个模板方法doInStatement()。这样就实现了动静分离。<br>\n比如说，我们数据库里有一个数据表User，程序员可以用一个数据访问类UserJdbcImpl进行数据访问，你可以看一下代码。</p><pre><code class=\"language-plain\">package com.test.service;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport com.minis.jdbc.core.JdbcTemplate;\nimport com.test.entity.User;\n\npublic class UserJdbcImpl extends JdbcTemplate {\n\t@Override\n\tprotected Object doInStatement(ResultSet rs) {\n        //从jdbc数据集读取数据，并生成对象返回\n\t\tUser rtnUser = null;\n\t\ttry {\n\t\t\tif (rs.next()) {\n\t\t\t\trtnUser = new User();\n\t\t\t\trtnUser.setId(rs.getInt(\"id\"));\n\t\t\t\trtnUser.setName(rs.getString(\"name\"));\n\t\t\t\trtnUser.setBirthday(new java.util.Date(rs.getDate(\"birthday\").getTime()));\n\t\t\t} else {\n\t\t\t}\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn rtnUser;\n\t}\n}\n</code></pre><p>应用程序员在自己实现的doInStatement()里获得SQL语句的返回数据集并进行业务处理，返回一个业务对象给用户类。</p><p>而对外提供服务的UserService用户类就可以简化成下面这样。</p><pre><code class=\"language-plain\">package com.test.service;\n\nimport com.minis.jdbc.core.JdbcTemplate;\nimport com.test.entity.User;\n\npublic class UserService {\n\tpublic User getUserInfo(int userid) {\n\t\tString sql = \"select id, name,birthday from users where id=\"+userid;\n\t\tJdbcTemplate jdbcTemplate = new UserJdbcImpl();\n\t\tUser rtnUser = (User)jdbcTemplate.query(sql);\n\t\t\n\t\treturn rtnUser;\n\t}\n}\n</code></pre><p>我们看到，用户类简单地创建一个UserJdbcImpl对象，然后执行query()即可，很简单。</p><p>有了这个简单的模板，我们就做到了把JDBC程序流程固化下来，分离出变化的部分，让应用程序员只需要管理SQL语句并处理返回的数据就可以了。</p><p>这是一个实用的结构，我们就基于这个结构继续往前走。</p><h2>通过Callback模式简化业务实现类</h2><p>上面抽取出来的Tempalte，我们也看到了，如果只是停留在现在的这一步，那应用程序的工作量还是很大的，对每一个数据表的访问都要求手写一个对应的JdbcImpl实现子类，很繁琐。为了不让每个实体类都手写一个类似于UserJdbcImpl的类，我们可以采用Callback模式来达到目的。</p><p>先介绍一下Callback模式，它是把一个需要被调用的函数作为一个参数传给调用函数。你可以看一下基本的做法。</p><p>先定义一个回调接口。</p><pre><code class=\"language-plain\">public interface Callback {\n&nbsp; &nbsp; void call();\n}\n</code></pre><p>有了这个Callback接口，任务类中可以把它作为参数，比如下面的业务任务代码。</p><pre><code class=\"language-plain\">public class Task {\n&nbsp; &nbsp; public void executeWithCallback(Callback callback) {\n&nbsp; &nbsp; &nbsp; &nbsp; execute(); //具体的业务逻辑处理\n&nbsp; &nbsp; &nbsp; &nbsp; if (callback != null) callback.call();\n&nbsp; &nbsp; }\n}\n</code></pre><p>这个任务类会先执行具体的业务逻辑，然后调用Callback的回调方法。</p><p>用户程序如何使用它呢？</p><pre><code class=\"language-plain\">&nbsp; &nbsp; public static void main(String[] args) {\n&nbsp; &nbsp; &nbsp; &nbsp; Task task = new Task();\n&nbsp; &nbsp; &nbsp; &nbsp; Callback callback = new Callback() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void call() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"callback...\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; };\n&nbsp; &nbsp; &nbsp; &nbsp; task.executeWithCallback(callback);\n&nbsp; &nbsp; }\n</code></pre><p>先创建一个任务类，然后定义具体的回调方法，最后执行任务的同时将Callback作为参数传进去。这里可以看到，回调接口是一个单一方法的接口，我们可以采用函数式编程进一步简化它。</p><pre><code class=\"language-plain\">&nbsp; &nbsp; public static void main(String[] args) {\n&nbsp; &nbsp; &nbsp; &nbsp; Task task = new Task();\n&nbsp; &nbsp; &nbsp; &nbsp; task.executeWithCallback(()-&gt;{System.out.println(\"callback;\")});\n&nbsp; &nbsp; }\n</code></pre><p>上面就是Callback模式的实现，我们把一个回调函数作为参数传给了调用者，调用者在执行完自己的任务后调用这个回调函数。</p><p>现在我们就按照这个模式改写JdbcTemplate 的query()方法。</p><pre><code class=\"language-plain\">\tpublic Object query(StatementCallback stmtcallback) {\n\t\tConnection con = null;\n\t\tStatement stmt = null;\n\t\t\n\t\ttry {\n\t\t\tClass.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");\n\t\t\tcon = DriverManager.getConnection(\"jdbc:sqlserver://localhost:1433;databasename=DEMO;user=sa;password=Sql2016;\");\n\n\t\t\tstmt = con.createStatement();\n\t\t\t\n\t\t\treturn stmtcallback.doInStatement(stmt);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tstmt.close();\n\t\t\t\tcon.close();\n\t\t\t} catch (Exception e) {\t\t\t\t\n\t\t\t}\n\t\t}\t\t\n\t\treturn null;\n\t}\n</code></pre><p>从代码中可以看出，在query()方法中增加了一个参数：StatementCallback，这就是需要回调的方法。这里我还要提醒你一下，Java是纯粹的面向对象编程，没有真正的全局函数，所以实际代码中是一个类。</p><p>有了这个回调参数，就不需要给每一个数据访问增加一个子类来实现doInStatemnt()了，而是作为参数传进去。</p><p>你可以看一下Callback接口。</p><pre><code class=\"language-plain\">package com.minis.jdbc.core;\n\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic interface StatementCallback {\n\tObject doInStatement(Statement stmt) throws SQLException;\n}\n</code></pre><p>可以看出这是一个函数式接口。</p><p>现在，应用程序就只需要用一个JdbcTemplate类就可以了，不用再为每一个业务类单独做一个子类。就像我们前面说的，用户类需要使用Callback动态匿名类的方式进行改造。</p><p>代码如下：</p><pre><code class=\"language-plain\">\tpublic User getUserInfo(int userid) {\n\t\tfinal String sql = \"select id, name,birthday from users where id=\"+userid;\n\t\treturn (User)jdbcTemplate.query(\n\t\t\t\t(stmt)-&gt;{\t\t\t\n\t\t\t\t\tResultSet rs = stmt.executeQuery(sql);\n\t\t\t\t\tUser rtnUser = null;\n\t\t\t\t\tif (rs.next()) {\n\t\t\t\t\t\trtnUser = new User();\n\t\t\t\t\t\trtnUser.setId(userid);\n\t\t\t\t\t\trtnUser.setName(rs.getString(\"name\"));\n\t\t\t\t\t\trtnUser.setBirthday(new java.util.Date(rs.getDate(\"birthday\").getTime()));\n\t\t\t\t\t}\n\t\t\t\t\treturn rtnUser;\n\t\t\t\t}\n\t\t);\n\t}\n</code></pre><p>从代码中可以看到，以前写在UserJdbcImpl里的业务代码，也就是对SQL语句返回值的处理逻辑，现在成了匿名类，作为参数传入query()里，最后在query()里会回调到它。</p><p>按照同样的办法我们还可以支持PreparedStatement类型，方法调用时带上SQL语句需要的参数值。</p><pre><code class=\"language-plain\">\tpublic Object query(String sql, Object[] args, PreparedStatementCallback pstmtcallback) {\n\t&nbsp; &nbsp; //省略获取connection等代码\n\t&nbsp; &nbsp; pstmt = con.prepareStatement(sql);\n\t&nbsp; &nbsp; for (int i = 0; i &lt; args.length; i++) { //设置参数\n    \t\tObject arg = args[i];\n            //按照不同的数据类型调用JDBC的不同设置方法\n\t    \tif (arg instanceof String) {\n\t\t  &nbsp; &nbsp; pstmt.setString(i+1, (String)arg);\n\t\t    } else if (arg instanceof Integer) {\n\t\t&nbsp; &nbsp;   pstmt.setInt(i+1, (int)arg);\n\t\t    }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\t&nbsp; &nbsp; return pstmtcallback.doInPreparedStatement(pstmt);\n\t}\n</code></pre><p>通过代码可以知道，和普通的Statement相比，这个PReparedStatement场景只是需要额外对SQL参数一个个赋值。这里我们还要注意一点，当SQL语句里有多个参数的时候，MiniSpring会按照参数次序赋值，和参数名没有关系。</p><p>我们再来看一下为PreparedStement准备的Callback接口。</p><pre><code class=\"language-plain\">package com.minis.jdbc.core;\n\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\npublic interface PreparedStatementCallback {\n\tObject doInPreparedStatement(PreparedStatement stmt) throws SQLException;\n}\n</code></pre><p>这也是一个函数式接口。</p><p>用户服务类代码改造如下：</p><pre><code class=\"language-plain\">public User getUserInfo(int userid) {\n\t\tfinal String sql = \"select id, name,birthday from users where id=?\";\n\t\treturn (User)jdbcTemplate.query(sql, new Object[]{new Integer(userid)},\n\t\t\t(pstmt)-&gt;{\t\t\t\n\t\t\t\tResultSet rs = pstmt.executeQuery();\n\t\t\t\tUser rtnUser = null;\n\t\t\t\tif (rs.next()) {\n\t\t\t\t\trtnUser = new User();\n\t\t\t\t\trtnUser.setId(userid);\n\t\t\t\t\trtnUser.setName(rs.getString(\"name\"));\n\t\t\t\t}&nbsp;\n\t\t\t\treturn rtnUser;\n\t\t\t}\n\t\t);\n\t}\n</code></pre><p>到这里，我们就用一个单一的JdbcTemplate类实现了数据访问。</p><h2>结合IoC容器</h2><p>当然，我们还可以更进一步，既然我们的MiniSpring是个IoC容器，可以管理一个一个的Bean对象，那么我们就要好好利用它。由于只需要唯一的一个JdbcTemplate类，我们就可以事先把它定义为一个Bean，放在IoC容器里，然后通过@Autowired自动注入。</p><p>在XML配置文件中声明一下。</p><pre><code class=\"language-plain\">\t&lt;bean id=\"jdbcTemplate\" class=\"com.minis.jdbc.core.JdbcTemplate\" /&gt;&nbsp;\n</code></pre><p>上层用户service程序中就不需要自己手动创建JdbcTemplate，而是通过Autowired注解进行注入就能得到了。</p><pre><code class=\"language-plain\">package com.test.service;\n\nimport java.sql.ResultSet;\nimport com.minis.beans.factory.annotation.Autowired;\nimport com.minis.jdbc.core.JdbcTemplate;\nimport com.test.entity.User;\n\t\npublic class UserService {\n\t\t@Autowired\n\t\tJdbcTemplate jdbcTemplate;\n}\n</code></pre><p>我们需要记住，MiniSpring只支持按照名字匹配注入，所以UserService类里的实例变量JdbcTemplate这个名字必须与XML文件中配置的Bean的id是一致的。如果不一致就会导致程序找不到JdbcTemplate。</p><p>这样一来，应用程序中和数据库访问相关的代码就全部剥离出去了，应用程序只需要声明使用它，而它的创建、管理都由MiniSpring框架来完成。从这里我们也能看出IoC容器带来的便利，事实上，我们需要用到的很多工具，都会以Bean的方式在配置文件中声明，交给IoC容器来管理。</p><h2>数据源</h2><p>我们注意到，JdbcTemplate中获取数据库连接信息等套路性语句仍然是硬编码的（hard coded）。</p><pre><code class=\"language-plain\">Class.forName(\"com.microsoft.sqlserver.jdbc.SQLServerDriver\");\ncon = DriverManager.getConnection(\"jdbc:sqlserver://localhost:1433;databasename=DEMO;user=sa;password=Sql2016;\");\n</code></pre><p>现在我们动手把这一部分代码包装成DataSource，通过它获取数据库连接。假设有了这个工具，上层应用程序就简单了。你可以看一下使用者的代码示例。</p><pre><code class=\"language-plain\">con = dataSource.getConnection();\n</code></pre><p>这个Data Source被JdbcTemplate使用。</p><pre><code class=\"language-plain\">public class JdbcTemplate {\n\tprivate DataSource dataSource;\n}\n</code></pre><p>而这个属性可以通过配置注入，你可以看下配置文件。</p><pre><code class=\"language-plain\">&lt;bean id=\"dataSource\" class=\"com.minis.jdbc.datasource.SingleConnectionDataSource\"&gt;\n\t&lt;property type=\"String\" name=\"driverClassName\" value=\"com.microsoft.sqlserver.jdbc.SQLServerDriver\"/&gt;\n\t&lt;property type=\"String\" name=\"url\" value=\"jdbc:sqlserver://localhost:1433;databasename=DEMO;\"/&gt;\n\t&lt;property type=\"String\" name=\"username\" value=\"sa\"/&gt;\n\t&lt;property type=\"String\" name=\"password\" value=\"Sql2016\"/&gt;\n&lt;/bean&gt;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n&lt;bean id=\"jdbcTemplate\" class=\"com.minis.jdbc.core.JdbcTemplate\" &gt;\n\t&lt;property type=\"javax.sql.DataSource\" name=\"dataSource\" ref=\"dataSource\"/&gt;\n&lt;/bean&gt;&nbsp;\n</code></pre><p>在DataSource这个Bean初始化的时候，设置Property时会加载相应的JDBC Driver，然后注入给JdbcTemplate来使用。</p><p>我们再次看到，独立抽取这些部件，加上IoC容器的Bean管理，给系统构造带来许多便利。</p><p>上面描述的是假定有了一个DataSource之后怎么使用，现在回头再来看DataSource本身是怎么构造出来的。其实Java里已经给出了这个接口，是javax.sql.DataSource。我们就遵守这个规范，做一个简单的实现。</p><pre><code class=\"language-plain\">package com.minis.jdbc.datasource;\n\nimport java.io.PrintWriter;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.util.Properties;\nimport java.util.logging.Logger;\nimport javax.sql.DataSource;\n\npublic class SingleConnectionDataSource implements DataSource {\n\tprivate String driverClassName;\n\tprivate String url;\n\tprivate String username;\n\tprivate String password;\n\tprivate Properties connectionProperties;\t\n\tprivate Connection connection;\n\t\n    //默认构造函数\n\tpublic SingleConnectionDataSource() {\n\t}\n    //一下是属性相关的getter和setter\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n\tpublic String getUsername() {\n\t\treturn username;\n\t}\n\tpublic void setUsername(String username) {\n\t\tthis.username = username;\n\t}\n\tpublic String getPassword() {\n\t\treturn password;\n\t}\n\tpublic void setPassword(String password) {\n\t\tthis.password = password;\n\t}\n\tpublic Properties getConnectionProperties() {\n\t\treturn connectionProperties;\n\t}\n\tpublic void setConnectionProperties(Properties connectionProperties) {\n\t\tthis.connectionProperties = connectionProperties;\n\t}\n\t@Override\n\tpublic PrintWriter getLogWriter() throws SQLException {\n\t\treturn null;\n\t}\n\t@Override\n\tpublic int getLoginTimeout() throws SQLException {\n\t\treturn 0;\n\t}\n\t@Override\n\tpublic Logger getParentLogger() throws SQLFeatureNotSupportedException {\n\t\treturn null;\n\t}\n\t@Override\n\tpublic void setLogWriter(PrintWriter arg0) throws SQLException {\n\t}\n\t@Override\n\tpublic void setLoginTimeout(int arg0) throws SQLException {\n\t}\n\t@Override\n\tpublic boolean isWrapperFor(Class&lt;?&gt; arg0) throws SQLException {\n\t\treturn false;\n\t}\n\t@Override\n\tpublic &lt;T&gt; T unwrap(Class&lt;T&gt; arg0) throws SQLException {\n\t\treturn null;\n\t}\n    //设置driver class name的方法，要加载driver类\n\tpublic void setDriverClassName(String driverClassName) {\n\t\tthis.driverClassName = driverClassName;\n\t\ttry {\n\t\t\tClass.forName(this.driverClassName);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new IllegalStateException(\"Could not load JDBC driver class [\" + driverClassName + \"]\", ex);\n\t\t}\n\t}\n    //实际建立数据库连接\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn getConnectionFromDriver(getUsername(), getPassword());\n\t}\n\t@Override\n\tpublic Connection getConnection(String username, String password) throws SQLException {\n\t\treturn getConnectionFromDriver(username, password);\n\t}\n    //将参数组织成Properties结构，然后拿到实际的数据库连接\n\tprotected Connection getConnectionFromDriver(String username, String password) throws SQLException {\n\t\tProperties mergedProps = new Properties();\n\t\tProperties connProps = getConnectionProperties();\n\t\tif (connProps != null) {\n\t\t\tmergedProps.putAll(connProps);\n\t\t}\n\t\tif (username != null) {\n\t\t\tmergedProps.setProperty(\"user\", username);\n\t\t}\n\t\tif (password != null) {\n\t\t\tmergedProps.setProperty(\"password\", password);\n\t\t}\n\n\t\tthis.connection = getConnectionFromDriverManager(getUrl(),mergedProps);\n\t\treturn this.connection;\n\t}\n    //通过DriverManager.getConnection()建立实际的连接\n\tprotected Connection getConnectionFromDriverManager(String url, Properties props) throws SQLException {\n\t\treturn DriverManager.getConnection(url, props);\n\t}\n}\n</code></pre><p>这个类很简单，封装了和数据访问有关的信息，除了getter和setter之外，它最核心的方法就是getConnection()，这个方法又会调用getConnectionFromDriver()，最后会调用到getConnectionFromDriverManager()。你看一下这个方法，里面就是我们熟悉的DriverManager.getConnection()，一层层调用，最后还是落实到这里了。</p><p>所以我们看实际的数据库连接是什么时候创建的呢？这个可以采用不同的策略，可以在初始化Bean的时候创建，也可以延后到实际使用的时候。MiniSpring到现在这一步，采取的是后面这个策略，在应用程序dataSource.getConnection()的时候才实际生成数据库连接。</p><h2>小结</h2><p>我们这节课通过三个手段叠加，简化了数据库操作，重构了数据访问的程序结构。第一个手段是<strong>模板化</strong>，把通用代码写到一个JdbcTemplate模板里，把变化的部分交给具体的类来实现。第二个手段就是通过<strong>Callback模式</strong>，把具体类里实现的业务逻辑包装成一个回调函数，作为参数传给JdbcTemplate模板，这样就省去了要为每一个数据表单独增加一个具体实现类的工作。第三个手段就是结合IoC容器，<strong>把JdbcTemplate声明成一个Bean</strong>，并利用@Autowired注解进行自动注入。</p><p>之后我们抽取出了数据源的概念，包装connection，让应用程序和底下的数据库分隔开。</p><p>当然，程序走到这一步，还是有很多不足，主要的就是JdbcTemplate中还保留了很多固定的代码，比如SQL结果和业务对象的自动匹配问题，而且也没有考虑数据库连接池等等。这些都需要我们在后面的课程中一个个解决。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课，我也给你留一道思考题。我们现在只实现了query，想一想如果想要实现update应该如何做呢？欢迎你在留言区与我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","neighbors":{"left":{"article_title":"12｜再回首：如何实现Spring MVC？","id":646763},"right":{"article_title":"14｜增强模板：如何抽取专门的部件完成专门的任务？","id":647834}},"comments":[{"had_liked":false,"id":372510,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1681219203,"is_pvip":false,"replies":[{"id":136000,"content":"driver基础功能也不是很复杂，主要是了解数据库系统提供的api，现代数据库都提供了java api，就更简单了。我那个时候只有c语言的api，所以还要用JNI技术来做。基础功能c代码记得我就几千行。\njdbc template很少直接使用了，一般用mybatis或者jpa，但是也有系统是用的。我个人认为了解jdbc template很有好处。这个话题比较大，见解不同，我自己不是很支持orm技术。我的观点，因为底下的数据库系统是关系模型，是一种代数演算，跟对象模型天然有隔，一味进行orm，我觉得是对面向对象的滥用。我在我的《认识编程》一书中讲到了这个观点。\n数据库并发数，跟jdbc template关系不大，是数据库系统和缓存系统主要决定的，实际上，包装越少性能越好，jdbc template就是一层薄薄的包装。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681302206,"ip_address":"澳大利亚","comment_id":372510,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"请教老师几个问题：\nQ1：JDBC driver复杂吗？代码规模一般多大？能否以加餐形式讲一下driver？\nQ2：JDBC Template还有用吗？\n现在一般的开发都是SSM或SSH，不会用JDBC Template。\nQ3：JDBC template能支持多大并发？\n用JDBC template的话，一个数据库实例，比如一个mysql实例，能支持多大的并发量？200？","like_count":7,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613405,"discussion_content":"driver基础功能也不是很复杂，主要是了解数据库系统提供的api，现代数据库都提供了java api，就更简单了。我那个时候只有c语言的api，所以还要用JNI技术来做。基础功能c代码记得我就几千行。\njdbc template很少直接使用了，一般用mybatis或者jpa，但是也有系统是用的。我个人认为了解jdbc template很有好处。这个话题比较大，见解不同，我自己不是很支持orm技术。我的观点，因为底下的数据库系统是关系模型，是一种代数演算，跟对象模型天然有隔，一味进行orm，我觉得是对面向对象的滥用。我在我的《认识编程》一书中讲到了这个观点。\n数据库并发数，跟jdbc template关系不大，是数据库系统和缓存系统主要决定的，实际上，包装越少性能越好，jdbc template就是一层薄薄的包装。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681302206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376766,"user_name":"云从","can_delete":false,"product_type":"c1","uid":2682971,"ip_address":"四川","ucode":"96442F21D37C0F","user_header":"https://static001.geekbang.org/account/avatar/00/28/f0/5b/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1687334501,"is_pvip":false,"replies":[{"id":137347,"content":"自己放一个mysql jar包就行","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1687396873,"ip_address":"澳大利亚","comment_id":376766,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"如果本地测试能够连接mysql  但是tomcat中可连接不上的话  看看tomcal  lib 下面有没有mysql 的驱动","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621630,"discussion_content":"自己放一个mysql jar包就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687396873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3866578,"avatar":"https://static001.geekbang.org/account/avatar/00/3a/ff/d2/c1f5334d.jpg","nickname":"dirtychill","note":"","ucode":"4D3172C60E522A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646403,"discussion_content":"我也是，web基于out生成目录启动的，看看这个目录的webINF有没有这个驱动jar包","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717927668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372446,"user_name":"马儿","can_delete":false,"product_type":"c1","uid":2247080,"ip_address":"四川","ucode":"542E23D7B6AB01","user_header":"","comment_is_top":false,"comment_ctime":1681144157,"is_pvip":false,"replies":[{"id":135962,"content":"目标不同，jdbc template不是为了完全不感知sql。minispring没有讨论orm这个议题。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681214859,"ip_address":"澳大利亚","comment_id":372446,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"实现dml语句如果只是简单的实现就像最初的那一版拼接sql就可以实现了，但是这样的话需要每次更新都手动拼接sql比较麻烦。如果想要传入相应的对象就更新，可以利用本节课的callback来实现将相应的对象字段转换为sql语句的过程。但是这节课的结果可能整体上离最终感知不到sql还比较远，如果需要完全不感知sql应该是用一个类专门负责根据类属性的注解来自动映射。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613253,"discussion_content":"目标不同，jdbc template不是为了完全不感知sql。minispring没有讨论orm这个议题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681214859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373504,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1682583247,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"前几天有点忙，这次补齐了。https:&#47;&#47;github.com&#47;caozhenyuan&#47;mini-spring.git。请看jdbc1、2、3分支","like_count":0}]}