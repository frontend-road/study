{"id":9103,"title":"第17讲 | 一个线程两次调用start()方法会出现什么情况？","content":"<p>今天我们来深入聊聊线程，相信大家对于线程这个概念都不陌生，它是Java并发的基础元素，理解、操纵、诊断线程是Java工程师的必修课，但是你真的掌握线程了吗？</p>\n<p>今天我要问你的问题是，<span class=\"orange\">一个线程两次调用start()方法会出现什么情况？谈谈线程的生命周期和状态转移。</span></p>\n<!-- [[[read_end]]] -->\n<h2>典型回答</h2>\n<p>Java的线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常，多次调用start被认为是编程错误。</p>\n<p>关于线程生命周期的不同状态，在Java 5以后，线程状态被明确定义在其公共内部枚举类型java.lang.Thread.State中，分别是：</p>\n<ul>\n<li>\n<p>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</p>\n</li>\n<li>\n<p>就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。</p>\n</li>\n<li>\n<p>在其他一些分析中，会额外区分一种状态RUNNING，但是从Java API的角度，并不能表示出来。</p>\n</li>\n<li>\n<p>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</p>\n</li>\n<li>\n<p>等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。Thread.join()也会令线程进入等待状态。</p>\n</li>\n<li>\n<p>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本，如下面示例：</p>\n</li>\n</ul>\n<pre><code>public final native void wait(long timeout) throws InterruptedException;\n</code></pre>\n<ul>\n<li>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。</li>\n</ul>\n<p>在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的。</p>\n<h2>考点分析</h2>\n<p>今天的问题可以算是个常见的面试热身题目，前面的给出的典型回答，算是对基本状态和简单流转的一个介绍，如果觉得还不够直观，我在下面分析会对比一个状态图进行介绍。总的来说，理解线程对于我们日常开发或者诊断分析，都是不可或缺的基础。</p>\n<p>面试官可能会以此为契机，从各种不同角度考察你对线程的掌握：</p>\n<ul>\n<li>\n<p>相对理论一些的面试官可以会问你线程到底是什么以及Java底层实现方式。</p>\n</li>\n<li>\n<p>线程状态的切换，以及和锁等并发工具类的互动。</p>\n</li>\n<li>\n<p>线程编程时容易踩的坑与建议等。</p>\n</li>\n</ul>\n<p>可以看出，仅仅是一个线程，就有非常多的内容需要掌握。我们选择重点内容，开始进入详细分析。</p>\n<h2>知识扩展</h2>\n<p>首先，我们来整体看一下线程是什么？</p>\n<p>从操作系统的角度，可以简单认为，线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。</p>\n<p>在具体实现中，线程还分为内核线程、用户线程，Java的线程实现其实是与虚拟机相关的。对于我们最熟悉的Sun/Oracle JDK，其线程也经历了一个演进过程，基本上在Java 1.2之后，JDK已经抛弃了所谓的<a href=\"https://en.wikipedia.org/wiki/Green_threads\">Green Thread</a>，也就是用户调度的线程，现在的模型是一对一映射到操作系统内核线程。</p>\n<p>如果我们来看Thread的源码，你会发现其基本操作逻辑大都是以JNI形式调用的本地代码。</p>\n<pre><code>private native void start0();\nprivate native void setPriority0(int newPriority);\nprivate native void interrupt0();\n</code></pre>\n<p>这种实现有利有弊，总体上来说，Java语言得益于精细粒度的线程和相关的并发操作，其构建高扩展性的大型应用的能力已经毋庸置疑。但是，其复杂性也提高了并发编程的门槛，近几年的Go语言等提供了协程（<a href=\"https://en.wikipedia.org/wiki/Coroutine\">coroutine</a>），大大提高了构建并发应用的效率。于此同时，Java也在<a href=\"http://openjdk.java.net/projects/loom/\">Loom</a>项目中，孕育新的类似轻量级用户线程（Fiber）等机制，也许在不久的将来就可以在新版JDK中使用到它。</p>\n<p>下面，我来分析下线程的基本操作。如何创建线程想必你已经非常熟悉了，请看下面的例子：</p>\n<pre><code>Runnable task = () -&gt; {System.out.println(&quot;Hello World!&quot;);};\nThread myThread = new Thread(task);\nmyThread.start();\nmyThread.join();\n</code></pre>\n<p>我们可以直接扩展Thread类，然后实例化。但在本例中，我选取了另外一种方式，就是实现一个Runnable，将代码逻放在Runnable中，然后构建Thread并启动（start），等待结束（join）。</p>\n<p>Runnable的好处是，不会受Java不支持类多继承的限制，重用代码实现，当我们需要重复执行相应逻辑时优点明显。而且，也能更好的与现代Java并发库中的Executor之类框架结合使用，比如将上面start和join的逻辑完全写成下面的结构：</p>\n<pre><code>Future future = Executors.newFixedThreadPool(1)\n.submit(task)\n.get();\n</code></pre>\n<p>这样我们就不用操心线程的创建和管理，也能利用Future等机制更好地处理执行结果。线程生命周期通常和业务之间没有本质联系，混淆实现需求和业务需求，就会降低开发的效率。</p>\n<p>从线程生命周期的状态开始展开，那么在Java编程中，有哪些因素可能影响线程的状态呢？主要有：</p>\n<ul>\n<li>\n<p>线程自身的方法，除了start，还有多个join方法，等待线程结束；yield是告诉调度器，主动让出CPU；另外，就是一些已经被标记为过时的resume、stop、suspend之类，据我所知，在JDK最新版本中，destory/stop方法将被直接移除。</p>\n</li>\n<li>\n<p>基类Object提供了一些基础的wait/notify/notifyAll方法。如果我们持有某个对象的Monitor锁，调用wait会让当前线程处于等待状态，直到其他线程notify或者notifyAll。所以，本质上是提供了Monitor的获取和释放的能力，是基本的线程间通信方式。</p>\n</li>\n<li>\n<p>并发类库中的工具，比如CountDownLatch.await()会让当前线程进入等待状态，直到latch被基数为0，这可以看作是线程间通信的Signal。</p>\n</li>\n</ul>\n<p>我这里画了一个状态和方法之间的对应图：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/31/dc/3169b7ca899afeb0359f132fb77c29dc.png?wh=892*467\" alt=\"\" /></p>\n<p>Thread和Object的方法，听起来简单，但是实际应用中被证明非常晦涩、易错，这也是为什么Java后来又引入了并发包。总的来说，有了并发包，大多数情况下，我们已经不再需要去调用wait/notify之类的方法了。</p>\n<p>前面谈了不少理论，下面谈谈线程API使用，我会侧重于平时工作学习中，容易被忽略的一些方面。</p>\n<p>先来看看守护线程（Daemon Thread），有的时候应用中需要一个长期驻留的服务程序，但是不希望其影响应用退出，就可以将其设置为守护线程，如果JVM发现只有守护线程存在时，将结束进程，具体可以参考下面代码段。<strong>注意，必须在线程启动之前设置。</strong></p>\n<pre><code>Thread daemonThread = new Thread();\ndaemonThread.setDaemon(true);\ndaemonThread.start();\n</code></pre>\n<p>再来看看<a href=\"https://en.wikipedia.org/wiki/Spurious_wakeup\">Spurious wakeup</a>。尤其是在多核CPU的系统中，线程等待存在一种可能，就是在没有任何线程广播或者发出信号的情况下，线程就被唤醒，如果处理不当就可能出现诡异的并发问题，所以我们在等待条件过程中，建议采用下面模式来书写。</p>\n<pre><code>// 推荐\nwhile ( isCondition()) {\nwaitForAConfition(...);\n}\n\n// 不推荐，可能引入bug\nif ( isCondition()) {\nwaitForAConfition(...);\n}\n\n</code></pre>\n<p>Thread.onSpinWait()，这是Java 9中引入的特性。我在<a href=\"http://time.geekbang.org/column/article/9042\">专栏第16讲</a>给你留的思考题中，提到“自旋锁”（spin-wait, busy-waiting），也可以认为其不算是一种锁，而是一种针对短期等待的性能优化技术。“onSpinWait()”没有任何行为上的保证，而是对JVM的一个暗示，JVM可能会利用CPU的pause指令进一步提高性能，性能特别敏感的应用可以关注。</p>\n<p>再有就是慎用<a href=\"https://docs.oracle.com/javase/9/docs/api/java/lang/ThreadLocal.html\">ThreadLocal</a>，这是Java提供的一种保存线程私有信息的机制，因为其在整个线程生命周期内有效，所以可以方便地在一个线程关联的不同业务模块之间传递信息，比如事务ID、Cookie等上下文相关信息。</p>\n<p>它的实现结构，可以参考<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/ee8524126794/src/java.base/share/classes/java/lang/ThreadLocal.java\">源码</a>，数据存储于线程相关的ThreadLocalMap，其内部条目是弱引用，如下面片段。</p>\n<pre><code>static class ThreadLocalMap {\n\tstatic class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n    \t/** The value associated with this ThreadLocal. */\n    \tObject value;\n    \tEntry(ThreadLocal&lt;?&gt; k, Object v) {\n        \tsuper(k);\n    \tvalue = v;\n    \t}\n      }\n   // …\n}\n</code></pre>\n<p>当Key为null时，该条目就变成“废弃条目”，相关“value”的回收，往往依赖于几个关键点，即set、remove、rehash。</p>\n<p>下面是set的示例，我进行了精简和注释：</p>\n<pre><code>private void set(ThreadLocal&lt;?&gt; key, Object value) {\n\tEntry[] tab = table;\n\tint len = tab.length;\n\tint i = key.threadLocalHashCode &amp; (len-1);\n\n\tfor (Entry e = tab[i];; …) {\n    \t//…\n    \tif (k == null) {\n// 替换废弃条目\n        \treplaceStaleEntry(key, value, i);\n        \treturn;\n    \t}\n       }\n\n\ttab[i] = new Entry(key, value);\n\tint sz = ++size;\n//  扫描并清理发现的废弃条目，并检查容量是否超限\n\tif (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)\n    \trehash();// 清理废弃条目，如果仍然超限，则扩容（加倍）\n}  \n</code></pre>\n<p>具体的清理逻辑是实现在cleanSomeSlots和expungeStaleEntry之中，如果你有兴趣可以自行阅读。</p>\n<p>结合<a href=\"http://time.geekbang.org/column/article/6970\">专栏第4讲</a>介绍的引用类型，我们会发现一个特别的地方，通常弱引用都会和引用队列配合清理机制使用，但是ThreadLocal是个例外，它并没有这么做。</p>\n<p>这意味着，废弃项目的回收<strong>依赖于显式地触发，否则就要等待线程结束</strong>，进而回收相应ThreadLocalMap！这就是很多OOM的来源，所以通常都会建议，应用一定要自己负责remove，并且不要和线程池配合，因为worker线程往往是不会退出的。</p>\n<p>今天，我介绍了线程基础，分析了生命周期中的状态和各种方法之间的对应关系，这也有助于我们更好地理解synchronized和锁的影响，并介绍了一些需要注意的操作，希望对你有所帮助。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？今天我准备了一个有意思的问题，写一个最简单的打印HelloWorld的程序，说说看，运行这个应用，Java至少会创建几个线程呢？然后思考一下，如何明确验证你的结论，真实情况很可能令你大跌眼镜哦。</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n<p></p>\n","comments":[{"had_liked":false,"id":12667,"user_name":"风动静泉","can_delete":false,"product_type":"c1","uid":1113190,"ip_address":"","ucode":"34DEF4FF06A491","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/66/d7f7ad77.jpg","comment_is_top":false,"comment_ctime":1528949274,"is_pvip":false,"replies":[{"id":"4212","content":"不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990836,"ip_address":"","comment_id":12667,"utype":1}],"discussion_count":6,"race_medal":0,"score":"491155221018","product_id":100006701,"comment_content":"一课一练:<br>使用了两种方式获取当前程序的线程数。<br>1、使用线程管理器MXBean<br>2、直接通过线程组的activeCount<br>第二种需要注意不断向上找父线程组，否则只能获取当前线程组，结果是1<br><br>结论:<br>使用以上两种方式获取的线程总数都是5个。<br>main<br>Attach Listener<br>Signal Dispatcher<br>Finalizer<br>Reference Handler<br><br>此外，如果使用的IDE是IDEA 直接运行会多一个Monitor Ctrl-break线程，这个是IDE的原因。debug模式下不会有这个线程。","like_count":113,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419361,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2346885,"avatar":"https://static001.geekbang.org/account/avatar/00/23/cf/85/01d477d1.jpg","nickname":"陈宇","note":"","ucode":"11CE4F953072C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548516,"discussion_content":"public static void main(String[] args) {\n        System.out.println(&#34;Hello World&#34;);\n        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();\n        long[] threadIds = threadMXBean.getAllThreadIds();\n        ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(threadIds);\n        for (ThreadInfo threadInfo : threadInfos) {\n            System.out.println(threadInfo.getThreadId()+&#34;: &#34;+threadInfo.getThreadName());\n        }\n    ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643246390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2346885,"avatar":"https://static001.geekbang.org/account/avatar/00/23/cf/85/01d477d1.jpg","nickname":"陈宇","note":"","ucode":"11CE4F953072C7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548515,"discussion_content":"Hello World\n4: Signal Dispatcher\n3: Finalizer\n2: Reference Handler\n1: main\n为啥我这只有四个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643246322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384801,"discussion_content":"&#34;main@1&#34; prio=5 tid=0x1 nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\t  \n&#34;Finalizer@666&#34; daemon prio=8 tid=0x3 nid=NA waiting\n  java.lang.Thread.State: WAITING\n\t  at java.lang.Object.wait(Object.java:-1)\n\t  at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)\n\t  at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)\n\t  at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)\n\n&#34;Reference Handler@667&#34; daemon prio=10 tid=0x2 nid=NA waiting\n  java.lang.Thread.State: WAITING\n\t  at java.lang.Object.wait(Object.java:-1)\n\t  at java.lang.Object.wait(Object.java:502)\n\t  at java.lang.ref.Reference.tryHandlePending(Reference.java:191)\n\t  at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)\n\n&#34;Attach Listener@664&#34; daemon prio=5 tid=0x5 nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\n&#34;Signal Dispatcher@665&#34; daemon prio=9 tid=0x4 nid=NA runnable\n  java.lang.Thread.State: RUNNABLE\n\n刚刚好5个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626758031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155612,"discussion_content":"这是怎么分析出来的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580269106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1125281,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2b/a1/d40cc39d.jpg","nickname":"煜城骁特","note":"","ucode":"F4939490CF38FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207830,"discussion_content":"idea debug启动，打断点，Frams下拉可以看到，完整的5个线程","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1584516926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":155612,"ip_address":""},"score":207830,"extra":""}]}]},{"had_liked":false,"id":12662,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1528948597,"is_pvip":false,"replies":[{"id":"4211","content":"不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990796,"ip_address":"","comment_id":12662,"utype":1}],"discussion_count":5,"race_medal":0,"score":"336536397685","product_id":100006701,"comment_content":"做了一个test分析老师的问题，观察到的情况如下：<br>JVM 启动 Hello World的线程分析<br>环境：<br>macOS + jdk8<br>检测获得<br>Thread[Reference Handler,10,system]<br>Thread[Finalizer,8,system]<br>Thread[main,5,main]<br>Thread[Signal Dispatcher,9,system]<br>Hello World!<br>其中：<br>Reference Handler：处理引用对象本身的垃圾回收<br>Finalizer：处理用户的Finalizer方法<br>Signal Dispatcher：外部jvm命令的转发器<br><br>在jdk6环境中<br>还有一个Attach Listener的线程<br>是负责接收外部命令的，如jmap、jstack<br><br>","like_count":79,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419359,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155613,"discussion_content":"这是怎么分析出来的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580269111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156424,"discussion_content":"我留言很久了，专栏文章应该有步骤？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580361823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":155613,"ip_address":""},"score":156424,"extra":""},{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180366,"discussion_content":"不知你微信多少？交流一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582293037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":156424,"ip_address":""},"score":180366,"extra":""},{"author":{"id":1001893,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","nickname":"小文同学","note":"","ucode":"48F2AEB989C12A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200824,"discussion_content":"wenkangqiang 一起交流","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583726749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":180366,"ip_address":""},"score":200824,"extra":""}]}]},{"had_liked":false,"id":12626,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1528937424,"is_pvip":false,"replies":[{"id":"4207","content":"前面是翻译窜了，已经修正；后面大家用了很多方法，基本都可以，主要目的是结合前面的介绍加深理解","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990422,"ip_address":"","comment_id":12626,"utype":1}],"discussion_count":1,"race_medal":0,"score":"96018217936","product_id":100006701,"comment_content":"“我们会发现一个特别的地方，通常幻象引用都会和引用队列配合清理机制使用，但是 ThreadLocal 是个例外，它并没有这么做。”<br> 老师，Entry继承的是WeakReference，这个是弱引用吧。<br> main:<br>        System.out.println(&quot;hello world&quot;);<br>        ThreadGroup group = Thread.currentThread().getThreadGroup();<br>        ThreadGroup topGroup = group;<br>        while (group != null) {<br>            topGroup = group;<br>            group = group.getParent();<br>        }<br>        int nowThreads = topGroup.activeCount();<br>        Thread[] lstThreads = new Thread[nowThreads];<br>        topGroup.enumerate(lstThreads);<br>        for (int i = 0; i &lt; nowThreads; i++) {<br>            System.out.println(&quot;线程number：&quot; + i + &quot; = &quot; + lstThreads[i].getName());<br>        }<br>out:<br>线程number：0 = Reference Handler &#47;&#47; 计算对象是否可达？<br>线程number：1 = Finalizer &#47;&#47; 回收对象时触发的finalize方法？<br>线程number：2 = Signal Dispatcher &#47;&#47; 线程调度员<br>线程number：3 = main<br>线程number：4 = Monitor Ctrl-Break &#47;&#47; 监控器，锁相关","like_count":22,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419334,"discussion_content":"前面是翻译窜了，已经修正；后面大家用了很多方法，基本都可以，主要目的是结合前面的介绍加深理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12576,"user_name":"爱折腾的老斑鸠","can_delete":false,"product_type":"c1","uid":1121408,"ip_address":"","ucode":"1DDAFA037FB03D","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/80/2bc29ca9.jpg","comment_is_top":false,"comment_ctime":1528933310,"is_pvip":true,"replies":[{"id":"4218","content":"嗯，线程池一般不建议和thread local配合...","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528991096,"ip_address":"","comment_id":12576,"utype":1}],"discussion_count":2,"race_medal":0,"score":"96018213822","product_id":100006701,"comment_content":"theadlocal里面的值如果是线程池的线程里面设置的，当任务完成，线程归还线程池时，这个threadlocal里面的值是不是不会被回收？","like_count":22,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419302,"discussion_content":"嗯，线程池一般不建议和thread local配合...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528991096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400677,"discussion_content":"一般自己在线程执行完清下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633361808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15279,"user_name":"黄启航","can_delete":false,"product_type":"c1","uid":1161541,"ip_address":"","ucode":"E070738CC7B287","user_header":"https://static001.geekbang.org/account/avatar/00/11/b9/45/c3d6fd51.jpg","comment_is_top":false,"comment_ctime":1531068494,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"65955577934","product_id":100006701,"comment_content":"杨老师您好，我有个疑问:<br><br>文章最后说&quot;弱引用都会和引用队列配合清理工作，但是Threadlocal是个例外，它并没有这么做。这意味着，废弃项目的回收依赖显示地触发，否则就要等待线程的结束&quot;  。<br><br>我的疑问：既然没有利用引用队列来实现自动清除，那TheadLocalMap内部的Entry继承WeakReference有何用意？能起到什么作用？<br>","like_count":16,"discussions":[{"author":{"id":1320592,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/90/f68608f3.jpg","nickname":"gwl","note":"","ucode":"24F334E9AC0313","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281630,"discussion_content":"可以看下这篇文章 \nhttps://www.cnblogs.com/aspirant/p/8991010.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591780880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96966,"discussion_content":"这块我也不明白+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577101688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12647,"user_name":"tyson","can_delete":false,"product_type":"c1","uid":1110943,"ip_address":"","ucode":"E88F630B53C743","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/9f/3e4e8d46.jpg","comment_is_top":false,"comment_ctime":1528941486,"is_pvip":true,"replies":[{"id":"4206","content":"不错","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990232,"ip_address":"","comment_id":12647,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44478614446","product_id":100006701,"comment_content":"1、站在应用程序方面，只创建了一个线程。<br>2、站在jvm方面，肯定还有gc等其余线程。<br><br>总结：<br>1、线程是系统调度的最小单元，应该是进程吧。线程是操作系统的资源，在运行的时候会打开文件描述符等。<br>2、 resume、stop、suspend等已经被废弃了<br>3、线程的等待和唤醒，建议使用reentrantlock的condition wait&#47;notify方法<br>4、可以使用线程的join方法、countdownlatch、cyclicbarrier、future等进行线程的等待","like_count":11,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419349,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12811,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1529049389,"is_pvip":true,"replies":[{"id":"4305","content":"同意","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529169625,"ip_address":"","comment_id":12811,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35888787757","product_id":100006701,"comment_content":"现在觉得踩坑是一种很好学习方法","like_count":9,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419419,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529169625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213022,"user_name":"李飞","can_delete":false,"product_type":"c1","uid":1555180,"ip_address":"","ucode":"930458850AA05B","user_header":"https://static001.geekbang.org/account/avatar/00/17/ba/ec/2b1c6afc.jpg","comment_is_top":false,"comment_ctime":1588263019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27358066795","product_id":100006701,"comment_content":"&#47;&#47;线程数验证<br>        System.out.println(&quot;hello world&quot;);<br>        int activeCount = Thread.activeCount();<br>        System.out.println(&quot;线程活跃数：&quot; + activeCount);<br>        Set&lt;Thread&gt; threadSet = Thread.getAllStackTraces().keySet();<br>        for (Thread thread : threadSet) {<br>            System.out.println(&quot;线程&quot; + thread.getId() + &quot;:&quot; + thread.getName());<br>        }<br><br>输出结果：<br>hello world<br>线程活跃数：1<br>线程3:Finalizer<br>线程4:Signal Dispatcher<br>线程2:Reference Handler<br>线程5:Attach Listener<br>线程1:main","like_count":7},{"had_liked":false,"id":55380,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1546153785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27315957561","product_id":100006701,"comment_content":"边看老师的讲课 边反思工程代码 ","like_count":7},{"had_liked":false,"id":12623,"user_name":"锐","can_delete":false,"product_type":"c1","uid":1110915,"ip_address":"","ucode":"A245BA96C9471F","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/83/e2612d81.jpg","comment_is_top":false,"comment_ctime":1528937124,"is_pvip":false,"replies":[{"id":"4215","content":"嗯，为了生命周期的需求","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990916,"ip_address":"","comment_id":12623,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23003773604","product_id":100006701,"comment_content":"通常弱引用都会和引用队列配合清理机制使用，但是 ThreadLocal 是个例外，它并没有这么做。<br><br>这意味着，废弃项目的回收依赖于显式地触发，否则就要等待线程结束，进而回收相应 ThreadLocalMap！这就是很多 OOM 的来源<br><br>这个平时还真没注意","like_count":5,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419331,"discussion_content":"嗯，为了生命周期的需求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42799,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1543048087,"is_pvip":false,"replies":[{"id":"15381","content":"范范谈有点晦涩，可以从线程进入、退出blocked&#47;waiting的方法&#47;条件来对比","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1543155696,"ip_address":"","comment_id":42799,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18722917271","product_id":100006701,"comment_content":"等待与阻塞有什么区别呢","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430202,"discussion_content":"范范谈有点晦涩，可以从线程进入、退出blocked/waiting的方法/条件来对比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543155696,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291272,"discussion_content":"阻塞会被别人唤醒,等待是自己醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594750016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1266987,"avatar":"https://static001.geekbang.org/account/avatar/00/13/55/2b/b7927cc4.jpg","nickname":"超超超超超帅耶🌴","note":"","ucode":"931E23DC0ACB04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212902,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","nickname":"旅途","note":"","ucode":"5022477E8E9441","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553684,"discussion_content":"也不是吧，阻塞是锁拿不到，不得不等，等待是代码里面自己wait了，可能是觉得其他条件不满足","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646029380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291272,"ip_address":""},"score":553684,"extra":""}]}]},{"had_liked":false,"id":12998,"user_name":"TonyEasy","can_delete":false,"product_type":"c1","uid":1115635,"ip_address":"","ucode":"CB455BA8915B64","user_header":"https://static001.geekbang.org/account/avatar/00/11/05/f3/4dd9e515.jpg","comment_is_top":false,"comment_ctime":1529276620,"is_pvip":false,"replies":[{"id":"4428","content":"不是的，工作线程一般不退出的，复用的是类似runnable这种","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529424233,"ip_address":"","comment_id":12998,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18709145804","product_id":100006701,"comment_content":"老师，我有一点疑问，在线程池里复用线程时是不是对同一个线程调用了多次.start()方法呢？","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419493,"discussion_content":"不是的，工作线程一般不退出的，复用的是类似runnable这种","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529424233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12786,"user_name":"mongo","can_delete":false,"product_type":"c1","uid":1113124,"ip_address":"","ucode":"F39FE783793A17","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/24/7d43d807.jpg","comment_is_top":false,"comment_ctime":1529029281,"is_pvip":false,"replies":[{"id":"4306","content":"下面章节就会覆盖这部分，我谈下自己的思路：大部分工程师是没有机会在工作中，全面使用并发的那些东西的，尤其是反馈读者中初学者不少；所以，我建议有个整体性体系有个了解，分清大体都有什么；然后可以选些实践场景，去实现用例代码。面试中大体也就够了，毕竟项目经验不是教程能解决的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529170152,"ip_address":"","comment_id":12786,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18708898465","product_id":100006701,"comment_content":"杨老师请教你，关于高并发和线程池，我刚刚入门，工作中没有涉及过这一块。我阅读了oracle java tutorial high level concurrency 章节，阅读并粗略理解了《并发编程实践》这本书，想进一步清晰我的理解，我现在苦于在实践练习方面不知道怎么进行。老师有什么具体可行的思路指点一下吗？留言圈里有好多大神，在这里同时也请教其他的朋友。谢谢老师，谢谢大家。","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419408,"discussion_content":"下面章节就会覆盖这部分，我谈下自己的思路：大部分工程师是没有机会在工作中，全面使用并发的那些东西的，尤其是反馈读者中初学者不少；所以，我建议有个整体性体系有个了解，分清大体都有什么；然后可以选些实践场景，去实现用例代码。面试中大体也就够了，毕竟项目经验不是教程能解决的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529170152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207581,"user_name":"承香墨影","can_delete":false,"product_type":"c1","uid":1023750,"ip_address":"","ucode":"4D6A4D6E1ED29F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/06/287d77dd.jpg","comment_is_top":false,"comment_ctime":1587112431,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10177047023","product_id":100006701,"comment_content":"Java 线程状态切换的图有问题，Runnable 到 Blocked 不包括阻塞 IO，在 Java 层面是不关心是否调用了 阻塞API 的，此时不会切换线程状态，依然保持在 RUNNABLE 中。","like_count":2},{"had_liked":false,"id":162906,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1576630397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10166564989","product_id":100006701,"comment_content":"17 一次线程多次调用start方法会提示IllegnalThreadStateException，1 线程生命周期的几个状态，在Java.lang.thread.state中，new线程刚创建还没真正启动的状态，runnable 就绪 表示该线程已经在jvm中执行，执行需要计算资源，可能正在运行，也可能正在等待cpu分配cpu片段，在就绪队列排队，blocked，阻塞 表示当前线程处于Monitor lock，比如线程试图获取某个锁，发现被其他线程占了，就会处于阻塞状态，等待waiting，比如生产者消费者模式，消费者条件未满足，让当前消费者等待，生产者去准备数据，通过notify等动作，通知消费者线程可以继续工作，计时等待，和进入等待的条件一样，调用方法是等待超时的方法，终止 terminated 不管意外退出还是自动终止，线程终止运行，也叫死亡，第二次调用start的时候，线程已经死亡或者处于非new的状态，所以会抛出异常 2 线程是什么 线程是线程调度的基本单元，一个进城包含多个线程，作为任务真正的执行者，有自己的栈，寄存器和本地存储等，但是会和进城中其他线程共享文件描述符和虚拟地址空间，线程分为内核线程和用户线程，看Thread的源码，以JNI形式调用的本地代码，3 创建线程 new Thread().start() thread.join()，线程的方法，有start，join等待线程结束，yield告诉调度室，主动让出CPU，基类Object提供了一些基础方法，wait，notify，notifyAll等方法，如果一个线程持有Minitor锁，会让其他线程处于wait状态，直到其他线程notify或者notifyall，Daemon Thread 守护线程，长期存在的服务线程","like_count":2},{"had_liked":false,"id":12622,"user_name":"高杰","can_delete":false,"product_type":"c1","uid":1123779,"ip_address":"","ucode":"2DA90479CD6D02","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/c3/6569bd7d.jpg","comment_is_top":false,"comment_ctime":1528937092,"is_pvip":false,"replies":[{"id":"4208","content":"翻译修正了，谢谢指出；你试试用比如最简单的jstack查看下，不止这些哦","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990531,"ip_address":"","comment_id":12622,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10118871684","product_id":100006701,"comment_content":"有几个弱引用，虚引用的地方，音频和文字对不上。把我搞晕了。<br>应该有2个线程，还有jvm的gc线程？还有第三个线程吗？","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419330,"discussion_content":"翻译修正了，谢谢指出；你试试用比如最简单的jstack查看下，不止这些哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12580,"user_name":"sunlight001","can_delete":false,"product_type":"c1","uid":1126975,"ip_address":"","ucode":"A72C4274D5DE8A","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/3f/fa4ac035.jpg","comment_is_top":false,"comment_ctime":1528934280,"is_pvip":false,"replies":[{"id":"4216","content":"不用了，明确移除是好习惯","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990958,"ip_address":"","comment_id":12580,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10118868872","product_id":100006701,"comment_content":"threadlocal在放入值之后，在get出来之后，需要做remove操作，我这么理解对么？以前写的程序都没remove😄","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419304,"discussion_content":"不用了，明确移除是好习惯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12579,"user_name":"食指可爱多","can_delete":false,"product_type":"c1","uid":1045721,"ip_address":"","ucode":"B918E07F55AB9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/d9/e572ae4d.jpg","comment_is_top":false,"comment_ctime":1528934205,"is_pvip":true,"replies":[{"id":"4217","content":"其他就包括我们前面章节说过的finalizer，各种cleaner等，还有事件处理等<br>","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528991061,"ip_address":"","comment_id":12579,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10118868797","product_id":100006701,"comment_content":"我了解确定线程有:任务线程，Main线程，垃圾回收线程，还有些线程没细心关注名字和用途，惭愧了。可以在业务线程中等待，然后在命令行用jstack看看当前jvm的线程堆栈。","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419303,"discussion_content":"其他就包括我们前面章节说过的finalizer，各种cleaner等，还有事件处理等\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528991061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12574,"user_name":"Eason","can_delete":false,"product_type":"c1","uid":1018519,"ip_address":"","ucode":"69C0ADAC7C5475","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/97/6c1e90f1.jpg","comment_is_top":false,"comment_ctime":1528933163,"is_pvip":false,"replies":[{"id":"4219","content":"wait和blocked是不同的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528991160,"ip_address":"","comment_id":12574,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10118867755","product_id":100006701,"comment_content":"“比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态”这个例子换一个理解，感觉也是在等待其他线程做某些操作。在“阻塞”中也是在“等待”中？？","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419300,"discussion_content":"wait和blocked是不同的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528991160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335026,"user_name":"孙剑平","can_delete":false,"product_type":"c1","uid":1865124,"ip_address":"","ucode":"33C41928024997","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/qc4pasMqznVJfdcpltOEbwVHH5zF1NUvKYuIzWvQMqxHEPUH6QpF8VDm0XNkaWwvHSWhEYTNCY3yNgCJSQQAvw/132","comment_is_top":false,"comment_ctime":1645259580,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5940226876","product_id":100006701,"comment_content":"老师好，我们第二次调star方法是报错，我看是有个threadStatus的值变为2了，源码没有看到赋值的地方，这值是什么时候从0变为2的呢？","like_count":1},{"had_liked":false,"id":16862,"user_name":"曲东方","can_delete":false,"product_type":"c1","uid":1177819,"ip_address":"","ucode":"6C3EA2F47A0B98","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/db/c4edf697.jpg","comment_is_top":false,"comment_ctime":1532263113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5827230409","product_id":100006701,"comment_content":"大概10来个吧，native占多数。大致分下面几类<br>1. 用户线程，main<br>2. GC相关线程，包括C1&#47;C2；与运行机器配置、操作系统、启动参数相关<br>3. 编译器&#47;解释器相关线程；与运行机器配置、操作系统、启动参数相关<br>4.引用及Finalizer处理线程<br>6. VM Thread：可以说它类似linux的init进程<br>7. VM Periodic Task Thread：JVM时钟模拟线程<br>8. Signal Dispatcher：JVM信号处理线程<br>9. Attach Listener：jdk工具类请求响应处理线程<br>10. Service Thread：低内存检测、JVMTI事件转发线程","like_count":0},{"had_liked":false,"id":13953,"user_name":"tracer","can_delete":false,"product_type":"c1","uid":1124766,"ip_address":"","ucode":"AE2BC047DB7D7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/9e/380a01ea.jpg","comment_is_top":false,"comment_ctime":1530083404,"is_pvip":false,"replies":[{"id":"4653","content":"不知道，源码...","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530117930,"ip_address":"","comment_id":13953,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5825050700","product_id":100006701,"comment_content":"有讲解那五个线程的资料吗？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419820,"discussion_content":"不知道，源码...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530117930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341308,"user_name":"L","can_delete":false,"product_type":"c1","uid":1142198,"ip_address":"","ucode":"AFF206EF3DF651","user_header":"https://static001.geekbang.org/account/avatar/00/11/6d/b6/67f8f097.jpg","comment_is_top":false,"comment_ctime":1649513886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1649513886","product_id":100006701,"comment_content":"不明白ThreadLocal的弱引用为什么会引起oom？<br>还有线程池不推荐使用ThreadLocal是因为怕程序员忘记做remove操作吗？<br>","like_count":0},{"had_liked":false,"id":246513,"user_name":"蒙奇君杰","can_delete":false,"product_type":"c1","uid":1117302,"ip_address":"","ucode":"2DBCECD149730F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/76/0c07376d.jpg","comment_is_top":false,"comment_ctime":1599385237,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599385237","product_id":100006701,"comment_content":"确实，就像评论里说的，大多数时候都在CURD，对这些细枝末节的点接触的比较少，自然就容易出现一问三猜的情况了。个人认为，对这些东西的理解才是最重要的，即知道有哪些就成，不必要太过细致的去深挖每一个线程概念的具体定义和作用。<br>这里我直接是用评论区提到的debug方法来查看多少个线程的。<br>环境：IDEA-2018.2+JDK8.0<br>没运行程序前，首先就只想到了应用程序层面的主线程，其次就是可能的JVM编译，JVM挂载等的线程(这两部分是猜的)。<br>一课一练---&gt;<br>Main——(做实事)<br>Finalizer-回收器线程<br>Signal Dispatcher——(指明要做什么)<br>Reference Handler——(检测是否需要同外部线程协作)<br>Attach Listener——（指明在哪里去做）","like_count":0},{"had_liked":false,"id":236649,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1595490610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595490610","product_id":100006701,"comment_content":"win10+jdk11<br>使用hread.getAllStackTraces().forEach((thread, stackTraceElements) -&gt; System.out.println(thread.getName()));<br>获取到的线程：<br>Finalizer<br>main<br>Reference Handler<br>Common-Cleaner<br>Signal Dispatcher<br>Attach Listener","like_count":0},{"had_liked":false,"id":220004,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1590133859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590133859","product_id":100006701,"comment_content":"给大家贴一下，线程状态解释的源码：<br> &#47;**<br>         * Thread state for a thread which has not yet started.<br>         *&#47;<br>        NEW,<br><br>        &#47;**<br>         * Thread state for a runnable thread.  A thread in the runnable<br>         * state is executing in the Java virtual machine but it may<br>         * be waiting for other resources from the operating system<br>         * such as processor.<br>         *&#47;<br>        RUNNABLE,<br><br>        &#47;**<br>         * Thread state for a thread blocked waiting for a monitor lock.<br>         * A thread in the blocked state is waiting for a monitor lock<br>         * to enter a synchronized block&#47;method or<br>         * reenter a synchronized block&#47;method after calling<br>         * {@link Object#wait() Object.wait}.<br>         *&#47;<br>        BLOCKED,","like_count":0},{"had_liked":false,"id":198412,"user_name":"我的黄金时代","can_delete":false,"product_type":"c1","uid":1062070,"ip_address":"","ucode":"D7825B45B372F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","comment_is_top":false,"comment_ctime":1585450045,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585450045","product_id":100006701,"comment_content":"        &#47;*<br>         * A zero status value corresponds to state &quot;NEW&quot;.<br>         *&#47;<br>        if (threadStatus != 0)<br>            throw new IllegalThreadStateException();<br>","like_count":0},{"had_liked":false,"id":192699,"user_name":"护爽使者","can_delete":false,"product_type":"c1","uid":1275464,"ip_address":"","ucode":"12DC35DD74671C","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/48/5ab89daa.jpg","comment_is_top":false,"comment_ctime":1584868869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584868869","product_id":100006701,"comment_content":"start是线程启动，run 是直接调用","like_count":0},{"had_liked":false,"id":182977,"user_name":"FATMAN89","can_delete":false,"product_type":"c1","uid":1175430,"ip_address":"","ucode":"48A67FB47B3C5D","user_header":"https://static001.geekbang.org/account/avatar/00/11/ef/86/12f95d66.jpg","comment_is_top":false,"comment_ctime":1582901413,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582901413","product_id":100006701,"comment_content":"老师，线程既然不能start两次，那么线程池是如何复用线程的呢？","like_count":0,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217116,"discussion_content":"给 空闲线程 塞 runnable 去执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585498665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175207,"user_name":"jackLee","can_delete":false,"product_type":"c1","uid":1234280,"ip_address":"","ucode":"720304AB76D9FB","user_header":"https://static001.geekbang.org/account/avatar/00/12/d5/68/af1682f1.jpg","comment_is_top":false,"comment_ctime":1580616004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580616004","product_id":100006701,"comment_content":"    &#47;**<br>     * Causes this thread to begin execution; the Java Virtual Machine<br>     * calls the &lt;code&gt;run&lt;&#47;code&gt; method of this thread.<br>     * &lt;p&gt;<br>     * The result is that two threads are running concurrently: the<br>     * current thread (which returns from the call to the<br>     * &lt;code&gt;start&lt;&#47;code&gt; method) and the other thread (which executes its<br>     * &lt;code&gt;run&lt;&#47;code&gt; method).<br>     * &lt;p&gt;<br>     * It is never legal to start a thread more than once.<br>     * In particular, a thread may not be restarted once it has completed<br>     * execution.<br>     *<br>     * @exception  IllegalThreadStateException  if the thread was already<br>     *               started.<br>     * @see        #run()<br>     * @see        #stop()<br>     *&#47;<br>    public synchronized void start() {<br>        &#47;**<br>         * This method is not invoked for the main method thread or &quot;system&quot;<br>         * group threads created&#47;set up by the VM. Any new functionality added<br>         * to this method in the future may have to also be added to the VM.<br>         *<br>         * A zero status value corresponds to state &quot;NEW&quot;.<br>         *&#47;<br>        if (threadStatus != 0)<br>            throw new IllegalThreadStateException();<br><br>        &#47;* Notify the group that this thread is about to be started<br>         * so that it can be added to the group&#39;s list of threads<br>         * and the group&#39;s unstarted count can be decremented. *&#47;<br>        group.add(this);<br><br>        boolean started = false;<br>        try {<br>            start0();<br>            started = true;<br>        } finally {<br>            try {<br>                if (!started) {<br>                    group.threadStartFailed(this);<br>                }<br>            } catch (Throwable ignore) {<br>                &#47;* do nothing. If start0 threw a Throwable then<br>                  it will be passed up the call stack *&#47;<br>            }<br>        }<br>    }","like_count":0},{"had_liked":false,"id":152948,"user_name":"Geek_032104","can_delete":false,"product_type":"c1","uid":1298282,"ip_address":"","ucode":"25542A2348F99F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/G61OS6hibNG7iakUmXeKmcY5VtFWnPpywzjOcUCm3t0HsibCibm3jzLNbdvjKQ8G8WSIkicBiaqoCsvHibn3M7wV4YbrA/132","comment_is_top":false,"comment_ctime":1574128481,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574128481","product_id":100006701,"comment_content":"blocked和waiting除了等待的对象不一样（前者等待锁，后者等待其它线程），还有别的区别吗？","like_count":0},{"had_liked":false,"id":149868,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573418598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573418598","product_id":100006701,"comment_content":"有了rxjava以后，真心不太想去直接写线程代码。","like_count":0},{"had_liked":false,"id":138626,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1570376479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570376479","product_id":100006701,"comment_content":"老师，线程等待时位于哪个区域？","like_count":0},{"had_liked":false,"id":136123,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1569370904,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569370904","product_id":100006701,"comment_content":"那join(),yeild(),sleep(),这三个方法调用后，分别进入什么状态？","like_count":0},{"had_liked":false,"id":116820,"user_name":"fcb的鱼","can_delete":false,"product_type":"c1","uid":1243901,"ip_address":"","ucode":"88667EBF09CEC0","user_header":"https://static001.geekbang.org/account/avatar/00/12/fa/fd/ec24cba7.jpg","comment_is_top":false,"comment_ctime":1563929739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563929739","product_id":100006701,"comment_content":"然而并没有找到线程状态在哪设置的？也就是在什么时候，把线程的state设置为0，什么时候又把值改变了？两次调用start的时候，发现线程状态不为0才报异常！","like_count":0},{"had_liked":false,"id":90202,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1556446727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556446727","product_id":100006701,"comment_content":"这是怎么检测出来 有多少个线程在后台运行的啊？","like_count":0},{"had_liked":false,"id":84960,"user_name":"流光","can_delete":false,"product_type":"c1","uid":1434612,"ip_address":"","ucode":"2B41D1B890018D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e3/f4/ecb33aef.jpg","comment_is_top":false,"comment_ctime":1554949620,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554949620","product_id":100006701,"comment_content":"创建单例线程,Future o = Executors.newSingleThreadExecutor().submit(() -&gt; {<br>            return &quot;asdf&quot;;<br>        });<br>这样更优雅些吧","like_count":0},{"had_liked":false,"id":82080,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1554115462,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554115462","product_id":100006701,"comment_content":"跟我们讲下协程主要是干什么的，好吗","like_count":0},{"had_liked":false,"id":76488,"user_name":"DL","can_delete":false,"product_type":"c1","uid":1349066,"ip_address":"","ucode":"4270976C29AB47","user_header":"https://static001.geekbang.org/account/avatar/00/14/95/ca/5e4580e7.jpg","comment_is_top":false,"comment_ctime":1552618725,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1552618725","product_id":100006701,"comment_content":"老师您好，对threadLocal的OOM有一些疑问。既然Map中的key是弱引用，是不是意味着只要我们能够在编程中注意将new出来的对象的强引用去掉（=null），后续的gc会自动清理掉弱引用key，对于key=nul的value的清理在后续的set等方法中会清理。这样即使在线程复用的情况下如何会出现OOM呢？","like_count":0,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384809,"discussion_content":"key被ThreadLocal弱引用，不会发生oom，会发生oom的地方是value\n\n如果把ThreadLocal置为null，那么意味着Heap中的ThreadLocal实例不在有强引用指向，只有弱引用存在，因此GC是可以回收这部分空间的，也就是key是可以回收的。\n\n但是value却存在一条从Current Thread过来的强引用链。因此只有当Current Thread销毁时，value才能得到释放。\n\n因此，只要这个线程对象被gc回收，就不会出现内存泄露，但在threadLocal设为null和线程结束这段时间内不会被回收的，就发生了我们认为的内存泄露。最要命的是线程对象不被回收的情况，比如使用线程池的时候，线程结束是不会销毁的，再次使用的，就可能出现内存泄露。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626761928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48209,"discussion_content":"我理解是线程复用的话 key一直不为null，所以哪怕没有使用线程，threadlocal也会一直占用一部分内存不释放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573463530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":48747,"user_name":"峻铭","can_delete":false,"product_type":"c1","uid":1106202,"ip_address":"","ucode":"63AB23BADACA88","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/1a/20977779.jpg","comment_is_top":false,"comment_ctime":1544529437,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1544529437","product_id":100006701,"comment_content":"我还是没明白为什么不能start两次，知其然不知其所以然","like_count":0,"discussions":[{"author":{"id":1188176,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/50/265671fd.jpg","nickname":"LGY001","note":"","ucode":"29CA0F9501D3EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28218,"discussion_content":"看下Thread类的start源码估计你就理解了，java线程有6个状态，在线程执行start函数时，首先会检查线程的状态是不是new，若不是则抛出异常，若是则将线程加入到线程组之中，并调用本地native方法来通知JVM在空闲时间执行相关任务逻辑，start后线程的状态就变为RUNNABLE了，所以调用两次就会抛出异常IllegalThreadStateException了，这是我的理解。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1570686979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43598,"user_name":"王子瑞Aliloke有事电联","can_delete":false,"product_type":"c1","uid":1249400,"ip_address":"","ucode":"9ABE8E475E336B","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/78/29bd3f1e.jpg","comment_is_top":false,"comment_ctime":1543243553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543243553","product_id":100006701,"comment_content":"通常弱引用都会和引用队列配合清理机制使用，但是 ThreadLocal 是个例外，它并没有这么做。<br><br>这意味着，废弃项目的回收依赖于显式地触发，否则就要等待线程结束，进而回收相应 ThreadLocalMap！这就是很多 OOM 的来源<br><br>就在前几天，踩了这个坑，项目跑着跑着，就OOM了，后来手动把session失效，交给GC回收。","like_count":0},{"had_liked":false,"id":37995,"user_name":"Phoenix","can_delete":false,"product_type":"c1","uid":1005368,"ip_address":"","ucode":"C51BE4C948755B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/38/ba6a106f.jpg","comment_is_top":false,"comment_ctime":1541845867,"is_pvip":false,"replies":[{"id":"13671","content":"据我所知tomcat也有相关问题","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1541908922,"ip_address":"","comment_id":37995,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541845867","product_id":100006701,"comment_content":"想要请教老师，对于tomcat服务器为每个用户请求新建一条线程，那么该线程的threadlocal也会随着请求结束，线程被回收，threadlocal也会相应的被回收，那么我理解的是，类似tomcat请求这种线程模型，threadlocal即使不调用remove，也不会出现OOM，这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428554,"discussion_content":"据我所知tomcat也有相关问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541908922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37949,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1541821914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541821914","product_id":100006701,"comment_content":"现在才来不知道问的问题还能看到不？<br>java线程wait对应实际线程的状态是什么呢？jvm调度都能做什么呢？从runable状态来看，jvm并不知道一个线程是否获取了cpu资源？<br>以上问题对应到posix上。<br>为什么threadlocal的 entry不利用引用队列来置空对value的引用呢？<br>java有没有考虑过异步转同步的async&#47;await模式呢？<br>","like_count":0},{"had_liked":false,"id":18577,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1533461852,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533461852","product_id":100006701,"comment_content":"1、站在应用程序方面，只创建了一个线程。<br>2、站在jvm方面，肯定还有gc等其余线程。<br><br>总结：<br>1、线程是系统调度的最小单元，应该是进程吧。线程是操作系统的资源，在运行的时候会打开文件描述符等。<br>2、 resume、stop、suspend等已经被废弃了<br>3、线程的等待和唤醒，建议使用reentrantlock的condition wait&#47;notify方法<br>4、可以使用线程的join方法、countdownlatch、cyclicbarrier、future等进行线程的等待","like_count":0},{"had_liked":false,"id":13194,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1529454434,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1529454434","product_id":100006701,"comment_content":"Threadlocal进行线程隔离，线程拥有自己的数据空间，synchronize进行线程同步。<br>另外想问老师，虚假唤醒的深层次原因是啥呢？","like_count":0},{"had_liked":false,"id":12999,"user_name":"TonyEasy","can_delete":false,"product_type":"c1","uid":1115635,"ip_address":"","ucode":"CB455BA8915B64","user_header":"https://static001.geekbang.org/account/avatar/00/11/05/f3/4dd9e515.jpg","comment_is_top":false,"comment_ctime":1529276746,"is_pvip":false,"replies":[{"id":"4417","content":"工作线程一般不退出的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529423199,"ip_address":"","comment_id":12999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529276746","product_id":100006701,"comment_content":"老师，我有一点疑问，在线程池复用线程时，对同一线程调用多次.start()方法，为何不报错呢？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419494,"discussion_content":"工作线程一般不退出的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529423199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12946,"user_name":"扫地僧的功夫梦","can_delete":false,"product_type":"c1","uid":1081053,"ip_address":"","ucode":"3B775474594BC3","user_header":"https://static001.geekbang.org/account/avatar/00/10/7e/dd/e4e6718a.jpg","comment_is_top":false,"comment_ctime":1529196635,"is_pvip":false,"replies":[{"id":"4424","content":"已回复，不是的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529423953,"ip_address":"","comment_id":12946,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529196635","product_id":100006701,"comment_content":"调用notify()&#47;notifyAll()方法线程是变为阻塞状态吧，因为线程还没获取到锁。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419470,"discussion_content":"已回复，不是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529423953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12812,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1529049480,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1529049480","product_id":100006701,"comment_content":"看了17讲回来留言threadlocal","like_count":0},{"had_liked":false,"id":12688,"user_name":"肖一林","can_delete":false,"product_type":"c1","uid":1113317,"ip_address":"","ucode":"1DE45D906EB836","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/e5/605f423f.jpg","comment_is_top":false,"comment_ctime":1528960187,"is_pvip":false,"replies":[{"id":"4205","content":"线程池里的线程生命周期长","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990112,"ip_address":"","comment_id":12688,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528960187","product_id":100006701,"comment_content":"threadlocal和线程池结合的问题真的没考虑过","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419371,"discussion_content":"线程池里的线程生命周期长","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12651,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1528943625,"is_pvip":false,"replies":[{"id":"4308","content":"我理解不是一回事，openjdk目前没有协程，Loom过程在做相关事情","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529170985,"ip_address":"","comment_id":12651,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528943625","product_id":100006701,"comment_content":"问个问题，NIO 2的异步是不是利用协程的原理设计的？它实际运行的是多线程吗？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419352,"discussion_content":"我理解不是一回事，openjdk目前没有协程，Loom过程在做相关事情","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529170985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12643,"user_name":"tyson","can_delete":false,"product_type":"c1","uid":1110943,"ip_address":"","ucode":"E88F630B53C743","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/9f/3e4e8d46.jpg","comment_is_top":false,"comment_ctime":1528940880,"is_pvip":true,"replies":[{"id":"4213","content":"正解","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990854,"ip_address":"","comment_id":12643,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528940880","product_id":100006701,"comment_content":"1、站在应用程序方面，只创建了一个线程。<br>2、站在jvm方面，肯定还有gc等其余线程。<br><br>总结：<br>1、线程是系统调度的最小单元，应该是进程吧。线程是操作系统的资源，在运行的时候会打开文件描述符等。<br>2、 resume、stop、suspend等已经被废弃了<br>3、线程的等待和唤醒，建议使用reentrantlock的condition wait&#47;notify方法<br>4、可以使用线程的join方法、countdownlatch、cyclicbarrier、future等进行线程的等待","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419346,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12642,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1528940548,"is_pvip":true,"replies":[{"id":"4214","content":"主要是为了加深理解，这种也就是老学究关心，哈哈","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990894,"ip_address":"","comment_id":12642,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528940548","product_id":100006701,"comment_content":"老师今天这课后题，又打脸了平时工作不仔细的地方，我首先想到的是好歹得sleep一下或打个断点用类似visualvm的工具看下，或者top之类数一下，赶着出门，回来试下","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419345,"discussion_content":"主要是为了加深理解，这种也就是老学究关心，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12617,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1122021,"ip_address":"","ucode":"B29CAB0EF4C474","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/e5/bee05364.jpg","comment_is_top":false,"comment_ctime":1528936910,"is_pvip":true,"replies":[{"id":"4210","content":"后边虚拟机那边介绍","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990575,"ip_address":"","comment_id":12617,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528936910","product_id":100006701,"comment_content":"线程得内存分配是怎么样的呢？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419327,"discussion_content":"后边虚拟机那边介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12584,"user_name":"hanmshashou","can_delete":false,"product_type":"c1","uid":1147615,"ip_address":"","ucode":"3424FFBEDE6138","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/B5KGe7PEWv1m0ZdUSRBLaX65brD5Iice8ze7xpFDJIzOTQSN2JqCkCYwOnTMW5ApNCyicCAs8t48DUuX5t66VHBQ/132","comment_is_top":false,"comment_ctime":1528934636,"is_pvip":false,"replies":[{"id":"4209","content":"汗颜，已修正","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528990547,"ip_address":"","comment_id":12584,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528934636","product_id":100006701,"comment_content":"weak 应该不是幻象引用吧","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419308,"discussion_content":"汗颜，已修正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528990547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12583,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1528934535,"is_pvip":false,"replies":[{"id":"4221","content":"是说FutureTask的实现吗？我记得是有区别的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528994106,"ip_address":"","comment_id":12583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528934535","product_id":100006701,"comment_content":"老师 future模式是怎么异步返回结果的呢？是不是把每个线程的运行结果放到queue中，然后轮询queue返回结果？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419307,"discussion_content":"是说FutureTask的实现吗？我记得是有区别的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528994106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}