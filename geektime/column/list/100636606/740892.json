{"id":740892,"title":"第 15 章 服务容错保护(2)","content":"<h2 id=\"nav_point_232\">15.2　使用 Resilience4j 实现容错</h2>\n<p>在理解了基本的容错理念和常见模式后，该进入实践环节了。考虑到在实战中会出现各种出乎意料的情况，除非自己是个久经考验的老手，或者大神级人物，否则还是老老实实使用那些已经被实践验证过的框架吧，避免在别人已经跌到过无数次的地方重复踩坑。</p>\n<p>放到以前，说起与服务容错相关的话题，就不得不提 Netflix 开源的 Hystrix，实际上，它就是当时事实上的行业标准。可惜在 2018 年 Netflix 宣布将该项目转入维护状态，不再继续投入开发，它就慢慢从宝座上退了下来。好在有几位后起之秀扛起了大旗，让大家有了其他的选择，它们就是本节要介绍的 Resilience4j，以及后续章节中会提到的阿里开源的 Sentinel。</p>\n<p>按照官方自己的介绍，Resilience4j 是受 Hystrix 的启发而开发的轻量级容错库，专门针对 Java 8 和函数式编程设计的。它没有太多依赖，而且简单易用。Resilience4j 提供了断路器、限流、重试、舱壁等常见容错功能实现；通过它的高阶函数（即它提供的装饰器）还可以对函数接口、Lambda 表达式和方法进行增强；而且 Resilience4j 的模块化程度很高，我们可以按需引入其中的核心容错能力。类似 Resilience4j 对 Spring Boot 和 Micronaut<span class=\"comment-number\">7</span> 的支持功能也被放到了不同的模块中，根据项目使用的框架来使用即可。表 15-1 罗列了一些 Resilience4j 的模块。</p><!-- [[[read_end]]] -->\n\n<p><strong>表 15-1　Resilience4j 的模块清单</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>功能</p></th>\n<th><p>模块</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>断路</p></td>\n<td><p>resilience4j-circuitbreaker</p></td>\n</tr>\n<tr>\n<td><p>限流</p></td>\n<td><p>resilience4j-ratelimiter</p></td>\n</tr>\n<tr>\n<td><p>舱壁</p></td>\n<td><p>resilience4j-bulkhead</p></td>\n</tr>\n<tr>\n<td><p>重试</p></td>\n<td><p>resilience4j-retry</p></td>\n</tr>\n<tr>\n<td><p>缓存</p></td>\n<td><p>resilience4j-cache</p></td>\n</tr>\n<tr>\n<td><p>超时</p></td>\n<td><p>resilience4j-timelimiter</p></td>\n</tr>\n<tr>\n<td><p>Feign 支持</p></td>\n<td><p>resilience4j-feign</p></td>\n</tr>\n<tr>\n<td><p>Spring Boot 2 支持</p></td>\n<td><p>resilience4j-spring-boot2</p></td>\n</tr>\n<tr>\n<td><p>Spring Reactor 支持</p></td>\n<td><p>resilience4j-reactor</p></td>\n</tr>\n<tr>\n<td><p>Micrometer 支持</p></td>\n<td><p>resilience4j-micrometer</p></td>\n</tr>\n<tr>\n<td><p>Prometheus 支持</p></td>\n<td><p>resilience4j-prometheus</p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_233\">15.2.1　使用 Resilience4j 实现限流</h3>\n<p>在开始介绍 Resilience4j 之前，让我们先来完善一下二进制奶茶店的例子，新增一个调茶师 TeaMaker 的模块，以便演示后续的多个功能。</p>\n<blockquote>\n<p><strong>需求描述</strong>　通常，奶茶店的收银和制作都是前后分开的，用户通过客户端下单并付款，或者由服务员在 Web 界面下单收银后，调茶师会根据订单进行制作。点单收银可以很快，但做一杯饮料往往很慢，现磨手冲咖啡、冰滴茶、鲜榨果汁之类的都需要时间，所以调茶师往往会成为奶茶店的瓶颈—这其实是一个潜在的限流需求，调茶师忙不过来时就不再接新订单了。</p>\n</blockquote>\n<ol>\n<li><p><strong>新增调茶师模块</strong></p>\n<p>这里显然就是提示我们要给 TeaMaker 增加限流功能，不过我们还是要先把这个模块简单地编写出来。可以通过 Spring Initializr 初始化 TeaMaker 工程 <span class=\"comment-number\">8</span>，选中 Web、Lombok、Actuator 和 Apache Zookeeper Discovery 依赖，前面三个用来实现本身的业务功能，第四个是为了让 BinaryTea 能够找到 TeaMaker，如果想把配置都放进配置中心，还可以再增加相关的依赖。</p>\n<p>代码示例 15-12 是 TeaMaker 对外暴露的 REST 服务。因为是演示，所以一切从简，直接提供一个订单号，只要单号是个正整数就算有效订单号，开始进行订单制作，制作完毕即返回 <code>200 OK</code>。返回的 JSON 报文中包含了三个属性，分别是成功制作与否、订单编号与制作此单的调茶师编号。</p>\n<blockquote>\n<p><strong>代码示例 15-12</strong>　TeaMaker 对外提供的服务代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@RestController\n@RequestMapping(\"/order\")\n@Slf4j\npublic class OrderController {\n    @Autowired\n    private OrderService orderService;\n\n    @PostMapping(\"/\")\n    public ResponseEntity&lt;ProcessResult&gt; process(@PathVariable Long id) {\n        if (id == null || id &lt;= 0) {\n            return ResponseEntity.badRequest().build();\n        }\n        ProcessResult result = orderService.make(id);\n        log.info(\"成功完成订单{}的制作\", id);\n        return ResponseEntity.ok(result);\n    }\n}\n\n@Getter\n@Setter\n@Builder\npublic class ProcessResult {\n    private boolean finish;\n    private long orderId;\n    private long teaMakerId;\n}</code></pre>\n<p>我们将具体的制作过程封装在了 <code>OrderService.make()</code> 方法里，它的逻辑如代码示例 15-13 所示。用一段 <code>sleep()</code> 来代表制作耗时，随后构造结果对象，<code>tea-maker.id</code> 和 <code>tea-maker.time-per-order</code> 都是 <code>application.properties</code> 中的配置值。</p>\n<blockquote>\n<p><strong>代码示例 15-13</strong>　具体制作订单的 <code>OrderService</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\npublic class OrderService {\n    @Value(\"$\")\n    private long teaMakerId;\n    @Value(\"$\")\n    private Duration timePerOrder;\n\n    public ProcessResult make(Long id) {\n        try {\n            TimeUnit.MILLISECONDS.sleep(timePerOrder.toMillis());\n        } catch (InterruptedException e) {\n        }\n        return ProcessResult.builder()\n               .finish(true).orderId(id)\n               .teaMakerId(teaMakerId)\n               .build();\n    }\n}</code></pre>\n<p>例如，我们可以像下面这样提供一些配置，再结合 Zookeeper 地址等其他内容，让程序先运行起来：</p>\n<pre class=\"code-rows\"><code>spring.application.name=tea-maker\nserver.port=8082\ntea-maker.id=1\ntea-maker.time-per-order=1s</code></pre>\n<p>一定要强调的是，目前你看到的方式并不是实现 TeaMaker 的理想方式，甚至可以说，这是一个糟糕的设计。把一个高耗时的操作嵌入订单支付后的主流程，用同步 HTTP 调用的方式来触发它，想想都是个可怕的操作。类似这样的操作应该从主流程里剥离，并将其异步化，在后续的第 16 章里，我们会通过消息的方式对它进行优化。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>增加限流功能</strong></p>\n<p>接下来，就该进入这节的重点了——引入 Resilience4j，实现限流功能。在 pom.xml 中添加如下依赖，它会自动带入 Resilience4j 的众多模块，例如 resilience4j-core、resilience4j-ratelimiter、resilience4j- circuitbreaker、resilience4j-bulkhead 等。当然，resilience4j-spring-boot2 也会有大量适用于 Spring Boot 的自动配置：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.resilience4j&lt;/groupId&gt;\n    &lt;artifactId&gt;resilience4j-spring-boot2&lt;/artifactId&gt;\n    &lt;version&gt;1.7.0&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>由于这是我们第一次接触 Resilience4j，所以先用最原始的代码来实现一下限流功能，大致的步骤如下。</p>\n<p>(1) 根据自己的需要配置 <code>RateLimiterConfig</code>，用 <code>RateLimiterConfig.ofDefaults()</code> 可以创建默认配置，<code>RateLimiterConfig.custom()</code> 可以用来创建自定义配置。</p>\n<p>(2) 用第 (1) 步的配置来创建 <code>RateLimiterRegistry</code>，用 <code>RateLimiterRegistry.ofDefaults()</code> 可以创建使用默认配置的 <code>RateLimiterRegistry</code>，用 <code>RateLimiterRegistry.of()</code> 来传入配置。</p>\n<p>(3) 用第 (2) 步的 <code>RateLimiterRegistry</code> 来创建 <code>RateLimiter</code>，调用 <code>RateLimiterRegistry</code> 的 <code>rateLimiter()</code> 方法，有不同参数的方法可供选择。</p>\n<p>(4) 用 <code>RateLimiter</code> 来装饰我们需要限流的代码，Resilience4j 的 <code>RateLimiter</code> 支持的限流对象，包括 <code>Callable</code>、<code>Runnable</code>、<code>CheckedRunnable</code>、<code>Supplier</code>、<code>CheckedSupplier</code>、<code>Consumer</code>、<code>CheckedConsumer</code> 和 <code>CompletionStage</code>。</p>\n<p>(5) 调用修饰后的代码，而非原始代码。</p>\n<p>resilience4j-spring-boot2 中的 <code>AbstractRateLimiterConfigurationOnMissingBean</code> 配置类里已经配置好了 <code>RateLimiterRegistry</code>，我们可以直接在代码中注入它，创建 <code>RateLimiter</code>。那么 <code>OrderService.make()</code> 方法就要调整成代码示例 15-14 那样，用 <code>rateLimiter.executeSupplier()</code> 把原来的逻辑封装起来，如果碰到限流就会抛出 <code>RequestNotPermitted</code> 异常。</p>\n<blockquote>\n<p><strong>代码示例 15-14</strong>　增加了限流代码的 <code>OrderService.make()</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\npublic class OrderService {\n    @Autowired\n    private RateLimiterRegistry rateLimiterRegistry;\n\n    public ProcessResult make(Long id) {\n        RateLimiter rateLimiter = rateLimiterRegistry.rateLimiter(\"make-tea\");\n        return rateLimiter.executeSupplier(() -&gt; {\n            try {\n                TimeUnit.MILLISECONDS.sleep(timePerOrder.toMillis());\n            } catch (InterruptedException e) {\n            }\n            return ProcessResult.builder()\n                   .finish(true).orderId(id)\n                   .teaMakerId(teaMakerId)\n                   .build();\n        });\n    }\n    // 省略其他代码\n}</code></pre>\n<p>对于抛出的限流异常，上层的 <code>OrderController</code> 需要进行对应的处理，不能让异常直接返回上游。可以针对这个异常返回特定的内容，就像代码示例 15-15 那样，编写一个异常处理器，返回特定的 <code>503 Service Unavailable</code>。</p>\n<blockquote>\n<p><strong>代码示例 15-15</strong>　为 <code>OrderController</code> 增加处理 <code>RequestNotPermitted</code> 的异常处理器</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@RestController\n@RequestMapping(\"/order\")\n@Slf4j\npublic class OrderController {\n    @ExceptionHandler(RequestNotPermitted.class)\n    public ResponseEntity&lt;ProcessResult&gt; handleRequestNotPermitted(HttpServletRequest request) {\n        log.warn(\"请求{}触发限流\", request.getRequestURL());\n        ProcessResult result = ProcessResult.builder().finish(false).build();\n        return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(result);\n    }\n    // 省略其他代码\n}</code></pre>\n<p>限流的各种配置都在 <code>RateLimiterConfigurationProperties</code> 里，我们使用了 Spring Boot，所以可以通过 resilience4j-spring-boot2 的 <code>RateLimiterProperties</code> 来进行配置。所有的配置项都以 <code>resilience4j.ratelimiter</code> 为前缀，用 <code>resilience4j.ratelimiter.instances.XXX</code> 来配置 <code>XXX</code> 限流器的具体参数。对于没有单独配置的限流器，则会使用 <code>resilience4j.ratelimiter.configs.default</code> 中的配置。主要的参数如表 15-2 所示。</p>\n<p><strong>表 15-2　限流相关的部分配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数</th><th>默认值</th><th>说明</th></tr><tr><td><code>limit-for-period</code></td><td><code>50</code></td><td>指定刷新时间段内允许执行的次数</td></tr><tr><td><code>limit-refresh-period</code></td><td><code>500ns</code></td><td>刷新时间段，过了这个时间后限流的计数器会还原</td></tr><tr><td><code>timeout-duration</code></td><td><code>5s</code></td><td>等待限流器放行的超时时间</td></tr><tr><td><code>register-health-indicator</code></td><td><code>false</code></td><td>是否要把这个限流器注册到 Actuator 的健康指标里</td></tr></table>\n\n<p>由于这个配置用 YAML 的可读性会更高一些，所以例子中我们将 <code>application.properties</code> 换为 <code>application.yml</code> 文件，例如下面这样：</p>\n<pre class=\"code-rows\"><code>spring.application.name: tea-maker\nserver.port: 8082\ntea-maker:\n  id: 1\n  time-per-order: 1s\n\nresilience4j:\n  ratelimiter:\n    instances:\n      make-tea:\n        limit-for-period: 1\n        limit-refresh-period: 10s\n        timeout-duration: 2s\n        register-health-indicator: true</code></pre>\n<p>在运行程序后，我们可以打开终端界面，用下面的 curl 命令在短时间内多发起几次调用，如果返回的 HTTP 响应码是 <code>200 OK</code>，说明正常调用，没被限流；如果返回的 HTTP 响应码是 <code>503 Service Unavailable</code>，则说明被限流了：</p>\n<pre class=\"code-rows\"><code>▸ curl -v -d \"\" http://localhost:8082/order/1</code></pre>\n<p>resilience4j-spring-boot2 能做的可不仅仅是为我们自动配置一些 <code>Registry</code> 类，它还包括了很多有用的功能，例如：</p>\n<ul>\n<li>其所依赖的 resilience4j-spring 中还有一些 Spring AOP 切面，例如专门拦截带 <code>@RateLimiter</code> 注解方法的 <code>RateLimiterAspect</code>；</li>\n<li>适配 Actuator 的各种 <code>Endpoint</code> 端点，例如显示限流器信息的 <code>RateLimiterEndpoint</code>；</li>\n<li>在健康检查断点中嵌入容错信息的各种 <code>HealthIndicator</code>，例如 <code>RateLimitersHealthIndicator</code>，可以通过 <code>management.health.ratelimiters.enabled</code> 开启它。</li>\n</ul>\n<p>为了使用 <code>RateLimiterAspect</code> 切面，我们需要引入 Spring AOP 的相关依赖，尤其是 AspectJ。在 pom.xml 中添加如下起步依赖（下文提到的其他 Resilience4j 注解和切面也同样需要这个依赖）：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>上面的代码示例 15-14 可以稍作调整，不用注入 <code>RateLimiterRegistry</code> 创建 <code>RateLimiter</code>，直接加个注解就好了，具体如代码示例 15-16 所示。</p>\n<blockquote>\n<p><strong>代码示例 15-16</strong>　使用 <code>@RateLimiter</code> 实现限流</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\npublic class OrderService {\n    @RateLimiter(name = \"make-tea\")\n    public ProcessResult make(Long id) {\n        // 内容如代码示例15-13的make()方法\n    }\n    // 省略其他代码\n}</code></pre>\n<p>为了能够通过 Actuator 来查看限流相关的信息，需要在 <code>application.yml</code> 中添加如下配置，<code>endpoints.web.exposure.include</code> 可以写具体要放开的端点，此处只是演示，因此用了 <code>*</code>：</p>\n<pre class=\"code-rows\"><code>management:\n  health.ratelimiters.enabled: true\n  endpoints.web.exposure.include: \"*\"\n  endpoint.health.show-details: always</code></pre>\n<p>再次运行程序，发起几次调用，随后我们可以通过浏览器访问健康检查端点，也就是 http://localhost:8082/actuator/health。能看到比较详细的信息，限流相关的信息在 <code>rateLimiters</code> 部分里，其中就包含了我们注册进去的 <code>make-tea</code>：</p>\n<pre class=\"code-rows\"><code>  {\n    \"status\": \"UP\",\n    \"components\": {\n      \"rateLimiters\": {\n        \"status\": \"UP\",\n        \"details\": {\n          \"make-tea\": {\n            \"status\": \"UP\",\n            \"details\": {\n              \"availablePermissions\": 1,\n              \"numberOfWaitingThreads\": 0\n            }\n          }\n        }\n      }\n      // 省略其他内容\n    }\n  }</code></pre>\n<p>而在 <code>http://localhost:8082/actuator/metrics</code> 中还包含了容错信息相关的度量指标，例如与限流相关的 <code>resilience4j.ratelimiter.available.permissions</code> 和 <code>resilience4j.ratelimiter.waiting_threads</code>，可以访问 <code>http://localhost:8082/actuator/metrics/resilience4j.ratelimiter.waiting_threads</code> 查看具体的内容。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_234\">15.2.2　使用 Resilience4j 实现断路</h3>\n<p>在知道了限流的实现方法后，再来看断路就会容易很多。Resilience4j 的断路器是在 resilience4j- circuitbreaker 模块里的，不过我们引入的 resilience4-spring-boot2 已经把各种需要用到的 Resilience4j 模块都带上了，因此就不需要再手动引入依赖了。</p>\n<p>Resilience4j 的断路器在遇到调用失败和慢调用时都会更新内部的统计值，当失败或耗时过慢的比例超过阈值后，断路器就会开启，后续的请求会抛出 <code>CallNotPermittedException</code> 异常。断路器处于开启状态一段时间后，会转入半开状态，放一部分请求做实际调用，判断下游是否已经恢复，如果恢复就关闭。Resilience4j 的断路器使用滑动窗口来存储并聚合调用结果，有两种实现可供选择，一种是基于<strong>计数</strong>的滑动窗口，统计的是 <em>N</em> 次调用的情况；另一种是基于<strong>时间</strong>的滑动窗口，统计的是 <em>N</em> 秒里的调用情况，默认用的是前者。</p>\n<ol>\n<li><p><strong>断路器配置</strong></p>\n<p><code>CircuitBreakerConfig</code> 是断路器的具体配置类，Spring Boot 里用到的则是 <code>CircuitBreakerProperties</code>。断路器相关的配置项都以 <code>resilience4j.circuitbreaker</code> 为前缀，我们可以用 <code>resilience4j.circuitbreaker.instances.XXX</code> 来配置 <code>XXX</code> 断路器的具体参数。对于没有单独配置的断路器，则会使用 <code>resilience4j.circuitbreaker.configs.default</code> 中的配置。表 15-3 列举了一些常用的配置项。</p>\n<p><strong>表 15-3　断路器相关的部分配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><td>配置项</td><th>默认值</th><th>说明</th></tr><tr><td><code>failure-rate-threshold</code></td><td><code>50</code></td><td>失败率阈值，大于等于该阈值的情况下断路器进入开启状态</td></tr><tr><td><code>slow-call-rate-threshold</code></td><td><code>100</code></td><td>慢请求比例阈值，大于等于该阈值的情况下断路器进入开启状态</td></tr><tr><td><code>slow-call-duration-threshold</code></td><td><code>60000ms</code></td><td>慢请求耗时阈值，超过该阈值的请求会被视为慢请求</td></tr><tr><td><code>sliding-window-type</code></td><td><code>COUNT_BASED</code></td><td>滑动窗口类型，基于计数（<code>COUNT_BASED</code>）的窗口还是基于时间（<code>TIME_BASED</code>）的窗口</td></tr><tr><td><code>sliding-window-size</code></td><td><code>100</code></td><td>滑动窗口的大小，如果是基于计数的窗口，要记录的是最后 <i>N</i> 个请求；如果是基于时间的窗口，则要记录的是最后 <i>N</i> 秒内的请求</td></tr><tr><td><code>minimum-number-of-calls</code></td><td><code>100</code></td><td>每个窗口内的最少调用次数，少于该次数不会计算失败率和慢请求比例</td></tr><tr><td><code>max-wait-duration-in-half-open-state</code></td><td><code>0ms</code></td><td>在半开状态下最多等待多少时间切换回打开状态，<code>0</code> 意味着在所有放行的请求结束前都会维持半开状态</td></tr><tr><td><code>wait-duration-in-open-state</code></td><td><code>60000ms</code></td><td>打开状态下，持续多长时间切换到半开状态</td></tr><tr><td><code>permitted-number-of-calls-in-half-open-state</code></td><td><code>10</code></td><td>半开状态下允许放过多少个请求去下游</td></tr><tr><td><code>record-exceptions</code></td><td>空</td><td>要被记录为失败，增加失败率的异常列表；如果在这里配置了异常，那其他的异常（除了 <code>ignore-exceptions</code> 里配置的）都会被视为成功</td></tr><tr><td><code>ignore-exceptions</code></td><td>空</td><td>要被忽略的异常，其中配置的异常既不会被视为失败，也不会被视为成功</td></tr><tr><td><code>register-healtd-indicator</code></td><td><code>false</code></td><td>是否要把这个断路器注册到 Actuator 的健康指标里</td></tr></table>\n\n<p>与限流一样，Resilience4j 的断路器也可以使用编程和注解两种方式。断路器的配置放在 <code>CircuitBreakerConfig</code> 中，可以用 <code>CircuitBreakerConfig.custom()</code> 来创建自定义配置，随后将配置传给 <code>CircuitBreakerRegistry</code>，通过它来创建具体的 <code>CircuitBreaker</code>。大概会是下面这样的：</p>\n<pre class=\"code-rows\"><code>// 使用默认配置创建CircuitBreakerRegistry\nCircuitBreakerRegistry registry = CircuitBreakerRegistry.ofDefaults();\nCircuitBreaker circuitBreaker = registry.circuitBreaker(\"tea-maker\");\ncircuitBreaker.executeSupplier(() -&gt; {...});</code></pre>\n<p>不过，在通常情况下，还是使用 <code>@CircuitBreaker</code> 注解更方便一些，而且 resilience4j-spring-boot2 还替我们自动配置了 <code>CircuitBreakerRegistry</code> 等内容，只需通过 Properties 或者 YAML 提供配置即可。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>断路保护示例</strong></p>\n<p>在了解了 Resilience4j 断路器的基本情况后，让我们通过一个例子来加深一下对它的认识。</p>\n<blockquote>\n<p><strong>需求描述</strong>　顾客在二进制奶茶店支付完订单后，会在收银台旁边等着，由于我们没有叫号系统，所以目前顾客就只能隔段时间来问一声：“我的饮料做好了吗？”如果一直没做好，问多了顾客也烦，工作人员还得不停地回答，又或者在人多时根本来不及回答，这种情况下，我们希望顾客问了几次都没做好或者没消息时隔段时间再问。</p>\n</blockquote>\n<p>我们可以理解并翻译一下这个需求，其中包含了两个子需求。</p>\n<ul>\n<li>Customer 系统在付款后就要不断向 BinaryTea 发起查询请求，通过订单 ID 查询订单状态，如果状态没到 <code>FINISHED</code> 就过一段时间再查，直到状态为 <code>FINISHED</code> 为止。</li>\n<li>如果遇到查询失败报错，或者是多次返回的订单状态未到 <code>FINISHED</code>，可以开启断路，一段时间里不再发起查询。</li>\n</ul>\n<p>为了实现第一个需求，要修改一下 BinaryTea 工程，提供一个查询单笔订单的接口，分别要修改 <code>OrderController</code> 和 <code>OrderService</code> 这两个类。先在 <code>OrderService</code> 里增加查询单笔订单的方法，直接通过 <code>OrderRepository</code> 就能完成查询，具体如代码示例 15-17 所示。<span class=\"comment-number\">9</span></p>\n<blockquote>\n<p><strong>代码示例 15-17</strong>　增加了查询单笔订单方法的 <code>OrderService</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Transactional\n@Slf4j\npublic class OrderService {\n    public Optional&lt;Order&gt; queryOrder(Long id) {\n        return orderRepository.findById(id);\n    }\n    // 省略其他代码\n}</code></pre>\n<p>随后在 <code>OrderController</code> 里增加一个处理 <code>/order/ GET</code> 请求的方法，根据传入的订单号查询订单，如果找不到对应订单就直接返回 <code>404 Not Found</code>。具体如代码示例 15-18 所示。</p>\n<blockquote>\n<p><strong>代码示例 15-18</strong>　处理 <code>/order/</code> 请求的 <code>OrderController</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Controller\n@RequestMapping(\"/order\")\n@Slf4j\npublic class OrderController {\n    @ResponseBody\n    @GetMapping(\"/\")\n    public ResponseEntity&lt;Order&gt; queryOneOrder(@PathVariable(\"id\") Long id) {\n        Optional&lt;Order&gt; result = orderService.queryOrder(id);\n        if (result.isPresent()) {\n            return ResponseEntity.ok(result.get());\n        } else {\n            return ResponseEntity.notFound().build();\n        }\n    }\n    // 省略其他代码\n}</code></pre>\n<p>程序运行后，可以通过 curl 命令带上身份信息访问一下 <code>/order/1</code>，看看能否取回编号为 <code>1</code> 的订单内容：</p>\n<pre class=\"code-rows\"><code>▸ curl -v -u LiLei:binarytea http://localhost:8080/order/1</code></pre>\n<p>在 Customer 工程里，同样要在 <code>OpenFeign</code> 接口里加上这个 URL 的定义，就像代码示例 15-19 那样。</p>\n<blockquote>\n<p><strong>代码示例 15-19</strong>　增加了 <code>/order/</code> 的 <code>OrderService</code> 接口代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@FeignClient(contextId = \"orderService\", name = \"binarytea\", path = \"/order\")\npublic interface OrderService {\n    @GetMapping(path = \"/\", produces = MediaType.APPLICATION_JSON_VALUE)\n    ResponseEntity&lt;Order&gt; queryOneOrder(@PathVariable(\"id\") Long id);\n    // 省略其他代码\n}</code></pre>\n<p>由于 <code>OrderService</code> 是个 <code>OpenFeign</code> 接口，具体的实现是在运行时生成的，不方便添加上面第二个子需求的逻辑，所以我们将查询并判断结果的逻辑写到了 <code>BinaryTeaClient</code> 里。通过 <code>OrderService</code> 查询订单，如果订单不存在就抛出异常，存在的话判断订单的状态，如果为 <code>FINISHED</code> 则返回 <code>true</code>，否则抛出异常。记得在 <code>CustomerApplication</code> 里定义 <code>BinaryTeaClient</code> 的 Bean 实例，同时去掉之前自己手动编写的 AOP 容错切面。</p>\n<p>代码示例 15-20 中需要重点说明一下 <code>@CircuitBreaker</code> 注解的用法，<code>name</code> 指定了断路器的名称，<code>fallbackMethod</code> 指定了断路器开启后降级调用的方法，该方法必须在同一个类里，方法的签名与原方法相同，但需要在参数最后增加一个异常参数，用来标明处理的异常，如果有多个 <code>orderIsNotFinished()</code> 方法，那么后面可以跟不同类型的异常。</p>\n<blockquote>\n<p><strong>代码示例 15-20</strong>　用来判断订单是否完成的 <code>BinaryTeaClient</code> 类与 <code>OrderNotFinishedException</code> 异常定义</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class BinaryTeaClient {\n    @Autowired\n    private OrderService orderService;\n\n    @CircuitBreaker(name = \"order-checker\", fallbackMethod = \"orderIsNotFinished\")\n    public boolean isOrderFinished(Long id) {\n        ResponseEntity&lt;Order&gt; entity = orderService.queryOneOrder(id);\n        if (HttpStatus.NOT_FOUND == entity.getStatusCode()) {\n            throw new IllegalArgumentException(\"没找到订单\");\n        }\n        Order order = entity.getBody();\n        if (\"FINISHED\".equalsIgnoreCase(order.getStatus())) {\n            return true;\n        }\n        log.info(\"订单{}还没好\", id);\n        throw new OrderNotFinishedException();\n    }\n\n    public boolean orderIsNotFinished(Long id, Exception e) {\n        return false;\n    }\n}\n\npublic class OrderNotFinishedException extends RuntimeException {\n}</code></pre>\n<p>接着，来重构一下 <code>OrderRunner</code> 类，为了让 <code>run()</code> 方法不至于太过冗长，我们需要将其中的逻辑拆分一下，将创建订单、支付订单、查询订单是否完成以及取订单放到三个不同的方法里。支付与取订单都是修改订单状态，因此共用了 <code>modifyOrderState()</code> 方法。具体如代码示例 15-21 所示。在 <code>waitUntilFinished()</code> 方法中针对几种不同的异常分别进行了处理，每次查询后等待 1 秒再发起下次的查询。</p>\n<blockquote>\n<p><strong>代码示例 15-21</strong>　增加了等待订单完成逻辑的 <code>OrderRunner</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Order(5)\n@Setter\n@Slf4j\npublic class OrderRunner implements ApplicationRunner {\n    @Autowired\n    private OrderService orderService;\n    @Autowired\n    private BinaryTeaClient client;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        List&lt;learning.spring.customer.model.Order&gt; orders = orderService.listOrders();\n        log.info(\"调用前的订单数量: {}\", orders.size());\n        Long id = createOrder();\n        modifyOrderState(id, \"PAID\");\n        waitUntilFinished(id);\n        modifyOrderState(id, \"TAKEN\");\n    }\n\n    private void waitUntilFinished(Long id) {\n        boolean flag = false;\n        while (!flag) {\n            try {\n                flag = client.isOrderFinished(id);\n                log.info(\"订单{}完成了没{}\", id, flag);\n                if (!flag) {\n                    TimeUnit.SECONDS.sleep(1);\n                }\n            } catch (IllegalArgumentException e) {\n                log.warn(\"没找到订单{}\", id);\n                break;\n            } catch (OrderNotFinishedException e) {\n                log.info(\"订单{}还没准备好\", id);\n            } catch (Exception e) {\n                log.error(\"啊呀有问题\", e);\n            }\n        }\n        log.info(\"订单{}已经好了\", id);\n    }\n\n    private Long createOrder() {...}\n    private void modifyOrderState(Long id, String state) {...}\n}</code></pre>\n<p>最后，还需要为 <code>order-checker</code> 这个断路器配置各种参数。这次我们换用 Properties 的方式来进行配置，在 <code>application.properties</code> 里添加代码示例 15-22 里的内容。具体的含义是这样的，使用默认的基于计数的滑动窗口，窗口大小设置为 30 次调用，最少要有 5 次调用才开始统计，断路器打开后等 10 秒钟进入半开状态，放行 2 个请求去检查订单是否已完成。由于我们的代码里针对订单不存在的状态做了特殊处理，所以忽略 <code>java.lang.IllegalArgumentException</code> 这种异常类型。</p>\n<blockquote>\n<p><strong>代码示例 15-22</strong>　<code>application.properties</code> 中添加 <code>order-checker</code> 相关的断路配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>resilience4j.circuitbreaker.instances.order-checker.sliding-window-size=30\nresilience4j.circuitbreaker.instances.order-checker.minimum-number-of-calls=5\nresilience4j.circuitbreaker.instances.order-checker.wait-duration-in-open-state=10s\nresilience4j.circuitbreaker.instances.order-checker.permitted-number-of-calls-in-half-open-state=2\nresilience4j.circuitbreaker.instances.order-checker.ignore-exceptions=java.lang.IllegalArgumentException\nresilience4j.circuitbreaker.instances.order-checker.register-health-indicator=true</code></pre>\n<p>Customer 运行后，我们可以根据日志中“订单 <code>{}</code> 还没好”和“订单 <code>{}</code> 还没准备好”的出现次数与间隔来判断断路器的状态。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_235\">15.2.3　使用 Resilience4j 实现隔离</h3>\n<p>Resilience4j 中与舱壁模式相关的内容是放在 resilience4j-bulkhead 模块里的，其中针对舱壁模式提供了两种实现，第一种是<strong>基于信号量</strong>的 <code>SemaphoreBulkhead</code>，另一种是<strong>基于有界队列和固定大小线程池</strong>的 <code>FixedThreadPoolBulkhead</code>，默认使用前者。</p>\n<ol>\n<li><p><strong>舱壁模式配置</strong></p>\n<p>与之前介绍的限流和断路一样，通过舱壁模式实现隔离也有编程和注解两种方式。编程模式配置放在 <code>BulkheadConfig</code> 中，通过 <code>BulkheadRegistry</code> 或者 <code>ThreadPoolBulkheadRegistry</code> 来创建 <code>Bulkhead</code> 对象，与之前介绍的另两种容错方式几乎是一样的。注解方式使用的是 <code>@Bulkhead</code> 注解，其中 <code>name</code> 属性用来指定名称，<code>type</code> 属性用来指定实现类型。</p>\n<p>resilience4j-spring-boot2 为我们完成了相关 Bean 的自动配置，基本上我们只需要进行一小部分配置就好了。由于 Resilience4j 里舱壁模式的两种配置差异较大，所以对应的配置也被拆成了两个配置类。基于信号量的默认实现配置放在 <code>BulkheadProperties</code> 里，属性的前缀是 <code>resilience4j.bulkhead</code>，表 15-4 罗列了其中的 2 个常用的配置项。</p>\n<p><strong>表 15-4　<code>resilience4j.bulkhead</code> 下的常用配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>max-concurrent-calls</code></td><td><code>25</code></td><td>允许的最大并行执行量</td></tr><tr><td><code>max-wait-duration</code></td><td><code>0</code></td><td>在获得执行权限前线程最多阻塞多久</td></tr></table>\n\n<p><code>FixedThreadPoolBulkhead</code> 的配置前缀是 <code>resilience4j.thread-pool-bulkhead</code>，对应的配置类是 <code>ThreadPoolBulkheadProperties</code>，表 15-5 罗列了其中的 4 个常用配置项。</p>\n<p><strong>表 15-5　<code>resilience4j.thread-pool-bulkhead</code> 下的常用配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>max-thread-pool-size</code></td><td><code>Runtime.getRuntime().availableProcessors()</code></td><td>线程池的最大线程数</td></tr><tr><td><code>core-thread-pool-size</code></td><td><code>Runtime.getRuntime().availableProcessors() - 1</code></td><td>线程池的核心线程数</td></tr><tr><td><code>queue-capacity</code></td><td><code>100</code></td><td>有界队列的大小</td></tr><tr><td><code>keep-alive-duration</code></td><td><code>20ms</code></td><td>当线程数大于核心线程数时，销毁线程前的最大等待时间</td></tr></table>\n\n<p>&nbsp;</p>\n</li>\n<li><p><strong>舱壁模式示例</strong></p>\n<p>同样的，在了解了基本的配置后，我们来看个实际的例子，加深下印象。</p>\n<blockquote>\n<p><strong>需求描述</strong>　有时店里的订单来得太多，调茶师根本来不及制做，所以响应会非常慢。前台时不时去询问调茶师是否已经制作完成，他还要花时间查看订单再答复，由于订单分配给了不同的调茶师，询问一单没有回复，不代表另一单也没有。所以可以考虑针对不同的调茶师做个隔离，分开询问。</p>\n</blockquote>\n<p>分析下这个需求，我们需要在 BinaryTea 里增加一个通知的功能，通知调茶师制作订单。正常情况下应该对不同的调茶师设置不同的舱壁做隔离，一个没回复不影响另一个，这里为了演示方便，就根据订单号取模来做隔离。</p>\n<p>既然是要通知 TeaMaker，那自然是要在 BinaryTea 中增加一个调用的客户端，本章中我们使用 <code>RestTemplate</code> 来发起 HTTP 调用，在后面的第 16 章介绍到消息队列后，我们会转向使用消息的方式。代码示例 15-23 是一个 TeaMaker 的客户端，通过 <code>RestTemplate</code> 对 <code>/order/</code> 发起 <code>POST</code> 请求。这里的 <code>makeTea()</code> 方法上增加了 <code>@Bulkhead</code> 注解，说明这个方法会在一个隔离的舱壁内执行。这个注解除了使用 <code>name</code> 属性指定名称外，还可以通过 <code>type</code> 指定类型，默认是 <code>SEMAPHORE</code>，即基于信号量的，也可以选择 <code>THREADPOOL</code>，此外还有降级用的 <code>fallbackMethod</code> 属性。在设置舱壁的名称时，这里使用了 SpEL 表达式，<code>#root.args[0]</code> 是传入的第一个参数，除以 2 取模后，基数是 <code>1</code>，偶数是 <code>0</code>，所以得到的名字分别是 <code>0-tea-maker</code> 和 <code>1-tea-maker</code>。</p>\n<blockquote>\n<p><strong>代码示例 15-23</strong>　用来发起通知 TeaMaker 制作订单的客户端</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\npublic class TeaMakerClient {\n    @Autowired\n    private RestTemplate restTemplate;\n    @Value(\"$\")\n    private String teaMakerUrl;\n\n    @Bulkhead(name = \"#root.args[0] % 2 + '-tea-maker'\")\n    public TeaMakerResult makeTea(Long id) {\n        ResponseEntity&lt;TeaMakerResult&gt; entity = restTemplate\n            .postForEntity(teaMakerUrl + \"/order/\", null,\n            TeaMakerResult.class, id);\n        log.info(\"请求TeaMaker，响应码：{}\", entity.getStatusCode());\n        if (entity.getStatusCode() == HttpStatus.BAD_REQUEST) {\n            return null;\n        }\n        return entity.getBody();\n    }\n}\n\n@Getter\n@Setter\npublic class TeaMakerResult {\n    private boolean finish;\n    private long orderId;\n    private long teaMakerId;\n}</code></pre>\n<p>有了具体的客户端之后，接下来就是编写触发通知的代码。在付款的线程里执行通知虽然看起来方便，但会要求付款的接口增加远程调用，这既会导致响应时间变慢又会带来额外的失败风险，所以这里考虑在另一个线程里进行通知。代码示例 15-24 设计了一个定时任务，在 <code>notifyTeaMaker()</code> 上增加了 2.4.2 节中介绍过的 <code>@Scheduled</code> 注解，两次执行间隔 <code>2000</code> 毫秒。定时任务的具体内容是从数据库里找到状态是 <code>PAID</code> 的订单，随后遍历这些订单发起通知，在获得执行的结果后将其中的调茶师信息保存到订单里，并将订单状态修改为 <code>FINISHED</code>。</p>\n<blockquote>\n<p><strong>请注意</strong>　这里只是出于演示的目的，并没有添加必要的防并发逻辑。如果同时有几个 <code>notifyTeaMaker()</code> 在运行，可能出现多次通知的情况。针对这种情况有很多不同的解决方案，常见的是加锁或者下游做幂等。</p>\n<p><strong>代码示例 15-24</strong>　触发通知用的定时任务</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\npublic class TeaMakerNotifier {\n    @Autowired\n    private OrderRepository orderRepository;\n    @Autowired\n    private TeaMakerRepository teaMakerRepository;\n    @Autowired\n    private TeaMakerClient teaMakerClient;\n\n    @Scheduled(fixedDelay=2000)\n    public void notifyTeaMaker() {\n        // 没考虑并发执行的问题\n        List&lt;Order&gt; orders = orderRepository.findByStatusOrderById(OrderStatus.PAID);\n        for (Order o : orders) {\n            try {\n                notifyOneOrder(o);\n            } catch(Exception e) {\n                log.error(\"通知处理订单失败\", e);\n            }\n        }\n    }\n\n    private void notifyOneOrder(Order o) {\n        TeaMakerResult result = teaMakerClient.makeTea(o.getId());\n        if (result == null || !result.isFinish()) {\n            return;\n        }\n        teaMakerRepository.findById(result.getTeaMakerId()).ifPresent(o::setMaker);\n        o.setStatus(OrderStatus.FINISHED);\n        orderRepository.save(o);\n    }\n}</code></pre>\n<p>为了让上面两段代码能顺利运行起来，需要开启定时任务支持，并在 Spring 上下文中添加一个 <code>RestTemplate</code> Bean。所以我们要简单地修改一下 <code>BinaryTeaApplication</code> 类，就像代码示例 15-25 那样，增加 <code>@EnableScheduling</code> 注解，并增加一个带有 <code>@LoadBalanced</code> 注解的 <code>restTemplate()</code> Bean 声明方法，告诉 Spring 这个 <code>RestTempalte</code> 支持基于服务发现的负载均衡。当然我们完全可以像 Customer 工程里那样通过 <code>RestTemplateBuilder</code> 来定制自己的 <code>RestTemplate</code>，这就交给大家自己动手了。再说后面的通知会改为基于消息方式的，这里就简单一些吧。</p>\n<blockquote>\n<p><strong>代码示例 15-25</strong>　修改后的 <code>BinaryTeaApplication</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableCaching\n@EnableScheduling\npublic class BinaryTeaApplication implements WebMvcConfigurer {\n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n    // 省略其他代码\n}</code></pre>\n<p>最后，不要忘记修改 <code>application.properties</code>，增加需要的 <code>tea-maker.url</code> 属性，配置 TeaMaker 的地址。如果想对 <code>tea-maker</code> 这个 Bulkhead 的配置做些调整，也可以加进去，就像代码示例 15-26 那样（在 15.2.4 节中会解释其中的 <code>configs</code> 的用法）。</p>\n<blockquote>\n<p><strong>代码示例 15-26</strong>　BinaryTea 的 <code>application.properties</code> 需要增加的配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>tea-maker.url=http://tea-maker\nresilience4j.bulkhead.configs.tea-maker.max-concurrent-calls=2\nresilience4j.bulkhead.configs.tea-maker.max-wait-duration=500ms\nresilience4j.bulkhead.instances.0-tea-maker.base-config=tea-maker\nresilience4j.bulkhead.instances.1-tea-maker.base-config=tea-maker</code></pre>\n<p>至此，BinaryTea 的修改就结束了。因为 15.2.1 里编写的 TeaMaker 项目还不支持服务注册与发现，所以这里为了让 BinaryTea 能找到它，我们需要在 TeaMaker 的 pom.xml 里增加 <code>spring-cloud-starter-zookeeper-discovery</code> 依赖，并在 <code>application.yml</code> 中增加 Zookeeper 地址配置，就像下面这样：</p>\n<pre class=\"code-rows\"><code>spring.cloud.zookeeper.connect-string: \"localhost:2181\"</code></pre>\n<p>现在，按照 TeaMaker、BinaryTea、Customer 的顺序启动工程，可以看到 Customer 最终成功打出了订单已经准备好了的日志，同时多跑几个 Customer 进程就能看到 BinaryTea 里舱壁隔离的效果。如果希望效果明显些，可以调整 TeaMaker 中 <code>tea-maker.time-per-order</code> 的时间，每单处理时间拉长一些，例如设置为 <code>10s</code>，那同时运行 3 个 Customer 很容易就能看到“通知处理订单失败”的日志。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_236\">15.2.4　resilience4j-spring-boot2 的特别说明</h3>\n<p>15.2 节我们介绍了 Resilience4j 提供的一些不同的容错功能，它可以直接使用，但因为我们是在 Spring Boot 的项目里，所以很自然地就会直接去用它提供的 Spring Boot 支持。虽然文中只介绍了限流、断路和舱壁的用法，但使用 resilience4j-spring-boot2 的话，大部分的容错功能的使用方法大同小异。接下来我们就几个通用的点做个说明。</p>\n<ol>\n<li><p><strong>注解中的 <code>fallbackMethod</code></strong></p>\n<p>在介绍 <code>@CircuitBreaker</code> 时，我们演示了该注解中的 <code>fallbackMethod</code> 的用法。其实，不止这个注解，resilience4j-annotations 包里的 <code>@Bulkhead</code>、<code>@RateLimiter</code>、<code>@Retry</code> 和 <code>@TimeLimiter</code> 注解都有 <code>fallbackMethod</code> 这个属性。Resilience4j 的各个 <code>Aspect</code> 在发现配置了 <code>fallbackMethod</code> 这个属性后，会把带有注解的整个方法的执行过程用 <code>FallbackDecorator</code> 包装起来，在抛异常时会调用属性里指定的方法。以默认实现 <code>DefaultFallbackDecorator</code> 为例，它会捕获 <code>Throwable</code> 类型的所有异常，所以无论是容错对应的异常，还是业务异常，或者其他什么异常，都会转到降级的方法上。</p>\n<p>关于降级的目标方法，除了直接给定方法名，也可以使用 SpEL 计算出方法名。<code>name</code> 和 <code>fallbackMethod</code> 都可以使用 SpEL，我们在 8.3.1 节中介绍过一些表达式，这里再简单回顾下。想要取得当前的方法名，可以使用 <code>#root.methodName</code>；想要获取第 1 个参数的值，可以用 <code>#root.args[0]</code>，也可以缩写成 <code>#p0</code> 或 <code>#a0</code>，分别是单词 parameter 和 argument 的首字母，它们都是参数的意思。有了 SpEL 的加持，可以实现根据参数内容选择不同的容错实例的功能，例如在使用舱壁模式时，也可以根据参数来选择不同的 <code>Bulkhead</code>，他们各有各的信号量控制并发计数。在这种场景下的 SpEL 表达式中 <code>#</code> 必须放在前面，不然会被解释成普通字符串。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>各个实例的公共配置</strong></p>\n<p>在之前的例子中，我们都是针对实例做的配置，例如 <code>resilience4j.ratelimiter.instances.make-tea</code> 和 <code>resilience4j.circuitbreaker.instances.order-checker</code>。可以发现配置项的格式大概是这样的 <code>resilience4j.XXX.instances.YYY.ZZZ</code>，其中 <code>XXX</code> 是对应的容错组件，例如 <code>ratelimiter</code>、<code>circuitbreaker</code>；<code>YYY</code> 是实例名称，例如 <code>order-checker</code>；<code>ZZZ</code> 是具体的配置项，例如 <code>max-concurrent-calls</code>。</p>\n<p>我们的例子比较简单，所以配置项不多，一个个配置也就罢了。但在实际的项目里，会有很多实例，而且还在不断增加，每个都人工配置显然是不行的。可以通过 <code>resilience4j.XXX.configs.default</code> 提供 <code>XXX</code> 组件的默认配置，但凡没有单独配置的实例都会使用该默认配置。</p>\n<p>除了默认配置，多个实例间也可以共享配置，通过 <code>resilience4j.XXX.instance.YYY.base-config</code> 来指定 <code>YYY</code> 实例要继承的基础配置名，假设我们有如下设置：</p>\n<pre class=\"code-rows\"><code>resilience4j.circuitbreaker.instances.order-checker.base-config=foo</code></pre>\n<p>那么 <code>CircuitBreakerConfigurationProperties</code> 在创建对应配置时就会去查找 <code>resilience4j.circuitbreaker.configs.foo</code> 下面的配置，这个配置可能是这样的：</p>\n<pre class=\"code-rows\"><code>resilience4j.circuitbreaker.configs.foo.sliding-window-size=100\nresilience4j.circuitbreaker.configs.foo.minimum-number-of-calls=10</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>各个注解的顺序</strong></p>\n<p>Resilience4j 为我们提供了 5 个不同的注解，对应了 5 个切面，具体如表 15-6 所示，每个切面都是实现了 <code>Ordered</code> 接口的，所以可以指定顺序。<code>BulkheadAspect</code> 的优先级是 <code>Ordered.LOWEST_ PRECEDENCE</code>，从 0.16.0 版本开始，这个值就被“固定死”了，所以这也是 5 个切面中唯一一个不能修改顺序的。表格中自下往上，其他几个切面的 <code>order</code> 分别是 <code>Ordered.LOWEST_PRECEDENCE-1</code> 一直到 <code>Ordered.LOWEST_PRECEDENCE-4</code>，其中的数值越小越先执行，大概的示意如下：</p>\n<pre class=\"code-rows\"><code>Retry ( CircuitBreaker ( RateLimiter ( TimeLimiter ( Bulkhead ( 具体方法 ) ) ) ) )</code></pre>\n<p><strong>表 15-6　Resilience4j 提供的注解与对应切面</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>注解</th><th>切面</th><th>顺序配置属性</th><th>默认优先级</th></tr><tr><td><code>@Retry</code></td><td><code>RetryAspect</code></td><td><code>resilience4j.retry.retry-aspect-order</code></td><td>1</td></tr><tr><td><code>@CircuitBreaker</code></td><td><code>CircuitBreakerAspect</code></td><td><code>resilience4j.circuitbreaker.circuit-breaker-aspect-order</code></td><td>2</td></tr><tr><td><code>@RateLimiter</code></td><td><code>RateLimiterAspect</code></td><td><code>resilience4j.ratelimiter.rate-limiter-aspect-order</code></td><td>3</td></tr><tr><td><code>@TimeLimiter</code></td><td><code>TimeLimiterAspect</code></td><td><code>resilience4j.timelimiter.time-limiter-aspect-order</code></td><td>4</td></tr><tr><td><code>@Bulkhead</code></td><td><code>BulkheadAspect</code></td><td><code>resilience4j.bulkhead.bulkhead-aspect-order</code>（不可改）</td><td>5</td></tr></table>\n\n</li>\n</ol>\n<h2 id=\"nav_point_237\">15.3　使用 Spring Cloud CircuitBreaker 实现容错</h2>\n<p>按照 Spring Framework 的设计理念，如果一个常用的东西有多种流行的实现，那大概率就能从这几种实现里抽象出一层通用接口，让开发者通过这层抽象编写代码，框架来负责处理底层的这些差异，例如书中介绍过的对象关系映射就是一个很好的例子。针对服务容错，目前也有好几款知名的开源框架，早期的 Netflix Hystrix，接棒 Hystrix 的 Resilience4j，国内阿里巴巴开源的 Sentinel，还有 Spring 自家的 Spring Retry。这些框架提供的能力大同小异，而在实践中大家的用途又是类似的，所以自然可以进行抽象封装，这就有了本节要介绍的 Spring Cloud CircuitBreaker。</p>\n<p>从 Spring Cloud CircuitBreaker 的名字就能看出，这个框架主要聚焦于服务容错的断路器之上。但在具体的实现层面，它还是会充分发挥底层的框架能力，组合使用超时、舱壁和断路功能。整个框架的核心是位于 spring-cloud-commons 包中的 <code>CircuitBreaker</code> 接口，<code>CircuitBreakerFactory</code> 是用来创建 <code>CircuitBreaker</code> 的，断路器所需的各种配置则通过 <code>ConfigBuilder</code> 来构造。</p>\n<p>知道了这些后，我们就能用它来编写代码了，在业务类中注入 <code>CircuitBreakerFactory</code>，通过它创建 <code>CircuitBreaker</code> 封装需要实现断路保护的业务代码即可。</p>\n<h3 id=\"nav_point_238\">15.3.1　通过 Spring Cloud CircuitBreaker 使用 Resilience4j</h3>\n<p>接下来，我们修改一下前文中直接使用 Resilience4j 的例子，通过 Spring Cloud CircuitBreaker 来实现断路功能，其底层还是 Resilience4j，看看编码时具体会有哪些变化。</p>\n<p>在依赖方面，我们不用再自己依赖 resilience4j-spring-boot2 了，改为使用 spring-cloud-starter-circuitbreaker-resilience4j，它会带入所需的各个组件，但其中不包含 <code>resilience4j-bulkhead</code>，我们可以按需自行添加该依赖。另外，下面这个依赖是从 2020.0.3 版本开始加入 spring-cloud-dependencies 中的，如果使用之前的老版本，需要自己添加版本，比如 2.1.1：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-circuitbreaker-resilience4j&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p><code>CircuitBreaker</code> 接口定义了两个 <code>run()</code> 方法，一个直接通过 <code>Supplier&lt;T&gt;</code> 传入要封装的业务逻辑，另一个则额外提供了一个降级方法，就类似 <code>@CircuitBreaker</code> 注解里的 <code>fallbackMethod</code> 属性，具体的接口定义如下所示 <span class=\"comment-number\">10</span>：</p>\n\n<pre class=\"code-rows\"><code>public interface CircuitBreaker {\n    &lt;T&gt; T run(Supplier&lt;T&gt; toRun);\n    &lt;T&gt; T run(Supplier&lt;T&gt; toRun, Function&lt;Throwable, T&gt; fallback);\n}</code></pre>\n<p>接下来，我们用 <code>CircuitBreaker</code> 改写 Customer 工程里的 <code>BinaryTeaClient</code> 类，需要注意修改 <code>import</code> 的内容，毕竟注解和这里用到的接口同名。代码示例 15-27<span class=\"comment-number\">11</span> 是修改后的 <code>BinaryTeaClient</code> 类，主要做了如下改动。</p>\n\n<ul>\n<li>通过构造方法注入 <code>CircuitBreakerFactory</code>，用它创建了后面要用的名为 <code>order-checker</code> 的 <code>CircuitBreaker</code> 实例。</li>\n<li>将原先的 <code>isOrderFinished()</code> 方法内容变为 <code>CircuitBreaker.run()</code> 的第一个参数，用 Lambda 表达式就可以了。</li>\n<li>由于我们的降级逻辑就是直接返回 <code>false</code>，所以不再需要额外的方法定义，直接用 <code>t -&gt; false</code> 作为 <code>run()</code> 的第二个参数即可。</li>\n</ul>\n<p>由于 <code>BinaryTeaClient</code> 增加了构造方法，因而我们需要调整 <code>CustomerApplication</code> 里声明对应 Bean 的方法，这里就不再赘述了。</p>\n<blockquote>\n<p><strong>代码示例 15-27</strong>　使用 Spring Cloud CircuitBreaker 改写后的 <code>BinaryTeaClient</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class BinaryTeaClient {\n    @Autowired\n    private OrderService orderService;\n    private CircuitBreaker orderCheckerCircuitBreaker;\n\n    public BinaryTeaClient(CircuitBreakerFactory circuitBreakerFactory)    {\n        orderCheckerCircuitBreaker = circuitBreakerFactory.create(\"order-checker\");\n    }\n\n    public boolean isOrderFinished(Long id) {\n        return orderCheckerCircuitBreaker.run(() -&gt; {\n            ResponseEntity&lt;Order&gt; entity = orderService.queryOneOrder(id);\n            if (HttpStatus.NOT_FOUND == entity.getStatusCode()) {\n                throw new IllegalArgumentException(\"没找到订单\");\n            }\n            Order order = entity.getBody();\n            if (\"FINISHED\".equalsIgnoreCase(order.getStatus())) {\n                return true;\n            }\n            log.info(\"订单{}还没好\", id);\n            throw new OrderNotFinishedException();\n        }, t -&gt; false);\n    }\n}</code></pre>\n<p>上面的代码就已经实现了断路保护，如果需要对参数进行调整，根据 15.2 节里介绍的设置 Resilience4j 属性的方法在 <code>application.properties</code> 里配置就可以了。究其原因，Spring Cloud CircuitBreaker 的自动配置类在创建 <code>Resilience4JCircuitBreakerFactory</code> 时并未自己构造相关的 <code>Registry</code>，而是注入了 Spring 上下文中的 <code>CircuitBreakerRegistry</code> 和 <code>TimeLimiterRegistry</code>，两者都是由 resilience4j-spring-boot2 自动创建的。因此，15.2 节中介绍的内容在这里都是适用的：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnProperty(name = { \"spring.cloud.circuitbreaker.resilience4j.enabled\",\n    \"spring.cloud.circuitbreaker.resilience4j.blocking.enabled\" }, matchIfMissing = true)\npublic class Resilience4JAutoConfiguration {\n    @Autowired(required = false)\n    private List&lt;Customizer&lt;Resilience4JCircuitBreakerFactory&gt;&gt; customizers = new ArrayList&lt;&gt;();\n\n    @Bean\n    @ConditionalOnMissingBean(CircuitBreakerFactory.class)\n    public Resilience4JCircuitBreakerFactory resilience4jCircuitBreakerFactory(\n        CircuitBreakerRegistry circuitBreakerRegistry, TimeLimiterRegistry timeLimiterRegistry,\n        @Autowired(required = false) Resilience4jBulkheadProvider\n        bulkheadProvider) {...}\n    // 省略其他代码\n}</code></pre>\n<p>上面是 <code>Resilience4JAutoConfiguration</code> 自动配置类的一个片段，除了 <code>resilience4jCircuitBreakerFactory</code> Bean 的定义，我们还看到了可以通过 <code>spring.cloud.circuitbreaker.resilience4j.enabled</code> 和 <code>spring.cloud.circuitbreaker.resilience4j.blocking.enabled</code> 这两个属性来控制是否开启 Spring Cloud CircuitBreaker 的自动配置。如果是 Reactive 方式的，可以用 <code>spring.cloud.circuitbreaker.resilience4j.reactive.enabled</code> 属性。</p>\n<p>大部分情况下，用配置文件就已经能满足日常需要了，但 Spring Cloud CircuitBreaker 的自动配置还是给我们留下了调整的余地。<code>Resilience4JAutoConfiguration</code> 里有一个 <code>Customizer&lt;Resilience4JCircuitBreakerFactory&gt;</code> 的列表，我们可以提供自己的 <code>Customizer&lt;Resilience4JCircuitBreakerFactory&gt;</code> 对 <code>Resilience4JCircuitBreakerFactory</code> 进行微调。</p>\n<p>如果是调整默认配置，可以像下面这样直接在 <code>Customizer</code> 里调用 <code>Resilience4JCircuitBreakerFactory</code> 的 <code>configureDefault()</code> 方法。其中所需的 <code>Resilience4JCircuitBreakerConfiguration</code>，则由 <code>Resilience4JConfigBuilder</code> 来进行构建，目前仅支持在这里传入 <code>CircuitBreakerConfig</code> 和 <code>TimeLimiterConfig</code>：</p>\n<pre class=\"code-rows\"><code>@Bean\npublic Customizer&lt;Resilience4JCircuitBreakerFactory&gt; defaultCustomizer() {\n    return f -&gt; f.configureDefault(id -&gt; new Resilience4JConfigBuilder(id)\n        .circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())\n        .timeLimiterConfig(TimeLimiterConfig.ofDefaults())\n        .build());\n}</code></pre>\n<p>如果要调整的是特定实例的配置，则是使用 <code>Resilience4JCircuitBreakerFactory</code> 的 <code>configure()</code> 方法，它可以一次设置多个拥有相同配置的实例。就比如下面这样：</p>\n<pre class=\"code-rows\"><code>@Bean\npublic Customizer&lt;Resilience4JCircuitBreakerFactory&gt; orderCheckerCustomizer() {\n    return f -&gt; f.configure(b -&gt; b.circuitBreakerConfig(CircuitBreakerConfig.ofDefaults())\n        .timeLimiterConfig(TimeLimiterConfig.ofDefaults())\n        .build(), \"order-checker\");\n}</code></pre>\n<p>对于使用了舱壁模式的情况，还可以提供自己的 <code>Customizer&lt;Resilience4jBulkheadProvider&gt;</code> Bean 实例，写法与上面类似，例如：</p>\n<pre class=\"code-rows\"><code>@Bean\npublic Customizer&lt;Resilience4jBulkheadProvider&gt; defaultBulkheadCustomizer() {\n    return p -&gt; p.configureDefault(id -&gt; new Resilience4jBulkheadConfigurationBuilder()\n        .bulkheadConfig(BulkheadConfig.ofDefaults())\n        .threadPoolBulkheadConfig(ThreadPoolBulkheadConfig.ofDefaults())\n        .build());\n}</code></pre>\n<h3 id=\"nav_point_239\">15.3.2　通过 Spring Cloud CircuitBreaker 使用 Sentinel</h3>\n<p>阿里巴巴开源的 Sentinel 是在国内开发者社区中较为流行的容错组件，从流量控制、熔断降级、负载保护等多个维度为服务的稳定性保驾护航。大家对阿里巴巴开源的各种设施都比较放心，其信心便是源自阿里多年双十一活动超高流量下积累的大量经验，Sentinel 的表现同样出类拔萃。Sentinel 主要有以下特点。</p>\n<ul>\n<li>在核心方面，整个 Sentinel 的核心库是轻量级的，没有太多的依赖。与此同时，它还提供了一套完善的 SPI 扩展机制，开发者可以通过 SPI 接口实现定制逻辑。</li>\n<li>在功能方面，Sentinel 拥有丰富的流量控制场景，例如秒杀、削峰填谷和快速故障熔断等，开发者既可以根据特定的指标进行流量控制，也可以针对热点等其他维度进行控制。</li>\n<li>在使用方面，Sentinel 的接入非常方便，支持大量的开源框架和库，例如 Spring Cloud、Quarkus、gRPC、Dubbo 和传统 Servlet。Sentinel 还默认提供了一套控制台，开发者可以通过控制台实时查看接入应用的单机和集群运行情况，并对规则进行管理。</li>\n</ul>\n<p>要使用 Spring Cloud Alibaba Sentinel 相关的支持，需要在 pom.xml 中引入相关的依赖，先是在 <code>&lt;dependencyManagement/&gt;</code> 中导入 <code>spring-cloud-alibaba-dependencies</code> 的依赖，版本可以是 2021.0.1.0：</p>\n<pre class=\"code-rows\"><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;!-- 省略spring-cloud-dependencies依赖 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;$&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;</code></pre>\n<p>接下来，在 <code>&lt;dependencies/&gt;</code> 中添加 <code>spring-cloud-starter-alibaba-sentinel</code> 依赖，它会传递引用 <code>spring-cloud-circuitbreaker-sentinel</code> 等相关依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>接下来，先让我们一起看看直接使用 Sentinel 是什么样的，通过 Spring Cloud Alibaba 使用又是什么样的，最后再用 Spring Cloud CircuitBreaker。</p>\n<ol>\n<li><p><strong>定义资源</strong></p>\n<p>Sentinel 本身的功能非常强大，完全可以独立运用在各种系统和场景中。在 Sentinel 中，要保护的东西被称为“<strong>资源</strong>”，它可以是一个服务接口，也可以是一段具体的代码。定义完资源后，就可以针对资源配置对应的规则了。定义资源的方式有以下几种。</p>\n<ul>\n<li><code>SphU</code> 可以用抛出异常的方式来定义资源，资源不可用（比如被限流或降级）时会抛出 <code>BlockException</code>。<code>SphU.entry()</code> 方法可以传入资源名，返回一个 <code>Entry</code> 实例，调用其中的 <code>exit()</code> 来结束资源。<code>SphU</code> 支持 <code>try-with-resources</code>，此时不需要手动调用 <code>exit()</code>。</li>\n<li><code>SphO</code> 可以用返回布尔值的方式来定义资源，<code>SphO.entry()</code> 传入资源名，在资源可用时返回 <code>true</code>，否则返回 <code>false</code>。<code>SphO.entry()</code> 与 <code>SphO.exit()</code> 需要成对出现，传入的资源名要两两匹配，不然会抛出异常。</li>\n<li>通过 <code>@SentinelResource</code> 注解来定义资源，同时设置资源不可用时的处理逻辑，也就是限流或降级后要执行的方法。</li>\n</ul>\n<p>表 15-7 罗列了 <code>SphU</code> 和 <code>SphO</code> 的 <code>entry()</code> 方法常用的一些公共参数，最简单的用法就是只传一个资源名。</p>\n<p><strong>表 15-7　<code>entry()</code> 方法的常用参数</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数名</th><th>默认值</th><th>说明</th></tr><tr><td><code>name</code></td><td></td><td>资源名</td></tr><tr><td><code>entryType</code></td><td><code>EntryType.OUT</code></td><td>资源调用的流量类型，<code>EntryType.IN</code> 是入口流量，<code>EntryType.OUT</code> 是出口流量，注意系统规则只对入口流量生效</td></tr><tr><td><code>count</code></td><td><code>1</code></td><td>本次资源调用请求的令牌数目</td></tr><tr><td><code>args</code></td><td></td><td>传入热点参数限流的参数</td></tr></table>\n\n<p>代码示例 15-28<span class=\"comment-number\">12</span> 就是简单修改了一下 BinaryTea 工程的 <code>TeaMakerClient</code> 类，通过 <code>SphU.entry()</code> 来封装订单状态查询接口，<code>BlockException</code> 是 Sentinel 抛出的异常，我们可以对它做些针对性的处理。由于使用了 <code>try-with-resources</code> 的方式，所以无须调用 <code>entry</code> 的 <code>exit()</code> 方法。另外，由于是编程实现的，因而在资源名上可操作性很大。</p>\n<blockquote>\n<p><strong>代码示例 15-28</strong>　通过 Sentinel 的编码方式来定义资源</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\npublic class TeaMakerClient {\n    public TeaMakerResult makeTea(Long id) {\n        try (Entry entry = SphU.entry(\"tea-maker-\" + (id % 2))) {\n            ResponseEntity&lt;TeaMakerResult&gt; entity =\n                restTemplate.postForEntity(teaMakerUrl + \"/order/\", null, TeaMakerResult.class, id);\n            log.info(\"请求TeaMaker，响应码：{}\", entity.getStatusCode());\n            if (entity.getStatusCode() == HttpStatus.BAD_REQUEST) {\n                return null;\n            }\n            return entity.getBody();\n        } catch (BlockException e) {\n            log.warn(\"订单{}通知TeaMaker时被Sentinel降级了\", id);\n        } catch (Exception e) {\n            log.warn(\"订单{}通知TeaMaker时发生异常\", e);\n        }\n        return null;\n    }\n    // 省略其他代码\n}</code></pre>\n<p>基于注解来定义 Sentinel 的资源似乎更符合 Spring 的风格，所以接下来，让我们看看在 Spring 项目里如何使用 <code>@SentinelResource</code> 注解。一般，我们会把这个注解加在具体的服务实现方法上，表 15-8 罗列了它的一些参数。要使用 <code>@SentinelResource</code> 注解，需要在 pom.xml 中引入 <code>sentinel-annotation-aspectj</code> 依赖，随后配置一个 <code>SentinelResourceAspect</code> 类型的 Bean；如果使用了 Spring Cloud Alibaba，也就是已经引入了 spring-cloud-starter-alibaba-sentinel，则会自带相应的依赖和配置，无须额外的操作就能直接使用。</p>\n<p><strong>表 15-8　<code>@SentinelResource</code> 注解的常用参数</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数名</th><th>默认值</th><th>说明</th></tr><tr><td><code>value</code></td><td></td><td>资源名</td></tr><tr><td><code>entryType</code></td><td><code>EntryType.OUT</code></td><td>资源调用的流量类型，是入口流量（<code>EntryType.IN</code>）还是出口流量（<code>EntryType.OUT</code>），注意系统规则只对入口流量生效</td></tr><tr><td><code>blockHandler</code></td><td></td><td>处理 <code>BlockException</code> 的方法，返回类型兼容原函数，参数与原函数一致，后面可以多一个 <code>BlockException</code></td></tr><tr><td><code>blockHandlerClass</code></td><td></td><td>通常 <code>blockHandler</code> 都在当前类里，但如果希望多个类共享同一个 <code>blockHandler</code>，可以把它抽到一个类里，同时将方法改为 <code>static</code> 的</td></tr><tr><td><code>fallback</code></td><td></td><td>处理 <code>BlockException</code> 以外异常的方法，大致逻辑与 <code>blockHandler</code> 相同</td></tr><tr><td><code>fallbackClass</code></td><td></td><td>与 <code>blockHandlerClass</code> 的逻辑类似，只是针对的是 <code>fallback</code></td></tr><tr><td><code>defaultFallback</code></td><td></td><td>默认的异常处理方法，该方法不接受任何参数</td></tr><tr><td><code>exceptionsToTrace</code></td><td><code></code></td><td>要记录的异常类清单</td></tr><tr><td><code>exceptionsToIgnore</code></td><td><code>{}</code></td><td>要忽略的异常类清单</td></tr></table>\n\n<p>代码示例 15-29 演示了如何使用注解来定义资源，<code>TeaMakerClient</code> 里定义了名为 <code>tea-maker</code> 的资源，并配置了一个被降级后的方法，直接返回一个 <code>TeaMakerResult</code>；<code>OrderController</code> 里定义了名为 <code>query-order</code> 的资源。此处的注解<strong>不支持</strong> SpEL 表达式，所以只能用固定的字符串。</p>\n<blockquote>\n<p><strong>代码示例 15-29</strong>　通过 <code>@SentinelResource</code> 注解来定义资源</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\npublic class TeaMakerClient {\n    @SentinelResource(value = \"tea-maker\", blockHandler = \"notFinished\")\n    public TeaMakerResult makeTea(Long id) {\n        // 与原先的方法内容相同\n    }\n\n    public TeaMakerResult notFinished(Long id, BlockException e) {\n        log.warn(\"Blocked by Sentinel - {}\", e.getMessage());\n        TeaMakerResult result = new TeaMakerResult();\n        result.setFinish(false);\n        result.setOrderId(id);\n        return result;\n    }\n    // 省略其他代码\n}\n\n@Controller\n@RequestMapping(\"/order\")\n@Slf4j\npublic class OrderController {\n    @ResponseBody\n    @GetMapping(\"/\")\n    @SentinelResource(\"query-order\")\n    public ResponseEntity&lt;Order&gt; queryOneOrder(@PathVariable(\"id\") Long id) {\n        // 与原先的方法内容相同\n    }\n    // 省略其他代码\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>定义规则</strong></p>\n<p>定义好了资源之后，就可以继续定义规则了。在内存中修改 Sentinel 的规则后能立即生效，且一个资源可以有多个不同的规则。Sentinel 中一共有 5 种类型的规则。</p>\n<p><strong>a. 流量控制规则</strong></p>\n<p>流量控制规则会基于 QPS 或并发数进行控制，避免系统被瞬时的流量压垮。对应规则类是 <code>FlowRule</code>，通过编码方式定义时用 <code>FlowRuleManager.loadRules()</code> 来加载规则。表 15-9 列出了流量控制规则的重要属性 <span class=\"comment-number\">13</span>。</p>\n<p><strong>表 15-9　流量控制规则的属性</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数名</th><th>默认值</th><th>说明</th></tr><tr><td><code>resource</code></td><td></td><td>资源名</td></tr><tr><td><code>count</code></td><td></td><td>限流阈值</td></tr><tr><td><code>grade</code></td><td><code>FLOW\\_GRADE\\_QPS</code></td><td>限流模式，并发数（<code>FLOW\\_GRADE\\_THREAD=0</code>）和 QPS（<code>FLOW\\_GRADE\\_QPS=1</code>）</td></tr><tr><td><code>limitApp</code></td><td><code>LIMIT\\_APP\\_DEFAULT</code></td><td>流量控制针对的来源应用，<code>LIMIT\\_APP\\_DEFAULT=default</code> 表示不区分来源，用 <code>,</code> 分隔</td></tr><tr><td><code>strategy</code></td><td><code>STRATEGY\\_DIRECT</code></td><td>调用关系限流策略。包括直接（<code>STRATEGY\\_DIRECT=0</code>），对资源本身限流；关联（<code>STRATEGY\\_RELATE=1</code>），资源间有关联时，避免相互争夺资源；链路（<code>STRATEGY\\_CHAIN=2</code>），根据调用链路限流</td></tr><tr><td><code>controlBehavior</code></td><td><code>CONTROL\\_BEHAVIOR\\_DEFAULT</code></td><td>流量控制效果，包括直接拒绝（<code>CONTROL\\_BEHAVIOR\\_DEFAULT</code>）、预热（<code>CONTROL\\_BEHAVIOR\\_WARM\\_UP</code>）、匀速排队（<code>CONTROL\\_BEHAVIOR\\_ RATE\\_LIMITER</code>）</td></tr><tr><td><code>clusterMode</code></td><td><code>false</code></td><td>是否集群限流</td></tr></table>\n\n<p><strong>b. 熔断降级规则</strong></p>\n<p>熔断降级规则会基于慢调用比例（<code>SLOW_REQUEST_RATIO</code>）、异常比例（<code>ERROR_RATIO</code>）和异常数（<code>ERROR_COUNT</code>）来进行熔断降级。对应规则类是 <code>DegradeRule</code>，通过编码方式定义时用 <code>DegradeRuleManager.loadRules()</code> 来加载规则。表 15-10 列出了熔断降级规则的属性。</p>\n<p><strong>表 15-10　熔断降级规则的属性</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数名</th><th>默认值</th><th>说明</th></tr><tr><td><code>resource</code></td><td></td><td>资源名</td></tr><tr><td><code>grade</code></td><td><code>DEGRADE_GRADE_RT</code></td><td>熔断策略，支持慢调用比例（<code>DEGRADE_GRADE_RT=0</code>）、异常比例（<code>DEGRADE_GRADE_EXCEPTION_RATIO=1</code>）和异常数（<code>DEGRADE_GRADE_EXCEPTION_COUNT=2</code>）</td></tr><tr><td><code>count</code></td><td></td><td>慢调用比例模式下为慢调用的临界响应时间；异常比例和异常数模式下为对应的阈值</td></tr><tr><td><code>timeWindow</code></td><td></td><td>熔断时间，单位为秒，超过这个时间后会进入半开模式</td></tr><tr><td><code>minRequestAmount</code></td><td><code>5</code></td><td>触发熔断的最小请求数，不到这个数量时熔断不会生效</td></tr><tr><td><code>statIntervalMs</code></td><td><code>1000</code></td><td>统计时长，单位为毫秒</td></tr><tr><td><code>slowRatioThreshold</code></td><td><code>1.0d</code></td><td>慢调用比例阈值</td></tr></table>\n\n<p><strong>c. 系统保护规则</strong></p>\n<p>系统保护规则会基于系统的 CPU 使用率、Load、平均响应时间、QPS、并发数进行自适应的流量控制。系统规则只对入口流量有效。对应规则类是 <code>SystemRule</code>，通过编码方式定义时用 <code>SystemRuleManager.loadRules()</code> 来加载规则。表 15-11 列出了系统保护规则的属性，默认值 <code>-1</code> 表示不生效。</p>\n<p><strong>表 15-11　系统保护规则的属性</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数名</th><th>默认值</th><th>说明</th></tr><tr><td><code>highestSystemLoad</code></td><td><code>-1</code></td><td>最高 Load 值</td></tr><tr><td><code>highestCpuUsage</code></td><td><code>-1</code></td><td>最高 CPU 使用率，取值范围在 0.0 到 1.0 之间，且为闭区间，即 [0.0,1.0]</td></tr><tr><td><code>qps</code></td><td><code>-1</code></td><td>最高 QPS</td></tr><tr><td><code>avgRt</code></td><td><code>-1</code></td><td>入口流量的平均响应时间</td></tr><tr><td><code>maxThread</code></td><td><code>-1</code></td><td>入口流量的最大并发数</td></tr></table>\n\n<p><strong>d. 来源访问控制规则</strong></p>\n<p>来源访问控制规则，也可以叫黑白名单规则，根据调用请求来源（origin）判断是否需要限制资源的访问。对应规则类是 <code>AuthorityRule</code>，通过编码方式定义时用 <code>AuthorityRuleManager.loadRules()</code> 来加载规则。表 15-12 列出了来源访问控制规则的属性。</p>\n<p><strong>表 15-12　来源访问控制规则的属性</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数名</th><th>默认值</th><th>说明</th></tr><tr><td><code>resource</code></td><td></td><td>资源名</td></tr><tr><td><code>limitApp</code></td><td></td><td>黑名单或白名单，用 <code>,</code> 分隔</td></tr><tr><td><code>strategy</code></td><td><code>AUTHORITY_WHITE</code></td><td>控制策略，白名单（<code>AUTHORITY_WHITE=0</code>）和黑名单（<code>AUTHORITY_BLACK=1</code>）</td></tr></table>\n\n<p><strong>e. 热点参数规则</strong></p>\n<p>热点参数规则会针对经常要访问的热点数据进行保护，Sentinel 基于 LRU 策略统计传入的参数后，根据配置的阈值与模式，结合令牌桶算法来进行参数级别的流量控制。这是是一种特殊的流量控制规则，它仅对包含热点超参数的资源调用有效。对应规则类是 <code>ParamFlowRule</code>，通过编码方式定义时用 <code>ParamFlowRuleManager.loadRules()</code> 来加载规则，热点参数规则对应的类都单独放在 <code>sentinel-parameter-flow-control</code> 依赖里。如果没有这个依赖的话，则需要我们自己添加一下。表 15-13 列出了热点参数规则的属性。</p>\n<p><strong>表 15-13　热点参数规则的属性</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数名</th><th>默认值</th><th>说明</th></tr><tr><td><code>resource</code></td><td></td><td>资源名</td></tr><tr><td><code>count</code></td><td></td><td>限流阈值</td></tr><tr><td><code>grade</code></td><td><code>FLOW_GRADE_QPS</code></td><td>限流模式，并发数（<code>FLOW_GRADE_THREAD=0</code>）和 QPS（<code>FLOW_GRADE_QPS=1</code>）</td></tr><tr><td><code>durationInSec</code></td><td><code>1</code></td><td>统计窗口时间长度，单位为秒</td></tr><tr><td><code>controlBehavior</code></td><td><code>CONTROL_BEHAVIOR_DEFAULT</code></td><td>流量控制效果，包括直接拒绝（<code>CONTROL_BEHAVIOR_DEFAULT</code>）、预热（<code>CONTROL_BEHAVIOR_WARM_UP</code>）、匀速排队（<code>CONTROL_BEHAVIOR_RATE_LIMITER</code>）</td></tr><tr><td><code>maxQueueingTimeMs</code></td><td><code>0</code></td><td>最大排队等待时长，仅在流量控制效果为匀速排队模式时生效</td></tr><tr><td><code>paramIdx</code></td><td></td><td>热点参数的索引，对应 <code>SphU.entry(xxx, args)</code> 中的参数索引位置</td></tr><tr><td><code>paramFlowItemList</code></td><td></td><td>参数例外项，可以针对指定的参数值单独设置限流阈值，不受 <code>count</code> 的限制，仅支持基本类型和字符串类型</td></tr><tr><td><code>clusterMode</code></td><td><code>false</code></td><td>是否为集群限流模式</td></tr></table>\n\n<p>既然我们有这么多种不同类型的规则，那在触发规则后都抛出 <code>BlockException</code> 也不好判断，Sentinel 贴心地为不同的规则定义了不同的 <code>BlockException</code> 子类：</p>\n<ul>\n<li>流量控制异常，抛出 <code>FlowException</code></li>\n<li>熔断降级异常，抛出 <code>DegradeException</code></li>\n<li>系统保护异常，抛出 <code>SystemBlockException</code></li>\n<li>访问控制异常，抛出 <code>AuthorityException</code></li>\n<li>热点参数限流异常，抛出 <code>ParamFlowException</code></li>\n</ul>\n<p>拿到一个异常后，可以通过 <code>BlockException.isBlockException(Throwable t)</code> 方法来判断它是不是 Sentinel 触发的异常。</p>\n<p>通过编码的方式来定义规则一般在测试时使用，在生产上还是不太方便。在生产环境中，很可能会需要根据运行的情况动态调整规则，Sentinel 提供了 <code>ReadableDataSource</code> 和 <code>WritableDataSource</code> 接口，以便通过动态规则源来管理规则。根据数据源的不同，Sentinel 可通过拉模式或者推模式来获取规则。所谓拉模式是客户端定时主动向规则源查询规则，规则源继承 <code>AutoRefreshDataSource</code> 抽象类即可；而推模式则是客户端注册监听，在规则发生变化时由规则源推送变更通知，规则源继承 <code>AbstractDataSource</code> 抽象类。表 15-14 罗列了一些 Sentinel 支持的规则源 <span class=\"comment-number\">14</span>，表中的依赖是 ArtifactId，GroupId 都是 <code>com.alibaba.csp</code>。</p>\n<p><strong>表 15-14　Sentinel 支持的一些规则源</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>规则源</th><th>对应的实现类</th><th>模式</th><th>依赖</th></tr><tr><td>文件规则源</td><td><code>FileRefreshableDataSource</code>、<code>FileInJarReadableDataSource</code></td><td>拉模式</td><td>sentinel-datasource-extension</td></tr><tr><td>Consul</td><td><code>ConsulDataSource</code></td><td>拉模式</td><td>sentinel-datasource-consul</td></tr><tr><td>Eureka</td><td><code>EurekaDataSource</code></td><td>拉模式</td><td>sentinel-datasource-eureka</td></tr><tr><td>ZooKeeper</td><td><code>ZookeeperDataSource</code></td><td>推模式</td><td>sentinel-datasource-zookeeper</td></tr><tr><td>Redis</td><td><code>RedisDataSource</code></td><td>推模式</td><td>sentinel-datasource-redis</td></tr><tr><td>Nacos</td><td><code>NacosDataSource</code></td><td>推模式</td><td>sentinel-datasource-nacos</td></tr><tr><td>Apollo</td><td><code>ApolloDataSource</code></td><td>推模式</td><td>sentinel-datasource-apollo</td></tr></table>\n\n<p>可以通过编程方式加载 <code>ReadableDataSource</code> 里的规则，不同的实现类需要传入的参数不同，<code>ZookeeperDataSource</code> 大概的形式是下面这样的：</p>\n<pre class=\"code-rows\"><code>ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; flowRuleDataSource =\n    new ZookeeperDataSource&lt;&gt;(remoteAddress, path,\n        source -&gt; JSON.parseObject(source, new TypeReference&lt;List&lt;FlowRule&gt;&gt;() {}));\nFlowRuleManager.register2Property(flowRuleDataSource.getProperty());</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Spring Cloud Alibaba 提供的配置支持</strong></p>\n<p>在 Spring Cloud Alibaba 的加持之下，我们可以用“更 Spring”的方式来加载规则，简单来说就是用 <code>application.properties</code> 来指定规则源，剩下的交给框架来做就好。对应的各种配置类都在 <code>spring-cloud-alibaba-sentinel-datasource</code> 依赖之中，我们先来看看具体该如何使用。代码示例 15-30 是针对 BinaryTea 的规则源配置，这里我们使用 JSON 文件来存放规则，分别是一个熔断降级规则源和一个流量控制规则源。为了方便修改，没有将它们放在 CLASSPATH 里，而是放在一个外部路径下，大家可以根据自己的路径做调整。</p>\n<blockquote>\n<p><strong>代码示例 15-30</strong>　BinaryTea 工程中配置的两个 Sentinel 动态规则源</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.cloud.sentinel.datasource.ds1.file.file=./rules/degrade-rules.json\nspring.cloud.sentinel.datasource.ds1.file.data-type=json\nspring.cloud.sentinel.datasource.ds1.file.rule-type=degrade\n\nspring.cloud.sentinel.datasource.ds2.file.file=./rules/flow-rules.json\nspring.cloud.sentinel.datasource.ds2.file.rule-type=flow</code></pre>\n<p><code>spring.cloud.sentinel.*</code> 的配置都在 <code>spring-cloud-starter-alibaba-sentinel</code> 中的 <code>SentinelProperties</code> 里，其中的 <code>datasource</code> 是 <code>TreeMap</code> 类型的，用来存放动态规则源。所以上面例子里 <code>spring.cloud.sentinel.datasource</code> 中的 <code>ds1</code> 和 <code>ds2</code> 都是 <code>TreeMap</code> 中的键名，对应的值类型是 <code>DataSourcePropertiesConfiguration</code>，它的结构大致是下面这样的：</p>\n<pre class=\"code-rows\"><code>public class DataSourcePropertiesConfiguration {\n    private FileDataSourceProperties file;\n    private NacosDataSourceProperties nacos;\n    private ZookeeperDataSourceProperties zk;\n    private ApolloDataSourceProperties apollo;\n    private RedisDataSourceProperties redis;\n    private ConsulDataSourceProperties consul;\n    // 省略其他代码\n}</code></pre>\n<p>从这个定义里就能猜到，Spring Cloud Alibaba 提供的配置目前支持文件、Nacos、ZooKeeper、Apollo、Redis 和 Consul，直接将配置放到对应的属性里就行了，这些属性类都继承自 <code>AbstractDataSourceProperties</code>，其中是一些公共配置，如表 15-15 所示。</p>\n<p><strong>表 15-15　一些公共的 Sentinel 规则源配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数名</th><th>默认值</th><th>说明</th></tr><tr><td><code>data-type</code></td><td><code>json</code></td><td>具体存放规则的类型，默认是 JSON 类型，也支持 XML，但需要添加 <code>jackson-dataformat-xml</code> 依赖，不同类型会对应不同的 <code>Converter</code> 类，也可以写 <code>custom</code> 自定义类型</td></tr><tr><td><code>rule-type</code></td><td></td><td>规则类型，具体内容定义在 <code>RuleType</code> 枚举中，例如 <code>flow</code> 表示流量控制规则，<code>degrade</code> 表示熔断降级规则，<code>system</code> 表示系统规则，其他的还有 <code>param-flow</code>、<code>authority</code>、<code>gw-flow</code> 和 <code>gw-api-group</code></td></tr><tr><td><code>converter-class</code></td><td></td><td>如果是 JSON 或者 XML 类型，无须配置该值，如果是 <code>custom</code> 类型则需要在这里配置具体的 <code>Converter</code> 的全限定类名</td></tr></table>\n\n<p>degrade-rules.json 和 flow-rules.json 这两个文件的内容如代码示例 15-31 所示，其实就是最简单的纯 JSON 文件，每个文件都是 <code>[]</code>（也就是 JSON 的数组）。文件中可以放多条规则，根据规则类型的不同，JSON 对象的属性也有所不同，具体可以看前文对应的表格。</p>\n<blockquote>\n<p><strong>代码示例 15-31</strong>　两个 Sentinel 规则文件的内容</p>\n</blockquote>\n<pre class=\"code-rows\"><code>// degrade-rules.json\n[\n    {\n        \"resource\": \"tea-maker\",\n        \"grade\": 2,\n        \"count\": 3,\n        \"timeWindow\": 60,\n        \"minRequestAmount\": 3,\n        \"statIntervalMs\": 60000\n    }\n]\n// flow-rules.json\n[\n    {\n        \"resource\": \"query-order\",\n        \"grade\": 0,\n        \"count\": 1\n    }\n]</code></pre>\n<p>因为 Spring Cloud Alibaba Sentinel 为我们自动注册了 <code>SentinelEndpoint</code> 端点，所以只要我们引入了 Actuator 依赖，并在 <code>management.endpoints.web.exposure.include</code> 中加入 <code>sentinel</code>，就可以在程序运行后访问 <code>/actuator/sentinel</code> 端点来查看 Sentinel 的具体规则情况 <span class=\"comment-number\">15</span>，例如 BinaryTea 工程就可以访问 <code>http://localhost:8080/actuator/sentinel</code>，输出的 JSON 大概就是下面这样的：</p>\n<pre class=\"code-rows\"><code>{\n    \"appName\": \"binarytea\",\n    \"datasource\": {\n        \"ds1\": {\n            \"apollo\": null,\n            \"consul\": null,\n            \"file\": {...},\n            \"nacos\": null,\n            \"redis\": null,\n            \"zk\": null\n        },\n        \"ds2\": {...}\n    },\n    \"rules\": {\n        \"authorityRule\": [],\n        \"degradeRules\": [\n            {...}\n        ],\n        \"flowRules\": [\n            {...}\n        ],\n        \"paramFlowRule\": [],\n        \"systemRules\": []\n    },\n    // 省略部分内容\n}</code></pre>\n<p>因为 flow-rules.json 中配置了 <code>query-order</code> 的并发线程数只能是 <code>1</code>，所以我们可以在 <code>OrderController.queryOneOrder()</code> 方法中加入一段 <code>Thread.sleep(30000)</code>，然后开两个终端，用下面的 curl 命令同时访问订单，一个最终会返回内容，而另一个则返回 <code>500 Internal Server Error</code> 错误，原因是系统被限流了，抛出了 <code>FlowException</code>。</p>\n<pre class=\"code-rows\"><code>▸ curl -v -u LiLei:binarytea http://localhost:8080/order/1</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用 Spring Cloud CircuitBreaker</strong></p>\n<p>之前引入的 <code>spring-cloud-starter-alibaba-sentinel</code> 已经帮我们把 <code>spring-cloud-circuitbreaker-sentinel</code> 依赖一并带进来了，所以我们可以直接通过 Spring Cloud CircuitBreaker 的抽象层来使用 Sentinel，具体的用法与 15.3.1 节中介绍的 Resilience4j 支持类似。但是有一点需要说明的是，目前通过 Spring Cloud CircuitBreaker Sentinel 只能配置熔断降级规则——通过 <code>SentinelConfigBuilder</code> 就能看到，里面暂时只能配置 <code>DegradeRule</code>。</p>\n<p>在前面的 BinaryTea 中，<code>TeaMakerClient</code> 里配置了一个需要熔断降级的资源 <code>tea-maker</code>，代码示例 15-32<span class=\"comment-number\">16</span> 用 <code>CircuitBreaker</code> 的方式调整了一下 <code>makeTea()</code> 的实现。通过构造方法传入的 <code>CircuitBreakerFactory</code> 先构造了 <code>tea-maker</code> 要用的 <code>CircuitBreaker</code> 实例，放在成员变量里，然后在 <code>makeTea()</code> 中把原来的方法内容封装在 <code>circuitBreaker.run()</code> 里，在遇到异常后会降级调用 <code>notFinished()</code> 方法。这个方法的参数稍微做了些调整，接受 <code>Throwable</code> 类型的异常。</p>\n<blockquote>\n<p><strong>代码示例 15-32</strong>　使用了 <code>CircuitBreaker</code> 的 <code>TeaMakerClient</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Slf4j\npublic class TeaMakerClient {\n    @Autowired\n    private RestTemplate restTemplate;\n    @Value(\"$\")\n    private String teaMakerUrl;\n    private CircuitBreaker circuitBreaker;\n\n    public TeaMakerClient(CircuitBreakerFactory factory) {\n        circuitBreaker = factory.create(\"tea-maker\");\n    }\n\n    public TeaMakerResult makeTea(Long id) {\n        return circuitBreaker.run(() -&gt; {\n            // 与原先的方法内容一样\n        }, t -&gt; notFinished(id, t));\n    }\n\n    public TeaMakerResult notFinished(Long id, Throwable t) {\n        log.warn(\"Fallback by Sentinel - {}\", t.getMessage());\n        TeaMakerResult result = new TeaMakerResult();\n        result.setFinish(false);\n        result.setOrderId(id);\n        return result;\n    }\n}</code></pre>\n<p><code>SentinelCircuitBreakerAutoConfiguration</code> 类为我们自动配置了 <code>SentinelCircuitBreakerFactory</code> Bean，为了增加 <code>tea-maker</code> 的具体规则，我们需要定义一个 <code>Customizer&lt;SentinelCircuitBreakerFactory&gt;</code> 类型的 Bean 做些个性化定制，代码示例 15-33 就是对应的配置。<code>application.properties</code> 里与降级熔断有关的 <code>spring.cloud.sentinel.datasource.ds1</code> 配置就可以直接删除了。</p>\n<blockquote>\n<p><strong>代码示例 15-33</strong>　<code>tea-maker</code> 对应的规则配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableCaching\n@EnableScheduling\npublic class BinaryTeaApplication implements WebMvcConfigurer {\n    @Bean\n    public Customizer&lt;SentinelCircuitBreakerFactory&gt; teaMakerCustomizer() {\n        DegradeRule rule = new DegradeRule();\n        rule.setResource(\"tea-maker\");\n        rule.setGrade(RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT);\n        rule.setCount(3);\n        rule.setTimeWindow(60);\n        rule.setMinRequestAmount(3);\n        rule.setStatIntervalMs(60000);\n\n        return f -&gt; f.configure(b -&gt; b.resourceName(\"tea-maker\")\n            .rules(Collections.singletonList(rule))\n            .entryType(EntryType.OUT), \"tea-maker\");\n    }\n    // 省略其他代码\n}</code></pre>\n<p>总体上说来，目前为止 Spring Cloud CircuitBreaker 对 Sentinel 的支持还是不尽如人意，还无法发挥出 Sentinel 的大部分功能，所以还是先通过 Spring Cloud Alibaba 来使用 Sentinel 就好。相信在后续的版本中，这方面的支持一定会得到加强。</p>\n</li>\n</ol>\n\n\n<h2 id=\"nav_point_240\">15.4　小结</h2>\n<p>本章我们学习了几种常见的服务容错模式，分别是重试模式、断路器模式、舱壁模式和限流器模式，还通过 Spring AOP 的方式大致演示了其中两种模式的实现方式。当然，在现实的生产环境中，如果没有特殊情况的话，还是建议使用成熟的框架来提供服务容错能力，而非自己动手实现。本章介绍的 Resilience4j 和 Sentinel 都是不错的选择，两者在功能、模块化、易用性等方面都有不俗的表现，对 Spring Boot、Spring Cloud 项目的支持也很到位。章节最后，我们还介绍了 Spring Cloud CircuitBreaker 项目，它在几款主流的服务容错框架之上建立了一层抽象，通过它来屏蔽底层实现的差异，这种做法在 Spring 家族中并不少见。</p>\n<p>下一章也是本书的最后一章，我们会聊聊服务集成相关的内容，例如，如何使用 REST 服务以外的通信方式，如何搭建微服务网关，以及如何实现服务链路追踪。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发小结</strong></p>\n<p>本章中，我们为整个例子增加了调茶师的模块，负责订单的制作。有了这个角色，就可以把已支付的订单推进到终态了。而顾客模块也通过轮询订单状态，获得了订单的进度情况，如果完成了就取餐。到目前为止，我们的订单流转过程是这样的：</p>\n<p>(1) Customer 模块下单，创建一笔新订单；</p>\n<p>(2) Customer 模块进行支付；</p>\n<p>(3) BinaryTea 在订单支付后，通过定时任务以 HTTP 的方式通知 TeaMaker；</p>\n<p>(4) TeaMaker 制作订单，完成订单制作后以 HTTP 的方式通知 BinaryTea；</p>\n<p>(5) Customer 不断轮询 BinaryTea，查询订单的状态，订单未完成则等待；</p>\n<p>(6) Customer 在轮询得到订单完成的状态后，完成取餐动作。</p>\n</blockquote>\n\n<br style=\"page-break-after:always\" />\n\n\n","comments":[]}