{"id":820345,"title":"08｜如何使用LLaMA 3进行多轮推理的搜索增强？","content":"<p>你好，我是Tyler！</p><p>在上一节中，我们深入探讨了如何利用 LLaMA 3 增强思维链的频率。尽管我们发现频率增强可以在一定程度上提高思维链的有效性，但这种方法存在系统性不足的问题，可能无法充分挖掘思维链的潜力。为了解决这些问题，我们引入了一种更高级的推理方法——“树状思维链”（Tree of Thought，简称 ToT）。</p><h2>什么是树状思维链？</h2><p>树状思维链常常被误解为对思维链（Chain of Thought，CoT）的简单树状扩展，然而，这种看法忽略了树状思维链的本质和独特性。实际上，树状思维链不仅是思维链的延展，而是引入了一种全新的思维模式，具有显著的区别和优势。</p><p>首先，思维链是一种逐步推理的方法，通过线性链的形式展开，每一步推理紧密相连，逐步接近问题的解决方案。这种方法有效地组织了推理过程，但其局限性在于只能按照单一方向推进，难以全面探索所有可能的思维路径。</p><p>你在上一节学习的自一致性（Self-Consistency）方法是一种在思维链中进行朴素分支扩展的策略。它通过生成多个不同的推理路径，并将这些路径的结果进行汇总，以提高最终答案的一致性。虽然自一致性方法在某种程度上增强了推理的可靠性，但仍然局限于对现有路径的汇总，而非系统性地探索不同的思维路径。</p><!-- [[[read_end]]] --><p>与此不同，树状思维链通过树状结构让模型在每一步推理中同时探索多个方向。这样，模型可以更全面地考虑各种可能性，从而得出更优的答案。虽然自一致性也是一种通过生成不同路径提升答案一致性的方法，但它仍局限于汇总路径，缺乏系统性。而树状思维链则能更深入地探索所有可能的路径。</p><h2>树状思维链的适用范围</h2><p>讨论树状思维链时，一个常见的误解是认为它仅适用于特定论文中提到的24点问题（该问题涉及通过加、减、乘、除等运算将四个数字计算出24）。由于论文中常用此问题作为示例，一些人可能误以为树状思维链的应用范围仅限于此。</p><p>实际上，树状思维链的应用远超24点问题。它的核心在于能够在一个<strong>定义明确的“问题空间”中进行系统化的搜索</strong>。问题空间指的是所有可能解或步骤的集合，通过探索这些解或步骤，ToT 能够找到最优解。</p><p>具体来说，问题空间包括所有潜在的状态和可能的转换路径，每一个状态可以通过不同的操作或决策到达其他状态。树状思维链通过系统地遍历这些状态和路径，进行有效的搜索，确保所有可能的解都被考虑，从而找到最佳的解决方案。</p><p>这种系统化的搜索过程确保了树状思维链能够处理各种复杂的问题，只要这些问题可以被形式化为一个问题空间。这使得树状思维链能够广泛应用于多个领域，包括但不限于路径规划、游戏决策、复杂推理和战略规划等场景。</p><p>例如，在路径规划问题中，问题空间可能是所有可能的路径，而树状思维链可以系统地探索这些路径以找到最短路径。在游戏决策中，问题空间可以是所有可能的游戏状态和移动，树状思维链可以帮助找到最佳策略。</p><p>因此，在树状思维链中，“树”不仅仅是一个普通层次结构，而是一个搜索树。树中的每个节点代表一个具体的思维步骤，而每个节点的分支则代表在该步骤后可能采取的不同推理路径。通过这种结构，我们能够全面、系统地探索所有潜在思维路径，从而显著提高最终推理结果的质量。这种方法确保推理过程的多样性与深度，使我们能够更好地应对复杂、多维度的问题。</p><h2>树状思维链的应用：解决24点问题</h2><p>为了更好地理解树状思维链的应用，让我们看一个具体的例子——24点游戏。这是一种数学挑战，目标是通过基本运算（加、减、乘、除）将四个给定数字计算出结果为24。我们将利用树状思维链系统地探索解决这一问题的所有可能路径。</p><p>树状思维链的关键在于探索所有可能推理路径，并且每一步推理都产生分支，代表不同可能的运算。对于24点问题，我们可以将所有可能运算步骤视作一个树状结构，其中每个节点代表一个可能的运算结果，而每个分支表示一种运算操作。</p><p>假设我们有四个数字：4, 7, 8, 8，接下来我们通过树状结构系统探索这些数字的运算组合。</p><h3><strong>第一步：选择两个数字进行运算</strong></h3><p>从数字集合中选择两个数字进行运算，生成一个新数字。接下来继续使用剩余的数字进行计算，直到所有数字被使用完。</p><p>例如，我们选择 <code>8</code> 和 <code>4</code>，进行减法运算：</p><pre><code class=\"language-plain\">8 - 4 = 4\n</code></pre><ul>\n<li>当前树的节点代表这个运算结果 <code>4</code>，树的下一层将继续探索剩下的数字 <code>7</code> 和 <code>8</code>。</li>\n</ul><h3><strong>第二步：对剩下的数字进行运算</strong></h3><p>选择 <code>7</code> 和 <code>8</code> 进行运算：</p><pre><code class=\"language-plain\">7 + 8 = 15\n</code></pre><ul>\n<li>这时树结构的另一层节点代表 <code>15</code>，我们可以进一步将这两个结果结合起来，继续计算。</li>\n</ul><h3><strong>第三步：将前两步结果结合</strong></h3><p>结合前面的结果 <code>4</code> 和 <code>15</code>，进行乘法运算：</p><pre><code class=\"language-plain\">4 * 15 = 60\n</code></pre><ul>\n<li>这不是我们要的结果，于是我们回溯，探索其他运算组合。</li>\n</ul><h3>第四步：<strong>继续探索其他可能路径</strong></h3><p>通过递归的树状思维链方法，我们会探索所有可能的运算组合。假设我们尝试了另一组操作：</p><p>选择 <code>8</code> 和 <code>4</code> 进行除法运算：</p><pre><code class=\"language-plain\">8 / 4 = 2\n</code></pre><p>剩余数字 <code>7</code> 和 <code>8</code>，进行减法：</p><pre><code class=\"language-plain\">8 - 7 = 1\n</code></pre><p>最后，将 <code>2</code> 和 <code>1</code> 进行乘法运算：</p><pre><code class=\"language-plain\">2 * 1 = 2\n</code></pre><p>结果不是24，因此继续探索其他路径。</p><p>以此类推，直到搜索到答案。</p><h2><strong>树状思维链中的树搜索过程</strong></h2><p>树状思维链（ToT）算法允许我们系统性地生成和评估所有可能的运算路径，以找到解决24点问题的最优解。每个节点和分支代表一个计算步骤，这种方法确保所有可能路径都被充分探索，从而显著提高找到正确答案的概率。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/f3/4ff7f3bdc3e248f35487162009289af3.png?wh=1139x563\" alt=\"图片\" title=\"Tree of Thoughts: Deliberate Problem Solving with Large Language Models\"></p><p>在“树状思维链”（ToT）算法中，树搜索过程可以分为以下几个主要步骤：</p><ol>\n<li>\n<p><strong>初始化树节点：</strong>树的根节点代表问题的起始状态。在24点游戏的例子中，这可以是游戏的初始数字。</p>\n</li>\n<li>\n<p><strong>生成子节点：</strong>从当前节点（思维步骤）开始，生成所有可能的下一个思维步骤或操作。这些操作可以是不同的数学运算或其他逻辑操作。每一个新生成的思维步骤都成为当前节点的子节点。</p>\n</li>\n<li>\n<p><strong>扩展树：</strong>对于每个子节点，继续生成其子节点，直到达到预定的搜索深度或找到有效的解决方案。在24点游戏中，这相当于在每一步生成新的可能数字状态，并继续操作，直到找到正确的解。</p>\n</li>\n<li>\n<p><strong>评估节点：</strong>对每个节点的思维链进行评估，计算其有效性或质量。这通常通过某种评分机制来实现，比如计算节点是否能达到24点目标。</p>\n</li>\n<li>\n<p><strong>选择最佳路径：</strong>在树的所有可能路径中，选择最优的路径，这通常基于评估结果。</p>\n</li>\n</ol><h3>树状思维链的实现步骤（代码来自<a href=\"https://arxiv.org/abs/2305.10601\">论文</a>原实现）</h3><p>在实际应用中，树状思维链的算法可以分为以下几个主要步骤：</p><ol>\n<li><strong>初始化树节点</strong></li>\n</ol><pre><code class=\"language-python\">   initial_numbers = task.steps\n</code></pre><p>定义树的根节点，即任务的初始状态。</p><ol start=\"2\">\n<li><strong>生成子节点</strong></li>\n</ol><pre><code class=\"language-python\">   def get_proposals(task, x, y):\n       propose_prompt = task.propose_prompt_wrap(x, y)\n       proposals = gpt(propose_prompt, n=1, stop=None)[0].split('\\n')\n       return [y + _ + '\\n' for _ in proposals]\n</code></pre><p><code>get_proposals</code> 函数生成当前节点的所有子节点，每个子节点代表一种可能的思维链路径。</p><ol start=\"3\">\n<li><strong>扩展树</strong></li>\n</ol><pre><code class=\"language-python\">   def solve_task(task):\n       print(f\"处理任务: {task.__class__.__name__}\")\n       initial_numbers = task.steps\n       proposals = get_proposals(task, initial_numbers, '')\n       values = get_values(task, initial_numbers, proposals, n_evaluate_sample=N_EVALUATE_SAMPLE)\n       best_proposals = sorted(zip(proposals, values), key=lambda x: x[1], reverse=True)[:N_SELECT_SAMPLE]\n       return best_proposals\n</code></pre><p><code>solve_task</code> 函数扩展树，生成所有可能的路径（子节点），并对每个路径进行评估。</p><ol start=\"4\">\n<li><strong>评估节点</strong></li>\n</ol><pre><code class=\"language-python\">   def get_values(task, x, ys, n_evaluate_sample, cache_value=True):\n       values = []\n       local_value_cache = {}\n       for y in ys:\n           if y in local_value_cache:\n               value = 0\n           else:\n               value = get_value(task, x, y, n_evaluate_sample, cache_value=cache_value)\n               local_value_cache[y] = value\n           values.append(value)\n       return values\n</code></pre><p><code>get_values</code> 函数评估了每个思维链路径的有效性，对树中每个节点进行评分。</p><ol start=\"5\">\n<li><strong>选择最佳路径</strong></li>\n</ol><pre><code class=\"language-python\">   best_proposals = sorted(zip(proposals, values), key=lambda x: x[1], reverse=True)[:N_SELECT_SAMPLE]\n</code></pre><p>在所有可能的路径中，选择评分最高的路径，即选择最佳节点作为解决方案。</p><h2>总结</h2><p>学到这里，我们来做个总结吧。</p><p>在本节课中，我们深入探讨了树状思维链（ToT）作为一种新型的推理模式，并对其与传统的思维链（Chain of Thought, CoT）进行了对比。不同于线性推进的CoT，ToT通过树状结构同时探索多条推理路径，从而能够更全面、更深入地挖掘推理的潜力。</p><p>ToT不仅是对自一致性（Self-Consistency）的扩展，更是一种全新的探索思维模式，它在每一步推理过程中能够并行考虑多个路径。在广泛的应用场景中，例如路径规划和游戏决策，ToT展示了其解决复杂问题的潜力。</p><p>ToT的核心优势包括：</p><ul>\n<li>\n<p>多方向探索：利用树状结构，同时评估多个思维路径，避免了CoT单一线性路径的局限。</p>\n</li>\n<li>\n<p>系统化搜索：在复杂问题空间中系统地遍历各种可能路径，确保找到最优解。</p>\n</li>\n</ul><p>通过经典的24点问题作为例子，我们展示了如何利用树状思维链逐步搜索运算路径来找到解决方案，体现了ToT在基于大语言模型的启发式搜索中的强大推理和问题解决能力。</p><p>希望你能够掌握这种思想，在日常应用中对问题空间进行建模，并采用高效的搜索方法，以提高解决问题的效率。</p><h2>思考题</h2><ol>\n<li>\n<p>为什么说 ToT 不是 CoT 的简单树状扩展？</p>\n</li>\n<li>\n<p>你认为 ToT 和 GPT-4o1 草莓模型的关系是什么？</p>\n</li>\n</ol><p>欢迎你把思考后的结果分享到留言区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":395409,"user_name":"术子米德","can_delete":false,"product_type":"c1","uid":1898023,"ip_address":"浙江","ucode":"382EA7E2AF0B56","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","comment_is_top":false,"comment_ctime":1730644791,"is_pvip":true,"replies":[{"id":143541,"content":"你好，术子米德，很高兴你对这个话题感兴趣。你提出的问题非常有趣，关于CoT和其他多步推理方法是否是模型与生俱来的能力，这是一个值得深入探讨的话题。\n\n首先，我想澄清一点，CoT和ToT并不是模型天生就具备的能力。这些方法实际上是在LlaMa3的技术报告中被特别强调的，它们是通过后训练数据构造来赋予模型的。这意味着，这些能力是通过在模型训练过程中引入特定的数据和策略来培养的，而不是模型一开始就拥有的。\n\n尽管Meta团队并不是这些方法的首创者，但他们在LlaMa3模型的构建中确实做出了特别努力，以增强模型的多步推理能力。这一点非常重要，因为多步推理是解决复杂问题的关键。\n\n我们希望通过课程，让同学们能够理解这些模型背后的原理。我们不希望同学们误以为所有不透明的模型都自然而然地具备这些能力。相反，我们希望他们能够认识到，这些能力是通过精心设计和训练得来的。\n\n最后，我们希望同学们能够理解这个闭环：基于已有的模型去探索和改进提示语工程方法，而这些改进的方法又可以在模型的后训练过程中进一步强化这些能力。这是一个动态的、不断发展的过程，对于大模型技术的发展至关重要。\n\n希望这个回答能够帮助你更好地理解CoT和ToT方法，以及它们在大模型技术发展中的作用。如果你有任何其他问题，欢迎继续探讨。","user_name":"作者回复","user_name_real":"作者","uid":1002568,"ctime":1730686508,"ip_address":"北京","comment_id":395409,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100828301,"comment_content":"疑问：CoT ToT，是否非Llama专属？如果是大模型共享的方法，跟课程主题对起来，总有点变扭啊","like_count":3,"discussions":[{"author":{"id":1002568,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4c/48/99de2a2b.jpg","nickname":"Tyler","note":"","ucode":"A657DD2FBAF31D","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653324,"discussion_content":"你好，术子米德，很高兴你对这个话题感兴趣。你提出的问题非常有趣，关于CoT和其他多步推理方法是否是模型与生俱来的能力，这是一个值得深入探讨的话题。\n\n首先，我想澄清一点，CoT和ToT并不是模型天生就具备的能力。这些方法实际上是在LlaMa3的技术报告中被特别强调的，它们是通过后训练数据构造来赋予模型的。这意味着，这些能力是通过在模型训练过程中引入特定的数据和策略来培养的，而不是模型一开始就拥有的。\n\n尽管Meta团队并不是这些方法的首创者，但他们在LlaMa3模型的构建中确实做出了特别努力，以增强模型的多步推理能力。这一点非常重要，因为多步推理是解决复杂问题的关键。\n\n我们希望通过课程，让同学们能够理解这些模型背后的原理。我们不希望同学们误以为所有不透明的模型都自然而然地具备这些能力。相反，我们希望他们能够认识到，这些能力是通过精心设计和训练得来的。\n\n最后，我们希望同学们能够理解这个闭环：基于已有的模型去探索和改进提示语工程方法，而这些改进的方法又可以在模型的后训练过程中进一步强化这些能力。这是一个动态的、不断发展的过程，对于大模型技术的发展至关重要。\n\n希望这个回答能够帮助你更好地理解CoT和ToT方法，以及它们在大模型技术发展中的作用。如果你有任何其他问题，欢迎继续探讨。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730686508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395328,"user_name":"漠北","can_delete":false,"product_type":"c1","uid":1296046,"ip_address":"上海","ucode":"298DB0781E0C05","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4OvKiaF14CVnpTUEibC06vyicltuXrXWKB44K1UERgrzJgVShHiaoicBSvWdQFEGqYHEL0k53GeXRKwpCmiaYof4NMTQ/132","comment_is_top":false,"comment_ctime":1730252515,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100828301,"comment_content":"希望能结合例子给出完整prompt拆解和状态转移过程细节","like_count":2}]}