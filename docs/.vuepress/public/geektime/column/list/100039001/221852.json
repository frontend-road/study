{"id":221852,"title":"68 | 访问者模式（上）：手把手带你还原访问者模式诞生的思维过程","content":"<p>前面我们讲到，大部分设计模式的原理和实现都很简单，不过也有例外，比如今天要讲的访问者模式。它可以算是23种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。</p><p>尽管如此，为了让你以后读到应用了访问者模式的代码的时候，能一眼就能看出代码的设计意图，同时为了整个专栏内容的完整性，我觉得还是有必要给你讲一讲这个模式。除此之外，为了最大化学习效果，我今天不只是单纯地讲解原理和实现，更重要的是，我会手把手带你还原访问者模式诞生的思维过程，让你切身感受到创造一种新的设计模式出来并不是件难事。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>带你“发明”访问者模式</h2><p>假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到txt文件中。如果让你来实现，你会怎么来做呢？</p><p>实现这个功能并不难，不同的人有不同的写法，我将其中一种代码实现方式贴在这里。其中，ResourceFile是一个抽象类，包含一个抽象函数extract2txt()。PdfFile、PPTFile、WordFile都继承ResourceFile类，并且重写了extract2txt()函数。在ToolApplication中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。</p><!-- [[[read_end]]] --><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n\n  public abstract void extract2txt();\n}\n\npublic class PPTFile extends ResourceFile {\n  public PPTFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...省略一大坨从PPT中抽取文本的代码...\n    //...将抽取出来的文本保存在跟filePath同名的.txt文件中...\n    System.out.println(&quot;Extract PPT.&quot;);\n  }\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...\n    System.out.println(&quot;Extract PDF.&quot;);\n  }\n}\n\npublic class WordFile extends ResourceFile {\n  public WordFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void extract2txt() {\n    //...\n    System.out.println(&quot;Extract WORD.&quot;);\n  }\n}\n\n// 运行结果是：\n// Extract PDF.\n// Extract WORD.\n// Extract PPT.\npublic class ToolApplication {\n  public static void main(String[] args) {\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.extract2txt();\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><p>如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列的功能，那如果我们继续按照上面的实现思路，就会存在这样几个问题：</p><ul>\n<li>违背开闭原则，添加一个新的功能，所有类的代码都要修改；</li>\n<li>虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</li>\n<li>把所有比较上层的业务逻辑都耦合到PdfFile、PPTFile、WordFile类中，导致这些类的职责不够单一，变成了大杂烩。</li>\n</ul><p>针对上面的问题，我们常用的解决方法就是拆分解耦，把业务操作跟具体的数据结构解耦，设计成独立的类。这里我们按照访问者模式的演进思路来对上面的代码进行重构。重构之后的代码如下所示。</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n  //...\n}\n//...PPTFile、WordFile代码省略...\npublic class Extractor {\n  public void extract2txt(PPTFile pptFile) {\n    //...\n    System.out.println(&quot;Extract PPT.&quot;);\n  }\n\n  public void extract2txt(PdfFile pdfFile) {\n    //...\n    System.out.println(&quot;Extract PDF.&quot;);\n  }\n\n  public void extract2txt(WordFile wordFile) {\n    //...\n    System.out.println(&quot;Extract WORD.&quot;);\n  }\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      extractor.extract2txt(resourceFile);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><p>这其中最关键的一点设计是，我们把抽取文本内容的操作，设计成了三个重载函数。函数重载是Java、C++这类面向对象编程语言中常见的语法机制。所谓重载函数是指，在同一类中函数名相同、参数不同的一组函数。</p><p>不过，如果你足够细心，就会发现，上面的代码是编译通过不了的，第37行会报错。这是为什么呢？</p><p>我们知道，多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。</p><p>在上面代码的第35～38行中，resourceFiles包含的对象的声明类型都是ResourceFile，而我们并没有在Extractor类中定义参数类型是ResourceFile的extract2txt()重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。那如何解决这个问题呢？</p><p>解决的办法稍微有点难理解，我们先来看代码，然后我再来给你慢慢解释。</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Extractor extractor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Extractor extractor) {\n    extractor.extract2txt(this);\n  }\n\n  //...\n}\n\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n//...Extractor代码不变...\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><p>在执行第30行的时候，根据多态特性，程序会调用实际类型的accept函数，比如PdfFile的accept函数，也就是第16行代码。而16行代码中的this类型是PdfFile的，在编译的时候就确定了，所以会调用extractor的extract2txt(PdfFile pdfFile)这个重载函数。这个实现思路是不是很有技巧？这是理解访问者模式的关键所在，也是我之前所说的访问者模式不好理解的原因。</p><p>现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那我们该如何实现呢？我们需要实现一个类似Extractor类的新类Compressor类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，我们还要在每个资源文件类中定义新的accept重载函数。具体的代码如下所示：</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Extractor extractor);\n  abstract public void accept(Compressor compressor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Extractor extractor) {\n    extractor.extract2txt(this);\n  }\n\n  @Override\n  public void accept(Compressor compressor) {\n    compressor.compress(this);\n  }\n\n  //...\n}\n}\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n//...Extractor代码不变\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n\n    Compressor compressor = new Compressor();\n    for(ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(compressor);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><p>上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，我们抽象出来一个Visitor接口，包含是三个命名非常通用的visit()重载函数，分别处理三种不同类型的资源文件。具体做什么业务处理，由实现这个Visitor接口的具体的类来决定，比如Extractor负责抽取文本内容，Compressor负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改ToolApplication的代码就可以了。</p><p>按照这个思路我们可以对代码进行重构，重构之后的代码如下所示：</p><pre><code>public abstract class ResourceFile {\n  protected String filePath;\n  public ResourceFile(String filePath) {\n    this.filePath = filePath;\n  }\n  abstract public void accept(Visitor vistor);\n}\n\npublic class PdfFile extends ResourceFile {\n  public PdfFile(String filePath) {\n    super(filePath);\n  }\n\n  @Override\n  public void accept(Visitor visitor) {\n    visitor.visit(this);\n  }\n\n  //...\n}\n//...PPTFile、WordFile跟PdfFile类似，这里就省略了...\n\npublic interface Visitor {\n  void visit(PdfFile pdfFile);\n  void visit(PPTFile pdfFile);\n  void visit(WordFile pdfFile);\n}\n\npublic class Extractor implements Visitor {\n  @Override\n  public void visit(PPTFile pptFile) {\n    //...\n    System.out.println(&quot;Extract PPT.&quot;);\n  }\n\n  @Override\n  public void visit(PdfFile pdfFile) {\n    //...\n    System.out.println(&quot;Extract PDF.&quot;);\n  }\n\n  @Override\n  public void visit(WordFile wordFile) {\n    //...\n    System.out.println(&quot;Extract WORD.&quot;);\n  }\n}\n\npublic class Compressor implements Visitor {\n  @Override\n  public void visit(PPTFile pptFile) {\n    //...\n    System.out.println(&quot;Compress PPT.&quot;);\n  }\n\n  @Override\n  public void visit(PdfFile pdfFile) {\n    //...\n    System.out.println(&quot;Compress PDF.&quot;);\n  }\n\n  @Override\n  public void visit(WordFile wordFile) {\n    //...\n    System.out.println(&quot;Compress WORD.&quot;);\n  }\n\n}\n\npublic class ToolApplication {\n  public static void main(String[] args) {\n    Extractor extractor = new Extractor();\n    List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);\n    for (ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(extractor);\n    }\n\n    Compressor compressor = new Compressor();\n    for(ResourceFile resourceFile : resourceFiles) {\n      resourceFile.accept(compressor);\n    }\n  }\n\n  private static List&lt;ResourceFile&gt; listAllResourceFiles(String resourceDirectory) {\n    List&lt;ResourceFile&gt; resourceFiles = new ArrayList&lt;&gt;();\n    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)\n    resourceFiles.add(new PdfFile(&quot;a.pdf&quot;));\n    resourceFiles.add(new WordFile(&quot;b.word&quot;));\n    resourceFiles.add(new PPTFile(&quot;c.ppt&quot;));\n    return resourceFiles;\n  }\n}\n</code></pre><h2>重新来看访问者模式</h2><p>刚刚我带你一步一步还原了访问者模式诞生的思维过程，现在，我们回过头来总结一下，这个模式的原理和代码实现。</p><p>访问者者模式的英文翻译是Visitor Design Pattern。在GoF的《设计模式》一书中，它是这么定义的：</p><blockquote>\n<p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p>\n</blockquote><p>翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p><p>定义比较简单，结合前面的例子不难理解，我就不过多解释了。对于访问者模式的代码实现，实际上，在上面例子中，经过层层重构之后的最终代码，就是标准的访问者模式的实现代码。这里，我又总结了一张类图，贴在了下面，你可以对照着前面的例子代码一块儿来看一下。</p><p><img src=\"https://static001.geekbang.org/resource/image/c4/65/c42c636c5384da5bd5343618305db865.jpg?wh=3436*1612\" alt=\"\"></p><p>最后，我们再来看下，访问者模式的应用场景。</p><p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实现相同的接口。在不同的应用场景下，\b我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</p><p>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。</p><p>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</p><h2>课堂讨论</h2><p>实际上，今天举的例子不用访问者模式也可以搞定，你能够想到其他实现思路吗？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"67 | 迭代器模式（下）：如何设计实现一个支持“快照”功能的iterator？","id":221269},"right":{"article_title":"69 | 访问者模式（下）：为什么支持双分派的语言不需要访问者模式？","id":222762}},"comments":[{"had_liked":false,"id":204017,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1586320217,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"272169259865","product_id":100039001,"comment_content":"访问者模式解决的痛点主要是需要动态绑定的类型，所以调用哪个重载版本，其参数中的子类必须传入静态类型为目标子类的参数，并在方法中使用传入参数的动态绑定。如果不使用访问者模式，可以使用策略模式，使用工厂模式在map中保存type和具体子类实例的映射，在使用的时候，根据type的不同调用不同子类的方法（动态绑定）。","like_count":63,"discussions":[{"author":{"id":1684390,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoibM43WGgK7Wr4VibCQDI1vnicysGibiaKetDdg7AwOelpfwATHky9MGu7M3TTX0uHsk2AicZP3AN2WGhw/132","nickname":"Geek_41fdbd","note":"","ucode":"AE9F916C7A6B53","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369938,"discussion_content":"如果WordFile不需要压缩呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619223278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250000,"discussion_content":"感觉就是把具体的对象，作为策略模式的type进行传递了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587982807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1065849,"avatar":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","nickname":"test","note":"","ucode":"9A4973E591DD12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"discussion":{"id":250030,"discussion_content":"是传递后需要用动态绑定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587985309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":250000,"ip_address":""},"score":250030,"extra":""}]}]},{"had_liked":false,"id":204035,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1586323091,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"173385014931","product_id":100039001,"comment_content":"1.虽然策略模式也能实现，但这个场景用访问者模式其实会优雅很多。<br>2.因为多种类型的同个操作聚合在了一起，那么因为这些类型是同父类的，所以属于父类的一些相同操作就能抽私有共用方法。<br>3.而策略模式，因为各个类型的代码都分割开了，那么就只好复制黏贴公共部分了。<br><br>4.另外，写合情合理的优雅代码，然后别人看不懂，一顿吹也是极爽的。只是一般节奏都挺快，第一时间可能就是策略模式走你，然后就没有然后了。","like_count":40,"discussions":[{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286881,"discussion_content":"具体的策略如果公共代码很多, 可以抽取一个BaseXXStratergy, 算是策略模式的延申, 并不影响各个策略的独立性.\n\n访问者模式问题在于可读性. 秀的挺爽, 读代码的人难受了.","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1593316861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2257439,"avatar":"https://static001.geekbang.org/account/avatar/00/22/72/1f/9ddfeff7.jpg","nickname":"文进","note":"","ucode":"CD1B6196EBC448","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409670,"discussion_content":"策略模式单个有弊端，但策略模式可以继承于一个抽象类，即策略模式+模板方法模式，即可解决。比访问者优雅和实用多了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635488000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1467219,"avatar":"https://static001.geekbang.org/account/avatar/00/16/63/53/b4590ccc.jpg","nickname":"阿文","note":"","ucode":"B53454CA52BD7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290806,"discussion_content":"访问者模式中的访问者并没有面向接口编程。而考虑使用访问者模式，是想不改动原有代码（被访问者）的情况下，使用的。如果增加一个访问者类型，所有访问者的代码都得改","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594609493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1467219,"avatar":"https://static001.geekbang.org/account/avatar/00/16/63/53/b4590ccc.jpg","nickname":"阿文","note":"","ucode":"B53454CA52BD7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290822,"discussion_content":"访问者的弊端就在那。但近期我真找到它的应用场景了。用适配器将多个策略标准化时。回参的不统一，java除了访问者模式，我没想到更好的办法。存在即合理，设计模式的出现，除了经验的总结也包括被逼无奈的场景。","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1594613558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290806,"ip_address":""},"score":290822,"extra":""},{"author":{"id":2283561,"avatar":"","nickname":"Geek_9c08ab","note":"","ucode":"EC57F8A6C8162E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392248,"discussion_content":"大佬，能说说具体怎么用的么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630921380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290822,"ip_address":""},"score":392248,"extra":""},{"author":{"id":2710546,"avatar":"https://static001.geekbang.org/account/avatar/00/29/5c/12/0eef6a4b.jpg","nickname":"壹零贰零","note":"","ucode":"53DC22F45FC2A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1467219,"avatar":"https://static001.geekbang.org/account/avatar/00/16/63/53/b4590ccc.jpg","nickname":"阿文","note":"","ucode":"B53454CA52BD7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405263,"discussion_content":"写错了把，是增加一个被访问者类型，所有访问者的代码都得改","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1634543456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":290806,"ip_address":""},"score":405263,"extra":""}]},{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":249998,"discussion_content":"感觉就是把具体的对象，作为策略模式的type进行传递了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587982781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"discussion":{"id":250052,"discussion_content":"这理解倒也没毛病。无非原本的表取值在这里变成了具体函数的选择了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587987842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":249998,"ip_address":""},"score":250052,"extra":""}]}]},{"had_liked":false,"id":203967,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1586313718,"is_pvip":false,"discussion_count":12,"race_medal":0,"score":"78895725046","product_id":100039001,"comment_content":"设计模式_68:<br># 作业：<br>今天的需求，我的第一反映是策略模式。<br># 感想:<br>挺认同文章的观点，别人写了这种模式要看得懂，自己还是不要用比较好。<br><br>给转述师提个Tip: 程序开发中常常用数字`2`代替`to`、用数字`4`代替`for`,比如文中的`extract2txt`，这时要读作`extract to txt`，而不是`extract 2(中文读音er) txt`。","like_count":18,"discussions":[{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225142,"discussion_content":"不知道为什么，我觉得这种命名方式有点不伦不类，反正打死我都不会用的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586350363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1514305,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","nickname":"xk_","note":"","ucode":"DFE1AC38EA78A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255911,"discussion_content":"简单，而且大家都懂的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588431961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":225142,"ip_address":""},"score":255911,"extra":""},{"author":{"id":2164290,"avatar":"","nickname":"Geek_17f1e0","note":"","ucode":"00FFA3B0AAE2FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320784,"discussion_content":"如果在英文环境下就会觉得很自然。从中文的角度看就会怪怪的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604478223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":225142,"ip_address":""},"score":320784,"extra":""},{"author":{"id":1375256,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fc/18/8e69f7cf.jpg","nickname":"TANMIYOO","note":"","ucode":"BC3556131D4D61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2164290,"avatar":"","nickname":"Geek_17f1e0","note":"","ucode":"00FFA3B0AAE2FE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321957,"discussion_content":"这就是IT行业的黑话","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604653023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320784,"ip_address":""},"score":321957,"extra":""}]},{"author":{"id":2164290,"avatar":"","nickname":"Geek_17f1e0","note":"","ucode":"00FFA3B0AAE2FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320782,"discussion_content":"我就想起来j2ee（j[er]ee）","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604477917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1578181,"avatar":"https://static001.geekbang.org/account/avatar/00/18/14/c5/13b42c44.jpg","nickname":"huang","note":"","ucode":"E2457134F25048","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2164290,"avatar":"","nickname":"Geek_17f1e0","note":"","ucode":"00FFA3B0AAE2FE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530381,"discussion_content":"今日快乐源泉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637062444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320782,"ip_address":""},"score":530381,"extra":"{\"user_type\":1}"}]},{"author":{"id":1236320,"avatar":"https://static001.geekbang.org/account/avatar/00/12/dd/60/a6a4f79a.jpg","nickname":"笨鸟","note":"","ucode":"68029ADA76AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336827,"discussion_content":"P2P,P2C","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608710980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1963604,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/f6/54/bf649b32.jpg","nickname":"cccy七里十一","note":"","ucode":"38858D844ECC72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376162,"discussion_content":"说起来我真的好讨厌真的to->2的命名啊ORZ，我感觉既没有多节省又不美观","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621998736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1021825,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","nickname":"David","note":"","ucode":"22CBBC13FC97A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343065,"discussion_content":"总结就是人都是懒得能1个字母绝对不3个 哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610936623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1600994,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6d/e2/5bf3c7c7.jpg","nickname":"以芢","note":"","ucode":"ABA00BD8F2C17D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342894,"discussion_content":"哈哈哈哈哈哈哈  还好我不听语音，觉得慢。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610868764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1355554,"avatar":"","nickname":"Joewing","note":"","ucode":"1417543A3B53D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318354,"discussion_content":"很多框架都是这么命名的，我反而觉得有点意思，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603716866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1445003,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0c/8b/3f7e9e74.jpg","nickname":"小小灬厮","note":"","ucode":"F4197D2F73364B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278782,"discussion_content":"看到这里才明白命名是这个意思。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591233847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203921,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1586307428,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"61715849572","product_id":100039001,"comment_content":"antlr(编译器框架）对语法树进行解析的时候就是通过visitor模式实现了扩展","like_count":14,"discussions":[{"author":{"id":1334409,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjRETqRjvLESLDZkNTjIiaSibtNYBaS1o8WMUicOFn3ycF3Mgh6LRJibqSBjVBjiaO2ibW0gHkafATb21A/132","nickname":"lmdcx","note":"","ucode":"F2CDD0091ADFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258221,"discussion_content":"所以比较难学？ O(∩_∩)O~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588667074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203924,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1586307937,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"53125915489","product_id":100039001,"comment_content":"课后思考：可以使用策略模式，对于不同的处理方式定义不同的接口，然后接口中提供对于不同类型文件的实现，再使用静态工厂类保存不同文件类型和不同处理方法的映射关系。对于后续扩展的新增文件处理方法，比如composer，按同样的方式实现一组策略，然后修改application代码使用对应的策略。","like_count":12,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385214,"discussion_content":"为啥我想起来了 装饰器模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626943789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248096,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1600008211,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40254713875","product_id":100039001,"comment_content":"当一组重载函数的参数类型是继承同一个接口或者父类的话，如果传入的参数的静态类型是这个接口或者父类，java是无法决定使用哪个重载函数的。访问者模式的巧妙之处在于，我们可以借助多态，利用多态的动态分派特性，让这个参数暴露一个方法，使得这一组重载函数（或者说声明这组重载函数的类）能进入参数对象内部（也就是让参数暴露一个参数类型是这组重载函数所在类的方法）。一旦这组重载函数进入了参数对象内部，这组重载函数就知道了它的真实类型了，这个时候再调用重载函数，就能根据参数的具体类型找到合适的重载方法了。<br>用一个通俗的例子来理解。敌军有多种类型的基地，我军有一套破坏敌军各种类型基地的方案，但是敌军的基地经过伪装，看上去都一样，我军在外面是无法决定使用哪套方案来攻击基地的。幸运的是，我军了解到，敌军每天中午会允许一批物资车进入基地，于是我方军队伪装成了敌军物资车进入到了敌军内部。进入基地之后我军了解了其真实类型，于是我军根据基地真实类型选择了相应的攻击方案，将敌军基地摧毁。","like_count":9,"discussions":[{"author":{"id":1005630,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/58/3e/77c9b529.jpg","nickname":"Sanhong","note":"","ucode":"0B68D6EE423CA8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329138,"discussion_content":"这个栗子🌰赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606316890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205250,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1586576296,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"35946314664","product_id":100039001,"comment_content":"如果不使用访问者模式，也许这也是一种改造方法：在Extractor类种在定义一个重载的方法，形参的类型为：ResourceFile，在该方法种判断参数的实际类型后再做分派。如下所示","like_count":8,"discussions":[{"author":{"id":2683430,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","nickname":"听风有信","note":"","ucode":"2CCB467114FF5C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582762,"discussion_content":"在分派的时候，抽象类实现访问者接口，可以利用模板方法模式，子类就只需要实现对特性类型的访问了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659664370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1813559,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/ac/37/8704144f.jpg","nickname":"覃丰","note":"","ucode":"CA3239CD545D06","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544587,"discussion_content":"你这种方法针对实现编程了，违反里氏替换原则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641570889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2263550,"avatar":"https://static001.geekbang.org/account/avatar/00/22/89/fe/2e034e3d.jpg","nickname":"白仔","note":"","ucode":"9B9D408951F890","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381496,"discussion_content":"很棒的方法，但是分派的时候，难免要 if else，这时候再引入策略模式，去掉 if else，可以理解为把策略模式放到具体的操作类里面？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625103839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227840,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","nickname":"大力水手Jerry","note":"","ucode":"E4A6C71E275DB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340219,"discussion_content":"这个仍然是访问者模式，唯一的区别是将关联动作从visitable类中转移到了visitor类中，且这种模式下因为要动态判断visitor类的实际类型，效率会受到一定影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609928800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312367,"discussion_content":"我觉得你的方案是最佳方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602670488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203914,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1586306508,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35946044876","product_id":100039001,"comment_content":"独立细分的访问者类（Extractor、Compressor），这些类分别对应所有类型对象某一操作的实现，如果类型多了，这些访问者类也会爆炸。","like_count":8,"discussions":[{"author":{"id":1368522,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e1/ca/d8b0835f.jpg","nickname":"橘子","note":"","ucode":"EDF6145878F897","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225241,"discussion_content":"默认适配器","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586353121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205280,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1586582051,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27356385827","product_id":100039001,"comment_content":"可以在 extractor.extract2txt(resourceFile); 这里，改为通过 instanceof 得到 resourceFile 的真正的对象类型，然后进行类型转换。代码大致如下：<br><br>if (resourceFile instanceof PdfFile ) extractor.extract2txt((PdfFile)resourceFile);<br>else if ...","like_count":6},{"had_liked":false,"id":263169,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1606030700,"is_pvip":true,"replies":[{"id":"96107","content":"嗯嗯","user_name":"作者回复","comment_id":263169,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700827,"user_name_real":"王争"}],"discussion_count":3,"race_medal":0,"score":"23080867180","product_id":100039001,"comment_content":"看完这个访问者模式，我第一反应是和桥接模式好相似，都是好像是操作与数据独立扩展，但是桥接模式主要使用的是组合，他的数据结构不支持扩展，进而我就理解了访问者模式和桥接模式不同的地方：桥接是对固定的数据结合进行多维度的独立扩展，每个维度的扩展可以在使用的时候随意组合，但是数据结构不支持改变，因为单纯的组合模式实现不了这种静态的“多态”；但是访问者模式最关键的地方是vist(this)，这么实现就做到了数据和操作两个的独立扩展，有新增的数据类型或者操作的时候都只需要按需扩展数据结构和操作即可，虽然这会涉及到所有的操作类，但是这并未对已存在的功能做出影响，是符合开闭原则的，但是这个扩展操作因为需要支持多种数据结构，所以不适合如桥接模式这种多维度独立扩展，因为那样需要改动很多的类和代码，不合适","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510111,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144462,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/8e/cf43b065.jpg","nickname":"Lee","note":"","ucode":"314D7BCB5C7C24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381451,"discussion_content":"我第一反应也是访问者模式与桥接模式一样啊，都是A类执行B类操作，就是A类将需要执行的动作委托给B类。但是我理解的不同跟你不太一样。\n\n桥接模式：A类和B的各自子类可以随意两两组合，就像作者的例子，通知A与发送B，不同的通知类型与不同的发送类型可以随意组合，发送类型B并不需要感知通知A有哪些子类，所以说两者是独立发展的。\n\n访问者模式：而访问者模式中，B类其实没有子类，B类是通过方法重载对A的不同子类有针对性的实现，所以B类是强依赖A的子类的，两者并不是独立发展的，当A类增加子类时，B类必须对应修改。\n\n策略模式：策略模式与桥接模式也很像，同样是A类执行B类操作，通过指定不同的B的子类来实现不同的操作，但是与桥接模式的区别就是A类是没有子类的，B类的不同操作实现都是针对的同一个类型。\n\n不记得在哪看到的一句描述策略模式的话：“策略模式是桥接模式的一种特例。”。我觉得有道理，当A类是固定的类型时，就是策略模式。\n\n所以，当有A类要执行B类操作时，A和B都存各自子类，且可以随意组合，不相互依赖，则使用桥接模式。当A类固定，没有子类，B类操作可以有多种时，使用策略模式。当A类有子类，同时对应的B类操作又受A的子类影响，并能随意指定，A1只能执行B1操作，A2只能执行B2操作，则可以使用访问者模式，将B1和B2通过B类的方法1和方法2重载实现，或者可以将B的方法1和方法2通过策略模式拆分成B1和B2，然后使用工厂模式实现，这样可以解决访问者模式增加A的子类时需要修改所有B类代码的问题。","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1625061384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144462,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/8e/cf43b065.jpg","nickname":"Lee","note":"","ucode":"314D7BCB5C7C24","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385373,"discussion_content":"sao话在嘴边 可就是说不出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627019798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381451,"ip_address":""},"score":385373,"extra":""}]}]},{"had_liked":false,"id":205002,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1586505787,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"23061342267","product_id":100039001,"comment_content":"  List&lt;Visitor&gt; visitors = new ArrayList&lt;&gt;();<br>        visitors.add(new Extractor());<br>        visitors.add(new Compressor());<br>        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[0]);<br>        for (Visitor visitor : visitors) {<br>            for (ResourceFile resourceFile : resourceFiles) {<br>                resourceFile.accept(visitor);<br>            }<br>        }<br><br><br>如果把main方法改成如上，是不是就相当于用到了职责链模式呀","like_count":5,"discussions":[{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312333,"discussion_content":"怎么说呢， 你要这么说，那还有点想 同步的观察者模式\n我们区分设计模式 最好从场景来区分。。。实现都大同小异的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602666094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203926,"user_name":"L","can_delete":false,"product_type":"c1","uid":1024906,"ip_address":"","ucode":"EDA19E20BE3B81","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/8a/b8b6ef13.jpg","comment_is_top":false,"comment_ctime":1586308110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23061144590","product_id":100039001,"comment_content":"课后题，策略模式+抽象工厂模式","like_count":5},{"had_liked":false,"id":203906,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1586304640,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"23061141120","product_id":100039001,"comment_content":"打卡 今日学习访问者设计模式，收获如下：<br>      访问者模式表示允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。体现了SRP原则。这个原则的代码实现比较复杂，关键要理解“函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法”。<br>      文章的例子通过4个版本的迭代，从一个最小原型实现，逐渐重构成一个符合访问者模式的代码。重构过程中不断使用前面讲解到的单一职责原则，基于接口而非实现编程等原则，使用工厂模式等来使代码逐渐符合“高内聚，低耦合”的目标。在实际开发中，该模式理解起来难度大，不建议使用。","like_count":5,"discussions":[{"author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224464,"discussion_content":"但是的确高内聚，低耦合。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586309067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1018370,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","nickname":"Frank","note":"","ucode":"7A488CC6FE15E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1286251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","nickname":"迷羊","note":"","ucode":"85AF8CED3436C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224740,"discussion_content":"恩 是的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586328140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224464,"ip_address":""},"score":224740,"extra":""}]}]},{"had_liked":false,"id":204994,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1586505104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18766374288","product_id":100039001,"comment_content":"三种模式的比较：<br>如果只是针对资源文件，来决定哪种场景下用哪种处理方式==&gt;用策略模式<br>class PPTFile{<br>    <br>}<br>interface Visitor {<br>    void visit(PPTFile pptFile);<br>}<br><br>&#47;&#47; 策略2<br>class Extractor implements Visitor {<br><br>    @Override<br>    public void visit(PPTFile pptFile) {<br>        System.out.println(&quot;抽取文字&quot;);<br>    }<br>}<br><br>&#47;&#47; 策略1<br>class Compressor implements Visitor {<br><br>    @Override<br>    public void visit(PPTFile pptFile) {<br>        System.out.println(&quot;压缩文件&quot;);<br>    }<br>}<br><br><br>class StrategyFactory {<br>    public Visitor getVisitor(PPTFile pptFile) {<br>        return ThreadLocalRandom.current().nextInt() % 2 == 0 ? new Extractor() : new Compressor();<br>    }<br>}<br><br>如果是针对某种资源，一系列操作都要用，则用职责链模式<br><br>上面的StrategyFactory 删除<br><br>class VisitorChain {<br><br>    private final List&lt;Visitor&gt; visitors = new ArrayList&lt;&gt;();<br><br>    public void addVisitor(Visitor visitor) {<br>        visitors.add(visitor);<br>    }<br><br>    List&lt;Visitor&gt; getAllAcceptVisitor() {<br>        return visitors;<br>    }<br>}<br><br>一组资源，支持一组功能。  如上 （好像这么解释也不充分？）<br>是不是就和wps里打开，关闭，保存功能似的他<br><br><br>","like_count":4},{"had_liked":false,"id":204113,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1586334817,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"14471236705","product_id":100039001,"comment_content":"问下老师，有没有哪个优秀的框架用到这个模式的？","like_count":3,"discussions":[{"author":{"id":1338086,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/e6/92257004.jpg","nickname":"徐超越","note":"","ucode":"D2587A1CB6C15C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":225703,"discussion_content":"语法树一般都会用，基本就是在树形结构上每个节点有不同操作时才适合访问者模式","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1586393497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1292456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/b8/a8/308cc6f4.jpg","nickname":"dlrqtc","note":"","ucode":"51E133026CF7F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326461,"discussion_content":"Alibaba Druid，Apache Calcite","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1605599579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213078,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","nickname":"mghio","note":"","ucode":"74883EDE4FD0DC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328574,"discussion_content":"ASM 字节码操作框架也用到了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606182872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325661,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3a/5d/c5dc789a.jpg","nickname":"咬尖月牙儿","note":"","ucode":"A6223A6B713109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290389,"discussion_content":"Spring解析占位符的时候用到了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594455943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1880582,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/b2/06/2086d76d.jpg","nickname":"buggetout","note":"","ucode":"63A948EF415FDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275556,"discussion_content":"对于不同类型对象，相同的几个操作我觉得就可以用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590728896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385371,"discussion_content":"一些 测试框架中 也用到这个技术了?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627019500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2396891,"avatar":"","nickname":"Geek_84e87d","note":"","ucode":"FE05CD5BA2822F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379773,"discussion_content":"google injector","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624123686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2116311,"avatar":"https://static001.geekbang.org/account/avatar/00/20/4a/d7/25007277.jpg","nickname":"起个名字好难","note":"","ucode":"CA5EBE510B8A34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330644,"discussion_content":"jsqlparser","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606661199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203973,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1586314120,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"14471216008","product_id":100039001,"comment_content":"对方法绑定感兴趣的同学可以看 深入理解java虚拟机 书中的-&gt;虚拟机字节码执行引擎-&gt;方法调用-&gt;方法分派的章节,详细介绍了虚拟机是如何通过静态绑定和动态绑定,实现方法重载和方法重写的<br>课后题:<br>如果子类对象的行为是一样的,都具备同样的行为(抽取,压缩,分析),那么用模板方法模式也完全可以,修改的成本并没有多大<br>如果子类对象的行为是不一致的,比如对ppt只进行抽取,对word进行抽取和压缩,那么各个子类都维护自己的方法比较好,没有必要抽取出来","like_count":3,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385374,"discussion_content":"好嘛 当初 就是这里 跳过了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627019837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249907,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1600847886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10190782478","product_id":100039001,"comment_content":"本质是操作对象本身和操作逻辑的解耦。","like_count":2},{"had_liked":false,"id":220709,"user_name":"道","can_delete":false,"product_type":"c1","uid":1324160,"ip_address":"","ucode":"851A0AD751D317","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/80/30e9ae41.jpg","comment_is_top":false,"comment_ctime":1590311310,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10180245902","product_id":100039001,"comment_content":"accept方法很巧妙，重载，编译器按照类型匹配，而this关键字代表“当前类型对象”","like_count":2},{"had_liked":false,"id":204332,"user_name":"筱乐乐哦","can_delete":false,"product_type":"c1","uid":1307611,"ip_address":"","ucode":"AE92539F0419C3","user_header":"https://static001.geekbang.org/account/avatar/00/13/f3/db/5b7a8fd8.jpg","comment_is_top":false,"comment_ctime":1586367591,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10176302183","product_id":100039001,"comment_content":"想问下这种设计模式在哪个的源码中有使用咋？先看下是怎么用的，老师写的例子还是比较简单易懂的，但感觉实际用的时候，需要根据业务抽象，就不好弄了呀","like_count":2,"discussions":[{"author":{"id":1111822,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/0e/3f369d27.jpg","nickname":"星","note":"","ucode":"3CD98024CCDBD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309324,"discussion_content":"aop框架  ASM就是用的访问者模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601258313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322555,"user_name":"陆一鸣猜不动","can_delete":false,"product_type":"c1","uid":2831163,"ip_address":"","ucode":"68E89A037F9A0C","user_header":"https://static001.geekbang.org/account/avatar/00/2b/33/3b/0b25b622.jpg","comment_is_top":false,"comment_ctime":1637481111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5932448407","product_id":100039001,"comment_content":"感觉这个也是控制反转的一种体现，然后写法我感觉挺functional的？","like_count":1},{"had_liked":false,"id":295710,"user_name":"乔宏民","can_delete":false,"product_type":"c1","uid":2181661,"ip_address":"","ucode":"B6A9F971E9CC96","user_header":"https://static001.geekbang.org/account/avatar/00/21/4a/1d/3567f117.jpg","comment_is_top":false,"comment_ctime":1622554883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5917522179","product_id":100039001,"comment_content":"访问者主要是把传入不确定的对象类型，反过来变成，用确定的对象类型来接收访问者，然后在自己类的方法内部，把自己再传给访问者的执行方法，这样就能确定了参数类型了。","like_count":1},{"had_liked":false,"id":253449,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1602743107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897710403","product_id":100039001,"comment_content":"我今天写、理解了半天，最终抽象了访问者和策略 两种模式在此场景下的区别：<br>两种模式都能实现，只是出发点截然不同。<br>访问者：  一个Visitor 包含访问N个资源的同一类方法(采用重载)，<br>        意在一个类提供一种访问形式，可以访问所有资源。<br>策略：    一个Strategy包含对1个资源的N种方法，<br>        意在一个类包含对一个资源的所有处理策略。<br>tips:当不希望实现Visitor所有接口时，可以将接口的方法定义为default方法。","like_count":1},{"had_liked":false,"id":206293,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1586835808,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881803104","product_id":100039001,"comment_content":"一个类里面的数据是稳定的，但是附加在数据上面的操作是不确定的。需要动态的或者静态的绑定对象与对象上面的操作。","like_count":1},{"had_liked":false,"id":205371,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1586600493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881567789","product_id":100039001,"comment_content":"思考题：可以用策略模式。这个应用场景是针对不同类型对象执行不同的操作，明显是个行为型的设计模式，这些不同的操作可以看作是一组针对不同类型对象的“算法”，把算法抽象出来，用工厂创建不同类型对象的对应“算法”，将type和“算法”操作对应起来，正好实现了访问者模式中“函数重载”要实现的功能。","like_count":1},{"had_liked":false,"id":205252,"user_name":"秋风画扇","can_delete":false,"product_type":"c1","uid":1132356,"ip_address":"","ucode":"5BCBC1422C51EC","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/44/964aa665.jpg","comment_is_top":false,"comment_ctime":1586576869,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5881544165","product_id":100039001,"comment_content":"访问者模式把行为独立出来，咋一看比较整齐，实际维护代价很大，每扩展一种对象每种行为都要添加一个重载方法。<br><br>个人更倾向于 模板方法，对象和行为融合在一起。父类抽象类实现共有行为，不同行为通过实现接口来扩展。这样从方法名称上就知道具体要做什么，也方便扩展，整体看起来更为统一","like_count":1,"discussions":[{"author":{"id":1608383,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8a/bf/3f7c45c9.jpg","nickname":"X_L～","note":"","ucode":"6BD8C24750F86B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368929,"discussion_content":"精辟","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618884117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220713,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a0/69/e42348a8.jpg","nickname":"李奇锋","note":"","ucode":"1A0A359D0530C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363771,"discussion_content":"前提是有一个正确/合理的抽象模型","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617280183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204233,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1586354535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881321831","product_id":100039001,"comment_content":"可以使用策略模式, 用工厂方法来","like_count":1},{"had_liked":false,"id":203998,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1586317060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881284356","product_id":100039001,"comment_content":"文中提到重载是一种静态绑定,多态是一种动态绑定,这里多态可以理解为重写吧<br>jvm中不存在重载,因为编译阶段时已经确定了目标方法.<br>动态绑定需要根据方法描述符来确定目标方法,最基础的是方法表的方式,另外还有优化手段内联缓存和方法内联.","like_count":1},{"had_liked":false,"id":203994,"user_name":"Ken张云忠","can_delete":false,"product_type":"c1","uid":1134288,"ip_address":"","ucode":"D0BAC9FC17DE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","comment_is_top":false,"comment_ctime":1586316061,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5881283357","product_id":100039001,"comment_content":"实际上，今天举的例子不用访问者模式也可以搞定，你能够想到其他实现思路吗？<br>可以使用策略模式.<br>定义读取策略接口ExtractorStrategy并实现三个策略,再定义一个策略工厂类,以文件类型作为key,以对应策略实现作为value,使用时通过具体的ResourceFile类型获取对应的策略实现类型,然后再调用实现函数.","like_count":1,"discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83909,"discussion_content":"并非表面，事实就是如此。原本的spring容器需要在web容器初始化好后才装配，现在变成web容器在spring容器初始化时装配。这给予了spring容器初始化更多的权限。脱离寄人篱下的窘境。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1576473410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2336076,"avatar":"https://static001.geekbang.org/account/avatar/00/23/a5/4c/8c225320.jpg","nickname":"Miss陈","note":"","ucode":"C4635B9479963A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330175,"discussion_content":"springboot只是一个自动装配的脚手架，你所说的控制权，依然是在spring框架手上啊，spring通过依赖注入实现对象的管理，springboot只是这些框架的一个零配置工具而已，tomcat服务器也是面向servlet规范开发，你所写的类会被编译成servlet类，你这个表述有点混乱，springboot只是一个jar包而已，里面对框架进行&#34;自动装配&#34;，实现0配置方便使用，对于你开发的应用，控制权一直在spring手中","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606539808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344431,"avatar":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","nickname":"马以","note":"","ucode":"3FEA06CA14DE28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192968,"discussion_content":"纳尼。。。。。？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583113092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252593,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/f1/840ef7f9.jpg","nickname":"KKKKK","note":"","ucode":"E9DAF0FCCE898C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98356,"discussion_content":"一个是运行容器 一个是开发框架 这两个有必然联系吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577156902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1482915,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","nickname":"业余爱好者","note":"","ucode":"A890935A982988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1252593,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1c/f1/840ef7f9.jpg","nickname":"KKKKK","note":"","ucode":"E9DAF0FCCE898C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98379,"discussion_content":"都是容器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577159032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":98356,"ip_address":""},"score":98379,"extra":""}]},{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88344,"discussion_content":"Springboot.  Web项目不还是离不开web容器吗，只是内嵌了而已,它还是活在web容器的“阴影”里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576704713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83720,"discussion_content":"真的是这样么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576459754,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1482915,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","nickname":"业余爱好者","note":"","ucode":"A890935A982988","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1397298,"avatar":"https://static001.geekbang.org/account/avatar/00/15/52/32/bb570f48.jpg","nickname":"向往的生活","note":"","ucode":"0E8DB45357820F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":83836,"discussion_content":"表面上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576468571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":83720,"ip_address":""},"score":83836,"extra":""}]}]},{"had_liked":false,"id":203978,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1586314943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881282239","product_id":100039001,"comment_content":"1.能,只需要应用策略模式,在策略类中提供一个入口,在入口方法中进行类的判断,调用即可,可读性较好,不过代码比较冗余<br>2.对于本章,其实可看做就是不同类型的用户去访问一个服务器,根据不同的用户去做不同的处理.比较困难的就是用户可能不知道自己是谁,那就需要我们去帮他知道是谁","like_count":1},{"had_liked":false,"id":360147,"user_name":"、BQ","can_delete":false,"product_type":"c1","uid":1132203,"ip_address":"浙江","ucode":"7CAFE074F7C536","user_header":"https://static001.geekbang.org/account/avatar/00/11/46/ab/bae17033.jpg","comment_is_top":false,"comment_ctime":1666232443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666232443","product_id":100039001,"comment_content":"假如某类文件不需要压缩或者转 txt，按访问者模式还是不能解决，所以还是违背开闭原则的吧","like_count":0},{"had_liked":false,"id":357941,"user_name":"魏知","can_delete":false,"product_type":"c1","uid":1005615,"ip_address":"上海","ucode":"662B0290AC2C41","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/2f/b29d08d6.jpg","comment_is_top":false,"comment_ctime":1663761422,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663761422","product_id":100039001,"comment_content":"语法解析器@babel&#47;traverse 中对不同 AST 节点类型做解析操作的时候，也用了访问者模式~","like_count":0},{"had_liked":false,"id":353653,"user_name":"听风有信","can_delete":false,"product_type":"c1","uid":2683430,"ip_address":"广东","ucode":"2CCB467114FF5C","user_header":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","comment_is_top":false,"comment_ctime":1659663921,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659663921","product_id":100039001,"comment_content":"模板方法模式，在父类中判断不同的类型，调用不同的方法。","like_count":0},{"had_liked":false,"id":351357,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1657719612,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657719612","product_id":100039001,"comment_content":"感觉就是策略模式膨胀后的我简化处理模式","like_count":0},{"had_liked":false,"id":348013,"user_name":"寒光","can_delete":false,"product_type":"c1","uid":1206187,"ip_address":"","ucode":"061BE413595F21","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/ab/fcf0cec4.jpg","comment_is_top":false,"comment_ctime":1654664327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654664327","product_id":100039001,"comment_content":"Visitor的重载方法没有必要，完全可以用一个更可读的方法名，如visitPdfFile，visitWordFile，这样理解起来就容易多了。","like_count":0},{"had_liked":false,"id":331349,"user_name":"张晓永","can_delete":false,"product_type":"c1","uid":1529668,"ip_address":"","ucode":"C728459C061A13","user_header":"https://static001.geekbang.org/account/avatar/00/17/57/44/a0ed355d.jpg","comment_is_top":false,"comment_ctime":1642559211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642559211","product_id":100039001,"comment_content":"访问者模式 企图用重载，解决接口实现太多的问题，和隐藏访问者具体操作的目的","like_count":0},{"had_liked":false,"id":331348,"user_name":"张晓永","can_delete":false,"product_type":"c1","uid":1529668,"ip_address":"","ucode":"C728459C061A13","user_header":"https://static001.geekbang.org/account/avatar/00/17/57/44/a0ed355d.jpg","comment_is_top":false,"comment_ctime":1642559024,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642559024","product_id":100039001,"comment_content":"访问者把重载方法，改成多个接口，就可以了，但这样会增加类的个数","like_count":0},{"had_liked":false,"id":324657,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1638529357,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1638529357","product_id":100039001,"comment_content":"为啥我想到的是桥梁模式","like_count":0,"discussions":[{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337681,"discussion_content":"同意","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609040737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324141,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1638321743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638321743","product_id":100039001,"comment_content":"职责链也可以","like_count":0},{"had_liked":false,"id":322292,"user_name":"小王在努力","can_delete":false,"product_type":"c1","uid":2733574,"ip_address":"","ucode":"A324EF87198905","user_header":"https://static001.geekbang.org/account/avatar/00/29/b6/06/cd1eaa49.jpg","comment_is_top":false,"comment_ctime":1637291920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637291920","product_id":100039001,"comment_content":"打卡，思想最重要；解耦，对象的创建和使用解耦。","like_count":0},{"had_liked":false,"id":319830,"user_name":"Geek_jerry","can_delete":false,"product_type":"c1","uid":1736148,"ip_address":"","ucode":"684923936D7849","user_header":"","comment_is_top":false,"comment_ctime":1635955684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635955684","product_id":100039001,"comment_content":"谢谢王争老师，这是我学过的最清晰的访问者模式，没有之一。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478031,"discussion_content":"tomcat的例子不算啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576804038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385841,"discussion_content":"你细品，前面旁敲侧击，最后一个类比概括，还不够精彩吗？跟作文倒叙一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627296019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2254854,"avatar":"https://static001.geekbang.org/account/avatar/00/22/68/06/e74b5675.jpg","nickname":"存在","note":"","ucode":"F3217DC5B799BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587509,"discussion_content":"JDBC其实也是一种DIP原则，各个数据库厂商自行实现驱动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663120546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317661,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634884088,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634884088","product_id":100039001,"comment_content":"这里访问者模式最核心的是 visit(this)  这样就把操作和资源分离，并且通过多态特性，省略了判断类型的过程。 如果用其他方式实现，因为不同资源类型的操作（比如extract或compress）具体不同，可以根据每种类型定义不同的策略类，在操作时，判断类型，然后应用不同的策略类，但会增加一个遍历判断类型的过程。","like_count":0},{"had_liked":false,"id":309908,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1630391257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630391257","product_id":100039001,"comment_content":"这篇文章实在太牛了！","like_count":0},{"had_liked":false,"id":309796,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1630335463,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630335463","product_id":100039001,"comment_content":"不错，又学习了一招","like_count":0},{"had_liked":false,"id":304318,"user_name":"常清","can_delete":false,"product_type":"c1","uid":1106090,"ip_address":"","ucode":"EA6975FDFD4D11","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/aa/68a7921b.jpg","comment_is_top":false,"comment_ctime":1627353375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627353375","product_id":100039001,"comment_content":"这里的visitor感觉就是个工具类，只不过平时我们自己主动调用工具类，这里间接调用。","like_count":0},{"had_liked":false,"id":303501,"user_name":"奕客","can_delete":false,"product_type":"c1","uid":2700602,"ip_address":"","ucode":"C65D8E8B8FFDA9","user_header":"https://static001.geekbang.org/account/avatar/00/29/35/3a/28a8595c.jpg","comment_is_top":false,"comment_ctime":1626835174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626835174","product_id":100039001,"comment_content":"对于这个场景不是很明白为什么就比策略模式要优雅的多，在策略工厂中通过Map缓存方式创建ExtractorStrategy、CompressorStrategy这两种策略之后，再根据type来判断具体调用哪个策略。如果再有新的操作，新增一个策略也是符合开闭原则啊。","like_count":0},{"had_liked":false,"id":301831,"user_name":"猪蹄子🍳","can_delete":false,"product_type":"c1","uid":2649189,"ip_address":"","ucode":"3C4875114716FA","user_header":"https://static001.geekbang.org/account/avatar/00/28/6c/65/d78cceda.jpg","comment_is_top":false,"comment_ctime":1625903137,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625903137","product_id":100039001,"comment_content":"1. 类的操作直接写在类中（例如：PdfFile.extract()）：数据结构和业务耦合。违反易扩展原则。<br>2. 将操作抽象为独立的类（Extractor，Compressor），数据结构仅提供操作接口（PdfFile.accept(extractor)）：解耦。但仍然需要为不同的操作提供不同的接口。<br>3. 将操作类抽象为一个统一的类（Visitor），数据结构为这些访问者提供统一的接口：访问者模式","like_count":0},{"had_liked":false,"id":301072,"user_name":"taku","can_delete":false,"product_type":"c1","uid":2068684,"ip_address":"","ucode":"B22DA9A4A9DC91","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotIianb3beTzsGIte6BZxlIhEwc2ryrNBGxZy8ibKbfibVJyUS8d3ZxybAdfJwHPm13ydPC4VJP7Lbw/132","comment_is_top":false,"comment_ctime":1625529190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625529190","product_id":100039001,"comment_content":"感觉像是组合模式的翻版，即依赖与被依赖对象的位置互换，同时被依赖对象去处理依赖对象(visit this)","like_count":0},{"had_liked":false,"id":295280,"user_name":"阿文","can_delete":false,"product_type":"c1","uid":1467219,"ip_address":"","ucode":"B53454CA52BD7E","user_header":"https://static001.geekbang.org/account/avatar/00/16/63/53/b4590ccc.jpg","comment_is_top":false,"comment_ctime":1622344102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622344102","product_id":100039001,"comment_content":"public interface Visitor { void visit(PdfFile pdfFile); void visit(PPTFile pdfFile); void visit(WordFile pdfFile);}<br>方法依赖了实现。多个XlsFile，就得改 访问者体系了，这里能不能优化下呢？感觉用策略模式简单明了一点。","like_count":0},{"had_liked":false,"id":292729,"user_name":"Earth Dog","can_delete":false,"product_type":"c1","uid":1435329,"ip_address":"","ucode":"63B1674F1B27E7","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/c1/041a39c4.jpg","comment_is_top":false,"comment_ctime":1620954496,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1620954496","product_id":100039001,"comment_content":"老师，有个疑问，那么如果需要添加对xls文件的处理是不是还是要修改visitor这个接口的代码，如果是的话，那么是不是其实还是有点不太符合开闭原则呢？<br><br>还有visitor这接口里面参数名字好像忘了改哈，<br>public interface Visitor { <br>void visit(PdfFile pdfFile); <br>void visit(PPTFile pdfFile);<br> void visit(WordFile pdfFile);<br>}<br>三个参数名都是pdfFile哈","like_count":0},{"had_liked":false,"id":292726,"user_name":"Earth Dog","can_delete":false,"product_type":"c1","uid":1435329,"ip_address":"","ucode":"63B1674F1B27E7","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/c1/041a39c4.jpg","comment_is_top":false,"comment_ctime":1620953193,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1620953193","product_id":100039001,"comment_content":"老师，对上面这个例子来说，策略模式 + 工厂方法是不是好点？Map存后缀作为key，具体处理方法为value，每次添加一个新的处理方式就注册到这个map里面。使用时，工厂通过后缀选择对应的方法进行处理","like_count":0},{"had_liked":false,"id":287108,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1617778765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617778765","product_id":100039001,"comment_content":"如果可以不同的操作在上个操作的基础上进行操作的话，我觉得可以用装饰器。如果不同有分离的话，策略，工厂，都是可以的","like_count":0},{"had_liked":false,"id":283676,"user_name":"Jason.w","can_delete":false,"product_type":"c1","uid":1366413,"ip_address":"","ucode":"EE39ADEB7C6BC8","user_header":"https://static001.geekbang.org/account/avatar/00/14/d9/8d/a6984f12.jpg","comment_is_top":false,"comment_ctime":1615882229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615882229","product_id":100039001,"comment_content":"我觉得可以用装饰者模式，<br>abstract class ResourceFileDecorator extend ResourceFile{<br>        protected ResourceFile resourceFile;<br>        public abstract void extract();<br>        public abstract void compress();<br>}<br>可以使用接口适配器把extract和compress隔离开。<br><br>下面两个装饰类分别继承对应的接口适配器。<br>ExtractableResourceFile、CompressableResourceFile.<br><br>","like_count":0},{"had_liked":false,"id":282312,"user_name":"当你的世界里有风吹过","can_delete":false,"product_type":"c1","uid":2051946,"ip_address":"","ucode":"42712891366309","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4f/6a/0a6b437e.jpg","comment_is_top":false,"comment_ctime":1615193705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615193705","product_id":100039001,"comment_content":"如果操作的对象再增加，那么Visitor访问者接口就需要增加新的方法，这样也违反开闭原则。","like_count":0},{"had_liked":false,"id":277223,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1612320723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612320723","product_id":100039001,"comment_content":"这种方式确实很难想到。","like_count":0},{"had_liked":false,"id":276316,"user_name":"🐝","can_delete":false,"product_type":"c1","uid":1183211,"ip_address":"","ucode":"28B3C527D81DC3","user_header":"https://static001.geekbang.org/account/avatar/00/12/0d/eb/c3ff1e85.jpg","comment_is_top":false,"comment_ctime":1611885647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611885647","product_id":100039001,"comment_content":"像模版模式，函数传递也很想函数式编程","like_count":0},{"had_liked":false,"id":274369,"user_name":"zhou","can_delete":false,"product_type":"c1","uid":1087243,"ip_address":"","ucode":"E1CE8575B3F106","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","comment_is_top":false,"comment_ctime":1610981089,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1610981089","product_id":100039001,"comment_content":"感觉访问者模式 更多的是把核心的逻辑从主体移到Visitor的实现中去处理了","like_count":0},{"had_liked":false,"id":274241,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1610937300,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610937300","product_id":100039001,"comment_content":"访问者模式理解:<br>使Visotor和Visitable可以独立变化。设计意图是解耦不同的操作和对象本身<br>Visitor:访问者可以去不同人家里去拜访 <br>visit(VisitableA v),visit(VisitableA v)。<br>Visitable: 被访问者接受不同的拜访者<br>accept(Visitor visitor)","like_count":0},{"had_liked":false,"id":271981,"user_name":"sta","can_delete":false,"product_type":"c1","uid":1032755,"ip_address":"","ucode":"D840070850EA5B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c2/33/ccbf2045.jpg","comment_is_top":false,"comment_ctime":1609901259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609901259","product_id":100039001,"comment_content":"访问者模式由于将不同类型的处理放在了同一个访问者类中（如Extract类），对每个类型的处理放在访问类的不同的重载方法中，重载方法的使用其实就是访问者模式的精髓（就是访问者模式与其他模式最大的区别，其他模式没用重载，访问模式的重载的作用就是区分不同的类型），但是Java不支持运行时动态绑定参数，只支持静态编译时绑定，所以不能将不同类型的接口传给访问者类，那么只能通过在不同类型的接口中增加一个accept方法，将访问者传递进accept方法，借用对象方法使用时的动态绑定，将当前类型的对象传入重载方法，以此比较绕的方法实现了方法重载。<br><br>访问者模式将不同类型的同一种处理方式放在同一个访问类中，既是访问者模式的优势也是其劣势，需要从不同的场景来看，如果场景是类型固定不变，且类型又比较多，且处理方式会变化，那么使用访问者模式，将不同类型的同一种处理方式放在同一个访问类中，可以减少类的个数易于维护，同时也满足开闭原则。但是如果场景是类型可能会变化的，那么新增一种类型，每个访问类中也要新增一个重载函数用于处理该类型，此时从函数角度来说是满足开闭原则的，但是从类角度来说又不满足开闭原则了。","like_count":0},{"had_liked":false,"id":264821,"user_name":"起个名字好难","can_delete":false,"product_type":"c1","uid":2116311,"ip_address":"","ucode":"CA5EBE510B8A34","user_header":"https://static001.geekbang.org/account/avatar/00/20/4a/d7/25007277.jpg","comment_is_top":false,"comment_ctime":1606662061,"is_pvip":false,"replies":[{"id":"96057","content":"嗯嗯 加油","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700501,"ip_address":"","comment_id":264821,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606662061","product_id":100039001,"comment_content":"把属性和行为分离的前提是抽象，如果要访问的对象结构一旦改变必然是灾难。在我看来最困难的地方还是抽象。我在阅读jsqlparser源码的时候发现代码相对容易理解，但是在抽象sql时，真的感觉类都要爆炸了，没有一定的抽象能力真的搞不定","like_count":0,"discussions":[{"author":{"id":1466447,"avatar":"https://static001.geekbang.org/account/avatar/00/16/60/4f/db0e62b3.jpg","nickname":"Daiver","note":"","ucode":"9B1A03AFBC79BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83570,"discussion_content":"共同点：二者的存在都是为了解耦。二者的区别：基于接口编程是最重要的就是可扩展性；而依赖注入托管了对象的生命周期，依赖注入有运行时 注入和编译时注入；从spring的依赖注入来说，它不仅有着了依赖注入作用，同时也包含了面向接口编程。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576430120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263117,"user_name":"CoderArthur","can_delete":false,"product_type":"c1","uid":1625233,"ip_address":"","ucode":"5B591914F0F67C","user_header":"https://static001.geekbang.org/account/avatar/00/18/cc/91/d56a81af.jpg","comment_is_top":false,"comment_ctime":1606012356,"is_pvip":false,"replies":[{"id":"96108","content":"是有点不好理解","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700841,"ip_address":"","comment_id":263117,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606012356","product_id":100039001,"comment_content":"很nice的设计模式，差点略过没看，还好点进来再看第二遍，第二遍略懂了点。<br><br>昨天在实现迭代器模式的时候，也碰到过运行时期动态选择和编译器静态选择的问题，现在按照作者的写法思考下怎么解决我的问题。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510101,"discussion_content":"是有点不好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260335,"user_name":"查理","can_delete":false,"product_type":"c1","uid":1111297,"ip_address":"","ucode":"A9FEA901E3A05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/01/5389295c.jpg","comment_is_top":false,"comment_ctime":1604986927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604986927","product_id":100039001,"comment_content":"课后题：策略模式 + 工厂模式。<br>Resource中维护type字段，标识类型（PDF、PPT、WORD）<br>定义操作接口，如Extractor，实现有PDFExtractor等。<br>工厂模式作用是根据type创建具体的策略","like_count":0},{"had_liked":false,"id":260279,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1929375,"ip_address":"","ucode":"7C554C97935443","user_header":"https://static001.geekbang.org/account/avatar/00/1d/70/9f/741cd6a4.jpg","comment_is_top":false,"comment_ctime":1604975318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604975318","product_id":100039001,"comment_content":"访问者模式把耦合提升到接口层面上了，接口设计地不好的话所有实现的子类都得改，还是用策略模式好点。","like_count":0},{"had_liked":false,"id":258586,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1604493164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604493164","product_id":100039001,"comment_content":"这个场景正是我现在做的项目中的一部分，有Excel、CSV、HTML、PDF等各种文件要解析","like_count":0},{"had_liked":false,"id":257143,"user_name":"cv0cv0","can_delete":false,"product_type":"c1","uid":1360093,"ip_address":"","ucode":"93FF9277F03FD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","comment_is_top":false,"comment_ctime":1603861056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603861056","product_id":100039001,"comment_content":"这一讲好。","like_count":0},{"had_liked":false,"id":256665,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1603700363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603700363","product_id":100039001,"comment_content":"打卡68","like_count":0},{"had_liked":false,"id":256408,"user_name":"flyCoder","can_delete":false,"product_type":"c1","uid":1074897,"ip_address":"","ucode":"82FB7B60775978","user_header":"https://static001.geekbang.org/account/avatar/00/10/66/d1/8664c464.jpg","comment_is_top":false,"comment_ctime":1603618523,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603618523","product_id":100039001,"comment_content":"今天的例子可以使用策略模式和工厂模式解决，但是访问者模式还是比较妙的。","like_count":0},{"had_liked":false,"id":255822,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1603439402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603439402","product_id":100039001,"comment_content":"但是违背了接口隔离原则，vistor<br>","like_count":0},{"had_liked":false,"id":253985,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1603003574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603003574","product_id":100039001,"comment_content":"有个疑问  拿Extractor 来说  Extractor 并不能直接访问ResourceFile 的属性那怎么实现功能呢，假如之前有些属性是私有的，那么为了满足 Extractor  的需求 那么ResourceFile 就需要该动，包括后面一讲的那个方式也是一样","like_count":0},{"had_liked":false,"id":253979,"user_name":"Gopher","can_delete":false,"product_type":"c1","uid":1206229,"ip_address":"","ucode":"3C1F9012BB486D","user_header":"https://static001.geekbang.org/account/avatar/00/12/67/d5/1b26b725.jpg","comment_is_top":false,"comment_ctime":1603000847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603000847","product_id":100039001,"comment_content":"访问者模式允许你在结构体中添加行为， 而又不会对结构体造成实际变更","like_count":0},{"had_liked":false,"id":253283,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1602673478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602673478","product_id":100039001,"comment_content":"感觉策略模式更好用哦。 <br>1、PDFStrategy、XMLStrategy， WORDStrategy<br>2、生成策略工厂 Map&lt;Class，Strategy&gt;，根据要处理的对象.getClass()，不同，找出对应的策略<br>3、执行策略的压缩or提取方法。<br>当业务膨胀时<br>4、增加一个过滤Strategy，加入Map中，满足开闭原则","like_count":0},{"had_liked":false,"id":252030,"user_name":"小乙哥","can_delete":false,"product_type":"c1","uid":1063308,"ip_address":"","ucode":"C77E79BEA0C325","user_header":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","comment_is_top":false,"comment_ctime":1602067475,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602067475","product_id":100039001,"comment_content":"1.与多态通过运行时确定调用的方法不同，访问者模式通过方法的重载，实现调用的多样性<br>2.访问者模式在编译器解析语法的时候有广泛的使用，比如Antlr","like_count":0},{"had_liked":false,"id":249141,"user_name":"张贺龙","can_delete":false,"product_type":"c1","uid":1862219,"ip_address":"","ucode":"209B08E3E7075A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKSjC36vSdPiaibQqrVicXYk7pvia1JKpY8aib9DBNMBHIPVxPE19wP9MTm63akRp6uYBjFibEk6XytrgNg/132","comment_is_top":false,"comment_ctime":1600474271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600474271","product_id":100039001,"comment_content":"可以通过职责链模式实现。对每个功能设计一个职责链，职责链继承同一个接口","like_count":0},{"had_liked":false,"id":248754,"user_name":"鲁鸣","can_delete":false,"product_type":"c1","uid":2152306,"ip_address":"","ucode":"974BA3C3E64630","user_header":"https://static001.geekbang.org/account/avatar/00/20/d7/72/cbef720d.jpg","comment_is_top":false,"comment_ctime":1600303466,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600303466","product_id":100039001,"comment_content":"碰到最多的就是使用visitor模式对ast抽象语法树进行访问。主要的问题就是每增加一种元素类型，所有的访问者都需要修改","like_count":0},{"had_liked":false,"id":243655,"user_name":"Geek_077f37","can_delete":false,"product_type":"c1","uid":2100185,"ip_address":"","ucode":"5CA1DD0C5A21B6","user_header":"","comment_is_top":false,"comment_ctime":1598240812,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598240812","product_id":100039001,"comment_content":"Java是一种静态多分派，动态单分派语言，访问者模式其实是一种动态多分派的实现。","like_count":0},{"had_liked":false,"id":232282,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593943211,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593943211","product_id":100039001,"comment_content":"问题定义：<br>需要针对PDF，word等数据文件进行文本抽取及压缩等操作。<br>pdf等是一个资源，而文本抽取和压缩是操作。<br>用访问者模式，我们可以定义：元素:pdf等资源，访问者：就是文本抽取或压缩操作。<br>对应的元素定义一个accept方法，相应的对于这个元素的操作会交给具体的文本抽取或压缩操作。 ","like_count":0},{"had_liked":false,"id":229702,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1593104342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593104342","product_id":100039001,"comment_content":"我觉得访问者模式，就是策略模式在支持重载语法的语言中的一种实现~  两个模式本质都是解耦操作和数据（对象）","like_count":0},{"had_liked":false,"id":227794,"user_name":"CarlXu","can_delete":false,"product_type":"c1","uid":1585713,"ip_address":"","ucode":"6A5DF4459907C2","user_header":"https://static001.geekbang.org/account/avatar/00/18/32/31/449513a1.jpg","comment_is_top":false,"comment_ctime":1592482602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592482602","product_id":100039001,"comment_content":"这里针对每个功能类的设计不同就变相的使用了不同的设计模式,  比如说我们把pdf&#47;word类的所有可能操作都放到自己类里面,  这个就是用的工厂模式+策略模式来实现解耦的功能.  如果我们从另外一个角度,把针对这些不同格式的文件可能进行的操作,当作一个新的类来设计, 就是现在的这种访问者模式.  代码量实际上是相同的, 只是把实现这些功能的代码放到了不同的类中进行组装而已.  这两种方式的好坏就得看实际的业务来说了.","like_count":0},{"had_liked":false,"id":227782,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592478883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592478883","product_id":100039001,"comment_content":"访问者模式和迭代器模式，都是解耦算法和数据，访问者侧重某个处理，迭代器着重逐个遍历","like_count":0},{"had_liked":false,"id":217827,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1589621760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589621760","product_id":100039001,"comment_content":"不使用访问者模式的话，可以作如下设计，ResourceFile 增加 abstract String type() 的抽象方法获取文件类型，再通过定义不同类型的 Extractor &#47; Compressor 处理器，如 PDFExtractor &#47; PDFCompressor（处理器也可以合并为 ResourceFileProcessor 并增加 extract2txt(ResourceFile file) &#47; compress(ResourceFile file) 方法），再以 ResourceFile.type() 的返回类型获取相应的处理器进行处理（策略模式+静态工厂模式）<br><br>访问者模式似乎也有一定的依赖倒置原则思想","like_count":0},{"had_liked":false,"id":215107,"user_name":"电光火石","can_delete":false,"product_type":"c1","uid":1013160,"ip_address":"","ucode":"3AD33BB4AA940F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/a8/dfe4cade.jpg","comment_is_top":false,"comment_ctime":1588906100,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588906100","product_id":100039001,"comment_content":"如果这个时候，新增一种文件类型，那么所有的visitor（extractor、compressor）是不是都需要增加一个方法去处理这个新的文件类型，这里有没有什么好的方法吗？感觉也违反了开闭原则，谢谢了！","like_count":0,"discussions":[{"author":{"id":1813614,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/ac/6e/c13d131c.jpg","nickname":"她微笑的脸y","note":"","ucode":"E3B559B10B4A70","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530713,"discussion_content":"依赖同一个抽象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637132730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2415980,"avatar":"","nickname":"Geek_9bd83c","note":"","ucode":"0CACC79030FCBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590716,"discussion_content":"上层定义约定接口，只调用接口。\n底层实现接口具体逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666035120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010796,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6c/6c/abb7bfe3.jpg","nickname":"我是谁","note":"","ucode":"2362EABBFFF7C2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542992,"discussion_content":"感觉较真起来还是要依赖于底层，只不过这个上层代码只使用了这个抽象/接口，而不是直接使用底层类","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640925074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215029,"user_name":"郑童文","can_delete":false,"product_type":"c1","uid":1030733,"ip_address":"","ucode":"3D193715CB8549","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/4d/7ba09ff0.jpg","comment_is_top":false,"comment_ctime":1588892761,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588892761","product_id":100039001,"comment_content":"感觉每增加一个ConcreteVisitable类，就需要向Visitor接口和每个ConcreteVisitor类增加一个方法。好像两者还是有耦合啊","like_count":0},{"had_liked":false,"id":211652,"user_name":"桃花河逆流而上","can_delete":false,"product_type":"c1","uid":1464183,"ip_address":"","ucode":"A88A60296743CF","user_header":"https://static001.geekbang.org/account/avatar/00/16/57/77/ad6b2b8b.jpg","comment_is_top":false,"comment_ctime":1587992649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587992649","product_id":100039001,"comment_content":"最近还真写了这么一段代码，是用 if-else 加 instanceof 判断是哪个子类，然后强转，强转后再传参...","like_count":0},{"had_liked":false,"id":211395,"user_name":"悠游","can_delete":false,"product_type":"c1","uid":1222834,"ip_address":"","ucode":"4FDDDDF29AE3F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/b2/998448ca.jpg","comment_is_top":false,"comment_ctime":1587957388,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587957388","product_id":100039001,"comment_content":"Extractor或者Visitor接口看起来都必须穷尽ResourceFile的类型，这样才能做到在编译器的重载，如果要新增一类数据类型，Extractor或者Visitor接口必须对新增数据类型的ResourceFile增加visit重载，这个有没有优化方案呢","like_count":0},{"had_liked":false,"id":208914,"user_name":"Jessica","can_delete":false,"product_type":"c1","uid":1084877,"ip_address":"","ucode":"9FC7E9BD3FE9F1","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/cd/b6bdc1b2.jpg","comment_is_top":false,"comment_ctime":1587464171,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587464171","product_id":100039001,"comment_content":"使用模板方法模式，将公共的部分定义在公共类中，比如，extractFromPDFToTxt可以分为两步，第一步是从PDF中读取文本，第二步是写入到txt，因此可以把公共的写入到txt这部分代码抽取到模板方法类中。同理，如果再来压缩等需求场景，可以将公共部分放在模板方法类中，不同的部分放在各自的实现类中。","like_count":0},{"had_liked":false,"id":207659,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1587130612,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1587130612","product_id":100039001,"comment_content":"看了以后，和策略模式差不多","like_count":0},{"had_liked":false,"id":207108,"user_name":"李稳","can_delete":false,"product_type":"c1","uid":1401912,"ip_address":"","ucode":"B8164B6B65E26C","user_header":"https://static001.geekbang.org/account/avatar/00/15/64/38/1bd1324e.jpg","comment_is_top":false,"comment_ctime":1587007447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587007447","product_id":100039001,"comment_content":"ppt,word,pdf多种文档，压缩，抽取文本等多个操作，2种多态形式，所以要定义2个接口，相互关系需有一方需要注入令一方，此处为操作通过参数注入到文档中，操作使用重载定义具体的文档操作","like_count":0},{"had_liked":false,"id":206289,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1586835245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586835245","product_id":100039001,"comment_content":"是我见过关于访问者讲解最好的一篇","like_count":0},{"had_liked":false,"id":204669,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1586439917,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1586439917","product_id":100039001,"comment_content":"课堂讨论: <br>使用策略+静态工厂可以实现需求. <br>访问者模式为一组对象执行同一操作, 很容易想到每种对象对应一种操作策略.<br><br>       ResourceFile pdf = new PdfFile();<br>        ResourceFile ppt = new PptFile();<br>        ResourceFile word = new WordFile();<br><br>        String s = ExtractStrategyFactory.create(pdf.getClass()).extractToTxt(pdf);<br><br>&#47;&#47;工厂实现<br>public class ExtractStrategyFactory {<br><br>    private ExtractStrategyFactory(){}<br><br>    private static Map&lt;Class&lt;? extends ResourceFile&gt;, ExtractStrategy&gt; map = new HashMap&lt;&gt;();<br>    static {<br>        map.put(PdfFile.class, new PdfExtractStrategy());<br>        map.put(PptFile.class, new PptExtractStrategy());<br>        map.put(WordFile.class, new WordExtractStrategy());<br>    }<br><br>    public static ExtractStrategy create(Class&lt;? extends ResourceFile&gt; clazz){<br>        return map.get(clazz);<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227579,"discussion_content":"实现是可以实现，但我觉得侧重点不一样。工厂模式还是关注对象本身的，访问者模式不care 对象，只要你们都需要这些操作就行，这些对象爱谁谁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586503364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1095857,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","nickname":"梦倚栏杆","note":"","ucode":"BDEB97F2822445","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":227677,"discussion_content":"实现需求主要是策略模式。静态工厂只是提供策略对象用。你的关注点应该放在一种对象对应一种extract策略上，而不是工厂上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586512164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":227579,"ip_address":""},"score":227677,"extra":""}]}]}]}