{"id":415098,"title":"07｜所有权：值的生杀大权到底在谁手上？","content":"<p>你好，我是陈天。</p><p>完成了上周的“get hands dirty”挑战，相信你对 Rust 的魅力已经有了感性的认知，是不是开始信心爆棚地尝试写小项目了。</p><p>但当你写的代码变多，编译器似乎开始和自己作对了，一些感觉没有问题的代码，编译器却总是莫名其妙报错。</p><p>那么从今天起我们重归理性，一起来研究 Rust 学习过程中最难啃的硬骨头：所有权和生命周期。为什么要从这个知识点开始呢？因为，<strong>所有权和生命周期是 Rust 和其它编程语言的主要区别，也是 Rust 其它知识点的基础</strong>。</p><p>很多 Rust 初学者在这个地方没弄明白，一知半解地继续学习，结果越学越吃力，最后在实际上手写代码的时候就容易栽跟头，编译总是报错，丧失了对 Rust 的信心。</p><p>其实所有权和生命周期之所以这么难学明白，除了其与众不同的解决内存安全问题的角度外，另一个很大的原因是，目前的资料对初学者都不友好，上来就讲 Copy / Move 语义怎么用，而没有讲明白<strong>为什么要这样用</strong>。</p><p>所以这一讲我们换个思路，从一个变量使用堆栈的行为开始，探究 Rust 设计所有权和生命周期的用意，帮你从根上解决这些编译问题。</p><h2>变量在函数调用时发生了什么</h2><p>首先，我们来看一看，在我们熟悉的大多数编程语言中，变量在函数调用时究竟会发生什么、存在什么问题。</p><!-- [[[read_end]]] --><p>看这段代码，main() 函数中定义了一个动态数组 data 和一个值 v，然后将其传递给函数 find_pos，在 data 中查找 v 是否存在，存在则返回 v 在 data 中的下标，不存在返回 None（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b8ab613d39f4ab0a771c1186c04a8220\">代码1</a>）：</p><pre><code class=\"language-rust\">fn main() {\n&nbsp; &nbsp; let data = vec![10, 42, 9, 8];\n&nbsp; &nbsp; let v = 42;\n&nbsp; &nbsp; if let Some(pos) = find_pos(data, v) {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"Found {} at {}\", v, pos);\n&nbsp; &nbsp; }\n}\n\nfn find_pos(data: Vec&lt;u32&gt;, v: u32) -&gt; Option&lt;usize&gt; {\n&nbsp; &nbsp; for (pos, item) in data.iter().enumerate() {\n&nbsp; &nbsp; &nbsp; &nbsp; if *item == v {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Some(pos);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; None\n}\n</code></pre><p>这段代码不难理解，要再强调一下的是，<strong>动态数组因为大小在编译期无法确定，所以放在堆上，并且在栈上有一个包含了长度和容量的胖指针指向堆上的内存</strong>。</p><p>在调用 find_pos() 时，main() 函数中的局部变量 data 和 v 作为参数传递给了 find_pos()，所以它们会被放在 find_pos() 的参数区。</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/2f/f0989fa8611db83b79500060e8cd682f.jpg?wh=2312x2043\" alt=\"\"></p><p>按照大多数编程语言的做法，现在堆上的内存就有了两个引用。不光如此，我们每把 data 作为参数传递一次，堆上的内存就会多一次引用。</p><p>但是，这些引用究竟会做什么操作，我们不得而知，也无从限制；而且堆上的内存究竟什么时候能释放，尤其在多个调用栈引用时，很难厘清，取决于最后一个引用什么时候结束。所以，这样一个看似简单的函数调用，给内存管理带来了极大麻烦。</p><p>对于堆内存多次引用的问题，我们先来看大多数语言的方案：</p><ul>\n<li><strong>C/C++ 要求开发者手工处理</strong>，非常不便。这需要我们在写代码时高度自律，按照前人总结的最佳实践来操作。但人必然会犯错，一个不慎就会导致内存安全问题，要么内存泄露，要么使用已释放内存，导致程序崩溃。</li>\n<li><strong>Java 等语言使用追踪式 GC</strong>，通过定期扫描堆上数据还有没有人引用，来替开发者管理堆内存，不失为一种解决之道，但 GC 带来的 STW 问题让语言的使用场景受限，性能损耗也不小。</li>\n<li><strong>ObjC/Swift 使用自动引用计数（ARC）</strong>，在编译时自动添加维护引用计数的代码，减轻开发者维护堆内存的负担。但同样地，它也会有不小的运行时性能损耗。</li>\n</ul><p>现存方案都是从管理引用的角度思考的，有各自的弊端。我们回顾刚才梳理的函数调用过程，从源头上看，本质问题是堆上内存会被随意引用，那么换个角度，我们是不是可以限制引用行为本身呢？</p><h2>Rust 的解决思路</h2><p>这个想法打开了新的大门，Rust就是这样另辟蹊径的。</p><p>在 Rust 以前，引用是一种随意的、可以隐式产生的、对权限没有界定的行为，比如 C 里到处乱飞的指针、Java 中随处可见的按引用传参，它们可读可写，权限极大。而 Rust 决定限制开发者随意引用的行为。</p><p>其实作为开发者，我们在工作中常常能体会到：<strong>恰到好处的限制，反而会释放无穷的创意和生产力</strong>。最典型的就是各种开发框架，比如 React、Ruby on Rails 等，他们限制了开发者使用语言的行为，却极大地提升了生产力。</p><p>好，思路我们已经有了，具体怎么实现来限制数据的引用行为呢？</p><p>要回答这个问题，我们需要先来回答：谁真正拥有数据或者说值的生杀大权，这种权利可以共享还是需要独占？</p><h3>所有权和 Move 语义</h3><p>照旧我们先尝试回答一下，对于值的生杀大权可以共享还是需要独占这一问题，我们大概都会觉得，一个值最好只有一个拥有者，因为所有权共享，势必会带来使用和释放上的不明确，走回 追踪式 GC 或者 ARC 的老路。</p><p>那么如何保证独占呢？具体实现其实是有些困难的，因为太多情况需要考虑。比如说一个变量被赋给另一个变量、作为参数传给另一个函数，或者作为返回值从函数返回，都可能造成这个变量的拥有者不唯一。怎么办？</p><p>对此，Rust 给出了如下规则：</p><ul>\n<li><strong>一个值只能被一个变量所拥有，这个变量被称为所有者</strong>（Each value in Rust has a variable that’s called its&nbsp;<em>owner</em>）。</li>\n<li><strong>一个值同一时刻只能有一个所有者</strong>（There can only be one owner at a time），也就是说不能有两个变量拥有相同的值。所以对应刚才说的变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，以便保证单一所有者的约束。</li>\n<li><strong>当所有者离开作用域，其拥有的值被丢弃</strong>（When the owner goes out of scope, the value will be dropped），内存得到释放。</li>\n</ul><p>这三条规则很好理解，核心就是保证单一所有权。其中第二条规则讲的所有权转移是 Move 语义，Rust 从 C++ 那里学习和借鉴了这个概念。</p><p>第三条规则中的作用域（scope）是一个新概念，我简单说明一下，它指一个代码块（block），在 Rust 中，一对花括号括起来的代码区就是一个作用域。举个例子，如果一个变量被定义在 if {} 内，那么 if 语句结束，这个变量的作用域就结束了，其值会被丢弃；同样的，函数里定义的变量，在离开函数时会被丢弃。</p><p>在这三条所有权规则的约束下，我们看开头的引用问题是如何解决的：<br>\n<img src=\"https://static001.geekbang.org/resource/image/fe/64/fe810cf1616bce15f53bcf6d28d7f864.jpg?wh=2312x2043\" alt=\"\"></p><p>原先 main() 函数中的 data，被移动到 find_pos() 后，就失效了，编译器会保证 main() 函数随后的代码无法访问这个变量，这样，就确保了堆上的内存依旧只有唯一的引用。</p><p>看这个图，你可能会有一个小小的疑问：main() 函数传递给 find_pos() 函数的另一个参数 v，也会被移动吧？为什么图上并没有标灰？咱们暂且将这个疑问放到一边，等这一讲学完，相信你会有答案的。</p><p>现在，我们来写段代码加深一下对所有权的理解。</p><p>在这段代码里，先创建了一个不可变数据 data，然后将 data 赋值给 data1。按照所有权的规则，赋值之后，data 指向的值被移动给了 data1，它自己便不可访问了。而随后，data1 作为参数被传给函数 sum()，在 main() 函数下，data1 也不可访问了。</p><p>但是后续的代码依旧试图访问 data1 和 data，所以，这段代码应该会有两处错误（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=3d76a275e808fac6fcc88e21e0a0a05b\">代码2</a>）：</p><pre><code class=\"language-rust\">fn main() {\n    let data = vec![1, 2, 3, 4];\n    let data1 = data;\n    println!(\"sum of data1: {}\", sum(data1));\n    println!(\"data1: {:?}\", data1); // error1\n    println!(\"sum of data: {}\", sum(data)); // error2\n}\n\nfn sum(data: Vec&lt;u32&gt;) -&gt; u32 {\n    data.iter().fold(0, |acc, x| acc + x)\n}\n</code></pre><p>运行时，编译器也确实捕获到了这两个错误，并清楚地告诉我们不能使用已经移动过的变量：</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/63/cc9ddbd4cd564f5488a628003effe563.png?wh=2350x994\" alt=\"\"></p><p>如果我们要在把 data1 传给 sum()，同时，还想让 main() 能够访问 data，该怎么办？</p><p>我们可以调用  <code>data.clone()</code> 把 data 复制一份出来给 data1，这样，在堆上就有  <code>vec![1,2,3,4]</code> 两个互不影响且可以独立释放的副本，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/14/a8/146a7f841faa498af7e2ec320e65c1a8.jpg?wh=2312x2043\" alt=\"\"></p><p>可以看到，<strong>所有权规则，解决了谁真正拥有数据的生杀大权问题，让堆上数据的多重引用不复存在，这是它最大的优势</strong>。</p><p>但是，这也会让代码变复杂，尤其是一些只存储在栈上的简单数据，如果要避免所有权转移之后不能访问的情况，我们就需要手动复制，会非常麻烦，效率也不高。</p><p>Rust 考虑到了这一点，提供了两种方案：</p><ol>\n<li>如果你不希望值的所有权被转移，在 Move 语义外，Rust 提供了 <strong>Copy 语义</strong>。如果一个数据结构实现了 <a href=\"https://doc.rust-lang.org/std/marker/trait.Copy.html\">Copy trait</a>，那么它就会使用 Copy 语义。这样，在你赋值或者传参时，值会自动按位拷贝（浅拷贝）。</li>\n<li>如果你不希望值的所有权被转移，又无法使用 Copy 语义，那你可以<strong>“借用”数据</strong>，我们下一讲会详细讨论“借用”。</li>\n</ol><p>我们先看今天要讲的第一种方案：Copy 语义。</p><h3>Copy 语义和 Copy trait</h3><p>符合 Copy 语义的类型，<strong>在你赋值或者传参时，值会自动按位拷贝</strong>。这句话不难理解，那在Rust中是具体怎么实现的呢？</p><p>我们再仔细看看刚才代码编译器给出的错误，你会发现，它抱怨 data 的类型 <code>Vec&lt;u32&gt;</code>没有实现 Copy trait，在赋值或者函数调用的时候无法 Copy，于是就按默认使用 Move 语义。而 Move 之后，原先的变量 data 无法访问，所以出错。</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/12/1a4decf636f175b4736aa8d8yy898712.png?wh=2350x476\" alt=\"\"></p><p>换句话说，当你要移动一个值，如果值的类型实现了 Copy trait，就会自动使用 Copy 语义进行拷贝，否则使用 Move 语义进行移动。</p><p>讲到这里，我插一句，在学习 Rust 的时候，你可以根据编译器详细的错误说明来尝试修改代码，使编译通过，在这个过程中，你可以用 Stack Overflow 搜索错误信息，进一步学习自己不了解的知识点。我也非常建议你根据上图中的错误代码 E0382 使用 <code>rustc --explain E0382</code>  探索更详细的信息。</p><p>好，回归正文，那在 Rust 中，什么数据结构实现了 Copy trait 呢？ 你可以通过下面的代码快速验证一个数据结构是否实现了 Copy trait（<a href=\"https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=457cc3107aea384268dcd4db7406351c\">验证代码</a>）：</p><pre><code class=\"language-rust\">fn is_copy&lt;T: Copy&gt;() {}\n\nfn types_impl_copy_trait() {\n&nbsp; &nbsp; is_copy::&lt;bool&gt;();\n&nbsp; &nbsp; is_copy::&lt;char&gt;();\n\n&nbsp; &nbsp; // all iXX and uXX, usize/isize, fXX implement Copy trait\n&nbsp; &nbsp; is_copy::&lt;i8&gt;();\n&nbsp; &nbsp; is_copy::&lt;u64&gt;();\n&nbsp; &nbsp; is_copy::&lt;i64&gt;();\n&nbsp; &nbsp; is_copy::&lt;usize&gt;();\n\n&nbsp; &nbsp; // function (actually a pointer) is Copy\n&nbsp; &nbsp; is_copy::&lt;fn()&gt;();\n\n&nbsp; &nbsp; // raw pointer is Copy\n&nbsp; &nbsp; is_copy::&lt;*const String&gt;();\n&nbsp; &nbsp; is_copy::&lt;*mut String&gt;();\n\n&nbsp; &nbsp; // immutable reference is Copy\n&nbsp; &nbsp; is_copy::&lt;&amp;[Vec&lt;u8&gt;]&gt;();\n&nbsp; &nbsp; is_copy::&lt;&amp;String&gt;();\n\n&nbsp; &nbsp; // array/tuple with values which is Copy is Copy\n&nbsp; &nbsp; is_copy::&lt;[u8; 4]&gt;();\n&nbsp; &nbsp; is_copy::&lt;(&amp;str, &amp;str)&gt;();\n}\n\nfn types_not_impl_copy_trait() {\n&nbsp; &nbsp; // unsized or dynamic sized type is not Copy\n&nbsp; &nbsp; is_copy::&lt;str&gt;();\n&nbsp; &nbsp; is_copy::&lt;[u8]&gt;();\n&nbsp; &nbsp; is_copy::&lt;Vec&lt;u8&gt;&gt;();\n&nbsp; &nbsp; is_copy::&lt;String&gt;();\n\n&nbsp; &nbsp; // mutable reference is not Copy\n&nbsp; &nbsp; is_copy::&lt;&amp;mut String&gt;();\n\n&nbsp; &nbsp; // array / tuple with values that not Copy is not Copy\n&nbsp; &nbsp; is_copy::&lt;[Vec&lt;u8&gt;; 4]&gt;();\n&nbsp; &nbsp; is_copy::&lt;(String, u32)&gt;();\n}\n\nfn main() {\n&nbsp; &nbsp; types_impl_copy_trait();\n&nbsp; &nbsp; types_not_impl_copy_trait();\n}\n</code></pre><p>推荐你动手运行这段代码，并仔细阅读编译器错误，加深印象。我也总结一下：</p><ul>\n<li>原生类型，包括函数、不可变引用和裸指针实现了 Copy；</li>\n<li>数组和元组，如果其内部的数据结构实现了 Copy，那么它们也实现了 Copy；</li>\n<li>可变引用没有实现 Copy；</li>\n<li>非固定大小的数据结构，没有实现 Copy。</li>\n</ul><p>另外，<a href=\"https://doc.rust-lang.org/std/marker/trait.Copy.html\">官方文档介绍 Copy trait 的页面</a>包含了 Rust 标准库中实现 Copy trait 的所有数据结构。你也可以在访问某个数据结构的时候，查看其文档的 Trait implementation 部分，看看它是否实现了 Copy trait。</p><p><img src=\"https://static001.geekbang.org/resource/image/98/c6/987d21d5338731ee25e72yyb33c3a9c6.png?wh=2464x1696\" alt=\"\"></p><h2>小结</h2><p>今天我们学习了 Rust 的单一所有权模式、Move 语义、Copy 语义，我整理一下关键信息，方便你再回顾一遍。</p><ul>\n<li>所有权：一个值只能被一个变量所拥有，且同一时刻只能有一个所有者，当所有者离开作用域，其拥有的值被丢弃，内存得到释放。</li>\n<li>Move 语义：赋值或者传参会导致值 Move，所有权被转移，一旦所有权转移，之前的变量就不能访问。</li>\n<li>Copy 语义：如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝（浅拷贝），产生新的值。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/7e/25/7ee571a984818fb8da358096c8391b25.jpg?wh=4507x2786\" alt=\"\"></p><p>通过单一所有权模式，Rust 解决了堆内存过于灵活、不容易安全高效地释放的问题，不过所有权模型也引入了很多新的概念，比如今天讲的 Move / Copy 语义。</p><p>由于是全新的概念，我们学习起来有一定的难度，但是你只要抓住了核心点：<strong>Rust 通过单一所有权来限制任意引用的行为</strong>，就不难理解这些新概念背后的设计意义。</p><p>下一讲我们会继续学习Rust的所有权和生命周期，在不希望值的所有权被转移，又无法使用 Copy 语义的情况下，如何“借用”数据……</p><h2>思考题</h2><p>今天的思考题有两道，第一道题巩固学习收获。另外第二道题如果你还记得，在文中，我提出了一个小问题，让你暂时搁置，今天学完之后就有答案了，现在你有想法了吗？欢迎留言分享出来，我们一起讨论。</p><ol>\n<li>在 Rust 下，分配在堆上的数据结构可以引用栈上的数据么？为什么？</li>\n<li>main() 函数传递给 find_pos() 函数的另一个参数 v，也会被移动吧？为什么图上并没有将其标灰？</li>\n</ol><p>欢迎在留言区分享你的思考。今天是你 Rust 学习的第七次打卡，感谢你的收听，如果你觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。</p><h2>参考资料</h2><p>trait 是 Rust 用于定义数据结构行为的接口。如果一个数据结构实现了 Copy trait，那么它在赋值、函数调用以及函数返回时会执行 Copy 语义，值会被按位拷贝一份（浅拷贝），而非移动。你可以看关于 <a href=\"https://doc.rust-lang.org/std/marker/trait.Copy.html\">Copy trait</a> 的资料。</p>","comments":[{"had_liked":false,"id":310761,"user_name":"赵岩松","can_delete":false,"product_type":"c1","uid":2032451,"ip_address":"","ucode":"596694E4360482","user_header":"https://static001.geekbang.org/account/avatar/00/1f/03/43/ed0dcb27.jpg","comment_is_top":false,"comment_ctime":1630896953,"is_pvip":false,"replies":[{"id":"112600","content":"理解地非常透彻！<br><br>的确如此，Rust 就是这样从最根本的问题出发来解决它。所有权是第一步，借用和生命周期是第二步。:)","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630905978,"ip_address":"","comment_id":310761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"444012528441","product_id":100085301,"comment_content":"第一题：可以<br>只要栈上的数据生命周期大于堆上数据的生命周期就可以<br>简单来说就是在堆上数据被回收之前栈上的数据一定会存在的情况下，是可以的<br>```<br>let x = 1;<br>let y = 2;<br>let v = vec![&amp;x, &amp;y];<br>println!(&quot;{:?}&quot;, v);<br>```<br><br>第二题：因为其为基本数据类型，实现了Copy trit<br>在find_pos()的栈帧中，第二个参数栈上保存的是0x0000_002A并不是main()中v所在的栈地址，没有所有权的转移(Copy trit)<br>也就是说find_pos()函数中无论怎么改变入参v的值，在find_pos()函数结束的时候也不会导致main()中v值的回收，故main()中v的值是不会改变的，是安全的<br><br>在这里说一下我对所有权的理解<br>首先，接触Rust之后我发现Rust里的新名词虽然很多，但是如果抛开名词本身转而去思考程序运行过程中的堆栈分析就可以比较快速的理解<br>首先来关注所有权规则的最后一点：当所有者离开作用域，其拥有的值被丢弃，&quot;内存得到释放&quot;<br>最后一点表明了提出所有权这个概念要做的事情，就是为了内存回收<br>那么在单一所有权的限制下，如何理解内存分配呢？<br>在这里我暂且用 x -&gt; a 表示指针x指向数据a<br>在其他语言中，内存中可以出现如下的情况  x -&gt; a; y -&gt; a; z -&gt; a; ...<br>但是在Rust中，假设最初为 x -&gt; a; 当我们接下来需要 y -&gt; a 时，我们可以认为x不会被使用了，也就是 x -&gt; a 这个引用在&quot;我的理解上&quot;就已经断了(所有权转移)<br>在执行过程中被引用的数据只会有一个&quot;有效的&quot;指针指向它(所有权唯一)<br><br>那么来看第一题，问的是堆上数据是否可以引用栈上的数据，我选择抛开堆栈不谈，因为不管分配到堆栈上都是分配到了内存上<br>在所有权机制的限制之下，可不可以引用这个问题其实就变成了如何避免悬垂引用，那么如何避免呢？使用生命周期(老师在抛砖引玉xdm)","like_count":103,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526343,"discussion_content":"理解地非常透彻！\n\n的确如此，Rust 就是这样从最根本的问题出发来解决它。所有权是第一步，借用和生命周期是第二步。:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630905978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314474,"user_name":"dotfiles","can_delete":false,"product_type":"c1","uid":1217723,"ip_address":"","ucode":"F915599EC2F6E5","user_header":"https://static001.geekbang.org/account/avatar/00/12/94/bb/1c8384a0.jpg","comment_is_top":false,"comment_ctime":1633099914,"is_pvip":false,"replies":[{"id":"113972","content":"非常好！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633320406,"ip_address":"","comment_id":314474,"utype":1}],"discussion_count":3,"race_medal":0,"score":"156251922570","product_id":100085301,"comment_content":"常见的内存安全问题: 内存泄漏(非内存安全问题) , 堆栈溢出(迭代器&#47;运行时检查), 重复释放, 悬垂指针;<br>所有权先解决重复释放的问题.<br>rust中,为了处理内存管理问题,要求每个内存对象(无论堆上或者栈上)仅有一个所有者,也就是所有权.<br>当所有者超出其作用域时,其管理的内存对象将会被释放, 这里分两种: 栈上内存由编译器自动管理,无需额外释放. 堆上内存会调用内存对象的Drop Trait. 这里就保证了不会发生重复释放.<br>rust中为了保证一块内存仅有一个所有者, 在所有权转移时(赋值，函数调用，函数返回)默认使用move语义, 也就是转移对象所有权. 除非对象实现了copy语义,那么会优先使用copy语义.<br>copy语义的作用类似于浅拷贝,仅拷贝栈上的内存.如基础类型, 裸指针,组合类型(其成员全部实现copy语义), 引用等.此时还是一块内存仅有一个所有者,只是内存被复制了一份. 因为栈上通常内存不大,那么此时发生了消耗较少的拷贝.<br>在rust语言机制上,不允许copy trait和drop trait同时实现,因为允许copy的,都在栈上. 栈上的内存管理是不需要开发者操心的,只有堆上的内存需要, 类似于C++的析构函数.<br>在rust语言机制上,clone trait是copy trait的supertait,也就是基类. copy trait的调用是由编译器默认调用的, 而clone trait则是开发者通过clone方法调用的.在了解了copy语义的作用后,clone语义也比较好理解,基本就是深拷贝了.那么深拷贝后的堆内存,通常也需要实现Drop Trait以保证内存不泄漏. clone相较栈消耗要大得多,因此为了避免拷贝,就引入了*borrow*的概念,类似C++的引用. 但引用又会带来悬垂指针的问题,这就需要通过*生命周期*来解决.<br>以上就是目前对所有权的理解. ","like_count":36,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527692,"discussion_content":"非常好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633320406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1642586,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/5a/3411221e.jpg","nickname":"Heidi","note":"","ucode":"2751FD284068AA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":589991,"discussion_content":"为啥不指出错误，里面几个观点容易误导人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665451484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":527692,"ip_address":"上海"},"score":589991,"extra":""},{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":1642586,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/5a/3411221e.jpg","nickname":"Heidi","note":"","ucode":"2751FD284068AA","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":590145,"discussion_content":"留言区的讨论比较开放，你如果认为有啥问题，可以具体留言，和这位同学以及老师一起展开讨论","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665556015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":589991,"ip_address":"北京"},"score":590145,"extra":""}]}]},{"had_liked":false,"id":310736,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1630889152,"is_pvip":false,"replies":[{"id":"112592","content":"对。不过实现 Copy 并不会影响程序的正确性。不会出现拷贝可能会被释放的内存的指针的问题。<br><br>Rust 在设计时就已经保证了你无法为一个在堆上分配内存的结构实现 Copy。所以 Vec &#47; String 等结构是不能实现 Copy 的。因为这条路已经被堵死了：Copy trait 和 Drop trait 不能共存。一旦你实现了 Copy trait，就无法实现 Drop trait。反之亦然。<br><br>有同学看到裸指针 *const T&#47; *mut T 实现了 Copy，就会想如果我用 unsafe 把 Vec&lt;T&gt; 的指针取出来，组成一个数据结构，到处 Copy，然后其中一个 drop 后，岂不就造成 use after free，破坏了 Rust 的安全性保证？很遗憾，Rust 并不允许你这么做。因为你无法实现 Drop。<br><br>我写了一段代码，感兴趣的同学可以看一下：<br><br>https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4828e734f6f161dfce32098333a1aaa5<br><br>```rust<br>use std::{fmt, slice};<br><br>#[derive(Clone, Copy)]<br>struct RawBuffer {<br>    ptr: *mut u8,<br>    len: usize,<br>}<br><br>impl From&lt;Vec&lt;u8&gt;&gt; for RawBuffer {<br>    fn from(vec: Vec&lt;u8&gt;) -&gt; Self {<br>        let slice = vec.into_boxed_slice();<br>        Self {<br>            len: slice.len(),<br>            &#47;&#47; into_raw 之后，Box 就不管这块内存的释放了，RawBuffer 需要处理<br>            ptr: Box::into_raw(slice) as *mut u8,<br>        }<br>    }<br>}<br><br>&#47;&#47; 如果 RawBuffer 实现了 Drop trait，就可以在所有者退出时释放堆内存<br>&#47;&#47; 然后，Drop trait 会跟 Copy trait 冲突，要么不实现 Copy，要么不实现 Drop<br>&#47;&#47; 如果不实现 Drop，那么就会导致内存泄漏，但它不会对正确性有任何破坏<br>&#47;&#47; 比如不会出现 use after free 这样的问题。<br>&#47;&#47; 你可以试着把下面注释掉，看看会出什么问题<br>&#47;&#47; impl Drop for RawBuffer {<br>&#47;&#47;     #[inline]<br>&#47;&#47;     fn drop(&amp;mut self) {<br>&#47;&#47;         let data = unsafe { Box::from_raw(slice::from_raw_parts_mut(self.ptr, self.len)) };<br>&#47;&#47;         drop(data)<br>&#47;&#47;     }<br>&#47;&#47; }<br><br>impl fmt::Debug for RawBuffer {<br>    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;&#39;_&gt;) -&gt; fmt::Result {<br>        let data = self.as_ref();<br>        write!(f, &quot;{:p}: {:?}&quot;, self.ptr, data)<br>    }<br>}<br><br>impl AsRef&lt;[u8]&gt; for RawBuffer {<br>    fn as_ref(&amp;self) -&gt; &amp;[u8] {<br>        unsafe { slice::from_raw_parts(self.ptr, self.len) }<br>    }<br>}<br><br>fn main() {<br>    let data = vec![1, 2, 3, 4];<br><br>    let buf: RawBuffer = data.into();<br><br>    &#47;&#47; 因为 buf 允许 Copy，所以这里 Copy 了一份<br>    use_buffer(buf);<br><br>    &#47;&#47; buf 还能用<br>    println!(&quot;buf: {:?}&quot;, buf);<br>}<br><br>fn use_buffer(buf: RawBuffer) {<br>    println!(&quot;buf to die: {:?}&quot;, buf);<br><br>    &#47;&#47; 这里不用特意 drop，写出来只是为了说明 Copy 出来的 buf 被 Drop 了<br>    drop(buf)<br>}<br>```","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630904711,"ip_address":"","comment_id":310736,"utype":1}],"discussion_count":7,"race_medal":0,"score":"113300038848","product_id":100085301,"comment_content":"另外对按位复制补充一点：<br><br>按位复制，等同于 C 语言里的 memcpy。<br><br>C 语言中的 memcpy 会从源所指的内存地址的起始位置开始拷贝 n 个字节，直到目标所指的内存地址的结束位置。但如果要拷贝的数据中包含指针，该函数并*不会*连同指针指向的数据一起拷贝。<br><br>因此如果是不包含指针的原生类型，那么按位复制(浅拷贝)等同于 clone，可如果是 Vec 这种在堆上开辟，在栈上存储胖指针的数据就不一样了，因为按位复制会拷贝胖指针本身，而其指向的堆中数据则不会拷贝，因此堆上的数据仍然只有一份。<br><br>最后，最好不用去实现 Copy。","like_count":27,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526329,"discussion_content":"对。不过实现 Copy 并不会影响程序的正确性。不会出现拷贝可能会被释放的内存的指针的问题。\n\nRust 在设计时就已经保证了你无法为一个在堆上分配内存的结构实现 Copy。所以 Vec / String 等结构是不能实现 Copy 的。因为这条路已经被堵死了：Copy trait 和 Drop trait 不能共存。一旦你实现了 Copy trait，就无法实现 Drop trait。反之亦然。\n\n有同学看到裸指针 *const T/ *mut T 实现了 Copy，就会想如果我用 unsafe 把 Vec&amp;lt;T&amp;gt; 的指针取出来，组成一个数据结构，到处 Copy，然后其中一个 drop 后，岂不就造成 use after free，破坏了 Rust 的安全性保证？很遗憾，Rust 并不允许你这么做。因为你无法实现 Drop。\n\n我写了一段代码，感兴趣的同学可以看一下：\n\nhttps://play.rust-lang.org/?version=stable&amp;amp;mode=debug&amp;amp;edition=2018&amp;amp;gist=4828e734f6f161dfce32098333a1aaa5\n\n```rust\nuse std::{fmt, slice};\n\n#[derive(Clone, Copy)]\nstruct RawBuffer {\n    ptr: *mut u8,\n    len: usize,\n}\n\nimpl From&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt; for RawBuffer {\n    fn from(vec: Vec&amp;lt;u8&amp;gt;) -&amp;gt; Self {\n        let slice = vec.into_boxed_slice();\n        Self {\n            len: slice.len(),\n            // into_raw 之后，Box 就不管这块内存的释放了，RawBuffer 需要处理\n            ptr: Box::into_raw(slice) as *mut u8,\n        }\n    }\n}\n\n// 如果 RawBuffer 实现了 Drop trait，就可以在所有者退出时释放堆内存\n// 然后，Drop trait 会跟 Copy trait 冲突，要么不实现 Copy，要么不实现 Drop\n// 如果不实现 Drop，那么就会导致内存泄漏，但它不会对正确性有任何破坏\n// 比如不会出现 use after free 这样的问题。\n// 你可以试着把下面注释掉，看看会出什么问题\n// impl Drop for RawBuffer {\n//     #[inline]\n//     fn drop(&amp;amp;mut self) {\n//         let data = unsafe { Box::from_raw(slice::from_raw_parts_mut(self.ptr, self.len)) };\n//         drop(data)\n//     }\n// }\n\nimpl fmt::Debug for RawBuffer {\n    fn fmt(&amp;amp;self, f: &amp;amp;mut fmt::Formatter&amp;lt;&amp;#39;_&amp;gt;) -&amp;gt; fmt::Result {\n        let data = self.as_ref();\n        write!(f, &amp;quot;{:p}: {:?}&amp;quot;, self.ptr, data)\n    }\n}\n\nimpl AsRef&amp;lt;[u8]&amp;gt; for RawBuffer {\n    fn as_ref(&amp;amp;self) -&amp;gt; &amp;amp;[u8] {\n       ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630904711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2254917,"avatar":"https://static001.geekbang.org/account/avatar/00/22/68/45/ddf89612.jpg","nickname":"bestgopher","note":"","ucode":"D89735C8CA9C6E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574545,"discussion_content":"这个代码会有内存泄漏吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654138485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2739803,"avatar":"","nickname":"Ryan","note":"","ucode":"026C66ED684E00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392325,"discussion_content":"这样解释对c背景的人来说还是有点懵的。c里面用memcpy一般都是为了复制堆上的数据，而不是拿来复制个指针。所以我理解clone才更像c中使用memcpy的场景。而copy语意对应到c中更像是等号的能力。所以c中当你意识到要用指针了，就是rust中要考虑是要move，还是clone，还是借用了。不知道我理解的对不对？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630949750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2739803,"avatar":"","nickname":"Ryan","note":"","ucode":"026C66ED684E00","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392388,"discussion_content":"memcpy 不是为了复制堆上的数据，而是复制一段内存，和内存在哪无关。memcpy是按位复制，不会管copy的内存上是否有指针，所以它是浅拷贝。clone 是深拷贝，不是memcpy","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630989320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":392325,"ip_address":""},"score":392388,"extra":""},{"author":{"id":2739803,"avatar":"","nickname":"Ryan","note":"","ucode":"026C66ED684E00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":392544,"discussion_content":"具体行为是这样，到使用模型的对应上我觉得存在一个错位。c程序中通常传递一个指针用等号就可以了，没必要取了地址再去用memcpy。而当想复制指针指向的数据时才会用memcpy。这种用法中，复制指针更像是浅拷贝，而调用memcpy完成了深拷贝，只不过找到指针指向的数据这件事不是由一个自动化的clone完成的，而是程序员来做的。rust所构建的语意模型在c程序员的脑中也有类似的一套东西，我所关心的是这种习惯与语意的对应。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631033015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":392388,"ip_address":""},"score":392544,"extra":""}]},{"author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392267,"discussion_content":"buf不用之后需要手动调用类似drop方法释放堆？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630929434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1133945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4d/79/803537db.jpg","nickname":"慢动作","note":"","ucode":"62C944F4A4D8AC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":392320,"discussion_content":"drop会自动调用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630945692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":392267,"ip_address":""},"score":392320,"extra":""}]}]},{"had_liked":false,"id":310862,"user_name":"苏苏","can_delete":false,"product_type":"c1","uid":2038353,"ip_address":"","ucode":"35A4EC6F75D453","user_header":"https://static001.geekbang.org/account/avatar/00/1f/1a/51/ac2d80fc.jpg","comment_is_top":false,"comment_ctime":1630937799,"is_pvip":true,"replies":[{"id":"112655","content":"第一周介绍为啥要学 Rust（why），上周的课让大家领略 Rust 能干啥（what），下面要解决怎么干（how）。:)","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630951162,"ip_address":"","comment_id":310862,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48875578055","product_id":100085301,"comment_content":"前两节课只是跑起来代码能运行感觉知识点大而懵， 但是像这节课这样干货比较多的，细节点讲的清清楚楚的就很喜欢。","like_count":11,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526379,"discussion_content":"第一周介绍为啥要学 Rust（why），上周的课让大家领略 Rust 能干啥（what），下面要解决怎么干（how）。:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630951162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310729,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1630884846,"is_pvip":false,"replies":[{"id":"112594","content":"1 &#47; 2 完全正确。<br><br>&gt; 其它主流语言默认都是 copy<br><br>这里不完全正确。很多语言会根据类型决定是传值还是传引用。传值是 Copy，传引用不是 Copy，类似 Rust 的借用，但又不一样。我们后续会讲到。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630904994,"ip_address":"","comment_id":310729,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35990623214","product_id":100085301,"comment_content":"1，在 Rust 下，分配在堆上的数据结构可以引用栈上的数据么？为什么？<br><br>可以，以 Vec 为例，它可以存储栈上的引用，但必须注意一点那就是该引用的生命周期不能超过栈上数据的生命周期。<br><br>2，main() 函数传递给 find_pos() 函数的另一个参数 v，也会被移动吧？为什么图上并没有将其标灰？<br><br>很简单，i 是原生类型，默认实现了 Copy 语义，在传参时，默认不再是移动而是 copy。<br><br>提一下，rust 的参数传递是反直觉的，默认为 move 和不可变，而其它主流语言默认都是 copy 和可变的，想要达到一样效果，必须实现 Copy 以及加上 mut。<br><br>要充分记住这一点，这是 rust 安全的生命线。","like_count":8,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526326,"discussion_content":"1 / 2 完全正确。\n\n&amp;gt; 其它主流语言默认都是 copy\n\n这里不完全正确。很多语言会根据类型决定是传值还是传引用。传值是 Copy，传引用不是 Copy，类似 Rust 的借用，但又不一样。我们后续会讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630904994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310826,"user_name":"hughieyu","can_delete":false,"product_type":"c1","uid":1206690,"ip_address":"","ucode":"FC1A64B2BAB784","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/a2/c30ac459.jpg","comment_is_top":false,"comment_ctime":1630923806,"is_pvip":false,"replies":[{"id":"112644","content":"对的。堆内存成了像栈一样的受控内存，只不过栈内存是受栈帧控制，堆内存受其栈上的所有者控制。再回顾一下堆内存的使用场景：1. 存放栈无法处理的内存（过大，或者长度不定，或者需要动态增长），2. 在同一个调用栈中真正需要被多个数据结构共享 3. 在多个调用栈中共享 <br><br>Rust 通过单一所有权的限制，让第一种也是使用情况最多的场景能够很好地处理。对于后两种，需要开个小口子，这就是我们接下来要讲的内容。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630938897,"ip_address":"","comment_id":310826,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31695694878","product_id":100085301,"comment_content":"感觉Rust就是把多重引用下的堆内存回收问题转变成了单一所有权下的值的使用问题","like_count":7,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526369,"discussion_content":"对的。堆内存成了像栈一样的受控内存，只不过栈内存是受栈帧控制，堆内存受其栈上的所有者控制。再回顾一下堆内存的使用场景：1. 存放栈无法处理的内存（过大，或者长度不定，或者需要动态增长），2. 在同一个调用栈中真正需要被多个数据结构共享 3. 在多个调用栈中共享 \n\nRust 通过单一所有权的限制，让第一种也是使用情况最多的场景能够很好地处理。对于后两种，需要开个小口子，这就是我们接下来要讲的内容。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630938897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062808,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIf1t1D3ictrpgeFuIukNLUdicibnibk7GCO4KAv63ffNYbZPPibeTkhcKPpV7XCYpmaGGKsDKN2Miaephg/132","nickname":"脑洞太大补不上","note":"","ucode":"ABB5BA9AE6D50A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582222,"discussion_content":"总结精辟！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659322085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320380,"user_name":"Geek_d6f7c6","can_delete":false,"product_type":"c1","uid":2651704,"ip_address":"","ucode":"ECE3879B25E1FC","user_header":"","comment_is_top":false,"comment_ctime":1636285346,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"18816154530","product_id":100085301,"comment_content":"大多数人都说好，但是我感觉老师讲的一点都不好，如果真没有rust基础，我认为是听不懂的","like_count":4,"discussions":[{"author":{"id":1205508,"avatar":"https://static001.geekbang.org/account/avatar/00/12/65/04/fea2dcf9.jpg","nickname":"Romber","note":"","ucode":"3FB24B736FF7E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549782,"discussion_content":"课程名起的误导人了，这门课应该叫rust第一课（下）","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1644234376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1385204,"avatar":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","nickname":"核桃","note":"","ucode":"7AB05270CBCCCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531756,"discussion_content":"先看看其他东西慢慢辅助理解吧，老师讲的东西不只是rust那么简单吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637408535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2717752,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/7BHTwtkds7KiauXnt14QufBibuWqq77Un89upzgsEhUwyrv7aEzsm3sSsPq9T5o8gYVnUCMjTIKFiaSBiabnhKrN5A/132","nickname":"Geek_e180fd","note":"","ucode":"71E192ED4A6C5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413733,"discussion_content":"这个课程是有起点的，建议可以根据前面内容把rust的基础点过一遍，带着问题再回来看，我是看那个rust权威指南看了整整三个月，才觉得这个教程不错","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636551756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3177536,"avatar":"https://static001.geekbang.org/account/avatar/00/30/7c/40/c1d837b5.jpg","nickname":"康宝combo","note":"","ucode":"07672F87CA52AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587692,"discussion_content":"没有基础确实够呛。建议至少把Rust Book看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663224247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1184682,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIovFO0icqOWLYEsN7IOCJRA8H7IXZQmYIyJdpaIBIsC0aL9lOfm2SkGlGvg6ZFDFZeBCMZ1Dfibxow/132","nickname":"FreyZhi","note":"","ucode":"3D68D79EBA6E96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581405,"discussion_content":"上课之前是需要预习的 🤪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658757864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2992421,"avatar":"","nickname":"Rex Wang","note":"","ucode":"FB419F40A5BA65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571398,"discussion_content":"如果没有the book的学习经验和小项目的练手，很多内容确实不易理解--但也不至于“一点都不好”吧？除了具体的知识，老师分享了很多学习方法和面对实际问题探索、思考的方法。这些不至于没有rust基础也听不懂吧。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652193263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1160964,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b7/04/97267e91.jpg","nickname":"happy","note":"","ucode":"AE6949E59E9E94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557568,"discussion_content":"确实需要有点基础，或者看完一本书来听会比较有收获。比如the book","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647864261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2412264,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ce/e8/8b3126d0.jpg","nickname":"小奶精","note":"","ucode":"EB264B3ADC20AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556447,"discussion_content":"看完the book再来看老师的课才会觉得棒棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647361149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310735,"user_name":"blackonion","can_delete":false,"product_type":"c1","uid":1395426,"ip_address":"","ucode":"E34B3704CE9055","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/E5icvvKzlGRD5trSibYvs5ZrhAvOib1UhyZV7ftYJLw1Jna1FWxpHBFlvK130DqArFVdXHh92GVWvSkckqxlibZAbg/132","comment_is_top":false,"comment_ctime":1630888868,"is_pvip":false,"replies":[{"id":"112593","content":"并不是。Vec&lt;T&gt; 在编译时可以确定大小（24 字节），但它不能实现 Copy trait。任何有资源需要释放的数据结构，都无法实现 Copy trait。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630904839,"ip_address":"","comment_id":310735,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18810758052","product_id":100085301,"comment_content":"可以理解为是否实现copy trait主要看rust编译器能否在编译时就能确定所需大小吗？","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526328,"discussion_content":"并不是。Vec&amp;lt;T&amp;gt; 在编译时可以确定大小（24 字节），但它不能实现 Copy trait。任何有资源需要释放的数据结构，都无法实现 Copy trait。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630904839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312402,"user_name":"一期一会","can_delete":false,"product_type":"c1","uid":1043780,"ip_address":"","ucode":"1C44A6453F6381","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/44/2267a5a7.jpg","comment_is_top":false,"comment_ctime":1631786920,"is_pvip":true,"replies":[{"id":"113197","content":"👍 大部分应该可以","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631802310,"ip_address":"","comment_id":312402,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5926754216","product_id":100085301,"comment_content":"感觉学完所有权、生命周期的内容，就可以开始用rust刷leetcode了。之前抄的别的语言的实现代码，一直莫名其妙的报错，原来就是这块问题。","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526962,"discussion_content":"👍 大部分应该可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631802310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310780,"user_name":"老荀","can_delete":false,"product_type":"c1","uid":1214893,"ip_address":"","ucode":"C32E743518DECD","user_header":"https://static001.geekbang.org/account/avatar/00/12/89/ad/4efd929a.jpg","comment_is_top":false,"comment_ctime":1630903658,"is_pvip":true,"replies":[{"id":"112640","content":"哈，别急别急。让子弹飞一会 :)","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630938357,"ip_address":"","comment_id":310780,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5925870954","product_id":100085301,"comment_content":"催更…第一次学习像追剧一样","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526350,"discussion_content":"哈，别急别急。让子弹飞一会 :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630938357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310726,"user_name":"springXu","can_delete":false,"product_type":"c1","uid":2064750,"ip_address":"","ucode":"F5DB0B963C894F","user_header":"","comment_is_top":false,"comment_ctime":1630873658,"is_pvip":true,"replies":[{"id":"112598","content":"1. 可以。它和生命周期有关，你可以看别人的回答。下堂课我们就会回答这个问题。<br>2. 对。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630905487,"ip_address":"","comment_id":310726,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5925840954","product_id":100085301,"comment_content":"问题1.我认为不能。它违背了单一所有权的原则。<br>问题2.let v的类型是基本数据类型，它是实现了Copy trait的。 所以学完本节内容第二题是能回答的。 <br>","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526324,"discussion_content":"1. 可以。它和生命周期有关，你可以看别人的回答。下堂课我们就会回答这个问题。\n2. 对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630905487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360214,"user_name":"永不言弃","can_delete":false,"product_type":"c1","uid":1104956,"ip_address":"北京","ucode":"D6F426124F3938","user_header":"https://static001.geekbang.org/account/avatar/00/10/dc/3c/bee2744b.jpg","comment_is_top":false,"comment_ctime":1666289835,"is_pvip":false,"replies":[{"id":"131019","content":"既然语法不太懂，那可以先去看rust的官方文档把不同的语法大概过一遍，再深入学习。不用着急的，学习嘛，以自己的知识积累和能力进步为准，找准自己的阶段性问题，针对性攻克。加油 💪","user_name":"编辑回复","user_name_real":"编辑","uid":"2547771","ctime":1666318056,"ip_address":"北京","comment_id":360214,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1666289835","product_id":100085301,"comment_content":"感觉会C++的来学这个应该比较容易懂， 我这种从Java和Go过来的，很多概念都听不懂，尤其是Rust的语法，我真是好蛋疼，有太多语法看不懂是啥意思","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591134,"discussion_content":"既然语法不太懂，那可以先去看rust的官方文档把不同的语法大概过一遍，再深入学习。不用着急的，学习嘛，以自己的知识积累和能力进步为准，找准自己的阶段性问题，针对性攻克。加油 💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666318056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360120,"user_name":"Geek_d6ff7b","can_delete":false,"product_type":"c1","uid":2980659,"ip_address":"浙江","ucode":"2CF3BECA8B5A4C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK0q1j4WJKRsibw5jynv5HOqhia2sccMTk9UDVQuEE1td83Bh55bq7XOedDexxzCcJwnZiaZSs57KGvQ/132","comment_is_top":false,"comment_ctime":1666189651,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666189651","product_id":100085301,"comment_content":"Copy trait 会浅拷贝一份值，如果是类似于指针类型的值，那会不会有两个指针指向同一块内存了，这与“一个值同一时刻只能有一个所有者”冲突了吗？","like_count":0},{"had_liked":false,"id":359800,"user_name":"Neo","can_delete":false,"product_type":"c1","uid":1070189,"ip_address":"浙江","ucode":"A2B2E2F8780557","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/6d/c947ef55.jpg","comment_is_top":false,"comment_ctime":1665909384,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665909384","product_id":100085301,"comment_content":"题目1: 不可以，因为栈上的数据可能会比堆上数据先被销毁掉<br>题目2: v时基础类型，实现了Copy trait","like_count":0},{"had_liked":false,"id":356346,"user_name":"你好梦梦","can_delete":false,"product_type":"c1","uid":1259578,"ip_address":"广东","ucode":"17A25B7AE62549","user_header":"https://static001.geekbang.org/account/avatar/00/13/38/3a/102afd91.jpg","comment_is_top":false,"comment_ctime":1662184486,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1662184486","product_id":100085301,"comment_content":"想问下，那对于Copy trait来说，我们自己在定义新的数据结构时，要不要实现Copy trait？如果我在定义函数传参时，那我该如何确定我这个参数用不用借用类型呢？","like_count":0,"discussions":[{"author":{"id":3177536,"avatar":"https://static001.geekbang.org/account/avatar/00/30/7c/40/c1d837b5.jpg","nickname":"康宝combo","note":"","ucode":"07672F87CA52AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587690,"discussion_content":"自定义类型是否能够实现Copy，取决于元素或者字段是否都实现了Copy。 第二个问题，这个就取决于你打算如何操作数据了：是遵循Rust的默认规则（基本move，偶尔copy），还是要打破这个规则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663224044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355571,"user_name":"Geek_e284c2","can_delete":false,"product_type":"c1","uid":3070339,"ip_address":"北京","ucode":"20718266BD50D5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/6xQSiaCXJUM56oosZbUtm7qM1M0QQd8c4Qov8BDZGGnpe6nU2v8MibP0GiaaBpibTbcXzItZrjBwibD7IadpDnlIqKA/132","comment_is_top":false,"comment_ctime":1661502735,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1661502735","product_id":100085301,"comment_content":"想问下为什么 Rust 没有对可变引用与非固定大小的数据结构实现 Copy trait，不是很理解这一点。","like_count":0,"discussions":[{"author":{"id":3177536,"avatar":"https://static001.geekbang.org/account/avatar/00/30/7c/40/c1d837b5.jpg","nickname":"康宝combo","note":"","ucode":"07672F87CA52AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587681,"discussion_content":"至于可变引用，这个涉及到引用的规则：多个读者，一个作者。即，一个指向物同一时间要么有多个不可变（或者共享）引用，要么只能有一个可变引用，不可变引用和可变引用是不兼容的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663216977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3177536,"avatar":"https://static001.geekbang.org/account/avatar/00/30/7c/40/c1d837b5.jpg","nickname":"康宝combo","note":"","ucode":"07672F87CA52AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587680,"discussion_content":"非固定大小的类型，只能在堆上分配，自然不能允许其Copy","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663216803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351997,"user_name":"寻码人","can_delete":false,"product_type":"c1","uid":1480750,"ip_address":"","ucode":"1CED05494AC7E2","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/2e/9cd3cea8.jpg","comment_is_top":false,"comment_ctime":1658318847,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658318847","product_id":100085301,"comment_content":"实现copy接口，堆上的数据也会copy吗","like_count":0},{"had_liked":false,"id":349188,"user_name":"Geek_0ba253","can_delete":false,"product_type":"c1","uid":2612720,"ip_address":"","ucode":"55D6DDECC9AF60","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/QvyPibAqLH5uEr7GNL6Lg9jT9sUs9jtub4LvO575nHuT3viagzmvKLCwGQRicsiadic3n9lM62qQ6n5shHfXUYib8Ktg/132","comment_is_top":false,"comment_ctime":1655790547,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1655790547","product_id":100085301,"comment_content":"第一题<br>可以，在同一作用域可以使用<br>第二题<br>v不会被移动，它是基本类型，使用了Copy语义","like_count":0},{"had_liked":false,"id":348853,"user_name":"小杰","can_delete":false,"product_type":"c1","uid":2853200,"ip_address":"","ucode":"BBDF8E9F348F65","user_header":"https://static001.geekbang.org/account/avatar/00/2b/89/50/aee9fdab.jpg","comment_is_top":false,"comment_ctime":1655462479,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655462479","product_id":100085301,"comment_content":"&#47;&#47; 第一题<br>实际写了一个demo测试，堆数据可以访问栈数据(看评论区大佬说是因为生命周期，我还没有学到，但是大致能理解)<br><br>&#47;&#47; 第二题<br>因为不可变量类型，已经实现了copy trait<br><br>&#39;&#39;&#39; rust &#39;&#39;&#39;<br>fn main(){<br>    let v = 24;<br>    let x = vec![heap_access_stack()];<br>    x[0];<br>    function_access_heap(v);<br>    println!(&quot;main stack access the immutable is {}&quot;, v);<br>}<br>    <br>fn function_access_heap(v:i32){<br>    println!(&quot;other stack access immutable variable is {}&quot;, v);<br>}<br><br>fn heap_access_stack(){<br>    println!(&quot;heap can access stack&quot;)<br>}<br><br>&#39;&#39;&#39; output &#39;&#39;&#39;<br>heap can access stack<br>other stack access immutable variable is 24<br>main stack access the immutable is 24<br>","like_count":0},{"had_liked":false,"id":340570,"user_name":"登高","can_delete":false,"product_type":"c1","uid":1068600,"ip_address":"","ucode":"CD40046238BA18","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/38/3faa8377.jpg","comment_is_top":false,"comment_ctime":1648910764,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648910764","product_id":100085301,"comment_content":"第一题一开始觉得不行，原因在数据在堆上似乎生命周期是长于栈上的。但这是对生命周期理解不够充分的项目，一个变量的生命周期到底有多长与它在栈上还是堆上并没有决定性的关系，着取决于场景。第二题因为copy语义，原来的变量依然可以访问","like_count":0},{"had_liked":false,"id":336054,"user_name":"Geek_d6f7c6","can_delete":false,"product_type":"c1","uid":2651704,"ip_address":"","ucode":"ECE3879B25E1FC","user_header":"","comment_is_top":false,"comment_ctime":1645869996,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1645869996","product_id":100085301,"comment_content":"如果一个数据结构实现了 Copy trait，那么它在赋值、函数调用以及函数返回时会执行 Copy 语义，值会被按位拷贝一份（浅拷贝）？这不是深拷贝吗？","like_count":0,"discussions":[{"author":{"id":2905523,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDqHQQByGiaXcAk94MdDn3ftupZLXyR6bAKibxOzMxy5h3uBwZ7QiaCiaIfbCMK0cIQfGNax8iawoiaQAg/132","nickname":"nuan","note":"","ucode":"55FF98EB85404D","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555286,"discussion_content":"看上面 pedro 同学的回复，讲的非常清楚。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646834841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335755,"user_name":"xiaojunzhou","can_delete":false,"product_type":"c1","uid":1276024,"ip_address":"","ucode":"C155FA9BB89318","user_header":"https://static001.geekbang.org/account/avatar/00/13/78/78/681a3e06.jpg","comment_is_top":false,"comment_ctime":1645674035,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645674035","product_id":100085301,"comment_content":"1. 在 Rust 下，分配在堆上的数据结构可以引用栈上的数据么？为什么？<br>可以，两者的生命周期满足要求就行<br>2. main() 函数传递给 find_pos() 函数的另一个参数 v，也会被移动吧？为什么图上并没有将其标灰？<br>因为参数 v 是原生类型，实现了 Copy 语义","like_count":0},{"had_liked":false,"id":334113,"user_name":"zoomdong","can_delete":false,"product_type":"c1","uid":1460980,"ip_address":"","ucode":"AA0B8F945D9935","user_header":"https://static001.geekbang.org/account/avatar/00/16/4a/f4/513d26e8.jpg","comment_is_top":false,"comment_ctime":1644749048,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644749048","product_id":100085301,"comment_content":"问题2 因为那个数据v是个基础数据类型，实现了 Copy Trait 所以不会被标灰。<br><br>问题1 是可以的。","like_count":0},{"had_liked":false,"id":333091,"user_name":"侯恩训","can_delete":false,"product_type":"c1","uid":1162376,"ip_address":"","ucode":"F4DC47EECA0F00","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/88/fbb6022e.jpg","comment_is_top":false,"comment_ctime":1644060358,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644060358","product_id":100085301,"comment_content":"问题1 :<br>可以，分配在堆上数据默认和持有其的指针（栈）有相同的生命周期，也就是和栈上其他值可能存在相同的生命周期，因此可以<br>问题2:<br>v是u32类型，实现了Copy Trait，其发生了复制，而不是移动","like_count":0},{"had_liked":false,"id":331456,"user_name":"ibin","can_delete":false,"product_type":"c1","uid":2699840,"ip_address":"","ucode":"766942C36B8E27","user_header":"https://static001.geekbang.org/account/avatar/00/29/32/40/d56f476c.jpg","comment_is_top":false,"comment_ctime":1642592813,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"1642592813","product_id":100085301,"comment_content":"fn main() {<br>    let data=vec![1,2,3,4];<br>    println!(&quot;{:p}&quot;,&amp;data);<br>    let y=data;<br>    println!(&quot;{:p}&quot;,&amp;y);<br>}<br>移动move语义：值移动给新的变量，我们取的指针是变量的指针，，那么值的地址有吗？<br>我一直理解是值的地址，但是如果是值的地址，上面的结果应该相同才对。","like_count":0,"discussions":[{"author":{"id":2905523,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIDqHQQByGiaXcAk94MdDn3ftupZLXyR6bAKibxOzMxy5h3uBwZ7QiaCiaIfbCMK0cIQfGNax8iawoiaQAg/132","nickname":"nuan","note":"","ucode":"55FF98EB85404D","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555291,"discussion_content":"&amp;data 和 &amp;y 都是栈上的地址，值在堆上存储。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646836569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330525,"user_name":"chyuwei","can_delete":false,"product_type":"c1","uid":1361377,"ip_address":"","ucode":"19687765E6DE5D","user_header":"","comment_is_top":false,"comment_ctime":1642016210,"is_pvip":false,"replies":[{"id":"120694","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642293132,"ip_address":"","comment_id":330525,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1642016210","product_id":100085301,"comment_content":"1.在 Rust 下，分配在堆上的数据结构可以引用栈上的数据么？为什么？<br>堆上的数据一般生命周期比栈数据生命周期长，所以不能<br>2.main() 函数传递给 find_pos() 函数的另一个参数 v，也会被移动吧？为什么图上并没有将其标灰？<br>v是u32，实现了Copy trait","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546303,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642293133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1460980,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/f4/513d26e8.jpg","nickname":"zoomdong","note":"","ucode":"AA0B8F945D9935","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550822,"discussion_content":"这里堆上的数据类型如果生命周期和栈上相同的话，就可以了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644749271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322479,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1637408728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637408728","product_id":100085301,"comment_content":"老师这里可能需要补充一下浅拷贝与深拷贝区别，深拷贝是会把指向数据的指针也拷贝的，而浅拷贝不会，只会拷贝数据。","like_count":0},{"had_liked":false,"id":322252,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1637279642,"is_pvip":false,"replies":[{"id":"118910","content":"cpp 由于历史原因，unique_ptr 等更像是已有体系的补丁，推荐，但不强制。Rust 把这个思想做进了语言内部，从根本上来解决内存安全以及并发安全的问题。所以 cpp 你可以保证你自己的代码都遵循规范，但无法保证所有的依赖也秉持相同的思想，这是最大的区别。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639852243,"ip_address":"","comment_id":322252,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637279642","product_id":100085301,"comment_content":"老师这个所有权和 cpp unique_ptr 有什么区别呢？<br>感觉都是限制只有一个所有者<br><br>后面的借用感觉有点像 shared_ptr<br><br>而且感觉如果只用智能指针的话 cpp 的那些内存问题也基本可以解决啊？<br><br>可以用 rust 对比一下 cpp 中的这两用智能指针的区别和优缺点吗？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539871,"discussion_content":"cpp 由于历史原因，unique_ptr 等更像是已有体系的补丁，推荐，但不强制。Rust 把这个思想做进了语言内部，从根本上来解决内存安全以及并发安全的问题。所以 cpp 你可以保证你自己的代码都遵循规范，但无法保证所有的依赖也秉持相同的思想，这是最大的区别。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1639852243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1061517,"avatar":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","nickname":"幻境之桥","note":"","ucode":"F9F4DD94CB554E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":540035,"discussion_content":"确实其实自己的也没法保证，特别是在多线程情况下，看到后面才明白从语言的核心层面解决了这些问题，Rust yyds 😁😁😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639924330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":539871,"ip_address":""},"score":540035,"extra":""}]}]},{"had_liked":false,"id":319417,"user_name":"🐷🐷🐷","can_delete":false,"product_type":"c1","uid":1361764,"ip_address":"","ucode":"4E9C2C6775C6C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/c7/64/098877d4.jpg","comment_is_top":false,"comment_ctime":1635786530,"is_pvip":false,"replies":[{"id":"116383","content":"但是借用的时候借用者并不拥有这个值。拥有的概念很重要，因为拥有值的变量会负责清理这个值。比如变量退出作用域，所有者会 drop 相关的资源；而借用者不会做任何事。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636556266,"ip_address":"","comment_id":319417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635786530","product_id":100085301,"comment_content":"老师好，这里有个问题请教下：<br>```<br>一个值同一时刻只能有一个所有者（There can only be one owner at a time），也就是说不能有两个变量拥有相同的值。<br>```<br><br>`也就是说不能有两个变量拥有相同的值` 这里的拥有是指拥有所有权嘛，在借用的情况下不是可以多个变量指向同一个值的嘛","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529628,"discussion_content":"但是借用的时候借用者并不拥有这个值。拥有的概念很重要，因为拥有值的变量会负责清理这个值。比如变量退出作用域，所有者会 drop 相关的资源；而借用者不会做任何事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636556266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318257,"user_name":"阿成","can_delete":false,"product_type":"c1","uid":1390032,"ip_address":"","ucode":"CEC3CD65FB9333","user_header":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","comment_is_top":false,"comment_ctime":1635217189,"is_pvip":false,"replies":[{"id":"116584","content":"红宝书误人，JS primitive type 是传值，object 是传引用。你想一个函数可以修改传入的 object，而函数的调用者可以访问到修改后的结果，那么就不可能是传值。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636643707,"ip_address":"","comment_id":318257,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1635217189","product_id":100085301,"comment_content":"作为一名前端er，也想对比一下 JS 中对应的情形。<br><br>```js<br>&#47;&#47; obj 这个标识符绑定到一个新创建的对象上<br>&#47;&#47; 我们把内存中的这个对象起个名字叫 OBJ_A1<br>let obj = {a: 1}<br>try_change(obj)<br>&#47;&#47; 下面以上边这次调用为例进行分析<br>&#47;&#47; 这里 value 是一个新的标识符<br>&#47;&#47; 在调用过程中，绑定到了上边的 OBJ_A1 对象<br>function try_change(value) {<br>  &#47;&#47; 这里新创建了一个对象，我们起名叫 OBJ_A2<br>  &#47;&#47; 我们用这个新对象覆盖了原来 value 所绑定的 OBJ_A1<br>  &#47;&#47; 这么做并不会改变标识符 obj 的绑定，也不会改变 obj 所绑定对象的值<br>  value = {a: 2}<br><br>  &#47;&#47; 想要修改传进来的对象，只能这样<br>  &#47;&#47; value.a = 2<br>}<br>```<br><br>整个过程大致是这样：<br>obj -&gt; OBJ_A1<br>obj -&gt; OBJ_A1 &lt;- value<br>obj -&gt; OBJ_A1 value -&gt; OBJ_A2<br><br>记得之前在红宝书上看到，JS的调用都是传值调用。那我猜 JS 里都是 Copy 语义。<br><br>我感觉（不一定对哈），上面例子中的 obj 在栈上的值是一个类似指针或者引用的东西（堆上地址+meta），但又有不同之处：<br>1. 读 obj 的时候，直接就能 access 到那个堆上的对象，不需要解引用，或者说引擎内部帮你自动解引用<br>2. 你无法通过解引用的方式去 overwrite 那块堆上的内存，因为 JS 没有这个语义<br><br>所以所谓的传值调用就是说：即使是传对象的情况下，也是对上边所说的类似指针或者引用的东西执行浅拷贝。<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529157,"discussion_content":"红宝书误人，JS primitive type 是传值，object 是传引用。你想一个函数可以修改传入的 object，而函数的调用者可以访问到修改后的结果，那么就不可能是传值。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636643707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314947,"user_name":"Geek_3a1a6f","can_delete":false,"product_type":"c1","uid":2770259,"ip_address":"","ucode":"188546D8B9F9BF","user_header":"","comment_is_top":false,"comment_ctime":1633606799,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633606799","product_id":100085301,"comment_content":"lifetime： the duration of the existence of a living being (such as a person or an animal) or a thing (such as a star or a subatomic particle)","like_count":0},{"had_liked":false,"id":313541,"user_name":"Geek_1a62fc","can_delete":false,"product_type":"c1","uid":2771502,"ip_address":"","ucode":"0CA04CDA06FBE4","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqgfY0CicVtAOv7icF1j3aUefQmib8LcbSyzC8Ha9TBq8nuia0R30Jd9ickNWzD9wwB7UUzcTaatPw9dPA/132","comment_is_top":false,"comment_ctime":1632481173,"is_pvip":false,"replies":[{"id":"113582","content":"函数的参数，作为接收者，拥有了这个变量。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632528675,"ip_address":"","comment_id":313541,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632481173","product_id":100085301,"comment_content":"提个小问题：&quot;值&quot;在传递给函数后，它的拥有都是谁？还是变量吗？我猜应该是接收这个”值&quot;的函数的内部变量。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527384,"discussion_content":"函数的参数，作为接收者，拥有了这个变量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632528675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313147,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1299572,"ip_address":"","ucode":"BF60C93A515DAB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJf3aXIOYKbJq6WicnrPMgm5CpXVBuaWS6UibLUia4ib3QAeUrXvtYdYUfOkaJnics5ME6HlNdic92Ap1hA/132","comment_is_top":false,"comment_ctime":1632297160,"is_pvip":false,"replies":[{"id":"113469","content":"深拷贝是说，一个数据结构里，如果包括指针，那么指针指向的数据也要拷贝，然后照这个规则循环下去，知道所有内存都复制完成。Copy 不会复制指针指向的值，只会复制数据结构本身。所以它是浅拷贝。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632358122,"ip_address":"","comment_id":313147,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632297160","product_id":100085301,"comment_content":"关于“Copy 语义：如果值实现了 Copy trait，那么赋值或传参会使用 Copy 语义，相应的值会被按位拷贝（浅拷贝），产生新的值”这段话中。我可以理解成，新分配一块地址，然后把值拷贝到新分配的地址中么？如果是这样的话，这不是深深拷贝么？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527250,"discussion_content":"深拷贝是说，一个数据结构里，如果包括指针，那么指针指向的数据也要拷贝，然后照这个规则循环下去，知道所有内存都复制完成。Copy 不会复制指针指向的值，只会复制数据结构本身。所以它是浅拷贝。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632358122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313128,"user_name":"青样儿","can_delete":false,"product_type":"c1","uid":1531381,"ip_address":"","ucode":"F9618962B74C25","user_header":"https://static001.geekbang.org/account/avatar/00/17/5d/f5/9c21ec45.jpg","comment_is_top":false,"comment_ctime":1632288686,"is_pvip":false,"replies":[{"id":"113466","content":"对","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1632357851,"ip_address":"","comment_id":313128,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1632288686","product_id":100085301,"comment_content":"Copy trit的处理和Java对基本类型的处理是不是差不多，java的基本类型是final修饰的每次对基本类型的处理都不改变原有值而是返回一个新的值","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527243,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632357851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312726,"user_name":"humblelei","can_delete":false,"product_type":"c1","uid":1562245,"ip_address":"","ucode":"4FE89EF54BD9B3","user_header":"https://static001.geekbang.org/account/avatar/00/17/d6/85/7f4f7ada.jpg","comment_is_top":false,"comment_ctime":1631954444,"is_pvip":true,"replies":[{"id":"113316","content":"正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631982074,"ip_address":"","comment_id":312726,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631954444","product_id":100085301,"comment_content":"打卡。<br>1、可以。只要栈上的数据还没有被释放调，生命周期大于堆上的数据就可以。<br>2、v实现了Copy trait，这里是对栈上数据的拷贝，对原值没有影响","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527090,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631982074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311724,"user_name":"Kerry","can_delete":false,"product_type":"c1","uid":2061524,"ip_address":"","ucode":"92F809EC998FC6","user_header":"https://static001.geekbang.org/account/avatar/00/1f/74/d4/38d813f0.jpg","comment_is_top":false,"comment_ctime":1631428145,"is_pvip":false,"replies":[{"id":"112993","content":"正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631515179,"ip_address":"","comment_id":311724,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631428145","product_id":100085301,"comment_content":"1. 可以，生命周期满足规则即可。例如Vec里可以存放栈上的引用。<br><br>fn main() {<br>    let s1 = &quot;Hello, world!&quot;;<br>    let s2 = &quot;Wow!&quot;;<br><br>    let a = vec![s1, s2];<br>    a.into_iter().for_each(|s| {<br>        println!(&quot;{}&quot;, s);<br>    });<br>}<br><br>2. v的类型是u32，而u32实现了Copy Trait，因此在移动时实际上是被拷贝了一份值，原有的值的所有权没有转交。<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526717,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631515179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311594,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1631328729,"is_pvip":false,"replies":[{"id":"112997","content":"可以通过借用的，继续往后学吧 :)","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631515741,"ip_address":"","comment_id":311594,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631328729","product_id":100085301,"comment_content":"rust确实解决了多重引用带来的问题，但是有另外一个问题，往往有时候我把一个变量传到某个函数里是希望他的值发生改变的，改变之后我还要感知到，但是按rust这么设计，copy出来的变量不会被函数改变，会被函数改变的值转移了所有权，我拿不到，我要怎么从函数的作用域里重新拿回所有权呢？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526674,"discussion_content":"可以通过借用的，继续往后学吧 :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631515741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311410,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1631230781,"is_pvip":true,"replies":[{"id":"112851","content":"正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1631237668,"ip_address":"","comment_id":311410,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631230781","product_id":100085301,"comment_content":"1. 感觉如果只是通过所有权的约束，那一个值的生命周期就和某个栈绑定在一起，所以已经不能像常规想的堆内存的生命周期不固定， 因此这里只要绑定的这个栈的生命周期小于栈上变量的生命周期即可。<br>2. 基本类型实现了copy语义， 不会move所有权。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526591,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631237668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311062,"user_name":"Joseph","can_delete":false,"product_type":"c1","uid":1085994,"ip_address":"","ucode":"B031FACEBEE273","user_header":"https://static001.geekbang.org/account/avatar/00/10/92/2a/bae66865.jpg","comment_is_top":false,"comment_ctime":1631061215,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1631061215","product_id":100085301,"comment_content":"我用c++智能指针理解","like_count":0},{"had_liked":false,"id":310798,"user_name":"亚伦碎语","can_delete":false,"product_type":"c1","uid":1014505,"ip_address":"","ucode":"F32E5E1B63CC90","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7a/e9/da5c0203.jpg","comment_is_top":false,"comment_ctime":1630914429,"is_pvip":false,"replies":[{"id":"112641","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630938367,"ip_address":"","comment_id":310798,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630914429","product_id":100085301,"comment_content":"1.可以，只要保证堆上数据的生命周期小于栈上。<br>2.因为 u32实现了Copy","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526359,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630938367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310778,"user_name":"大远","can_delete":false,"product_type":"c1","uid":1365409,"ip_address":"","ucode":"A2421ACDD78490","user_header":"https://static001.geekbang.org/account/avatar/00/14/d5/a1/9800de2f.jpg","comment_is_top":false,"comment_ctime":1630903557,"is_pvip":false,"replies":[{"id":"112615","content":"哈哈老师现在（一周两篇）写稿压力就挺大的，毕竟为了保证质量。所以暂时不支持付费点播啦，如果关于课程内容有啥想再深入了解的问题，欢迎在评论区交流发言～","user_name":"编辑回复","user_name_real":"叶如芊","uid":"2547771","ctime":1630912693,"ip_address":"","comment_id":310778,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1630903557","product_id":100085301,"comment_content":"天哥，这么醍醐灌顶的课程，一周3讲根本不过瘾啊，可以额外付费点播吗？","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526349,"discussion_content":"哈哈老师现在（一周两篇）写稿压力就挺大的，毕竟为了保证质量。所以暂时不支持付费点播啦，如果关于课程内容有啥想再深入了解的问题，欢迎在评论区交流发言～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630912693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310777,"user_name":"老荀","can_delete":false,"product_type":"c1","uid":1214893,"ip_address":"","ucode":"C32E743518DECD","user_header":"https://static001.geekbang.org/account/avatar/00/12/89/ad/4efd929a.jpg","comment_is_top":false,"comment_ctime":1630902607,"is_pvip":true,"replies":[{"id":"112614","content":"哈哈好习惯，持续打卡持续学习，加油:)","user_name":"编辑回复","user_name_real":"叶如芊","uid":"2547771","ctime":1630912474,"ip_address":"","comment_id":310777,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1630902607","product_id":100085301,"comment_content":"先赞后看，已成习惯","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526348,"discussion_content":"哈哈好习惯，持续打卡持续学习，加油:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630912474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310754,"user_name":"Henry","can_delete":false,"product_type":"c1","uid":1003515,"ip_address":"","ucode":"54AFE9C99B31B4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/fb/10366b97.jpg","comment_is_top":false,"comment_ctime":1630893644,"is_pvip":true,"replies":[{"id":"112599","content":"对！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630905500,"ip_address":"","comment_id":310754,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630893644","product_id":100085301,"comment_content":"1: 实验了下可以，并找不出 Rust 限制不让这么做的理由；<br>2: u32 时下了 Copy Trait，所以 copy 了一个新的值赋给了函数函数，所以 v 在后续依然可以引用","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526338,"discussion_content":"对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630905500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310749,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1923859,"ip_address":"","ucode":"89EA5FCF036C42","user_header":"https://static001.geekbang.org/account/avatar/00/1d/5b/13/6db9ba58.jpg","comment_is_top":false,"comment_ctime":1630892420,"is_pvip":true,"replies":[{"id":"112589","content":"对！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630901380,"ip_address":"","comment_id":310749,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630892420","product_id":100085301,"comment_content":"文中的v是基数类型数组类型，已经实现了Copy,所以不需要手动Copy","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526337,"discussion_content":"对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630901380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310748,"user_name":"gnu","can_delete":false,"product_type":"c1","uid":1631832,"ip_address":"","ucode":"B598402D9377D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/e6/58/a0f74927.jpg","comment_is_top":false,"comment_ctime":1630891040,"is_pvip":false,"replies":[{"id":"112590","content":"正确！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630901389,"ip_address":"","comment_id":310748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630891040","product_id":100085301,"comment_content":"因为 v 是 u32 类型实现了 Copy trait，且分配在栈上，调用 find_pos 时 Copy 了一份 v&#39;，所以图里不用值灰。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526336,"discussion_content":"正确！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630901389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310738,"user_name":"阿海","can_delete":false,"product_type":"c1","uid":1281585,"ip_address":"","ucode":"2589431F840C42","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/31/28972804.jpg","comment_is_top":false,"comment_ctime":1630889784,"is_pvip":true,"replies":[{"id":"112591","content":"正解！更准确地说栈上数据的生命周期大于等于堆上数据的生命周期即可","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1630901441,"ip_address":"","comment_id":310738,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630889784","product_id":100085301,"comment_content":"堆上的数据可以引用栈上的数据，但两者要有相同的生命周期；v是基本数据类型，实现了copy，find_pos里的v是另一个存储在栈上的数据","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526330,"discussion_content":"正解！更准确地说栈上数据的生命周期大于等于堆上数据的生命周期即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630901441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}