{"id":505790,"title":"34 | Kotlin与Jetpack简直是天生一对！","content":"<p>你好，我是朱涛。今天，我们来聊聊Android的Jetpack。</p><p>在我看来，Kotlin和Jetpack，它们两个简直就是天生一对。作为Android开发者，如果只用Kotlin不用Jetpack，我们其实很难在Android平台充分发挥Kotlin的语言优势。而如果我们只用Jetpack而不用Kotlin，那么，我们将只能用到Jetpack的小部分功能。毕竟，Jetpack当中有很多API和库，是专门为Kotlin提供的。</p><p>经过前面课程内容的学习，相信现在你已经对Kotlin十分熟悉了，那么，接下来就让我们来看看Jetpack吧！这节课里，我会为你介绍Jetpack核心库的基本概念、简单用法，以及它跟Kotlin之间的关系，从而也为我们下节课的实战项目打下基础。</p><h2>Jetpack简介</h2><p>Jetpack，它有“喷气式背包”的意思。对于我们开发者来说，它其实就是Google官方为我们提供的一套开发套件，专门用来帮助Android开发者提升开发效率、提升应用稳定性的。</p><p><a href=\"https://android-developers.googleblog.com/2019/05/whats-new-with-android-jetpack.html\"><img src=\"https://static001.geekbang.org/resource/image/ba/c2/ba1e45560e1e6510591d75ee6ee862c2.jpg?wh=600x600\" alt=\"\"></a></p><p>Android Jetpack，最初的宣传图标，就是“穿着喷气式背包的Android机器人”。大概意思就是：有了Jetpack，Android就能“起飞了”。这当然只是一种夸张的比喻，不过，从我实际的开发体验来说，Jetpack确实可以给Android开发者带来极大的好处，尤其是当Jetpack与Kotlin结合到一起的情况下。</p><!-- [[[read_end]]] --><p>我们先来了解下KTX。</p><h2>KTX</h2><p>KTX是Jetpack当中最特殊的一类库，它是由Kotlin编写的，同时也仅为Kotlin开发者服务，使用Java语言的Android开发者是用不了的。KTX，它的作用其实是对当前Android生态当中的API进行额外补充。它依托Kotlin的扩展能力，为Android原有API增加新的：扩展函数、扩展属性、高阶函数、命名参数、参数默认值、协程支持。</p><p>如果我们想要使用KTX的核心功能，我们需要单独进行依赖：</p><pre><code class=\"language-groovy\">// 代码段1\n\ndependencies {\n    implementation \"androidx.core:core-ktx:1.7.0\"\n}\n</code></pre><p>让我们来看一个关于SharedPreference的简单例子，如果我们使用Java，我们大概率是需要写一堆模板代码的，类似这样：</p><pre><code class=\"language-java\">// 代码段2\n\nSharedPreferences sharedPreferences= getSharedPreferences(\"data\",Context.MODE_PRIVATE);\nSharedPreferences.Editor editor = sharedPreferences.edit();\neditor.putString(SP_KEY_RESPONSE, response);\n\neditor.commit();\neditor.apply();\n</code></pre><p>不过，如果我们有了KTX，那么代码就会变得极其简单：</p><pre><code class=\"language-plain\">// 代码段3\n\npreference.edit { putBoolean(\"key\", value) }\n</code></pre><p>上面的这个edit()方法，其实是一个高阶函数，它是由KTX提供的，如果你去看它的源代码，会发现，它其实就是一个扩展出来的高阶函数：</p><pre><code class=\"language-plain\">// 代码段4\n\ninline fun SharedPreferences.edit(\n        commit: Boolean = false,\n        action: SharedPreferences.Editor.() -&gt; Unit\n) {\n    val editor = edit()\n    action(editor)\n    if (commit) {\n        editor.commit()\n    } else {\n        editor.apply()\n    }\n}\n</code></pre><p>可以看到，KTX其实就是将一些常见的模板代码封装了起来，然后以扩展函数的形式提供给开发者。虽然它自身的原理很简单，但是却可以大大提升开发者的效率。</p><p>KTX除了能够扩展Android SDK的API以外，它还可以扩展Jetpack当中其他的库，比如说LiveData、Room等等。接下来，我们就来看看Jetpack当中比较核心的库：Lifecycle。</p><h2>Lifecycle</h2><p>Lifecycle，其实就是Android的生命周期组件。在整个Jetpack组件当中的地位非常特殊，是必学的组件。举个例子，其他的组件比如WorkManager，如果我们实际工作中用不上，那么我们不去学它是不会有什么问题的。Lifecycle不一样，只要我们是做Android开发的，我们就绕不开Lifecycle。Activity里面有Lifecycle；Fragment里面也有；LiveData里面也有；</p><p>ViewModel底层也用到了Lifecycle；使用协程也离不开Lifecycle。</p><p>那么，Lifecycle到底是什么呢？我们平时提到生命周期，往往都是说的Activity、Fragment，而它们两者之间却有一个很大的问题，<strong>生命周期函数不一致</strong>。</p><p>Activity的生命周期我们肯定心里有数，不过Fragment生命周期函数比Activity多了几个：onCreateView、onViewCreated、onViewStateRestore、onDestoryView。最重要的是，Fragment生命周期、回调函数、Fragment内部View的生命周期，它们三者之间还有很复杂的对应关系。换句话说，Fragment的生命周期函数要比Activity复杂一些。</p><p>加之，Activity和Fragment结合的情况下，它们的生命周期行为在不同版本的Android系统上行为可能还会不一致。这在某些边界条件下，还会引发一些难以排查的bug，进一步增加我们Android程序员的维护成本。</p><p>在计算机世界里，大部分问题都可以通过增加一个抽象层来解决。Android团队的做法就是推出了Lifecycle这个架构组件，用它来统一Activity、Fragment的生命周期行为。</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/a1/f03yy1b87813c58f5591aab720e432a1.jpg?wh=2000x904\" alt=\"\"></p><p>有了LifeCycle以后，我们开发者就可以面向Lifecycle编程。比如说，我们希望实现一个通用的地理位置监听的Manager，就可以这样来做：</p><pre><code class=\"language-plain\">// 代码段5\n\n// 不关心调用方是Activity还是Fragment\nclass LocationManager(\n    private val context: Context,\n    private val callback: (Location) -&gt; Unit\n): DefaultLifecycleObserver {\n\n    override fun onStart(owner: LifecycleOwner) {\n        start()\n    }\n\n    override fun onStop(owner: LifecycleOwner) {\n        stop()\n    }\n\n    private fun start() {\n        // 使用高德之类的 SDK 请求地理位置\n    }\n\n    private fun stop() {\n        // 停止\n    }\n}\n\nclass LifecycleExampleActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_life_cycle_example)\n\n        val locationManager = LocationManager(this) {\n            // 展示地理位置信息\n        }\n        lifecycle.addObserver(locationManager)\n    }\n}\n</code></pre><p>上面代码的LocationManager只需要实现DefaultLifecycleObserver这个接口即可，外部是在Activity还是在Fragment当中使用，根本不必关心。</p><h3>Lifecycle与协程</h3><p>通过前面课程的学习，我们知道，协程其实也是有生命周期的。也就是说，Android和Kotlin协程都是有生命周期的。这就意味着，当我们在Android当中使用协程的时候，就要格外小心。</p><p>作为Android开发者，你一定知道内存泄漏的概念：当内存变量的生命周期大于Android生命周期的时候，我们就认为内存发生泄漏了。类似的，当协程的生命周期大于Android生命周期的时候，<strong>协程也就发生泄漏了</strong>。</p><p>这一点，Android官方早就帮我们考虑到了。Lifecycle还可以跟我们前面提到的KTX结合到一起，进一步为Kotlin协程提供支持。</p><p><img src=\"https://static001.geekbang.org/resource/image/ba/5c/ba1d19579cd0e6e6a8e4e004732c705c.png?wh=884x456\" alt=\"图片\"></p><p>在Activity、Fragment当中，KTX还提供了对应的lifecycleScope，它本质上就是一个：与生命周期绑定的协程作用域。</p><pre><code class=\"language-plain\">// 代码段6\n\n// 1\npublic val LifecycleOwner.lifecycleScope: LifecycleCoroutineScope\n    // 2\n    get() = lifecycle.coroutineScope\n\npublic abstract class LifecycleCoroutineScope internal constructor() : CoroutineScope {\n    internal abstract val lifecycle: Lifecycle\n\n    public fun launchWhenCreated(block: suspend CoroutineScope.() -&gt; Unit): Job = launch {\n        lifecycle.whenCreated(block)\n    }\n\n    public fun launchWhenStarted(block: suspend CoroutineScope.() -&gt; Unit): Job = launch {\n        lifecycle.whenStarted(block)\n    }\n\n    public fun launchWhenResumed(block: suspend CoroutineScope.() -&gt; Unit): Job = launch {\n        lifecycle.whenResumed(block)\n    }\n}\n</code></pre><p>在Android当中，Activity和Fragment都会实现LifecycleOwner这个接口，代表它们都是拥有生命周期的组件。注释1处，这里使用了Kotlin的扩展属性，为LifecycleOwner扩展了lifecycleScope。它的类型是LifecycleCoroutineScope，而它其实就是CoroutineScope的实现类。</p><p>lifecycleScope这个属性的具体实现，其实是通过注释2处的自定义getter()实现的，也就是：Lifecycle.coroutineScope。</p><pre><code class=\"language-plain\">// 代码段7\n\npublic val Lifecycle.coroutineScope: LifecycleCoroutineScope\n    get() {\n        while (true) {\n            // 1\n            val existing = mInternalScopeRef.get() as LifecycleCoroutineScopeImpl?\n            if (existing != null) {\n                return existing\n            }\n            // 2\n            val newScope = LifecycleCoroutineScopeImpl(\n                this,\n                SupervisorJob() + Dispatchers.Main.immediate\n            )\n            //3\n            if (mInternalScopeRef.compareAndSet(null, newScope)) {\n                newScope.register()\n                return newScope\n            }\n        }\n    }\n</code></pre><p>可以看到，Lifecycle.coroutineScope仍然是一个扩展属性。它的逻辑其实也很简单，主要是分为了三个步骤：</p><ul>\n<li>第一步，检查是否存在缓存的CoroutineScope，如果存在，那就直接返回即可。</li>\n<li>第二步，如果不存在缓存，那就创建一个新的协程作用域。在创建的作用域的时候，用到了两个我们熟悉的概念：SupervisorJob、Dispatchers.Main，它们都是协程上下文的元素，<strong>前者是用来隔离协程异常传播的，后者是指定协程执行线程的</strong>。</li>\n<li>第三步，更新缓存，并且调用register()绑定scope与Lifecycle的关系，最后返回。</li>\n</ul><p>接下来，我们打破砂锅问到底，看看register()的具体逻辑是什么：</p><pre><code class=\"language-plain\">// 代码段8\n\ninternal class LifecycleCoroutineScopeImpl(\n    override val lifecycle: Lifecycle,\n    override val coroutineContext: CoroutineContext\n    // 2\n) : LifecycleCoroutineScope(), LifecycleEventObserver {\n    init {\n        if (lifecycle.currentState == Lifecycle.State.DESTROYED) {\n            coroutineContext.cancel()\n        }\n    }\n\n    // 1\n    fun register() {\n        launch(Dispatchers.Main.immediate) {\n            if (lifecycle.currentState &gt;= Lifecycle.State.INITIALIZED) {\n                lifecycle.addObserver(this@LifecycleCoroutineScopeImpl)\n            } else {\n                coroutineContext.cancel()\n            }\n        }\n    }\n\n    // 3\n    override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {\n        if (lifecycle.currentState &lt;= Lifecycle.State.DESTROYED) {\n            lifecycle.removeObserver(this)\n            coroutineContext.cancel()\n        }\n    }\n}\n\npublic interface LifecycleEventObserver extends LifecycleObserver {\n    void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event);\n}\n</code></pre><p>上面的代码一共有三个注释，我们一个个来看：</p><ul>\n<li>注释1，register()，可以看到，它的逻辑其实很简单，主要就是调用了addObserver()，将自身作为观察者传了进去。之所以可以这么做，还是因为注释2处的LifecycleEventObserver。</li>\n<li>注释2，LifecycleEventObserver，它其实就是一个SAM接口，每当LifeCycleOwner的生命周期发生变化的时候，这个onStateChanged()方法就会被调用。而这个方法的具体实现则在注释3处。</li>\n<li>注释3，这里的逻辑也很简单，当LifeCycleOwner对应的Activity、Fragment被销毁以后，就会调用removeObserver(this)移除观察者，最后，就是最关键的coroutineContext.cancel()，取消整个作用域里所有的协程任务。</li>\n</ul><p>这样一来，就能保证LifeCycle与协程的生命周期完全一致了，也就不会出现协程泄漏的问题了。</p><h2>小结</h2><p>这节课，我们主要了解了Android当中的Jetpack，它是Android官方提供给开发者的一个开发套件，可以帮助我们开发者提升开发效率。Jetpack当中其实有<a href=\"https://developer.android.com/jetpack\">几十个库</a>，在这节课里，我们是着重讲解了其中的KTX与LifeCycle。</p><ul>\n<li>KTX，主要是依托Kotlin的扩展能力，为Android原有API增加新的：扩展函数、扩展属性、高阶函数、命名参数、参数默认值、协程支持。</li>\n<li>Lifecycle，其实就是Android的生命周期组件。它统一封装了Activity、Fragment等Android生命周期的组件。让我们开发者可以只关注LifeCycle的生命周期，而不用在意其他细节。</li>\n<li>KTX还为LifeCycle增加了协程支持，也就是lifecycleScope。在它的底层，这个协程作用域和宿主的生命周期进行了绑定。当宿主被销毁以后，它可以确保lifecycleScope当中的协程任务，也跟着被取消。</li>\n</ul><p>所以，对于Android开发者来说，Kotlin和Jetpack是一个“你中有我，我中有你”的关系，我们把它们称为“天生一对”一点儿也不为过。</p><h2>思考题</h2><p>在Android中使用协程的时候，除了lifecycleScope以外，我们还经常会使用ViewModel的viewModelScope。你能结合前面协程篇、源码篇的知识点，分析出viewModelScope的实现原理吗？</p><pre><code class=\"language-plain\">class MyViewModel : ViewModel() {\n    private val _persons: MutableLiveData&lt;List&lt;Person&gt;&gt; = MutableLiveData()\n    val persons: LiveData&lt;List&lt;Person&gt;&gt; = _persons\n\n    fun loadPersons() {\n        viewModelScope.launch {\n            delay(500L)\n            _persons.value = listOf(Person(\"Tom\"), Person(\"Jack\"))\n        }\n    }\n}\n\n// 扩展属性\npublic val ViewModel.viewModelScope: CoroutineScope\n    get() {\n        val scope: CoroutineScope? = this.getTag(JOB_KEY)\n        if (scope != null) {\n            return scope\n        }\n        return setTagIfAbsent(\n            JOB_KEY,\n            // 实现类\n            CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)\n        )\n    }\n\n// 实现了Closeable的CoroutineScope\ninternal class CloseableCoroutineScope(context: CoroutineContext) : Closeable, CoroutineScope {\n    override val coroutineContext: CoroutineContext = context\n\n    override fun close() {\n        // 取消\n        coroutineContext.cancel()\n    }\n}\n\npublic abstract class ViewModel {\n\n    @Nullable\n    private final Map&lt;String, Object&gt; mBagOfTags = new HashMap&lt;&gt;();\n    private volatile boolean mCleared = false;\n\n\n    @SuppressWarnings(\"WeakerAccess\")\n    protected void onCleared() {\n    }\n\n    @MainThread\n    final void clear() {\n        mCleared = true;\n\n        if (mBagOfTags != null) {\n            synchronized (mBagOfTags) {\n                for (Object value : mBagOfTags.values()) {\n                    // 调用scope的close()\n                    closeWithRuntimeException(value);\n                }\n            }\n        }\n        onCleared();\n    }\n\n    // scope暂存起来\n    @SuppressWarnings(\"unchecked\")\n    &lt;T&gt; T setTagIfAbsent(String key, T newValue) {\n        T previous;\n        synchronized (mBagOfTags) {\n            previous = (T) mBagOfTags.get(key);\n            if (previous == null) {\n                mBagOfTags.put(key, newValue);\n            }\n        }\n        T result = previous == null ? newValue : previous;\n        if (mCleared) {\n\n            closeWithRuntimeException(result);\n        }\n        return result;\n    }\n\n    private static void closeWithRuntimeException(Object obj) {\n        if (obj instanceof Closeable) {\n            try {\n                ((Closeable) obj).close();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}\n</code></pre>","neighbors":{"left":{"article_title":"33 | Java Android开发者还会有未来吗？","id":504379},"right":{"article_title":"35 | 用Kotlin写一个GitHub Trending App","id":506682}},"comments":[{"had_liked":false,"id":341445,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1649624673,"is_pvip":false,"replies":[{"id":"124974","content":"Lifecycle只是简单的单个状态变更，所以用CAS能够最大程度保证效率。ViewModel使用synchronized，主要还是因为其中的mBagOfTags，它是一个Map，Android官方因为一些旧系统的限制，导致无法使用ConcurrentHashMap，所以才出此下策。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649954678,"ip_address":"","comment_id":341445,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23124461153","product_id":100103401,"comment_content":"思考题:viewModelScope是一个CloseableCoroutineScope，这个对象是懒加载的，第一次使用的时候才会创建，一旦创建以后，这个对象有一个close函数，会在ViewModel clear的时候调用，确保了viewModelScope的Coroutine scope和viewModel生命周期一致。了viewModelScope总体上和lifecycle的scope实现类似。区别是创建的时候，lifecycle用的是无锁+不断循环+compareAndSet方式，而viewModelScope实现的是synchronized带锁的方式，请问老师Android为什么会在两种类似的情况下采用不同的线程同步策略?","like_count":5,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563257,"discussion_content":"Lifecycle只是简单的单个状态变更，所以用CAS能够最大程度保证效率。ViewModel使用synchronized，主要还是因为其中的mBagOfTags，它是一个Map，Android官方因为一些旧系统的限制，导致无法使用ConcurrentHashMap，所以才出此下策。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649954678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":592117,"discussion_content":"“Android官方因为一些旧系统的限制，导致无法使用ConcurrentHashMap，所以才出此下策”\n\n请问老师，这个旧系统的限制具体是哪些呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667128893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":563257,"ip_address":"河北"},"score":592117,"extra":""}]},{"author":{"id":1090798,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","nickname":"魏全运","note":"","ucode":"3FED702C724E2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561434,"discussion_content":"@Paul Shan，对于你的疑问，我说下我的理解。lifecycle和viewmode的两个策略是典型的乐观锁和悲观锁，可以了解下两个锁适用的场景。对于lifecycle这种基本都是读的场景（因为可以预见的大部分适用这个的场景都是在主线程），乐观锁是最好的。而viewmodel的使用场景可能是在model中也可能在view中，所以在不同线程使用的概率要大很多，所以此时用了synchronized这种悲观锁。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1649639656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357380,"user_name":"遥远的救世主","can_delete":false,"product_type":"c1","uid":1181334,"ip_address":"浙江","ucode":"4CC436479CAA21","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/96/4273bb09.jpg","comment_is_top":false,"comment_ctime":1663212859,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1663212859","product_id":100103401,"comment_content":"Android KTX 已经归档，不推荐使用了","like_count":0,"discussions":[{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592118,"discussion_content":"请问在哪看到的？源码中没有@Deprecated这样的注解呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667129030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1252940,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1e/4c/10174727.jpg","nickname":"xinHAOr","note":"","ucode":"C37EC11770EF24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587722,"discussion_content":"不会吧？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663238665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}