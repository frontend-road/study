{"id":149644,"title":"21 | 期末实战：为你的简约版IM系统，加上功能","content":"<p>你好，我是袁武林。</p><p>在期中实战中，我们一起尝试实现了一个简易版的聊天系统，并且为这个聊天系统增加了一些基本功能。比如，用户登录、简单的文本消息收发、消息存储设计、未读数提示、消息自动更新等。</p><p>但是期中实战的目的，主要是让你对IM系统的基本功能构成有一个直观的了解，所以在功能的实现层面上比较简单。比如针对消息的实时性，期中采用的是基于HTTP短轮询的方式来实现。</p><p>因此，在期末实战中，我们主要的工作就是针对期中实战里的消息收发来进行功能优化。</p><p>比如，我们会采用WebSocket的长连接，来替代之前的HTTP短轮询方式，并且会加上一些课程中有讲到的相对高级的功能，如应用层心跳、ACK机制等。</p><p>希望通过期末整体技术实现上的升级，你能更深刻地体会到IM系统升级前后，对使用方和服务端压力的差异性。相应的示例代码我放在了<a href=\"https://github.com/coldwalker/Sample\">GitHub</a>里，你可以作为参考来学习和实现。</p><h2>功能介绍</h2><p>关于这次期末实战，希望你能够完成的功能主要包括以下几个部分：</p><ol>\n<li>支持基于WebSocket的长连接。</li>\n<li>消息收发均通过长连接进行通信。</li>\n<li>支持消息推送的ACK机制和重推机制。</li>\n<li>支持客户端的心跳机制和双端的idle超时断连。</li>\n<li>支持客户端断线后的自动重连。</li>\n</ol><h2>功能实现拆解</h2><!-- [[[read_end]]] --><p>接下来，我们就针对以上这些需要升级的功能和新增的主要功能，来进行实现上的拆解。</p><h3>WebSocket长连接</h3><p>首先，期末实战一个比较大的改变就是，将之前HTTP短轮询的实现，改造成真正的长连接。为了方便Web端的演示，这里我建议你可以使用WebSocket来实现。</p><p>对于WebSocket，我们在客户端JS（JavaScript）里主要是使用HTML5的原生API来实现，其核心的实现代码部分如下：</p><pre><code>if (window.WebSocket) {\n    websocket = new WebSocket(&quot;ws://127.0.0.1:8080&quot;);\n    websocket.onmessage = function (event) {\n        onmsg(event);\n    };\n\n    //连接建立后的事件监听\n    websocket.onopen = function () {\n        bind();\n        heartBeat.start();\n    }\n\n    //连接关闭后的事件监听\n    websocket.onclose = function () {\n        reconnect();\n    };\n\n    //连接出现异常后的事件监听\n    websocket.onerror = function () {\n        reconnect();\n    };\n\n} else {\n    alert(&quot;您的浏览器不支持WebSocket协议！&quot;\n}\n</code></pre><p>页面打开时，JS先通过服务端的WebSocket地址建立长连接。要注意这里服务端连接的地址是ws://开头的，不是http://的了；如果是使用加密的WebSocket协议，那么相应的地址应该是以wss://开头的。</p><p>建立长连之后，要针对创建的WebSocket对象进行事件的监听，我们只需要在各种事件触发的时候，进行对应的逻辑处理就可以了。</p><p>比如，API主要支持的几种事件有：长连接通道建立完成后，通过onopen事件来进行用户信息的上报绑定；通过onmessage事件，对接收到的所有该连接上的数据进行处理，这个也是我们最核心的消息推送的处理逻辑；另外，在长连接通道发生异常错误，或者连接被关闭时，可以分别通过onerror和onclose两个事件来进行监听处理。</p><p>除了通过事件监听，来对长连接的状态变化进行逻辑处理外，我们还可以通过这个WebSocket长连接，向服务器发送数据（消息）。这个功能在实现上也非常简单，你只需要调用WebSocket对象的send方法就OK了。</p><p>通过长连接发送消息的代码设计如下：</p><pre><code>var sendMsgJson = '{ &quot;type&quot;: 3, &quot;data&quot;: {&quot;senderUid&quot;:' + sender_id + ',&quot;recipientUid&quot;:' + recipient_id + ', &quot;content&quot;:&quot;' + msg_content + '&quot;,&quot;msgType&quot;:1  }}';\n\nwebsocket.send(sendMsgJson);\n</code></pre><p>此外，针对WebSocket在服务端的实现，如果你是使用JVM（Java Virtual Machine，Java虚拟机）系列语言的话，我推荐你使用比较成熟的Java NIO框架Netty来做实现。</p><p>因为Netty本身对WebSocket的支持就很完善了，各种编解码器和WebSocket的处理器都有，这样我们在代码实现上就比较简单。</p><p>采用Netty实现WebSocket Server的核心代码，你可以参考下面的示例代码：</p><pre><code>EventLoopGroup bossGroup =\n                    new EpollEventLoopGroup(serverConfig.bossThreads, new DefaultThreadFactory(&quot;WebSocketBossGroup&quot;, true));\n                    \nEventLoopGroup workerGroup =\n                    new EpollEventLoopGroup(serverConfig.workerThreads, new DefaultThreadFactory(&quot;WebSocketWorkerGroup&quot;, true));\n\nServerBootstrap serverBootstrap = new ServerBootstrap().group(bossGroup, workerGroup).channel(EpollServerSocketChannel.class);\n\nChannelInitializer&lt;SocketChannel&gt; initializer = new ChannelInitializer&lt;SocketChannel&gt;() {\n    @Override\n    protected void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        //先添加WebSocket相关的编解码器和协议处理器\n        pipeline.addLast(new HttpServerCodec());\n        pipeline.addLast(new HttpObjectAggregator(65536));\n        pipeline.addLast(new LoggingHandler(LogLevel.DEBUG));\n        pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/&quot;, null, true));\n        //再添加服务端业务消息的总处理器\n        pipeline.addLast(websocketRouterHandler);\n        //服务端添加一个idle处理器，如果一段时间Socket中没有消息传输，服务端会强制断开\n        pipeline.addLast(new IdleStateHandler(0, 0, serverConfig.getAllIdleSecond()));\n        pipeline.addLast(closeIdleChannelHandler);\n    }\n}\n\nserverBootstrap.childHandler(initializer);\nserverBootstrap.bind(serverConfig.port).sync(\n</code></pre><p>首先<strong>创建服务器的ServerBootstrap对象</strong>。Netty作为服务端，从ServerBootstrap启动，ServerBootstrap对象主要用于在服务端的某一个端口进行监听，并接受客户端的连接。</p><p>接着，<strong>通过ChannelInitializer对象，初始化连接管道中用于处理数据的各种编解码器和业务逻辑处理器</strong>。比如这里，我们就需要添加为了处理WebSocket协议相关的编解码器，还要添加服务端接收到客户端发送的消息的业务逻辑处理器，并且还加上了用于通道idle超时管理的处理器。</p><p>最后，<strong>把这个管道处理器链挂到ServerBootstrap，再通过bind和sync方法，启动ServerBootstrap的端口进行监听</strong>就可以了。</p><h3>核心消息收发逻辑处理</h3><p>建立好WebSocket长连接后，我们再来看一下最核心的消息收发是怎么处理的。</p><p>刚才讲到，客户端发送消息的功能，在实现上其实比较简单。我们只需要通过WebSocket对象的send方法，就可以把消息通过长连接发送到服务端。</p><p>那么，下面我们就来看一下服务端接收到消息后的逻辑处理。</p><p>核心的代码逻辑在WebSocketRouterHandler这个处理器中，消息接收处理的相关代码如下：</p><pre><code> @Override\nprotected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {\n    //如果是文本类型的WebSocket数据\n    if (frame instanceof TextWebSocketFrame) {\n        //先解析出具体的文本数据内容\n        String msg = ((TextWebSocketFrame) frame).text();\n        //再用JSON来对这些数据内容进行解析\n        JSONObject msgJson = JSONObject.parseObject(msg);\n        int type = msgJson.getIntValue(&quot;type&quot;);\n        JSONObject data = msgJson.getJSONObject(&quot;data&quot;);\n        \n        long senderUid = data.getLong(&quot;senderUid&quot;);\n        long recipientUid = data.getLong(&quot;recipientUid&quot;);\n        String content = data.getString(&quot;content&quot;);\n        int msgType = data.getIntValue(&quot;msgType&quot;);\n        //调用业务层的Service来进行真正的发消息逻辑处理\n        MessageVO messageContent = messageService.sendNewMsg(senderUid, recipientUid, content, msgType);\n        \n        if (messageContent != null) {\n            JSONObject jsonObject = new JSONObject();\n            jsonObject.put(&quot;type&quot;, 3);\n            jsonObject.put(&quot;data&quot;, JSONObject.toJSON(messageContent));\n                        ctx.writeAndFlush(new TextWebSocketFrame(JSONObject.toJSONString(jsonObject)));\n        }\n    }\n}\n</code></pre><p>这里的WebSocketRouterHandler，我们也是采用事件监听机制来实现。由于这里需要处理“接收到”的消息，所以我们只需要实现channelRead0方法就可以。</p><p>在前面的管道处理器链中，因为添加了WebSocket相关的编解码器，所以这里的WebSocketRouterHandler接收到的都是WebSocketFrame格式的数据。</p><p>接下来，我们从WebSocketFrame格式的数据中，解析出文本类型的收发双方UID和发送内容，就可以调用后端业务模块的发消息功能，来进行最终的发消息逻辑处理了。</p><p>最后，把需要返回给消息发送方的客户端的信息，再通过writeAndFlush方法写回去，就完成消息的发送。</p><p>不过，以上的代码只是处理消息的发送，那么针对消息下推的逻辑处理又是如何实现的呢？</p><p>刚刚讲到，客户端发送的消息，会通过后端业务模块来进行最终的发消息逻辑处理，这个处理过程也包括消息的推送触发。</p><p>因此，我们可以在messageService.sendNewMsg方法中，等待消息存储、未读变更都完成后，再处理待推送给接收方的消息。</p><p>你可以参考下面的核心代码：</p><pre><code>private static final ConcurrentHashMap&lt;Long, Channel&gt; userChannel = new ConcurrentHashMap&lt;&gt;(15000);\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {\n        //处理上线请求\n        long loginUid = data.getLong(&quot;uid&quot;);\n        userChannel.put(loginUid, ctx.channel());\n    }\npublic void pushMsg(long recipientUid, JSONObject message) {\n    Channel channel = userChannel.get(recipientUid);\n    if (channel != null &amp;&amp; channel.isActive() &amp;&amp; channel.isWritable()) {\n        channel.writeAndFlush(new TextWebSocketFrame(message.toJSONString()));\n    }\n}\n</code></pre><p>首先，我们在处理用户建连上线的请求时，会先在网关机内存记录一个“当前连接用户和对应的连接”的映射。</p><p>当系统有消息需要推送时，我们通过查询这个映射关系，就能找到对应的连接，然后就可以通过这个连接，将消息下推下去。</p><pre><code>public class NewMessageListener implements MessageListener {\n    @Override\n    public void onMessage(Message message, byte[] pattern) {\n        String topic = stringRedisSerializer.deserialize(message.getChannel());\n        //从订阅到的Redis的消息里解析出真正需要的业务数据\n        String jsonMsg = valueSerializer.deserialize(message.getBody());\n        logger.info(&quot;Message Received --&gt; pattern: {}，topic:{}，message: {}&quot;, new String(pattern), topic, jsonMsg);\n        JSONObject msgJson = JSONObject.parseObject(jsonMsg);\n        //解析出消息接收人的UID\n        long otherUid = msgJson.getLong(&quot;otherUid&quot;);\n        JSONObject pushJson = new JSONObject();\n        pushJson.put(&quot;type&quot;, 4);\n        pushJson.put(&quot;data&quot;, msgJson);\n        \n        //最终调用网关层处理器将消息真正下推下去\n        websocketRouterHandler.pushMsg(otherUid, pushJson);\n\n    }\n}\n\n@Override\npublic MessageVO sendNewMsg(long senderUid, long recipientUid, String content, int msgType) {\n    \n    //先对发送消息进行存储、加未读等操作\n    //...\n    // 然后将待推送消息发布到Redis\n    redisTemplate.convertAndSend(Constants.WEBSOCKET_MSG_TOPIC, JSONObject.toJSONString(messageVO));\n}\n</code></pre><p>然后，我们可以基于Redis的发布/订阅，实现一个消息推送的发布订阅器。</p><p>在业务层进行发送消息逻辑处理的最后，会将这条消息发布到Redis的一个Topic中，这个Topic被NewMessageListener一直监听着，如果有消息发布，那么监听器会马上感知到，然后再将消息提交给WebSocketRouterHandler，来进行最终消息的下推。</p><h3>消息推送的ACK</h3><p>我在<a href=\"https://time.geekbang.org/column/article/129751\">“04 | ACK机制：如何保证消息的可靠投递？”</a>中有讲到，当系统有消息下推后，我们会依赖客户端响应的ACK包，来保证消息推送的可靠性。如果消息下推后一段时间，服务端没有收到客户端的ACK包，那么服务端会认为这条消息没有正常投递下去，就会触发重新下推。</p><p>关于ACK机制相应的服务端代码，你可以参考下面的示例：</p><pre><code>public void pushMsg(long recipientUid, JSONObject message) {\n    channel.writeAndFlush(new TextWebSocketFrame(message.toJSONString()));\n    //消息推送下去后，将这条消息加入到待ACK列表中\n    addMsgToAckBuffer(channel, message);\n}\npublic void addMsgToAckBuffer(Channel channel, JSONObject msgJson) {\n    nonAcked.put(msgJson.getLong(&quot;tid&quot;), msgJson);\n    //定时器针对下推的这条消息在5s后进行&quot;是否ACK&quot;的检查\n    executorService.schedule(() -&gt; {\n        if (channel.isActive()) {\n            //检查是否被ACK，如果没有收到ACK回包，会触发重推\n            checkAndResend(channel, msgJson);\n        }\n    }, 5000, TimeUnit.MILLISECONDS);\n}\nlong tid = data.getLong(&quot;tid&quot;);\nnonAcked.remove(tid);\nprivate void checkAndResend(Channel channel, JSONObject msgJson) {\n    long tid = msgJson.getLong(&quot;tid&quot;);\n    //重推2次\n    int tryTimes = 2;                    \n    while (tryTimes &gt; 0) {\n        if (nonAcked.containsKey(tid) &amp;&amp; tryTimes &gt; 0) {\n            channel.writeAndFlush(new TextWebSocketFrame(msgJson.toJSONString()));\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        tryTimes--;\n    }\n}\n</code></pre><p>用户在上线完成后，服务端会在这个连接维度的存储里，初始化一个起始值为0的序号（tid），每当有消息推送给客户端时，服务端会针对这个序号进行加1操作，下推消息时就会携带这个序号连同消息一起推下去。</p><p>消息推送后，服务端会将当前消息加入到一个“待ACK Buffer”中，这个ACK Buffer的实现，我们可以简单地用一个ConcurrentHashMap来实现，Key就是这条消息携带的序号，Value是消息本身。</p><p>当消息加入到这个“待ACK Buffer”时，服务端会同时创建一个定时器，在一定的时间后，会触发“检查当前消息是否被ACK”的逻辑；如果客户端有回ACK，那么服务端就会从这个“待ACK Buffer”中移除这条消息，否则如果这条消息没有被ACK，那么就会触发消息的重新下推。</p><h3>应用层心跳</h3><p>在了解了如何通过WebSocket长连接，来完成最核心的消息收发功能之后，我们再来看下，针对这个长连接，我们如何实现新增加的应用层心跳功能。</p><p>应用层心跳的作用，我在<a href=\"https://time.geekbang.org/column/article/134231\">第8课“智能心跳机制：解决网络的不确定性”</a>中也有讲到过，主要是为了解决由于网络的不确定性，而导致的连接不可用的问题。</p><p>客户端发送心跳包的主要代码设计如下，不过我这里的示例代码只是一个简单的实现，你可以自行参考，然后自己去尝试动手实现：</p><pre><code>//每2分钟发送一次心跳包，接收到消息或者服务端的响应又会重置来重新计时。\nvar heartBeat = {\n    timeout: 120000,\n    timeoutObj: null,\n    serverTimeoutObj: null,\n    reset: function () {\n        clearTimeout(this.timeoutObj);\n        clearTimeout(this.serverTimeoutObj);\n        this.start();\n    },\n    start: function () {\n        var self = this;\n        this.timeoutObj = setTimeout(function () {\n            var sender_id = $(&quot;#sender_id&quot;).val();\n            var sendMsgJson = '{ &quot;type&quot;: 0, &quot;data&quot;: {&quot;uid&quot;:' + sender_id + ',&quot;timeout&quot;: 120000}}';\n            websocket.send(sendMsgJson);\n            self.serverTimeoutObj = setTimeout(function () {\n                websocket.close();\n                $(&quot;#ws_status&quot;).text(&quot;失去连接！&quot;);\n            }, self.timeout)\n        }, this.timeout)\n    },\n}\n</code></pre><p>客户端通过一个定时器，每2分钟通过长连接给服务端发送一次心跳包，如果在2分钟内接收到服务端的消息或者响应，那么客户端的下次2分钟定时器的计时，会进行清零重置，重新计算；如果发送的心跳包在2分钟后没有收到服务端的响应，客户端会断开当前连接，然后尝试重连。</p><p>我在下面的代码示例中，提供的“服务端接收到心跳包的处理逻辑”的实现过程，其实非常简单，只是封装了一个普通回包消息进行响应，代码设计如下：</p><pre><code>@Override\nprotected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {\n    long uid = data.getLong(&quot;uid&quot;);\n    long timeout = data.getLong(&quot;timeout&quot;);\n    logger.info(&quot;[heartbeat]: uid = {} , current timeout is {} ms, channel = {}&quot;, uid, timeout, ctx.channel());\n    ctx.writeAndFlush(new TextWebSocketFrame(&quot;{\\&quot;type\\&quot;:0,\\&quot;timeout\\&quot;:&quot; + timeout + &quot;}&quot;));\n}\n</code></pre><p>我们实际在线上实现的时候，可以采用前面介绍的“智能心跳”机制，通过服务端对心跳包的响应，来计算新的心跳间隔，然后返回给客户端来进行调整。</p><p>好，到这里，期末实战的主要核心功能基本上也讲解得差不多了，细节方面你可以再翻一翻我在<a href=\"https://github.com/coldwalker/Sample\">GitHub</a>上提供的示例代码。</p><p>对于即时消息场景的代码实现来说，如果要真正达到线上使用的程度，相应的代码量是非常庞大的；而且对于同一个功能的实现，根据不同的使用场景和业务特征，很多业务在设计上也会有较大的差异性。</p><p>所以，实战课程的设计和示例代码只能做到挂一漏万，我尽量通过最简化的代码，来让你真正了解某一个功能在实现上最核心的思想。并且，通过期中和期末两个阶段的功能升级与差异对比，使你能感受到这些差异对于使用方体验和服务端压力的改善，从而可以更深刻地理解和掌握前面课程中相应的理论点。</p><h2>小结</h2><p>今天的期末实战，我们主要是针对期中实战中IM系统设计的功能，来进行优化改造。</p><p>比如，<strong>使用基于WebSocket的长连接</strong>，代替基于HTTP的短轮询，来提升消息的实时性，并增加了<strong>应用层心跳、ACK机制</strong>等新功能。</p><p>通过这次核心代码的讲解，是想让你能理论结合实际地去理解前面课程讲到的，IM系统设计中最重要的部分功能，也希望你能自己尝试去动手写一写。当然，你也可以基于已有代码，去增加一些之前课程中有讲到，但是示例代码中没有实现的功能，比如离线消息、群聊等。</p><p>最后再给你留一个思考题：<strong>ACK机制的实现中，如果尝试多次下推之后仍然没有成功，服务端后续应该进行哪些处理呢？</strong></p><p>以上就是今天课程的内容，欢迎你给我留言，我们可以在留言区一起讨论，感谢你的收听，我们下期再见。</p>","neighbors":{"left":{"article_title":"20 | 存储和并发：万人群聊系统设计中的几个难点","id":148308},"right":{"article_title":"22 | 答疑解惑：不同即时消息场景下架构实现上的异同","id":151075}},"comments":[{"had_liked":false,"id":140856,"user_name":"墙角儿的花","can_delete":false,"product_type":"c1","uid":1258474,"ip_address":"","ucode":"EE5CAD76175CCF","user_header":"","comment_is_top":false,"comment_ctime":1571061394,"is_pvip":false,"replies":[{"id":"54735","content":"网络阻塞和滑动窗口都是底层传输层的事情呀，和上层的websocket没啥关系，如果有由于传输内容大导致拥塞的问题需要解决的是websocket封装的业务内容是否足够精简，是否需要进一步压缩，和websocket本身无关。websocket自带的心跳机制浏览器很多并不自动支持，所以一般都是自己应用层来实现，自带的心跳机制只要服务端过滤掉也并不会影响连接本身的稳定性。所以最好还是通过双端抓包来具体分析，也有可能是由于链路中间的反向代理等服务导致的。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571225170,"ip_address":"","comment_id":140856,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27340865170","product_id":100034901,"comment_content":"有个大佬给我讲，用websocket在弱网下因为网络阻塞，tcp滑动窗口，不断断网重连，websocket自己又有自己的心跳机制，导致服务端压力很大，云云，我还没搞明白究竟什么意思。难道tcp本身不也是这样？","like_count":7,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470595,"discussion_content":"网络阻塞和滑动窗口都是底层传输层的事情呀，和上层的websocket没啥关系，如果有由于传输内容大导致拥塞的问题需要解决的是websocket封装的业务内容是否足够精简，是否需要进一步压缩，和websocket本身无关。websocket自带的心跳机制浏览器很多并不自动支持，所以一般都是自己应用层来实现，自带的心跳机制只要服务端过滤掉也并不会影响连接本身的稳定性。所以最好还是通过双端抓包来具体分析，也有可能是由于链路中间的反向代理等服务导致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571225170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140696,"user_name":"lecy_L","can_delete":false,"product_type":"c1","uid":1127659,"ip_address":"","ucode":"7C96DDBB3D1F7E","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","comment_is_top":false,"comment_ctime":1571033301,"is_pvip":false,"replies":[{"id":"54467","content":"直播那一章课程里有讲到哈，简单的话就用redis的发布订阅就可以。所有网关机订阅所有房间消息，各网关机认领本机维护的房间用户信息并下推。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571058555,"ip_address":"","comment_id":140696,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14455935189","product_id":100034901,"comment_content":"咨询个问题，望解答。<br>网关机记录用户和链接的信息，finnal在jvm里面的。现在我有一个这样的场景，一个房间（类似群聊）有N个用户，按照上面的说法我要怎么链接到同一个服务器（多应用情况），或者是怎么通知其他链接？在线等，急","like_count":4,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470513,"discussion_content":"直播那一章课程里有讲到哈，简单的话就用redis的发布订阅就可以。所有网关机订阅所有房间消息，各网关机认领本机维护的房间用户信息并下推。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571058555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127659,"avatar":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","nickname":"lecy_L","note":"","ucode":"7C96DDBB3D1F7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33727,"discussion_content":"老师，我现在有个这样的在线教育的场景。实时性要求极高，延迟要在200ms以下，直播是用第三方的通道，鼠标互动等是自己的socket服务。如果采用发布订阅模式的话，队列会成为单点极有可能延迟高，有其他的设计方案参考吗？场景是房间教学，一个房间有几个或者10来个人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571141245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140578,"user_name":"墙角儿的花","can_delete":false,"product_type":"c1","uid":1258474,"ip_address":"","ucode":"EE5CAD76175CCF","user_header":"","comment_is_top":false,"comment_ctime":1571011054,"is_pvip":false,"replies":[{"id":"54465","content":"👍","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571058246,"ip_address":"","comment_id":140578,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14455912942","product_id":100034901,"comment_content":"回答问题，关闭清除客户端连接和待ACK列表","like_count":4,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470450,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571058246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243591,"user_name":"Niud","can_delete":false,"product_type":"c1","uid":1573367,"ip_address":"","ucode":"4E9355D6F11F03","user_header":"https://static001.geekbang.org/account/avatar/00/18/01/f7/d3f3429b.jpg","comment_is_top":false,"comment_ctime":1598202450,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10188137042","product_id":100034901,"comment_content":"老师，websocket和mqtt开发即时通讯，这两种技术优缺点可以说一下吗？在做技术选型","like_count":2},{"had_liked":false,"id":191130,"user_name":"hellojd_gk","can_delete":false,"product_type":"c1","uid":1679543,"ip_address":"","ucode":"319AF4C1AD568D","user_header":"https://static001.geekbang.org/account/avatar/00/19/a0/b7/1327ae60.jpg","comment_is_top":false,"comment_ctime":1584747317,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10174681909","product_id":100034901,"comment_content":"一直对im感兴趣，想找个开源的项目玩一下。github的类似项目都差不多，能推荐个吗？","like_count":2},{"had_liked":false,"id":140693,"user_name":"yangzi","can_delete":false,"product_type":"c1","uid":1589251,"ip_address":"","ucode":"83E02FD4C4AC08","user_header":"https://static001.geekbang.org/account/avatar/00/18/40/03/525a1e78.jpg","comment_is_top":false,"comment_ctime":1571032201,"is_pvip":false,"replies":[{"id":"54466","content":"有点小问题：离线消息建议在消息存储完后就存上，这样离线buffer里的消息是连续的，便于后续检查获取。另外还需要清除 待ack列表中这条消息。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571058416,"ip_address":"","comment_id":140693,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10160966793","product_id":100034901,"comment_content":"回答问题：如果多次下推仍然没有成功，关闭客户端连接，将未回执的消息存储为离线消息。","like_count":2,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470512,"discussion_content":"有点小问题：离线消息建议在消息存储完后就存上，这样离线buffer里的消息是连续的，便于后续检查获取。另外还需要清除 待ack列表中这条消息。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571058416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173580,"user_name":"燃着的半支烟","can_delete":false,"product_type":"c1","uid":1230837,"ip_address":"","ucode":"23C7B588F400A7","user_header":"https://static001.geekbang.org/account/avatar/00/12/c7/f5/4e9a82e9.jpg","comment_is_top":false,"comment_ctime":1579600314,"is_pvip":false,"replies":[{"id":"67350","content":"针对发送方设备，不需要回推这条消息，但是需要能更新最新一条消息的“版本号”或者“时间戳”，因为这个是在服务端才生成的，这样发送方设备就就能正确更新本地的消息“版本号”了。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1579691091,"ip_address":"","comment_id":173580,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5874567610","product_id":100034901,"comment_content":"老师，咨询个问题。为啥代码中，即使用了消息发送，也使用了下推消息（发送redis topic，然后监听到了topic之后，下推消息），那这样客户端岂不是会收到两遍消息？","like_count":1,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482121,"discussion_content":"针对发送方设备，不需要回推这条消息，但是需要能更新最新一条消息的“版本号”或者“时间戳”，因为这个是在服务端才生成的，这样发送方设备就就能正确更新本地的消息“版本号”了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579691091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141338,"user_name":"lecy_L","can_delete":false,"product_type":"c1","uid":1127659,"ip_address":"","ucode":"7C96DDBB3D1F7E","user_header":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","comment_is_top":false,"comment_ctime":1571141275,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"5866108571","product_id":100034901,"comment_content":"老师，我现在有个这样的在线教育的场景。实时性要求极高，延迟要在200ms以下，直播是用第三方的通道，鼠标互动等是自己的socket服务。如果采用发布订阅模式的话，队列会成为单点极有可能延迟高，有其他的设计方案参考吗？场景是房间教学，一个房间有几个或者10来个人","like_count":1,"discussions":[{"author":{"id":1250775,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/d7/96e77edd.jpg","nickname":"问心","note":"","ucode":"6808568D61CE36","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222888,"discussion_content":"实时性要求高，音视频用的应该是webrtc，或基于webrtc做的吧。webrtc里面是有数据通道的，直接用他们的数据通道就好了，这样就可以保证音视频和操作同步了。如果用TCP长连，一但网络抖动肯定会有卡顿和延迟的。用UDP的话，就是看谁对底层算法优化的好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586179417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1127659,"avatar":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","nickname":"lecy_L","note":"","ucode":"7C96DDBB3D1F7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250775,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/d7/96e77edd.jpg","nickname":"问心","note":"","ucode":"6808568D61CE36","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":224341,"discussion_content":"考虑过操作同步共用音视频的通道，声网的。但是被老板给回绝了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586279901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":222888,"ip_address":""},"score":224341,"extra":""},{"author":{"id":1250775,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/d7/96e77edd.jpg","nickname":"问心","note":"","ucode":"6808568D61CE36","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1127659,"avatar":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","nickname":"lecy_L","note":"","ucode":"7C96DDBB3D1F7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224694,"discussion_content":"老板没说啥原因么？印象里声网是按时间收费，没有按数据量收费的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586323908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224341,"ip_address":""},"score":224694,"extra":""},{"author":{"id":1127659,"avatar":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","nickname":"lecy_L","note":"","ucode":"7C96DDBB3D1F7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1250775,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/d7/96e77edd.jpg","nickname":"问心","note":"","ucode":"6808568D61CE36","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":227102,"discussion_content":"有具体聊过这个问题，过程不太记得了。结果是说服了我的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586449076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224694,"ip_address":""},"score":227102,"extra":""}]},{"author":{"id":1010018,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/69/62/b874af21.jpg","nickname":"颛顼","note":"","ucode":"4A6139389C62EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216367,"discussion_content":"每个房间人都不多，redis保存一个房间里人得列表，人到网关机映射，直接查出来后，通过网关机下推就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585442504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1127659,"avatar":"https://static001.geekbang.org/account/avatar/00/11/34/eb/d00aedb0.jpg","nickname":"lecy_L","note":"","ucode":"7C96DDBB3D1F7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1010018,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/69/62/b874af21.jpg","nickname":"颛顼","note":"","ucode":"4A6139389C62EA","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":217154,"discussion_content":"如果所有请求经过网关机，那么网关机是否可能存在单点问题，现阶段每个链接消息频率是60桢。如果采用网状节点，每台机子都做服务端和客户端会怎样呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585503841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":216367,"ip_address":""},"score":217154,"extra":""}]}]},{"had_liked":false,"id":290833,"user_name":"yuanjm","can_delete":false,"product_type":"c1","uid":1811213,"ip_address":"","ucode":"B0FD1AB91467A3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a3/0d/d2c302db.jpg","comment_is_top":false,"comment_ctime":1619774388,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619774388","product_id":100034901,"comment_content":"咨询个问题，望解答。<br>ack重推时，通过线程池的延迟任务执行，如果5秒内有大量消息，放入延迟队列会不会导致OOM，如果重推失败了，休眠2秒占用了线程池的线程，导致其他在该执行的时间点的需要重推的消息排队等待，导致延迟队列越来越长，而且导致重试时间一直延长。<br>有没有更贴近生产环境的设计方案啊，现在在为ack重传问题发愁。","like_count":1,"discussions":[{"author":{"id":1649662,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2b/fe/7925eb7e.jpg","nickname":"pdf","note":"","ucode":"A44250955878BB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551507,"discussion_content":"同学你解决了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645026660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254127,"user_name":"活着","can_delete":false,"product_type":"c1","uid":1197612,"ip_address":"","ucode":"551E8A69503115","user_header":"https://static001.geekbang.org/account/avatar/00/12/46/2c/cb8477cd.jpg","comment_is_top":false,"comment_ctime":1603069824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603069824","product_id":100034901,"comment_content":"服务端每个用户2分钟心跳检测计时，怎么维护，是不很占用资源呢","like_count":0},{"had_liked":false,"id":236934,"user_name":"思绪走了灬光✨","can_delete":false,"product_type":"c1","uid":1101661,"ip_address":"","ucode":"512DD0FA5C024C","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/5d/99756164.jpg","comment_is_top":false,"comment_ctime":1595592906,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1595592906","product_id":100034901,"comment_content":"老师有没有读过netty-socketio这个框架，其中的AckManager的设计思想没有看懂，如果调用client.sendEvent(String event,AckCallback&lt;?&gt; ackCallback,Object ... data) 方法，服务端没有收到客户端的ack,服务端要如何设置重发呢？","like_count":0},{"had_liked":false,"id":214470,"user_name":"xuan","can_delete":false,"product_type":"c1","uid":1634582,"ip_address":"","ucode":"01892B5A2F3056","user_header":"https://static001.geekbang.org/account/avatar/00/18/f1/16/c3ae1a4c.jpg","comment_is_top":false,"comment_ctime":1588754213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588754213","product_id":100034901,"comment_content":"老师，请问如果发送了一条消息，消息被发布到redis上后，如果接收方没有上线，那么就找不到接收方的channel来发送，怎么办","like_count":0},{"had_liked":false,"id":175439,"user_name":"greensky01","can_delete":false,"product_type":"c1","uid":1002581,"ip_address":"","ucode":"9C1B0EBFC603D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4c/55/879a4443.jpg","comment_is_top":false,"comment_ctime":1580720886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580720886","product_id":100034901,"comment_content":"老师，“应用层心跳”一节中的代码示例：<br><br>var self = this;<br>this.timeoutObj = setTimeout(function () {<br>    ...<br>    self.serverTimeoutObj = setTimeout(function () {<br>         ...}, self.timeout)<br>    }, this.timeout)<br>}<br><br>请问这里的外层的 self = this 是为了什么？","like_count":0},{"had_liked":false,"id":168711,"user_name":"overland","can_delete":false,"product_type":"c1","uid":1208835,"ip_address":"","ucode":"609A463519E5F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/03/da1fcc81.jpg","comment_is_top":false,"comment_ctime":1578145520,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1578145520","product_id":100034901,"comment_content":"运行起来现在心跳这块感觉有问题，每隔六分钟就主动断开连接了，那这样心跳就没意义了吧，有谁能帮忙回答下吗","like_count":0,"discussions":[{"author":{"id":1206833,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6a/31/83e2fe48.jpg","nickname":"HOTPOOR-@xialiwei","note":"","ucode":"E51B83A875B6B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258120,"discussion_content":"我的实践体验表明，如果用户是VPN过来，部分只有30秒，根本来不及心跳包。只能走重连。要么就是间隔更短时间发心跳包，保活。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588649800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168554,"user_name":"overland","can_delete":false,"product_type":"c1","uid":1208835,"ip_address":"","ucode":"609A463519E5F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/03/da1fcc81.jpg","comment_is_top":false,"comment_ctime":1578109875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578109875","product_id":100034901,"comment_content":"请教老师个问题，demo上的将查询总未读数删掉，然后心跳机制，就六分钟自动断开了，为什么呢，心跳每两分钟发消息，难道不是有消息传输吗，求老师解答","like_count":0},{"had_liked":false,"id":148713,"user_name":"rachel.li","can_delete":false,"product_type":"c1","uid":1645001,"ip_address":"","ucode":"D326B61D8C0769","user_header":"https://static001.geekbang.org/account/avatar/00/19/19/c9/d0f2c32c.jpg","comment_is_top":false,"comment_ctime":1573053013,"is_pvip":false,"replies":[{"id":"57780","content":"你说的这个是示例代码运行的问题吗？示例代码默认会通过embedded 的方式在jvm里自动启动一个兼容redis协议的模拟redis供使用。如果本机还额外起了redis的话需要看下端口是否存在冲突。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1573477185,"ip_address":"","comment_id":148713,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1573053013","product_id":100034901,"comment_content":"老师你好，我电脑redis已经启动，但是项目启动的时候报错启动不了redis。debug查看了错误说creating server tcp..........no such file or directory，然后谷歌了按网上的办法重新按顺序重新连接redis，启动项目还是报那个错，但是我其他项目是正常的。您有什么思路不","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473580,"discussion_content":"你说的这个是示例代码运行的问题吗？示例代码默认会通过embedded 的方式在jvm里自动启动一个兼容redis协议的模拟redis供使用。如果本机还额外起了redis的话需要看下端口是否存在冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573477185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104869,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/e5/26c2f7de.jpg","nickname":"奔跑的小黄牛","note":"","ucode":"C4E014CA41CB66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352079,"discussion_content":"我本机没有启动redis，也会有这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614596414,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104869,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/e5/26c2f7de.jpg","nickname":"奔跑的小黄牛","note":"","ucode":"C4E014CA41CB66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352078,"discussion_content":"示例代码启动时报错。Error creating bean with name &#39;embededRedis&#39;: Invocation of init method failed; nested exception is java.lang.RuntimeException: Can&#39;t start redis server.\n\n请问怎么解决的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614596276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145231,"user_name":"铁柱","can_delete":false,"product_type":"c1","uid":1221419,"ip_address":"","ucode":"86306660251EF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/a3/2b/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1572233477,"is_pvip":false,"replies":[{"id":"56476","content":"嗯，看了一下确实存在这个问题，感谢反馈，最新代码已经修复这个问题啦，把待ack列表放入到channel的attr里面了，避免复用导致混乱的问题。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1572494586,"ip_address":"","comment_id":145231,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572233477","product_id":100034901,"comment_content":"ack机制里提到“服务端会在这个连接维度的存储里，初始化一个起始值为 0 的序号（tid）”，但是老师您的代码里实际上所有的channel是公用一个websockethandler，也就是使用同一个对象，那么这个concurrenhashmap实际上是被所有连接共享的吧，这样设计难道不会造成ack消息确认被覆盖吗(eg:channel1中tid为1的ack被channel2中tid为1的ack确认覆盖了)","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472302,"discussion_content":"嗯，看了一下确实存在这个问题，感谢反馈，最新代码已经修复这个问题啦，把待ack列表放入到channel的attr里面了，避免复用导致混乱的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572494586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140768,"user_name":"joylee109","can_delete":false,"product_type":"c1","uid":1436426,"ip_address":"","ucode":"ACADE2A155BB04","user_header":"https://static001.geekbang.org/account/avatar/00/15/eb/0a/038d0954.jpg","comment_is_top":false,"comment_ctime":1571045645,"is_pvip":false,"replies":[{"id":"54469","content":"对于经过认证的用户，实现上可以不需要再带上发送方uid，这里是想网关机不依赖认证信息，实现上网关机从session获取完全没问题。另外这里只是个演示demo，线上的话起码会走tls的wss协议。","user_name":"作者回复","user_name_real":"coldwalker","uid":"1297490","ctime":1571058825,"ip_address":"","comment_id":140768,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571045645","product_id":100034901,"comment_content":"老师，你好。websocket 想服务器传送数据的时候， sender_id 是明文传送嘛？现在用户已经登录了网站，认证方式可能是：session ,或者 jwt 方式，或者其他方式。既然用户已经登录，为什么还要在传送数据到后端的时候，将sender_id 明文带上呢？感觉明文传送 sender_id 到后端不安全。","like_count":0,"discussions":[{"author":{"id":1297490,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYCoRSxIa6dDjrcyBqObGfj1lDVia1pOrSVxyltKI7RfGekdXPQNObwaBQg3gwvarlQA/132","nickname":"coldwalker","note":"","ucode":"AF9AF257A745C9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470547,"discussion_content":"对于经过认证的用户，实现上可以不需要再带上发送方uid，这里是想网关机不依赖认证信息，实现上网关机从session获取完全没问题。另外这里只是个演示demo，线上的话起码会走tls的wss协议。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571058825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}