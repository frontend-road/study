{"id":138405,"title":"期中大作业丨题目以及解答剖析","content":"<p>你好，今天是期中大作业讲解课。诚如一位同学所言，这次的大作业不是在考察网络编程的细节，而是在考如何使用系统API完成cd、pwd、ls等功能。不过呢，网络编程的框架总归还是要掌握的。</p><p>我研读了大部分同学的代码，基本上是做得不错的，美中不足的是能动手完成代码编写和调试的同学偏少。我还是秉持一贯的看法，计算机程序设计是一门实战性很强的学科，如果只是单纯地听讲解，没有自己动手这一环，对知识的掌握总归还是差那么点意思。</p><p>代码我已经push到<a href=\"https://github.com/froghui/yolanda/tree/master/mid-homework\">这里</a>，你可以点进链接看一下。</p><h2>客户端程序</h2><p>废话少说，我贴下我的客户端程序：</p><pre><code>#include &quot;lib/common.h&quot;\n#define  MAXLINE     1024\n\nint main(int argc, char **argv) {\n    if (argc != 3) {\n        error(1, 0, &quot;usage: tcp_client &lt;IPaddress&gt; &lt;port&gt;&quot;);\n    }\n    int port = atoi(argv[2]);\n    int socket_fd = tcp_client(argv[1], port);\n\n    char recv_line[MAXLINE], send_line[MAXLINE];\n    int n;\n\n    fd_set readmask;\n    fd_set allreads;\n    FD_ZERO(&amp;allreads);\n    FD_SET(0, &amp;allreads);\n    FD_SET(socket_fd, &amp;allreads);\n\n    for (;;) {\n        readmask = allreads;\n        int rc = select(socket_fd + 1, &amp;readmask, NULL, NULL, NULL);\n\n        if (rc &lt;= 0) {\n            error(1, errno, &quot;select failed&quot;);\n        }\n\n        if (FD_ISSET(socket_fd, &amp;readmask)) {\n            n = read(socket_fd, recv_line, MAXLINE);\n            if (n &lt; 0) {\n                error(1, errno, &quot;read error&quot;);\n            } else if (n == 0) {\n                printf(&quot;server closed \\n&quot;);\n                break;\n            }\n            recv_line[n] = 0;\n            fputs(recv_line, stdout);\n            fputs(&quot;\\n&quot;, stdout);\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &amp;readmask)) {\n            if (fgets(send_line, MAXLINE, stdin) != NULL) {\n                int i = strlen(send_line);\n                if (send_line[i - 1] == '\\n') {\n                    send_line[i - 1] = 0;\n                }\n\n                if (strncmp(send_line, &quot;quit&quot;, strlen(send_line)) == 0) {\n                    if (shutdown(socket_fd, 1)) {\n                        error(1, errno, &quot;shutdown failed&quot;);\n                    }\n                }\n\n                size_t rt = write(socket_fd, send_line, strlen(send_line));\n                if (rt &lt; 0) {\n                    error(1, errno, &quot;write failed &quot;);\n                }\n            }\n        }\n    }\n\n    exit(0);\n}\n</code></pre><p>客户端的代码主要考虑的是使用select同时处理标准输入和套接字，我看到有同学使用fgets来循环等待用户输入，然后再把输入的命令通过套接字发送出去，当然也是可以正常工作的，只不过不能及时响应来自服务端的命令结果，所以，我还是推荐使用select来同时处理标准输入和套接字。</p><p>这里select如果发现标准输入有事件，读出标准输入的字符，就会通过调用write方法发送出去。如果发现输入的是quit，则调用shutdown方法关闭连接的一端。</p><p>如果select发现套接字流有可读事件，则从套接字中读出数据，并把数据打印到标准输出上；如果读到了EOF，表示该客户端需要退出，直接退出循环，通过调用exit来完成进程的退出。</p><!-- [[[read_end]]] --><h2>服务器端程序</h2><p>下面是我写的服务器端程序：</p><pre><code>#include &quot;lib/common.h&quot;\nstatic int count;\n\nstatic void sig_int(int signo) {\n    printf(&quot;\\nreceived %d datagrams\\n&quot;, count);\n    exit(0);\n}\n\nchar *run_cmd(char *cmd) {\n    char *data = malloc(16384);\n    bzero(data, sizeof(data));\n    FILE *fdp;\n    const int max_buffer = 256;\n    char buffer[max_buffer];\n    fdp = popen(cmd, &quot;r&quot;);\n    char *data_index = data;\n    if (fdp) {\n        while (!feof(fdp)) {\n            if (fgets(buffer, max_buffer, fdp) != NULL) {\n                int len = strlen(buffer);\n                memcpy(data_index, buffer, len);\n                data_index += len;\n            }\n        }\n        pclose(fdp);\n    }\n    return data;\n}\n\nint main(int argc, char **argv) {\n    int listenfd;\n    listenfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in server_addr;\n    bzero(&amp;server_addr, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    server_addr.sin_port = htons(SERV_PORT);\n\n    int on = 1;\n    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, sizeof(on));\n\n    int rt1 = bind(listenfd, (struct sockaddr *) &amp;server_addr, sizeof(server_addr));\n    if (rt1 &lt; 0) {\n        error(1, errno, &quot;bind failed &quot;);\n    }\n\n    int rt2 = listen(listenfd, LISTENQ);\n    if (rt2 &lt; 0) {\n        error(1, errno, &quot;listen failed &quot;);\n    }\n\n    signal(SIGPIPE, SIG_IGN);\n\n    int connfd;\n    struct sockaddr_in client_addr;\n    socklen_t client_len = sizeof(client_addr);\n\n\n    char buf[256];\n    count = 0;\n\n    while (1) {\n        if ((connfd = accept(listenfd, (struct sockaddr *) &amp;client_addr, &amp;client_len)) &lt; 0) {\n            error(1, errno, &quot;bind failed &quot;);\n        }\n\n        while (1) {\n            bzero(buf, sizeof(buf));\n            int n = read(connfd, buf, sizeof(buf));\n            if (n &lt; 0) {\n                error(1, errno, &quot;error read message&quot;);\n            } else if (n == 0) {\n                printf(&quot;client closed \\n&quot;);\n                close(connfd);\n                break;\n            }\n            count++;\n            buf[n] = 0;\n            if (strncmp(buf, &quot;ls&quot;, n) == 0) {\n                char *result = run_cmd(&quot;ls&quot;);\n                if (send(connfd, result, strlen(result), 0) &lt; 0)\n                    return 1;\n            } else if (strncmp(buf, &quot;pwd&quot;, n) == 0) {\n                char buf[256];\n                char *result = getcwd(buf, 256);\n                if (send(connfd, result, strlen(result), 0) &lt; 0){\n                    return 1;\n                 }\n                free(result);\n            } else if (strncmp(buf, &quot;cd &quot;, 3) == 0) {\n                char target[256];\n                bzero(target, sizeof(target));\n                memcpy(target, buf + 3, strlen(buf) - 3);\n                if (chdir(target) == -1) {\n                    printf(&quot;change dir failed, %s\\n&quot;, target);\n                }\n            } else {\n                char *error = &quot;error: unknown input type&quot;;\n                if (send(connfd, error, strlen(error), 0) &lt; 0)\n                    return 1;\n            }\n        }\n    }\n    exit(0);\n\n}\n</code></pre><p>服务器端程序需要两层循环，第一层循环控制多个客户端连接，当然咱们这里没有考虑使用并发，这在第三个模块中会讲到。严格来说，现在的服务器端程序每次只能服务一个客户连接。</p><p>第二层循环控制和单个连接的数据交互，因为我们不止完成一次命令交互的过程，所以这一层循环也是必须的。</p><p>大部分同学都完成了这个两层循环的设计，我觉得非常棒。</p><p>在第一层循环里通过accept完成了连接的建立，获得连接套接字。</p><p>在第二层循环里，先通过调用read函数从套接字获取字节流。我这里处理的方式是反复使用了buf缓冲，每次使用之前记得都要调用bzero完成初始化，以便重复利用。</p><p>如果读取数据为0，则说明客户端尝试关闭连接，这种情况下，需要跳出第二层循环，进入accept阻塞调用，等待新的客户连接到来。我看到有同学使用了goto来完成跳转，其实使用break跳出就可以了，也有同学忘记跳转了，这里需要再仔细看一下。</p><p>在读出客户端的命令之后，就进入处理环节。通过字符串比较命令，进入不同的处理分支。C语言的strcmp或者strncmp可以帮助我们进行字符串比较，这个比较类似于Java语言的String equalsIgnoreCase方法。当然，如果命令的格式有错，需要我们把错误信息通过套接字传给客户端。</p><p>对于“pwd”命令，我是通过调用getcwd来完成的，getcwd是一个C语言的API，可以获得当前的路径。</p><p>对于“cd”命令，我是通过调用chdir来完成的，cd是一个C语言的API，可以将当前目录切换到指定的路径。有的同学在这里还判断支持了“cd ~”，回到了当前用户的HOME路径，这个非常棒，我就没有考虑这种情况了。</p><p>对于“ls”命令，我看到有同学是调用了scandir方法，获得当前路径下的所有文件列表，再根据每个文件类型，进行了格式化的输出。这个方法非常棒，是一个标准实现。我这里呢，为了显得稍微不一样，通过了popen的方法，执行了ls的bash命令，把bash命令的结果通过文件字节流的方式读出，再将该字节流通过套接字传给客户端。我看到有的同学在自己的程序里也是这么做的。</p><p>这次的期中大作业，主要考察了客户端-服务器编程的基础知识。</p><p>客户端程序考察使用select多路复用，一方面从标准输入接收字节流，另一方面通过套接字读写，以及使用shutdown关闭半连接的能力。</p><p>服务器端程序则考察套接字读写的能力，以及对端连接关闭情况下的异常处理等能力。</p><p>不过，服务器端程序目前只能一次服务一个客户端连接，不具备并发服务的能力。如何编写一个具备高并发服务能力的服务器端程序，将是我们接下来课程的重点。我们将会重点讲述基于I/O多路复用的事件驱动模型，并以此为基础设计一个高并发网络编程框架，通过这个框架，实现一个HTTP服务器。挑战和难度越来越高，你准备好了吗?</p>","comments":[{"had_liked":false,"id":134971,"user_name":"(￣_￣ )","can_delete":false,"product_type":"c1","uid":1133366,"ip_address":"","ucode":"8B6E2EF240D4AD","user_header":"https://static001.geekbang.org/account/avatar/00/11/4b/36/ed40fb3a.jpg","comment_is_top":false,"comment_ctime":1568964979,"is_pvip":false,"replies":[{"id":"52197","content":"👍","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569406812,"ip_address":"","comment_id":134971,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23043801459","product_id":100032701,"comment_content":"我用的把dup2把标准输入输出重定向到套接字，用system调用命令","like_count":6,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467984,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569406812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135055,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1568991293,"is_pvip":false,"replies":[{"id":"52196","content":"因为每次select操作完就会把传入的fd_set修改掉，以便告知应用程序什么样的事件发生了，所以需要一个初始化的fd_set保存感兴趣的待检测fd_set。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569406770,"ip_address":"","comment_id":135055,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10158925885","product_id":100032701,"comment_content":"为什么select要用两个fd_set来操作,只有一个fd_set会出现什么问题?","like_count":3,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468022,"discussion_content":"因为每次select操作完就会把传入的fd_set修改掉，以便告知应用程序什么样的事件发生了，所以需要一个初始化的fd_set保存感兴趣的待检测fd_set。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569406770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135162,"user_name":"LDxy","can_delete":false,"product_type":"c1","uid":1188710,"ip_address":"","ucode":"956432CE7B7761","user_header":"https://static001.geekbang.org/account/avatar/00/12/23/66/413c0bb5.jpg","comment_is_top":false,"comment_ctime":1569048075,"is_pvip":false,"replies":[{"id":"52191","content":"仅仅是为了计算连接的数量。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569406316,"ip_address":"","comment_id":135162,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5864015371","product_id":100032701,"comment_content":"服务器端程序里面的count++是做何用的？","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468075,"discussion_content":"仅仅是为了计算连接的数量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569406316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134898,"user_name":"骏Jero","can_delete":false,"product_type":"c1","uid":1133122,"ip_address":"","ucode":"C0D505B088275E","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/42/b2c7dd30.jpg","comment_is_top":false,"comment_ctime":1568948449,"is_pvip":false,"replies":[{"id":"51753","content":"你是怎么测试的？贴上代码来看看，很感兴趣的说。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568960466,"ip_address":"","comment_id":134898,"utype":1}],"discussion_count":6,"race_medal":0,"score":"5863915745","product_id":100032701,"comment_content":"老师，有个问题想问下  UDP报文最大长度？ 之前你的专栏udp那篇的提问，我编写代码在局域网试了下可以达到65507个字节。然后参照往上一些资料有些根据mtu来进行计算，但是为什么实际种事65507而不是mtu 1500字节计算出来的1472字节","like_count":2,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467947,"discussion_content":"你是怎么测试的？贴上代码来看看，很感兴趣的说。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568960466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002005,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","nickname":"stackWarn","note":"","ucode":"89672E452DEBA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297254,"discussion_content":"65507加上ip h20字节 加上udp h 8字节，就是65535","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596848902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002005,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","nickname":"stackWarn","note":"","ucode":"89672E452DEBA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297256,"discussion_content":"为啥要避免分片呢。 因为ip层分片不会超时重传等，丢了一个就得传全部分片","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596849070,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002005,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","nickname":"stackWarn","note":"","ucode":"89672E452DEBA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297255,"discussion_content":"通常是应用程序去判断优化发多少，发多了就会分片","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596848956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002005,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/15/106eaaa8.jpg","nickname":"stackWarn","note":"","ucode":"89672E452DEBA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297252,"discussion_content":"最大是65535，通常为了避免ip分片，不建议大于mtu，特殊应用比如dns不建议大于512","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596848814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1133122,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4a/42/b2c7dd30.jpg","nickname":"骏Jero","note":"","ucode":"C0D505B088275E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":19587,"discussion_content":"老师你好，\n我的代码时golang的，客户端如下\nconn, err := net.Dial(&#34;udp&#34;, &#34;:8888&#34;)\t\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer conn.Close()\nconst size = 65507\n\tvar query [size]byte\n\tfor i := 0; i < size; i++ {\n\t\tquery[i] = &#39;a&#39;\n\t}\n\tn, err := conn.Write(query[:])\n\n/*\n超过65507 会报如下，我是在局域网测试，windows操作系统\nwsasend: A message sent on a datagram socket was larger than the internal message buffer or some other network limit,\n\tor the buffer used to receive a datagram into was smaller than the datagram itself.\n*/","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569208796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325817,"user_name":"Geek_60e402","can_delete":false,"product_type":"c1","uid":2685772,"ip_address":"","ucode":"2BA18B57249600","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/MRPyUwu5UQohFRm505mO9KEh4rhmhCABwhVgYDFg9XnoiaUlvmqoQyzsWNdPEd8JHSK8NErN066RdFOyeINK04A/132","comment_is_top":false,"comment_ctime":1639150059,"is_pvip":false,"replies":[{"id":"118234","content":"可以的","user_name":"作者回复","user_name_real":"编辑","uid":"1618647","ctime":1639295410,"ip_address":"","comment_id":325817,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639150059","product_id":100032701,"comment_content":"ls命令我使用的是readdir函数读取当前目录下文件信息，包括文件类型，文件名，列出的文件可以更加个性化一点。","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537998,"discussion_content":"可以的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639295410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193323,"user_name":"linker","can_delete":false,"product_type":"c1","uid":1803259,"ip_address":"","ucode":"6C5799F2FC2C82","user_header":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","comment_is_top":false,"comment_ctime":1584889620,"is_pvip":false,"replies":[{"id":"74751","content":"程序有点bug，data数据应该每次都要清零，否则之前的数据有残存在data数据中。不是popen的问题。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1585483944,"ip_address":"","comment_id":193323,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1584889620","product_id":100032701,"comment_content":"cd &#47;改变了目录后，ls查看到的还是改变之前的目录里面的东西，pwd可以看到改变之后的，这可能是因为popen没有继承环境变量？","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488538,"discussion_content":"程序有点bug，data数据应该每次都要清零，否则之前的数据有残存在data数据中。不是popen的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585483944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1803259,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","nickname":"linker","note":"","ucode":"6C5799F2FC2C82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216766,"discussion_content":"好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585484028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":139117,"user_name":"Geek_Wison","can_delete":false,"product_type":"c1","uid":1504371,"ip_address":"","ucode":"2CD880F07FDD57","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er4HlmmWfWicNmo3x3HKaOwz3ibcicDFlV5xILbILKGFCXbnaLf2fZRARfBdVBC5NhIPmXxaxA0T9Jhg/132","comment_is_top":false,"comment_ctime":1570548616,"is_pvip":false,"replies":[{"id":"54318","content":"是的，两个地方都需要free掉这块内存。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1570973068,"ip_address":"","comment_id":139117,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1570548616","product_id":100032701,"comment_content":"老师您好，上面服务器端代码的free result 你写错地方了，应该写到83行后面，但是你写到了90行了。","like_count":1,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469799,"discussion_content":"是的，两个地方都需要free掉这块内存。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570973068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136812,"user_name":"Steiner","can_delete":false,"product_type":"c1","uid":1622329,"ip_address":"","ucode":"232C1C75207A1E","user_header":"https://static001.geekbang.org/account/avatar/00/18/c1/39/11904266.jpg","comment_is_top":false,"comment_ctime":1569515911,"is_pvip":false,"replies":[{"id":"52786","content":"看一下你当前启动程序的user，还有你的目录属主权限，这个说明你当前启动程序的用户不是当前目录的属主，没有权限进行chdir操作。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569724886,"ip_address":"","comment_id":136812,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569515911","product_id":100032701,"comment_content":"对于cd我直接用了chdir,出现Permission denied怎么办<br>","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468804,"discussion_content":"看一下你当前启动程序的user，还有你的目录属主权限，这个说明你当前启动程序的用户不是当前目录的属主，没有权限进行chdir操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569724886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135142,"user_name":"沉淀的梦想","can_delete":false,"product_type":"c1","uid":1177315,"ip_address":"","ucode":"BCB7C26F9D214B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/e3/e4bcd69e.jpg","comment_is_top":false,"comment_ctime":1569039097,"is_pvip":false,"replies":[{"id":"52193","content":"是的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1569406404,"ip_address":"","comment_id":135142,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569039097","product_id":100032701,"comment_content":"测了一些strcmp，好像写大小写敏感的，更接近Java里的equals，而不是equalsIgnoreCase吧？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468064,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569406404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134944,"user_name":"mgxian","can_delete":false,"product_type":"c1","uid":1014806,"ip_address":"","ucode":"7B7E77E6A83B87","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/16/4d1e5cc1.jpg","comment_is_top":false,"comment_ctime":1568960385,"is_pvip":false,"replies":[{"id":"51756","content":"嗯，只是一个演示，你们可以自行优化。拆分成多个函数当然是可以的。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568960633,"ip_address":"","comment_id":134944,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568960385","product_id":100032701,"comment_content":"可能老师的程序只是为了给我们演示。我发现老师程序主体都在一个main函数写的，没有分开组织成多个小函数，有时 if 的嵌套有点深，其实可以把异常情况直接 return 回去，这样嵌套就会少很多。这样代码也会容易理解一些。","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467970,"discussion_content":"嗯，只是一个演示，你们可以自行优化。拆分成多个函数当然是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568960633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134883,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1568946458,"is_pvip":false,"replies":[{"id":"51747","content":"是的，已修正。一会更新下。","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568959896,"ip_address":"","comment_id":134883,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568946458","product_id":100032701,"comment_content":"malloc的内存没有被释放？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467942,"discussion_content":"是的，已修正。一会更新下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568959896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134882,"user_name":"MoonGod","can_delete":false,"product_type":"c1","uid":1254337,"ip_address":"","ucode":"CB39976963F37A","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/c1/54ef6885.jpg","comment_is_top":false,"comment_ctime":1568946327,"is_pvip":false,"replies":[{"id":"51748","content":"我这里的现象是客户端quit之后会打印。你是什么系统？<br><br>","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568959980,"ip_address":"","comment_id":134882,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568946327","product_id":100032701,"comment_content":"老师有个问题没有想清楚，就是服务端代码中，在读取到客户端发送的EOF后，会打印printf(&quot;server closed \\n&quot;);。但我在实践的过程中，发现这行日志总是在客户端重新连接后，并发送第一条指令后，才在服务端的控制台打印出来，为什么不是在客户端发送quit之后立马打印出来的呢？","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467941,"discussion_content":"我这里的现象是客户端quit之后会打印。你是什么系统？\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568959980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134868,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1568944374,"is_pvip":false,"replies":[{"id":"51749","content":"哈哈，不是都搞定了么","user_name":"作者回复","user_name_real":"froghui","uid":"1618647","ctime":1568960004,"ip_address":"","comment_id":134868,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568944374","product_id":100032701,"comment_content":"我觉得网络不难 难的是你让我去程序里面 ls pwd cd ..&#47;o(╥﹏╥)o","like_count":0,"discussions":[{"author":{"id":1618647,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b2/d7/df4086cf.jpg","nickname":"froghui","note":"","ucode":"843028B4E07F41","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467935,"discussion_content":"哈哈，不是都搞定了么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568960004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254337,"avatar":"https://static001.geekbang.org/account/avatar/00/13/23/c1/54ef6885.jpg","nickname":"MoonGod","note":"","ucode":"CB39976963F37A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17086,"discussion_content":"老师有个问题没有想清楚，就是服务端代码中，在读取到客户端发送的EOF后，会打印printf(&#34;server closed \\n&#34;);。但我在实践的过程中，发现这行日志总是在客户端重新连接后，并发送第一条指令后，才在服务端的控制台打印出来，为什么不是在客户端发送quit之后立马打印出来的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568946264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}