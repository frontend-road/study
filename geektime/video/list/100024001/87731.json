{"id":87731,"title":"34 | sync.pool对象缓存","content":"<h1>课件及源代码地址</h1><p><a href=\"https://gitee.com/geektime-geekbang/go_learning\">https://gitee.com/geektime-geekbang/go_learning</a></p><h2>书目推荐</h2><p><a href=\"time://mall?url=https%3A%2F%2Fh5.youzan.com%2Fv2%2Fgoods%2F1ycmk3uob0ryw\">《计算机程序的构造和解释》</a></p>","comments":[{"had_liked":false,"id":153409,"user_name":"thomas","can_delete":false,"product_type":"c3","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1574231901,"is_pvip":false,"replies":[{"id":59653,"content":"你使用的是那个版本呢？\n官方Go runtime 1.13将对sync.Pool中的对象回收时机策略做出调整。在1.12版本及以前的版本中，在每轮垃圾回收过程中，每个sync.Pool实例中的所有缓存对象都将被无条件回收掉。从1.13版本开始，如果一个sync.Pool实例在上一轮垃圾回收过程结束之后仍然被使用过，则其中的缓存对象将不会被回收掉。此举对于使用sync.Pool来提升效率的程序来说，将大大减少周期性的因为缓存被清除而造成的瞬时效率下降。\n\n","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1574691309,"ip_address":"","comment_id":153409,"utype":1}],"discussion_count":7,"race_medal":1,"score":2,"product_id":100024001,"comment_content":"为什么加上runtime.GC()这句后，依然还是会读取缓存？\n\nfunc main() {\n\tpool := &amp;sync.Pool{\n\t\tNew: func() interface{}{\n\t\t\tfmt.Println(&quot;create a new object&quot;)\n\t\t\treturn 100\n\t\t},\n\t}\n\n\tv,ok := pool.Get().(int)\n\tfmt.Println(v,ok)\n\tpool.Put(3)\t\n\truntime.GC()\n\tv,ok = pool.Get().(int)\n\tfmt.Println(v,ok)\n}\n\n运行结果：\ncreate a new object\n100 true\n3 true","like_count":10,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475155,"discussion_content":"你使用的是那个版本呢？\n官方Go runtime 1.13将对sync.Pool中的对象回收时机策略做出调整。在1.12版本及以前的版本中，在每轮垃圾回收过程中，每个sync.Pool实例中的所有缓存对象都将被无条件回收掉。从1.13版本开始，如果一个sync.Pool实例在上一轮垃圾回收过程结束之后仍然被使用过，则其中的缓存对象将不会被回收掉。此举对于使用sync.Pool来提升效率的程序来说，将大大减少周期性的因为缓存被清除而造成的瞬时效率下降。\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574691309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105098,"avatar":"https://static001.geekbang.org/account/avatar/00/10/dc/ca/de844ac9.jpg","nickname":"Anker_张","note":"","ucode":"21BCF54C371BB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236264,"discussion_content":"在GC回收后等待一段时间 就会回收掉了    因此推断GC回收时异步的\nruntime.GC()\ntime.Sleep(time.Second*1)\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587085028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1356077,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b1/2d/661132f3.jpg","nickname":"佚名","note":"","ucode":"A4E35B21AC3C31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":113983,"discussion_content":"我也是1.13，确实有时候会被回收，有时候不会，原来是改了策略","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577947400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1433247,"avatar":"https://static001.geekbang.org/account/avatar/00/15/de/9f/b6c59a75.jpg","nickname":"dust！","note":"","ucode":"7ADCCC7985B381","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1356077,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b1/2d/661132f3.jpg","nickname":"佚名","note":"","ucode":"A4E35B21AC3C31","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":187911,"discussion_content":"我的也是，有时候回收，有时候不回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582778031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":113983,"ip_address":"","group_id":0},"score":187911,"extra":""}]},{"author":{"id":2890901,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/1c/95/3d8920c9.jpg","nickname":"abcdabcd999","note":"","ucode":"E1D9902737F544","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600977,"discussion_content":"典型的 clock sweep 算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674980242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007453,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5f/5d/211d2edd.jpg","nickname":"zqq","note":"","ucode":"3BBDBF95107C66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323902,"discussion_content":"为了测试效果连续执行2次GC就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605014647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016777,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","nickname":"thomas","note":"","ucode":"9AB945308F1B50","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59687,"discussion_content":"谢谢解答。我用的就是1.13","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574692840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186561,"user_name":"james","can_delete":false,"product_type":"c3","uid":1049208,"ip_address":"","ucode":"5701899403917C","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/78/23c56bce.jpg","comment_is_top":false,"comment_ctime":1583883546,"is_pvip":false,"replies":[{"id":75407,"content":"第一个 Get取出的是私有池中的，私有池仅可放一个对象\n后面的Get取出的则是共享池中的，而共享池的是后进先出的。可以参考sync.pool的源代码：\nfunc (p *Pool) Get() interface{} {\n\tif race.Enabled {\n\t\trace.Disable()\n\t}\n\tl := p.pin()\n\tx := l.private\n\tl.private = nil\n\truntime_procUnpin()\n\tif x == nil {\n\t\tl.Lock()\n\t\tlast := len(l.shared) - 1\n\t\tif last &gt;= 0 {\n\t\t\tx = l.shared[last]\n\t\t\tl.shared = l.shared[:last]\n\t\t}","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1585833351,"ip_address":"","comment_id":186561,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"老师, put 的顺序, 和 get 出来的顺序为啥不一样呢,  这个是queue还是stack 呢, 貌似都不是\n\tpool := sync.Pool{New: func() interface{} {\n\t\treturn 10\n\t}}\n\n\tpool.Put(1)\n\tpool.Put(2)\n\tpool.Put(3)\n\n\tt.Log(pool.Get().(int)) &#47;&#47; 1\n\tt.Log(pool.Get().(int)) &#47;&#47; 3\n\tt.Log(pool.Get().(int)) &#47;&#47; 2","like_count":7,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486802,"discussion_content":"第一个 Get取出的是私有池中的，私有池仅可放一个对象\n后面的Get取出的则是共享池中的，而共享池的是后进先出的。可以参考sync.pool的源代码：\nfunc (p *Pool) Get() interface{} {\n\tif race.Enabled {\n\t\trace.Disable()\n\t}\n\tl := p.pin()\n\tx := l.private\n\tl.private = nil\n\truntime_procUnpin()\n\tif x == nil {\n\t\tl.Lock()\n\t\tlast := len(l.shared) - 1\n\t\tif last &amp;gt;= 0 {\n\t\t\tx = l.shared[last]\n\t\t\tl.shared = l.shared[:last]\n\t\t}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585833351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82769,"user_name":"manatee","can_delete":false,"product_type":"c3","uid":1041112,"ip_address":"","ucode":"708D90E7A265BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e2/d8/f0562ede.jpg","comment_is_top":false,"comment_ctime":1554303045,"is_pvip":false,"replies":[{"id":29961,"content":"这个就是在函数课程中提到，方法在Go中方法是第一公民，所以New是结构体中一个变量，而这个变量的值是个方法。这里你把自定义的方法作为变量值付给了New","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1554364296,"ip_address":"","comment_id":82769,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"请教一下老师在初始化sync.pool中那个New:func() 是什么写法呢，之前好像没遇到过","like_count":6,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445717,"discussion_content":"这个就是在函数课程中提到，方法在Go中方法是第一公民，所以New是结构体中一个变量，而这个变量的值是个方法。这里你把自定义的方法作为变量值付给了New","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554364296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287613,"user_name":"escray","can_delete":false,"product_type":"c3","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1618049688,"is_pvip":true,"replies":[{"id":104458,"content":"没错。其实每一节课都应该这样","user_name":"作者回复","user_name_real":"蔡超","uid":1008262,"ctime":1618103297,"ip_address":"","comment_id":287613,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"sync.pool 对象缓存，而不是对象池，不适合于做连接池\n私有对象，而不是私有对象池\n私有对象访问的时候（写入）不需要锁；共享池写入需要锁\n\n如果使用 sync.pool 来缓存对象，那么每次访问的时候都有可能会遇到锁的问题，锁的开销和创建对象的开销需要进行比较和权衡，才能决定应该使用哪种方式。\n\ngo 1.13 版本后，对于 sync.pool 中缓存的对象，会被放入 victim 中，此时还可以被访问到，直到第二次 GC\n\n我觉的这门课程应该是老师和同学们共创，如果不看留言的话（包括作者回复部分），那么会缺失不少内容。","like_count":2,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518368,"discussion_content":"没错。其实每一节课都应该这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618103297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":299590,"user_name":"Calvin","can_delete":false,"product_type":"c3","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1624728977,"is_pvip":false,"replies":[{"id":110075,"content":"官方Go runtime 1.13后对sync.Pool中的对象回收时机策略做出调整。在1.12版本及以前的版本中，在每轮垃圾回收过程中，每个sync.Pool实例中的所有缓存对象都将被无条件回收掉。从1.13版本开始，如果一个sync.Pool实例在上一轮垃圾回收过程结束之后仍然被使用过，则其中的缓存对象将不会被回收掉。此举对于使用sync.Pool来提升效率的程序来说，将大大减少周期性的因为缓存被清除而造成的瞬时效率下降。","user_name":"作者回复","user_name_real":"蔡超","uid":1008262,"ctime":1627305084,"ip_address":"","comment_id":299590,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"老师，最后的例子中，Put 进去 3 个 100，我这里测试有时会只输出 2 个 100，有时又是 3 个，这是不是因为“协程安全”问题，Put、Get 2 个操作非原子性的原因？但是例子中 3 个 Put 是在所有 Get 前面的，难道 Put 它不是同步的吗？\n我用的 Go 版本是 1.16.5。","like_count":1,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522483,"discussion_content":"官方Go runtime 1.13后对sync.Pool中的对象回收时机策略做出调整。在1.12版本及以前的版本中，在每轮垃圾回收过程中，每个sync.Pool实例中的所有缓存对象都将被无条件回收掉。从1.13版本开始，如果一个sync.Pool实例在上一轮垃圾回收过程结束之后仍然被使用过，则其中的缓存对象将不会被回收掉。此举对于使用sync.Pool来提升效率的程序来说，将大大减少周期性的因为缓存被清除而造成的瞬时效率下降。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627305084,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281918,"user_name":"八宝","can_delete":false,"product_type":"c3","uid":1324501,"ip_address":"","ucode":"89D991A930FDEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/35/d5/17833946.jpg","comment_is_top":false,"comment_ctime":1614949440,"is_pvip":false,"replies":[{"id":102369,"content":"我认为这个是由于在Go1.13版本后引入了victim cache机制的原因，每一次GC并不一定会销毁所有缓存对象。这样的好处是：\n1. 减少回收对象的数量，缩短GC时间\n2. 提高缓存的命中率","user_name":"作者回复","user_name_real":"蔡超","uid":1008262,"ctime":1615001220,"ip_address":"","comment_id":281918,"utype":1}],"discussion_count":1,"race_medal":1,"score":2,"product_id":100024001,"comment_content":"go v1.16 版 测试GC对 sync.Pool的影响\n1). Get 1次，Put 1次，GC，Get1次\n\tv := pool.Get().(int)\n\tfmt.Println(v)\n\tpool.Put(3)\n\truntime.GC()\n\tv1, _ := pool.Get().(int)\n\tfmt.Println(v1)\n反复执行多次后，出现以下两种打印\n(i)\ncreate a new object.\n100\ncreate a new object.\n100\n可能的原因:  GC 时把Pool 清掉了?? 难道触发了2次GC吗\n(ii)\ncreate a new object.\n100\n3\n可能的原因：GC时候没有清掉Pool ?\n这种问题如何排查，老师能给点思路吗？","like_count":0,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516550,"discussion_content":"我认为这个是由于在Go1.13版本后引入了victim cache机制的原因，每一次GC并不一定会销毁所有缓存对象。这样的好处是：\n1. 减少回收对象的数量，缩短GC时间\n2. 提高缓存的命中率","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615001220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":121828,"user_name":"魏颖琪","can_delete":false,"product_type":"c3","uid":1184964,"ip_address":"","ucode":"097544C71EBDA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/14/c4/e354d8ba.jpg","comment_is_top":false,"comment_ctime":1565230286,"is_pvip":false,"replies":[{"id":44789,"content":"其实在我的总结里提到了，sync.Pool是可以在多协程的情况下使用的，但是在访问共享池时，会有锁的开销。\n\n-协程安全，会有锁的开销","user_name":"作者回复","user_name_real":"ChaoCai2010","uid":1008262,"ctime":1565272807,"ip_address":"","comment_id":121828,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"在go doc中这样描述：A Pool is safe for use by multiple goroutines simultaneously. 并没有提及共享池的协程不安全。请问老师，如何理解pool是否协程安全？","like_count":0,"discussions":[{"author":{"id":1008262,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/86/632ad029.jpg","nickname":"蔡超","note":"","ucode":"4C281BBF511238","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461966,"discussion_content":"其实在我的总结里提到了，sync.Pool是可以在多协程的情况下使用的，但是在访问共享池时，会有锁的开销。\n\n-协程安全，会有锁的开销","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565272807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82906,"user_name":"tjudream","can_delete":false,"product_type":"c3","uid":1104851,"ip_address":"","ucode":"A81870769C5E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/d3/d71622c8.jpg","comment_is_top":false,"comment_ctime":1554346867,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"老师能否讲解一些Go语言的内存模型，以及Go语言的垃圾回收机制。\nGo语言和也向Java一样分为堆内存、栈内存和永久区吗？\nGo语言是使用协程去做垃圾回收的吗？是否和Java一样存在Stop The World的情况？\nGo语言没有像Java一样的JVM虚拟机，那它是编译的时候把垃圾回收、协程管理等相关的代码都编译进去了吗？每个Go的二进制包中都存在这些指令吗？","like_count":14},{"had_liked":false,"id":87683,"user_name":"忽然之间","can_delete":false,"product_type":"c3","uid":1052876,"ip_address":"","ucode":"CA6CF7883735DE","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/cc/9226d3c8.jpg","comment_is_top":false,"comment_ctime":1555660386,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"视频内容点到为止，每次听了还要去搜索各种资源来加深理解，希望老师给提供一些更恰当的、提供思考方向、更具实战的例子。","like_count":13},{"had_liked":false,"id":248806,"user_name":"Terence孫","can_delete":false,"product_type":"c3","uid":1157674,"ip_address":"","ucode":"8C3A89C18A2182","user_header":"https://static001.geekbang.org/account/avatar/00/11/aa/2a/ce7c487d.jpg","comment_is_top":false,"comment_ctime":1600315971,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100024001,"comment_content":"这里sync.Pool的生命周期需要说明下\nGo 1.13版本以前，里面缓存的生命周期是下次GC之前\nGO 1.13版本以后，里面缓存的生命周期是下下次GC之前，在第一次执行GC时会将对象放入victim中，在此的数据还是可以获取得到，当GC再此执行时victim中旧数据将被新淘汰得数据替换，此时数据彻底删除","like_count":8},{"had_liked":false,"id":131249,"user_name":"李坤(Terry)","can_delete":false,"product_type":"c3","uid":1262081,"ip_address":"","ucode":"CBB7549543A9C9","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/01/97d12197.jpg","comment_is_top":false,"comment_ctime":1567679564,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"新发布的go1.13版本中，pool支持跨GC了。\n原文是：Pool no longer needs to be completely repopulated after every GC. It now retains some objects across GCs, as opposed to releasing all objects, reducing load spikes for heavy users of Pool.","like_count":2},{"had_liked":false,"id":316216,"user_name":"芒果少侠","can_delete":false,"product_type":"c3","uid":1350159,"ip_address":"","ucode":"98D0BBB52BB80F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9a/0f/da7ed75a.jpg","comment_is_top":false,"comment_ctime":1634202726,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"sync.Pool和bufferedChannel来做对象池，都会有锁的开销以确保性能安全。所以业务代码必须考量，是否创建对象的开销比锁性能开销大，再决定要不要使用这种对象池化技术。","like_count":1},{"had_liked":false,"id":354013,"user_name":"right-chen","can_delete":false,"product_type":"c3","uid":1435172,"ip_address":"北京","ucode":"E0E940E80E7A2D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e6/24/30806a88.jpg","comment_is_top":false,"comment_ctime":1660015914,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"sync.pool叫对象缓存，我感觉叫对象缓存队列比较合适。\n\nfunc TestSyncPool(t *testing.T) {\n\tpool := &amp;sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\tfmt.Println(&quot;Create a new object&quot;)\n\t\t\treturn 100\n\t\t},\n\t}\n\n\tfmt.Println(pool.Get()) &#47;&#47;Create a new object 100\n\tpool.Put(3)\n\tpool.Put(3)\n\tfmt.Println(pool.Get()) &#47;&#47;3\n\tfmt.Println(pool.Get()) &#47;&#47;3\n\tfmt.Println(pool.Get()) &#47;&#47;Create a new object 100\n\tpool.Put(3)\n\truntime.GC()            &#47;&#47;会清空sync.pool中缓存的对象\n\tfmt.Println(pool.Get()) &#47;&#47;Create a new object 100\n}","like_count":0},{"had_liked":false,"id":345442,"user_name":"wangzhanhua","can_delete":false,"product_type":"c3","uid":1237481,"ip_address":"","ucode":"E8F4C487265C0E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL2N0WMpQDia4Td3jaw9XvLEkp27M66ULFoqAvc7xpnQsJMrtUWsgdicib8qptGyC764clMfhbqul1Dg/132","comment_is_top":false,"comment_ctime":1652272719,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"golang的gc机制实在是垃圾","like_count":0},{"had_liked":false,"id":345200,"user_name":"original","can_delete":false,"product_type":"c3","uid":1447770,"ip_address":"","ucode":"1CFBD47E75D482","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/5a/112c0a2c.jpg","comment_is_top":false,"comment_ctime":1652103549,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"那这样的话 sync.pool我是感觉在实际应用场景中有点鸡肋了，当缓存用他会被GC删掉，当连接池用他明显不合适，那他的应用场景就类似临时缓存了，不知道这个东西有没有实际特别有用的场景，谁能举个例子","like_count":0},{"had_liked":false,"id":284148,"user_name":"Geek_d021a5","can_delete":false,"product_type":"c3","uid":1805985,"ip_address":"","ucode":"E713C9DC72FBF5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbR2CkXA6ZiaSZibIW7QsibjYMlLiaCRsvibgeEnzWEwUHHw6zX6h6e9DaqLRCX5jqPT6OVWuibhUVZ7mQ/132","comment_is_top":false,"comment_ctime":1616078752,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"感觉有点跳跃，协程的 Processor 是啥，对象池一下从 ch23 到了 ch32 ...","like_count":0},{"had_liked":false,"id":125184,"user_name":"虢國技醬","can_delete":false,"product_type":"c3","uid":1056807,"ip_address":"","ucode":"5A192262AA037E","user_header":"https://static001.geekbang.org/account/avatar/00/10/20/27/a6932fbe.jpg","comment_is_top":false,"comment_ctime":1566113838,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100024001,"comment_content":"老师所说的每个processor的私有对象和共享池应该就是pool源码的这两个字段定义\n\n&#47;&#47; Local per-P Pool appendix.\ntype poolLocalInternal struct {\n\tprivate interface{} &#47;&#47; Can be used only by the respective P.\n\tshared  poolChain   &#47;&#47; Local P can pushHead&#47;popHead; any P can popTail.\n}\n","like_count":0}]}