{"id":644987,"title":"10｜数据绑定: 如何自动转换传入的参数？","content":"<p>你好，我是郭屹。今天我们继续手写MiniSpring，这节课我们讨论传入参数的转换问题。</p><p>上节课，我们已经基本完成了对Dispatcher的扩展，用HanderMapping来处理映射关系，用HandlerAdapter来处理映射后具体方法的调用。</p><p>在处理请求的过程中，我们用ServletRequest接收请求参数，而获取参数用的是getParameter()方法，它的返回值是String字符串，这也意味着无论是获取字符串参数、数字参数，还是布尔型参数，它获取到的返回值都是字符串。而如果要把请求参数转换成Java对象，就需要再处理，那么每一次获取参数后，都需要显式地编写大量重复代码，把String类型的参数转换成其他类型。显然这不符合我们对框架的期望，我们希望框架能帮助我们自动处理这些常规数据格式的转换。</p><p>再扩大到整个访问过程，后端处理完毕后，返回给前端的数据再做返回，也存在格式转换的问题，传入传出两个方向我们都要处理。而这节课我们讨论的重点是“传入”方向。</p><h2>传入参数的绑定</h2><p>我们先考虑传入方向的问题：请求参数怎么和Java对象里的属性进行自动映射？</p><p>这里，我们引入WebDataBinder来处理。这个类代表的是一个内部的目标对象，用于将Request请求内的字符串参数转换成不同类型的参数，来进行适配。所以比较自然的想法是这个类里面要持有一个目标对象target，然后还要定义一个bind()方法，通过来绑定参数和目标对象，这是WebDataBinder里的核心。</p><!-- [[[read_end]]] --><pre><code class=\"language-java\">&nbsp; &nbsp; public void bind(HttpServletRequest request) {\n&nbsp; &nbsp; &nbsp; &nbsp; PropertyValues mpvs = assignParameters(request);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        addBindValues(mpvs, request);\n&nbsp; &nbsp; &nbsp; &nbsp; doBind(mpvs);\n&nbsp; &nbsp; }\n</code></pre><p>通过bind方法的实现，我们可以看出，它主要做了三件事。</p><ol>\n<li>把Request里的参数解析成PropertyValues。</li>\n<li>把Request里的参数值添加到绑定参数中。</li>\n<li>把两者绑定在一起。</li>\n</ol><p>你可以看一下WebDataBinder的详细实现。</p><pre><code class=\"language-java\">package com.minis.web;\n\nimport java.util.Map;\nimport javax.servlet.http.HttpServletRequest;\nimport com.minis.beans.PropertyValues;\nimport com.minis.util.WebUtils;\n\npublic class WebDataBinder {     \n    private Object target;\n    private Class&lt;?&gt; clz;\n    private String objectName;\n    public WebDataBinder(Object target) {         \n        this(target, \"\");\n    }\n    public WebDataBinder(Object target, String targetName) {         \n        this.target = target;\n        this.objectName = targetName;\n        this.clz = this.target.getClass();     \n    }\n    //核心绑定方法，将request里面的参数值绑定到目标对象的属性上\n&nbsp; &nbsp; public void bind(HttpServletRequest request) {\n&nbsp; &nbsp; &nbsp; &nbsp; PropertyValues mpvs = assignParameters(request);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        addBindValues(mpvs, request);\n&nbsp; &nbsp; &nbsp; &nbsp; doBind(mpvs);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; private void doBind(PropertyValues mpvs) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        applyPropertyValues(mpvs);\n&nbsp; &nbsp; }\n    //实际将参数值与对象属性进行绑定的方法\n&nbsp; &nbsp; protected void applyPropertyValues(PropertyValues mpvs) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        getPropertyAccessor().setPropertyValues(mpvs);\n&nbsp; &nbsp; }\n    //设置属性值的工具\n&nbsp; &nbsp; protected BeanWrapperImpl getPropertyAccessor() {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        return new BeanWrapperImpl(this.target);\n&nbsp; &nbsp; }\n    //将Request参数解析成PropertyValues\n&nbsp; &nbsp; private PropertyValues assignParameters(HttpServletRequest request) {\n&nbsp; &nbsp; &nbsp; &nbsp; Map&lt;String, Object&gt; map = WebUtils.getParametersStartingWith(request, \"\");\n&nbsp; &nbsp; &nbsp; &nbsp; return new PropertyValues(map);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; protected void addBindValues(PropertyValues mpvs, HttpServletRequest request) {\n&nbsp; &nbsp; } \n}\n</code></pre><p>从这个实现方法里可以看出，先是调用了assignParameters()，把Request里的参数换成内存里的一个map对象，这一步用到了底层的WebUtils工具类，这个转换对我们来说比较简单。而最核心的方法是getPropertyAccessor().setPropertyValues(mpvs);，这个getPropertyAccessor则是内置了一个BeanWrapperImpl对象，内部包含了target。由名字可以看出它是Bean的包装实现类，把属性map绑定到目标对象上去。</p><p>有了这个大流程，我们再来探究一下一个具体的参数是如何转换的，我们知道Request的转换都是从字符串转为其他类型，所以我们可以定义一个通用接口，名叫PropertyEditor，内部提供一些方法可以让字符串和Obejct之间进行双向灵活转换。</p><pre><code class=\"language-java\">package com.minis.beans;\n\npublic interface PropertyEditor {&nbsp; &nbsp; &nbsp;\n    void setAsText(String text);&nbsp; &nbsp; &nbsp;\n    void setValue(Object value);&nbsp; &nbsp; &nbsp;\n    Object getValue();\n&nbsp; &nbsp; Object getAsText();\n}\n</code></pre><p>现在我们来定义两个PropertyEditor的实现类：CustomNumberEditor和StringEditor，分别处理Number类型和其他类型，并进行类型转换。你可以看一下CustomNumberEditor的相关源码。</p><pre><code class=\"language-java\">package com.minis.beans;\n\nimport java.text.NumberFormat;\nimport com.minis.util.NumberUtils;\nimport com.minis.util.StringUtils;\n\npublic class CustomNumberEditor implements PropertyEditor{&nbsp; &nbsp; &nbsp;\n    private Class&lt;? extends Number&gt; numberClass; //数据类型\n&nbsp; &nbsp; private NumberFormat numberFormat; //指定格式\n&nbsp; &nbsp; private boolean allowEmpty;\n&nbsp; &nbsp; private Object value;\n&nbsp; &nbsp; public CustomNumberEditor(Class&lt;? extends Number&gt; numberClass, boolean allowEmpty) throws IllegalArgumentException {\n&nbsp; &nbsp; &nbsp; &nbsp; this(numberClass, null, allowEmpty);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public CustomNumberEditor(Class&lt;? extends Number&gt; numberClass, NumberFormat numberFormat, boolean allowEmpty) throws IllegalArgumentException {\n&nbsp; &nbsp; &nbsp; &nbsp; this.numberClass = numberClass;\n&nbsp; &nbsp; &nbsp; &nbsp; this.numberFormat = numberFormat;\n&nbsp; &nbsp; &nbsp; &nbsp; this.allowEmpty = allowEmpty;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; //将一个字符串转换成number赋值\n&nbsp; &nbsp; public void setAsText(String text) {\n\t\tif (this.allowEmpty &amp;&amp; !StringUtils.hasText(text)) {\n\t\t\tsetValue(null);\n\t\t}\n\t\telse if (this.numberFormat != null) {\n\t\t\t// 给定格式\n\t\t\tsetValue(NumberUtils.parseNumber(text, this.numberClass, this.numberFormat));\n\t\t}\n\t\telse {\n\t\t\tsetValue(NumberUtils.parseNumber(text, this.numberClass));\n\t\t}\n&nbsp; &nbsp; }\n&nbsp; &nbsp; //接收Object作为参数\n&nbsp; &nbsp; public void setValue(Object value) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (value instanceof Number) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.value = (NumberUtils.convertNumberToTargetClass((Number) value, this.numberClass));\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.value = value;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n    }\n&nbsp; &nbsp; public Object getValue() {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        return this.value;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; //将number表示成格式化串\n&nbsp; &nbsp; public Object getAsText() {\n&nbsp; &nbsp; &nbsp; &nbsp; Object value = this.value;\n\t\tif (value == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (this.numberFormat != null) {\n\t\t\t// 给定格式.\n\t\t\treturn this.numberFormat.format(value);\n\t\t}\n\t\telse {\n\t\t\treturn value.toString();\n\t\t}\n&nbsp; &nbsp; }\n}\n</code></pre><p>整体实现也比较简单，在内部定义一个名为value的域，接收传入的格式化text或者value值。如果遇到的值是Number类型的子类，比较简单，就进行强制转换。这里我们用到了一个底层工具类NumberUtils，它提供了一个NumberUtils.parseNumber(text, this.numberClass, this.numberFormat)方法，方便我们在数值和文本之间转换。</p><p>你可以看下StringEditor实现的相关源代码。</p><pre><code class=\"language-java\">package com.minis.beans;\n\nimport java.text.NumberFormat;\nimport com.minis.util.NumberUtils;\nimport com.minis.util.StringUtils;\n\npublic class StringEditor implements PropertyEditor{\n &nbsp; &nbsp;private Class&lt;String&gt; strClass;\n&nbsp; &nbsp; private String strFormat;\n&nbsp; &nbsp; private boolean allowEmpty;\n&nbsp; &nbsp; private Object value;\n&nbsp; &nbsp; public StringEditor(Class&lt;String&gt; strClass,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; boolean allowEmpty) throws IllegalArgumentException {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this(strClass, \"\", allowEmpty);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public StringEditor(Class&lt;String&gt; strClass,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String strFormat, boolean allowEmpty) throws IllegalArgumentException {\n&nbsp; &nbsp; &nbsp; &nbsp; this.strClass = strClass;\n&nbsp; &nbsp; &nbsp; &nbsp; this.strFormat = strFormat;\n&nbsp; &nbsp; &nbsp; &nbsp; this.allowEmpty = allowEmpty;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void setAsText(String text) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        setValue(text);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void setValue(Object value) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        this.value = value;\n    }\n&nbsp; &nbsp; public String getAsText() {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        return value.toString();&nbsp; &nbsp; &nbsp;\n    }\n&nbsp; &nbsp; public Object getValue() {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        return this.value;\n&nbsp; &nbsp; }\n}\n</code></pre><p>StringEditor的实现类就更加简单了，因为它是字符串本身的处理，但它的构造函数有些不一样，支持传入字符串格式strFormat，这也是为后续类型转换格式留了一个“口子”。</p><p>有了两个基本类型的Editor作为工具，现在我们再来看关键的类BeanWapperImpl的实现。</p><pre><code class=\"language-java\">package com.minis.web;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport com.minis.beans.PropertyEditor;\nimport com.minis.beans.PropertyEditorRegistrySupport;\nimport com.minis.beans.PropertyValue;\nimport com.minis.beans.PropertyValues;\n\npublic class BeanWrapperImpl extends PropertyEditorRegistrySupport {\n&nbsp; &nbsp; Object wrappedObject; //目标对象\n&nbsp; &nbsp; Class&lt;?&gt; clz;\n&nbsp; &nbsp; PropertyValues pvs; //参数值\n&nbsp; &nbsp; public BeanWrapperImpl(Object object) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        registerDefaultEditors(); //不同数据类型的参数转换器editor\n&nbsp; &nbsp; &nbsp; &nbsp; this.wrappedObject = object;\n&nbsp; &nbsp; &nbsp; &nbsp; this.clz = object.getClass();\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void setBeanInstance(Object object) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        this.wrappedObject = object;\n&nbsp; &nbsp; }\n    public Object getBeanInstance() {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        return wrappedObject;\n&nbsp; &nbsp; }\n    //绑定参数值\n&nbsp; &nbsp; public void setPropertyValues(PropertyValues pvs) {\n&nbsp; &nbsp; &nbsp; &nbsp; this.pvs = pvs;\n&nbsp; &nbsp; &nbsp; &nbsp; for (PropertyValue pv : this.pvs.getPropertyValues()) {&nbsp; &nbsp; &nbsp; &nbsp; \n     &nbsp; &nbsp; &nbsp;setPropertyValue(pv);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n    //绑定具体某个参数\n&nbsp; &nbsp; public void setPropertyValue(PropertyValue pv) {\n        //拿到参数处理器\n&nbsp; &nbsp; &nbsp; &nbsp; BeanPropertyHandler propertyHandler = new&nbsp;BeanPropertyHandler(pv.getName());\n        //找到对该参数类型的editor\n&nbsp; &nbsp; &nbsp; &nbsp; PropertyEditor pe =&nbsp;this.getDefaultEditor(propertyHandler.getPropertyClz());&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        //设置参数值\n        pe.setAsText((String) pv.getValue());\n&nbsp; &nbsp; &nbsp; &nbsp; propertyHandler.setValue(pe.getValue());\n    }\n    //一个内部类，用于处理参数，通过getter()和setter()操作属性\n&nbsp; &nbsp; class BeanPropertyHandler {\n&nbsp; &nbsp; &nbsp; &nbsp; Method writeMethod = null;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        Method readMethod = null;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        Class&lt;?&gt; propertyClz = null;\n&nbsp; &nbsp; &nbsp; &nbsp; public Class&lt;?&gt; getPropertyClz() {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n            return propertyClz;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; public BeanPropertyHandler(String propertyName) {\n\t\t\ttry {\n                //获取参数对应的属性及类型\n    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Field field = clz.getDeclaredField(propertyName);\n    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; propertyClz = field.getType();\n                //获取设置属性的方法，按照约定为setXxxx（）\n    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this.writeMethod = clz.getDeclaredMethod(\"set\" +&nbsp;\n    propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1), propertyClz);\n                //获取读属性的方法，按照约定为getXxxx（）\n                this.readMethod = clz.getDeclaredMethod(\"get\" +&nbsp;\n    propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1), propertyClz);\n            } catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}&nbsp; &nbsp; &nbsp; &nbsp; }\n        //调用getter读属性值\n&nbsp; &nbsp; &nbsp; &nbsp; public Object getValue() {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object result = null;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writeMethod.setAccessible(true);\n\t\t\ttry {\n    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = readMethod.invoke(wrappedObject);&nbsp;\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return result;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n        //调用setter设置属性值\n&nbsp; &nbsp; &nbsp; &nbsp; public void setValue(Object value) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writeMethod.setAccessible(true);\n\t\t\ttry {\n    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writeMethod.invoke(wrappedObject, value);\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>这个类的核心在于利用反射对Bean属性值进行读写，具体是通过setter和getter方法。但具体的实现，则有赖于继承的PropertyEditorRegistrySupport这个类。我们再来看看PropertyEditorRegistrySupport是如何实现的。</p><pre><code class=\"language-java\">package com.minis.beans;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class PropertyEditorRegistrySupport {\n    private Map&lt;Class&lt;?&gt;, PropertyEditor&gt; defaultEditors;\n    private Map&lt;Class&lt;?&gt;, PropertyEditor&gt; customEditors;\n    //注册默认的转换器editor\n    protected void registerDefaultEditors() {\n        createDefaultEditors();\n    }\n    //获取默认的转换器editor\n    public PropertyEditor getDefaultEditor(Class&lt;?&gt; requiredType) {\n        return this.defaultEditors.get(requiredType);\n    }\n    //创建默认的转换器editor，对每一种数据类型规定一个默认的转换器\n    private void createDefaultEditors() {\n        this.defaultEditors = new HashMap&lt;&gt;(64);\n        // Default instances of collection editors.\n        this.defaultEditors.put(int.class, new CustomNumberEditor(Integer.class, false));\n        this.defaultEditors.put(Integer.class, new CustomNumberEditor(Integer.class, true));\n        this.defaultEditors.put(long.class, new CustomNumberEditor(Long.class, false));\n        this.defaultEditors.put(Long.class, new CustomNumberEditor(Long.class, true));\n        this.defaultEditors.put(float.class, new CustomNumberEditor(Float.class, false));\n        this.defaultEditors.put(Float.class, new CustomNumberEditor(Float.class, true));\n        this.defaultEditors.put(double.class, new CustomNumberEditor(Double.class, false));\n        this.defaultEditors.put(Double.class, new CustomNumberEditor(Double.class, true));\n        this.defaultEditors.put(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, true));\n        this.defaultEditors.put(BigInteger.class, new CustomNumberEditor(BigInteger.class, true));\n        this.defaultEditors.put(String.class, new StringEditor(String.class, true));\n    }\n    //注册客户化转换器\n    public void registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor propertyEditor) {\n        if (this.customEditors == null) {\n            this.customEditors = new LinkedHashMap&lt;&gt;(16);\n        }\n        this.customEditors.put(requiredType, propertyEditor);\n    }\n    //查找客户化转换器\n    public PropertyEditor findCustomEditor(Class&lt;?&gt; requiredType) {\n        Class&lt;?&gt; requiredTypeToUse = requiredType;\n        return getCustomEditor(requiredTypeToUse);\n    }\n    public boolean hasCustomEditorForElement(Class&lt;?&gt; elementType) {\n        return (elementType != null &amp;&amp; this.customEditors != null &amp;&amp; this.customEditors.containsKey(elementType));\n    }\n    //获取客户化转换器\n    private PropertyEditor getCustomEditor(Class&lt;?&gt; requiredType) {\n        if (requiredType == null || this.customEditors == null) {\n            return null;\n        }\n        PropertyEditor editor = this.customEditors.get(requiredType);\n        return editor;\n    }\n}\n\n</code></pre><p>从这段源码里可以看到，PropertyEditorRegistrySupport 的核心实现是createDefaultEditors方法，它里面内置了大量基本类型或包装类型的转换器Editor，还定义了可以定制化的转换器Editor，这也是WebDataBinder能做不同类型转换的原因。不过我们目前的实现，只支持数字和字符串几个基本类型的转换，暂时不支持数组、列表、map等格式。</p><p>现在，我们已经实现了一个完整的WebDataBinder，用来绑定数据。我们接下来将提供一个WebDataBinderFactory，能够更方便、灵活地操作WebDataBinder。</p><pre><code class=\"language-java\">package com.minis.web;\n\nimport javax.servlet.http.HttpServletRequest;\n\npublic class WebDataBinderFactory {\n&nbsp; &nbsp; public WebDataBinder createBinder(HttpServletRequest request, Object target, String objectName) {\n&nbsp; &nbsp; &nbsp; &nbsp; WebDataBinder wbd = new WebDataBinder(target, objectName);\n&nbsp; &nbsp; &nbsp; &nbsp; initBinder(wbd, request);\n&nbsp; &nbsp; &nbsp; &nbsp; return wbd;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; protected void initBinder(WebDataBinder dataBinder, HttpServletRequest request) {\n&nbsp; &nbsp; } \n}\n</code></pre><p>有了上面一系列工具之后，我们看怎么使用它们进行数据绑定。从前面的讲解中我们已经知道，这个 HTTP Request请求最后会找到映射的方法上，也就是通过RequestMappingHandlerAdapter里提供的handleInternal 方法，来调用invokeHandlerMethod 方法，所以我们从这个地方切入，改造 invokeHandlerMethod 方法，实现参数绑定。</p><pre><code class=\"language-java\">&nbsp; &nbsp; protected void invokeHandlerMethod(HttpServletRequest request,&nbsp;\nHttpServletResponse response, HandlerMethod handlerMethod) throws Exception {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        WebDataBinderFactory binderFactory = new WebDataBinderFactory();\n&nbsp; &nbsp; &nbsp; &nbsp; Parameter[] methodParameters =&nbsp;\nhandlerMethod.getMethod().getParameters();\n&nbsp; &nbsp; &nbsp; &nbsp; Object[] methodParamObjs = new Object[methodParameters.length];\n&nbsp; &nbsp; &nbsp; &nbsp; int i = 0;\n        //对调用方法里的每一个参数，处理绑定\n&nbsp; &nbsp; &nbsp; &nbsp; for (Parameter methodParameter : methodParameters) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Object methodParamObj = methodParameter.getType().newInstance();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n            //给这个参数创建WebDataBinder\n            WebDataBinder wdb = binderFactory.createBinder(request,&nbsp;\nmethodParamObj, methodParameter.getName());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wdb.bind(request);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; methodParamObjs[i] = methodParamObj;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; Method invocableMethod = handlerMethod.getMethod();\n&nbsp; &nbsp; &nbsp; &nbsp; Object returnObj = invocableMethod.invoke(handlerMethod.getBean(), methodParamObjs);\n&nbsp; &nbsp; &nbsp; &nbsp; response.getWriter().append(returnObj.toString());\n&nbsp; &nbsp; }\n</code></pre><p>在invokeHandlerMethod 方法的实现代码中，methodParameters 变量用来存储调用方法的所有参数，针对它们进行循环，还有一个变量methodParamObj，是一个新创建的空对象，也是我们需要进行绑定操作的目标，binderFactory.createBinder则是创建了WebDtaBinder，对目标对象进行绑定。整个循环结束之后，Request里面的参数就绑定了调用方法里的参数，之后就可以被调用。</p><p>我们从这个绑定过程中可以看到，循环过程就是按照参数在方法中出现的次序逐个绑定的，所以这个次序是很重要的。</p><h2>客户化转换器</h2><p>现在我们已经实现了Request数据绑定过程，也提供了默认的CustomNumberEditor和StringEditor，来进行数字和字符串两种类型的转换，从而把ServletRequest里的请求参数转换成Java对象里的数据类型。但这种默认的方式比较固定，如果你希望转换成自定义的类型，那么原有的两个Editor就没办法很好地满足需求了。</p><p>因此我们要继续探讨，如何支持自定义的Editor，让我们的框架具有良好的扩展性。其实上面我们看到PropertyEditorRegistrySupport里，已经提前准备好了客户化转换器的地方，你可以看下代码。</p><pre><code class=\"language-java\">public class PropertyEditorRegistrySupport {\n    private Map&lt;Class&lt;?&gt;, PropertyEditor&gt; defaultEditors;\n    private Map&lt;Class&lt;?&gt;, PropertyEditor&gt; customEditors;\n</code></pre><p>我们利用客户化Editor这个“口子”，新建一个部件，把客户自定义的Editor注册进来就可以了。</p><p>我们先在原有的WebDataBinder 类里，增加registerCustomEditor方法，用来注册自定义的Editor，你可以看一下相关代码。</p><pre><code class=\"language-java\">public void registerCustomEditor(Class&lt;?&gt; requiredType, PropertyEditor&nbsp;propertyEditor) {\n&nbsp; &nbsp;   getPropertyAccessor().registerCustomEditor(requiredType, propertyEditor); &nbsp;\n}\n</code></pre><p>在这里，可以自定义属于我们自己的CustomEditor ，比如在com.test 包路径下，自定义CustomDateEditor，这是一个自定义的日期格式处理器，来配合我们的测试。</p><pre><code class=\"language-java\">package com.test;\n\nimport java.text.NumberFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Date;\nimport com.minis.beans.PropertyEditor;\nimport com.minis.util.NumberUtils;\nimport com.minis.util.StringUtils;\n\npublic class CustomDateEditor implements PropertyEditor {&nbsp; &nbsp; &nbsp;\n    private Class&lt;Date&gt; dateClass;\n&nbsp; &nbsp; private DateTimeFormatter datetimeFormatter;\n&nbsp; &nbsp; private boolean allowEmpty;\n&nbsp; &nbsp; private Date value;\n\tpublic CustomDateEditor() throws IllegalArgumentException {\n\t\tthis(Date.class, \"yyyy-MM-dd\", true);\n\t}\t\t\n\tpublic CustomDateEditor(Class&lt;Date&gt; dateClass) throws IllegalArgumentException {\n\t\tthis(dateClass, \"yyyy-MM-dd\", true);\n\t}\t\t\n\tpublic CustomDateEditor(Class&lt;Date&gt; dateClass,\n\t\t\t\t&nbsp; boolean allowEmpty) throws IllegalArgumentException {\n\t\tthis(dateClass, \"yyyy-MM-dd\", allowEmpty);\n\t}\t\n\tpublic CustomDateEditor(Class&lt;Date&gt; dateClass,\n\t\t\t\tString pattern, boolean allowEmpty) throws IllegalArgumentException {\n\t\tthis.dateClass = dateClass;\n\t\tthis.datetimeFormatter = DateTimeFormatter.ofPattern(pattern);\n\t\tthis.allowEmpty = allowEmpty;\n\t}\n&nbsp; &nbsp; public void setAsText(String text) {\n\t\tif (this.allowEmpty &amp;&amp; !StringUtils.hasText(text)) {\n\t\t\tsetValue(null);\n\t\t}\t\t\t\n\t\telse {\n\t\t\tLocalDate localdate = LocalDate.parse(text, datetimeFormatter);\n\t\t\tsetValue(Date.from(localdate.atStartOfDay(ZoneId.systemDefault()).toInstant()));\n\t\t}\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public void setValue(Object value) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n            this.value = (Date) value;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public String getAsText() {\n&nbsp; &nbsp; &nbsp; &nbsp; Date value = this.value;\n\t\tif (value == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\tLocalDate localDate = value.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();\n\t\t\treturn localDate.format(datetimeFormatter);\n\t\t}\n&nbsp; &nbsp; }\n&nbsp; &nbsp; public Object getValue() {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        return this.value;\n&nbsp; &nbsp; }\n}\n</code></pre><p>程序也比较简单，用DateTimeFormatter来转换字符串和日期就可以了。<br>\n接下来我们定义一个WebBindingInitializer，其中有一个initBinder实现方法，为自定义的CustomEditor注册做准备。</p><pre><code class=\"language-java\">public interface WebBindingInitializer {&nbsp; &nbsp; &nbsp;\n    void initBinder(WebDataBinder binder); \n}\n</code></pre><p>下面，我们再实现WebBindingInitializer接口，在实现方法initBinder里，注册自定义的CustomDateEditor，你可以看下相关代码。</p><pre><code class=\"language-java\">package com.test;\n\nimport java.util.Date;\nimport com.minis.web.WebBindingInitializer;\nimport com.minis.web.WebDataBinder;\n\npublic class DateInitializer implements WebBindingInitializer{\n\tpublic void initBinder(WebDataBinder binder) {\n\t\tbinder.registerCustomEditor(Date.class, new CustomDateEditor(Date.class,\"yyyy-MM-dd\", false));\n\t}\n}\n\n</code></pre><p>通过上述实现可以看到，我们自定义了“yyyy-MM-dd”这样一种日期格式，也可以根据具体业务需要，自定义其他日期格式。</p><p>然后，我们要使用它们，回到RequestMappingHandlerAdapter 这个类里，新增WebBindingInitializer 的属性定义，调整原有的RequestMappingHandlerAdapter(WebApplicationContext wac)这个构造方法的具体实现，你可以看下调整后的代码。</p><pre><code class=\"language-java\">&nbsp; &nbsp; public RequestMappingHandlerAdapter(WebApplicationContext wac) {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.wac = wac;\n &nbsp; &nbsp; &nbsp; this.webBindingInitializer = (WebBindingInitializer)&nbsp;\nthis.wac.getBean(\"webBindingInitializer\");\n&nbsp; &nbsp; }\n</code></pre><p>其实也就是增加了webBindingInitializer属性的设置。</p><p>然后再利用IoC容器，让这个构造方法，支持用户通过applicationContext.xml 配置webBindingInitializer，我们可以在applicationContext.xml里新增下面这个配置。</p><pre><code class=\"language-xml\">&lt;bean id=\"webBindingInitializer\" class=\"com.test.DateInitializer\"&gt;&nbsp; &nbsp; &lt;/bean&gt;\n</code></pre><p>最后我们只需要在BeanWrapperImpl 实现类里，修改setPropertyValue(PropertyValue pv)这个方法的具体实现，把最初我们直接获取DefaultEditor的代码，改为先获取CustomEditor ，如果它不存在，再获取DefaultEditor，你可以看下相关实现。</p><pre><code class=\"language-java\">&nbsp; &nbsp; public void setPropertyValue(PropertyValue pv) {\n&nbsp; &nbsp; &nbsp; &nbsp; BeanPropertyHandler propertyHandler = new BeanPropertyHandler(pv.getName());&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        PropertyEditor pe = this.getCustomEditor(propertyHandler.getPropertyClz());&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n        if (pe == null) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pe = this.getDefaultEditor(propertyHandler.getPropertyClz());&nbsp;&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; pe.setAsText((String) pv.getValue());\n&nbsp; &nbsp; &nbsp; &nbsp; propertyHandler.setValue(pe.getValue());\n}\n</code></pre><p>改造后，就能支持用户自定义的CustomEditor ，增强了扩展性。同样的类型，如果既有用户自定义的实现，又有框架默认的实现，那用户自定义的优先。</p><p>到这里，传入参数的处理问题我们就探讨完了。</p><h2>小结</h2><p>这节课，我们重点探讨了MVC里前后端参数的自动转换，把Request里的参数串自动转换成调用方法里的参数对象。</p><p>为了完成传入参数的自动绑定，我们使用了WebDataBinder，它内部用BeanWrapperImpl对象，把属性值的map绑定到目标对象上。绑定的过程中，要对每一种数据类型分别进行格式转换，对基本的标准数据类型，由框架给定默认的转换器，但是对于别的数据类型或者是文化差异很大的数据类型，如日期型，我们可以通过CustomEditor机制让用户自定义。</p><p>通过数据的自动绑定，我们不用再通过request.getParameter()方法手动获取参数值，再手动转成对象了，这些HTTP请求里的参数值就自动变成了后端方法里的参数对象值，非常便利。实际上后面我们会看到，这种两层之间的数据自动绑定和转换，在许多场景中都非常有用，比如Jdbc Template。所以这节课的内容需要你好好消化，灵活运用。</p><p>完整源代码参见 <a href=\"https://github.com/YaleGuo/minis\">https://github.com/YaleGuo/minis</a></p><h2>课后题</h2><p>学完这节课的内容，我也给你留一道思考题。我们现在的实现是把Request里面的参数值，按照内部的次序隐含地自动转成后台调用方法参数对象中的某个属性值，那么可不可以使用一个手段，让程序员手动指定某个调用方法的参数跟哪个Request参数进行绑定呢？欢迎你在留言区和我交流讨论，也欢迎你把这节课分享给需要的朋友。我们下节课见！</p>","neighbors":{"left":{"article_title":"09｜分解Dispatcher：如何把专门的事情交给专门的部件去做？","id":644976},"right":{"article_title":"11｜ModelAndView ：如何将处理结果返回给前端？","id":645019}},"comments":[{"had_liked":false,"id":372170,"user_name":"梦某人","can_delete":false,"product_type":"c1","uid":3228991,"ip_address":"河北","ucode":"D9F14B15AC2A12","user_header":"https://static001.geekbang.org/account/avatar/00/31/45/3f/e4fc2781.jpg","comment_is_top":false,"comment_ctime":1680798533,"is_pvip":false,"replies":[{"id":135840,"content":"你的思考是对的，目前处理不了简单类型，也处理不了多参数。前几年的线下课这是作为学院扩展练习布置的。你考虑到了，想得很细，学思练，一定会收益很大。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680862834,"ip_address":"澳大利亚","comment_id":372170,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"目前这个似乎并不能完成对基本类型的转换，反而似乎要处理的是复合类型的转换？当然也可能是我代码和理解存在问题。\n目前逻辑上是： Adapter 中对参数进行处理，对于每个参数都有一个 WebDataBinder 进行处理，而这个类在做类型绑定的时候，主要是通过 BeanWrapperImpl 类来进行处理，此时，每个 WebDataBinder 和 BeanWrapperImpl 内的 clazz 指向的都是这个参数的类，基本类型在这里会是一个 String、Long 之类的。 在 BeanWrapperImpl 的 setPropertyValue 方法中，主要是借助于由请求转换而来的 PropertyValue 类，这个PropertyValue 主要有 name 和value 是请求中的请求名和参数，并调用了 BeanPropertyHandler 以 PropertyValue 的 name 值进行处理。 BeanPropertyHandler 首先 根据请求名找到这个请求参数的类里面对应名称的 Field，再根据 Field 获取对应的 clazz，然后使用 Editor 的 getValue 来进行类型转换， 使用 set 方法进行赋值，然后使用对应属性的  get 进行取值操作。\n但是基本类型没有 setString 和 getString 之类的情况。。。。。所以他反而没办法处理相对基础的类型。\n解决方案应该是考虑配置默认类型的 writemethod 和 readmethod，，优化 BeanPropertyHandler 类。\n\n现在给我的感觉就是 卡在了两头中间，类型转换可以完成，也能从请求中取到值，可以根据方法的参数列表构建对应的类型，但是中间基础类型的绑定的这一块是卡住无法处理的，就是基本类型是有问题的。\n\n最后是思考题，如果要处理顺序问题，那么应该是在 apater中处理方法参数上的标记，根据注解或者标记来调整顺序。比如设置一个注解，指定同一类型的不同参数的名称，或者是指定顺序。然后在 adapter 中拿到方法后，根据注解重排这个方法的参数列表顺序。\n","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612715,"discussion_content":"你的思考是对的，目前处理不了简单类型，也处理不了多参数。前几年的线下课这是作为学院扩展练习布置的。你考虑到了，想得很细，学思练，一定会收益很大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680862834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372002,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1680591937,"is_pvip":false,"replies":[{"id":135788,"content":"赞！这是我喜欢的教学相长。学手艺就要这么眼脑手结合在一起，自己动手，而不是简单听讲，光看光听是学不会的。你的这个问题，后面都有改。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680644230,"ip_address":"澳大利亚","comment_id":372002,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"this.webBindingInitializer = (WebBindingInitializer) this.webApplicationContext.getBean(&quot;webBindingInitializer&quot;);\n这段代码错误的原因是上一章节的DispatcherServlet文件\n  protected void refresh() {\n        &#47;&#47; 初始化 controller\n        initController();\n\n        initHandlerMappings(this.webApplicationContext);\n        initHandlerAdapters(this.parentApplicationContext);\n    }\n这个地方传递的容器不正确导致的，因为这两个容器一个是配置文件applicationContext.xml解析bean容器，一个是包扫描controller的bean容器。而webBindingInitializer这个bean的定义在applicationContext.xml配置文件中，所以传入webApplicationContext这个容器对象是获取不到的。改为parentApplicationContext就可以正确执行下去。可能后面章节还会改，但是本章节的内容结束出现了这个问题。","like_count":2,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612392,"discussion_content":"赞！这是我喜欢的教学相长。学手艺就要这么眼脑手结合在一起，自己动手，而不是简单听讲，光看光听是学不会的。你的这个问题，后面都有改。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680644230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2849121,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/79/61/c5cda164.jpg","nickname":"zzw","note":"","ucode":"80B8AC2E99E588","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623995,"discussion_content":"你说的不对\ninitHandlerAdapters(this.webApplicationContext);也是可以的\n第一步：webBindingInitializer在子容器（webApplicationContext）找不到\n第二部：子容器有父容器parentApplicationContext，会继续从父容器中找","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1690105117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2682971,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f0/5b/791d0f5e.jpg","nickname":"云从","note":"","ucode":"96442F21D37C0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620891,"discussion_content":"我debug 了半天才发现是这个问题 好处是对结构更明白了，之前一知半解的东西更清楚了一点，坏处是真的考验耐心","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1686648596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374644,"user_name":"lmnsds","can_delete":false,"product_type":"c1","uid":1069422,"ip_address":"北京","ucode":"0ED5B1443059DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/6e/757d42a0.jpg","comment_is_top":false,"comment_ctime":1684249926,"is_pvip":false,"replies":[{"id":136753,"content":"对。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1684404410,"ip_address":"澳大利亚","comment_id":374644,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"WebDataBinder类决定了本文的效果：\n    - controller函数只能是一个自定义对象类型，且只能有一个参数\n    - request中的参数不能名不能是参数对象中没有的成员名称，否则会报错","like_count":1,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":618647,"discussion_content":"对。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684404410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372729,"user_name":"风轻扬","can_delete":false,"product_type":"c1","uid":1542987,"ip_address":"北京","ucode":"DB972F2DF059C4","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","comment_is_top":false,"comment_ctime":1681491024,"is_pvip":false,"replies":[{"id":136082,"content":"翻译问题各自有习惯，你的翻译挺好。其实术语用英文原文更好，我线下课所有术语名词都是英语。\nsetAccessible是笔误，copy后没改。是不是public都用一下是个习惯。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681563015,"ip_address":"澳大利亚","comment_id":372729,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"这一讲，学到了以下知识点：\n1)、如何将请求参数封装到实体类的字段上\n2)、用接口，不要用实现类，增加扩展性\nSpring框架真是应了现在很流行的一句服务标语：把困难留给自己，把方便带给客户。\n另外，有2个问题，请教老师：\n1)、为什么要翻译成客户化转换器呢?翻译成自定义转换器是不是更容易理解一点?\n2)、BeanWrapperImpl中的getValue方法中,是一个笔误吗?应该是readMethod.setAccessible吧?另外,正常情况下,对外提供的set、get方法都是public的,不需要setAccessible为true了吧?","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613876,"discussion_content":"翻译问题各自有习惯，你的翻译挺好。其实术语用英文原文更好，我线下课所有术语名词都是英语。\nsetAccessible是笔误，copy后没改。是不是public都用一下是个习惯。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681563016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/15ab499a.jpg","nickname":"风轻扬","note":"","ucode":"DB972F2DF059C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":614067,"discussion_content":"嗯嗯，好的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681656671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":613876,"ip_address":"北京","group_id":0},"score":614067,"extra":""}]}]},{"had_liked":false,"id":372396,"user_name":"袁帅","can_delete":false,"product_type":"c1","uid":1084993,"ip_address":"北京","ucode":"A71A89B9F1BD69","user_header":"https://static001.geekbang.org/account/avatar/00/10/8e/41/709e9677.jpg","comment_is_top":false,"comment_ctime":1681097099,"is_pvip":false,"replies":[{"id":135930,"content":"简单类型是有问题的，你看一下复杂对象的测试。简单类型和多参数，都是线下班的扩展练习。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681123390,"ip_address":"澳大利亚","comment_id":372396,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"@RequestMapping(&quot;&#47;test3&quot;)\n\tpublic String doTest3(Integer a) {}\n参数是Integer  methodParameter.getType().newInstance();  这行会报错啊\njava.lang.NoSuchMethodException: java.lang.Integer.&lt;init&gt;()","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":613085,"discussion_content":"简单类型是有问题的，你看一下复杂对象的测试。简单类型和多参数，都是线下班的扩展练习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681123390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2849121,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/79/61/c5cda164.jpg","nickname":"zzw","note":"","ucode":"80B8AC2E99E588","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624008,"discussion_content":"什么线下班？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690111262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":372366,"user_name":"不是早晨，就是黄昏","can_delete":false,"product_type":"c1","uid":2645005,"ip_address":"河南","ucode":"B7132BA7740AFE","user_header":"https://static001.geekbang.org/account/avatar/00/28/5c/0d/9ec703ab.jpg","comment_is_top":false,"comment_ctime":1681031556,"is_pvip":false,"replies":[{"id":135910,"content":"感谢建议，我们后面把测试写得明细一点。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1681043909,"ip_address":"澳大利亚","comment_id":372366,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"所以我们应该怎么测试呢，在浏览器中输入的地址中参数应该是什么，应该给以下测试程序，来梳理整个流程，否则很乱","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612966,"discussion_content":"感谢建议，我们后面把测试写得明细一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1681043909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371956,"user_name":"马儿","can_delete":false,"product_type":"c1","uid":2247080,"ip_address":"四川","ucode":"542E23D7B6AB01","user_header":"","comment_is_top":false,"comment_ctime":1680545999,"is_pvip":false,"replies":[{"id":135768,"content":"用心了，高质量问题，你的理解都是对的。对基本类型的支持和多参数支持，这是扩展练习。MiniSpring是供学习用的，当时的线下班需要学员过程中补充更多特性。这就是我强调的眼脑手结合。我一直认为，编程是手工活儿，有点像学木匠，站在一边看师傅打家具是不能真掌握的这门手艺的，要自己动手。赞你。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680587591,"ip_address":"澳大利亚","comment_id":371956,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"感觉这节课的内容还是有点难懂.目前自己梳理了一下逻辑。大概有以下几个问题，希望老师能抽空解答一下\n1.现在的代码似乎不能够解析基本类型，只能解析复杂类型。按照代码逻辑应该是将所有属性绑定到一个复杂类型中去，如果方法参数是基本类型就会报错NoSuchField\n2.如果是复杂类型controller中每个参数都通过createbinder创建了WebDataBinder，但是WebDataBinder#BeanWrapperImpl每次都重新创建了BeanWrapperImpl对象，导致初始注册的CustomEditor在后续注册的时候并没有生效。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612276,"discussion_content":"用心了，高质量问题，你的理解都是对的。对基本类型的支持和多参数支持，这是扩展练习。MiniSpring是供学习用的，当时的线下班需要学员过程中补充更多特性。这就是我强调的眼脑手结合。我一直认为，编程是手工活儿，有点像学木匠，站在一边看师傅打家具是不能真掌握的这门手艺的，要自己动手。赞你。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680587591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2543552,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cf/c0/6b45853e.jpg","nickname":"Geek_bai","note":"","ucode":"BABED41D473964","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":651839,"discussion_content":"问题二：创建了两个 BeanWrapperImpl 对象，导致自定义转换器绑定不到数据，建议参考源代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1727531535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371873,"user_name":"Geek_xbye50","can_delete":false,"product_type":"c1","uid":1006424,"ip_address":"福建","ucode":"0BF3780C247F22","user_header":"","comment_is_top":false,"comment_ctime":1680481105,"is_pvip":false,"replies":[{"id":135652,"content":"对。不过要进一步想想在程序哪个地方修改才能支持这个注解。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1680499722,"ip_address":"澳大利亚","comment_id":371873,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"增加一个类似requestParam的注解","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":612039,"discussion_content":"对。不过要进一步想想在程序哪个地方修改才能支持这个注解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1680499722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374642,"user_name":"lmnsds","can_delete":false,"product_type":"c1","uid":1069422,"ip_address":"北京","ucode":"0ED5B1443059DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/51/6e/757d42a0.jpg","comment_is_top":false,"comment_ctime":1684249114,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"http:&#47;&#47;localhost:8080&#47;test4?name=yourname&amp;id=2&amp;birthday=2023-05-16\n可以使用如上url进行测试\n“&#47;test4”对应的controller method 要以User为参数。User是定义在test.entity下的类。","like_count":1},{"had_liked":false,"id":376332,"user_name":"云从","can_delete":false,"product_type":"c1","uid":2682971,"ip_address":"四川","ucode":"96442F21D37C0F","user_header":"https://static001.geekbang.org/account/avatar/00/28/f0/5b/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1686711752,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100536701,"comment_content":"自定义CustomEditor时，记得在RequestMappingHandlerAdapter的invokeHandlerMethod（） 方法里面初始化一下\n&#47;&#47;注册binder中的editor-- 自定义editer\n            webBindingInitializer.initBinder(wdb);","like_count":0},{"had_liked":false,"id":371998,"user_name":"C.","can_delete":false,"product_type":"c1","uid":1444698,"ip_address":"江苏","ucode":"5AE269220EFD73","user_header":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","comment_is_top":false,"comment_ctime":1680589892,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100536701,"comment_content":"this.webBindingInitializer = (WebBindingInitializer) this.wac.getBean(&quot;webBindingInitializer&quot;);这段代码在这个章节结束执行报错，No bean,而且出现了这个情况getBean了好多次HelloWorldBean。\n\nwebBindingInitializer bean created. com.minis.test.DateInitializer : com.minis.test.DateInitializer@305bb0d\nhandle properties for bean: webBindingInitializer\n bean registerded............. webBindingInitializer\nContext Refreshed...\ncom.minis.test.controller.HelloWorldBean bean created. com.minis.test.controller.HelloWorldBean : com.minis.test.controller.HelloWorldBean@4852cf8d\nhandle properties for bean: com.minis.test.controller.HelloWorldBean\n bean registerded............. com.minis.test.controller.HelloWorldBean\n[2023-04-04 02:29:06,605] 工件 mini-spring:war: 工件已成功部署\n[2023-04-04 02:29:06,605] 工件 mini-spring:war: 部署已花费 553 毫秒\ncom.minis.test.controller.HelloWorldBean bean created. com.minis.test.controller.HelloWorldBean : com.minis.test.controller.HelloWorldBean@71e1b60b\nhandle properties for bean: com.minis.test.controller.HelloWorldBean\n bean registerded............. com.minis.test.controller.HelloWorldBean\ncom.minis.test.controller.HelloWorldBean bean created. com.minis.test.controller.HelloWorldBean : com.minis.test.controller.HelloWorldBean@4ab383d7\nhandle properties for bean: com.minis.test.controller.HelloWorldBean\n bean registerded............. com.minis.test.controller.HelloWorldBean\ncom.minis.test.controller.HelloWorldBean bean created. com.minis.test.controller.HelloWorldBean : com.minis.test.controller.HelloWorldBean@6962cf89\nhandle properties for bean: com.minis.test.controller.HelloWorldBean\n bean registerded............. com.minis.test.controller.HelloWorldBean\ncom.minis.test.controller.HelloWorldBean bean created. com.minis.test.controller.HelloWorldBean : com.minis.test.controller.HelloWorldBean@1256dc01\nhandle properties for bean: com.minis.test.controller.HelloWorldBean\n bean registerded............. com.minis.test.controller.HelloWorldBean","like_count":0}]}