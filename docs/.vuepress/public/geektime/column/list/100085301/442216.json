{"id":442216,"title":"33｜并发处理（上）：从atomics到Channel，Rust都提供了什么工具？","content":"<p>你好，我是陈天。</p><p>不知不觉我们已经并肩作战三十多讲了，希望你通过这段时间的学习，有一种“我成为更好的程序员啦！”这样的感觉。这是我想通过介绍 Rust 的思想、处理问题的思路、设计接口的理念等等传递给你的。如今，我们终于来到了备受期待的并发和异步的篇章。</p><p>很多人分不清并发和并行的概念，Rob Pike，Golang 的创始人之一，对此有很精辟很直观的解释：</p><blockquote>\n<p>Concurrency is about&nbsp;<strong>dealing with</strong>&nbsp;lots of things at once. Parallelism is about&nbsp;<strong>doing</strong>&nbsp;lots of things at once.</p>\n</blockquote><p>并发是一种同时处理很多事情的能力，并行是一种同时执行很多事情的手段。</p><p>我们把要做的事情放在多个线程中，或者多个异步任务中处理，这是并发的能力。在多核多 CPU 的机器上同时运行这些线程或者异步任务，是并行的手段。可以说，并发是为并行赋能。当我们具备了并发的能力，并行就是水到渠成的事情。</p><p>其实之前已经涉及了很多和并发相关的内容。比如用 std::thread 来创建线程、用 std::sync 下的并发原语（Mutex）来处理并发过程中的同步问题、用 Send/Sync trait 来保证并发的安全等等。</p><!-- [[[read_end]]] --><p>在处理并发的过程中，<strong>难点并不在于如何创建多个线程来分配工作，在于如何在这些并发的任务中进行同步</strong>。我们来看并发状态下几种常见的工作模式：自由竞争模式、map/reduce 模式、DAG 模式：<br>\n<img src=\"https://static001.geekbang.org/resource/image/00/58/003294c9ba4b291e47585fa1a599a358.jpg?wh=2364x1142\" alt=\"\"></p><p>在自由竞争模式下，多个并发任务会竞争同一个临界区的访问权。任务之间在何时、以何种方式去访问临界区，是不确定的，或者说是最为灵活的，只要在进入临界区时获得独占访问即可。</p><p>在自由竞争的基础上，我们可以限制并发的同步模式，典型的有 map/reduce 模式和 DAG 模式。map/reduce 模式，把工作打散，按照相同的处理完成后，再按照一定的顺序将结果组织起来；DAG 模式，把工作切成不相交的、有依赖关系的子任务，然后按依赖关系并发执行。</p><p>这三种基本模式组合起来，可以处理非常复杂的并发场景。所以，当我们处理复杂问题的时候，应该<strong>先厘清其脉络，用分治的思想把问题拆解成正交的子问题，然后组合合适的并发模式来处理这些子问题</strong>。</p><p>在这些并发模式背后，都有哪些并发原语可以为我们所用呢，这两讲会重点讲解和深入五个概念Atomic、Mutex、Condvar、Channel 和 Actor model。今天先讲前两个Atomic和Mutex。</p><h2>Atomic</h2><p>Atomic 是所有并发原语的基础，它为并发任务的同步奠定了坚实的基础。</p><p>谈到同步，相信你首先会想到锁，所以在具体介绍 atomic 之前，我们从最基本的锁该如何实现讲起。自由竞争模式下，我们需要用互斥锁来保护某个临界区，使进入临界区的任务拥有独占访问的权限。</p><p>为了简便起见，在获取这把锁的时候，如果获取不到，就一直死循环，直到拿到锁为止（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=de58e0ed23b546b3025c566ecbded4e5\">代码</a>）：</p><pre><code class=\"language-rust\">use std::{cell::RefCell, fmt, sync::Arc, thread};\n\nstruct Lock&lt;T&gt; {\n    locked: RefCell&lt;bool&gt;,\n    data: RefCell&lt;T&gt;,\n}\n\nimpl&lt;T&gt; fmt::Debug for Lock&lt;T&gt;\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"Lock&lt;{:?}&gt;\", self.data.borrow())\n    }\n}\n\n// SAFETY: 我们确信 Lock&lt;T&gt; 很安全，可以在多个线程中共享\nunsafe impl&lt;T&gt; Sync for Lock&lt;T&gt; {}\n\nimpl&lt;T&gt; Lock&lt;T&gt; {\n    pub fn new(data: T) -&gt; Self {\n        Self {\n            data: RefCell::new(data),\n            locked: RefCell::new(false),\n        }\n    }\n\n    pub fn lock(&amp;self, op: impl FnOnce(&amp;mut T)) {\n        // 如果没拿到锁，就一直 spin\n        while *self.locked.borrow() != false {} // **1\n\n        // 拿到，赶紧加锁\n        *self.locked.borrow_mut() = true; // **2\n\n        // 开始干活\n        op(&amp;mut self.data.borrow_mut()); // **3\n\n        // 解锁\n        *self.locked.borrow_mut() = false; // **4\n    }\n}\n\nfn main() {\n    let data = Arc::new(Lock::new(0));\n\n    let data1 = data.clone();\n    let t1 = thread::spawn(move || {\n        data1.lock(|v| *v += 10);\n    });\n\n    let data2 = data.clone();\n    let t2 = thread::spawn(move || {\n        data2.lock(|v| *v *= 10);\n    });\n    t1.join().unwrap();\n    t2.join().unwrap();\n\n    println!(\"data: {:?}\", data);\n}\n</code></pre><p>这段代码模拟了 Mutex 的实现，它的核心部分是 lock() 方法。</p><p>我们之前说过，Mutex 在调用 lock() 后，会得到一个 MutexGuard 的 RAII 结构，这里为了简便起见，要求调用者传入一个闭包，来处理加锁后的事务。<strong>在 lock() 方法里，拿不到锁的并发任务会一直 spin，拿到锁的任务可以干活，干完活后会解锁，这样之前 spin 的任务会竞争到锁，进入临界区</strong>。</p><p>这样的实现看上去似乎问题不大，但是你细想，它有好几个问题：</p><ol>\n<li>在多核情况下，<code>**1</code> 和 <code>**2</code> 之间，有可能其它线程也碰巧 spin 结束，把 locked 修改为 true。这样，存在多个线程拿到这把锁，破坏了任何线程都有独占访问的保证。</li>\n<li>即便在单核情况下，<code>**1</code> 和 <code>**2</code> 之间，也可能因为操作系统的可抢占式调度，导致问题1发生。</li>\n<li>如今的编译器会最大程度优化生成的指令，如果操作之间没有依赖关系，可能会生成乱序的机器码，比如<code>**3</code> 被优化放在 <code>**1</code> 之前，从而破坏了这个 lock 的保证。</li>\n<li>即便编译器不做乱序处理，CPU 也会最大程度做指令的乱序执行，让流水线的效率最高。同样会发生 3 的问题。</li>\n</ol><p>所以，我们实现这个锁的行为是未定义的。可能大部分时间如我们所愿，但会随机出现奇奇怪怪的行为。一旦这样的事情发生，bug 可能会以各种不同的面貌出现在系统的各个角落。而且，这样的 bug 几乎是无解的，因为它很难稳定复现，表现行为很不一致，甚至，只在某个 CPU 下出现。</p><p>这里再强调一下 unsafe 代码需要足够严谨，需要非常有经验的工程师去审查，这段代码之所以破快了并发安全性，是因为我们错误地认为：为 Lock&lt;T&gt; 实现 Sync，是安全的。</p><p>为了解决上面这段代码的问题，我们必须在 CPU 层面做一些保证，让某些操作成为原子操作。</p><p>最基础的保证是：<strong>可以通过一条指令读取某个内存地址，判断其值是否等于某个前置值，如果相等，将其修改为新的值。这就是 Compare-and-swap 操作，简称</strong><a href=\"https://en.wikipedia.org/wiki/Compare-and-swap\">CAS</a>。它是操作系统的几乎所有并发原语的基石，使得我们能实现一个可以正常工作的锁。</p><p>所以，刚才的代码，我们可以把一开始的循环改成：</p><pre><code class=\"language-rust\">while self\n\t.locked\n\t.compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed)\n\t.is_err() {}\n</code></pre><p>这句的意思是：如果 locked 当前的值是 <code>false</code>，就将其改成 <code>true</code>。这整个操作在一条指令里完成，不会被其它线程打断或者修改；如果 locked 的当前值不是 <code>false</code>，那么就会返回错误，我们会在此不停 spin，直到前置条件得到满足。这里，<code>compare_exchange</code> 是 Rust 提供的 CAS 操作，它会被编译成 CPU 的对应 CAS 指令。</p><p>当这句执行成功后，locked 必然会被改变为 <code>true</code>，我们成功拿到了锁，而任何其他线程都会在这句话上 spin。</p><p>同样在释放锁的时候，相应地需要使用 atomic 的版本，而非直接赋值成 <code>false</code>：</p><pre><code class=\"language-rust\">self.locked.store(false, Ordering::Release);\n</code></pre><p>当然，为了配合这样的改动，我们还需要把 locked 从 <code>bool</code> 改成 <code>AtomicBool</code>。在 Rust里，<code>std::sync::atomic</code> 有大量的 atomic 数据结构，对应各种基础结构。我们看使用了 AtomicBool 的新实现（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9636a125b2104ab203fb6a9d536f3cf6\">代码</a>）：</p><pre><code class=\"language-rust\">use std::{\n    cell::RefCell,\n    fmt,\n    sync::{\n        atomic::{AtomicBool, Ordering},\n        Arc,\n    },\n    thread,\n};\n\nstruct Lock&lt;T&gt; {\n    locked: AtomicBool,\n    data: RefCell&lt;T&gt;,\n}\n\nimpl&lt;T&gt; fmt::Debug for Lock&lt;T&gt;\nwhere\n    T: fmt::Debug,\n{\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"Lock&lt;{:?}&gt;\", self.data.borrow())\n    }\n}\n\n// SAFETY: 我们确信 Lock&lt;T&gt; 很安全，可以在多个线程中共享\nunsafe impl&lt;T&gt; Sync for Lock&lt;T&gt; {}\n\nimpl&lt;T&gt; Lock&lt;T&gt; {\n    pub fn new(data: T) -&gt; Self {\n        Self {\n            data: RefCell::new(data),\n            locked: AtomicBool::new(false),\n        }\n    }\n\n    pub fn lock(&amp;self, op: impl FnOnce(&amp;mut T)) {\n        // 如果没拿到锁，就一直 spin\n        while self\n            .locked\n            .compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed)\n            .is_err()\n        {} // **1\n\n        // 已经拿到并加锁，开始干活\n        op(&amp;mut self.data.borrow_mut()); // **3\n\n        // 解锁\n        self.locked.store(false, Ordering::Release);\n    }\n}\n\nfn main() {\n    let data = Arc::new(Lock::new(0));\n\n    let data1 = data.clone();\n    let t1 = thread::spawn(move || {\n        data1.lock(|v| *v += 10);\n    });\n\n    let data2 = data.clone();\n    let t2 = thread::spawn(move || {\n        data2.lock(|v| *v *= 10);\n    });\n    t1.join().unwrap();\n    t2.join().unwrap();\n\n    println!(\"data: {:?}\", data);\n}\n</code></pre><p>可以看到，通过使用 <code>compare_exchange</code> ，规避了 1 和 2 面临的问题，但对于和编译器/CPU自动优化相关的 3 和 4，我们还需要一些额外处理。这就是这个函数里额外的两个和 <code>Ordering</code> 有关的奇怪参数。</p><p>如果你查看 atomic 的文档，可以看到 <a href=\"https://doc.rust-lang.org/std/sync/atomic/enum.Ordering.html\">Ordering</a> 是一个 enum：</p><pre><code class=\"language-rust\">pub enum Ordering {\n    Relaxed,\n    Release,\n    Acquire,\n    AcqRel,\n    SeqCst,\n}\n</code></pre><p>文档里解释了几种 Ordering 的用途，我来稍稍扩展一下。</p><p>第一个Relaxed，这是最宽松的规则，它对编译器和 CPU 不做任何限制，可以乱序执行。</p><p>Release，当我们<strong>写入数据</strong>（比如上面代码里的 store）的时候，如果用了 <code>Release</code> order，那么：</p><ul>\n<li>对于当前线程，任何读取或写入操作都不能被乱序排在这个 store <strong>之后</strong>。也就是说，在上面的例子里，CPU 或者编译器不能把 <code>**3</code> 挪到 <code>**4</code> 之后执行。</li>\n<li>对于其它线程，如果使用了 <code>Acquire</code> 来读取这个 atomic 的数据， 那么它们看到的是修改后的结果。上面代码我们在 <code>compare_exchange</code> 里使用了 <code>Acquire</code> 来读取，所以能保证读到最新的值。</li>\n</ul><p>而Acquire是当我们<strong>读取数据</strong>的时候，如果用了 <code>Acquire</code> order，那么：</p><ul>\n<li>对于当前线程，任何读取或者写入操作都不能被乱序排在这个读取<strong>之前</strong>。在上面的例子里，CPU 或者编译器不能把 <code>**3</code> 挪到 <code>**1</code> 之前执行。</li>\n<li>对于其它线程，如果使用了 <code>Release</code> 来修改数据，那么，修改的值对当前线程可见。</li>\n</ul><p>第四个AcqRel是Acquire 和 Release 的结合，同时拥有 Acquire 和 Release 的保证。这个一般用在 <code>fetch_xxx</code> 上，比如你要对一个 atomic 自增 1，你希望这个操作之前和之后的读取或写入操作不会被乱序，并且操作的结果对其它线程可见。</p><p>最后的SeqCst是最严格的 ordering，除了 <code>AcqRel</code> 的保证外，它还保证所有线程看到的所有 <code>SeqCst</code> 操作的顺序是一致的。</p><p><strong>因为 CAS 和 ordering 都是系统级的操作，所以这里描述的 Ordering 的用途在各种语言中都大同小异</strong>。对于 Rust 来说，它的 atomic 原语<a href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\">继承于 C++</a>。如果读 Rust 的文档你感觉云里雾里，那么 C++ 关于 ordering 的文档要清晰得多。</p><p>其实上面获取锁的 spin 过程性能不够好，更好的方式是这样处理一下：</p><pre><code class=\"language-rust\">while self\n    .locked\n    .compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed)\n    .is_err()\n{\n    // 性能优化：compare_exchange 需要独占访问，当拿不到锁时，我们\n    // 先不停检测 locked 的状态，直到其 unlocked 后，再尝试拿锁\n    while self.locked.load(Ordering::Relaxed) == true {}\n}\n</code></pre><p>注意，我们在 while loop 里，又嵌入了一个 loop。这是因为 CAS 是个代价比较高的操作，它需要获得对应内存的独占访问（exclusive access），我们希望失败的时候只是简单读取 atomic 的状态，只有符合条件的时候再去做独占访问，进行 CAS。所以，看上去多做了一层循环，实际代码的效率更高。</p><p>以下是两个线程同步的过程，一开始 t1 拿到锁、t2 spin，之后 t1 释放锁、t2 进入到临界区执行：<br>\n<img src=\"https://static001.geekbang.org/resource/image/5f/62/5fc2678a12c993768365851fe5531662.jpg?wh=2364x1625\" alt=\"\"></p><p>讲到这里，相信你对 atomic 以及其背后的 CAS 有初步的了解了。那么，atomic 除了做其它并发原语，还有什么作用？</p><p>我个人用的最多的是做各种 lock-free 的数据结构。比如，需要一个全局的 ID 生成器。当然可以使用 UUID 这样的模块来生成唯一的 ID，但如果我们同时需要这个 ID 是有序的，那么 <code>AtomicUsize</code> 就是最好的选择。</p><p>你可以用 <code>fetch_add</code> 来增加这个 ID，而 <code>fetch_add</code> 返回的结果就可以用于当前的 ID。这样，不需要加锁，就得到了一个可以在多线程中安全使用的 ID 生成器。</p><p>另外，atomic 还可以用于记录系统的各种 metrics。比如一个简单的 in-memory Metrics 模块：</p><pre><code class=\"language-rust\">use std::{\n    collections::HashMap,\n    sync::atomic::{AtomicUsize, Ordering},\n};\n\n// server statistics\npub struct Metrics(HashMap&lt;&amp;'static str, AtomicUsize&gt;);\n\nimpl Metrics {\n    pub fn new(names: &amp;[&amp;'static str]) -&gt; Self {\n        let mut metrics: HashMap&lt;&amp;'static str, AtomicUsize&gt; = HashMap::new();\n        for name in names.iter() {\n            metrics.insert(name, AtomicUsize::new(0));\n        }\n        Self(metrics)\n    }\n\n    pub fn inc(&amp;self, name: &amp;'static str) {\n        if let Some(m) = self.0.get(name) {\n            m.fetch_add(1, Ordering::Relaxed);\n        }\n    }\n\n    pub fn add(&amp;self, name: &amp;'static str, val: usize) {\n        if let Some(m) = self.0.get(name) {\n            m.fetch_add(val, Ordering::Relaxed);\n        }\n    }\n\n    pub fn dec(&amp;self, name: &amp;'static str) {\n        if let Some(m) = self.0.get(name) {\n            m.fetch_sub(1, Ordering::Relaxed);\n        }\n    }\n\n    pub fn snapshot(&amp;self) -&gt; Vec&lt;(&amp;'static str, usize)&gt; {\n        self.0\n            .iter()\n            .map(|(k, v)| (*k, v.load(Ordering::Relaxed)))\n            .collect()\n    }\n}\n</code></pre><p>它允许你初始化一个全局的 metrics 表，然后在程序的任何地方，无锁地操作相应的 metrics：</p><pre><code class=\"language-rust\">lazy_static! {\n    pub(crate) static ref METRICS: Metrics = Metrics::new(&amp;[\n        \"topics\",\n        \"clients\",\n        \"peers\",\n        \"broadcasts\",\n        \"servers\",\n        \"states\",\n        \"subscribers\"\n    ]);\n}\n\nfn main() {\n    METRICS.inc(\"topics\");\n    METRICS.inc(\"subscribers\");\n\n    println!(\"{:?}\", METRICS.snapshot());\n}\n</code></pre><p>完整代码见 <a href=\"https://github.com/tyrchen/geektime-rust\">GitHub repo</a> 或者 <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=5299292be00c8e897360e1b05387670e\">playground</a>。</p><h2>Mutex</h2><p>Atomic 虽然可以处理自由竞争模式下加锁的需求，但毕竟用起来不那么方便，我们需要更高层的并发原语，来保证软件系统控制多个线程对同一个共享资源的访问，使得每个线程在访问共享资源的时候，可以独占或者说互斥访问（mutual exclusive access）。</p><p>我们知道，对于一个共享资源，如果所有线程只做读操作，那么无需互斥，大家随时可以访问，很多 immutable language（如 Erlang / Elixir）做了语言层面的只读保证，确保了并发环境下的无锁操作。这牺牲了一些效率（常见的 list/hashmap 需要使用 <a href=\"https://en.wikipedia.org/wiki/Persistent_data_structure\">persistent data structure</a>），额外做了不少内存拷贝，换来了并发控制下的简单轻灵。</p><p>然而，<strong>一旦有任何一个或多个线程要修改共享资源，不但写者之间要互斥，读写之间也需要互斥</strong>。毕竟如果读写之间不互斥的话，读者轻则读到脏数据，重则会读到已经被破坏的数据，导致 crash。比如读者读到链表里的一个节点，而写者恰巧把这个节点的内存释放掉了，如果不做互斥访问，系统一定会崩溃。</p><p>所以操作系统提供了用来解决这种读写互斥问题的基本工具：Mutex（RwLock 我们放下不表）。</p><p>其实上文中，为了展示如何使用 atomic，我们制作了一个非常粗糙简单的 SpinLock，就可以看做是一个广义的 Mutex。<strong>SpinLock</strong>，顾名思义，就是线程通过 CPU 空转（spin，就像前面的 while loop）忙等（busy wait），来等待某个临界区可用的一种锁。</p><p>然而，这种通过 SpinLock 做互斥的实现方式有使用场景的限制：如果受保护的临界区太大，那么整体的性能会急剧下降， CPU 忙等，浪费资源还不干实事，不适合作为一种通用的处理方法。</p><p>更通用的解决方案是：当多个线程竞争同一个 Mutex 时，获得锁的线程得到临界区的访问，其它线程被挂起，放入该 Mutex 上的一个等待队列里。<strong>当获得锁的线程完成工作，退出临界区时，Mutex 会给等待队列发一个信号，把队列中第一个线程唤醒</strong>，于是这个线程可以进行后续的访问。整个过程如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/54/dc/54caee8ebf240e2812da0022cb099bdc.jpg?wh=2364x1142\" alt=\"\"></p><p>我们前面也讲过，线程的上下文切换代价很大，所以频繁将线程挂起再唤醒，会降低整个系统的效率。所以很多 Mutex 具体的实现会将 SpinLock（确切地说是 spin wait）和线程挂起结合使用：<strong>线程的 lock 请求如果拿不到会先尝试 spin 一会，然后再挂起添加到等待队列</strong>。Rust 下的 <a href=\"https://github.com/Amanieu/parking_lot\">parking_lot</a> 就是这样实现的。</p><p>当然，这样实现会带来公平性的问题：如果新来的线程恰巧在 spin 过程中拿到了锁，而当前等待队列中还有其它线程在等待锁，那么等待的线程只能继续等待下去，这不符合 FIFO，不适合那些需要严格按先来后到排队的使用场景。为此，parking_lot 提供了 fair mutex。</p><p>Mutex 的实现依赖于 CPU 提供的 atomic。你可以把 Mutex 想象成一个粒度更大的 atomic，只不过这个 atomic 无法由 CPU 保证，而是通过软件算法来实现。</p><p>至于操作系统里另一个重要的概念信号量（semaphore），你可以认为是 Mutex 更通用的表现形式。比如在新冠疫情下，图书馆要控制同时在馆内的人数，如果满了，其他人就必须排队，出来一个才能再进一个。这里，如果总人数限制为 1，就是 Mutex，如果 &gt; 1，就是 semaphore。</p><h2>小结</h2><p>今天我们学习了两个基本的并发原语 Atomic 和 Mutex。Atomic 是一切并发同步的基础，通过CPU 提供特殊的 CAS 指令，操作系统和应用软件可以构建更加高层的并发原语，比如 SpinLock 和 Mutex。</p><p>SpinLock和 Mutex 最大的不同是，<strong>使用 SpinLock，线程在忙等（busy wait），而使用 Mutex lock，线程在等待锁的时候会被调度出去，等锁可用时再被调度回来</strong>。</p><p>听上去 SpinLock 似乎效率很低，其实不是，这要具体看锁的临界区大小。如果临界区要执行的代码很少，那么和 Mutex lock 带来的上下文切换（context switch）相比，SpinLock 是值得的。在 Linux Kernel 中，很多时候我们只能使用 SpinLock。</p><h3>思考题</h3><p>你可以想想可以怎么实现 semaphore，也可以想想像图书馆里那样的人数控制系统怎么用信号量实现（提示：Rust 下 tokio 提供了 <a href=\"https://docs.rs/tokio/1.13.0/tokio/sync/struct.Semaphore.html\">tokio::sync::Semaphore</a>）。</p><p>欢迎在留言区分享你的思考，感谢你的阅读。下一讲我们继续学习并发的另外三个概念Condvar、Channel 和 Actor model，下一讲见～</p><h3>参考资料</h3><ol>\n<li>Robe Pike的演讲 <a href=\"https://go.dev/blog/waza-talk\">concurrency is not parallelism</a>，如果你没有看过，建议去看看。</li>\n<li>通过今天的例子，相信你对 atomic 以及其背后的 CAS 有个初步的了解，如果你还想更深入学习 Rust 下如何使用 atomic，可以看 Jon Gjengset 的视频：<a href=\"https://www.youtube.com/watch?v=rMGWeSjctlY\">Crust of Rust: Atomics and Memory Ordering</a>。</li>\n<li>Rust 的 <a href=\"https://github.com/mvdnes/spin-rs\">spin-rs crate</a> 提供了 Spinlock 的实现，感兴趣的可以看看它的实现。</li>\n</ol>","neighbors":{"left":{"article_title":"32｜实操项目：使用PyO3开发Python3模块","id":437569},"right":{"article_title":"34｜并发处理（下）：从atomics到Channel，Rust都提供了什么工具？","id":442217}},"comments":[{"had_liked":false,"id":321782,"user_name":"Ethan Liu","can_delete":false,"product_type":"c1","uid":1070043,"ip_address":"","ucode":"231F944F7CD56A","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","comment_is_top":false,"comment_ctime":1637045681,"is_pvip":true,"replies":[{"id":"116885","content":"文中已经讲了，Rust 的优点是所有方案都支持，缺点是你需要考虑合适的场景用合适的工具，另外 Rust channel 在某些情况下性能不如 golang；golang  的优点是简单，CSP 一招鲜，大部分场景 channel  都能很好适用，缺点是遇到 channel 不好解决的问题，或者效率不高的问题，就比较尴尬","user_name":"作者回复","comment_id":321782,"uid":"1079375","ip_address":"","utype":1,"ctime":1637077496,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"23111882161","product_id":100085301,"comment_content":"rust相比go在并发处理上 有什么优点和缺点？","like_count":6,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530498,"discussion_content":"文中已经讲了，Rust 的优点是所有方案都支持，缺点是你需要考虑合适的场景用合适的工具，另外 Rust channel 在某些情况下性能不如 golang；golang  的优点是简单，CSP 一招鲜，大部分场景 channel  都能很好适用，缺点是遇到 channel 不好解决的问题，或者效率不高的问题，就比较尴尬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637077496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326910,"user_name":"Geek_b52974","can_delete":false,"product_type":"c1","uid":1298252,"ip_address":"","ucode":"59884399646620","user_header":"","comment_is_top":false,"comment_ctime":1639745416,"is_pvip":true,"replies":[{"id":"120819","content":"👍","user_name":"作者回复","comment_id":326910,"uid":"1079375","ip_address":"","utype":1,"ctime":1642311219,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5934712712","product_id":100085301,"comment_content":"作業:<br>use std::sync::Arc;<br><br>use tokio::{sync::Semaphore, task::JoinHandle};<br><br>#[tokio::main]<br>async fn main() {<br>    let library = Box::new(Library::new(3));<br>    let mut tasks: Vec&lt;JoinHandle&lt;()&gt;&gt; = vec![];<br>    for i in 0..10 {<br>        tasks.push(library.enter(move || println!(&quot;no: {}, borrow book&quot;, i)));<br>    }<br>    for task in tasks {<br>        task.await.unwrap();<br>    }<br>    println!(&quot;{:?}&quot;, library.semaphore.available_permits());<br>}<br><br>struct Library {<br>    semaphore: Arc&lt;Semaphore&gt;,<br>}<br><br>impl Library {<br>    fn new(capacity: usize) -&gt; Self {<br>        Self {<br>            semaphore: Arc::new(Semaphore::new(capacity)),<br>        }<br>    }<br><br>    fn enter(&amp;self, chore: impl Fn() + Send + &#39;static) -&gt; JoinHandle&lt;()&gt; {<br>        let semaphore = self.semaphore.clone();<br>        tokio::spawn(async move {<br>            &#47;&#47; remove this you will get panic<br>            &#47;&#47; semaphore.close();<br>            println!(&quot;{} quota left&quot;, semaphore.available_permits());<br>            let s = semaphore.acquire_owned().await.unwrap();<br>            chore();<br>            drop(s);<br>        })<br>    }<br>}","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546462,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642311219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321394,"user_name":"D. D","can_delete":false,"product_type":"c1","uid":2186992,"ip_address":"","ucode":"C416E5602C8814","user_header":"https://static001.geekbang.org/account/avatar/00/21/5e/f0/62d8cf9e.jpg","comment_is_top":false,"comment_ctime":1636827889,"is_pvip":true,"replies":[{"id":"118929","content":"👍","user_name":"作者回复","comment_id":321394,"uid":"1079375","ip_address":"","utype":1,"ctime":1639853726,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5931795185","product_id":100085301,"comment_content":"既然 Semaphore 是 Mutex 的推广，那么实现的思路应该有点类似。<br>参考老师文章中所说的 Mutex 的实现方法，实现 Semaphore 的一个思路是：<br>我们可以用一个 AtomicUsize 记录可用的 permits 的数量。在获取 permits 的时候，如果无法获取到足够的 permits，就把当前线程挂起，放入 Semaphore 的一个等待队列里。获取到 permits 的线程完成工作后退出临界区时，Semaphore 给等待队列发送信号，把队头的线程唤醒。<br><br>至于像图书馆那样的人数控制系统，tokio 的 Semaphore 文档中使用 Semaphore::acquire_owned 的例子可以说就是这种场景的模拟。","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539890,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639853727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321212,"user_name":"终生恻隐","can_delete":false,"product_type":"c1","uid":2739953,"ip_address":"","ucode":"4E21A631545D22","user_header":"https://static001.geekbang.org/account/avatar/00/29/ce/f1/d2fc86bb.jpg","comment_is_top":false,"comment_ctime":1636709021,"is_pvip":false,"replies":[{"id":"118935","content":"Duration 有 from_secs &#47; from_millis 等方法，不必用 Duration::new，这个接口不直观。","user_name":"作者回复","comment_id":321212,"uid":"1079375","ip_address":"","utype":1,"ctime":1639853864,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5931676317","product_id":100085301,"comment_content":"&#47;&#47; [dependencies]<br>&#47;&#47; tokio = { version = &quot;1&quot;, features = [&quot;full&quot;] }<br>&#47;&#47; chrono = &quot;*&quot;<br><br><br>use tokio::sync::{Semaphore, TryAcquireError};<br>use std::sync::Arc;<br>use std::thread;<br>use std::time::Duration;<br>use chrono::prelude::*;<br><br>#[tokio::main]<br>async fn main() {<br>    let semaphore = Arc::new(Semaphore::new(3));<br>    let mut join_handles = Vec::new();<br><br>    for c in 0..5 {<br>        let permit = semaphore.clone().acquire_owned().await.unwrap();<br>        join_handles.push(tokio::spawn(async move {<br>            let local: DateTime&lt;Local&gt; = Local::now();<br>            println!(&quot;count{} start time: {}&quot;, c+1, local);<br>            thread::sleep(Duration::new(10, 0));<br>            drop(permit);<br>        }));<br>    }<br><br>    for handle in join_handles {<br>        handle.await.unwrap();<br>    }<br>}","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539896,"discussion_content":"Duration 有 from_secs / from_millis 等方法，不必用 Duration::new，这个接口不直观。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639853864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358654,"user_name":"进击的Lancelot","can_delete":false,"product_type":"c1","uid":2620407,"ip_address":"广东","ucode":"3BCC355801DC61","user_header":"https://static001.geekbang.org/account/avatar/00/27/fb/f7/88ab6f83.jpg","comment_is_top":false,"comment_ctime":1664519594,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1664519594","product_id":100085301,"comment_content":"作业：https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=453c39051a8257931b0cb167bf8fc60f","like_count":0},{"had_liked":false,"id":351280,"user_name":"ELSE","can_delete":false,"product_type":"c1","uid":1172907,"ip_address":"","ucode":"72448D7271C8B0","user_header":"https://static001.geekbang.org/account/avatar/00/11/e5/ab/56f348e5.jpg","comment_is_top":false,"comment_ctime":1657675722,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657675722","product_id":100085301,"comment_content":"golang不是也支持atomic, mutex这些原语吗，为什么说遇到channel不好解决的时候就比较尴尬呢，不好理解","like_count":0},{"had_liked":false,"id":348904,"user_name":"BeCool","can_delete":false,"product_type":"c1","uid":1474104,"ip_address":"","ucode":"0A62B0C2ABE28D","user_header":"https://static001.geekbang.org/account/avatar/00/16/7e/38/ae659af9.jpg","comment_is_top":false,"comment_ctime":1655533985,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1655533985","product_id":100085301,"comment_content":"老师，我是刚学习的萌新，想问下，这段代码有时候是100有时候是10，正常吗","like_count":0,"discussions":[{"author":{"id":1192115,"avatar":"","nickname":"preston","note":"","ucode":"A98A587D4B716C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581102,"discussion_content":"是正常的，因为线程的join不等于马上就调用，具体会先调用谁要看系统调度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658496443,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347186,"user_name":"菅田","can_delete":false,"product_type":"c1","uid":1228201,"ip_address":"","ucode":"75668DE75FF7BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/bd/a9/688b9bc6.jpg","comment_is_top":false,"comment_ctime":1653803634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653803634","product_id":100085301,"comment_content":"看了一遍老师的文章之后结合crust的youtube视频，有一点还是没弄明白：什么情况下可以不使用SeqCst？<br>还有我对Ordering的理解是否正确：<br>1. Ordering 是对同一个Atomic的值的使用的限制，如果涉及多个atomic的值时应该使用SeqCst来保证顺序；<br>2. 在对同一个值读写时，load时使用Acquire，在store时使用Release，用这Acquire 、Release代码包裹起来中间的读写操作是安全的？比方说：<br>```<br>while !x.load(Ordering::Acquire) {<br>}<br>x.store(&#47;** );**&#47;<br>x.store(&#47;** );**&#47;<br>x.store(&#47;** );**&#47; &#47;&#47; 这三句store都是安全的，在被别的线程load的时候都是在x.store(1)之后的结果？其他线程在此期间不会插入进来；<br>x.store(1, Ordering::Release);<br><br>```","like_count":0},{"had_liked":false,"id":342911,"user_name":"Geek_9f3c8c","can_delete":false,"product_type":"c1","uid":2342031,"ip_address":"","ucode":"6E4E43E9504749","user_header":"","comment_is_top":false,"comment_ctime":1650530988,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650530988","product_id":100085301,"comment_content":"该文章关于CAS的代码示例似乎并未实现线程间同步，只是实现了对临界区访问的互斥。该示例运行结果可能是100或者10。","like_count":0},{"had_liked":false,"id":330584,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1642057433,"is_pvip":true,"replies":[{"id":"120685","content":"对","user_name":"作者回复","comment_id":330584,"uid":"1079375","ip_address":"","utype":1,"ctime":1642292639,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1642057433","product_id":100085301,"comment_content":"cas是指令集指令提供的能力 一般语言封装的并发原语都是在这个基础上的","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546294,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642292639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330142,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1641812541,"is_pvip":false,"replies":[{"id":"120701","content":"👍","user_name":"作者回复","comment_id":330142,"uid":"1079375","ip_address":"","utype":1,"ctime":1642293587,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1641812541","product_id":100085301,"comment_content":"感觉和java对应的功能，原理一致","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546310,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642293588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324854,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1638688510,"is_pvip":false,"replies":[{"id":"118858","content":"不分场合地使用 Relaxed，会导致不一致的更新；不分场合地使用 SeqCst，会导致性能问题。","user_name":"作者回复","comment_id":324854,"uid":"1079375","ip_address":"","utype":1,"ctime":1639848182,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1638688510","product_id":100085301,"comment_content":"另外关于Ordering那几个的区别，个人写代码的时候，绝大部分时候，要么最简单的Relaxed，要么最严格的SeqCst，剩下的，不一定考虑那么多，除非特殊需要才去查一下区别，平时记不住的。。。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539818,"discussion_content":"不分场合地使用 Relaxed，会导致不一致的更新；不分场合地使用 SeqCst，会导致性能问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639848182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324853,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1638688346,"is_pvip":false,"replies":[{"id":"118856","content":"不是。atomic operation 是硬件提供的无法被中断打断的指令，并不是去关闭中断。<br>这里我们用 atomic 实现的 mutex，就是一个 spinlock。","user_name":"作者回复","comment_id":324853,"uid":"1079375","ip_address":"","utype":1,"ctime":1639848097,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1638688346","product_id":100085301,"comment_content":"理解一下，对于所谓的指令原子操作，在计算机底层里面，没记错就是中断总线关闭吧。<br><br>然后那段优化的代码，就是拿不到锁先while空转一下，这里就有点像java的自旋锁的概念那样。<br>当然这里为什么空转性能会比spin好，从系统的角度理解，空转没有调用系统调用，那么就没有太多的进程或者线程切换，而切换这个是涉及上下文变更的。不管进程还是线程，上下文切换的时候，其实五大结构都是要考虑的，例如信号量那些是否要保存起来等等，那样代码自然会大很多了。<br><br>不知道这样理解是否对哈。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539816,"discussion_content":"不是。atomic operation 是硬件提供的无法被中断打断的指令，并不是去关闭中断。\n这里我们用 atomic 实现的 mutex，就是一个 spinlock。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639848097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321778,"user_name":"Geek_b52974","can_delete":false,"product_type":"c1","uid":1298252,"ip_address":"","ucode":"59884399646620","user_header":"","comment_is_top":false,"comment_ctime":1637044058,"is_pvip":true,"replies":[{"id":"118915","content":"你可以详细看文档：https:&#47;&#47;doc.rust-lang.org&#47;std&#47;sync&#47;atomic&#47;struct.AtomicBool.html#method.compare_exchange","user_name":"作者回复","comment_id":321778,"uid":"1079375","ip_address":"","utype":1,"ctime":1639852711,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1637044058","product_id":100085301,"comment_content":"compare_exchange(false, true, Ordering::Acquire, Ordering::Relaxed)<br>想问一下第三个参数 为何不是 acqRel，这样其他线程会知道吗？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539876,"discussion_content":"你可以详细看文档：https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.compare_exchange","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639852712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321161,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1636695041,"is_pvip":false,"replies":[{"id":"118936","content":"嗯","user_name":"作者回复","comment_id":321161,"uid":"1079375","ip_address":"","utype":1,"ctime":1639853871,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":2,"score":"1636695041","product_id":100085301,"comment_content":"CAS 的原理挺绕的，需要好好的消化，最近也在看“Go 并发实战课”，有一些互通的地方。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539897,"discussion_content":"嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639853871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}