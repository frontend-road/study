{"id":782323,"title":"17｜函数闭包：函数式编程的重要支撑","content":"<p>你好，我是海纳。</p><p>我们通过前面那么多节课的努力，先后实现了函数调用、内建方法、函数传参等特性。在虚拟机中，函数机制的实现都离不开 FunctionObject 和 FrameObject 这两个对象。</p><p>有了 FunctionObject，一个函数就可以像普通的整数或者字符串那样，作为参数传递给另外一个函数，也可以作为返回值被传出函数。所以，在 Python 语言中，函数也和整数类型、字符串类型一样，是<strong>第一类公民（first class citizen）</strong>。</p><p>把函数作为第一类公民，使新的编程范式成为可能，但它也引入了一些必须要解决的问题，例如自由变量和闭包的问题。这节课我们就先来实现它。</p><h2>函数闭包</h2><p>在函数中查找变量的时候，遵循 LEBG 规则。其中 L 代表局部变量，E 代表闭包变量（Enclosing），G 代表全局变量，B 则代表虚拟机内建变量。</p><p>在<a href=\"https://time.geekbang.org/column/article/776961\">第 11 课</a>，我们提到了全局变量和局部变量，但当时没有解释闭包变量是什么，这节课我们专门研究闭包变量的功能和影响。我们先来看一个最简单的例子。</p><pre><code class=\"language-python\">def func():\n&nbsp; &nbsp; x = 2\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; def say():\n&nbsp; &nbsp; &nbsp; &nbsp; print(x)\n\n&nbsp; &nbsp; return say\n\nf = func()\nf()\n</code></pre><p>运行这个例子，最后一行会打印出 2。</p><p>首先，调用 func 的时候，得到返回值是在 func 函数内部定义的函数 say。所以变量 f（第 9 行）指向的是函数 say，调用它的时候就会打印 2（第 10 行）。</p><!-- [[[read_end]]] --><p>也就是说，当 say 函数在 func 函数的定义之外执行的时候，依然可以访问到 x 的值。这就好像在定义 say 函数的时候，把 x 和 say 打包在一起了，我们把这个包裹叫做闭包（closure）。</p><p>我们再把这段代码翻译成 pyc 文件，然后通过 show_file 工具查看它的内容。我给出了 func 函数的字节码，你可以看一下。</p><pre><code class=\"language-plain\">&nbsp; &nbsp; &nbsp; code\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;argcount 0\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nlocals 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stacksize 3\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;flags 0003\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;code ...\n&nbsp; 2&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (2)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 STORE_DEREF&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (x)\n\n&nbsp; 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 LOAD_CLOSURE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (x)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 BUILD_TUPLE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 (&lt;code object say&gt;)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 ('func.&lt;locals&gt;.say')\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 MAKE_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 (closure)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 STORE_FAST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (say)\n\n&nbsp; 7&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 16 LOAD_FAST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (say)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;18 RETURN_VALUE\n.....\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;names ()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;varnames ('say',)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;freevars ()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cellvars ('x',)\n</code></pre><p>这里出现了两个新的字节码：STORE_DEREF 和 LOAD_CLOSURE。还有 func 所对应的 CodeObject 的 cellvars 也不为空，这是我们第一次遇到这种情况。</p><p>cellvars 里的变量是在本函数中定义，在内部函数中被引用的。在这个例子中，只有一个 x，说明内部函数所引用的本地定义变量只有 x 一个。这种会被内部函数引用的变量就是 cell 变量。</p><p>接下来，我们从头开始完整地梳理一遍字节码。STORE_DEREF 是为 x 赋值（第 8 行），因为 x 是 cell 变量，Python 专门为 cell 变量引入了一类新的字节码。</p><p>然后虚拟机通过 LOAD_CLOSURE 又把 x 加载到操作数栈上（第 10 行），接下来 BUILD_TUPLE 参数为 1，代表了创建一个列表，列表中只有一个元素，那就是 x。</p><p>接着就是加载 CodeObject 到栈顶（第 12 行），然后加载一个字符串到栈顶（第 13 行），这个字符串代表了函数的全名，或者叫做限定名称。限定名会把函数所在的命名空间都带上，例如这个例子中的 say 函数就是定义在 func 函数中，作为它的局部变量。所以，它的全量限定名就是 <code>“func.&lt;locals&gt;.say”</code>。</p><p>最后执行 MAKE_FUNCTION 创建一个 FunctionObject（第 14 行）。这个例子里的参数有点特殊，它的值是 0x8。</p><p>我们知道 MAKE_FUNCTION 指令的操作数代表了创建函数对象时提供的默认参数的个数，当操作数为 1 时，代表要创建的函数带有默认参数，而且默认参数的值以列表的形式提供。</p><p>Python 3.8 则采用 0x8 这个特殊值来代表当前创建的函数对象是一个闭包对象，而不是一个普通的函数对象。</p><p>MAKE_FUNCTION 指令会把刚才放在栈顶的那个 cell 变量列表也打包塞进 FunctionObject 中。这种把外部定义的变量一起打包的情况就是闭包。理解了这些字节码的具体动作以后，我们就能实现它们了。</p><h2>闭包功能的总体设计</h2><p>闭包的功能比较复杂，所以在动手实现之前，我们先来完成总体的架构设计。这里我举一个具体的例子，配合多张图片来说明闭包功能的执行步骤。</p><pre><code class=\"language-python\">def func():\n    x = 2\n    \n    def foo():\n        nonlocal x\n        x += 1\n        return x\n\n    return foo\n</code></pre><p>步骤一，在 func 函数中定义 x 变量，使用的是 STORE_DEREF。显然，这里需要为 func 函数的执行环境添加 cell 变量表，以便把 x 的值存放在这里。实际的设计中，我们在 FrameObject 里添加一个名为 _closure 的变量表，来存放 cell 变量。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/8e/a7d63b04a4beb86a14b77aa837f6128e.png?wh=1504x724\" alt=\"图片\"></p><p>步骤二，在定义 foo 函数之前，虚拟机需要使用 LOAD_CLOSURE 把 x 变量加载到栈顶，这一步不能把 x 所代表的整数对象直接加载到栈顶。而是应该把 x 所在的变量表和它的下标保存在 CellObject 里。</p><p>步骤三，使用 MAKE_FUNCTION 创建闭包函数。cell 变量会被打包进 foo 函数对应的 FunctionObject 中。从 func 函数的 FrameObject 到 foo 函数的 FrameObject，需要有一个“邮递员”来传送这些 cell 变量。而这正是 MAKE_FUNCTION 要做的事情。你可以看一下我给出的示意图。</p><p><img src=\"https://static001.geekbang.org/resource/image/85/01/8520460d637193f95937c5cfd75d9801.png?wh=2134x1060\" alt=\"图片\"></p><p>步骤四，在 foo 函数的 FrameObject 里，通过 LOAD_DEREF 从 CellObject 中读取 x 的真实取值，并且把它加上 1，再使用 STORE_DEREF 修改变量 x 的值。假如这个时候，x 的值在 foo 函数外被修改了，由于 cell 变量里保存的是变量表和下标，所以这里的 LOAD_DEREF 也一样可以看到。</p><p><img src=\"https://static001.geekbang.org/resource/image/af/a5/af38a3eca9e81dc0f3b04c4d5ed993a5.png?wh=2134x1060\" alt=\"图片\"></p><p>REF 是 reference 的缩写，是C++语言中“引用”的意思，DEREF 正是解引用的意思。而 cell 变量的作用确实和C++语言里的“引用”功能差不多，所以这个名字非常恰当。</p><p>搞明白了这些关键步骤，我们就可以动手实现闭包函数的功能了。</p><p>首先，我们来实现 CellObject，也就是引用的能力。</p><pre><code class=\"language-c++\">class CellObject : public HiObject {\nfriend class CellKlass;\n\nprivate:\n&nbsp; &nbsp; HiList* _table;\n&nbsp; &nbsp; int _index;\n\npublic:\n&nbsp; &nbsp; CellObject(HiList* l, int i);\n&nbsp; &nbsp; HiObject* value();\n&nbsp; &nbsp; void set_value(HiObject* o);\n};\n</code></pre><p>CellObject 类包含两个成员变量，_table 代表变量所存储的变量表，_index 记录了变量在变量表中的下标。</p><p>value 方法用来从变量表里取出变量，set_value 则用于更新变量表中的值。你可以看一下CellObject 的具体实现。</p><pre><code class=\"language-c++\">CellObject::CellObject(HiList* t, int i) :&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; _table(t), _index(i) {\n&nbsp; &nbsp; set_klass(CellKlass::get_instance());\n}\n\nHiObject* CellObject::value() {\n&nbsp; &nbsp; return _table-&gt;get(_index);\n}\n\nvoid CellObject::set_value(HiObject* o) {\n&nbsp; &nbsp; return _table-&gt;set(_index, o);\n}\n</code></pre><p>接下来，在 FrameObject 中引入了 closure 这个域，来记录所有的 cell 变量。</p><pre><code class=\"language-c++\">FrameObject::FrameObject(CodeObject* codes) {\n    //....\n&nbsp; &nbsp; _closure = nullptr;\n\n&nbsp; &nbsp; HiList* cells = _codes-&gt;_cell_vars;\n&nbsp; &nbsp; if (cells &amp;&amp; cells-&gt;size() &gt; 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; _closure = new HiList();\n\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; cells-&gt;size(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _closure-&gt;append(nullptr);\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; if (func-&gt;closure() &amp;&amp; func-&gt;closure()-&gt;size() &gt; 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; if (_closure == nullptr)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _closure = func-&gt;closure();\n&nbsp; &nbsp; &nbsp; &nbsp; else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _closure = _closure-&gt;add(func-&gt;closure())-&gt;as&lt;HiList&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n    //....\n}\n</code></pre><p>如果有多级嵌套的情况，每一级都有可能出现 cell 变量，所以对于某一个内层的函数来说，它所能使用的 cell 变量可能来自于本层函数，也有可能来自于外层函数。</p><p>Python 虚拟机在执行内层函数的时候，会把它们叠加在一起，按照从外到内的顺序排放，STORE_DEREF 等指令也会按照这个顺序生成操作数。</p><p>所以，我们在创建 FrameObject 的时候，也要按照这样的顺序把变量摆放好。如果本层函数没有定义新的 cell 变量，而外层函数有定义，那就直接使用外层函数的变量表就可以了（第 16 行）。如果本层函数也有定义 cell 变量，那么本层函数的 cell 变量放在前面，外层的放在后面（第 18 行）。注意这里的 add 方法是列表相加，而不是添加一个元素。</p><p>第三步，实现 STORE_DEREF 指令。</p><pre><code class=\"language-c++\">void Interpreter::eval_frame() {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::STORE_DEREF:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = _frame-&gt;closure()-&gt;get(op_arg);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = POP();\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (v == nullptr || v-&gt;klass() != CellKlass::get_instance()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _frame-&gt;closure()-&gt;set(op_arg, w);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v-&gt;as&lt;CellObject&gt;()-&gt;set_value(w);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>STORE_DEREF 的操作数是变量在变量表中的序号。在修改 cell 变量之前，先从变量里取出它的值（第 9 行）。如果这个变量是一个空指针或者是普通变量，这就意味着这个 cell 变量是在当前函数中定义的（第 12 至 14 行），因为这个变量还没有通过 LOAD_CLOSURE 变成 CellObject 传递给内层函数。</p><p>如果这个变量是一个 CellObject，就说明变量是在外层函数中定义的，对这个变量的修改就不能在当前栈帧的 cell 变量表里进行。而是应该通过 set_value 方法修改定义它的地方（第 16 行）。</p><p>第四步，实现 LOAD_CLOSURE 指令，它需要一种新的数据结构，这种数据结构可以记录 cell 变量所在的表和它在表中的序号。通过这种方式，我们模拟了“引用”这一机制。</p><pre><code class=\"language-c++\">void Interpreter::eval_frame() {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::LOAD_CLOSURE:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = _frame-&gt;closure()-&gt;get(op_arg);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (v == NULL) {\n\t\t\t\t&nbsp; &nbsp; v = _frame-&gt;get_cell_from_parameter(op_arg);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _frame-&gt;closure()-&gt;set(op_arg, v);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (v-&gt;klass() == CellKlass::get_instance()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(v);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(new CellObject(_frame-&gt;closure(), op_arg));\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\nHiObject* FrameObject::get_cell_from_parameter(int i) {\n&nbsp; &nbsp; HiObject* cell_name = _codes-&gt;_cell_vars-&gt;get(i);\n&nbsp; &nbsp; i = _codes-&gt;_var_names-&gt;index(cell_name);\n&nbsp; &nbsp; return _fast_locals-&gt;get(i);\n}\n</code></pre><p>这段代码先从 closure 表里取出对应序号的对象（第 9 行）。如果取出来是空值，那就说明这个值不是局部变量，而是一个参数。我们来看一个例子。</p><pre><code class=\"language-python\">def func(x = 5):\n&nbsp; &nbsp; def say():\n&nbsp; &nbsp; &nbsp; &nbsp; print(x)\n\n&nbsp; &nbsp; x = 3\n&nbsp; &nbsp; print(x)\n&nbsp; &nbsp; return say\n</code></pre><p>这段代码中使用的 x 就出现在了入参中，而不是局部变量。这种情况下，我们先把这个 cell 变量从参数列表中取出来，再存入到 closure 表中。这样，LOAD_CLOSURE 指令就可以直接使用 closure 指针和序号值来构建 CellObject 了。get_cell_from_parameter 实现了这个功能。</p><p>如果从 closure 中找不到相应的变量，那就说明这个变量并不是由当前函数定义的，也就是说它并不来自于 STORE_CLOSURE 指令，而是来自外部函数的参数，所以我们在 closure 中找不到变量，就会转而去外部函数的参数列表里查找这个变量（LOAD_CLOSURE 的 第 11 行）。</p><p>最后一步，补全 MAKE_FUNCTION 的功能。当操作数为 0x8 的时候，代表需要向 FunctionObject 里传递 cell 变量表，这是为了把当前函数中定义的 cell 变量表传给被调用的那个函数。</p><pre><code class=\"language-c++\">void Interpreter::eval_frame() {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::MAKE_FUNCTION:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = POP(); // function name\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fo = new FunctionObject(v);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fo-&gt;set_globals(_frame-&gt;globals());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (op_arg &amp; 0x8) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fo-&gt;set_closure(POP()-&gt;as&lt;HiList&gt;());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_arg &amp;= 0x7;\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (op_arg == 1) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HiList* t = POP()-&gt;as&lt;HiList&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args = new ArrayList&lt;HiObject*&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; t-&gt;size(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args-&gt;add(t-&gt;get(i));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fo-&gt;set_default(args);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(fo);\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (args != NULL) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete args;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args = NULL;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>在这里我们又一次请出了 FunctionObject 这个邮递员，在此之前，我们已经把全局变量（第 12 行）和默认参数（第 26 行）都打包进 FunctionObject 里，当真正执行这个函数的时候，才会由这个函数对象创建 FrameObject。</p><p>到这里为止，闭包的功能就实现完成了，在这个基础之上，我们再来研究一种 Python 中特有的语法：<strong>函数修饰器（decorator）</strong>。</p><h2>函数修饰器</h2><p>Python 的函数修饰器是一种特殊类型的函数，它接受另一个函数作为输入参数。这意味着你可以在修饰器内部访问和操作这个被传入的函数。</p><p>装饰器函数执行后，会返回一个新的函数对象。这个新函数通常会在执行原始函数之前或之后添加额外的操作，比如记录日志、性能测试、权限验证等，但最终还是会调用原始函数。</p><p>当使用 @decorator 语法应用装饰器到一个函数上的时候，Python 会用装饰器返回的新函数来替换原始函数。这样一来，每当尝试调用原始函数的时候，实际上是调用了装饰器返回的那个新函数。这里我给你一个具体的例子，你可以看一下。</p><pre><code class=\"language-python\">def call_cnt(fn):\n&nbsp; &nbsp; cnt = 0\n&nbsp; &nbsp; def inner_func(*args):\n&nbsp; &nbsp; &nbsp; &nbsp; nonlocal cnt\n        cnt += 1\n&nbsp; &nbsp; &nbsp; &nbsp; print(cnt)\n&nbsp; &nbsp; &nbsp; &nbsp; return fn(*args)\n\n&nbsp; &nbsp; return inner_func\n\n@call_cnt\ndef add(a, b = 2):&nbsp;\n&nbsp; &nbsp; return a + b&nbsp;\n\nprint add(1, 2)\nprint add(2, 3)\n</code></pre><p>在这个例子中，call_cnt 作为一个函数修饰器可以用来统计某一个方法被调用的次数。例如，使用 call_cnt 修饰了 add 方法以后，每次调用 add 方法，计数器都会加 1，并且计数的值会被打印出来。</p><p>实际上，上面这段代码和下面这行代码是完全等价的，修饰器不过是以下函数调用的一种语法上的简写。我们把这种用于简化代码的语法叫做<strong>语法糖</strong>。</p><pre><code class=\"language-python\">add = call_cnt(add)\n</code></pre><p>也就是说，虚拟机执行 call_cnt 所得到的返回值，替换掉了原来的 add 方法。在这个新的方法里，可以进行计数器加一和打印计数器的值，并且调用老的 add 方法，以保持逻辑上的完全兼容。</p><p>可以看到，在这个例子中，最重要的就是 call_cnt 的返回值本质上是一个闭包，所以当我们实现了闭包的功能以后，函数的修饰器功能也就完成了。</p><p>要真正让这个例子成功运行，还需要补全两个字节码，分别是BUILD_TUPLE_UNPACK_WITH_CALL 和 CALL_FUNCTION_EX。</p><p>前者的作用是把扩展列表参数都整合到一个列表里。后者的作用是使用栈顶的列表作为参数去调用函数。你可以看我给出的这个例子。</p><pre><code class=\"language-python\">def call_ex(a, b, c, d):\n&nbsp; &nbsp; return a + b + c + d\n\nargs = [3, 4]\na = [1, ]\nb = (2, )\nprint(call_ex(*a, *b, *args))\n</code></pre><p>你可以自己使用 Python 3.8 执行这个例子，就会看到 BUILD_TUPLE_UNPACK_WITH_CALL 会把 a、b 和 args 三个列表整合成一个列表。</p><p>而 CALL_FUNCTION_EX 会把最后整合好的列表作为参数传递给 call_ex 函数。</p><p>所以这两个字节码可以这样实现：</p><pre><code class=\"language-c++\">void Interpreter::eval_frame() {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::CALL_FUNCTION_EX:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; assert(op_arg == 0);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args = POP()-&gt;as&lt;HiList&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fo = static_cast&lt;FunctionObject*&gt;(POP());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; build_frame(fo, args, kwargs);\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n        .....\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::BUILD_TUPLE_UNPACK_WITH_CALL:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args = new HiList();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op_arg--;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (op_arg--) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args-&gt;append(w);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args-&gt;append(v);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_extend(args);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = args-&gt;get(0);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; args-&gt;clear();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH(w);\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n        ...\n        }\n    }\n}\n</code></pre><p>因为我们在设计 FrameObject 的时候，就选择了使用列表来传递所有的参数，所以 CALL_FUNCTION_EX 的实现反而变得更简单了，它只需要把列表直接传递给 build_frame 方法就可以了（第 12 行）。</p><p>BUILD_TUPLE_UNPACK_WITH_CALL 的操作数代表了要合并的列表的个数。例如 call_ex 接受了三个列表，那么这里的操作数就是 3。所以上述代码采用了循环语句来不断地把列表向前整合，最终成为一个列表（第 21 至 28 行），最后再把整合完的列表放到栈顶（第 29 行）。</p><p>完成了这些工作，前面的例子就可以正确执行了。</p><h2>总结</h2><p>这节课我们实现了函数闭包的功能。在函数式编程中函数闭包是一个非常常见的概念。闭包本质上是由函数及其相关的引用环境组合而成的实体。简而言之，就是<strong>闭包允许一个函数记住并访问它自身作用域以外的变量</strong>，即便它的外部作用域已经不再存在的时候也是这样。</p><p>闭包通常涉及至少两个函数层次，一个外部函数（封装环境）和一个内部函数（闭包本身）。内部函数可以访问外部函数的变量和参数。在 Python 字节码中，外部函数中定义并且被内部函数使用的变量被记录在 cell_vars 中，我们把它叫做 cell 变量。而对于内部函数，这些变量就是自由变量。自由变量是指在某个作用域内使用的变量，但该变量在这个作用域内并没有被定义或赋值，它的定义存在于当前作用域的外部。</p><p>这节课我们实现了 STORE_DEF、LOAD_CLOSURE、LOAD_DEREF 三个字节码，从而实现了完整的闭包功能。最后，我们这节课也通过补齐一些特殊的字节码，最终实现了函数修饰器的功能。到这里，函数的基本功能就已经全部完成了。从下节课开始，我们会把重点转向对象系统的实现。</p><h2>思考题</h2><p>你知道丘奇数（church number）吗？请你自己动手使用 Lambda 表达式来实现丘奇数，并在我们的虚拟机上做测试，欢迎你把你的实现分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"16｜字典（下）：位置参数和闭包依赖字典实现","id":781345},"right":{"article_title":"18｜类型对象：虚拟机如何识别对象的类型？","id":782484}},"comments":[{"had_liked":false,"id":391521,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"上海","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1718418816,"is_pvip":false,"replies":[{"id":142612,"content":"不是哦。修饰器只是转成了call指令。你再看看编译后的字节码？多写几个例子","user_name":"作者回复","user_name_real":"编辑","uid":1360512,"ctime":1720749265,"ip_address":"上海","comment_id":391521,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"所以可以认为当 一个函数由装饰器修饰时，函数调用对应的字节码由CALL_FUNCTION变为了CALL_FUNCTION_EX，这样就由解释器帮忙把函数调用改为了装饰器封装后的函数？","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647894,"discussion_content":"不是哦。修饰器只是转成了call指令。你再看看编译后的字节码？多写几个例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1720749265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":396206,"user_name":"冯某","can_delete":false,"product_type":"c1","uid":3889476,"ip_address":"上海","ucode":"7E78ECA53DF453","user_header":"https://static001.geekbang.org/account/avatar/00/3b/59/44/727b90a8.jpg","comment_is_top":false,"comment_ctime":1733563360,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"记录一下","like_count":0},{"had_liked":false,"id":395366,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1730441788,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":394673,"user_name":"Geek_3d35fd","can_delete":false,"product_type":"c1","uid":2006671,"ip_address":"北京","ucode":"A6B12DEA5B6EEE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKhqDU299SMLuWE5I3Rc1AGyqraV3v95FVaB9H1konxseOicGicLbQjKvF3G9DtGrZaG9icR0K6zMTYw/132","comment_is_top":false,"comment_ctime":1727530149,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"文中提到的STORE_CLOSURE 在源码中并不存在，是不是STORE_DEREF? ","like_count":0},{"had_liked":false,"id":394462,"user_name":"Geek_66a783","can_delete":false,"product_type":"c1","uid":3882146,"ip_address":"浙江","ucode":"26C66C3EACAE16","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pkjW8zleOmmWAbAMPkshJSFnDcN6d06DrYDeSIibmic2SW05Flv3ic5kLhzcHukia1Y1Ktm4OXdzYsicCnINiaCOeqQQ/132","comment_is_top":false,"comment_ctime":1726850580,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"gitee上LOAD_DEREF字节码的实现似乎有点问题，会导致以下代码无法运行：\ndef foo(x):\n    # x已经被提升为了cell variable，但是在函数栈帧的_closure上还没有记录在案，\n    # 因此若虚拟机通过Load_Deref字节码访问将会导致出错！\n    print(x)\n    def bar():\n        print(x)\n    return bar\nfoo(&quot;Hello World&quot;)\n\n这是我的修改版本：\n            case ByteCode::LOAD_DEREF: {\n                v = _frame-&gt;closure()-&gt;get(op_arg);\n                if (v == nullptr) {\n                    v = _frame-&gt;get_cell_from_parameter(op_arg);\n                    _frame-&gt;closure()-&gt;set(op_arg, v);\n                }\n                if (v-&gt;klass() == CellKlass::get_instance()) {\n                    v = v-&gt;as&lt;CellObject&gt;()-&gt;value();\n                }\n                PUSH(v);\n                break;\n            }","like_count":0}]}