{"id":631500,"title":"29｜限界上下文（中）：限界上下文怎样影响架构设计？","content":"<p>你好，我是钟敬。</p><p>上节课我们学习了“限界上下文”和“上下文映射”两个模式。</p><p>今天我们继续完成“工时管理”上下文，帮你进一步深化这两个概念。然后，我们会根据限界上下文来完成架构设计。由于这个迭代出现了多个上下文，所以架构设计的时候，我们首先要讨论的就是使用单体还是微服务。</p><h2>为“工时项管理”上下文建模</h2><p>沿用上节课的假设，你是开发组长，我是技术骨干，比你先学了一些DDD，我们都是这个项目的第一批成员，共同承担着架构师的职责。</p><p>在为“工时管理”上下文建模之前，我们先回顾一下之前的模型。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/3f/d82d4cd63f78a1ab488435221ac13d3f.jpg?wh=3550x2179\" alt=\"\"></p><p>你思考了一下，问：“工时管理和其他上下文的有一个区别，就是这里多了泛化。那么拆成上下文以后，是不是还要原样保持这个泛化呢？另外，考虑到请假信息也要报工时这个新需求，是不是说请假记录也要作为工时项的子类呢？”</p><p>我说：“让我先试着画一画，再讨论吧。”于是我为工时项管理上下文画出了后面的模型图。</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/66/6a7c2bd3bc372920b99f6e2a97cfbf66.jpg?wh=3118x2324\" alt=\"\"></p><p>看到这张图，你有些疑惑地问：“泛化跑哪儿去了？”接下来，让我们一步一步看一下。</p><h3>“员工”的上下文映射</h3><p>先看个简单的，和“项目管理”上下文一样，<strong>员工</strong>也是从“基础信息管理”上下文映射过来的。</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/04/b4d39c1de3049c3b9e2ca3135abf1504.jpg?wh=2913x2179\" alt=\"\"></p><h3>“工时项”实体</h3><p>下面看比较重要的<strong>工时项</strong>实体。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/30/a2ed1de1f77b2e8d537c07408cf30330.jpg?wh=2913x2179\" alt=\"\"></p><p>请注意，由于现在我们是专门考虑“工时管理”上下文，所以我们不必过多地受到“项目管理”和“假期管理”中概念的“拖累”，而是聚焦在什么样的模型对实现工时管理功能最有利就可以了。</p><!-- [[[read_end]]] --><p>对于报工时的需求而言，项目、子项目、普通工时项等除了用来表示不同工时项的分类以外，并没有其他意义。所以，这时候用特性值来区分就可以了，而不需要泛化。</p><p>我们在工时项上加了一个指向自身的关联，表示工时项的父子关系。增加这一关联有这样几点考量。</p><p>第一，它可以用于表示项目和子项目的父子关系。</p><p>第二，就算不是项目的工时项，也可能有层次关系，现在的设计更有普适性了。</p><p>第三，这个关联可以表达任意深度的层次关系，而不是像项目那样只能表达两层关系。</p><p>我们再看看工时项实体里的这三个属性：<strong>是否可在本级报工时</strong>、<strong>是否要分配成员</strong>、<strong>状态</strong>。</p><p>这三个属性都是可以从“项目管理”上下文中<strong>项目</strong>实体的<strong>工时粒度</strong>、<strong>是否要分配项目成员</strong>和<strong>状态</strong>转换来的，而转换逻辑又不全是直接对应的。现在把这三个属性放在<strong>工时项</strong>，就意味着，有的工时项，即使不是项目，也可能只能在下一级工时项上报工时、也可能要分配成员、也可能在工时项失效后就不能报工时。</p><p>总之，这个设计比原先更灵活，能用在更多的场景，对于 SaaS 系统更加适用。</p><h3>“工时项”的上下文映射</h3><p>再看看工时项的上下文映射。</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/5e/eeacd3a31d7c3e283eb8dc8a6cdd1b5e.jpg?wh=2913x2179\" alt=\"\"></p><p>这个映射的注解比我们之前遇到的要复杂一些，分成了三段。</p><p>第一段说的是普通工时项直接在本上下文中定义，也就是这种情况下，其实并不存在上下文映射。</p><p>第二段说的是和“项目管理”上下文之间的映射。由于逻辑比之前的映射情况更复杂，所以我们为&lt;&lt;map from&gt;&gt;增加了一个 “map logic” 属性，在这里可以用任何形式表示任何你想说明的映射逻辑。目前，我们说明了，项目映射成第一级的工时项，而子项目映射成第二级工时项。前面说的那些属性的转换关系，也发生在这个映射过程中。</p><p>第三段是和“假期管理”上下文的映射。我们目前的策略是，建立一个虚拟的一级工时项“假期”，用来把所有假期工时项归到一起。然后具体的假期种类，比如“年假”“病假”等等，作为“假期”工时项的二级工时项。当然，也可能有些企业不想这么做，而是想直接把“年假”“病假”作为一级工时项。这也没关系，因为目前的模型是支持这种灵活定义的。</p><p>我们对比一下<strong>员工</strong>实体的上下文映射和<strong>工时项</strong>的上下文映射。<strong>员工</strong>虽然在两个上下文之间有映射关系，但至少还是一一对应的。但是这个上下文中的<strong>工时项</strong>实体和“项目管理”上下文里的<strong>项目</strong>实体的关系就不是简单地一一对应了，而且属性的转换也不是那么直接。</p><p>所以，“工时项管理”上下文里的<strong>工时项</strong>和“项目管理”上下文里的<strong>项目</strong>是有转换关系的两个不同的概念。换句话说，这两个概念是不一致的。但是在两个上下文内部，各自的概念则是一致的。说到这里，你对<strong>限界上下文内部概念保持一致，上下文之间的概念不必一致</strong>这句话，是不是理解得更深刻了呢？</p><h3>“工时项成员”的上下文映射</h3><p>最后再看看工时项成员的映射关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/ae/1a3053f8555cd2623b9010f310yy20ae.jpg?wh=2913x2233\" alt=\"\"></p><p>和<strong>工时项</strong>的映射类似，对于普通工时项，如果也要分配人员的话，那么就直接在本上下文里定义。而对于项目，则从“项目管理”上下文的<strong>项目成员</strong>实体映射过来。</p><p>这里我们还要注意，在“项目管理”上下文里，保存了项目成员关系的历史，也就是说，哪怕一个员工已经退出项目了，仍然可以查到他曾经参与过这个项目。但是，这种历史信息对报工时是没有意义的，所以本上下文的<strong>工时项成员</strong>里只保留当前有效的关系就可以了。从这里，我们再一次看到了不一一对应的映射关系。</p><p>至于<strong>工时记录</strong>和请假记录之间的映射也是类似的，这里就不多说了。</p><h2>限界上下文的概念映射图</h2><p>好，我们已经把每个限界上下文内部的领域模型梳理过一遍了，如果还想在全局上描述一下各个上下文的映射关系，那么可以用下面的<strong>上下文概念映射图</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/0e/fd/0e2abcf9cb7264f072ae5bbff3f1f5fd.jpg?wh=3600x2179\" alt=\"\"></p><p>由于《领域驱动设计》原书没有给出正规的表示法，所以这张图也是我根据 UML 的原理自行设计的。</p><p>我们可以用 UML 的依赖，也就是虚线箭头表示映射关系。使用时要注意箭头的方向。UML 里的依赖是由依赖方指向被依赖方。所以，如果一个概念从 A 映射到 B，那么是 B 依赖 A，所以是 B 指向 A。然后，我们给依赖也加上 &lt;&lt;map from&gt;&gt; 衍型。由于上下文已经由箭头指明了，因此注释里不必指出上下文，只写映射逻辑就可以了。</p><h2>限界上下文驱动的架构设计</h2><p>好，到这里我们已经完成了限界上下文的建模，接下来，探讨实现问题。注意，截止到前面上下文映射的内容，仍然是领域专家能够理解的业务概念，所以仍然需要IT人员和领域专家达成一致。但是从现在开始，后面的内容就只是技术人员关注的内容，和领域专家无关了。</p><h3>单体还是微服务</h3><p>首先要考虑的问题是架构设计。在前两个迭代，我们都是在一个上下文里工作，用分层架构就可以了。现在有多个上下文，问题就复杂一些了。我们第一步要决定，对于多个上下文的情况，是采用单体还是微服务架构。</p><p>虽然现在微服务比较流行，不过单体应用并没有“原罪”。到底采用哪种架构还是要综合考虑。比如说，一般在满足后面这些条件时，才应该使用微服务，否则还是用单体架构好些。</p><p>第一，收益大于成本。使用微服务的好处包括容易横向扩容、独立部署、避免系统腐化等等。代价是提高了运维的成本、远程调用增加了性能损耗以及维护最终一致性的复杂性等等。只有在收益大于成本的情况下，才值得使用微服务。</p><p>第二，只有在团队有足够的运维技能和基础设施支持的时候，才能使用微服务。</p><p>第三，只有团队具有一定的开发微服务的技能和经验时，才能使用微服务。</p><p>假如决定使用单体，可以像后面这样画架构图。</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/64/1dcda5c0f34007ca90dbyy2fe762c364.jpg?wh=3600x2179\" alt=\"\"></p><h3>UML组件图</h3><p>这里我们用到了一种之前没用过的 UML 图，叫做组件图（component diagram）。</p><p>在 UML 里，一个组件符号是一个方框，方框的右上角有一个嵌入了两个垂直摆放的小矩形的小方块。</p><p>UML里对“组件”的定义是比较宽泛的。只要是对外暴露接口，对内封装实现的软件单元，都算组件。并没有规定两个组件到底是运行在不同进程，还是同一个进程，也没有规定是运行时动态链接，还是编译时静态链接。</p><p>虽然写得比较好的“类”也符合对外暴露接口，对内封装实现的要求，不过一般来说，组件的颗粒度比类要大。我们可以把组件分成进程内的和进程间的，下面举例说明一下常见的组件类型。</p><p>进程间组件类型可以分为单体应用或者微服务。</p><p>进程内组件类型的例子包括微软早期的 COM 组件、Java 的公共 Jar 包、Java 的 OSGi 模块、Maven 多模块项目中的模块、Java 9 开始提供的内置模块等等。注意，这里说的“模块”，和领域模型图里用来给领域对象分组的“模块”，不是一个层面的概念。前者是实现层面，后者是概念层面。</p><p>UML 里，一般也把系统和子系统当成组件，并且用带有 &lt;&lt;system&gt;&gt; 或 &lt;&lt;subsystem&gt;&gt; 衍型的组件符号来表示。</p><p><img src=\"https://static001.geekbang.org/resource/image/89/05/898c9b33673a3c2f4dd743a9eayy8005.jpg?wh=3600x1703\" alt=\"\"></p><p>不过，UML 里并没有规定到底什么是“系统”和“子系统”，而是把对它们的理解留给了 UML 的用户。</p><p>在前面的单体架构图里，“Unjuanable”（不要卷了）作为一个单体应用，用一个组件符号来表示。为了强调这是一个单体，我用了一个自定义的衍型 &lt;&lt;monolithic&gt;&gt;。</p><p>组件里面是表示限界上下文的 3 个包。我们假定在这个组件的代码里，没有用任何专门的模块机制，所以里面的限界上下文用普通的包图来表示。这也意味着，在代码的目录结构中，在根目录下面，首先为这 3 个上下文建立 3 个包，每个包内部，再按分层架构来进一步分包。</p><p>如果我们用了 Maven 的多模块或者 Java 9 的模块机制来封装各个上下文的代码，那么组件图里可以像这样表示。</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/26/2fa66b0beaae82b9b35ea995c6b16826.jpg?wh=3600x2179\" alt=\"\"></p><p>这个图里 unjuanable 组件里嵌套的不再是包，而是 3 个子组件了。这些子组件的衍型是&lt;&lt;module&gt;&gt; ，以便强调这是 3 个模块。</p><p>至于外面的 leavemng （假期管理）组件，表示一个外部的系统，我们并不关心它是单体还是微服务，所以也就不用泛型了。</p><h2>总结</h2><p>好，这节课的内容先讲到这，下面来总结一下。</p><p>今天我们讲了两个内容，一个是继续完成“工时项管理”上下文的建模，另一个是进行架构设计。</p><p>通过“工时项管理”的建模，我们深入理解了不同上下文之间的概念是怎样“不一致的”。另外，也进一步学习了这种不一致，是如何通过上下文映射来转换的。</p><p>我们还发现，原来工时项管理中的泛化不见了。事实上，原来的泛化逻辑隐含在了<strong>工时项类别</strong>实体以及“项目管理”和“工时管理”两个上下文的映射逻辑中。</p><p>通过聚焦“工时管理”上下文的设计，不受其他上下文概念的干扰，我们得到了一个更加简洁和灵活的设计。</p><p>基于划分出的限界上下文，就可以设计系统的架构了。到底使用微服务还是单体架构需要综合考虑。通常要根据投入产出、人员能力、基础设施等因素做出权衡。</p><p>另外，在 UML 方面，我为你提供了一种在全局上表示上下文间映射关系的方法，还为你演示了如何利用 UML 组件图表示架构设计。你可以课后尝试结合自己的项目画图练习一下。</p><p>下节课，我们会继续讨论微服务的划分。</p><h2>思考题</h2><p>最后我给你留两道思考题。</p><p>1.还记得吗？在之前的模型，如果要查询某个员工可以报工时的工时项，需要 3 条 SQL 语句，而根据现在的设计，只需要 1 条就可以了。你觉得大概应该怎么写这条 SQL 语句呢？</p><p>2.“工时管理”上下文中，工时项的“可否在本级报工时”以及“状态”两个字段，和“项目管理”上下文里的相应字段的映射关系并不那么直接，你觉得转换逻辑应该是怎样的呢？</p><p>好，今天的课程结束了，有什么问题欢迎在评论区留言，下节课，我们来探讨微服务的划分以及限界上下文集成的问题。</p>","comments":[{"had_liked":false,"id":368890,"user_name":"wy","can_delete":false,"product_type":"c1","uid":1843252,"ip_address":"广东","ucode":"AAC3C76852B4EB","user_header":"https://static001.geekbang.org/account/avatar/00/1c/20/34/f6470d0b.jpg","comment_is_top":false,"comment_ctime":1676869432,"is_pvip":false,"replies":[{"id":134349,"content":"这说明您确实有实际项目经验 🐮\n共同提高！","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1676882960,"ip_address":"广东","comment_id":368890,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"来个彩虹屁吧，我感觉关于工时项的相关需求设计得挺好的，很符合目前需求迭代的节奏，而且需要一定的设计能力;\n这部分工时项的需求，看起来很简单(pm角度)，但实际上如果没有良好的设计，我估计实现出来就是依托答辩，后续新增的需求只能是难上加难🤣","like_count":2,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605988,"discussion_content":"这说明您确实有实际项目经验 🐮\n共同提高！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676882960,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369517,"user_name":"赵晏龙","can_delete":false,"product_type":"c1","uid":2673605,"ip_address":"湖南","ucode":"F15730BCA97EE0","user_header":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","comment_is_top":false,"comment_ctime":1677634145,"is_pvip":false,"replies":[{"id":134735,"content":"就目前这个场景，【工时项成员】在【工时项系统】中做冗余比较好些。这是因为，【工时项成员】中的内容，可能不止来源于【项目成员】，还可能有非项目的工时项，也要安排成员。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677920580,"ip_address":"广东","comment_id":369517,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"1、我没有太明白，这个map from 到底是指在子模块中自我维护一个状态，还是从外部接口获取？如项目成员-&gt;工时项成员，【工时项成员】是否需要在【工时项系统】中做冗余？这决定了这道题的答案。按照我的理解，如果需要一条SQL查，隐式的说明这是一个数据库内，也就是一个子系统内。一个join应该就能查出来。\n","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607486,"discussion_content":"就目前这个场景，【工时项成员】在【工时项系统】中做冗余比较好些。这是因为，【工时项成员】中的内容，可能不止来源于【项目成员】，还可能有非项目的工时项，也要安排成员。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1677920580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368861,"user_name":"wy","can_delete":false,"product_type":"c1","uid":1843252,"ip_address":"广东","ucode":"AAC3C76852B4EB","user_header":"https://static001.geekbang.org/account/avatar/00/1c/20/34/f6470d0b.jpg","comment_is_top":false,"comment_ctime":1676816076,"is_pvip":false,"replies":[{"id":134803,"content":"这样就造成了项目管理对工时项的耦合。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1677987482,"ip_address":"广东","comment_id":368861,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"对于工时项map from项目有些疑惑，总感觉应该是反的，因为工时项应该算是抽象，为啥这里要感知具体的实现;\n我理解应该是在项目管理上下文中有一个工时项实体(map from工时项管理上下文)，然后项目实体还是会有一条泛化的线指向这个工时项实体","like_count":1,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607583,"discussion_content":"这样就造成了项目管理对工时项的耦合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677987482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1903229,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0a/7d/791d0f5e.jpg","nickname":"子衿","note":"","ucode":"E76CC673517290","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605676,"discussion_content":"1. 这个和需求有关系，这里项目管理上下文中，是不需要访问工时管理上下文的，所以没必要在项目管理上下文去映射出一个工时项实体\n2. 我觉得可能是需求功能没有想清楚，可以这样来想象一下，就是填报工时的时候，肯定是有一个界面，让你去查询你能填报的工时项，原来因为不分限界上下文，所以你会查你所在的项目，这就用到了项目管理的内容，以及其他普通工时项，但当你拆分成多个限界上下文，此时你再填报工时的时候，后端其实暴露的只有工时上下文的接口，然后在工时上下文中，只需要帮你查看你能填报的工时项有哪些就可以了，只需查你作为工时项成员的工时项，以及不需要分成成员的工时项，就能得到所有你可以填报的工时项记录了，但现在就有一个问题，就是你作为哪些工时项的成员，这部分数据从哪里来，这部分肯定就是从项目管理上下文得到的，得到的手段可以是当你加入某个项目时，项目管理上下文发送一个消息，工时项上下文通过订阅这个消息，在自己的工时项成员中，也记录一份，也可以是工时项上下文实时访问项目管理上下文的接口得到，不管怎么说，这部分数据是从项目管理上下文来的，所以这里的映射关系中，工时项成员的内容，是从项目管理上下文映射来的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1676858917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1843252,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/20/34/f6470d0b.jpg","nickname":"wy","note":"","ucode":"AAC3C76852B4EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1903229,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0a/7d/791d0f5e.jpg","nickname":"子衿","note":"","ucode":"E76CC673517290","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605798,"discussion_content":"嗯嗯，感谢解释，基本明白了;\n估计这个工时项的分页查询功能后面应该是用来讲cqrs的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676868332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":605676,"ip_address":"广东","group_id":0},"score":605798,"extra":""}]}]},{"had_liked":false,"id":393613,"user_name":"猴哥","can_delete":false,"product_type":"c1","uid":1588683,"ip_address":"浙江","ucode":"63A1BFDF13D85D","user_header":"https://static001.geekbang.org/account/avatar/00/18/3d/cb/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1724316523,"is_pvip":false,"replies":[{"id":143635,"content":"在为“工时项”实体进行数据库设计时，“工时项表”会有一个字段“父工时项ID”，对于一级工时项，该字段为空，对于二级工时项，字段的值是其所属父工时项的ID。这个字段在数据库设计层面体现，在领域模型层面不体现，这是因为“工时项”实体的自关联（父工时项 -- 子工时项）已经表达了这个含义，没有必要重复了。","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1731399702,"ip_address":"广东","comment_id":393613,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"“项目映射成第一级的工时项，而子项目映射成第二级工时项”，第一级、第二级是体现在哪的，没看到相关字段啊？？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653692,"discussion_content":"在为“工时项”实体进行数据库设计时，“工时项表”会有一个字段“父工时项ID”，对于一级工时项，该字段为空，对于二级工时项，字段的值是其所属父工时项的ID。这个字段在数据库设计层面体现，在领域模型层面不体现，这是因为“工时项”实体的自关联（父工时项 -- 子工时项）已经表达了这个含义，没有必要重复了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731399702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":375264,"user_name":"阿甘","can_delete":false,"product_type":"c1","uid":1684220,"ip_address":"北京","ucode":"955C37248DE1FE","user_header":"https://static001.geekbang.org/account/avatar/00/19/b2/fc/360d55b3.jpg","comment_is_top":false,"comment_ctime":1685176053,"is_pvip":false,"replies":[{"id":137139,"content":"泛化会增加模型的复杂性，如果不是很必要，还是不用","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1685968883,"ip_address":"广东","comment_id":375264,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"请教钟老师：拆分上下文过程中，项目、子项目到工时项的泛化关系为何要去除？保留这个泛化关系好像更容易说明其业务关系。（是为了最小化模型之间的依赖吗？）","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":620237,"discussion_content":"泛化会增加模型的复杂性，如果不是很必要，还是不用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685968883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":371420,"user_name":"BMX","can_delete":false,"product_type":"c1","uid":1160849,"ip_address":"上海","ucode":"DB01EAE73B7D24","user_header":"https://static001.geekbang.org/account/avatar/00/11/b6/91/e7df4173.jpg","comment_is_top":false,"comment_ctime":1679915085,"is_pvip":false,"replies":[{"id":135518,"content":"下节课就讲到了","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1679928148,"ip_address":"广东","comment_id":371420,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"“这也意味着，在代码的目录结构中，在根目录下面，首先为这 3 个上下文建立 3 个包，每个包内部，再按分层架构来进一步分包。”这里有个疑问：组件(界限上下文)之间如果有调用关系，如&quot;projectmng&quot;需要调用&quot;basicinfomng&quot;，那么调用的是API层，应用层还是领域或聚合层服务呢？","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":611109,"discussion_content":"下节课就讲到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1679928148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369887,"user_name":"灵活工作","can_delete":false,"product_type":"c1","uid":1017296,"ip_address":"湖北","ucode":"41F0870C832ECD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/d0/56602a43.jpg","comment_is_top":false,"comment_ctime":1678096692,"is_pvip":false,"replies":[{"id":134844,"content":"是","user_name":"作者回复","user_name_real":"编辑","uid":1288110,"ctime":1678119061,"ip_address":"广东","comment_id":369887,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"这是原文“在代码的目录结构中，在根目录下面，首先为这 3 个上下文建立 3 个包，每个包内部，再按分层架构来进一步分包”，不理解这句话，是不是在IDEA开发工具里面首先新建一个maven project，然后在src新建3个并列的上下文的包，然后在每个包里新建adapt\ner,application,domain的包，在adapter目录下新建drive和driving包？这样和迭代一的代码目录结构很不一样了","like_count":0,"discussions":[{"author":{"id":1288110,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VBLEAcychgbs5CicUczSYcibicoicZmyk1JHHFiae94KuvVsibAKtcQAvnOPWp0C4yvia8mzvQAORiazjWSoc1XQ9QkLrQ/132","nickname":"钟敬","note":"","ucode":"20B3D31A2C8C86","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607819,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678119061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376680,"user_name":"铿然","can_delete":false,"product_type":"c1","uid":1162461,"ip_address":"江苏","ucode":"D529242EC2E2EA","user_header":"https://static001.geekbang.org/account/avatar/00/11/bc/dd/c9413f59.jpg","comment_is_top":false,"comment_ctime":1687218141,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"有点复杂，先把业务需求和场景说清楚再展开设计更容易理解，否则要么不理解，要么会觉得是过度设计。","like_count":0},{"had_liked":false,"id":369434,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1677546792,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311801,"comment_content":"工时管理依赖的上下文真多啊，有：基础信息管理、项目管理、假期管理","like_count":0}]}