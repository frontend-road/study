{"id":188667,"title":"22 | 缓存架构：如何减少不必要的计算？","content":"<p>上一篇我们讲到，互联网应用的主要挑战就是在高并发情况下，大量的用户请求到达应用系统服务器，造成了巨大的计算压力。互联网应用的核心解决思路就是采用分布式架构，提供更多的服务器，从而提供更多的计算资源，以应对高并发带来的计算压力及资源消耗。</p><p>那么有没有办法减少到达服务器的并发请求压力呢？或者请求到达服务器后，有没有办法减少不必要的计算，降低服务器的计算资源消耗，尽快返回计算结果给用户呢？</p><p>有，解决的核心就是缓存。</p><p>所谓缓存，就是将需要多次读取的数据暂存起来，这样在后面，应用程序需要多次读取的时候，就不必从数据源重复加载数据了，这样就可以降低数据源的计算负载压力，提高数据响应速度。</p><p>一般说来，缓存可以分成两种，通读缓存和旁路缓存。</p><p><strong>通读（read-through）缓存</strong>，应用程序访问通读缓存获取数据的时候，如果通读缓存有应用程序需要的数据，那么就返回这个数据；如果没有，那么通读缓存就自己负责访问数据源，从数据源获取数据返回给应用程序，并将这个数据缓存在自己的缓存中。这样，下次应用程序需要数据的时候，就可以通过通读缓存直接获得数据了。</p><p>通读缓存在架构中的位置与作用如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/db/5e7556f257facad7980bcfd07b060fdb.png?wh=1282*226\" alt=\"\"></p><p><strong>旁路（cache-aside）缓存</strong>，应用程序访问旁路缓存获取数据的时候，如果旁路缓存中有应用程序需要的数据，那么就返回这个数据；如果没有，就返回空（null）。应用程序需要自己从数据源读取数据，然后将这个数据写入到旁路缓存中。这样，下次应用程序需要数据的时候，就可以通过旁路缓存直接获得数据了。</p><!-- [[[read_end]]] --><p>旁路缓存在架构中位置与作用如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/e1/d127542911a21454a786b210ca6ecce1.png?wh=800*462\" alt=\"\"></p><h2>通读缓存</h2><p>互联网应用中主要使用的通读缓存是CDN和反向代理缓存。</p><p><strong>CDN（Content Delivery Network）即内容分发网络</strong>。我们上网的时候，App或者浏览器想要连接到互联网应用的服务器，需要网络服务商，比如移动、电信这样的服务商为我们提供网络服务，建立网络连接才可以上网。</p><p>而这些服务商需要在全国范围内部署骨干网络、交换机机房才能完成网络连接服务，这些交换机机房可能会离用户非常近，那么互联网应用能不能在这些交换机机房中部署缓存缓存服务器呢？这样，用户就可以近距离获得自己需要的数据，既提高了响应速度，又节约了网络带宽和服务器资源。</p><p>当然可以。这个部署在网络服务商机房中的缓存就是CDN，因为距离用户非常近，又被称作网络连接的第一跳。目前很多互联网应用大约80%以上的网络流量都是通过CDN返回的。</p><p><img src=\"https://static001.geekbang.org/resource/image/e9/1e/e95cf98ddc2f33accc7a783d247f721e.png?wh=1112*782\" alt=\"\"></p><p>CDN只能缓存静态数据内容，比如图片、CSS、JS、HTML等内容。而动态的内容，比如订单查询、商品搜索结果等必须要应用服务器进行计算处理后才能获得。因此，互联网应用的静态内容和动态内容需要进行分离，静态内容和动态内容部署在不同的服务器集群上，使用不同的二级域名，即所谓的动静分离，一方面便于运维管理，另一方面也便于CDN进行缓存，使CDN只缓存静态内容。</p><p><strong>反向代理缓存也是一种通读缓存</strong>。我们上网的时候，有时候需要通过代理上网，这个代理是代理我们的客户端上网设备。而反向代理则代理服务器，是应用程序服务器的门户，所有的网络请求都需要通过反向代理才能到达应用程序服务器。既然所有的请求都需要通过反向代理才能到达应用服务器，那么在这里加一个缓存，尽快将数据返回给用户，而不是发送给应用服务器，这就是反向代理缓存。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/1b/6456704366dcd0b7b8607d85e31a631b.png?wh=1066*226\" alt=\"\"></p><p>用户请求到达反向代理缓存服务器，反向代理检查本地是否有需要的数据，如果有就直接返回，如果没有，就请求应用服务器，得到需要的数据后缓存在本地，然后返回给用户。</p><h2>旁路缓存</h2><p>CDN和反向代理缓存通常会作为系统架构的一部分，很多时候对应用程序是透明的。而应用程序在代码中主要使用的是对象缓存，<strong>对象缓存是一种旁路缓存。</strong></p><p>不管是通读缓存还是旁路缓存，缓存通常都是以&lt;key, value&gt;的方式存储在缓存中，比如，CDN和反向代理缓存中，每个URL是一个key，那么URL对应的文件内容就是value。而对象缓存中，key通常是一个ID，比如用户ID，商品ID等等，而value则是一个对象，就是ID对应的用户对象或者商品对象。</p><p>对于&lt;key, value&gt;的数据格式，我们在前面在数据结构讨论过，比较快速的存取方式是使用Hash表。<strong>因此通读缓存和旁路缓存在实现上，基本上<strong><strong>用的</strong></strong>是Hash表</strong>。</p><p>程序中使用的对象缓存，可以分成两种。一种是本地缓存，缓存和应用程序在同一个进程中启动，使用程序的堆空间存放缓存数据。本地缓存的响应速度快，但是缓存可以使用的内存空间相对比较小，但是对于大型互联网应用所需要缓存的数据通以T计，这时候就要使用远程的分布式缓存了。</p><p>分布式缓存是指将一组服务器构成一个缓存集群，共同对外提供缓存服务，那么应用程序在每次读写缓存的时候，如何知道要访问缓存集群中的哪台服务器呢？我们以Memcached为例，看看分布式缓存的架构：</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/6e/ca000caeaca469128dee3a59ddd0896e.png?wh=1274*626\" alt=\"\"></p><p>Memcached将多台服务器构成一个缓存集群，缓存数据存储在每台服务器的内存中。事实上，使用缓存的应用程序服务器通常也是以集群方式部署的，每个程序需要依赖一个Memcached的客户端SDK，通过SDK的API访问Memcached的服务器。</p><p>应用程序调用API，API调用SDK的路由算法，路由算法根据缓存的key值，计算这个key应该访问哪台Memcached服务器，计算得到服务器的IP地址和端口号后，API再调用SDK的通信模块，将&lt;key, value&gt;值以及缓存操作命令发送给具体的某台Memcached服务器，由这台服务器完成缓存操作。</p><p>那么，路由算法又是如何计算得到Memcached的服务器IP端口呢？比较简单的一种方法，和Hash算法一样，利用key的Hash值对服务器列表长度取模，根据余数就可以确定服务器列表的下标，进而得到服务器的IP和端口。</p><h2>缓存注意事项</h2><p>使用缓存可以减少不必要的计算，能够带来三个方面的好处：</p><ol>\n<li>缓存的数据通常存储在内存中，距离使用数据的应用也更近一点，因此相比从硬盘上获取，或者从远程网络上获取，它获取数据的速度更快一点，响应时间更快，性能表现更好。</li>\n<li>缓存的数据通常是计算结果数据，比如对象缓存中，通常存放经过计算加工的结果对象，如果缓存不命中，那么就需要从数据库中获取原始数据，然后进行计算加工才能得到结果对象，因此使用缓存可以减少CPU的计算消耗，节省计算资源，同样也加快了处理的速度。</li>\n<li>通过对象缓存获取数据，可以降低数据库的负载压力；通过CDN、反向代理等通读缓存获取数据，可以降低服务器的负载压力。这些被释放出来的计算资源，可以提供给其他更有需要的计算场景，比如写数据的场景，间接提高整个系统的处理能力。</li>\n</ol><p>但是缓存也不是万能的，如果不恰当地使用缓存，也可能会带来问题。</p><p>首先就是<strong>数据脏读</strong>的问题，缓存的数据来自数据源，如果数据源中的数据被修改了，那么缓存中的数据就变成脏数据了。</p><p>主要解决办法有两个，一个是<strong>过期失效</strong>，每次写入缓存中的数据都标记其失效时间，在读取缓存的时候，检查数据是否已经过期失效，如果失效，就重新从数据源获取数据。缓存失效依然可能会在未失效时间内读到脏数据，但是一般的应用都可以容忍较短时间的数据不一致，比如淘宝卖家更新了商品信息，那么几分钟数据没有更新到缓存，买家看到的还是旧数据，这种情况通常是可以接受的，这时候，就可以设置缓存失效时间为几分钟。</p><p>另一个办法就是<strong>失效通知</strong>，应用程序更新数据源的数据，同时发送通知，将该数据从缓存中清除。失效通知看起来数据更新更加及时，但是实践中，更多使用的还是过期失效。</p><p>此外，并不是所有数据使用缓存都有意义。在互联网应用中，大多数数据访问都是有热点的，比如热门微博会被更多阅读，热门商品会被更多浏览。那么将这些热门的数据保存在缓存中是有意义的，因为缓存通常使用内存，存储空间比较有限，只能存储有限的数据，热门数据存储在缓存中，可以被更多次地读取，缓存效率也比较高。</p><p>相反，<strong>如果缓存的数据没有热点，写入缓存的数据很难被重复读取，那么使用缓存就不是很有必要了</strong>。</p><h2>小结</h2><p>缓存是优化软件性能的杀手锏，任何需要查询数据、请求数据的场合都可以考虑使用缓存。缓存几乎是无处不在的，程序代码中可以使用缓存，网络架构中可以使用缓存，CPU、操作系统、虚拟机也大量使用缓存，事实上，缓存最早就是在CPU中使用的。对于一个典型的互联网应用而言，使用缓存可以解决绝大部分的性能问题，如果需要优化软件性能，那么可以优先考虑哪里可以使用缓存改善性能。</p><p>除了本篇提到的系统架构缓存外，客户端也可以使用缓存，在App或者浏览器中缓存数据，甚至都不需要消耗网络带宽资源，也不会消耗CDN、反向代理的内存资源，更不会消耗服务器的计算资源。</p><h2>思考题</h2><p>我们从Memcached路由算法讲到余数Hash算法，但是，这种算法在Memcached服务器集群扩容，也就是增加服务器的时候，会遇到较大的问题，问题是什么呢？应该如何解决？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流进步一下。</p>","comments":[{"had_liked":false,"id":171303,"user_name":"holybell","can_delete":false,"product_type":"c1","uid":1394188,"ip_address":"","ucode":"DB1D8230FCF95C","user_header":"https://static001.geekbang.org/account/avatar/00/15/46/0c/58a3eb04.jpg","comment_is_top":false,"comment_ctime":1578898528,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"207737328736","product_id":100040201,"comment_content":"关于思考题，使用Memcached服务器数量参与hash余数算法，会导致服务器数量增减的时候，相同的路由被重新计算到不同的机器上，这就会导致每次增删Memcached服务器的时候，会导致大量的缓存失效，针对这个问题可以采用一致性哈希算法，将所有的服务器连接成一个逻辑上的环，采用一个不会改变运算逻辑的hash函数，当一个key计算出hash值的时候落到环上的某一个点，之后顺时针找到最近的一个服务器即可，这样即使删除Memcached服务器，只会导致该服务器的缓存转移到环上下一个点的服务器上，不会导致几乎整个Memcached集群缓存的失效；同时如果是增加Memcached机器，那么相当于从环路上的某个机器匀了一部分数据到新机器上，旧机器的缓存可以配合过期策略自动删除。","like_count":49,"discussions":[{"author":{"id":1179565,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","nickname":"Farewell丶","note":"","ucode":"A0D69893C5375C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138085,"discussion_content":"实践中还有就是缓存量大的情况下，扩缩容之后的短时间内缓存搬迁的情况。这个搬迁在数据量小的情况下，可以交给缓存中间件做，比较小。而如果大量缓存迁移时间缓慢，中间件本身要进行集群见的数据复制转移，对正常业务进行就会造成一些问题。所以一般需要根据新的扩容容量，预先搬迁缓存。进行扩容时，预先往新生成的机器中添加缓存，然后加入集群，缩容时，复制缓存之后，再下掉对应的机器，重新构建集群。当然，现有分布式中间件越来越完善的情况下，缓存集群自己的节点预操作，就绪/准备下线，加入/离开集群，整套编排流程也比较容易或完善了。而且还出现了k8s这种管理编排框架，对比较老旧的状态中间件也能进行一些处理。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1579223956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529298,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","nickname":"你的美","note":"","ucode":"71B97BDBA3CDC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":138555,"discussion_content":"有个问题请教：Kubemetes=K8s吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579252425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1529298,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","nickname":"你的美","note":"","ucode":"71B97BDBA3CDC3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383723,"discussion_content":"Kubernetes\n你的m好神似","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626224153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":138555,"ip_address":""},"score":383723,"extra":""}]}]},{"had_liked":false,"id":192694,"user_name":"桂冠远航","can_delete":false,"product_type":"c1","uid":1155463,"ip_address":"","ucode":"5959E1A1DAA05D","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","comment_is_top":false,"comment_ctime":1584868666,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"91779181882","product_id":100040201,"comment_content":"这个专栏大而全是好事，但限于篇幅每个点都比较浅。","like_count":21,"discussions":[{"author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310680,"discussion_content":"我觉的这个“浅尝辄止”是和专栏的定位有关系的，更适合职场 3-5 年的同学。不过我看了之后也还是觉的有收获，可以当做一个索引。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601992880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1155463,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a1/87/259ab5a3.jpg","nickname":"桂冠远航","note":"","ucode":"5959E1A1DAA05D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020525,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","nickname":"escray","note":"","ucode":"1F4204930E47C4","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":313191,"discussion_content":"专栏其实还是想看干货，索引挺多的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602993925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310680,"ip_address":""},"score":313191,"extra":""}]}]},{"had_liked":false,"id":183693,"user_name":"探索无止境","can_delete":false,"product_type":"c1","uid":1044178,"ip_address":"","ucode":"91D2A9907DFA79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/d2/7024431c.jpg","comment_is_top":false,"comment_ctime":1583117356,"is_pvip":false,"replies":[{"id":"71137","content":"大部分业务场景可以接受短时间的读取脏数据，通知清理的方式带来的系统复杂性和压力得不偿失。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1583128541,"ip_address":"","comment_id":183693,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31647888428","product_id":100040201,"comment_content":"老师您好，文中提到缓存解决脏数据的方式失效通知，立即清理缓存，为什么实际采用的少？","like_count":8,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485749,"discussion_content":"大部分业务场景可以接受短时间的读取脏数据，通知清理的方式带来的系统复杂性和压力得不偿失。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583128541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295351,"discussion_content":"失效通知方式会导致网络通讯增加、缓存数据更改更频繁。但如果实际的场景是：更改的情况非常少，那是否应该实用失效通知方式呢？\n\n另外比如说股票交易系统，银行账户系统这种，如何使用缓存？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596173125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181621,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1582598738,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18762467922","product_id":100040201,"comment_content":"缓存是将数据的生产和消费解耦，在消费次数明显高于生产次数的现实中，让网络各个节点共享数据以减少无谓的数据生产。通路缓存节点必然位于数据生产者和数据消费者之间，当通路缓存不存在需要的数据的时候，就主动向生产者要数据，最终更新自己并把数据返回下家。通读缓存通常离数据消费者更近，因为这样才有效率。通读缓存在数据生产和消费者插入节点，有时也会增加生产者和消费者的距离，并不是万能的。CDN只适合于静态数据，因为动态数据更新快，缓存意义不大。反向代理也是在服务器和应用间插入一个节点，来代理服务器，个人觉得反向代理对于动态数据意义也不大。<br><br>旁路缓存则是数据消费者的衍生，数据消费者可能自己存不下那么多数据，就用旁路缓存来暂存结果，下次访问的时候先从旁路缓存读取，如果没有，再向数据生产者要数据，然后更新旁路缓存。旁路缓存需要存储大量数据，这个时候就需要将数据分配给不同的服务器，分配最好均匀，这和hash算法本质相同，因而有很多应用。<br><br>总结，通读代理是数据生成者的衍生，可以代理生产者。旁路缓存是数据消费者的衍生，可以想象成数据消费者外挂的内存或硬盘。通读缓存都存在于生产者和消费者之间的关键节点上，旁路缓存则是把这些关键节点扩容，让其有更好的性能。缓存是数据生产的一个快照，当其过了时效，也就失效了。","like_count":4,"discussions":[{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295356,"discussion_content":"数据的动静分离是因为：\nCDN离用户近，而且不具备计算功能，所有的计算功能都是由在应用程序服务器上的代码实现的，大量静态文件直接从CDN里面拿。 \n代理服务器是离应用程序服务器近，对于频繁访问的数据可以缓存在代理服务器里面，里面都是通过应用服务器计算好了的结果，通过key value 对象缓存。这样用户请求就不需要去访问应用服务器做频繁的重复计算。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596173969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":251985,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1602039837,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"10191974429","product_id":100040201,"comment_content":"推荐去看一下隔壁《高并发系统设计 40 问》的缓存部分（可以试读有关缓存的 4 篇），我是为了最后的思考题，Memcached 的哈希一致性算法，而去看的。<br><br>缓存大概可以分为以下三类<br><br>旁路缓存 Cache Aside：<br>通路缓存 Read&#47;Write Through：<br>写回缓存 Write Back：计算机体系结构中的设计，比如操作系统的 Page Cache<br><br>这篇专栏偏重于缓存架构的概要介绍，而高并发专栏里面提到了一些实际使用中的注意事项，配合服用疗效更好。当然，最终还是要到真实的使用场景中去学以致用。<br><br>除了 Memcached，也有把 Redis 来当做缓存使用的。<br><br>我觉的缓存受到限制的原因主要还是速度比较快的存储，费用昂贵——从 CPU 中的 L1 Cache、L2 Cache，一直到 Memcached 的内存数据库，CDN 和其他缓存技术，如果真的不考虑性价比的话，那么大量使用内存或者 SSD 等高速存储应该就可以了。","like_count":2},{"had_liked":false,"id":172456,"user_name":"草原上的奔跑","can_delete":false,"product_type":"c1","uid":1120348,"ip_address":"","ucode":"D69C617F767736","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/5c/1a58e8f6.jpg","comment_is_top":false,"comment_ctime":1579180813,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10169115405","product_id":100040201,"comment_content":"通读缓存、旁路缓存，第一次对缓存有了明确的认知。hash算法在扩缩容时会导致绝大多数缓存失效，这是它的问题。使用一致性hash算法可以降低失效缓存的数量，改善缓存的效率。但一致性hash也有自己的问题，比如平衡性问题等，又会针对这些问题提出解决方案。<br><br>之前看一些架构性的内容，不知道为何要这样做。听了李老师娓娓道来的讲述，明白了架构的演进，心里有些底，不再是飘在空中的感觉","like_count":2},{"had_liked":false,"id":171395,"user_name":"俊杰","can_delete":false,"product_type":"c1","uid":1020008,"ip_address":"","ucode":"197C1CB1D48CB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/68/511fc1e5.jpg","comment_is_top":false,"comment_ctime":1578916728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10168851320","product_id":100040201,"comment_content":"会导致大量缓存不命中，可以用一致性哈希算法解决","like_count":2},{"had_liked":false,"id":356610,"user_name":"zqnba","can_delete":false,"product_type":"c1","uid":1258589,"ip_address":"日本","ucode":"20000DAD8C92F1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBicEibaY3wha6ibzQATjIq4dvbtPoP0vMicasl52MgfjicKQFOdibVViaDnBpWt6wtcOhxFx5emiajUXpZg/132","comment_is_top":false,"comment_ctime":1662448679,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662448679","product_id":100040201,"comment_content":"谢谢。提个建议：<br>&quot;首先就是数据脏读的问题，缓存的数据来自数据源，如果数据源中的数据被修改了，那么缓存中的数据就变成脏数据了。&quot;<br><br>意思可以理解。不过这里的“脏读”，跟数据库事物的“脏读”定义不一致。有点容易混淆。","like_count":0},{"had_liked":false,"id":350152,"user_name":"java小霸王","can_delete":false,"product_type":"c1","uid":1168540,"ip_address":"","ucode":"7094BCD9F25E1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/d4/9c/030e80d3.jpg","comment_is_top":false,"comment_ctime":1656603384,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656603384","product_id":100040201,"comment_content":"一致性哈希，或者redis的哈希槽机制","like_count":0},{"had_liked":false,"id":275802,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1611671816,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1611671816","product_id":100040201,"comment_content":"最后的问题 一致性hash算法可以解决吧 <br>另一个就是 总算是懂了read-through 和 cache-aside","like_count":0},{"had_liked":false,"id":238456,"user_name":"不要挑战自己的智商","can_delete":false,"product_type":"c1","uid":2063114,"ip_address":"","ucode":"4910FF07C35DC5","user_header":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","comment_is_top":false,"comment_ctime":1596174653,"is_pvip":true,"replies":[{"id":"88091","content":"旁路缓存都是一个个的对象（id, 对象）是吗？<br>是的<br><br>旁路缓存全都是本地缓存是吗？<br>分布式对象缓存也是<br><br>浏览器的缓存就是旁路缓存，是吗？<br>是的","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1596179687,"ip_address":"","comment_id":238456,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596174653","product_id":100040201,"comment_content":"旁路缓存的几段有点confusing..请问老师：<br>旁路缓存都是一个个的对象（id, 对象）是吗？<br>旁路缓存全都是本地缓存是吗？缓存和应用程序在同一个进程中启动，使用程序的堆空间存放缓存数据。这个缓存是由客户端应用来管理的，比如浏览器的缓存就是旁路缓存，是吗？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502752,"discussion_content":"旁路缓存都是一个个的对象（id, 对象）是吗？\n是的\n\n旁路缓存全都是本地缓存是吗？\n分布式对象缓存也是\n\n浏览器的缓存就是旁路缓存，是吗？\n是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596179687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197438,"user_name":"非同凡想","can_delete":false,"product_type":"c1","uid":1934969,"ip_address":"","ucode":"713FD449A49D5A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/86/79/066a062a.jpg","comment_is_top":false,"comment_ctime":1585377996,"is_pvip":false,"replies":[{"id":"74775","content":"是的","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1585526400,"ip_address":"","comment_id":197438,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1585377996","product_id":100040201,"comment_content":"淘宝一般会在CDN放商品图片么？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489523,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585526400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295358,"discussion_content":"我认为应该是所有的图片和静态文件都会放在CDN里面，是吗？需要考虑数据安全的问题吗？毕竟部署在别人的机房里面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596174060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186015,"user_name":"布衣骇客","can_delete":false,"product_type":"c1","uid":1256280,"ip_address":"","ucode":"5226B0F67090D1","user_header":"https://static001.geekbang.org/account/avatar/00/13/2b/58/11c05ccb.jpg","comment_is_top":false,"comment_ctime":1583742508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583742508","product_id":100040201,"comment_content":"扩容后可以导致部分缓存不命中，这个怎么处理呢？再用一致性hash路由算法的话，肯定会导致缓存不命中的情况的。还有老师，缓存雪崩的一般怎么处理好呢？缓存预热？或者是漏斗算法？","like_count":0},{"had_liked":false,"id":174723,"user_name":"旅途","can_delete":false,"product_type":"c1","uid":1212902,"ip_address":"","ucode":"5022477E8E9441","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/e6/6cafed37.jpg","comment_is_top":false,"comment_ctime":1580363731,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580363731","product_id":100040201,"comment_content":"一致性hash","like_count":0}]}