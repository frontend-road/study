{"id":497807,"title":"15 | 限流器设计：如何避免超预期的高并发压力压垮系统？","content":"<p>你好，我是李智慧。</p><p>在互联网高可用架构设计中，限流是一种经典的高可用架构模式。因为某些原因，大量用户突然访问我们的系统时，或者有黑客恶意用DoS（Denial of Service，拒绝服务）方式攻击我们的系统时，这种未曾预期的高并发访问对系统产生的负载压力可能会导致系统崩溃。</p><p>解决这种问题的一个主要手段就是限流，即拒绝部分访问请求，使访问负载压力降低到一个系统可以承受的程度。这样虽然有部分用户访问失败，但是整个系统依然是可用的，依然能对外提供服务，而不是因为负载压力太大而崩溃，导致所有用户都不能访问。</p><p>为此，我们准备开发一个限流器，产品名称为“Diana”。</p><h2>需求分析</h2><p>我们将Diana定位为一个限流器组件，即Diana的主要应用场景是部署在微服务网关或者其他HTTP服务器入口，以过滤器的方式对请求进行过滤，对超过限流规则的请求返回“服务不可用”HTTP响应。</p><p>Diana的限流规则可通过配置文件获取，并需要支持本地配置和远程配置两种方式，远程配置优先于本地配置。限流方式包括：</p><ul>\n<li>全局限流：针对所有请求进行限流，即保证整个系统处理的请求总数满足限流配置。</li>\n<li>账号限流：针对账号进行限流，即对单个账号发送的请求进行限流。</li>\n<li>设备限流：针对设备进行限流，即对单个客户端设备发送的请求进行限流。</li>\n<li>资源限流：针对某个资源（即某个URL）进行限流，即保证访问该资源的请求总数满足限流配置。</li>\n</ul><!-- [[[read_end]]] --><p>并且Diana设计应遵循开闭原则，能够支持灵活的限流规则功能扩展，即未来在不修改现有代码和兼容现有配置文件的情况下，支持新的配置规则。</p><h2>概要设计</h2><p>Diana的设计目标是一个限流器组件，即Diana并不是一个独立的系统，不可以独立部署进行限流，而是部署在系统网关（或者其他HTTP服务器上），作为网关的一个组件进行限流，部署模型如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/4e/e77c0eaf41d816223d8b603f02a3854e.jpg?wh=1920x973\" alt=\"图片\"></p><p>用户请求（通过负载均衡服务器）到达网关服务器。网关服务器本质也是一个HTTP服务器，限流器是部署在网关中的一个过滤器（filter）组件，和网关中的签名校验过滤器、用户权限过滤器等配置在同一个过滤器责任链（Chain of Responsibility）上。限流器应该配置在整个过滤器责任链的前端，也就是说，如果请求超过了限流，请求不需要再进入其他过滤器，直接被限流器拒绝。</p><p>用户请求进入限流器后，根据限流策略，判断该请求是否已经超过限流，如果超过，限流器直接返回状态码为503（Too Many Requests）的响应；如果没有超过限流，请求继续向下处理（经过其他网关过滤器），并最终调用微服务完成处理。</p><p>限流器的策略可以在本地配置，也可以通过远程的配置中心服务器加载，即远程配置。远程配置优先于本地配置。</p><h4>限流模式设计</h4><p>请求是否超过限流，主要就是判断单位时间请求数量是否超过配置的请求限流数量。单位时间请求数量，可以本地记录，也可以远程记录。方便起见，本地记录称作本地限流，远程记录称作远程限流（也叫分布式限流）。</p><p>本地限流意味着，每个网关服务器需要根据本地记录的单位时间请求数量进行限流。假设限流配置为每秒限流50请求，如果该网关服务器本地记录的当前一秒内接受请求数量达到50，那么这一秒内的后续请求都返回503响应。如果整个系统部署了100台网关服务器，每个网关配置本地限流为每秒50，那么，整个系统每秒最多可以处理5000个请求。</p><p>远程限流意味着，所有网关共享同一个限流数量，每个网关服务器收到请求后，从远程服务器中获取单位时间内已处理请求数，如果超过限流，就返回503响应。也就是说，可能某个网关服务器一段时间内根本就没有请求到达，但是远程的已处理请求数已经达到了限流上限，那么这台网关服务器也必须拒绝请求。我们使用Redis作为记录单位时间请求数量的远程服务器。</p><h4>高可用设计</h4><p>为了保证配置中心服务器和Redis服务器宕机时，限流器组件的高可用。限流器应具有自动降级功能，即配置中心不可用，则使用本地配置；Redis服务器不可用，则降级为本地限流。</p><h2>详细设计</h2><p>常用的限流算法有4种，固定窗口（Window）限流算法，滑动窗口（Sliding Window）限流算法，漏桶（Leaky Bucket）限流算法，令牌桶（Token Bucket）限流算法。我们将详细讨论这四种算法的实现。</p><p>此外，限流器运行期需要通过配置文件获取对哪些URL路径进行限流；本地限流还是分布式限流；对用户限流还是对设备限流，还是对所有请求限流；限流的阈值是多少；阈值的时间单位是什么；具体使用哪种限流算法。因此，我们需要先看下配置文件的设计。</p><h4>配置文件设计</h4><p>Diana限流器使用YAML进行配置，配置文件举例如下：</p><pre><code class=\"language-plain\">Url:/\nrules:\n - actor:device\n   unit:second\n   rpu:10\n   algo:TB\n   scope:global\n - actor:all\n   unit:second\n   rpu:50\n   algo:W\n   scope:local\n</code></pre><p>配置文件的配置项有7种，分别说明如下：</p><ol>\n<li>Url记录限流的资源地址，\"/“表示所有请求，配置文件中的路径可以互相包含，比如“/”包含“/sample”，限流器要先匹配“/”的限流规则，如果“/”的限流规则还没有触发（即访问”/\"的流量，也就是单位时间所有的请求总和没有达到限流规则），则再匹配“/sample”。</li>\n<li>每个Url可以配置多个规则rules，每个规则包括actor，unit，rpu，algo，scope</li>\n<li>actor为限流对象，可以是账号（actor），设备（device），全部（all）</li>\n<li>unit为限流时间单位，可以是秒（second），分（minute），时（hour），天（day）</li>\n<li>rpu为单位时间限流请求数（request per unit），即上面unit定义的单位时间内允许通过的请求数目，如unit为second，rpu为100，表示每秒允许通过100个请求，每秒超过100个请求就进行限流，返回503响应</li>\n<li>scope为rpu生效范围，可以是本地（local），也可以是全局（global），scope也决定了单位时间请求数量是记录在本地还是远程，local记录在本地，global记录在远程。</li>\n<li>algo限流算法，可以是window，sliding window，leaky bucket，token bucket 。</li>\n</ol><p>Diana支持配置4种限流算法，使用者可以根据自己的需求场景，为不同资源地址配置不同的限流算法，下面详细描述这四种算法实现。</p><h4><strong>固定窗口（Window）限流算法</strong></h4><p>固定窗口限流算法就是将配置文件中的时间单位unit作为一个时间窗口，每个窗口仅允许限制流量内的请求通过，如图。</p><p><img src=\"https://static001.geekbang.org/resource/image/96/a3/9656050d518cca2825de965d180838a3.jpg?wh=1920x412\" alt=\"图片\"></p><p>我们将时间轴切分成一个一个的限流窗口，每个限流窗口有一个窗口开始时间和一个窗口结束时间，窗口开始时，计数器清零，每进入一个请求，计数器就记录+1。如果请求数目超过rpu配置的限流请求数，就拒绝服务，返回503响应。当前限流窗口结束后，就进入下个限流窗口，计数器再次清零，重新开始。处理流程活动图如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/cc/dd/cc5b503a196cd917d35464eb0e53bddd.jpg?wh=1920x1489\" alt=\"图片\"></p><p>上图包括“初始化”和“处理流程”两个泳道。初始化的时候，设置“窗口计数器”和“当前窗口结束时间”两个变量。处理请求的时候，判断当前时间是否大于“当前窗口结束时间”，如果大于，那么重置“窗口计数器”和“当前窗口结束时间”两个变量；如果没有，窗口计数器+1，并判断计数器是否大于配置的限流请求数rpu，根据结果决定是否进行限流。</p><p>这里的“窗口计数器”可以本地记录，也可以远程记录，也就是配置中的local和global。固定窗口算法在配置文件中algo项可配置“window”或者缩写“W”。</p><p>固定窗口实现比较容易，但是如果使用这种限流算法，在一个限流时间单位内，通过的请求数可能是rpu的两倍，无法达到限流的目的，如下图。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/c6/c7b2dae2c9b96dd775557295ba3680c6.jpg?wh=1920x412\" alt=\"图片\"></p><p>假设单位时间请求限流数rpu为100，在第一个限流窗口快要到结束时间的时候，突然进来100个请求，因为这个请求量在限流范围内，所以没有触发限流，请求全部通过。然后进入第二个限流窗口，限流计数器清零。这时又忽然进入100个请求，因为已经进入第二个限流窗口，所以也没触发限流。在短时间内，通过了200个请求，这样可能会给系统造成巨大的负载压力。</p><h4>滑动窗口（Sliding Window）限流算法</h4><p>改进固定窗口缺陷的方法是采用滑动窗口限流算法，如下图。</p><p><img src=\"https://static001.geekbang.org/resource/image/12/cf/12d45534b212abf3cbfd764b85bd72cf.jpg?wh=1920x536\" alt=\"图片\"></p><p>滑动窗口就是将限流窗口内部切分成一些更小的时间片，然后在时间轴上滑动，每次滑动，滑过一个小时间片，就形成一个新的限流窗口，即滑动窗口。然后在这个滑动窗口内执行固定窗口算法即可。</p><p>滑动窗口可以避免固定窗口出现的放过两倍请求的问题，因为一个短时间内出现的所有请求必然在一个滑动窗口内，所以一定会被滑动窗口限流。</p><p>滑动窗口的算法实现基本和固定窗口一致，只要改动重置“窗口计数器”和“当前窗口结束时间”的逻辑就可以。固定窗口算法重置为窗口结束时间+1 unit 时间，滑动窗口算法重置为窗口结束时间+1个时间片。但是固定窗口算法重置后，窗口计数器为0，而滑动窗口需要将窗口计数器设置为当前窗口已经经过的时间片的请求总数，比如上图里，一个滑动窗口被分为5个时间片，滑动窗口2的浅蓝色部分就是已经经过了4个时间片。</p><p>滑动窗口算法在配置文件中algo项可配置“sliding window”或者缩写“SW”。</p><h4>漏桶（Leaky Bucket）限流算法</h4><p>漏桶限流算法是模拟水流过一个有漏洞的桶进而限流的思路，如图。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/11/d5de3e408c2abc1ff15ee96a60439d11.jpg?wh=2000x654\" alt=\"\"></p><p>水龙头的水先流入漏桶，再通过漏桶底部的孔流出。如果流入的水量太大，底部的孔来不及流出，就会导致水桶太满溢出去。</p><p>限流器利用漏桶的这个原理设计漏桶限流算法，用户请求先流入到一个特定大小的漏桶中，系统以特定的速率从漏桶中获取请求并处理。如果用户请求超过限流，就会导致漏桶被请求数据填满，请求溢出，返回503响应。</p><p>所以漏桶算法不仅可以限流，当流量超过限制的时候会拒绝处理，直接返回503响应，还能控制请求的处理速度。</p><p>实践中，可以采用队列当做漏桶。如图。</p><p><img src=\"https://static001.geekbang.org/resource/image/bb/16/bb8ca5effb1458600a7a43a622764a16.jpg?wh=1920x354\" alt=\"图片\"></p><p>构建一个特定长度的队列queue作为漏桶，开始的时候，队列为空，用户请求到达后从队列尾部写入队列，而应用程序从队列头部以特定速率读取请求。当读取速度低于写入速度的时候，一段时间后，队列会被写满，这时候写入队列操作失败。写入失败的请求直接构造503响应返回。</p><p>但是使用队列这种方式，实际上是把请求处理异步化了（写入请求的线程和获取请求的线程不是同一个线程），并不适合我们目前同步网关的场景（如果使用前面设计过的Flower框架开发的异步网关就可以用这种队列方式）。</p><p>因此Diana实现漏桶限流算法并不使用消息队列，而是阻塞等待。根据限流配置文件计算每个请求之间的间隔时间，例如：限流每秒10个请求，那么每两个请求的间隔时间就必须&gt;=100ms。用户请求到达限流器后，根据当前最近一个请求处理的时间和阻塞的请求线程数目，计算当前请求线程的sleep时间。每个请求线程的sleep时间不同，最后就可以实现每隔100ms唤醒一个请求线程去处理，从而达到漏桶限流的效果。</p><p>计算请求线程sleep时间的伪代码如下：</p><pre><code class=\"language-java\">初始化 :\n间隔时间 = 100ms;\n阻塞线程数 = 0;\n最近请求处理时间戳  = 0；\n\nlong sleep时间(){\n  //最近没有请求，不阻塞\n  if((now - 最近请求处理时间戳） &gt;= 间隔时间 and 阻塞线程数 &lt;= 0）{\n    最近请求处理时间戳 = now;\n    return 0; //不阻塞\n  }\n  //排队请求太多，漏桶溢出\n  if(阻塞线程数 &gt; 最大溢出线程数) {\n    return MAX_TIME;//MAX_TIME表示阻塞时间无穷大，当前请求被限流\n  }\n  //请求在排队，阻塞等待\n    阻塞线程数++;\n    return 间隔时间 * 阻塞线程数 - (now - 最近请求处理时间戳) ;\n}\n</code></pre><p>请求线程sleep时间结束，继续执行的时候，修改阻塞线程数：</p><pre><code class=\"language-plain\">最近请求处理时间戳 = now;\n阻塞线程数--;\n</code></pre><p>注意，以上代码多线程并发执行，需要进行加锁操作。</p><p>使用漏桶限流算法，即使系统资源很空闲，多个请求同时到达时，漏桶也是慢慢地一个接一个地去处理请求，这其实并不符合人们的期望，因为这样就是在浪费计算资源。因此除非有特别的场景需求，否则不推荐使用该算法。</p><p>漏桶算法的algo配置项名称为“leaky bucket”或者“LB”。</p><h4>令牌桶（Token Bucket）限流算法</h4><p>令牌桶是另一种桶限流算法，模拟一个特定大小的桶，然后向桶中以特定的速度放入令牌（token），请求到达后，必须从桶中取出一个令牌才能继续处理。如果桶中已经没有令牌了，那么当前请求就被限流，返回503响应。如果桶中的令牌放满了，令牌桶也会溢出。</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/a8/eede538f223553d706aa77b7340407a8.png?wh=892x536\" alt=\"图片\"></p><p>上面的算法描述似乎需要有一个专门线程生成令牌，还需要一个数据结构模拟桶。实际上，令牌桶的实现，只需要在请求获取令牌的时候，通过时间计算，就可以算出令牌桶中的总令牌数。伪代码如下：</p><pre><code class=\"language-plain\">初始化 :\n最近生成令牌时间戳 = 0；\n总令牌数 = 0；\n令牌生成时间间隔 = 100ms;\n\nboolean 获取令牌(){\n  //令牌桶中有令牌，直接取令牌即可\n  if(总令牌数 &gt;= 1){\n    总令牌数--；\n    return true;\n  }\n  //令牌桶中没有令牌了，重算现在令牌桶中的总令牌数，可能算出的总令牌数依然为0\n  总令牌数 = min(令牌数上限值，总令牌数 + \n  (now - 最近生成令牌时间戳) / 令牌生成时间间隔)；\n  if(总令牌数 &gt;= 1){\n    总令牌数--；\n    最近生成令牌时间戳 = now；//有令牌了，才能重设时间\n    return true；\n  }\n  return false；\n}\n</code></pre><p>令牌桶限流算法综合效果比较好，能在最大程度利用系统资源处理请求的基础上，实现限流的目标，建议通常场景中优先使用该算法，Diana的缺省配置算法也是令牌桶。令牌桶算法的algo配置项名称为“token bucket”或“TB”。</p><h2>小结</h2><p>限流器是一个典型的技术中间件，使用者是应用系统开发工程师，他们在自己的应用系统中使用限流器，通过配置文件来实现满足自己业务场景的限流需求。这里隐含了一个问题：大家都是开发者，这些应用系统开发工程师为什么要用你开发的中间件？事实上，技术中间件天然会受到更多的挑剔，架构师在设计技术组件的时候要格外考虑<strong>易用性和扩展性</strong>，开发出来的技术中间件要能经得起同行的审视和挑战。</p><p>这篇设计文档中，包含了很多伪代码，这些伪代码是限流算法实现的核心逻辑。架构师一方面需要思考宏观的技术决策，一方面要思考微观的核心代码。这里两方面的能力支撑起架构师的技术影响力，既要能上得厅堂，在老板、客户等外部相关方面前侃侃而谈，保障自己和团队能掌控自己的技术方向；也要能下得厨房，搞定最有难度的代码实现，让团队成员相信跟着你混，没有迈不过去的技术坎。</p><h2>思考题</h2><p>滑动窗口算法中，如何管理时间片，以及如何计算滑动过程中的一个窗口内各个时间片的窗口计数器之和？用什么样的数据结构和算法比较合适？</p><p>欢迎在评论区分享你的思考，我们共同进步。</p>","comments":[{"had_liked":false,"id":339637,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1648264052,"is_pvip":true,"replies":[{"id":"124211","content":"非常赞","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648433341,"ip_address":"","comment_id":339637,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31713035124","product_id":100105701,"comment_content":"（1）使用队列管理时间片，每次窗口移动就是一个出队和入队操作<br><br>（2）使用hashmap管理各个时间片的计数器key，如果是本地模式则value存在内存中，如果是分布式模式则value存放在redis中","like_count":7,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558665,"discussion_content":"非常赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648433341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339464,"user_name":"Geek_7347cf","can_delete":false,"product_type":"c1","uid":2343516,"ip_address":"","ucode":"2E25574FAB1B3B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mmTEibMibic5ibsVpNZkR3HBlpPpZYt0gHGdIqOduLGxRHZpTWRG3q56CT1eejoLgNsdaW5aQGWXfyibN4vm9CicYb3w/132","comment_is_top":false,"comment_ctime":1648114243,"is_pvip":false,"replies":[{"id":"124203","content":"很赞","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648432652,"ip_address":"","comment_id":339464,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23122950723","product_id":100105701,"comment_content":"个人觉得可以使用redis的的hash  通过 对时间进行取模分片","like_count":5,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558656,"discussion_content":"很赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648432652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339345,"user_name":"周文童","can_delete":false,"product_type":"c1","uid":1005411,"ip_address":"","ucode":"0C65A0A67229FA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/63/be6db73e.jpg","comment_is_top":false,"comment_ctime":1648040964,"is_pvip":true,"replies":[{"id":"124202","content":"很赞。相当于用时间戳计算Hash值，key就是时间片，所以其实不用遍历数组，取模就得到数组下标。","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648432577,"ip_address":"","comment_id":339345,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14532942852","product_id":100105701,"comment_content":"Sentinel 是用 Atomic 的 Array 存储，每个数组元素为一个 bucket，存储的时候用时间戳和数组的 length 取模。算累计时间就只需要遍历数组，算每一个 bucket 里面的时间戳和当前时间戳是否在一个时间限制里面。","like_count":3,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558655,"discussion_content":"很赞。相当于用时间戳计算Hash值，key就是时间片，所以其实不用遍历数组，取模就得到数组下标。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648432577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345905,"user_name":"群书","can_delete":false,"product_type":"c1","uid":1437036,"ip_address":"","ucode":"BA9EE71D2D818A","user_header":"https://static001.geekbang.org/account/avatar/00/15/ed/6c/6fb35017.jpg","comment_is_top":false,"comment_ctime":1652690554,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"5947657850","product_id":100105701,"comment_content":"在令牌桶算法中，计算令牌的方法如下：<br>总令牌数 = min(令牌数上限值，总令牌数 +   (now - 最近生成令牌时间戳) &#47; 令牌生成时间间隔)；<br>为何要 “总令牌数 +   (now - 最近生成令牌时间戳) &#47; 令牌生成时间间隔” ，总令牌数不是为零吗？需要加上 “总令牌数”吗","like_count":1,"discussions":[{"author":{"id":2804063,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/c9/5f/db8073d3.jpg","nickname":"ball","note":"","ucode":"C20917ACD5F006","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584160,"discussion_content":"需要，总令牌数就是上一轮生成过程中剩下的还未消耗的令牌数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660647887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340990,"user_name":"食指可爱多","can_delete":false,"product_type":"c1","uid":1045721,"ip_address":"","ucode":"B918E07F55AB9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/d9/e572ae4d.jpg","comment_is_top":false,"comment_ctime":1649256247,"is_pvip":true,"replies":[{"id":"124666","content":"赞","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1649295611,"ip_address":"","comment_id":340990,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5944223543","product_id":100105701,"comment_content":"我之前做过一个分布式限流组建，就是用令牌桶算法。redis做存储，脚本逻辑用lua脚本实现，算法逻辑参考Google Guava中的实现。","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560349,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649295611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339209,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1647995151,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5942962447","product_id":100105701,"comment_content":"我可能会使用定长队列存储每一个时间窗。时间窗只统计最近的若干个，符合先进先出的要求。额外用一个变量存储总计数器。<br><br>新的请求进来，如果没有切换新的时间窗，将最后的时间窗计数器+1。如果涉及时间窗切换，则需要先做出队操作。并且总计数器扣除出队的时间窗计数器。然后入队新的时间窗，时间窗计数器为1<br><br>如果，中间请求间隔过长，涉及跳时间窗，则根据实际情况，入队若干个0时间窗进行填充。","like_count":1,"discussions":[{"author":{"id":1242401,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/21/17814610.jpg","nickname":"山东哥哥帅","note":"","ucode":"6BBEA84359262F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576434,"discussion_content":"使用队列实现滑动窗口，这个限流是绝对的平稳","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655544934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2911084,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6b/6c/3e80afaf.jpg","nickname":"HappyHasson","note":"","ucode":"B84CC43E349CFA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558219,"discussion_content":"我们生产环境用了这种实现算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648136972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360955,"user_name":"IT小村","can_delete":false,"product_type":"c1","uid":1330357,"ip_address":"北京","ucode":"BDFEE0D821CB6E","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/b5/fcede1a9.jpg","comment_is_top":false,"comment_ctime":1667032752,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1667032752","product_id":100105701,"comment_content":"公司用的，就是令牌桶算法","like_count":0},{"had_liked":false,"id":357961,"user_name":"Jav","can_delete":false,"product_type":"c1","uid":2846808,"ip_address":"北京","ucode":"2562623ADD4BC1","user_header":"https://static001.geekbang.org/account/avatar/00/2b/70/58/69e4ae1c.jpg","comment_is_top":false,"comment_ctime":1663774997,"is_pvip":false,"replies":[{"id":"130717","content":"全局限流通常是需要进行小流量、精确限流的场景，比如秒杀商品，控制访问量不要超过商品数量太多，这类场景的rpu通常不会很大。10万级rpu的限流建议就不要全局限流了，意义不大。","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1665540729,"ip_address":"北京","comment_id":357961,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1663774997","product_id":100105701,"comment_content":"Redis单机10w啊，用redis作为限流器有瓶颈，有没有方案可以解决这个性能瓶颈的？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590110,"discussion_content":"全局限流通常是需要进行小流量、精确限流的场景，比如秒杀商品，控制访问量不要超过商品数量太多，这类场景的rpu通常不会很大。10万级rpu的限流建议就不要全局限流了，意义不大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665540729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345775,"user_name":"Logan","can_delete":false,"product_type":"c1","uid":2727984,"ip_address":"","ucode":"D812A9F8A53E5B","user_header":"https://static001.geekbang.org/account/avatar/00/29/a0/30/b53fb2ee.jpg","comment_is_top":false,"comment_ctime":1652588639,"is_pvip":false,"replies":[{"id":"126221","content":"是的，会影响性能，所以全局限流器应该应用在需要精确控制访问量的接口上，这种接口的并发量通常不会太高。<br><br>redis的正常耗时应该在1~2ms，你的项目中耗时似乎有点偏高了。","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1652682675,"ip_address":"","comment_id":345775,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652588639","product_id":100105701,"comment_content":"关于分布式限流，如果每个请求过来，都和Redis进行交互，岂不是会影响接口耗时？<br>目前项目中和Redis交互的耗时大约需要5~10ms","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572259,"discussion_content":"是的，会影响性能，所以全局限流器应该应用在需要精确控制访问量的接口上，这种接口的并发量通常不会太高。\n\nredis的正常耗时应该在1~2ms，你的项目中耗时似乎有点偏高了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652682675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345045,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1651979378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651979378","product_id":100105701,"comment_content":"固定时间窗口：把时间轴划分为固定长度时间的分段，内存里面存储当前时间片的开始时间、结束时间和已经处理的请求数量，请求过来的时候查看是否在存储的时间片内，是则请求数量+1看是否超过，否则重置存储；<br>滑动窗口：把固定窗口时间轴再分为n段，请求过来的时候查看当前小段 ~ 往前推n段的时间内的请求数是否已经超过限流<br>漏桶：请求必须匀速放行，异步的方法通常用队列，消费端取得请求后匀速的处理。同步的方式通常是sleep到跟上个请求的时间间隔达到预期后放行（即使处理资源很空闲，多个请求到来时也是匀速处理，所以少用）<br>令牌桶：池子里有一定的令牌，请求到达后获得令牌即可放行。内存里保存生成令牌的时间以及生成数，请求到达时如果没有令牌，则重新生成令牌。","like_count":0},{"had_liked":false,"id":344500,"user_name":"gesanri","can_delete":false,"product_type":"c1","uid":1121174,"ip_address":"","ucode":"AE3B97DC3ED668","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELtOO0HKrj5SI5JSlmwiaCvaF6GLiaTmf5NX88OZaO3HymTAGTeIoicBUjqzmMF6sF5raPFjuqLFibrrw/132","comment_is_top":false,"comment_ctime":1651587790,"is_pvip":false,"replies":[{"id":"125786","content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1651720441,"ip_address":"","comment_id":344500,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651587790","product_id":100105701,"comment_content":"这个漏桶算法的伪代码，看意思是假设1秒限制10个请求，假设第一个请求在2ms的时候来了并且当时就处理完了，完后第二个请求在5ms的时候来了，那么第二个请求也必须等到102ms的时候才能被处理，是这样吗？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570266,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651720441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343431,"user_name":"开心小毛","can_delete":false,"product_type":"c1","uid":1023762,"ip_address":"","ucode":"9D57A2773759F3","user_header":"","comment_is_top":false,"comment_ctime":1650850945,"is_pvip":false,"replies":[{"id":"125388","content":"漏桶和令牌桶在是否严格控制每秒请求上限上没区别啊，区别就是在于适用场景不同，比如一个计算密集型的应用在一个单CPU计算机上运行，每个请求需要运算10ms，那么显然设置rpu为100的漏桶比令牌桶更好。","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1650855877,"ip_address":"","comment_id":343431,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1650850945","product_id":100105701,"comment_content":"想请教李老师一个选用限流策略的问题：如果不追求严格的每秒请求上限，到底存不存在一种应用场景是只能用漏桶而不能用令牌桶的呢？如果不追求严格的每秒请求上限，存不存在一种应用场景漏桶策略会优于令牌桶？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567190,"discussion_content":"漏桶和令牌桶在是否严格控制每秒请求上限上没区别啊，区别就是在于适用场景不同，比如一个计算密集型的应用在一个单CPU计算机上运行，每个请求需要运算10ms，那么显然设置rpu为100的漏桶比令牌桶更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650855877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1023762,"avatar":"","nickname":"开心小毛","note":"","ucode":"9D57A2773759F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":567210,"discussion_content":"在老师的例子中（“一个计算密集型的应用在一个单CPU计算机上运行，每个请求需要运算10ms”）如果选择令牌数上限为1的令牌桶策略，会比漏桶策略性能差么？还是说因为令牌桶会拒绝太多扎堆到来的请求？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650858079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":567190,"ip_address":""},"score":567210,"extra":""}]}]},{"had_liked":false,"id":341822,"user_name":"Tico","can_delete":false,"product_type":"c1","uid":2825710,"ip_address":"","ucode":"768F5FD8562DF5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqMd9DibRjo8gqHo4DRSZO3lkZ2KMezY3z9ia77kNKv8hRLLDCics35Ll2HTMt2Eiadk8uZA0l0EiaOvLQ/132","comment_is_top":false,"comment_ctime":1649846937,"is_pvip":false,"replies":[{"id":"124897","content":"开始队列为空的时候，如果同时来50个请求，都能放进队列，那就同时去执行？这不是漏桶，这是令牌桶。。。","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1649907934,"ip_address":"","comment_id":341822,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1649846937","product_id":100105701,"comment_content":"漏桶算法可以用于同步网关的场景，重点是不要把请求放到队列里面去消费，比如说设置一个50深度的队列，请求来我往队列里放一个对象（这个对象不是请求信息），若能放进队列说明队列未满可以继续执行请求，应用返回处理结果的时候去消费一个队列数据，若放不进去说明队列满了直接返回503","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562920,"discussion_content":"开始队列为空的时候，如果同时来50个请求，都能放进队列，那就同时去执行？这不是漏桶，这是令牌桶。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649907934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2825710,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqMd9DibRjo8gqHo4DRSZO3lkZ2KMezY3z9ia77kNKv8hRLLDCics35Ll2HTMt2Eiadk8uZA0l0EiaOvLQ/132","nickname":"Tico","note":"","ucode":"768F5FD8562DF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562932,"discussion_content":"嗯嗯，另外一种实现思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649910097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340504,"user_name":"dao","can_delete":false,"product_type":"c1","uid":1087879,"ip_address":"","ucode":"4181FB270462CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/99/87/98ebb20e.jpg","comment_is_top":false,"comment_ctime":1648866924,"is_pvip":true,"replies":[{"id":"124623","content":"赞","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1649211100,"ip_address":"","comment_id":340504,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648866924","product_id":100105701,"comment_content":"固定窗口是滑动窗口的一个特例。滑动窗口算法：<br>1）在同一时间片内累加计数；<br>2）在同一时间窗口内，切换时间片时计数会移交下一时间片；<br>3）窗口切换时，重置时间片序号和计算器。<br>固定窗口没有2），并且1）是指同一时间窗口，3）没有时间片序号重置。<br>个人看法，对于同一限流计数器，不需要特殊的数据结构，使用一般对象就可以。对象可能包含的信息如下，<br>{ 时间片序号，截止时间戳，计数 } （附：这个对象是复用的，在计数、时间片切换、窗口切换时更新）<br>多种限流计数器之间使用 hashmap 。<br>","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560144,"discussion_content":"赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649211100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339813,"user_name":"Lance-Yanh","can_delete":false,"product_type":"c1","uid":2925298,"ip_address":"","ucode":"2869845EFFBBDA","user_header":"https://static001.geekbang.org/account/avatar/00/2c/a2/f2/db06a8bc.jpg","comment_is_top":false,"comment_ctime":1648399197,"is_pvip":false,"replies":[{"id":"124257","content":"嗯嗯，具体如何实现呢，key value如何设计？时间片内请求如何计数？","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648446881,"ip_address":"","comment_id":339813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648399197","product_id":100105701,"comment_content":"本地用concurrentSkipListMap，远程用redis zset，辛苦老师点评","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558742,"discussion_content":"嗯嗯，具体如何实现呢，key value如何设计？时间片内请求如何计数？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648446881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339232,"user_name":"Geek_7347cf","can_delete":false,"product_type":"c1","uid":2343516,"ip_address":"","ucode":"2E25574FAB1B3B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mmTEibMibic5ibsVpNZkR3HBlpPpZYt0gHGdIqOduLGxRHZpTWRG3q56CT1eejoLgNsdaW5aQGWXfyibN4vm9CicYb3w/132","comment_is_top":false,"comment_ctime":1648001511,"is_pvip":false,"replies":[{"id":"123974","content":"1 这种情况可以用更小的窗口和更小的时间片改善<br>2 后3&#47;4并没有闲置，前面集中进来的请求还在服务器中处理呢，这就是限流器的目的。通常也不存在系统不可用时间&gt;系统可用时间，如果是集中在前1&#47;4进来的，就意味着后3&#47;4请求很少；如果前后的请求都很多，意味着正常请求就有这么多，那就是阈值设置不合理或者服务器部署太少了。","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648006253,"ip_address":"","comment_id":339232,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648001511","product_id":100105701,"comment_content":"对于固定窗口或滑动窗口 如果所有请求都集中在第一个1&#47;4区段触发阈值，那么后面3&#47;4区段将被闲置，无法处理用户请求，系统不可用时间&gt;系统可用时间，针对这种情况有没有比较好的解决方案","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557870,"discussion_content":"1 这种情况可以用更小的窗口和更小的时间片改善\n2 后3/4并没有闲置，前面集中进来的请求还在服务器中处理呢，这就是限流器的目的。通常也不存在系统不可用时间&gt;系统可用时间，如果是集中在前1/4进来的，就意味着后3/4请求很少；如果前后的请求都很多，意味着正常请求就有这么多，那就是阈值设置不合理或者服务器部署太少了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648006253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339229,"user_name":"Geek_7347cf","can_delete":false,"product_type":"c1","uid":2343516,"ip_address":"","ucode":"2E25574FAB1B3B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/mmTEibMibic5ibsVpNZkR3HBlpPpZYt0gHGdIqOduLGxRHZpTWRG3q56CT1eejoLgNsdaW5aQGWXfyibN4vm9CicYb3w/132","comment_is_top":false,"comment_ctime":1648000759,"is_pvip":false,"replies":[{"id":"123972","content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648005828,"ip_address":"","comment_id":339229,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648000759","product_id":100105701,"comment_content":"重置窗口时间的逻辑 在高并发场景下 是不是应该考虑锁的问题","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557866,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648005828,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339227,"user_name":"奔浪","can_delete":false,"product_type":"c1","uid":2915106,"ip_address":"","ucode":"537B9FB02F5EA0","user_header":"https://static001.geekbang.org/account/avatar/00/2c/7b/22/2a810977.jpg","comment_is_top":false,"comment_ctime":1648000161,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648000161","product_id":100105701,"comment_content":"首先:<br>        能想到的是链表带头尾指针呢种，新来的从头部插入，而检查是否过期直接从尾部检查【前提是进入的元素要带有时间否则没法判断】<br>第二种:<br>        基于上面进行变形，上面检查是否过期是有个一线程定时轮询，或者在准备进入新元素的时候被动检查是否能弹出过期元素这样的我们也可以将此工作封入链表结构本身，在插入元素自动检查尾部元素是否过期如果过期自动弹出。<br>        当然以上当检查到尾部有过期的那么接着迭代检查下一个元素","like_count":0},{"had_liked":false,"id":339220,"user_name":"丫丫","can_delete":false,"product_type":"c1","uid":2896229,"ip_address":"","ucode":"982AE515E87971","user_header":"","comment_is_top":false,"comment_ctime":1647999286,"is_pvip":false,"replies":[{"id":"123971","content":"Redis进行全局计数","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648005767,"ip_address":"","comment_id":339220,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1647999286","product_id":100105701,"comment_content":"谢谢老师的专题！<br>请问老师，在分布式限流中，本地限流器如何知道其他限流器的计数，工程中用什么同步算法或者协议？谢谢老师。","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557865,"discussion_content":"Redis进行全局计数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648005767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2896229,"avatar":"","nickname":"丫丫","note":"","ucode":"982AE515E87971","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":557884,"discussion_content":"老师可能我的问题没有问好， 如果qps超过了百万级别，我们必须要使用redis集群，这个时候如何获取全局的限流器计数呢？集群中消息同步肯定会有延迟， 如何在最快的速度同步呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648017267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":557865,"ip_address":""},"score":557884,"extra":""},{"author":{"id":2911084,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6b/6c/3e80afaf.jpg","nickname":"HappyHasson","note":"","ucode":"B84CC43E349CFA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2896229,"avatar":"","nickname":"丫丫","note":"","ucode":"982AE515E87971","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558216,"discussion_content":"一种类型的计数器就一个key，qps大小不影响redis集群，计数器个数才影响","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648136846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":557884,"ip_address":""},"score":558216,"extra":""}]}]},{"had_liked":false,"id":339214,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1647995520,"is_pvip":true,"replies":[{"id":"123970","content":"1 快速看了下sentinel文档，sentinel的控制台是独立部署，sentinel流控组件也需要和网关或者应用部署在一起。<br>2 可以<br>3 不是，请求进入的时候判断，文中有讲<br>","user_name":"作者回复","user_name_real":"编辑","uid":"1007349","ctime":1648005717,"ip_address":"","comment_id":339214,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647995520","product_id":100105701,"comment_content":"请教老师几个问题啊：<br>Q1：限流器可以和网关相互独立吗？<br>文中提到的限流器是网关的一个组件，限流器不是独立的。SpringCloud中的sentinel和网关是独立部署的。限流器应该可以和网关相互独立吧。<br>Q2：Nginx可以作为限流器使用吗？<br>Q3：固定窗口方法中的时间结束是通过定时器实现的吗？","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557863,"discussion_content":"1 快速看了下sentinel文档，sentinel的控制台是独立部署，sentinel流控组件也需要和网关或者应用部署在一起。\n2 可以\n3 不是，请求进入的时候判断，文中有讲\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648005717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}