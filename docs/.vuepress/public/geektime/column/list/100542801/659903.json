{"id":659903,"title":"15｜基于Flask的推荐服务：如何把召回集推荐出去？","content":"<p>你好，我是黄鸿波。</p><p>在前面的课程中，我们搭建了一个简单的Flask服务，并且已经可以通过Postman来进行调用，这节课我们将在此基础上，把基于规则的召回集成进来并推荐给用户。这节课你会学到下面的内容。</p><ol>\n<li>写一个基于时间的召回，并存储到Redis数据库中。</li>\n<li>编写一个翻页查询服务，能够进行翻页查询。</li>\n<li>编写Service服务，将基于时间的召回推荐给用户。</li>\n</ol><h2>编写基于时间的召回</h2><p>推荐系统如果想要将内容推荐给用户，首先要做的就是要找到合适的内容，然后将这些内容通过一定的整理和排序，按照一定的规则推荐给用户。这些规则可能是时间、热度、相似度以及一些用于特征的评分，也可以是这些中一个或者多个算法的结合。在这节课里，我们就先用简单的基于时间的召回算法来做。</p><p>首先，我们来回顾一下我们之前的内容画像，下图是内容画像其中的一条数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/ac/b5dfdc8ac8f03980aebe4de0ba3017ac.png?wh=1920x254\" alt=\"图片\"></p><p>我们可以看到，我们的用户画像实际上是由10个字段组成，在这10个字段中，第一个字段 _id 是MongoDB数据库为我们生成的一个唯一的id值，我们可以用其作为索引，来标记其唯一性。</p><p>与时间相关的字段有2个，一个是news_date，另一个是create_time。在这两个字段中，news_date表示的是新闻发布的时间，create_time指的是这个新闻的入库时间（也就是爬虫爬取的时间），这两个时间作为特征数据在不同的算法中有不同的用处。我们目前是想要基于时间来进行召回，这个时间最好使用新闻的发布时间，因为新闻发布时间属于新闻本身的一个特征，可以防止“时间穿越”事件的发生。</p><!-- [[[read_end]]] --><p>“时间穿越”是指在现在的时间点出现了未来的内容。比如说，我们在2023年3月16日爬取了一批3月1号之前的新闻，按理来说爬取的内容都是在3月1日之前的数据，这时突然出现了一个3月15号的新闻事件，虽然3月15日在现实生活中已经过去，但是在数据库里是一个未发生的数据，我们就称之为“时间穿越”。<strong>在推荐系统中，要尤其注意避免“时间穿越”问题。</strong></p><p>我们再来想另外一个问题，既然我们要将内容推荐给用户，什么方法是最高效的呢？</p><p>如果我们直接从MongoDB中查询我们想要的数据，然后再组装到用户界面上，效率就会变得非常低。因为首先MongoDB是文档型数据库，对于这种快速存取本身不是特别擅长，此外我们还要对MongoDB做按时间的倒序排序，本身也会有比较大的时间开销。所以在这里最好的解决办法就是使用Redis数据库来进行存取，这样能够使用户更加快速地得到内容。</p><p>总结一下，我们第一步是将我们的数据从MongoDB数据库中取出，然后按照时间的倒序进行排序存入到Redis数据库中。当需要给用户进行推荐的时候，我们直接从Redis数据库中读取数据，然后进行组装后推荐。</p><p>接下来我们来看看怎么实现这一步。</p><p>首先，在我们的recommendation_class项目中，有一个名为scheduler的目录。这个目录一般用来存放需要定时运行的任务，比如定时进行离线的召回、定时清除数据库中的无用数据、定时更新推荐列表等等。</p><p>随着时间的变更，爬虫新爬取出来的数据应该被及时加到里面，因此我们需要在里面新建一个Python文件，我们将其命名为date_recall.py，然后在这个文件中做基于时间的召回。我们在做基于时间召回的时候需要设置一个时间范围，不需要对过于久远的内容进行召回。比如说超过一周的内容，我们认为就没有了时间的时效性。</p><p>还记得我们在讲爬虫的时候给你留的一个<a href=\"https://time.geekbang.org/column/article/652864\">小作业</a>吗？我们将数据重新爬取一遍并重新制作一下我们的内容画像，此时，你需要参考之前的课程完成以下2个步骤。</p><ol>\n<li>将之前MongoDB数据库中scrapy_data数据库的Collection删掉，重新跑一遍爬虫程序，爬取更多的分类和更多的数据。</li>\n<li>将之前MongoDB数据库中recommendation数据库的Collection删掉，重新跑一遍内容画像中的数据。</li>\n</ol><p>我先来说一下我的新版代码（作业的拓展版）。在新版代码中我一共爬取了3个类别的数据，分别是国内新闻、电影、娱乐，并在main.py文件中设置了1个叫page的参数，目的是指定我爬取多少页的内容。这个时候，在爬虫页也会有对应爬取的页数设置。</p><p>经过10页数据的爬取，目前数据库总条数有243条，并将其制作成了内容画像。接下来，我们要将这一批数据按照时间顺序存入到数据库中。</p><p>由于我们所爬取的类别较少，并且娱乐和电影类别更新得又不是特别频繁，因此我们取国内新闻20天内的数据，娱乐和电影我们取3个月内的数据存入到Redis数据库中。</p><p>我们首先在项目中新建一个Redis数据库的连接工具类，用作连接Redis数据库。我们在dao目录下新建一个名为 redis_db.py 的Python文件，并编写如下代码。</p><pre><code class=\"language-plain\">#!/usr/bin/env python \n# -*- coding: utf-8 -*-\nimport redis\n&nbsp;\n&nbsp;\nclass Redis(object):\n&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self):\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.redis = redis.StrictRedis(host= '127.0.0.1',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port= 6379,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;password= '',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decode_responses=True)\n</code></pre><p>这段代码非常简单，就是导入了Redis库，然后建立了一个数据库连接的变量连接到了本机，端口为6379。</p><p>然后，我们再来编写scheduler目录下的date_recall.py文件。这个文件要从MongoDB中获取数据，然后按照时间的倒序插入到Redis数据库中。在这里，我们介绍一个Redis数据库中常用的数据结构ZADD。</p><p>ZADD命令用于将一个或多个成员元素及其分数值加入到有序集当中。如果某个成员已经是有序集的成员，更新这个成员的分数值，并通过重新插入这个成员元素来保证该成员在正确的位置上。分数值可以是整数值或双精度浮点数。如果有序集合 key不存在，则创建一个空的有序集并执行ZADD操作。</p><p>在推荐系统中ZADD命令非常常用，我们可以将最外面的key用用户id或者推荐列表的类型（比如基于时间的召回、基于热度的召回）来代替，里面的key作为推荐内容的content_id，value（也就是分数）作为相关度评分或者排序的顺序倒序。</p><p>当有用户需要推荐的时候，我们就从这里拿出相应的数据来进行推荐，比如一次取10个content_id作为推荐列表，我们来编写一下这个文件的代码。</p><pre><code class=\"language-plain\">from dao import redis_db\nfrom dao.mongo_db import MongoDB\n&nbsp;\n&nbsp;\nclass DateRecList(object):\n&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self):\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._redis = redis_db.Redis()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.mongo = MongoDB(db='recommendation')\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.db_content = self.mongo.db_recommendation\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.collection_test = self.db_content['content_label']\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;def get_news_order_by_time(self):\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ids = list()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = self.collection_test.find().sort([{\"$news_date\", -1}])\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count = 10000\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for news in data:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._redis.redis.zadd(\"rec_date_list\", {str(news['_id']): count})\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count -= 1\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(count)\n&nbsp;\n&nbsp;\nif __name__ == '__main__':\n&nbsp;&nbsp;&nbsp;&nbsp;date_rec = DateRecList()\n&nbsp;&nbsp;&nbsp;&nbsp;date_rec.get_news_order_by_time()\n</code></pre><p>这段代码也相对比较简单，首先我们从MongoDB数据库中读取数据，并按照新闻的时间进行降序排序，把它赋值给一个变量data。然后我们再把数据插入到Redis数据库中，在插入到Redis数据库中的时候，我们使用的是ZADD方法。</p><blockquote>\n<p>ZADD的优势是能够按照一定的顺序进行排序，这个顺序可以是升序也可以是降序。一般来讲，我们会以降序的方式排序，无论是时间还是分数都是如此。如果是时间降序的时候，就会将最新的内容排在前面，用户会看到比较新鲜的内容；如果是按照分数降序，就是将用户最感兴趣的内容放在前面，增加用户的点击率和用户的黏性。<br>\n&nbsp;<br>\n在往Redis数据库中插入数据的时候，我们将key设置为 rec_date_list，这样的话所有使用时间召回算法的用户都会共用这一个列表，从而进行推荐。</p>\n</blockquote><p>除此之外，这里面我还设置了一个count值。在ZADD命令中以score作为排序依据，但是时间并不是一个score。所以我在这里预先设置了一个比较大的值，然后按照这个值的降序给内容赋予分值，这样最高分代表了时间最靠前的内容，我们再进行推荐的时候，就可以按照这个方式进行推荐了。</p><p>运行上面的代码之后，我们在Redis数据库中查看一下结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/b5/8a9ce4791e67ffb5810881fa6a5ecbb5.png?wh=1920x508\" alt=\"图片\"></p><p>可以看到，我们的内容已经插入进去了。</p><p>到了现在，我们是不是就可以写Service的代码，然后将数据推送给用户了呢？当然可以，但是按照企业级的推荐方式，我不建议这么做。</p><p>首先，如果用这种方式我们需要从Redis中拿完每一个id，然后再跑去MongoDB中查询相对应的内容，这样做实在是太慢了。用户量和内容量比较少的话还行，一旦我们的用户量以及数据库中的内容比较多，用这种方法就会导致推送的速度非常慢，从而影响用户体验。</p><p>比较好的一种方式就是将我们需要的内容存储到Redis数据库中，当列表需要查询数据时就直接从Redis中进行数据的调用，这样效率就会非常高。因此，我们在scheduler目录下新建一个mongo_to_redis_content.py文件，用来将MongoDB中的内容存到Redis数据库中，我们可以在里面编写如下代码。</p><pre><code class=\"language-plain\">from dao import redis_db\nfrom dao.mongo_db import MongoDB\n&nbsp;\n&nbsp;\nclass mongo_to_redis_content(object):\n&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self):\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._redis = redis_db.Redis()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.mongo = MongoDB(db='recommendation')\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.db_recommendation = self.mongo.db_recommendation\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.collection_content = self.db_recommendation['content_label']\n&nbsp;\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;def get_from_mongoDB(self):\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pipelines = [{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'$group': {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'_id': \"$type\"\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;types = self.collection_content.aggregate(pipelines)\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for type in types:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;collection = {\"type\": type['_id']}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = self.collection_content.find(collection)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x in data:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = dict()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result['content_id'] = str(x['_id'])\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result['describe'] = x['describe']\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result['type'] = x['type']\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result['news_date'] = x['news_date']\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result['title'] = x['title']\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._redis.redis.set(\"news_detail:\" + str(x['_id']), str(result))\n&nbsp;\n&nbsp;\nif __name__ == '__main__':\n&nbsp;&nbsp;&nbsp;&nbsp;write_to_redis = mongo_to_redis_content()\n&nbsp;&nbsp;&nbsp;&nbsp;write_to_redis.get_from_mongoDB()\n</code></pre><p>这段代码就是从MongoDB中获取内容，然后存储到Redis数据库中。只不过在这里，我们使用了一个新的Redis命令，叫做SET。</p><p>Redis的Set命令用于在Redis键中设置一些字符串值，在这里我们一个key可以对应一个字符串，也就是说我们可以将内容作为value传入进去。因此，我设置了key的值为 “news_detail:” 加上content_id，这样就可以保证key的唯一性。然后再将value设置为内容，当有需要取内容的时候，我们就去取 “news_detail:content_id”。这样的话，整个效率会有质的提升。</p><p>我们运行上面的代码，可以得到下面的结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/d8/f35cce94f13b3f2f2e0c2b332c4b56d8.png?wh=1920x1049\" alt=\"图片\"></p><p>我们可以看到，现在Redis数据库中就是按照我们的设想来的，已经能够把每一个文章的详细信息都写入了进去。在这里，我们只需要内容的id、内容本身、标题、类型和时间这5个字段即可。</p><h2>将基于时间的召回推荐给用户</h2><p>在前面的课程中，我们已经建立了一个最基本的Flask项目，接下来我们就要在这个Flask项目的基础上，开发我们第一个基于时间的推荐服务。</p><ol>\n<li>一个简单的翻页功能，因为不可能每次都把所有的id传过去，所以加上一个翻页功能，能够让用户有更好的体验。</li>\n<li>将基于时间的召回集推荐给用户。</li>\n</ol><p>我们首先打开之前的recommendation-service这个项目，切换到我们的recommendation-service的Anaconda环境下，安装一些我们所需要的库，这里我们执行如下命令来安装Redis库。</p><pre><code class=\"language-plain\">pip install redis\n</code></pre><p>然后在这个项目中新建一个叫utils的目录，主要是放置一些工具类。比如说我们的这个分页，实际上也可以看做是一个工具。然后我们在这个utils目录下，新建一个分页工具，名为page_utils.py。然后我们新建一个dao目录，将我们的Redis数据库连接工具从其他项目中复制过来，命名为redis_db.py，此时目录结构如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/ee/2b1812be06885dbb1efef9201ce034ee.png?wh=619x841\" alt=\"图片\"></p><p>接下来我们来写这两个文件的代码，首先是redis_db.py文件的代码。</p><pre><code class=\"language-plain\">import redis\n&nbsp;\nclass Redis(object):\n&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self):\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.redis = redis.StrictRedis(host='localhost',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port=6379,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db=10,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;password='',\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;decode_responses=True)\n</code></pre><p>上面这段代码我们前面多次用到，这里我们重点看一下page_utils.py文件的代码。</p><pre><code class=\"language-plain\">from dao import redis_db\n&nbsp;\nclass page_utils(object):\n&nbsp;&nbsp;&nbsp;&nbsp;def __init__(self):\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self._redis = redis_db.Redis()\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;def get_data_with_page(self, page, page_size):\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start = (page - 1) * page_size\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end = start + page_size\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = self._redis.redis.zrevrange(\"rec_date_list\", start, end)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lst = list()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for x in data:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info = self._redis.redis.get(\"news_detail:\" + x)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lst.append(info)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return lst\n&nbsp;\nif __name__ == '__main__':\n&nbsp;&nbsp;&nbsp;&nbsp;page_size = page_utils()\n&nbsp;&nbsp;&nbsp;&nbsp;print(page_size.get_data_with_page(1, 20))\n</code></pre><p>这段代码主要是实现一个翻页的功能，我在里面实现了一个名字叫做get_data_with_page()的函数。在这里需要传入page和page_size两个参数，page表示当前需要请求第几页，page_size表示每一页有多少条内容。使用这种方法，对于前端界面的翻页和用户体验都有极大的帮助。</p><p>有了翻页功能之后，就可以正式写我们的接口程序了。接口程序在app.py这个文件里，原本的app.py是一个非常简单的程序，现在我们来对这个程序做一个改写。</p><pre><code class=\"language-plain\">from flask import Flask, request, jsonify\nimport json\nfrom utlis.page_utils import page_utils\npage_query = page_utils()\n&nbsp;\napp = Flask(__name__)\n&nbsp;\n&nbsp;\n@app.route('/')\ndef hello_world():\n&nbsp;&nbsp;&nbsp;&nbsp;return 'Hello World!'\n&nbsp;\n@app.route('/hello_rec', methods=[\"POST\"])\ndef hello_recommendation():\n&nbsp;&nbsp;&nbsp;&nbsp;try:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if request.method == 'POST':\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;req_json = request.get_data()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rec_obj = json.loads(req_json)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user_id = rec_obj[\"user_id\"]\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return jsonify({\"code\": 0, \"msg\": \"请求成功\", \"data\": \"hello \" + user_id})\n&nbsp;&nbsp;&nbsp;&nbsp;except:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return jsonify({\"code\": 2000, \"msg\": \"error\"})\n&nbsp;\n@app.route(\"/recommendation/get_rec_list\", methods=['POST'])\ndef get_rec_list():\n&nbsp;&nbsp;&nbsp;&nbsp;if request.method == 'POST':\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;req_json = request.get_data()\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rec_obj = json.loads(req_json)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_num = rec_obj['page_num']\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;page_size = rec_obj['page_size']\n&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data = page_query.get_data_with_page(page_num, page_size)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return jsonify({\"code\": 0, \"msg\": \"请求成功\", \"data\": data})\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;except Exception as e:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(str(e))\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return jsonify({\"code\": 2000, \"msg\": \"error\"})\n&nbsp;\nif __name__ == '__main__':\n\tapp.run(port=10086)\n</code></pre><p>这段代码是一段WebService代码，就是把我们的服务提供成一个API接口进行调用，接收用户前端的请求。请求的参数有以下两个。</p><ul>\n<li>page_num，表示当前请求的是第几页的内容。</li>\n<li>page_size，表示当前请求的每一页有多少条数据。</li>\n</ul><p>当用户从客户端发送请求之后，在WebService端就会使用POST接收这两参数，然后传递到page_query的get_data_with_page()函数中，这个时候，函数内部就会根据请求的参数去数据库查询，然后返回相应的结果。</p><p>下面，我们来运行一下我们的app.py程序，此时会得到如下结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/09/61df648deddce54d94ea25d9ef646c09.png?wh=1920x298\" alt=\"图片\"></p><p>现在我们的程序已经运行成功了，接下来我们使用Postman来尝试调用一下它。</p><p><img src=\"https://static001.geekbang.org/resource/image/72/eb/7275e5e80fcb22yy5200e0860d50d4eb.png?wh=1920x1042\" alt=\"图片\"></p><p>我们可以发现，现在我们输出的内容就是按照时间倒序排序的，并且，我们调用时请求的参数为page_num和page_size。</p><p></p><h2><strong>总结</strong></h2><p>现在我们已经能够把按照时间召回的内容推送出去了，今天我们主要讲了下面五个要点。</p><ol>\n<li>基于时间召回可以和用户画像相结合进行召回。</li>\n<li>基于时间召回需要特别注意“时间穿越”的问题。</li>\n<li>你应该熟悉如何将MongoDB里面的数据按照时间顺序插入到Redis。</li>\n<li>在推荐系统进行推荐的时候，知道如何做能够使推荐的效率更高、速度更快。</li>\n<li>我们可以使用翻页请求的方式来提高用户体验。</li>\n</ol><h2>思考题</h2><p>学完今天的课程，给你留两个小作业。</p><ol>\n<li>复现今天的课程内容。</li>\n<li>给推荐过的内容存储在Redis已推荐列表中，并且下次推荐时候去除这一部分内容。</li>\n</ol><p>期待你的分享，如果今天的内容让你有所收获，也欢迎你推荐给有需要的朋友！</p>","comments":[{"had_liked":false,"id":380984,"user_name":"Weitzenböck","can_delete":false,"product_type":"c1","uid":2669122,"ip_address":"江苏","ucode":"78C92583084ABA","user_header":"https://static001.geekbang.org/account/avatar/00/28/ba/42/5ca553bd.jpg","comment_is_top":false,"comment_ctime":1694529533,"is_pvip":false,"replies":[{"id":140012,"content":"https:&#47;&#47;github.com&#47;ipeaking&#47;recommendation\n\nhttps:&#47;&#47;github.com&#47;ipeaking&#47;scrapy_sina","user_name":"作者回复","user_name_real":"编辑","uid":1982950,"ctime":1699860302,"ip_address":"广东","comment_id":380984,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100542801,"comment_content":"这个代码到底在哪里啊？学了那么久了都没有看到","like_count":0,"discussions":[{"author":{"id":1982950,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/41/e6/beb42103.jpg","nickname":"黄鸿波","note":"","ucode":"5EB4E6946A363C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631646,"discussion_content":"https://github.com/ipeaking/recommendation\n\nhttps://github.com/ipeaking/scrapy_sina","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699860302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374869,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1684541834,"is_pvip":false,"replies":[{"id":136910,"content":"A1：同学您好，不好意思，最近事情有点多，源码将在下周左右提供；\nA2：一般来讲，都是用一个基本的推荐算法作为基础，然后配合深度学习的推荐来去做的，比如说YouTubeDNN或者双塔模型，但是具体用的是什么，这个我们无法判断；\nA3：我们这里面的分数实际上是写死的一个序列，在用其他算法，比如说YouTubeDNN或者协同过滤的时候，会有具体的分数，那些是计算出来的。","user_name":"作者回复","user_name_real":"作者","uid":1982950,"ctime":1685029968,"ip_address":"广东","comment_id":374869,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100542801,"comment_content":"Q1：源码链接已经提供了吗？\nQ2：百度首页会提供推荐列表，估计是什么算法？\nQ3：本文开始的“分数”，是根据什么确定的？某一个值可能选一个特殊值，比如特别大的数值，那其他的分数呢？","like_count":0,"discussions":[{"author":{"id":1982950,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/41/e6/beb42103.jpg","nickname":"黄鸿波","note":"","ucode":"5EB4E6946A363C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619369,"discussion_content":"A1：同学您好，不好意思，最近事情有点多，源码将在下周左右提供；\nA2：一般来讲，都是用一个基本的推荐算法作为基础，然后配合深度学习的推荐来去做的，比如说YouTubeDNN或者双塔模型，但是具体用的是什么，这个我们无法判断；\nA3：我们这里面的分数实际上是写死的一个序列，在用其他算法，比如说YouTubeDNN或者协同过滤的时候，会有具体的分数，那些是计算出来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685029969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374828,"user_name":"Geek_ccc0fd","can_delete":false,"product_type":"c1","uid":1461544,"ip_address":"广东","ucode":"DB53D576AEC020","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/EaBxhibOicZe9L7z2icbU4W462l543drFWYqibqczTicj4Msyb2g9pDSGmFTiafW9jibwib7jG6hpAdPMcCowdCiaxHaOdA/132","comment_is_top":false,"comment_ctime":1684468196,"is_pvip":false,"replies":[{"id":136882,"content":"这个可能是因为版本的不同会导致细微的差异，大家遇到这种问题可以自行百度下，有好的实践经验，也可以一起分享下。","user_name":"作者回复","user_name_real":"编辑","uid":1982950,"ctime":1684858274,"ip_address":"广东","comment_id":374828,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100542801,"comment_content":"从mongodb获取排序数据报错：pymongo.errors.OperationFailure: FieldPath field names may not start with &#39;$&#39;.\n发现不需要带$,我的pymongo版本4.3.3，正确代码：\ndata = self.collection_test.find().sort([{&quot;$news_date&quot;, -1}])\n","like_count":0,"discussions":[{"author":{"id":1982950,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/41/e6/beb42103.jpg","nickname":"黄鸿波","note":"","ucode":"5EB4E6946A363C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619199,"discussion_content":"这个可能是因为版本的不同会导致细微的差异，大家遇到这种问题可以自行百度下，有好的实践经验，也可以一起分享下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1684858274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387006,"user_name":"叶圣枫","can_delete":false,"product_type":"c1","uid":1126794,"ip_address":"上海","ucode":"6DE65AB06AD20E","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/8a/be3b7ae6.jpg","comment_is_top":false,"comment_ctime":1706150479,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100542801,"comment_content":"StrictRedis 构造的时候要指定本地的db id，不一定是db=10. \n我的本地是0。","like_count":0},{"had_liked":false,"id":385322,"user_name":"悟尘","can_delete":false,"product_type":"c1","uid":2189310,"ip_address":"北京","ucode":"4E7E854340D3A4","user_header":"https://static001.geekbang.org/account/avatar/00/21/67/fe/5d17661a.jpg","comment_is_top":false,"comment_ctime":1702447590,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100542801,"comment_content":"文稿中的代码示例和github里的代码不一样呀，有点出入，应该以哪个为准？","like_count":0,"discussions":[{"author":{"id":1126794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/31/8a/be3b7ae6.jpg","nickname":"叶圣枫","note":"","ucode":"6DE65AB06AD20E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636443,"discussion_content":"我的经验是两边的代码都要依据本地环境微调一下，都不能直接跑起来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1706150590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}