{"id":740982,"title":"第 10 章 设计质量贯穿始终(2)","content":"<h2 id=\"nav_point_238\">10.4　代码评审和结对编程</h2>\n<p>测试是发现代码质量问题的有效手段。但在大多数时候，测试关注的是功能问题，难以发现设计问题。</p>\n<p>软件设计本质上是一个智力活动。为了有效地发现设计质量问题、提升设计质量，最好的方法是引入更多人的智慧。本节我们将介绍两个彼此相关的实践：代码评审和结对编程。</p>\n<h3 id=\"nav_point_239\">10.4.1　正确认识代码评审的价值</h3>\n<p>顾名思义，代码评审是在代码编码过程中，或编码完成后，由其他开发者阅读代码，以提升代码质量的活动。代码评审看起来很简单，但是在现实中，经常出现各种错误的做法。这些做法导致许多团队付出了代码评审的成本，却没有取得应有的收益。</p>\n<p><strong>代码评审的目标不是发现功能上的缺陷</strong></p>\n<p>代码评审最本质的作用并不是发现问题。如果只是发现问题，那代码评审是一种极其低效的方法，测试先行已经建立了自动化测试，用计算机来查错比人类查错可高效多了。</p>\n<p>代码评审的核心作用是提升设计质量、统一设计风格和建立长期的代码文化。在代码评审的过程中，团队成员对于什么是好的设计的认知会逐渐趋同，并会以编写高质量的代码为荣。与此同时，无论是评审者还是被评审者，都能持续学习，并因此提高编程技能。</p>\n<p>当然，不可否认的是，代码评审一定也能或多或少地发现代码中的逻辑问题。但是，把发现问题作为代码评审的目标，显然是一种不合理的责任转移。代码实现者有义务保证代码逻辑的正确性。把检验代码是否正确的期望过多地寄托到代码评审上，既低效，又有害。</p><!-- [[[read_end]]] -->\n<p><strong>代码评审保障了代码的可理解性</strong></p>\n<p>高质量的设计应该是易于理解的。什么是易于理解呢？一般来说，不管一段代码有多么糟糕，它的作者都不会觉得自己的代码难以理解。</p>\n<p>尽管设计原则、度量工具等都可以在一定程度上为可理解性提供指导和反馈，但是最有效的方式是：在代码写完之后立即请人阅读。如果不是立即阅读，而是在若干月，甚至若干年后用到这段代码时才发现代码不可读，那显然已经太迟了。</p>\n<p>代码评审强制提前了反馈周期。对于结对编程，由于两个开发者始终坐在一起，所以反馈速度会更快。引入评审者角色后，代码立即就有了一位或多位读者，这段代码也就立即经历了可读性的检验，从而避免了持续累积的复杂代码给团队带来维护噩梦。</p>\n<p><strong>代码评审引起知识传播，促进设计共识</strong></p>\n<p>几乎没有程序员不知道“高内聚、低耦合”这个设计原则。但是，知道设计原则是一回事，能把设计原则灵活地运用在实践中是另一回事。不少程序员有过这样的经历：尽管已经花费了许多时间学习技能，但是在具体的场景中还是不知道怎么应用它。通过代码评审可以见识很多鲜活的设计案例，这是促进知识传播的好方法。</p>\n<p>有时候即使对于同一个具体的概念，团队中的不同开发者可能会有不同的想法。我就曾经在代码评审活动中参与过关于早崩溃设计原则的激烈讨论。有人认为早崩溃很合理，有人则更担心可靠性，并对早崩溃激烈地提出反对意见。这其实是非常好的达成设计共识的机会。</p>\n<p>抽象的讨论往往不容易引起争议，但是具体的业务场景就不一样了。把抽象的理论和概念落实到具体的事情上，会让案例更鲜活，讨论也更充分。这正如海洋法系的“判例”制度。判例制度把抽象的法律条文形成了具体的案例解释，可以让其他法官在面对类似的问题时有据可依。要是只是抽象的法律条文，那不同的法官就可能会有不同的解读。代码评审其实也形成了设计上的判例：哪一类设计是合理的，哪一类设计是不合理的。通过针对具体的问题进行具体分析，团队成员会逐渐形成设计共识。</p>\n<p><strong>代码评审有助于塑造代码文化</strong></p>\n<p>一个充满代码文化、非常关注代码质量的团队是不可能产出低质量代码的。在一个拥有更好的代码文化的团队中工作，程序员的幸福感也会大大增强。那么，怎么塑造代码文化呢？</p>\n<p>在实际项目中，有一个非常重要的代码文化干扰因素——交付压力。当交付迫在眉睫的时候，不少人会下意识地做出短期有利的选择——优先保证交付。至于质量问题，特别是看不见的设计质量问题——则是“以后再说”。</p>\n<p>代码评审引入了一种非常有趣的系统动力。对于评审者来说，由于代码评审本来就是探讨应该如何提高设计质量的过程，所以通过不断的辩论，他们脑海中关于质量的意识都会得到加强。对于被评审者来说，除了这种讨论过程，还存在一种良性的社会压力：只要想到“还会有很多人会阅读我的代码”，程序员就不太会选择那种只在短期获得收益，在长期会造成较大损失的“投机”行为。毕竟，爱惜个人荣耀是人与生俱来的特征。</p>\n<h3 id=\"nav_point_240\">10.4.2　正确组织代码评审</h3>\n<p>组织高质量的代码评审需要一些策略。毕竟，代码评审是较为消耗脑力和时间的活动，因为策略不当把代码评审做成表面文章的情况也不在少数。</p>\n<p><strong>应该采用线下评审还是线上评审</strong></p>\n<p>线下评审也叫作圆桌评审，是团队级别的评审，实施成本相对较高。毕竟要召集许多人，就一份代码展开讨论，是需要腾出大块时间的。线上评审则比较便利，发出评审、完成评审的操作可以异步进行，能较好地利用碎片时间。</p>\n<p>不过，线下评审和线上评审的收益也有所不同。线下讨论往往会更深入，知识的传播面也比较广。有时候，他人的意见往往能给参与者带来更多启发，形成思维的碰撞。线上评审的参与者则一般较少，由于缺少实时互动，知识传播或者思维碰撞的范围也就较小。</p>\n<p>因此，不少团队采取的是线上、线下相结合的方式。在日常的评审活动中，他们通过线上评审提升效率，同时定期或者不定期地组织线下评审，对比较集中或者关注度较高的问题进行讨论，同线上评审形成互补。</p>\n<p><strong>尽量减小所评审代码的批量</strong></p>\n<p>不要让一次代码评审涉及太多代码。想象一下，一个本来就对你的代码上下文不是太理解的人，在忙碌于各种各样任务的同时，一下子收到了成百上千行需要评审的代码，那他需要付出多大的耐心，具备多强的理解力才能给出有效的反馈？</p>\n<p>在保证评审的代码具有完整意义的情况下，规模越小，代码评审就越有效。有研究表明<sup>[47]</sup>，当评审的代码量较少时，发现问题的概率会大大增加。如果每次评审的代码量超过 400 行，那么发现问题的概率会大幅减小。</p>\n<p>在实践中，成熟的团队会避免对大批量的代码进行评审。例如，一项针对 Google\n的代码评审实践的调研表明<sup>[48]</sup>，有 35% 的情况是仅仅修改了一个文件，90% 的情况修改的文件数在 10 个以内，甚至有 10% 的情况下仅仅修改了 1 行代码。好处是显而易见的——修改了哪里非常清晰，问题也会一目了然。</p>\n<p><strong>重视单元测试的价值</strong></p>\n<p>在代码评审中也会涉及单元测试？是的——单元测试非常重要。带有单元测试的代码会提供更多关于代码更新的上下文，让代码评审具有更高的效率和质量。</p>\n<p>团队如果真正重视单元测试，就需要把单元测试作为代码资产的一部分，代码评审在一定程度上也让单元测试的策略得到了更好的实施。所以，代码评审和单元测试具有双向的推动作用。</p>\n<p><strong>采用结对编程实践</strong></p>\n<p>当把代码评审中的代码批量减少到极致，把面对面的代码评审推进到极致时，就出现了一种新的实践：结对编程。</p>\n<p>结对编程源自极限编程，它是少有的同时融合了知识传播、开发质量和开发效率的编程实践。结对编程看起来很容易，但绝不意味着给一台电脑接上两个鼠标和两个键盘就是结对编程了。真正决定结对编程效果的因素往往是细节。文化因素对结对编程的效果有着至关重要的影响。</p>\n<p>结对编程中结对的程序员需要持续地进行沟通和讨论。这会带来两方面的益处：第一，由于必须把思路说出来，所以会立即检验代码的设计思路，保证其可理解性。第二，把思路说出来本身会促进思考，从而使思考结构更清晰，减少了编码过程中的错误。</p>\n<h2 id=\"nav_point_241\">10.5　代码质量度量和问题检测</h2>\n<p>程序员通过代码来自动化业务逻辑、自动化控制系统、自动化各种场景。那么，程序员每天关心的代码质量是不是也应该自动化？这就是我们本节的主题：使用工具来度量代码质量、检测代码问题，从而辅助程序员写出更高质量的代码。</p>\n<p>实现代码质量度量和问题检测的难度是很高的。这是因为软件代码的问题极其复杂。严格来说，能对代码进行精确评价的工具迄今为止还没有产生。不过，作为提升代码质量的辅助手段，存在许多经过实践检验的指标和方法。而且，理解这些指标往往有助于程序员写出更高质量的代码。</p>\n<p>下面我们就按照度量和检验目标的不同，介绍一些常见且重要的度量指标以及背后的设计思想。由于具体的检测工具会持续发展，因此本节提到的工具仅作为示例，请读者重点关注它们背后的方法。</p>\n<h3 id=\"nav_point_242\">10.5.1　缺陷检测</h3>\n<p>缺陷检测是最为实用的软件开发工具之一。按照一般的方法，如果想发现软件缺陷，就必须运行程序并且执行测试用例，无论是自动测试或者手工测试。而在使用缺陷检测工具时无须运行程序，就能发现软件中的隐含缺陷。这确实非常有趣，性价比也非常高。</p>\n<p>静态代码分析技术可以在不运行程序的情况下，通过分析源代码、字节码或者二进制程序的执行路径，根据一定的启发式规则，指出代码的潜在缺陷。</p>\n<p>静态代码分析工具的背后是比较专业的技术，如符号执行。对于大多数程序员来说，只要学会使用这类工具，理解其基本原理就可以，无须精通背后的技术方法。如果你还没有使用过这类工具，那么了解它们最好的办法就是立即下载、安装，然后运行一下，试一试。</p>\n<p>我们以 SpotBugs<span class=\"comment-number\">5</span> 为例来介绍这类缺陷检测工具。SpotBugs 是一个用于 Java 语言的静态代码分析工具，可以检测许多类型的缺陷。图 10.4 展示了使用 SpotBugs 对某个程序进行检测后的部分结果。</p>\n\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00393.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10.4</strong>　应用 SpotBugs 发现代码中的潜在问题</p>\n<p>SpotBugs 在该程序中检测出了若干错误。图 10.4 中的错误是对一个未初始化对象进行了读操作：<code>cache2</code> 变量从未被初始化，但在第 19 行中的 <code>get</code> 方法却调用了这个变量，显然此处代码是有风险的。</p>\n<p>SpotBugs 这类工具能发现许多类型的代码缺陷或者代码中的潜在问题。在本示例的项目中，它还发现了如下类型的错误。</p>\n<ul>\n<li>错误地使用了 <code>==</code> 符号（应该使用 <code>equals</code>）。</li>\n<li>声明了从来未用到的成员变量。</li>\n<li>没有检查所调用函数的返回值。</li>\n<li>含有不必要的条件检查语句。</li>\n<li>……</li>\n</ul>\n<p>使用缺陷检查工具，肯定会有漏报，一般也会存在误报。可即便如此，由于静态代码检查的成本非常低，收益却很高，因此尽可能多地利用缺陷检查工具来提供代码质量，是非常推荐的选择。</p>\n<p>优质的代码不仅需要没有功能缺陷，还应该体现好的易于理解、易于维护、易于扩展等特征。为此，第 2 章也介绍了高质量软件的许多内部特征，如编码风格应该一致、命名应该规范、实现应该简洁、没有重复、具备自动化测试等。借助于设计质量检测或度量工具，可以在一定程度上让内部设计质量变得可见。</p>\n<h3 id=\"nav_point_243\">10.5.2　代码规约检测</h3>\n<p>代码规约检测是一种特别有用的编码质量检测辅助工具。代码规约中通常包含易于理解、易于维护等方面的许多重要特征。通过分析代码，代码规约检测工具可以发现许多平常得不到注意的问题。</p>\n<p>图 10.5 是应用 p3c 代码规约检测工具<span class=\"comment-number\">6</span>对某个程序进行检测后的结果。其中显示的是一处命名不够规范的问题，即变量名应该使用小写，而该处代码的参数名却使用了大写。</p>\n\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00394.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10.5</strong>　应用 p3c 代码规约检测工具发现的代码规约问题</p>\n<h3 id=\"nav_point_244\">10.5.3　函数复杂度</h3>\n<p>代码应该尽量简洁。对此，有一些简单而有效的指标，如函数代码行、圈复杂度等，都可以较好地反映代码的简洁性。</p>\n<p><strong>函数代码行</strong></p>\n<p>函数代码行或语句数是一个非常简单的指标，这个指标很容易统计，且非常有效。通过暴露那些长函数，促进每个函数变得更简洁，好的设计往往会自己浮现出来。</p>\n<p><strong>圈复杂度</strong></p>\n<p>圈复杂度是另一个度量函数实现的复杂性的经典方法。圈复杂度（CCN，Cyclomatic Complexity Number）也叫作 McCabe 复杂度，由 McCabe 于  1976 年提出<sup>[49]</sup>。为了说明圈复杂度的概念，我们先来看一段来自真实项目的代码。</p>\n<pre class=\"code-rows\"><code>public void createThumbnail(File from, File to) throws Exception {\n    BufferedImage buffer = ImageIO.read(from);\n    double ratio_x = w / buffer.getWidth();\n    double ratio_y = h / buffer.getHeight();\n    if (ratio_x &gt;= 1) {\n        if (ratio_y &lt; 1) {\n            ratio_x = height / h;\n        } else {\n            if (ratio_x &gt; ratio_y) {\n                ratio_x = height / h;\n            } else {\n                ratio_x = width / w;\n            }\n        }\n    } else {\n        if (ratio_y &lt; 1) {\n            if (ratio_x &gt; ratio_y) {\n                ratio_x = height / h;\n            } else {\n                ratio_x = width / w;\n            }\n        } else {\n            ratio_x = width * 1.0 / w;\n        }\n    }\n    // 后续代码略\n}</code></pre>\n<p><strong>代码清单 10.8</strong>　圈复杂度较高的一段代码</p>\n<p>这段代码的作用是为一个图片文件创建缩略图，当然它的行数确实也不少，不过真正导致它更加难以理解的是它里面包含大量条件分支语句。如何用数值的形式反映上述代码的复杂性呢？圈复杂度的思路是：如果一个方法的可执行路径越多，那这个方法就越难得到充分测试，它的风险也就越高。基于这样的思想，我们可以画出如图 10.6 所示的结构。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00395.jpeg\" alt=\"\" width=\"63%\" style=\"width: 63%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10.6</strong>　<code>createThumbnail</code> 方法的执行流程</p>\n<p>从图 10.6 中可以数出来，这个方法共有 6 条可执行路径，所以至少需要 6 个测试用例才能保证每条可执行路径都能被测试到，它的圈复杂度就为 6。</p>\n<p>圈复杂度可以很简单地通过节点和边的数量计算出来。它有两个公式，一个是</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00396.gif\" alt=\"V(G)=E-N+2,\" /></p>\n<p>其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00397.gif\" alt=\"E\" inline-img=\"true\" /> 代表流程图中边的数量，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00398.gif\" alt=\"N\" inline-img=\"true\" /> 代表流程图中节点的数量；另一个是</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00399.gif\" alt=\"V(G)=P+1,\" /></p>\n<p>其中 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00328.gif\" alt=\"P\" inline-img=\"true\" /> 代表包含条件的节点的数量。</p>\n<p><strong>认知复杂度</strong></p>\n<p>圈复杂度虽然是一种很好的复杂度度量，也确实反映了执行路径的多寡，但有时候它的计算结果可能和人的主观感受不符。例如下面的例子<sup>[50]</sup>。</p>\n<pre class=\"code-rows\"><code>int sumOfPrimes(int max) {            // +1\n    int total = 0;\n    OUT:\n    for (int i = 1; i &lt;= max; ++i) {  // +1\n        for (int j = 2; j &lt; i; ++j) { // +1\n            if (i % j == 0) {         // +1\n                continue OUT;\n            }\n            total += i;\n        }\n    }\n    return total;\n}</code></pre>\n<p><strong>代码清单 10.9</strong>　较复杂的代码 1——求解质因数之和</p>\n<pre class=\"code-rows\"><code>String getWords(int number) {       // +1\n    switch (number) {\n        case 1:  return \"one\";      // +1\n        case 2:  return \"a couple\"; // +1\n        case 3:  return \"a few\";    // +1\n        default: return \"lots\";\n    }\n}</code></pre>\n<p><strong>代码清单 10.10</strong>　较复杂的代码 2——对数字进行语义解读</p>\n<p>代码清单 10.9 和代码清单 10.10 的圈复杂度都是 4，但从感受上来说，这两段代码的复杂度是完全不同的。问题在于，代码清单 10.10 中的 <code>switch-case</code> 语句虽然从执行路径上讲确实有很多条，但是人一眼就可以看出其中的规律，认知起来并不困难。而代码清单 10.9 中的嵌套逻辑，就很难认知。</p>\n<p>从可理解性视角看，认知复杂度是一种更好的表达函数实现复杂度的方法，它计算起来也较为简单。下面从原理上进行分析。</p>\n<ul>\n<li>线性执行是最简单的逻辑。只要从线性流中拉出了分支，复杂度就增加 1，如 <code>for</code>、<code>while</code>、<code>if</code>、<code>switch</code> 语句等。</li>\n<li>嵌套会增加复杂度。每增加一个嵌套，复杂度增加该嵌套层次的深度。</li>\n<li>凡是从认知视角是等价的逻辑，都不会影响复杂度。例如 <code>if-else</code>、<code>switch-case</code>、<code>if (a&amp;&amp;b||c)</code> 这些，复杂度都仅是增加 1，并不会像圈复杂度那样每增加一条执行路径就增加 1。</li>\n</ul>\n<p>有许多工具支持复杂度的度量。通过度量数据，从代码中挑选出那些复杂度较高的方法并进行优化，是一种有效的提升代码质量的方案。</p>\n<h3 id=\"nav_point_245\">10.5.4　测试覆盖率</h3>\n<p>自动化测试对代码很重要。那么，有没有什么办法能检验测试是否完备呢？测试覆盖率就是一种有效的度量。不过，在使用测试覆盖率时要谨慎，因为它很容易被误用。它不可以作为目标，只能作为指示器。现在我们就来分析一下测试覆盖率指标。</p>\n<p><strong>测试覆盖率是指示器</strong></p>\n<p>为什么说测试覆盖率可以作为测试完备程度的指示器？这是因为：没有被覆盖的代码要么是漏测、要么是死代码，二者必有其一。</p>\n<p>在 6.4 节，我们曾经使用了一个计算表达式的例子。图 10.7 展示的是执行完既有测试之后，在 IDE 中看到的测试覆盖率情况。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00400.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10.7</strong>　一段代码的测试覆盖情况</p>\n<p>从图中可以看到，第 85 行的一个分支没有被覆盖。仔细阅读代码，我们会发现它不能处理字符长度超过 50 的四则运算算式。根据覆盖率指示的信息，我们不仅仅发现了漏测的功能，还发现了这是一处未经声明的契约。因此，我们需要编写一个新的测试来补充功能测试上的遗漏，同时补足契约。</p>\n<pre class=\"code-rows\"><code>    @Test\n    @DisplayName(\"不能处理超过 50 个字符的算式\")\n    void testExpressionsLonggerThan50ShouldBeRejected() {\n        // 构造一个长度为 51 位的算式\n        String expression = \"1\" + String.format(\"%050d\", 0);\n        Assertions.assertThrows(ExpressionError.class, () -&gt; {\n            calculator.evaluate(expression);\n        });\n    }</code></pre>\n<p><strong>代码清单 10.11</strong>　增加测试，补足契约</p>\n<p>当然，没有被测试覆盖的代码也很可能不是漏测了，而是在演进过程中变成了死代码，即已经完全无用了。例如，图 10.8 是在一个真实项目<span class=\"comment-number\">7</span>上运行测试后的结果。</p>\n\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00401.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10.8</strong>　通过覆盖率发现死代码</p>\n<p>显然，<code>EntityNotExistException</code> 和 <code>NoRequestedTypeOfAncestorExisted</code> 这两个类没有被任何测试覆盖。经过仔细调查，发现这两段代码确实是无用代码，它们就应该被移除。<span class=\"comment-number\">8</span></p>\n\n<p>测试覆盖率在各种语言下都有许多工具。在 Java 语言中，最有名的覆盖率测试工具是 Jacoco。</p>\n<p><strong>不要把测试覆盖率作为指标</strong></p>\n<p>既然测试覆盖率很有用，那把它定义成项目的目标如何呢？例如，要求至少达到 80% 的测试覆盖率？如果高测试覆盖率是团队基于优秀工程实践形成的共识，那这是一个好的目标。可如果高测试覆盖率仅仅是行政性要求，就很容易出现问题。</p>\n<p>好的动机未必会产生好的结果。下面这些都是在实践项目中，由于仅要求了测试覆盖率，但是没有优秀工程实践和设计共识导致的后果。</p>\n<ol>\n<li class=\"第1级有序列表\">无断言测试。无断言测试当然不是真正的测试。不写断言未必是偷懒，更常见的场景是一些代码已经非常复杂，也说不清究竟输入、输出是什么，但是测试覆盖率有要求呀！怎么办呢？只好写一个测试，以保证会覆盖到这段代码，但是没法写断言。无断言测试是有害的，它不仅没有任何价值，还会造成“这段代码已经被覆盖”的虚假安全感。</li>\n<li class=\"第1级有序列表\">读写代码的内部状态。有些设计不良的代码有着复杂的内部分支和状态，要通过黑盒测试实现高测试覆盖率很难。这时候如果片面追求测试覆盖率，那必然会迫使程序员通过分析内部状态，甚至访问和暴露内部变量或内部状态，来提升测试覆盖率。如前所述，这种做法是非常危险的：它建立了测试代码和产品代码的耦合，而且对外暴露了本不该暴露的内部状态。</li>\n<li class=\"第1级有序列表\">达到测试率就完事大吉。图 10.7 对应的测试覆盖率结果，其实仅用一个测试就可以达到。这个测试仅需使用一个用例：<code>1+1-1*(1/1)</code>。显然这个测试什么也说明不了，但它已经达到了 91.9% 的高覆盖率。这绝非测试覆盖率本来的要求。如果仅是要求测试覆盖率，而没有关于质量的共识和能力，很容易就会造成这种后果。</li>\n</ol>\n<p>提升测试覆盖率最有效的做法是测试先行。在测试先行的实践中，由于是先制定契约，再编码实现，所以测试覆盖率不可能太低，而且每个测试用例的意义都会很明确。</p>\n<h3 id=\"nav_point_246\">10.5.5　结构问题检测</h3>\n<p>软件总是会被分解为彼此协作的设计单元。结构问题检测的目标在于使用代码分析工具，了解不合理的分解和依赖。如果代码结构不合理，就会影响设计的易于理解、易于维护和易于演进特征。例如，模块 A 依赖于模块 B，而模块 B 经常发生变更，那么模块 A 就没法稳定，这就不是一个好的设计。</p>\n<p><strong>设计结构矩阵</strong></p>\n<p>首先我们介绍在结构问题检测中会使用的一个基本工具：设计结构矩阵（简称 DSM，Design Structure Matrix）<sup>[51]</sup>。图 10.9 展示了由某个项目的源代码生成的 DSM。<span class=\"comment-number\">9</span></p>\n\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00402.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10.9</strong>　某项目的 DSM</p>\n<p>DSM 是一个二维正方矩阵，它能比较直观地表达设计单元之间的依赖关系。矩阵中的每个元素都表达了两个设计单元之间的依赖情况。如在图 10.9 中，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00403.gif\" alt=\"\\boldsymbol_ \" inline-img=\"true\" /> 的值 1286 代表从设计单元 depends/extrator 到设计单元 depends/entity 之间共有 1286 个依赖。由于软件分解具有自相似性，所以可以使用 DSM 分析任意粒度的设计单元，如包和包之间的依赖关系、类和类之间的依赖关系等。通过观察矩阵反映的依赖关系，可以比较容易地发现哪些设计单元之间存在比较密切的耦合，从而发现设计中的潜在问题。</p>\n<p><strong>发现问题热点</strong></p>\n<p>虽然 DSM 可以较好地可视化设计单元之间的依赖关系，但是当设计单元的数量很庞大时，仅仅可视化是不够的，我们需要一些能快速找到问题热点的方法。</p>\n<p>研究者们不断探索了许多结构度量和问题发现的方法，如稳定性度量、抽象性度量、主序列距离等<sup>[31]</sup>。其中，Yuanfang Cai（蔡元芳）等总结了一组架构热点模式<sup>[52]</sup>。其中的热点模式包括以下这些。</p>\n<ul>\n<li>不稳定的接口：一个接口如果被很多设计单元依赖，而这个接口自身是不稳定的，那必然意味着不良的设计。</li>\n<li>意外地共同变更：如果两个设计单元之间看起来没有显式的依赖关系，但是它们经常共同变更，则意味着它们必然存在隐式依赖。</li>\n<li>不合理的继承：如果在一个继承树中，父类的某些部分依赖于自己的子类，则必然意味着父类抽象的失败。而如果一个外部的调用方同时依赖于父类和子类，也必然意味着设计层次的不一致。</li>\n<li>繁忙的十字路口：如果一个设计单元依赖于许多其他设计单元，同时也被许多其他设计单元依赖，那这就是所谓的“设计的十字路口”。十字路口很重要，如果该设计单元自身经常变更，势必会存在严重的问题，会导致上下游都变得不稳定。</li>\n<li>循环依赖：循环依赖是失败的模块化。凡是参与到循环依赖中的设计单元，在复用时就只能同出同进，也就是在本质上只能将它们作为一个模块看待。无论是直接的循环依赖还是间接的循环依赖，都会导致严重的耦合。</li>\n<li>包循环：在正常情况下，软件系统中的模块应该是一个树形结构。有时候，在类这个粒度上，或许没有循环依赖，但是由于设计分割得不合理，会导致在更高层次的粒度上出现循环依赖，这也会影响到设计的可复用性和可理解性。</li>\n</ul>\n<p>利用这些热点模式，可以较快地发现设计中的问题。只要能识别到设计单元之间的依赖<span class=\"comment-number\">10</span>，获取到设计单元的历史变更数据<span class=\"comment-number\">11</span>，就可以通过一些简单的规则发现上述热点模式。</p>\n\n\n<p><strong>结构问题的度量指标</strong></p>\n<p>有一些指标能较好地反映结构视角的设计质量。其中比较有影响力的指标包括解耦度<sup>[53]</sup>（DL，Decoupling Level）、传播成本<sup>[54]</sup>（PC，Propagation Cost）等。由于这类指标计算起来较为复杂，因此这里我们不介绍具体算法，有兴趣的读者可以阅读相应的参考文献。</p>\n<h3 id=\"nav_point_247\">10.5.6　明智地应用度量指标</h3>\n<p>灵活应用度量和检测工具，可以有效地提升设计质量。要注意如果误用，或者过度使用，很可能会适得其反。前文我们已经从测试覆盖率的示例中看到了把度量数据作为目标可能会引起问题。在本节中，我们介绍正确应用度量的策略。</p>\n<p><strong>把度量和检测工具作为助手</strong></p>\n<p>程序员总是希望写出高质量的代码。如果能通过工具及时了解代码中存在的问题，自然是再好不过了。</p>\n<p>有经验且自律的程序员大多习惯于在编码时使用代码检查工具进行自我检查，看是否不小心违反了编程规范、是否引入了潜在的缺陷、代码质量是否有下降等。这是使用度量和检测工具的最佳状态。真正有效的行为是出于主动的，而不是他人要求的。持续反馈不仅有助于提高代码质量，个人能力也能不断得以增强。</p>\n<p><strong>明智地选择度量指标</strong></p>\n<p>度量指标不是越多越好，尤其对于软件设计而言。软件设计是一个极度复杂的问题。经过许多年的发展，人们提出了特别多的度量指标，本节介绍的只是冰山一角。</p>\n<p>好的度量一定是有目的的度量。也就是说，要弄清楚这个度量是否明确回答了某个清晰的问题，指引了一个确定的方向。对于检测工具来说，只要误报率不是特别高，往往就是有用的。但是，度量就不一定了，有一些指标很值得商榷。</p>\n<p>在面向对象中，有一组著名的度量指标，叫作 C&amp;K 度量，源自 Chidamber 和 Kemerer 于 1994 年发表的论文<sup>[55]</sup>。C&amp;K 度量共有 6 个度量指标，分别是：每个类的加权方法数（WMC）、继承树的深度（DIT）、子类的数目（NOC）、类间的耦合（CBO）、类的响应（RFC）和内聚方法缺失（LCOM）。我不准备详细介绍这 6 个指标，只取其中的 NOC 作为示例。</p>\n<p>NOC 这个指标很容易理解：就是一个类有多少个子类。Chidamber 和 Kemerer 认为，子类数目如果超过了一定的阈值，就意味着设计不够好。这个结论是真实的吗？为什么子类的个数多，就意味着问题？</p>\n<p>这个指标背后的逻辑其实是变更影响。也就是说，子类越多，当父类发生变更后，受到影响的类的数目就越多，变更的成本也就更高。但是如果父类很稳定，这个指标显然就不合适了，恰恰相反，这说明抽象设计很好，复用机会很多，此时 NOC 的数值高反而是设计质量高的体现。</p>\n<p>所以，像 NOC 这类度量指标反映的问题是不精确、模糊的，不应该被选作软件度量的指标。如果要回答变更影响的问题，那么可以考虑代码的解耦度、架构热点分析等更有效的代码度量指标或者问题检测工具。</p>\n<p>类似于 NOC 这类意义不明显或者有歧义的度量指标有很多，其中有不少已经被实现到了代码度量的工具中。对这类指标，我的态度是：度量不是目的，用尽量少的指标撬动尽可能大的质量改善行动，带来更好的设计结果，才是我们追求的真正目标。</p>\n<p><strong>持续地对度量进行监控</strong></p>\n<p>软件具有天然腐化的趋势。在没有刻意提升质量的情况下，软件的设计质量一定会随着时间的流逝逐步下降。“熵增原理”，也就是封闭系统的混乱度一定会逐步上升，这不仅适用于自然世界，对软件世界也同样适用。</p>\n<p>造成软件腐化趋势的原因很简单：每次新增功能，都是对于过去设计的一次扰动。如果只是在旧的设计上修修补补，那一定是补丁摞补丁，导致系统越来越难以维护。图 10.10 展示了一个函数的圈复杂度是如何随着代码演进持续增长的，这个案例来自真实项目，它的圈复杂度在做了近 300 次修改后，增长了 10 倍之多。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00404.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10.10</strong>　软件具有天然腐化的趋势</p>\n<p>如果能监控度量指标，就可以在问题蔓延之前快速发现问题，从而让代码的质量始终处于一个可控的水平，提升设计质量。</p>\n<h2 id=\"nav_point_248\">10.6　小结</h2>\n<p>质量是软件设计的核心，持续的高质量一定来自质量内建。本章介绍了质量内建的策略以及相关的关键实践，并介绍了支撑高质量软件设计的度量和工具。图 10.11 总结了本章的核心概念和方法。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100011/image00405.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 10.11</strong>　设计质量贯穿始终</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}