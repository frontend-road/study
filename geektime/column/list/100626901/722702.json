{"id":722702,"title":"08｜Option<T>与Result<T, E>、迭代器","content":"<p>你好，我是Mike，今天我们一起来重点学习在Rust中高频使用的 <code>Option&lt;T&gt;</code>、<code>Result&lt;T, E&gt;</code>、迭代器，通过学习这些内容，我们可以继续夯实集合中所有权相关的知识点。</p><p><code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 并不是Rust的独创设计，在Rust之前，OCaml、Haskell、Scala等已经使用它们很久了。新兴的一批语言Kotlin、Swift 等也和Rust一样引入了这两种类型。而C++17之后也引入了它们。</p><p>这其实能说明使用 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 逐渐成了编程语言圈子的一种新共识。而迭代器已经是目前几乎所有主流语言的标配了，所以我们也来看看Rust中的迭代器有什么独到的地方。</p><p>如果你习惯了命令式编程或OOP编程，那么这节课我们提到各种操作对你来说可能有点陌生，不过也不用担心，这节课我设计了大量示例，你可以通过熟悉这些示例代码，掌握Rust中地道的编程风格。</p><h2><code>Option&lt;T&gt;</code> 与 <code>Result&lt;T, E&gt;</code></h2><p><code>Option&lt;T&gt;</code> 与 <code>Result&lt;T, E&gt;</code> 在Rust代码中随处可见，但是我们到现在才开始正式介绍，就是因为它们实际是带类型参数的枚举类型。</p><h3><code>Option&lt;T&gt;</code> 的定义</h3><pre><code class=\"language-plain\">pub enum Option&lt;T&gt; {\n    None,\n    Some(T),\n}\n</code></pre><!-- [[[read_end]]] --><p><code>Option&lt;T&gt;</code> 定义为包含两个变体的枚举。一个是不带负载的None，另一个是带一个类型参数作为其负载的Some。<code>Option&lt;T&gt;</code> 的实例在Some和None中取值， 表示这个实例有取空值的可能。</p><p>你可以把 <code>Option&lt;T&gt;</code> 理解为把空值单独提出来了一个维度。在没有 <code>Option&lt;T&gt;</code> 的语言中，空值是分散在其他类型中的。比如空字符串、空数组、数字0、NULL指针等。并且有的语言还把空值区分为空值和未定义的值，如 nil、undefined等。</p><p>Rust做了两件事情来解决这个混乱的场面。第一，Rust中所有的变量定义后使用前都必须初始化，所以不存在未定义值这个情况。第二，Rust把空值单独提出来统一定义成 <code>Option&lt;T&gt;::None</code>，并在标准库层面上就做好了规范，上层的应用在设计时也应该遵循这个规范。</p><p>我们来看一个示例。</p><pre><code class=\"language-plain\">let s = String::from(\"\");\nlet a: Option&lt;String&gt; = Some(s);\n</code></pre><p>变量a是携带空字符串的 <code>Option&lt;String&gt;</code> 类型。这里，空字符串\"\"的“空”与None所表示的“无”表达了不同的意义。</p><p>如果早点发明Option，Tony Hoare就不会自责了。Tony Hoare在<a href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/\">一次分享</a>中说，他在1965年发明的空引用（Null references）是一个“十亿美元”的错误。</p><p>他是这样说的：我把它叫做我的十亿美元错误。那个时候，我正在为一个面向对象语言中的引用设计第一个全面的类型系统。我的目标是让编译器自动施加检查，来确保对引用的所有使用都是绝对安全的。但是我当时无法抵抗空引用的诱惑，就是因为它非常容易实现。这导致了难以计数的错误、漏洞和系统崩溃，在后续40年里这可能已经导致了十亿美元的痛苦和破坏。</p><p>Rust通过所有权并借用检查器、<code>Option&lt;T&gt;</code>、<code>Result&lt;T, E&gt;</code> 等一整套机制全面解决了Hoare想解决的问题。</p><h3><code>Result&lt;T, E&gt;</code> 的定义</h3><p>我们先来看一个示例。</p><pre><code class=\"language-plain\">pub enum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre><p><code>Result&lt;T, E&gt;</code> 被定义为包含两个变体的枚举。这两个变体各自带一个类型参数作为其负载。<code>Ok(T)</code> 用来表示结果正确，<code>Err(E)</code> 用来表示结果有错误。</p><p>对比其他语言函数错误返回的约定，C、CPP、Java语言里有时用返回0来表示函数执行正确，有时又不是这样，你需要根据代码所在的上下文环境来判断返回什么值代表正确，返回什么值代表错误。</p><p>而Go语言强制对函数返回值做出了约定。</p><pre><code class=\"language-plain\">ret, err := function()\nif err != nil {\n</code></pre><p>约定要求函数返回两个值，正确的情况下，<code>ret</code> 存放返回值，<code>err</code> 为 <code>nil</code>。如果函数要返回错误值，那么会给 <code>err</code> 变量填充具体的内容，于是就出现了经典的满屏 <code>if err ！= nil</code> 代码，成了Go语言圈的一个梗。可以看到，Go语言已经朝着把错误信息和正常返回值类型剥离开来的方向走出了一步。</p><p>而Rust没有像Go那样设计，一是因为Rust不存在单独的 <code>nil</code> 这种空值，二是Rust直接用带类型参数的枚举就可以达到这个目的。</p><p>一个枚举实例在一个时刻只能是那个枚举类型的某一个变体。所以一个函数的返回值，不论它是正确的情况还是错误的情况，都能用 <code>Result&lt;T, E&gt;</code> 类型统一表达，这样会显得更紧凑。同时还因为 <code>Result&lt;T, E&gt;</code> 是一种类型，我们可以在它之上添加很多操作，用起来很方便。下面我用例子来给你讲解。</p><pre><code class=\"language-plain\">let r: Result&lt;String, String&gt; = function();\n</code></pre><p>这个例子表示将函数返回值赋给变量r，返回类型是 <code>Result&lt;String, String&gt;</code>。在正确的情况下，返回内容为String类型；错误的情况下，被返回的错误类型也是String。你是不是在想：两种可以一样？当然可以，这两个类型参数可以被任意类型代入。</p><p><code>Result&lt;T, E&gt;</code> 被用来支撑Rust的错误处理机制，所以非常重要。我们会在第18讲详细讲述基于 <code>Result&lt;T, E&gt;</code> 的错误处理。</p><h3>解包</h3><p>现在我们遇到了一个问题，比如 <code>Option&lt;u32&gt;::Some(10)</code> 和 <code>10u32</code> 明显已经不是同一种类型了。我们真正想要的值被“包裹”在了另外一种类型里面。这种“包裹”是通过枚举变体来实现的。那我们想获取被包在里面的值应该怎么做呢？</p><p>其实有很多办法，我们先讲一类解包操作。这里我列出了三种方法，分别是 <code>expect()</code>、<code>unwrap()</code>、<code>unwrap_or()</code>。我给出了它们解包的具体操作和示例代码，你可以看一下有什么不同。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/4e/2c6688bff17d22b516a83e8063fb094e.jpg?wh=1920x439\" alt=\"图片\"></p><p>示例：</p><pre><code class=\"language-plain\">// Option\nlet x = Some(\"value\");\nassert_eq!(x.expect(\"fruits are healthy\"), \"value\");\n// Result\nlet path = std::env::var(\"IMPORTANT_PATH\")\n    .expect(\"env variable `IMPORTANT_PATH` should be set by `wrapper_script.sh`\");\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/95/ed/959455893ca1ae8c43ffyye251c015ed.jpg?wh=1920x413\" alt=\"图片\"></p><p>示例：</p><pre><code class=\"language-plain\">// Option\nlet x = Some(\"air\");\nassert_eq!(x.unwrap(), \"air\");\n// Result\nlet x: Result&lt;u32, &amp;str&gt; = Ok(2);\nassert_eq!(x.unwrap(), 2);\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/ca/e5/ca69bfe4787585c0e16529c5ddd8b5e5.jpg?wh=1920x485\" alt=\"图片\"></p><p>示例：</p><pre><code class=\"language-plain\">// Option\nassert_eq!(Some(\"car\").unwrap_or(\"bike\"), \"car\");\nassert_eq!(None.unwrap_or(\"bike\"), \"bike\");\n\n// Result\nlet default = 2;\nlet x: Result&lt;u32, &amp;str&gt; = Ok(9);\nassert_eq!(x.unwrap_or(default), 9);\n\nlet x: Result&lt;u32, &amp;str&gt; = Err(\"error\");\nassert_eq!(x.unwrap_or(default), default);\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/71/08/7170a2fcaec48fd123158f99e88ce708.jpg?wh=1920x415\" alt=\"图片\"></p><p>示例：</p><pre><code class=\"language-plain\">// Option\nlet x: Option&lt;u32&gt; = None;\nlet y: Option&lt;u32&gt; = Some(12);\n\nassert_eq!(x.unwrap_or_default(), 0);\nassert_eq!(y.unwrap_or_default(), 12);\n\n// Result\nlet good_year_from_input = \"1909\";\nlet bad_year_from_input = \"190blarg\";\nlet good_year = good_year_from_input.parse().unwrap_or_default();\nlet bad_year = bad_year_from_input.parse().unwrap_or_default();\n\nassert_eq!(1909, good_year);\nassert_eq!(0, bad_year);\n</code></pre><p>可以看到，解包操作挺费劲的。如果我们总是先用 <code>Option&lt;T&gt;</code> 或 <code>Result&lt;T, E&gt;</code> 把值包裹起来，用的时候再手动解包，那其实说明没有真正抓住到 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 的设计要义。在Rust中，很多时候我们不需要解包也能操作里面的值，这样就不用做看起来多此一举的解包操作了。下面我们来看一下在不解包的情况下，我们可以怎样做。</p><h3>不解包的情况下如何操作？</h3><p>不解包的情况下如果想要获取被包在里面的值就需要用到 <code>Option&lt;T&gt;</code> 和<code>Result&lt;T, E&gt;</code> 里的一些常用方法。</p><p><code>Option&lt;T&gt;</code> 上的常用方法和示例：</p><ul>\n<li>map()：在 Option 是 Some 的情况下，通过 map 中提供的函数或闭包把 Option 里的类型转换成另一种类型。在 Option 是 None 的情况下，保持 None 不变。map() 会消耗原类型，也就是获取所有权。</li>\n</ul><pre><code class=\"language-plain\">let maybe_some_string = Some(String::from(\"Hello, World!\"));\nlet maybe_some_len = maybe_some_string.map(|s| s.len());\nassert_eq!(maybe_some_len, Some(13));\n&nbsp;\nlet x: Option&lt;&amp;str&gt; = None;\nassert_eq!(x.map(|s| s.len()), None);\n</code></pre><ul>\n<li>cloned()：通过克隆 Option 里面的内容，把 <code>Option&lt;&amp;T&gt;</code> 转换成 <code>Option&lt;T&gt;</code>。</li>\n</ul><pre><code class=\"language-plain\">let x = 12;\nlet opt_x = Some(&amp;x);\nassert_eq!(opt_x, Some(&amp;12));\nlet cloned = opt_x.cloned();\nassert_eq!(cloned, Some(12));\n</code></pre><ul>\n<li>is_some()：如果 Option 是 Some 值，返回 true。</li>\n</ul><pre><code class=\"language-plain\">let x: Option&lt;u32&gt; = Some(2);\nassert_eq!(x.is_some(), true);\n&nbsp;\nlet x: Option&lt;u32&gt; = None;\nassert_eq!(x.is_some(), false);\n</code></pre><ul>\n<li>is_none()：如果 Option 是 None 值，返回 true。</li>\n</ul><pre><code class=\"language-plain\">let x: Option&lt;u32&gt; = Some(2);\nassert_eq!(x.is_none(), false);\n&nbsp;\nlet x: Option&lt;u32&gt; = None;\nassert_eq!(x.is_none(), true);\n</code></pre><ul>\n<li>as_ref()：把 <code>Option&lt;T&gt;</code> 或 <code>&amp;Option&lt;T&gt;</code> 转换成 <code>Option&lt;&amp;T&gt;</code>。创建一个新 Option，里面的类型是原来类型的引用，就是从 <code>Option&lt;T&gt;</code> 到 <code>Option&lt;&amp;T&gt;</code>。原来那个 <code>Option&lt;T&gt;</code> 实例保持不变。</li>\n</ul><pre><code class=\"language-plain\">let text: Option&lt;String&gt; = Some(\"Hello, world!\".to_string());\nlet text_length: Option&lt;usize&gt; = text.as_ref().map(|s| s.len());\nprintln!(\"still can print text: {text:?}\");\n</code></pre><ul>\n<li>as_mut()：把 <code>Option&lt;T&gt;</code> 或 <code>&amp;mut Option&lt;T&gt;</code> 转换成 <code>Option&lt;&amp;mut T&gt;</code>。</li>\n</ul><pre><code class=\"language-plain\">let mut x = Some(2);\nmatch x.as_mut() {\nSome(v) =&gt; *v = 42,\nNone =&gt; {},\n}\nassert_eq!(x, Some(42));\n</code></pre><ul>\n<li>take()：把 Option 的值拿出去，在原地留下一个 None 值。这个非常有用。相当于把值拿出来用，但是却没有消解原来那个 Option。</li>\n</ul><pre><code class=\"language-plain\">let mut x = Some(2);\nlet y = x.take();\nassert_eq!(x, None);\nassert_eq!(y, Some(2));\n&nbsp;\nlet mut x: Option&lt;u32&gt; = None;\nlet y = x.take();\nassert_eq!(x, None);\nassert_eq!(y, None);\n</code></pre><ul>\n<li>replace()：在原地替换新值，同时把原来那个值抛出来。</li>\n</ul><pre><code class=\"language-plain\">let mut x = Some(2);\nlet old = x.replace(5);\nassert_eq!(x, Some(5));\nassert_eq!(old, Some(2));\n&nbsp;\nlet mut x = None;\nlet old = x.replace(3);\nassert_eq!(x, Some(3));\nassert_eq!(old, None);\n</code></pre><ul>\n<li>and_then()：如果 Option 是 None，返回 None；如果 Option 是 Some，就把参数里面提供的函数或闭包应用到被包裹的内容上，并返回运算后的结果。</li>\n</ul><pre><code class=\"language-plain\">fn sq_then_to_string(x: u32) -&gt; Option&lt;String&gt; {\nx.checked_mul(x).map(|sq| sq.to_string())\n}\n&nbsp;\nassert_eq!(Some(2).and_then(sq_then_to_string), Some(4.to_string()));\nassert_eq!(Some(1_000_000).and_then(sq_then_to_string), None); // overflowed!\nassert_eq!(None.and_then(sq_then_to_string), None);\n</code></pre><p>我们再看 <code>Result&lt;T, E&gt;</code> 上的常用方法和示例。</p><ul>\n<li>map()：当 Result 是 Ok 的时候，把 Ok 里的类型通过参数里提供的函数运算并且可以转换成另外一种类型。当 Result 是 Err 的时候，原样返回 Err 和它携带的内容。</li>\n</ul><pre><code class=\"language-plain\">let line = \"1\\n2\\n3\\n4\\n\";\n&nbsp;\nfor num in line.lines() {\nmatch num.parse::&lt;i32&gt;().map(|i| i * 2) {\nOk(n) =&gt; println!(\"{n}\"),\nErr(..) =&gt; {}\n}\n}\n</code></pre><ul>\n<li>is_ok()：如果 Result 是 Ok，返回 true。</li>\n</ul><pre><code class=\"language-plain\">let x: Result&lt;i32, &amp;str&gt; = Ok(-3);\nassert_eq!(x.is_ok(), true);\n&nbsp;\nlet x: Result&lt;i32, &amp;str&gt; = Err(\"Some error message\");\nassert_eq!(x.is_ok(), false);\n</code></pre><ul>\n<li>is_err()：如果 Result 是 Err，返回 true。</li>\n</ul><pre><code class=\"language-plain\">let x: Result&lt;i32, &amp;str&gt; = Ok(-3);\nassert_eq!(x.is_err(), false);\n&nbsp;\nlet x: Result&lt;i32, &amp;str&gt; = Err(\"Some error message\");\nassert_eq!(x.is_err(), true);\n</code></pre><ul>\n<li>as_ref()：创建一个新 Result，里面的两种类型分别是原来两种类型的引用，就是从 <code>Result&lt;T, E&gt;</code> 到 <code>Result&lt;&amp;T, &amp;E&gt;</code>。原来那个 <code>Result&lt;T, E&gt;</code> 实例保持不变。</li>\n</ul><pre><code class=\"language-plain\">let x: Result&lt;u32, &amp;str&gt; = Ok(2);\nassert_eq!(x.as_ref(), Ok(&amp;2));\n&nbsp;\nlet x: Result&lt;u32, &amp;str&gt; = Err(\"Error\");\nassert_eq!(x.as_ref(), Err(&amp;\"Error\"));\n</code></pre><ul>\n<li>as_mut()：创建一个新 Result，里面的两种类型分别是原来两种类型的可变引用，就是从 <code>Result&lt;T, E&gt;</code> 到 <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code>。原来那个 <code>Result&lt;T, E&gt;</code> 实例保持不变。</li>\n</ul><pre><code class=\"language-plain\">fn mutate(r: &amp;mut Result&lt;i32, i32&gt;) {\nmatch r.as_mut() {\nOk(v) =&gt; *v = 42,\nErr(e) =&gt; *e = 0,\n}\n}\nlet mut x: Result&lt;i32, i32&gt; = Ok(2);\nmutate(&amp;mut x);\nassert_eq!(x.unwrap(), 42);\nlet mut x: Result&lt;i32, i32&gt; = Err(13);\nmutate(&amp;mut x);\nassert_eq!(x.unwrap_err(), 0);\n</code></pre><ul>\n<li>and_then()：当 Result 是 Ok 时，把这个方法提供的函数或闭包应用到 Ok 携带的内容上面，并返回一个新的 Result。当 Result 是 Err 的时候，这个方法直接传递返回这个 Err 和它的负载。这个方法常常用于一路链式操作，前提是过程里的每一步都需要返回 Result。</li>\n</ul><pre><code class=\"language-plain\">fn sq_then_to_string(x: u32) -&gt; Result&lt;String, &amp;'static str&gt; {\nx.checked_mul(x).map(|sq| sq.to_string()).ok_or(\"overflowed\")\n}\n&nbsp;\nassert_eq!(Ok(2).and_then(sq_then_to_string), Ok(4.to_string()));\nassert_eq!(Ok(1_000_000).and_then(sq_then_to_string), Err(\"overflowed\"));\nassert_eq!(Err(\"not a number\").and_then(sq_then_to_string), Err(\"not a number\"));\n</code></pre><ul>\n<li>map_err()：当 Result 是 Ok 时，传递原样返回。当 Result 是 Err时，对 Err 携带的内容使用这个方法提供的函数或闭包进行运算及类型转换。这个方法常常用于转换 Result 的 Err 的负载的类型，在错误处理流程中大量使用。</li>\n</ul><pre><code class=\"language-plain\">fn stringify(x: u32) -&gt; String { format!(\"error code: {x}\") }\nlet x: Result&lt;u32, u32&gt; = Ok(2);\nassert_eq!(x.map_err(stringify), Ok(2));\nlet x: Result&lt;u32, u32&gt; = Err(13);\nassert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n</code></pre><h3><code>Option&lt;T&gt;</code> 与 <code>Result&lt;T, E&gt;</code> 的相互转换</h3><p><code>Option&lt;T&gt;</code> 与 <code>Result&lt;T, E&gt;</code> 之间是可以互相转换的。转换的时候需要注意，<code>Result&lt;T, E&gt;</code> 比 <code>Option&lt;T&gt;</code> 多一个类型参数，所以它带的信息比 <code>Option&lt;T&gt;</code> 多一份，因此核心要点就是<strong>要注意信息的添加与抛弃</strong>。</p><h4><code>从Option&lt;T&gt;</code> 到 <code>Result&lt;T, E&gt;：ok_or()</code></h4><p><code>Option&lt;T&gt;</code> 实例如果是 <code>Some</code>，直接把内容重新包在 <code>Result&lt;T, E&gt;::Ok()</code> 里。如果是 <code>None</code>，使用 <code>ok_or()</code> 里提供的参数作为 <code>Err</code> 的内容。</p><pre><code class=\"language-plain\">let x = Some(\"foo\");\nassert_eq!(x.ok_or(0), Ok(\"foo\"));\n\nlet x: Option&lt;&amp;str&gt; = None;\nassert_eq!(x.ok_or(0), Err(0));\n</code></pre><h4>从 <code>Result&lt;T, E&gt;</code> 到 <code>Option&lt;T&gt;：ok()</code></h4><p>如果 <code>Result&lt;T, E&gt;</code> 是 <code>Ok</code>，就把内容重新包在 <code>Some</code> 里。如果 <code>Result&lt;T, E&gt;</code> 是 <code>Err</code>，就直接换成 <code>None</code>，丢弃 <code>Err</code> 里的内容，同时原 <code>Result&lt;T, E&gt;</code> 实例被消费。</p><pre><code class=\"language-plain\">let x: Result&lt;u32, &amp;str&gt; = Ok(2);\nassert_eq!(x.ok(), Some(2));\n\nlet x: Result&lt;u32, &amp;str&gt; = Err(\"Nothing here\");\nassert_eq!(x.ok(), None);\n</code></pre><h4>从 <code>Result&lt;T, E&gt;</code> 到 <code>Option&lt;T&gt;：err()</code></h4><p>如果 <code>Result&lt;T, E&gt;</code> 是 <code>Ok</code>，直接换成 <code>None</code>，丢弃 <code>Ok</code> 里的内容。如果 <code>Result&lt;T, E&gt;</code> 是 <code>Err</code>，把内容重新包在 <code>Some</code> 里，同时原 <code>Result&lt;T, E&gt;</code> 实例被消费。</p><pre><code class=\"language-plain\">let x: Result&lt;u32, &amp;str&gt; = Ok(2);\nassert_eq!(x.err(), None);\n\nlet x: Result&lt;u32, &amp;str&gt; = Err(\"Nothing here\");\nassert_eq!(x.err(), Some(\"Nothing here\"));\n</code></pre><p>下面我们讲讲迭代器。</p><h2>迭代器</h2><p>迭代器其实很简单，就是对一个集合类型进行遍历。比如对 <code>Vec&lt;T&gt;</code>、对 <code>HashMap&lt;K, V&gt;</code> 等进行遍历。使用迭代器有一些好处，比如：</p><ol>\n<li>按需使用，不需要把目标集合一次性全部加载到内存，使用一点加载一点。</li>\n<li>惰性计算，可以用来表达无限区间，比如第一讲我们说的range，可以表达1到无限这个集合，这种在其他有些语言中很难表达。</li>\n<li>可以安全地访问边界，不需要使用有访问风险的下标操作符。</li>\n</ol><h3><code>next()</code> 方法</h3><p>迭代器上有一个标准方法，叫作 <code>next()</code>，这个方法返回 <code>Option&lt;Item&gt;</code>，其中 Item 就是组成迭代器的元素。这个方法的字面意思就是<strong>迭代出下一个元素</strong>。如果这个集合被迭代完成了，那么最后一次执行会返回 <code>None</code>。比如下面的例子，在迭代器上调用 <code>.next()</code> 返回 <code>u32</code> 数字。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let a: Vec&lt;u32&gt; = vec![1, 2, 3, 4, 5];\n&nbsp; &nbsp; let mut an_iter = a.into_iter();    // 将Vec&lt;u32&gt;转换为迭代器\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; while let Some(i) = an_iter.next() {  // 调用 .next() 方法\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"{i}\");\n&nbsp; &nbsp; }\n}\n// 输出\n1\n2\n3\n4\n5\n</code></pre><p>实际上，Rust中不止 <code>into_iter()</code> 这一种将集合转换成迭代器的方法。</p><h3><code>iter()</code>、<code>iter_mut()</code>、<code>into_iter()</code>与三种迭代器</h3><p>Rust中的迭代器根据所有权三态可以分成三种。</p><ol>\n<li>获取集合元素不可变引用的迭代器，对应方法为 <code>iter()</code>。</li>\n<li>获取集合元素可变引用的迭代器，对应方法为 <code>iter_mut()</code>。</li>\n<li>获取集合元素所有权的迭代器，对应方法为 <code>into_iter()</code>。</li>\n</ol><p>在Rust标准库约定中，如果你看到一个类型上实现了 <code>iter()</code> 方法，那么它会返回获取集合元素不可变引用的迭代器；如果你看到一个类型上实现了 <code>iter_mut()</code> 方法，那么它会返回获取集合元素可变引用的迭代器；如果你看到一个类型上实现了 <code>into_iter()</code> 方法，那么它会返回获取集合元素所有权的迭代器。调用了这个迭代器后，迭代器的执行会消耗掉原集合。</p><p>我们来看这三种不同的迭代器的一个对比。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let mut a = [1, 2, 3];    // 一个整数数组\n\n&nbsp; &nbsp; let mut an_iter = a.iter();  // 转换成第一种迭代器\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; assert_eq!(Some(&amp;1), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(&amp;2), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(&amp;3), an_iter.next());\n&nbsp; &nbsp; assert_eq!(None, an_iter.next());\n\n&nbsp; &nbsp; let mut an_iter = a.iter_mut();  // 转换成第二种迭代器\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; assert_eq!(Some(&amp;mut 1), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(&amp;mut 2), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(&amp;mut 3), an_iter.next());\n&nbsp; &nbsp; assert_eq!(None, an_iter.next());\n\n&nbsp; &nbsp; let mut an_iter = a.into_iter();  // 转换成第三种迭代器，并消耗掉a\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; assert_eq!(Some(1), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(2), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(3), an_iter.next());\n&nbsp; &nbsp; assert_eq!(None, an_iter.next());\n\n    println!(\"{:?}\", a);\n}\n</code></pre><p>你还可以与字符串数组进行对比加深理解。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let mut a = [\"1\".to_string(), \"2\".to_string(), \"3\".to_string()];\n&nbsp; &nbsp; let mut an_iter = a.iter();\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; assert_eq!(Some(&amp;\"1\".to_string()), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(&amp;\"2\".to_string()), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(&amp;\"3\".to_string()), an_iter.next());\n&nbsp; &nbsp; assert_eq!(None, an_iter.next());\n\n&nbsp; &nbsp; let mut an_iter = a.iter_mut();\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; assert_eq!(Some(&amp;mut \"1\".to_string()), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(&amp;mut \"2\".to_string()), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(&amp;mut \"3\".to_string()), an_iter.next());\n&nbsp; &nbsp; assert_eq!(None, an_iter.next());\n\n&nbsp; &nbsp; let mut an_iter = a.into_iter();\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; assert_eq!(Some(\"1\".to_string()), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(\"2\".to_string()), an_iter.next());\n&nbsp; &nbsp; assert_eq!(Some(\"3\".to_string()), an_iter.next());\n&nbsp; &nbsp; assert_eq!(None, an_iter.next());\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; println!(\"{:?}\", a);    // 请你试试这一行有没有问题？\n}\n</code></pre><p>对于整数数组 <code>[1,2,3]</code> 而言，调用 <code>into_iter()</code> 实际会复制一份这个数组，再将复制后的数组转换成迭代器，并消耗掉这个复制后的数组，因此最后的打印语句能把原来那个a打印出来。对于字符串数组 <code>[\"1\".to_string(), \"2\".to_string(), \"3\".to_string()]</code> 而言，调用 <code>into_iter()</code> 会直接消耗掉这个字符串数组，因此最后的打印语句不能把原来那个a打印出来。</p><p>为什么会有这个差异呢？你可以从我们<a href=\"https://time.geekbang.org/column/article/718916\">第 2 讲</a>所有权相关知识中找到答案。</p><h3>for 语句的真面目</h3><p>有了迭代器的背景知识后，我们终于要解开Rust语言里面for语句的真面目了。for语句是一种语法糖。语句 <code>for item in c {}</code> 会展开成下面这样：</p><pre><code class=\"language-plain\">let mut tmp_iter = c.into_iter();\nwhile let Some(item) = tmp_iter.next() {}\n</code></pre><p>也就是说，for语句默认使用获取元素所有权的迭代器模式，自动调用了 <code>into_iter()</code> 方法。因此，for语句会消耗集合 c。同时也说明，要将一个类型放在for语句里进行迭代，需要这个类型实现了迭代器 <code>into_iter()</code> 方法。</p><p>标准库中常见的 Range、Vec、HashMap、BtreeMap等都实现了 <code>into_iter()</code> 方法，因此它们可以放在for语句里进行迭代。</p><p>for语句作为一种基础语法，它会消耗掉原集合。有时候希望不获取原集合元素所有权，比如只是打印一下，这时只需要获取集合元素的引用 ，应该怎么办呢？</p><p>Rust中也考虑到了这种需求，提供了配套的辅助语法。</p><ul>\n<li>用 <code>for  in &amp;c {}</code> 获取元素的不可变引用，相当于调用 <code>c.iter()</code>。</li>\n<li>用 <code>for  in &amp;mut c {}</code> 获取元素的可变引用，相当于调用 <code>c.iter_mut()</code>。</li>\n</ul><p>用这两种形式就不会消耗原集合所有权。</p><p>我们来看示例。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let mut a = [\"1\".to_string(), \"2\".to_string(), \"3\".to_string()];\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; for item in &amp;a {  \n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"{}\", item);\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; for item in &amp;mut a {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"{}\", item);\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; for item in a {    // 请想一想为什么要把这一句放在后面\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"{}\", item);\n&nbsp; &nbsp; }\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; // println!(\"{:?}\", a);  // 你可以试试把这一句打开\n}\n// 输出\n1\n2\n3\n1\n2\n3\n1\n2\n3\n</code></pre><p>因为 <code>into_iter()</code> 会消耗集合所有权，因此在上面示例中我们把它放在最后去展示。</p><h3>获取集合类型中元素的所有权</h3><p>我们来看一个简单的例子，一般来说，我们想要获取Vec里的一个元素，只需要下标操作就可以了。</p><pre><code class=\"language-plain\">fn main() {\n    let s1 = String::from(\"aaa\");\n    let s2 = String::from(\"bbb\");\n    let s3 = String::from(\"ccc\");\n    let s4 = String::from(\"ddd\");\n    \n    let v = vec![s1, s2, s3, s4];\n    let a = v[0];    // 这里，我们想访问 s1 的内容\n}\n</code></pre><p>这段代码稀松平常，在Rust中却没办法编译通过。</p><pre><code>error[E0507]: cannot move out of index of `Vec&lt;String&gt;`\n  --&gt; src/main.rs:11:13\n   |\n11 |     let a = v[0];  \n   |             ^^^^ move occurs because value has type `String`, which does not implement the `Copy` trait\n   |\nhelp: consider borrowing here\n   |\n11 |     let a = &amp;v[0]; \n   |             +\n</code></pre><p>提示不能从 <code>Vec&lt;String&gt;</code> 中用下标操作符移出元素。我们改一下代码。</p><pre><code>fn main() {\n    let s1 = String::from(&quot;aaa&quot;);\n    let s2 = String::from(&quot;bbb&quot;);\n    let s3 = String::from(&quot;ccc&quot;);\n    let s4 = String::from(&quot;ddd&quot;);\n    \n    let v = vec![s1, s2, s3, s4];\n    let a = &amp;v[0];  // 明确a只获得v中第一个元素的引用\n}\n</code></pre><p>明确a只获得v中第一个元素的引用，这下可以编译通过了。这里，你可以顺便思考一下，对于 <code>Vec&lt;u32&gt;</code> 这种类型的动态数组，let a = v[0]; 这种代码可以编译通过吗？你可以立即动手测试一下。</p><p>在上面示例中，你可能为了从集合中获得 s1 的所有权，而不得不使用 <code>let a = v[0].clone()</code>。而根据我们这节课讲的迭代器知识，使用 <code>into_iter()</code> 就可以拿到并操作上述动态数组v中元素的所有权。</p><pre><code class=\"language-plain\">fn main() {\n    let s1 = String::from(\"aaa\");\n    let s2 = String::from(\"bbb\");\n    let s3 = String::from(\"ccc\");\n    let s4 = String::from(\"ddd\");\n    \n    let v = vec![s1, s2, s3, s4];\n    for s in v {      // 这里，s拿到了集合元素的所有权\n        println!(\"{}\", s);\n    }\n}\n</code></pre><p>这也体现了Rust对权限有相当细致的管理。对于下标索引这种不安全的操作，禁止获得集合元素所有权；对于迭代器这种安全的操作，允许它获得集合元素所有权。</p><h2>小结</h2><p>我们这节课详细探讨了Rust中的 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 的定义及常见操作。学习了如何以解包和不解包方式使用它们。内容比较细，风格可能也是你不太熟悉的。不过现在你只需要先了解这种代码风格，以后的项目实践中再慢慢掌握它们。</p><p>我们还介绍了迭代器的概念。迭代器的 <code>next()</code> 方法会返回一个 <code>Option&lt;Item&gt;</code> 类型。在所有权三态理论的指导下Rust中的迭代器也划分成了三种，可以通过不同的方法获取到集合元素的不可变引用、可变引用和所有权，这是Rust和其他语言的迭代器很不一样的地方。每种迭代器都有各自适用的场景，正确使用迭代器能提高代码的可靠性和可阅读性。</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/32/d300204ce7c0e9a948b486d617e7fa32.jpg?wh=1646x1233\" alt=\"\"></p><p>学习完这节课的内容之后，你应该能更深刻地感受到所有权概念在Rust语言中的支配地位。</p><h2>思考题</h2><p>你可以用同样的思路去研究一下，看看如何拿到 HashMap 中值的所有权。</p><p><a href=\"https://doc.rust-lang.org/std/collections/struct.HashMap.html\">https://doc.rust-lang.org/std/collections/struct.HashMap.html</a></p><p>欢迎你把你的成果展示在评论区，也欢迎你把这节课的内容分享给需要的朋友，邀他一起学习，我们下节课再见！</p>","comments":[{"had_liked":false,"id":383539,"user_name":"天高地迥","can_delete":false,"product_type":"c1","uid":2673491,"ip_address":"上海","ucode":"1C5C53C9BA97A7","user_header":"https://static001.geekbang.org/account/avatar/00/28/cb/53/74a6cd05.jpg","comment_is_top":false,"comment_ctime":1699242166,"is_pvip":false,"replies":[{"id":139741,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699256789,"ip_address":"重庆","comment_id":383539,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"Vec&lt;String&gt; []索引不能move的原因思考：\nVec实现了Index trait的index方法，该方法返回一个引用。然后使用［］语法糖的时候，编译器会自动解引用：v［0］变成*v.index(&amp;0)。其实错误的本质是borrowed value不能move out。","like_count":17,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631024,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699256789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383958,"user_name":"Ransang","can_delete":false,"product_type":"c1","uid":1133041,"ip_address":"上海","ucode":"DB67566A627DF2","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/f1/bd61dbb1.jpg","comment_is_top":false,"comment_ctime":1700019401,"is_pvip":false,"replies":[{"id":140102,"content":"对，你发现了一个惊人的事实，有用的知识又增加了！\n你会发现，所有的 iter() 和 iter_mut() 都是实现在 types 上的，它们的输出结果就是将 type 变成另一个type_i，这个type_i 实现了 Iterator trait。而对所有实现了 Iterator trait 的，又自动为其实现了 IntoIterator trait，into_iter() 正是这个trait中的方法。第09讲会讲到这方面的预备知识。\n这种分离实现是Rust的典型特色，因为不是所有的类型都需要实现这3种迭代器的，这样设计可带来最大程度的灵活性。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700191900,"ip_address":"重庆","comment_id":383958,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"HashMap实现了into_iter()，因此可以用for语句获取其所有权，另外我在老师发的hashmap的文档中发现HashMap的iter()和iter_mut()是分类在Implementations中，而into_iter()是在Trait Implementations中，请问这里面有什么特殊之处吗","like_count":6,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631948,"discussion_content":"对，你发现了一个惊人的事实，有用的知识又增加了！\n你会发现，所有的 iter() 和 iter_mut() 都是实现在 types 上的，它们的输出结果就是将 type 变成另一个type_i，这个type_i 实现了 Iterator trait。而对所有实现了 Iterator trait 的，又自动为其实现了 IntoIterator trait，into_iter() 正是这个trait中的方法。第09讲会讲到这方面的预备知识。\n这种分离实现是Rust的典型特色，因为不是所有的类型都需要实现这3种迭代器的，这样设计可带来最大程度的灵活性。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1700191900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385310,"user_name":"小可爱(`へ´*)ノ","can_delete":false,"product_type":"c1","uid":1016404,"ip_address":"四川","ucode":"E75189846F6616","user_header":"https://static001.geekbang.org/account/avatar/00/0f/82/54/b9cd3674.jpg","comment_is_top":false,"comment_ctime":1702428815,"is_pvip":false,"replies":[{"id":140430,"content":"谢谢","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702436108,"ip_address":"重庆","comment_id":385310,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师讲的很好，多了解rust底层规则，才能写出更好的代码。","like_count":3,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633652,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702436108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383736,"user_name":"鸠摩智","can_delete":false,"product_type":"c1","uid":1106201,"ip_address":"江苏","ucode":"853E584FC4CD64","user_header":"https://static001.geekbang.org/account/avatar/00/10/e1/19/c756aaed.jpg","comment_is_top":false,"comment_ctime":1699529489,"is_pvip":true,"replies":[{"id":139955,"content":"是的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699591185,"ip_address":"重庆","comment_id":383736,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"    let arr = vec![1,3,3,4];\n    let a = arr[0];\n    println!(&quot;{}&quot;, a);\n    println!(&quot;{:?}&quot;, arr);\n对于Vec&lt;u32&gt;是可以用v[0]的，因为u32是可以Copy的","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631476,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699591185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383628,"user_name":"Marco","can_delete":false,"product_type":"c1","uid":1012627,"ip_address":"中国香港","ucode":"502149B57700FE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/73/93/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1699368030,"is_pvip":false,"replies":[{"id":139814,"content":"可以的。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699412171,"ip_address":"重庆","comment_id":383628,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师你好。\n&quot;next() 方法&quot;这一节的例子也可以改为如下结构吧\n    loop {\n        match an_iter.next() {\n            Some(i) =&gt; println!(&quot;{i}&quot;),\n            None =&gt; break,\n        }\n    }","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631226,"discussion_content":"可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699412172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383551,"user_name":"PEtFiSh","can_delete":false,"product_type":"c1","uid":1765926,"ip_address":"上海","ucode":"C4922398A92E05","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLO6XvxfFPMGcVSSX8uIZY2yib29qlyat178pU4QM3gIic5GXZ8PC0tzRiazP3FiajXbTj19SE4ZhV0gQ/132","comment_is_top":false,"comment_ctime":1699260131,"is_pvip":false,"replies":[{"id":139819,"content":"👍👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699412229,"ip_address":"重庆","comment_id":383551,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"for (k, v) in myhash { &#47;&#47;`myhash` moved due to this implicit call to `.into_iter()`\n    &#47;&#47; todo:\n    &#47;&#47; 这里会获得v的所有权，并且消耗掉myhash\n}\n\nprintln!(&quot;{:?}&quot;, myhash); &#47;&#47;value borrowed here after move","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631231,"discussion_content":"👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699412229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383541,"user_name":"-","can_delete":false,"product_type":"c1","uid":1546505,"ip_address":"北京","ucode":"7B34258D346793","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/09/29c46a7b.jpg","comment_is_top":false,"comment_ctime":1699243329,"is_pvip":false,"replies":[{"id":139742,"content":"let a: Vec&lt;u32&gt; = vec![1, 2, 3, 4, 5];","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699256801,"ip_address":"重庆","comment_id":383541,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":" 定义了类型以后，let a: Vec&lt;u32&gt; = [1, 2, 3, 4, 5];语法错误\n修改为let a= [1, 2, 3, 4, 5];","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631025,"discussion_content":"let a: Vec&lt;u32&gt; = vec![1, 2, 3, 4, 5];","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699256801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389129,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"广东","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1711633261,"is_pvip":false,"replies":[{"id":141741,"content":"你指的这个吗？\nlet line = &quot;1\\n2\\n3\\n4\\n&quot;;\n \nfor num in line.lines() {\nmatch num.parse::&lt;i32&gt;().map(|i| i * 2) {\nOk(n) =&gt; println!(&quot;{n}&quot;),\nErr(..) =&gt; {}\n}\n}\n排版有点问题。这个Err分支是 parse() 方法有可能出错，返回一个Err，在map时，直接透传这个Err，然后就到match那里了。\n\n_ 是占位符，是可以的。.. 经常用于比如 (x, ..) 这种，关注某个或前面某几个元素，而忽略后面的。\n","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1713028092,"ip_address":"加拿大","comment_id":389129,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"请教下老师，文章中“不解包的情况下如何操作？”小节部分说到 Result&lt;T, E&gt; 的常用方法 map() 时，里面示例代码的模式匹配的 Err(..) 分支是什么意思？我试了 Err(_) 也是可以执行通过的，_ 忽略元组枚举变体 Err 的负载，（和 .. 相比）它们两个有什么区别？分别什么时候使用哪个呢？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641822,"discussion_content":"你指的这个吗？\nlet line = &#34;1\\n2\\n3\\n4\\n&#34;;\n \nfor num in line.lines() {\nmatch num.parse::&lt;i32&gt;().map(|i| i * 2) {\nOk(n) =&gt; println!(&#34;{n}&#34;),\nErr(..) =&gt; {}\n}\n}\n排版有点问题。这个Err分支是 parse() 方法有可能出错，返回一个Err，在map时，直接透传这个Err，然后就到match那里了。\n\n_ 是占位符，是可以的。.. 经常用于比如 (x, ..) 这种，关注某个或前面某几个元素，而忽略后面的。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713028092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386998,"user_name":"wcf","can_delete":false,"product_type":"c1","uid":1829111,"ip_address":"北京","ucode":"6E3B0A47B963E7","user_header":"https://static001.geekbang.org/account/avatar/00/1b/e8/f7/1b45fa46.jpg","comment_is_top":false,"comment_ctime":1706110001,"is_pvip":false,"replies":[{"id":141266,"content":"你运行一下就知道怎么回事了。简单的说是，u32与String在再赋值时的行为不同。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1708823513,"ip_address":"加拿大","comment_id":386998,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"为什么会有这个差异呢？你可以从我们第 2 讲所有权相关知识中找到答案。\n============\n没看出来为什么?","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637691,"discussion_content":"你运行一下就知道怎么回事了。简单的说是，u32与String在再赋值时的行为不同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708823513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1808028,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/96/9c/952d95e7.jpg","nickname":"Jack.💤","note":"","ucode":"E2C2E082D7F269","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647368,"discussion_content":"```which does not implement the `Copy` trait``` 这句话是重点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1719931771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":395993,"user_name":"当初莫相识","can_delete":false,"product_type":"c1","uid":2768765,"ip_address":"北京","ucode":"313917BB360D48","user_header":"https://static001.geekbang.org/account/avatar/00/2a/3f/7d/f624fa69.jpg","comment_is_top":false,"comment_ctime":1732622125,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"C++ 现在有Option，但是没有Result，可以如何设计自行设计一个Result呢","like_count":0},{"had_liked":false,"id":395122,"user_name":"落星野","can_delete":false,"product_type":"c1","uid":2667148,"ip_address":"北京","ucode":"EDFD05088A2026","user_header":"https://static001.geekbang.org/account/avatar/00/28/b2/8c/77d4d9bf.jpg","comment_is_top":false,"comment_ctime":1729499876,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"上面对Go语言返回值的说法有一点小问题，Go语言不限制返回值的数量与类型，最后一个返回的 err 只是一种编码习惯，一般用于返回实现了 Error 接口的实例，亦即只要实现了 error.Error() 方法的实例返回都皆可。如果用户为了简便起见，在最后返回string类型（字符串），则返回的 err 就是一个字符串。","like_count":0},{"had_liked":false,"id":393280,"user_name":"Geek_93cb91","can_delete":false,"product_type":"c1","uid":3944492,"ip_address":"上海","ucode":"C2A77CCBA6E193","user_header":"","comment_is_top":false,"comment_ctime":1723361787,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"买过好几本书了&#xff0c;反复入门再入门&#xff0c;感觉唐老师的内容比书全面多了&#xff0c;再入门一遍&#xff0c;最后一遍&#xff01;","like_count":0},{"had_liked":false,"id":390705,"user_name":"wbytts","can_delete":false,"product_type":"c1","uid":1233036,"ip_address":"江苏","ucode":"0341E00F80FFF5","user_header":"https://static001.geekbang.org/account/avatar/00/12/d0/8c/71ed37f8.jpg","comment_is_top":false,"comment_ctime":1716056028,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"unwrap_or_default 的配图，Result那一列写错文字了","like_count":0},{"had_liked":false,"id":390618,"user_name":"Massdama","can_delete":false,"product_type":"c1","uid":3887120,"ip_address":"美国","ucode":"A04628AADD4E8E","user_header":"https://static001.geekbang.org/account/avatar/00/3b/50/10/c57c7389.jpg","comment_is_top":false,"comment_ctime":1715779134,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"持有使用权的数据需要所有时要考虑借 也就是引用","like_count":0},{"had_liked":false,"id":390137,"user_name":"独钓寒江","can_delete":false,"product_type":"c1","uid":1203049,"ip_address":"中国香港","ucode":"2C81906FD88C8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/69/7ace1ddb.jpg","comment_is_top":false,"comment_ctime":1714450168,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"第三次刷基础篇，之前不知道Some(T)是什么，具体来说是不知道Some是什么类型，因为枚举内可以包含多种类型，那么Some是什么类型？看得好懵，心里慌得一批。这次搜索了一下，大多只是说Some是Option类型，只看到Rust By Example里说了一句Some(value)是元组结构体，噢， 终于没那么懵了","like_count":0},{"had_liked":false,"id":389670,"user_name":"独钓寒江","can_delete":false,"product_type":"c1","uid":1203049,"ip_address":"中国香港","ucode":"2C81906FD88C8C","user_header":"https://static001.geekbang.org/account/avatar/00/12/5b/69/7ace1ddb.jpg","comment_is_top":false,"comment_ctime":1713236177,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"可以具体展开解释一下“let maybe_some_len = maybe_some_string.map(|s| s.len());” 里面的 “map(|s| s.len())” 吗？猜|s|是闭包，s是什么呢？ self ？猜s.len()是获取长度， 但|s| s.len() 合起来写就看懵了。","like_count":0,"discussions":[{"author":{"id":1203049,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5b/69/7ace1ddb.jpg","nickname":"独钓寒江","note":"","ucode":"2C81906FD88C8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":642124,"discussion_content":"再查了一下，原来|s| s.len() 合起来才是闭包，不了解，需要补充的知识","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1713331425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385392,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1702552060,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"思考题： 用 entry\nuse std::collections::hash_map::Entry;\nmatch some_hashmap.entry(key) {\n    Entry::Occupied(value) =&gt; ...\n    Entry::Vacant(vacant entry) =&gt; ...\n}\n\n具体类型应该有点对不上， 回头看看文档的","like_count":0}]}