{"id":740931,"title":"1.1 基础编程模型","content":"\n<p>我们学习算法的方法是用 Java 编程语言编写的<strong>程序</strong>来实现算法。这样做是出于以下原因：</p>\n<ul>\n<li>程序是对算法精确、优雅和完全的描述；</li>\n<li>可以通过运行程序来学习算法的各种性质；</li>\n<li>可以在应用程序中直接使用这些算法。</li>\n</ul>\n<p>相比用自然语言描述算法，这些是重要而巨大的优势。</p>\n<p>这样做的一个缺点是我们要使用特定的编程语言，这会使分离算法的思想和实现细节变得困难。我们在实现算法时考虑到了这一点，只使用了大多数现代编程语言都具有且能够充分描述算法所必需的语法。</p>\n<p>我们仅使用了 Java 的一个子集。尽管我们没有明确地说明这个子集的范围，但你也会看到我们只使用了很少的 Java 特性，而且会优先使用大多数现代编程语言所共有的语法。我们的代码是完整的，因此希望你能下载这些代码并用我们的测试数据或是你自己的来运行它们。</p>\n<p>我们把描述和实现算法所用到的语言特性、软件库和操作系统特性总称为<strong>基础编程模型</strong>。本节以及 1.2 节会详细说明这个模型，相关内容自成一体，主要是作为文档供读者查阅，以便理解本书的代码。我们的另一本入门级的书籍 <em>An Introduction to Programming in Java: An Interdisciplinary Approach</em> 也使用了这个模型。</p>\n<p>作为参考，图 1.1.1 所示的是一个完整的 Java 程序。它说明了我们的基础编程模型的许多基本特点。在讨论语言特性时我们会用这段代码作为例子，但可以先不用考虑代码的实际意义（它实现了经典的<strong>二分查找</strong>算法，并在<strong>白名单过滤</strong>应用中对算法进行了检验，请见 1.1.10 节）。我们假设你具备某种主流语言编程的经验，因此你应该知道这段代码中的大多数要点。图中的注释应该能够解答你的任何疑问。因为图中的代码某种程度上反映了本书代码的风格，而且对各种 Java 编程惯例和语言构造，在用法上我们都力求一致，所以即使是经验丰富的 Java 程序员也应该看一看。</p><!-- [[[read_end]]] -->\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00797.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.1.1　Java 程序及其命令行的调用</strong></p>\n<h3 id=\"nav_point_12\">1.1.1　Java 程序的基本结构</h3>\n<p>一段 Java 程序（<strong>类</strong>）或者是一个<strong>静态方法</strong>（函数）<strong>库</strong>，或者<strong>定义了一个数据类型</strong>。要创建静态方法库和定义数据类型，会用到下面七种语法，它们是 Java 语言的基础，也是大多数现代语言所共有的。</p>\n<ul>\n<li><strong>原始数据类型</strong>：它们在计算机程序中精确地定义<strong>整数</strong>、<strong>浮点数</strong>和<strong>布尔值</strong>等。它们的定义包括取值范围和能够对相应的值进行的<strong>操作</strong>，它们能够被组合为类似于数学公式定义的<strong>表达式</strong>。</li>\n<li><strong>语句</strong>：语句通过创建<strong>变量</strong>并对其赋值、控制运行流程或者引发副作用来进行计算。我们会使用六种语句：<strong>声明</strong>、<strong>赋值</strong>、<strong>条件</strong>、<strong>循环</strong>、<strong>调用</strong>和<strong>返回</strong>。</li>\n<li><strong>数组</strong>：数组是多个同种数据类型的值的集合。</li>\n<li><strong>静态方法</strong>：静态方法可以封装并重用代码，使我们可以用独立的模块开发程序。</li>\n<li><strong>字符串</strong>：字符串是一连串的字符，Java 内置了对它们的一些操作。</li>\n<li><strong>标准输入 / 输出</strong>：标准输入输出是程序与外界联系的桥梁。</li>\n<li><strong>数据抽象</strong>：数据抽象封装和重用代码，使我们可以定义非原始数据类型，进而支持面向对象编程。</li>\n</ul>\n<p>我们将在本节学习前六种语法，数据抽象是下一节的主题。</p>\n<p>运行 Java 程序需要和操作系统或开发环境打交道。为了清晰和简洁，我们把这种输入命令执行程序的环境称为<strong>虚拟终端</strong>。请登录本书的网站去了解如何使用虚拟终端，或是现代系统中许多其他高级的编程开发环境的使用方法。</p>\n<p>在例子中，BinarySearch 类有两个静态方法<code>rank()</code> 和 <code>main()</code>。第一个方法 <code>rank()</code> 含有四条语句：两条声明语句，一条循环语句（该语句中又有一条赋值语句和两条条件语句）和一条返回语句。第二个方法 <code>main()</code> 包含三条语句：一条声明语句、一条调用语句和一个循环语句（该语句中又包含一条赋值语句和一条条件语句）。</p>\n<p>要执行一个 Java 程序，首先需要用 <code>javac</code> 命令<strong>编译</strong>它，然后再用 <code>java</code> 命令<strong>运行</strong>它。例如，要运行 BinarySearch，首先要输入 <code>javac BinarySearch.java</code>（这将生成一个叫 BinarySearch.class 的文件，其中含有这个程序的 Java <strong>字节码</strong>）；然后再输入 <code>java BinarySearch</code>（接着是一个白名单文件名）把控制权移交给这段字节码程序。为了理解这段程序，我们接下来要详细介绍原始数据类型和表达式，各种 Java 语句、数组、静态方法、字符串和输入输出。</p>\n<h3 id=\"nav_point_13\">1.1.2　原始数据类型与表达式</h3>\n<p><strong>数据类型</strong>就是一组数据和对其所能进行的操作的集合。首先考虑以下 4 种 Java 语言最基本的原始数据类型：</p>\n<ul>\n<li><strong>整型</strong>，及其算术运算符（<code>int</code>）；</li>\n<li><strong>双精度实数类型</strong>，及其算术运算符（<code>double</code>）；</li>\n<li><strong>布尔型</strong>，它的值 <code></code> 及其逻辑操作（<code>boolean</code>）；</li>\n<li><strong>字符型</strong>，它的值是你能够输入的英文字母数字字符和符号（<code>char</code>）。</li>\n</ul>\n<p>接下来我们看看如何指明这些类型的值和对这些类型的操作。</p>\n<p>Java 程序控制的是用<strong>标识符</strong>命名的<strong>变量</strong>。每个变量都有自己的类型并存储了一个合法的值。在 Java 代码中，我们用类似数学表达式的<strong>表达式</strong>来实现对各种类型的操作。对于原始类型来说，我们用标识符来引用变量，用 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 等<strong>运算符</strong>来指定操作，用<strong>字面量</strong>，例如 <code>1</code> 或者 <code>3.14</code> 来表示值，用形如 <code>(x+2.236)/2</code> 的表达式来表示对值的操作。表达式的目的就是计算某种数据类型的值。表 1.1.1 对这些基本内容进行了说明。</p>\n<p><strong>表 1.1.1　Java 程序的基本组成</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>术语</p></th>\n<th><p>例子</p></th>\n<th><p>定义</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>原始数据类型</p></td>\n<td><p><code>int double boolean char</code></p></td>\n<td><p>一组数据和对其所能进行的操作的集合（Java 语言内置）</p></td>\n</tr>\n<tr>\n<td><p>标识符</p></td>\n<td><p><code>a abc Ab$ a_b ab123 lo hi</code></p></td>\n<td><p>由字母、数字、下划线和 <code>$</code> 组成的字符串，首字符不能是数字</p></td>\n</tr>\n<tr>\n<td><p>变量</p></td>\n<td><p>［任意标识符］</p></td>\n<td><p>表示某种数据类型的值</p></td>\n</tr>\n<tr>\n<td><p>运算符</p></td>\n<td><p><code>+ － * /</code></p></td>\n<td><p>表示某种数据类型的运算</p></td>\n</tr>\n<tr>\n<td><p>字面量</p></td>\n<td><p><code>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;0 －42</code><br /><code>double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.0 1.0e-15 3.14</code><br /><code>boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true false</code><br /><code>char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'a'&nbsp;&nbsp;'+'&nbsp;&nbsp;'9'&nbsp;&nbsp;'\\n'</code></p></td>\n<td><p>值在源代码中的表示</p></td>\n</tr>\n<tr>\n<td><p>表达式</p></td>\n<td><p><code>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lo + (hi – lo) / 2</code><br /><code>double&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.0e-15 * t</code><br /><code>boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lo &lt;= hi</code></p></td>\n<td><p>字面量、变量或是能够计算出结果的一串字面量、变量和运算符的组合</p></td>\n</tr>\n</tbody>\n</table>\n<p>只要能够指定值域和在此值域上的操作，就能定义一个数据类型。表 1.1.2 总结了 Java 的 <code>int</code>、<code>double</code>、<code>boolean</code> 和 <code>char</code> 类型的相关信息。许多现代编程语言中的基本数据类型和它们都很相似。对于 <code>int</code> 和 <code>double</code> 来说，这些操作是我们熟悉的算术运算；对于 <code>boolean</code> 来说则是逻辑运算。需要注意的重要一点是，<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 都是被<strong>重载过</strong>的——根据上下文，同样的运算符对不同类型会执行不同的操作。这些初级运算的关键性质是<strong>运算产生的数据的数据类型和参与运算的数据的数据类型是相同的</strong>。这也意味着我们经常需要处理近似值，因为很多情况下由表达式定义的准确值并非参与表达式运算的值。例如，<code>5/3</code> 的值是 <code>1</code> 而 <code>5.0/3.0</code> 的值是 <code>1.66666666666667</code>，两者都很接近但并不准确地等于 <code>5/3</code>。下表并不完整，我们会在本节最后的答疑部分中讨论更多运算符和偶尔需要考虑到的各种异常情况。</p>\n<p><strong>表 1.1.2　Java 中的原始数据类型</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>类型</p></th>\n<th><p>值域</p></th>\n<th><p>运算符</p></th>\n<th><p>典型表达式表达式</p></th>\n<th><p>值</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>int</code></p></td>\n<td><p>-2<sup>31</sup> 至 +2<sup>31</sup>-1 之间的整数（32 位，二进制补码）</p></td>\n<td><p><code>+</code>（加）<br /><code>-</code>（减）<br /><code>*</code>（乘）<br /><code>/</code>（除）<br /><code>%</code>（求余）</p></td>\n<td><p><code>5 + 3</code><br /><code>5 – 3</code><br /><code>5 * 3</code><br /><code>5 / 3</code><br /><code>5 % 3</code></p></td>\n<td><p><code>8</code><br /><code>2</code><br /><code>15</code><br /><code>1</code><br /><code>2</code></p></td>\n</tr>\n<tr>\n<td><p><code>double</code></p></td>\n<td><p>双精度实数（64 位，IEEE 754 标准）</p></td>\n<td><p><code>+</code>（加）<br /><code>-</code>（减）<br /><code>*</code>（乘）<br /><code>/</code>（除）</p></td>\n<td><p><code>3.141 + 0.03</code><br /><code>2.0 - 2.0e-7</code><br /><code>100 * 0.015</code><br /><code>6.02e23 / 2.0</code></p></td>\n<td><p><code>3.171</code><br /><code>1.9999998</code><br /><code>1.5</code><br /><code>3.01e23</code></p></td>\n</tr>\n<tr>\n<td><p><code>boolean</code></p></td>\n<td><p><code>true</code> 或 <code>false</code></p></td>\n<td><p><code>&amp;&amp;</code>（与）<br /><code>||</code>（或）<br /><code>!</code>（非）<br /><code>^</code>（异或）</p></td>\n<td><p><code>true &amp;&amp; false</code><br /><code>false || true</code><br /><code>!false</code><br /><code>true ^ true</code></p></td>\n<td><p><code>false</code><br /><code>true</code><br /><code>true</code><br /><code>false</code></p></td>\n</tr>\n<tr>\n<td><p><code>char</code></p></td>\n<td><p>字符（16 位）</p></td>\n<td><p>（算术运算符，但很少使用）</p></td>\n<td><p>&nbsp;</p></td>\n<td><p>&nbsp;</p></td>\n</tr>\n</tbody>\n</table>\n<h4>1.1.2.1　表达式</h4>\n<p>如表1.1.2 所示，Java 使用的是<strong>中缀</strong>表达式：一个字面量（或是一个表达式），紧接着是一个运算符，再接着是另一个字面量（或者另一个表达式）。当一个表达式包含一个以上的运算符时，运算符的作用顺序非常重要，因此 Java 语言规范约定了如下的运算符优先级：运算符 <code>*</code> 和 <code>/</code>（以及 <code>%</code>）的优先级高于 <code>+</code> 和 <code>-</code>（优先级越高，越早运算）；在逻辑运算符中，<code>!</code> 拥有最高优先级，之后是 <code>&amp;&amp;</code>，接下来是 <code>||</code>。一般来说，相同优先级的运算符的运算顺序是从左至右。与在正常的算数表达式中一样，使用括号能够改变这些规则。因为不同语言中的优先级规则会有些许不同，我们在代码中会使用括号并用各种方法努力消除对优先级规则的依赖。</p>\n<h4>1.1.2.2　类型转换</h4>\n<p>如果不会损失信息，数值会被自动提升为高级的数据类型。例如，在表达式 <code>1+2.5</code> 中，1 会被转换为浮点数 <code>1.0</code>，表达式的值也为 <code>double</code> 值 <code>3.5</code>。<strong>转换</strong>指的是在表达式中把类型名放在括号里将其后的值转换为括号中的类型。例如，<code>(int)3.7</code> 的值是 <code>3</code> 而 <code>(double)3</code> 的值是 3.0。需要注意的是将浮点型转换为整型将会截断小数部分而非四舍五入，在复杂的表达式中的类型转换可能会很复杂，应该小心并尽量少使用类型转换，最好是在表达式中只使用同一类型的字面量和变量。</p>\n<h4>1.1.2.3　比较</h4>\n<p>下列运算符能够比较相同数据类型的两个值并产生一个布尔值：<strong>相等</strong>（<code>==</code>）、<strong>不等</strong>（<code>!=</code>）、<strong>小于</strong>（<code>&lt;</code>）、<strong>小于等于</strong>（<code>&lt;=</code>）、<strong>大于</strong>（<code>&gt;</code>）和<strong>大于等于</strong>（<code>&gt;=</code>）。这些运算符被称为混合类型运算符，因为它们的结果是布尔型，而不是参与比较的数据类型。结果是布尔型的表达式被称为<strong>布尔表达式</strong>。我们将会看到这种表达式是条件语句和循环语句的重要组成部分。</p>\n<h4>1.1.2.4　其他原始类型</h4>\n<p>Java 的<code>int</code> 型能够表示 2<sup>32</sup> 个不同的值，用一个字长 32 位的机器字即可表示（虽然现在的许多计算机有字长 64 位的机器字，但<code>int</code> 型仍然是 32 位）。与此相似，<code>double</code> 型的标准规定为 64 位。这些大小对于一般应用程序中使用的整数和实数已经足够了。为了提供更大的灵活性，Java 还提供了其他五种原始数据类型：</p>\n<ul>\n<li>64 位整数，及其算术运算符 <code>(long)</code>；</li>\n<li>16 位整数，及其算术运算符 <code>(short)</code>；</li>\n<li>16 位字符，及其算术运算符 <code>(char)</code>；</li>\n<li>8 位整数，及其算术运算符 <code>(byte)</code>；</li>\n<li>32 位单精度实数，及其算术运算符 <code>(float)</code>。</li>\n</ul>\n<p>在本书中我们大多使用 <code>int</code> 和 <code>double</code> 进行算术运算，因此我们在此不会再详细讨论其他类似的数据类型。</p>\n<h3 id=\"nav_point_14\">1.1.3　语句</h3>\n<p>Java 程序是由<strong>语句</strong>组成的。语句能够通过创建和操作变量、对变量赋值并控制这些操作的执行流程来描述运算。语句通常会被组织成代码段，即花括号中的一系列语句。</p>\n<ul>\n<li><strong>声明语句</strong>：创建某种类型的变量并用标识符为其命名。</li>\n<li><strong>赋值语句</strong>：将（由表达式产生的）某种类型的数值赋予一个变量。Java 还有一些<strong>隐式赋值</strong>的语法可以使某个变量的值相对于当前值发生变化，例如将一个整型值加 1。</li>\n<li><strong>条件语句</strong>：能够简单地改变执行流程——根据指定的条件执行两个代码段之一。</li>\n<li><strong>循环语句</strong>：更彻底地改变执行流程——只要条件为真就不断地反复执行代码段中的语句。</li>\n<li><strong>调用和返回语句</strong>：和静态方法有关（见 1.1.6 节），是改变执行流程和代码组织的另一种方式。</li>\n</ul>\n<p>程序就是由一系列声明、赋值、条件、循环、调用和返回语句组成的。一般来说代码的结构都是<strong>嵌套</strong>的：一个条件语句或循环语句的代码段中也能包含条件语句或是循环语句。例如，<code>rank()</code> 中的 <code>while</code> 循环就包含一个 <code>if</code> 语句。接下来，我们逐个说明各种类型的语句。</p>\n<h4>1.1.3.1　声明语句</h4>\n<p><strong>声明</strong>语句将一个变量名和一个类型在编译时关联起来。Java 需要我们用声明语句指定变量的名称和类型。这样，我们就清楚地指明了能够对其进行的操作。Java 是一种<strong>强类型</strong>的语言，因为 Java 编译器会检查类型的一致性（例如，它不会允许将布尔类型和浮点类型的变量相乘）。变量可以声明在第一次使用之前的任何地方——一般我们都在<strong>首次</strong>使用该变量的时候声明它。变量的<strong>作用域</strong>就是定义它的地方，一般由相同代码段中声明之后的所有语句组成。</p>\n<h4>1.1.3.2　赋值语句</h4>\n<p><strong>赋值</strong>语句将（由一个表达式定义的）某个数据类型的值和一个变量关联起来。在 Java 中，当我们写下<code>c=a+b</code> 时，我们表达的不是数学等式，而是一个操作，即令变量 <code>c</code> 的值等于变量 <code>a</code> 的值与变量 <code>b</code> 的值之和。当然，在赋值语句执行后，从数学上来说<code>c</code> 的值必然会等于 <code>a+b</code>，但语句的目的是改变 <code>c</code> 的值（如果需要的话）。赋值语句的左侧必须是单个变量，右侧可以是能够得到相应类型的值的任意表达式。</p>\n<h4>1.1.3.3　条件语句</h4>\n<p>大多数运算都需要用不同的操作来处理不同的输入。在 Java 中表达这种差异的一种方法是 <code>if</code> 语句：</p>\n<pre class=\"code-rows\"><code>if (&lt;boolean expression&gt;) { &lt;block statements&gt; }</code></pre>\n<p>这种描述方式是一种叫做<strong>模板</strong>的形式记法，我们偶尔会使用这种格式来表示 Java 的语法。尖括号（<code>&lt;&gt;</code>）中的是我们已经定义过的语法，这表示我们可以在指定的位置使用该语法的任意实例。在这里，<code>&lt;boolean expression&gt;</code> 表示一个布尔表达式，例如一个比较操作。<code>&lt;block statements&gt;</code> 表示一段 Java 语句。我们也可以给出 <code>&lt;boolean expression&gt;</code> 和<code>&lt;block statements&gt;</code> 的形式定义，不过我们不想深入这些细节。<code>if</code> 语句的意义不言自明：当且仅当布尔表达式的值为真 <code>(true)</code> 时代码段中的语句才会被执行。以下 <code>if-else</code> 语句能够在两个代码段之间作出选择：</p>\n<pre class=\"code-rows\"><code>if (&lt;boolean expression&gt;) { &lt;block statements&gt; }\nelse                      { &lt;block statements&gt; }</code></pre>\n<h4>1.1.3.4　循环语句</h4>\n<p>许多运算都需要重复。Java 语言中处理这种计算的基本语句的格式是：</p>\n<pre class=\"code-rows\"><code>while (&lt;boolean expression&gt;) { &lt;block statements&gt; }</code></pre>\n<p><code>while</code> 语句和 <code>if</code> 语句的形式相似（只是用<code>while</code> 代替了 <code>if</code>），但意义大有不同。当布尔表达式的值为假（<code>false</code>）时，代码什么也不做；当布尔表达式的值为真（<code>true</code>）时，执行代码段（和 <code>if</code> 一样），然后再次检查布尔表达式的值，如果仍然为真，再次执行代码段。如此这般，只要布尔表达式的值为真，就继续执行代码段。我们将循环语句中的代码段称为<strong>循环体</strong>。</p>\n<h4>1.1.3.5　<code>break</code> 与 <code>continue</code> 语句</h4>\n<p>有些情况下我们也会需要比基本的 <code>if</code> 和 <code>while</code> 语句更加复杂的流程控制。相应地，Java 支持在<code>while</code> 循环中使用另外两条语句：</p>\n<ul>\n<li><code>break</code> 语句，立即从循环中退出；</li>\n<li><code>continue</code> 语句，立即开始下一轮循环。</li>\n</ul>\n<p>本书很少在代码中使用它们（许多程序员从来都不用），但在某些情况下它们的确能够大大简化代码。</p>\n<h3 id=\"nav_point_15\">1.1.4　简便记法</h3>\n<p>程序有很多种写法，我们追求清晰、优雅和高效的代码。这样的代码经常会使用以下这些广为流传的简便写法（不仅仅是 Java，许多语言都支持它们）。</p>\n<h4>1.1.4.1　声明并初始化</h4>\n<p>可以将声明语句和赋值语句结合起来，在声明（创建）一个变量的同时将它初始化。例如，<code>int i = 1;</code> 创建了名为 <code>i</code> 的变量并赋予其初始值 1。最好在接近首次使用变量的地方声明它并将其初始化（为了限制它的作用域）。</p>\n<h4>1.1.4.2　隐式赋值</h4>\n<p>当希望一个变量的值相对于其当前值变化时，可以使用一些简便的写法。</p>\n<ul>\n<li>递增 / 递减运算符，<code>++i;</code> 等价于 <code>i=i+1;</code> 且表达式为 <code>i+1;</code>。类似地，<code>--i;</code> 等价于 <code>i=i-1;</code>。<code>i++;</code> 和 <code>i--;</code> 的意思分别与上述的 <code>++i;</code> 和 <code>--i;</code> 相同。</li>\n<li>其他复合运算符，在赋值语句中将一个二元运算符写在等号之前，等价于将左边的变量放在等号右边并作为第一个操作数。例如，<code>i/=2;</code> 等价于 <code>i=i/2;</code>。注意，<code>i += 1;</code> 等价于 <code>i = i + 1;</code>（以及 <code>++i;</code>）。</li>\n</ul>\n<h4>1.1.4.3　单语句代码段</h4>\n<p>如果条件或循环语句的代码段只有一条语句，代码段的花括号可以省略。</p>\n<h4>1.1.4.4　<code>for</code> 语句</h4>\n<p>很多循环的模式都是这样的：初始化一个索引变量，然后使用 <code>while</code> 循环并将包含索引变量的表达式作为循环的条件，<code>while</code> 循环的最后一条语句会将索引变量加 1。使用 Java 的 <code>for</code> 语句可以更紧凑地表达这种循环：</p>\n<pre class=\"code-rows\"><code>for (&lt;initialize&gt;; &lt;boolean expression&gt;; &lt;increment&gt;)\n{\n   &lt;block statements&gt;\n}</code></pre>\n<p>除了几种特殊情况之外，这段代码都等价于：</p>\n<pre class=\"code-rows\"><code>&lt;initialize&gt;;\nwhile (&lt;boolean expression&gt;)\n{\n   &lt;block statements&gt;\n   &lt;increment&gt;;\n}</code></pre>\n<p>我们将使用 <code>for</code> 语句来表示对这种<strong>初始化—递增</strong>循环用法的支持。</p>\n<p>表 1.1.3 总结了各种 Java 语句及其示例与定义。</p>\n<p><strong>表 1.1.3　Java 语句</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>语句</p></th>\n<th><p>示例</p></th>\n<th><p>定义</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>声明语句</p></td>\n<td><p></p><pre>int i;<br />double c;</pre></td>\n<td><p>创建一个指定类型的变量并用标识符命名</p></td>\n</tr>\n<tr>\n<td><p>赋值语句</p></td>\n<td><p></p><pre>a = b + 3;<br />discriminant = b * b - 4.0 * c;</pre></td>\n<td><p>将某一数据类型的值赋予一个变量</p></td>\n</tr>\n<tr>\n<td><p>声明并初始化</p></td>\n<td><p></p><pre>int i = 1;<br />double c = 3.14159265;</pre></td>\n<td><p>在声明时赋予变量初始值</p></td>\n</tr>\n<tr>\n<td><p>隐式赋值</p></td>\n<td><p></p><pre>++i;<br />i += 1;</pre></td>\n<td><p><code>i = i + 1;</code></p></td>\n</tr>\n<tr>\n<td><p>条件语句（<code>if</code>）</p></td>\n<td><p><code>if (x &lt; 0) x = -x;</code></p></td>\n<td><p>根据布尔表达式的值执行一条语句</p></td>\n</tr>\n<tr>\n<td><p>条件语句（<code>if-else</code>）</p></td>\n<td><p></p><pre>if (x &gt; y) max = x;<br />else       max = y;</pre></td>\n<td><p>根据布尔表达式的值执行两条语句中的一条</p></td>\n</tr>\n<tr>\n<td><p>循环语句（<code>while</code>）</p></td>\n<td><p></p><pre>int v = 0;<br />while(v &lt;= N)<br />  v = 2 * v;<br />double t = c;<br />while (Math.abs(t - c/t) &gt; 1e-15*t)<br />  t = (c/t + t) / 2.0;</pre></td>\n<td><p>执行语句，直至布尔表达式的值变为假（<code>false</code>）</p></td>\n</tr>\n<tr>\n<td><p>循环语句（<code>for</code>）</p></td>\n<td><p></p><pre>for (int i = 1; i &lt;= N; i++)<br />    sum += 1.0/i;<br />for (int i = 0; i &lt;= N; i++)<br />    StdOut.println(2*Math.PI*i/N);</pre></td>\n<td><p><code>while</code> 语句的简化版</p></td>\n</tr>\n<tr>\n<td><p>调用语句</p></td>\n<td><p><code>int key = StdIn.readInt();</code></p></td>\n<td><p>调用另一方法（请见 1.1.6.2 节）</p></td>\n</tr>\n<tr>\n<td><p>返回语句</p></td>\n<td><p><code>return false;</code></p></td>\n<td><p>从方法中返回（请见 1.1.6.3 节）</p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_16\">1.1.5　数组</h3>\n<p><strong>数组</strong>能够顺序存储相同类型的多个数据。除了存储数据，我们也希望能够访问数据。访问数组中的某个元素的方法是将其编号然后<strong>索引</strong>。如果我们有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个值，它们的编号则为 0 至 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00799.gif\" alt=\"N-1\" inline-img=\"true\" />。这样对于 0 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00799.gif\" alt=\"N-1\" inline-img=\"true\" /> 之间任意的 <code>i</code>，我们就能够在 Java 代码中用 <code>a[i]</code> 唯一地表示第 <code>i+1</code> 个元素的值。在 Java 中这种数组被称为<strong>一维数组</strong>。</p>\n<h4>1.1.5.1　创建并初始化数组</h4>\n<p>在 Java 程序中创建一个数组需要三步：</p>\n<ul>\n<li>声明数组的名字和类型；</li>\n<li>创建数组；</li>\n<li>初始化数组元素。</li>\n</ul>\n<p>在声明数组时，需要指定数组的名称和它含有的数据的类型。在创建数组时，需要指定数组的长度（元素的个数）。例如，在以下代码中，“完整模式”部分创建了一个有 <code>N</code> 个元素的<code>double</code> 数组，所有的元素的初始值都是 <code>0.0</code>。第一条语句是数组的声明，它和声明一个相应类型的原始数据类型变量十分相似，只有类型名之后的方括号说明我们声明的是一个数组。第二条语句中的关键字 <code>new</code> 使 Java 创建了这个数组。我们需要在运行时明确地创建数组的原因是 Java 编译器在编译时无法知道应该为数组预留多少空间（对于原始类型则可以）。<code>for</code> 语句初始化了数组的 <code>N</code> 个元素，将它们的值置为 <code>0.0</code>。在代码中使用数组时，一定要依次声明、创建并初始化数组。忽略了其中的任何一步都是很常见的编程错误。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00800.gif\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p style=\"text-align: center\"><strong>声明、创建并初始化一个数组</strong></p>\n<h4>1.1.5.2　简化写法</h4>\n<p>为了精简代码，我们常常会利用 Java 对数组默认的初始化来将三个步骤合为一条语句，即上例中的简化写法。等号的左侧声明了数组，等号的右侧创建了数组。这种写法不需要<code>for</code> 循环，因为在一个 Java 数组中 <code>double</code> 类型的变量的默认初始值都是 <code>0.0</code>，但如果你想使用不同的初始值，那么就需要使用 <code>for</code> 循环了。数值类型的默认初始值是 <code>0</code>，布尔型的默认初始值是 <code>false</code>。例子中的第三种方式用花括号将一列由逗号分隔的值在编译时将数组初始化。</p>\n<h4>1.1.5.3　使用数组</h4>\n<p>典型的数组处理代码请见表 1.1.4。在声明并创建数组之后，在代码的任何地方都能通过数组名之后的方括号中的索引来访问其中的元素。数组一经创建，它的大小就是固定的。程序能够通过 <code>a.length</code> 获取数组 <code>a[]</code> 的长度，而它的最后一个元素总是 <code>a[a.length – 1]</code>。Java 会自动进行边界检查——如果你创建了一个大小为 <code>N</code> 的数组，但使用了一个小于 <code>0</code> 或者大于 <code>N-1</code> 的索引访问它，程序会因为运行时抛出 <code>ArrayIndexOutOfBoundsException</code> 异常而终止。</p>\n<p><strong>表 1.1.4　典型的数组处理代码</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>任务</p></th>\n<th><p>实现（代码片段）</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>找出数组中最大的元素</p></td>\n<td><p></p><pre>double max = a[0];<br />for (int i = 1; i &lt; a.length; i++)<br />    if (a[i] &gt; max) max = a[i];</pre></td>\n</tr>\n<tr>\n<td><p>计算数组元素的平均值</p></td>\n<td><p></p><pre>int N = a.length;<br />double sum = 0.0;<br />for (int i = 0; i &lt; N; i++)<br />    sum += a[i];<br />double average = sum / N;</pre></td>\n</tr>\n<tr>\n<td><p>复制数组</p></td>\n<td><p></p><pre>int N = a.length;<br />double[] b = new double[N];<br />for (int i = 0; i &lt; N; i++)<br />    b[i] = a[i];</pre></td>\n</tr>\n<tr>\n<td><p>颠倒数组元素的顺序</p></td>\n<td><p></p><pre>int N = a.length;<br />for (int i = 0; i &lt; N/2; i++)<br />{<br />    double temp = a[i];<br />    a[i] = a[N-1-i];<br />    a[N-i-1] = temp;<br />}</pre></td>\n</tr>\n<tr>\n<td><p>矩阵相乘（方阵）<br /><code>a[][] * b[][] = c[][]</code></p></td>\n<td><p></p><pre>int N = a.length;<br />double[][] c = new double[N][N];<br />for (int i = 0; i &lt; N; i++)<br />    for (int j = 0; j &lt; N; j++)<br />    { // 计算行i 和列j 的点乘<br />       for (int k = 0; k &lt; N; k++)<br />          c[i][j] += a[i][k]*b[k][j];<br />    }</pre></td>\n</tr>\n</tbody>\n</table>\n<h4>1.1.5.4　起别名</h4>\n<p>请注意，<strong>数组名表示的是整个数组</strong>——如果我们将一个数组变量赋予另一个变量，那么两个变量将会指向同一个数组。例如以下这段代码：</p>\n<pre class=\"code-rows\"><code>int[] a = new int[N];\n...\na[i] = 1234;\n...\nint[] b = a;\n...\nb[i] = 5678;  // a[i] 的值也会变成5678</code></pre>\n<p>这种情况叫做<strong>起别名</strong>，有时可能会导致难以察觉的问题。如果你是想将数组复制一份，那么应该声明、创建并初始化一个新的数组，然后将原数组中的元素值挨个复制到新数组，如表 1.1.4 的第三个例子所示。</p>\n<h4>1.1.5.5　二维数组</h4>\n<p>在 Java 中<strong>二维数组</strong>就是一维数组的数组。二维数组可以是参差不齐的（元素数组的长度可以不一致），但大多数情况下（根据合适的参数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />）我们都会使用 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00802.gif\" alt=\"M\\times N\" inline-img=\"true\" />，即 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> <strong>行</strong>长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的数组的二维数组（也可以称数组含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> <strong>列</strong>）。在 Java 中访问二维数组也很简单。二维数组<code>a[][]</code> 的第 <code>i</code> 行第 <code>j</code> 列的元素可以写作 <code>a[i][j]</code>。声明二维数组需要两对方括号。创建二维数组时要在类型名之后分别在方括号中指定行数以及列数，例如：</p>\n<pre class=\"code-rows\"><code>double[][] a = new double[M][N];</code></pre>\n<p>我们将这样的数组称为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00802.gif\" alt=\"M\\times N\" inline-img=\"true\" /> 的数组。我们约定，第一维是行数，第二维是列数。和一维数组一样，Java 会将数值类型的数组元素初始化为 <code>0</code>，将布尔型的数组元素初始化为<code>false</code>。默认的初始化对二维数组更有用，因为可以节约更多的代码。下面这段代码和刚才只用一行就完成创建和初始化的语句是等价的：</p>\n<pre class=\"code-rows\"><code>double[][] a;\na = new double[M][N];\nfor (int i = 0; i &lt; M; i++)\n   for (int j = 0; j &lt; N; j++)\n      a[i][j] = 0.0;</code></pre>\n<p>在将二维数组初始化为 <code>0</code> 时这段代码是多余的，但是如果想要初始化为其他值，我们就需要嵌套的 <code>for</code> 循环了。</p>\n<h3 id=\"nav_point_17\">1.1.6　静态方法</h3>\n<p>本书中的所有 Java 程序要么是<strong>数据类型</strong>的定义（详见 1.2 节），要么是一个<strong>静态方法库</strong>。在许多语言中，静态方法被称为<strong>函数</strong>，因为它们和数学函数的性质类似。静态方法是一组在被调用时会被顺序执行的语句。修饰符 <code>static</code> 将这类方法和 1.2 节的<strong>实例方法</strong>区别开来。当讨论两类方法共有的属性时我们会使用不加定语的<strong>方法</strong>一词。</p>\n<h4>1.1.6.1　静态方法</h4>\n<p><strong>方法</strong>封装了由一系列语句所描述的运算。方法需要<strong>参数</strong>（某种数据类型的值）并根据参数计算出某种数据类型的<strong>返回值</strong>（例如数学函数的结果）或者产生某种<strong>副作用</strong>（例如打印一个值）。BinarySearch 中的静态函数 <code>rank()</code> 是前者的一个例子；<code>main()</code> 则是后者的一个例子。每个静态方法都是由<strong>签名</strong>（关键字<code>public static</code> 以及函数的返回值，方法名以及一串各种类型的参数）和<strong>函数体</strong>（即包含在花括号中的代码）组成的，如图 1.1.2 所示。静态函数的例子请见表 1.1.5。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00803.gif\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.1.2　静态方法解析</strong></p>\n<p><strong>表 1.1.5　典型静态方法的实现</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>任务</p></th>\n<th><p>实现</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>计算一个整数的绝对值</p></td>\n<td><p></p><pre>public static int abs(int x)<br />{<br />    if (x &lt; 0) return -x;<br />    else       return x;<br />}</pre></td>\n</tr>\n<tr>\n<td><p>计算一个浮点数的绝对值</p></td>\n<td><p></p><pre>public static double abs(double x)<br />{<br />    if (x &lt; 0.0) return -x;<br />    else         return x;<br />}</pre></td>\n</tr>\n<tr>\n<td><p>判定一个数是否是素数</p></td>\n<td><p></p><pre>public static boolean isPrime(int N)<br />{<br />    if (N &lt; 2) return false;<br />    for (int i = 2; i*i &lt;= N; i++)<br />        if (N % i == 0) return false;<br />    return true;<br />}</pre></td>\n</tr>\n<tr>\n<td><p>计算平方根（牛顿迭代法）</p></td>\n<td><p></p><pre>public static double sqrt(double c)<br />{<br />    if (c &lt; 0) return Double.NaN;<br />    double err = 1e-15;<br />    double t = c;<br />    while (Math.abs(t - c/t) &gt; err * t)<br />        t = (c/t + t) / 2.0;<br />    return t;<br />}</pre></td>\n</tr>\n<tr>\n<td><p>计算直角三角形的斜边</p></td>\n<td><p></p><pre>public static double hypotenuse(double a, double b)<br />{ return Math.sqrt(a*a + b*b); }</pre></td>\n</tr>\n<tr>\n<td><p>计算调和级数（请见表 1.4.5）</p></td>\n<td><p></p><pre>public static double H(int N)<br />{<br />    double sum = 0.0;<br />    for (int i = 1; i &lt;= N; i++)<br />        sum += 1.0 / i;<br />    return sum;<br />}</pre></td>\n</tr>\n</tbody>\n</table>\n<h4>1.1.6.2　调用静态方法</h4>\n<p><strong>调用</strong>静态方法的<strong>方法</strong>是写出方法名并在后面的括号中列出参数值，用逗号分隔。当调用是表达式的一部分时，方法的返回值将会替代表达式中的方法调用。例如，BinarySearch 中调用 <code>rank()</code> 返回了一个 <code>int</code> 值。仅由一个方法调用和一个分号组成的<strong>语句</strong>一般用于产生副作用。例如，BinarySearch 的 <code>main()</code> 函数中对系统方法 <code>Arrays.sort()</code> 的调用产生的副作用，是将数组中的所有条目有序地排列。调用方法时，它的参数变量将被初始化为调用时所给出的相应表达式的值。返回语句将结束静态方法并将控制权交还给调用者。如果静态方法的目的是计算某个值，返回语句应该指定这个值（如果这样的静态方法在执行完所有的语句之后都没有返回语句，编译器会报错）。</p>\n<h4>1.1.6.3　方法的性质</h4>\n<p>对方法所有性质的完整描述超出了本书的范畴，但以下几点值得一提。</p>\n<ul>\n<li><strong>方法的参数按值传递</strong>：在方法中参数变量的使用方法和局部变量相同，唯一不同的是参数变量的初始值是由调用方提供的。方法处理的是参数的值，而非参数本身。这种方式产生的结果是在静态方法中改变一个参数变量的值对调用者没有影响。本书中我们一般不会修改参数变量。值传递也意味着数组参数将会是原数组的别名（见 1.1.5.4 节）——方法中使用的参数变量能够引用调用者的数组并改变其内容（只是不能改变原数组变量本身）。例如，<code>Arrays.sort()</code> 将能够改变通过参数传递的数组的内容，将其排序。</li>\n<li><strong>方法名可以被重载</strong>：例如，Java 的 Math 包使用这种方法为所有的原始数值类型实现了 <code>Math.abs()</code>、<code>Math.min()</code> 和 <code>Math.max()</code> 函数。重载的另一种常见用法是为函数定义两个版本，其中一个需要一个参数而另一个则为该参数提供一个默认值。</li>\n<li><strong>方法只能返回一个值，但可以包含多个返回语句</strong>：一个 Java 方法只能返回一个值，它的类型是方法签名中声明的类型。静态方法第一次执行到一条返回语句时控制权将会回到调用代码中。尽管可能存在多条返回语句，任何静态方法每次都只会返回一个值，即被执行的第一条返回语句的参数。</li>\n<li><strong>方法可以产生副作用</strong>：方法的返回值可以是 <code>void</code>，这表示该方法没有返回值。返回值为 <code>void</code> 的静态函数不需要明确的返回语句，方法的最后一条语句执行完毕后控制权将会返回给调用方。我们称 <code>void</code> 类型的静态方法会产生副作用（接受输入、产生输出、修改数组或者改变系统状态）。例如，我们的程序中的静态方法 <code>main()</code> 的返回值就是 <code>void</code>，因为它的作用是向外输出。技术上来说，数学方法的返回值都不会是 <code>void</code>（<code>Math.random()</code> 虽然不接受参数但也有返回值）。</li>\n</ul>\n<p>2.1 节所述的实例方法也拥有这些性质，尽管两者在副作用方面大为不同。</p>\n<h4>1.1.6.4　递归</h4>\n<p>方法可以调用自己（如果你对<strong>递归</strong>概念感到奇怪，请完成练习 1.1.16 到练习 1.1.22）。例如，下面给出了 <code>BinarySearch</code> 的 <code>rank()</code> 方法的另一种实现。我们会经常使用递归，因为递归代码比相应的非递归代码更加简洁优雅、易懂。下面这种实现中的注释就言简意赅地说明了代码的作用。我们可以用数学归纳法证明这段注释所解释的算法的正确性。我们会在 3.1 节中展开这个话题并为二分查找提供一个这样的证明。</p>\n<p>编写递归代码时最重要的有以下三点。</p>\n<ul>\n<li>递归总有一个<strong>最简单的情况</strong>——方法的第一条语句总是一个包含<code>return</code> 的条件语句。</li>\n<li>递归调用总是去尝试解决一个<strong>规模更小</strong>的子问题，这样递归才能收敛到最简单的情况。在下面的代码中，第四个参数和第三个参数的差值一直在缩小。</li>\n<li>递归调用的父问题和尝试解决的子问题之间不应该有<strong>交集</strong>。在下面的代码中，两个子问题各自操作的数组部分是不同的。</li>\n</ul>\n<pre class=\"code-rows\"><code>public static int rank(int key, int[] a)\n{  return rank(key, a, 0, a.length - 1);  }\n\npublic static int rank(int key, int[] a, int lo, int hi)\n{  //如果key存在于a[]中，它的索引不会小于lo且不会大于hi\n\n   if (lo &gt; hi) return -1;\n   int mid = lo + (hi - lo) / 2;\n   if      (key &lt; a[mid]) return rank(key, a, lo, mid - 1);\n   else if (key &gt; a[mid]) return rank(key, a, mid + 1, hi);\n   else                   return mid;\n}</code></pre>\n<p style=\"text-align: center\"><strong>二分查找的递归实现</strong></p>\n<p>违背其中任意一条都可能得到错误的结果或是低效的代码（见练习 1.1.19 和练习 1.1.27），而坚持这些原则能写出清晰、正确且容易评估性能的程序。使用递归的另一个原因是我们可以使用数学模型来估计程序的性能。我们会在 3.2 节的二分查找以及其他几个地方分析这个问题。</p>\n<h4>1.1.6.5　基础编程模型</h4>\n<p><strong>静态方法库</strong>是定义在一个 Java 类中的一组静态方法。类的声明是<code>public class</code> 加上类名，以及用花括号包含的静态方法。存放类的文件的文件名和类名相同，扩展名是 .java。Java 开发的基本模式是编写一个静态方法库（包含一个 <code>main()</code> 方法）来完成一个任务。输入 java 和类名以及一系列字符串就能调用类中的 <code>main()</code> 方法，其参数为由输入的字符串组成的一个数组。<code>main()</code> 的最后一条语句执行完毕之后程序终止。在本书中，当我们提到用于执行一项任务的 Java <strong>程序</strong>时，我们指的是用这种模式开发的代码（可能还包括对数据类型的定义，如 1.2 节所示）。例如，BinarySearch 就是一个由两个静态方法 <code>rank()</code> 和 <code>main()</code> 组成的 Java 程序，它的作用是将输入中所有不在通过命令行指定的白名单中的数字打印出来。</p>\n<h4>1.1.6.6　模块化编程</h4>\n<p>这个模型的最重要之处在于通过静态方法库实现了模块化编程。我们可以构造许多个静态方法库（<strong>模块</strong>），一个库中的静态方法也能够调用另一个库中定义的静态方法。这能够带来许多好处：</p>\n<ul>\n<li>程序整体的代码量很大时，每次处理的模块大小仍然适中；</li>\n<li>可以共享和重用代码而无需重新实现；</li>\n<li>很容易用改进的实现替换老的实现；</li>\n<li>可以为解决编程问题建立合适的抽象模型；</li>\n<li>缩小调试范围（请见 1.1.6.7 节关于单元测试的讨论）。</li>\n</ul>\n<p>例如，BinarySearch 用到了三个独立的库，即我们的 StdOut 和 StdIn 以及 Java 的 Arrays，而这三个库又分别用到了其他的库。</p>\n<h4>1.1.6.7　单元测试</h4>\n<p>Java 编程的最佳实践之一就是每个静态方法库中都包含一个 <code>main()</code> 函数来测试库中的所有方法（有些编程语言不支持多个 <code>main()</code> 方法，因此不支持这种方式）。恰当的单元测试本身也是很有挑战性的编程任务。每个模块的<code>main()</code> 方法至少应该调用模块中的其他代码并在某种程度上保证它的正确性。随着模块的成熟，我们可以将 <code>main()</code> 方法作为一个<strong>开发用例</strong>，在开发过程中用它来测试更多的细节；也可以把它编成一个<strong>测试用例</strong>来对所有代码进行全面的测试。当用例越来越复杂时，我们可能会将它独立成一个模块。在本书中，我们用 <code>main()</code> 来说明模块的功能并将测试用例留做练习。</p>\n<h4>1.1.6.8　外部库</h4>\n<p>我们会使用来自 4 个不同类型的库中的静态方法，重用每种库代码的方式都稍有不同。它们大多都是静态方法库，但也有部分是数据类型的定义并包含了一些静态方法。</p>\n<ul>\n<li>系统标准库java.lang.*：这其中包括Math 库，实现了常用的数学函数；Integer 和Double 库，能够将字符串转化为 <code>int</code> 和 <code>double</code> 值；String 和 StringBuilder 库，我们稍后会在本节和第 5 章中详细讨论；以及其他一些我们没有用到的库。</li>\n<li>导入的系统库，例如 java.util.Arrays：每个标准的 Java 版本中都含有上千个这种类型的库，不过本书中我们用到的并不多。要在程序的开头使用 <code>import</code> 语句导入才能使用这些库（我们也是这样做的）。</li>\n<li>本书中的其他库：例如，其他程序也可以使用BinarySearch 的<code>rank()</code> 方法。要使用这些库，请在本书的网站上下载它们的源代码并放入你的工作目录中。</li>\n<li>我们为本书（以及我们的另一本入门教材 <em>An Introduction to Programming in Java: An Interdisciplinary Approach</em>）开发的标准库 Std*：我们会在下面简要地介绍这些库，它们的源代码和使用方法都能够在本书的网站上找到。</li>\n</ul>\n<p>要调用另一个库中的方法（存放在相同或者指定的目录中，或是一个系统标准库，或是在类定义前用<code>import</code> 语句导入的库），我们需要在方法前指定库的名称。例如，BinarySearch 的 <code>main()</code> 方法调用了系统库 java.util.Arrays 的 <code>sort()</code> 方法，我们的库 In 中的 <code>readInts()</code> 方法和 StdOut 库中的 <code>println()</code> 方法。</p>\n<p>我们自己及他人使用模块化方式编写的方法库能够极大地扩展我们的编程模型。除了在 Java 的标准版本中可用的所有库之外，网上还有成千上万各种用途的代码库。为了将我们的编程模型限制在一个可控范围之内，以将精力集中在算法上，我们只会使用以下所示的方法库，并在 1.1.7 节中列出了其中的部分方法。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00804.gif\" alt=\"\" width=\"43%\" style=\"width: 43%\" /></p>\n<p style=\"text-align: center\"><strong>本书使用的含有静态方法的库</strong></p>\n<h3 id=\"nav_point_18\">1.1.7　API</h3>\n<p>模块化编程的一个重要组成部分就是记录库方法的用法并供其他人参考的<strong>文档</strong>。我们会统一使用<strong>应用程序编程接口</strong>（API）的方式列出本书中使用的每个库方法名称、签名和简短的描述。我们用用例来指代调用另一个库中的方法的程序，用<strong>实现</strong>描述实现了某个 API 方法的 Java 代码。</p>\n<h4>1.1.7.1　举例</h4>\n<p>在表 1.1.6 的例子中，我们用 java.lang 中 Math 库常用的静态方法说明 API 的文档格式。</p>\n<p>这些方法实现了各种数学函数——它们通过参数计算得到某种类型的值（<code>random()</code> 除外，它没有对应的数学函数，因为它不接受参数）。它们的参数都是 <code>double</code> 类型且返回值也都是 <code>double</code> 类型，因此可以将它们看做 <code>double</code> 数据类型的扩展——这种扩展的能力正是现代编程语言的特性之一。API 中的每一行描述了一个方法，提供了使用该方法所需要知道的所有信息。Math 库也定义了常数<code>PI</code>（圆周率 π）和 <code>E</code>（自然对数 <code>e</code>），你可以在自己的程序中通过这些变量名引用它们。例如，<code>Math.sin(Math.PI/2)</code> 的结果是 <code>1.0</code>，<code>Math.log(Math.E)</code> 的结果也是 <code>1.0</code>（因为 <code>Math.sin()</code> 的参数是弧度而 <code>Math.log()</code> 使用的是自然对数函数）。</p>\n<p><strong>表 1.1.6　Java 的数学函数库的 API（节选）</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>Math</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double abs(double a)</code></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00805.gif\" /> 的绝对值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double max(double a, double b)</code></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00805.gif\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00806.gif\" /> 中的较大者</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double min(double a, double b)</code></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00805.gif\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00806.gif\" /> 中的较小者</td></tr>\n<tr><td colspan=\"2\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>注 1：<code>abs()</code>、<code>max()</code> 和 <code>min()</code> 也定义了 <code>int</code>、<code>long</code> 和 <code>float</code> 的版本。</b></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double sin(double theta)</code></td><td>正弦函数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double cos(double theta)</code></td><td>余弦函数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double tan(double theta)</code></td><td>正切函数</td></tr>\n<tr><td colspan=\"2\"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注 2：角用弧度表示，可以使用 <code>toDegrees()</code> 和 <code>toRadians()</code> 转换角度和弧度。</b></td></tr>\n<tr><td colspan=\"2\"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注 3：它们的反函数分别为 <code>asin()</code>、<code>acos()</code> 和 <code>atan()</code>。</b></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double exp(double a)</code></td><td>指数函数（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00807.gif\" />）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double log(double a)</code></td><td>自然对数函数（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00808.gif\" />，即 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00809.gif\" />）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double pow(double a, double b)</code></td><td>求 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00805.gif\" /> 的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00806.gif\" /> 次方（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00810.gif\" />）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double random()</code></td><td>[0, 1) 之间的随机数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double sqrt(double a)</code></td><td><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00805.gif\" /> 的平方根</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double E</code></td><td>常数 e（常数）</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double PI</code></td><td>常数 π（常数）</td></tr>\n</table>\n\n<p><sup>其他函数请见本书的网站。</sup></p>\n<h4>1.1.7.2　Java 库</h4>\n<p>成千上万个库的在线文档是 Java 发布版本的一部分。为了更好地描述我们的编程模型，我们只是从中节选了本书所用到的若干方法。例如，BinarySearch 中用到了 Java 的 Arrays 库中的 <code>sort()</code> 方法，我们对它的记录如表 1.1.7 所示。</p>\n<p><strong>表 1.1.7　Java 的 Arrays 库节选（java.util.Arrays）</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>Arrays</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void sort(int[] a)</code></td><td>将数组按升序排序</td></tr>\n</table>\n\n<p><sup>注：其他原始类型和 <code>Object</code> 对象也有对应版本的方法。</sup></p>\n<p>Arrays 库不在 java.lang 中，因此我们需要用 <code>import</code> 语句导入后才能使用它，与 BinarySearch 中一样。事实上，本书的第 2 章讲的正是数组的各种 <code>sort()</code> 方法的实现，包括 <code>Arrays.sort()</code> 中实现的归并排序和快速排序算法。Java 和很多其他编程语言都实现了本书讲解的许多基础算法。例如，Arrays 库还包含了二分查找的实现。为避免混淆，我们一般会使用自己的实现，但对于你已经掌握的算法使用高度优化的库实现当然也没有任何问题。</p>\n<h4>1.1.7.3　我们的标准库</h4>\n<p>为了介绍 Java 编程、为了科学计算以及算法的开发、学习和应用，我们也开发了若干库来提供一些实用的功能。这些库大多用于处理输入输出。我们也会使用以下两个库来测试和分析我们的实现。第一个库扩展了<code>Math.random()</code> 方法（见表 1.1.8），以根据不同的概率密度函数得到随机值；第二个库则支持各种统计计算（见表 1.1.9）。</p>\n<p><strong>表 1.1.8　我们的随机数静态方法库的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>StdRandom</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;void setSeed(long seed)</code></td><td>设置随机生成器的种子</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;double random()</code></td><td><code>0</code> 到 <code>1</code> 之间的实数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int uniform(int N)</code></td><td><code>0</code> 到 <code>N-1</code> 之间的整数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int uniform(int lo, int hi)</code></td><td><code>lo</code> 到 <code>hi-1</code> 之间的整数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;double uniform(double lo, double hi)</code></td><td><code>lo</code> 到 <code>hi</code> 之间的实数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;boolean bernoulli(double p)</code></td><td>返回真的概率为 <code>p</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;double gaussian()</code></td><td>正态分布，期望值为 <code>0</code>，标准差为 <code>1</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;double gaussian(double m, double s)</code></td><td>正态分布，期望值为 <code>m</code>，标准差为 <code>s</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int discrete(double[] a)</code></td><td>返回 <code>i</code> 的概率为 <code>a[i]</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;void shuffle(double[] a)</code></td><td>将数组 <code>a</code> 随机排序</td></tr>\n</table>\n\n<p><sup>注：库中也包含为其他原始类型和 <code>Object</code> 对象重载的 <code>shuffle()</code> 函数。</sup></p>\n<p><strong>表 1.1.9　我们的数据分析静态方法库的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>StdStats</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static double max(double[] a)</code></td><td>最大值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static double min(double[] a)</code></td><td>最小值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static double mean(double[] a)</code></td><td>平均值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static double var(double[] a)</code></td><td>采样方差</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static double stddev(double[] a)</code></td><td>采样标准差</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static double median(double[] a)</code></td><td>中位数</td></tr>\n</table>\n\n<p>StdRandom 的 <code>setSeed()</code> 方法为随机数生成器提供<strong>种子</strong>，这样我们就可以重复和随机数有关的实验。以上一些方法的实现请参考表 1.1.10。有些方法的实现非常简单，为什么还要在方法库中实现它们？设计良好的方法库对这个问题的标准回答如下。</p>\n<ul>\n<li>这些方法所实现的抽象层有助于我们将精力集中在实现和测试本书中的算法，而非生成随机数或是统计计算。每次都自己写完成相同计算的代码，不如直接在用例中调用它们要更简洁易懂。</li>\n<li>方法库会经过大量测试，覆盖极端和罕见的情况，是我们可以信任的。这样的实现需要大量的代码。例如，我们经常需要使用的各种数据类型的实现，又比如 Java 的 Arrays 库针对不同数据类型对 <code>sort()</code> 进行了多次重载。</li>\n</ul>\n<p>这些是 Java 模块化编程的基础，不过在这里可能有些夸张。但这些方法库的方法名称简单、实现容易，其中一些仍然能作为有趣的算法练习。因此，我们建议你到本书的网站上去学习一下 StdRandom.java 和 StdStats.java 的源代码并好好利用这些经过验证了的实现。使用这些库（以及检验它们）最简单的方法就是从网站上下载它们的源代码并放入你的工作目录。网站上讲解了在各种系统上使用它们的配置目录的方法。</p>\n<p><strong>表 1.1.10　StdRandom 库中的静态方法的实现</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>期望的结果</p></th>\n<th><p>实现</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>随机返回 <code>[a,b)</code> 之间的一个 <code>double</code> 值</p></td>\n<td><p></p><pre>public static double uniform(double a, double b)<br />{  return a + StdRandom.random() * (b-a);  }</pre></td>\n</tr>\n<tr>\n<td><p>随机返回 <code>[0..N)</code> 之间的一个 <code>int</code> 值</p></td>\n<td><p></p><pre>public static int uniform(int N)<br />{  return (int) (StdRandom.random() * N);  }</pre></td>\n</tr>\n<tr>\n<td><p>随机返回 <code>[lo,hi)</code> 之间的一个 <code>int</code> 值</p></td>\n<td><p></p><pre>public static int uniform(int lo, int hi)<br />{  return lo + StdRandom.uniform(hi - lo);  }</pre></td>\n</tr>\n<tr>\n<td><p>根据离散概率随机返回的 <code>int</code> 值（出现 <code>i</code> 的概率为 <code>a[i]</code>）</p></td>\n<td><p></p><pre>public static int discrete(double[] a)<br />{  // a[] 中各元素之和必须等于1<br />     double r = StdRandom.random();<br />     double sum = 0.0;<br />     for (int i = 0; i &lt; a.length; i++)<br />     {<br />        sum = sum + a[i];<br />        if (sum &gt;= r) return i;<br />     }<br />     return -1;<br />}</pre></td>\n</tr>\n<tr>\n<td><p>随机将 <code>double</code> 数组中的元素排序（请见练习 1.1.36）</p></td>\n<td><p></p><pre>public static void shuffle(double[] a)<br />{<br />   int N = a.length;<br />   for (int i = 0; i &lt; N; i++)<br />   {  // 将a[i] 和a[i..N-1] 中任意一个元素交换<br />      int r = i + StdRandom.uniform(N-i);<br />      double temp = a[i];<br />      a[i] = a[r];<br />      a[r] = temp;<br />   }<br />}</pre></td>\n</tr>\n</tbody>\n</table>\n<h4>1.1.7.4　你自己编写的库</h4>\n<p>你应该将自己编写的<strong>每一个</strong>程序都当做一个日后可以重用的库。</p>\n<ul>\n<li>编写用例，在实现中将计算过程分解成可控的部分。</li>\n<li>明确静态方法库和与之对应的 API（或者多个库的多个 API）。</li>\n<li>实现 API 和一个能够对方法进行独立测试的 <code>main()</code> 函数。</li>\n</ul>\n<p>这种方法不仅能帮助你实现可重用的代码，而且能够教会你如何运用模块化编程来解决一个复杂的问题。</p>\n<p>API 的<strong>目的</strong>是将调用和实现<strong>分离</strong>：除了API 中给出的信息，调用者不需要知道实现的其他细节，而实现也不应考虑特殊的应用场景。API 使我们能够广泛地重用那些为各种目的独立开发的代码。没有任何一个 Java 库能够包含我们在程序中可能用到的所有方法，因此这种能力对于编写复杂的应用程序特别重要。相应地，程序员也可以将 API 看做调用和实现之间的一份<strong>契约</strong>，它详细说明了每个方法的作用。实现的目标就是能够遵守这份契约。一般来说，做到这一点有很多种方法，而且将调用者的代码和实现的代码分离使我们可以将老算法替换为更新更好的实现。在学习算法的过程中，这也使我们能够感受到算法的改进所带来的影响。</p>\n<h3 id=\"nav_point_19\">1.1.8　字符串</h3>\n<p>字符串是由一串字符（char 类型的值）组成的。一个 <code>String</code> 类型的字面量包括一对双引号和其中的字符，比如 <code>\"Hello, World\"</code>。<code>String</code> 类型是 Java 的一个数据类型，但并<strong>不是</strong>原始数据类型。我们现在就讨论 <code>String</code> 类型是因为它非常基础，几乎所有 Java 程序都会用到它。</p>\n<h4>1.1.8.1　字符串拼接</h4>\n<p>和各种原始数据类型一样，Java 内置了一个串联<code>String</code> 类型字符串的运算符（<code>+</code>）。表 1.1.11 是对表 1.1.2 的补充。拼接两个 <code>String</code> 类型的字符串将得到一个新的 <code>String</code> 值，其中第一个字符串在前，第二个字符串在后。</p>\n<p><strong>表 1.1.11　Java 的 <code>String</code> 数据类型</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><th rowspan=\"2\">类型</th><th rowspan=\"2\">值域</th><th rowspan=\"2\">举例</th><th rowspan=\"2\">运算符</th><th colspan=\"2\">表达式举例</th></tr>\n<tr><th>表达式</th><th>值</th></tr>\n<tr><td><code><b>String</b></code></td><td>一串字符</td><td><pre>\"AB\"<br />\"Hello\"<br />\"2.5\"</pre></td><td><code>+</code>（拼接）</td><td><pre>\"Hi, \" + \"Bob\"<br />\"12\" + \"34\"<br />\"1\" + \"+\" + \"2\"</pre></td><td><pre>\"Hi, Bob\"<br />\"1234\"<br />\"1+2\"</pre></td></tr>\n</table>\n\n<h4>1.1.8.2　类型转换</h4>\n<p>字符串的两个主要用途分别是将用户从键盘输入的内容转换成相应数据类型的值以及将各种数据类型的值转化成能够在屏幕上显示的内容。Java 的 <code>String</code> 类型为这些操作内置了相应的方法，而且 Integer 和 Double 库还包含了分别和 <code>String</code> 类型相互转化的静态方法（见表 1.1.12）。</p>\n<p><strong>表 1.1.12　<code>String</code> 值和数字之间相互转换的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>Integer</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;parseInt(String s)</code></td><td>将字符串 <code>s</code> 转换为整数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static String&nbsp;&nbsp;toString(int i)</code></td><td>将整数 <code>i</code> 转换为字符串</td></tr>\n<tr><td colspan=\"2\"><code>public class <b>Double</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static double&nbsp;&nbsp;parseDouble(String s)</code></td><td>将字符串 <code>s</code> 转换为浮点数</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static String&nbsp;&nbsp;toString(double x)</code></td><td>将浮点数 <code>x</code> 转换为字符串</td></tr>\n</table>\n\n<h4>1.1.8.3　自动转换</h4>\n<p>我们很少明确使用刚才提到的 <code>toString()</code> 方法，因为 Java 在连接字符串的时候会自动将任意数据类型的值转换为字符串：如果加号（<code>+</code>）的一个参数是字符串，那么 Java 会<strong>自动</strong>将其他参数都转换为字符串（如果它们不是的话）。除了像 <code>\"The square root of 2.0 is \" + Math.sqrt(2.0)</code> 这样的使用方式之外，这种机制也使我们能够通过一个空字符串 <code>\"\"</code> 将任意数据类型的值转换为字符串值。</p>\n<h4>1.1.8.4　命令行参数</h4>\n<p>在 Java 中字符串的一个重要的用途就是使程序能够接收到从命令行传递来的信息。这种机制很简单。当你输入命令 java 和一个库名以及一系列字符串之后，Java 系统会调用库的 <code>main()</code> 方法并将那<strong>一系列字符串变成一个数组</strong>作为参数传递给它。例如，BinarySearch 的 <code>main()</code> 方法需要一个命令行参数，因此系统会创建一个大小为 1 的数组。程序用这个值，也就是 <code>args[0]</code>，来获取白名单文件的文件名并将其作为 <code>StdIn.readInts()</code> 的参数。另一种在我们的代码中常见的用法是当命令行参数表示的是数字时，我们会用 <code>parseInt()</code> 和 <code>parseDouble()</code> 方法将其分别转换为整数和浮点数。</p>\n<p><strong>字符串的用法</strong>是现代程序中的重要部分。现在我们还只是用 <code>String</code> 在外部表示为字符串的数字和内部表示为数字类数据类型的值进行转换。在 1.2 节中我们会看到 Java 为我们提供了非常丰富的字符串操作；在 1.4 节中我们会分析 <code>String</code> 类型在 Java 内部的表示方法；在第 5 章我们会深入学习处理字符串的各种算法。这些算法是本书中最有趣、最复杂也是影响力最大的一部分算法。</p>\n<h3 id=\"nav_point_20\">1.1.9　输入输出</h3>\n<p>我们的标准输入、输出和绘图库的作用是建立一个 Java 程序和外界交流的简易模型。这些库的基础是强大的 Java 标准库，但它们一般更加复杂，学习和使用起来都更加困难。我们先来简单地了解一下这个模型。</p>\n<p>在我们的模型中，Java 程序可以从<strong>命令行参数</strong>或者一个名为<strong>标准输入流</strong>的抽象字符流中获得输入，并将输出写入另一个名为<strong>标准输出流</strong>的字符流中。</p>\n<p>我们需要考虑 Java 和操作系统之间的接口，因此我们要简要地讨论一下大多数操作系统和程序开发环境所提供的相应机制。本书网站上列出了关于你所使用的系统的更多信息。默认情况下，命令行参数、标准输入和标准输出是和应用程序绑定的，而应用程序是由能够接受命令输入的操作系统或是开发环境所支持。我们笼统地用<strong>终端</strong>来指代这个应用程序提供的供输入和显示的窗口。20 世纪 70 年代早期的 Unix 系统已经证明我们可以用这个模型方便直接地和程序以及数据进行交互。我们在经典的模型中加入了一个<strong>标准绘图模块</strong>用来可视化表示对数据的分析，如图 1.1.3 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00811.gif\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.1.3　Java 程序整体结构</strong></p>\n<h4>1.1.9.1　命令和参数</h4>\n<p>终端窗口包含一个提示符，通过它我们能够向操作系统输入<strong>命令</strong>和<strong>参数</strong>。本书中我们只会用到几个命令，如表 1.1.13 所示。我们会经常使用 java 命令来运行我们的程序。我们在1.1.8.4 节中提到过，Java 类都会包含一个静态方法 <code>main()</code>，它有一个 <code>String</code> 数组类型的参数 <code>args[]</code>。这个数组的内容就是我们输入的命令行参数，操作系统会将它传递给 Java。Java 和操作系统都默认参数为字符串。如果我们需要的某个参数是数字，我们会使用类似<code>Integer.parseInt()</code> 的方法将其转换为适当的数据类型的值。图 1.1.4 是对命令的分析。</p>\n<p><strong>表 1.1.13　操作系统常用命令</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>命令</p></th>\n<th><p>参数</p></th>\n<th><p>作用</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>javac</code></p></td>\n<td><p>.java 文件名</p></td>\n<td><p>编译 Java 程序</p></td>\n</tr>\n<tr>\n<td><p><code>java</code></p></td>\n<td><p>.class 文件名（不需要扩展名）和命令行参数</p></td>\n<td><p>运行 Java 程序</p></td>\n</tr>\n<tr>\n<td><p><code>more</code></p></td>\n<td><p>任意文本文件名</p></td>\n<td><p>打印文件内容</p></td>\n</tr>\n</tbody>\n</table>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00812.gif\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.1.4　命令详解</strong></p>\n<h4>1.1.9.2　标准输出</h4>\n<p>我们的 StdOut 库的作用是支持标准输出。一般来说，系统会将标准输出打印到终端窗口。<code>print()</code> 方法会将它的参数放到标准输出中；<code>println()</code> 方法会附加一个换行符；<code>printf()</code> 方法能够格式化输出（见 1.1.9.3 节）。Java 在其 System.out 库中提供了类似的方法，但我们会用 StdOut 库来统一处理标准输入和输出（并进行了一些技术上的改进），见表1.1.14。</p>\n<p><strong>表 1.1.14　我们的标准输出库的静态方法的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>StdOut</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;void&nbsp;&nbsp;print(String s)</code></td><td>打印 <code>s</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;void&nbsp;&nbsp;println(String s)</code></td><td>打印 <code>s</code> 并接一个换行符</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;void&nbsp;&nbsp;println()</code></td><td>打印一个换行符</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;void&nbsp;&nbsp;printf(String f, ...)</code></td><td>格式化输出</td></tr>\n</table>\n\n<p><sup>注：其他原始类型和 <code>Object</code> 对象也有对应版本的方法。</sup></p>\n<p>要使用这些方法，请从本书的网站上将StdOut.java 下载到你的工作目录，并像<code>StdOut.println(\"Hello, World\");</code> 这样在代码中调用它们。左下方的程序就是一个例子。</p>\n<h4>1.1.9.3　格式化输出</h4>\n<pre class=\"code-rows\"><code>public class RandomSeq\n{\n   public static void main(String[] args)\n   {  // 打印N个(lo, hi)之间的随机值\n      int N = Integer.parseInt(args[0]);\n      double lo = Double.parseDouble(args[1]);\n      double hi = Double.parseDouble(args[2]);\n      for (int i = 0; i &lt; N; i++)\n      {\n         double x = StdRandom.uniform(lo, hi);\n         StdOut.printf(\"%.2f\\n\", x);\n      }\n   }\n}</code></pre>\n<p style=\"text-align: center\"><code>StdOut</code> 的用例示例</p>\n<pre class=\"code-rows\"><code>% java RandomSeq 5 100.0 200.0\n123.43\n153.13\n144.38\n155.18\n104.02</code></pre>\n<p>在最简单的情况下 <code>printf()</code> 方法接受两个参数。第一个参数是一个<strong>格式字符串</strong>，描述了第二个参数应该如何在输出中被转换为一个字符串。最简单的格式字符串的第一个字符是 <code>%</code> 并紧跟一个以字符表示的<strong>转换代码</strong>。我们最常使用的转换代码包括<code>d</code>（用于 Java 整型的十进制数）、<code>f</code>（浮点型）和 <code>s</code>（字符串）。在 <code>%</code> 和转换代码之间可以插入一个整数来表示转换之后的值的宽度，即输出字符串的长度。默认情况下，转换后会在字符串的左边添加空格以达到需要的<strong>宽度</strong>，如果我们想在右边加入空格则应该使用负宽度（如果转换得到的字符串比设定宽度要长，宽度会被忽略）。在宽度之后我们还可以插入一个小数点以及一个数值来指定转换后的 <code>double</code>值保留的小数位数（精度）或是 <code>String</code> 字符串所截取的长度。使用 <code>printf()</code> 方法时需要记住的最重要的一点就是，<strong>格式字符串中的转换代码和对应参数的数据类型必须匹配</strong>。也就是说，Java 要求参数的数据类型和转换代码表示的数据类型必须相同。<code>printf()</code> 的第一个 <code>String</code> 字符串参数也可以包含其他字符。所有非格式字符串的字符都会被传递到输出之中，而格式字符串则会被参数的值所替代（按照指定的方式转换为字符串）。例如，这条语句：</p>\n<pre class=\"code-rows\"><code>StdOut.printf(\"PI is approximately %.2f\\n\", Math.PI);</code></pre>\n<p>会打印出：</p>\n<pre class=\"code-rows\"><code>PI is approximately 3.14</code></pre>\n<p>可以看到，在 <code>printf()</code> 中我们需要明确地在第一个参数的末尾加上 <code>\\n</code> 来换行。<code>printf()</code> 函数能够接受两个或者更多的参数。在这种情况下，在格式化字符串中每个参数都会有对应的转换代码，这些代码之间可能隔着其他会被直接传递到输出中的字符。也可以直接使用静态方法 <code>String.format()</code> 来用和 <code>printf()</code> 相同的参数得到一个格式化字符串而无需打印它。我们可以用格式化打印方便地将实验数据输出为表格形式（这是它们在本书中的主要用途），如表 1.1.15 所示。</p>\n<p><strong>表 1.1.15　<code>printf()</code> 的格式化方式（更多选项请见本书网站）</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><th>数据类型</th><th>转换代码</th><th>举例</th><th>格式化字符串举例</th><th>转换后输出的字符串</th></tr>\n<tr><td><code><b>int</b></code></td><td><code>d</code></td><td><code>512</code></td><td><pre>\"%14d\"<br />\"%-14d\"</pre></td><td><pre>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;512\"<br />\"512&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"</pre></td></tr>\n<tr><td><code><b>double</b></code></td><td><code>f</code><br /><code>e</code></td><td><code>1595.1680010754388</code></td><td><pre>\"%14.2f\"<br />\"%.7f\"<br />\"%14.4e\"</pre></td><td><pre>\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1595.17\"<br />\"1595 . 1680011\"<br />\"&nbsp;&nbsp;&nbsp;&nbsp;1.5952e+03\"</pre></td></tr>\n<tr><td><code><b>String</b></code></td><td><code>s</code></td><td><code>\"Hello, World\"</code></td><td><pre>\"%14s\"<br />\"%-14s\"<br />\"%-14.5s\"</pre></td><td><pre>\"&nbsp;&nbsp;Hello, World\"<br />\"Hello, World&nbsp;&nbsp;\"<br />\"Hello&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"</pre></td></tr>\n</table>\n\n<h4>1.1.9.4　标准输入</h4>\n<pre class=\"code-rows\"><code>public class Average\n{\n    public static void main(String[] args)\n    {  // 取StdIn中所有数的平均值\n       double sum = 0.0;\n       int cnt = 0;\n       while (!StdIn.isEmpty())\n       {  // 读取一个数并计算累计之和\n          sum += StdIn.readDouble();\n          cnt++;\n       }\n       double avg = sum / cnt;\n       StdOut.printf(\"Average is %.5f\\n\", avg);\n    }\n}</code></pre>\n<p style=\"text-align: center\">StdIn 的用例举例</p>\n<pre class=\"code-rows\"><code>% java Average\n1.23456\n2.34567\n3.45678\n4.56789\n&lt;ctrl-d&gt;\nAverage is 2.90123</code></pre>\n<p>我们的 StdIn 库从标准输入流中获取数据，这些数据可能为空也可能是一系列由空白字符分隔的值（空格、制表符、换行符等）。默认状态下系统会将标准输出定向到终端窗口——你输入的内容就是输入流（由 <code>&lt;ctrl-d&gt;</code> 或 <code>&lt;ctrl-z&gt;</code> 结束，取决于你使用的终端应用程序）。这些值可能是 <code>String</code> 或是 Java 的某种原始类型的数据。标准输入流最重要的特点是这些值会在你的程序读取它们之后消失。只要程序读取了一个值，它就不能回退并再次读取它。这个特点产生了一些限制，但它反映了一些输入设备的物理特性并简化了对这些设备的抽象。有了输入流模型，这个库中的静态方法大都是自文档化的（它们的签名即说明了它们的用途）。右侧列出了 StdIn 的一个用例。</p>\n<p>表 1.1.16 详细说明了标准输入库中的静态方法的 API。</p>\n<p><strong>表 1.1.16　标准输入库中的静态方法的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>Public class <b>StdIn</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static boolean&nbsp;&nbsp;isEmpty()</code></td><td>如果输入流中没有剩余的值则返回 <code>true</code>，否则返回 <code>false</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;readInt()</code></td><td>读取一个 <code>int</code> 类型的值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;double&nbsp;&nbsp;readDouble()</code></td><td>读取一个 <code>double</code> 类型的值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;float&nbsp;&nbsp;readFloat()</code></td><td>读取一个 <code>float</code> 类型的值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;readLong()</code></td><td>读取一个 <code>long</code> 类型的值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static boolean&nbsp;&nbsp;readBoolean()</code></td><td>读取一个 <code>boolean</code> 类型的值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;readChar()</code></td><td>读取一个 <code>char</code> 类型的值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;byte&nbsp;&nbsp;readByte()</code></td><td>读取一个 <code>byte</code> 类型的值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;String&nbsp;&nbsp;readString()</code></td><td>读取一个 <code>String</code> 类型的值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static boolean&nbsp;&nbsp;hasNextLine()</code></td><td>输入流中是否还有下一行</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;String&nbsp;&nbsp;readLine()</code></td><td>读取该行的其余内容</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;String&nbsp;&nbsp;readAll()</code></td><td>读取输入流中的其余内容</td></tr>\n</table>\n\n<h4>1.1.9.5　重定向与管道</h4>\n<p>标准输入输出使我们能够利用许多操作系统都支持的命令行的扩展功能。只需要向启动程序的命令中加入一个简单的提示符，就可以将它的标准输出<strong>重定向</strong>至一个文件。文件的内容既可以永久保存也可以在之后作为另一个程序的输入：</p>\n<pre class=\"code-rows\"><code>% java RandomSeq 1000 100.0 200.0 &gt; data.txt</code></pre>\n<p>这条命令指明标准输出流不是被打印至终端窗口，而是被写入一个叫做 data.txt 的文件。每次调用<code>StdOut.print()</code> 或是 <code>StdOut.println()</code> 都会向该文件追加一段文本。在这个例子中，我们最后会得到一个含有 1000 个随机数的文件。终端窗口中不会出现任何输出：它们都被直接写入了“<code>&gt;</code>”号之后的文件中。这样我们就能将信息存储以备下次使用。请注意不需要改变 RandomSeq 的任何内容——它使用的是标准输出的抽象，因此它不会因为我们使用了该抽象的另一种不同的实现而受到影响。类似，我们可以重定向标准输入以使 StdIn 从文件而不是终端应用程序中读取数据：</p>\n<pre class=\"code-rows\"><code>% java Average &lt; data.txt</code></pre>\n<p>这条命令会从文件 data.txt 中读取一系列数值并计算它们的平均值。具体来说，“<code>&lt;</code>”号是一个提示符，它告诉操作系统读取文本文件 data.txt 作为输入流而不是在终端窗口中等待用户的输入。当程序调用 <code>StdIn.readDouble()</code> 时，操作系统读取的是文件中的值。将这些结合起来，将一个程序的输出重定向为另一个程序的输入叫做<strong>管道</strong>：</p>\n<pre class=\"code-rows\"><code>% java RandomSeq 1000 100.0 200.0 | java Average</code></pre>\n<p>这条命令将 RandomSeq 的标准输出和 Average 的标准输入指定为同一个流。它的效果是好像在 Average 运行时 RandomSeq 将它生成的数字输入了终端窗口。这种差别影响非常深远，因为它突破了我们能够处理的输入输出流的长度限制。例如，即使计算机没有足够的空间来存储十亿个数，我们仍然可以将例子中的 1000 换成 1 000 000 000 （当然我们还是需要一些时间来处理它们）。当 RandomSeq 调用 <code>StdOut.println()</code> 时，它就向输出流的末尾添加了一个字符串；当 Average 调用 <code>StdIn.readInt()</code> 时，它就从输入流的开头删除了一个字符串。这些动作发生的实际顺序取决于操作系统：它可能会先运行 RandomSeq 并产生一些输出，然后再运行 Average，来消耗这些输出，或者它也可以先运行 Average，直到它需要一些输入然后再运行 RandomSeq 来产生一些输出。虽然最后的结果都一样，但我们的程序就不再需要担心这些细节，因为它们只会和标准输入和标准输出的抽象打交道。</p>\n<p>图 1.1.5 总结了重定向与管道的过程。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00813.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.1.5　命令行的重定向与管道</strong></p>\n<h4>1.1.9.6　基于文件的输入输出</h4>\n<p>我们的 In 和 Out 库提供了一些静态方法，来实现向文件中写入或从文件中读取一个原始数据类型（或 <code>String</code> 类型）的数组的抽象。我们会使用 In 库中的 <code>readInts()</code>、<code>readDoubles()</code> 和 <code>readStrings()</code> 以及 Out 库中重载的多个 <code>write()</code> 方法，<code>name</code> 参数可以是文件或网页，如表 1.1.17 所示。例如，借此我们可以在同一个程序中分别使用文件和标准输入达到两种不同的目的，例如 BinarySearch。In 和 Out 两个库也实现了一些数据类型和它们的实例方法，这使我们能够将多个文件作为输入输出流并将网页作为输入流，我们还会在 1.2 节中再次考察它们。</p>\n<p><strong>表 1.1.17　我们用于读取和写入数组的静态方法的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>In</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;int[]&nbsp;&nbsp;readInts(String name)</code></td><td>读取多个 <code>int</code> 值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static double[]&nbsp;&nbsp;readDoubles(String name)</code></td><td>读取多个 <code>double</code> 值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static String[]&nbsp;&nbsp;readStrings(String name)</code></td><td>读取多个 <code>String</code> 值</td></tr>\n<tr><td colspan=\"2\"><code>public class <b>Out</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;write(int[] a, String name)</code></td><td>写入多个 <code>int</code> 值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;write(doule[] a, String name)</code></td><td>写入多个 <code>double</code> 值</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;write(String[] a, String name)</code></td><td>写入多个 <code>String</code> 值</td></tr>\n</table>\n\n<p><sup>注 1：库也支持其他原始数据类型。</sup></p>\n<p><sup>注 2：库也支持 <code>StdIn</code> 和 <code>StdOut</code>（忽略 name 参数）。</sup></p>\n<h4>1.1.9.7　标准绘图库（基本方法）</h4>\n<p>目前为止，我们的输入输出抽象层的重点只有文本字符串。现在我们要介绍一个产生图像输出的抽象层。这个库的使用非常简单并且允许我们利用可视化的方式处理比文字丰富得多的信息。和我们的标准输入输出一样，标准绘图抽象层实现在库 <code>StdDraw</code> 中，可以从本书的网站上下载 StdDraw.java 到你的工作目录来使用它。标准绘图库很简单：我们可以将它想象为一个抽象的能够在二维画布上画出点和直线的绘图设备。这个设备能够根据程序调用的 <code>StdDraw</code> 中的静态方法画出一些基本的几何图形，这些方法包括画出点、直线、文本字符串、圆、长方形和多边形等。和标准输入输出中的方法一样，这些方法几乎也都是自文档化的：<code>StdDraw.line()</code> 能够根据参数的坐标画出一条连接点 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00814.gif\" alt=\"(x_0,y_0)\" inline-img=\"true\" /> 和点 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00815.gif\" alt=\"(x_1,y_1)\" inline-img=\"true\" /> 的线段，<code>StdDraw.point()</code> 能够根据参数坐标画出一个以 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00816.gif\" alt=\"(x,y)\" inline-img=\"true\" /> 为中心的点，等等，如图 1.1.6 所示。几何图形可以被填充（默认为黑色）。默认的比例尺为单位正方形（所有的坐标均在 0 和 1 之间）。标准的实现会将画布显示为屏幕上的一个窗口，点和线为黑色，背景为白色。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00817.gif\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.1.6　<code>StdDraw</code> 的用法举例</strong></p>\n<p>表 1.1.18 是对标准绘图库中静态方法 API 的汇总。</p>\n<p><strong>表 1.1.18　标准绘图库的静态（绘图）方法的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td><code>public class <b>StdDraw</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;line(double x0, double y0, double x1, double y1)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;point(double x, double y)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;text(double x, double y, String s)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;circle(double x, double y, double r)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;filledCircle(double x, double y, double r)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;ellipse(double x, double y, double rw, double rh)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;filledEllipse(double x, double y, double rw, double rh)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;square(double x, double y, double r)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;filledSquare(double x, double y, double r)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;rectangle(double x, double y, double rw, double rh)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;filledRectangle(double x, double y, double rw, double rh)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;polygon(double[] x, double[] y)</code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;filledPolygon(double[] x, double[] y)</code></td></tr>\n</table>\n\n<h4>1.1.9.8　标准绘图库（控制方法）</h4>\n<p>标准绘图库中还包含一些方法来改变画布的大小和比例、直线的颜色和宽度、文本字体、绘图时间（用于动画）等。可以使用在 <code>StdDraw</code> 中预定义的<code>BLACK</code>、<code>BLUE</code>、<code>CYAN</code>、<code>DARK_GRAY</code>、<code>GRAY</code>、<code>GREEN</code>、<code>LIGHT_GRAY</code>、<code>MAGENTA</code>、<code>ORANGE</code>、<code>PINK</code>、<code>RED</code>、<code>BOOK_RED</code>、<code>WHITE</code> 和 <code>YELLOW</code> 等颜色常数作为 <code>setPenColor()</code> 方法的参数（可以用 <code>StdDraw.RED</code> 这样的方式调用它们）。画布窗口的菜单还包含一个选项用于将图像保存为适于在网上传播的文件格式。表 1.1.19 总结了 <code>StdDraw</code> 中静态控制方法的 API。</p>\n<p><strong>表 1.1.19　标准绘图库的静态（控制）方法的 API</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>StdDraw</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;setXscale(double x0, double x1)</code></td><td>将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00818.gif\" /> 的范围设为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00819.gif\" /></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;setYscale(double y0, double y1)</code></td><td>将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00820.gif\" /> 的范围设为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00821.gif\" /></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;setPenRadius(double r)</code></td><td>将画笔的粗细半径设为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00822.gif\" /></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;setPenColor(Color c)</code></td><td>将画笔的颜色设为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00823.gif\" /></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;setFont(Font f)</code></td><td>将文本字体设为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00824.gif\" /></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;setCanvasSize(int w, int h)</code></td><td>将画布窗口的宽和高分别设为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00825.gif\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00826.gif\" /></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;clear(Color c)</code></td><td>清空画布并用颜色 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00823.gif\" /> 将其填充</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;&nbsp;static void&nbsp;&nbsp;show(int dt)</code></td><td>显示所有图像并暂停 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00827.gif\" /> 毫秒</td></tr>\n</table>\n\n<p>在本书中，我们会在数据分析和算法的可视化中使用 <code>StdDraw</code>。表 1.1.20 是一些例子，我们在本书的其他章节和练习中还会遇到更多的例子。绘图库也支持<strong>动画</strong>——当然，这个话题只能在本书的网站上展开了。</p>\n<p><strong>表 1.1.20　<code>StdDraw</code> 绘图举例</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>数据</p></th>\n<th><p>绘图的实现（代码片段）</p></th>\n<th><p>结果</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>函数值</p></td>\n<td><p></p><pre>int N = 100;<br />StdDraw.setXscale(0, N);<br />StdDraw.setYscale(0, N*N);<br />StdDraw.setPenRadius(.01);<br />for (int i = 1; i &lt;= N; i++)<br />{<br />   StdDraw.point(i, i);<br />   StdDraw.point(i, i*i);<br />   StdDraw.point(i, i*Math.log(i));<br />}</pre></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00828.gif\" alt=\"{%}\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p>随机数组</p></td>\n<td><p></p><pre>int N = 50;<br />double[] a = new double[N];<br />for (int i = 0; i &lt; N; i++)<br />   a[i] = StdRandom.random();<br />for (int i = 0; i &lt; N; i++)<br />{<br />   double x = 1.0*i/N;<br />   double y = a[i]/2.0;<br />   double rw = 0.5/N;<br />   double rh = a[i]/2.0;<br />   StdDraw.filledRectangle(x, y, rw, rh);<br />}</pre></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00829.gif\" alt=\"{%}\" inline-img=\"true\" /></p></td>\n</tr>\n<tr>\n<td><p>已排序的随机数组</p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00830.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" inline-img=\"true\" /></p></td>\n<td><p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00831.gif\" alt=\"{%}\" inline-img=\"true\" /></p></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nav_point_21\">1.1.10　二分查找</h3>\n<p>我们要学习的第一个 Java 程序的示例程序就是著名、高效并且应用广泛的<strong>二分查找</strong>算法，如下所示。这个例子将会展示本书中学习新算法的基本方法。和我们将要学习的所有程序一样，它既是算法的准确定义，又是算法的一个完整的 Java 实现，而且你还能够从本书的网站上下载它。</p>\n<blockquote>\n<p><strong>二分查找</strong></p>\n<pre class=\"code-rows\"><code>import java.util.Arrays;\npublic class BinarySearch\n{\n   public static int rank(int key, int[] a)\n   {  // 数组必须是有序的\n      int lo  = 0;\n      int hi = a.length - 1;\n      while (lo &lt;= hi)\n      {  // 被查找的键要么不存在，要么必然存在于a[lo..hi] 之中\n         int mid = lo + (hi - lo) / 2;\n         if      (key &lt; a[mid]) hi = mid - 1;\n         else if (key &gt; a[mid]) lo = mid + 1;\n         else                   return mid;\n      }\n      return -1;\n   }\n   public static void main(String[] args)\n   {\n      int[] whitelist = In.readInts(args[0]);\n      Arrays.sort(whitelist);\n      while (!StdIn.isEmpty())\n      {  // 读取键值，如果不存在于白名单中则将其打印\n         int key = StdIn.readInt();\n         if (rank(key, whitelist) &lt; 0)\n            StdOut.println(key);\n      }\n   }\n}</code></pre>\n<p>这段程序接受一个白名单文件（一列整数）作为参数，并会过滤掉标准输入中的所有存在于白名单中的条目，仅将不在白名单上的整数打印到标准输出中。它在<code>rank()</code> 静态方法中实现了二分查找算法并高效地完成了这个任务。关于二分查找算法的完整讨论，包括它的正确性、性能分析及其应用，请见 3.1 节。</p>\n<pre class=\"code-rows\"><code>% java BinarySearch tinyW.txt &lt; tinyT.txt\n50\n99\n13</code></pre>\n</blockquote>\n<h4>1.1.10.1　二分查找</h4>\n<p>我们会在 3.2 节中详细学习二分查找算法，但此处先简单地描述一下。算法是由静态方法 <code>rank()</code> 实现的，它接受一个整数键和一个已经有序的<code>int</code> 数组作为参数。如果该键存在于数组中则返回它的索引，否则返回 <code>-1</code>。算法使用两个变量 <code>lo</code> 和 <code>hi</code>，并保证如果键在数组中则它一定在 <code>a[lo..hi]</code> 中，然后方法进入一个循环，不断将数组的中间键（索引为<code>mid</code>）和被查找的键比较。如果被查找的键等于 <code>a[mid]</code>，返回 <code>mid</code>；否则算法就将查找范围缩小一半，如果被查找的键小于 <code>a[mid]</code> 就继续在左半边查找，如果被查找的键大于 <code>a[mid]</code> 就继续在右半边查找。算法找到被查找的键或是查找范围为空时该过程结束。二分查找之所以快是因为它只需检查很少几个条目（相对于数组的大小）就能够找到目标元素（或者确认目标元素不存在）。在有序数组中进行二分查找的示例如图 1.1.7 所示。</p>\n<h4>1.1.10.2　开发用例</h4>\n<p>对于每个算法的实现，我们都会开发一个用例 <code>main()</code> 函数，并在书中或是本书的网站上提供一个示例输入文件来帮助读者学习该算法并检测它的性能。在这个例子中，这个用例会从命令行指定的文件中读取多个整数，并会打印出标准输入中所有不存在于该文件中的整数。我们使用了图 1.1.8 所示的几个较小的测试文件来展示它的行为，这些文件也是图 1.1.7 中的跟踪和例子的基础。我们会使用较大的测试文件来模拟真实应用并测试算法的性能（请见 1.1.10.3 节）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00832.gif\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.1.7　有序数组中的二分查找</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00833.gif\" alt=\"\" width=\"45%\" style=\"width: 45%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.1.8　为 BinarySearch 的测试用例准备的小型测试文件</strong></p>\n<h4>1.1.10.3　白名单过滤</h4>\n<p>如果可能，我们的测试用例都会通过模拟实际情况来展示当前算法的必要性。这里该过程被称为<strong>白名单过滤</strong>。具体来说，可以想象一家信用卡公司，它需要检查客户的交易账号是否有效。为此，它需要：</p>\n<ul>\n<li>将客户的账号保存在一个文件中，我们称它为<strong>白名单</strong>；</li>\n<li>从标准输入中得到每笔交易的账号；</li>\n<li>使用这个测试用例在标准输出中打印所有与任何客户无关的账号，公司很可能拒绝此类交易。</li>\n</ul>\n<p>在一家有上百万客户的大公司中，需要处理数百万甚至更多的交易都是很正常的。为了模拟这种情况，我们在本书的网站上提供了文件largeW.txt（100 万个整数）和largeT.txt（1000 万个整数）其基本情况如图 1.1.9 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00834.gif\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 1.1.9　为 BinarySearch 测试用例准备的大型文件</strong></p>\n<h4>1.1.10.4　性能</h4>\n<p>一个程序只是可用往往是不够的。例如，以下 <code>rank()</code> 的实现也可以很简单，它会检查数组的每个元素，甚至都不需要数组是有序的：</p>\n<pre class=\"code-rows\"><code>public static int rank(int key, int[] a)\n{\n   for (int i = 0; i &lt; a.length; i++)\n      if (a[i] == key) return i;\n   return -1;\n}</code></pre>\n<p>有了这个简单易懂的解决方案，我们为什么还需要归并排序和二分查找呢？你在完成练习 1.1.38 时会看到，计算机用 <code>rank()</code> 方法的暴力实现处理大量输入（比如含有 100 万个条目的白名单和 1000 万条交易）非常慢。<strong>没有如二分查找或者归并排序这样的高效算法，解决大规模的白名单问题是不可能的</strong>。良好的性能常常是极为重要的，因此我们会在 1.4 节中为性能研究做一些铺垫，并会分析我们学习的所有算法的性能特点（包括 2.2 节的归并排序和 3.1 节中的二分查找）。</p>\n<p>目前，我们在这里粗略地勾勒出我们的编程模型的目标是，确保你能够在计算机上运行类似于 BinarySearch 的代码，使用它处理我们的测试数据并为适应各种情况修改它（比如本节练习中所描述的一些情况）以完全理解它的可应用性。我们的编程模型就是设计用来简化这些活动的，这对各种算法的学习至关重要。</p>\n<h3 id=\"nav_point_22\">1.1.11　展望</h3>\n<p>在本节中，我们描述了一个精巧而完整的编程模型，数十年来它一直在（并且现在仍在）为广大程序员服务。但现代编程技术已经更进一步。前进的这一步被称为<strong>数据抽象</strong>，有时也被称为<strong>面向对象编程</strong>，它是我们下一节的主题。简单地说，数据抽象的主要思想是鼓励程序定义自己的<strong>数据类型</strong>（一系列值和对这些值的操作），而不仅仅是那些操作预定义的数据类型的静态方法。</p>\n<p>面向对象编程在最近几十年得到了广泛的应用，数据抽象已经成为现代程序开发的核心。我们在本书中“拥抱”数据抽象的原因主要有三。</p>\n<ul>\n<li>它允许我们通过模块化编程复用代码。例如，第 2 章中的排序算法和第 3 章中的二分查找以及其他算法，都允许调用者用同一段代码处理任意类型的数据（而不仅限于整数），包括调用者自定义的数据类型。</li>\n<li>它使我们可以轻易构造多种所谓的<strong>链式</strong>数据结构，它们比数组更灵活，在许多情况下都是高效算法的基础。</li>\n<li>借助它我们可以准确地定义所面对的算法问题。比如 1.5 节中的 union-find 算法、2.4 节中的优先队列算法和第 3 章中的符号表算法，它们解决问题的方式都是定义数据结构并高效地实现它们的一组操作。这些问题都能够用数据抽象很好地解决。</li>\n</ul>\n<p>尽管如此，但我们的重点仍然是对算法的研究。在了解了这些知识以后，我们将学习面向对象编程中和我们的使命相关的另一个重要特性。</p>\n<h3 id=\"nav_point_23\">答疑</h3>\n<p><strong>问</strong>　什么是 Java 的字节码？</p>\n<p><strong>答</strong>　它是程序的一种低级表示，可以运行于 Java 的<strong>虚拟机</strong>。将程序抽象为字节码可以保证 Java 程序员的代码能够运行在各种设备之上。</p>\n<p><strong>问</strong>　 Java 允许整型溢出并返回错误值的做法是错误的。难道 Java 不应该自动检查溢出吗？</p>\n<p><strong>答</strong>　这个问题在程序员中一直是有争议的。简单的回答是它们之所以被称为<strong>原始</strong>数据类型就是因为缺乏此类检查。避免此类问题并不需要很高深的知识。我们会使用 <code>int</code> 类型表示较小的数（小于 10 个十进制位）而使用 <code>long</code> 表示 10 亿以上的数。</p>\n<p><strong>问</strong>　<code>Math.abs(-2147483648)</code> 的返回值是什么？</p>\n<p><strong>答</strong>　<code>-2147483648</code>。这个奇怪的结果（但的确是真的）就是整数溢出的典型例子。</p>\n<p><strong>问</strong>　如何才能将一个 <code>double</code> 变量初始化为无穷大？</p>\n<p><strong>答</strong>　可以使用 Java 的内置常数：<code>Double.POSITIVE_INFINITY</code> 和 <code>Double.NEGATIVE_INFINITY</code>。</p>\n<p><strong>问</strong>　能够将 <code>double</code> 类型的值和 <code>int</code> 类型的值相互比较吗？</p>\n<p><strong>答</strong>　不通过类型转换是不行的，但请记住 Java 一般会自动进行所需的类型转换。例如，如果 <code>x</code> 的类型是 <code>int</code> 且值为<code>3</code>，那么表达式<code>(x&lt;3.1)</code> 的值为<code>true</code>——Java 会在比较前将<code>x</code> 转换为<code>double</code> 类型（因为<code>3.1</code>是一个 <code>double</code> 类型的字面量）。</p>\n<p><strong>问</strong>　如果使用一个变量前没有将它初始化，会发生什么？</p>\n<p><strong>答</strong>　如果代码中存在任何可能导致使用未经初始化的变量的执行路径，Java 都会抛出一个编译异常。</p>\n<p><strong>问</strong>　Java 表达式 <code>1/0</code> 和 <code>1.0/0.0</code> 的值是什么？</p>\n<p><strong>答</strong>　第一个表达式会产生一个运行时除以零<strong>异常</strong>（它会终止程序，因为这个值是未定义的）；第二个表达式的值是<code>Infinity</code>（无穷大）。</p>\n<p><strong>问</strong>　能够使用 <code>&lt;</code> 和 <code>&gt;</code> 比较 <code>String</code> 变量吗？</p>\n<p><strong>答</strong>　不行，只有原始数据类型定义了这些运算符。请见 1.1.2.3 节。</p>\n<p><strong>问</strong>　负数的除法和余数的结果是什么？</p>\n<p><strong>答</strong>　表达式 <code>a/b</code> 的商会向 <code>0</code> 取整；<code>a % b</code> 的余数的定义是 <code>(a/b)*b + a % b</code> 恒等于 <code>a</code>。例如 <code>-14/3</code> 和 <code>14/-3</code> 的商都是 <code>-4</code>，但 <code>-14 % 3</code> 是 <code>-2</code>，而 <code>14 % -3</code> 是 <code>2</code>。</p>\n<p><strong>问</strong>　为什么使用 <code>(a &amp;&amp; b)</code> 而非 <code>(a &amp; b)</code> ？</p>\n<p><strong>答</strong>　运算符 <code>&amp;</code>、<code>|</code> 和 <code>^</code> 分别表示整数的<strong>位</strong>逻辑操作<strong>与</strong>、<strong>或</strong>和<strong>异或</strong>。因此，<code>10|6</code> 的值为 <code>14</code>，<code>10^6</code> 的值为 <code>12</code>。在本书中我们很少（偶尔）会用到这些运算符。<code>&amp;&amp;</code> 和 <code>||</code> 运算符仅在独立的布尔表达式中有效，原因是<strong>短路</strong>求值法则：表达式从左向右求值，一旦整个表达式的值已知则停止求值。</p>\n<p><strong>问</strong>　嵌套 <code>if</code> 语句中的二义性有问题吗？</p>\n<p><strong>答</strong>　是的。在 Java 中，以下语句：</p>\n<pre class=\"code-rows\"><code>if &lt;expr1&gt; if &lt;expr2&gt; &lt;stmntA&gt; else &lt;stmntB&gt;</code></pre>\n<p>　等价于：</p>\n<pre class=\"code-rows\"><code>if &lt;expr1&gt; { if &lt;expr2&gt; &lt;stmntA&gt; else &lt;stmntB&gt; }</code></pre>\n<p>　即使你想表达的是：</p>\n<pre class=\"code-rows\"><code>if &lt;expr1&gt; { if &lt;expr2&gt; &lt;stmntA&gt; } else &lt;stmntB&gt;</code></pre>\n<p>　避免这种“无主的”<code>else</code> 陷阱的最好办法是显式地写明所有大括号。</p>\n<p><strong>问</strong>　一个 <code>for</code> 循环和它的 <code>while</code> 形式有什么区别？</p>\n<p><strong>答</strong>　<code>for</code> 循环头部的代码和 <code>for</code> 循环的主体代码在同一个代码段之中。在一个典型的 <code>for</code> 循环中，递增变量一般在循环结束之后都是不可用的；但在和它等价的 <code>while</code> 循环中，递增变量在循环结束之后仍然是可用的。这个区别常常是使用 <code>while</code> 而非 <code>for</code> 循环的主要原因。</p>\n<p><strong>问</strong>　有些 Java 程序员用 <code>int a[]</code> 而不是 <code>int[] a</code> 来声明一个数组。这两者有什么不同？</p>\n<p><strong>答</strong>　在 Java 中，两者等价且都是合法的。前一种是C 语言中数组的声明方式。后者是 Java 提倡的方式，因为变量的类型 <code>int[]</code> 能更清楚地说明这是一个整型的<strong>数组</strong>。</p>\n<p><strong>问</strong>　为什么数组的起始索引是 <code>0</code> 而不是 <code>1</code> ？</p>\n<p><strong>答</strong>　这个习惯来源于机器语言，那时要计算一个数组元素的地址需要将数组的起始地址加上该元素的索引。将起始索引设为 <code>1</code> 要么会浪费数组的第一个元素的空间，要么会花费额外的时间来将索引减 <code>1</code>。</p>\n<p><strong>问</strong>　如果 <code>a[]</code> 是一个数组，为什么 <code>StdOut.println(a)</code> 打印出的是一个十六进制的整数，比如 <code>@f62373</code>，而不是数组中的元素呢？</p>\n<p><strong>答</strong>　问得好。该方法打印出的是这个数组的地址，不幸的是你一般都不需要它。</p>\n<p><strong>问</strong>　我们为什么不使用标准的 Java 库来处理输入和图形？</p>\n<p><strong>答</strong>　我们<strong>的确</strong>用到了它们，但我们希望使用更简单的抽象模型。<code>StdIn</code> 和 <code>StdDraw</code> 背后的 Java 标准库是为实际生产设计的，这些库和它们的 API 都有些笨重。要想知道它们真正的模样，请查看 StdIn.java 和 StdDraw.java 的代码。</p>\n<p><strong>问</strong>　我的程序能够重新读取标准输入中的值吗？</p>\n<p><strong>答</strong>　不行，你只有一次机会，就好像你不能撤销 <code>println()</code> 的结果一样。</p>\n<p><strong>问</strong>　如果我的程序在标准输入为空之后仍然尝试读取，会发生什么？</p>\n<p><strong>答</strong>　会得到一个错误。<code>StdIn.isEmpty()</code> 能够帮助你检查是否还有可用的输入以避免这种错误。</p>\n<p><strong>问</strong>　这条出错信息是什么意思？</p>\n<pre class=\"code-rows\"><code>Exception in thread \"main\" java.lang.NoClassDefFoundError: StdIn</code></pre>\n<p><strong>答</strong>　你可能忘记把 StdIn.java 文件放到工作目录中去了。</p>\n<p><strong>问</strong>　在 Java 中，一个静态方法能够将另一个静态方法作为参数吗？</p>\n<p><strong>答</strong>　不行，但问得好，因为有很多语言都能够这么做。</p>\n<h3 id=\"nav_point_24\">练习</h3>\n<p><strong>1.1.1</strong>　给出以下表达式的值：</p>\n<p>　a. <code>( 0 + 15 ) / 2</code></p>\n<p>　b. <code>2.0e-6 * 100000000.1</code></p>\n<p>　c. <code>true &amp;&amp; false || true &amp;&amp; true</code></p>\n<p><strong>1.1.2</strong>　给出以下表达式的类型和值：</p>\n<p>　a. <code>(1 + 2.236)/2</code></p>\n<p>　b. <code>1 + 2 + 3 + 4.0</code></p>\n<p>　c. <code>4.1 &gt;= 4</code></p>\n<p>　d. <code>1 + 2 + \"3\"</code></p>\n<p><strong>1.1.3</strong>　编写一个程序，从命令行得到三个整数参数。如果它们都相等则打印 <code>equal</code>，否则打印 <code>not equal</code>。</p>\n<p><strong>1.1.4</strong>　下列语句各有什么问题（如果有的话）？</p>\n<p>　a. <code>if (a &gt; b) then c = 0;</code></p>\n<p>　b. <code>if a &gt; b { c = 0; }</code></p>\n<p>　c. <code>if (a &gt; b) c = 0;</code></p>\n<p>　d. <code>if (a &gt; b) c = 0 else b = 0;</code></p>\n<p><strong>1.1.5</strong>　编写一段程序，如果 <code>double</code> 类型的变量 <code>x</code> 和 <code>y</code> 都严格位于 <code>0</code> 和 <code>1</code> 之间则打印 <code>true</code>，否则打印 <code>false</code>。</p>\n<p><strong>1.1.6</strong>　下面这段程序会打印出什么？</p>\n<pre class=\"code-rows\"><code>int f = 0;\nint g = 1;\nfor (int i = 0; i &lt;= 15; i++)\n{\n   StdOut.println(f);\n   f = f + g;\n   g = f - g;\n}</code></pre>\n<p><strong>1.1.7</strong>　分别给出以下代码段打印出的值：</p>\n<p>　a.</p>\n<pre class=\"code-rows\"><code>double t = 9.0;\nwhile (Math.abs(t - 9.0/t) &gt; .001)\n   t = (9.0/t + t) / 2.0;\nStdOut.printf(\"%.5f\\n\", t);</code></pre>\n<p>　b.</p>\n<pre class=\"code-rows\"><code>int sum = 0;\nfor (int i = 1; i &lt; 1000; i++)\n   for (int j = 0; j &lt; i; j++)\n       sum++;\nStdOut.println(sum);</code></pre>\n<p>　c.</p>\n<pre class=\"code-rows\"><code>int sum = 0;\nfor (int i = 1; i &lt; 1000; i *= 2)\n   for (int j = 0; j &lt; 1000; j++)\n       sum++;\nStdOut.println(sum);</code></pre>\n<p><strong>1.1.8</strong>　下列语句会打印出什么结果？给出解释。</p>\n<p>　a. <code>System.out.println('b');</code></p>\n<p>　b. <code>System.out.println('b' + 'c');</code></p>\n<p>　c. <code>System.out.println((char) ('a' + 4));</code></p>\n<p><strong>1.1.9</strong>　编写一段代码，将一个正整数 N 用二进制表示并转换为一个 <code>String</code> 类型的值 <code>s</code>。</p>\n<p>　<strong>解答</strong>：Java 有一个内置方法 <code>Integer.toBinaryString(N)</code> 专门完成这个任务，但该题的目的就是给出这个方法的其他实现方法。下面就是一个特别简洁的答案：</p>\n<pre class=\"code-rows\"><code>String s = \"\";\nfor (int n = N; n &gt; 0; n /= 2)\n   s = (n % 2) + s;</code></pre>\n<p><strong>1.1.10</strong>　下面这段代码有什么问题？</p>\n<pre class=\"code-rows\"><code>int[] a;\nfor (int i = 0; i &lt; 10; i++)\n   a[i] = i * i;</code></pre>\n<p>　<strong>解答</strong>：它没有用 <code>new</code> 为 <code>a[]</code> 分配内存。这段代码会产生一个 <code>variable a might not have been initialized</code> 的编译错误。</p>\n<p><strong>1.1.11</strong>　编写一段代码，打印出一个二维布尔数组的内容。其中，使用 <code>*</code> 表示真，空格表示假。打印出行号和列号。</p>\n<p><strong>1.1.12</strong>　以下代码段会打印出什么结果？</p>\n<pre class=\"code-rows\"><code>int[] a = new int[10];\nfor (int i = 0; i &lt; 10; i++)\n   a[i] = 9 - i;\nfor (int i = 0; i &lt; 10; i++)\n   a[i] = a[a[i]];\nfor (int i = 0; i &lt; 10; i++)\n   System.out.println(a[i]);</code></pre>\n<p><strong>1.1.13</strong>　编写一段代码，打印出一个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 行 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 列的二维数组的<strong>转置</strong>（交换行和列）。</p>\n<p><strong>1.1.14</strong>　编写一个静态方法<code>lg()</code>，接受一个整型参数 N，返回不大于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00835.gif\" alt=\"\\log_2N\" inline-img=\"true\" /> 的最大整数。<strong>不要</strong>使用 Math 库。</p>\n<p><strong>1.1.15</strong>　编写一个静态方法 <code>histogram()</code>，接受一个整型数组 <code>a[]</code> 和一个整数 <code>M</code> 为参数并返回一个大小为<code>M</code> 的数组，其中第<code>i</code> 个元素的值为整数<code>i</code> 在参数数组中出现的次数。如果<code>a[]</code> 中的值均在<code>0</code> 到<code>M-1</code> 之间，返回数组中所有元素之和应该和 <code>a.length</code> 相等。</p>\n<p><strong>1.1.16</strong>　给出 <code>exR1(6)</code> 的返回值：</p>\n<pre class=\"code-rows\"><code>public static String exR1(int n)\n{\n   if (n &lt;= 0) return \"\";\n   return exR1(n-3) + n + exR1(n-2) + n;\n}</code></pre>\n<p><strong>1.1.17</strong>　找出以下递归函数的问题：</p>\n<pre class=\"code-rows\"><code>public static String exR2(int n)\n{\n   String s = exR2(n-3) + n + exR2(n-2) + n;\n   if (n &lt;= 0) return \"\";\n   return s;\n}</code></pre>\n<p>　<strong>答</strong>：这段代码中的基础情况永远不会被访问。调用 <code>exR2(3)</code> 会产生调用 <code>exR2(0)</code>、<code>exR2(-3)</code> 和 <code>exR2(-6)</code>，循环往复直到发生 <code>StackOverflowError</code>。</p>\n<p><strong>1.1.18</strong>　请看以下递归函数：</p>\n<pre class=\"code-rows\"><code>public static int mystery(int a, int b)\n{\n   if (b == 0)     return 0;\n   if (b % 2 == 0) return mystery(a+a, b/2);\n   return mystery(a+a, b/2) + a;\n}</code></pre>\n<p>　<code>mystery(2, 25)</code> 和 <code>mystery(3, 11)</code> 的返回值是多少？给定正整数 <code>a</code> 和 <code>b</code>，<code>mystery(a,b)</code> 计算的结果是什么？将代码中的 <code>+</code> 替换为 <code>*</code> 并将 <code>return 0</code> 改为 <code>return 1</code>，然后回答相同的问题。</p>\n<p><strong>1.1.19</strong>　在计算机上运行以下程序：</p>\n<pre class=\"code-rows\"><code>public class Fibonacci\n{\n   public static long F(int N)\n   {\n      if (N == 0) return 0;\n      if (N == 1) return 1;\n      return F(N-1) + F(N-2);\n   }\n   public static void main(String[] args)\n   {\n      for (int N = 0; N &lt; 100; N++)\n         StdOut.println(N + \" \" + F(N));\n   }\n}</code></pre>\n<p>　计算机用这段程序在一个小时之内能够得到 <code>F(N)</code> 结果的最大 <code>N</code> 值是多少？开发 <code>F(N)</code> 的一个更好的实现，用数组保存已经计算过的值。</p>\n<p><strong>1.1.20</strong>　编写一个递归的静态方法计算 <code>ln</code> <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00836.gif\" alt=\"(N!)\" inline-img=\"true\" /> 的值。</p>\n<p><strong>1.1.21</strong>　编写一段程序，从标准输入按行读取数据，其中每行都包含一个名字和两个整数。然后用 <code>printf()</code> 打印一张表格，每行的若干列数据包括名字、两个整数和第一个整数除以第二个整数的结果，精确到小数点后三位。可以用这种程序将棒球球手的击球命中率或者学生的考试分数制成表格。</p>\n<p><strong>1.1.22</strong>　使用 1.1.6.4 节中的 <code>rank()</code> 递归方法重新实现 <code>BinarySearch</code> 并跟踪该方法的调用。每当该方法被调用时，打印出它的参数 <code>lo</code> 和 <code>hi</code> 并按照递归的深度缩进。<strong>提示</strong>：为递归方法添加一个参数来保存递归的深度。</p>\n<p><strong>1.1.23</strong>　为<code>BinarySearch</code> 的测试用例添加一个参数：<code>+</code> 打印出标准输入中<strong>不</strong>在白名单上的值；<code>-</code>，则打印出标准输入中<strong>在</strong>白名单上的值。</p>\n<p><strong>1.1.24</strong>　给出使用欧几里得算法计算 105 和 24 的最大公约数的过程中得到的一系列 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00837.gif\" alt=\"p\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00838.gif\" alt=\"q\" inline-img=\"true\" /> 的值。扩展该算法中的代码得到一个程序 Euclid，从命令行接受两个参数，计算它们的最大公约数并打印出每次调用递归方法时的两个参数。使用你的程序计算 1 111 111 和 1 234 567 的最大公约数。</p>\n<p><strong>1.1.25</strong>　使用数学归纳法证明欧几里得算法能够计算任意一对非负整数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00837.gif\" alt=\"p\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00838.gif\" alt=\"q\" inline-img=\"true\" /> 的最大公约数。</p>\n<h3 id=\"nav_point_25\">提高题</h3>\n<p><strong>1.1.26</strong>　将<strong>三个数字排序</strong>。假设 <code>a</code>、<code>b</code>、<code>c</code> 和<code>t</code> 都是同一种原始数字类型的变量。证明以下代码能够将 <code>a</code>、<code>b</code>、<code>c</code> 按照升序排列：</p>\n<pre class=\"code-rows\"><code>if (a &gt; b) { t = a; a = b; b = t; }\nif (a &gt; c) { t = a; a = c; c = t; }\nif (b &gt; c) { t = b; b = c; c = t; }</code></pre>\n<p><strong>1.1.27</strong>　<strong>二项分布</strong>。估计用以下代码计算 <code>binomial(100, 50, 0.25)</code> 将会产生的递归调用次数：</p>\n<pre class=\"code-rows\"><code>public static double binomial(int N, int k, double p)\n{\n   if (N == 0 &amp;&amp; k == 0) return 1.0;\n   if (N &lt; 0 || k &lt; 0) return 0.0;\n   return (1.0 - p)*binomial(N-1, k, p) + p*binomial(N-1, k-1, p);\n}</code></pre>\n<p>　将已经计算过的值保存在数组中并给出一个更好的实现。</p>\n<p><strong>1.1.28</strong>　<strong>删除重复元素</strong>。修改<code>BinarySearch</code> 类中的测试用例来删去排序之后白名单中的所有重复元素。</p>\n<p><strong>1.1.29</strong>　<strong>等值键</strong>。为 <code>BinarySearch</code> <strong>类</strong>添加一个静态方法<code>rank()</code>，它接受一个键和一个整型有序数组（可能存在重复键）作为参数并返回数组中小于该键的元素数量，以及一个类似的方法 <code>count()</code> 来返回数组中等于该键的元素的数量。<strong>注意</strong>：如果 <code>i</code> 和 <code>j</code> 分别是 <code>rank(key,a)</code> 和 <code>count(key,a)</code> 的返回值，那么 <code>a[i..i+j-1]</code> 就是数组中所有和 <code>key</code> 相等的元素。</p>\n<p><strong>1.1.30</strong>　<strong>数组练习</strong>。编写一段程序，创建一个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00839.gif\" alt=\"N\\times N\" inline-img=\"true\" /> 的布尔数组 <code>a[][]</code>。其中当 <code>i</code> 和 <code>j</code> 互质时（没有相同因子），<code>a[i][j]</code> 为 <code>true</code>，否则为 <code>false</code>。</p>\n<p><strong>1.1.31</strong>　<strong>随机连接</strong>。编写一段程序，从命令行接受一个整数 <code>N</code> 和 <code>double</code> 值 <code>p</code>（0 到 1 之间）作为参数，在一个圆上画出大小为 <code>0.05</code> 且间距相等的 <code>N</code> 个点，然后将每对点按照概率 <code>p</code> 用灰线连接。</p>\n<p><strong>1.1.32</strong>　<strong>直方图</strong>。假设标准输入流中含有一系列 <code>double</code> 值。编写一段程序，从命令行接受一个整数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 和两个 <code>double</code> 值 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00840.gif\" alt=\"l\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00822.gif\" alt=\"r\" inline-img=\"true\" />。将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00841.gif\" alt=\"(l,r)\" inline-img=\"true\" /> 分为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 段并使用 <code>StdDraw</code> 画出输入流中的值落入每段的数量的直方图。</p>\n<p><strong>1.1.33</strong>　<strong>矩阵库</strong>。编写一个 Matrix 库并实现以下 API：</p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\">\n<tr><td colspan=\"2\"><code>public class <b>Matrix</b></code></td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;dot(double[] x, double[] y)</code></td><td>向量点乘</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static double[][]&nbsp;&nbsp;mult(double[][] a, double[][] b)</code></td><td>矩阵和矩阵之积</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static double[][]&nbsp;&nbsp;transpose(double[][] a)</code></td><td>转置矩阵</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;double[]&nbsp;&nbsp;mult(double[][] a, double[] x)</code></td><td>矩阵和向量之积</td></tr>\n<tr><td><code>&nbsp;&nbsp;&nbsp;static&nbsp;&nbsp;&nbsp;double[]&nbsp;&nbsp;mult(double[] y, double[][] a)</code></td><td>向量和矩阵之积</td></tr>\n</table>\n\n<p>　编写一个测试用例，从标准输入读取矩阵并测试所有方法。</p>\n<p><strong>1.1.34</strong>　<strong>过滤</strong>。以下哪些任务<strong>需要</strong>（在数组中，比如）保存标准输入中的所有值？哪些可以被实现为一个过滤器且仅使用固定数量的变量和固定大小的数组（和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 无关）？在每个问题中，输入都来自于标准输入且含有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个 0 到 1 的实数。</p>\n<ul>\n<li>打印出最大和最小的数</li>\n<li>打印出所有数的中位数</li>\n<li>打印出第 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" /> 小的数，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" /> 小于 100</li>\n<li>打印出所有数的平方和</li>\n<li>打印出 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" /> 个数的平均值</li>\n<li>打印出大于平均值的数的百分比</li>\n<li>将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" /> 个数按照升序打印</li>\n<li>将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" /> 个数按照随机顺序打印</li>\n</ul>\n<h3 id=\"nav_point_26\">实验题</h3>\n<p><strong>1.1.35</strong>　<strong>模拟掷骰子</strong>。以下代码能够计算每种两个骰子之和的准确概率分布：</p>\n<pre class=\"code-rows\"><code>int SIDES = 6;\ndouble[] dist = new double[2*SIDES+1];\nfor (int i = 1; i &lt;= SIDES; i++)\n   for (int j = 1; j &lt;= SIDES; j++)\n      dist[i+j] += 1.0;\n\nfor (int k = 2; k &lt;= 2*SIDES; k++)\n   dist[k] /= 36.0;</code></pre>\n<p>　<code>dist[i]</code> 的值就是两个骰子之和为 <code>i</code> 的概率。用实验模拟 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 次掷骰子，并在计算两个 1 到 6 之间的随机整数之和时记录每个值的出现频率以验证它们的概率。<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 要多大才能够保证你的经验数据和准确数据的吻合程度达到小数点后三位？</p>\n<p><strong>1.1.36</strong>　<strong>乱序检查</strong>。通过实验检查表 1.1.10 中的乱序代码是否能够产生预期的效果。编写一个程序 ShuffleTest，接受命令行参数 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />，将大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00801.gif\" alt=\"M\" inline-img=\"true\" /> 的数组打乱 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 次且在每次打乱之前都将数组重新初始化为<code>a[i] = i</code>。打印一个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00843.gif\" alt=\"M\\times M\" inline-img=\"true\" /> 的表格，对于所有的列 <code>j</code>，行 <code>i</code> 表示的是 <code>i</code> 在打乱后落到 <code>j</code> 的位置的次数。数组中的所有元素的值都应该接近于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00844.gif\" alt=\"N/M\" inline-img=\"true\" />。</p>\n<p><strong>1.1.37</strong>　<strong>糟糕的打乱</strong>。假设在我们的乱序代码中你选择的是一个 <code>0</code> 到<code>N-1</code> 而非<code>i</code> 到<code>N-1</code> 之间的随机整数。证明得到的结果并非均匀地分布在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00845.gif\" alt=\"N!\" inline-img=\"true\" /> 种可能性之间。用上一题中的测试检验这个版本。</p>\n<p><strong>1.1.38</strong>　<strong>二分查找与暴力查找</strong>。根据 1.1.10.4 节给出的暴力查找法编写一个程序<code>BruteForceSearch</code>，在你的计算机上比较它和 <code>BinarySearch</code> 处理 largeW.txt 和 largeT.txt 所需的时间。</p>\n<p><strong>1.1.39</strong>　<strong>随机匹配</strong>。编写一个使用 <code>BinarySearch</code> 的程序，它从命令行接受一个整型参数 <code>T</code>，并会分别针对 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00846.gif\" alt=\"N=10^3\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00847.gif\" alt=\"10^4\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00848.gif\" alt=\"10^5\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" /> 将以下实验运行 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00850.gif\" alt=\"T\" inline-img=\"true\" /> 遍：生成两个大小为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的随机 6 位正整数数组并找出同时存在于两个数组中的整数的数量。打印一个表格，对于每个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />，给出 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00850.gif\" alt=\"T\" inline-img=\"true\" /> 次实验中该数量的平均值。</p>\n","comments":[]}