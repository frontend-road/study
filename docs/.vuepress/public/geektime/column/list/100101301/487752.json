{"id":487752,"title":"29 | 消息驱动：如何集成 Stream 实现消息驱动？","content":"<p>你好，我是姚秋辰。</p><p>在上节课中，我们通过一些实际案例了解到了消息驱动技术的应用场景，这节课我们就使用Spring Cloud Stream技术来一场演练，基于RabbitMQ消息中间件来落地实践场景。</p><p>以往我们在项目中使用Stream时，大都是使用经典的@Input、@Output和@StreamListener等注解来注册消息生产者和消费者，而Stream在3.1版本之后在这几个注解上打了一个@Deprecated标记，意思是这种对接方式已经被淘汰了，不推荐继续使用。取而代之的是更为流行的Functional Programming风格，也就是我们俗称的函数式编程。</p><p>从近几年的技术发展趋势就可以看出来，函数式编程成了一种技术演进的趋势，它能让你以更少的代码和精简化的配置实现自己的业务逻辑。函数式编程和约定大于配置相结合的编程风格比较放飞自我，在接下来的实战环节中，你就会体会到这种less code style的快感了。</p><p>因为函数式消息驱动在同一个应用包含多个Event Topic的情况下有一些特殊配置，所以为了方便演示这个场景，我选择了Customer服务中的两个具有关联性的业务，分别是用户领取优惠券和删除优惠券，这节课我们就将这两个服务改造成基于消息驱动的实现方式。</p><!-- [[[read_end]]] --><h2>实现消息驱动</h2><p>我把业务场景里的消息生产者和消费者都定义在了Customer服务中，可能你会以为，在真实项目里，生产者和消费者应该分别定义在不同的应用中，大多数情况下确实如此。比如在<a href=\"https://time.geekbang.org/column/article/487158\">上节课</a>的消息广播场景里，一个订单完成之后，通过广播消息触发下游各个服务的业务流程，这里的生产者和消费者是分在不同应用中的。</p><p>但是呢，我们也有把生产者和消费者定义在同一个应用中的场景，我叫它自产自销。比如在一些削峰填谷的例子中，为了平滑处理用户流量并降低负载，我们可以将高QPS但时效性要求不高的请求堆积到消息组件里，让当前应用的消费者慢慢去处理。比如我曾经实现的批量发布商品就是这么个自产自销的例子，商品服务接收请求后丢到MQ，让同一个应用内部的消费者慢慢消化。</p><p>我们接下来就分三步走，用这个自产自销的路子来实现消息驱动业务。先添加生产者代码，再定义消费者逻辑，最后添加配置文件。</p><p>按照惯例，集成之前你需要先把下面这个Stream依赖项添加到coupon-customer-impl项目的pom文件中。由于我们底层使用的中间件是RabbitMQ，所以我们引入的是stream-rabbit组件，如果你使用的是不同的中间件，那么需要引入对口的依赖项。</p><pre><code class=\"language-plain\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>添加好依赖项之后，我们先来动手编写生产者逻辑。</p><h3>添加生产者</h3><p>生产者只做一件事，就是生产一个消息事件，并将这个事件发送到RabbitMQ。我在Customer服务下创建了一个叫做CouponProducer的类，添加了sendCoupon和deleteCoupon这两个生产者方法，分别对应了领取优惠券和删除优惠券。在这两个方法内，我使用了StreamBridge这个Stream的原生组件，将信息发送给RabbitMQ。</p><pre><code class=\"language-plain\">@Service\n@Slf4j\npublic class CouponProducer {\n\n    @Autowired\n    private StreamBridge streamBridge;\n\n    public void sendCoupon(RequestCoupon coupon) {\n        log.info(\"sent: {}\", coupon);\n        streamBridge.send(EventConstant.ADD_COUPON_EVENT, coupon);\n    }\n\n    public void deleteCoupon(Long userId, Long couponId) {\n        log.info(\"sent delete coupon event: userId={}, couponId={}\", userId, couponId);\n        streamBridge.send(EventConstant.DELETE_COUPON_EVENT, userId + \",\" + couponId);\n    }\n\n}\n</code></pre><p>在这段代码里，streamBridge.send方法的第一个参数是Binding Name，它指定了这条消息要被发到哪一个信道中，其中ADD_COUPON_EVENT=addCoupon-out-0，而deleteCoupon=deleteCoupon-out-0。你先不要管这两个奇怪的值是什么，你只要把Binding Name理解成一条消息从Stream到达RabbitMQ之间的“通道”，待会儿看到配置文件的时候，你就会清楚这条通道是怎么与RabbitMQ中定义的消息队列名称关联起来的了。</p><p>消息的生产者已经定义好了，接下来我在CouponCustomerController中新添加了两个方法，单独用来测试我们定义的两个生产者服务。这两个Controller方法接收的参数和现有的领券、删除券的接口是一致的，唯二的区别是请求路径后面多了个Event，以及方法的返回值变成了void。</p><pre><code class=\"language-plain\">@PostMapping(\"requestCouponEvent\")\npublic void requestCouponEvent(@Valid @RequestBody RequestCoupon request) {\n    couponProducer.sendCoupon(request);\n}\n\n// 用户删除优惠券\n@DeleteMapping(\"deleteCouponEvent\")\npublic void deleteCouponEvent(@RequestParam(\"userId\") Long userId,\n                         @RequestParam(\"couponId\") Long couponId) {\n    couponProducer.deleteCoupon(userId, couponId);\n}\n</code></pre><p>到这里，我们生产者端的配置就完成了，接下来我们就去编写消息的消费者。</p><h3>添加消息消费者</h3><p>我在CouponProducer的同级目录下创建了一个CouponConsumer类，它作为消息的消费者，从RabbitMQ处消费由生产者发布的消息事件，方法底层仍然是调用CustomerService服务来完成业务逻辑。</p><p>在这段代码中，有一个“<strong>约定大于配置</strong>”的规矩你一定要遵守，那就是不要乱起方法名。我这里定义的addCoupon、deleteCoupon两个方法名是有来头的，你要确保消费者方法的名称和配置文件中所定义的Function Name以及Binding Name保持一致，这是function event的一条潜规则。因为在默认情况下，框架会使用消费者方法的method name作为当前消费者的标识，如果消费者标识和配置文件中的名称不一致，那么Spring应用就不知道该把当前的消费者绑定到哪一个Stream信道上去。</p><p>另外有一点需要提醒你，我在代码中采用了Consumer的实现方式，它是函数式编程的一种方式，你也可以根据自己的编程习惯，采用其它函数式编程方式来编写这段逻辑。</p><pre><code class=\"language-plain\">@Slf4j\n@Service\npublic class CouponConsumer {\n\n    @Autowired\n    private CouponCustomerService customerService;\n\n    @Bean\n    public Consumer&lt;RequestCoupon&gt; addCoupon() {\n        return request -&gt; {\n            log.info(\"received: {}\", request);\n            customerService.requestCoupon(request);\n        };\n    }\n\n    @Bean\n    public Consumer&lt;String&gt; deleteCoupon() {\n        return request -&gt; {\n            log.info(\"received: {}\", request);\n            List&lt;Long&gt; params = Arrays.stream(request.split(\",\"))\n                    .map(Long::valueOf)\n                    .collect(Collectors.toList());\n            customerService.deleteCoupon(params.get(0), params.get(1));\n        };\n    }\n\n}\n</code></pre><p>到这里消费者的定义也完成了。在定义生产者和消费者的过程中我多次提到了配置文件，下面我们就来看一下Stream的配置项都有哪些内容。</p><h3>添加配置文件</h3><p>Stream的配置项比较多，我打算分Binder和Binding两部分来讲。我们先来看Binder部分，Binder中配置了对接外部消息中间件所需要的连接信息。如果你的程序中只使用了单一的中间件，比如只接入了RabbitMQ，那么你可以直接在spring.rabbitmq节点下配置连接串，不需要特别指定binders配置。</p><p>如果你在Stream中需要同时对接多个不同类型，或多个同类型但地址端口各不相同的消息中间件，那么你可以把这些中间件的信息配置在spring.cloud.stream.binders节点下。其中type属性指定了当前消息中间件的类型，而environment则指定了连接信息。</p><pre><code class=\"language-plain\">spring:\n  cloud:\n    stream:\n      # 如果你项目里只对接一个中间件，那么不用定义binders\n      # 当系统要定义多个不同消息中间件的时候，使用binders定义\n      binders:\n        my-rabbit:\n          type: rabbit # 消息中间件类型\n          environment: # 连接信息\n            spring:\n              rabbitmq:\n                host: localhost\n                port: 5672\n                username: guest\n                password: guest\n      \n</code></pre><p>配置完了binders，我们接下来看看如何定义spring.cloud.stream.bindings节点，这个节点保存了生产者、消费者、binder和RabbitMQ四方的关联关系。</p><pre><code class=\"language-plain\">spring:\n  cloud:\n    stream:\n      bindings:\n        # 添加coupon - Producer\n        addCoupon-out-0:\n          destination: request-coupon-topic\n          content-type: application/json\n          binder: my-rabbit\n        # 添加coupon - Consumer\n        addCoupon-in-0:\n          destination: request-coupon-topic\n          content-type: application/json\n          # 消费组，同一个组内只能被消费一次\n          group: add-coupon-group\n          binder: my-rabbit\n        # 删除coupon - Producer\n        deleteCoupon-out-0:\n          destination: delete-coupon-topic\n          content-type: text/plain\n          binder: my-rabbit\n        # 删除coupon - Consumer\n        deleteCoupon-in-0:\n          destination: delete-coupon-topic\n          content-type: text/plain\n          group: delete-coupon-group\n          binder: my-rabbit\n      function:\n        definition: addCoupon;deleteCoupon\n</code></pre><p>我们以addCoupon为例，你会看到我定义了addCoupon-out-0和addCoupon-in-0这两个节点，节点名称中的out代表当前配置的是一个生产者，而in则代表这是一个消费者，这便是spring-function中约定的命名关系：</p><p>Input信道（消费者）：&lt; functionName &gt; - in - &lt; index &gt;；</p><p>Output信道（生产者）：&lt; functionName &gt; - out - &lt; index &gt;。</p><p>你可能注意到了，在命名规则的最后还有一个index，它是input和output的序列，如果同一个function name只有一个output和一个input，那么这个index永远都是0。而如果你需要为一个function添加多个input和output，就需要使用index变量来区分每个生产者消费者了。如果你对index的使用场景感兴趣，可以参考文稿中的<a href=\"https://docs.spring.io/spring-cloud-stream/docs/3.1.0/reference/html/spring-cloud-stream.html#_functions_with_multiple_input_and_output_arguments\">官方社区文档</a>。</p><p>现在你已经了解了生产者和消费者的信道是如何定义的，但是，至于这个信道和RabbitMQ里定义的消息队列之间的关系，你知道是怎么指定的吗？</p><p>信道和RabbitMQ的绑定关系是通过binder属性指定的。如果当前配置文件的上下文中只有一个消息中间件（比如使用默认的MQ），你并不需要声明binder属性。但如果你配置了多个binder，那就需要为每个信道声明对应的binder是谁。addCoupon-out-0对应的binder名称是my-rabbit，这个binder就是我刚才在spring.cloud.stream.binders里声明的配置。通过这种方式，生产者消费者信道到消息中间件（binder）的联系就建立起来了。</p><p>信道和消息队列的关系是通过destination属性指定的。以addCoupon为例，我在addCoupon-out-0生产者配置项中指定了destination=request-coupon-topic，意思是将消息发送到名为request-coupon-topic的Topic中。我又在addCoupon-in-0消费者里添加了同样的配置，意思是让当前消费者从request-coupon-topic消费新的消息。</p><p>RabbitMQ消息组件内部是通过交换机（Exchange）和队列（Queue）来做消息投递的，如果你登录RabbitMQ的控制台，就可以在Exchanges下看到我声明的delete-coupon-topic和request-coupon-topic。</p><p><img src=\"https://static001.geekbang.org/resource/image/74/82/74de92b7156a5eb7b7eebf5291733682.png?wh=661x601\" alt=\"图片\"></p><p>切换到Queues面板，你还会看到这两个交换机所绑定的队列名称。这里的队列名称后面还跟了一个group name，这就是我在消费者这一侧设置的消息分组，我在配置项中为add-coupon-in设置了group=add-coupon-group，即当前分组内只有一台机器可以去消费队列中的消息，这就是所谓的“消息分组单播”的场景。如果你不设置group属性，那么这个消息就会成为一条“广播消息”。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/eb/5fb0dd9635eff788edba15b80962e1eb.png?wh=1030x506\" alt=\"图片\"></p><p>最后的最后，有一个最为重要的配置项，我专门把它放到最后来讲，那就是spring.cloud.stream.function。如果你的项目中只有一组消费者，那么你完全不用搭理这个配置项，只要确保消费者代码中的method name和bindings下声明的消费者信道名称相对应就好了；如果你的项目中有多组消费者（比如我声明了addCoupon和deleteCoupon两个消费者），在这种情况下，你需要将消费者所对应的function name添加到spring.cloud.stream.function，否则消费者无法被绑定到正确的信道。</p><pre><code class=\"language-plain\">spring:\n  cloud:\n    stream:\n      function:\n        definition: addCoupon;deleteCoupon\n</code></pre><p>到这里，我们就完整搭建了一套消息驱动的方案。下面让我来带你回顾下本节重点吧。</p><h2>总结</h2><p>在今天的课程里，我们使用了Stream在新版本中推荐的functional event风格实现了用户领券和删除券。在这个环节里，你需要注意的是遵循spring function的约定，在下面的几个地方使用一致的命名规则。</p><ol>\n<li>生产者端代码中的binding name（addCoupon-out-0）和配置文件中的生产者名称一致；</li>\n<li>同一对生产者和消费者，在配置文件中要使用一样的Topic Name；</li>\n<li>如果项目中存在多个消费者，使用spring.cloud.stream.function或者spring.cloud.function把所有消费者的function name写出来。</li>\n</ol><p>约定大于配置这种风格，对初学者来说，是需要一些上手门槛的，但当你熟悉了这里面的门道之后，你就能利用这种less code开发风格大幅提高开发效率。</p><h2>思考题</h2><p>如果Consumer在消费消息的时候发生了异常，你知道有哪些异常处理的方式吗？</p><p>好啦，这节课就结束啦。欢迎你把这节课分享给更多对Spring Cloud感兴趣的朋友。我是姚秋辰，我们下节课再见！</p>","neighbors":{"left":{"article_title":"28 | 消息驱动：谁说消息队列只能削峰填谷？","id":487158},"right":{"article_title":"30 | 消息驱动：如何高效处理 Stream 中的异常？","id":488500}},"comments":[{"had_liked":false,"id":345499,"user_name":"Carla","can_delete":false,"product_type":"c1","uid":1181454,"ip_address":"","ucode":"29608BF359A567","user_header":"","comment_is_top":false,"comment_ctime":1652336587,"is_pvip":true,"replies":[{"id":"126160","content":"讲真，而且很容易出错，排查起来还不容易 ：）","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1652583533,"ip_address":"","comment_id":345499,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5947303883","product_id":100101301,"comment_content":"约定的多了，怎么感觉反而变得麻烦了😂","like_count":2,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572043,"discussion_content":"讲真，而且很容易出错，排查起来还不容易 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652583533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335372,"user_name":"wake","can_delete":false,"product_type":"c1","uid":1222812,"ip_address":"","ucode":"08F77A1144D383","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/9c/643646b9.jpg","comment_is_top":false,"comment_ctime":1645492138,"is_pvip":false,"replies":[{"id":"122647","content":"其实和返回值关系不大，Consumer只是函数式编程的一种实现方式，还有其他方式比如Flux、Supplier。如果方法重名，我印象中是遵循先来后到，后初始化的bean对应的consumer优先生效。同学可以本地试一下，回头告诉我们答案哈","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1645632341,"ip_address":"","comment_id":335372,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5940459434","product_id":100101301,"comment_content":"老师如果我其它方法名也叫addCoupon会被误认为消费者吗？或者说只有返回值为Consumer才会被认定为消费者，那如果有两个同样的返回Consumer的addCoupon方法呢","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552913,"discussion_content":"其实和返回值关系不大，Consumer只是函数式编程的一种实现方式，还有其他方式比如Flux、Supplier。如果方法重名，我印象中是遵循先来后到，后初始化的bean对应的consumer优先生效。同学可以本地试一下，回头告诉我们答案哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645632341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2573588,"avatar":"","nickname":"Geek_8b92bf","note":"","ucode":"0EED09DA79D171","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558131,"discussion_content":"测试了一下，其实和方法名无关，匹配的是beanName，只不过刚好@Bean注解默认用方法名作为beanName而已。function代表的不是方法名，而是bean必须是@FunctionalInterface吧，只不过Stream里面要求了Type must be one of Supplier, Function or Consumer。以下方法也是可以消费消息\n    @Bean(&#34;addCoupon&#34;)\n    public Function&lt;RequestCoupon,Object&gt; dddef(){\n        return d-&gt;{\n            System.out.println(&#34;可以哦ggdd&#34;);\n            System.out.println(d);\n            return null;\n        };\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648105939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352634,"user_name":"zkr","can_delete":false,"product_type":"c1","uid":1792800,"ip_address":"上海","ucode":"8BF9D0348BBF87","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5b/20/ae2d4489.jpg","comment_is_top":false,"comment_ctime":1658823577,"is_pvip":false,"replies":[{"id":"128731","content":"routing key也可以在配置中指定，后面做消息分区的时候这部分有讲，如果需要定制的话可以参考","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1659942435,"ip_address":"上海","comment_id":352634,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1658823577","product_id":100101301,"comment_content":"为啥生产者发消息，消费者接受消息不用指定队列名和routing key？队列这个我还能理解，我试了下是按topic名+group名自动生成了一个，但是为啥topic模式不用指定routing key？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583186,"discussion_content":"routing key也可以在配置中指定，后面做消息分区的时候这部分有讲，如果需要定制的话可以参考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659942435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348805,"user_name":"曹亮","can_delete":false,"product_type":"c1","uid":3006290,"ip_address":"","ucode":"168855E7B18105","user_header":"","comment_is_top":false,"comment_ctime":1655426521,"is_pvip":false,"replies":[{"id":"127578","content":"直接发送mq可以理解为JDBC，使用Stream可以理解为在jdbc上卷了一层JPA，后一个比前一个卷，造轮子哈哈<br><br>回到MQ来看的话就相当于Stream在底层中间件之上做了一层spring-integration的抽象，屏蔽了底层细节。","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1657104955,"ip_address":"","comment_id":348805,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1655426521","product_id":100101301,"comment_content":"老师，请教一下，在微服务项目中Stream和mq结合使用，和直接在服务里将消息发送到mq，这两种有什么区别？用stream的优势体现在哪里？","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578975,"discussion_content":"直接发送mq可以理解为JDBC，使用Stream可以理解为在jdbc上卷了一层JPA，后一个比前一个卷，造轮子哈哈\n\n回到MQ来看的话就相当于Stream在底层中间件之上做了一层spring-integration的抽象，屏蔽了底层细节。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657104955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346801,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1653443598,"is_pvip":false,"replies":[{"id":"126728","content":"世上无难事，只要肯放弃。同学直接用我的源码吧：）","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1654237771,"ip_address":"","comment_id":346801,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653443598","product_id":100101301,"comment_content":"感觉，这配置好难。配了好几天都没有配好。","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574666,"discussion_content":"世上无难事，只要肯放弃。同学直接用我的源码吧：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654237772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344838,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1651819574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651819574","product_id":100101301,"comment_content":"消费消息发生异常,消息重新进入队列重新消费","like_count":0},{"had_liked":false,"id":335780,"user_name":"奔跑的蚂蚁","can_delete":false,"product_type":"c1","uid":2379253,"ip_address":"","ucode":"7348CA436144CB","user_header":"https://static001.geekbang.org/account/avatar/00/24/4d/f5/2e80aca6.jpg","comment_is_top":false,"comment_ctime":1645686657,"is_pvip":false,"replies":[{"id":"122853","content":"这几行日志没看到报错信息，应该是INFO log，如果有Error可以把完整log trace发出来一起看下","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1645970782,"ip_address":"","comment_id":335780,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1645686657","product_id":100101301,"comment_content":"试了下spring-cloud-starter-stream-rocketmq 的 function binding <br>第一次发送消息会报日志<br>DefaultBinderFactory      : Retrieving cached binder: rocketmq<br>DirectWithAttributesChannel    : Channel &#39;unknown.channel.name&#39; has 1 subscriber(s).<br>BeanFactoryAwareFunctionRegistry : Looking up function &#39;streamBridge&#39; with acceptedOutputTypes: [application&#47;json]<br><br>.MessagingMethodInvokerHelper   : Overriding default instance of MessageHandlerMethodFactory with provided one.<br><br><br>这些都正常嘛<br>","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553582,"discussion_content":"这几行日志没看到报错信息，应该是INFO log，如果有Error可以把完整log trace发出来一起看下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645970782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2379253,"avatar":"https://static001.geekbang.org/account/avatar/00/24/4d/f5/2e80aca6.jpg","nickname":"奔跑的蚂蚁","note":"","ucode":"7348CA436144CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":553678,"discussion_content":"没有error 日志 能正常发送消息，但是看日志貌似是 channel未命名，不知道这样会不会有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646026436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553582,"ip_address":""},"score":553678,"extra":""}]}]},{"had_liked":false,"id":334872,"user_name":"奔跑的蚂蚁","can_delete":false,"product_type":"c1","uid":2379253,"ip_address":"","ucode":"7348CA436144CB","user_header":"https://static001.geekbang.org/account/avatar/00/24/4d/f5/2e80aca6.jpg","comment_is_top":false,"comment_ctime":1645163943,"is_pvip":false,"replies":[{"id":"122392","content":"重试策略（次数+每次重试间隔）会在后面的一节课程里单独讲到，应该快上线了","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1645369199,"ip_address":"","comment_id":334872,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645163943","product_id":100101301,"comment_content":"我们项目用了spirng.cloud.stream.rocketMq  出了异常是自动重试，老师能讲讲原理嘛  能自定义重试间隔是次数嘛（是不是mq里面配置的）","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552251,"discussion_content":"重试策略（次数+每次重试间隔）会在后面的一节课程里单独讲到，应该快上线了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645369199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334804,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1645143414,"is_pvip":true,"replies":[{"id":"122390","content":"Q1：不走寻常路是可以，但是失去了约定大约配置的意义<br>Q2：Consumer是函数式编程的一种方式<br>Q3：函数式编程语法，建议先找一些开源资料熟悉下语法<br>Q4: 任意名字<br>Q5：交换机和队列之间可以建立绑定关系，官网的帮助文档里有详细信息https:&#47;&#47;www.rabbitmq.com&#47;documentation.html<br>","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1645369091,"ip_address":"","comment_id":334804,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1645143414","product_id":100101301,"comment_content":"请教老师几个问题：<br>Q1：消费者标识是否可以不用方法名，另外指定一个？<br>Q2：“采用了 Consumer 的实现方式”，“添加消息消费者”部分的这句话中，consumer的实现方式是指什么？笔误吗？<br>Q3 ：“return request -&gt; ”，request从哪里来？<br>CouponConsumer类中，addCoupon方法中直接用了request，此request从哪里来的？<br>Q4：配置文件中，binders下面的my-rabbit，这个名字是任意的吗？<br>  如果有多个，其他的也要起一个不同的名字吗？ 比如my-rabbit2,<br>  my-kafka等<br>Q5： 交换机和队列是怎么对应的？<br>A 两个交换机，两个队列，每个交换机都可以将消息发送到两个队列吗？<br>B 队列的名字，用点号分成两部分，有什么含义吗？","like_count":0,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552248,"discussion_content":"Q1：不走寻常路是可以，但是失去了约定大约配置的意义\nQ2：Consumer是函数式编程的一种方式\nQ3：函数式编程语法，建议先找一些开源资料熟悉下语法\nQ4: 任意名字\nQ5：交换机和队列之间可以建立绑定关系，官网的帮助文档里有详细信息https://www.rabbitmq.com/documentation.html\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645369091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1408553,"avatar":"https://static001.geekbang.org/account/avatar/00/15/7e/29/2fc94ee7.jpg","nickname":"金灶沐","note":"","ucode":"997DE6CD343179","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555783,"discussion_content":"Q1: 可以指定其他名字，因为此标识是用的Bean的名字， 因为@Bean没有指定名字，所以Bean的名字就是方法名，  如果@Bean(&#34;testBean&#34;)，就可以将testBean当做标识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647073676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}