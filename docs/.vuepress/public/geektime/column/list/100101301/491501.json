{"id":491501,"title":"35 | 分布式事务：使用 Nacos+Seata 实现 TCC 补偿模式","content":"<p>你好，我是姚秋辰。</p><p>上节课我们落地了一套Seata AT方案，要我说呢，AT绝对是最省心的分布式事务方案，一个注解搞定一切。今天这节课，我们来加一点难度，从Easy模式直接拉到Hard模式，看一个巨复杂的分布式事务方案：Seata TCC。</p><p>说TCC复杂，那是相对于AT来讲的。在AT模式下，你通过一个注解就能搞定所有事情，不需要对业务层代码进行任何修改。TCC难就难在它的实现方式上，它是一个基于“补偿模式”的解决方案。补偿的意思就是，你需要通过编写业务逻辑代码实现事务控制。</p><p>那TCC是如何通过代码来控制事务状态的呢？这就要说到TCC的三阶段事务模型了。</p><h2>TCC事务模型</h2><p>TCC名字里这三个字母分别是三个单词的首字母缩写，从前到后分别是Try、Confirm和Cancel，这三个单词分别对应了TCC模式的三个执行阶段，每一个阶段都是独立的本地事务。</p><p><img src=\"https://static001.geekbang.org/resource/image/70/ec/700119981d8a5bf14843d35c4b03ecec.jpg?wh=1920x559\" alt=\"图片\"></p><p>Try阶段完成的工作是<strong>预定操作资源（Prepare），</strong>说白了就是“占座”的意思，在正式开始执行业务逻辑之前，先把要操作的资源占上座。</p><p>Confirm阶段完成的工作是<strong>执行主要业务逻辑（Commit）</strong>，它类似于事务的Commit操作。在这个阶段中，你可以对Try阶段锁定的资源进行各种CRUD操作。如果Confirm阶段被成功执行，就宣告当前分支事务提交成功。</p><!-- [[[read_end]]] --><p>Cancel阶段的工作是<strong>事务回滚（Rollback），</strong>它类似于事务的Rollback操作。在这个阶段中，你可没有AT方案的undo_log帮你做自动回滚，你需要通过业务代码，对Confirm阶段执行的操作进行人工回滚。</p><p>我用一个考研占座的例子帮你理解TCC的工作流程。话说学校有一个专给考研学生准备的不打烊的考研复习教室，一座难求。如果你想要用TCC的方式坐定一个位子，那么第一步就是要执行Try操作，比如往座位上放上一块板砖，那这个座位就被你预定住了，后面来的人发现座位上面有块砖就去找其他座位了。第二步是Confirm阶段，这时候需要把板砖拿走，然后本尊坐在位子上，到这里TCC事务就算成功执行了。</p><p>如果Try阶段无法锁定资源，或者Confirm阶段发生异常，那么整个全局事务就会回滚，这就触发了第三步Cancel，你需要对Try步骤中锁定的资源进行释放，于是乎，这块砖在Cancel阶段被移走了，座位回到了TCC执行前的状态。</p><p>从这个例子可以看出，TCC的每一个步骤都需要你通过执行业务代码来实现。那接下来，让我带你去实战项目中落地一个简单的TCC案例，近距离感受下Hard模式的开发体验。</p><h2>实现TCC</h2><p>这次我们依然选择优惠券模板删除这个场景作为TCC的落地案例，我将在上节课的AT模式的基础之上，对Template服务做一番改造，将deleteTemplate接口改造为TCC风格。</p><p>前面咱提到过，TCC是由Try-Confirm-Cancel三个部分组成的，这三个部分怎么来定义呢？我先来写一个TCC风格的接口，你一看就明白了。</p><h3>注册TCC接口</h3><p>为了方便你阅读代码，我在Template服务里单独定义了一个新的接口，取名为CouponTemplateServiceTCC，它继承了CouponTemplateService这个接口。</p><pre><code class=\"language-plain\">@LocalTCC\npublic interface CouponTemplateServiceTCC extends CouponTemplateService {\n\n    @TwoPhaseBusinessAction(\n            name = \"deleteTemplateTCC\",\n            commitMethod = \"deleteTemplateCommit\",\n            rollbackMethod = \"deleteTemplateCancel\"\n    )\n    void deleteTemplateTCC(@BusinessActionContextParameter(paramName = \"id\") Long id);\n\n    void deleteTemplateCommit(BusinessActionContext context);\n\n    void deleteTemplateCancel(BusinessActionContext context);\n}\n</code></pre><p>在这段代码中，我使用了两个TCC的核心注解：LocalTCC和TwoPhaseBusinessAction。</p><p>其中@LocalTCC注解被用来修饰实现了二阶段提交的本地TCC接口，而@TwoPhaseBusinessAction注解标识当前方法使用TCC模式管理事务提交。</p><p>在TwoPhaseBusinessAction注解内，我通过name属性给当前事务注册了一个全局唯一的TCC bean name，然后分别使用commitMethod和rollbackMethod指定了它在Confirm阶段和Cancel阶段所要执行的方法。Try阶段所要执行的方法，便是被@TwoPhaseBusinessAction所修饰的deleteTemplateTCC方法了。</p><p>你一定注意到了我在deleteTemplateCommit和deleteTemplateCancel这两个方法中使用了一个特殊的入参BusinessActionContext，你可以使用它传递查询参数。在TCC模式下，查询参数将作为BusinessActionContext的一部分，在事务上下文中进行传递。</p><p>如果你对TCC注解的底层源码感兴趣，我推荐你从GlobalTransactionScanner这个类的wrapIfNecessary方法开始研究。它通过TCCBeanParserUtils工具类来判断当前资源是否为TCC的实现类，如果是TCC自动代理的话，就生成一个TccActionInterceptor作为当前bean对象的事务拦截器。</p><pre><code class=\"language-plain\">if (TCCBeanParserUtils.isTccAutoProxy(bean, beanName, applicationContext)) {\n    //TCC interceptor, proxy bean of sofa:reference/dubbo:reference, and LocalTCC\n    interceptor = new TccActionInterceptor(TCCBeanParserUtils.getRemotingDesc(beanName));\n}\n</code></pre><p>接口定义完成后，我们将CouponTemplateServiceImpl的接口类指向刚定义好的CouponTemplateServiceTCC方法，接下来就可以写具体实现了，按照TCC三阶段的顺序，我们先从一阶段Prepare写起。</p><h3>编写一阶段Prepare逻辑</h3><p>在一阶段Prepare的过程中，我们执行的是Try逻辑，它的目标是“锁定”优惠券模板资源。为了达成这个目标，我们需要对coupon_template数据库做一个小修改，引入一个名为locked的变量，用来标记当前资源是否被锁定。你可以直接执行下面的SQL语句添加这个属性。</p><pre><code class=\"language-plain\">alter table coupon_template\n   add locked tinyint(1) default 0 null;\n</code></pre><p>在CouponTemplate类中，我们也要加上locked属性。</p><pre><code class=\"language-plain\">@Column(name = \"locked\", nullable = false)\nprivate Boolean locked;\n</code></pre><p>有了locked字段，我们就可以在Try阶段借助它来锁定券模板了。我们先来看一下简化版的资源锁定代码吧。</p><pre><code class=\"language-plain\">@Override\n@Transactional\npublic void deleteTemplateTCC(Long id) {\n    CouponTemplate filter = CouponTemplate.builder()\n            .available(true)\n            .locked(false)\n            .id(id)\n            .build();\n\n    CouponTemplate template = templateDao.findAll(Example.of(filter))\n            .stream().findFirst()\n            .orElseThrow(() -&gt; new RuntimeException(\"Template Not Found\"));\n\n    template.setLocked(true);\n    templateDao.save(template);\n}\n</code></pre><p>在这段代码中，我在通过ID查找优惠券的同时，添加了两个查询限定条件来筛选未被锁定且状态为available的券模板。如果查到了符合条件的记录，我会将其locked状态置为true。</p><p>在正式的线上业务中，Try方法的资源锁定逻辑会更加复杂。我举一个例子，就拿转账来说吧，如果张三要向李四转账30元，在TCC模式下这30元会被“锁定”并计入冻结金额中，我们在“锁定”资源的同时还需要记录是“谁”冻结了这部分金额。比如你可以在生成锁定记录的时候将转账交易号也一并记下来，这个交易号就是我们前面说的那个“谁”，这样你就知道这些金额是被哪笔交易锁定的了。这样一来，当你执行回滚逻辑将金额从“冻结余额”里释放的时候，就不会错误地释放其他转账请求锁定的金额了。</p><p>接下来我们去看下二阶段Commit的执行逻辑。</p><h3>编写二阶段Commit逻辑</h3><p>二阶段Commit就是TCC中的Confirm阶段，只要TCC框架执行到了Commit逻辑，那么就代表各个分支事务已经成功执行了Try逻辑。我们在Commit阶段执行的是主体业务逻辑，即删除优惠券，但是别忘了你还要将Try阶段的资源锁定解除掉。</p><p>在下面的代码中，我们放心大胆地直接读取了指定ID的优惠券，不用担心ID不存在，因为ID不存在的话，在Try阶段就会抛出异常，TCC会转而执行Rollback方法，压根进不到Commit阶段。读取到Template对象之后，我们分别设置locked=false，available=true。</p><pre><code class=\"language-plain\">@Override\n@Transactional\npublic void deleteTemplateCommit(BusinessActionContext context) {\n    Long id = Long.parseLong(context.getActionContext(\"id\").toString());\n\n    CouponTemplate template = templateDao.findById(id).get();\n\n    template.setLocked(false);\n    template.setAvailable(false);\n    templateDao.save(template);\n\n    log.info(\"TCC committed\");\n}\n</code></pre><p>现在你已经完成了二阶段Commit，最后让我们来编写Rollback的逻辑吧。</p><h3>编写二阶段Rollback逻辑</h3><p>二阶段Rollback对应的是TCC中的Cancel阶段，如果在Try或者Confirm阶段发生了异常，就会触发TCC全局事务回滚，Seata Server会将Rollback指令发送给每一个分支事务。</p><p>在下面这段简化的Rollback代码中，我们读取了Template对象，并通过将locked设置为false的方式对资源进行解锁。</p><pre><code class=\"language-plain\">@Override\n@Transactional\npublic void deleteTemplateCancel(BusinessActionContext context) {\n    Long id = Long.parseLong(context.getActionContext(\"id\").toString());\n    Optional&lt;CouponTemplate&gt; templateOption = templateDao.findById(id);\n\n    if (templateOption.isPresent()) {\n        CouponTemplate template = templateOption.get();\n        template.setLocked(false);\n        templateDao.save(template);\n    }\n    log.info(\"TCC cancel\");\n}\n</code></pre><p>在线上业务中，Cancel方法只能释放由当前TCC事务在Try阶段锁定的资源，这就要求你在Try阶段记录资源锁定方的信息，并在Confirm和Cancel段逻对这个信息进行判断。</p><p>你知道为什么我在Cancel里特意加了一段逻辑，判断Template是否存在吗？这就要提到TCC的空回滚了。</p><h3>TCC空回滚</h3><p>所谓空回滚，是在没有执行Try方法的情况下，TC下发了回滚指令并执行了Cancel逻辑。</p><p>那么在什么情况下会出现空回滚呢？比如某个分支事务的一阶段Try方法因为网络不可用发生了Timeout异常，或者Try阶段执行失败，这时候TM端会判定全局事务回滚，TC端向各个分支事务发送Cancel指令，这就产生了一次空回滚。</p><p>处理空回滚的正确的做法是，在Cancel阶段，你应当先判断一阶段Try有没有执行成功。示例程序中的判断方式比较简单，我先是判断资源是否已经被锁定，再执行释放操作。如果资源未被锁定或者压根不存在，你可以认为Try阶段没有执行成功，这时在Cancel阶段直接返回成功即可。</p><p>更为完善的一种做法是，引入独立的事务控制表，在Try阶段中将XID和分支事务ID落表保存，如果Cancel阶段查不到事务控制记录，那么就说明Try阶段未被执行。同理，Cancel阶段执行成功后，也可以在事务控制表中记录回滚状态，这样做是为了防止另一个TCC的坑，“倒悬”。</p><h3>TCC倒悬</h3><p>倒悬又被叫做“悬挂”，它是指TCC三个阶段没有按照先后顺序执行。我们就拿刚讲过的空回滚的例子来说吧，如果Try方法因为网络问题卡在了网关层，导致锁定资源超时，这时Cancel阶段执行了一次空回滚，到目前为止一切正常。但回滚之后，原先超时的Try方法经过网关层的重试，又被后台服务接收到了，这就产生了一次倒悬场景，即一阶段Try在二阶段回滚之后被触发。</p><p>在倒悬的情况下，整个事务已经被全局回滚，那么如果你再执行一次Try操作，当前资源将被长期锁定，这就造成了一种类似死锁的局面。解法很简单，你可以利用事务控制表记录二阶段执行状态，并在Try阶段中检查该状态，如果二阶段回滚完毕，那么就直接跳过一阶段Try。</p><p>到这里，我们就落地了一套TCC业务，下面让我们来回顾下这节课的重要内容吧。</p><h2>总结</h2><p>TCC相比于AT而言，代码开发量至少要double，它以开发量为代价，换取了事务的高度可控性。不过我仍然不建议头脑一热就上TCC方案，因为TCC非常考验开发团队对业务的理解深度，为什么这样说呢？一个重要原因是，你需要把串行的业务逻辑拆分成Try-Confirm-Cancel三个不同的阶段执行，如何设计资源的锁定流程、如果不同资源间有关联性又怎么锁定、回滚的反向补偿逻辑等等，你需要对业务流程的每一个步骤了如指掌，才能设计出高效的TCC流程。</p><p>还有需要特别注意的一点是幂等性，接口幂等性是保证数据一致性的重要前提。在大厂中通常有框架层面的幂等组件，或者幂等性服务供你调用，对于中小业务来说，通过本地事务控制表来确保幂等性是一种简单有效的低成本方案。</p><h2>思考题</h2><p>通过这两节课我们落地了AT和TCC方案，Seata里还有一个SAGA方案，你能举一反三自选SAGA并落地几个小demo吗？</p><p>到这里，我们就学完了这个专栏的最后一节正课内容。欢迎你把这个专栏分享给更多对Spring Cloud感兴趣的朋友。我是姚秋辰，我们结束语再见！</p>","neighbors":{"left":{"article_title":"34 | 分布式事务：使用 Nacos+Seata 实现AT模式","id":491132},"right":{"article_title":"结束语 | 站在聚光灯下","id":492366}},"comments":[{"had_liked":false,"id":336801,"user_name":"奔跑的蚂蚁","can_delete":false,"product_type":"c1","uid":2379253,"ip_address":"","ucode":"7348CA436144CB","user_header":"https://static001.geekbang.org/account/avatar/00/24/4d/f5/2e80aca6.jpg","comment_is_top":false,"comment_ctime":1646376328,"is_pvip":false,"replies":[{"id":"123093","content":"小公司，小团队，可千万别上TCC，除非跟这家老板有仇。<br><br>更简单的方法，就是自建本地事务表+跑批job补偿，短链路用事务型消息也可以","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1646405274,"ip_address":"","comment_id":336801,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44596049288","product_id":100101301,"comment_content":"对于tcc 和 at 如果涉及到分布式事务  小公司 和 团队人数少的公司选择哪个好呢？还有别的更简单的方法吗","like_count":11,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554499,"discussion_content":"小公司，小团队，可千万别上TCC，除非跟这家老板有仇。\n\n更简单的方法，就是自建本地事务表+跑批job补偿，短链路用事务型消息也可以","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1646405274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363593,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLFvhaPbJ1sBZqr8GQRVDiaxsicukAETVzjqmBRba2WqibbmX3NmoPIkaNEnBvyaWobyCjGN0FJgGnKQ/132","nickname":"Geek_9948a5","note":"","ucode":"7DDAF4A21EA1FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586150,"discussion_content":"好的，这就上","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662003849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336800,"user_name":"奔跑的蚂蚁","can_delete":false,"product_type":"c1","uid":2379253,"ip_address":"","ucode":"7348CA436144CB","user_header":"https://static001.geekbang.org/account/avatar/00/24/4d/f5/2e80aca6.jpg","comment_is_top":false,"comment_ctime":1646376235,"is_pvip":false,"replies":[{"id":"123392","content":"如果是用dubbo或者HSF的话，其实版本控制内置version属性就可以很好解决，但是如果是open feign这类对版本控制支持的并不咋样的组件，那我们一般就是采取&#47;v1&#47;v2这种path来区分。比如手机app，老版本新版本要同时支持，但业务差别很大，那么就新app用v2，老app用v1，直到老app强制更新后下线v1","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1646993787,"ip_address":"","comment_id":336800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10236310827","product_id":100101301,"comment_content":"老师能讲下 微服务的 后端接口 版本升级怎么控制的嘛，多个版本兼容怎么做的呢？是通过网关转发到不同的服务上吗。","like_count":3,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555618,"discussion_content":"如果是用dubbo或者HSF的话，其实版本控制内置version属性就可以很好解决，但是如果是open feign这类对版本控制支持的并不咋样的组件，那我们一般就是采取/v1/v2这种path来区分。比如手机app，老版本新版本要同时支持，但业务差别很大，那么就新app用v2，老app用v1，直到老app强制更新后下线v1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646993787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347583,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1654170555,"is_pvip":false,"replies":[{"id":"126738","content":"如果是串行执行的分布式事务，比如A-&gt;B-&gt;C，当执行到C的时候，A和B可以认为已经完成了Commit操作，所以C如果去捞数据的话，那么读到的就是AB步骤执行过后的数据。<br><br>另外针对全局事务来说，每个分支事务完成事务提交后会上报TC完成状态。","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1654239032,"ip_address":"","comment_id":347583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1654170555","product_id":100101301,"comment_content":"之前看过Seata文档，看了老师的文章后，发现理解更深了，问个问题，关于AT隔离性问题，默认是读提交，这是因为全局事务中，每个分支事务都是直接提交的，所以针对全局事务来说，是需要读到其他事物中部分分支已经提交的事务吗？","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574678,"discussion_content":"如果是串行执行的分布式事务，比如A-&gt;B-&gt;C，当执行到C的时候，A和B可以认为已经完成了Commit操作，所以C如果去捞数据的话，那么读到的就是AB步骤执行过后的数据。\n\n另外针对全局事务来说，每个分支事务完成事务提交后会上报TC完成状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654239032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336749,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1646353541,"is_pvip":true,"replies":[{"id":"123096","content":"1. implements实现接口<br>2. 当年通过mtop来做，自研魔改黑科技。大厂一般都用各种自研产品<br>3. 我对tomcat调优并不精通，但是看这个问题好像出自面试宝典","user_name":"作者回复","user_name_real":"编辑","uid":"2819998","ctime":1646406567,"ip_address":"","comment_id":336749,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1646353541","product_id":100101301,"comment_content":"请教老师几个问题：<br>Q1：接口类指向是什么意思？<br>文中有一句话“将 CouponTemplateServiceImpl 的接口类指向刚定义好的 CouponTemplateServiceTCC 方法”，怎么指向的？<br>Q2：阿里这种级别的公司，其入口是怎么做的？<br>网站最外面的入口，是怎么实现的？现有的外部网关，比如F5、Nginx、LVS等，处理速度都是有限的，对于阿里这种规模的公司，肯定是处理不过来的。那怎么解决这个问题？<br>Q3：tomcat连接数与CPU核数的矛盾问题。<br>tomcat服务器一般能够支持500个连接，好像最大支持1000个连接；一个连接一个线程，那就是500个线程。但一般服务器的CPU核数也就是10个左右。一般的规律是：线程的数量一般是核数的2倍，也就是20个。20个和500个不矛盾吗？","like_count":1,"discussions":[{"author":{"id":2819998,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/07/9e/d2de2832.jpg","nickname":"姚半仙","note":"","ucode":"4C86AA5D6D8C39","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554503,"discussion_content":"1. implements实现接口\n2. 当年通过mtop来做，自研魔改黑科技。大厂一般都用各种自研产品\n3. 我对tomcat调优并不精通，但是看这个问题好像出自面试宝典","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646406567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1165671,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/67/0f74bf61.jpg","nickname":"昵称还没想好。","note":"","ucode":"21E6001F29951B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570129,"discussion_content":"3. 并不矛盾啊；Tomcat 网络IO多路复用模型，一个Reactor线程可以处理多个网络IO连接，再根据连接上的事件(connect, read,write...)转发给相应Worker线程去处理","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651672183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1165671,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/67/0f74bf61.jpg","nickname":"昵称还没想好。","note":"","ucode":"21E6001F29951B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":574597,"discussion_content":"说的没毛病","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654169264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":570129,"ip_address":""},"score":574597,"extra":""}]}]}]}