{"id":134595,"title":"43丨如何使用Redis搭建玩家排行榜？","content":"<p>上一篇文章中，我们使用Redis模拟了多用户抢票的问题，这里再回顾一下原理。我们通过使用WATCH+MULTI的方式实现乐观锁机制，对ticket_count这个键进行监视，当这个键发生变化的时候事务就会被打断，重新请求，这样做的好处就是可以保证事务对键进行操作的原子性，当然我们也可以使用Redis的incr和decr来实现键的原子性递增或递减。</p><p>今天我们用Redis搭建一个玩家的排行榜，假设一个服务器存储了10万名玩家的数据，我们想给这个区（这台服务器）上的玩家做个全区的排名，该如何用Redis实现呢？</p><p>不妨一起来思考下面几个问题：</p><ol>\n<li>MySQL是如何实现玩家排行榜的？有哪些难题需要解决？</li>\n<li>如何用Redis模拟10万名玩家数据？Redis里的Lua又是什么？</li>\n<li>Redis如何搭建玩家排行榜？和MySQL相比有什么优势？</li>\n</ol><h2>使用MySQL搭建玩家排行榜</h2><p>我们如果用MySQL搭建玩家排行榜的话，首先需要生成10万名玩家的数据，这里我们使用之前学习过的存储过程来模拟。</p><p>为了简化，玩家排行榜主要包括3个字段：user_id、score、和create_time，它们分别代表玩家的用户ID、玩家的积分和玩家的创建时间。</p><!-- [[[read_end]]] --><h3>王者荣耀英雄等级说明</h3><p>这里我们可以模拟王者荣耀的英雄等级，具体等级标准如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/f1/4d/f10fb49dde602525a65270c6b2af884d.png?wh=931*444\" alt=\"\"><br>\n如果想要英雄要达到最强王者的段位，那么之前需要积累112颗（9+12+16+25+25+25）星星，而达到最强王者之后还可以继续积累无上限的星星。在随机数模拟上，我们也分成两个阶段，第一个阶段模拟英雄的段位，我们使用随机数来模拟score（数值范围是1-112之间），当score=112的时候，再模拟最强王者等级中的星星个数。如果我们只用一个随机数进行模拟，会出现最强王者的比例变大的情况，显然不符合实际情况。</p><h3>使用存储过程模拟10万名玩家数据</h3><p>这里我们使用存储过程，具体代码如下：</p><pre><code>CREATE DEFINER=`root`@`localhost` PROCEDURE `insert_many_user_scores`(IN START INT(10), IN max_num INT(10))\nBEGIN\nDECLARE i INT DEFAULT 0;\n-- 模拟玩家英雄的星星数\nDECLARE score INT;\nDECLARE score2 INT;\n-- 初始注册时间\nDECLARE date_start DATETIME DEFAULT ('2017-01-01 00:00:00');\n-- 每个玩家的注册时间\nDECLARE date_temp DATETIME;\nSET date_temp = date_start;\nSET autocommit=0;\n \nREPEAT\nSET i=i+1;\nSET date_temp = date_add(date_temp, interval RAND()*60 second);\n-- 1-112随机数\nSET score = CEIL(RAND()*112);\n-- 如果达到了王者，继续模拟王者的星星数\nIF score = 112 THEN\n           SET score2 = FLOOR(RAND()*100);\n           SET score = score + score2;\nEND IF;\n-- 插入新玩家\nINSERT INTO user_score(user_id, score, create_time) VALUES((START+i), score, date_temp); \nUNTIL i = max_num\nEND REPEAT;\nCOMMIT;\nEND\n</code></pre><p>然后我们使用<code>call insert_many_user_scores(10000,100000);</code>模拟生成10万名玩家的得分数据。注意在insert之前，需要先设置<code>autocommit=0</code>，也就是关闭了自动提交，然后在批量插入结束之后再手动进行COMMIT，这样做的好处是可以进行批量提交，提升插入效率。你可以看到整体的用时为5.2秒。</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/5f/2d0a227b72da92e0ab79da59be28915f.png?wh=1288*106\" alt=\"\"></p><p>如上代码所示，我用score来模拟第一阶段的星星数，如果score达到了112再来模拟score2的分数，这里我限定最强王者阶段的星星个数上限为100。同时我们还模拟了用户注册的时间，这是因为排行榜可以有两种表示方式，第二种方式需要用到这个时间。</p><p>第一种表示方式为并列排行榜，也就是分数相同的情况下，允许排名并列，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/2e/6edf318c5f4cbe7b48f6da3b65d2982e.png?wh=937*355\" alt=\"\"><br>\n第二种为严格排行榜。当分数相同的时候，会按照第二条件来进行排序，比如按照注册时间的长短，注册时间越长的排名越靠前。这样的话，上面那个排行榜就会变成如下所示的严格排行榜。</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/7e/6ec6befb0ffbc2a7a8682d309f96217e.png?wh=966*391\" alt=\"\"><br>\n你能看到当10013和10015得分相同的时候，如果按照注册时间来进行排名的话，会将10013排到10015前面。</p><p>上面的数据仅仅为示意，下面我们用实际的10万条数据做一个严格排行榜（你可以点击<a href=\"https://github.com/cystanford/mysql_user_scores\">下载地址</a>下载这10万条数据， 也可以自己使用上面的存储过程来进行模拟）首先使用SQL语句进行查询：</p><pre><code>SELECT (@rownum := @rownum + 1) AS user_rank, user_id, score, create_time\nFROM user_score, (SELECT @rownum := 0) b\nORDER BY score DESC, create_time ASC\n</code></pre><p>运行结果如下（10万条数据，用时0.17s）：</p><p><img src=\"https://static001.geekbang.org/resource/image/14/f8/14d88fd5293ac312e585ec05529473f8.png?wh=1066*439\" alt=\"\"><br>\n这里有几点需要说明。</p><p>MySQL不像Oracle一样自带rownum统计行编号的功能，所以这里我们需要自己来实现rownum功能，也就是设置MySQL的变量<code>@rownum</code>，初始化为<code>@rownum :=0</code>，然后每次SELECT一条数据的时候都自动加1。</p><p>通过开发程序（比如Python、PHP和Java等）统计排名会更方便，这里同样需要初始化一个变量，比如<code>rownum=0</code>，然后每次fetch一条数据的时候都将该变量加1，作为记录的排名。同时，开发程序也可以很方便地实现并列排名，因为程序可以进行上下文的统计，当两名玩家得分相同时，排名相同，否则排名会顺序加1。</p><p>如果想要通过SQL来实现，可以写成下面这样：</p><pre><code>SELECT user_id, score,\n    IFNULL((SELECT COUNT(*) FROM user_score WHERE score &gt; t.score), 0) + 1 AS user_rank  \nFROM user_score t\nORDER BY user_rank ASC\n</code></pre><p>这样做的原理是查找比当前分数大的数据行数，然后加1，但是这样执行效率会很低，相当于需要对每个玩家都统计一遍排名。</p><h2>Lua是什么，如何在Redis中使用</h2><p>知道如何用MySQL模拟数据后，我们再来看下如何在Redis中完成这一步。事实上，Redis本身不提供存储过程的功能，不过在2.6版本之后集成了Lua语言，可以很方便地实现类似存储过程的函数调用方式。</p><p>Lua是一个小巧的脚本语言，采用标准C语言编写，一个完整的Lua解析器大小只有200K。我们之前讲到过采用标准C语言编写的好处就在于执行效率高，依懒性低，同时兼容性好，稳定性高。这些特性同样Lua也有，它可以嵌入到各种应用程序中，提供灵活的扩展和定制功能。</p><h3>如何在Redis中使用Lua</h3><p>在Redis中使用Lua脚本的命令格式如下：</p><pre><code>EVAL script numkeys key [key ...] arg [arg ...]\n</code></pre><p>我来说明下这些命令中各个参数代表的含义。</p><ol>\n<li>script，代表的是Lua的脚本内容。</li>\n<li>numkeys，代表后续参数key的个数。</li>\n<li>key就是我们要操作的键，可以是多个键。我们在Lua脚本中可以直接使用这些key，直接通过<code>KEYS[1]</code>、<code>KEYS[2]</code>来获取，默认下标是从1开始。</li>\n<li>arg，表示传入到Lua脚本中的参数，就像调用函数传入的参数一样。在Lua脚本中我们可以通过<code>ARGV[1]</code>、<code>ARGV[2]</code>来进行获取，同样默认下标从1开始。</li>\n</ol><p>下面我们通过2个例子来体会下，比如我们使用eval <code>\"return {ARGV[1], ARGV[2]}\" 0 cy 123</code>，代表的是传入的key的个数为0，后面有两个arg，分别为cy和123。在Lua脚本中，我们直接返回这两个参数<code>ARGV[1]</code>, <code>ARGV[2]</code>，执行结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/76/f8b92089f5eed056fdf49eae53c2d576.png?wh=1453*159\" alt=\"\"><br>\n比如我们要用这一条语句：</p><pre><code>eval &quot;math.randomseed(ARGV[1]); local temp = math.random(1,112); redis.call('SET', KEYS[1], temp); return 'ok';&quot; 1 score 30\n</code></pre><p>这条语句代表的意思是，我们传入KEY的个数为1，参数是score，arg参数为30。在Lua脚本中使用<code>ARGV[1]</code>，也就是30作为随机数的种子，然后创建本地变量temp等于1到112之间的随机数，再使用SET方法对KEY，也就是用刚才创建的随机数对score这个字段进行赋值，结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/b5/be/b569fe5c81ae82bd8e38cc2a93df72be.png?wh=1730*233\" alt=\"\"><br>\n然后我们在Redis中使用<code>GET score</code>对刚才设置的随机数进行读取，结果为34。</p><p>另外我们还可以在命令中调用Lua脚本，使用的命令格式：</p><pre><code>redis-cli --eval lua_file key1 key2 , arg1 arg2 arg3\n</code></pre><p>使用redis-cli的命令格式不需要输入key的个数，在key和arg参数之间采用了逗号进行分割，注意逗号前后都需要有空格。同时在eval后面可以带一个lua文件（以.lua结尾）。</p><h2>使用Lua创建10万名玩家数据</h2><p>如果我们想要通过Lua脚本创建10万名玩家的数据，文件名为<code>insert_user_scores.lua</code>，代码如下：</p><pre><code>--设置时间种子\nmath.randomseed(ARGV[1]) \n-- 设置初始的生成时间\nlocal create_time = 1567769563 - 3600*24*365*2.0 \nlocal num = ARGV[2]\nlocal user_id = ARGV[3]\nfor i=1, num do\n  --生成1到60之间的随机数\n  local interval = math.random(1, 60) \n  --产生1到112之间的随机数\n  local temp = math.random(1, 112) \n  if (temp == 112) then\n        --产生0到100之间的随机数\n        temp = temp + math.random(0, 100) \n  end\n  create_time = create_time + interval\n  temp = temp + create_time / 10000000000\n  redis.call('ZADD', KEYS[1], temp, user_id+i-1)\nend\nreturn 'Generation Completed'\n</code></pre><p>上面这段代码可以实现严格排行榜的排名，具体方式是将score进行了改造，score 为浮点数。整数部分为得分，小数部分为时间差。</p><p>在调用的时候，我们通过<code>ARGV[1]</code>获取时间种子的参数，传入的<code>KEYS[1]</code>为<code>user_score</code>，也就是创建有序集合<code>user_score</code>。然后通过num来设置生成玩家的数量，通过<code>user_id</code>获取初始的<code>user_id</code>。最后调用如下命令完成玩家数据的创建：</p><pre><code>redis-cli -h localhost -p 6379 --eval insert_user_scores.lua user_score , 30 100000 10000\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/ba/94/ba8fcef75a2ea951dd31d9f7e266d094.png?wh=1729*159\" alt=\"\"></p><h3>使用Redis实现玩家排行榜</h3><p>我们通过Lua脚本模拟完成10万名玩家数据，并将其存储在了Redis的有序集合<code>user_score</code>中，下面我们就来使用Redis来统计玩家排行榜的数据。</p><p>首先我们需要思考的是，一个典型的游戏排行榜都包括哪些功能呢？</p><ol>\n<li>统计全部玩家的排行榜</li>\n<li>按名次查询排名前N名的玩家</li>\n<li>查询某个玩家的分数</li>\n<li>查询某个玩家的排名</li>\n<li>对玩家的分数和排名进行更新</li>\n<li>查询指定玩家前后M名的玩家</li>\n<li>增加或移除某个玩家，并对排名进行更新</li>\n</ol><p>在Redis中实现上面的功能非常简单，只需要使用Redis我们提供的方法即可，针对上面的排行榜功能需求，我们分别来看下Redis是如何实现的。</p><h3>统计全部玩家的排行榜</h3><p>在Redis里，统计全部玩家的排行榜的命令格式为<code>ZREVRANGE 排行榜名称 起始位置 结束位置 [WITHSCORES]</code>。</p><p>我们使用这行命令即可：</p><pre><code>ZREVRANGE user_score 0 -1 WITHSCORES\n</code></pre><p>我们对玩家排行榜<code>user_score</code>进行统计，其中-1代表的是全部的玩家数据，<code>WITHSCORES</code>代表的是输出排名的同时也输出分数。</p><h3>按名次查询排名前N名的玩家</h3><p>同样我们可以使用<code>ZREVRANGE</code>完成前N名玩家的排名，比如我们想要统计前10名玩家，可以使用：<code>ZREVRANGE user_score 0 9</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/3c/2e87be9528653b388f8a3dabedfcf23c.png?wh=1016*566\" alt=\"\"></p><h3>查询某个玩家的分数</h3><p>命令格式为<code>ZSCORE 排行榜名称 玩家标识</code>。</p><p>时间复杂度为<code>O(1)</code>。</p><p>如果我们想要查询玩家10001的分数可以使用：<code>ZSCORE user_score 10001</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/74/95/742b794aa98bb9cf100cce8070a8f295.png?wh=1000*106\" alt=\"\"></p><h3>查询某个玩家的排名</h3><p>命令格式为<code>ZREVRANK 排行榜名称 玩家标识</code>。</p><p>时间复杂度为<code>O(log(N))</code>。</p><p>如果我们想要查询玩家10001的排名可以使用：<code>ZREVRANK user_score 10001</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/c8/1f/c8a13f56fc4e151dd9804a9e317da91f.png?wh=1044*106\" alt=\"\"></p><h3>对玩家的分数进行更新，同时排名进行更新</h3><p>如果我们想要对玩家的分数进行增减，命令格式为<code>ZINCRBY 排行榜名称 分数变化 玩家标识</code>。</p><p>时间复杂度为<code>O(log(N))</code>。</p><p>比如我们想对玩家10001的分数减1，可以使用：<code>ZINCRBY user_score -1 10001</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/a6/14/a644a5aa7019b1cb3b7602bca4749614.png?wh=1091*113\" alt=\"\"><br>\n然后我们再来查看下玩家10001的排名，使用：<code>ZREVRANK user_score 10001</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/51/54/51256aa0c27547ae508fc05049b2d554.png?wh=1034*109\" alt=\"\"><br>\n你能看到排名由17153降到了18036名。</p><h3>查询指定玩家前后M名的玩家</h3><p>比如我们想要查询玩家10001前后5名玩家都是谁，当前已知玩家10001的排名是18036，那么可以使用：<code>ZREVRANGE user_score 18031 18041</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/54/91/54eae0a13dea61d15752469c9d42e591.png?wh=1216*613\" alt=\"\"><br>\n这样就可以得到玩家10001前后5名玩家的信息。</p><p><strong>增加或删除某个玩家，并对排名进行更新</strong></p><p>如果我们想要删除某个玩家，命令格式为<code>ZREM 排行榜名称 玩家标识</code>。</p><p>时间复杂度为<code>O(log(N))</code>。</p><p>比如我们想要删除玩家10001，可以使用：<code>ZREM user_score 10001</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/d4/fee0dc8d42ca239427fe136375bda0d4.png?wh=941*113\" alt=\"\"><br>\n这样我们再来查询下排名在18031到18041的玩家是谁，使用：<code>ZREVRANGE user_score 18031 18041</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/c0/85/c06a95d1ef82cd215698585a40d91b85.png?wh=1206*603\" alt=\"\"><br>\n你能看到玩家10001的信息被删除，同时后面的玩家排名都向前移了一位。</p><p>如果我们想要增加某个玩家的数据，命令格式为<code>ZADD 排行榜名称 分数 玩家标识</code>。</p><p>时间复杂度为<code>O(log(N))</code>。</p><p>这里，我们把玩家10001的信息再增加回来，使用：<code>ZADD user_score 93.1504697596 10001</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/37/a3586cd0a7819d01226e5daaf2234d37.png?wh=1297*106\" alt=\"\"><br>\n然后我们再来看下排名在18031到18041的玩家是谁，使用：<code>ZREVRANGE user_score 18031 18041</code>。</p><p><img src=\"https://static001.geekbang.org/resource/image/18/ec/18de0c19c2dfb777632c8d0edd6e3bec.png?wh=1216*606\" alt=\"\"><br>\n你能看到插入了玩家10001的数据之后，排名又回来了。</p><h2>总结</h2><p>今天我们使用MySQL和Redis搭建了排行榜，根据相同分数的处理方式，我们可以把排行榜分成并列排行榜和严格排行榜。虽然MySQL和Redis都可以搭建排行榜，但两者还是有区别的。MySQL擅长存储数据，而对于数据的运算来说则效率不高，比如统计排行榜的排名，通常还是需要使用后端语言（比如Python、PHP、Java等）再进行统计。而Redis本身提供了丰富的排行榜统计功能，不论是增加、删除玩家，还是对某个玩家的分数进行调整，Redis都可以对排行榜实时更新，对于游戏的实时排名来说，这还是很重要的。</p><p>在Redis中还集成了Lua脚本语言，通过Lua我们可以更加灵活地扩展Redis的功能，同时在Redis中使用Lua语言，还可以对Lua脚本进行复用，减少网络开销，编写代码也更具有模块化。此外Redis在调用Lua脚本的时候，会将它作为一个整体，也就是说中间如果有其他的Redis命令是不会被插入进去的，也保证了Lua脚本执行过程中不会被其他命令所干扰。</p><p><img src=\"\" alt=\"\"></p><p>我们今天使用Redis对10万名玩家的数据进行了排行榜的统计，相比于用RDBMS实现排行榜来说，使用Redis进行统计都有哪些优势呢？</p><p>我们使用了Lua脚本模拟了10万名玩家的数据，其中玩家的分数score分成了两个部分，整数部分为实际的得分，小数部分为注册时间。例子中给出的严格排行榜是在分数相同的情况下，按照注册时间的长短进行的排名，注册时间长的排名靠前。如果我们将规则进行调整，同样是在分数相同的情况下，如果注册时间长的排名靠后，又该如何编写代码呢？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流一下。</p>","neighbors":{"left":{"article_title":"42丨如何使用Redis来实现多用户抢票问题","id":132851},"right":{"article_title":"44丨DBMS篇总结和答疑：用SQLite做词云","id":138317}},"comments":[{"had_liked":false,"id":132840,"user_name":"石维康","can_delete":false,"product_type":"c1","uid":1067564,"ip_address":"","ucode":"E39ED8416B2C01","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","comment_is_top":false,"comment_ctime":1568250114,"is_pvip":false,"replies":[{"id":"62730","content":"不错的方法 哈哈","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1577087199,"ip_address":"","comment_id":132840,"utype":1}],"discussion_count":3,"race_medal":0,"score":"48812890370","product_id":100029501,"comment_content":"在生成数据时,把&quot;temp = temp + create_time &#47; 10000000000&quot;换成 temp = temp +1 - create_time &#47; 10000000000 哈哈","like_count":11,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467140,"discussion_content":"不错的方法 哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577087199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1524154,"avatar":"https://static001.geekbang.org/account/avatar/00/17/41/ba/ae028565.jpg","nickname":"YqY","note":"","ucode":"73FB936045DCB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215501,"discussion_content":"没看明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585325855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1524154,"avatar":"https://static001.geekbang.org/account/avatar/00/17/41/ba/ae028565.jpg","nickname":"YqY","note":"","ucode":"73FB936045DCB9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278159,"discussion_content":"类似于减数变大了（即注册时间长的那个），你得到的值就更小了，所以排名就更靠后了，你可以自己带入具体数字算一下就知道。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591156853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215501,"ip_address":""},"score":278159,"extra":""}]}]},{"had_liked":false,"id":132784,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1568219150,"is_pvip":false,"replies":[{"id":"53369","content":"通常一个功能用一种DBMS即可，所以会用到有序集合的member保存id和name。因为这些数据是需要高频访问的，所以放到redis中会更适合。如果想要查询更具体的数据，需要用户点击排行榜中的某个玩家的时候，可以使用MySQL来处理，比如查看这个玩家具体使用过哪些英雄，具体战绩如何等。","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1570429312,"ip_address":"","comment_id":132784,"utype":1}],"discussion_count":5,"race_medal":1,"score":"48812859406","product_id":100029501,"comment_content":"感觉用redis，最终还是需要结合程序以及MySQL来处理，因为排行榜展示，前端还是需要用户名的，光给个用户id不知道是谁，除非redis有序集合的member包含了用户id和name，请指正。","like_count":11,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467118,"discussion_content":"通常一个功能用一种DBMS即可，所以会用到有序集合的member保存id和name。因为这些数据是需要高频访问的，所以放到redis中会更适合。如果想要查询更具体的数据，需要用户点击排行榜中的某个玩家的时候，可以使用MySQL来处理，比如查看这个玩家具体使用过哪些英雄，具体战绩如何等。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570429312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1527530,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/lfMbV8RibrhFxjILg4550cZiaay64mTh5Zibon64TiaicC8jDMEK7VaXOkllHSpS582Jl1SUHm6Jib2AticVlHibiaBvUOA/132","nickname":"用0和1改变自己","note":"","ucode":"42B8F6ECF6BDD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10132,"discussion_content":"我也觉的，数据肯定也要有一份在MySQL数据库里，不然Redis的数据没了咋办，Redis和数据库的数据如何同步也是一个问题，希望老师能讲解下，或给个思路","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568266430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1217638,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/66/667d46fa.jpg","nickname":"莫名","note":"","ucode":"D32218FF34C986","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1527530,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/lfMbV8RibrhFxjILg4550cZiaay64mTh5Zibon64TiaicC8jDMEK7VaXOkllHSpS582Jl1SUHm6Jib2AticVlHibiaBvUOA/132","nickname":"用0和1改变自己","note":"","ucode":"42B8F6ECF6BDD0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202021,"discussion_content":"可以考虑使用cache aside的缓存更新策略，先更新数据库数据，然后让缓存失效。不过在这个排行榜的例子中感觉还是有问题的，因为很可能绝大部分查询最终还是落到了数据库上(因为用户积分数据更新频繁)，就算分读写库又会面临数据更新问题。没有特别必要，感觉还是从业务上来解决比较好，例如排行榜的更新变成定时更新，这样的话就能很好地利用缓存了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583854067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":10132,"ip_address":""},"score":202021,"extra":""}]},{"author":{"id":1350608,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9b/d0/86aee34c.jpg","nickname":"刘凯","note":"","ucode":"EFDC932CAE61A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210867,"discussion_content":"redis排行榜，已学打卡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584784397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1309984,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fd/20/2761ef0e.jpg","nickname":"cheriston","note":"","ucode":"617CBFCE0925C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29350,"discussion_content":"老师，如何设计redis的cache方案，设计冷热数据方案？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570763377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132592,"user_name":"JustDoDT","can_delete":false,"product_type":"c1","uid":1127175,"ip_address":"","ucode":"6AF0B80F00EAEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","comment_is_top":false,"comment_ctime":1568170139,"is_pvip":false,"replies":[{"id":"63501","content":"Good Job","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1577514945,"ip_address":"","comment_id":132592,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23043006619","product_id":100029501,"comment_content":"注册时间排名靠后MySQL语法：create_time按照降序排列。<br>SELECT (@rownum := @rownum + 1) AS user_rank, user_id, score, create_time<br>FROM user_score, (SELECT @rownum := 0) b<br>ORDER BY score DESC, create_time DESC<br>","like_count":5,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467025,"discussion_content":"Good Job","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577514945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196251,"user_name":"博弈","can_delete":false,"product_type":"c1","uid":1433344,"ip_address":"","ucode":"B1A69837E41972","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/EcYNib1bnDf5dz6JcrE8AoyZYMdqic2VNmbBtCcVZTO9EoDZZxqlQDEqQKo6klCCmklOtN9m0dTd2AOXqSneJYLw/132","comment_is_top":false,"comment_ctime":1585267335,"is_pvip":false,"replies":[{"id":"76635","content":"对的","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1586523024,"ip_address":"","comment_id":196251,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175201927","product_id":100029501,"comment_content":"Redis在实现排行榜方面优势显著，有现成命令且在内存操作，速度快","like_count":2,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489250,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586523024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133225,"user_name":"felix","can_delete":false,"product_type":"c1","uid":1086157,"ip_address":"","ucode":"DF514D0BB9B508","user_header":"https://static001.geekbang.org/account/avatar/00/10/92/cd/d39e568c.jpg","comment_is_top":false,"comment_ctime":1568452028,"is_pvip":false,"replies":[{"id":"76638","content":"感谢提问，where INET_ATON(t.ip_address) between i.start_int and i.end_int<br>这里会对i.start_int 和 i.end_int进行比较。所以如果设置了联合索引KEY `ip_range_int` (`start_int`,`end_int`) USING BTREE 是不会起作用的，因为联合索引具有最左匹配原则<br><br>下面 add index indx_t_dt_ip_start_int (start_int)，说明对单个字段start_int 创建了index，所以在possible_keys 中存在start_int。具体是否需要索引MySQL还是会根据实际情况来判断，因为每次比较是判断where t.ip_address &gt;= i.start_int 这里会和根据t.ip_address以及i.start_int的数据分布情况而定，如果MySQL认为这需要扫描大部分索引，因此意义不大时就不会采用索引字段start_int<br>","user_name":"作者回复","user_name_real":"cy","uid":"1306094","ctime":1586524212,"ip_address":"","comment_id":133225,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10158386620","product_id":100029501,"comment_content":"咨询老师一个关于ip匹配的索引问题：<br>有一个IP的库表，每一条记录了一个开始ip和结束ip，然后想批量匹配ip，查询为何没有用上“联合索引KEY `ip_range_int` (`start_int`,`end_int`) USING BTREE”？要怎么设置索引才有效？<br>CREATE TABLE `t_dt_ip` (<br>  `id` int(11) NOT NULL AUTO_INCREMENT,<br>  `start_ip` char(15) DEFAULT NULL,<br>  `end_ip` char(15) DEFAULT NULL,<br>  `location` varchar(100) DEFAULT NULL,<br>  `start_int` int(10) unsigned DEFAULT &#39;0&#39;,<br>  `end_int` int(10) unsigned DEFAULT &#39;0&#39;,<br>  PRIMARY KEY (`id`),<br>  KEY `ip_range` (`start_ip`,`end_ip`) USING BTREE,<br>  KEY `ip_range_int` (`start_int`,`end_int`) USING BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;<br><br>explain  update t_tmp_ip t, t_dt_ip i  <br>set t.ip_id = i.id<br>where INET_ATON(t.ip_address) between i.start_int and i.end_int;<br>| id | select_type | table | partitions | type | possible_keys                       | key  | key_len | ref  | rows   | filtered | Extra                                          |<br>|  1 | UPDATE      | t     | NULL       | ALL  | NULL                                | NULL | NULL    | NULL |   1000 |   100.00 | NULL                                           |<br>|  1 | SIMPLE      | i     | NULL       | ALL  | ip_range_int      | NULL | NULL    | NULL | 541942 |    11.11 | Range checked for each record (index map: 0xC) |<br><br>甚至加上单个字段索引也没有用？？<br>alter table `t_dt_ip` add index indx_t_dt_ip_start_int (start_int);<br>mysql&gt; explain select * from t_dt_ip i join t_tmp_ip t on 1= 1 where t.ip_address &gt;= i.start_int limit 1;<br>| id | select_type | table | partitions | type | possible_keys                       | key  | key_len | ref  | rows   | filtered | Extra                                          |<br>|  1 | SIMPLE      | t     | NULL       | ALL  | NULL                                | NULL | NULL    | NULL |  73126 |   100.00 | NULL                                           |<br>|  1 | SIMPLE      | i     | NULL       | ALL  | ip_range_int,indx_t_dt_ip_start_int | NULL | NULL    | NULL | 541942 |    33.33 | Range checked for each record (index map: 0xC) |<br>","like_count":2,"discussions":[{"author":{"id":1306094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ed/ee/c4779b67.jpg","nickname":"cy","note":"","ucode":"50D653399A31F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467304,"discussion_content":"感谢提问，where INET_ATON(t.ip_address) between i.start_int and i.end_int\n这里会对i.start_int 和 i.end_int进行比较。所以如果设置了联合索引KEY `ip_range_int` (`start_int`,`end_int`) USING BTREE 是不会起作用的，因为联合索引具有最左匹配原则\n\n下面 add index indx_t_dt_ip_start_int (start_int)，说明对单个字段start_int 创建了index，所以在possible_keys 中存在start_int。具体是否需要索引MySQL还是会根据实际情况来判断，因为每次比较是判断where t.ip_address &amp;gt;= i.start_int 这里会和根据t.ip_address以及i.start_int的数据分布情况而定，如果MySQL认为这需要扫描大部分索引，因此意义不大时就不会采用索引字段start_int\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586524212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355513,"user_name":"白菜炒五花肉","can_delete":false,"product_type":"c1","uid":1519828,"ip_address":"上海","ucode":"0D4CBD221C2880","user_header":"https://static001.geekbang.org/account/avatar/00/17/30/d4/6eb8f5af.jpg","comment_is_top":false,"comment_ctime":1661439825,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661439825","product_id":100029501,"comment_content":"ERR Error running script (call to f_84b63a152215a96efa70b8935ae3d2b0e5ab93d1): @user_script:3: user_script:3: bad argument #1 to &#39;randomseed&#39; (number expected, got nil) 老师，使用redis创建10w名玩家数据，执行lua脚本，报这个错误是啥问题","like_count":0},{"had_liked":false,"id":296862,"user_name":"完美坚持","can_delete":false,"product_type":"c1","uid":1919541,"ip_address":"","ucode":"AE0261D8DDEF64","user_header":"https://static001.geekbang.org/account/avatar/00/1d/4a/35/66caeed9.jpg","comment_is_top":false,"comment_ctime":1623206114,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1623206114","product_id":100029501,"comment_content":"为什么<br>查询某个玩家的排名<br>对玩家的分数和排名进行更新<br>查询指定玩家前后 M 名的玩家<br>增加或移除某个玩家，并对排名进行更新<br>的时间复杂度都是O(log(N))，这和有序集合的数据存储结构有关吗？老师能不能简单解释一下，或者给个链接<br>","like_count":0,"discussions":[{"author":{"id":2725137,"avatar":"https://static001.geekbang.org/account/avatar/00/29/95/11/e7ada34e.jpg","nickname":"听晨","note":"","ucode":"E6332436389C6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390644,"discussion_content":"和Redis的存储结构采用跳表有关，前面有用户提到，具体原理可参考\nhttps://www.cnblogs.com/yuanfang0903/p/12165394.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629949446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}