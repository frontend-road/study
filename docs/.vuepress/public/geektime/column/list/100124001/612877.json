{"id":612877,"title":"28｜调度引擎：负载均衡与调度器实战","content":"<p>你好，我是郑建勋。</p><p>在上一节课程中，我们实战了广度优先搜索算法，不过我们对网站的爬取都是在一个协程中进行的。在真实的实践场景中，我们常常需要爬取多个初始网站，我们希望能够同时爬取这些网站。这就需要合理调度和组织爬虫任务了。因此，这节课的重点就是实战任务调度的高并发模型，使资源得到充分的利用。</p><h2>实战调度引擎</h2><p>首先，我们新建一个文件夹engine用于存储调度引擎的代码，核心的调度逻辑位于ScheduleEngine.Run中。这部分的完整代码位于 <a href=\"https://github.com/dreamerjackson/crawler\">tag v0.1.4</a>，你可以对照代码进行查看。</p><p>调度引擎主要目标是完成下面几个功能：</p><ol>\n<li>创建调度程序，接收任务并将任务存储起来；</li>\n<li>执行调度任务，通过一定的调度算法将任务调度到合适的worker中执行；</li>\n<li>创建指定数量的worker，完成实际任务的处理；</li>\n<li>创建数据处理协程，对爬取到的数据进行进一步处理。</li>\n</ol><pre><code class=\"language-plain\">func (s *ScheduleEngine) Run() {\n\trequestCh := make(chan *collect.Request)\n\tworkerCh := make(chan *collect.Request)\n\tout := make(chan collect.ParseResult)\n\ts.requestCh = requestCh\n\ts.workerCh = workerCh\n\ts.out = out\n\tgo s.Schedule()\n}\n</code></pre><!-- [[[read_end]]] --><p>Run方法首先初始化了三个通道。其中，requestCh负责接收请求，workerCh负责分配任务给worker，out负责处理爬取后的数据，完成下一步的存储操作。schedule函数会创建调度程序，负责的是调度的核心逻辑。</p><p>第一步我们来看看schedule函数如何接收任务并完成任务的调度。</p><p>schedule函数如下所示，其中，requestCh通道接收来自外界的请求，并将请求存储到reqQueue队列中。workerCh通道负责传送任务，后面每一个worker将获取该通道的内容，并执行对应的操作。</p><p>在这里，我们使用了for语句，让调度器循环往复地获取外界的爬虫任务，并将任务分发到worker中。如果任务队列reqQueue大于0，意味着有爬虫任务，这时我们获取队列中第一个任务，并将其剔除出队列。最后ch &lt;- req 会将任务发送到workerCh通道中，等待worker接收。</p><pre><code class=\"language-plain\">func (s *Schedule) Schedule() {\n\tvar reqQueue = s.Seeds\n\tgo func() {\n\t\tfor {\n\t\t\tvar req *collect.Request\n\t\t\tvar ch chan *collect.Request\n\n\t\t\tif len(reqQueue) &gt; 0 {\n\t\t\t\treq = reqQueue[0]\n\t\t\t\treqQueue = reqQueue[1:]\n\t\t\t\tch = s.workerCh\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase r := &lt;-s.requestCh:\n\t\t\t\treqQueue = append(reqQueue, r)\n\n\t\t\tcase ch &lt;- req:\n\t\t\t}\n\t\t}\n\t}()\n}\n</code></pre><p>通道还有一个特性，就是我们往nil通道中写入数据会陷入到堵塞的状态。因此，如果reqQueue为空，这时req和ch都是nil，当前协程就会陷入到堵塞的状态，直到接收到新的请求才会被唤醒。</p><p>我们可以用一个例子来验证这一特性：</p><pre><code class=\"language-plain\">func main() {\n\tvar ch chan *int\n\tgo func() {\n\t\t&lt;-ch\n\t}()\n\tselect {\n\tcase ch &lt;- nil:\n\t\tfmt.Println(\"it's time\")\n\t}\n}\n</code></pre><p>在这个例子中，运行后会出现死锁，因为当前程序全部陷入到了无限堵塞的状态。</p><pre><code class=\"language-plain\">fatal error: all goroutines are asleep - deadlock!\n</code></pre><p>调度引擎除了启动schedule函数，还需要安排多个实际干活的worker程序。</p><p>下一步，让我们创建指定数量的worker，完成实际任务的处理。其中WorkCount为执行任务的数量，可以灵活地去配置。</p><pre><code class=\"language-plain\">func (s *ScheduleEngine) Run() {\n\t...\n\tgo s.Schedule()\n\tfor i := 0; i &lt; s.WorkCount; i++ {\n\t\tgo s.CreateWork()\n\t}\n}\n</code></pre><p>这里的 CreateWork 创建出实际处理任务的函数，它又细分为下面几个步骤：</p><ul>\n<li>←s.workerCh接收到调度器分配的任务；</li>\n<li>s.fetcher.Get 访问服务器，r.ParseFunc 解析服务器返回的数据；</li>\n<li>s.out ← result 将返回的数据发送到out通道中，方便后续的处理。</li>\n</ul><pre><code class=\"language-plain\">func (s *Schedule) CreateWork() {\n\tfor {\n\t\tr := &lt;-s.workerCh\n\t\tbody, err := s.Fetcher.Get(r)\n\t\tif err != nil {\n\t\t\ts.Logger.Error(\"can't fetch \",\n\t\t\t\tzap.Error(err),\n\t\t\t)\n\t\t\tcontinue\n\t\t}\n\t\tresult := r.ParseFunc(body, r)\n\t\ts.out &lt;- result\n\t}\n}\n</code></pre><p>最后一步，我们需要单独安排一个函数来处理爬取并解析后的数据结构，完整的函数如下：</p><pre><code class=\"language-plain\">func (s *Schedule) HandleResult() {\n\tfor {\n\t\tselect {\n\t\tcase result := &lt;-s.out:\n\t\t\tfor _, req := range result.Requesrts {\n\t\t\t\ts.requestCh &lt;- req\n\t\t\t}\n\t\t\tfor _, item := range result.Items {\n\t\t\t\t// todo: store\n\t\t\t\ts.Logger.Sugar().Info(\"get result\", item)\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre><p>在HandleResult函数中，&lt;-s.out接收所有worker解析后的数据，其中要进一步爬取的Requests列表将全部发送回s.requestCh通道，而result.Items里包含了我们实际希望得到的结果，所以我们先用日志把结果打印出来。</p><p>最后，让我们用之前介绍的爬取豆瓣小组的例子来验证调度器的功能。</p><p>在main函数中，生成初始网址列表作为种子任务。构建engine.Schedule，设置worker的数量，采集器Fetcher和日志Logger，并调用s.Run()运行调度器。</p><pre><code class=\"language-plain\"> func main(){\n\t\tvar seeds []*collect.Request\n\t\tfor i := 0; i &lt;= 0; i += 25 {\n\t\t\tstr := fmt.Sprintf(\"&lt;https://www.douban.com/group/szsh/discussion?start=%d&gt;\", i)\n\t\t\tseeds = append(seeds, &amp;collect.Request{\n\t\t\t\tUrl:       str,\n\t\t\t\tWaitTime:  1 * time.Second,\n\t\t\t\tCookie:    \"xxx\",\n\t\t\t\tParseFunc: doubangroup.ParseURL,\n\t\t\t})\n\t\t}\n\t\n\t\tvar f collect.Fetcher = &amp;collect.BrowserFetch{\n\t\t\tTimeout: 3000 * time.Millisecond,\n\t\t\tLogger:  logger,\n\t\t\tProxy:   p,\n\t\t}\n\t\n\t\ts := engine.Schedule{\n\t\t\tWorkCount: 5,\n\t\t\tLogger:    logger,\n\t\t\tFetcher:   f,\n\t\t\tSeeds:     seeds,\n\t\t}\n\t\ts.Run()\n}\n\n</code></pre><p>输出结果为：</p><pre><code class=\"language-plain\">{\"level\":\"INFO\",\"ts\":\"2022-10-19T00:55:54.281+0800\",\"caller\":\"engine/schedule.go:78\",\"msg\":\"get result: &lt;https://www.douban.com/group/topic/276978032/&gt;\"}\n{\"level\":\"INFO\",\"ts\":\"2022-10-19T00:55:54.355+0800\",\"caller\":\"engine/schedule.go:78\",\"msg\":\"get result: &lt;https://www.douban.com/group/topic/276973871/&gt;\"}\n</code></pre><h2>函数式选项模式</h2><p>在上面的例子中，我们初始化engine.Schedule时将一系列的参数传递到了结构体当中。在实践中可能会有几十个参数等着我们赋值，从面向对象的角度来看，不同参数的灵活组合可能会带来不同的调度器类型。在实践中为了方便使用，开发者可能会创建非常多的 API 来满足不同场景的需要，如下所示：</p><pre><code class=\"language-plain\">// 基本调度器\nfunc NewBaseSchedule() *Schedule {\n\treturn &amp;Schedule{\n\t\tWorkCount: 1,\n\t\tFetcher：baseFetch,\n\t}\n}\n// 多worker调度器\nfunc NewMultiWorkSchedule(workCount int) *Schedule {\n\treturn &amp;Schedule{\n\t\tWorkCount: workCount,\n\t\tFetcher：baseFetch,\n\t}\n}\n\n// 代理调度器\nfunc NewProxySchedule(proxy string) *Schedule {\n\treturn &amp;Schedule{\n\t\tWorkCount: 1,\n\t\tFetcher：proxyFetch(proxy),\n\t}\n}\n</code></pre><p>随着参数的不断增多，这种API会变得越来越多，这就增加了开发者的心理负担。</p><p>另一种使用方式就是传递一个统一的Config配置结构，如下所示。这种方式只需要创建单个API，但是需要在内部对所有的变量进行判断，繁琐且不优雅。对于使用者来说，也很难确定自己需要使用哪一个字段。</p><pre><code class=\"language-plain\">type Config struct {\n\tWorkCount int\n\tFetcher   collect.Fetcher\n\tLogger    *zap.Logger\n\tSeeds     []*collect.Request\n}\n\nfunc NewSchedule(c *Config) *Schedule {\n\tvar s = &amp;Schedule{}\n\tif c.Seeds != nil {\n\t\ts.Seeds = c.Seeds\n\t}\n\tif c.Fetcher != nil {\n\t\ts.Fetcher = c.Fetcher\n\t}\n\n\tif c.Logger != nil {\n\t\ts.Logger = c.Logger\n\t}\n\t...\n\treturn s\n}\n</code></pre><p>那么有没有方法可以更加优雅地处理这种多参数配置问题呢？</p><p>Rob Pike 在2014年的<a href=\"https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html\">一篇博客中</a>提到了一种优雅的处理方法叫做<strong>函数式选项模式(Functional Options)。</strong>这种模式展示了闭包函数的有趣用途，目前在很多开源库中都能看到它的身影，我们项目中使用的日志库 Zap 也使用了这种模式。下面我以上面schedule的配置为例来说明函数式选项模式（完整代码请查看<a href=\"https://github.com/dreamerjackson/crawler\">tag v0.1.5</a>）。</p><p><strong>第一步，</strong>我们要对schedule结构进行改造，把可以配置的参数放入到<code>options</code> 结构中：</p><pre><code class=\"language-plain\">type Schedule struct {\n\trequestCh chan *collect.Request\n\tworkerCh  chan *collect.Request\n\tout       chan collect.ParseResult\n\toptions\n}\n\ntype options struct {\n\tWorkCount int\n\tFetcher   collect.Fetcher\n\tLogger    *zap.Logger\n\tSeeds     []*collect.Request\n}\n</code></pre><p><strong>第二步，</strong>我们需要书写一系列的闭包函数，这些函数的返回值是一个参数为 <code>options</code> 的函数：</p><pre><code class=\"language-plain\">\ntype Option func(opts *options)\n\nfunc WithLogger(logger *zap.Logger) Option {\n\treturn func(opts *options) {\n\t\topts.Logger = logger\n\t}\n}\nfunc WithFetcher(fetcher collect.Fetcher) Option {\n\treturn func(opts *options) {\n\t\topts.Fetcher = fetcher\n\t}\n}\n\nfunc WithWorkCount(workCount int) Option {\n\treturn func(opts *options) {\n\t\topts.WorkCount = workCount\n\t}\n}\n\nfunc WithSeeds(seed []*collect.Request) Option {\n\treturn func(opts *options) {\n\t\topts.Seeds = seed\n\t}\n}\n</code></pre><p><strong>第三步，</strong>创建一个生成schedule的新函数，函数参数为Option的可变参数列表。defaultOptions为默认的Option，代表默认的参数列表，然后循环遍历可变函数参数列表并执行。</p><pre><code class=\"language-plain\">func NewSchedule(opts ...Option) *Schedule {\n\toptions := defaultOptions\n\tfor _, opt := range opts {\n\t\topt(&amp;options)\n\t}\n\ts := &amp;Schedule{}\n\ts.options = options\n\treturn s\n}\n</code></pre><p><strong>第四步，</strong>在main函数中调用NewSchedule。让我们来看看函数式选项模式的效果：</p><pre><code class=\"language-plain\">func main(){\n\ts := engine.NewSchedule(\n\t\t\tengine.WithFetcher(f),\n\t\t\tengine.WithLogger(logger),\n\t\t\tengine.WithWorkCount(5),\n\t\t\tengine.WithSeeds(seeds),\n\t\t)\n\ts.Run()\n}\n</code></pre><p>从这个例子中，我们可以看到函数式选项模式的好处：</p><ul>\n<li>API 具有可扩展性，高度可配置化，新增参数不会破坏现有代码；</li>\n<li>参数列表非常简洁，并且可以使用默认的参数；</li>\n<li>option函数使参数的含义非常清晰，易于开发者理解和使用；</li>\n<li>如果将 options 结构中的参数设置为小写，还可以限制这些参数的权限，防止这些参数在package 外部使用。</li>\n</ul><p>刚才，我们实战了 fan-in 和 fan-out 高并发模型，并深度使用了通道和select的机制。接下来让我们更进一步，看一下实现通道和select机制的原理，掌握这种高并发模型的底层图像。</p><h2>通道的底层原理</h2><p>通道的实现并没有想象中复杂。它利用互斥锁实现了并发安全，只不过Go运行时为我们屏蔽了底层的细节。<strong>通道包括两种类型，一种是无缓冲的通道，另一种是带缓冲区的通道。</strong>通道的结构如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/2d/1d3df16f6b81e75537442a0a226de12d.jpg?wh=1920x1743\" alt=\"图片\"></p><p>可以看到，通道中包含了数据的类型、大小、数量，堵塞协程队列，以及用于缓存区的诸多字段。</p><p>我们先来看看无缓冲区的通道是怎么实现的。</p><h3>无缓冲区的通道</h3><p>通道需要有多个协程分别完成读和写的功能，这样才能保证数据传输是顺畅的。对于无缓冲区的通道来说，如果有一个协程正在将数据写入通道，但是当前没有协程读取数据，那么写入协程将立即陷入到休眠状态。写入协程堵塞之前协程会被封装到sudog结构中，并存储到写入的堵塞队列sendq中，之后协程陷入休眠。</p><p>之前我们介绍过，协程的堵塞是位于用户态的，协程切换时，运行时会保存当前协程的状态、并调用 <code>gopark</code> 函数切换到g0完成新一轮的调度。如果之后有协程读取数据，那么读取协程会立即读取sendq队列中第一个等待的协程，并将该协程对应的元素拷贝到读取协程中，同时调用 <code>goready</code> 唤醒写入协程，将写入协程放入到可运行队列中等待被调度器调度。</p><p><img src=\"https://static001.geekbang.org/resource/image/95/df/951ea2060624460486cd7c19yy2c52df.jpg?wh=1920x1242\" alt=\"图片\"></p><h3>带缓冲区的通道</h3><p>而对于带缓冲区的通道来说，假设缓存队列的数量为N，那么如果写入的数据量不大于N，写入协程就不会陷入到休眠状态，所有数据都会存储在缓冲队列中。</p><p>缓冲队列可以在一定程度上削峰填谷，加快处理速度。但是如果写入速度始终大于读取数据，那么缓冲区迟早也有写满的时候，到时候仍然会陷入堵塞，只是延迟了问题的暴露并带来内存的浪费。因此缓冲区的容量不可以过大，我们可以根据实际情况给出一个经验值。例如上面的爬虫案例中，我们就可以给接收任务的requestCh通道加上缓存区，先将缓存区设置为500，这样就不会频繁堵塞住调度器了。</p><p>对于有缓存的通道，存储在 buf 中的数据虽然是线性的数组，但是这些数组和序号recvx、recvq 模拟了一个环形队列。recvx 可以定位到 buf 是从哪个位置读取的通道中的元素，而 sendx 则能够找到写入时放入 buf 的位置，这样做主要是为了再次利用已经使用过的空间。从 recvx 到 sendx 的距离qcount就是通道队列中的元素数量。</p><p><img src=\"https://static001.geekbang.org/resource/image/44/c9/44d5ac405f5997b198747c6b6acaacc9.jpg?wh=1920x1013\" alt=\"图片\"></p><h2>Select 机制的底层原理</h2><p>在前面的实战案例中，我们还看到了大量channel与select结合使用的场景。</p><p>受到通道特性的限制，如果单个通道被堵塞，协程就无法继续执行了。那有没有一种机制可以像网络中的多路复用一样，监听多个通道，使后续处理协程能够及时地运行？</p><p>其实就和网络中把select用于Socket的多路复用机制一样，Go中也可以用select语句实现这样的多路复用机制。select语句中的每一个case都对应着一个待处理的读取或写入通道。举个简单实用的例子，下面的程序如果800毫秒之后也接受不到通道c中的数据，定时器time.After就会接收到数据，从而打印timeout。</p><pre><code class=\"language-plain\">select {\n\tcase &lt;-c:\n\t\tfmt.Println(\"random 01\")\n\tcase &lt;-time.After(800 * time.Millisecond):\n\t\tfmt.Println(\"timeout\")\n\t}\n</code></pre><p>借助select可以实现许多有表现力的设计，那select是如何工作的呢？</p><p>Select底层调用了 <code>selectgo</code> 函数，它的工作可以分为三个部分：</p><ul>\n<li>第一部分涉及到遍历。<code>selectgo</code> 首先循环查找当前准备就绪的通道，如果能够找到，则正常进行后续处理。在具体的实现方式上，由于 select内部的 <code>scases</code> 数组存储了所有需要管理的通道，所以很容易想到循环遍历 <code>scases</code> ，最终找到可用的通道。不过这可能导致一个问题，那就是如果前面的通道始终有数据，后面的通道将永远得不到执行的机会。为了解决这一问题，Go语言为select加入了随机性，会利用洗牌算法随机打散数组顺序，保证了所有通道都有执行的机会。</li>\n<li>第二部分涉及到协程的休眠。如果select找不到准备就绪的通道，这时和单个协程的堵塞一样，它会将当前协程放入到所有通道的等待队列中，并陷入到休眠状态。</li>\n<li>第三部分涉及到协程的唤醒。如果有任意一个通道准备就绪，当前的协程将会被唤醒，并到准备就绪的case处继续执行。 要注意的一点是，最后 <code>selectgo</code> 会将sudog结构体从其他通道的等待队列中移出，因为当前协程已经能够正常运行，不再需要被其他通道唤醒了。</li>\n</ul><h2>总结</h2><p>这节课，我们用fan-in、fan-out并发模式实战了爬虫的任务调度器。在实战中，我们频繁使用了通道与select结合的方式，还深入底层看到了通道与select的原理。最后我们还学习了函数选项模式在构建API时的优势。在后面的项目中，我们还会频繁地用到这种特性。</p><h2>课后题</h2><p>在我们的课程中，schedule函数其实有一个bug，您能看出来吗？你觉得可以用什么方式找出这样的Bug？</p><p>欢迎你在留言区与我交流讨论，我们下节课见！</p>","comments":[{"had_liked":false,"id":364509,"user_name":"shuff1e","can_delete":false,"product_type":"c1","uid":1756280,"ip_address":"北京","ucode":"85601271951B5A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep075ibtmxMf3eOYlBJ96CE9TEelLUwePaLqp8M75gWHEcM3za0voylA0oe9y3NiaboPB891rypRt7w/132","comment_is_top":false,"comment_ctime":1671065656,"is_pvip":false,"replies":[{"id":134131,"content":"是的，后面有修复","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1676214132,"ip_address":"北京","comment_id":364509,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"bug应该是，会丢失发给worker的任务。\n\ncase r := &lt;-s.requestCh:的情况下，如果req不是nil，应该把req再添加到reqQueue头部","like_count":1,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603451,"discussion_content":"是的，后面有修复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676214132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368302,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1352753,"ip_address":"江苏","ucode":"1770CA7050647A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI8qibAw4lRCic1pbnA6yzQU3UqtQm3NqV1bUJ5EiaUnJ24V1yf4rtY7n2Wx7ZVvTemqq5a61ERWrrHA/132","comment_is_top":false,"comment_ctime":1676144215,"is_pvip":false,"replies":[{"id":134113,"content":"目前只有初始化会写，运行时都是读，所以不会有并发问题。  随着课程的深入，运行时可以添加资源，到时会有并发冲突的考虑","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1676211077,"ip_address":"北京","comment_id":368302,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"有个小问题请教一下老师， 这个Seeds 是slice， 我觉得在取出任务的时候会有并发问题 如果没有请老师指教下 ","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603430,"discussion_content":"目前只有初始化会写，运行时都是读，所以不会有并发问题。  随着课程的深入，运行时可以添加资源，到时会有并发冲突的考虑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676211077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1352753,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI8qibAw4lRCic1pbnA6yzQU3UqtQm3NqV1bUJ5EiaUnJ24V1yf4rtY7n2Wx7ZVvTemqq5a61ERWrrHA/132","nickname":"Alex","note":"","ucode":"1770CA7050647A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605614,"discussion_content":"好的 谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676792440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366330,"user_name":"mantra","can_delete":false,"product_type":"c1","uid":1389310,"ip_address":"北京","ucode":"81705795D01642","user_header":"https://static001.geekbang.org/account/avatar/00/15/32/fe/c2179924.jpg","comment_is_top":false,"comment_ctime":1673586086,"is_pvip":false,"replies":[{"id":134123,"content":"我所有的项目链接都放置的主库的地址，tag的地址就稍微点击一下吧","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1676212187,"ip_address":"北京","comment_id":366330,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"本文档中的代码链接 tag v0.1.4 （之前的文档，也一样）对应的 URL 都是主库的地址（https:&#47;&#47;github.com&#47;dreamerjackson&#47;crawler），这是故意的吗？正确的应该是 https:&#47;&#47;github.com&#47;dreamerjackson&#47;crawler&#47;archive&#47;refs&#47;tags&#47;v0.1.4.tar.gz","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603440,"discussion_content":"我所有的项目链接都放置的主库的地址，tag的地址就稍微点击一下吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676212188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364827,"user_name":"7oty","can_delete":false,"product_type":"c1","uid":1434864,"ip_address":"广东","ucode":"6E00D586B7FF75","user_header":"","comment_is_top":false,"comment_ctime":1671548171,"is_pvip":false,"replies":[{"id":134133,"content":"后面文章会有介绍","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1676214247,"ip_address":"北京","comment_id":364827,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"如何控制某个爬虫任务的启动，停止和任务的实时运行状态？","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603453,"discussion_content":"后面文章会有介绍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676214247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364780,"user_name":"翡翠虎","can_delete":false,"product_type":"c1","uid":1448015,"ip_address":"广西","ucode":"2572E93C4C57A5","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/4f/9e4d5591.jpg","comment_is_top":false,"comment_ctime":1671479936,"is_pvip":false,"replies":[{"id":134134,"content":"随着课程深入会看到，我们的任务是存储在etcd中的，所以不会丢失","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1676214574,"ip_address":"北京","comment_id":364780,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"如果任务推送到worker，但又还没实施，这时候那台服务器停机了，或者进程退出了，任务会不会丢？怎么处理任务还没执行就丢了的这种情况呢？","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603455,"discussion_content":"随着课程深入会看到，我们的任务是存储在etcd中的，所以不会丢失","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676214574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1285800,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9e/a8/09106237.jpg","nickname":"吴亚楠","note":"","ucode":"9582C4086FD13E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603104,"discussion_content":"这种的肯定会的，除非这些信息保存在远端数据库里\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675943488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364401,"user_name":"Geek_a9ea01","can_delete":false,"product_type":"c1","uid":3199345,"ip_address":"广东","ucode":"4046B8E39150FD","user_header":"","comment_is_top":false,"comment_ctime":1670924751,"is_pvip":false,"replies":[{"id":134143,"content":"这个是已知的问题，我在后面的课程中做了修复","user_name":"作者回复","user_name_real":"编辑","uid":1903914,"ctime":1676216879,"ip_address":"北京","comment_id":364401,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"for { var req *collect.Request var ch chan *collect.Request if len(reqQueue) &gt; 0 { req = reqQueue[0] reqQueue = reqQueue[1:] ch = s.workerCh } select { case r := &lt;-s.requestCh: reqQueue = append(reqQueue, r) case ch &lt;- req: } }\n有个问题：\n如果ch堵塞了  这时候又有requestCh请求上来；会不会导致ch数据丢失？","like_count":0,"discussions":[{"author":{"id":1903914,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0d/2a/dcb935cf.jpg","nickname":"时间为我们证明","note":"","ucode":"299438152D9F3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603468,"discussion_content":"这个是已知的问题，我在后面的课程中做了修复","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676216880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366955,"user_name":"周龙亭","can_delete":false,"product_type":"c1","uid":1004577,"ip_address":"上海","ucode":"21BD0DD15CFCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/21/8c13a2b4.jpg","comment_is_top":false,"comment_ctime":1674656953,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"func (s *Schedule) Schedule() {\n\tvar reqQueue = s.Seeds\n\tgo func() {\n\t\tfor {\n\t\t\tvar req *collect.Request\n\t\t\tvar ch chan *collect.Request\n\n\t\t\tif len(reqQueue) &gt; 0 {\n\t\t\t\treq = reqQueue[0]\n\t\t\t\tch = s.workerCh\n\t\t\t}\n\t\t\tselect {\n\t\t\tcase r := &lt;-s.requestCh:\n\t\t\t\treqQueue = append(reqQueue, r)\n\n\t\t\tcase ch &lt;- req:\n\t\t\t\treqQueue = reqQueue[1:]\n\t\t\t}\n\t\t}\n\t}()\n}","like_count":2},{"had_liked":false,"id":364413,"user_name":"Realm","can_delete":false,"product_type":"c1","uid":1081299,"ip_address":"浙江","ucode":"30CBEBE619D1A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/d3/b5896293.jpg","comment_is_top":false,"comment_ctime":1670937031,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"                          \n                       Seeds\n                           |\n                           |              req                     ParseFunc(req)      HandleResult()\nrequestCh----&gt; reqQueue -----&gt; workerCh ----------&gt; out-----------&gt; result:\n^                                                                                                                - item ==&gt; 存储\n|                                                                                                                 - req |\n|---------------&lt;----------------------&lt;---------------------&lt;------|","like_count":2},{"had_liked":false,"id":388295,"user_name":"Geek_38ea75","can_delete":false,"product_type":"c1","uid":3647096,"ip_address":"北京","ucode":"5295680D787299","user_header":"","comment_is_top":false,"comment_ctime":1709812763,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"我有好几个问题\n1.为啥req和ch放在for循环内部声明，这样有个问题，就是work来不及执行的话，会丢失。\n2.如果requestCh中的任务很多的话，会导致work队列中没有能够运行的任务。","like_count":0},{"had_liked":false,"id":366952,"user_name":"周龙亭","can_delete":false,"product_type":"c1","uid":1004577,"ip_address":"上海","ucode":"21BD0DD15CFCA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/21/8c13a2b4.jpg","comment_is_top":false,"comment_ctime":1674655993,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100124001,"comment_content":"修复下Schedule方法的bug：\n\nfunc (s *Schedule) schedule() {\n\tgo func() {\n\t\tfor r := range s.requestCh {\n\t\t\ts.reqQueueCond.L.Lock()\n\t\t\ts.reqQueue = append(s.reqQueue, r)\n\t\t\ts.reqQueueCond.Signal()\n\t\t\ts.reqQueueCond.L.Unlock()\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tfor {\n\t\t\ts.reqQueueCond.L.Lock()\n\t\t\tfor len(s.reqQueue) == 0 {\n\t\t\t\ts.reqQueueCond.Wait()\n\t\t\t}\n\n\t\t\tvar movedReqQueue = s.reqQueue\n\t\t\ts.reqQueue = nil\n\n\t\t\ts.reqQueueCond.L.Unlock()\n\n\t\t\tfor _, r := range movedReqQueue {\n\t\t\t\ts.workerCh &lt;- r\n\t\t\t}\n\t\t}\n\n\t}()\n}","like_count":0},{"had_liked":false,"id":364447,"user_name":"Realm","can_delete":false,"product_type":"c1","uid":1081299,"ip_address":"浙江","ucode":"30CBEBE619D1A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/d3/b5896293.jpg","comment_is_top":false,"comment_ctime":1670986803,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"```\nfunc (s *ScheduleEngine) Schedule() {\n\tvar reqQueue = s.Seeds\n\tgo func() {\n\t\tfor {\n\t\t\tvar req *collect.Request\n\t\t\t&#47;&#47;var ch chan *collect.Request\n\t\t\tch := make(chan *collect.Request)\n```\n使用make创建ch，这样ch就不是nil了，即使reqQueue为空的时候，case ch &lt;- req:就不是往nil通道中写数据了。","like_count":0},{"had_liked":false,"id":364427,"user_name":"老猫","can_delete":false,"product_type":"c1","uid":1008270,"ip_address":"江苏","ucode":"7F23297709749A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/8e/985cbc25.jpg","comment_is_top":false,"comment_ctime":1670945286,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100124001,"comment_content":"&#47;&#47; s.requestCh = make(chan *collect.Request,100)\n&#47;&#47; s.workerCh = make(chan *collect.Request,500)\nfunc (s *ScheduleEngine) Schedule() {\n\tvar reqQueue = s.Seeds\n\tgo func() {\n\t\tfor _, req := range reqQueue {\n\t\t\ts.workerCh &lt;- req\n\t\t}\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase r := &lt;-s.requestCh:\n\t\t\t\ts.workerCh &lt;- r\n\t\t\t}\n\t\t}\n\t}()\n}","like_count":0},{"had_liked":false,"id":364417,"user_name":"拾掇拾掇","can_delete":false,"product_type":"c1","uid":1051873,"ip_address":"浙江","ucode":"D775F374C2A1D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","comment_is_top":false,"comment_ctime":1670941035,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":1,"score":3,"product_id":100124001,"comment_content":"开启go run 的datarace参数吗？","like_count":0}]}