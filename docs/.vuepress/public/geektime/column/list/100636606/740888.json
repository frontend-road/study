{"id":740888,"title":"第 13 章 服务注册与发现(2)","content":"<h2 id=\"nav_point_210\">13.3　服务注册与发现的抽象与应用</h2>\n<p>Spring Cloud 的服务注册与发现机制正是图 13-3 分布式负载均衡方案的一种实现，它提供了定义好的各种接口，针对不同的服务注册中心，我们只需提供不同的注册与发现实现类就能获得想要的负载均衡能力。在 13.3 节中，我们会看到除了 Zookeeper，还可以用 Nacos、Consul 和 Eureka 来充当注册中心，在此之前先让我们来了解下这套机制是如何实现的。</p>\n<h3 id=\"nav_point_211\">13.3.1　服务注册的抽象</h3>\n<p>服务是静态的概念，真正提供服务的是一个个运行中的服务实例，<code>ServiceInstance</code> 接口就代表了这个概念，其中包含了服务 ID、实例 ID、主机、端口等信息。<code>Registration</code> 接口没有任何内容，它的作用是充当注册动作的标识。在 13.2 节中，我们的注册中心用的是 Zookeeper，所以 Spring Cloud Zookeepr 提供了一个 <code>ZookeeperRegistration</code> 子接口，实现类是 <code>ServiceInstanceRegistration</code>。</p>\n<p><code>ServiceRegistry</code> 接口的作用就是向注册中心注册和注销 <code>Registration</code>，其中的方法是 <code>register()</code>、<code>deregister()</code>、<code>setStatus()</code>、<code>getStatus()</code> 和 <code>close()</code>，分别对应了注册、注销、设置节点状态、获取节点状态和关闭。<code>ZookeeperServiceRegistry</code> 就是该接口对应的实现，基于 Apache Curator 的 <code>ServiceDiscovery</code> 对 Zookeeper 做各种对应的操作，负责在启动时把实例注册到 Zookeeper 上。</p>\n<p>知道了 <code>ServiceRegistry</code> 负责服务实例的注册后，又是什么地方触发了注册这个动作呢？我们的应用启动后就自动注册到了注册中心，并没有人为进行注册，<code>AutoServiceRegistration</code> 接口就代表了自动服务注册的行为，这个接口只是一个标识，里面没有具体的方法，重要的内容都在抽象类 <code>AbstractAutoServiceRegistration</code> 中。在接收到 <code>WebServerInitializedEvent</code> 事件后，会根据设置判断是否需要自动注册，如果需要则触发服务实例的注册动作（也就是调用 <code>register()</code> 方法），<code>AbstractAutoServiceRegistration</code> 在调用 <code>serviceRegistry.register()</code> 进行服务注册前后分别还会触发 <code>InstancePreRegisteredEvent</code> 和 <code>InstanceRegisteredEvent</code> 事件，方便在这些阶段扩展自己的动作。只要不去设置 <code>spring.cloud.service-registry.auto-registration.enabled</code> 为 <code>false</code>，<code>AutoServiceRegistrationAutoConfiguration</code> 会配置自动服务注册相关的内容。</p><!-- [[[read_end]]] -->\n<p><code>ZookeeperAutoServiceRegistration</code> 就是 Spring Cloud Zookeeper 中具体负责自动服务注册的实现类，它的注册依据是 <code>spring.cloud.zookeeper.discovery.enabled</code> 配置项，默认为 <code>true</code>。本节中介绍的重要接口和实现类的关系如图 13-4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00791.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 13-4　Spring Cloud Zookeeper 的服务注册核心接口与类</strong></p>\n<h3 id=\"nav_point_212\">13.3.2　服务发现的抽象</h3>\n<p>服务注册好了之后，服务的消费者就该考虑如何从注册中心获取已注册的服务实例了，也就是怎么去发现服务。Spring Cloud 的 <code>DiscoveryClient</code> 接口提供了服务发现机制的抽象，具体说来，<code>DiscoveryClient</code> 提供了一些读操作，通过其中的 <code>getServices()</code> 可以获得注册中心上的所有服务清单，通过 <code>getInstances()</code> 可以获得指定服务的实例清单。带有 <code>@LoadBalanced</code> 注解的 <code>RestTemplate</code> 在向指定服务发起请求时，实际就是从 <code>DiscoveryClient</code> 中获取具体要调用的服务实例信息，所以 <code>DiscoveryClient</code> 就是背后的核心。</p>\n<p>仍然以 Zookeeper 为例，Spring Cloud Zookeeper 提供了 <code>ZookeeperDiscoveryClient</code> 实现，其背后依靠的同样是 Apache Curator 的 <code>ServiceDiscovery</code>。自动配置类 <code>CuratorServiceDiscoveryAutoConfiguration</code> 提供了 <code>ServiceDiscovery</code> Bean，<code>ZookeeperDiscoveryClientConfiguration</code> 则提供了 <code>ZookeeperDiscoveryClient</code> Bean。在自动配置的加持之下，我们就有了可用的 <code>DiscoveryClient</code>。</p>\n<p>Spring Cloud Common 中默认还提供了两个 <code>DiscoveryClient</code> 的实现，分别是 <code>CompositeDiscoveryClient</code> 和 <code>SimpleDiscoveryClient</code>。前者是一个组合服务发现客户端，可以将多个 <code>DiscoveryClient</code> 组装到一起，在查找服务和服务实例时依次遍历每个 <code>DiscoveryClient</code>，返回找到的第一个结果。后者则提供了一种基于配置文件的服务发现方式，通过 <code>spring.cloud.discovery.client.simple</code> 前缀的配置提供服务与实例的映射关系，将其绑定到 <code>SimpleDiscoveryProperties</code> 对象里，<code>SimpleDiscoveryClient</code> 再从中查找服务与实例。在实践中，通常还是会使用独立的服务注册中心，而非配置文件。</p>\n<p>此外，早期的 Spring Cloud 中需要添加 <code>@EnableDiscoveryClient</code> 来开启 <code>DiscoveryClient</code> 的支持，现在已经无须手动添加该注解了，只要 CLASSPATH 中存在相应的实现，Spring 会进行自动配置。如果希望关闭服务发现机制，可以将 <code>spring.cloud.discovery.enabled</code> 设置为 <code>false</code>。</p>\n<h3 id=\"nav_point_213\">13.3.3　在 Consul 中注册服务</h3>\n<p>本章早些时候，我们已经演示过如何使用 Zookeeper 作为服务注册中心进行服务实例的注册和发现，在大概了解其背后的实现方式后，再让我们一起来看看 Spring Cloud 支持的其他几种服务注册中心。</p>\n<p>HashiCorp Consul 是一款服务网格解决方案，它兼具了分布式、高可用、可感知数据中心等诸多特性，提供了服务发现、服务配置、服务分段（segmentation）、键值存储等功能，我们可以按需使用这些功能，本书后续章节里还会用到 Consul 的服务配置功能。</p>\n<p>Consul 提供了一种简单的服务定义格式，通过 HTTP 接口可以动态地将服务的定义提交到 Consul 服务端，配合健康检查机制，就能判断哪些服务处于可用状态。除了使用 API 方式，我们还可以通过 DNS 来查询服务，Consul 提供了 DNS 解析支持，例如，<code>binarytea.service.dc1.consul</code> 代表了 DC1 数据中心的 BinaryTea 服务。</p>\n<p>既然我们是在介绍 Spring Cloud，这里自然是要使用 Spring Cloud 提供的服务注册与发现机制。首先像下面这样在 pom.xml 中引入 Consul 服务发现相关的依赖，之前用的是 <code>spring-cloud-starter-zookeeper-discovery</code>，现在换成 <code>spring-cloud-starter-consul-discovery</code>。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>通过查看 <code>ConsulServiceRegistry</code> 和 <code>ConsulDiscoveryClient</code> 的代码，我们可以了解到 Spring Cloud 的 Consul 的服务注册与发现机制是通过 <code>com.ecwid.consul.v1.ConsulClient</code> 来实现的，这是一个 Consul API 的客户端。默认情况下，Spring Cloud Consul 会与启动在 <code>localhost:8500</code> 上的 Consul Agent 进行通信，但也可以通过下面的配置进行设置：</p>\n<pre class=\"code-rows\"><code>spring.cloud.consul.host=localhost\nspring.cloud.consul.port=8500</code></pre>\n<p>表 13-4 中罗列了一些常用的配置项，默认值基本就能满足日常的使用，大家可以按需稍作修改。</p>\n<p><strong>表 13-4　Spring Cloud Consul 的部分服务发现配置</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置项</p></th>\n<th><p>默认值</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>spring.cloud.consul.enabled</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否开启 Consul 支持</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.consul.discovery.enabled</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否开启 Consul 服务发现功能</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.consul.discovery.register</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否注册服务</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.consul.discovery.fail-fast</code></p></td>\n<td><p><code>false</code></p></td>\n<td><p>注册失败时是否抛出异常，为 <code>false</code> 时只打印日志</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.consul.host</code></p></td>\n<td><p><code>localhost</code></p></td>\n<td><p>Consul Agent 的主机名</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.consul.port</code></p></td>\n<td><p><code>8500</code></p></td>\n<td><p>Consul Agent 的端口</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.consul.discovery.prefer-ip-address</code></p></td>\n<td><p><code>false</code></p></td>\n<td><p>注册服务时是使用 IP 还是主机名</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.consul.discovery.instance-id</code></p></td>\n<td><p><code>$:</code> 逗号分隔的 <code>Profile:$</code></p></td>\n<td><p>要注册的服务实例 ID</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.consul.discovery.register-health-check</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否注册健康检查</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.consul.discovery.health-check-interval</code></p></td>\n<td><p><code>10s</code></p></td>\n<td><p>健康检查间隔时间</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.consul.discovery.health-check-path</code></p></td>\n<td><p><code>/actuator/health</code></p></td>\n<td><p>健康检查的路径</p></td>\n</tr>\n</tbody>\n</table>\n<p>在运行新的 BinaryTea 程序 <span class=\"comment-number\">8</span> 前，我们还需要准备一个 Consul 的环境，如果是开发学习，可以考虑直接用 Docker<span class=\"comment-number\">9</span> 在本地启动一个环境，命令大概是下面这样的，运行后可以通过浏览器访问 http://localhost:8500/ 看看是否启动成功：</p>\n\n\n<pre class=\"code-rows\"><code>▸ docker pull consul\n▸ docker run --name consul -d -p 8500:8500 -p 8600:8600/udp consul</code></pre>\n<p>在工程的 <code>applicaton.properties</code> 中，去掉 Zookeeper 相关配置，换成 Consul 的，大概的配置片段如代码示例 13-6 所示。</p>\n<blockquote>\n<p><strong>代码示例 13-6</strong>　使用 Consul 的配置文件片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.application.name=binarytea\nspring.cloud.consul.host=localhost\nspring.cloud.consul.port=8500\n# 省略其他配置</code></pre>\n<p>运行后在日志中会看到类似下面这样的输出：</p>\n<pre class=\"code-rows\"><code>2021-06-17 00:16:46.252 INFO 71861 --- [main] o.s.c.c.s.ConsulServiceRegistry : Registering service with\nconsul: NewService,\nport=8080, enableTagOverride=null, check=Check,\ntcp='null', timeout='null', deregisterCriticalServiceAfter='null', tlsSkipVerify=null, status='null',\ngrpc='null', grpcUseTLS=null}, checks=null}</code></pre>\n<p>通过浏览器访问 Consul 页面查看，会看到类似图 13-5 所示的信息。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00792.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 13-5　Consul 页面中看到的二进制奶茶店程序</strong></p>\n<h3 id=\"nav_point_214\">13.3.4　在 Nacos 中注册服务</h3>\n<p>Nacos 是阿里巴巴开源的一款中间件产品，提供了完善的云原生服务发现、配置和管理能力。服务是 Nacos 里的重要成员，在 Nacos 的管理平台上，可以掌握大量服务相关的元数据，比如生命周期、依赖、健康状态、路由策略等。本节会重点介绍如何在 Spring Cloud 的帮助下使用 Nacos 来实现微服务的注册和发现功能。</p>\n<p>第一步是引入依赖，由于 Spring Cloud Alibaba 不在 <code>spring-cloud-dependencies</code> 里，所以先要在 <code>&lt;dependencyManagement/&gt;</code> 中引入 <code>spring-cloud-alibaba-dependencies</code>，就像下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;$&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;$&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;</code></pre>\n<p>其中的 <code>$</code> 可以从官方主页找到，例如可以在 <code>&lt;properties/&gt;</code> 中将其设置为 <code>2021.0.1.0</code><span class=\"comment-number\">10</span>。随后，再到 <code>&lt;dependencies/&gt;</code> 里引入 Nacos 服务注册与发现相关的依赖：</p>\n\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>第二步是在 <code>application.properties</code> 中配置 Nacos 服务端相关的信息，例如在 <code>127.0.0.1:8848</code> 启动一个 Nacos 服务端，可以像代码示例 13-7 那样配置。其中，为了方便演示，<code>management.endpoints.web.exposure.include=*</code> 暴露了所有的端点，因为 Nacos 为我们提供了一个 <code>nacos-discovery</code> 端点，我们可以通过它查看详细的信息。当然，也可以手动设置需要暴露的端点。</p>\n<blockquote>\n<p><strong>代码示例 13-7</strong>　针对 <code>Nacos</code> 的 <code>BinaryTea</code> 配置片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.application.name=binarytea\nmanagement.endpoints.web.exposure.include=*\nspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</code></pre>\n<p>修改完 BinaryTea 项目，还需要用类似的方式修改 Customer 项目的依赖和配置。需要注意，<code>spring-cloud-starter-alibaba-nacos-discover</code> 里并不包含 <code>spring-cloud-starter-loadbalancer</code>，需要我们自己添加这个依赖之后 OpenFeign 才能用上 Spring Cloud 的负载均衡，如代码示例 13-8 所示。<span class=\"comment-number\">11</span></p>\n\n<blockquote>\n<p><strong>代码示例 13-8</strong>　Customer 项目的 pom.xml 中要调整的依赖代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>而在 <code>application.properties</code> 里则可以像代码示例 13-9 这样做些配置。</p>\n<blockquote>\n<p><strong>代码示例 13-9</strong>　服务消费者端的 Nacos 相关配置片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.application.name=customer\nmanagement.endpoints.web.exposure.include=*\nspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</code></pre>\n<p>除了 <code>spring.cloud.nacos.discovery.server-addr</code>，表 13-5 还罗列了一些 Nacos 相关的配置，通常情况下只需要提供 Nacos 的服务端地址就好，Spring 会自动完成其他的配置工作，能够满足大部分的场景需要。</p>\n<p><strong>表 13-5　Nacos 服务发现相关的部分配置</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置项</p></th>\n<th><p>默认值</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>spring.cloud.nacos.discovery</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否开启 Nacos 服务发现相关支持</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.nacos.discovery.server-addr</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>Nacos 服务端地址</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.nacos.discovery.service</code></p></td>\n<td><p><code>$</code></p></td>\n<td><p>服务名，默认使用 Spring 应用名</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.nacos.discovery.namespace</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>用来区分不同环境的命名空间</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.nacos.discovery.weight</code></p></td>\n<td><p><code>1</code></p></td>\n<td><p>当前实例的权重，取值范围 1 到 100，值越大权重越高</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.nacos.discovery.ip</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>要注册到 Nacos 上的 IP</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.nacos.discovery.port</code></p></td>\n<td><p><code>-1</code></p></td>\n<td><p>要注册到 Nacos 上的端口，默认是自动发现的</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.nacos.discovery.access-key</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>阿里云账户的 AccessKey，不用阿里云不用设置</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.nacos.discovery.secret-key</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>阿里云账户的 Secretkey，不用阿里云不用设置</p></td>\n</tr>\n</tbody>\n</table>\n<p>这次，我们同样使用 Docker 来启动一个简单的单机 Nacos<span class=\"comment-number\">12</span>，监听本地的 <code>8848</code> 端口。这个模式下默认使用 Derby 作为数据存储，只能用来测试，不能用在生产环境中。至于生产环境的版本，大家可以参考官方文档进行部署。</p>\n\n<pre class=\"code-rows\"><code>▸ docker pull nacos/nacos-server\n▸ docker run --name nacos -e MODE=standalone -p 8848:8848 -d nacos/nacos-server</code></pre>\n<p>成功启动 Nacos 服务端和两个应用程序后，可以通过浏览器访问 http://localhost:8848/nacos，在登录界面中使用 <code>nacos</code> 作为用户名和密码。随后就能看到类似图 13-6 的服务列表，其中包含了服务提供者 binarytea，Customer 运行过程中点击订阅者也能看到服务的订阅者。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00793.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 13-6　Nacos 中的服务列表</strong></p>\n<blockquote>\n<p><strong>茶歇时间：Spring Cloud Alibaba 概述</strong></p>\n<p>众所周知，阿里巴巴集团旗下的各家公司都在大量使用 Java，加之阿里多年的实践，沉淀出了很多优秀的中间件设施。阿里将它们开源，同时还在阿里云上提供了对应的服务。Spring Cloud 作为目前主流的 Java 微服务框架，阿里自然希望这些设施能够方便地被 Spring Cloud 的用户接受并使用到自己的系统中。于是就有了 Spring Cloud Alibaba，最初它是由阿里巴巴开发并发布在阿里巴巴的项目下，后来并入了 Spring Cloud 项目。</p>\n<p>在 Spring Cloud Alibaba 的帮助下，只需简单的一些注解和少数配置，就能让基于 Spring Cloud 的系统用上阿里巴巴分布式解决方案中的很多中间件。主要包括如下内容，本书中会涉及其中的 Nacos、Sentinel 和 Dubbo。</p>\n<ul>\n<li><strong>Nacos</strong>，提供服务实例的注册与发现能力，也可作为服务配置的后端数据存储。</li>\n<li><strong>Sentinel</strong>，提供流量控制、服务降级等保护能力。</li>\n<li><strong>RocketMQ</strong>，一款高性能、可伸缩的金融级消息中间件，通过 Spring Cloud Alibaba 可以实现基于 RocketMQ 的事件驱动与消息总线。</li>\n<li><strong>Seata</strong>，提供分布式事务解决方案。</li>\n<li><strong>Dubbo</strong>，一款被广泛使用的 RPC 框架。</li>\n</ul>\n</blockquote>\n<h3 id=\"nav_point_215\">13.3.5　在 Eureka 中注册服务</h3>\n<p>在 Spring Cloud 刚问世时，Spring Cloud 的一大特色就是和 Netflix 的开源设施做了大量整合。Netflix 的开源软件套件（Netflix OSS）当时也非常出名，其中与微服务相关的部分组件如表 13-6 所示。一时间，大家都在学习如何在 Spring Cloud 项目里用 Eureka 来做服务发现与注册，这几乎就是 Spring Cloud 的 Hello World 项目。不过随着时间的推移，Netflix OSS 中的部分组件不再开源，例如 Eureka 和 Zuul，加之社区中有了更多可供选择的同类产品，Spring Cloud 也对它们做了很好的支持，所以 Eureka 已经不再是我们的首选了。</p>\n<p><strong>表 13-6　Netflix OSS 中的与微服务相关的部分组件</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>组件</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>Eureka</p></td>\n<td><p>服务发现与注册中心，针对 Amazon Web Services（AWS）做了针对性设计，也可用于非 AWS 的场景</p></td>\n</tr>\n<tr>\n<td><p>Archaius</p></td>\n<td><p>分布式配置中心</p></td>\n</tr>\n<tr>\n<td><p>Ribbon</p></td>\n<td><p>客户端进程间通讯（IPC）组件，提供负载均衡、容错、多协议支持等功能</p></td>\n</tr>\n<tr>\n<td><p>Hystrix</p></td>\n<td><p>可靠性组件，在服务调用过程中提供服务降级、容错等功能</p></td>\n</tr>\n<tr>\n<td><p>Zuul</p></td>\n<td><p>微服务网关</p></td>\n</tr>\n</tbody>\n</table>\n<p>在 Spring Cloud 里，所有对 Netflix OSS 的支持都集中在 Spring Cloud Netflix 项目里，这一节里我们会重点关注对 Eureka 的支持。接下来先将 BinaryTea 的注册中心替换为 Eureka<span class=\"comment-number\">13</span>，只需在 pom.xml 里引入 Eureka 客户端依赖即可。早期还需要在配置类上增加 <code>@EnableEurekaClient</code> 注解，现在这步不是必需的了。</p>\n\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>随后，在 <code>application.properties</code> 中配置与 Eureka 相关的信息，就像下面这样。其中的 <code>defaultZone</code><span class=\"comment-number\">14</span> 是所有 Eureka 客户端都能获取的默认服务端 URL，也可以针对性地使用其他可用区名来配置特定的服务端 URL。<code>eureka.client.service-url</code> 实际是个 <code>Map&lt;String, String&gt;</code> 类型，这里的 <code>defaultZone</code> 是作为键存在的，可以视为一个特殊的字符串。</p>\n\n<pre class=\"code-rows\"><code>spring.application.name=binarytea\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\neureka.instance.prefer-ip-address=true</code></pre>\n<p>除了上面提到的配置，其他主要配置都在 <code>eureka.instance.*</code> 和 <code>eureka.client.*</code> 这两个前缀下，前者对应了 <code>EurekaInstanceConfigBean</code>，后者对应的是 <code>EurekaClientConfigBean</code>，表 13-7 中例举了一部分。</p>\n<p><strong>表 13-7　Spring Cloud 中常用的一些 Eureka 配置</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置项</p></th>\n<th><p>默认值</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>eureka.instance.hostname</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>实例的主机名</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.instance.prefer-ip-address</code></p></td>\n<td><p><code>false</code></p></td>\n<td><p>注册时是否优先使用 IP 地址，而非主机名</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.instance.status-page-url-path</code></p></td>\n<td><p><code>/actuator/info</code></p></td>\n<td><p>当前实例的应用信息</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.instance.health-check-url-path</code></p></td>\n<td><p><code>/actuator/health</code></p></td>\n<td><p>当前实例的健康检查 URL 路径</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.instance.secure-port-enabled</code></p></td>\n<td><p><code>false</code></p></td>\n<td><p>是否开启 HTTPS 端口</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.client.enabled</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>开启 Eureka 服务发现客户端支持</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.client.healthcheck.enabled</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否执行健康检查</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.client.register-with-eureka</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>当前实例是否要注册到 Eureka 上</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.client.fetch-registry</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否拉取 Eureka 上的注册信息</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.client.prefer-same-zone-eureka</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否优先使用同一个区域的实例</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.client.eureka-server-connect-timeout-seconds</code></p></td>\n<td><p><code>5</code></p></td>\n<td><p>服务端连接超时秒数</p></td>\n</tr>\n<tr>\n<td><p><code>eureka.client.eureka-server-read-timeout-seconds</code></p></td>\n<td><p><code>8</code></p></td>\n<td><p>服务端读取超时秒数</p></td>\n</tr>\n</tbody>\n</table>\n<p>如果使用 HTTPS 连接 Eureka，相关的配置以 <code>eureka.client.tls.*</code> 打头，有需要的可以查看官方文档的相应内容。</p>\n<p>在运行程序前，需要在本地启动一个 Eureka 服务端，可以用 Docker Hub 上的 Docker 镜像，也可以自己用官方 Eureka 来搭建。Spring Cloud Eureka 自带了一套简单的服务端，几行代码就能搞定一个 Eureka 服务。我们可以到 Spring Initialzr 上新建一个项目，输入项目基本信息，例如项目名就叫 <code>eureka-server</code>，在依赖中选择 Eureka Server，随后生成项目。如果打开 pom.xml，可以看到它就是在其中添加了如下依赖。由于我们使用的 Java 11 已经去掉了 JAXB 模块，因而这个依赖里还带上了 <code>jaxb-runtime</code> 依赖。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>在启动类 <code>EurekaServerApplication</code> 上，添加 <code>@EnableEurekaServer</code> 注解就能开启一个简易的单机版 Eureka，就像代码示例 13-9 一样。</p>\n<blockquote>\n<p><strong>代码示例 13-9</strong>　用来启动 Eureka 服务端的 <code>EurekaServerApplication</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}</code></pre>\n<p>接下来，还要像代码示例 13-10 这样在 <code>application.properties</code> 中做些配置。让服务端监听 <code>8761</code> 端口，这个端口与前文中 BinaryTea 工程里配置的一样，由于本身就是 Eureka 服务端，所以不需要再进行注册或者拉取服务了。</p>\n<blockquote>\n<p><strong>代码示例 13-10</strong>　Eureka 服务端的简单配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.application.name=eureka-server\nserver.port=8761\n\neureka.client.register-with-eureka=false\neureka.client.fetch-registry=false</code></pre>\n<p>启动 Eureka 服务端后，运行 BinaryTea，访问 http://localhost:8761，就能看到类似图 13-7 这样的界面。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00794.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 13-7　注册了一个服务的 Eureka 界面</strong></p>\n<h2 id=\"nav_point_216\">13.4　小结</h2>\n<p>本章我们了解了负载均衡的基础知识，具体学习了如何使用 Spring Cloud 来实现分布式的微服务注册与发现机制，Spring Cloud 可以使用 Eureka、Consul、Zookeeper 和 Nacos 来充当服务的注册中心，Eureka 更适合 AWS 环境，而 Zookeeper 则天生不适合作为复杂大型系统的服务注册中心，我们可以根据实际情况进行选型。在此过程中，我们还对 Spring Cloud 的服务注册与发现机制背后的原理做了简单说明。</p>\n<p>下一章，我们会聊到微服务中的另一个重要话题——微服务的配置，看一看如何使用 Spring Cloud 来管理服务的配置信息。</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发小结</strong></p>\n<p>本章中，我们并没有为二进制奶茶的程序增加什么功能性的需求，而是为了满足日后服务的扩展，为它增加了集群化的能力，重点是服务注册与发现的能力。在 Spring Cloud 的帮助下，我们可以在不改变代码的情况下，自由地切换多种服务注册中心。在客户端侧，除了之前使用的 <code>RestTemplate</code>，我们还引入了更易用的 OpenFeign，以接口契约的形式来声明服务，以类似本地方法调用的方式调用服务端的各种接口。</p>\n</blockquote>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 13 章 服务注册与发现(1)","id":740887},"right":{"article_title":"第 14 章 服务配置管理(1)","id":740889}},"comments":[]}