{"id":396467,"title":"11｜将模型实现为RESTful API（下）","content":"<p>你好，我是徐昊。今天我们来聊聊继续如何将模型映射为RESTful API。</p><p>上节课我们学习了如何将领域模型实现为RESTful API的宏观步骤，分为四步：</p><ol>\n<li>通过URI表示领域模型；</li>\n<li>根据URI设计API；</li>\n<li>使用分布式超媒体设计API中涉及的资源；</li>\n<li>使用得到的API去覆盖业务流程，验证API的有效性。</li>\n</ol><p>并着重学习了，如何通过URI表示领域模型；并在得到与领域模型对应的URI之后，使用类似角色-目标-实体法的分析方法，获得API候选。那么今天我们就继续学习后面两步，通过分布式超媒体设计API中涉及的资源，并将使用API覆盖业务流程，以验证API的有效性。</p><h2><strong>RESTful API是一种什么样风格的API？</strong></h2><p>到目前为止我们得到的API候选，比如 GET /users 等，还不能被称作RESTful API，而仅仅可以被叫做<strong>基于HTTP的远程过程调用</strong>（HTTP RPC）。那么<strong>RESTful API到底是一种什么样的API呢？</strong></p><p>RESTful API是指<strong>符合REST架构风格的API设计</strong>，而REST架构风格是对互联网规模架构（Internet Scale Architecture）的总结与提炼。这一切都源于Roy Fielding提出的一个问题：既然互联网（Internet）是人类迄今为止构造的最大的软件应用，那么到底是什么样的架构原则，支撑了如此规模的异构且互联的系统呢？我们能从中学习到什么，以帮助我们更好地构建软件？</p><!-- [[[read_end]]] --><p>Roy Fielding将互联网定义为<strong>分布式超媒体信息获取系统</strong>（Distributed Hypermedia Information Retrieval System）。也就是由超媒体描述的、分布式的信息系统。在这个系统中，信息分布在不同的服务器中，并由超媒体联通。换句话说，<strong>分布式超媒体是互联网的集成策略</strong>（需要进一步了解的同学可以去看看<a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm\">Roy的论文</a>）。</p><p>因而我们必须理解这种集成策略给整个系统带来了什么影响，这样才能在实现RESTful API时，尽可能发挥它的优势。</p><p>在我看来，这种集成策略实现了客户端与服务器之间的渐进式服务消费（Progressive Service Consumption）。<strong>而这种渐进式服务消费，在客户端的多样性和API的稳定性之间，取得了完美的平衡。</strong></p><p>也就是说，它让我们可以用同样一套API，去对应具有不同诉求的参差多态的客户端们（我将这种API称为幸福API，因为罗素说“参差多态乃是幸福的本源”。那么能够支持参差多态的客户端的API，也就是幸福API）。</p><p>让我们回想一下，当你访问网络上的信息时，你会通过URI指定需要访问的页面。页面中会关联CSS、JavaScript等所需的资源，并包含其他页面的链接。浏览器会下载对应的CSS、JavaScript，完成界面的渲染。你也可以通过页面中的链接，去访问其他关联的页面。</p><p>在整个过程中，你无需考虑CSS、JavaScript来自哪里，关联的页面是否来自同一个网站。因为从始至终，你都将这些关联的资源看作是一个完整的资源在消费。这是我们习以为常的场景。</p><p>然而如果我们从系统集成的角度重新看待这个过程，就会有不同的体会。<strong>网页中对其他资源的引用，实际上表示了对其他服务计算结果的整合</strong>。一个典型的例子就是Google Analytics，虽然它是以js的形式出现。但当页面引用到了这个js资源时，实际上完成的是对Google Analytics服务的整合。</p><p>而当你点击页面中包含的链接时，浏览器会为你请求对应的网站资源，并将计算结果（大概率是另一个页面）在浏览器客户端里展示。这也可以看作是对其他系统的集成。更具体地讲，也就是浏览器客户端通过延迟（Lazy）调用的方式，整合了其他系统提供的服务。</p><p>所以无论是css、js这样的资源，还是通过超链接引用的其他页面，都是服务端返回的页面中描述的。而客户端则根据服务端提供的描述，选择恰当的时机，访问这些关联的资源，也就是整合其他系统提供的服务。这样的系统集成方式，我们称之为<strong>由服务器指导的客户端侧集成</strong>（Server-side guided client-side integration）。如图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/08/9c/08b4c4638580fc032d96c3b58a48cd9c.jpg?wh=8000x4500\" alt=\"\"></p><p>由于对于关联资源的访问是由客户端发起的，并不是由服务器端强制的，那么客户端可能出于某些原因（安全、计算资源受限等）选择不去访问某些关联资源。</p><p>比如，在智能手机大规模流行之前，大部分手机上的浏览器不具备完整执行js的能力，因而很多浏览器选择不加载任何js资源。</p><p>从这样的角度出发，我们就会发现，CSS、JavaScript或者页面中通过超链接引用的其他页面，<strong>都可以看作是对当前页面的增强</strong>。比如CSS增强了当前页面的视觉效果，js增强了当前页面的交互，页面中的超链接为页面中的内容提供了额外的信息。<strong>于是通过超媒体格式，我们不仅可以描述当前的服务，还可以描述增强的服务。</strong></p><p>比如，你在极客时间专栏里阅读这篇文章，那么当前的服务是让文章在浏览器中显示，供你阅读，这是默认服务。那么怎么增强它呢？我们可以提供语音的版本，也可以提供视频，还可以提供大字打印版等等。那么我们可以在超媒体格式中，描述这些关联的资源。如下HTML代码所示（HTML是最常见的超媒体）：</p><pre><code>&lt;article&gt;\n    &lt;title&gt;11 | 将模型实现为RESTful API（下）&lt;/title&gt;\n    &lt;p&gt;....&lt;/p&gt;\n    &lt;link href=&quot;http://voice.geekbang.org/chapter11.mp3&quot; rel=&quot;voice&quot;/&gt;\n    &lt;link href=&quot;http://video.geekbang.org/chapter11.mp4&quot; rel=&quot;video&quot;/&gt;\n    &lt;link href=&quot;http://easy-reading-print.com/13678328&quot; rel=&quot;print&quot;/&gt;\n&lt;/article&gt;\n</code></pre><p>在这段代码中，我们通过link标签，表示了这篇文章与其他资源的关系。可以看出，我们关联了“<a href=\"http://voice.geekbang.org/chapter11.mp3%E2%80%9D%E2%80%9Chttp://video.geekbang.org/chapter11.mp4%E2%80%9D%E5%92%8C%E2%80%9Chttp://easy-reading-print.com/13678328%E2%80%9D\">http://voice.geekbang.org/chapter11.mp3”“http://video.geekbang.org/chapter11.mp4”和“http://easy-reading-print.com/13678328”</a> 。它们与当前文章的关系分布为voice、video和print。此时，客户端可以根据这些额外的信息，在不同的情景下选择加载哪些额外的资源。</p><p>假设此时我们有三个客户端，分别是用于阅读的某阅读器，用于听书的某播放器，以及某个打印机。那么这些客户端只需要拿到这段超媒体，然后各自选择对应的服务即可：</p><ul>\n<li>阅读器按照HTML格式显示内容，忽略其他关联的服务；</li>\n<li>播放器从超媒体中提取由<code>voice</code>链接的资源，去加载对应的mp3，忽略其他HTML文本和服务；</li>\n<li>打印机从超媒体中提取由<code>print</code>链接的资源，送去打印，忽略其他HTML文本和服务。</li>\n</ul><p>可以看到，我们使用了同样的API，支撑起了完全不同的客户端。而这些客户端彼此之间也并不知道对方的存在，它们只关心自己关注的资源。换言之，<strong>通过超媒体描述的增强服务，让客户端和服务器之间形成了一种协商与匹配的关系，也就是我们所说的渐进式服务消费</strong>。</p><p>所谓渐进式，指得是按需索取，而不要求消费全部关联的服务。也正是渐进式的消费方式，促使互联网成为了一个异构、松耦合且开放的系统。同时这也正是我们希望自己所构建的系统能够具有的特质。</p><p>所以<strong>通过分布式超媒体的设计，实现这种渐进式服务消费，也就是我们从HTTP RPC过渡到真正的RESTful API的重中之重</strong>。</p><p>这里再讲三个题外话。第一个，<strong>以渐进式思路构造的超媒体格式，是一个被极度低估了的思考模型</strong>。</p><p>它的一个具体应用——渐进增强（Progressive Enhancement），是开发前端应用的最佳思考方式，同时也是诸多JavaScript框架的核心思路。掌握了它，你就能迅速成为资深前端工程师。</p><p>我仍然记得我是如何在领悟了渐进增强之后，在4个小时之内，从前端白丁成为前端架构师的。以及，多年前那个初秋的午后，郑晔同学（对，就是在极客时间已经写了三个专栏，正在努力写第四个的郑晔同学）在西安高新区某公交站等出租车时，跟我说起前端学习是如何如何之零碎，不如后端知识系统。当我用了20分钟给他讲了渐进增强，然后他几乎是马上就全都会了。</p><p>第二，如果通过超媒体关联的资源是代码，那么我们就能指引客户端按照服务端设计的行为，去执行和消费超媒体资源了。</p><p>比如，我们现在有一个订单，需要通过支付网关支付。而支付网关可能有很多不同的选择，网银啊、微信啊、支付宝什么的。那么我们可以通过超链接关联支付网关的客户端：</p><pre><code>&lt;article&gt;\n    &lt;title&gt;订单详情&lt;/title&gt;\n    &lt;p&gt;....&lt;/p&gt;\n    &lt;link href=&quot;http://payment.com/12358921&quot; rel=&quot;payment&quot;/&gt;    \n    &lt;link href=&quot;http://payment.geekbang.org/bank.js&quot; rel=&quot;payment-client&quot;/&gt;\n&lt;/article&gt;\n</code></pre><p>这意味着，客户端不需要知道使用的是哪个支付网关，只需要加载<code>payment-client</code>关联的资源，并通过它完成支付即可（当然我们需要提前约定JavaScript的加载策略和入口函数）。于是，服务端进一步控制了客户端的行为，不仅仅是通过超媒体指引了增强的服务，连带如何消费这些服务也提供了指引。</p><p>这就是按需代码（Code-On-Demand），通过它，我们能够在将服务器端的计算压力转移到客户端的同时，也不会丧失自己对计算的控制。此外，通过它，也进一步解耦了客户端与服务器之间的耦合。客户端不需要理解服务器端的逻辑，只需要按照指示执行代码即可。可以这么说，按需代码这个技巧，对于需要高灵活度的API设计是极其重要的。</p><p>第三，这种完全由服务端控制的客户端行为，也被称作HATEOAS（Hypermedia As The Engine Of Application State），即<strong>超媒体作为应用程序状态的控制引擎</strong>。在Richardson成熟的模型中（Richardson Maturity Model），是最高成熟度的RESTful API。我想经过今天的学习，你应该完全理解其背后的原因了。</p><p>好了，我们言归正传，接下来就看看如何使用分布式超媒体来设计API中的资源，以实现HATEOAS。</p><h2>如何将模型映射为RESTful API？</h2><h3>通过分布式超媒体设计API中涉及的资源</h3><p>首先我们需要知道什么样的格式属于超媒体。那么<strong>包含超链接的格式都可以看作超媒体</strong>，因此HTML是超媒体格式。在前面的例子里，HTML中的link是表达关联资源的主要手段，它的构成要素有两个：</p><ol>\n<li>指向关联资源的链接（href）；</li>\n<li>与主资源是哪种关联关系（rel）。</li>\n</ol><p>这两个是构成超链接的必要因素，缺一不可。同时，只要具备这两个要素，都可以被看作超链接。比如如下HTML元素，可以当作超链接：</p><pre><code>&lt;a href=&quot;http://payment.com/12358921&quot; rel=&quot;payment&quot;/&gt;\n\n\n&lt;area shape=&quot;rect&quot; coords=&quot;184,6,253,27&quot; href=&quot;http://some-place.com&quot; rel=&quot;center&quot; /&gt;\n</code></pre><p><strong>而我们常用的JSON和XML并没有提供默认的链接格式，所以它们并不是超媒体</strong>。于是我们在设计RESTful API的时候，要使用HAL（Hypertext Application Language），而不是原味的JSON或者XML（Vanilla JSON or Plain XML）。</p><p>HAL目前还是Internet标准的一个提案，你也可以自定义自己的XML和JSON超媒体格式，不过我估计最终结果和HAL应该差不多，所以还不如直接用HAL来得简单。</p><p>XML的HAL基本上就是把HTML的link作为标准标签引入了XML，而JSON的HAL则定义了_links结构来表示链接。如下所示，就是XML HAL和JSON HAL规范中给出的同一个资源的示例：</p><pre><code>Content-Type: application/hal+xml\n&lt;resource rel=&quot;self&quot; href=&quot;/orders/523&quot;&gt;\n    &lt;link rel=&quot;warehouse&quot; href=&quot;/warehouse/56&quot;/&gt;\n    &lt;link rel=&quot;invoice&quot; href=&quot;/invoices/873&quot;/&gt;\n    &lt;currency&gt;USD&lt;/currency&gt;\n    &lt;status&gt;shipped&lt;/status&gt;\n    &lt;total&gt;10.20&lt;/total&gt;\n&lt;/resource&gt;\n\n\nContent-Type: application/hal+json\n{\n  &quot;_links&quot;: {\n    &quot;self&quot;: { &quot;href&quot;: &quot;/orders/523&quot; },\n    &quot;warehouse&quot;: { &quot;href&quot;: &quot;/warehouse/56&quot; },\n    &quot;invoice&quot;: { &quot;href&quot;: &quot;/invoices/873&quot; }\n  },\n  &quot;currency&quot;: &quot;USD&quot;,\n  &quot;status&quot;: &quot;shipped&quot;,\n  &quot;total&quot;: 10.20\n}\n</code></pre><p>解决了格式问题，我们来看看怎么使用超媒体设计API中的资源。这里的关键，正如我们刚才所讲，是<strong>如何通过超链接构成渐进式服务消费</strong>。</p><p>我们仍以极客时间专栏的模型为例：<br>\n<img src=\"https://static001.geekbang.org/resource/image/d4/0b/d4b29445e50e8f57495ed9047222f40b.jpg?wh=1920x1080\" alt=\"\"><br>\n首先我们看一下聚合根的超媒体描述。对于一个User实例而言，我们可以使用如下的HAL JSON来描述它：</p><pre><code>{\n    &quot;_links&quot;: {\n        &quot;self&quot;: { &quot;href&quot;: &quot;/users/19&quot; },\n        &quot;subscriptions&quot;: { &quot;href&quot;: &quot;/users/19/subscriptions&quot; } \n    },\n    &quot;username&quot;: &quot;爱学习的鱼玄机&quot;,\n    ...\n}\n</code></pre><p>这段HAL JSON中包含两个超链接：self和subscriptions。self表明获取当前资源的URI，我们会将这个URI称作主URI（Primary URI）。这个URI从概念上来讲，和ID是等价的，也就是可以用于唯一定位当前资源的标识符。同时，self也是用以缓存的URI。</p><p>subscriptions表示了聚合关系User-Subscriptions，也就是指示了如何寻找被当前User聚合的Subscription。对于聚合根而言，需要为所有的聚合对象提供链接，以指示如何获取这些聚合对象。</p><p>你可能会问，self URI有什么用？如果单独对一个User实例而言，可能用处不大。但是在集合资源中，self URI就是不可或缺的了。比如对于<code>/users</code>，我们使用如下的HAL JSON描述：</p><pre><code>{\n    &quot;_links&quot;: {\n        &quot;self&quot; : &quot;/users&quot;\n    },\n    &quot;_embedded&quot;: {\n        &quot;users&quot;: [\n            {\n                &quot;_links&quot;: {\n                    &quot;self&quot;: &quot;/users/18&quot;\n                },\n                &quot;username&quot; : &quot;会聊骚的黄庭坚&quot;,\n                ...                \n            },\n            {\n                &quot;_links&quot;: {\n                    &quot;self&quot;: &quot;/users/19&quot;\n                },\n                &quot;username&quot; : &quot;爱学习的鱼玄机&quot;,\n                ...                                \n            },\n            ...\n        ]\n    },\n    &quot;total&quot;: 43215,\n    ...\n}\n</code></pre><p>可以看到，我们通过<code>_embedded</code>表示了所有的用户。不过这里还有一个需要我们权衡的地方。如果User对象有很多属性（比方说包含年龄、家庭住址、个人状态等），那么我们需要在<code>/users</code>的HAL JSON中包含所有这些属性吗？</p><p>如果包含所有属性，那么这个HAL JSON的体积可能会变得非常巨大；而如果不包含所有的属性，那么在客户端需要使用其中某些数据的时候，就会拿不到相应的信息。</p><p>这时候就该列表中每一个User对象中包含的self URI发挥作用了。<strong>我们可以把集合资源和其中的独立资源，看作是渐进式的两种不同服务。</strong></p><p>也就是说，我们可以把在集合资源中包含的数据，看作是更基础的服务，像常用数据这样，可以满足大部分客户端在通常情况下对用户数据的需求。而其中每一个User对象中包含的self URI所指示的服务，我们可以将其看作是增强服务，也就是全量数据。</p><p>于是，如果某个客户端需要不包含在常用数据中的信息，那么它可以通过self URI去获取全量数据。<strong>也就是说，我们将常用数据和全量数据设计成渐进式消费的两种不同的服务，并通过分布式超媒体格式，描述了它们之间的关联。</strong></p><p>这样我们就可以让同样一份超媒体描述，来支撑不同的客户端了。与此同时，我们也不需要为不同的客户端提供不同格式的数据信息。当然，你可能会问，这么做，难道不会有性能问题吗？<strong>答案是有，不过没关系，因为有缓存。</strong></p><p>REST架构大量依赖缓存来缓解性能问题。我们甚至可以说，是否能够有效地利用缓存，会决定REST架构的成败。这也是为什么我们强调主URI应该是用于缓存的URI。<strong>也就是在构造资源的时候，我们要将缓存当作必须考虑的特性，详加设计。</strong></p><p>让我通过一个例子，来看看缓存会怎样影响我们的设计决策。这也是非常常见的一个场景——分页。</p><p>你可能注意到了，在前面的HAL JSON中，<code>/users</code>一共有43215个用户，如果将所有的用户都包含进来，就会产生极大的HAL JSON文件，因此我们需要分页处理。好在这并不难：</p><pre><code>{\n    &quot;_links&quot;: {\n        &quot;self&quot; : &quot;/users&quot;,\n        &quot;next&quot; : &quot;/users?page=3&quot;\n    }\n    ...\n}\n</code></pre><p>我们可以通过next链接表示后面的一页。那么我们怎么才能通过缓存，使得当有新用户注册的时候，大部分页面的缓存都不失效呢？</p><p>一个有效的策略是，永远不缓存<code>/users</code>页面，也就是<code>/users</code>永远表示新近注册的用户。如果它们达到分页上限时（比如50），就生成新的页面id，并缓存它，然后继续使用<code>/users</code>等待新注册的用户。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/79/f4f2c9120de1a3ee11d6a3df455e6179.jpg?wh=8000x4500\" alt=\"\"></p><p>那么前面几页的HAL JSON可能就是这样子的（如下所示）。而且你会发现缓存下来的页面，我们永远不需要修改其中的内容：</p><pre><code>// 以下为未被缓冲的信息\n{\n    &quot;_links&quot;: {\n        &quot;self&quot; : &quot;/users&quot;,\n        &quot;next&quot; : &quot;/users?page=4&quot;\n    }\n    ...\n}\n\n\n// 以下为被缓冲的信息\n{\n    &quot;_links&quot;: {\n        &quot;self&quot; : &quot;/users?page=4&quot;,\n        &quot;next&quot; : &quot;/users?page=3&quot;\n    }\n    ...\n}\n\n\n{\n    &quot;_links&quot;: {\n        &quot;self&quot; : &quot;/users?page=3&quot;,\n        &quot;next&quot; : &quot;/users?page=2&quot;\n    }\n    ...\n}\n</code></pre><p>那你可能会有疑问，如果客户端与服务端对分页的要求不同，这时候该怎么办？比如客户端需要每页显示50条，而服务器端则需要按每页20条缓存？</p><p>答案是：<strong>服务器永远不需要考虑客户端的需求。</strong>把客户端的额外需求，当作渐进式服务消费的需求，那我们只需要提供对应的链接即可。</p><p>也就是说，只要保证页面间的链接，剩下的就交由客户端自行处理。<strong>这就是互联网架构的精髓，将集成与订制推向客户端，从而保持服务端的稳定。</strong></p><h3>将API映射回业务流程</h3><p>在我们将API中涉及的资源都使用分布式超媒体描述了之后，我们就获得了完整的API定义。而且，借由分布式超媒体，我们可以达成HATEOAS，实现渐进式服务消费，从而充分分离客户端与服务端的耦合与依赖。此外，如果你充分考虑了缓存策略，性能也不会构成任何问题。</p><p>那么剩下的最后一步，就是将API重新映射回所需要支撑的业务流程或者用户旅程之中，与业务方一起验证这些API是否能够满足所有的需求。示意图如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/53/88/531a6689579558bcf45ffd9a3fc05688.jpg?wh=8000x4500\" alt=\"\"></p><p>如果我们将API作为模型的另一种表现形式，那么映射会在流程中与业务方验证，也就和磋商形成统一语言的过程一致了。我想你已经有足够的了解了，就不再赘述了。</p><h2>小结</h2><p>这节课我们讲述了什么是分布式超媒体，以及为什么它是互联网架构的默认集成模式。以及我们如何通过使用分布式超媒体形成渐进式服务消费。并以此为核心理念，讨论了如何描述API中的资源。此外，我们还重点讨论了集合资源，以及如何通过缓存解决分页等问题，并通过一个分页的例子展示了如何将客户端与服务端充分解耦。</p><p>至此，你应该学会了在单体分层架构模式下，如何将模型的能力通过RESTful API暴露。那么接下来，我们将进入云时代的业务建模，看看新的架构约束到底将会怎样影响我们建立业务模型。</p><p>编辑小提示：为了方便读者间的交流学习，我们建立了微信读者群。想要加入的同学，戳此加入<a href=\"https://jinshuju.net/f/wjtvTP\">“如何落地业务建模”交流群</a>&gt;&gt;&gt;</p><h2>思考题</h2><p>你是如何理解云平台的？在你看来，云平台的哪些特性会影响我们的业务模型？</p><p><img src=\"https://static001.geekbang.org/resource/image/c6/c4/c67a591e4ef68e1d42a952dea12408c4.jpg?wh=1500x1798\" alt=\"\"></p><p>欢迎把你的思考和想法分享在留言区，我会和你交流。那么旧约部分到这里就结束了，我们新约篇章再见！</p>","comments":[{"had_liked":false,"id":303465,"user_name":"大海浮萍","can_delete":false,"product_type":"c1","uid":1067638,"ip_address":"","ucode":"7A3B9011C639ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/76/abb7bfe3.jpg","comment_is_top":true,"comment_ctime":1626802137,"is_pvip":false,"replies":[{"id":"109837","content":"修改状态是post 修改信息是put","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626821377,"ip_address":"","comment_id":303465,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233720556614001e+18","product_id":100082101,"comment_content":"看完restful api第二章，还是有些疑问，比如在采购订单场景下，修改订单（修改基本信息）和发布订单（修改状态，通知下游），感觉只能都设计成 PUT &#47;order&#47;{order_id}，那如何区分这两种用例呢，请赐教","like_count":4,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523692,"discussion_content":"修改状态是post 修改信息是put","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626821377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311424,"user_name":"哈德韦","can_delete":false,"product_type":"c1","uid":1637085,"ip_address":"","ucode":"E7C9B3D087D2D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/fa/dd/f640711f.jpg","comment_is_top":false,"comment_ctime":1631234634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"40285940298","product_id":100082101,"comment_content":"我还以为@郑晔 大佬和我一样在公交车站是在等公交车🚌，现在知道自己和大佬的区别了。","like_count":9},{"had_liked":false,"id":303558,"user_name":"绝露","can_delete":false,"product_type":"c1","uid":1136244,"ip_address":"","ucode":"5DD2F131B5903B","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/74/7ef8b5a0.jpg","comment_is_top":false,"comment_ctime":1626854551,"is_pvip":false,"replies":[{"id":"109880","content":"没有","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626864295,"ip_address":"","comment_id":303558,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27396658327","product_id":100082101,"comment_content":"有没有写过文章，描述那4个小时发生了什么。 非常好奇。","like_count":6,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523736,"discussion_content":"没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626864295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2388512,"avatar":"https://static001.geekbang.org/account/avatar/00/24/72/20/733fdd94.jpg","nickname":"王帅","note":"","ucode":"EE352769ABFAA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571926,"discussion_content":"前端同学坐不住了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652494792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350419,"user_name":"云川","can_delete":false,"product_type":"c1","uid":1087077,"ip_address":"","ucode":"49EC5972B9EB1C","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/65/aaf5985b.jpg","comment_is_top":false,"comment_ctime":1656905567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10246840159","product_id":100082101,"comment_content":"分页的例子中，如果前端的需求是分页且多条件查询，对Rest架构的后端是不是就无解了？","like_count":2},{"had_liked":false,"id":306720,"user_name":"支离书","can_delete":false,"product_type":"c1","uid":1026921,"ip_address":"","ucode":"AD2570AC5EF7BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/69/5f1f0d1c.jpg","comment_is_top":false,"comment_ctime":1628680533,"is_pvip":false,"replies":[{"id":"111062","content":"如果你需要web的scale 那么就要这么做 不需要随便怎么做都可以","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1628682992,"ip_address":"","comment_id":306720,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10218615125","product_id":100082101,"comment_content":"服务器永远不需要考虑客户端的需求。 --这话客户端同学不答应啊，并且考虑大部分中小公司现状，前端人员一般没有后端人员资历深，让前端因为分页数不一致就加一堆逻辑恐怕也不现实啊。。更何况要把集成与订制的责任交给前端了。。","like_count":2,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524890,"discussion_content":"如果你需要web的scale 那么就要这么做 不需要随便怎么做都可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628682992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551774,"discussion_content":"我觉得是要分具体场景的，不能单独拿一句话出来解读。\n另，“服务器永远不需要考虑客户端的需求”，里面的“永远”太绝对了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645109383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147456,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/40/02ae9409.jpg","nickname":"Learner","note":"","ucode":"289EBF7A445808","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393317,"discussion_content":"我不赞同这种做法，后端完全可以通过适配器来匹配前端的需求，这种不管前端具体需求丢一堆数据的做法不可取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631354632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303770,"user_name":"：）byebye burden","can_delete":false,"product_type":"c1","uid":1418207,"ip_address":"","ucode":"2AE345D40898E4","user_header":"https://static001.geekbang.org/account/avatar/00/15/a3/df/a0e60008.jpg","comment_is_top":false,"comment_ctime":1626973155,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10216907747","product_id":100082101,"comment_content":"业务流程就是编排API的过程","like_count":2},{"had_liked":false,"id":347061,"user_name":"Geek_123","can_delete":false,"product_type":"c1","uid":1446508,"ip_address":"","ucode":"52C65EA3C24F63","user_header":"","comment_is_top":false,"comment_ctime":1653652172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5948619468","product_id":100082101,"comment_content":"和郑晔同学讲的20分钟 前台渐进增强，希望能详细讲讲，怎么就迅速成为资深架构师了~","like_count":1},{"had_liked":false,"id":306718,"user_name":"支离书","can_delete":false,"product_type":"c1","uid":1026921,"ip_address":"","ucode":"AD2570AC5EF7BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/69/5f1f0d1c.jpg","comment_is_top":false,"comment_ctime":1628680239,"is_pvip":false,"replies":[{"id":"111061","content":"从有缓存的开始 到最新的","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1628682942,"ip_address":"","comment_id":306718,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5923647535","product_id":100082101,"comment_content":"&#47;users一直返回最新注册的用户，那么就不是固定的50个了吧？第一页的数据个数就一直在变了。。就必须靠客户端解决这个问题了，不仅是在每页个数不同时需要客户端解决了","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524889,"discussion_content":"从有缓存的开始 到最新的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628682942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304877,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1627653739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5922621035","product_id":100082101,"comment_content":"本章<br>很棒的洞见，我还得再品品。这是一句废话，但真长见识了，得再想想。<br>课后题：<br>在我原本的理解。云平台是实现层面的优化，而业务建模是抽象层面的活，业务模型理应不受云平台的出现而改变。从实现层面的效率优化反向影响抽象层面的模型设计，有意思的思路，期待老师的内容。","like_count":1},{"had_liked":false,"id":303884,"user_name":"邓志国","can_delete":false,"product_type":"c1","uid":1043844,"ip_address":"","ucode":"380AE67ED7B9D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/84/0b8e2d25.jpg","comment_is_top":false,"comment_ctime":1627045643,"is_pvip":false,"replies":[{"id":"109989","content":"这是客户端应该有的样子","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1627048409,"ip_address":"","comment_id":303884,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5922012939","product_id":100082101,"comment_content":"这种客户端，是又一次发明了浏览器吗？","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523863,"discussion_content":"这是客户端应该有的样子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627048409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303496,"user_name":"Oops!","can_delete":false,"product_type":"c1","uid":1479474,"ip_address":"","ucode":"E2678CC12121A7","user_header":"https://static001.geekbang.org/account/avatar/00/16/93/32/e11fcd33.jpg","comment_is_top":false,"comment_ctime":1626833755,"is_pvip":false,"replies":[{"id":"109851","content":"查询一般post 表示不可缓存 ","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626839464,"ip_address":"","comment_id":303496,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5921801051","product_id":100082101,"comment_content":"我的理解是本节主要讲了RESTFUL API的一个准标准：HAL，前端开发的时候也需要遵循这个标准才能woker吧。比如分页的例子，前端按50每页加载，后端20每页的往外吐，那前端就需要理解这个next链接隐含的含义，即next链接返回接下来的数据，但是不一定符合页面分页模式，然后前端需要一直调用next,直到凑足50条，是这样吗？另外，关于缓存，按文中所提模式，如果查询条件比较复杂多变，比如有排序项，过滤等，那这个缓存会不会过于复杂。进一步的，如果允许用户注销，用户注销后，前面缓存的这个用户信息该怎么处理？","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523707,"discussion_content":"查询一般post 表示不可缓存 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626839464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303309,"user_name":"赵晏龙","can_delete":false,"product_type":"c1","uid":2673605,"ip_address":"","ucode":"F15730BCA97EE0","user_header":"https://static001.geekbang.org/account/avatar/00/28/cb/c5/c1d7ca5e.jpg","comment_is_top":false,"comment_ctime":1626709926,"is_pvip":false,"replies":[{"id":"109774","content":"www就这么感 在规模优先的系统下 唯一选择","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626713354,"ip_address":"","comment_id":303309,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5921677222","product_id":100082101,"comment_content":"【服务器永远不需要考虑客户端的需求】这是我在这一章里面学到的最重要的东西，结合你讲的渐进式服务消费，确实能解决一些问题。","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523625,"discussion_content":"www就这么感 在规模优先的系统下 唯一选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626713354,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360924,"user_name":"JianXu","can_delete":false,"product_type":"c1","uid":1033219,"ip_address":"上海","ucode":"2A61BDBB573BDC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/03/f753fda7.jpg","comment_is_top":false,"comment_ctime":1667000446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1667000446","product_id":100082101,"comment_content":"老师，你能简短的说一下您的学习方法吗？我看您的文章，有一种维度更高的感觉。同样学习restful , 感觉自己就是学了个皮，精髓没有摸到。","like_count":0},{"had_liked":false,"id":356134,"user_name":"leesper","can_delete":false,"product_type":"c1","uid":1351104,"ip_address":"贵州","ucode":"CC76320571BECA","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/c0/cb5341ec.jpg","comment_is_top":false,"comment_ctime":1662002423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662002423","product_id":100082101,"comment_content":"老师，分页那个例子为啥是倒着来的？本页是4，nextpage为啥是3？","like_count":0},{"had_liked":false,"id":346239,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1652936498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652936498","product_id":100082101,"comment_content":"有的时候背负巨大的工作量，原来是替前端写了代码！<br>作为一个后端，确实不应该操前端心<br>前端，颤抖吧","like_count":0},{"had_liked":false,"id":326003,"user_name":"Geek_fe0336","can_delete":false,"product_type":"c1","uid":1422144,"ip_address":"","ucode":"09D070BD4EFB57","user_header":"https://static001.geekbang.org/account/avatar/00/15/b3/40/54894c8f.jpg","comment_is_top":false,"comment_ctime":1639302306,"is_pvip":false,"replies":[{"id":"118237","content":"也可以是：不会考证李商隐是gay的软件工程师就不是好的咨询师！","user_name":"编辑回复","user_name_real":"编辑","uid":"2189689","ctime":1639303604,"ip_address":"","comment_id":326003,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1639302306","product_id":100082101,"comment_content":"看来不会弹吉他的软件工程师不是好咨询师啊！","like_count":0,"discussions":[{"author":{"id":2189689,"avatar":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","nickname":"🐑","note":"","ucode":"DE34B3B14287D1","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538026,"discussion_content":"也可以是：不会考证李商隐是gay的软件工程师就不是好的咨询师！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639303604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313493,"user_name":"深山小书童","can_delete":false,"product_type":"c1","uid":1079593,"ip_address":"","ucode":"6B5DD3B3D84534","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/29/a90cf777.jpg","comment_is_top":false,"comment_ctime":1632464590,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632464590","product_id":100082101,"comment_content":"hal json是不是意味着要加一层bff来适配各种客户端","like_count":0},{"had_liked":false,"id":311425,"user_name":"哈德韦","can_delete":false,"product_type":"c1","uid":1637085,"ip_address":"","ucode":"E7C9B3D087D2D9","user_header":"https://static001.geekbang.org/account/avatar/00/18/fa/dd/f640711f.jpg","comment_is_top":false,"comment_ctime":1631234697,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631234697","product_id":100082101,"comment_content":"好多年前尝试在公司推渐进增强，推不动于是离开了","like_count":0},{"had_liked":false,"id":306913,"user_name":"輪迴","can_delete":false,"product_type":"c1","uid":1010641,"ip_address":"","ucode":"7504F61285BE35","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/d1/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1628773471,"is_pvip":true,"replies":[{"id":"111144","content":"不新颖 就是从web总结出来的","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1628780937,"ip_address":"","comment_id":306913,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628773471","product_id":100082101,"comment_content":"渐进式服务消费很新颖的思路，这种方式对多变的前端开发是否合适？移动端设备的性能与存储的取舍都需要考虑。","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524973,"discussion_content":"不新颖 就是从web总结出来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628780937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305392,"user_name":"帅气のboy","can_delete":false,"product_type":"c1","uid":1517767,"ip_address":"","ucode":"30DCA27B9F8459","user_header":"https://static001.geekbang.org/account/avatar/00/17/28/c7/c5c67391.jpg","comment_is_top":false,"comment_ctime":1627957719,"is_pvip":false,"replies":[{"id":"110463","content":"是个定位问题 定位为业务能力 和定位成后端 前端的心态是不一样的","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1627960922,"ip_address":"","comment_id":305392,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1627957719","product_id":100082101,"comment_content":"实际业务中要让前端接受这个方式可能会很难。但是这个思想可以指导服务端将业务代码写成分层结构，越底层的越是通用不变的，越上层的就可以是下层多个接口的组合","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524373,"discussion_content":"是个定位问题 定位为业务能力 和定位成后端 前端的心态是不一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627960922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303166,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1096652,"ip_address":"","ucode":"E79CEA70430449","user_header":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","comment_is_top":false,"comment_ctime":1626629764,"is_pvip":true,"replies":[{"id":"109718","content":"如人饮水","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626652120,"ip_address":"","comment_id":303166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626629764","product_id":100082101,"comment_content":"渐进式服务消费有那么厉害吗。。。","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523572,"discussion_content":"如人饮水","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626652120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302965,"user_name":"敬","can_delete":false,"product_type":"c1","uid":1008801,"ip_address":"","ucode":"232FB849D9D8F1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/64/a1/9f2900d9.jpg","comment_is_top":false,"comment_ctime":1626487455,"is_pvip":true,"replies":[{"id":"109641","content":"缓存 ","user_name":"作者回复","user_name_real":"徐八叉","uid":"2537798","ctime":1626495704,"ip_address":"","comment_id":302965,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1626487455","product_id":100082101,"comment_content":"渐进式增强和性能如何权衡呢？比如一个page由多个module组成，一个module由多个element组成，如果&#47;pages&#47;{pageid}只返回module的超链接集合，前端要请求多少次啊？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523495,"discussion_content":"缓存 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626495704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1028208,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b0/70/d3cf607b.jpg","nickname":"lexus","note":"","ucode":"D67BB1E5778E23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556551,"discussion_content":"引入缓存就增加了整个架构的复杂度，我想这也是为什么没推起来的主要原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647415912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008801,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/64/a1/9f2900d9.jpg","nickname":"敬","note":"","ucode":"232FB849D9D8F1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384601,"discussion_content":"不管服务还是客户端缓存，要保持渐进风格，都存在第一次要多次交互的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626675788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}