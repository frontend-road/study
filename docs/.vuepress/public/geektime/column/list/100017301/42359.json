{"id":42359,"title":"14 | 排序优化：如何实现一个通用的、高性能的排序函数？","content":"<p>几乎所有的编程语言都会提供排序函数，比如C语言中qsort()，C++ STL中的sort()、stable_sort()，还有Java语言中的Collections.sort()。在平时的开发中，我们也都是直接使用这些现成的函数来实现业务逻辑中的排序功能。那你知道这些排序函数是如何实现的吗？底层都利用了哪种排序算法呢？</p><p>基于这些问题，今天我们就来看排序这部分的最后一块内容：<strong><span class=\"orange\">如何实现一个通用的、高性能的排序函数？</span></strong></p><h2>如何选择合适的排序算法？</h2><p>如果要实现一个通用的、高效率的排序函数，我们应该选择哪种排序算法？我们先回顾一下前面讲过的几种排序算法。</p><p><img src=\"https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg?wh=1142*698\" alt=\"\"></p><p>我们前面讲过，线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p><p>如果对小规模数据进行排序，可以选择时间复杂度是O(n<sup>2</sup>)的算法；如果对大规模数据进行排序，时间复杂度是O(nlogn)的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是O(nlogn)的排序算法来实现排序函数。</p><p>时间复杂度是O(nlogn)的排序算法不止一个，我们已经讲过的有归并排序、快速排序，后面讲堆的时候我们还会讲到堆排序。堆排序和快速排序都有比较多的应用，比如Java语言采用堆排序实现排序函数，C语言使用快速排序实现排序函数。</p><!-- [[[read_end]]] --><p>不知道你有没有发现，使用归并排序的情况其实并不多。我们知道，快排在最坏情况下的时间复杂度是O(n<sup>2</sup>)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是O(nlogn)，从这点上看起来很诱人，那为什么它还是没能得到“宠信”呢？</p><p>还记得我们上一节讲的归并排序的空间复杂度吗？归并排序并不是原地排序算法，空间复杂度是O(n)。所以，粗略点、夸张点讲，如果要排序100MB的数据，除了数据本身占用的内存之外，排序算法还要额外再占用100MB的内存空间，空间耗费就翻倍了。</p><p>前面我们讲到，快速排序比较适合来实现排序函数，但是，我们也知道，快速排序在最坏情况下的时间复杂度是O(n<sup>2</sup>)，如何来解决这个“复杂度恶化”的问题呢？</p><h2>如何优化快速排序？</h2><p>我们先来看下，为什么最坏情况下快速排序的时间复杂度是O(n<sup>2</sup>)呢？我们前面讲过，如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为O(n<sup>2</sup>)。实际上，<strong>这种O(n<sup>2</sup>)时间复杂度出现的主要原因还是因为我们分区点选得不够合理</strong>。</p><p>那什么样的分区点是好的分区点呢？或者说如何来选择分区点呢？</p><p>最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多</strong>。</p><p>如果很粗暴地直接选择第一个或者最后一个数据作为分区点，不考虑数据的特点，肯定会出现之前讲的那样，在某些情况下，排序的最坏情况时间复杂度是O(n<sup>2</sup>)。为了提高排序算法的性能，我们也要尽可能地让每次分区都比较平均。</p><p>我这里介绍两个比较常用、比较简单的分区算法，你可以直观地感受一下。</p><h3>1.三数取中法</h3><p>我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p><h3>2.随机法</h3><p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的O(n<sup>2</sup>)的情况，出现的可能性不大。</p><p>好了，我这里也只是抛砖引玉，如果想了解更多寻找分区点的方法，你可以自己课下深入去学习一下。</p><p>我们知道，快速排序是用递归来实现的。我们在递归那一节讲过，递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p><h2>举例分析排序函数</h2><p>为了让你对如何实现一个排序函数有一个更直观的感受，我拿Glibc中的qsort()函数举例说明一下。虽说qsort()从名字上看，很像是基于快速排序算法实现的，实际上它并不仅仅用了快排这一种算法。</p><p>如果你去看源码，你就会发现，<strong>qsort()会优先使用归并排序来排序输入数据</strong>，因为归并排序的空间复杂度是O(n)，所以对于小数据量的排序，比如1KB、2KB等，归并排序额外需要1KB、2KB的内存空间，这个问题不大。现在计算机的内存都挺大的，我们很多时候追求的是速度。还记得我们前面讲过的用空间换时间的技巧吗？这就是一个典型的应用。</p><p>但如果数据量太大，就跟我们前面提到的，排序100MB的数据，这个时候我们再用归并排序就不合适了。所以，<strong>要排序的数据量比较大的时候，qsort()会改为用快速排序算法来排序</strong>。</p><p>那qsort()是如何选择快速排序算法的分区点的呢？如果去看源码，你就会发现，qsort()选择分区点的方法就是“三数取中法”。是不是也并不复杂？</p><p>还有我们前面提到的递归太深会导致堆栈溢出的问题，qsort()是通过自己实现一个堆上的栈，手动模拟递归来解决的。我们之前在讲递归那一节也讲过，不知道你还有没有印象？</p><p>实际上，qsort()并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于4时，qsort()就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，在小规模数据面前，<strong>O(n<sup>2</sup>)时间复杂度的算法并不一定比O(nlogn)的算法执行时间长</strong>。我们现在就来分析下这个说法。</p><p>我们在讲复杂度分析的时候讲过，算法的性能可以通过时间复杂度来分析，但是，这种复杂度分析是比较偏理论的，如果我们深究的话，实际上时间复杂度并不等于代码实际的运行时间。</p><p>时间复杂度代表的是一个增长趋势，如果画成增长曲线图，你会发现O(n<sup>2</sup>)比O(nlogn)要陡峭，也就是说增长趋势要更猛一些。但是，我们前面讲过，在大O复杂度表示法中，我们会省略低阶、系数和常数，也就是说，O(nlogn)在没有省略低阶、系数、常数之前可能是O(knlogn + c)，而且k和c有可能还是一个比较大的数。</p><p>假设k=1000，c=200，当我们对小规模数据（比如n=100）排序时，n<sup>2</sup>的值实际上比knlogn+c还要小。</p><pre><code>knlogn+c = 1000 * 100 * log100 + 200 远大于10000\n\nn^2 = 100*100 = 10000\n</code></pre><p>所以，对于小规模数据的排序，O(n<sup>2</sup>)的排序算法并不一定比O(nlogn)排序算法执行的时间长。对于小数据量的排序，我们选择比较简单、不需要递归的插入排序算法。</p><p>还记得我们之前讲到的哨兵来简化代码，提高执行效率吗？在qsort()插入排序的算法实现中，也利用了这种编程技巧。虽然哨兵可能只是少做一次判断，但是毕竟排序函数是非常常用、非常基础的函数，性能的优化要做到极致。</p><p>好了，C语言的qsort()我已经分析完了，你有没有觉得其实也不是很难？基本上都是用了我们前面讲到的知识点，有了前面的知识积累，看一些底层的类库的时候是不是也更容易了呢？</p><h2>内容小结</h2><p>今天我带你分析了一下如何来实现一个工业级的通用的、高效的排序函数，内容比较偏实战，而且贯穿了一些前面几节的内容，你要多看几遍。我们大部分排序函数都是采用O(nlogn)排序算法来实现，但是为了尽可能地提高性能，会做很多优化。</p><p>我还着重讲了快速排序的一些优化策略，比如合理选择分区点、避免递归太深等等。最后，我还带你分析了一个C语言中qsort()的底层实现原理，希望你对此能有一个更加直观的感受。</p><h2>课后思考</h2><p>在今天的内容中，我分析了C语言的中的qsort()的底层排序算法，你能否分析一下你所熟悉的语言中的排序函数都是用什么排序算法实现的呢？都有哪些优化技巧？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p><hr><p><strong><span class=\"orange\">特别说明：</span></strong></p><p>专栏已经更新一月有余，我在留言区看到很多同学说，希望给出课后思考题的标准答案。鉴于留言区里本身就有很多非常好的答案，之后我会将我认为比较好的答案置顶在留言区，供需要的同学参考。</p><p>如果文章发布一周后，留言里依旧没有比较好的答案，我会把我的答案写出来置顶在留言区。</p><p>最后，<strong>希望你把思考的过程看得比标准答案更重要。</strong></p>","comments":[{"had_liked":false,"id":34407,"user_name":"刘強","can_delete":false,"product_type":"c1","uid":1035612,"ip_address":"","ucode":"B2E41BB894A727","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","comment_is_top":false,"comment_ctime":1540165363,"is_pvip":false,"discussion_count":24,"race_medal":0,"score":"2617175248627","product_id":100017301,"comment_content":"我们的教育让我们对标准答案的依赖太深了，让我们失去了独立思考的能力。深深的感受到了这一点。思考的过程比标准答案更重要，这句话才是关键。","like_count":610,"discussions":[{"author":{"id":1514305,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","nickname":"xk_","note":"","ucode":"DFE1AC38EA78A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1221,"discussion_content":"我觉得还有一点高中3年太短了，竞争太激烈了，哪有时间独立思考啊。但是，教育让我明白，有目的的去学习会更加的效率。\n","likes_number":26,"is_delete":false,"is_hidden":false,"ctime":1562410669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264920,"discussion_content":"过于偏激的观点\n","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1589358471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1646965,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLQl2kFWIJlknTH3mB2qib6kibiagp7g9g9TVCPP4QsMTegEmib8N2B1mxvVE5snjun3MNwONJGtaazqw/132","nickname":"单源最长路","note":"","ucode":"5CF27DC752D98A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13906,"discussion_content":"学而不思则罔，思而不学则殆，思考和答案都很重要","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1568713461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1517095,"avatar":"https://static001.geekbang.org/account/avatar/00/17/26/27/a4abd984.jpg","nickname":"kango","note":"","ucode":"3D740DB0CE94F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":269516,"discussion_content":"给出一个比较好的解法，也是让人借鉴，给人验证用，毕竟学习都是从模仿开始的","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1589903706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1036987,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d2/bb/3b1a1347.jpg","nickname":"大雪山圣地","note":"","ucode":"A161F7E12F1BAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367121,"discussion_content":"又一个被公知洗脑了的","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1618275177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245802,"discussion_content":"我觉得思考过程与标准结果，同样重要。面试中、工作中，面试官或者领导是很希望我们能够通过自己的思考来解决问题的，但是思考的结果要与面试官或者领导的想法保持比较一致，才能得到更好的正向反馈，促进自己的进步","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1587700545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1421584,"avatar":"https://static001.geekbang.org/account/avatar/00/15/b1/10/0748204e.jpg","nickname":"吃鱼的Simon","note":"","ucode":"8C38441CDE0D28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381689,"discussion_content":"何不食肉糜？那些死活想不出来的人，不配学个标准答案了？先解决有没有，再解决好不好","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1625187419,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1421584,"avatar":"https://static001.geekbang.org/account/avatar/00/15/b1/10/0748204e.jpg","nickname":"吃鱼的Simon","note":"","ucode":"8C38441CDE0D28","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381861,"discussion_content":"你知道为何简单的问题，都死活想不出来吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625243439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381689,"ip_address":""},"score":381861,"extra":""}]},{"author":{"id":1517195,"avatar":"https://static001.geekbang.org/account/avatar/00/17/26/8b/d5e27bd0.jpg","nickname":"张小张","note":"","ucode":"0DBEF42144BDC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370857,"discussion_content":"甩锅教育，想要标准答案明明就是偷懒不想思考","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1619569538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200140,"avatar":"https://static001.geekbang.org/account/avatar/00/12/50/0c/5c6b2233.jpg","nickname":"徐萌","note":"","ucode":"0937E75DB9C69F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":235044,"discussion_content":"过于愤青，对我而言，给出答案只是方便对比其它人的实现，程序实现本来就挺多样","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587014385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382394,"discussion_content":"就我个人而言，想要一个权威答案是为了面试求稳","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1625555531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1035612,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/5c/e09eac13.jpg","nickname":"刘強","note":"","ucode":"B2E41BB894A727","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382912,"discussion_content":"是的，各有各的想法，我只是表达我的观点而已","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625789802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":382394,"ip_address":""},"score":382912,"extra":""}]},{"author":{"id":1716015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2f/2f/f434b676.jpg","nickname":"背靠咸🐟遇见🐱","note":"","ucode":"30113675864F23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380617,"discussion_content":"我只是简单的想要个老师的答案来和自己的对比下，或者是在我怎么都想不出来的时候能看下别人是什么思路的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624606463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1711363,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqiaEI7wXhKvaEfUbQOyMMXvHPwgOMlNO26wBNianWJTtibQwpDTDkmpJBlff2fHYwwbkEnMVB3ibuicIQ/132","nickname":"Jerry Wu","note":"","ucode":"85F9E5060A2A01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332479,"discussion_content":"应试阶段，追求的就是答案，如果能力或者说知识储备已无需应试或者面试，另当别论。另外，我愿意做一个丧失独立思考能力的刷题人...","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607235742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1224554,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/RQdib68D7dsoFlYXOweiaPqLrcyn2jD6DCGnz8nc2VFmhmX0bpGTeSrVM5M9Qs7ibIInAmt5MeLcpcNja5YjyZCIg/132","nickname":"bigzuo","note":"","ucode":"448C258D31A8A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311699,"discussion_content":"真好的一个答案","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602465510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132312,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","nickname":"o0oi1i","note":"","ucode":"D1F6AD4AAEAFBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":247274,"discussion_content":"顶","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587807385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1038449,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/71/d6f79534.jpg","nickname":"一个工匠","note":"","ucode":"2168BA6F926074","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558622,"discussion_content":"我同意你的观点，也支持你不对评论进行回复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648401428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1608726,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/eVgcqg5p554rB5Oxs5uOBRtiaTkaGJoPf8IODUWdRPicgUonTtCyK0YJ8t0hTAtHoSMAr8jZNWwJgQtMu5NMcS0w/132","nickname":"去777","note":"","ucode":"8EF8CF537ABED3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547349,"discussion_content":"太教条","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642645395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020529,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/71/9fd7cd7a.jpg","nickname":"Daniel","note":"","ucode":"282E09B3146501","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364775,"discussion_content":"应试考试，让我们变成了一个不如”英语文盲“的人，我第了一个美国电影，里面一个地主让黑人奴婢看契约，黑人说我是文盲，不认识字，我瞬间就被震撼了，试问国内的教育，有多少学生是，会写英文和阅读英文，真到和外国人交流的时候就变成了“哑巴”，我当时在想，我是不是连一个“文盲”都不如","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617601492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2006370,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6O7eHEFkNbA2CWSJgtSTib1mo7Ib5ksy83gSwkajjJv48ZmBB2icND6FibuOhNEtrXdIqn5rQV2yZzg/132","nickname":"602089","note":"","ucode":"FC0E36D7E08AB6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1020529,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/71/9fd7cd7a.jpg","nickname":"Daniel","note":"","ucode":"282E09B3146501","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":369845,"discussion_content":"震惊了，还有这种新的舔国外大法？一个人能说本国母语，不识字在你看来都是多么了不起的事情了？我国普遍新一代人既能说本国母语，也都识字，你觉得还不如它？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619171937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364775,"ip_address":""},"score":369845,"extra":""},{"author":{"id":2190078,"avatar":"https://static001.geekbang.org/account/avatar/00/21/6a/fe/3ac6392c.jpg","nickname":"Mr.K","note":"","ucode":"601ECA7C36AAE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020529,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/71/9fd7cd7a.jpg","nickname":"Daniel","note":"","ucode":"282E09B3146501","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":370234,"discussion_content":"这多像公知说出来的话，首先英语教育目的不全是为了口语交流，比如我们程序员用英语最多是类似看java doc，不需要你会口语；你要出国留学或者定居完全可以请个口语老师啊，义务教育没必要为你的需求买单。你是不是又该羡慕国外快乐教育了，觉得他们多好，实际上有钱人家的精英教育放学后还是一堆私教课程。西方的大众教育只提供基本、有限的教育，要想成为精英，就必须复出更多的金钱，而中国是公立学校的教学质量反而更好。应试教育影不影响创新呢，目前暂没有发现有什么影响，因为应试是塞给你大量知识，并不是说不让你去思考，日韩也是这种填鸭式学习，也没见人家没创新。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1619341788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364775,"ip_address":""},"score":370234,"extra":""},{"author":{"id":1511778,"avatar":"https://static001.geekbang.org/account/avatar/00/17/11/62/737836a4.jpg","nickname":"梧桐树下","note":"","ucode":"EF87F14198B1AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020529,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/71/9fd7cd7a.jpg","nickname":"Daniel","note":"","ucode":"282E09B3146501","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":414971,"discussion_content":"和一个在中国出差的老外交流，震惊的是，他居然不会讲中文！这个“中文文盲”完全没意识到自己自己有多么无知！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636949207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364775,"ip_address":""},"score":414971,"extra":""}]},{"author":{"id":1254814,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/9e/69b65b6f.jpg","nickname":"一棵开花的树","note":"","ucode":"01688DC32E4F8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337809,"discussion_content":"要养成独立思考独立探索独立解决问题的能力","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609079424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1607993,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJOrAsTjYmJxWt31ibJhnBkXvHSqsiaTCGM9EBFIE589LZvLCdFzJs0sGIpAic6QLI4ibw01aPIAIweeQ/132","nickname":"Jeffery_Yu","note":"","ucode":"CB2558760C5255","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297452,"discussion_content":"人是一颗会思想的芦苇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596942172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34522,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1540198580,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"1749591888052","product_id":100017301,"comment_content":"查看了下Arrays.sort的源码，主要采用TimSort算法, 大致思路是这样的：<br><br>1 元素个数 &lt; 32, 采用二分查找插入排序(Binary Sort)<br>2 元素个数 &gt;= 32, 采用归并排序，归并的核心是分区(Run)<br>3 找连续升或降的序列作为分区，分区最终被调整为升序后压入栈<br>4 如果分区长度太小，通过二分插入排序扩充分区长度到分区最小阙值<br>5 每次压入栈，都要检查栈内已存在的分区是否满足合并条件，满足则进行合并<br>6 最终栈内的分区被全部合并，得到一个排序好的数组<br><br>Timsort的合并算法非常巧妙：<br><br>1 找出左分区最后一个元素(最大)及在右分区的位置<br>2 找出右分区第一个元素(最小)及在左分区的位置<br>3 仅对这两个位置之间的元素进行合并，之外的元素本身就是有序的","like_count":408,"discussions":[{"author":{"id":1020861,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/bd/f3977ebb.jpg","nickname":"John","note":"","ucode":"E4ADF8488953FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266278,"discussion_content":"还有Arrays.sort(Number[])用了DualPivotQuicksort.","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1589500336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122074,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1f/1a/54a00fdb.jpg","nickname":"artshell","note":"","ucode":"A74C45DA8FC550","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96863,"discussion_content":"jdk 7后算法经过优化了 DualPivotQuicksort这个类","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577097454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2715388,"avatar":"","nickname":"Geek8535","note":"","ucode":"D1919541632C95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407014,"discussion_content":"arr < 47是用的插入排序","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634891794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2715388,"avatar":"","nickname":"Geek8535","note":"","ucode":"D1919541632C95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407009,"discussion_content":"Arrays.sort arr >= 47 || arr < 286 是快排，arr>=286 但是arr里面降序太多的话应该是觉得是没有结构的数据，The array is not highly structured,use Quicksort instead of merge sort又转回快排，正常大于286就是归并了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634890686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1350567,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9b/a7/e360afbb.jpg","nickname":"星辰大海","note":"","ucode":"503090B6D2BBCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2715388,"avatar":"","nickname":"Geek8535","note":"","ucode":"D1919541632C95","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574269,"discussion_content":"说反了。归并排序稳定但会使用额外空间，快速排序不太稳定，但不使用额外空间。\n所以：待排序元素数&lt; 47插入排序，(&gt;=47 &amp;&amp; &lt; 286) 使用归并排序，&gt;= 286 则使用双轴快速排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653931871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":407009,"ip_address":""},"score":574269,"extra":""}]},{"author":{"id":1451364,"avatar":"https://static001.geekbang.org/account/avatar/00/16/25/64/d66ea739.jpg","nickname":"黑洞","note":"","ucode":"840A4330B1B2F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274052,"discussion_content":"这个合并的方法好耶","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590539804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1451364,"avatar":"https://static001.geekbang.org/account/avatar/00/16/25/64/d66ea739.jpg","nickname":"黑洞","note":"","ucode":"840A4330B1B2F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":90507,"discussion_content":"这个合并算法确实观察细致，性能优化到极致。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576769859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34462,"user_name":"杨伟","can_delete":false,"product_type":"c1","uid":1239937,"ip_address":"","ucode":"D5B521A0688E02","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/81/43f4b52c.jpg","comment_is_top":false,"comment_ctime":1540179174,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1015152461030","product_id":100017301,"comment_content":"思考过程比答案重要这句话是不假，但是有答案来验证自己的思考是否准确在初学时期也很重要。<br><br>学习知识每个人的理解会不同，有的人可能这么理解有的人可能那样理解。如果没有一个标杆，有些同学就会按照自己错误的理解继续学习下去。<br><br>有了标准答案，同学就可以对照答案来反思自己的理解是否正确。也能够从别人的答案中看到更好的解答也是一种学习。<br><br>当然自己偷懒不思考，依赖标准答案，那肯定是学不好的","like_count":235,"discussions":[{"author":{"id":1802112,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYKTd1Bt8ibClEibhn3hKzia4sxavGczbRta6gWwiaCtj9ZEb087GaGdJ5zibwkt7zbxSHkN8YnSMAr4w/132","nickname":"Geek_7073e7","note":"","ucode":"192BA2FFB12205","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339416,"discussion_content":"也就是：思而不学则殆","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1609663273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2555914,"avatar":"https://static001.geekbang.org/account/avatar/00/27/00/0a/078e4347.jpg","nickname":"东","note":"","ucode":"98A57ADA38A7DF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1802112,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYKTd1Bt8ibClEibhn3hKzia4sxavGczbRta6gWwiaCtj9ZEb087GaGdJ5zibwkt7zbxSHkN8YnSMAr4w/132","nickname":"Geek_7073e7","note":"","ucode":"192BA2FFB12205","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532318,"discussion_content":"第二不学则罔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637575278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339416,"ip_address":""},"score":532318,"extra":"{\"user_type\":1}"}]},{"author":{"id":1665210,"avatar":"https://static001.geekbang.org/account/avatar/00/19/68/ba/d71be5bc.jpg","nickname":"Ari_Golovin","note":"","ucode":"CF888FA00C0DF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323292,"discussion_content":"赞同","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604912755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2260390,"avatar":"https://static001.geekbang.org/account/avatar/00/22/7d/a6/15798bf2.jpg","nickname":"温雅小公子","note":"","ucode":"9EA63E36D7C85C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574412,"discussion_content":"很多人为了避免思考可以做任何事。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654049262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34449,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1540174389,"is_pvip":true,"discussion_count":7,"race_medal":0,"score":"512641282613","product_id":100017301,"comment_content":"java1.8中的排序，在元素小于47的时候用插入排序，大于47小于286用双轴快排，大于286用timsort归并排序，并在timesort中记录数据的连续的有序段的的位置，若有序段太多，也就是说数据近乎乱序，则用双轴快排，当然快排的递归调用的过程中，若排序的子数组数据数量小，用插入排序。","like_count":120,"discussions":[{"author":{"id":2962599,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/34/a7/52c4ea60.jpg","nickname":"年少挽滑稽世无双","note":"","ucode":"793DCBDE25A07B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571157,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652090937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2798455,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/b3/77/cb9ca598.jpg","nickname":"Stockholm","note":"","ucode":"5F6501554B631E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413381,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636460657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2762634,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoBvqEtL5jPfibavnGmvicCVndB1VabyrlZjls3KdYaN4FuaViaFDVRgVoWPmczXlfTvz83WGLPyicXgw/132","nickname":"Geek_cddbfa","note":"","ucode":"09A04136394E24","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404670,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634379295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748742,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/af/06/2478c354.jpg","nickname":"王同学","note":"","ucode":"E2FE15452816D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390420,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629819869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1765791,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/f1/9f/7eb3ea4a.jpg","nickname":"宇宙美少女","note":"","ucode":"14C911ABB350FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350792,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614006595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2017580,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c9/2c/9ed40921.jpg","nickname":"BOB","note":"","ucode":"E86596709EAB1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336118,"discussion_content":"m","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608490277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2052088,"avatar":"","nickname":"dyh_zero","note":"","ucode":"98029D72597EF2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323412,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604930566,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72077,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1551515564,"is_pvip":false,"replies":[{"id":"26263","content":"👍 细心，新版本的jdk估计有优化吧，可以从代码中发现：<br>        if (LegacyMergeSort.userRequested)<br>            legacyMergeSort(a);<br><br>legacy的实现确实是堆排序！","user_name":"作者回复","comment_id":72077,"uid":"1190123","ip_address":"","utype":1,"ctime":1551664905,"user_name_real":"gg"}],"discussion_count":11,"race_medal":0,"score":"388098572204","product_id":100017301,"comment_content":"说说我觉得文章可能存在的一个问题，再借此问题，正好回答下思考题！<br>----------------------<br>文章中有一段话，如下：<br>&quot;时间复杂度是 O(nlogn) 的排序算法不止一个，我们已经讲过的有归并排序、快速排序，后面讲堆的时候我们还会讲到堆排序。堆排序和快速排序都有比较多的应用，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。&quot;<br>这里说，”Java语言采用堆排序实现排序函数“，这句话是不是错误的？<br><br>在JDK中，排序相关的主要是两个工具类：Arrays.java  和 Collections.java，具体的排序方法是sort()。这里要注意的是，Collections.java中的sort()方法是将List转为数组，然后调用Arrays.sort()方法进行排序，具体代码如下(留言中代码格式可能有点混乱，讲究看看，也可以自行参看List.sort())：<br>default void sort(Comparator&lt;? super E&gt; c) {<br>        Object[] a = this.toArray();<br>        Arrays.sort(a, (Comparator) c);<br>        ListIterator&lt;E&gt; i = this.listIterator();<br>        for (Object e : a) {<br>            i.next();<br>            i.set((E) e);<br>        }<br>    }<br><br>在Arrays类中，sort()有一系列的重载方法，罗列几个典型的Arrays.sort()方法如下:<br>public static void sort(int[] a) {<br>     DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);<br> }<br><br>public static void sort(long[] a) {<br>     DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);<br>}<br><br>public static void sort(Object[] a) {<br>        if (LegacyMergeSort.userRequested)<br>            legacyMergeSort(a);<br>        else<br>            ComparableTimSort.sort(a, 0, a.length, null, 0, 0);<br>}<br>重载方法虽然多，但是从“被排序的数组所存储的内容”这个维度可以将其分为两类：<br>1. 存储的数据类型是基本数据类型<br>2. 存储的数据类型是Object<br>第一种情况使用的是快排，在数据量很小的时候，使用的插入排序；<br>第二种情况使用的是归并排序，在数据量很小的时候，使用的也是插入排序<br> <br>以上两种场景所用到的排序都是「混合式的排序」，也都是为了追求极致的性能而设计的。另外，第二种排序有个专业的名称，叫：TimSort(可以自行Wikipedia)<br><br>","like_count":90,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441450,"discussion_content":"👍 细心，新版本的jdk估计有优化吧，可以从代码中发现：\n        if (LegacyMergeSort.userRequested)\n            legacyMergeSort(a);\n\nlegacy的实现确实是堆排序！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1551664905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192932,"avatar":"https://static001.geekbang.org/account/avatar/00/12/33/e4/0d85d2bc.jpg","nickname":"Allany","note":"","ucode":"2181E93F708DC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44657,"discussion_content":"优秀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572960547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2873959,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/da/67/e18b690e.jpg","nickname":"神经蛙","note":"","ucode":"E0CE74B2363E10","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543121,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640952877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2849207,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/p7WrTfywicxkRZTdlSEvzTsrWssRF0YnmGY2ffFYGKjIoNC8fnbMiaI9Kic0gOD3icLiapY5vmYh89yLUH7qgZZicn3g/132","nickname":"Geek_8b8904","note":"","ucode":"3A7967582FFE8D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":533857,"discussion_content":"应该是表述不严谨吧，作者也说了这种通用的排序一般都是混合型的，针对不同场景有区分，不太可能只用一种方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637995124,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2798455,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/b3/77/cb9ca598.jpg","nickname":"Stockholm","note":"","ucode":"5F6501554B631E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413391,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636462068,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1067720,"avatar":"https://static001.geekbang.org/account/avatar/00/10/4a/c8/7679cd2a.jpg","nickname":"冬青树","note":"","ucode":"3DC219F6EE3046","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412571,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636210320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1992973,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/69/0d/0a2fd71e.jpg","nickname":"刘博","note":"","ucode":"F00AA3B3200BBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399207,"discussion_content":"你专业的让我害怕，宝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632921648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074734,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/2e/527b73c9.jpg","nickname":"骑着🚀看银河","note":"","ucode":"8706A99A89F0CE","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379572,"discussion_content":"只能说老师有点偷懒了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623986995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1903708,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0c/5c/b03b2cc1.jpg","nickname":"Geek_db6a4b","note":"","ucode":"E5992D1CF088C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303875,"discussion_content":"针对int数组的重载函数为插入排序+双轴快排+TimSort实现，针对Object数组的重载函数的实现是堆排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599399059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2036705,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/13/e1/6939ae4f.jpg","nickname":"knight劉先生","note":"","ucode":"CEE9BFC8D3D969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290752,"discussion_content":"优秀，是timsort","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594599655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020861,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/bd/f3977ebb.jpg","nickname":"John","note":"","ucode":"E4ADF8488953FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266284,"discussion_content":"插一句补充Jerry兄, &#34;Collections.java中的sort()方法是将List转为数组&#34; 中间还有一步是Collections.sort把这个活交还给了List.sort, 于是List又把这个活交给了Arrays的sort.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589500834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34436,"user_name":"小确幸","can_delete":false,"product_type":"c1","uid":1099329,"ip_address":"","ucode":"C090505CB2DB69","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/41/b868f086.jpg","comment_is_top":false,"comment_ctime":1540171678,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"323662718878","product_id":100017301,"comment_content":"数据库里面的Order BY，用的是什么排序呢？","like_count":75,"discussions":[{"author":{"id":1272047,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","nickname":"Magic","note":"","ucode":"FD9CEDAA419EB0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":16524,"discussion_content":"如果有limit限制，则是堆排序。如果数据无法全部读入内存，则是归并排序，否则是快排","likes_number":33,"is_delete":false,"is_hidden":false,"ctime":1568898223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1591003,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoDQubRAAlUiceS9cJ1lkkaVItmejPc396ficHgnePUJibHCRibXqtok9CQfvpsjMFhRxVJ510SnYW8nQ/132","nickname":"Geek_10d122","note":"","ucode":"810C8873A20669","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8924,"discussion_content":"有索引的话是b+树的排序","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1568102079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050411,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/2b/d111e75d.jpg","nickname":"Lion","note":"","ucode":"21AA6AE4A90789","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391122,"discussion_content":"没有索引，内存内 是快排序，内存不够，会到临时文件排序 ，用的归并","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1630306209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1992973,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/69/0d/0a2fd71e.jpg","nickname":"刘博","note":"","ucode":"F00AA3B3200BBE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1050411,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/2b/d111e75d.jpg","nickname":"Lion","note":"","ucode":"21AA6AE4A90789","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399212,"discussion_content":"所以说当排序字段数据相同的值比较多的时候，order by 分页的时候会出现数据丢失的情况，不稳定排序","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632921899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":391122,"ip_address":""},"score":399212,"extra":""}]},{"author":{"id":1081205,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7f/75/551c5d6c.jpg","nickname":"CrazyCodes","note":"","ucode":"C9C0E72522EB5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368777,"discussion_content":"如果命中索引用b+ b+默认有序，无需排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618829267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1625589,"avatar":"https://static001.geekbang.org/account/avatar/00/18/cd/f5/49e65d7a.jpg","nickname":"小鲨鱼。","note":"","ucode":"E0607C8C0F13B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64359,"discussion_content":"数据量小一次快排，数据量大分区快排，后归并排序？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574946475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35756,"user_name":"李靖峰","can_delete":false,"product_type":"c1","uid":1139247,"ip_address":"","ucode":"AA4DE3E91A1FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/2f/6fe8ee9e.jpg","comment_is_top":false,"comment_ctime":1540783153,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"259238820913","product_id":100017301,"comment_content":"golang标准库中的Sort用的是快排+希尔排序+插排，数据量大于12时用快排，小于等于12时用6作为gap做一次希尔排序，然后走一遍普通的插排（插排对有序度高的序列效率高）。其中快排pivot的选择做了很多工作不是一两句话可以描述出来，是基于首中尾中值的很复杂的变种","like_count":60,"discussions":[{"author":{"id":2120951,"avatar":"https://static001.geekbang.org/account/avatar/00/20/5c/f7/cffc0520.jpg","nickname":"APTX4869","note":"","ucode":"C427B3638184BB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336489,"discussion_content":"如果递归深度超过maxDepth，还会使用堆排序","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1608607258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2253623,"avatar":"https://static001.geekbang.org/account/avatar/00/22/63/37/187a193a.jpg","nickname":"难逃月色","note":"","ucode":"582F0DE168DB2D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351135,"discussion_content":"数据量大于12时如果递归深度为0会使用堆排序，不为0时是快排，相关代码在sort文件的196行至224行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614161507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34600,"user_name":"姜威","can_delete":false,"product_type":"c1","uid":1244051,"ip_address":"","ucode":"C58EB9A5AD634D","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/93/f19a5364.jpg","comment_is_top":false,"comment_ctime":1540215976,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"203403678888","product_id":100017301,"comment_content":"总结：如何实现一个通用的高性能的排序函数？<br>一、如何选择合适的排序算法？<br>1.排序算法一览表<br>                 时间复杂度 是稳定排序？ 是原地排序？<br>冒泡排序     O(n^2)           是                是<br>插入排序     O(n^2)           是                是<br>选择排序     O(n^2)           否                是<br>快速排序     O(nlogn)        否                是 <br>归并排序     O(nlogn)        是                否<br>桶排序        O(n)              是                 否<br>计数排序 O(n+k)，k是数据范围 是           否<br>基数排序 O(dn)，d是纬度 是                  否<br>2.为什选择快速排序？<br>1）线性排序时间复杂度很低但使用场景特殊，如果要写一个通用排序函数，不能选择线性排序。<br>2）为了兼顾任意规模数据的排序，一般会首选时间复杂度为O(nlogn)的排序算法来实现排序函数。<br>3）同为O(nlogn)的快排和归并排序相比，归并排序不是原地排序算法，所以最优的选择是快排。<br>二、如何优化快速排序？<br>导致快排时间复杂度降为O(n)的原因是分区点选择不合理，最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。如何优化分区点的选择？有2种常用方法，如下：<br>1.三数取中法<br>①从区间的首、中、尾分别取一个数，然后比较大小，取中间值作为分区点。<br>②如果要排序的数组比较大，那“三数取中”可能就不够用了，可能要“5数取中”或者“10数取中”。<br>2.随机法：每次从要排序的区间中，随机选择一个元素作为分区点。<br>3.警惕快排的递归发生堆栈溢出，有2中解决方法，如下：<br>①限制递归深度，一旦递归超过了设置的阈值就停止递归。<br>②在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈过程，这样就没有系统栈大小的限制。<br>三、通用排序函数实现技巧<br>1.数据量不大时，可以采取用时间换空间的思路<br>2.数据量大时，优化快排分区点的选择<br>3.防止堆栈溢出，可以选择在堆上手动模拟调用栈解决<br>4.在排序区间中，当元素个数小于某个常数是，可以考虑使用O(n^2)级别的插入排序<br>5.用哨兵简化代码，每次排序都减少一次判断，尽可能把性能优化到极致<br>四、思考<br>1.Java中的排序函数都是用什么排序算法实现的？有有哪些技巧？","like_count":47,"discussions":[{"author":{"id":1483323,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a2/3b/851ec7df.jpg","nickname":"s.","note":"","ucode":"24047FA876252D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154101,"discussion_content":"你是课代表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580116256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220919,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/CJYUnMtcdu7GdMGxzVicTYpfsbhTKzrCIpoLIJxn8ByWsq1ol35RZLe1u4eWJpFhGK7ISpee2slWYokn0vBicw7A/132","nickname":"Woosang","note":"","ucode":"BB63C9F1BBDF61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53418,"discussion_content":"数据量不大时为什么不是空间换时间呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574166965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1220919,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/CJYUnMtcdu7GdMGxzVicTYpfsbhTKzrCIpoLIJxn8ByWsq1ol35RZLe1u4eWJpFhGK7ISpee2slWYokn0vBicw7A/132","nickname":"Woosang","note":"","ucode":"BB63C9F1BBDF61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69451,"discussion_content":"他写反了。。。\n数据量不大的时候，意味着 空间复杂度为O(n)、时间复杂度为O(nlogn)的归并排序 可以被接受（相对于 性能可能劣化的快排）\n就是 空间  换 时间了（空间复杂度 稍微上涨，但是 时间不会劣化）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575288454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53418,"ip_address":""},"score":69451,"extra":""},{"author":{"id":1754897,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c7/11/ed02ee23.jpg","nickname":"小安a~🐯","note":"","ucode":"46861B89E281C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78923,"discussion_content":"没写反，大数据是空间换时间，小数据是时间换空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576032856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":69451,"ip_address":""},"score":78923,"extra":""},{"author":{"id":1798068,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/6f/b4/d465acef.jpg","nickname":"啊噗！","note":"","ucode":"C911E772E1E800","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1754897,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/c7/11/ed02ee23.jpg","nickname":"小安a~🐯","note":"","ucode":"46861B89E281C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":155962,"discussion_content":"？小数据才是空间换时间啊 大数据量还怎么用空间换啊...","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1580306834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78923,"ip_address":""},"score":155962,"extra":""}]},{"author":{"id":1459470,"avatar":"https://static001.geekbang.org/account/avatar/00/16/45/0e/1f5b1280.jpg","nickname":"Adward","note":"","ucode":"E7B3714D9E3E5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2251,"discussion_content":"&#34;导致快排时间复杂度降为O(n)的原因是分区点选择不合理&#34;，应该是降为o(n2)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563413714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34439,"user_name":"Andrew 陈震","can_delete":false,"product_type":"c1","uid":1249848,"ip_address":"","ucode":"0C524D35F8A862","user_header":"https://static001.geekbang.org/account/avatar/00/13/12/38/1333a556.jpg","comment_is_top":false,"comment_ctime":1540171839,"is_pvip":false,"replies":[{"id":"12344","content":"太深报错也没问题 不过不建议这么处理<br>归并排序比较稳定 栈的深度是logn 非常小 所以不会堆栈溢出<br>关于手动模拟栈 你可以看看qsort（）函数的实现","user_name":"作者回复","comment_id":34439,"uid":"1190123","ip_address":"","utype":1,"ctime":1540259001,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"199108667455","product_id":100017301,"comment_content":"老师，我有一个问题，关于递归太深导致堆栈溢出的问题。对于这个问题，您说一般有两种解决方法，一是设置最深的层数，如果超过层数了，就报错。对于这样的问题，我想排序一个数列，超过了层数，难道就不排了么？我看有留言说，stl中的sort默认是使用快排的，但当递归深度过大时 会转为使用归并排序。但是归并排序也是递归排序啊，如果两种排序都达到了最深层数怎么处理？另外，在排序之前，能否估算出排序是否超过最深层数呢？如果估算不出，那岂不是要先排一遍，发现超过层数，再换用别的。我的想法是设个阈值，不超过阈值，用一种，超过了，用另一种。<br><br>第二种应对堆栈溢出的方法是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程。这个方法在您的几篇教程里都提到过，但是不详细，您能否稍微详细讲解一下。<br><br>谢谢老师","like_count":46,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427209,"discussion_content":"太深报错也没问题 不过不建议这么处理\n归并排序比较稳定 栈的深度是logn 非常小 所以不会堆栈溢出\n关于手动模拟栈 你可以看看qsort（）函数的实现","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1540259001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1462911,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKf9xWMCV4ic5dsKyroQpGkYGZ32IPicVPVsF1TPENeTcspd6HhhaciaHCCmzeicaiaItZS3DahASFovJQ/132","nickname":"bai","note":"","ucode":"C9673B7F2C896E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304458,"discussion_content":"也不用报错吧，剩下的使用插入排序也可以吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599575292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39636,"discussion_content":"非常好的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571971121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36476,"user_name":"蛐鸣","can_delete":false,"product_type":"c1","uid":1253969,"ip_address":"","ucode":"797DB029A46E40","user_header":"https://static001.geekbang.org/account/avatar/00/13/22/51/cb285f5a.jpg","comment_is_top":false,"comment_ctime":1541123221,"is_pvip":false,"replies":[{"id":"12948","content":"👍","user_name":"作者回复","comment_id":36476,"uid":"1190123","ip_address":"","utype":1,"ctime":1541123511,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"156159945877","product_id":100017301,"comment_content":"看了一下，.NET里面的Array排序实现:<br>1. 三个以内的，直接比较，交换进行实现<br>2.大于3个小于16个的，用的是插入排序进行的实现<br>3.对于大于16，并且深度限制是0的，用的是堆排序实现的<br>4.对于大于15，并且深度限制不是0的，使用的是快速排序；然后快速排序分区使用的也是三数取中法","like_count":36,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427883,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541123511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1699582,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ee/fe/248b86a7.jpg","nickname":"八一","note":"","ucode":"FA1BB919F9FE6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":112734,"discussion_content":"我也是学C#，也看了源码，对于不同的版本排序方案不一样，在C#5.0以后使用的是内省排序。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577881431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36056,"user_name":"Random.nextName()","can_delete":false,"product_type":"c1","uid":1244960,"ip_address":"","ucode":"8D18D91B8D3BC7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0lHhbutibIdWRv0pm2EPtvxqcVz0PblEic7GDxHK8JUSkyuWQl1B1NVQTzEowQIxfOf3saRBOTtog/132","comment_is_top":false,"comment_ctime":1540906908,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"134684893084","product_id":100017301,"comment_content":"Google v8中对QuickSort的实现是:<br>数据规模在10以内的话使用快排;<br>数据规模在10到1000之间时选择中点作为pivot进行快排;<br>数据规模在1000以上时，每隔200到215个数选一个数，将选出来的数排序，选择中间值作为pivot进行快排；<br>而且还有几个细节：<br>1是折半的时候用的是位运算；<br>2是每一次遍历都会分成小于pivot，等于pivot，大于pivot的三个区间；<br>3是小于pivot和大于pivot这两个区间中数据规模比较小的会递归执行QuickSort，数据规模大的会先通过while循环减小数据规模。<br>附上源码链接: https:&#47;&#47;github.com&#47;v8&#47;v8&#47;blob&#47;master&#47;src&#47;js&#47;array.js","like_count":31,"discussions":[{"author":{"id":1959211,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e5/2b/59bde898.jpg","nickname":"Jack.Huang","note":"","ucode":"FD089E25D93A26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291702,"discussion_content":"数据规模在10以内的话应该是使用插入排序","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1594911674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1321770,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2b/2a/63af9b35.jpg","nickname":"贾飞雨","note":"","ucode":"CBD8FD331B4173","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413404,"discussion_content":"https://github.com/v8/v8/blob/901b67916dc2626158f42af5b5c520ede8752da2/src/array.js 新的地址","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1636466526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35769,"user_name":"leo","can_delete":false,"product_type":"c1","uid":1107385,"ip_address":"","ucode":"0A3D3508398328","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhicDSmL4vicPF4mF9g5icORERwDSqZv5Guk0TyhiacuBsiaVxCdktI6oCrKzcycwFlpyL6Q1nDbvJZzA/132","comment_is_top":false,"comment_ctime":1540785841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"78850197169","product_id":100017301,"comment_content":"排序的思维导图链接：https:&#47;&#47;share.weiyun.com&#47;5X17MG3","like_count":18},{"had_liked":false,"id":79072,"user_name":"24隋心所欲","can_delete":false,"product_type":"c1","uid":1342000,"ip_address":"","ucode":"1B8B2789F68C94","user_header":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","comment_is_top":false,"comment_ctime":1553343593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"74567787625","product_id":100017301,"comment_content":"针对 Java 语言：<br><br>1. 对于基本类型的数组，Java 采用的是双枢轴快速排序（Dual-Pivot Quicksort），这个算法是 Java 7 引入的。在此之前，Java 采用的是普通的快速排序，双枢轴快速排序是对普通快速排序的优化，新算法的实现代码位于类 java.util.DualPivotQuicksort 中。<br><br>2. 对于对象类型，Java 采用的算法是 TimSort，TimSort 算法也是 Java 7 引入的。在此之前，Java 采用的是归并排序。TimSort 算法实际上是对归并排序的一系列优化，TimSort 的实现代码位于类 java.util.TimSort 中。<br><br>3. 在这些排序算法中，如果数组长度比较小，它们还会采用效率更高的插入排序。","like_count":18},{"had_liked":false,"id":34471,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1241346,"ip_address":"","ucode":"B8E39F3E61A36E","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/02/862b6faa.jpg","comment_is_top":false,"comment_ctime":1540182423,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"70259659159","product_id":100017301,"comment_content":"关于快排递归过深的处理的疑惑，以及关于 STL 里的 std::sort 是怎么实现的，可以看我这篇博客：https:&#47;&#47;liam.page&#47;2018&#47;09&#47;18&#47;std-sort-in-STL&#47;","like_count":16,"discussions":[{"author":{"id":2640403,"avatar":"https://static001.geekbang.org/account/avatar/00/28/4a/13/8ce308f0.jpg","nickname":"深蹲局特工","note":"","ucode":"D43D4BA2E43061","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377115,"discussion_content":"老哥写的真棒！想问句题外话，这种属于自己网页的博客要怎么建立呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622512643,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34419,"user_name":"城","can_delete":false,"product_type":"c1","uid":1035315,"ip_address":"","ucode":"32C4FCE1944000","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cc/33/19f150d9.jpg","comment_is_top":false,"comment_ctime":1540168664,"is_pvip":false,"replies":[{"id":"12263","content":"是的","user_name":"作者回复","comment_id":34419,"uid":"1190123","ip_address":"","utype":1,"ctime":1540173200,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"70259645400","product_id":100017301,"comment_content":"qsort中为避免递归调用过深，所以在堆上模拟了栈。不知道是否是将递归调用，改写为循环非递归方式呢？","like_count":17,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427204,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540173200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1926508,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/65/6c/be97a3ae.jpg","nickname":"Geek_bb2310","note":"","ucode":"022885B257DEB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":264923,"discussion_content":"yep","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589358731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34441,"user_name":"雨天","can_delete":false,"product_type":"c1","uid":1056406,"ip_address":"","ucode":"FD9FB404ECA463","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/96/3162d51f.jpg","comment_is_top":false,"comment_ctime":1540172174,"is_pvip":false,"replies":[{"id":"12270","content":"并没解决 所以qsort不稳定","user_name":"作者回复","comment_id":34441,"uid":"1190123","ip_address":"","utype":1,"ctime":1540174227,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"57374747022","product_id":100017301,"comment_content":"使用快排如何解决不稳定排序的问题?","like_count":13,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427210,"discussion_content":"并没解决 所以qsort不稳定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540174227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36794,"user_name":"favorlm","can_delete":false,"product_type":"c1","uid":1120997,"ip_address":"","ucode":"CFD52127AA6E1D","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","comment_is_top":false,"comment_ctime":1541334556,"is_pvip":false,"replies":[{"id":"13079","content":"留言区点赞最高的就是答案","user_name":"作者回复","comment_id":36794,"uid":"1190123","ip_address":"","utype":1,"ctime":1541381789,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"44491007516","product_id":100017301,"comment_content":"虽然说思考很重要，但是面试还是需要你实现一种算法。","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428021,"discussion_content":"留言区点赞最高的就是答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541381789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":46420,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1543919804,"is_pvip":false,"replies":[{"id":"16669","content":"👍","user_name":"作者回复","comment_id":46420,"uid":"1190123","ip_address":"","utype":1,"ctime":1543974210,"user_name_real":"gg"}],"discussion_count":4,"race_medal":0,"score":"40198625468","product_id":100017301,"comment_content":"老师，你好，我终于认真消化完了前面的知识，没有半点马虎，也给自己打个卡记录。<br>关于思考题：<br>查看了Java的Arrays.sort<br>1.若数组元素个数总数小于47，使用插入排序<br>2.若数据元素个数总数在47~286之间，使用快速排序。应该是使用的优化版本的三值取中的优化版本。<br>3.若大于286的个数，使用归并排序。<br>底层实现的代码比之前示范写的代码校验多，所以目前只能看到这，下面继续加油吧！","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431456,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543974210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1357311,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","nickname":"L","note":"","ucode":"5B847B2378854E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308631,"discussion_content":"小于47，用插入；47~286，用快排；大于286，趋近有序 用归并，无序 用快排。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601013597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6384,"discussion_content":"47~286之间，使用快速排序;大于286的个数，使用归并排序? 个数大而采用归并排序，岂不是更浪费空间，应该是47-286使用归并排序，大于286使用的是快速排序的吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1566875264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1453182,"avatar":"https://static001.geekbang.org/account/avatar/00/16/2c/7e/f1efd18b.jpg","nickname":"摊牌","note":"","ucode":"F142596BFE4594","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559455,"discussion_content":"47和286具体产生的临界点影响是什么？为什么导致变换排序算法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648780840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37049,"user_name":"学习爱好者","can_delete":false,"product_type":"c1","uid":1236851,"ip_address":"","ucode":"F00A42CAB9912D","user_header":"","comment_is_top":false,"comment_ctime":1541432339,"is_pvip":false,"replies":[{"id":"13246","content":"嗯嗯 用归并或者插入排序就稳定了","user_name":"作者回复","comment_id":37049,"uid":"1190123","ip_address":"","utype":1,"ctime":1541467842,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"40196138003","product_id":100017301,"comment_content":"王老师，总结8种排序算法的那个图，桶排序不一定是稳定排序吧？比如桶内排序用快排的时候","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428142,"discussion_content":"嗯嗯 用归并或者插入排序就稳定了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541467842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118217,"user_name":"helloworld2018","can_delete":false,"product_type":"c1","uid":1210386,"ip_address":"","ucode":"2AE40C0DF5A9F7","user_header":"https://static001.geekbang.org/account/avatar/00/12/78/12/7df38a54.jpg","comment_is_top":false,"comment_ctime":1564294894,"is_pvip":false,"replies":[{"id":"43659","content":"不是所有的应用场景都关注稳定性呀","user_name":"作者回复","comment_id":118217,"uid":"1190123","ip_address":"","utype":1,"ctime":1564526773,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"35924033262","product_id":100017301,"comment_content":"老师好，请教个问题，快排不是稳定算法，为啥还要用快排","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460307,"discussion_content":"不是所有的应用场景都关注稳定性呀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564526773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246481,"user_name":"执迷不悟","can_delete":false,"product_type":"c1","uid":2164461,"ip_address":"","ucode":"F7C62AB70938CE","user_header":"https://static001.geekbang.org/account/avatar/00/21/06/ed/68bbb38d.jpg","comment_is_top":false,"comment_ctime":1599370712,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31664141784","product_id":100017301,"comment_content":"上完这节课，我感觉我整个人得到了升华。","like_count":7,"discussions":[{"author":{"id":1453182,"avatar":"https://static001.geekbang.org/account/avatar/00/16/2c/7e/f1efd18b.jpg","nickname":"摊牌","note":"","ucode":"F142596BFE4594","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559454,"discussion_content":"开始迷恋了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648780397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":36503,"user_name":"豆豆","can_delete":false,"product_type":"c1","uid":1187545,"ip_address":"","ucode":"F38848C82F7520","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/d9/cb12e020.jpg","comment_is_top":false,"comment_ctime":1541132191,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"31605903263","product_id":100017301,"comment_content":"老师好，桶排序每个桶里面采取快排，但是快排不是稳定排序啊，为什么桶排序就变成稳定排序了呢？","like_count":7,"discussions":[{"author":{"id":2443427,"avatar":"https://static001.geekbang.org/account/avatar/00/25/48/a3/2df11999.jpg","nickname":"Boom clap!!!","note":"","ucode":"E9AF8ECB963239","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":361811,"discussion_content":"采用了快排就不是稳定的啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616761705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34788,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1540300438,"is_pvip":false,"replies":[{"id":"12507","content":"是有点 毕竟代码是写给机器执行的 多看几遍 再自己默写默写","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540394898,"ip_address":"","comment_id":34788,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31605071510","product_id":100017301,"comment_content":"老师，你之前讲的快排、归并，原理我都理解的很清晰，但是一旦到转换成代码的时候，感觉一脸懵逼，你最开始这是这样吗？","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427338,"discussion_content":"是有点 毕竟代码是写给机器执行的 多看几遍 再自己默写默写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540394898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49676,"user_name":"公号-彤哥读源码","can_delete":false,"product_type":"c1","uid":1239881,"ip_address":"","ucode":"C0D16E1BA12DA0","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/49/bd914b5f.jpg","comment_is_top":false,"comment_ctime":1544751621,"is_pvip":false,"replies":[{"id":"17894","content":"是的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1544754125,"ip_address":"","comment_id":49676,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27314555397","product_id":100017301,"comment_content":"归并排序空间复杂度应该没那么高，因为实际存储的都是指针或者引用。","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432715,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1544754125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38280,"user_name":"懒猫","can_delete":false,"product_type":"c1","uid":1206544,"ip_address":"","ucode":"B4B567A11B491D","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/10/275ae749.jpg","comment_is_top":false,"comment_ctime":1542014973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27311818749","product_id":100017301,"comment_content":"简单说下go语言的，大致是两个限制条件：数据长度和递归深度，如果长度大于或等于12，且递归深度大于0时，使用快排，快排在选择分区点数字时用了三数取中法，如果长度大于12且递归深度限制为0时，使用堆排序，如果数据长度小于或等于12时，用的希尔排序，间隔用是6","like_count":6},{"had_liked":false,"id":159201,"user_name":"阿冰777","can_delete":false,"product_type":"c1","uid":1373893,"ip_address":"","ucode":"F365EB44F971F3","user_header":"https://static001.geekbang.org/account/avatar/00/14/f6/c5/6329ddcc.jpg","comment_is_top":false,"comment_ctime":1575557647,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"14460459535","product_id":100017301,"comment_content":"Day11: Javascript里，当数组长度小于等于22 的时候，使用插入排序，当数组长度小于等于1000的时候，使用快速排序，并且分区点为中点，当数组长度大于1000时，分区点为三位数取中间值,中间值的取法是每200~215个数据取一个数值，最后获得一个数组，再讲这个数组排序，取中位数（是的，为了取得分区点还要先进行一次排序。。。）","like_count":3,"discussions":[{"author":{"id":1156074,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","nickname":"HoSalt","note":"","ucode":"610B03E2A002D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250453,"discussion_content":"请问是在那里看到相关信息的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588002460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":83246,"user_name":"盘尼西林","can_delete":false,"product_type":"c1","uid":1197347,"ip_address":"","ucode":"B59569FC25144F","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/23/28311447.jpg","comment_is_top":false,"comment_ctime":1554478840,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14439380728","product_id":100017301,"comment_content":"go 中的sort <br>    1. if hi - lo &gt; 12<br>         defind maxDepth = 2*lgn<br>         use quickSort(lo,hi,maxDepth) {<br>            if maxDepth == 0 then use heapSort(lo,hi) and return<br>            maxDepth -- <br>            ml, mh := partition() {<br>                pivot = getPivotBy4Couple()<br>                return ml, mh &#47;&#47; ml,mh 是重复pivot的起始结束边界<br>            }<br>            use quickSort(lo,mi)<br>            use quickSort(mh,hi)<br>         }<br>    2. if hi - lo between 1 and 12<br>        use gap = 6 shell sort<br>        use insertSort again","like_count":3},{"had_liked":false,"id":239129,"user_name":"酸辣土豆丝","can_delete":false,"product_type":"c1","uid":1751234,"ip_address":"","ucode":"0E3E4AFB31E1E6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/c2/d1904d74.jpg","comment_is_top":false,"comment_ctime":1596442625,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10186377217","product_id":100017301,"comment_content":"Python的sort函数使用了Tim sort方法，小的用插入排序，大的数据用归并排序","like_count":2},{"had_liked":false,"id":106621,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561357719,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151292311","product_id":100017301,"comment_content":"快速排序算法的优化：<br><br>1. 三数取中（找更好的分区点）<br>2. 随机法（找更好的分区点）<br>3. 手动模拟栈（防止递归引起的堆栈溢出）<br><br>qsort():归并+快排（三数取中法+手动模拟栈）+插入（哨兵）<br><br>关于标准答案的思考：<br>我们长久以来过于依赖标准答案，哪怕是思考之后也希望能有所谓的“必然正确的”标准答案以供检验。现在互联网如此发达，我们应当能完善自检机制。能提出问题，也能解决问题，还能判断答案的优劣。希望标准答案能变成多观点多角度的讨论。","like_count":2},{"had_liked":false,"id":97081,"user_name":"Aaaaaaaaaaayou","can_delete":false,"product_type":"c1","uid":1073601,"ip_address":"","ucode":"67BA315B87587D","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/c1/93031a2a.jpg","comment_is_top":false,"comment_ctime":1558582122,"is_pvip":false,"replies":[{"id":"34701","content":"词典中有“宠信”这个词哦","user_name":"编辑回复","user_name_real":"王锦","uid":"1058895","ctime":1558583110,"ip_address":"","comment_id":97081,"utype":2}],"discussion_count":1,"race_medal":0,"score":"10148516714","product_id":100017301,"comment_content":"宠信 =&gt;  宠幸","like_count":2,"discussions":[{"author":{"id":1058895,"avatar":"https://static001.geekbang.org/account/avatar/00/10/28/4f/48e48553.jpg","nickname":"@阿锦啊","note":"","ucode":"3C5F00333D7174","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":451131,"discussion_content":"词典中有“宠信”这个词哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558583110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34429,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1241346,"ip_address":"","ucode":"B8E39F3E61A36E","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/02/862b6faa.jpg","comment_is_top":false,"comment_ctime":1540170828,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10130105420","product_id":100017301,"comment_content":"前面那个说 std::sort 会用归并的你站住。SGISTL 的 std::sort 在数据规模小的时候用改进的插排，在数据规模大的时候用用改进的快排，在陷入恶化之后用堆排，在几乎排好序之后用改进的插排。请告诉我哪里用了归并了……","like_count":2},{"had_liked":false,"id":34396,"user_name":"八百","can_delete":false,"product_type":"c1","uid":1253530,"ip_address":"","ucode":"79F1F79ADF5A00","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/9a/3b1c65fd.jpg","comment_is_top":false,"comment_ctime":1540144118,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10130078710","product_id":100017301,"comment_content":"打卡","like_count":2},{"had_liked":false,"id":277976,"user_name":"药师","can_delete":false,"product_type":"c1","uid":1213258,"ip_address":"","ucode":"14BB054A38A2F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/4a/3e08427e.jpg","comment_is_top":false,"comment_ctime":1612688723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907656019","product_id":100017301,"comment_content":"我一直很好奇为什么java新版本排序要用timsort，而timport大概是对归并排序的一个优化，难道他不怕空间复杂度高么？<br>可能原因是这样的：<br>1、首先当排序数量大于286且连续性好的时候才会采用Timsort，连续性不好还会使用双轴快排<br>2、如果连续性好的情况下用别管怎么选择分区点，快排时间复杂度都可能退化O(n²)<br>3、Timsort就是针对这种连续性好的情况针对归并排序的优化，优化的方向如下：<br>    1、Timsort是稳定的算法，当前排序的数组中已经有排序好的数，它的时间复杂度会小于O(nlogn)<br>    2、最坏情况下Timsort算法需要的临时空间是n&#47;2，在最好情况下，它只需要一个很小的临时存储空间<br>感慨一下，jdk对排序的优化深入骨髓了，对极端情况的考虑如此充分，大概这样才能称得上是工业级别的排序吧","like_count":1},{"had_liked":false,"id":266162,"user_name":"万历十五年","can_delete":false,"product_type":"c1","uid":1122150,"ip_address":"","ucode":"3D8CF5DF847AE8","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/66/59e0647a.jpg","comment_is_top":false,"comment_ctime":1607223576,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5902190872","product_id":100017301,"comment_content":"对于排序算法：时间，空间和稳定性构成了不可能三角形。<br>插入排序，获得了空间和稳定，但失去了时间，<br>快排，获得了时间和空间，但失去了稳定，<br>归并，获得了时间和稳定，但失去了空间。<br>在实际使用中，要针对业务数据特点来做取舍。","like_count":2},{"had_liked":false,"id":241663,"user_name":"奥佛铎","can_delete":false,"product_type":"c1","uid":1234919,"ip_address":"","ucode":"A1D544E5F22B7F","user_header":"","comment_is_top":false,"comment_ctime":1597385965,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892353261","product_id":100017301,"comment_content":"c++ STL sort():<br>只能使用RandomAcessIterator，数据量小使用插入排序，递归过深使用堆排序，其他情况才使用快排","like_count":1},{"had_liked":false,"id":229108,"user_name":"狮锅艺","can_delete":false,"product_type":"c1","uid":1187577,"ip_address":"","ucode":"1B4AD130F9D0CA","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/f9/bfb54326.jpg","comment_is_top":false,"comment_ctime":1592898110,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887865406","product_id":100017301,"comment_content":"golang sort包中的Sort函数，也是在数据量不同的情况下使用不同的排序算法，源码如下：<br><br>func quickSort(data Interface, a, b, maxDepth int) {<br>\tfor b-a &gt; 12 { &#47;&#47; Use ShellSort for slices &lt;= 12 elements<br>\t\tif maxDepth == 0 {<br>\t\t\theapSort(data, a, b)<br>\t\t\treturn<br>\t\t}<br>\t\tmaxDepth--<br>\t\tmlo, mhi := doPivot(data, a, b)<br>\t\t&#47;&#47; Avoiding recursion on the larger subproblem guarantees<br>\t\t&#47;&#47; a stack depth of at most lg(b-a).<br>\t\tif mlo-a &lt; b-mhi {<br>\t\t\tquickSort(data, a, mlo, maxDepth)<br>\t\t\ta = mhi &#47;&#47; i.e., quickSort(data, mhi, b)<br>\t\t} else {<br>\t\t\tquickSort(data, mhi, b, maxDepth)<br>\t\t\tb = mlo &#47;&#47; i.e., quickSort(data, a, mlo)<br>\t\t}<br>\t}<br>\tif b-a &gt; 1 {<br>\t\t&#47;&#47; Do ShellSort pass with gap 6<br>\t\t&#47;&#47; It could be written in this simplified form cause b-a &lt;= 12<br>\t\tfor i := a + 6; i &lt; b; i++ {<br>\t\t\tif data.Less(i, i-6) {<br>\t\t\t\tdata.Swap(i, i-6)<br>\t\t\t}<br>\t\t}<br>\t\tinsertionSort(data, a, b)<br>\t}<br>}","like_count":1},{"had_liked":false,"id":228255,"user_name":"Mr.Li","can_delete":false,"product_type":"c1","uid":1196401,"ip_address":"","ucode":"6BBFE118103125","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/71/b8c99cf5.jpg","comment_is_top":false,"comment_ctime":1592624695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887591991","product_id":100017301,"comment_content":"我这边有个疑问，我们学了这些排序算法的原理后。实际开发中排序要重写吗？还是说直接用高级语言封装的方法。","like_count":1},{"had_liked":false,"id":217579,"user_name":"3.141516","can_delete":false,"product_type":"c1","uid":1013309,"ip_address":"","ucode":"34AF71B02692F3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/3d/8120438b.jpg","comment_is_top":false,"comment_ctime":1589536897,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5884504193","product_id":100017301,"comment_content":"Java 中的排序算法 Arrays.sort ，综合了插入排序、堆排序、归并排序、快排。","like_count":1},{"had_liked":false,"id":214280,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1588693522,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5883660818","product_id":100017301,"comment_content":"学习笔记：<br>1. 工业级的排序算法，一般优先选用O(nlogn)算法作为原型，包括：快速排序、堆排序、归并排序<br>2. 在优化过程中，对于不同的数据才用不同的排序算法。<br>    c中，小规模数据用归并排序，大规模用快速排序，快速排序还使用了自己模拟堆，防止堆栈溢出。4个数据以下时，利用了插入排序，而且用到了哨兵来减少一个判断操作，性能做到了极致<br>3. c++中的sort分析:简直就是艺术品<br>https:&#47;&#47;www.cnblogs.com&#47;ygh1229&#47;articles&#47;9806398.html<br>  一、主体，快速排序<br><br>         1. 递归代码优化：循环递归(解释参考原文链接)、递归深度阈值(解释参考二)<br>         2. 分割函数优化：三点值法<br><br>二、堆排序-递归深度阈值<br>      通常我们认为，递归过深导致算法性能下降，主要影响是堆栈的问题。但其实递归过深，在快速排序中代表的是pivot选择不好，所以才会不断深入。所以递归过深代表了快速排序恶化O(n2)倾向。此时换用堆排序，因为堆排序无论何时都是nlogn的复杂度。<br>三、插入排序:该部分相当妙<br><br>   1. 第二阈值：快速排序的循环递归中，如果递归长度&lt;16，则选择用插入排序。此时这16个值已经相对有序，插入排序能够达到O(n)的时间复杂度，相当恐怖。<br><br>   2.  极限优化--哨兵思想：哨兵思想用的太妙了(我都没想到怎么用哨兵)。<br><br>      ​       插入排序遍历整个数组，将遍历值放在前面的有序数组的合适位置。找合适位置的过程是从后往前的，所以为了防止超界，每次都要判定是否超界，无形中增加了很多没用的比较操作(只有最后一次超界的判定才是有用的)。<br><br>      ​       为了防止这一情况，我们先判断第一个值是否小于val。如果是，则可以放心大胆的向前遍历，寻找正确的位置。如果不是，则第一个位置就是我们要的位置，所有数据向后移位，将val放在第一个就好。道理很简单。<br><br>四、代码逻辑<br><br>1. 进入快排(其实不是快排)，循环递归深度限制为数组长度的2倍。如果超出深度，换用堆排序。循环终止条件为数组长度&lt;=16；<br>2. 快排完成后的结果一般情况下是很多段&lt;=16的数组，这些数组整体是有序的。也就是说左边的数组段一定小于等于右边的数组段<br>3. 整体调用一次最终插入排序（不是三、的插排），因为此时已经很有序了，所以插入排序能达到O(n)。这里有个坑：stl源码中将&gt;16数组分成了两段，0-16，用(三、)中的插入排序，其余用不带边界检测的插入排序(plus. 与不带边界检测的寻找插入点做区分)，因为它确定，第二段的最右边一定是最小值。当然不带边界检测的插排要快的多，追求极致性能，恐怖如斯。","like_count":1,"discussions":[{"author":{"id":1981613,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","nickname":"Geek_ac7784","note":"","ucode":"62F0E5E6D6F4BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258919,"discussion_content":"递归深度阈值有误。应该是log2 (size) 向下取整","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588740475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213194,"user_name":"严丹","can_delete":false,"product_type":"c1","uid":1798204,"ip_address":"","ucode":"96FA634D06C3FD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/70/3c/a002615b.jpg","comment_is_top":false,"comment_ctime":1588326497,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5883293793","product_id":100017301,"comment_content":"通过一次qSort()将知识点串联起来了，也能明白底层类库这么实现的道理，感谢！","like_count":1},{"had_liked":false,"id":207388,"user_name":"Xiaoman","can_delete":false,"product_type":"c1","uid":1072429,"ip_address":"","ucode":"54FE261583E16E","user_header":"https://static001.geekbang.org/account/avatar/00/10/5d/2d/4c3a1aa2.jpg","comment_is_top":false,"comment_ctime":1587079647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882046943","product_id":100017301,"comment_content":"算法的选择没有绝对的标准，需要具体情况具体分析，找到最合适的算法：<br>1）对于数据量比较大数据排序尽量采用时间复杂度为O（nlogn）的原地排序同时要避免占用过多额外空间<br>2）对于小数据量的排序O（n2）的算法不一定比O（nlogn）的效率低，可以采用插入排序等<br>","like_count":1},{"had_liked":false,"id":136160,"user_name":"David","can_delete":false,"product_type":"c1","uid":1023472,"ip_address":"","ucode":"1C76747719CD3B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9d/f0/6c34b90f.jpg","comment_is_top":false,"comment_ctime":1569375178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5864342474","product_id":100017301,"comment_content":"Mark 待实践","like_count":1},{"had_liked":false,"id":134455,"user_name":"零维","can_delete":false,"product_type":"c1","uid":1235055,"ip_address":"","ucode":"D783CB1D59D1BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/6f/22e5ec55.jpg","comment_is_top":false,"comment_ctime":1568849766,"is_pvip":false,"replies":[{"id":"51694","content":"是的，自己写个栈，替代掉函数栈","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568934120,"ip_address":"","comment_id":134455,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5863817062","product_id":100017301,"comment_content":"请问，老师讲的「手动模拟调用栈」是什么意思，是指把递归代码写成非递归代码的形式吗？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467755,"discussion_content":"是的，自己写个栈，替代掉函数栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568934120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107150,"user_name":"salmonl","can_delete":false,"product_type":"c1","uid":1010160,"ip_address":"","ucode":"0F85E5AD2C52B2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/69/f0/714c2f83.jpg","comment_is_top":false,"comment_ctime":1561468296,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856435592","product_id":100017301,"comment_content":"来这里的遇到的PHPer不多啊，PHP sort记得手册明确说明使用快排","like_count":1},{"had_liked":false,"id":358454,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1664331040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664331040","product_id":100017301,"comment_content":"总结：<br>考虑数据量大小选择排序方法。对于快排，通过选择基准的方法来避免时间复杂度退化。<br>go语言使用的就是根据数据量来选择希尔排序，快排，堆排序","like_count":0},{"had_liked":false,"id":356942,"user_name":"戴峥","can_delete":false,"product_type":"c1","uid":2048952,"ip_address":"丹麦","ucode":"18F5DACA09B76B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/43/b8/8c33cd6b.jpg","comment_is_top":false,"comment_ctime":1662713965,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662713965","product_id":100017301,"comment_content":"答案不需要标准 但需要不神秘  给没思路的同学节省时间。学习不是死磕  除了思考也需要记忆和借鉴","like_count":0},{"had_liked":false,"id":352838,"user_name":"蔡洪宝","can_delete":false,"product_type":"c1","uid":3010867,"ip_address":"","ucode":"CFA04CC9A087D7","user_header":"https://static001.geekbang.org/account/avatar/00/2d/f1/33/4de9affe.jpg","comment_is_top":false,"comment_ctime":1658977773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658977773","product_id":100017301,"comment_content":"没有标准答案，只有大胆的思考","like_count":0},{"had_liked":false,"id":344630,"user_name":"Ike","can_delete":false,"product_type":"c1","uid":2957656,"ip_address":"","ucode":"5B49B7DBDCCC41","user_header":"https://static001.geekbang.org/account/avatar/00/2d/21/58/a04ee0bf.jpg","comment_is_top":false,"comment_ctime":1651678127,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651678127","product_id":100017301,"comment_content":"大家都好厉害啊，老师暂时讲的算法我都会写，但是那个qsort算法看的我稀里糊涂的，我的修为是不是不适合这个课程 QIQ","like_count":0},{"had_liked":false,"id":340363,"user_name":"摊牌","can_delete":false,"product_type":"c1","uid":1453182,"ip_address":"","ucode":"F142596BFE4594","user_header":"https://static001.geekbang.org/account/avatar/00/16/2c/7e/f1efd18b.jpg","comment_is_top":false,"comment_ctime":1648780690,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648780690","product_id":100017301,"comment_content":"当你认真学习一样东西时，如果同时感觉到学的太慢了，那你一定是分心了","like_count":0},{"had_liked":false,"id":336823,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1646384652,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646384652","product_id":100017301,"comment_content":"看完小结：<br>1. 当数据量较小时， 使用插入排序，效果更好， 因为系数更优<br>2. 快速排序可以通过三数取中，随机法来设置分区点减少复杂度的退化<br>3. 快速排序的递归嵌套过深时，可以通过手动模拟栈的方式来实现快排的入出栈<br><br>看了评论区， V8 引擎中的数组排序使用插入和快速进行混合，快排有三数取中，增加等于区，哨兵减少交换，尾递归优化等","like_count":0},{"had_liked":false,"id":327347,"user_name":"Geek_63ad86","can_delete":false,"product_type":"c1","uid":1528671,"ip_address":"","ucode":"E758532B1169D6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ib3Rzem884S7icAGXsBzGKyricapL0sfax7wL7T4n1W1ZPZ0h7XNtGd5aqLlZQgZ3bZTPBmC4xa7ia8iaR0XBKMAuIQ/132","comment_is_top":false,"comment_ctime":1640074441,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640074441","product_id":100017301,"comment_content":"桶排序基于快速排序，所以也不是稳定的吧<br>","like_count":0},{"had_liked":false,"id":320679,"user_name":"神经蛙","can_delete":false,"product_type":"c1","uid":2655916,"ip_address":"","ucode":"3A655AEF65A94C","user_header":"https://static001.geekbang.org/account/avatar/00/28/86/ac/d77f5d46.jpg","comment_is_top":false,"comment_ctime":1636448966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636448966","product_id":100017301,"comment_content":"STL的sort算法，数据量大时采用QuickSort快排算法，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort快排的递归调用带来过大的额外负荷，就改用Insertion Sort插入排序。如果递归层次过深，还会改用HeapSort堆排序。","like_count":0},{"had_liked":false,"id":319016,"user_name":"Bupt_daydayup","can_delete":false,"product_type":"c1","uid":1248375,"ip_address":"","ucode":"5E2BBE695288B5","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/77/d855bfb2.jpg","comment_is_top":false,"comment_ctime":1635510094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635510094","product_id":100017301,"comment_content":"通过qsort的例子，可以充分知道，在工业级的排序算法应用中，是需要根据数据量的情况灵活采用排序算法的。<br>1. 当数据量比较小时，比如100kb的数据，对内存空间的占用消耗微乎其微，采用归并排序这种稳定且时间效率为nlogn的比较合适。<br>2. 当数据量比较大，采用了快速排序。但是因为快排是一个依靠递归的算法，如果数据量特别大，递归层数特别多，容易造成系统堆栈溢出的问题。而且快拍的性能极度依赖于分区点两侧数据量分布是否均匀有关","like_count":0},{"had_liked":false,"id":317709,"user_name":"付伟","can_delete":false,"product_type":"c1","uid":1397649,"ip_address":"","ucode":"97DC8054E30D97","user_header":"https://static001.geekbang.org/account/avatar/00/15/53/91/5a160371.jpg","comment_is_top":false,"comment_ctime":1634898525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634898525","product_id":100017301,"comment_content":"看了一下golang 的排序，里面到了设置的最大递归深度就改用希尔排序，然后分区点也是逻辑复杂的地方","like_count":0},{"had_liked":false,"id":296431,"user_name":"溜溜球","can_delete":false,"product_type":"c1","uid":2631573,"ip_address":"","ucode":"BBA5E4405D9902","user_header":"https://static001.geekbang.org/account/avatar/00/28/27/95/095ad3c3.jpg","comment_is_top":false,"comment_ctime":1622972353,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1622972353","product_id":100017301,"comment_content":"C++ sort的排序方法(内省式排序 Introsort)：<br>1.当区间长度大于16时 ，使用快排(三数取中 减少时间复杂度退化 )，当超过递归深度时使用堆排序<br>2.当区间长度小于16时，使用插入排序","like_count":0},{"had_liked":false,"id":291025,"user_name":"Eirture","can_delete":false,"product_type":"c1","uid":1308178,"ip_address":"","ucode":"49EC3830989464","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/12/19914d72.jpg","comment_is_top":false,"comment_ctime":1619947558,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619947558","product_id":100017301,"comment_content":"golang 的 sort.Sort() 实现使用了：希尔排序，插入排序，快排，堆排序。<br>1. 当列表长度 n &gt; 12 时，如果当前递归深度大于 2*ceil(lg(n+1)) 使用“堆排序”。否则快排，分区点实用的是三数取中法。<br>2. 12 &gt;= n &gt; 1 时，以 6 为间隔做一遍希尔排序，使大致有序。再做一遍插入排序。<br><br>https:&#47;&#47;github.com&#47;golang&#47;go&#47;blob&#47;fcee6b930a01407527e3a0386af2ea7ac4e66d44&#47;src&#47;sort&#47;sort.go#L196<br><br><br><br>","like_count":0},{"had_liked":false,"id":290024,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1134539,"ip_address":"","ucode":"11C598D0723D08","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/cb/ede92cd5.jpg","comment_is_top":false,"comment_ctime":1619327526,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619327526","product_id":100017301,"comment_content":"的确需要去看看源码","like_count":0},{"had_liked":false,"id":286297,"user_name":"yw","can_delete":false,"product_type":"c1","uid":1676638,"ip_address":"","ucode":"B478D3F90632E5","user_header":"https://static001.geekbang.org/account/avatar/00/19/95/5e/221ae9d7.jpg","comment_is_top":false,"comment_ctime":1617244706,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617244706","product_id":100017301,"comment_content":"桶排序的稳定性取决于桶内的排序算法吧,如果桶内用的是不稳定的排序算法,那桶排序也应该是不稳定的啊","like_count":0},{"had_liked":false,"id":280681,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614316801,"is_pvip":true,"discussion_count":1,"race_medal":5,"score":"1614316801","product_id":100017301,"comment_content":"茶艺师学编程<br><br>今天的课给到我一个画面<br><br>就拿排序算法来说，一般的排序算法就像是“普通的自行车”；<br>而工业级的排序算法就像是“有变速的自行车”，面对不同的路况，能不同的应对方案。","like_count":0,"discussions":[{"author":{"id":1073947,"avatar":"https://static001.geekbang.org/account/avatar/00/10/63/1b/83ac7733.jpg","nickname":"忧天小鸡","note":"","ucode":"A1412BDC108FD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373420,"discussion_content":"算法就是为了解决走烂路的问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620722535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280054,"user_name":"Geek_b9e729","can_delete":false,"product_type":"c1","uid":1609340,"ip_address":"","ucode":"E7607DE48AAA1F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKmql1FP9mYRmcIg8eGibU7ibhQ1Hph3LZerO90b2ibFNtIc20laZqnfCyrrGxfPeh9WmVdKdAz6bhng/132","comment_is_top":false,"comment_ctime":1614066140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614066140","product_id":100017301,"comment_content":"桶排序内部是快排，快排是不稳定排序算法，为什么桶排序却是稳定的呢？","like_count":0},{"had_liked":false,"id":278688,"user_name":"peace","can_delete":false,"product_type":"c1","uid":2440439,"ip_address":"","ucode":"92A2E5C40CD241","user_header":"https://static001.geekbang.org/account/avatar/00/25/3c/f7/78c29969.jpg","comment_is_top":false,"comment_ctime":1613202193,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613202193","product_id":100017301,"comment_content":"快排是不稳定排序，为什么C库中没有想办法优化呢？而是继续沿用，通用性上有些问题","like_count":0},{"had_liked":false,"id":278025,"user_name":"梁汝健丶","can_delete":false,"product_type":"c1","uid":1133557,"ip_address":"","ucode":"20D24F6C0158C8","user_header":"https://static001.geekbang.org/account/avatar/00/11/4b/f5/3ab1bea1.jpg","comment_is_top":false,"comment_ctime":1612707925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612707925","product_id":100017301,"comment_content":"加油","like_count":0},{"had_liked":false,"id":269259,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1608593656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608593656","product_id":100017301,"comment_content":"总结：<br>通用的排序算法：小规模的数据可以选择O(n^2)的排序算法，大规模数据的排序算法一般选择时间复杂度为O(nlogn)的快速排序。为了兼顾大小规模的数据，更加通用的排序算法是选择排序。<br><br>首先，虽然看上去O(N^2)的时间复杂度要比O(nlogn)的复杂度要高，但当数据规模很小时，算上系数，常数，低阶函数后，可能O(N^2)代码的执行时间要比O(nlogn)要短；但当数据规模很大时，O(N^2)肯定是不适用了，肯定选择复杂度更低的排序算法，可以选择归并排序，选择排序和线性排序。但由于归并排序占用的空间复杂度太高，数据量很大时，占用的内存会翻倍。线性排序又对数据的样本有很高的要求，所以一般使用选择排序；<br><br>综上，无论小规模还是大规模的数据，都可以使用快速排序来完成。<br><br>要使用选择排序就需要规避掉在最坏情况下的时间复杂度。造成最坏时间复杂度的原因为选择不合理的分区点。理想情况下，选择分区点后，分区两侧的数据量相差不大。所以在解决这个问题时，我们的出发点是：如何找到合理的分区点，来降低这种最坏情况的出现<br><br>如何找到快速排序合理的分区点呢？<br>1. 三点取中法：取头，尾，中间元素，三个元素比较大小后，取中间值作为分区点。有时当数据规模比较大时，还可以延展为：五点取中法，十点取中法等。<br><br>2.随机法：这个很容易理解，就是随机选择一个作为分区点。<br><br>既然快速排序使用的是递归，那就避免不了递归的缺陷：深度过深导致堆栈溢出和重复计算问题。<br><br>当然快速排序不设计重复计算的问题。那快速排序该如何避免由于递归过深导致溢出问题的呢？也有两种解决方案：<br>1. 设置阈值，当达到阈值后，不在进行递归<br>2.在堆上自行实现调用栈，手动模拟函数调用的入栈和出栈过程，从而绕开系统调用栈大小的限制","like_count":0},{"had_liked":false,"id":264859,"user_name":"Adam","can_delete":false,"product_type":"c1","uid":1517838,"ip_address":"","ucode":"965DCD693E752B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK36t2flfxhzKygfLfdIHbK99M9D9w3v3bwAHUibJSFAs1ibswf7hbhkqL321k5SUjfiaWkkHeRBlibNA/132","comment_is_top":false,"comment_ctime":1606694619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606694619","product_id":100017301,"comment_content":"Java1.8小于47插入排序 47-256双指针块排 大于256 归并排序","like_count":0},{"had_liked":false,"id":261463,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1364353,"ip_address":"","ucode":"1B2125C519443D","user_header":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","comment_is_top":false,"comment_ctime":1605344931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605344931","product_id":100017301,"comment_content":"思考题：<br>V8 引擎对 Array.prototype.sort 里面，排序算法的默认实现：\r<br>少于 10 个元素：插入排序 O(n^2)\r<br>多于等于 10 个元素：快速排序 O(nlogn)<br>\r<br>https:&#47;&#47;github.com&#47;v8&#47;v8&#47;blob&#47;master&#47;src&#47;builtins&#47;typed-array-sort.tq#L112-L115","like_count":0},{"had_liked":false,"id":250627,"user_name":"洪兴掌管一代","can_delete":false,"product_type":"c1","uid":1751242,"ip_address":"","ucode":"4B22C0B99A60F1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/ca/93b716f7.jpg","comment_is_top":false,"comment_ctime":1601177115,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601177115","product_id":100017301,"comment_content":"第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制<br><br>老师你好，这句话中，在堆上模拟调用栈的过程，不会造成堆溢出么？","like_count":0},{"had_liked":false,"id":245813,"user_name":"xgh","can_delete":false,"product_type":"c1","uid":1985935,"ip_address":"","ucode":"3C508E2ED32508","user_header":"https://static001.geekbang.org/account/avatar/00/1e/4d/8f/e3f171c1.jpg","comment_is_top":false,"comment_ctime":1599060598,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599060598","product_id":100017301,"comment_content":"java的collections.sort记得是归并+插入排序实现，恰巧看过源码","like_count":0},{"had_liked":false,"id":244284,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598450931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598450931","product_id":100017301,"comment_content":"java collections.sort 如果不指定归并排序， 默认会使用timsort 这种大量优化过的归并排序， 不过我的能力不足， 无法看明白timsort具体优化成什么样子","like_count":0},{"had_liked":false,"id":234840,"user_name":".","can_delete":false,"product_type":"c1","uid":2055898,"ip_address":"","ucode":"77609EE91386C4","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5e/da/9064df96.jpg","comment_is_top":false,"comment_ctime":1594808547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594808547","product_id":100017301,"comment_content":"效率高于一切<br>","like_count":0},{"had_liked":false,"id":229169,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1592915105,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592915105","product_id":100017301,"comment_content":"<br>Java 8 中的Collection.sort()排序，如果数据小于32个，就要用二分插入排序，当数据大于32个时，会将数组分成长度为16-32之间的小数组，然后依次对小数组进行二分插入排序并合并，其中二分插入排序还用到了查找升序或者降序的手法优化排序，<br>对于数组合并也做了大量优化，感觉是将插入排序和归并排序相结合并各自进行一些优化","like_count":0},{"had_liked":false,"id":210176,"user_name":"russellyue","can_delete":false,"product_type":"c1","uid":1541894,"ip_address":"","ucode":"0758ACF772F9C1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIMwPE6FwsicZ6bjhu7ZpWLnoib8G76sA1XL8y5W8GxqfQEjBub6g57E60mzjWzrA6icMRw1QT5CpyA/132","comment_is_top":false,"comment_ctime":1587694483,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1587694483","product_id":100017301,"comment_content":"总结：本质上，就是针对不一样的数据大小采用不一样的排序算法一般来说，线性排序算法的使用场景比较小，所以不能拿来作为一个通用的排序算法。那么我们一般会采用时间复杂度为O(nlogn)的排序算法，在时间复杂度为O(nlogn)的排序算法中，快速排序会优先于归并排序。原因就在于归并排序不是原地排序。但是快速排序也有一个致命的问题，那就是pivot的选择会影响到算法的时间复杂度，极端情况下，就是每一次快排的时候，全部数据都在pivot的另一边，那么时间复杂度就退化为O(n^2)。但是我们可以通过一些方式来优化pivot的选择，而不是每次都选择最后一个数据。第一种方式是三数取中法，就是选取首、中和尾的中间值。如果数据比较大的话，可以选择5数取中或者10数取中法。第二种方式，就是取区间中的随机数据作为分区点。另外，在数据比较少的情况下，O(n^2)的算法可能会优于O(nlogn)的算法。原因就在于，大O表示法研究的是渐进时间复杂度，代表的是随着数据的增长，算法时间复杂度的增长趋势。当数据比较小的时候，常数和系数项对于执行时间的影响也比较大。","like_count":0},{"had_liked":false,"id":210152,"user_name":"小童","can_delete":false,"product_type":"c1","uid":1763395,"ip_address":"","ucode":"300444B520E79D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","comment_is_top":false,"comment_ctime":1587692100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587692100","product_id":100017301,"comment_content":"太强了 一个排序运用很多算法！","like_count":0},{"had_liked":false,"id":208244,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1587307844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587307844","product_id":100017301,"comment_content":"qsort 兼顾了各种情况，进行优化，适用面很广，这才是工业级的排序函数，不简单是实现某个排序算法，而是将排序这个需求进行了细分，在各种场景下都要高效。","like_count":0},{"had_liked":false,"id":206376,"user_name":"梅端","can_delete":false,"product_type":"c1","uid":1525335,"ip_address":"","ucode":"FEC08731457770","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/57/fe38a6db.jpg","comment_is_top":false,"comment_ctime":1586850164,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586850164","product_id":100017301,"comment_content":"老师说的好，思考才是最重要的，点赞!!!!!!!!","like_count":0},{"had_liked":false,"id":201823,"user_name":"慕华","can_delete":false,"product_type":"c1","uid":1128579,"ip_address":"","ucode":"3026277274798B","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/83/cf789e0e.jpg","comment_is_top":false,"comment_ctime":1585841322,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585841322","product_id":100017301,"comment_content":"jdk8，小于48用的双插入排序，小于284用归并，其余三路快排，用5个点来判断是否近似排序，如果近似排序，用归并代替快排。","like_count":0},{"had_liked":false,"id":201351,"user_name":"Betamake","can_delete":false,"product_type":"c1","uid":1042234,"ip_address":"","ucode":"E7A6A595B4793E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/3a/eeedd8a4.jpg","comment_is_top":false,"comment_ctime":1585754740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585754740","product_id":100017301,"comment_content":"STL中的sort();当数据量较大时，采用快速排序分段，若每个分段内数据量仍较大时，段内还是采用快速排序，若每个分段内数据量较小时(&lt;16),段内采用插入排序，若递归深度较大时，采用堆排序","like_count":0},{"had_liked":false,"id":201070,"user_name":"游山行人","can_delete":false,"product_type":"c1","uid":1583499,"ip_address":"","ucode":"E559BD0A3C6484","user_header":"https://static001.geekbang.org/account/avatar/00/18/29/8b/3629c0f8.jpg","comment_is_top":false,"comment_ctime":1585711952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585711952","product_id":100017301,"comment_content":"老师，一样的疑问，桶排序童内用了快排，为什么还是稳定算法","like_count":0},{"had_liked":false,"id":200759,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585647062,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585647062","product_id":100017301,"comment_content":"java<br>在Arrays.sort()中，如果数据较少也是用插入排序","like_count":0},{"had_liked":false,"id":191648,"user_name":"黄昏鹿场","can_delete":false,"product_type":"c1","uid":1269801,"ip_address":"","ucode":"BC331B34E878CE","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/29/4564caba.jpg","comment_is_top":false,"comment_ctime":1584786650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584786650","product_id":100017301,"comment_content":"可以","like_count":0},{"had_liked":false,"id":189985,"user_name":"起疯了","can_delete":false,"product_type":"c1","uid":1148096,"ip_address":"","ucode":"F0CBA63FDFAEBF","user_header":"https://static001.geekbang.org/account/avatar/00/11/84/c0/dc45b789.jpg","comment_is_top":false,"comment_ctime":1584588971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584588971","product_id":100017301,"comment_content":"重刷一遍算法，准备面试","like_count":0},{"had_liked":false,"id":179251,"user_name":"凉人。","can_delete":false,"product_type":"c1","uid":1659177,"ip_address":"","ucode":"4DB16004A62015","user_header":"https://static001.geekbang.org/account/avatar/00/19/51/29/24739c58.jpg","comment_is_top":false,"comment_ctime":1581945325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581945325","product_id":100017301,"comment_content":"我认为快排的优化大概是这两种方法:<br>1 选择基准的方式<br>2 优化递归操作<br>目的大多为了减少递归次数","like_count":0},{"had_liked":false,"id":178850,"user_name":"lpf32","can_delete":false,"product_type":"c1","uid":1039717,"ip_address":"","ucode":"E1B127FDFF74BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/65/3b4a2930.jpg","comment_is_top":false,"comment_ctime":1581840305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581840305","product_id":100017301,"comment_content":"rust sort默认使用迭代的归并排序，但如果数据量小于20就使用插入排序，因为在小数量的情况下，插入比归并更快。","like_count":0},{"had_liked":false,"id":166644,"user_name":"yuanhjty","can_delete":false,"product_type":"c1","uid":1039318,"ip_address":"","ucode":"6E770C40E14A76","user_header":"https://static001.geekbang.org/account/avatar/00/0f/db/d6/efd70043.jpg","comment_is_top":false,"comment_ctime":1577529587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577529587","product_id":100017301,"comment_content":"模拟函数调用栈，使用循环实现快排，typescript版：<br><br>function partition(items: number[], left: number, right: number): number {<br>  const pivot = items[right];<br>  let i = left;<br>  for (let j = left; j &lt; right; j++) {<br>    if (items[j] &lt; pivot) {<br>      swap(items, i, j);<br>      i++;<br>    }<br>  }<br>  swap(items, i, right);<br>  return i;<br>}<br><br>type Frame = {<br>  left: number;<br>  right: number;<br>  status: 0 | 1 | 2;<br>  middle?: number;<br>};<br><br>function quickSort(items: number[]): number[] {<br>  const frameStack = new Stack&lt;Frame&gt;();<br>  frameStack.push({<br>    left: 0,<br>    right: items.length - 1,<br>    status: 0,<br>  });<br><br>  while (!frameStack.isEmpty()) {<br>    const frame = frameStack.peek();<br>    const { left, right, status } = frame;<br><br>    if (left &gt;= right) {<br>      frameStack.pop();<br>      continue;<br>    }<br><br>    if (status === 0) {<br>      const middle = partition(items, left, right);<br>      frameStack.push({<br>        left,<br>        right: middle - 1,<br>        status: 0,<br>      });<br>      frame.middle = middle;<br>      frame.status = 1;<br>    } else if (status === 1) {<br>      frameStack.push({<br>        left: frame.middle + 1,<br>        right,<br>        status: 0,<br>      });<br>      frame.status = 2;<br>    } else if (status === 2) {<br>      frameStack.pop();<br>    }<br>  }<br><br>  return items;<br>}","like_count":0},{"had_liked":false,"id":161346,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1576196456,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576196456","product_id":100017301,"comment_content":"1，如何实现一个通用的，高性能的排序函数？<br>\t <br>\t（1）线性排序算法的时间复杂度比较低，适用场景比较特殊。所以通用的排序函数不能使用线性排序算法。<br>\t（2）小规模数据排序，可以使用时间复杂为O(n^2)的算法；对大规模数据进行排序，时间复杂度是O(nlogn)的算法更加高效。所以为了兼顾任意数据规模的排序，一般都首选时间复杂度是O(nlogn)的排序算法。<br>\t（3）时间复杂度是O(nlogn)的排序算法不止一个，归并排序，快速排序，堆排序。但堆排序和快速排序使用较多。<br>\t（4）归并排序使用的不多是因为，空间复杂度是O(n)。<br>\t<br><br>\t2，如何优化快速排序？<br>\t\t（1）O(n^2)的时间复杂度出现的主要原因是因为我们的分区点选的不够合理<br>在最坏情况下快速排序的时间复杂度是O(n^2)。如果数据原来是有序的或者是接近有序的，每次分区都选择最后一个数据，那快速排序算法就会变得很糟糕，时间复杂度就会退化为O(n^2)。<br>\t\t（2）最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。<br>\t\t<br>\t\t（3）分区算法：<br>\t\t\t&lt;1&gt;：三数取中法：<br>\t\t\t\t从区间的首，尾，中间分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。<br>\t\t\t\t这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，会好于单纯取某个数据。在要排序的数组比较大时，需要取更多的数。<br>\t\t\t<br>\t\t\t&lt;2&gt;：随机法：<br>\t\t\t\t随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度看，也不大可能会出现每次分区点都选的很差的情况。<br>\t<br><br>\t\t<br><br>Arrays.sort<br>java8的排序<br>长度小于47：插入排序，包含普通插入排序和成对插入排序<br>长度小于286:快排，选择了两个pivote<br>长度大于286:检查数据是否有序，使用TimeSort或者快排<br>","like_count":0},{"had_liked":false,"id":160004,"user_name":"SteveYang","can_delete":false,"product_type":"c1","uid":1754829,"ip_address":"","ucode":"C42BCA4F40A9EF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKCbnOvEatUN4ysE2cl6zJNoAJVXXuQVhicQ1jxh6Z2Towrmmc1I6PndaicuQQ0RyyJPyJQicv4tSib9Q/132","comment_is_top":false,"comment_ctime":1575856508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575856508","product_id":100017301,"comment_content":"C#的Array. Sort采用的是快速排序，分区使用的是三者取中法。","like_count":0},{"had_liked":false,"id":159704,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1575732505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575732505","product_id":100017301,"comment_content":"「通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制」这个如何实现？我知道可以用循环代替递归","like_count":0},{"had_liked":false,"id":159487,"user_name":"港","can_delete":false,"product_type":"c1","uid":1122464,"ip_address":"","ucode":"35931FC6198180","user_header":"https://static001.geekbang.org/account/avatar/00/11/20/a0/1fca96c0.jpg","comment_is_top":false,"comment_ctime":1575635476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575635476","product_id":100017301,"comment_content":"java的Arrays.sort()在长度小于47时使用插入排序，长度大于286时，使用的timesort归并排序，大于47小于286用双轴快排","like_count":0},{"had_liked":false,"id":159259,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1575592842,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1575592842","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":150855,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1573617104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573617104","product_id":100017301,"comment_content":"看了java的Array.sort <br>1.当 数组length小于47 时 使用插入排序<br>2.当小于286时，使用快速排序<br>3.超过286使用合并排序<br>其中快速排序的pivot是采用5数取中的方法，五个数分别在数组的中间，并以长度的 1&#47;7 向<br>前后再各取两个。并且快速排序中增加了有序序列的监测","like_count":0},{"had_liked":false,"id":144173,"user_name":"Geek_eedadb","can_delete":false,"product_type":"c1","uid":1674637,"ip_address":"","ucode":"5C0AA741DA013F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6uMhKkDoyJ5ctXISeMrhXVBw55z7KJQze2niaUZGIhibeHrWib7jtCfOc8zOhxzeB5BAMZggicvQjZQ/132","comment_is_top":false,"comment_ctime":1571875071,"is_pvip":false,"replies":[{"id":"55986","content":"这个话题有点大了，我抽空写篇文章说说，你可以关注我的公号众：小争哥","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1572230654,"ip_address":"","comment_id":144173,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571875071","product_id":100017301,"comment_content":"哨兵是怎么用的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471834,"discussion_content":"这个话题有点大了，我抽空写篇文章说说，你可以关注我的公号众：小争哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572230654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142228,"user_name":"王加武","can_delete":false,"product_type":"c1","uid":1665471,"ip_address":"","ucode":"DDCFE578C6C428","user_header":"https://static001.geekbang.org/account/avatar/00/19/69/bf/50a824a4.jpg","comment_is_top":false,"comment_ctime":1571314993,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571314993","product_id":100017301,"comment_content":"JAVA 中的Collections.sort()排序的底层使用了快速排序，插入排序，归并排序三大排序算法，根据数据规模的不同会使用不同的排序算法，追求最优的效率！<br>","like_count":0},{"had_liked":false,"id":139417,"user_name":"先哥哥","can_delete":false,"product_type":"c1","uid":1693587,"ip_address":"","ucode":"633C118E3D331F","user_header":"https://static001.geekbang.org/account/avatar/00/19/d7/93/456d6f1a.jpg","comment_is_top":false,"comment_ctime":1570629537,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570629537","product_id":100017301,"comment_content":"快排的优化可以用三值取中法+插入排序+聚集。元素较少时用插入排序，较多时可以用三值取中法选取基准数，并在一次遍历后将与基准数相同的数聚集在基准数的两侧。划分时就不需要处理这部分重复的数了。","like_count":0},{"had_liked":false,"id":134701,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1568898152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568898152","product_id":100017301,"comment_content":"C++ STL中sort函数的实现综合了插入排序，快排和堆排序三种排序算法。当数据量小于16时，使用插入排序，并做了哨兵节点的优化。数据量较大时采用快排，其中分区点采用三数取中法获取，当递归深度超过45时，改用堆排序","like_count":0},{"had_liked":false,"id":134173,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1568770256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568770256","product_id":100017301,"comment_content":"老师，您好！希望您能在百忙之中，帮我解一下惑，问题是这样的：在JDK8中Arrays类中有一个私有的静态方法：<br>    private static void sort(float[] a, int left, int right, boolean leftmost) <br>在方法体中，会用到插入排序：<br>.............................................<br>                &#47;*<br>                 * Skip the longest ascending sequence.<br>                 *&#47;<br>                do {<br>                    if (left &gt;= right) {<br>                        return;<br>                    }<br>                } while (a[++left] &gt;= a[left - 1]);<br><br>                &#47;*<br>                 * Every element from adjoining part plays the role<br>                 * of sentinel, therefore this allows us to avoid the<br>                 * left range check on each iteration. Moreover, we use<br>                 * the more optimized algorithm, so called pair insertion<br>                 * sort, which is faster (in the context of Quicksort)<br>                 * than traditional implementation of insertion sort.<br>                 *&#47;<br>                for (int k = left; ++left &lt;= right; k = ++left) {<br>                    float a1 = a[k], a2 = a[left];<br><br>                    if (a1 &lt; a2) {<br>                        a2 = a1; a1 = a[left];<br>                    }<br>                    while (a1 &lt; a[--k]) {<br>                        a[k + 2] = a[k];<br>                    }<br>                    a[++k + 1] = a1;<br><br>                    while (a2 &lt; a[--k]) {<br>                        a[k + 1] = a[k];<br>                    }<br>                    a[k + 1] = a2;<br>                }<br>                float last = a[right];<br><br>                while (last &lt; a[--right]) {<br>                    a[right + 1] = a[right];<br>                }<br>                a[right + 1] = last;<br>            }<br><br><br>.............................<br>这个所谓的“pair insertion  sort”到底是什么路数？本人愚笨，想不明白！！！","like_count":0},{"had_liked":false,"id":133323,"user_name":"胡永","can_delete":false,"product_type":"c1","uid":1200543,"ip_address":"","ucode":"6C8BA1E0BED9C0","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/9f/1840385e.jpg","comment_is_top":false,"comment_ctime":1568516661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568516661","product_id":100017301,"comment_content":"我把老师上次课程讲的计数排序的实现用 javascript实现了一遍，发在了我的公众号上，然后附上了我的分享课程的链接，哈哈，老师这个入门课真心不错，对我这个转行来的前端很有用","like_count":0},{"had_liked":false,"id":129841,"user_name":"Song╮承諾","can_delete":false,"product_type":"c1","uid":1590793,"ip_address":"","ucode":"50FDBFE5BDDD12","user_header":"https://static001.geekbang.org/account/avatar/00/18/46/09/c61257f6.jpg","comment_is_top":false,"comment_ctime":1567300631,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1567300631","product_id":100017301,"comment_content":"PHP元素个数小于等于16使用插入排序，大于16使用快速排序","like_count":0},{"had_liked":false,"id":115351,"user_name":"王麒","can_delete":false,"product_type":"c1","uid":1265260,"ip_address":"","ucode":"330017C5A911B6","user_header":"https://static001.geekbang.org/account/avatar/00/13/4e/6c/71020c59.jpg","comment_is_top":false,"comment_ctime":1563538991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563538991","product_id":100017301,"comment_content":"优化版的快排","like_count":0},{"had_liked":false,"id":113945,"user_name":"唐二毛","can_delete":false,"product_type":"c1","uid":1597884,"ip_address":"","ucode":"7C16F45165F4BA","user_header":"https://static001.geekbang.org/account/avatar/00/18/61/bc/a656bee7.jpg","comment_is_top":false,"comment_ctime":1563191797,"is_pvip":false,"replies":[{"id":"41563","content":"发代码上来 不然我咋知道为啥啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563231246,"ip_address":"","comment_id":113945,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563191797","product_id":100017301,"comment_content":"自己实现的 归并排序总是比插入排序慢，一直想不通是什么原因，老师能否指点一下!","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458448,"discussion_content":"发代码上来 不然我咋知道为啥啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563231246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111069,"user_name":"石景峰","can_delete":false,"product_type":"c1","uid":1597637,"ip_address":"","ucode":"874265FA93EFBC","user_header":"https://static001.geekbang.org/account/avatar/00/18/60/c5/9788ee6d.jpg","comment_is_top":false,"comment_ctime":1562464461,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562464461","product_id":100017301,"comment_content":"记忆是理解的基础","like_count":0,"discussions":[{"author":{"id":1717444,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/34/c4/08d9f349.jpg","nickname":"元","note":"","ucode":"4576E15018EEA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":70288,"discussion_content":"反了吧，理解才是记忆基础。。不理解记忆不了，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575342364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106673,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1561369846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561369846","product_id":100017301,"comment_content":"利用拉格朗日中值定理","like_count":0},{"had_liked":false,"id":104072,"user_name":"Leedom","can_delete":false,"product_type":"c1","uid":1301344,"ip_address":"","ucode":"BC1240F2364DAD","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/60/17c224f6.jpg","comment_is_top":false,"comment_ctime":1560612303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560612303","product_id":100017301,"comment_content":"秋招准备中，真心觉得这个课程挺好的，希望自己能在九月前听完，感觉完全是把算法和实际常见的场景做了个结合。","like_count":0},{"had_liked":false,"id":99177,"user_name":"Geek_18b741","can_delete":false,"product_type":"c1","uid":1368496,"ip_address":"","ucode":"097BA0C2F44150","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlztvlBgajZMEph8AvkP2pfoqNCGtYSalIKgrCbCg0MWDZJgJwqVRfWA6cgIoZicL6dKibfK0zjsWg/132","comment_is_top":false,"comment_ctime":1559175142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559175142","product_id":100017301,"comment_content":"java8的排序<br>长度小于47：插入排序，包含普通插入排序和成对插入排序<br>长度小于286:快排，选择了两个pivote<br>长度大于286:检查数据是否有序，使用TimeSort或者快排","like_count":0},{"had_liked":false,"id":98423,"user_name":"Fergus","can_delete":false,"product_type":"c1","uid":1277066,"ip_address":"","ucode":"3A8AC741C49CEB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","comment_is_top":false,"comment_ctime":1559003582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559003582","product_id":100017301,"comment_content":"感谢老师：思考的过程，比“标准答案”重要的多。在学Python，用到的排序有sort,sorted,reversed，底层实现暂时还没看过，看完再回来。","like_count":0},{"had_liked":false,"id":84052,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1411645,"ip_address":"","ucode":"BF590964828F8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/8a/3d/5f29e927.jpg","comment_is_top":false,"comment_ctime":1554775517,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554775517","product_id":100017301,"comment_content":"4.9<br>很受用","like_count":0},{"had_liked":false,"id":81175,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1553825994,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1553825994","product_id":100017301,"comment_content":"const swap = (arr, i, j) =&gt; {<br>    if (i !== j) {<br>        const temp = arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    }<br>}","like_count":0},{"had_liked":false,"id":77248,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1552896756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552896756","product_id":100017301,"comment_content":"哪里可以看qsort(),找了一圈没找到","like_count":0},{"had_liked":false,"id":72325,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551587234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551587234","product_id":100017301,"comment_content":"同一种排序算法可能会根据数量值来采取动态变换而采用不同的排序算法，这本身就是一种算法优化。<br>","like_count":0},{"had_liked":false,"id":72088,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1551517318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551517318","product_id":100017301,"comment_content":"「在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法快。」<br><br>我对这句话有了新的体会，或者说，我对时间复杂度又有了比较深的体会:<br><br>「时间复杂度理论」是评估一个算法好坏的标准。这个理论隐含着一个非常重要的条件(或思想）：我们在比较算法时，必须要考虑数量特别大，大到近乎无穷大。因为计算机本来就是为了处理大数的，在小数上，计算机的优势不明显。很显然，这个理论是「科学性的」。但是在实际的软件开发中，工程师需要处理的绝大多数问题是「工程性的」，工程师要做的是“traceoff&quot;。正是因为这样，虽然快排的时间复杂度优于插入排序，但是工程师没有对插入排序一棒子打死。在小数据量下，依然还得用。例如：c语言函数库中的qsort，Java中的DualPivotQuicksort 和 TimSort等。","like_count":0},{"had_liked":false,"id":69863,"user_name":"朱坤","can_delete":false,"product_type":"c1","uid":1098637,"ip_address":"","ucode":"65224DA2456EAB","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/8d/214ad614.jpg","comment_is_top":false,"comment_ctime":1550892075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550892075","product_id":100017301,"comment_content":"按老师说的qsort思路实现了一遍(没有手动模拟栈)，实践中，我是把快排的三数取中变成 O(2N)的找到数组最大最小值，取平均，再找最接近平均的下标。。这种方法即可以取到较平均的分割点，也可以判断数组是否已经有序，提前对已有序的区间中断递归。。实践中还发现，如果是100万个很小范围的数字(0-100整数)，数组中会有大量重复的数据，此时进行快排。。如果不判断是否已经有序，分割点很可能始终是区间的首位，那么算法很快退化为O(N^2).并且栈溢出。","like_count":0},{"had_liked":false,"id":68840,"user_name":"黑白尤文","can_delete":false,"product_type":"c1","uid":1152644,"ip_address":"","ucode":"95B9F73AA0F20D","user_header":"https://static001.geekbang.org/account/avatar/00/11/96/84/d4ba322f.jpg","comment_is_top":false,"comment_ctime":1550622945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550622945","product_id":100017301,"comment_content":"我记得STL的排序用的三数取中的快排，Java用的归并优化的TimSort","like_count":0},{"had_liked":false,"id":66625,"user_name":"Pre-Y","can_delete":false,"product_type":"c1","uid":1396900,"ip_address":"","ucode":"A13D13A37F3ABC","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/a4/8d2e454b.jpg","comment_is_top":false,"comment_ctime":1549969044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1549969044","product_id":100017301,"comment_content":"今日份的打卡。<br>","like_count":0},{"had_liked":false,"id":63376,"user_name":"zachary","can_delete":false,"product_type":"c1","uid":1349192,"ip_address":"","ucode":"2559469DCF083F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/HRicO9C2gHpCxibedw0370AtpeqE9uo5kkBW4XCrsF9btibJPIq4vSribYdsjiaOFPK7YMfNmSSdIQlUMXGwgicTLTCg/132","comment_is_top":false,"comment_ctime":1548335730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1548335730","product_id":100017301,"comment_content":"O(n^2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长，这个结论的分析过程有些疑问。<br><br>现在是要证明在小数据量排序的情况下，归并比插入好。<br>归并：时间复杂度完整的表达式是 n*logn + n*T(1)，这个已经是没有省略低阶、系数和常数的表达式了<br>插入：时间复杂度为 n^2<br>要比的话，应该拿上面的两个公式来比，即便 n = 100 的情况下，归并还是比插入好啊，老师讲解时的 nlogn的完整表达式，不应该是归并的完整时间复杂度的表达式吧","like_count":0},{"had_liked":false,"id":62190,"user_name":"逍遥一叹","can_delete":false,"product_type":"c1","uid":1358759,"ip_address":"","ucode":"9FCAEB2E57DB70","user_header":"https://static001.geekbang.org/account/avatar/00/14/bb/a7/03f90dc4.jpg","comment_is_top":false,"comment_ctime":1547973781,"is_pvip":false,"replies":[{"id":"24175","content":"应该是用数组的。看你排序量多大了，再大就要使用多路排序（归并排序、桶排序等）、或者外排序。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1550479805,"ip_address":"","comment_id":62190,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1547973781","product_id":100017301,"comment_content":"当前排序算法都是基于数组分析的，当数据量很大时，还会使用数组装待排序的数据吗？如果使用链表等数据结构，这些算法的复杂度是否有影响？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437131,"discussion_content":"应该是用数组的。看你排序量多大了，再大就要使用多路排序（归并排序、桶排序等）、或者外排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1550479805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":62062,"user_name":"冰心丹","can_delete":false,"product_type":"c1","uid":1248443,"ip_address":"","ucode":"9E75D881373AD7","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/bb/057ec571.jpg","comment_is_top":false,"comment_ctime":1547900197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547900197","product_id":100017301,"comment_content":"有个C的排序函数看不明白，希望老师帮忙解答一下","like_count":0},{"had_liked":false,"id":57526,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1546828540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546828540","product_id":100017301,"comment_content":"spark的话，应该是桶排序。看他源码一个数据集拿来，先要走下rangePartition这个类，然后走shuffle，节点内排序。rangePartition这个类就是根据数据的大小然后分片，过程中定义好他的大小。最后节点排序之后出来merge。感觉就是桶排序的思路。这么说来桶排序貌似很契合分布式的排序算法","like_count":0},{"had_liked":false,"id":56257,"user_name":"nothing","can_delete":false,"product_type":"c1","uid":1250912,"ip_address":"","ucode":"49058C9095281D","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/60/d6024ae8.jpg","comment_is_top":false,"comment_ctime":1546412416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546412416","product_id":100017301,"comment_content":"老师请问有没有一种好的方法，可以通过排序看一组数据中有没有重复元素？","like_count":0},{"had_liked":false,"id":56188,"user_name":"Ben","can_delete":false,"product_type":"c1","uid":1252353,"ip_address":"","ucode":"70351D4FAE47F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/1c/01/5aaaf5b6.jpg","comment_is_top":false,"comment_ctime":1546401179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546401179","product_id":100017301,"comment_content":"#### .Net FrameWork Array Sort<br><br>    桌面版本4.5<br>        IntrospectiveSort(keys, values, index, length, comparer)<br>        如果待排序数组长度小于16<br>            &lt;=3: 直接交换1,2 1,3 2,3<br>            插入排序 InsertionSort<br>        如果待排序数组长度大于16: <br>            根据二分法得到分层深度, 然后选取分区, 递归降低深度为0, 调用堆排序<br>            if (depthLimit == 0) Heapsort(keys, values, lo, hi, comparer); return;<br>            depthLimit--;<br>            PickPivotAndPartition(keys, values, lo, hi, comparer);<br>            IntroSort(keys, values, num2 + 1, hi, depthLimit, comparer);<br>            hi = num2 - 1;<br>    其他版本 <br>        DepthLimitedQuickSort(keys, values, index, length + index - 1, comparer, 32)<br>        使用快速排序降低递归深度, 深度降为0后, 调用堆排序","like_count":0},{"had_liked":false,"id":51166,"user_name":"铃兰Neko","can_delete":false,"product_type":"c1","uid":1092845,"ip_address":"","ucode":"C6CECC62D73F1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/ac/ed/d868396d.jpg","comment_is_top":false,"comment_ctime":1545124322,"is_pvip":false,"replies":[{"id":"18556","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545184957,"ip_address":"","comment_id":51166,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1545124322","product_id":100017301,"comment_content":"对java来说，跟踪了一下 jdk1.7的源码：<br>Arrays 这个工具类提供的 sort 方法注释说的很清楚，<br>使用的是： DualPivotQuicksort 这个类实现排序；<br>1. 显然是快排，提供 O(n long(n)) 的 时间复杂度<br>2. 测试过很多数据集，这些数据集让传统的 快排命中最差情况，即n方，而dual pivot不会<br>3. 其他的大多数情况， dual pivot 也比传统的 one pivot 要快很多。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":433319,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545184957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49914,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1544788780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544788780","product_id":100017301,"comment_content":"关于优化快速排序：<br><br>在极端特殊的情况下（如排好序的数据中，每次以最后一个数据为分区点的情况）使用快排会使时间复杂度退化到O(n^2)，主要原因事分区点选的不合理，快排中分区点选择使的两边的数据相等时是最好的。所以分区点的选择是可以优化的以减少极端情况出现的概率。方法有：1、三数取中法（首尾中分别取数选择中间大小的数作为分区点）2、随机法<br><br>C语言中的qsort()函数就是优化排序的集成。qsort()优先使用归并排序（对于数据量小的比如几kb等，这时候花费同样的空间来换取时间是可以的），但当数据量大，比如100MB的数据用归并就需要额外100MB空间就不太好，这是qsort()会用快排来排序，分区点选的就是三数取中法。当数据特别小时，比如几个数字排序，就会使用插入排序（因为数据很小时，O(n^2)并不一定会比O(nlogn)花费时间多，所以选择比较简单，不用递归的排序）。","like_count":0},{"had_liked":false,"id":48685,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544515212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544515212","product_id":100017301,"comment_content":"小数据规模，O(n*n)的时间复杂度不一定比O（nlogn）慢<br>较小规模时，归并排序优于快速排序<br><br>快速排序也需要优化<br>快速排序 ------<br>合理选择分区点，<br>三个数选中间那个，或者随机一个出来<br><br>避免递归太深<br>通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程；<br>限制递归深度<br><br>思考题：<br>java里面的排序，也是区分了情况进行处理，没有细看","like_count":0},{"had_liked":false,"id":45915,"user_name":"Geek_987169","can_delete":false,"product_type":"c1","uid":1180853,"ip_address":"","ucode":"4B2955A044805D","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/b5/8bc4790b.jpg","comment_is_top":false,"comment_ctime":1543817581,"is_pvip":false,"replies":[{"id":"16538","content":"这里的堆表示计算机的堆内存。这句话更简单的理解是 实现一个栈 替代系统调用栈","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543888616,"ip_address":"","comment_id":45915,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543817581","product_id":100017301,"comment_content":"老师，&quot;自己实现一个堆上的栈&quot;是啥意思？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":431266,"discussion_content":"这里的堆表示计算机的堆内存。这句话更简单的理解是 实现一个栈 替代系统调用栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543888616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38910,"user_name":"Marnie","can_delete":false,"product_type":"c1","uid":1001912,"ip_address":"","ucode":"ECF9B22574F868","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/b8/fb19aa6a.jpg","comment_is_top":false,"comment_ctime":1542159107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542159107","product_id":100017301,"comment_content":"排序算法优化：<br>1.根据数据量，将几种算法结合起来使用。<br>2.递归太深，容易堆栈移除。解决方式是1.做深度判断，超过某个深度主动结束 2.自己实现堆栈管理。","like_count":0},{"had_liked":false,"id":36916,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1541387183,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1541387183","product_id":100017301,"comment_content":"设计通用的、高性能的排序：<br><br>线性排序的特殊性导致不适合通用这个特点， 而O(n^2)的效率太差，所以会选用O(nlogn)的快排或归并，而归并之前说了会造成空间的浪费，所以快排比较受欢迎。<br><br>而快排的最差效率是O(n^2)，提高效率的优化：1. 选择好的分区点，如三数取中法，取前后中三个数选出中间数；随机法，随机选择某个数不是很靠谱。2. 用模拟堆栈的方式代替递归，可以避免递归堆栈溢出的情况。<br><br>然而即使优化了效率，快排还是有缺点，由于是递归实现，可能会导致堆栈溢出，并且算法本身是不稳定的。所以还是要多个排序算法配合。<br><br>有一个排序思路可以借鉴：判断如果数据量不是那么的大，使用归并排序，这样其空间的占用也不会很大。如果数据量很大则使用快排，同时堆栈到一定程度时要停止递归（当然可以不使用递归，通过模拟栈的方式），最后如果排序到后期如果数据量很小使用插入排序，因为其实当数据量很少的时候就不能忽视常数、系数了，导致可能o(nlogn)比o(n^2)还要慢。","like_count":0},{"had_liked":false,"id":35977,"user_name":"周茜(Diane)","can_delete":false,"product_type":"c1","uid":1241703,"ip_address":"","ucode":"401D6C8800F51A","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/67/fd7c8a97.jpg","comment_is_top":false,"comment_ctime":1540879352,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540879352","product_id":100017301,"comment_content":"Apple，循环实现的归并排序。http:&#47;&#47;www.inf.fh-flensburg.de&#47;lang&#47;algorithmen&#47;sortieren&#47;merge&#47;mergiter.htm","like_count":0},{"had_liked":false,"id":35799,"user_name":"AotSun","can_delete":false,"product_type":"c1","uid":1257822,"ip_address":"","ucode":"3E6F78AAA11A0F","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/5e/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1540806314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540806314","product_id":100017301,"comment_content":"由于长期的以分数为主导，让思维定势，不敢想不敢做，其实并没有绝对的答案，主要是分析方法，按照更合理、更优化的方式来思考，从而得到答案。","like_count":0},{"had_liked":false,"id":35750,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1540781577,"is_pvip":true,"replies":[{"id":"12737","content":"并不是的 后面会讲 别急","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540811772,"ip_address":"","comment_id":35750,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540781577","product_id":100017301,"comment_content":"在堆上模拟实现一个函数栈 是怎么实现的呢？ 就是 我们用for循环来模拟的那种吗。。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427657,"discussion_content":"并不是的 后面会讲 别急","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540811772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35679,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1540739434,"is_pvip":false,"replies":[{"id":"12703","content":"估计有些同学已经掉队了 加油💪跟上","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540777620,"ip_address":"","comment_id":35679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540739434","product_id":100017301,"comment_content":"发现到后面，留言变少了。Mark一下，这几节排序内容信息量比较多，不同排序算法的时间和空间复杂度、稳定性以及适用场景等也都有所不同，一个字，就是干！","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427624,"discussion_content":"估计有些同学已经掉队了 加油💪跟上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540777620,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":35393,"user_name":"想换个昵称","can_delete":false,"product_type":"c1","uid":1236419,"ip_address":"","ucode":"0DEF5B253CFF8F","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/c3/826fca10.jpg","comment_is_top":false,"comment_ctime":1540537668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540537668","product_id":100017301,"comment_content":"public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {<br>        if (c == null) {<br>            sort(a);<br>        } else {<br>            if (LegacyMergeSort.userRequested)<br>                legacyMergeSort(a, c);<br>            else<br>                TimSort.sort(a, 0, a.length, c, null, 0, 0);<br>        }<br>    }<br><br>  老师，我不是很明白在java中Arrays源码中的 LegacyMergeSort.userRequested 这句是判断了什么😂，求点播","like_count":0},{"had_liked":false,"id":34843,"user_name":"天下","can_delete":false,"product_type":"c1","uid":1103061,"ip_address":"","ucode":"5F94E5DB2373EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/d5/1b9cbaeb.jpg","comment_is_top":false,"comment_ctime":1540339670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540339670","product_id":100017301,"comment_content":"分析一下代码","like_count":0},{"had_liked":false,"id":34841,"user_name":"小白猪","can_delete":false,"product_type":"c1","uid":1180615,"ip_address":"","ucode":"BC7FC0E0585B76","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/c7/bd45f0c9.jpg","comment_is_top":false,"comment_ctime":1540338633,"is_pvip":false,"replies":[{"id":"12505","content":"应该用归并排序","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540394794,"ip_address":"","comment_id":34841,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540338633","product_id":100017301,"comment_content":"老师，桶排序内部用的是快速排序，那么为什么桶排序是稳定算法？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427357,"discussion_content":"应该用归并排序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540394794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34645,"user_name":"纯洁的憎恶","can_delete":false,"product_type":"c1","uid":1130512,"ip_address":"","ucode":"5E9757DE6F45DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/10/b6bf3c3c.jpg","comment_is_top":false,"comment_ctime":1540252849,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1540252849","product_id":100017301,"comment_content":"库函数排序算法优化点：1.空间占用不大的时候采用更稳定的归并排序；2.空间占用大的时候用快速排序；3.快速排序要合理选择区间分割点钱，可采用三数取中、五数取中、随机抽取等；4.快速排序要防止系统堆栈溢出，可通过自实现轧入堆栈的方式解决；5.数据量极少情况下可切换为归并等简单的排序算法，其常数及常乘数复杂度要低于复杂的n（logn）算法。","like_count":0},{"had_liked":false,"id":34640,"user_name":"梦醒十分","can_delete":false,"product_type":"c1","uid":1043585,"ip_address":"","ucode":"33830A5A73DDF8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/81/2127e215.jpg","comment_is_top":false,"comment_ctime":1540248353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540248353","product_id":100017301,"comment_content":"所谓的标准答案就是没有深入思考，没有突破和创新。","like_count":0},{"had_liked":false,"id":34630,"user_name":"肖小强","can_delete":false,"product_type":"c1","uid":1245065,"ip_address":"","ucode":"A929A8D1DAD3C4","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/89/32e3f682.jpg","comment_is_top":false,"comment_ctime":1540224325,"is_pvip":false,"replies":[{"id":"12324","content":"堆上建栈 可以突破系统栈的大小 避免堆栈溢出。最合理的说法是这样子的。","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540258334,"ip_address":"","comment_id":34630,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540224325","product_id":100017301,"comment_content":"“将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度”老师，您在递归那一讲中提到的将递归改成非递归的过程，应该就是这里提到的在堆上实现一个函数调用栈吧。请问这个方法既然能防止堆栈溢出，那为什么又说其本质没有变，也没有解决某些问题？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427276,"discussion_content":"堆上建栈 可以突破系统栈的大小 避免堆栈溢出。最合理的说法是这样子的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540258334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34546,"user_name":"程序员大天地","can_delete":false,"product_type":"c1","uid":1249001,"ip_address":"","ucode":"7A21F15FEE2D5B","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/e9/98b6ea61.jpg","comment_is_top":false,"comment_ctime":1540202218,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540202218","product_id":100017301,"comment_content":"打卡，开始就有想到是多种排序综合应用。","like_count":0},{"had_liked":false,"id":34524,"user_name":"Woong","can_delete":false,"product_type":"c1","uid":1024978,"ip_address":"","ucode":"F009F3DFC4760A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/d2/69356194.jpg","comment_is_top":false,"comment_ctime":1540198830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540198830","product_id":100017301,"comment_content":"Android中的Collections.sort()长度小于32会使用折半插入排序，超过会使用TImSort","like_count":0},{"had_liked":false,"id":34508,"user_name":"凭实力写bug","can_delete":false,"product_type":"c1","uid":1235611,"ip_address":"","ucode":"6F772551F18935","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/9b/e0ef47df.jpg","comment_is_top":false,"comment_ctime":1540195271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540195271","product_id":100017301,"comment_content":"感觉真的我也想要标准答案，这都是老师带的，开始上学的时候感觉自己还是有想法的，可是老师只人答案。感觉现在教育系统有很大问题","like_count":0},{"had_liked":false,"id":34478,"user_name":"老姚","can_delete":false,"product_type":"c1","uid":1150339,"ip_address":"","ucode":"51A9ABBA1FFFE9","user_header":"https://static001.geekbang.org/account/avatar/00/11/8d/83/8b6972c0.jpg","comment_is_top":false,"comment_ctime":1540185284,"is_pvip":false,"replies":[{"id":"12329","content":"好像不可行 比如4 1 3 5 8","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540258636,"ip_address":"","comment_id":34478,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540185284","product_id":100017301,"comment_content":"关于快排在一个有序队列中时间为n^2解决思考：<br>  如果从最右取值进行判断，如果返回P等于最右，说明没有任务交换，原顺序不变，则不再进行递归，是否可行。<br>if(P=R) 则return; ","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427221,"discussion_content":"好像不可行 比如4 1 3 5 8","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540258636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":34464,"user_name":"刘远通","can_delete":false,"product_type":"c1","uid":1253307,"ip_address":"","ucode":"4D3EE819E4B235","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/bb/c488d5db.jpg","comment_is_top":false,"comment_ctime":1540179643,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1540179643","product_id":100017301,"comment_content":"快速排序选择分点，以及递归到规模比较小的时候直接使用插入排序","like_count":0},{"had_liked":false,"id":34463,"user_name":"勤劳的小胖子-libo","can_delete":false,"product_type":"c1","uid":1158344,"ip_address":"","ucode":"5BB20CD5A56568","user_header":"https://static001.geekbang.org/account/avatar/00/11/ac/c8/4b1c0d40.jpg","comment_is_top":false,"comment_ctime":1540179453,"is_pvip":false,"replies":[{"id":"12330","content":"可以自己模拟栈","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1540258670,"ip_address":"","comment_id":34463,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1540179453","product_id":100017301,"comment_content":"有什么技巧把递归转化成非递归？<br>发现一些递归算法，比如树的访问之类，没有什么思路如何转化成非递归。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":427219,"discussion_content":"可以自己模拟栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540258670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}