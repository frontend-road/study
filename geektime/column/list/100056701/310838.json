{"id":310838,"title":"39 | Redis 6.0的新特性：多线程、客户端缓存与安全","content":"<p>你好，我是蒋德钧。</p><p>Redis官方在今年5月份正式推出了6.0版本，这个版本中有很多的新特性。所以，6.0刚刚推出，就受到了业界的广泛关注。</p><p>所以，在课程的最后，我特意安排了这节课，想来和你聊聊Redis 6.0中的几个关键新特性，分别是面向网络处理的多IO线程、客户端缓存、细粒度的权限控制，以及RESP 3协议的使用。</p><p>其中，面向网络处理的多IO线程可以提高网络请求处理的速度，而客户端缓存可以让应用直接在客户端本地读取数据，这两个特性可以提升Redis的性能。除此之外，细粒度权限控制让Redis可以按照命令粒度控制不同用户的访问权限，加强了Redis的安全保护。RESP 3协议则增强客户端的功能，可以让应用更加方便地使用Redis的不同数据类型。</p><p>只有详细掌握了这些特性的原理，你才能更好地判断是否使用6.0版本。如果你已经在使用6.0了，也可以看看怎么才能用得更好，少踩坑。</p><p>首先，我们来了解下6.0版本中新出的多线程特性。</p><h2>从单线程处理网络请求到多线程处理</h2><p><strong>在Redis 6.0中，非常受关注的第一个新特性就是多线程</strong>。这是因为，Redis一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF重写），但是，从网络IO处理到实际的读写命令处理，都是由单个线程完成的。</p><!-- [[[read_end]]] --><p>随着网络硬件的性能提升，Redis的性能瓶颈有时会出现在网络IO的处理上，也就是说，<strong>单个主线程处理网络请求的速度跟不上底层网络硬件的速度</strong>。</p><p>为了应对这个问题，一般有两种方法。</p><p>第一种方法是，用用户态网络协议栈（例如DPDK）取代内核网络协议栈，让网络请求的处理不用在内核里执行，直接在用户态完成处理就行。</p><p>对于高性能的Redis来说，避免频繁让内核进行网络请求处理，可以很好地提升请求处理效率。但是，这个方法要求在Redis的整体架构中，添加对用户态网络协议栈的支持，需要修改Redis源码中和网络相关的部分（例如修改所有的网络收发请求函数），这会带来很多开发工作量。而且新增代码还可能引入新Bug，导致系统不稳定。所以，Redis 6.0中并没有采用这个方法。</p><p>第二种方法就是采用多个IO线程来处理网络请求，提高网络请求处理的并行度。Redis 6.0就是采用的这种方法。</p><p>但是，Redis的多IO线程只是用来处理网络请求的，对于读写命令，Redis仍然使用单线程来处理。这是因为，Redis处理请求时，网络处理经常是瓶颈，通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命令操作，就不用为了保证Lua脚本、事务的原子性，额外开发多线程互斥机制了。这样一来，Redis线程模型实现就简单了。</p><p>我们来看下，在Redis 6.0中，主线程和IO线程具体是怎么协作完成请求处理的。掌握了具体原理，你才能真正地会用多线程。为了方便你理解，我们可以把主线程和多IO线程的协作分成四个阶段。</p><p><strong>阶段一：服务端和客户端建立Socket连接，并分配处理线程</strong></p><p>首先，主线程负责接收建立连接请求。当有客户端请求和实例建立Socket连接时，主线程会创建和客户端的连接，并把 Socket 放入全局等待队列中。紧接着，主线程通过轮询方法把Socket连接分配给IO线程。</p><p><strong>阶段二：IO线程读取并解析请求</strong></p><p>主线程一旦把Socket分配给IO线程，就会进入阻塞状态，等待IO线程完成客户端请求读取和解析。因为有多个IO线程在并行处理，所以，这个过程很快就可以完成。</p><p><strong>阶段三：主线程执行请求操作</strong></p><p>等到IO线程解析完请求，主线程还是会以单线程的方式执行这些命令操作。下面这张图显示了刚才介绍的这三个阶段，你可以看下，加深理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/58/cd/5817b7e2085e7c00e63534a07c4182cd.jpg?wh=3000*2000\" alt=\"\"></p><p><strong>阶段四：IO线程回写Socket和主线程清空全局队列</strong></p><p>当主线程执行完请求操作后，会把需要返回的结果写入缓冲区，然后，主线程会阻塞等待IO线程把这些结果回写到Socket中，并返回给客户端。</p><p>和IO线程读取和解析请求一样，IO线程回写Socket时，也是有多个线程在并发执行，所以回写Socket的速度也很快。等到IO线程回写Socket完毕，主线程会清空全局队列，等待客户端的后续请求。</p><p>我也画了一张图，展示了这个阶段主线程和IO线程的操作，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/1b/2e1f3a5bafc43880e935aaa4796d131b.jpg?wh=3000*1693\" alt=\"\"></p><p>了解了Redis主线程和多线程的协作方式，我们该怎么启用多线程呢？在Redis 6.0中，多线程机制默认是关闭的，如果需要使用多线程功能，需要在redis.conf中完成两个设置。</p><p><strong>1.设置io-thread-do-reads配置项为yes，表示启用多线程。</strong></p><pre><code>io-threads-do-reads yes\n</code></pre><p>2.设置线程个数。一般来说，<strong>线程个数要小于Redis实例所在机器的CPU核个数</strong>，例如，对于一个8核的机器来说，Redis官方建议配置6个IO线程。</p><pre><code>io-threads  6\n</code></pre><p>如果你在实际应用中，发现Redis实例的CPU开销不大，吞吐量却没有提升，可以考虑使用Redis 6.0的多线程机制，加速网络处理，进而提升实例的吞吐量。</p><h2>实现服务端协助的客户端缓存</h2><p>和之前的版本相比，Redis 6.0新增了一个重要的特性，就是实现了服务端协助的客户端缓存功能，也称为跟踪（Tracking）功能。有了这个功能，业务应用中的Redis客户端就可以把读取的数据缓存在业务应用本地了，应用就可以直接在本地快速读取数据了。</p><p>不过，当把数据缓存在客户端本地时，我们会面临一个问题：<strong>如果数据被修改了或是失效了，如何通知客户端对缓存的数据做失效处理？</strong></p><p>6.0实现的Tracking功能实现了两种模式，来解决这个问题。</p><p><strong>第一种模式是普通模式</strong>。在这个模式下，实例会在服务端记录客户端读取过的key，并监测key是否有修改。一旦key的值发生变化，服务端会给客户端发送invalidate消息，通知客户端缓存失效了。</p><p>在使用普通模式时，有一点你需要注意一下，服务端对于记录的key只会报告一次invalidate消息，也就是说，服务端在给客户端发送过一次invalidate消息后，如果key再被修改，此时，服务端就不会再次给客户端发送invalidate消息。</p><p>只有当客户端再次执行读命令时，服务端才会再次监测被读取的key，并在key修改时发送invalidate消息。这样设计的考虑是节省有限的内存空间。毕竟，如果客户端不再访问这个key了，而服务端仍然记录key的修改情况，就会浪费内存资源。</p><p>我们可以通过执行下面的命令，打开或关闭普通模式下的Tracking功能。</p><pre><code>CLIENT TRACKING ON|OFF\n</code></pre><p><strong>第二种模式是广播模式</strong>。在这个模式下，服务端会给客户端广播所有key的失效情况，不过，这样做了之后，如果key 被频繁修改，服务端会发送大量的失效广播消息，这就会消耗大量的网络带宽资源。</p><p>所以，在实际应用时，我们会让客户端注册希望跟踪的key的前缀，当带有注册前缀的key被修改时，服务端会把失效消息广播给所有注册的客户端。<strong>和普通模式不同，在广播模式下，即使客户端还没有读取过key，但只要它注册了要跟踪的key，服务端都会把key失效消息通知给这个客户端</strong>。</p><p>我给你举个例子，带你看一下客户端如何使用广播模式接收key失效消息。当我们在客户端执行下面的命令后，如果服务端更新了user:id:1003这个key，那么，客户端就会收到invalidate消息。</p><pre><code>CLIENT TRACKING ON BCAST PREFIX user\n</code></pre><p>这种监测带有前缀的key的广播模式，和我们对key的命名规范非常匹配。我们在实际应用时，会给同一业务下的key设置相同的业务名前缀，所以，我们就可以非常方便地使用广播模式。</p><p>不过，刚才介绍的普通模式和广播模式，需要客户端使用RESP 3协议，RESP 3协议是6.0新启用的通信协议，一会儿我会给你具体介绍。</p><p>对于使用RESP 2协议的客户端来说，就需要使用另一种模式，也就是重定向模式（redirect）。在重定向模式下，想要获得失效消息通知的客户端，就需要执行订阅命令SUBSCRIBE，专门订阅用于发送失效消息的频道_redis_:invalidate。同时，再使用另外一个客户端，执行CLIENT TRACKING命令，设置服务端将失效消息转发给使用RESP 2协议的客户端。</p><p>我再给你举个例子，带你了解下如何让使用RESP 2协议的客户端也能接受失效消息。假设客户端B想要获取失效消息，但是客户端B只支持RESP 2协议，客户端A支持RESP 3协议。我们可以分别在客户端B和A上执行SUBSCRIBE和CLIENT TRACKING，如下所示：</p><pre><code>//客户端B执行，客户端B的ID号是303\nSUBSCRIBE _redis_:invalidate\n\n//客户端A执行\nCLIENT TRACKING ON BCAST REDIRECT 303\n</code></pre><p>这样设置以后，如果有键值对被修改了，客户端B就可以通过_redis_:invalidate频道，获得失效消息了。</p><p>好了，了解了6.0 版本中的客户端缓存特性后，我们再来了解下第三个关键特性，也就是实例的访问权限控制列表功能（Access Control List，ACL），这个特性可以有效地提升Redis的使用安全性。</p><h2>从简单的基于密码访问到细粒度的权限控制</h2><p>在Redis 6.0 版本之前，要想实现实例的安全访问，只能通过设置密码来控制，例如，客户端连接实例前需要输入密码。</p><p>此外，对于一些高风险的命令（例如KEYS、FLUSHDB、FLUSHALL等），在Redis 6.0 之前，我们也只能通过rename-command来重新命名这些命令，避免客户端直接调用。</p><p>Redis 6.0 提供了更加细粒度的访问权限控制，这主要有两方面的体现。</p><p><strong>首先，6.0版本支持创建不同用户来使用Redis</strong>。在6.0版本前，所有客户端可以使用同一个密码进行登录使用，但是没有用户的概念，而在6.0中，我们可以使用ACL SETUSER命令创建用户。例如，我们可以执行下面的命令，创建并启用一个用户normaluser，把它的密码设置为“abc”：</p><pre><code>ACL SETUSER normaluser on &gt; abc\n</code></pre><p><strong>另外，6.0版本还支持以用户为粒度设置命令操作的访问权限</strong>。我把具体操作列在了下表中，你可以看下，其中，加号（+）和减号（-）就分别表示给用户赋予或撤销命令的调用权限。</p><p><img src=\"https://static001.geekbang.org/resource/image/d1/c8/d1bd6891934cfa879ee080de1c5455c8.jpg?wh=2643*894\" alt=\"\"></p><p>为了便于你理解，我给你举个例子。假设我们要设置用户normaluser只能调用Hash类型的命令操作，而不能调用String类型的命令操作，我们可以执行如下命令：</p><pre><code>ACL SETUSER normaluser +@hash -@string\n</code></pre><p>除了设置某个命令或某类命令的访问控制权限，6.0版本还支持以key为粒度设置访问权限。</p><p>具体的做法是使用波浪号“~”和key的前缀来表示控制访问的key。例如，我们执行下面命令，就可以设置用户normaluser只能对以“user:”为前缀的key进行命令操作：</p><pre><code>ACL SETUSER normaluser ~user:* +@all\n</code></pre><p>好了，到这里，你了解了，Redis 6.0可以设置不同用户来访问实例，而且可以基于用户和key的粒度，设置某个用户对某些key允许或禁止执行的命令操作。</p><p>这样一来，我们在有多用户的Redis应用场景下，就可以非常方便和灵活地为不同用户设置不同级别的命令操作权限了，这对于提供安全的Redis访问非常有帮助。</p><h2>启用RESP 3协议</h2><p>Redis 6.0实现了RESP 3通信协议，而之前都是使用的RESP 2。在RESP 2中，客户端和服务器端的通信内容都是以字节数组形式进行编码的，客户端需要根据操作的命令或是数据类型自行对传输的数据进行解码，增加了客户端开发复杂度。</p><p>而RESP 3直接支持多种数据类型的区分编码，包括空值、浮点数、布尔值、有序的字典集合、无序的集合等。</p><p>所谓区分编码，就是指直接通过不同的开头字符，区分不同的数据类型，这样一来，客户端就可以直接通过判断传递消息的开头字符，来实现数据转换操作了，提升了客户端的效率。除此之外，RESP 3协议还可以支持客户端以普通模式和广播模式实现客户端缓存。</p><h2>小结</h2><p>这节课，我向你介绍了Redis 6.0的新特性，我把这些新特性总结在了一张表里，你可以再回顾巩固下。</p><p><img src=\"https://static001.geekbang.org/resource/image/21/f0/2155c01bf3129d5d58fcb98aefd402f0.jpg?wh=2922*2097\" alt=\"\"></p><p>最后，我也再给你一个小建议：因为Redis 6.0是刚刚推出的，新的功能特性还需要在实际应用中进行部署和验证，所以，如果你想试用Redis 6.0，可以尝试先在非核心业务上使用Redis 6.0，一方面可以验证新特性带来的性能或功能优势，另一方面，也可以避免因为新特性不稳定而导致核心业务受到影响。</p><h2>每课一问</h2><p>你觉得，Redis 6.0的哪个或哪些新特性会对你有帮助呢？</p><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事。我们下节课见。</p>","comments":[{"had_liked":false,"id":263256,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1606061461,"is_pvip":true,"discussion_count":11,"race_medal":0,"score":"409627954581","product_id":100056701,"comment_content":"Redis 6.0 的哪些新特性帮助最大？<br><br>我觉得 Redis 6.0 提供的多 IO 线程和客户端缓存这两大特性，对于我们使用 Redis 帮助最大。<br><br>多 IO 线程可以让 Redis 在并发量非常大时，让其性能再上一个台阶，性能提升近 1 倍，对于单机 Redis 性能要求更高的业务场景，非常有帮助。<br><br>而客户端缓存可以让 Redis 的数据缓存在客户端，相当于每个应用进程多了一个本地缓存，Redis 数据没有变化时，业务直接在应用进程内就能拿到数据，这不仅节省了网络带宽，降低了 Redis 的请求压力，还充分利用了业务应用的资源，对应用性能的提升也非常大。","like_count":96,"discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338260,"discussion_content":"第二点，之前许多中大团队都做过尝试，主要是集中在\n1）、封装本地缓存 与 redis，对外看起来是一个接口或者方法。\n2）、本地缓存如何被直接控制，例如接受请求主动加载某个key  主动卸载\n最重要的要能够承受加了本地缓存 与 缓存之间的极短时间内的不一致。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1609226227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2326134,"avatar":"https://static001.geekbang.org/account/avatar/00/23/7e/76/368394bf.jpg","nickname":"哦","note":"","ucode":"C776659DED9D79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380785,"discussion_content":"请问，这里Redis6.0的多线程模式是不是可以理解为多Reactor单线程的模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624697203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1411419,"avatar":"https://static001.geekbang.org/account/avatar/00/15/89/5b/b014ce14.jpg","nickname":"小五","note":"","ucode":"B7B1F121837CD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2326134,"avatar":"https://static001.geekbang.org/account/avatar/00/23/7e/76/368394bf.jpg","nickname":"哦","note":"","ucode":"C776659DED9D79","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381382,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625032302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380785,"ip_address":""},"score":381382,"extra":""},{"author":{"id":1131165,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/9d/c36b7ef7.jpg","nickname":"顾骨","note":"","ucode":"3F6BA592AB7723","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2326134,"avatar":"https://static001.geekbang.org/account/avatar/00/23/7e/76/368394bf.jpg","nickname":"哦","note":"","ucode":"C776659DED9D79","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550147,"discussion_content":"多Reactor单线程实际上完全没有意义，感觉更像是单 Reactor 多线程的变种：命令执行不在子线程而是在主线程。对执行耗时长的操作（比如bigkey），我感觉提升不大","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644394449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380785,"ip_address":""},"score":550147,"extra":""},{"author":{"id":1886364,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJoIDpqWcd3vuowkXguSkPuH2TcwmD9iak0sscUzCDrGAMln89vdC3GuH6KcQJkGg4xjdnb0bdnz2A/132","nickname":"shirly","note":"","ucode":"46875D2FCB9A6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2326134,"avatar":"https://static001.geekbang.org/account/avatar/00/23/7e/76/368394bf.jpg","nickname":"哦","note":"","ucode":"C776659DED9D79","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574899,"discussion_content":"同问？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654426540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":380785,"ip_address":""},"score":574899,"extra":""}]},{"author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336710,"discussion_content":"能详细说下io多路复用和多io线程的关系嘛，这一点我没理解通顺","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608684857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338271,"discussion_content":"转隔壁  深入拆解Tomcat &amp; Jetty\n有对这部分做了蛮深刻的讲解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609228365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336710,"ip_address":""},"score":338271,"extra":""},{"author":{"id":2049553,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLUDoNibohMic2oxC3UvaubWmuY5gcaS2Ht1GHcm3q99e5x0Xg0kSEwrR4XVO64zicwLFZEo1gZiaTJoQ/132","nickname":"陈时锐","note":"","ucode":"8CADD4EF8C2212","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379299,"discussion_content":"io多路复用指的是一个线程等待多个套接字的读写事件，多io线程就是用多个io线程做这件事吧 ，个人理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1623819469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336710,"ip_address":""},"score":379299,"extra":""}]},{"author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336709,"discussion_content":"能详细说下io多路复用和多io线程的关系嘛，这一点我没理解通顺","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608684852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2326134,"avatar":"https://static001.geekbang.org/account/avatar/00/23/7e/76/368394bf.jpg","nickname":"哦","note":"","ucode":"C776659DED9D79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380784,"discussion_content":"IO多路复用是指一个线程监听多个socket，主线程调用select接口传入要监听的socket，内核为遍历socket进行监听，当这些socket上面有读写等事件发生的时候，主线程select调用返回，然后再对发生事件的socket进行操作。而多个IO线程是指多个线程处理IO，读写数据","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1624697161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336709,"ip_address":""},"score":380784,"extra":""}]},{"author":{"id":1247522,"avatar":"https://static001.geekbang.org/account/avatar/00/13/09/22/22c0c4fa.jpg","nickname":"benying","note":"","ucode":"DEBAB485F381CC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328160,"discussion_content":"课代表好早","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606093407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268098,"user_name":"Geek_04f704","can_delete":false,"product_type":"c1","uid":1311265,"ip_address":"","ucode":"67395AA9DCD2EA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erKbqXs1LibG86q2OxHLic21eduYd9JPCf5ZaDlic3Dk7P0rS1n9jjExrvE6tmartuhPQhgSeEHZ1SaQ/132","comment_is_top":false,"comment_ctime":1608057660,"is_pvip":false,"replies":[{"id":"97654","content":"Redis 6.0中的多线程只是指，在客户端请求接收和解析，以及请求后的数据通过网络返回给客户端时，使用了多线程。而命令请求本身的数据读写操作还是由单线程来完成的，所以仍然可以保证单命令操作的原子性。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608595785,"ip_address":"","comment_id":268098,"utype":1}],"discussion_count":4,"race_medal":0,"score":"96097338172","product_id":100056701,"comment_content":"老师，redis支持多线程后，怎么实现单命令操作原子性的？","like_count":23,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511841,"discussion_content":"Redis 6.0中的多线程只是指，在客户端请求接收和解析，以及请求后的数据通过网络返回给客户端时，使用了多线程。而命令请求本身的数据读写操作还是由单线程来完成的，所以仍然可以保证单命令操作的原子性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608595785,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553767,"discussion_content":"阻塞，全局等待队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646061816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363997,"discussion_content":"天呐 你看文章了吗，还问这问题。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617345966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1934802,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/85/d2/045c63fb.jpg","nickname":"王建新","note":"","ucode":"E3151DDC0EEF0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345560,"discussion_content":"天呐 你看文章了吗，还问这问题。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611741572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263296,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1606094787,"is_pvip":false,"discussion_count":13,"race_medal":1,"score":"78915506115","product_id":100056701,"comment_content":"Redis 6.0增加了IO线程来处理网络请求，如果客户端先发送了一个`set key1 val1`写命令，紧接着发送一个`get key1`读命令。请问老师，由于IO线程是多线程处理的，是否会导致`get key1`读命令 先于 `set key1 val1`写命令执行呢？结果客户端读到了key1的旧值。","like_count":19,"discussions":[{"author":{"id":1049643,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/2b/68d6ac0d.jpg","nickname":"whiledoing","note":"","ucode":"1BEB769E13F47C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336145,"discussion_content":"个人初步理解：需要看客户端实现了，如果客户端用线程池去连接服务器，那么多个访问对应不同连接，可能存在乱序；如果客户端就一个连接，那么连接内数据读取是TCP保序的，不会乱序。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1608514334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193052,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/5c/6b4757a0.jpg","nickname":"倪大人","note":"","ucode":"4798D69F3E86FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328287,"discussion_content":"如果是同一个客户端，用的应该是同一个socket，那么两个指令在io线程读取、解析的时候就是有序的，主线程执行的时候也有序，不会读到旧值","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1606119747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193052,"avatar":"https://static001.geekbang.org/account/avatar/00/12/34/5c/6b4757a0.jpg","nickname":"倪大人","note":"","ucode":"4798D69F3E86FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328586,"discussion_content":"一个客户端建立一个socket还是一个请求建立一个socket","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606184546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328287,"ip_address":""},"score":328586,"extra":""},{"author":{"id":1128491,"avatar":"https://static001.geekbang.org/account/avatar/00/11/38/2b/9db9406b.jpg","nickname":"星夜","note":"","ucode":"3B46C09D994CEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334593,"discussion_content":"一个客户端一个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607911986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328586,"ip_address":""},"score":334593,"extra":""}]},{"author":{"id":1035257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","nickname":"Mr.蜜","note":"","ucode":"C911B81198B3F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336113,"discussion_content":"如果客户端只有一个的话，服务器接收客户端的请求是有序的，不存在你说的问题。而在读写分离的场景，那么不管服务器是否存在多线程，都会出现你说的问题。以为set和get不在一个客户端中，其数据同步存在一定的时延，进而很有可能读到错误的数据。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1608481283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297635,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo7R9LibMTe6CF9sVIcZUee5xCVEAxiava7CUb37V3ic6eFYuWBgFelDqeA0wekG2ibA3HFic94PYJHWlA/132","nickname":"山里小龙","note":"","ucode":"4ADA02F1ED59EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407271,"discussion_content":"不会，因为io线程是与socket绑定的，socker内执行是有序的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1634963515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372966,"discussion_content":"如果不是指定在两个线程中发送set、get的话，客户端单线程中发送了set命令，会阻塞等待set命令的返回结果，收到返回结果后才会发送get命令。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620544848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1386818,"avatar":"https://static001.geekbang.org/account/avatar/00/15/29/42/43d4b1a8.jpg","nickname":"烫烫烫","note":"","ucode":"C06018670DE76A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328280,"discussion_content":"我觉得是有可能的，即使是6.0之前的版本，如果这两个命令没有写入Lua文件中执行的话，中间也有可能被其它线程插入命令，效果也差不多。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606117886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1470434,"avatar":"https://static001.geekbang.org/account/avatar/00/16/6f/e2/f3b05833.jpg","nickname":"A 拽丫头","note":"","ucode":"F875D99D18DF6E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1386818,"avatar":"https://static001.geekbang.org/account/avatar/00/15/29/42/43d4b1a8.jpg","nickname":"烫烫烫","note":"","ucode":"C06018670DE76A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":582606,"discussion_content":"我也觉得有可能乱序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659523382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328280,"ip_address":"上海"},"score":582606,"extra":""}]},{"author":{"id":2536290,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/UswOHxYIocRX8LzhxbottcbUkwN0KcsLsw6Q8bFyXefCZzKnh6gCIKh2DicEeECTszLdJcl7l9TCdJzFcTay5Bw/132","nickname":"木又","note":"","ucode":"6CC0E49A027E3E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377373,"discussion_content":"希望老师能回答一下@","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622619571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020629,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","nickname":"yeek","note":"","ucode":"A1C71023113CB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329480,"discussion_content":"只要在redis服务端的socket链接中，不是同一个，就不能保证有序","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606389788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328213,"discussion_content":"我的理解主线程获取socket,这一步收到的客户端命令是有序的,然后只是分配给io线程多线程去解析请求和写回socket,命令还是在主线程在执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606106526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362375,"discussion_content":"多线程解析请求，有没有可能本来主线程先接受到的是set，后接受get，然后放在全局等待队列里，给io线程去处理，但是get先被一个io线程解析好，然后给主线程去执行，这不就会有问题么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616933261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328213,"ip_address":""},"score":362375,"extra":""}]}]},{"had_liked":false,"id":263287,"user_name":"王世艺","can_delete":false,"product_type":"c1","uid":1899435,"ip_address":"","ucode":"04DA844568766B","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fb/ab/c0c29cda.jpg","comment_is_top":false,"comment_ctime":1606092694,"is_pvip":true,"discussion_count":4,"race_medal":0,"score":"57440667542","product_id":100056701,"comment_content":"多线程io和epoll啥区别","like_count":14,"discussions":[{"author":{"id":1020629,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","nickname":"yeek","note":"","ucode":"A1C71023113CB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329481,"discussion_content":"epoll负责从网络接收数据到内核，多线程io从epoll记录的socket中将数据从内核读取到用户态","likes_number":28,"is_delete":false,"is_hidden":false,"ctime":1606389906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","nickname":"Mr.蜜","note":"","ucode":"C911B81198B3F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336114,"discussion_content":"这是2个概念，但首先还是要了解epoll的机制。epoll是内核去处理和接收网络数据，但如果网络请求很多，客户端也很多，那么单线程的epoll的处理还是顺序遍历的（可以参考select）；如果这时候，用多线程去分别处理socket数据，那么他们就可以并行的接收数据，增加相同时间的网络数据吞吐率，从而提升性能。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1608481577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1780797,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/2c/3d/0bd58aa4.jpg","nickname":"Em","note":"","ucode":"32012A5C603C8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1035257,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","nickname":"Mr.蜜","note":"","ucode":"C911B81198B3F5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578405,"discussion_content":"什么啊   epoll遍历也是遍历的活跃的套接字  select全部遍历","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656701719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":336114,"ip_address":""},"score":578405,"extra":""}]},{"author":{"id":2359194,"avatar":"https://static001.geekbang.org/account/avatar/00/23/ff/9a/f7d84a69.jpg","nickname":"Andrew.Fang","note":"","ucode":"1D754BBFC223F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335841,"discussion_content":"redis的单线程和多线程都是使用了epoll机制，底层都用到了多路服用机制，只是采用的线程模型不同。估计每个io线程都有一个selector用来注册连接，但是是只注册一个还是多个，没说明白，估计为了简化，只注册一个，因为一个线程还对应一对读写缓冲区，不好处理多个连接","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1608349174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263315,"user_name":"东","can_delete":false,"product_type":"c1","uid":1043947,"ip_address":"","ucode":"0FF5018422CEA9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/eb/88cac7a5.jpg","comment_is_top":false,"comment_ctime":1606099836,"is_pvip":false,"replies":[{"id":"97932","content":"这是个很好的用例场景！","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608997733,"ip_address":"","comment_id":263315,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48850740092","product_id":100056701,"comment_content":"6.0的权限细粒度控制对我们很有用，以前多个微服务共享同一个redis集群，权限没法隔离，现在可以控制不同的服务使用不同的key前缀，从而很好的隔离了服务，可以有效避免误操作，或者一个服务的bug影响到所有服务。","like_count":11,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510145,"discussion_content":"这是个很好的用例场景！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608997733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268769,"user_name":"🌾🌾🌾小麦🌾🌾🌾","can_delete":false,"product_type":"c1","uid":2046490,"ip_address":"","ucode":"ECB0CE18D5B49A","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3a/1a/ae3c1492.jpg","comment_is_top":false,"comment_ctime":1608344326,"is_pvip":false,"replies":[{"id":"97737","content":"我们说的缓存污染一般是指缓存系统里面的数据不被访问，但是由于缓存策略没有及时淘汰，又滞留在缓存中，导致缓存空间被占用，但是又不服务访问请求，造成了污染。<br><br>客户端缓存的主要问题是要和缓存系统中的数据保存一致，也就是说缓存系统中的数据被更新了，客户端需要及时做invalidation操作，避免应用在客户端缓存中读到旧的缓存数据。<br><br>内存泄露一般是内存没有正确回收导致的，和缓存污染、客户端缓存倒没有必然的联系。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608684400,"ip_address":"","comment_id":268769,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31673115398","product_id":100056701,"comment_content":"请问老师客户端缓存端缓存会不会导致缓存污染及内存泄露问题？","like_count":7,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512030,"discussion_content":"我们说的缓存污染一般是指缓存系统里面的数据不被访问，但是由于缓存策略没有及时淘汰，又滞留在缓存中，导致缓存空间被占用，但是又不服务访问请求，造成了污染。\n\n客户端缓存的主要问题是要和缓存系统中的数据保存一致，也就是说缓存系统中的数据被更新了，客户端需要及时做invalidation操作，避免应用在客户端缓存中读到旧的缓存数据。\n\n内存泄露一般是内存没有正确回收导致的，和缓存污染、客户端缓存倒没有必然的联系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608684400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271163,"user_name":"Dolly","can_delete":false,"product_type":"c1","uid":1513825,"ip_address":"","ucode":"CC74978F393055","user_header":"https://static001.geekbang.org/account/avatar/00/17/19/61/119cbde2.jpg","comment_is_top":false,"comment_ctime":1609426040,"is_pvip":false,"replies":[{"id":"98413","content":"除了保证一致性，客户端缓存本身也能加速访问，所以，这个特性是Redis 6.0中比较重要的一个，可以重点关注 :)","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609718876,"ip_address":"","comment_id":271163,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27379229816","product_id":100056701,"comment_content":"客户端缓存那个直接解决redis和本地缓存的一致性问题","like_count":7,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512853,"discussion_content":"除了保证一致性，客户端缓存本身也能加速访问，所以，这个特性是Redis 6.0中比较重要的一个，可以重点关注 :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609718876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263426,"user_name":"pretty.zh","can_delete":false,"product_type":"c1","uid":2257169,"ip_address":"","ucode":"E22A1817B39F22","user_header":"https://static001.geekbang.org/account/avatar/00/22/71/11/2d5cdb14.jpg","comment_is_top":false,"comment_ctime":1606131575,"is_pvip":false,"replies":[{"id":"97928","content":"你说的是指Redis中的整数对象共享池么？例如0到9999这些整数会被频繁用到，所以，使用共享对象来表示这些数，每个数只存一份String对象，可以节省内存空间。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1608997002,"ip_address":"","comment_id":263426,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18786000759","product_id":100056701,"comment_content":"老师，redis常量池是什么","like_count":4,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510187,"discussion_content":"你说的是指Redis中的整数对象共享池么？例如0到9999这些整数会被频繁用到，所以，使用共享对象来表示这些数，每个数只存一份String对象，可以节省内存空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608997002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263283,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":1629537,"ip_address":"","ucode":"8A0F58E2723893","user_header":"https://static001.geekbang.org/account/avatar/00/18/dd/61/544c2838.jpg","comment_is_top":false,"comment_ctime":1606091735,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"18785960919","product_id":100056701,"comment_content":"请问下，redis的客户端缓存与业务实例的本地缓存有区别吗？","like_count":4},{"had_liked":false,"id":328056,"user_name":"听秋","can_delete":false,"product_type":"c1","uid":2564684,"ip_address":"","ucode":"03CCD3B14980FA","user_header":"https://static001.geekbang.org/account/avatar/00/27/22/4c/d413494f.jpg","comment_is_top":false,"comment_ctime":1640505821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5935473117","product_id":100056701,"comment_content":"老师，客户端缓存的普通模式，当不在收到服务端的通知时，服务端 的 key 被修改了，应用读的是缓存到本地的数据，那不就读到旧数据了吗？","like_count":1},{"had_liked":false,"id":287468,"user_name":"芋头","can_delete":false,"product_type":"c1","uid":1227492,"ip_address":"","ucode":"A9C875548E4EE5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ba/e4/6df89add.jpg","comment_is_top":false,"comment_ctime":1617963775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5912931071","product_id":100056701,"comment_content":"Redis 6.0新特性:1.处理网络IO采用多线程模式2.服务端协助的客户端的缓存（普通模式和广播模式及重定向模式通知客户端key失效的信息）3.实现RESP3 协议，支持多种类型区分编码4.实例的细粒度访问权限控制（不同用户不同权限及用户为粒度的命令权限及支持以key为粒度用户权限）","like_count":1},{"had_liked":false,"id":281045,"user_name":"Kvicii.Y","can_delete":false,"product_type":"c1","uid":1442588,"ip_address":"","ucode":"446BFA633569EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/1c/c9fe6738.jpg","comment_is_top":false,"comment_ctime":1614561028,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5909528324","product_id":100056701,"comment_content":"这个多IO线程我没有看懂作用、能解释下吗","like_count":1},{"had_liked":false,"id":280483,"user_name":"neohope","can_delete":false,"product_type":"c1","uid":1043475,"ip_address":"","ucode":"C0268F6E7E2B6E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","comment_is_top":false,"comment_ctime":1614231682,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5909198978","product_id":100056701,"comment_content":"老师好，我翻了一下6.2的源码，多线程IO处理这个地方，主线程通知IO线程处理数据后，线程好像不算是阻塞状态吧？<br><br>int handleClientsWithPendingReadsUsingThreads(void) 函数里，主线程会一次性将多个接收请求分配给多个IO线程，然后一个死循环等待IO线程全部处理完毕，但线程状态应该是运行状态，不是阻塞状态吧？","like_count":1,"discussions":[{"author":{"id":1016575,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/ff/00e7614e.jpg","nickname":"robyy","note":"","ucode":"773337C9942A7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355873,"discussion_content":"死循环就是阻塞吧，这时主线程无法执行其他操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615498608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1325282,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/e2/28aa8e6c.jpg","nickname":"会玩code","note":"","ucode":"9220B072AF68C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016575,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/82/ff/00e7614e.jpg","nickname":"robyy","note":"","ucode":"773337C9942A7F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547846,"discussion_content":"这个时候如果有其他请求进来呢？主线程还能接收吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642901888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":355873,"ip_address":""},"score":547846,"extra":""},{"author":{"id":2365133,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLR2YXdT0AticVATPbtpd1LLOAA0FE1uRJstglZeBs1bAiaPB2PkEnlibIFtUPg1gsseribTib5Oiaw0BBA/132","nickname":"Geek_0cfc2d","note":"","ucode":"4E7A034578A19E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1325282,"avatar":"https://static001.geekbang.org/account/avatar/00/14/38/e2/28aa8e6c.jpg","nickname":"会玩code","note":"","ucode":"9220B072AF68C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552660,"discussion_content":"不能，会一直等待IO线程处理完毕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645539321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547846,"ip_address":""},"score":552660,"extra":""}]}]},{"had_liked":false,"id":272375,"user_name":"陌上花开","can_delete":false,"product_type":"c1","uid":1217933,"ip_address":"","ucode":"F623E6AA54D224","user_header":"https://static001.geekbang.org/account/avatar/00/12/95/8d/e27e5c7a.jpg","comment_is_top":false,"comment_ctime":1610071225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5905038521","product_id":100056701,"comment_content":"主线程接收完请求以后，通过轮询的方式交给IO线程处理，IO处理的速度可能会存在不一致的情况，如果保证主线程在执行命令的时候是按照轮询的顺序？","like_count":1},{"had_liked":false,"id":353532,"user_name":"A 拽丫头","can_delete":false,"product_type":"c1","uid":1470434,"ip_address":"上海","ucode":"F875D99D18DF6E","user_header":"https://static001.geekbang.org/account/avatar/00/16/6f/e2/f3b05833.jpg","comment_is_top":false,"comment_ctime":1659524333,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659524333","product_id":100056701,"comment_content":"多线程io  和  io多路复用有啥区别？ 我怎么感觉这两个是一个咧","like_count":0},{"had_liked":false,"id":314631,"user_name":"cake","can_delete":false,"product_type":"c1","uid":1966533,"ip_address":"","ucode":"55A7FC6CC1204C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/01/c5/b48d25da.jpg","comment_is_top":false,"comment_ctime":1633266828,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633266828","product_id":100056701,"comment_content":"客户端需要根据操作的命令或是数据类型自行对传输的数据进行解码，增加了客户端开发复杂度   应该是对传输的数据进行编码叭 0.0？","like_count":0},{"had_liked":false,"id":299537,"user_name":"哦","can_delete":false,"product_type":"c1","uid":2326134,"ip_address":"","ucode":"C776659DED9D79","user_header":"https://static001.geekbang.org/account/avatar/00/23/7e/76/368394bf.jpg","comment_is_top":false,"comment_ctime":1624697216,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1624697216","product_id":100056701,"comment_content":"请问，这里Redis6.0的多线程模式是不是可以理解为多Reactor单线程的模式","like_count":0,"discussions":[{"author":{"id":1099484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/dc/37dac825.jpg","nickname":"阿豪","note":"","ucode":"AF3CB1CE262CEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536805,"discussion_content":"应该是的，多个recator处理网络请求解析工作，单worker线程执行命令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638871776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296956,"user_name":"我","can_delete":false,"product_type":"c1","uid":2277195,"ip_address":"","ucode":"49C9AFFB997A3F","user_header":"https://static001.geekbang.org/account/avatar/00/22/bf/4b/2acf59c1.jpg","comment_is_top":false,"comment_ctime":1623239212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623239212","product_id":100056701,"comment_content":"redis6新的过期key扫描机制，相比于redis4可以有效的防止过期key堆积，可以节约成本。","like_count":0},{"had_liked":false,"id":296387,"user_name":"Ac、","can_delete":false,"product_type":"c1","uid":1610575,"ip_address":"","ucode":"7E7A8458372F33","user_header":"https://static001.geekbang.org/account/avatar/00/18/93/4f/61edeea6.jpg","comment_is_top":false,"comment_ctime":1622949982,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622949982","product_id":100056701,"comment_content":"对于Redis 6.0 来说，如果开启多 IO 线程的话，就不用 epoll。也就是说，多 IO 线程是 epoll 的一个替代方案？","like_count":0},{"had_liked":false,"id":293408,"user_name":"Geek_zt","can_delete":false,"product_type":"c1","uid":2094956,"ip_address":"","ucode":"4C70D267B90D03","user_header":"https://static001.geekbang.org/account/avatar/00/1f/f7/6c/c5997b0b.jpg","comment_is_top":false,"comment_ctime":1621385106,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1621385106","product_id":100056701,"comment_content":"客户端？服务端？是指什么，都是redis实例，还是一个后端为客户端，redis实例为服务端","like_count":0,"discussions":[{"author":{"id":1650562,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2f/82/bd80d7de.jpg","nickname":"Ben","note":"","ucode":"E436EE4CA7C146","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385344,"discussion_content":"一般服务端指redis server（实例），客户端就是访问redis server的应用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627009041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286681,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1617497024,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1617497024","product_id":100056701,"comment_content":"Redis 使用多 IO 线程处理网络请求，单线程处理读写命令，这应该是一个很好的 trade-off。<br><br>不知道国内公司采用 Redis 6.0 的多不多，对那些做了二次开发的，可能升级会困难一些；相对而言，可能小团队更容易升级。<br><br>对于课后题，小白无从解答，只能揣测。<br><br>是否需要多线程网络 IO 处理以及服务端协助的客户端缓存，可能需要看具体的业务场景；细粒度的权限控制和 RESP 3 协议感觉似乎比较有用。","like_count":0},{"had_liked":false,"id":278798,"user_name":"曾泽浩","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1613353875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613353875","product_id":100056701,"comment_content":"老师，客户端缓存是要自己根据tracking特性在业务中去实现吗？","like_count":0},{"had_liked":false,"id":278308,"user_name":"小轨道王子","can_delete":false,"product_type":"c1","uid":2430899,"ip_address":"","ucode":"4319DB2F46D14A","user_header":"","comment_is_top":false,"comment_ctime":1612865654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612865654","product_id":100056701,"comment_content":"主线程和io线程交互队列类似dpdk的无锁队列吗？io线程怎么感知主线程有消息扔过来了？","like_count":0},{"had_liked":false,"id":277856,"user_name":"Geek_1e8830","can_delete":false,"product_type":"c1","uid":1506574,"ip_address":"","ucode":"CD84A5AAAE6872","user_header":"","comment_is_top":false,"comment_ctime":1612623638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612623638","product_id":100056701,"comment_content":"权限控制到key这个级别对性能会不会有影响？","like_count":0},{"had_liked":false,"id":277213,"user_name":"茫农","can_delete":false,"product_type":"c1","uid":1206365,"ip_address":"","ucode":"71F7143644C9CB","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/5d/1ccee378.jpg","comment_is_top":false,"comment_ctime":1612317727,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612317727","product_id":100056701,"comment_content":"1，主线程等待io线程写完清空队列，队列里存的是什么？<br>2，等待写完是说主线程是一批一批的处理请求吗，是处理完一批再接一批处理？","like_count":0},{"had_liked":false,"id":267089,"user_name":"Geek_feee06","can_delete":false,"product_type":"c1","uid":1736547,"ip_address":"","ucode":"DB0C3DEEBCD502","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4qo5a7dgS8002fyNiciczVEWyaHH9Jw0WPoO59aRlIC8XNTRFNuMp3l8ELeC4DSY4yL84klibWIjZaicfL09P2aamA/132","comment_is_top":false,"comment_ctime":1607592255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607592255","product_id":100056701,"comment_content":"这种监测带有前缀的 key 的广播模式，与etcd的watch --prefix功能类似。不同点在于Redis返回给客户端的是invalidate消息，而etcd是返回更新后的值。所以etcd中这个功能一般用于配置共享与服务发现，而Redis直接返回无效，客户端若想获取最新的值，就得重新读取。有个疑问为什么Redis不像etcd这样也返回更新后的值给客户端呢？","like_count":0},{"had_liked":false,"id":267082,"user_name":"Geek_feee06","can_delete":false,"product_type":"c1","uid":1736547,"ip_address":"","ucode":"DB0C3DEEBCD502","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4qo5a7dgS8002fyNiciczVEWyaHH9Jw0WPoO59aRlIC8XNTRFNuMp3l8ELeC4DSY4yL84klibWIjZaicfL09P2aamA/132","comment_is_top":false,"comment_ctime":1607591325,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607591325","product_id":100056701,"comment_content":"这种监测带有前缀的 key 的广播模式，和etcd的watch prefix功能一样，不知道底层实现和性能有何差异？","like_count":0},{"had_liked":false,"id":264949,"user_name":"小袁","can_delete":false,"product_type":"c1","uid":1811495,"ip_address":"","ucode":"3F5D8721F577D9","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a4/27/15e75982.jpg","comment_is_top":false,"comment_ctime":1606718060,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606718060","product_id":100056701,"comment_content":"原文有一句话“如果你在实际应用中，发现 Redis 实例的 CPU 开销不大，吞吐量却没有提升，可以考虑使用 Redis 6.0 的多线程机制，加速网络处理，进而提升实例的吞吐量”。<br>这句话是不是有问题，如果真的是对网卡的数据来不及接收，那进程的cpu都已经跑满了才对。如果cpu没有跑满，又不从网卡取数据，这到底是什么行为？","like_count":0,"discussions":[{"author":{"id":1180877,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/cd/3f73dead.jpg","nickname":"黑曼巴ye","note":"","ucode":"3ACFD4B79E46A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341405,"discussion_content":"redis默认使用单线程，而单线程最多占用一个CPU，对于多核的机器来说，不可能跑满的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610412861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264946,"user_name":"千万海","can_delete":false,"product_type":"c1","uid":1179560,"ip_address":"","ucode":"941C431A163B83","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a8/73cd4a30.jpg","comment_is_top":false,"comment_ctime":1606717327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606717327","product_id":100056701,"comment_content":"这里面的主线程都是指同一个线程么，如果是，为什么处理链接和处理执行命令的线程为什么不分开？返回数据的时候，既然已经把数据写入了缓冲区了，为什么还需要io 线程专门写入socket？ 这个缓冲区是指的什么缓冲区？不是输出缓冲区么？老师或哪个大佬能解答下么<br>","like_count":0},{"had_liked":false,"id":264893,"user_name":"dfuru","can_delete":false,"product_type":"c1","uid":2110772,"ip_address":"","ucode":"0222FADA093D95","user_header":"","comment_is_top":false,"comment_ctime":1606701520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606701520","product_id":100056701,"comment_content":"客户端缓存，保证实例与缓存的数据一致性，还有其它方法吗？","like_count":0},{"had_liked":false,"id":264248,"user_name":"yeek","can_delete":false,"product_type":"c1","uid":1020629,"ip_address":"","ucode":"A1C71023113CB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","comment_is_top":false,"comment_ctime":1606390049,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606390049","product_id":100056701,"comment_content":"客户端实现本地缓存，在内存托管的平台上，会不会产生内存泄漏？","like_count":0},{"had_liked":false,"id":263531,"user_name":"灿烂明天","can_delete":false,"product_type":"c1","uid":1322455,"ip_address":"","ucode":"07DA56B0680D0C","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/d7/74fc8f38.jpg","comment_is_top":false,"comment_ctime":1606176768,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606176768","product_id":100056701,"comment_content":"老师，我想问下，轮训的方式把socket给io线程，与线程绑定的时候是不是已经是可读了，还是轮训有哪些可读的再给io线程的，请解惑，麻烦老师了","like_count":0,"discussions":[{"author":{"id":1020629,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","nickname":"yeek","note":"","ucode":"A1C71023113CB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329483,"discussion_content":"epoll是直接拿到可读的socket","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606389998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263474,"user_name":" 尿布","can_delete":false,"product_type":"c1","uid":1476323,"ip_address":"","ucode":"D1C8BDA7540962","user_header":"https://static001.geekbang.org/account/avatar/00/16/86/e3/a31f6869.jpg","comment_is_top":false,"comment_ctime":1606140772,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606140772","product_id":100056701,"comment_content":"2020.11.23打卡","like_count":0}]}