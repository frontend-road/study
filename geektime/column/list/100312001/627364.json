{"id":627364,"title":"26｜生产稳定的秘密武器：如何实施自动化渐进式交付？","content":"<p>你好，我是王炜。</p><p>在上一节课，我为你介绍了什么是金丝雀发布以及如何实施自动化金丝雀发布。</p><p>在实施金丝雀发布的过程中，我们通过 Argo Rollout 的金丝雀策略将发布过程分成了 3 个阶段，每个阶段金丝雀的流量比例都不同，经过一段时间之后，金丝雀环境变成了新的生产环境。实际上，这也是一种渐进式的交付方式，它通过延长发布时间来保护生产环境，降低了发生生产事故的概率。</p><p>不过，这种渐进式的交付方式存在一个明显的缺点：无法自动判断金丝雀环境是否出错。</p><p>这可能会导致一种情况，当金丝雀环境在接收生产流量之后，它产生了大量的请求错误，在缺少人工介入的情况下，发布仍然按照计划进行，最终导致生产环境故障。</p><p>为了解决这个问题，我们希望渐进式交付变得更加智能，一个好的工程实践方式是：<strong>通过指标分析来自动判断金丝雀发布的质量，如果符合预期，就继续金丝雀步骤；如果不符合预期，则进行回滚。</strong>这样，也就能够避免将金丝雀环境的故障带到生产环境中了，这种分析方法也叫做金丝雀分析。</p><p>这节课，我们就来学习如何将 Argo Rollout 和 Prometheus 结合，实现自动渐进式交付。</p><p>在开始今天的学习之前，你需要做好下面这些准备。</p><ul>\n<li>按照第一章<a href=\"https://time.geekbang.org/column/article/612571\">第 2 讲</a>的内容在本地配置好 Kind 集群，安装 Ingress-Nginx，<strong>并暴露 80 和 443 端口。</strong></li>\n<li>配置好 Kubectl，使其能够访问 Kind 集群。</li>\n<li>按照<a href=\"https://time.geekbang.org/column/article/625912\">第 24 讲</a>的内容安装好 Argo Rollout 以及 kubectl 插件。</li>\n</ul><!-- [[[read_end]]] --><h2>自动渐进式交付概述</h2><p>为了更好地帮助你理解自动渐进式交付，我给你画了一张整体的架构和流程图，如下所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/42/49/4214bc7180548e84e5f42a8d31411f49.jpg?wh=1920x953\" alt=\"图片\"></p><p>相比较金丝雀发布，自动渐进式交付增加了 Prometheus、Analysis Template 和 AnalysisRun 对象。其中，Analysis Template 定义用于分析的模板，AnalysisRun 是分析模板的实例化，Prometheus 是用来存储指标的数据库。</p><p>在这节课的例子中，我设计的自动渐进式交付流程会按照下面这张流程图来进行。</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/b2/bd6fa71710420b7e67dca5c6f0c5d7b2.jpg?wh=1920x663\" alt=\"图片\"></p><p>自动渐进式交付开始时，首先会先将金丝雀环境的流量比例设置为 20% 并持续两分钟，然后将金丝雀环境的流量比例设置为 40% 并持续两分钟，然后再以此类推到 60%、80%，直到将金丝雀环境提升为生产环境为止。</p><p>从第二个阶段开始，自动金丝雀分析开始运行，在持续运行的过程中，如果金丝雀分析失败，那么金丝雀环境将进行自动回滚。这样就达到了自动渐进式交付的目的。</p><h2>自动渐进式交付实战</h2><p>接下来，我们进入到渐进式交付的实战环节，实战过程大致分成下面几个步骤。</p><ol>\n<li>创建生产环境，包括 Rollout 对象、Service 和 Ingress。</li>\n<li>创建用于自动金丝雀分析的 AnalysisTemplate 模板。</li>\n<li>安装 Prometheus 并配置 Ingress-Nginx。</li>\n<li>修改镜像版本，启动渐进式交付。</li>\n</ol><h3>创建生产环境</h3><p>首先，我们需要创建用于模拟生产环境的 Rollout 对象、Service 和 Ingress。将下面的内容保存为 rollout-with-analysis.yaml 文件。</p><pre><code class=\"language-yaml\">apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: canary-demo\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: canary-demo\n  strategy:\n    canary:\n      analysis:\n        templates:\n        - templateName: success-rate\n        startingStep: 2\n        args:\n        - name: ingress\n          value: canary-demo\n      canaryService: canary-demo-canary\n      stableService: canary-demo\n      trafficRouting:\n        nginx:\n          stableIngress: canary-demo\n      steps:\n      - setWeight: 20\n      - pause:\n          duration: 2m\n      - setWeight: 40\n      - pause:\n          duration: 2m\n      - setWeight: 60\n      - pause:\n          duration: 2m\n      - setWeight: 80\n      - pause:\n          duration: 2m\n  template:\n    metadata:\n      labels:\n        app: canary-demo\n    spec:\n      containers:\n      - image: argoproj/rollouts-demo:blue\n        imagePullPolicy: Always\n        name: canary-demo\n        ports:\n        - containerPort: 8080\n          name: http\n          protocol: TCP\n        resources:\n          requests:\n            cpu: 5m\n            memory: 32Mi\n</code></pre><p>上面的内容相比较<a href=\"https://time.geekbang.org/column/article/626641\">第 25 讲</a>金丝雀发布的 Rollout 对象并没有太大差异，只是在 canary 字段下面增加了 analysis 字段，它的作用是指定金丝雀分析的模板，模板内容我们会在稍后创建。另外，这里同样使用了 argoproj/rollouts-demo:blue 镜像来模拟生产环境。</p><p>然后，使用 kubectl apply 命令将它应用到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f rollout-with-analysis.yaml\nrollout.argoproj.io/canary-demo created\n</code></pre><p>接下来，我们还需要创建 Service 对象。在这里，我们可以一并创建生产环境和金丝雀环境所需要用到的 Service ，将下面的内容保存为 canary-demo-service.yaml。</p><pre><code class=\"language-yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: canary-demo\n  labels: \n    app: canary-demo\nspec:\n  ports:\n  - port: 80\n    targetPort: http\n    protocol: TCP\n    name: http\n  selector:\n    app: canary-demo\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: canary-demo-canary\n  labels: \n    app: canary-demo\nspec:\n  ports:\n  - port: 80\n    targetPort: http\n    protocol: TCP\n    name: http\n  selector:\n    app: canary-demo\n</code></pre><p>然后，使用 kubectl apply 命令将它应用到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f canary-demo-service.yaml\nservice/canary-demo created\nservice/canary-demo-canary created\n</code></pre><p>最后，再创建 Ingress 对象。将下面的内容保存为 canary-demo-ingress.yaml 文件。</p><pre><code class=\"language-yaml\">apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: canary-demo\n  labels:\n    app: canary-demo\n  annotations:\n    kubernetes.io/ingress.class: nginx\nspec:\n  rules:\n    - host: progressive.auto\n      http:\n        paths:\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: canary-demo\n                port:\n                  name: http\n</code></pre><p>在这个 Ingress 对象中，指定了 progressive.auto 作为访问域名。</p><p>然后，使用 kubectl apply 命令将它应用到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f canary-demo-ingress.yaml\ningress.networking.k8s.io/canary-demo created\n</code></pre><h3>创建 AnalysisTemplate</h3><p>由于我们在 Rollout 对象中指定了名为 success-rate 的金丝雀分析模板，所以我们还需要创建它。将下面的内容保存为 analysis-success.yaml 文件。</p><pre><code class=\"language-yaml\">apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: ingress\n  metrics:\n  - name: success-rate\n    interval: 10s\n    failureLimit: 3\n    successCondition: result[0] &gt; 0.90\n    provider:\n      prometheus:\n        address: http://prometheus-kube-prometheus-prometheus.prometheus:9090\n        query: &gt;+\n          sum(\n            rate(nginx_ingress_controller_requests{ingress=\"{{args.ingress}}\",status!~\"[4-5].*\"}[60s]))\n            /\n            sum(rate(nginx_ingress_controller_requests{ingress=\"{{args.ingress}}\"}[60s])\n          )\n</code></pre><p>这里我简单介绍一下 AnalysisTemplate 对象字段的含义。</p><p>首先 spec.args 字段定义了参数，该参数会在后续的 query 语句中使用，它的值是从 Rollout 对象的 canary.analysis.args 字段传递进来的。</p><p>spec.metrics 字段定义了自动分析的相关配置。其中，interval 字段为频率，每 10 秒钟执行一次分析。failureLimit 字段代表“连续 3 次失败则金丝雀分析失败”，此时要执行回滚动作。successCondition 字段代表判断条件，这里的 result[0] 是一个表达式，代表的含义是当查询语句的返回值大于 0.90 时，说明本次金丝雀分析成功了。</p><p>最后，spec.metrics.provider 字段定义了分析数据来源于 Prometheus，还定义了 Prometheus Server 的连接地址，我们将在稍后部署 Prometheus。</p><p>query 字段是金丝雀分析的查询语句。这条查询语句的含义你可以简单地理解成：在 60 秒内 HTTP 状态码不为 4xx 和 5xx 的请求占所有请求的比例。换句话说，当 HTTP 请求成功的比例大于 0.90 时，代表一次金丝雀分析成功。</p><h3>访问生产环境</h3><p>接下来，为了访问生产环境，你还需要先配置 Hosts。</p><pre><code class=\"language-yaml\">127.0.0.1 progressive.auto\n</code></pre><p>接下来，使用浏览器访问 <a href=\"http://progressive.auto\">http://progressive.auto</a>，你应该能看到如下页面。</p><p><img src=\"https://static001.geekbang.org/resource/image/cd/4e/cd029631060f31f7f2282361ecc1d34e.png?wh=1920x1005\" alt=\"图片\"></p><h3>安装 Prometheus</h3><p>Prometheus&nbsp;是 Kubernetes 平台开源的监控和报警系统。由于金丝雀分析需要用到 Prometheus 来查询指标，所以我们需要先部署它。这里我使用 Helm 的方式进行部署。</p><pre><code class=\"language-yaml\">$ helm repo add prometheus-community https://prometheus-community.github.io/helm-charts\n$ helm upgrade prometheus prometheus-community/kube-prometheus-stack \\\n--namespace prometheus&nbsp; --create-namespace --install \\\n--set prometheus.prometheusSpec.podMonitorSelectorNilUsesHelmValues=false \\\n--set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false\n\nRelease \"prometheus\" does not exist. Installing it now.\n......\nSTATUS: deployed\n</code></pre><p>在上面的安装命令中，我使用 --set 对安装参数进行了配置，这是为了让它后续能够顺利获取到 Ingress-Nginx 的监控指标。</p><p>然后，你需要等待 prometheus 命名空间下的工作负载处于就绪状态。</p><pre><code class=\"language-yaml\">$ kubectl wait --for=condition=Ready pods --all -n prometheus\npod/alertmanager-prometheus-kube-prometheus-alertmanager-0 condition met\npod/prometheus-grafana-64b6c46fb5-6hz2z condition met\npod/prometheus-kube-prometheus-operator-696cc64986-pv9rg condition met\npod/prometheus-kube-state-metrics-649f8795d4-glbcq condition met\npod/prometheus-prometheus-kube-prometheus-prometheus-0 condition met\npod/prometheus-prometheus-node-exporter-mqnrw condition met\n</code></pre><p>到这里，Prometheus 就部署完成了。</p><h3>配置 Ingress-Nginx 和 ServiceMonitor</h3><p>为了让 Prometheus 能够顺利地获取到 HTTP 请求指标，我们需要打开 Ingress-Nginx Metric 指标端口。</p><p>首先需要为 Ingress-Nginx Deployment 添加容器的指标端口，你可以执行下面的命令来完成。</p><pre><code class=\"language-yaml\">$ kubectl patch deployment ingress-nginx-controller -n ingress-nginx --type='json' -p='[{\"op\": \"add\", \"path\": \"/spec/template/spec/containers/0/ports/-\", \"value\": {\"name\": \"prometheus\",\"containerPort\":10254}}]'\ndeployment.apps/ingress-nginx-controller patched\n</code></pre><p>然后，为 Ingrss-Nginx Service 添加指标端口。</p><pre><code class=\"language-yaml\">$ kubectl patch service ingress-nginx-controller -n ingress-nginx --type='json' -p='[{\"op\": \"add\", \"path\": \"/spec/ports/-\", \"value\": {\"name\": \"prometheus\",\"port\":10254,\"targetPort\":\"prometheus\"}}]'\nservice/ingress-nginx-controller patched\n</code></pre><p>最后，为了让 Prometheus 能够抓取到 Ingress-Nginx 指标，我们还需要创建 ServiceMonitor 对象，它可以为 Prometheus 配置指标获取的策略。将下面的内容保存为 servicemonitor.yaml 文件。</p><pre><code class=\"language-yaml\">apiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: nginx-ingress-controller-metrics\n  namespace: prometheus\n  labels:\n    app: nginx-ingress\n    release: prometheus-operator\nspec:\n  endpoints:\n  - interval: 10s\n    port: prometheus\n  selector:\n    matchLabels:\n      app.kubernetes.io/instance: ingress-nginx\n      app.kubernetes.io/name: ingress-nginx\n  namespaceSelector:\n    matchNames:\n    - ingress-nginx\n</code></pre><p>然后，通过 kubectl 将它部署到集群内。</p><pre><code class=\"language-yaml\">$ kubectl apply -f servicemonitor.yaml\nservicemonitor.monitoring.coreos.com/nginx-ingress-controller-metrics created\n</code></pre><p>当把 ServiceMonitor 应用到集群后，Prometheus 会按照标签来匹配 Ingress-Nginx Pod，并且会每 10s 主动拉取一次指标数据，并保存到 Prometheus 时序数据库中。</p><h3>验证 Ingress-Nginx 指标</h3><p>接下来，我们验证 Prometheus 是否已经成功获取到了 Ingress-Nginx 指标，这将决定自动金丝雀分析是否能成功获取到数据。</p><p>我们可以进入 Prometheus 控制台验证是否成功获取了 Ingress-Nginx 指标。首先，使用 kubectl port-forward 命令将 Prometheus 转发到本地。</p><pre><code class=\"language-yaml\">$ kubectl port-forward service/prometheus-kube-prometheus-prometheus 9090:9090 -n prometheus\nForwarding from 127.0.0.1:9090 -&gt; 9090\nForwarding from [::1]:9090 -&gt; 9090 \n</code></pre><p>接下来，使用浏览器打开 <a href=\"http://127.0.0.1:9090\">http://127.0.0.1:9090</a> 进入控制台，在搜索框中输入 nginx_ingress，如果出现一系列指标，则说明 Prometheus 和 Ingress-Nginx 已经配置完成，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/06/64/062d98ea9739e8dbd36c11a1d0d47f64.png?wh=1920x1005\" alt=\"图片\"></p><h2>自动渐进式交付实验</h2><p>现在，所有的准备工作都已经完成了，接下来我们进行自动渐进式交付实验。</p><p>让我们重新回忆一下我在前面提到的这张流程图。</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/5f/b40e2044e5a92a635dc8732357f1a25f.jpg?wh=1920x616\" alt=\"图片\"></p><p>在实验过程过程中，我会按照这张流程图分别进行两个实验。</p><ol>\n<li>自动渐进式交付成功（图中①号链路）。</li>\n<li>自动渐进式交付失败（图中②号链路）。</li>\n</ol><h3>自动渐进式交付成功</h3><p>接下来，我们进行自动渐进式交付成功的实验。</p><p>要开始实验，只要更新 Rollout 对象的镜像版本即可。在<a href=\"https://time.geekbang.org/column/article/626641\">第 25 讲</a>中，我提到了编辑 Rollout 对象并通过 kubectl apply 的方法来更新镜像版本。这节课，我们使用另一种更新镜像的方法，通过 Argo Rollout kubectl 插件来更新镜像。</p><pre><code class=\"language-yaml\">$ kubectl argo rollouts set image canary-demo canary-demo=argoproj/rollouts-demo:green\nrollout \"canary-demo\" image updated\n</code></pre><p>接下来，使用浏览器打开 <a href=\"http://progressive.auto\">http://progressive.auto</a> 返回应用，过一会儿看到绿色方块开始出现，流量占比约为 20%，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/78/f7c2116134499eddff81d44939355e78.png?wh=1920x1005\" alt=\"图片\"></p><p>现在，你可以尝试打开 Argo Rollout 控制台。</p><pre><code class=\"language-yaml\">$ kubectl argo rollouts dashboard\nINFO[0000] Argo Rollouts Dashboard is now available at http://localhost:3100/rollouts\n</code></pre><p>使用浏览器访问 <a href=\"http://localhost:3100/rollouts\">http://localhost:3100/rollouts</a> 进入控制台，观察自动渐进式交付过程。可以看到目前处在 20% 金丝雀流量的下一阶段，也就是暂停 2 分钟的阶段。</p><p><img src=\"https://static001.geekbang.org/resource/image/45/41/4505900970309b8f3bb1de844671ca41.png?wh=1920x1005\" alt=\"图片\"></p><p>2 分钟后，将进入到 40% 金丝雀流量阶段，从这个阶段开始，自动金丝雀分析开始工作，直到最后金丝雀发布完成，金丝雀环境提升为了生产环境，这时自动分析也完成了，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/e5/9c611d54433b937840c60b7aacfb98e5.png?wh=1920x1005\" alt=\"图片\"></p><p>到这里，一次完整的自动渐进式交付就完成了。</p><h3>自动渐进式交付失败</h3><p>在上面的实验中，由于应用返回的 HTTP 状态码都是 200 ，所以金丝雀分析自然是会成功的。</p><p>接下来，我们来尝试进行自动渐进式交付失败的实验。</p><p>经过了自动渐进式交付成功的实验之后，当前生产环境中的镜像为 argoproj/rollouts-demo:green，我们继续使用 Argo Rollout kubectl 插件来更新镜像，并将镜像版本修改为 yellow 版本。</p><pre><code class=\"language-yaml\">$ kubectl argo rollouts set image canary-demo canary-demo=argoproj/rollouts-demo:yellow\nrollout \"canary-demo\" image updated\n</code></pre><p>接下来，重新返回 <a href=\"http://progressive.auto\">http://progressive.auto</a> 打开应用，等待一段时间后，你会看到请求开始出现黄色方块，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/79/d5/7926c8e71af9aa0f08301fa71161b5d5.png?wh=1920x1005\" alt=\"图片\"></p><p>接下来，我们让应用返回错误的 HTTP 状态码。你可以滑动界面上的 ERROR 滑动块，将错误率设置为 50%，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/bc/a9/bc1178ee8698f16bc6ec35690d9698a9.png?wh=1920x1005\" alt=\"图片\"></p><p>现在，你会在黄色方块中看到带有红色描边的方块，这代表本次请求返回的 HTTP 状态码不等于 200，说明<strong>我们成功控制了一部分请求返回错误</strong>。</p><p>2 分钟后，金丝雀发布会进入到 40% 流量的阶段，此时自动分析将开始进行。现在，我们进入 Argo Rollout 控制台。</p><pre><code class=\"language-yaml\">$ kubectl argo rollouts dashboard\nINFO[0000] Argo Rollouts Dashboard is now available at http://localhost:3100/rollouts\n</code></pre><p>使用浏览器打开 <a href=\"http://localhost:3100/rollouts\">http://localhost:3100/rollouts</a>，进入发布详情，等待一段时间后，金丝雀分析将失败，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/9e/3e/9e29d8050d91702c74b43fc1d599b03e.png?wh=1920x1005\" alt=\"图片\"></p><p>此时，Argo Rollout 将执行自动回滚操作，这时候重新返回 <a href=\"http://progressive.auto\">http://progressive.auto</a> 打开应用，你会看到黄色方块的流量消失，所有请求被绿色方块取代，说明已经完成回滚了，如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/9d/d54d1f999e990cf7cc224ffc34be8f9d.png?wh=1920x1005\" alt=\"图片\"></p><p>到这里，一次完整的渐进式交付失败实验就完成了。</p><h2>总结</h2><p>这节课，我为你介绍了什么是渐进式交付，以及如何借助 ArgoCD 实施渐进式交付，它的发布流程和我们在 25 讲提到的金丝雀发布非常类似。</p><p>不同的是，渐进式交付在金丝雀发布的过程中加入了自动金丝雀分析，它可以验证新版本在生产环境中的表现，而这是单纯的金丝雀发布所无法实现的。借助渐进式交付，我们可以在发布过程通过指标实时分析金丝雀环境，兼顾发布的安全性和效率。</p><p>值得注意的是，为了能够查询到示例应用的 HTTP 指标，我开启了 Ingress-Nginx 的指标开关，这样所有经过 Ingress-Nginx 的流量都会被记录下来，结合 Prometheus ServiceMonitor 实现了 HTTP 请求指标的采集。</p><p>此外，为了让 ArgoCD 在渐进式交付时顺利运行金丝雀分析，我们还需要创建 AnalysisTemplate 对象，它实际上是 PromQL 编写的查询语句，ArgoCD 在交付过程中会用这条语句去 Prometheus 查询，并将返回的结果和预定义的阈值进行对比，以此控制渐进式交付应该继续进行还是回滚。</p><p>在实际的业务场景中，如果你希望验证多个维度的指标，你可以创建多个 AnalysisTemplate 并将它配置到 Rollout 对象中，进一步提高分析的可靠性。另外，你还可以在金丝雀发布的 steps 阶段里配置“内联”的分析步骤，比如在金丝雀环境 20% 和 40% 流量阶段的下一阶段分别运行不同的金丝雀分析，具体配置方法你可以参考<a href=\"https://argoproj.github.io/argo-rollouts/features/analysis/\">这份文档</a>。</p><p>这节课我并没有深入介绍 Prometheus。在生产环境下，我们通常会使用它来构建强大的监控和告警系统，我将在后续的课程为你详细介绍。</p><h2>思考题</h2><p>最后，给你留一道思考题吧。</p><p>当自动分析失败导致回滚时，是否有必要将镜像版本回写到 GitOps 应用定义的仓库中呢？</p><p>欢迎你给我留言交流讨论，你也可以把这节课分享给更多的朋友一起阅读。我们下节课见。</p>","comments":[{"had_liked":false,"id":369542,"user_name":"ghostwritten","can_delete":false,"product_type":"c1","uid":1308196,"ip_address":"北京","ucode":"AE512F2E24A1A0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f6/24/547439f1.jpg","comment_is_top":false,"comment_ctime":1677653058,"is_pvip":false,"replies":[{"id":134679,"content":"👍🏻 这里确实是有网络问题，很棒的解决方案！","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1677661608,"ip_address":"广东","comment_id":369542,"utype":1}],"discussion_count":1,"race_medal":1,"score":2,"product_id":100312001,"comment_content":"在这篇 helm 部署 prometheus-operator的时候卡住了，发现有两个镜像没有拉取成功，发现是registry.k8s.io：\n registry.k8s.io&#47;ingress-nginx&#47;kube-webhook-certgen:v1.3.0\nregistry.k8s.io&#47;kube-state-metrics&#47;kube-state-metrics:v2.8.0\n我利用 github action 自动拉取registry.k8s.io镜像推送dockerhub，重新定制了kube-prometheus-stack的charts并推送到github package或者私有harbor，总结了一篇文章： https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;8AYyAb-Uj8dOWxQxHCfD6A","like_count":1,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607186,"discussion_content":"👍🏻 这里确实是有网络问题，很棒的解决方案！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677661608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379318,"user_name":"Sophia-百鑫","can_delete":false,"product_type":"c1","uid":1269105,"ip_address":"上海","ucode":"070DC977441003","user_header":"https://static001.geekbang.org/account/avatar/00/13/5d/71/4f6aad17.jpg","comment_is_top":false,"comment_ctime":1691722638,"is_pvip":false,"replies":[{"id":138218,"content":"检查一下 ingress 路由策略","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1691763533,"ip_address":"广东","comment_id":379318,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"我在25讲金丝雀自动化发布实战的基础上，直接进行了本讲的实战，完成按老师的步骤执行。发现http:&#47;&#47;progressive.auto&#47;  一直显示的是绿色格子。 如何解决？\n","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625504,"discussion_content":"检查一下 ingress 路由策略","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1691763533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368332,"user_name":"gyl1989113","can_delete":false,"product_type":"c1","uid":1363213,"ip_address":"四川","ucode":"B7F2860B3FB101","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/cBh6rmNsSIbHEAGKiaq25yz9tqGuJEjbIYn2K0uFBLEe8lBNjL3SUOicibPbAO5SdH6TxV65kcCpK6FOB1hBr3PBQ/132","comment_is_top":false,"comment_ctime":1676210476,"is_pvip":false,"replies":[{"id":134148,"content":"Jenkins 作为 ci 工具用的比较多，持续部署就不太擅长了。","user_name":"作者回复","user_name_real":"编辑","uid":1275456,"ctime":1676252488,"ip_address":"广东","comment_id":368332,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"问下大佬工作中基本上都用argocd嘛。。我看tekton就一章节，jenkins看不到～","like_count":0,"discussions":[{"author":{"id":1275456,"avatar":"https://static001.geekbang.org/account/avatar/00/13/76/40/791d0f5e.jpg","nickname":"王炜","note":"","ucode":"B6F98A1EC06BDB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603489,"discussion_content":"Jenkins 作为 ci 工具用的比较多，持续部署就不太擅长了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676252489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363213,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/cBh6rmNsSIbHEAGKiaq25yz9tqGuJEjbIYn2K0uFBLEe8lBNjL3SUOicibPbAO5SdH6TxV65kcCpK6FOB1hBr3PBQ/132","nickname":"gyl1989113","note":"","ucode":"B7F2860B3FB101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":605028,"discussion_content":"好的，顺便问下ingress-nginx开启prometheus那一句kubect patch看不懂。。能解释下嘛。。 平时工作的话ci用tekton,cd用argocd嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676554577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367812,"user_name":"m1k3","can_delete":false,"product_type":"c1","uid":1027018,"ip_address":"广东","ucode":"896BCA57B7766E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ab/ca/bb1ebf5d.jpg","comment_is_top":false,"comment_ctime":1675649969,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"有必要，可以作为历史数据分析。这个版本镜像有什么问题可能推给开发者debug","like_count":1},{"had_liked":false,"id":367805,"user_name":"Amosヾ","can_delete":false,"product_type":"c1","uid":1567014,"ip_address":"广东","ucode":"833F6FCB4042AD","user_header":"https://static001.geekbang.org/account/avatar/00/17/e9/26/472e16e4.jpg","comment_is_top":false,"comment_ctime":1675646641,"is_pvip":true,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"镜像版本肯定需要回写到仓库中，否则开始自动更新的应用岂不是要重复执行发布回滚的操作。","like_count":1,"discussions":[{"author":{"id":1983237,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/43/05/3fbf26cf.jpg","nickname":"Noel ZHANG","note":"","ucode":"DF4E7E1FAFB509","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608160,"discussion_content":"你的后半句我不理解，理论上下一次是下一个image版本了，为什么会重复回滚操作呢？当然，发布失败不一定就是image的问题，可能是权限，网络，配置各种非image问题产生的。一帮情况下从dev到prod都要实现包流转，如果是产品发生回滚，大概率不是image问题，所以镜像肯定要留着。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678289281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385110,"user_name":"DeenJun","can_delete":false,"product_type":"c1","uid":1026010,"ip_address":"广东","ucode":"6D40BA39A33C9D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/da/f057374c.jpg","comment_is_top":false,"comment_ctime":1702100037,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"如果要把版本回写到仓库，那就是argocd要有git的写入权限？这感觉不是一个好的实践呢","like_count":0},{"had_liked":false,"id":384858,"user_name":"Geek_9acf33","can_delete":false,"product_type":"c1","uid":2191611,"ip_address":"广东","ucode":"3C39B88C3B7813","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI4tSatQ0rLPu7KBPyxnicmNj0SznMibMK85mFcRKvZrjA7XzP48CKUx0K7xbs2pbxzjTfsbyZicQ6Lg/132","comment_is_top":false,"comment_ctime":1701691362,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"需要，gitops不就是为了让线上环境跟git仓库里一致","like_count":0},{"had_liked":false,"id":367793,"user_name":"无名无姓","can_delete":false,"product_type":"c1","uid":2621412,"ip_address":"北京","ucode":"487BD5AA2CD305","user_header":"https://static001.geekbang.org/account/avatar/00/27/ff/e4/927547a9.jpg","comment_is_top":false,"comment_ctime":1675614434,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100312001,"comment_content":"验证需要哪些指标呢？","like_count":0}]}