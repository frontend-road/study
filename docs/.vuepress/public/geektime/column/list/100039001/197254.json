{"id":197254,"title":"44 | 工厂模式（上）：我为什么说没事不要随便用工厂模式创建对象？","content":"<p>上几节课我们讲了单例模式，今天我们再来讲另外一个比较常用的创建型模式：工厂模式（Factory Design Pattern）。</p><p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。不过，在GoF的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。实际上，前面一种分类方法更加常见，所以，在今天的讲解中，我们沿用第一种分类方法。</p><p>在这三种细分的工厂模式中，简单工厂、工厂方法原理比较简单，在实际的项目中也比较常用。而抽象工厂的原理稍微复杂点，在实际的项目中相对也不常用。所以，我们今天讲解的重点是前两种工厂模式。对于抽象工厂，你稍微了解一下即可。</p><p>除此之外，我们讲解的重点也不是原理和实现，因为这些都很简单，重点还是带你搞清楚应用场景：什么时候该用工厂模式？相对于直接new来创建对象，用工厂模式来创建究竟有什么好处呢？</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>简单工厂（Simple Factory）</h2><p>首先，我们来看，什么是简单工厂模式。我们通过一个例子来解释一下。</p><p>在下面这段代码中，我们根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象RuleConfig。</p><!-- [[[read_end]]] --><pre><code>public class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = null;\n    if (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new JsonRuleConfigParser();\n    } else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new XmlRuleConfigParser();\n    } else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new YamlRuleConfigParser();\n    } else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parser = new PropertiesRuleConfigParser();\n    } else {\n      throw new InvalidRuleConfigException(\n             &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n    }\n\n    String configText = &quot;&quot;;\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return &quot;json&quot;;\n  }\n}\n</code></pre><p>在“规范和重构”那一部分中，我们有讲到，为了让代码逻辑更加清晰，可读性更好，我们要善于将功能独立的代码块封装成函数。按照这个设计思路，我们可以将代码中涉及parser创建的部分逻辑剥离出来，抽象成createParser()函数。重构之后的代码如下所示：</p><pre><code>  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n    }\n\n    String configText = &quot;&quot;;\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return &quot;json&quot;;\n  }\n\n  private IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n</code></pre><p>为了让类的职责更加单一、代码更加清晰，我们还可以进一步将createParser()函数剥离到一个独立的类中，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p><pre><code>public class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);\n    if (parser == null) {\n      throw new InvalidRuleConfigException(\n              &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n    }\n\n    String configText = &quot;&quot;;\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return &quot;json&quot;;\n  }\n}\n\npublic class RuleConfigParserFactory {\n  public static IRuleConfigParser createParser(String configFormat) {\n    IRuleConfigParser parser = null;\n    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new JsonRuleConfigParser();\n    } else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new XmlRuleConfigParser();\n    } else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new YamlRuleConfigParser();\n    } else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) {\n      parser = new PropertiesRuleConfigParser();\n    }\n    return parser;\n  }\n}\n</code></pre><p>大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，比如Java中的DateFormat、Calender。除此之外，工厂类中创建对象的方法一般都是create开头，比如代码中的createParser()，但有的也命名为getInstance()、createInstance()、newInstance()，有的甚至命名为valueOf()（比如Java String类的valueOf()函数）等等，这个我们根据具体的场景和习惯来命名就好。</p><p>在上面的代码实现中，我们每次调用RuleConfigParserFactory的createParser()的时候，都要创建一个新的parser。实际上，如果parser可以复用，为了节省内存和对象创建的时间，我们可以将parser事先创建好缓存起来。当调用createParser()函数的时候，我们从缓存中取出parser对象直接使用。</p><p>这有点类似单例模式和简单工厂模式的结合，具体的代码实现如下所示。在接下来的讲解中，我们把上一种实现方法叫作简单工厂模式的第一种实现方法，把下面这种实现方法叫作简单工厂模式的第二种实现方法。</p><pre><code>public class RuleConfigParserFactory {\n  private static final Map&lt;String, RuleConfigParser&gt; cachedParsers = new HashMap&lt;&gt;();\n\n  static {\n    cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());\n    cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());\n    cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());\n    cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());\n  }\n\n  public static IRuleConfigParser createParser(String configFormat) {\n    if (configFormat == null || configFormat.isEmpty()) {\n      return null;//返回null还是IllegalArgumentException全凭你自己说了算\n    }\n    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());\n    return parser;\n  }\n}\n</code></pre><p>对于上面两种简单工厂模式的实现方法，如果我们要添加新的parser，那势必要改动到RuleConfigParserFactory的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的parser，只是偶尔修改一下RuleConfigParserFactory代码，稍微不符合开闭原则，也是完全可以接受的。</p><p>除此之外，在RuleConfigParserFactory的第一种代码实现中，有一组if分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，如果if分支并不是很多，代码中有if分支也是完全可以接受的。应用多态或设计模式来替代if分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性。关于这一点，我们在后面章节中会详细讲到。</p><p>总结一下，尽管简单工厂模式的代码实现中，有多处if分支判断逻辑，违背开闭原则，但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加parser，也没有太多的parser）是没有问题的。</p><h2>工厂方法（Factory Method）</h2><p>如果我们非得要将if分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构。重构之后的代码如下所示：</p><pre><code>public interface IRuleConfigParserFactory {\n  IRuleConfigParser createParser();\n}\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new JsonRuleConfigParser();\n  }\n}\n\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new XmlRuleConfigParser();\n  }\n}\n\npublic class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new YamlRuleConfigParser();\n  }\n}\n\npublic class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {\n  @Override\n  public IRuleConfigParser createParser() {\n    return new PropertiesRuleConfigParser();\n  }\n}\n</code></pre><p>实际上，这就是工厂方法模式的典型代码实现。这样当我们新增一种parser的时候，只需要新增一个实现了IRuleConfigParserFactory接口的Factory类即可。所以，<strong>工厂方法模式比起简单工厂模式更加符合开闭原则。</strong></p><p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。问题存在于这些工厂类的使用上。接下来，我们看一下，如何用这些工厂类来实现RuleConfigSource的load()函数。具体的代码如下所示：</p><pre><code>public class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = null;\n    if (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new JsonRuleConfigParserFactory();\n    } else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new XmlRuleConfigParserFactory();\n    } else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new YamlRuleConfigParserFactory();\n    } else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) {\n      parserFactory = new PropertiesRuleConfigParserFactory();\n    } else {\n      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = &quot;&quot;;\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return &quot;json&quot;;\n  }\n}\n</code></pre><p>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了load()函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。那怎么来解决这个问题呢？</p><p><strong>我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</strong>这段话听起来有点绕，我把代码实现出来了，你一看就能明白了。其中，RuleConfigParserFactoryMap类是创建工厂对象的工厂类，getParserFactory()返回的是缓存好的单例工厂对象。</p><pre><code>public class RuleConfigSource {\n  public RuleConfig load(String ruleConfigFilePath) {\n    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);\n\n    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n    if (parserFactory == null) {\n      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n    }\n    IRuleConfigParser parser = parserFactory.createParser();\n\n    String configText = &quot;&quot;;\n    //从ruleConfigFilePath文件中读取配置文本到configText中\n    RuleConfig ruleConfig = parser.parse(configText);\n    return ruleConfig;\n  }\n\n  private String getFileExtension(String filePath) {\n    //...解析文件名获取扩展名，比如rule.json，返回json\n    return &quot;json&quot;;\n  }\n}\n\n//因为工厂类只包含方法，不包含成员变量，完全可以复用，\n//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。\npublic class RuleConfigParserFactoryMap { //工厂的工厂\n  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = new HashMap&lt;&gt;();\n\n  static {\n    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());\n    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());\n    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());\n    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());\n  }\n\n  public static IRuleConfigParserFactory getParserFactory(String type) {\n    if (type == null || type.isEmpty()) {\n      return null;\n    }\n    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());\n    return parserFactory;\n  }\n}\n</code></pre><p>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的parser类和parser factory类，并且在RuleConfigParserFactoryMap类中，将新的parser factory对象添加到cachedFactories中即可。代码的改动非常少，基本上符合开闭原则。</p><p>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多Factory类，也会增加代码的复杂性，而且，每个Factory类只是做简单的new操作，功能非常单薄（只有一行代码），也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</p><p><strong>那什么时候该用工厂方法模式，而非简单工厂模式呢？</strong></p><p>我们前面提到，之所以将某个代码块剥离出来，独立为函数或者类，原因是这个代码块的逻辑过于复杂，剥离之后能让代码更加清晰，更加可读、可维护。但是，如果代码块本身并不复杂，就几行代码而已，我们完全没必要将它拆分成单独的函数或者类。</p><p>基于这个设计思想，当对象的创建逻辑比较复杂，不只是简单的new一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p><p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含if分支逻辑的实现方式。如果我们还想避免烦人的if-else分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p><h2>抽象工厂（Abstract Factory）</h2><p>讲完了简单工厂、工厂方法，我们再来看抽象工厂模式。抽象工厂模式的应用场景比较特殊，没有前两种常用，所以不是我们本节课学习的重点，你简单了解一下就可以了。</p><p>在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule规则配置还是System系统配置）来分类，那就会对应下面这8个parser类。</p><pre><code>针对规则配置的解析器：基于接口IRuleConfigParser\nJsonRuleConfigParser\nXmlRuleConfigParser\nYamlRuleConfigParser\nPropertiesRuleConfigParser\n\n针对系统配置的解析器：基于接口ISystemConfigParser\nJsonSystemConfigParser\nXmlSystemConfigParser\nYamlSystemConfigParser\nPropertiesSystemConfigParser\n</code></pre><p>针对这种特殊的场景，如果还是继续用工厂方法来实现的话，我们要针对每个parser都编写一个工厂类，也就是要编写8个工厂类。如果我们未来还需要增加针对业务配置的解析器（比如IBizConfigParser），那就要再对应地增加4个工厂类。而我们知道，过多的类也会让系统难维护。这个问题该怎么解决呢？</p><p>抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser等），而不是只创建一种parser对象。这样就可以有效地减少工厂类的个数。具体的代码实现如下所示：</p><pre><code>public interface IConfigParserFactory {\n  IRuleConfigParser createRuleParser();\n  ISystemConfigParser createSystemParser();\n  //此处可以扩展新的parser类型，比如IBizConfigParser\n}\n\npublic class JsonConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new JsonRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new JsonSystemConfigParser();\n  }\n}\n\npublic class XmlConfigParserFactory implements IConfigParserFactory {\n  @Override\n  public IRuleConfigParser createRuleParser() {\n    return new XmlRuleConfigParser();\n  }\n\n  @Override\n  public ISystemConfigParser createSystemParser() {\n    return new XmlSystemConfigParser();\n  }\n}\n\n// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码\n</code></pre><h2>\b重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。</p><p>在今天讲的三种工厂模式中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。所以，下面我重点对前两种工厂模式的应用场景进行总结。</p><p>当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。何为创建逻辑比较复杂呢？我总结了下面两种情况。</p><ul>\n<li>第一种情况：类似规则配置解析的例子，代码中存在if-else分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨if-else创建对象的代码抽离出来，放到工厂类中。</li>\n<li>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。</li>\n</ul><p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，我建议使用工厂方法模式。</p><p>除了刚刚提到的这几种情况之外，如果创建对象的逻辑并不复杂，那我们就直接通过new来创建对象就可以了，不需要使用工厂模式。</p><p>现在，我们上升一个思维层面来看工厂模式，它的作用无外乎下面这四个。这也是判断要不要使用工厂模式的最本质的参考标准。</p><ul>\n<li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li>\n<li>代码复用：\b创建代码抽离到独立的工厂类之后可以复用。</li>\n<li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li>\n<li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li>\n</ul><h2>课堂讨论</h2><ol>\n<li>工厂模式是一种非常常用的设计模式，在很多开源项目、工具类中到处可见，比如Java中的Calendar、DateFormat类。除此之外，你还知道哪些用工厂模式实现类？可以留言说一说它们为什么要设计成工厂模式类？</li>\n<li>实际上，简单工厂模式还叫作静态工厂方法模式（Static Factory Method Pattern）。之所以叫静态工厂方法模式，是因为其中创建对象的方法是静态的。那为什么要设置成静态的呢？设置成静态的，在使用的时候，是否会影响到代码的可测试性呢？</li>\n</ol><p>欢迎在留言区写下你的答案，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"43 | 单例模式（下）：如何设计实现一个集群环境下的分布式单例模式？","id":196790},"right":{"article_title":"45 | 工厂模式（下）：如何设计实现一个Dependency Injection框架？","id":198614}},"comments":[{"had_liked":false,"id":177792,"user_name":"逍遥思","can_delete":false,"product_type":"c1","uid":1015512,"ip_address":"","ucode":"340F05C786730F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/d8/92a98fb6.jpg","comment_is_top":false,"comment_ctime":1581500762,"is_pvip":false,"discussion_count":20,"race_medal":0,"score":"1642259007834","product_id":100039001,"comment_content":"复杂度无法被消除，只能被转移：<br><br>- 不用工厂模式，if-else 逻辑、创建逻辑和业务代码耦合在一起<br>- 简单工厂是将不同创建逻辑放到一个工厂类中，if-else 逻辑在这个工厂类中<br>- 工厂方法是将不同创建逻辑放到不同工厂类中，先用一个工厂类的工厂来来得到某个工厂，再用这个工厂来创建，if-else 逻辑在工厂类的工厂中","like_count":382},{"had_liked":false,"id":210264,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1587709592,"is_pvip":true,"replies":[{"id":"78767","content":"👍","user_name":"作者回复","comment_id":210264,"uid":"1190123","ip_address":"","utype":1,"ctime":1588042628,"user_name_real":"王争"}],"discussion_count":33,"race_medal":0,"score":"740322084504","product_id":100039001,"comment_content":"个人意见，传统的工厂模式太麻烦了，除非业务真的很复杂，通常我会选择以下方案。<br>还是举文中的例子<br><br>1.将不同的RuleConfigParser实现按照约定格式指定beanName注入，比方说@Component(“XmlRuleConfigParser”)，取的时候applicationContext.getBean(typeSuffix+RuleConfigParser)即可，拓展的话，自己写一个xxRuleConfigParser，就注入进去了，也不需要在map容器新增。<br>整个工厂方法就是<br>public RuleConfigParser getInstance(suffix){<br>    return InstanceLocator.getBean(suffix+&quot;RuleConfigParser&quot;);<br>}<br><br><br>2.直接用java.util.functional实现现代函数式编程范式的设计模式<br>像文中的例子,可以看作工厂,也可以看作获取一种parse策略。<br>可以有一个FunctionFactory内部维护一组Function&lt;String,String&gt;函数，再有一个Map容器 mapping type和Function的关系。这样是简化了类的数量，如果业务简单没必要整太多类，function铺在一个factory里可读性不会有什么问题。如果是没有返回值的操作，也可以用Consumer函数。打个比方<br><br>    public BiConsumer&lt;AbstractProductServiceRequest, Function&lt;ProductServiceQueryRequest,<br>        ProductServiceQueryResponse&gt;&gt; operateConsumer() {<br>        switch (serviceOperationEnum) {<br>            case OPEN:<br>                return openConsumer();<br>            case CLOSE:<br>                return closeConsumer();<br>            default:<br>                throw new RuntimeException(&quot;not support OperationType&quot;);<br>        }<br>    }<br><br>如果是对象，那更简单，Map&lt;Supply&gt;函数即可。<br><br>public class ShapeFactory {<br>  final static Map&lt;String, Supplier&lt;Shape&gt;&gt; map = new HashMap&lt;&gt;();<br>  static {<br>    map.put(&quot;CIRCLE&quot;, Circle::new);<br>    map.put(&quot;RECTANGLE&quot;, Rectangle::new);<br>  }   <br>  public Shape getShape(String shapeType){<br>     Supplier&lt;Shape&gt; shape = map.get(shapeType.toUpperCase());<br>     if(shape != null) {<br>       return shape.get();<br>     }<br>     throw new IllegalArgumentException(&quot;No such shape &quot; + shapeType.toUpperCase());<br>  }<br>}<br><br><br>以上个人意见，对于比较简单的场景，lambda function等方式代替类，会显得不那么臃肿，具体还是要看需求。至于OOP等原则，也不是完全要遵守的，就像争哥说的少量if可以不管，一样的道理，灵活运用。","like_count":172,"discussions":[{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51070,"discussion_content":"到了那个时候[个人认为短时间内不会实现], 猜测会产生两种结果, 水平一般的被取代,可能是被机器[倾向于机器], 可能是其他人, 技术牛的, 编写能自动生成我们想要软件的软件.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573807161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1141173,"avatar":"https://static001.geekbang.org/account/avatar/00/11/69/b5/1e1731cc.jpg","nickname":"zs阿帅","note":"","ucode":"07A54AE7F1CAFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51045,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573803799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177676,"user_name":"攻城狮MK","can_delete":false,"product_type":"c1","uid":1299404,"ip_address":"","ucode":"D418DEF46E0A04","user_header":"https://static001.geekbang.org/account/avatar/00/13/d3/cc/e3a54a6b.jpg","comment_is_top":false,"comment_ctime":1581472416,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"220624804512","product_id":100039001,"comment_content":"我把Head First的定义贴过来，方便大家理解总结<br><br>工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类<br><br>抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类","like_count":51,"discussions":[{"author":{"id":1088710,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","nickname":"苗","note":"","ucode":"5ECCC6C855E541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205793,"discussion_content":"这个定义其实不好理解。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1584343872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003005,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","nickname":"许童童","note":"","ucode":"4B799C0C6BC678","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167400,"discussion_content":"抽象工厂模式可以简单理解为帮你组装好了一个生产类的流水线。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581488476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134574,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/ee/bd08cfab.jpg","nickname":"一魄","note":"","ucode":"71541125D4AA5A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412040,"discussion_content":"删了吧，很晦涩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636065829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1643474,"avatar":"https://static001.geekbang.org/account/avatar/00/19/13/d2/230c2a98.jpg","nickname":"眭文峰","note":"","ucode":"62910C62D8205D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384430,"discussion_content":"没有作者的好理解，快点忘记快点忘记","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626588357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240810,"user_name":"跳跳","can_delete":false,"product_type":"c1","uid":2085322,"ip_address":"","ucode":"332AA758394E83","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d1/ca/b537d120.jpg","comment_is_top":false,"comment_ctime":1597072351,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"203460535263","product_id":100039001,"comment_content":"我觉得很多人被带跑偏了 工厂本身的重点不是解决if else 而是解决简单工厂的开闭原则，大家都在重点讨论if else 即使被省略了 也是map的功劳啊","like_count":47,"discussions":[{"author":{"id":1484192,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/a0/e0cccf7e.jpg","nickname":"圆圆满满","note":"","ucode":"396E7A822014D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576313,"discussion_content":"工厂本质就是用策略模式隔离了对象创建逻辑的复杂性。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1655426879,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2546944,"avatar":"https://static001.geekbang.org/account/avatar/00/26/dd/00/63bfbea9.jpg","nickname":"码不能停","note":"","ucode":"D43C94F7106936","race_medal":5,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590219,"discussion_content":"if-else其实只是为了引出简单工厂模式的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665627188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003265,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4f/01/cff4ce72.jpg","nickname":"cat","note":"","ucode":"F50B371C2123C2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549330,"discussion_content":"正解，解决if是map顺带的事儿。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643859676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177834,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1581512610,"is_pvip":true,"discussion_count":6,"race_medal":0,"score":"173380204450","product_id":100039001,"comment_content":"在JDK中工厂方法的命名有些规范：<br>1. valueOf() 返回与入参相等的对象<br>例如 Integer.valueOf()<br>2. getInstance() 返回单例对象<br>例如 Calendar.getInstance()<br>3. newInstance() 每次调用时返回新的对象<br>例如 HelloWorld.class.getConstructor().newInstance()<br>4 在反射中的工厂方法 <br>例如 XXX.class.getField(String name) 返回成员<br><br>静态工厂方法的优点：<br>1. 静态工厂方法子类可以继承，但不能重写，这样返回类型就是确定的。可以返回对象类型或者primitive 类型。<br>2. 静态工厂方法的名字更有意义，例如Collections.synchronizedMap() <br>3. 静态工厂方法可以封装创建对象的逻辑，还可以做其他事情，让构造方法只初始化成员变量。<br>4. 静态工厂方法可以控制创建实例的个数。例如单例模式，或者多例模式，使用本质上是可以用静态工厂方法实现。","like_count":40,"discussions":[{"author":{"id":1322636,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","nickname":"张滔","note":"","ucode":"87ABAFF0E861E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277063,"discussion_content":"兄嘚，Calendar.getInstance()返回的不是单例，每次都会去new一个出来。。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1590992066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1322636,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","nickname":"张滔","note":"","ucode":"87ABAFF0E861E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277121,"discussion_content":"好的，谢谢！学习了！我看的不仔细。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591003601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277063,"ip_address":""},"score":277121,"extra":""},{"author":{"id":2085090,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","nickname":"写代码的","note":"","ucode":"F58186409A3D65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":299703,"discussion_content":"不怪你，这个类的命名就有问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597772151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277121,"ip_address":""},"score":299703,"extra":""},{"author":{"id":2140880,"avatar":"https://static001.geekbang.org/account/avatar/00/20/aa/d0/2d20a69b.jpg","nickname":"Yuyy","note":"","ucode":"D2587EB03C7028","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1322636,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2e/8c/b261e15a.jpg","nickname":"张滔","note":"","ucode":"87ABAFF0E861E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391829,"discussion_content":"确实是\n    public Calendar getInstance(TimeZone zone, Locale locale) {\n        return new Calendar.Builder()\n                     .setLocale(locale)\n                     .setTimeZone(zone)\n                     .setInstant(System.currentTimeMillis())\n                     .build();\n    }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630650692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277063,"ip_address":""},"score":391829,"extra":""}]},{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245900,"discussion_content":"Effective Java创建模式中有讲解，像Guava Lists、ImmutableMap等实现都是这种风格，表达创建含义。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587709718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178151,"user_name":"Brian","can_delete":false,"product_type":"c1","uid":1057945,"ip_address":"","ucode":"4C930BF5051EE0","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/99/694d5ee7.jpg","comment_is_top":false,"comment_ctime":1581598438,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"113250748134","product_id":100039001,"comment_content":"一、三种工厂模式<br>  1. 简单工厂（Simple Factory）<br>    使用场景：<br>      a. 当每个对象的创建逻辑都比较简单的时候，将多个对象的创建逻辑放到一个工厂类中。<br>    实现：<br>      a. if else 创建不同的对象。<br>      b. 用单例模式 + 简单工厂模式结合来实现。<br>  2. 工厂方法（Factory Method）<br>    使用场景：<br>      a. 当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类时，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。<br>      b. 避免很多 if-else 分支逻辑时。<br>    实现：<br>      a. 定义相应的ParserFactory接口，每个工厂定义一个实现类。这种方式使用会有多个if else 让使用更加复杂。<br>      b. 创建工厂的工厂来，此方案可以解决上面的问题。<br>  3. 抽象工厂（Abstract Factory）- 不常用<br>    使用场景：<br>      a. 有多种分类方式，如方式要用一套工厂方法，方式二要用一套工厂方法，详见原文例子。<br>    实现：<br>      让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。<br><br>二、例子<br>  刚好最近有这方面的应用场景，主要使用了 单例模式 + 工厂模式 + 策略模式，用于解化多过的if else的复杂性。<br><br>public class OrderOperateStrategyFactory {<br>    &#47;**<br>     * 消费类型和策略对象映射。<br>     *&#47;<br>    private Map&lt;CheckoutType, OrderOperateStrategy&gt; map;<br><br>    &#47;**<br>     * 构造策略列表。<br>     *&#47;<br>    private OrderOperateStrategyFactory() {<br>        List&lt;OrderOperateStrategy&gt; list = new ArrayList&lt;&gt;();<br>        list.add(SpringContextHolder.getBean(ConsumptionOrderOperateStrategy.class));<br>        list.add(SpringContextHolder.getBean(GroupServiceOrderOperateStrategy.class));<br>        &#47;&#47;...<br>        map = list.stream().collect(Collectors.toMap(OrderOperateStrategy::getCheckoutType, v -&gt; v));<br>    }<br><br>    &#47;**<br>     * 通过消费类型获取订单操作策略。<br>     *<br>     * @param checkoutType 消费类型<br>     * @return 订单损我策略对象<br>     *&#47;<br>    public OrderOperateStrategy get(CheckoutType checkoutType) {<br>        return map.get(checkoutType);<br>    }<br><br>    &#47;**<br>     * 静态内部类单例对象。<br>     *&#47;<br>    private static class Holder {<br>        private static OrderOperateStrategyFactory INSTANCE = new OrderOperateStrategyFactory();<br>    }<br><br>    &#47;**<br>     * 获取订单操作策略工厂类实例。<br>     *<br>     * @return 单例实例。<br>     *&#47;<br>    public static OrderOperateStrategyFactory getInstance() {<br>        return Holder.INSTANCE;<br>    }<br>}  <br><br>使用：<br>OrderOperateStrategy strategy = OrderOperateStrategyFactory.getInstance().get(checkoutType);<br>strategy.complete(orderId);","like_count":26,"discussions":[{"author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245888,"discussion_content":"用Spring做策略，直接用beanName就行了，\b注解指定不同前缀的beanName，拿的时候拼一下beanName，从applicationContext直接getBean（beanName），就自然是一个工厂了，因为register动作spring已经帮你做了，所以你也不用map容器和单例了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587708673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1092169,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","nickname":"落尘kira","note":"","ucode":"D203B519E43F85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1541669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","nickname":"zhengyu.nie","note":"","ucode":"FFE0377D323E46","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":258199,"discussion_content":"工业写法，有一点需要补充的是在getBean外建议再封装一个get方法会更有利于代码可读性，也方便统一调用（除非你的同学真的不写硬编码）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588663513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":245888,"ip_address":""},"score":258199,"extra":""},{"author":{"id":2335869,"avatar":"https://static001.geekbang.org/account/avatar/00/23/a4/7d/19eb8409.jpg","nickname":"明石家秋刀鱼","note":"","ucode":"B0DAC2CFECE5C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1092169,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/49/51790edb.jpg","nickname":"落尘kira","note":"","ucode":"D203B519E43F85","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332812,"discussion_content":"map的这种还是getBean 是工业写法？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607345976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":258199,"ip_address":""},"score":332812,"extra":""}]}]},{"had_liked":false,"id":177900,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1581524479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"96070804991","product_id":100039001,"comment_content":"分歧：<br>1.文中说，创建对象不复杂的情况下用new，复杂的情况用工厂方法。这描述没问题，但工厂方法除了处理复杂对象创建这一职责，还有增加扩展点这优点。工厂方法，在可能有扩展需求，比如要加对象池，缓存，或其他业务需求时，可以提供扩展的地方。所以，除非明确确定该类只会有简单数据载体的职责（值对象），不然建议还是用工厂方法好点。new这种操作是没有扩展性的。<br><br>回答问题：<br>2.工厂方法要么归于类，要么归于实例。如果归于实例，那么第一个实例怎么来？而且实例创建出另一个实例，这种行为应该称为拷贝，或则拆分。是一个平级的复制或分裂的行为。而归于类，创建出实例，是一个父子关系，其创建的语义更强些。 <br>我认为不影响测试。因为工厂方法不该包含业务，它只是new的一种更好的写法。所以你只需要用它，而并不该需要测它。如果你的静态工厂方法都需要测试，那么说明你这个方法不够“干净”。","like_count":22},{"had_liked":false,"id":180840,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582426901,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"66006936341","product_id":100039001,"comment_content":"设计模式_44:<br># 作业<br>1. Android开发中工厂模式也很常用，比如`BitmapFactory`类；用工厂模式的原因是`Bitmap`对象的创建过程比较复杂，并且可以通过不同的方式来创建。<br><br>2. 查了一下资料，意识到这个问题的核心在于使用*静态工厂方法*替代的是使用构造函数，之所以用*静态方法*，是因为它比构造函数具有以下优势：<br>  (1) 构造函数的名字无意义，方法的名字包含更多有用信息<br>  (2) 构造函数只能返回当前Class类型对象，而方法可以返回当前类型对象、当前类型的子类对象，也可以返回基础数据类型<br>  (3) 如果创建过程很复杂，那么方法可以把很多不应该由构造函数处理的过程放在方法中，让构造函数只处理初始化成员的工作，职责更单一。<br>  (4) 方法可以控制生成对象的个数(单例，多例等)<br><br># 感想<br>看了今天的内容，突然有个疑问:<br>*static*方法可以是抽象方法吗？可以被继承吗？<br>验证了一下，发现 *static*方法可以被重写，*static* 与 *abstract* 是冲突的, 不能同时修饰一个方法；而且，如果用子类重写了父类的static方法，这时候让父类的引用指向子类对象，然后调用该*static*方法，这时调用的是父类的*static*方法，也就是不支持“多态”，这也解释了为什么*static* 与 *abstract*冲突。<br><br>关于第二题，直觉上来讲，如果不用静态方法就只能对对象方法，但使用对象方法的前提是有一个对象，但这个方法就是用来创建对象的，这时一个死锁。。。但显然问题的用意不是这个，于是查了资料。。。","like_count":15,"discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311878,"discussion_content":"调用方法的对象和方法返回的对象不是同一个类的对象，为什么会是死循环呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602510194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1447220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLia2EwyyEVs3tWRnMlqaAG7R7HvlW4vGvxthKsicgsCEeXO1qL7mMy6GAzgdkSKcH3c70Qa2hY3JLw/132","nickname":"沐夜星光","note":"","ucode":"22F699E237B179","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248465,"discussion_content":"第2点说的是，方法相对于构造函数的优势，问题的侧重点应该在于静态吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587872739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203159,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586145871,"is_pvip":false,"discussion_count":3,"race_medal":1,"score":"48830786127","product_id":100039001,"comment_content":"作者只会java，感觉讲起来有些晦涩。感觉没有讲清楚，什么叫工厂模式。何为工厂？作者在讲解每一个模式的时候，是不是应该解释一下，为什么起这个名字？不同的名字，肯定是具体描述的抽象。通过名字的由来，就能够明确其相关的区别。","like_count":11,"discussions":[{"author":{"id":2076251,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/5b/4bd42286.jpg","nickname":"宋计洋","note":"","ucode":"9A34E8F71C6CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559019,"discussion_content":"工厂就是汽车工厂生产汽车一样，制作各个零件，组装起来，产生一个汽车给你，在JAVA里面就是把一个对象的实例给你，同时也把他需要的参数、依赖的对象（也就是零件）给你装好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648563452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118111,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","nickname":"见南山","note":"","ucode":"6A8BB82B7573CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405785,"discussion_content":"工厂的作用就是创建一系列一样的对象啊。只不过代码中创建对象的逻辑非常简单而已，如果举一个非常复杂的创建对象的样例，会比较好理解吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634646271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384227,"discussion_content":"我还一直以为 既然叫工厂 那岂不是就认同了工厂就是来生产 很多一样的东西的，关键字 多 一样 ；结果 工厂模式只是封装了业务代码中用于生产实例的代码块。 那我觉得还不如叫做加工厂模式，而不是简单的工厂模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626432901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237072,"user_name":"Robin","can_delete":false,"product_type":"c1","uid":1316981,"ip_address":"","ucode":"64F61D5A02CA40","user_header":"https://static001.geekbang.org/account/avatar/00/14/18/75/d78f1441.jpg","comment_is_top":false,"comment_ctime":1595666707,"is_pvip":false,"replies":[{"id":"88026","content":"改动是不多呀������ 您有更好的设计思路建议吗？","user_name":"作者回复","comment_id":237072,"uid":"1190123","ip_address":"","utype":1,"ctime":1596111845,"user_name_real":"王争"}],"discussion_count":8,"race_medal":0,"score":"44545339667","product_id":100039001,"comment_content":"原文：简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果不是需要频繁地添加新的 parser，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。<br>原文：工厂方法：当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。代码的改动非常少，基本上符合开闭原则。<br>感觉说法有点牵强，添加一个类，简单工厂模式修改RuleConfigParserFactory， 工厂方法也要修改RuleConfigParserFactoryMap，也是会违背开闭原则。关键简单工厂模式(第二种方式)下添加的代码量一个是map.put,工厂方法也是一个map.put,然后说明工厂方法代码的改动非常少，基本上符合开闭原则？","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502297,"discussion_content":"改动是不多呀������ 您有更好的设计思路建议吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596111845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2036575,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/13/5f/03ae295c.jpg","nickname":"Geek_wandou","note":"","ucode":"F3706FA98DA632","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319743,"discussion_content":"赞同，改动是不多，但没看出来“工厂方法比简单工厂更符合开闭原则”体现在哪，需要添加一个新的类时，都是需要修改逻辑的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604110911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2085322,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/d1/ca/b537d120.jpg","nickname":"跳跳","note":"","ucode":"332AA758394E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297865,"discussion_content":"我对这点也有歧义，都是改动map，为什么还需要工厂模式呢 为什么不用简单工厂呢 工厂模式的可扩展就没有意义了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1597074693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358382,"discussion_content":"我也觉得这段有问题，从文章示例来看 没体现出工厂方法相对于简单工厂的优越性在哪里，反倒更复杂。\n\n我同意@Yeyw的看法，如果对象的创建初始化逻辑很复杂，用简单工厂的话，每个if/else下都会有一堆代码，但是如果用工厂方法，我们可以把这复杂的创建初始化对象逻辑封装到工厂类中，这样就达到了向用户隐藏具体的实例化细节的目的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615974979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1160678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/e6/c67f12bd.jpg","nickname":"左耳朵东","note":"","ucode":"60134ACF12BB52","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398414,"discussion_content":"我也觉得主要是因为例子中创建 XXXConfigParser 类的实例代码太简单了，只有一行 new 看不出区别，如果 new 之前还有大量的初始化代码，工厂方法和简单工厂（第二种方式）的区别就出来了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632791372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":358382,"ip_address":""},"score":398414,"extra":""}]},{"author":{"id":1463740,"avatar":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","nickname":"Yeyw","note":"","ucode":"C9D20DB91C3BE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357393,"discussion_content":"我觉得只是隐藏具体的创建实现，和简单工厂同样使用map可扩展参数","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615800127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1758349,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d4/8d/76667754.jpg","nickname":"circle。","note":"","ucode":"F42633FA7DBB80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325553,"discussion_content":"我以为只有我一个人有这疑惑呢…这也是我反复看了这一篇的原因。简单工厂第二种实现方式似乎比工厂方法改动量更少啊…都是需要改map，但是工厂方法还要新增类","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605345757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812221,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a6/fd/d7d18be3.jpg","nickname":"Francis℃","note":"","ucode":"9B02FAA3E4E6DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325976,"discussion_content":"我说下我这边的看法，如果结合spring的依赖注入来看，这个问题就很好解决了。RuleConfigParserFactoryMap可以注入所有parser factory 。这样，我们只需要新增parser factory 即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605492917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205096,"user_name":"Wh1","can_delete":false,"product_type":"c1","uid":1282715,"ip_address":"","ucode":"6D28506B99A285","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","comment_is_top":false,"comment_ctime":1586527565,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40241233229","product_id":100039001,"comment_content":"看到工厂方法模式，相信很多人会和我有一模一样的疑问：工厂方法模式不是一样存在if - else么，就算再通过一个工厂优化了if - else分支，与第二种简单工厂不是差不多么？<br>反复看了几遍理解类作者的意图。如果ConfigParser的实例创建不是简单的 new 这么简单，而是存在很多复杂的逻辑，那么简单工厂模式就不能通过直接put(newConfigParser())这种方式，必须通过 if else 语句块来完成获取解析器对象的逻辑。<br>如果要封装复杂的初始化逻辑，那么就可以通过工厂方法来重构。但是工厂方法重构之后会有很多if - else分支，这时候就可以再建立一个工厂将这些 if - else分支优化。<br>总而言之，如果创建对象是一个简单的new 就能完成的，那么毋庸置疑简单工厂更好一些。如果创建对象比较复杂，就采用工厂方法","like_count":9,"discussions":[{"author":{"id":2335869,"avatar":"https://static001.geekbang.org/account/avatar/00/23/a4/7d/19eb8409.jpg","nickname":"明石家秋刀鱼","note":"","ucode":"B0DAC2CFECE5C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332821,"discussion_content":"有这种疑问是因为作者全篇过于强调简单工厂模式带来的繁杂的ifelse问题，而引入工厂模式不仅仅是为了解决ifelse问题，还为了解决复杂对象的创建问题等。所以即使工厂方法模式不能解决ifelse或者是又包一层简单工厂来解决ifelse，也是可以接受的。也就是说都被作者的思路带偏了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607348272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210137,"user_name":"林子er","can_delete":false,"product_type":"c1","uid":1629256,"ip_address":"","ucode":"85637288F22CF0","user_header":"https://static001.geekbang.org/account/avatar/00/18/dc/48/9796286e.jpg","comment_is_top":false,"comment_ctime":1587690236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35947428604","product_id":100039001,"comment_content":"工厂方法和抽象工厂都是先定义工厂接口，由子类去创建实际的对象。不同点在于每个工厂方法只负责创建一种对象，解决的是一维问题，而抽象工厂一个工厂创建一簇对象（多种），解决的是多维问题（文章中是二维）。工厂方法是抽象工厂的一种特例。抽象工厂是采用降维的思想来解决复杂问题。","like_count":8},{"had_liked":false,"id":180482,"user_name":"乾坤瞬间","can_delete":false,"product_type":"c1","uid":1683130,"ip_address":"","ucode":"15BDCF29CBF8EB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","comment_is_top":false,"comment_ctime":1582293672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27352097448","product_id":100039001,"comment_content":"课后习题1，在spark livy框架中，有一个ClientFactory类，这个类根据用户的开发环境会设置成不同的客户端，一种是用来生产rpcClient客户端，一种是用来生产httpClient，每一种创建的逻辑和方式都非常复杂，会根据不同的参数生成Client,有些客户端会内置看门狗，以提高可用性，有些没有.所以应对这种创建的复杂性，使用了工厂模式，使用了工厂的工厂<br>习题2，个人认为这样的静态方法，第一与单例模式的思想不可分离，因为创建对象的抽象不需要通过创建一个新的类来实现，或者根据dry选择，用静态方法复用代码块的方式更加直接粗糙，简单美。我觉得在可测试方面是有影响的，不过因为这种简单的抽象是基于原有逻辑不存在未决行为的基础上的，而且对新增的代码有足够的信心<br>同时总结一下今天的三种工厂方法的演进<br>利用数学公式y≡f(x,x2)的角度，y是关于x x2的一个系统描述。<br>简单工厂只基于在系统y在不断加上x3的情况下，直接引入一个新的变量来简单替换f函数<br>工厂函数是在替换变量的基础上对x进行了再替换，使得系统更容易理解，y≡f(θ(x),θ(x2)...)形式<br>抽象方法是把x变量替换为δ(x,m)即，y≡f(δ(x,m)，δ(x2,m))形式","like_count":6},{"had_liked":false,"id":177646,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1581445948,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"27351249724","product_id":100039001,"comment_content":"对象每次都要重用，也可以用map缓存，不过value要改成全类名，通过反射来创建对象，这样每次都是一个新的类了，除非那个类被设计成禁止反射调用。","like_count":6,"discussions":[{"author":{"id":2853618,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/8a/f2/6c6f7886.jpg","nickname":"。。","note":"","ucode":"A52A6043D27D87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576888,"discussion_content":"大佬，有个地方不太明白，如果使用 map这种方式调用，有点类似于单例的味道了，全局唯一了。比如 map.get() 取到对象了，如果我通过 set() 来设置对象中属性的值，那么下次取这个对象的时候，这个属性值还是上次设置的，感觉不太好呢（单例里面也有这个问题）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655825183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812807,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg","nickname":"御风","note":"","ucode":"51C8212BE06364","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350539,"discussion_content":"map的value中为什么不直接new呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613909392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1272723,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/93/5ff6b668.jpg","nickname":"ori","note":"","ucode":"5F66BFF8C2AFC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298149,"discussion_content":"多此一举","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597204321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1272723,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/93/5ff6b668.jpg","nickname":"ori","note":"","ucode":"5F66BFF8C2AFC5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298276,"discussion_content":"是是是，您天下第一呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597233379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298149,"ip_address":""},"score":298276,"extra":""},{"author":{"id":1272723,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/93/5ff6b668.jpg","nickname":"ori","note":"","ucode":"5F66BFF8C2AFC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298381,"discussion_content":"可不么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597284357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298276,"ip_address":""},"score":298381,"extra":""},{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1272723,"avatar":"https://static001.geekbang.org/account/avatar/00/13/6b/93/5ff6b668.jpg","nickname":"ori","note":"","ucode":"5F66BFF8C2AFC5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298701,"discussion_content":"您的脑子也是多此一举","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597380222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298381,"ip_address":""},"score":298701,"extra":""}]},{"author":{"id":1737397,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/82/b5/a6049a26.jpg","nickname":"大强","note":"","ucode":"D5C64C5A01B25D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279269,"discussion_content":"？用反射，你是要写框架","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591318652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1737397,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/82/b5/a6049a26.jpg","nickname":"大强","note":"","ucode":"D5C64C5A01B25D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279312,"discussion_content":"你不用反射怎么让他是非单利对象？反射就一定是框架？嗯？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591322672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":279269,"ip_address":""},"score":279312,"extra":""}]},{"author":{"id":1618709,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b3/15/30822e33.jpg","nickname":"小麦","note":"","ucode":"2C800B598A2CDE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":199873,"discussion_content":"为什么要反射？反射的速度很慢的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583634468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1618709,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b3/15/30822e33.jpg","nickname":"小麦","note":"","ucode":"2C800B598A2CDE","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":200097,"discussion_content":"那不然你要怎么生成一个新的类？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583656762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":199873,"ip_address":""},"score":200097,"extra":""}]}]},{"had_liked":false,"id":242666,"user_name":"丹枫无迹","can_delete":false,"product_type":"c1","uid":1218765,"ip_address":"","ucode":"61A508C2464AF3","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/cd/d85c6361.jpg","comment_is_top":false,"comment_ctime":1597806361,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18777675545","product_id":100039001,"comment_content":"我一直不明白工厂方法模式存在的意义，除了争哥说的，当类的实例化比较复杂时每个类的实例化单独出来，简化代码。<br><br>工厂方法模式，RuleConfigSource 类中实例化工厂，再由工厂创建类，难道直接 new 个类不更简单吗？那就变成简单工厂模式了。。。工厂方法一样也破坏了开闭原则啊。<br><br>","like_count":4,"discussions":[{"author":{"id":2314948,"avatar":"","nickname":"小白","note":"","ucode":"ED798245A9B0CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":346512,"discussion_content":"为了遵循开闭原则吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611976874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2036575,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/13/5f/03ae295c.jpg","nickname":"Geek_wandou","note":"","ucode":"F3706FA98DA632","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319744,"discussion_content":"和简单工厂一样的，要添加一个新类时，简单工厂模式修改RuleConfigParserFactory， 工厂方法模式也要修改RuleConfigParserFactoryMap，也是会违背开闭原则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604111123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181841,"user_name":"攻城拔寨","can_delete":false,"product_type":"c1","uid":1053934,"ip_address":"","ucode":"CBC37183DAB6B2","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/ee/d72a8222.jpg","comment_is_top":false,"comment_ctime":1582642901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18762512085","product_id":100039001,"comment_content":"简单工厂：把 if-else 创建的代码放到另一个工厂类去实现，可用 map 的方式代替 if-else。<br><br>工厂方法：我觉得就是工厂的工厂～如果创建对象本身也比较复杂，不是一个 new 能解决的，那么可以用工厂方法，不然用简单工厂适合一些。<br><br>抽象工厂： 同个纬度，不同类型的对象能够用一个工厂来创建，此时就可以用抽象工厂。","like_count":4},{"had_liked":false,"id":177753,"user_name":"唐龙","can_delete":false,"product_type":"c1","uid":1471657,"ip_address":"","ucode":"87A10AE04F2037","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","comment_is_top":false,"comment_ctime":1581491316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18761360500","product_id":100039001,"comment_content":"试着把代码翻译成了C++语言，应该算是搞懂了(以前只会单例)。目前没写过特别复杂的项目，简单工厂对我个人来说够用了。","like_count":4},{"had_liked":false,"id":241584,"user_name":"杨鹏程baci","can_delete":false,"product_type":"c1","uid":1205949,"ip_address":"","ucode":"3D22F6B74340A8","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/bd/bd5d503e.jpg","comment_is_top":false,"comment_ctime":1597365402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14482267290","product_id":100039001,"comment_content":"看了很多回答，第2个问题我总感觉和大家理解的不太一样，我认为这个问题的关注点是创建对象的方法为啥是静态的。首先静态的使用更方便，可以不需要通过创建工厂类对象来调用创建对象的方法；第二点这种工具类没有其他面向对象的属性，只负责创建对象，也不需要严格通过对象来进行使用；第三点如果要创建工厂类的对象要么就会发生频繁创建和销毁对象，要么就有需要引入单例模式。用上原因通过类名来调用静态方法是最简单，最实用的方式，也符合简单原则。","like_count":3},{"had_liked":false,"id":180219,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1582211209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14467113097","product_id":100039001,"comment_content":"课堂讨论<br><br>1. 工厂模式是一种非常常用的设计模式，在很多开源项目、工具类中到处可见，比如 Java 中的 Calendar、DateFormat 类。除此之外，你还知道哪些用工厂模式实现类？可以留言说一说它们为什么要设计成工厂模式类？<br><br>   ​    在android开发网络请求类库Retrofit中, 可以通过添加Converter将json格式的数据转化为实体类. 例如,GsonConverterFactory通过继承自Converter.Factory的方式来实现将json通过Gson转化为Bean.<br><br>   <br><br>   ​    这里ConverterFactory设计为工厂模式主要是为了衍生类自己实现Factory接口的方法,并且可以为Retrofit实例添加多个ConverterFactory.<br><br>   <br><br>2. 实际上，简单工厂模式还叫作静态工厂方法模式（Static Factory Method Pattern）。之所以叫静态工厂方法模式，是因为其中创建对象的方法是静态的。那为什么要设置成静态的呢？设置成静态的，在使用的时候，是否会影响到代码的可测试性呢？<br><br>   ​    若创建对象的方法不设置为静态的, 需要new工厂对象, 才能使用工厂对象创建产品对象. 还不如直接new产品对象. 考虑到简单工厂的业务比较简单, 对测试性的影响较小.","like_count":3},{"had_liked":false,"id":177739,"user_name":"勤劳的明酱","can_delete":false,"product_type":"c1","uid":1259140,"ip_address":"","ucode":"05EBE89B80371B","user_header":"https://static001.geekbang.org/account/avatar/00/13/36/84/788f0c60.jpg","comment_is_top":false,"comment_ctime":1581487400,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14466389288","product_id":100039001,"comment_content":"那Spring的BeanFactory实际上使用的是简单工厂模式 + 单例模式对吧，如果是工厂模式那就是使用ObjectFactory和FactoryBean来实现。第三方的复杂bean的初始化使用工厂模式，对于普通的bean统一处理，虽然复杂但没必要使用工厂。","like_count":3,"discussions":[{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341208,"discussion_content":"有问题吧， 工厂模式关注的是对象的创建， ObjectFactory 是对象查找","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610351205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274089,"user_name":"胡杨林","can_delete":false,"product_type":"c1","uid":2367034,"ip_address":"","ucode":"2BD561DB35050C","user_header":"https://static001.geekbang.org/account/avatar/00/24/1e/3a/a671f5c7.jpg","comment_is_top":false,"comment_ctime":1610847743,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10200782335","product_id":100039001,"comment_content":"感觉抽象工厂方法与工厂方法一样。为什么要分成俩说呢？","like_count":2},{"had_liked":false,"id":257970,"user_name":"Tomy","can_delete":false,"product_type":"c1","uid":1192601,"ip_address":"","ucode":"D7E49E90B0D60F","user_header":"https://static001.geekbang.org/account/avatar/00/12/32/99/91b58bf7.jpg","comment_is_top":false,"comment_ctime":1604228206,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10194162798","product_id":100039001,"comment_content":"整个内容没有看懂RuleConfigParser这个类好像始终没有用到，跟这个类是什么关系IRuleConfigParser，把老师的代码复制到IDEA，跟着一步一步实现，发现类和接口太多了，<br>老师能否把整个一步一步迭代重构的代码放到github。","like_count":2},{"had_liked":false,"id":225178,"user_name":"宁悦","can_delete":false,"product_type":"c1","uid":1901403,"ip_address":"","ucode":"68844C314FEEF8","user_header":"https://static001.geekbang.org/account/avatar/00/1d/03/5b/3cdbc9fa.jpg","comment_is_top":false,"comment_ctime":1591674555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10181609147","product_id":100039001,"comment_content":"应用场景：根据 .json .xml .yaml后缀选择不同的解析器。生产不同对象。<br><br>   实现方式1.0：<br>        直接if-else判断，生成不同的解析器。过多的if-else判断，为了代码可读性，将代码封装到一个类中形成2.0方式。<br><br>   实现方式2.0：<br>         逻辑过于复杂抽象到一个类中，形成简单工厂模式。<br><br>         简单工厂：<br>             定义一个接口，不同的解析器继承这个接口，在Factory里面创建对象。<br>             把所有的判断逻辑都放在了Factory里面，<br><br>         每次新增后缀名，都需要修改if-else语句，为了不修改if-else语句，不违反开放-关闭规则，引入工厂方法。<br>   <br>   实现方式3.0<br>         工厂方法：<br>             把所有的if-eLse，利用多态方式解耦。<br>             首先创建工厂接口，然后创建工厂实现类，引用产品接口<br>             创建产品接口，创建产品实现类。<br><br>         每次新增需求，都要多写工厂类，避免过的的编写工厂类，引入抽象工厂方法。<br>   <br>   实现方式4.0<br>        抽象工厂方法：<br>            一个工厂生产多个产品。","like_count":2},{"had_liked":false,"id":196878,"user_name":"阿德","can_delete":false,"product_type":"c1","uid":1602420,"ip_address":"","ucode":"186D5E19E3CB6E","user_header":"https://static001.geekbang.org/account/avatar/00/18/73/74/3bf4b74e.jpg","comment_is_top":false,"comment_ctime":1585320263,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175254855","product_id":100039001,"comment_content":"在阐述工  厂方法（Factory Method）的第一段-----“ 如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态。按照多态的实现思路，对上面的代码进行重构”，然后铮哥下面的工厂方法还是用到了跟简单工厂方法一样的多态和if else，，，看不出有代码实现原理上什么不同","like_count":2},{"had_liked":false,"id":292964,"user_name":"云淡风轻","can_delete":false,"product_type":"c1","uid":1121817,"ip_address":"","ucode":"D6903A0FCEBC58","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/19/a235f31d.jpg","comment_is_top":false,"comment_ctime":1621118703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5916085999","product_id":100039001,"comment_content":"工厂模式的三种我理解是重构的几个阶段。<br>1、最开始，对象创建直接使用if-else<br>2、if分支太多，将代码重构都简单工厂类中<br>3、如果对象创建逻辑复杂，代码量大，可以使用工厂方法进行拆分<br>4、如果工厂类膨胀太快，过多，可以使用抽象工厂将部分工厂组合起来使用","like_count":1},{"had_liked":false,"id":271743,"user_name":"陈桂章","can_delete":false,"product_type":"c1","uid":1500789,"ip_address":"","ucode":"8A938BB95E6D5A","user_header":"https://static001.geekbang.org/account/avatar/00/16/e6/75/67147342.jpg","comment_is_top":false,"comment_ctime":1609773470,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5904740766","product_id":100039001,"comment_content":"我一直理解的工厂方法是有一个“大工厂”以及一堆“小工厂”，在客户端（也就是文中的RuleConfigSource类）先进行“大工厂”（RuleConfigParserFactoryMap）的创建，然后继续进行其他需要用到的“小工厂”的创建，也就是说由使用者自行判断使用的“小工厂”，后续拓展只需要动态添加“小工厂”即可<br>萌新一个，希望能帮忙解惑","like_count":1,"discussions":[{"author":{"id":1577210,"avatar":"https://static001.geekbang.org/account/avatar/00/18/10/fa/d977627e.jpg","nickname":"刘大人","note":"","ucode":"F66AE613E80398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344470,"discussion_content":"大工厂 里面还是要增加 新的if else ， 所以作者说的去掉if  else  只是使用了map，和工厂方法 没啥关系吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611471687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261923,"user_name":"郑大钱","can_delete":false,"product_type":"c1","uid":1503067,"ip_address":"","ucode":"114CF48056880E","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","comment_is_top":false,"comment_ctime":1605580199,"is_pvip":false,"replies":[{"id":"96130","content":"������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701238,"ip_address":"","comment_id":261923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5900547495","product_id":100039001,"comment_content":"传统的工厂模式确实很传统。<br>简单工厂是在一个工厂方法里通过流程控制语句创建不同的对象，适合创建简单的对象。<br>工厂方法和简单方法没有什么区别，只是用工厂对象再此封装了复杂对象的创建。工厂的工厂负责调用工厂的创建方法，每个工厂只创建一个对象，适合创建复杂的对象。<br>工厂模式是对创建方法的封装和抽象，创建的复杂度无法被抵消，只能被转移到工厂内部消化。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509667,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701238,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241059,"user_name":"Geek_0a4616","can_delete":false,"product_type":"c1","uid":1670730,"ip_address":"","ucode":"9C37ED61ECCAC2","user_header":"","comment_is_top":false,"comment_ctime":1597162100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892129396","product_id":100039001,"comment_content":"简单工厂 解决对象创建和业务代码分离<br>工厂模式 解决复杂创建过程从简单工厂的if esle中分离<br>抽象工厂 解决工厂过多，一类相关产品可以放到同一工厂创建。","like_count":1},{"had_liked":false,"id":193707,"user_name":"杰洛特","can_delete":false,"product_type":"c1","uid":1098146,"ip_address":"","ucode":"46D0574654F8AC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqEacia8yO1dR5Tal9B7w8PzTRrViajlAvDph96OqcuBGe29icbXOibhibGmaBcO7BfpVia0Y8ksZwsuAYQ/132","comment_is_top":false,"comment_ctime":1584951385,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879918681","product_id":100039001,"comment_content":"关于简单工厂还是工厂方法模式选择这块，老师您提到“如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。”但是，这个工厂方法模式里面后面还要创建工厂的工厂，工厂的工厂里面不也会遇到需要烦人的 if-else 分支逻辑吗？","like_count":1},{"had_liked":false,"id":190005,"user_name":"88591","can_delete":false,"product_type":"c1","uid":1254656,"ip_address":"","ucode":"04CE3E46455185","user_header":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","comment_is_top":false,"comment_ctime":1584591075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879558371","product_id":100039001,"comment_content":"以前看设计模式，就想把代码记下来。照着做，现在看设计模式，想的是我能不能想到这样的设计思路。<br>照做的阶段，代码没有出现大的问题，因为都是站在前人肩膀上面。殊不知前人踩过的坑。就像买东西，选东西，大家都是说好。那多半就错不了，减少了深入分析的过程，也相当于提升了效率吧。现在知道为啥好，要对自己好的东西才是真的好。","like_count":1},{"had_liked":false,"id":189681,"user_name":"苗","can_delete":false,"product_type":"c1","uid":1088710,"ip_address":"","ucode":"5ECCC6C855E541","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","comment_is_top":false,"comment_ctime":1584540411,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879507707","product_id":100039001,"comment_content":"我有点疑问，例子中工厂构造的对象都是使用的默认构造函数；如果需要传入构造参数，那是不是就不适合使用工厂了，因为工厂生产出来的都是一模一样的对象。","like_count":1,"discussions":[{"author":{"id":1337949,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/5d/2a7604e5.jpg","nickname":"暮鼓晨钟","note":"","ucode":"582F3AC92A0FCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261594,"discussion_content":"这种情况选择建造者模式来创建对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588985768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183275,"user_name":"雷刚","can_delete":false,"product_type":"c1","uid":1655725,"ip_address":"","ucode":"115FE2BE1AAB61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pTD8nS0SsORKiaRD3wB0NK9Bpd0wFnPWtYLPfBRBhvZ68iaJErMlM2NNSeEibwQfY7GReILSIYZXfT9o8iaicibcyw3g/132","comment_is_top":false,"comment_ctime":1582985368,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5877952664","product_id":100039001,"comment_content":"作业1：JDK 中 URLStreamHandlerFactory 设计成工厂方法，用于创建 URL 对应协议的处理器 URLStreamHandler，可以很方便的扩展 url 协议。<br>作业2：个人认为不影响测试。首先简单工厂创建对象，方法一般都非常简单，测试时传入对应的参数创建对象，结果是确定的，就像精通工具类一样测试就好。如果对象创建比较复杂，则会选择工厂方法或抽象工厂方法了。","like_count":1,"discussions":[{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200958,"discussion_content":"赞同你的回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583747090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177738,"user_name":"SKY","can_delete":false,"product_type":"c1","uid":1083870,"ip_address":"","ucode":"10C3CB831974AE","user_header":"https://static001.geekbang.org/account/avatar/00/10/89/de/7bf4c3a3.jpg","comment_is_top":false,"comment_ctime":1581487255,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5876454551","product_id":100039001,"comment_content":"不理解“如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用多态“，但是最后给出的load() 函数依然if..else（）没有体现出利用多态去掉if分支","like_count":1,"discussions":[{"author":{"id":1457464,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3d/38/6f02a4b9.jpg","nickname":"your problem？","note":"","ucode":"6E096E7958CFD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168141,"discussion_content":"没有啊，最后的load函数没有用if else ，用的是简单工厂，通过Map存储去获取对应解析器对象啊，个人理解，程序设计是不能改变业务的本质的，例如你要通过文件后缀去生成不同的对象，这本身就是个分支业务，无论你怎么设计，最终都是要分支的，那这里的工厂的意义在于，将复杂对象组装及生成过程，封装起来，使调用者可以简单获取对象，降低耦合，假如在未来新增了解析器，只需要修改简单工厂，添加新的解析对象即可，不影响原来的调用逻辑，假如你觉得静态块中手动put存储的方式还是死板，你可以通过读取配置文件的方式加载相应map，你只需要改动配置文件，新增解析类即可，不用动其他代码","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581558134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1083870,"avatar":"https://static001.geekbang.org/account/avatar/00/10/89/de/7bf4c3a3.jpg","nickname":"SKY","note":"","ucode":"10C3CB831974AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":169805,"discussion_content":"通过Map存储去获取对应解析器对象，这个确实可以避免if else，但是如果新添加一个解析器，使用简单工厂是添加一个ConfigParser类，在put中新加一个new ConfigParser()，工厂模式是实现一个IRuleConfigParserFactory，也是在put中加一个new  XXConfigParserFactory()。不知到多态在里面起啥作用？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581646768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1282715,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/9b/65f98192.jpg","nickname":"Wh1","note":"","ucode":"6D28506B99A285","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1083870,"avatar":"https://static001.geekbang.org/account/avatar/00/10/89/de/7bf4c3a3.jpg","nickname":"SKY","note":"","ucode":"10C3CB831974AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":228084,"discussion_content":"老兄，这里我一开始也和你一模一样的疑问，反复看了几遍理解类作者的意图。如果ConfigParser的实例创建不是简单的 new 这么简单，而是存在很多复杂的逻辑，那么简单工厂模式就不能通过直接put(newConfigParser())这种方式，必须通过 if else 语句块来完成获取解析器对象的逻辑。\n如果要封装复杂的初始化逻辑，那么就可以通过工厂方法来重构。但是工厂方法重构之后会有很多if - else分支，这时候就可以再建立一个工厂将这些 if - else的分支通过简单工厂的思路来优化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586525421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":169805,"ip_address":""},"score":228084,"extra":""}]}]},{"had_liked":false,"id":177712,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1581478573,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5876445869","product_id":100039001,"comment_content":"java.text.NumberFormat是使用工厂模式实现的，它可以根据特定的区域设置格式化数字，这个类设置成工厂模式是因为全世界有很多不同的区域，有很多不同的数字表示法，所有从开闭原则角度，用工厂模式实现可以方便的增加对不同区域数字转换的支持。<br>使用静态方法创建对象首先可以使得创建对象的方法名字更有意义，使用者看到方法名就知道什么意思了，提高了代码的可读性。其次使用静态方法创建对象可以重复使用事先创建好的对象，最后使用静态工厂方法可以返回原返回类型的任何子类对象，更灵活。使用Calander#getInstance， NumberFormat这种工具类的静态工厂方法一般是不会影响到可测试性的, 另外使用文中Parser的例子的静态方法也不会有影响，暂时没想到会有影响的例子。 ","like_count":1},{"had_liked":false,"id":177675,"user_name":"迷羊","can_delete":false,"product_type":"c1","uid":1286251,"ip_address":"","ucode":"85AF8CED3436C8","user_header":"https://static001.geekbang.org/account/avatar/00/13/a0/6b/0a21b2b8.jpg","comment_is_top":false,"comment_ctime":1581471830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876439126","product_id":100039001,"comment_content":"抽象工厂还可以这样拆分：RuleConfigParserFactory和SystemConfigParserFactory，这样一个工厂可以创建4种类型的parser，而且之后添加parser也不会增加太多类。","like_count":1},{"had_liked":false,"id":177661,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1581467321,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5876434617","product_id":100039001,"comment_content":"老师最好提供你讲课例子代码完整的版本，结合你讲的内容消化理解😊","like_count":1,"discussions":[{"author":{"id":1438860,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","nickname":"子房","note":"","ucode":"CB05938C248BB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341212,"discussion_content":"黄土高原","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610351833,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048887,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","nickname":"高源","note":"","ucode":"751B41FD38EF7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167379,"discussion_content":"吉林高原，😀️","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581484399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":167327,"discussion_content":"陕西高源吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581477922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360717,"user_name":"Null","can_delete":false,"product_type":"c1","uid":1382587,"ip_address":"北京","ucode":"A7D4DF2A43C7D8","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/bb/9299fab1.jpg","comment_is_top":false,"comment_ctime":1666777655,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1666777655","product_id":100039001,"comment_content":"感觉这块可以看HEAD FIRST 设计模式，里面讲的很清楚。简单说 多个工厂，每个Factory 服从N个协议，可以创建一类对象（抽象工厂）， 多个工厂，但是工厂与对象一对一（工厂方法），一个工厂可以搞定（简单工厂）","like_count":0},{"had_liked":false,"id":344663,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1651716495,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1651716495","product_id":100039001,"comment_content":"「对调用者透明」，请问一下“透明”是什么意思呢？是用户看不见底层实现，也不需要看见底层实现的意思吗？","like_count":0},{"had_liked":false,"id":344556,"user_name":"Geek_7e0e83","can_delete":false,"product_type":"c1","uid":2142423,"ip_address":"","ucode":"554DEE2AAAE33C","user_header":"","comment_is_top":false,"comment_ctime":1651647836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651647836","product_id":100039001,"comment_content":"Bean对象的反序列化工厂类，BeanDeserializerFactory。创建的目的是隔离Bean反序列的操作对象的创建过程。让Bean的反序列化过程更加清晰。<br><br>设置成静态方法，那么创建对象的时候就不要实例化工厂对象。每次创建对象如果也要同样的创建一个工厂类那么会浪费内存资源。不会影响代码的可测试性，工厂类的中创建对象的逻辑很简单，只有一点点的代码。如果需要测试，也可以把工厂类设计成单例类。也可以避免不必要的工厂对象的创建","like_count":0},{"had_liked":false,"id":344475,"user_name":"Geek_508ed0","can_delete":false,"product_type":"c1","uid":2827475,"ip_address":"","ucode":"203310D61146D2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/4mkwAC73EZtVJcCibyLCv8qmibK4poia8aCWpTib1tc62UBQLttlVopm4dKDhsSMPHyPJiasgLquJTYIibsX1UtaTzsw/132","comment_is_top":false,"comment_ctime":1651575968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651575968","product_id":100039001,"comment_content":"感觉if到map的更改不仅仅是把if去掉了，换成map之后可操作性更大，比如可以扫包注入到map中，这样也可以满足开闭原则","like_count":0,"discussions":[{"author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94216,"discussion_content":"这样有观点有科普还有原文引用的评论真优秀👍","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1576942119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94409,"discussion_content":"多谢鼓励！我会继续加油的！UncleBob真是提概念的好手！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1576943509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":94216,"ip_address":""},"score":94409,"extra":""},{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":278155,"discussion_content":"请问UncleBob是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591155848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":94409,"ip_address":""},"score":278155,"extra":""},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":335076,"discussion_content":"Uncle Bob是Robert C. Martin的昵称，不是Martin Fowler","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1608085905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":94409,"ip_address":""},"score":335076,"extra":""}]},{"author":{"id":1947612,"avatar":"","nickname":"tm1234","note":"","ucode":"4042321C713186","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257495,"discussion_content":"所以很多程序员干了几年，仅仅就会写CURD.. 真相了","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1588577450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1803259,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/83/fb/621adceb.jpg","nickname":"linker","note":"","ucode":"6C5799F2FC2C82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145172,"discussion_content":"本人了解面向过程的c语言。\n1:封装，在一个文件中定义变量为static，而把修改变量的函数对外开放，设为extern\n2:抽象，函数本身就是带走抽象的意思，在c语言头文件中，对外开放的函数头就是抽象。\n3:继承，定义一个结构体带函数指针与数据，然后把这个结构体嵌入到其他结构体中，模仿了组合概念，应该不是抽象。\n4:多态，函数指针实现多态。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1579537526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1904140,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/0e/0c/4ec2075f.jpg","nickname":"薛定谔的疯兔子","note":"","ucode":"BEF678D50400F5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394852,"discussion_content":"我觉得还有很大一个原因是，开发节奏太快，需求过来就要马上实现，开发人员都没有时间去沉淀思考，久而久之建立贫血模型就成了大家的习惯了。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1632102764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048681,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/69/3b1375ca.jpg","nickname":"海拉鲁","note":"","ucode":"6E3493295CED6F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203777,"discussion_content":"赞同。从实用性的角度看，无论贫血模型还是充血模型，还是要因地制宜，不要太本本主义","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584079872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503067,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ef/5b/ff28088f.jpg","nickname":"郑大钱","note":"","ucode":"114CF48056880E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299526,"discussion_content":"个人感觉“贫血模型”给我带来的最大的好处是易测试","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597722461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245706,"discussion_content":"当下管用模型就是好模型","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587693452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063308,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","nickname":"小乙哥","note":"","ucode":"C77E79BEA0C325","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":56092,"discussion_content":"优秀","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574431700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3017263,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/0a/2f/477f02d1.jpg","nickname":"Playmaker","note":"","ucode":"48652E8135B54B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589110,"discussion_content":"一语惊醒梦中人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664424373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国香港"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149402,"avatar":"https://static001.geekbang.org/account/avatar/00/11/89/da/136cdca6.jpg","nickname":"陈斌","note":"","ucode":"AD6933D125C930","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582716,"discussion_content":"我觉得贫血模型就像需要填数据的表格，很多类定义只是为了定义数据传输对象的格式，不一定需要包含行为。所以也不能说贫血模型就不好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659603843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605058,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","nickname":"东方拓睿","note":"","ucode":"1FD25D75CAC7C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575950,"discussion_content":"很认同，现在的框架鼓励程序猿这样做，比如spring体系，大家只要在service.层写好业务逻辑就好了，其他的交给依赖注入吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655205542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207410,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXSb2jAzlMM0JdTjWrNiaq2uR9eeloBYp906POddb9evmuj5f4CUoO6ge8TibibwtZicnl1sRHic9rW7g/132","nickname":"紫日","note":"","ucode":"73A8DEE323AC19","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316674,"discussion_content":"符合人类直觉思维。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603438703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1322366,"avatar":"https://static001.geekbang.org/account/avatar/00/14/2d/7e/335a9b9d.jpg","nickname":"🐝null","note":"","ucode":"16F5E4965F8D5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":313208,"discussion_content":"习惯成自然","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603000195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1302911,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e1/7f/9e36154f.jpg","nickname":"黄晓辉","note":"","ucode":"7C20BDFC46DE7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":83413,"discussion_content":"谢谢科普","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576423598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740639,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8f/5f/c6d10aa8.jpg","nickname":"码弓手","note":"","ucode":"B5D1EC8424B5D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68231,"discussion_content":"如果是业务性不强用贫血确实很好，否则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575206824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178156,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fa/2c/9a0c45e6.jpg","nickname":"微凉","note":"","ucode":"F6BD0AE11AE224","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54067,"discussion_content":"学习了，谢谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574256826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53180,"discussion_content":"优秀","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574142168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52378,"discussion_content":"学习了，我好好看看这文章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574045506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":72781,"discussion_content":"先看评论再看文章的吗 😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575526816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52378,"ip_address":""},"score":72781,"extra":""},{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72986,"discussion_content":"看这篇文章的时候，看到一半，刚好来了一个需求，就先看了评论，回头把剩下的看了。哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1575547157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":72781,"ip_address":""},"score":72986,"extra":""}]}]},{"had_liked":false,"id":343599,"user_name":"恬毅","can_delete":false,"product_type":"c1","uid":1015240,"ip_address":"","ucode":"914ED16F3BE714","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/c8/e4727683.jpg","comment_is_top":false,"comment_ctime":1650947776,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650947776","product_id":100039001,"comment_content":"工厂模式的例子：Executors<br><br>为什么设置成静态的？","like_count":0},{"had_liked":false,"id":339059,"user_name":"夏天","can_delete":false,"product_type":"c1","uid":1285986,"ip_address":"","ucode":"F29D56F9265751","user_header":"https://static001.geekbang.org/account/avatar/00/13/9f/62/960eecc3.jpg","comment_is_top":false,"comment_ctime":1647875111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647875111","product_id":100039001,"comment_content":"mybatis 框架中 日志模块使用了工厂模式","like_count":0},{"had_liked":false,"id":330698,"user_name":"theory18","can_delete":false,"product_type":"c1","uid":1339502,"ip_address":"","ucode":"F3C96051F563F8","user_header":"https://static001.geekbang.org/account/avatar/00/14/70/6e/8f9d9fe9.jpg","comment_is_top":false,"comment_ctime":1642124291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642124291","product_id":100039001,"comment_content":"Java线程池ThreadFactory使用了工厂方法模式，支持用户灵活扩展","like_count":0},{"had_liked":false,"id":328500,"user_name":"Geek_East","can_delete":false,"product_type":"c1","uid":1589947,"ip_address":"","ucode":"A1A7CBF9B8FB2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","comment_is_top":false,"comment_ctime":1640755006,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1640755006","product_id":100039001,"comment_content":"无论是那种工厂模式，最终目的都是将对象创建的复杂过程进行封装, 符合单一职能原则、变化隔离原则，最终能够提高代码的可拓展性. 但是, if-else 对标多态并不妥当，多态更多地是配合依赖反转原则，降低具体类之间的依赖程度，保证对象传值时的灵活性。if-else真正应该对标的是key-value形式的HashMap. ","like_count":0},{"had_liked":false,"id":323613,"user_name":"Z宇锤锤","can_delete":false,"product_type":"c1","uid":2188142,"ip_address":"","ucode":"7DB36E986A7A51","user_header":"https://static001.geekbang.org/account/avatar/00/21/63/6e/6b971571.jpg","comment_is_top":false,"comment_ctime":1638021074,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638021074","product_id":100039001,"comment_content":"0.10.1版本Kafka中定义了CompressionFactory用来选择数据的压缩格式。设计成工厂模式的优点就是在选择数据的压缩方式根据压缩类型传入参数就可以，简化了使用方对压缩格式的选择。","like_count":0},{"had_liked":false,"id":323259,"user_name":"Wheat","can_delete":false,"product_type":"c1","uid":1260141,"ip_address":"","ucode":"7D99EA149B6DE8","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6d/910b2445.jpg","comment_is_top":false,"comment_ctime":1637805785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637805785","product_id":100039001,"comment_content":"表面上简单工厂足够用，实际上工厂方法把每个bean的构建都拆出来用对应的工厂单独维护，而非通过使用复杂的bean的构造函数，这样的好处是降低了构造函数与入参的耦合性","like_count":0},{"had_liked":false,"id":320437,"user_name":"凡","can_delete":false,"product_type":"c1","uid":1041878,"ip_address":"","ucode":"BCF83BE1D434D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/d6/37a1be71.jpg","comment_is_top":false,"comment_ctime":1636332718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636332718","product_id":100039001,"comment_content":"工厂方法一开始就生成对应的对象。那如果用不上，岂不是浪费内存？","like_count":0},{"had_liked":false,"id":319760,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1635931514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635931514","product_id":100039001,"comment_content":"总结<br>1、简单工厂（Simple Factory）<br>\t也叫静态工厂<br>\t把创建对象的部分抽离出来，或可新建Factory类，逻辑简单的可以满足<br>2、工厂方法（Factory Method）<br>\t工厂方法模式比起简单工厂模式更加符合开闭原则。<br>\t可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。<br>\t逻辑简单只是简单的new下可以用哦简单工厂，如果new对象过程复杂则可以用工厂方法<br>3、抽象工厂（Abstract Factory）<br>\t上面2个工厂模式能解决单一的工厂类型生产对象，如果要多种类型工厂则用抽象工厂。详情看课程例子<br>\t没有上面2种常用<br>4、要不要使用工厂模式的最本质的参考标准<br>\t封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。<br>\t代码复用：创建代码抽离到独立的工厂类之后可以复用。<br>\t隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。<br>\t控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。<br>复杂度无法被消除，只能被转移<br>工厂本身的重点不是解决if else 而是解决简单工厂的开闭原则，大家都在重点讨论if else 即使被省略了 也是map的功劳","like_count":0},{"had_liked":false,"id":318306,"user_name":"Geek_Littlelolo","can_delete":false,"product_type":"c1","uid":2051588,"ip_address":"","ucode":"E0AFD17D91D9EC","user_header":"","comment_is_top":false,"comment_ctime":1635237099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635237099","product_id":100039001,"comment_content":"new 对象: 包工头接了一项任务,对任务出现的各种情况,亲自安排协调不同的人员,然后进行处理.<br>简单工厂:  包工头感觉自己作为扛把子的,财大气粗,亲自协调人员有失身份,协调安排人员这个事情应该独立出去,自己最后见到这个人就行了,不关心这个人是谁,只要能做好这件事就可以了,于是找个人才市场,根据包工头的需求,人才市场提供不同的人员.<br>工厂方法: 人才市场发现,包工头要找的人才具备的技能比较多,太麻烦了,于是把这个找人的任务,根据需求的不同有分发给了各个分部市场,最终由各个分部,经过一系列的复杂的操作,确定最终的人选,执行此项任务.","like_count":0},{"had_liked":false,"id":317065,"user_name":"Molyt","can_delete":false,"product_type":"c1","uid":2283490,"ip_address":"","ucode":"9CCF7A18B2C547","user_header":"https://static001.geekbang.org/account/avatar/00/22/d7/e2/5e5cc8f3.jpg","comment_is_top":false,"comment_ctime":1634655107,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1634655107","product_id":100039001,"comment_content":"“如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式“。不可复用不是得每次new 一个对象吗，没法放在map里面，这样不是得用if-else判断吗","like_count":0},{"had_liked":false,"id":316829,"user_name":"直走的螃蟹","can_delete":false,"product_type":"c1","uid":2683294,"ip_address":"","ucode":"8116812CF0A1F2","user_header":"","comment_is_top":false,"comment_ctime":1634561579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634561579","product_id":100039001,"comment_content":"如果多个if语句都是简单的字符串判断，采用Map的方式就可以更加简化代码，不过在阅读性上可能有所减弱。","like_count":0},{"had_liked":false,"id":313630,"user_name":"云淡风轻","can_delete":false,"product_type":"c1","uid":1373334,"ip_address":"","ucode":"DE5A3565F001E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/f4/96/94985c6b.jpg","comment_is_top":false,"comment_ctime":1632570955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632570955","product_id":100039001,"comment_content":"感觉工厂方法模式和抽象工厂模式区别就是一个是创建一个工厂，一个创建多个工厂。","like_count":0},{"had_liked":false,"id":312858,"user_name":"Geek_32cca0","can_delete":false,"product_type":"c1","uid":2743957,"ip_address":"","ucode":"A24204F2C0485E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJF8vUICSb6yEleDjtsTe8OrwqmpaoxlicHB7NutCwMMs5ZvsQrguEJ3VL0x5I85jS6xlbrWcMdWKA/132","comment_is_top":false,"comment_ctime":1632062309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632062309","product_id":100039001,"comment_content":"使用工厂方法避免静态工厂没有遵守开闭原则，感觉说服力不是特别强。","like_count":0},{"had_liked":false,"id":312347,"user_name":"征","can_delete":false,"product_type":"c1","uid":1592863,"ip_address":"","ucode":"A1B11446D28836","user_header":"https://static001.geekbang.org/account/avatar/00/18/4e/1f/c6fd287e.jpg","comment_is_top":false,"comment_ctime":1631762486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631762486","product_id":100039001,"comment_content":"当类的代码量不大时，可以在当前类中把对象的创建逻辑封装成函数；当类的代码量膨胀到一定程度时，可以把对象的创建函数转移到工厂类中，这样业务类中的代码逻辑更加清晰，可读性更好。","like_count":0},{"had_liked":false,"id":307646,"user_name":"Geek_b7eb88","can_delete":false,"product_type":"c1","uid":1573715,"ip_address":"","ucode":"0EB46381D9B1CB","user_header":"","comment_is_top":false,"comment_ctime":1629188930,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629188930","product_id":100039001,"comment_content":"抽象工厂不就是在工厂方法的接口类中，加了另一个方法，让其他继承接口的工厂类再实现另一个创建方法吗？还是我理解错了？","like_count":0},{"had_liked":false,"id":307345,"user_name":"Fwwwddd","can_delete":false,"product_type":"c1","uid":1493914,"ip_address":"","ucode":"8ADACF48E1041A","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/9a/9d822800.jpg","comment_is_top":false,"comment_ctime":1629037152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629037152","product_id":100039001,"comment_content":"文中讲的工厂方法模式，对工厂进行了抽象，这个不是抽象工厂吗？不太理解","like_count":0},{"had_liked":false,"id":306332,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1628501126,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1628501126","product_id":100039001,"comment_content":"对于抽象工厂扩展性更强，也没有多几个类，为何不那么常用呢？","like_count":0},{"had_liked":false,"id":297819,"user_name":"Geek_5b7d28","can_delete":false,"product_type":"c1","uid":2057476,"ip_address":"","ucode":"BAA1CDD539C369","user_header":"","comment_is_top":false,"comment_ctime":1623802631,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623802631","product_id":100039001,"comment_content":"课堂讨论<br>        我认为工厂方法本质上属于工具类，是一个创建对象的工具类，而且本身没有属性可维护。并且工具类一般使用频繁，会伴随整个项目运行周期，因此设计成了静态方便使用。<br>","like_count":0},{"had_liked":false,"id":295981,"user_name":"JKwar","can_delete":false,"product_type":"c1","uid":1047466,"ip_address":"","ucode":"B733CA24D5701F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/aa/01fedf6c.jpg","comment_is_top":false,"comment_ctime":1622689822,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1622689822","product_id":100039001,"comment_content":"课堂讨论1：Java 的 Executors 线程池。因为线程池创建逻辑比较复杂，需要动态根据不同类型来创建对象。<br>课堂讨论2：因为如果不设置为静态的话，就要通过构造方法来创建对象。而构造方法不能表达更多信息，例如：用静态 Foo x = Foo.create()<br>不用静态 Foo x = new Foo() 。使用构造器相对于静态来说每次对创建了一个新对象。","like_count":0},{"had_liked":false,"id":295313,"user_name":"二木","can_delete":false,"product_type":"c1","uid":1374789,"ip_address":"","ucode":"B91ED9F15F7D79","user_header":"https://static001.geekbang.org/account/avatar/00/14/fa/45/c4080f68.jpg","comment_is_top":false,"comment_ctime":1622362032,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1622362032","product_id":100039001,"comment_content":"只会js的 看Java代码很累啊","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474880,"discussion_content":"说的非常好👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574129970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033566,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/5e/24cc5a72.jpg","nickname":"阿狸爱JAVA","note":"","ucode":"597971781B1500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55870,"discussion_content":"我感觉我处于 作者说什么都觉得好有道理呀，恨不得里吗操刀子 去修改目前项目里的弊端，可是这位朋友却可以跳出作者是思维，提出自己的看法，佩服，什么时候我也可以这样。。。","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1574407561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2370904,"avatar":"","nickname":"Geek_7c3eea","note":"","ucode":"C0698A30E803B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335287,"discussion_content":"主要是业务学习成本太高，一般公司无法承担成本.ddd固然好，但是谁又给你足够的时间去炮制你的模型呢？贫血虽然有弊端，但确实适合新手入门。我们系统大多都是贫血加架构大泥球，新毕业的，带上一个月就能上手改。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1608135668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2875594,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","nickname":"孙新","note":"","ucode":"A80038A479B943","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2370904,"avatar":"","nickname":"Geek_7c3eea","note":"","ucode":"C0698A30E803B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579709,"discussion_content":"我新去一个公司，连旧项目的代码重构他们都没什么意愿。(原代码实在是可读性太差了，基本编码规范都没有，基本没有注释)。别说更高级的架构了。目前自己慢慢梳理重构，相信重构以后会给后续开发和维护效率带来质的提高。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657624948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335287,"ip_address":""},"score":579709,"extra":""}]},{"author":{"id":1192259,"avatar":"https://static001.geekbang.org/account/avatar/00/12/31/43/a1947dcb.jpg","nickname":"Felix Cao","note":"","ucode":"3C4690F1D9D5B8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300483,"discussion_content":"DDD不单是程序上的事，他还需要产品设计层面区分得好，面向对象的才会实现得更好，一定程度还是需要产品设计的合理性的。贫血模型主要的是编写成本低，充血模型运用到团队公司，人力成本是挺高的。关键是很多人都没在乎过程序的合理性，只是完成任务。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1598145256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1192259,"avatar":"https://static001.geekbang.org/account/avatar/00/12/31/43/a1947dcb.jpg","nickname":"Felix Cao","note":"","ucode":"3C4690F1D9D5B8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":300499,"discussion_content":"是的，编程在ddd只能占三分之一相关的东西。ddd主要是得建立领域模型，基于模型沟通，基于模型实现，基于模型扩展。好的模型比编码实现重要。然后完全用事件脚本这种结构性的编码方式也没太大问题，比较遗憾的就是模型和事件脚本的编码实现不好映射，而且事件脚本在复杂性隔离上有时会有点束手无策。所以，我的项目里还是有大量用事件脚本的实现，充血模型更多会在重构时去增加行为来提高复用和屏蔽复杂性（做多了就比较习惯写充血模型了，一开始挺别扭）。但完美的充血模型，我觉得反而会是累赘。毕竟事件脚本才是编码主流。大部分人不习惯面相对象的编码方式，追求完美充血模型，往往耗时耗力，碰一鼻子灰后还是四不像，不见得好。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1598150197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300483,"ip_address":""},"score":300499,"extra":""},{"author":{"id":1192259,"avatar":"https://static001.geekbang.org/account/avatar/00/12/31/43/a1947dcb.jpg","nickname":"Felix Cao","note":"","ucode":"3C4690F1D9D5B8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300653,"discussion_content":"DDD应用我觉得代码层面作用不大，但实行敏捷的技术团队中，对团队业务边界的定义，产品界限的定义很有指导作用。对于贫血模式和充血模式的讨论其实只是对面向对象运用的好坏讨论。在代码层面，DDD最多也是一个面向对象引申出来概念。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598225370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300499,"ip_address":""},"score":300653,"extra":""},{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1192259,"avatar":"https://static001.geekbang.org/account/avatar/00/12/31/43/a1947dcb.jpg","nickname":"Felix Cao","note":"","ucode":"3C4690F1D9D5B8","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":300685,"discussion_content":"不是的。贫血模型那能叫面相对象吗？可以重新了解下面相对象。在实现模型这块，ddd其实给出了一些要素和分层架构的东西。其目的无非也是提高复用隔离变化，实现软件的高内聚低耦合。一般开发随便就好，但如果你是组长或则部长，我认为你还得代表团队整体的编码水平，这些基本原则和评判标准还是得清晰的，这代表了你的品位。可以不用但不可以不懂。ddd的主流实现确实是面相对象，但不等于函数式编程就不能用ddd，所以也不能说ddd是面相对象的延伸。你可以认为它是一套方法论或则说套路。我认为ddd最大的价值还是在跨领域落地领域模型，进而驱动设计，编码只是其中一部分。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1598233316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300653,"ip_address":""},"score":300685,"extra":""}]},{"author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54088,"discussion_content":"充血模型过于专业，专业性跟成本方面要求太高，太难实现了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574258329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1433535,"avatar":"https://static001.geekbang.org/account/avatar/00/15/df/bf/96b50d1e.jpg","nickname":"😚 46","note":"","ucode":"EED0EBBBF80A43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1687656,"avatar":"https://static001.geekbang.org/account/avatar/00/19/c0/68/314e8306.jpg","nickname":"威先森","note":"","ucode":"5F445C6832274B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72782,"discussion_content":"认同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575526878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54088,"ip_address":""},"score":72782,"extra":""}]},{"author":{"id":1048681,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/69/3b1375ca.jpg","nickname":"海拉鲁","note":"","ucode":"6E3493295CED6F","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203778,"discussion_content":"赞同，对于业务初期阶段“贫血模型”更易于理解，快速开发原型上线。在后期业务不断演进后就要开始考虑采用DDD了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584080125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1048681,"avatar":"https://static001.geekbang.org/account/avatar/00/10/00/69/3b1375ca.jpg","nickname":"海拉鲁","note":"","ucode":"6E3493295CED6F","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":204183,"discussion_content":"也不全是，ddd会是复杂项目发展的一个节点，但也不是一个终态。一旦项目很好的做了微服务拆分，那理论上每个微服务应该足够单纯，甚至是业务只读的。其业务的复杂程度本身就可以不引入复杂的分层架构和抽象设计。因为抽象这一层已经在应用架构做了。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1584117472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":203778,"ip_address":""},"score":204183,"extra":""}]},{"author":{"id":1026390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a9/56/315c5be7.jpg","nickname":"青鸟","note":"","ucode":"A4818C5C0C688D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404664,"discussion_content":"666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634377167,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2404887,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b2/17/3161b49c.jpg","nickname":"达叔灬","note":"","ucode":"5CCBAF13548F02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383851,"discussion_content":"卧槽  太有道理了  收下我得膝盖","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626254285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377003,"discussion_content":"大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622458561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188793,"avatar":"https://static001.geekbang.org/account/avatar/00/12/23/b9/8d182f13.jpg","nickname":"起风了","note":"","ucode":"9A8A2E51E198EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306612,"discussion_content":"2 的第一个理由，没看明白。【合理的业务封装却阻碍关于复用通用抽象的矛盾】每一个字都认识，连起来就看不懂 ┭┮﹏┭┮ 不知道迟到了一年的我，还能得到好心人的回复吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600330245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1965699,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","nickname":"慎独明强","note":"","ucode":"DC2F7F2C0C8F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303728,"discussion_content":"佳新大佬，6666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599362452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242573,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/cd/3890be04.jpg","nickname":"小川","note":"","ucode":"D462222DDBB978","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279687,"discussion_content":"老哥，加个好友可行 (●&#39;◡&#39;●)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591380003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1306032,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","nickname":"桂城老托尼","note":"","ucode":"139E4B8EE88B79","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110001,"discussion_content":"ddd的成本有点高，互联网一般要快，完了再优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577715906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1306032,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","nickname":"桂城老托尼","note":"","ucode":"139E4B8EE88B79","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110081,"discussion_content":"1.要快没毛病。所以不是一开始就用ddd也不是全部都用ddd。而是在业务价值显著且变化频率较高的模块采用ddd。起步成本虽高，但其易扩易维护的特性，长远上看其实是降低成本的。\n\n2.ddd的领域封装的成本是高，但其分层和事件驱动的架构特性和面向过程+贫血模型的常规开发模式是不冲突的。合理的架构可维持软件长期发展上的开发心智负担的稳定。\n\n3.话不多说，用了再说，不论利弊自己实现一遍再权衡便是。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1577717144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":110001,"ip_address":""},"score":110081,"extra":""}]},{"author":{"id":1165364,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","nickname":"海罗沃德","note":"","ucode":"8704F1D6980FA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85546,"discussion_content":"感覺有必要把極客時間裡DDD的課程買一下了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576553755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290050,"user_name":"Chen","can_delete":false,"product_type":"c1","uid":2529422,"ip_address":"","ucode":"9A7EF7CDB7CAF0","user_header":"https://static001.geekbang.org/account/avatar/00/26/98/8e/18098233.jpg","comment_is_top":false,"comment_ctime":1619338706,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619338706","product_id":100039001,"comment_content":"## 希望得到解答<br>对于争哥举的例子一直稍有疑问——通过工厂方法解决 if-else 语义<br>疑问点：简单工厂同样也可以解决，因为if-else 解决问题的核心不在模式本身，而在于静态初始化方法那里；只要获取解析器的方式是解耦的，通过简单工厂同样可以解决判断语句的问题。<br>对于这个案例我的感受是：工厂方法接口有点过度设计了<br>希望争哥答疑解惑<br>","like_count":0},{"had_liked":false,"id":288253,"user_name":"auch","can_delete":false,"product_type":"c1","uid":2227105,"ip_address":"","ucode":"462B7410040102","user_header":"https://static001.geekbang.org/account/avatar/00/21/fb/a1/601c3808.jpg","comment_is_top":false,"comment_ctime":1618381514,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1618381514","product_id":100039001,"comment_content":"受@zhengyu.nie的启发，创建有参构造函数的对象时，可以使用Function&lt;T, R&gt;,具体代码<br>public class ComponentFactory {<br><br>    private static final Map&lt;ComponentEnum, Function&lt;DagNode, AbstractComponent&gt;&gt; cachedComponent = new HashMap&lt;&gt;();<br><br>    static {<br>        cachedComponent.put(HTTPSERVER, HttpServerComponent::new);<br>        cachedComponent.put(HTTPCLIENT, HttpClientComponent::new);<br>        cachedComponent.put(JDBC, JDBCServerComponent::new);<br>        cachedComponent.put(GROOVY, GroovyComponent::new);<br>    }<br><br>    public static AbstractComponent getComponent(DagNode dagNode) {<br>        String type = dagNode.getType();<br>        Set&lt;String&gt; types = Arrays.stream(values()).map(ComponentEnum::getType).collect(Collectors.toSet());<br>        if (StringUtils.isEmpty(type) || !types.contains(type)) {<br>            throw new RuntimeException(&quot;type非法&quot;);<br>        }<br>        return cachedComponent.get(ComponentEnum.getValue(type)).apply(dagNode);<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559338,"discussion_content":"应该是Arrays.stream(ComponentEnum.values())","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648712973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287013,"user_name":"Jerry","can_delete":false,"product_type":"c1","uid":1621616,"ip_address":"","ucode":"9CDB5CFF39E219","user_header":"https://static001.geekbang.org/account/avatar/00/18/be/70/70c71ec6.jpg","comment_is_top":false,"comment_ctime":1617727418,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617727418","product_id":100039001,"comment_content":"看了三遍，每一遍都有不同收获。","like_count":0},{"had_liked":false,"id":286774,"user_name":"Geek_6d3429","can_delete":false,"product_type":"c1","uid":1898698,"ip_address":"","ucode":"F112DBF8375B7F","user_header":"","comment_is_top":false,"comment_ctime":1617590271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617590271","product_id":100039001,"comment_content":"工厂这思路，将一类有相似性的对象的创建，放到一个类中，将各对象的创建和使用分离。好处一是，不必到处找对应的类，如创建三角形，长方形，不用去找三角形，而是去找几何图形的创建工厂。好处二是，分散复杂度，一个对象的创建过程由于相关的类较多，参数较多，可能会比较复杂，把这些单独处理，将复杂度分散到工厂类里。<br><br>       简单工厂模式，只是对创建过程进行了封装，把选择创建哪个类型的对象的逻辑，放到了工厂。当创建逻辑不复杂时，这就足够了。<br><br>       工厂模式，可能每种对象创建的参数差异较大，且较为复杂，这样就可以为每个类型的对象创建一个工厂。进一步将复杂度，分散到各自的工厂中。<br><br>        至于选择创建哪种对象的逻辑，即常说的if else逻辑，可以通过创建工厂的map，通过查找key，来创建。通常在工厂模式上，再加上一个类，来处理这个选择逻辑。还可以通过这个上层类来管理已经创建的对象，如A工厂创建了a个对象，B工厂创建了b个对象。","like_count":0},{"had_liked":false,"id":284717,"user_name":"Geek_East","can_delete":false,"product_type":"c1","uid":1589947,"ip_address":"","ucode":"A1A7CBF9B8FB2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqXKSvfaeicog2Ficx4W3pNeA1KRLOS7iaFy2uoxCDoYpGkGnP6KPGecKia6Dr3MtCkNGpHxAzmTMd0LA/132","comment_is_top":false,"comment_ctime":1616426291,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1616426291","product_id":100039001,"comment_content":"工厂模式的出现时为了隔离代码中创建对象的复杂过程。<br><br>隔离出来的部分和已知代码如何关联？<br>如果隔离部分有多个版本，可以通过抽象类或者接口做媒介进行关联，符合开闭原则。<br><br>工厂方法未能从本质上消除if-else带来的分叉结构，即便使用key-value pair也是一样。它只是转移了判断分叉的位置， 当且仅当迁移到对象创建的时机时，才不会有if-else, 因为已经被人为选择。","like_count":0},{"had_liked":false,"id":283408,"user_name":"Yeyw","can_delete":false,"product_type":"c1","uid":1463740,"ip_address":"","ucode":"C9D20DB91C3BE5","user_header":"https://static001.geekbang.org/account/avatar/00/16/55/bc/fad0090b.jpg","comment_is_top":false,"comment_ctime":1615771949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615771949","product_id":100039001,"comment_content":"分离使用和生成，隐藏生成细节","like_count":0},{"had_liked":false,"id":277977,"user_name":"我不是黄蓉我不会武功","can_delete":false,"product_type":"c1","uid":2416157,"ip_address":"","ucode":"E4BE01B01AF1BB","user_header":"https://static001.geekbang.org/account/avatar/00/24/de/1d/c1bd26dc.jpg","comment_is_top":false,"comment_ctime":1612688971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612688971","product_id":100039001,"comment_content":"如果将 parser 事先创建好缓存起来，创建cachedParsers时应该是使用IRuleConfigParser而不是RuleConfigParser，可能老师笔误，<br>完整的代码是：<br><br>public class RuleConfigParserFactory {<br><br>    private static final Map&lt;String, IRuleConfigParser&gt; cachedParsers = new HashMap&lt;&gt;();<br><br>    static {<br>        cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());<br>        cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());<br>        cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());<br>        cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());<br>    }<br><br><br>    public static IRuleConfigParser createParser(String configFormat) {<br>        if (configFormat == null || configFormat.isEmpty()) {<br>            return null;&#47;&#47;返回null还是IllegalArgumentException全凭你自己说了算<br>        }<br>        IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());<br>        return parser;<br>    }<br>}","like_count":0},{"had_liked":false,"id":275995,"user_name":"肖立俊","can_delete":false,"product_type":"c1","uid":1642648,"ip_address":"","ucode":"D2F7FCE6C9C704","user_header":"","comment_is_top":false,"comment_ctime":1611739946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611739946","product_id":100039001,"comment_content":"方法工厂的demo代码是存在问题的。工厂方法应该把简单工厂的内部逻辑判断移到了客户端代码来进行，否则就与简单工厂一样，存在对修改开放的问题了。","like_count":0},{"had_liked":false,"id":269513,"user_name":"席席","can_delete":false,"product_type":"c1","uid":1591399,"ip_address":"","ucode":"656377E29D4F76","user_header":"https://static001.geekbang.org/account/avatar/00/18/48/67/128eda8f.jpg","comment_is_top":false,"comment_ctime":1608689386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608689386","product_id":100039001,"comment_content":"王老师，怎么判断类对象是否可以复用，也就是什么时候用单例工厂和非单例工厂，它们分别要达成什么样的条件才能具体区分改用哪个工厂模式？","like_count":0},{"had_liked":false,"id":266123,"user_name":"明石家秋刀鱼","can_delete":false,"product_type":"c1","uid":2335869,"ip_address":"","ucode":"B0DAC2CFECE5C8","user_header":"https://static001.geekbang.org/account/avatar/00/23/a4/7d/19eb8409.jpg","comment_is_top":false,"comment_ctime":1607177064,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607177064","product_id":100039001,"comment_content":"应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合开闭原则，但也增加了类的个数，牺牲了代码的可读性。<br>-----------------------------------------------<br>请问应用多态或设计模式是怎样做的呢？","like_count":0},{"had_liked":false,"id":265518,"user_name":"小旭贼优秀","can_delete":false,"product_type":"c1","uid":1673976,"ip_address":"","ucode":"8755845FF87CE5","user_header":"https://static001.geekbang.org/account/avatar/00/19/8a/f8/617e8f79.jpg","comment_is_top":false,"comment_ctime":1606920308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606920308","product_id":100039001,"comment_content":"简单工厂中创建对象的方法是静态的，我觉得是因为工厂对象过于庞大，如果初始化会比较占用jvm中堆的资源，方法设计成静态的在使用时可以通过类名.方法名进行调用,并且工厂对象不会存在于堆中。","like_count":0},{"had_liked":false,"id":256798,"user_name":"包子","can_delete":false,"product_type":"c1","uid":1089345,"ip_address":"","ucode":"6CC4EBB8CD3924","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/41/82306dfe.jpg","comment_is_top":false,"comment_ctime":1603756233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603756233","product_id":100039001,"comment_content":"你好，争哥。一般在使用工厂类的时候，我们什么时候实例化工厂对象呢？<br><br>像我一般用工厂，老喜欢定义为静态方法，这样可以避免每次都new，也方便使用。<br><br>这样有什么问题吗？","like_count":0},{"had_liked":false,"id":252994,"user_name":"何柄融","can_delete":false,"product_type":"c1","uid":1398884,"ip_address":"","ucode":"A4C165D1EE3726","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/64/b715d45a.jpg","comment_is_top":false,"comment_ctime":1602556299,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602556299","product_id":100039001,"comment_content":"没看出工厂方法模式怎么去除if else了，只发现它可以抽出复杂逻辑的代码到初始化类中，，求大佬指导！明明简单工厂和工厂方法在根据条件判断的时候都有if else啊","like_count":0,"discussions":[{"author":{"id":1200660,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/14/cb118a61.jpg","nickname":"键舞飞扬","note":"","ucode":"4EC7A8D2E7AC78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344651,"discussion_content":"被带偏了，不是为了去掉If else ,   是为了把这不稳定的部分移出去。让主体更符合开闭原则。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611546428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250281,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","comment_is_top":false,"comment_ctime":1601008865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601008865","product_id":100039001,"comment_content":"确认很有用呢","like_count":0},{"had_liked":false,"id":247023,"user_name":"Geek_35cfdd","can_delete":false,"product_type":"c1","uid":1792214,"ip_address":"","ucode":"AD9615ABB4CA25","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoiaP1gptuBzj3AXMpY8yLTIkpuarouOVzLde4636UJ7zAgnOEZibiaAIRVAicFaO64ftH45YOn1pD3VA/132","comment_is_top":false,"comment_ctime":1599558950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599558950","product_id":100039001,"comment_content":"私认为，简单工厂中创建类时方法是否静态本质和业务场景是挂钩的。在你上面举例子的那个Calendar确实可以是静态的，因为在初始化时里面的参数是默认写死的。但是在大部分业务场景下，工厂本质是为了解决复杂对象的创建，那么此对象的属性一般来说比较多，而且某些属性的获取可能是需要调用接口调用才能拿到。这个时候如果将方法设置为静态的，那么就会有问题。","like_count":0},{"had_liked":false,"id":246930,"user_name":"桃源小盼","can_delete":false,"product_type":"c1","uid":1039664,"ip_address":"","ucode":"3FA0819FD69FF8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/dd/30/9d36ccaf.jpg","comment_is_top":false,"comment_ctime":1599533636,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1599533636","product_id":100039001,"comment_content":"总公司对应工厂方法，<br>子公司对应简单工厂，<br>这样来理解很容易。","like_count":0,"discussions":[{"author":{"id":1617369,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/FqWrN8aNrlXEfo2YeDeCRuWMZ57VzsNC0aibkEIdiaNBdUVPjlBXrg9F4Eb8uMFYckuSgmXQ49vT6SHoicAjeEGdA/132","nickname":"Geek_558387","note":"","ucode":"2EA857EBC365B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309091,"discussion_content":"竟扯犊子","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601187867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1039664,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dd/30/9d36ccaf.jpg","nickname":"桃源小盼","note":"","ucode":"3FA0819FD69FF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1617369,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/FqWrN8aNrlXEfo2YeDeCRuWMZ57VzsNC0aibkEIdiaNBdUVPjlBXrg9F4Eb8uMFYckuSgmXQ49vT6SHoicAjeEGdA/132","nickname":"Geek_558387","note":"","ucode":"2EA857EBC365B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309129,"discussion_content":"请具体说一下哪里不好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601193492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309091,"ip_address":""},"score":309129,"extra":""}]}]},{"had_liked":false,"id":240358,"user_name":"御风","can_delete":false,"product_type":"c1","uid":1812807,"ip_address":"","ucode":"51C8212BE06364","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg","comment_is_top":false,"comment_ctime":1596875960,"is_pvip":false,"replies":[{"id":"89262","content":"反射可以，但不能再static静态代码块中创建对象吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1597453456,"ip_address":"","comment_id":240358,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596875960","product_id":100039001,"comment_content":"掌握了使用工厂模式的本本质：封装变化（创建逻辑可能变化）、隔离复杂性、控制复杂度（让类职责更加单一）、代码复用。<br>如果创建的对象不能复用，又不想用if–else，就不能使用简单工厂模式。<br>这个可以在static代码块中使用反射？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503414,"discussion_content":"反射可以，但不能再static静态代码块中创建对象吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597453456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240087,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1596760267,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596760267","product_id":100039001,"comment_content":"第二个问题：简单工厂本身是无状态的，无需创建多个对象，并且也不需要定义复杂构造函数，因此采用静态方法更匹配这种特性","like_count":0},{"had_liked":false,"id":237557,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1595863031,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595863031","product_id":100039001,"comment_content":"1.游戏里常用的对象池也算是工厂模式吧，拿bullet 必须。 2.对于静态方法，我的理解是方便使用，目的是获得对象，而不是为了一个新对象而去new一个工厂出来。关于测试性，使用工厂模式出来的对象 通常应该不会具有对于其他复杂类或者模块的依赖性，本身应该就是一个干净的对象，所以应该不会影响到代码测试。除非这个工厂是有依赖到其他服务模块或者单例，没有做干净，那么这样的工厂类使用静态方法会影响到测试性。","like_count":0},{"had_liked":false,"id":232163,"user_name":"唯她命","can_delete":false,"product_type":"c1","uid":1240398,"ip_address":"","ucode":"8F687E8D306840","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/4e/ef406442.jpg","comment_is_top":false,"comment_ctime":1593877229,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593877229","product_id":100039001,"comment_content":"什么叫针对规则配置的解析器，什么叫针对系统配置的解析器？？","like_count":0,"discussions":[{"author":{"id":1715988,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2f/14/840d0925.jpg","nickname":"Varus","note":"","ucode":"B9CB88C248BD93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":64233,"discussion_content":"感觉自己一直扛着屠龙刀在切菜","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1574942898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1484184,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","nickname":"djfhchdh","note":"","ucode":"E71D75328CE398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62210,"discussion_content":"快糙猛，很正常","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574823571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1245904,"avatar":"https://static001.geekbang.org/account/avatar/00/13/02/d0/8abab63f.jpg","nickname":"治慧","note":"","ucode":"47C331EF63EDC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":207808,"discussion_content":"自己以为自己写的是面向对象结果是面向过程😢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584515487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1811277,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a3/4d/59390ba9.jpg","nickname":"排骨","note":"","ucode":"A413CF46211E1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585740,"discussion_content":"直接上去就是砍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661782502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2449748,"avatar":"https://static001.geekbang.org/account/avatar/00/25/61/54/5bf767e7.jpg","nickname":"没有心的人","note":"","ucode":"F27D5894087B11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350675,"discussion_content":"俺也一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613976358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348593,"discussion_content":"一样😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612661132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330913,"discussion_content":"一样啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606730032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1747935,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ab/df/7bf49e31.jpg","nickname":"breeze","note":"","ucode":"143767E9307ED2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285876,"discussion_content":"一样一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592982410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284955,"discussion_content":"不用怀疑。我们都是这么干的😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592699428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1514495,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1b/ff/8cb67f1f.jpg","nickname":"明天","note":"","ucode":"27DD39C3CF638B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84160,"discussion_content":"一直和你在做一样的事","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576492409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623626,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/4a/3bd896fc.jpg","nickname":"Heiky","note":"","ucode":"03AA79E1BC4AE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52544,"discussion_content":"哈哈，我和你一样的想法，估计都在写面向过程的代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574065363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1623626,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/4a/3bd896fc.jpg","nickname":"Heiky","note":"","ucode":"03AA79E1BC4AE4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52637,"discussion_content":"一起努力，跟着专栏进步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574074887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52544,"ip_address":""},"score":52637,"extra":""}]},{"author":{"id":1237655,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","nickname":"Kang","note":"","ucode":"088A8DA0A16BDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52449,"discussion_content":"估计写的都是面向过程哦，嘿嘿","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574052418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1237655,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e2/97/dfadcc92.jpg","nickname":"Kang","note":"","ucode":"088A8DA0A16BDE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52465,"discussion_content":"doble康厉害👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574053659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52449,"ip_address":""},"score":52465,"extra":""}]}]},{"had_liked":false,"id":230695,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593468771,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593468771","product_id":100039001,"comment_content":"三种工厂模式<br>简单工厂，对象创建本身复杂的话(如有资源初始化)，可以抽个工厂<br>工厂方法，即当对象创建按某种类别进行划分会有多种工厂，这时可以用工厂方法，即封装了获取工厂的复杂性<br><br>工厂方法有以下几种优点：<br>防腐层，创建对象复杂逻辑改动不影响调用者<br>代码复用","like_count":0},{"had_liked":false,"id":228613,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1015754,"ip_address":"","ucode":"00DF2FEC58D2E6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","comment_is_top":false,"comment_ctime":1592752471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592752471","product_id":100039001,"comment_content":"2. 工厂模式分为三类：1）简单工场模式；2）工场方法模式；3）抽象工场模式<br>简单工场模式和工场方法模式比较常用，抽象工场模式不常用<br>3. 简单工场模式思想：定义工场类，和一个工场方法，工场方法通过传入的参数判断应该创建哪类的对象<br>4. 工场方法模式思想：定义个工场的工场类RuleConfigParserFactoryMap，在工场的工场类中定义一个方法public static IRuleConfigParserFactory getParserFactory(String type)，该方法根据传递的参数返回对应的工场<br>5. 抽象工厂是对工厂方法的改进，为了防止类的数量暴增而提出的，但是虽然可以减少类的暴增，但是对已有的代码改动比较多。虽然可以减少工场类的个数，但是就对已有的代码改动比较多了。例如现在又增加了一种从classpath加载的解析器，因此对于JsonConfigParserFactory的改动就需要增加下面的方法<br>@Override public ISystemConfigParser createClasspathParser() {<br>return new JsonClasspathConfigParser();<br>}<br>其余的已经存在的Factory也要做相应的修改，改动量比较大","like_count":0},{"had_liked":false,"id":221285,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1590463172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590463172","product_id":100039001,"comment_content":"1. 加载获取配置的类 一般适合设计成单例 因为他根本不需要创建多个对象参与操作<br>2. 因为短小间接而设置静态的 If else就能搞定，而且没有过于复杂的逻辑 对于可测试性我觉得没多啥影响 要测试还是挺方便的","like_count":0},{"had_liked":false,"id":208228,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1587305543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587305543","product_id":100039001,"comment_content":"1. Java 中的 Collections, Executors 等工具类都是用到了静态工厂<br>2. 不影响可测试性，工厂创建的对象可通过依赖注入的方式被引用，测试时也可以 Mock","like_count":0},{"had_liked":false,"id":205596,"user_name":"fly","can_delete":false,"product_type":"c1","uid":1025992,"ip_address":"","ucode":"D1F6938C9CE15D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a7/c8/5608cbdb.jpg","comment_is_top":false,"comment_ctime":1586680669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586680669","product_id":100039001,"comment_content":"简单工厂：对if-else进行了转移，让代码看起来更简洁<br>工厂方法：只是进一步封装拆分创建实例的过程，if-else用map的key-value来消灭<br>抽象工厂：两种以上分类方式，用抽象工厂减少工厂类的个数倍增问题，较少使用<br><br>","like_count":0},{"had_liked":false,"id":203206,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586156121,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1586156121","product_id":100039001,"comment_content":"Factory Method Pattern：define an interface or abstract class for creating an object but let the subclasses decide which class to instantiate. <br><br>Abstract Factory Pattern：define an interface or abstract class for creating families of related (or dependent) objects but without specifying their concrete sub-classes.","like_count":0},{"had_liked":false,"id":203204,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586155516,"is_pvip":false,"discussion_count":2,"race_medal":1,"score":"1586155516","product_id":100039001,"comment_content":"个人感觉结合实际的例子来学习，这样的方式的确挺好的。但是也增加了理解的复杂度。在听这个章节时，第一次听完之后，一脸懵。然后，个人首先去找相关的网页文章，学习了一下什么是工厂模式，以及其分类之间的区别和联系。在弄清楚了什么是工厂模式后，然后再来重新听这篇文章，这才理解了作者的意思。作者把工厂模式的讲解结合重构在一起讲解，增加了这篇文章的复杂度。因为这部文章的核心主题是工厂模式。这篇文章不适合初学者，适合具有一定设计模式基础和java代码基础的人。","like_count":0,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383780,"discussion_content":"对对对 我说咋读着有点矛盾呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626236982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1888301,"avatar":"","nickname":"Huyunfu","note":"","ucode":"61A3AFC7BD4203","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583074,"discussion_content":"说得好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659915093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1605058,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7d/c2/e6332a1b.jpg","nickname":"东方拓睿","note":"","ucode":"1FD25D75CAC7C1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575953,"discussion_content":"我觉得是两个方面来说，从设计角度上来说面向对象符合人类对于事物的理解，各种事物相互之间的关系，这是一种多维的，网状性的，比如人处在一个社会中有不同的身份，人与人之间有许多不同关系，人和万物之间，人与社会等等，而对于实现角度，相当于做事的时候，我们都是按照程式化的方式按部就班。思维里面多会按照第一部做什么，第二部做什么，实际上就是做事的细化，以及做事的主次顺序，这是两个不同维度的，我们做软件开发就是要恰到好处结合面向对象与面向过程来做，比如老师讲的架构是上是面向对象，但我们每个方法内就要用面向过程来实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655206793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":199335,"user_name":"Geek_e9b8c4","can_delete":false,"product_type":"c1","uid":1716601,"ip_address":"","ucode":"C29F7344A6EE6B","user_header":"","comment_is_top":false,"comment_ctime":1585487135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585487135","product_id":100039001,"comment_content":"本文总结和可运行代码： http:&#47;&#47;uee.me&#47;dbCKH ","like_count":0},{"had_liked":false,"id":189633,"user_name":"丁乐洪","can_delete":false,"product_type":"c1","uid":1264392,"ip_address":"","ucode":"549CE57AB20B49","user_header":"https://static001.geekbang.org/account/avatar/00/13/4b/08/52954cd7.jpg","comment_is_top":false,"comment_ctime":1584536446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584536446","product_id":100039001,"comment_content":"工作中，刚准备使用工厂模式","like_count":0},{"had_liked":false,"id":189306,"user_name":"空白昵称","can_delete":false,"product_type":"c1","uid":1433815,"ip_address":"","ucode":"91F50CA25102AB","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d7/744bd8c3.jpg","comment_is_top":false,"comment_ctime":1584498264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584498264","product_id":100039001,"comment_content":"1. 使用工厂方法的设计，会增强代码可读性，更易于理解。如果全都前篇一律的new，就会需要考虑过多初始化参数，带来不必要的麻烦。<br>2. 设计成静态的，应该是根据实际应用场景来设计的吧。此时跟单例有些相似，全局只创建了一份。获取到的是静态实例，会对单元测试产生影响。比如该实例中暴露的属性，就跟全局可变变量是一样的...<br>不知道我的理解可对！","like_count":0},{"had_liked":false,"id":186986,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1583983776,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583983776","product_id":100039001,"comment_content":"简单工厂即是通过一个静态方法生成对象，里面有很多的if-else；<br>工厂方法即一个工厂类创建一个对象，避免应到简单工厂各种if-else，用多态将不同的创建逻辑放到一个工厂类中；一类产品及子类，一个抽象工厂及不同子类对应工厂子类；<br>抽象工厂相对于工厂方法，每个工厂子类🈶️多个创建对象的方法，适用于多类产品，可减少工厂类的创建<br>","like_count":0,"discussions":[{"author":{"id":1364353,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","nickname":"大力","note":"","ucode":"1B2125C519443D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297525,"discussion_content":"赞同这一句：\n“无论面向对象或面向过程，写出层次清晰，易扩展，易维护的代码才是目的。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596959579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241567,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/df/8ba04bec.jpg","nickname":"Joker","note":"","ucode":"C42E11098E1B38","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":66704,"discussion_content":"为什么说静态方法将方法与数据分离？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575099729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1364353,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d1/81/89ba9d81.jpg","nickname":"大力","note":"","ucode":"1B2125C519443D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241567,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/df/8ba04bec.jpg","nickname":"Joker","note":"","ucode":"C42E11098E1B38","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297524,"discussion_content":"静态方法一般是不会对类中的全局属性（数据）进行操作的，属于无状态，无副作用。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596959547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":66704,"ip_address":""},"score":297524,"extra":""}]}]},{"had_liked":false,"id":186627,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1583893280,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583893280","product_id":100039001,"comment_content":"RuleConfigParserFactoryMap 这个是不是还要加一个私有的构造方法呢？","like_count":0},{"had_liked":false,"id":185889,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583720688,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583720688","product_id":100039001,"comment_content":"1.在Spring这个依赖注入框架中,其创建实例并注入进去,利用的就是BeanFactory,其隐藏了具体的创建细节,在框架启动之后,就将类和类之间的依赖关系设置好,方便调用者直接去使用了,这个Bean的工厂类,是整个框架的基石<br>2.简单工厂由于不会被继承,而且其创建对象的方法中逻辑相对稳定,不会发生改变,而且就算改变,也只是小层次的改变,基本符合开闭原则,可以设计为静态的,而且由于我们一般通过工厂类拿到的是创建好的对象,不和实际业务代码耦合,不会影响到测试性","like_count":0},{"had_liked":false,"id":185191,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1583509709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583509709","product_id":100039001,"comment_content":"我对工厂类的理解，最重要的内容还是只向上层提供接口，而我们可以根据自己的需求实现类。<br><br>实现类假如构建复杂，可以为工厂类再设计每个实现类的工厂类，这里可以尝试用 枚举+抽象方法， 实现这些 “实现类的工厂类”","like_count":0},{"had_liked":false,"id":184353,"user_name":"霹雳大仙pp","can_delete":false,"product_type":"c1","uid":1046893,"ip_address":"","ucode":"F654FD9AEC1D56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/6d/b623562a.jpg","comment_is_top":false,"comment_ctime":1583297343,"is_pvip":false,"discussion_count":0,"race_medal":3,"score":"1583297343","product_id":100039001,"comment_content":"1、Spring中FactoryBean工厂，屏蔽内部bean创建细节<br>2、不影响测试，工厂方法可以被mock代替","like_count":0},{"had_liked":false,"id":183141,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1582959890,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1582959890","product_id":100039001,"comment_content":"简单工厂-直接new对象<br>工厂模式-具体类来new对象<br>抽象工厂模式-具体类生成不同的对象","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474825,"discussion_content":"😄你说的后面都基本上有讲到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574037065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182983,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1582901653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582901653","product_id":100039001,"comment_content":"问题一：Spring中BeanFactory，Spring 启动的时候，最重要的就是初始化对象，而他们又有多种出事对象的方法，例如xml，注解等<br>问题二：设置成静态的方法，是为了方便调用方调用。个人感觉，简单工厂创建的对象种类是相对稳定，不影响代码的可测试性。","like_count":0},{"had_liked":false,"id":181509,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1582553177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582553177","product_id":100039001,"comment_content":"1. Executors利用静态方法做工厂方法，dubbo的spi也是工厂的思路<br>2. 首先包含简单工厂方法的对象，没有必要有构造函数。因为他只是创建对象的一个类。不用实例化，所以如果方法不是静态的，就没法调用了。<br>3. 我认为不影响可测试性，因为静态方法仅仅返回了一个对象，而需要测试的应该是这个对象的被你调用的方法。并不是拿到这个对象的过程。","like_count":0},{"had_liked":false,"id":180258,"user_name":"一名小学生","can_delete":false,"product_type":"c1","uid":1137292,"ip_address":"","ucode":"5C73082E6B6370","user_header":"https://static001.geekbang.org/account/avatar/00/11/5a/8c/1fec5fa2.jpg","comment_is_top":false,"comment_ctime":1582242107,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582242107","product_id":100039001,"comment_content":"学习了～<br>","like_count":0},{"had_liked":false,"id":180096,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1582186186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582186186","product_id":100039001,"comment_content":"会影响可测试性，因为它无法被mock（通常是mock实例的实例方法），导致其他依赖工厂类的类难以测试","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475342,"discussion_content":"给类本身提供一个copy方法呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574377996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1049017,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/b9/73435279.jpg","nickname":"学习学个屁","note":"","ucode":"DF2D61E6FB2FCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576287,"discussion_content":"map struct ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655394463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2347137,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","nickname":"snake","note":"","ucode":"47BFFE4D048156","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330915,"discussion_content":"我是给类提供了一个copy方法，里面用的是 BeanUtils.copyProperties。。不能提供set方法那是不是只能手动调用实体类的set方法了，如果属性多的话手写代码有点累啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606730328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284956,"discussion_content":"这个问题我刚刚做梦和老师回复的解决思路是一样的。开心。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592699662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1339810,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/a2/72dfab8a.jpg","nickname":"随便打鹅","note":"","ucode":"F594AB37C5CE19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1283461,"avatar":"https://static001.geekbang.org/account/avatar/00/13/95/85/15cd21c2.jpg","nickname":"杨锋","note":"","ucode":"85A7828A538FB0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":305316,"discussion_content":"但是这样得手写代码😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599875076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":284956,"ip_address":""},"score":305316,"extra":""}]}]},{"had_liked":false,"id":180054,"user_name":"majaja","can_delete":false,"product_type":"c1","uid":1253057,"ip_address":"","ucode":"02A895E97DEB4A","user_header":"https://static001.geekbang.org/account/avatar/00/13/1e/c1/93d5d486.jpg","comment_is_top":false,"comment_ctime":1582174717,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582174717","product_id":100039001,"comment_content":"所以，在这个应用场景下，简单工厂模式简单好用，比工方法厂模式更加合适。<br>此處工方法厂是錯字嗎?","like_count":0},{"had_liked":false,"id":180030,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1582168603,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582168603","product_id":100039001,"comment_content":"课堂讨论<br>2. 简单工厂创建对象的方法之所以用静态的, 那是因为他的职责就是创建对象, 本身不需要包含任何和对象相关的任何成员变量, 换句话说, 就是任何人使用这个简单工厂的时候, 工厂都是无状态的, 所以直接用静态方法即可.","like_count":0},{"had_liked":false,"id":179090,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1581910979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581910979","product_id":100039001,"comment_content":"第一问 很少遇到<br>第二问 我觉得应该要考虑创建出来的对象是否存在一些成员变量吧  如果有数据的话就会有影响或者没啥影响吧","like_count":0},{"had_liked":false,"id":178604,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1581757872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581757872","product_id":100039001,"comment_content":"很喜欢最后的这几个总结。 感谢分享！<br>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。<br>代码复用：\b创建代码抽离到独立的工厂类之后可以复用。<br>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。<br>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。","like_count":0},{"had_liked":false,"id":178592,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1581753059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581753059","product_id":100039001,"comment_content":"打卡<br>三种工厂模式<br>一、简单工厂模式<br>使用场景：<br>1）代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。同时，对象的创建也不复杂。<br>实现方式：<br>1）使用if else逻辑进行创建<br>2）当对象可以复用的时候，可以使用单例模式+工厂模式组合<br><br>二、工厂方法模式<br>使用场景：<br>1）尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂。<br>2）在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。又想去除过多的if-else分支<br>实现方式：<br>1）定义相应的Factory接口，为每个工厂定义一个实现类。<br>2）之后定义工厂的工厂，把这些Factory实现类放到一个简单工厂类中<br><br>三、  抽象工厂（Abstract Factory）- 不常用<br><br>判断要不要使用工厂模式的标准<br>一、封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。<br>二、代码复用：创建代码抽离到独立的工厂类中可以复用<br>三、隔离复杂性：可以封装复杂的创建逻辑<br>四、控制复杂度：将创建代码抽离出来，让原本的函数或是类职责更单一，代码更简洁","like_count":0},{"had_liked":false,"id":178530,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1581735551,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581735551","product_id":100039001,"comment_content":"课堂讨论: 2. 实际上，简单工厂模式还叫作静态工厂方法模式（Static Factory Method Pattern）。之所以叫静态工厂方法模式，是因为其中创建对象的方法是静态的。那为什么要设置成静态的呢？设置成静态的，在使用的时候，是否会影响到代码的可测试性呢？<br>答: 设置成静态的是方便调用者调用, 同时, 静态方法在编译时就绑定了, 它是全局的, 有利于资源利用, 节省开销","like_count":0},{"had_liked":false,"id":178297,"user_name":"风羽星泉","can_delete":false,"product_type":"c1","uid":1198377,"ip_address":"","ucode":"CBC63AA00C5D70","user_header":"https://static001.geekbang.org/account/avatar/00/12/49/29/bbeccb9f.jpg","comment_is_top":false,"comment_ctime":1581653095,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581653095","product_id":100039001,"comment_content":"老师文章中提到的“工厂的工厂”，真是眼前一亮。","like_count":0},{"had_liked":false,"id":177884,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1581521527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581521527","product_id":100039001,"comment_content":"工厂模式细分为简单工厂，工厂方法，抽象工厂三种。工厂是一个创建型模式，主要用于对象的创建。对于对象的创建，如果是Java这种语言，最容易想到的是Object obj = new Object()这种方式。而通过工厂模式，可以封装对象创建的更多、更复杂的逻辑。三种不同的方式分别对应不同的应用场景，重点要理解他们分别应用于哪些场景。通过使用代码实现工厂模式，也逐渐体会到了之前学习到的一些设计思想，如面向对象特性，基于接口而非实现编程，单一职责，开闭原则，KISS原则等。<br>课堂讨论<br>1. 工厂模式实现类：java.util.concurrent.Executors、java.util.stream.Collectors、Spring中的BeanFactory。设计成工厂模式的原因除了文章中讲的那些外，由于没有深入研究过这些类，暂时得不出其他结论；<br>2. 简单工厂的方法设置成静态个人理解使使用者使用简单，不需要创建对象，直接调用即可。对于可测试性，静态工厂方法一般都比较简单，无需测试，测试的重点应该放在对象创建的逻辑上。","like_count":0},{"had_liked":false,"id":177780,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1581498750,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1581498750","product_id":100039001,"comment_content":"简单明了，明白了三种工厂方法的适用场景","like_count":0},{"had_liked":false,"id":177737,"user_name":"webmin","can_delete":false,"product_type":"c1","uid":1047014,"ip_address":"","ucode":"98B0CA882454E8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f9/e6/47742988.jpg","comment_is_top":false,"comment_ctime":1581486764,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1581486764","product_id":100039001,"comment_content":"实际上，简单工厂模式还叫作静态工厂方法模式（Static Factory Method Pattern）。之所以叫静态工厂方法模式，是因为其中创建对象的方法是静态的。那为什么要设置成静态的呢？<br>一是工具类方便使用；二是可以节约资源的使用，工厂大部分时候不需要创建不同的工厂实例；<br><br>设置成静态的，在使用的时候，是否会影响到代码的可测试性呢？<br>会有影响，需要使用Mock的高级方法才能对静态方法进行替换；","like_count":0},{"had_liked":false,"id":177672,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1581471496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581471496","product_id":100039001,"comment_content":"打卡","like_count":0}]}