{"id":192236,"title":"加餐2 | 前端安全：如何打造一个可信的前端环境？","content":"<p>你好，我是何为舟，欢迎来到安全专栏的第二次加餐时间。</p><p>前端的安全性一直是我们在考虑安全问题时，没有办法绕过的关键问题。今天，我就来和你聊一聊如何保护前端的安全性。</p><p>我们先来看一个攻击事件。2017年，12306网站被曝出有“买下铺”的功能。我们都有过买票的经历，当我们在12306上买卧铺的时候，是没法选择上铺、中铺还是下铺的。但是，有人去分析了12306的前端代码，发现里面其实包含了选铺位的功能，只是默认为随机，没有展示出来。所以，有人通过篡改前端代码，就将这个功能开放出来了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/92/73/92d2a4d2e1f7ed9a52aa8c70617b1573.jpg?wh=874*476\" alt=\"\"><br>\n一旦黑客能够完全摸清楚应用的前端代码，就能够任意地篡改前端的逻辑，实现带有想要功能的前端应用了。</p><p>如果说12306的例子，还不足以让你对前端安全产生警惕的话，你可以想一想，我们在网上看到的各种所谓的“破解版”软件，其实都是人为修改了应用的前端认证功能，从而不需要认证就可以正常使用。</p><p>除了篡改前端代码，黑客还可以通过对前后端接口的调用过程进行分析，复刻出一个自己的前端应用。在黑客复刻的前端应用中，所有的接口认证和加密都合法，只是调用的顺序完全由黑客掌控。粉丝圈比较流行的各类明星应援工具，其实都是基于这个原理实现的：黑客通过分析微博客户端的接口，自己打包了一个前端应用，实现了一键关注、点赞等功能。因为这些接口都是合法的，所以后端人员很难分辨出这些请求是来自于正规的应用，还是黑客自己实现的应用。</p><!-- [[[read_end]]] --><p>针对前端的攻击可以说是“防不胜防”，这让后端没有办法信任前端的环境，甚至没有办法信任前端发起的请求和上传的数据，极大地影响了公司和应用的正常发展。那么，我们应该通过什么方法来保障前端的可信呢？</p><h2>什么是混淆技术？</h2><p>要解决这个问题，我们可以先想一下黑客攻击前端的过程：黑客通过分析前端代码，来篡改前端逻辑，实现带有想要功能的前端应用。那有没有一种方法，无法让黑客在前端代码中分析出有效信息呢？答案就是<strong>混淆</strong>。</p><p>在理想状态下，我们混淆了前端代码之后，不仅能让黑客无法篡改前端代码，还能保证即使黑客成功篡改代码，那么篡改后的前端代码依然不可用。同时，黑客无法获得前端的接口密钥和签名等信息，也就无法伪造正常的前端应用去发起请求了。</p><p>我们知道，安全中通常不存在理想状态。我们最需要做的，就是不断地升级对抗，来接近这个理想的目标。</p><p>刚才我们说的是混淆技术可以实现的结果，那混淆技术究竟是什么呢？在不同的语言和环境（如：Android 、iOS和Web）中，混淆技术都是相对独立的。尽管混淆技术相对独立，但我还是希望，你可以通过理解一门语言的混淆技术和思路，做到“一通百通”。我也希望能够更好地启发你去思考，如何去做好前端安全。接下来，我就以JavaScript为例，带你梳理混淆的常见技术和思路。</p><h3>1.清晰代码无序化</h3><p>在实际工作中，开发人员总是会要求自己写出清晰简洁的代码。但是，这也为黑客的代码分析提供了便利。因此，混淆的第一步，一定是想办法让我们的JavaScript代码变得“难看”，也就是将整洁的代码变得无序。</p><p>有什么办法能让代码变得“难看”呢？我这里通过一个例子来具体解释一下，你就能明白了。</p><p>我们先来看一段代码。</p><pre><code>function obfuscate() {\n  console.log(&quot;I'm obfuscator!&quot;);\n}\nobfuscate();\n</code></pre><p>我们一眼就能够看出这段代码的逻辑：有一个obfucate方法，这个方法会打出一行日志，日志内容为“I’m obfuscator!”。</p><p>在JavaScript中，空格、换行、缩进这些内容，只是为了让代码看起来更清晰。所以，这些对代码没有影响，只是便于开发人员查看的内容，完全可以去除。这样一来，这段代码我们就可以改成下面这样：</p><pre><code>function obfuscate(){console['log']('I'm obfuscator!');}obfuscate();\n</code></pre><p>把代码压缩成一行后，黑客想要阅读就已经比较吃力。在此基础上，我们还可以让它变得更“难看”。实际上，JavaScript中的方法名和变量名也不影响逻辑执行，只是开发人员用来表示方法和变量的含义，完全可以用没有意义的随机字符替代。随机字符代替后的效果如下：</p><pre><code>function _0xc648a(){console['log']('I\\x27m\\x20obfuscator!');}_0xc648a();\n</code></pre><h3>2.简单逻辑复杂化</h3><p>对于上面这段无序化后的代码，只要黑客稍微花点心思去阅读，再配合一些JavaScript格式化的工具，也能够弄明白它的逻辑。归根结底还是因为这段代码“太简单了”。那么，我们是不是能够让原本简单的代码变得复杂呢？实现方法有很多种，我们先来看最简单的一种：加入无意义的代码。</p><p>我们还是以最开始的简单代码为例。为了方便你查看，我把前面那段简单代码重新贴在这里。</p><pre><code>function obfuscate() {\n  console.log(&quot;I'm obfuscator!&quot;);\n}\nobfuscate();\n</code></pre><p>在这段代码中，本来输出的日志就是一个固定的字符串“I’m obfuscator!”。但是，我们可以先将这段字符串放在一个字典中，然后再通过字典去获取字符串。修改后的效果如下：</p><pre><code>function obfuscate() {\n    var _0x16df9a = { 'HXGCi': 'I\\x27m\\x20obfuscator!' };\n    console['log'](_0x16df9a['HXGCi']);\n}\nobfuscate();\n</code></pre><p>这就是通过字典等形式，将常量变成变量的混淆方法。在此基础上，我们还可以加入一些无意义的switch、if和while语句，进一步将代码复杂化。</p><p>除了加入一些无意义的代码，我们还可以加入一些不会被执行的代码，让混淆的结果更有威慑力。比如下面这段代码：</p><pre><code>(function (_0x2177d9, _0x1442cc) {\n    var _0xb84613 = function (_0x5a2b5f) {\n        while (--_0x5a2b5f) {\n            _0x2177d9['push'](_0x2177d9['shift']());\n        }\n    };\n    _0xb84613(++_0x1442cc);\n}(_0x1808, 0x1ea));\nfunction obfuscate() {\n    console['log']('I\\x27m\\x20obfuscator!');\n}\nobfuscate();\n</code></pre><p>在这段代码中，中间的function (_0x2177d9, _0x1442cc)就不会被执行，它的目的仅仅是让代码看起来更复杂而已。</p><h3>3.固定字符动态化</h3><p>在我们前面说的这几个混淆代码的例子中，关键字符串“I’m obfuscator!”始终都存在。如果黑客关心的只是这个字符串，那它通过搜索就可以很快定位到。也就是说，通过前面几种方式混淆的前端代码，其中的接口、密钥和签名等信息，黑客还是很容易就可以获取到。</p><p>既然关键字符串“存在”于代码中就不安全，那有没有方法可以让关键字符串“消失”呢？我们可以通过加入一些逻辑，让这些关键字符串只有在实际运行的时候，才会被计算出来。</p><p>最简单、最直接的思路就是，我们可以将关键字符串改成多个字符串拼接的形式。效果如下：</p><pre><code>function obfuscate() {\n    console['log']('I\\x27m\\x20o' + 'bfusc' + 'ator!');\n}\nobfuscate();\n</code></pre><p>通过这样改写的方式，黑客就没有办法通过搜索功能，找到“I’m obfuscator!”的位置了。</p><p>但是，这种简单分割字符串的方式很容易被发现。所以，我们可以将这些字符串从它原本的位置拿出来，通过更复杂的方法（如：数组的引用、方法的调用等）来获取。效果如下：</p><pre><code>var _0x5e96 = [\n    'bfusc',\n    'ator!',\n    'log',\n    'I\\x27m\\x20o'\n];\n(function (_0x520fe6, _0x366376) {\n    var _0x38fe5f = function (_0x456d44) {\n        while (--_0x456d44) {\n            _0x520fe6['push'](_0x520fe6['shift']());\n        }\n    };\n    _0x38fe5f(++_0x366376);\n}(_0x5e96, 0x15e));\nvar _0x40ca = function (_0x520fe6, _0x366376) {\n    _0x520fe6 = _0x520fe6 - 0x0;\n    var _0x38fe5f = _0x5e96[_0x520fe6];\n    return _0x38fe5f;\n};\nfunction obfuscate() {\n    console[_0x40ca('0x0')](_0x40ca('0x1') + _0x40ca('0x2') + _0x40ca('0x3'));\n}\nobfuscate();\n</code></pre><p>这样一来，黑客想要快速找到_0x40ca(‘0x1’)具体指什么，就需要花上一番功夫了。</p><h3>4.反调试</h3><p>前面3种技术都是直接对源码进行混淆。但是，大多数情况下，黑客在分析代码的时候，不是直接阅读源码，而是通过调试的方法在JavaScript代码运行过程中，获取实际的代码执行方向以及变量的值。因此，为了保护前端安全，我们要采用反调试技术。在JavaScript中，主要有两种方法可以对抗调试：域名锁定和无限断点。下面，我们一一来看。</p><p><strong>第一种是域名锁定。</strong></p><p>当黑客来想要分析一个网页的时候，通常会将代码下载下来放到本地运行。但是，我们更希望这个分析过程仍然发生在当前的域名下，这样我们就能够通过请求去分析黑客到底干了什么。因此，我们可以在JavaScript中加入一段域名判断的逻辑。这样一来，当JavaScript运行的环境是localhost（本地主机）域名，或者其他未知的域名时，JavaScript就会产生错误，黑客就无法正常运行下载后的JavaScript文件了。</p><p>我来举个例子。在JavaScript中，我们可以通过window.location.host获取当前域名，然后判断这个域名是否等于网站的域名，比如server.com。如果不等于的话， 说明JavaScript不是通过正常访问域名的形式执行的。因此，JavaScript会直接返回，不执行后续的逻辑。代码如下：</p><pre><code>function obfuscate() {\n  if(window.location.host != 'server.com'){\n    return;\n  }\n  console.log(&quot;I'm obfuscator!&quot;);\n}\nobfuscate();\n</code></pre><p><strong>第二种是无线断点。</strong></p><p>在调式技术中，我们最常用到的功能就是断点。通过设置断点，我们可以让程序停留在某一个代码或者指令上，方便查看停留的这个时刻中各个变量的具体值是什么。</p><p>在JavaScript中，debugger指令就是用来添加断点的。所以，在反调试的时候，我们可以在JavaScript中开启一个单独的线程，来循环调用debugger。这样一来，如果黑客进入到调试模式，就会不断地停滞在无意义的断点处，从而无法正常调试。在正常运行JavaScript的时候，debugger不会生效，也就不会影响用户的正常使用。</p><p>除此之外，针对提供了额外的JavaScript接口的浏览器（比如Chrome），我们可以通过在JavaScript中检测开发者工具是否开启等特征，来实现反调试。开发者工具是开发人员在调试过程中必须使用的工具，一旦开启，基本就代表已经进入调试状态了。因此，我们可以在检测到开发者工具开启的时候，不去执行正常的JavaScript逻辑，这样就能够起到反调试的作用了。</p><p>好了，说完了这4种混淆技术，我要提醒你一点。这些混淆技术不是独立使用的，而应该是组合使用的。完整的混淆流程应该是这样的：首先，我们可以在原有的JavaScript代码中加入反调试的逻辑，然后通过简单逻辑复杂化和固定字符动态化的方法，隐藏原有的逻辑和反调试的逻辑。最后，通过清晰代码无序化，将所有的额外信息进行剔除，最终将代码变成了压缩成一行的JavaScript文件。</p><h2>混淆技术有什么负面影响？</h2><p>尽管混淆技术是保护前端安全的重要技术，但混淆技术改变了前端代码，就不可避免会影响前端的功能。这也是混淆始终达不到理想状态的一个主要原因。对于JavaScript的混淆来说，它的负面影响主要包括三个方面：增加体积、影响性能和无法分析报错。</p><p><strong>混淆带来的最直接影响就是增加代码体积</strong>。在固定字符动态化的例子中，原本简单的4行代码经过混淆之后，变成了几十行。如果应用更复杂一些，一个几KB的JavaScript文件经过混淆之后变成几百KB，也是很正常的事情。这样一来，用户网络加载一个大型的JavaScript文件，所面对的消耗、加载时的延迟以及运行时的内存等都会有明显增长。</p><p>除了增加代码体积以外，<strong>混淆还会增加额外的执行逻辑，降低代码执行的速度影响性能</strong>。比如说，console.log本来只是一个简单的指令，但是在混淆之后，JavaScript需要对它进行数据的取值、索引的计算以及字符串的拼接等操作。这样一来，混淆后的代码执行速度必然会下降。</p><p>而且这些无用的操作，事实上是可以无限添加的。因此，在混淆的时候，如何把控复杂化的程度，是我们需要谨慎考量和测试的。</p><p>还有一点是不可避免的，那就是<strong>混淆后的代码，不仅黑客无法阅读，你其实也无法阅读</strong>。在混淆之前，如果前端出现错误，我们可以直接通过错误信息定位错误；但是在混淆之后，错误信息会变得“很难看”，而且代码只会剩下一行，我们也就无法定位了。</p><p>你还需要注意一点：<strong>混淆不可能让代码变得完全不可读</strong>。因为你的代码最终需要执行在用户终端，而执行的条件就是终端能够读懂代码。以JavaScript为例，黑客完全可以自己定义一个浏览器来执行JavaScript代码。这样一来，尽管黑客没办法直接阅读JavaScript文件，但仍然可以通过浏览器执行的指令集和内存环境来进行分析。</p><h2>总结</h2><p>好了，今天的加餐就到这里。</p><p>我们主要以JavaScript为例，梳理了混淆的主要技术和思路。虽然通过混淆，我们能大大增加黑客分析前端代码的难度，但是，混淆同样会给我们的正常工作和应用的执行增加难度，带来负面影响。所以，我们在使用混淆技术的时候，必须要经过谨慎的考量和测试。<br>\n<img src=\"https://static001.geekbang.org/resource/image/e6/30/e66c15067eed8691b6056c2e115ec830.jpg?wh=2252*1852\" alt=\"\"></p><h2>思考题</h2><p>最后，还是给你留一道思考题。</p><p>我们知道，不同的语言和环境，其混淆的技术和思路都存在各自的特点。你可以试着分析一下，在你熟悉的语言和环境中，有哪些方式可以用来进行代码混淆？</p><p>欢迎留言和我分享你的思考和疑惑，也欢迎你把文章分享给你的朋友。我们下一讲再见！</p>","comments":[{"had_liked":false,"id":174976,"user_name":"岑小白","can_delete":false,"product_type":"c1","uid":1159644,"ip_address":"","ucode":"F57DDAA2D80AEA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/dc/53f7db1e.jpg","comment_is_top":false,"comment_ctime":1580485022,"is_pvip":false,"replies":[{"id":"68167","content":"也不完全是，混淆之后只是报错信息不可用了。但是你自己埋入的日志还是可以看到的，所以想要debug的话，只能依靠自己埋入足够充分的错误判断和日志了。","user_name":"作者回复","user_name_real":"captain","uid":"1012580","ctime":1580714664,"ip_address":"","comment_id":174976,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14465386910","product_id":100041701,"comment_content":"😂 前端 debug 本来就是史诗级难度，这样混淆之后基本上自绝于 debug 了。保密性要求没那么高的项目一般也就 ugly 一下了。这样看来，安全也是需要极大成本的啊。","like_count":2,"discussions":[{"author":{"id":1012580,"avatar":"","nickname":"captain","note":"","ucode":"471A8412D923EB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482587,"discussion_content":"也不完全是，混淆之后只是报错信息不可用了。但是你自己埋入的日志还是可以看到的，所以想要debug的话，只能依靠自己埋入足够充分的错误判断和日志了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580714664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176361,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1581043332,"is_pvip":false,"replies":[{"id":"68887","content":"测试流程通常要求的是测试环境和线上环境代码一致，不然容易出现因混淆或其他因素的代码改动，导致测试环境正常，线上环境却出BUG的情况。当然，如果线上BUG能够稳定复现的花，其实还是可以通过在本地原始代码调试，去进行DEBUG的。不过我也经常遇到，线上的偶发BUG，不知道崩溃的原因，导致无法排查的情况。","user_name":"作者回复","user_name_real":"captain","uid":"1012580","ctime":1581401027,"ip_address":"","comment_id":176361,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10170977924","product_id":100041701,"comment_content":"      个人觉得有一个还不错的方式不过仅仅用在最关键的地方或场合：写2套代码或本地测试环境留注释完整的源代码，线上环境把相关注释全部祛除。线上出现问题时，问题放到测试环境调试，毕竟线上代码的修改必须经过测试环境测试才能提交生产环境；测试系统有完整注释的源代码便于测试和解决问题就能解决问题。<br>        这是个人学完今天课程的一点扩展的想法：唯一的代价就是稍微多花点时间；不过能真正解决问题不再乎那几分钟的删除注释的时间。谢谢老师的分享。","like_count":2,"discussions":[{"author":{"id":1012580,"avatar":"","nickname":"captain","note":"","ucode":"471A8412D923EB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483086,"discussion_content":"测试流程通常要求的是测试环境和线上环境代码一致，不然容易出现因混淆或其他因素的代码改动，导致测试环境正常，线上环境却出BUG的情况。当然，如果线上BUG能够稳定复现的花，其实还是可以通过在本地原始代码调试，去进行DEBUG的。不过我也经常遇到，线上的偶发BUG，不知道崩溃的原因，导致无法排查的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581401027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232451,"user_name":"longsang","can_delete":false,"product_type":"c1","uid":1746831,"ip_address":"","ucode":"27AE9C7EBB24A2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/a7/8f/670756ee.jpg","comment_is_top":false,"comment_ctime":1594007015,"is_pvip":false,"replies":[{"id":"85950","content":"加固做得好的js，都不支持下载运行，需要线上环境调试，改代码没那么简单～","user_name":"作者回复","user_name_real":"captain","uid":"1012580","ctime":1594172117,"ip_address":"","comment_id":232451,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5888974311","product_id":100041701,"comment_content":"看着老师说的无限debug，试了一下，可以通过如下的代码实现：<br>    &lt;script&gt;<br>        function tryDebugger() {<br>            try {<br>                if ((&#39;&#39; + 0 &#47; 0)) {<br>                    debugger<br>                }<br>            } catch (err) {}<br>        }<br>        setInterval(tryDebugger, 4000)<br>    &lt;&#47;script&gt;<br>嗯，如果一打开控制台，就跳到debugger界面，想想还是很恶心的<br>但实际上，破解方法也非常简单： CTRL + F ’debugger&#39; ， 替换为 ‘’ 2333333","like_count":1,"discussions":[{"author":{"id":1012580,"avatar":"","nickname":"captain","note":"","ucode":"471A8412D923EB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500650,"discussion_content":"加固做得好的js，都不支持下载运行，需要线上环境调试，改代码没那么简单～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594172117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175564,"user_name":"darktemple9","can_delete":false,"product_type":"c1","uid":1134637,"ip_address":"","ucode":"277D806B834E86","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/2d/46203749.jpg","comment_is_top":false,"comment_ctime":1580744610,"is_pvip":false,"replies":[{"id":"68885","content":"一般是先会定义一个标准，即应用的体积和性能最差能到什么程度，然后按照这个标准，去调整混淆的强度。大部分的混淆插件都能够去配置混淆的强度。","user_name":"作者回复","user_name_real":"captain","uid":"1012580","ctime":1581400517,"ip_address":"","comment_id":175564,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5875711906","product_id":100041701,"comment_content":"webpack打包可以用uglify插件，问题是混淆强度怎么确定了，特别是业务看重体积和性能的情况下，这些策略怎么上呢？","like_count":1,"discussions":[{"author":{"id":1012580,"avatar":"","nickname":"captain","note":"","ucode":"471A8412D923EB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482801,"discussion_content":"一般是先会定义一个标准，即应用的体积和性能最差能到什么程度，然后按照这个标准，去调整混淆的强度。大部分的混淆插件都能够去配置混淆的强度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581400517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345585,"user_name":"Geek_145846","can_delete":false,"product_type":"c1","uid":2530478,"ip_address":"","ucode":"1DA77D13A8F19E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoAlkIjytYG8MqOtDf7n7pF3rXJnoMNL9ebRXluPvGh2e2A9TxyMoQxPyYQ1dInAFIeltwo8zuvhg/132","comment_is_top":false,"comment_ctime":1652413336,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652413336","product_id":100041701,"comment_content":"混淆代码真的是杀敌100自损90的方法，有没有更好的方法呢","like_count":0},{"had_liked":false,"id":323271,"user_name":"Bob","can_delete":false,"product_type":"c1","uid":1007005,"ip_address":"","ucode":"1A67FF9DC1FE1B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/9d/4ee1faf4.jpg","comment_is_top":false,"comment_ctime":1637809723,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637809723","product_id":100041701,"comment_content":"代码自带混淆效果就不用这么麻烦了:P","like_count":0},{"had_liked":false,"id":302827,"user_name":"亚林","can_delete":false,"product_type":"c1","uid":1018972,"ip_address":"","ucode":"4A5A6D24314B79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","comment_is_top":false,"comment_ctime":1626400216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626400216","product_id":100041701,"comment_content":"iOS和Android混淆太难了","like_count":0},{"had_liked":false,"id":220861,"user_name":"皮特尔","can_delete":false,"product_type":"c1","uid":1017161,"ip_address":"","ucode":"313862C91DD325","user_header":"https://static001.geekbang.org/account/avatar/00/0f/85/49/585c69c4.jpg","comment_is_top":false,"comment_ctime":1590330419,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590330419","product_id":100041701,"comment_content":"总结一下：<br>1. 清晰代码无序化；<br>2. 简单逻辑复杂化；<br>3. 固定字符动态化；<br>4. 反调试。<br><br>这些方法主要用于前端Javascript代码，其他平台，比如 iOS、Android，都有各自的反调试方法。","like_count":0},{"had_liked":false,"id":174878,"user_name":"iLeGeND","can_delete":false,"product_type":"c1","uid":1055475,"ip_address":"","ucode":"4055A628A6E97C","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/f3/41d5ba7d.jpg","comment_is_top":false,"comment_ctime":1580445093,"is_pvip":false,"replies":[{"id":"68164","content":"网上有很多公开的平台和工具可以帮你作混淆，搜索一下，直接使用就好了。","user_name":"作者回复","user_name_real":"captain","uid":"1012580","ctime":1580714220,"ip_address":"","comment_id":174878,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580445093","product_id":100041701,"comment_content":"混淆具体是怎么操作的呢 不会是手动吧","like_count":0,"discussions":[{"author":{"id":1012580,"avatar":"","nickname":"captain","note":"","ucode":"471A8412D923EB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482556,"discussion_content":"网上有很多公开的平台和工具可以帮你作混淆，搜索一下，直接使用就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580714220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174874,"user_name":"LEON","can_delete":false,"product_type":"c1","uid":1109922,"ip_address":"","ucode":"58F7AF5302FCAD","user_header":"https://static001.geekbang.org/account/avatar/00/10/ef/a2/6ea5bb9e.jpg","comment_is_top":false,"comment_ctime":1580444154,"is_pvip":true,"replies":[{"id":"68163","content":"1、浏览器不支持JS脚本，那就只能是静态HTML页面了。这种页面里面没有逻辑，把注释和隐藏信息去掉就行了。<br>2、每个语言都有各自的混淆技术，所以这里没提。比如iOS自带反编译工具，安卓有各类加固平台可以使用。","user_name":"作者回复","user_name_real":"captain","uid":"1012580","ctime":1580714082,"ip_address":"","comment_id":174874,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580444154","product_id":100041701,"comment_content":"您好，如果浏览器前端不支持JS脚本怎么办？只有JS脚本可以进行前端混淆吗？还有什么技术可以进行前端混淆？谢谢。","like_count":0,"discussions":[{"author":{"id":1012580,"avatar":"","nickname":"captain","note":"","ucode":"471A8412D923EB","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482553,"discussion_content":"1、浏览器不支持JS脚本，那就只能是静态HTML页面了。这种页面里面没有逻辑，把注释和隐藏信息去掉就行了。\n2、每个语言都有各自的混淆技术，所以这里没提。比如iOS自带反编译工具，安卓有各类加固平台可以使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580714082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035165,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cb/9d/2bc85843.jpg","nickname":"　　　　　　　鸟人","note":"","ucode":"E504B22F336035","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":193099,"discussion_content":"我记得以前访问国外网站  他禁用f12调试查看  请问这是怎么实现的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583123878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}