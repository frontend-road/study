{"id":741039,"title":"第 14 章 LNMP环境配置(2)","content":"<h2 id=\"nav_point_294\">14.4 Nginx配置</h2>\n<p>这一节所讲述的内容为工作中使用较多的部分，你一开始学起来会比较吃力，因为不太明白很多概念是什么意思。阿铭的建议是，一定要跟着去动手操作，根据结果来理解需求的本质，只要理解了自然就明白了。</p>\n<h3 id=\"nav_point_295\">14.4.1 默认虚拟主机</h3>\n<p>先来解释“虚拟主机”。早期的Linux服务器上，一个服务器只能运行一个网站，也就是说只能跑一个域名。但随着技术的发展，一个服务器上可以跑多个域名，这样就帮我们节省了成本。其实，这里的服务器就叫作主机，早期一个主机对应一个站点。现在不同了，一个主机可以跑多个站点，所以就有了虚拟主机的概念。我们可以把一台服务器虚拟出多个主机出来，这样就实现了一台服务器跑多个站点。</p>\n<p>既然一台服务器上可以有多个虚拟主机，每个虚拟主机都会定义一个域名（当然也可以定义多个），那么只要把这个域名解析指向到该台服务器，我们自然就可以访问这个站点了。说到这儿，你可能又有新的问题：什么叫解析指向？如果你会用浏览器访问一个站点，那么肯定不难理解下面阿铭的解释。咱们访问一个网站，需要先在浏览器里输入域名，然后就能访问到网站内容了。这个过程是需要浏览器和远程服务器通信的，网站内容就是从服务器上读取到的。而这个服务器在哪儿是由你访问的域名来决定的，而域名之所以能决定服务器在哪里，就是因为这个域名做了解析指向。对服务器的IP地址做域名解析，这个行为是由DNS服务器来完成的。</p><!-- [[[read_end]]] -->\n<p>假如你访问的域名指向了你的服务器，而你又在这台服务器上做了配置标记了这个域名（接下来阿铭会讲解如何标记），这样这个域名就能被正常访问。但如果没有在服务器上给这个域名做标记，会发生什么呢？按理说，没有做标记的域名是不合法的，是不能正常返回结果的。</p>\n<p>上面讲了那么多关于域名的东西，阿铭的目的就是让你更容易理解“默认虚拟主机”的概念。Nginx是支持多个虚拟主机的，也就是说可以在一个服务器上运行多个站点，标记多个域名。但如果没有标记的域名也指向了这台服务器，那总得有处理这个域名的一个虚拟主机吧，这个虚拟主机就叫作“默认虚拟主机”。通俗点讲，你的服务器上有很多域名，很多站点，很多虚拟主机，这些域名是在Nginx的配置文件中做过标记的，是“名花有主”、一一对应的，每个域名都能对应着自己的虚拟主机。但是，有一个特殊的域名也指向了服务器，却没有跟它对应的虚拟主机。这时候，Nginx就会把这个域名直接丢给一个特殊的虚拟主机来处理，这个特殊的虚拟主机就是“默认虚拟主机”。</p>\n<p>在Nginx中第一个被加载的虚拟主机就是默认主机。当然，我们也可以用一个配置来标记默认虚拟主机。也就是说，如果没有这个标记，第一个虚拟主机就为默认虚拟主机。</p>\n<p>修改主配置文件nginx.conf，在结束符号<code>}</code>前面加入一行配置，修改内容如下：</p>\n<pre class=\"code-rows\"><code> include vhost/*.conf;\n}</code></pre>\n<p>意思是会加载 /usr/local/nginx/conf/vhost/ 下面的所有以 .conf结尾的文件，这样我们就可以把所有虚拟主机配置文件都放到vhost目录下面了。执行如下命令创建虚拟主机配置文件：</p>\n<pre class=\"code-rows\"><code># mkdir /usr/local/nginx/conf/vhost\n# cd /usr/local/nginx/conf/vhost\n# vim default.conf // 写入如下内容\nserver\n{\n listen 80 default_server; # 有这个default_server标记的就是默认虚拟主机\n server_name aaa.com;\n index index.html index.htm index.php;\n root /data/nginx/default;\n}\n# /usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n# /usr/local/nginx/sbin/nginx -s reload // 更改配置文件后，重载\n# mkdir -p /data/nginx/default\n# echo \"default_server\" &gt; /data/nginx/default/index.html // 创建索引页\n# curl -x127.0.0.1:80 aaa.com // 访问aaa.com\ndefault_server\n# curl -x127.0.0.1:80 1212.com // 访问一个没有定义过的域名，也会访问到aaa.com\ndefault_server</code></pre>\n<h3 id=\"nav_point_296\">14.4.2 用户认证</h3>\n<p>再来创建一个新的虚拟主机：</p>\n<pre class=\"code-rows\"><code># cd /usr/local/nginx/conf/vhost/\n# vim test.com.conf // 加入如下内容\nserver\n{\n listen 80;\n server_name test.com;\n index index.html index.htm index.php;\n root /data/nginx/test.com;\n\n location /\n {\n auth_basic \"Auth\";\n auth_basic_user_file /usr/local/nginx/conf/htpasswd;\n }\n}\n\n# yum install -y httpd-tools // 安装httpd-tools，目的是为了安装下面的htpasswd命令\n# htpasswd -cm /usr/local/nginx/conf/htpasswd aming // 创建aming用户\nNew password:\nRe-type new password:\nAdding password for user aming\n// htpasswd命令为创建用户的工具，-c为create（创建），-m指定密码加密方式为MD5，\n// / usr/local/nginx/conf/htpasswd为密码文件，aming为要创建的用户。第一次执行该命令需要加-c，\n// 第二次再创建新的用户时，就不用加-c了，否则密码文件会被重置，之前的用户被清空\n# /usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n# /usr/local/nginx/sbin/nginx -s reload</code></pre>\n<p>核心配置语句就两行，<code>auth_basic</code>打开认证，<code>auth_basic_user_file</code>指定用户密码文件，当然前提是这个用户密码文件存在。而生成用户密码文件的工具需要借助httpd的<code>htpasswd</code>，Nginx不自带这个工具。下面可以使用<code>curl</code>命令来验证：</p>\n<pre class=\"code-rows\"><code># mkdir /data/nginx/test.com\n# echo \"test.com\" &gt; /data/nginx/test.com/index.html\n# curl -I -x127.0.0.1:80 test.com\nHTTP/1.1 401 Unauthorized\nServer: nginx/1.18.0\nDate: Sat, 27 Jun 2020 02:07:38 GMT\nContent-Type: text/html\nContent-Length: 179\nConnection: keep-alive\nWWW-Authenticate: Basic realm=\"Auth\"\n说明：状态码为401说明，该网站需要验证。\n# curl -uaming:lishiming -x127.0.0.1:80 test.com // 使用curl的-u指定用户名密码就可以正常访问了\ntest.com</code></pre>\n<p>下面我们在Windows上来访问并验证用户认证。首先打开Windows的hosts文件，该文件类似Linux上的/etc/hosts。Windows上的hosts文件所在路径为C:\\Windows\\System32\\drivers\\etc\\hosts，第一次编辑它会提示用什么方式打开，选择“记事本”或者“写字板”都可以。在最下面增加一行：并加入一行（你的IP地址可能和阿铭的不一样，请自行更改）：</p>\n<pre class=\"code-rows\"><code>192.168.72.128 test.com</code></pre>\n<p>然后在浏览器中访问test.com，出现如图14-1所示的验证对话框。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100013/image00426.jpeg\" alt=\"{%}\" /></p>\n<p><strong>图14-1 验证</strong></p>\n<p>输入用户名aming和其密码，就可以访问了。如果是针对某个目录做用户认证，需要修改<code>location</code>后面的路径：</p>\n<pre class=\"code-rows\"><code>location /admin/\n{\n auth_basic \"Auth\";\n auth_basic_user_file /usr/local/nginx/conf/htpasswd;\n}</code></pre>\n<h3 id=\"nav_point_297\">14.4.3 域名或链接重定向</h3>\n<p>重定向也可以叫作跳转，这个用法比较普遍，一个网站可能会有多个域名，比如小明公司的网站可以通过两个域名访问：域名A和域名B。用域名A访问的时候，浏览器里面的网址直接变成了域名B，这其实就是域名跳转的过程。域名跳转有什么作用呢？在阿铭看来主要有两方面：第一，一个站点有多个域名会对SEO有影响，说白了就是对百度搜索关键词的排名有影响，如果把多个域名全部跳转到一个指定的域名，这样以这个域名为中心，就可以把权重集中在这个域名上，搜索关键词的排名也就靠前了；第二，如果之前的某个域名不再使用了，但是搜索引擎还留着之前老域名的链接，这意味着用户可能会搜到我们的网站并且单击老的域名，故需要把老域名做个跳转跳到新域名，这样用户搜索的时候，也可以访问到网站。</p>\n<p>下面阿铭将test1.com和test2.com重定向到test.com，配置如下：</p>\n<pre class=\"code-rows\"><code># vi test.com.conf // 更改为如下内容\nserver\n{\n listen 80;\n server_name test.com test1.com test2.com;\n index index.html index.htm index.php;\n root /data/nginx/test.com;\n\n if ($host != 'test.com' ) {\n rewrite ^/(.*)$ http://test.com/$1 permanent;\n }\n\n}</code></pre>\n<p>在Nginx配置中，<code>server_name</code>后面可以跟多个域名，<code>permanent</code>为永久重定向，状态码为301。另外还有一个常用的<code>redirect</code>，叫作临时重定向，状态码为302。那么什么时候使用301或者302呢？阿铭给你一个简单的法则：如果跳转域名就用301，如果仅跳转链接就用302。测试过程如下：</p>\n<pre class=\"code-rows\"><code># /usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n# /usr/local/nginx/sbin/nginx -s reload\n# curl -x127.0.0.1:80 test1.com/123.txt -I\nHTTP/1.1 301 Moved Permanently\nServer: nginx/1.18.0\nDate: Sat, 27 Jun 2020 02:32:05 GMT\nContent-Type: text/html\nContent-Length: 169\nConnection: keep-alive\nLocation: http://test.com/123.txt</code></pre>\n<p>下面再来看看链接跳转。有一个需求，需要将http://test.com/a.html跳转到http://test.com/b.html，看看如何实现吧。测试过程如下：</p>\n<pre class=\"code-rows\"><code># vi test.com.conf // 更改为如下内容\nserver\n{\n listen 80;\n server_name test.com;\n index index.html index.htm index.php;\n root /data/nginx/test.com;\n rewrite /a.html /b.html redirect;\n}\n# /usr/local/nginx/sbin/nginx –t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n# /usr/local/nginx/sbin/nginx -s reload\n# curl -I -x127.0.0.1:80 test.com/a.html\nHTTP/1.1 302 Moved Temporarily\nServer: nginx/1.18.0\nDate: Sat, 27 Jun 2020 02:38:07 GMT\nContent-Type: text/html\nContent-Length: 145\nLocation: http://test.com/b.html\nConnection: keep-alive</code></pre>\n<p>如果是相同域名的链接跳转，可以省略域名，只写链接，比如本例中阿铭只写了/a.html和/b.html。最终测试出来状态码为302，这是因为我们使用了临时重定向的控制<code>flag rediect</code>。</p>\n<h3 id=\"nav_point_298\">14.4.4 Nginx的访问日志</h3>\n<p>访问日志作用很大，不仅可以记录网站的访问情况，还可以在网站有异常发生时帮助我们定位问题，比如网站被攻击时，可以通过查看日志看到一些规律。先来看看Nginx的日志格式：</p>\n<pre class=\"code-rows\"><code># grep -A2 log_format /usr/local/nginx/conf/nginx.conf\n log_format combined_realip '$remote_addr $http_x_forwarded_for [$time_local]'\n ' $host \"$request_uri\" $status'\n ' \"$http_referer\" \"$http_user_agent\"';</code></pre>\n<p>Nginx需要在主配置文件中定义日志格式，然后在虚拟主机里面调用。配置文件中的<code>combined_realip</code>为日志格式的名字，后面可以调用它；<code>$remote_addr</code>为访问网站的用户的出口IP；<code>$http_x_forwarded_for</code>为代理服务器的IP，如果使用了代理，则会记录代理的IP；<code>$time_local</code>为当前的时间；<code>$host</code>为访问的主机名；<code>$request_uri</code>为访问的URL地址；<code>$status</code>为状态码；<code>$http_referer</code>为<code>referer</code>地址；<code>$http_user_agent</code>为<code>user_agent</code>。</p>\n<p>然后再到虚拟主机配置文件中指定访问日志的路径：</p>\n<pre class=\"code-rows\"><code># vi test.com.conf // 修改配置文件\nserver\n{\n listen 80;\n server_name test.com test1.com test2.com;\n index index.html index.htm index.php;\n root /data/nginx/test.com;\n\n if ($host != 'test.com' ) {\n rewrite ^/(.*)$ http://test.com/$1 permanent;\n }\n access_log /tmp/1.log combined_realip;\n}</code></pre>\n<p>使用<code>access_log</code>来指定日志的存储路径，最后面指定日志的格式名字，测试过程如下：</p>\n<pre class=\"code-rows\"><code># /usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n# /usr/local/nginx/sbin/nginx -s reload\n# curl -x127.0.0.1:80 test.com/111\n&lt;html&gt;\n&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;\n&lt;hr&gt;&lt;center&gt;nginx/1.18.0&lt;/center&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n# cat /tmp/1.log\n127.0.0.1 - [27/Jun/2020:10:47:10 +0800] test.com \"/111\" 404 \"-\" \"curl/7.61.1\"</code></pre>\n<p>在13.8.1节中，阿铭介绍系统日志/var/log/messages时，提到过其支持日志切割，即每周一个日志，这样做的目的是为了防止日志无限制增大。同样地，Nginx的日志也需要做切割，要想切割Nginx日志需要借助系统的切割工具或者自定义脚本。在这里，阿铭提供一个Nginx的日志切割脚本：</p>\n<pre class=\"code-rows\"><code># vim /usr/local/sbin/nginx_log_rotate.sh // 写入如下内容\n#! /bin/bash\n## 假设nginx的日志存放路径为/data/logs/\nd=`date -d \"-1 day\" +%Y%m%d`\nlogdir=\"/data/logs\"\nnginx_pid=\"/usr/local/nginx/logs/nginx.pid\"\ncd $logdir\nfor log in `ls *.log`\ndo\n mv $log $log-$d\ndone\n/bin/kill -HUP `cat $nginx_pid`</code></pre>\n<p>写完脚本后，还需要增加任务计划：</p>\n<pre class=\"code-rows\"><code>0 0 * * * /bin/bash /usr/local/sbin/nginx_log_rotate.sh</code></pre>\n<p>该脚本会在0点0分执行，其大概的意思是：修改 /data/logs/ 下所有访问日志的名字，改为以昨天日期为后缀的名字，比如test.com.log-20200530，改完名字后还要重新生成新的日志，这里使用kill -HUP pid来完成。</p>\n<h3 id=\"nav_point_299\">14.4.5 配置静态文件不记录日志并添加过期时间</h3>\n<p>一个网站会有很多元素，尤其是图片、JS、CSS等静态的文件非常多，用户每请求一个页面就会访问诸多的图片、JS等静态元素，这些元素的请求会被记录在日志中。如果一个站点访问量很大，那么访问日志文件增长会非常快，一天就可以达到几吉字节（GB）。这不仅会对服务器的磁盘空间造成影响，更重要的是会影响磁盘的读写速度。阿铭一开始也说了，访问日志很重要，我们又不能不记录。还好把这些巨量的静态元素请求记录到日志里的意义并不大，所以可以限制记录这些静态元素，并且把日志按天归档，一天一个日志，这样也可以防止单个日志文件过大。Nginx的日志如果不记录静态文件，那么其配置并不复杂，虚拟主机配置文件改写如下：</p>\n<pre class=\"code-rows\"><code>vi\nserver\n{\n listen 80;\n server_name test.com test1.com test2.com;\n index index.html index.htm index.php;\n root /data/nginx/test.com;\n\n if ($host != 'test.com' ) {\n rewrite ^/(.*)$ http://test.com/$1 permanent;\n }\n location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n {\n expires 7d;\n access_log off;\n }\n location ~ .*\\.(js|css)$\n {\n expires 12h;\n access_log off;\n }\n access_log /tmp/1.log combined_realip;\n}</code></pre>\n<p>使用<code>location ~</code>可以指定对应的静态文件，<code>expires</code>配置过期时间，而<code>access_log</code>配置为<code>off</code>就可以不记录访问日志了。平时我们访问一个网站时，很多元素为静态的小图片，那这些小图片完全可以缓存在咱们的计算机里，这样再次访问该站点时，速度就会很快。那到底能缓存多久呢？如果服务器上的某个图片更改了，那么应该访问新的图片才对。这就涉及一个静态文件缓存时长的问题，也叫作“缓存过期时间”。下面阿铭来模拟一下：</p>\n<pre class=\"code-rows\"><code># /usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n# echo \"111111111111\" &gt; /data/nginx/test.com/1.js // 创建JS文件\n# echo \"2222222222222\" &gt; /data/nginx/test.com/2.jpg // 创建JPG文件\n# touch /data/nginx/test.com/1.jss // 创建一个对比的文件\n# curl -I -x127.0.0.1:80 test.com/1.js // 访问JS类型的文件，缓存过期时间为12小时\nHTTP/1.1 200 OK\nServer: nginx/1.18.0\nDate: Sun, 28 Jun 2020 13:44:07 GMT\nContent-Type: application/javascript\nContent-Length: 13\nLast-Modified: Sun, 28 Jun 2020 13:43:51 GMT\nConnection: keep-alive\nETag: \"5ef89e97-d\"\nExpires: Mon, 29 Jun 2020 01:44:07 GMT\nCache-Control: max-age=43200\nAccept-Ranges: bytes\n\n# curl -I -x127.0.0.1:80 test.com/2.jpg // 访问JPG类型的文件，缓存过期时间为7小时\nHTTP/1.1 200 OK\nServer: nginx/1.18.0\nDate: Sun, 28 Jun 2020 13:44:21 GMT\nContent-Type: image/jpeg\nContent-Length: 14\nLast-Modified: Sun, 28 Jun 2020 13:43:56 GMT\nConnection: keep-alive\nETag: \"5ef89e9c-e\"\nExpires: Sun, 05 Jul 2020 13:44:21 GMT\nCache-Control: max-age=604800\nAccept-Ranges: bytes\n\n# curl -I -x127.0.0.1:80 test.com/1.jss\nHTTP/1.1 200 OK\nServer: nginx/1.18.0\nDate: Sun, 28 Jun 2020 13:44:38 GMT\nContent-Type: application/octet-stream\nContent-Length: 0\nLast-Modified: Sun, 28 Jun 2020 13:44:01 GMT\nConnection: keep-alive\nETag: \"5ef89ea1-0\"\nAccept-Ranges: bytes</code></pre>\n<p>可以很清楚地看到<code>Cache-control</code>对应着缓存过期时间，另外也可以看一下访问日志：</p>\n<pre class=\"code-rows\"><code># cat /tmp/1.log\n127.0.0.1 - [27/Jun/2020:10:47:10 +0800] test.com \"/111\" 404 \"-\" \"curl/7.61.1\"\n127.0.0.1 - [28/Jun/2020:21:44:38 +0800] test.com \"/1.jss\" 200 \"-\" \"curl/7.61.1\"</code></pre>\n<p>虽然阿铭访问了JS以及JPG，但都没有记录到访问日志中，效果实现了。</p>\n<h3 id=\"nav_point_300\">14.4.6 Nginx防盗链</h3>\n<p>我们先来聊一个案例。2009年的时候，阿铭负责运维的一个业务5d6d（早已经死翘翘了）为免费论坛，谁都可以申请，期间有一个站长申请了一个站点专门来存放图片。由于缺少经验，阿铭并没有给该业务做防盗链，导致这个网站的图片随便被别的网站借用，以致该网站访问量巨大，最终业务带宽在一个月内飙升了300MB/s。当发现带宽异常时，我们通过抓包找到了对应的站点，随后给服务器做了防盗链，并且删除了有问题的图片，这样才把带宽恢复到正常值。但那个月的带宽费用确实让公司出血了。</p>\n<p>通过这个真实案例，你可以体会到做防盗链是多么有价值。防盗链，通俗讲，就是不让别人盗用你网站上的资源。这个资源，通常指的是图片、视频、歌曲、文档等。讲解防盗链配置之前，阿铭再给你讲述一下referer的概念，上面讲解日志格式时曾提到过它。你通过A网站的一个页面http://a.com/a.html里面的链接去访问B网站的一个页面http://b.com/b.html，那么这个B网站页面的referer就是http://a.com/a.html。也就是说，一个referer其实就是一个网址。Nginx配置防盗链由于和过期时间、不记录日志有部分重合，因此可以把两部分组合在一起：</p>\n<pre class=\"code-rows\"><code>location ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip|doc|pdf|gz|bz2|jpeg|bmp|xls)$\n{\n expires 7d;\n valid_referers none blocked server_names *.test.com ;\n if ($invalid_referer) {\n return 403;\n }\n access_log off;\n}</code></pre>\n<p>测试过程如下：</p>\n<pre class=\"code-rows\"><code># /usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n# /usr/local/nginx/sbin/nginx -s reload\n\n# curl -x127.0.0.1:80 -I -e \"http://aaa.com/1.txt\" test.com/2.jpg\nHTTP/1.1 403 Forbidden\nServer: nginx/1.18.0\nDate: Sun, 28 Jun 2020 14:06:14 GMT\nContent-Type: text/html\nContent-Length: 153\nConnection: keep-alive\n// 使用-e来定义referer，这个referer一定要以http://开头，否则不管用\n\n# curl -x127.0.0.1:80 -I -e \"http://test.com/1.txt\" test.com/2.jpg\nHTTP/1.1 200 OK\nServer: nginx/1.18.0\nDate: Sun, 28 Jun 2020 14:06:30 GMT\nContent-Type: image/jpeg\nContent-Length: 14\nLast-Modified: Sun, 28 Jun 2020 13:43:56 GMT\nConnection: keep-alive\nETag: \"5ef89e9c-e\"\nExpires: Sun, 05 Jul 2020 14:06:30 GMT\nCache-Control: max-age=604800\nAccept-Ranges: bytes</code></pre>\n<p>可以看到不仅仅有过期时间，还有防盗链的功能。</p>\n<h3 id=\"nav_point_301\">14.4.7 访问控制</h3>\n<p>对于一些比较重要的网站内容，除了可以使用用户认证限制访问之外，还可以通过其他一些方法做到限制，比如限制IP，或者限制<code>user_agent</code>。限制IP指的是限制访问网站的来源IP，而限制<code>user_agent</code>通常用来限制恶意或者不正常的请求。</p>\n<p>下面再来介绍一下<code>user_agent</code>。<code>user_agent</code>翻译为中文叫作“用户代理”，其实可以理解为浏览器标识，当用<code>curl</code>访问时，<code>user_agent</code>为“curl/7.29.0”，用Chrome浏览器访问时，<code>user_agent</code>为“Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36”。阿铭在工作中经常针对<code>user_agent</code>来限制一些访问，比如限制一些不太友好的搜索引擎“爬虫”，你之所以能在百度搜到阿铭的论坛，就是因为百度会派一些“蜘蛛爬虫”来抓取网站数据。“蜘蛛爬虫”抓取数据类似于用户用浏览器访问网站，当“蜘蛛爬虫”太多或者访问太频繁时，就会浪费服务器资源。另外，也可以限制恶意请求，这种恶意请求我们通常称作cc攻击，它的原理很简单，就是用很多用户的计算机同时访问同一个站点，当访问量或者频率达到一定层次，就会耗尽服务器资源，从而使之不能正常提供服务。这种cc攻击其实有很明显的规律，其中发起这些恶意请求的<code>user_agent</code>相同或者相似，那我们就可以通过限制<code>user_agent</code>来起到防攻击的作用。</p>\n<p>Nginx也需要限制某些IP不能访问或者只允许某些IP访问。比如，我们有个需求是只允许192.168.72.1和127.0.0.1访问admin目录，配置文件如下：</p>\n<pre class=\"code-rows\"><code>location /admin/\n{\n allow 192.168.72.1;\n allow 127.0.0.1;\n deny all;\n}</code></pre>\n<p>假如来源IP为192.168.72.129，它会从上到下逐一去匹配，第一个IP（192.168.72.1）不匹配，第二个IP（127.0.0.1）不匹配，直到第三行（<code>all</code>）的时候才匹配到，匹配的这条规则为<code>deny</code>（也就是拒绝访问），所以最终会返回一个403的状态码。测试过程如下：</p>\n<pre class=\"code-rows\"><code># mkdir /data/nginx/test.com/admin/\n# echo \"123\" &gt; /data/nginx/test.com/admin/1.html\n# curl -x127.0.0.1:80 test.com/admin/1.html\n123\n# curl -x192.168.72.128:80 test.com/admin/1.html\n&lt;html&gt;\n&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;\n&lt;hr&gt;&lt;center&gt;nginx/1.18.0&lt;/center&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<p>配置文件中的IP也可以为IP段，比如可以写成<code>allow 192.168.72.0/24</code>。如果只拒绝某几个IP，就可以写成这样了：</p>\n<pre class=\"code-rows\"><code>location /admin/\n{\n deny 192.168.72.1;\n deny 127.0.0.1;\n}</code></pre>\n<p>如果是黑名单的形式，就不需要写<code>allow all</code>了，因为默认就是允许所有。除了这种简单地限制目录外，也可以根据正则匹配来限制。对于使用PHP语言编写的网站，有一些目录是有上传文件需求的，比如阿铭在前面列举的那个防盗链案例，因为服务器可以上传图片，并且没有做防盗链，所以被人家当成了一个图片存储服务器，并且盗用带宽流量。如果网站代码有漏洞，让黑客上传了一个用PHP代码写的木马，由于网站可以执行PHP程序，最终就会让黑客拿到服务器权限。为了避免这种情况发生，我们需要把能上传文件的目录直接禁止解析PHP代码（不用担心会影响网站访问，若这种目录也需要解析PHP，那说明程序员不合格），Nginx禁止某个目录解析PHP的配置如下：</p>\n<pre class=\"code-rows\"><code>location ~ .*(abc|image)/.*\\.php$\n{\n deny all;\n}</code></pre>\n<p>小括号里面的竖线为分隔符，是“或者”的意思，把该分隔符放在abc和image之间就可以使URL中带有<code>abc</code>或者<code>image</code>字符串，并且是PHP的请求拒绝访问网站。</p>\n<p>在Nginx配置里，也可以针对<code>user_agent</code>做一些限制，阿铭平时用得非常多。配置如下：</p>\n<pre class=\"code-rows\"><code>if ($http_user_agent ~ 'Spider/3.0|YoudaoBot|Tomato')\n{\n return 403;\n}</code></pre>\n<p>其中<code>~</code>为匹配符号，只要<code>user_agent</code>中含有<code>Spider/3.0</code>、<code>YoudaoBot</code>、<code>Tomato</code>字符串，都会被拒绝，<code>return 403</code>为直接返回403状态码，当然也可以把它替换为<code>deny all</code>。</p>\n<h3 id=\"nav_point_302\">14.4.8 Nignx解析PHP</h3>\n<p>前面阿铭讲了很多Nginx的配置，一直都还没有提到和PHP相关的东西。在LNMP中，PHP是以一个服务（<code>php-fpm</code>）的形式存在的，首先要启动<code>php-fpm</code>服务，然后Nginx再和<code>php-fpm</code>通信。也就是说，处理PHP脚本解析的工作是由<code>php-fpm</code>来完成的，Nginx仅仅是一个“搬运工”，它把用户的请求传递给<code>php-fpm</code>，<code>php-fpm</code>处理完成后把结果传递给Nginx，Nginx再把结果返回给用户。那么Nginx是如何和PHP联系起来的呢？其实，在上面阿铭给大家的nginx.conf中已经有所展示。下面是test.com.conf的内容，其中包含了PHP相关的配置：</p>\n<pre class=\"code-rows\"><code>server\n{\n listen 80;\n server_name test.com test1.com test2.com;\n index index.html index.htm index.php;\n root /data/nginx/test.com;\n\n if ($host != 'test.com' ) {\n rewrite ^/(.*)$ http://test.com/$1 permanent;\n }\n\n location ~ \\.php$\n {\n include fastcgi_params;\n fastcgi_pass unix:/tmp/php-fcgi.sock;\n fastcgi_index index.php;\n fastcgi_param SCRIPT_FILENAME /data/nginx/test.com$fastcgi_script_name;\n }\n access_log /tmp/1.log combined_realip;\n}</code></pre>\n<p>其中<code>fastcgi_pass</code>用来指定<code>php-fpm</code>的地址，如果<code>php-fpm</code>监听的是一个<code>tcp:port</code>的地址（比如127.0.0.1:9000），那么也需要在这里改成<code>fastcgi_pass 127.0.0.1:9000</code>。这个地址一定要和<code>php-fpm</code>服务监听的地址匹配，否则会报502错误。</p>\n<p>还有一个地方也需要注意，<code>factcgi_param SCRIPT_FILENAME</code>后面跟的路径为该站点的根目录，和前面定义的root那个路径保持一致。如果这里配置不对，访问PHP页面会出现404错误。</p>\n<h3 id=\"nav_point_303\">14.4.9 Nginx代理</h3>\n<p>Nginx的代理功能非常实用，这也是Nginx越来越受欢迎的一个原因。一家公司有很多台服务器，为了节省成本，不能为所有服务器都分配公网IP，而如果一个没有公网IP的服务器要提供Web服务，就可以通过代理来实现，其代理过程如图14-2所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100013/image00427.jpeg\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p><strong>图14-2 Nginx代理</strong></p>\n<p>如果Nginx后面有多台Web服务器，并且Nginx同时代理这些服务器，那么Nginx就起到一个负载均衡的作用，这个功能在生产环境中用得也特别多。先来看一下如何配置Nginx的代理：</p>\n<pre class=\"code-rows\"><code># cd /usr/local/nginx/conf/vhost\n# vim proxy.conf // 写入如下内容\nserver\n{\n listen 80;\n server_name ask.apelearn.com;\n\n location /\n {\n proxy_pass http://47.104.7.242/;\n proxy_set_header Host $host;\n proxy_set_header X-Real-IP $remote_addr;\n proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n }\n}</code></pre>\n<p>前两行不用解释，和普通的虚拟主机是一样的，不同的是后面<code>proxy</code>相关的语句。<code>proxy_pass</code>指定要代理的域名所在的服务器IP，这里的IP就是阿铭的论坛所在服务器IP。后面的三行为定义发往后端Web服务器的请求头，第二行必须有，否则代理不成功，它表示后端Web服务器的域名和当前配置文件中的<code>server_name</code>保持一致；第三行和第四行可以省略，前面在讲述Nginx日志格式的时候介绍过这两个参数，表示的含义是一样的。配置文件保存后，重新加载Nginx服务并验证，命令如下：</p>\n<pre class=\"code-rows\"><code># /usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n# /usr/local/nginx/sbin/nginx -s reload\n# curl -x127.0.0.1:80 ask.apelearn.com -I\nHTTP/1.1 200 OK\nServer: nginx/1.18.0\nDate: Sun, 28 Jun 2020 14:20:43 GMT\nContent-Type: text/html; charset=UTF-8\nConnection: keep-alive\nX-Powered-By: PHP/5.4.16\nP3P: CP=\"CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR\"\nSet-Cookie: ape__Session=jio8hb84ods47012d88tviti27; expires=Sun, 28-Jun-2020 14:24:07 GMT; path=/; domain=.apelearn.com\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\nPragma: no-cache\nVary: Accept-Encoding\n\n# curl ask.apelearn.com -I\nHTTP/1.1 200 OK\nServer: nginx\nDate: Sun, 28 Jun 2020 14:19:31 GMT\nContent-Type: text/html; charset=UTF-8\nConnection: keep-alive\nX-Powered-By: PHP/5.4.16\nP3P: CP=\"CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR\"\nSet-Cookie: ape__Session=976hk1s873jdbdn8iq2v6jhge2; expires=Sun, 28-Jun-2020 14:24:31 GMT; path=/; domain=.apelearn.com\nExpires: Thu, 19 Nov 1981 08:52:00 GMT\nCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0\nPragma: no-cache\nVary: Accept-Encoding</code></pre>\n<p>这样看是没有问题的，阿铭虚拟机上的Nginx版本为1.18.0，而阿铭论坛服务器上用的Nginx版本并没有显示。把服务器上的环境版本暴露出来并不安全，因为这样别有用心的人会直接获取到服务器上的软件版本信息，如果正好该版本有漏洞，那么他就可以直接攻击了。关于如何关掉版本信息，阿铭不在本章描述。下面阿铭再提供一个负载均衡的示例，在编写Nginx虚拟主机配置文件之前，先来查看一下www.qq.com域名对应的IP，使用<code>dig</code>命令（使用<code>yum install bind-utils</code>安装）：</p>\n<pre class=\"code-rows\"><code># dig @8.8.8.8 www.qq.com\n\n; &lt;&lt;&gt;&gt; DiG 9.11.13-RedHat-9.11.13-3.el8 &lt;&lt;&gt;&gt; @8.8.8.8 www.qq.com\n; (1 server found)\n;; global options: +cmd\n;; Got answer:\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 59151\n;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 512\n;; QUESTION SECTION:\n;www.qq.com. IN A\n\n;; ANSWER SECTION:\nwww.qq.com. 159 IN CNAME public-v6.sparta.mig.tencent-cloud.net.\npublic-v6.sparta.mig.tencent-cloud.net. 98 IN A 111.30.164.236\npublic-v6.sparta.mig.tencent-cloud.net. 98 IN A 111.30.171.191\npublic-v6.sparta.mig.tencent-cloud.net. 98 IN A 111.30.171.194\n\n;; Query time: 147 msec\n;; SERVER: 8.8.8.8#53(8.8.8.8)\n;; WHEN: 日 6月 28 22:29:01 CST 2020\n;; MSG SIZE rcvd: 139</code></pre>\n<p>可以看到有三个IP，这三个IP都可以访问到www.qq.com。先来验证一下：</p>\n<pre class=\"code-rows\"><code># curl -x111.30.164.236:80 www.qq.com -I\nHTTP/1.1 302 Moved Temporarily\nServer: nginx\nDate: Sun, 28 Jun 2020 14:30:26 GMT\nContent-Type: text/html\nContent-Length: 154\nConnection: keep-alive\nLocation: https://www.qq.com/\n\n# curl -x111.30.171.191:80 www.qq.com -I\nHTTP/1.1 302 Moved Temporarily\nServer: nginx\nDate: Sun, 28 Jun 2020 14:30:42 GMT\nContent-Type: text/html\nContent-Length: 154\nConnection: keep-alive\nLocation: https://www.qq.com/\n\n# curl -x111.30.171.194:80 www.qq.com -I\nHTTP/1.1 302 Moved Temporarily\nServer: nginx\nDate: Sun, 28 Jun 2020 14:30:53 GMT\nContent-Type: text/html\nContent-Length: 154\nConnection: keep-alive\nLocation: https://www.qq.com/</code></pre>\n<p>可以看到三个IP返回的结果一样，它使用的Web服务器软件也是nginx。有三个IP就可以做负载均衡了，配置过程如下：</p>\n<pre class=\"code-rows\"><code># vim /usr/local/nginx/conf/vhost/load.conf // 写入如下内容\nupstream qq_com\n{\n ip_hash;\n server 111.30.171.194:80;\n server 111.30.171.191:80;\n server 111.30.164.236:80;\n}\n\nserver\n{\n listen 80;\n server_name www.qq.com;\n\n location /\n {\n proxy_pass http://qq_com;\n proxy_set_header Host $host;\n proxy_set_header X-Real-IP $remote_addr;\n proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n }\n}</code></pre>\n<p>和简单的代理有所不同，负载均衡多了一个<code>upstream</code>，这里定义后端的Web服务器，可以是一个，也可以是多个。其中<code>ip_hash</code>为负载均衡的算法，它表示根据IP地址把请求分发到不同的服务器上。比如用户A的IP为1.1.1.1，用户B的IP为2.2.2.2，则A访问的时候会把请求转发到第一个Web服务器上，而B访问的时候会转发到第二个Web Server上。这种算法用在把session存到本机磁盘上的情况，至于什么是session，阿铭大概说一下。你访问猿课看课程需要登录，那么你一旦登录，服务器上就会记录你的session信息，这个session会保存一段时间。比如，你看了一个10分钟的课程，然后去开会了，过去半小时再打开网站，你依然是登录的状态，这就是因为session还存在这台服务器上。下面是测试结果：</p>\n<pre class=\"code-rows\"><code># /usr/local/nginx/sbin/nginx -t\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful\n# /usr/local/nginx/sbin/nginx -s reload\n# curl -x127.0.0.1:80 www.qq.com -I\nHTTP/1.1 302 Moved Temporarily\nServer: nginx/1.18.0\nDate: Sun, 28 Jun 2020 14:33:53 GMT\nContent-Type: text/html\nContent-Length: 154\nConnection: keep-alive\nLocation: https://www.qq.com/</code></pre>\n<p>神奇吗？阿铭的虚拟机竟然也可以访问www.qq.com了，这其实就是代理的作用！</p>\n<h3 id=\"nav_point_304\">14.4.10 Nignx配置SSL</h3>\n<p>2016年底苹果公司就开始要求各个企业的iOS APP必须使用HTTPS通信，原因很简单，就是保证安全。而目前Chrome、Firefox等各大浏览器，也开始针对HTTPS做调整。你有没有发现，使用百度搜问题时，百度的网址前面是HTTPS。</p>\n<p>这说明HTTPS已经成为一种趋势，阿铭相信过不了10年，整个互联网都会强制使用HTTPS通信，而废弃目前主流的HTTP。那到底什么是HTTPS呢？简单讲，它就是一种加密的HTTP协议。如果HTTP通信的数据包在传输过程中被截获，那么截获者就可以破译这些数据包里面的信息，其中不乏用户名、密码、手机号等敏感信息。而如果使用HTTPS通信，即使数据包被截获，截获者也无法破译里面的内容。图14-3给出了HTTPS的通信过程。</p>\n<p>其通信过程大致如下。</p>\n<p>(1) 浏览器发送一个HTTPS请求给服务器。</p>\n<p>(2) 服务器要有一套数字证书，这个证书可以自己制作（后面的操作就是阿铭自己制作的证书），也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过后才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。</p>\n<p>(3) 服务器会把公钥传输给客户端。</p>\n<p>(4) 客户端（浏览器）收到公钥后，会验证其是否合法有效，若无效会有警告提醒，有效则会生成一串随机字符串，并用收到的公钥加密。</p>\n<p>(5) 客户端把加密后的随机字符串传输给服务器。</p>\n<p>(6) 服务器收到加密随机字符串后，先用私钥解密（公钥加密，私钥解密），获取到这一串随机字符串后，再用这串随机字符串加密传输的数据（该加密为“对称加密”；所谓对称加密，就是将数据和私钥，也就是这个随机字符串通过某种算法混合在一起，这样除非知道私钥，否则无法获取数据内容）。</p>\n<p>(7) 服务器把加密后的数据传输给客户端。</p>\n<p>(8) 客户端收到数据后，再用自己的私钥（也就是那个随机字符串）解密。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100013/image00428.jpeg\" alt=\"{%}\" /></p>\n<p><strong>图14-3 HTTPS通信过程</strong></p>\n<p>通过上文的简要分析，我们可以确定服务器上必须有一对公钥和私钥，也就是后文提到的SSL证书。如果是公司的网站对外提供服务，则需要购买被各大浏览器厂商认可的SSL证书。阿铭曾经在沃通购买过SSL证书，你可以做个参考。目前各大SSL证书服务商已经不再提供免费的SSL证书服务，所以做本实验的时候，阿铭只能在Linux机器上生成一对自定义的SSL证书，这个证书只能我们自己用一下，不能使用在生产环境中。具体配置过程如下：</p>\n<pre class=\"code-rows\"><code># cd /usr/local/nginx/conf\n# openssl genrsa -des3 -out tmp.key 2048\nGenerating RSA private key, 2048 bit long modulus (2 primes)\n...........................+++++\n.......................................................+++++\ne is 65537 (0x010001)\nEnter pass phrase for tmp.key:\nVerifying - Enter pass phrase for tmp.key:\n\n// openssl命令如果没有，使用yum install –y openssl安装。这一步是生成key文件（通常称为“私钥”），2048\n//为加密字符串长度，会让我们输入一个密码，密码不能太短，否则不成功\n\n# openssl rsa -in tmp.key -out aminglinux.key\nEnter pass phrase for tmp.key:\nwriting RSA key\n\n// 这一步是把刚刚生成的tmp.key再转换成aminglinux.key，目的是删除刚才设置的密码，如果key文件有密码，\n// 则必须在Nginx加载它的时候输入它的密码，因此很不方便\n# rm -f tmp.key\n# openssl req -new -key aminglinux.key -out aminglinux.csr\nYou are about to be asked to enter information that will be incorporated\ninto your certificate request.\nWhat you are about to enter is what is called a Distinguished Name or a DN.\nThere are quite a few fields but you can leave some blank\nFor some fields there will be a default value,\nIf you enter '.', the field will be left blank.\n-----\nCountry Name (2 letter code) [XX]:\nState or Province Name (full name) []:\nLocality Name (eg, city) [Default City]:\nOrganization Name (eg, company) [Default Company Ltd]:\nOrganizational Unit Name (eg, section) []:\nCommon Name (eg, your name or your server's hostname) []:aming.com\nEmail Address []:\n\nPlease enter the following 'extra' attributes\nto be sent with your certificate request\nA challenge password []:123456\nAn optional company name []:\n\n// 除了Common Name和Challenge password有设置外，其他都是直接按回车。\n// 这一步是生成证书请求文件，这个并不是上文提到的公钥，但这个文件是必须要有的，我们要拿key文件和这\n// 个CSR文件一起生成最终的公钥文件。其中Common Name为后面配置Nginx配置文件的server_name\n\n# openssl x509 -req -days 365 -in aminglinux.csr -signkey aminglinux.key -out aminglinux.crt\nSignature ok\nsubject=/C=XX/L=Default City/O=Default Company Ltd/CN=aming.com\nGetting Private key\n\n// 说明：这样最终才生成了CRT证书文件，也就是图14-3中的公钥</code></pre>\n<p>以上操作的最终目的是生成aminglinux.key和aminglinux.crt两个文件。其实购买的SSL证书主要是得到这两个文件，有了这两个文件就可以配置Nginx了。配置过程如下：</p>\n<pre class=\"code-rows\"><code># vim /usr/local/nginx/conf/vhost/ssl.conf // 写入如下内容\nserver\n{\n listen 443 ssl;\n server_name aming.com;\n index index.html index.php;\n root /data/nginx/aming.com;\n\n ssl on;\n ssl_certificate aminglinux.crt;\n ssl_certificate_key aminglinux.key;\n ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\n location ~ \\.php$\n {\n include fastcgi_params;\n fastcgi_pass unix:/tmp/php-fcgi.sock;\n fastcgi_index index.php;\n fastcgi_param SCRIPT_FILENAME /data/nginx/aming.com$fastcgi_script_name;\n }\n access_log /tmp/1.log combined_realip;\n}</code></pre>\n<p>保存配置文件后，检查配置是否有问题。阿铭在检查配置时，发现了问题：</p>\n<pre class=\"code-rows\"><code># /usr/local/nginx/sbin/nginx -t\nnginx: [emerg] unknown directive \"ssl\" in /usr/local/nginx/conf/vhost/ssl.conf:8\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test failed</code></pre>\n<p>这说明，当前的Nginx并不支持SSL，这是因为阿铭在先前的Nginx编译时，并没有额外配置支持SSL的参数，要解决该问题只能重新编译一遍Nginx。操作过程如下：</p>\n<pre class=\"code-rows\"><code># cd /usr/local/src/nginx-1.18.0/\n# ./configure --prefix=/usr/local/nginx --with-http_ssl_module\n# make\n# make install</code></pre>\n<p>编译完成后，再来检验一次：</p>\n<pre class=\"code-rows\"><code># /usr/local/nginx/sbin/nginx –t\nnginx: [warn] the \"ssl\" directive is deprecated, use the \"listen ... ssl\" directive instead in /usr/local/nginx/conf/vhost/ssl.conf:8\nnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok\nnginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</code></pre>\n<p>有个<code>warn</code>的提示，这个倒不是错误，并不影响。要想去除此告警，可以将配置文件的第8行删除掉。然后创建对应的目录和测试文件：</p>\n<pre class=\"code-rows\"><code># mkdir /data/nginx/aming.com\n# echo \"&lt;?php phpinfo(); ?&gt;\" &gt; /data/nginx/aming.com/1.php\n# systemctl restart nginx.service</code></pre>\n<p>再编辑hosts文件，写入一行：</p>\n<pre class=\"code-rows\"><code>192.168.72.128 aming.com</code></pre>\n<p>用浏览器访问https://aming.com/1.php会提示不安全，如图14-4所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100013/image00429.jpeg\" alt=\"{%}\" /></p>\n<p><strong>图14-4 不安全的连接</strong></p>\n<p>这是因为该证书为我们自己制作的，并没有得到浏览器的认可，如果想继续访问，可以单击“高级”按钮，然后单击“添加例外”，在弹出的对话框单击“确认安全例外”，然后就可以访问网站内容了。此时，你还可以看到浏览器的地址栏左侧有一个灰色的小锁，并且带有黄色三角形，这意味着该链接不安全。这是因为该站点的SSL证书是我们自己颁发的，因而不能被浏览器承认。</p>\n<h2 id=\"nav_point_305\">14.5 <code>php-fpm</code>配置</h2>\n<p>和LAMP不同的是，在LNMP架构中，<code>php-fpm</code>是作为一个独立的服务存在。既然是独立服务，那么它必然有自己的配置文件。<code>php-fpm</code>的配置文件为/usr/local/php-fpm/etc/php-fpm.conf，该文件同样支持<code>include</code>语句，类似于nginx.conf里面的<code>include</code>。</p>\n<h3 id=\"nav_point_306\">14.5.1 <code>php-fpm</code>的<code>pool</code></h3>\n<p>Nignx可以配置多个虚拟主机，<code>php-fpm</code>也支持配置多个pool，每一个pool可以监听一个端口，也可以监听一个socket，这个概念阿铭已经在前面已经有所阐述。阿铭把php-fpm.conf做一个更改，内容如下：</p>\n<pre class=\"code-rows\"><code>[global]\npid = /usr/local/php-fpm/var/run/php-fpm.pid\nerror_log = /usr/local/php-fpm/var/log/php-fpm.log\ninclude = etc/php-fpm.d/*.conf</code></pre>\n<p><code>include</code>的这一行比较特殊，请注意等号后面的路径，必须先写上<code>etc</code>目录，再写需要创建的配置文件目录和子配置文件：</p>\n<pre class=\"code-rows\"><code># mkdir /usr/local/php-fpm/etc/php-fpm.d\n# cd /usr/local/php-fpm/etc/php-fpm.d\n# vim www.conf // 内容如下\n[www]\nlisten = /tmp/www.sock\nlisten.mode=666\nuser = php-fpm\ngroup = php-fpm\npm = dynamic\npm.max_children = 50\npm.start_servers = 20\npm.min_spare_servers = 5\npm.max_spare_servers = 35\npm.max_requests = 500\nrlimit_files = 1024</code></pre>\n<p>保存后，再编辑另外的配置文件：</p>\n<pre class=\"code-rows\"><code># vim aming.conf // 写入如下内容\n[aming]\nlisten = /tmp/aming.sock\nlisten.mode=666\nuser = php-fpm\ngroup = php-fpm\npm = dynamic\npm.max_children = 50\npm.start_servers = 20\npm.min_spare_servers = 5\npm.max_spare_servers = 35\npm.max_requests = 500\nrlimit_files = 1024</code></pre>\n<p>这样就有两个子配置文件，也就是说有两个pool了，第一个pool监听了 /tmp/www.sock，第二个pool监听了 /tmp/aming.sock。这样，就可以在Nginx不同的虚拟主机中调用不同的pool，从而达到相互隔离的目的，两个pool互不影响。下面来验证一下配置是否有问题：</p>\n<pre class=\"code-rows\"><code># /usr/local/php-fpm/sbin/php-fpm -t\n[28-Jun-2020 22:48:39] NOTICE: configuration file /usr/local/php-fpm/etc/php-fpm.conf test is successful</code></pre>\n<p>然后重启一下<code>php-fpm</code>服务：</p>\n<pre class=\"code-rows\"><code># /etc/init.d/php-fpm restart\nGracefully shutting down php-fpm . done\nStarting php-fpm done</code></pre>\n<p>再来查看 /tmp/ 目录下面的sock文件：</p>\n<pre class=\"code-rows\"><code># ls /tmp/*.sock\n/tmp/aming.sock /tmp/mysql.sock /tmp/php-fcgi.sock</code></pre>\n<h3 id=\"nav_point_307\">14.5.2 <code>php-fpm</code>的慢执行日志</h3>\n<p>这一节非常重要，请务必认真看完并理解。<code>php-fpm</code>的慢执行日志阿铭用得非常多，它可以帮助你快速地追踪到问题点。为了更容易理解<code>php-fpm</code>的慢执行日志，阿铭先来举一个小例子。</p>\n<p>小明是一个运维工程师，他维护的网站是用PHP语言编写的，运行环境为LNMP，网站访问量不算大，一直都很稳定。但有一天，网站突然很卡，打开一个页面需要十几秒，小明发现问题后，马上登录服务器排查问题。他做的操作有：使用<code>w</code>命令查看服务器负载，使用<code>free</code>命令查看内存，使用<code>top</code>命令查看哪个进程占用CPU，使用<code>nload</code>命令查看网卡流量……总之小明做了很多操作，种种迹象表明<code>php-fpm</code>进程占用了很多资源。</p>\n<p>但<code>php-fpm</code>进程究竟在干什么？为什么耗费了很多资源呢？小明很想知道，只有找到问题点，才能解决<code>php-fpm</code>耗费资源的问题，然后网站自然就快了。小明的经验有限，不知道怎么去查看<code>php-fpm</code>在干什么。在哪一步卡住了呢？小明开始到Google上去搜文档，找啊找，找啊找，找了很久，也尝试了许多方法，终于“皇天不负有心人”，小明找到了一个很有效的方法，其实就是阿铭要介绍的<code>php-fpm</code>慢执行日志。</p>\n<p>通过<code>php-fpm</code>的慢执行日志，我们可以非常清晰地了解到PHP的脚本在哪里执行时间长，它可以定位到具体的行。在上例中，小明就是通过查看<code>php-fpm</code>的慢执行日志最终得到结论：是因为PHP调用了一个远程的网站接口，而这个接口网络出现故障，访问它需要十几秒的时间，所以<code>php-fpm</code>也会等十几秒，最终导致网站访问很卡。说了这么多，你肯定很想知道如何开启和查看<code>php-fpm</code>的慢执行日志，操作步骤如下：</p>\n<pre class=\"code-rows\"><code># vim /usr/local/php-fpm/etc/php-fpm.d/www.conf // 在最后面加入如下内容\nrequest_slowlog_timeout = 1\nslowlog = /usr/local/php-fpm/var/log/www-slow.log</code></pre>\n<p>第一行定义超时时间，即PHP的脚本执行时间只要超过1秒就会记录日志，第二行定义慢执行日志的路径和名字。以后，你遇到PHP网站访问卡顿的问题时，要记得去查看这个慢执行日志，一定会帮到你！</p>\n<h3 id=\"nav_point_308\">14.5.3 <code>php-fpm</code>定义<code>open_basedir</code></h3>\n<p><code>open_basedir</code>的作用是将网站限定在指定目录里，就算该站点被黑了，黑客只能在该目录下面有所作为，而不能左右其他目录。如果你的服务器上只有一个站点，那么可以直接在php.ini中设置<code>open_basedir</code>参数。但如果服务器上运行的站点比较多，那在php.ini中设置就不合适了，因为在php.ini中只能定义一次，也就是说所有站点都一起定义限定的目录，这样似乎起不到隔离多个站点的作用。<code>php-fpm</code>可以针对不同的pool设置不同的<code>open_basedir</code>：</p>\n<pre class=\"code-rows\"><code># vim /usr/local/php-fpm/etc/php-fpm.d/aming.conf // 在最后面加入\nphp_admin_value[open_basedir]=/data/www/:/tmp/</code></pre>\n<p>只要在对应的Nginx虚拟主机配置文件中调用对应的pool，就可以使用<code>open_basedir</code>来物理隔离多个站点了，从而达到安全的目的。</p>\n<h3 id=\"nav_point_309\">14.5.4 <code>php-fpm</code>进程管理</h3>\n<p>来看这一段配置：</p>\n<pre class=\"code-rows\"><code>pm = dynamic\npm.max_children = 50\npm.start_servers = 20\npm.min_spare_servers = 5\npm.max_spare_servers = 35\npm.max_requests = 500</code></pre>\n<p>第一行，定义<code>php-fpm</code>的子进程启动模式，<code>dynamic</code>为动态模式；一开始只启动少量的子进程，根据实际需求，动态地增加或者减少子进程，最多不会超过<code>pm.max_children</code>定义的数值。另外一种模式为<code>static</code>，这种模式下子进程数量由<code>pm.max_children</code>决定，一次性启动这么多，之后不会减少也不会增加。</p>\n<p><code>pm.start_servers</code>针对<code>dynamic</code>模式，定义<code>php-fpm</code>服务在启动时产生的子进程数量。<code>pm.min_spare_servers</code>针对<code>dynamic</code>模式，定义在空闲时段子进程数的最少数量，如果达到这个数值，<code>php-fpm</code>服务会自动派生新的子进程。<code>pm.max_spare_servers</code>也是针对<code>dynamic</code>模式的，定义在空闲时段子进程数的最大值，如果高于这个数值就开始清理空闲的子进程。<code>pm.max_requests</code>针对<code>dynamic</code>模式，定义一个子进程最多处理的请求数，也就是说在一个<code>php-fpm</code>的子进程中最多可以处理<code>pm.max_requests</code>个请求，当达到这个数值时，进程会自动退出。</p>\n<h2 id=\"nav_point_310\">14.6 课后习题</h2>\n<p>(1) 到MySQL官网下载一个源码包，尝试编译安装，编译参数可以参考我们已经安装过的MySQL的编译参数。</p>\n<p>(2) MySQL的配置文件my.cnf是否可以放到/etc/目录外的其他目录下？</p>\n<p>(3) PHP的配置文件是什么？<code>php-fpm</code>的配置文件是什么？</p>\n<p>(4) 如何检测Nginx配置文件是否有错？如何检测<code>php-fpm</code>的配置文件是否有错？</p>\n<p>(5) 本章中出现了两次<code>chmod 755 /etc/init.d/xxx</code>，其中<code>xxx</code>为<code>mysql</code>、<code>php-fpm</code>。为什么要更改它们的权限？如果不改会有什么问题？</p>\n<p>(6) Nginx是如何做到解析PHP文件的？它是如何和PHP联系在一起的？</p>\n<p>(7) 请配置Nginx的访问日志，并编写日志切割脚本（按天切割）。</p>\n<p>(8) 请配置Nginx域名重定向，比如一个虚拟主机支持多个域名访问abc.com和123.com，那么如何让123.com的访问跳转到abc.com？</p>\n<p>(9) 请配置Nginx的用户验证。</p>\n<p>(10) 请针对Nginx站点，设置禁止某个目录下的PHP程序解析。</p>\n<p>(11) 请使用Nginx代理一个站点。</p>\n<p>(12) 请配置Nginx，限制只让某个IP访问网站。</p>\n<p>(13) 请设置Nginx防盗链，比如只让A域名的referer访问，其他站点不能访问。</p>\n<p>(14) 请设置Nginx根据<code>user_agent</code>来限制访问，比如禁止百度的蜘蛛访问站点。</p>\n<p>(15) 请配置Nginx的虚拟目录。</p>\n<p>(16) php-fpm.conf中配置有多个pool，如何针对每一个pool配置<code>open_basedir</code>以及<code>slow_log</code>？</p>\n\n<br style=\"page-break-after:always\" />","comments":[]}