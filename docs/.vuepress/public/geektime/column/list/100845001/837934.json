{"id":837934,"title":"08｜Gin+client-go：构建API工具","content":"<p>你好，我是邢云阳。</p><p>在前两节课中，我们介绍了&nbsp;client-go&nbsp;的两种进阶使用技巧。但需要强调的是，“存在即合理”——client-go 中每种操作资源的方法都有其特定的使用场景。是否在项目中采用这些进阶技巧，最终还需要根据需求来判断。例如，如果项目中并不需要高频查询，就没有必要通过 Informer 将资源缓存到本地。分享这些技巧的目的，是为了拓宽你的知识面，让你在实际工作中多一些选择，提高应对的灵活性。</p><p>与此同时，正如我反复提到的，API 是 AI 时代的一等公民。因此本节课，我们将在前面内容的基础上，完成资源的创建、删除和查询三种操作的代码实现，并使用 Gin 框架构建一个 HTTP Server，将这些功能封装成三个独立的 API。这些 API 将为后续 Agent 的调用提供工具支持。</p><h2>Gin 简介</h2><p>首先，我们来简单介绍一下&nbsp;Gin。Gin 是一个用 Go 语言编写的高性能、轻量级 Web 框架。它的设计灵感来自于 Python 的 Flask 框架，以简洁易用著称，非常适合构建 RESTful API。可以说 gin 已经成为了 Go 语言编写 Web 后端的最佳实践。</p><p>以下是一段最简单的 Gin 示例代码，展示如何快速搭建一个返回 “Hello, Gin!” 的 HTTP Server：</p><!-- [[[read_end]]] --><pre><code class=\"language-go\">package main\n\nimport (\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc main() {\n\t// 创建一个默认的 Gin 路由引擎\n\tr := gin.Default()\n\n\t// 定义一个简单的 GET 路由\n\tr.GET(\"/hello\", func(c *gin.Context) {\n\t\tc.JSON(200, gin.H{\n\t\t\t\"message\": \"Hello, Gin!\",\n\t\t})\n\t})\n\n\t// 启动 HTTP 服务，监听 8080 端口\n\tr.Run(\":8080\") // 默认监听 0.0.0.0:8080\n}\n</code></pre><p>可以看到，几行代码就可以构建出一个 HTTP Server，非常简单易懂。我们在浏览器输入 “localhost:8080/hello” 看一下效果：</p><p><img src=\"https://static001.geekbang.org/resource/image/31/df/31cbb3cc712029debe880074bcd1a3df.png?wh=429x132\" alt=\"图片\"></p><h2>代码讲解</h2><h3>API 设计</h3><p>了解了什么是 Gin 之后，我们进入今天的代码实践环节。首先，我们需要设计 API。这次设计的目标是实现增、删、查三种通用API，用于通过自然语言操控 Kubernetes 服务，除此之外，我们还要设计一个验证 API，用于在创建资源时，验证用户传入的 resource 是否正确。</p><p>首先来看增删查三个 API。在实际使用场景中，对于这三种操作，用户一般会这么说：</p><pre><code class=\"language-plain\">//创建\n帮我在 default 命名空间下创建一个名为 nginx 的 Pod。\n\n//查询\n帮我列出 default 命名空间下的 configmap 列表。\n\n//删除\n帮我删除 default 命名空间下名为 ng-svc 的 service。\n</code></pre><p>从这样的提问方式中可以总结出一个特点，用户通常只会明确告诉我们要操作的资源的&nbsp;kind&nbsp;或&nbsp;resource 名称，例如 pod、service 等等，而不会提及&nbsp;group&nbsp;和&nbsp;version。并且用户要操作的资源是随机不固定的。因此，我们可以设计成通用路由，比如：</p><pre><code class=\"language-plain\">// 创建\nPOST http://&lt;host&gt;:&lt;port&gt;/:resources?ns=&lt;资源命名空间&gt;\nBody: json格式\n数据结构: yaml string类型 存放资源 yaml 文件内容\n\n// 删除\nDELETE http://&lt;host&gt;:&lt;port&gt;/:resources?ns=&lt;资源命名空间&gt;&amp;name=&lt;资源名称&gt;\n\n// 查询\nGET http://&lt;host&gt;:&lt;port&gt;/:resources?ns=&lt;资源命名空间&gt;\n</code></pre><p>这样设计的思路是，路径参数 resources 直接填入从用户那里获取的待操作资源名称，实现通用化，而不需要针对每一种资源都设计一条路由，比如 GET http://<host>:<port>/pods、GET http://<host>:<port>/services 等等。有了这个前提，针对这三种操作所需的不同参数，就很好设计了。</port></host></port></host></p><p>针对创建 API，需要知道命名空间来创建动态客户端，也需要传输一个资源 yaml，才能做具体的创建工作。而删除需要命名空间和资源名称，查询需要命名空间。当然查询也可以做得再复杂一点，比如加上标签过滤，在这里我就不演示了。</p><p>接下来看一下验证 API。验证 API 的作用主要是验证用户输入的 resource 是否是一个 K8s 支持的 resource。例如用户说 “我要创建一个 pod ”，这是没问题的，但如果用户说“我要创建一个 abc”，那就有问题了，我们可以通过验证 API 直接验证出错误就拦截掉，无需再进行后续的步骤了。</p><p>验证的原理，实际上就是我们在<a href=\"https://time.geekbang.org/column/article/836672\">第 6 节课</a>讲过的通过 resource 获取 GVR的原理，如果能获取到说明没问题，如果获取不到，则说明用户填错了。</p><p>因此 API 可以这么设计：</p><pre><code class=\"language-plain\">// 查询\nGET http://&lt;host&gt;:&lt;port&gt;/get/gvr?resource=&lt;资源名称&gt;\n</code></pre><h3>目录结构</h3><p>设计完成后，我们来写代码，首先来看一下目录结构。</p><pre><code class=\"language-go\">.\n|-- pkg\n| |-- config\n| | |-- k8sconfig.go \n| |-- controllers\n| | |-- resourceCtl.go\n| |-- services\n| | |-- resourceService.go\n|-- go.mod\n|-- go.sum\n|-- main.go\n</code></pre><p>根目录包含 pkg 文件夹，用于编写业务代码。pkg 下面包含了 config、controllers，以及 services 三个文件夹。config 主要是做配置相关的代码，目前包含 k8sconfig.go，做 client, restMapper 等初始化操作；controllers 主要是做路由处理相关工作，包含 resourceCtl.go，用于做创建、删除、查询资源三个 API 的路由处理；services 做具体的与底层 K8s 交互的业务，也就是 client-go 部分的代码，包含 resourceService.go。最后在 main.go 中定义路由并启动 gin 服务器。</p><p>接下来我就按照 config、services、controllers 这三层的顺序开始讲解。</p><h3>config</h3><p>k8sconfig.go 还是沿用上一节课的链式调用的代码结构，整体变动不大。只是如下所示在 K8sConfig 结构体中，增加了 clientSet、restMapper 以及 SharedInformerFactory。</p><pre><code class=\"language-go\">type K8sConfig struct {\n&nbsp; &nbsp; *rest.Config\n&nbsp; &nbsp; *kubernetes.Clientset\n&nbsp; &nbsp; *dynamic.DynamicClient\n&nbsp; &nbsp; meta.RESTMapper\n&nbsp; &nbsp; informers.SharedInformerFactory\n&nbsp; &nbsp; e error\n}\n</code></pre><p>这些成员的初始化在之前的两节课中都已经讲过，在这里不做赘述。我会将本节课的代码放到 Github 上，你可以自行查看。</p><h3>services</h3><p>services 层的代码是具体的业务实现，需要使用 client-go 来完成增删改三种操作以及验证操作。</p><p>对于创建操作和删除操作，我们可以使用<a href=\"https://time.geekbang.org/column/article/836672\">第 6 节课</a>讲解的 restMapper + DynamicClient 的方式。将路由传入的 resources 利用 restMapper 映射取得 GVR，之后通过 DynamicClient 完成资源创建删除。</p><p>在 第 6 节课的课后思考题中，我曾经提到过，如果 mapping 函数传入的 resourceOrKindArg</p><p>参数不是 resource 而是 Kind，我们在代码中如何处理。实际上，非常简单，因为 schema 包不只提供了 ParseResourceArg 方法用于根据 resource 取出 groupResource，还提供了 ParseKindArg 方法用于根据 Kind 取出 groupKind。我们可以将代码这样完善一下：</p><pre><code class=\"language-go\">func (r *ResourceService) mappingFor(resourceOrKindArg string, restMapper *meta.RESTMapper) (*meta.RESTMapping, error) {\n    // 之前的处理 resource 的代码\n    ...\n\n    //处理 Kind 的新代码\n    fullySpecifiedGVK, groupKind := schema.ParseKindArg(resourceOrKindArg)\n  &nbsp; if fullySpecifiedGVK == nil {\n  &nbsp; &nbsp; &nbsp; gvk := groupKind.WithVersion(\"\")\n  &nbsp; &nbsp; &nbsp; fullySpecifiedGVK = &amp;gvk\n  &nbsp; }\n  \n  &nbsp; if !fullySpecifiedGVK.Empty() {\n  &nbsp; &nbsp; &nbsp; if mapping, err := (*restMapper).RESTMapping(fullySpecifiedGVK.GroupKind(), fullySpecifiedGVK.Version); err == nil {\n  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return mapping, nil\n  &nbsp; &nbsp; &nbsp; }\n  &nbsp; }\n  \n  &nbsp; mapping, err := (*restMapper).RESTMapping(groupKind, gvk.Version)\n  &nbsp; if err != nil {\n  &nbsp; &nbsp; &nbsp; if meta.IsNoMatchError(err) {\n  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nil, fmt.Errorf(\"the server doesn't have a resource type %q\", groupResource.Resource)\n  &nbsp; &nbsp; &nbsp; }\n  &nbsp; &nbsp; &nbsp; return nil, err\n  &nbsp; }\n  \n    return mapping, nil\n}\n</code></pre><p>有了 mapping 之后，就可以通过 mapping.Resource 拿到 GVR。之后通过我们封装的 getResourceInterface 函数，设置好 DynamicClient。</p><pre><code class=\"language-go\">func (r *ResourceService) getResourceInterface(resourceOrKindArg string, ns string, client dynamic.Interface, restMapper *meta.RESTMapper) (dynamic.ResourceInterface, error) {\n&nbsp; &nbsp; var ri dynamic.ResourceInterface\n\n&nbsp; &nbsp; restMapping, err := r.mappingFor(resourceOrKindArg, restMapper)\n&nbsp; &nbsp; if err != nil {\n&nbsp; &nbsp; &nbsp; &nbsp; return nil, fmt.Errorf(\"failed to get RESTMapping for %s: %v\", resourceOrKindArg, err)\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; // 判断资源是命名空间级别的还是集群级别的\n&nbsp; &nbsp; if restMapping.Scope.Name() == \"namespace\" {\n&nbsp; &nbsp; &nbsp; &nbsp; ri = client.Resource(restMapping.Resource).Namespace(ns)\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; ri = client.Resource(restMapping.Resource)\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; return ri, nil\n}\n</code></pre><p>我们利用动态客户端，可以通过 Create 可以创建资源，通过 Delete 可以删除资源，这都很简单了。比如创建这样写：</p><pre><code class=\"language-go\">func (r *ResourceService) CreateResource(resourceOrKindArg string, ns string, yaml string) error {\n&nbsp; &nbsp; obj := &amp;unstructured.Unstructured{}\n&nbsp; &nbsp; _, _, err := scheme.Codecs.UniversalDeserializer().Decode([]byte(yaml), nil, obj)\n&nbsp; &nbsp; if err != nil {\n&nbsp; &nbsp; &nbsp; &nbsp; return err\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; ri, err := r.getResourceInterface(resourceOrKindArg, ns, r.client, r.restMapper)\n&nbsp; &nbsp; if err != nil {\n&nbsp; &nbsp; &nbsp; &nbsp; return err\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; _, err = ri.Create(context.Background(), obj, metav1.CreateOptions{})\n&nbsp; &nbsp; if err != nil {\n&nbsp; &nbsp; &nbsp; &nbsp; return err\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return nil\n}\n</code></pre><p>我们唯一需要关注的是 ri.Create 需要传入一个 obj，代表待创建的资源实体，它的类型是 *unstructured.Unstructured，通过源码可以看出，其本质就是一个 map[string]interface{}。</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/02/faafeafd0a0fa232a6fc792a86249402.png?wh=1024x165\" alt=\"图片\"></p><p>那么如何将 string 类型的 yaml 转化成这种格式呢？scheme 包中给我们封装好了 Decode 函数，即代码第三行的 scheme.Codecs.UniversalDeserializer().Decode，直接调用即可完成转换。</p><p>创建和删除都清晰后，再顺便说一下验证操作。验证是很简单的，直接利用上面的 mappingFor 函数获取 GVR 即可。</p><p>最后我们沿着上一节课的课后思考题看一下查询如何写。上一节课最后，我说你可以思考一下如何将 restMapper 和 SharedInformerFactory 结合起来，实现根据 resource 或其他 kind 从 informer 中查询资源。</p><p>现在我们来一起做一下这个功能。</p><p>首先需要在 k8sconfig.go 中初始化 SharedInformerFactory，代码如下：</p><pre><code class=\"language-go\">func (k *K8sConfig) InitInformer() informers.SharedInformerFactory {\n&nbsp; &nbsp; fact := informers.NewSharedInformerFactory(k.InitClientSet(), 0) //创建通用informer工厂\n\n&nbsp; &nbsp; informer := fact.Core().V1().Pods()\n&nbsp; &nbsp; informer.Informer().AddEventHandler(&amp;cache.ResourceEventHandlerFuncs{})\n\n&nbsp; &nbsp; ch := make(chan struct{})\n&nbsp; &nbsp; fact.Start(ch)\n&nbsp; &nbsp; fact.WaitForCacheSync(ch)\n\n&nbsp; &nbsp; return fact\n}\n</code></pre><p>在初始化中创建监听 pods 的 informer。之后来写查询业务代码。</p><pre><code class=\"language-go\">func (r *ResourceService) ListResource(resourceOrKindArg string, ns string) ([]runtime.Object, error) {\n&nbsp; &nbsp; restMapping, err := r.mappingFor(resourceOrKindArg, r.restMapper)\n&nbsp; &nbsp; if err != nil {\n&nbsp; &nbsp; &nbsp; &nbsp; return nil, err\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; informer, _ := r.fact.ForResource(restMapping.Resource)\n&nbsp; &nbsp; list, _ := informer.Lister().ByNamespace(ns).List(labels.Everything())\n&nbsp; &nbsp; return list, nil\n}\n</code></pre><p>首先，先使用 mappingFor，获取restMapping，restMapping.Resource 就是 GVR。之后通过 SharedInformerFactory 的 ForResource 方法获取监听的 informer，最后通过 informer 的 Lister 就能获取资源列表。</p><p>services 部分，我们就讲到这里，有了前面两节课的基础，理解这个代码还是很简单的。</p><h3>controllers</h3><p>最后来看一下，路由处理部分。路由处理代码在 resourceCtl.go 中，我依然使用了面向对象思想，创建了 ResourceCtl 以及构造函数。</p><pre><code class=\"language-go\">type ResourceCtl struct {\n&nbsp; &nbsp; resourceService *services.ResourceService\n}\n\nfunc NewResourceCtl(service *services.ResourceService) *ResourceCtl {\n&nbsp; &nbsp; return &amp;ResourceCtl{resourceService: service}\n}\n</code></pre><p>由于 client-go 相关的业务代码，放在了 services 中，在路由处理函数中需要调用，因此我在 ResourceCtl 结构中添加了 resourceService 作为成员。</p><p>路由处理的逻辑很简单，我们看一下相对最复杂的创建处理逻辑的实现套路，学会了套路，查询和删除就不难了。</p><pre><code class=\"language-go\">func (r *ResourceCtl) Create() func(c *gin.Context) {\n&nbsp; &nbsp; return func(c *gin.Context) {\n&nbsp; &nbsp; &nbsp; &nbsp; var resource = c.Param(\"resource\")\n&nbsp; &nbsp; &nbsp; &nbsp; ns := c.DefaultQuery(\"ns\", \"default\")\n\n&nbsp; &nbsp; &nbsp; &nbsp; type ResouceParam struct {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Yaml string `json:\"yaml\"`\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; var param ResouceParam\n&nbsp; &nbsp; &nbsp; &nbsp; if err := c.ShouldBindJSON(&amp;param); err != nil {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.JSON(400, gin.H{\"error\": \"解析请求体失败: \" + err.Error()})\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return\n&nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; err := r.resourceService.CreateResource(resource, ns, param.Yaml)\n&nbsp; &nbsp; &nbsp; &nbsp; if err != nil {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.JSON(400, gin.H{\"error\": \"创建失败：\" + err.Error()})\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c.JSON(200, gin.H{\"data\": \"创建成功\"})\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>由于 gin 在定义路由时，需要填写 func(c *gin.Context) 类型的回调函数，因此这里的 Create 方法的返回值就是 func(c *gin.Context)。代码的第 3～14 行做了对 HTTP Request 请求的参数解析工作。在 gin 中，使用 c.Param() 来解析路径参数；使用 c.DefaultQuery() 与 c.Query() 来解析查询参数，不同的是 c.DefaultQuery() 可以赋默认值；使用c.ShouldBindJSON() 来解析 json 格式的Body。</p><p>参数解析完成后， 调用 services 包的 CreateResource 方法处理具体业务逻辑。</p><h3>路由定义与启动</h3><p>全部业务代码完成后，就可以在 main.go 中定义路由以及启动服务器了。代码如下：</p><pre><code class=\"language-go\">r := gin.New()\n\nr.GET(\"/:resource\", ctl.List())\nr.DELETE(\"/:resource\", ctl.Delete())\nr.POST(\"/:resource\", ctl.Create())\nr.GET(\"/get/gvr\", resourceCtl.GetGVR())\n\nr.Run(\":8080\")\n</code></pre><h3></h3><p>我们将四条路由定义好，然后启动 gin server。</p><h3>测试</h3><p>使用 Apifox 工具做一下测试。首先测试 pod 创建。</p><p><img src=\"https://static001.geekbang.org/resource/image/56/d1/56451ebed9350828ff85e84ceef39bd1.png?wh=1439x811\" alt=\"图片\"></p><p>我们在 body 中传入了一个 名字为 foo-app 的 pod 的 yaml 内容，点击发送后，返回创建成功。</p><p>之后测试 一下pod 查询，验证刚才创建的 pod 是否存在。</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/67/5f71455523eb49cbe9acbb9f7fb5ce67.png?wh=1105x749\" alt=\"图片\"></p><p>可以看到返回的 body 中含有 foo-app 这个 pod。</p><p>再测试一下 pod 删除，删除刚才创建的 pod。</p><p><img src=\"https://static001.geekbang.org/resource/image/23/c3/2326466cfc00f008509469ee19f85ac3.png?wh=1129x817\" alt=\"图片\"></p><p>返回删除成功。</p><p>最后测试一下验证 API。先输入一个正确的 resource，结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/55/e1/5564a729084a81da9b2df40923c1c5e1.png?wh=1108x697\" alt=\"图片\"></p><p>再输入一个错误的 resource，结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/70/34/706c4d79c50f38ecc8e702c8ded7e834.png?wh=1279x697\" alt=\"图片\"></p><p>OK，全部测试完毕。</p><h2>总结</h2><p>这节课是对前两小节 client-go 知识的一个小的应用实战。我结合着 gin 框架，沿着前两小节的课后思考题，带你完成了创建、删除、查询 Kubernetes 资源以及验证用户输入四个 API 的编写，并做了测试。这节课的代码我已经上传到 <a href=\"<a href=\" https:=\"\" geek=\"\" gintools\"=\"\">https://Geek/ginTools</a> at main · xingyunyang01/Geek\"&gt;Github了，供你参考。</p><p>在传统应用中，将后端业务封装成 API，可以实现前后端的解耦。而在 AI 时代，则可以实现与 Agent 的解耦，也就是说，Agent 不管是用 ReAct 还是用 ReWoo，是用 Go 语言还是用 Python 与 API 工具都没关系。再进一步，Agent 将会形成一个类似“网关”的效果，“网关”的后面是各种工具 API，而前端是一个能输入自然语言的界面，这个界面具体是使用 UI 还是命令行，是使用 Python、Java，还是 Go实现，我们并不关心，只要它能和我们的 Agent 连接即可。</p><p>这些思路，我们会在后面的课程中，为你一步步展现。</p><h2>思考题</h2><p>本节课的查询代码只能够查询到 pods 资源，查询其他资源会返回空。这是什么原因呢？如果我们要查询 deployments 该如何做？</p><p>欢迎你在留言区展示你的思考和测试结果，我们一起来讨论。如果你觉得这节课的内容对你有帮助的话，也欢迎你分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":396721,"user_name":"linxs","can_delete":false,"product_type":"c1","uid":1006728,"ip_address":"广东","ucode":"0D860DF26FD150","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/88/222d946e.jpg","comment_is_top":false,"comment_ctime":1735523925,"is_pvip":false,"replies":[{"id":143983,"content":"优秀👍","user_name":"作者回复","user_name_real":"编辑","uid":1943646,"ctime":1735530467,"ip_address":"山东","comment_id":396721,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100845001,"comment_content":"1. 在示例项目中，InitInformer方法中只添加了Pod的，只能查询 pods 资源\n2. 如果要支持查询 其他对象如deployment的话， 需要在InitInformer方法中创建deployment的informer\n","like_count":0,"discussions":[{"author":{"id":1943646,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/a8/5e/791d0f5e.jpg","nickname":"最后的风之子","note":"","ucode":"45D5487480A5D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":655656,"discussion_content":"优秀👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1735530467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}