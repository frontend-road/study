{"id":740869,"title":"第 6 章 Spring 中的 JDBC(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>常见的数据库连接池配置</li>\n<li>在 Spring 中使用 JDBC 操作数据库</li>\n<li>Spring 中的事务抽象</li>\n<li>Spring 中的异常抽象</li>\n</ul>\n</blockquote>\n<p>JDBC 的全称是 Java Database Connectivity，是一套面向关系型数据库的规范。虽然数据库各有不同，但这些数据库都提供了基于 JDBC 规范实现的 JDBC 驱动。开发者只需要面向 JDBC 接口编程，就能在很大程度上规避数据库差异带来的问题。Java 应用程序基本上是通过 JDBC 来连接并操作数据库的，哪怕我们使用了对象关系映射框架（例如 Hibernate），其底层也是用 JDBC 来与数据库进行交互的。</p>\n<h2 id=\"nav_point_91\">6.1　配置数据源</h2>\n<p>无论是简单的增删改查操作，还是复杂的数据分析任务，都需要先提供一个数据源（<code>DataSource</code>）。顾名思义，数据源就是数据的源头，即可以从中获取数据的地方。数据源的常见实现是连接池，开发者能通过连接池来管理 JDBC 连接。由于 JDBC 操作都是基于连接的，因而在本章的第一部分中，我们先来了解一下连接池。</p>\n<h3 id=\"nav_point_92\">6.1.1　数据库连接池</h3>\n<p>在学习 Java 时，大家可能学习过 JDBC 的基础知识。JDBC 通过 <code>java.sql</code> 包中的 <code>Connection</code> 来连接数据库，随后创建 <code>Statement</code> 或 <code>PreparedStatement</code> 执行 SQL 语句。如果是查询操作，在 JDBC 中会用 <code>ResultSet</code> 来代表返回的结果集。一个普通的查询操作可能如代码示例 6-1 所示。<span class=\"comment-number\">1</span></p>\n\n<blockquote>\n<p><strong>代码示例 6-1</strong>　基础的 JDBC 查询操作示例片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>Class.forName(\"org.h2.Driver\");\n// 此处使用了try-with-resource的语法，因此不用在finally语法段中关闭资源\ntry (Connection connection = DriverManager.getConnection(\"jdbc:h2:mem:test_db\");\n    Statement statement = connection.createStatement();\n     ResultSet resultSet = statement.executeQuery(\"SELECT X FROM SYSTEM_RANGE(1, 10)\")) {\n    while (resultSet.next()) {\n        log.info(\"取值：{}\", resultSet.getInt(1));\n    }\n} catch (Exception e) {\n    log.error(\"出错啦\", e);\n}</code></pre>\n<p>这样的代码虽然不复杂，但是在真实的生产环境中，并不推荐大家自己来创建并管理数据库连接，主要原因是创建一个 JDBC 连接的成本非常高。我们建议通过数据库连接池来管理连接，它的主要功能有：</p>\n<ul>\n<li>根据配置，事先创建一定数量的连接放在连接池中，以便在需要的时候直接返回现成的连接；</li>\n<li>维护连接池中的连接，根据配置，清理已存在的连接。</li>\n</ul>\n<p>我们常用的数据库连接池都实现了 <code>DataSource</code> 接口，通过其中的 <code>getConnection()</code> 方法即可获得一个连接。本节将介绍目前比较流行的两个连接池——HikariCP 和 Druid。此外，业界还有其他一些连接池的出镜率也比较高，比如 DBCP2 和 C3P0 等。</p>\n<ol>\n<li><p><strong>HikariCP</strong></p>\n<p>Spring Boot 2.<em>x</em> 项目的默认数据库连接池是 HikariCP，Hikari 这个词在日语中的意思是“光”，也许作者起这个名字是为了突出它“速度快”的这个特点。在工程中引入数据库相关的 Spring Boot Starter，默认就会引入 HikariCP 的依赖。例如，在 Spring Initializr 上选中 H2、JDBC API 和 Lombok 三个组件，生成一个工程，其中的依赖就包括如下内容：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n    &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;</code></pre>\n<p>Spring Boot 的自动配置机制在检测到 CLASSPATH 中存在 H2 数据库的依赖，且没有配置过 <code>DataSource</code> 时，会进行自动配置，提供一个基于内存数据库的数据源。在下一节中我们还会看到不用 Spring Boot 自动配置，而是手动配置一个 <code>DataSource</code> 的例子。我们可以通过一段测试代码来验证一下，如代码示例 6-2 所示。<span class=\"comment-number\">2</span></p>\n<blockquote>\n<p><strong>代码示例 6-2</strong>　<code>DatasourceDemoApplicationTests</code> 测试类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass DatasourceDemoApplicationTests {\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @Test\n    void testDataSource() throws SQLException {\n        assertTrue(applicationContext.containsBean(\"dataSource\"));\n        DataSource dataSource = applicationContext.getBean(\"dataSource\", DataSource.class);\n        assertTrue(dataSource instanceof HikariDataSource);\n\n        Connection connection = dataSource.getConnection();\n        assertTrue(connection instanceof HikariProxyConnection);\n        connection.close();\n\n        assertEquals(10, ((HikariDataSource) dataSource).getMaximumPoolSize());\n    }\n}</code></pre>\n<p>在 <code>testDataSource()</code> 方法中，我们做了如下一些动作：</p>\n<p>(1) 先判断上下文中是否存在名为 <code>dataSource</code> 的 Bean；</p>\n<p>(2) 如果存在，则取出该 Bean，同时要求这个 Bean 是实现了 <code>DataSource</code> 接口的；</p>\n<p>(3) 判断取出的 <code>dataSource</code> 是 <code>HikariDataSource</code> 类型的；</p>\n<p>(4) 从 <code>dataSource</code> 中取出一个连接，判断它是否为 <code>HikariProxyConnection</code> 类型；</p>\n<p>(5) 判断连接池的最大连接数是否为 10，这是一个默认值。</p>\n<p>运行后，这个单元测试能够顺利通过。</p>\n<p>在实际使用时，可以直接注入 <code>DataSource</code> Bean，但在更多的情况下，我们并不会直接去操作 <code>DataSource</code>，而是使用更上层的 API。在后文中我们会看到 Spring Framework 的一些 JDBC 封装操作。</p>\n<p>HikariCP 有不少配置项，用于调整连接池的大小和各种超时设置，可以直接配置在连接池对象上。Spring Boot 为我们提供了方便的配置方式，在 <code>application.properties</code> 中就可以修改自动配置的连接池，具体的参数如表 6-1 所示。</p>\n<p><strong>表 6-1　HikariCP 的常用配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>Spring Boot 配置属性</th><th>配置含义</th></tr><tr><td>`jdbcUrl`</td><td>`spring.datasource.url`</td><td>用于连接数据库的 JDBC URL</td></tr><tr><td>`username`</td><td>`spring.datasource.username`</td><td>连接数据库使用的用户名</td></tr><tr><td>`password`</td><td>`spring.datasource.password`</td><td>连接数据库使用的密码</td></tr><tr><td>`maximumPoolSize`</td><td>`spring.datasource.hikari.maximum-pool-size`</td><td>连接池中的最大连接数</td></tr><tr><td>`minimumIdle`</td><td>`spring.datasource.hikari.minimum-idle`</td><td>连接池中保持的最小空闲连接数</td></tr><tr><td>`connectionTimeout`</td><td>`spring.datasource.hikari.connection-timeout`</td><td>建立连接时的超时时间，单位为秒</td></tr><tr><td>`idleTimeout`</td><td>`spring.datasource.hikari.idle-timeout`</td><td>连接清理前的空闲时间，单位为秒</td></tr><tr><td>`maxLifetime`</td><td>`spring.datasource.hikari.max-lifetime`</td><td>连接池中连接的最大存活时间，单位为秒</td></tr></table>\n\n<blockquote>\n<p><strong>茶歇时间：HikariCP 为什么说自己比别人快</strong></p>\n<p>HikariCP 官方一直将“快”作为自己的亮点。从官方性能测试的结果来看，HikariCP 的性能数倍于 DBCP2、C3P0 和 Tomcat 连接池。</p>\n<p>官方有一篇“Down the Rabbit Hole”的文章，简单说明了 HikariCP 性能出众的原因：</p>\n<ul>\n<li class=\"第3级无序列表\">通过字节码进行加速，<code>JavassistProxyFactory</code> 中使用 <code>Javassist</code> 直接生成了大量字节码塞到了 <code>ProxyFactory</code> 中，同时还对字节码进行了精确地优化；</li>\n<li class=\"第3级无序列表\">使用 <code>FastList</code> 代替了 JDK 内置的 <code>ArrayList</code>；</li>\n<li class=\"第3级无序列表\">从 .NET 中借鉴了无锁集合 <code>ConcurrentBag</code>。</li>\n</ul>\n<p>由此可见，HikariCP 的作者还是在连接池的性能调优方面下了很多功夫的，甚至可以说用上了不少“奇技淫巧”。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>Druid</strong></p>\n<p>阿里巴巴开源的 Druid 数据库连接池在阿里巴巴集团内部得到了广泛的应用，在国内也有大量的使用者。暂且不论 Druid 是否是 Java 语言中最好的数据库连接池，但其官方宣称它是面向监控而生的数据库连接池倒是一个不争的事实。在监控能力之外，Druid 还提供了很丰富的功能，例如：</p>\n<ul>\n<li>针对主流数据库的适配，包含驱动、连接检查、异常等；</li>\n<li>内置 SQL 注入防火墙功能；</li>\n<li>内置数据库密码非对称加密功能；</li>\n<li>内置针对数据库异常的 <code>ExceptionSorter</code>，可对不同的异常进行区别对待；</li>\n<li>内置丰富的日志信息；</li>\n<li>提供了强大的扩展能力，可在 JDBC 连接操作的各个阶段注入自己的逻辑。</li>\n</ul>\n<p>如果用一个字来形容 HikariCP 的特点，那就是“快”，它需要配合其他的一些组件才能实现某些功能。Druid 的特点应该就是“全”，仅其内置的功能就已经能满足绝大部分生产环境中的苛刻要求了，更不用说我们还能对它进行扩展。</p>\n<p>Druid 提供了一个 Spring Boot Starter 来适配 Spring Boot 的自动配置功能。也就是说，除了自己动手配置一个 <code>DruidDataSource</code> Bean 以外，我们也可以通过自动配置的方式来提供数据源的 Bean。</p>\n<p>仍旧以上面的 <code>DataSourceDemo</code> 为例，在 pom.xml 中添加如下依赖（版本可通过官方主页查询）即可引入 Druid 的支持。如果可以的话，建议从 spring-boot-starter-jdbc 中排除掉 HikariCP 的依赖，因为项目中不再需要它了：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;1.2.8&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>对于测试代码，我们也稍作调整，将判断的条件替换为 Druid 的类，具体如代码示例 6-3 所示。<span class=\"comment-number\">3</span></p>\n<blockquote>\n<p><strong>代码示例 6-3</strong>　<code>DatasourceDemoApplicationTests</code> 测试类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass DatasourceDemoApplicationTests {\n    @Autowired\n    private ApplicationContext applicationContext;\n\n    @Test\n    void testDataSource() throws SQLException {\n        assertTrue(applicationContext.containsBean(\"dataSource\"));\n        DataSource dataSource = applicationContext.getBean(\"dataSource\", DataSource.class);\n        assertTrue(dataSource instanceof DruidDataSource);\n\n        Connection connection = dataSource.getConnection();\n        assertTrue(connection instanceof DruidPooledConnection);\n        connection.close();\n\n        assertEquals(DruidDataSource.DEFAULT_MAX_ACTIVE_SIZE,((DruidDataSource) dataSource).getMaxActive());\n    }\n}</code></pre>\n<p>在判断出使用了 H2 内嵌数据库后，通过 druid-spring-boot-starter 也能自动创建数据源的 Bean。我们对其类型和一些默认配置做了判断。与 HikariCP 类似，Druid 也提供了很多配置项，其中常用的内容如表 6-2 所示，关于 Druid 的高阶功能，我们会在后续的章节中再展开讨论。</p>\n<p><strong>表 6-2　Druid 的常用配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>Spring Boot 配置属性</th><th>配置含义</th></tr><tr><td>`url`</td><td>`spring.datasource.url`</td><td>用于连接数据库的 JDBC URL</td></tr><tr><td>`username`</td><td>`spring.datasource.username`</td><td>连接数据库使用的用户名</td></tr><tr><td>`password`</td><td>`spring.datasource.password`</td><td>连接数据库使用的密码</td></tr><tr><td>`initialSize`</td><td>`spring.datasource.druid.initial-size`</td><td>初始化连接池时建立的连接数</td></tr><tr><td>`maxActive`</td><td>`spring.datasource.druid.max-active`</td><td>连接池中的最大连接数</td></tr><tr><td>`minIdle`</td><td>`spring.datasource.druid.min-idle`</td><td>连接池中保持的最小空闲连接数</td></tr><tr><td>`maxWait`</td><td>`spring.datasource.druid.max-wait`</td><td>获取连接的最大等待时间，单位为毫秒</td></tr><tr><td>`testOnBorrow`</td><td>`spring.datasource.druid.test-on-borrow`</td><td>获取连接时检查连接，会影响性能</td></tr><tr><td>`testOnReturn`</td><td>`spring.datasource.druid.test-on-return`</td><td>归还连接时检查连接，会影响性能</td></tr><tr><td>`testWhileIdle`</td><td>`spring.datasource.druid.test-while-idle`</td><td>检查空闲的连接，具体的检查发生在获取时，对性能几乎无影响</td></tr><tr><td>`filters`</td><td>`spring.datasource.druid.filters`</td><td>要配置的插件过滤器列表</td></tr></table>\n\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_93\">6.1.2　数据源配置详解</h3>\n<p>Spring Boot 为了减少数据源的配置工作，做了大量的基础工作，比如：</p>\n<ul>\n<li>提供了方便的 <code>spring.datasource</code> 通用配置参数；</li>\n<li>提供了针对多种连接池的单数据源自动配置；</li>\n<li>提供了针对内嵌数据库的特殊自动配置。</li>\n</ul>\n<p>接下来就让我们分别来了解这些特性以及它们的实现原理。在本节的最后，会以 MySQL 为例，配置一个数据源。</p>\n<ol>\n<li><p><strong>数据源配置参数详解</strong></p>\n<p>Spring Boot 为数据源配置提供了一个 <code>DataSourceProperties</code>，用于绑定 <code>spring.datasource</code> 的配置内容。它的类定义如下：</p>\n<pre class=\"code-rows\"><code>@ConfigurationProperties(prefix = \"spring.datasource\")\npublic class DataSourceProperties implements BeanClassLoaderAware, InitializingBean {}</code></pre>\n<p>之前在介绍 HikariCP 和 Druid 时，我们已经看到过一些配置项了，现在再跟着 <code>DataSourceProperties</code> 重新认识一下 Spring Boot 提供的配置项，具体如表 6-3 所示。</p>\n<p><strong>表 6-3　Spring Boot 提供的部分常用 <code>spring.datasource</code> 配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>spring.datasource.url</code></td><td></td><td>数据库的 JDBC URL</td></tr><tr><td><code>spring.datasource.username</code></td><td></td><td>连接数据库的用户名</td></tr><tr><td><code>spring.datasource.password</code></td><td></td><td>连接数据库的密码</td></tr><tr><td><code>spring.datasource.name</code></td><td>使用内嵌数据库时为 <code>testdb</code></td><td>数据源的名称</td></tr><tr><td><code>spring.datasource.jndi-name</code></td><td></td><td>获取数据源的 JNDI 名称</td></tr><tr><td><code>spring.datasource.type</code></td><td>根据 CLASSPATH 自动探测</td><td>连接池实现的全限定类名</td></tr><tr><td><code>spring.datasource.driver-class-name</code></td><td>根据 URL 自动探测</td><td>JDBC 驱动类的全限定类名</td></tr><tr><td><code>spring.datasource.generate-unique-name</code></td><td><code>true</code></td><td>是否随机生成数据源名称</td></tr></table>\n\n<p>我们一般会配置表 6-3 中的前三个配置项，再结合一些连接池的配置（Spring Boot 内置了对 HikariCP、DBCP2 和 Tomcat 连接池的支持），还有其他对应的配置，分别放在了如下前缀的配置项中：</p>\n<ul>\n<li><code>spring.datasource.hikari.*</code>（在之前的章节中已经见过一些了）；</li>\n<li><code>spring.datasource.dbcp2.*</code>；</li>\n<li><code>spring.datasource.tomcat.*</code>。</li>\n</ul>\n<p>还有一些与初始化相关的配置，稍后再做说明。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>数据源自动配置详解</strong></p>\n<p>Spring Boot 的数据源自动配置，是一个很好的自动配置实现示范。我们通过 <code>DataSourceAutoConfiguration</code> 类可以学习到很多自动配置的技巧，例如条件控制、内嵌配置类、导入其他配置等。</p>\n<p><code>DataSourceAutoConfiguration</code> 会先判断是否存在 <code>DataSource</code> 和 <code>EmbeddedDatabaseType</code>，满足条件则导入 <code>DataSourcePoolMetadataProvidersConfiguration</code> 和 <code>DataSourceInitializationConfiguration</code> 两个配置类，前者配置连接池元数据提供者，后者进行数据源初始化配置。</p>\n<p>整个 <code>DataSourceAutoConfiguration</code> 分为两个内嵌配置类——内嵌数据库配置类 <code>EmbeddedDatabaseConfiguration</code> 和连接池数据源配置类 <code>PooledDataSourceConfiguration</code>。下面来看一下连接池数据源的配置。</p>\n<p><code>PooledDataSourceConfiguration</code> 会直接导入 <code>DataSourceConfiguration</code> 中关于 HikariCP、DBCP2、Tomcat 和通用数据源的配置，随后这些配置类再根据自己的条件决定是否生效；此外 <code>DataSourceJmxConfiguration</code> 配置类也会根据条件将不同数据库连接池的信息发布到 JMX 端点上。</p>\n<p>我们以 HikariCP 的自动配置 <code>DataSourceConfiguration.Hikari</code> 为例，来看一下 Spring Boot 是如何为我们自动配置 <code>DataSource</code> 的。其他类型数据库连接池的配置与它大同小异，下面是具体的代码：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(HikariDataSource.class)\n@ConditionalOnMissingBean(DataSource.class)\n@ConditionalOnProperty(name = \"spring.datasource.type\", havingValue = \"com.zaxxer.hikari.\nHikariDataSource\", matchIfMissing = true)\nstatic class Hikari {\n    @Bean\n    @ConfigurationProperties(prefix = \"spring.datasource.hikari\")\n    HikariDataSource dataSource(DataSourceProperties properties) {\n        HikariDataSource dataSource = createDataSource(properties, HikariDataSource.class);\n        if (StringUtils.hasText(properties.getName())) {\n            dataSource.setPoolName(properties.getName());\n        }\n        return dataSource;\n    }\n}</code></pre>\n<p>首先，判断 CLASSPATH 中存在 <code>HikariDataSource</code> 类，并且尚未配置 <code>DataSource</code>。如果配置了 <code>spring.datasource.type</code> 并且是 HikariCP 的类，或者这个属性为空，则配置生效。</p>\n<p>接着，创建一个 <code>HikariDataSource</code> 数据源对象，如果指定了数据源名称，则进行赋值。</p>\n<p>最后，通过 <code>@ConfigurationProperties</code> 将 <code>spring.datasource.hikari.*</code> 的属性都绑定到返回的 <code>HikariDataSource</code> 对象上，这个对象就是 Spring 上下文中的 <code>DataSource</code> Bean 了。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>内嵌数据库的特殊逻辑</strong></p>\n<p>在之前的示例中，我们使用了 H2 内嵌数据库，它可以轻松地将所有数据保存在本机内存中 <span class=\"comment-number\">4</span>，程序关闭后，内存中的数据就消失了。因此，H2 用来作为测试数据库非常合适。我们在后续的示例中也会大量地使用 H2。</p>\n<p><code>EmbeddedDatabaseType</code> 定义了 Spring Boot 内置支持的三种数据库，即 HSQL、H2 和 Derby，<code>EmbeddedDatabaseConnection</code> 则分别定义了三者的 JDBC 驱动类和用来创建内存数据库的 JDBC URL。系统启动时会根据 CLASSPATH 来判断是否存在对应的驱动类。随后，<code>EmbeddedDataSourceConfiguration.dataSource()</code> 方法会根据前面的信息来创建 <code>DataSource</code> 对象。</p>\n<p>创建完内嵌数据库的 <code>DataSource</code> 后，Spring Boot 还会为我们进行数据库的初始化工作，我们可以在这个过程中建表，并导入初始的数据。初始化动作是由 <code>DataSourceInitializer</code> 类来实现的，它会根据 <code>spring.sql.init.schema-locations</code> 和 <code>spring.sql.init.data-locations</code> 这两个属性来初始化数据库中的表和数据，默认通过读取 CLASSPATH 中的 schema.sql 和 data.sql 文件来进行初始化。表 6-4 罗列了一些与数据源初始化相关的配置项 <span class=\"comment-number\">5</span>。</p>\n<p><strong>表 6-4　与数据源初始化相关的配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>当前配置项</th><th>旧配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>spring.sql.init.mode</code></td><td><code>spring.datasource.initialization-mode</code></td><td><code>embedded</code></td><td>何时使用 DDL 和 DML<sup><b>6</b></sup>脚本初始化数据源，可选值为 <code>embedded</code>、<code>always</code> 和 <code>never</code></td></tr><tr><td><code>spring.sql.init.platform</code></td><td><code>spring.datasource.platform</code></td><td><code>all</code></td><td>脚本对应的平台，用来拼接最终的 SQL 脚本文件名，例如，schema-.sql</td></tr><tr><td><code>spring.sql.init.separator</code></td><td><code>spring.datasource.separator</code></td><td><code>;</code></td><td>脚本中的语句分隔符</td></tr><tr><td><code>spring.sql.init.encoding</code></td><td><code>spring.datasource.sql-script-encoding</code></td><td></td><td>SQL 脚本的编码</td></tr><tr><td><code>spring.sql.init.continue-on-error</code></td><td><code>spring.datasource.continue-on-error</code></td><td><code>false</code></td><td>初始化过程中报错是否停止初始化</td></tr><tr><td><code>spring.sql.init.schema-locations</code></td><td><code>spring.datasource.schema</code></td><td></td><td>初始化用的 DDL 脚本，默认会用 schema.sql</td></tr><tr><td><code>spring.sql.init.username</code></td><td><code>spring.datasource.schema-username</code></td><td></td><td>DDL 语句运行所用的用户名，如与连接用的不一样，可在此指定</td></tr><tr><td><code>spring.sql.init.password</code></td><td><code>spring.datasource.schema-password</code></td><td></td><td>DDL 语句运行所用的密码，如与连接用的不一样，可在此指定</td></tr><tr><td><code>spring.sql.init.data-locations</code></td><td><code>spring.datasource.data</code></td><td></td><td>初始化用的 DML 脚本，默认会用 data.sql</td></tr><tr><td><code>spring.sql.init.username</code></td><td><code>spring.datasource.data-username</code></td><td></td><td>DML 语句运行所用的用户名，如与连接用的不一样，可在此指定</td></tr><tr><td><code>spring.sql.init.password</code></td><td><code>spring.datasource.data-password</code></td><td></td><td>DML 语句运行所用的密码，如与连接用的不一样，可在此指定</td></tr></table>\n\n<blockquote>\n<p><sup><b>6</b></sup>DDL 是数据定义语言，一般对应与表结构相关的内容；DML 是数据操作语言，一般对应与表数据库增删改查相关的操作内容。</p>\n</blockquote>\n<p>第一个配置项就告诉我们，Spring Boot 只是默认为内嵌数据库做初始化，其实，我们也可以对任意数据库进行初始化。不过在实际生产中，这种初始化工作很少由系统来实现，更多的是通过一定的流程，经 DBA 审批后自动或人工进行变更的。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置一个连接 MySQL 的数据源</strong></p>\n<p>在工作中，我们的系统一般都会连接类似 MySQL、Oracle 这样的数据库，很少会用 H2、Derby，所以在本节的最后，我们以 MySQL 为例，看看 Spring Boot 程序该如何来连接生产数据库。</p>\n<p>要连接数据库，首先需要在 pom.xml 的 <code>&lt;dependencies/&gt;</code> 中加入 MySQL 的 JDBC 驱动，可以像下面这样添加依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;mysql&lt;/groupId&gt;\n    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>spring-boot-dependencies 会自动为我们管理 mysql-connector-java 的版本。例如，Spring Boot 2.6.3 中用的就是 mysql-connector-java 8.0.28。随后，我们在 <code>application.properties</code> 中添加与数据源相关的配置，如代码示例 6-4<span class=\"comment-number\">7</span> 所示。</p>\n<blockquote>\n<p><strong>代码示例 6-4</strong>　<code>application.properties</code> 中 MySQL 数据源的配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.datasource.url=jdbc:mysql://localhost/binary-tea?useUnicode=true&amp;characterEncoding=utf8\nspring.datasource.username=binary-tea\nspring.datasource.password=binary-tea\nspring.datasource.hikari.maximum-pool-size=20\nspring.datasource.hikari.minimum-idle=10</code></pre>\n<p>这个配置会连接本机安装的 MySQL，端口是默认的 <code>3306</code>，连接的数据库是 <code>binary-tea</code>，用户名和密码也是 <code>binary-tea</code>。</p>\n<blockquote>\n<p><strong>请注意</strong>　在生产环境请不要使用这样的“弱密码”，而且密码不要用明文配置在文件中。</p>\n</blockquote>\n<p>随后，对测试代码稍作修改，让它检查一下我们是否成功连接了 MySQL。具体见代码示例 6-5。</p>\n<blockquote>\n<p><strong>代码示例 6-5</strong>　<code>DatasourceDemoApplicationTests</code> 测试类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass DatasourceDemoApplicationTests {\n    @Autowired\n    private ApplicationContext applicationContext;\n    @Value(\"$\")\n    private String jdbcUrl;\n\n    @Test\n    void testDataSource() throws SQLException {\n        assertTrue(applicationContext.containsBean(\"dataSource\"));\n        DataSource dataSource = applicationContext.getBean(\"dataSource\", DataSource.class);\n        assertTrue(dataSource instanceof HikariDataSource);\n\n        HikariDataSource hikari = (HikariDataSource) dataSource;\n        assertEquals(20, hikari.getMaximumPoolSize());\n        assertEquals(10, hikari.getMinimumIdle());\n        assertEquals(\"com.mysql.cj.jdbc.Driver\", hikari.getDriverClassName());\n        assertEquals(jdbcUrl, hikari.getJdbcUrl());\n\n        Connection connection = hikari.getConnection();\n        assertNotNull(connection);\n        connection.close();\n    }\n}</code></pre>\n<p>通过这个测试，我们可以看到 Spring Boot 根据我们的 JDBC URL 和 CLASSPATH 自动推断出了所需的 JDBC 驱动类，并将其设置为了 <code>com.mysql.cj.jdbc.Driver</code>。我们也可以自己来创建 <code>DataSource</code> Bean，HikariCP 本身也能自己来选择驱动，但如果此时 <code>driverClassName</code> 为空，则可以去掉那个判断。代码示例 6-6 是自己创建 Bean 的代码。</p>\n<blockquote>\n<p><strong>代码示例 6-6</strong>　自己配置 <code>HikariDataSource</code> Bean 的代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Bean\n@ConfigurationProperties(\"spring.datasource.hikari\")\npublic DataSource dataSource(DataSourceProperties properties) {\n    HikariDataSource dataSource = new HikariDataSource();\n    dataSource.setJdbcUrl(properties.getUrl());\n    dataSource.setUsername(properties.getUsername());\n    dataSource.setPassword(properties.getPassword());\n    return dataSource;\n}</code></pre>\n<p>如果使用 XML 的方式，可能会像下面这样：</p>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n    https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n\n    &lt;bean id=\"dataSource\" class=\"com.zaxxer.hikari.HikariDataSource\"&gt;\n        &lt;property name=\"jdbcUrl\" ref=\"$\"/&gt;\n        &lt;property name=\"username\" ref=\"$\"/&gt;\n        &lt;property name=\"password\" ref=\"$\"/&gt;\n        &lt;property name=\"maxPoolSize\" ref=\"$\"/&gt;\n        &lt;property name=\"minIdle\" ref=\"$\"/&gt;\n        &lt;!-- 其他配置省略 --&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre>\n<blockquote>\n<p><strong>茶歇时间：使用 Docker 简化本地开发环境的准备工作</strong></p>\n<p>随着容器技术的普及，在生产和测试环境使用 Kubernetes 早已不是什么新鲜事了。容器中不仅包含了我们的工程，还包含了工程运行所需的整个环境。而且，容器技术相比传统的虚拟机更节省资源，运行效率更高，是交付与运行的理想之选。</p>\n<p>Docker 是目前比较常用的容器，它提供了针对不同操作系统的支持，可以非常方便地在本地搭建起一套环境。在开发时，我们经常需要搭建各种基础设施，比如，MySQL 数据库、Redis、Zookeeper 等。有了 Docker，搭建这些基础设施就变成了简单的几条命令。</p>\n<p>以上面提到的 MySQL 为例，要在本机从头开始搭建一套 MySQL，只需简单的两句命令。</p>\n<p>首先，通过 <code>docker pull</code> 命令从仓库 <span class=\"comment-number\">8</span>中获取 MySQL 的镜像：</p>\n<pre class=\"code-rows\"><code>▸ docker pull mysql</code></pre>\n<p>接着，根据官方镜像的说明运行 MySQL，并进行相应的初始化：</p>\n<pre class=\"code-rows\"><code>▸ docker run --name binary-tea-mysql -d -p 3306:3306 -v ~/docker-data/mysql/binary-tea:/var/lib/mysql -e MYSQL_DATABASE=binary-tea -e MYSQL_USER=binary-tea -e MYSQL_PASSWORD=binary-tea -e MYSQL_ROOT_PASSWORD=root_password mysql</code></pre>\n<p>这里，我们简单说明一下 <code>docker run</code> 的命令，命令最后的 <code>mysql</code> 是镜像名，前面几个参数的作用见表 6-5。</p>\n<p><strong>表 6-5　<code>docker run</code> 命令中几个参数的作用</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>参数</th><th>作用</th></tr><tr><td><code>--name</code></td><td>指定了运行后容器的名称，如果不指定的话，Docker 会自动生成一个</td></tr><tr><td><code>-d</code></td><td>在后台运行容器</td></tr><tr><td><code>-p</code></td><td>将容器中的端口映射到宿主机上，例如，这里就可以通过本机的 3306 端口来访问容器的 3306 端口</td></tr><tr><td><code>-v</code></td><td>将宿主机的某个目录挂载到容器中，例如，这里就把本机的 ~/docker-data/mysql/binary-tea 目录挂载到了容器里</td></tr><tr><td><code>-e</code></td><td>用来指定容器的环境变量</td></tr></table>\n\n</blockquote>\n<p>除了 <code>docker run</code>，常用的命令还有 <code>docker stop</code>、<code>docker start</code> 和 <code>docker ps</code>。<code>docker stop</code> 用来停止运行中的容器，<code>docker start</code> 则是将停止运行的容器再启动起来，例如，可以用 <code>docker stop binary-tea-mysql</code> 来停止刚才由 <code>docker run</code> 创建的容器。<code>docker ps</code> 命令可以查看当前正在运行的容器。</p>\n<p>Docker 涉及的内容非常多，如果大家感兴趣的话，可以前往其官方网站了解更多信息。</p>\n</li>\n</ol>\n\n\n\n\n<h2 id=\"nav_point_94\">6.2　使用 JDBC 操作数据库</h2>\n<p>在建立了数据源之后，想要操作数据，最简单的办法就是使用 JDBC 提供的接口，正如 6.1 节开头那样。但使用原生 API 需要做很多模板化的工作，而且在一些细节上如果处理不当也会造成一些麻烦。Spring Framework 为我们提供了一整套关于 JDBC 的封装，Spring Boot 更是贴心地提供了相关的自动配置。在本节中，我们就来了解一些与数据操作相关的内容。</p>\n<p>说起 JDBC 操作，最基本的就是增删改查操作，但无论是什么操作，都遵循一个基本的流程：</p>\n<p>(1) 获取 <code>Connection</code> 连接；</p>\n<p>(2) 通过 <code>Connection</code> 创建 <code>Statement</code> 或者 <code>PreparedStatement</code>；</p>\n<p>(3) 执行具体的 SQL 操作；</p>\n<p>(4) 关闭 <code>Statement</code> 或者 <code>PreparedStatement</code>；</p>\n<p>(5) 关闭 <code>Connection</code>。</p>\n<p>可以看到，其中只有第 (3) 步是与我们的逻辑有关的，其他的步骤都是基本一样的，GoF 23 中的模板模式就非常适用这种情况。实际上，Spring Framework 也是这么做的，它为我们提供了 <code>JdbcTemplate</code> 和 <code>NamedParameterJdbcTemplate</code> 两个模板类，我们可以通过它们进行各种 SQL 操作。</p>\n<p>接下来，让我们以 <code>JdbcTemplate</code> 为例来了解下如何通过模板类进行增删改查操作。</p>\n<h3 id=\"nav_point_95\">6.2.1　查询类操作</h3>\n<p><code>JdbcTemplate</code> 中提供了很多参数与返回类型的 <code>query</code> 前缀方法，其中，比较常用的是 <code>query()</code> 和 <code>queryForObject()</code>。它们也有很多参数和返回类型，本节中只会介绍其中的几个，其他的可以通过 JavaDoc 或者 <code>JdbcTemplate</code> 的代码来了解。现在，继续以我们的奶茶店系统为例，演示一下 JDBC 相关的操作。</p>\n<blockquote>\n<p><strong>需求描述</strong>　假设，顾客进店点饮品，我们需要准备一份菜单，其中包含饮品的名称和价格。此处，需要提供两个查询方法，一个用来查询菜单中的条目总数，当条目总数多的时候，可以让顾客感觉我们店内饮品选择多样化，条目总数少的时候，可以说我们只做精品；另一个用来查询菜单的明细，在启动时打印一下店里的菜单。</p>\n</blockquote>\n<p>以第 5 章的 binarytea-endpoint 例子作为基础，我们新建一个 <code>binarytea-jdbc</code> 项目，菜单信息会被保存在名为 <code>t_menu</code> 的表中，并提供相应的接口。<span class=\"comment-number\">9</span> 在项目的 pom.xml 文件依赖中增加如下内容，分别是 Spring Boot 的 JDBC 依赖、H2 数据库依赖以及 Lombok。</p>\n\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n    &lt;artifactId&gt;h2&lt;/artifactId&gt;\n    &lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n    &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;</code></pre>\n<p>先为菜单条目创建一个对应的模型（Model）类，其中的内容与数据表结构一一对应。在后续操作时，它可以将查询所得结果转换为这个类型，这样更便于使用，也易于理解，具体见代码示例 6-7。其中，我们通过 Lombok 注解减少了大量方法代码的编写工作。</p>\n<blockquote>\n<p><strong>请注意</strong>　请务必事先在 IDEA 中安装 Lombok 插件。</p>\n</blockquote>\n<p>&nbsp;</p>\n<blockquote>\n<p><strong>代码示例 6-7</strong>　<code>MenuItem</code> 类的声明</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.binarytea.model;\n\n// 省略 import\n\n@Builder\n@Getter\n@Setter\n@ToString\npublic class MenuItem {\n    private Long id;\n    private String name;\n    private String size;\n    private BigDecimal price; // 暂时用BigDecimal表示金额\n    private Date createTime;\n    private Date updateTime;\n}</code></pre>\n<p>主要的查询逻辑都会放在 <code>MenuRepository</code> 中，这个类上添加了 <code>@Repository</code> 注解，用来告诉 Spring 容器这个类要创建 Bean 实例，并且它代表了一个数据仓库（Repository）。容器会自动注入构造方法所需的 <code>JdbcTemplate</code> 实例，我们也可以提供空构造方法，在 <code>jdbcTemplate</code> 的声明上添加 <code>@Autowired</code>，效果是一样的。具体的类声明见代码示例 6-8。</p>\n<blockquote>\n<p><strong>代码示例 6-8</strong>　<code>MenuRepository</code> 类的声明</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.binarytea.repository;\n\n// 省略import\n\n@Repository\npublic class MenuRepository {\n    private JdbcTemplate jdbcTemplate;\n\n    public MenuRepository(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n    // 几个查询方法待说明\n}</code></pre>\n<p>要查询的 SQL 只返回一个值，那么可以使用 <code>queryForObject(String sql, Class&lt;T&gt; requiredType)</code> 方法，例如，代码示例 6-9 会返回表中记录的总数。</p>\n<blockquote>\n<p><strong>代码示例 6-9</strong>　统计总数的 <code>countMenuItems()</code> 方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public long countMenuItems() {\n    return jdbcTemplate.queryForObject(\"select count(*) from t_menu\", Long.class);\n}</code></pre>\n<p>返回的结果有多个字段，可以用 <code>queryForMap()</code> 将它们都放到一个 <code>Map&lt;String, Object&gt;</code> 中，也可以通过 <code>RowMapper</code> 将字段映射到某个对象上。例如，代码示例 6-10 用 <code>queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, @Nullable Object... args)</code> 方法查询单条记录，并将字段内容填充进 <code>MenuItem</code> 里。</p>\n<blockquote>\n<p><strong>代码示例 6-10</strong>　查询单条记录的 <code>queryForItem()</code> 方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public MenuItem queryForItem(Long id) {\n    return jdbcTemplate.queryForObject(\"select * from t_menu where id = ?\", rowMapper(), id);\n}\n\nprivate RowMapper&lt;MenuItem&gt; rowMapper() {\n    return (resultSet, rowNum) -&gt; {\n        return MenuItem.builder()\n                .id(resultSet.getLong(\"id\"))\n                .name(resultSet.getString(\"name\"))\n                .size(resultSet.getString(\"size\"))\n                .price(BigDecimal.valueOf(resultSet.getLong(\"price\") / 100.0d))\n                .createTime(new Date(resultSet.getDate(\"create_time\").getTime()))\n                .updateTime(new Date(resultSet.getDate(\"update_time\").getTime()))\n                .build();\n    };\n}</code></pre>\n<p>其中的 <code>RowMapper&lt;MenuItem&gt;</code> 可以直接通过 Lambda 的方式写在方法调用里，但为了能够复用这个 <code>RowMapper</code>，我们将它单独“抽”了出来。</p>\n<p>一个查询操作如果要求返回多条记录，可以使用 <code>query(String sql, RowMapper&lt;T&gt; rowMapper)</code>。代码示例 6-11 的 <code>queryAllItems()</code> 可以返回全部的菜单内容，其中还用到了上面定义的 <code>rowMapper()</code>。</p>\n<blockquote>\n<p><strong>代码示例 6-11</strong>　返回全部菜单的 <code>queryAllItems()</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>public List&lt;MenuItem&gt; queryAllItems() {\n    return jdbcTemplate.query(\"select * from t_menu\", rowMapper());\n}</code></pre>\n<p>为了让查询能够正常执行，我们需要为 H2 数据库建表并添加一些初始数据 <span class=\"comment-number\">10</span>，它们被分别放在工程 src/resources 目录的 schema.sql 和 data.sql 中，具体内容见代码示例 6-12 与代码示例 6-13。</p>\n\n<blockquote>\n<p><strong>代码示例 6-12</strong>　包含表结构定义的 schema.sql</p>\n</blockquote>\n<pre class=\"code-rows\"><code>drop table t_menu if exists;\n\ncreate table t_menu (\n    id bigint auto_increment,\n    name varchar(128),\n    size varchar(16),\n    price bigint,\n    create_time timestamp,\n    update_time timestamp,\n    primary key (id)\n);</code></pre>\n<blockquote>\n<p><strong>代码示例 6-13</strong>　包含初始数据的 data.sql</p>\n</blockquote>\n<pre class=\"code-rows\"><code>insert into t_menu (name, size, price, create_time, update_time) values ('Java咖啡', '中杯', 1000, now(), now());\ninsert into t_menu (name, size, price, create_time, update_time) values ('Java咖啡', '大杯', 1500, now(), now());</code></pre>\n<p>为了保证 <code>MenuRepository</code> 类的功能正确，我们需要添加一些单元测试，根据上面构造的数据对方法的调用结果进行判断，就像代码示例 6-14 中演示的那样。</p>\n<blockquote>\n<p><strong>代码示例 6-14</strong>　<code>MenuRepositoryTest</code> 中的测试代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\nclass MenuRepositoryTest {\n    @Autowired\n    private MenuRepository menuRepository;\n\n    @Test\n    void testCountMenuItems() {\n        assertEquals(2, menuRepository.countMenuItems());\n    }\n\n    @Test\n    void testQueryAllItems() {\n        List&lt;MenuItem&gt; items = menuRepository.queryAllItems();\n        assertNotNull(items);\n        assertFalse(items.isEmpty());\n        assertEquals(2, items.size());\n    }\n\n    @Test\n    void testQueryForItem() {\n        MenuItem item = menuRepository.queryForItem(1L);\n        assertItem(item, 1L, \"Java咖啡\", \"中杯\", BigDecimal.valueOf(10.00));\n    }\n\n    private void assertItem(MenuItem item, Long id, String name, String size, BigDecimal price) {\n        assertNotNull(item);\n        assertEquals(id, item.getId());\n        assertEquals(name, item.getName());\n        assertEquals(size, item.getSize());\n        assertEquals(price, item.getPrice());\n    }\n}</code></pre>\n<p>单元测试中，我们通过各种断言自动验证了方法的返回内容，在自动化测试过程中无须人的介入，并且可以反复执行。断言是单元测试中<strong>必不可少</strong>的部分，千万不要用<strong>“日志输出＋人工观察”</strong>的方式。</p>\n<p>最后，编写启动后输出菜单的逻辑。我们可以通过 <code>ApplicationRunner</code> 来执行打印动作，如代码示例 6-15 所示。在 <code>MenuPrinterRunner</code> 上添加 Lombok 的 <code>@Slf4j</code> 注解，会自动生成一个 <code>log</code> 对象，即可用它来打印日志。</p>\n<blockquote>\n<p><strong>代码示例 6-15</strong>　<code>MenuPrinterRunner</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>package learning.spring.binarytea.runner;\n\n// 省略import\n\n@Component\n@Slf4j\npublic class MenuPrinterRunner implements ApplicationRunner {\n    private final MenuRepository menuRepository;\n\n    public MenuPrinterRunner(MenuRepository menuRepository) {\n        this.menuRepository = menuRepository;\n    }\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        log.info(\"共有{}个饮品可选。\", menuRepository.countMenuItems());\n        menuRepository.queryAllItems().forEach(i -&gt; log.info(\"饮品：{}\", i));\n    }\n}</code></pre>\n<p>整个程序在运行后，能在日志中找到类似下面这样的内容：</p>\n<pre class=\"code-rows\"><code>2022-02-13 00:01:48.838  INFO 70291 --- [main] l.s.binarytea.runner.MenuPrinterRunner  : 共有2个饮品可选。\n2022-02-13 00:01:48.841  INFO 70291 --- [main] l.s.binarytea.runner.MenuPrinterRunner  : 饮品：\nMenuItem(id=1, name=Java咖啡, size=中杯, price=10.0, createTime=Sun Feb 13 00:00:00 CST 2022,\nupdateTime=Sun Feb 13 00:00:00 CST 2022)\n2022-02-13 00:01:48.849 INFO 70291 --- [main] l.s.binarytea.runner.MenuPrinterRunner   : 饮品：\nMenuItem(id=2, name=Java咖啡, size=大杯, price=15.0, createTime=Sun Feb 13 00:00:00 CST 2022,\nupdateTime=Sun Feb 13 00:00:00 CST 2022)</code></pre>\n<h3 id=\"nav_point_96\">6.2.2　变更类操作</h3>\n<p><code>JdbcTemplate</code> 的 <code>update()</code> 方法可以用来执行修改类的 SQL 语句，比如 <code>INSERT</code>、<code>UPDATE</code> 和 <code>DELETE</code> 语句。以插入数据为例，大家可以简单地使用 <code>update(String sql, @Nullable Object... args)</code> 方法，这个方法的返回值是更新到的记录条数。插入一条菜单内容的代码大概是代码示例 6-16 这样的。</p>\n<blockquote>\n<p><strong>代码示例 6-16</strong>　插入一条记录</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public static final String INSERT_SQL =\n        \"insert into t_menu (name, size, price, create_time, update_time) values (?, ?, ?, now(), now())\";\n\npublic int insertItem(MenuItem item) {\n    return jdbcTemplate.update(INSERT_SQL, item.getName(),\n            item.getSize(), item.getPrice().multiply(BigDecimal.valueOf(100)).longValue());\n}</code></pre>\n<p>其中，SQL 语句后的参数顺序对应了 SQL 中 <code>?</code> 占位符的顺序。在很多时候，数据的 ID 是自增长的主键，如果我们希望在插入记录后能取得生成的 ID，这时可以使用 <code>KeyHolder</code> 类来持有生成的键。代码类似代码示例 6-17。</p>\n<blockquote>\n<p><strong>代码示例 6-17</strong>　插入一条记录并填充主键</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public int insertItemAndFillId(MenuItem item) {\n    KeyHolder keyHolder = new GeneratedKeyHolder();\n    int affected = jdbcTemplate.update(con -&gt; {\n        PreparedStatement preparedStatement =\n                con.prepareStatement(INSERT_SQL, PreparedStatement.RETURN_GENERATED_KEYS);\n        // 也可以用PreparedStatement preparedStatement =\n        //            con.prepareStatement(INSERT_SQL, new String[] { \"id\" });\n\n        preparedStatement.setString(1, item.getName());\n        preparedStatement.setString(2, item.getSize());\n        preparedStatement.setLong(3, item.getPrice().multiply(BigDecimal.valueOf(100)).longValue());\n        return preparedStatement;\n    }, keyHolder);\n    if (affected == 1) {\n        item.setId(keyHolder.getKey().longValue());\n    }\n    return affected;\n}</code></pre>\n<p>更新与删除操作使用的也是类似的手法，同样也是 <code>update()</code> 方法，例如，代码示例 6-18 将根据主键删除一条菜单项记录。</p>\n<blockquote>\n<p><strong>代码示例 6-18</strong>　删除一条菜单项记录</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public int deleteItem(Long id) {\n    return jdbcTemplate.update(\"delete from t_menu where id = ?\", id);\n}</code></pre>\n<p>上述增加和删除方法的测试会影响表中的记录数量，随机运行会导致对结果判断的不准确，因此需要指定测试的运行顺序。JUnit 5 提供了 <code>@TestMethodOrder</code> 注解来指定操作的执行顺序，可以选择字母序、注解顺序和随机三种。以注解顺序为例，代码大概会是代码示例 6-19 这样的。</p>\n<blockquote>\n<p><strong>代码示例 6-19</strong>　指定了注解顺序的测试代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootTest\n@TestMethodOrder(MethodOrderer.OrderAnnotation.class)\nclass MenuRepositoryTest {\n    @Autowired\n    private MenuRepository menuRepository;\n    // 省略了其他测试方法\n    @Test\n    @Order(1)\n    void testInsertItem() {\n        MenuItem item = MenuItem.builder().name(\"Go橙汁\").size(\"中杯\").price(BigDecimal.valueOf(12.00)).build();\n\n        assertEquals(1, menuRepository.insertItem(item));\n        assertNull(item.getId());\n        MenuItem queryItem = menuRepository.queryForItem(3L);\n        assertItem(queryItem, 3L, \"Go橙汁\", \"中杯\", BigDecimal.valueOf(12.00));\n\n        assertEquals(1, menuRepository.insertItemAndFillId(item));\n        queryItem = menuRepository.queryForItem(item.getId());\n        assertItem(queryItem, 4L, \"Go橙汁\", \"中杯\", BigDecimal.valueOf(12.00));\n    }\n\n    @Test\n    @Order(2)\n    void testDelete() {\n        assertEquals(1, menuRepository.deleteItem(3L));\n        assertEquals(1, menuRepository.deleteItem(2L));\n    }\n\n    private void assertItem(MenuItem item, Long id, String name, String size, BigDecimal price) {\n        assertNotNull(item);\n        assertEquals(id, item.getId());\n        assertEquals(name, item.getName());\n        assertEquals(size, item.getSize());\n        assertEquals(price, item.getPrice());\n    }\n}</code></pre>\n<p>在上面的例子里，我们的 SQL 中用到了很多 <code>?</code>，<code>?</code> 的数量一多，就容易在传参时搞错位置。Spring Framework 为我们提供了一个 <code>NamedParameterJdbcTemplate</code> 类，其中封装了很多 <code>JdbcTemplate</code> 的操作。<code>NamedParameterJdbcTemplate</code> 可以为 SQL 中的参数设定名称，然后根据名称进行赋值。Spring Boot 同样为它进行了自动配置，在只有一个或指定了主 <code>JdbcTemplate</code> 的 Bean 时，Spring Boot 就会自动配置一个 <code>NamedParameterJdbcTemplate</code> Bean。我们可以把上面的 <code>insertItem()</code> 修改成代码示例 6-20 这样。</p>\n<blockquote>\n<p><strong>代码示例 6-20</strong>　使用了 <code>NamedParameterJdbcTemplate</code> 的 <code>insertItem()</code> 方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public int insertItem(MenuItem item) {\n    String sql = \"insert into t_menu (name, size, price, create_time, update_time) values \" +\n            \"(:name, :size, :price, now(), now())\";\n    MapSqlParameterSource sqlParameterSource = new MapSqlParameterSource();\n    sqlParameterSource.addValue(\"name\", item.getName());\n    sqlParameterSource.addValue(\"size\", item.getSize());\n    sqlParameterSource.addValue(\"price\", item.getPrice().multiply(BigDecimal.valueOf(100)).longValue());\n    return namedParameterJdbcTemplate.update(sql, sqlParameterSource);\n}</code></pre>\n<p>在代码示例 6-20 中可以看到，SQL 中的占位符被替换为了具体的参数名称。在执行语句时，通过 <code>SqlParameterSource</code> 来传入参数，这个接口有多种实现，比如上面例子中的 <code>MapSqlParameterSource</code> 会以 <code>Map</code> 的形式来提供参数，<code>BeanPropertySqlParameterSource</code> 会从 Bean 属性中提取参数。</p>\n<h3 id=\"nav_point_97\">6.2.3　批处理操作</h3>\n<p>在数据处理时，我们经常会遇到需要插入或更新一大批数据的情况。大多数 JDBC 驱动针对批量调用相同 <code>PreparedStatement</code> 的情况都做了特殊优化，所以在 Spring Framework 中也为批处理操作提供了多个 <code>batchUpdate()</code> 方法，方法的返回是一个 <code>int[]</code>，代表每次执行语句的更新条数。</p>\n<blockquote>\n<p><strong>需求描述</strong>　二进制奶茶店目前的菜单内容还比较少，一条一条地添加勉强也可以接受，但内容多了之后，完整的操作过程就太慢了，效率也不高。为何不一次性添加一批菜单条目呢？搞个批量操作多好呀！</p>\n</blockquote>\n<p>我们可以设计一个批量插入数据的接口，像代码示例 6-21 那样，在 <code>batchUpdate()</code> 方法中，传入 <code>BatchPreparedStatementSetter</code> 来设置 <code>PreparedStatement</code> 占位符的内容。</p>\n<blockquote>\n<p><strong>代码示例 6-21</strong>　批量插入方法</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public int insertItems(List&lt;MenuItem&gt; items) {\n    int[] count = jdbcTemplate.batchUpdate(INSERT_SQL, new BatchPreparedStatementSetter() {\n        @Override\n        public void setValues(PreparedStatement ps, int i) throws SQLException {\n            MenuItem item = items.get(i);\n            ps.setString(1, item.getName());\n            ps.setString(2, item.getSize());\n            ps.setLong(3, item.getPrice().multiply(BigDecimal.valueOf(100)).longValue());\n        }\n\n        @Override\n        public int getBatchSize() {\n            return items.size();\n        }\n    });\n    return Arrays.stream(count).sum();\n}</code></pre>\n<p>上述方法的测试代码如代码示例 6-22 所示。我们通过 Java 8 的流式代码创建了 3 个菜单条目，将它们放在一个 <code>List&lt;MenuItem&gt;</code> 中，随后调用 <code>insertItems()</code> 方法，判断是否成功插入 3 条记录，并逐条验证了每条插入记录的内容。这里设置了 <code>@Order(3)</code> 来控制测试用例的执行顺序，因为上面插入过几条记录，所以本次新增的记录 ID 从 <code>5</code> 开始。如果是单独运行 <code>testInsertItems()</code>，那么 ID 要从 <code>3</code> 开始。</p>\n<blockquote>\n<p><strong>代码示例 6-22</strong>　<code>MenuRepositoryTest</code> 中关于 <code>insertItems()</code> 的测试代码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Test\n@Order(3)\nvoid testInsertItems() {\n    List&lt;MenuItem&gt; items = Stream.of(\"Go橙汁\", \"Python气泡水\", \"JavaScript苏打水\")\n            .map(n -&gt; MenuItem.builder().name(n).size(\"中杯\").price(BigDecimal.valueOf(12.00)).build())\n            .collect(Collectors.toList());\n    assertEquals(3, menuRepository.insertItems(items));\n    assertItem(menuRepository.queryForItem(3L), 3L, \"Go橙汁\", \"中杯\", BigDecimal.valueOf(12.00));\n    assertItem(menuRepository.queryForItem(4L), 4L, \"Python气泡水\", \"中杯\", BigDecimal.valueOf(12.00));\n    assertItem(menuRepository.queryForItem(5L), 5L, \"JavaScript苏打水\", \"中杯\", BigDecimal.valueOf(12.00));\n}</code></pre>\n<p><code>batchUpdate()</code> 方法还有其他几种形式，用起来也相对容易些，例如 <code>batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</code>，<code>Object[]</code> 就是按给定的顺序替换内容。<code>insertItems()</code> 可以改写成下面这样：</p>\n<pre class=\"code-rows\"><code>public int insertItems(List&lt;MenuItem&gt; items) {\n    List&lt;Object[]&gt; batchArgs = items.stream().map(item -&gt; new Object[]{\n            item.getName(), item.getSize(), item.getPrice().multiply(BigDecimal.valueOf(100)).longValue()})\n            .collect(Collectors.toList());\n    int[] count = jdbcTemplate.batchUpdate(INSERT_SQL, batchArgs);\n    return Arrays.stream(count).sum();\n}</code></pre>\n<p><code>NamedParameterJdbcTemplate</code> 中也提供了 <code>batchUpdate()</code> 方法，我们能使用 <code>SqlParameterSource</code> 来代表一条对应的内容。辅助类 <code>SqlParameterSourceUtils</code> 中有一些方法，可以帮我们把一批对象转换为 <code>SqlParameterSource[]</code>。同样的，我们可以用 <code>NamedParameterJdbcTemplate</code> 来改写 <code>insertItems()</code> 方法：</p>\n<pre class=\"code-rows\"><code>public int insertItems(List&lt;MenuItem&gt; items) {\n    String sql = \"insert into t_menu (name, size, price, create_time, update_time) values \" +\n            \"(:name, :size, :price * 100, now(), now())\";\n    int[] count = namedParameterJdbcTemplate.batchUpdate(sql, SqlParameterSourceUtils.createBatch(items));\n    return Arrays.stream(count).sum();\n}</code></pre>\n<p>这里我们实际使用的是 <code>BeanPropertySqlParameterSource</code>，从对象中提取属性对应到 SQL 中的命名参数上，<code>price</code> 的类型是 <code>BigDecimal</code>，单位是元，而数据库中我们的单位是分，所以在 SQL 语句中做了些小调整。</p>\n<h3 id=\"nav_point_98\">6.2.4　自动配置说明</h3>\n<p>上文提到 Spring Boot 提供了 <code>JdbcTemplate</code> 和 <code>NamedParameterJdbcTemplate</code> 的自动配置，接下来让我们详细看一下它的具体配置：</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })\n@ConditionalOnSingleCandidate(DataSource.class)\n@AutoConfigureAfter(DataSourceAutoConfiguration.class)\n@EnableConfigurationProperties(JdbcProperties.class)\n@Import({ DatabaseInitializationDependencyConfigurer.class, JdbcTemplateConfiguration.class,\nNamedParameterJdbcTemplateConfiguration.class })\npublic class JdbcTemplateAutoConfiguration {}</code></pre>\n<p>当 CLASSPATH 中存在 <code>DataSource</code> 和 <code>JdbcTemplate</code>，同时能明确一个主要的 <code>DataSource</code> Bean 时，<code>JdbcTemplateAutoConfiguration</code> 才会生效，而它的配置内容要看 <code>DatabaseInitializationDependencyConfigurer</code>、<code>JdbcTemplateConfiguration</code> 和 <code>NamedParameterJdbcTemplateConfiguration</code>，重点是后面两个。</p>\n<p><code>JdbcTemplateConfiguration</code> 会在没有配置 <code>JdbcOperations</code> 的实现 Bean 时生效，它的作用是提供一个 <code>JdbcTemplate</code> Bean，这个 Bean 会自动注入现有的 <code>DataSource</code>，并将 <code>spring.jdbc.template.*</code> 的配置项内容设置进来，相关配置及其说明见表 6-6。</p>\n<p><strong>表 6-6　<code>spring.jdbc.template.*</code> 的配置项</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置项</p></th>\n<th><p>默认值</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>spring.jdbc.template.fetch-size</code></p></td>\n<td><p><code>-1</code></p></td>\n<td><p>每次从数据库获取的记录条数，<code>-1</code> 表示使用驱动的默认值</p></td>\n</tr>\n<tr>\n<td><p><code>spring.jdbc.template.max-rows</code></p></td>\n<td><p><code>-1</code></p></td>\n<td><p>一次查询可获取的最大记录条数，<code>-1</code> 表示使用驱动的默认值</p></td>\n</tr>\n<tr>\n<td><p><code>spring.jdbc.template.query-timeout</code></p></td>\n<td><p>&nbsp;</p></td>\n<td><p>查询的超时时间，没有配置的话使用 JDBC 驱动的默认值，如果没有加时间单位，默认为秒</p></td>\n</tr>\n</tbody>\n</table>\n<p><code>NamedParameterJdbcTemplateConfiguration</code> 则比较简单，在能确定一个主要的 <code>JdbcTemplate</code>，同时又没有手动配置 <code>NamedParameterJdbcOperations</code> Bean 时，自动创建一个 <code>NamedParameter-JdbcTemplate</code> Bean，并将 <code>JdbcTemplate</code> 注入其中。</p>\n<p>如果我们不希望 Spring Boot 为我们做自动配置，只需要自己创建一个 <code>JdbcTemplate</code> 就可以了，比如像下面这样：</p>\n<pre class=\"code-rows\"><code>@Bean\npublic JdbcTemplate jdbcTemplate(DataSource dataSource) {\n    return new JdbcTemplate(dataSource);\n}</code></pre>\n","neighbors":{"left":{"article_title":"第二部分 Spring 中的数据操作","id":740868},"right":{"article_title":"第 6 章 Spring 中的 JDBC(2)","id":740870}},"comments":[{"had_liked":false,"id":392761,"user_name":"richen","can_delete":false,"product_type":"c1","uid":1031295,"ip_address":"陕西","ucode":"BC62C939571659","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6Ze7q22j9vt1iajg9feQ94DQsG9XWQGttg8rb8vIndAK68TI10lGalYviaJyRNsuk561iafAHpjeWqWZ1yTVeicl7Q/132","comment_is_top":false,"comment_ctime":1721717070,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636606,"comment_content":"需要配置spring.datasource.type=com.alibaba.druid.pool.DruidDataSource, 否则测试用例通不过","like_count":0}]}