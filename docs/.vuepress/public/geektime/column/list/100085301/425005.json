{"id":425005,"title":"22｜阶段实操（2）：构建一个简单的KV server-基本流程","content":"<p>你好，我是陈天。</p><p>上篇我们的KV store刚开了个头，写好了基本的接口。你是不是摩拳擦掌准备开始写具体实现的代码了？别着急，当定义好接口后，先不忙实现，在撰写更多代码前，我们可以从一个使用者的角度来体验接口如何使用、是否好用，反观设计有哪些地方有待完善。</p><p>还是按照上一讲定义接口的顺序来一个一个测试：首先我们来构建协议层。</p><h3>实现并验证协议层</h3><p>先创建一个项目：<code>cargo new kv --lib</code>。进入到项目目录，在 Cargo.toml 中添加依赖：</p><pre><code class=\"language-rust\">[package]\nname = \"kv\"\nversion = \"0.1.0\"\nedition = \"2018\"\n\n[dependencies]\nbytes = \"1\" # 高效处理网络 buffer 的库\nprost = \"0.8\" # 处理 protobuf 的代码\ntracing = \"0.1\" # 日志处理\n\n[dev-dependencies]\nanyhow = \"1\" # 错误处理\nasync-prost = \"0.2.1\" # 支持把 protobuf 封装成 TCP frame\nfutures = \"0.3\" # 提供 Stream trait\ntokio = { version = \"1\", features = [\"rt\", \"rt-multi-thread\", \"io-util\", \"macros\", \"net\" ] } # 异步网络库\ntracing-subscriber = \"0.2\" # 日志处理\n\n[build-dependencies]\nprost-build = \"0.8\" # 编译 protobuf\n</code></pre><!-- [[[read_end]]] --><p>然后在项目根目录下创建 abi.proto，把上文中 protobuf 的代码放进去。在根目录下，再创建 <a href=\"http://build.rs\">build.rs</a>：</p><pre><code class=\"language-rust\">fn main() {\n    let mut config = prost_build::Config::new();\n    config.bytes(&amp;[\".\"]);\n    config.type_attribute(\".\", \"#[derive(PartialOrd)]\");\n    config\n        .out_dir(\"src/pb\")\n        .compile_protos(&amp;[\"abi.proto\"], &amp;[\".\"])\n        .unwrap();\n}\n</code></pre><p>这个代码在<a href=\"https://time.geekbang.org/column/article/413634\">第 5 讲</a>已经见过了，<a href=\"http://build.rs\">build.rs</a> 在编译期运行来进行额外的处理。</p><p>这里我们为编译出来的代码额外添加了一些属性。比如为 protobuf 的 bytes 类型生成 Bytes 而非缺省的 Vec&lt;u8&gt;，为所有类型加入 PartialOrd 派生宏。关于 prost-build 的扩展，你可以看<a href=\"https://docs.rs/prost-build/0.8.0/prost_build/struct.Config.html\">文档</a>。</p><p>记得创建 src/pb 目录，否则编不过。现在，在项目根目录下做 <code>cargo build</code> 会生成 src/pb/abi.rs 文件，里面包含所有 protobuf 定义的消息的 Rust 数据结构。我们创建 src/pb/mod.rs，引入 <a href=\"http://abi.rs\">abi.rs</a>，并做一些基本的类型转换：</p><pre><code class=\"language-rust\">pub mod abi;\n\nuse abi::{command_request::RequestData, *};\n\nimpl CommandRequest {\n    /// 创建 HSET 命令\n    pub fn new_hset(table: impl Into&lt;String&gt;, key: impl Into&lt;String&gt;, value: Value) -&gt; Self {\n        Self {\n            request_data: Some(RequestData::Hset(Hset {\n                table: table.into(),\n                pair: Some(Kvpair::new(key, value)),\n            })),\n        }\n    }\n}\n\nimpl Kvpair {\n    /// 创建一个新的 kv pair\n    pub fn new(key: impl Into&lt;String&gt;, value: Value) -&gt; Self {\n        Self {\n            key: key.into(),\n            value: Some(value),\n        }\n    }\n}\n\n/// 从 String 转换成 Value\nimpl From&lt;String&gt; for Value {\n    fn from(s: String) -&gt; Self {\n        Self {\n            value: Some(value::Value::String(s)),\n        }\n    }\n}\n\n/// 从 &amp;str 转换成 Value\nimpl From&lt;&amp;str&gt; for Value {\n    fn from(s: &amp;str) -&gt; Self {\n        Self {\n            value: Some(value::Value::String(s.into())),\n        }\n    }\n}\n</code></pre><p>最后，在 src/lib.rs  中，引入 pb 模块：</p><pre><code class=\"language-rust\">mod pb;\npub use pb::abi::*;\n</code></pre><p>这样，我们就有了能把 KV server 最基本的 protobuf 接口运转起来的代码。</p><p>在根目录下创建 examples，这样可以写一些代码测试客户端和服务器之间的协议。我们可以先创建一个 examples/client.rs 文件，写入如下代码：</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse async_prost::AsyncProstStream;\nuse futures::prelude::*;\nuse kv::{CommandRequest, CommandResponse};\nuse tokio::net::TcpStream;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    tracing_subscriber::fmt::init();\n\n    let addr = \"127.0.0.1:9527\";\n    // 连接服务器\n    let stream = TcpStream::connect(addr).await?;\n\n    // 使用 AsyncProstStream 来处理 TCP Frame\n    let mut client =\n        AsyncProstStream::&lt;_, CommandResponse, CommandRequest, _&gt;::from(stream).for_async();\n\n    // 生成一个 HSET 命令\n    let cmd = CommandRequest::new_hset(\"table1\", \"hello\", \"world\".into());\n\n    // 发送 HSET 命令\n    client.send(cmd).await?;\n    if let Some(Ok(data)) = client.next().await {\n        info!(\"Got response {:?}\", data);\n    }\n\n    Ok(())\n}\n</code></pre><p>这段代码连接服务器的 9527 端口，发送一个 HSET 命令出去，然后等待服务器的响应。</p><p>同样的，我们创建一个 examples/dummy_server.rs 文件，写入代码：</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse async_prost::AsyncProstStream;\nuse futures::prelude::*;\nuse kv::{CommandRequest, CommandResponse};\nuse tokio::net::TcpListener;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    tracing_subscriber::fmt::init();\n    let addr = \"127.0.0.1:9527\";\n    let listener = TcpListener::bind(addr).await?;\n    info!(\"Start listening on {}\", addr);\n    loop {\n        let (stream, addr) = listener.accept().await?;\n        info!(\"Client {:?} connected\", addr);\n        tokio::spawn(async move {\n            let mut stream =\n                AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();\n            while let Some(Ok(msg)) = stream.next().await {\n                info!(\"Got a new command: {:?}\", msg);\n\t\t\t\t\t\t\t\t// 创建一个 404 response 返回给客户端\n                let mut resp = CommandResponse::default();\n                resp.status = 404;\n                resp.message = \"Not found\".to_string();\n                stream.send(resp).await.unwrap();\n            }\n            info!(\"Client {:?} disconnected\", addr);\n        });\n    }\n}\n</code></pre><p>在这段代码里，服务器监听 9527 端口，对任何客户端的请求，一律返回 status = 404，message 是 “Not found” 的响应。</p><p>如果你对这两段代码中的异步和网络处理半懂不懂，没关系，你先把代码抄下来运行。今天的内容跟网络无关，你重点看处理流程就行。未来会讲到网络和异步处理的。</p><p>我们可以打开一个命令行窗口，运行：<code>RUST_LOG=info cargo run --example dummy_server --quiet</code>。然后在另一个命令行窗口，运行：<code>RUST_LOG=info cargo run --example client --quiet</code>。</p><p>此时，服务器和客户端都收到了彼此的请求和响应，协议层看上去运作良好。一旦验证通过，就你可以进入下一步，因为协议层的其它代码都只是工作量而已，在之后需要的时候可以慢慢实现。</p><h3>实现并验证 Storage trait</h3><p>接下来构建 Storage trait。</p><p>我们上一讲谈到了如何使用嵌套的支持并发的 im-memory HashMap 来实现 storage trait。由于 Arc&lt;RwLock&lt;HashMap&lt;K, V&gt;&gt;&gt; 这样的支持并发的 HashMap 是一个刚需，Rust 生态有很多相关的 crate 支持，这里我们可以使用 dashmap 创建一个 MemTable 结构，来实现 Storage trait。</p><p>先创建 src/storage 目录，然后创建 src/storage/mod.rs，把刚才讨论的 trait 代码放进去后，在 src/lib.rs 中引入 “mod storage”。此时会发现一个错误：并未定义 KvError。</p><p>所以来定义 KvError。<a href=\"https://time.geekbang.org/column/article/424002\">第 18 讲</a>讨论错误处理时简单演示了，如何使用 <a href=\"https://github.com/dtolnay/thiserror\">thiserror</a> 的派生宏来定义错误类型，今天就用它来定义 KvError。创建 src/error.rs，然后填入：</p><pre><code class=\"language-rust\">use crate::Value;\nuse thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum KvError {\n    #[error(\"Not found for table: {0}, key: {1}\")]\n    NotFound(String, String),\n\n    #[error(\"Cannot parse command: `{0}`\")]\n    InvalidCommand(String),\n    #[error(\"Cannot convert value {:0} to {1}\")]\n    ConvertError(Value, &amp;'static str),\n    #[error(\"Cannot process command {0} with table: {1}, key: {2}. Error: {}\")]\n    StorageError(&amp;'static str, String, String, String),\n\n    #[error(\"Failed to encode protobuf message\")]\n    EncodeError(#[from] prost::EncodeError),\n    #[error(\"Failed to decode protobuf message\")]\n    DecodeError(#[from] prost::DecodeError),\n\n    #[error(\"Internal error: {0}\")]\n    Internal(String),\n}\n</code></pre><p>这些 error 的定义其实是在实现过程中逐步添加的，但为了讲解方便，先一次性添加。对于 Storage 的实现，我们只关心 StorageError，其它的 error 定义未来会用到。</p><p>同样，在 src/lib.rs 下引入 mod error，现在 src/lib.rs 是这个样子的：</p><pre><code class=\"language-rust\">mod error;\nmod pb;\nmod storage;\n\npub use error::KvError;\npub use pb::abi::*;\npub use storage::*;\n</code></pre><p>src/storage/mod.rs 是这个样子的：</p><pre><code class=\"language-rust\">use crate::{KvError, Kvpair, Value};\n\n/// 对存储的抽象，我们不关心数据存在哪儿，但需要定义外界如何和存储打交道\npub trait Storage {\n    /// 从一个 HashTable 里获取一个 key 的 value\n    fn get(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;\n    /// 从一个 HashTable 里设置一个 key 的 value，返回旧的 value\n    fn set(&amp;self, table: &amp;str, key: String, value: Value) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;\n    /// 查看 HashTable 中是否有 key\n    fn contains(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;bool, KvError&gt;;\n    /// 从 HashTable 中删除一个 key\n    fn del(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;\n    /// 遍历 HashTable，返回所有 kv pair（这个接口不好）\n    fn get_all(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;Kvpair&gt;, KvError&gt;;\n    /// 遍历 HashTable，返回 kv pair 的 Iterator\n    fn get_iter(&amp;self, table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt;;\n}\n</code></pre><p>代码目前没有编译错误，可以在这个文件末尾添加测试代码，尝试使用这些接口了，当然，我们还没有构建 MemTable，但通过 Storage trait 已经大概知道 MemTable 怎么用，所以可以先写段测试体验一下：</p><pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn memtable_basic_interface_should_work() {\n        let store = MemTable::new();\n        test_basi_interface(store);\n    }\n\n    #[test]\n    fn memtable_get_all_should_work() {\n        let store = MemTable::new();\n        test_get_all(store);\n    }\n\n    fn test_basi_interface(store: impl Storage) {\n        // 第一次 set 会创建 table，插入 key 并返回 None（之前没值）\n        let v = store.set(\"t1\", \"hello\".into(), \"world\".into());\n        assert!(v.unwrap().is_none());\n        // 再次 set 同样的 key 会更新，并返回之前的值\n        let v1 = store.set(\"t1\", \"hello\".into(), \"world1\".into());\n        assert_eq!(v1, Ok(Some(\"world\".into())));\n\n        // get 存在的 key 会得到最新的值\n        let v = store.get(\"t1\", \"hello\");\n        assert_eq!(v, Ok(Some(\"world1\".into())));\n\n        // get 不存在的 key 或者 table 会得到 None\n        assert_eq!(Ok(None), store.get(\"t1\", \"hello1\"));\n        assert!(store.get(\"t2\", \"hello1\").unwrap().is_none());\n\n        // contains 纯在的 key 返回 true，否则 false\n        assert_eq!(store.contains(\"t1\", \"hello\"), Ok(true));\n        assert_eq!(store.contains(\"t1\", \"hello1\"), Ok(false));\n        assert_eq!(store.contains(\"t2\", \"hello\"), Ok(false));\n\n        // del 存在的 key 返回之前的值\n        let v = store.del(\"t1\", \"hello\");\n        assert_eq!(v, Ok(Some(\"world1\".into())));\n\n        // del 不存在的 key 或 table 返回 None\n        assert_eq!(Ok(None), store.del(\"t1\", \"hello1\"));\n        assert_eq!(Ok(None), store.del(\"t2\", \"hello\"));\n    }\n\n    fn test_get_all(store: impl Storage) {\n        store.set(\"t2\", \"k1\".into(), \"v1\".into()).unwrap();\n        store.set(\"t2\", \"k2\".into(), \"v2\".into()).unwrap();\n        let mut data = store.get_all(\"t2\").unwrap();\n        data.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        assert_eq!(\n            data,\n            vec![\n                Kvpair::new(\"k1\", \"v1\".into()),\n                Kvpair::new(\"k2\", \"v2\".into())\n            ]\n        )\n    }\n\n\t\tfn test_get_iter(store: impl Storage) {\n        store.set(\"t2\", \"k1\".into(), \"v1\".into()).unwrap();\n        store.set(\"t2\", \"k2\".into(), \"v2\".into()).unwrap();\n        let mut data: Vec&lt;_&gt; = store.get_iter(\"t2\").unwrap().collect();\n        data.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        assert_eq!(\n            data,\n            vec![\n                Kvpair::new(\"k1\", \"v1\".into()),\n                Kvpair::new(\"k2\", \"v2\".into())\n            ]\n        )\n    }\n}\n</code></pre><p>这种在写实现之前写单元测试，是标准的 TDD（Test-Driven Development）方式。<br>\n我个人不是 TDD 的狂热粉丝，<strong>但会在构建完 trait 后，为这个 trait 撰写测试代码，因为写测试代码是个很好的验证接口是否好用的时机</strong>。毕竟我们不希望实现 trait 之后，才发现 trait 的定义有瑕疵，需要修改，这个时候改动的代价就比较大了。</p><p>所以，当 trait 推敲完毕，就可以开始写使用 trait 的测试代码了。在使用过程中仔细感受，如果写测试用例时用得不舒服，或者为了使用它需要做很多繁琐的操作，那么可以重新审视 trait 的设计。</p><p>你如果仔细看单元测试的代码，就会发现我始终秉持<strong>测试 trait 接口的思想</strong>。尽管在测试中需要一个实际的数据结构进行 trait 方法的测试，但核心的测试代码都用的泛型函数，让这些代码只跟 trait 相关。</p><p>这样，一来可以避免某个具体 trait 实现的干扰，二来在之后想加入更多 trait 实现时，可以共享测试代码。比如未来想支持 DiskTable，那么只消加几个测试例，调用已有的泛型函数即可。</p><p>好，搞定测试，确认trait设计没有什么问题之后，我们来写具体实现。可以创建 src/storage/memory.rs 来构建 MemTable：</p><pre><code class=\"language-rust\">use crate::{KvError, Kvpair, Storage, Value};\nuse dashmap::{mapref::one::Ref, DashMap};\n\n/// 使用 DashMap 构建的 MemTable，实现了 Storage trait\n#[derive(Clone, Debug, Default)]\npub struct MemTable {\n    tables: DashMap&lt;String, DashMap&lt;String, Value&gt;&gt;,\n}\n\nimpl MemTable {\n    /// 创建一个缺省的 MemTable\n    pub fn new() -&gt; Self {\n        Self::default()\n    }\n\n    /// 如果名为 name 的 hash table 不存在，则创建，否则返回\n    fn get_or_create_table(&amp;self, name: &amp;str) -&gt; Ref&lt;String, DashMap&lt;String, Value&gt;&gt; {\n        match self.tables.get(name) {\n            Some(table) =&gt; table,\n            None =&gt; {\n                let entry = self.tables.entry(name.into()).or_default();\n                entry.downgrade()\n            }\n        }\n    }\n}\n\nimpl Storage for MemTable {\n    fn get(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {\n        let table = self.get_or_create_table(table);\n        Ok(table.get(key).map(|v| v.value().clone()))\n    }\n\n    fn set(&amp;self, table: &amp;str, key: String, value: Value) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {\n        let table = self.get_or_create_table(table);\n        Ok(table.insert(key, value))\n    }\n\n    fn contains(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;bool, KvError&gt; {\n        let table = self.get_or_create_table(table);\n        Ok(table.contains_key(key))\n    }\n\n    fn del(&amp;self, table: &amp;str, key: &amp;str) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt; {\n        let table = self.get_or_create_table(table);\n        Ok(table.remove(key).map(|(_k, v)| v))\n    }\n\n    fn get_all(&amp;self, table: &amp;str) -&gt; Result&lt;Vec&lt;Kvpair&gt;, KvError&gt; {\n        let table = self.get_or_create_table(table);\n        Ok(table\n            .iter()\n            .map(|v| Kvpair::new(v.key(), v.value().clone()))\n            .collect())\n    }\n\n\t\tfn get_iter(&amp;self, _table: &amp;str) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = Kvpair&gt;&gt;, KvError&gt; {\n        todo!()\n    }\n}\n</code></pre><p>除了 get_iter() 外，这个实现代码非常简单，相信你看一下 dashmap 的文档，也能很快写出来。get_iter() 写起来稍微有些难度，我们先放下不表，会在下一篇 KV server 讲。如果你对此感兴趣，想挑战一下，欢迎尝试。</p><p>实现完成之后，我们可以测试它是否符合预期。注意现在 src/storage/memory.rs 还没有被添加，所以 cargo 并不会编译它。要在 src/storage/mod.rs 开头添加代码：</p><pre><code class=\"language-rust\">mod memory;\npub use memory::MemTable;\n</code></pre><p>这样代码就可以编译通过了。因为还没有实现 get_iter 方法，所以这个测试需要被注释掉：</p><pre><code class=\"language-rust\">// #[test]\n// fn memtable_iter_should_work() {\n//     let store = MemTable::new();\n//     test_get_iter(store);\n// }\n</code></pre><p>如果你运行 <code>cargo test</code> ，可以看到测试都通过了：</p><pre><code class=\"language-bash\">&gt; cargo test\n   Compiling kv v0.1.0 (/Users/tchen/projects/mycode/rust/geek-time-rust-resources/21/kv)\n    Finished test [unoptimized + debuginfo] target(s) in 1.95s\n     Running unittests (/Users/tchen/.target/debug/deps/kv-8d746b0f387a5271)\n\nrunning 2 tests\ntest storage::tests::memtable_basic_interface_should_work ... ok\ntest storage::tests::memtable_get_all_should_work ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests kv\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n</code></pre><h3>实现并验证 CommandService trait</h3><p>Storage trait 我们就算基本验证通过了，现在再来验证 CommandService。</p><p>我们创建 src/service 目录，以及 src/service/mod.rs 和 src/service/command_service.rs 文件，并在 src/service/mod.rs 写入：</p><pre><code class=\"language-rust\">use crate::*;\n\nmod command_service;\n\n/// 对 Command 的处理的抽象\npub trait CommandService {\n    /// 处理 Command，返回 Response\n    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse;\n}\n</code></pre><p>不要忘记在 src/lib.rs 中加入 service：</p><pre><code class=\"language-rust\">mod error;\nmod pb;\nmod service;\nmod storage;\n\npub use error::KvError;\npub use pb::abi::*;\npub use service::*;\npub use storage::*;\n</code></pre><p>然后，在 src/service/command_service.rs 中，我们可以先写一些测试。为了简单起见，就列 HSET、HGET、HGETALL 三个命令：</p><pre><code class=\"language-rust\">use crate::*;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::command_request::RequestData;\n\n    #[test]\n    fn hset_should_work() {\n        let store = MemTable::new();\n        let cmd = CommandRequest::new_hset(\"t1\", \"hello\", \"world\".into());\n        let res = dispatch(cmd.clone(), &amp;store);\n        assert_res_ok(res, &amp;[Value::default()], &amp;[]);\n\n        let res = dispatch(cmd, &amp;store);\n        assert_res_ok(res, &amp;[\"world\".into()], &amp;[]);\n    }\n\n    #[test]\n    fn hget_should_work() {\n        let store = MemTable::new();\n        let cmd = CommandRequest::new_hset(\"score\", \"u1\", 10.into());\n        dispatch(cmd, &amp;store);\n        let cmd = CommandRequest::new_hget(\"score\", \"u1\");\n        let res = dispatch(cmd, &amp;store);\n        assert_res_ok(res, &amp;[10.into()], &amp;[]);\n    }\n\n    #[test]\n    fn hget_with_non_exist_key_should_return_404() {\n        let store = MemTable::new();\n        let cmd = CommandRequest::new_hget(\"score\", \"u1\");\n        let res = dispatch(cmd, &amp;store);\n        assert_res_error(res, 404, \"Not found\");\n    }\n\n    #[test]\n    fn hgetall_should_work() {\n        let store = MemTable::new();\n        let cmds = vec![\n            CommandRequest::new_hset(\"score\", \"u1\", 10.into()),\n            CommandRequest::new_hset(\"score\", \"u2\", 8.into()),\n            CommandRequest::new_hset(\"score\", \"u3\", 11.into()),\n            CommandRequest::new_hset(\"score\", \"u1\", 6.into()),\n        ];\n        for cmd in cmds {\n            dispatch(cmd, &amp;store);\n        }\n\n        let cmd = CommandRequest::new_hgetall(\"score\");\n        let res = dispatch(cmd, &amp;store);\n        let pairs = &amp;[\n            Kvpair::new(\"u1\", 6.into()),\n            Kvpair::new(\"u2\", 8.into()),\n            Kvpair::new(\"u3\", 11.into()),\n        ];\n        assert_res_ok(res, &amp;[], pairs);\n    }\n\n    // 从 Request 中得到 Response，目前处理 HGET/HGETALL/HSET\n    fn dispatch(cmd: CommandRequest, store: &amp;impl Storage) -&gt; CommandResponse {\n        match cmd.request_data.unwrap() {\n            RequestData::Hget(v) =&gt; v.execute(store),\n            RequestData::Hgetall(v) =&gt; v.execute(store),\n            RequestData::Hset(v) =&gt; v.execute(store),\n            _ =&gt; todo!(),\n        }\n    }\n\n    // 测试成功返回的结果\n    fn assert_res_ok(mut res: CommandResponse, values: &amp;[Value], pairs: &amp;[Kvpair]) {\n        res.pairs.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        assert_eq!(res.status, 200);\n        assert_eq!(res.message, \"\");\n        assert_eq!(res.values, values);\n        assert_eq!(res.pairs, pairs);\n    }\n\n    // 测试失败返回的结果\n    fn assert_res_error(res: CommandResponse, code: u32, msg: &amp;str) {\n        assert_eq!(res.status, code);\n        assert!(res.message.contains(msg));\n        assert_eq!(res.values, &amp;[]);\n        assert_eq!(res.pairs, &amp;[]);\n    }\n}\n</code></pre><p>这些测试的作用就是验证产品需求，比如：</p><ul>\n<li>HSET 成功返回上一次的值（这和 Redis 略有不同，Redis 返回表示多少 key 受影响的一个整数）</li>\n<li>HGET 返回 Value</li>\n<li>HGETALL 返回一组无序的 Kvpair</li>\n</ul><p>目前这些测试是无法编译通过的，因为里面使用了一些未定义的方法，比如 10.into()：想把整数 10 转换成一个 Value、CommandRequest::new_hgetall(“score”)：想生成一个 HGETALL 命令。</p><p>为什么要这么写？因为如果是 CommandService 接口的使用者，自然希望使用这个接口的时候，调用的整体感觉非常简单明了。</p><p>如果接口期待一个 Value，但在上下文中拿到的是 10、“hello” 这样的值，那我们作为设计者就要考虑为 Value 实现 From&lt;T&gt;，这样调用的时候最方便。同样的，对于生成 CommandRequest 这个数据结构，也可以添加一些辅助函数，来让调用更清晰。</p><p>到现在为止我们写了两轮测试了，相信你对测试代码的作用有大概理解。我们来总结一下：</p><ol>\n<li>验证并帮助接口迭代</li>\n<li>验证产品需求</li>\n<li>通过使用核心逻辑，帮助我们更好地思考外围逻辑并反推其实现</li>\n</ol><p>前两点是最基本的，也是很多人对TDD的理解，其实还有更重要的也就是第三点。除了前面的辅助函数外，我们在测试代码中还看到了 dispatch 函数，它目前用来辅助测试。<strong>但紧接着你会发现，这样的辅助函数，可以合并到核心代码中。这才是“测试驱动开发”的实质</strong>。</p><p>好，根据测试，我们需要在 src/pb/mod.rs 中添加相关的外围逻辑，首先是 CommandRequest 的一些方法，之前写了 new_hset，现在再加入 new_hget 和 new_hgetall：</p><pre><code class=\"language-rust\">impl CommandRequest {\n    /// 创建 HGET 命令\n    pub fn new_hget(table: impl Into&lt;String&gt;, key: impl Into&lt;String&gt;) -&gt; Self {\n        Self {\n            request_data: Some(RequestData::Hget(Hget {\n                table: table.into(),\n                key: key.into(),\n            })),\n        }\n    }\n\n    /// 创建 HGETALL 命令\n    pub fn new_hgetall(table: impl Into&lt;String&gt;) -&gt; Self {\n        Self {\n            request_data: Some(RequestData::Hgetall(Hgetall {\n                table: table.into(),\n            })),\n        }\n    }\n\n    /// 创建 HSET 命令\n    pub fn new_hset(table: impl Into&lt;String&gt;, key: impl Into&lt;String&gt;, value: Value) -&gt; Self {\n        Self {\n            request_data: Some(RequestData::Hset(Hset {\n                table: table.into(),\n                pair: Some(Kvpair::new(key, value)),\n            })),\n        }\n    }\n}\n</code></pre><p>然后写对 Value 的 From&lt;i64&gt; 的实现：</p><pre><code class=\"language-rust\">/// 从 i64转换成 Value\nimpl From&lt;i64&gt; for Value {\n    fn from(i: i64) -&gt; Self {\n        Self {\n            value: Some(value::Value::Integer(i)),\n        }\n    }\n}\n</code></pre><p>测试代码目前就可以编译通过了，然而测试显然会失败，因为还没有做具体的实现。我们在 src/service/command_service.rs 下添加 trait 的实现代码：</p><pre><code class=\"language-rust\">impl CommandService for Hget {\n    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {\n        match store.get(&amp;self.table, &amp;self.key) {\n            Ok(Some(v)) =&gt; v.into(),\n            Ok(None) =&gt; KvError::NotFound(self.table, self.key).into(),\n            Err(e) =&gt; e.into(),\n        }\n    }\n}\n\nimpl CommandService for Hgetall {\n    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {\n        match store.get_all(&amp;self.table) {\n            Ok(v) =&gt; v.into(),\n            Err(e) =&gt; e.into(),\n        }\n    }\n}\n\nimpl CommandService for Hset {\n    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {\n        match self.pair {\n            Some(v) =&gt; match store.set(&amp;self.table, v.key, v.value.unwrap_or_default()) {\n                Ok(Some(v)) =&gt; v.into(),\n                Ok(None) =&gt; Value::default().into(),\n                Err(e) =&gt; e.into(),\n            },\n            None =&gt; Value::default().into(),\n        }\n    }\n}\n</code></pre><p>这自然会引发更多的编译错误，因为我们很多地方都是用了 into() 方法，却没有实现相应的转换，比如，Value 到 CommandResponse 的转换、KvError 到 CommandResponse 的转换、Vec&lt;Kvpair&gt; 到 CommandResponse 的转换等等。</p><p>所以在 src/pb/mod.rs 里继续补上相应的外围逻辑：</p><pre><code class=\"language-rust\">/// 从 Value 转换成 CommandResponse\nimpl From&lt;Value&gt; for CommandResponse {\n    fn from(v: Value) -&gt; Self {\n        Self {\n            status: StatusCode::OK.as_u16() as _,\n            values: vec![v],\n            ..Default::default()\n        }\n    }\n}\n\n/// 从 Vec&lt;Kvpair&gt; 转换成 CommandResponse\nimpl From&lt;Vec&lt;Kvpair&gt;&gt; for CommandResponse {\n    fn from(v: Vec&lt;Kvpair&gt;) -&gt; Self {\n        Self {\n            status: StatusCode::OK.as_u16() as _,\n            pairs: v,\n            ..Default::default()\n        }\n    }\n}\n\n/// 从 KvError 转换成 CommandResponse\nimpl From&lt;KvError&gt; for CommandResponse {\n    fn from(e: KvError) -&gt; Self {\n        let mut result = Self {\n            status: StatusCode::INTERNAL_SERVER_ERROR.as_u16() as _,\n            message: e.to_string(),\n            values: vec![],\n            pairs: vec![],\n        };\n\n        match e {\n            KvError::NotFound(_, _) =&gt; result.status = StatusCode::NOT_FOUND.as_u16() as _,\n            KvError::InvalidCommand(_) =&gt; result.status = StatusCode::BAD_REQUEST.as_u16() as _,\n            _ =&gt; {}\n        }\n\n        result\n    }\n}\n</code></pre><p>从前面写接口到这里具体实现，不知道你是否感受到了这样一种模式：在 Rust 下，<strong>但凡出现两个数据结构 v1 到 v2 的转换，你都可以先以 v1.into() 来表示这个逻辑，继续往下写代码，之后再去补 From&lt;T&gt; 的实现</strong>。如果 v1 和 v2 都不是你定义的数据结构，那么你需要把其中之一用 struct 包装一下，来绕过（<a href=\"https://time.geekbang.org/column/article/421324\">第 </a><a href=\"https://time.geekbang.org/column/article/421324\">14 讲</a>）之前提到的孤儿规则。<br>\n你学完这节课可以再去回顾一下<a href=\"https://time.geekbang.org/column/article/414478\">第 6 讲</a>，仔细思考一下当时说的“绝大多数处理逻辑都是把数据从一个接口转换成另一个接口”。</p><p>现在代码应该可以编译通过并测试通过了，你可以 <code>cargo test</code> 测试一下。</p><h3>最后的拼图：Service 结构的实现</h3><p>好，所有的接口，包括客户端/服务器的协议接口、Storage trait 和 CommandService trait 都验证好了，接下来就是考虑如何用一个数据结构把所有这些东西串联起来。</p><p>依旧从使用者的角度来看如何调用它。为此，我们在 src/service/mod.rs 里添加如下的测试代码：</p><pre><code class=\"language-rust\">#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::{MemTable, Value};\n\n\t\t#[test]\n    fn service_should_works() {\n        // 我们需要一个 service 结构至少包含 Storage\n        let service = Service::new(MemTable::default());\n\n        // service 可以运行在多线程环境下，它的 clone 应该是轻量级的\n        let cloned = service.clone();\n\n        // 创建一个线程，在 table t1 中写入 k1, v1\n        let handle = thread::spawn(move || {\n            let res = cloned.execute(CommandRequest::new_hset(\"t1\", \"k1\", \"v1\".into()));\n            assert_res_ok(res, &amp;[Value::default()], &amp;[]);\n        });\n        handle.join().unwrap();\n\n        // 在当前线程下读取 table t1 的 k1，应该返回 v1\n        let res = service.execute(CommandRequest::new_hget(\"t1\", \"k1\"));\n        assert_res_ok(res, &amp;[\"v1\".into()], &amp;[]);\n    }\n}\n\n#[cfg(test)]\nuse crate::{Kvpair, Value};\n\n// 测试成功返回的结果\n#[cfg(test)]\npub fn assert_res_ok(mut res: CommandResponse, values: &amp;[Value], pairs: &amp;[Kvpair]) {\n    res.pairs.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    assert_eq!(res.status, 200);\n    assert_eq!(res.message, \"\");\n    assert_eq!(res.values, values);\n    assert_eq!(res.pairs, pairs);\n}\n\n// 测试失败返回的结果\n#[cfg(test)]\npub fn assert_res_error(res: CommandResponse, code: u32, msg: &amp;str) {\n    assert_eq!(res.status, code);\n    assert!(res.message.contains(msg));\n    assert_eq!(res.values, &amp;[]);\n    assert_eq!(res.pairs, &amp;[]);\n}\n</code></pre><p>注意，这里的 assert_res_ok() 和 assert_res_error() 是从 src/service/command_service.rs 中挪过来的。<strong>在开发的过程中，不光产品代码需要不断重构，测试代码也需要重构来贯彻 DRY 思想</strong>。</p><p>我见过很多生产环境的代码，产品功能部分还说得过去，但测试代码像是个粪坑，经年累月地 copy/paste 使其臭气熏天，每个开发者在添加新功能的时候，都掩着鼻子往里扔一坨走人，使得维护难度越来越高，每次需求变动，都涉及一大坨测试代码的变动，这样非常不好。</p><p>测试代码的质量也要和产品代码的质量同等要求。好的开发者写的测试代码的可读性也是非常强的。你可以对比上面写的三段测试代码多多感受。</p><p>在撰写测试的时候，我们要特别注意：<strong>测试代码要围绕着系统稳定的部分，也就是接口，来测试，而尽可能少地测试实现</strong>。这是我对这么多年工作中血淋淋的教训的深刻总结。</p><p>因为产品代码和测试代码，两者总需要一个是相对稳定的，既然产品代码会不断地根据需求变动，测试代码就必然需要稳定一些。</p><p>那什么样的测试代码是稳定的？测试接口的代码是稳定的。只要接口不变，无论具体实现如何变化，哪怕今天引入一个新的算法，明天重写实现，测试代码依旧能够凛然不动，做好产品质量的看门狗。</p><p>好，我们回来写代码。在这段测试中，已经敲定了 Service 这个数据结构的使用蓝图，它可以跨线程，可以调用 execute 来执行某个 CommandRequest 命令，返回 CommandResponse。</p><p>根据这些想法，在 src/service/mod.rs 里添加 Service 的声明和实现：</p><pre><code class=\"language-rust\">/// Service 数据结构\npub struct Service&lt;Store = MemTable&gt; {\n    inner: Arc&lt;ServiceInner&lt;Store&gt;&gt;,\n}\n\nimpl&lt;Store&gt; Clone for Service&lt;Store&gt; {\n    fn clone(&amp;self) -&gt; Self {\n        Self {\n\t\t\tinner: Arc::clone(&amp;self.inner),\n        }\n    }\n}\n\n/// Service 内部数据结构\npub struct ServiceInner&lt;Store&gt; {\n    store: Store,\n}\n\nimpl&lt;Store: Storage&gt; Service&lt;Store&gt; {\n    pub fn new(store: Store) -&gt; Self {\n        Self {\n            inner: Arc::new(ServiceInner { store }),\n        }\n    }\n\n    pub fn execute(&amp;self, cmd: CommandRequest) -&gt; CommandResponse {\n        debug!(\"Got request: {:?}\", cmd);\n        // TODO: 发送 on_received 事件\n        let res = dispatch(cmd, &amp;self.inner.store);\n        debug!(\"Executed response: {:?}\", res);\n        // TODO: 发送 on_executed 事件\n\n        res\n    }\n}\n\n// 从 Request 中得到 Response，目前处理 HGET/HGETALL/HSET\npub fn dispatch(cmd: CommandRequest, store: &amp;impl Storage) -&gt; CommandResponse {\n    match cmd.request_data {\n        Some(RequestData::Hget(param)) =&gt; param.execute(store),\n        Some(RequestData::Hgetall(param)) =&gt; param.execute(store),\n        Some(RequestData::Hset(param)) =&gt; param.execute(store),\n        None =&gt; KvError::InvalidCommand(\"Request has no data\".into()).into(),\n        _ =&gt; KvError::Internal(\"Not implemented\".into()).into(),\n    }\n}\n</code></pre><p>这段代码有几个地方值得注意：</p><ol>\n<li>首先 Service 结构内部有一个 ServiceInner 存放实际的数据结构，Service 只是用 Arc 包裹了 ServiceInner。这也是 Rust 的一个惯例，把需要在多线程下 clone 的主体和其内部结构分开，这样代码逻辑更加清晰。</li>\n<li>execute() 方法目前就是调用了 dispatch，但它未来潜在可以做一些事件分发。这样处理体现了 SRP（Single Responsibility Principle）原则。</li>\n<li>dispatch 其实就是把测试代码的 dispatch 逻辑移动过来改动了一下。</li>\n</ol><p>再一次，我们重构了测试代码，把它的辅助函数变成了产品代码的一部分。现在，你可以运行 <code>cargo test</code> 测试一下，如果代码无法编译，可能是缺一些 use 代码，比如：</p><pre><code class=\"language-rust\">use crate::{\n    command_request::RequestData, CommandRequest, CommandResponse, KvError, MemTable, Storage,\n};\nuse std::sync::Arc;\nuse tracing::debug;\n</code></pre><h3>新的 server</h3><p>现在处理逻辑已经都完成了，可以写个新的 example 测试服务器代码。</p><p>把之前的 examples/dummy_server.rs 复制一份，成为 examples/server.rs，然后引入 Service，主要的改动就三句：</p><pre><code class=\"language-rust\">// main 函数开头，初始化 service\nlet service: Service = Service::new(MemTable::new());\n// tokio::spawn 之前，复制一份 service\nlet svc = service.clone();\n// while loop 中，使用 svc 来执行 cmd\nlet res = svc.execute(cmd);\n</code></pre><p>你可以试着自己修改。完整的代码如下：</p><pre><code class=\"language-rust\">use anyhow::Result;\nuse async_prost::AsyncProstStream;\nuse futures::prelude::*;\nuse kv::{CommandRequest, CommandResponse, MemTable, Service};\nuse tokio::net::TcpListener;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    tracing_subscriber::fmt::init();\n    let service: Service = Service::new(MemTable::new());\n    let addr = \"127.0.0.1:9527\";\n    let listener = TcpListener::bind(addr).await?;\n    info!(\"Start listening on {}\", addr);\n    loop {\n        let (stream, addr) = listener.accept().await?;\n        info!(\"Client {:?} connected\", addr);\n        let svc = service.clone();\n        tokio::spawn(async move {\n            let mut stream =\n                AsyncProstStream::&lt;_, CommandRequest, CommandResponse, _&gt;::from(stream).for_async();\n            while let Some(Ok(cmd)) = stream.next().await {\n                let res = svc.execute(cmd);\n                stream.send(res).await.unwrap();\n            }\n            info!(\"Client {:?} disconnected\", addr);\n        });\n    }\n}\n</code></pre><p>完成之后，打开一个命令行窗口，运行：<code>RUST_LOG=info cargo run --example server --quiet</code>，然后在另一个命令行窗口，运行：<code>RUST_LOG=info cargo run --example client --quiet</code>。此时，服务器和客户端都收到了彼此的请求和响应，并且处理正常。</p><p>我们的 KV server 第一版的基本功能就完工了！当然，目前还只处理了 3 个命令，剩下 6 个需要你自己完成。</p><h2>小结</h2><p>KV server 并不是一个很难的项目，但想要把它写好，并不简单。如果你跟着讲解一步步走下来，可以感受到一个有潜在生产环境质量的 Rust 项目应该如何开发。在这上下两讲内容中，有两点我们一定要认真领会。</p><p>第一点，你要对需求有一个清晰的把握，找出其中不稳定的部分（variant）和比较稳定的部分（invariant）。在 KV server 中，不稳定的部分是，对各种新的命令的支持，以及对不同的 storage 的支持。<strong>所以需要构建接口来消弭不稳定的因素，让不稳定的部分可以用一种稳定的方式来管理</strong>。</p><p>第二点，代码和测试可以围绕着接口螺旋前进，使用 TDD 可以帮助我们进行这种螺旋式的迭代。<strong>在一个设计良好的系统中：接口是稳定的，测试接口的代码是稳定的，实现可以是不稳定的</strong>。在迭代开发的过程中，我们要不断地重构，让测试代码和产品代码都往最优的方向发展。</p><p>纵观我们写的 KV server，包括测试在内，你很难发现有函数或者方法超过 50 行，代码可读性非常强，几乎不需要注释，就可以理解。另外因为都是用接口做的交互，未来维护和添加新的功能，也基本上满足 OCP 原则，除了 dispatch 函数需要很小的修改外，其它新的代码都是在实现一些接口而已。</p><p>相信你能初步感受到在 Rust 下撰写代码的最佳实践。如果你之前用其他语言，已经采用了类似的最佳实践，那么可以感受一下同样的实践在 Rust 下使用的那种优雅；如果你之前由于种种原因，写的是类似之前意大利面条似的代码，那在开发 Rust 程序时，你可以试着接纳这种更优雅的开发方式。</p><p>毕竟，现在我们手中有了更先进的武器，就可以用更先进的打法。</p><h2>思考题</h2><ol>\n<li>为剩下 6 个命令 HMGET、HMSET、HDEL、HMDEL、HEXIST、HMEXIST 构建测试，并实现它们。在测试和实现过程中，你也许需要添加更多的 From&lt;T&gt; 的实现。</li>\n<li>如果有余力，可以试着实现 MemTable 的 get_iter() 方法（后续的 KV Store 实现会讲）。</li>\n</ol><h3>延伸思考</h3><p>虽然我们的 KV server 使用了 concurrent hashmap 来处理并发，但这并不一定是最好的选择。</p><p>我们也可以创建一个线程池，每个线程有自己的 HashMap。当 HGET/HSET 等命令来临时，可以对 key 做个哈希，然后分派到 “拥有” 那个 key 的线程，这样，可以避免在处理的时候加锁，提高系统的吞吐。你可以想想如果用这种方式处理，该怎么做。</p><p>恭喜你完成了学习的第22次打卡。如果你觉得有收获，也欢迎你分享给身边的朋友，邀他一起讨论。我们下一讲期中测试见～</p>","neighbors":{"left":{"article_title":"21｜阶段实操（1）：构建一个简单的KV server-基本流程","id":425001},"right":{"article_title":"加餐｜期中测试：来写一个简单的grep命令行","id":425013}},"comments":[{"had_liked":false,"id":315538,"user_name":"newzai","can_delete":false,"product_type":"c1","uid":1102367,"ip_address":"","ucode":"D5E34D427D65FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/1f/2ef2514b.jpg","comment_is_top":false,"comment_ctime":1633916032,"is_pvip":false,"replies":[{"id":"115294","content":"examples &#47; test 里用的库是 dev-dependencies + dependencies。build.rs 里用到的库是 build-dependencies + dependencies。正常代码（库&#47;二进制）用的是 dependencies","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635133081,"ip_address":"","comment_id":315538,"utype":1}],"discussion_count":3,"race_medal":1,"score":"48878556288","product_id":100085301,"comment_content":"dev-dependencies 与 dependencies的第三方crate是如何划分的?tokio 为啥不放到 dependencies? 放到 dependencies 与 dev-dependencies 有啥区别？某些如何决策一个 crate放到哪个 dependencies？","like_count":11,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528065,"discussion_content":"examples / test 里用的库是 dev-dependencies + dependencies。build.rs 里用到的库是 build-dependencies + dependencies。正常代码（库/二进制）用的是 dependencies","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635133081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1401568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","nickname":"记事本","note":"","ucode":"FA942636EE0CC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402630,"discussion_content":"dev-dependencies  ：cargo build 时候用到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633923416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1200704,"avatar":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","nickname":"pedro","note":"","ucode":"F40C839DDFD599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":402587,"discussion_content":"dev=develop，开发环境使用，生成环境不使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633919561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327335,"user_name":"施泰博","can_delete":false,"product_type":"c1","uid":2718966,"ip_address":"","ucode":"E88E4E737398EF","user_header":"https://static001.geekbang.org/account/avatar/00/29/7c/f6/028f80a8.jpg","comment_is_top":false,"comment_ctime":1640070385,"is_pvip":false,"replies":[{"id":"120815","content":"👍 很好的 tips","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1642310938,"ip_address":"","comment_id":327335,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27409874161","product_id":100085301,"comment_content":"用powershell的。RUST _LOG=info。改成$env:RUST_LOG=&quot;info&quot;;然后再cargo run","like_count":6,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546458,"discussion_content":"👍 很好的 tips","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642310938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320299,"user_name":"Geek_b52974","can_delete":false,"product_type":"c1","uid":1298252,"ip_address":"","ucode":"59884399646620","user_header":"","comment_is_top":false,"comment_ctime":1636208091,"is_pvip":true,"replies":[{"id":"116352","content":"嗯，没问题，可以：<br><br>fn set(<br>        &amp;self,<br>        table: &amp;str,<br>        key: impl Into&lt;String&gt;,<br>        value: impl Into&lt;Value&gt;,<br>    ) -&gt; Result&lt;Option&lt;Value&gt;, KvError&gt;;","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636526949,"ip_address":"","comment_id":320299,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18816077275","product_id":100085301,"comment_content":"为何不是这样设计<br><br>  fn set(&amp;self, table: &amp;str, key: String, value: impl Into&lt;Value&gt;) <br><br>这样以来就可以让使用者知道他有一个新的type 需要存时应该 implement 这个 trait 也不会让使用时需要一直 写into","like_count":5,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529948,"discussion_content":"嗯，没问题，可以：\n\nfn set(\n        &amp;amp;self,\n        table: &amp;amp;str,\n        key: impl Into&amp;lt;String&amp;gt;,\n        value: impl Into&amp;lt;Value&amp;gt;,\n    ) -&amp;gt; Result&amp;lt;Option&amp;lt;Value&amp;gt;, KvError&amp;gt;;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636526949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317148,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1634695496,"is_pvip":false,"replies":[{"id":"115249","content":"get_all() 会有太多内存占用，所以一般需要提供可遍历的结果时，倾向于使用 iterator","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635123428,"ip_address":"","comment_id":317148,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14519597384","product_id":100085301,"comment_content":"老师，get_all接口为什么不好？","like_count":3,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528682,"discussion_content":"get_all() 会有太多内存占用，所以一般需要提供可遍历的结果时，倾向于使用 iterator","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635123428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317989,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1635088058,"is_pvip":false,"replies":[{"id":"115304","content":"谢谢！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635133708,"ip_address":"","comment_id":317989,"utype":1}],"discussion_count":1,"race_medal":2,"score":"10225022650","product_id":100085301,"comment_content":"必须仔细看老师的教程，不仔细就掉坑里了。说实话老师的文章讲的是真心详细，基本上把所有的坑都讲了。如果实在编译不过，去下载老师的源码，千万记得要坚持下去。","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529058,"discussion_content":"谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635133708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315643,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1633934273,"is_pvip":false,"replies":[{"id":"115293","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635132998,"ip_address":"","comment_id":315643,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10223868865","product_id":100085301,"comment_content":"得益于老师良好的抽象，我抽出了中午的时间，完成了 hdel 和 hexist 两个命令，如下：<br>```<br>running 6 tests<br>test service::command_service::tests::hget_with_non_exist_key_should_return_404 ... ok<br>test service::command_service::tests::hexist_should_work ... ok<br>test service::command_service::tests::hget_should_work ... ok<br>test service::command_service::tests::hdel_should_work ... ok<br>test service::command_service::tests::hset_should_work ... ok<br>test service::command_service::tests::hgetall_should_work ... ok<br>```<br><br>有时间再来慢慢补充，rust 确实是爽的不行。","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528135,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635132998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1401568,"avatar":"https://static001.geekbang.org/account/avatar/00/15/62/e0/d2ff52da.jpg","nickname":"记事本","note":"","ucode":"FA942636EE0CC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405284,"discussion_content":"同学，加个微信交流下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634548794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323720,"user_name":"losuika","can_delete":false,"product_type":"c1","uid":1218666,"ip_address":"","ucode":"19685B1B00A4F3","user_header":"https://static001.geekbang.org/account/avatar/00/12/98/6a/3ddeca6e.jpg","comment_is_top":false,"comment_ctime":1638115944,"is_pvip":false,"replies":[{"id":"118878","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639849887,"ip_address":"","comment_id":323720,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5933083240","product_id":100085301,"comment_content":"感觉 get_iter 加上生命周期的约束好一些，因为现在 GAT 还没稳定，可以这样实现下，<br>fn get_iter&lt;&#39;a&gt;(<br>    &amp;&#39;a self,<br>    table: &amp;str,<br>) -&gt; Result&lt;Box&lt;dyn Iterator&lt;Item = crate::Kvpair&gt; + &#39;a&gt;, crate::KvError&gt; {<br>    let table = self.get_or_create_table(table);<br>    let inner = Iter::new(table);<br>    Ok(Box::new(inner))<br>}<br><br>struct Iter&lt;&#39;a&gt; {<br>    _table: *const Ref&lt;&#39;static, String, DashMap&lt;String, Value&gt;&gt;,<br>    inner: dashmap::iter::Iter&lt;&#39;a, String, Value&gt;,<br>}<br><br>impl&lt;&#39;a&gt; Iter&lt;&#39;a&gt; {<br>    fn new(table: Ref&lt;&#39;a, String, DashMap&lt;String, Value&gt;&gt;) -&gt; Self {<br>        let t = unsafe {std::mem::transmute::&lt;Ref&lt;&#39;a, String, DashMap&lt;String, Value&gt;&gt;, Ref&lt;&#39;static, String, DashMap&lt;String, Value&gt;&gt;&gt;(table)};<br>        let _table = Box::leak(Box::new(t)) as *const Ref&lt;&#39;static, String, DashMap&lt;String, Value&gt;&gt;;<br><br>        let inner = unsafe {(*_table).iter()};<br>        Self {_table, inner}<br>    }<br>}<br><br>impl&lt;&#39;a&gt; Iterator for Iter&lt;&#39;a&gt; {<br>    type Item = crate::Kvpair;<br><br>    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {<br>        let item = self.inner.next();<br>        item.map(|v| crate::Kvpair::new(v.key(), v.value().clone()))<br>    }<br>}<br><br>impl&lt;&#39;a&gt; Drop for Iter&lt;&#39;a&gt; {<br>    fn drop(&amp;mut self) {<br>        unsafe { drop_in_place(self._table as *mut Ref&lt;&#39;a, String, DashMap&lt;String, Value&gt;&gt;) };<br>    }<br>}","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539839,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639849887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320636,"user_name":"周","can_delete":false,"product_type":"c1","uid":1149798,"ip_address":"","ucode":"E4D57FF40B355A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8b/66/2b55a7ac.jpg","comment_is_top":false,"comment_ctime":1636429945,"is_pvip":false,"replies":[{"id":"116302","content":"你需要 async-prost 也升级到 prost 0.9 版本。注意像 prost 这样的库，在不同版本间生成的 protobuf 代码有可能不一样，所以你不能把 kv 中使用 0.9 编译出来的 protobuf，用在 0.8 版本中 encode&#47;decode。就好比你要用前朝的尚方宝剑斩本朝的官一样。<br><br>我把 async-prost 升级了一下（0.3），也把 kv 升级到 prost 0.9，编译可以通过，你可以试试看。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636471387,"ip_address":"","comment_id":320636,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5931397241","product_id":100085301,"comment_content":"我把prost的版本改成0.9（0.8版本的可以正常运行) ，然后再测试examples的时候 client.send的时候有个报错:<br>the method `send` exists for struct `AsyncProstStream&lt;tokio::net::TcpStream, CommandResponse, CommandRequest, AsyncDestination&gt;`, but its trait bounds were not satisfied<br>the following trait bounds were not satisfied:<br>`AsyncProstStream&lt;tokio::net::TcpStream, CommandResponse, CommandRequest, AsyncDestination&gt;: futures::Sink&lt;_&gt;`<br>which is required by `AsyncProstStream&lt;tokio::net::TcpStream, CommandResponse, CommandRequest, AsyncDestination&gt;: SinkExt&lt;_&gt;`rustcE0599<br>stream.rs(24, 1): doesn&#39;t satisfy `_: SinkExt&lt;_&gt;`<br>stream.rs(24, 1): doesn&#39;t satisfy `_: futures::Sink&lt;_&gt;`.<br>我试着用“如何阅读源码”里边的方法，但是还是不太懂这个错误的原因。希望老师能指点下查错的方法","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530073,"discussion_content":"你需要 async-prost 也升级到 prost 0.9 版本。注意像 prost 这样的库，在不同版本间生成的 protobuf 代码有可能不一样，所以你不能把 kv 中使用 0.9 编译出来的 protobuf，用在 0.8 版本中 encode/decode。就好比你要用前朝的尚方宝剑斩本朝的官一样。\n\n我把 async-prost 升级了一下（0.3），也把 kv 升级到 prost 0.9，编译可以通过，你可以试试看。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636471387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318322,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1635240642,"is_pvip":true,"replies":[{"id":"116581","content":"prost 知识 protobuf serialize &#47; deserialize 的工具，并不负责做这样的事情。你说的半包粘包的问题，是被 async_prost 处理的：https:&#47;&#47;github.com&#47;tyrchen&#47;async-prost&#47;blob&#47;master&#47;src&#47;reader.rs#L136。当然，也可以用网络那一堂讲到的 Frame &#47; LengthDelimitedCodec 来姐姐。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1636642968,"ip_address":"","comment_id":318322,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5930207938","product_id":100085301,"comment_content":"tcp的半包粘包等，是被prost处理掉了吗？","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529188,"discussion_content":"prost 知识 protobuf serialize / deserialize 的工具，并不负责做这样的事情。你说的半包粘包的问题，是被 async_prost 处理的：https://github.com/tyrchen/async-prost/blob/master/src/reader.rs#L136。当然，也可以用网络那一堂讲到的 Frame / LengthDelimitedCodec 来姐姐。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636642968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316419,"user_name":"xl000","can_delete":false,"product_type":"c1","uid":1117935,"ip_address":"","ucode":"6FEABE7F7D0DC0","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/ef/030e6d27.jpg","comment_is_top":false,"comment_ctime":1634299283,"is_pvip":false,"replies":[{"id":"115273","content":"嗯，可以用 impl Into&lt;Value&gt;","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635131236,"ip_address":"","comment_id":316419,"utype":1}],"discussion_count":1,"race_medal":5,"score":"5929266579","product_id":100085301,"comment_content":"```Rust<br>impl Kvpair {<br>    &#47;&#47;&#47; 创建一个新的 kv pair<br>    fn new(key: impl Into&lt;String&gt;, value: impl Into&lt;Value&gt;) -&gt; Self {<br>        Self {<br>            key: key.into(),<br>            value: Some(value.into()),<br>        }<br>    }<br>}<br>```<br>老师Value类型的参数为什么不用impl Into&lt;Value&gt;来定义呢，会有什么问题吗","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528379,"discussion_content":"嗯，可以用 impl Into&amp;lt;Value&amp;gt;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635131236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315784,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1634000193,"is_pvip":false,"replies":[{"id":"115288","content":"嗯，是的。github 里是正确的，但文章忘记改了，我让编辑更新。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635132834,"ip_address":"","comment_id":315784,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5928967489","product_id":100085301,"comment_content":"文中代码有一处错误：<br>let cloned = service.clone();<br>&#47;&#47; 创建一个线程，在 table t1 中写入 k1, v1<br>let handle = thread::spawn(move || {<br>      let res = cloned.execute(CommandRequest::new_hset(&quot;t1&quot;, &quot;k1&quot;, &quot;v1&quot;.into()));<br>      assert_res_ok(res, &amp;[Value::default()], &amp;[]);<br>});<br><br>下面的 execute 应该是有 cloned 来执行的，不能由 service 执行，所有权问题。<br>","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528165,"discussion_content":"嗯，是的。github 里是正确的，但文章忘记改了，我让编辑更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635132834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359841,"user_name":"Geek_a6c6ce","can_delete":false,"product_type":"c1","uid":3074996,"ip_address":"广东","ucode":"21DC76D3225403","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/TusRVU51UggZGpicXMgH64Cb8jek0wyTOpagtUHNAj0EPbhbEv0FJpFU2K3glbtOdJXiaQ9o6QoEfv5PiaIu7rwng/132","comment_is_top":false,"comment_ctime":1665972785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665972785","product_id":100085301,"comment_content":"咔哒","like_count":0},{"had_liked":false,"id":357155,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"日本","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1662995255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662995255","product_id":100085301,"comment_content":"做iter的练习被生命周期折磨得快哭了。后面应该着重再讲一讲的","like_count":0},{"had_liked":false,"id":357013,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"天津","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1662858666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662858666","product_id":100085301,"comment_content":"看到ServiceInner和Service的实现代码就勾起了我一直的一个疑问<br>ServiceInner&lt;Store: Storage&gt; 写成这样不可以么？为什么还要在实现Service方法时才确定泛型参数，就像文中这样： impl&lt;Store: Storage&gt; Service&lt;Store&gt;<br>更高一级的抽象有必要么？我感觉在这个软件的可见生命周期里都不太会用有非Storage的Store吧？<br>但我在看rust的一些三方实现以及之前其他支持复杂泛型的语言的代码里，好像都是这种风格。<br>不太理解其意义。","like_count":0},{"had_liked":false,"id":334988,"user_name":"manonloki","can_delete":false,"product_type":"c1","uid":1199431,"ip_address":"","ucode":"BB28C47615C851","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/47/bd232c70.jpg","comment_is_top":false,"comment_ctime":1645241190,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645241190","product_id":100085301,"comment_content":"这里填个坑，prost生成的代码中有两个Value 。<br>一个是结构体 对应的是message Value,<br>另一个是枚举value::Value 对应的是 message Value{ value }。<br>例子里用的是结构体。如果引入了枚举那个，就会报错说没有实现Default。<br>如果强制手工实现也会报其他错误。具体原因学识尚浅不太清楚，但是这坑给新人指出来，免得跟我一样卡了两天……","like_count":0},{"had_liked":false,"id":333102,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1644065804,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1644065804","product_id":100085301,"comment_content":"老师，这个 as _ 是什么意思？","like_count":0,"discussions":[{"author":{"id":2660581,"avatar":"https://static001.geekbang.org/account/avatar/00/28/98/e5/a716040e.jpg","nickname":"...zzZ","note":"","ucode":"953A50D833CA58","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551885,"discussion_content":"as 是类型转换，_ 是省略类型让编译器推导。比如：fn f(_: i64) {}; let i: i32 = 0;f(i as _);","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1645164377,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":323592,"user_name":"Jagger","can_delete":false,"product_type":"c1","uid":1914208,"ip_address":"","ucode":"0BD13223AEE076","user_header":"https://static001.geekbang.org/account/avatar/00/1d/35/60/d3e723a7.jpg","comment_is_top":false,"comment_ctime":1638007868,"is_pvip":true,"replies":[{"id":"118884","content":"你看看你自己的 Value 实现 Default trait 没？可以参考 github repo  下的代码。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639850140,"ip_address":"","comment_id":323592,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1638007868","product_id":100085301,"comment_content":"陈老师，Value::default() 这个函数我没有找到哎？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539845,"discussion_content":"你看看你自己的 Value 实现 Default trait 没？可以参考 github repo  下的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639850140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218666,"avatar":"https://static001.geekbang.org/account/avatar/00/12/98/6a/3ddeca6e.jpg","nickname":"losuika","note":"","ucode":"19685B1B00A4F3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534839,"discussion_content":"Value 里面是 Option ，Option 实现了 Default，所以 Value 也就实现了 Default","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638284446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322923,"user_name":"东子","can_delete":false,"product_type":"c1","uid":1507020,"ip_address":"","ucode":"A8B9FC47AE9285","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/cc/d1923683.jpg","comment_is_top":false,"comment_ctime":1637659045,"is_pvip":false,"replies":[{"id":"118899","content":"你不能之间换 BTreeMap，而是需要类似 Arc&lt;RwLock&lt;BTreeMap&gt;&gt; 的结构，因为你要多线程读写这个数据。Dashmap 内部封装了一个优化的 Arc&lt;RwLock&lt;HashMap&gt;&gt;。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639851626,"ip_address":"","comment_id":322923,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637659045","product_id":100085301,"comment_content":"#[derive(Clone, Debug, Default)]<br>pub struct MemTable {<br>    tables: DashMap&lt;String, BTreeMap&lt;String, String&gt;&gt;,<br>}<br><br>impl MemTable {<br>    &#47;&#47;&#47; 创建一个缺省的 MemTable<br>    pub fn new() -&gt; Self {<br>        Self::default()<br>    }<br><br>    &#47;&#47;&#47; 如果名为 name 的 hash table 不存在，则创建，否则返回<br>    fn get_or_create_table(&amp;self, name: &amp;str) -&gt; Ref&lt;String, BTreeMap&lt;String, String&gt;&gt; {<br>        match self.tables.get(name) {<br>            Some(table) =&gt; table,<br>            None =&gt; {<br>                let entry = self.tables.entry(name.into()).or_default();<br>                entry.downgrade()<br>            }<br>        }<br>    }<br>    fn set(&amp;self, table: &amp;str, key: String, value: String) -&gt; Result&lt;bool&gt; {<br>        let mut table = self.get_or_create_table(table);<br>        table.insert(key, value);<br>        Ok(true)<br>    }<br>}<br><br>tables: DashMap&lt;String, BTreeMap&lt;String, String&gt;&gt;,我把dashmap换成 btreemap 就会报错<br><br>error[E0596]: cannot borrow data in a dereference of `dashmap::mapref::one::Ref&lt;&#39;_, String, BTreeMap&lt;String, String&gt;&gt;` as mutable<br>  --&gt; src&#47;map_demo.rs:71:9<br>   |<br>71 |         table.insert(key, value);<br>   |         ^^^^^ cannot borrow as mutable<br>陈老师 ","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539860,"discussion_content":"你不能之间换 BTreeMap，而是需要类似 Arc&lt;RwLock&lt;BTreeMap&gt;&gt; 的结构，因为你要多线程读写这个数据。Dashmap 内部封装了一个优化的 Arc&lt;RwLock&lt;HashMap&gt;&gt;。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639851626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317827,"user_name":"啦啦啦啦啦啦啦","can_delete":false,"product_type":"c1","uid":1470066,"ip_address":"","ucode":"220DC1DF76454F","user_header":"https://static001.geekbang.org/account/avatar/00/16/6e/72/f8e5b97e.jpg","comment_is_top":false,"comment_ctime":1634982807,"is_pvip":false,"replies":[{"id":"115225","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635121214,"ip_address":"","comment_id":317827,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634982807","product_id":100085301,"comment_content":"实现 Hmget：<br> &#47;&#47;&#47; 从一个 HashTable 里获取 批量 keys 对应的 values<br>    fn get_values(&amp;self, table: &amp;str, keys: &amp;Vec&lt;String&gt;) -&gt; Result&lt;Vec&lt;Option&lt;Value&gt;&gt;, KvError&gt;;<br>&#47;&#47;&#47; 创建 HMGET 命令<br>    pub fn new_hmget(table: impl Into&lt;String&gt;, keys: Vec&lt;impl Into&lt;String&gt; + Copy&gt;)  -&gt; Self {<br><br>        Self {<br>            request_data: Some(RequestData::Hmget(Hmget {<br>                table: table.into(),<br>                keys: keys<br>                    .iter()<br>                    .map(|&amp;s| s.into())<br>                    .collect(),<br>            })),<br>        }<br>    }<br><br>impl CommandService for Hmget {<br>    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {<br>        match store.get_values(&amp;self.table, &amp;self.keys) {<br>            Ok(v) =&gt; v.into(),<br>            Err(e) =&gt; e.into(),<br>        }<br>    }<br>}<br><br>fn get_values(&amp;self, table: &amp;str, keys: &amp;Vec&lt;String&gt;) -&gt; Result&lt;Vec&lt;Option&lt;Value&gt;&gt;, KvError&gt; {<br>    let table = self.get_or_create_table(table);<br>    let mut result: Vec&lt;Option&lt;Value&gt;&gt; = Vec::new();<br>    for key in keys.iter() {<br>      if let Some(val) = table.get(key).map(|v| v.value().clone()) {<br>        result.push(Some(val));<br>      }<br>    }<br>    Ok(result)<br>  }<br>#[test]<br>    fn hmget_should_work() {<br>        let store = MemTable::new();<br>        let cmd = CommandRequest::new_hset(&quot;score&quot;, &quot;u1&quot;, 10.into());<br>        dispatch(cmd, &amp;store);<br>        let cmd = CommandRequest::new_hset(&quot;score&quot;, &quot;12&quot;, 11.into());<br>        dispatch(cmd, &amp;store);<br>        let cmd = CommandRequest::new_hmget(&quot;score&quot;, vec![&quot;u1&quot;, &quot;12&quot;]);<br>        let res = dispatch(cmd, &amp;store);<br>        assert_res_ok(res, &amp;[10.into(), 11.into()], &amp;[]);<br>    }","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528993,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635121214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317222,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1634715599,"is_pvip":false,"replies":[{"id":"115245","content":"嗯，返回一个数组这样的场景，单个错误的处理是比较麻烦，除非使用 Vec&lt;Result&lt;T, E&gt;&gt;。如果不改变接口，这里，返回默认值是比较可行的方法。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635123075,"ip_address":"","comment_id":317222,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634715599","product_id":100085301,"comment_content":"hmget&#47;hmset等命令调用storage接口时，如何进行错误处理比较好？我现在是忽略错误，返回默认值，感觉不太好","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528723,"discussion_content":"嗯，返回一个数组这样的场景，单个错误的处理是比较麻烦，除非使用 Vec&amp;lt;Result&amp;lt;T, E&amp;gt;&amp;gt;。如果不改变接口，这里，返回默认值是比较可行的方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635123075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317179,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1634700980,"is_pvip":false,"replies":[{"id":"115248","content":"你需要自己先实现一下到 Value 的转换：<br><br>impl From&lt;bool&gt; for Value {<br>    fn from(b: bool) -&gt; Self {<br>        Self {<br>            value: Some(value::Value::Bool(b)),<br>        }<br>    }<br>}","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635123339,"ip_address":"","comment_id":317179,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634700980","product_id":100085301,"comment_content":"```<br>impl CommandService for Hexist {<br>    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {<br>        match store.contains(&amp;self.table, &amp;self.key) {<br>            Ok(v) =&gt; v.into(),<br>            Err(e) =&gt; e.into(),<br>        }<br>    }<br>}<br>```<br>这里编译报错：^^^^ the trait `From&lt;bool&gt;` is not implemented for `abi::CommandResponse`<br>布尔值怎样转为CommandResponse呢？<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528701,"discussion_content":"你需要自己先实现一下到 Value 的转换：\n\nimpl From&amp;lt;bool&amp;gt; for Value {\n    fn from(b: bool) -&amp;gt; Self {\n        Self {\n            value: Some(value::Value::Bool(b)),\n        }\n    }\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635123339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315992,"user_name":"终生恻隐","can_delete":false,"product_type":"c1","uid":2739953,"ip_address":"","ucode":"4E21A631545D22","user_header":"https://static001.geekbang.org/account/avatar/00/29/ce/f1/d2fc86bb.jpg","comment_is_top":false,"comment_ctime":1634096317,"is_pvip":false,"replies":[{"id":"115280","content":"嗯，不错","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635132364,"ip_address":"","comment_id":315992,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634096317","product_id":100085301,"comment_content":"&#47;&#47; hmget<br>    &#47;&#47; 创建 HGETALL 命令<br>    pub fn new_hmget(table: impl Into&lt;String&gt;, keys: Vec::&lt;impl Into&lt;String&gt; + Copy&gt;) -&gt; Self {<br>        let mut v: Vec::&lt;::prost::alloc::string::String&gt; = Vec::new();<br>        for &amp;i in keys.iter() {<br>            v.push(i.into());<br>        }<br>        &#47;&#47; map 显示 not reference, why?<br>        &#47;&#47; let a:  Vec::&lt;::prost::alloc::string::String&gt; = keys.iter().map(|&amp;x| x.into()).collect();<br>        Self {<br>            request_data: Some(RequestData::Hmget(Hmget {<br>                table: table.into(),<br>                keys: v<br>            })),<br>        }<br>    }<br><br>impl CommandService for Hmget {<br>    fn execute(self, store: &amp;impl Storage) -&gt; CommandResponse {<br>        let mut out: Vec::&lt;Kvpair&gt; = Vec::new();<br>        for key in self.keys {<br>            match store.get(&amp;self.table, &amp;key) {<br>                Ok(Some(v)) =&gt; out.push(Kvpair::new(key, v)),<br>                _ =&gt; {}<br>            }<br>        }<br>        return out.into();<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528228,"discussion_content":"嗯，不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635132364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}