{"id":285230,"title":"01 | 硬币找零问题：从贪心算法说起","content":"<p>你好，我是卢誉声。</p><p>作为“初识动态规划”模块的第一节课，我会带着你一起从贪心算法开始了解整个知识体系的脉络。现实中，我们往往不愿意承认自己贪婪。事实上，贪婪是渴望而不知满足，它是人的一种基本驱动力。既然是基本驱动力，那它自然就不会太难。</p><p>所以你可能会说贪心算法很简单啊，但其实不然，这里面还真有不少门道值得我们说说。而且，它还跟动态规划问题有着千丝万缕的联系，能够帮助我们理解真正的动归问题。</p><p>接下来我们就从一个简单的算法问题开始探讨，那就是硬币找零。在开始前，我先提出一个问题：<strong>任何算法都有它的局限性，贪心算法也如此，那么贪心算法能解决哪些问题呢？</strong></p><p>你不妨带着这个问题来学习下面的内容。</p><h2>硬币找零问题</h2><p>移动支付已经成为了我们日常生活当中的主流支付方式，无论是在便利店购买一瓶水，还是在超市或菜市场购买瓜果蔬菜等生活用品，无处不在的二维码让我们的支付操作变得异常便捷。</p><p>但在移动支付成为主流支付方式之前，我们常常需要面对一个简单问题，就是找零的问题。</p><p>虽然说硬币找零在日常生活中越来越少，但它仍然活跃在编程领域和面试问题当中，主要还是因为它极具代表性，也能多方面考察一个开发人员或面试者解决问题的能力。</p><p>既然如此，我们就先来看看这个算法问题的具体描述。</p><!-- [[[read_end]]] --><p>问题：给定n种不同面值的硬币，分别记为c[0], c[1], c[2], … c[n]，同时还有一个总金额k，编写一个函数计算出<strong>最少</strong>需要几枚硬币凑出这个金额k？每种硬币的个数不限，且如果没有任何一种硬币组合能组成总金额时，返回 -1。</p><pre><code>示例 1：\n\n输入：c[0]=1, c[1]=2, c[2]=5, k=12\n输出：3 \n解释：12 = 5 + 5 + 2\n</code></pre><pre><code>示例 2：\n\n输入：c[0]=5, k=7\n输出：-1\n解释：只有一种面值为5的硬币，怎么都无法凑出总价值为7的零钱。\n</code></pre><p>题目中有一个醒目的提示词，那就是“最少”。嗯，看起来这是一个求最值的问题，其实也好理解，如果题目不在这里设定这一条件，那么所求结果就不唯一了。</p><p>举个简单的例子，按照示例1的题设，有三种不同面值的硬币，分别为c1=1, c2=2, c3=5，在没有“最少”这一前提条件下你能罗列出几种不同的答案？我在这里随意列出几个：</p><pre><code>解1：输出：5，因为 5 + 2 + 2 + 2 + 1 = 12。\n解2：输出：6，因为 2 + 2 + 2 + 2 + 2 + 2 = 12。\n解3：输出：12，因为 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 = 12。\n</code></pre><p>所以，这是一个求最值的问题。那么求最值的核心问题是什么呢？嗯，无非就是<strong>穷举</strong>，显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币，那么最少的凑法，就是这道题目的答案。</p><p>在面试中，一般来说穷举从来都不是一个好方法。除非你要的结果就是所有的不同组合，而不是一个最值。但即便是求所有的不同组合，在计算的过程中也仍然会出现重复计算的问题，我们将这种现象称之为<strong>重叠子问题</strong>。</p><p>请你记住这个关键概念，它是动态规划当中的一个重要概念。但现在你只需要知道所谓重叠子问题就是：我们在罗列所有可能答案的过程中，可能存在重复计算的情况。我会在后续课程中与你深入探讨这个概念。</p><p>在尝试解决硬币找零问题前，我们先用较为严谨的定义来回顾一下贪心算法的概念。</p><h2>贪心算法</h2><p>所谓贪心算法，就是指它的每一步计算作出的都是在当前看起来最好的选择，也就是说它所作出的选择只是在某种意义上的局部最优选择，并不从整体最优考虑。在这里，我把这两种选择的思路称作<strong>局部最优解</strong>和<strong>整体最优解</strong>。</p><p>因此，我们可以得到贪心算法的基本思路：</p><ol>\n<li>根据问题来建立数学模型，一般面试题会定义一个简单模型；</li>\n<li>把待求解问题划分成若干个子问题，对每个子问题进行求解，得到子问题的局部最优解；</li>\n<li>把子问题的局部最优解进行合并，得到最后基于局部最优解的一个解，即原问题的答案。</li>\n</ol><h2>解题思路</h2><p>现在让我们回到这个问题上来。</p><p>既然这道题问的是<strong>最少</strong>需要几枚硬币凑出金额k，那么是否可以尝试使用贪心的思想来解这个问题呢？从面值最大的硬币开始兑换，最后得出的硬币总数很有可能就是最少的。</p><p>这个想法不错，让我们一起来试一试。</p><p>我用一个例子，带你看下整个贪心算法求解的过程，我们从  c[0]=5, c[1]=3 且k=11 的情况下寻求最少硬币数。按照“贪心原则”，我们先挑选面值最大的，即为5的硬币放入钱包。接着，还有6元待解（即11-5 = 6）。这时，我们再次“贪心”，放入5元面值的硬币。</p><p><img src=\"https://static001.geekbang.org/resource/image/20/12/20e9a277444dfcf9362cf1f22106d812.jpg?wh=1338*638\" alt=\"\"></p><p>这样来看，贪心算法其实不难吧。我在这里把代码贴出来，你可以结合代码再理解一下算法的执行步骤。</p><p>Java 实现：</p><pre><code>int getMinCoinCountHelper(int total, int[] values, int valueCount) {\n    int rest = total;\n    int count = 0;\n\n    // 从大到小遍历所有面值\n    for (int i = 0; i &lt; valueCount; ++ i) {\n        int currentCount = rest / values[i]; // 计算当前面值最多能用多少个\n        rest -= currentCount * values[i]; // 计算使用完当前面值后的余额\n        count += currentCount; // 增加当前面额用量\n\n        if (rest == 0) {\n            return count;\n        }\n    }\n\n    return -1; // 如果到这里说明无法凑出总价，返回-1\n}\n\nint getMinCoinCount() {\n    int[] values = { 5, 3 }; // 硬币面值\n    int total = 11; // 总价\n    return getMinCoinCountHelper(total, values, 2); // 输出结果\n}\n</code></pre><p>C++ 实现：</p><pre><code>int GetMinCoinCountHelper(int total, int* values, int valueCount) {\n    int rest = total;\n    int count = 0;\n\n    // 从大到小遍历所有面值\n    for (int i = 0; i &lt; valueCount; ++ i) {\n        int currentCount = rest / values[i]; // 计算当前面值最多能用多少个\n        rest -= currentCount * values[i]; // 计算使用完当前面值后的余额\n        count += currentCount; // 增加当前面额用量\n\n        if (rest == 0) {\n            return count;\n        }\n    }\n\n    return -1; // 如果到这里说明无法凑出总价，返回-1\n}\n\nint GetMinCoinCount() {\n    int values[] = { 5, 3 }; // 硬币面值\n    int total = 11; // 总价\n    return GetMinCoinCountHelper(total, values, 2); // 输出结果\n}\n</code></pre><p>这段代码就是简单地从最大的面值开始尝试，每次都会把当前面值的硬币尽量用光，然后才会尝试下一种面值的货币。</p><p>嗯。。。你有没有发现问题？那就是还剩1元零钱待找，但是我们只有c[0]=5, c[1]=3两种面值的硬币，怎么办？这个问题无解了，该返回-1了吗？显然不是。</p><p>我们把第2步放入的5元硬币取出，放入面值为3元的硬币试试看。这时，你就会发现，我们还剩3元零钱待找。</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/85/8fayy6c170b5732431fecb165d53e885.jpg?wh=1344*696\" alt=\"\"></p><p>正好我们还有c[1]=3的硬币可以使用，因此解是c[0]=5, c[1]=3, c[1]=3，即<strong>最少</strong>使用三枚硬币凑出了k=11这个金额。</p><p>我们对贪心算法做了改进，引入了回溯来解决前面碰到的“过于贪心”的问题。同样地，我把改进后的代码贴在这，你可以再看看跟之前算法实现的区别。</p><p>Java 实现：</p><pre><code>int getMinCoinCountOfValue(int total, int[] values, int valueIndex) {\n    int valueCount = values.length;\n    if (valueIndex == valueCount) { return Integer.MAX_VALUE; }\n\n    int minResult = Integer.MAX_VALUE;\n    int currentValue = values[valueIndex];\n    int maxCount = total / currentValue;\n\n    for (int count = maxCount; count &gt;= 0; count --) {\n        int rest = total - count * currentValue;\n\n        // 如果rest为0，表示余额已除尽，组合完成\n        if (rest == 0) {\n            minResult = Math.min(minResult, count);\n            break;\n        }\n\n        // 否则尝试用剩余面值求当前余额的硬币总数\n        int restCount = getMinCoinCountOfValue(rest, values, valueIndex + 1);\n\n        // 如果后续没有可用组合\n        if (restCount == Integer.MAX_VALUE) {\n            // 如果当前面值已经为0，返回-1表示尝试失败\n            if (count == 0) { break; }\n            // 否则尝试把当前面值-1\n            continue;\n        }\n\n        minResult = Math.min(minResult, count + restCount);\n    }\n\n    return minResult;\n}\n\nint getMinCoinCountLoop(int total, int[] values, int k) {\n    int minCount = Integer.MAX_VALUE;\n    int valueCount = values.length;\n    \n    if (k == valueCount) {\n        return Math.min(minCount, getMinCoinCountOfValue(total, values, 0));\n    }\n\n    for (int i = k; i &lt;= valueCount - 1; i++) {\n        // k位置已经排列好\n        int t = values[k];\n        values[k] = values[i];\n        values[i]=t;\n        minCount = Math.min(minCount, getMinCoinCountLoop(total, values, k + 1)); // 考虑后一位\n\n        // 回溯\n        t = values[k];\n        values[k] = values[i];\n        values[i]=t;\n    }\n\n    return minCount;\n}\n\nint getMinCoinCountOfValue() {\n    int[] values = { 5, 3 }; // 硬币面值\n    int total = 11; // 总价\n    int minCoin = getMinCoinCountLoop(total, values, 0);\n    \n    return (minCoin == Integer.MAX_VALUE) ? -1 : minCoin;  // 输出答案\n}\n</code></pre><p>C++ 实现：</p><pre><code>int GetMinCoinCountOfValue(int total, int* values, int valueIndex, int valueCount) {\n    if (valueIndex == valueCount) { return INT_MAX; }\n\n    int minResult = INT_MAX;\n    int currentValue = values[valueIndex];\n    int maxCount = total / currentValue;\n\n    for (int count = maxCount; count &gt;= 0; count --) {\n        int rest = total - count * currentValue;\n\n        // 如果rest为0，表示余额已除尽，组合完成\n        if (rest == 0) {\n            minResult = min(minResult, count);\n            break;\n        }\n\n        // 否则尝试用剩余面值求当前余额的硬币总数\n        int restCount = GetMinCoinCountOfValue(rest, values, valueIndex + 1, valueCount);\n\n        // 如果后续没有可用组合\n        if (restCount == INT_MAX) {\n            // 如果当前面值已经为0，返回-1表示尝试失败\n            if (count == 0) { break; }\n            // 否则尝试把当前面值-1\n            continue;\n        }\n\n        minResult = min(minResult, count + restCount);\n    }\n\n    return minResult;\n}\n\nint GetMinCoinCountLoop(int total, int* values, int valueCount, int k) {\n    int minCount = INT_MAX;\n    if (k == valueCount) {\n        return min(minCount, GetMinCoinCountOfValue(total, values, 0, valueCount));\n    }\n\n    for (int i = k; i &lt;= valueCount - 1; i++) {\n        // k位置已经排列好\n        int t = values[k];\n        values[k] = values[i];\n        values[i]=t;\n        minCount = min(minCount, GetMinCoinCountOfValue(total, values, 0, valueCount));\n        minCount = min(minCount, GetMinCoinCountLoop(total, values, valueCount, k + 1)); // 考虑后一位\n\n        // 回溯\n        t = values[k];\n        values[k] = values[i];\n        values[i]=t;\n    }\n\n    return minCount;\n}\n\nint GetMinCoinCountOfValue() {\n    int values[] = { 5, 3 }; // 硬币面值\n    int total = 11; // 总价\n    int minCoin = GetMinCoinCountLoop(total, values, 2, 0);\n    \n    return (minCoin == INT_MAX) ? -1 : minCoin;\n}\n</code></pre><p>改进后的算法实现在之前的基础上增加上了一个<strong>回溯</strong>过程。简单地说就是多了一个<strong>递归</strong>，不断尝试用更少的当前面值来拼凑。只要有一个组合成功，我们就返回总数，如果所有组合都尝试失败，就返回-1。</p><p>嗯，这样就没问题了，对硬币找零问题来说，我们得到了理想的结果。</p><h2>贪心算法的局限性</h2><p>从上面这个例子我们可以看出，如果只是简单采用贪心的思路，那么到用完2个5元硬币的时候我们就已经黔驴技穷了——因为剩下的1元无论如何都没法用现在的硬币凑出来。这是什么问题导致的呢？</p><p>这就是贪心算法所谓的<strong>局部最优</strong>导致的问题，因为我们每一步都尽量多地使用面值最大的硬币，因为这样数量肯定最小，但是有的时候我们就进入了死胡同，就好比上面这个例子。</p><p>所谓<strong>局部最优</strong>，就是只考虑“当前”的最大利益，既不向前多看一步，也不向后多看一步，导致每次都只用当前阶段的最优解。</p><p>那么如果纯粹采用这种策略我们就永远无法达到<strong>整体最优</strong>，也就无法求得题目的答案了。至于能得到答案的情况那就是我们走狗屎运了。</p><p>虽然纯粹的贪心算法作用有限，但是这种求解<strong>局部最优</strong>的思路在方向上肯定是对的，毕竟所谓的<strong>整体最优</strong>肯定是从很多个<strong>局部最优</strong>中选择出来的，因此所有最优化问题的基础都是贪心算法。</p><p>回到前面的例子，我只不过是在贪心的基础上加入了失败后的回溯，稍微牺牲一点当前利益，仅仅是希望通过下一个硬币面值的<strong>局部最优</strong>达到最终可行的<strong>整体最优</strong>。</p><p>所有贪心的思路就是我们最优化求解的根本思想，所有的方法只不过是针对贪心思路的改进和优化而已。回溯解决的是正确性问题，而动态规划则是解决时间复杂度的问题。</p><p>贪心算法是求解整体最优的真正思路源头，这就是为什么我们要在课程的一开始就从贪心算法讲起。</p><h2>课程总结</h2><p>硬币找零问题本质上是求最值问题。事实上，动态规划问题的一般形式就是求最值，而求最值的核心思想是<strong>穷举</strong>。这是因为只要我们能够找到所有可能的答案，从中挑选出最优的解就是算法问题的结果。</p><p>在没有优化的情况下，穷举从来就不算是一个好方法。所以我带你使用了贪心算法来解题，它是一种使用<strong>局部最优</strong>思想解题的算法（即从问题的某一个初始解出发逐步逼近给定的目标，以尽可能快的速度去求得更好的解，当达到算法中的某一步不能再继续前进时，算法停止）。</p><p>但是通过硬币找零问题，我们也发现了贪心算法本身的局限性：</p><ol>\n<li>不能保证求得的最后解是最佳的；</li>\n<li>不能用来求最大或最小解问题；</li>\n<li>只能求满足某些约束条件的可行解的范围。</li>\n</ol><p>我们往往需要使用<strong>回溯</strong>来优化贪心算法，否则就会导致算法失效。因此，在求解最值问题时，我们需要更好的方法来解。在后面课程讲到递归和穷举优化问题的时候，我会讲到解决最值问题的正确思路和方法：考虑<strong>整体最优</strong>的问题。</p><h2>课后思考</h2><p>在递归问题中，回溯是一种经典的优化算法性能的方法。递归对动态规划来说也十分重要。你能否举出使用回溯算法来解的面试问题？并给出你的解。希望你能在课后提出问题，进行练习。</p><p>最后，欢迎留言和我分享你的思考，我会第一时间给你反馈。如果今天的内容对你有所启发，也欢迎把它分享给你身边的朋友，邀请他一起学习！</p>","comments":[{"had_liked":false,"id":248618,"user_name":"AshinInfo","can_delete":false,"product_type":"c1","uid":1299511,"ip_address":"","ucode":"098F5C74A37009","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/37/aa152ddb.jpg","comment_is_top":true,"comment_ctime":1600242126,"is_pvip":false,"replies":[{"id":"91289","content":"赞，感谢你的分享，顶一顶，让更多人看到。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600256818,"ip_address":"","comment_id":248618,"utype":1}],"discussion_count":11,"race_medal":0,"score":"9.2233722918581002e+18","product_id":100060501,"comment_content":"重新调整得了java代码部分，提高代码的可读性 <br>private static void getMinCoinCountOfValue() {<br>        &#47;&#47; 硬币面值<br>        int[] values = {5, 3};<br>        &#47;&#47; 总价<br>        int total = 11;<br>        int minCoinCount = getMinCoinCountOfValueHelper(total, values);<br><br>        &#47;&#47; 输出结果<br>        System.out.println(minCoinCount);<br>    }<br><br>    &#47;**<br>     * @param total 金额<br>     * @param coins 币种数组，从大到小排序<br>     * @return 返回币数，如果返回-1表示无法凑够total<br>     *&#47;<br>    private static int getMinCoinCountOfValueHelper(int total, int[] coins) {<br>        if (coins.length == 0) {<br>            return -1;<br>        }<br><br>        &#47;&#47;当前币值<br>        int currentCoin = coins[0];<br><br>        &#47;&#47;使用当前币值数量<br>        int useCurrentCoinCount = total &#47; currentCoin;<br><br>        int restTotal = total - useCurrentCoinCount * currentCoin;<br>        &#47;&#47; 如果restTotal为0，表示余额已除尽，组合完成<br>        if (restTotal == 0) {<br>            return useCurrentCoinCount;<br>        }<br><br>        &#47;&#47; 其他币种数量<br>        int coninCount = -1;<br>        &#47;&#47; 剩余的币种<br>        int[] restCoins = Arrays.copyOfRange(coins, 1, coins.length);<br>        while (useCurrentCoinCount &gt;= 0) {<br>            &#47;&#47; 否则尝试用剩余面值求当前余额的硬币总数<br>            coninCount = getMinCoinCountOfValueHelper(restTotal, restCoins);<br><br>            &#47;&#47; 如果后续没有有可用组合,退一步，当前useCurrentCoinCount币数减1<br>            if (coninCount == -1) {<br>                &#47;&#47; 否则尝试把当前面值数-1<br>                useCurrentCoinCount--;<br>                &#47;&#47; 重新计算restTotal<br>                restTotal = total - useCurrentCoinCount * currentCoin;<br>                <br>            } else {<br>                return useCurrentCoinCount + coninCount;<br>            }<br>        }<br><br>        return -1;<br>    }","like_count":60,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505705,"discussion_content":"赞，感谢你的分享，顶一顶，让更多人看到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600256818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1299511,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d4/37/aa152ddb.jpg","nickname":"AshinInfo","note":"","ucode":"098F5C74A37009","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307498,"discussion_content":"/**\n     * 针对过于贪心的问题,对代码进行改进。进行回溯，枚举后，取最优值\n     *\n     * @param total 金额\n     * @param coins 币种数组，从大到小排序\n     * @return 返回币数，如果返回-1表示无法凑够total\n     */\n    private static int getMinCoinCountOfValueHelper(int total, int[] coins) {\n        if (coins.length == 0) {\n            return -1;\n        }\n\n        //当前币值\n        int currentCoin = coins[0];\n\n        //当前面币值使用数量\n        int useCurrentCoinCount = total / currentCoin;\n\n        int restTotal = total - useCurrentCoinCount * currentCoin;\n        // 如果restTotal为0，表示余额已除尽，组合完成\n        if (restTotal == 0) {\n            return useCurrentCoinCount;\n        }\n\n        // 最少币数\n        int minCoinCount = Integer.MAX_VALUE;\n        // 其他币种数量\n        int coinCount = -1;\n        // 剩余的币种\n        int[] restCoins = Arrays.copyOfRange(coins, 1, coins.length);\n        while (useCurrentCoinCount >= 0) {\n            // 否则尝试用剩余面值求当前余额的硬币总数\n            coinCount = getMinCoinCountOfValueHelper(restTotal, restCoins);\n\n            // 有解直接取最少的值\n            if (coinCount != -1) {\n                minCoinCount = Math.min(minCoinCount, useCurrentCoinCount + coinCount);\n            }\n\n            // 如果后续没有可用组合,退一步，当前useCurrentCoinCount币数减1 否则尝试把当前面值数-1\n            useCurrentCoinCount--;\n            // 重新计算restTotal\n            restTotal = total - useCurrentCoinCount * currentCoin;\n        }\n\n        if (Integer.MAX_VALUE == minCoinCount) {\n            return -1;\n\n        } else {\n            return minCoinCount;\n        }\n    }","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1600671306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1299511,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d4/37/aa152ddb.jpg","nickname":"AshinInfo","note":"","ucode":"098F5C74A37009","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310552,"discussion_content":"你的代码，我一遍就看懂了，但是老师的代码，看了好几遍，也没明白。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1601904082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307498,"ip_address":""},"score":310552,"extra":""},{"author":{"id":1369757,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7WkTI1IicbKvsPJng5vQh5qlrf1smbfl2zb7icHZfzcAk1k4lr8w8IDEAdrqq1NHW5XZMPXiaa1h7Jn1LGOWOCkIA/132","nickname":"早起不吃虫","note":"","ucode":"13CD3B5E1F9435","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1299511,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d4/37/aa152ddb.jpg","nickname":"AshinInfo","note":"","ucode":"098F5C74A37009","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333846,"discussion_content":"确实比老师的代码清晰很多","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1607651610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":307498,"ip_address":""},"score":333846,"extra":""}]},{"author":{"id":1135948,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/4c/df7ff549.jpg","nickname":"星星","note":"","ucode":"206B5063D53B01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557564,"discussion_content":"代码可读性非常高，老师的代码对于方法和变量的解释欠缺，对比之下这位同学这段代码通俗易懂，赞！！！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1647863546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2144376,"avatar":"https://static001.geekbang.org/account/avatar/00/20/b8/78/ab0c798a.jpg","nickname":"Novmbrain","note":"","ucode":"06FB7D329ECC1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368201,"discussion_content":"确实，老师的代码看的我头疼","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618603346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1140836,"avatar":"https://static001.geekbang.org/account/avatar/00/11/68/64/756ba667.jpg","nickname":"just code it","note":"","ucode":"9953DAD398F33D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2144376,"avatar":"https://static001.geekbang.org/account/avatar/00/20/b8/78/ab0c798a.jpg","nickname":"Novmbrain","note":"","ucode":"06FB7D329ECC1E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371003,"discussion_content":"这位作者写的代码有点绕","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619605179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368201,"ip_address":""},"score":371003,"extra":""}]},{"author":{"id":1903459,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/m7fLWyJrnwEPoIefiaxusQRh6D1Nq7PCXA8RiaxkmzdNEmFARr5q8L4qouKNaziceXia92an8hzYa5MLic6N6cNMEoQ/132","nickname":"alex_lai","note":"","ucode":"3057F2A593A6DB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547898,"discussion_content":"上来除得尽就返回了？是不是得跟当选择下的其他的选择做个min？ \n只是肉眼看了一下 说错请见谅 比如说你第一个coin是1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642925161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2943644,"avatar":"","nickname":"Geek_de7049","note":"","ucode":"DC0779858443FB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1903459,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/m7fLWyJrnwEPoIefiaxusQRh6D1Nq7PCXA8RiaxkmzdNEmFARr5q8L4qouKNaziceXia92an8hzYa5MLic6N6cNMEoQ/132","nickname":"alex_lai","note":"","ucode":"3057F2A593A6DB","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":563502,"discussion_content":"不需要，方法中coins数组入参是按照从大到小顺序排的，最大的直接除尽直接就是最小的硬币数量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650011811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547898,"ip_address":""},"score":563502,"extra":""}]},{"author":{"id":2299399,"avatar":"","nickname":"Geek_531e37","note":"","ucode":"1988FE31CCC290","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351682,"discussion_content":"请问循环条件的依据是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614395222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1159871,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b2/bf/aea9e7c6.jpg","nickname":"615","note":"","ucode":"1F04CDC9966F72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2299399,"avatar":"","nickname":"Geek_531e37","note":"","ucode":"1988FE31CCC290","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406692,"discussion_content":"useCurrentCoinCount--; 使得当前最大面值所用硬币-1继续尝试，减少到0为止。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634821807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351682,"ip_address":""},"score":406692,"extra":""}]}]},{"had_liked":false,"id":248582,"user_name":"sanyinchen","can_delete":false,"product_type":"c1","uid":2015961,"ip_address":"","ucode":"815B6EF6662473","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkKNKezgVwHxRSPyiaHz9GXVVpsq6jqRn9tqP8DmibpDoAjpc6JmM4icC5maNSssOJDjmRc8icERoWicA/132","comment_is_top":false,"comment_ctime":1600229655,"is_pvip":false,"replies":[{"id":"91293","content":"嗯，这里的代码逻辑需要再加上“回溯时比较保留最小值”，这样就没有问题了。<br><br>贪心真的很容易过于贪婪，代码已更新。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600268373,"ip_address":"","comment_id":248582,"utype":1}],"discussion_count":2,"race_medal":0,"score":"104679444759","product_id":100060501,"comment_content":"上述回溯+贪心并不能取到最优解,<br>比如[1,7,10] amount=14<br>那么根据递归深搜 10 + 1 + 1 + 1 + 1 会比 7 + 7 先到","like_count":24,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505691,"discussion_content":"嗯，这里的代码逻辑需要再加上“回溯时比较保留最小值”，这样就没有问题了。\n\n贪心真的很容易过于贪婪，代码已更新。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600268373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1017595,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/86/fb/4add1a52.jpg","nickname":"兵戈","note":"","ucode":"0F1723EBCE1BC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306312,"discussion_content":"当前算法确实不能算出最优解，而且也没有对数组做从大到小排序（虽然排序了也不一定能算出最优解）。\n不过我理解本文的算法提出贪心算法的大体思路，并不是一个完整的解法，最优解算法在下一篇文章中有完整给出","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1600244929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248459,"user_name":"梅亮宏@创造力","can_delete":false,"product_type":"c1","uid":1372221,"ip_address":"","ucode":"5D890C40738DFD","user_header":"https://static001.geekbang.org/account/avatar/00/14/f0/3d/158ab958.jpg","comment_is_top":false,"comment_ctime":1600170870,"is_pvip":true,"replies":[{"id":"91303","content":"没错，寻找最优解的时候，本质上还是需要进行枚举（穷举），因此优化算法性能是最重要的第一步，如果使用了动态规划，就可以大幅压缩计算时间，在此基础上，如果性能仍不满意（即数据规模实在太巨大），那么则可以考虑使用工程化的方法，比如你提到的分布式计算来提高计算性能。<br><br>AI 中的强化学习，本质上它的目的是寻找全局最优解。但是，我们最终能找的只是一定范围内的局部最优解，使得这个局部最优解在一定条件下，最接近我们期望的全局最优解。这个发散点很好，算法发展到一定高度就会进入机器学习领域，无论如何，基本的算法思路其实没有本质差别。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600269772,"ip_address":"","comment_id":248459,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44549843830","product_id":100060501,"comment_content":"老师说的很生动！用递归加局部最优的方法一定能得到正解。但是如果问题变得更加复杂的情况下，例如我们有1亿中硬币可以用，总币值为几万亿。可能还需要优化一下算法性能或者用分布式计算把性能提高？<br><br>这让我想到了ai中的reinforcement learning。个人认为有些偏全局优化？就如alphaGo，每一步棋都需要以整个棋局为出发点考虑。有点像老师这个算法里面的递归，即每尝试走一步的时候都会记录状态，用树状结构罗列所有可能性然后回溯。通过神经网络来的weight值估算是不是应该回溯。另外即使找到最优解了，还可以设置exploit更多最优的可能。纯个人理解，有点发散，希望老师指正！","like_count":10,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505657,"discussion_content":"没错，寻找最优解的时候，本质上还是需要进行枚举（穷举），因此优化算法性能是最重要的第一步，如果使用了动态规划，就可以大幅压缩计算时间，在此基础上，如果性能仍不满意（即数据规模实在太巨大），那么则可以考虑使用工程化的方法，比如你提到的分布式计算来提高计算性能。\n\nAI 中的强化学习，本质上它的目的是寻找全局最优解。但是，我们最终能找的只是一定范围内的局部最优解，使得这个局部最优解在一定条件下，最接近我们期望的全局最优解。这个发散点很好，算法发展到一定高度就会进入机器学习领域，无论如何，基本的算法思路其实没有本质差别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600269772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250728,"user_name":"AshinInfo","can_delete":false,"product_type":"c1","uid":1299511,"ip_address":"","ucode":"098F5C74A37009","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/37/aa152ddb.jpg","comment_is_top":false,"comment_ctime":1601203058,"is_pvip":false,"replies":[{"id":"91904","content":"是的，回溯就相当于穷举过程中递归的一个补丁（patch）。<br><br>另外，你对递归和回溯的理解、比喻，比较恰当。可以这么理解。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1601530660,"ip_address":"","comment_id":250728,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27371006834","product_id":100060501,"comment_content":"递归的目的是求解<br>回溯+递归的目的是枚举所有组合的解，并取最优解返回<br>没有回溯，递归只能获得一个解或者无解，获得的解不一定是最优解<br>递归是一种算法结构，回溯是一种算法思想<br>一般回溯多用递归实现<br>","like_count":6,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506273,"discussion_content":"是的，回溯就相当于穷举过程中递归的一个补丁（patch）。\n\n另外，你对递归和回溯的理解、比喻，比较恰当。可以这么理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601530660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248267,"user_name":"Karl","can_delete":false,"product_type":"c1","uid":1027890,"ip_address":"","ucode":"7938C53C6D9387","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/32/74465c5e.jpg","comment_is_top":false,"comment_ctime":1600085082,"is_pvip":false,"replies":[{"id":"91242","content":"你好 Karl！<br>感谢你提出此问题。代码已经做了相应调整和更新。并追加了 Java 版本的代码供大家参考。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600155382,"ip_address":"","comment_id":248267,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23074921562","product_id":100060501,"comment_content":"老师，第一段代码的第22行，是不是应该为调用GetMinCoinCountHelper?","like_count":5,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505600,"discussion_content":"你好 Karl！\n感谢你提出此问题。代码已经做了相应调整和更新。并追加了 Java 版本的代码供大家参考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600155382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248316,"user_name":"好运来","can_delete":false,"product_type":"c1","uid":1113937,"ip_address":"","ucode":"F469ED6CEFEF30","user_header":"https://static001.geekbang.org/account/avatar/00/10/ff/51/9d5cfadd.jpg","comment_is_top":false,"comment_ctime":1600099017,"is_pvip":true,"replies":[{"id":"91296","content":"赞。事实上，纯粹的贪心算法只考虑了局部最优的情况，因此在绝大多数情况下是得不到最优解的。在回溯版本中，需要枚举所有的组合，并保留最小的结果。本质上，这里是通过回溯来进行穷举的，因此效率还是不够好。后面的课程会给出更好的解决方法。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600268645,"ip_address":"","comment_id":248316,"utype":1}],"discussion_count":1,"race_medal":1,"score":"14485000905","product_id":100060501,"comment_content":"测试在原有贪心基础上加上回溯可以找到一组可行解：<br>int[] values = new int[] {5, 3}; &#47;&#47; 硬币面值<br>int total = 11; &#47;&#47; 总价<br>贪心策略求出可行解不是全局最优解：<br>values = new int[]{5, 4, 1}; &#47;&#47; 硬币面值<br>total = 13; &#47;&#47; 总价","like_count":3,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505618,"discussion_content":"赞。事实上，纯粹的贪心算法只考虑了局部最优的情况，因此在绝大多数情况下是得不到最优解的。在回溯版本中，需要枚举所有的组合，并保留最小的结果。本质上，这里是通过回溯来进行穷举的，因此效率还是不够好。后面的课程会给出更好的解决方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600268645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248280,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1600089123,"is_pvip":false,"replies":[{"id":"91263","content":"欢迎进入动归世界。<br>动态规划其实也不难，是有规可循的。跟随课程，我们一起进步。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600176226,"ip_address":"","comment_id":248280,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14484991011","product_id":100060501,"comment_content":"对动规有了新的了解，感谢老师！","like_count":3,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505605,"discussion_content":"欢迎进入动归世界。\n动态规划其实也不难，是有规可循的。跟随课程，我们一起进步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600176226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1504234,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","nickname":"EncodedStar","note":"","ucode":"03958CA7DDD6AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306131,"discussion_content":"谢谢老师！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600178102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293447,"user_name":"020","can_delete":false,"product_type":"c1","uid":1754350,"ip_address":"","ucode":"5556345E7633B2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/c4/ee/af002b61.jpg","comment_is_top":false,"comment_ctime":1621391461,"is_pvip":false,"replies":[{"id":"108593","content":"贪心本身其实是不想枚举出所有情况，不过这个就会导致只能得到局部最优解，最后想要解决问题还是要通过不同方式枚举出所有组合。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1624693460,"ip_address":"","comment_id":293447,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10211326053","product_id":100060501,"comment_content":"看来半天回溯+贪心，发现其实就是把所有情况都枚举出来取最小值。。。。。。","like_count":2,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520217,"discussion_content":"贪心本身其实是不想枚举出所有情况，不过这个就会导致只能得到局部最优解，最后想要解决问题还是要通过不同方式枚举出所有组合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624693460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248326,"user_name":"Geek_98ba19","can_delete":false,"product_type":"c1","uid":1232209,"ip_address":"","ucode":"9ACD8A76F5D9FF","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/51/7ee94f83.jpg","comment_is_top":false,"comment_ctime":1600109183,"is_pvip":false,"replies":[{"id":"91261","content":"提供全方位服务。Java 语言描述的代码已经跟随专栏上线，每一段代码都会提供Java + C++ 两种语言描述。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600176110,"ip_address":"","comment_id":248326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10190043775","product_id":100060501,"comment_content":"C++语法看不懂啊，能否用Java 这种绝大数人的入门语言写例子啊？","like_count":2,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505621,"discussion_content":"提供全方位服务。Java 语言描述的代码已经跟随专栏上线，每一段代码都会提供Java + C++ 两种语言描述。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600176110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248322,"user_name":"KipJiang","can_delete":false,"product_type":"c1","uid":1076521,"ip_address":"","ucode":"9914755766177F","user_header":"https://static001.geekbang.org/account/avatar/00/10/6d/29/897c9835.jpg","comment_is_top":false,"comment_ctime":1600103402,"is_pvip":false,"replies":[{"id":"91297","content":"上手实际操作是非常重的，鼓励这种学习的方法哟。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600268671,"ip_address":"","comment_id":248322,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10190037994","product_id":100060501,"comment_content":"编译、运行通过：<br><br>#include &lt;iostream&gt;<br><br>int GetMinCoinCountOfValueHelper(int total, int* values, int valueIndex, int valueCount)<br>{<br>    if (valueIndex == valueCount) {<br>        return -1;<br>    }<br><br>    int currentValue = values[valueIndex];<br>    int maxCount = total &#47; currentValue;<br><br>    for (int count = maxCount; count &gt;= 0; count --) {<br>        int rest = total - count * currentValue;<br>        &#47;&#47; 如果rest为0，表示余额已除尽，组合完成<br>        if (rest == 0) {<br>            return count;<br>        }<br><br>        &#47;&#47; 否则尝试用剩余面值求当前余额的硬币总数<br>        int restCount = GetMinCoinCountOfValueHelper(rest, values, valueIndex + 1, valueCount);<br><br>        &#47;&#47; 如果后续没有可用组合<br>        if (restCount == -1) {<br>            &#47;&#47; 如果当前面值已经为0，返回-1表示尝试失败<br>            if (count == 0) { return -1; }<br>            continue; &#47;&#47; 否则尝试把当前面值-1<br>        }<br><br>        return count + restCount;<br>    }<br><br>    return -1;<br>}<br><br>void GetMinCoinCountOfValue() {<br>    int values[] = { 5, 3 }; &#47;&#47; 硬币面值<br>    int total = 11; &#47;&#47; 总价<br>    int valueCount = sizeof(values) &#47; sizeof(values[0]);<br>    int minCoinCount = GetMinCoinCountOfValueHelper(total, values, 0, valueCount);<br>    <br>    std::cout &lt;&lt; minCoinCount &lt;&lt; std::endl; &#47;&#47; 输出结果<br>}<br><br>int main()<br>{<br>    GetMinCoinCountOfValue();<br>    return 0;<br>}","like_count":2,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505619,"discussion_content":"上手实际操作是非常重的，鼓励这种学习的方法哟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600268671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1183950,"avatar":"https://static001.geekbang.org/account/avatar/00/12/10/ce/fd941b1a.jpg","nickname":"鬼谷阳明","note":"","ucode":"DBAB611CEB9C75","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305956,"discussion_content":" int valueCount = sizeof(values) / sizeof(values[0]);专栏里这行忘记了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600137255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307897,"user_name":"vin","can_delete":false,"product_type":"c1","uid":2739189,"ip_address":"","ucode":"F279740F504B31","user_header":"https://static001.geekbang.org/account/avatar/00/29/cb/f5/959d1c1b.jpg","comment_is_top":false,"comment_ctime":1629295549,"is_pvip":false,"replies":[{"id":"118247","content":"这里实际上是考虑所有的排列组合。","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1639321688,"ip_address":"","comment_id":307897,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5924262845","product_id":100060501,"comment_content":"GetMinCoinCountLoop这个方法是在干嘛呀？感觉直接getMinCoinCountOfValue(total, values, 0)不就行了吗？GetMinCoinCountLoop将数组元素换来换去有啥意义吗？有点看不懂，要是多加点注释就好了","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538090,"discussion_content":"这里实际上是考虑所有的排列组合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639321688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286968,"user_name":"Geek_8c4282","can_delete":false,"product_type":"c1","uid":1562826,"ip_address":"","ucode":"09E13C2DDBA48D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq3opKxGyQia0CQibZU8If7Qv6ia3j4XiaWIdCHxrK0T3uZ5RVUSgwf0IJVRVt0wVLibryycTqv4VnEzbw/132","comment_is_top":false,"comment_ctime":1617709419,"is_pvip":false,"replies":[{"id":"104656","content":"谢谢建议，我们会改进的。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1618411506,"ip_address":"","comment_id":286968,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5912676715","product_id":100060501,"comment_content":"回溯的那段算法，方法说明没有，每一步要干什么也没有，实在看不懂，接口注释还是写写吧","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518150,"discussion_content":"谢谢建议，我们会改进的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618411506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":276066,"user_name":"宋不肥","can_delete":false,"product_type":"c1","uid":1240126,"ip_address":"","ucode":"32B34AF579C91C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/3e/885ec1d2.jpg","comment_is_top":false,"comment_ctime":1611760689,"is_pvip":false,"replies":[{"id":"101323","content":"谢谢建议，变量命名可读性这个因人而异，的确不能满足所有人的命名习惯，我会考虑改进的。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1613370320,"ip_address":"","comment_id":276066,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5906727985","product_id":100060501,"comment_content":"时隔1个多月，二刷一下，发现这一篇比第二篇代码难读，就在于变量和函数的命名，实在是又长，意义又差，比如valueCount 完全不如valuelength这样的名字来的直观，而且取名还很像，很多时候看了几行，就忘记标识符号的意思是啥来着了，第二篇命名改进了之后可读性就好很多。","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514588,"discussion_content":"谢谢建议，变量命名可读性这个因人而异，的确不能满足所有人的命名习惯，我会考虑改进的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613370320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249475,"user_name":"AshinInfo","can_delete":false,"product_type":"c1","uid":1299511,"ip_address":"","ucode":"098F5C74A37009","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/37/aa152ddb.jpg","comment_is_top":false,"comment_ctime":1600669014,"is_pvip":false,"replies":[{"id":"91939","content":"感谢你的肯定！","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1601567849,"ip_address":"","comment_id":249475,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5895636310","product_id":100060501,"comment_content":"1.从找零问题开始，引出贪心算法思想<br>2.在使用贪心算法后，发现过于贪心导致找零不一定能得到解<br>3.于是通过调整代码，即使用回溯算法（即递归的方式实现回溯）来解决过于贪心导致无法得出解问题<br>4. 进一步发现上面调整的代码虽然能得到解，但是得到的解不一定是最优解<br>作者层层递进，循循善诱。牛逼<br>最后一点小建议，如果能在文章的开头能有个小目录，再好不过了","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505935,"discussion_content":"感谢你的肯定！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601567849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248480,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1600176625,"is_pvip":false,"replies":[{"id":"91302","content":"嗯嗯，你的理解是正确的。贪心算法的局限性体现在它在每一步计算中只考虑局部最优解，这导致了它的局限性。对于需要考虑整体最优的问题，我们需要别的方法。<br><br>后面的课程就会提到穷举、回溯以及动态规划。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600269520,"ip_address":"","comment_id":248480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5895143921","product_id":100060501,"comment_content":"之前对贪心算法的理解是：因为总是局部最优，所以不能用来解决实际问题。学完了这一节，明白了贪心算法的局限性及其应用场景。","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505660,"discussion_content":"嗯嗯，你的理解是正确的。贪心算法的局限性体现在它在每一步计算中只考虑局部最优解，这导致了它的局限性。对于需要考虑整体最优的问题，我们需要别的方法。\n\n后面的课程就会提到穷举、回溯以及动态规划。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600269520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248375,"user_name":"托尼斯威特","can_delete":false,"product_type":"c1","uid":1729060,"ip_address":"","ucode":"98A1035527292E","user_header":"https://static001.geekbang.org/account/avatar/00/1a/62/24/07e2507c.jpg","comment_is_top":false,"comment_ctime":1600139806,"is_pvip":false,"replies":[{"id":"91304","content":"贪心算法只是在一定条件下，希望能加快搜索的速度。但是，往往在大多数情况下，都不满足这种条件。因此，贪心很难直接得到整体最优解。<br><br>贪心算法的本质决定了它能解决问题的范围和高度。如果不辅以别的工具函数或算法，它关注的是局部最优解。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600269867,"ip_address":"","comment_id":248375,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5895107102","product_id":100060501,"comment_content":"原来如此，用搜索解这个题，可以带上贪心的思路","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505638,"discussion_content":"贪心算法只是在一定条件下，希望能加快搜索的速度。但是，往往在大多数情况下，都不满足这种条件。因此，贪心很难直接得到整体最优解。\n\n贪心算法的本质决定了它能解决问题的范围和高度。如果不辅以别的工具函数或算法，它关注的是局部最优解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600269867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248359,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1600132899,"is_pvip":false,"replies":[{"id":"91306","content":"没错，是的。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600269902,"ip_address":"","comment_id":248359,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5895100195","product_id":100060501,"comment_content":"感觉带有回溯的贪心算法最差的情况应该就是进行了穷举吧..","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505631,"discussion_content":"没错，是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600269902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1703222,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","nickname":"Roger宇","note":"","ucode":"CBA23C01409349","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305992,"discussion_content":"应该是的，每次回溯换一个也就是碰运气，最差运气也就是穷举\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600144168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248270,"user_name":"赵国辉","can_delete":false,"product_type":"c1","uid":1166280,"ip_address":"","ucode":"390196BD3082B8","user_header":"https://static001.geekbang.org/account/avatar/00/11/cb/c8/ff9f3ffb.jpg","comment_is_top":false,"comment_ctime":1600086319,"is_pvip":false,"replies":[{"id":"91294","content":"你问的这个问题非常好。没错，的确会出现这种情况，所以为了确保最优解，必须得对所有得到的结果进行比较，保留最小的那个。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600268445,"ip_address":"","comment_id":248270,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5895053615","product_id":100060501,"comment_content":"老师，按照本节课的算法，我的理解是，由于没有对所有解进行比较。会不会出现找到的解不是最优解呢？","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505601,"discussion_content":"你问的这个问题非常好。没错，的确会出现这种情况，所以为了确保最优解，必须得对所有得到的结果进行比较，保留最小的那个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600268445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263094,"avatar":"https://static001.geekbang.org/account/avatar/00/13/45/f6/c75ff5a6.jpg","nickname":"ll","note":"","ucode":"30075384D40BCA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305962,"discussion_content":"int values[] = { 5, 3 }; // 硬币面值  前提是已经从大到小排序过了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600138718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248242,"user_name":"赵国辉","can_delete":false,"product_type":"c1","uid":1166280,"ip_address":"","ucode":"390196BD3082B8","user_header":"https://static001.geekbang.org/account/avatar/00/11/cb/c8/ff9f3ffb.jpg","comment_is_top":false,"comment_ctime":1600077392,"is_pvip":false,"replies":[{"id":"91202","content":"感谢你的留言。<br>咱们以实用为王，通用思路是从贪心算法开始，然后考虑是否能用穷举来解决（如果穷举效率低，就看能否用回溯来加速穷举），接着才是备忘录，最后如果还是不够好，那么选择动态规划来解决。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600090200,"ip_address":"","comment_id":248242,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5895044688","product_id":100060501,"comment_content":"老师从最直接的解法入手，然后指出其局限和不足。然后再针对此问题进行优化和解决。而不是直接给出答案。感觉很自然，更容易理解问题本质，很棒。","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505594,"discussion_content":"感谢你的留言。\n咱们以实用为王，通用思路是从贪心算法开始，然后考虑是否能用穷举来解决（如果穷举效率低，就看能否用回溯来加速穷举），接着才是备忘录，最后如果还是不够好，那么选择动态规划来解决。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600090200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351335,"user_name":"ppyh","can_delete":false,"product_type":"c1","uid":1351148,"ip_address":"上海","ucode":"14022ADEC9B53F","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","comment_is_top":false,"comment_ctime":1657707422,"is_pvip":false,"replies":[{"id":"130356","content":"这个代码里是需要 getMinCoinCountLoop 才能得到最优解。","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1664034838,"ip_address":"上海","comment_id":351335,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1657707422","product_id":100060501,"comment_content":"没有getMinCoinCountLoop这段代码是不是也可以求出最优解啊","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588739,"discussion_content":"这个代码里是需要 getMinCoinCountLoop 才能得到最优解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664034838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351148,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/ec/235b74c0.jpg","nickname":"ppyh","note":"","ucode":"14022ADEC9B53F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579832,"discussion_content":"补充如果数组是从大到小的话","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657709271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348242,"user_name":"T0ngJG","can_delete":false,"product_type":"c1","uid":1197994,"ip_address":"","ucode":"1C630EEECDED41","user_header":"https://static001.geekbang.org/account/avatar/00/12/47/aa/9236524f.jpg","comment_is_top":false,"comment_ctime":1654864114,"is_pvip":false,"replies":[{"id":"127725","content":"Loop部分的目的的确就是全排列·。","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1657525943,"ip_address":"","comment_id":348242,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1654864114","product_id":100060501,"comment_content":"看了半天，loop是个阶乘级的代码，在做全排列吧…… 感觉这个题目里应该排个序从大到小去计算就好了。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579563,"discussion_content":"Loop部分的目的的确就是全排列·。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657525943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345324,"user_name":"Pedestrian","can_delete":false,"product_type":"c1","uid":1383945,"ip_address":"","ucode":"D51E870B3CB26C","user_header":"https://static001.geekbang.org/account/avatar/00/15/1e/09/a4dd3217.jpg","comment_is_top":false,"comment_ctime":1652193405,"is_pvip":false,"replies":[{"id":"126434","content":"没有问题，本质就是递归回溯。赞一个～","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1653378890,"ip_address":"","comment_id":345324,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652193405","product_id":100060501,"comment_content":"对置顶评论同学代码，用JavaScript实现：<br>&#47;**<br> * @param total 金额<br> * @param coins 币种数组，从大到小排序<br> * @return 返回币数，如果返回-1表示无法凑够total<br> *&#47;<br>function getMinCoinCountOfValueHelper (total, coins) {<br>    if (coins.length === 0) {<br>        return -1;<br>    }<br>    &#47;&#47; 当前币值<br>    const currentCoin = coins[0];<br>    &#47;&#47; 使用当前币值数量<br>    let useCurrentCoinCount = Math.floor(total &#47; currentCoin);<br><br>    let restTotal = total - (useCurrentCoinCount * currentCoin);<br>    &#47;&#47; 如果restTotal为0，表示余额已除尽，组合完成<br>    if (restTotal === 0) {<br>        return useCurrentCoinCount;<br>    }<br>    &#47;&#47; 其他币种数量<br>    let coninCount = -1;<br>    &#47;&#47; 剩余的币种<br>    const restCoins = coins.slice(1, coins.length)<br><br>    while (useCurrentCoinCount &gt;= 0) {<br>        &#47;&#47; 否则尝试用剩余面值求当前余额的硬币总数<br>        coninCount = getMinCoinCountOfValueHelper(restTotal, restCoins)<br>        &#47;&#47; 如果后续没有有可用组合,退一步，当前useCurrentCoinCount币数减1<br>        if (coninCount === -1) {<br>            &#47;&#47; 否则尝试把当前面值数-1<br>            useCurrentCoinCount--;<br>            &#47;&#47; 重新计算restTotal<br>            restTotal = total - (useCurrentCoinCount * currentCoin)<br>        } else {<br>            return useCurrentCoinCount + coninCount;<br>        }<br>    }<br>    return -1;<br>}","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573358,"discussion_content":"没有问题，本质就是递归回溯。赞一个～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653378890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344787,"user_name":"Pedestrian","can_delete":false,"product_type":"c1","uid":1383945,"ip_address":"","ucode":"D51E870B3CB26C","user_header":"https://static001.geekbang.org/account/avatar/00/15/1e/09/a4dd3217.jpg","comment_is_top":false,"comment_ctime":1651766052,"is_pvip":false,"replies":[{"id":"126435","content":"代码实现没有问题。 :)","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1653378899,"ip_address":"","comment_id":344787,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651766052","product_id":100060501,"comment_content":"文中第一阶段的demo代码，用JavaScript实现：<br>function minCoinChange(coins, amount) {<br>    const change = [];<br>    let total = 0;<br>    for (let i = coins.length; i &gt;= 0; i--) {<br>        const coin = coins[i];<br>        while (total + coin &lt;= amount) {<br>            change.push(coin);<br>            total += coin;<br>        }<br>    }<br>    return change;<br>}","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573359,"discussion_content":"代码实现没有问题。 :)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653378899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343456,"user_name":"7years","can_delete":false,"product_type":"c1","uid":2171508,"ip_address":"","ucode":"C6370A91EEDD99","user_header":"https://static001.geekbang.org/account/avatar/00/21/22/74/e0c720a1.jpg","comment_is_top":false,"comment_ctime":1650859923,"is_pvip":false,"replies":[{"id":"126436","content":"是的，的确如此，这里暴力会比较耗时。","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1653378909,"ip_address":"","comment_id":343456,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650859923","product_id":100060501,"comment_content":"老师 直接给values从大到小排序是不是就不需要loop的那段代码了 这种简单的回溯好像时间会很久","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573360,"discussion_content":"是的，的确如此，这里暴力会比较耗时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653378909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331962,"user_name":"alex_lai","can_delete":false,"product_type":"c1","uid":1903459,"ip_address":"","ucode":"3057F2A593A6DB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/m7fLWyJrnwEPoIefiaxusQRh6D1Nq7PCXA8RiaxkmzdNEmFARr5q8L4qouKNaziceXia92an8hzYa5MLic6N6cNMEoQ/132","comment_is_top":false,"comment_ctime":1642923076,"is_pvip":true,"replies":[{"id":"126442","content":"其实总结就是：<br>1.\t如果问题每一步的局部最优解可以累积出全局最优解，那么直接贪心<br>2.\t如果局部最优解加上实际可以接受的计算存储消耗，那么就用贪心去改，这个比较难判定，需要自己分析一下<br>这两种情况都建议贪心，动态规划反而使得问题复杂了。<br>","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1653378991,"ip_address":"","comment_id":331962,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642923076","product_id":100060501,"comment_content":"判断贪心不能用感觉不难。 但是什么时候可以用贪心有总结吗？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573367,"discussion_content":"其实总结就是：\n1.\t如果问题每一步的局部最优解可以累积出全局最优解，那么直接贪心\n2.\t如果局部最优解加上实际可以接受的计算存储消耗，那么就用贪心去改，这个比较难判定，需要自己分析一下\n这两种情况都建议贪心，动态规划反而使得问题复杂了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653378991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325586,"user_name":"王建","can_delete":false,"product_type":"c1","uid":1153792,"ip_address":"","ucode":"68000818D8AA41","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/00/8c1b9631.jpg","comment_is_top":false,"comment_ctime":1639031805,"is_pvip":false,"replies":[{"id":"118502","content":"getMinCoinCountOfValue本身的代码是一个回溯的策略，每一次递归还需要使用getMinCoinCountLoop来做一个排列组合枚举这种情况下的完整组合，确保所有的情况都被计算进来了。","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1639488096,"ip_address":"","comment_id":325586,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639031805","product_id":100060501,"comment_content":"测试getMinCoinCountOfValue函数就能解决硬币找零问题。没有理解为什么还要套个getMinCoinCountLoop函数","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538693,"discussion_content":"getMinCoinCountOfValue本身的代码是一个回溯的策略，每一次递归还需要使用getMinCoinCountLoop来做一个排列组合枚举这种情况下的完整组合，确保所有的情况都被计算进来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639488096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311664,"user_name":"Geek_b302cc","can_delete":false,"product_type":"c1","uid":2193752,"ip_address":"","ucode":"DB06F7C13C9748","user_header":"","comment_is_top":false,"comment_ctime":1631372480,"is_pvip":false,"replies":[{"id":"118243","content":"代码逻辑其实就是通过getMinCoinCountLoop把原来代码中直接选取看起来最好的结果替换成不断尝试可用的面额，如果一个不行就退而求其次。<br> <br>","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1639321622,"ip_address":"","comment_id":311664,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631372480","product_id":100060501,"comment_content":"希望老师能再详细讲讲贴出的贪心+回溯的代码逻辑","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538086,"discussion_content":"代码逻辑其实就是通过getMinCoinCountLoop把原来代码中直接选取看起来最好的结果替换成不断尝试可用的面额，如果一个不行就退而求其次。\n \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639321623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302159,"user_name":"Menoetius","can_delete":false,"product_type":"c1","uid":2105718,"ip_address":"","ucode":"86232257CB1EF5","user_header":"https://static001.geekbang.org/account/avatar/00/20/21/76/d0d55d60.jpg","comment_is_top":false,"comment_ctime":1626101274,"is_pvip":false,"replies":[{"id":"112095","content":"k和i应该不是一直相等的。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1630215756,"ip_address":"","comment_id":302159,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626101274","product_id":100060501,"comment_content":"&#47;&#47; k位置已经排列好 int t = values[k]; values[k] = values[i]; values[i]=t;<br>&#47;&#47; 回溯 t = values[k]; values[k] = values[i]; values[i]=t;<br>老师你好，请问上面两段代码中的k和i的值不是一直相等的吗，既然相等，又怎么起到重新排列组合的作用？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523198,"discussion_content":"k和i应该不是一直相等的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630215756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292566,"user_name":"哦吼掉了","can_delete":false,"product_type":"c1","uid":1232599,"ip_address":"","ucode":"1F89B1BA1EEF52","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/d7/8168e1bf.jpg","comment_is_top":false,"comment_ctime":1620879730,"is_pvip":true,"replies":[{"id":"108595","content":"这个实现没有问题。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1624693486,"ip_address":"","comment_id":292566,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1620879730","product_id":100060501,"comment_content":"自己重新写了一版Java，欢迎拍砖。<br>  &#47;&#47; 找零钱: 有K中不同币值的硬币，个数不限，如何使用最少的硬币凑出X元？ 返回所需硬币数<br>    private static void chargeMoney() {<br>&#47;&#47;        int total = 11;<br>&#47;&#47;        int[] coins = {3, 5};<br>        int total = 14;<br>        int[] coins = {1, 7, 10};<br>        &#47;&#47; 币种:{3,5} 换11元最少用多少硬币<br>        &#47;&#47; 币种:{1,7,10} 换14元最少用多少硬币<br>        coins = Arrays.stream(coins).boxed().sorted(Comparator.comparingInt(Integer::intValue).reversed()).mapToInt(Integer::valueOf).toArray();<br>        int count = doCharge(total, coins, 0);<br>        System.out.println(count);<br>    }<br><br>    &#47;**<br>     * 换零钱  把total元兑换成硬币<br>     *<br>     * @param total        需要兑换的金额<br>     * @param coins        币种金额列表<br>     * @param curCoinIndex 当前兑换的币种<br>     * @return<br>     *&#47;<br>    private static int doCharge(int total, int[] coins, int curCoinIndex) {<br>        int coin = coins[curCoinIndex];<br><br>        if (total &lt; coins[curCoinIndex]) {<br>            return -1;<br>        }<br><br>        int maxCharge = total &#47; coin;<br>        int change = total % coin;<br><br>        if (change == 0) {<br>            System.out.println(String.format(&quot;已兑换:%d*[%d元币],剩余0元.&quot;, maxCharge, coin));<br>            return maxCharge;<br>        }<br><br>        &#47;&#47; 使用下一个币种进行兑换,能兑换则累加返回使用币数量;兑换不了则当前币种少兑换一张,然后进行下一币种兑换;<br>        int otherCharge = doCharge(change, coins, curCoinIndex + 1);<br><br>        if (otherCharge != -1) {<br>            System.out.println(String.format(&quot;已兑换:%d*[%d元币],剩余%d元.继续使用币种[%d元]兑换成功.&quot;, maxCharge, coin, change, coins[curCoinIndex + 1]));<br>            return otherCharge + maxCharge;<br>        } else {<br>            System.out.println(String.format(&quot;已兑换:%d*[%d元币],剩余%d元.继续使用币种[%d元]兑换失败.打算少用一张[%d元]&quot;, maxCharge - 1, coin, total - (maxCharge - 1) * coin, coins[curCoinIndex + 1], coin));<br>            maxCharge = maxCharge - 1;<br>            change = total - maxCharge * coin;<br>            return maxCharge + doCharge(change, coins, curCoinIndex + 1);<br>        }<br>    }","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519878,"discussion_content":"这个实现没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624693486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292052,"user_name":"3.141516","can_delete":false,"product_type":"c1","uid":1013309,"ip_address":"","ucode":"34AF71B02692F3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/3d/8120438b.jpg","comment_is_top":false,"comment_ctime":1620656512,"is_pvip":true,"replies":[{"id":"108599","content":"恩，这个应该没有问题。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1624693518,"ip_address":"","comment_id":292052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1620656512","product_id":100060501,"comment_content":"求全排列问题就用到了回溯算法的思想，首先交换数组元素，在求解了子问题之后，需要回来，把数组元素在换回来。然后进行下一轮求解。代码如下<br><br>def full_permutations_recursive(array, i):<br>    if i == len(array):<br>        print(array)<br>    else:<br>        for j in range(i, len(array)):<br>            swap(array, i, j)<br>            full_permutations_recursive(array, i + 1)<br>            swap(array, i, j)","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519658,"discussion_content":"恩，这个应该没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624693518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285077,"user_name":"嘻哈二重性","can_delete":false,"product_type":"c1","uid":1207853,"ip_address":"","ucode":"89FAD507691FEA","user_header":"https://static001.geekbang.org/account/avatar/00/12/6e/2d/df5ec0bf.jpg","comment_is_top":false,"comment_ctime":1616600182,"is_pvip":false,"replies":[{"id":"104557","content":"切实可行的另一种解法。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1618231026,"ip_address":"","comment_id":285077,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616600182","product_id":100060501,"comment_content":"用这种方式实现了下<br>    public static void main(String[] args) {<br>        System.out.println(YingBi.getMinCoinCountOfValue(14,new int[]{1,3,10},2));<br>    }<br><br><br>    public static int getMinCoinCountOfValue(int curTotal,int[] values,int index){<br>        int curCount = 0;<br>        int total = curTotal;<br>        for (int i=index;i&gt;=0;i--){<br><br>            int value =  values[i];<br>            int  count = total &#47; value;<br>            total = total % value;<br><br>            if (total==0){<br>                return curCount+count;<br>            }<br>            &#47;&#47;获取剩余的最优解<br>            int minCoinCountOfValue = getMinCoinCountOfValue(total, values, i - 1);<br>            &#47;&#47;获取比当前小的最优解<br>            int thenCoinCountOfValue = getMinCoinCountOfValue(curTotal, values, i - 1);<br><br>            &#47;&#47;获取比当前小的最优解 比 当前解小 ，就取这个<br>            if (thenCoinCountOfValue&lt;(curCount+count+minCoinCountOfValue)){<br>                return thenCoinCountOfValue;<br>            }<br><br>            &#47;&#47;如果剩余的返回的数字大于0，说明没有剩余，而且更小的也没有最优解，这个就是解<br>            if (minCoinCountOfValue&gt;0){<br>                return curCount+count+minCoinCountOfValue;<br>            }<br>            &#47;&#47;如果没有解，并且 使用数字大于0，就回溯1位<br>            if (count&gt;0){<br>                total = total+value;<br>                curCount = curCount-1;<br>            }<br>        }<br>        return -1;<br>    }<br>","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517579,"discussion_content":"切实可行的另一种解法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618231026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285039,"user_name":"北顾-岛城","can_delete":false,"product_type":"c1","uid":1433568,"ip_address":"","ucode":"54ECB3E5E4073A","user_header":"https://static001.geekbang.org/account/avatar/00/15/df/e0/ce671992.jpg","comment_is_top":false,"comment_ctime":1616588346,"is_pvip":false,"replies":[{"id":"104560","content":"嗯，思路是类似的。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1618231058,"ip_address":"","comment_id":285039,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616588346","product_id":100060501,"comment_content":"发现了另一种解法dfs，好像跟老师的类似<br>class Solution {<br>    private int[] coins;<br>    private int ans = Integer.MAX_VALUE;<br>    public int coinChange(int[] coins, int amount) {<br>        this.coins = coins;<br>        Arrays.sort(this.coins);    &#47;&#47; 先排序<br>        dfs(this.coins.length - 1, amount, 0);  &#47;&#47; 从价值最大的硬币开始深搜<br>        return ans == Integer.MAX_VALUE ? -1 : ans;<br>    }<br><br>    private void dfs(int index, int amount, int cnt) {<br>        if (amount == 0) {<br>            ans = Math.min(ans, cnt);<br>            return;<br>        }<br>        if (index &lt; 0) return;<br>        for (int i = amount &#47; coins[index]; i &gt;= 0 &amp;&amp; i + cnt &lt; ans; --i) { &#47;&#47; 通过判断条件剪枝<br>            dfs(index - 1, amount - i * coins[index], cnt + i);<br>        }<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517561,"discussion_content":"嗯，思路是类似的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618231058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285037,"user_name":"北顾-岛城","can_delete":false,"product_type":"c1","uid":1433568,"ip_address":"","ucode":"54ECB3E5E4073A","user_header":"https://static001.geekbang.org/account/avatar/00/15/df/e0/ce671992.jpg","comment_is_top":false,"comment_ctime":1616587280,"is_pvip":false,"replies":[{"id":"104561","content":"没问题，这种经典问题是需要掌握的。置顶推荐。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1618231080,"ip_address":"","comment_id":285037,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616587280","product_id":100060501,"comment_content":"回溯算法的经典问题：N皇后问题。<br>n皇后问题是将n个皇后放置在n*n的棋盘上，皇后彼此之间不能相互攻击(任意两个皇后不能位于同一行，同一列，同一斜线)。<br>给定一个整数n，返回所有不同的n皇后问题的解决方案。<br><br>public class Solution {<br>    private List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;List&lt;String&gt;&gt;();<br>    private int[] queens;   &#47;&#47; 存储皇后位置<br>    private boolean[] cols;<br>    private boolean[] upDiagonal;<br>    private boolean[] downDiagonal;<br>    private int n;<br>    &#47;*<br>     * @param n: The number of queens<br>     * @return: All distinct solutions<br>     *&#47;<br>    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {<br>        queens = new int[n];<br>        cols = new boolean[n];<br>        upDiagonal = new boolean[2 * n - 1];<br>        downDiagonal = new boolean[2 * n];<br>        this.n = n;<br>        search(0);<br>        return ans;<br>    }<br><br>    private void search(int row) {<br>        if (row == n) {<br>            List&lt;String&gt; solution = drawSolution();<br>            ans.add(solution);<br>            return;<br>        }<br>        for (int i = 0; i &lt; n; ++i) {<br>            if (!cols[i] &amp;&amp; !upDiagonal[row + i] &amp;&amp; !downDiagonal[row - i + n]) {<br>                queens[row] = i;<br>                cols[i] = true;<br>                upDiagonal[row + i] = true;<br>                downDiagonal[row - i + n] = true;<br>                search(row + 1);<br>                &#47;&#47; 回溯结束时无需恢复queens[row]位置，因为会覆盖<br>                cols[i] = false;<br>                upDiagonal[row + i] = false;<br>                downDiagonal[row - i + n] = false;<br>            }<br>        }<br>    }<br><br>    private List&lt;String&gt; drawSolution() {<br>        List&lt;String&gt; solution = new ArrayList&lt;String&gt;();<br>        for (int i = 0; i &lt; n; ++i) {<br>            char[] row = new char[n];<br>            Arrays.fill(row, &#39;.&#39;);<br>            row[queens[i]] = &#39;Q&#39;;<br>            solution.add(new String(row));<br>        }<br>        return solution;<br>    }<br>}<br><br>","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517559,"discussion_content":"没问题，这种经典问题是需要掌握的。置顶推荐。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618231080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285021,"user_name":"北顾-岛城","can_delete":false,"product_type":"c1","uid":1433568,"ip_address":"","ucode":"54ECB3E5E4073A","user_header":"https://static001.geekbang.org/account/avatar/00/15/df/e0/ce671992.jpg","comment_is_top":false,"comment_ctime":1616581453,"is_pvip":false,"replies":[{"id":"104563","content":"可以考虑加上注释，谢谢建议。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1618231099,"ip_address":"","comment_id":285021,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616581453","product_id":100060501,"comment_content":"感觉我好蠢，回溯那个版本的代码看半天才看懂。老师要不要加上一下说明，getMinCoinCountLoop是用来尝试不同的排列组合的函数，GetMinCoinCountOfValue是用来求当前排列下的最小硬币数的函数","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517553,"discussion_content":"可以考虑加上注释，谢谢建议。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618231099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280462,"user_name":"Geek_531e37","can_delete":false,"product_type":"c1","uid":2299399,"ip_address":"","ucode":"1988FE31CCC290","user_header":"","comment_is_top":false,"comment_ctime":1614223197,"is_pvip":false,"replies":[{"id":"102849","content":"谢谢反馈，我会考虑改进这一部分，稍后在正文中做出改进。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1615801772,"ip_address":"","comment_id":280462,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1614223197","product_id":100060501,"comment_content":"优化后的代码是在看不懂，一个注释都没有，最关键过度的这一步怎么就一笔带过？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516105,"discussion_content":"谢谢反馈，我会考虑改进这一部分，稍后在正文中做出改进。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615801772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278340,"user_name":"新手","can_delete":false,"product_type":"c1","uid":1238298,"ip_address":"","ucode":"A691F17A9CE49A","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/1a/788885ae.jpg","comment_is_top":false,"comment_ctime":1612885138,"is_pvip":false,"replies":[{"id":"101319","content":"没问题。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1613370279,"ip_address":"","comment_id":278340,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612885138","product_id":100060501,"comment_content":"回溯版本的Rust实现：<br><br>fn get_min_coin_count(values: &amp;[i32], total: i32) -&gt; i32 {<br>    if values.is_empty() {<br>        return -1;<br>    }<br><br>    let current_value = values[0];<br>    let rest_values = &amp;values[1..];<br>    let max_count = total &#47; current_value;<br><br>    for count in (0..=max_count).rev() {<br>        let rest = total - count * current_value;<br>        if rest == 0 {<br>            return count;<br>        }<br><br>        let rest_count = get_min_coin_count(rest_values, rest);<br>        if rest_count != -1 {<br>            return count + rest_count;<br>        }<br>    }<br><br>    -1<br>}<br><br>fn main() {<br>    let values = [5, 3];<br>    let total = 11;<br>    let count = get_min_coin_count(&amp;values, total);<br>    println!(&quot;{}&quot;, count);<br>}<br>","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515352,"discussion_content":"没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613370279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277191,"user_name":"Casper","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1612314403,"is_pvip":true,"replies":[{"id":"101320","content":"没问题。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1613370290,"ip_address":"","comment_id":277191,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1612314403","product_id":100060501,"comment_content":"我自己理解后的C++版本：<br>#include &lt;iostream&gt;<br>using namespace std;<br><br>int GetMinCoin(int total, int* values, int valuesCount, int idx) {<br>\tif (idx == valuesCount) return INT_MAX;<br><br>\tint currentCoin = values[idx];<br>\tint minResult = INT_MAX;<br>\tint usedCount = total &#47; currentCoin;<br>\tfor (int count = usedCount; count &gt;= 0; --count) {<br>\t\tint rest = total % currentCoin;<br>\t\tif (rest == 0) {<br>\t\t\tminResult = min(minResult, count);<br>\t\t\tbreak;<br>\t\t}<br><br>\t\tint restCount = GetMinCoin(rest, values, valuesCount, idx + 1);<br>\t\tif (restCount == INT_MAX) {<br>\t\t\tif (count == 0) break;  &#47;&#47; 已经遍历完, 直接跳出循环<br><br>\t\t\tcontinue;  &#47;&#47; 减少一个当前最大值, 继续进行<br>\t\t}<br><br>\t\tminResult = min(minResult, count + restCount);<br>\t}<br>\treturn minResult;<br>}<br><br>int GetCoin(int total, int* values, int valuesCount) {<br>\tint minResult = INT_MAX;<br>\tfor (int idx = 0; idx &lt; valuesCount; ++idx) {<br>\t\tint count = GetMinCoin(total, values, valuesCount, idx);<br>\t\tminResult = min(minResult, count);<br>\t}<br>\treturn minResult;<br>}<br><br>int main() {<br>\tint total = 14;<br>\tint values[] = {2, 12, 6 , 1 };<br>\tint valuesCount = sizeof(values) &#47; sizeof(int);<br>\tcout&lt;&lt; GetCoin(total, values, valuesCount) &lt;&lt; endl;<br>\treturn 0;<br>}","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514954,"discussion_content":"没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613370290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2914270,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/77/de/4894a700.jpg","nickname":"extern","note":"","ucode":"0B2798165EAC77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551216,"discussion_content":"都是基于排好序的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644930442,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022129,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","nickname":"Casper","note":"","ucode":"69282EB175B48E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348394,"discussion_content":"修正: 将循环中的 rest 计算值改为: rest = total - currentCoin * count;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612533682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022129,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","nickname":"Casper","note":"","ucode":"69282EB175B48E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348384,"discussion_content":"{5,4,3} 拼凑 {14} 的结果是错误的，哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612531925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277155,"user_name":"Casper","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1612277734,"is_pvip":true,"replies":[{"id":"101321","content":"这里的作用是交换排列顺序，实现不同的排列。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1613370297,"ip_address":"","comment_id":277155,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612277734","product_id":100060501,"comment_content":"老师的C++代码中, 没有明白<br>int t = values[k];<br>values[k] = values[i];<br>values[i]=t; <br>这三句的作用，我在实际操作时, 注释掉前后这3句, 结果依然是正确的, 感觉这几句是多余的，希望老师帮忙解答一下。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514942,"discussion_content":"这里的作用是交换排列顺序，实现不同的排列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613370297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262953,"user_name":"燕子","can_delete":false,"product_type":"c1","uid":1414467,"ip_address":"","ucode":"513EF413B30A25","user_header":"https://static001.geekbang.org/account/avatar/00/15/95/43/b368fd59.jpg","comment_is_top":false,"comment_ctime":1605920647,"is_pvip":false,"replies":[{"id":"95661","content":"不一定，其实肯定存在可以通过简单粗暴的贪心法解决的问题，只不过很多问题稍微复杂一点的确很少有可以通过单纯的贪心算法解决的。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1606230808,"ip_address":"","comment_id":262953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605920647","product_id":100060501,"comment_content":"是不是可以这么说，单纯使用贪心算法的场景基本是不存在的，至少要和回溯一起，才能真正解决实际问题？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510047,"discussion_content":"不一定，其实肯定存在可以通过简单粗暴的贪心法解决的问题，只不过很多问题稍微复杂一点的确很少有可以通过单纯的贪心算法解决的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606230808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259459,"user_name":"THROW","can_delete":false,"product_type":"c1","uid":1112141,"ip_address":"","ucode":"A3C089A8F5F941","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/4d/4b748ff1.jpg","comment_is_top":false,"comment_ctime":1604732450,"is_pvip":false,"replies":[{"id":"95671","content":"没有问题，顶上去。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1606230954,"ip_address":"","comment_id":259459,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604732450","product_id":100060501,"comment_content":"    private static int compute(int[] array, int target) {<br>        if (target == 0) {<br>            return 0;<br>        }<br>        if (array.length &lt;= 0) {<br>            return -1;<br>        }<br>        int maxOne = array[0];<br>        int used = target &#47; maxOne;<br>        int left = target % maxOne;<br>        array = Arrays.copyOfRange(array, 1, array.length);<br>        while (used &gt; 0) {<br>            int after = compute(array, left);<br>            if (after == -1) {<br>                used--;<br>                left += maxOne;<br>            } else {<br>                System.out.println(&quot;使用面值&quot; + maxOne + &quot;的硬币&quot; + used + &quot;个&quot;);<br>                return used + after;<br>            }<br>        }<br>        return -1;<br>    }","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508941,"discussion_content":"没有问题，顶上去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606230954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256158,"user_name":"qxz","can_delete":false,"product_type":"c1","uid":2217629,"ip_address":"","ucode":"4676DCB82B37DB","user_header":"https://static001.geekbang.org/account/avatar/00/21/d6/9d/dbdae8c7.jpg","comment_is_top":false,"comment_ctime":1603542308,"is_pvip":false,"replies":[{"id":"93653","content":"这里的回溯代码里面其实就是用优化过的方案求了全排列。然后每个枚举。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1603904237,"ip_address":"","comment_id":256158,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603542308","product_id":100060501,"comment_content":"这回溯算法的参考代码比较难理解。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507947,"discussion_content":"这里的回溯代码里面其实就是用优化过的方案求了全排列。然后每个枚举。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603904237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254657,"user_name":"Everlaa","can_delete":false,"product_type":"c1","uid":1708271,"ip_address":"","ucode":"9B4FFFABD62B07","user_header":"https://static001.geekbang.org/account/avatar/00/1a/10/ef/4c9b2383.jpg","comment_is_top":false,"comment_ctime":1603163653,"is_pvip":false,"replies":[{"id":"93118","content":"感谢你的肯定！一般来说ACM竞赛使用C&#47;C++比较多，但是为了方便大家的理解，提供Java的实现也是顺应趋势。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1603380468,"ip_address":"","comment_id":254657,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603163653","product_id":100060501,"comment_content":"两种语言实现，棒棒哒","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507475,"discussion_content":"感谢你的肯定！一般来说ACM竞赛使用C/C++比较多，但是为了方便大家的理解，提供Java的实现也是顺应趋势。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603380468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254258,"user_name":"落曦","can_delete":false,"product_type":"c1","uid":1475039,"ip_address":"","ucode":"C70F7E2EDC3FD7","user_header":"https://static001.geekbang.org/account/avatar/00/16/81/df/066ffab3.jpg","comment_is_top":false,"comment_ctime":1603092544,"is_pvip":false,"replies":[{"id":"93123","content":"是的，贪心算法本身的局限性太大，它只能解决局部最优解的问题。如果非得使用贪心算法解决更大规模的问题（比如需要考虑整体最优的情况的题目），那么就必须辅以辅助函数、辅助算法等形式来解决问题。这么做其实得不偿失，针对不同类型的问题，考虑使用不同的算法或思想解决，有的放矢，才是上上策。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1603380868,"ip_address":"","comment_id":254258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603092544","product_id":100060501,"comment_content":"我们上课老师和我们讲贪心比dp还难，很多dp的题目有板子，而贪心不同的问题之间跨度非常的大","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507337,"discussion_content":"是的，贪心算法本身的局限性太大，它只能解决局部最优解的问题。如果非得使用贪心算法解决更大规模的问题（比如需要考虑整体最优的情况的题目），那么就必须辅以辅助函数、辅助算法等形式来解决问题。这么做其实得不偿失，针对不同类型的问题，考虑使用不同的算法或思想解决，有的放矢，才是上上策。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603380868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254237,"user_name":"帽子狗","can_delete":false,"product_type":"c1","uid":2106663,"ip_address":"","ucode":"51596F366AF068","user_header":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","comment_is_top":false,"comment_ctime":1603089125,"is_pvip":false,"replies":[{"id":"93416","content":"DP函数就是状态转移方程的函数化。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1603700858,"ip_address":"","comment_id":254237,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603089125","product_id":100060501,"comment_content":"dp本质还是状态转移方程<br>dp(n) = min(dp(n-c[i])+1)  i &gt;=0 &amp;&amp; i &lt; c.length - 1","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507327,"discussion_content":"DP函数就是状态转移方程的函数化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603700858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250688,"user_name":"AshinInfo","can_delete":false,"product_type":"c1","uid":1299511,"ip_address":"","ucode":"098F5C74A37009","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/37/aa152ddb.jpg","comment_is_top":false,"comment_ctime":1601196217,"is_pvip":false,"replies":[{"id":"91920","content":"这段代码多余，虽然它的执行与否不影响最终结果，但显然多余且没有必要，已删除。感谢你认真的发现和反馈！","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1601557235,"ip_address":"","comment_id":250688,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601196217","product_id":100060501,"comment_content":"第二段的代码<br>getMinCoinCountLoop，这个方法有点无法理解<br>minCount = min(minCount, GetMinCoinCountOfValue(total, values, 0, valueCount));        minCount = min(minCount, GetMinCoinCountLoop(total, values, valueCount, k + 1)); &#47;&#47; 考虑后一位<br>这里为什么这么写，感觉如果这样写，只要最后一行赋值即可，第一行赋值没有任何意义","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506260,"discussion_content":"这段代码多余，虽然它的执行与否不影响最终结果，但显然多余且没有必要，已删除。感谢你认真的发现和反馈！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601557235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250517,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1601112794,"is_pvip":false,"replies":[{"id":"91921","content":"正解，顶上去。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1601557984,"ip_address":"","comment_id":250517,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1601112794","product_id":100060501,"comment_content":"每种硬币有[0,maxCount]个之间的选择，选择了第一种硬币后，就递归到下一种选择即可。<br><br>int getMinCoinCountLoop(int total, int[] values, int startIndex, int currentCount) {<br>    int minCount = Integer.MAX_VALUE;<br>    if (startIndex == values.length) {<br>      return minCount;<br>    }<br><br>    int maxCurrentCoinCount = total &#47; values[startIndex];<br>    if (maxCurrentCoinCount * values[startIndex] == total) {<br>      minCount = maxCurrentCoinCount;<br>      return minCount + currentCount;<br>    }<br><br>    for (int i = 0;i &lt;= maxCurrentCoinCount;i++) {<br>      int restValue = total - i * values[startIndex];<br>      minCount = Math.min(minCount, getMinCoinCountLoop(restValue, values,<br>          startIndex+1,<br>          currentCount+i));<br>    }<br><br>    return minCount;<br>  }","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506225,"discussion_content":"正解，顶上去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601557984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1317749,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1b/75/daa7c5cf.jpg","nickname":"一只小地鼠","note":"","ucode":"C4FBD8AA223E86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341725,"discussion_content":"迭代不好吗，为什么要递归","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610506021,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264408,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4b/18/8b6482d9.jpg","nickname":"谭谭","note":"","ucode":"5E925BD1AC120E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328721,"discussion_content":"[1,2,5]\n11 无法通过！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606217737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250493,"user_name":"Noah","can_delete":false,"product_type":"c1","uid":1473744,"ip_address":"","ucode":"30748FB1FFB4AD","user_header":"https://static001.geekbang.org/account/avatar/00/16/7c/d0/eec67c84.jpg","comment_is_top":false,"comment_ctime":1601102867,"is_pvip":true,"replies":[{"id":"91922","content":"getMinCoinCountOfValue有点问题并不能求出全排列，充分测试几个用例就能知道了。不过你可以把两个函数合并自己写一个直接生成全排列的版本也是可以的。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1601558886,"ip_address":"","comment_id":250493,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1601102867","product_id":100060501,"comment_content":"老师，您好，回溯代码部分的int getMinCoinCountOfValue(int total, int[] values, int valueIndex)；已经对硬币可能的情况做了全排列了，我简单测试了几个用例，也都可以直接求出最小的硬币数；所以int getMinCoinCountLoop(int total, int[] values, int k) ;这个函数的作用是什么？这个函数看的有点困惑","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506222,"discussion_content":"getMinCoinCountOfValue有点问题并不能求出全排列，充分测试几个用例就能知道了。不过你可以把两个函数合并自己写一个直接生成全排列的版本也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601558886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1473744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7c/d0/eec67c84.jpg","nickname":"Noah","note":"","ucode":"30748FB1FFB4AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310170,"discussion_content":"谢谢老师,后面又试了下其他的例子,getMinCoinCountOfValue(int total, int[] values, int valueIndex){...}无法求出所有可能的组合,其中一段代码:\nif (rest == 0) {\n\tminResult = Math.min(minResult, count);\n\tbreak;\n}\n由于break的原因,每次得到一个组合的解就会退出循环,无法继续求解,在values=[1,7,10],total=11的情况下,在getMinCoinCountOfValue(){...}直接调用getMinCoinCountOfValue(int total, int[] values, int valueIndex)得到的答案是11;这里将break改成continue后,这个问题就得到了解决,不在是得到一个组合方案就退出循环了,而是比较所有的组合,从而输出最少的硬币组合数.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601654668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250479,"user_name":"Noah","can_delete":false,"product_type":"c1","uid":1473744,"ip_address":"","ucode":"30748FB1FFB4AD","user_header":"https://static001.geekbang.org/account/avatar/00/16/7c/d0/eec67c84.jpg","comment_is_top":false,"comment_ctime":1601094960,"is_pvip":true,"replies":[{"id":"91902","content":"函数的功能是为求解原问题服务的，参数在正文中有所提及。如果你还对某些特定的参数或变量不太清楚，可以留言，我为你解答。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1601529736,"ip_address":"","comment_id":250479,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1601094960","product_id":100060501,"comment_content":"老师能不能对回溯那一部分的代码多加一点注释,例如:函数的功能,参数的意思等,现在的代码看着有点迷","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506215,"discussion_content":"函数的功能是为求解原问题服务的，参数在正文中有所提及。如果你还对某些特定的参数或变量不太清楚，可以留言，我为你解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601529736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1473744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7c/d0/eec67c84.jpg","nickname":"Noah","note":"","ucode":"30748FB1FFB4AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310175,"discussion_content":"谢谢老师,我又回过头来看了一遍,这次看懂了,之前对getMinCoinCountLoop这个函数的作用感到很困惑, 原因是对全排列的回溯代码写法不是很了解.(PS:如果对于全排列回溯法不不熟悉的同学可以看看leetcode上的一个介绍:https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/).\n\ngetMinCoinCountLoop这个函数实现的功能是对硬币数组values进行了一个全排列,在每一次生排列的时候,调用getMinCoinCountOfValue针对这个排列生成硬币的组合数量.\n\n老师的getMinCoinCountOfValue(int total, int[] values, int valueIndex){...}函数其实写的很完善了,稍微改一下就能直接求出硬币数, 这里使用getMinCoinCountLoop函数给人一种绕了一个弯子的感觉. 老师如果能说明下getMinCoinCountLoop是解决了getMinCoinCountOfValue(int total, int[] values, int valueIndex){...}函数中哪里的不足可能会更清晰一点.\n老师的文章里有这样一句话,&#34;改进后的算法实现在之前的基础上增加上了一个回溯过程。简单地说就是多了一个递归，不断尝试用更少的当前面值来拼凑&#34;. 我想这是对getMinCoinCountOfValue(int total, int[] values, int valueIndex){...} 函数里的for循环部分的描述,但是在getMinCoinCountLoop这里面也用到了回溯,所以第一次看的时候,就会感到困惑,回溯到底是在哪一部分发挥作用,这些是我在第一次看(有点菜)的时候的一些感受,不知道有没有同学和我一样啊,写下这些,希望给可能遇到类似问题的人一些参考.\n最后,如果有什么说的不对的地方,欢迎老师指正.\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601656885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1059121,"avatar":"https://static001.geekbang.org/account/avatar/00/10/29/31/e85391c0.jpg","nickname":"Charles","note":"","ucode":"230914786D1E62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1473744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7c/d0/eec67c84.jpg","nickname":"Noah","note":"","ucode":"30748FB1FFB4AD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":331469,"discussion_content":"我也发现了这个问题，根本搞不清楚这两个函数之间道理有什么联系，两个是如何相互协同作用的，作者根本不解释，也不做函数注释，如果说一些简单的参数能够通过代码看出来，不用注释，但是涉及到某些参数和逻辑根本看不明白，也不注释，就不是好的代码规范了。\n况且，通过评论区，我发现不止一个同学有这个问题，好多同学都有反馈，作者也看到了，好几个月过去了，却仍然没有做任何改进。\n如果说，这是自己的开源项目，自己的作品，跟其他人无关，那也就罢了。\n但是，在这里拿来教学，且作为商品为学生服务，仍然这样，就说不过去了，且学生在询问很多次这两个函数的作用后，仍然无动于衷，很明显过分了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606879388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":310175,"ip_address":""},"score":331469,"extra":""}]},{"author":{"id":2121147,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Mluia3Ebv2LYrLcPBCw0jTINxIricFeiaaE9Q8d1MNEktWEiaiavOicxuTtsaQ8D3l4To5ca6Wh40ibFsz5f9DFJdEKtA/132","nickname":"skrbug","note":"","ucode":"92595EB0ABCE8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335136,"discussion_content":"原来不止我一个人，我看了半天都没太明白什么意思，谢谢Noah同学提供的资料","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608103580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250039,"user_name":"ymw","can_delete":false,"product_type":"c1","uid":1404266,"ip_address":"","ucode":"332D31EFCA5331","user_header":"https://static001.geekbang.org/account/avatar/00/15/6d/6a/b65db36c.jpg","comment_is_top":false,"comment_ctime":1600913744,"is_pvip":false,"replies":[{"id":"91924","content":"如果将getMinCoinCountOfValue改进一下也可以达到这个效果。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1601559996,"ip_address":"","comment_id":250039,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600913744","product_id":100060501,"comment_content":"如果硬币面值的数组是从大到小排列的，那么不使用getMinCoinCountLoop方法，只用getMinCoinCountOfValue方法是否也能求出最小硬币数呢","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506113,"discussion_content":"如果将getMinCoinCountOfValue改进一下也可以达到这个效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601559996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249348,"user_name":"jplusztx","can_delete":false,"product_type":"c1","uid":1661339,"ip_address":"","ucode":"FF5A887BB073E4","user_header":"https://static001.geekbang.org/account/avatar/00/19/59/9b/b16a0482.jpg","comment_is_top":false,"comment_ctime":1600603596,"is_pvip":false,"replies":[{"id":"91501","content":"这里使用了“原地交换”的方式，生成所有的价值序列的排列组合，目的是为了枚举出所有可能的解。相较于每次都生成新的组合数组，原地交换的方式代码执行效率会相对高一点，这是因为不需要每次组合都申请新的内存空间。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600699017,"ip_address":"","comment_id":249348,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1600603596","product_id":100060501,"comment_content":"我看了很久还是没理解为什么getMinCoinCountLoop方法中的i和k需要先交换位置，请老师解惑","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505904,"discussion_content":"这里使用了“原地交换”的方式，生成所有的价值序列的排列组合，目的是为了枚举出所有可能的解。相较于每次都生成新的组合数组，原地交换的方式代码执行效率会相对高一点，这是因为不需要每次组合都申请新的内存空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600699017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1661339,"avatar":"https://static001.geekbang.org/account/avatar/00/19/59/9b/b16a0482.jpg","nickname":"jplusztx","note":"","ucode":"FF5A887BB073E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308153,"discussion_content":"在我实际运行中发现是否交换位置好像对最终结果没有影响。是否是因为原题目测试数据会有无序呢？这里我没做尝试，我自己设立的测试数据全是使用由大到小排列的数组。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600856930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249123,"user_name":"Ethan Liu","can_delete":false,"product_type":"c1","uid":1070043,"ip_address":"","ucode":"231F944F7CD56A","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","comment_is_top":false,"comment_ctime":1600438966,"is_pvip":true,"replies":[{"id":"91498","content":"原问题想求的其实是整体最优。但显然在这里，单纯的贪心策略只能实现局部最优，因此是无法获得正确结果的。<br><br>所以是，不满足题意。这里用例子说明了单纯的贪心算法的局限性。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600698555,"ip_address":"","comment_id":249123,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600438966","product_id":100060501,"comment_content":"老师，只使用贪心得到的5，5算是局部最优解吗？都不满足题意啊","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505840,"discussion_content":"原问题想求的其实是整体最优。但显然在这里，单纯的贪心策略只能实现局部最优，因此是无法获得正确结果的。\n\n所以是，不满足题意。这里用例子说明了单纯的贪心算法的局限性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600698555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248738,"user_name":"石维康","can_delete":false,"product_type":"c1","uid":1067564,"ip_address":"","ucode":"E39ED8416B2C01","user_header":"https://static001.geekbang.org/account/avatar/00/10/4a/2c/f8451d77.jpg","comment_is_top":false,"comment_ctime":1600277897,"is_pvip":false,"replies":[{"id":"91504","content":"这里使用了“原地交换”的技巧，生成所有的价值序列的排列组合，目的是为了枚举出所有可能的解。相较于每次都生成新的组合数组，原地交换的方式代码执行效率会相对会高一丢丢，这是因为不需要每次组合都申请新的内存空间。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600699191,"ip_address":"","comment_id":248738,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600277897","product_id":100060501,"comment_content":"    for (int i = k; i &lt;= valueCount - 1; i++) {<br>        &#47;&#47; k位置已经排列好<br>        int t = values[k];<br>        values[k] = values[i];<br>        values[i]=t;<br>        minCount = Math.min(minCount, getMinCoinCountOfValue(total, values, 0));<br>        minCount = Math.min(minCount, getMinCoinCountLoop(total, values, k + 1)); &#47;&#47; 考虑后一位<br><br>        &#47;&#47; 回溯<br>        t = values[k];<br>        values[k] = values[i];<br>        values[i]=t;<br>    }<br>请问这段代码的功能可以解释一下吗？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505729,"discussion_content":"这里使用了“原地交换”的技巧，生成所有的价值序列的排列组合，目的是为了枚举出所有可能的解。相较于每次都生成新的组合数组，原地交换的方式代码执行效率会相对会高一丢丢，这是因为不需要每次组合都申请新的内存空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600699191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248492,"user_name":"Geek_jianghao","can_delete":false,"product_type":"c1","uid":1584112,"ip_address":"","ucode":"B3A8C8B0E04294","user_header":"https://static001.geekbang.org/account/avatar/00/18/2b/f0/0193f6ff.jpg","comment_is_top":false,"comment_ctime":1600179005,"is_pvip":true,"replies":[{"id":"91291","content":"同学你好，本专栏只提供C++和Java两个语言版本，事实上这已经是老师为了让更多同学易于学习而做出的调整。如果哪里有疑问，可以在留言区随时向老师提问。","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1600262404,"ip_address":"","comment_id":248492,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1600179005","product_id":100060501,"comment_content":"老师，请问有没有python版本的呢？可不可以提供一个github，对应主流的几种不同语言的具体实现","like_count":0,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505662,"discussion_content":"同学你好，本专栏只提供C++和Java两个语言版本，事实上这已经是老师为了让更多同学易于学习而做出的调整。如果哪里有疑问，可以在留言区随时向老师提问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600262404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248325,"user_name":"arch","can_delete":false,"product_type":"c1","uid":1078931,"ip_address":"","ucode":"A69EBFE0520B85","user_header":"https://static001.geekbang.org/account/avatar/00/10/76/93/64ed7385.jpg","comment_is_top":false,"comment_ctime":1600104487,"is_pvip":true,"replies":[{"id":"91298","content":"是的，理论上是可行的，能否尝试一下写出算法代码？","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600268725,"ip_address":"","comment_id":248325,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600104487","product_id":100060501,"comment_content":"回溯算法：最短路径问题","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505620,"discussion_content":"是的，理论上是可行的，能否尝试一下写出算法代码？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600268725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248285,"user_name":"偶然~zZ","can_delete":false,"product_type":"c1","uid":1445062,"ip_address":"","ucode":"84D0ACA932AC01","user_header":"https://static001.geekbang.org/account/avatar/00/16/0c/c6/934e3e4f.jpg","comment_is_top":false,"comment_ctime":1600089679,"is_pvip":false,"replies":[{"id":"91243","content":"现在代码部分做了调整，同时提供了Java实现和C++实现供大家参考。如果还有任何问题请告诉我～","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1600155592,"ip_address":"","comment_id":248285,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1600089679","product_id":100060501,"comment_content":"c++语法看不懂  ","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505607,"discussion_content":"现在代码部分做了调整，同时提供了Java实现和C++实现供大家参考。如果还有任何问题请告诉我～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600155592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1703222,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fd/36/f947c340.jpg","nickname":"Roger宇","note":"","ucode":"CBA23C01409349","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305993,"discussion_content":"不是有两种语言么？认真点看呐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600144208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}