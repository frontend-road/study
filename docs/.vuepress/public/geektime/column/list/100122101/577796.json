{"id":577796,"title":"07 | 深入理解对象的私有和静态属性","content":"<p>你好，我是石川。</p><p>在前面几讲里，我们围绕着函数式编程，从基础的输入、计算、输出讲起，到过程中可能产生的副作用，再到如何通过纯函数和不可变作为解决思路来管理副作用等等，都有了系统的了解。之后，我们又通过响应式编程和函数式编程的结合，了解了这种模式下面，如何面对未知以及基于事件变化做出响应。</p><p>从这节课开始，我们再来深入了解下 <strong>JavaScript的对象构建和面向对象的编程模式</strong>。</p><p>在<a href=\"https://time.geekbang.org/column/article/572260\">第1讲</a>里，我们第一次介绍到了对象和面向对象。对象其实就好比一个人，生来都是带有属性和功能的，比如肤色、身高等等就是我们的属性，会哭会笑这些就是我们的功能。我们作为对象和别的对象之间要产生交互，这就是面向对象的设计。那今天我们就从一个对象的创建讲起。</p><p><img src=\"https://static001.geekbang.org/resource/image/93/3f/9373c0aafa4598048e69e1797d73c93f.jpeg?wh=1920x1080\" alt=\"图片\"></p><p>在面向对象的设计中，一个对象的属性是至关重要的，因为它也决定了对象是什么、能做什么。一个对象可以有对外分享的、别人可以获取的<strong>公开属性</strong>，也有不对外暴露的、别人不可以随便获取的<strong>私有属性</strong>。</p><p>除了公开和私有属性，还有<strong>静态属性</strong>。静态属性是属于类，而不是单独属于对象的。这么解释听上去可能有些绕口，我们可以打个比方，比如说中国有14亿人口，那么“14亿人口”就是属于中国这个国家类的属性，但是我们不能说具体每一个中国人具有“14亿人口”这个属性。</p><!-- [[[read_end]]] --><p>同样地，静态属性也包含公开属性和私有属性。就好比一个公司作为一个组织类，通常为了体现规模，会公开自己有多少员工，这就是公司的<strong>公开静态属性</strong>；但是公司不会公开一些运营数据，因为这个是敏感话题，只有审计的时候或特定场合才提供，这个运营数据可能就属于<strong>私有静态属性</strong>。</p><p>目前用于创建私有属性和静态属性的支持，都是在2022年6月后，也就是在JavaScript出现后的25年，才纳入ECMAScript规范中的（但其实除了已经退役的IE浏览器外，几乎大多数主流浏览器之前都支持了这两个功能）。但是在此之前，人们就通过其它方式，试着实现类似的功能了。</p><p>今天这节课，我们就来看看它们实现的底层逻辑和应用。</p><h2>如何创建私有属性？</h2><p>在面向对象中，有个很重要的概念就是创建私有属性。</p><p>我们可以看到，和Java不一样，当用JavaScript创建一个Widget对象时，无论是使用class、对象字面量还是函数构造式，一般的情况下，在定义了属性和方法后就可以公开调用，并没有任何限制。</p><pre><code class=\"language-javascript\">// 示例1：类class\nclass WidgetA {\n  constructor() {\n    this.appName =  \"天气应用\"\n  }\n  getName(){\n    return this.appName;\n  }\n}\nvar widget1 = new WidgetA();\nconsole.log(widget1.appName); // 返回 “天气应用”\nconsole.log(widget1.getName()); // 返回 “天气应用”\n\n// 示例2：对象字面量\nvar WidgetB = {\n  appName : \"天气应用\",\n  getName : function (){\n    return this.appName;\n  }\n}\n\nconsole.log(WidgetB.appName); // 返回 “天气应用”\nconsole.log(WidgetB.getName()); // 返回 “天气应用”\n\n// 示例3：函数构造式\nfunction WidgetC(){\n  this.appName = \"天气应用\";\n  this.getName = function (){\n    return \"天气应用\";\n  };\n}\n\nvar widget3 = new WidgetC();\nconsole.log(widget3.appName); // 返回 “天气应用”\nconsole.log(widget3.getName()); // 返回 “天气应用”\n</code></pre><h3>用#符号创建私有属性</h3><p>那怎么才能在对象中创建私有属性呢？根据最新的<a href=\"https://262.ecma-international.org/13.0/\">ES13</a> 规范，我们可以通过#符号，来定义一个私有的属性。</p><p>首先，我们声明了一个#appName，在构建者constructor里，我们给它赋值为“天气应用”。这时，当我们直接调取appName时，会看到返回的结果就是未定义的。但如果我们通过getName方法，就可以获取appName的值。</p><pre><code class=\"language-javascript\">class WidgetD {\n&nbsp; #appName;\n&nbsp; constructor(){\n&nbsp; &nbsp; &nbsp; this.#appName = \"天气应用\";\n&nbsp; }\n&nbsp; getName(){\n&nbsp; &nbsp; return this.#appName;\n&nbsp; }&nbsp;\n}\n\nvar widget4 = new WidgetD();\nconsole.log(widget4.appName); // 返回 undefined\nconsole.log(widget4.getName()); // 返回 “天气应用”\n</code></pre><p>所以下面，我们就一起来看看在#问世之前，工程师们是怎么实现私有属性的。主要有闭包、WeakMap和Symbol这三种方式。</p><h3>用闭包和IIFE创建私有属性</h3><p>我们先来看看如何在对象字面量中创建私有属性。是的，我们在前面讲函数式编程时，提到过的闭包在这里派上用场了。</p><p>首先，我们声明一个WidgetE的变量，然后再来创建一个立即被调用的函数式表达（IIFE），在这个表达里面，我们先给内部的appName变量赋值为“天气应用”。</p><p>之后，在函数中我们再给WidgetE赋值，这里赋值的是一个对象，里面我们定义了getName的方法，它返回的就是外部函数的appName。</p><p>这个时候，当我们试图获取WedgetE.appName时，会发现无法获取嵌套函数内部声明的变量。但是当我们通过getName的方法，利用嵌套函数中内嵌函数可以访问外部函数的变量的特点，就可以获取相应的返回值。</p><pre><code class=\"language-javascript\">// 对象字面量\nvar WidgetE;\n(function(){\n  var appName = \"天气应用\";\n  WidgetE = {\n    getName: function(){\n      return appName;\n    }\n  };\n}());\nWidgetE.appName; // 返回 undefined\nWidgetE.getName(); // 返回 “天气应用”\n</code></pre><p>好，下面我们再来看看如何通过构造函数的方式，构造私有属性。</p><p>这里也可以通过我们学过的闭包，直接上代码。这个例子其实看上去要比上面的例子简单，我们先定义一个函数，在里面声明一个变量appName，然后创建一个getName的表达式函数，返回appName。</p><pre><code class=\"language-javascript\">// 构造函数\nfunction WidgetF() {\n  var appName = \"天气应用\";\n  this.getName = function(){\n    return appName;\n  }\n}\nvar widget6 = new WidgetF();\nconsole.log(widget6.appName); // 返回 undefined\nconsole.log(widget6.getName()); // 返回 “天气应用”\n</code></pre><p>这时候，我们通过函数构造可以创建一个新的函数widget6，但是通过这个新构建的对象来获取appName是没有结果的，因为在这里，appName是封装在WidgetF内部。不过widget6可以通过getName来获取appName，同样，这里是利用闭包的特点，来获取函数之外的变量。</p><p>可是这个例子中还有一个问题，就是我们每次在创建一个新对象的时候，私有属性都会被重新创建一次，这样就会造成重复工作和冗余内存。解决这个问题的办法就是<strong>把通用的属性和功能赋值给prototype</strong>，这样通过同一个构建者创建的对象，可以共享这些隐藏的属性。</p><p>比如我们来看下面的例子，我们给WidgetG的原型赋值了一个函数返回的对象，函数中包含了私有属性，返回的对象中包含了获取属性的方法。这样我们在创建一个widget7的对象之后，就能看到它可以获取天气应用支持的机型了。</p><pre><code class=\"language-javascript\">function WidgetG() {\n  var appName = \"天气应用\";\n  this.getName = function(){\n    return appName;\n  }\n}\nWidgetG.prototype = (function(){\n  var model = \"支持安卓\";\n  return {\n    getModel: function(){\n      return model;\n    }   \n  }\n}());\nvar widget7 = new WidgetG();\nconsole.log(widget7.getName()); // 返回 “天气应用”\nconsole.log(widget7.getModel()); // 返回 “支持安卓”\n</code></pre><h3>用WeakMap创建私有属性</h3><p>在<a href=\"http://es6-features.org/#Constants\">ES6</a> 中，JavaScript引入了Set和Map的数据结构。Set和Map主要用于数据重组和数据储存。Set用的是集合的数据结构，Map用的是字典的数据结构。Map具有极快的查找速度，后面课程中我们在讲数据结构和算法的时候，还会详细介绍。在这里，我们主要先看WeakMap，它的特点是<strong>只接受对象作为键名，键名是弱引用，键值可以是任意的</strong>。</p><p>在下面的例子中，我们首先声明了一个WidgetG变量。接下来，建立一个块级作用域，在这个作用域里，我们再声明一个privateProps的WeakMap变量。然后我们给WidgetG赋值一个函数声明，在里面给WeakMap的键名设置为this，键值里面的appName为“天气应用”。下一步，我们基于WidgetF的prototype来创建一个getName方法，里面返回了appName的值。</p><p>利用这样的方式，就可以同时达到对appName的封装和通过getName在外部对私有属性值的获取了。</p><pre><code class=\"language-javascript\">var WidgetH;\n{\n  let privateProps = new WeakMap();\n  \n  WidgetH = function(){\n    privateProps.set(this,{appName : \"天气应用\"});\n  }\n  \n  WidgetH.prototype.getName = function(){\n    return privateProps.get(this).appName;\n  }\n}\n  \nvar widget8 = new WidgetH();\nconsole.log(widget8.appName); // 返回 undefined\nconsole.log(widget8.getName()); // 返回 “天气应用”\n</code></pre><h3>用Symbol创建私有属性</h3><p>Symbol也是在ES6引入的一个新的数据类型，我们可以用它给对象的属性的键名命名。</p><p>同样我们来看一个例子。和上个例子相似，这里我们建立了一个块级作用域，但区别是我们<strong>把privateProps从WeakMap换成了Symbol来实现私有属性。</strong></p><pre><code class=\"language-javascript\">var WidgetI;\n{\n  let privateProps = Symbol();\n  \n  WidgetI = function(){\n    this[privateProps] = {appName : \"天气应用\"};\n  }\n  \n  WidgetI.prototype.getName = function(){\n    return this[privateProps].appName;\n  }\n}\n  \nvar widget9 = new WidgetI();\nconsole.log(widget9.getName()); // 返回 “天气应用”\n</code></pre><h2>如何创建静态属性？</h2><p>前面我们提到了，静态的属性是属于构造函数的属性，而不是构造对象实例的属性。下面我们就来看看，如何通过JavaScript来实现静态属性。</p><h3>创建公开静态属性</h3><p>我们先看看如何通过static这个关键词来创建公开的静态属性。如以下代码所示，当我们直接在WidgetJ上面获取appName和getName的时候，可以看到结果是返回“天气应用”。而如果我们用WidgetJ构建一个widget10，看到返回的是未定义。这就说明，<strong>静态属性只能作用于class本身</strong>。</p><pre><code class=\"language-javascript\">class WidgetJ {\n  static appName = \"天气应用\";\n  static getName(){\n    return this.appName;\n  } \n}\n\nconsole.log(WidgetJ.appName); // 返回 “天气应用”\nconsole.log(WidgetJ.getName()); // 返回 “天气应用”\n\nvar widget10 = new WidgetJ();\nconsole.log(widget10.appName); // 返回 undefined\nconsole.log(widget10.getName()); // 返回 undefined\n</code></pre><h3>创建私有静态属性</h3><p>好，说完了公有静态属性，我们再来看看私有静态属性。私有的静态属性，顾名思义就是它不只是供构造者使用的，同时也是被封装在构建者之内的。</p><p>我们来看看它要如何实现，其实就是把 <strong>#符号和static关键词相加</strong>来使用。</p><pre><code class=\"language-javascript\">class WidgetM {\n  static #appName = \"天气应用\";\n  static staticGetName(){\n    return WidgetM.#appName; \n  }\n  instanceGetName(){\n    return WidgetM.#appName; \n  }\n}\n\nconsole.log(WidgetM.staticGetName()); // 返回 “天气应用”\n\nvar widget13 = new WidgetM();\nconsole.log(widget13.instanceGetName()); // 返回 “天气应用”\n</code></pre><h2>总结</h2><p>这节课我们通过对象内部的私有和静态属性，在第一讲的基础上，进一步地了解了对象的构建。同时，更重要的是，我们通过去掉私有属性的语法糖，也了解了如何通过函数式中的闭包、对象中的prototype、值类型中的Map和Symbol，这些更底层的方式实现同样的功能。在后面的两节课里，我们会继续从单个对象延伸到对象间的“生产关系”，来进一步理解面向对象的编程模式。</p><h2>思考题</h2><p>我们今天尝试通过去掉语法糖，用更底层的方式实现了对象中的私有属性，那么你能不能自己动手试试去掉静态属性的语法糖，来实现类似的功能？</p><p>欢迎在留言区分享你的答案、交流学习心得或者提出问题，如果觉得有收获，也欢迎你把今天的内容分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"06 | 如何通过模块化、异步和观察做到动态加载？","id":577550},"right":{"article_title":"08｜深入理解继承、Delegation和组合","id":578058}},"comments":[{"had_liked":false,"id":359454,"user_name":"西红柿炒番茄","can_delete":false,"product_type":"c1","uid":2045741,"ip_address":"北京","ucode":"384828B4ABEDF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/37/2d/df408cde.jpg","comment_is_top":false,"comment_ctime":1665549617,"is_pvip":false,"replies":[{"id":130872,"content":"好问题，它们和闭包是不同的。闭包主要利用的是内层函数对外层函数内变量的访问。symbol主要是利用了唯一值的特点，实现私有属性。\n\n而用weakmap，可以对属性存储，避免了用this对属性的获取。并且和map相比，它只能用对象作为键名，键值会随着对象销毁。这样可以避免不同对象用同一个map时之间相互的影响；以及对象销毁了后，map依然存在的问题。","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1665846069,"ip_address":"北京","comment_id":359454,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"weekmap、symbol实现静态属性，应该也是利用了闭包的特性吧？因为都是在创建的函数中保存了外部存储的数据","like_count":1,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590544,"discussion_content":"好问题，它们和闭包是不同的。闭包主要利用的是内层函数对外层函数内变量的访问。symbol主要是利用了唯一值的特点，实现私有属性。\n\n而用weakmap，可以对属性存储，避免了用this对属性的获取。并且和map相比，它只能用对象作为键名，键值会随着对象销毁。这样可以避免不同对象用同一个map时之间相互的影响；以及对象销毁了后，map依然存在的问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1665846069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1288733,"avatar":"https://static001.geekbang.org/account/avatar/00/13/aa/1d/b8fdd622.jpg","nickname":"laoergege","note":"","ucode":"559CCF36805A04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590507,"discussion_content":"symbol 实现的确实用到闭包，但数据是直接存在对象上。感觉老师讲的三种无非就是隐藏存储数据位置不同，我个人其实就两种：闭包和 symbol","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665826944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1008631,"avatar":"","nickname":"yuduxyz","note":"","ucode":"6C7F2DECDFEEC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288733,"avatar":"https://static001.geekbang.org/account/avatar/00/13/aa/1d/b8fdd622.jpg","nickname":"laoergege","note":"","ucode":"559CCF36805A04","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592766,"discussion_content":"我理解是两种，闭包和块级作用域。WeakMap 和 Symbol 的例子本质上都是利用块级作用域外部无法获取内部 privateProps 的特性。\n另外 WeakMap 和 Symbol 是没有用到闭包的，断点调试可以发现 Scope 中没有 Clousure，只是一个 Block","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667697171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":590507,"ip_address":"广东","group_id":0},"score":592766,"extra":""},{"author":{"id":1288733,"avatar":"https://static001.geekbang.org/account/avatar/00/13/aa/1d/b8fdd622.jpg","nickname":"laoergege","note":"","ucode":"559CCF36805A04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008631,"avatar":"","nickname":"yuduxyz","note":"","ucode":"6C7F2DECDFEEC5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592842,"discussion_content":"个人理解，闭包只是一种数据结构，将函数和执行环境绑定在一起，你从调试器看到的Clousure和block，个人感觉其实都是闭包对象的。实现私有数据要不就是藏在闭包对象中，或者普通对象通过symbol去隐藏。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667760759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":592766,"ip_address":"广东","group_id":0},"score":592842,"extra":""},{"author":{"id":2641149,"avatar":"https://static001.geekbang.org/account/avatar/00/28/4c/fd/2e4cd48f.jpg","nickname":"见字如晤","note":"","ucode":"2CBA86D3254B85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1288733,"avatar":"https://static001.geekbang.org/account/avatar/00/13/aa/1d/b8fdd622.jpg","nickname":"laoergege","note":"","ucode":"559CCF36805A04","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":615888,"discussion_content":"那就本质都是闭包数据结构了，如果是symbol实现的话，也是利用了外层无法访问内层的原理，只不过如果不用symbol而是一个普通字符串的话，外层是可能在内层未导出的情况下经过“碰撞”恰巧使用了那个普通字符串——但归根结底还是闭包数据结构+原生唯一性支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682487750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":592842,"ip_address":"广东","group_id":0},"score":615888,"extra":""}]}]},{"had_liked":false,"id":358845,"user_name":"鐘","can_delete":false,"product_type":"c1","uid":1518535,"ip_address":"北京","ucode":"0106652D5F7BD9","user_header":"https://static001.geekbang.org/account/avatar/00/17/2b/c7/9c8647c8.jpg","comment_is_top":false,"comment_ctime":1664886520,"is_pvip":false,"replies":[{"id":130623,"content":"可以参考MDN里介绍的“私有静态方法”：https:&#47;&#47;developer.mozilla.org&#47;zh-CN&#47;docs&#47;Web&#47;JavaScript&#47;Reference&#47;Classes&#47;Private_class_fields\n\nclass ClassWithPrivateStaticMethod {\n  static #privateStaticMethod() {\n    return 42;\n  }\n\n  static publicStaticMethod1() {\n    return ClassWithPrivateStaticMethod.#privateStaticMethod();\n  }\n\n  static publicStaticMethod2() {\n    return this.#privateStaticMethod();\n  }\n}\n\nconsole.log(ClassWithPrivateStaticMethod.publicStaticMethod1() === 42); &#47;&#47; true\nconsole.log(ClassWithPrivateStaticMethod.publicStaticMethod2() === 42); &#47;&#47; true","user_name":"作者回复","user_name_real":"编辑","uid":2785919,"ctime":1665309067,"ip_address":"北京","comment_id":358845,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"靜態公開屬性或方法的話可以這樣實現:\n\nclass A{}\nA.a = 1\nA.b = function(){}\n\n私有的靜態方法不知道怎麼實現","like_count":1,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589788,"discussion_content":"可以参考MDN里介绍的“私有静态方法”：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Private_class_fields\n\nclass ClassWithPrivateStaticMethod {\n  static #privateStaticMethod() {\n    return 42;\n  }\n\n  static publicStaticMethod1() {\n    return ClassWithPrivateStaticMethod.#privateStaticMethod();\n  }\n\n  static publicStaticMethod2() {\n    return this.#privateStaticMethod();\n  }\n}\n\nconsole.log(ClassWithPrivateStaticMethod.publicStaticMethod1() === 42); // true\nconsole.log(ClassWithPrivateStaticMethod.publicStaticMethod2() === 42); // true","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665309067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1518535,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2b/c7/9c8647c8.jpg","nickname":"鐘","note":"","ucode":"0106652D5F7BD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595112,"discussion_content":"了解, 我以為是有除了語法之外, 別的方式可以達成\n這樣看起來不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669731092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"中国台湾","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359097,"user_name":"褚琛","can_delete":false,"product_type":"c1","uid":1160498,"ip_address":"海南","ucode":"E08926DFC44973","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/32/43b46132.jpg","comment_is_top":false,"comment_ctime":1665236555,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"&#47;&#47;闭包创建私有静态私有属性\n\nvar WidgetN;\n\n(function () {\n  var appName = &#39;天气应用&#39;;\n\n  WidgetN = function() {};\n  WidgetN.staticGetName = function() {\n    return appName;\n  }\n})()\n\nconsole.log(WidgetN.staticGetName());\nconsole.log(WidgetN.appName);\n\n&#47;&#47;Symbol创建静态私有属性\nvar WidgetP;\n\n{\n  let staticPrivateProps = Symbol();\n\n  WidgetP = function() {};\n\n  WidgetP[staticPrivateProps] = { appName: &#39;天气应用&#39; };\n\n  WidgetP.staticGetName = function() {\n    return WidgetP[staticPrivateProps].appName;\n  }\n}\nconsole.log(WidgetP.staticGetName());\nconsole.log(WidgetP.appName);","like_count":2},{"had_liked":false,"id":371183,"user_name":"Nuvole Bianche","can_delete":false,"product_type":"c1","uid":2100301,"ip_address":"上海","ucode":"3C059A454C16C7","user_header":"https://static001.geekbang.org/account/avatar/00/20/0c/4d/90ab20d8.jpg","comment_is_top":false,"comment_ctime":1679623741,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"原文：“在下面的例子中，我们首先声明了一个 WidgetG 变量。接下来，建立一个块级作用域，在这个作用域里，我们再声明一个 privateProps 的 WeakMap 变量。然后我们给 WidgetG 赋值一个函数声明，在里面给 WeakMap 的键名设置为 this，键值里面的 appName 为“天气应用”。下一步，我们基于 WidgetF 的 prototype 来创建一个 getName 方法，里面返回了 appName 的值。”   其中的WidgetG 在示例代码中用的是WidgetH吧","like_count":0},{"had_liked":false,"id":371162,"user_name":"Nuvole Bianche","can_delete":false,"product_type":"c1","uid":2100301,"ip_address":"上海","ucode":"3C059A454C16C7","user_header":"https://static001.geekbang.org/account/avatar/00/20/0c/4d/90ab20d8.jpg","comment_is_top":false,"comment_ctime":1679589736,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"原文: 这时候，我们通过函数构造可以创建一个新的函数 widget6，      应该是新的对象widget6吧。","like_count":0},{"had_liked":false,"id":361470,"user_name":"哎呦先生","can_delete":false,"product_type":"c1","uid":1200430,"ip_address":"北京","ucode":"24076486C75030","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/2e/6f7b0e7c.jpg","comment_is_top":false,"comment_ctime":1667530226,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100122101,"comment_content":"私有属性无法通过对象实例直接操作，需要对象暴露方法来操作具体属性。java中一般用get和set方法来进行私有属性的获取和操作属性。静态属性是属于类的属性，不是某个类的实例属性。例如你可以说人类有五千年的文明，但是不能说某个人有五千年的文明。文明这个属性，是属于人类而不是具体某个人。","like_count":0}]}