{"id":464954,"title":"18 | Java内存模型：Java中的volatile有什么用？","content":"<p>你好，我是海纳。</p><p>随着这节课的开始，我们将进入到专栏的最后一个模块：<strong>自动内存管理篇</strong>。在这个模块，你将会了解到，以Java为代表的托管型语言是如何自动进行内存管理和回收整理的，这将提高你使用Java、Python、 Go等托管型语言的能力。</p><p>为什么我要把自动内存管理篇放到最后才讲呢？因为要理解这一篇的内容，需要软件篇和硬件篇的知识做铺垫。比如说，在面试时，有一个问题面试官问到的频率非常高，但几乎没有人能回答正确，因为它需要的前置知识太多。这个问题是：Java中的volatile有什么用？如何正确地使用它？</p><p>这个问题之所以会频繁出现在面试中，是因为Java并发库中大量使用了volatile变量，在JVM的研发历史上，它在各种不同的体系结构下产生了很多典型的问题。那么，在开发并发程序的时候，深刻地理解它的作用是非常有必要的。</p><p>幸运的是，前面硬件篇的知识已经帮我们打好了足够的基础，今天我们就可以深入讨论这个问题了。由于在这个问题中，volatile的语义是由Java内存模型定义的，我们就先从Java内存模型这个话题聊起。</p><h2>Java内存模型</h2><p>我们知道在不同的架构上，缓存一致性问题是不同的，例如x86采用了TSO模型，它的<strong>写后写（StoreStore）和读后读（LoadLoad）</strong>完全不需要软件程序员操心，但是Arm的弱内存模型就要求我们自己在合适的位置添加StoreStore barrier和LoadLoad barrier。例如下面这个例子：</p><!-- [[[read_end]]] --><pre><code>public class MemModel {\n    static int x = 0;\n    static int y = 0;\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                x = 1;\n                y = 1;\n            }\n        });\n        Thread t2 = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (y == 0);\n                if (x != 1) {\n                    System.out.println(&quot;Error!&quot;);\n                }\n            }\n        });\n        t2.start();\n        t1.start();\n        try {\n            t1.join();\n            t2.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>上面这个例子在x86机器上运行是没有问题的，但是在Arm机器就有概率打印出Error。原因是第一个线程t1对变量x和y的写操作的顺序是不能保证顺序的，同时，第二个线程t2读取x和y的时候也不保证顺序。这一点我们在<a href=\"https://time.geekbang.org/column/article/461801\">第15节课</a>和<a href=\"https://time.geekbang.org/column/article/462113\">第16节课</a> 已经分析过了。</p><p>为了解决这个问题，Java语言在规范中做出了明确的规定，也就是在JSR 133文档中规定了Java内存模型。<strong>内存模型是用来描述编程语言在支持多线程编程中，对共享内存访问的顺序</strong>。所以显然，在上面例子中，线程间变量共享的情况，就可以借此来解决。</p><p>在JSR133文档中，这个内存模型有一个专门的名字，叫<strong>Happens-before</strong>，它规定了一些同步动作的先后顺序。当然，这个规范也不是一蹴而就的，它也是经过了几次讨论和更新之后才最终定稿。所以，在早期的JVM实现中仍然存在一些弱内存相关的问题。这些问题我们很难称其为bug，因为标准里的规定就有问题，虚拟机实现只是遵从了标准而已。</p><p>接下来，我们探寻一下Happens-before模型究竟会带来什么样的问题，这样你就能深刻体会到volatile存在的意义了。</p><h2>Happens-before模型</h2><p>Java内存模型（Java Memory Model， JMM）是通过各种操作来定义的，包括对变量的读写操作、加锁和释放锁，以及线程的启动和等待操作。JMM为程序中的动作定义了一种先后关系，这些关系被称为Happens-Before关系。<strong>要想保证操作B可以看到操作A的结果，A和B就必须满足Happens-Before关系</strong>，这个结论与A和B是否在同一线程中执行无关。</p><p>我们先来看Happens-Before的规则，然后再对它的特点进行分析。我们要明确Happens-Before模型所讨论的都是同步动作，包括加锁、解锁、读写volatile变量、线程启动和线程完成等。下面这几条规则中所说的操作都是指同步动作。见下面的表格：</p><p><img src=\"https://static001.geekbang.org/resource/image/12/96/12122e04d343b260a6a0636e2be7e396.jpg?wh=2284x1555\" alt=\"\"></p><p>Happens-Before模型强调的是同步动作的先后关系，对于非同步动作，就没有任何的限制了。这节课的第一个例子，它里面的读写操作都是非同步动作，所以它在不同的体系结构上运行，会得到不同的结果。但这并不违反JMM的规定。</p><p>你要牢记一点的是，<strong>JMM是一种理论上的内存模型，并不是真实存在的。它是以具体的CPU的内存模型为基础的</strong>。可能我这么说，你还是觉得比较抽象，现在，我们来看JSR 133文档中的两个令人费解的例子，你就能理解了。</p><p>第一个例子是控制流依赖，例子中包括了两个线程且变量x和y的初值都是0。第一个线程的代码是：</p><pre><code>// Thread1\nr1 = x;\nif (r1 != 0)\n  y = 1;\n</code></pre><p>第二个线程的代码是：</p><pre><code>// Thread 2\nr2 = y;\nif (r2 != 0)\n  x = 1;\n</code></pre><p>由于存在控制流依赖，这两段代码中，第4行都不能提前到第2行之前执行。换句话说，到目前为止，所有的主流的CPU中，上面两段代码都会按照代码顺序执行。你可以推演一下，最终的运行结果一定是r1和r2的值都是0。</p><p><strong>但是Happens-before是一种理论模型</strong>，如果线程1中，y=1先于r1=x执行，同时线程2中，x=1先于r2=y执行，最后的结果，存在r1和r2的值都是1的可能性。理论上确实可能存在一种CPU，当它进行分支预测投机执行的时候，投机的结果被其他CPU观察到。当然，实际中绝对不可能出现这样的CPU，因为这意味着厂家花费了更多的精力为软件开发者带来了一个巨大的麻烦，而且由于核间同步通讯的要求，CPU的性能还会下降。</p><p>第二个例子是数据流依赖。假设x和y的初值是0，而r1和r2的初值是42。线程1的代码是：</p><pre><code>r1 = x;\ny = r1;\n</code></pre><p>线程2的代码是：</p><pre><code>r2 = y;\nx = r2;\n</code></pre><p>因为每个线程内部的第2行和第1行之间都存在数据依赖，所以这里是无法产生乱序执行的，所以无论你以怎样的顺序对这两个线程进行调度，都不可能出现r1=r2=42的情况的。但是r1=r2=42在Happens-before模型中却是合理的，因为它没有对数据流依赖进行规定。</p><p>也就是说，<strong>普通的变量读写在JMM是允许乱序的</strong>，如果真的有人造出这么愚蠢的CPU，运行出这种结果却是符合Happens-before的规定的。</p><p><strong>但是这两个问题在现实中并不存在</strong>。我这里特别想讲这两个例子的原因，是因为JSR 133文档花费了大量的篇幅在介绍本不应该存在的两个问题，这导致这个文档极其晦涩难懂。</p><p>从实用的角度，我建议你<strong>在理解JMM时，一定要结合具体的CPU体系结构</strong>。大体上讲，JMM加上每一种体系结构都有的控制流依赖和数据流依赖，才是一种比较实用的内存模型。纯粹的JMM本身的实用性并不强。</p><p>JMM是一种标准规定，它并不管实现者是如何实现它的。具体到Java语言虚拟机的实现，当Java并发库的核心开发者Doug Lea将JMM简化之后，就变得更容易理解一些。我们来看Doug Lea的描述。</p><h2>JVM的具体实现</h2><p>Doug Lea为了方便虚拟机开发人员理解Java内存模型，编写了一个名为<a href=\"http://gee.cs.oswego.edu/dl/jmm/cookbook.html\">《Java内存模型Cookbook》</a>的小册子。在这个小册子中，他给出一个表格，<strong>现代的JVM基本都是按照这个表格来实现的</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/f0/83/f0a8bc71606dc1d9c2c1735f9e933a83.jpg?wh=2284x1340\" alt=\"\"></p><p>这个表格描述了连续的两个读写动作，JVM应该如何处理。表格的最左列代表了第一个动作，第一行代表了第二个动作。表格中的内容使用了LoadLoad、LoadStore、StoreStore、StoreLoad四种内存屏障，分别表示第一个动作和第二个动作之间应该插入什么类型的内存屏障。</p><p>在上一节课中，我们知道了，在不同的体系结构上，这四类barrier的实际含义并不相同。因为x86采用了<strong>TSO模型</strong>，所以它根本没有定义LoadLoad、LoadStore和StoreStore这三种barrier，x86上只有StoreLoad barrier是有意义的。</p><p>而Arm上，由于存在单向的barrier，所以LoadLoad和LoadStore barrier就可以使用acquire load代替，LoadStore和StoreStore barrier也可以使用release store代替，而StoreLoad barrier就只能使用dmb代替了。</p><p>我们可以看到，表格的第三行刚好就对应了arm的acquire load barrier，所以我们就知道在arm上，JVM在实现volatile读的时候就必然会使用acquire load来代替。表格的第四列则刚好对应arm的release store barrier，同时，arm上的JVM在实现volatile写的时候，就可以使用release store来代替。</p><p>回到这节课开始时的例子，可见，只要将变量 y 改成 volatile，就相当于在第8行和第9行之前增加了StoreStore barrier，同时在第15行和第16行处增加了LoadLoad barrier，那么这段Java代码在Arm上的效果就与上一节课所分析的内存屏障的示例代码逻辑是一致的了。</p><p>只要JVM遵守了JMM的规定，那么不管在什么平台上，最后的运行结果都是一样。在这节课刚开始的那个例子中，只要把变量 y 修改成volatile修饰的，就不会再出现在x86上不会打印Error，而在Arm有机率打印Error的情况了。<strong>所有平台运行结果的一致性是由JVM遵守JMM来保证的</strong>。</p><p>到这里，我们就知道了，Happens-before模型是一种理论模型，它没有规定控制流依赖和数据流依赖。但是在实际的CPU中，这两种依赖都是存在的，这是JVM实现的基础。所以在JVM的实现中，主要是参考了Doug Lea所写的Cookbook中的建议。<strong>从实用的角度，Java程序员就可以从Doug Lea所给出的表格去理解volatile的意义，而不必再去参考JSR 133文档。</strong></p><p>接下来，我们通过两个例子来进一步加深对Java内存模型的理解，看看Java内存模型在实际场景中是如何应用的。</p><h2>JMM应用举例一：AQS</h2><p>与这节课第一个例子相似，JDK的源代码中有很多使用volatile变量的读写来保证代码执行顺序的例子，我们以CountDownLatch来举例，它有一个内部类是Sync，它的定义如下所示：</p><pre><code>private static final class Sync extends AbstractQueuedSynchronizer {\n    Sync(int count) {\n        setState(count);\n    }\n\n    int getCount() {\n        return getState();\n    }\n\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n}\n</code></pre><p>我们看到代码里的tryAcquireShared代表这个方法具有acquire语义，而tryReleaseShared则代表了这个方法具有release语义。从tryAcquireShared的代码里，我们可以推测getState里面应该会有acquire语义，我们继续看AbstractQueuedSynchronizer的代码。</p><pre><code>public abstract class AbstractQueuedSynchronizer\n    extends AbstractOwnableSynchronizer\n    implements java.io.Serializable {\n\n    /**\n     * The synchronization state.\n     */\n    private volatile int state;\n\n    /**\n     * Returns the current value of synchronization state.\n     * This operation has memory semantics of a {@code volatile} read.\n     * @return current state value\n     */\n    protected final int getState() {\n        return state;\n    }\n\n    /**\n     * Sets the value of synchronization state.\n     * This operation has memory semantics of a {@code volatile} write.\n     * @param newState the new state value\n     */\n    protected final void setState(int newState) {\n        state = newState;\n    }\n\n    /**\n     * Atomically sets synchronization state to the given updated\n     * value if the current state value equals the expected value.\n     * This operation has memory semantics of a {@code volatile} read\n     * and write.\n     *\n     * @param expect the expected value\n     * @param update the new value\n     * @return {@code true} if successful. False return indicates that the actual\n     *         value was not equal to the expected value.\n     */\n    protected final boolean compareAndSetState(int expect, int update) {\n        // See below for intrinsics setup to support this\n        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n    }\n</code></pre><p>从上面的代码中可以看到，state是一个volatile变量，根据JMM模型，我们可以知道getState方法是一种带有acquire语义的读。</p><p>在为state变量赋值的时候，AbstractQueuedSynchronizer(AQS)提供了两个方法，一个是setState，另一个是compareAndSetState。其中setState是一个带有release语义的写。那为什么还要提供comareAndSet方法呢？</p><p>这是因为compareAndSetState，不仅是强调release语义，它还有原子性语义。这个操作中包含了<strong>取值，比较和赋值三个动作</strong>，如果比较操作不成功，则赋值操作不会发生。</p><p>通过这个例子，我们就可以得到一个结论，<strong>内存屏障与原子操作是两个不同的概念。内存屏障强调的是可见性，而原子操作则是强调多个步骤要么都完成，要么都不做。也就是说一个操作中的多个步骤是不能存在有些完成了，有些没完成的状态的。</strong></p><p>接下来，我们再举一个与内存模型相关的并发例子。这是一道十几年来经久不衰的面试题，也是Java面试官最喜欢问的。这道题是：如何高效地实现线程安全的单例模式？</p><h2>JMM应用举例二：线程安全的单例模式</h2><p>我们知道单例模式是设计模式的一种，它的主要特点是全局只能生成唯一的对象。如何才能写出线程安全的单例模式代码呢？</p><p>我们从单线程最基本的单例模式开始讲起，它的代码是这样的：</p><pre><code>class Singleton {\n    private static Singleton instance;\n    \n    public int a;\n    \n    private Singleton() {\n      a = 1;\n    }\n    \n    public static Singleton getInstance() {\n        if (instance == null)\n            instance = new Singleton();\n        return instance;\n    }\n}\n</code></pre><p>这个类的特点是，<strong>构造函数是私有的</strong>。这意味着，除了在getInstance这个静态方法里，可以使用“new Singleton”的方式进行对象的创建，整个工程中的其他任意位置都不能再使用这种方法进行创建。</p><p>要想得到Singleton的实例就只能使用getInstance这个静态方法。而这个方法每一次都会返回同一个对象。所以这就保证了全局只能产生一个Singleton实例。</p><p>这个单例模式看上去写得很正确，但是面试题中的要求是写出线程安全的单例模式。上面的写法显然不是线程安全的。为什么我这么说呢？</p><p>假设第一个线程调用getInstance时，看到instance变量的值为null，它就会创建一个新的Singleton对象，然后将其赋值给instance变量。当第二个线程随后调用getInstance时，它仍然有可能看到instance变量的值为null，然后也创建一个新的Singleton对象。更具体的过程希望你可以自己进行分析，因为这是并发程序的相关内容，不是我们这节课的重点，所以我就不啰嗦了。</p><p>为了解决这个问题，我们可以将getInstance方法改为同步方法，这样就为调用这个方法加上了锁，从而可以保证线程安全：</p><pre><code>class Singleton {\n    private static Singleton instance;\n    public int a;\n    private Singleton() {\n        a = 1;\n    }\n    public synchronized static Singleton getInstance() {\n        if (instance == null)\n            instance = new Singleton();\n        return instance;\n    }\n}\n</code></pre><p>显然，上面的代码是线程安全的，我们之前分析过，在线程1还未执行完getInstance，线程2就开始执行的情况，在加锁以后就不会再出现了。但是这样会带来新的问题：<strong>访问加锁的方法是非常低效的</strong>。</p><p>所以，又有另外一种实现方式被提出：</p><pre><code>class Singleton {\n    private static Singleton instance = new Singleton();\n    \n    public int a;\n    private Singleton() {\n        a = 1;\n    }\n    \n    public static Singleton getInstance() {\n        return instance;\n    }\n}\n</code></pre><p>上面代码的第二行是在类加载的时候执行的，而类加载过程是线程安全的，所以不管有多少线程调用getInstance方法，它的返回值都是第二行所创建的对象。</p><p>这种创建方式有别于第一种。<strong>第一种单例模式的实现是在第一次调用getInstance时，它是在不得不创建的时候才去创建新的对象，所以这种方式被称为懒汉式；第二种实现则是在类加载时就将对象创建好了，所以这种方式被称为饿汉式</strong>。</p><p>还有的人既想使用懒汉式进行创建，又希望程序的效率比较好，所以提出了双重检查(Double Check)，它的具体实现方案如下：</p><pre><code>class Singleton {\n    // 非核心代码略\n    \n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n</code></pre><p>大多数情况下，instance变量的值都不为null，所以这个方法大多数时候都不会走到加锁的分支里。如果instance变量值为null，则通过在Singleton.class对象上进行加锁，来保证对象创建的正确性，看上去这个实现非常好。</p><p>但是经过我们这节课的讲解，你就能理解这个写法在多核体系结构上还是会出现问题的。假设线程1执行到第8行，在创建Singleton变量的时候，由于没有Happens-Before的约束，所以instance变量和instance.a变量的赋值的先后顺序就不能保证了。</p><p>如果这时线程2调用了getInstance，它可能看到instance的值不是null，但是instance.a的值仍然是一个未初始化的值，也就是说线程2看到了instance和instance.a这两个变量的赋值乱序执行了。</p><p>这显然是一个写后写的乱序执行，所以修改的办法很简单：<strong>只需要将instance变量加上volatile关键字，即可把这个变量的读变成acquire读，写变成release写</strong>。这样，我们才真正地正确实现了饿汉式和懒汉式的单例模式。</p><h2>总结</h2><p>好啦，今天这节课就结束啦，这节课我们学习了Java内存模型。从这节课中，我们了解到JSR 133中所描述的Java内存模型是一种理论模型，它的规则非常少，以至于连控制流依赖和数据流依赖都没有规定，这导致JSR133文档讨论了很多在现实中根本不存在的情况。</p><p>而我们在讨论JMM的实现时，必然会与具体的CPU相联系。Doug Lea将JMM做了简单的翻译，使用软件程序员可以看懂的语言重新阐释了JSR 133文档。</p><p>到这里，这节课开始处所讲的volatile的机制，其答案也就明晰了。它的作用是为变量的读写增加happens before关系，结合具体的CPU实现，就相当于是为变量的读增加acquire语义，为变量的写增加release语义。</p><p>接下来，我们用两个具体的例子来解释可见性、原子性和volatile的用法。</p><p>第一个例子是Java并发库中的核心数据结构AbstractQueuedSynchronizer(AQS)，它通过使用volatile变量和原子操作来维护对象的状态。</p><p>第二个例子是实现线程安全的单例模式。我们梳理了单例模式的各种实现方式，并详细介绍了double check实现方式的问题，以及如何使用volatile来修复这个问题。</p><h2>思考题</h2><p>请你思考一下，volatile能替代锁（或者CAS操作）的能力吗？比如，下面这个例子的写法，sum的最终结果一定是80000吗？如果不是的话，应该怎么做才能保证呢？欢迎你在留言区分享你的想法和收获，我在留言区等你。</p><pre><code>class AddThread extends Thread {\n    public void run() {\n        for (int i = 0; i &lt; 40000; i++)\n            Main.sum += 1;\n    }\n}\n\nclass Main {\n    public static volatile int sum = 0;\n    public static void main(String[ ] args) throws Exception {\n        AddThread t1 = new AddThread();\n        AddThread t2 = new AddThread();\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n\n        System.out.println(sum);\n    }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/9e/4e/9ea947633ce6ca2395e8878b3708124e.jpg?wh=2284x1780\" alt=\"\"></p><p>好啦，这节课到这就结束啦。欢迎你把这节课分享给更多对计算机内存感兴趣的朋友。我是海纳，我们下节课再见！</p>","neighbors":{"left":{"article_title":"17 | NUMA：非均匀访存带来了哪些提升与挑战？","id":464090},"right":{"article_title":"19 | 垃圾回收：如何避免内存泄露？","id":465516}},"comments":[{"had_liked":false,"id":325297,"user_name":"大豆","can_delete":false,"product_type":"c1","uid":1350130,"ip_address":"","ucode":"BC78EF2336DBD0","user_header":"https://static001.geekbang.org/account/avatar/00/14/99/f2/c74d24d7.jpg","comment_is_top":false,"comment_ctime":1638895306,"is_pvip":false,"replies":[{"id":"118055","content":"太对了，同学！","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1638931264,"ip_address":"","comment_id":325297,"utype":1}],"discussion_count":6,"race_medal":0,"score":"10228829898","product_id":100094901,"comment_content":"1、volatile不能代替锁，它的作用是绕过高速缓存，直接与内存进行交互并读写数据。<br>2、当多线程时，会存在线程A将新值写入内存前，线程B又从内存读取了旧值，这样就会导致sum的值不会是80000。<br>3、要想sum的值为80000，还得给Main.sum += 1;这句代码加锁。<br>4、volatile还有一个作用是防止指令重排，对吗？老师。","like_count":3,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536999,"discussion_content":"太对了，同学！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638931264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1350130,"avatar":"https://static001.geekbang.org/account/avatar/00/14/99/f2/c74d24d7.jpg","nickname":"大豆","note":"","ucode":"BC78EF2336DBD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574709,"discussion_content":"第一点错误的。volatile并不会绕过高速缓冲，而是通过内存屏障的方式来保证其可见性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654271339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361159,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqJobg767PUeqrqQQ4B6YvMatj2SRyOicKZZ4gWTf30dMketiaj58Gc3RFTmckGxAXlL9ERSxGovq9g/132","nickname":"涛哥哥","note":"","ucode":"329A1384E3AB5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573774,"discussion_content":"volatile 写后会强制刷新 store buff 到  cache line ，volatile 读会把 invalid Queue 全部应用一遍吧，所以应该不会每次读取都会读取内存吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653637725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1342279,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7b/47/96dad3ff.jpg","nickname":"Hunter_Dark","note":"","ucode":"3A07CCBC250B69","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553722,"discussion_content":"我有两点疑问，我理解防止指令冲排序，应该是添加了内存屏障后的附加作用吧？第2点是：volatile能让cpu绕过自己的高速缓存？不是让高速缓存失效吗？重新从内存读取？@海纳","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646040475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1038449,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/71/d6f79534.jpg","nickname":"一个工匠","note":"","ucode":"2168BA6F926074","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552281,"discussion_content":"volatile 绕过了高速缓存直接和内存交互读写数据了？不可能吧！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645372319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101293,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/ed/825d84ee.jpg","nickname":"费城的二鹏","note":"","ucode":"DE768A0CC3053D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536954,"discussion_content":"思考题，+=不是原子操作，所以结果不一定是80000，还是需要用锁的方式避免多线程问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638921945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334575,"user_name":"AriseFX","can_delete":false,"product_type":"c1","uid":1816560,"ip_address":"","ucode":"274CCBA62CCCF0","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b7/f0/380183ff.jpg","comment_is_top":false,"comment_ctime":1645004044,"is_pvip":false,"replies":[{"id":"122933","content":"使用cas，就不用再使用volatile了，cas确实会保证可见性。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1646124039,"ip_address":"","comment_id":334575,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5939971340","product_id":100094901,"comment_content":"请教一个问题，思考题如果使用CAS来更新sum的话，这里使用volatile关键字还有意义么，CAS不是已经包含了volatile读&#47;写的语义么？","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553873,"discussion_content":"使用cas，就不用再使用volatile了，cas确实会保证可见性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646124039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1483671,"avatar":"https://static001.geekbang.org/account/avatar/00/16/a3/97/ca8057a4.jpg","nickname":"Mona432","note":"","ucode":"3F02C646C8DC83","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591844,"discussion_content":"不对啊，volatile保证可见性，cas保证原子性，得结合使用啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666859178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254864,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/d0/3d5696d8.jpg","nickname":"无嘴小呆子","note":"","ucode":"4165B025F20929","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564524,"discussion_content":"CAS是Java通过JNI调用底层汇编指令实现原子性。同时在多核情况下，汇编指令会加锁前缀，从而保证可以读到变量的当前值。这和volatile的内存屏障、解决线程工作内存缓存是一个效果。你是想问例如Atomic类为什么还要用volatile修饰value嘛？它的出发点更多是解决update（CAS）和get方法并行下的可见性问题，比如AtomicLong中的value。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650266412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334540,"user_name":"AriseFX","can_delete":false,"product_type":"c1","uid":1816560,"ip_address":"","ucode":"274CCBA62CCCF0","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b7/f0/380183ff.jpg","comment_is_top":false,"comment_ctime":1644994243,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5939961539","product_id":100094901,"comment_content":"思考题<br> <br>public void run() {<br>        long sumOffset = UNSAFE.staticFieldOffset(Main.class.getDeclaredField(&quot;sum&quot;));<br>        for (int i = 0; i &lt; 40000; i++) {<br>            UNSAFE.getAndAddInt(Main.class, sumOffset, 1);<br>        }<br>    }","like_count":1},{"had_liked":false,"id":326554,"user_name":"王建新","can_delete":false,"product_type":"c1","uid":1934802,"ip_address":"","ucode":"E3151DDC0EEF0D","user_header":"https://static001.geekbang.org/account/avatar/00/1d/85/d2/045c63fb.jpg","comment_is_top":false,"comment_ctime":1639560176,"is_pvip":false,"replies":[{"id":"118733","content":"第15课里有的，volatile之所以难就是需要的前置知识多。要耐心点从头看。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1639720322,"ip_address":"","comment_id":326554,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5934527472","product_id":100094901,"comment_content":"菜鸡求请教：acquire 语意，和release 语意 都代表什么，求解答。。","like_count":1,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539449,"discussion_content":"第15课里有的，volatile之所以难就是需要的前置知识多。要耐心点从头看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639720322,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347304,"user_name":"anqi","can_delete":false,"product_type":"c1","uid":1202442,"ip_address":"","ucode":"956AFB84029AC9","user_header":"https://static001.geekbang.org/account/avatar/00/12/59/0a/9b2126ac.jpg","comment_is_top":false,"comment_ctime":1653913617,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653913617","product_id":100094901,"comment_content":"volatile 可以保证可见性，但无法保证原子性<br>因为数据可能在 寄存器或者 （store buffer + cpu cache + memory）组成的内存子系统中，<br>当在寄存器中时，如果发生中断，另一个线程仍然可以在上面的内存子系统中读到同样的值， 造成两次操作都是基于一个值做了自增操作，虽然刷新回内存的操作可以保证可见性，但已经于事无补了。","like_count":1},{"had_liked":false,"id":340280,"user_name":"卖藥郎","can_delete":false,"product_type":"c1","uid":1231829,"ip_address":"","ucode":"0539EF1D335918","user_header":"https://static001.geekbang.org/account/avatar/00/12/cb/d5/fab32cf7.jpg","comment_is_top":false,"comment_ctime":1648717411,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648717411","product_id":100094901,"comment_content":"volatile 能替代锁（或者 CAS 操作）的能力吗？<br>答：不能。比如 i++，实际会包含读改写三个操作，T1从主存中读取值之后，由于没有原子性限制，主存中的值可能会在此刻发生变化。<br>不知道这样理解的对不对，望老师指正","like_count":0},{"had_liked":false,"id":333941,"user_name":"苏志辉","can_delete":false,"product_type":"c1","uid":1068927,"ip_address":"","ucode":"39B25CE21C04EE","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/7f/5dc11380.jpg","comment_is_top":false,"comment_ctime":1644626520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644626520","product_id":100094901,"comment_content":"怎么理解程序顺序规则和控制流依赖、数据流依赖，程序顺序规则不会让有数据依赖的禁止重排吗？","like_count":0},{"had_liked":false,"id":332643,"user_name":"榕","can_delete":false,"product_type":"c1","uid":1053178,"ip_address":"","ucode":"4611A40E21ECEB","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/fa/e0dcc1bf.jpg","comment_is_top":false,"comment_ctime":1643439036,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643439036","product_id":100094901,"comment_content":"而 Arm 上，由于存在单向的 barrier，所以 LoadLoad 和 LoadStore barrier 就可以使用 acquire load 代替，LoadStore 和 StoreStore barrier 也可以使用 release store 代替，而 StoreLoad barrier 就只能使用 dmb 代替了。<br><br>老师，本文以上描述跟第16课内存模型中以下描述有点不一致:<br><br>与 stlr 相对称的是，它同时具备 LoadLoad barrier 的能力和 StoreLoad barrier 的能力。在实际场景中，我们使用最多的还是 LoadLoad barrier，此时我们会使用 ldar 来代替。<br><br>16课中讲acquire load是具有LoadLoad barrier和StoreLoad barrier能力，但本文说LoadLoad 和 LoadStore barrier 就可以使用 acquire load 代替，而 StoreLoad barrier 就只能使用 dmb 代替了。这里有点搞不清了，麻烦老师解惑","like_count":0},{"had_liked":false,"id":326493,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1639539825,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639539825","product_id":100094901,"comment_content":"“JMM 是一种理论上的内存模型，并不是真实存在的”，那JMM是不是跟OSI七层模型一样了","like_count":0},{"had_liked":false,"id":325577,"user_name":"送过快递的码农","can_delete":false,"product_type":"c1","uid":1587666,"ip_address":"","ucode":"66EA81B3BADC73","user_header":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","comment_is_top":false,"comment_ctime":1639028773,"is_pvip":false,"replies":[{"id":"118120","content":"我觉得你这个总结还是感性上的一种总结，还不够精细。大体方向是对的。但细节还要再多抠一下。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1639035376,"ip_address":"","comment_id":325577,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1639028773","product_id":100094901,"comment_content":"我尝试对之前的知识和今天的文章我来梳理一下。volatile 关键字修饰的变量要遵循happen-bofore模型。由于cpu缓存的情况，我们会出现读滞后数据的情况。前面的知识，cpu通过缓存一致性协议，对缓存状态进行管理，一旦失效，会通过总线同步给其他核心。但是由于，这样性能成本太高，所以出现写缓存区+失效队列+内存屏障来进行补充？又由于我理解这个是jmm内存模型提出的规范，由于不同平台，不同cpu缓存架构不一样，cpu所提供的内存屏障实现也不一样。volatile关键字，虽说是可见性，但是也是集cpu，操作系统，jvm这些在不同层级上做自己的事情，方能实现。感觉也是现代计算机知识体系的一个精华（由于，前面很多看了不懂不懂，所以麻烦老师看看我的理解对不对，感觉这个也是要多刷的，不然越学越废）","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537332,"discussion_content":"我觉得你这个总结还是感性上的一种总结，还不够精细。大体方向是对的。但细节还要再多抠一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639035376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1587666,"avatar":"https://static001.geekbang.org/account/avatar/00/18/39/d2/845c0e39.jpg","nickname":"送过快递的码农","note":"","ucode":"66EA81B3BADC73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":537369,"discussion_content":"细节我越扣越晕，只能先把大的方向上先想清楚了，然后再慢慢看。。。所以感觉整个专栏要多刷，可能得配合其他资料","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639043129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537332,"ip_address":""},"score":537369,"extra":""}]}]},{"had_liked":false,"id":325447,"user_name":"raisecomer","can_delete":false,"product_type":"c1","uid":1304195,"ip_address":"","ucode":"32EA488E46471F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtlEYuHnR8VdRkNPcmkIqTM9DKahpcpicDdBvcmBWMIAAhBrd0QNWvl09slqrzB5TibryVcIfPmb7Q/132","comment_is_top":false,"comment_ctime":1638959096,"is_pvip":false,"replies":[{"id":"118972","content":"这就是jsr133文档难受的地方，我这里是照着翻译回来的。其实他想说的是写操作如果在程序里出现在读操作之前，那就不能乱序。这就是写后读屏障的规则。其实你不用太在意jsr133说的是什么，只要看Doug lea给的那张表就行了。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1639928935,"ip_address":"","comment_id":325447,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1638959096","product_id":100094901,"comment_content":"“happen-before模型”的表格中“对volatile的写操作在对该变量的读操作之前执行”，太令人费解了","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540064,"discussion_content":"这就是jsr133文档难受的地方，我这里是照着翻译回来的。其实他想说的是写操作如果在程序里出现在读操作之前，那就不能乱序。这就是写后读屏障的规则。其实你不用太在意jsr133说的是什么，只要看Doug lea给的那张表就行了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639928935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254864,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/d0/3d5696d8.jpg","nickname":"无嘴小呆子","note":"","ucode":"4165B025F20929","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537779,"discussion_content":"如果一个变量有volatile修饰，在多线程中一个更改以后，另外一个由于CPU缓存，及MESI一致性不能实时同步导致无法感知，读取时用的还是原来错误的值。但是如果volatile则表示这种情况的写对另外一个线程可立即感知更改，你可以理解立刻进行MESI一致性操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639191666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325353,"user_name":".","can_delete":false,"product_type":"c1","uid":1335848,"ip_address":"","ucode":"C0541289C44AF8","user_header":"https://static001.geekbang.org/account/avatar/00/14/62/28/0356880b.jpg","comment_is_top":false,"comment_ctime":1638929756,"is_pvip":false,"replies":[{"id":"118070","content":"总结得非常好！15，16课已经讲过了啊，arm上就是采用了dmb, arquire, release这三种。","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1638951812,"ip_address":"","comment_id":325353,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638929756","product_id":100094901,"comment_content":"volatile作用的自我总结：<br>1.给编译器看在编译层面禁止重拍<br>2.给虚拟机看让其在对应的指令加入屏障。防止cpu级别的重排序与缓存一致性问题<br><br>思考题:<br>这个问题就像++i问题类似，由于加一是由多个字节码才能完成（java虚拟机基于栈的设计尤其明显比安卓虚拟机完成一件事需要更多指令）。假设cpu1取出数据放入操作栈，还没进行计算操作，而此时时间片正好用完另线程cpu2完成一次加一，在切回cpu1时数据已经错误。<br><br>解决方案：<br><br>1.加锁保证多线程的串行<br>2.操作变成原子操作，如使用并发包下的原子类<br><br><br><br>老师能不能以后讲讲cpu之上的内存模型呢？比如arm","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537082,"discussion_content":"总结得非常好！15，16课已经讲过了啊，arm上就是采用了dmb, arquire, release这三种。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638951812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325345,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1638928492,"is_pvip":true,"replies":[{"id":"118068","content":"Bingo~","user_name":"作者回复","user_name_real":"编辑","uid":"1360512","ctime":1638951671,"ip_address":"","comment_id":325345,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638928492","product_id":100094901,"comment_content":"volatile 只能保证可见性和有序性。不能保证原子性。","like_count":0,"discussions":[{"author":{"id":1360512,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c2/80/6ebf32e8.jpg","nickname":"海纳","note":"","ucode":"AB9F7ADB1428D2","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537079,"discussion_content":"Bingo~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638951671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}