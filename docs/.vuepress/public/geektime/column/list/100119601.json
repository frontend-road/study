[{"article_id":555109,"article_title":"开篇词｜React Web开发这样学，才能独当一面！","article_content":"<p>你好，我是宋一玮，欢迎加入React应用开发的学习。</p><p>React作为当下极为火热的三大前端技术之一，市面上的相关课程、书籍和文档层出不穷，其中也不乏一些优质内容。那为什么我还要开设React Web应用开发这样一门课呢？</p><p>在近几年的开发工作中，我有幸与一些刚上手React不久的前端开发者共事，他们之中有些是刚入行的年轻人，有些是从其他技术栈，甚至是其他软件领域转过来的开发者，他们都很优秀。</p><p>在为前端开发队伍不断发展壮大感到高兴的同时，我也从中观察到一些问题，并将其归纳总结成了“<strong>五个无所适从</strong>”：</p><ol>\n<li>对Web前端开发形成了固化印象，过于局限在框架上，脱离了框架就无所适从了；</li>\n<li>对各类开源React组件库很有心得，但需要定制或自己写组件时就无所适从了；</li>\n<li>编写相对简单的React样板项目手到擒来，项目规模提升后就无所适从了；</li>\n<li>在开发Web前端时习惯手工测试，当需要引入自动化测试时就无所适从了；</li>\n<li>停留在独自开发一个前端项目的舒适区，多人协作开发时就无所适从了。</li>\n</ol><p>之所以有这些问题，是因为我发现很多前端开发者都有一个误区，那就是过于关注和强调“最新框架”“最新版本”，而<strong>缺乏对前端发展历史的深度了解，也缺少对前端新技术新领域的上手实践。</strong></p><!-- [[[read_end]]] --><p>对此，我积累了一套从原理到实战的思考总结，并提炼了走出这个误区的“两步走”策略，分别是“以史为鉴”和“上手实践”，这一次想全部分享给你。</p><h2>为什么总是学不好Web前端开发？</h2><p>容我先向你介绍一下我自己。我曾先后供职于IBM、Amazon、一家O2O创业公司以及时光网，现任FreeWheel中国研发中心基础架构部的前端架构师，负责FreeWheel自研前端框架、BFF、微前端等方案的设计研发和推广。</p><p>从最早的ASP、JSF、Flex、Dojo，一直到移动端、Angular，以及现在FreeWheel内广泛使用的React，我从事前端开发和架构设计已有16年。</p><h3>以史为鉴，学习新技术</h3><p>比起很多朝气蓬勃的年轻人，16年不算短，硬要说优势的话，那就是一直专注于前端，亲身经历了诸多新老前端技术的更迭。</p><p>我想你肯定会说前端技术的更迭太快了，在这一轮又一轮的学习实践中，似乎没有什么能沉淀下来的东西。其实我跟你一样，并不清楚未来的新技术具体是什么，但我认为<strong>新老前端技术有很多相通的部分，相互之间有着紧密的传承</strong>。</p><p>你应该知道，随着Web前端技术的能力和应用领域不断增多，Web前端开发工作的广度和深度也随之提升，这就要求Web前端工程师必须构建起坚固的知识技能图谱。</p><p>因此解决“五个无所适从”问题的第一步，就是<strong>以史为鉴</strong>，从历史脉络中建构解决问题的新思路：哪些东西一直在变，又有哪些东西从没变过，从而对自己为之工作的前端应用有更立体的了解，并将其真正变成自己的知识。</p><p>比如有很多朋友都很熟悉JSP，它是本世纪初非常热门的技术，但作为被寄予厚望的后继者JSF（Java Server Faces）就没多少人用过了，就在这一少部分JSF开发者中，也许更少人会知道JSF 1.1有多少Bug，1.2有多么姗姗来迟，还有前面的版本与后来的JSF 2.0简直就是<a href=\"https://stackoverflow.com/a/4532870/245345\">两个不同物种</a>。</p><p>虽然JSF的这种折腾精神导致它流失了不少用户，最终也败给了更务实的Struts框架。但我亲历过JSF Web应用项目，深刻领悟到了前端组件化开发的潜力，也为之后学习Adobe Flex和Angular奠定了扎实基础。</p><p>可以说，正是对软件前端<strong>发展规律</strong>的认识，才让我坚定了从事前端开发工作的信心，也在一定程度上帮助我对抗了“新技术来得太快学了白学”的焦虑。</p><h3>上手实践，时常总结思考</h3><p>不过，比起很多业内有威望有实力的前辈，16年的工作经历也不算长，若问起我的自信从何而来，那我会说自己数年如一日，<strong>对新技术新领域一直保持上手实践的习惯</strong>。这也是解决“五个无所适从”的第二个方法，也是我认为最根本的方法。</p><p>对于上手实践，我们不能理解得太简单片面，以为实践时间投入得越来越多，技术的熟练程度就会越来越高。无论是从跟同行的交流中，还是从自己和身边同事朋友的经历中，我都意识到<strong>实践不是二维的，而是三维的</strong>。</p><p>我想用一个螺旋学习曲线，来定义这个三维的学习实践过程：</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/a7/e5ff43365248a7ed1a0b3189cb179ea7.jpg?wh=3840x2160\" alt=\"\"></p><p>如图所示，学习一个新框架，学习它的基本概念、上手调用API写代码，一般而言都属于技术表层；而理清概念之间的联系、理解API内部的原理，则属于技术底层。</p><p><strong>如果学习实践只停留在表层，那一定会遇到瓶颈</strong><strong>。</strong>但如果这时更进一步，去学习底层，把概念和接口关联起来，就会豁然开朗；然后再回到表层，掌握程度就会不断提升。</p><p>我举一个有些微不足道的小例子。边框圆角是前端应用常见的一种设计，与功能无关，更多是在强调视觉和交互。然而CSS属性<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7\"><strong>border-radius</strong></a>是从2011年的IE9才开始被浏览器支持，而且当年IE9市场份额还很小，那其他版本的浏览器该怎么实现呢？</p><p>我先后经历了切图+table定位、切图+div+CSS、jQuery插件。后来在Android 2.1上做App开发时，从它内建的九宫格图片（Nine-Patches）功能中受到启发，原来切图也可以推迟到运行时再做。于是我又专门去研究如何用JS解析Photoshop的PSD源文件，希望能进一步优化从设计稿到HTML原型的工作流程。</p><p>后来有一天商业软件Sketch横空出世，改革了原型设计工作，我也很识趣地放弃了这个尝试。但工程化的思路，为我后续快速上手Gulp、Webpack这些构建工具打下了基础。</p><p>从边框圆角到前端工程化，看似跨度过大，但这正说明了<strong>动手实践、深度理解技术表层与底层，支撑了我前端职业生涯发展的每一步</strong>。</p><p>在我的观念里，无论软件架构还是前端架构，说到底都是<strong>对软件不同层次的抽象</strong>（Abstraction），而各类开发框架里的概念、模型、算法也是抽象，开发者编写的代码也包含抽象，三者具有相通性。</p><p>因此做架构、搭框架、写代码，都是前端开发工作的组成部分，并没有绝对的界限。</p><h2>React Web应用开发的正确打开方式</h2><p>特定到React技术，我对如何<strong>学好</strong>这门技术也有一些自己的见解，可以用<strong>一个公式</strong>来表达——“React新版本+函数组件&Hooks优先+团队协作=高效进阶”。</p><p>公式可能有点长，不过理解起来并不难，接下来我就具体地讲一讲。</p><h3><strong>新版React，函数组件+Hooks优先</strong></h3><p>我是从React v0.14版本开始投入到React Web应用开发工作的。当时类组件还是主流，JSX、React元素、props、state、context这些概念已经稳定下来。</p><p>React官方虽然试验性地推出了无状态函数组件，但功能还非常简单，无论是官方文档还是各类教程，都是以类组件为主。当React来到v16.8.0，正式推出了Hooks。从功能上来说，函数组件已经可以和类组件平起平坐了，不过毕竟还是新功能，文档教程还是以类组件为主。</p><p>然而三年过去了，React已经推出了v18.2.0版本，函数组件加Hooks已经取代类组件成为React开发主流，多数文档教程们还在坚守着类组件。</p><p>我认为更有效率的React学习方式，是在掌握基础概念的同时，<strong>优先学习函数组件和Hooks</strong>，必要时再补充类组件的知识。这样开发者就能更贴近React社区的最新趋势，更快上手实际项目的开发。</p><h3><strong>了解现实挑战，为团队协作做准备</strong></h3><p>但我并不认为这些已足够解决前面提到的“五个无所适从”的问题，我也不建议你止步于此。当你真正从事React前端开发的工作时，会有更多的挑战接踵而至。</p><p>这里引用一个我司FreeWheel的案例。我们利用自研React组件库以及高度封装Redux的状态管理库，搭建并有效利用前端基础设施，将企业原有的巨型Ruby-on-Rails应用，逐步迁移至多个React单页应用。</p><p>在整个迁移过程中，我们不仅要边学边用新框架，更要理解老框架是怎么工作的。为了降低产品迭代的成本和风险，在很长一个阶段中，我们都要保持新老框架的共存。</p><p>打个不恰当的比方，这种技术栈杂糅的情况就好像在四合院里建起了写字楼，再把写字楼的一半改建成东方明珠。我认识的不少开发者是有技术洁癖的，他们会有意无意地抵触这种技术共存的状态。</p><p>然而，正是这个大胆的改造方案，让我们的产品迭代和技术演进之间取得了平衡，既能更早地引入React技术，带来开发体验和用户体验的提升，也为后期清偿各种技术债务奠定了基础。</p><p>这个案例正好也佐证了，<strong>React前端开发不仅仅是React框架本身，</strong>还包括对前端整体架构和React技术边界的把握，对新老前端技术差异的理解，与历史遗留代码的整合，与多个前端开发团队的协作，等等。</p><p>因此在面对一个大型React项目时，我们不仅需要掌握一些趁手的工具，还要建立在团队中协作开发的工作方式和技术体系。</p><h2>课程是怎么设计的？</h2><p>刚刚说的这些，其实也正是咱们这门课的核心设计理念。接下来，我就说说这门课具体是怎么设计的。</p><h3>历史篇：建构对React技术栈的总体认识</h3><p>我会从软件前端发展的历史抽取部分片段，揭示一些规律，为你增加学习前端技术和从事前端开发工作的信心。</p><p>在此基础上，将由前端的发展趋势引出课程主题——React技术，从前端架构和技术选型的视角，让你对React技术栈建立一个总体认识。</p><h3>“独狼”篇：快速开发简单的React前端应用</h3><p>我会先带着你创建一个React项目，快速开发一个简单的React Web应用。然后从这个应用的代码开始，从浅到深，一起学习React的基本概念，如JSX语法、单向数据流等。</p><p>在学习这些概念和API的过程中，不仅是How，我还会穿插一些Why，力求让你在脑海中建立这些概念之间的逻辑关系。也就是下面这张思维导图的蓝色部分：</p><p><img src=\"https://static001.geekbang.org/resource/image/39/93/39bab54c5ea0af1be554a4fe71b18b93.jpeg?wh=1184x720\" alt=\"\"></p><h3>项目篇：高效掌握现代前端工程化技术</h3><p>在这个模块，我会介绍一些更具挑战的React概念和技巧，包括不可变数据、应用状态管理、强类型校验、代码复用（也就是上图中的紫色部分），在React项目规模和复杂度不断提升时，它们将成为你的得力工具。</p><p>此外，你在单打独斗时可能会形成自己特有的开发习惯。但如果因为开发大型项目需要融入一个前端开发团队时，就有必要掌握一些不同的团队协作的工作方式，包括项目代码结构、单元测试、端到端自动化测试和持续集成。</p><p>当完成这些内容，你将会对大型React项目和团队协作有所准备，相信也会对你在前端开发领域的职业发展有所助力。</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/ed/f24bebc6d0230b8402e0d384215b03ed.jpg\" alt=\"\"></p><h2>开篇寄语</h2><p>我深知开发者用于学习的时间精力是很有限的，投入一门课的时间，肯定希望这门课物超所值。相应的，<strong>学习一门技术，务必要有大于一门技术的收获</strong>，这也是我开设这个专栏的初衷。</p><p>好了，千里之行始于足下，我们第一节课见！</p>","neighbors":{"left":[],"right":{"article_title":"01｜身为Web前端工程师，我都在开发什么？","id":553789}}},{"article_id":553789,"article_title":"01｜身为Web前端工程师，我都在开发什么？","article_content":"<p>你好，我是宋一玮。</p><p>前端技术日新月异，尤其Web前端技术的能力和应用领域不断增多，Web前端开发工作的广度和深度也随之日益提升，这就要求Web前端工程师必须扩展自己的知识技能体系。</p><p>而不少前端开发者吐槽，这些技术更新太快了：刚刚学习了新语言、新框架、新组件库，没多久就变成了老技术，然后又要赶着去学习新技术；加上紧张的工作生活挤压自己的学习时间，一轮一轮下来，觉得自己没沉淀下来什么。</p><p>那么，如何在学习和实践前端技术中有所沉淀？</p><p>首先，<strong>前端技术不只是技术</strong>。学习Web前端技术的目的是将其应用于实际前端开发工作，要对自己为之工作的前端应用有更全面、立体的了解，才能更有效地总结、归纳技术点，真正成为自己的知识。</p><p>其次，<strong>掌握技术的广度和深度一样重要</strong>。把一项技术钻研到极致，是很受人敬佩的，但在实际工作中也有可能反而限制了思路，正如常说的“拿了把顺手的锤子，就觉得哪里都是钉子”。当掌握多项技术后，技术与技术之间的联系和差异，就会在你脑海中形成一张知识图谱。这样再有新技术来，你就已经有准备了。</p><p>在这节课里，我会简要介绍前端应用的历史，提炼出一些前端的领域知识，并从中找到一些不曾改变的规律和原理。然后作为论据，我会比较20年前的Java Web技术和近年来浏览器端的JS前端技术。希望这些内容会帮你触碰到前端应用开发的本质。</p><!-- [[[read_end]]] --><h2>前端开发工作历史悠久</h2><p>我们从事开发的Web前端是一种图形用户界面，即GUI。</p><p>GUI在1984年Apple发布Macintosh时首次进入大众的视野。我首次接触个人电脑是在DOS流行的年代，主要交互方式还是命令行，当时的国产软件金山WPS文字处理系统让我大开眼界，进入UCDOS，运行WPS，整个屏幕就进入了支持鼠标操作的图形界面。</p><p>很久以后我才知道在DOS上开发GUI，纯靠应用软件厂商自己设计开发。</p><p>之后随着微软Windows系统的崛起，GUI成为计算机人机交互的主流。开发者们利用Windows的MFC、macOS的Cocoa、跨平台的GTK、Qt等框架，构建了不计其数的GUI应用。</p><p>分布式计算引入了C/S（客户端-服务器）架构。上世纪90年代起，互联网开始兴起，网站作为GUI更加灵活、丰富，更易分发，这让浏览器一跃成为最普及的客户端。早期的网站或Web应用以静态网页加服务器端页面技术为主，如CGI、ASP、PHP、JSP、Ruby on Rails、ASP.NET等。</p><p>2004年，谷歌发布了一款基于AJAX技术开发的，标志性的Web应用——Gmail，从此B/S（浏览器-服务器）架构一发不可收拾，成为C/S架构中的主流。在B/S架构的早期，除了JavaScript，还有一众基于浏览器扩展的RIA技术试图收复失地，如Java Applet、Adobe Flash/Flex、MS Silverlight。</p><p>而2010年，Apple创始人乔布斯老爷子公开抨击Flash、力挺HTML5，这导致Flex等RIA技术的消亡，Web应用迎来HTML5的时代。浏览器领域Firefox和Chrome先后打破IE的垄断，尤其是V8 JS引擎的横空出世，也打消了开发者对JS性能的顾虑。</p><p>浏览器们卷了起来，也带动了JS语言本身和Web API的标准化。JS框架从早期的jQueryUI、Dojo Toolkit、ExtJS，演进到后来的Backbone.js、Ember.js，一直到现在的React、Vue、Angular三大框架。</p><p>历史的车轮会一直向前，但技术的轮子会时不时往回滚。例如，移动互联网时代，在移动设备算力有限的条件下，iOS、Android移动端的原生App要比Web应用更普及。又如，基于浏览器端JS Web应用为主流的今天，同构JS应用、SSR服务器端渲染、SSG静态网站生成又开始在行业中有了一席之地，如Next.js、Nuxt.js。</p><p>前端开发历史悠久，前端技术实践有着丰富的积累，很多现今的问题，在历史中都能找到答案。</p><h2>前端是界面也是接口</h2><p>前面介绍了GUI开发技术的历史，现在我们把关注点放在前端开发者，也就是“你”身上。</p><p>GUI是Graphical User Interface的缩写，其中的Interface我们一般翻译成“界面”，而API中的“I”同样是Interface，我们一般翻译成“接口”。类比一下编程语言里接口的特性，使用者只关注接口，而无需关注接口对应的内部实现。</p><p>前端界面也是这样，<strong>用户只关注与应用界面的交互，而不需要关注界面后面对应的程序是怎么实现的</strong>。作为前端开发者，你是这类“接口”的负责人，你自然是接口的实现者，用户是接口的使用者，但他们不会提出接口该怎样设计（不过他们会抱怨“这界面怎么这么难用”），所以你同时也是接口设计的把关人。</p><p>和编程接口有着一系列设计模式类似，GUI作为接口也有它特有的设计准则。</p><ol>\n<li><strong>可用性</strong>：“别让我思考（Steve Krug，2000）。”一个优秀的GUI是能够自解释的，用户不需要向导或仅需极少向导即可学会如何与之交互。</li>\n<li><strong>一致性</strong>：“单一界面标准，能够通过提高产出和减少错误，改善用户学习界面的能力和提高生产率（Jakob Nielsen，1993）。”“除非有真正出众的替代方案，否则还是遵循标准（《软件观念革命——交互设计精髓》Alan Cooper，2005）。”</li>\n<li><strong>遵循用户心智模型，避免实现模型</strong>：比如前端界面上有个颜色选择器，比起一个RGB数字值输入框，把可用的颜色块列举出来备选对普通用户更友好。</li>\n<li><strong>最小惊讶原则</strong>（Principle Of Least Astonishment/Surprise）：是的，就是编程时常见的那个最小惊讶原则，同样适用于前端交互领域。</li>\n<li><strong>及时反馈</strong>：用户点了提交按钮，我们需要让他知道是否成功，如果在成功前后端需要一些时间计算，那么我们需要显示一个进度条，告诉用户后端在努力了，很快了；任何场景下都要避免GUI冻结而无法做任何操作的情况。</li>\n</ol><p>作为前端工程师，你可能会有疑问，上面这些不都是PM、设计师和交互设计师的工作吗？我只要写代码就好了（最好我连切图都不需要做）。那有点冒犯地说，你可能被大公司惯坏了。</p><p>无论国内国外，在具有活力的创业公司，你都能找到一些优秀的前端开发者，他们在前端代码之外，也负责交互设计，分担一部分PM工作，甚至还必须自己兼任设计师。</p><p>当然，并不是每个人都会选择创业公司，也不否定大公司或其他非创业公司一样会有全能型的选手，只是需要知道在成为优秀的前端开发者的路上，程序代码以外的知识和技能必然会成为你的助力。</p><p>例如，当开发零售电商网站时，你知道从商品促销页到详情页、到购物车、再到结算、下单最终支付成功，转化率是呈漏斗形下跌的，优化关键流程和关键交互可以有效提高各环节转化率。</p><p>再如，当开发面向欧洲客户的网站时，你知道需要针对欧盟的GDPR开展合规工作，页面上使用Cookie时必须明确提示用户，Cookie中保存了哪些数据，网站会怎样使用这些数据，以及数据会与哪些第三方分享等等。这些本身并不是前端程序代码，但却决定了前端软件产品的质量和效果。</p><p>其实这与其他工程师并没有本质区别。一位优秀的后端工程师，除了编写后端代码，也需要深入了解业务需求，真正吃透业务才能开发出可伸缩、可扩展、可维护的后端服务。一位优秀的算法工程师，也不能只一味的去套用最先进的算法模型，而更需要分析业务，针对业务建模、设计适合的算法、实现并落地。</p><p>即便不限定行业或场景，前端开发也有着自己的领域知识。这里举两个例子。</p><p>一是<strong>交互设计</strong>。面向用户的交互设计需要用到多种多样的图形化元素，按钮图标是其中一种。随着行业和前端技术的发展，图标在拟物化到抽象化、立体化到扁平化这些风格间反复横跳。</p><p>比如这个“保存”图标，<a href=\"https://freesvg.org/vector-image-of-blue-floppy-disc\">拟物化版本：</a></p><p><img src=\"https://static001.geekbang.org/resource/image/69/42/695ee9b102825603677ce6321bb9f842.png?wh=100x97\" alt=\"\"></p><p><a href=\"https://commons.wikimedia.org/wiki/File:Antu_document-save-as-template.svg\">扁平化版本：</a></p><p><img src=\"https://static001.geekbang.org/resource/image/62/99/62468c43a7dae8b1d6fdf010fa8d9099.png?wh=100x99\" alt=\"\"></p><p>用户们会因为一致性，而对不同应用中的类似图标有相同的预期，认为点击这个按钮将会保存现有的工作。但这一预期是由其演化历史保证的，最初的拟物化版本来自于真实的<a href=\"https://commons.wikimedia.org/wiki/File:Hand_with_floppy_disk.jpg\">3.5英寸软盘</a>：</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/04/6b6df10cd9e7f9c5053f37b15b012d04.png?wh=1000x751\" alt=\"\"></p><p>每个版本之间都有一定的连贯性，这样经历过这些版本的用户才能准确判断新版图标是干什么的。话说回来，我有采访过一些00后的同学，他们完全没见过软盘这种物体，那么这一图标的共识就被打破了。随后我们需要建立新的共识，比如iOS里的保存图标：</p><p><img src=\"https://static001.geekbang.org/resource/image/f8/d4/f83dda5833669d6fyy3ff203c9c7bdd4.png?wh=300x324\" alt=\"\"></p><p>二是<strong>Web浏览器</strong>。前端开发者在设计开发一个Web应用之前，需要清楚浏览器能做什么、不能做什么、有什么限制、有什么workaround，才能做到胸有成竹，不会答应某位PM提出的“根据用户电脑外壳颜色自动改变网页颜色”这样异想天开的需求。</p><p>浏览器会提供基本的可交互组件供开发者使用，如 <code>&lt;input type=\"checkbox\" /&gt;</code>单选框、 <code>&lt;textarea /&gt;</code> 多行文本框这样的表单元素，现代浏览器也终于支持了 <code>&lt;dialog /&gt;</code>对话框。然而看下面截图底部的组件：</p><p><img src=\"https://static001.geekbang.org/resource/image/2e/c9/2e33de03c37b77afda2f7465e04e63c9.png?wh=640x480\" alt=\"\" title=\"来源于网络\"></p><p>历史上第一个使用标签页（或称“页签”，英文为Tabs）的软件产品是Apple的HyperCard，截图是它的帮助界面。而它首次出现的时间是1987年。</p><p>标签页也是Web应用最常见的布局方式之一。然而，时至今日，众多浏览器都没有在HTML、JS里内建对标签页的支持。以至于前端开发者要反复为Web应用开发标签页这个轮子。这样的现状有什么历史原因我也不清楚，但开发者在知道类似这样的限制以后，就会在估算开发周期时把开发轮子的时间也纳入进来。</p><h2>前端领域的变与不变</h2><p>纵观历史，前端技术一直在发展，但同时也有一些技术原理是没有太大变化的。了解这些不变的东西，可以帮你在面对新技术时更从容。在这里我想以本世纪初企业级B/S应用主流的JSP技术作为参照物，与近些年的Web前端技术栈做个对比。</p><h3>模版</h3><p>JSP应用的开发是这样演化的：最初是简单的JSP文件，里面混写了一段Java代码，通过JDBC连接数据库，SQL查询到数据，然后直接在同一文件的HTML模版里混入Java变量展现出来。这样的JSP只要拷贝到Tomcat Web Container的ROOT目录中就可以工作了。</p><pre><code>// index.jsp\n&lt;html&gt;\n&lt;body&gt;\n&lt;%!\nint getCount() {\n  // JDBC ...\n  int count = /* ... */;\n  return count;\n}\n%&gt;\n  &lt;p&gt;图书数量：&lt;%= getCount() %&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\nReact也可以把逻辑和视图写在一个文件里。\n\n// main.jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n    \nconst App = () =&gt; {\n  const [count, setCount] = React.useState();\n  React.useEffect(() =&gt; {\n    (async () =&gt; {\n      const res = await fetch('/book/count');\n      // ...\n      setCount(data);\n    })();\n  }, []);\n    \n  return (\n    &lt;p&gt;图书数量：{ count }&lt;/p&gt;\n  );\n};\n   \nReactDOM.render(&lt;App /&gt;, document.getElementById('app'));\n</code></pre><p>单从代码上看，两者在HTML模版方面异曲同工。</p><h3>模版的条件和循环</h3><p>JSP页面模版上有条件或者循环逻辑时，也是可以通过混写Java代码来实现。但考虑到代码的可读性和可维护性，JSP引入了标签库，如下面的 <code>JSTL</code> 。</p><pre><code>// index.jsp\n&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;\n&lt;%\n// ...\n%&gt;\n&lt;ul&gt;\n&lt;c:forEach var=&quot;book&quot; items=&quot;${books}&quot; &gt;\n  &lt;li&gt;\n    书名：${book.title}\n    &lt;c:if test=&quot;${book.isSoldOut}&quot;&gt;\n      （已售空）\n    &lt;/c:if&gt;\n  &lt;/li&gt;\n&lt;/c:forEach&gt;\n&lt;/ul&gt;\n</code></pre><p>与React并驾齐驱的Vue.js框架，模版包含了<code>v-if</code> 、 <code>v-for</code> 指令，可以在模版中实现条件和循环。</p><pre><code>// main.vue\n&lt;script&gt;\n// ...\n&lt;/script&gt;\n  \n&lt;template&gt;\n  &lt;ul&gt;\n    &lt;li v-for=&quot;book in books&quot;&gt;\n      书名：{{ book.title }}\n      &lt;span v-if=&quot;book.isSoldOut&quot;&gt;\n        （已售空）\n      &lt;/span&gt;\n    &lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/template&gt;\n</code></pre><h3>代码分层</h3><p>当业务变得复杂后，把控制逻辑和页面展现都写在同一个JSP文件中已经无法满足项目增长的需要。这时就引入了MVC架构，JSP作为纯粹的视图，Servlet作为控制器，加上Java Bean对象作为模型。这样就解耦了三种代码，提高了可维护性和可扩展性。</p><pre><code>// BookBean.java (Model)\npublic class BookBean {\n  // ...\n}\n\n// BookController.java (Controller)\npublic class ControllerServlet extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response)  \n            throws ServletException, IOException {    \n        String isbn = request.getParameter(&quot;isbn&quot;);\n        BookBean book = new BookBean();\n        // JDBC ...\n        request.setAttribute(&quot;book&quot;, book);\n        RequestDispatcher dispatcher = request.getRequestDispatcher(&quot;book.jsp&quot;);\n        rd.forward(request, response);\n    }\n}\n   \n// book.jsp (View)\n&lt;%@page import=&quot;BookBean&quot;%&gt;\n&lt;html&gt;\n&lt;body&gt;\n&lt;%! BookBean book = (BookBean) request.getAttribute(&quot;book&quot;); %&gt;\n  &lt;p&gt;书名：&lt;%= book.getTitle() %&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>再来看三大Web前端框架的Angular是如何以MVVM架构拆分代码文件的。数据模型、HTML视图与JSP在概念上是相似的，而View-model视图模型则取代了上面JSP中控制器的地位。</p><pre><code>// book.ts (Model)\nexport default class Book {\n  // ...\n}\n\n// book.component.ts (View-model)\nimport { Component, OnInit } from '@angular/core';\nimport Book from './book.ts';\n@Component({\n  selector: 'book-detail',\n  templateUrl: './book.component.html',\n  styleUrls: ['./book.component.css']\n})\nexport class BookComponent implements OnInit {\n  title: string;\n  ngOnInit() {\n    const book = new Book();\n    // ...\n    this.title = book.title;\n  }\n}\n    \n// book.component.html (View)\n&lt;p&gt;书名：{{title}}&lt;/p&gt;\n</code></pre><p>当然，MVC和MVVM架构本是平台无关的，Java Web领域也有MVVM框架，JS前端领域也有MVC框架。</p><h3>软件分发</h3><p>当JSP项目包含 <code>.java</code> 源文件时，需要编译并与JSP文件一起打包成 <code>.war</code> 包，再部署到Tomcat 里就可以提供服务了。</p><p>虽然目标不同，但React、Vue.js、Angular项目一般而言也需要先通过Webpack、Vite等工具构建，生成若干bundle后再部署到CDN上，即可投入使用。</p><h3>项目依赖管理</h3><p>Java的技术生态是极为丰富的，可以借助第三方开源库（或闭源库）实现很多功能。JSP项目中也常会引入很多这样的依赖。在最早期，这些依赖是通过拷贝 <code>.jar</code>包到项目中引入的。当依赖项增多，依赖关系变得复杂后，Java引入了Maven工具。Maven其中一项职能就是定义、管理依赖。</p><pre><code>&lt;!-- pom.xml --&gt;\n&lt;project&gt;\n  &lt;groupId&gt;com.example.book&lt;/groupId&gt;\n  &lt;artifactId&gt;bookProject&lt;/artifactId&gt;\n  &lt;version&gt;${project1Version}&lt;/version&gt;\n  &lt;packaging&gt;jar&lt;/packaging&gt;\n \n  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;log4j&lt;/groupId&gt;\n      &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre><p>在项目构建时，Maven会从中心仓库里下载预编译好的log4j作为项目依赖。JS项目的 <code>package.json</code> 与上面的XML有类似的作用：</p><pre><code>// package.json\n{\n  &quot;name&quot;: &quot;react_test&quot;,\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;private&quot;: true,\n  &quot;dependencies&quot;: {\n    &quot;react&quot;: &quot;^18.1.0&quot;,\n    &quot;react-dom&quot;: &quot;^18.1.0&quot;\n  }\n}\n</code></pre><p>代码的<code>dependencies</code>字段表示，在执行<code>npm install</code>的时候，会从npm仓库中下载react和react-dom的NPM包，作为项目依赖。</p><h2>小结</h2><p>从上面各项对比已经可以看出，前端在这数十年中，沉淀下来的各种概念、原理、最佳实践，都会在新的前端技术中继续发扬光大。所以没有所谓“学了白学”，读书讲究“开卷有益”，学习前端技术的每个知识点、每次实践都帮你踏出坚实的一步。</p><p>下一节，我们将延续本节的思路，具体看一看React对之前的各类前端技术如何扬弃，React凭什么成为三大前端框架之首（根据NPM下载量数据）。</p><h2>思考与互动</h2><p>这节课中间提到，用户体验是前端开发的领域知识之一。你在使用别人开发的前端应用时，有没有遇到过一些奇葩的用户体验，让你吐槽难用后，还暗自下定决心：“如果是我，肯定不会开发出这么蠢的前端”？</p><p>欢迎把你的思考和想法分享在留言区，也欢迎把课程分享给你的朋友或同事，我们下节课见！</p>","neighbors":{"left":{"article_title":"开篇词｜React Web开发这样学，才能独当一面！","id":555109},"right":{"article_title":"02｜开发前端有哪些要点？React框架是如何应对的？","id":553795}}},{"article_id":553795,"article_title":"02｜开发前端有哪些要点？React框架是如何应对的？","article_content":"<p>你好，我是宋一玮，欢迎回到React组件的学习。</p><p>在上节课，我们简单回顾了一下前端开发的历史，指出前端开发领域一直在积累特有的领域知识；提出了GUI图形用户界面也是一种接口，跟后端API开发类似，前端“接口”也有自己的设计准则。然后把本世纪初的Java Web技术当作参照物，列举了前端开发领域的变与不变。希望能帮助开发者坚定持续学习的信心。</p><p>再看现状，现代前端框架有很多，前端项目的技术选型令人头疼。这时前端开发者就希望能有一些方法帮助自己做出选择，不仅是为项目选择，也为了确定自己的学习目标而选择。</p><p>React框架在诸多前端技术排行榜上均位列第一，其生态也是最丰富最活跃的。你可能会好奇：</p><ul>\n<li>React框架凭什么这么火？</li>\n<li>是不是因为React火，所以我才要学它？</li>\n<li>是不是因为React火，每个项目都无脑选它就对了？</li>\n</ul><p>在这节课，让我们回归到前端开发的本源，即模版、数据建模、交互、数据传输等等这些要点。我认为正是React在这些要点上具有优秀的设计、实践或生态，才造就了它今天的地位。</p><p>当你理解这些要点，再结合具体前端项目的需要，就可以更有信心地做出是否选型React的判断了。</p><h2>“跳伞”+“跑圈”</h2><p>你看到这个标题想到了什么？《PUBG》还是《和平精英》？啊？你从不打游戏啊，那打扰了。在玩生存类游戏时：</p><!-- [[[read_end]]] --><ul>\n<li>高手的流程为开局跳伞、落地跑圈、大吉大利；</li>\n<li>菜鸟的流程为开局跳伞、落地成盒、重开一局。</li>\n</ul><p>当然，这节课肯定不是要教你打游戏，我只是想用游戏中的概念类比一下前端开发。游戏里选用的策略和装备，基本可以体现出你是不是高手；前端开发中选择怎样的架构和技术选型，很大程度上决定了你能不能“大吉大利”。</p><p>接下来就让我们看看React在全程都起到了什么作用。</p><h2>“跳伞”：从前端架构到实现</h2><p>“跳伞”是一个从高空接近地面的过程，地面的目标由远及近、由粗到细，跳伞玩家也可以控制自己目标落地区域。软件从架构设计到具体实现跟这个过程有很多相似，单是软件架构就可以有所谓<strong>三万英尺视图</strong>（30000-Foot View）、<strong>一千英尺视图</strong>（1000-Foot View）等不同粒度的设计。</p><p>顺便提一下，三万英尺视图本来是商业战略中的概念，后被《97 Things Every Software Architect Should Know》这本合著引入到软件架构设计领域。这门课程专注于前端，所以我们跳过系统架构、软件架构等不那么“前端”的概念。</p><h3>前端应用分类</h3><p>我们先试着从最高空鸟瞰前端应用，目前主流的包含GUI的分布式应用，基本可以分成：</p><ul>\n<li>B/S应用\n<ul>\n<li>浏览器端\n<ul>\n<li>移动H5应用</li>\n<li>桌面Web应用</li>\n</ul>\n</li>\n<li>服务器端</li>\n</ul>\n</li>\n<li>C/S应用\n<ul>\n<li>客户端\n<ul>\n<li>移动端App</li>\n<li>PC客户端</li>\n</ul>\n</li>\n<li>服务器端</li>\n</ul>\n</li>\n</ul><p>近年来客户端也开始拥抱Web，衍生出基于Webview的Hybrid混合应用。</p><p>它们之间的关联关系如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/yy/5f7de8dc615819afbb073da1e85faeyy.jpg?wh=3247x1914\" alt=\"\"></p><p>看到这样的地图，结合第一节的内容，你在“跳伞”的第一时间，基本就能确定自己要往哪里跳了。是的，你的目标区域是浏览器端，这也是React框架最擅长的领域。</p><p>我们这门课主要针对浏览器端，特别是桌面浏览器。之所以定位到桌面浏览器，是考虑到相关开发调试工具更加丰富，有利于在实践中学习。课程的绝大部分内容也适用于移动端H5应用。</p><h3>前端逻辑架构</h3><p>当你跳出机舱，下降了三分之一高度时，会看清浏览器端Web应用的一部分结构。这些结构仍在逻辑层面，相对抽象，强调各个模块的层次结构和相互关系，还不涉及到技术实现。这在软件架构设计中一般被称为<strong>逻辑架构</strong>。</p><p>前端的逻辑架构，设计的重点自然是前端应用。以用户体验较好的SPA单页应用（Single Page Application）为例，下图是一张用于参考的逻辑架构图，注意这张架构图并不是通用的、四海皆准的，我们只是用它作为例子：</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/34/c5c03914ee9bf36e9f34fe9a2f8b7a34.jpg?wh=4000x2250\" alt=\"\"></p><p>在上图中，作为前端的SPA会包含若干业务功能模块，和服务器通信、前端路由、表单处理、错误处理等多种通用功能模块。通过服务器通信模块，前端会请求服务器端接口，获取或修改业务数据。服务器端即后端，一般包含入口的API网关（Gateway）、若干个后端服务，底层是数据库存储。</p><p>在架构图的两侧，展示了部分支持性质的模块。在设计阶段定义的设计系统（Design System）、响应式布局、可访问性等用户体验领域知识会支持整个前端应用的开发。在部署上线阶段，打包编译、CI/CD、自动化测试、运维工具等基础设施，会保证开发者辛辛苦苦开发的应用最终可以为用户所见、被用户使用。在运行时，用户认证（Authentication）、授权（Authorization）、前端监控、配置管理等通用模块可以支撑应用的正常运行。</p><p>你如果仔细观察会发现，这些模块在图上呈现的高度并不一致，与前端应用层也没有完全对齐。请你放心，我在画图上有些强迫症，这里是故意这么画的：</p><ul>\n<li>最右边的用户体验领域设计，是纯前端的支持模块，所以高度与前端一致，并在纵向上与前端对齐；</li>\n<li>左右两侧的部署上线基础设施和运行时模块，基本同时涵盖了前端后端，所以它们的底边都延长到与后端平齐。</li>\n</ul><p>你如果追问为什么后端底边比其他模块更低？纯粹是为了美术上的构图平衡，让图更顺眼些。</p><p>其实在业界实践中，一个相对复杂的前端应用可能会同时包含多个SPA，最终以MPA多页应用（Multi-Page Application）的形式提供给用户。当然，这并不是必须的。</p><h3>前端应用架构</h3><p>别忘了，你还在“跳伞”过程中。经过刚才的观察，你已经搞清了前端应用从逻辑上都有哪些模块。我希望你一边继续下降，一边调整方向对准SPA单页应用区域。</p><p>已经下降了三分之二高度，这时你可以看清SPA内部的一些技术细节了。这些细节更加贴近技术，但还是相对抽象的，不限定技术实现方式。这在软件架构设计中属于<strong>应用架构</strong>。</p><p>下图是典型的MVC（Model-View-Controller）应用架构的变体：</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/f9/fa5706d7d9e5de02742b3af899568ef9.jpg?wh=3464x2070\" alt=\"\"></p><p>一个“纯粹”的MVC架构，视图会触发控制器，控制器修改模型，模型再触发视图更新。常见的MVC变体，包括MVVM（Model-View-ViewModel）、MVP（Model-View-Presenter）、MVI（Model-View-Intent）。其中MVI架构最接近React社区里提倡的单向数据流。</p><p>既然是“跳伞”，那可别忘了开伞，现在是时候了。</p><h2>“跑圈”：前端技术选型与React</h2><p>好了，“跳伞”的你顺利落地了。现在开始“跑圈”。跑圈是指在有限的地面范围有目的地持续移动，造访多个目标地点、获取装备、采取各类行动；之后随着时间的推进，地面范围会逐渐缩小，你的行动也将更具挑战，之前实现的目标和积累的装备会成为你的助力，最终获胜。</p><p>软件开发中的<strong>技术选型</strong>和实现与这一过程异曲同工。软件架构要落地，其中一个重要环节就是技术选型。在前端领域，技术选型尤为重要。一般而言，前端开发交付的产品最终会<strong>运行在一个受限环境中</strong>，如浏览器、智能手机平台、Webview等，反过来就会要求<strong>前端框架也要迎合运行环境的特性</strong>，否则它有可能帮倒忙。</p><p>举个例子，浏览器里支持的脚本语言是JavaScript，但你在技术选型时第一时间选择了Go语言，那将很难开发浏览器端的交互逻辑（啊？你说Go代码编译成WebAssembly，那没事了）。</p><p>先根据“跳伞”时看到的各种模块，确定一下需要选型的前端技术点：</p><ol>\n<li>开发语言</li>\n<li>MVC或类MVC框架</li>\n<li>服务器通信</li>\n<li>表单处理</li>\n<li>错误处理</li>\n<li>前端路由</li>\n<li>打包编译工具</li>\n<li>自动化测试框架</li>\n</ol><p>暂时只列这么多。实践中根据具体应用需求不同，还会有很多其他技术点需要考虑。</p><p>下面请你跟随我，结合以上选型技术点，<strong>看React框架如何满足前端应用开发的需要。</strong></p><h3>开发语言</h3><p>无论框架怎么选，先得选好开发语言。浏览器原生支持的语言包括：文档语言<strong>HTML</strong>、样式语言<strong>CSS</strong>和脚本语言<strong>JavaScript</strong>。2019年底<strong>WebAssembly</strong>正式进入W3C标准，成为浏览器的第四种原生支持语言，不过这门课程不会涉及WebAssembly。</p><p>除了这些原生支持的语言，开发者还可以使用其他语言开发，然后编译成原生语言在浏览器中执行。如JS的超集<strong>TypeScript</strong>，语法与JS相近，支持类型系统，通过编译器编译成浏览器可执行的JS，尤其适合开发大型Web应用。再如<strong>LESS</strong>、<strong>SaSS</strong>，扩展了CSS的语法，更方便模块化，通过编译器可以编译成浏览器可解析的CSS。</p><p>关于JS，还有一个值得提的点，在浏览器JS演进过程中，厂商和技术社区合作推出了标准化的<strong>ECMAScript</strong>（简称ES），从ES6即ES2015开始，每年ES会推出一个包含少量新语法或新接口的新版本。</p><p>其中ES2015包含的新特性是最多的，随后ES2017的 <code>Async</code>/<code>Await</code> 、ES2018的对象展开语法（<code>...</code>）、ES2020的可选链操作符（<code>?.</code>）都是改变JS开发者编程习惯的重要特性。然而并不是所有浏览器的所有版本都支持最新的ECMAScript。</p><p>为了兼容用户的老浏览器，但又能充分利用新语法带来的好处，可以用Babel这样的编译器将高版本的ES代码转译成更多浏览器支持的低版本，如为了（不得不）支持已经退出历史舞台的IE11，将ES2020的代码转译成ES5。</p><p>这门课程中的样例代码将以ES2020编写。</p><h3>React对应技术点</h3><p>React框架是Meta公司前身Facebook（下称FB）于2013年开源的，声明式、组件化的前端开发框架。</p><p>首先从开发语言看，React支持ES2015以上的版本。虽然也支持ES5，但并不推荐，如果必须要支持老浏览器，那就利用Babel转译吧。同时，React对TypeScript也有很好的支持，提供了完整的类型定义。所以打算用React时，你不用担心语言支持的问题。</p><p>然后，我们不妨把React直接拉进我们的技术选型里，看看React涵盖了哪些技术点。</p><p><strong>第一，<strong><strong>MVC或类MVC框架</strong></strong>。</strong></p><p>React为视图层带来了声明式的<strong>JSX语法</strong>，这种语法是模版的同时又是JS语言本身，易学性、灵活性和性能远超其他模版引擎。</p><p>在视图之外，React设计了一套<strong>单向数据流</strong>机制进行<strong>应用状态管理</strong>。从视图事件触发状态变更，状态变更的结果汇总在一起，通过不可变数据传递给关心这些数据的视图，视图根据传入的数据决定是否重新渲染。</p><p>开发者将视图和相关逻辑声明成一个个<strong>React组件</strong>，React底层实现了一套<strong>虚拟DOM模型</strong>，它比浏览器DOM更为轻量，React靠比对新旧两个虚拟DOM来实现低成本的渲染。</p><p>这里提到的JSX语法、React组件、虚拟DOM、单向数据流，在后续课程中会一一讲解。</p><p>说句题外话，虚拟DOM作为一种抽象，并不与浏览器直接绑定，理论上可以用于其他平台。于是2015年FB开源了React Native框架，开发者们可以用JS语言，加上与React基本相同的API开发iOS和Android的原生应用。</p><p>与Hybrid应用不同，React Native的JSX会被渲染成目标平台的原生组件，进而提高性能、提升体验，这在当时也给React挣足了面子。但不像React，React Native在后来发展中经历过一些波折，被Google推出的跨端框架Flutter迎头赶上。</p><p><strong>第二，<strong><strong>表单处理</strong></strong>。</strong></p><p>React框架本身并没有提供高度抽象的表单处理组件或者接口。但在React开发者可以将HTML表单元素声明为<strong>受控组件</strong>（Controlled Components），并基于受控组件的状态数据进行表单处理。</p><p><strong>第三，<strong><strong>错误处理</strong></strong>。</strong></p><p>React没有内建处理全局错误的机制，但提供了<strong>错误边界</strong>（Error Boundaries）API，可以在组件树中实现类似<code>try...catch</code> 的功能。</p><p>受控组件、错误边界在后续的课程中会涉及到。</p><h3>React生态</h3><p>你可能会吐槽，React的功能怎么这么少？隔壁Angular可是内置了服务器通信模块和路由模块啊！</p><p>我个人认为所谓的“功能少”反而是React流行的重要原因之一。一个大而全的框架难免会落入一个窘境：学起来更累，用起来更重，定制起来也更受限。</p><p>React做好了属于自己卖点的部分：声明式、组件化、单向数据流，以及后来的Hooks，其他领域则留给第三方。用React的人越多，为React开发的第三方开源库越多；React生态越丰富，用React的人越多。这就形成了<strong>React的马太效应</strong>。</p><p>列举一些React生态：</p><ul>\n<li>类MVC框架：早期的React侧重于视图，并没有内置 <code>dispatch</code> 和 <code>reducer</code> 相关的接口，但开源社区为React设计的应用状态管理框架如雨后春笋，百家争鸣，如FB的Flux、开源的Redux、MobX等等；</li>\n<li>服务器通信：浏览器标准的<code>fetch</code> API，以及更强的React Query框架；</li>\n<li>表单处理：Formik框架、React Hook Form框架；</li>\n<li>前端路由：事实标准的 <code>react-router</code> 框架；</li>\n<li>组件样式：诸多CSS-in-JS框架，如 <code>emotion</code> ；</li>\n<li>打包编译工具：Webpack、Babel，以及包含了前者的Create-React-App脚手架；</li>\n<li>自动化测试框架：Jest、React Testing Library。</li>\n</ul><p>此外还有大批高质量的可复用组件库，如AntD、Material-UI等。这些第三方框架和工具，为React补足了开发现代Web应用缺少的功能。有些组合固定出现，以至于被开发者戏称为“React全家桶”。</p><h2>小结</h2><p>这节课我们借用“跳伞”+“跑圈”的比喻，将这门课程的范围设定在桌面Web应用，从架构层面分析了前端开发的组成部分，包括逻辑架构的SPA、业务功能模块、通用功能模块和应用架构的类MVC模式。</p><p>然后聊了技术选型阶段面对的技术点，将ES2020指定为这门课程的开发语言，也简要介绍了React框架本身和React生态的分工。</p><p>下节课我们会快速进入实践环节，请你跟着我写一个简单的React应用。</p><h2>思考与互动</h2><p>“跳伞”过程中你看到了前端逻辑架构和应用架构，里面定义的不少模块在各类前端框架中都很常见。可否请你选择一个你熟悉或者完全不熟悉的、React以外的前端框架，对照着这个框架的文档，看看框架都涵盖了哪些模块？</p><p>欢迎把你的思考和想法分享在留言区，也欢迎把课程分享给你的朋友或同事，我们下节课见！</p>","neighbors":{"left":{"article_title":"01｜身为Web前端工程师，我都在开发什么？","id":553789},"right":{"article_title":"03｜看板应用：从零开始快速搭建一个React项目","id":553817}}},{"article_id":553817,"article_title":"03｜看板应用：从零开始快速搭建一个React项目","article_content":"<p>你好，我是宋一玮。从这节课开始，我们就进入到React Web应用开发的学习。</p><p>作为前端开发者，在学习一门新技术时最常用的方法是什么？Linux操作系统的创始人Linus大神有句名言：“口说无凭，放码过来。”没错儿，上手写代码确实是最有效的方式之一。</p><p>然而我也听到过不少吐槽：</p><ul>\n<li>前端开发不应该是一边写代码，一边刷新浏览器就够了吗？</li>\n<li>为什么只想写几行代码，要配置一天的开发环境？</li>\n<li>代码在别人那里跑的好好的，为什么我这里跑不起来了？</li>\n<li>我改了几行代码，为什么页面没反应/就挂了？</li>\n</ul><p>我们需要了解一个现状，那就是现代前端开发早已结束了刀耕火种的时代，逐步向其他软件开发领域看齐。比如常被一起提到的后端开发领域，开发者们也常会抱怨配置开发环境又复杂又耗时间，同样的代码换个环境编译就会挂，等等。</p><p>现代前端的编译构建、依赖管理、CI/CD等工程化实践一应俱全，正如第1讲提到的，前端应用功能日益丰富、强大，这样的变化也是为了应对开发复杂度的攀升，但同时也带来了类似的痛点。我们即将要创建的React项目，就需要用到一系列工具链。不过这些技术，对于初学者来说确实有一定的门槛。</p><p>这时你可能会问到：“那我什么时候才可以上手写React代码？”</p><!-- [[[read_end]]] --><p>答案是“立刻”。</p><p>近十年的软件开发框架比起本世纪初那些更易于上手，其中一个重要原因是，优秀的框架会提供一些脚手架或者样板工程帮助开发者快速开始。有不少React开发者——不止初学者，更包括一些进阶者——是从Facebook（后面的课程中简称为FB）官方开源的Create React App（<a href=\"https://zh-hans.reactjs.org/docs/create-a-new-react-app.html#create-react-app\">CRA</a>）入手的。</p><p>所以在这一讲，在需要了解最少概念的前提下，我们会先快速搭建一个小型React项目跑起来。然后在第4-11讲，我们会“肢解”这个项目，将拆解出来的部分从浅到深排序，一一为你讲解，并做一些必要的实验。在第12讲结尾，你将有足够的知识从零开始，选择略有不同的技术栈，将这个React项目定制成另一个版本。从此你就可以作为“独狼”（褒义）React工程师，开展各类实践了。</p><p>现在，就让我们来开发一个React看板应用。这里的“看板”是敏捷开发里的看板（Kanban），如下图所示，是一个简单的原型图：</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/9e/5d6d3yyef5961ba4027b1d4a67ddc69e.jpg?wh=2956x1869\" alt=\"\"></p><h2>搭建环境</h2><p>你大概会怀疑自己上当了：“不是说‘立刻’吗？”</p><p>虽说脚手架工具可以帮我们省去大部分工作，但前端最基础的开发环境，Node.js还是要有的。当然，如果你的电脑里已经安装过Node.js，大可以跳过这一步，那自然就是“立刻”了。</p><p>因为Node.js的版本升级非常快，所以在安装时最好用一个Node版本管理工具，最主流的当然是nvm，nvm是基于shell开发的，在macOS和Linux上工作的很好，只可惜不支持Windows。而我最近比较喜欢以Rust开发的、跨平台的<a href=\"https://github.com/Schniz/fnm\">fnm</a>。</p><p>fnm功能与nvm类似，都可以在一套环境里安装多个版本的Node，随时按需切换，也可以根据具体项目的配置（支持nvm的  <code>.nvmrc</code>  ），半自动地切换版本。比起nvm，fnm执行效率更高，而且跨平台。无论你的开发机是macOS、Linux还是Windows，都可以在<a href=\"https://github.com/Schniz/fnm/releases\">这个地址</a>下载到对应的版本，加到 <code>PATH</code>中即可。</p><p>当然，对于macOS和Linux，更方便的方式还是打开命令行。在Mac上执行：</p><pre><code>brew install fnm\n</code></pre><p>安装成功后在你的 <code>.bashrc</code> 或 <code>.zshrc</code> 中加入以下命令，保存并重启命令行窗口：</p><pre><code>eval &quot;$(fnm env --use-on-cd)&quot;\n</code></pre><p>安装fnm后，用它安装Node最新的LTS（Long Term Support长期支持）版本：</p><pre><code>fnm install --lts\n</code></pre><p>装好Node.js后，建议你再安装一个针对前端开发的IDE。我推荐微软的<a href=\"https://code.visualstudio.com\">VSCode</a>，它为JavaScript和TypeScript提供了强大的Language Server，在语法检查、代码补全等方面十分出众，丰富的插件生态也为React前端开发提供了助力。</p><p>接着，我建议把VSCode加到命令行环境里，在VSCode菜单上点击 <code>View</code>-&gt; <code>Command Palette ...</code> -&gt; 输入<code>install code</code> -&gt; 选择提示的<code>Shell Command: Install 'code' command in PATH</code> 回车，这样在命令行里就可以通过<code>code /path/to/my/project</code> 的方式打开VSCode了。</p><p>需要提前说明的是，以下内容均以macOS为主，绝大部分操作都是兼容Windows的。</p><h2>搭建项目</h2><p>在Node.js环境下，就可以搭建React项目了。首先，我们需要在命令行创建一个工作目录，然后执行CRA命令：</p><pre><code>mkdir /Users/geektime/workspaces\ncd /Users/geektime/workspaces\nnpx create-react-app oh-my-kanban\n</code></pre><p>在看到如下提示时，React项目就顺利生成了。</p><pre><code>npx: installed 67 in 7.669s\n\nCreating a new React app in /Users/geektime/workspaces/oh-my-kanban.\n\nInstalling packages. This might take a couple of minutes.\n\n...\n\nSuccess! Created oh-my-kanban at /Users/geektime/workspaces/oh-my-kanban\nInside that directory, you can run several commands:\n\n  npm start\n    Starts the development server.\n\n  npm run build\n    Bundles the app into static files for production.\n\n  npm test\n    Starts the test runner.\n\n  npm run eject\n    Removes this tool and copies build dependencies, configuration files\n    and scripts into the app directory. If you do this, you can’t go back!\n\nWe suggest that you begin by typing:\n\n  cd oh-my-kanban\n  npm start\n\nHappy hacking!\n</code></pre><p>这时用VSCode打开这个项目，再回到命令行中执行启动命令：</p><pre><code>cd oh-my-kanban\ncode .\nnpm start\n</code></pre><p>在看到如下提示信息时，浏览器会自动弹出来，展示CRA的例子页面：</p><pre><code>Compiled successfully!\n\nYou can now view oh-my-kanban in the browser.\n\n  Local:            http://localhost:3000\n  On Your Network:  http://192.168.0.3:3000\n\nNote that the development build is not optimized.\nTo create a production build, use npm run build.\n\nwebpack compiled successfully\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/49/2c/49cc65465e87a9908038aa461dc58c2c.png?wh=2624x1424\" alt=\"\"></p><p>这时切换到IDE，可以看到 <code>src/App.js</code>的代码与目前页面内容是相符的。</p><p><img src=\"https://static001.geekbang.org/resource/image/73/c6/73861f25cb17bc1faeacae0b1aedf8c6.png?wh=2624x1424\" alt=\"\"></p><p>在此基础上，如果你对源文件稍作修改：</p><pre><code> function App() {\n   return (\n     &lt;div className=&quot;App&quot;&gt;\n       &lt;header className=&quot;App-header&quot;&gt;\n+        &lt;h1&gt;我的看板&lt;/h1&gt;\n         &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;\n         &lt;p&gt;\n</code></pre><p>这时你不需要主动刷新浏览器，页面会自动更新。</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/9e/fa9c1876a8ef98a34e5806886173309e.png?wh=2624x1424\" alt=\"\"></p><p>相比其他软件开发领域，<strong>前端开发本身会为开发者提供即时的正反馈</strong>。这就是说你每次修改一段源码，（一般而言）都能以视觉的方式验证软件的变化。你用CRA搭建的这套React环境就符合这一特征。</p><h2>添砖加瓦</h2><p>目前的项目大部分文件都是CRA自动生成的，我们暂时不去追究这些文件和代码都是干什么的，而是先聚焦到 <code>src/App.js</code> 和 <code>src/App.css</code>  这两个源文件。</p><p>有一些初级前端开发者拿到一个原型稿或视觉稿后，会先手足无措，不知道从哪里开始；当瞄准了某个功能点，又会一下子陷入到细节里面去，反而忽视了整体。</p><p>如果你也有这样的困惑，我会建议你回忆一下上学时做考试卷的场景，拿到卷子，先整体看一下有多少选择题填空题、多少大题，各分配多少时间，如果答题时间不够了哪些战略性放弃，哪些直接靠猜（笑）。</p><p>对于React应用开发，也可以用类似的思路：<strong>从整体到局部，从简单到复杂，从视图到交互，从数据到逻辑</strong>。</p><p>依照这个思路，第一步是从整体入手，搭建视图。你首先需要增加一些布局元素。从前面的原型图可以看到，oh-my-kanban的主界面是上导航下内容、内容为横向三栏的典型布局。这种布局用CSS的Flexbox可以轻易实现。</p><p>为了应用Flexbox，需要调整一下DOM结构，直接将<code>src/App.js</code> 替换为以下代码：</p><pre><code>import logo from './logo.svg';\nimport './App.css';\n\nfunction App() {\n  return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;header className=&quot;App-header&quot;&gt;\n        &lt;h1&gt;我的看板&lt;/h1&gt;\n        &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;\n      &lt;/header&gt;\n      &lt;main className=&quot;kanban-board&quot;&gt;\n        &lt;section className=&quot;kanban-column&quot;&gt;&lt;/section&gt;\n        &lt;section className=&quot;kanban-column&quot;&gt;&lt;/section&gt;\n        &lt;section className=&quot;kanban-column&quot;&gt;&lt;/section&gt;\n      &lt;/main&gt;\n    &lt;/div&gt;\n      );\n    }\n\nexport default App;\n</code></pre><p>同时，我们还需要修改<code>src/App.css</code>  ，加入flex布局属性：</p><pre><code> .App {\n+  displ ay: flex;\n+  flex-direction: column;\n+  gap: 1rem;\n+  height: 100vh;\n   text-align: center;\n }\n\n .App-logo {\n-  height: 40vmin;\n+  height: 80%;\n   pointer-events: none;\n }\n\n @media (prefers-reduced-motion: no-preference) {\n   .App-logo {\n     animation: App-logo-spin infinite 20s linear;\n   }\n }\n\n .App-header {\n+  flex: 1;\n+  margin: 1rem 1rem 0;\n+  border-radius: 1rem;\n   background-color: #282c34;\n-  min-height: 100vh;\n+  min-height: 5rem;\n   display: flex;\n-  flex-direction: row-reverse;\n+  flex-direction: row-reverse;\n   align-items: center;\n   justify-content: center;\n   font-size: calc(10px + 2vmin);\n   color: white;\n }\n</code></pre><p>并在 <code>src/App.css</code> 中追加“看板”、“看板列”两个类样式：</p><pre><code>.kanban-board {\n  flex: 10;\n  display: flex;\n  flex-direction: row;\n  gap: 1rem;\n  margin: 0 1rem 1rem;\n}\n\n.kanban-column {\n  flex: 1 1;\n  border: 1px solid gray;\n  border-radius: 1rem;\n}\n</code></pre><p>这时浏览器内的页面会自动更新，布局有了雏形：</p><p><img src=\"https://static001.geekbang.org/resource/image/c6/8d/c6792c9ba3d459d9a60bd59eca21828d.png?wh=2624x1424\" alt=\"\"></p><p>根据原型图定义，三个看板列有不同的样式代表不同的含义。那需要继续修改<code>src/App.js</code>：</p><pre><code>       &lt;/header&gt;\n       &lt;main className=&quot;kanban-board&quot;&gt;\n-        &lt;section className=&quot;kanban-column&quot;&gt;&lt;/section&gt;\n+        &lt;section className=&quot;kanban-column column-todo&quot;&gt;\n+          &lt;h2&gt;待处理&lt;/h2&gt;\n+        &lt;/section&gt;\n-        &lt;section className=&quot;kanban-column&quot;&gt;&lt;/section&gt;\n+        &lt;section className=&quot;kanban-column column-ongoing&quot;&gt;\n+          &lt;h2&gt;进行中&lt;/h2&gt;\n+        &lt;/section&gt;\n-        &lt;section className=&quot;kanban-column&quot;&gt;&lt;/section&gt;\n+        &lt;section className=&quot;kanban-column column-done&quot;&gt;\n+          &lt;h2&gt;已完成&lt;/h2&gt;\n+        &lt;/section&gt;\n       &lt;/main&gt;\n     &lt;/div&gt;\n</code></pre><p>同时在<code>src/App.css</code>末尾，为三个看板列分别加入不同的背景色样式：</p><pre><code>.kanban-column &gt; h2 {\n  margin: 0.6rem 1rem;\n  padding-bottom: 0.6rem;\n  border-bottom: 1px solid gray;\n}\n\n.column-todo {\n  background-color: #C9AF97;\n}\n\n.column-ongoing {\n  background-color: #FFE799;\n}\n\n.column-done {\n  background-color: #C0E8BA;\n}\n</code></pre><p>保存文件后，页面会更新：</p><p><img src=\"https://static001.geekbang.org/resource/image/10/f6/106070fc88225195c7c581a4e2e11af6.png?wh=2624x1424\" alt=\"\"></p><p>接下来要在看板列里加入卡片了。先从“待处理”入手，在<code>src/App.js</code>的看板列中加入一个无序列表：</p><pre><code> &lt;section className=&quot;kanban-column column-todo&quot;&gt;\n      &lt;h2&gt;待处理&lt;/h2&gt;\n      &lt;ul&gt;\n        &lt;li className=&quot;kanban-card&quot;&gt;\n          &lt;div className=&quot;card-title&quot;&gt;开发任务-1&lt;/div&gt;\n          &lt;div className=&quot;card-status&quot;&gt;22-05-22 18:15&lt;/div&gt;\n        &lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/section&gt;\n</code></pre><p>在 <code>src/App.css</code> 中加入对应的CSS，让它看起来更像卡片：</p><pre><code>.kanban-column {\n  flex: 1 1;\n  display: flex;\n  flex-direction: column;\n  border: 1px solid gray;\n  border-radius: 1rem;\n}\n\n.kanban-column &gt; ul {\n  flex: 1;\n  flex-basis: 0;\n  margin: 1rem;\n  padding: 0;\n  overflow: auto;\n}\n    \n.kanban-card {\n  margin-bottom: 1rem;\n  padding: 0.6rem 1rem;\n  border: 1px solid gray;\n  border-radius: 1rem;\n  list-style: none;\n  background-color: rgba(255, 255, 255, 0.4);\n  text-align: left;\n}\n    \n.card-title {\n  min-height: 3rem;\n}\n    \n.card-status {\n  text-align: right;\n  font-size: 0.8rem;\n  color: #333;\n}\n</code></pre><p>基本符合原型图：</p><p><img src=\"https://static001.geekbang.org/resource/image/78/6e/78b49e95b732345ac1650ef44766f86e.png?wh=2624x1424\" alt=\"\"></p><h2>循环渲染</h2><p>对照原型图，待处理列是有多张卡片的。这时有人祭出了复制粘贴大法，靠手工加入多个<code>&lt;li className=\"kanban-card\"&gt;</code>标签：</p><pre><code>&lt;section className=&quot;kanban-column column-todo&quot;&gt;\n  &lt;h2&gt;待处理&lt;/h2&gt;\n  &lt;ul&gt;\n    &lt;li className=&quot;kanban-card&quot;&gt;\n      &lt;div className=&quot;card-title&quot;&gt;开发任务-1&lt;/div&gt;\n      &lt;div className=&quot;card-status&quot;&gt;22-05-22 18:15&lt;/div&gt;\n    &lt;/li&gt;\n    &lt;li className=&quot;kanban-card&quot;&gt;\n      &lt;div className=&quot;card-title&quot;&gt;开发任务-2&lt;/div&gt;\n      &lt;div className=&quot;card-status&quot;&gt;22-05-22 18:15&lt;/div&gt;\n    &lt;/li&gt;\n    &lt;li className=&quot;kanban-card&quot;&gt;\n      &lt;div className=&quot;card-title&quot;&gt;开发任务-3&lt;/div&gt;\n      &lt;div className=&quot;card-status&quot;&gt;22-05-22 18:15&lt;/div&gt;\n    &lt;/li&gt;\n    &lt;!-- ... (省略) --&gt;\n  &lt;/ul&gt;\n&lt;/section&gt;\n</code></pre><p>从页面显示结果来看确实有效，但你一定也发现了不对劲的地方。</p><ol>\n<li>增加更多的卡片就要复制粘贴更多次吗？</li>\n<li>如果卡片的设计有任何改动，要把每张卡片的代码都修改一遍吗？</li>\n<li>我在开发阶段怎么会知道最终用户在运行时会创建多少张卡片呢？</li>\n</ol><p>是的，这样的写法违背了编程的DRY（Don’t Repeat Yourself）原则，降低了代码的可延展性、可读性。这时你可以使用<strong>循环渲染</strong>，把前面的卡片代码更新为：</p><pre><code>&lt;section className=&quot;kanban-column column-todo&quot;&gt;\n      &lt;h2&gt;待处理&lt;/h2&gt;\n      &lt;ul&gt;\n        {\n          new Array(10).fill('').map(item =&gt; (\n            &lt;li className=&quot;kanban-card&quot;&gt;\n              &lt;div className=&quot;card-title&quot;&gt;开发任务-1&lt;/div&gt;\n              &lt;div className=&quot;card-status&quot;&gt;22-05-22 18:15&lt;/div&gt;\n            &lt;/li&gt;\n          ))\n        }\n      &lt;/ul&gt;\n    &lt;/section&gt;\n</code></pre><p>这段代码里 <code>{ /* ... */ }</code> 中间的部分可以混写<strong>JS表达式</strong>。<code>new Array(10).fill('')</code> 是出于演示目的用空字符串填充一个包含10个元素的数组，数组的 <code>map()</code> 方法返回一个新的数组，这样就是一个有效的表达式。虽然这个表达式是一个循环，但你却不能混写 <code>for...of</code> 这样的循环语句。</p><p>修改后，页面更新为：</p><p><img src=\"https://static001.geekbang.org/resource/image/01/b5/01a1bc1b4b9b5c4275aa8b3cf64fceb5.png?wh=2624x1424\" alt=\"\"></p><p>接下来要同时实现两个需求：</p><ul>\n<li>10个待处理卡片的数据应该是不同的；</li>\n<li>“进行中”和“已完成”看板列也需要展示卡片。</li>\n</ul><p>这就需要将数据与展示进行拆分。在<code>src/App.js</code>头部加入三组数据和一个组件。</p><pre><code>const todoList = [\n  { title: '开发任务-1', status: '22-05-22 18:15' },\n  { title: '开发任务-3', status: '22-05-22 18:15' },\n  { title: '开发任务-5', status: '22-05-22 18:15' },\n  { title: '测试任务-3', status: '22-05-22 18:15' }\n];\nconst ongoingList = [\n  { title: '开发任务-4', status: '22-05-22 18:15' },\n  { title: '开发任务-6', status: '22-05-22 18:15' },\n  { title: '测试任务-2', status: '22-05-22 18:15' }\n];\nconst doneList = [\n  { title: '开发任务-2', status: '22-05-22 18:15' },\n  { title: '测试任务-1', status: '22-05-22 18:15' }\n];\n\n   const KanbanCard = ({ title, status }) =&gt; {\n  return (\n    &lt;li className=&quot;kanban-card&quot;&gt;\n      &lt;div className=&quot;card-title&quot;&gt;{title}&lt;/div&gt;\n      &lt;div className=&quot;card-status&quot;&gt;{status}&lt;/div&gt;\n    &lt;/li&gt;\n  );\n};\n</code></pre><p>继续修改之前的看板列代码，消费这三组数据和一个组件：</p><pre><code> &lt;main className=&quot;kanban-board&quot;&gt;\n    &lt;section className=&quot;kanban-column column-todo&quot;&gt;\n      &lt;h2&gt;待处理&lt;/h2&gt;\n      &lt;ul&gt;\n        { todoList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }\n      &lt;/ul&gt;\n    &lt;/section&gt;\n    &lt;section className=&quot;kanban-column column-ongoing&quot;&gt;\n      &lt;h2&gt;进行中&lt;/h2&gt;\n      &lt;ul&gt;\n        { ongoingList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }\n      &lt;/ul&gt;\n    &lt;/section&gt;\n    &lt;section className=&quot;kanban-column column-done&quot;&gt;\n      &lt;h2&gt;已完成&lt;/h2&gt;\n      &lt;ul&gt;\n        { doneList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }\n      &lt;/ul&gt;\n    &lt;/section&gt;\n  &lt;/main&gt;\n</code></pre><p>其中<code>{ todoList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }</code> 表达式的值是一个组件的数组，React会对这样的组件数组做循环渲染。因为 <code>App</code> 组件内部使用了 <code>KanbanCard</code> 组件，从而形成了组件层级结构（Hierarchy），我们可以称 <code>App</code> 是 <code>KanbanCard</code> 的父组件， <code>KanbanCard</code> 是 <code>App</code> 的子组件。</p><p>这时的页面是这样子的：</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/66/d08d138e27ee2bbd30d0582bbe22a266.png?wh=2624x1424\" alt=\"\"></p><p>前面看板列的CSS <code>.kanban-column &gt; ul { flex: 1; flex-basis: 0; overflow: auto; }</code>，保证了卡片增减不会改变页面高度，而是自动出现滚动条。</p><h2>处理交互和条件渲染</h2><p>到目前为止，你已经搭建好了待处理、进行中、已完成三个看板列，并利用循环渲染在每个看板列中都加入了一些看板卡片。现在该加入一些交互了。最基础的交互是为看板添加新卡片。</p><p>在<code>src/App.js</code>中 <code>KanbanCard</code>的后边插入一个新组件：</p><pre><code>const KanbanNewCard = () =&gt; {\n  return (\n    &lt;li className=&quot;kanban-card&quot;&gt;\n      &lt;h3&gt;添加新卡片&lt;/h3&gt;\n      &lt;div className=&quot;card-title&quot;&gt;\n        &lt;input type=&quot;text&quot; /&gt;\n      &lt;/div&gt;\n    &lt;/li&gt;\n  );\n};\n</code></pre><p>在待处理看板列的代码中插入这个组件，同时在顶部加入一个“添加新卡片”按钮：</p><pre><code>&lt;section className=&quot;kanban-column column-todo&quot;&gt;\n  &lt;h2&gt;待处理&lt;button&gt;&amp;#8853; 添加新卡片&lt;/button&gt;&lt;/h2&gt;\n  &lt;ul&gt;\n    &lt;KanbanNewCard /&gt;\n    { todoList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }\n  &lt;/ul&gt;\n&lt;/section&gt;\n</code></pre><p>在 <code>src/App.css</code> 中加入对应的CSS：</p><pre><code>.kanban-column &gt; h2 &gt; button {\n  float: right;\n  margin-top: 0.2rem;\n  padding: 0.2rem 0.5rem;\n  border: 0;\n  border-radius: 1rem;\n  height: 1.8rem;\n  line-height: 1rem;\n  font-size: 1rem;\n}\n    \n.card-title &gt; input[type=&quot;text&quot;] {\n  width: 80%;\n}\n</code></pre><p>这时页面会更新为：</p><p><img src=\"https://static001.geekbang.org/resource/image/df/a9/dfc780403c593559c065193a16d262a9.png?wh=2624x1424\" alt=\"\"></p><p>这里我要带着你增加几个小交互：</p><ol>\n<li>默认不显示“添加新卡片”卡片；</li>\n<li>点击顶部“添加新卡片”按钮，“添加新卡片”卡片才会出现；</li>\n<li>在出现的文本框中输入卡片标题，按回车即在待处理看板列顶部新插入一张卡片，这张卡片的标题为刚才文本框的输入；</li>\n<li>在新卡片插入同时，“添加新卡片”卡片消失，回到 1 的状态。</li>\n</ol><p>你可以先修改 <code>App</code> 组件的代码实现 1 和 2 ：</p><pre><code>   +import React, { useState } from 'react';\n        \n     //... (省略)\n      \n     function App() {\n    +  const [showAdd, setShowAdd] = useState(false);\n    +  const handleAdd = (evt) =&gt; {\n    +    setShowAdd(true);\n    +  };\n    +\n       return (\n         &lt;div className=&quot;App&quot;&gt;\n           &lt;header className=&quot;App-header&quot;&gt;\n             &lt;h1&gt;我的看板&lt;/h1&gt;\n             &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;\n           &lt;/header&gt;\n           &lt;main className=&quot;kanban-board&quot;&gt;\n             &lt;section className=&quot;kanban-column column-todo&quot;&gt;\n    -          &lt;h2&gt;待处理&lt;button&gt;&amp;#8853; 添加新卡片&lt;/button&gt;&lt;/h2&gt;\n    +          &lt;h2&gt;待处理&lt;button onClick={handleAdd}\n    +            disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;&lt;/h2&gt;\n               &lt;ul&gt;\n    -            &lt;KanbanNewCard /&gt;\n    +            { showAdd &amp;&amp; &lt;KanbanNewCard /&gt; }\n                 { todoList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }\n               &lt;/ul&gt;\n             &lt;/section&gt;\n</code></pre><p>这里使用了<strong>条件渲染</strong>，  <code>{ showAdd &amp;&amp; &lt;KanbanNewCard /&gt; }</code>  是一个简化的条件表达式，当<code>showAdd</code> 的值为 <code>false</code> 时，表达式会短路直接返回 <code>false</code> ，React不会渲染这个值，当<code>showAdd</code> 的值为 <code>true</code> 时，子组件 <code>&lt;KanbanNewCard /&gt;</code>  则会渲染出来。</p><p>那么<code>showAdd</code> 的值什么情况下会改变呢？答案是用户点击，<code>onClick={handleAdd}</code>为按钮增加了点击事件处理，点击按钮时会把状态 <code>showAdd</code> 的值由默认的 <code>false</code> 修改为 <code>true</code> 。这里提到的状态特指React的state，是一种存在于React组件内部数据，而创建状态state时使用的 <code>useState()</code> 是React的基本Hooks之一，这些概念和API这节我们暂不展开。代码生效后，交互1和2就实现了：</p><p><img src=\"https://static001.geekbang.org/resource/image/fa/91/fa29f7cd05e9c6a3c3b0c157c2e10891.gif?wh=470x350\" alt=\"\"></p><p>接下来你要实现交互3和4。先在 <code>KanbanNewCard</code> 组件中加些代码，让它成为“受控组件”：</p><pre><code>-const KanbanNewCard = () =&gt; {\n+const KanbanNewCard = ({ onSubmit }) =&gt; {\n+  const [title, setTitle] = useState('');\n+  const handleChange = (evt) =&gt; {\n+    setTitle(evt.target.value);\n+  };\n+  const handleKeyDown = (evt) =&gt; {\n+    if (evt.key === 'Enter') {\n+      onSubmit(title);\n+    }\n+  };\n+\n   return (\n     &lt;li className=&quot;kanban-card&quot;&gt;\n       &lt;h3&gt;添加新卡片&lt;/h3&gt;\n       &lt;div className=&quot;card-title&quot;&gt;\n-        &lt;input type=&quot;text&quot; /&gt;\n+        &lt;input type=&quot;text&quot; value={title}\n+          onChange={handleChange} onKeyDown={handleKeyDown} /&gt;\n       &lt;/div&gt;\n     &lt;/li&gt;\n   );\n };\n</code></pre><p>其中 <code>onChange</code> 事件处理函数将 <code>&lt;input&gt;</code> 的输入值随时更新到状态 <code>title</code> 里， <code>onKeyDown</code> 事件处理函数会监听回车键，当用户在文本框中敲击回车时，<code>title</code> 的值会传给 <code>onSubmit</code> 函数。你可能会急着问，这个<code>onSubmit</code> 函数是哪来的？答案在下面的代码里，它来自于父组件 <code>App</code>：</p><pre><code> function App() {\n   const [showAdd, setShowAdd] = useState(false);\n   const handleAdd = (evt) =&gt; {\n     setShowAdd(true);\n   };\n+  const handleSubmit = (title) =&gt; {\n+    todoList.unshift({ title, status: new Date().toDateString() });\n+    setShowAdd(false);\n+  };\n  \n   return (\n     &lt;div className=&quot;App&quot;&gt;\n      &lt;header className=&quot;App-header&quot;&gt;\n        &lt;h1&gt;我的看板&lt;/h1&gt;\n        &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;\n      &lt;/header&gt;\n       &lt;main className=&quot;kanban-board&quot;&gt;\n         &lt;section className=&quot;kanban-column column-todo&quot;&gt;\n           &lt;h2&gt;待处理&lt;button onClick={handleAdd}\n             disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;&lt;/h2&gt;\n           &lt;ul&gt;\n-            { showAdd &amp;&amp; &lt;KanbanNewCard /&gt; }\n+            { showAdd &amp;&amp; &lt;KanbanNewCard onSubmit={handleSubmit} /&gt; }\n             { todoList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }\n           &lt;/ul&gt;\n</code></pre><p>刚才<code>onSubmit</code> 函数是从父组件通过props属性传递给<code>KanbanNewCard</code> 组件的。这里提到的属性props是React组件对外的数据接口，可以传入多种数据类型，包括函数，至于props的概念本节暂不展开。</p><p>父组件把一个回调函数 <code>handleSubmit</code> 通过子组件的<code>onSubmit</code> 属性传给子组件。父组件并不需要知道子组件里面发生了什么，只需要知道一旦回调函数被调用，函数参数中就能拿到用户输入的<code>title</code> 值。这时回调函数会根据<code>title</code> 的值在待处理看板列的数组开头插入一个新卡片数据，并将控制着“添加新卡片”卡片是否显示的<code>showAdd</code> 状态值设置为 <code>false</code> 。</p><p>至此，前面定义的交互 1 至 4 均已实现。效果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/75/8f075b5aaf6842a3638814f6f3e08075.gif?wh=470x350\" alt=\"\"></p><h2>数据驱动</h2><p>至此，我们利用组件事件处理和条件渲染手法，为看板列增加了一个核心交互功能：“添加新卡片”。</p><p>现在回忆一下循环渲染和条件渲染里用到的两种数据，前者 <code>todoList</code> 数组存在所有组件的外边，而后者 <code>showAdd</code> 是在组件内部由<code>useState()</code> 创建的。那么我替你提出一个问题：既然两种数据都可以用于显示，也都可以被修改，<strong>为什么React还要专门提供状态state？</strong></p><p>请你用现在的代码做个小实验。</p><p>你面前来了一位来自互联网行业的资深PM，他向你提出把前面的交互 4 需求改成：“在新卡片插入同时，‘添加新卡片’卡片<strong>并不</strong>消失”。“至于这次修改上线的时间点嘛，3分钟内可以吗？” 开个玩笑，没有PM、没有时限，只要实现需求就好。</p><p>你很快就定位到，只要把这句注释掉，应该就可以了。代码如下：</p><pre><code> function App() {\n   const [showAdd, setShowAdd] = useState(false);\n   const handleAdd = (evt) =&gt; {\n     setShowAdd(true);\n   };\n   const handleSubmit = (title) =&gt; {\n     todoList.unshift({ title, status: new Date().toDateString() });\n-    setShowAdd(false);\n+    // setShowAdd(false);\n   };\n</code></pre><p>咦，什么情况？为什么敲完标题回车页面没变化？本来预期是插入新卡片，但这却没有发生。</p><p>其实这是React正常的行为，用一个不太严谨但很方便的说法：<strong>在组件内部改变state会让组件重新渲染</strong>，细节我们暂时不展开。前面数组的改变之所以能体现在页面上，完全是因为正巧在更新完数组后，同一组件的state有所变化，致使组件重新渲染，数组的变化搭了顺风车。</p><p>知道了这一点，你大概就知道如何修复刚改出来的Bug了。把组件外面的<code>todoList</code> 数组改为state转移到组件内部：</p><pre><code> function App() {\n   const [showAdd, setShowAdd] = useState(false);\n+  const [todoList, setTodoList] = useState([\n+    { title: '开发任务-1', status: '22-05-22 18:15' },\n+    { title: '开发任务-3', status: '22-05-22 18:15' },\n+    { title: '开发任务-5', status: '22-05-22 18:15' },\n+    { title: '测试任务-3', status: '22-05-22 18:15' }\n+  ]);\n   const handleAdd = (evt) =&gt; {\n     setShowAdd(true);\n   };\n   const handleSubmit = (title) =&gt; {\n-    todoList.unshift({ title, status: new Date().toDateString() });\n+    setTodoList(currentTodoList =&gt; [\n+      { title, status: new Date().toDateString() },\n+      ...currentTodoList\n+    ]);\n    // setShowAdd(false);\n  };\n</code></pre><p>至于为什么不能沿用之前 <code>todoList.unshift()</code> 的写法，我们以后的课程中会重点涉及。</p><p>既然把数据转移到组件内部了，那外部的 <code>const todoList = [/* ... */];</code> 就可以删掉了。接着你可以自行对 <code>ongoingList</code> 和 <code>doneList</code> 做相同的转移。</p><p>至此，你的oh-my-kanban有了一个基础版本。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/a3/21/a39b9e0519564359edfe18c59e2ac121.png?wh=2624x1424\" alt=\"\"></p><p>在三个看板列间，还有进一步的交互：</p><ol>\n<li>对于任意看板列里的任意卡片，可以用鼠标拖拽到其他的看板列；</li>\n<li>在释放拖拽时，被拖拽的卡片插入到目标看板列，并从原看板列中移除。</li>\n</ol><p>你可以独立思考一下上面的需求。目前仅仅从这一个小项目中积累的知识，大概还不足以实现。但没关系，后续我们会补上。</p><h2>小结</h2><p>在这节课，我们学到了如何利用Create React App脚手架工具快速搭建一套React项目。并从零开始，你实现了一个并不完整的、简易的看板应用。中间涉及到React的语法、循环渲染、条件渲染和交互事件处理，也让你对props和state有一个初步的印象。</p><p>对这个React项目有了感性的认识后，现在我们可以回应这节课一开始的吐槽：</p><ul>\n<li>在搭建好项目工具链后，React前端开发确实是一边写代码，一边刷新浏览器，而且是自动刷新；</li>\n<li>正因为有CRA这样优秀的脚手架工具，React的开发环境搭建起来几乎不费什么时间；</li>\n<li>代码在别人那里跑的好好的，在你这里跑不起来，首先要排查开发环境和项目搭建的问题；</li>\n<li>你改了React代码但页面没变化，有可能是你的修改没能触发React的重新渲染，这需要进一步学习React中的核心概念。</li>\n</ul><p>当然，这个看板应用的代码是比较简单甚至简陋的。在接下来的课程里，我会对这个基于CRA的项目进行解构，为你讲解其中所包含的React技术点、设计开发方法、工具链以及一些最佳实践，同时也会带着你动手实践一些关键代码。力求在这一部分课程结尾，让你有足够的知识，独立设计开发小型的React Web应用。</p><p>我们下节课再见！</p><h2>思考题</h2><ol>\n<li>好不容易写的代码，保存到你最喜欢的代码仓库吧。之后我们会做不少实验，手一抖删错代码是难免的，这时能访问到代码的历史就方便很多。</li>\n<li>在你的浏览器中安装FB官方的React Developer Tools扩展（<a href=\"https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi\">Chrome下载地址</a> / <a href=\"https://addons.mozilla.org/en-US/firefox/addon/react-devtools\">Firefox下载地址</a>），打开浏览器开发者工具，切换到组件页签，观察你的代码改动与组件树之间的联系。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/a0/b0/a004e6fc4ea55d1ea408ea12f5f0f9b0.png?wh=2624x1424\" alt=\"\"></p><p>欢迎把你的思考和想法分享在留言区，也欢迎把课程分享给你的朋友或同事，我们下节课见！</p>","neighbors":{"left":{"article_title":"02｜开发前端有哪些要点？React框架是如何应对的？","id":553795},"right":{"article_title":"04｜JSX：如何理解这种声明式语法糖？","id":559946}}},{"article_id":559946,"article_title":"04｜JSX：如何理解这种声明式语法糖？","article_content":"<p>你好，我是宋一玮。上节课我们利用Create React App（CRA）脚手架工具创建了一个React项目，并在项目中部分实现了一个简单的看板应用。在接下来的课程里，我们会把看板应用抽丝剥茧，逐一认识学习项目里涉及到的React概念和API。很自然地，我们这节课会讲到JSX语法和React组件。</p><p>有不少初学者对React的第一印象就是JSX语法，以至于会有这样的误解：</p><ul>\n<li>JSX就是React？</li>\n<li>JSX就是React组件？</li>\n<li>JSX就是另一种HTML？</li>\n<li>JSX既能声明视图，又能混入JS表达式，那是不是可以把所有逻辑都写在JSX里？</li>\n</ul><p>这些误解常会导致开发时遇到各种问题：</p><ul>\n<li>写出连续超百行、甚至近千行的JSX代码，既冗长又难维护；</li>\n<li>在JSX的标签上添加了HTML属性却不生效；</li>\n<li>JSX混入JS表达式后，页面一直报错。</li>\n</ul><p>其实只要<strong>理清了JSX和React组件的关系</strong>，这些问题自然不在话下。</p><p>总的来说，React是一套声明式的、组件化的前端框架。顾名思义，<strong>声明（动词）组件</strong>是React前端开发工作最重要的组成部分。在声明组件的代码中使用了JSX语法，JSX不是HTML，也不是组件的全部。</p><p>接下来，我们就详细展开介绍JSX和React组件。</p><!-- [[[read_end]]] --><h2>JSX是语法糖</h2><p>Web应用日益复杂，其视图中往往包含很多的控制逻辑，比如条件、循环等。以声明式开发视图，就需要把控制逻辑代码也加入到声明语句中去。而这样的代码，就对可读性、可维护性提出了挑战。</p><p>在JSX之前，前端领域有各种视图模版技术，JSP、Struts、Handlebars、Pug等，都在用各自的方法满足这些需求。那么JSX语法与其他声明式模版语法有什么异同？不用JSX可以写React吗？</p><p>我们在这节课开始时提到了React组件，组件是React开发的基本单位。在组件中，需要被渲染的内容是用 <code>React.createElement(component, props, ...children)</code> 声明的，而JSX正是<code>createElement</code>函数的语法糖。浏览器本身不支持JSX，所以在应用发布上线前，<strong>JSX源码需要工具编译成由若干</strong><code>createElement</code><strong>函数组成的JS代码，然后才能在浏览器中正常执行</strong>。至于编译工具，我们在后面的课程会有所涉及。</p><p>例如，上节课看板组件的部分JSX：</p><pre><code>&lt;header className=&quot;App-header&quot;&gt;\n  &lt;h1&gt;我的看板&lt;/h1&gt;\n&lt;/header&gt;\n</code></pre><p>编译成JS就会变成：</p><pre><code>React.createElement(&quot;header&quot;, {className: &quot;App-header&quot;},\n  React.createElement(&quot;h1&quot;, null, &quot;我的看板&quot;)\n);\n</code></pre><p>当然你也可以选择不用JSX，而是自己手写这些JS代码。这样做最显著的好处就是，这部分代码不需要针对JSX做编译，直接可以作用于浏览器。但当元素或者元素的嵌套层级比较多时，JS代码的右括号会越来越多。当你看到成篇的 <code>))))))));</code> 时，你的代码和内心会有一个先崩溃。就算IDE帮忙自动格式化，对应层级缩进，也没法减少括号嵌套的数量。</p><p>也许是因为先入为主，在Web领域，类HTML语法天生就更受欢迎。<strong>JSX提供的类HTML/XML的语法会让声明代码更加直观</strong>，在IDE的支持下，语法高亮更醒目，<strong>比起纯JS也更容易维护</strong>。相比JSX带来的开发效率的提升，编译JSX的成本基本可以忽略不计。</p><p>如果光看JSX中“X”的部分，还不足以让它和其他HTML/XML模版技术区别开来，这里还要强调一下JSX中“JS”的部分。请你回忆一下我们在上节课写的JSX代码，以里面的条件渲染为例：</p><pre><code>{ showAdd &amp;&amp; &lt;KanbanNewCard onSubmit={handleSubmit} /&gt; }\n\n我们来对比一下Java SSH（Spring+Struts2+Hibernate）技术栈里Struts2模版的写法：\n\n&lt;s:if test=&quot;showAdd&quot;&gt;\n    &lt;div&gt;KanbanNewCard ...&lt;/div&gt;\n&lt;/s:if&gt;\n</code></pre><p>可以发现两者判断条件的语义是相同的，区别是Struts2用XML定义了一套名为标签库的DSL（Domain-Specific Language，领域特定语言），由标签库提供的 <code>&lt;s:if&gt;&lt;/s:if&gt;</code>做条件渲染；而<strong>JSX则直接利用了JS语句。很明显，JS表达式能做的，JSX都能做，不需要开发者再去学习一套新的DSL</strong>。</p><p>也正是因为JSX作为语法糖足够“甜”，我们才能得到这样的结论：JSX是前端视图领域“最JS”的声明式语法，它为React的推广和流行起了至关重要的作用。</p><h2>前端开发中的声明式与命令式</h2><p>既然刚才提到了声明式（Declarative），就一定要提一下命令式（Imperative）。这两种编程范式的PK存在于软件开发的各个领域。下面的表格呢，从（非）现实世界用例、各领域代表性技术、具体JS语句三个方面，将声明式和命令式做了一个对比。</p><p><img src=\"https://static001.geekbang.org/resource/image/25/2f/250e1722bde8db58da7b49c38b4e902f.jpg?wh=4000x2250\" alt=\"\"></p><p>React是声明式的前端技术，这一点首先就体现在创建组件的视图上，无论是使用JSX语法还是直接利用<code>React.createElement()</code> 函数，都是在<strong>描述开发者期待的视图状态</strong>。开发者只需关心渲染结果，而React框架内部会实现具体的渲染过程，最终调用浏览器DOM API。</p><p>你可能会感兴趣：“除了jQuery，还有其他的前端框架是命令式的吗？”肯定是有的，但很明显，声明式才是主流。目前的三大主流前端框架，React、Vue、Angular都是声明式的。包括Flutter这样的新兴跨端框架也类似，都采用了典型的声明式API，以下是Flutter的官方例子：</p><pre><code>Widget titleSection = Container(\n  padding: const EdgeInsets.all(32),\n  child: Row(\n    children: [\n      Expanded(\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Container(\n              padding: const EdgeInsets.only(bottom: 8),\n              child: const Text('Oeschinen Lake Campground'),\n            ),\n            Text('Kandersteg, Switzerland'),\n          ],\n        ),\n      ),\n      Icon(\n        Icons.star,\n        color: Colors.red[500],\n      ),\n      const Text('41'),\n    ],\n  ),\n);\n</code></pre><p>多少有点眼熟吧。很有意思的是，从2017年开始，每年都有Flutter用户在社区中呼吁引入JSX语法（<a href=\"https://github.com/flutter/flutter/issues/11609\">#11609</a>、<a href=\"https://github.com/flutter/flutter/issues/15922\">#15922</a>、<a href=\"https://github.com/flutter/flutter/issues/70928\">#70928</a>），但这一愿望都没有实现。这又一次彰显了JSX这种语法糖的吸引力。</p><p>理解了JSX是语法糖，其真实身份是声明式的<code>React.createElement()</code> 函数，接下来我们来看看它的具体写法。</p><h2>JSX的写法和常见坑</h2><p>先回到一个简单的问题上，JSX是哪几个单词的缩写？是的，<strong>J</strong>ava<strong>S</strong>cript <strong>X</strong>ML，即在JS语言里加入类XML的语法扩展。这样我们就可以把JSX一分为二：先介绍<strong>X</strong>的部分，即标签的命名规则，支持的元素类型、子元素类型；然后是<strong>JS</strong>的部分，即JSX中都有哪里可以加入JS表达式、规则是什么，进一步回顾上节课的条件渲染和循环渲染表达式。</p><h3>JSX的基本写法</h3><p>请你回顾一下上节课 <code>src/App.js</code>的内容，我们将以<code>App</code> 组件为例，串讲一下JSX的常规写法和写JSX时常踩的坑。为了方便参考，我会在这里贴一部分<code>App</code> 组件的源码。</p><pre><code>function App() {\n  const [showAdd, setShowAdd] = useState(false);\n  const [todoList, setTodoList] = useState([]);\n  const handleAdd = (evt) =&gt; {\n    setShowAdd(true);\n  };\n  const handleSubmit = (title) =&gt; {\n    setTodoList(currentTodoList =&gt; [\n      { title, status: new Date().toDateString() },\n      ...currentTodoList\n    ]);\n    setShowAdd(false);\n  };\n\n return (\n    &lt;div className=&quot;App&quot;&gt;\n      &lt;header className=&quot;App-header&quot;&gt;\n        &lt;h1&gt;我的看板&lt;/h1&gt;\n        &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;\n      &lt;/header&gt;\n      &lt;main className=&quot;kanban-board&quot;&gt;\n        &lt;section className=&quot;kanban-column column-todo&quot;&gt;\n          &lt;h2&gt;待处理&lt;button onClick={handleAdd}\n            disabled={showAdd}&gt;&amp;#8853; 添加新卡片&lt;/button&gt;&lt;/h2&gt;\n          &lt;ul&gt;\n            { showAdd &amp;&amp; &lt;KanbanNewCard onSubmit={handleSubmit} /&gt; }\n            { todoList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }\n          &lt;/ul&gt;\n        &lt;/section&gt;\n        {/* ...省略 */}\n      &lt;/main&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre><p>虽然在写JSX时并不需要时时惦记着编译出来的<code>React.createElement()</code> 语句，但在学习时还是很有帮助的。我们来看一下JSX各个组成部分与<code>React.createElement()</code> 函数各参数的对应关系，代码如下：</p><pre><code>React.createElement(type)\nReact.createElement(type, props)\nReact.createElement(type, props, ...children)\n</code></pre><p>其中 <code>type</code> 参数是必须的，props可选，当参数数量<a href=\"#\">\\geq</a>3时，可以有一个或多个children。</p><p>以下是一个具体例子：</p><pre><code>   &lt;li className=&quot;kanban-card&quot;&gt;\n&lt;!-- ^^ ^^^^^^^^^ ^^^^^^^^^^^^^\n  type  props-key  props-value                                  --&gt;\n      &lt;div className=&quot;card-title&quot;&gt;{title}&lt;/div&gt;   &lt;!-- children --&gt;\n      &lt;div className=&quot;card-status&quot;&gt;{status}&lt;/div&gt; &lt;!-- ____|    --&gt;\n    &lt;/li&gt;\n</code></pre><p>把children中的一个成员单独来看，也是对应一条<code>createElement()</code> 语句的：</p><pre><code>   &lt;div className=&quot;card-title&quot;&gt;{title}&lt;/div&gt;\n&lt;!-- ^^^ ^^^^^^^^^ ^^^^^^^^^^^^ ^^^^^^^\n   type  props-key props-value   children --&gt;\n</code></pre><p>你可以在这个<a href=\"https://babeljs.io/repl/#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=false&corejs=3.21&spec=false&loose=false&code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=react&prettier=false&targets=&version=7.18.4&externalPlugins=&assumptions=%7B%7D\">在线Babel编译器</a>中做各种实验。</p><p>这里额外说一个大坑。当<code>App</code> 代码 <code>return</code> 语句返回JSX时，将JSX包在了一对括号 <code>( )</code> 里，这是为了避免踏入JS自动加分号的陷阱。例如：</p><pre><code>function Component() {\n  return \n    &lt;div&gt;{/*假设这行JSX语句很长，为了提升一些代码可读性才特地换行*/}&lt;/div&gt;;\n}\n</code></pre><p>放到编译器里会生成：</p><pre><code>function Component() {\n  return;\n  React.createElement(&quot;div&quot;, null);\n}\n</code></pre><p>整个函数短路了！根本不会执行到<code>React.createElement()</code> 语句。为了修正这个问题，我们需要为JSX加上括号：</p><pre><code>function Component() {\n  return (\n    &lt;div&gt;{/*假设这行JSX语句很长，为了提升一些代码可读性，特地换行*/}&lt;/div&gt;\n  );\n}\n</code></pre><p>再次编译：</p><pre><code>function Component() {\n  return React.createElement(&quot;div&quot;, null);\n}\n</code></pre><p>终于对了。</p><p>你能想象当年我和同事找Bug找了一整天，最后发现只是 <code>(</code> <code>)</code> 两个字符的问题吗？ “一朝被蛇咬，十年怕井绳。”自此，我养成了为JSX最外层加括号的习惯，甚至连单行return都会加上括号。毕竟在改老代码时，单行return有可能会改成多行，留下忘加括号的隐患。</p><h3>命名规则</h3><p>俗话说“无规矩不以成方圆”，学习JSX，就让我们从命名规则开始。</p><p>自定义React组件时，组件本身采用的变量名或者函数名，需要以大写字母开头。</p><pre><code>function MyApp() {\n//_______^\n  return (&lt;div&gt;&lt;/div&gt;);\n}\nconst KanbanCard = () =&gt; (\n//____^\n  &lt;div&gt;&lt;/div&gt;\n);\n</code></pre><p>在JSX中编写标签时，HTML元素名称均为小写字母，自定义组件首字母务必大写。</p><pre><code>   &lt;h1&gt;我的看板&lt;/h1&gt;\n&lt;!-- ^________全小写 --&gt;\n    &lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;\n&lt;!-- ^^^______全小写 --&gt;\n    &lt;button onClick={handleAdd} disabled={showAdd}&gt;添加新卡片&lt;/button&gt;\n&lt;!-- ^^^^^^___全小写 --&gt;\n\n\n    &lt;KanbanCard /&gt;\n&lt;!-- ^_____首字母大写 --&gt;\n</code></pre><p>如果你很坚持自定义组件也要全小写，那我鼓励你亲手试一下，比如 <code>&lt;camelCaseComponent /&gt;</code>。在浏览器开发者工具中定位到这个元素，你会发现React把它当成了一个不规范的HTML标签直接丢给了浏览器，而浏览器也不认识它，直接解析成 <code>&lt;camelcasecomponent&gt;&lt;/camelcasecomponent&gt;</code>。这也算是React的一种约定大于配置（Convention Over Configuration）了。</p><p>至于 <code>props</code> 属性名称，在React中使用驼峰命名（camelCase），且区分大小写，比如在 <code>&lt;FileCard filename=\"文件名\" fileName=\"另一个文件名\" /&gt;</code> 中，你可以同时传两个字母相同但大小写不同的属性 ，这与传统的HTML属性不同。</p><h3>JSX元素类型</h3><p>从前面的源码来看，我们在代表组件的函数里，返回了一整段JSX。JSX产生的每个节点都称作React元素，它是React应用的最小单元。React元素有三种基本类型：</p><ol>\n<li>React封装的DOM元素，如 <code>&lt;div&gt;&lt;/div&gt;</code>、 <code>&lt;img /&gt;</code> ，这部分元素会最终被渲染为真实的DOM；</li>\n<li>React组件渲染的元素，如<code>&lt;KanbanCard /&gt;</code> ，这部分元素会调用对应组件的渲染方法；</li>\n<li>React Fragment元素，<code>&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code> 或者简写成 <code>&lt;&gt;&lt;/&gt;</code>，这一元素没有业务意义，也不会产生额外的DOM，主要用来将多个子元素分组。</li>\n</ol><p>其他还有Portal、Suspense等类型，这节课我们先不展开。</p><p>我们会为JSX元素加入props，不同类型元素的props有所区别。</p><p>React封装的DOM元素将浏览器DOM整体做了一次面向React的标准化，比如在HTML中很容易引起混淆的<code>readonly=\"true\"</code> ，它的W3C标准应该是 <code>readonly=\"readonly\"</code> ，而常被误用的<code>readonly=\"false\"</code> 其实是无用的（谐音梗），在React JSX中就统一为 <code>readOnly={true}</code> 或 <code>readOnly={false}</code> ，更贴近JS的开发习惯。</p><p>至于前面反复出现的 <code>className=\"kanban-card\"</code> ，更多是因为 HTML标签里的<code>class</code> 是JS里的保留字，需要避开。</p><p>React组件渲染的元素，JSX中的props应该与自定义组件定义中的props对应起来；如果没有特别处理，没有对应的props会被忽略掉。这也是开发JSX时偶尔会犯的错误，在组件定义中改了props的属性名，但忘了改对应的JSX元素中的props，导致子组件拿不到属性值。</p><p>至于Fragment元素，没有props。</p><h3>JSX子元素类型</h3><p>JSX元素可以指定子元素。在之后的课程里你会看到很多子组件的概念，这里先留一个印象：<strong>子元素不一定是子组件，子组件一定是子元素</strong>。</p><p>子元素的类型包括：</p><ol>\n<li>字符串，最终会被渲染成HTML标签里的字符串；</li>\n<li>另一段JSX，会嵌套渲染；</li>\n<li>JS表达式，会在渲染过程中执行，并让返回值参与到渲染过程中；</li>\n<li>布尔值、null值、undefined值，不会被渲染出来；</li>\n<li>以上各种类型组成的数组。</li>\n</ol><h3>JSX中的JS表达式</h3><p>在JSX中可以插入JS表达式，特征是用大括号 <code>{ }</code> 包起来，主要有两个地方：</p><ol>\n<li>作为props值，如 <code>&lt;button disabled={showAdd}&gt;添加新卡片&lt;/button&gt;</code>；</li>\n<li>作为JSX元素的子元素，如 <code>&lt;div className=\"card-title\"&gt;{title}&lt;/div&gt;</code>。</li>\n</ol><p>这些表达式可以简单到原始数据类型 <code>{true}</code> 、<code>{123}</code> ，也可以复杂到一大串Lambda组成的函数表达式 <code>{ todoList.filter(card =&gt; card.title.startsWith('TODO:')).map(props =&gt; &lt;KanbanCard {...props} /&gt;) }</code> ，只要确保最终的返回值符合props值或者JSX子元素的要求，就是有效的表达式。</p><p>前面也讲到，<strong>JSX是声明式的，所以它的内部不应该出现命令式的语句</strong>，如 <code>if ... else ...</code>。当你拿不准自己写到JSX <code>{ }</code> 里的代码到底是不是表达式，可以试着把这部分代码直接赋值给一个JS变量。如果这个赋值能成功，说明它确实是表达式；如果赋值不成功，可以从如下四个方面进行检查：</p><ul>\n<li>是否有语法错误；</li>\n<li>是否使用了<code>for...of</code>的声明式变体<code>array.forEach</code> ，这个中招几率比较高；</li>\n<li>是否没有返回值；</li>\n<li>是否有返回值，但不符合props或者子元素的要求。</li>\n</ul><p>另外有个props表达式的特殊用法：属性展开， <code>&lt;KanbanCard {...props} /&gt;</code> 利用JS <code>...</code> 语法把 <code>props</code> 这个对象中的所有属性都传给 <code>KanbanCard</code> 组件。</p><p>对了，如果你想在JSX里加注释，会发现HTML注释 <code>&lt;!-- --&gt;</code>根本没法通过编译，这时需要改用 <code>{/* */}</code> 来加注释，编译时它会被识别成JS注释然后抛弃掉。</p><h3>回顾条件渲染和循环渲染</h3><p>有了上面的知识，我请你再回顾一下上节课中的条件渲染和循环渲染：</p><pre><code>{ showAdd &amp;&amp; &lt;KanbanNewCard onSubmit={handleSubmit} /&gt; }\n\n</code></pre><p>上面是一个典型的条件表达式，如果<code>showAdd</code> 为 <code>true</code> 时，会返回后面的JSX，渲染《新建看板卡片》组件；否则会返回 <code>showAdd</code> 的值，即 <code>false</code> 。根据子元素类型中描述的，<code>false</code> 值并不会被渲染出来，《新建看板卡片》组件就不会被渲染了。</p><pre><code>{ todoList.map(props =&gt; &lt;KanbanCard {...props} /&gt;) }\n</code></pre><p>上面是一个典型的数组转换表达式。当 <code>todoList</code> 为空数组时，表达式返回一个新的空数组，不会渲染出来；而当<code>todoList</code> 包含1个或更多个项目时，会返回一个JSX的数组，相当于：</p><pre><code>{[\n  &lt;KanbanCard title=&quot;开发任务-1&quot; status=&quot;22-05-22 18:15&quot; /&gt;,\n  &lt;KanbanCard title=&quot;开发任务-2&quot; status=&quot;22-05-22 18:15&quot; /&gt;\n]}\n</code></pre><h2>JSX与React组件的关系</h2><p>你终于忍不住问出这个问题：“前面课里反复提到React组件，为啥一个普普通通的<code>function App() {}</code> 函数就成组件了？”</p><p>这是个好问题！</p><p>鲁迅笔下的名人孔乙己曾说过“回字有四样写法”，巧了，React组件也是。React组件最初不是这么精简的。目前React的版本是v18，7年前的2015年React发布了两个大版本v0.13和v0.14（你可以理解成v13和v14），当时React组件的主流写法是：</p><pre><code>const KanbanCard = React.createClass({\n  render: function() {\n    return (&lt;div&gt;KanbanCard ...&lt;/div&gt;);\n  }\n});\n</code></pre><p>FB官方在v0.13中开始推广<a href=\"https://zh-hans.reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html#plain-javascript-classes\">ES6 class</a>的写法：</p><pre><code>class KanbanCard extends React.Component {\n  render() {\n    return (&lt;div&gt;KanbanCard {this.props.title}&lt;/div&gt;);\n  }\n}\n</code></pre><p>用这两种方式<strong>定义组件时，最核心的就是实现</strong> <code>render()</code> <strong>方法。</strong><code>render()</code> 方法的<strong>返回值可以是一段JSX（或对应的React元素）、原始数据类型</strong>（注：该方法在React v18以前的版本不可以返回<code>undefined</code>，否则会报错） 、<strong>其他React数据类型或者是这几种类型的数组</strong>。</p><p>除了<code>render()</code> 方法，这两种写法还能加入其他属性和方法，完整实现React组件具有的状态管理、生命周期、事件处理等功能，这些功能我们放在后续的课程里，在这里暂时不展开。所以说JSX只是React组件的一部分，这就澄清了“JSX就是React组件”这个误解。</p><p>除了前面两种写法，在v0.14，React新加入了一种更为简化的<strong>无状态函数组件</strong>（<a href=\"https://zh-hans.reactjs.org/blog/2015/10/07/react-v0.14.html#stateless-function-components\">Stateless Function Component</a>）：</p><pre><code>// ES6箭头函数\nconst KanbanCard = (props) =&gt; {\n  var title = props.title;\n  return (&lt;div&gt;KanbanCard {title}&lt;/div&gt;);\n};\n  \n// 更简单的箭头函数+参数解构\nconst KanbanCard = ({title}) =&gt; (\n  &lt;div&gt;KanbanCard {title}&lt;/div&gt;\n);\n</code></pre><p>函数的参数就是props，<strong>函数的返回值与前面两种写法中</strong><code>render()</code><strong>方法的返回值相同</strong>。这种函数组件在React Hooks尚未发布时，还不能自己处理state状态，需要在它的父组件提供状态，并通过props传递给它。虽然函数组件功能受限，但它贵在简单，受到了开发者的广泛欢迎。以至于开源社区开发了各种支持库，用诸如高阶组件的方式补足函数组件缺失的功能。</p><p>当时最出名的库莫过于<a href=\"https://github.com/acdlite/recompose\">recompose</a>，举个简单的例子：</p><pre><code>import { withState } from 'recompose';\n\nconst enhance = withState('showAdd', 'setShowAdd', false);\nconst KanbanColumn = enhance(({ showAdd, setShowAdd }) =&gt; (\n  &lt;section className=&quot;kanban-column column-todo&quot;&gt;\n    &lt;h2&gt;\n      待处理\n      &lt;button onClick={() =&gt; setShowAdd(true)}&gt;添加新卡片&lt;/button&gt;\n    &lt;/h2&gt;\n    &lt;ul&gt;\n      { showAdd &amp;&amp; &lt;KanbanNewCard /&gt; }\n    &lt;/ul&gt;\n  &lt;/section&gt;\n));\n</code></pre><p>其中可以看到 <code>KanbanColumn</code> 组件的主体是 <code>enhance</code> 参数的箭头函数组件。前面 <code>recompose</code> 的<code>withState(stateName, stateUpdaterName, initialState)</code> 函数会创建一个单一功能的高阶组件（高阶组件后面课程会讲到），它会创建名为 <code>showAdd</code> 的state，并通过props传递给作为子组件的函数组件，父子组件结合在一起，形成一个功能完整的React组件。顺便一提，后来recompose的作者还加入了React官方开发组。</p><p>到了React v16.8，Hooks正式发布，函数组件取代类组件成为了React组件的C位。题外话，对于React函数组件的流行，我在当年是有点意外的。我本人是ES6 class的死忠粉，但后来先后上手了recompose和官方的Hooks，真香。</p><p>当然，介绍这段历史并不是为了吃瓜，最重要的还是回答你刚才的问题“为啥一个普普通通的函数就成组件了” 。</p><p>简单总结一下，函数组件上位的原因包括：</p><ul>\n<li>React的哲学 <code>UI=f(state)</code> ；</li>\n<li>更彻底的关注点分离（Separation Of Concerns）；</li>\n<li>函数式编程的影响；</li>\n<li>React内部实现的不断优化；</li>\n<li>开源社区的反哺。</li>\n</ul><h2>小结</h2><p>这节课我们学习了JSX的概念和写法，同时也引出了React声明式的特性，也初步聊了一下React组件。</p><p>这时我相信你已经不会再有这节课开头的误解了：</p><ul>\n<li>\n<p>JSX就是React？</p>\n<ul>\n<li>不是。JSX只是React其中一个API，<code>createElement</code> 函数的语法糖。</li>\n</ul>\n</li>\n<li>\n<p>JSX就是React组件？</p>\n<ul>\n<li>不是。JSX是React组件渲染方法返回值的一部分，React组件还有其他的功能。</li>\n</ul>\n</li>\n<li>\n<p>JSX就是另一种HTML？</p>\n<ul>\n<li>不是。JSX本质还是JS，只是在最终渲染时才创建修改DOM。</li>\n</ul>\n</li>\n<li>\n<p>JSX既能声明视图，又能混入JS表达式，那是不是可以把所有逻辑都写在JSX里？</p>\n<ul>\n<li>可以是可以，但毕竟不能在JSX里使用命令式语句，能做的事情很有限。</li>\n</ul>\n</li>\n</ul><p>运用好JSX，可以很大程度提高你的React开发效率和效果。</p><p>下一讲，我们将趁热打铁，继续探讨React组件，从比React元素颗粒度更大的层面，认识React渲染的机制。同时也学习如何从业务和技术两方面入手，将一份原始的需求拆解为若干React组件。</p><h2>思考题</h2><p>这一讲中间举过一个Flutter的例子，提到用户希望将JSX语法引入Flutter。想请你按这个思路思考如下两个问题：</p><ol>\n<li>JSX一定得是React吗？React以外的技术能不能使用JSX？</li>\n<li>JSX一定得生成HTML吗？可以用JSX生成其他模版吗？</li>\n</ol><p>欢迎把你的想法分享在留言区，我会和你交流。相信经过你的深度思考，学习效果会更好！我们下节课再见！</p>","neighbors":{"left":{"article_title":"03｜看板应用：从零开始快速搭建一个React项目","id":553817},"right":[]}}]