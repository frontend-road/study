{"id":517514,"title":"37｜参数传递的正确方法和模板的二进制膨胀","content":"<p>你好，我是吴咏炜。</p><p>上一讲我们讨论的视图类型的对象，通常和内置类型的对象一样，是使用传值的方式来进行传参的。这种方式非常简单，也是比较推荐的 C++ 的做法，但这种方式存在对对象类型的限制。在对象比较大的时候，或者可能比较大的时候，按值传参就可能有性能问题。这包括了大部分的函数模板，除非你能预知用来实例化模板的参数。此外，还有很多对象可能是不可复制、甚至不可移动的，显然，这些对象你也不可能按值传参。此时，你就只能使用引用或指针来传参了。</p><h2>参数传递的方式</h2><p>函数的参数有入参、出参和出入参之分。入参是最常见的情况，意味着一个参数是让函数来使用的。出参表示一个参数是函数来写的，它必须是一个引用或指针，在现代 C++ 里已经较少推荐，因为返回对象（包括结构体、<code>pair</code>、<code>tuple</code> 等）往往可导致更加清晰、更加安全、同时性能也不下降的代码。出入参是一种中间情况，参数会被函数同时读和写。它也是引用或指针，常常是一个序列的对象（如 <code>vector</code> 和 <code>string</code>），里面本来就有内容，并在函数执行的过程中让函数继续往里添加内容。</p><p>对于现代 C++，非可选的出参和出入参通常使用引用方式，这样的代码写起来会更加方便。而可选的出参和出入参则一般使用指针方式，可以用空指针表示这个参数不被使用。而入参的情况就复杂多了：</p><!-- [[[read_end]]] --><ul>\n<li>如果一个入参是不可选，且它的类型为内置类型或小对象（可按两个指针的大小作初步估算），应当使用值传参的方式（<code>Obj obj</code>）：数字类型、指针类型、视图类型一般会使用这种方式。</li>\n<li>如果一个入参是不可选的，默认可使用 const 左值引用的方式（<code>const Obj&amp; obj</code>）：容器、大对象和堆上分配内存的对象一般会使用这种方式。</li>\n<li>如果一个入参是可选的，则可以使用指针传参，使用空指针表示这个参数不存在（<code>Obj* ptr</code> 或 <code>const Obj* ptr</code>）。</li>\n<li>如果一个入参是不可选、移动友好的，且在函数中需要产生一个拷贝，那可以使用值方式传参（<code>Obj obj</code>）。</li>\n</ul><p>前三种情况都比较直白，应该只有最后一种需要说明一下。使用值传参的典型情况是构造函数、赋值运算符和利用入参构造新对象的函数。我们在<a href=\"https://time.geekbang.org/column/article/169263\">第 2 讲</a>就给出过使用值传参的赋值运算符的例子。这里，我再举一个构造函数来说明一下。如果我们需要传递一个字符串给构造函数，让构造函数把它作为成员变量存下来以供后续使用和更改，那我们这个参数使用 <code>string</code> 就挺合适：</p><pre><code class=\"language-cpp\">class Obj {\npublic:\n  explicit Obj(string name)\n    : name_(move(name)) {}\n  …\n\nprivate:\n  string name_;\n};\n</code></pre><p>这样写的话，如果我们传递一个左值 <code>string</code> 给 <code>Obj</code> 构造函数的话，编译器会产生一次拷贝和一次移动，把名字写到 <code>name_</code> 里，比使用 <code>const string&amp;</code> 作为参数类型多一次移动。它的优点是当 <code>string</code> 是一个临时对象的时候（包括用户传递字符串字面量的情况），<code>Obj</code> 的构造函数会通过两次移动把名字写到 <code>name_</code> 里。这时候，如果我们使用的是 <code>const string&amp;</code> 的话，临时构造出来的 <code>string</code> 对象就不能被移动，而是白白地构造和析构了，浪费。</p><p>当然，入参也可以是右值引用，但这对于普通的函数（移动构造函数、移动赋值运算符之外）就很少见了，因为大部分情况下没有必要要求入参必须是个临时对象。同时提供左值引用和右值引用的重载是一种可能性，但除了在追求极致优化的基础库里，一般并不值得这么做。</p><p>上面说的情况都是参数类型（<code>Obj</code>）已知的情况。对于函数模板，参数类型本身可能是一个模板参数。这种情况下，我们又应该如何处理呢？</p><h3>转发引用</h3><p>实际上，基本原则跟上面仍然是类似的，除了我们需要把参数继续往下传到另外一个函数去、并且我们不知道这个参数会如何被使用的情况。这时，我们通常会使用转发引用。</p><p>转发引用的一个典型形式是在 <code>make_unique</code>、<code>make_shared</code>、<code>emplace</code> 等函数或方法里传递未知数量和类型的参数，如：</p><pre><code class=\"language-cpp\">template &lt;typename T,\n          typename... Args&gt;\nauto make_unique(Args&amp;&amp;... args)\n{\n  return unique_ptr&lt;T&gt;(\n    new T(forward&lt;Args&gt;(args)...));\n}\n</code></pre><p>刨除不常见的 const 右值的情况，我们来具体分析一下常见的三种场景（先限定单参数的情况）：</p><ul>\n<li>当给定的参数是 const 左值（如 <code>const Obj&amp;</code>）时，<code>Args</code> 被推导为 <code>const Obj&amp;</code>，这样，在引用坍缩后，<code>Args&amp;&amp;</code> 仍然是 <code>const Obj&amp;</code>。</li>\n<li>当给定的参数是非 const 左值（如 <code>Obj&amp;</code>）时，<code>Args</code> 被推导为 <code>Obj&amp;</code>，这样，在引用坍缩后，<code>Args&amp;&amp;</code> 仍然是 <code>Obj&amp;</code>。</li>\n<li>当给定的参数是右值（如 <code>Obj&amp;&amp;</code>）时，<code>Args</code> 被推导为 <code>Obj</code>，这样，<code>Args&amp;&amp;</code> 当然仍保持为 <code>Obj&amp;&amp;</code>。</li>\n</ul><p>回顾一下，我们这里要使用 <code>forward</code> 的原因是，所有的变量都是左值，因此，如果我们要保持“右值性”，就得使用强制类型转换。<code>forward</code> 所做的事情，本质上就是 <code>static_cast&lt;Args&amp;&amp;&gt;(args)</code>，右值被转换成右值引用（xvalue），左值仍保持为左值引用（由于引用坍缩）。</p><p>一般而言，转发引用之后总会跟着 <code>forward</code> 的使用。反过来，如果转发引用后面没有 <code>forward</code> 的话，则是非常可疑的（ranges 是一种常见的例外）<span class=\"orange\">[1]</span>。</p><h3>auto&amp;&amp;</h3><p>转发引用的另外一种常见用法是 <code>auto&amp;&amp;</code>。可能的场景有：</p><ul>\n<li>在变量声明中使用</li>\n<li>在泛型 lambda 表达式中使用</li>\n<li>在 C++20 的函数模板参数声明中使用</li>\n</ul><p>我们可以写：</p><pre><code class=\"language-cpp\">auto&amp;&amp; x = …;\n</code></pre><p>我们可以写：</p><pre><code class=\"language-cpp\">for (auto&amp;&amp; item : rng) {\n  …\n}\n</code></pre><p>我们也可以写：</p><pre><code class=\"language-cpp\">auto lambda = [](auto&amp;&amp; x,\n                 auto&amp;&amp; y) {\n  // 处理并返回\n};\n</code></pre><p>到了 C++20，我们还可以写：</p><pre><code class=\"language-cpp\">auto process(auto&amp;&amp; x, auto&amp;&amp; y)\n{\n  // 处理并返回\n}\n</code></pre><p>这么写着还真方便啊，也不用管参数是不是 const，及到底是左值还是右值了。爽。</p><h3>转发引用的问题</h3><p>如果你真这么觉得的话，那你显然忘了我刚写的这句话了：</p><blockquote>\n<p>一般而言，转发引用之后总会跟着 <code>forward</code> 的使用。反过来，如果转发引用后面没有 <code>forward</code> 的话，则是非常可疑的（ranges 是一种常见的例外）。</p>\n</blockquote><p>我们先抛开不谈语义问题（毕竟，如果没有副作用，语义不正确在某些时候也是可以接受的……），看看这么写有什么实际问题。</p><p>拿泛型 lambda 表达式那个例子来说，它本质上相当于下面的函数对象定义：</p><pre><code class=\"language-cpp\">struct Unnamed {\n  template &lt;typename T1,\n            typename T2&gt;\n  auto operator()(T1&amp;&amp; x,\n                  T2&amp;&amp; y) const\n  {\n    // 处理并返回\n  }\n} lambda;\n</code></pre><p>粗粗一看，似乎也没什么问题，是吧？</p><p>假设我们有下面的变量定义：</p><pre><code class=\"language-cpp\">int n;\nlong long lln;\nspan&lt;const int&gt; sp;\n</code></pre><p>问题来了：下面的表达式会产生多少个不同的特化（实例化结果）？</p><pre><code class=\"language-cpp\">lambda(n, lln);\nlambda(lln, n);\nlambda(n, 1);\nlambda(n, sp[0]);\nlambda(sp[0], lln);\n</code></pre><p>问题实际不难，我们只需要按照推导规则把参数类型一一填进去即可：</p><pre><code class=\"language-cpp\">Unnamed::operator()&lt;int&amp;, long long&amp;&gt;;\nUnnamed::operator()&lt;long long&amp;, int&amp;&gt;;\nUnnamed::operator()&lt;int&amp;, int&gt;;\nUnnamed::operator()&lt;int&amp;, const int&amp;&gt;;\nUnnamed::operator()&lt;const int&amp;, long long&amp;&gt;;\n</code></pre><p>所有的情况都是不同的，所以有五种不同的特化！这就意味着，至少从理论上来说，这五种不同的使用方式可能会产生五份不同的二进制代码。</p><h3>避免不必要的转发引用</h3><p>那这是不是真的会成为一个问题呢？这……取决于具体情况，尤其取决于代码是不是可以被良好地内联。作为一般的指导原则，消除不必要的特化是最简单的处理方式。</p><p>就我们目前这个具体例子来说，假设我们不修改入参 <code>x</code> 和 <code>y</code>，我们有两种不同的处理方式：</p><ul>\n<li>如果我们的参数只会是内置类型（如上面用到的 <code>int</code>、<code>long long</code> 等），我们可以按值传参</li>\n<li>如果我们对参数类型和大小无法确定，那使用 const 引用会是一个不错的选择</li>\n</ul><p>如果把这个例子的 <code>auto&amp;&amp;</code> 改一下：</p><pre><code class=\"language-cpp\">auto lambda = [](const auto&amp; x,\n                 const auto&amp; y) {\n  // 处理并返回\n};\n</code></pre><p>那我们至少可以把上面的五种特化缩减到三种了：</p><pre><code class=\"language-cpp\">Unnamed::operator()&lt;int, long long&gt;;\nUnnamed::operator()&lt;long long, int&gt;;\nUnnamed::operator()&lt;int, int&gt;;\n</code></pre><p>注意，我主要想说明的是我们应当避免不必要的转发引用，而不是避免所有的转发引用。特别是，如果你在 <code>auto&amp;&amp;</code> 后面需要使用 <code>forward</code> 来进行转发的话（类似于 <code>forward&lt;decltype(x)&gt;(x)</code>），那转发引用的使用通常是合适的。</p><h2>模板的二进制膨胀</h2><p>模板在带来方便和性能的同时，也可能使代码产生膨胀，这是一个需要权衡的问题。我们上一讲讲到的视图类型，实际上既可能消减二进制代码，也可能增加二进制代码。</p><p>对于像 <code>span</code> 这样的类型，它明显可以消减二进制代码。如果我们的 <code>print</code> 函数的定义改成：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nvoid print(const T&amp; rng)\n{\n  for (const auto&amp; n : rng) {\n    cout &lt;&lt; n &lt;&lt; ' ';\n  }\n  cout &lt;&lt; '\\n';\n}\n</code></pre><p>那它显然可以工作，而且还非常灵活。但是，现在当我们传递 <code>vector&lt;int&gt;</code>、<code>array&lt;int, 5&gt;</code>、<code>array&lt;int, 8&gt;</code>、<code>int[5]</code>、<code>int[8]</code> 时，那就是五种不同的特化了。如果由于任何原因 <code>print</code> 不能内联的话，我们就会生成约五倍数量的二进制代码。</p><p>而像 <code>elements_view</code> 这样的类型就反过来潜在可能会增加二进制代码。相信你目前已经能理解这个问题，我就不展开了。不过，相对其他一些不使用视图类型的方案，它在易用性和性能方面的提升，很可能大大超过了潜在的二进制膨胀的危害。</p><h3>通过退化消减二进制膨胀</h3><p>某些二进制膨胀问题不太好解决，有一些则是很容易解决的。在像传递 <code>char[8]</code>、<code>int[5]</code> 这样的参数的场景，使用指针或者 <code>span</code>（即指针加长度）往往是一种很好的替换方案。下面，我们再来看一个很具体的例子，如何高效地实现一个通用的日志函数的传参。</p><p>为了高效地传递大对象，日志函数的对外接口可能长下面这个样子：</p><pre><code class=\"language-cpp\">template &lt;typename... Args&gt;\nvoid log(log_level,\n         const Args&amp;... args);\n</code></pre><p>这里，我们用 const 左值引用传参，规避了前面说的不同引用类型的参数会带来的额外特化。但这里我们还会遇到一个常见问题：字面量 <code>\"hello\"</code> 和 <code>\"world\"</code> 被视作同一类型——<code>const char[6]</code>——但它们和 <code>\"hi\"</code>——<code>const char[3]</code>——就不是同一类型了。这时候，我们需要非引用方式传参时候的退化行为，把 <code>const char</code> 数组当作 <code>const char*</code> 处理。</p><p>我们可以简单地把目前的这个 <code>log</code> 函数模板重命名为 <code>log_impl</code>，而新增一个简单转发的 <code>log</code> 函数模板：</p><pre><code class=\"language-cpp\">template &lt;typename... Args&gt;\nvoid log(log_level level,\n         const Args&amp;... args)\n{\n  log_impl(level,\n           try_decay(args)...);\n}\n</code></pre><p>这个函数够简单，一般可以内联。即使不能内联，它会带来的额外膨胀也非常小。所以，我们只需要专心实现 <code>try_decay</code> 就行了。</p><p>这里，我们就有一定的自由度来选择到底该怎么做了。我目前的策略是这样的：</p><ul>\n<li>对于可以退化为 <code>const char*</code> 的类型，强制类型转换成 <code>const char*</code></li>\n<li>对于其他数组类型，将其转变为 <code>span</code></li>\n<li>其他情况直接完美转发</li>\n</ul><p>代码如下：</p><pre><code class=\"language-cpp\">template &lt;typename T&gt;\nconstexpr decltype(auto)\ntry_decay(T&amp;&amp; value)\n{\n  using decayed_type = decay_t&lt;T&gt;;\n  using remove_ref_type =\n    remove_reference_t&lt;T&gt;;\n  if constexpr (\n    is_same_v&lt;decayed_type,\n              const char*&gt;) {\n    return decayed_type(value);\n  } else if constexpr (\n    is_array_v&lt;remove_ref_type&gt;) {\n    return span&lt;remove_extent_t&lt;\n      remove_ref_type&gt;&gt;(value);\n  } else {\n    return forward&lt;T&gt;(value);\n  }\n}\n</code></pre><p>需要注意一下，使用转发引用的函数都潜在存在此类问题。所以，在 C++11 开始的新时代里，也并不是使用 <code>emplace_back</code> 一定比 <code>push_back</code> 更好，即使你正确使用、没有犯低级错误 <span class=\"orange\">[2]</span>。</p><h3>通过公共基类消减二进制膨胀</h3><p>除了参数类型，还有一种常见的优化类模板方法的办法，就是抽取公共基类。</p><p>类模板里通常有很多方法，一般总有些是跟模板参数相关的。但是，也常常可能存在一些方法，跟模板参数没有任何关系，或者很容易就能改造成没有关系。这类方法也是模板二进制膨胀的来源之一。</p><p>想象一下，类模板 <code>Obj&lt;T&gt;</code> 里有方法 <code>CommonMethod()</code>。当我们用不同的类型，如 <code>int</code> 和 <code>char</code>，去实例化的时候，我们就可能会编译产生方法 <code>Obj&lt;int&gt;::CommonMethod()</code> 和 <code>Obj&lt;char&gt;::CommonMethod()</code>。这是两个无关的成员函数，因此编译器一般不会为你进行优化。在你每次实例化时，编译器都会在需要用到 <code>CommonMethod</code> 时提供一份新的代码，而不会看到不同的 <code>CommonMethod</code> 实际是一样的。我们需要显式地告诉编译器，不同的 <code>CommonMethod</code> 实际上是同一份。一种通行的做法，就是把这样的方法放到一个公用的非模板基类里去。如下所示：</p><pre><code class=\"language-cpp\">class ObjBase {\npublic:\n  void CommonMethod();\n};\n\ntemplate &lt;typename T&gt;\nclass Obj : private ObjBase {\npublic:\n  // 如果 CommonMethod 是一个 Obj\n  // 需要暴露的方法\n  using ObjBase::CommonMethod;\n  …\n};\n</code></pre><p><code>Obj</code> 私有继承 <code>ObjBase</code>，这是一种实现继承关系。我们让 <code>Obj</code> 可以使用 <code>ObjBase</code> 的数据成员和方法，但不允许别人通过一个 <code>ObjBase</code> 的引用或指针来访问 <code>Obj</code>。如果 <code>CommonMethod</code> 原来是一个私有方法，那 <code>Obj</code> 现在直接使用就可以了；如果 <code>CommonMethod</code> 原来是一个公开或保护方法，那我们需要在合适的位置使用 <code>using</code> 来确保它能被调用者或子类使用。</p><p>某些标准库实现里的模板类就会使用这种方法来进行优化。</p><h2>内容小结</h2><p>本讲我讨论了两个相关问题：如何传递参数，如何减少模板的二进制膨胀。使用合适的引用方式，并合理使用退化，可以让我们产出既灵活又小巧的代码。</p><h2>课后思考</h2><p>如果一个函数的调用者应该持有一个 <code>unique_ptr</code>，函数的参数应该怎么写？</p><p>为什么目前的 <code>try_decay</code> 里面需要使用 <code>remove_reference_t</code>？两个用到的地方如果直接使用 <code>T</code> 会发生什么后果？</p><p>期待你的思考，如有任何疑问，我们留言区见！</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Arthur O’Dwyer, “‘Universal reference’ or ‘forward reference’?”. <a href=\"https://quuxplusone.github.io/blog/2022/02/02/look-what-they-need/\">https://quuxplusone.github.io/blog/2022/02/02/look-what-they-need/</a></span></p><p><span class=\"reference\">[2] Arthur O’Dwyer, “Don’t blindly prefer <code>emplace_back</code> to <code>push_back</code>”. <a href=\"https://quuxplusone.github.io/blog/2021/03/03/push-back-emplace-back/\">https://quuxplusone.github.io/blog/2021/03/03/push-back-emplace-back/</a></span></p>","neighbors":{"left":{"article_title":"36｜访问对象的代理对象：视图类型","id":513719},"right":{"article_title":"38 | 折叠表达式：高效的编译期展开","id":523170}},"comments":[]}