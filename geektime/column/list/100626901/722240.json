{"id":722240,"title":"07｜类型与类型参数：给Rust小助手提供更多信息","content":"<p>你好，我是Mike。今天我们一起来学习Rust中类型相关的知识。</p><p>这块儿知识在其他大部分语言入门材料中讲得不多，但是对于Rust而言，却是非常重要而有趣的。我们都知道，计算机硬件执行的代码其实是二进制序列。而<strong>对一个二进制值来说，正是类型赋予了它意义</strong>。</p><p>比如 01100001 这个二进制数字，同样的内存表示，如果是整数，就表示97。如果是字符，就表示 <code>'a'</code> 这个 char。如果没有类型去赋予它额外的信息，当你看到这串二进制编码时，是不知道它代表什么的。</p><h2>类型</h2><p>《Programming.with.Types》2019 这本书里对类型做了一个定义，翻译出来是这样的：类型是对数据的分类，这个分类定义了这些数据的意义、被允许的值的集合，还有能在这些数据上执行哪些操作。编译器或运行时会检查类型化过程，以确保数据的完整性，对数据施加访问限制，以及把数据按程序员的意图进行解释。</p><p>有些情况下，我们会简化讨论，把操作部分忽略掉，所以我们可以简单地<strong>把类型看作集合，这个集合表达了这个类型的实例能取到的所有可能的值</strong>。</p><h3>类型系统</h3><p>这本书里还定义了类型系统的概念。</p><p>书里是这样说的：类型系统是一套规则集——把类型赋予和施加到编程语言的元素上。这些元素可以是变量、函数和其他高阶结构。类型系统通过你在代码中提供的标注来给元素赋予类型，或者根据它的上下文隐式地推导某个元素的类型。类型系统允许在类型间做各种转换，同时禁止其他的一些转换。</p><!-- [[[read_end]]] --><p>举例来说，刚刚我们提到的类型的标注就像这种 <code>let a: u32 = 10;</code>。我们用 <code>: u32</code> 这种语法对变量a进行了标注，表明变量a的类型是 <code>u32</code> 类型。<code>u32</code> 可以转换成 <code>u64</code>。</p><pre><code class=\"language-plain\">let b = a as u64;\n</code></pre><p>但是 <code>u32</code> 不能直接转换到String上去。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let a: u32 = 10;\n&nbsp; &nbsp; let b = a as String;    // 错误的\n\n&nbsp; &nbsp; println!(\"{b}\");\n}\n</code></pre><h3>类型化的好处</h3><p>类型化有5大好处：正确性、不可变性、封装性、组合性、可读性。这5大好处中的每一个都是软件工程理论推崇的。</p><p>Rust语言非常强调<strong>类型化</strong>，它的类型系统非常严格，隐式转换非常少，在某些简单场景下甚至会引起初学者的不适。</p><p>比如下面这个代码：</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let a = 1.0f32;\n&nbsp; &nbsp; let b = 10;\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; let c = a * b;\n}\n</code></pre><p>编译错误，提示你不能将一个浮点数和一个整数相乘。</p><pre><code class=\"language-plain\">error[E0277]: cannot multiply `f32` by `{integer}`\n --&gt; src/main.rs:5:15\n  |\n5 |     let c = a * b;\n  |               ^ no implementation for `f32 * {integer}`\n  |\n  = help: the trait `Mul&lt;{integer}&gt;` is not implemented for `f32`\n  = help: the following other types implement trait `Mul&lt;Rhs&gt;`:\n            &lt;&amp;'a f32 as Mul&lt;f32&gt;&gt;\n            &lt;&amp;f32 as Mul&lt;&amp;f32&gt;&gt;\n            &lt;f32 as Mul&lt;&amp;f32&gt;&gt;\n            &lt;f32 as Mul&gt;\n</code></pre><p>初学者遇到这种情况，往往会觉得Rust过于严苛，一个很自然的操作都不让我通过，烦死了，马上就想放弃了。</p><p>当遇到这种基础类型转换错误时，可以尝试使用 <strong>as 操作符</strong>显式地将类型转成一致。</p><p>修改上述代码如下：</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let a = 1.0f32;\n&nbsp; &nbsp; let b = 10 as f32;    // 添加了 as f32\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; let c = a * b;\n}\n</code></pre><p>这段代码就可以编译通过了。</p><p>这里其实展示出Rust的一个非常明显的特点：<strong>尽可能地显式化</strong>。显式化包含两层意思。</p><ol>\n<li>不做自动隐式转换。</li>\n<li>没有内置转换策略。</li>\n</ol><p>不做自动隐式转换，可以这样来理解，比如前面的示例，当别人来看你的代码的时候，多了 <code>as f32</code> 这几个字符，他就明白你是在做类型转换，就会自然地警觉起来，分析上下文，估计出下面算出的结果是什么类型。这相当于由程序员为编译器明确地提供了一些额外的信息。</p><p>没有内置转换策略这一点，我们可以拿JavaScript社区中流传的一张梗图来对比说明。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/be/4f0c8b5269e3e03e086ca762802860be.png?wh=572x650\" alt=\"图片\" title=\"图片来源：https://www.codenong.com/cs107029540/\"></p><p>取图里的一个示例，在 JavaScript 里，<code>9 + \"1\"</code> 计算出来的结果是 <code>\"91\"</code>。这其实就涉及两个不同类型之间相加如何处理的问题。在这个问题上，JavaScript 自己内置了策略，把两个不同类型的值加起来，硬生生算出了一个结果。而当遇到 <code>91- \"1\"</code> 时，策略又变了，算出了数字 90。这些就是内置类型转换策略的体现。</p><p>而在Rust中，<code>9+\"1\"</code> 是不可能通过编译的，更不要说计算出一个神奇的结果了。如果要写出类似的代码，在Rust中可以这样做。</p><pre><code class=\"language-plain\">fn main() {\n&nbsp; &nbsp; let a = 9 + '1' as u8;\n&nbsp; &nbsp; let b = 9.to_string() + \"1\";\n}\n</code></pre><p>有没有觉得特别清晰！我们一眼就能推断出 a 和 b 的类型，a为u8类型，b为String类型。</p><p>这就是Rust的严谨，它有着严密的类型体系，在类型化上绝不含糊。它从底层到上层构建了一套完整严密的类型大厦。你的项目越大，使用Rust感觉也就越舒服，原因之一就是严谨的类型系统在为你保驾护航。</p><h2>类型作为一种约束</h2><p>前面提到，类型是变量所有可能取得的值的集合。换句话说，类型实际上限制或定义了变量的取值空间。因此，<strong>类型对于变量来说，也是一种约束</strong>。</p><p>实际上，Rust中的 : （冒号）在语法层面上就是约束。</p><p>示例：</p><pre><code class=\"language-plain\">let a: u8 = 10;\nlet b: String = \"123\".to_string();\n</code></pre><p>上述示例中，变量a被限制为只能在u8这个类型的值空间取值，也就是0到255这256个整数里的一个，而10属于这个空间。变量b被限制为只能在字符串值空间内取值。不管字符串的值空间多大（其实是无限），这些值与u8、u32这些类型的值也是不同的。</p><p>关于 : 作为约束的体现，我们会在后面的课程中不断看到。</p><h2>多种类型如何表示？</h2><p>前面我们讲到了，用一种类型来对变量的取值空间进行约束。这确实非常好，有利于程序的健壮性。但有时也会遇到这种方式不够用的场景。比如在Rust中，我们把整数分成 u8、u16、u32、u64。现在我想写一个函数，它的参数支持整数，也就是说要同时能接受u8、u16、u32、u64这几种类型的值，应该怎么办？如果只是采用前面的理论，这个需求是没法做到的。</p><p>再看另外一个实际的例子，我有一个日志函数，可以给这个函数传入数字、字符串等类型。这种需求很常见。如何让这一个日志函数同时支持数字和字符串作为参数呢？这就很头痛了。</p><p>这里实际提出了这样一个问题：<strong>在Rust语言中，有没有办法用某种方式来表示多种类型？</strong>答案是有的。</p><h2>类型参数</h2><p>在Rust语言中定义类型的时候，可以使用<strong>类型参数</strong>。比如标准库里常见的 <code> Vec&lt;T&gt;</code>，就带一个类型参数T，它可以支持不同类型的列表，如 <code>Vec&lt;u8&gt;</code>、<code>Vec&lt;u32&gt;</code>、<code>Vec&lt;String&gt;</code> 等。这里这个 T 就表示一个类型参数，在定义时还不知道它具体是什么类型。只有在使用的时候，才会对这个 T 赋予一个具体的类型。</p><p>这里这个 <code>Vec&lt;T&gt;</code>，是一个类型整体，单独拆开来讲Vec类型是没有意义的。T是 <code>Vec&lt;T&gt;</code> 中的类型参数，它其实也是信息，提供给Rust编译器使用。而带类型参数的类型整体（比如 <code>Vec&lt;T&gt;</code>）就叫做<strong>泛型</strong>（generic type）。</p><h3>结构体中的类型参数</h3><p>我们来看一个例子，自定义一个结构体 <code>Point&lt;T&gt;</code>。</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n</code></pre><p>这是一个二维平面上的点，由x、y两个坐标轴来定义。因为x、y的取值有可能是整数，也有可能是浮点数，甚至有可能是其他值，比如无穷精度的类型。所以我们定义一个类型参数 T，定义的时候需要把T放在结构体类型名字后面，用 <code>&lt;&gt;</code> 括起来，也就是 <code>struct Point&lt;T&gt;</code>。这里的 <code>Point&lt;T&gt;</code> 整体就成为了泛型。然后，标注 x 和 y 分量的类型都是 T。可以看到，T占据了冒号后面定义类型的位置。所以说它是<strong>占位类型</strong>也没有问题。</p><p>对这个结构体的例子来说，其实还隐藏了一个很重要的细节：x和y字段的类型都是T，意味着 x 和 y 两个分量的类型是一样的。</p><p>我们来看这个Point结构体类型如何实例化。</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };     // 一个整数point\n    let float = Point { x: 1.0, y: 4.0 };    // 一个浮点数point\n}\n</code></pre><p>符合我们预期，正常编译通过。那如果实例化的时候，给x和y赋予不同的类型值会怎样呢？我们来试试。</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let wont_work = Point { x: 5, y: 4.0 };\n}\n\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:7:38\n  |\n7 |     let wont_work = Point { x: 5, y: 4.0 };\n  |                                      ^^^ expected integer, found floating-point number\n</code></pre><p>编译器正确地指出了问题，说期望整数却收到了浮点数，所以不通过。<br>\n这里有个细节，那就是编译器对 <code>Point&lt;T&gt;</code> 中的T参数进行了推导，因为它首先遇到的是x的值 5，是一个整数类型，因此编译器就把 T 具体化成了整数类型（具体哪一种还没说，不过在这里不重要），当再收到y分量的值的时候，发现是浮点数类型，和刚才的整数类型不一致了。而Point中定义的时候，又要求x和y的类型是相同的，这个时候就产生了冲突，于是报错。</p><p>那么，如何解决这个问题呢？Rust并没有限制我们只能定义一个类型参数呀！定义多个就好了，把x分量和y分量定义成不同的参数化类型。</p><pre><code class=\"language-plain\">struct Point&lt;T, U&gt; {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}\n</code></pre><p>像这样，代码就可以顺利通过编译了。</p><p>再次强调，前面两个示例里的 <code>Point&lt;T&gt;</code> 和 <code>Point&lt;T, U&gt;</code> 都是一个类型整体。这个时候，你把 Point 这个符号本身单独拿出来是没有意义的。</p><p>在使用的时候，可以用turbofish语法 <code>::&lt;&gt;</code> 明确地给泛型，或者说是给Rust编译器提供类型参数信息，我们修改一下上面两个示例。</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n&nbsp; &nbsp; x: T,\n&nbsp; &nbsp; y: T,\n}\n\nfn main() {\n&nbsp; &nbsp; let integer = Point::&lt;u32&gt; { x: 5, y: 10 };&nbsp; &nbsp; &nbsp;\n&nbsp; &nbsp; let float = Point::&lt;f32&gt; { x: 1.0, y: 4.0 };&nbsp; &nbsp; \n}\n</code></pre><pre><code class=\"language-plain\">struct Point&lt;T, U&gt; {\n&nbsp; &nbsp; x: T,\n&nbsp; &nbsp; y: U,\n}\n\nfn main() {\n&nbsp; &nbsp; let both_integer = Point::&lt;u32, u32&gt; { x: 5, y: 10 };\n&nbsp; &nbsp; let both_float = Point::&lt;f32, f32&gt; { x: 1.0, y: 4.0 };\n&nbsp; &nbsp; let integer_and_float = Point::&lt;u32, f32&gt; { x: 5, y: 4.0 };\n}\n</code></pre><p>注意，使用时提供类型参数信息用的是<code>::&lt;&gt;</code>，而定义类型参数的时候只用到<code>&lt;&gt;</code>，注意它们的区别。Rust把定义和使用两个地方通过语法明确地区分开了，而有的语言并没有区分这两个地方。</p><p>到这里，我们会体会到，类型参数存在两个过程，<strong>一个是定义时，一个是使用时</strong>。这两个过程的区分很重要。这里所谓的“使用时”，仍然是在编译期进行分析的，也就是分析你在代码的某个地方用到了这个带类型参数的类型，然后把这个参数具体化，从而形成一个最终的类型版本。</p><p>比如 <code>Point&lt;T&gt;</code> 类型的具化类型可能是 <code>Point&lt;u32&gt;</code>、<code>Point&lt;f32&gt;</code> 等等；<code>Point&lt;T, U&gt;</code> 类型的具化类型可能是 <code>Point&lt;u32, u32&gt;</code>、<code>Point&lt;u32, f32&gt;</code>、<code>Point&lt;f32, u32&gt;</code>、<code>Point&lt;f32, f32&gt;</code> 等等。到底有多少种具化版本，是看你在后面代码使用时，会用到多少种不同的具体类型。这个数目是由编译器自动帮我们计算展开的。</p><p>这种在编译期间完成的类型展开成具体版本的过程，被叫做<strong>编译期单态化。</strong>单态化的意思就是把处于混沌未知的状态具体化到一个单一的状态。</p><h3>在泛型上做impl</h3><p>当类型是一个泛型时，要对其进行impl的话，需要处理类型参数，形式相比于我们在<a href=\"https://time.geekbang.org/column/article/720991\">第 5 讲</a>讲到的impl 结构体，有一点变化。这里我们还是用  <code>Point&lt;T&gt;</code> 举例。</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n&nbsp; &nbsp; x: T,\n&nbsp; &nbsp; y: T,\n}\n\nimpl&lt;T&gt; Point&lt;T&gt; {        // 注意这一行\n&nbsp; &nbsp; fn play(n: T) {}      // 注意这一行\n}\n</code></pre><p>在对 <code>Point&lt;T&gt;</code> 做 impl 的时候，需要在 impl 后面加一个 <code>&lt;T&gt;</code>，表示在impl 的 block 中定义类型参数T，供impl block中的元素使用，这些元素包括： <code>impl&lt;T&gt; Point&lt;T&gt;</code> 里 <code>Point&lt;T&gt;</code> 中的T和整个 impl 的花括号body中的代码，如 <code>play()</code> 函数的参数就用到了这个T。</p><p>有一个细节需要注意：<code>struct Point&lt;T&gt;</code> 里 <code>Point&lt;T&gt;</code> 中的 T 是定义类型参数T，<code>impl&lt;T&gt; Point&lt;T&gt;</code> 中的 <code>Point&lt;T&gt;</code> 中的T是使用类型参数T，这个T是在impl后面那个尖括号中定义的。</p><p>在对泛型做了 impl 后，对其某一个具化类型继续做 impl 也是可以的，比如：</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n&nbsp; &nbsp; x: T,\n&nbsp; &nbsp; y: T,\n}\n\nimpl&lt;T&gt; Point&lt;T&gt; {\n&nbsp; &nbsp; fn play(n: T) {}\n}\n\nimpl Point&lt;u32&gt; {      // 这里，对具化类型 Point&lt;u32&gt; 继续做 impl\n&nbsp; &nbsp; fn doit() {}\n}\n</code></pre><p>下面我们来看具体场景中的类型参数的使用。</p><h3>枚举中的类型参数</h3><p>前面讲过，枚举的变体可以挂载任意其他类型作为负载。因此每个负载的位置，都可以出现类型参数。比如最常见的两个枚举，<code>Option&lt;T&gt;</code> 与 <code>Result&lt;T, E&gt;</code>，就是泛型。</p><p><code>Option&lt;T&gt;</code> 用来表示有或无。</p><pre><code class=\"language-plain\">enum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n</code></pre><p><code>Result&lt;T, E&gt;</code> 用来表示结果，正确或错误。Ok变体带类型参数T，Err变体带类型参数E。</p><pre><code class=\"language-plain\">enum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre><p>我们后面会详细阐述 <code>Option&lt;T&gt;</code> 和 <code>Result&lt;T, E&gt;</code> 的用法。</p><p>现在再看一个更复杂的枚举中带类型参数的例子。</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nenum Aaa&lt;T, U&gt; {\n    V1(Point&lt;T&gt;),\n    V2(Vec&lt;U&gt;),\n}\n</code></pre><p>我们来解释一下，枚举 <code>Aaa&lt;T, U&gt;</code> 的变体 V1 带了一个 <code>Point&lt;T&gt;</code> 的负载，变体V2带了一个 <code>Vec&lt;U&gt;</code> 的负载。由于出现了两个类型参数T和U，所以需要在Aaa后面的尖括号里定义这两个类型参数。</p><p>实际上，类型参数也是一种复用代码的方式，可以让写出的代码更紧凑。下面我们来看具体的应用场景。</p><h3>函数中的类型参数</h3><p>需求是这样的：很多不同的类型，其实它们实现某个逻辑时，逻辑是一模一样的。因此如果没有类型参数，就得对每个具体的类型重新实现一次同样的逻辑，这样就显得代码很臃肿。重复的代码也不好维护，容易出错。</p><p>示例：</p><pre><code class=\"language-plain\">struct PointU32 {\n&nbsp; &nbsp; x: u32,\n&nbsp; &nbsp; y: u32,\n}\n\nstruct PointF32 {\n&nbsp; &nbsp; x: f32,\n&nbsp; &nbsp; y: f32,\n}\n\nfn print_u32(p: PointU32) {\n&nbsp; &nbsp; println!(\"Point {}, {}\", p.x, p.y);\n}\n\nfn print_f32(p: PointF32) {\n&nbsp; &nbsp; println!(\"Point {}, {}\", p.x, p.y);\n}\n\nfn main() {\n&nbsp; &nbsp; let p = PointU32 {x: 10, y: 20};\n&nbsp; &nbsp; print_u32(p);\n\n&nbsp; &nbsp; let p = PointF32 {x: 10.2, y: 20.4};\n&nbsp; &nbsp; print_f32(p);\n}\n</code></pre><p>上面示例中，因为我们没有使用类型参数，那就得针对不同的字段类型（u32，f32）分别定义结构体（PointU32，PointF32）和对应的打印函数（print_u32，print_f32），并分别调用。</p><p>而有了类型参数的话，这样的需求代码只需要写一份，让编译器来帮我们分析到时候要应用到多少种不同的类型上。</p><p>上面的代码可以优化成这样：</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n&nbsp; &nbsp; x: T,\n&nbsp; &nbsp; y: T,\n}\n\nfn print&lt;T: std::fmt::Display&gt;(p: Point&lt;T&gt;) {\n&nbsp; &nbsp; println!(\"Point {}, {}\", p.x, p.y);\n}\n\nfn main() {\n&nbsp; &nbsp; let p = Point {x: 10, y: 20};\n&nbsp; &nbsp; print(p);\n\n&nbsp; &nbsp; let p = Point {x: 10.2, y: 20.4};\n&nbsp; &nbsp; print(p);\n}\n</code></pre><p>是不是清爽多了！</p><p>实际上，清爽只是我们看到的样子。在编译的时候，Rust编译器会帮助我们把这种泛型代码展开成前面那个示例的样子。这种脏活累活，Rust编译器帮我们完成了。</p><p>细心的你可能发现了，print函数的类型参数在定义的时候，多了一个东西。</p><pre><code class=\"language-plain\">fn print&lt;T: std::fmt::Display&gt;(p: Point&lt;T&gt;) {\n</code></pre><p>这里 <code>T: std::fmt::Display</code> 的意思是要求 T 满足某些条件/约束。这里具体来说就是 T 要满足可以被打印的条件。因为我们这个函数的目的是把 x 和 y 分量打印出来，那么它确实要能被打印才行，比如得能转换成人类可见的某种格式。</p><p>关于这种约束，我们后面会详细讲述。</p><h3>方法中的类型参数</h3><p>结构体中可以有类型参数，函数中也可以有类型参数，它们组合起来，方法上当然也可以有类型参数。</p><p>示例：</p><pre><code class=\"language-plain\">struct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nimpl&lt;T&gt; Point&lt;T&gt; {          // 在impl后定义impl block中要用到的类型参数\n    fn x(&amp;self) -&gt; &amp;T {     // 这里，在方法的返回值上使用了这个类型参数\n        &amp;self.x\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n    println!(\"p.x = {}\", p.x());\n}\n// 输出 \np.x = 5\n</code></pre><p>上面的示例中，<code>Point&lt;T&gt;</code> 的方法 <code>x()</code> 的返回值类型就是 &amp;T，使用到了 <code>impl&lt;T&gt;</code> 这里定义的类型参数T。</p><p>下面我们继续看更复杂的内容，方法中的类型参数和结构体中的类型参数可以不同。</p><pre><code class=\"language-plain\">struct Point&lt;X1, Y1&gt; {\n&nbsp; &nbsp; x: X1,\n&nbsp; &nbsp; y: Y1,\n}\n\n// 这里定义了impl block中可以使用的类型参数X3, Y3，\nimpl&lt;X3, Y3&gt; Point&lt;X3, Y3&gt; {\n&nbsp; &nbsp; // 这里单独为mixup方法定义了两个新的类型参数 X2, Y2\n&nbsp; &nbsp; // 于是在mixup方法中，可以使用4个类型参数：X3, Y3, X2, Y2\n&nbsp; &nbsp; fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X3, Y2&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; Point {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x: self.x,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y: other.y,\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let p1 = Point { x: 5, y: 10.4 };\n&nbsp; &nbsp; let p2 = Point { x: \"Hello\", y: 'c' };\n\n&nbsp; &nbsp; let p3 = p1.mixup(p2);\n\n&nbsp; &nbsp; println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}\n\n// 输出 \np3.x = 5, p3.y = c\n</code></pre><p>可以看到，我们在 <code>Point&lt;X3, Y3&gt;</code> 的方法 <code>mixup()</code> 上新定义了两个类型参数X2、Y2，于是在 <code>mixup()</code> 方法中，可以同时使用4个类型参数：X2、Y2、X3、Y3。你可以品味一下这个示例，不过这种复杂情况，现在的你只需要了解就可以了。</p><p>接下来我们来聊一聊Rust里的类型体系构建方法。</p><h2>类型体系构建方法</h2><p>类型体系构建指的是如何从最底层的小砖块开始，通过封装、组合、集成，最后修建成一座类型上的摩天大楼。在Rust里，主要有四大基础设施参与这个搭建的过程。</p><ul>\n<li>struct 结构体</li>\n<li>enum 枚举</li>\n<li>洋葱结构</li>\n<li>type 关键字</li>\n</ul><h3>struct和enum</h3><p>struct是Rust里把简单类型组合起来的主要结构。struct里的字段可以是基础类型，也可以是其他结构体或枚举等复合类型，这样就可以一层一层往上套。结构体struct表达的是一种元素间同时起作用的结构。</p><p>而枚举enum表达的是一种元素间在一个时刻只有一种元素起作用的结构。因此枚举类型特别适合做配置和类型聚合之类的工作。</p><p>你可以看一下下面的综合示例，它是对某个学校的数学课程建模的层级模型。</p><pre><code class=\"language-plain\">struct Point(u32, u32);  // 定义点\n\nstruct Rectangle {  // 长方形由两个点决定\n  p1: Point,\n  p2: Point,\n}\n\nstruct Triangle(Point, Point, Point);  // 三角形由三个点组成\n\nstruct Circle(Point, u32);  // 圆由点和半径组成\n\nenum Shape {   // 由枚举把长方形，三角形和圆形聚合在一起\n  Rectangle(Rectangle),\n  Triangle(Triangle),\n  Circle(Circle),\n}\n\nstruct Axes;   // 定义坐标\n\nstruct Geometry {    // 几何学由形状和坐标组成\n  shape: Shape,\n  axes: Axes,\n}\n\nstruct Algebra;      // 定义代数\n\nenum Level {         // 定义学校的级别\n  Elementary,        // 小学\n  Secondary,         // 初中\n  High,              // 高中\n}\n\nenum Course {          // 数学要学习几何和代数，由枚举来聚合\n  Geometry(Geometry),\n  Algebra(Algebra),\n}\n\nstruct MathLesson {      // 定义数学课程，包括数学的科目和级别\n  math: Course,\n  level: Level,\n}\n</code></pre><p>请根据注释认真体会其中类型的层级结构。你甚至可以试着去编译一下上述代码，看看是不是可以编译通过。</p><p><span class=\"reference\">偷偷告诉你答案：是可以通过的！</span></p><h3>newtype</h3><p>结构体还有一种常见的封装方法，那就是用单元素的元组结构体。比如定义一个列表类型 <code>struct List(Vec&lt;u8&gt;);</code>。它实际就是 <code>Vec&lt;u8&gt;</code> 类型的一个新封装，相当于给里面原来那种类型取了一个新名字，同时也把原类型的属性和方法等屏蔽起来了。</p><p>有时，你还可以看到没有具化类型参数的情形。</p><pre><code class=\"language-plain\">struct List&lt;T&gt;(Vec&lt;T&gt;);\n</code></pre><p>这种模式非常常见，于是业界给它取了个名字，叫做 newtype 模式，意思是用新的类型名字替换里面原来那个类型名字。</p><h3>洋葱结构</h3><p>Rust中的类型还有另外一种构建方法——洋葱结构。我们来看一个示例，注意代码里的type关键字在这里的作用是把一个类型重命名，取了一个更短的名字。</p><pre><code class=\"language-plain\">// 你可以试着编译这段代码\nuse std::collections::HashMap;\n\ntype AAA = HashMap&lt;String, Vec&lt;u8&gt;&gt;;\ntype BBB = Vec&lt;AAA&gt;;\ntype CCC = HashMap&lt;String, BBB&gt;;\ntype DDD = Vec&lt;CCC&gt;;\ntype EEE = HashMap&lt;String, DDD&gt;;\n</code></pre><p>最后EEE展开就是这样的：</p><pre><code class=\"language-plain\">HashMap&lt;String, Vec&lt;HashMap&lt;String, Vec&lt;HashMap&lt;String, Vec&lt;u8&gt;&gt;&gt;&gt;&gt;&gt;;\n</code></pre><p>可以看到，尖括号的层数很多，像洋葱一样一层一层的，因此叫洋葱类型结构。只要你开心，你可以把这个层次无限扩展下去。</p><p>我们再来看一个结合 newtype 和 struct 的更复杂的示例。</p><pre><code class=\"language-plain\">use std::collections::HashMap;\n\nstruct AAA(Vec&lt;u8&gt;);\nstruct BBB {\n&nbsp; hashmap: HashMap&lt;String, AAA&gt;\n}\nstruct CCC(BBB);\ntype DDD = Vec&lt;CCC&gt;;\ntype EEE = HashMap&lt;String, Vec&lt;DDD&gt;&gt;;\n\n最后，EEE展开就类似下面这样（仅示意，无法编译通过）\nHashMap&lt;String, Vec&lt;Vec&lt;CCC(BBB {hashmap: HashMap&lt;String, AAA&lt;Vec&lt;u8&gt;&gt;&gt;})&gt;&gt;&gt;\n</code></pre><p>可以看到，洋葱结构在嵌套层级多了之后，展开是相当复杂的。</p><h3>type关键字</h3><p>type关键字很重要，它的作用是在洋葱结构表示太长了之后，把一大串类型的表达简化成一个简短的名字。在Rust中使用type关键字，可以使类型大厦的构建过程变得清晰可控。</p><p>type关键字还可以处理泛型的情况，比如：</p><pre><code class=\"language-plain\">type MyType&lt;T&gt; = HashMap&lt;String, Vec&lt;HashMap&lt;String, Vec&lt;HashMap&lt;String, Vec&lt;T&gt;&gt;&gt;&gt;&gt;&gt;;\n</code></pre><p>因为最里面那个是类型 <code>Vec&lt;T&gt;</code>，T 类型参数还在。因此给这个洋葱类型重命名的时候，需要把这个 T 参数带上，于是就变成了 <code>MyType&lt;T&gt;</code>。</p><p>这种写法在标准库里很常见，最佳示例就是关于各种 <code>Result*</code> 的定义。</p><p>在 <code>std::io</code> 模块里，取了一个与 <code>std::result::Result&lt;T, E&gt;</code> 同名的 Result 类型，把 <code>std::result::Result&lt;T, E&gt;</code> 定义简化了，具化其Error类型为 <code>std::io::Error</code>，同时仍保留了第一个类型参数 T。于是得到了 <code>Result&lt;T&gt;</code>。</p><pre><code class=\"language-plain\">pub type Result&lt;T&gt; = Result&lt;T, Error&gt;;\n</code></pre><p>刚开始接触Rust的时候，你可能会对这种表达方式产生疑惑，其实道理就在这里。以后你在阅读Rust生态中各种库的源码时，也会经常遇到这种封装方式，所以我们要习惯它。</p><p>关于这种定义更多的资料参见：</p><p><a href=\"https://doc.rust-lang.org/std/result/enum.Result.html\">https://doc.rust-lang.org/std/result/enum.Result.html</a><br>\n<a href=\"https://doc.rust-lang.org/std/io/type.Result.html\">https://doc.rust-lang.org/std/io/type.Result.html</a><br>\n<a href=\"https://doc.rust-lang.org/std/io/struct.Error.html\">https://doc.rust-lang.org/std/io/struct.Error.html</a></p><h2>小结</h2><p><img src=\"https://static001.geekbang.org/resource/image/a8/db/a8b0ab1fabe5c6138f55d1effd4c7bdb.jpg?wh=1882x1480\" alt=\"\"></p><p>这节课我们对Rust中类型相关的知识做了一个专门的讲解。现代编程语言的趋势是越来越强调类型化，比如 TypeScript、Rust。一个成熟的类型系统对于编写健壮的程序来说至关重要。类型可以看作是对变量取值空间的一种约束。</p><p>在Rust中，有很多对多种类型做统一处理的需求，因此引入了类型参数和泛型的概念。它们实际是在类型化道路上的必然选择，因为单一的类型确实不方便，或者不能满足我们的需求。你要先克服对这种参数化设计的畏惧感，只要花一些时间熟悉这节课我们提到的那些形式，这些概念就不难掌握。</p><p>然后，这节课我们还讲解了4种类型体系建模方法，你可以在后面的实践过程中慢慢加深理解。</p><h2>思考题</h2><p>如果你给某个泛型实现了一个方法，那么，还能为它的一个具化类型再实现同样的方法吗？</p><p>欢迎你把思考后的结果分享到评论区，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p><h4>《Programming.with.Types》原文摘录</h4><p><img src=\"https://static001.geekbang.org/resource/image/e7/de/e7a9844641dd3fedeb43e5ce7d2558de.jpg?wh=1022x182\" alt=\"图片\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/03/e9/0315a018c95a61cd6d54bde9cace8ee9.jpg?wh=1114x126\" alt=\"图片\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/50/6f/5005yy9ef73f713e299e5a322f301d6f.jpg?wh=1030x222\" alt=\"图片\"></p>","comments":[{"had_liked":false,"id":383400,"user_name":"古明地觉","can_delete":false,"product_type":"c1","uid":1528298,"ip_address":"中国台湾","ucode":"31DA063A17FC27","user_header":"https://static001.geekbang.org/account/avatar/00/17/51/ea/d9a83bb3.jpg","comment_is_top":false,"comment_ctime":1698982456,"is_pvip":false,"replies":[{"id":139677,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699003209,"ip_address":"重庆","comment_id":383400,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题：&quot;为泛型实现了一个方法，能否再为具化类型实现一个同名方法&quot;，取决于这个泛型能否表示相应的具化类型。比如为泛型 T 和 String 实现了相同的方法，由于 T 没有施加任何约束，它可以代表 String。那么当调用方法时，对于具化类型 String 来说，要调用哪一个呢？因此会出现歧义，编译器会报错：方法被重复定义了。\n\n但如果给泛型 T 施加了一个 Copy 约束，要求 T 必须实现了 Copy trait，那么就不会报错了，因为此时 T 代表不了 String，所以调用方法不会出现歧义。但如果再为 i32 实现一个同名方法就会报错了，因为 i32 实现了 Copy，它可以被 T 表示。\n\nPS：老师我在 06 讲提了一个问题，之前在学 Rust 的时候就一直困扰着我，还麻烦老师解答一下。","like_count":9,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630884,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699003209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":4017296,"avatar":"https://static001.geekbang.org/account/avatar/00/3d/4c/90/00336164.jpg","nickname":"知足","note":"","ucode":"27061A7B1C218F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653250,"discussion_content":"对于 T 与自定义类型是适用的，对于T和String不适用了，upstream crates may add a new impl of trait std::marker::Copy for type std::string::String in future versions","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730471890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383399,"user_name":"一个人旅行","can_delete":false,"product_type":"c1","uid":2555864,"ip_address":"北京","ucode":"A708238B10B44B","user_header":"https://static001.geekbang.org/account/avatar/00/26/ff/d8/d48d6088.jpg","comment_is_top":false,"comment_ctime":1698981668,"is_pvip":false,"replies":[{"id":139671,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699001653,"ip_address":"重庆","comment_id":383399,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"不能，编译器会提示duplicate definitions for XXXXX。\n如果想为具化类型再实现同样的方法，则可以定义一个trait，用具化类型实现这个trait，来达到&quot;为具化类型再实现同样的方法“的目的。","like_count":5,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630875,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699001653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383685,"user_name":"-Hedon🍭","can_delete":false,"product_type":"c1","uid":3176234,"ip_address":"湖北","ucode":"FAE541E7A2B88F","user_header":"https://static001.geekbang.org/account/avatar/00/30/77/2a/0cd4c373.jpg","comment_is_top":false,"comment_ctime":1699447530,"is_pvip":false,"replies":[{"id":139936,"content":"很棒","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699505407,"ip_address":"重庆","comment_id":383685,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题：核心点就在于不能为同一个类型实现 2 个相同函数签名的方法，因为这会引起方法冲突。\n\n编译报错如下：\n\nerror[E0592]: duplicate definitions with name `print`\n  --&gt; examples&#47;generic.rs:7:5\n   |\n7  |     fn print(&amp;self) {\n   |     ^^^^^^^^^^^^^^^ duplicate definitions for `print`\n...\n13 |     fn print(&amp;self) {\n   |     --------------- other definition for `print`\n\n\n所以一般情况下，如果 impl&lt;T&gt; 后面的 T 没有任何的约束，那么就表示为所有类型的 T 都实现了方法，比如说 print()，这个时候是不能为具化类型再次实现 print() 的，因为这个时候就产生了方法冲突。\n\n但是，如果 impl&lt;T: std::fmt:Display&gt; 后面的 T 是有约束的，那么其实只为符合这个约束的类型实现了 print()，其余类型是没有实现的，所以是可以为其余具化类型实现相同的方法的。\n\n如：\n\n```rust\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nstruct NotDisplay {\n    a: u32,\n}\n\nimpl&lt;T: std::fmt::Display&gt; Point&lt;T&gt; {\n    fn print(&amp;self) {\n        println!(&quot;Point: {}, {}&quot;, self.x, self.y);\n    }\n}\n\nimpl Point&lt;NotDisplay&gt; {\n    fn print(&amp;self) {\n        println!(&quot;not display&quot;);\n    }\n}\n```","like_count":3,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631403,"discussion_content":"很棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699505407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383397,"user_name":"Geek_de05b4","can_delete":false,"product_type":"c1","uid":2675374,"ip_address":"上海","ucode":"C88B30D2D79ADC","user_header":"","comment_is_top":false,"comment_ctime":1698980218,"is_pvip":false,"replies":[{"id":139670,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699001644,"ip_address":"重庆","comment_id":383397,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"impl&lt;T: std::ops::Add&lt;Output = T&gt;&gt; Bar&lt;T&gt; {\n    fn plus(self, other: Bar&lt;T&gt;) -&gt; T {\n        self.value + other.value\n    }\n}\n\nimpl Bar&lt;u32&gt; {\n    fn plus(&amp;self, other: &amp;Bar&lt;u32&gt;) -&gt; u32 {\n        self.value + other.value\n    }\n}\n\n&#47;&#47;Output:\nerror[E0592]: duplicate definitions with name `plus`\n  --&gt; src&#47;main.rs:64:5\n   |\n64 |     fn plus(self, other: Bar&lt;T&gt;) -&gt; T {\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `plus`\n...\n70 |     fn plus(&amp;self, other: &amp;Bar&lt;u32&gt;) -&gt; u32 {\n   |     --------------------------------------- other definition for `plus`\n\n不能","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630874,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699001644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383697,"user_name":"Noya","can_delete":false,"product_type":"c1","uid":1519230,"ip_address":"浙江","ucode":"52EEB72E80BAF8","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/7e/a15b477c.jpg","comment_is_top":false,"comment_ctime":1699465229,"is_pvip":false,"replies":[{"id":139932,"content":"对的","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1699505252,"ip_address":"重庆","comment_id":383697,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题：通常是不能， 但是可以通过 trait 进行特化","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631399,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699505252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383386,"user_name":"伯阳","can_delete":false,"product_type":"c1","uid":1596631,"ip_address":"北京","ucode":"DBDC8735AA54AD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5c/d7/3b92bb0d.jpg","comment_is_top":false,"comment_ctime":1698960775,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"和Java的范型类似","like_count":1},{"had_liked":false,"id":395858,"user_name":"坤","can_delete":false,"product_type":"c1","uid":1585570,"ip_address":"浙江","ucode":"AD2B2D6A4E5CBF","user_header":"https://static001.geekbang.org/account/avatar/00/18/31/a2/16c3318d.jpg","comment_is_top":false,"comment_ctime":1732265578,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"let a = 9 + &#39;1&#39; as u8;\n结果是 58,让我困惑了:9+1 结果明明是10,这怎么就58了.\n然后就想:为什么是58而不是其他的值,特征是这个数字小于100,\n那么&#39;1&#39; 就是 58-9=49,有了一个猜想&#39;1&#39; as u8 是指ascii码的1,转之后是49, \n然后就去验证,查看ascii,果然&#39;1&#39;是49.\n","like_count":0}]}