{"id":385964,"title":"11｜事件处理：如何创建自定义事件？","content":"<p>你好，我是王沛。今天我们来聊聊 React 中的事件处理。</p><p>我们知道，在 React 中，父子组件的交互是通过 props。这个机制其实是双向的，父组件通过 props 把值传递给子组件，而子组件则通过暴露一些事件，给父组件反馈到一些状态或数据。这两个环节是<strong>组件之间通信的基础</strong>，所以都需要熟练掌握。</p><p>我们前面的课程已经有很多通过 props 从父组件传递参数的子组件的场景了，那么今天这节课，我们就来看看在 React 中事件的机制是怎样的，从原理出发，帮助你深入理解。同时呢，也来学习一下对于自定义事件，一般都有哪些典型的应用场景，帮助你学以致用。</p><h2>在 React 中使用原生事件</h2><p>在 React 中进行事件监听的语法，和原生 DOM 事件的写法是非常类似的，都是在一个节点上加一个回调函数的属性来实现。比如下面的方式：</p><pre><code>&lt;button onClick={handler}&gt;Hello&lt;/button&gt; \n\n</code></pre><p>在前面的课程中我们已经看到了很多类似的例子。不过还要特别说明一点，对于原生 DOM 的事件，标准的的写法可能是都小写，比如 onclick。但是在 React 中，都是<strong>约定使用骆驼体</strong>（Camel Case）。</p><p>通过这个规律，我们基本上不用刻意去记事件的名称。我们要始终记得，<strong>只要原生 DOM 有的事件，在 React 中基本都可以使用，只是写法上采用骆驼体就可以了</strong>，比如 onMouseOver、onChange 等。</p><!-- [[[read_end]]] --><p>此外，关于事件处理函数，那就要回到很多同学之前在留言区提到的一个问题：是不是所有的回调函数都需要用 useCallback 进行封装呢？是不是简单的回调函数就可以不用封装了呢？</p><p>其实是否需要 useCallback ，和函数的复杂度没有必然关系，而是<strong>和回调函数绑定到哪个组件有关</strong>。这是为了避免因组件属性变化而导致不必要的重新渲染。</p><p>而对于原生的 DOM 节点，比如 button、input 等，我们是不用担心重新渲染的。所以呢，如果你的事件处理函数是传递给原生节点，那么不写 callback，也几乎不会有任何性能的影响。</p><p>但是<strong>如果你使用的是自定义组件，或者一些 UI 框架的组件，那么回调函数还都应该用 useCallback 进行封装</strong>。</p><p>##React 原生事件的原理：合成事件（Synthetic Events）</p><p>因为原生事件的机制比较特别，所以我在这里要特别强调一下它的原理。</p><p>由于虚拟 DOM 的存在，在 React 中即使绑定一个事件到原生的 DOM 节点，事件也并不是绑定在对应的节点上，而是<strong>所有的事件都是绑定在根节点上</strong>。然后由 React 统一监听和管理，获取事件后再分发到具体的虚拟 DOM 节点上。</p><p>在 React 17 之前，所有的事件都是绑定在 document 上的，而从React 17 开始，<strong>所有的事件都绑定在整个 App 上的根节点上</strong>，这主要是为了以后页面上可能存在多版本 React 的考虑。</p><p>具体来说，React 这么做的原因主要有两个。</p><p>第一，虚拟 DOM render 的时候， DOM 很可能还没有真实地 render 到页面上，所以无法绑定事件。</p><p>第二，React 可以屏蔽底层事件的细节，避免浏览器的兼容性问题。同时呢，对于 React Native 这种不是通过浏览器 render 的运行时，也能提供一致的 API。</p><p>这里有一点我要多解释下。那就是为什么事件绑定在某个根节点上，也能触发实际 DOM 节点的事件。</p><p>我们知道，在浏览器的原生机制中，事件会从被触发的节点往父节点冒泡，然后沿着整个路径一直到根节点，所以根节点其实是可以收到所有的事件的。这也称之为<strong>浏览器事件的冒泡模型</strong>。</p><p>因此，无论事件在哪个节点被触发， React 都可以通过事件的 srcElement 这个属性，知道它是从哪个节点开始发出的，这样 React 就可以收集管理所有的事件，然后再以一致的API 暴露出来。</p><p>这样的话，我们在写原生事件的时候，就再也不用再担心浏览器兼容性的问题了。如下图所示，就展示了事件机制冒泡模型的原理：</p><p><img src=\"https://static001.geekbang.org/resource/image/1b/06/1bd06yy56b1103376d0ec45fb87b7906.png?wh=556x862\" alt=\"\"></p><p>对于原生事件的处理，可以说是 React 的一个创新，不仅能够让你像以前在原生 DOM 节点上定义事件的方式一样，而且还提供了一致的 API，让我们不用再担心浏览器的兼容问题，使用起来也更加容易。</p><h2>创建自定义事件</h2><p>对于一个自定义组件，除了可以从 props 接收参数并用于渲染之外，还很可能<strong>需要和父组件进行交互</strong>，从而反馈信息。这个时候，我们就需要<strong>为组件创建自定义事件</strong>，这也是 React 整个 UI 模型中非常重要的一个环节。</p><p>需要注意的是，虽然自定义事件和原生事件看上去类似，但是两者的机制是完全不一样的：</p><ul>\n<li>原生事件是浏览器的机制；</li>\n<li>而自定义事件则是纯粹的组件自己的行为，本质是一种回调函数机制。</li>\n</ul><p>可能你一听自定义事件，下意识就觉得有些麻烦。但其实在 React 中，自定义事件不用通过任何特殊的 API，只需要通过 props 给组件传递一个回调函数，然后在组件中的某个时机，比如用户输入，或者某个请求完成时，去调用这个传过来的回调函数就可以了。</p><p>当然，习惯上我们都会<strong>将这样的回调函数命名为 onSomething 这种以“ on ”开头的名字</strong>，方便在使用的时候理解。</p><p>其实在<a href=\"https://time.geekbang.org/column/article/381423\">第6讲</a>中，我们在创建一个价格输入组件时已经实现了自定义事件，但是并没有具体地解释。那么在这里再给你举一个简单的例子，实现一个 on/off 的切换按钮，那么理解自定义事件，其实就非常简单了。</p><p>下面就是实现的代码，你也可以通过文末的链接在线查看代码和运行效果：</p><pre><code>import { useState } from &quot;react&quot;;\n\n// 创建一个无状态的受控组件\nfunction ToggleButton({ value, onChange }) {\n  const handleClick = () =&gt; {\n    onChange(!value);\n  };\n  return (\n    &lt;button style={{ width: &quot;60px&quot; }} onClick={handleClick}&gt;\n      &lt;span&gt;{value ? &quot;On&quot; : &quot;Off&quot;}&lt;/span&gt;\n    &lt;/button&gt;\n  );\n}\n</code></pre><p>可以看到，所谓自定义事件，就是定义了一个 onChange 这样的属性，允许传递一个回调函数给这个组件，在某个时机去调用这个回调函数，从而实现事件的功能。</p><p>那么下面的代码就演示了如何使用这样一个组件：</p><pre><code>import { useState } from &quot;react&quot;;\nimport ToggleButton from './ToggleButton';\n\nfunction ToggleButtonExample() {\n  const [on, setOn] = useState(true);\n  return (\n    &lt;&gt;\n      &lt;h1&gt;Toggle Button&lt;/h1&gt;\n      &lt;ToggleButton value={on} onChange={(value) =&gt; setOn(value)} /&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre><p>这里可以看到，ToggleButton 组件内部调用了 onChange 这个通过属性传递进来的回调函数，并传递了当前值给回调函数，从而实现了子组件到父组件的通信。</p><h2>使用 Hooks 封装键盘事件</h2><p>开篇词就提到，整个课程我们都是围绕 React Hooks 展开的，那么 Hooks 在事件处理方面又可以带来哪些新的思路呢？</p><p>在<a href=\"https://time.geekbang.org/column/article/381423\">第6讲</a>我们已经看到了一个 useScroll 的例子，通过 Hooks 绑定了滚动条位置这个数据源。那么这里再给大家看一个绑定键盘按键的例子，看看如何使用 Hooks，让代码语义更加清晰。</p><p>相比 useScroll，键盘事件可能看上去更加和 Hooks 没有关系。因为滚动条位置至少在直观上是一个很明显的数据，但是键盘呢，却完全是一个个独立的事件。</p><p>不过，如果你充分认识到 <strong>Hooks 具备绑定任何数据源的能力</strong>，那你就会知道，键盘输入正是一个非常常见的数据源。这样，我们就可以把键盘输入变成某个状态，方便在组件中使用。</p><p>在没有 Hooks 的时候，比如说我们要让某个显示表格的页面，支持通过左右键进行翻页的功能。那么我们就需要在 useEffect 里去做 window.addEventListnner，然后在返回的回调函数里去 window.removeEventListnner，实现起来就很麻烦。</p><p>但是，如果我们用一个 Hook 来实现这个功能，那么只要实现一次，就可以在多个组件中使用了。下面就是这个 Hook 的实现代码：</p><pre><code>import { useEffect, useState } from &quot;react&quot;;\n\n// 使用 document.body 作为默认的监听节点\nconst useKeyPress = (domNode = document.body) =&gt; {\n  const [key, setKey] = useState(null);\n  useEffect(() =&gt; {\n    const handleKeyPress = (evt) =&gt; {\n      setKey(evt.keyCode);\n    };\n    // 监听按键事件\n    domNode.addEventListener(&quot;keypress&quot;, handleKeyPress);\n    return () =&gt; {\n      // 接触监听按键事件\n      domNode.removeEventListener(&quot;keypress&quot;, handleKeyPress);\n    };\n  }, [domNode]);\n  return key;\n};\n</code></pre><p>有了这个 Hook，我们在使用的时候就非常方便，无需做任何事件的绑定，而是<strong>只要把键盘按键看做是一个不断变化的数据源</strong>，这样，就可以去实时监听某个 DOM 节点上触发的键盘事件了。</p><p>比如下面就是去显示当前按键的一个简单使用例子：</p><pre><code>import useKeyPress from './useKeyPress';\n\nfunction UseKeyPressExample() =&gt; {\n  const key = useKeyPress();\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;UseKeyPress&lt;/h1&gt;\n      &lt;label&gt;Key pressed: {key || &quot;N/A&quot;}&lt;/label&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre><h2>小结</h2><p>在这节课，我们主要学习了 React 中的事件机制。事件其实分为两种。</p><p>一种是<strong>原生的DOM 事件</strong>，在用法上和标准的 DOM API 是基本一一映射的，通过事件合成的机制，React 能够提供统一的 API 来抹平浏览器之间的差异，让开发更加简单。</p><p>另一种事件则是<strong>自定义事件</strong>，所谓的自定义事件，其实就是利用了属性传递回调函数给子组件，实现事件的触发。本质上，它和原生事件的机制是完全不一样的，原生事件是浏览器层面的事件，而自定义事件则是纯组件实现的一种机制。</p><p>最后呢，我们分析了一个例子：如何用 Hooks 去简化事件的处理。将键盘按键这个事件封装成了一个 Hook，就可以简化键盘事件的使用，也很好地展示了 Hooks 的思路带给我们的惊喜，可以让本来很技术的一些实现，比如事件的监听和解绑，变得更加具有语义，从而也让代码更容易理解和维护。</p><p>最后，附上这节课所有的代码和运行结果的链接：<a href=\"https://codesandbox.io/s/react-hooks-course-20vzg\">https://codesandbox.io/s/react-hooks-course-20vzg</a>。</p><h2>思考题</h2><p>在键盘按键的例子中，我们只是实现了单个按键的监听，如果我们要实现同时两个按键的监听呢？比如同时按下 A 和 B，那么用 Hooks 怎么去比较好的实现？</p><p>这节课的题目有点难度，但是会对你的学习很有帮助，希望你可以深度思考一下，并在评论区分享你的想法和思考。同时，我也会把一些不错的回答进行置顶，供大家学习交流。</p>","neighbors":{"left":{"article_title":"10｜函数组件设计模式：如何应对复杂条件渲染场景？","id":385358},"right":{"article_title":"12｜项目结构：为什么要按领域组织文件夹结构？","id":386843}},"comments":[{"had_liked":false,"id":298541,"user_name":"前端小猪","can_delete":false,"product_type":"c1","uid":1764429,"ip_address":"","ucode":"DDC0F702986274","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ec/4d/1551ed5f.jpg","comment_is_top":false,"comment_ctime":1624182214,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"48868822470","product_id":100079901,"comment_content":"因为点击了两个按钮会触发两个事件，所以我的想法是：使用数组的方式存储key值,keyup的时候清空数组就行了：<br>const useKeyPress = (domNode = document.body) =&gt; {<br>    const [keys, setKeys] = useState([])<br>    useEffect(() =&gt; {<br>      const handleKeyPress = evt =&gt; {<br>        setKeys(prevKeys =&gt; {<br>          if (prevKeys.length !== 2) {<br>            return [...prevKeys, evt.keyCode]<br>          } else {<br>            return prevKeys<br>          }<br>        })<br>      }<br>      domNode.addEventListener(&#39;keypress&#39;, handleKeyPress)<br>      return () =&gt; {<br>        domNode.removeEventListener(&#39;keypress&#39;, handleKeyPress)<br>      }<br>    }, [domNode])<br>    return keys<br>  }","like_count":12,"discussions":[{"author":{"id":1374957,"avatar":"https://static001.geekbang.org/account/avatar/00/14/fa/ed/0742b854.jpg","nickname":"Jun Ma","note":"","ucode":"0C5E2AB51E6A83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584571,"discussion_content":"有个问题就是，只能存前面两个key，不能一直改变？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660915819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302458,"user_name":"Geek_9ab0c7","can_delete":false,"product_type":"c1","uid":2638918,"ip_address":"","ucode":"F31870F5B18CB2","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqz5X60ickyQOBejQZOiaunoQkgJo82jFDkXQosdCkHLpoe6YibL8uup10udh303eyCpROkia40xXkHSw/132","comment_is_top":false,"comment_ctime":1626230364,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27396034140","product_id":100079901,"comment_content":"基本思路： 1. 使用数组存值；2. keydown存值； 3. 当keyup表示单键或者组合键按键结束，清空数组；4.当长按键不放会多次触发事件，所以setKey时需要去重<br><br>export default function useKeyPress (dom = document.body) {<br>  const [key, setKey] = useState([])<br>  const isNext = useRef(true) &#47;&#47; 当keyup之后，isNext置为true表示又是新一轮的按键监听<br>  useEffect(() =&gt; {<br>    const handleKeyPress = (e) =&gt; {<br>      if (e.type === &#39;keydown&#39;) {<br>        if (isNext.current) setKey([])<br>        setKey(keys =&gt; [...new Set([...keys, e.key])]) &#47;&#47; 去重<br>        isNext.current = false<br>      } else {<br>        isNext.current = true<br>      }<br>    }<br>    dom.addEventListener(&#39;keydown&#39;, handleKeyPress)<br>    dom.addEventListener(&#39;keyup&#39;, handleKeyPress)<br>    return () =&gt; {<br>      dom.removeEventListener(&#39;keydown&#39;, handleKeyPress)<br>      dom.removeEventListener(&#39;keydown&#39;, handleKeyPress)<br>    }<br>  }, [dom])<br>  return key.join(&#39;,&#39;)<br>}","like_count":7,"discussions":[{"author":{"id":1336608,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/20/65dd107f.jpg","nickname":"大兔叽","note":"","ucode":"E2720A83E5DBF8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413324,"discussion_content":"Nice兄嘚","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636446760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305679,"user_name":"罗大明","can_delete":false,"product_type":"c1","uid":1912341,"ip_address":"","ucode":"17D133F13BA079","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJVpGfkkH8rqNia2V5xib71YaHn1bpCV9BNJn6ONPfGJGs2Giceoibn6ArNauJvjvHhtCNob8HCUDs7kA/132","comment_is_top":false,"comment_ctime":1628096202,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923063498","product_id":100079901,"comment_content":"老师，这样拿到的keyCode其实是上一次的吧（也就是上一个按下的键盘）这样监听没什么意义啊","like_count":1},{"had_liked":false,"id":300083,"user_name":"闲闲","can_delete":false,"product_type":"c1","uid":1637571,"ip_address":"","ucode":"B2099BDCFF6191","user_header":"https://static001.geekbang.org/account/avatar/00/18/fc/c3/0991edfc.jpg","comment_is_top":false,"comment_ctime":1624978519,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5919945815","product_id":100079901,"comment_content":"老师我有两个问题，麻烦帮忙解答下：<br>1、上面绑定的键盘事件，hook里面具体什么时候回注销这个事件呢，代码是在useEffect return里面注销事件的，那具体什么时候会走到这代码里面呢？<br>2、看到这节课内容我想起来之前封装组件遇到的一个问题，场景是这样，需要封装一个公共组件，对于原生dom事件需要都能接受，其他的无用的props不想接受，react有什么方法可以判断当前的事件是不是原生dom支持的吗？还是说我需要具体的一一罗列？","like_count":1,"discussions":[{"author":{"id":2528648,"avatar":"https://static001.geekbang.org/account/avatar/00/26/95/88/aee4fdd0.jpg","nickname":"D","note":"","ucode":"95A4227DB3C609","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574274,"discussion_content":"1. 当hooks的依赖数组中的对象变化时和该组件注销时候，对应到这个例子中就是坚挺对象的domNode变化的时候。（目前绑定在document.body上面）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1653952612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349124,"user_name":"Geek_d15b65","can_delete":false,"product_type":"c1","uid":3029356,"ip_address":"","ucode":"D2FE5E750B9230","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/icyrQvzWBjcTzEhYrP62pImJSwSwxDh7X3VX87oTtIeSsMg3aSDMZKnKicynN9UBBsDeWaK3vzibD8ibHhrg2b5Cpg/132","comment_is_top":false,"comment_ctime":1655740476,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1655740476","product_id":100079901,"comment_content":"const useKeyPress = (domNode = document.body ) =&gt; {<br>  const [key1, setKey1] = useState(null);<br>  const [key2, setKey2] = useState(null);<br>  const [flag, setFlag] = useState(0);<br>  useEffect(() =&gt; {<br>    const handleKeyPress = (evt) =&gt; {<br>      &#47;&#47; 设置两种状态， 0 是key1，1是key2<br>      if(flag === 0){<br>        setKey1(evt.keyCode);<br>        setKey2(null);<br>        setFlag(1);<br>      }else if (flag === 1){<br>        setKey2(evt.keyCode);<br>        setFlag(0);<br>      }<br><br>    };<br>    &#47;&#47; 监听按键事件<br>    domNode.addEventListener(&#39;keypress&#39;, handleKeyPress);<br>    return () =&gt; {<br>      domNode.removeEventListener(&#39;keypress&#39;, handleKeyPress);<br>    }<br>  },[domNode, flag]);<br>  return { key1, key2 };<br>}<br>","like_count":0},{"had_liked":false,"id":309588,"user_name":"知故","can_delete":false,"product_type":"c1","uid":1898098,"ip_address":"","ucode":"8A05FC14443637","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJlZSBIXmp6PVpCXnicMR1dD4K4u2FWt4LQhicf9mJiaFOHUntft5nTzAptb8gzF4M8Yvs6gocykf22w/132","comment_is_top":false,"comment_ctime":1630242783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630242783","product_id":100079901,"comment_content":"我们可以分别建立2个按下的hooks，以及2个弹起的hooks, 作为数据源，用一个useMemo来监控这2个键同时按下的状态","like_count":1},{"had_liked":false,"id":307517,"user_name":"lugusliu","can_delete":false,"product_type":"c1","uid":1378530,"ip_address":"","ucode":"B2D6A2F4122055","user_header":"https://static001.geekbang.org/account/avatar/00/15/08/e2/138689a8.jpg","comment_is_top":false,"comment_ctime":1629129091,"is_pvip":false,"replies":[{"id":"111732","content":"感谢指出！","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1629726589,"ip_address":"","comment_id":307517,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1629129091","product_id":100079901,"comment_content":"”那么我们就需要在 useEffect 里去做 window.addEventListner，然后在返回的回调函数里去 window.removeEventListner，实现起来就很麻烦“<br>这里有两处笔误<br>addEventListner -&gt; addEventListener<br>removeEventListner -&gt; removeEventListener","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525185,"discussion_content":"感谢指出！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629726589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020644,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/e4/abb7bfe3.jpg","nickname":"TerryGoForIt","note":"","ucode":"701B0E72F15AB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583754,"discussion_content":"老师的笔误远不止这些，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660356495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1195144,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/88/6bef27d6.jpg","nickname":"大神博士","note":"","ucode":"8C4318095949F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551559,"discussion_content":"这句话的前面也很奇怪，“在没有 Hooks 的时候“，但是 useEfferct 不也是 hooks 吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645062584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300353,"user_name":"我要的飞翔","can_delete":false,"product_type":"c1","uid":1200447,"ip_address":"","ucode":"41C51DBC8372BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/51/3f/41c68054.jpg","comment_is_top":false,"comment_ctime":1625125779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625125779","product_id":100079901,"comment_content":"const useKeyboard = (domNode = document.body) =&gt; {<br>  const [keys, setKeys] = useState([]);<br>  useEffect(() =&gt; {<br>    const handleKeyPress = evt =&gt; setKeys(keys =&gt; [...keys, evt.keyCode]);<br>    const handleKeyUp = evt =&gt; setKeys(keys =&gt; keys.filter(k =&gt; k !== evt.keyCode));<br>    domNode.addEventListener(&quot;keypress&quot;, handleKeyPress); &#47;&#47; 按下<br>    domNode.addEventListener(&quot;keyup&quot;, handleKeyUp); &#47;&#47; 按下<br>    return () =&gt; {<br>      &#47;&#47; 接触监听按键事件<br>      domNode.removeEventListener(&quot;keypress&quot;, handleKeyPress);<br>      domNode.removeEventListener(&quot;keyup&quot;, handleKeyUp);<br>    };<br>  }, [domNode]);<br>  return keys;<br>}","like_count":0},{"had_liked":false,"id":299889,"user_name":"余熙","can_delete":false,"product_type":"c1","uid":1240802,"ip_address":"","ucode":"7F98DCFB899CB7","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/e2/23e44221.jpg","comment_is_top":false,"comment_ctime":1624893482,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1624893482","product_id":100079901,"comment_content":"“如果你的事件处理函数是传递给原生节点，那么不写 callback，也几乎不会有任何性能的影响。”<br>为什么这么说呢，是不是因为原生节点，本来就要不断渲染","like_count":0,"discussions":[{"author":{"id":1385324,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/6c/e5a88f14.jpg","nickname":"胡哥有话说","note":"","ucode":"5046D968D448E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383389,"discussion_content":"传递给一个原生节点时，如 <button onClick={eventHandler}></button>，及时每次eventHandler都是最新的，导致button渲染，这也几乎是没有成本的。\n如果是 <mySelfButton  onCallback={eventHanlder} />，此时如果eventHandler有变化，都会引起mySelfButton组件的渲染，引起的开销会比较大，所以建议使用useCallback","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626076579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1240802,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/e2/23e44221.jpg","nickname":"余熙","note":"","ucode":"7F98DCFB899CB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1385324,"avatar":"https://static001.geekbang.org/account/avatar/00/15/23/6c/e5a88f14.jpg","nickname":"胡哥有话说","note":"","ucode":"5046D968D448E5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383903,"discussion_content":"谢谢您的回答。\n\n但还是不清楚，多出来的时间复杂度在哪，是因为 diff 算法吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626277097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383389,"ip_address":""},"score":383903,"extra":""},{"author":{"id":1038425,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/59/2fc5886b.jpg","nickname":"林斌","note":"","ucode":"EA44A69E8C9457","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1240802,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/e2/23e44221.jpg","nickname":"余熙","note":"","ucode":"7F98DCFB899CB7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386081,"discussion_content":"我觉得因为原生节点够简单，所以在整个渲染过程中重渲染损耗可以忽略不计，但是传给自定义的组件， 夸张点 几百几千个标签组成，那就是几千倍原声节点的渲染损耗。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627394421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":383903,"ip_address":""},"score":386081,"extra":""}]}]},{"had_liked":false,"id":298743,"user_name":"吴小丽","can_delete":false,"product_type":"c1","uid":2647544,"ip_address":"","ucode":"64F6AC4D4FDEAF","user_header":"https://static001.geekbang.org/account/avatar/00/28/65/f8/e68e8786.jpg","comment_is_top":false,"comment_ctime":1624284985,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1624284985","product_id":100079901,"comment_content":"不太理解[domNode]有啥作用，不用它，例子也能成","like_count":0,"discussions":[{"author":{"id":1909693,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/23/bd/b150086a.jpg","nickname":"在路上_W","note":"","ucode":"632D9130F58D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383322,"discussion_content":"比如在某个区域内监听事件，就有区别了。例子默认是body了，看不出啥区别。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626058462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298574,"user_name":"Free fall","can_delete":false,"product_type":"c1","uid":2637054,"ip_address":"","ucode":"8DBF73CD0F423F","user_header":"","comment_is_top":false,"comment_ctime":1624202083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624202083","product_id":100079901,"comment_content":"可以按多个<br>const useKeypress = (node = document.body) =&gt; {<br>  const [key, setKey] = useState(null)<br><br>  function reset() {<br>    setKey(null)<br>  }<br><br>  useEffect(() =&gt; {<br>    function handleKeypress(e) {<br>      setKey((key) =&gt; key + &#39;,&#39; + e.keyCode)<br>    }<br><br>    node &amp;&amp; node.addEventListener(&#39;keypress&#39;, handleKeypress)<br><br>    return () =&gt; {<br>      node.removeEventListener(&#39;keypress&#39;, handleKeypress)<br>    }<br>  }, [node])<br><br>  return [key, reset]<br>}","like_count":0},{"had_liked":false,"id":298489,"user_name":"错误代码0000","can_delete":false,"product_type":"c1","uid":1271255,"ip_address":"","ucode":"1A462AF27322E8","user_header":"https://static001.geekbang.org/account/avatar/00/13/65/d7/4eda752c.jpg","comment_is_top":false,"comment_ctime":1624154940,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1624154940","product_id":100079901,"comment_content":"老师，会有自定义hook嘛。。 想对其场景和封装加深理解","like_count":0,"discussions":[{"author":{"id":1038425,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d8/59/2fc5886b.jpg","nickname":"林斌","note":"","ucode":"EA44A69E8C9457","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386082,"discussion_content":"所有除了官方的useXXX都是自定义hooks啊～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627394460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":298368,"user_name":"喵咪爱吃肉","can_delete":false,"product_type":"c1","uid":1901074,"ip_address":"","ucode":"6CEA983AFF58AF","user_header":"https://static001.geekbang.org/account/avatar/00/1d/02/12/ce3dc4c8.jpg","comment_is_top":false,"comment_ctime":1624064747,"is_pvip":false,"replies":[{"id":"108270","content":"一半啦~","user_name":"作者回复","user_name_real":"Nate","uid":"1018676","ctime":1624086744,"ip_address":"","comment_id":298368,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1624064747","product_id":100079901,"comment_content":"追番～","like_count":0,"discussions":[{"author":{"id":1018676,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/34/61035278.jpg","nickname":"Nate","note":"","ucode":"844B4C20BB3D6E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522115,"discussion_content":"一半啦~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624086744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}