{"id":93044,"title":"09 | CAP定理：三选二，架构师必须学会的取舍","content":"<p>你好，我是蔡元楠。</p><p>今天我要与你分享的主题是CAP定理。</p><p>在分布式系统的两讲中，我们一起学习到了两个重要的概念：可用性和一致性。</p><p>而今天，我想和你讲解一个与这两个概念相关，并且在设计分布式系统架构时都会讨论到的一个定理——<strong>CAP定理</strong>（CAP Theorem）。</p><h2>CAP定理</h2><p>CAP这个概念最初是由埃里克·布鲁尔博士（Dr. Eric Brewer）在2000年的ACM年度学术研讨会上提出的。</p><p>如果你对这次演讲感兴趣的话，可以翻阅他那次名为“<a href=\"https://people.eecs.berkeley.edu/~brewer/cs262b-2004/PODC-keynote.pdf\">Towards Robust Distributed Systems</a>”的演讲deck。</p><p>在两年之后，塞思·吉尔伯特（Seth Gilbert）和麻省理工学院的南希·林奇教授（Nancy Ann Lynch）在他们的论文“Brewer’s conjecture and the Feasibility of Consistent, Available, Partition-Tolerant Web Services”中证明了这一概念。</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/8f/2bfd96a97ce8d38834105964d0cb0e8f.png?wh=1278*1346\" alt=\"\"></p><p>他们在这篇论文中证明了：在任意的分布式系统中，一致性（Consistency），可用性（Availability）和分区容错性（Partition-tolerance）这三种属性最多只能同时存在两个属性。</p><!-- [[[read_end]]] --><p>下面，我来为你解读一下这三种属性在这篇论文里的具体意思。</p><h2>C属性：一致性</h2><p>一致性在这里指的是<strong>线性一致性（Linearizability Consistency）</strong>。在线性一致性的保证下，所有分布式环境下的操作都像是在单机上完成的一样，也就是说图中Sever A、B、C的状态一直是一致的。</p><p><img src=\"https://static001.geekbang.org/resource/image/17/41/17a4df9ff551c932bf60ca459fe3b641.jpg?wh=380*391\" alt=\"\"></p><p>打个比方，现在有两个操作（Operation），操作A和操作B，都需要在同一个分布式系统上完成。</p><p>我们假设操作A作用在系统上的时候，所看见的所有系统状态（State）叫作状态A。而操作B作用在系统上的时候，所看见的所有系统状态叫作状态B。</p><p>如果操作A是在操作B之前发生的，并且操作A成功了。那么系统状态B必须要比系统状态A更加新。</p><p>可能光看理论的话你还是会觉得这个概念有点模糊，那下面我就以一个具体例子来说明吧。</p><p>假设我们设计了一个分布式的购物系统，在这个系统中，商品的存货状态分别保存在服务器A和服务器B中。我们把存货状态定义为“有货状态”或者“无货状态”。在最开始的时候，服务器A和服务器B都会显示商品为有货状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/ed/38/ed38011a91fdd19021b6450415f5a738.jpg?wh=494*229\" alt=\"\"></p><p>等一段时间过后，商品卖完了，后台就必须将这两台服务器上的商品状态更新为无货状态。</p><p>因为是在分布式的环境下，商品状态的更新在服务器A上完成了，显示为无货状态。而服务器B的状态因为网络延迟的原因更新还未完成，还是显示着有货状态。</p><p>这时，恰好有两个用户使用着这个购物系统，先后发送了一个查询操作（Query Operation）到后台服务器中查询商品状态。</p><p>我们假设是用户A先查询的，这个查询操作A被发送到了服务器A上面，并且成功返回了商品是无货状态的。用户B在随后也对同一商品进行查询，而这个查询操作B被发送到了服务器B上面，并且成功返回了商品是有货状态的。</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/08/c3421ee2650ba291bbf630448d3f5f08.jpg?wh=469*350\" alt=\"\"></p><p>我们知道，对于整个系统来说，商品的系统状态应该为无货状态。而操作A又是在操作B之前发送并且成功完成的，所以如果这个系统有线性一致性这个属性的话，操作B所看到的系统状态理论上应该是无货状态。</p><p>但在我们这个例子中，操作B却返回了有货状态。所以我们说，这个分布式的购物系统并不满足论文里所讲到的线性一致性。</p><p>聊完了一致性，我们一起来看看可用性的含义。</p><h2>A属性：可用性</h2><p>可用性的概念比较简单，在这里指的是<strong>在分布式系统中，任意非故障的服务器都必须对客户的请求产生响应</strong>。</p><p>当系统满足可用性的时候，不管出现什么状况（除非所有的服务器全部崩溃），都能返回消息。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/80/a22d6b3032f045565b952076f5f1ce80.jpg?wh=457*353\" alt=\"\"></p><p>也就是说，当客户端向系统发送请求，只要系统背后的服务器有一台还未崩溃，那么这个未崩溃的服务器必须最终响应客户端。</p><h2>P属性：分区容错性</h2><p>在了解了可用性之后，你还需要了解分区容错性。它分为两个部分，“分区”和“容错”。</p><p>在一个分布式系统里，如果出现一些故障，可能会使得部分节点之间无法连通。由于这些故障节点无法联通，造成整个网络就会被分成几块区域，从而使数据分散在这些无法连通的区域中的情况，你可以认为这就是发生了分区错误。</p><p><img src=\"https://static001.geekbang.org/resource/image/59/d4/59b52bb37de477286a70c355fe0fe1d4.jpg?wh=426*383\" alt=\"\"></p><p>如图所示，如果你要的数据只在Sever A中保存，当系统出现分区错误，在不能直接连接Sever A时，你是无法获取数据的。我们要“分区容错”，意思是即使出现这样的“错误”，系统也需要能“容忍”。也就是说，就算错误出现，系统也必须能够返回消息。</p><p>分区容错性，在这里指的是我们的<strong>系统允许网络丢失从一个节点发送到另一个节点的任意多条消息</strong>。</p><p>我们知道，在现代网络通信中，节点出现故障或者网络出现丢包这样的情况是时常会发生的。</p><p>如果没有了分区容错性，也就是说系统不允许这些节点间的通讯出现任何错误的话，那我们日常所用到的很多系统就不能再继续工作了。</p><p>所以在<strong>大部分情况下，系统设计都会保留P属性，而在C和A中二选一</strong>。</p><p>论文中论证了在任意系统中，我们最多可以保留CAP属性中的两种，也就是CP或者AP或者CA。关于具体的论证过程，如果你感兴趣的话，可以自行翻阅论文查看。</p><p>你可能会问，在我们平常所用到的开发架构中，有哪些系统是属于CP系统，有哪些是AP系统又有哪些是CA系统呢？我来给你介绍一下：</p><ul>\n<li>CP系统：Google BigTable, Hbase, MongoDB, Redis, MemCacheDB，这些存储架构都是放弃了高可用性（High Availablity）而选择CP属性的。</li>\n<li>AP系统：Amazon Dynamo系统以及它的衍生存储系统Apache Cassandra和Voldemort都是属于AP系统</li>\n<li>CA系统：Apache Kafka是一个比较典型的CA系统。</li>\n</ul><p>我在上面说过，P属性在现代网络时代中基本上是属于一个必选项，那为什么Apache Kafka会放弃P选择CA属性呢？我来给你解释一下它的架构思想。</p><h2>放弃了P属性的Kafka Replication</h2><p>在Kafka发布了0.8版本之后，Kafka系统引入了Replication的概念。Kafka Relocation通过将数据复制到不同的节点上，从而增强了数据在系统中的持久性（Durability）和可用性（Availability）。在Kafka Replication的系统设计中，所有的数据日志存储是设计在同一个数据中心（Data Center）里面的，也就是说，在同一个数据中心里网络分区出现的可能性是十分之小的。</p><p>它的具体架构是这样的，在Kafka数据副本（Data Replication）的设计中，先通过Zookeeper选举出一个领导者节点（Leader）。这个领导者节点负责维护一组被称作同步数据副本（In-sync-replica）的节点，所有的数据写入都必须在这个领导者节点中记录。</p><p>我来举个例子，假设现在数据中心有三台服务器，一台被选为作为领导者节点，另外两台服务器用来保存数据副本，分别是Replication1和Replication2，它们两个节点就是被领导者节点维护的同步数据副本了。领导者节点知道它维护着两个同步数据副本。</p><p>如果用户想写入一个数据，假设是“Geekbang”</p><ol>\n<li>\n<p>用户会发请求到领导者节点中想写入“Geekbang”。</p>\n</li>\n<li>\n<p>领导者节点收到请求后先在本地保存好，然后也同时发消息通知Replication1和Replication2。</p>\n</li>\n<li>\n<p>Replication1和Replication2收到消息后也保存好这条消息并且回复领导者节点写入成功。</p>\n</li>\n<li>\n<p>领导者节点记录副本1和副本2都是健康（Healthy）的，并且回复用户写入成功。</p>\n</li>\n</ol><p>红色的部分是领导者节点本地日志，记录着有哪些同步数据副本是健康的。</p><p><img src=\"https://static001.geekbang.org/resource/image/d7/ca/d731b39103542c83c98bbe57aca1ecca.jpg?wh=451*443\" alt=\"\"></p><p>往后用户如果想查询写入的数据，无论是领导者节点还是两个副本都可以返回正确同步的结果。</p><p>那假如分区出现了该怎么办呢？例如领导者节点和副本1无法通讯了，这个时候流程就变成这样了。</p><ol>\n<li>\n<p>用户会发请求到领导者节点中想写入“Geekbang”。</p>\n</li>\n<li>\n<p>领导者节点收到请求后先在本地保存好，然后也同时发消息通知Replication1和Replication2。</p>\n</li>\n<li>\n<p>只有Replication2收到消息后也保存好这条消息并且回复领导者节点写入成功。</p>\n</li>\n<li>\n<p>领导者节点记录副本2是健康的，并且回复用户写入成功。</p>\n</li>\n</ol><p>同样，红色的部分是领导者节点本地日志，记录着有哪些同步数据副本是健康的。</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/f6/9d97ad203e7869019a84363c847b3cf6.jpg?wh=451*443\" alt=\"\"></p><p>如果所有副本都无法通讯的时候，Apache Kafka允许系统只有一个节点工作，也就是领导者节点。这个时候所有的写入都只保存在领导者节点了。过程如下，</p><ol>\n<li>\n<p>用户会发请求到领导者节点中想写入“Geekbang”。</p>\n</li>\n<li>\n<p>领导者节点收到请求后先在本地保存好，然后也同时发消息通知Replication1和Replication2。</p>\n</li>\n<li>\n<p>没有任何副本回复领导者节点写入成功，领导者节点记录无副本是健康的，并且回复用户写入成功。</p>\n</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/7a/5c/7a0b62273c39bbf0dbda1ca3513f595c.jpg?wh=451*443\" alt=\"\"></p><p>当然，在最坏的情况下，连领导者节点也挂了，Zookeeper会重新去寻找健康的服务器节点来当选新的领导者节点。</p><h2>小结</h2><p>通过今天的学习，我们知道在CAP定理中，一致性，可用性和分区容错性这三个属性最多只能选择两种属性保留。CAP定理在经过了差不多20年的讨论与演化之后，大家对这三个属性可能会有着自己的一些定义。</p><p>例如在讨论一致性的时候，有的系统宣称自己是拥有C属性，也就拥有一致性的，但是这个一致性并不是论文里所讨论到的线性一致性。</p><p>在我看来，作为大规模数据处理的架构师，我们应该熟知自己的系统到底应该保留CAP中的哪两项属性，同时也需要熟知，自己所应用到的平台架构是保留着哪两项属性。</p><h2>思考题</h2><p>如果让你重新设计微博系统中的发微博功能，你会选择CAP的哪两个属性呢？为什么呢？</p><p>欢迎你把答案写在留言区，与我和其他同学一起讨论。</p><p>如果你觉得有所收获，也欢迎把文章分享给你的朋友。</p><p></p>","comments":[{"had_liked":false,"id":91875,"user_name":"常超","can_delete":false,"product_type":"c1","uid":1138665,"ip_address":"","ucode":"4AE7743B4ADF20","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/e9/95ef44f3.jpg","comment_is_top":true,"comment_ctime":1557124891,"is_pvip":false,"replies":[{"id":"32932","content":"常超您好，又看到了您的留言！其实归根结底P属性还是说当Network Partition发生后，无论后面网络分区是否会恢复，分离出来的子系统都可以正常运行。您所说这几个例子确实是讲到了在Kafka Replication中，有的节点在分区后就无法再使用了，所以设计的时候并没有考虑P属性。另外还多加一句，并不是Kafka没有P属性，而是Intra-cluster Kafka Replication没有P属性。<br><br>谢谢你的参考资料，这对我和其他读者们来说都非常有帮助！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557197311,"ip_address":"","comment_id":91875,"utype":1}],"discussion_count":1,"race_medal":0,"score":"9.2233721500810998e+18","product_id":100025301,"comment_content":"关于大家出现很多疑问的Kafka是否有P属性的问题，上网搜了一下，找到一个可以说明Kafka不具备P属性的例子，不知道理解对不对，请老师和大家批评指正。<br><br>比如：在以下的场景序列下，会出现数据写入丢失的情况，所以不能说kafka是有P属性<br><br>前提：leader和两个slave 1、2<br>序列：<br>1.机器leader跟两个slave之间发生partion<br>这是leader成为唯一服务节点，继续接受写入请求w1,但是w1只保存在了leader机器上，无法复制到slave1和2<br>2.leader和zookeeper之间发生partition，导致kafka选取slave 1为新leader，新leader接受新写入w1<br>这时候，上面1的w1写入丢失了。即使之后旧leader复活，w1的写入数据也不会被恢复出来。<br>参考：https:&#47;&#47;bit.ly&#47;2VGKtu1<br>","like_count":27,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449066,"discussion_content":"常超您好，又看到了您的留言！其实归根结底P属性还是说当Network Partition发生后，无论后面网络分区是否会恢复，分离出来的子系统都可以正常运行。您所说这几个例子确实是讲到了在Kafka Replication中，有的节点在分区后就无法再使用了，所以设计的时候并没有考虑P属性。另外还多加一句，并不是Kafka没有P属性，而是Intra-cluster Kafka Replication没有P属性。\n\n谢谢你的参考资料，这对我和其他读者们来说都非常有帮助！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557197311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93223,"user_name":"王燊 شن ون","can_delete":false,"product_type":"c1","uid":1136335,"ip_address":"","ucode":"AE8A6CCED48618","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/cf/53f64618.jpg","comment_is_top":true,"comment_ctime":1557443022,"is_pvip":false,"replies":[{"id":"33277","content":"谢谢你的留言！你的理解非常正确，A就是指集群中即便挂掉几个机器但是集群对外还是正常运行的，P就是指即便机器间无法通讯了但是集群对外还是正常运行。<br><br>我对于Kafka Replication pick CA这种设计的理解是，设计师只考虑了在Replication的集群里对CA的保证而放弃了对P的保证。所以当发生Network Partition的时候，系统有可能可以工作，有可能不能继续工作。例如说C的保证是因为Kafka Replication要求了领导者节点的数据一定要同步数据副本节点上，否则不会返回这个数据；A的保证是因为无论有多少数据副本节点挂了，只要领导者节点不挂，这个Replication集群都可以返回数据，但是当领导者挂了，这整个Replication集群就不能再用了，而没了这个集群也就没有CAP属性可言了。希望这能帮助你理解，如果有不明确的地方也欢迎你继续留言提问，一起学习进步。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557454295,"ip_address":"","comment_id":93223,"utype":1}],"discussion_count":2,"race_medal":0,"score":"9.2233720942467994e+18","product_id":100025301,"comment_content":"我的理解：A是机器挂掉仍可用，P是网络挂掉仍可用。如果我的理解正确，那老师您说Kafka不支持P的解释，即当Kafka leader挂掉整个系统不可用，其实是不是表明Kafka是不支持A，而不是不支持P的？","like_count":14,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449533,"discussion_content":"谢谢你的留言！你的理解非常正确，A就是指集群中即便挂掉几个机器但是集群对外还是正常运行的，P就是指即便机器间无法通讯了但是集群对外还是正常运行。\n\n我对于Kafka Replication pick CA这种设计的理解是，设计师只考虑了在Replication的集群里对CA的保证而放弃了对P的保证。所以当发生Network Partition的时候，系统有可能可以工作，有可能不能继续工作。例如说C的保证是因为Kafka Replication要求了领导者节点的数据一定要同步数据副本节点上，否则不会返回这个数据；A的保证是因为无论有多少数据副本节点挂了，只要领导者节点不挂，这个Replication集群都可以返回数据，但是当领导者挂了，这整个Replication集群就不能再用了，而没了这个集群也就没有CAP属性可言了。希望这能帮助你理解，如果有不明确的地方也欢迎你继续留言提问，一起学习进步。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557454295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005123,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/56/43/abb7bfe3.jpg","nickname":"阿巍-豆夫","note":"","ucode":"732188848B0A85","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5679,"discussion_content":"那我的理解就是hdfs满足cap，a 一台namenode 一台datanode挂掉系统可用，c hdfs 三副本，P namnode发生分区，stand by 节点变成active 一旦拉起挂掉namnode数据反向同步。 请问这是不是cap都满足了呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566435688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91725,"user_name":"常超","can_delete":false,"product_type":"c1","uid":1138665,"ip_address":"","ucode":"4AE7743B4ADF20","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/e9/95ef44f3.jpg","comment_is_top":true,"comment_ctime":1557101584,"is_pvip":false,"replies":[{"id":"32931","content":"常超您好，感谢您的提问！<br><br>关于这个问题我是这么看的。当我们在分布式环境中讨论CAP属性的时候，P属性可以说是当任意节点断开后，系统还是可以正常的运行。对于整个Kafka系统来说，P当然是必须要保留的。可当你只从Kafka Replication来看的时候，如果一个cluster里面领导者挂掉了，单单就这个cluster来说有再多的副本存在也是无法运行了，所以就Kafka Replication来说，它没有保留P属性。<br><br>而在Kafka Replication的设计中为什么说P被放弃了呢，引用Kafka的作者之一Jun Rao在设计Kafka Replication的说法，是因为“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的Engineering官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。<br><br>不知道我的解释能否让您更好地理解，也欢迎您继续留言提问，我们一起学习进步！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557196894,"ip_address":"","comment_id":91725,"utype":1}],"discussion_count":3,"race_medal":0,"score":"9.2233720942465004e+18","product_id":100025301,"comment_content":"老师您好，文中说kafka放弃了P属性。<br>但是从后面的解释来看，即使出现分区（领导者节点和副本1无法通讯），整个系统也能正常工作，这种行为难道不是保持了P属性吗。您能否举一个P属性被放弃的例子？","like_count":14,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449004,"discussion_content":"常超您好，感谢您的提问！\n\n关于这个问题我是这么看的。当我们在分布式环境中讨论CAP属性的时候，P属性可以说是当任意节点断开后，系统还是可以正常的运行。对于整个Kafka系统来说，P当然是必须要保留的。可当你只从Kafka Replication来看的时候，如果一个cluster里面领导者挂掉了，单单就这个cluster来说有再多的副本存在也是无法运行了，所以就Kafka Replication来说，它没有保留P属性。\n\n而在Kafka Replication的设计中为什么说P被放弃了呢，引用Kafka的作者之一Jun Rao在设计Kafka Replication的说法，是因为“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的Engineering官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。\n\n不知道我的解释能否让您更好地理解，也欢迎您继续留言提问，我们一起学习进步！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557196894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111899,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","nickname":"时隐时现","note":"","ucode":"DA4D622FF84920","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28372,"discussion_content":"&#34;如果一个cluster里面领导者挂掉了，单单就这个cluster来说有再多的副本存在也是无法运行了&#34; leader挂掉了，剩余的replica完全可以再重新选新主，怎么会整个cluster都无法运行？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570692866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1114356,"avatar":"https://static001.geekbang.org/account/avatar/00/11/00/f4/cc5f0896.jpg","nickname":"Jowin","note":"","ucode":"19017F7D06C22A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326096,"discussion_content":"kafka复制集这种设计，在发生副本挂掉后，集群继续可用；在leader挂掉后，集群不可用，知道选出新的leader；因此，从复制集的角度，它选择了CA，在能保证一致性的情况下(副本挂掉)系统可用，除非无法保证一致性(Leader挂掉)。\n从kafka的producer角度看，发送消息是可以指定ack数量，只有达到指定数量的副本写入成功，才算消息写入成功，这其实也是CA的手段(如果只有Leader写入成功，当Leader挂掉后，新选举出来的Leader会缺失部分消息)。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605520361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91770,"user_name":"锦","can_delete":false,"product_type":"c1","uid":1468298,"ip_address":"","ucode":"CB0EB4B68C468B","user_header":"https://static001.geekbang.org/account/avatar/00/16/67/8a/babd74dc.jpg","comment_is_top":true,"comment_ctime":1557105739,"is_pvip":false,"replies":[{"id":"32928","content":"谢谢你的答案。<br><br>关于疑问一：MongoDB的设计默认是希望读写有strong consistency的。当然MongoDB也有自身的Replica Set来保证可用性：https:&#47;&#47;docs.mongodb.com&#47;manual&#47;replication&#47;#replication-in-mongodb<br>关于疑问二：你说的没有错，作为多个data clusters来说，Kafka系统是不可能放弃P的，不然一旦leader挂掉系统就没有任何结果可以返回了。但是我在这一讲中所讲述的Intra-cluster Kafka Replication Design是对于一个cluster来说。就像我回答其他有同样疑问的读者一样，之所以我在文中说Kafka Replication选择了CA，是因为Kafka的作者之一Jun Rao在设计Kafka Replication的时候，明确说明了“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。<br><br>学习之后提出疑问是一个很好的习惯，也希望后面继续看到你的留言！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557196003,"ip_address":"","comment_id":91770,"utype":1}],"discussion_count":2,"race_medal":0,"score":"9.2233720470018007e+18","product_id":100025301,"comment_content":"AP，发微博保证最终一致性就可以。<br>疑问一，mongodb采用CP，那么它在可用性方面有做什么事情吗？<br>疑问二，kafka这种通过选举leader的方式不就是分区容错性吗？为什么说放弃了P呢？","like_count":2,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449023,"discussion_content":"谢谢你的答案。\n\n关于疑问一：MongoDB的设计默认是希望读写有strong consistency的。当然MongoDB也有自身的Replica Set来保证可用性：https://docs.mongodb.com/manual/replication/#replication-in-mongodb\n关于疑问二：你说的没有错，作为多个data clusters来说，Kafka系统是不可能放弃P的，不然一旦leader挂掉系统就没有任何结果可以返回了。但是我在这一讲中所讲述的Intra-cluster Kafka Replication Design是对于一个cluster来说。就像我回答其他有同样疑问的读者一样，之所以我在文中说Kafka Replication选择了CA，是因为Kafka的作者之一Jun Rao在设计Kafka Replication的时候，明确说明了“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。\n\n学习之后提出疑问是一个很好的习惯，也希望后面继续看到你的留言！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557196003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667727,"avatar":"","nickname":"Geek_guys","note":"","ucode":"4B4EBF0254D4A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21304,"discussion_content":"呵呵","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569465277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":100264,"user_name":"mccrms","can_delete":false,"product_type":"c1","uid":1232528,"ip_address":"","ucode":"EE65C5B2012A0F","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/90/fafbbe0b.jpg","comment_is_top":false,"comment_ctime":1559519723,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"177653178859","product_id":100025301,"comment_content":"文中提到的CA示例其实是有很强的误导性的。<br><br>首先我们要明确如下的事实:<br>1)对于一个分布式系统而言，节点故障和网络故障属于常态<br>2)如果出现网络故障，会造成节点分区<br>3)分布式系统在存在节点分区的情况下，C和A是冲突的<br><br>通过上面的事实我们可以推断出，如果想设计出一个CA系统，必须保证网络不出现分区才有可能，怎样保证网络不出现分区呢，一是单台机器，二是像例子中所述，将所有节点放在同个数据中心中可以假定网络出现分区的概率很低。这也是为什么例子中的情况可以假装称为CA。<br><br>还有一些需要辅助理解CAP的知识如下:<br>1)对于分布式系统而言，最简单可以分为两种，一是所有节点通过都可以通过某种策略对外提供服务，是对等的，二是所有节点通过一个master对外提供服务，甚至是一个单点的master<br>2)探讨系统CAP的前提应该是系统在能提供服务的情况下的CAP，如果存在master单点，但是有很多从属worker的话，这时的可用性探讨需要划分为worker故障和master故障来看。对于文中的例子master如果挂掉系统不可用则表名A其实也是勉强的<br><br>CAP Theorem is like the old joke about software projects: you can have it on TIME, in BUDGET, or CORRECT. Pick any two😀<br><br>CAP三者互相制衡，应该是看侧重哪两个，而不是选了哪两个，不是两个100分剩下的一个0分，本质上都要兼顾的。","like_count":42,"discussions":[{"author":{"id":1045945,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","nickname":"不记年","note":"","ucode":"287E40C68356DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213712,"discussion_content":"这个解释厉害\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585115463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111899,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/5b/d2e7c2c4.jpg","nickname":"时隐时现","note":"","ucode":"DA4D622FF84920","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28383,"discussion_content":"正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570693394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91880,"user_name":"Codelife","can_delete":false,"product_type":"c1","uid":1041421,"ip_address":"","ucode":"10458683978083","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhMtBwGqqmyhxp5uaDTvvp18iaalQj8qHv6u8rv1FQXGozfl3alPvdPHpEsTWwFPFVOoP6EeKT4bw/132","comment_is_top":false,"comment_ctime":1557125980,"is_pvip":false,"replies":[{"id":"32908","content":"谢谢你的留言！你的理解非常正确，就是因为这样Kafka Replication的设计中不需要考虑到P的存在，让整个Replication Design成为CA系统。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557190626,"ip_address":"","comment_id":91880,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74571570012","product_id":100025301,"comment_content":"严格来说,CAP理论是针对分区副本来定义的，之所以说kafka放弃P，只支持CA，是因为，kafka原理中当出现单个broke宕机，将要出现分区的时候，直接将该broke从集群中剔除，确保整个集群不会出现P现象","like_count":18,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449068,"discussion_content":"谢谢你的留言！你的理解非常正确，就是因为这样Kafka Replication的设计中不需要考虑到P的存在，让整个Replication Design成为CA系统。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557190626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110662,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg","nickname":"Hank_Yan","note":"","ucode":"86899B561C502B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289452,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594104516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":122682,"user_name":"coldpark","can_delete":false,"product_type":"c1","uid":1058331,"ip_address":"","ucode":"D1B0F343B384F8","user_header":"https://static001.geekbang.org/account/avatar/00/10/26/1b/4caf36bd.jpg","comment_is_top":false,"comment_ctime":1565488529,"is_pvip":false,"replies":[{"id":"47609","content":"是有一定道理","user_name":"作者回复","user_name_real":"Yuannan蔡元楠","uid":"1257426","ctime":1566882956,"ip_address":"","comment_id":122682,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31630259601","product_id":100025301,"comment_content":"有一个形象的比喻不知道恰当不恰当，一个系统相当于一个团队，有C属性说明这个团队每次都能保质保量完成任务，A属性说明这个团队每次都能及时完成任务，P属性相当于这个团队内部偶尔会犯一些小错误。犯错是很常见的，所以一般都具有P属性。<br>CP类型的团队对外的形象相当于：我的团队不是完美的，但我的产品绝对不会出问题，只要你给我足够的时间让我们把问题排查清楚。<br>AP类型的团队给人的感觉就是：人非圣贤，孰能无过，我的队员会犯错，我的团队也有估计不足的时候，但是客户的需求我们总会最快响应。<br>CA类型的团队有个强人领袖（leader节点）：任何事务无论大小都过问一遍，一旦发现手下有人犯错，立马剔除出团队，如果自己犯错，让出领袖地位，整个团队一定要保证最快最好完成任务。","like_count":7,"discussions":[{"author":{"id":1257426,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/d2/0b6a8945.jpg","nickname":"Yuannan蔡元楠","note":"","ucode":"695E183CE496A8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462359,"discussion_content":"是有一定道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566882956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98520,"user_name":"Zoe","can_delete":false,"product_type":"c1","uid":1528912,"ip_address":"","ucode":"A5D671919EE7B1","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/50/8a76a8cc.jpg","comment_is_top":false,"comment_ctime":1559015821,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14443917709","product_id":100025301,"comment_content":"查了查文档，对于Kafka没有考虑P因素，是因为相同的partition （leader和replications）都在同一个data center里，大概是说不需要去考虑P。<br><br>但对于同时满足CA还请老师再解释一下。文档里说，可以config availability over durability，也可以反之。<br>如果选择availability的话，设置acks=all，可以保证isr里登记在册的broker都接收到信息，但isr里也可能只有leader一个。所以当leader挂了之后到再选出新leader期间就有数据丢失的可能性。<br>如果选择durability的话可以设置min_insync_replicas，但如果小于这个threshold的时候，不是得等着某个broker恢复，这样不就牺牲availabilty了吗？<br><br>所以，到底C和A是如何都满足的？","like_count":3,"discussions":[{"author":{"id":1106802,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e3/72/afd1eef0.jpg","nickname":"柳年思水","note":"","ucode":"65589C121B904A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1838,"discussion_content":"我的理解是这样的：设置 acks=all及 min_isr 的情况下（服务端还要禁止脏选举，这些配置是不丢的必要条件，可以看下这个：http://matt33.com/2017/09/04/kafka-best-pratice/#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2），假设这个 partition有 3 个副本，min_isr设置为 2，那么这个系统最多容忍 1 台机器故障，而且系统还是可以保证强一致性的，也就是满足了 CA 的特性。\n关于你说的挂掉的机器小于 min_isr 时需要等待的情况，分布式系统的 A 是有要求的，容忍故障的机器是限制的，并不是说所有机器挂了，我还能保证可用性。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1562943039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91813,"user_name":"桃园悠然在","can_delete":false,"product_type":"c1","uid":1017637,"ip_address":"","ucode":"704460D9CAD1CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/25/898dea4e.jpg","comment_is_top":false,"comment_ctime":1557113313,"is_pvip":false,"replies":[{"id":"32904","content":"谢谢你的支持，哈哈！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557189433,"ip_address":"","comment_id":91813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442015201","product_id":100025301,"comment_content":"另外，增加一个评论：蔡老师的文章头图每张都跟内容强相关（不知是否自己P图或者照相的），而且右上角有文章序号很用心，点赞！","like_count":3,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449042,"discussion_content":"谢谢你的支持，哈哈！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557189433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91772,"user_name":"王聪 Claire","can_delete":false,"product_type":"c1","uid":1090310,"ip_address":"","ucode":"0D9CC82C9F44D4","user_header":"https://static001.geekbang.org/account/avatar/00/10/a3/06/9fa93074.jpg","comment_is_top":false,"comment_ctime":1557105967,"is_pvip":false,"replies":[{"id":"32877","content":"谢谢你的提问！我的理解是如果仅仅就一个Kafka Replication cluster来说，如果领导者挂了我们就不会再从这个cluster拿到内容了，所以在Intra-cluster Replication这个设计点上，他们是不考虑P的。<br><br>之所以我在文中说Kafka Replication选择了CA，是因为Kafka的作者之一Jun Rao在设计Kafka Replication的时候，明确说明了“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。<br><br>所以你会发现，他们的设计思路是仅仅就Intra-cluster的data replication出发的。当然，如果从整个Kafka系统来说，是不可能放弃P的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557185087,"ip_address":"","comment_id":91772,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14442007855","product_id":100025301,"comment_content":"kafka 的replication机制，即使出现分区这样的错误，系统也能够通过领导者节点返回消息。怎么算放弃了P呢？谢谢。","like_count":3,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449025,"discussion_content":"谢谢你的提问！我的理解是如果仅仅就一个Kafka Replication cluster来说，如果领导者挂了我们就不会再从这个cluster拿到内容了，所以在Intra-cluster Replication这个设计点上，他们是不考虑P的。\n\n之所以我在文中说Kafka Replication选择了CA，是因为Kafka的作者之一Jun Rao在设计Kafka Replication的时候，明确说明了“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。\n\n所以你会发现，他们的设计思路是仅仅就Intra-cluster的data replication出发的。当然，如果从整个Kafka系统来说，是不可能放弃P的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557185087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136532,"user_name":"Geek_guys","can_delete":false,"product_type":"c1","uid":1667727,"ip_address":"","ucode":"4B4EBF0254D4A0","user_header":"","comment_is_top":false,"comment_ctime":1569465701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10159400293","product_id":100025301,"comment_content":"其实为啥要纠结这些文字概念呢，个人感觉老师在文章里讲的这些例子很容易误导听众和读者，有些根本就没有讲清楚，比如redis你说是CP，大家知道redis的高可用有主从模式，哨兵模式，cluster模式，如果脱离这些架构或者业务场景讲CAP，未免太有点纸上谈兵，不敢苟同。CAP不是一套方法论，而是一个结果，任何分布式系统的设计一定是在特定环境下解决某个或者某些问题，CAP只是这些设计后的一个结果而已。","like_count":2},{"had_liked":false,"id":94317,"user_name":"和你一起搬砖的胡大爷","can_delete":false,"product_type":"c1","uid":1008587,"ip_address":"","ucode":"54607F4E17917A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/cb/7c004188.jpg","comment_is_top":false,"comment_ctime":1557768435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10147703027","product_id":100025301,"comment_content":"kafka的例子其实复杂，不大适合举p的例子，kafka也不一定要全sync之后写入才确认，isr也是可以配的。我的理解这里损失p是在isr不等于replica，分区后leader不见了，一个没同步的replica变成leader，一会leader回来了，两边数据就对不上了。如果isr设置成和replica一致，一旦分区了，有replica无法写入了，kafka那个log就没法用了. 但是如果isr能按生存节点收缩，是不是这个问题也解决了。","like_count":2},{"had_liked":false,"id":93868,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1557644807,"is_pvip":false,"replies":[{"id":"33521","content":"谢谢你的再次留言！是的，理解正确！既然replication1对于集群来说现在以及以后都不可用了，也就相对于集群没有了这个replication1，那也就不存在说网络分区后replication1还是否在集群正常运行的问题了。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557648032,"ip_address":"","comment_id":93868,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10147579399","product_id":100025301,"comment_content":"老师，我好像懂了。kafka replication不保证p，指的是当网络出现分区后，和主有一台副本比如replicatin1和leader失联了，那replication1就会被踢出去，相当它于宕机了。在这里，分区导致replication1不可用了，所以说不保证p。<br>是这样理解吗？","like_count":2,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449802,"discussion_content":"谢谢你的再次留言！是的，理解正确！既然replication1对于集群来说现在以及以后都不可用了，也就相对于集群没有了这个replication1，那也就不存在说网络分区后replication1还是否在集群正常运行的问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557648032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93672,"user_name":"J.M.Liu","can_delete":false,"product_type":"c1","uid":1200037,"ip_address":"","ucode":"B2CB84B8E923A6","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/a5/71358d7b.jpg","comment_is_top":false,"comment_ctime":1557556352,"is_pvip":false,"replies":[{"id":"33498","content":"谢谢你的留言！其实选择CA的系统是少之又少，你的问题里面提到了一个关键点，当机子挂掉的时候或者当网络分区出现的时候，系统会直接将这个机子从集群中剔除掉了，也就是说无论以后这个机子处于什么状态都不会再出现在这个集群中，在集群中剩下的机子数据一直都是同步的，所以就有了有CA却不存在P的说法了。不知道这个解释你觉得怎么样，同时也欢迎你不理解的话继续提问。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557641841,"ip_address":"","comment_id":93672,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10147490944","product_id":100025301,"comment_content":"不太理解ca系统，允许有机子挂掉，却不允许网络分区。机子都挂掉了，到这台机子的网络可不就是连不通了吗？ 允许机子化掉却不允许机子和集群失联，这是个悖论呀。怎么理解这个呢老师","like_count":2,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449725,"discussion_content":"谢谢你的留言！其实选择CA的系统是少之又少，你的问题里面提到了一个关键点，当机子挂掉的时候或者当网络分区出现的时候，系统会直接将这个机子从集群中剔除掉了，也就是说无论以后这个机子处于什么状态都不会再出现在这个集群中，在集群中剩下的机子数据一直都是同步的，所以就有了有CA却不存在P的说法了。不知道这个解释你觉得怎么样，同时也欢迎你不理解的话继续提问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557641841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91808,"user_name":"桃园悠然在","can_delete":false,"product_type":"c1","uid":1017637,"ip_address":"","ucode":"704460D9CAD1CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/25/898dea4e.jpg","comment_is_top":false,"comment_ctime":1557113082,"is_pvip":false,"replies":[{"id":"32934","content":"谢谢你的留言！P属性的好处是在分布式环境下，无论网络发不发生分区，整个系统都可以照常运行。不管分区后用户读到的是stale data，还是up-to-date data。像常超同学的留言中举了几个例子，如果系统设计上没有了P属性，很多时候network partition发生了， 那剩下的一些节点可能就无法再用了，最坏的情况下可能整个系统都无法运行下去。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557197537,"ip_address":"","comment_id":91808,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10147047674","product_id":100025301,"comment_content":"我理解kafka作为一个消息系统平台，是不允许消息丢失的，所以通过replication机制冗余数据保证。但是P属性更像是一个缺点（容忍了消息丢失），它的好处该怎么理解呢？谢谢老师！","like_count":2,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449040,"discussion_content":"谢谢你的留言！P属性的好处是在分布式环境下，无论网络发不发生分区，整个系统都可以照常运行。不管分区后用户读到的是stale data，还是up-to-date data。像常超同学的留言中举了几个例子，如果系统设计上没有了P属性，很多时候network partition发生了， 那剩下的一些节点可能就无法再用了，最坏的情况下可能整个系统都无法运行下去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557197537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91732,"user_name":"wmg","can_delete":false,"product_type":"c1","uid":1070036,"ip_address":"","ucode":"BA4CED171B59E9","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/d4/2ed767ea.jpg","comment_is_top":false,"comment_ctime":1557102319,"is_pvip":false,"replies":[{"id":"32911","content":"谢谢你的提问！对于整个Kafka系统来说，你的理解是正确的！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557191036,"ip_address":"","comment_id":91732,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10147036911","product_id":100025301,"comment_content":"老师，如果kafka支持必须同步节点写成功，那是不是就是一个cp系统，如果支持非健康节点选举为leader，是不是就是ap系统？","like_count":2,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449007,"discussion_content":"谢谢你的提问！对于整个Kafka系统来说，你的理解是正确的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557191036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94739,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1557887726,"is_pvip":false,"replies":[{"id":"34206","content":"谢谢你的留言！最终一致性和线性一致性并不是一个意思。<br><br>线性一致性是属于强一致性，如果用在微博上就是说如果一个用户发了一条新的微博，那这个用户的所有好友在刷新这个的用户微博的时候都一定要看到这条新的微博。<br><br>如果是最终一致性的话，指的是如果一个用户发了一条新的微博，那这个用户的好友刷新这个用户微博的时候，有可能会看到这条新的微博，也有可能看不到。但是不断地刷新之后，经过一段时间最终所有的用户总会看到这条新的微博。<br><br>所以说发微博一般都会用到AP属性。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1558128832,"ip_address":"","comment_id":94739,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852855022","product_id":100025301,"comment_content":"谢谢老师，是不了解微博的机制，请问老师，发微博应该要用什么CAP属性？<br>看到留言有人说，发微博保证最终一致性就好，不知道这个跟CAP的线性一致性是不是一个意思？<br>","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450189,"discussion_content":"谢谢你的留言！最终一致性和线性一致性并不是一个意思。\n\n线性一致性是属于强一致性，如果用在微博上就是说如果一个用户发了一条新的微博，那这个用户的所有好友在刷新这个的用户微博的时候都一定要看到这条新的微博。\n\n如果是最终一致性的话，指的是如果一个用户发了一条新的微博，那这个用户的好友刷新这个用户微博的时候，有可能会看到这条新的微博，也有可能看不到。但是不断地刷新之后，经过一段时间最终所有的用户总会看到这条新的微博。\n\n所以说发微博一般都会用到AP属性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558128832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93792,"user_name":"LaimanYeung","can_delete":false,"product_type":"c1","uid":1503079,"ip_address":"","ucode":"D809F2842031CA","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/67/bb9d9358.jpg","comment_is_top":false,"comment_ctime":1557593293,"is_pvip":false,"replies":[{"id":"33488","content":"谢谢你的总结！非常棒！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557639495,"ip_address":"","comment_id":93792,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5852560589","product_id":100025301,"comment_content":"A：集群某个或某几节点挂掉时，客户端仍然可以访问服务端.<br>C：客户访问集群中任一服务端，返回的状态都是一致的.<br>P：集群内部机器通讯出现问题导致服务A的数据无法同步到其他节点时，客户端访问服务A，服务A扔能返回未同步到其他节点的数据.","like_count":2,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449771,"discussion_content":"谢谢你的总结！非常棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557639495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066752,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","nickname":"piboye","note":"","ucode":"7CFD8712857A85","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311046,"discussion_content":"a 不光是节点挂了吧，分区是指节点间网络不同，但和客户端的连接是通的。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602201953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93418,"user_name":"hua168","can_delete":false,"product_type":"c1","uid":1065255,"ip_address":"","ucode":"CFF9A7E86EBA48","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/27/3ff1a1d6.jpg","comment_is_top":false,"comment_ctime":1557467201,"is_pvip":false,"replies":[{"id":"33556","content":"谢谢你的提问！<br>1. 是的，节点是指所有的节点。<br>2. 如果按照你所说的架构，两个节点都允许写入数据的话，中间肯定会有一个master node去同步这些写入数据。而我所理解在你说的例子中可以随机读取任意一个node的数据这种架构，你可以参考dynamo quorum的做法，要保持同步的话不可能只读一个node的数据，而是要读取N个nodes的数据看看是否一致，如果一致了才返回结果给客户。<br>3. 如果是按照专栏中所讲的Kafka Replication的例子，因为出现network partition出现而导致replication节点无法同步数据了，那这个replication节点就会被剔除出集群，剩下的所有节点数据还是同步的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557700366,"ip_address":"","comment_id":93418,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852434497","product_id":100025301,"comment_content":"Availability和Partition Tolerance并不是由是否允许数据丢失来判断的。<br><br>我来举个例子说明吧。假设现在有一个由两个节点组成的集群，这两个节点都可以独立运作也可以与对方通讯，而客户端是与这个集群通讯的。作为一个集群来说，Availability指的是不管这两个节点哪一个节点坏掉不能运作了，对于客户端来说还是可以继续与这个集群进行通讯的。Partition Tolerance指得是，本来这两个节点可能是需要互相通讯来同步数据的，而因为Network Partition使得它们之间不能通讯了，但是对于客户端来说还是可以继续与这个集群进行通讯的。<br><br>按照您这样说，我疑惑的是：<br>1. 节点是所有节点，包括主节点吧？<br>2. 两个节点之间，如果有数据分别写入的话，那不就是数据不一致吗？<br>  如果node1写入A数据，node2被写入B数据，怎同步？那数据不是乱套了？读也出现不一的情况<br>比如是金钱类的，不能是负数，我请求node1花完了，我刷新一下又访问到node2发现还是原来，我又花完了，那我不是可以花双倍？一同步那不是出错？同步不了，因为扣双倍，已小于0<br><br>3. 如果是CA的话，P出问题，不是出现不一致吗，那么我怎么保证C？","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449624,"discussion_content":"谢谢你的提问！\n1. 是的，节点是指所有的节点。\n2. 如果按照你所说的架构，两个节点都允许写入数据的话，中间肯定会有一个master node去同步这些写入数据。而我所理解在你说的例子中可以随机读取任意一个node的数据这种架构，你可以参考dynamo quorum的做法，要保持同步的话不可能只读一个node的数据，而是要读取N个nodes的数据看看是否一致，如果一致了才返回结果给客户。\n3. 如果是按照专栏中所讲的Kafka Replication的例子，因为出现network partition出现而导致replication节点无法同步数据了，那这个replication节点就会被剔除出集群，剩下的所有节点数据还是同步的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557700366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92803,"user_name":"涵","can_delete":false,"product_type":"c1","uid":1502742,"ip_address":"","ucode":"BB8575DB13F1E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/ee/16/742956ac.jpg","comment_is_top":false,"comment_ctime":1557328581,"is_pvip":false,"replies":[{"id":"33221","content":"谢谢你的提问！现在在很多系统的设计中都是可以通过调节系统配置来达到CP或者AP的功能，但是不可能同时满足C、A、P这三个属性。<br>像很多同学们都会提到的，如果一套系统里有了主从复制集群这种高可用的架构，那是不是这个系统就一定是AP系统了？其实也不一定的。举个例子，如果系统已经搭建了主从复制的高可用架构，但是系统想达到CP，而这个时候主节点和从节点的数据更新可能并不一致，但是主节点因为某些原因无法连通或者是暂时崩溃了，系统可以选择对客户端的请求不返回任何结果，因为数据不一致。那这个时候系统其实就没有达到A属性了。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557427725,"ip_address":"","comment_id":92803,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852295877","product_id":100025301,"comment_content":"老师好，通过您对kafka replication的讲解，以及同学们分析的其他系统，感觉一个分布式平台在设计时需要选择保障CP或AP，被拿掉的A或C也不是完全不考虑，会通过一些其他的辅助系统来支持保障，所以对于平台来说绝大多数时间是可以做到CAP的。不知道这样理解是否正确?","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449388,"discussion_content":"谢谢你的提问！现在在很多系统的设计中都是可以通过调节系统配置来达到CP或者AP的功能，但是不可能同时满足C、A、P这三个属性。\n像很多同学们都会提到的，如果一套系统里有了主从复制集群这种高可用的架构，那是不是这个系统就一定是AP系统了？其实也不一定的。举个例子，如果系统已经搭建了主从复制的高可用架构，但是系统想达到CP，而这个时候主节点和从节点的数据更新可能并不一致，但是主节点因为某些原因无法连通或者是暂时崩溃了，系统可以选择对客户端的请求不返回任何结果，因为数据不一致。那这个时候系统其实就没有达到A属性了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557427725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92071,"user_name":"刘万里","can_delete":false,"product_type":"c1","uid":1504306,"ip_address":"","ucode":"B4E54997D1455F","user_header":"https://static001.geekbang.org/account/avatar/00/16/f4/32/c4550f66.jpg","comment_is_top":false,"comment_ctime":1557185961,"is_pvip":false,"replies":[{"id":"32894","content":"谢谢你的留言！现在来说还没有专门介绍Apache Beam的书籍，不过如果你想了解底层思想的还，可以看Tyler Akidau写的Streaming Systems。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557188207,"ip_address":"","comment_id":92071,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852153257","product_id":100025301,"comment_content":"老师，您有apache beam相关的书推荐吗？谢谢","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449137,"discussion_content":"谢谢你的留言！现在来说还没有专门介绍Apache Beam的书籍，不过如果你想了解底层思想的还，可以看Tyler Akidau写的Streaming Systems。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557188207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91951,"user_name":"挖矿的小戈","can_delete":false,"product_type":"c1","uid":1503917,"ip_address":"","ucode":"2078A85139BD5D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/9chAb6SjxFiapSeicsAsGqzziaNlhX9d5aEt8Z0gUNsZJ9dICaDHqAypGvjv4Bx3PryHnj7OFnOXFOp7Ik21CVXEA/132","comment_is_top":false,"comment_ctime":1557143427,"is_pvip":false,"replies":[{"id":"32892","content":"谢谢你的留言！<br>1. 是的呢，Kafka Replication的设计思想就是因为一个数据中心中很少会出现Network Partition所以主攻高可用和强一致性。你的理解是对的，不过感觉很多其他读者误会了我所说的Kafka Replication，理解成整个Kafka系统都是CA系统了，哈哈。<br>2. 我也学习受教了，谢谢！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557188063,"ip_address":"","comment_id":91951,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852110723","product_id":100025301,"comment_content":"1. kafka作为CA系统的理解：<br>      kafka的设计是只需要保证单个数据中心的broker之间能够数据复制就好，出现网络分区的情况比较少，因此他主攻高可用和强一致性<br>2.  文中，老师提到kafka的Leader选举是由Zookeeper选举的，这儿有点不严谨<br>     原因：kafka会由Zookeeper选举一台broker作为controller，之后由controller来维护partition的leader、flower，而leader宕机之后进行新leader的选举也是由controller负责的<br>3. 微博发微博的功能，满足AP就行，C的话只需要是最终一致性就好，就跟微信朋友圈一样","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449095,"discussion_content":"谢谢你的留言！\n1. 是的呢，Kafka Replication的设计思想就是因为一个数据中心中很少会出现Network Partition所以主攻高可用和强一致性。你的理解是对的，不过感觉很多其他读者误会了我所说的Kafka Replication，理解成整个Kafka系统都是CA系统了，哈哈。\n2. 我也学习受教了，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557188063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91950,"user_name":"挖矿的小戈","can_delete":false,"product_type":"c1","uid":1503917,"ip_address":"","ucode":"2078A85139BD5D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/9chAb6SjxFiapSeicsAsGqzziaNlhX9d5aEt8Z0gUNsZJ9dICaDHqAypGvjv4Bx3PryHnj7OFnOXFOp7Ik21CVXEA/132","comment_is_top":false,"comment_ctime":1557143368,"is_pvip":false,"replies":[{"id":"32891","content":"谢谢你的留言！<br>1. 是的呢，Kafka Replication的设计思想就是因为一个数据中心中很少会出现Network Partition所以主攻高可用和强一致性。你的理解是对的，不过感觉很多其他读者误会了我所说的Kafka Replication，理解成整个Kafka系统都是CA系统了，哈哈。<br>2. 我也学习受教了，谢谢！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557188056,"ip_address":"","comment_id":91950,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852110664","product_id":100025301,"comment_content":"1. kafka作为CA系统的理解：<br>      kafka的设计是只需要保证单个数据中心的broker之间能够数据复制就好，出现网络分区的情况比较少，因此他主攻高可用和强一致性<br>2.  文中，老师提到kafka的Leader选举是由Zookeeper选举的，这儿有点不严谨<br>     原因：kafka会由Zookeeper选举一台broker作为controller，之后由controller来维护partition的leader、flower，而leader宕机之后进行新leader的选举也是由controller负责的<br>3. 微博发微博的功能，满足AP就行，C的话只需要是最终一致性就好，就跟微信朋友圈一样","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449094,"discussion_content":"谢谢你的留言！\n1. 是的呢，Kafka Replication的设计思想就是因为一个数据中心中很少会出现Network Partition所以主攻高可用和强一致性。你的理解是对的，不过感觉很多其他读者误会了我所说的Kafka Replication，理解成整个Kafka系统都是CA系统了，哈哈。\n2. 我也学习受教了，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557188056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91949,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1146910,"ip_address":"","ucode":"10638C8601A7CD","user_header":"https://static001.geekbang.org/account/avatar/00/11/80/1e/784e50c9.jpg","comment_is_top":false,"comment_ctime":1557143288,"is_pvip":false,"replies":[{"id":"32907","content":"谢谢你的留言！我也学习了。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557190236,"ip_address":"","comment_id":91949,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852110584","product_id":100025301,"comment_content":"Kafka集群leader维护了一个in-sync replica (ISR) set，表示一个和leader保持同步的follower集合，如果follower长时间未向leader同步数据，时间超过一个设置的参数，则该follower就会被踢出ISR，而后该follower回重启自己并向leader同步数据，通过这种方法避免长时间不能同步数据的问题","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449093,"discussion_content":"谢谢你的留言！我也学习了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557190236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91858,"user_name":"kris37","can_delete":false,"product_type":"c1","uid":1179297,"ip_address":"","ucode":"65555B42CFF0A1","user_header":"","comment_is_top":false,"comment_ctime":1557121069,"is_pvip":true,"replies":[{"id":"33041","content":"谢谢你的留言！仅对这个cluster的Replication而言，这个理解是正确的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557266999,"ip_address":"","comment_id":91858,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852088365","product_id":100025301,"comment_content":"kafka之所以说是ca系统，是因为他跟本就不保证p，因为发生了p kafka 的被独立的分区部分无法保证c 也无法保证a","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449061,"discussion_content":"谢谢你的留言！仅对这个cluster的Replication而言，这个理解是正确的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557266999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91835,"user_name":"陈建斌红了..","can_delete":false,"product_type":"c1","uid":1073301,"ip_address":"","ucode":"575F04D041C2C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/95/08571d0b.jpg","comment_is_top":false,"comment_ctime":1557117234,"is_pvip":false,"replies":[{"id":"33059","content":"谢谢你的经验分享！Redis在最初设计的时候，是属于single server的，即便后面有了主从复制的机制，当主节点挂了只要你不从Secondary node读取数据，还是可以保证数据的一致性，所以业界一直称Redis是属于CP system。<br><br>当然你说得也很对，在Redis有了Sentinel系统之后也可以提供High availability了。虽然我很少用到Redis，你所说的key rehash应该是属于Sentinel中quorum的一种应用，用来侦测有哪些节点挂了。<br><br>最后我想引用一下Reids作者Antirez的话：“Redis Cluster for instance is a system biased towards consistency than availability. Redis Sentinel itself is an HA solution with the dogma of consistency and master slave setups.”","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557278134,"ip_address":"","comment_id":91835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852084530","product_id":100025301,"comment_content":"redis是ap 吧，redis集群挂一台，key会rehash，保证可用。redis做分不式锁，主节点挂了，假如主还没来得及同步数据，数据丢了，锁会被申请多次。保证你能申请，这是可用性，不限制你申请多次，这是没有一致性。","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449051,"discussion_content":"谢谢你的经验分享！Redis在最初设计的时候，是属于single server的，即便后面有了主从复制的机制，当主节点挂了只要你不从Secondary node读取数据，还是可以保证数据的一致性，所以业界一直称Redis是属于CP system。\n\n当然你说得也很对，在Redis有了Sentinel系统之后也可以提供High availability了。虽然我很少用到Redis，你所说的key rehash应该是属于Sentinel中quorum的一种应用，用来侦测有哪些节点挂了。\n\n最后我想引用一下Reids作者Antirez的话：“Redis Cluster for instance is a system biased towards consistency than availability. Redis Sentinel itself is an HA solution with the dogma of consistency and master slave setups.”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557278134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91760,"user_name":"Geek_1987v5","can_delete":false,"product_type":"c1","uid":1514466,"ip_address":"","ucode":"603A31AF885149","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/lUOVNGBvDTqss5XExibXsOrx1mAM7raMhQbdEHdkAeIEGLoK2wJXjy1QiaDKZlQ9vLjTyZcia39KVmrpzJB8zRhqA/132","comment_is_top":false,"comment_ctime":1557105063,"is_pvip":false,"replies":[{"id":"32905","content":"谢谢你的留言！如果选择CP的话就要考虑到如果用户访问不到微博了会有很多不满哦。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557189500,"ip_address":"","comment_id":91760,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852072359","product_id":100025301,"comment_content":"CP","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449020,"discussion_content":"谢谢你的留言！如果选择CP的话就要考虑到如果用户访问不到微博了会有很多不满哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557189500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91758,"user_name":"9527","can_delete":false,"product_type":"c1","uid":1032735,"ip_address":"","ucode":"04B51C09E3C7B8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c2/1f/343f2dec.jpg","comment_is_top":false,"comment_ctime":1557104844,"is_pvip":false,"replies":[{"id":"33072","content":"你好，谢谢你的提问！<br>1. 没错，线性一致性可以理解为强一致性。<br>2. 关于公司选择哪一个技术栈可能还是取决于自身的应用场景和需求的。像当时Facebook决定放弃Cassandra而使用HBase的原因，原文是说“We found Cassandra&#39;s eventual consistency model to be a difficult pattern<br>to reconcile for our new Messages infrastructure.”。所以对于Facebook而言，就像你所说的，最终一致性模型导致了Facebook放弃它。<br>3. Partition tolerance一般在系统中都不会少的，因为要保证出现网络分区后系统能正常运行。对于A的理解可以这么看，主从备份确实是能提高Availability，不过问题要这么看。HBase是要保证strong consistency的，如果不同节点的数据不一致，即便节点还在运行HBase也无法返回结果。<br>4. 这个要看你怎么配置了，如果是一个MySql集群，那就是CP了，如果你配置多个同步的MySql集群，那就是AP。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557281959,"ip_address":"","comment_id":91758,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852072140","product_id":100025301,"comment_content":"老师好，我有几个问题不明白<br>1.文中提到的一致性是线性一致的，这个是相当于强一致性吗<br><br>2.Cassandra是AP的，HBase是CP的，很多项目都将HBase替代了Cassandra，是因为运维水平上来了，可以用运维来弥补HBase中高可用的不足吗，而Cassandra被很多项目弃用是因为它不是最终一致性的，导致在一段时间窗口内会出现数据不一致，这样理解对吗？<br><br>3.HBase的Master可以起多个作为备份避免单点问题，那不是应该是CA吗，为什么是CP呢？<br><br>4.MySql集群应该是属于CA还是CP呢？","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449018,"discussion_content":"你好，谢谢你的提问！\n1. 没错，线性一致性可以理解为强一致性。\n2. 关于公司选择哪一个技术栈可能还是取决于自身的应用场景和需求的。像当时Facebook决定放弃Cassandra而使用HBase的原因，原文是说“We found Cassandra&amp;#39;s eventual consistency model to be a difficult pattern\nto reconcile for our new Messages infrastructure.”。所以对于Facebook而言，就像你所说的，最终一致性模型导致了Facebook放弃它。\n3. Partition tolerance一般在系统中都不会少的，因为要保证出现网络分区后系统能正常运行。对于A的理解可以这么看，主从备份确实是能提高Availability，不过问题要这么看。HBase是要保证strong consistency的，如果不同节点的数据不一致，即便节点还在运行HBase也无法返回结果。\n4. 这个要看你怎么配置了，如果是一个MySql集群，那就是CP了，如果你配置多个同步的MySql集群，那就是AP。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557281959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91757,"user_name":"ykkk88","can_delete":false,"product_type":"c1","uid":1068585,"ip_address":"","ucode":"A1BCFC2F0D1022","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/29/1be3dd40.jpg","comment_is_top":false,"comment_ctime":1557104793,"is_pvip":false,"replies":[{"id":"32913","content":"谢谢你的提问！感觉很多读者都有同样的问题。<br><br>我的理解是如果仅仅就一个Kafka Replication cluster来说，如果领导者挂了我们就不会再从这个cluster拿到内容了，所以在Intra-cluster Replication这个设计点上，他们是不考虑P的。<br><br>之所以我在文中说Kafka Replication选择了CA，是因为Kafka的作者之一Jun Rao在设计Kafka Replication的时候，明确说明了“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。<br><br>所以你会发现，他们的设计思路是仅仅就Intra-cluster的data replication出发的。当然，如果从整个Kafka系统来说，是不可能放弃P的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557191103,"ip_address":"","comment_id":91757,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852072089","product_id":100025301,"comment_content":"kafka replication和放弃p有什么关系么","like_count":1,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449017,"discussion_content":"谢谢你的提问！感觉很多读者都有同样的问题。\n\n我的理解是如果仅仅就一个Kafka Replication cluster来说，如果领导者挂了我们就不会再从这个cluster拿到内容了，所以在Intra-cluster Replication这个设计点上，他们是不考虑P的。\n\n之所以我在文中说Kafka Replication选择了CA，是因为Kafka的作者之一Jun Rao在设计Kafka Replication的时候，明确说明了“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。\n\n所以你会发现，他们的设计思路是仅仅就Intra-cluster的data replication出发的。当然，如果从整个Kafka系统来说，是不可能放弃P的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557191103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322154,"user_name":"James","can_delete":false,"product_type":"c1","uid":1036309,"ip_address":"","ucode":"7A0DC75746CB3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/15/c5dc2b0d.jpg","comment_is_top":false,"comment_ctime":1637208489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637208489","product_id":100025301,"comment_content":"老师你好，想问下可用性与性能的关系是什么？在Redis和MySQL  cache aside模式并发时会存在缓存不一致的，那这里的不一致我可以牺牲性能（比如加分布式锁）来解决，所以这里的性能就是可用性吗？我理解可用性没有要求性能，一个请求过来我可以让他等待一小会（加锁处理并发问题或者进行分布式事务达到强一致），然后处理它，这个最终会返回结果，只是接口处理时间变长了，不能说牺牲了可用性吧？","like_count":0},{"had_liked":false,"id":252249,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1602212509,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602212509","product_id":100025301,"comment_content":"1 网络分区 都是短暂的，后续可以恢复。网络分区不是指节点挂了，网络分区的节点和客户端还是有连接的。 网络分区也不一定指丢包，延迟也会导致误判。<br>2机器零时挂了，考虑机器恢复的情况，这种情况可以看成是网络分区的简单模式。<br>3 单节点没办法区分是网络分区还是机器零时挂了。<br><br>kafka之所说自己不考虑p，基本条件是同一数据中心很少网络分区，当真正出现的时候，他会把分区当成节点永久故障，节点永久故障其实是更简单的情况。<br><br>cap经典 讨论的是单一数据，原子写操作，网络无延迟，非机器挂掉的场景。 而我们讨论cap的时候其实会有不同的假设和理解，这导致cap最容易起争议<br><br>c 是针对单份数据还是多份数据；一致性还有要区分不同的接口，比如etcd本身也提供非一致性读的操作；一致性的级别也有很多，线性，因果，写读，读读，写写；一致性讨论还涉及时钟源的问题，时钟误差是多少范围内。<br><br>a 区分是什么操作，现实系统中还要考虑超时时间，还有qps的变化，还有不可用的时间范围sla<br><br>p 网络分区，是丢包？网络包超时？系统处理超时？ 机器挂掉？a到b通，b到a不通呢？单节点很难区分是什么原因，往往只能把接口超时或者故障当成是分区错误来处理。 分区又涉及感知，处理，和恢复。<br>","like_count":0},{"had_liked":false,"id":252217,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1602201345,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602201345","product_id":100025301,"comment_content":"cap 一直以来误解太多了，c，a，p每一个属性都有不同的灰度。","like_count":0},{"had_liked":false,"id":252191,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1602168608,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602168608","product_id":100025301,"comment_content":"真是每个人理解的cap都不一样啊，看了3个课程，都有不同的理解😂","like_count":0},{"had_liked":false,"id":252189,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1602167884,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602167884","product_id":100025301,"comment_content":"发微博，发本身应该是cp，发完之后的通知可以是ap。 因为发文章失败了用户可以重试，但不能发了成功后，系统后面又认为没发。通知部分不一致影响不大。","like_count":0},{"had_liked":false,"id":248928,"user_name":"Ignacio","can_delete":false,"product_type":"c1","uid":1130334,"ip_address":"","ucode":"AEAA24A58B6D29","user_header":"https://static001.geekbang.org/account/avatar/00/11/3f/5e/2fa1377d.jpg","comment_is_top":false,"comment_ctime":1600362520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600362520","product_id":100025301,"comment_content":"文中提到的CA示例其实是有很强的误导性的。一个分布式系统肯定支持network partition也就是P属性。在出现网络分区后，C和A不可能同时满足，任何分布式系统都要在C和A之间做一个选择。可能的结果只有两个：CP和AP。不支持网络分区，那是单点系统，不存在讨论CAP的意义。","like_count":0},{"had_liked":false,"id":238075,"user_name":"stephen","can_delete":false,"product_type":"c1","uid":1337994,"ip_address":"","ucode":"CDEB34771891A3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dAkTIgz3sFoO20qQMbRiaRqWrpicIWiaLMbkeLkribTOUvrzDZPOaRfZgQOvTtAgib35D7DKFiarejer74F4Qs0771mQ/132","comment_is_top":false,"comment_ctime":1596065529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596065529","product_id":100025301,"comment_content":"kafka是topic分partition 每个partition主从复制，part ition其实就是分区的概念，只不过如果说的是一个partition自己的isr，那确实它没有考虑p特性","like_count":0},{"had_liked":false,"id":194891,"user_name":"不记年","can_delete":false,"product_type":"c1","uid":1045945,"ip_address":"","ucode":"287E40C68356DC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/b9/888fe350.jpg","comment_is_top":false,"comment_ctime":1585116927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585116927","product_id":100025301,"comment_content":"假设我们的系统必须满足P, 也就是容忍网络分区。<br>当分区产生时，如果要满足A，也就是每个分区都要提供服务，因为各分区之间无法通信所以满足不了C。<br>如果要满足C，也就是系统只向用户提供状态完成同步的机器，那么必要要放弃掉其它分区的机器，只保留某一个分区中的机器对外提供服务。<br>假设我们的系统必须满足C<br>当出现网络分区时，如果要想保留P, 也就是说各个分区依然是系统的一部分，因为C的原因，必然存在分区无法提供服务，因此无法保证A<br>如果想保证A，就不能存在P，也就是说要剔除分区，最终只保留一个分区","like_count":0},{"had_liked":false,"id":193805,"user_name":"Eden2020","can_delete":false,"product_type":"c1","uid":1899158,"ip_address":"","ucode":"0DEE62F2335237","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fa/96/4a7b7505.jpg","comment_is_top":false,"comment_ctime":1584968512,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584968512","product_id":100025301,"comment_content":"发微博选择AP即可。CAP只能说是指导思想，生产实践中还是很多细节要考虑的，感觉这一块缺乏一些深度的解读","like_count":0},{"had_liked":false,"id":179120,"user_name":"楊_宵夜","can_delete":false,"product_type":"c1","uid":1019302,"ip_address":"","ucode":"7BA0CADC5F23BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/a6/22c37c91.jpg","comment_is_top":false,"comment_ctime":1581923075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581923075","product_id":100025301,"comment_content":"蔡老师好, 暂时读了三遍文章, 但仍然有些疑问;<br>- 综合来看, 是否能说 P的含义 其实包含了 [ C or A ] 呢?<br>- 换一种问法: P能否看做 [ C or A ] 的超集呢?<br><br>根据文章论述, 如果一个系统没有了P, 一旦网络发生了异常, 那不就没有A了吗? 网络异常了, 又谈什么C呢?<br>因此, 在系统已经有了P的前提下, 才有基础去选择 C或者A 吧?<br><br>根据您的评论, 也是说, Kafka作为一个整体系统, 肯定是保留了P, 那是否可以认为, Kafka作为一个整体, 同时就保留了[CAP]呢?<br>","like_count":0},{"had_liked":false,"id":172126,"user_name":"风","can_delete":false,"product_type":"c1","uid":1032932,"ip_address":"","ucode":"2DEDB586E625C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c2/e4/ad418d90.jpg","comment_is_top":false,"comment_ctime":1579093968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579093968","product_id":100025301,"comment_content":"想请教下老师，elasticsearch属于CAP中的哪两种？一直没思考出来。。。","like_count":0},{"had_liked":false,"id":126607,"user_name":"阿巍-豆夫","can_delete":false,"product_type":"c1","uid":1005123,"ip_address":"","ucode":"732188848B0A85","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/43/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1566435715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566435715","product_id":100025301,"comment_content":"那我的理解就是hdfs满足cap，a 一台namenode 一台datanode挂掉系统可用，c hdfs 三副本，P namnode发生分区，stand by 节点变成active 一旦拉起挂掉namnode数据反向同步。 请问这是不是cap都满足了呢？","like_count":0},{"had_liked":false,"id":108967,"user_name":"滩涂曳尾","can_delete":false,"product_type":"c1","uid":1187478,"ip_address":"","ucode":"40F650F2A419D4","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/96/c735ad6b.jpg","comment_is_top":false,"comment_ctime":1561942811,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561942811","product_id":100025301,"comment_content":"线性一致性——对分布式系统操作B 晚于 操作A，则B看到的分布式系统状态也更晚。<br>所谓“线性”：x轴为操作，y轴为系统状态，两者成线性。","like_count":0},{"had_liked":false,"id":105847,"user_name":"科莫湖畔的球童","can_delete":false,"product_type":"c1","uid":1025780,"ip_address":"","ucode":"E63B6D4F7EA129","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a6/f4/f641a356.jpg","comment_is_top":false,"comment_ctime":1561093059,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561093059","product_id":100025301,"comment_content":"老师和tim cook有点像啊","like_count":0},{"had_liked":false,"id":104425,"user_name":"你好旅行者","can_delete":false,"product_type":"c1","uid":1154101,"ip_address":"","ucode":"5C72A428DC28F3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/35/9dc79371.jpg","comment_is_top":false,"comment_ctime":1560751682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560751682","product_id":100025301,"comment_content":"老师提到的Kafka的那个演讲来自饶军在2013年做的一次报告，报告的地址是<br>https:&#47;&#47;www.youtube.com&#47;watch?v=XcvHmqmh16g出现在21:50左右的地方。报告里提到，因为Kafka是部署在一个DataCenter中的，而一个DataCenter很少会出现Partitioning的情况，所以Kafka放弃了P。可是我想问一个问题，为什么在一个DataCenter就很少出现Partitioning的情况了呢？<br><br>还有，老师在回复里多次提到，大家误会了您的意思，认为整个Kafka系统都是CA的。那么请问老师，整个Kafka系统是怎样的呢？<br><br>最后问老师一个问题哈，因为自己最近也在研究Redis，老师说Redis放弃了高可用性。可是作为一个高可用高性能分布式缓存，Redis的性能是非常出色的，为什么说他不是高可用的呢？","like_count":0},{"had_liked":false,"id":103432,"user_name":"倪必荣","can_delete":false,"product_type":"c1","uid":1046496,"ip_address":"","ucode":"34F707BB9DDDC9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/e0/34290aa4.jpg","comment_is_top":false,"comment_ctime":1560434348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560434348","product_id":100025301,"comment_content":"c:各节点数据一致性<br>a:节点挂掉依然可运行<br>p:通讯连线挂掉依然可运行","like_count":0},{"had_liked":false,"id":101348,"user_name":"xfly","can_delete":false,"product_type":"c1","uid":1193153,"ip_address":"","ucode":"215CF53ECF2298","user_header":"https://static001.geekbang.org/account/avatar/00/12/34/c1/255161c9.jpg","comment_is_top":false,"comment_ctime":1559786341,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1559786341","product_id":100025301,"comment_content":"不知道我的理解正确不正确：<br>1，一份数据在多台机器上有副本，一个副本的leader宕机，这份数据就不能正确返回客户端了，所以不满足分区容错性，而那些各个副本的地位平等的系统是满足分区容错性的。<br>2，稍后kafka通过选举为刚才的副本有了新的leader，数据现在能正常返回了，这体现的是kafka的A属性（高可用），这里分区容错跟可用性是很容易混淆的","like_count":0},{"had_liked":false,"id":94690,"user_name":"Flash","can_delete":false,"product_type":"c1","uid":1236163,"ip_address":"","ucode":"E285075C9E0B02","user_header":"https://static001.geekbang.org/account/avatar/00/12/dc/c3/e4ba51d5.jpg","comment_is_top":false,"comment_ctime":1557882397,"is_pvip":false,"replies":[{"id":"33874","content":"谢谢你的留言！请问你说的是还没理解CAP呢还是不了解微博的机制呢？","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557884528,"ip_address":"","comment_id":94690,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557882397","product_id":100025301,"comment_content":"看完本篇文章，我也不知道微博是用什么CAP中的哪两个属性啊，更别说去思考重新设计怎么做呢？？","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450172,"discussion_content":"谢谢你的留言！请问你说的是还没理解CAP呢还是不了解微博的机制呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557884528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93592,"user_name":"大俊stan","can_delete":false,"product_type":"c1","uid":1125370,"ip_address":"","ucode":"BD0CB5FC790DDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/fa/1cde88d4.jpg","comment_is_top":false,"comment_ctime":1557507583,"is_pvip":false,"replies":[{"id":"33462","content":"谢谢你的留言提问！Zookeeper一般会认为是CP系统，对于你所说的作为注册中心缺少P的情况，我搜索了一下相关资料，好像并没有这样的官方说法。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557560549,"ip_address":"","comment_id":93592,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557507583","product_id":100025301,"comment_content":"老师您好 能否把kaffka的ca类比为zookeeper作为注册中心时也缺少p，还有就是zookeeper在进行大量节点重新选取时是缺少a的","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449691,"discussion_content":"谢谢你的留言提问！Zookeeper一般会认为是CP系统，对于你所说的作为注册中心缺少P的情况，我搜索了一下相关资料，好像并没有这样的官方说法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557560549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93288,"user_name":"蒙开强","can_delete":false,"product_type":"c1","uid":1317706,"ip_address":"","ucode":"61B3183781B9F7","user_header":"https://static001.geekbang.org/account/avatar/00/14/1b/4a/f9df2d06.jpg","comment_is_top":false,"comment_ctime":1557450232,"is_pvip":false,"replies":[{"id":"33272","content":"谢谢你的提问！如果感兴趣的话可以查阅：https:&#47;&#47;engineering.linkedin.com&#47;kafka&#47;intra-cluster-replication-apache-kafka。同时也欢迎你继续留言讨论，因为这个Kafka Replication的例子确实不太好理解。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557453215,"ip_address":"","comment_id":93288,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557450232","product_id":100025301,"comment_content":"老师，你好，我看到在留言区里你回答提问者时，说了kafka选择了ca，这个是在官网的那个地方可以查看这个说明呢","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449564,"discussion_content":"谢谢你的提问！如果感兴趣的话可以查阅：https://engineering.linkedin.com/kafka/intra-cluster-replication-apache-kafka。同时也欢迎你继续留言讨论，因为这个Kafka Replication的例子确实不太好理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557453215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93118,"user_name":"汶恬萝","can_delete":false,"product_type":"c1","uid":1062855,"ip_address":"","ucode":"3A0D84A190FB9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/c7/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1557401340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557401340","product_id":100025301,"comment_content":"kafka的例子感觉有点奇怪<br><br>1.按照文中 a的理论，在分布式系统中，任意非故障的服务器都必须对客户的请求产生响应。如果 master挂了，那 slaver必须对客户请求产生响应才对，但按 replication架构， master挂了会停止服务。<br><br>2.按文中 p理论，当某些系统允许网络丢失从一个节点发送到另一个节点的任意多条消息。如果不支持p，那slaver挂了，replication应该停止服务。但其实是允许master到slaver数据丢失的","like_count":0},{"had_liked":false,"id":93060,"user_name":"hua168","can_delete":false,"product_type":"c1","uid":1065255,"ip_address":"","ucode":"CFF9A7E86EBA48","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/27/3ff1a1d6.jpg","comment_is_top":false,"comment_ctime":1557386717,"is_pvip":false,"replies":[{"id":"33271","content":"谢谢你的提问！<br><br>Availability和Partition Tolerance并不是由是否允许数据丢失来判断的。<br><br>我来举个例子说明吧。假设现在有一个由两个节点组成的集群，这两个节点都可以独立运作也可以与对方通讯，而客户端是与这个集群通讯的。作为一个集群来说，Availability指的是不管这两个节点哪一个节点坏掉不能运作了，对于客户端来说还是可以继续与这个集群进行通讯的。Partition Tolerance指得是，本来这两个节点可能是需要互相通讯来同步数据的，而因为Network Partition使得它们之间不能通讯了，但是对于客户端来说还是可以继续与这个集群进行通讯的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557453096,"ip_address":"","comment_id":93060,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557386717","product_id":100025301,"comment_content":"老师，我想问一下A与P是怎区别的，是不是从是否允许数据丢失上判断？<br>A所有节点间发数据是没有丢失的<br>P节点间数据是允许丢失的，<br>如果这样的话，那么主节点和节点间数据不是产生不一致的情况吗，又怎么保证C，一致性？","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449475,"discussion_content":"谢谢你的提问！\n\nAvailability和Partition Tolerance并不是由是否允许数据丢失来判断的。\n\n我来举个例子说明吧。假设现在有一个由两个节点组成的集群，这两个节点都可以独立运作也可以与对方通讯，而客户端是与这个集群通讯的。作为一个集群来说，Availability指的是不管这两个节点哪一个节点坏掉不能运作了，对于客户端来说还是可以继续与这个集群进行通讯的。Partition Tolerance指得是，本来这两个节点可能是需要互相通讯来同步数据的，而因为Network Partition使得它们之间不能通讯了，但是对于客户端来说还是可以继续与这个集群进行通讯的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557453096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92914,"user_name":"zhihai.tu","can_delete":false,"product_type":"c1","uid":1045888,"ip_address":"","ucode":"61371EA3EF6988","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f5/80/baddf03b.jpg","comment_is_top":false,"comment_ctime":1557364536,"is_pvip":true,"replies":[{"id":"33183","content":"谢谢你的答案！我也赞同！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557387244,"ip_address":"","comment_id":92914,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557364536","product_id":100025301,"comment_content":"AP吧，C只要保持最终一致性就可以了。用户发送微博，写和读之间可以容忍一定的延迟。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449423,"discussion_content":"谢谢你的答案！我也赞同！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557387244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92859,"user_name":"都市夜归人","can_delete":false,"product_type":"c1","uid":1071909,"ip_address":"","ucode":"DFF59BE3D80B42","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/25/d78cc1fe.jpg","comment_is_top":false,"comment_ctime":1557357987,"is_pvip":true,"replies":[{"id":"33185","content":"谢谢你的提问！其实这个要看你怎么理解同步这个词了。我可以举个例子来说明我想表达的意思。如果操作A和B都是数值加一这个操作，在A和B操作之前系统状态是0。操作A成功完成了并且在B之前，那系统状态A就是数值1了，系统状态B不会是0也不会是1必须2。如果你理解的同步是这样的话那就对了。可能我表达得不到位，谢谢指出！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557388350,"ip_address":"","comment_id":92859,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557357987","product_id":100025301,"comment_content":"如果操作 A 是在操作 B 之前发生的，并且操作 A 成功了。那么系统状态 B 必须要比系统状态 A 更加新。<br>请问怎么会更加新？应该是同步吧？谢谢！","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449402,"discussion_content":"谢谢你的提问！其实这个要看你怎么理解同步这个词了。我可以举个例子来说明我想表达的意思。如果操作A和B都是数值加一这个操作，在A和B操作之前系统状态是0。操作A成功完成了并且在B之前，那系统状态A就是数值1了，系统状态B不会是0也不会是1必须2。如果你理解的同步是这样的话那就对了。可能我表达得不到位，谢谢指出！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557388350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92541,"user_name":"zhengfc","can_delete":false,"product_type":"c1","uid":1003097,"ip_address":"","ucode":"9DBB9F6F11D3C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/59/cdd842b2.jpg","comment_is_top":false,"comment_ctime":1557296913,"is_pvip":false,"replies":[{"id":"33141","content":"谢谢你的留言！我很赞同你的想法！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557338400,"ip_address":"","comment_id":92541,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557296913","product_id":100025301,"comment_content":"微博作为社交类的产品一般需要保证可用性，即AP；与金融相关的产品一般要保证CP，例如支付宝","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449311,"discussion_content":"谢谢你的留言！我很赞同你的想法！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557338400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92331,"user_name":"SpanningWings","can_delete":false,"product_type":"c1","uid":1503174,"ip_address":"","ucode":"A5E98A2626F187","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dV2JvjoAOHOibxVqExibsBv0ib9jJ9zD8icYaDtFbicUgP0GmRbzmgujvz6pOl6drUcgdvfQXTJpOOY9OL45WrkInbA/132","comment_is_top":false,"comment_ctime":1557234192,"is_pvip":false,"replies":[{"id":"33037","content":"谢谢你的留言！我十分赞成第一段你对Availability的理解！我个人的理解是在这个Replication的设计理念上，他们不会考虑network partition发生后会怎么处理。但是对于整个Kafka系统来说，像这种Leader election底层infrastructure还是由Zookeeper来实现，肯定还是CP或者AP的。在留言里我看到常超同学也给出了一些reference感觉也是不错的例子。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557262550,"ip_address":"","comment_id":92331,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557234192","product_id":100025301,"comment_content":"对CA系统的分类我还是有问题。在Kafka replication的例子里面，当网络partition发生时，比如原leader不能访问了，节点重新elect leader，这是典型的放弃Consistency来保证Availability的做法哦。这样看来，它是个AP系统。<br><br>看来设计者的意思是正常情况下，宣称不支持P。异常情况下，P真的发生了，后果自负，可以选择A来恢复服务，也可以选择C停止服务。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449218,"discussion_content":"谢谢你的留言！我十分赞成第一段你对Availability的理解！我个人的理解是在这个Replication的设计理念上，他们不会考虑network partition发生后会怎么处理。但是对于整个Kafka系统来说，像这种Leader election底层infrastructure还是由Zookeeper来实现，肯定还是CP或者AP的。在留言里我看到常超同学也给出了一些reference感觉也是不错的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557262550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92310,"user_name":"徐","can_delete":false,"product_type":"c1","uid":1502878,"ip_address":"","ucode":"6BE46455FDD491","user_header":"https://static001.geekbang.org/account/avatar/00/16/ee/9e/204ce89c.jpg","comment_is_top":false,"comment_ctime":1557229174,"is_pvip":false,"replies":[{"id":"33055","content":"谢谢你的经验分享！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557274199,"ip_address":"","comment_id":92310,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557229174","product_id":100025301,"comment_content":"个人理解，DYNAMO，降低W、R  就实现了A ，加大W、R 就实现了C，比较灵活。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449213,"discussion_content":"谢谢你的经验分享！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557274199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92278,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1557219594,"is_pvip":false,"replies":[{"id":"33050","content":"谢谢你的提问！<br><br>看来你是有在使用或者源码剖析过Kafka。是的呢，Kafka底层实现的话就如你所说的，是通过ReplicaFetcherManager管理ReplicaFetcherThread，follower不断地去获取leader中的message offset。不过我觉得在讲述这个例子的时候如果讲述到了底层实现的话，可能不一定容易理解，毕竟这个专栏不是Kafka专栏。我更希望还是在high level上说明白一个概念吧。<br><br>如果你觉得希望后面的章节能够讲述底层实现的话，也欢迎你提出自己的看法建议给我，谢谢！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557271609,"ip_address":"","comment_id":92278,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557219594","product_id":100025301,"comment_content":"文中描述kafka的这句&quot;2. 领导者节点收到请求后先在本地保存好，然后也同时发消息通知 R1和R2&quot;，难道不是follower创建ReplicaFetcherThread去主动pull leader中的消息吗？","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449205,"discussion_content":"谢谢你的提问！\n\n看来你是有在使用或者源码剖析过Kafka。是的呢，Kafka底层实现的话就如你所说的，是通过ReplicaFetcherManager管理ReplicaFetcherThread，follower不断地去获取leader中的message offset。不过我觉得在讲述这个例子的时候如果讲述到了底层实现的话，可能不一定容易理解，毕竟这个专栏不是Kafka专栏。我更希望还是在high level上说明白一个概念吧。\n\n如果你觉得希望后面的章节能够讲述底层实现的话，也欢迎你提出自己的看法建议给我，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557271609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92277,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1557219500,"is_pvip":false,"replies":[{"id":"33052","content":"谢谢你的提问！我个人理解是线性一致性（Linearizability）可以看作是强一致性（Strong Consistency）。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557272387,"ip_address":"","comment_id":92277,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557219500","product_id":100025301,"comment_content":"怎样理解文中所述的“线性一致性”？平常听到的一致性包括有“强一致性”，“弱一致性”和“最终一致性”，那么这里说的“线性一致性”跟它们有区别和联系吗？","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449204,"discussion_content":"谢谢你的提问！我个人理解是线性一致性（Linearizability）可以看作是强一致性（Strong Consistency）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557272387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92070,"user_name":"coyang","can_delete":false,"product_type":"c1","uid":1024805,"ip_address":"","ucode":"563687E0F6A441","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/25/5da16c25.jpg","comment_is_top":false,"comment_ctime":1557185527,"is_pvip":true,"replies":[{"id":"32895","content":"谢谢你的留言！GlusterFS我也是第一次听说，学习了，谢谢！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557188583,"ip_address":"","comment_id":92070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557185527","product_id":100025301,"comment_content":"发微博选择ap，c不是特别重要，只要最后能够达到一致就可以了。分布式文件系统GlusterFS感觉和kafka很相似，也是放弃了p。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449136,"discussion_content":"谢谢你的留言！GlusterFS我也是第一次听说，学习了，谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557188583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91982,"user_name":"Ming","can_delete":false,"product_type":"c1","uid":1516011,"ip_address":"","ucode":"69BB73B8AB7E3F","user_header":"https://static001.geekbang.org/account/avatar/00/17/21/eb/bb2e7a3b.jpg","comment_is_top":false,"comment_ctime":1557148821,"is_pvip":false,"replies":[{"id":"32890","content":"谢谢你的留言与观点！<br><br>CAP理论其实并不粗糙，都有明确的定义。不过如你所说，不同的系统对于consistency会有不同的定义，可能已经偏离了当初论文中所阐明的consistency观点。<br><br>当然了，大部分的理论我们都是可以在wiki上面找得到的。不单单是我的专栏，像其它专栏中，如操作系统方面的概念、数据库的概念又或者是计组上的概念都能够在wiki上找到，但是我们为什么又要拿出来给读者讲解呢？我在设计专栏的时候并不假设读者的背景，无论你是毫无经验的学生又或者是拥有很多大数据处理经验的工程师，我都希望能照顾到大部分的读者让大家都有一定的收获。我也相信你是一个非常有经验的高级工程师，学习阅读能力比其他人会更快一些，所以阅读某些篇章的时候可能会觉得偏简单一些。<br><br>对于顾客交互的问题，可能我留言的延时有长有短，让你觉得讲师也就不和顾客交互的错觉。但是我一直都希望能保证阅读每一位顾客的留言并且也写下自己的想法。在此也感谢你的建议。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557187692,"ip_address":"","comment_id":91982,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557148821","product_id":100025301,"comment_content":"CAP的理论是20年前的产物，很粗糙，不同的vendor对其的理解都不一样。因此我以为讨论这个的意义不大（留个wiki链接完全足够），作为工程师往往关注的是“什么情况下会挂，什么情况下会数据不一致”。<br><br>我感觉，这个专栏除了从开篇的若干章，之后的内容质量下滑，讲师也少有对顾客的交互。我真希望平台能提供按阶段收费，而不是一锤子买卖。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449101,"discussion_content":"谢谢你的留言与观点！\n\nCAP理论其实并不粗糙，都有明确的定义。不过如你所说，不同的系统对于consistency会有不同的定义，可能已经偏离了当初论文中所阐明的consistency观点。\n\n当然了，大部分的理论我们都是可以在wiki上面找得到的。不单单是我的专栏，像其它专栏中，如操作系统方面的概念、数据库的概念又或者是计组上的概念都能够在wiki上找到，但是我们为什么又要拿出来给读者讲解呢？我在设计专栏的时候并不假设读者的背景，无论你是毫无经验的学生又或者是拥有很多大数据处理经验的工程师，我都希望能照顾到大部分的读者让大家都有一定的收获。我也相信你是一个非常有经验的高级工程师，学习阅读能力比其他人会更快一些，所以阅读某些篇章的时候可能会觉得偏简单一些。\n\n对于顾客交互的问题，可能我留言的延时有长有短，让你觉得讲师也就不和顾客交互的错觉。但是我一直都希望能保证阅读每一位顾客的留言并且也写下自己的想法。在此也感谢你的建议。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557187692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91954,"user_name":"miwucc","can_delete":false,"product_type":"c1","uid":1326429,"ip_address":"","ucode":"7935BD907119AE","user_header":"https://static001.geekbang.org/account/avatar/00/14/3d/5d/ac666969.jpg","comment_is_top":false,"comment_ctime":1557143941,"is_pvip":false,"replies":[{"id":"32879","content":"谢谢你的留言，有质疑是一件好的事情！<br><br>首先我不确定你是觉得例子中的哪一块内容你觉得不同意，如果你的疑问是Kafka这个系统是否放弃了P，我的回答是并没有放弃P。作为一个整体系统来说，在分布式的环境下，系统的设计是不会放弃P的，也就是大多数系统在CAP里面都会选择AP或者CP。 <br><br>而如果你的疑问是Kafka Replication Design的思想里有没有放弃P，这一点我觉得我是认同Kafka作者Jun Rao的观点的，所以我也特地在标题中写上“放弃了P属性的Kafka Replication”，而不是“放弃了P属性的Kafka系统”以免引起误会。<br><br>Kafka的作者之一Jun Rao在设计Kafka Replication的时候，明确说明了“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的Engineering官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。 <br><br>如果还有疑问的地方，也欢迎你继续留言提问，一起学习进步！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557185801,"ip_address":"","comment_id":91954,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557143941","product_id":100025301,"comment_content":"kafka的例子觉得不同意。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449097,"discussion_content":"谢谢你的留言，有质疑是一件好的事情！\n\n首先我不确定你是觉得例子中的哪一块内容你觉得不同意，如果你的疑问是Kafka这个系统是否放弃了P，我的回答是并没有放弃P。作为一个整体系统来说，在分布式的环境下，系统的设计是不会放弃P的，也就是大多数系统在CAP里面都会选择AP或者CP。 \n\n而如果你的疑问是Kafka Replication Design的思想里有没有放弃P，这一点我觉得我是认同Kafka作者Jun Rao的观点的，所以我也特地在标题中写上“放弃了P属性的Kafka Replication”，而不是“放弃了P属性的Kafka系统”以免引起误会。\n\nKafka的作者之一Jun Rao在设计Kafka Replication的时候，明确说明了“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的Engineering官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。 \n\n如果还有疑问的地方，也欢迎你继续留言提问，一起学习进步！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557185801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91939,"user_name":"孙稚昊","can_delete":false,"product_type":"c1","uid":1010660,"ip_address":"","ucode":"44283BA4A577B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/e4/afacba1c.jpg","comment_is_top":false,"comment_ctime":1557140621,"is_pvip":false,"replies":[{"id":"32900","content":"谢谢你的留言！哈哈，HBase在设计上选择了Consistency和Partition Tolerance。反而是Cassandra是AP system。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557189311,"ip_address":"","comment_id":91939,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557140621","product_id":100025301,"comment_content":"hbase 的所有记录都是append only 的，印象中是AP，反而是consistency 有点妥协？","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449088,"discussion_content":"谢谢你的留言！哈哈，HBase在设计上选择了Consistency和Partition Tolerance。反而是Cassandra是AP system。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557189311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91830,"user_name":"笑地","can_delete":false,"product_type":"c1","uid":1103478,"ip_address":"","ucode":"2CD6F5BCAAC2C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/76/be6fc02e.jpg","comment_is_top":false,"comment_ctime":1557116774,"is_pvip":false,"replies":[{"id":"33039","content":"数据和架构不是割裂的两个事情，相反我们这里讲的是数据处理系统的架构设计。不论是前端工程师要考虑前端架构，存储系统要考虑存储系统架构。脱离了技术系统，架构无从谈起，脱离了架构设计我也不认为纯粹的数据有什么意义。","user_name":"作者回复","user_name_real":"Yuannan蔡元楠","uid":"1257426","ctime":1557266790,"ip_address":"","comment_id":91830,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557116774","product_id":100025301,"comment_content":"感觉这几讲都很大数据关系没那么大，更多是讲架构方面的，内容能否向大数据倾斜一点","like_count":0,"discussions":[{"author":{"id":1257426,"avatar":"https://static001.geekbang.org/account/avatar/00/13/2f/d2/0b6a8945.jpg","nickname":"Yuannan蔡元楠","note":"","ucode":"695E183CE496A8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449049,"discussion_content":"数据和架构不是割裂的两个事情，相反我们这里讲的是数据处理系统的架构设计。不论是前端工程师要考虑前端架构，存储系统要考虑存储系统架构。脱离了技术系统，架构无从谈起，脱离了架构设计我也不认为纯粹的数据有什么意义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557266790,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91828,"user_name":"孙稚昊","can_delete":false,"product_type":"c1","uid":1010660,"ip_address":"","ucode":"44283BA4A577B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/e4/afacba1c.jpg","comment_is_top":false,"comment_ctime":1557116214,"is_pvip":false,"replies":[{"id":"32902","content":"谢谢你的留言，理解正确的！好一个不挂才是王道！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557189390,"ip_address":"","comment_id":91828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557116214","product_id":100025301,"comment_content":"微博这种append only 的系统，对一致性其实没多大需求，用户闲着没事也会不停刷的，不挂才是王道","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449047,"discussion_content":"谢谢你的留言，理解正确的！好一个不挂才是王道！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557189390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91826,"user_name":"孙稚昊","can_delete":false,"product_type":"c1","uid":1010660,"ip_address":"","ucode":"44283BA4A577B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/e4/afacba1c.jpg","comment_is_top":false,"comment_ctime":1557116092,"is_pvip":false,"replies":[{"id":"32903","content":"谢谢你的留言，理解正确的！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557189413,"ip_address":"","comment_id":91826,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557116092","product_id":100025301,"comment_content":"AP，微博对consistency 要求不高，访问量又特别大，尤其是明星的消息，造成瞬间爆发流量，availability 比较重要","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449046,"discussion_content":"谢谢你的留言，理解正确的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557189413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91800,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1557111045,"is_pvip":false,"replies":[{"id":"32897","content":"谢谢你的留言，理解正确的！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557188695,"ip_address":"","comment_id":91800,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557111045","product_id":100025301,"comment_content":"微博只能选AP：<br>可用性必须保证<br>数据量庞大，必须分区<br>一致性就只能放后面，最终一致就行了，晚一点看到回复也没啥大的影响","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449033,"discussion_content":"谢谢你的留言，理解正确的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557188695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91769,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":false,"comment_ctime":1557105622,"is_pvip":false,"replies":[{"id":"32899","content":"谢谢你的留言，理解正确的！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557188959,"ip_address":"","comment_id":91769,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557105622","product_id":100025301,"comment_content":"AP。<br>A是要满足可用性，一定要有信息返回<br>P分区容错一般来讲不可避免<br>C对于不同的用户去刷新你发的微博，只要保证最终一致性就可以了","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449022,"discussion_content":"谢谢你的留言，理解正确的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557188959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91759,"user_name":"孤鹜齐飞","can_delete":false,"product_type":"c1","uid":1149144,"ip_address":"","ucode":"33CF3142DAD56C","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/d8/fdd2cecd.jpg","comment_is_top":false,"comment_ctime":1557104845,"is_pvip":false,"replies":[{"id":"32896","content":"谢谢你的留言，理解正确的！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557188679,"ip_address":"","comment_id":91759,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557104845","product_id":100025301,"comment_content":"微博的场景对C的要求并不是十分紧迫，而AP才是关键","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449019,"discussion_content":"谢谢你的留言，理解正确的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557188679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91752,"user_name":"不贰过先生","can_delete":false,"product_type":"c1","uid":1496958,"ip_address":"","ucode":"B208B8DF5FA109","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/7e/6b6384e9.jpg","comment_is_top":false,"comment_ctime":1557104205,"is_pvip":false,"replies":[{"id":"32914","content":"谢谢你的答案，我也十分赞同！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557191120,"ip_address":"","comment_id":91752,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557104205","product_id":100025301,"comment_content":"发微博，不需要一致性，即C属性，但是其需要最终一致性。需要AP属性，即他需要高可用性和分区容错性。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449016,"discussion_content":"谢谢你的答案，我也十分赞同！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557191120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91748,"user_name":"邱从贤※klion26","can_delete":false,"product_type":"c1","uid":1027239,"ip_address":"","ucode":"36DF21F2B9E94C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/a7/4d41966a.jpg","comment_is_top":false,"comment_ctime":1557103954,"is_pvip":false,"replies":[{"id":"32915","content":"谢谢你的答案，我也十分赞同！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557191134,"ip_address":"","comment_id":91748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557103954","product_id":100025301,"comment_content":"ap<br>p 是肯定需要的，需要保证可靠性，随时都可以访问<br>a 和 c 来说，微博不像记账系统，不需要强一致性，就算每个人看到的都是不一样的状态也是允许的，后期视情况来进行修补就好了，因此选择 a 放弃 c","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449013,"discussion_content":"谢谢你的答案，我也十分赞同！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557191134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91743,"user_name":"林夕","can_delete":false,"product_type":"c1","uid":1494249,"ip_address":"","ucode":"89ADA39FC10BBD","user_header":"https://static001.geekbang.org/account/avatar/00/16/cc/e9/19497393.jpg","comment_is_top":false,"comment_ctime":1557103680,"is_pvip":false,"replies":[{"id":"32910","content":"谢谢你的留言提问！<br><br>我的理解是如果仅仅就一个Kafka Replication cluster来说，如果领导者挂了我们就不会再从这个cluster拿到内容了，所以在Intra-cluster Replication这个设计点上，他们是不考虑P的。<br><br>之所以我在文中说Kafka Replication选择了CA，是因为Kafka的作者之一Jun Rao在设计Kafka Replication的时候，明确说明了“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。<br><br>所以你会发现，他们的设计思路是仅仅就Intra-cluster的data replication出发的。当然，如果从整个Kafka系统来说，是不可能放弃P的。","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557190958,"ip_address":"","comment_id":91743,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557103680","product_id":100025301,"comment_content":"你好，kafka是CA的那段不太理解，既然两台follower都挂了，kafka集群还能返回结果，不是满足了分区容错吗","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449012,"discussion_content":"谢谢你的留言提问！\n\n我的理解是如果仅仅就一个Kafka Replication cluster来说，如果领导者挂了我们就不会再从这个cluster拿到内容了，所以在Intra-cluster Replication这个设计点上，他们是不考虑P的。\n\n之所以我在文中说Kafka Replication选择了CA，是因为Kafka的作者之一Jun Rao在设计Kafka Replication的时候，明确说明了“All distributed systems must make trade-offs between guaranteeing consistency, availability, and partition tolerance. Our goal was to support replication in a Kafka cluster within a single datacenter, where network partitioning is rare, so our design focuses on maintaining highly available and strongly consistent replicas.”，这一点是在Linkedin的官方文档上publish的。而在2013年的Apachecon上，Kafka Replication的技术演讲上也明确说明了“Kafka Replication: Pick CA”。\n\n所以你会发现，他们的设计思路是仅仅就Intra-cluster的data replication出发的。当然，如果从整个Kafka系统来说，是不可能放弃P的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557190958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91736,"user_name":"JohnT3e","can_delete":false,"product_type":"c1","uid":1063982,"ip_address":"","ucode":"CF4AAAC933529C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLdWHFCr66TzHS2CpCkiaRaDIk3tU5sKPry16Q7ic0mZZdy8LOCYc38wOmyv5RZico7icBVeaPX8X2jcw/132","comment_is_top":false,"comment_ctime":1557103314,"is_pvip":false,"replies":[{"id":"32909","content":"谢谢你的留言，我十分赞同你的答案！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557190675,"ip_address":"","comment_id":91736,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557103314","product_id":100025301,"comment_content":"发微博只需要最终一致性保证就可以了，因此选择AP。","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449010,"discussion_content":"谢谢你的留言，我十分赞同你的答案！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557190675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91731,"user_name":"Allie","can_delete":false,"product_type":"c1","uid":1059891,"ip_address":"","ucode":"80497FE06D8E1F","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/33/f3755a9b.jpg","comment_is_top":false,"comment_ctime":1557102234,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557102234","product_id":100025301,"comment_content":"AP，微博需要保证发送和查看信息，而所有数据的及时性是不需要严格保证的","like_count":0},{"had_liked":false,"id":91730,"user_name":"Allie","can_delete":false,"product_type":"c1","uid":1059891,"ip_address":"","ucode":"80497FE06D8E1F","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/33/f3755a9b.jpg","comment_is_top":false,"comment_ctime":1557102062,"is_pvip":false,"replies":[{"id":"32912","content":"谢谢你的答案，我也十分赞同！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557191052,"ip_address":"","comment_id":91730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557102062","product_id":100025301,"comment_content":"ap，一致性不需要严格保证，而另外两个是必须有的，不然影响功能使用","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449006,"discussion_content":"谢谢你的答案，我也十分赞同！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557191052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91714,"user_name":"大漠胡杨","can_delete":false,"product_type":"c1","uid":1070357,"ip_address":"","ucode":"A655BF98DE8158","user_header":"https://static001.geekbang.org/account/avatar/00/10/55/15/3c75f9f6.jpg","comment_is_top":false,"comment_ctime":1557099433,"is_pvip":true,"replies":[{"id":"32926","content":"谢谢你的答案，我也十分赞同！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557194439,"ip_address":"","comment_id":91714,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557099433","product_id":100025301,"comment_content":"选择AP","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449001,"discussion_content":"谢谢你的答案，我也十分赞同！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557194439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91695,"user_name":"icejoywoo","can_delete":false,"product_type":"c1","uid":1019222,"ip_address":"","ucode":"E68C8B54D07EC3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/56/2a04dd88.jpg","comment_is_top":false,"comment_ctime":1557075039,"is_pvip":false,"replies":[{"id":"32927","content":"谢谢你的答案，我也十分赞同！","user_name":"作者回复","user_name_real":"Geek_88e0d7","uid":"1503187","ctime":1557194454,"ip_address":"","comment_id":91695,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557075039","product_id":100025301,"comment_content":"AP，发微博以后follower不需要第一时间看到","like_count":0,"discussions":[{"author":{"id":1503187,"avatar":"","nickname":"Geek_88e0d7","note":"","ucode":"3E2596F3EB9165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448995,"discussion_content":"谢谢你的答案，我也十分赞同！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557194454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]}]}