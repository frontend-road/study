{"id":445827,"title":"27｜缓存服务：如何基于Redis实现封装？","content":"<p>你好，我是轩脉刃。</p><p>上面两节课把数据库操作接入到hade框架中了，现在我们能使用容器中的ORM服务来操作数据库了。在实际工作中，一旦数据库出现性能瓶颈，除了优化数据库本身之外，另外一个常用的方法是使用缓存来优化业务请求。所以这节课，我们来讨论一下，hade框架如何提供缓存支持。</p><p>现在的Web业务，大部分都是使用Redis来做缓存实现。但是，缓存的实现方式远不止Redis一种，比如在Redis出现之前，Memcached一般是缓存首选；在单机上，还可以使用文件来存储数据，又或者直接使用进程的内存也可以进行缓存实现。</p><p>缓存服务的底层使用哪个存储方式，和具体的业务架构原型相关。我个人在不同业务场景中用过不少的缓存存储方案，不过业界用的最多的Redis，还是优点比较突出。相比文件存储，它能集中分布式管理；而相比Memcached，优势在于多维度的存储数据结构。所以，顺应潮流，我们hade框架主要也针对使用Redis来实现缓存服务。</p><p>我们这节课会创建两个服务，一个是Redis服务，提供对Redis的封装，另外一个是缓存服务，提供一系列对“缓存”的统一操作。而这些统一操作，具体底层是由Redis还是内存进行驱动的，这个可以根据配置决定。</p><!-- [[[read_end]]] --><p>下面我们一个个来讨论吧。</p><h2>Redis服务</h2><p>首先封装一个可以对Redis进行操作的服务。和封装ORM一样，我们自己并不实现Redis的底层传输协议和操作封装，只将Redis“创建连接”的过程封装在hade中就行了。</p><p>这里我们就选择<a href=\"https://github.com/go-redis/redis\">go-redis</a>这个库来实现对Redis的连接。这个库目前也是Golang开源社区最常用的Redis库，有12.8k的star数，使用的是BSD 协议，可以引用，可以修改，但是修改的同时要保留版权声明，这里我们并不需要修改，所以BSD已经足够了。这个库目前是v8版本，可以使用 <code>go get github.com/go-redis/redis/v8</code> 来引入它。</p><p>go-redis的连接非常简单，我们看官网的例子，就看创建连接部分：</p><pre><code class=\"language-go\">import (\n&nbsp; &nbsp; \"context\"\n&nbsp; &nbsp; \"github.com/go-redis/redis/v8\"\n)\n\nvar ctx = context.Background()\n\nfunc ExampleClient() {\n    // 创建连接\n&nbsp; &nbsp; rdb := redis.NewClient(&amp;redis.Options{\n&nbsp; &nbsp; &nbsp; &nbsp; Addr:&nbsp; &nbsp; &nbsp;\"localhost:6379\",\n&nbsp; &nbsp; &nbsp; &nbsp; Password: \"\", // no password set\n&nbsp; &nbsp; &nbsp; &nbsp; DB:&nbsp; &nbsp; &nbsp; &nbsp;0,&nbsp; // use default DB\n&nbsp; &nbsp; })\n\n&nbsp; &nbsp; ...\n}\n</code></pre><p><strong>核心的redis.NewClient方法，返回的是一个*redis.Client结构，它就相当于Gorm中的DB数据结构，就是我们要实例化Redis的实例</strong>。这个结构是一个封装了300+个Redis操作的数据结构，你可以使用 <code>go doc github.com/go-redis/redis/v8.Client</code> 来观察它封装的Redis操作。</p><h3>配置</h3><p>redis.NewClient方法还有一个参数：*redis.Options 数据结构。这个数据结构就相当于Gorm中的gorm.Config，里面封装了实例化redis.Client的各种配置信息，来看一些重要的配置，都做了注释：</p><pre><code class=\"language-go\">// redis的连接配置\ntype Options struct {\n   // 网络情况\n   // Default is tcp.\n   Network string\n   // host:port 格式的地址\n   Addr string\n   \n   // redis的用户名\n   Username string\n   // redis密码\n   Password string\n   // redis的database\n   DB int\n   \n   // 连接超时\n   // Default is 5 seconds.\n   DialTimeout time.Duration\n   // 读超时\n   // Default is 3 seconds.\n   ReadTimeout time.Duration\n   // 写超时\n   // Default is ReadTimeout.\n   WriteTimeout time.Duration\n   \n   // 最小空闲连接数\n   MinIdleConns int\n   // 最大连接时长\n   MaxConnAge time.Duration\n   \n   // 空闲连接时长\n   // Default is 5 minutes. -1 disables idle timeout check.\n   IdleTimeout time.Duration\n   ...\n}\n</code></pre><p>这些配置项相信你也非常熟悉了，既有连接请求的配置项，也有连接池的配置项。</p><p>和Gorm的配置封装一样，我们想要给用户提供一个配置即用的缓存服务，需要做如下三个事情：</p><ul>\n<li>自定义一个数据结构，封装redis.Options结构</li>\n<li>让刚才自定义的结构能生成一个唯一标识（类似Gorm的DSN）</li>\n<li>支持通过配置文件加载这个结构，同时，支持通过Option可变参数来修改它</li>\n</ul><p>在framework/contract/redis.go中，我们首先定义<strong>RedisConfig数据结构</strong>，这个结构单纯封装redis.Options就行了，没有其他额外的参数需要设置：</p><pre><code class=\"language-go\">// RedisConfig 为hade定义的Redis配置结构\ntype RedisConfig struct {\n   *redis.Options\n</code></pre><p>同时为这个RedisConfig定义一个唯一标识，来标识一个redis.Client。这里我们选用了Addr、DB、UserName、Network 四个字段值来标识。<strong>基本上这四个字段加起来能标识“用什么账号登录哪个Redis地址的哪个database”了</strong>：</p><pre><code class=\"language-go\">// UniqKey 用来唯一标识一个RedisConfig配置\nfunc (config *RedisConfig) UniqKey() string {\n   return fmt.Sprintf(\"%v_%v_%v_%v\", config.Addr, config.DB, config.Username, config.Network)\n}\n</code></pre><p>RedisConfig结构定义完成，下面想要把它加载并支持可修改，我们要结合实例化redis.Client对象来说。</p><h3>初始化连接</h3><p>如何封装Redis的连接实例，这个同Gorm的封装一样，使用Option可变参数的方式。还是在 framework/contract/redis.go中继续写入：</p><pre><code class=\"language-go\">package contract\n\n...\n\nconst RedisKey = \"hade:redis\"\n\n// RedisOption 代表初始化的时候的选项\ntype RedisOption func(container framework.Container, config *RedisConfig) error\n\n// RedisService 表示一个redis服务\ntype RedisService interface {\n   // GetClient 获取redis连接实例\n   GetClient(option ...RedisOption) (*redis.Client, error)\n}\n</code></pre><p>定义了一个RedisService，表示Redis服务对外提供的协议，它只有一个GetClient方法，通过这个方法能获取到Redis的一个连接实例redis.Client。</p><p>你能看到GetClient方法有一个可变参数RedisOption，这个可变参数是一个函数结构，参数中带有传递进入了的RedisConfig指针，所以<strong>这个RedisOption是有修改RedisConfig结构的能力的</strong>。</p><p>那具体提供哪些RedisOption函数呢？和ORM一样，我们要提供多层次的修改方案，包括默认配置、按照配置项进行配置，以及手动配置：</p><ul>\n<li>GetBaseConfig获取redis.yaml根目录下的Redis配置，作为默认配置</li>\n<li>GetConfigPath 根据指定配置路径获取Redis配置</li>\n<li>WithRedisConfig 可以直接修改RedisConfig中的redis.Options配置信息</li>\n</ul><p>在实现这三个函数之前，有必要先看一下我们的Redis配置文件cofig/testing/redis.yaml：</p><pre><code class=\"language-yaml\">timeout: 10s # 连接超时\nread_timeout: 2s # 读超时\nwrite_timeout: 2s # 写超时\n\nwrite:\n    host: localhost # ip地址\n    port: 3306 # 端口\n    db: 0 #db\n    username: jianfengye # 用户名\n    password: \"123456789\" # 密码\n    timeout: 10s # 连接超时\n    read_timeout: 2s # 读超时\n    write_timeout: 2s # 写超时\n    conn_min_idle: 10 # 连接池最小空闲连接数\n    conn_max_open: 20 # 连接池最大连接数\n    conn_max_lifetime: 1h # 连接数最大生命周期\n    conn_max_idletime: 1h # 连接数空闲时长\n</code></pre><p>和database.yaml的配置一样，根级别的作为默认配置，二级配置作为单个Redis的配置，并且二级配置会覆盖默认配置。这里还有一个小心思，特意将这些配置项都和database.yaml保持一致了，这样使用者在配置的时候能减少学习成本。</p><p>这三个方法的具体实现和Gorm没有什么太大的区别。基本方法就是使用容器中的配置服务、读取配置信息，然后修改参数中的RedisConfig指针，你可以参考分支中的代码文件<a href=\"https://github.com/gohade/coredemo/blob/geekbang/27/framework/provider/redis/config.go\">framework/provider/redis/config.go</a>。</p><p>我们重点把注意力放在<strong>GetClient方法的实现</strong>上，写在framework/provider/redis/service.go中。类似gorm的GetDB方法，它是一个单例模式，就是一个RedisConfig，只产生一个redis.Client，用一个map加上一个lock来初始化Redis实例：</p><pre><code class=\"language-go\">// HadeRedis 代表hade框架的redis实现\ntype HadeRedis struct {\n    container framework.Container      // 服务容器\n    clients   map[string]*redis.Client // key为uniqKey, value为redis.Client (连接池）\n\n    lock *sync.RWMutex\n}\n</code></pre><p>在GetClient函数中，首先还是获取基本Redis配置 redisConfig，使用参数opts对redisConfig进行修改，最后判断当前redisConfig是否已经实例化了：</p><ul>\n<li>如果已经实例化，返回实例化redis.Client；</li>\n<li>如果未实例化，实例化redis.Client，返回实例化的redis.Client。</li>\n</ul><pre><code class=\"language-go\">// GetClient 获取Client实例\nfunc (app *HadeRedis) GetClient(option ...contract.RedisOption) (*redis.Client, error) {\n    // 读取默认配置\n    config := GetBaseConfig(app.container)\n\n    // option对opt进行修改\n    for _, opt := range option {\n        if err := opt(app.container, config); err != nil {\n            return nil, err\n        }\n    }\n\n    // 如果最终的config没有设置dsn,就生成dsn\n    key := config.UniqKey()\n\n    // 判断是否已经实例化了redis.Client\n    app.lock.RLock()\n    if db, ok := app.clients[key]; ok {\n        app.lock.RUnlock()\n        return db, nil\n    }\n    app.lock.RUnlock()\n\n    // 没有实例化gorm.DB，那么就要进行实例化操作\n    app.lock.Lock()\n    defer app.lock.Unlock()\n\n    // 实例化gorm.DB\n    client := redis.NewClient(config.Options)\n\n    // 挂载到map中，结束配置\n    app.clients[key] = client\n\n    return client, nil\n}\n</code></pre><p>这里只讲了Redis服务的接口和服务实现的关键函数，其中provider的实现基本上和ORM的一致，没有什么特别，就不在这里重复列出代码了。</p><p>到这里我们就将Redis的服务融合进入hade框架了。但Redis只是缓存服务的一种实现，我们这节课最终目标是想实现一个缓存服务。</p><h2>缓存服务</h2><p>缓存服务的使用方式其实非常多，我们可以设置有超时/无超时的缓存，也可以使用计数器缓存，一份好的缓存接口的设计，能对应用的缓存使用帮助很大。</p><p>所以这一部分，相比缓存服务的具体实现，<strong>缓存服务的协议设计直接影响了这个服务的可用性</strong>，我们要重点理解对缓存协议的设计。</p><h3>协议</h3><p>实现一个服务的三步骤，服务协议、服务提供者、服务实例。就先从协议开始，我们希望这个缓存服务提供哪些能力呢？</p><p>首先，缓存协议一定是有两个方法，一个设置缓存、一个获取缓存。设定为Get方法为获取缓存，Set方法为设置缓存。</p><pre><code class=\"language-go\">// Get 获取某个key对应的值\nGet(ctx context.Context, key string) (string, error)\n// Set 设置某个key和值到缓存，带超时时间\nSet(ctx context.Context, key string, val string, timeout time.Duration) error\n</code></pre><p>同时，注意设置缓存的时候，又区分出两种需求，我们需要设置带超时时间的缓存，也需要设置不带超时时间的、永久的缓存。所以，Set方法衍生出Set和SetForever两种。</p><pre><code class=\"language-go\">// SetForever 设置某个key和值到缓存，不带超时时间\nSetForever(ctx context.Context, key string, val string) error\n</code></pre><p>在设置了某个key之后，会不会需要修改这个缓存key的缓存时长呢？完全是有可能的，比如将某个key的缓存时长加大，或者想要获取某个key的缓存时长，所以我们再把注意力放在缓存时长的操作上，提供对缓存时长的操作函数SetTTL和GetTTL：</p><pre><code class=\"language-go\">// SetTTL 设置某个key的超时时间\nSetTTL(ctx context.Context, key string, timeout time.Duration) error\n// GetTTL 获取某个key的超时时间\nGetTTL(ctx context.Context, key string) (time.Duration, error)\n</code></pre><p>再来，Get和Set目前对应的value值为string，但是我们希望value值能不仅仅是一个字符串，它还可以直接是一个对象，这样缓存服务就能存储和获取一个对象出来，能大大方便缓存需求。</p><p>所以我们定义两个GetObj和SetObj方法，来实现对象的缓存存储和获取，但是这个对象在实际存储的时候，又势必要进行序列化和反序列的过程，所以我们对存储和获取的对象再增加一个要求，让它实现官方库的BinaryMarshaler和BinaryUnMarshaler接口：</p><pre><code class=\"language-go\">// GetObj 获取某个key对应的对象, 对象必须实现 https://pkg.go.dev/encoding#BinaryUnMarshaler\nGetObj(ctx context.Context, key string, model interface{}) error\n// SetObj 设置某个key和对象到缓存, 对象必须实现 https://pkg.go.dev/encoding#BinaryMarshaler\nSetObj(ctx context.Context, key string, val interface{}, timeout time.Duration) error\n// SetForeverObj 设置某个key和对象到缓存，不带超时时间，对象必须实现 https://pkg.go.dev/encoding#BinaryMarshaler\nSetForeverObj(ctx context.Context, key string, val interface{}) error\n</code></pre><p>现在，我们已经可以一个key进行缓存获取和设置了，但是有时候要同时对多个key做缓存的获取和设置，来设置对多个key进行操作的方法GetMany和SetMany：</p><pre><code class=\"language-go\">// GetMany 获取某些key对应的值\nGetMany(ctx context.Context, keys []string) (map[string]string, error)\n// SetMany 设置多个key和值到缓存\nSetMany(ctx context.Context, data map[string]string, timeout time.Duration) error\n</code></pre><p>在实际业务中，我们还会有一些计数器的需求，需要将计数器存储到缓存，同时也要能对这个计数器缓存进行增加和减少的操作。可以为计数器缓存设计Calc、Increment、Decrement的接口：</p><pre><code class=\"language-go\">// Calc 往key对应的值中增加step计数\nCalc(ctx context.Context, key string, step int64) (int64, error)\n// Increment 往key对应的值中增加1\nIncrement(ctx context.Context, key string) (int64, error)\n// Decrement 往key对应的值中减去1\nDecrement(ctx context.Context, key string) (int64, error)\n</code></pre><p>缓存的使用有一种Cache-Aside模式，可以提升“获取数据”的性能。可能你没有听过这个名字，但其实我们都用过，这个模式描述的就是在实际操作之前，先去缓存中查看有没有对应的数据，如果有的话，不进行操作，如果没有的话才进行实际操作生成数据，并且把数据存储在缓存中。</p><p>我们希望缓存服务也能支持这种Cache-Aside模式。如何支持呢？</p><p>首先，要有一个生成数据的通用方法结构，我们定义为RememberFunc，让这个函数将服务容器传递进去，这样在具体的实现中，使用者就可以从服务容器中获取各种各样的具体注册服务了，能大大增强这个RemeberFunc的实现能力：</p><pre><code class=\"language-go\">// RememberFunc 缓存的Remember方法使用，Cache-Aside模式对应的对象生成方法\ntype RememberFunc func(ctx context.Context, container framework.Container) (interface{}, error)\n</code></pre><p>然后，我们为缓存服务定义一个Remember方法，来实现这个Cache-Aside模式。</p><pre><code class=\"language-go\">// Remember 实现缓存的Cache-Aside模式, 先去缓存中根据key获取对象，如果有的话，返回，如果没有，调用RememberFunc 生成\nRemember(ctx context.Context, key string, timeout time.Duration, rememberFunc RememberFunc, model interface{}) error\n</code></pre><p>它的参数来仔细看下。除了context之外，有一个key，代表这个缓存使用的key，其次是timeout 代表缓存时长，接着是前面定义的 RememberFunc了，代表如果缓存中没有这个key，就调用RememberFunc函数来生成数据对象。</p><p>这个数据对象从哪里输出呢？就是这里的最后一个参数model了，当然这个Obj必须实现BinaryMarshaler和BinaryUnmarshaler接口。这样定义之后，Remember的具体实现就简单了。</p><p>看这个我在单元测试代码provider/cache/services/redis_test.go中写的测试：</p><pre><code class=\"language-go\">type Bar struct {\n   Name string\n}\nfunc (b *Bar) MarshalBinary() ([]byte, error) {\n   return json.Marshal(b)\n}\nfunc (b *Bar) UnmarshalBinary(bt []byte) error {\n   return json.Unmarshal(bt, b)\n}\n\nConvey(\"remember op\", func() {\n   objNew := Bar{}\n   objNewFunc := func(ctx context.Context, container framework.Container) (interface{}, error) {\n      obj := &amp;Bar{\n         Name: \"bar\",\n      }\n      return obj, nil\n   }\n   err = mc.Remember(ctx, \"foo_remember\", 1*time.Minute, objNewFunc, &amp;objNew)\n   So(err, ShouldBeNil)\n   So(objNew.Name, ShouldEqual, \"bar\")\n})\n</code></pre><p>我们定义了Bar结构，它实现了BinaryMarshaler和BinaryUnmarshaler接口，并且定义了一个objNewFunc方法实现了前面我们定义的RememberFunc。</p><p>之后可以使用Remember方法来为这个方法设置一个Cache-Aside缓存，它的key为foo_remember，缓存时长为1分钟。</p><p>最后回看一下我们对缓存的协议定义，各种缓存的设置和获取方法都有了，还差删除缓存的方法对吧。所以来定义删除单个key的缓存和删除多个key的缓存：</p><pre><code class=\"language-go\">// Del 删除某个key\nDel(ctx context.Context, key string) error\n// DelMany 删除某些key\nDelMany(ctx context.Context, keys []string) error\n</code></pre><p>到这里缓存协议就定义完成了，一共16个方法，要好好理解下这些方法的定义，还是那句话，理解如何定义协议比实现更为重要。<br>\n<img src=\"https://static001.geekbang.org/resource/image/da/e5/da9b83e6856e5fd523bc270981846fe5.jpg?wh=2364x2273\" alt=\"\"></p><h2>实现</h2><p>下面来实现这个缓存服务。前面一再强调了，Redis只是缓存的一种实现，Redis之外，我们可以用不同的存储来实现缓存，甚至，可以使用内存来实现。目前hade框架支持内存和Redis实现缓存，这里我们就先看看如何用Redis来实现缓存。</p><p>由于缓存有不同实现，所以和日志服务一样，<strong>要使用配置文件来cache.yaml中的driver字段，来区别使用哪个缓存</strong>。如果driver为redis，表示使用Redis来实现缓存，如果为memory，表示用内存来实现缓存。当然如果使用Redis的话，就需要同时带上Redis连接的各种参数，参数关键字都类似前面说的Redis服务的配置。</p><p>一个典型的cache.yaml的配置如下：</p><pre><code class=\"language-go\">driver: redis # 连接驱动\nhost: 127.0.0.1 # ip地址\nport: 6379 # 端口\ndb: 0 #db\ntimeout: 10s # 连接超时\nread_timeout: 2s # 读超时\nwrite_timeout: 2s # 写超时\n\n#driver: memory # 连接驱动\n</code></pre><p>那对应到具体实现上，区分使用哪个缓存驱动，我们会在服务提供者provider中来进行。在provider中，注意下Register方法，注册具体的服务实例方法时，要先读取配置中的cache.driver路径：</p><pre><code class=\"language-go\">// Register 注册一个服务实例\nfunc (l *HadeCacheProvider) Register(c framework.Container) framework.NewInstance {\n   if l.Driver == \"\" {\n      tcs, err := c.Make(contract.ConfigKey)\n      if err != nil {\n         // 默认使用console\n         return services.NewMemoryCache\n      }\n\n      cs := tcs.(contract.Config)\n      l.Driver = strings.ToLower(cs.GetString(\"cache.driver\"))\n   }\n\n   // 根据driver的配置项确定\n   switch l.Driver {\n   case \"redis\":\n      return services.NewRedisCache\n   case \"memory\":\n      return services.NewMemoryCache\n   default:\n      return services.NewMemoryCache\n   }\n}\n</code></pre><p>如果是Redis驱动，我们使用service.NewRedisCache来初始化一个Redis连接，定义RedisCache结构来存储redis.Client。</p><p><strong>在初始化的时候，先确定下容器中是否已经绑定了Redis服务，如果没有的话，做一下绑定操作</strong>。这个行为能让我们的缓存容器更为安全。</p><p>接着使用cache.yaml中的配置，来初始化一个redis.Client，这里使用的redisService.GetClient和redis.WithConfigPath，都是上面设计Redis服务的时候刚设计实现的方法。最后将redis.Client 封装到RedisCache中，返回：</p><pre><code class=\"language-go\">import (\n   \"context\"\n   \"errors\"\n   redisv8 \"github.com/go-redis/redis/v8\"\n   \"github.com/gohade/hade/framework\"\n   \"github.com/gohade/hade/framework/contract\"\n   \"github.com/gohade/hade/framework/provider/redis\"\n   \"sync\"\n   \"time\"\n)\n\n// RedisCache 代表Redis缓存\ntype RedisCache struct {\n   container framework.Container\n   client    *redisv8.Client\n   lock      sync.RWMutex\n}\n\n// NewRedisCache 初始化redis服务\nfunc NewRedisCache(params ...interface{}) (interface{}, error) {\n   container := params[0].(framework.Container)\n   if !container.IsBind(contract.RedisKey) {\n      err := container.Bind(&amp;redis.RedisProvider{})\n      if err != nil {\n         return nil, err\n      }\n   }\n\n   // 获取redis服务配置，并且实例化redis.Client\n   redisService := container.MustMake(contract.RedisKey).(contract.RedisService)\n   client, err := redisService.GetClient(redis.WithConfigPath(\"cache\"))\n   if err != nil {\n      return nil, err\n   }\n\n   // 返回RedisCache实例\n   obj := &amp;RedisCache{\n      container: container,\n      client:    client,\n      lock:      sync.RWMutex{},\n   }\n   return obj, nil\n}\n</code></pre><p>好，有Redis缓存的实例了，下面来看16个方法的实现。</p><p>Set系列的方法一共有Set/SetObj/SetMany/SetForever/SetForeverObj/SetTTL 6个，其他5个相对简单一些，在生成的redis.Client结构中都有对应实现，我们直接使用redis.Client调用即可，就不赘述了。其中SetMany方法相对复杂些，我们着重说明下。</p><p>在Redis中，SetMany这种为多个key设置缓存的方法，一般可以遍历key，然后一个个调用Set方法，但是这样效率就低了。更好的实现方式是使用pipeline。</p><p>什么是Redis的pipeline呢？Redis的客户端和服务端的交互，采用的是客户端-服务端模式，就是每个客户端的请求发送到Redis服务端，都会有一个完整的响应。所以，向服务端发送n个请求，就对应有n次响应。那么<strong>对于这种n个请求且n个请求没有上下文逻辑关系，我们能不能批量发送，但是只发送一次请求，然后只获取一次响应呢</strong>？</p><p>Redis的pipeline就是这个原理，它将多个请求合成为一个请求，批量发送给Redis服务端，并且只从服务端获取一次数据，拿到这些请求的所有结果。</p><p>我们的SetMany就很符合这个场景。具体的代码如下：</p><pre><code class=\"language-go\">// SetMany 设置多个key和值到缓存\nfunc (r *RedisCache) SetMany(ctx context.Context, data map[string]string, timeout time.Duration) error {\n   pipline := r.client.Pipeline()\n   cmds := make([]*redisv8.StatusCmd, 0, len(data))\n   for k, v := range data {\n      cmds = append(cmds, pipline.Set(ctx, k, v, timeout))\n   }\n   _, err := pipline.Exec(ctx)\n   return err\n}\n</code></pre><p>先用redis.Client.Pipeline() 来创建一个pipeline管道，然后用一个redis.StatusCmd数组来存储要发送的所有命令，最后调用一次pipeline.Exec来一次发送命令。</p><p>Set方法就讲到这里，Get系列的方法一共有4个，Get/GetObj/GetMany/GetTTL。</p><p>在实现Get系列方法的时候有地方需要注意下，因为<strong>Get是有可能Get一个不存在的key的</strong>，对于这种不存在的key是否返回error，是一个可以稍微思考的话题。</p><p>比如Get这个方法，返回的是string和error，如果对于一个不存在的key，返回了空字符串+空error的组合，而对于一个设置了空字符串的key，也返回空字符串+空error的组合，这里其实是丢失了“是否存在key”的信息的。</p><p>所以，对于这些不存在的key，我们设计返回一个 ErrKeyNotFound 的自定义error。像Get函数就实现为如下：</p><pre><code class=\"language-go\">// Get 获取某个key对应的值\nfunc (r *RedisCache) Get(ctx context.Context, key string) (string, error) {\n   val, err := r.client.Get(ctx, key).Result()\n   // 这里判断了key是否为空\n   if errors.Is(err, redisv8.Nil) {\n      return val, ErrKeyNotFound\n   }\n   return val, err\n}\n</code></pre><p>其他Get相关的实现没有什么难点。</p><p>除了Get系列和Set系列，其他的方法有Calc、Increment、Decrement、Del、DelMany 都没有什么太复杂的逻辑，都是redis.Client的具体封装。</p><p>最后看下Remember这个方法：</p><pre><code class=\"language-go\">// Remember 实现缓存的Cache-Aside模式, 先去缓存中根据key获取对象，如果有的话，返回，如果没有，调用RememberFunc 生成\nfunc (r *RedisCache) Remember(ctx context.Context, key string, timeout time.Duration, rememberFunc contract.RememberFunc, obj interface{}) error {\n   err := r.GetObj(ctx, key, obj)\n   // 如果返回为nil，说明有这个key，且有数据，obj已经注入了，返回nil\n   if err == nil {\n      return nil\n   }\n\n   // 有err，但是并不是key不存在，说明是有具体的error的，不能继续往下执行了，返回err\n   if !errors.Is(err, ErrKeyNotFound) {\n      return err\n   }\n\n   // 以下是key不存在的情况, 调用rememberFunc\n   objNew, err := rememberFunc(ctx, r.container)\n   if err != nil {\n      return err\n   }\n\n   // 设置key\n   if err := r.SetObj(ctx, key, objNew, timeout); err != nil {\n      return err\n   }\n   // 用GetObj将数据注入到obj中\n   if err := r.GetObj(ctx, key, obj); err != nil {\n      return err\n   }\n   return nil\n}\n</code></pre><p>前面说过Remember方法是Cache-Aside模式的实现，它的逻辑是先判断缓存中是否有这个key，如果有的话，直接返回对象，如果没有的话，就调用RememberFunc方法来实例化这个对象，并且返回这个实例化对象。</p><p>好了，这里的framework/provider/cache/redis.go我们实现差不多了。</p><h2>验证</h2><p>来做验证，我们为缓存服务写一个简单的路由，在这个路由中：</p><ul>\n<li>获取缓存服务</li>\n<li>设置foo为key的缓存，值为bar</li>\n<li>获取foo为key的缓存，把值打印到控制台</li>\n<li>删除foo为key的缓存</li>\n</ul><pre><code class=\"language-go\">// DemoCache cache的简单例子\nfunc (api *DemoApi) DemoCache(c *gin.Context) {\n   logger := c.MustMakeLog()\n   logger.Info(c, \"request start\", nil)\n   // 初始化cache服务\n   cacheService := c.MustMake(contract.CacheKey).(contract.CacheService)\n   // 设置key为foo\n   err := cacheService.Set(c, \"foo\", \"bar\", 1*time.Hour)\n   if err != nil {\n      c.AbortWithError(500, err)\n      return\n   }\n   // 获取key为foo\n   val, err := cacheService.Get(c, \"foo\")\n   if err != nil {\n      c.AbortWithError(500, err)\n      return\n   }\n   logger.Info(c, \"cache get\", map[string]interface{}{\n      \"val\": val,\n   })\n   // 删除key为foo\n   if err := cacheService.Del(c, \"foo\"); err != nil {\n      c.AbortWithError(500, err)\n      return\n   }\n   c.JSON(200, \"ok\")\n}\n</code></pre><p>增加对应的路由：</p><pre><code class=\"language-go\">r.GET(\"/demo/cache/redis\", api.DemoRedis)\n</code></pre><p>在浏览器中请求地址： <a href=\"http://localhost:8888/demo/cache/redis\">http://localhost:8888/demo/cache/redis</a>：<br>\n<img src=\"https://static001.geekbang.org/resource/image/2a/50/2acd5f030ab6b4d5ce8e05ec0c961850.png?wh=583x174\" alt=\"\"></p><p>查看控制台输出的日志：<br>\n<img src=\"https://static001.geekbang.org/resource/image/6c/14/6cf8ba131ba431303f5f77560015f814.png?wh=617x130\" alt=\"\"></p><p>可以明显看到cacheService.Get的数据为bar，打印了出来。验证正确！</p><p>本节课我们主要修改了framework目录下Redis和cache相关的代码。目录截图也放在这里供你对比查看，所有代码都已经上传到<a href=\"https://github.com/gohade/coredemo/tree/geekbang/27\">geekbang/27</a>分支了。<br>\n<img src=\"https://static001.geekbang.org/resource/image/04/03/04d8a0896596b62ab57848a882d82903.png?wh=355x1116\" alt=\"\"></p><h2>小结</h2><p>除DB之外，缓存是我们最常使用的一个存储了，今天我们先是实现了Redis的服务，再用Redis服务实现了一个缓存服务。</p><p>第一部分的Redis服务，同上一节课ORM的逻辑一样，我们只是将go-redis库进行了封装，具体怎么使用，还是依赖你在实际工作中多使用、多琢磨，网上也有很多go-redis库的相关资料。<br>\n<img src=\"https://static001.geekbang.org/resource/image/da/e5/da9b83e6856e5fd523bc270981846fe5.jpg?wh=2364x2273\" alt=\"\"><br>\n在第二部分实现的过程中，相信你现在能理解，<strong>一个服务的接口设计，就是一个“我们想要什么服务”的思考过程</strong>。比如在缓存服务接口设计中，我们定义了16个方法，囊括了Get/Set/Del/Remember等一系列方法，你可以对照思维导图复习一下。但这些方法并不是随便拍脑袋出来的，是因为有设置缓存、获取缓存、删除缓存等需求，才这样设计的。</p><h3>思考题</h3><p>目前hade框架支持内存和Redis实现缓存，我们今天展示了Redis的实现。缓存服务的内存缓存如何实现呢？可以先思考一下，如果是你来实现会如何设计呢？如果有兴趣，你可以自己动手操作一下。完成之后，你可以比对GitHub分支上我已经实现的版本，看看有没有更好的方案。</p><p>欢迎在留言区分享你的思考。感谢你的收听，如果你觉得今天的内容对你有所帮助，也欢迎分享给你身边的朋友，邀请他一起学习。我们下节课见～</p>","neighbors":{"left":{"article_title":"26｜GORM（下）：数据库的使用必不可少","id":440701},"right":{"article_title":"28｜SSH：如何生成发布系统让框架发布自动化？","id":445835}},"comments":[{"had_liked":false,"id":357535,"user_name":"qiutian","can_delete":false,"product_type":"c1","uid":1313498,"ip_address":"浙江","ucode":"99658A8E342498","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/da/dcf8f2b1.jpg","comment_is_top":false,"comment_ctime":1663344518,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663344518","product_id":100090601,"comment_content":"这篇感觉有点乱，一会是Redis的代码，一会又插入了Cache的代码，能看懂，但不是很清晰","like_count":0},{"had_liked":false,"id":349887,"user_name":"Jussi Lee","can_delete":false,"product_type":"c1","uid":1211190,"ip_address":"","ucode":"F2F5948CCD52A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/36/fd46331c.jpg","comment_is_top":false,"comment_ctime":1656412445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656412445","product_id":100090601,"comment_content":"redis 关闭链接的相关逻辑，好像没有看到","like_count":0},{"had_liked":false,"id":325361,"user_name":"Aaron","can_delete":false,"product_type":"c1","uid":1600291,"ip_address":"","ucode":"18AA1D86F7F4CE","user_header":"https://static001.geekbang.org/account/avatar/00/18/6b/23/ddad5282.jpg","comment_is_top":false,"comment_ctime":1638930849,"is_pvip":true,"replies":[{"id":"118663","content":"json.Marshal 的方式也是可以的, 本质都是序列化和反序列化。","user_name":"作者回复","user_name_real":"编辑","uid":"1069186","ctime":1639609285,"ip_address":"","comment_id":325361,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638930849","product_id":100090601,"comment_content":"SetObj方法的说明【GetObj 获取某个key对应的对象, 对象必须实现 https:&#47;&#47;pkg.go.dev&#47;encoding#BinaryUnMarshaler】， 我并没有这样实现， 我直接以json.Marshal，转成字符串的形式进行存储。get的时候，再json.Unmarshal进行转换，转换成结构体。另外，我实现的时候，设置过期时间的时候， 0代表永久存储， 在V8(v8.11.4, GO是1.17) 的源码里也能看到说明。【Zero expiration means the key has no expiration time.】","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539097,"discussion_content":"json.Marshal 的方式也是可以的, 本质都是序列化和反序列化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639609285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324385,"user_name":"牙小木","can_delete":false,"product_type":"c1","uid":1172050,"ip_address":"","ucode":"E5C12D37A62949","user_header":"https://static001.geekbang.org/account/avatar/00/11/e2/52/56dbb738.jpg","comment_is_top":false,"comment_ctime":1638412406,"is_pvip":true,"replies":[{"id":"117711","content":"哎是考虑到定义协议的时候容易乱，加了个图。还有哪里你觉得加个图更合适的吗？","user_name":"编辑回复","user_name_real":"编辑","uid":"2547771","ctime":1638416529,"ip_address":"","comment_id":324385,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1638412406","product_id":100090601,"comment_content":"层次描述清晰，感觉缺了点层次图。字不如图哦","like_count":0,"discussions":[{"author":{"id":2547771,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e0/3b/8ec916b2.jpg","nickname":"多少","note":"","ucode":"0A6EF7AA6E4BB7","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535351,"discussion_content":"哎是考虑到定义协议的时候容易乱，加了个图。还有哪里你觉得加个图更合适的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638416529,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322620,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1637502072,"is_pvip":true,"replies":[{"id":"119266","content":"是的，但是服务层毕竟封装了实例化的方法，这样至少把配置&#47;日志的逻辑都封装了，还是有一定必要的。","user_name":"作者回复","user_name_real":"编辑","uid":"1069186","ctime":1640224045,"ip_address":"","comment_id":322620,"utype":1}],"discussion_count":6,"race_medal":0,"score":"1637502072","product_id":100090601,"comment_content":"看上去封装的redis服务只会返回go-redis实现的redis client，那么定义redis服务的接口似乎就不是很必要，因为不会再有其他的redis服务的实现了。文中使用redis服务是为了实现缓存服务，那么直接用go-redis实现就好了。","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540974,"discussion_content":"是的，但是服务层毕竟封装了实例化的方法，这样至少把配置/日志的逻辑都封装了，还是有一定必要的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640224045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534338,"discussion_content":"自己封装了一层， 可以做功能的扩展，是有必要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638167673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534647,"discussion_content":"目前看不到会有什么样的扩展，能否举个例子呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638249936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":534338,"ip_address":""},"score":534647,"extra":""},{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":534769,"discussion_content":"比如我想监听redis中的一个key的变化，就需要封装下，这只是个简单的例子，自己封装下，好控制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638275362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":534647,"ip_address":""},"score":534769,"extra":""},{"author":{"id":1667175,"avatar":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","nickname":"qinsi","note":"","ucode":"090D9C4068FF12","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536096,"discussion_content":"是否可以理解为尽管redis服务只会返回同样的redis client实现，但可能不同的redis服务会对redis client进行不同的配置？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638687173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":534769,"ip_address":""},"score":536096,"extra":""}]}]},{"had_liked":false,"id":322492,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1241581,"ip_address":"","ucode":"9B70BE6908EB3B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f1/ed/4e249c6b.jpg","comment_is_top":false,"comment_ctime":1637418194,"is_pvip":false,"replies":[{"id":"119250","content":"是的，cache不只是redis","user_name":"作者回复","user_name_real":"编辑","uid":"1069186","ctime":1640221704,"ip_address":"","comment_id":322492,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637418194","product_id":100090601,"comment_content":"以redis为基础，最大限度扩展cache的抽象，学习了","like_count":0,"discussions":[{"author":{"id":1069186,"avatar":"https://static001.geekbang.org/account/avatar/00/10/50/82/32a2bf86.jpg","nickname":"叶剑峰","note":"","ucode":"3974D917C69C29","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540949,"discussion_content":"是的，cache不只是redis","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640221704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}