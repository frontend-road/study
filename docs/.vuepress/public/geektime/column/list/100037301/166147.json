{"id":166147,"title":"14 | 代码模型（下）：如何保证领域模型与代码模型的一致性？","content":"<p>你好，我是欧创新。</p><p>在 <a href=\"https://time.geekbang.org/column/article/163961\">[第 12 讲]</a> 中，我们了解了如何用事件风暴来构建领域模型，在构建领域模型的过程中，我们会提取出很多的领域对象，比如聚合、实体、命令和领域事件等。到了 <a href=\"https://time.geekbang.org/column/article/165248\">[第 13 讲]</a>，我们又根据DDD分层架构模型，建立了标准的微服务代码模型，为代码对象定义好了分层和目录结构。</p><p>那要想完成微服务的设计和落地，这之后其实还有一步，也就是我们今天的重点——将领域对象映射到微服务代码模型中。那为什么这一步如此重要呢？</p><p>DDD强调先构建领域模型然后设计微服务，以保证领域模型和微服务的一体性，因此我们不能脱离领域模型来谈微服务的设计和落地。但在构建领域模型时，我们往往是站在业务视角的，并且有些领域对象还带着业务语言。<span class=\"orange\">我们还需要将领域模型作为微服务设计的输入，对领域对象进行设计和转换，让领域对象与代码对象建立映射关系。</span></p><p>接下来我们围绕今天的重点，详细来讲一讲。</p><h2>领域对象的整理</h2><p>完成微服务拆分后，领域模型的边界和领域对象就基本确定了。</p><p>我们第一个重要的工作就是，整理事件风暴过程中产生的各个领域对象，比如：聚合、实体、命令和领域事件等内容，将这些领域对象和业务行为记录到下面的表格中。</p><p>你可以看到，这张表格里包含了：领域模型、聚合、领域对象和领域类型四个维度。一个领域模型会包含多个聚合，一个聚合包含多个领域对象，每个领域对象都有自己的领域类型。领域类型主要标识领域对象的属性，比如：聚合根、实体、命令和领域事件等类型。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/b5/ce/b5570b95095fd9103506fef3fa6a87ce.jpg?wh=1284*994\" alt=\"\"></p><h2>从领域模型到微服务的设计</h2><p>从领域模型到微服务落地，我们还需要做进一步的设计和分析。事件风暴中提取的领域对象，还需要经过用户故事或领域故事分析，以及微服务设计，才能用于微服务系统开发。</p><p>这个过程会比事件风暴来的更深入和细致。主要关注内容如下：</p><ul>\n<li>分析微服务内有哪些服务？</li>\n<li>服务所在的分层？</li>\n<li>应用服务由哪些服务组合和编排完成？</li>\n<li>领域服务包括哪些实体的业务逻辑？</li>\n<li>采用充血模型的实体有哪些属性和方法？</li>\n<li>有哪些值对象？</li>\n<li>哪个实体是聚合根等？</li>\n<li>最后梳理出所有的领域对象和它们之间的依赖关系，我们会给每个领域对象设计对应的代码对象，定义它们所在的软件包和代码目录。</li>\n</ul><p>这个设计过程建议参与的角色有：DDD专家、架构师、设计人员和开发经理。</p><h3>领域层的领域对象</h3><p>事件风暴结束时，领域模型聚合内一般会有：聚合、实体、命令和领域事件等领域对象。在完成故事分析和微服务设计后，微服务的聚合内一般会有：聚合、聚合根、实体、值对象、领域事件、领域服务和仓储等领域对象。</p><p>下面我们就来看一下这些领域对象是怎么得来的？</p><p><strong>1. 设计实体</strong></p><p>大多数情况下，领域模型的业务实体与微服务的数据库实体是一一对应的。但某些领域模型的实体在微服务设计时，可能会被设计为多个数据实体，或者实体的某些属性被设计为值对象。</p><p>我们分析个人客户时，还需要有地址、电话和银行账号等实体，它们被聚合根引用，不容易在领域建模时发现，我们需要在微服务设计过程中识别和设计出来。</p><p>在分层架构里，实体采用充血模型，在实体类内实现实体的全部业务逻辑。这些不同的实体都有自己的方法和业务行为，比如地址实体有新增和修改地址的方法，银行账号实体有新增和修改银行账号的方法。</p><p>实体类放在领域层的Entity目录结构下。</p><p><strong>2. 找出聚合根</strong></p><p>聚合根来源于领域模型，在个人客户聚合里，个人客户这个实体是聚合根，它负责管理地址、电话以及银行账号的生命周期。个人客户聚合根通过工厂和仓储模式，实现聚合内地址、银行账号等实体和值对象数据的初始化和持久化。</p><p>聚合根是一种特殊的实体，它有自己的属性和方法。聚合根可以实现聚合之间的对象引用，还可以引用聚合内的所有实体。聚合根类放在代码模型的Entity目录结构下。聚合根有自己的实现方法，比如生成客户编码，新增和修改客户信息等方法。</p><p><strong>3. 设计值对象</strong></p><p>根据需要将某些实体的某些属性或属性集设计为值对象。值对象类放在代码模型的Entity目录结构下。在个人客户聚合中，客户拥有客户证件类型，它是以枚举值的形式存在，所以将它设计为值对象。</p><p>有些领域对象可以设计为值对象，也可以设计为实体，我们需要根据具体情况来分析。如果这个领域对象在其它聚合内维护生命周期，且在它依附的实体对象中只允许整体替换，我们就可以将它设计为值对象。如果这个对象是多条且需要基于它做查询统计，我建议将它设计为实体。</p><p><strong>4. 设计领域事件</strong></p><p>如果领域模型中领域事件会触发下一步的业务操作，我们就需要设计领域事件。首先确定领域事件发生在微服务内还是微服务之间。然后设计事件实体对象，事件的发布和订阅机制，以及事件的处理机制。判断是否需要引入事件总线或消息中间件。</p><p>在个人客户聚合中有客户已创建的领域事件，因此它有客户创建事件这个实体。</p><p>领域事件实体和处理类放在领域层的Event目录结构下。领域事件的发布和订阅类我建议放在应用层的Event目录结构下。</p><p><strong>5. 设计领域服务</strong></p><p>如果一个业务动作或行为跨多个实体，我们就需要设计领域服务。领域服务通过对多个实体和实体方法进行组合，完成核心业务逻辑。你可以认为领域服务是位于实体方法之上和应用服务之下的一层业务逻辑。</p><p>按照严格分层架构层的依赖关系，如果实体的方法需要暴露给应用层，它需要封装成领域服务后才可以被应用服务调用。所以如果有的实体方法需要被前端应用调用，我们会将它封装成领域服务，然后再封装为应用服务。</p><p>个人客户聚合根这个实体创建个人客户信息的方法，被封装为创建个人客户信息领域服务。然后再被封装为创建个人客户信息应用服务，向前端应用暴露。</p><p>领域服务类放在领域层的Service目录结构下。</p><p><strong>6. 设计仓储</strong></p><p>每一个聚合都有一个仓储，仓储主要用来完成数据查询和持久化操作。仓储包括仓储的接口和仓储实现，通过依赖倒置实现应用业务逻辑与数据库资源逻辑的解耦。</p><p>仓储代码放在领域层的Repository目录结构下。</p><h3>应用层的领域对象</h3><p>应用层的主要领域对象是应用服务和事件的发布以及订阅。</p><p>在事件风暴或领域故事分析时，我们往往会根据用户或系统发起的命令，来设计服务或实体方法。为了响应这个命令，我们需要分析和记录：</p><ul>\n<li>在应用层和领域层分别会发生哪些业务行为；</li>\n<li>各层分别需要设计哪些服务或者方法；</li>\n<li>这些方法和服务的分层以及领域类型（比如实体方法、领域服务和应用服务等），它们之间的调用和组合的依赖关系。</li>\n</ul><p>在严格分层架构模式下，不允许服务的跨层调用，每个服务只能调用它的下一层服务。服务从下到上依次为：实体方法、领域服务和应用服务。</p><p>如果需要实现服务的跨层调用，我们应该怎么办？我建议你采用服务逐层封装的方式。</p><p><img src=\"https://static001.geekbang.org/resource/image/eb/b2/eb626396fcb9f541ec46a799275e04b2.png?wh=2233*1571\" alt=\"\"></p><p>我们看一下上面这张图，服务的封装和调用主要有以下几种方式。</p><p><strong>1. 实体方法的封装</strong></p><p>实体方法是最底层的原子业务逻辑。如果单一实体的方法需要被跨层调用，你可以将它封装成领域服务，这样封装的领域服务就可以被应用服务调用和编排了。如果它还需要被用户接口层调用，你还需要将这个领域服务封装成应用服务。经过逐层服务封装，实体方法就可以暴露给上面不同的层，实现跨层调用。</p><p>封装时服务前面的名字可以保持一致，你可以用*DomainService或*AppService后缀来区分领域服务或应用服务。</p><p><strong>2. 领域服务的组合和封装</strong></p><p>领域服务会对多个实体和实体方法进行组合和编排，供应用服务调用。如果它需要暴露给用户接口层，领域服务就需要封装成应用服务。</p><p><strong>3.应用服务的组合和编排</strong></p><p>应用服务会对多个领域服务进行组合和编排，暴露给用户接口层，供前端应用调用。</p><p>在应用服务组合和编排时，你需要关注一个现象：多个应用服务可能会对多个同样的领域服务重复进行同样业务逻辑的组合和编排。当出现这种情况时，你就需要分析是不是领域服务可以整合了。你可以将这几个不断重复组合的领域服务，合并到一个领域服务中实现。这样既省去了应用服务的反复编排，也实现了服务的演进。这样领域模型将会越来越精炼，更能适应业务的要求。</p><p>应用服务类放在应用层Service目录结构下。领域事件的发布和订阅类放在应用层Event目录结构下。</p><h2>领域对象与微服务代码对象的映射</h2><p>在完成上面的分析和设计后，我们就可以建立像下图一样的，领域对象与微服务代码对象的映射关系了。</p><h3>典型的领域模型</h3><p>个人客户领域模型中的个人客户聚合，就是典型的领域模型，从聚合内可以提取出多个实体和值对象以及它的聚合根。</p><p>我们看一下下面这个图，我们对个人客户聚合做了进一步的分析。提取了个人客户表单这个聚合根，形成了客户类型值对象，以及电话、地址、银行账号等实体，为实体方法和服务做了封装和分层，建立了领域对象的关联和依赖关系，还有仓储等设计。关键是这个过程，我们建立了领域对象与微服务代码对象的映射关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/70/c1fce57f9e2a88ab2728db79ff45c770.png?wh=1493*885\" alt=\"\"></p><p>下面我对表格的各栏做一个简要的说明。</p><ul>\n<li>层：定义领域对象位于分层架构中的哪一层，比如：接口层、应用层、领域层以及基础层等。</li>\n<li>领域对象：领域模型中领域对象的具体名称。</li>\n<li>领域类型：根据DDD知识体系定义的领域对象的类型，包括：限界上下文、聚合、聚合根、实体、值对象、领域事件、应用服务、领域服务和仓储服务等领域类型。</li>\n<li>依赖的领域对象：根据业务对象依赖或分层调用的依赖关系，建立的领域对象的依赖关系，比如：服务调用依赖、关联对象聚合等。</li>\n<li>包名：代码模型中的包名，对应领域对象所在的软件包。</li>\n<li>类名：代码模型中的类名，对应领域对象的类名。</li>\n<li>方法名：代码模型中的方法名，对应领域对象实现或操作的方法名。</li>\n</ul><p>在建立这种映射关系后，我们就可以得到如下图的微服务代码结构了。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/5e/84a486d4c0d9146462b31c7fcd5d835e.png?wh=370*661\" alt=\"\"></p><h3>非典型领域模型</h3><p>有些业务场景可能并不能如你所愿，你可能无法设计出典型的领域模型。这类业务中有多个实体，实体之间相互独立，是松耦合的关系，这些实体主要参与分析或者计算，你找不出聚合根，但就业务本身来说它们是高内聚的。而它们所组合的业务与其它聚合是在一个限界上下文内，你也不大可能将它单独设计为一个微服务。</p><p>这种业务场景其实很常见。比如，在个人客户领域模型内有客户归并的聚合，它扫描所有客户，按照身份证号码、电话号码等是否重复的业务规则，判断是否是重复的客户，然后对重复的客户进行归并。这种业务场景你就找不到聚合根。</p><p>那对于这类非典型模型，我们怎么办？</p><p>我们还是可以借鉴聚合的思想，仍然用聚合来定义这部分功能，并采用与典型领域模型同样的分析方法，建立实体的属性和方法，对方法和服务进行封装和分层设计，设计仓储，建立领域对象之间的依赖关系。唯一可惜的就是我们依然找不到聚合根，不过也没关系，除了聚合根管理功能外，我们还可以用DDD的其它设计方法。</p><h2>总结</h2><p>今天我们学习了从领域模型到微服务的设计过程，这个过程在微服务设计过程中非常的关键。你需要从微服务系统的角度，对领域模型做深入、细致的分析，为领域对象分层，找出各个领域对象的依赖关系，建立领域对象与微服务代码对象的映射关系，从而保证领域模型与代码模型的一致性，最终完成微服务的设计。</p><p>在建立这种业务模型与微服务系统架构的关系后，整个项目团队就可以在统一的通用语言下工作，即使不熟悉业务的开发人员，或者不熟悉代码的业务人员，也可以很快就定位到代码位置。</p><h2>思考题</h2><p>分析一下基于DDD领域模型的微服务设计方式，和你公司现在所进行的微服务设计，或者和你了解到的微服务设计，有什么不同？</p><p>期待你的分享，我们一同交流！</p><p></p>","neighbors":{"left":{"article_title":"13 | 代码模型（上）：如何使用DDD设计微服务代码模型？","id":165248},"right":{"article_title":"15 | 边界：微服务的各种边界在架构演进中的作用？","id":166635}},"comments":[{"had_liked":false,"id":231367,"user_name":"伊来温","can_delete":false,"product_type":"c1","uid":2044174,"ip_address":"","ucode":"137E3A8258206B","user_header":"https://static001.geekbang.org/account/avatar/00/1f/31/0e/cbcada9b.jpg","comment_is_top":false,"comment_ctime":1593658118,"is_pvip":false,"replies":[{"id":"85460","content":"从你的场景来看，企业跟用户是一对多的关系吧。你可以这样设计，在企业聚合中将用户的相关信息设计为一个包含若干用户属性的用户值对象，然后企业聚合根引用用户值对象，用户值对象的数据来源于用户聚合。<br>用户聚合包含了全量的用户数据，而在企业聚合中用户值对象只是简单必须的用户数据，通过这种数据冗余的方式，在企业聚合中，就可以通过企业领域服务中一次获取企业和它相关的用户数据清单。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593670600,"ip_address":"","comment_id":231367,"utype":1}],"discussion_count":13,"race_medal":0,"score":"87493004038","product_id":100037301,"comment_content":"我的回复怎么不见了，再发一下。请教下老师，关于领域代码的分层和编排上一直以来我有个一个疑问。假设我有两个领域聚合跟，用户(User)和企业(Corp)，对应的领域服务是UserDomianService和CorpDomainService，那我假如需要这个一个接口listCoprUser来获取企业下面的用户列表， 这个接口该放在哪一层做编排呢。1. 如果放在CorpDomainService里面，则会造成对User实体的引用，造成耦合。2.难道上升到app层做编排么？但listCoprUser又像是一个领域服务。3.又或者做成一个新的领域服务CorpUserDomainService吗？那是不是CorpUserDomainService在代码结构上只有一个领域服务，而没有repository, domain层级了呢？","like_count":21,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500275,"discussion_content":"从你的场景来看，企业跟用户是一对多的关系吧。你可以这样设计，在企业聚合中将用户的相关信息设计为一个包含若干用户属性的用户值对象，然后企业聚合根引用用户值对象，用户值对象的数据来源于用户聚合。\n用户聚合包含了全量的用户数据，而在企业聚合中用户值对象只是简单必须的用户数据，通过这种数据冗余的方式，在企业聚合中，就可以通过企业领域服务中一次获取企业和它相关的用户数据清单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593670600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1032205,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/0d/e6a7cf89.jpg","nickname":"加哈乌哈提","note":"","ucode":"FCA4227CCF8296","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534446,"discussion_content":"对于主要是查询的问题，看过很多文章，比较好的方式CQRS（命令查询职责分离），在Query的时候，可以抛开DDD的限制，直接用类似传统的三层架构的方式去数据库查询。\n\n当然前提是，需要想清楚user和corp的关联关系如何处理；\n一般user最多有属于个或者少量的几个corp，因此将老师前面的回答调整一下，在user这个聚合下维护一个valueobject用来存储corp rel，这样在执行command的时候相对容易，然后查询的时候直接join数据表做相关分页之类的操作就可以了。\n\n大家可以一起讨论。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1638190765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1032205,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/0d/e6a7cf89.jpg","nickname":"加哈乌哈提","note":"","ucode":"FCA4227CCF8296","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564497,"discussion_content":"从业务上，员工作为企业的值对象是合理的，但数据库设计上需要建立关联表了。\n从实现上，员工表上添加企业字段，更加简单。还有一个前提是企业与员工是一对多的关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650257258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":534446,"ip_address":""},"score":564497,"extra":""}]},{"author":{"id":1096652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","nickname":"xxx","note":"","ucode":"E79CEA70430449","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385624,"discussion_content":"这里的核心思想还是：聚合之间不应该直接引用，只可以引用id，或者采用值对象的方式保存引用聚合的一部分核心字段。这两种方式各有优缺点：采用id需要应用层再查一次，优点则是数据不会过期。采用值对象的优点是不需应用层再查一次，并且查询的时候如果需要一些过滤条件也可以直接支持；缺点则是数据可能会过期（当然有的数据场景要求数据就是要当时的快照，比如订单中的送货地址，此时缺点就变成了优点）。\n前面所描述的还都是模型层面的（或者对象层面的），到持久层如何落地又是另一个场景，需要分开讨论。值对象可以直接铺平字段到实体中（只能支持1对1），也可以作为一个json放到一个字段中（也支持一对多）。如果引用的是个集合（一对多）并且基数很大，显然放到一个表就不合适了，应该分开存到另一个表中。查询时可以分页，不要全量取。\n最后最近的专栏《如何落地业务建模》中提到了关联对象，可以用来处理这种场景。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1627183514,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2078752,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/b8/20/832e01dc.jpg","nickname":"ZzC🍖","note":"","ucode":"9EF8785409E77D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323791,"discussion_content":"按照老师的说法，那企业聚合中的用户值对象的来源是什么呢？领域事件吗？或者是数据库同步技术同步来的？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1604997300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1707838,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AcJM5WNhE062TQAsIE8KTxTsZMTHJHCm4LCfsjBPibZ6iaGRamfZqIRFcLXLVfAQobeCIgA9o5wiaRCKa0dNbic1iag/132","nickname":"paulmin","note":"","ucode":"6AAB20AB369E90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398355,"discussion_content":"这种情况下， 分页查询的技术问题要如何解决？应该要上升应用服务层，有一个CorpUserAppService或UserCorpAppService的服务来去获取仓储层一个冗余的聚合数据表 user_corp_combine 的跨表的带条件的查询吧？例如根据用户名查询第二页的其所归属的企业数据列表。（假设一个用户可拥有N个企业，反之亦然，做多对多的情况）\n-- 用户名查询时要去调用User领域服务换取变成id值！（来解决用户数据冗余到聚合表，但主表上的用户名发生变化的情况）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632761138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077598,"avatar":"https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg","nickname":"Peter Yu","note":"","ucode":"D56786A6E85321","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329321,"discussion_content":"【然后企业聚合根引用用户值对象，用户值对象的数据来源于用户聚合】老师，这个用户值对象的数据是通过哪一层的service获得，userDomainService，还是userAppService。考虑到层级依赖关系，应该调用userDomainService？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606366478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1752796,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/be/dc/ce674e93.jpg","nickname":"Michael","note":"","ucode":"7BC7539A3355DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584027,"discussion_content":"可否把这个功能放在user的领域服务里，提供一个接口查询在某个企业下的所有用户，因为user有corp这个属性，自然应该带有filter功能，user表也有corp字段。那这个查询就是对user做过滤，查出满足条件的user","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660564271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1496195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJrgpv3Kia5Iw2kmg2rV4PSReiaic8d0Dj93XPlJaNpPRPC2xAIS22PQerSxb0cgjChSGAEOyX4tJBCQ/132","nickname":"夏风","note":"","ucode":"EEF37E75FBBA8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352538,"discussion_content":"如果一个企业有几万人，这个用户值对象不是很大？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614765500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1707838,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/AcJM5WNhE062TQAsIE8KTxTsZMTHJHCm4LCfsjBPibZ6iaGRamfZqIRFcLXLVfAQobeCIgA9o5wiaRCKa0dNbic1iag/132","nickname":"paulmin","note":"","ucode":"6AAB20AB369E90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1496195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJrgpv3Kia5Iw2kmg2rV4PSReiaic8d0Dj93XPlJaNpPRPC2xAIS22PQerSxb0cgjChSGAEOyX4tJBCQ/132","nickname":"夏风","note":"","ucode":"EEF37E75FBBA8A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398349,"discussion_content":"那就要做翻页的设计了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632760608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352538,"ip_address":""},"score":398349,"extra":""},{"author":{"id":1270239,"avatar":"https://static001.geekbang.org/account/avatar/00/13/61/df/c9470e1f.jpg","nickname":"明同学","note":"","ucode":"4F0877EB8B942E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1496195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJrgpv3Kia5Iw2kmg2rV4PSReiaic8d0Dj93XPlJaNpPRPC2xAIS22PQerSxb0cgjChSGAEOyX4tJBCQ/132","nickname":"夏风","note":"","ucode":"EEF37E75FBBA8A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539938,"discussion_content":"根据企业code查询用户列表，这个算是报表了，是不是应该放到数据中台，而不是放在业务域系统里实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639885836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":352538,"ip_address":""},"score":539938,"extra":""}]},{"author":{"id":1180810,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/8a/ff94bd60.jpg","nickname":"涛涛","note":"","ucode":"747C4B1F20A2D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289531,"discussion_content":"老师，企业对用户的映射也要单独存储到一张表了？是这样吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594131078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2044174,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/31/0e/cbcada9b.jpg","nickname":"伊来温","note":"","ucode":"137E3A8258206B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288194,"discussion_content":"豁然开朗，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593674992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167173,"user_name":"Jack.Chen","can_delete":false,"product_type":"c1","uid":1233590,"ip_address":"","ucode":"3A321C759AA0AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/d2/b6/31837c65.jpg","comment_is_top":false,"comment_ctime":1577707510,"is_pvip":false,"replies":[{"id":"64941","content":"这两天会加一篇完整的代码详解。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577744233,"ip_address":"","comment_id":167173,"utype":1}],"discussion_count":6,"race_medal":0,"score":"66002216950","product_id":100037301,"comment_content":"希望把完整样例代码放出来","like_count":15,"discussions":[{"author":{"id":1233590,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d2/b6/31837c65.jpg","nickname":"Jack.Chen","note":"","ucode":"3A321C759AA0AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":122927,"discussion_content":"这都一周了，样例代码没好吗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1578380475,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1725691,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/54/fb/d533b03e.jpg","nickname":"Andy","note":"","ucode":"BDA2AEB353ECC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1233590,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d2/b6/31837c65.jpg","nickname":"Jack.Chen","note":"","ucode":"3A321C759AA0AC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572539,"discussion_content":"哈哈代码有了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652843170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":122927,"ip_address":""},"score":572539,"extra":""}]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479768,"discussion_content":"这两天会加一篇完整的代码详解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577744233,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1481811,"avatar":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","nickname":"ub8","note":"","ucode":"0D937C3EAEB781","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":582659,"discussion_content":"大哥两年过去了代码呢\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659581595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":479768,"ip_address":"北京"},"score":582659,"extra":""}]},{"author":{"id":1390326,"avatar":"https://static001.geekbang.org/account/avatar/00/15/36/f6/d65b7302.jpg","nickname":"峰","note":"","ucode":"527BB65559F0B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205501,"discussion_content":"持久化的最佳实践是什么？把持久化对象和领域对象分开，还是合在一起？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584318845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1233590,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d2/b6/31837c65.jpg","nickname":"Jack.Chen","note":"","ucode":"3A321C759AA0AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":113969,"discussion_content":"行，那就等两天","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577945437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230654,"user_name":"冯磊","can_delete":false,"product_type":"c1","uid":1177161,"ip_address":"","ucode":"1F36B58ADBBF22","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/49/179cc446.jpg","comment_is_top":false,"comment_ctime":1593441270,"is_pvip":false,"replies":[{"id":"85211","content":"应用层连接用户接口层和领域层，它是很薄的一层，主要职能是协调领域层多个聚合完成服务的组合和编排。<br>应用层之下是领域层，领域层是由多个业务职责单一的聚合构成，实现核心的领域逻辑。应用层负责协调领域层多个聚合的领域服务或领域对象，面向用例和业务流程完成服务的组合和编排。所以理论上应用层不应该实现领域模型的领域逻辑。这也是应用层为什么会很薄的原因。<br>应用层之上是用户接口层，在应用层完成领域层服务组合和编排后，应用服务被用户接口层Facade服务封装，完成接口和数据适配后，以粗粒度的服务通过API网关面向前端应用发布。<br>此外，应用层也是微服务之间服务调用的通道，微服务在应用层可以调用其他微服务的应用服务，完成微服务之间的服务组合和编排。<br>在应用层主要有应用服务、事件订阅和发布等相关代码逻辑。<br>其中，应用服务主要负责服务的组合、编排和转发，处理业务用例的执行顺序以及结果的拼装。在应用服务中还可以进行安全认证、权限校验、事务控制、领域事件发布或订阅等。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593495880,"ip_address":"","comment_id":230654,"utype":1}],"discussion_count":4,"race_medal":0,"score":"53133048822","product_id":100037301,"comment_content":"感觉application这一层完全可以去掉，intrerface直接调domain service就可以的。作者能解释一下application这一层为什么必须存在吗？","like_count":12,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499977,"discussion_content":"应用层连接用户接口层和领域层，它是很薄的一层，主要职能是协调领域层多个聚合完成服务的组合和编排。\n应用层之下是领域层，领域层是由多个业务职责单一的聚合构成，实现核心的领域逻辑。应用层负责协调领域层多个聚合的领域服务或领域对象，面向用例和业务流程完成服务的组合和编排。所以理论上应用层不应该实现领域模型的领域逻辑。这也是应用层为什么会很薄的原因。\n应用层之上是用户接口层，在应用层完成领域层服务组合和编排后，应用服务被用户接口层Facade服务封装，完成接口和数据适配后，以粗粒度的服务通过API网关面向前端应用发布。\n此外，应用层也是微服务之间服务调用的通道，微服务在应用层可以调用其他微服务的应用服务，完成微服务之间的服务组合和编排。\n在应用层主要有应用服务、事件订阅和发布等相关代码逻辑。\n其中，应用服务主要负责服务的组合、编排和转发，处理业务用例的执行顺序以及结果的拼装。在应用服务中还可以进行安全认证、权限校验、事务控制、领域事件发布或订阅等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593495880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1444583,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erS45sT36oSCibh8YMF9aD0IKltrdCoEicqUeEzbC2Hlr4UiahibfLvpib3LauzQxv6X3vyfCvrgz0m3dg/132","nickname":"jeeker","note":"","ucode":"1E78795E7DF8E7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591784,"discussion_content":"应用层是编排业务的，业务用例往往是多个领域行为的组合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666828936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580280,"discussion_content":"原因是如果有多个聚合需要合作完成事情，并且接口有不同来原，如mq，客户调用。这时就需要应用层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658062267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213325,"avatar":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","nickname":"徐李","note":"","ucode":"41550F6CA1E112","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540268,"discussion_content":"应用层确实感觉是为了抽象而抽象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640003360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230016,"user_name":"suke","can_delete":false,"product_type":"c1","uid":1007753,"ip_address":"","ucode":"C0287C31A4F45B","user_header":"","comment_is_top":false,"comment_ctime":1593242699,"is_pvip":false,"replies":[{"id":"85221","content":"依赖倒置的代码在加餐里面会有详细说明。<br>一、依赖倒置（DIP）设计：是指面向接口编程，而不是面向实现编程。这样可以避免业务逻辑与实现逻辑的耦合，在实现逻辑出现变化时，降低对业务逻辑的影响。<br>为了解耦领域逻辑和数据处理逻辑，我们在领域层和基础层之间增加了薄薄的一层，这一层就是仓储。<br>仓储模式包含仓储接口和仓储实现，仓储接口面向领域层提供基础层数据处理相关的访问接口，仓储实现完成仓储接口对应的数据持久化相关的逻辑处理。一个聚合会有一个仓储，统一由仓储来完成聚合数据的持久化。<br>领域层业务逻辑面向仓储接口编程，当聚合内的实体数据需要持久化时，只需将领域对象DO对象转换成PO持久化对象，然后传递给仓储接口，通过仓储实现完成DO数据的持久化工作。这样领域层就可以更好的聚焦于聚合的领域逻辑，而不必关心实体数据在基础层到底是如何实现持久化的了。<br>仓储接口的实现逻辑非常简单，只需要在仓储接口类中，定义仓储实现的基本接口和参数就可以了。<br>仓储接口代码如下：<br>public interface PersonRepository {<br>  void insert(PersonPO personPO);<br>  void update(PersonPO personPO);<br>  PersonPO findById(String personId);<br>  PersonPO findLeaderByPersonId(String personId);<br>}<br>仓储实现会根据仓储接口的数据处理逻辑要求，调用DAO完成数据查询或数据持久化，如基于聚合根ID的查询，聚合中新增或修改等领域对象数据的持久化操作。假如数据库需要技术升级，我们只需调整仓储实现的数据处理逻辑，适配新的数据库就可以了，这种调整不会影响领域逻辑。<br>仓储实现代码如下：<br>public class PersonRepositoryImpl implements PersonRepository {<br>       @Autowired<br>    PersonDao personDao;<br>    @Override<br>    public void insert(PersonPO personPO) {<br>        personDao.save(personPO);<br>    }<br>    @Override<br>    public void update(PersonPO personPO) {<br>        personDao.save(personPO);<br>    }<br>    @Override<br>    public PersonPO findById(String personId) {<br>        return personDao.findById(personId).orElseThrow(() -&gt; new RuntimeException(&quot;未找到用户&quot;));<br>    }<br>    @Override<br>    public PersonPO findLeaderByPersonId(String personId) {<br>        return personDao.findLeaderByPersonId(personId);<br>    }<br>}<br>在领域服务中，可以调用仓储接口完成数据持久化操作。由于领域服务只与仓储接口发生调用关系，数据的持久化逻辑在仓储实现中完成。因此在更换数据库时，只要仓储接口不变，领域服务的逻辑就可以一直保持不变。<br>领域服务如下：<br>public class PersonDomainService {<br>    @Autowired<br>    PersonRepository personRepository;   <br>    public void update(Person person) {<br>        personRepository.update(personFactory.createPersonPO(person));<br>    }<br>}<br>这样就保持了领域层领域逻辑的稳定，实现了领域层与基础层的解耦和依赖倒置。<br>二、充血模型与贫血模型的关键差异：<br>在充血模型中，业务逻辑都在领域实体对象中实现，实体本身不仅包含了属性，还包含了它的业务行为。DDD领域模型中实体是一个具有业务行为和逻辑的对象。<br>而在贫血模型中领域对象大多只有setter和getter方法，业务逻辑统一放在业务逻辑层实现，而不是在领域对象中实现。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593498503,"ip_address":"","comment_id":230016,"utype":1}],"discussion_count":4,"race_medal":0,"score":"48837882955","product_id":100037301,"comment_content":"老师 请问依赖倒置是如何体现的？还有所谓的充血模式，最好能有具体的代码说明，不然还是觉得很空洞","like_count":11,"discussions":[{"author":{"id":1451068,"avatar":"https://static001.geekbang.org/account/avatar/00/16/24/3c/23456f0d.jpg","nickname":"🎩","note":"","ucode":"2F1C469595CF51","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329254,"discussion_content":"这个例子有问题吧，仓储不是操作聚合根的吗？这例子怎么是操作PO","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1606354001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499737,"discussion_content":"依赖倒置的代码在加餐里面会有详细说明。\n一、依赖倒置（DIP）设计：是指面向接口编程，而不是面向实现编程。这样可以避免业务逻辑与实现逻辑的耦合，在实现逻辑出现变化时，降低对业务逻辑的影响。\n为了解耦领域逻辑和数据处理逻辑，我们在领域层和基础层之间增加了薄薄的一层，这一层就是仓储。\n仓储模式包含仓储接口和仓储实现，仓储接口面向领域层提供基础层数据处理相关的访问接口，仓储实现完成仓储接口对应的数据持久化相关的逻辑处理。一个聚合会有一个仓储，统一由仓储来完成聚合数据的持久化。\n领域层业务逻辑面向仓储接口编程，当聚合内的实体数据需要持久化时，只需将领域对象DO对象转换成PO持久化对象，然后传递给仓储接口，通过仓储实现完成DO数据的持久化工作。这样领域层就可以更好的聚焦于聚合的领域逻辑，而不必关心实体数据在基础层到底是如何实现持久化的了。\n仓储接口的实现逻辑非常简单，只需要在仓储接口类中，定义仓储实现的基本接口和参数就可以了。\n仓储接口代码如下：\npublic interface PersonRepository {\n  void insert(PersonPO personPO);\n  void update(PersonPO personPO);\n  PersonPO findById(String personId);\n  PersonPO findLeaderByPersonId(String personId);\n}\n仓储实现会根据仓储接口的数据处理逻辑要求，调用DAO完成数据查询或数据持久化，如基于聚合根ID的查询，聚合中新增或修改等领域对象数据的持久化操作。假如数据库需要技术升级，我们只需调整仓储实现的数据处理逻辑，适配新的数据库就可以了，这种调整不会影响领域逻辑。\n仓储实现代码如下：\npublic class PersonRepositoryImpl implements PersonRepository {\n       @Autowired\n    PersonDao personDao;\n    @Override\n    public void insert(PersonPO personPO) {\n        personDao.save(personPO);\n    }\n    @Override\n    public void update(PersonPO personPO) {\n        personDao.save(personPO);\n    }\n    @Override\n    public PersonPO findById(String personId) {\n        return personDao.findById(personId).orElseThrow(() -&amp;gt; new RuntimeException(&amp;quot;未找到用户&amp;quot;));\n    }\n    @Override\n    public PersonPO findLeaderByPersonId(String personId) {\n        return personDao.findLeaderByPersonId(personId);\n    }\n}\n在领域服务中，可以调用仓储接口完成数据持久化操作。由于领域服务只与仓储接口发生调用关系，数据的持久化逻辑在仓储实现中完成。因此在更换数据库时，只要仓储接口不变，领域服务的逻辑就可以一直保持不变。\n领域服务如下：\npublic class PersonDomainService {\n    @Autowired\n    PersonRepository personRepository;   \n    public void update(Person person) {\n        personRepository.update(personFactory.createPersonPO(person));\n    }\n}\n这样就保持了领域层领域逻辑的稳定，实现了领域层与基础层的解耦和依赖倒置。\n二、充血模型与贫血模型的关键差异：\n在充血模型中，业务逻辑都在领域实体对象中实现，实体本身不仅包含了属性，还包含了它的业务行为。DDD领域模型中实体是一个具有业务行为和逻辑的对象。\n而在贫血模型中领域对象大多只有setter和getter方法，业务逻辑统一放在业务逻辑层实现，而不是在领域对象中实现。\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1593498503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2108194,"avatar":"https://static001.geekbang.org/account/avatar/00/20/2b/22/79d183db.jpg","nickname":"H·H","note":"","ucode":"113E95BA6B6F51","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":584578,"discussion_content":"老师，仓储层的输出应该是DO而不是PO  我理解仓储层主要就是把PO转换成DO","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660927793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":499737,"ip_address":"上海"},"score":584578,"extra":""}]},{"author":{"id":1810545,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a0/71/50812cef.jpg","nickname":"BestQiang","note":"","ucode":"CF028621D39B67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342948,"discussion_content":"所以,充血模型的例子呢?这还是对概念解释了一下而已呀.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610885332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151956,"user_name":"ANYI","can_delete":false,"product_type":"c1","uid":1084773,"ip_address":"","ucode":"B010B0FB10E0C5","user_header":"https://static001.geekbang.org/account/avatar/00/10/8d/65/633a7478.jpg","comment_is_top":false,"comment_ctime":1573821599,"is_pvip":false,"replies":[{"id":"58505","content":"1、实体的这些数据库映射是通过mapper来实现的。<br>2、松散分层架构是可以跨层调用了，实现起来很容易。但是在复杂的情况下，服务不太容易管理，比如，你可能不知道你的方法到底被谁组合和封装了，一旦出现方法变更，你不容易一次找出所有受影响方。而逐层封装的话，你只需要逐层通知到上层就可以了。<br>3、微服务内的服务编排相对简单，就是业务逻辑的执行顺序而已，个人感觉不需要引入什么工具。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573907165,"ip_address":"","comment_id":151956,"utype":1}],"discussion_count":7,"race_medal":0,"score":"23048658079","product_id":100037301,"comment_content":"1，对于实体采用充血模型，包含自己的属性及行为，例如保持、更新、删除等行为方法，需要持久化，依赖基础层数据库操作，是在实体直接引入，例如mybatis的mapper？<br>2，对于相对简单的实体操作增删改查这种，需要暴露到接口层；那要一层一层向上封装，实体》领域服务》应用服务》接口服务；这样是不是又显得代码很多余；一个简单的增加修改方法接口，需要很多冗余代码，上层也没有其他逻辑，封装一下调用下层，写一个接口，要写很多层次调用，是否会很臃肿啰嗦，是不是就可以直接接口层封装就省去一些层呢？<br>3，在服务编排上有没有一些框架什么的？还是都是通过if else的手写？","like_count":5,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474669,"discussion_content":"1、实体的这些数据库映射是通过mapper来实现的。\n2、松散分层架构是可以跨层调用了，实现起来很容易。但是在复杂的情况下，服务不太容易管理，比如，你可能不知道你的方法到底被谁组合和封装了，一旦出现方法变更，你不容易一次找出所有受影响方。而逐层封装的话，你只需要逐层通知到上层就可以了。\n3、微服务内的服务编排相对简单，就是业务逻辑的执行顺序而已，个人感觉不需要引入什么工具。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573907165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254112,"avatar":"https://static001.geekbang.org/account/avatar/00/13/22/e0/6295a753.jpg","nickname":"Harvey","note":"","ucode":"164D1178DA091A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52304,"discussion_content":"如果是简单的增删改查，根本就没有业务逻辑，在应用服务里就完成了，没必要一层层封装了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574037937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1398824,"avatar":"https://static001.geekbang.org/account/avatar/00/15/58/28/c86340ca.jpg","nickname":"达文西","note":"","ucode":"01C1063F23D634","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85491,"discussion_content":"松散分层架构是可以跨层调用了，实现起来很容易。但是在复杂的情况下，服务不太容易管理，比如，你可能不知道你的方法到底被谁组合和封装了，一旦出现方法变更，你不容易一次找出所有受影响方。而逐层封装的话，你只需要逐层通知到上层就可以了。     老师说到的这个就是痛点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576549594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008383,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/ff/467898a2.jpg","nickname":"Gondar","note":"","ucode":"EF23BFCDC622FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62220,"discussion_content":"是不是业务分析的比较彻底的的情况下，所有增删改查一定会对应一个业务动作。包含特定逻辑？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574824651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1084773,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8d/65/633a7478.jpg","nickname":"ANYI","note":"","ucode":"B010B0FB10E0C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008383,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/ff/467898a2.jpg","nickname":"Gondar","note":"","ucode":"EF23BFCDC622FE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":62760,"discussion_content":"一些基础数据，界面维护，就是增删改启用，像这样从页面到数据落库就没有什么逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574860645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":62220,"ip_address":""},"score":62760,"extra":""}]},{"author":{"id":1084773,"avatar":"https://static001.geekbang.org/account/avatar/00/10/8d/65/633a7478.jpg","nickname":"ANYI","note":"","ucode":"B010B0FB10E0C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53755,"discussion_content":"所以是不是简单的增删查改，就松散行，直接跨层调用；","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574213496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53087,"discussion_content":"建议还是放在领域层，但是采用松散分层架构模式，可以跨层调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574130764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151811,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1573795555,"is_pvip":false,"replies":[{"id":"58508","content":"谢谢你的建议。后面准备准备，可能需要点时间。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573907271,"ip_address":"","comment_id":151811,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23048632035","product_id":100037301,"comment_content":"1.同求代码案例。（基于一个非ddd微服务的demo，分支形式实现微服务内部代码规范，跨服务间代码重组）<br><br>2.代码案例这个成本很大，但还是厚颜无耻的提了。毕竟缺少代码这个实体，这个专栏感觉就少点东西。毕竟讲得再抽象精准，可能也没有展示code来得直接明了。<br><br>3.我们需要从实悟虚，从虚就实。如果理论能结合code案例，这个专栏的学习成本和实用性将会有质得飞跃。","like_count":5,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474622,"discussion_content":"谢谢你的建议。后面准备准备，可能需要点时间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573907271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151650,"user_name":"吴海洋","can_delete":false,"product_type":"c1","uid":1341168,"ip_address":"","ucode":"4FEACF32F07073","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJju8YSmU5veRaY6obrwTmulvK1hA8Rx4yw9OLc07U6kNSkxUyWTku7zzDFgnZb451thyicrdBuDNw/132","comment_is_top":false,"comment_ctime":1573775707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18753644891","product_id":100037301,"comment_content":"写得不错，通俗易懂。文章结构也符合我的阅读习惯。👍","like_count":4},{"had_liked":false,"id":223467,"user_name":"日月星辰","can_delete":false,"product_type":"c1","uid":1796332,"ip_address":"","ucode":"4E9F48153B2D8B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/68/ec/eb0ebbb6.jpg","comment_is_top":false,"comment_ctime":1591097643,"is_pvip":false,"replies":[{"id":"82481","content":"同一个微服务不同聚合之间为了解耦，不建议聚合之间直接调用。你可以将聚合之间的调用提升到应用层，通过应用服务来实现跨聚合的组合和调用。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591254843,"ip_address":"","comment_id":223467,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14475999531","product_id":100037301,"comment_content":"同一个微服务里不同领域之间的调用可以在应用层直接调用吗？","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497138,"discussion_content":"同一个微服务不同聚合之间为了解耦，不建议聚合之间直接调用。你可以将聚合之间的调用提升到应用层，通过应用服务来实现跨聚合的组合和调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591254843,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197335,"user_name":"Geek_deb968","can_delete":false,"product_type":"c1","uid":1440025,"ip_address":"","ucode":"2305597B009AF3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f9/19/7c3b12ee.jpg","comment_is_top":false,"comment_ctime":1585369025,"is_pvip":true,"replies":[{"id":"74592","content":"复杂的查询一般都不走领域模型，一般这种查询你可以用原来的查询设计方式，或者采用读写分离方式。在DDD领域模型中主要是基于聚合根的id的查询。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585382413,"ip_address":"","comment_id":197335,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14470270913","product_id":100037301,"comment_content":"大部分业务场景其实都是查询的比较多，关于领域模型我现在看到的和理解到的都是实体简单业务操作，我十分希望能看到关于查询在DDD上代码是怎么实现的，比如门店是一个聚合根，门店菜系设计为值对象，那么我根据菜系查询门店是不是在领域模型上很难操作了，感觉领域模型都是在实体也就是满足确定了唯一标识的情况下，才能发挥作用，动态的查询在DDD上是需要怎样实现呢","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489498,"discussion_content":"复杂的查询一般都不走领域模型，一般这种查询你可以用原来的查询设计方式，或者采用读写分离方式。在DDD领域模型中主要是基于聚合根的id的查询。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585382413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1270239,"avatar":"https://static001.geekbang.org/account/avatar/00/13/61/df/c9470e1f.jpg","nickname":"明同学","note":"","ucode":"4F0877EB8B942E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539939,"discussion_content":"复杂查询在数据中台里实现，业务域系统主要实现面向C端用户的处理和查询","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639886177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9e/b1/758f2fe7.jpg","nickname":"香","note":"","ucode":"121D6CECECEEC3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335911,"discussion_content":"去掉domain层，架子我觉得完全是可以参考的，我引入DDD更多倒不是说业务有多复杂，主要就是想着定一个规范，后续新的开发参与到项目来时，不至于把原来已经够乱的代码结构（重构前）弄得更乱。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608380143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264158,"user_name":"Peter Yu","can_delete":false,"product_type":"c1","uid":1077598,"ip_address":"","ucode":"D56786A6E85321","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg","comment_is_top":false,"comment_ctime":1606366920,"is_pvip":true,"replies":[{"id":"96485","content":"聚合之间的领域服务是不建议相互调用的，这样聚合之间会产生耦合，不利于未来领域模型演进和聚合的拆分。聚合之间有两种协作模式，一种是领域事件驱动的模式，可以实现聚合之间数据的传输，另外一种是在应用层通过应用服务来组合和协调不同聚合的领域服务，完成跨聚合的调用和操作。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1606897796,"ip_address":"","comment_id":264158,"utype":1}],"discussion_count":1,"race_medal":4,"score":"10196301512","product_id":100037301,"comment_content":"老师，aDomainService何以调用bDomainService的方法吗。比如之前有个同学提问：Corp和User属于两个领域，但是Corp中有个查询user的服务，你建议他将此方法放在domainService层，那同步user的数据时，corpDomainService岂不是得调用userDomainService了？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510445,"discussion_content":"聚合之间的领域服务是不建议相互调用的，这样聚合之间会产生耦合，不利于未来领域模型演进和聚合的拆分。聚合之间有两种协作模式，一种是领域事件驱动的模式，可以实现聚合之间数据的传输，另外一种是在应用层通过应用服务来组合和协调不同聚合的领域服务，完成跨聚合的调用和操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606897796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191355,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1390326,"ip_address":"","ucode":"527BB65559F0B0","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/f6/d65b7302.jpg","comment_is_top":false,"comment_ctime":1584765178,"is_pvip":false,"replies":[{"id":"73377","content":"一个参考是聚合中的关键实体，另外可以根据引用关系来判断，在所有具有引用关系的实体或值对象中，处于根位置的就是聚合根。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584770161,"ip_address":"","comment_id":191355,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174699770","product_id":100037301,"comment_content":"如何识别出聚合根？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488156,"discussion_content":"一个参考是聚合中的关键实体，另外可以根据引用关系来判断，在所有具有引用关系的实体或值对象中，处于根位置的就是聚合根。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584770161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156934,"user_name":"Jesen","can_delete":false,"product_type":"c1","uid":1344792,"ip_address":"","ucode":"1CD9A1D525410D","user_header":"https://static001.geekbang.org/account/avatar/00/14/85/18/9f613f78.jpg","comment_is_top":false,"comment_ctime":1574998184,"is_pvip":false,"replies":[{"id":"60351","content":"这个只是代码存放目录的考虑。具体的持久化是在仓储实现的服务里面。为了方便聚合的重新组合，我在代码目录结构里面将仓储的接口和实现都放在领域层的聚合目录下，如果微服务架构演进，你可以直接将聚合相关的代码一起拿走。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575165509,"ip_address":"","comment_id":156934,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164932776","product_id":100037301,"comment_content":"老师，如果把仓储Respository的实现放到基础设施层，其仓储接口定义在领域层里面，那么在领域层里面该怎么持久化呢，可以通过在应用层中将仓储注入到领域服务里面来实现吗？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476274,"discussion_content":"这个只是代码存放目录的考虑。具体的持久化是在仓储实现的服务里面。为了方便聚合的重新组合，我在代码目录结构里面将仓储的接口和实现都放在领域层的聚合目录下，如果微服务架构演进，你可以直接将聚合相关的代码一起拿走。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575165509,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327241,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1640003253,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5934970549","product_id":100037301,"comment_content":"这样的一个微服务设计过程，在几十万，几百万行的代码系统中，不是要维护很大很大一个映射关系吗？基本上是每一个类，每一个操作，现在的接口都是要映射成DDD对应的实体，事件模型等对应名词。","like_count":1},{"had_liked":false,"id":303274,"user_name":"Peter Yu","can_delete":false,"product_type":"c1","uid":1077598,"ip_address":"","ucode":"D56786A6E85321","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg","comment_is_top":false,"comment_ctime":1626696672,"is_pvip":true,"discussion_count":4,"race_medal":4,"score":"5921663968","product_id":100037301,"comment_content":"老师，我在ddd实际中遇到一个非常困惑的问题。我有个服务是实现代码质量分析的。现在分析数据在表里都有了，主要有一张DailyMeasure表，记录date（日期），author（开发人员），metric（度量单位：如提交数commits、有效代码行书validCodeLines、sonar问题数issues等），value（度量的值）。【相应的领域对象也是这些字段】。<br><br>现在我有一个报表功能，主要是分页展示每个用户指定日期时段内的度量数据AuthorMeasures（authorId、duplicatonLines、validCodeLines、validCommentLines、issues、commits）。这个对象没有任何业务，只要聚合DailyMeasure表的数据返回给前端即可。<br><br>按传统写法只要写个sql封装成AuthorMeasuresDto就回传给前端可以了。但按照ddd思想，还得要建do、po，然后在各个层转化一遍，多了许多刻板流程（repositoy-&gt;po-&gt;factory-&gt;do-&gt;domainSerive-&gt;applicationService-&gt;assembler-&gt;dto）。我想问的是，对于没有业务逻辑的查询，也得严格遵循ddd的代码范式吗，感觉非常冗余和臃肿。<br><br>望解惑！","like_count":1,"discussions":[{"author":{"id":1351827,"avatar":"https://static001.geekbang.org/account/avatar/00/14/a0/93/dc71b119.jpg","nickname":"欧冰","note":"","ucode":"C5DC10A65C6BBF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388328,"discussion_content":"这种主要是统计，没什么业务的项目，不适用 DDD 吧。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628696709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077598,"avatar":"https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg","nickname":"Peter Yu","note":"","ucode":"D56786A6E85321","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386147,"discussion_content":"现在实践当中，还发现一个问题：开发一个API因为涉及到每层的穿透，牵扯到修改的文件非常多，一般有15+个类被修改。这或许是ddd的弊端？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627442784,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1077598,"avatar":"https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg","nickname":"Peter Yu","note":"","ucode":"D56786A6E85321","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385385,"discussion_content":"还有一个问题，如果对于一个Do，他的dto的字段和do一样，有必要独立建一个dto吗。如果有少数不一样呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627023465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1169474,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d8/42/d4e7a136.jpg","nickname":"有思想的芦苇","note":"","ucode":"AA0B96363B1587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1077598,"avatar":"https://static001.geekbang.org/account/avatar/00/10/71/5e/5393a76d.jpg","nickname":"Peter Yu","note":"","ucode":"D56786A6E85321","race_medal":4,"user_type":1,"is_pvip":true},"discussion":{"id":403665,"discussion_content":"个人建议：绝大部分情况下po和do可以合二为一，dto和do必须分开，领域层及以下层直接使用do，应用层将do转换为dto","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1634128206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":385385,"ip_address":""},"score":403665,"extra":""}]}]},{"had_liked":false,"id":258340,"user_name":"Even He","can_delete":false,"product_type":"c1","uid":2017616,"ip_address":"","ucode":"B665039EC1112C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c9/50/5bd53d78.jpg","comment_is_top":false,"comment_ctime":1604390958,"is_pvip":false,"replies":[{"id":"94113","content":"appService是在应用层，entity的方法是在领域层，虽然它们都在同一个微服务，中间还有领域服务，因此属于从应用层到领域层的跨层调用。如果应用层直接访问entity的话，部分领域逻辑就会落到应用服务中，如果应用服务组合了多个聚合的实体，就容易使得聚合之间产生耦合，甚至直接对不同聚合实体对象的访问，会破坏领域层聚合内部的业务规则控制逻辑。记住，应用服务主要是完成服务组合和编排，以及协同的工作，基本不参与聚合内部的领域逻辑。<br>而interface中的assembler职责主要是完成对象之间的转换操作，这部分内容不涉及服务调用和业务逻辑处理。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1604457132,"ip_address":"","comment_id":258340,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5899358254","product_id":100037301,"comment_content":"老师您好。想请教一个问题。<br>例子中，遵循了严格的分层方式，即不允许跨层调用。如appService需要调用entity的方法需要通过domainService。（虽然我觉得appService调entity也不算跨层，理由是application层和domain层中间没有其他的层。）<br>那interface中的assembler，它的职责是将dto转化成domain object。这个处理如果实在interface种执行，是不是变成了跨层调用？<br>期待您的回复。谢谢。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508624,"discussion_content":"appService是在应用层，entity的方法是在领域层，虽然它们都在同一个微服务，中间还有领域服务，因此属于从应用层到领域层的跨层调用。如果应用层直接访问entity的话，部分领域逻辑就会落到应用服务中，如果应用服务组合了多个聚合的实体，就容易使得聚合之间产生耦合，甚至直接对不同聚合实体对象的访问，会破坏领域层聚合内部的业务规则控制逻辑。记住，应用服务主要是完成服务组合和编排，以及协同的工作，基本不参与聚合内部的领域逻辑。\n而interface中的assembler职责主要是完成对象之间的转换操作，这部分内容不涉及服务调用和业务逻辑处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604457132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":256556,"user_name":"一两","can_delete":false,"product_type":"c1","uid":2202383,"ip_address":"","ucode":"75CA15C28ECBCE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epK1zyWib7IKYB7icA7huf2eibCymuOCLcxK0whveSkVaOeOKfuRoDM3sFbQMicvaZyRpMgI7IKTZgYPA/132","comment_is_top":false,"comment_ctime":1603676996,"is_pvip":false,"replies":[{"id":"93391","content":"是的，仓储一般都是跟聚合是一对一的。应用层服务主要是做服务组合和编排，一般不会直接和数据打交道。但是也有特殊的情况，比如在应用层完成查询逻辑，或者跨聚合的复杂查询，而这些逻辑一般不会有领域模型的概念。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1603690750,"ip_address":"","comment_id":256556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5898644292","product_id":100037301,"comment_content":"老师，聚合或实体可以直接调用仓储接口吗？为什么网上有的说法是仓储接口应该在应用层调用，感觉应用层调用仓储接口的话，难免会把业务逻辑拆的四分五裂把","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508051,"discussion_content":"是的，仓储一般都是跟聚合是一对一的。应用层服务主要是做服务组合和编排，一般不会直接和数据打交道。但是也有特殊的情况，比如在应用层完成查询逻辑，或者跨聚合的复杂查询，而这些逻辑一般不会有领域模型的概念。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603690750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176014,"user_name":"okjesse","can_delete":false,"product_type":"c1","uid":1050510,"ip_address":"","ucode":"1CD3B09D5C1F11","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8e/307098e4.jpg","comment_is_top":false,"comment_ctime":1580911397,"is_pvip":false,"replies":[{"id":"68995","content":"领域服务只在一个聚合内，一般不建议跨聚合的领域服务调用，这样会增加聚合之间的耦合度，不利于架构演进时微服务的再次拆分。<br>领域服务只是针对一个聚合内的实体。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581494364,"ip_address":"","comment_id":176014,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5875878693","product_id":100037301,"comment_content":"【如果一个业务动作或行为跨多个实体，我们就需要设计领域服务】，请问这个实体指的是一个聚合根下面的多个实体吗。  我看例子代码也是一个聚合根会有一个领域服务，会存在一个领域服务跨多个聚合根吗。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482993,"discussion_content":"领域服务只在一个聚合内，一般不建议跨聚合的领域服务调用，这样会增加聚合之间的耦合度，不利于架构演进时微服务的再次拆分。\n领域服务只是针对一个聚合内的实体。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581494364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174615,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1580296586,"is_pvip":false,"replies":[{"id":"67917","content":"实体自身的方法来完成增删改，复杂查询可以交由应用服务来做。仓储接口可以在应用服务或者领域服务中调用，也可以是聚合根的方法里。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1580374013,"ip_address":"","comment_id":174615,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5875263882","product_id":100037301,"comment_content":"想问下实体的增删改查是由实体来做还是领域服务来做？谁来调用仓储","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482463,"discussion_content":"实体自身的方法来完成增删改，复杂查询可以交由应用服务来做。仓储接口可以在应用服务或者领域服务中调用，也可以是聚合根的方法里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580374013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168143,"user_name":"山巅最小的费马质数颗松","can_delete":false,"product_type":"c1","uid":1110194,"ip_address":"","ucode":"42D93BD9C371DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/b2/0d324d41.jpg","comment_is_top":false,"comment_ctime":1578018925,"is_pvip":false,"replies":[{"id":"65298","content":"复杂聚合用工厂来实现吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578029589,"ip_address":"","comment_id":168143,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5872986221","product_id":100037301,"comment_content":"老师，如果存储是在实体类里面调用repository，那么我们要通过spring注入这些repository，但是实体理论上是每次new出来的新对象,那么我们就不能直接用@component啥的了，因为默认是单例的，这样我们岂不是每次创建实体都得自己调用applicationcotext.getbean来得到prototype的实体，或者把这个封装成工厂，所有创建实体都走工厂?","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480151,"discussion_content":"复杂聚合用工厂来实现吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578029589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":165626,"user_name":"ZIxuAN","can_delete":false,"product_type":"c1","uid":1256455,"ip_address":"","ucode":"C04260E5E384A7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2c/07/06460a88.jpg","comment_is_top":false,"comment_ctime":1577271568,"is_pvip":false,"replies":[{"id":"63275","content":"通过工厂来完成所有关联实体的初始化。一般都在领域服务里面来调工厂和仓储完成持久化。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577359092,"ip_address":"","comment_id":165626,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5872238864","product_id":100037301,"comment_content":"老师，领域层调用仓储添加实体，是在实体里面调用还是在领域服务中调用。实体中会涉及持久化操作吗","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479236,"discussion_content":"通过工厂来完成所有关联实体的初始化。一般都在领域服务里面来调工厂和仓储完成持久化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577359092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159427,"user_name":"鱼养猫","can_delete":false,"product_type":"c1","uid":1442699,"ip_address":"","ucode":"D6C11F1360F732","user_header":"","comment_is_top":false,"comment_ctime":1575621341,"is_pvip":false,"replies":[{"id":"60934","content":"持久化是通过仓储来做。这样通过依赖倒置，可以解耦领域模型实现与数据库资源。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575625230,"ip_address":"","comment_id":159427,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870588637","product_id":100037301,"comment_content":"数据的持久化是在领域服务中还是实体中?如果持久化放在实体中,使用spring和mybatis就得把实体声明@Component 注入mapper,还得设置多例.持久化是否可以放在领域服务中去做?","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477053,"discussion_content":"持久化是通过仓储来做。这样通过依赖倒置，可以解耦领域模型实现与数据库资源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575625230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157477,"user_name":"Geek_4660f3","can_delete":false,"product_type":"c1","uid":1757482,"ip_address":"","ucode":"8B59B0C29EF88A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIMFaaIb1ZyU6zuYrT2WlD4RrsV2orxLonpIFwsx3ic01OLJ0N4dnSXQ3mFQxnbemiabKDw9810rX4Q/132","comment_is_top":false,"comment_ctime":1575172249,"is_pvip":false,"replies":[{"id":"60469","content":"聚合根由于管理了聚合内所有的实体和值对象，它的有些方法其实可以替代部分领域服务的功能。但是我建议聚合根本身的业务行为放在聚合根的方法内，聚合内的所有领域服务用一个单独的领域服务类来实现。<br>应用服务应该调用领域服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575254772,"ip_address":"","comment_id":157477,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870139545","product_id":100037301,"comment_content":"1、领域服务和聚合根是什么关系<br>2、领域服务是封装了多个实体的业务，那么领域服务是存放在聚合根内的么<br>3、应用服务是直接调用领域服务还是调用聚合根","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476439,"discussion_content":"聚合根由于管理了聚合内所有的实体和值对象，它的有些方法其实可以替代部分领域服务的功能。但是我建议聚合根本身的业务行为放在聚合根的方法内，聚合内的所有领域服务用一个单独的领域服务类来实现。\n应用服务应该调用领域服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575254772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156607,"user_name":"Jim Liao","can_delete":false,"product_type":"c1","uid":1700131,"ip_address":"","ucode":"E4E41A86EF5BF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6pWZZKvqsbgtZfqQGJAfGV9IQLZiavAOJ908IXoP3F21uRicFOVJaySIVaCokE7PSJgLcsDib0ggWiaZkwIHsYKpgQ/132","comment_is_top":false,"comment_ctime":1574921926,"is_pvip":true,"replies":[{"id":"60125","content":"不是。<br>实体完成自己的业务行为，但是聚合内有一些业务逻辑是由多个实体共同完成的。这种业务行为是跨了多个实体。比如支付订单的操作，需要对订单以及订单明细两个实体进行操作，这个行为就是一个领域服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574926205,"ip_address":"","comment_id":156607,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869889222","product_id":100037301,"comment_content":"“如果一个业务动作或行为跨多个实体，我们就需要设计领域服务”这句怎么理解？<br>这多个实体是聚合内的，还是说跨聚合的？如果是聚合内的，不是由聚合中的行为来处理吗？如果是跨聚合的，但是实体是通过聚合根访问的，是不是这句话要改为“如果一个业务动作或行为跨多个聚合，就需要设计成领域服务”","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476167,"discussion_content":"不是。\n实体完成自己的业务行为，但是聚合内有一些业务逻辑是由多个实体共同完成的。这种业务行为是跨了多个实体。比如支付订单的操作，需要对订单以及订单明细两个实体进行操作，这个行为就是一个领域服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574926205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151787,"user_name":"何沛","can_delete":false,"product_type":"c1","uid":1477145,"ip_address":"","ucode":"5673C580982710","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/19/a54761af.jpg","comment_is_top":false,"comment_ctime":1573792191,"is_pvip":false,"replies":[{"id":"58417","content":"谢谢指出，图已调整。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573801758,"ip_address":"","comment_id":151787,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868759487","product_id":100037301,"comment_content":"abcAppService{<br>      abDomainService();<br>      c.f();&#47;&#47;老师这里是不是应该调整为cDomainService();<br>}","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474616,"discussion_content":"谢谢指出，图已调整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573801758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151712,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1573780855,"is_pvip":false,"replies":[{"id":"58308","content":"如果直接对外暴露的话，建议封装一下。避免业务逻辑泄露。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573781781,"ip_address":"","comment_id":151712,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868748151","product_id":100037301,"comment_content":"领域实体的方法必须要通过领域服务封装一下吗？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474585,"discussion_content":"如果直接对外暴露的话，建议封装一下。避免业务逻辑泄露。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573781781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151705,"user_name":"AlexHuang","can_delete":false,"product_type":"c1","uid":1481439,"ip_address":"","ucode":"C359C1B9D3671A","user_header":"https://static001.geekbang.org/account/avatar/00/16/9a/df/58f07489.jpg","comment_is_top":false,"comment_ctime":1573780581,"is_pvip":false,"replies":[{"id":"58310","content":"实体的功能实现是在聚合根，其它服务只是封装和编排，服务内部不实现实体的业务逻辑，所以不会出现功能重叠的情况。有些前端可能不需要服务组合和编排，直接调用创建客户的方法，这就是跨层暴露，所以建议封装一下后，再暴露。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573782006,"ip_address":"","comment_id":151705,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5868747877","product_id":100037301,"comment_content":"老师讲的很好！<br>请教一个问题，聚合根下的方法（比如：创建个人客户信息）和领域服务中的方法（比如：创建个人客户信息）功能会不会重叠，对外暴露的场景是什么？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474581,"discussion_content":"实体的功能实现是在聚合根，其它服务只是封装和编排，服务内部不实现实体的业务逻辑，所以不会出现功能重叠的情况。有些前端可能不需要服务组合和编排，直接调用创建客户的方法，这就是跨层暴露，所以建议封装一下后，再暴露。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573782006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":189318,"discussion_content":"那如果一个前端创建用户的时候，要求添电话，一个前端要求在创建用户的时候，可以不添加电话，这个时候的逻辑判断是写在什么位置呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582869102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151701,"user_name":"盲僧","can_delete":false,"product_type":"c1","uid":1617432,"ip_address":"","ucode":"8E29CF9A3045D0","user_header":"https://static001.geekbang.org/account/avatar/00/18/ae/18/b649c2c0.jpg","comment_is_top":false,"comment_ctime":1573780206,"is_pvip":false,"replies":[{"id":"58312","content":"等我有时间的时候，我整理一个吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573782211,"ip_address":"","comment_id":151701,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868747502","product_id":100037301,"comment_content":"作者代码的地址可以发一下吗，或者给个demo","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474577,"discussion_content":"等我有时间的时候，我整理一个吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573782211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151640,"user_name":"鸭子","can_delete":false,"product_type":"c1","uid":1048496,"ip_address":"","ucode":"A973B86BEC352C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/b0/a3e19c70.jpg","comment_is_top":false,"comment_ctime":1573774026,"is_pvip":false,"replies":[{"id":"58299","content":"实体对象的方法在实体类内实现，有些领域服务只是做封装或者组合编排。<br>领域逻辑别放到应用服务中去，容易让领域模型逻辑与编排逻辑出现混乱，最后做成三层架构了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573780264,"ip_address":"","comment_id":151640,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5868741322","product_id":100037301,"comment_content":"领域服务过多会不会导致领域中的实体对象对象变成贫血模型，如果没有领域服务又很可能把领域内的逻辑放到应用服务用去，纠结。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474560,"discussion_content":"实体对象的方法在实体类内实现，有些领域服务只是做封装或者组合编排。\n领域逻辑别放到应用服务中去，容易让领域模型逻辑与编排逻辑出现混乱，最后做成三层架构了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573780264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1369756,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIopdUJmtgpsr9GibAibcZgS7h23P4FrgBfed3WveI4b4f8Vl2JjibhCzib9Y8Vs2M1PGQr7cwoKADxZQ/132","nickname":"秦道","note":"","ucode":"BE195C09BD14A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":537417,"discussion_content":"服务编排，不包括业务实现！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639057234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":474560,"ip_address":""},"score":537417,"extra":""}]}]},{"had_liked":false,"id":360544,"user_name":"A$APRocky","can_delete":false,"product_type":"c1","uid":1405947,"ip_address":"广东","ucode":"D1B5C2F8B1B67C","user_header":"https://static001.geekbang.org/account/avatar/00/15/73/fb/40164b5d.jpg","comment_is_top":false,"comment_ctime":1666625869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666625869","product_id":100037301,"comment_content":"领域事件不应该发布放在应用层感觉不是很合理，如果是某某某创建时，这个领域事件应该定义在domains层而不是应用层","like_count":0},{"had_liked":false,"id":355538,"user_name":"李志坡","can_delete":false,"product_type":"c1","uid":1445320,"ip_address":"江苏","ucode":"CCABC7E5CC5421","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/c8/fdfd768b.jpg","comment_is_top":false,"comment_ctime":1661480885,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661480885","product_id":100037301,"comment_content":"欧老师，本文章给的实例中，在应用层中，每个方法是一个类，而在最后您给的实例代码中，应用层中有多个方法放在一个类，这个中间有什么蹊跷呢？<br><br>","like_count":0},{"had_liked":false,"id":354589,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1752796,"ip_address":"上海","ucode":"7BC7539A3355DA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/be/dc/ce674e93.jpg","comment_is_top":false,"comment_ctime":1660571203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660571203","product_id":100037301,"comment_content":"Domain Service可以调用其他领域服务吗？我现在订单领域服务会调用库存领域服务做库存操作校验，之所以没放应用层是想保持下单整个业务逻辑都在领域层。<br>另外，领域服务可以依赖什么，不能依赖什么，能做什么？挺困惑的。我现在的代码里领域服务stockProcessDomainService会调用repository，因为repository负责整个aggregate的crud，所以通过repository来获取这些能力；领域服务也会使用多个aggregate，比如库存服务会依赖商品aggregate，订单aggregate，库存aggregate做库存操作的校验和更新；","like_count":0},{"had_liked":false,"id":354008,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"北京","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1660012002,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660012002","product_id":100037301,"comment_content":"“如果这个对象是多条且需要基于它做查询统计，我建议将它设计为实体。” 举的例子中的“客户证件类型”也是一个查询条件，为什么设计成为值对象？老是可以通过代码举个例子吗","like_count":0},{"had_liked":false,"id":339080,"user_name":"HePengFei","can_delete":false,"product_type":"c1","uid":2808797,"ip_address":"","ucode":"64A8F4CA31C41C","user_header":"","comment_is_top":false,"comment_ctime":1647909552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647909552","product_id":100037301,"comment_content":"从最上层一直到底层持久化，会不会充斥大量对象拷贝的代码  怎么解决","like_count":0},{"had_liked":false,"id":321170,"user_name":"赵云","can_delete":false,"product_type":"c1","uid":1376233,"ip_address":"","ucode":"FBECC7A2F4F70F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ff/e9/daebe1ea.jpg","comment_is_top":false,"comment_ctime":1636698660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636698660","product_id":100037301,"comment_content":"有点疑问，为啥service不可以直接用model里面的方法，service造出model，model再操作 有啥问题么？","like_count":0},{"had_liked":false,"id":315284,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1633785174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633785174","product_id":100037301,"comment_content":"依据DDD的架构分层，把架构分为：基础层、领域层、应用层、用户接口层。<br><br>应用DDD的思想对领域进行拆分，分析出各个领域的聚合、实体、值对象，然后分别创建值对象、实体，再结合业务对实体进行聚合，然后通过组合聚合的方式构建出领域服务对象，而应用层可以通过组合领域服务对象来构建应用服务对象。","like_count":0},{"had_liked":false,"id":302040,"user_name":"独孤九剑","can_delete":false,"product_type":"c1","uid":2230909,"ip_address":"","ucode":"6C1253E2B8C1D4","user_header":"https://static001.geekbang.org/account/avatar/00/22/0a/7d/ac715471.jpg","comment_is_top":false,"comment_ctime":1626052113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626052113","product_id":100037301,"comment_content":"针对找不到聚合根的场景，可以引入“虚拟根”的概念吗？","like_count":0},{"had_liked":false,"id":295902,"user_name":"Geek_92a994","can_delete":false,"product_type":"c1","uid":2324017,"ip_address":"","ucode":"D573E3260C0446","user_header":"","comment_is_top":false,"comment_ctime":1622635361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622635361","product_id":100037301,"comment_content":"一直没搞懂聚合根的表现形式到底是啥，只能是唯一id吗，还是能用对象作为聚合根","like_count":0},{"had_liked":false,"id":293998,"user_name":"絆","can_delete":false,"product_type":"c1","uid":1618328,"ip_address":"","ucode":"52D965461314DB","user_header":"https://static001.geekbang.org/account/avatar/00/18/b1/98/11b22d79.jpg","comment_is_top":false,"comment_ctime":1621673260,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1621673260","product_id":100037301,"comment_content":"老师为什么应用层服务根据行为写了三个XXXXPersonInfoAppSevice.java, 不是直接用PersonInfoAppSevice.java 写三个方法呢?","like_count":0,"discussions":[{"author":{"id":1369756,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIopdUJmtgpsr9GibAibcZgS7h23P4FrgBfed3WveI4b4f8Vl2JjibhCzib9Y8Vs2M1PGQr7cwoKADxZQ/132","nickname":"秦道","note":"","ucode":"BE195C09BD14A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537415,"discussion_content":"我也正要问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639057141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291874,"user_name":"[hoxing]","can_delete":false,"product_type":"c1","uid":1434363,"ip_address":"","ucode":"276CCD9A1F8151","user_header":"https://static001.geekbang.org/account/avatar/00/15/e2/fb/b8975ab0.jpg","comment_is_top":false,"comment_ctime":1620566624,"is_pvip":false,"replies":[{"id":"105718","content":"可根据需要，在前端、BFF或应用服务里面都可以。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1620645485,"ip_address":"","comment_id":291874,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1620566624","product_id":100037301,"comment_content":"我想知道，在实体对象创建的时候，一些必要参数校验放那里面做，就比如person这个实体，名字必输的校验是在构造方法里面处理还是怎么处理","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519590,"discussion_content":"可根据需要，在前端、BFF或应用服务里面都可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620645485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260809,"user_name":"金龟","can_delete":false,"product_type":"c1","uid":1228500,"ip_address":"","ucode":"1C7D35C8AE8D9D","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/d4/ff1c1319.jpg","comment_is_top":false,"comment_ctime":1605111499,"is_pvip":false,"replies":[{"id":"94753","content":"如果领域服务涉及到复杂查询，这里面有两种情况：如果这种复杂查询需要进行跨聚合的数据关联，你可以在应用服务中组合读聚合的查询服务和写聚合的领域逻辑，首先从读模型中获取查询服务，然后再执行领域服务。<br>如果这种查询是聚合内部的，直接在同一个聚合通过聚合根完成查询就可以了。所以领域服务内部可以直接组合查询服务和完成业务逻辑。<br>CQRS是一种读写分离的设计模式，跟领域模型是不同层次的概念，有关它的介绍你可以在网上查询“DDD+CQRS”了解相关情况。我过一段时间后会考虑再写一个加餐来介绍CQRS。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605169336,"ip_address":"","comment_id":260809,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605111499","product_id":100037301,"comment_content":"复杂查询不放在领域模型中 但如果我1.某个领域服务要完成某个功能必须使用复杂查询怎么办 2.意思是一个服务里面有两种模式 领域模式+cqrs模式? 3.老师能给个代码demo不","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509293,"discussion_content":"如果领域服务涉及到复杂查询，这里面有两种情况：如果这种复杂查询需要进行跨聚合的数据关联，你可以在应用服务中组合读聚合的查询服务和写聚合的领域逻辑，首先从读模型中获取查询服务，然后再执行领域服务。\n如果这种查询是聚合内部的，直接在同一个聚合通过聚合根完成查询就可以了。所以领域服务内部可以直接组合查询服务和完成业务逻辑。\nCQRS是一种读写分离的设计模式，跟领域模型是不同层次的概念，有关它的介绍你可以在网上查询“DDD+CQRS”了解相关情况。我过一段时间后会考虑再写一个加餐来介绍CQRS。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605169336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260561,"user_name":"有爱有波哥","can_delete":false,"product_type":"c1","uid":1464493,"ip_address":"","ucode":"DD9A023563151F","user_header":"https://static001.geekbang.org/account/avatar/00/16/58/ad/6abb57c4.jpg","comment_is_top":false,"comment_ctime":1605060726,"is_pvip":false,"replies":[{"id":"94616","content":"复杂查询不放在领域模型内。你可以用CQRS模型，也就是读写分离模式，将复杂的读模型分离出去，形成读和写两个不同的聚合，读模型可以面向整个微服务提供服务。这样复杂的查询就可以自由的采用SQL获取复杂的数据关联，如跨聚合查询等。读模型和写模型可以共享一个数据库，也可以采用读写数据库分离的方式来实现。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605066227,"ip_address":"","comment_id":260561,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605060726","product_id":100037301,"comment_content":"老师说的在DDD领域模型中主要是基于聚合根的id的查询，这个不理解，那复杂查询怎么设计，能给点建议和思路吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509234,"discussion_content":"复杂查询不放在领域模型内。你可以用CQRS模型，也就是读写分离模式，将复杂的读模型分离出去，形成读和写两个不同的聚合，读模型可以面向整个微服务提供服务。这样复杂的查询就可以自由的采用SQL获取复杂的数据关联，如跨聚合查询等。读模型和写模型可以共享一个数据库，也可以采用读写数据库分离的方式来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605066227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260026,"user_name":"风","can_delete":false,"product_type":"c1","uid":1077538,"ip_address":"","ucode":"104638BF19B048","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/22/b8c596b6.jpg","comment_is_top":false,"comment_ctime":1604910705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604910705","product_id":100037301,"comment_content":"从微服务系统的角度，对领域模型做深入、细致的分析，为领域对象分层，找出各个领域对象的依赖关系，建立领域对象与微服务代码对象的映射关系，从而保证领域模型与代码模型的一致性，最终完成微服务的设计。","like_count":0},{"had_liked":false,"id":249893,"user_name":"Hello.World.唐 ","can_delete":false,"product_type":"c1","uid":1127394,"ip_address":"","ucode":"DA192A1B9D4BD6","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/e2/4893dc25.jpg","comment_is_top":false,"comment_ctime":1600844712,"is_pvip":false,"replies":[{"id":"91628","content":"领域事件的发布在领域层或应用层都是可以的。比如在领域服务中业务数据保存后，马上触发一个领域事件，这个事件的处理逻辑可以放在领域服务中实现。另外，你也可以将业务逻辑做出一个领域服务，事件处理逻辑做成一个领域服务，然后在应用服务中将这两个服务进行组合完成同样的逻辑。具体选择什么样的方式，你可以根据习惯或业务复杂度来选择。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1600933764,"ip_address":"","comment_id":249893,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1600844712","product_id":100037301,"comment_content":"老师您好，有一个疑问，关于领域层里面的event。前面章节有讲过，领域事件一般统一在应用层处理，为什么在领域层还会出现event？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506050,"discussion_content":"领域事件的发布在领域层或应用层都是可以的。比如在领域服务中业务数据保存后，马上触发一个领域事件，这个事件的处理逻辑可以放在领域服务中实现。另外，你也可以将业务逻辑做出一个领域服务，事件处理逻辑做成一个领域服务，然后在应用服务中将这两个服务进行组合完成同样的逻辑。具体选择什么样的方式，你可以根据习惯或业务复杂度来选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600933764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224095,"user_name":"冷脚","can_delete":false,"product_type":"c1","uid":1101601,"ip_address":"","ucode":"C693E75F417D3C","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/21/87888b61.jpg","comment_is_top":false,"comment_ctime":1591274589,"is_pvip":false,"replies":[{"id":"82542","content":"你是两个不同的渠道应用调用同一个领域模型的微服务吗？你可以再看一下第8章《微服务架构模型：几种常见模型的对比和分析》的项目级微服务或企业级中台微服务的集成方式。<br>其实我感觉你不需要两个微服务吧，直接用一个微服务就可以支持两个不同的渠道应用，你可以用用户接口层的Facade接口来适配不同的前端应用。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591318711,"ip_address":"","comment_id":224095,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1591274589","product_id":100037301,"comment_content":"请问一下，我现在有两个微服务都会用到同一个domain领域模型，这个怎么处理呢？补充一下两个微服务分别是xxx-web和xxx-app，xxx-web是给后台管理平台调用的，xxx-app是给终端app调用的，两个微服务可能会共用多个领域模型。望老师抽空帮忙解答一下，谢谢。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497361,"discussion_content":"你是两个不同的渠道应用调用同一个领域模型的微服务吗？你可以再看一下第8章《微服务架构模型：几种常见模型的对比和分析》的项目级微服务或企业级中台微服务的集成方式。\n其实我感觉你不需要两个微服务吧，直接用一个微服务就可以支持两个不同的渠道应用，你可以用用户接口层的Facade接口来适配不同的前端应用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591318711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/21/87888b61.jpg","nickname":"冷脚","note":"","ucode":"C693E75F417D3C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279286,"discussion_content":"Xxx-web这个微服务是给web前端调用的，最终是公司运营人员使用的，里面涉及到数据统计之类的，可能占用资源比较大，怕影响到Android 和iOS终端APp 使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591319608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223473,"user_name":"日月星辰","can_delete":false,"product_type":"c1","uid":1796332,"ip_address":"","ucode":"4E9F48153B2D8B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/68/ec/eb0ebbb6.jpg","comment_is_top":false,"comment_ctime":1591098779,"is_pvip":false,"replies":[{"id":"82480","content":"还是有不少变化的，比如实体的充血模式，依赖倒置，仓储模式等等。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591254731,"ip_address":"","comment_id":223473,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591098779","product_id":100037301,"comment_content":"感觉DDD分层就是比传统三层架构多了个应用层，之前领域本身的操作和对领域的编排都在service层，现在只是分开了而已","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497139,"discussion_content":"还是有不少变化的，比如实体的充血模式，依赖倒置，仓储模式等等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591254731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211695,"user_name":"Geek_821c96","can_delete":false,"product_type":"c1","uid":1092407,"ip_address":"","ucode":"B07B528F2E12C6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ab/37/455d6a8d.jpg","comment_is_top":false,"comment_ctime":1587996230,"is_pvip":false,"replies":[{"id":"78769","content":"应用层和领域层都可以调仓储的，接口层很少会调仓储。因为接口层主要是进行服务和数据的组装的工作。它主要是调用应用服务的方式来实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1588044391,"ip_address":"","comment_id":211695,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587996230","product_id":100037301,"comment_content":"我今天看了下DDD官方给的实例代码，为何应用层，接口层都可以调用仓储啊。。。我有点晕了。求指点，谢谢！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493340,"discussion_content":"应用层和领域层都可以调仓储的，接口层很少会调仓储。因为接口层主要是进行服务和数据的组装的工作。它主要是调用应用服务的方式来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588044391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192859,"user_name":"Geek_kevin","can_delete":false,"product_type":"c1","uid":1301274,"ip_address":"","ucode":"03B0253CA59582","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/1a/30201f1a.jpg","comment_is_top":false,"comment_ctime":1584876220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584876220","product_id":100037301,"comment_content":"这节课信息量略大，需要好好消化","like_count":0},{"had_liked":false,"id":189345,"user_name":"狮锅艺","can_delete":false,"product_type":"c1","uid":1187577,"ip_address":"","ucode":"1B4AD130F9D0CA","user_header":"https://static001.geekbang.org/account/avatar/00/12/1e/f9/bfb54326.jpg","comment_is_top":false,"comment_ctime":1584503270,"is_pvip":false,"replies":[{"id":"73009","content":"全部的样例代码在加餐里面。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584510164,"ip_address":"","comment_id":189345,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584503270","product_id":100037301,"comment_content":"要是有样例代码就更好了","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487675,"discussion_content":"全部的样例代码在加餐里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584510164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181835,"user_name":"发飙的蜗牛","can_delete":false,"product_type":"c1","uid":1800868,"ip_address":"","ucode":"B2D96A2D0B6BA4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7a/a4/79ffe77c.jpg","comment_is_top":false,"comment_ctime":1582641242,"is_pvip":false,"replies":[{"id":"70575","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582769117,"ip_address":"","comment_id":181835,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582641242","product_id":100037301,"comment_content":"完成事件风暴之后，得出我们的领域模型，主要包含这些领域对象，限界上下文，聚合，聚合很，实体，值对象，验证规则，领域事件，领域服务，命令，实体依赖关系等。之后需要对这些领域对象整理归类，通过用户故事分析，用户旅程分析等对领域模型进行梳理，然后进行微服务的设计！<br>为领域对象分层，找出领域对象之间的关系，有哪些领域服务，应用服务，逐步建立领域对象和微服务代码对象的映射关系，从而保证领域模型与代码模型的一致，完成微服务的设计。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485136,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582769117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180615,"user_name":"小谢同学","can_delete":false,"product_type":"c1","uid":1032544,"ip_address":"","ucode":"E809E6BC470631","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/60/fc3689d0.jpg","comment_is_top":false,"comment_ctime":1582351465,"is_pvip":false,"replies":[{"id":"70420","content":"我这里是把领域模型里面的所有对象都成为领域对象。方法是实体的行为，在实体类里面实现，它依附于实体。领域事件是一种比较复杂的业务行为，可能会贯穿应用层和领域层。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582642503,"ip_address":"","comment_id":180615,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582351465","product_id":100037301,"comment_content":"之前讲聚合与聚合根的时候，提到一个聚合内主要包含三种领域对象，即实体、聚合根和值对象，现在又提到聚合内还包含事件与方法？这两种领域对象该如何理解？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484734,"discussion_content":"我这里是把领域模型里面的所有对象都成为领域对象。方法是实体的行为，在实体类里面实现，它依附于实体。领域事件是一种比较复杂的业务行为，可能会贯穿应用层和领域层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582642503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177086,"user_name":"赵宇浩","can_delete":false,"product_type":"c1","uid":1102850,"ip_address":"","ucode":"571C1B03858F67","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/02/ad82f59a.jpg","comment_is_top":false,"comment_ctime":1581264451,"is_pvip":false,"replies":[{"id":"68989","content":"第一个问题：如果这种复杂的批量处理的数据导入或者数据查询，没有很强的业务规则或者数据一致性要求，你可以直接在应用层通过应用服务完成批量导入或者查询就可以了，不需要经过领域层。<br>第二个问题：我理解是跨用户、地址和账户的多个聚合的事务一致性要求。你可以通过事件总线，一次修改一个聚合，其它聚合的数据修改通过领域事件机制异步处理，采用数据最终一致性的方式。或者在应用服务中处理这三个聚合数据修改时采用分布式事务处理机制也是可以的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581493658,"ip_address":"","comment_id":177086,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1581264451","product_id":100037301,"comment_content":"问题一:<br>假如用户是个复杂聚合根，同时存在List的操作一般怎么处理。<br>比如支持单用户信息创建以及批量用户信息创建。<br>单用户的实体创建包含基本信息校验和仓储写入两个步骤。<br>但批量创建不太可能循环调用每个用户的创建方法吧。<br><br>所以这样就要给用户这个类再加个基本信息校验的方法？<br>然后领域服务层，循环校验之后，再批量写入？<br><br>但这样用户这个类，就要有两个构造方法？<br>一个需要持有仓储(单用户操作)，<br>一个不需要持有仓储(用于多用户操作)？<br><br>问题二:<br>比如用户里包含了地址和账户。<br>那么仓储的事务怎么考虑，事务也由用户这个类去保证么？还是事务在领域服务里实现？<br>实现一:在用户实体里持有用户仓储，账户实体里持有账户仓储，然后用户创建的方法里，先调用账户的写入方法，再调用自己的仓储保存，如果自己存储失败，回滚？听上去好像可以实现，也符合逻辑。但是感觉这个类的每次实例初始化是不是有点麻烦。<br>实现二:实体不持有仓储，领域服务是单例的，就可以直接注入用户，账户，地址的仓储，然后只是组装内存数据，在领域服务层依次调用仓储，保证事务。也可以实现，但这样实体的责任是不是太弱了，这个领域服务层和三层架构的service层是不是有点像。<br><br>不知道实际中怎么做更推荐，望指导","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483304,"discussion_content":"第一个问题：如果这种复杂的批量处理的数据导入或者数据查询，没有很强的业务规则或者数据一致性要求，你可以直接在应用层通过应用服务完成批量导入或者查询就可以了，不需要经过领域层。\n第二个问题：我理解是跨用户、地址和账户的多个聚合的事务一致性要求。你可以通过事件总线，一次修改一个聚合，其它聚合的数据修改通过领域事件机制异步处理，采用数据最终一致性的方式。或者在应用服务中处理这三个聚合数据修改时采用分布式事务处理机制也是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581493658,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2089155,"avatar":"","nickname":"昌南一枝花","note":"","ucode":"66118BEFFDC9BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299020,"discussion_content":"我觉得第一个问题批量创建用户也应该放在实体里，第二个问题应该用实现一，用工厂模式创建","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597533188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092407,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ab/37/455d6a8d.jpg","nickname":"Geek_821c96","note":"","ucode":"B07B528F2E12C6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250009,"discussion_content":"为什么批量操作放应用层就可以了，不明白。为何不写在聚合层了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587983183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102850,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d4/02/ad82f59a.jpg","nickname":"赵宇浩","note":"","ucode":"571C1B03858F67","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165359,"discussion_content":"之所以说初始化麻烦是考虑如果是贫血模型，用户类的初始化只需要反序列化前端报文，再mapping 就行了。地址和账户信息都有了。\n但是如果每个实体都要持有仓储的话，就要序列化完，再把每个仓储给set进去？还要考虑比如账户是不是null？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581264827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164782,"user_name":"okjesse","can_delete":false,"product_type":"c1","uid":1050510,"ip_address":"","ucode":"1CD3B09D5C1F11","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8e/307098e4.jpg","comment_is_top":false,"comment_ctime":1577091123,"is_pvip":false,"replies":[{"id":"62825","content":"两个都可以的。后面的微服务样例我用的是JPA，过一段时间后我会发给大家的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1577106281,"ip_address":"","comment_id":164782,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1577091123","product_id":100037301,"comment_content":"请问你们repository使用的是jpa还是mybatis，有使用mybatis-plus吗。最好能有个代码模板。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478892,"discussion_content":"两个都可以的。后面的微服务样例我用的是JPA，过一段时间后我会发给大家的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577106281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050510,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/8e/307098e4.jpg","nickname":"okjesse","note":"","ucode":"1CD3B09D5C1F11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98276,"discussion_content":"如果是jpa的话，repository查询DO如何处理呢，貌似jpa对这个处理不太好。之前我们也使用jpa后面又换成mybatis了，但的确jpa和ddd的思想结合的更好。另外代码模板大概啥时候有啊，我们这边有个比较大的项目还想用您的这个进行实践。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577152488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161152,"user_name":"胡杨","can_delete":false,"product_type":"c1","uid":1025786,"ip_address":"","ucode":"B8EE0E3DDFCCB1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLTX00Cv4JWPAkQ9IVwicRAZYcT9TdCvlapylOy0TZhbm60V3Npr5wS8lfSI7VVyqj6NLVk2kB9QeA/132","comment_is_top":false,"comment_ctime":1576133340,"is_pvip":false,"replies":[{"id":"61509","content":"不好意思啊，没有接触过nopcommerce相关的的组件。微服务之间的领域事件大多还是通过消息中间件的模式。你说的注册和监听是不是指的微服务内部事件总线的功能，如果能实现领域事件的发布和监听，能实现不同聚合之间的解耦，我觉得应该是可以用的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576204886,"ip_address":"","comment_id":161152,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576133340","product_id":100037301,"comment_content":"DDD里的领域事件可以用类似nopcommerce框架里的继承注册监听的方式来简单实现么？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477618,"discussion_content":"不好意思啊，没有接触过nopcommerce相关的的组件。微服务之间的领域事件大多还是通过消息中间件的模式。你说的注册和监听是不是指的微服务内部事件总线的功能，如果能实现领域事件的发布和监听，能实现不同聚合之间的解耦，我觉得应该是可以用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576204886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160132,"user_name":"@倾杯","can_delete":false,"product_type":"c1","uid":1128136,"ip_address":"","ucode":"FC718A923D214F","user_header":"https://static001.geekbang.org/account/avatar/00/11/36/c8/961e6267.jpg","comment_is_top":false,"comment_ctime":1575876745,"is_pvip":false,"replies":[{"id":"61111","content":"你可以在用户接口层创建DTO类和assembler类。在assembler类里完成映射。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575886590,"ip_address":"","comment_id":160132,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575876745","product_id":100037301,"comment_content":"老师，代码模型这块我还有一点不太确定，就是dto-&gt;do这个转换方法具体是在controller中调用还是在xxAppService中调用呢？反过来do-&gt;dto方法又该是在哪个类里调用呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477267,"discussion_content":"你可以在用户接口层创建DTO类和assembler类。在assembler类里完成映射。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575886590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159428,"user_name":"鱼养猫","can_delete":false,"product_type":"c1","uid":1442699,"ip_address":"","ucode":"D6C11F1360F732","user_header":"","comment_is_top":false,"comment_ctime":1575621451,"is_pvip":false,"replies":[{"id":"60935","content":"你说的是微服务之间的服务调用，还是微服务内的应用服务或领域服务？微服务之间服务调用可以通过API网关来调用，API网关是基础层的组件。微服务内的服务调用，直接服务跨层调用就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575625425,"ip_address":"","comment_id":159428,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1575621451","product_id":100037301,"comment_content":"服务A调用服务B,是放在基础设施层吗?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477054,"discussion_content":"你说的是微服务之间的服务调用，还是微服务内的应用服务或领域服务？微服务之间服务调用可以通过API网关来调用，API网关是基础层的组件。微服务内的服务调用，直接服务跨层调用就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575625425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154187,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1574388812,"is_pvip":false,"replies":[{"id":"59197","content":"参数大部分都是实体对象。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574400240,"ip_address":"","comment_id":154187,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1574388812","product_id":100037301,"comment_content":"CreatePersonInfo这个方法，如果传入的参数太多怎么办，代码会不会不太优雅","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475399,"discussion_content":"参数大部分都是实体对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574400240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55823,"discussion_content":"Person.createPersonInfo这个传的是实体对象的话。难道Person这个实体要依赖仓储来实现创建吗。java都是用spring组件来管理bean的，如果这样的话，我要在person中用spring applicationContext去获取仓储组件。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574403232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55848,"discussion_content":"前端传过来的时候是DTO对象，在进入应用层的时候已经转换成了person的DO对象，然后person的DO对象在领域层会传到仓储接口，完成持久化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574405489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":55868,"discussion_content":"看来真得依赖，那实体干的事情就太多了，哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574407543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":55848,"ip_address":""},"score":55868,"extra":""}]}]},{"had_liked":false,"id":154185,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1574388725,"is_pvip":false,"replies":[{"id":"59204","content":"你这通过生成客户编码的领域服务，调用中间件的服务就可以吧。或者在领域服务内按照业务规则自己生成编码也可以吧。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574401298,"ip_address":"","comment_id":154185,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574388725","product_id":100037301,"comment_content":"生成客户编码这个有个问题，如果是要用到中间件生成客户编码，那这个聚合根Person不就依赖了基础层的中间件了吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475398,"discussion_content":"你这通过生成客户编码的领域服务，调用中间件的服务就可以吧。或者在领域服务内按照业务规则自己生成编码也可以吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574401298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55857,"discussion_content":"依赖是必然的，但是这种依赖是接口层面的调用依赖。而不是业务逻辑的依赖，也就是基础资源如仓储组件或者中间件以仓储接口的方式提供给实体，后端的资源逻辑实现在仓储实现里面实现。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574406018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55826,"discussion_content":"其实我想确认的是，实体是不是不应该依赖其他组件如仓储组件，其他中间件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574403768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153150,"user_name":"Geek_1c00cb","can_delete":false,"product_type":"c1","uid":1424080,"ip_address":"","ucode":"5B98BA2BBAD0DD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvnkXZiaop0haMiarN6TJTUyRtAK3NUetGBJP6MrZBmaadibWPUW1bKib4U51DyVEQkEicUNukWFTzzbQ/132","comment_is_top":false,"comment_ctime":1574168756,"is_pvip":false,"replies":[{"id":"58833","content":"这是为了聚合之间代码重组的方便，一次可以将聚合代码和仓储代码迁移走。上一节讲聚合的代码目录的时候有特别说明的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574170439,"ip_address":"","comment_id":153150,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574168756","product_id":100037301,"comment_content":"前面一直在讲仓储层的依赖反转，代码实现时怎么又放到领域里面了，是领域里面控制如何选择仓储，而不是应用层？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475061,"discussion_content":"这是为了聚合之间代码重组的方便，一次可以将聚合代码和仓储代码迁移走。上一节讲聚合的代码目录的时候有特别说明的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574170439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1424080,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvnkXZiaop0haMiarN6TJTUyRtAK3NUetGBJP6MrZBmaadibWPUW1bKib4U51DyVEQkEicUNukWFTzzbQ/132","nickname":"Geek_1c00cb","note":"","ucode":"5B98BA2BBAD0DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53472,"discussion_content":"好的，了解了，回复效率真高，感谢。不过每次重构，都是大工程，这种封装后，后面何时变回依赖倒置模式，估计比较难确定了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574171011,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153097,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1574157126,"is_pvip":false,"replies":[{"id":"58831","content":"有dto，do，po等对象，不同的层采用不同的对象。第16节会有专门介绍。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574166760,"ip_address":"","comment_id":153097,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574157126","product_id":100037301,"comment_content":"关于接口层、应用层、领域层在相互调用的时候应该采用什么形式传输呢？比如说接口层接收的参数肯定是DTO对象，那么DTO是否可以传入到下面的应用层甚至领域层呢？还是应用层和领域层都需要定义自己的传输对象？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475042,"discussion_content":"有dto，do，po等对象，不同的层采用不同的对象。第16节会有专门介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574166760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128136,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/c8/961e6267.jpg","nickname":"@倾杯","note":"","ucode":"FC718A923D214F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76992,"discussion_content":"那dto->do这个转换方法具体是在controller中调用还是在xxAppService中调用呢？反过来do->dto方法又该是在哪个类里调用呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575876659,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152647,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1574056475,"is_pvip":false,"replies":[{"id":"58665","content":"1.通过聚合根调仓储来做数据初始化。复杂的用工厂，不复杂的没必要用工厂。<br>2计算的业务逻辑一般都是核心逻辑。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574072585,"ip_address":"","comment_id":152647,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1574056475","product_id":100037301,"comment_content":"在实际操作的时候经常会碰到一个问题，加入一个领域服务内部需要创建两个聚合（或实体）完成业务操作，有几个细节的问题：<br>1、在创建这个实体的问题，是在领域服务里面把这个两个实体的大部分属性直接赋值，还是应该有工厂方法来创建实体？<br>2、关于实体封装核心业务逻辑，在这个例子里面怎么才能算核心业务逻辑呢？比如说通过单件*数量来计算金额？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474884,"discussion_content":"1.通过聚合根调仓储来做数据初始化。复杂的用工厂，不复杂的没必要用工厂。\n2计算的业务逻辑一般都是核心逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574072585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55859,"discussion_content":"聚合根调用仓储接口来实现持久化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574406562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55683,"discussion_content":"通过聚合根调仓储  -- 这句话是什么意思呢。 难道聚合根这个实体类要依赖仓储类吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574389275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152454,"user_name":"阿玛铭","can_delete":false,"product_type":"c1","uid":1100703,"ip_address":"","ucode":"DBF948D82ACBE3","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","comment_is_top":false,"comment_ctime":1574005156,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"1574005156","product_id":100037301,"comment_content":"项目正好做到这一步，记录一下：<br>应用服务对领域服务的编排和封装技巧。<br>关注应用服务的简洁性和实用性。服务api的编排有大而全、实用而精简（来自用户界面、定时任务、领域事件等触发源头的需求）两种。如果希望较低的层次更加稳定，就需要基础层（非四层模型内容）微服务提供大而全的api集合，再由较高层的微服务根据触发源的需求做编排。这里涉及业务操作数据的一致性和高层微服务的灵活性之间的权衡。大而全需要更多地引入事件总线（MQ）或者分布式事务中间件，实用而简洁会导致前台灵活性不足，进而影响平台级别的复用能力。","like_count":0,"discussions":[{"author":{"id":1063689,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","nickname":"给心来块冰块","note":"","ucode":"7AFB56581782A2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":127017,"discussion_content":"可以加个微信吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578560209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1063689,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","nickname":"给心来块冰块","note":"","ucode":"7AFB56581782A2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":141275,"discussion_content":"个人信息不方便发布到这里，看看极客时间后续的上不上私信功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579406728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":127017,"ip_address":""},"score":141275,"extra":""},{"author":{"id":1063689,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","nickname":"给心来块冰块","note":"","ucode":"7AFB56581782A2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":145191,"discussion_content":"要不你加我吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579539859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":141275,"ip_address":""},"score":145191,"extra":""},{"author":{"id":1100703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/9f/ee68858c.jpg","nickname":"阿玛铭","note":"","ucode":"DBF948D82ACBE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1063689,"avatar":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","nickname":"给心来块冰块","note":"","ucode":"7AFB56581782A2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":145582,"discussion_content":"可以啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579571751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":145191,"ip_address":""},"score":145582,"extra":""}]}]},{"had_liked":false,"id":152312,"user_name":"Geek_435a60","can_delete":false,"product_type":"c1","uid":1263925,"ip_address":"","ucode":"4FF6B2EB9F1BFA","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/35/191c9db1.jpg","comment_is_top":false,"comment_ctime":1573969110,"is_pvip":true,"replies":[{"id":"58545","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573986465,"ip_address":"","comment_id":152312,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573969110","product_id":100037301,"comment_content":"领域类，有领域异常吧？比如我有一个背包聚合，扣减背包库存的时候，可能抛出库存不够的异常，这种异常也是要定义在领域层吧？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474781,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573986465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152172,"user_name":"Todd  BD","can_delete":false,"product_type":"c1","uid":1015267,"ip_address":"","ucode":"21F27169916949","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","comment_is_top":false,"comment_ctime":1573897062,"is_pvip":false,"replies":[{"id":"58501","content":"都两个微服务了，在两个不同的项目里，要重建一个新的值对象的class的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573906041,"ip_address":"","comment_id":152172,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1573897062","product_id":100037301,"comment_content":"如果我有两个微服务， 查询场景下， 服务A需要调用服务B去获取服务B中聚合的一个值对象（Z.class）， 对于在服务A中，从服务B里拿来的这个值对象也同样是当值对象使用并绑定在服务A的一个聚合对应的DTO里， 请问服务A是否能直接使用服务B包中的Z.class，还是说需要在A服务中重新创建一个相应的Class以起到防腐层的效果？ ","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474736,"discussion_content":"都两个微服务了，在两个不同的项目里，要重建一个新的值对象的class的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573906041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015267,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/e3/ad6a4758.jpg","nickname":"Todd  BD","note":"","ucode":"21F27169916949","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51749,"discussion_content":"虽然是两个微服务 但是设计上我们会把服务的接口层的DTO抽出jar包供调用方依赖，所以服务A完全是能拿到这个值对象的类的，所以还是要新建吗？理由是什么？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573920608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53070,"discussion_content":"如果有比较多的复用考虑，是可以这样设计的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574129096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51799,"discussion_content":"两者可以做到解耦吧，B服务的类只做传输使用，比如B服务整个废弃了，换成了C服务，你需要换掉所有相关的引用，包括你的Dto里面的还有领域层里面的，当然工作量可能会多一些，需要自己再创建一个几乎一模一样的类，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573953024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152094,"user_name":"Geek_2973a9","can_delete":false,"product_type":"c1","uid":1699564,"ip_address":"","ucode":"3FFF79D6608E36","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DKLvU4DhJueYbIdV8pGQED1vAt5pIUepcvneOlABUyfeeP64SibsL5wvcpo3JJibQNTyJVDvIE5ahcCiaQuP2CxGA/132","comment_is_top":false,"comment_ctime":1573875832,"is_pvip":false,"replies":[{"id":"58469","content":"分层啦，依赖关系，领域划分，事件风暴等等，太多了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573881283,"ip_address":"","comment_id":152094,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573875832","product_id":100037301,"comment_content":"除了聚合根管理功能外，我们还可以用 DDD 的其它设计方法——请问还有哪些方法？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474714,"discussion_content":"分层啦，依赖关系，领域划分，事件风暴等等，太多了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573881283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152016,"user_name":"ZIxuAN","can_delete":false,"product_type":"c1","uid":1256455,"ip_address":"","ucode":"C04260E5E384A7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2c/07/06460a88.jpg","comment_is_top":false,"comment_ctime":1573834827,"is_pvip":false,"replies":[{"id":"58442","content":"是的，复杂的查询可以不放实体里。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573866424,"ip_address":"","comment_id":152016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573834827","product_id":100037301,"comment_content":"通俗易懂，讲的非常好。请教一下，查询是不是可以不放在实体自己去维护，实体只处理行为相关的。单独封装queryHandler去组装各种复杂查询，这是不是也符合CQRS的读写分离原则。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474688,"discussion_content":"是的，复杂的查询可以不放实体里。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573866424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152011,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":false,"comment_ctime":1573833015,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1573833015","product_id":100037301,"comment_content":"细节很多，疑问也很多，明天整理下demo和问题，再抛出来向老师请教~","like_count":0},{"had_liked":false,"id":151913,"user_name":"vincent","can_delete":false,"product_type":"c1","uid":1699893,"ip_address":"","ucode":"C6183096033397","user_header":"https://static001.geekbang.org/account/avatar/00/19/f0/35/e6f10d8d.jpg","comment_is_top":false,"comment_ctime":1573811739,"is_pvip":false,"replies":[{"id":"58607","content":"你可以看一下第6节，里面有领域事件的详细的流程介绍。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574040510,"ip_address":"","comment_id":151913,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573811739","product_id":100037301,"comment_content":"希望老师对领域事件的调用进行进一步的解答。 “客户已创建” 的领域事件是由于在创建客户的过程需要对多个尸体做持久化工作。 在上面时候 发布领域事件 怎么调用领域时间？  比如 创建一个客户时候  createPersonInfo -&gt; psersonservice - &gt; person.createperson, address.createAddress ...  在这个过程中哪里用到了领域事件？  能简单的说一下领域事件调用过程 或者 flow 吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474650,"discussion_content":"你可以看一下第6节，里面有领域事件的详细的流程介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574040510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1108505,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ea/19/14018371.jpg","nickname":"瓜瓜","note":"","ucode":"F90A5135A9BB4B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51813,"discussion_content":"提问题，用点心，老师就会给解答了，尸体这个。。。。。哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573956298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151743,"user_name":"川杰","can_delete":false,"product_type":"c1","uid":1099750,"ip_address":"","ucode":"815211E1D698E6","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/e6/11f21cb4.jpg","comment_is_top":false,"comment_ctime":1573783996,"is_pvip":false,"replies":[{"id":"58348","content":"1、客户创建事件是事件实体。不是业务实体，继承自DomainEvent，主要用于存储事件数据。<br>2、同意你的观点，它们三个服务可以放在一个领域服务类里的。如果领域服务的逻辑很复杂的话，我建议一个领域服务一个类。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573786213,"ip_address":"","comment_id":151743,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573783996","product_id":100037301,"comment_content":"请教两个问题：1、为什么客户创建事件会被设计为实体？2、创建、修改、更新个人客户信息为什么要用三个类来维护（我认为业务之间有独立性才会被分为一个类，像这三种应该属于个人客户信息维护这个业务概念的吧），如果到处都是这样的设计，不是会出现类爆炸的情况吗？<br>如果是我设计的话，我会用一个 个人客户信心维护领域服务，包含这三个方法。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474598,"discussion_content":"1、客户创建事件是事件实体。不是业务实体，继承自DomainEvent，主要用于存储事件数据。\n2、同意你的观点，它们三个服务可以放在一个领域服务类里的。如果领域服务的逻辑很复杂的话，我建议一个领域服务一个类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573786213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151703,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1573780459,"is_pvip":false,"replies":[{"id":"58311","content":"忘了说前提了，A、B、C它们是同一个聚合的哈。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573782072,"ip_address":"","comment_id":151703,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573780459","product_id":100037301,"comment_content":"领域服务不是不能夸聚合访问吗，为啥abdomainservive能访问a()","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474579,"discussion_content":"忘了说前提了，A、B、C它们是同一个聚合的哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573782072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151672,"user_name":"云中漫步","can_delete":false,"product_type":"c1","uid":1172978,"ip_address":"","ucode":"7E3BE72888E307","user_header":"https://static001.geekbang.org/account/avatar/00/11/e5/f2/262a7364.jpg","comment_is_top":false,"comment_ctime":1573778195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573778195","product_id":100037301,"comment_content":"看了例子，清晰明了。","like_count":0}]}