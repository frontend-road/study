{"id":326253,"title":"19 | 容器安全（1）：我的容器真的需要privileged权限吗?","content":"<p>你好，我是程远。从今天这一讲，我们进入到了容器安全的模块。</p><p>容器安全是一个很大的话题，容器的安全性很大程度是由容器的架构特性所决定的。比如容器与宿主机共享Linux内核，通过Namespace来做资源的隔离，通过shim/runC的方式来启动等等。</p><p>这些容器架构特性，在你选择使用容器之后，作为使用容器的用户，其实你已经没有多少能力去对架构这个层面做安全上的改动了。你可能会说用<a href=\"https://katacontainers.io/\">Kata Container</a>、<a href=\"https://gvisor.dev/\">gVisor</a> 就是安全“容器”了。不过，Kata或者gVisor只是兼容了容器接口标准，而内部的实现完全是另外的技术了。</p><p>那么对于使用容器的用户，在运行容器的时候，在安全方面可以做些什么呢？我们主要可以从这两个方面来考虑：第一是赋予容器合理的capabilities，第二是在容器中以非root用户来运行程序。</p><p>为什么是这两点呢？我通过两讲的内容和你讨论一下，这一讲我们先来看容器的capabilities的问题。</p><h2>问题再现</h2><p>刚刚使用容器的同学，往往会发现用缺省 <code>docker run</code>的方式启动容器后，在容器里很多操作都是不允许的，即使是以root用户来运行程序也不行。</p><p>我们用下面的<a href=\"https://github.com/chengyli/training/tree/main/security/capability\">例子</a>来重现一下这个问题。我们先运行<code>make image</code> 做个容器镜像，然后运行下面的脚本：</p><!-- [[[read_end]]] --><pre><code class=\"language-shell\"># docker run --name iptables -it registry/iptables:v1 bash\n[root@0b88d6486149 /]# iptables -L\niptables v1.8.4 (nf_tables): Could not fetch rule set generation id: Permission denied (you must be root)\n \n[root@0b88d6486149 /]# id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre><p>在这里，我们想在容器中运行 <code>iptables</code> 这个命令，来查看一下防火墙的规则，但是执行命令之后，你会发现结果输出中给出了\"Permission denied (you must be root)\"的错误提示，这个提示要求我们用root用户来运行。</p><p>不过在容器中，我们现在已经是以root用户来运行了，么为什么还是不可以运行\"iptables\"这条命令呢？</p><p>你肯定会想到，是不是容器中又做了别的权限限制？如果你去查一下资料，就会看到启动容器有一个\"privileged\"的参数。我们可以试一下用上这个参数，没错，我们用了这个参数之后，iptables这个命令就执行成功了。</p><pre><code class=\"language-shell\"># docker stop iptables;docker rm iptables\niptables\niptables\n# docker run --name iptables --privileged -it registry/iptables:v1 bash\n[root@44168f4b9b24 /]# iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination\n \nChain FORWARD (policy ACCEPT)\ntarget     prot opt source               destination\n \nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination\n</code></pre><p>看上去，我们用了一个配置参数就已经解决了问题，似乎很容易。不过这里我们可以进一步想想，用\"privileged\"参数来解决问题，是不是一个合理的方法呢？用它会有什么问题吗？</p><p>要回答这些问题，我们先来了解一下\"privileged\"是什么意思。从Docker的<a href=\"https://github.com/moby/moby/blob/17.03.x/daemon/exec_linux.go#L25\">代码</a>里，我们可以看到，如果配置了privileged的参数的话，就会获取所有的capabilities，那什么是capabilities呢？</p><pre><code class=\"language-shell\">            if ec.Privileged {\n                        p.Capabilities = caps.GetAllCapabilities()\n            }\n</code></pre><h2>基本概念</h2><h3>Linux capabilities</h3><p>要了解Linux capabilities的定义，我们可以先查看一下\"Linux Programmer's Manual\"中关于<a href=\"https://man7.org/linux/man-pages/man7/capabilities.7.html\">Linux capabilities</a>的描述。</p><p>在Linux capabilities出现前，进程的权限可以简单分为两类，第一类是特权用户的进程（进程的有效用户ID是0，简单来说，你可以认为它就是root用户的进程），第二类是非特权用户的进程（进程的有效用户ID是非0，可以理解为非root用户进程）。</p><p>特权用户进程可以执行Linux系统上的所有操作，而非特权用户在执行某些操作的时候就会被内核限制执行。其实这个概念，也是我们通常对Linux中root用户与非root用户的理解。</p><p>从kernel 2.2开始，Linux把特权用户所有的这些“特权”做了更详细的划分，这样被划分出来的每个单元就被称为capability。</p><p>所有的capabilities都在<a href=\"https://man7.org/linux/man-pages/man7/capabilities.7.html\">Linux capabilities</a>的手册列出来了，你也可以在内核的文件<a href=\"https://github.com/torvalds/linux/blob/v5.4/include/uapi/linux/capability.h#L113\">capability.h</a>中看到所有capabilities的定义。</p><p>对于任意一个进程，在做任意一个特权操作的时候，都需要有这个特权操作对应的capability。</p><p>比如说，运行iptables命令，对应的进程需要有CAP_NET_ADMIN这个capability。如果要mount一个文件系统，那么对应的进程需要有CAP_SYS_ADMIN这个capability。</p><p>我还要提醒你的是，CAP_SYS_ADMIN这个capability里允许了大量的特权操作，包括文件系统，交换空间，还有对各种设备的操作，以及系统调试相关的调用等等。</p><p>在普通Linux节点上，非root用户启动的进程缺省没有任何Linux capabilities，而root用户启动的进程缺省包含了所有的Linux capabilities。</p><p>我们可以做个试验，对于root用户启动的进程，如果把CAP_NET_ADMIN这个capability移除，看看它是否还可以运行iptables。</p><p>在这里我们要用到<a href=\"https://man7.org/linux/man-pages/man1/capsh.1.html\">capsh</a>这个工具，对这个工具不熟悉的同学可以查看超链接。接下来，我们就用capsh执行下面的这个命令：</p><pre><code class=\"language-shell\"># sudo /usr/sbin/capsh --keep=1 --user=root   --drop=cap_net_admin  --   -c './iptables -L;sleep 100'\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination\n \nChain FORWARD (policy ACCEPT)\ntarget     prot opt source               destination\n \nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination\niptables: Permission denied (you must be root).\n</code></pre><p>这时候，我们可以看到即使是root用户，如果把\"CAP_NET_ADMIN\"给移除了，那么在执行iptables的时候就会看到\"Permission denied (you must be root).\"的提示信息。</p><p>同时，我们可以通过/proc文件系统找到对应进程的status，这样就能确认进程中的CAP_NET_ADMIN是否已经被移除了。</p><pre><code class=\"language-shell\"># ps -ef | grep sleep\nroot     22603 22275  0 19:44 pts/1    00:00:00 sudo /usr/sbin/capsh --keep=1 --user=root --drop=cap_net_admin -- -c ./iptables -L;sleep 100\nroot     22604 22603  0 19:44 pts/1    00:00:00 /bin/bash -c ./iptables -L;sleep 100\n \n# cat /proc/22604/status | grep Cap\nCapInh:            0000000000000000\nCapPrm:          0000003fffffefff\nCapEff:             0000003fffffefff\nCapBnd:          0000003fffffefff\nCapAmb:         0000000000000000\n</code></pre><p>运行上面的命令查看 /proc/<pid>/status里Linux capabilities的相关参数之后，我们可以发现，输出结果中包含5个Cap参数。</pid></p><p>这里我给你解释一下， 对于当前进程，直接影响某个特权操作是否可以被执行的参数，是\"CapEff\"，也就是\"Effective capability sets\"，这是一个bitmap，每一个bit代表一项capability是否被打开。</p><p>在Linux内核<a href=\"https://github.com/torvalds/linux/blob/v5.4/include/uapi/linux/capability.h#L203\">capability.h</a>里把CAP_NET_ADMIN的值定义成12，所以我们可以看到\"CapEff\"的值是\"0000003fffffefff\"，第4个数值是16进制的\"e\"，而不是f。</p><p>这表示CAP_NET_ADMIN对应的第12-bit没有被置位了（0xefff = 0xffff &amp; (~(1 &lt;&lt; 12))），所以这个进程也就没有执行iptables命令的权限了。</p><p>对于进程status中其他几个capabilities相关的参数，它们还需要和应用程序文件属性中的capabilities协同工作，这样才能得到新启动的进程最终的capabilities参数的值。</p><p>我们看下面的图，结合这张图看后面的讲解：</p><p><img src=\"https://static001.geekbang.org/resource/image/90/5c/906a996776f84d8f856cc7f62589095c.jpeg?wh=1920*1080\" alt=\"\"></p><p>如果我们要新启动一个程序，在Linux里的过程就是先通过fork()来创建出一个子进程，然后调用execve()系统调用读取文件系统里的程序文件，把程序文件加载到进程的代码段中开始运行。</p><p>就像图片所描绘的那样，这个新运行的进程里的相关capabilities参数的值，是由它的父进程以及程序文件中的capabilities参数值计算得来的。</p><p>具体的计算过程你可以看<a href=\"https://man7.org/linux/man-pages/man7/capabilities.7.html\">Linux capabilities</a>的手册中的描述，也可以读一下网上的这两篇文章：</p><ul>\n<li><a href=\"https://blog.container-solutions.com/linux-capabilities-why-they-exist-and-how-they-work\">Capabilities: Why They Exist and How They Work</a></li>\n<li><a href=\"https://blog.container-solutions.com/linux-capabilities-in-practice\">Linux Capabilities in Practice</a></li>\n</ul><p>我就不对所有的进程和文件的capabilities集合参数和算法挨个做解释了，感兴趣的话你可以自己详细去看看。</p><p>这里你只要记住最重要的一点，<strong>文件中可以设置capabilities参数值，并且这个值会影响到最后运行它的进程。</strong>比如，我们如果把iptables的应用程序加上 CAP_NET_ADMIN的capability，那么即使是非root用户也有执行iptables的权限了。</p><pre><code class=\"language-shell\">$ id\nuid=1000(centos) gid=1000(centos) groups=1000(centos),10(wheel)\n$ sudo setcap cap_net_admin+ep ./iptables\n$ getcap ./iptables\n./iptables = cap_net_admin+ep\n$./iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination\n \nChain FORWARD (policy ACCEPT)\ntarget     prot opt source               destination\nDOCKER-USER  all  --  anywhere             anywhere\nDOCKER-ISOLATION-STAGE-1  all  --  anywhere             anywhere\nACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED\nDOCKER     all  --  anywhere             anywhere\nACCEPT     all  --  anywhere             anywhere\nACCEPT     all  --  anywhere             anywhere\n…\n</code></pre><p>好了，关于Linux capabilities的内容到这里我们就讲完了，其实它就是把Linux root用户原来所有的特权做了细化，可以更加细粒度地给进程赋予不同权限。</p><h2>解决问题</h2><p>我们搞懂了Linux capabilities之后，那么对privileged的容器也很容易理解了。<strong>Privileged的容器也就是允许容器中的进程可以执行所有的特权操作。</strong></p><p>因为安全方面的考虑，容器缺省启动的时候，哪怕是容器中root用户的进程，系统也只允许了15个capabilities。这个你可以查看<a href=\"https://github.com/opencontainers/runc/blob/v1.0.0-rc92/libcontainer/SPEC.md#security\">runC spec文档中的security</a> 部分，你也可以查看容器init进程status里的Cap参数，看一下容器中缺省的capabilities。</p><pre><code class=\"language-shell\"># docker run --name iptables -it registry/iptables:v1 bash\n[root@e54694652a42 /]# cat /proc/1/status  |grep Cap\nCapInh:            00000000a80425fb\nCapPrm:          00000000a80425fb\nCapEff:              00000000a80425fb\nCapBnd:          00000000a80425fb\nCapAmb:         0000000000000000\n</code></pre><p>我想提醒你，当我们发现容器中运行某个程序的权限不够的时候，并不能“偷懒”把容器设置为\"privileged\"，也就是把所有的capabilities都赋予了容器。</p><p>因为容器中的权限越高，对系统安全的威胁显然也是越大的。比如说，如果容器中的进程有了CAP_SYS_ADMIN的特权之后，那么这些进程就可以在容器里直接访问磁盘设备，直接可以读取或者修改宿主机上的所有文件了。</p><p>所以，在容器平台上是基本不允许把容器直接设置为\"privileged\"的，我们需要根据容器中进程需要的最少特权来赋予capabilities。</p><p>我们结合这一讲开始的例子来说说。在开头的例子中，容器里需要使用iptables。因为使用iptables命令，只需要设置CAP_NET_ADMIN这个capability就行。那么我们只要在运行Docker的时候，给这个容器再多加一个NET_ADMIN参数就可以了。</p><pre><code class=\"language-shell\"># docker run --name iptables --cap-add NET_ADMIN -it registry/iptables:v1 bash\n[root@cfedf124dcf1 /]# iptables -L\nChain INPUT (policy ACCEPT)\ntarget     prot opt source               destination\n \nChain FORWARD (policy ACCEPT)\ntarget     prot opt source               destination\n \nChain OUTPUT (policy ACCEPT)\ntarget     prot opt source               destination\n</code></pre><h2>重点小结</h2><p>这一讲我们主要学习了如何给容器赋予合理的capabilities。</p><p>那么，我们自然需要先来理解什么是Linux capabilities。<strong>其实Linux capabilities就是把Linux root用户原来所有的特权做了细化，可以更加细粒度地给进程赋予不同权限。</strong></p><p>对于Linux中的每一个特权操作都有一个对应的capability，对于一个capability，有的对应一个特权操作，有的可以对应很多个特权操作。</p><p>每个Linux进程有5个capabilities集合参数，其中Effective集合里的capabilities决定了当前进程可以做哪些特权操作，而其他集合参数会和应用程序文件的capabilities集合参数一起来决定新启动程序的capabilities集合参数。</p><p>对于容器的root用户，缺省只赋予了15个capabilities。如果我们发现容器中进程的权限不够，就需要分析它需要的最小capabilities集合，而不是直接赋予容器\"privileged\"。</p><p>因为\"privileged\"包含了所有的Linux capabilities, 这样\"privileged\"就可以轻易获取宿主机上的所有资源，这会对宿主机的安全产生威胁。所以，我们要根据容器中进程需要的最少特权来赋予capabilities。</p><h2>思考题</h2><p>你可以查看一下你的Linux系统里ping程序文件有哪些capabilities，看看有什么办法，能让Linux普通用户没有执行ping的能力。</p><p>欢迎你在留言区和我交流互动。如果学完这一讲让你有所收获，也欢迎转发给你的同事、或者朋友，一起交流探讨容器安全的问题。</p>","neighbors":{"left":{"article_title":"18 | 容器网络配置（3）：容器中的网络乱序包怎么这么高？","id":324357},"right":{"article_title":"20 | 容器安全（2）：在容器中，我不以root用户来运行程序可以吗？","id":327107}},"comments":[{"had_liked":false,"id":270630,"user_name":"莫名","can_delete":false,"product_type":"c1","uid":1007254,"ip_address":"","ucode":"E28F2602BA25DD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","comment_is_top":false,"comment_ctime":1609200099,"is_pvip":false,"replies":[{"id":"98235","content":"赞！","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1609249569,"ip_address":"","comment_id":270630,"utype":1}],"discussion_count":2,"race_medal":0,"score":"134753186275","product_id":100063801,"comment_content":"getcap $(which ping)<br>setcap -r $(which ping)<br><br>顺便举个之前使用过的例子：普通用户默认没有 tcpdump 抓包权限，可添加 net_raw、net_admin caps：<br>sudo setcap cap_net_raw,cap_net_admin+ep $(which tcpdump)","like_count":32,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512696,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609249569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218501,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","nickname":"罗峰","note":"","ucode":"5F3D6AF8F28322","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390746,"discussion_content":"这个是在容器内部执行吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630025151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270543,"user_name":"朱新威","can_delete":false,"product_type":"c1","uid":2326208,"ip_address":"","ucode":"50E7A6D0873853","user_header":"https://static001.geekbang.org/account/avatar/00/23/7e/c0/1c3fd7dd.jpg","comment_is_top":false,"comment_ctime":1609153422,"is_pvip":true,"replies":[{"id":"98217","content":"哈哈别慌哦，咱们后续还有专题加餐，等更新的时间里，你还可以复习已有内容哦。","user_name":"编辑回复","user_name_real":"赵宇新","uid":"1501385","ctime":1609238043,"ip_address":"","comment_id":270543,"utype":2}],"discussion_count":3,"race_medal":0,"score":"31673924494","product_id":100063801,"comment_content":"已经更新20讲了，莫名有点心慌，生怕这么好的专栏结束了🤪","like_count":7,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512664,"discussion_content":"哈哈别慌哦，咱们后续还有专题加餐，等更新的时间里，你还可以复习已有内容哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609238043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240709,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/85/59e39469.jpg","nickname":"Xianping","note":"","ucode":"108EF4AFF699C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343600,"discussion_content":"老师有没有个github 或者什么其他的联系方式？可以追逐点赞和学习的地方","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611108596,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240709,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ee/85/59e39469.jpg","nickname":"Xianping","note":"","ucode":"108EF4AFF699C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343598,"discussion_content":"真的是很好的专栏，从实用、解决问题的角度出发，毫不遮掩，毫不啰嗦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611108045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270500,"user_name":"老酒馆","can_delete":false,"product_type":"c1","uid":1737481,"ip_address":"","ucode":"6CB09E0AF29FF8","user_header":"https://static001.geekbang.org/account/avatar/00/1a/83/09/4a4b0cf2.jpg","comment_is_top":false,"comment_ctime":1609146500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18789015684","product_id":100063801,"comment_content":"getcap &#47;usr&#47;bin&#47;ping 查看ping进程当前cap<br>setcap cap_net_admin,cap_net_raw+p &#47;usr&#47;bin&#47;ping 设置ping进程cap","like_count":4},{"had_liked":false,"id":272874,"user_name":"morse","can_delete":false,"product_type":"c1","uid":1001529,"ip_address":"","ucode":"E22E5FA291B9AA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/39/4e95e7b9.jpg","comment_is_top":false,"comment_ctime":1610340793,"is_pvip":false,"replies":[{"id":"99556","content":"@morse<br>你用capsh看到的cap_net_raw 应该是在Binding Cap而不是在Effective Cap里。<br><br>ubuntu20.04 里安装的ping程序本身允许普通用户ping ICMP.<br>https:&#47;&#47;unix.stackexchange.com&#47;questions&#47;617927&#47;why-ping-works-without-capability-and-setuid","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1610940846,"ip_address":"","comment_id":272874,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10200275385","product_id":100063801,"comment_content":"老师, 您好, 我在 Ubuntu20.04 下删除 ping 的 capabilities 后, 切换别的用户后, 还是可以正常使用 ping 的, 我进行了以下操作. <br># getcap &#47;usr&#47;bin&#47;ping # 发现ping 具有cap_net_raw capability<br><br>&#47;usr&#47;bin&#47;ping = cap_net_raw+ep<br># 删除全部 capabilites<br># sudo setcap -r &#47;usr&#47;bin&#47;ping<br># 切换普通用户 sudo su - appuser<br># ping localhost # 可以正常工作<br># capsh --print -- -c &quot;&#47;bin&#47;ping -c 1 localhost&quot; #可以看到还是具有cap_net_raw<br>Current: =<br>Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read<br>....<br><br># capsh --print # 打印当前用户全部 capabilities, 发现当前用户是具有 cap_net_raw <br><br>给我的感觉, 在 Ubuntu 20.04 中, useradd appuser 创建好的用户, 初始就具有一定的 capabilites, 所以在运行程序的时候, 用户自身的 capabilities+程序的 capabliities 是最终的. 所以就算把文件的 capabilities 删除, 只要用户还具有这个能力, 那么还是可以正常执行的. <br><br>那么我的问题来了, 我没有找到, 如何对一个用户限制这种 capabilities, 即我 useradd 一个 用户, 怎么限制这个用户的 capabilities.<br>","like_count":2,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513416,"discussion_content":"@morse\n你用capsh看到的cap_net_raw 应该是在Binding Cap而不是在Effective Cap里。\n\nubuntu20.04 里安装的ping程序本身允许普通用户ping ICMP.\nhttps://unix.stackexchange.com/questions/617927/why-ping-works-without-capability-and-setuid","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610940846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315658,"user_name":"heyhd9475","can_delete":false,"product_type":"c1","uid":2682873,"ip_address":"","ucode":"3CDB4DC5BF0FEB","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eq30mvo0eATZ3Yfm5POktwic3NJSRkiagtJt1vaxyvCS22PJRm8xrulXqaLJRWQWb6zNI4zL0G2QkCA/132","comment_is_top":false,"comment_ctime":1633938219,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5928905515","product_id":100063801,"comment_content":"老师想问一下文件的capabilities是保存在什么地方呢，getcap应该也是从什么地方读取的这些信息吧，是inode,file,dentry？","like_count":1},{"had_liked":false,"id":305192,"user_name":"Christopher","can_delete":false,"product_type":"c1","uid":1757265,"ip_address":"","ucode":"1AC6035DFA4ECB","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d0/51/f1c9ae2d.jpg","comment_is_top":false,"comment_ctime":1627873033,"is_pvip":false,"replies":[{"id":"110972","content":"selinux 是通过对object, 例如进程\\文件, 打上label来控制这些object的相互作用。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1628601462,"ip_address":"","comment_id":305192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5922840329","product_id":100063801,"comment_content":"selinux是不是实际上就是限制cap权限的操作","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524310,"discussion_content":"selinux 是通过对object, 例如进程\\文件, 打上label来控制这些object的相互作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628601462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270389,"user_name":"Tony","can_delete":false,"product_type":"c1","uid":2181855,"ip_address":"","ucode":"AADFBF2D5B8005","user_header":"https://static001.geekbang.org/account/avatar/00/21/4a/df/c1eb99cf.jpg","comment_is_top":false,"comment_ctime":1609113170,"is_pvip":false,"replies":[{"id":"98237","content":"我想你问的问题是关于rootless container的？普通用户可以启动容器，但是用户权限并没有提高，非该用户的文件还是不能读写。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1609252537,"ip_address":"","comment_id":270389,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5904080466","product_id":100063801,"comment_content":"老师你好。请问在Linux中（比如centos），在允许普通用户使用docker以后，如何如何限制用户不能读取，宿主机上非该普通用户的文件？","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512604,"discussion_content":"我想你问的问题是关于rootless container的？普通用户可以启动容器，但是用户权限并没有提高，非该用户的文件还是不能读写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609252537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205253,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","nickname":"我来也","note":"","ucode":"773D6104F56767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338765,"discussion_content":"你是说非root用户加入docker用户组后,可以使用docker了. \n如何限制该用户不能读取宿主机上其他用户的文件?\n\n我觉得目前是做不到的.\n\n我刚才试了下, 非root用户使用这个命令,可以看到root用户的文件:\ndocker run --rm -it -v /:/volume busybox ls /volume/root/\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609377306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346823,"user_name":"Bill","can_delete":false,"product_type":"c1","uid":2904248,"ip_address":"","ucode":"10B70368940264","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJk3PElN2J96DtyWuIg6xPSs3zRFsIMibOvIn5kuRkESORsRIkDJMUekymI2wiaYiaP0UzibXWEl0aLYw/132","comment_is_top":false,"comment_ctime":1653460936,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1653460936","product_id":100063801,"comment_content":"Best ever","like_count":0},{"had_liked":false,"id":309625,"user_name":"罗峰","can_delete":false,"product_type":"c1","uid":1218501,"ip_address":"","ucode":"5F3D6AF8F28322","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","comment_is_top":false,"comment_ctime":1630282962,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630282962","product_id":100063801,"comment_content":"有的gpu容器需要privileged这个是啥原因呢","like_count":0},{"had_liked":false,"id":275462,"user_name":"王皓月","can_delete":false,"product_type":"c1","uid":1154968,"ip_address":"","ucode":"02F05C485968DB","user_header":"https://static001.geekbang.org/account/avatar/00/11/9f/98/b6f20c10.jpg","comment_is_top":false,"comment_ctime":1611552354,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611552354","product_id":100063801,"comment_content":"老师您好，我想要在容器中使用systemctl，除了启用特权模式还有别的办法吗？看到过大牛在docker run的时候加了&#47;sys&#47;fs&#47;cgroup:&#47;sys&#47;fs&#47;cgroup就可以在容器内使用systemctl，这个和特权模式有什么区别？","like_count":0}]}