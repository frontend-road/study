{"id":741035,"title":"第 13 章 Linux系统管理技巧(1)","content":"<h1 id=\"nav_point_243\">第 13 章 Linux系统管理技巧</h1>\n<p>阿铭在前面介绍的内容都是基础知识，如果你想成为一名合格的Linux系统管理员，要学的东西还有很多，后续章节会陆续介绍一些工作中常用的技能。只要你熟练掌握这些必备知识，那么绝对可以胜任初级管理员职位。然后你还需要继续在工作中充实自己，只要坚持学习，一两年就可以成为中高级工程师，月薪还是很可观的。</p>\n<h2 id=\"nav_point_244\">13.1 监控系统的状态</h2>\n<p>众所周知，生病了需要去医院看病，大夫首先要询问我们哪里不舒服，然后再通过观察和自己的经验，大体上就能判定我们得的是什么病。然而Linux不会说话，它不会主动告诉我们哪里出现了问题，需要我们自己去观察。那么如何评估系统运行状态是否良好呢？下面阿铭就介绍一些帮我们分析系统状态的工具。</p>\n<h3 id=\"nav_point_245\">13.1.1 使用<code>w</code>命令查看当前系统的负载</h3>\n<p>具体用法如下：</p>\n<pre class=\"code-rows\"><code># w\n22:07:15 up 74 days, 7:52, 1 user, load average: 0.00, 0.00, 0.00\nUSER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT\nroot pts/0 192.168.18.1 22:07 1.00s 0.07s 0.01s w</code></pre>\n<p>相信所有Linux管理员最常用的命令就是这个<code>w</code>了，该命令显示的信息很丰富。第1行从左至右显示的信息依次为：时间、系统运行时间、登录用户数、平均负载。从第2行开始的所有行则是告诉我们：当前登录的用户名及其登录地址等。其实在这些信息中，阿铭认为最应该关注第1行中的<code>load average:</code>后面的3个数值。</p>\n<p>第1个数值表示1分钟内系统的平均负载值，第2个数值表示5分钟内系统的平均负载值，第3个数值表示15分钟内系统的平均负载值。我们着重看第1个值，它表示单位时间段内使用CPU的活动进程数（在这里其实就是1分钟内），值越大就说明服务器压力越大。一般情况下，这个值只要不超过服务器的CPU数量就没有关系。如果服务器的CPU数量为8，那么值小于8就说明当前服务器没有压力，否则就要关注一下了。查看服务器有几个CPU的方法如下所示：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code># cat /proc/cpuinfo\nprocessor : 0\nvendor_id : GenuineIntel\ncpu family : 6\nmodel : 62\nmodel name : Intel(R) Xeon(R) CPU E5-2650 v2 @ 2.60GHz\nstepping : 4\nmicrocode : 0x427\ncpu MHz : 2600.039\ncache size : 20480 KB\nphysical id : 0\nsiblings : 1\ncore id : 0\ncpu cores : 1\napicid : 0\ninitial apicid : 0\nfpu : yes\nfpu_exception : yes\ncpuid level : 13\nwp : yes\nflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 x2apic popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cpuid_fault pti fsgsbase smep xsaveopt dtherm ida arat pln pts\nbugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf\nbogomips : 5200.07\nclflush size : 64\ncache_alignment : 64\naddress sizes : 40 bits physical, 48 bits virtual\npower management:\n\nprocessor : 1\nvendor_id : GenuineIntel\ncpu family : 6\nmodel : 62\nmodel name : Intel(R) Xeon(R) CPU E5-2650 v2 @ 2.60GHz\nstepping : 4\nmicrocode : 0x427\ncpu MHz : 2600.039\ncache size : 20480 KB\nphysical id : 2\nsiblings : 1\ncore id : 0\ncpu cores : 1\napicid : 2\ninitial apicid : 2\nfpu : yes\nfpu_exception : yes\ncpuid level : 13\nwp : yes\nflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 x2apic popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cpuid_fault pti fsgsbase smep xsaveopt dtherm ida arat pln pts\nbugs : cpu_meltdown spectre_v1 spectre_v2 spec_store_bypass l1tf\nbogomips : 5200.07\nclflush size : 64\ncache_alignment : 64\naddress sizes : 40 bits physical, 48 bits virtual\npower management:</code></pre>\n<p>上例中，/proc/cpuinfo这个文件记录了CPU的详细信息。目前市面上的服务器有很多是2颗多核CPU，在Linux看来，它就是2×<em>n</em>个CPU（这里的<em>n</em>为单颗物理CPU上有几核）。假如<em>n</em>是4，则查看这个文件时会显示8段类似的信息，而最后一段信息的<code>processor :</code>后面会显示7。所以查看当前系统有几个CPU，我们可以使用命令<code>grep -c 'processor' /proc/cpuinfo</code>。然而查看有几颗物理CPU时，则需要查看关键字<code>physical id</code>。</p>\n<p>另外一个查看CPU信息的命令为<code>lscpu</code>，如下所示：</p>\n<pre class=\"code-rows\"><code># lscpu\nArchitecture: x86_64\nCPU op-mode(s): 32-bit, 64-bit\nByte Order: Little Endian\nCPU(s): 2\nOn-line CPU(s) list: 0,1\nThread(s) per core: 1\nCore(s) per socket: 1\nSocket(s): 2\nNUMA node(s): 1\nVendor ID: GenuineIntel\nCPU family: 6\nModel: 62\nModel name: Intel(R) Xeon(R) CPU E5-2650 v2 @ 2.60GHz\nStepping: 4\nCPU MHz: 2600.039\nBogoMIPS: 5200.07\nHypervisor vendor: VMware\nVirtualization type: full\nL1d cache: 32K\nL1i cache: 32K\nL2 cache: 256K\nL3 cache: 20480K\nNUMA node0 CPU(s): 0,1\nFlags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts mmx fxsr sse sse2 ss syscall nx rdtscp lm constant_tsc arch_perfmon pebs bts nopl xtopology tsc_reliable nonstop_tsc cpuid aperfmperf pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 x2apic popcnt aes xsave avx f16c rdrand hypervisor lahf_lm cpuid_fault pti fsgsbase smep xsaveopt dtherm ida arat pln pts</code></pre>\n<h3 id=\"nav_point_246\">13.1.2 用<code>vmstat</code>命令监控系统的状态</h3>\n<p><code>vmstat</code>的具体用法如下：</p>\n<pre class=\"code-rows\"><code># vmstat\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r b swpd free buff cache si so bi bo in cs us sy id wa st\n 3 0 0 938948 4184 645672 0 0 61 128 90 182 1 1 98 0 0</code></pre>\n<p>命令<code>w</code>查看的是系统整体上的负载，通过看那个数值可以知道当前系统有没有压力，但它无法判断具体是哪里（CPU、内存、磁盘等）有压力，所以这就用到了<code>vmstat</code>。<code>vmstat</code>命令打印的结果共分为6部分：<code>procs</code>、<code>memory</code>、<code>swap</code>、<code>io</code>、<code>system</code>和<code>cpu</code>。请重点关注一下<code>r</code>、<code>b</code>、<code>si</code>、<code>so</code>、<code>bi</code>、<code>bo</code>这几列信息。</p>\n<ul>\n<li><code>procs</code>显示进程的相关信息。<ul>\n<li><strong><code>r</code></strong>（<strong>run</strong>）：表示运行或等待CPU时间片的进程数。大家不要误认为等待CPU时间片意味着进程没有运行，实际上某一时刻1个CPU只能有一个进程占用，其他进程只能排队等着，此时这些排队等待CPU资源的进程依然是运行状态。该数值如果长期大于服务器CPU的个数，则说明CPU资源不够用了。</li>\n<li><strong><code>b</code></strong>（<strong>block</strong>）：表示等待资源的进程数，这里的资源指的是I/O、内存等。举个例子，当磁盘读写非常频繁时，写数据就会非常慢，此时CPU运算很快就结束了，但进程需要把计算的结果写入磁盘，这样进程的任务才算完成，那此时这个进程只能慢慢地等待磁盘了，这样这个进程就是这个<code>b</code>状态。该数值如果长时间大于<code>1</code>，则需要关注一下了。</li>\n</ul>\n</li>\n<li><code>memory</code>显示内存的相关信息。<ul>\n<li><strong><code>swpd</code></strong>：表示切换到交换分区中的内存数量，单位为KB。</li>\n<li><strong><code>free</code></strong>：表示当前空闲的内存数量，单位为KB。</li>\n<li><strong><code>buff</code></strong>：表示（即将写入磁盘的）缓冲大小，单位为KB。</li>\n<li><strong><code>cache</code></strong>：表示（从磁盘中读取的）缓存大小，单位为KB。</li>\n</ul>\n</li>\n<li><code>swap</code>显示内存的交换情况。<ul>\n<li><strong><code>si</code></strong>：表示由交换区写入内存的数据量，单位为KB。</li>\n<li><strong><code>so</code></strong>：表示由内存写入交换区的数据量，单位为KB。</li>\n</ul>\n</li>\n<li><code>io</code>显示磁盘的使用情况。<ul>\n<li><strong><code>bi</code></strong>：表示从块设备读取数据的量（读磁盘），单位为KB。</li>\n<li><strong><code>bo</code></strong>：表示写入块设备的数据的量（写磁盘），单位为KB。</li>\n</ul>\n</li>\n<li><code>system</code>显示采集间隔内发生的中断次数。<ul>\n<li><strong><code>in</code></strong>：表示在某一时间间隔内观测到的设备每秒的中断次数。</li>\n<li><strong><code>cs</code></strong>：表示每秒产生的上下文切换次数。</li>\n</ul>\n</li>\n<li><code>cpu</code>显示CPU的使用状态。<ul>\n<li><strong><code>us</code></strong>：显示用户态下所花费CPU的时间百分比。</li>\n<li><strong><code>sy</code></strong>：显示系统花费CPU的时间百分比。</li>\n<li><strong><code>id</code></strong>：表示CPU处于空闲状态的时间百分比。</li>\n<li><strong><code>wa</code></strong>：表示I/O等待所占用CPU的时间百分比。</li>\n<li><strong><code>st</code></strong>：表示被偷走的CPU所占百分比（一般都为<code>0</code>，不用关注）。</li>\n</ul>\n</li>\n</ul>\n<p>在以上所介绍的各个参数中，阿铭经常会关注<code>r</code>、<code>b</code>和<code>wa</code>这3列。<code>io</code>部分的<code>bi</code>和<code>bo</code>也是要经常参考的对象，如果磁盘IO压力很大，则这两列的数值会比较高。另外，当<code>si</code>和<code>so</code>两列的数值比较高并且不断变化时，就说明内存不够了，内存中的数据频繁交换到交换分区中，这往往对系统性能影响极大。</p>\n<p>我们使用<code>vmstat</code>查看系统状态时，通常都是使用如下形式：</p>\n<pre class=\"code-rows\"><code># vmstat 1 5</code></pre>\n<p>或者：</p>\n<pre class=\"code-rows\"><code># vmstat 1</code></pre>\n<p>前一条命令表示每隔1秒输出一次状态，共输出5次；后一条命令表示每隔1秒输出一次状态且一直输出，除非按Ctrl+C键结束。</p>\n<h3 id=\"nav_point_247\">13.1.3 用<code>top</code>命令显示进程所占的系统资源</h3>\n<p>具体用法如下：</p>\n<pre class=\"code-rows\"><code># top\ntop - 22:28:30 up 2 days, 8:14, 1 user, load average: 0.00, 0.00, 0.00\nTasks: 154 total, 2 running, 152 sleeping, 0 stopped, 0 zombie\n%Cpu(s): 2.6 us, 7.7 sy, 0.0 ni, 87.2 id, 0.0 wa, 2.6 hi, 0.0 si, 0.0 st\nMiB Mem : 3770.4 total, 2086.4 free, 437.3 used, 1246.8 buff/cache\nMiB Swap: 4060.0 total, 4060.0 free, 0.0 used. 2893.2 avail Mem\n\n PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND\n28123 root 20 0 60948 3948 3308 R 5.6 0.1 0:00.03 top\n 1 root 20 0 246944 14540 9144 S 0.0 0.4 3:42.49 systemd\n 2 root 20 0 0 0 0 S 0.0 0.0 0:04.89 kthreadd\n 3 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_gp\n 4 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 rcu_par_gp\n 6 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 kworker/0:0H-kblockd\n 8 root 0 -20 0 0 0 I 0.0 0.0 0:00.00 mm_percpu_wq\n 9 root 20 0 0 0 0 S 0.0 0.0 31:45.82 ksoftirqd/0\n 10 root 20 0 0 0 0 R 0.0 0.0 34:36.15 rcu_sched\n 11 root rt 0 0 0 0 S 0.0 0.0 16:37.79 migration/0\n 12 root rt 0 0 0 0 S 0.0 0.0 0:45.63 watchdog/0\n 13 root 20 0 0 0 0 S 0.0 0.0 0:00.00 cpuhp/0\n 14 root 20 0 0 0 0 S 0.0 0.0 0:00.00 cpuhp/1\n 15 root rt 0 0 0 0 S 0.0 0.0 0:46.99 watchdog/1\n 16 root rt 0 0 0 0 S 0.0 0.0 14:44.19 migration/1</code></pre>\n<p><code>top</code>命令用于动态监控进程所占的系统资源，结果每隔3秒变一次。它的特点是把占用系统资源（CPU、内存、磁盘I/O等）最高的进程放到最前面。上例中，<code>top</code>命令打印出了很多信息，包括系统负载（<code>load average）</code>、进程数（<code>Tasks</code>）、CPU使用情况、内存使用情况以及交换分区使用情况。这些内容其实可以通过其他命令来查看，用<code>top</code>重点查看的还是下面的进程使用系统资源的详细状况，其中你需要关注<code>%CPU</code>、<code>%MEM</code>和<code>COMMAND</code>这几项所代表的意义。<code>RES</code>这一项为进程所占的内存大小，而<code>%MEM</code>这一项为使用内存的百分比。在<code>top</code>状态下，按Shift+M键可以按照内存使用大小排序。按数字1可以列出所有核CPU的使用状态，按Q键可以退出<code>top</code>。</p>\n<p>另外，阿铭经常用到命令<code>top -bn1</code>，它表示非动态打印系统资源的使用情况，可以用在shell脚本中。示例如下：</p>\n<pre class=\"code-rows\"><code># top -bn1 |head\ntop - 22:29:37 up 2 days, 8:15, 1 user, load average: 0.00, 0.00, 0.00\nTasks: 155 total, 1 running, 154 sleeping, 0 stopped, 0 zombie\n%Cpu(s): 0.0 us, 5.6 sy, 0.0 ni, 91.7 id, 0.0 wa, 2.8 hi, 0.0 si, 0.0 st\nMiB Mem : 3770.4 total, 2086.1 free, 437.6 used, 1246.8 buff/cache\nMiB Swap: 4060.0 total, 4060.0 free, 0.0 used. 2893.0 avail Mem\n\n PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND\n28137 root 20 0 60944 3944 3392 R 6.2 0.1 0:00.02 top\n 1 root 20 0 246944 14540 9144 S 0.0 0.4 3:42.49 systemd\n 2 root 20 0 0 0 0 S 0.0 0.0 0:04.89 kthreadd</code></pre>\n<p>和<code>top</code>命令唯一的区别就是，它一次性输出所有信息而非动态显示。</p>\n<h3 id=\"nav_point_248\">13.1.4 用<code>sar</code>命令监控系统状态</h3>\n<p><code>sar</code>命令很强大，它可以监控系统中几乎所有资源的状态，比如平均负载、网卡流量、磁盘状态、内存使用等。与其他系统状态监控工具不同，它可以打印历史信息，可以显示当天从零点开始到当前时刻的系统状态信息。如果你的系统没有安装这个命令，请使用命令<code>yum install -y sysstat</code>安装。初次使用<code>sar</code>命令时会报错，是因为<code>sar</code>工具还没有生成相应的数据库文件（无须实时监控，因为不用去查询那个库文件）。它的数据库文件在/var/log/sa/目录下。因为这个命令太复杂，所以阿铭只介绍以下两个方面。</p>\n<ol>\n<li><p><strong>查看网卡流量<code>sar -n DEV</code></strong></p>\n<p>具体用法如下：</p>\n<pre class=\"code-rows\"><code># sar -n DEV 1 5\nLinux 4.18.0-80.el8.x86_64 (localhost.localdomain) 03/03/20 _x86_64_ (2 CPU)\n\n22:31:30 IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil\n22:31:31 virbr0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n22:31:31 lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n22:31:31 ens33 1.00 1.00 0.06 0.18 0.00 0.00 0.00 0.00\n\n22:31:31 IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil\n22:31:32 virbr0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n22:31:32 lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n22:31:32 ens33 12.00 23.00 0.70 2.69 0.00 0.00 0.00 0.00\n\n22:31:32 IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil\n22:31:33 virbr0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n22:31:33 lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n22:31:33 ens33 1.00 2.00 0.06 0.71 0.00 0.00 0.00 0.00\n\n22:31:33 IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil\n22:31:34 virbr0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n22:31:34 lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n22:31:34 ens33 1.00 2.00 0.06 0.71 0.00 0.00 0.00 0.00\n\n22:31:34 IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil\n22:31:35 virbr0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n22:31:35 lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\n22:31:35 ens33 1.00 1.00 0.06 0.60 0.00 0.00 0.00 0.00\n\nAverage: IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s %ifutil\nAverage: virbr0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\nAverage: lo 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00\nAverage: ens33 3.20 5.80 0.19 0.98 0.00 0.00 0.00 0.00</code></pre>\n<p>你的结果可能和阿铭的不一样，这是因为网卡名字不一样，总之这个命令会把网卡信息打印出来，这里的<code>1 5</code>和<code>vmstat</code>用法一样，表示每隔1秒打印一次，共打印5次。<code>IFACE</code>这一列表示设备名称，<code>rxpck/s</code>这一列表示每秒收取的包的数量，<code>txpck/s</code>这一列表示每秒发送出去的包的数量，<code>rxkB/s</code>这一列表示每秒收取的数据量（单位为KB），<code>txkB/s</code>这一列表示每秒发送的数据量（后面几列不需要关注）。</p>\n<p>如果有一天服务器丢包非常严重，那么你就应该查一下网卡流量是否异常了。如果<code>rxpck/s</code>那一列的数值大于<code>4000</code>，或者<code>rxkB/s</code>那一列的数值大于<code>5000000</code>，则很有可能是被攻击了。正常的服务器网卡流量不会这么高，除非是你自己在复制数据。</p>\n<p>另外也可以使用<code>-f</code>选项查看某一天的网卡流量历史，后面跟文件名。在Red Hat或者CentOS发行版中，<code>sar</code>的库文件一定在 /var/log/sa/ 目录下，如果你刚安装syssta包，该目录下还未生成任何文件，其用法如下所示：</p>\n<pre class=\"code-rows\"><code># sar -n DEV -f /var/log/sa/sa03</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>查看历史负载<code>sar -q</code></strong></p>\n<p>具体用法如下：</p>\n<pre class=\"code-rows\"><code># sar -q\nCannot open /var/log/sa/sa03: No such file or directory</code></pre>\n<p>如果报如上错误，可以重启syssta服务，命令为<code>systemctl restart sysstat</code>。即使生成该库文件，但依然还不能正常显示结果，因为它每隔10分钟才会记录一次数据。这个命令有助于我们查看服务器在过去某个时间的负载状况。其实阿铭介绍<code>sar</code>命令，只是为了让你学会查看网卡流量（这是非常有用的）。如果你感兴趣可以<code>man</code>一下，它的用法还有很多。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_249\">13.1.5 用<code>nload</code>命令查看网卡流量</h3>\n<p><code>sar</code>虽然可以查看网卡流量，但是不够直观，还有一个更好用的工具，那就是<code>nload</code>。系统并没有默认安装它，其安装方法如下：</p>\n<pre class=\"code-rows\"><code># yum install –y epel-release; yum install –y nload</code></pre>\n<p>安装过程阿铭不再贴出来。关于上面的命令，也许你有疑问，为什么不直接写两个包呢？这是因为要想安装<code>nload</code>，前提是先安装<code>epel-release</code>包，<code>nload</code>包是在<code>epel</code>这个扩展源里面的。以后在工作中，你一定会经常使用<code>epel</code>扩展源安装一些软件包，非常方便。安装完之后，直接运行<code>nload</code>命令，然后回车就会出现如图13-1所示的界面。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100013/image00423.jpeg\" alt=\"{%}\" /></p>\n<p><strong>图13-1 <code>nload</code>命令的运行结果</strong></p>\n<p>最上面一行是网卡名字以及IP地址，按向右箭头可以查看其他网卡的网络流量。输出结果分为两部分，<code>Incoming</code>为进入网卡的流量，<code>Outgoing</code>为从网卡出去的流量，我们关注的当然是<code>Curr</code>那行的数据，其单位也可以动态自动调整，非常人性化。按Q键退出该界面。</p>\n<h3 id=\"nav_point_250\">13.1.6 用<code>free</code>命令查看内存使用状况</h3>\n<p>具体用法如下：</p>\n<pre class=\"code-rows\"><code> total used free shared buff/cache available\nMem: 1849532 230972 1346700 8852 271860 1460708\nSwap: 2097148 0 2097148</code></pre>\n<p><code>free</code>命令可以查看当前系统的总内存大小以及内存使用的情况。</p>\n<ul>\n<li><strong><code>total</code></strong>：内存总大小。</li>\n<li><strong><code>used</code></strong>：真正使用的实际内存大小。</li>\n<li><strong><code>free</code></strong>：剩余物理内存大小（没有被分配，纯剩余）。</li>\n<li><strong><code>shared</code></strong>：共享内存大小，不用关注它。</li>\n<li><strong><code>buff/cache</code></strong>：分配给<code>buffer</code>和<code>cache</code>的内存总共有多大。关于<code>buffer</code>和<code>cache</code>大家也许有一些疑惑，因为两者的字面意思很相近。阿铭教你一个容易区分这两者的方法，<code>buffer</code>和<code>cache</code>都是一部分内存，内存的作用就是缓解CPU和IO（如，磁盘）的速度差距，你可以这样理解：数据经过CPU计算，即将要写入磁盘，这时用的内存为<code>buffer</code>；CPU要计算时，需要把数据从磁盘中读出来，临时先放到内存中，这部分内存就是<code>cache</code>。</li>\n<li><strong><code>available</code></strong>：系统可使用的内存有多大，它包含了<code>free</code>。Linux系统为了让应用运行得更快，会预先分配一部分内存（<code>buffer/cache</code>）给某些应用使用，虽然这部分内存并没有真正被使用，但也已经分配出去了。然而，当另外一个服务要使用更多内存时，是可以把这部分预先分配的内存拿来用的。所以还没有被占用的这部分<code>buffer</code>和<code>cache</code>再加上<code>free</code>就是<code>available</code>。</li>\n</ul>\n<p>这个<code>free</code>命令显示的结果中，其实有一个隐藏的公式：<code>total=used+free+buff/cache</code>。另外，<code>available</code>是由<code>free</code>这部分内存和<code>buff/cache</code>还未被占用的那部分内存组成。<code>used</code>那部分内存和<code>buff/cache</code>被占用的内存是没有关系的。</p>\n<p><code>free</code>命令还可以加<code>-m</code>和<code>-g</code>选项（分别以MB和GB为单位）打印内存的使用状况，甚至还支持<code>-h</code>选项。示例命令如下：</p>\n<pre class=\"code-rows\"><code># free -m\n total used free shared buff/cache available\nMem: 1806 225 1315 8 265 1426\nSwap: 2047 0 2047\n# free -g\n total used free shared buff/cache available\nMem: 1 0 1 0 0 1\nSwap: 1 0 1\n# free -h\n total used free shared buff/cache available\nMem: 1.8Gi 225Mi 1.3Gi 8.0Mi 265Mi 1.4Gi\nSwap: 2.0Gi 0B 2.0Gi</code></pre>\n<h3 id=\"nav_point_251\">13.1.7 用<code>ps</code>命令查看系统进程</h3>\n<p>系统管理员一定要知道你所管理的系统都有哪些进程在运行，在Windows下只要打开任务管理器即可查看。那么在Linux下如何查看呢？其实使用前面介绍的<code>top</code>命令就可以，但是查看起来没有<code>ps</code>命令方便，它是专门显示系统进程的命令，如下所示：</p>\n<pre class=\"code-rows\"><code># ps aux\nUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\nroot 1 0.1 0.7 178496 13248 ? Ss 20:32 0:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 17\nroot 2 0.0 0.0 0 0 ? S 20:32 0:00 [kthreadd]\nroot 3 0.0 0.0 0 0 ? I&lt; 20:32 0:00 [rcu_gp]\nroot 4 0.0 0.0 0 0 ? I&lt; 20:32 0:00 [rcu_par_gp]\nroot 6 0.0 0.0 0 0 ? I&lt; 20:32 0:00 [kworker/0:0H-kblockd]\nroot 7 0.0 0.0 0 0 ? I 20:32 0:00 [kworker/u256:0-events_unbound]\nroot 8 0.0 0.0 0 0 ? I&lt; 20:32 0:00 [mm_percpu_wq]\nroot 9 0.0 0.0 0 0 ? S 20:32 0:00 [ksoftirqd/0]\nroot 10 0.0 0.0 0 0 ? R 20:32 0:00 [rcu_sched]\nroot 11 0.0 0.0 0 0 ? S 20:32 0:00 [migration/0]\nroot 12 0.0 0.0 0 0 ? S 20:32 0:00 [watchdog/0]\nroot 13 0.0 0.0 0 0 ? S 20:32 0:00 [cpuhp/0]\nroot 15 0.0 0.0 0 0 ? S 20:32 0:00 [kdevtmpfs]\nroot 16 0.0 0.0 0 0 ? I&lt; 20:32 0:00 [netns]\nroot 17 0.0 0.0 0 0 ? S 20:32 0:00 [kauditd]\nroot 18 0.0 0.0 0 0 ? S 20:32 0:00 [khungtaskd]\nroot 19 0.0 0.0 0 0 ? S 20:32 0:00 [oom_reaper]\nroot 20 0.0 0.0 0 0 ? I&lt; 20:32 0:00 [writeback]\nroot 21 0.0 0.0 0 0 ? S 20:32 0:00 [kcompactd0]\nroot 22 0.0 0.0 0 0 ? SN 20:32 0:00 [ksmd]\nroot 23 0.0 0.0 0 0 ? SN 20:32 0:00 [khugepaged]\nroot 24 0.0 0.0 0 0 ? I&lt; 20:32 0:00 [crypto]\nroot 25 0.0 0.0 0 0 ? I&lt; 20:32 0:00 [kintegrityd]</code></pre>\n<p>阿铭也经常看到有人喜欢用命令<code>ps -elf</code>，但它们显示的信息基本上是一样的。<code>ps</code>命令还有更多的用法，你只要会用这个命令就足够了。下面介绍几个系统进程的参数。</p>\n<ul>\n<li><strong><code>PID</code></strong>：表示进程的ID，这个ID很有用。在Linux中，内核管理进程就得靠<code>PID</code>来识别和管理某一个进程。比如我想终止某一个进程，则用命令“<code>kill 进程的PID</code>”。有时这样并不能终止进程，需要加<code>-9</code>选项，即“<code>kill -9 进程的PID</code>”，但这样有点暴力，严重的时候会丢数据，所以尽量还是别用。</li>\n<li><strong><code>STAT</code></strong>：进程的状态。进程状态分为以下几种（不要求记住，但要了解）。<ul>\n<li><strong><code>D</code></strong>：不能中断的进程（通常为IO）。</li>\n<li><strong><code>R</code>（run）</strong>：正在运行中的进程，其中包括等待CPU时间片的进程。</li>\n<li><strong><code>S</code>（sleep）</strong>：已经中断的进程。通常情况下，系统的大部分进程处于这个状态。</li>\n<li><strong><code>T</code></strong>：已经停止或者暂停的进程。如果我们正在运行一个命令，比如说<code>sleep 10</code>，我们按一下Ctrl+Z暂停进程时，用<code>ps</code>命令查看就会显示<code>T</code>这个状态。</li>\n<li><strong><code>W</code></strong>：（内核2.6xx以后不可用），没有足够的内存页分配给进程。</li>\n<li><strong><code>X</code></strong>：已经死掉的进程（这个好像从来不会出现）。</li>\n<li><strong><code>Z</code></strong>：僵尸进程，即杀不掉、打不死的垃圾进程，不过没有关系，因为一般只占用系统一点资源。如果占用太多（一般不会出现），就需要重视了。</li>\n<li><strong><code>&lt;</code></strong>：高优先级进程。</li>\n<li><strong><code>N</code></strong>：低优先级进程。</li>\n<li><strong><code>L</code></strong>：该进程有内存分页被锁。</li>\n<li><strong><code>s</code></strong>：主进程，后面阿铭讲到Nginx或者<code>php-fpm</code>服务的时候，你就能更好地理解它了。</li>\n<li><strong><code>l</code></strong>：多线程进程。</li>\n<li><strong><code>+</code></strong>：在前台运行的进程，比如在当前终端执行的<code>ps aux</code>就是前台进程。</li>\n</ul>\n</li>\n</ul>\n<p><code>ps</code>命令是阿铭在工作中用得非常多的一个命令，所以请记住它。阿铭经常会将<code>ps</code>连同管道符一起使用，用来查看某个进程或者进程的数量。示例命令如下：</p>\n<pre class=\"code-rows\"><code># ps aux |grep -c sshd\n4\n# ps aux |grep sshd\nroot 814 0.0 0.3 92304 6648 ? Ss 20:33 0:00 /usr/sbin/sshd -D -oCiphers=aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes256-ctr,aes256-cbc,aes128-gcm@openssh.com,aes128-ctr,aes128-cbc -oMACs=hmac-sha2-256-etm@openssh.com,hmac-sha1-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,hmac-sha1,umac-128@openssh.com,hmac-sha2-512 -oGSSAPIKexAlgorithms=gss-gex-sha1-,gss-group14-sha1- -oKexAlgorithms=curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1 -oHostKeyAlgorithms=rsa-sha2-256,rsa-sha2-256-cert-v01@openssh.com,ecdsa-sha2-nistp256,ecdsa-sha2-nistp256-cert-v01@openssh.com,ecdsa-sha2-nistp384,ecdsa-sha2-nistp384-cert-v01@openssh.com,rsa-sha2-512,rsa-sha2-512-cert-v01@openssh.com,ecdsa-sha2-nistp521,ecdsa-sha2-nistp521-cert-v01@openssh.com,ssh-ed25519,ssh-ed25519-cert-v01@openssh.com,ssh-rsa,ssh-rsa-cert-v01@openssh.com -oPubkeyAcceptedKeyTypes=rsa-sha2-256,rsa-sha2-256-cert-v01@openssh.com,ecdsa-sha2-nistp256,ecdsa-sha2-nistp256-cert-v01@openssh.com,ecdsa-sha2-nistp384,ecdsa-sha2-nistp384-cert-v01@openssh.com,rsa-sha2-512,rsa-sha2-512-cert-v01@openssh.com,ecdsa-sha2-nistp521,ecdsa-sha2-nistp521-cert-v01@openssh.com,ssh-ed25519,ssh-ed25519-cert-v01@openssh.com,ssh-rsa,ssh-rsa-cert-v01@openssh.com -oCASignatureAlgorithms=rsa-sha2-256,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,rsa-sha2-512,ecdsa-sha2-nistp521,ssh-ed25519,ssh-rsa\nroot 1709 0.0 0.5 151200 9368 ? Ss 20:54 0:00 sshd: root [priv]\nroot 1713 0.0 0.2 151200 5300 ? S 20:54 0:00 sshd: root@pts/0\nroot 1745 0.0 0.0 12320 1080 pts/0 R+ 20:57 0:00 grep --color=auto sshd</code></pre>\n<p>上例中的<code>4</code>不准确，需要减掉<code>1</code>。因为使用<code>grep</code>命令时，<code>grep</code>命令本身也算一个进程。</p>\n<h3 id=\"nav_point_252\">13.1.8 用<code>netstat</code>命令查看网络状况</h3>\n<p>具体用法如下：</p>\n<pre class=\"code-rows\"><code># netstat -lnp\nActive Internet connections (only servers)\nProto Recv-Q Send-Q Local Address Foreign Address State PID/Program name\ntcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 814/sshd\ntcp6 0 0 :::22 :::* LISTEN 814/sshd\nudp 0 0 0.0.0.0:68 0.0.0.0:* 1648/dhclient\nudp 0 0 127.0.0.1:323 0.0.0.0:* 766/chronyd\nudp6 0 0 ::1:323 :::* 766/chronyd\nraw6 0 0 :::58 :::* 7 796/NetworkManager\nActive UNIX domain sockets (only servers)\nProto RefCnt Flags Type State I-Node PID/Program name Path\nunix 2 [ ACC ] SEQPACKET LISTENING 21770 1/systemd /run/systemd/coredump\nunix 2 [ ACC ] STREAM LISTENING 25846 783/sssd_nss /var/lib/sss/pipes/nss\nunix 2 [ ACC ] SEQPACKET LISTENING 21557 1/systemd /run/udev/control\nunix 2 [ ACC ] STREAM LISTENING 24964 1/systemd /var/run/.heim_org.h5l.kcm-socket\nunix 2 [ ACC ] STREAM LISTENING 24966 1/systemd /run/dbus/system_bus_socket\nunix 2 [ ACC ] STREAM LISTENING 12679 1/systemd /run/systemd/journal/stdout\nunix 2 [ ACC ] STREAM LISTENING 32410 1496/systemd /run/user/0/systemd/private\nunix 2 [ ACC ] STREAM LISTENING 32419 1496/systemd /run/user/0/bus\nunix 2 [ ACC ] STREAM LISTENING 25795 763/sssd /var/lib/sss/pipes/private/\n sbus-monitor\nunix 2 [ ACC ] STREAM LISTENING 25816 780/sssd_be /var/lib/sss/pipes/private/\n sbus-dp_implicit_files.780\nunix 2 [ ACC ] STREAM LISTENING 25804 761/VGAuthService /var/run/vmware/guestServicePipe\nunix 2 [ ACC ] STREAM LISTENING 21476 1/systemd /run/systemd/private\nActive Bluetooth connections (only servers)\nProto Destination Source State PSM DCID SCID IMTU OMTU Security\nProto Destination Source State Channel</code></pre>\n<p>若没有此命令，请使用<code>yum install net-tools</code>安装。由于书本页面有限，显示的字符已经换行，看起来有点乱。显示的结果中，上面那一部分是<code>tcp/ip</code>，下面一部分是监听的socket（<code>unix</code>开头的行）。<code>netstat</code>命令用来打印网络连接状况、系统所开放端口、路由表等信息。阿铭最常用的两种用法是<code>netstat -lnp</code>（打印当前系统启动有哪些端口）和<code>netstat -an</code>（打印网络连接状况），它们非常有用，请一定要记住。示例如下：</p>\n<pre class=\"code-rows\"><code># netstat -an |head -n 20 // 为了节省空间，只显示前20行\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address Foreign Address State\ntcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN\ntcp 0 52 192.168.72.128:22 192.168.72.1:52219 ESTABLISHED\ntcp6 0 0 :::22 :::* LISTEN\nudp 0 0 0.0.0.0:68 0.0.0.0:*\nudp 0 0 127.0.0.1:323 0.0.0.0:*\nudp6 0 0 ::1:323 :::*\nraw6 0 0 :::58 :::* 7\nActive UNIX domain sockets (servers and established)\nProto RefCnt Flags Type State I-Node Path\nunix 2 [ ACC ] SEQPACKET LISTENING 21770 /run/systemd/coredump\nunix 2 [ ACC ] STREAM LISTENING 25846 /var/lib/sss/pipes/nss\nunix 2 [ ACC ] SEQPACKET LISTENING 21557 /run/udev/control\nunix 3 [ ] DGRAM 12656 /run/systemd/notify\nunix 2 [ ] DGRAM 12658 /run/systemd/cgroups-agent\nunix 12 [ ] DGRAM 12670 /run/systemd/journal/dev-log\nunix 2 [ ] DGRAM 25475 /var/run/chrony/chronyd.sock\nunix 2 [ ACC ] STREAM LISTENING 24964 /var/run/.heim_org.h5l.kcm-socket\nunix 2 [ ACC ] STREAM LISTENING 24966 /run/dbus/system_bus_socket</code></pre>\n<p>最右侧为网络连接的状态，如果你对TCP三次握手比较熟悉，那么应该不会对最后这一列的字符串感到陌生。如果你管理是一台提供Web服务（80端口）的服务器，那么就可以使用命令<code>netstat -an |grep 80</code>来查看当前连接Web服务的有哪些IP了。</p>\n<h2 id=\"nav_point_253\">13.2 抓包工具</h2>\n<p>有时你也许想看一下某个网卡上都有哪些数据包，尤其是当你初步判定服务器上有流量攻击时，使用抓包工具来抓取数据包就可以知道有哪些IP在攻击了。</p>\n<h3 id=\"nav_point_254\">13.2.1 tcpdump工具</h3>\n<p>具体用法如下：</p>\n<pre class=\"code-rows\"><code># tcpdump -nn -i ens33\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes\n09:41:46.647812 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 3649233742:3649233954, ack 443629343, win 251, length 212\n09:41:46.647976 IP 192.168.72.1.52219 &gt; 192.168.72.128.22: Flags [.], ack 212, win 253, length 0\n09:41:46.648337 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 212:504, ack 1, win 251, length 292\n09:41:46.648493 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 504:668, ack 1, win 251, length 164\n09:41:46.648562 IP 192.168.72.1.52219 &gt; 192.168.72.128.22: Flags [.], ack 668, win 252, length 0\n09:41:46.648651 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 668:928, ack 1, win 251, length 260\n09:41:46.648744 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 928:1092, ack 1, win 251, length 164\n09:41:46.648800 IP 192.168.72.1.52219 &gt; 192.168.72.128.22: Flags [.], ack 1092, win 256, length 0\n09:41:46.648875 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 1092:1368, ack 1, win 251, length 276\n09:41:46.648978 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 1368:1532, ack 1, win 251, length 164\n09:41:46.649035 IP 192.168.72.1.52219 &gt; 192.168.72.128.22: Flags [.], ack 1532, win 254, length 0\n09:41:46.649128 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 1532:1808, ack 1, win 251, length 276\n09:41:46.649206 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 1808:1972, ack 1, win 251, length 164\n09:41:46.649297 IP 192.168.72.1.52219 &gt; 192.168.72.128.22: Flags [.], ack 1972, win 253, length 0\n09:41:46.649433 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 1972:2248, ack 1, win 251, length 276\n09:41:46.649531 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 2248:2412, ack 1, win 251, length 164\n09:41:46.649591 IP 192.168.72.1.52219 &gt; 192.168.72.128.22: Flags [.], ack 2412, win 251, length 0\n09:41:46.649675 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 2412:2688, ack 1, win 251, length 276\n09:41:46.649760 IP 192.168.72.128.22 &gt; 192.168.72.1.52219: Flags [P.], seq 2688:2852, ack 1, win 251, length 164\n09:41:46.649809 IP 192.168.72.1.52219 &gt; 192.168.72.128.22: Flags [.], ack 2852, win 256, length 0</code></pre>\n<p>回车后会出现密密麻麻的一堆字符串，在按Ctrl+C组合键之前，这些字符串一直在刷屏，刷屏越快说明网卡上的数据包越多。如果没有<code>tcpdump</code>命令，需要使用命令<code>yum install -y tcpdump</code>安装。上例中，我们只需要关注第3列和第4列，它们显示的信息是哪一个IP+端口号在连接哪一个IP+端口号。后面的信息是该数据包的相关信息，如果不懂也没有关系。</p>\n<p><code>-i</code>选项后面跟设备名称，如果想抓取其他网卡的数据包，后面则要跟其他网卡的名字。<code>-nn</code>选项的作用是让第3列和第4列显示成“IP+端口号”的形式，如果不加<code>-nn</code>选项则显示 “主机名+服务名称”。</p>\n<p>阿铭在shell脚本中也经常会用到<code>tcpdump</code>命令。你可能会问，shell脚本是自动执行的，那我们如何按快捷键Ctrl+C结束抓包呢？<code>tcpdump</code>还有其他的选项可以使用。</p>\n<pre class=\"code-rows\"><code># tcpdump -nn -i ens33 -c 100</code></pre>\n<p><code>-c</code>的作用是指定抓包数量，抓够了就自动退出，不用我们人为取消。阿铭再给大家列几个常用的示例：</p>\n<pre class=\"code-rows\"><code># tcpdump -nn -i ens33 port 22 // 这样指定只抓22端口的包\n# tcpdump –nn –i ens33 tcp and not port 22 // 指定抓tcp的包，但是不要22端口的\n# tcpdump –nn –i ens33 port 22 and port 53 // 只抓22和53端口的包</code></pre>\n<h3 id=\"nav_point_255\">13.2.2 wireshark工具</h3>\n<p>也许你在Windows下使用过wireshark这个抓包工具，它的功能非常强大。在Linux平台我们同样也可以使用它，只不过是以命令行的形式。wireshark的具体选项阿铭不再详细介绍，在日常工作中，<code>tcpdump</code>其实就已经够我们使用了。下面的用法是阿铭在工作中使用比较多的，希望你能掌握这些用法：</p>\n<pre class=\"code-rows\"><code># tshark -n -t a -R http.request -T fields -e \"frame.time\" -e \"ip.src\" -e \"http.host\" -e \"http.request.method\" -e \"http.request.uri\"</code></pre>\n<p>我们要执行的命令是<code>tshark</code>，你的CentOS默认是没有这个命令的，请使用如下命令安装：</p>\n<pre class=\"code-rows\"><code># yum install -y wireshark</code></pre>\n<p>然后再看看上面的抓包命令<code>tshark</code>，这条命令用于Web服务器，可以显示如下信息：</p>\n<pre class=\"code-rows\"><code>Jun 26, 2020 09:11:44.017592529 CST\" 116.179.32.105 ask.apelearn.com\nGET /question/96924473532</code></pre>\n<p>这类似于Web访问日志。若服务器没有配置访问日志，可以临时使用该命令查看一下当前服务器上的Web请求。在这里要注意的是，如果你的机器上没有开启Web服务，是不会显示任何内容的。</p>\n<pre class=\"code-rows\"><code># tshark -n -i eth1 -R 'mysql.query' -T fields -e \"ip.src\" -e \"mysql.query\"</code></pre>\n<p>上面的命令会抓取eth1网卡<code>mysql</code>的查询都有哪些，不过这种方法仅仅适用于<code>mysql</code>的端口为3306的情况，如果不是3306，请使用下面的方法：</p>\n<pre class=\"code-rows\"><code>// 这是一行命令，并非换行\n# tshark -i eth1 port 3307 -d tcp.port==3307,mysql -z \"proto,colinfo,mysql.query,mysql.query\"</code></pre>\n<h2 id=\"nav_point_256\">13.3 Linux网络相关</h2>\n<p>其实，Linux的网络知识挺多的，阿铭在本节只把常用的一些技能教给大家。比如，如何设置IP、如何设置主机名、如何设置DNS等。</p>\n<h3 id=\"nav_point_257\">13.3.1 用<code>ifconfig</code>命令查看网卡IP</h3>\n<p>前面阿铭曾用<code>ip addr</code>这个命令来查看过系统的IP地址。其实在CentOS 7之前，我们使用最多的命令是<code>ifconfig</code>，它类似于Windows的<code>ipconfig</code>命令，后面不加任何选项和参数时，只打印当前网卡IP的相关信息（如子网掩码、网关等）。在Windows下设置IP非常简单，然而在命令窗口下如何设置呢？这就需要修改配置文件 /etc/sysconfig/network-scripts/ifcfg-xxx了，这里的xxx指的是网卡的名字，可以使用<code>ip addr</code>命令查看所有网卡。如果你的系统里没有<code>ifconfig</code>命令，可以使用<code>yum install -y net-tools</code>安装。</p>\n<p>如果Linux上有多个网卡，而你只想重启某一个网卡的话，可以使用如下命令：</p>\n<pre class=\"code-rows\"><code># ifdown ens33; ifup ens33</code></pre>\n<p><code>ifdown</code>即停用网卡，<code>ifup</code>即启动网卡。需要大家注意的是，如果我们远程登录服务器，当使用命令<code>ifdown ens33</code>时，很有可能后面的命令<code>ifup ens33</code>并不会运行。这样会导致我们断网而无法连接服务器，所以请尽量使用命令<code>systemctl restart network</code>来重启网卡。或者使用<code>nmcli</code>也可以实现同样的效果：</p>\n<pre class=\"code-rows\"><code># nmcli c down ens33; nmcli c up ens33</code></pre>\n<h3 id=\"nav_point_258\">13.3.2 给一个网卡设定多个IP</h3>\n<p>在Linux系统中，网卡是可以设定多重IP的，阿铭就曾经为一台服务器的网卡设定了5个IP。多重IP的设置过程如下：</p>\n<pre class=\"code-rows\"><code># cd /etc/sysconfig/network-scripts/\n# cp ifcfg-ens33 ifcfg-ens33:1</code></pre>\n<p>然后编辑ifcfg-ens33:1这个配置文件。一定要注意<code>DEVICE</code>要写成<code>ens33:1</code>，如下所示：</p>\n<pre class=\"code-rows\"><code># vi ifcfg-ens33:1 // 编辑为类似如下内容\nTYPE=\"Ethernet\"\nPROXY_METHOD=\"none\"\nBROWSER_ONLY=\"no\"\nBOOTPROTO=\"static\"\nDEFROUTE=\"yes\"\nIPV4_FAILURE_FATAL=\"no\"\nIPV6INIT=\"yes\"\nIPV6_AUTOCONF=\"yes\"\nIPV6_DEFROUTE=\"yes\"\nIPV6_FAILURE_FATAL=\"no\"\nIPV6_ADDR_GEN_MODE=\"stable-privacy\"\nNAME=\"ens33:1\"\nUUID=\"0f632d9e-f3a1-40f9-8116-3340e2db6074\"\nDEVICE=\"ens33:1\"\nONBOOT=\"yes\"\nIPADDR=192.168.72.129\nNETMASK=255.255.255.0</code></pre>\n<p>其实就是改一下<code>NAME</code>、<code>DEVICE</code>、<code>IPADDR</code>，另外<code>DNS1</code>和<code>GATEWAY</code>可以删除，设置完毕重启网卡，如下所示：</p>\n<pre class=\"code-rows\"><code># ifdown ens33 &amp;&amp; ifup ens33</code></pre>\n<p>之后再查看网卡IP，如下所示：</p>\n<pre class=\"code-rows\"><code># ifconfig\nens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500\n inet 192.168.72.128 netmask 255.255.255.0 broadcast 192.168.72.255\n inet6 fe80::454b:a2e5:64e5:67a3 prefixlen 64 scopeid 0x20&lt;link&gt;\n ether 00:0c:29:15:7f:b9 txqueuelen 1000 (Ethernet)\n RX packets 66415 bytes 76169910 (72.6 MiB)\n RX errors 0 dropped 0 overruns 0 frame 0\n TX packets 15584 bytes 2655575 (2.5 MiB)\n TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0\n\nens33:1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500\n inet 192.168.72.129 netmask 255.255.255.0 broadcast 192.168.72.255\n ether 00:0c:29:15:7f:b9 txqueuelen 1000 (Ethernet)</code></pre>\n<p>从上面可以看到，多了一个<code>ens33:1</code>。</p>\n<h3 id=\"nav_point_259\">13.3.3 查看网卡连接状态</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># mii-tool ens33\nens33: negotiated 1000baseT-FD flow-control, link ok</code></pre>\n<p>这里显示<code>link ok</code>，就说明网卡为连接状态。如果显示<code>no link</code>，则说明网卡坏了或者没有连接网线。还有一个命令也可以查看网卡的状态，如下：</p>\n<pre class=\"code-rows\"><code># ethtool ens33\nSettings for ens33:\n Supported ports: [ TP ]\n Supported link modes: 10baseT/Half 10baseT/Full\n 100baseT/Half 100baseT/Full\n 1000baseT/Full\n Supported pause frame use: No\n Supports auto-negotiation: Yes\n Supported FEC modes: Not reported\n Advertised link modes: 10baseT/Half 10baseT/Full\n 100baseT/Half 100baseT/Full\n 1000baseT/Full\n Advertised pause frame use: No\n Advertised auto-negotiation: Yes\n Advertised FEC modes: Not reported\n Speed: 1000Mb/s\n Duplex: Full\n Port: Twisted Pair\n PHYAD: 0\n Transceiver: internal\n Auto-negotiation: on\n MDI-X: off (auto)\n Supports Wake-on: d\n Wake-on: d\n Current message level: 0x00000007 (7)\n drv probe link\n Link detected: yes</code></pre>\n<p>如果网卡没有连接，则最后一行<code>Link detected</code>显示为<code>no</code>。</p>\n<h3 id=\"nav_point_260\">13.3.4 更改主机名</h3>\n<p>在第3章的时候，阿铭就已经介绍过如何更改主机名。安装完系统后，主机名默认为<code>localhost.localdomain</code>，使用<code>hostname</code>命令就可以查看Linux的主机名，如下所示：</p>\n<pre class=\"code-rows\"><code># hostname\nlocalhost.localdomain</code></pre>\n<p>使用<code>hostname</code>命令也可以更改主机名，如下所示：</p>\n<pre class=\"code-rows\"><code># hostname Aming\n# hostname\nAming</code></pre>\n<p>下次登录时，命令提示符<code>[root@localhost ~]</code>中的<code>localhost</code>就会更改成<code>Aming</code>。不过这个修改只是保存在了内存中，之后重启，主机名还是会变成改动之前的名称。所以更改主机名的同时还需要更改相关的配置文件/etc/hostname。下面阿铭再介绍一种更改主机名的方法，这种方法会自动更改文件内容，如下所示：</p>\n<pre class=\"code-rows\"><code># hostnamectl set-hostname aminglinux-123\n# hostname\naminglinux-123\n# cat /etc/hostname\naminglinux-123</code></pre>\n<h3 id=\"nav_point_261\">13.3.5 设置DNS</h3>\n<p>DNS是用来解析域名的。平时我们访问网站时都是直接输入一个网址，然后DNS把这个网址解析到一个IP。关于DNS的概念，阿铭不再详细介绍，如果你感兴趣就去网上查一下。</p>\n<p>在Linux下设置DNS非常简单，只要把DNS地址写到配置文件 /etc/resolv.conf中即可。如下所示：</p>\n<pre class=\"code-rows\"><code># cat /etc/resolv.conf\n# Generated by NetworkManager\nnameserver 119.29.29.29</code></pre>\n<p>第一行以<code>#</code>开头的行没有实际意义，仅仅是一个注释，它的意思是，这个配置文件中的DNS IP地址是由<code>NetworkManager</code>服务生成的。那么为什么这个DNS由它生成呢？你是否还有印象，我们在定义网卡配置文件的时候，就有一行<code>DNS1=119.29.29.29</code>，其实就是因为这行配置，该配置文件里才有了<code>nameserver</code>的IP地址。resolv.conf有它固有的格式，一定要写成<code>nameserver IP</code>的格式。阿铭建议你写两个或多个<code>namserver</code>，系统默认会用第一个<code>namserver</code>去解析域名，当第一个解析不成功时使用第二个。</p>\n<p>说到这，你是否有疑惑：既然两个地方都可以定义DNS的IP地址，那么到底在哪里定义呢？阿铭给出的答案是：如果只是临时修改DNS IP地址，就直接修改/etc/resolv.conf；如果是想永久生效的话，还是要修改网卡的配置文件。</p>\n<p>在Linux下还有一个特殊文件/etc/hosts也能解析域名，不过需要我们在里面手动添加IP和域名这些内容。它的作用是临时解析某个域名，非常有用。该文件的内容如下：</p>\n<pre class=\"code-rows\"><code># cat /etc/hosts\n127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4\n::1 localhost localhost.localdomain localhost6 localhost6.localdomain6</code></pre>\n<p>请用Vim编辑该文件，增加一行<code>192.168.72.1 www.baidu.com</code>，保存文件后再ping一下，www.baidu.com就会连接到192.168.72.1了。如下所示：</p>\n<pre class=\"code-rows\"><code># ping -c 2 www.baidu.com\nPING www.baidu.com (192.168.72.1) 56(84) bytes of data.\n64 bytes from www.baidu.com (192.168.72.1): icmp_seq=1 ttl=64 time=0.531 ms\n64 bytes from www.baidu.com (192.168.72.1): icmp_seq=2 ttl=64 time=0.392 ms\n\n--- www.baidu.com ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 54ms\nrtt min/avg/max/mdev = 0.392/0.461/0.531/0.072 ms</code></pre>\n<p>/etc/hosts的格式很简单，每一行分别为一条记录，分成两部分，第一部分是IP，第二部分是域名。关于hosts文件，有以下几点需要你注意：</p>\n<ul>\n<li>一个IP后面可以跟多个域名，可以是几十个甚至上百个；</li>\n<li>每一行只能有一个IP，也就是说一个域名不能对应多个IP；</li>\n<li>如果有多行出现相同的域名（对应的IP不一样），那么会按最前面出现的记录来解析。</li>\n</ul>\n","neighbors":{"left":{"article_title":"第 12 章 shell脚本","id":741034},"right":{"article_title":"第 13 章 Linux系统管理技巧(2)","id":741036}},"comments":[]}