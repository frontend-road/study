{"id":165161,"title":"96 | Swift中的自动引用计数","content":"<p><strong>课件地址</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/swift-course\">https://gitee.com/geektime-geekbang/swift-course</a></p>","comments":[{"had_liked":false,"id":336693,"user_name":"Null","can_delete":false,"product_type":"c3","uid":1382587,"ip_address":"","ucode":"A7D4DF2A43C7D8","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/bb/9299fab1.jpg","comment_is_top":false,"comment_ctime":1646294544,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"两个知识点，\n一，weak跟oc中的差不多，接触相互持有的关系，还能帮你自动设置为nil，因此必须是可选性。\nunowned类似于oc的unsafe-unretain，不会帮你自动设置为nil，所以可选不可选也不重要了。唯一就是你用的时候自己确定到底是有值，还是nil，否则就崩溃给你看。意思吧，就是说我不安全，谨慎使用哈哈哈。\n\n二、闭包解循环，添加一个捕获的数组。\nlazy var someClosure = {\n    [unowned self, weak delegate = self.delegate]\n    (index: Int, stringToProcess: String) -&gt; String in\n    &#47;&#47; closure body goes here\n}","like_count":0},{"had_liked":false,"id":327214,"user_name":"谁见过风","can_delete":false,"product_type":"c3","uid":2444997,"ip_address":"","ucode":"60DC15DD2CD88E","user_header":"https://static001.geekbang.org/account/avatar/00/25/4e/c5/5c5acc30.jpg","comment_is_top":false,"comment_ctime":1639985901,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"class Country {\n    let name: String\n    var capitalCity: City!\n    init(name: String, capitalName: String) {\n        self.name\n        self.capitalCity = City(name: capitalName, country: self)\n    }\n}\n\n这个示例代码Country的init方法在capitalCity属性赋值时会报错：\n&#39;self&#39; used before all stored properties are initialized\nReturn from initializer without initializing all stored properties","like_count":0}]}