{"id":151949,"title":"14 | 缓存的使用姿势（二）：缓存如何做到高可用？","content":"<p>你好，我是唐扬。</p><p>前面几节课，我带你了解了缓存的原理、分类以及常用缓存的使用技巧。我们开始用缓存承担大部分的读压力，从而缓解数据库的查询压力，在提升性能的同时保证系统的稳定性。这时，你的电商系统整体的架构演变成下图的样子：</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/05/6c860d61a578cde20591968cc2741a05.jpg?wh=1142*559\" alt=\"\"></p><p>我们在Web层和数据库层之间增加了缓存层，请求会首先查询缓存，只有当缓存中没有需要的数据时才会查询数据库。</p><p>在这里，你需要关注缓存命中率这个指标（缓存命中率=命中缓存的请求数/总请求数）。一般来说，在你的电商系统中，核心缓存的命中率需要维持在99%甚至是99.9%，哪怕下降1%，系统都会遭受毁灭性的打击。</p><p>这绝不是危言耸听，我们来计算一下。假设系统的QPS是10000/s，每次调用会访问10次缓存或者数据库中的数据，那么当缓存命中率仅仅减少1%，数据库每秒就会增加10000 * 10 * 1% = 1000次请求。而一般来说我们单个MySQL节点的读请求量峰值就在1500/s左右，增加的这1000次请求很可能会给数据库造成极大的冲击。</p><p>命中率仅仅下降1%造成的影响就如此可怕，更不要说缓存节点故障了。而图中单点部署的缓存节点就成了整体系统中最大的隐患，那我们要如何来解决这个问题，提升缓存的可用性呢？</p><!-- [[[read_end]]] --><p>我们可以通过部署多个节点，同时设计一些方案让这些节点互为备份。这样，当某个节点故障时，它的备份节点可以顶替它继续提供服务。<strong>而这些方案就是我们本节课的重点：分布式缓存的高可用方案。</strong></p><p>在我的项目中，我主要选择的方案有<strong>客户端方案、中间代理层方案和服务端方案</strong>三大类：</p><ul>\n<li>\n<p><strong>客户端方案</strong>就是在客户端配置多个缓存的节点，通过缓存写入和读取算法策略来实现分布式，从而提高缓存的可用性。</p>\n</li>\n<li>\n<p><strong>中间代理层方案</strong>是在应用代码和缓存节点之间增加代理层，客户端所有的写入和读取的请求都通过代理层，而代理层中会内置高可用策略，帮助提升缓存系统的高可用。</p>\n</li>\n<li>\n<p><strong>服务端方案</strong>就是Redis 2.4版本后提出的Redis Sentinel方案。</p>\n</li>\n</ul><p>掌握这些方案可以帮助你，抵御部分缓存节点故障导致的，缓存命中率下降的影响，增强你的系统的鲁棒性。</p><h2>客户端方案</h2><p>在客户端方案中，你需要关注缓存的写和读两个方面：</p><ul>\n<li>\n<p>写入数据时，需要把被写入缓存的数据分散到多个节点中，即进行数据分片；</p>\n</li>\n<li>\n<p>读数据时，可以利用多组的缓存来做容错，提升缓存系统的可用性。关于读数据，这里可以使用主从和多副本两种策略，两种策略是为了解决不同的问题而提出的。</p>\n</li>\n</ul><p>下面我就带你一起详细地看一下到底要怎么做。</p><p><strong>1.缓存数据如何分片</strong></p><p>单一的缓存节点受到机器内存、网卡带宽和单节点请求量的限制，不能承担比较高的并发，因此我们考虑将数据分片，依照分片算法将数据打散到多个不同的节点上，每个节点上存储部分数据。</p><p>这样在某个节点故障的情况下，其他节点也可以提供服务，保证了一定的可用性。这就好比不要把鸡蛋放在同一个篮子里，这样一旦一个篮子掉在地上，摔碎了，别的篮子里还有没摔碎的鸡蛋，不至于一个不剩。</p><p><strong>一般来讲，分片算法常见的就是Hash分片算法和一致性Hash分片算法两种。</strong></p><p>Hash分片的算法就是对缓存的Key做哈希计算，然后对总的缓存节点个数取余。你可以这么理解：</p><p>比如说，我们部署了三个缓存节点组成一个缓存的集群，当有新的数据要写入时，我们先对这个缓存的Key做比如crc32等Hash算法生成Hash值，然后对Hash值模3，得出的结果就是要存入缓存节点的序号。</p><p><img src=\"https://static001.geekbang.org/resource/image/72/55/720f7e4543d45fdc71056de280caff55.jpg?wh=1142*469\" alt=\"\"></p><p>\b这个算法最大的优点就是简单易理解，缺点是当增加或者减少缓存节点时，缓存总的节点个数变化造成计算出来的节点发生变化，从而造成缓存失效不可用。<strong>所以我建议你，</strong>如果采用这种方法，最好建立在你对于这组缓存命中率下降不敏感，比如下面还有另外一层缓存来兜底的情况下。<br>\n\b<br>\n<strong>当然了，用一致性Hash算法可以很好地解决增加和删减节点时，命中率下降的问题。</strong>在这个算法中，我们将整个Hash值空间组织成一个虚拟的圆环，然后将缓存节点的IP地址或者主机名做Hash取值后，放置在这个圆环上。当我们需要确定某一个Key需要存取到哪个节点上的时候，先对这个Key做同样的Hash取值，确定在环上的位置，然后按照顺时针方向在环上“行走”，遇到的第一个缓存节点就是要访问的节点。比方说下面这张图里面，Key 1和Key 2会落入到Node  1中，Key 3、Key 4会落入到Node 2中，Key 5落入到Node 3中，Key 6落入到Node 4中。</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/fe/f9ea0e201aa954cf46c5762835095efe.jpg?wh=1142*914\" alt=\"\"></p><p>这时如果在Node 1和Node 2之间增加一个Node 5，你可以看到原本命中Node 2的Key 3现在命中到Node 5，而其它的Key都没有变化；同样的道理，如果我们把Node 3从集群中移除，那么只会影响到Key 5 。所以你看，<strong>在增加和删除节点时，只有少量的Key会“漂移”到其它节点上，</strong>而大部分的Key命中的节点还是会保持不变，从而可以保证命中率不会大幅下降。</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/91/4c13c4fd4278dc97d072afe09a1a1b91.jpg?wh=1142*807\" alt=\"\"></p><p>不过，事物总有两面性。虽然这个算法对命中率的影响比较小，但它还是存在问题：</p><ul>\n<li>\n<p>缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大；当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，会对后面这个节点造成压力。</p>\n</li>\n<li>\n<p>一致性Hash算法的脏数据问题。</p>\n</li>\n</ul><p>极端情况下，比如一个有三个节点A、B、C承担整体的访问，每个节点的访问量平均，A故障后，B将承担双倍的压力（A和B的全部请求），当B承担不了流量Crash后，C也将因为要承担原先三倍的流量而Crash，这就造成了整体缓存系统的雪崩。</p><p>说到这儿，你可能觉得很可怕，但也不要太担心，<strong>我们程序员就是要能够创造性地解决各种问题，所以你可以在一致性Hash算法中引入虚拟节点的概念。</strong></p><p>它将一个缓存节点计算多个Hash值分散到圆环的不同位置，这样既实现了数据的平均，而且当某一个节点故障或者退出的时候，它原先承担的Key将以更加平均的方式分配到其他节点上，从而避免雪崩的发生。</p><p><strong>其次，就是一致性Hash算法的脏数据问题。为什么会产生脏数据呢？</strong>比方说，在集群中有两个节点A和B，客户端初始写入一个Key为k，值为3的缓存数据到Cache A中。这时如果要更新k的值为4，但是缓存A恰好和客户端连接出现了问题，那这次写入请求会写入到Cache B中。接下来缓存A和客户端的连接恢复，当客户端要获取k的值时，就会获取到存在Cache A中的脏数据3，而不是Cache B中的4。</p><p><strong>所以，在使用一致性Hash算法时一定要设置缓存的过期时间，</strong>这样当发生漂移时，之前存储的脏数据可能已经过期，就可以减少存在脏数据的几率。</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/f8/4c10bb2e9b0f6cb9920d4b1c9418b2f8.jpg?wh=1142*591\" alt=\"\"></p><p>很显然，数据分片最大的优势就是缓解缓存节点的存储和访问压力，但同时它\b也让缓存的使用\b更加复杂。在MultiGet（批量获取）场景下，单个节点的访问量并没有减少，同时节点数太多会造成缓存访问的SLA（即“服务等级协议”，SLA代表了网站服务可用性）得不到很好的保证，因为根据木桶原则，SLA取决于最慢、最坏的节点的情况，节点数过多也会增加出问题的概率，<strong>因此我推荐4到6个节点为佳。</strong></p><p><strong>2.Memcached的主从机制</strong></p><p>Redis本身支持主从的部署方式，但是Memcached并不支持，所以我们今天主要来了解一下Memcached的主从机制是如何在客户端实现的。</p><p>在之前的项目中，我就遇到了单个主节点故障导致数据穿透的问题，这时我为每一组Master配置一组Slave，更新数据时主从同步更新。读取时，优先从Slave中读数据，如果读取不到数据就穿透到Master读取，并且将数据回种到Slave中以保持Slave数据的热度。</p><p>主从机制最大的优点就是当某一个Slave宕机时，还会有Master作为兜底，不会有大量请求穿透到数据库的情况发生，提升了缓存系统的高可用性。</p><p><img src=\"https://static001.geekbang.org/resource/image/54/60/5468eb8779396b38c3731839f3d8d960.jpg?wh=1142*588\" alt=\"\"></p><p><strong>3.多副本</strong></p><p>其实，主从方式已经能够解决大部分场景的问题，但是对于极端流量的场景下，一组Slave通常来说并不能完全承担所有流量，Slave网卡带宽可能成为瓶颈。</p><p>为了解决这个问题，我们考虑在Master/Slave之前增加一层副本层，整体架构是这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/67/03/6779f9b6741b7767068df767218bcd03.jpg?wh=1142*537\" alt=\"\"></p><p>在这个方案中，当客户端发起查询请求时，请求首先会先从多个副本组中选取一个副本组发起查询，如果查询失败，就继续查询Master/Slave，并且将查询的结果回种到所有副本组中，避免副本组中脏数据的存在。</p><p>基于成本的考虑，每一个副本组容量比Master和Slave要小，因此它只存储了更加热的数据。在这套架构中，Master和Slave的请求量会大大减少，为了保证它们存储数据的热度，在实践中我们会把Master和Slave作为一组副本组使用。</p><h2>中间代理层方案</h2><p>虽然客户端方案已经能解决大部分的问题，但是只能在单一语言系统之间复用。例如微博使用Java语言实现了这么一套逻辑，我使用PHP就难以复用，需要重新写一套，很麻烦。<strong>而中间代理层的方案就可以解决这个问题。</strong>你可以将客户端解决方案的经验移植到代理层中，通过通用的协议（如Redis协议）来实现在其他语言中的复用。</p><p>如果你来自研缓存代理层，你就可以将客户端方案中的高可用逻辑封装在代理层代码里面，这样用户在使用你的代理层的时候就不需要关心缓存的高可用是如何做的，只需要依赖你的代理层就好了。</p><p>除此以外，业界也有很多中间代理层方案，比如Facebook的<a href=\"https://github.com/facebook/mcrouter\">Mcrouter</a>，Twitter的<a href=\"https://github.com/twitter/twemproxy\">Twemproxy</a>，豌豆荚的<a href=\"https://github.com/CodisLabs/codis\">Codis</a>。它们的原理基本上可以由一张图来概括：</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/43/c517437faf418e7fa085b1850e3f7343.jpg?wh=1142*487\" alt=\"\"></p><p>看这张图你有什么发现吗？ 所有缓存的<strong>读写请求</strong>都是经过代理层完成的。代理层是无状态的，主要负责读写请求的路由功能，并且在其中内置了一些高可用的逻辑，不同的开源中间代理层方案中使用的高可用策略各有不同。比如在Twemproxy中，Proxy保证在某一个Redis节点挂掉之后会把它从集群中移除，后续的请求将由其他节点来完成；而Codis的实现略复杂，它提供了一个叫Codis Ha的工具来实现自动从节点提主节点，在3.2版本之后换做了Redis Sentinel方式，从而实现Redis节点的高可用。</p><h2>服务端方案</h2><p>Redis在2.4版本中提出了Redis Sentinel模式来解决主从Redis部署时的高可用问题，它可以在主节点挂了以后自动将从节点提升为主节点，保证整体集群的可用性，整体的架构如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/94/e1/94ae214f840d2844b7b43751aab6d8e1.jpg?wh=1142*531\" alt=\"\"></p><p>Redis Sentinel也是集群部署的，这样可以避免Sentinel节点挂掉造成无法自动故障恢复的问题，每一个Sentinel节点都是无状态的。在Sentinel中会配置Master的地址，Sentinel会时刻监控Master的状态，当发现Master在配置的时间间隔内无响应，就认为Master已经挂了，Sentinel会从从节点中选取一个提升为主节点，并且把所有其他的从节点作为新主的从节点。Sentinel集群内部在仲裁的时候，会根据配置的值来决定当有几个Sentinel节点认为主挂掉可以做主从切换的操作，也就是集群内部需要对缓存节点的状态达成一致才行。</p><p>Redis Sentinel不属于代理层模式，因为对于缓存的写入和读取请求不会经过Sentinel节点。Sentinel节点在架构上和主从是平级的，是作为管理者存在的，<strong>所以可以认为是在服务端提供的一种高可用方案。</strong></p><h2>课程小结</h2><p>这就是今天分享的全部内容了，我们一起来回顾一下重点：</p><p>分布式缓存的高可用方案主要有三种，首先是客户端方案，一般也称为Smart Client。我们通过制定一些数据分片和数据读写的策略，可以实现缓存高可用。这种方案的好处是性能没有损耗，缺点是客户端逻辑复杂且在多语言环境下不能复用。</p><p>其次，中间代理方案在客户端和缓存节点之间增加了中间层，在性能上会有一些损耗，在代理层会有一些内置的高可用方案，比如Codis会使用Codis Ha或者Sentinel。</p><p>最后，服务端方案依赖于组件的实现，Memcached就只支持单机版没有分布式和HA的方案，而Redis在2.4版本提供了Sentinel方案可以自动进行主从切换。服务端方案会在运维上增加一些复杂度。</p><p>总体而言，分布式缓存的三种方案各有所长，有些团队可能在开发过程中已经积累了Smart Client上的一些经验；而有些团队在Redis运维上经验丰富，就可以推进Sentinel方案；有些团队在存储研发方面有些积累，就可以推进中间代理层方案，甚至可以自研适合自己业务场景的代理层组件，具体的选择还是要看团队的实际情况而定。</p><h2>一课一思</h2><p>结合你们过往的经历，我们来聊一聊缓存高可用的重要性吧，比如当缓存可用性下降会造成什么严重问题呢？你们又是如何来保证缓存的高可用的呢？欢迎在留言区与我一同讨论。</p><p>最后，感谢你的阅读，如果这篇文章让你有所收获，也欢迎你将它分享给更多的朋友。</p>","comments":[{"had_liked":false,"id":143445,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1571709743,"is_pvip":false,"replies":[{"id":"55493","content":"是的👍","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571792605,"ip_address":"","comment_id":143445,"utype":1}],"discussion_count":1,"race_medal":0,"score":"160485499695","product_id":100035801,"comment_content":"大概总结了一下：<br>实现高可用的核心依旧是集群。多个缓存节点，提高容错率。<br>客户端实现：由客户端的策略决定如何写缓存，如何读缓存。性能高，但是逻辑复杂，无法跨平台。<br>中间件实现：所有客户端先访问中间件，然后中间件决定了缓存策略。因为引入了中间件，所以性能较差，但是可以跨平台，并且有能力的公司还可以自研中间件。<br>服务端实现：主从切换由服务端实现。最大的缺点是增加了运维成本。<br>不知道我的理解是否正确。<br><br>","like_count":38,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471541,"discussion_content":"是的👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571792605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142601,"user_name":"longslee","can_delete":false,"product_type":"c1","uid":1465986,"ip_address":"","ucode":"C24E32E5B1B6F5","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg","comment_is_top":false,"comment_ctime":1571410248,"is_pvip":false,"replies":[{"id":"55088","content":"1. 如果B节点剔除，那么K2的读写都会到C节点上<br>2. 命中率会下降，因为B节点没有被删除的时候，C节点上是没有K2数据的。B节点剔除后，第一次从C节点获取K2数据是要穿透的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571453669,"ip_address":"","comment_id":142601,"utype":1}],"discussion_count":5,"race_medal":0,"score":"65995919688","product_id":100035801,"comment_content":"打卡。 老师好，提问：一致性Hash中，比如存在A(k1)、B(k2)、C(k3)，3个节点，括号中为分配的Key，假如B节点剔除了，那么k2会漂移到C节点。 那么此时客户端请求get k2的时候，是被计算好从C节点获取呢，还是完全就拿不到需要去数据库查？如果是从C节点获取，那感觉命中率完全没有下降。 这一点确实没搞清楚，忘老师解惑，谢谢🙏","like_count":15,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471192,"discussion_content":"1. 如果B节点剔除，那么K2的读写都会到C节点上\n2. 命中率会下降，因为B节点没有被删除的时候，C节点上是没有K2数据的。B节点剔除后，第一次从C节点获取K2数据是要穿透的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571453669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180676,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/04/0af56558.jpg","nickname":"Jc.Chen","note":"","ucode":"36886491352CD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302949,"discussion_content":"你应该是理解错[漂移]的意思，[漂移]是指，指定key将被解析到C节点获取，不是指key和value这个键值对漂移到C节点","likes_number":8,"is_delete":false,"is_hidden":false,"ctime":1599096411,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1480119,"avatar":"https://static001.geekbang.org/account/avatar/00/16/95/b7/15e157ec.jpg","nickname":"路人甲","note":"","ucode":"B720984454AFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71559,"discussion_content":"就是说，数据写到一个节点分片中，其余的不写吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575433480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1465986,"avatar":"https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg","nickname":"longslee","note":"","ucode":"C24E32E5B1B6F5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1480119,"avatar":"https://static001.geekbang.org/account/avatar/00/16/95/b7/15e157ec.jpg","nickname":"路人甲","note":"","ucode":"B720984454AFAF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71744,"discussion_content":"嗯？没懂呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575455116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":71559,"ip_address":""},"score":71744,"extra":""},{"author":{"id":1123043,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/e3/510b69f9.jpg","nickname":"benny","note":"","ucode":"E2F30AF0C808D9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1480119,"avatar":"https://static001.geekbang.org/account/avatar/00/16/95/b7/15e157ec.jpg","nickname":"路人甲","note":"","ucode":"B720984454AFAF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":166570,"discussion_content":"对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581412978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":71559,"ip_address":""},"score":166570,"extra":""}]}]},{"had_liked":false,"id":144463,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1571928686,"is_pvip":false,"replies":[{"id":"55688","content":"1万是基准测试的结果，在实际中sql更复杂，达不到这个性能","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571960008,"ip_address":"","comment_id":144463,"utype":1}],"discussion_count":3,"race_medal":0,"score":"57406503534","product_id":100035801,"comment_content":"老师，您之前说4核8G的机器上，MySQL最高支撑QPS为1万，怎样本文开头又说MySQL读峰值才1500&#47;s呢","like_count":14,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471954,"discussion_content":"1万是基准测试的结果，在实际中sql更复杂，达不到这个性能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571960008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364503,"discussion_content":"之前不是说互联网的SQL都比较简单嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617504504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1744053,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/9c/b5/c936c54b.jpg","nickname":"💣","note":"","ucode":"F3B82CEB6B6934","race_medal":3,"user_type":1,"is_pvip":true},"reply_author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590965,"discussion_content":"互联网的sql是个什么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666190073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364503,"ip_address":"上海"},"score":590965,"extra":""}]}]},{"had_liked":false,"id":210132,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1587689514,"is_pvip":false,"replies":[{"id":"78353","content":"👍","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1587699373,"ip_address":"","comment_id":210132,"utype":1}],"discussion_count":4,"race_medal":0,"score":"48832329770","product_id":100035801,"comment_content":"高可用的设计思路没有其他的核心就是增加副本，针对数据就增加数据副本，针对服务就增加服务副本，针对机房就增加机房副本，增加副本引入的新问题是数据不一致性，下面各种算法什么的都是为了解决因增加副本而带来的数据不一致性问题或者节点挂了怎么使服务继续可用的策略。比如：数据怎么迁移？故障怎么隔离？故障节点恢复后怎么是否加入？怎么加入？最近热上了看火影，影分术就是鸣人的高可用方式，其他的高可用思路和这个如出一辙。从动漫中也可以看出，这个需要更多能量，对公司而言，需要更多机器和存储空间，技术复杂度也会增加一些，幸好有现成的组件避免人人都重复造轮子的资源浪费。","like_count":12,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492952,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587699373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1872697,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/93/39/f642023f.jpg","nickname":"Hplus","note":"","ucode":"DC32CBC3E9C11D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564275,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650204820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364511,"discussion_content":"冗余与分片","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617506079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1092218,"avatar":"https://static001.geekbang.org/account/avatar/00/10/aa/7a/ae8c247d.jpg","nickname":"指尖以东","note":"","ucode":"1DEE134FE92FD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262937,"discussion_content":"向你学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589157851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143446,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1571709933,"is_pvip":false,"replies":[{"id":"55490","content":"是的 ：）","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571792516,"ip_address":"","comment_id":143446,"utype":1}],"discussion_count":4,"race_medal":0,"score":"40226415597","product_id":100035801,"comment_content":"另外就客户端和服务端的理解：<br>老实说一开始我也一脸懵逼。以为客户端就是用户端。<br>但是后来想通了。<br>应用服务器为用户提供数据接口，用户就是客户端，应用就是服务端。<br>但是缓存为应用服务器提供缓存服务，这时候对于缓存服务器来说应用服务器就是客户端，而缓存就是服务端。","like_count":9,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471542,"discussion_content":"是的 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571792516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364507,"discussion_content":"这一节的客户端指的是应用层，服务端指的是缓存，因为缓存给应用层提供数据读取功能\n客户端方案：在应用层代码设置缓存读取和写入方案\n中间代理层方案：在应用代码和缓存节点之间增加代理层，应用层所有的写入和读取的请 求都通过代理层\n服务端方案：缓存本身内部实现了高可用方案，redis sentinel或者redis cluster","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1617505774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009831,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/68/a7/c3fd1fd9.jpg","nickname":"聪","note":"","ucode":"9D672A8580A945","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312322,"discussion_content":"这里的client就是你的去远程缓存拿数据的代码，用的比如redis smart client之类的library","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1602662428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1592279,"avatar":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","nickname":"William Ning","note":"","ucode":"4DB8D05E69E5F3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362718,"discussion_content":"客户端与服务端是相对而言，互为参考～ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617017976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147052,"user_name":"Hwan","can_delete":false,"product_type":"c1","uid":1205627,"ip_address":"","ucode":"A728C6790511BD","user_header":"https://static001.geekbang.org/account/avatar/00/12/65/7b/66b9befd.jpg","comment_is_top":false,"comment_ctime":1572778149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23047614629","product_id":100035801,"comment_content":"回答一下问题，如果缓存的高可用做的不够好的话，一旦线上发生故障，导致缓存直接崩了，再加上并发量比较大的话，可能会直接去访问数据库了，对数据库的压力比较大，严重的话，会导致数据库崩溃，然后就是各种丢数据，然后关于如何做的话，建议之前做好关于一些流量的评估，以Redis为例，现在有现成的哨兵和集群方案可以使用，当然也可以Codis，还有一点就是部署线上的时候可以先演练下","like_count":6},{"had_liked":false,"id":162946,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1576633311,"is_pvip":false,"replies":[{"id":"62135","content":"1. 写入的时候中缓存，这样从缓存里面读就实时了<br>2. 直接读主库","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1576735174,"ip_address":"","comment_id":162946,"utype":1}],"discussion_count":9,"race_medal":0,"score":"18756502495","product_id":100035801,"comment_content":"老师，主从会有延迟，写入主库，但延迟同步到从库，在同步完成前去从库读数据，读不到，这如何解决呢","like_count":5,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478186,"discussion_content":"1. 写入的时候中缓存，这样从缓存里面读就实时了\n2. 直接读主库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576735174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1518310,"avatar":"https://static001.geekbang.org/account/avatar/00/17/2a/e6/c788257f.jpg","nickname":"geek_arong2048","note":"","ucode":"AB575BE100E4A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":576550,"discussion_content":"写入缓存后，redis可能也存在主从延迟问题，这时读到的redis数据也是老数据，这应该如何解决呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655645495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":478186,"ip_address":""},"score":576550,"extra":""}]},{"author":{"id":1013493,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/76/f5/e3f5bd8d.jpg","nickname":"宝仔","note":"","ucode":"A0F17DFF99DB21","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213194,"discussion_content":"写入的时候中缓存是啥意思，这句话没理解","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585058583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1755152,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VTPuhJb5xxuRwH1iblqrAe3De4PoETgNWibZRkLlhvszysdtpAvSPZFuYtsJfWJmoXOFFWnpR02W9NGIiammU8UPg/132","nickname":"Info_E","note":"","ucode":"97207B2CC4C776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1013493,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/76/f5/e3f5bd8d.jpg","nickname":"宝仔","note":"","ucode":"A0F17DFF99DB21","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":550673,"discussion_content":"写主库之前写缓存， 读的时候直接读缓存就完了 别读从库","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644664550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213194,"ip_address":""},"score":550673,"extra":""}]},{"author":{"id":2104541,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7paIUwnxWN99xhC2omNeAIbKY0FhYX3ibAh85FZqQphlr97UewO51FyqeIjSg31dZ6p7S8tgKk5Q/132","nickname":"冰","note":"","ucode":"685BB45108D2DB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312584,"discussion_content":"主从复制的延迟问题(先分清哪些请求允许过期读，哪些请求不允许过期读)，一主一从的时候，我们使用的是 半同步复制+对比位点解决的。\n两主两从的时候我们是采用不允许过期读的请求走主库的方案解决的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602739190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1755152,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VTPuhJb5xxuRwH1iblqrAe3De4PoETgNWibZRkLlhvszysdtpAvSPZFuYtsJfWJmoXOFFWnpR02W9NGIiammU8UPg/132","nickname":"Info_E","note":"","ucode":"97207B2CC4C776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2104541,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7paIUwnxWN99xhC2omNeAIbKY0FhYX3ibAh85FZqQphlr97UewO51FyqeIjSg31dZ6p7S8tgKk5Q/132","nickname":"冰","note":"","ucode":"685BB45108D2DB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356159,"discussion_content":"对比位点是啥意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615542668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312584,"ip_address":""},"score":356159,"extra":""},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2104541,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7paIUwnxWN99xhC2omNeAIbKY0FhYX3ibAh85FZqQphlr97UewO51FyqeIjSg31dZ6p7S8tgKk5Q/132","nickname":"冰","note":"","ucode":"685BB45108D2DB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364512,"discussion_content":"为什么两主两从的时候不继续采用半同步复制+对比位点的方案？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617506192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312584,"ip_address":""},"score":364512,"extra":""}]},{"author":{"id":1013493,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/76/f5/e3f5bd8d.jpg","nickname":"宝仔","note":"","ucode":"A0F17DFF99DB21","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213199,"discussion_content":"第二个应该是直接读从库吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585058655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1678641,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ONIogicHLw4qYdzjVlm5SS75kqnmrdziadgOaHZNn8IGffSZ8xHTgOz0ZBzsFqyO5dsjF7JFs5LBXvHXSpC6eiaibg/132","nickname":"Geek_4c1353","note":"","ucode":"E86D3B067A3694","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1013493,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/76/f5/e3f5bd8d.jpg","nickname":"宝仔","note":"","ucode":"A0F17DFF99DB21","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":290273,"discussion_content":"第二个是读主库","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594394028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213199,"ip_address":""},"score":290273,"extra":""}]}]},{"had_liked":false,"id":148321,"user_name":"海罗沃德","can_delete":false,"product_type":"c1","uid":1165364,"ip_address":"","ucode":"8704F1D6980FA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c8/34/fb871b2c.jpg","comment_is_top":false,"comment_ctime":1572979705,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"18752848889","product_id":100035801,"comment_content":"分享一個踩過的坑，在AWS上，產品經理要做一個增加搜索速度的功能，要求把最近搜過的關鍵字跟結果緩存起來，於是就通過AWS elastic cache做了一盒緩存層，然後產品經理提出我們的項目是跨region訪問的，我在A region更改數據後在瞬間開另一個瀏覽器用deep link方式從B region再訪問，都要看到數據，然而AWS的緩存不支持跨region的數據拷貝，於是這個story的failure就變成我來背鍋","like_count":4,"discussions":[{"author":{"id":1009831,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/68/a7/c3fd1fd9.jpg","nickname":"聪","note":"","ucode":"9D672A8580A945","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312323,"discussion_content":"事先不调研aws doc？哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602662493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1724843,"avatar":"","nickname":"Geek_908e99","note":"","ucode":"5E7C4D317F0C73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289173,"discussion_content":"最后问题解决了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594016073,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147223,"user_name":"无形","can_delete":false,"product_type":"c1","uid":1016889,"ip_address":"","ucode":"B740E2A68A17A5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","comment_is_top":false,"comment_ctime":1572845928,"is_pvip":true,"replies":[{"id":"57040","content":"其实更多的会在redis和mysql之间增加并发的控制，因为redis还是可以扛很好的并发的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1572940498,"ip_address":"","comment_id":147223,"utype":1}],"discussion_count":9,"race_medal":0,"score":"18752715112","product_id":100035801,"comment_content":"还没看完就想说一下我之前的做法，我们有两级缓存，服务器应用程序自身有一个内存缓存，再有Redis缓存，如果内存缓存没有命中，应用程序会创建一个单机的资源锁（go语言，用map+chan实现），大量请求进来，只有第一个请求会获取锁，其他请求获取锁失败，调用wait方法，等待第一个请求获取数据，第一个请求先从Redis中获取数据写入到内存缓存，Redis没有命中再读取MySQL，写会到Redis，执行结束后会通过close chan的方式广播消息，通知其他请求拿到了数据，从内存中读取数据，再释放锁。这样就解决了缓存穿透的问题，同一时刻，不论多大的并发量，真正到存储查询数据的请求只会有一个。","like_count":5,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473207,"discussion_content":"其实更多的会在redis和mysql之间增加并发的控制，因为redis还是可以扛很好的并发的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572940498,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079293,"avatar":"https://static001.geekbang.org/account/avatar/00/10/77/fd/c6619535.jpg","nickname":"XD","note":"","ucode":"DC9DCFB3841A4E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556335,"discussion_content":"singleflight","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1647318245,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1755152,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/VTPuhJb5xxuRwH1iblqrAe3De4PoETgNWibZRkLlhvszysdtpAvSPZFuYtsJfWJmoXOFFWnpR02W9NGIiammU8UPg/132","nickname":"Info_E","note":"","ucode":"97207B2CC4C776","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356162,"discussion_content":"对每个key都配一个chan，内存压力会不会比较大。 写的时候怎么写，多个服务器节点时会不会有一致性问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615543364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118196,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0f/f4/026bddc6.jpg","nickname":"梅小西","note":"","ucode":"F55CC7763DF440","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91495,"discussion_content":"那你这每个key都会配一个chan么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576836899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1118196,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0f/f4/026bddc6.jpg","nickname":"梅小西","note":"","ucode":"F55CC7763DF440","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":93058,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576903412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":91495,"ip_address":""},"score":93058,"extra":""}]},{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44258,"discussion_content":"手动@老师，Redis并发确实很强，用内存缓存的原因是为减少读取Redis带来的网络消耗，提高服务的性能。在用内存缓存时能够提升几倍的QPS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572941240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1150696,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8e/e8/f1e12f2e.jpg","nickname":"青木","note":"","ucode":"2B566ABDAD1339","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43834,"discussion_content":"你这只是单一业务场景的实现，而非设计","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572912320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1150696,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8e/e8/f1e12f2e.jpg","nickname":"青木","note":"","ucode":"2B566ABDAD1339","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":43984,"discussion_content":"虽然有点局限，但是在go语言内是通用的，如果能把缓存部分，升级为缓存代理，把锁的部分用于并发控制，就能成为一个通用的解决方案。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572920701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43834,"ip_address":""},"score":43984,"extra":""},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016889,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/39/c8772466.jpg","nickname":"无形","note":"","ucode":"B740E2A68A17A5","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":364513,"discussion_content":"缓存——》缓存服务\n锁——》分布式锁服务\n改为RPC供远程调用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617506378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":43984,"ip_address":""},"score":364513,"extra":""}]}]},{"had_liked":false,"id":145679,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1572342595,"is_pvip":false,"replies":[{"id":"56281","content":"指的是你的应用服务器，是缓存的使用者","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1572392766,"ip_address":"","comment_id":145679,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18752211779","product_id":100035801,"comment_content":"老师，这个客户端方案中的客户端指哪里。一般我理解的客户端是浏览器或手机app...","like_count":4,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472525,"discussion_content":"指的是你的应用服务器，是缓存的使用者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572392766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250862,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1601263862,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14486165750","product_id":100035801,"comment_content":"在分享老师文章的时候，学到了一致性哈希算法的不同实现<br>1. 哈希环法<br>2. google的jump consistent hash<br>3. Maglev一致性哈希法","like_count":3},{"had_liked":false,"id":191103,"user_name":"kamida","can_delete":false,"product_type":"c1","uid":1904146,"ip_address":"","ucode":"16D7CA59870AC0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/jXbwicoDwia7ooDfwBTRyvNYQkefnVwF1CMicMS8FqKfuFAdvVZo2pqc4ic0R9kSdHTIxaE6YyqxwX8BdNGv5PqSIw/132","comment_is_top":false,"comment_ctime":1584736922,"is_pvip":false,"replies":[{"id":"73903","content":"分片策略是由算法确定的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1585020138,"ip_address":"","comment_id":191103,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10174671514","product_id":100035801,"comment_content":"分片策略是怎么配置的呢 比如说客户端或者中间层怎么知道哪个node负责consistent hash ring上的key的？有zookeeper？<br><br>还有我记得sentinel不支持分片的吧","like_count":2,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488115,"discussion_content":"分片策略是由算法确定的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585020138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364525,"discussion_content":"redis sentinel 主从架构，分片算法的需要在客户端或者中间代理层实现吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617508294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1904146,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/jXbwicoDwia7ooDfwBTRyvNYQkefnVwF1CMicMS8FqKfuFAdvVZo2pqc4ic0R9kSdHTIxaE6YyqxwX8BdNGv5PqSIw/132","nickname":"kamida","note":"","ucode":"16D7CA59870AC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211957,"discussion_content":"老师能解答一下吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584906940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163685,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1576766938,"is_pvip":false,"replies":[{"id":"63086","content":"算法上不太一样哦","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1577242894,"ip_address":"","comment_id":163685,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10166701530","product_id":100035801,"comment_content":"老师，Redis Cluster中使用了hash槽，我理解跟一致性hash其实是等价的，对吧。不过，Redis在分片间还实现了在新增节点时自动迁移数据","like_count":2,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478505,"discussion_content":"算法上不太一样哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577242894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010209,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/21/fe356d0b.jpg","nickname":"辉辉","note":"","ucode":"BB83A45BB55B1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182848,"discussion_content":"固定hash槽，和一致性hash不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582460148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1010209,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/21/fe356d0b.jpg","nickname":"辉辉","note":"","ucode":"BB83A45BB55B1B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364515,"discussion_content":"hash slot 16384我理解等价于一致性hash算法引入的虚拟节点个数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617506715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":182848,"ip_address":""},"score":364515,"extra":""}]}]},{"had_liked":false,"id":144562,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1571969053,"is_pvip":false,"replies":[{"id":"55939","content":"1. 会考虑分片<br>2. 是的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1572219712,"ip_address":"","comment_id":144562,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10161903645","product_id":100035801,"comment_content":"老师，memcached的主从机制会考虑分片实现多个主吗，还是单机全量？多副本方案中提到会选用一个主从作为一个副本组，是一个master多个slave的结构吗？但是画图没有标示这种结构","like_count":2,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472008,"discussion_content":"1. 会考虑分片\n2. 是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572219712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159113,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1575539615,"is_pvip":false,"replies":[{"id":"61441","content":"这个和sentinal无关的。只要做了主从分离，读的都是slave节点。sentinal是来监控主库，在主库出现问题的时候可以帮助你做从库提主","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1576132184,"ip_address":"","comment_id":159113,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5870506911","product_id":100035801,"comment_content":"老师  最近学习  这里还有一个问题   在Redis的sentinal方案中   读缓存是读Slave结点吗？？   感觉只有读Slave结点   才能实现更高的读请求性能   但是读Slave节点时   Master中的数据还没有同步过来   没有读到结果   或者读到旧数据脏数据的话  这个应该怎么解决  ？？？    还是说  读请求也只能读Master结点","like_count":2,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476954,"discussion_content":"这个和sentinal无关的。只要做了主从分离，读的都是slave节点。sentinal是来监控主库，在主库出现问题的时候可以帮助你做从库提主","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576132184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150179,"user_name":"Fourty Seven","can_delete":false,"product_type":"c1","uid":1323868,"ip_address":"","ucode":"DD213225842F68","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/5c/8c0a372a.jpg","comment_is_top":false,"comment_ctime":1573474168,"is_pvip":false,"replies":[{"id":"57792","content":"是的，因为虚拟了多个节点，这些节点会分布在圆环的多个位置","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1573481945,"ip_address":"","comment_id":150179,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868441464","product_id":100035801,"comment_content":"它将一个缓存节点计算多个 Hash 值分散到圆环的不同位置，这样既实现了数据的平均，而且当某一个节点故障或者退出的时候，它原先承担的 Key 将以更加平均的方式分配到其他节点上，从而避免雪崩的发生。<br>老师，这句话啥意思了？是说把一个节点分布到多个位置？","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474085,"discussion_content":"是的，因为虚拟了多个节点，这些节点会分布在圆环的多个位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573481945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149014,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1573127439,"is_pvip":false,"replies":[{"id":"57327","content":"在一致性hash下，如果删除一个节点，比如在一个环上有a，b，c三个节点，b故障，那么只有b的数据会迁移到c上；但是普通hash会重新计算hash值，理论上会影响所有的数据","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1573169825,"ip_address":"","comment_id":149014,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5868094735","product_id":100035801,"comment_content":"老师请教一下  客户端一致性哈希算法 四到六个结点  如果四个结点的话  删除一个结点 依然会有四分之一的请求无法命中缓存  感觉这个一直性哈希算法和普通的哈希算法  没有太大区别呀  老师能不能再仔细简介一下这个地方  看不出一致性哈希算法的优势","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473707,"discussion_content":"在一致性hash下，如果删除一个节点，比如在一个环上有a，b，c三个节点，b故障，那么只有b的数据会迁移到c上；但是普通hash会重新计算hash值，理论上会影响所有的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573169825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2273081,"avatar":"https://static001.geekbang.org/account/avatar/00/22/af/39/56809e21.jpg","nickname":"舟行","note":"","ucode":"A3B5131690EFDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360252,"discussion_content":"在一致性算法上加个虚拟层影响就会小很多，就不会是四分之一了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616399624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2273081,"avatar":"https://static001.geekbang.org/account/avatar/00/22/af/39/56809e21.jpg","nickname":"舟行","note":"","ucode":"A3B5131690EFDE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364517,"discussion_content":"加了虚拟层依然会有1/4的数据受影响\n因为原数据节点上有大约1/4的数据没有，再次访问肯定会访问数据库，但只要并发量不大，缓存可以逐步迁移\n虚拟层只是为了数据的分布更加均衡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617507243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":360252,"ip_address":""},"score":364517,"extra":""}]},{"author":{"id":1101929,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","nickname":"张德","note":"","ucode":"31FE63E8725EFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47108,"discussion_content":"明白了  谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573272364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145383,"user_name":"胖胖虎","can_delete":false,"product_type":"c1","uid":1139121,"ip_address":"","ucode":"9CA8F99CC82944","user_header":"https://static001.geekbang.org/account/avatar/00/11/61/b1/1261c177.jpg","comment_is_top":false,"comment_ctime":1572262582,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5867229878","product_id":100035801,"comment_content":"看到老师最后的总结：<br>总体而言，分布式缓存的三种方案各有所长，有些团队可能在开发过程中已经积累了 Smart Client 上的一些经验；而有些团队在 Redis 运维上经验丰富，就可以推进 Sentinel 方案；有些团队在存储研发方面有些积累，就可以推进中间代理层方案，甚至可以自研适合自己业务场景的代理层组件，具体的选择还是要看团队的实际情况而定。<br><br>如果产品是从0开始，各方面没有太多积累，合理的选择是什么？之前我自己选的是Redis-Sentinel，因为这是官方支持的高可用模式，但是看到老师说对运维要求比较高，想了解一下需要重点关注哪些方面。","like_count":1,"discussions":[{"author":{"id":1139121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/61/b1/1261c177.jpg","nickname":"胖胖虎","note":"","ucode":"9CA8F99CC82944","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40788,"discussion_content":"我再描述一下我的场景吧，我的应用场景比较简单，主要是用来记录客户端的令牌，大约10万个客户端，每分钟会做一次同步，同步的时候会比对令牌的值，令牌10分钟更新一次。其实频度不高。设计中使用两台redis以哨兵模式部署。主要还是为了消除单点。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572268968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1139121,"avatar":"https://static001.geekbang.org/account/avatar/00/11/61/b1/1261c177.jpg","nickname":"胖胖虎","note":"","ucode":"9CA8F99CC82944","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364518,"discussion_content":"哨兵至少需要部署在3台机器上，跟两台redis都是部署在不同的机器上嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617507387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40788,"ip_address":""},"score":364518,"extra":""}]}]},{"had_liked":false,"id":142873,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1571571699,"is_pvip":false,"replies":[{"id":"55194","content":"1. 从概率学上保证，如果你虚拟出来的节点足够多，你无法保证绝对的均匀<br>2. 是的 虚拟节点也宕机了<br>3. 貌似是没有的，不过在一些memcached客户端代码中都会有实现","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571577795,"ip_address":"","comment_id":142873,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866538995","product_id":100035801,"comment_content":"老师，关于一致性hash有几点疑问，请老师解答：<br>1.为了防止hash环的倾斜，由实际节点虚拟出来的一部分虚拟节点是如何保证虚拟节点能均匀排列呢？还是说增加虚拟节点的算法可以自定义虚拟节点插入的位置呢？<br>2.假设一个真实节点宕机了，那是不是那个真实节点相对应的虚拟节点也“宕机”(不可用)了？<br>3.一致性hash算法在java里或者.net里面有现成的实现吗？若有是对应那个类呢？","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471304,"discussion_content":"1. 从概率学上保证，如果你虚拟出来的节点足够多，你无法保证绝对的均匀\n2. 是的 虚拟节点也宕机了\n3. 貌似是没有的，不过在一些memcached客户端代码中都会有实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571577795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142749,"user_name":"distdev","can_delete":false,"product_type":"c1","uid":1302798,"ip_address":"","ucode":"22AA05788627C6","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/0e/9ce05946.jpg","comment_is_top":false,"comment_ctime":1571490027,"is_pvip":false,"replies":[{"id":"55192","content":"sorry,我之前回复有误，在redis cluster中有高可用策略来保证的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571577251,"ip_address":"","comment_id":142749,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5866457323","product_id":100035801,"comment_content":"另外您说redis cluster不是高可用方案 为什么？","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471252,"discussion_content":"sorry,我之前回复有误，在redis cluster中有高可用策略来保证的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571577251,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142456,"user_name":"Chocolate","can_delete":false,"product_type":"c1","uid":1013822,"ip_address":"","ucode":"242CF0E3C10E97","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/3e/c39d86f1.jpg","comment_is_top":false,"comment_ctime":1571370917,"is_pvip":false,"replies":[{"id":"55093","content":"算是吧~","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571453908,"ip_address":"","comment_id":142456,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866338213","product_id":100035801,"comment_content":"老师，repcached 算不算 memcached 的服务端高可用方案","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471133,"discussion_content":"算是吧~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571453908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142349,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1571358483,"is_pvip":true,"replies":[{"id":"54884","content":"redis cluster不算是高可用方案","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571358976,"ip_address":"","comment_id":142349,"utype":1}],"discussion_count":8,"race_medal":0,"score":"5866325779","product_id":100035801,"comment_content":"老师 现在有redis cluster了 这个算哪种实现方案？","like_count":1,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471076,"discussion_content":"redis cluster不算是高可用方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571358976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099957,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c8/b5/b32ff06d.jpg","nickname":"千里不留行","note":"","ucode":"7F9C518E6E0DFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208880,"discussion_content":"没明白 redis cluster不算是高可用 。  实际部署每个主节点都要有一或多个从节点，主挂掉，进行主从切换","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584586872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36293,"discussion_content":"为什么么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571359856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1338831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/cf/ec335526.jpg","nickname":"jc9090kkk","note":"","ucode":"6C992D07A2E78F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36336,"discussion_content":"redis cluster的解决方案的核心部署基础在于cluster方案的主节点和子节点是一一对应的，其中主节点提供读写操作，从节点作为备用节点，只做数据异步复制（但并不能做到强一致性），不提供请求，只作为故障转移使用，部分节点不可用时，对于集群来讲是部分可用的。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升，而哨兵（sentinel）模式，主要是针对 Redis 数据节点中的主节点的高可用切换，对 Redis 的数据节点做失败判定分为主观下线和客观下线两种，对于 Redis 的从节点有对节点做主观下线操作，并不执行故障转移，这两种方案作对比，哨兵模式的优点更多一点，比如部署相对简单，主从高可用判定成本也相对较小，而且哨兵模式也是官方推荐的解决方案，从整体的优缺点来看，哨兵模式的高可用性是要比cluster要高一些的，但不是说cluster就完全不能做到高可用，只是付出的成本更高一些，希望能帮助到你","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571364309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36293,"ip_address":""},"score":36336,"extra":""},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1338831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/cf/ec335526.jpg","nickname":"jc9090kkk","note":"","ucode":"6C992D07A2E78F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36338,"discussion_content":"明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571364664,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36336,"ip_address":""},"score":36338,"extra":""},{"author":{"id":1001861,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/49/85/3f161d95.jpg","nickname":"Alpha","note":"","ucode":"60CA15A25EC796","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1338831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/cf/ec335526.jpg","nickname":"jc9090kkk","note":"","ucode":"6C992D07A2E78F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36352,"discussion_content":"Cluster模式能做到数据分片提高可扩展性，这是哨兵模式不能做到的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571366781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36336,"ip_address":""},"score":36352,"extra":""}]}]},{"had_liked":false,"id":319438,"user_name":"亚林","can_delete":false,"product_type":"c1","uid":1018972,"ip_address":"","ucode":"4A5A6D24314B79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","comment_is_top":false,"comment_ctime":1635815860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635815860","product_id":100035801,"comment_content":"必须是甩运维","like_count":0},{"had_liked":false,"id":318323,"user_name":"mghio","can_delete":false,"product_type":"c1","uid":1213078,"ip_address":"","ucode":"74883EDE4FD0DC","user_header":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","comment_is_top":false,"comment_ctime":1635240918,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1635240918","product_id":100035801,"comment_content":"【备份】是解决高可用的最好的方式！","like_count":0},{"had_liked":false,"id":314860,"user_name":"xueping","can_delete":false,"product_type":"c1","uid":2530432,"ip_address":"","ucode":"8A5DA6F1DB6FCD","user_header":"https://static001.geekbang.org/account/avatar/00/26/9c/80/b1137584.jpg","comment_is_top":false,"comment_ctime":1633508856,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1633508856","product_id":100035801,"comment_content":"问个问题，客户端方案的缓存节点是说redis或memcache的节点吗？","like_count":0},{"had_liked":false,"id":276742,"user_name":"K菌无惨","can_delete":false,"product_type":"c1","uid":2194764,"ip_address":"","ucode":"97A532D588FD49","user_header":"","comment_is_top":false,"comment_ctime":1612097618,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612097618","product_id":100035801,"comment_content":"文章说Memcached不支持主从模式,但是配图里面从库数据的写入确是从主库那边同步过去的?这还算是客户端方案吗","like_count":0},{"had_liked":false,"id":265857,"user_name":"不工","can_delete":false,"product_type":"c1","uid":1462843,"ip_address":"","ucode":"A8725E6D0E1765","user_header":"https://static001.geekbang.org/account/avatar/00/16/52/3b/f1501d79.jpg","comment_is_top":false,"comment_ctime":1607052910,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607052910","product_id":100035801,"comment_content":"一致性hash中的虚拟节点没怎么看懂，能够用图展示出来吗？还有一致性hash有什么实现的组件吗？","like_count":0},{"had_liked":false,"id":253251,"user_name":"聪","can_delete":false,"product_type":"c1","uid":1009831,"ip_address":"","ucode":"9D672A8580A945","user_header":"https://static001.geekbang.org/account/avatar/00/0f/68/a7/c3fd1fd9.jpg","comment_is_top":false,"comment_ctime":1602662784,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1602662784","product_id":100035801,"comment_content":"其实难点在于需要把高速缓存当做数据库用，意思就是，要利用缓存的快，还要强一致性，可惜牺牲一定的HA高可用。<br><br>一般文章里面的描述都是当缓存用，失效了可以去后面数据库拿。我组里一个case是存dup，大量的dup存在redis上面。要求读写强一致性，还要latency低。现在的方案基本上是shard data，然后每个数据中心弄5个cluster，每个cluster放3个redis server，这3个server存一样的keys。这样client读三个server，只有数据一致时候（0，1，无）就判定当前是否是duplicate。<br><br>我们是想改成用consistent hashing 然后利用client的内存，去直接存这些keys，这样就不用维护很多的redis clusters。但是不是很成功，要重写基本上要考虑太多事情。<br><br>","like_count":0,"discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364524,"discussion_content":"每个cluster机器故障，也会故障，可用性设置存在问题吧\n为什么不把cluster存的keys交替在不同机器上呢？\n\n每个cluster放3个redis server，每个内存足够嘛？\n要是为了高效利用CPU，是不是应该部署3个redis server？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617507972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243562,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1616970,"ip_address":"","ucode":"A5735665E303FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UXuSevhia94o9Eky4OfMuSictaldxcqpjGuvRCOcvjIIoVBAENLEZbv2lgwmwC8icK1ZrUcneNtiaeFBV8MT3uzNg/132","comment_is_top":false,"comment_ctime":1598187342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598187342","product_id":100035801,"comment_content":"哨兵机制主从切换，实现了高可用，客户端和中间代理方案分片，解决了单击资源限制的问题","like_count":0},{"had_liked":false,"id":232755,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1594109937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594109937","product_id":100035801,"comment_content":"老师，想问下 Memcached 主从机制，为每一组 master 配置一组 slave，请问这里的一组 master 是指一个 master 还是多个 master?","like_count":0},{"had_liked":false,"id":227892,"user_name":"王俊","can_delete":false,"product_type":"c1","uid":1070496,"ip_address":"","ucode":"C513020E635FF4","user_header":"https://static001.geekbang.org/account/avatar/00/10/55/a0/d66b6c74.jpg","comment_is_top":false,"comment_ctime":1592522957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592522957","product_id":100035801,"comment_content":"sentinel 是无状态的，它保存了 master 的数据，感觉保存了状态信息啊，sentinel是有状态的吧？","like_count":0},{"had_liked":false,"id":224523,"user_name":"Sam_Deep_Thinking","can_delete":false,"product_type":"c1","uid":1001152,"ip_address":"","ucode":"8E4EF6F24B821B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/46/c0/bf880bda.jpg","comment_is_top":false,"comment_ctime":1591430522,"is_pvip":true,"replies":[{"id":"82712","content":"篇幅限制，只讲解了分布式缓存","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1591538267,"ip_address":"","comment_id":224523,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591430522","product_id":100035801,"comment_content":"怎么没讲到本地缓存和堆外缓存，这种也是应付瞬时大流量的缓存方案。","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497510,"discussion_content":"篇幅限制，只讲解了分布式缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591538267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213068,"user_name":"Omer","can_delete":false,"product_type":"c1","uid":1676246,"ip_address":"","ucode":"8EE3E531313265","user_header":"https://static001.geekbang.org/account/avatar/00/19/93/d6/040e4965.jpg","comment_is_top":false,"comment_ctime":1588295660,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588295660","product_id":100035801,"comment_content":"老师，请教个问题。<br>我看到你文中说的，一致性hash的脏数据问题。我想问的是，如果是普通的hash算法出现一样的节点挂掉的情况，会如何处理呢？","like_count":0},{"had_liked":false,"id":197426,"user_name":"Lin大坑haha~","can_delete":false,"product_type":"c1","uid":1307653,"ip_address":"","ucode":"1C0AC3009FA6CB","user_header":"https://static001.geekbang.org/account/avatar/00/13/f4/05/cbcaaef1.jpg","comment_is_top":false,"comment_ctime":1585377205,"is_pvip":false,"replies":[{"id":"74906","content":"有一些从数据库同步数据到缓存的组件","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1585541640,"ip_address":"","comment_id":197426,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585377205","product_id":100035801,"comment_content":"缓存和数据库的同步机制，有没有开源的框架实现呢？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489518,"discussion_content":"有一些从数据库同步数据到缓存的组件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585541640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181413,"user_name":"小洛","can_delete":false,"product_type":"c1","uid":1005062,"ip_address":"","ucode":"227EC21891012B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/06/ea49b29d.jpg","comment_is_top":false,"comment_ctime":1582536738,"is_pvip":false,"replies":[{"id":"71108","content":"谢谢鼓励~","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1583115431,"ip_address":"","comment_id":181413,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582536738","product_id":100035801,"comment_content":"多副本就是缓存的缓存。解决单组m&#47;s的单机瓶颈，其实都是为了抵抗大流量，很多问题的解决思路都是相通的，谢谢老师分享","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484994,"discussion_content":"谢谢鼓励~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583115431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167245,"user_name":"什么也不说","can_delete":false,"product_type":"c1","uid":1053685,"ip_address":"","ucode":"1FAB54FA4CAB7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/f5/21fd4868.jpg","comment_is_top":false,"comment_ctime":1577751209,"is_pvip":false,"replies":[{"id":"65162","content":"多副本你可以认为是缓存的缓存，也就是在缓存之上再加一组缓存，可以解决单组缓存的带宽瓶颈<br><br>而在实践过程中，因为大部分流量都会被副本承担，master和slave的数据有可能会变得不热，所以可以把master和slave当做副本","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1577955293,"ip_address":"","comment_id":167245,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1577751209","product_id":100035801,"comment_content":"老师，多副本能举个例子吗？这块没看明白<br>先是说一组slave会有问题<br>在这个方案中，当客户端发起查询请求时，请求首先会先从多个副本组中选取一个副本组发起查询，如果查询失败，就继续查询 Master&#47;Slave，并且将查询的结果回种到所有副本组中，避免副本组中脏数据的存在。<br><br>最后说在实践中我们会把 Master 和 Slave 作为一组副本组使用。","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479793,"discussion_content":"多副本你可以认为是缓存的缓存，也就是在缓存之上再加一组缓存，可以解决单组缓存的带宽瓶颈\n\n而在实践过程中，因为大部分流量都会被副本承担，master和slave的数据有可能会变得不热，所以可以把master和slave当做副本","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577955293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1242061,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f3/cd/7eaf13fb.jpg","nickname":"星星","note":"","ucode":"2A9C7943C9AEF3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588041,"discussion_content":"多级缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663490435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164749,"user_name":"青青子衿","can_delete":false,"product_type":"c1","uid":1438102,"ip_address":"","ucode":"4A388A3BA70C29","user_header":"https://static001.geekbang.org/account/avatar/00/15/f1/96/9571fa3d.jpg","comment_is_top":false,"comment_ctime":1577085765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577085765","product_id":100035801,"comment_content":"redis cluster能不能详细的说说呢？","like_count":0},{"had_liked":false,"id":156569,"user_name":"overland","can_delete":false,"product_type":"c1","uid":1208835,"ip_address":"","ucode":"609A463519E5F0","user_header":"https://static001.geekbang.org/account/avatar/00/12/72/03/da1fcc81.jpg","comment_is_top":false,"comment_ctime":1574915013,"is_pvip":false,"replies":[{"id":"60229","content":"每个副本里面都有热数据","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1575014896,"ip_address":"","comment_id":156569,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574915013","product_id":100035801,"comment_content":"老师，那个多副本那块，是每个副本里面存着三个缓存的的热点数据还是，对应的缓存有个副本","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476155,"discussion_content":"每个副本里面都有热数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575014896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154544,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1574477920,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574477920","product_id":100035801,"comment_content":"老师，Redis没有部署哨兵之前，使用集群部署。当单台服务器出现故障时，造成部分片区不可用，Redis是怎么解决这个问题的？还是根本就没解决呢？<br><br>按老师的思路我觉得会有几种方案：<br>第一种方案：Redis设置该片区不可用，然后顺延到下一个片区。<br>第二种方案：运维手工解决，把这个片区划分到其他片区，也就是重新分片。","like_count":0},{"had_liked":false,"id":151085,"user_name":"天青","can_delete":false,"product_type":"c1","uid":1603286,"ip_address":"","ucode":"F592CC19954081","user_header":"https://static001.geekbang.org/account/avatar/00/18/76/d6/a9f381bf.jpg","comment_is_top":false,"comment_ctime":1573651732,"is_pvip":false,"replies":[{"id":"58449","content":"多副本应该可以一定程度上缓解热点数据的问题，因为它的一个主要作用就是抗流量<br><br>本地缓存确实可以解决热点的问题","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1573867161,"ip_address":"","comment_id":151085,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573651732","product_id":100035801,"comment_content":"老师您好，文中的多副本可以解决缓存的热点数据的问题吗？我的理解是在应用服务和缓存服务之间加本地缓存层存储热点数据，起这样吗？还有没有其他解决缓存的热点数据的方式？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474360,"discussion_content":"多副本应该可以一定程度上缓解热点数据的问题，因为它的一个主要作用就是抗流量\n\n本地缓存确实可以解决热点的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573867161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150439,"user_name":"fdconan","can_delete":false,"product_type":"c1","uid":1244596,"ip_address":"","ucode":"01C71C6E9FD1E4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLv9HJIW4OACkjlwOQJ9cU7HzvaDFYkACWCib2lzOMef9ZiaGDTVFqjPicpVK5KDRbBRVGGHrMHQO1Rw/132","comment_is_top":false,"comment_ctime":1573534214,"is_pvip":false,"replies":[{"id":"57975","content":"服务端方案是组件自带的，代理层是在组件之上的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1573610945,"ip_address":"","comment_id":150439,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573534214","product_id":100035801,"comment_content":"请教下，中间层代理方案和服务端方案有什么不同吗？文中没有详细说明哦。","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474159,"discussion_content":"服务端方案是组件自带的，代理层是在组件之上的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573610945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144927,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1572097246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572097246","product_id":100035801,"comment_content":"老师，我认为从另一个角度来讲，本篇分为两部分：缓存分片，主从机制。缓存分片可以客户端分，中间件分，服务端分，实现的原理我理解差不多，只是功能在的位置不同。主从机制，只能在服务端实现。","like_count":0},{"had_liked":false,"id":144552,"user_name":"扬一场远远的风","can_delete":false,"product_type":"c1","uid":1357801,"ip_address":"","ucode":"AB47E3D2EAB8A8","user_header":"https://static001.geekbang.org/account/avatar/00/14/b7/e9/5400cdf3.jpg","comment_is_top":false,"comment_ctime":1571968018,"is_pvip":false,"replies":[{"id":"55719","content":"大概4核8G，机械硬盘<br>如果机器配置更好，肯定能撑的读请求更高","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571974045,"ip_address":"","comment_id":144552,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571968018","product_id":100035801,"comment_content":"您好，文章中有说MySql的峰值读请求是1500，请问一下这是在什么样的机器配置下？如果硬盘是Ssd，CPU也是多核，且Mysql的buffer能设置好几个Ｇ，万兆网卡的机器配置下是否还是不能超过1500？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472005,"discussion_content":"大概4核8G，机械硬盘\n如果机器配置更好，肯定能撑的读请求更高","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571974045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019332,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","nickname":"长期规划","note":"","ucode":"5EF65E9115834B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86940,"discussion_content":"4核8G的QPS才1500，感觉好低啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576633415,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144279,"user_name":"刺猬","can_delete":false,"product_type":"c1","uid":1108297,"ip_address":"","ucode":"60C3E38F4F03CC","user_header":"https://static001.geekbang.org/account/avatar/00/10/e9/49/29072f9e.jpg","comment_is_top":false,"comment_ctime":1571887223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571887223","product_id":100035801,"comment_content":"老实说缓存的高可用的三种方案区分有点模糊，用一般思维去读这个，有点懵，尤其是客户端方案。","like_count":0},{"had_liked":false,"id":143517,"user_name":"开心小毛","can_delete":false,"product_type":"c1","uid":1023762,"ip_address":"","ucode":"9D57A2773759F3","user_header":"","comment_is_top":false,"comment_ctime":1571723176,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571723176","product_id":100035801,"comment_content":"请问老师，在Memcache实现主从机制的例子中，从机较主机有什么不同么(过期时间短？体积小？速度快？）否则又如何保证在从机未命中的前提下主机命中概率能更大？","like_count":0},{"had_liked":false,"id":143314,"user_name":"Keith","can_delete":false,"product_type":"c1","uid":1193337,"ip_address":"","ucode":"B40774090714D1","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/79/21647da2.jpg","comment_is_top":false,"comment_ctime":1571666894,"is_pvip":false,"replies":[{"id":"55353","content":"1.是的，对于缓存来说，应用就是它的客户端<br>2.单独部署","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571701060,"ip_address":"","comment_id":143314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571666894","product_id":100035801,"comment_content":"你好, 关于客户端模式:<br>1. 客户端模式是指用户代码的服务端(以我们的电商系统为例)吗?<br>2. 客户端模式的缓存存放在何处?","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471483,"discussion_content":"1.是的，对于缓存来说，应用就是它的客户端\n2.单独部署","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571701060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143249,"user_name":"陈靖","can_delete":false,"product_type":"c1","uid":1147418,"ip_address":"","ucode":"8C9596A54DB5C8","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/1a/64ec25ff.jpg","comment_is_top":false,"comment_ctime":1571655353,"is_pvip":false,"replies":[{"id":"55359","content":"客户端代表是缓存的客户端，也就是缓存的调用方，就是你的应用<br>服务端代表缓存的服务端","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571701388,"ip_address":"","comment_id":143249,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571655353","product_id":100035801,"comment_content":"没搞懂客户端和服务端代表啥","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471447,"discussion_content":"客户端代表是缓存的客户端，也就是缓存的调用方，就是你的应用\n服务端代表缓存的服务端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571701388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142817,"user_name":"良记","can_delete":false,"product_type":"c1","uid":1033503,"ip_address":"","ucode":"F78CC56BB32D8F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c5/1f/485fcff9.jpg","comment_is_top":false,"comment_ctime":1571542489,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571542489","product_id":100035801,"comment_content":"个人感觉Redis Sentinel和微服务中的Eureka是比较类似的模式，那么Sentinel在重新选主的时候是不是不可用的？这样对于一个要求高的系统来说也是非常不利的一件事吧？","like_count":0},{"had_liked":false,"id":142748,"user_name":"distdev","can_delete":false,"product_type":"c1","uid":1302798,"ip_address":"","ucode":"22AA05788627C6","user_header":"https://static001.geekbang.org/account/avatar/00/13/e1/0e/9ce05946.jpg","comment_is_top":false,"comment_ctime":1571489905,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1571489905","product_id":100035801,"comment_content":"能否谈谈replica之间一致性方案的取舍？简单的主从  同步还是异步  所有读写都访问主或者如您课中所说的 写访问主 读访问从  另外是否有人采用paxos这样的方案 或者还有其他的方案吗？ 谢谢","like_count":0},{"had_liked":false,"id":142732,"user_name":"longslee","can_delete":false,"product_type":"c1","uid":1465986,"ip_address":"","ucode":"C24E32E5B1B6F5","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/82/438c8534.jpg","comment_is_top":false,"comment_ctime":1571482882,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1571482882","product_id":100035801,"comment_content":"那么，老师再问一下，Redis 的 slot，是否也跟一致性hash一样的，如果一个节点移除或者挂掉，以前属于这个节点的key，也会在下一次首次使用的时候，数据需要穿透？","like_count":0,"discussions":[{"author":{"id":1762252,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e3/cc/0947ff0b.jpg","nickname":"nestle","note":"","ucode":"469800BED81B54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185134,"discussion_content":"每段slot可以配一个master和多个slave。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582597200,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142707,"user_name":"斐波那契","can_delete":false,"product_type":"c1","uid":1464006,"ip_address":"","ucode":"85E2EBC01392B1","user_header":"https://static001.geekbang.org/account/avatar/00/16/56/c6/0b449bc6.jpg","comment_is_top":false,"comment_ctime":1571469437,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571469437","product_id":100035801,"comment_content":"刚刚看了这片文章脑子里就灵光一闪 对于思考题 我觉得可以借鉴操作系统系统里的tlb 就是在缓存成在加一个缓存 这个缓存就是web存在本地（不同于cookie 但具体怎么样还没想清楚 只是突发奇想）","like_count":0},{"had_liked":false,"id":142556,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1571395036,"is_pvip":false,"replies":[{"id":"55090","content":"1. 是一致性hash算法决定的，A的连接出了问题，会按照圆环上的顺序从下一个节点取<br>2. 因为副本组的容量比主从小，所以它的数据更少，相对来说会读写热点一些的数据<br>3. 副本组就相当于slave的slave的概念，只是它有多组，可以抗更高的流量","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571453797,"ip_address":"","comment_id":142556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571395036","product_id":100035801,"comment_content":"1. 一致性Hash的脏数据问题里，缓存A和客户端连接出现问题，为什么客户端就能写入到B了呢？<br>2. 多副本的方案里，为什么说副本组只存储了更加热的数据？非热点数据不从副本组查询么？只要查询，不是依旧会写入？<br>这个解决方案第一次见，感觉怪怪的。担心slave的承载能力，是不是给slave再接slave就好了呢？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471174,"discussion_content":"1. 是一致性hash算法决定的，A的连接出了问题，会按照圆环上的顺序从下一个节点取\n2. 因为副本组的容量比主从小，所以它的数据更少，相对来说会读写热点一些的数据\n3. 副本组就相当于slave的slave的概念，只是它有多组，可以抗更高的流量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571453797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142426,"user_name":"Alpha","can_delete":false,"product_type":"c1","uid":1001861,"ip_address":"","ucode":"60CA15A25EC796","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/85/3f161d95.jpg","comment_is_top":false,"comment_ctime":1571366875,"is_pvip":false,"replies":[{"id":"55094","content":"是的，是由客户端来做的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571453921,"ip_address":"","comment_id":142426,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571366875","product_id":100035801,"comment_content":"请问老师memcached主从方案中是怎么做主从数据同步的，客户端双写吗？","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471121,"discussion_content":"是的，是由客户端来做的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571453921,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142418,"user_name":"吃饭饭","can_delete":false,"product_type":"c1","uid":1231549,"ip_address":"","ucode":"95CFA07CDA2957","user_header":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","comment_is_top":false,"comment_ctime":1571365491,"is_pvip":false,"replies":[{"id":"55096","content":"1. 是的，redis的高可用方案比较成熟<br>2. 虚拟节点其实是想让穿透发生到多个节点上","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571453962,"ip_address":"","comment_id":142418,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571365491","product_id":100035801,"comment_content":"感觉老师默认把目光集中在 Redis 上了，因为文中的哨兵模式和主从复制都是 Redis 的吧。还有我感觉出现虚拟节点主要用来解决 Hash 倾斜，望指教","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471115,"discussion_content":"1. 是的，redis的高可用方案比较成熟\n2. 虚拟节点其实是想让穿透发生到多个节点上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571453962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":142358,"user_name":"饭团","can_delete":false,"product_type":"c1","uid":1332557,"ip_address":"","ucode":"E24F240CC91BE8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","comment_is_top":false,"comment_ctime":1571359537,"is_pvip":false,"replies":[{"id":"55098","content":"数据更新的时候要同时更新副本组的","user_name":"作者回复","user_name_real":"唐扬","uid":"1448977","ctime":1571454023,"ip_address":"","comment_id":142358,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1571359537","product_id":100035801,"comment_content":"老师，在m-s前添加一层副本层！那他的数据是怎么淘汰的呢？比如第一步我主从数据都是1 副本没有这时回来查，并且副本回写为1.过一会我的数据表为了2！但是副本数据没变！这种情况是咋处理的！","like_count":0,"discussions":[{"author":{"id":1448977,"avatar":"https://static001.geekbang.org/account/avatar/00/16/1c/11/4b45993d.jpg","nickname":"唐扬","note":"","ucode":"1AF4C4A4DBC6EF","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471081,"discussion_content":"数据更新的时候要同时更新副本组的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571454023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1762252,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e3/cc/0947ff0b.jpg","nickname":"nestle","note":"","ucode":"469800BED81B54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185100,"discussion_content":"感觉副本又增加了维护数据一致性的成本。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582595066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36885,"discussion_content":"哦 明白了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571456378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/cf/ec335526.jpg","nickname":"jc9090kkk","note":"","ucode":"6C992D07A2E78F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36327,"discussion_content":"你数据库更新了 难道不清理缓存系统吗？ 你这种情况是由你自己的业务代码中操作缓存读写或删除来保证的，缓存系统本身不做保证，缓存系统本身只做数据过期删除处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571363417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1332557,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erbY9UsqHZhhVoI69yXNibBBg0TRdUVsKLMg2UZ1R3NJxXdMicqceI5yhdKZ5Ad6CJYO0XpFHlJzIYQ/132","nickname":"饭团","note":"","ucode":"E24F240CC91BE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1338831,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/cf/ec335526.jpg","nickname":"jc9090kkk","note":"","ucode":"6C992D07A2E78F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36340,"discussion_content":"不不不，缓存肯定会更新，但是缓存上层还有一层副本！这层副本怎么更新？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571364744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36327,"ip_address":""},"score":36340,"extra":""}]}]}]}