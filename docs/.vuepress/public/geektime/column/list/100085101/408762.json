{"id":408762,"title":"07 | Mock 框架：怎么让测试变得可控？","content":"<p>你好，我是郑晔！</p><p>上一讲，我们谈到测试不好测，关键是软件设计问题。一个好的设计可以把很多实现细节从业务代码中隔离出去。</p><p>之所以要隔离出去，一个重要的原因就是这些实现细节不那么可控。比如，如果我们依赖了数据库，就需要保证这个数据库环境同时只有一个测试在用。理论上这样不是不可能，但成本会非常高。再比如，如果依赖了第三方服务，那么我们就没法控制它给我们返回预期的值。这样一来，很多出错的场景，我们可能都没法测试。</p><p>所以，在测试里，我们不能依赖于这些好不容易隔离出去的细节。否则，测试就会变得不稳定，这也是很多团队测试难做的重要原因。不依赖于这些细节，那我们的测试总需要有一个实现出现在所需组件的位置上吧？或许你已经想到答案了，没错，这就是我们这一讲要讲的 Mock 框架。</p><h2>从模式到框架</h2><p><strong>做测试，本质上就是在一个可控的环境下对被测系统/组件进行各种试探。</strong>拥有大量依赖于第三方代码，最大的问题就是不可控。</p><p>怎么把不可控变成可控？第一步自然是隔离，第二步就是用一个可控的组件代替不可控的组件。换言之，用一个假的组件代替真的组件。</p><p>这种用假组件代替真组件的做法，在测试中屡见不鲜，几乎成了标准的做法。但是，因为各种做法又有细微的差别，所以，如果你去了解这个具体做法会看到很多不同的名词，比如：Stub、Dummy、Fake、Spy、Mock 等等。实话说，你今天问我这些名词的差异，我也需要去查找相关的资料，不能给出一个立即的答复。它们之间确实存在差异，但差异几乎到了可以忽略不计的份上。</p><!-- [[[read_end]]] --><p>Gerard Meszaros 写过一本《<a href=\"https://book.douban.com/subject/1859393/\">xUnit Test Patterns</a>》，他给这些名词起了一个统一的名字，形成了一个新的模式：<a href=\"https://martinfowler.com/bliki/TestDouble.html\">Test Double（测试替身）</a>。其基本结构如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/0a/29/0a9ac08ddf1de69e90d917c36fe37929.jpg?wh=1188x721\" alt=\"\"></p><p>在这个图里，SUT 指的是被测系统（System Under Test），Test Double 就是与 SUT 进行交互的一个组件。有了我们之前的讲解，这个图应该不难看懂。</p><p>然而，这个名字也没有在业界得到足够广泛的传播，你更熟悉的说法应该是 Mock 对象。因为后来在这个模式广泛流行起来之前，Mock 框架先流行了起来。</p><h2>Mock 框架</h2><p>Mock 框架的基本逻辑很简单，创建一个模拟对象并设置它的行为，主要就是用什么样的参数调用时，给出怎样的反馈。虽然 Mock 框架本身的逻辑很简单，但前期也经过了很长一段时间的发展，什么东西可以 Mock  以及怎样去表现 Mock，不同的 Mock 框架给出了不同的答案。</p><p>今天我们的讨论就以 Mockito 这个框架作为我们讨论的基础，这也是目前 Java 社区最常用的 Mock 框架。</p><p>要学习 Mock 框架，必须要掌握它最核心的两个点：<strong>设置模拟对象</strong>与<strong>校验对象行为</strong>。</p><h3>设置 Mock 对象</h3><p>要设置一个模拟对象，首先要创建一个模拟对象。在实战中，我们已经见识过了。</p><pre><code>TodoItemRepository repository = mock(TodoItemRepository.class);\n</code></pre><p>接下来就是设置它的行为，下面是从实战中摘取的两个例子。</p><pre><code>when(repository.findAll()).thenReturn(of(new TodoItem(&quot;foo&quot;)));\nwhen(repository.save(any())).then(returnsFirstArg());\n</code></pre><p>一个好程序库其 API 要有很强的表达性，像前面这两段代码，即便我不解释，看语句本身也知道它做了些什么。</p><p><strong>模拟对象的设置核心就是两点：参数是什么样的以及对应的处理是什么样的。</strong></p><p>参数设置其实是一个参数匹配的过程，核心要回答的问题就是判断给出的实参是否满足这里设置的条件。像上面代码中，save 的写法表示任意参数都可以，我们也可以设置它是特定的值，比如像下面这样。</p><pre><code>when(repository.findByIndex(1)).thenReturn(new TodoItem(&quot;foo&quot;));\n</code></pre><p>其实它也是一个参数匹配的过程，只不过这里做了些省略，完整的写法应该是下面这样。</p><pre><code>when(repository.findByIndex(eq(1))).thenReturn(new TodoItem(&quot;foo&quot;));\n</code></pre><p>如果你有更复杂的参数匹配过程，甚至可以自己去实现一个匹配过程。但我强烈建议你不要这么做，因为测试应该是简单的。一般来说，<strong>相等和任意参数这两种用法在大多数情况下已经够用了。</strong></p><p>设置完参数，接下来，就是对应的处理。能够设置相应的处理，这是体现模拟对象可控的关键。前面的例子我们看到了如何设置相应的返回值，我们也可以抛出异常，模拟异常场景。</p><pre><code>when(repository.save(any())).thenThrow(IllegalArgumentException.class);\n</code></pre><p>同设置参数类似，相应的处理也可以写得很复杂，但我同样建议你不要这么做，原因也是一样的，测试要简单。<strong>知道怎样设置返回值，怎样抛出异常，已经足够大多数情况下使用了。</strong></p><h3>校验对象行为</h3><p>模拟对象的另外一个重要行为是校验对象行为，就是知道一个方法有没有按照预期的方式调用。比如，我们可以预期 save 函数在执行过程中得到了调用。</p><pre><code>verify(repository).save(any());\n</code></pre><p>这只是校验了 save 方法得到了调用，我们还可以校验这个方法调用了多少次。</p><pre><code>verify(repository, atLeast(3)).save(any());\n</code></pre><p>同样，校验也有很多可以设置的参数，但我同样不建议你把它用得太复杂了，<strong>就连verify 本身我都建议你不要用得太多</strong>。</p><p>verify 用起来会给人一种安全感，所以，会让人有一种多用的倾向，但这是一种错觉。我在讲测试框架时说过，verify 其实是一种断言。断言意味着这是一个函数应该具备的行为，是一种行为上的约定。</p><p>一旦设置了 verify，实际上也就约束了函数的实现。但 verify 约束的对象又是底层的组件，是一种实现细节。换言之，过度使用 verify 造成的结果就是把一个函数的实现细节约定死了。</p><p>过度使用 verify，在写代码的时候，你会有一种成就感。但是，一旦涉及代码修改，整个人就不好了。因为实现细节被 verify 锁定死，一旦修改代码，这些 verify 就很容易造成测试无法通过。</p><p><strong>测试应该测试的是接口行为，而不是内部实现</strong>。所以，verify 虽好，还是建议少用。如果有一些场景不用 verify 就没有什么可断言的了，那该用 verify 还是要用。</p><p>如果按照测试模式来说，设置 Mock 对象的行为应该算是 Stub，而校验对象行为的做法，才是 Mock。<strong>如果按照模式的说法，我们应该常用 Stub，少用 Mock。</strong></p><h2>Mock 框架的延伸</h2><p>Mock 框架的主要作用是模拟对象的行为，但作为一种软件设计思想，它却有着更大的影响。既然我们可以模拟对象行为，那本质上来说，我们也可以模拟其它东西。所以，后面也有一些基于这种模拟思想的框架，其中，目前行业中使用最为广泛的是模拟服务器。</p><p>模拟服务器顾名思义，它模拟的是服务器行为，现在在行业中广泛使用的模拟服务器主要是 HTTP 模拟服务器。HTTP 服务器的主要行为就是收到一个请求之后，给出一个应答，从行为上说，这与对象接受一系列参数，给出相应的处理如出一辙。</p><p>接下来我就以 Moco 为例，简单介绍一下模拟服务器。<a href=\"https://github.com/dreamhead/moco\">Moco</a> 是我自己编写的一个开源模拟服务器程序库，曾在 2013 年获得 Oracle 的 Duke 选择奖。（在《软件设计之美》中讲到程序库的设计时，我讲过 <a href=\"https://time.geekbang.org/column/article/267856\">Moco 整个设计的来龙去脉</a>。如果你有兴趣，可以去回顾一下。）</p><p>下面是一个使用了 Moco 的测试代码。</p><pre><code>public void should_return_expected_response() {\n  // 设置模拟服务器的信息\n  // 设置服务器访问的端口\n  HttpServer server = httpServer(12306);\n  // 访问/foo 这个 URI 时，返回 bar\n  server.request(by(uri(&quot;/foo&quot;))).response(&quot;bar&quot;); \n  \n  // 开始执行测试\n  running(server, () -&gt; {\n    // 这里用了 Apache HTTP库访问模拟服务器，实际上，可以使用你的真实项目\n    Content content = Request.Get(&quot;http://localhost:12306/foo&quot;)\n      .execute()\n      .returnContent();\n      \n    // 对结果进行断言\n    assertThat(content.asString(), is(&quot;bar&quot;));\n  });\n}\n</code></pre><p>在这段代码里，我们启动了一个 HTTP 服务器，当你访问 /foo 这个 URI 时，它会给你返回一个应答 bar。这其中最关键的一行代码就是设置请求应答的那行。</p><pre><code>server.request(by(uri(&quot;/foo&quot;))).response(&quot;bar&quot;); \n</code></pre><p>Moco 的 API 本身也有很强的表达性，通过代码本身你就能看到，这里就是设置了一个请求以及相应的应答。</p><p>Moco 的配置支持很多的 HTTP 元素，像下面这段代码，你可以同时匹配请求内容和 URI，也可以同时设置应答文本和 HTTP 的状态码。</p><pre><code>server\n  .request(and(by(&quot;foo&quot;), by(uri(&quot;/foo&quot;))))\n  .response(and(with(text(&quot;bar&quot;)), status(200)));\n</code></pre><p>在上面的例子里面，running 是负责模拟服务器启停的代码，里面包含的代码就是，通过自己真实的服务代码发出的真实请求。</p><p>Moco 还支持 verify，如果你想像 Mock 框架那样去校验服务器是否收到了相应的请求，就可以使用它。</p><pre><code>RequestHit hit = requestHit();\nfinal HttpServer server = httpServer(port(), hit);\nrunning(server, () -&gt; {\n  ...\n})\n\nhit.verify(by(uri(&quot;/foo&quot;)), times(1));\n</code></pre><p>虽然 Moco 支持这样的能力，但同使用 Mock 框架类似，我也建议你少用 verify。</p><p>Moco 最大的价值就是让原本不可控的第三方 HTTP 服务器，现在可以按照我们预期的方式执行。比如，在真实的集成过程，你很难要求第三方服务器给你一个错误的应答，或者一个超时的应答，但使用 Moco 你就可以让它模拟出这样的行为。</p><p>Moco 还有一个很大的价值，原本你要做集成，唯一的选项是把整个系统跑起来，基本上就到了系统集成的范畴。而现在使用 Moco，验证工作可以用集成测试的代码就可以完成。作为程序员我们很清楚，相比于系统测试，这种做法轻太多了，一旦出现问题，定位起来也容易很多。从开发效率上看，这简直是数量级的提升。</p><p>Moco 不仅仅支持模拟 HTTP 服务器，还做了进一步延伸，支持模拟 WebSocket 服务器。</p><pre><code>HttpServer server = httpServer(12306);\nwebSocketServer = server.websocket(&quot;/ws&quot;);\nwebSocketServer.request(by(&quot;foo&quot;)).response(&quot;bar&quot;);\n</code></pre><p>无论是模拟 HTTP 服务器，还是模拟 WebSocket 服务器，本质上来说，它都是模拟对象这一思想的延伸。而所有这一切的出发点都是，我们希望在测试中得到一个可控的环境。</p><h2>总结时刻</h2><p>今天我们主要讲了 Mock 框架。Mock 框架是源自 Test Double（测试替身）这种测试模式。我们希望自己有一个可控的环境对被测系统/组件进行测试，背后的思想就是用假的却可控的组件去代替真实不可控的组件。</p><p>现在 Mock 框架已经成为了测试的重要组成部分，理解一个Mock框架核心就是要理解如何设置对象行为以及如何校验对象行为。设置对象行为主要是设置相应的参数以及对应的处理，无论这个处理是给出返回值，还是抛出异常。校验对象行为是一种断言，是看对象是否按照预期方式执行。不过，我给你提了一个醒，verify 虽好，尽量少用。</p><p>最后，我们还以 Moco 为例讲到了 Mock 框架的延伸，也就是模拟服务器。Moco 主要是模拟 HTTP 服务器，其核心就是对什么样的请求，给出什么样的应答。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>使用 Mock 框架，少用 verify。</strong></p><h2>思考题</h2><p>今天我们讲了 Mock 框架，你在实际工作中用到过 Mock 框架吗？它解决了你怎样的问题，或是你在使用它的过程中遇到怎样的困难，欢迎在留言区分享你的经验。</p>","neighbors":{"left":{"article_title":"06 | 测试不好做，为什么会和设计有关系？","id":408187},"right":{"article_title":"08 | 单元测试应该怎么写？","id":409822}},"comments":[{"had_liked":false,"id":307800,"user_name":"sylan215","can_delete":false,"product_type":"c1","uid":1019029,"ip_address":"","ucode":"5A2CF31BC69F40","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/95/4544d905.jpg","comment_is_top":false,"comment_ctime":1629260195,"is_pvip":false,"replies":[{"id":"111895","content":"多谢你的总结！","user_name":"作者回复","comment_id":307800,"uid":"1258861","ip_address":"","utype":1,"ctime":1629940605,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"23104096675","product_id":100085101,"comment_content":"1、这一讲主要是讲 Mock 的，对于自动化测试来说，这个技术确实很关键，当然，老师也在文中建议慎用，使用的前提是，我们真的明白这些技术的作用和副作用。<br><br>2、前一讲说了测试要减少耦合性，同时我们为了保证测试目的的唯一性，就引入了 Mock 技术，它一定程度上，让我们的关注点更集中；<br><br>3、和 Mock 技术类似，我们还可以了解 Stub、Dummy、Fake、Spy 等技术，同样是帮忙我们优化测试目的，简化测试实现的；<br><br>4、Mock 等模拟对象，可以让我们方便的模拟传参和不同返回值的情况，这些如果是在实际业务环境中，构造起来可能会非常麻烦；<br><br>5、非测试目的的过程中的 verify 要慎用，避免降低用例的适用性，也会增加用例的维护成本；<br><br>以上，期待后续的精彩内容。","like_count":6,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525292,"discussion_content":"多谢你的总结！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629940605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308225,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1629458480,"is_pvip":false,"replies":[{"id":"111674","content":"严格地说，第三方是否正常运行，这事不属于测试。如果采用测试的方式，第三方服务有一天宕机了，你的测试失败了，但你根本就没有动代码。所以，它无法起到测试应有的作用。所以，你真正需要的是一个监控程序，而不是一个测试。<br><br>当然，为了让人们注意到第三方服务的正确性，你专门做一个“测试”集合，在持续集成的服务以更长的周期运行，而不需要像普通的测试一样，每次提交都运行。","user_name":"作者回复","comment_id":308225,"uid":"1258861","ip_address":"","utype":1,"ctime":1629631362,"user_name_real":"郑晔"}],"discussion_count":4,"race_medal":0,"score":"14514360368","product_id":100085101,"comment_content":"请教一下老师， <br>把第三方mock掉了，<br>那么如何验证 我们请求第三方的参数是否正确， 我们到第三方的请求是否可以正常运行。","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525437,"discussion_content":"严格地说，第三方是否正常运行，这事不属于测试。如果采用测试的方式，第三方服务有一天宕机了，你的测试失败了，但你根本就没有动代码。所以，它无法起到测试应有的作用。所以，你真正需要的是一个监控程序，而不是一个测试。\n\n当然，为了让人们注意到第三方服务的正确性，你专门做一个“测试”集合，在持续集成的服务以更长的周期运行，而不需要像普通的测试一样，每次提交都运行。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1629631362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564992,"discussion_content":"第三方服务可能根本不需要测试，需要测试的是第三方服务的各种返回值对业务逻辑的影响。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1650368750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1158152,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ac/08/8b99367c.jpg","nickname":"topsion","note":"","ucode":"01366517C6F564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558650,"discussion_content":"请求参数也应该断言的。Mockitio提供的ArgumentCaptor","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648431305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1135528,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","nickname":"return","note":"","ucode":"42B8A3380DF04B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390221,"discussion_content":"明白了 非常感谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629717821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307855,"user_name":"grandgraph","can_delete":false,"product_type":"c1","uid":1016036,"ip_address":"","ucode":"B26060999DAA73","user_header":"","comment_is_top":false,"comment_ctime":1629282595,"is_pvip":false,"replies":[{"id":"111493","content":"按照你的逻辑，测试这个聚合服务就是要对其依赖的服务做Mock。这和单独的服务是否依赖于Repository没关系","user_name":"作者回复","comment_id":307855,"uid":"1258861","ip_address":"","utype":1,"ctime":1629335038,"user_name_real":"郑晔"}],"discussion_count":2,"race_medal":1,"score":"14514184483","product_id":100085101,"comment_content":"如果存在多层, 那么每层对下层依赖的对象都需要做Stub&#47;Mock吗? 比如AggregateService依赖多个Service对象, 而各个Service对象又有自己的Repository, 那么在测试AggregateService时, 需要对各个Service对象做Mock吗?","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525317,"discussion_content":"按照你的逻辑，测试这个聚合服务就是要对其依赖的服务做Mock。这和单独的服务是否依赖于Repository没关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629335038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577799,"discussion_content":"接口或者界面的理解，依赖的服务本质上就属于接口的实现层面了，仔细想想就明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656339421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307838,"user_name":"阿姆斯壮","can_delete":false,"product_type":"c1","uid":1265599,"ip_address":"","ucode":"87D5923D639CD6","user_header":"https://static001.geekbang.org/account/avatar/00/13/4f/bf/6584bdeb.jpg","comment_is_top":false,"comment_ctime":1629276414,"is_pvip":false,"replies":[{"id":"111494","content":"加油，向高水平程序员进军！","user_name":"作者回复","comment_id":307838,"uid":"1258861","ip_address":"","utype":1,"ctime":1629335757,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"14514178302","product_id":100085101,"comment_content":"今天又忍不住上来分享一下。把郑大之前的课程应用到工作之后。先从「坏味道」入手，利用函数式编程消除大量重复代码。不做CVS程序员。当工作和学习充分结合起来后，发现每天的工作都充满了乐趣。总感觉工作时间好快。（一天7个小时）不需要加班。可能我们公司是一个不务正业的IT公司。接下来，就是期待郑大的测试课。把自动化测试这块也应用到工作中。","like_count":4,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525310,"discussion_content":"加油，向高水平程序员进军！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629335757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308435,"user_name":"asusual","can_delete":false,"product_type":"c1","uid":2735468,"ip_address":"","ucode":"AF9AA546D3794F","user_header":"https://static001.geekbang.org/account/avatar/00/29/bd/6c/a988846d.jpg","comment_is_top":false,"comment_ctime":1629619355,"is_pvip":false,"replies":[{"id":"111697","content":"所谓经验，都是教训","user_name":"作者回复","comment_id":308435,"uid":"1258861","ip_address":"","utype":1,"ctime":1629687853,"user_name_real":"郑晔"}],"discussion_count":1,"race_medal":0,"score":"10219553947","product_id":100085101,"comment_content":"以前写测试基本都写了verify。现在看来郑大的观点非常准确~<br><br>过度使用 verify，在写代码的时候，你会有一种成就感。但是，一旦涉及代码修改，整个人就不好了。因为实现细节被 verify 锁定死，一旦修改代码，这些 verify 就很容易造成测试无法通过。","like_count":3,"discussions":[{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525490,"discussion_content":"所谓经验，都是教训","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629687853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307735,"user_name":"下弦の月","can_delete":false,"product_type":"c1","uid":1909916,"ip_address":"","ucode":"57D924C51679D4","user_header":"https://static001.geekbang.org/account/avatar/00/1d/24/9c/e32fe600.jpg","comment_is_top":false,"comment_ctime":1629221315,"is_pvip":false,"replies":[{"id":"111574","content":"你这个理解没问题","user_name":"作者回复","comment_id":307735,"uid":"1258861","ip_address":"","utype":1,"ctime":1629416638,"user_name_real":"郑晔"}],"discussion_count":3,"race_medal":0,"score":"5924188611","product_id":100085101,"comment_content":"是否可以这么理解？<br>有个待测的组件A，内部依赖组建B,会执行B.callFunc(); <br>同时，B还依赖于组建C,会执行 C.callMethod();<br><br>对A做单元测试的时候，我们需要隔离对B的依赖。Stub 做的事情是模拟一个B对象，设置好模拟B对象的 callFunc() 这个方法的输入与输出即可。<br><br>而Mock，除了上述的安排好输入与输出之外，还要对B.callFunc() 这个方法本身的行为做校验。比如verify(C,atLeast(1)).callMethod(any());<br><br>总结下来就是：如果只是准备一个被模拟对象的输入输出，就是Stub；如果要检查被模拟对象内部的行为，就是Mock。","like_count":2,"discussions":[{"author":{"id":1087302,"avatar":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","nickname":"北风一叶","note":"","ucode":"30310E66341D2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391653,"discussion_content":"我能说我看了这个，才理解文章啥意思么。。。。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1630566690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1258861,"avatar":"https://static001.geekbang.org/account/avatar/00/13/35/6d/07a42f81.jpg","nickname":"郑晔","note":"","ucode":"1EBD5AA5D4FC89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525267,"discussion_content":"你这个理解没问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629416638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1756505,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/59/493b8eab.jpg","nickname":"细心点","note":"","ucode":"F4D0EF8C71718E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588749,"discussion_content":"理解了 谢谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664072638,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348051,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1654690444,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654690444","product_id":100085101,"comment_content":"使用 Mock 框架，少用 verify。--记下来","like_count":0},{"had_liked":false,"id":341454,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1649636828,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649636828","product_id":100085101,"comment_content":"如何确定verify多写了，过度依赖，这有没有一个标准，如果我一个void返回的方法，需要处理单元测试，里面有几个依赖对象，那对于整个流程来说，我写单元测试肯定是需要verify调用到它们的时候入参是不是合法的，调用了几次，是不是这样的顺序调用，那这样势必要有多个verify？这块有点疑惑希望老师解答下","like_count":0},{"had_liked":false,"id":329204,"user_name":"ownraul","can_delete":false,"product_type":"c1","uid":1080963,"ip_address":"","ucode":"37A3D24BE83D0E","user_header":"https://static001.geekbang.org/account/avatar/00/10/7e/83/27fd9c50.jpg","comment_is_top":false,"comment_ctime":1641208235,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1641208235","product_id":100085101,"comment_content":"之前的代码中用了一个 RestTemplate 的mock 来模拟第三方的返回, 不好地方在于一旦使用了之后全部的  restTemplate 都被模拟, 用 Moco 直接模拟返回结果是个更加优雅的方式了, 只要把第三方的 url 都解耦开, 用本地不同的端口进行模拟就好","like_count":0}]}