{"id":740765,"title":"第 5 章 非原始值的响应式方案(2)","content":"<h2 id=\"nav_point_48\">5.4　合理地触发响应</h2>\n<p>上一节中，我们从规范的角度详细介绍了如何代理对象，在这个过程中，处理了很多边界条件。例如，我们需要明确知道操作的类型是 <code>'ADD'</code> 还是 <code>'SET'</code>，抑或是其他操作类型，从而正确地触发响应。但想要合理地触发响应，还有许多工作要做。</p>\n<p>首先，我们来看要面临的第一个问题，即当值没有发生变化时，应该不需要触发响应才对：</p>\n<pre class=\"code-rows\"><code> const obj = { foo: 1 }\n const p = new Proxy(obj, { /* ... */ })\n<p>effect(() =&gt; {<br />\nconsole.log(p.foo)<br />\n})</p>\n<p>// 设置 p.foo 的值，但值没有变化<br />\np.foo = 1<br />\n</code></pre></p>\n<p>如上面的代码所示，<code>p.foo</code> 的初始值为 <code>1</code>，当为 <code>p.foo</code> 设置新的值时，如果值没有发生变化，则不需要触发响应。为了满足需求，我们需要修改 <code>set</code> 拦截函数的代码，在调用 <code>trigger</code> 函数触发响应之前，需要检查值是否真的发生了变化：</p>\n<pre class=\"code-rows\"><code> const p = new Proxy(obj, {\n   set(target, key, newVal, receiver) {\n     // 先获取旧值\n     const oldVal = target[key]\n<pre><code> const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\n const res = Reflect.set(target, key, newVal, receiver)\n // 比较新值与旧值，只要当不全等的时候才触发响应\n if (oldVal !== newVal) {\n   trigger(target, key, type)\n }\n\n return res\n</code></pre>\n<p>},<br />\n})<br />\n</code></pre></p>\n<p>如上面的代码所示，我们在 <code>set</code> 拦截函数内首先获取旧值 <code>oldVal</code>，接着比较新值与旧值，只有当它们不全等的时候才触发响应。现在，如果我们再次测试本节开头的例子，会发现重新设置相同的值已经不会触发响应了。</p>\n<p>然而，仅仅进行全等比较是有缺陷的，这体现在对 <code>NaN</code> 的处理上。我们知道 <code>NaN</code> 与 <code>NaN</code> 进行全等比较总会得到 <code>false</code>：</p>\n<pre class=\"code-rows\"><code> NaN === NaN // false\n NaN !== NaN // true\n</code></pre>\n<p>换句话说，如果 <code>p.foo</code> 的初始值是 <code>NaN</code>，并且后续又为其设置了 <code>NaN</code> 作为新值，那么仅仅进行全等比较的缺陷就暴露了：</p>\n<pre class=\"code-rows\"><code> const obj = { foo: NaN }\n const p = new Proxy(obj, { /* ... */ })\n<p>effect(() =&gt; {<br />\nconsole.log(p.foo)<br />\n})</p>\n<p>// 仍然会触发响应，因为 NaN !== NaN 为 true<br />\np.foo = NaN<br />\n</code></pre></p>\n<p>这仍然会触发响应，并导致不必要的更新。为了解决这个问题，我们需要再加一个条件，即在新值和旧值不全等的情况下，要保证它们都不是 <code>NaN</code>：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code> const p = new Proxy(obj, {\n   set(target, key, newVal, receiver) {\n     // 先获取旧值\n     const oldVal = target[key]\n<pre><code> const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\n const res = Reflect.set(target, key, newVal, receiver)\n // 比较新值与旧值，只有当它们不全等，并且不都是 NaN 的时候才触发响应\n if (oldVal !== newVal &amp;amp;&amp;amp; (oldVal === oldVal || newVal === newVal)) {\n   trigger(target, key, type)\n }\n\n return res\n</code></pre>\n<p>},<br />\n})<br />\n</code></pre></p>\n<p>这样我们就解决了 <code>NaN</code> 的问题。</p>\n<p>但想要合理地触发响应，仅仅处理关于 <code>NaN</code> 的问题还不够。接下来，我们讨论一种从原型上继承属性的情况。为了后续讲解方便，我们需要封装一个 <code>reactive</code> 函数，该函数接收一个对象作为参数，并返回为其创建的响应式数据：</p>\n<pre class=\"code-rows\"><code> function reactive(obj) {\n   return new Proxy(obj, {\n     // 省略前文讲解的拦截函数\n   })\n }\n</code></pre>\n<p>可以看到，<code>reactive</code> 函数只是对 <code>Proxy</code> 进行了一层封装。接下来，我们基于 <code>reactive</code> 创建一个例子：</p>\n<pre class=\"code-rows\"><code> const obj = {}\n const proto = { bar: 1 }\n const child = reactive(obj)\n const parent = reactive(proto)\n // 使用 parent 作为 child 的原型\n Object.setPrototypeOf(child, parent)\n<p>effect(() =&gt; {<br />\nconsole.log(child.bar) // 1<br />\n})<br />\n// 修改 child.bar 的值<br />\nchild.bar = 2 // 会导致副作用函数重新执行两次<br />\n</code></pre></p>\n<p>观察如上代码，我们定义了空对象 <code>obj</code> 和对象 <code>proto</code>，分别为二者创建了对应的响应式数据 <code>child</code> 和 <code>parent</code>，并且使用 <code>Object.setPrototypeOf</code> 方法将 <code>parent</code> 设置为 <code>child</code> 的原型。接着，在副作用函数内访问 <code>child.bar</code> 的值。从代码中可以看出，<code>child</code> 本身并没有 <code>bar</code> 属性，因此当访问 <code>child.bar</code> 时，值是从原型上继承而来的。但无论如何，既然 <code>child</code> 是响应式数据，那么它与副作用函数之间就会建立联系，因此当我们执行 <code>child.bar = 2</code> 时，期望副作用函数会重新执行。但如果你尝试运行上面的代码，会发现副作用函数不仅执行了，还执行了两次，这会造成不必要的更新。</p>\n<p>为了搞清楚问题的原因，我们需要逐步分析整个过程。当在副作用函数中读取 <code>child.bar</code> 的值时，会触发 <code>child</code> 代理对象的 <code>get</code> 拦截函数。我们知道，在拦截函数内是使用 <code>Reflect.get(target, key, receiver)</code> 来得到最终结果的，对应到上例，这句话相当于：</p>\n<pre class=\"code-rows\"><code> Reflect.get(obj, 'bar', receiver)\n</code></pre>\n<p>这其实是实现了通过 <code>obj.bar</code> 来访问属性值的默认行为。也就是说，引擎内部是通过调用 <code>obj</code> 对象所部署的 <code>[[Get]]</code> 内部方法来得到最终结果的，因此我们有必要查看规范 10.1.8.1 节来了解 <code>[[Get]]</code> 内部方法的执行流程，如图 5-5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00514.jpeg\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-5　<code>[[Get]]</code> 内部方法的执行流程</strong></p>\n<p>图 5-5 中的第 3 步所描述的内容如下。</p>\n<blockquote>\n<p>3. 如果 <code>desc</code> 是 <code>undefined</code>，那么</p>\n<p>a. 让 <code>parent</code> 的值为 <code>? O.[[GetPrototypeOf]]()</code>。</p>\n<p>b. 如果 <code>parent</code> 是 <code>null</code>，则返回 <code>undefined</code>。</p>\n<p>c. 返回 <code>? parent.[[Get]](P, Receiver)</code>。</p>\n</blockquote>\n<p>在第 3 步中，我们能够了解到非常关键的信息，即如果对象自身不存在该属性，那么会获取对象的原型，并调用原型的 <code>[[Get]]</code> 方法得到最终结果。对应到上例中，当读取 <code>child.bar</code> 属性值时，由于 <code>child</code> 代理的对象 <code>obj</code> 自身没有 <code>bar</code> 属性，因此会获取对象 <code>obj</code> 的原型，也就是 <code>parent</code> 对象，所以最终得到的实际上是 <code>parent.bar</code> 的值。但是大家不要忘了，<code>parent</code> 本身也是响应式数据，因此在副作用函数中访问 <code>parent.bar</code> 的值时，会导致副作用函数被收集，从而也建立响应联系。所以我们能够得出一个结论，即 <code>child.bar</code> 和 <code>parent.bar</code> 都与副作用函数建立了响应联系。</p>\n<p>但这仍然解释不了为什么当设置 <code>child.bar</code> 的值时，会连续触发两次副作用函数执行，所以接下来我们需要看看当设置操作发生时的具体执行流程。我们知道，当执行 <code>child.bar = 2</code> 时，会调用 <code>child</code> 代理对象的 <code>set</code> 拦截函数。同样，在 <code>set</code> 拦截函数内，我们使用 <code>Reflect.set(target, key, newVal, receiver)</code> 来完成默认的设置行为，即引擎会调用 <code>obj</code> 对象部署的 <code>[[Set]]</code> 内部方法，根据规范的 10.1.9.2 节可知 <code>[[Set]]</code> 内部方法的执行流程，如图 5-6 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00515.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-6　<code>[[Set]]</code> 内部方法的执行流程</strong></p>\n<p>图 5-6 中第 2 步所描述的内容如下。</p>\n<blockquote>\n<p>2. 如果 <code>ownDesc</code> 是 <code>undefined</code>，那么</p>\n<p>a. 让 <code>parent</code> 的值为 <code>O.[[GetPrototypeOf]]()</code>。</p>\n<p>b. 如果 <code>parent</code> 不是 <code>null</code>，则</p>\n<p>　　I. 返回 <code>? parent.[[Set]](P, V, Receiver)</code>；</p>\n<p>c. 否则</p>\n<p>　　I. 将 <code>ownDesc</code> 设置为 <code>{ [[Value]]: undefined, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }</code>。</p>\n</blockquote>\n<p>由第 2 步可知，如果设置的属性不存在于对象上，那么会取得其原型，并调用原型的 <code>[[Set]]</code> 方法，也就是 <code>parent</code> 的 <code>[[Set]]</code> 内部方法。由于 <code>parent</code> 是代理对象，所以这就相当于执行了它的 <code>set</code> 拦截函数。换句话说，虽然我们操作的是 <code>child.bar</code>，但这也会导致 <code>parent</code> 代理对象的 <code>set</code> 拦截函数被执行。前面我们分析过，当读取 <code>child.bar</code> 的值时，副作用函数不仅会被 <code>child.bar</code> 收集，也会被 <code>parent.bar</code> 收集。所以当 <code>parent</code> 代理对象的 <code>set</code> 拦截函数执行时，就会触发副作用函数重新执行，这就是为什么修改 <code>child.bar</code> 的值会导致副作用函数重新执行两次。</p>\n<p>接下来，我们需要思考解决方案。思路很简单，既然执行两次，那么只要屏蔽其中一次不就可以了吗？我们可以把由 <code>parent.bar</code> 触发的那次副作用函数的重新执行屏蔽。怎么屏蔽呢？我们知道，两次更新是由于 <code>set</code> 拦截函数被触发了两次导致的，所以只要我们能够在 <code>set</code> 拦截函数内区分这两次更新就可以了。当我们设置 <code>child.bar</code> 的值时，会执行 <code>child</code> 代理对象的 <code>set</code> 拦截函数：</p>\n<pre class=\"code-rows\"><code> // child 的 set 拦截函数\n set(target, key, value, receiver) {\n   // target 是原始对象 obj\n   // receiver 是代理对象 child\n }\n</code></pre>\n<p>此时的 <code>target</code> 是原始对象 <code>obj</code>，<code>receiver</code> 是代理对象 <code>child</code>，我们发现 <code>receiver</code> <strong>其实就是</strong> <code>target</code> <strong>的代理对象</strong>。</p>\n<p>但由于 <code>obj</code> 上不存在 <code>bar</code> 属性，所以会取得 <code>obj</code> 的原型 <code>parent</code>，并执行 <code>parent</code> 代理对象的 <code>set</code> 拦截函数：</p>\n<pre class=\"code-rows\"><code> // parent 的 set 拦截函数\n set(target, key, value, receiver) {\n   // target 是原始对象 proto\n   // receiver 仍然是代理对象 child\n }\n</code></pre>\n<p>我们发现，当 <code>parent</code> 代理对象的 <code>set</code> 拦截函数执行时，此时 <code>target</code> 是原始对象 <code>proto</code>，而 <code>receiver</code> 仍然是代理对象 <code>child</code>，而<strong>不再是</strong> <code>target</code> <strong>的代理对象</strong>。通过这个特点，我们可以看到 <code>target</code> 和 <code>receiver</code> 的区别。由于我们最初设置的是 <code>child.bar</code> 的值，所以无论在什么情况下，<code>receiver</code> 都是 <code>child</code>，而 <code>target</code> 则是变化的。根据这个区别，我们很容易想到解决办法，只需要判断 <code>receiver</code> 是否是 <code>target</code> 的代理对象即可。只有当 <code>receiver</code> 是 <code>target</code> 的代理对象时才触发更新，这样就能够屏蔽由原型引起的更新了。</p>\n<p>所以接下来的问题变成了如何确定 <code>receiver</code> 是不是 <code>target</code> 的代理对象，这需要我们为 <code>get</code> 拦截函数添加一个能力，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> function reactive(obj) {\n   return new Proxy(obj {\n     get(target, key, receiver) {\n       // 代理对象可以通过 raw 属性访问原始数据\n       if (key === 'raw') {\n         return target\n       }\n<pre><code>   track(target, key)\n   return Reflect.get(target, key, receiver)\n }\n // 省略其他拦截函数\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>我们增加了一段代码，它实现的功能是，代理对象可以通过 <code>raw</code> 属性读取原始数据，例如：</p>\n<pre class=\"code-rows\"><code> child.raw === obj // true\n parent.raw === proto // true\n</code></pre>\n<p>有了它，我们就能够在 <code>set</code> 拦截函数中判断 <code>receiver</code> 是不是 <code>target</code> 的代理对象了：</p>\n<pre class=\"code-rows\"><code> function reactive(obj) {\n   return new Proxy(obj {\n     set(target, key, newVal, receiver) {\n       const oldVal = target[key]\n       const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\n       const res = Reflect.set(target, key, newVal, receiver)\n<pre><code>   // target === receiver.raw 说明 receiver 就是 target 的代理对象\n   if (target === receiver.raw) {\n     if (oldVal !== newVal &amp;amp;&amp;amp; (oldVal === oldVal || newVal === newVal)) {\n       trigger(target, key, type)\n     }\n   }\n\n   return res\n }\n // 省略其他拦截函数\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>如以上代码所示，我们新增了一个判断条件，只有当 <code>receiver</code> 是 <code>target</code> 的代理对象时才触发更新，这样就能屏蔽由原型引起的更新，从而避免不必要的更新操作。</p>\n<h2 id=\"nav_point_49\">5.5　浅响应与深响应</h2>\n<p>本节中我们将介绍 <code>reactive</code> 与 <code>shallowReactive</code> 的区别，即深响应和浅响应的区别。实际上，我们目前所实现的 <code>reactive</code> 是浅响应的。拿如下代码来说：</p>\n<pre class=\"code-rows\"><code> const obj = reactive({ foo: { bar: 1 } })\n<p>effect(() =&gt; {<br />\nconsole.log(obj.foo.bar)<br />\n})<br />\n// 修改 obj.foo.bar 的值，并不能触发响应<br />\nobj.foo.bar = 2<br />\n</code></pre></p>\n<p>首先，创建 <code>obj</code> 代理对象，该对象的 <code>foo</code> 属性值也是一个对象，即 <code>{ bar: 1 }</code>。接着，在副作用函数内访问 <code>obj.foo.bar</code> 的值。但是我们发现，后续对 <code>obj.foo.bar</code> 的修改不能触发副作用函数重新执行，这是为什么呢？来看一下现在的实现：</p>\n<pre class=\"code-rows\"><code> function reactive(obj) {\n   return new Proxy(obj {\n     get(target, key, receiver) {\n       if (key === 'raw') {\n         return target\n       }\n<pre><code>   track(target, key)\n   // 当读取属性值时，直接返回结果\n   return Reflect.get(target, key, receiver)\n }\n // 省略其他拦截函数\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>由上面这段代码可知，当我们读取 <code>obj.foo.bar</code> 时，首先要读取 <code>obj.foo</code> 的值。这里我们直接使用 <code>Reflect.get</code> 函数返回 <code>obj.foo</code> 的结果。由于通过 <code>Reflect.get</code> 得到 <code>obj.foo</code> 的结果是一个普通对象，即 <code>{ bar: 1 }</code>，它并不是一个响应式对象，所以在副作用函数中访问 <code>obj.foo.bar</code> 时，是不能建立响应联系的。要解决这个问题，我们需要对 <code>Reflect.get</code> 返回的结果做一层包装：</p>\n<pre class=\"code-rows\"><code> function reactive(obj) {\n   return new Proxy(obj {\n     get(target, key, receiver) {\n       if (key === 'raw') {\n         return target\n       }\n<pre><code>   track(target, key)\n   // 得到原始值结果\n   const res = Reflect.get(target, key, receiver)\n   if (typeof res === 'object' &amp;amp;&amp;amp; res !== null) {\n     // 调用 reactive 将结果包装成响应式数据并返回\n     return reactive(res)\n   }\n   // 返回 res\n   return res\n }\n // 省略其他拦截函数\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，当读取属性值时，我们首先检测该值是否是对象，如果是对象，则递归地调用 <code>reactive</code> 函数将其包装成响应式数据并返回。这样当使用 <code>obj.foo</code> 读取 <code>foo</code> 属性值时，得到的就会是一个响应式数据，因此再通过 <code>obj.foo.bar</code> 读取 <code>bar</code> 属性值时，自然就会建立响应联系。这样，当修改 <code>obj.foo.bar</code> 的值时，就能够触发副作用函数重新执行了。</p>\n<p>然而，并非所有情况下我们都希望深响应，这就催生了 <code>shallowReactive</code>，即浅响应。所谓浅响应，指的是只有对象的第一层属性是响应的，例如：</p>\n<pre class=\"code-rows\"><code> const obj = shallowReactive({ foo: { bar: 1 } })\n<p>effect(() =&gt; {<br />\nconsole.log(obj.foo.bar)<br />\n})<br />\n// obj.foo 是响应的，可以触发副作用函数重新执行<br />\nobj.foo = { bar: 2 }<br />\n// obj.foo.bar 不是响应的，不能触发副作用函数重新执行<br />\nobj.foo.bar = 3<br />\n</code></pre></p>\n<p>在这个例子中，我们使用 <code>shallowReactive</code> 函数创建了一个浅响应的代理对象 <code>obj</code>。可以发现，只有对象的第一层属性是响应的，第二层及更深层次的属性则不是响应的。实现此功能并不难，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 封装 createReactive 函数，接收一个参数 isShallow，代表是否为浅响应，默认为 false，即非浅响应\n function createReactive(obj, isShallow = false) {\n   return new Proxy(obj, {\n     // 拦截读取操作\n     get(target, key, receiver) {\n       if (key === 'raw') {\n         return target\n       }\n<pre><code>   const res = Reflect.get(target, key, receiver)\n\n   track(target, key)\n\n   // 如果是浅响应，则直接返回原始值\n   if (isShallow) {\n     return res\n   }\n\n   if (typeof res === 'object' &amp;amp;&amp;amp; res !== null) {\n     return reactive(res)\n   }\n\n   return res\n }\n // 省略其他拦截函数\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们把对象创建的工作封装到一个新的函数 <code>createReactive</code> 中。该函数除了接收原始对象 <code>obj</code> 之外，还接收参数 <code>isShallow</code>，它是一个布尔值，代表是否创建浅响应对象。默认情况下，<code>isShallow</code> 的值为 <code>false</code>，代表创建深响应对象。这里需要注意的是，当读取属性操作发生时，在 <code>get</code> 拦截函数内如果发现是浅响应的，那么直接返回原始数据即可。有了 <code>createReactive</code> 函数后，我们就可以使用它轻松地实现 <code>reactive</code> 以及 <code>shallowReactive</code> 函数了：</p>\n<pre class=\"code-rows\"><code> function reactive(obj) {\n   return createReactive(obj)\n }\n function shallowReactive(obj) {\n   return createReactive(obj, true)\n }\n</code></pre>\n<h2 id=\"nav_point_50\">5.6　只读和浅只读</h2>\n<p>我们希望一些数据是只读的，当用户尝试修改只读数据时，会收到一条警告信息。这样就实现了对数据的保护，例如组件接收到的 <code>props</code> 对象应该是一个只读数据。这时就要用到接下来要讨论的 <code>readonly</code> 函数，它能够将一个数据变成只读的：</p>\n<pre class=\"code-rows\"><code> const obj = readonly({ foo: 1 })\n // 尝试修改数据，会得到警告\n obj.foo = 2\n</code></pre>\n<p>只读本质上也是对数据对象的代理，我们同样可以使用 <code>createReactive</code> 函数来实现。如下面的代码所示，我们为 <code>createReactive</code> 函数增加第三个参数 <code>isReadonly</code>：</p>\n<pre class=\"code-rows\"><code> // 增加第三个参数 isReadonly，代表是否只读，默认为 false，即非只读\n function createReactive(obj, isShallow = false, isReadonly = false) {\n   return new Proxy(obj, {\n     // 拦截设置操作\n     set(target, key, newVal, receiver) {\n       // 如果是只读的，则打印警告信息并返回\n       if (isReadonly) {\n         console.warn(`属性 $ 是只读的`)\n         return true\n       }\n       const oldVal = target[key]\n       const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\n       const res = Reflect.set(target, key, newVal, receiver)\n       if (target === receiver.raw) {\n         if (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) {\n           trigger(target, key, type)\n         }\n       }\n<pre><code>   return res\n },\n deleteProperty(target, key) {\n   // 如果是只读的，则打印警告信息并返回\n   if (isReadonly) {\n     console.warn(`属性 $ 是只读的`)\n     return true\n   }\n   const hadKey = Object.prototype.hasOwnProperty.call(target, key)\n   const res = Reflect.deleteProperty(target, key)\n\n   if (res &amp;amp;&amp;amp; hadKey) {\n     trigger(target, key, 'DELETE')\n   }\n\n   return res\n }\n // 省略其他拦截函数\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>在这段代码中，当使用 <code>createReactive</code> 创建代理对象时，可以通过第三个参数指定是否创建一个只读的代理对象。同时，我们还修改了 <code>set</code> 拦截函数和 <code>deleteProperty</code> 拦截函数的实现，因为对于一个对象来说，只读意味着既不可以设置对象的属性值，也不可以删除对象的属性。在这两个拦截函数中，我们分别添加了是否是只读的判断，一旦数据是只读的，则当这些操作发生时，会打印警告信息，提示用户这是一个非法操作。</p>\n<p>当然，如果一个数据是只读的，那就意味着任何方式都无法修改它。因此，没有必要为只读数据建立响应联系。出于这个原因，当在副作用函数中读取一个只读属性的值时，不需要调用 <code>track</code> 函数追踪响应：</p>\n<pre class=\"code-rows\"><code> const obj = readonly({ foo: 1 })\n effect(() =&gt; {\n   obj.foo // 可以读取值，但是不需要在副作用函数与数据之间建立响应联系\n })\n</code></pre>\n<p>为了实现该功能，我们需要修改 <code>get</code> 拦截函数的实现：</p>\n<pre class=\"code-rows\"><code> function createReactive(obj, isShallow = false, isReadonly = false) {\n   return new Proxy(obj, {\n     // 拦截读取操作\n     get(target, key, receiver) {\n       if (key === 'raw') {\n         return target\n       }\n       // 非只读的时候才需要建立响应联系\n       if (!isReadonly) {\n         track(target, key)\n       }\n<pre><code>   const res = Reflect.get(target, key, receiver)\n\n   if (isShallow) {\n     return res\n   }\n\n   if (typeof res === 'object' &amp;amp;&amp;amp; res !== null) {\n     return reactive(res)\n   }\n\n   return res\n }\n // 省略其他拦截函数\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，在 <code>get</code> 拦截函数内检测 <code>isReadonly</code> 变量的值，判断是否是只读的，只有在非只读的情况下才会调用 <code>track</code> 函数建立响应联系。基于此，我们就可以实现 <code>readonly</code> 函数了：</p>\n<pre class=\"code-rows\"><code> function readonly(obj) {\n   return createReactive(obj, false, true /* 只读 */)\n }\n</code></pre>\n<p>然而，上面实现的 <code>readonly</code> 函数更应该叫作 <code>shallowReadonly</code>，因为它没有做到深只读：</p>\n<pre class=\"code-rows\"><code> const obj = readonly({ foo: { bar: 1 } })\n obj.foo.bar = 2 // 仍然可以修改\n</code></pre>\n<p>所以为了实现深只读，我们还应该在 <code>get</code> 拦截函数内递归地调用 <code>readonly</code> 将数据包装成只读的代理对象，并将其作为返回值返回：</p>\n<pre class=\"code-rows\"><code> function createReactive(obj, isShallow = false, isReadonly = false) {\n   return new Proxy(obj, {\n     // 拦截读取操作\n     get(target, key, receiver) {\n       if (key === 'raw') {\n         return target\n       }\n       if (!isReadonly) {\n         track(target, key)\n       }\n<pre><code>   const res = Reflect.get(target, key, receiver)\n\n   if (isShallow) {\n     return res\n   }\n\n   if (typeof res === 'object' &amp;amp;&amp;amp; res !== null) {\n     // 如果数据为只读，则调用 readonly 对值进行包装\n     return isReadonly ? readonly(res) : reactive(res)\n   }\n\n   return res\n }\n // 省略其他拦截函数\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，我们在返回属性值之前，判断它是否是只读的，如果是只读的，则调用 <code>readonly</code> 函数对值进行包装，并把包装后的只读对象返回。</p>\n<p>对于 <code>shallowReadonly</code>，实际上我们只需要修改 <code>createReactive</code> 的第二个参数即可：</p>\n<pre class=\"code-rows\"><code> function readonly(obj) {\n   return createReactive(obj, false, true)\n }\n<p>function shallowReadonly(obj) {<br />\nreturn createReactive(obj, true /* shallow */, true)<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，在 <code>shallowReadonly</code> 函数内调用 <code>createReactive</code> 函数创建代理对象时，将第二个参数 <code>isShallow</code> 设置为 <code>true</code>，这样就可以创建一个浅只读的代理对象了。</p>\n<h2 id=\"nav_point_51\">5.7　代理数组</h2>\n<p>从本节开始，我们讲解如何代理数组。实际上，在 JavaScript 中，数组只是一个特殊的对象而已，因此想要更好地实现对数组的代理，就有必要了解相比普通对象，数组到底有何特殊之处。</p>\n<p>在 5.2 节中，我们深入讲解了 JavaScript 中的对象。我们知道，在 JavaScript 中有两种对象：常规对象和异质对象。我们还讨论了两者的差异。而本节中我们要介绍的数组就是一个异质对象，这是因为数组对象的 <code>[[DefineOwnProperty]]</code> 内部方法与常规对象不同。换句话说，数组对象除了 <code>[[DefineOwnProperty]]</code> 这个内部方法之外，其他内部方法的逻辑都与常规对象相同。因此，当实现对数组的代理时，用于代理普通对象的大部分代码可以继续使用，如下所示：</p>\n<pre class=\"code-rows\"><code> const arr = reactive(['foo'])\n<p>effect(() =&gt; {<br />\nconsole.log(arr[0]) // ‘foo’<br />\n})</p>\n<p>arr[0] = ‘bar’ // 能够触发响应<br />\n</code></pre></p>\n<p>上面这段代码能够按预期工作。实际上，当我们通过索引读取或设置数组元素的值时，代理对象的 <code>get</code>/<code>set</code> 拦截函数也会执行，因此我们不需要做任何额外的工作，就能够让数组索引的读取和设置操作是响应式的了。</p>\n<p>但对数组的操作与对普通对象的操作仍然存在不同，下面总结了所有对数组元素或属性的“读取”操作。</p>\n<ul>\n<li>通过索引访问数组元素值：<code>arr[0]</code>。</li>\n<li>访问数组的长度：<code>arr.length</code>。</li>\n<li>把数组作为对象，使用 <code>for...in</code> 循环遍历。</li>\n<li>使用 <code>for...of</code> 迭代遍历数组。</li>\n<li>数组的原型方法，如 <code>concat/join/every/some/find/findIndex/includes</code> 等，以及其他所有不改变原数组的原型方法。</li>\n</ul>\n<p>可以看到，对数组的读取操作要比普通对象丰富得多。我们再来看看对数组元素或属性的设置操作有哪些。</p>\n<ul>\n<li>通过索引修改数组元素值：<code>arr[1] = 3</code>。</li>\n<li>修改数组长度：<code>arr.length = 0</code>。</li>\n<li>数组的栈方法：<code>push/pop/shift/unshift</code>。</li>\n<li>修改原数组的原型方法：<code>splice/fill/sort</code> 等。</li>\n</ul>\n<p>除了通过数组索引修改数组元素值这种基本操作之外，数组本身还有很多会修改原数组的原型方法。调用这些方法也属于对数组的操作，有些方法的操作语义是“读取”，而有些方法的操作语义是“设置”。因此，当这些操作发生时，也应该正确地建立响应联系或触发响应。</p>\n<p>从上面列出的这些对数组的操作来看，似乎代理数组的难度要比代理普通对象的难度大很多。但事实并非如此，这是因为数组本身也是对象，只不过它是异质对象罢了，它与常规对象的差异并不大。因此，大部分用来代理常规对象的代码对于数组也是生效的。接下来，我们就从通过索引读取或设置数组的元素值说起。</p>\n<h3 id=\"nav_point_52\">5.7.1　数组的索引与 <code>length</code></h3>\n<p>拿本节开头的例子来说，当通过数组的索引访问元素的值时，已经能够建立响应联系了：</p>\n<pre class=\"code-rows\"><code> const arr = reactive(['foo'])\n<p>effect(() =&gt; {<br />\nconsole.log(arr[0]) // ‘foo’<br />\n})</p>\n<p>arr[0] = ‘bar’ // 能够触发响应<br />\n</code></pre></p>\n<p>但通过索引设置数组的元素值与设置对象的属性值仍然存在根本上的不同，这是因为数组对象部署的内部方法 <code>[[DefineOwnProperty]]</code> 不同于常规对象。实际上，当我们通过索引设置数组元素的值时，会执行数组对象所部署的内部方法 <code>[[Set]]</code>，这一步与设置常规对象的属性值一样。根据规范可知，内部方法 <code>[[Set]]</code> 其实依赖于 <code>[[DefineOwnProperty]]</code>，到了这里就体现出了差异。数组对象所部署的内部方法 <code>[[DefineOwnProperty]]</code> 的逻辑定义在规范的 10.4.2.1 节，如图 5-7 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00516.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-7　<code>[[DefineOwnProperty]]</code> 内部方法的执行流程</strong></p>\n<p>图 5-7 中第 3 步的 j 子步骤描述的内容如下。</p>\n<blockquote>\n<p>j. 如果 <code>index &gt;= oldLen</code>，那么</p>\n<p>I. 将 <code>oldLenDesc.[[Value]]</code> 设置为 <code>index + 1</code>。</p>\n<p>II. 让 <code>succeeded</code> 的值为 <code>OrdinaryDefineOwnProperty(A, ''length'', oldLenDesc)</code>。</p>\n<p>III. 断言：<code>succeeded</code> 是 <code>true</code>。</p>\n</blockquote>\n<p>可以看到，规范中明确说明，如果设置的索引值大于数组当前的长度，那么要更新数组的 <code>length</code> 属性。所以当通过索引设置元素值时，可能会隐式地修改 <code>length</code> 的属性值。因此在触发响应时，也应该触发与 <code>length</code> 属性相关联的副作用函数重新执行，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const arr = reactive(['foo']) // 数组的原长度为 1\n<p>effect(() =&gt; {<br />\nconsole.log(arr.length) // 1<br />\n})<br />\n// 设置索引 1 的值，会导致数组的长度变为 2<br />\narr[1] = ‘bar’<br />\n</code></pre></p>\n<p>在这段代码中，数组的原长度为 <code>1</code>，并且在副作用函数中访问了 <code>length</code> 属性。然后设置数组索引为 <code>1</code> 的元素值，这会导致数组的长度变为 <code>2</code>，因此应该触发副作用函数重新执行。但目前的实现还做不到这一点，为了实现目标，我们需要修改 <code>set</code> 拦截函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function createReactive(obj, isShallow = false, isReadonly = false) {\n   return new Proxy(obj, {\n     // 拦截设置操作\n     set(target, key, newVal, receiver) {\n       if (isReadonly) {\n         console.warn(`属性 $ 是只读的`)\n         return true\n       }\n       const oldVal = target[key]\n       // 如果属性不存在，则说明是在添加新的属性，否则是设置已有属性\n       const type = Array.isArray(target)\n         // 如果代理目标是数组，则检测被设置的索引值是否小于数组长度，\n         // 如果是，则视作 SET 操作，否则是 ADD 操作\n         ? Number(key) &lt; target.length ? 'SET' : 'ADD'\n         : Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\n<pre><code>   const res = Reflect.set(target, key, newVal, receiver)\n   if (target === receiver.raw) {\n     if (oldVal !== newVal &amp;amp;&amp;amp; (oldVal === oldVal || newVal === newVal)) {\n       trigger(target, key, type)\n     }\n   }\n\n   return res\n }\n // 省略其他拦截函数\n</code></pre>\n<p>}<br />\n</code></pre></p>\n<p>我们在判断操作类型时，新增了对数组类型的判断。如果代理的目标对象是数组，那么对于操作类型的判断会有所区别。即被设置的索引值如果小于数组长度，就视作 <code>SET</code> 操作，因为它不会改变数组长度；如果设置的索引值大于数组的当前长度，则视作 <code>ADD</code> 操作，因为这会隐式地改变数组的 <code>length</code> 属性值。有了这些信息，我们就可以在 <code>trigger</code> 函数中正确地触发与数组对象的 <code>length</code> 属性相关联的副作用函数重新执行了：</p>\n<pre class=\"code-rows\"><code> function trigger(target, key, type) {\n   const depsMap = bucket.get(target)\n   if (!depsMap) return\n   // 省略部分内容\n<p>// 当操作类型为 ADD 并且目标对象是数组时，应该取出并执行那些与 length 属性相关联的副作用函数<br />\nif (type === ‘ADD’ &amp;&amp; Array.isArray(target)) {<br />\n// 取出与 length 相关联的副作用函数<br />\nconst lengthEffects = depsMap.get(‘length’)<br />\n// 将这些副作用函数添加到 effectsToRun 中，待执行<br />\nlengthEffects &amp;&amp; lengthEffects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})<br />\n}</p>\n<p>effectsToRun.forEach(effectFn =&gt; {<br />\nif (effectFn.options.scheduler) {<br />\neffectFn.options.scheduler(effectFn)<br />\n} else {<br />\neffectFn()<br />\n}<br />\n})<br />\n}<br />\n</code></pre></p>\n<p>但是反过来思考，其实修改数组的 <code>length</code> 属性也会隐式地影响数组元素，例如：</p>\n<pre class=\"code-rows\"><code> const arr = reactive(['foo'])\n<p>effect(() =&gt; {<br />\n// 访问数组的第 0 个元素<br />\nconsole.log(arr[0]) // foo<br />\n})<br />\n// 将数组的长度修改为 0，导致第 0 个元素被删除，因此应该触发响应<br />\narr.length = 0<br />\n</code></pre></p>\n<p>如上面的代码所示，在副作用函数内访问了数组的第 0 个元素，接着将数组的 <code>length</code> 属性修改为 <code>0</code>。我们知道这会隐式地影响数组元素，即所有元素都被删除，所以应该触发副作用函数重新执行。然而并非所有对 <code>length</code> 属性的修改都会影响数组中的已有元素，拿上例来说，如果我们将 <code>length</code> 属性设置为 <code>100</code>，这并不会影响第 0 个元素，所以也就不需要触发副作用函数重新执行。这让我们意识到，当修改 <code>length</code> 属性值时，只有那些索引值大于或等于新的 <code>length</code> 属性值的元素才需要触发响应。但无论如何，目前的实现还做不到这一点，为了实现目标，我们需要修改 <code>set</code> 拦截函数。在调用 <code>trigger</code> 函数触发响应时，应该把新的属性值传递过去：</p>\n<pre class=\"code-rows\"><code> function createReactive(obj, isShallow = false, isReadonly = false) {\n   return new Proxy(obj, {\n     // 拦截设置操作\n     set(target, key, newVal, receiver) {\n       if (isReadonly) {\n         console.warn(`属性 $ 是只读的`)\n         return true\n       }\n       const oldVal = target[key]\n<pre><code>   const type = Array.isArray(target)\n     ? Number(key) &amp;lt; target.length ? 'SET' : 'ADD'\n     : Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'\n\n   const res = Reflect.set(target, key, newVal, receiver)\n   if (target === receiver.raw) {\n     if (oldVal !== newVal &amp;amp;&amp;amp; (oldVal === oldVal || newVal === newVal)) {\n       // 增加第四个参数，即触发响应的新值\n       trigger(target, key, type, newVal)\n     }\n   }\n\n   return res\n },\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>接着，我们还需要修改 <code>trigger</code> 函数：</p>\n<pre class=\"code-rows\"><code> // 为 trigger 函数增加第四个参数，newVal，即新值\n function trigger(target, key, type, newVal) {\n   const depsMap = bucket.get(target)\n   if (!depsMap) return\n   // 省略其他代码\n<p>// 如果操作目标是数组，并且修改了数组的 length 属性<br />\nif (Array.isArray(target) &amp;&amp; key === ‘length’) {<br />\n// 对于索引大于或等于新的 length 值的元素，<br />\n// 需要把所有相关联的副作用函数取出并添加到 effectsToRun 中待执行<br />\ndepsMap.forEach((effects, key) =&gt; {<br />\nif (key &gt;= newVal) {<br />\neffects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})<br />\n}<br />\n})<br />\n}</p>\n<p>effectsToRun.forEach(effectFn =&gt; {<br />\nif (effectFn.options.scheduler) {<br />\neffectFn.options.scheduler(effectFn)<br />\n} else {<br />\neffectFn()<br />\n}<br />\n})<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，为 <code>trigger</code> 函数增加了第四个参数，即触发响应时的新值。在本例中，新值指的是新的 <code>length</code> 属性值，它代表新的数组长度。接着，我们判断操作的目标是否是数组，如果是，则需要找到所有索引值大于或等于新的 <code>length</code> 值的元素，然后把与它们相关联的副作用函数取出并执行。</p>\n<h3 id=\"nav_point_53\">5.7.2　遍历数组</h3>\n<p>既然数组也是对象，就意味着同样可以使用 <code>for...in</code> 循环遍历：</p>\n<pre class=\"code-rows\"><code> const arr = reactive(['foo'])\n<p>effect(() =&gt; {<br />\nfor (const key in arr) {<br />\nconsole.log(key) // 0<br />\n}<br />\n})<br />\n</code></pre></p>\n<p>这里有必要指出一点，我们应该尽量避免使用 <code>for...in</code> 循环遍历数组。但既然在语法上是可行的，那么当然也需要考虑。前面我们提到，数组对象和常规对象的不同仅体现在 <code>[[DefineOwnProperty]]</code> 这个内部方法上，也就是说，使用 <code>for...in</code> 循环遍历数组与遍历常规对象并无差异，因此同样可以使用 <code>ownKeys</code> 拦截函数进行拦截。下面是我们之前实现的 <code>ownKeys</code> 拦截函数：</p>\n<pre class=\"code-rows\"><code> function createReactive(obj, isShallow = false, isReadonly = false) {\n   return new Proxy(obj, {\n     // 省略其他拦截函数\n     ownKeys(target) {\n       track(target, ITERATE_KEY)\n       return Reflect.ownKeys(target)\n     }\n   })\n }\n</code></pre>\n<p>这段代码取自前文，当初我们为了追踪对普通对象的 <code>for...in</code> 操作，人为创造了 <code>ITERATE_KEY</code> 作为追踪的 <code>key</code>。但这是为了代理普通对象而考虑的，对于一个普通对象来说，只有当添加或删除属性值时才会影响 <code>for...in</code> 循环的结果。所以当添加或删除属性操作发生时，我们需要取出与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行。不过，对于数组来说情况有所不同，我们看看哪些操作会影响 <code>for...in</code> 循环对数组的遍历。</p>\n<ul>\n<li>添加新元素：<code>arr[100] = 'bar'</code>。</li>\n<li>修改数组长度：<code>arr.length = 0</code>。</li>\n</ul>\n<p>其实，无论是为数组添加新元素，还是直接修改数组的长度，本质上都是因为修改了数组的 <code>length</code> 属性。一旦数组的 <code>length</code> 属性被修改，那么 <code>for...in</code> 循环对数组的遍历结果就会改变，所以在这种情况下我们应该触发响应。很自然的，我们可以在 <code>ownKeys</code> 拦截函数内，判断当前操作目标 <code>target</code> 是否是数组，如果是，则使用 <code>length</code> 作为 <code>key</code> 去建立响应联系：</p>\n<pre class=\"code-rows\"><code> function createReactive(obj, isShallow = false, isReadonly = false) {\n   return new Proxy(obj, {\n     // 省略其他拦截函数\n     ownKeys(target) {\n       // 如果操作目标 target 是数组，则使用 length 属性作为 key 并建立响应联系\n       track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)\n       return Reflect.ownKeys(target)\n     }\n   })\n }\n</code></pre>\n<p>这样无论是为数组添加新元素，还是直接修改 <code>length</code> 属性，都能够正确地触发响应了：</p>\n<pre class=\"code-rows\"><code> const arr = reactive(['foo'])\n<p>effect(() =&gt; {<br />\nfor (const key in arr) {<br />\nconsole.log(key)<br />\n}<br />\n})</p>\n<p>arr[1] = ‘bar’ // 能够触发副作用函数重新执行<br />\narr.length = 0 // 能够触发副作用函数重新执行<br />\n</code></pre></p>\n<p>讲解了使用 <code>for...in</code> 遍历数组，接下来我们再看看使用 <code>for...of</code> 遍历数组的情况。与 <code>for...in</code> 不同，<code>for...of</code> 是用来遍历<strong>可迭代对象</strong>（iterable object）的，因此我们需要先搞清楚什么是可迭代对象。ES2015 为 JavaScript 定义了<strong>迭代协议</strong>（iteration protocol），它不是新的语法，而是一种协议。具体来说，一个对象能否被迭代，取决于该对象或者该对象的原型是否实现了 <code>@@iterator</code> 方法。这里的 <code>@@[name]</code> 标志在 ECMAScript 规范里用来代指 JavaScript 内建的 <code>symbols</code> 值，例如 <code>@@iterator</code> 指的就是 <code>Symbol.iterator</code> 这个值。如果一个对象实现了 <code>Symbol.iterator</code> 方法，那么这个对象就是可以迭代的，例如：</p>\n<pre class=\"code-rows\"><code> const obj = {\n   val: 0,\n   [Symbol.iterator]() {\n     return {\n       next() {\n         return {\n           value: obj.val++,\n           done: obj.val &gt; 10 ? true : false\n         }\n       }\n     }\n   }\n }\n</code></pre>\n<p>该对象实现了 <code>Symbol.iterator</code> 方法，因此可以使用 <code>for...of</code> 循环遍历它：</p>\n<pre class=\"code-rows\"><code> for (const value of obj) {\n   console.log(value)  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n }\n</code></pre>\n<p>数组内建了 <code>Symbol.iterator</code> 方法的实现，我们可以做一个实验：</p>\n<pre class=\"code-rows\"><code> const arr = [1, 2, 3, 4, 5]\n // 获取并调用数组内建的迭代器方法\n const itr = arr[Symbol.iterator]()\n<p>console.log(itr.next())  //<br />\nconsole.log(itr.next())  //<br />\nconsole.log(itr.next())  //<br />\nconsole.log(itr.next())  //<br />\nconsole.log(itr.next())  //<br />\nconsole.log(itr.next())  //<br />\n</code></pre></p>\n<p>可以看到，我们能够通过将 <code>Symbol.iterator</code> 作为键，获取数组内建的迭代器方法。然后手动执行迭代器的 <code>next</code> 函数，这样也可以得到期望的结果。这也是默认情况下数组可以使用 <code>for...of</code> 遍历的原因：</p>\n<pre class=\"code-rows\"><code> const arr = [1, 2, 3, 4, 5]\n<p>for (const val of arr) {<br />\nconsole.log(val)  // 1, 2, 3, 4, 5<br />\n}<br />\n</code></pre></p>\n<p>实际上，想要实现对数组进行 <code>for...of</code> 遍历操作的拦截，关键点在于找到 <code>for...of</code> 操作依赖的基本语义。在规范的 23.1.5.1 节中定义了数组迭代器的执行流程，如图 5-8 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00517.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-8　数组迭代器的执行流程</strong></p>\n<p>图 5-8 中第 3 步的 b 子步骤所描述的内容如下。</p>\n<blockquote>\n<p>b. 重复以下步骤。</p>\n<p>i. 如果 <code>array</code> 有 <code>[[TypedArrayName]]</code> 内部槽，那么</p>\n<p>　　1. 如果 <code>IsDetachedBuffer(array.[[ViewedArrayBuffer]])</code> 是 <code>true</code>，则抛出 <code>TypeError</code> 异常。</p>\n<p>　　2. 让 <code>len</code> 的值为 <code>array.[[ArrayLength]]</code>。</p>\n<p>ii. 否则</p>\n<p>　　1. 让 <code>len</code> 的值为 <code>LengthOfArrayLike(array)</code>。</p>\n<p>iii. 如果 <code>index &gt;= len</code>，则返回 <code>undefined</code>。</p>\n<p>iv. 如果 <code>kind</code> 是 <code>key</code>，则执行 <code>? Yield(𝔽(index))</code>。</p>\n<p>v. 否则</p>\n<p>　　1. 让 <code>elementKey</code> 的值为 <code>! ToString(𝔽(index))</code>。</p>\n<p>　　2. 让 <code>elementValue</code> 的值为 <code>? Get(array, elementKey)</code>。</p>\n<p>　　3. 如果 <code>kind</code> 是 <code>value</code>，执行 <code>? Yield(elementValue)</code>。</p>\n<p>　　4. 否则</p>\n<p>　　　　a. 断言：<code>kind</code> 是 <code>key + value</code>。</p>\n<p>　　　　b. 执行：<code>? Yield(! CreateArrayFromList(« 𝔽(index), elementValue »))</code>。</p>\n<p>vi. 将 <code>index</code> 设置为 <code>index + 1</code>。</p>\n</blockquote>\n<p>可以看到，数组迭代器的执行会读取数组的 <code>length</code> 属性。如果迭代的是数组元素值，还会读取数组的索引。其实我们可以给出一个数组迭代器的模拟实现：</p>\n<pre class=\"code-rows\"><code> const arr = [1, 2, 3, 4, 5]\n<p>arr[Symbol.iterator] = function() {<br />\nconst target = this<br />\nconst len = target.length<br />\nlet index = 0</p>\n<p>return {<br />\nnext() {<br />\nreturn {<br />\nvalue: index &lt; len ? target[index] : undefined,<br />\ndone: index++ &gt;= len<br />\n}<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，我们用自定义的实现覆盖了数组内建的迭代器方法，但它仍然能够正常工作。</p>\n<p>这个例子表明，迭代数组时，只需要在副作用函数与数组的长度和索引之间建立响应联系，就能够实现响应式的 <code>for...of</code> 迭代：</p>\n<pre class=\"code-rows\"><code> const arr = reactive([1, 2, 3, 4, 5])\n<p>effect(() =&gt; {<br />\nfor (const val of arr) {<br />\nconsole.log(val)<br />\n}<br />\n})</p>\n<p>arr[1] = ‘bar’  // 能够触发响应<br />\narr.length = 0  // 能够触发响应<br />\n</code></pre></p>\n<p>可以看到，不需要增加任何代码就能够使其正确地工作。这是因为只要数组的长度和元素值发生改变，副作用函数自然会重新执行。</p>\n<p>这里不得不提的一点是，数组的 <code>values</code> 方法的返回值实际上就是数组内建的迭代器，我们可以验证这一点：</p>\n<pre class=\"code-rows\"><code> console.log(Array.prototype.values === Array.prototype[Symbol.iterator]) // true\n</code></pre>\n<p>换句话说，在不增加任何代码的情况下，我们也能够让数组的迭代器方法正确地工作：</p>\n<pre class=\"code-rows\"><code> const arr = reactive([1, 2, 3, 4, 5])\n<p>effect(() =&gt; {<br />\nfor (const val of arr.values()) {<br />\nconsole.log(val)<br />\n}<br />\n})</p>\n<p>arr[1] = ‘bar’  // 能够触发响应<br />\narr.length = 0  // 能够触发响应<br />\n</code></pre></p>\n<p>最后需要指出的是，无论是使用 <code>for...of</code> 循环，还是调用 <code>values</code> 等方法，它们都会读取数组的 <code>Symbol.iterator</code> 属性。该属性是一个 <code>symbol</code> 值，为了避免发生意外的错误，以及性能上的考虑，我们不应该在副作用函数与 <code>Symbol.iterator</code> 这类 <code>symbol</code> 值之间建立响应联系，因此需要修改 <code>get</code> 拦截函数，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> function createReactive(obj, isShallow = false, isReadonly = false) {\n   return new Proxy(obj, {\n     // 拦截读取操作\n     get(target, key, receiver) {\n       console.log('get: ', key)\n       if (key === 'raw') {\n         return target\n       }\n<pre><code>   // 添加判断，如果 key 的类型是 symbol，则不进行追踪\n   if (!isReadonly &amp;amp;&amp;amp; typeof key !== 'symbol') {\n     track(target, key)\n   }\n\n   const res = Reflect.get(target, key, receiver)\n\n   if (isShallow) {\n     return res\n   }\n\n   if (typeof res === 'object' &amp;amp;&amp;amp; res !== null) {\n     return isReadonly ? readonly(res) : reactive(res)\n   }\n\n   return res\n },\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>在调用 <code>track</code> 函数进行追踪之前，需要添加一个判断条件，即只有当 <code>key</code> 的类型不是 <code>symbol</code> 时才进行追踪，这样就避免了上述问题。</p>\n<h3 id=\"nav_point_54\">5.7.3　数组的查找方法</h3>\n<p>通过上一节的介绍我们意识到，数组的方法内部其实都依赖了对象的基本语义。所以大多数情况下，我们不需要做特殊处理即可让这些方法按预期工作，例如：</p>\n<pre class=\"code-rows\"><code> const arr = reactive([1, 2])\n<p>effect(() =&gt; {<br />\nconsole.log(arr.includes(1)) // 初始打印 true<br />\n})</p>\n<p>arr[0] = 3 // 副作用函数重新执行，并打印 false<br />\n</code></pre></p>\n<p>这是因为 <code>includes</code> 方法为了找到给定的值，它内部会访问数组的 <code>length</code> 属性以及数组的索引，因此当我们修改某个索引指向的元素值后能够触发响应。</p>\n<p>然而 <code>includes</code> 方法并不总是按照预期工作，举个例子：</p>\n<pre class=\"code-rows\"><code> const obj = {}\n const arr = reactive([obj])\n<p>console.log(arr.includes(arr[0]))  // false<br />\n</code></pre></p>\n<p>如上面的代码所示。我们首先定义一个对象 <code>obj</code>，并将其作为数组的第一个元素，然后调用 <code>reactive</code> 函数为其创建一个响应式对象，接着尝试调用 <code>includes</code> 方法在数组中进行查找，看看其中是否包含第一个元素。很显然，这个操作应该返回 <code>true</code>，但如果你尝试运行这段代码，会发现它返回了 <code>false</code>。</p>\n<p>为什么会这样呢？这需要我们去查阅语言规范，看看 <code>includes</code> 方法的执行流程是怎样的。规范的 23.1.3.13 节给出了 <code>includes</code> 方法的执行流程，如图 5-9 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00518.jpeg\" alt=\"\" width=\"70%\" style=\"width: 70%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-9　<code>includes</code> 方法的执行流程</strong></p>\n<p>图 5-9 展示了数组的 <code>includes</code> 方法的执行流程，我们重点关注第 1 步和第 10 步。其中，第 1 步所描述的内容如下。</p>\n<blockquote>\n<ol>\n<li class=\"第2级有序列表\">让 <code>O</code> 的值为 <code>? ToObject(this value)</code>。</li>\n</ol>\n</blockquote>\n<p>第 10 步所描述的内容如下。</p>\n<blockquote>\n<p>10. 重复，<code>while</code> 循环（条件 <code>k &lt; len</code>），</p>\n<p>a. 让 <code>elementK</code> 的值为 <code>? Get(O, ! ToString(𝔽(k)))</code> 的结果。</p>\n<p>b. 如果 <code>SameValueZero(searchElement, elementK)</code> 是 <code>true</code>，则返回 <code>true</code>。</p>\n<p>c. 将 <code>k</code> 设置为 <code>k + 1</code>。</p>\n</blockquote>\n<p>这里我们注意第 1 步，让 <code>O</code> 的值为 <code>? ToObject(this value)</code>，这里的 <code>this</code> 是谁呢？在 <code>arr.includes(arr[0])</code> 语句中，<code>arr</code> 是代理对象，所以 <code>includes</code> 函数执行时的 <code>this</code> 指向的是代理对象，即 <code>arr</code>。接着我们看第 10.a 步，可以看到 <code>includes</code> 方法会通过索引读取数组元素的值，但是这里的 <code>O</code> 是代理对象 <code>arr</code>。我们知道，通过代理对象来访问元素值时，如果值仍然是可以被代理的，那么得到的值就是新的代理对象而非原始对象。下面这段 <code>get</code> 拦截函数内的代码可以证明这一点：</p>\n<pre class=\"code-rows\"><code> if (typeof res === 'object' &amp;&amp; res !== null) {\n   // 如果值可以被代理，则返回代理对象\n   return isReadonly ? readonly(res) : reactive(res)\n }\n</code></pre>\n<p>知道这些后，我们再回头看这句代码：<code>arr.includes(arr[0])</code>。其中，<code>arr[0]</code> 得到的是一个代理对象，而在 <code>includes</code> 方法内部也会通过 <code>arr</code> 访问数组元素，从而也得到一个代理对象，问题是这两个代理对象是不同的。这是因为每次调用 <code>reactive</code> 函数时都会创建一个新的代理对象：</p>\n<pre class=\"code-rows\"><code> function reactive(obj) {\n   // 每次调用 reactive 时，都会创建新的代理对象\n   return createReactive(obj)\n }\n</code></pre>\n<p>即使参数 <code>obj</code> 是相同的，每次调用 <code>reactive</code> 函数时，也都会创建新的代理对象。这个问题的解决方案如下所示：</p>\n<pre class=\"code-rows\"><code> // 定义一个 Map 实例，存储原始对象到代理对象的映射\n const reactiveMap = new Map()\n<p>function reactive(obj) {<br />\n// 优先通过原始对象 obj 寻找之前创建的代理对象，如果找到了，直接返回已有的代理对象<br />\nconst existionProxy = reactiveMap.get(obj)<br />\nif (existionProxy) return existionProxy</p>\n<p>// 否则，创建新的代理对象<br />\nconst proxy = createReactive(obj)<br />\n// 存储到 Map 中，从而避免重复创建<br />\nreactiveMap.set(obj, proxy)</p>\n<p>return proxy<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们定义了 <code>reactiveMap</code>，用来存储原始对象到代理对象的映射。每次调用 <code>reactive</code> 函数创建代理对象之前，优先检查是否已经存在相应的代理对象，如果存在，则直接返回已有的代理对象，这样就避免了为同一个原始对象多次创建代理对象的问题。接下来，我们再次运行本节开头的例子：</p>\n<pre class=\"code-rows\"><code> const obj = {}\n const arr = reactive([obj])\n<p>console.log(arr.includes(arr[0]))  // true<br />\n</code></pre></p>\n<p>可以发现，此时的行为已经符合预期了。</p>\n<p>然而，还不能高兴得太早，再来看下面的代码：</p>\n<pre class=\"code-rows\"><code> const obj = {}\n const arr = reactive([obj])\n<p>console.log(arr.includes(obj))  // false<br />\n</code></pre></p>\n<p>在上面这段代码中，我们直接把原始对象作为参数传递给 <code>includes</code> 方法，这是很符合直觉的行为。而从用户的角度来看，自己明明把 <code>obj</code> 作为数组的第一个元素了，为什么在数组中却仍然找不到 <code>obj</code> 对象呢？其实原因很简单，因为 <code>includes</code> 内部的 <code>this</code> 指向的是代理对象 <code>arr</code>，并且在获取数组元素时得到的值也是代理对象，所以拿原始对象 <code>obj</code> 去查找肯定找不到，因此返回 <code>false</code>。为此，我们需要重写数组的 <code>includes</code> 方法并实现自定义的行为，才能解决这个问题。首先，我们来看如何重写 <code>includes</code> 方法，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const arrayInstrumentations = {\n   includes: function() {/* ... */}\n }\n<p>function createReactive(obj, isShallow = false, isReadonly = false) {<br />\nreturn new Proxy(obj, {<br />\n// 拦截读取操作<br />\nget(target, key, receiver) {<br />\nconsole.log('get: ', key)<br />\nif (key === ‘raw’) {<br />\nreturn target<br />\n}<br />\n// 如果操作的目标对象是数组，并且 key 存在于 arrayInstrumentations 上，<br />\n// 那么返回定义在 arrayInstrumentations 上的值<br />\nif (Array.isArray(target) &amp;&amp; arrayInstrumentations.hasOwnProperty(key)) {<br />\nreturn Reflect.get(arrayInstrumentations, key, receiver)<br />\n}</p>\n<pre><code>   if (!isReadonly &amp;amp;&amp;amp; typeof key !== 'symbol') {\n     track(target, key)\n   }\n\n   const res = Reflect.get(target, key, receiver)\n\n   if (isShallow) {\n     return res\n   }\n\n   if (typeof res === 'object' &amp;amp;&amp;amp; res !== null) {\n     return isReadonly ? readonly(res) : reactive(res)\n   }\n\n   return res\n },\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们修改了 <code>get</code> 拦截函数，目的是重写数组的 <code>includes</code> 方法。具体怎么做呢？我们知道，<code>arr.includes</code> 可以理解为读取代理对象 <code>arr</code> 的 <code>includes</code> 属性，这就会触发 <code>get</code> 拦截函数，在该函数内检查 <code>target</code> 是否是数组，如果是数组并且读取的键值存在于 <code>arrayInstrumentations</code> 上，则返回定义在 <code>arrayInstrumentations</code> 对象上相应的值。也就是说，当执行 <code>arr.includes</code> 时，实际执行的是定义在 <code>arrayInstrumentations</code> 上的 <code>includes</code> 函数，这样就实现了重写。</p>\n<p>接下来，我们就可以自定义 <code>includes</code> 函数了：</p>\n<pre class=\"code-rows\"><code> const originMethod = Array.prototype.includes\n const arrayInstrumentations = {\n   includes: function(...args) {\n     // this 是代理对象，先在代理对象中查找，将结果存储到 res 中\n     let res = originMethod.apply(this, args)\n<pre><code> if (res === false) {\n   // res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找并更新 res 值\n   res = originMethod.apply(this.raw, args)\n }\n // 返回最终结果\n return res\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>如上面这段代码所示，其中 <code>includes</code> 方法内的 <code>this</code> 指向的是代理对象，我们先在代理对象中进行查找，这其实是实现了 <code>arr.include(obj)</code> 的默认行为。如果找不到，通过 <code>this.raw</code> 拿到原始数组，再去其中查找，最后返回结果，这样就解决了上述问题。运行如下测试代码：</p>\n<pre class=\"code-rows\"><code> const obj = {}\n const arr = reactive([obj])\n<p>console.log(arr.includes(obj))  // true<br />\n</code></pre></p>\n<p>可以发现，现在代码的行为已经符合预期了。</p>\n<p>除了 <code>includes</code> 方法之外，还需要做类似处理的数组方法有 <code>indexOf</code> 和 <code>lastIndexOf</code>，因为它们都属于根据给定的值返回查找结果的方法。完整的代码如下：</p>\n<pre class=\"code-rows\"><code> const arrayInstrumentations = {}\n<p>;[‘includes’, ‘indexOf’, ‘lastIndexOf’].forEach(method =&gt; {<br />\nconst originMethod = Array.prototype[method]<br />\narrayInstrumentations[method] = function(…args) {<br />\n// this 是代理对象，先在代理对象中查找，将结果存储到 res 中<br />\nlet res = originMethod.apply(this, args)</p>\n<pre><code> if (res === false || res === -1) {\n   // res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找，并更新 res 值\n   res = originMethod.apply(this.raw, args)\n }\n // 返回最终结果\n return res\n</code></pre>\n<p>}<br />\n})<br />\n</code></pre></p>\n<h3 id=\"nav_point_55\">5.7.4　隐式修改数组长度的原型方法</h3>\n<p>本节中我们讲解如何处理那些会隐式修改数组长度的方法，主要指的是数组的栈方法，例如 <code>push/pop/shift/unshift</code>。除此之外，<code>splice</code> 方法也会隐式地修改数组长度，我们可以查阅规范来证实这一点。以 <code>push</code> 方法为例，规范的 23.1.3.20 节定义了 <code>push</code> 方法的执行流程，如图 5-10 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00519.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-10　数组 <code>push</code> 方法的执行流程</strong></p>\n<p>图 5-10 所描述的内容如下。</p>\n<blockquote>\n<p>当调用 <code>push</code> 方法并传递 0 个或多个参数时，会执行以下步骤。</p>\n<p>1. 让 <code>O</code> 的值为 <code>? ToObject(this value)</code>。</p>\n<p>2. 让 <code>len</code> 的值为 <code>? LengthOfArrayLike(O)</code>。</p>\n<p>3. 让 <code>argCount</code> 的值为 <code>items</code> 的元素数量。</p>\n<p>4. 如果 <code>len + argCount &gt; 2<sup>53</sup> - 1</code>，则抛出 <code>TypeError</code> 异常。</p>\n<p>5. 对于 <code>items</code> 中的每一个元素 <code>E</code>：</p>\n<p>a. 执行 <code>? Set(O, ! ToString(<img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00520.gif\" alt=\"\\mathbb\" inline-img=\"true\" />(len)), E, true)</code>；</p>\n<p>b. 将 <code>len</code> 设置为 <code>len + 1</code>。</p>\n<p>6. 执行 <code>? Set(O, ''length'', <img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00520.gif\" alt=\"\\mathbb\" inline-img=\"true\" />(len), true)</code>。</p>\n<p>7. 返回 <code><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00520.gif\" alt=\"\\mathbb\" inline-img=\"true\" />(len)</code>。</p>\n</blockquote>\n<p>由第 2 步和第 6 步可知，当调用数组的 <code>push</code> 方法向数组中添加元素时，既会读取数组的 <code>length</code> 属性值，也会设置数组的 <code>length</code> 属性值。这会导致两个独立的副作用函数互相影响。以下面的代码为例：</p>\n<pre class=\"code-rows\"><code> const arr = reactive([])\n // 第一个副作用函数\n effect(() =&gt; {\n   arr.push(1)\n })\n<p>// 第二个副作用函数<br />\neffect(() =&gt; {<br />\narr.push(1)<br />\n})<br />\n</code></pre></p>\n<p>如果你尝试在浏览器中运行上面这段代码，会得到栈溢出的错误（Maximum call stack size exceeded）。</p>\n<p>为什么会这样呢？我们来详细分析上面这段代码的执行过程。</p>\n<ul>\n<li>第一个副作用函数执行。在该函数内，调用 <code>arr.push</code> 方法向数组中添加了一个元素。我们知道，调用数组的 <code>push</code> 方法会间接读取数组的 <code>length</code> 属性。所以，当第一个副作用函数执行完毕后，会与 <code>length</code> 属性建立响应联系。</li>\n<li>接着，第二个副作用函数执行。同样，它也会与 <code>length</code> 属性建立响应联系。但不要忘记，调用 <code>arr.push</code> 方法不仅会间接读取数组的 <code>length</code> 属性，还会间接设置 <code>length</code> 属性的值。</li>\n<li>第二个函数内的 <code>arr.push</code> 方法的调用设置了数组的 <code>length</code> 属性值。于是，响应系统尝试把与 <code>length</code> 属性相关联的副作用函数全部取出并执行，其中就包括第一个副作用函数。问题就出在这里，可以发现，第二个副作用函数还未执行完毕，就要再次执行第一个副作用函数了。</li>\n<li>第一个副作用函数再次执行。同样，这会间接设置数组的 <code>length</code> 属性。于是，响应系统又要尝试把所有与 <code>length</code> 属性相关联的副作用函数取出并执行，其中就包含第二个副作用函数。</li>\n<li>如此循环往复，最终导致调用栈溢出。</li>\n</ul>\n<p>问题的原因是 <code>push</code> 方法的调用会间接读取 <code>length</code> 属性。所以，只要我们“屏蔽”对 <code>length</code> 属性的读取，从而避免在它与副作用函数之间建立响应联系，问题就迎刃而解了。这个思路是正确的，因为数组的 <code>push</code> 方法在语义上是修改操作，而非读取操作，所以避免建立响应联系并不会产生其他副作用。有了解决思路后，我们尝试实现它，这需要重写数组的 <code>push</code> 方法，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 一个标记变量，代表是否进行追踪。默认值为 true，即允许追踪\n let shouldTrack = true\n // 重写数组的 push 方法\n ;['push'].forEach(method =&gt; {\n   // 取得原始 push 方法\n   const originMethod = Array.prototype[method]\n   // 重写\n   arrayInstrumentations[method] = function(...args) {\n     // 在调用原始方法之前，禁止追踪\n     shouldTrack = false\n     // push 方法的默认行为\n     let res = originMethod.apply(this, args)\n     // 在调用原始方法之后，恢复原来的行为，即允许追踪\n     shouldTrack = true\n     return res\n   }\n })\n</code></pre>\n<p>在这段代码中，我们定义了一个标记变量 <code>shouldTrack</code>，它是一个布尔值，代表是否允许追踪。接着，我们重写了数组的 <code>push</code> 方法，利用了前文介绍的 <code>arrayInstrumentations</code> 对象。重写后的 <code>push</code> 方法保留了默认行为，只不过在执行默认行为之前，先将标记变量 <code>shouldTrack</code> 的值设置为 <code>false</code>，即禁止追踪。当 <code>push</code> 方法的默认行为执行完毕后，再将标记变量 <code>shouldTrack</code> 的值还原为 <code>true</code>，代表允许追踪。最后，我们还需要修改 <code>track</code> 函数，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function track(target, key) {\n   // 当禁止追踪时，直接返回\n   if (!activeEffect || !shouldTrack) return\n   // 省略部分代码\n }\n</code></pre>\n<p>可以看到，当标记变量 <code>shouldTrack</code> 的值为 <code>false</code> 时，即禁止追踪时，<code>track</code> 函数会直接返回。这样，当 <code>push</code> 方法间接读取 <code>length</code> 属性值时，由于此时是禁止追踪的状态，所以 <code>length</code> 属性与副作用函数之间不会建立响应联系。这样就实现了前文给出的方案。我们再次尝试运行下面这段测试代码：</p>\n<pre class=\"code-rows\"><code> const arr = reactive([])\n // 第一个副作用函数\n effect(() =&gt; {\n   arr.push(1)\n })\n<p>// 第二个副作用函数<br />\neffect(() =&gt; {<br />\narr.push(1)<br />\n})<br />\n</code></pre></p>\n<p>会发现它能够正确地工作，并且不会导致调用栈溢出。</p>\n<p>除了 <code>push</code> 方法之外，<code>pop</code>、<code>shift</code>、<code>unshift</code> 以及 <code>splice</code> 等方法都需要做类似的处理。完整的代码如下：</p>\n<pre class=\"code-rows\"><code> let shouldTrack = true\n // 重写数组的 push、pop、shift、unshift 以及 splice 方法\n ;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(method =&gt; {\n   const originMethod = Array.prototype[method]\n   arrayInstrumentations[method] = function(...args) {\n     shouldTrack = false\n     let res = originMethod.apply(this, args)\n     shouldTrack = true\n     return res\n   }\n })\n</code></pre>\n","comments":[]}