{"id":726207,"title":"14｜tokio实战：编写一个网络命令行程序","content":"<p>你好，我是Mike，上一节课我们了解了Rust异步编程和tokio的基础知识，今天我们就来一起用tokio做一个小应用。</p><h2>准备阶段</h2><p>我们常常需要知道远程服务器上的一些信息，这有一些现成的工具可以做到。我们来试一下如何使用tokio实现这一功能。</p><p><strong>目标：</strong>编写一个获取服务器时间的命令行程序。</p><p><strong>任务分解：</strong></p><ol>\n<li>命令行：这个工具取名为 getinfo, 参数格式是 <code>getinfo {ip}</code>，就是在 getinfo 后接IP地址，获取服务器时间。</li>\n<li>tcp server：监听 8888 端口，获取从客户端来的请求，然后获取服务器本地时间，返回。</li>\n<li>tcp client：连接服务端地址 <code>ip:port</code>，向服务端发送获取服务器时间指令。</li>\n<li>测试。</li>\n</ol><h2>实现</h2><p>下面我们开始实现。</p><h3>创建项目</h3><p>我们打开终端或者IDE中的Terminal，执行：</p><pre><code class=\"language-plain\">cargo new --bin getinfo\n</code></pre><h3>命令行雏形</h3><p>Rust标准库中实际已经有获取命令行参数的功能，<code>std::env</code> 提供了一种获取命令行参数的方法 <a href=\"https://doc.rust-lang.org/std/index.html\">std</a>::<a href=\"https://doc.rust-lang.org/std/env/index.html\">env</a>::<a href=\"https://doc.rust-lang.org/std/env/fn.args.html#\">args</a>()，可以将命令行参数转换成一个迭代器，通过 for 循环就可以遍历所有命令行参数，当然也可以使用迭代器上的 <code>.nth()</code> 直接定位到某一个参数。比如：</p><pre><code class=\"language-plain\">let addr = env::args()\n&nbsp; &nbsp; .nth(1)\n&nbsp; &nbsp; .unwrap_or_else(|| \"127.0.0.1:8888\".to_string());\n</code></pre><!-- [[[read_end]]] --><p>有了这个功能，我们就可以得到命令行的初始版本。</p><pre><code class=\"language-plain\">use std::env;\n\nfn main() {\n  let addr = env::args()\n    .nth(1)\n    .unwrap_or(\"127.0.0.1:8888\".to_string());\n    \n  println!(\"{}\", addr);\n}\n</code></pre><p>检查一下Cargo.toml中的配置，我们的应用名字应该叫 getinfo。</p><pre><code class=\"language-plain\">[package]\nname = \"getinfo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n</code></pre><p>执行 cargo build 编译，会出现 target 目录。</p><pre><code class=\"language-plain\">Cargo.lock&nbsp; Cargo.toml&nbsp; src/&nbsp; target/\n</code></pre><p>执行 <code>cargo run</code> 或 <code>./target/debug/getinfo</code>。可以得到输出 <code>127.0.0.1:8888</code>。</p><p>而执行 <code>cargo run -- 127.0.0.1:8000</code> 或 <code>./target/debug/getinfo 127.0.0.1:8000</code>，可以得到输出 <code>127.0.0.1:8000</code>。</p><p>这里我们来分析一下这个命令行的形式。</p><pre><code class=\"language-plain\">./target/debug/getinfo ip_address\n</code></pre><p>命令行参数从左到右按序号从0开始计数，上面命令中，<code>./target/debug/getinfo</code> 序号为 0，<code>ip_address</code> 部分序号就是 1，如果后面还有其他参数，那么序号依次递增。所以你就可以理解为什么我们上面的代码中，使用 <code>.nth(1)</code> 取IP地址的信息。</p><p>标准库中命令行相关的功能虽然比较初级，但是对于我们的例子来说，已经够用了。Rust生态中有个非常好用的写命令行的库：<a href=\"https://crates.io/crates/clap\">clap</a>，如果你想写一个功能丰富的命令行程序，可以去尝试一下这个 clap。</p><p>下面我们就要开始 tokio tcp server 的创建。</p><h3>添加依赖</h3><p>先加入tokio的依赖，在项目目录下执行命令。</p><pre><code class=\"language-plain\">cargo add tokio --features full\ncargo add tokio-util --features full\ncargo add futures\ncargo add bytes\n</code></pre><p>执行完这几个添加依赖的命令后，Cargo.toml文件现在看起来是类似下面这个样子：</p><pre><code class=\"language-plain\">mike@LAPTOP-04V0EV33:~/works/jikeshijian/getinfo$ cat Cargo.toml\n[package]\nname = \"getinfo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\nbytes = \"1.5.0\"\nfutures = \"0.3.29\"\ntokio = { version = \"1.33.0\", features = [\"full\"] }\ntokio-util = { version = \"0.7.10\", features = [\"full\"] }\n</code></pre><p><code>cargo add</code> 工具为我们准确配置了具体依赖库的版本号和特性。</p><h3>基于tokio实现tcp server</h3><p>我们的tcp server实际要干下面几件事儿。</p><ol>\n<li>接收tcp client的连接，每一个新连接创建一个新的task。</li>\n<li>读取tcp client发过来的指令数据。</li>\n<li>根据指令，获取服务器本地的时间信息。</li>\n<li>将得到的信息字符串写入socket，返回给客户端。</li>\n</ol><pre><code class=\"language-plain\">use std::env;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\nuse tokio::net::TcpListener;\nuse tokio::process::Command;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n&nbsp; &nbsp; let addr = env::args()\n&nbsp; &nbsp; &nbsp; &nbsp; .nth(1)\n&nbsp; &nbsp; &nbsp; &nbsp; .unwrap_or_else(|| \"127.0.0.1:8888\".to_string());\n&nbsp; &nbsp; println!(\"Listening on: {}\", addr);\n&nbsp; &nbsp; let listener = TcpListener::bind(&amp;addr).await?;\n\n&nbsp; &nbsp; // 注意这里是一个无条件循环，表明始终处于服务状态\n&nbsp; &nbsp; loop {\n&nbsp; &nbsp; &nbsp; &nbsp; // 等待客户端请求连上来\n&nbsp; &nbsp; &nbsp; &nbsp; let (mut socket, _) = listener.accept().await?;\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 来一个客户端连接，创建一个对应的新任务\n&nbsp; &nbsp; &nbsp; &nbsp; tokio::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 分配一个缓冲存\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let mut buf = [0; 1024];\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let mut offset = 0;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 循环读，因为不能确保一次能从网络线路上读完数据\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loop {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 读操作，返回的n表示读了多少个字节\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 正常情况下，读到数据才会返回，如果没有读到，就会等待\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let n = socket\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .read(&amp;mut buf[offset..])\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .await\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .expect(\"failed to read data from socket\");\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // n返回0的情况，是碰到了EOF，表明远端的写操作已断开，这个一定要判断\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if n == 0 {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 碰到了EOF就直接返回结束此任务，因为后面的操作没了意义\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"offset: {offset}, n: {n}\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let end = offset + n;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 转换指令为字符串\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if let Ok(directive) = std::str::from_utf8(&amp;buf[..end]) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"{directive}\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 执行指令对应的工作\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let output = process(directive).await;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"{output}\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 向客户端返回处理结果\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; socket\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .write_all(&amp;output.as_bytes())\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .await\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .expect(\"failed to write data to socket\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 判断是否转换失败，如果失败，就有可能是网络上的数据还没读完\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 要继续loop读下一波数据\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = end;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; }\n}\n\nasync fn process(directive: &amp;str) -&gt; String {\n&nbsp; &nbsp; if directive == \"gettime\" {\n&nbsp; &nbsp; &nbsp; &nbsp; // 这里我们用了unwrap()是因为我们一般确信执行date命令不会失败\n&nbsp; &nbsp; &nbsp; &nbsp; // 更可靠的做法是对返回的Result作处理\n&nbsp; &nbsp; &nbsp; &nbsp; let output = Command::new(\"date\").output().await.unwrap();\n&nbsp; &nbsp; &nbsp; &nbsp; String::from_utf8(output.stdout).unwrap()\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; // 如果是其他指令，我们目前返回 无效指令\n&nbsp; &nbsp; &nbsp; &nbsp; \"invalid command\".to_owned()\n&nbsp; &nbsp; }\n}\n</code></pre><p>代码中有详细解释，这里我也补充说明一下。</p><p>首先，我们给main函数指定了返回类型：<code>Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt;</code>。错误类型部分是一个用 <code>Box&lt;T&gt;</code> 装盒的trait object，这个trait object是针对标准库中的Error trait的。在这里的意思是，凡是实现了Error trait的类型都可以作为错误类型从main函数中返回。</p><p>第12行 <code>let listener = TcpListener::bind(&amp;addr).await?;</code> 行末有一个问号，这是Rust里的问号操作符，意思是.await 得到数据后是一个 <code>Result&lt;&gt;</code>，如果这个 <code>Result&lt;&gt;</code> 是Ok值，那就解开它，返回里面的内容，这个例子里是一个TcpListener实例；而如果这个 <code>Result&lt;&gt;</code> 是Err值，那就直接从函数中返回，不再往下执行。问号操作符在这里起一个防御式编程的作用，能够让流程代码显得更简洁。</p><p>注意第15行是一个loop无条件循环，也就是死循环。为什么呢？因为这是个服务端程序，是需要一直跑着的，退出就意味着出问题了。</p><p>第17行，监听客户端来的连接，来一个就产生一个 socket 实例。我们看到，在let后面用了模式匹配写法，直接把元组析构了。如果来了多个连接，就会产生多个task，它们之间互不干扰，是并发处理的。</p><p>第20行，针对每一个连上的客户端连接，创建一个新的tokio轻量级线程task，来处理对应的任务。继续往下，第22行，可以看到，这个服务端程序为每个连接创建了一个缓冲区，大小是1024字节。从网络上读到的数据会放在这个缓冲区里面。</p><p>第25行，再次用了一个循环。因为网络上的数据是呈流的形式过来的，在一次CPU读取它之前，这些数据有可能还没完全到达服务器上面。因此可能需要多次读。读没读够，可以尝试把已经读到数据转换成字符串，看是否能成功来判断（这个判断方式并不严谨，这里主要用于说明流程）。如果成功了，就调用 <code>process()</code> 业务函数来计算。</p><p>process()异步函数中使用了 <code>tokio::process::Command</code> 类型来调用系统中的 <code>date</code> 命令，这是一个Linux下的查看系统日期时间的命令，会输出下面这种格式：</p><pre><code class=\"language-plain\">Tue Oct 31 14:56:27 CST 2023\n</code></pre><p><span class=\"reference\">注：如果你使用Windows的话，可以找找Windows里的替代命令。</span></p><p><code>process()</code> 函数会返回这个字符串。</p><p>然后，通过同一个 socket，将数据返回给客户端连接：<code>socket.write_all</code>。</p><p>在多次读的过程中，要注意偏移量offset的处理。可以看到，代码量虽然不多，但是充满了细节，请你仔细品味一下。</p><h3>基于tokio实现tcp client</h3><p>下面我们来看对应的tcp客户端应该怎么实现。</p><p>因为我们要马上再创建一个可执行程序，所以默认的 <code>cargo run</code> 命令就不能满足这个需求，它默认只能启动一个二进制文件。我们需要改一下Cargo.toml的配置，在文件中加入一些内容。</p><pre><code class=\"language-plain\">[[bin]]\nname = \"server\"\npath = \"src/server.rs\"\n\n[[bin]]\nname = \"client\"\npath = \"src/client.rs\"\n</code></pre><p>然后把src目录下的 main.rs 改成 server.rs，并创建一个新文件 client.rs，代码如下：</p><pre><code class=\"language-plain\">use std::env;\nuse tokio::io::{AsyncReadExt, AsyncWriteExt};\nuse tokio::net::TcpStream;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n&nbsp; &nbsp; let addr = env::args()\n&nbsp; &nbsp; &nbsp; &nbsp; .nth(1)\n&nbsp; &nbsp; &nbsp; &nbsp; .unwrap_or_else(|| \"127.0.0.1:8888\".to_string());\n&nbsp; &nbsp; // 连接到服务端\n&nbsp; &nbsp; let mut stream = TcpStream::connect(&amp;addr).await?;\n\n&nbsp; &nbsp; // 写入指令数据，这是一种最简单的协议.\n&nbsp; &nbsp; stream.write_all(b\"gettime\").await?;\n\n&nbsp; &nbsp; // 等待tcp server的回复，读取内容\n&nbsp; &nbsp; // 这里用动态数组来存储从服务端返回的内容\n&nbsp; &nbsp; let mut buf: Vec&lt;u8&gt; = Vec::with_capacity(8128);\n&nbsp; &nbsp; // 读取的缓冲区\n&nbsp; &nbsp; let mut resp = [0u8; 2048];\n&nbsp; &nbsp; loop {\n&nbsp; &nbsp; &nbsp; &nbsp; // 尝试一次读，返回读到的字节数\n&nbsp; &nbsp; &nbsp; &nbsp; let n = stream.read(&amp;mut resp).await?;\n&nbsp; &nbsp; &nbsp; &nbsp; // 将读到的字节合并到buf中去\n&nbsp; &nbsp; &nbsp; &nbsp; buf.extend_from_slice(&amp;resp[0..n]);\n&nbsp; &nbsp; &nbsp; &nbsp; if n == 0 {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 流断掉了\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; panic!(\"Unexpected EOF\");\n&nbsp; &nbsp; &nbsp; &nbsp; } else if buf.len() &gt;= 28 {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // like: \"Tue Oct 31 14:56:27 CST 2023\"\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // buf 已经填充了足够的内容\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // buf 中还没有足够多的内容，继续填充...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; // 转换并打印返回的信息\n&nbsp; &nbsp; let timeinfo = String::from_utf8(buf)?;\n&nbsp; &nbsp; println!(\"{}\", timeinfo);\n\n&nbsp; &nbsp; Ok(())\n}\n</code></pre><p>代码中有详细解释，这里我也做一下补充说明。</p><p>第11行，我们使用 <code>TcpStream::connect()</code> 连到服务端上去，注意这点和服务端的监听是不同的。然后第14行，向tcp连接中写入协议指令，这里就是简单的字节串：<code>b\"gettime\"</code>。</p><p>然后第17行到25行，我们采用了另外一种方式来存储读回来的数据，这里用到了动态数组Vec的 <code>API extend_from_slice()</code>，这个的好处是不需要由自己来维护每次读到的偏移量。第21行，我们再次使用了loop，还是同样的原因，网络上的数据流，我们有可能一次读取不完，需要多次读才行。</p><p>第29行是跳出此循环的判断条件，这里是因为我们知道会返回 date 命令的输出结果，它是固定的28个字节的长度。这个条件相当死板，这里也只是起演示作用。</p><p>最后就把这个从服务端程序得到的内容打印出来。下面我们开始测试。</p><h3>测试</h3><p>编译运行服务端：</p><pre><code class=\"language-plain\">cargo run --bin server 或 cargo run --bin server -- 127.0.0.1:8888\n</code></pre><p>编译执行客户端：</p><pre><code class=\"language-plain\">cargo run --bin client 或 cargo run --bin client -- 127.0.0.1:8888\n</code></pre><p>查看执行效果。</p><p>服务端打印：</p><pre><code class=\"language-plain\">Listening on: 127.0.0.1:8888\noffset: 0, n: 7\ngettime\nTue Oct 31 15:04:08 CST 2023\n\n</code></pre><p>客户端打印：</p><pre><code class=\"language-plain\">Tue Oct 31 15:07:48 CST 2023\n\n</code></pre><p>这样，我们就成功实现了我们的第一个命令行应用，并完整体验了tokio网络编程。</p><h2>Frame 层</h2><p>前面我们的实现，完成了这个应用初步的功能。但是实际上对于我们初学者来说，难度还是比较大，主要体现在4个方面。</p><ol>\n<li>什么时候要加loop，什么时候不加？</li>\n<li>两个端的合法性判定条件是什么？能否推广到适用面更广的方式？</li>\n<li>多次读取的偏移量或缓冲区如何准确维护？</li>\n<li>tcp网络协议的背景知识，服务端与客户端的基本概念，EOF在什么条件下触发等等。</li>\n</ol><p>其中前面三条都属于实现层面的细节，我们可以来了解一下产生这些复杂性的原因。</p><h3>复杂性的来源</h3><p>我们知道，一个tcp连接就像一个管道一样，里面流过的是一个个的字节，也就是说，它传输的是一个字节流。然而，由于网络本身的复杂性，比如如果服务器在很远的地方，数据有可能要经历过很多次路由器/交换机才能到达，有可能一个字节和下一个字节之间会间隔一段时间才能传过来。这时候，直接在 socket 上做的一次 read，并不能保证就一定读完整了我们想要的内容，有可能只读到了一个片段而已。</p><p>这个问题其实属于传输层的问题，不应该让上层业务开发人员来担忧。如果在考虑业务的同时，还要考虑这种底层问题的话，总会感觉施展不开，各种细节会缠得你寸步难行。</p><p>比如有两个人A和B，A给B发送两条消息msg_a和msg_b，B 接收消息的时候，一般会希望编程接口每次拿到一个完整的消息，第一次取是msg_a，不多也不少；第二次取是 msg_b，不多也不少。不会担心每次取的时候，消息可能取不完整，需要用一个循环重复取，并且还得把每次取到的片段拼接成一个大的完整的消息内容。</p><p>当消息体小的时候，可能问题不明显，当消息体大的时候，比如一次有几兆内容的时候，这个问题其实就无法忽略了。</p><p>好在tokio框架已经为我们考虑了这个问题。tokio生态引入了Frame的概念，Frame就是一个帧/框，一个Frame里可以包含一段完整的可预期的信息。相当于它在tcp这一层之上又抽象了一层，封装了具体怎么读取和切分原始的字节序列这个问题。Frame让我们读到的总是业务关心的一批批数据：msg。Frame机制将网络流的原始字节序列转换成Frame序列，并且会自动帮我们确定Frame的边界在哪里。</p><h3>Frame编解码</h3><p>既然是Frame，就涉及到采用何种编码的问题。Frame本身只是一个框的概念，这个框里面具体填什么格式的内容，是由编码决定的，写入的时候编码，取出的时候需要解码。</p><p>与 tokio 配套的 tokio_util crate 里，提供了四种最简单的编解码类型：BytesCodec、LinesCodec、AnyDelimiterCodec、LengthDelimitedCodec。我们分别介绍一下。</p><ul>\n<li>BytesCodec</li>\n</ul><p>Frame长度为1的编解码。一个字节一个Frame。适用于文本和二进制的任何网络协议。如果你的应用就想一个字节一个字节地处理数据流，这个就是合适的选择。</p><ul>\n<li>LinesCodec</li>\n</ul><p>行编解码协议，它使用 <code>\\n</code> 作为Frame之间的分隔。这个协议用得很多，特别适合文本网络协议。</p><ul>\n<li>AnyDelimiterCodec</li>\n</ul><p>指定间隔符的编解码协议，这个相当于LinesCodec的扩展版本。用这个协议，你可以自定义任何Frame分隔符，比如 ; , # 等等。它也比较适用于文本网络协议。</p><ul>\n<li>LengthDelimitedCodec</li>\n</ul><p>长度分隔编解码协议。这个协议的思路是，每一个msg发送的时候，在它前面，都加上一个固定位数的长度表示前缀。这样，每次读到这个前缀数字的时候，就知道接下来要读多少个字节，才会形成一个完整的Frame。比如编码后的一个Frame类似下面这个样子：</p><pre><code class=\"language-plain\">+----------+--------------------------------+\n| len: u32 |          frame payload         |\n+----------+--------------------------------+\n</code></pre><p>这个方法是协议设计的典型方法，具有非常强的通用性，适用于文本或二进制的网络协议。</p><p>tokio不仅提供了这些默认的简单的编解码方案，它还允许你自定义Codec。如果上面4种都不能满足你的需求，你完全可以按它的规范自定义一个。</p><p>此处，我们可以用LengthDelimitedCodec，只需要在基本的 TcpStream 上套一下就可以了。接着往下看。</p><h3>使用Frame改造代码</h3><p>使用Framed + LengthDelimitedCodec 类型改造后的服务端和客户端代码如下：</p><p>服务端代码：</p><pre><code class=\"language-plain\">use bytes::Bytes;\nuse futures::{SinkExt, StreamExt};\nuse std::env;\nuse tokio::net::TcpListener;\nuse tokio::process::Command;\nuse tokio_util::codec::{Framed, LengthDelimitedCodec};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n&nbsp; &nbsp; let addr = env::args()\n&nbsp; &nbsp; &nbsp; &nbsp; .nth(1)\n&nbsp; &nbsp; &nbsp; &nbsp; .unwrap_or_else(|| \"127.0.0.1:8888\".to_string());\n&nbsp; &nbsp; println!(\"Listening on: {}\", addr);\n&nbsp; &nbsp; let listener = TcpListener::bind(&amp;addr).await?;\n\n&nbsp; &nbsp; // 注意这里是一个无条件循环，表明始终处于服务状态\n&nbsp; &nbsp; loop {\n&nbsp; &nbsp; &nbsp; &nbsp; // 等待客户端请求连上来\n&nbsp; &nbsp; &nbsp; &nbsp; let (stream, _) = listener.accept().await?;\n&nbsp; &nbsp; &nbsp; &nbsp; // 包裹成一个Frame stream\n&nbsp; &nbsp; &nbsp; &nbsp; let mut framed_stream = Framed::new(stream, LengthDelimitedCodec::new());\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 创建子task执行任务\n&nbsp; &nbsp; &nbsp; &nbsp; tokio::spawn(async move {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 等待读取一个一个msg，如果返回None，会退出这个循环\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while let Some(msg) = framed_stream.next().await {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; match msg {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ok(msg) =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 解析指令，执行任务\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let directive = String::from_utf8(msg.to_vec())\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .expect(\"error when converting to string directive.\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"{directive}\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let output = process(&amp;directive).await;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"{output}\");\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 返回执行结果\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _ = framed_stream.send(Bytes::from(output)).await;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Err(e) =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"{e:?}\");\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; }\n}\n\nasync fn process(directive: &amp;str) -&gt; String {\n&nbsp; &nbsp; if directive == \"gettime\" {\n&nbsp; &nbsp; &nbsp; &nbsp; // 这里我们用了unwrap()是因为我们一般确信执行date命令不会失败\n&nbsp; &nbsp; &nbsp; &nbsp; // 更可靠的做法是对返回的Result作处理\n&nbsp; &nbsp; &nbsp; &nbsp; let output = Command::new(\"date\").output().await.unwrap();\n&nbsp; &nbsp; &nbsp; &nbsp; String::from_utf8(output.stdout).unwrap()\n&nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; // 如果是其他指令，我们目前返回 无效指令\n&nbsp; &nbsp; &nbsp; &nbsp; \"invalid command\".to_owned()\n&nbsp; &nbsp; }\n}\n</code></pre><p>这里我简单解释一下上面的示例。</p><p>在监听到连接stream（第19行）后，把它包裹成Frame stream（第21行），然后使用 <code>while let</code> 配合 <code>framed_stream.next()</code> 对这个流进行迭代，就读出了里面一帧一帧的数据msg。需要返回结果的时候，使用 <code>framed_stream.send()</code> 就可以了。</p><p>客户端代码：</p><pre><code class=\"language-plain\">use bytes::Bytes;\nuse futures::{SinkExt, StreamExt};\nuse std::env;\nuse tokio::net::TcpStream;\nuse tokio_util::codec::{Framed, LengthDelimitedCodec};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n&nbsp; &nbsp; let addr = env::args()\n&nbsp; &nbsp; &nbsp; &nbsp; .nth(1)\n&nbsp; &nbsp; &nbsp; &nbsp; .unwrap_or_else(|| \"127.0.0.1:8888\".to_string());\n&nbsp; &nbsp; // 连接到服务端\n&nbsp; &nbsp; let stream = TcpStream::connect(&amp;addr).await?;\n&nbsp; &nbsp; // 包裹成 Frame stream\n&nbsp; &nbsp; let mut framed_stream = Framed::new(stream, LengthDelimitedCodec::new());\n\n&nbsp; &nbsp; // 发送指令\n&nbsp; &nbsp; framed_stream.send(Bytes::from(\"gettime\")).await?;\n\n&nbsp; &nbsp; // 读取返回数据，这里只读一次\n&nbsp; &nbsp; if let Some(msg) = framed_stream.next().await {\n&nbsp; &nbsp; &nbsp; &nbsp; match msg {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Ok(msg) =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; let timeinfo = String::from_utf8(msg.to_vec())?;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; println!(\"{}\", timeinfo);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Err(e) =&gt; return Err(e.into()),\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; Ok(())\n}\n</code></pre><p>在连接到服务器，得到连接stream（第13行）后，把它包裹成Frame stream（第15行） ，然后使用 <code>framed_stream.send()</code> 发送一条指令，在后面用迭代器方法等待指令执行后返回的内容msg。对msg的处理方式和服务端代码一致。</p><p>可以看到，经过Frame层抽象后，大大精简了代码逻辑，整体变得非常清爽。最关键的是，改造后的代码实际<strong>完全重塑了程序员的心智模型</strong>：我们不再需要关注底层传输的大量细节了，真正实现了面向业务编码，可以按时下班了，非常开心。</p><p><span class=\"reference\">注：这节课的完整代码点击<a href=\"https://github.com/miketang84/jikeshijian/tree/master/14-getinfo\">这里</a>可以获取。</span></p><h2>小结</h2><p>这节课我们一起学习了如何循序渐进地基于tokio开发一个服务端和客户端tcp网络应用命令行程序。知识点很多，我们一起来回顾一下。</p><ul>\n<li>Rust中命令行参数的获取方式；</li>\n<li>在Cargo.toml 配置文件中添加依赖；</li>\n<li>在服务端建立 tcp lisener；</li>\n<li>根据新的连接创建新的task；</li>\n<li>读取tcp数据输入，以及写入返回内容；</li>\n<li>建立 tcp client 连接；</li>\n<li>编译测试Rust命令行程序；</li>\n<li>tokio的Frame概念和编解码；</li>\n<li>使用Frame简化网络编程。</li>\n</ul><p>网络编程有其复杂性在里面，所以这节课我们应该重点掌握使用Frame的编程模型，同时了解原始字节流的处理原理。</p><h2>思考题</h2><p>最后请你来思考2个问题。</p><ol>\n<li>EOF是什么，什么时候会碰到EOF？</li>\n<li>请问 stream.read_to_end() 接口能读完网络连接中的数据吗？</li>\n</ol><p>欢迎你把思考后的结果分享到评论区和我一起讨论，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":384177,"user_name":"PEtFiSh","can_delete":false,"product_type":"c1","uid":1765926,"ip_address":"四川","ucode":"C4922398A92E05","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLO6XvxfFPMGcVSSX8uIZY2yib29qlyat178pU4QM3gIic5GXZ8PC0tzRiazP3FiajXbTj19SE4ZhV0gQ/132","comment_is_top":false,"comment_ctime":1700465984,"is_pvip":false,"replies":[{"id":140156,"content":"👍，真棒！","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700540116,"ip_address":"重庆","comment_id":384177,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"EOF: End of file. 在linux万物皆file的情况下connection也可以是一个file。所以，当Connection关闭的时候，就会产生EOF。\nstream.read_to_end()是持续read()直到EOF，因此能够读完网络里的数据，如果使用stream.read_to_end(&amp;mut buf).await?;读取的话，会持续wait，直到连接关闭才能进行后续的操作。","like_count":6,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632171,"discussion_content":"👍，真棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700540116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384160,"user_name":"学水","can_delete":false,"product_type":"c1","uid":2557688,"ip_address":"加拿大","ucode":"F8B27FD11187EC","user_header":"https://static001.geekbang.org/account/avatar/00/27/06/f8/09ad484b.jpg","comment_is_top":false,"comment_ctime":1700441281,"is_pvip":false,"replies":[{"id":140162,"content":"对的，其实网络编程到了底层基本都是这个样子了。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700540931,"ip_address":"重庆","comment_id":384160,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"感觉这部分内容和java的netty包有点像","like_count":4,"discussions":[{"author":{"id":2178332,"avatar":"","nickname":"杨国威","note":"","ucode":"F5FD883322772D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632068,"discussion_content":"tcp网络通信协议是标准，不同语言处理起来当然要像。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1700445420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632177,"discussion_content":"对的，其实网络编程到了底层基本都是这个样子了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1700540931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2911084,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6b/6c/3e80afaf.jpg","nickname":"HappyHasson","note":"","ucode":"B84CC43E349CFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649017,"discussion_content":"和语言无关，是网络编程的知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1722559140,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385978,"user_name":"沉默的话唠","can_delete":false,"product_type":"c1","uid":1231254,"ip_address":"广西","ucode":"90212EF174C6E3","user_header":"https://static001.geekbang.org/account/avatar/00/12/c9/96/4577c1ef.jpg","comment_is_top":false,"comment_ctime":1703756293,"is_pvip":false,"replies":[{"id":140691,"content":"感谢肯定🙏，回头和小编商量商量。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703856042,"ip_address":"重庆","comment_id":385978,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"跟着一路下来，感觉讲师讲的真的不错。 不知道后面考不考虑有训练营之类的，更加全面体系的课程。","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634751,"discussion_content":"感谢肯定🙏，回头和小编商量商量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703856042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384404,"user_name":"Citroen","can_delete":false,"product_type":"c1","uid":2188563,"ip_address":"辽宁","ucode":"03017DB11EC537","user_header":"https://static001.geekbang.org/account/avatar/00/21/65/13/8654e7c9.jpg","comment_is_top":false,"comment_ctime":1700814729,"is_pvip":false,"replies":[{"id":140251,"content":"很简单，发送端用 LengthDelimitedCodec 编码的，接收端也同样用 LengthDelimitedCodec 解码就行了。tokio的这层Framed包装自动完成了这项工作了，具体的编解码是在下层layer做的，上层你就关心业务就好啦，已经给你取到了。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700837604,"ip_address":"重庆","comment_id":384404,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"这段代码\nlet mut framed_stream = Framed::new(stream, LengthDelimitedCodec::new())\n请问一下老师，我现在需要接收client端的数据（数据是打包好的protobuf序列化后的二进制数据，\n前面有四位长度表示这个序列化后的二进制数据的长度，也就是说数据格式是，头（四位 用于说明后面完整protobuf序列化后的数据长度）加内容（protobuf序列化后的二进制数据）,len(四位长度）加main(protobuf序列化后的二进制数据 每次长度不固定，但可通过前面的len可以知道），每段数据都是这样 这样的数据怎么取？","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632493,"discussion_content":"很简单，发送端用 LengthDelimitedCodec 编码的，接收端也同样用 LengthDelimitedCodec 解码就行了。tokio的这层Framed包装自动完成了这项工作了，具体的编解码是在下层layer做的，上层你就关心业务就好啦，已经给你取到了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700837604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2764102,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/2d/46/e6235836.jpg","nickname":"令狐萝卜","note":"","ucode":"1F8FDCF9B6B509","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":632657,"discussion_content":"那服务器是怎么知道客户端用什么编码方式呢？换一种编码方式是不是就不能工作了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701149412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":632493,"ip_address":"湖北","group_id":0},"score":632657,"extra":""},{"author":{"id":2188563,"avatar":"https://static001.geekbang.org/account/avatar/00/21/65/13/8654e7c9.jpg","nickname":"Citroen","note":"","ucode":"03017DB11EC537","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2764102,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/2d/46/e6235836.jpg","nickname":"令狐萝卜","note":"","ucode":"1F8FDCF9B6B509","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632672,"discussion_content":"老师的意思应该是其他客户端应该是按照服务器端使用的LengthDelimitedCodec配置方式组装数据，这样应该就没问题了。比如服务器端用默认的LengthDelimitedCodec 配置，那么client端如果不用相同的发送方式，那就要自己拼装数据，把数据做成头是uint32表示的信息长度大小，然后后面紧接着是数据内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701163538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":632657,"ip_address":"辽宁","group_id":0},"score":632672,"extra":""}]}]},{"had_liked":false,"id":384193,"user_name":"哄哄","can_delete":false,"product_type":"c1","uid":3779530,"ip_address":"北京","ucode":"F75FB23BEDC60A","user_header":"https://static001.geekbang.org/account/avatar/00/39/ab/ca/32d6c05d.jpg","comment_is_top":false,"comment_ctime":1700484572,"is_pvip":false,"replies":[{"id":140154,"content":"crates.io,  lib.rs, https:&#47;&#47;github.com&#47;rust-unofficial&#47;awesome-rust","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700539732,"ip_address":"重庆","comment_id":384193,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"应该用什么已有的crate包，感觉也是新人的一个问题。请问上哪能快速认识常用第三方包呢？","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632169,"discussion_content":"crates.io,  lib.rs, https://github.com/rust-unofficial/awesome-rust","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700539732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385716,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1703154117,"is_pvip":false,"replies":[{"id":140635,"content":"tokio strean是全双工的，可以写。但是你如果程序被卡在 read_to_end 那里，那写逻辑也执行不了。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703578027,"ip_address":"重庆","comment_id":385716,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"EOF =&gt; End Of File, 在数据流断开的时候会碰到\n\nstream.read_to_end(buf) =&gt; 把这个 stream 里接收到的所有数据都丢到一个 buf_vec 里， 应该是一个阻塞函数吧， 只要链接不断开， 就一直等待， 单开一个进程 &#47; 线程来跑 read_to_end 然后在别的进程 &#47; 线程从 buf 里往外面读数据\n\n不过感觉如果用 read_to_end 的话当前 stream 就没办法往里写数据了， 这咋整啊， 难道是 clone 一份 stream 然后在其他进程 &#47; 线程来写吗， 还是设计的时候就不考虑往 `用了 read_to_end 的 stream`里继续写数据了？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634501,"discussion_content":"tokio strean是全双工的，可以写。但是你如果程序被卡在 read_to_end 那里，那写逻辑也执行不了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703578027,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385711,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1703152238,"is_pvip":false,"replies":[{"id":140588,"content":"https:&#47;&#47;github.com&#47;miketang84&#47;jikeshijian&#47;","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703232544,"ip_address":"重庆","comment_id":385711,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"啊？ 有源码的啊， star 一下先","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634338,"discussion_content":"https://github.com/miketang84/jikeshijian/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1703232544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385668,"user_name":"-Hedon🍭","can_delete":false,"product_type":"c1","uid":3176234,"ip_address":"湖北","ucode":"FAE541E7A2B88F","user_header":"https://static001.geekbang.org/account/avatar/00/30/77/2a/0cd4c373.jpg","comment_is_top":false,"comment_ctime":1703070266,"is_pvip":false,"replies":[{"id":140553,"content":"👍，不错。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703122431,"ip_address":"重庆","comment_id":385668,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题1：EOF\n\n\tEOF 是 &quot;End of File&quot; 的缩写，意为“文件结束”。它是一个用于表示文件或数据流末尾的控制信号或字符。当读取文件或数据流时，EOF用于指示没有更多的数据可读取。\n\t\n\tEOF 通常出现在以下几种情况：\n\n\t1. 文件读取：在读取文件内容时，到达文件末尾后，会遇到 EOF。这告诉程序没有更多的数据可读取。\n\n\t2. 标准输入：在某些编程语言或环境中，如 Unix&#47;Linux 的命令行，可以使用特定的键盘组合（如 Ctrl+D ）来生成 EOF 信号，表示标准输入结束。\n\n\t3. 数据流结束：在处理数据流（如网络传输中的数据）时，EOF 可以用来指示数据传输已经完成。\n\n\n思考题2：stream.read_to_end()\n\n\t首先我觉得核心点在 “读完” 这个概念上，即意味着连接中的数据是有限的，才有读完，如果是无限的流数据，那么 stream.read_to_end() 会一直阻塞等待数据的到来。如果明确数据的有限的，那么在数据源发出 EOF 后，stream.read_to_end() 就会返回，那这个时候是可以 “读完” 的。当前，前提是你的内存得够。\n\n\n(连续2周搬砖赶需求，终于能抽点时间续上 rust 的学习了 T_T)","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634228,"discussion_content":"👍，不错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703122431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384174,"user_name":"A0.何文祥","can_delete":false,"product_type":"c1","uid":1052569,"ip_address":"广东","ucode":"2549126DAEA15D","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/99/0d72321f.jpg","comment_is_top":false,"comment_ctime":1700463048,"is_pvip":false,"replies":[{"id":140152,"content":"再次感谢🤝","user_name":"编辑回复","user_name_real":"编辑","uid":2843479,"ctime":1700538194,"ip_address":"北京","comment_id":384174,"utype":2}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"cargo new --bin getinf应为cargo new --bin getinfo","like_count":0,"discussions":[{"author":{"id":2843479,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","nickname":"小虎子🐯","note":"","ucode":"4C9530B3FB407B","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632167,"discussion_content":"再次感谢🤝","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700538194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384167,"user_name":"Andylinge","can_delete":false,"product_type":"c1","uid":2727445,"ip_address":"江苏","ucode":"D0D24185E99A67","user_header":"https://static001.geekbang.org/account/avatar/00/29/9e/15/e499fc69.jpg","comment_is_top":false,"comment_ctime":1700452412,"is_pvip":false,"replies":[{"id":140157,"content":"对的，date命令是linux下的，抱歉忘了这个细节，后面想办法补充说明一下。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700540207,"ip_address":"重庆","comment_id":384167,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"Windows 11 报如下错误，大家可以把process里面的获取时间命令自己用Rust重写一下。\n```Listening on: 127.0.0.1:8880\nAccepted a connection from: 127.0.0.1:9354\ngettime\nthread &#39;tokio-runtime-worker&#39; panicked at src&#47;server.rs:80:58:\ncalled `Result::unwrap()` on an `Err` value: Error { kind: NotFound, message: &quot;program not found&quot; }\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nerror: process didn&#39;t exit successfully: `D:\\00-Program\\05-Rust\\14-Rust_MikeTang\\r14_tokio\\getinfo\\target\\debug\\server.exe` (exit code: 0xc000013a, STATUS_CONTROL_C_EXIT)\n```","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632172,"discussion_content":"对的，date命令是linux下的，抱歉忘了这个细节，后面想办法补充说明一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700540207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2414906,"avatar":"https://static001.geekbang.org/account/avatar/00/24/d9/3a/9a867533.jpg","nickname":"何浩","note":"","ucode":"1DE354DF5F42C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634616,"discussion_content":"修改文件如下，可以成功打印出\nserver：\nListening on: 127.0.0.1:8888\noffset: 0, n: 7\ngettime\n2023-12-28\nclient：\n2023-12-28\n\nserver.rs :\nlet output = Command::new(&#34;date&#34;).output().await.unwrap(); \n==&gt;        \n        let output = if cfg!(target_os = &#34;windows&#34;) {\n    Command::new(&#34;cmd&#34;)\n        .args([&#34;/C&#34;, &#34;echo %date:~0,4%-%date:~5,2%-%date:~8,2%&#34;])\n        .output()\n        .await.unwrap()\n} else {\n    Command::new(&#34;sh&#34;)\n        .arg(&#34;-c&#34;)\n        .arg(&#34;date&#34;)\n        .output()\n        .await.unwrap()\n};\n\nclient.rs\n} else if buf.len() &gt;= 28 {\n            // like: &#34;Tue Oct 31 14:56:27 CST 2023&#34;\n            // buf 已经填充了足够的内容\n            break;\n==&gt;\n else if buf.len() &gt;= 10 {\n            // like: &#34;Tue Oct 31 14:56:27 CST 2023&#34;\n            // buf 已经填充了足够的内容\n            break;\n\n","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1703736675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"陕西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384156,"user_name":"学水","can_delete":false,"product_type":"c1","uid":2557688,"ip_address":"加拿大","ucode":"F8B27FD11187EC","user_header":"https://static001.geekbang.org/account/avatar/00/27/06/f8/09ad484b.jpg","comment_is_top":false,"comment_ctime":1700437777,"is_pvip":false,"replies":[{"id":140161,"content":"恭喜同学，你找到了一条虫子。👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1700540912,"ip_address":"重庆","comment_id":384156,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"第一版server代码，没读到完整请求的话，为啥更新offset为n而不是end呢","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":632176,"discussion_content":"恭喜同学，你找到了一条虫子。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1700540912,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385713,"user_name":"superggn","can_delete":false,"product_type":"c1","uid":3623568,"ip_address":"北京","ucode":"831CCD98B393FE","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/7Q403U68Oy4lXG5sFBPVKLrfwaRzBqpBZibpEBXcPf9UOO3qrnh7RELoByTLzBZLkN9Nukfsj7DibynbZjKAKgag/132","comment_is_top":false,"comment_ctime":1703152920,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100626901,"comment_content":"笔记\n\nstream &#47; socket 这个东西， 不用关心具体定义， 只要知道拿着它可以进行读写操作就行了\n\n\n\nserver 跑起来了之后可以用 nc 命令来简单跑一下测试（不用 client.rs）， 注意 nc 发的消息自带一个 `\\n`, 记得 strip_suffix 搞一下\n\n&gt;nc 127.0.0.1 8888\n\n\n\nps: 前段时间撸 https:&#47;&#47;github.com&#47;jonhoo&#47;rust-tcp 快撸哭了... 看到 tokio 这么简单的代码真舒服","like_count":2}]}