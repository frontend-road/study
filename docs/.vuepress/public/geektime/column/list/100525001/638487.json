{"id":638487,"title":"14｜过大类重构：如何重构动辄过万行的一个类？","content":"<p>你好，我是黄俊彬。</p><p>上节课，我们一起学习了如何将大型的单体遗留系统重构为组件化架构。通过这次重构，我们有了更加低耦合、高内聚的组件。但是回到组件内部，代码质量对开发也非常重要。我相信你在过去的代码里一定会遇到一种典型的代码坏味道，那就是“过大类”。</p><p>在产品迭代的过程中，由于缺少规范和守护，单个类很容易急剧膨胀，有的甚至达到几万行的规模。过大的类会导致发散式的修改问题，只要需求有变化，这个类就得做相应修改。所以才有了有时候的“不得已而为之”的做法：为了不让修改引起新的问题，通过复制黏贴来扩展功能。</p><p>所以这节课，我们将一起来学习“过大类”的重构之法。我们将组件内分层架构重构流程分为3个维度和7个步骤，希望通过这些流程方法，可以帮助你更加高效、高质量完成代码重构。</p><h2>“过大类”的典型问题</h2><p>在移动应用中，“过大类”最常见的情况就是将所有的业务逻辑都写在同一个界面之中。我们来看看后面这段示例代码。</p><pre><code class=\"language-plain\">public class LoginActivity extends AppCompatActivity {\n    \n    //省略相关代码... ...\n    \n&nbsp;&nbsp;&nbsp;&nbsp;@Override\n&nbsp;&nbsp;&nbsp;&nbsp;public void onCreate(Bundle savedInstanceState) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.onCreate(savedInstanceState);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loginButton.setOnClickListener(v -&gt; {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String username = usernameEditText.getText().toString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String password = passwordEditText.getText().toString();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//用户登录\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LogUtils.log(\"login...\", username);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//验证账号及密码\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isValid(username) || isValid(password)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callBack.filed(\"invalid\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//通过服务器判断账户及密码的有效性x\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean result = checkFromServer(username, password);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserController.isLogin = true;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserController.currentUserInfo = new UserInfo();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UserController.currentUserInfo.username = username;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//登录成功保持本地的信息\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SharedPreferencesUtils.put(this, username, password);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log.d(\"login failed\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (NetworkErrorException networkErrorException) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log.d(\"networkErrorException\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;private static boolean isValid(String str) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (str == null || TextUtils.isEmpty(str)) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;private boolean checkFromServer(String username, String password) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//通过网络请求服务数据\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String result = httpUtil.post(username, password);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//解析Json对象\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSONObject jsonObject = new JSONObject(result);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return jsonObject.getBoolean(\"result\");\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch (JSONException e) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;public static final String FILE_NAME = \"share_data\";\n&nbsp;&nbsp;&nbsp;&nbsp;public static void put(Context context, String key, Object object) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SharedPreferences sp = context.getSharedPreferences(FILE_NAME,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Context.MODE_PRIVATE);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SharedPreferences.Editor editor = sp.edit();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//... ...\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;editor.apply();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n  //省略相关代码... ...\n  \n}\n</code></pre><!-- [[[read_end]]] --><p>从上面的示例代码中可以看出，创建页面时初始化数据后，当用户点击了登录按钮触发数据的校验后，通过网络请求校验数据的正确性，最后进行本地的持续化数据存储。</p><p>登录页面不仅仅承载了UI控件的初始化和管理，还需要负责登录网络请求、数据校验及结果处理、数据的持久化存储等功能。</p><p>假如现在有这么几个产品的需求要增加，应该如何修改代码进行功能扩展呢？</p><ul>\n<li>UI上要做一些优化，当登录失败时要弹出提示框提醒用户。</li>\n<li>我们需要对数据存储进行升级，所有数据要存储到数据库中。</li>\n<li>用户名的规则升级为仅支持电话和邮箱格式，需要在本地做校验。</li>\n</ul><p>我们可以看出基于这样的设计，不管是UI还是校验规则上有需求变化，抑或是数据持久化或网络框架有变化，都需要对登录页面进行修改。当大量的逻辑耦合在一起时，如果没有任何自动化测试守护，那么就会大大增加修改代码的风险。而且，要是基于这个代码再持续不断地添加新功能 ，就会陷入代码越来越差、但又越来越不敢修改代码的死循环之中。</p><h2>重构策略</h2><p>随着业务需求和代码规模的不断膨胀，我们针对过大类的重构策略就是<strong>分而治之</strong>。通过分层将不同维度的变化控制在独立的边界中，使之能够独立的演化，从而减少修改代码时彼此之间产生的影响。</p><p>从前面的例子我们可以识别出典型的3个不同维度的变化场景：第一个是UI上的变化；第二个是业务数据逻辑的变化；第三个维度是基础设施框架的变化。</p><p>UI上的变化，如主题或排版的设计，不会对数据业务产生影响，此时如果有独立的UI层，在扩展、修改时就能减少对其他逻辑代码的影响。一般在常见的分层架构模式下，会有独立的View层来承载独立的UI变化。</p><p>业务数据逻辑的变化也一样，一些数据的校验、计算、组装规则也都是容易发生变化的维度。同样在常见的分层架构中也有独立的业务逻辑处理层。</p><p>最后一个容易变化的地方就是基础设施框架，比如持久化的框架，可能会从前期轻量的配置存储需求演化为数据库的存储；网络请求框架则可能会随着技术栈的升级替换为新的框架。如果此时所有对于基础设施的调用都散落在各个UI的入口上，那么修改变更的成本就会非常高。</p><p>下面我们以MVP（Model-View-Presenter）这种分层架构为例，一起来看看MVP的架构是如何进行分层设计和交互的。在MVP模式中，模型层提供数据，视图层负责显示，表现层负责逻辑的处理。</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/a8/e8b6089f06fceb01b14yy04f16b544a8.jpg?wh=3069x1771\" alt=\"\" title=\"MVP模式的架构设计\n\"></p><p>MVP架构在视图层与表现层的交互过程中都会定义对应的接口，以使彼此之间的依赖更加稳定。由于模型与视图完全分离，我们可以在修改视图时不影响模型。同时也可以将一个表现层用于多个视图，且不需要改变表现层的逻辑。这个特点非常有用，因为视图的变化总是比模型的变化更加频繁。</p><p>另外，使用接口依赖能更好地提高代码的可测试性，例如在对表现层进行分层测试时，只需要验证视图层的接口有没有正常被调用即可。相比对几百行的方法进行测试，职责更加单一的分层能让编写自动化测试的工作变得更简单。</p><p>我们还是以上面那个新增需求为例，进行重构后的代码扩展方式,你可以参考这张表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/59/db/59bc4yyd02d4c9ff753f708bc02a87db.jpg?wh=3600x1584\" alt=\"\"><br>\n可以看出，分而治之的策略将需求变化隔离在了不同的分层之中，这样需求变化就只在一个可控的边界里，可以减少相互影响。</p><h2>重构流程</h2><p>现在我们回到一开始提出的问题，如何更高效、更高质量地完成组件内分层架构的重构？我们将组件内分层架构的重构流程按3个维度分为了7个步骤。</p><p><img src=\"https://static001.geekbang.org/resource/image/75/ae/75d88677c0284663ac8ae5fa585459ae.jpg?wh=3450x2069\" alt=\"\"></p><h3>1. 业务分析</h3><p>对于遗留系统来说，比较常见的问题就是需求的上下文中容易存在断层，所以第一步就是尽可能地了解、分析原有的业务需求。只有更清楚地挖掘原有的需求设计，才不会因为理解上的差异出现错误的代码调整。你可以参考3种常用的方式来理解需求。</p><p>第一种方式就是<strong>找人</strong>：通过与相关干系人（如与产品经理、设计人员、测试人员）沟通，对需求进行确认和答疑，这是最直接有效的方式。</p><p>但有时候你会发现如果人员流动大的话，可能相关干系人也不清楚原有的设计，这时你可以参考<strong>看文档</strong>的方法。我们可以通过查看相关的文档（如查看原有的需求文档、设计文档、测试用例、设计稿），帮助我们更好地去理解原有的需求。</p><p>当然这里也有可能存在没有文档或者文档的内容已经过时的问题，这时我们还有第三种方法——<strong>看代码</strong>。</p><p>代码肯定反映了最新的代码需求，如果有自动化测试代码，我们还可以通过测试用例的输入和输出来辅助理解需求。一般我们可以从最上层的UI页面代码看起，逐步根据代码的调用栈查看相关的逻辑。</p><p>通常来说，业务分析这一步有两个重要的场景要梳理清楚：第一个是用户正常的使用场景；第二个是用户异常的使用场景。这些场景都将是后面补充自动化验收测试的重要输入。</p><p>我们还是以前面登陆的代码为例，用户正常的使用场景应该包括：</p><ul>\n<li>输入正确的账号密码，点击登录正常验证。</li>\n<li>输入错误的账号密码，点击登录提示失败。</li>\n<li>.……</li>\n</ul><p>异常的使用场景应该包括：</p><ul>\n<li>当用户点击登录后，但因为手机出现网络异常，需要提示网络异常。</li>\n<li>当用户点击登录后，但服务器返回异常的错误时，需要提示相应的错误码。</li>\n<li>……</li>\n</ul><h3>2. 代码分析</h3><p>业务分析之后就是代码分析，通过这一步，我们一方面是要了解原有的业务，另外一方面要去诊断现有代码中有哪些优化点。</p><p>通常除了像“过大类”这种明显的问题，可能也会存在代码规范、方法复杂度、循环依赖、代码潜在漏洞等问题。我们需要尽可能将这些问题都识别出来，作为后续重构的输入。</p><p>这里我也给你推荐几个常用的类检查工具。</p><p><strong>第一个是Lint</strong>。Lint 是Android Studio 自带的代码扫描分析工具，它可以帮助我们发现代码结构或质量问题。Lint 发现的每个问题都有描述信息和等级，我们可以很方便地定位问题，同时按照严重程度来解决。</p><p><strong>第二个是Sonar</strong>。Sonar也提供了SonarLint作为IDE的插件。通过该插件可以帮助我们识别代码中的基础坏味道、代码复杂度以及潜在的缺陷等问题。</p><p>关于Lint的使用，你只需要在你的项目中选择Code-&gt;Inspect Code菜单后运行检查，就可以在Problems窗口中查看具体的问题列表了。</p><p><img src=\"https://static001.geekbang.org/resource/image/0f/yy/0ff711d0dc302c091fbb637168cff9yy.jpg?wh=3143x1771\" alt=\"\"></p><p>关于SonarLint插件，你需要先从IDE中搜索安装该插件。安装成功后右击鼠标选择菜单栏中的 “Analyze with SonarLint” 可以触发扫描。具体的问题列表你可以在SonarLint窗口中查看。</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/df/8ca9292dcfb0a66a2b162164da4yyedf.jpg?wh=3069x1771\" alt=\"\"></p><p>在这一步，我建议你至少将工具检查出来的Error级别问题也纳入重构修改，特别是一些圈复杂度高的类和方法，都可以重点记录下来，这些都是后续做重构需要重点关注的内容。</p><h3>3. 补充自动化验收测试</h3><p>经过前面的业务分析和代码分析后，我们来看第三步，这是为第一步业务分析梳理出来的用户场景补充自动化验收测试。</p><p>为什么需要先补充自动化验收测试呢？因为只有有了测试的覆盖，后面第五步在进行小步安全重构时，我们才能频繁借助这些测试来验证重构有没有破坏原有的业务逻辑，这样能更好地发现和减少因为重构修改代码而引起新的问题。</p><p>这一步通常是覆盖中大型的自动化测试，我们可以借助Espresso或Robolectric框架。例如前面那个登录的例子，我们将梳理出来的用户场景，变成自动化的验收测试用例。</p><pre><code class=\"language-plain\">public class LoginActivityTest{\n  public void should_login_sucees_when_input_correct_username_and_password(){//... ...}\n  public void should_login_failed_when_input_error_username_and_password(){//... ...}\n  public void should_show_network_error_tip_when_current_network_is_exception(){//... ...}\n  public void should_show_error_code_when_server_is_error(){//... ...}\n  //... ...\n}\n</code></pre><p>注意，这一步我们需要将前面第一步的业务分析场景全部覆盖，并且所有的用例需要执行通过。</p><h3>4. 简单设计</h3><p>补充好自动化验收测试后，接下来就是进行“简单设计”了。这一步让我们在开始动手重构前，想清楚重构后的代码将会是什么样子，以终为始才能让我们的目标更加清晰，让过程更加可度量。</p><p>我们经常听到一句半开玩笑的话，就是“代码重构以后又变成另外一个遗留系统”，其实，这很可能就是因为我们没有先进行设计，缺乏清晰的重构目标。</p><p>那么这一步怎么来做呢？我们可以根据选择的架构模式，定义出核心的类、接口和数据模型，这些关键的要素能支撑起整个架构的模式。</p><p>我们还是以登录这个例子来讲，假设我们希望重构为MVP架构，那么首先是整体的核心类的设计。</p><pre><code class=\"language-plain\">//View\npublic class LoginActivity implement LoginContract.LoginView \n\n//Presenter\npublic class LoginPresenter \n\n//Model\npublic class UserInfo \n</code></pre><p>其次是核心的交互接口。</p><pre><code class=\"language-plain\">//interface\npublic interface LoginContract {\n interface LoginView  {\n    success(UserInfo userInfo);\n    failed(String errorMessage);\n  }\n}\n</code></pre><p>我再强调一下，通过简单设计这一步，我们要定义出支持未来架构的核心的类、接口和数据模型。</p><h3>5. 小步安全重构</h3><p>接下来是小步安全重构。在重构的过程中，我们要最大限度运用<a href=\"https://time.geekbang.org/column/article/632698\">第8节课</a>介绍的安全重构手法，减少人工直接修改代码的频率，尽可能做到小步提交，并借助测试进行频繁地验证，逐步将代码修改为新设计的架构模式。这样既能提高重构的效率，通过自动化又能有效避免手工挪动代码带来的潜在错误。</p><p>在执行这个步骤中，有3个关键要点你需要特别注意。</p><p>第一个是<strong>小步</strong>，将整个重构分解为小的步骤，例如通过一次重构将业务逻辑移动到Presenter类或是将原有的View实现替换为接口回调的形式。每一次小的重构后可以通过版本管理工具进行保存，这样方便我们及时将代码进行回滚。</p><p>第二个是<strong>频繁运行测试。</strong>每当有一次小的重构完成后都需要频繁执行测试，如果这个时候测试有异常，就证明我们的重构破坏了原有的功能，需要进行排查。通过这样的反馈，我们可以在更早期发现问题并及时处理。</p><p>第三个是<strong>使用IDE的安全重构功能。</strong>使用自动化重构可以有效减少人为修改代码带来的风险，并且效率也会更高。</p><p>这一步我们需要将所有的代码按照第四步中的设计，完成所有的代码重构，并且要保证编写的自动化验收测试全部运行通过。</p><h3>6. 补充中小型测试</h3><p>当重构完成后，此时的代码可测性更高，是我们补充中小型测试的最佳时机。通过补充用例可以固化重构后的代码逻辑，避免后续代码逻辑被破坏。此外，中小型自动化测试的执行时间更快，更能提前反馈问题。</p><p>通常来说，我们在这一步要给重构后新增的类补充测试。还是以前面登录为例，重构后新增了一个LoginPresenter的类，那么我们就要对里面的login方法进行更细粒度的测试，覆盖方法内部更细的分支条件和异常条件。</p><p>就像后面代码演示的这样，我们要补充验证username、password的校验和模拟Exception的小型测试。</p><pre><code class=\"language-plain\">class LoginPresenter{\n  boolean boolean（String username，String password）{\n    if（isValid（username）|| isValid（password））{\n      return false；\n    }\n    try{\n       XXX.login(username,password);\n    }catch（NetWorkException e）\n    {\n      //... ...\n    }\n  }\n}\n</code></pre><p>这一步我们可以借助测试覆盖率工具，来检查重构后代码的核心业务逻辑是否有覆盖测试。当然这里我们不一定要求100%的覆盖率，具体要结合我们的业务和代码来进行评估。</p><h3>7. 集成验收</h3><p>最后一步集成验收，它是最后检查整个重构的结果，只有集成了才算是真的完成了重构。</p><p>这一步，不仅要保证重构后的代码独立编译调试通过，还要保证所有的自动化测试和集成验收测试也能运行通过。</p><p>通常来说，如果前面的6个步骤做到位，那么最后的集成阶段应该不会有太多的问题。这也是我们经常说的“质量内建”，虽然前面增加了投入，但能有效减少后期的返工。</p><p>在实际的过程中，我们要注意避免出现长生命周期的重构分支，否则可能会在最后集成时出现大量的代码冲突。此外，中大型的重构也应该合理拆分任务，让每一个小步的重构都能满足集成的条件。如果过程质量做得好，其实我觉得更好的方式就是直接基于主干重构，避免拉长期的重构分支。</p><h2>总结</h2><p>这节课，我通过一个“过大类”的示例为你介绍了“过大类”的典型问题、重构的策略和关键的重构流程。我们通过将重构流程按3个维度分为了7个步骤，让组件内分层架构重构的落地更加简单。</p><p>为了帮助你加深了解，我将重构的流程和关键的要点都总结到了下面这张图中。其中，分析阶段的两个步骤让我们以始为终，深入了解需求和代码现状；重构阶段的四个步骤让我们能更加安全、高效地完成代码调整；验收阶段则提醒我们，只有集成才是真正地完成了重构工作。</p><p><img src=\"https://static001.geekbang.org/resource/image/a1/56/a1574d95c467yyc50e5634cd17ba6b56.jpg?wh=1920x855\" alt=\"图片\"></p><p>“Talk is cheap, show me the code”，下节课我将通过一个具体的案例，带你一起体验一次组件分层架构重构之旅，敬请期待！</p><h2>思考题</h2><p>请问你在项目中遇到过最大的类有多少行？你是如何在这个基础上进行开发的呢？</p><p>欢迎你在留言区与我交流讨论，同时也欢迎你把这节课分享给你的同事或朋友，我们一起来高效高质量交付软件！</p>","neighbors":{"left":{"article_title":"13 | 组件运行时兼容：让组件可以灵活插拔","id":638406},"right":{"article_title":"15 | 重构实操：化整为零，落地文件模块MVP重构","id":639801}},"comments":[{"had_liked":false,"id":370397,"user_name":"Geek_a8c1a2","can_delete":false,"product_type":"c1","uid":3202596,"ip_address":"新加坡","ucode":"783E563546D7EE","user_header":"","comment_is_top":false,"comment_ctime":1678785381,"is_pvip":false,"replies":[{"id":135094,"content":"Hi，我理解你应该指的是大型的重构。大型重构也要拆解成小步集成，每个小步的重构其实也和正常的需求开发一样，我的建议是短特性分支的生命周期一般在3天左右，不超过5天。另外在开始重构前也得和业务一起沟通评估，看近期业务是否有新的需求变化，确定优先级。","user_name":"作者回复","user_name_real":"编辑","uid":1179206,"ctime":1678847996,"ip_address":"广东","comment_id":370397,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100525001,"comment_content":"重构的同时，正常的业务迭代不会停止，如果重构时间较长，如何确保这期间的需求变更？ 您也提到了避免长时间周期的重构分支，请教下 一般来说 多长的重构周期会比较合理？","like_count":1,"discussions":[{"author":{"id":1179206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/46/033fccb2.jpg","nickname":"黄俊彬","note":"","ucode":"0DBE0CE4E7CFC9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609136,"discussion_content":"Hi，我理解你应该指的是大型的重构。大型重构也要拆解成小步集成，每个小步的重构其实也和正常的需求开发一样，我的建议是短特性分支的生命周期一般在3天左右，不超过5天。另外在开始重构前也得和业务一起沟通评估，看近期业务是否有新的需求变化，确定优先级。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678847996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370321,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1678712334,"is_pvip":false,"replies":[{"id":135095,"content":"Hi，peter。\nQ1：感谢反馈，少了一个}。另外是刻意这么设计的，将内聚的接口集合到一起，Contract里面应该还得有Presenter的接口。\nQ2：有，非常多。\nQ3：国内很多研发团队都是这样，最后由测试团队负责整体验收。\nQ4:  会。\nQ5:  还是得根据自己的业务来，如果使用建议使用大厂且有持续维护的方案，例如tinker。","user_name":"作者回复","user_name_real":"编辑","uid":1179206,"ctime":1678848400,"ip_address":"广东","comment_id":370321,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100525001,"comment_content":"请教老师几个问题：\nQ1：第五步接口嵌套是笔误吗？\n第五步接口设计：public interface LoginContract { interface LoginView  {  。 两个接口是嵌套关系，为什么这样设计？是笔误少写一个右花括号吗？\nQ2：SDK中有超过一万行的类吗？我印象中好像有，也许是记错了。\nQ3：安卓集成测试是由独立于开发的测试团队负责吗？\nQ4：安卓测试，会用模拟服务端吗？\n比如，安卓团队自己开发一个模拟的服务端？\nQ5：国内用的安卓APP，老师建议用热更新吗？\n安卓APP，只在国内使用，对于更新，老师的建议是什么？支持用热更新吗？还是支持传统的更新方案？","like_count":1,"discussions":[{"author":{"id":1179206,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fe/46/033fccb2.jpg","nickname":"黄俊彬","note":"","ucode":"0DBE0CE4E7CFC9","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609137,"discussion_content":"Hi，peter。\nQ1：感谢反馈，少了一个}。另外是刻意这么设计的，将内聚的接口集合到一起，Contract里面应该还得有Presenter的接口。\nQ2：有，非常多。\nQ3：国内很多研发团队都是这样，最后由测试团队负责整体验收。\nQ4:  会。\nQ5:  还是得根据自己的业务来，如果使用建议使用大厂且有持续维护的方案，例如tinker。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678848400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}