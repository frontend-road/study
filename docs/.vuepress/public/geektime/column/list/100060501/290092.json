{"id":290092,"title":"06 | 0-1背包：动态规划的Hello World","content":"<p>你好，我是卢誉声。从今天开始，我们正式进入动态规划套路模块。</p><p>不知道你是否跟我有过相似的经历，那就是提起动态规划，最先想到的就是背包问题。事实上，背包问题分很多种，大多数人首先遇到的一般是背包中的0-1背包问题。</p><p>因此，我把这个问题称作 Hello World，这跟我们学习一门新的编程语言十分相似。它很经典，又极具代表性，能很好地展示动态规划思想，对于你掌握动态规划面试题来说，也十分有帮助。</p><p>在“初识动态规划”模块中，相信你已经对动态规划问题有了一个比较全面的认识和了解。今天，就让我们用一用前面所学的解题思路，其实就是把总结出来的套路，套用在0-1背包问题上，看看能不能解决这道题。</p><p>那在开始前呢，我还是先提出一个简单的问题，那就是：<strong>为什么将它称作0-1背包问题，0-1代表什么？</strong>你不妨带着这个小问题，来学习今天的内容。</p><h2>0-1 背包问题</h2><p>我们先来看看0-1背包问题的描述。</p><p>问题：给你一个可放总重量为 $W$ 的背包和 $N$ 个物品，对每个物品，有重量 $w$ 和价值 $v$ 两个属性，那么第 $i$ 个物品的重量为 $w[i]$，价值为 $v[i]$。现在让你用这个背包装物品，问最多能装的价值是多少？</p><!-- [[[read_end]]] --><p>示例：</p><pre><code>示例：\n\n输入：W = 5, N = 3\n     w = [3, 2, 1], v = [5, 2, 3]\n输出：8\n解释：选择 i=0 和 i=2 这两件物品装进背包。它们的总重量 4 小于 W，同时可以获得最大价值 8。\n</code></pre><h3>算法问题分析</h3><p>这个问题的描述和示例都比较简单，而且容易理解。当遇到这样一个问题时，你该从哪里下手呢？</p><p>如果你是一个动态规划老手，当然就能一眼看出这是个动态规划问题。但如果你是第一次接触，也不用担心，接下来我就带着你判断一下。</p><p>按照我之前给你说过的思路，先看问题是怎么问的：“最多能装的价值的多少？”注意这里有一个“最”字，遇到这种问题我们应该最先想到什么呢？没错，贪心算法。那么贪心算法的局部最优能解决我们的问题吗？</p><p>事实上不太能，因为如果按照贪心算法来解的话，我们很难得到整体最优解。举个简单的例子，按照示例给出的输入，如果我们先选择 $i=0$ 和 $ i=1$ 的物品，那么总重量正好是$W=5$，但这不是最优解，因为总价值才 $7$。因此，为了获得整体最优解，我们该怎么办呢？显然就是穷举。</p><p>在后续的课程中，我会与你分享更多面试实战题目。届时你就会发现，当问题复杂到一定程度后，穷举真的不是一件容易的事。因此，我们优先考虑使用动态规划来解决这个问题。那么该问题满足动态规划的特征吗？我在这列举出来，你对照看一下：</p><ol>\n<li>重叠子问题：对于0-1背包问题来说，即便我们不画出求解树，也能很容易看出在穷举的过程中存在重复计算的问题。这是因为各种排列组合间肯定存在重叠子问题的情况；</li>\n<li>无后效性：当我们选定了一个物品后，它的重量与价值就随即确定了，后续选择的物品不会对当前这个选择产生副作用。因此，该问题无后效性；</li>\n<li>最优子结构：当我们选定了一个物品后，继续做决策时，我们是可以使用之前计算的重量和价值的，也就是说后续的计算可以通过前面的状态推导出来。因此，该问题存在最优子结构。</li>\n</ol><h3>写出状态转移方程</h3><p>现在，我们确定了这是一个动态规划问题。接下来，让我们一起看看如何写出动态规划算法的核心，即状态转移方程。还记得之前总结的动态规划求解框架（或者说套路）吗？</p><p>首先，我们先来确定初始化状态。任何穷举算法（包括递归在内）都需要一个终止条件，这个所谓的终止条件，就是我们在动态规划解法当中的最初子问题，因此我们将其称作<strong>初始化状态</strong>。</p><p>在0-1背包中，这个终止条件是什么呢？显然，当背包的容量为 0 或者物品的数量为 0 时要终止执行。如果体现在代码上，就是当物品总数为 0 时重量为 0；而重量为 0 时显然物品数量也为 0。</p><p>接着，在什么情况下，会导致计算过程中不断逼近上面提到的初始化状态呢？其实题目中已经给出了答案。我们从背包的角度看待这个问题，将物品放入背包时：</p><ol>\n<li>背包内物品的数量 $N$ 在增加，它是一个变量；</li>\n<li>同时，背包还能装下的重量 $W$ 在减少，它也是一个变量。</li>\n</ol><p>因此，当前背包内的物品数量 $N$ 和背包还能装下的重量 $W$ 就是这个动态规划问题的<strong>状态参数</strong>。</p><p>然后，我们再来看如何进行<strong>决策</strong>。在0-1背包问题中，我们的决策无非就是该不该把当前这个物品放入背包中：如果将该物品放入背包，子问题的答案是多少；如果没有放入，子问题的答案又是多少。</p><p>我们曾说过，通常情况下，状态转移方程的参数就是状态转移过程中的变量，即状态参数。而函数的返回值就是答案，在这里就是最大价值。因此，我们从上面两种决策情况中取最优解，即 max (放入该物品, 不放入该物品)。</p><p>在确定了初始化状态、状态参数和决策后，我们就可以开始尝试写状态转移方程了。由于这是我们第一次正式面对动归问题，我会先把递归形式的状态转移过程描述出来，代码如下：</p><pre><code>/* \n * tn: traversed n，即已经遍历过的物品；\n * rw: reserved w，即背包还能容量的重量。\n */\nDP(int tn, int rw) {\n  // 当遍历完所有物品时，就该返回 0 了，因为没有物品也就没有价值了\n  if tn &lt; 0\n    return 0\n  \n  // 当背包还能容纳的重量已经小于当前物品的重量时，显然这个物品不能放入背包\n  if rw &lt; w[tn]\n    return DP(tn - 1, rw)\n  \n  // 作出决策，该不该放入物品：\n  //   1. 放入：那么价值是 DP(tn - 1, rw - w[tn])；\n  //   2. 不放入：那么价值是 DP(tn - 1, rw)。\n  return max(DP(tn - 1, rw), DP(tn - 1, rw - w[tn]) + v[tn])\n}\n</code></pre><p>顺着这个思路，我把状态转移方程给写出来，它是这样的：</p><p>$$DP(tn, rw)=\\left\\{\\begin{array}{c}<br>\n0, tn&lt;=0\\\\\\<br>\n0, rw&lt;=0\\\\\\<br>\nDP(tn-1,rw), rw&lt;w[tn]\\\\\\<br>\nmax(DP(tn-1,rw), DP(tn-1,rw-w[tn])+v[tn])),rw&gt;=w[tn]<br>\n\\end{array}\\right.$$</p><p>现在，我们有了针对0-1背包问题的完整状态转移方程，可以开始编写代码了。</p><h3>编写代码进行求解</h3><p>但在编写代码前，还有一个小问题需要解决，就是我们需要为动态规划代码准备一个备忘录，来存储计算过的子问题答案。那么这个备忘录的数据结构应该是什么样的呢？</p><p>从前面的分析可以看出，状态转移方程中有两个状态参数，并通过这两个状态参数确定了一个子问题的答案。因此，我们可以使用一个二维数组作为备忘录。</p><p>为了通用起见，我将其命名为$DP[tn][rw]$，其中行代表的是 $tn$，表示第几个物品；列代表的是$rw$，表示背包还能容纳的重量。这个索引组合（比如$DP[2][3]$）对应位置的值，就是这个子问题的答案，表示当背包还能容纳 3 的重量时，放入前 2 件物品的最大价值。</p><p>所有先决条件都解决了，现在来看一下如何用标准的动归解法来求解此问题，我直接给出代码。</p><p>Java 实现：</p><pre><code>int dp(int[] w, int[] v, int N, int W) {\n    // 创建备忘录\n    int[][] dp = new int[N+1][W+1];\n  \n    // 初始化状态\n    for (int i = 0; i &lt; N + 1; i++) { dp[i][0] = 0; }\n    for (int j = 0; j &lt; W + 1; j++) { dp[0][j] = 0; }\n  \n    for (int tn = 1; tn &lt; N + 1; tn++) { // 遍历每一件物品\n\t\tfor (int rw = 1; rw &lt; W + 1; rw++) { // 背包容量有多大就还要计算多少次\n    \t\tif (rw &lt; w[tn]) {\n    \t\t\t// 当背包容量小于第tn件物品重量时，只能放入前tn-1件\n    \t\t\tdp[tn][rw] = dp[tn-1][rw];\n    \t\t} else {\n                // 当背包容量还大于第tn件物品重量时，进一步作出决策\n    \t\t\tdp[tn][rw] = Math.max(dp[tn-1][rw], dp[tn-1][rw-w[tn]] + v[tn]);\n    \t\t}\n    \t}\n    }\n  \n  return dp[N][W];\n}\n\nint solveDP() {\n  int N = 3, W = 5; // 物品的总数，背包能容纳的总重量\n  int[] w = {0, 3, 2, 1}; // 物品的重量\n  int[] v = {0, 5, 2, 3}; // 物品的价值\n  \n  return dp(w, v, N, W); // 输出答案\n}\n</code></pre><p>C++ 实现：</p><pre><code>int DP(const std::vector&lt;int&gt;&amp; w, const std::vector&lt;int&gt;&amp; v, int N, int W) {\n  int dp[N+1][W+1]; memset(dp, 0, sizeof(dp)); // 创建备忘录\n  \n  // 初始化状态\n  for (int i = 0; i &lt; N + 1; i++) { dp[i][0] = 0; }\n  for (int j = 0; j &lt; W + 1; j++) { dp[0][j] = 0; }\n  \n  for (int tn = 1; tn &lt; N + 1; tn++) { // 遍历每一件物品\n    for (int rw = 1; rw &lt; W + 1; rw++) { // 背包容量有多大就还要计算多少次\n      if (rw &lt; w[tn]) {\n        // 当背包容量小于第tn件物品重量时，只能放入前tn-1件\n        dp[tn][rw] = dp[tn-1][rw];\n      } else {\n        // 当背包容量还大于第tn件物品重量时，进一步作出决策\n        dp[tn][rw] = max(dp[tn-1][rw], dp[tn-1][rw-w[tn]] + v[tn]);\n      }\n    }\n  }\n  \n  return dp[N][W];\n}\n\nint DPSol() {\n  int N = 3, W = 5; // 物品的总数，背包能容纳的总重量\n  std::vector&lt;int&gt; w = {0, 3, 2, 1}; // 物品的重量\n  std::vector&lt;int&gt; v = {0, 5, 2, 3}; // 物品的价值\n  \n  return DP(w, v, N, W); // 输出答案\n}\n</code></pre><p>我们几乎照搬了状态转移方程描述的内容到代码里，因此这段代码通俗易懂。</p><p>首先，我们定义了两个数组，其中 $w$ 用来表示物品的重量，而 $v$ 用来表示物品的价值。这里需要注意的是，每个数组的第 0 项都是 0。由于小于 0 的值对应的都应该是 0，因此我们可以通过这个方法来省去冗余的 if 判断逻辑。</p><p>我们已经定义了备忘录即 $DP[tn][rw]$ 数组的含义：当背包还能装 $rw$ 重量的物品，放入了前 $tn$ 件物品时的最大价值。接下来，我们再依据状态转移方程的定义来<strong>初始化状态</strong>：</p><ol>\n<li>创建一个大小为 N+1 / W+1 的二维数组，并将所有位置初始化为0；</li>\n<li>初始化状态，即前面提到的穷举的终止条件，把所有的 $dp[0][i]$ 和 $dp[j][0]$ 全部都设置为 0。</li>\n</ol><p>接着，进入编写函数主体循环的阶段，让我们看看每一次循环中是如何做<strong>决策</strong>的：</p><ol>\n<li>主循环分为两层，第 1 层遍历所有物品，也就是尝试放入每个物品；第 2 层遍历背包容量，也就是假定当前背包容量是 $rw$ 的时候，求在背包容量为$rw$时，放入当前物品的最大价值；</li>\n<li>如果背包容量小于当前物品价值，那么这个时候最大价值也就是当前容量不变，使用上一个物品的最大价值即可；</li>\n<li>如果背包容量大于当前物品价值，那么这个时候最大价值也就是从以下两个决策中挑选：</li>\n</ol><blockquote>\n<p>a. 放入这个物品前的最大价值 + 当前物品价值和作为答案；<br>\nb. 不放入这个物品时，当前容量的最大价值作为答案。</p>\n</blockquote><p>我在下面的表格中，用箭头画出了容量为 5 时的求解路径。你可以参照这个求解路径来加深对代码的理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/af/d0/afbe718a68b8a1f89c42c259a75ca7d0.png?wh=1374*390\" alt=\"\"></p><p>在面试过程中，如果能养成对编写代码重审的习惯，也是可以加分的。因此，在我们实现完决策逻辑后，再对代码做些基本的检查，就可以“交卷”了。</p><h2>0-1 背包问题的延伸</h2><p>事实上，由于0-1背包问题过于经典，在真正的算法面试环节，如果涉及动态规划问题时，基本不会让你直接解决这个问题，而是让你解决这个问题的变种。</p><p>因此，我们有必要对0-1背包问题做一个延伸，来看看如何把一个看似陌生的动态规划问题转化成0-1背包问题来进行求解。</p><h3>算法问题分析</h3><p>我们先来看看问题的描述。</p><p>问题：有一堆石头，每块石头的重量都是正整数。每次从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 $x$ 和 $y$，且 $x ≤ y$。那么粉碎的可能结果如下：</p><ol>\n<li>如果 $x$ 与 $y$ 相等，那么两块石头都会被完全粉碎；</li>\n<li>否则，重量为 $x$ 的石头将会完全粉碎，而重量为 $y$ 的石头的新重量为 $y - x$。</li>\n</ol><p>最后，最多只会剩下一块石头。返回此时石头最小的可能重量。如果没有石头剩下，就返回 0。</p><p>示例：</p><pre><code>示例：\n\n输入：[1, 2, 1, 7, 9, 4]\n输出：\n解释：Round 1: (2, 4) -&gt; 2, 数组变成 [1, 1, 7, 9, 2]\n     Round 2: (7, 9) -&gt; 2, 数组变成 [1, 1, 2, 2]\n     Round 3: (2, 2) -&gt; 0, 数组变成 [1, 1]\n     Round 4: (1, 1) -&gt; 0, 数组为空，返回 0\n</code></pre><p>如果你是第一次遇见这个问题，那么你很可能跟绝大多数人（包括我在内）一样一脸茫然，一上来就没有什么思路。这其实很正常，事实上动态规划的面试题有规可循，总共就那么几种，见过了，以后就知道了。</p><p>我们先来读一下题目，最后的问题中包含了“最”字，这时你就应该小心了。同时，这个题目显然需要通过排列组合的方式从所有可能组合中找到最优解，因此会涉及穷举，如果涉及穷举，就很有可能涉及重叠子问题。</p><p>我刚才在0-1背包中使用了一个模版化的分析方法，我建议你在这里对此问题进行类似的分析。分析后你就会发现，这应该是一个动态规划问题。</p><h3>转化成动态规划问题</h3><p>现在，我们就来讲一下到底如何将其转化为动态规划问题。</p><p>首先，请你观察一下上面提供的示例。在示例中，第一步组合 2 和 4，求出 (4 - 2) = 2；第二步组合 7 和 9，求出 (9 - 7) = 2；第三步组合 2 和 2，求出 (2 - 2) = 0；最后第四步组合 1 和 1，同样得 0。我们把这个过程组合成一个式子，它看起来是这样的：</p><p>$$1-(1-((4-2)-(9-7)))$$</p><p>如果解开这些括号，就可以得到 1 - 4 + 2 + 9 - 7 - 1。再做一下简单的变换，就可以得到如下式子：</p><p>$$1 + 2 + 9 - 1 - 4 - 7$$</p><p>这个时候，我们可以把这个公式分成两组，一组是从数组中挑选出几个数字相加；然后，将另外几个数字相减，求两个数字的差。最后确保这个差最小。</p><p>从直觉上来说，如何确保两组数字之差最小呢？</p><p>我们可以看到如果一组数字接近所有数字之和的 1/2，那么两组数字之差肯定越小，比如上面的示例中所有数字之和是 24，所以一组数字是 12，另一组数字也是 12，最后肯定能得到最小值0。</p><p>现在，假设有一个背包，背包的容量是 12（24/2）。接着，我们有一堆的物品，重量分别是 [1, 2, 1, 7, 9, 4]，注意我们设它的价值与重量相同。现在我们希望选出的物品放到背包里的价值最大，这样一来，我们就可以把这个题目转化成0-1背包问题了。</p><h3>写出状态转移方程</h3><p>那么，动态规划部分的状态转移方程就和0-1背包问题中的一样，如下所示：</p><p>$$DP(tn, rw)=\\left\\{\\begin{array}{c}<br>\n0, tn&lt;=0\\\\\\<br>\n0, rw&lt;=0\\\\\\<br>\nDP(tn-1,rw), rw&lt;w[tn]\\\\\\<br>\nmax=(DP(tn-1,rw), DP(tn-1,rw-w[tn])+v[tn])),rw&gt;=w[tn]<br>\n\\end{array}\\right.$$</p><p>看到了吧！我们巧妙地把这个看似让人蒙圈的问题成功转化成了一个标准的0-1背包问题，而且能够直接复用我们所学的内容。</p><p>万事俱备后就是编写代码，由于状态转移方程与0-1背包问题如出一辙，因此我们这里就省略编码这一环节了。</p><h2>通用的动态规划</h2><p>在上一个模块“初识动态规划”中，我们曾经介绍了一种经过经验总结的动态规划解题框架（或者说是套路）。其实当时，我并未给出比较严格的框架，作为补充完善动态规划理论的重要一环，我们很有必要学习、掌握通用的动态规划的框架。</p><p>我们已经知道，一个动态规划问题是指它可以从大问题中找到无后效性的重叠子问题。所谓无后效行是指，其子问题不会双向依赖，只会单向依赖。否则，我们就无法确保子问题处理后，更大的问题一定能取到子问题的解。</p><p>现在，我们准备对动态规划问题进行泛化统一建模，如果用数学语言描述就如下公式所示：</p><p>$$f(x)=\\left\\{\\begin{array}{c}<br>\nd(x), x \\in V_{I}\\\\\\<br>\ng(\\{v(f(s(x,c)),c)\\}),c \\in values(x)<br>\n\\end{array}\\right.$$</p><p>我们该怎么理解这个公式呢？首先，我们需要考虑一些边界情况，如果输入向量 $x$，那么在边界组合 $V_{I}$ 中，用一个边界函数 $d(x)$ 直接返回 $f(x)$ 的值，就不需要再划分子问题了。比如在0-1背包问题中，当 $tn$ 或 $rw$ 小于等于 0 时，这个值就是 0。</p><p>否则，说明这是一个可以划分子问题的问题，那么我们就需要从可选组合 $values$ 中取出用于划分子问题的备选值。需要牢记的是，在复杂问题中这个 $values$ 可能不是一个一成不变的组合，它会随着当前状态 $x$ 变化而变化。</p><p>接着，我们对每一个备选值 $c$（与上面的 $x$ 类似，同样可能是一个向量），通过函数 $s(x, c)$ 求得当前备选值的子问题的 $x$, $c$。然后，通过 $f(s(x, c))$ 得到这个子问题的结果。</p><p>再接着，我们通过子问题 $v(f(s(x, c)), c)$ 的结果和当前备选值 $c$，来求得当前问题的解。因为我们有一系列的备选值 $c$，因此会得到一个当前问题的求解集合。</p><p>最后，我们通过最优化函数 $g(t)$ 进行求解。比如原问题是求最小值，那么 $g(t)$ 就是 $min(t)$；如果是求最大值，那么就是 $max(t)$。这两种是最为常见的函数，我们在前面的例题当中也都见过了。</p><p>这样一来，我们就可以把所有的问题都套入这个框架，写出对应的状态转移方程了。</p><h2>课程总结</h2><p>现在让我们回到这节课开头提出的那个问题，那就是0-1背包问题中的 0 和 1 代表的到底是什么呢？</p><p>其实，你可以看到在整个算法计算过程中，每次我们只能做两种选择：</p><ol>\n<li>放入当前物品；</li>\n<li>不放入当前物品。</li>\n</ol><p>如果我们对这个问题稍作修改：每个物品有一定的数量（注意不止一个），同时还允许在背包中反复放入多个相同的物品，那么这个问题就变成了每个物品应该放几个。</p><p>我们可以看到0-1背包就是这种问题的一个子集，相当于每个物品都只有 1 个的背包问题！如果从放入数量的角度来看，放入当前物品就相当于当前的物品放入了 1 个，不放入当前物品就相当于放入了 0 个。</p><p>所以，这就是为什么这个背包问题被称为0-1背包的根本原因。</p><p>充分理解0-1背包的解题思路，对全面掌握背包问题来说至关重要。我会在下一节课为你讲解泛化的背包问题，并给出衍生的面试问题讨论，帮助你攻破背包问题难关。</p><h2>课后思考</h2><p>在这节课中，我们介绍了0-1背包问题的延伸，提出了一个“粉碎石头”的问题。现在，请你按照求解0-1背包问题的思路，全面分析一下这个问题，然后写出求解的代码。</p><p>不知道你今天的收获如何呢？如果感觉已经掌握了解题思路，不妨也去考考你们的同事或者朋友吧，刚好也有机会复述一遍今天所学。</p>","neighbors":{"left":{"article_title":"05｜面试即正义第一期：什么样的问题应该使用动态规划？","id":289310},"right":{"article_title":"07｜完全背包：深入理解背包问题","id":291638}},"comments":[{"had_liked":false,"id":250289,"user_name":"浅语清风","can_delete":false,"product_type":"c1","uid":1627685,"ip_address":"","ucode":"178639FA449D31","user_header":"https://static001.geekbang.org/account/avatar/00/18/d6/25/a2b77f1d.jpg","comment_is_top":false,"comment_ctime":1601013682,"is_pvip":false,"replies":[{"id":"91900","content":"我们一起加油！有任何相关问题，都欢迎留言讨论。我也会尽我所能帮你解答。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1601529484,"ip_address":"","comment_id":250289,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40255719346","product_id":100060501,"comment_content":"课程难度越来越大了，对于对于初学者来说看一遍是根本不够的，要反复学习，不断积累，编程实践。我一定要攻克动态规划的难关！","like_count":9,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506177,"discussion_content":"我们一起加油！有任何相关问题，都欢迎留言讨论。我也会尽我所能帮你解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601529484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259413,"user_name":"冬风向左吹","can_delete":false,"product_type":"c1","uid":1066928,"ip_address":"","ucode":"376C45C5134F93","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","comment_is_top":false,"comment_ctime":1604720185,"is_pvip":false,"replies":[{"id":"95672","content":"并不是这样，因为 dp[tn][rw]是背包在处理第tn个物品后背包剩余rw容量的最优解，那么如果我们没有把第tn件物品放进去，那么肯定就是dp[tn-1][rw]。当时如果我们要把第tn件物品放进去，那么放进去背包之后容量就只剩下了rw-w[tn]，所以需要取得就是dp[tn-1][rw-w[tn]]（也就是在容量只剩下rw-w[tn]得情况下，处理第tn-1个物品时最优是多少）。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1606230963,"ip_address":"","comment_id":259413,"utype":1}],"discussion_count":4,"race_medal":0,"score":"10194654777","product_id":100060501,"comment_content":"没太理解这里：dp[tn-1][rw-w[tn]] + v[tn]。放入物品前的价值+放入特别的价值。为什么放入特别前的价值 rw-w[tn]，这里要减w[tn]呢。放入物品前的价值不就是dp[tn-1][rw]吗？","like_count":2,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508934,"discussion_content":"并不是这样，因为 dp[tn][rw]是背包在处理第tn个物品后背包剩余rw容量的最优解，那么如果我们没有把第tn件物品放进去，那么肯定就是dp[tn-1][rw]。当时如果我们要把第tn件物品放进去，那么放进去背包之后容量就只剩下了rw-w[tn]，所以需要取得就是dp[tn-1][rw-w[tn]]（也就是在容量只剩下rw-w[tn]得情况下，处理第tn-1个物品时最优是多少）。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606230963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2481167,"avatar":"https://static001.geekbang.org/account/avatar/00/25/dc/0f/4d38b101.jpg","nickname":"格局","note":"","ucode":"EDF3736A1FAA8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550308,"discussion_content":"dp[tn][rw]是表示： 放入tn个物品后，剩余空间为rw时的最大价值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644479826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2192802,"avatar":"https://static001.geekbang.org/account/avatar/00/21/75/a2/9f2b966b.jpg","nickname":"林潭","note":"","ucode":"9CC449D8F347A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324164,"discussion_content":"决策是否放入，不放入就是dp[tn-1][rw],放入之后还能容纳的重量就要减去w[tn],再加上当前物品的价值v[tn],即dp[tn-1][rw-w[tn]] + v[tn]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605063645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1066928,"avatar":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","nickname":"冬风向左吹","note":"","ucode":"376C45C5134F93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2192802,"avatar":"https://static001.geekbang.org/account/avatar/00/21/75/a2/9f2b966b.jpg","nickname":"林潭","note":"","ucode":"9CC449D8F347A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326031,"discussion_content":"棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605502629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324164,"ip_address":""},"score":326031,"extra":""}]}]},{"had_liked":false,"id":254260,"user_name":"Roy Liang","can_delete":false,"product_type":"c1","uid":1098898,"ip_address":"","ucode":"1DF5FC831A35DA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c4/92/338b5609.jpg","comment_is_top":false,"comment_ctime":1603092685,"is_pvip":false,"replies":[{"id":"93414","content":"赞，没问题。顶上去！","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1603700810,"ip_address":"","comment_id":254260,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10193027277","product_id":100060501,"comment_content":"#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;cmath&gt;<br>#include &lt;cstring&gt;<br><br>using namespace std;<br><br>int DP(const std::vector&lt;int&gt;&amp; w, const std::vector&lt;int&gt;&amp; v, int N, int W) {<br>  int dp[N+1][W+1];<br>  memset(dp, 0, sizeof(dp)); &#47;&#47; 创建备忘录<br><br>  for (int tn = 1; tn &lt; N + 1; tn++) { &#47;&#47; 遍历每一件物品<br>    for (int rw = 1; rw &lt; W + 1; rw++) { &#47;&#47; 背包容量有多大就还要计算多少次<br>      if (rw &lt; w[tn]) {<br>        &#47;&#47; 当背包容量小于第tn件物品重量时，只能放入前tn-1件<br>        dp[tn][rw] = dp[tn-1][rw];<br>      } else {<br>        &#47;&#47; 当背包容量还大于第tn件物品重量时，进一步作出决策<br>        dp[tn][rw] = max(dp[tn-1][rw], dp[tn-1][rw-w[tn]] + v[tn]);<br>      }<br>    }<br>  }<br><br>  return dp[N][W];<br>}<br><br>int main() {<br>  int N, i, sum = 0, t, part1, part2;<br>  vector&lt;int&gt; w, v;<br>  w.push_back(0);<br>  v.push_back(0);<br><br>  cin &gt;&gt; N;<br>  for (i = 1; i &lt;= N; i++) {<br>    cin &gt;&gt; t;<br>    sum += t;<br>    w.push_back(t);<br>    v.push_back(t);<br>  }<br>  part1 = DP(w, v, N, sum &#47; 2);<br>  part2 = sum - part1;<br>  cout &lt;&lt; abs(part1 - part2) &lt;&lt; endl;<br>}","like_count":2,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507339,"discussion_content":"赞，没问题。顶上去！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603700810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282722,"user_name":"BBQ","can_delete":false,"product_type":"c1","uid":1656804,"ip_address":"","ucode":"683BBF7F7AE370","user_header":"https://static001.geekbang.org/account/avatar/00/19/47/e4/17cb3df1.jpg","comment_is_top":false,"comment_ctime":1615376782,"is_pvip":false,"replies":[{"id":"102843","content":"恩，这样处理没有问题。顶上去，让大家看到。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1615801547,"ip_address":"","comment_id":282722,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5910344078","product_id":100060501,"comment_content":"感谢老师的细心讲解，怎么感觉越写越简单了呢。 😀<br>把空间复杂度优化了一下，用一个一维数组，倒着走，就不会产生重复计算了。<br><br>    def lastStoneWeightII(self, stones: List[int]) -&gt; int:<br>        total = sum(stones)<br>        size = (total)&#47;&#47;2+1 #这个要注意，如果容量要达到size，大小要是size + 1<br><br>        dp = [0] * size<br><br>        for i in range(len(stones)):<br>            j = size - 1<br>            while j &gt;= stones[i]:<br>                dp[j] = max(dp[j], dp[j-stones[i]] + stones[i])<br>                j-= 1<br>        return total - dp[-1] - dp[-1]","like_count":2,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516820,"discussion_content":"恩，这样处理没有问题。顶上去，让大家看到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615801547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274628,"user_name":"樟树林","can_delete":false,"product_type":"c1","uid":1891807,"ip_address":"","ucode":"17185F3F05AD7D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/dd/df/9ad77647.jpg","comment_is_top":false,"comment_ctime":1611105888,"is_pvip":false,"replies":[{"id":"101324","content":"这个背包内可以容纳的物品只取决于背包的容量和物品的重量，示例数据里背包容量为2的情况下，最优解肯定是3，因为永远只能装下一个物品，这个是不是对问题的理解有什么偏差。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1613370329,"ip_address":"","comment_id":274628,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5906073184","product_id":100060501,"comment_content":"老师，关于背包问题哈，背包容量为2，物品个数为3的背包，按照你上述计算得出的结果是3，但实际结果应为6。这个问题，老师能解释一下吗？","like_count":1,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514074,"discussion_content":"这个背包内可以容纳的物品只取决于背包的容量和物品的重量，示例数据里背包容量为2的情况下，最优解肯定是3，因为永远只能装下一个物品，这个是不是对问题的理解有什么偏差。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613370329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1891807,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/dd/df/9ad77647.jpg","nickname":"樟树林","note":"","ucode":"17185F3F05AD7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344003,"discussion_content":"老师，我觉得这个代码还是有问题。按照上面的代码求解容量为1，个数为1的背包，得出的解是0，这还是不对呀，因为实际是3，老师，这个能解释一下吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611230653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1891807,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/dd/df/9ad77647.jpg","nickname":"樟树林","note":"","ucode":"17185F3F05AD7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343831,"discussion_content":"我懂了，原来每个物品只有一个啊，我还以为是无数个呢！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611192874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2220763,"avatar":"https://static001.geekbang.org/account/avatar/00/21/e2/db/97c6f756.jpg","nickname":"_patrick","note":"","ucode":"B24C6EEBCABB94","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1891807,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/dd/df/9ad77647.jpg","nickname":"樟树林","note":"","ucode":"17185F3F05AD7D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579168,"discussion_content":"0 1背包 就是 一个物品就两种状态，放入 或者 不放入。 就是每个物品就一个，即便相同物品 也得占一个 w[i] v[i]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657213421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343831,"ip_address":""},"score":579168,"extra":""}]}]},{"had_liked":false,"id":343107,"user_name":"L.M.","can_delete":false,"product_type":"c1","uid":1570250,"ip_address":"","ucode":"FA699EC1974154","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/ca/2ff82405.jpg","comment_is_top":false,"comment_ctime":1650630035,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650630035","product_id":100060501,"comment_content":"11数组会溢出吧","like_count":0},{"had_liked":false,"id":341085,"user_name":"小灰","can_delete":false,"product_type":"c1","uid":1130729,"ip_address":"","ucode":"1AB4E3AEDEE7FC","user_header":"https://static001.geekbang.org/account/avatar/00/11/40/e9/29dfa621.jpg","comment_is_top":false,"comment_ctime":1649339217,"is_pvip":true,"replies":[{"id":"126437","content":"这段C#代码没有问题。赞。","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1653378934,"ip_address":"","comment_id":341085,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649339217","product_id":100060501,"comment_content":"       根据老师的代码，我用了 C#实现，请老师赐教，代码如下:  <br>       &#47;&#47;&#47; &lt;summary&gt;<br>        &#47;&#47;&#47; 0-1 背包问题（针对当前物品，是放入背包，还是不放入背包时的价值最大）<br>        &#47;&#47;&#47; &lt;&#47;summary&gt;<br>        &#47;&#47;&#47; &lt;returns&gt;&lt;&#47;returns&gt;<br>        public int KnapsackDP(int[] wtItems, int[] valItems, int total, int maxWeight)<br>        {<br>            &#47;&#47; 创建备忘录<br>            int[,] dpItems = new int[total + 1, maxWeight + 1];<br>            &#47;&#47; 初始化状态<br>            &#47;&#47;for (int i = 0; i &lt; N + 1; i++) { dpItems[i,0] = 0; }<br>            &#47;&#47;for (int j = 0; j &lt; W + 1; j++) { dpItems[0,j] = 0; }<br><br>            for (int tn = 1; tn &lt; total + 1; tn++)  &#47;&#47; 遍历每一件物品<br>            {<br><br>                for (int rw = 1; rw &lt; maxWeight + 1; rw++)   &#47;&#47; 背包容量有多大就还要计算多少次<br>                {<br><br>                    if (rw &lt; wtItems[tn])  &#47;&#47; 当背包容量小于第 tn 件物品重量时，只能放入前tn-1件<br>                    {<br><br>                        dpItems[tn, rw] = dpItems[tn - 1, rw];<br>                    }<br>                    else<br>                    {<br>                        &#47;&#47; 当背包容量还大于第tn件物品重量时，进一步作出决策<br>                        dpItems[tn, rw] = Math.Max(dpItems[tn - 1, rw], dpItems[tn - 1, rw - wtItems[tn]] + valItems[tn]);<br>                    }<br>                }<br>            }<br><br>            return dpItems[total, maxWeight];<br>        }<br><br><br>        [TestCaseSource(&quot;KnapsackSource&quot;)]<br>        public void KnapsackDPTest(int[] wtItems, int[] valItems, int total, int maxWeight, int expectedMaxVal)<br>        {<br>            var maxVal = KnapsackDP(wtItems, valItems, total, maxWeight); &#47;&#47; 输出答案<br>            Console.WriteLine($&quot;KnapsackDPTest,maxVal:{maxVal},expectedMaxVal:{expectedMaxVal}&quot;);<br>            Assert.AreEqual(expectedMaxVal, maxVal);<br>        }<br>        public static IEnumerable KnapsackSource()<br>        {<br>            yield return new TestCaseData(new int[] { 0, 3, 2, 1 }, new int[] { 0, 5, 2, 3 }, 3, 5, 8);<br>        }","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573361,"discussion_content":"这段C#代码没有问题。赞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653378934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332471,"user_name":"alex_lai","can_delete":false,"product_type":"c1","uid":1903459,"ip_address":"","ucode":"3057F2A593A6DB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/m7fLWyJrnwEPoIefiaxusQRh6D1Nq7PCXA8RiaxkmzdNEmFARr5q8L4qouKNaziceXia92an8hzYa5MLic6N6cNMEoQ/132","comment_is_top":false,"comment_ctime":1643268401,"is_pvip":true,"replies":[{"id":"126440","content":"这里n的确指的是处理第n个物品后的最优解，的确不是选了几个item。只不过你调整物品的顺序肯定也不影响这个最优解而已。","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1653378975,"ip_address":"","comment_id":332471,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1643268401","product_id":100060501,"comment_content":"dp[n,w]中的n 不是表示第几个item在还剩w空间的情况下的最优解 而是总共可以选n个item在w空间里的最优解吧？！ 我的意思n的值跟顺序无关，比如dp[1, 10] 就是选一个item给10的空间 最优是多少","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573365,"discussion_content":"这里n的确指的是处理第n个物品后的最优解，的确不是选了几个item。只不过你调整物品的顺序肯定也不影响这个最优解而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653378975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327351,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1059952,"ip_address":"","ucode":"F70511D614B9F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/70/02b627a6.jpg","comment_is_top":false,"comment_ctime":1640077365,"is_pvip":false,"replies":[{"id":"126444","content":"这样是可以的。赞，让大家看到。","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1653379017,"ip_address":"","comment_id":327351,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640077365","product_id":100060501,"comment_content":"关于粉碎石头（力扣上的题：1049. 最后一块石头的重量 II）的问题的思考：<br><br>1. 可以把石头分为两堆，这两堆的重量尽量均衡，才能产生最小的差值<br>2. 那么就相当于把所有石头的总重量除以2，作为背包的容量，然后看最大能装入多少重量的石头<br>3. 从而转化成背包问题<br>","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573369,"discussion_content":"这样是可以的。赞，让大家看到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653379017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":327328,"user_name":"coder","can_delete":false,"product_type":"c1","uid":1059952,"ip_address":"","ucode":"F70511D614B9F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/70/02b627a6.jpg","comment_is_top":false,"comment_ctime":1640067279,"is_pvip":false,"replies":[{"id":"126445","content":"是的，应该是背包容量小于当前物品重量或者体积","user_name":"作者回复","user_name_real":"编辑","uid":"1006976","ctime":1653379025,"ip_address":"","comment_id":327328,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1640067279","product_id":100060501,"comment_content":"背包基本问题，做决策部分：“如果背包容量小于当前物品价值”<br><br>应该是“小于当前物品重量”或者“小于当前物品体积”吧？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573370,"discussion_content":"是的，应该是背包容量小于当前物品重量或者体积","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653379025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309569,"user_name":"放飞风筝","can_delete":false,"product_type":"c1","uid":2744611,"ip_address":"","ucode":"B73C9C96B8E029","user_header":"https://static001.geekbang.org/account/avatar/00/29/e1/23/717c4449.jpg","comment_is_top":false,"comment_ctime":1630236698,"is_pvip":false,"replies":[{"id":"113500","content":"没错，先弄清楚状态，再把状态带入转移方程，就完成了一半工作。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1632407757,"ip_address":"","comment_id":309569,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630236698","product_id":100060501,"comment_content":"主要抓住状态参数（构建备忘录）和转移方程","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525918,"discussion_content":"没错，先弄清楚状态，再把状态带入转移方程，就完成了一半工作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632407757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":301130,"user_name":"Alvin","can_delete":false,"product_type":"c1","uid":1284900,"ip_address":"","ucode":"8CF85DA34B3CEC","user_header":"https://static001.geekbang.org/account/avatar/00/13/9b/24/a131714e.jpg","comment_is_top":false,"comment_ctime":1625547364,"is_pvip":false,"replies":[{"id":"112094","content":"其实我们的确会先思考解决方案中的参数，只不过讨论的时候会先讨论这些参数的初始值。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1630215746,"ip_address":"","comment_id":301130,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1625547364","product_id":100060501,"comment_content":"看到这里一直觉得这个思路很奇怪，为什么是先初始化状态参数，再确定状态参数。不先确定状态参数，怎么初始化？每次看老师的思路说先初始化xxx，感觉其实就已经确定了xxx是状态参数。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522904,"discussion_content":"其实我们的确会先思考解决方案中的参数，只不过讨论的时候会先讨论这些参数的初始值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630215746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292492,"user_name":"3.141516","can_delete":false,"product_type":"c1","uid":1013309,"ip_address":"","ucode":"34AF71B02692F3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/3d/8120438b.jpg","comment_is_top":false,"comment_ctime":1620840156,"is_pvip":true,"replies":[{"id":"108596","content":"恩，但是程序就需要精确的描述，同时屏蔽实现的细节，因此我们必须要使用这种精确的方程来描述问题。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1624693494,"ip_address":"","comment_id":292492,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1620840156","product_id":100060501,"comment_content":"这个数学方程很数学、很简洁，但是看着头疼......不如文字好理解","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519851,"discussion_content":"恩，但是程序就需要精确的描述，同时屏蔽实现的细节，因此我们必须要使用这种精确的方程来描述问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624693494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288485,"user_name":"pearl刘东洋","can_delete":false,"product_type":"c1","uid":2027794,"ip_address":"","ucode":"EB50A5726285C5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f1/12/c40d07bc.jpg","comment_is_top":false,"comment_ctime":1618489265,"is_pvip":true,"replies":[{"id":"108603","content":"是的，动态规划其实是学习解决问题的思想，然后不断尝试用这种方法去解决各类问题，总结不同类型问题，最后慢慢培养一种解决问题的新思维。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1624693556,"ip_address":"","comment_id":288485,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618489265","product_id":100060501,"comment_content":"看到这里有一个心得体会，动态规划确实是一种解决问题的思想，光看作者的代码实现其实收获会很小，而且后续也不一定能解决类似的动态规划问题，要把更多的时间和经历花在体会作者分析一个问题到动态规划的几个特点中的过程，这个是核心，容我再多看几遍，榨干作者，哈哈哈","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518637,"discussion_content":"是的，动态规划其实是学习解决问题的思想，然后不断尝试用这种方法去解决各类问题，总结不同类型问题，最后慢慢培养一种解决问题的新思维。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624693556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285030,"user_name":"James","can_delete":false,"product_type":"c1","uid":1036309,"ip_address":"","ucode":"7A0DC75746CB3A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/15/c5dc2b0d.jpg","comment_is_top":false,"comment_ctime":1616584337,"is_pvip":false,"replies":[{"id":"104562","content":"这个方法是不行的，你可以换一类数据试试看这个方法。比如剩余空间为3时，有一个重量2价值4的，和一个重量3价值5的，你只能选性价比低的，否则你需要加上回溯，这样时间复杂度就高了，不是简单贪心就能解决的。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1618231089,"ip_address":"","comment_id":285030,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616584337","product_id":100060501,"comment_content":"老师那个0-1背包的问题你说用贪心来解不能得到全局最优解，但是我想了下对于贪心来说，我每次都选择单位重量下价值最大的那个物品最终也能得到全局最优解（比如那个例子价值为3的物品重量为1，那每单位重量就值3，这个最大，我先选这个，其次是价值为5的物品，平均单位价值为1.6，我再选择这个物品，那么最终求得的价值是8），是全局最优解，不知道理解的对不对","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517555,"discussion_content":"这个方法是不行的，你可以换一类数据试试看这个方法。比如剩余空间为3时，有一个重量2价值4的，和一个重量3价值5的，你只能选性价比低的，否则你需要加上回溯，这样时间复杂度就高了，不是简单贪心就能解决的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618231089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282768,"user_name":"Geek_116dbe","can_delete":false,"product_type":"c1","uid":2366949,"ip_address":"","ucode":"7905FDA531501A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/kj8UwADicsWBicD19FFOg8BuxHBibweWibxjpNIKHSJmAsIUu7D0GfFWdWfFELc688m9icmrfThvickW9ibAddq4jD4ow/132","comment_is_top":false,"comment_ctime":1615390485,"is_pvip":false,"replies":[{"id":"102842","content":"这道题目需要求的其实是最后的结果，而不是一个可行序列，对于[4,3,4,3,2]这个序列其实有其他的执行序列可以达到最后粉碎结果为0的效果。所以这个需要根据题目要求来看具体的算法，得到最后的结果和得到序列的算法是不一样的。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1615801516,"ip_address":"","comment_id":282768,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615390485","product_id":100060501,"comment_content":"确实能通过大部分测试用例。<br>但是[4,3,4,3,2]这个测试用例无法通过，确实可以选出4 + 4 和 3 + 3 + 2两个和为8的序列，但是无法碰撞让其剩余值为0。<br>这里的问题就是碰撞过程是离散的，相同和相消是连续的，在实际操作中无法完全匹配。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516830,"discussion_content":"这道题目需要求的其实是最后的结果，而不是一个可行序列，对于[4,3,4,3,2]这个序列其实有其他的执行序列可以达到最后粉碎结果为0的效果。所以这个需要根据题目要求来看具体的算法，得到最后的结果和得到序列的算法是不一样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615801516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279524,"user_name":"刘帅帅","can_delete":false,"product_type":"c1","uid":1314396,"ip_address":"","ucode":"69BC4DEC380A3E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eogu5icVZzlYcOv5yxLBPtFk1EicguBCAqc2eOTrE1ttlSeTsky645Nw00gu0JF9P0BYib18dJBjlmtA/132","comment_is_top":false,"comment_ctime":1613811937,"is_pvip":false,"replies":[{"id":"102850","content":"谢谢，我们会继续努力，进一步提升课程的质量。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1615801780,"ip_address":"","comment_id":279524,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613811937","product_id":100060501,"comment_content":"写的是非常的棒的，特别是思考分析的过程，这种就是已经达到举重若轻的地步了。","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515763,"discussion_content":"谢谢，我们会继续努力，进一步提升课程的质量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615801780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262616,"user_name":"猴子请来的仁波切","can_delete":false,"product_type":"c1","uid":1142393,"ip_address":"","ucode":"08DDFC23784BF8","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/79/abf66ba0.jpg","comment_is_top":false,"comment_ctime":1605780446,"is_pvip":false,"replies":[{"id":"95662","content":"在0-1背包中，如果物品tn的重量已经大于背包可以容纳的总重量，自然就不选择这个了。如果可以容纳下而且价值很高，那么肯定会有一个方案是没有选择前面的物品选择了最后的物品确保总价值最高。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1606230823,"ip_address":"","comment_id":262616,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605780446","product_id":100060501,"comment_content":"老师咨询个问题，举个极端的情况，在选取物品tn时，它的重量大于背包可容纳的重量，但它的价值非常大，目前的处理方法会漏掉物品tn<br>是不是输入数据需要提前做一下什么处理？","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509899,"discussion_content":"在0-1背包中，如果物品tn的重量已经大于背包可以容纳的总重量，自然就不选择这个了。如果可以容纳下而且价值很高，那么肯定会有一个方案是没有选择前面的物品选择了最后的物品确保总价值最高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606230823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260699,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1605085953,"is_pvip":true,"replies":[{"id":"95909","content":"尝试用解题模板去套用一些题目，多做一些练习。会好起来。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1606550837,"ip_address":"","comment_id":260699,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605085953","product_id":100060501,"comment_content":"动态规划确实一个难啃的骨头","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509265,"discussion_content":"尝试用解题模板去套用一些题目，多做一些练习。会好起来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606550837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259566,"user_name":"Lake","can_delete":false,"product_type":"c1","uid":1096981,"ip_address":"","ucode":"D8BE14643919BC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLHS9BjwOgkqV1NSmNRFxUC6KU0DibS75f00GhMWx4s5OYLryibaNDoJ1tZAFRaHJ7jSZXA4pNumraQ/132","comment_is_top":false,"comment_ctime":1604757209,"is_pvip":false,"replies":[{"id":"95670","content":"“应该是这样吧1−(1 - ((4−2)−(9−7))) ”<br><br>是的，感谢提出，已纠正。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1606230941,"ip_address":"","comment_id":259566,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604757209","product_id":100060501,"comment_content":"这道题真的是上来好吓唬人，本地写了几个例子能过，偶然发现LeetCode有，就贴下能AC的版本吧。<br>另外1−(((4−2)−(9−7))−1) 这里应该是写错了吧，应该是这样吧1−(1 - ((4−2)−(9−7))) <br><br>class Solution {<br>    public int lastStoneWeightII(int[] stones) {<br>        int sum = 0;<br>        int N = stones.length;<br>        for(int i=0; i&lt;N; i++) {<br>            sum += stones[i];<br>        }<br>        <br>        int W = sum &#47; 2;<br>        int[][] dp = new int[N + 1][W + 1];<br>        <br>        for(int i=0; i&lt;N + 1; i++) dp[i][0] = 0;<br>        for(int j=0; j&lt;W + 1; j++) dp[0][j] = 0;<br>        <br>        for(int i=1; i&lt;N + 1; i++) {<br>            for(int j=1; j&lt; W + 1; j++) {<br>                if(j &lt; stones[i-1]) {<br>                    dp[i][j] = dp[i-1][j];<br>                } else {<br>                    dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-stones[i-1]] + stones[i-1]);<br>                }<br>            }<br>        }<br>        <br>        int maxHalfSum = dp[N][W];<br>        <br>        return sum - maxHalfSum * 2;<br>    }<br>}","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508960,"discussion_content":"“应该是这样吧1−(1 - ((4−2)−(9−7))) ”\n\n是的，感谢提出，已纠正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606230941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259411,"user_name":"冬风向左吹","can_delete":false,"product_type":"c1","uid":1066928,"ip_address":"","ucode":"376C45C5134F93","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/b0/a9b77a1e.jpg","comment_is_top":false,"comment_ctime":1604720062,"is_pvip":false,"replies":[{"id":"95673","content":"因为 dp[tn][rw]是背包在处理第tn个物品后背包剩余rw容量的最优解，那么如果我们没有把第tn件物品放进去，那么肯定就是dp[tn-1][rw]。当时如果我们要把第tn件物品放进去，那么放进去背包之后容量就只剩下了rw-w[tn]，所以需要取得就是dp[tn-1][rw-w[tn]] （也就是在容量只剩下rw-w[tn]得情况下，处理第tn-1个物品时最优是多少）。<br> <br>","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1606230973,"ip_address":"","comment_id":259411,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604720062","product_id":100060501,"comment_content":"没太理解这里：放入物品前的价值+放入物品的价值。dp[tn-1][rw-w[tn]] + v[tn]","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508933,"discussion_content":"因为 dp[tn][rw]是背包在处理第tn个物品后背包剩余rw容量的最优解，那么如果我们没有把第tn件物品放进去，那么肯定就是dp[tn-1][rw]。当时如果我们要把第tn件物品放进去，那么放进去背包之后容量就只剩下了rw-w[tn]，所以需要取得就是dp[tn-1][rw-w[tn]] （也就是在容量只剩下rw-w[tn]得情况下，处理第tn-1个物品时最优是多少）。\n \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606230973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259238,"user_name":"帽子狗","can_delete":false,"product_type":"c1","uid":2106663,"ip_address":"","ucode":"51596F366AF068","user_header":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","comment_is_top":false,"comment_ctime":1604660689,"is_pvip":false,"replies":[{"id":"95675","content":"这个思路也是没问题的，不过就涉及到连续子数组的处理了。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1606230992,"ip_address":"","comment_id":259238,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1604660689","product_id":100060501,"comment_content":"如果仅剩3个石头，质量分别为a,b,c 且 a &gt; b &amp;&amp; a &gt;c。<br>其结果一定是abs(a - (b+c))<br>那么对于每个stone数组， 都可以将其拆分为3个连续子数组, 并求碎石结果。<br>选出最小的拆分结果。<br><br>私以为这样穷举会直观点.<br><br>dp数组二维dp[i][j] 表示从i - j 区间的子数组碎出来的结果, 0 &lt;= i &lt;= j &lt; stone.length","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508885,"discussion_content":"这个思路也是没问题的，不过就涉及到连续子数组的处理了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606230992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2106663,"avatar":"https://static001.geekbang.org/account/avatar/00/20/25/27/0076d304.jpg","nickname":"帽子狗","note":"","ucode":"51596F366AF068","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328825,"discussion_content":"嗯，想了下。不算连续子数组吧，主要首尾没有左右石头，要单独处理下。会稍微绕点，确实不太适合做例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606233114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257641,"user_name":"jefferyqjy","can_delete":false,"product_type":"c1","uid":1179005,"ip_address":"","ucode":"30A2191B644966","user_header":"https://static001.geekbang.org/account/avatar/00/11/fd/7d/b0ca572b.jpg","comment_is_top":false,"comment_ctime":1604047406,"is_pvip":false,"replies":[{"id":"94425","content":"恩，这方面的确可以做得更好。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1604900471,"ip_address":"","comment_id":257641,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604047406","product_id":100060501,"comment_content":"建议0-1背包问题一开始的那个描述状态转移方程的伪代码各个变量是什么意思，描述可以再斟酌一下~现在tn“即已经遍历过的物品”这样的描述感觉有点拗口，也不清晰，不太容易理解","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508401,"discussion_content":"恩，这方面的确可以做得更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604900471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254898,"user_name":"马东","can_delete":false,"product_type":"c1","uid":1445290,"ip_address":"","ucode":"8F53148B85F12A","user_header":"https://static001.geekbang.org/account/avatar/00/16/0d/aa/4f038961.jpg","comment_is_top":false,"comment_ctime":1603208379,"is_pvip":false,"replies":[{"id":"93412","content":"是的，这种解法也是可以的，本质的解体思路没有区别。<br>赞，顶上去让更多人看到。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1603700748,"ip_address":"","comment_id":254898,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603208379","product_id":100060501,"comment_content":"“”粉碎石头”，尝试求解了一下，想到了两种解法，第一种就是在数组中插入‘+’ ，‘-’ 使得数组总值最小，我记得这个leetcode有类似这个题型；第二种方法，也就是本节课中给出的解法：<br>    public static int rock(int[] w){<br><br>        int sum = 0;<br>        for (int i = 0; i &lt; w.length ; i++) {<br>            sum += w[i];<br>        }<br><br>        return sum&#47;2 - rockHelper(w,sum&#47;2,w.length -1);<br>    }<br><br>    private static int rockHelper(int[] w, int cap,int N){<br>        int[][] dp = new int[N + 1][cap + 1];<br><br><br>        for (int i = 1; i &lt; N+1; i++) {<br><br>            for (int j = 1; j &lt; cap+1; j++) {<br><br>                if (j &lt; w[i]){<br>                    dp[i][j] = dp[i-1][j];<br>                }else {<br>                    int t1 = dp[i-1][j];<br>                    int t2 = dp[i-1][j-w[i]];<br>                    if (t2 + w[i] &gt; cap){<br>                        dp[i][j] = dp[i-1][j];<br>                    }else{<br>                        dp[i][j] = Math.max(t1,t2+w[i]);<br>                    }<br>                }<br>            }<br><br>        }<br>        <br>        return dp[N][cap];<br>    }","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507549,"discussion_content":"是的，这种解法也是可以的，本质的解体思路没有区别。\n赞，顶上去让更多人看到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603700748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254084,"user_name":"iron_man","can_delete":false,"product_type":"c1","uid":1099883,"ip_address":"","ucode":"C0053A59442910","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/6b/0f3876ef.jpg","comment_is_top":false,"comment_ctime":1603062915,"is_pvip":false,"replies":[{"id":"93657","content":"是的，这里可以将石头数量限定成石头总数的1&#47;2。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1603904381,"ip_address":"","comment_id":254084,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603062915","product_id":100060501,"comment_content":"老师讲的很透，很细，很好。对于粉碎石头的问题有一点疑惑，就是选择容量为12的背包，是不是还有石头数量的限制，不多不少只能3个石头？而0-1背包问题，对于选择的石头并没有数量限制，只要不超过石头总数和背包容量即可","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507275,"discussion_content":"是的，这里可以将石头数量限定成石头总数的1/2。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603904381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252797,"user_name":"猫头鹰爱拿铁","can_delete":false,"product_type":"c1","uid":1105958,"ip_address":"","ucode":"24266B58968428","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/26/4942a09e.jpg","comment_is_top":false,"comment_ctime":1602489752,"is_pvip":true,"replies":[{"id":"92675","content":"赞，没有问题。给你顶上去。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1602856186,"ip_address":"","comment_id":252797,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602489752","product_id":100060501,"comment_content":"尝试用递归和dp解了一下，这里有个难点就是为什么返回值是总和-dp值*2，数组可以看成[平均值-偏差，平均值+偏差]，要使得平均值+偏差-（平均值-偏差）最小也就是偏差需要最小，而dp算出来的值是最接近平均值的，所以偏差最小。<br>private static int min = Integer.MAX_VALUE;<br><br>    public int ans(int[] weight) {<br>        int n = weight.length;<br>        int w = 0;<br>        for (int i = 0; i &lt; weight.length; i++) {<br>            w += weight[i];<br>        }<br><br>        getAnsByRecursion(0, n, 0, w, weight);<br>        &#47;&#47;return getAnsByDP(w, n, weight);<br>        return min;<br>    }<br><br>    public void getAnsByRecursion(int k, int n, int rw, int w, int[] weight) {<br>        if (k == n) {<br>            if (Math.abs(w - rw * 2) &lt; min) {<br>                min = Math.abs(w - rw * 2);<br>            }<br>            return;<br>        }<br>        for (int i = k; i &lt; n; i++) {<br>            getAnsByRecursion(i + 1, n, rw + weight[i], w, weight);<br>            getAnsByRecursion(i + 1, n, rw, w, weight);<br>        }<br>    }<br><br>    public int getAnsByDP(int w, int n, int[] weight) {<br>        &#47;&#47;取前i个最接近w的重量<br>        int total = w;<br>        w = w &#47; 2;<br>        int[][] dp = new int[n + 1][w + 1];<br>        for (int i = 0; i &lt; w + 1; i++) {<br>            dp[0][i] = 0;<br>        }<br>        for (int j = 0; j &lt; n + 1; j++) {<br>            dp[j][0] = 0;<br>        }<br>        for (int i = 1; i &lt; n + 1; i++) {<br>            for (int j = 1; j &lt; w + 1; j++) {<br>                if (j - weight[i - 1] &gt;= 0) {<br>                    if (Math.abs(j - dp[i - 1][j]) &gt;<br>                            Math.abs(j - (dp[i - 1][j - weight[i - 1]] + weight[i - 1]))) {<br>                        dp[i][j] = dp[i - 1][j - weight[i - 1]] + weight[i - 1];<br>                        continue;<br>                    }<br>                }<br>                dp[i][j] = dp[i - 1][j];<br>            }<br>        }<br>        return total - 2 * dp[n][w];<br>    }","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506877,"discussion_content":"赞，没有问题。给你顶上去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602856186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252469,"user_name":"AshinInfo","can_delete":false,"product_type":"c1","uid":1299511,"ip_address":"","ucode":"098F5C74A37009","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/37/aa152ddb.jpg","comment_is_top":false,"comment_ctime":1602314064,"is_pvip":false,"replies":[{"id":"92679","content":"是的，这里初始化是一个“例行过程”。主要为了让整个动态规划的“套路”更加清晰，注意有初始化状态这个步骤。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1602856396,"ip_address":"","comment_id":252469,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602314064","product_id":100060501,"comment_content":"&#47;&#47; 初始化状态    <br>for (int i = 0; i &lt; N + 1; i++) { dp[i][0] = 0; }    <br>for (int j = 0; j &lt; W + 1; j++) { dp[0][j] = 0; <br>在java代码中，这两行的初始化代码可以去掉，默认都是0","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506785,"discussion_content":"是的，这里初始化是一个“例行过程”。主要为了让整个动态规划的“套路”更加清晰，注意有初始化状态这个步骤。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602856396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250318,"user_name":"德忠","can_delete":false,"product_type":"c1","uid":2049550,"ip_address":"","ucode":"5AE28832F4B3F1","user_header":"https://static001.geekbang.org/account/avatar/00/1f/46/0e/cc32612e.jpg","comment_is_top":false,"comment_ctime":1601022654,"is_pvip":false,"replies":[{"id":"91923","content":"这里仔细看一下w和v定义，我们特意把数组第一位定义成了0，所以这里取重量价值的时候不用-1。","user_name":"作者回复","user_name_real":"卢誉声","uid":"1006976","ctime":1601559594,"ip_address":"","comment_id":250318,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1601022654","product_id":100060501,"comment_content":"tn是从1到N+1, c++ 代码 11、15行用tn取重量和价值，应该是w[tn-1]、v[tn-1]吧","like_count":0,"discussions":[{"author":{"id":1006976,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/80/0c52be53.jpg","nickname":"卢誉声","note":"","ucode":"93C5EFC39EB9C6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506181,"discussion_content":"这里仔细看一下w和v定义，我们特意把数组第一位定义成了0，所以这里取重量价值的时候不用-1。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601559594,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2182238,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIsVqicRvr1dQhkmBVNsY58wloFlAqGyPiaRj6e8azllnQsn0wtRfaicibVTnKVJd8fIn9JhiciaBuicAwwg/132","nickname":"霸道","note":"","ucode":"4709DE8DFD797E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309131,"discussion_content":"w,v第一项都是0,0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601193924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}