{"id":185189,"title":"17 | 函数式编程：一种越来越流行的编程范式","content":"<p>你好，我是吴咏炜。</p><p>上一讲我们初步介绍了函数对象和 lambda 表达式，今天我们来讲讲它们的主要用途——函数式编程。</p><h2>一个小例子</h2><p>按惯例，我们还是从一个例子开始。想一下，如果给定一组文件名，要求数一下文件里的总文本行数，你会怎么做？</p><p>我们先规定一下函数的原型：</p><pre><code class=\"language-c++\">int count_lines(const char** begin,\n                const char** end);\n</code></pre><p>也就是说，我们期待接受两个 C 字符串的迭代器，用来遍历所有的文件名；返回值代表文件中的总行数。</p><p>要测试行为是否正常，我们需要一个很小的 <code>main</code> 函数：</p><pre><code class=\"language-c++\">int main(int argc,\n         const char** argv)\n{\n  int total_lines = count_lines(\n    argv + 1, argv + argc);\n  cout &lt;&lt; \"Total lines: \"\n       &lt;&lt; total_lines &lt;&lt; endl;\n}\n</code></pre><p>最传统的命令式编程大概会这样写代码：</p><pre><code class=\"language-c++\">int count_file(const char* name)\n{\n  int count = 0;\n  ifstream ifs(name);\n  string line;\n  for (;;) {\n    getline(ifs, line);\n    if (!ifs) {\n      break;\n    }\n    ++count;\n  }\n  return count;\n}\n\nint count_lines(const char** begin,\n                const char** end)\n{\n  int count = 0;\n  for (; begin != end; ++begin) {\n    count += count_file(*begin);\n  }\n  return count;\n}\n</code></pre><!-- [[[read_end]]] --><p>我们马上可以做一个简单的“说明式”改造。用 <code>istream_line_reader</code> 可以简化 <code>count_file</code> 成：</p><pre><code class=\"language-c++\">int count_file(const char* name)\n{\n  int count = 0;\n  ifstream ifs(name);\n  for (auto&amp;&amp; line :\n       istream_line_reader(ifs)) {\n    ++count;\n  }\n  return count;\n}\n</code></pre><p>在这儿，要请你停一下，想一想如何进一步优化这个代码。然后再继续进行往下看。</p><hr><p>如果我们使用之前已经出场过的两个函数，<code>transform</code> <span class=\"orange\">[1]</span> 和 <code>accumulate</code> <span class=\"orange\">[2]</span>，代码可以进一步简化为：</p><pre><code class=\"language-c++\">int count_file(const char* name)\n{\n  ifstream ifs(name);\n  istream_line_reader reader(ifs);\n  return distance(reader.begin(),\n                  reader.end());\n}\n\nint count_lines(const char** begin,\n                const char** end)\n{\n  vector&lt;int&gt; count(end - begin);\n  transform(begin, end,\n            count.begin(),\n            count_file);\n  return accumulate(\n    count.begin(), count.end(),\n    0);\n}\n</code></pre><p>这个就是一个非常函数式风格的结果了。上面这个处理方式恰恰就是 map-reduce。<code>transform</code> 对应 map，<code>accumulate</code> 对应 reduce。而检查有多少行文本，也成了代表文件头尾两个迭代器之间的“距离”（distance）。</p><h2>函数式编程的特点</h2><p>在我们的代码里不那么明显的一点是，函数式编程期望函数的行为像数学上的函数，而非一个计算机上的子程序。这样的函数一般被称为纯函数（pure function），要点在于：</p><ul>\n<li>会影响函数结果的只是函数的参数，没有对环境的依赖</li>\n<li>返回的结果就是函数执行的唯一后果，不产生对环境的其他影响</li>\n</ul><p>这样的代码的最大好处是易于理解和易于推理，在很多情况下也会使代码更简单。在我们上面的代码里，<code>count_file</code> 和 <code>accumulate</code> 基本上可以看做是纯函数（虽然前者实际上有着对文件系统的依赖），但 <code>transform</code> 不行，因为它改变了某个参数，而不是返回一个结果。下一讲我们会看到，这会影响代码的组合性。</p><p>我们的代码中也体现了其他一些函数式编程的特点：</p><ul>\n<li>函数就像普通的对象一样被传递、使用和返回。</li>\n<li>代码为说明式而非命令式。在熟悉函数式编程的基本范式后，你会发现说明式代码的可读性通常比命令式要高，代码还短。</li>\n<li>一般不鼓励（甚至完全不使用）可变量。上面代码里只有 <code>count</code> 的内容在执行过程中被修改了，而且这种修改实际是 <code>transform</code> 接口带来的。如果接口像<a href=\"https://time.geekbang.org/column/article/181608\">[第 13 讲]</a> 展示的 <code>fmap</code> 函数一样返回一个容器的话，就可以连这个问题都消除了。（C++ 毕竟不是一门函数式编程语言，对灵活性的追求压倒了其他考虑。）</li>\n</ul><h3>高阶函数</h3><p>既然函数（对象）可以被传递、使用和返回，自然就有函数会接受函数作为参数或者把函数作为返回值，这样的函数就被称为高阶函数。我们现在已经见过不少高阶函数了，如：</p><ul>\n<li><code>sort</code></li>\n<li><code>transform</code></li>\n<li><code>accumulate</code></li>\n<li><code>fmap</code></li>\n<li><code>adder</code></li>\n</ul><p>事实上，C++ 里以 algorithm（算法）<span class=\"orange\">[3]</span> 名义提供的很多函数都是高阶函数。</p><p>许多高阶函数在函数式编程中已成为基本的惯用法，在不同语言中都会出现，虽然可能是以不同的名字。我们在此介绍非常常见的三个，map（映射）、reduce（归并）和 filter（过滤）。</p><p>Map 在 C++ 中的直接映射是 <code>transform</code>（在 &lt;algorithm&gt; 头文件中提供）。它所做的事情也是数学上的映射，把一个范围里的对象转换成相同数量的另外一些对象。这个函数的基本实现非常简单，但这是一种强大的抽象，在很多场合都用得上。</p><p>Reduce 在 C++ 中的直接映射是 <code>accumulate</code>（在 &lt;numeric&gt; 头文件中提供）。它的功能是在指定的范围里，使用给定的初值和函数对象，从左到右对数值进行归并。在不提供函数对象作为第四个参数时，功能上相当于默认提供了加法函数对象，这时相当于做累加；提供了其他函数对象时，那当然就是使用该函数对象进行归并了。</p><p>Filter 的功能是进行过滤，筛选出符合条件的成员。它在当前 C++（C++20 之前）里的映射可以认为有两个：<code>copy_if</code> 和 <code>partition</code>。这是因为在 C++20 带来 ranges 之前，在 C++ 里实现惰性求值不太方便。上面说的两个函数里，<code>copy_if</code> 是把满足条件的元素拷贝到另外一个迭代器里；<code>partition</code> 则是根据过滤条件来对范围里的元素进行分组，把满足条件的放在返回值迭代器的前面。另外，<code>remove_if</code> 也有点相近，通常用于删除满足条件的元素。它确保把不满足条件的元素放在返回值迭代器的前面（但不保证满足条件的元素在函数返回后一定存在），然后你一般需要使用容器的 <code>erase</code> 成员函数来将待删除的元素真正删除。</p><h3>命令式编程和说明式编程</h3><p>传统上 C++ 属于命令式编程。命令式编程里，代码会描述程序的具体执行步骤。好处是代码显得比较直截了当；缺点就是容易让人只见树木、不见森林，只能看到代码啰嗦地怎么做（how），而不是做什么（what），更不用说为什么（why）了。</p><p>说明式编程则相反。以数据库查询语言 SQL 为例，SQL 描述的是类似于下面的操作：你想从什么地方（from）选择（select）满足什么条件（where）的什么数据，并可选指定排序（order by）或分组（group by）条件。你不需要告诉数据库引擎具体该如何去执行这个操作。事实上，在选择查询策略上，大部分数据库用户都不及数据库引擎“聪明”；正如大部分开发者在写出优化汇编代码上也不及编译器聪明一样。</p><p>这并不是说说明式编程一定就优于命令式编程。事实上，对于很多算法，命令式才是最自然的实现。以快速排序为例，很多地方在讲到函数式编程时会给出下面这个 Haskell（一种纯函数式的编程语言）的例子来说明函数式编程的简洁性：</p><pre><code class=\"language-haskell\">quicksort []     = []\nquicksort (p:xs) = (quicksort left)\n         ++ [p] ++ (quicksort right)\n  where\n    left  = filter (&lt; p) xs\n    right = filter (&gt;= p) xs\n</code></pre><p>这段代码简洁性确实没话说，但问题是，上面的代码的性能其实非常糟糕。真正接近 C++ 性能的快速排序，在 Haskell 里写出来一点不优雅，反而更丑陋 <span class=\"orange\">[4]</span>。</p><p>所以，我个人认为，说明式编程跟命令式编程可以结合起来产生既优雅又高效的代码。对于从命令式编程成长起来的大部分程序员，我的建议是：</p><ul>\n<li>写表意的代码，不要过于专注性能而让代码难以维护——记住高德纳的名言：“过早优化是万恶之源。”</li>\n<li>使用有意义的变量，但尽量不要去修改变量内容——变量的修改非常容易导致程序员的思维错误。</li>\n<li>类似地，尽量使用没有副作用的函数，并让你写的代码也尽量没有副作用，用返回值来代表状态的变化——没有副作用的代码更容易推理，更不容易出错。</li>\n<li>代码的隐式依赖越少越好，尤其是不要使用全局变量——隐式依赖会让代码里的错误难以排查，也会让代码更难以测试。</li>\n<li>使用知名的高级编程结构，如基于范围的 for 循环、映射、归并、过滤——这可以让你的代码更简洁，更易于推理，并减少类似下标越界这种低级错误的可能性。</li>\n</ul><p>这些跟函数式编程有什么关系呢？——这些差不多都是来自函数式编程的最佳实践。学习函数式编程，也是为了更好地体会如何从这些地方入手，写出易读而又高性能的代码。</p><h3>不可变性和并发</h3><p>在多核的时代里，函数式编程比以前更受青睐，一个重要的原因是函数式编程对并行并发天然友好。影响多核性能的一个重要因素是数据的竞争条件——由于共享内存数据需要加锁带来的延迟。函数式编程强调不可变性（immutability）、无副作用，天然就适合并发。更妙的是，如果你使用高层抽象的话，有时可以轻轻松松“免费”得到性能提升。</p><p>拿我们这一讲开头的例子来说，对代码做下面的改造，启用 C++17 的并行执行策略 <span class=\"orange\">[5]</span>，就能自动获得在多核环境下的性能提升：</p><pre><code class=\"language-c++\">int count_lines(const char** begin,\n                const char** end)\n{\n  vector&lt;int&gt; count(end - begin);\n  transform(execution::par,\n            begin, end,\n            count.begin(),\n            count_file);\n  return reduce(\n    execution::par,\n    count.begin(), count.end());\n}\n</code></pre><p>我们可以看到，两个高阶函数的调用中都加入了 <code>execution::par</code>，来启动自动并行计算。要注意的是，我把 <code>accumulate</code> 换成了 <code>reduce</code> <span class=\"orange\">[6]</span>，原因是前者已经定义成从左到右的归并，无法并行。<code>reduce</code> 则不同，初始值可以省略，操作上没有规定顺序，并反过来要求对元素的归并操作满足交换律和结合率（加法当然是满足的），即：</p><p>$$<br>\n\\begin{aligned}<br>\nA\\ \\otimes\\ B &amp;= B\\ \\otimes\\ A\\\\\\<br>\n(A\\ \\otimes\\ B)\\ \\otimes\\ C &amp;= A\\ \\otimes\\ (B\\ \\otimes\\ C)<br>\n\\end{aligned}<br>\n$$</p><p>当然，在这个例子里，一般我们不会有海量文件，即使有海量文件，并行读取性能一般也不会快于顺序读取，所以意义并不是很大。下面这个简单的例子展示了并行 <code>reduce</code> 的威力：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;execution&gt;\n#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main()\n{\n  vector&lt;double&gt; v(10000000, 0.0625);\n\n  {\n    auto t1 = chrono::\n      high_resolution_clock::now();\n    double result = accumulate(\n      v.begin(), v.end(), 0.0);\n    auto t2 = chrono::\n      high_resolution_clock::now();\n    chrono::duration&lt;double, milli&gt;\n      ms = t2 - t1;\n    cout &lt;&lt; \"accumulate: result \"\n         &lt;&lt; result &lt;&lt; \" took \"\n         &lt;&lt; ms.count() &lt;&lt; \" ms\\n\";\n  }\n\n  {\n    auto t1 = chrono::\n      high_resolution_clock::now();\n    double result =\n      reduce(execution::par,\n             v.begin(), v.end());\n    auto t2 = chrono::\n      high_resolution_clock::now();\n    chrono::duration&lt;double, milli&gt;\n      ms = t2 - t1;\n    cout &lt;&lt; \"reduce:     result \"\n         &lt;&lt; result &lt;&lt; \" took \"\n         &lt;&lt; ms.count() &lt;&lt; \" ms\\n\";\n  }\n}\n</code></pre><p>在我的电脑（Core i7 四核八线程）上的某次执行结果是：</p><blockquote>\n<p><code>accumulate: result 625000 took 26.122 ms</code><br>\n<code>reduce: result 625000 took 4.485 ms</code></p>\n</blockquote><p>执行策略还比较新，还没有被所有编译器支持。我目前测试下来，MSVC 没有问题，Clang 不行，GCC 需要外部库 TBB（Threading Building Blocks）<span class=\"orange\">[7]</span> 的帮助。我上面是用 GCC 编译的，命令行是：</p><blockquote>\n<p><code>g++-9 -std=c++17 -O3 test.cpp -ltbb</code></p>\n</blockquote><h2>Y 组合子</h2><p>限于篇幅，这一讲我们只是很初浅地探讨了函数式编程。对于 C++ 的函数式编程的深入探讨是有整本书的（见参考资料 <span class=\"orange\">[8]</span>），而今天讲的内容在书的最前面几章就覆盖完了。在后面，我们还会探讨部分的函数式编程话题；今天我们只再讨论一个有点有趣、也有点烧脑的话题，Y 组合子 <span class=\"orange\">[9]</span>。第一次阅读的时候，如果觉得困难，可以跳过这一部分。</p><p>不过，我并不打算讨论 Haskell Curry 使用的 Y 组合子定义——这个比较复杂，需要写一篇完整的文章来讨论（<span class=\"orange\">[10]</span>），而且在 C++ 中的实用性非常弱。我们只看它解决的问题：如何在 lambda 表达式中表现递归。</p><p>回想一下我们用过的阶乘的递归定义：</p><pre><code class=\"language-c++\">int factorial(int n)\n{\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * factorial(n - 1);\n  }\n}\n</code></pre><p>注意里面用到了递归，所以你要把它写成 lambda 表达式是有点困难的：</p><pre><code class=\"language-c++\">auto factorial = [](int n) {\n  if (n == 0) {\n    return 1;\n  } else {\n    return n * ???(n - 1);\n  }\n}\n</code></pre><p>下面我们讨论使用 Y 组合子的解决方案。</p><p>我们首先需要一个特殊的高阶函数，定义为：</p><p>$$<br>\ny(f) = f(y(f))<br>\n$$</p><p>显然，这个定义有点奇怪。事实上，它是会导致无限展开的——而它的威力也在于无限展开。我们也因此必须使用惰性求值的方式才能使用这个定义。</p><p>然后，我们定义阶乘为：</p><p>$$<br>\n\\mathrm{fact}(n) = \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times \\mathrm{fact}(n − 1)<br>\n$$</p><p>假设 $\\mathrm{fact}$ 可以表示成 $y(F)$，那我们可以做下面的变形：</p><p>$$<br>\n\\begin{aligned}<br>\ny(F)(n) &amp;= \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times y(F)(n − 1)\\\\\\<br>\nF(y(F))(n) &amp;= \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times y(F)(n − 1)<br>\n\\end{aligned}<br>\n$$</p><p>再把 $y(F)$ 替换成 $f$，我们从上面的第二个式子得到：</p><p>$$<br>\nF(f)(n) = \\mathrm{If\\ IsZero}(n)\\ \\mathrm{then}\\ 1\\ \\mathrm{else}\\ n \\times f(n − 1)<br>\n$$</p><p>我们得到了 $F$ 的定义，也就自然得到了 $\\mathrm{fact}$ 的定义。而且，这个定义是可以用 C++ 表达出来的。下面是完整的代码实现：</p><pre><code class=\"language-c++\">#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\n// Y combinator as presented by Yegor Derevenets in P0200R0\n// &lt;url:http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html&gt;\ntemplate &lt;class Fun&gt;\nclass y_combinator_result {\n  Fun fun_;\npublic:\n  template &lt;class T&gt;\n  explicit y_combinator_result(\n    T&amp;&amp; fun)\n    : fun_(std::forward&lt;T&gt;(fun))\n  {\n  }\n\n  template &lt;class... Args&gt;\n  decltype(auto)\n  operator()(Args&amp;&amp;... args)\n  {\n    // y(f) = f(y(f))\n    return fun_(\n      std::ref(*this),\n      std::forward&lt;Args&gt;(args)...);\n  }\n};\n\ntemplate &lt;class Fun&gt;\ndecltype(auto)\ny_combinator(Fun&amp;&amp; fun)\n{\n  return y_combinator_result&lt;\n    std::decay_t&lt;Fun&gt;&gt;(\n    std::forward&lt;Fun&gt;(fun));\n}\n\nint main()\n{\n  // 上面的那个 F\n  auto almost_fact =\n    [](auto f, int n) -&gt; int {\n    if (n == 0)\n      return 1;\n    else\n      return n * f(n - 1);\n  };\n  // fact = y(F)\n  auto fact =\n    y_combinator(almost_fact);\n  cout &lt;&lt; fact(10) &lt;&lt; endl;\n}\n</code></pre><p>这一节不影响后面的内容，看不懂的可以暂时略过。😝</p><h2>内容小结</h2><p>本讲我们对函数式编程进行了一个入门式的介绍，希望你对函数式编程的特点、优缺点有了一个初步的了解。然后，我快速讨论了一个会烧脑的话题，Y 组合子，让你对函数式编程的威力和难度也有所了解。</p><h2>课后思考</h2><p>想一想，你如何可以实现一个惰性的过滤器？一个惰性的过滤器应当让下面的代码通过编译，并且不会占用跟数据集大小相关的额外空间：</p><pre><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n// filter_view 的定义\n\nint main()\n{\n  vector v{1, 2, 3, 4, 5};\n  auto&amp;&amp; fv = filter_view(\n    v.begin(), v.end(), [](int x) {\n      return x % 2 == 0;\n    });\n  cout &lt;&lt; accumulate(fv.begin(),\n                     fv.end(), 0)\n       &lt;&lt; endl;\n}\n</code></pre><p>结果输出应该是 <code>6</code>。</p><p><strong>提示：</strong>参考 <code>istream_line_reader</code> 的实现。</p><p>告诉我你是否成功了，或者你遇到了什么样的特别困难。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] cppreference.com, “std::transform”. <a href=\"https://en.cppreference.com/w/cpp/algorithm/transform\">https://en.cppreference.com/w/cpp/algorithm/transform</a> </span></p><p><span class=\"reference\">[1a] cppreference.com, “std::transform”. <a href=\"https://zh.cppreference.com/w/cpp/algorithm/transform\">https://zh.cppreference.com/w/cpp/algorithm/transform</a> </span></p><p><span class=\"reference\">[2] cppreference.com, “std::accumulate”. <a href=\"https://en.cppreference.com/w/cpp/algorithm/accumulate\">https://en.cppreference.com/w/cpp/algorithm/accumulate</a> </span></p><p><span class=\"reference\">[2a] cppreference.com, “std::accumulate”. <a href=\"https://zh.cppreference.com/w/cpp/algorithm/accumulate\">https://zh.cppreference.com/w/cpp/algorithm/accumulate</a> </span></p><p><span class=\"reference\">[3] cppreference.com, “Standard library header &lt;algorithm&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/algorithm\">https://en.cppreference.com/w/cpp/header/algorithm</a> </span></p><p><span class=\"reference\">[3a] cppreference.com, “标准库头文件 &lt;algorithm&gt;”. <a href=\"https://zh.cppreference.com/w/cpp/header/algorithm\">https://zh.cppreference.com/w/cpp/header/algorithm</a> </span></p><p><span class=\"reference\">[4] 袁英杰, “Immutability: The Dark Side”. <a href=\"https://www.jianshu.com/p/13cd4c650125\">https://www.jianshu.com/p/13cd4c650125</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “Standard library header &lt;execution&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/execution\">https://en.cppreference.com/w/cpp/header/execution</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “标准库头文件 &lt;execution&gt;”. <a href=\"https://zh.cppreference.com/w/cpp/header/execution\">https://zh.cppreference.com/w/cpp/header/execution</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::reduce”. <a href=\"https://en.cppreference.com/w/cpp/algorithm/reduce\">https://en.cppreference.com/w/cpp/algorithm/reduce</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::reduce”. <a href=\"https://zh.cppreference.com/w/cpp/algorithm/reduce\">https://zh.cppreference.com/w/cpp/algorithm/reduce</a> </span></p><p><span class=\"reference\">[7] Intel, tbb. <a href=\"https://github.com/intel/tbb\">https://github.com/intel/tbb</a> </span></p><p><span class=\"reference\">[8] Ivan Čukić, <em>Functional Programming in C++</em>. Manning, 2019, <a href=\"https://www.manning.com/books/functional-programming-in-c-plus-plus\">https://www.manning.com/books/functional-programming-in-c-plus-plus</a> </span></p><p><span class=\"reference\">[9] Wikipedia, “Fixed-point combinator”. <a href=\"https://en.wikipedia.org/wiki/Fixed-point_combinator\">https://en.wikipedia.org/wiki/Fixed-point_combinator</a> </span></p><p><span class=\"reference\">[10] 吴咏炜, “<em>Y</em> Combinator and C++”. <a href=\"https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/\">https://yongweiwu.wordpress.com/2014/12/14/y-combinator-and-cplusplus/</a> </span></p>","neighbors":{"left":{"article_title":"16 | 函数对象和lambda：进入函数式编程","id":184018},"right":{"article_title":"18 | 应用可变模板和tuple的编译期技巧","id":185899}},"comments":[{"had_liked":false,"id":169547,"user_name":"王小品","can_delete":false,"product_type":"c1","uid":1264741,"ip_address":"","ucode":"174F19F4040C92","user_header":"https://static001.geekbang.org/account/avatar/00/13/4c/65/1782ca15.jpg","comment_is_top":false,"comment_ctime":1578376827,"is_pvip":false,"replies":[{"id":"65787","content":"哈哈，有意思的比喻。以前学过函数式编程？","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578392348,"ip_address":"","comment_id":169547,"utype":1}],"discussion_count":2,"race_medal":0,"score":"190556937851","product_id":100040501,"comment_content":"Y-Combinator被你说高深了。递归就是自己调用自己。lamda表达式想递归，困难在于不知道自己的函数名，怎么办？调用不了自己，难道还调用不了别人。所以lamda表达式调用了Y-Combinator去间接调用自己，而Y-Combinator只不过：一，记录lamda表达式；二，转调lamda表达式。这就好比普京受制于连任时间限制，如果想继续连任，则找个代言人Y-Combinator继任。代言人的唯一作用就是到期传位普京。","like_count":44,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480606,"discussion_content":"哈哈，有意思的比喻。以前学过函数式编程？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578392348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172090,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/7a/38a27e47.jpg","nickname":"蓦然回首","note":"","ucode":"B17658DCFE6402","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345990,"discussion_content":"说的真是太对了！哈哈哈！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611832427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168180,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1578028251,"is_pvip":false,"replies":[{"id":"65332","content":"OK，没啥大问题。<br><br>代码风格要稍微说明一下。你似乎是模拟了库代码的风格，这还是有点风险的。在一般的用户代码里，不应该出现双下划线打头、或者下划线加大写字母打头的标识符——这是给系统保留的。<br><br>详见：<br><br>https:&#47;&#47;zh.cppreference.com&#47;w&#47;cpp&#47;language&#47;identifiers","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578056220,"ip_address":"","comment_id":168180,"utype":1}],"discussion_count":4,"race_medal":0,"score":"23052864731","product_id":100040501,"comment_content":"参考 istream_line_reader 实现的，望老师斧正<br><br>template&lt;typename _InIt, typename _Fun&gt;<br>class filter_view {<br>public:<br>\tclass iterator {  &#47;&#47;  实现  InputIterator  <br>\tpublic:<br><br>\t\tusing iterator_category = input_iterator_tag;<br>\t\tusing value_type = typename _InIt::value_type;<br>\t\tusing difference_type = typename _InIt::difference_type;<br>\t\tusing pointer = typename _InIt::pointer;<br>\t\tusing reference = value_type&amp;;<br><br>\t\titerator(_InIt  _First, _InIt _Last, _Fun f)<br>\t\t\t:_First(_First), _Last(_Last), _fun(f) {<br>\t\t\t++(*this);<br>\t\t}<br><br>\t\treference operator*() const noexcept { return *_Cur; }<br>\t\t<br>\t\tpointer operator-&gt;() const noexcept { return &amp;(*_Cur); }<br><br>\t\titerator&amp; operator++() {<br>\t\t\twhile (_First != _Last &amp;&amp; !_fun(*_First)) {<br>\t\t\t\t_First++;<br>\t\t\t}<br>\t\t\t_Cur = _First;<br>\t\t\tif (_First != _Last) {<br>\t\t\t\t_First++;<br>\t\t\t}<br>\t\t\treturn *this;<br>\t\t}<br><br>\t\titerator operator++(int) {<br>\t\t\titerator temp(*this);<br>\t\t\t++(*this);<br>\t\t\treturn temp;<br>\t\t}<br><br>\t\tbool operator==(const iterator&amp; rhs)<br>\t\t\tconst noexcept<br>\t\t{<br>\t\t\treturn _Cur == rhs._Cur;<br>\t\t}<br>\t\tbool operator!=(const iterator&amp; rhs)<br>\t\t\tconst noexcept<br>\t\t{<br>\t\t\treturn !operator==(rhs);<br>\t\t}<br>\tprivate:<br>\t\t_InIt _First;<br>\t\t_InIt _Last;<br>\t\t_InIt _Cur;<br>\t\t_Fun _fun;<br><br>\t};<br><br>\tfilter_view(_InIt _First, _InIt _Last, _Fun f)<br>\t\t:_First(_First), _Last(_Last), _fun(f) {<br><br>\t}<br><br>\titerator begin() const noexcept {<br>\t\treturn iterator(_First, _Last, _fun);<br>\t}<br><br>\titerator end() const  noexcept {<br>\t\treturn iterator(_Last, _Last, _fun);<br>\t}<br>private:<br>\t_InIt _First;<br>\t_InIt _Last;<br>\t_Fun _fun;<br>};","like_count":5,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480163,"discussion_content":"OK，没啥大问题。\n\n代码风格要稍微说明一下。你似乎是模拟了库代码的风格，这还是有点风险的。在一般的用户代码里，不应该出现双下划线打头、或者下划线加大写字母打头的标识符——这是给系统保留的。\n\n详见：\n\nhttps://zh.cppreference.com/w/cpp/language/identifiers","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578056220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2596026,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","nickname":"chang","note":"","ucode":"594EF8CB4477BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378400,"discussion_content":"若第一个元素匹配，会跳过第一个元素？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623207319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1362403,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","nickname":"三味","note":"","ucode":"A580F715D1CC96","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":127000,"discussion_content":"贴一下我的实现,实现盖楼：\n#include <iostream>\n#include <vector>\n\ntemplate <typename It, typename F>\nclass filter_view {\npublic:\n\n\tclass iterator {\n\tpublic:\n\t\tusing difference_type = ptrdiff_t;\n\t\tusing iterator_category = std::forward_iterator_tag;\n\t\tusing value_type = std::decay_t<decltype(*std::declval<It>())>;\n\t\tusing pointer = const value_type *;\n\t\tusing reference = const value_type&amp;;\n\n\n\t\texplicit iterator(It beg, It end, F f) \n\t\t\t: _itr(beg), _end(end), _f(f) {\n\t\t\twhile (_itr != _end &amp;&amp; !_f(*_itr))\n\t\t\t\t++_itr;\n\t\t}\n\n\t\tconst value_type&amp; operator*() const { return *_itr; }\n\n\t\tconst value_type* operator->() const { return &amp;(*_itr); }\n\n\t\t// ++iterator\n\t\titerator&amp; operator++() {\n\t\t\tassert(_itr != _end);\n\t\t\tnext();\n\t\t\treturn *this;\n\t\t}\n\n\t\t// iterator++\n\t\titerator operator++(int) {\n\t\t\tassert(_itr != _end);\n\t\t\titerator tmp = *this;\n\t\t\tnext();\n\t\t\treturn tmp;\n\t\t}\n\n\t\tbool operator==(const iterator&amp; rhs) const { return _itr == rhs._itr; }\n\n\t\tbool operator!=(const iterator&amp; rhs) const { return _itr != rhs._itr; }\n\n\tprivate:\n\t\tvoid next() {\n\t\t\t++_itr;\n\t\t\twhile (_itr != _end &amp;&amp; !_f(*_itr)) \n\t\t\t\t++_itr;\n\t\t}\n\n\t\tIt _itr;\n\t\tIt _end;\n\t\tF _f;\n\t};\n\n\texplicit filter_view(It beg, It end, F f) : _beg(beg, end, f), _end(end, end, f) {}\n\n\titerator begin() const { return _beg; }\n\n\titerator end() const { return _end; }\n\nprivate:\n\titerator _beg;\n\titerator _end;\n};\n\nint main()\n{\n\tstd::vector<int> v = {1,1,2,2,3,3,4,4,5,5}; \n\tfor (int i=0; i<v.size(); ++i) {\n\t\tfor (int j=i; j<v.size(); ++j) {\n\t\t\tauto beg = std::next(v.begin(), i);\n\t\t\tauto end = std::next(v.begin(), j);\n\t\t\tauto&amp;&amp; fv = filter_view(beg, end, [](int x) { return x%2 == 0; }); \n\t\t\tstd::cout << &#34;( &#34;;\n\t\t\tstd::copy(beg, end, std::ostream_iterator<int>(std::cout, &#34; &#34;));\n\t\t\tstd::cout << &#34;) => [ &#34;;\n\t\t\tstd::copy(fv.begin(), fv.end(), std::ostream_iterator<int>(std::cout, &#34; &#34;));\n\t\t\tstd::cout << &#3","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578558212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188222,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","nickname":"罗 乾 林","note":"","ucode":"D0406F95176ABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":116319,"discussion_content":"收到，感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578059795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286146,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1015324,"ip_address":"","ucode":"2DF8932F07E24F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/1c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1617169228,"is_pvip":false,"replies":[{"id":"104028","content":"首先，按你目前代码的写法（非virtual方法），把create函数的返回值改成 Base 和 Derived 是可以工作的。即，如果能做到静态多态的话，各个函数返回实际类型即可。<br><br>可是，如果按照一般的做法，Base 加上虚析构，create 标成 virtual 的话，情况就不一样了。虚函数必须返回同样的类型，或者如果是指针&#47;引用类型的话，按“协变”的要求，覆写的虚函数返回的指针&#47;引用是被覆写的虚函数的返回类型的子类。因为虚函数被调用时，编译器是不知道实际调用的是哪个函数，如果返回非指针&#47;引用的子类对象的话，编译器连怎么拷贝、移动这个对象都不知道了……","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1617297025,"ip_address":"","comment_id":286146,"utype":1}],"discussion_count":6,"race_medal":0,"score":"10207103820","product_id":100040501,"comment_content":"吴老师，为什么c++不能在返回值优化，支持把rvalue通过move构造给一个lvalue引用。我想实现模板中的协变，函数返回local variable，只能通过声明返回值类型为引用和指针才能协变支持返回值多态。把一个生命周期短的variable自动move给返回值不是应该的吗？这个场景在工厂场景下应该很常见吧。<br>class Base{<br>}<br>class Derive : public Base {}<br><br>class Factory {<br> Bae &amp; create(){<br> return Base();<br>}<br>class SubFactory : public Factory{<br> Base &amp; create (){<br>    return Derive();<br>}<br>}<br>这里的返回值类型也有可能是泛型参数，现在看来只能用智能指针包一层，通过move构造返回，这看起来不太方便。<br>}","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517882,"discussion_content":"首先，按你目前代码的写法（非virtual方法），把create函数的返回值改成 Base 和 Derived 是可以工作的。即，如果能做到静态多态的话，各个函数返回实际类型即可。\n\n可是，如果按照一般的做法，Base 加上虚析构，create 标成 virtual 的话，情况就不一样了。虚函数必须返回同样的类型，或者如果是指针/引用类型的话，按“协变”的要求，覆写的虚函数返回的指针/引用是被覆写的虚函数的返回类型的子类。因为虚函数被调用时，编译器是不知道实际调用的是哪个函数，如果返回非指针/引用的子类对象的话，编译器连怎么拷贝、移动这个对象都不知道了……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617297025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364380,"discussion_content":"上次的回答还是有点问题，没有抓住要点。更新了一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617460427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1015324,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/1c/abb7bfe3.jpg","nickname":"Frank","note":"","ucode":"2DF8932F07E24F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":364734,"discussion_content":"这里的工厂函数返回的是子类的引用，但是按照c++的语义，引用只能指向一个左值才能长期使用，工厂函数返回引用会在返回时被析构，不支持右值的那种返回值优化移动语义。这样要做一个抽象化的工厂函数就不太方便，我希望顶层抽象一个接口，至于返回类型应该由子类决定。不知道智能指针能不能支持协变，即虚函数返回shared_ptr<Base>，子类返回shared_pt r<Derived>。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617588645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364380,"ip_address":""},"score":364734,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1015324,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/1c/abb7bfe3.jpg","nickname":"Frank","note":"","ucode":"2DF8932F07E24F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":364942,"discussion_content":"\n我知道你要做啥啊。回答的另一个角度就是，从生命周期管理的角度，你原先说的做不到。\n\n智能指针协变从接口的角度是不行的。但如果 B 继承 A 的话，你可以把 shared_ptr<B> 在一个接口声明为 shared_ptr<A> 的函数里返回。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617669488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364734,"ip_address":""},"score":364942,"extra":""},{"author":{"id":1015324,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/1c/abb7bfe3.jpg","nickname":"Frank","note":"","ucode":"2DF8932F07E24F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":365019,"discussion_content":"了解了，谢谢吴老师。看来c++做高度抽象的协变逆变还是比较困难的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617686883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":364942,"ip_address":""},"score":365019,"extra":""}]}]},{"had_liked":false,"id":168059,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1578009155,"is_pvip":true,"replies":[{"id":"65270","content":"map-reduce 是一种方法，已经有很久了。在 C++ 里的直接对应是 transform 和 accumulate。TBB 见参考资料 [7]。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578015418,"ip_address":"","comment_id":168059,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10167943747","product_id":100040501,"comment_content":"请问老师，map和reduce.那是最新的语句吗？还是有第三方库？那个TBB？","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480123,"discussion_content":"map-reduce 是一种方法，已经有很久了。在 C++ 里的直接对应是 transform 和 accumulate。TBB 见参考资料 [7]。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578015418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283940,"user_name":"geek","can_delete":false,"product_type":"c1","uid":2401422,"ip_address":"","ucode":"FF0845140D72A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","comment_is_top":false,"comment_ctime":1615989156,"is_pvip":true,"replies":[{"id":"103111","content":"看一下“加餐”里我的参考实现吧。你的这个问题还不少。不够通用，而且前置和后置++的理解反了，返回类型也不对——前置应返回引用，后置返回对象。后置++的参数是假的，永远不需要传递，也不应该给出名字。你写 it++; 时，编译器会自动调用 it.operator++(int)（示意，不是合法代码）。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1616154429,"ip_address":"","comment_id":283940,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5910956452","product_id":100040501,"comment_content":"课后思考的一种实现，请老师指正一下其中存在的问题。<br>template &lt;typename T = std::vector&lt;int&gt;&gt;<br>    class filter_view {<br>    public:<br>        filter_view(){}<br>        filter_view(typename T::iterator begin, typename T::iterator end, std::function&lt;bool(int)&gt; func):begin_(begin),end_(end),func_(func){}<br><br>        class iterator {<br>        public:<br>            iterator(typename T::iterator end):end_(end){}<br>            iterator(typename T::iterator begin, std::function&lt;bool(int)&gt; func):begin_(begin), func_(func) {}<br><br>            int operator*() {<br>                if (!func_(*begin_)) return 0;<br>                return *begin_;<br>            }<br><br>            int operator-&gt;() {<br>                if (!func_(*begin_)) return 0;<br>                return *begin_;<br>            }<br><br>            iterator operator++(int n) {<br>                ++begin_;<br>                return *this;<br>            }<br><br>            iterator operator++() {<br>                iterator t = *this;<br>                operator++(0);<br>                return t;<br>            }<br><br>            bool operator==(const iterator&amp; o) const {<br>                return begin_ == o.begin_;<br>            }<br><br>            bool operator!=(const iterator&amp; o) const {<br>                return !(begin_ == o.end_);<br>            }<br>        private:<br>            typename T::iterator begin_;<br>            typename T::iterator end_;<br>            std::function&lt;bool(int)&gt; func_;<br>        };<br><br>        iterator begin() {<br>            if (!func_) {<br>                throw std::logic_error(&quot;func_ is null&quot;);<br>            }<br>            return iterator(begin_,func_);<br>        }<br><br>        iterator end() {<br>            if (!func_) {<br>                throw std::logic_error(&quot;func_ is null&quot;);<br>            }<br>            return iterator(end_);<br>        }<br><br>    private:<br>        typename T::iterator begin_;<br>        typename T::iterator end_;<br>        std::function&lt;bool(int)&gt; func_;<br>    };","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517186,"discussion_content":"看一下“加餐”里我的参考实现吧。你的这个问题还不少。不够通用，而且前置和后置++的理解反了，返回类型也不对——前置应返回引用，后置返回对象。后置++的参数是假的，永远不需要传递，也不应该给出名字。你写 it++; 时，编译器会自动调用 it.operator++(int)（示意，不是合法代码）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616154429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2401422,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/NyFOEueITjaGLpakMEuWAqVQjo1uDIXlpDdpCxXGfaWiaXzibLQ3WgOFCe8D9FvCmyjsGT7jDsLUbkt8jt2aVs9g/132","nickname":"geek","note":"","ucode":"FF0845140D72A9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359269,"discussion_content":"好的，😅","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616154583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316361,"user_name":"常振华","can_delete":false,"product_type":"c1","uid":2062252,"ip_address":"","ucode":"D61B40E1CCEFD5","user_header":"","comment_is_top":false,"comment_ctime":1634286745,"is_pvip":false,"replies":[{"id":"114624","content":"可读性问题，仁者见仁，智者见智。我不认为函数式编程一定更优越，但有些场景，函数式写法就是有优势的（反过来的场合当然也有）。C++的多范式，就是允许你在同一程序里根据需求自由使用不同的范式。<br><br>说函数式编程代码简洁性不如直接命令式，我想我开头的例子已经可以反驳这个观点了。函数式风格通常代码还容易重用，这也是特点之一。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1634380401,"ip_address":"","comment_id":316361,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1634286745","product_id":100040501,"comment_content":"函数式编程在并发场合下的确有优势，但是普通应用，比如递归，实现起来比命令式复杂那么多，可读性更差，意义何在。而且函数式编程的代码简洁性不如直接命令式+注释","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528369,"discussion_content":"可读性问题，仁者见仁，智者见智。我不认为函数式编程一定更优越，但有些场景，函数式写法就是有优势的（反过来的场合当然也有）。C++的多范式，就是允许你在同一程序里根据需求自由使用不同的范式。\n\n说函数式编程代码简洁性不如直接命令式，我想我开头的例子已经可以反驳这个观点了。函数式风格通常代码还容易重用，这也是特点之一。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634380401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296869,"user_name":"chang","can_delete":false,"product_type":"c1","uid":2596026,"ip_address":"","ucode":"594EF8CB4477BD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/2ibrq71Y5Ww3KDRibDxF1gt9YDEPuZkv4ITHEP1u4vvjpPDukkLoK4ngQy1hKKzccnsicLkUAda7sPpibR6Kyb0cfQ/132","comment_is_top":false,"comment_ctime":1623207186,"is_pvip":false,"replies":[{"id":"107984","content":"OK，没什么大问题。<br><br>要完全满足将来的概念检查的话，最好再加上后置 ++ 和 -&gt; 的实现。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1623478844,"ip_address":"","comment_id":296869,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1623207186","product_id":100040501,"comment_content":"我也贴下我的实现，参考了前面一些同学的，望老师指正不足之处：<br><br>template&lt;typename It, typename Comp&gt;<br>class filter_view {<br>public:<br>    class iterator {<br>    public:<br>        &#47;&#47;支持内置指针<br>        using value_type = typename std::iterator_traits&lt;It&gt;::value_type;<br>        using difference_type = typename std::iterator_traits&lt;It&gt;::difference_type;<br>        using pointer = value_type*;<br>        using reference = value_type&amp;;<br>        using iterator_category = std::input_iterator_tag;<br><br>        iterator(It it, It e, Comp cmp) : it_(it), e_(e), cmp_(cmp) {<br>            skipNoMatch();<br>        }<br><br>        iterator&amp; operator++() {<br>            ++it_;<br>            skipNoMatch();<br>            return *this;<br>        }<br><br>        auto operator*() {<br>            return *it_;<br>        }<br><br>        bool operator==(const iterator &amp;rhs) const {<br>            return it_ == rhs.it_;<br>        }<br><br>        bool operator!=(const iterator &amp;rhs) const {<br>            return !(*this == rhs);<br>        }<br><br>    private:<br>        void skipNoMatch() {<br>            while (it_ != e_ &amp;&amp; !cmp_(*it_)) {<br>                ++it_;<br>            }<br>        }<br><br>    private:<br>        It it_;<br>        It e_;<br>        Comp cmp_;<br>    };<br><br>    filter_view(It b, It e, Comp cmp) : b_(b), e_(e), cmp_(cmp) {}<br><br>    iterator begin() const {<br>        return iterator(b_, e_, cmp_);<br>    }<br><br>    iterator end() const {<br>        return iterator(e_, e_, cmp_);<br>    }<br><br>private:<br>    It b_;<br>    It e_;<br>    Comp cmp_;<br>};","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521620,"discussion_content":"OK，没什么大问题。\n\n要完全满足将来的概念检查的话，最好再加上后置 ++ 和 -&amp;gt; 的实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623478844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286931,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1015324,"ip_address":"","ucode":"2DF8932F07E24F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/1c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1617687112,"is_pvip":false,"replies":[{"id":"104253","content":"对不起，我目前没时间看这么复杂的代码。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1617801600,"ip_address":"","comment_id":286931,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1617687112","product_id":100040501,"comment_content":"吴老师，我重写了map-reduce逻辑(lazy evaluation)，但是目前的flatten功能输出有点混乱，我暂时没排查出结果。能帮我看下吗？https:&#47;&#47;github.com&#47;franklucky001&#47;fp-map-reduce&#47;blob&#47;master&#47;main.cpp","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518135,"discussion_content":"对不起，我目前没时间看这么复杂的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617801600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015324,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/1c/abb7bfe3.jpg","nickname":"Frank","note":"","ucode":"2DF8932F07E24F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365755,"discussion_content":"好吧😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617875955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286161,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1015324,"ip_address":"","ucode":"2DF8932F07E24F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/1c/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1617172845,"is_pvip":false,"replies":[{"id":"104029","content":"这跟前面的问题本质上是一回事吧？所以，你要么使用静态多态，这样所有的类型必须能够在编译时分析出来；要么使用动态多态，必须把对象放堆上，并且对象有虚析构函数。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1617297118,"ip_address":"","comment_id":286161,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617172845","product_id":100040501,"comment_content":"吴老师， 我想实现类似rust的lazy evaluation特征的map reduce,代码https:&#47;&#47;github.com&#47;franklucky001&#47;template_programming&#47;blob&#47;master&#47;collection&#47;iterator.hpp<br>但是模板中，不方便实现协变，声明成引用局部变量会析构，begin和end虚函数必须声明成智能指针才能通过move构造返回局部变量,有没有更好的方式。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517889,"discussion_content":"这跟前面的问题本质上是一回事吧？所以，你要么使用静态多态，这样所有的类型必须能够在编译时分析出来；要么使用动态多态，必须把对象放堆上，并且对象有虚析构函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617297118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269659,"user_name":"Geek_845be1","can_delete":false,"product_type":"c1","uid":1644657,"ip_address":"","ucode":"2B83B62C9D9C5D","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDH0RbXvDGVoyRtxs3kLmwSmibqqic4EYYwSH12KqsrrKgpGic7cZXfsicpDMShFTAIT6p3jTJ3ypKzg/132","comment_is_top":false,"comment_ctime":1608730261,"is_pvip":false,"replies":[{"id":"97794","content":"使用引用要小心生命周期问题……到下一个 } 引用指向的对象就被销毁了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1608768602,"ip_address":"","comment_id":269659,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608730261","product_id":100040501,"comment_content":"用 std::function 保存 lambda，通过引用捕获，可以很方便的实现了lambda 递归。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512348,"discussion_content":"使用引用要小心生命周期问题……到下一个 } 引用指向的对象就被销毁了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608768602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231103,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1593583298,"is_pvip":false,"replies":[{"id":"85390","content":"就是不修改变量的内容，前面一种含义。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1593650853,"ip_address":"","comment_id":231103,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593583298","product_id":100040501,"comment_content":"吴老师，您好。<br>此讲内容和之前内容比较，颇有些道与术的分别。<br>个人感觉函数式编程和ADT范式强调的isolation有几份神似。<br>您在文中的几条建议，我有些困惑地方，向您请教：<br>第二条建议：”使用有意义的变量，但尽量不要去修改变量内容——变量的修改非常容易导致程序员的思维错误“；请问您指的是抽象层面上”不要改变变量的含义&#47;意义“？亦或是具体层面上”不要改变传入参数以及环境变量的内容“？从上下文来看似乎是后者，但这样一来好像和第三条建议有些重复了。<br>请您指教，多谢。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500158,"discussion_content":"就是不修改变量的内容，前面一种含义。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593650853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226207,"user_name":"易轻尘","can_delete":false,"product_type":"c1","uid":1136684,"ip_address":"","ucode":"0D0CB9D6D45A70","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/2c/92c7ce3b.jpg","comment_is_top":false,"comment_ctime":1591991574,"is_pvip":true,"replies":[{"id":"83359","content":"不一样的做法，也挺好。<br><br>不过，再花点力气，是可以去掉对 std::function 的使用的。这可以提升提点效率。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1592066393,"ip_address":"","comment_id":226207,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591991574","product_id":100040501,"comment_content":"没有看istream_line_reader前，个人的实现，有点丑陋：<br><br>template&lt;typename InputIt, typename Pred&gt;<br>auto filter_view(InputIt a, InputIt b, Pred pred) {<br>    struct {<br>        InputIt _begin, _end;<br>        function&lt;bool(decltype(*_begin))&gt; _pred;<br>        struct iterator {<br>            InputIt _it, _end;<br>            function&lt;bool(decltype(*_it))&gt; _pred;<br>            iterator(InputIt it, InputIt e, decltype(_pred) p):_it(it), _end(e), _pred(p){}<br>            bool operator != (const iterator&amp; other) {return _it != other._it;}<br>            bool operator == (const iterator&amp; other) {return _it == other._it;}<br><br>            auto operator*() {return *_it;}<br>            auto operator-&gt;() {return &amp;(*_it);}<br><br>            iterator&amp; operator ++ () {<br>                do {<br>                    if(_it == _end) break;<br>                    ++ _it;<br>                    if(_it == _end || _pred(*_it)) break;<br>                } while(true);<br>                return *this;<br>            }<br>        };<br>        <br>        iterator begin() {<br>            while(_begin != _end &amp;&amp; !_pred(*_begin))<br>                ++ _begin;<br>            return iterator(_begin, _end, _pred);<br>        }<br>        iterator end() {<br>            return iterator(_end, _end, _pred);<br>        }<br>    } object;<br>    object._begin = a;<br>    object._end = b;<br>    object._pred = [pred](decltype(*a) x){return pred(x);};<br>    return object;<br>}","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498148,"discussion_content":"不一样的做法，也挺好。\n\n不过，再花点力气，是可以去掉对 std::function 的使用的。这可以提升提点效率。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592066393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177372,"user_name":"Leon📷","can_delete":false,"product_type":"c1","uid":1219496,"ip_address":"","ucode":"B9BBD1EFAAE5A2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/a8/6a391c66.jpg","comment_is_top":false,"comment_ctime":1581379818,"is_pvip":false,"replies":[{"id":"68873","content":"啊，现在是因为手机屏幕太小……😁<br><br>读到第 21 讲你就自然明白了。可以先去读一下，那讲是独立的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1581398661,"ip_address":"","comment_id":177372,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581379818","product_id":100040501,"comment_content":"老师，我问下，文章中返回类型都是单独一行，以前是电脑屏幕太小写不下，所以很多老代码都这么写，现在难道又重新流行这种写法了吗","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483404,"discussion_content":"啊，现在是因为手机屏幕太小……😁\n\n读到第 21 讲你就自然明白了。可以先去读一下，那讲是独立的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581398661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174710,"user_name":"微风漂过","can_delete":false,"product_type":"c1","uid":1509168,"ip_address":"","ucode":"4F3E37C1E2FFF5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/JGPabHDickBjMJwVoJ7ZRGiaT21BibxvCJ9DR9Gvn3G1iazHQPTJQtkWwfFssYfGJsPahEB7sOnXScibkrsr4gx6LeA/132","comment_is_top":false,"comment_ctime":1580358320,"is_pvip":false,"replies":[{"id":"67936","content":"哦，这个是我写的，不是标准库里的。<br><br>源代码在第 7 讲讲解了。<br><br>https:&#47;&#47;github.com&#47;adah1972&#47;nvwa&#47;blob&#47;master&#47;nvwa&#47;istream_line_reader.h","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1580397644,"ip_address":"","comment_id":174710,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580358320","product_id":100040501,"comment_content":"istream_line_reader 的实现在哪里找？cppreference里面没有搜到。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482497,"discussion_content":"哦，这个是我写的，不是标准库里的。\n\n源代码在第 7 讲讲解了。\n\nhttps://github.com/adah1972/nvwa/blob/master/nvwa/istream_line_reader.h","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580397644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1509168,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/JGPabHDickBjMJwVoJ7ZRGiaT21BibxvCJ9DR9Gvn3G1iazHQPTJQtkWwfFssYfGJsPahEB7sOnXScibkrsr4gx6LeA/132","nickname":"微风漂过","note":"","ucode":"4F3E37C1E2FFF5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156828,"discussion_content":"好吧，谢谢。断断续续看的，前面的快忘了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580397982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170570,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1578634595,"is_pvip":false,"replies":[{"id":"66133","content":"性能。不用引用，对于比较重（比如，有较多按值捕获）的函数对象，拷贝的开销就比较大了。用 Fun&amp;&amp; 和 std::forward，就是要把拷贝尽可能转变成移动。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578667136,"ip_address":"","comment_id":170570,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578634595","product_id":100040501,"comment_content":"关于这个y_combinator, 代码中有很多我不太理解的：<br>1. 为什么lambda函数作为参数传递的时候，都是Fun&amp;&amp;？我实际测试直接用Fun，对于当前代码没什么问题，直接用Fun不好么？；<br>2. 关于forward，题目中所有带有forward的地方，我都直接替换为不带forward的方式，编译和运行也没有什么问题。这里的forward作用究竟是怎样的？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481019,"discussion_content":"性能。不用引用，对于比较重（比如，有较多按值捕获）的函数对象，拷贝的开销就比较大了。用 Fun&amp;amp;&amp;amp; 和 std::forward，就是要把拷贝尽可能转变成移动。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578667136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170260,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1578558056,"is_pvip":false,"replies":[{"id":"66132","content":"功能看起来没啥问题。嗯，太长，所以贴到别的留言下去了，还是有点怪怪的。<br><br>还是要提醒，在一般的用户代码里，不应该出现双下划线打头、或者下划线加大写字母打头的标识符——这是给系统保留的。<br><br>详见：<br><br>https:&#47;&#47;zh.cppreference.com&#47;w&#47;cpp&#47;language&#47;identifiers","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578667018,"ip_address":"","comment_id":170260,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578558056","product_id":100040501,"comment_content":"这一节是我耗时最长的一节。。因为来回翻阅迭代器那一节。。<br>写了个std::copy(fv.begin(), fv.end(), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;)); 结果编译失败。。查了半天。。因为没定义pointer和reference类型。。<br>还有就是，之前的章节看得不仔细，看别人答案觉得好奇怪，为什么一上来要++(*this)。。后来对比自己的实现，我是按照forward_iterator_tag来定义的，所以写法有些不同。代码比较长。。我还是贴一下，放到留言的留言中吧，不然太长了。自己测试没啥问题，不过不保证。。没问题。。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480910,"discussion_content":"功能看起来没啥问题。嗯，太长，所以贴到别的留言下去了，还是有点怪怪的。\n\n还是要提醒，在一般的用户代码里，不应该出现双下划线打头、或者下划线加大写字母打头的标识符——这是给系统保留的。\n\n详见：\n\nhttps://zh.cppreference.com/w/cpp/language/identifiers","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578667018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169638,"user_name":"じJRisenづジ","can_delete":false,"product_type":"c1","uid":1401105,"ip_address":"","ucode":"87EB43D4B0B19C","user_header":"https://static001.geekbang.org/account/avatar/00/15/61/11/85386508.jpg","comment_is_top":false,"comment_ctime":1578395214,"is_pvip":false,"replies":[{"id":"65867","content":"跟学外语一样，基本诀窍就是多读多写。文档现在都很齐全的，但除了极少数天才式的人物，看了不用就会忘掉吧。而且，没真正用过，碰到一些坑，看了的理解都不一定正确。<br><br>另外就是看书了。书比文档更有体系性，更适合完整的学习，需要投入整块的时间。标准库的书，应该就是 Nicolai Josuttis 的那本 The C++ Standard Library 第二版了。中文版刚查了一下，侯捷译，一千多页。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578440020,"ip_address":"","comment_id":169638,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1578395214","product_id":100040501,"comment_content":"#include &lt;iostream&gt;<br>#include &lt;chrono&gt;<br>#include &lt;execution&gt;<br>#include &lt;numeric&gt;<br>#include &lt;vector&gt; 老师怎么学习库知识？ 提点思路","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480648,"discussion_content":"跟学外语一样，基本诀窍就是多读多写。文档现在都很齐全的，但除了极少数天才式的人物，看了不用就会忘掉吧。而且，没真正用过，碰到一些坑，看了的理解都不一定正确。\n\n另外就是看书了。书比文档更有体系性，更适合完整的学习，需要投入整块的时间。标准库的书，应该就是 Nicolai Josuttis 的那本 The C++ Standard Library 第二版了。中文版刚查了一下，侯捷译，一千多页。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578440020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1401105,"avatar":"https://static001.geekbang.org/account/avatar/00/15/61/11/85386508.jpg","nickname":"じJRisenづジ","note":"","ucode":"87EB43D4B0B19C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124634,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578446010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168078,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1578011602,"is_pvip":false,"replies":[{"id":"65269","content":"Y Combinator 只是好玩展示一下，刺激一下大家的好奇心。要进一步了解，是需要看参考资料，或者其他中英文资料的。你说的这篇我之前没看过，内容也不错。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578014020,"ip_address":"","comment_id":168078,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578011602","product_id":100040501,"comment_content":"Y-Combinator主要用到了一个不动点理论，刘未鹏老师的《康托尔、哥德尔、图灵——永恒的金色对角线》这篇文章里面说的相对详细一些。玩过一段函数式...就只有haskell那段代码看懂了😂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480129,"discussion_content":"Y Combinator 只是好玩展示一下，刺激一下大家的好奇心。要进一步了解，是需要看参考资料，或者其他中英文资料的。你说的这篇我之前没看过，内容也不错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578014020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}