{"id":713611,"title":"20｜JMM：如何打造一个线程安全的程序？","content":"<p>你好，我是康杨。</p><p>在编程过程中，你有没有遇到过在运行多线程程序时想用共享变量来通讯，却发现程序结果和预期不一致的情况？这个常见的问题就是多线程编程的难点，涉及<strong>内存可见性和重排</strong>等问题。今天我们就来解决这些问题，并探讨JVM如何通过它的内存模型JMM来解决它们。</p><h2>可见性问题</h2><p>第一个问题出现在处理器和内存之间。现代电脑系统中，处理器速度很快，内存的读写速度却远远不能比肩。为了解决这种矛盾，引入了高速缓存，处理器将计算所需数据复制到缓存，从而加快运算速度。然而，这也引发了缓存的一致性问题，也就是说，在多处理器系统里，如果每个处理器都同时使用相同的内存，那么它们的缓存数据可能会出现差异。</p><p>处理器必须按照一些协议进行同步操作，在读写时维持缓存一致性。这里就涉及到内存可见性问题，也就是<strong>一个线程修改的状态能够即时在其他线程中可见</strong>。</p><h2>重排问题</h2><p>我们日常写的代码，在实际运行之前，都会经过JVM及底层CPU等各种优化，来达到最优的执行性能。但是这种优化都是基于单线程考虑的优化，如果你的程序是以多线程的方式运行，反而很容易引发各种问题。所以<strong>对于多线程的程序，知道JVM实际进行了哪些优化非常重要。</strong></p><p>指令序列从源代码到实际执行的过程可能会经历以下三种重新排序。</p><!-- [[[read_end]]] --><h3>编译器优化的重排</h3><p>JVM的编译器有可能在保持单线程原有含义的同时，对代码的运作流程进行修正，从而提升运行效率。</p><p>示例代码：</p><pre><code class=\"language-java\">public class CompilerOptimizationExample {\n&nbsp;\nprivate static int a =0;\nprivate static boolean flag = false;\n\npublic static void main(String[] args) throws InterruptedException {\n&nbsp;\nThread thread1= new Thread(()-&gt;{\na =1;\nflag = true;\n});\nThread thread2= new Thread(()-&gt;{\nif (flag){\nSystem.out.println(\"a =\"+ a);\n}\n});\nthread1.start();\n&nbsp;\nthread2.start();\n&nbsp;\nthread1.join();\nthread2.join();\n}\n}\n</code></pre><p>在这个例子中，编译器可能会把 <code>a =1</code> 和 <code>flag = true</code> 的执行顺序进行重排，也就是先执行 <code>flag = true</code> 再执行 <code>a =1</code>。这种重排可能导致线程2在执行 <code>if (flag)</code> 时, <code>flag</code> 已经为true，但是 <code>a</code> 还没被赋值为1，导致输出的结果不符合预期。</p><h3>指令并行的重排</h3><p>指令并行重排属于CPU优化的范畴，对于不存在数据前后依赖的情况，CPU可能会调整指令的执行，将多条指令重叠执行。你可以看一下示例代码。</p><pre><code class=\"language-java\">public class InstructionReorderingExample {\n&nbsp;\nprivate static int a =0;\nprivate static boolean flag = false;\npublic static void main(String[] args) throws InterruptedException {\n&nbsp;\nThread thread1= new Thread(()-&gt;{\na =1;\nflag = true;\n});\nThread thread2= new Thread(()-&gt;{\nwhile (!flag);\nSystem.out.println(\"a =\"+ a);\n});\nthread1.start();\nthread2.start();\nthread1.join();\nhread2.join();\n}\n}\n</code></pre><p>在这个例子中，指令并行可能导致线程2在执行 <code>while (!flag)</code> 的时候，由于指令重排，<code>flag</code> 已经为true，但是 <code>a</code> 的值还没有被刷新到共享内存中，导致输出的结果不符合预期。</p><h3>内存系统的重排</h3><p>因为处理器利用了缓存以及读写缓冲区，所以负载和保存的任务有可能会混乱地进行。这种重新排序可能会使内存与缓存数据同步时间产生偏差。</p><pre><code class=\"language-java\">public class MemoryReorderingExample {\n&nbsp;\nprivate static boolean flag = false;\nprivate static int result =0;\npublic static void main(String[] args) throws InterruptedException {\nThread writerThread = new Thread(()-&gt;{\nresult =1;\nflag = true;\n});\nThread readerThread = new Thread(()-&gt;{\nif (flag){\nSystem.out.println(\"Result:\"+ result);\n}\n});\nwriterThread.start();\nreaderThread.start();\nwriterThread.join();\nreaderThread.join();\n}\n}\n</code></pre><p>在这个例子中，由于处理器的缓存，在线程2执行 <code>if (flag)</code> 时，<code>flag</code> 已经为true，但是由于缓存同步的时间差，<code>result</code> 的值可能还没有被刷新到缓存中，导致输出的结果不符合预期。</p><h2>JMM</h2><p>Java内存模型是为了解决这些问题而设计的线程安全的解决方案。它是JVM提供的一种抽象概念，描述了多线程之间如何协同工作以及如何访问和改变共享数据。它定义了Java程序和虚拟机之间的互动规则，确保程序在多线程环境下具有一致的内存可见性和操作顺序。</p><p>我们先来了解下JMM的一些基本概念。</p><h3>主内存和工作内存</h3><p>被称为共享记忆的主内存是各个进程可以共同使用的内存空间，而每一个进程都有其独立的工作区，用来保存运行过程中的各种信息和运算成果。当某个进程对某一变量进行读取或修改操作的时候，需要先把相关数据从主存搬到工作区，完成后又需要把改动后的内容重新拷贝回主存。</p><h3>内存可见性</h3><p>内存可见性是指在不同的线程间对相同的变量值的看法。当一个线程更改了共享变量的数值，另一个线程能否立即察觉到这个新的变量值，这就是所谓的内存可见性问题。</p><h3>重排序</h3><p>重排序是指编译器和处理器在对程序进行优化时，为了提高程序的运行速度，可能会调整程序的执行顺序。但是，因为程序执行顺序的改变可能会对程序的正确性造成影响，所以编译器和处理器在进行重排序时的时候，必须遵循一定的规则。</p><h3>同步</h3><p>同步是指通过加锁等方式来保证程序在多线程环境下的正确性。常见的同步手段包括Synchronized关键字、Lock接口、Volatile变量和原子变量等。</p><h3>happens-before关系</h3><p>happens-before关系是指在多线程环境下操作之间的一种关系，可以保证程序在多线程环境下的正确性。JVM中有多种语义规则，如线程锁定解锁规则、Volatile变量规则等都是happens-before关系，这些规则可以让程序员不再需要过多地考虑内存可见性问题。</p><h2>JMM的基本原理</h2><p>Java内存模型针对变量提出了一些基本规则，包括3个方面。</p><ol>\n<li>线程间通信必须经过主内存</li>\n</ol><p>Java内存模型规定，线程之间的通信必须经过主内存。在多线程系统中，各个线程都有自身实际的任务寄存器，所以它们对主寄存器进行的数据变量运算需要保持同步。当一个线程修改了共享变量的值时，必须确保这个变量的最新值能够立即对其他线程可见。</p><ol start=\"2\">\n<li>变量操作必须在工作内存中进行</li>\n</ol><p>根据Java内存模式的规则，任何变量动作都应该在工作存储器中执行，不能直接对主存储器执行动作。每个线程在读写、赋值和修改数据变量的时候，都要求在自身的工作内存中完成运算，并把结果并发到主程序。</p><ol start=\"3\">\n<li>指令重排等优化必须遵循规则</li>\n</ol><p>Java内存模型还明确指出，在执行如命令重排等优化任务的时候，编辑器和管理器需要遵循一些规范。指令执行的顺序必须符合程序在编写时的顺序，不能出现因优化而导致程序运行结果不正确的情况。</p><h2>JMM下Java内存间的交互操作</h2><ol>\n<li>内存交互基本操作</li>\n</ol><p>在Java的内存模型中，有8种操作方式来保障主内存和工作内存数据的一致性。</p><p><img src=\"https://static001.geekbang.org/resource/image/16/ff/16093ab854c0be77cb01e999fc2yy6ff.jpg?wh=2076x1006\" alt=\"\"></p><ol start=\"2\">\n<li>内存交互基本规则</li>\n</ol><p>根据Java内存模型的规定，执行以下9条规则才能进行上述的8种操作。</p><ul>\n<li>读取和载入操作必须按顺序执行，存储和写入操作也必须按顺序执行。</li>\n<li>读取操作和载入操作、存储操作和写入操作必须配对出现，不允许单独出现。</li>\n<li>在工作程序中修改变量后，需要把它同步运行到主程序。</li>\n<li>没办法把工作内存中的变量无意识地同步到主内存。</li>\n<li>只有在进行载入或赋值操作后，某个数据变量才能被使用或存储。不可以直接在工作存储器中使用未经初始化的数据变量。</li>\n<li>只有在同一时刻，一个线程才能对一个变量进行锁定，并且必须执行相同的解锁操作才能完成锁定。</li>\n<li>在对某个变量执行锁定操作之后，工作内存里的这个变量值将被移除，这就需要我们再次进行载入或赋值。</li>\n<li>一个变量没有被锁定时不允许进行解锁操作，也不允许解锁其他线程锁定的变量。</li>\n<li>在执行解锁任务之前，必须把参数同步到主内存。</li>\n</ul><p>这些规则确保了多线程访问共享变量时的线程安全，并保证了数据的一致性。</p><h2>JMM的解决方案</h2><p>除了上述这些基础的规则，JMM也提供了一些实现这个规则的解决方案。</p><ul>\n<li>Synchronized关键字：Java语言中最基本的同步手段，它可以保证同一时刻只有一个线程会执行临界区内的代码，从而避免了多线程访问共享资源的情况。</li>\n<li>Volatile关键字：保证变量的可见性和有序性。当一个变量被Volatile修饰的时候，修改变量的值会立即被其他线程看见，同时编译器和处理器不会把其指令重排到其他语句之前或之后。</li>\n<li>final关键字：保证被修饰的变量的值只能被赋值一次，也就是说它是一个常量，一旦被赋值后不可修改。</li>\n<li>Lock接口：JDK5提供的一种高级的同步手段，它和Synchronized关键字不同，它可以重入，也就是同一个线程可以多次获取同一个锁。</li>\n<li>原子变量：保证在多线程环境下，对于变量的增删改操作是原子性的。</li>\n</ul><h2>重点回顾</h2><p><img src=\"https://static001.geekbang.org/resource/image/0a/c6/0ab6f836e94493fdbb4fdc526a6c54c6.jpg?wh=1798x1778\" alt=\"\"></p><p>问题可见性和重排问题是多线程并发编程中经常遇到的两个问题。</p><p>可见性就是指在一个线程中，共享变量的修改在另一个线程中不能被看到。这主要是由于处理器和内存的速度不同导致的，处理器会把计算所需的数据复制到缓存里，从而产生了缓存一致性问题。为了解决这个问题，<strong>线程必须按照一些协议进行同步操作，保证修改的状态能够即时在其他线程中可见。</strong></p><p>重排问题是指在翻译器和数据处理器执行代码的时候，对命令顺序执行的再次排列。这种优化是为了提高程序的执行性能，但是在多线程环境下可能导致程序的执行结果不符合预期。<strong>为了解决重排问题，Java内存模型规定了一些规则，如读取和载入操作必须按顺序执行，存储和写入操作也必须按顺序执行等。</strong></p><p>Java提供了一些策略来应对可见性和重排的问题。其中，<strong>Synchronized 关键字</strong>能确保在同一时间段内只有一个线程能够执行临界区域的代码，从而防止多线程共享资源的情况发生。<strong>Volatile 关键字</strong>可以保证变量的可见性和有序性。<strong>Lock 接口和原子变量</strong>也可以提供线程安全的解决方案。此外 <strong>final 关键字</strong>可以保证被修饰的变量的值只能被赋值一，不可修改。所以说，熟练掌握JMM是写出线程安全的Java程序的基础。</p><h2>思考题</h2><p>学而不思则罔，学完这节课之后，我给你留两个问题。</p><ol>\n<li>在JVM体系中存在几种重排？</li>\n<li>JMM的解决方案包括哪些？</li>\n</ol><p>希望你认真思考，然后把思考后的结果分享到评论区，我们一起讨论，如果有收获的话，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p><h2>💡点亮你的知识框架图</h2><p><img src=\"https://static001.geekbang.org/resource/image/d7/de/d7dbafa4ba464963c3604e827cf508de.jpg?wh=6666x4672\" alt=\"图片\"></p>","comments":[{"had_liked":false,"id":382438,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1697335177,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"请教老师几个问题：\nQ1：编译器重排的例子，怎么禁止编译器重排列？\nQ2：指令并行重排的例子，指令并行，是指“a = 1”和“flag = true”这两个指令并行处理，而且并行处理的时候，“flag = true”比“a = 1”先执行吗？  另外，while (!flag)，是不是多加了一个“！”？“重叠执行”就是指并行执行吗？\nQ3：缓存系统的重排，“处理器利用了缓存以及读写缓冲区”这句话中，“缓存”是指CPU缓存吗？“读写缓冲区”又是指什么？“负载和保存的任务”，这句话中，“负载任务”和“保存任务”分别指什么？\nQ4：JVM，主内存和工作内存部分。假设系统物理内存是100M，不考虑操作系统和其他应用，假设有两个进程A和B，A用10M内存，B用20M内存，那剩下的70M内存就是主内存吗？\nQ5：“当某个进程对某一变量进行读取或修改操作的时候，需要先把相关数据从主存搬到工作区，完成后又需要把改动后的内容重新拷贝回主存。”，对于某个进程，对于所有的变量修改都需要这样操作吗？还是只针对某些变量？","like_count":0}]}