{"id":238418,"title":"86 | 开源实战四（下）：总结Spring框架用到的11种设计模式","content":"<p>上一节课，我们讲解了Spring中支持扩展功能的两种设计模式：观察者模式和模板模式。这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。</p><p>实际上，Spring框架中用到的设计模式非常多，不下十几种。我们今天就总结罗列一下它们。限于篇幅，我不可能对每种设计模式都进行非常详细的讲解。有些前面已经讲过的或者比较简单的，我就点到为止。如果有什么不是很懂的地方，你可以通过阅读源码，查阅之前的理论讲解，自己去搞定它。如果一直跟着我的课程学习，相信你现在已经具备这样的学习能力。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>适配器模式在Spring中的应用</h2><p>在Spring MVC中，定义一个Controller最常用的方式是，通过@Controller注解来标记某个类是Controller类，通过@RequesMapping注解来标记函数对应的URL。不过，定义一个Controller远不止这一种方法。我们还可以通过让类实现Controller接口或者Servlet接口，来定义一个Controller。针对这三种定义方式，我写了三段示例代码，如下所示：</p><pre><code>// 方法一：通过@Controller、@RequestMapping来定义\n@Controller\npublic class DemoController {\n    @RequestMapping(&quot;/employname&quot;)\n    public ModelAndView getEmployeeName() {\n        ModelAndView model = new ModelAndView(&quot;Greeting&quot;);        \n        model.addObject(&quot;message&quot;, &quot;Dinesh&quot;);       \n        return model; \n    }  \n}\n\n// 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系\npublic class DemoController implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception {\n        ModelAndView model = new ModelAndView(&quot;Greeting&quot;);\n        model.addObject(&quot;message&quot;, &quot;Dinesh Madhwal&quot;);\n        return model;\n    }\n}\n\n// 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系\npublic class DemoServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    this.doPost(req, resp);\n  }\n  \n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    resp.getWriter().write(&quot;Hello World.&quot;);\n  }\n}\n</code></pre><!-- [[[read_end]]] --><p>在应用启动的时候，Spring容器会加载这些Controller类，并且解析出URL对应的处理函数，封装成Handler对象，存储到HandlerMapping对象中。当有请求到来的时候，DispatcherServlet从HanderMapping中，查找请求URL对应的Handler，然后调用执行Handler对应的函数代码，最后将执行结果返回给客户端。</p><p>但是，不同方式定义的Controller，其函数的定义（函数名、入参、返回值等）是不统一的。如上示例代码所示，方法一中的函数的定义很随意、不固定，方法二中的函数定义是handleRequest()、方法三中的函数定义是service()（看似是定义了doGet()、doPost()，实际上，这里用到了模板模式，Servlet中的service()调用了doGet()或doPost()方法，DispatcherServlet调用的是service()方法）。DispatcherServlet需要根据不同类型的Controller，调用不同的函数。下面是具体的伪代码：</p><pre><code>Handler handler = handlerMapping.get(URL);\nif (handler instanceof Controller) {\n  ((Controller)handler).handleRequest(...);\n} else if (handler instanceof Servlet) {\n  ((Servlet)handler).service(...);\n} else if (hanlder 对应通过注解来定义的Controller) {\n  反射调用方法...\n}\n</code></pre><p>从代码中我们可以看出，这种实现方式会有很多if-else分支判断，而且，如果要增加一个新的Controller的定义方法，我们就要在DispatcherServlet类代码中，对应地增加一段如上伪代码所示的if逻辑。这显然不符合开闭原则。</p><p>实际上，我们可以利用是适配器模式对代码进行改造，让其满足开闭原则，能更好地支持扩展。在<a href=\"https://time.geekbang.org/column/article/205912\">第51节课</a>中，我们讲到，适配器其中一个作用是“统一多个类的接口设计”。利用适配器模式，我们将不同方式定义的Controller类中的函数，适配为统一的函数定义。这样，我们就能在DispatcherServlet类代码中，移除掉if-else分支判断逻辑，调用统一的函数。</p><p>刚刚讲了大致的设计思路，我们再具体看下Spring的代码实现。</p><p>Spring定义了统一的接口HandlerAdapter，并且对每种Controller定义了对应的适配器类。这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter等。源码我贴到了下面，你可以结合着看下。</p><pre><code>public interface HandlerAdapter {\n  boolean supports(Object var1);\n\n  ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;\n\n  long getLastModified(HttpServletRequest var1, Object var2);\n}\n\n// 对应实现Controller接口的Controller\npublic class SimpleControllerHandlerAdapter implements HandlerAdapter {\n  public SimpleControllerHandlerAdapter() {\n  }\n\n  public boolean supports(Object handler) {\n    return handler instanceof Controller;\n  }\n\n  public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    return ((Controller)handler).handleRequest(request, response);\n  }\n\n  public long getLastModified(HttpServletRequest request, Object handler) {\n    return handler instanceof LastModified ? ((LastModified)handler).getLastModified(request) : -1L;\n  }\n}\n\n// 对应实现Servlet接口的Controller\npublic class SimpleServletHandlerAdapter implements HandlerAdapter {\n  public SimpleServletHandlerAdapter() {\n  }\n\n  public boolean supports(Object handler) {\n    return handler instanceof Servlet;\n  }\n\n  public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n    ((Servlet)handler).service(request, response);\n    return null;\n  }\n\n  public long getLastModified(HttpServletRequest request, Object handler) {\n    return -1L;\n  }\n}\n\n//AnnotationMethodHandlerAdapter对应通过注解实现的Controller，\n//代码太多了，我就不贴在这里了\n</code></pre><p>在DispatcherServlet类中，我们就不需要区分对待不同的Controller对象了，统一调用HandlerAdapter的handle()函数就可以了。按照这个思路实现的伪代码如下所示。你看，这样就没有烦人的if-else逻辑了吧？</p><pre><code>// 之前的实现方式\nHandler handler = handlerMapping.get(URL);\nif (handler instanceof Controller) {\n  ((Controller)handler).handleRequest(...);\n} else if (handler instanceof Servlet) {\n  ((Servlet)handler).service(...);\n} else if (hanlder 对应通过注解来定义的Controller) {\n  反射调用方法...\n}\n\n// 现在实现方式\nHandlerAdapter handlerAdapter = handlerMapping.get(URL);\nhandlerAdapter.handle(...);\n</code></pre><h2>策略模式在Spring中的应用</h2><p>我们前面讲到，Spring AOP是通过动态代理来实现的。熟悉Java的同学应该知道，具体到代码实现，Spring支持两种动态代理实现方式，一种是JDK提供的动态代理实现方式，另一种是Cglib提供的动态代理实现方式。</p><p>前者需要被代理的类有抽象的接口定义，后者不需要（这两种动态代理实现方式的更多区别请自行百度研究吧）。针对不同的被代理类，Spring会在运行时动态地选择不同的动态代理实现方式。这个应用场景实际上就是策略模式的典型应用场景。</p><p>我们前面讲过，策略模式包含三部分，策略的定义、创建和使用。接下来，我们具体看下，这三个部分是如何体现在Spring源码中的。</p><p>在策略模式中，策略的定义这一部分很简单。我们只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到Spring源码，AopProxy是策略接口，JdkDynamicAopProxy、CglibAopProxy是两个实现了AopProxy接口的策略类。其中，AopProxy接口的定义如下所示：</p><pre><code>public interface AopProxy {\n  Object getProxy();\n  Object getProxy(ClassLoader var1);\n}\n</code></pre><p>在策略模式中，策略的创建一般通过工厂方法来实现。对应到Spring源码，AopProxyFactory是一个工厂类接口，DefaultAopProxyFactory是一个默认的工厂类，用来创建AopProxy对象。两者的源码如下所示：</p><pre><code>public interface AopProxyFactory {\n  AopProxy createAopProxy(AdvisedSupport var1) throws AopConfigException;\n}\n\npublic class DefaultAopProxyFactory implements AopProxyFactory, Serializable {\n  public DefaultAopProxyFactory() {\n  }\n\n  public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {\n    if (!config.isOptimize() &amp;&amp; !config.isProxyTargetClass() &amp;&amp; !this.hasNoUserSuppliedProxyInterfaces(config)) {\n      return new JdkDynamicAopProxy(config);\n    } else {\n      Class&lt;?&gt; targetClass = config.getTargetClass();\n      if (targetClass == null) {\n        throw new AopConfigException(&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;);\n      } else {\n        return (AopProxy)(!targetClass.isInterface() &amp;&amp; !Proxy.isProxyClass(targetClass) ? new ObjenesisCglibAopProxy(config) : new JdkDynamicAopProxy(config));\n      }\n    }\n  }\n\n  //用来判断用哪个动态代理实现方式\n  private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {\n    Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();\n    return ifcs.length == 0 || ifcs.length == 1 &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[0]);\n  }\n}\n</code></pre><p>策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。对应到Spring源码中，我们可以参看刚刚给出的DefaultAopProxyFactory类中的createAopProxy()函数的代码实现。其中，第10行代码是动态选择哪种策略的判断条件。</p><h2>组合模式在Spring中的应用</h2><p>上节课讲到Spring“再封装、再抽象”设计思想的时候，我们提到了Spring Cache。Spring Cache提供了一套抽象的Cache接口。使用它我们能够\b统一不同缓存实现（Redis、Google Guava…）的不同的访问方式。Spring中针对不同缓存实现的不同缓存访问类，都依赖这个接口，比如：EhCacheCache、GuavaCache、NoOpCache、RedisCache、JCacheCache、ConcurrentMapCache、CaffeineCache。Cache接口的源码如下所示：</p><pre><code>public interface Cache {\n  String getName();\n  Object getNativeCache();\n  Cache.ValueWrapper get(Object var1);\n  &lt;T&gt; T get(Object var1, Class&lt;T&gt; var2);\n  &lt;T&gt; T get(Object var1, Callable&lt;T&gt; var2);\n  void put(Object var1, Object var2);\n  Cache.ValueWrapper putIfAbsent(Object var1, Object var2);\n  void evict(Object var1);\n  void clear();\n\n  public static class ValueRetrievalException extends RuntimeException {\n    private final Object key;\n\n    public ValueRetrievalException(Object key, Callable&lt;?&gt; loader, Throwable ex) {\n      super(String.format(&quot;Value for key '%s' could not be loaded using '%s'&quot;, key, loader), ex);\n      this.key = key;\n    }\n\n    public Object getKey() {\n      return this.key;\n    }\n  }\n\n  public interface ValueWrapper {\n    Object get();\n  }\n}\n</code></pre><p>在实际的开发中，一个项目有可能会用到多种不同的缓存，比如既用到Google Guava缓存，也用到Redis缓存。除此之外，同一个缓存实例，也可以根据业务的不同，分割成多个小的逻辑缓存单元（或者叫作命名空间）。</p><p>为了管理多个缓存，Spring还提供了缓存管理功能。不过，它包含的功能很简单，主要有这样两部分：一个是根据缓存名字（创建Cache对象的时候要设置name属性）获取Cache对象；另一个是获取管理器管理的所有缓存的名字列表。对应的Spring源码如下所示：</p><pre><code>public interface CacheManager {\n  Cache getCache(String var1);\n  Collection&lt;String&gt; getCacheNames();\n}\n</code></pre><p>刚刚给出的是CacheManager接口的定义，那如何来实现这两个接口呢？实际上，这就要用到了我们之前讲过的组合模式。</p><p>我们前面讲过，组合模式主要应用在能表示成树形结构的一组数据上。树中的结点分为叶子节点和中间节点两类。对应到Spring源码，EhCacheManager、SimpleCacheManager、NoOpCacheManager、RedisCacheManager等表示叶子节点，CompositeCacheManager表示中间节点。</p><p>叶子节点包含的是它所管理的Cache对象，中间节点包含的是其他CacheManager管理器，既可以是CompositeCacheManager，也可以是具体的管理器，比如EhCacheManager、RedisManager等。</p><p>我把CompositeCacheManger的代码贴到了下面，你可以结合着讲解一块看下。其中，getCache()、getCacheNames()两个函数的实现都用到了递归。这正是树形结构最能发挥优势的地方。</p><pre><code>public class CompositeCacheManager implements CacheManager, InitializingBean {\n  private final List&lt;CacheManager&gt; cacheManagers = new ArrayList();\n  private boolean fallbackToNoOpCache = false;\n\n  public CompositeCacheManager() {\n  }\n\n  public CompositeCacheManager(CacheManager... cacheManagers) {\n    this.setCacheManagers(Arrays.asList(cacheManagers));\n  }\n\n  public void setCacheManagers(Collection&lt;CacheManager&gt; cacheManagers) {\n    this.cacheManagers.addAll(cacheManagers);\n  }\n\n  public void setFallbackToNoOpCache(boolean fallbackToNoOpCache) {\n    this.fallbackToNoOpCache = fallbackToNoOpCache;\n  }\n\n  public void afterPropertiesSet() {\n    if (this.fallbackToNoOpCache) {\n      this.cacheManagers.add(new NoOpCacheManager());\n    }\n\n  }\n\n  public Cache getCache(String name) {\n    Iterator var2 = this.cacheManagers.iterator();\n\n    Cache cache;\n    do {\n      if (!var2.hasNext()) {\n        return null;\n      }\n\n      CacheManager cacheManager = (CacheManager)var2.next();\n      cache = cacheManager.getCache(name);\n    } while(cache == null);\n\n    return cache;\n  }\n\n  public Collection&lt;String&gt; getCacheNames() {\n    Set&lt;String&gt; names = new LinkedHashSet();\n    Iterator var2 = this.cacheManagers.iterator();\n\n    while(var2.hasNext()) {\n      CacheManager manager = (CacheManager)var2.next();\n      names.addAll(manager.getCacheNames());\n    }\n\n    return Collections.unmodifiableSet(names);\n  }\n}\n</code></pre><h2>装饰器模式在Spring中的应用</h2><p>我们知道，缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。</p><p>实现这样一个功能，Spring使用到了装饰器模式。TransactionAwareCacheDecorator增加了对事务的支持，在事务提交、回滚的时候分别对Cache的数据进行处理。</p><p>TransactionAwareCacheDecorator实现Cache接口，并且将所有的操作都委托给targetCache来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现，我就不多作解释了。</p><pre><code>public class TransactionAwareCacheDecorator implements Cache {\n  private final Cache targetCache;\n\n  public TransactionAwareCacheDecorator(Cache targetCache) {\n    Assert.notNull(targetCache, &quot;Target Cache must not be null&quot;);\n    this.targetCache = targetCache;\n  }\n\n  public Cache getTargetCache() {\n    return this.targetCache;\n  }\n\n  public String getName() {\n    return this.targetCache.getName();\n  }\n\n  public Object getNativeCache() {\n    return this.targetCache.getNativeCache();\n  }\n\n  public ValueWrapper get(Object key) {\n    return this.targetCache.get(key);\n  }\n\n  public &lt;T&gt; T get(Object key, Class&lt;T&gt; type) {\n    return this.targetCache.get(key, type);\n  }\n\n  public &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader) {\n    return this.targetCache.get(key, valueLoader);\n  }\n\n  public void put(final Object key, final Object value) {\n    if (TransactionSynchronizationManager.isSynchronizationActive()) {\n      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n        public void afterCommit() {\n          TransactionAwareCacheDecorator.this.targetCache.put(key, value);\n        }\n      });\n    } else {\n      this.targetCache.put(key, value);\n    }\n  }\n  \n  public ValueWrapper putIfAbsent(Object key, Object value) {\n    return this.targetCache.putIfAbsent(key, value);\n  }\n\n  public void evict(final Object key) {\n    if (TransactionSynchronizationManager.isSynchronizationActive()) {\n      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n        public void afterCommit() {\n          TransactionAwareCacheDecorator.this.targetCache.evict(key);\n        }\n      });\n    } else {\n      this.targetCache.evict(key);\n    }\n\n  }\n\n  public void clear() {\n    if (TransactionSynchronizationManager.isSynchronizationActive()) {\n      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {\n        public void afterCommit() {\n          TransactionAwareCacheDecorator.this.targetCache.clear();\n        }\n      });\n    } else {\n      this.targetCache.clear();\n    }\n  }\n}\n</code></pre><h2>工厂模式在Spring中的应用</h2><p>在Spring中，工厂模式最经典的应用莫过于实现IOC容器，对应的Spring源码主要是BeanFactory类和ApplicationContext相关类（AbstractApplicationContext、ClassPathXmlApplicationContext、FileSystemXmlApplicationContext…）。除此之外，在理论部分，我还带你手把手实现了一个简单的IOC容器。你可以回过头去再看下。</p><p>在Spring中，创建Bean的方式有很多种，比如前面提到的纯构造函数、无参构造函数加setter方法。我写了一个例子来说明这两种创建方式，代码如下所示：</p><pre><code>public class Student {\n  private long id;\n  private String name;\n  \n  public Student(long id, String name) {\n    this.id = id;\n    this.name = name;\n  }\n  \n  public void setId(long id) {\n    this.id = id;\n  }\n  \n  public void setName(String name) {\n    this.name = name;\n  }\n}\n\n// 使用构造函数来创建Bean\n&lt;bean id=&quot;student&quot; class=&quot;com.xzg.cd.Student&quot;&gt;\n    &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;/&gt;\n    &lt;constructor-arg name=&quot;name&quot; value=&quot;wangzheng&quot;/&gt;\n&lt;/bean&gt;\n\n// 使用无参构造函数+setter方法来创建Bean\n&lt;bean id=&quot;student&quot; class=&quot;com.xzg.cd.Student&quot;&gt;\n    &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;wangzheng&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre><p>实际上，除了这两种创建Bean的方式之外，我们还可以通过工厂方法来创建Bean。还是刚刚这个例子，用这种方式来创建Bean的话就是下面这个样子：</p><pre><code>public class StudentFactory {\n  private static Map&lt;Long, Student&gt; students = new HashMap&lt;&gt;();\n  \n  static{\n    map.put(1, new Student(1,&quot;wang&quot;));\n    map.put(2, new Student(2,&quot;zheng&quot;));\n    map.put(3, new Student(3,&quot;xzg&quot;));\n  }\n \n  public static Student getStudent(long id){\n    return students.get(id);\n  }\n}\n\n// 通过工厂方法getStudent(2)来创建BeanId=&quot;zheng&quot;&quot;的Bean\n&lt;bean id=&quot;zheng&quot; class=&quot;com.xzg.cd.StudentFactory&quot; factory-method=&quot;getStudent&quot;&gt;\n    &lt;constructor-arg value=&quot;2&quot;&gt;&lt;/constructor-arg&gt;           \n&lt;/bean&gt;\n</code></pre><h2>其他模式在Spring中的应用</h2><p>前面的几个模式在Spring中的应用讲解的都比较详细，接下来的几个模式，大部分都是我们之前讲过的，这里只是简单总结一下，点到为止，如果你对哪块有遗忘，可以回过头去看下理论部分的讲解。</p><p>SpEL，全称叫Spring Expression Language，是Spring中常用来编写配置的表达式语言。它定义了一系列的语法规则。我们只要按照这些语法规则来编写表达式，Spring就能解析出表达式的含义。实际上，这就是我们前面讲到的解释器模式的典型应用场景。</p><p>因为解释器模式没有一个非常固定的代码实现结构，而且Spring中SpEL相关的代码也比较多，所以这里就不带你一块阅读源码了。如果感兴趣或者项目中正好要实现类似的功能的时候，你可以再去阅读、借鉴它的代码实现。代码主要集中在spring-expresssion这个模块下面。</p><p>前面讲到单例模式的时候，我提到过，单例模式有很多弊端，比如单元测试不友好等。应对策略就是通过IOC容器来管理对象，通过IOC容器来实现对象的唯一性的控制。实际上，这样实现的单例并非真正的单例，它的唯一性的作用范围仅仅在同一个IOC容器内。</p><p>除此之外，Spring还用到了观察者模式、模板模式、职责链模式、代理模式。其中，观察者模式、模板模式在上一节课已经详细讲过了。</p><p>实际上，在Spring中，只要后缀带有Template的类，基本上都是模板类，而且大部分都是用Callback回调来实现的，比如JdbcTemplate、RedisTemplate等。剩下的两个模式在Spring中的应用应该人尽皆知了。职责链模式在Spring中的应用是拦截器（Interceptor），代理模式经典应用是AOP。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>我们今天提到的设计模式有11种，它们分别是适配器模式、策略模式、组合模式、装饰器模式、工厂模式、单例模式、解释器模式、观察者模式、模板模式、职责链模式、代理模式，基本上占了23种设计模式的一半。这还只是我所知道的，实际上，Spring用到的设计模式可能还要更多。你看，设计模式并非“花拳绣腿”吧，它在实际的项目开发中，确实有很多应用，确实可以发挥很大的作用。</p><p>还是那句话，对于今天的内容，你不需要去记忆哪个类用到了哪个设计模式。你只需要跟着我的讲解，把每个设计模式在Spring中的应用场景，搞懂就可以了。看到类似的代码，能够立马识别出它用到了哪种设计模式；看到类似的应用场景，能够立马反映出要用哪种模式去解决，这样就说明你已经掌握得足够好了。</p><h2>课堂讨论</h2><p>我们前面讲到，除了纯构造函数、构造函数加setter方法和工厂方法之外，还有另外一个经常用来创建对象的模式，Builder模式。如果我们让Spring支持通过Builder模式来创建Bean，应该如何来编写代码和配置呢？你可以设计一下吗？</p><p>欢迎留言和我分享你的想法。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","comments":[{"had_liked":false,"id":219127,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1589951814,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"83194330438","product_id":100039001,"comment_content":"可以使用FactoryBean接口来实现，如下：<br>&#47;&#47;StdHttpClient可以理解为已经定义好的一个类，使用builder模式实现。<br>public class HttpFactoryBean implements FactoryBean&lt;HttpClient&gt;{<br><br>private String host;<br>private int port;<br><br><br>public HttpClient getObject() throws Exception {<br>    return new StdHttpClient.Builder()<br>                            .host(host)<br>                            .port(port)<br>                            .build();<br>}<br><br>public Class&lt;? extends HttpClient&gt; getObjectType() {<br>    return StdHttpClient.class;<br>}<br><br>public boolean isSingleton() {<br>    return true;<br>}<br><br>public void setHost(String host) {<br>    this.host = host;<br>}<br><br>public void setPort(int port) {<br>    this.port = port;<br>}}<br>添加配置到bean定义：<br>&lt;beans ...&gt; <br>   &lt;bean name=&quot;myHttpClient&quot; class=&quot;HttpFactoryBean&quot;&gt;<br>       &lt;property name=&quot;port&quot; value=&quot;8080&quot;&#47;&gt;<br>       &lt;property name=&quot;host&quot; value=&quot;localhost&quot;&#47;&gt;<br>   &lt;&#47;bean&gt;<br>&lt;&#47;beans&gt;<br>之后你就可以使用StdHttpClient实例了。","like_count":19,"discussions":[{"author":{"id":2162521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MaX06SRk19zM2lAaymYylpXD6LMtIPFlDyxZKgRhmZCjhNE4nIdDGBmh08razhebVCgAv54xialYBBIIwmleBew/132","nickname":"Geek_6d1382","note":"","ucode":"B61E65CFEB684F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331956,"discussion_content":"参数校验怎么设计呢？扩展不了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607011885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219225,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1589968767,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70309445503","product_id":100039001,"comment_content":"不是做java的看的好累....看源码必须是先知道怎么使用, 然后才看源码, 这样才比较好看懂源码.","like_count":16},{"had_liked":false,"id":219224,"user_name":"饭","can_delete":false,"product_type":"c1","uid":1610573,"ip_address":"","ucode":"B3F1702D4DE604","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJKj3GbvevFibxwJibTqm16NaE8MXibwDUlnt5tt73KF9WS2uypha2m1Myxic6Q47Zaj2DZOwia3AgicO7Q/132","comment_is_top":false,"comment_ctime":1589968655,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"57424543503","product_id":100039001,"comment_content":"越看到后面，越觉得最好的模式就是没有模式，用好并理解基本的面向对象设计就成功一半了。","like_count":13,"discussions":[{"author":{"id":2234620,"avatar":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","nickname":"江南一笑","note":"","ucode":"E38938A1178827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380048,"discussion_content":"嗯。没有遇到实际问题 就硬搬模式 感觉学得也不深刻 用起来也生硬","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1624307983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1063308,"avatar":"https://static001.geekbang.org/account/avatar/00/10/39/8c/089525aa.jpg","nickname":"小乙哥","note":"","ucode":"C77E79BEA0C325","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317264,"discussion_content":"同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603524117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219227,"user_name":"Jie","can_delete":false,"product_type":"c1","uid":1045078,"ip_address":"","ucode":"AB94041E548FEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","comment_is_top":false,"comment_ctime":1589968900,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"23064805380","product_id":100039001,"comment_content":"这篇内容密度很大，可以看上两天。<br><br>另外策略模式那块提到“这两种动态代理实现方式的更多区别请自行百度研究吧”，不是应该用Google搜索么=w=？","like_count":5,"discussions":[{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311759,"discussion_content":"讲了这么久设计模式的核心思想，重意不重形。你还停留在表面或者更下一层-抬杠。小伙子要加油啊","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1602483634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2068684,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotIianb3beTzsGIte6BZxlIhEwc2ryrNBGxZy8ibKbfibVJyUS8d3ZxybAdfJwHPm13ydPC4VJP7Lbw/132","nickname":"taku","note":"","ucode":"B22DA9A4A9DC91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383590,"discussion_content":"此处百度是一个动词，就像英文语境下的you just google it 中的google","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626172640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1105744,"avatar":"https://static001.geekbang.org/account/avatar/00/10/df/50/b9955f61.jpg","nickname":"皮聪","note":"","ucode":"75D9E182BC00E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559702,"discussion_content":"其实这篇文章主要告诉你spring中用到了哪些设计模式，我觉得前面认真学了，这里应该很容易才对呀。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648888941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219109,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1589946335,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10179880927","product_id":100039001,"comment_content":"对象的初始化有两种实现方式。一种是在类中自定义一个初始化函数，并且通过配置文件，显式地告知 Spring，哪个函数是初始化函数<br>","like_count":2},{"had_liked":false,"id":219048,"user_name":"悟光","can_delete":false,"product_type":"c1","uid":1439777,"ip_address":"","ucode":"E81339EBC4F492","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/21/3fa228e6.jpg","comment_is_top":false,"comment_ctime":1589937255,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10179871847","product_id":100039001,"comment_content":"尝试了一下，xml配置未找到直接调用build方法的配置，用构造器注入<br>类：<br><br>public class Student {<br>    private long id;<br>    private String name;<br><br>    private Student(Builder builder) {<br>        this.id =builder.id;<br>        this.name = builder.name;<br>    }<br><br>    public String getName() {<br>        return name;<br>    }<br><br><br>    public static class Builder {<br>        private long id;<br>        private String name;<br>        public Student build() {<br>            if (StringUtils.isEmpty(name)){<br>                throw  new IllegalArgumentException(&quot;name  is empty&quot;);<br>            }<br>           return new Student(this);<br>        }<br><br>        public void setId(long id) {<br>            this.id = id;<br>        }<br><br>        public void setName(String name) {<br>            this.name = name;<br>        }<br>    }<br>}<br>配置：<br>&lt;bean id=&quot;build&quot; class=&quot;cn.gitv.rt.advertisv5.utils.Student.Builder&quot; &gt;<br>        &lt;property name=&quot;name&quot; value=&quot;aa&quot;&#47;&gt;<br>        &lt;property name=&quot;id&quot; value=&quot;2&quot;&#47;&gt;<br>    &lt;&#47;bean&gt;<br>    &lt;bean id=&quot;student&quot; class=&quot;cn.gitv.rt.advertisv5.utils.Student&quot;&gt;<br>        &lt;constructor-arg ref=&quot;build&quot;&#47;&gt;<br>    &lt;&#47;bean&gt;<br>2、“实际上，我们可以利用是适配器模式对代码进行改造，让其满足开闭原则，能更好地支持扩赞”。 这一句应该 “赞” 敲串行了。<br>","like_count":3},{"had_liked":false,"id":221811,"user_name":"xk_","can_delete":false,"product_type":"c1","uid":1514305,"ip_address":"","ucode":"DFE1AC38EA78A7","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/41/dbb7d785.jpg","comment_is_top":false,"comment_ctime":1590594782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885562078","product_id":100039001,"comment_content":"public class Builder {<br>    private String id;<br>    private String name;<br>    private String age;<br><br>    public void setId(String id) {<br>        if (id == null)<br>            throw new RuntimeException(&quot;id can&#39;t be null&quot;);<br>        this.id = id;<br>    }<br><br>    public void setName(String name) {<br>        if (name == null)<br>            throw new RuntimeException(&quot;name can&#39;t be null&quot;);<br>        this.name = name;<br><br>    }<br>    public void setAge(String age) {<br>        if (age == null)<br>            throw new RuntimeException(&quot;age can&#39;t be null&quot;);<br>        this.age = age;<br><br>    }<br>    ...getter...<br>}<br>public class Student {<br>    String id;<br>    String name;<br>    String age;<br><br>    Student(Builder builder) {<br>        id = builder.getId();<br>        name = builder.getName();<br>        age = builder.getAge();<br>    }<br>}<br><br>&lt;bean id=&quot;build&quot; class=&quot;com.aaa.Builder&quot; &gt;<br>        &lt;property name=&quot;name&quot; value=&quot;aa&quot;&#47;&gt;<br>        &lt;property name=&quot;id&quot; value=&quot;2&quot;&#47;&gt;<br>        &lt;property name=&quot;age&quot; value=&quot;2&quot;&#47;&gt;<br>    &lt;&#47;bean&gt;<br>    &lt;bean id=&quot;student&quot; class=&quot;com.aaa.Student&quot;&gt;<br>        &lt;constructor-arg ref=&quot;build&quot;&#47;&gt;<br>    &lt;&#47;bean&gt;","like_count":0},{"had_liked":false,"id":220921,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1590337279,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885304575","product_id":100039001,"comment_content":"信息量很大慢慢消化谢谢老师","like_count":1},{"had_liked":false,"id":219111,"user_name":"电光火石","can_delete":false,"product_type":"c1","uid":1013160,"ip_address":"","ucode":"3AD33BB4AA940F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/a8/dfe4cade.jpg","comment_is_top":false,"comment_ctime":1589946431,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5884913727","product_id":100039001,"comment_content":"&#47;&#47; 通过参考工厂方法来创建BeanId=&quot;zheng&quot;&quot;的Bean<br><br>&lt;bean id=&quot;zheng&quot; class=&quot;com.xzg.cd.StudentBuilder&quot; build-method=&quot;build&quot;&gt;<br>\t&lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;&#47;property&gt;<br>\t&lt;property name=&quot;name&quot; value=&quot;wangzheng&quot;&gt;&lt;&#47;property&gt;<br>&lt;&#47;bean&gt;<br>把factory-method改成build-method","like_count":1,"discussions":[{"author":{"id":1055334,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","nickname":"苦行僧","note":"","ucode":"726024A9A9CF44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278340,"discussion_content":"你们这个是整理+搬迁代码。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591175031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350102,"user_name":"小王在努力","can_delete":false,"product_type":"c1","uid":2733574,"ip_address":"","ucode":"A324EF87198905","user_header":"https://static001.geekbang.org/account/avatar/00/29/b6/06/cd1eaa49.jpg","comment_is_top":false,"comment_ctime":1656573029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656573029","product_id":100039001,"comment_content":"坚持！","like_count":0},{"had_liked":false,"id":346281,"user_name":"🚦注意有车              ༽","can_delete":false,"product_type":"c1","uid":2113645,"ip_address":"","ucode":"F638673227ECB1","user_header":"https://static001.geekbang.org/account/avatar/00/20/40/6d/61caf56b.jpg","comment_is_top":false,"comment_ctime":1652973758,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1652973758","product_id":100039001,"comment_content":"看了开头老师讲的适配器模式，跟策略模式好像差不多，总觉得适配器模式就是策略模式；两者该怎么具体区分呢","like_count":0,"discussions":[{"author":{"id":2342321,"avatar":"https://static001.geekbang.org/account/avatar/00/23/bd/b1/324ff184.jpg","nickname":"土豆","note":"","ucode":"6676E091CA6E48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573061,"discussion_content":"目的不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653188753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331102,"user_name":"Mirss.zhao","can_delete":false,"product_type":"c1","uid":1330632,"ip_address":"","ucode":"4A8F20B1A9D142","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTItudDLPfbZabQLjk1NE8NSibQocdRy88rerQdxHFKx4KzUyaEnSLPbszcKAaPX8NgG3sHbZXib41aQ/132","comment_is_top":false,"comment_ctime":1642425169,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1642425169","product_id":100039001,"comment_content":"在mapping中保存adapter的时候不需要if else.判断是哪种controller的adapter吗","like_count":0,"discussions":[{"author":{"id":1165671,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c9/67/0f74bf61.jpg","nickname":"昵称还没想好。","note":"","ucode":"21E6001F29951B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568036,"discussion_content":"protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {\n\t\tif (this.handlerAdapters != null) {\n\t\t\tfor (HandlerAdapter adapter : this.handlerAdapters) {\n\t\t\t\tif (adapter.supports(handler)) {\n\t\t\t\t\treturn adapter;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new ServletException(&#34;No adapter for handler [&#34; + handler +\n\t\t\t\t&#34;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&#34;);\n\t}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651049076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329905,"user_name":"黄平","can_delete":false,"product_type":"c1","uid":1142708,"ip_address":"","ucode":"2207224A09735C","user_header":"https://static001.geekbang.org/account/avatar/00/11/6f/b4/4aefe4c0.jpg","comment_is_top":false,"comment_ctime":1641635896,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1641635896","product_id":100039001,"comment_content":"将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败，这个问题只是说了用了装饰器设计模式，最后如何解决呢？","like_count":0,"discussions":[{"author":{"id":2076251,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/ae/5b/4bd42286.jpg","nickname":"宋计洋","note":"","ucode":"9A34E8F71C6CBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564911,"discussion_content":"https://dzone.com/articles/spring-cache-annotation-tips-and-tricks    这篇文章有讲，自定义一个CacheManager Bean, 你的Cache注解就带事务感知了，具体如何做的就是上面代码里面TransactionSynchronizationManager这个类把缓存的操作都延迟到事务完成去做，就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650353345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326336,"user_name":"牛凡","can_delete":false,"product_type":"c1","uid":1890173,"ip_address":"","ucode":"36DD925F480EA4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pCUrja4Z78P36FkdXQFFwnsmnicUjTsY7ickbR1xxAEp9yD1JebIafWiaXJLMvW7Ptn7Z6r6z3BiadQHHBhk1icYovw/132","comment_is_top":false,"comment_ctime":1639474471,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639474471","product_id":100039001,"comment_content":"在Spring中没有找到AnnotationMethodHandlerAdapter，应该是RequestMappingHandlerAdapter吧","like_count":1},{"had_liked":false,"id":258074,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1604286866,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604286866","product_id":100039001,"comment_content":"打卡86","like_count":0},{"had_liked":false,"id":243661,"user_name":"John(易筋)","can_delete":false,"product_type":"c1","uid":1180202,"ip_address":"","ucode":"BB4E58DD4B8F15","user_header":"https://static001.geekbang.org/account/avatar/00/12/02/2a/90e38b94.jpg","comment_is_top":false,"comment_ctime":1598242501,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598242501","product_id":100039001,"comment_content":"这两种动态代理实现方式的更多区别请自行Google","like_count":0},{"had_liked":false,"id":225667,"user_name":"黄平","can_delete":false,"product_type":"c1","uid":1142708,"ip_address":"","ucode":"2207224A09735C","user_header":"https://static001.geekbang.org/account/avatar/00/11/6f/b4/4aefe4c0.jpg","comment_is_top":false,"comment_ctime":1591811107,"is_pvip":false,"replies":[{"id":"83998","content":"😂 自己查查吧","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1592526469,"ip_address":"","comment_id":225667,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591811107","product_id":100039001,"comment_content":"TransactionAwareCacheDecorator怎么用呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497936,"discussion_content":"😂 自己查查吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592526469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221002,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1590376958,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590376958","product_id":100039001,"comment_content":"Bean 的xml的配置&lt;constructor-arg ref=&#39;Builder类&#39;&gt;，即构造函数的入参是builder类（引用类型），BeanFactory中会使用递归，构造完Builder类对象之后，再构造你想要的Bean","like_count":0}]}