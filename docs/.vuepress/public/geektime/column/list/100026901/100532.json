{"id":100532,"title":"16 | 值传递，引用传递or其他，Python里参数是如何传递的？","content":"<p>你好，我是景霄。</p><p>在前面的第一大章节中，我们一起学习了Python的函数基础及其应用。我们大致明白了，所谓的传参，就是把一些参数从一个函数传递到另一个函数，从而使其执行相应的任务。但是你有没有想过，参数传递的底层是如何工作的，原理又是怎样的呢？</p><p>实际工作中，很多人会遇到这样的场景：写完了代码，一测试，发现结果和自己期望的不一样，于是开始一层层地debug。花了很多时间，可到最后才发现，是传参过程中数据结构的改变，导致了程序的“出错”。</p><p>比如，我将一个列表作为参数传入另一个函数，期望列表在函数运行结束后不变，但是往往“事与愿违”，由于某些操作，它的值改变了，那就很有可能带来后续程序一系列的错误。</p><p>因此，了解Python中参数的传递机制，具有十分重要的意义，这往往能让我们写代码时少犯错误，提高效率。今天我们就一起来学习一下，Python中参数是如何传递的。</p><h2><strong>什么是值传递和引用传递</strong></h2><p>如果你接触过其他的编程语言，比如C/C++，很容易想到，常见的参数传递有2种：<strong>值传递</strong>和<strong>引用传递</strong>。所谓值传递，通常就是拷贝参数的值，然后传递给函数里的新变量。这样，原变量和新变量之间互相独立，互不影响。</p><p>比如，我们来看下面的一段C++代码：</p><!-- [[[read_end]]] --><pre><code>#include &lt;iostream&gt;\nusing namespace std;\n \n// 交换2个变量的值\nvoid swap(int x, int y) {\nint temp;\ntemp = x; // 交换x和y的值\n x = y;\n y = temp;\n return;\n}\nint main () {\n int a = 1;\n int b = 2;\n cout &lt;&lt; &quot;Before swap, value of a :&quot; &lt;&lt; a &lt;&lt; endl;\n cout &lt;&lt; &quot;Before swap, value of b :&quot; &lt;&lt; b &lt;&lt; endl;\n swap(a, b); \n cout &lt;&lt; &quot;After swap, value of a :&quot; &lt;&lt; a &lt;&lt; endl;\n cout &lt;&lt; &quot;After swap, value of b :&quot; &lt;&lt; b &lt;&lt; endl;\n return 0;\n}\nBefore swap, value of a :1\nBefore swap, value of b :2\nAfter swap, value of a :1\nAfter swap, value of b :2\n</code></pre><p>这里的swap()函数，把a和b的值拷贝给了x和y，然后再交换x和y的值。这样一来，x和y的值发生了改变，但是a和b不受其影响，所以值不变。这种方式，就是我们所说的值传递。</p><p>所谓引用传递，通常是指把参数的引用传给新的变量，这样，原变量和新变量就会指向同一块内存地址。如果改变了其中任何一个变量的值，那么另外一个变量也会相应地随之改变。</p><p>还是拿我们刚刚讲到的C++代码为例，上述例子中的swap()函数，如果改成下面的形式，声明引用类型的参数变量：</p><pre><code>void swap(int&amp; x, int&amp; y) {\n   int temp;\n   temp = x; // 交换x和y的值\n   x = y;\n   y = temp;\n   return;\n}\n</code></pre><p>那么输出的便是另一个结果：</p><pre><code>Before swap, value of a :1\nBefore swap, value of b :2\nAfter swap, value of a :2\nAfter swap, value of b :1\n</code></pre><p>原变量a和b的值被交换了，因为引用传递使得a和x，b和y一模一样，对x和y的任何改变必然导致了a和b的相应改变。</p><p>不过，这是C/C++语言中的特点。那么Python中，参数传递到底是如何进行的呢？它们到底属于值传递、引用传递，还是其他呢？</p><p>在回答这个问题之前，让我们先来了解一下，Python变量和赋值的基本原理。</p><h2><strong>Python变量及其赋值</strong></h2><p>我们首先来看，下面的Python代码示例：</p><pre><code>a = 1\nb = a\na = a + 1\n</code></pre><p>这里首先将1赋值于a，即a指向了1这个对象，如下面的流程图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/97/eb/97c05df49cfe051d7b76addd833f33eb.png?wh=422*214\" alt=\"\"></p><p>接着b = a则表示，让变量b也同时指向1这个对象。这里要注意，Python里的对象可以被多个变量所指向或引用。</p><p><img src=\"https://static001.geekbang.org/resource/image/c0/9f/c00c9fc013cea4eb840921eb4b3e499f.png?wh=350*336\" alt=\"\"></p><p>最后执行a = a + 1。需要注意的是，Python的数据类型，例如整型（int）、字符串（string）等等，是不可变的。所以，a = a + 1，并不是让a的值增加1，而是表示重新创建了一个新的值为2的对象，并让a指向它。但是b仍然不变，仍然指向1这个对象。</p><p>因此，最后的结果是，a的值变成了2，而b的值不变仍然是1。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/17/fc10cd3e3512e984d530a4b82259e917.png?wh=422*290\" alt=\"\"></p><p>通过这个例子你可以看到，这里的a和b，开始只是两个指向同一个对象的变量而已，或者你也可以把它们想象成同一个对象的两个名字。简单的赋值b = a，并不表示重新创建了新对象，只是让同一个对象被多个变量指向或引用。</p><p>同时，指向同一个对象，也并不意味着两个变量就被绑定到了一起。如果你给其中一个变量重新赋值，并不会影响其他变量的值。</p><p>明白了这个基本的变量赋值例子，我们再来看一个列表的例子：</p><pre><code>l1 = [1, 2, 3]\nl2 = l1\nl1.append(4)\nl1\n[1, 2, 3, 4]\nl2\n[1, 2, 3, 4]\n</code></pre><p>同样的，我们首先让列表l1和l2同时指向了[1, 2, 3]这个对象。</p><p><img src=\"https://static001.geekbang.org/resource/image/c2/f9/c2f8e0d9a8570bd56a43a21b7bb25af9.png?wh=662*370\" alt=\"\"></p><p>由于列表是可变的，所以l1.append(4)不会创建新的列表，只是在原列表的末尾插入了元素4，变成[1, 2, 3, 4]。由于l1和l2同时指向这个列表，所以列表的变化会同时反映在l1和l2这两个变量上，那么，l1和l2的值就同时变为了[1, 2, 3, 4]。</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/5f/b16d29112c361f596952961d13da345f.png?wh=694*358\" alt=\"\"></p><p>另外，需要注意的是，Python里的变量可以被删除，但是对象无法被删除。比如下面的代码：</p><pre><code>l = [1, 2, 3]\ndel l\n</code></pre><p>del l 删除了l这个变量，从此以后你无法访问l，但是对象[1, 2, 3]仍然存在。Python程序运行时，其自带的垃圾回收系统会跟踪每个对象的引用。如果[1, 2, 3]除了l外，还在其他地方被引用，那就不会被回收，反之则会被回收。</p><p>由此可见，在Python中：</p><ul>\n<li>变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；而一个对象，可以被多个变量所指向。</li>\n<li>可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。</li>\n<li>对于不可变对象（字符串、整型、元组等等），所有指向该对象的变量的值总是一样的，也不会改变。但是通过某些操作（+=等等）更新不可变对象的值时，会返回一个新的对象。</li>\n<li>变量可以被删除，但是对象无法被删除。</li>\n</ul><h2><strong>Python函数的参数传递</strong></h2><p>从上述Python变量的命名与赋值的原理讲解中，相信你能举一反三，大概猜出Python函数中参数是如何传递了吧？</p><p>这里首先引用Python官方文档中的一段说明：</p><blockquote>\n<p>“Remember that arguments are passed by assignment in Python. Since assignment  just creates references to objects, there’s no alias between an  argument name in the caller and callee, and so no call-by-reference per Se.”</p>\n</blockquote><p>准确地说，Python的参数传递是<strong>赋值传递</strong> （pass by assignment），或者叫作对象的<strong>引用传递</strong>（pass by object reference）。Python里所有的数据类型都是对象，所以参数传递时，只是让新变量与原变量指向相同的对象而已，并不存在值传递或是引用传递一说。</p><p>比如，我们来看下面这个例子：</p><pre><code>def my_func1(b):\n\tb = 2\n\na = 1\nmy_func1(a)\na\n1\n</code></pre><p>这里的参数传递，使变量a和b同时指向了1这个对象。但当我们执行到b = 2时，系统会重新创建一个值为2的新对象，并让b指向它；而a仍然指向1这个对象。所以，a的值不变，仍然为1。</p><p>那么对于上述例子的情况，是不是就没有办法改变a的值了呢？</p><p>答案当然是否定的，我们只需稍作改变，让函数返回新变量，赋给a。这样，a就指向了一个新的值为2的对象，a的值也因此变为2。</p><pre><code>def my_func2(b):\n\tb = 2\n\treturn b\n\na = 1\na = my_func2(a)\na\n2\n</code></pre><p>不过，当可变对象当作参数传入函数里的时候，改变可变对象的值，就会影响所有指向它的变量。比如下面的例子：</p><pre><code>def my_func3(l2):\n\tl2.append(4)\n\nl1 = [1, 2, 3]\nmy_func3(l1)\nl1\n[1, 2, 3, 4]\n</code></pre><p>这里l1和l2先是同时指向值为[1, 2, 3]的列表。不过，由于列表可变，执行append()函数，对其末尾加入新元素4时，变量l1和l2的值也都随之改变了。</p><p>但是，下面这个例子，看似都是给列表增加了一个新元素，却得到了明显不同的结果。</p><pre><code>def my_func4(l2):\n\tl2 = l2 + [4]\n\nl1 = [1, 2, 3]\nmy_func4(l1)\nl1\n[1, 2, 3]\n</code></pre><p>为什么l1仍然是[1, 2, 3]，而不是[1, 2, 3, 4]呢？</p><p>要注意，这里l2 = l2 + [4]，表示创建了一个“末尾加入元素4“的新列表，并让l2指向这个新的对象。这个过程与l1无关，因此l1的值不变。当然，同样的，如果要改变l1的值，我们就得让上述函数返回一个新列表，再赋予l1即可：</p><pre><code>def my_func5(l2):\n\tl2 = l2 + [4]\n\treturn l2\n\nl1 = [1, 2, 3]\nl1 = my_func5(l1)\nl1\n[1, 2, 3, 4]\n</code></pre><p>这里你尤其要记住的是，改变变量和重新赋值的区别：</p><ul>\n<li>my_func3()中单纯地改变了对象的值，因此函数返回后，所有指向该对象的变量都会被改变；</li>\n<li>但my_func4()中则创建了新的对象，并赋值给一个本地变量，因此原变量仍然不变。</li>\n</ul><p>至于my_func3()和my_func5()的用法，两者虽然写法不同，但实现的功能一致。不过，在实际工作应用中，我们往往倾向于类似my_func5()的写法，添加返回语句。这样更简洁明了，不易出错。</p><h2><strong>总结</strong></h2><p>今天，我们一起学习了Python的变量及其赋值的基本原理，并且解释了Python中参数是如何传递的。和其他语言不同的是，Python中参数的传递既不是值传递，也不是引用传递，而是赋值传递，或者是叫对象的引用传递。</p><p>需要注意的是，这里的赋值或对象的引用传递，不是指向一个具体的内存地址，而是指向一个具体的对象。</p><ul>\n<li>如果对象是可变的，当其改变时，所有指向这个对象的变量都会改变。</li>\n<li>如果对象不可变，简单的赋值只能改变其中一个变量的值，其余变量则不受影响。</li>\n</ul><p>清楚了这一点，如果你想通过一个函数来改变某个变量的值，通常有两种方法。一种是直接将可变数据类型（比如列表，字典，集合）当作参数传入，直接在其上修改；第二种则是创建一个新变量，来保存修改后的值，然后将其返回给原变量。在实际工作中，我们更倾向于使用后者，因为其表达清晰明了，不易出错。</p><h2><strong>思考题</strong></h2><p>最后，我为你留下了两道思考题。</p><p>第一个问题，下面的代码中, l1、l2和l3都指向同一个对象吗？</p><pre><code>l1 = [1, 2, 3]\nl2 = [1, 2, 3]\nl3 = l2\n</code></pre><p>第二个问题，下面的代码中，打印d最后的输出是什么呢？</p><pre><code>def func(d):\n    d['a'] = 10\n\td['b'] = 20\n\nd = {'a': 1, 'b': 2}\nfunc(d)\nprint(d)\n</code></pre><p>欢迎留言和我分享，也欢迎你把这篇文章分享给你的同事、朋友，一起在交流中进步。</p>","neighbors":{"left":{"article_title":"15 | Python对象的比较、拷贝","id":100105},"right":{"article_title":"17 | 强大的装饰器","id":100914}},"comments":[{"had_liked":false,"id":104437,"user_name":"Jingxiao","can_delete":false,"product_type":"c1","uid":1259521,"ip_address":"","ucode":"EB966BB87132F6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","comment_is_top":true,"comment_ctime":1560754060,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"9.2233724034877993e+18","product_id":100026901,"comment_content":"关于思考题：<br>第一题：<br>l2和l3是指向同一个对象，因为两者之间用等号赋值了，l1并不是，l1所指向的[1, 2, 3]是另外一块内存空间，大家可以通过id()这个函数验证<br><br>第二题：<br>输出的是{&#39;a&#39;: 10, &#39;b&#39;: 20}，字典是可变的，传入函数后，函数里的d和外部的d实际上都指向同一个对象<br>d[idx] = value语句改变了字典对应key所指向的值<br>","like_count":86,"discussions":[{"author":{"id":2344816,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLCbnGYOhwYmBwytX5e8Dd3ll9JwjUgaS5QK2JnbxrNdwJiaFksjsKQXBw9OuLZicrCB7unnS3ZGLOw/132","nickname":"米勒","note":"","ucode":"9C02A167B593A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341045,"discussion_content":"老师，麻烦问下，一块内存空间是不是只能有一个对象，而一个对象可以是多个内存空间吗?不是太明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610271654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1535749,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/fjMKxJNhpI3IMZdFPMeVfvNwnX0smK9ZJRjcpooF7y2DibUk7A0u6m7BcWiamZsJSDicUxoJCcbYiaXT9GEcJTndhQ/132","nickname":"吃兔子的大萝卜","note":"","ucode":"AF7AE763DBE8E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21768,"discussion_content":"是你了，课代表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569514772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2143277,"avatar":"https://static001.geekbang.org/account/avatar/00/20/b4/2d/44680897.jpg","nickname":"Resolution","note":"","ucode":"F74C067C58CD05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1535749,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/fjMKxJNhpI3IMZdFPMeVfvNwnX0smK9ZJRjcpooF7y2DibUk7A0u6m7BcWiamZsJSDicUxoJCcbYiaXT9GEcJTndhQ/132","nickname":"吃兔子的大萝卜","note":"","ucode":"AF7AE763DBE8E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301417,"discussion_content":"这不是老师吗","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1598520019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21768,"ip_address":""},"score":301417,"extra":""}]}]},{"had_liked":false,"id":103648,"user_name":"不瘦到140不改名","can_delete":false,"product_type":"c1","uid":1528298,"ip_address":"","ucode":"31DA063A17FC27","user_header":"https://static001.geekbang.org/account/avatar/00/17/51/ea/2ce84d5a.jpg","comment_is_top":false,"comment_ctime":1560482439,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"358042768007","product_id":100026901,"comment_content":"针对@小恶魔的问题，回复一下<br><br>python里面一切皆对象， 比如a=1。在java里面是int a = 1，相当于先声明了一个int类型的变量a，然后给这个变量赋值为1。但在python中，是先在内存中申请一份空间，存的值为1，然后再给这块空间贴上一个标签，叫变量a，因此python中变量实际上是一个便利贴，可以贴在任何地方。并且还可以通过值来推断出变量的类型，这一步是由解释器来完成的。所以python虽然不需要显式声明变量，但它其实是强类型语言。<br>def func(d):<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br>    d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br><br><br>d = {}<br>func(d)<br>print(d)  # {&#39;a&#39;: 10, &#39;b&#39;: 20}<br><br>至于这里为什么会是这个结果，当我们将d传递给func的时候，其实func里面的d和外面的d指向的是同一片内存。相当于一开始d={},存放{}这份空间只有d这一个便利贴，但是func(d)的时候，这份空间又多了一个便利贴。尽管都叫d，但一个是全局变量d，一个是函数的参数d<br>当d[&#39;a&#39;] = 10和d[&#39;b&#39;]=20的时候，由于字典是可变类型，所以外面的d也被修改了，此时外面的d和函数里面的d都指向了{&#39;a&#39;: 10, &#39;b&#39;: 20}, 但是当d = {&#39;a&#39;: 1, &#39;b&#39;: 2}的时候，这是属于赋值。因此python会在内存中再开辟一份空间，空间存放{&#39;a&#39;: 1, &#39;b&#39;: 2}，然后让函数里面的局部变量d指向它，相当于将原本位于{&#39;a&#39;:10,&#39;b&#39;:20}上的便利贴撕下来，贴在了另一块空间。但这只是函数里面的d，对外面的d是没有影响的，所以外面的d依旧是{&#39;a&#39;: 10, &#39;b&#39;: 20}。","like_count":83,"discussions":[{"author":{"id":1079586,"avatar":"https://static001.geekbang.org/account/avatar/00/10/79/22/eced501c.jpg","nickname":"Geek_444bc7","note":"","ucode":"5E2929258E8BBA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3036,"discussion_content":"没看明白，试了下外面的id(d)和函数里的id(d)值是一样的，何来又开辟了一个新空间","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564127217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1524154,"avatar":"https://static001.geekbang.org/account/avatar/00/17/41/ba/ae028565.jpg","nickname":"YqY","note":"","ucode":"73FB936045DCB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079586,"avatar":"https://static001.geekbang.org/account/avatar/00/10/79/22/eced501c.jpg","nickname":"Geek_444bc7","note":"","ucode":"5E2929258E8BBA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4537,"discussion_content":"我试了一下 id不一样啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565528123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3036,"ip_address":""},"score":4537,"extra":""},{"author":{"id":1143983,"avatar":"https://static001.geekbang.org/account/avatar/00/11/74/af/6f39dcf8.jpg","nickname":"奥卡姆剃刀","note":"","ucode":"BF71372CA50EDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079586,"avatar":"https://static001.geekbang.org/account/avatar/00/10/79/22/eced501c.jpg","nickname":"Geek_444bc7","note":"","ucode":"5E2929258E8BBA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358764,"discussion_content":"id(d)值不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616046657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":3036,"ip_address":""},"score":358764,"extra":""}]},{"author":{"id":1233917,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d3/fd/41eb3ecc.jpg","nickname":"奔跑的徐胖子","note":"","ucode":"CFB8A7C4F99D34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4241,"discussion_content":"厉害，厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565247003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1528298,"avatar":"https://static001.geekbang.org/account/avatar/00/17/51/ea/2ce84d5a.jpg","nickname":"不瘦到140不改名","note":"","ucode":"31DA063A17FC27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2523,"discussion_content":"为什么要变呢？l1 = l1 + [4]等于新创建了一个列表然后赋值给l1，但此时的l1和外面的l1已经不是同一个l1了。\n如果你是l1 += [4]，那么外面的l1是会改变的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563759861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149164,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/ec/1460179b.jpg","nickname":"我心飞扬","note":"","ucode":"E41155122C9A1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":889,"discussion_content":"def my_func4(l1):\n\tl1 = l1 + [4]\n\nl1 = [1, 2, 3]\nmy_func4(l1)\nl1\n[1, 2, 3]\n请问这样解释:l1+【4】是一个新变量重新让l1指向他，这时为什么外面的l1不变","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562138588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1149164,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/ec/1460179b.jpg","nickname":"我心飞扬","note":"","ucode":"E41155122C9A1F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4248,"discussion_content":"我来尝试给你解释一下。 首先，你应该可以理解，my_func4(l1)这里的l1只是一个代号，现在为了避免混淆，把这个函数定义里的l1换成p。\n1. 首先遇到函数体定义这两行，解释器只检查语法，没问题，但现在并不执行。\n2. l1定义为一个长度为3的数组。\n3. 对l1调用my_func4函数，跳转到函数体内。\n4. 现在p = [1,2,3]，l1 = [1,2,3]，两者指向的是同一个对象，连内存地址都一样。\n5. 这个函数执行的操作就是p = p + [4]，执行完之后，p不再指向[1,2,3]，而是指向了重新生成的另一个对象，[1,2,3,4]。现在的关系是 p = [1,2,3,4]，l1 = [1,2,3]，两者之间互相没有关系，同时p = [1，2，3，4]是存在于函数执行过程中的，如果在函数结束之前没有将这个值返回，那离开函数体时，p这个变量就会被销毁，即相当于执行了一个del p的操作。\n6. 现在跳出函数体，此时整个内存中就一个变量l1，它指向[1,2,3]。\n\n我觉得有必要说明的是对一个list以下三种操作方法的区别：\nx = [1,2,3]\n如果执行x = x + [4]，那x的值变成[1,2,3,4]，但这个新list并不是简单地在原来的list的尾部添了一个4，而是重新生成了一个新的list [1,2,3,4]，它与原来的[1,2,3]没有任何关系。此时如果原来的[1,2,3]还有其它变量在用，那就没什么操作，如果没有任何变量指向它，那它就会被收回，它占用的那个内存就会被释放。\n如果执行 x += [4]或者执行x.append(4)，那x的值同样便成[1,2,3,4]，但是内存地址没有变，新的list是在原来的那个内存地址上的[1,2,3]的基础上在尾部添加了一个元素4。\n\n‘a = a + b’的意义仅是赋值操作，在a自身原有的值的基础上进行“+”操作，并不是在自身原来指向的对象上进行操作，无论对于不可变类型int, string, tuple来说，还是对于有序的可变类型list来说，此操作都会切断与原对象的联系，然后生成新的对象，具体体现在内存值发生变化。（set和dict不支持‘+’操作）\n\n&#39;a += b&#39;， &#39;+=&#39;是拼接操作。对于不可变类型int, string, tuple来说，&#39;a += b&#39;可以看作是 &#39;a = a + b&#39;，所以同上，会重新生成新的对象；而对于可变类型list来说，此语句等效于 a.append(b)，因其可变，所以直接在原内存地址原对象上进行变化。set和dict均不支持此操作符。","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1565250403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":889,"ip_address":""},"score":4248,"extra":""},{"author":{"id":1545340,"avatar":"https://static001.geekbang.org/account/avatar/00/17/94/7c/b84eb0dd.jpg","nickname":"persie","note":"","ucode":"0050B6B4F9EB9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1149164,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/ec/1460179b.jpg","nickname":"我心飞扬","note":"","ucode":"E41155122C9A1F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5627,"discussion_content":"第一个l1是函数参数，你换成l2,l3也是一样的，不知道是否理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566392375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":889,"ip_address":""},"score":5627,"extra":""}]}]},{"had_liked":false,"id":103513,"user_name":"somenzz","can_delete":false,"product_type":"c1","uid":1187197,"ip_address":"","ucode":"EA59A170DF8910","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","comment_is_top":false,"comment_ctime":1560470641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"100344718449","product_id":100026901,"comment_content":"第一个比较简单，列表是可变对象，每创建一个列表，都会重新分配内存，因此 l1 和 l2 并不是同一个对象，由于 l3 = l2 表明 l3 指向 l2 的对象。<br><br>第二个 输出的结果应该是 {&#39;a&#39;: 10, &#39;b&#39;: 20} ，d = {&#39;a&#39;: 1, &#39;b&#39;: 2} 属于重新指向新的对象，并不改变原有的字典对象。","like_count":23},{"had_liked":false,"id":104079,"user_name":"yshan","can_delete":false,"product_type":"c1","uid":1136788,"ip_address":"","ucode":"A2ECDCDA52B8EE","user_header":"https://static001.geekbang.org/account/avatar/00/11/58/94/c8bc2b59.jpg","comment_is_top":false,"comment_ctime":1560617091,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"44510290051","product_id":100026901,"comment_content":"首先更正下，需要先定义d={}。<br>然后，局部变量与全局变量的区别，函数内定义的d为全局变量，在没有关键字声明的情形下不能改变全局变量，由于字典可变，遵循可变则可变的原则，输出为{&#39;a&#39;: 10, &#39;b&#39;: 20}。<br>最后，看实验：<br>def func(d):<br>    print(id(d))<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br>    print(id(d))<br>    d = {&#39;a&#39;:1, &#39;b&#39;:2}<br>    print(id(d))<br>    print(d)<br><br>d = {}<br>print(id(d))<br>func(d)<br>print(d)<br>print(id(d))<br><br>执行结果：<br>3072243980<br>3072243980<br>3072243980<br>3072244108<br>{&#39;a&#39;: 1, &#39;b&#39;: 2}<br>{&#39;a&#39;: 10, &#39;b&#39;: 20}<br>3072243980<br><br>","like_count":10,"discussions":[{"author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4249,"discussion_content":"总结：\n1. 对于传入函数的不可变类型int, string和tuple，想要使得初始的全局变量的值发生变化，函数内部必须有return语句。\n2. 对于传入函数的可变类型dict, set, list，如果没有对整体的赋值操作，函数内部变量发生变化时，对应的全局变量也同时发生变化。如果有对整体的赋值操作，则全局变量不受函数操作的影响。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1565251512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2369413,"avatar":"https://static001.geekbang.org/account/avatar/00/24/27/85/ddeeaf30.jpg","nickname":"dived","note":"","ucode":"141916A3BAF5A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1526614,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4b/56/6e4fa81b.jpg","nickname":"Leo","note":"","ucode":"A8C97D54966476","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374331,"discussion_content":"不完整啊,只写return返回值没意义，还要变量在外面接收函数返回值才行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621140956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4249,"ip_address":""},"score":374331,"extra":""}]}]},{"had_liked":false,"id":103717,"user_name":"程序员人生","can_delete":false,"product_type":"c1","uid":1113668,"ip_address":"","ucode":"C5C5073D89AAA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/44/3e3040ac.jpg","comment_is_top":false,"comment_ctime":1560496735,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35920235103","product_id":100026901,"comment_content":"第一题，用id（）打印出来后可以证明，l1和l2不是同一个对象，l2和l3是同一个对象。由于列表是可变的，所以l1和l2指向不同的内存区域。<br>第二题，做了一下修改，如下：<br>def func(d):<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br>    d={&#39;a&#39;:1,&#39;b&#39;:2}<br><br>d={}<br>func(d)<br>print(d)<br><br>执行结果：<br>{&#39;a&#39;: 10, &#39;b&#39;: 20}<br><br>d = {&#39;a&#39;: 1, &#39;b&#39;: 2}应该是指向了新的对象<br><br><br>","like_count":8,"discussions":[{"author":{"id":1217874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/95/52/ad190682.jpg","nickname":"Mr wind","note":"","ucode":"484F02D1962239","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":172237,"discussion_content":"这个例子可以，大家在编辑器中可以清楚看到提示 d={&#39;a&#39;:1,&#39;b&#39;:2} 提示d is not used","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581773623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":104106,"user_name":"Wing·三金","can_delete":false,"product_type":"c1","uid":1341402,"ip_address":"","ucode":"6B9F5822C3717F","user_header":"https://static001.geekbang.org/account/avatar/00/14/77/da/54c663f3.jpg","comment_is_top":false,"comment_ctime":1560653355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27330457131","product_id":100026901,"comment_content":"# C++<br><br>- 按值传递：拷贝参数的值构建新的变量传递到函数<br>- 按引用传递：把参数的引用（i.e. 地址）传递到函数<br><br># Python<br><br>- 按赋值传递&#47;按对象的引用传递<br>- 凡是对对象本身进行的操作，都会影响传递的原对象；凡是生成了新对象的操作，都不会影响传递的原对象<br>- 正如【一个人可以死两次，第一次是肉体死去，第二次是当没人记得它的时候】，python 中如果有多个变量指向同一个对象，那么当删除一个变量时并不会真正删除其所指定的对象；只有当所有指定该对象的变量都被删除时，python 才会回收该对象所占用的资源<br>- 一般原则：对于不可变的数据类型，operator 等操作会返回新的对象，不会影响原对象；对于可变的数据类型，任何对【对象本身】的操作都会影响所有指向该对象的变量<br>- 补充上一条：e.g. 对于 list 而言，l += [1] 和 l = l + [1] 不同！前者是在 l 本身的末尾添加新元素，后者是在 l 的基础上添加新的元素并返回新的对象<br>- 在工程上，偏爱类似于上一条后者的作法——即通过【创建新的对象+将其返回】的作法，来减少出错的概率<br><br># 思考题<br><br>1. l1 与 l2 不同，l3 与 l2 同；<br>2. 严格来说，如果没有上下文，这是一段错误的代码，因为没有预先定义 d 变量；不妨假设在第 6 行之前补充语句 d = {}，则输出结果为 {&#39;a&#39;: 10, &#39;b&#39;: 20}，因为 func 中前两行才是改变了对象的操作。而第 3 行只是将函数中的局部变量 d 指向了新的字典 {&#39;a&#39;: 1, &#39;b&#39;: 2}，但全局变量 d 仍然指向着刚刚被修改过的字典对象。","like_count":6},{"had_liked":false,"id":103558,"user_name":"SCAR","can_delete":false,"product_type":"c1","uid":1031209,"ip_address":"","ucode":"38C0927FA3C5FC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/29/022905e6.jpg","comment_is_top":false,"comment_ctime":1560472995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23035309475","product_id":100026901,"comment_content":"第一题：l2和l3指向同一个对象，l2和l1不指向同一个对象。这个题的关键要点是要了解list对象是没有“内存驻留”机制的，这点和整数对象对小于256的数采用的“内存驻留”是截然不同的，所以l1和l2不是指向同一对象。而l3=l2,这就是让l3指向l2指向的对象，很显然l3和l2指向的是同一个对象。<br>第二题：题目里的d = {&#39;a&#39;: 1, &#39;b&#39;: 2}应该是顶格的吧，估计是老师手误或是编辑器出问题了，不然没意义。如果是这样，print(d),输出应该是{&#39;a&#39;: 10, &#39;b&#39;: 20}。","like_count":5},{"had_liked":false,"id":138219,"user_name":"自由民","can_delete":false,"product_type":"c1","uid":1346236,"ip_address":"","ucode":"435C67531697F1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/bc/cb39ed38.jpg","comment_is_top":false,"comment_ctime":1570104768,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14455006656","product_id":100026901,"comment_content":"总结:Python中参数传递既不是传值也不是传引用，而是赋值传递，或传对象的引用。不是指向一个具体的内存地址，而是指向具体的对象。<br>如果对象是不变的，改变对象会新建一个对象，并将其中一个变量指向该对象，其它变量不变。如果对象是可变的，改变一个变量时，其它所有指向该对象的变量都会受影响。要想在函数中改变对象，可以传入可变数据类型(列表，字典，集合)，直接改变；也可以创建一个新对象，修改以后返回。建议用后者，表达清晰明了，不易出错。<br>思考题1:<br>l2与l3指向同一对象，与l1不同。<br># 思考题1<br> l1 = [1,2,3,4]<br> l2 = [1,2,3,4]<br> l3 = l2<br> print(id(l1), id(l2), id(l3))<br>思考题2<br>{&quot;a&quot;:10, &quot;b&quot;:20}<br>课程的练习代码: https:&#47;&#47;github.com&#47;zwdnet&#47;PythonPractice","like_count":3},{"had_liked":false,"id":230470,"user_name":"youaresherlock","can_delete":false,"product_type":"c1","uid":1281550,"ip_address":"","ucode":"B4D379C6B50DD4","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/0e/3fbc418d.jpg","comment_is_top":false,"comment_ctime":1593396010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10183330602","product_id":100026901,"comment_content":"Python应该是共享传参","like_count":2},{"had_liked":false,"id":146980,"user_name":"1cho糖糖","can_delete":false,"product_type":"c1","uid":1215443,"ip_address":"","ucode":"9B80BE53F1D433","user_header":"https://static001.geekbang.org/account/avatar/00/12/8b/d3/6ec3bfa1.jpg","comment_is_top":false,"comment_ctime":1572750684,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10162685276","product_id":100026901,"comment_content":"遇到了下面一个问题<br><br>```<br>def demo1(array):<br>    array += [4, 5]<br>    return array<br><br><br>def demo2(array):<br>    array = array + [4, 5]<br>    return array<br><br><br>a = [1, 2, 3]<br>b = [1, 2, 3]<br><br>c = demo1(a)<br>print(&#39;a list is {}\\nc list is {}\\na is c :{}&#39;.format(a, c, a is c))  # True<br># 输出结果<br>a list is [1, 2, 3, 4, 5]<br>c list is [1, 2, 3, 4, 5]<br>a is c :True<br><br>d = demo2(b)<br>print(&#39;b list is {}\\nd list is {}\\nb is d :{}&#39;.format(b, d, b is d))  # False<br># 输出结果<br>b list is [1, 2, 3]<br>d list is [1, 2, 3, 4, 5]<br>b is d :False<br><br># 函数内部为什么 array += [4, 5] 与 array = array + [4, 5] 对传入的列表影响结果不同<br>```","like_count":2,"discussions":[{"author":{"id":2043445,"avatar":"","nickname":"0235","note":"","ucode":"479A5357B7CE43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293980,"discussion_content":"我理解的是，demo1是在array本身上加4，5列表；而demo2是将array加上4，5列表后（此时已经是一个新的内存了）赋给一个新变量，而这个新变量恰好等于array而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595751383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103517,"user_name":"catshitfive","can_delete":false,"product_type":"c1","uid":1542973,"ip_address":"","ucode":"E030B61F3D0811","user_header":"https://static001.geekbang.org/account/avatar/00/17/8b/3d/2a3b67f8.jpg","comment_is_top":false,"comment_ctime":1560471068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150405660","product_id":100026901,"comment_content":"第一题：本例中，对于列表对象而言，l1和l2是不同的对象，l3指向的是l2，属于同一对象；对于列表内的immutable元素对象而言，这三个列表指向的都是相同的对象<br>第二题 使用数据结构中内置的方法或者切片操作会直接修改可变元素的内容而保持内存地址不变，如果是二个对象直接操作，则会创建新对象，所以本例中变量指向的字典内容会被函数更新<br>对于一维列表可以浅拷贝保存数据，对于二维及以上的，应该用深拷贝保存数据才安全","like_count":2},{"had_liked":false,"id":103492,"user_name":"KaitoShy","can_delete":false,"product_type":"c1","uid":1038415,"ip_address":"","ucode":"E2E2E9BD3F5048","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/4f/65abc6f0.jpg","comment_is_top":false,"comment_ctime":1560466172,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10150400764","product_id":100026901,"comment_content":"1. l2和l3是一个，l1不是。可以通过id(l2),id(l1),id(l3)验证。<br>2. d不是没有初始化么。输出错误吧。如果在使用函数func(),将d初始化为d={},输出{&#39;a&#39;:10, &#39;b&#39;:20}.原因：前两个改变了对象的值。后面是创建了新对象赋值给了本地对象。","like_count":2},{"had_liked":false,"id":275572,"user_name":"Jacky","can_delete":false,"product_type":"c1","uid":1387735,"ip_address":"","ucode":"B259184BC9E7B7","user_header":"https://static001.geekbang.org/account/avatar/00/15/2c/d7/5b1b09fd.jpg","comment_is_top":false,"comment_ctime":1611586542,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5906553838","product_id":100026901,"comment_content":"不可变对象，赋值给变量时，如果两个对象的值相同，则指向同一个对象。<br>两个变量指向同一对象，如果其中一个对象的值改变，则新建对象赋值给变量。<br>可变对象，赋值给变量时，如果两个对象的值相同，则指向不同对象。<br>两个变量指向同一对象，如果其中一个对象的值改变，两个变量的值都发生改变。（指向统一对象）","like_count":1},{"had_liked":false,"id":215808,"user_name":"轻风悠扬","can_delete":false,"product_type":"c1","uid":1319215,"ip_address":"","ucode":"F2276CE113BED1","user_header":"https://static001.geekbang.org/account/avatar/00/14/21/2f/b29e8af8.jpg","comment_is_top":false,"comment_ctime":1589107237,"is_pvip":true,"replies":[{"id":"79955","content":"l2 = l2 + [4]和l2 += [4]是一样的啊，程序运行的结果都是[1, 2, 3, 4]","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1589178263,"ip_address":"","comment_id":215808,"utype":1}],"discussion_count":7,"race_medal":0,"score":"5884074533","product_id":100026901,"comment_content":"老师，最后一个代码示例，如果我把l2 = l2 + [4] 换成 l2 += [4]，l1会变成[1,2,3,4].不明白l2 = l2 + [4] 换成 l2 += [4]有什么不一样的地方，有点小困惑<br><br>def my_func5(l2):<br>  l2 += [4]<br><br>l1 = [1, 2, 3]<br>my_func5(l1)<br>l1<br>[1, 2, 3, 4]","like_count":1,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494565,"discussion_content":"l2 = l2 + [4]和l2 += [4]是一样的啊，程序运行的结果都是[1, 2, 3, 4]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589178263,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1740208,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/8d/b0/520f65d4.jpg","nickname":"幻影","note":"","ucode":"E98DDC420A6E00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315995,"discussion_content":"对于列表来说，a += [4] 和 a = a+ [4] 确实不一样","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603345242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2064044,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7e/ac/4303e8ef.jpg","nickname":"Geek_b692f5","note":"","ucode":"C2826604F71C36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299583,"discussion_content":"如果想要更详细的了解 += 操作到底如何运行的，看官方文档：https://www.python.org/dev/peps/pep-0203/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597740968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2064044,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7e/ac/4303e8ef.jpg","nickname":"Geek_b692f5","note":"","ucode":"C2826604F71C36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299578,"discussion_content":"作者可能没看仔细，“+=”操作经过Python优化，等效于append操作，l2 = l2 + [4] 将新的list赋值给临时对象l2，并不会改变 l1 的值：\n>>> l=[1,2,3]\n>>> def f(a):\n...     a = a + [4]\n... \n>>> f(l)\n>>> l\n[1, 2, 3]\n>>> def ff(a):\n...     a += [4]\n... \n>>> ff(l)\n>>> l\n[1, 2, 3, 4]\n>>> \n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597738778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2064044,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7e/ac/4303e8ef.jpg","nickname":"Geek_b692f5","note":"","ucode":"C2826604F71C36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299585,"discussion_content":"原本以为自己用着Python挺熟练的，谁知道细节一大堆，果然整天琢磨一门编程语言和用工具的人，是两个世界的人","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597741112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2064044,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7e/ac/4303e8ef.jpg","nickname":"Geek_b692f5","note":"","ucode":"C2826604F71C36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299582,"discussion_content":"参见源码：https://github.com/python/cpython/blob/master/Objects/listobject.c\n\nstatic PyObject *\nlist_inplace_concat(PyListObject *self, PyObject *other)\n{\n    PyObject *result;\n\n    result = list_extend(self, other);\n    if (result == NULL)\n        return result;\n    Py_DECREF(result);\n    Py_INCREF(self);\n    return (PyObject *)self;\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597739922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2064044,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7e/ac/4303e8ef.jpg","nickname":"Geek_b692f5","note":"","ucode":"C2826604F71C36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299580,"discussion_content":"准确来说，list对象的 += 操作符，后面的参数是 iterable，和 list.extend 函数是同等的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597739491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103623,"user_name":"张丽娜","can_delete":false,"product_type":"c1","uid":1032331,"ip_address":"","ucode":"D70CFF68E72DAF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/8b/0371baee.jpg","comment_is_top":false,"comment_ctime":1560478410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855445706","product_id":100026901,"comment_content":"def my_func2(b):<br>    print(&#39;a的值是{}&#39;.format(a))<br>    print(&#39;b的值是{}&#39;.format(a))<br>    b = 2<br>    print(&#39;b的值是{}&#39;.format(b))<br>    return b<br><br><br>a = 1<br>a = my_func2(a)  #这句话so 重要，重新用返回值对于a进行了赋值，看起来debug来逐步分析很重要啊<br>print(&#39;a的值是{}&#39;.format(a))","like_count":1},{"had_liked":false,"id":103584,"user_name":"小恶魔","can_delete":false,"product_type":"c1","uid":1136450,"ip_address":"","ucode":"C2A6197CC74886","user_header":"https://static001.geekbang.org/account/avatar/00/11/57/42/bd500d0f.jpg","comment_is_top":false,"comment_ctime":1560474903,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5855442199","product_id":100026901,"comment_content":"看了这么多关于问题2回复都是结果。我想知道python中对参数赋值不会影响外部的值，这是设定语法，还有什么深层次的原因或设计考虑么，谢谢老师。","like_count":1,"discussions":[{"author":{"id":1528751,"avatar":"https://static001.geekbang.org/account/avatar/00/17/53/af/e5bf5d08.jpg","nickname":"lllong33","note":"","ucode":"5D012385994C3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":90,"discussion_content":"可变对象会影响外部的值，不可变对象不会影响。当然你也可以声明global(全局)和nonlocal(闭包，一层)来修改不可变对象的值。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561088948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356076,"user_name":"晁生贵","can_delete":false,"product_type":"c1","uid":2974279,"ip_address":"广东","ucode":"53EF39358E2BEE","user_header":"","comment_is_top":false,"comment_ctime":1661950501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661950501","product_id":100026901,"comment_content":"第一个 ，都是指向同一个对象<br>第二个，打印<br>{&#39;a&#39;: 10, &#39;b&#39;: 20}<br>","like_count":0},{"had_liked":false,"id":343640,"user_name":"Geek_145846","can_delete":false,"product_type":"c1","uid":2530478,"ip_address":"","ucode":"1DA77D13A8F19E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoAlkIjytYG8MqOtDf7n7pF3rXJnoMNL9ebRXluPvGh2e2A9TxyMoQxPyYQ1dInAFIeltwo8zuvhg/132","comment_is_top":false,"comment_ctime":1650964096,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650964096","product_id":100026901,"comment_content":"特别喜欢老师的专栏，把很多教程中没有说透的知识点说清楚了！","like_count":0},{"had_liked":false,"id":342046,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1649990076,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649990076","product_id":100026901,"comment_content":"这个参数传递，python和java 简直一样","like_count":0},{"had_liked":false,"id":338113,"user_name":"含章","can_delete":false,"product_type":"c1","uid":1434831,"ip_address":"","ucode":"A7CA116D5275C9","user_header":"https://static001.geekbang.org/account/avatar/00/15/e4/cf/906f47c9.jpg","comment_is_top":false,"comment_ctime":1647307510,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647307510","product_id":100026901,"comment_content":"<br>def my_func1(b):<br>  b = 2<br><br>a = 1<br>my_func1(a)<br>a<br>1<br><br>这里的参数传递，使变量 a 和 b 同时指向了 1 这个对象。但当我们执行到 b = 2 时，系统会重新创建一个值为 2 的新对象，并让 b 指向它；而 a 仍然指向 1 这个对象。所以，a 的值不变，仍然为 1。<br><br>这里的解释是不是有问题啊？","like_count":0},{"had_liked":false,"id":331875,"user_name":"王俊","can_delete":false,"product_type":"c1","uid":1640276,"ip_address":"","ucode":"7EDE3F56E10248","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJrIyCrRXMPXUQTR5IHNOh6niaY3MRr2mtv6W6WXcT1FHK1aic3NOhfzdaqfx3u8mmFAmibgX8xDdB2g/132","comment_is_top":false,"comment_ctime":1642845716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642845716","product_id":100026901,"comment_content":"编程规范里都不推荐吧可变对象作为方法的参数了","like_count":0},{"had_liked":false,"id":327304,"user_name":"qiu123456","can_delete":false,"product_type":"c1","uid":1333387,"ip_address":"","ucode":"71DC61AF12E8A5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/SXhZVacJlNR0lBbPib7peJbVlhsX8iaiaw2AdkfO8RTn0V7zoBvm5dWy4uvBehqTuOzlRFTG1r46Wz9GIiaMAHMvfA/132","comment_is_top":false,"comment_ctime":1640055315,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640055315","product_id":100026901,"comment_content":"思考题1<br>l1和l2不是同一个对象，l2和l3引用同一个对象<br>思考题2<br>由于d是字典，属于可变对象，因此函数内部的d不会新建一个对象，而是原有的对象，最后的结果是{&#39;a&#39;: 10, &#39;b&#39;: 20}","like_count":0},{"had_liked":false,"id":308957,"user_name":"苏苏","can_delete":false,"product_type":"c1","uid":1136433,"ip_address":"","ucode":"5FFD7F3B0F7F7A","user_header":"https://static001.geekbang.org/account/avatar/00/11/57/31/da42b783.jpg","comment_is_top":false,"comment_ctime":1629872135,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629872135","product_id":100026901,"comment_content":"python 这里是不是可以理解为如果是不可变对象，其实传递的是副本，如是可变对象传递的是引用地址","like_count":0},{"had_liked":false,"id":307430,"user_name":"小博主","can_delete":false,"product_type":"c1","uid":2712504,"ip_address":"","ucode":"4C7318ACFB9F40","user_header":"https://static001.geekbang.org/account/avatar/00/29/63/b8/4db57533.jpg","comment_is_top":false,"comment_ctime":1629098873,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629098873","product_id":100026901,"comment_content":"和上一届的浅拷贝和深拷贝一个道理吧","like_count":0},{"had_liked":false,"id":300611,"user_name":"罗辑","can_delete":false,"product_type":"c1","uid":1539649,"ip_address":"","ucode":"06AB60316B51C4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/OwZuBRbVUkziazePs2xTKskNpZachRtCBZLHlv4dAUgaBC5qHI292xaxvg3atGnHlDwjIOXPKEbc7zOrtMyicSNg/132","comment_is_top":false,"comment_ctime":1625246380,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1625246380","product_id":100026901,"comment_content":"请问老师：dict自带的copy方法是浅拷贝还是深拷贝？<br>d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br>f=d<br>g =d.copy()<br>print(id(d),id(f),id(g))<br>得到的结果。d和f指向同一个对象，g指向另外的对象。","like_count":0,"discussions":[{"author":{"id":1005520,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/d0/b9312769.jpg","nickname":"北斗(宇)","note":"","ucode":"9532B48D7C29C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541938,"discussion_content":"感觉你没理解浅拷贝，浅拷贝也是创建新对象的，只不过内部的元素，指向以前的元素对象，深拷贝，元素对象也会重新创建对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640609994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284176,"user_name":"cooper","can_delete":false,"product_type":"c1","uid":2321982,"ip_address":"","ucode":"27259668DC97B5","user_header":"https://static001.geekbang.org/account/avatar/00/23/6e/3e/874ec3c1.jpg","comment_is_top":false,"comment_ctime":1616114597,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1616114597","product_id":100026901,"comment_content":"为啥评论第二道思考题都会看错呢？明明写法是这样的：<br>def func(d):<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br><br>d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br>func(d)<br>print(d)<br><br>前面赋值了，都看不懂题目吗","like_count":0,"discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412578,"discussion_content":"很明显：在大家评论之后，正文被编辑了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1636211212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280799,"user_name":"道骨仙风的小松","can_delete":false,"product_type":"c1","uid":1244029,"ip_address":"","ucode":"778C17A8886106","user_header":"https://static001.geekbang.org/account/avatar/00/12/fb/7d/8f5941ac.jpg","comment_is_top":false,"comment_ctime":1614396163,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1614396163","product_id":100026901,"comment_content":"第一题：<br>尝试了 list，dict，set，变量l2，l3指向同一个对象，l1指向另一个对象。<br>尝试 str，tuple，int，变量l1，l2，l3均指向同一个对象<br>第二题：<br>打印d输出｛‘a’: 10, ‘b’:20}","like_count":0},{"had_liked":false,"id":270187,"user_name":"非同凡想","can_delete":false,"product_type":"c1","uid":1934969,"ip_address":"","ucode":"713FD449A49D5A","user_header":"https://static001.geekbang.org/account/avatar/00/1d/86/79/066a062a.jpg","comment_is_top":false,"comment_ctime":1608974337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608974337","product_id":100026901,"comment_content":"# l1为内存地址A<br># l2、l3同为内存地址B<br>l1 = [1, 2, 3]<br>l2 = [1, 2, 3]<br>l3 = l2<br>print(id(l1),id(l2),id(l3)) #2250115146248 2250115146312 2250115146312<br><br><br>#字段为可变对象，函数内部d和外部的d,指向同一块内存地址<br>def func(d):<br>    print(id(d)) # 1971630603576<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br>d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br>print(id(d))  # 1971630603576<br>func(d)<br>print(d)  #{&#39;a&#39;: 10, &#39;b&#39;: 20}","like_count":0},{"had_liked":false,"id":265358,"user_name":"Cal","can_delete":false,"product_type":"c1","uid":1582137,"ip_address":"","ucode":"9F2EF46687D18F","user_header":"https://static001.geekbang.org/account/avatar/00/18/24/39/5300ca6f.jpg","comment_is_top":false,"comment_ctime":1606877328,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1606877328","product_id":100026901,"comment_content":"l1 = [1,2,3]<br>l2 = [1,2,3]<br>l3 = l2<br><br>print(id(l1))<br>print(id(l2))<br>print(id(l3))<br>print(l1 is l2)<br>print(l1 == l2)<br><br>执行结果为:<br>1617861257160<br>1617851379848<br>1617851379848<br>False<br>True<br><br>可不可以这么理解，l1,l2属于不同的引用，但是他们都是指向同一个个对象。","like_count":0},{"had_liked":false,"id":239697,"user_name":"superhu0","can_delete":false,"product_type":"c1","uid":1971003,"ip_address":"","ucode":"391A93711EF549","user_header":"https://static001.geekbang.org/account/avatar/00/1e/13/3b/1c2a8d32.jpg","comment_is_top":false,"comment_ctime":1596619222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596619222","product_id":100026901,"comment_content":"总结中“如果对象不可变，简单的赋值只能改变其中一个变量的’值‘，其余变量则不受影响。”<br>这样说更贴合本意并更好理解：“如果对象不可变，变量重新赋值只能改变该变量所引用的对象，其余变量不受影响（即仍引用原对象）。”<br><br>另外，如果对象可变（l = [1,2,3]   # id(l) 为123）：<br>1、采取赋值（=）的方式对变量进行改变（l = l + []），相当于对变量l重新赋值了新的对象，前后两个l变量引用的是不同的对象。 # id(l) 为456<br>2、如果采用数据结构本身的方法（l.append([])），则相当于直接修改了该变量所引用的对象。# id(l) 为123        第2点我不知道说的对不对，或者不够全面，还请老师和专业大佬指正。","like_count":0},{"had_liked":false,"id":238483,"user_name":"Bee","can_delete":false,"product_type":"c1","uid":2086265,"ip_address":"","ucode":"3774D0CA746DA9","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d5/79/e1801426.jpg","comment_is_top":false,"comment_ctime":1596181169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596181169","product_id":100026901,"comment_content":"第一题：l1 l2是不同的对象，因为分别开辟了两个内存，l2 l3是同一个对象，因为l3和l2引用的同一块内存<br>第二题：因为传递的是一个可变的字典，所以在函数内修改字典的值，外部也会改变","like_count":0},{"had_liked":false,"id":232277,"user_name":"小西子","can_delete":false,"product_type":"c1","uid":2034865,"ip_address":"","ucode":"321C9C6075FFE2","user_header":"https://static001.geekbang.org/account/avatar/00/1f/0c/b1/f85dbb1e.jpg","comment_is_top":false,"comment_ctime":1593941007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593941007","product_id":100026901,"comment_content":"1.l1,l2都是指创建了新对象，分配了内存空间，l3,表示指向l2变量所指的对象<br><br>2.字典是可变对象，对象改变，会影响所有指向该对象的变量","like_count":0},{"had_liked":false,"id":221169,"user_name":"刘建武","can_delete":false,"product_type":"c1","uid":1986274,"ip_address":"","ucode":"0FFC88E0CA14EA","user_header":"","comment_is_top":false,"comment_ctime":1590420168,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590420168","product_id":100026901,"comment_content":"1） l1和l2不同，l2和l3相同。<br>2）因为：如果对象是可变的，当其改变时，所有指向这个对象的变量都会改变。<br>因此d是字典，因此里面会改变外面，输出为{&#39;a&#39;: 10, &#39;b&#39;: 20}。","like_count":0},{"had_liked":false,"id":220464,"user_name":"ShmilyVidian","can_delete":false,"product_type":"c1","uid":1177103,"ip_address":"","ucode":"2B2485B48B8D33","user_header":"https://static001.geekbang.org/account/avatar/00/11/f6/0f/0499db2c.jpg","comment_is_top":false,"comment_ctime":1590246742,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590246742","product_id":100026901,"comment_content":"第一题：l2和l3指向同一块内存地址，l1是独立一块内存地址<br>第二题：列表可变的，同一份引用地址，输出值为{a:10,b:20}","like_count":0},{"had_liked":false,"id":216066,"user_name":"LiuJ","can_delete":false,"product_type":"c1","uid":1937496,"ip_address":"","ucode":"EE4896E8E96B95","user_header":"https://static001.geekbang.org/account/avatar/00/1d/90/58/e2ab3dfe.jpg","comment_is_top":false,"comment_ctime":1589179672,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589179672","product_id":100026901,"comment_content":"第一个问题，l1 和 l2 指向的是不同对象，l2 和 l3 指向的是同一个对象；<br>第二个问题，输出的是 {&#39;a&#39;: 10, &#39;b&#39;: 20}。","like_count":0},{"had_liked":false,"id":202993,"user_name":"TristanDong","can_delete":false,"product_type":"c1","uid":1199392,"ip_address":"","ucode":"632B5E364C8AA8","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/20/9f430641.jpg","comment_is_top":false,"comment_ctime":1586098824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586098824","product_id":100026901,"comment_content":"对于单个列表和字典的传参，使用可变参数和关键字参数的方式是不是更好？那就不用考虑函数对于外部变量的影响了。","like_count":0},{"had_liked":false,"id":173119,"user_name":"大龄程序员在线治掉发","can_delete":false,"product_type":"c1","uid":1763091,"ip_address":"","ucode":"A246D4E4683589","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e7/13/6f76ada6.jpg","comment_is_top":false,"comment_ctime":1579427869,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579427869","product_id":100026901,"comment_content":"1.肯定不是<br>2.d是传递进来的值,不是重新赋值,你改变了他,后面也跟着改变","like_count":0},{"had_liked":false,"id":152048,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573865468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573865468","product_id":100026901,"comment_content":"思考题<br>l1 指向一个对象<br>l2和l3指向同一个对象<br><br>a ：10,b：2","like_count":0},{"had_liked":false,"id":150584,"user_name":"mercy","can_delete":false,"product_type":"c1","uid":1022225,"ip_address":"","ucode":"0843ACF5C72A17","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/11/9f09be94.jpg","comment_is_top":false,"comment_ctime":1573563018,"is_pvip":false,"replies":[{"id":"58225","content":"不一样的概念呢","user_name":"作者回复","user_name_real":"Jingxiao","uid":"1259521","ctime":1573711131,"ip_address":"","comment_id":150584,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573563018","product_id":100026901,"comment_content":"对象的id能否理解为指针","like_count":0,"discussions":[{"author":{"id":1259521,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJOlibibPFEWOib8ib7RtfAtxND5FUqCxxoeTuLAbBI9ic23xuwdXT4IyiaWq3Fic9RgEAYI0lBTbEp2rcg/132","nickname":"Jingxiao","note":"","ucode":"EB966BB87132F6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474207,"discussion_content":"不一样的概念呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573711131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150454,"user_name":"Arthur","can_delete":false,"product_type":"c1","uid":1334905,"ip_address":"","ucode":"A66B904766C443","user_header":"https://static001.geekbang.org/account/avatar/00/14/5e/79/0b56b7bd.jpg","comment_is_top":false,"comment_ctime":1573539534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573539534","product_id":100026901,"comment_content":"可变类型，按引用传递；不可变类型，按值传递。","like_count":0},{"had_liked":false,"id":132295,"user_name":"2020","can_delete":false,"product_type":"c1","uid":1344670,"ip_address":"","ucode":"0DEA914CDBE5B7","user_header":"https://static001.geekbang.org/account/avatar/00/14/84/9e/05ed50dd.jpg","comment_is_top":false,"comment_ctime":1568079990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568079990","product_id":100026901,"comment_content":"思考题一：<br>print(l1 is l2)  #False<br>print(l3 is l2)  #True<br>l1和l2指向的是不同对象，l3和l2指向同一对象。l2 = [1,2,3]，Python是直接新建了一个对象，然后将l2指向它，不是先在内存中查找是否存在相同值得对象是否已经创建过","like_count":0},{"had_liked":false,"id":132048,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1568013847,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568013847","product_id":100026901,"comment_content":"思考题1：<br>l1、l2指向不同的对象，l2和l3指向同一对象。<br><br>思考题2：<br>d最后的输出是：{&#39;a&#39;: 10, &#39;b&#39;: 20}","like_count":0},{"had_liked":false,"id":128290,"user_name":"R","can_delete":false,"product_type":"c1","uid":1248638,"ip_address":"","ucode":"165F104B71EAF2","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/7e/2f709bdf.jpg","comment_is_top":false,"comment_ctime":1566869043,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566869043","product_id":100026901,"comment_content":"请问老师，return返回b，b是一个引用，还是一个对象呢。","like_count":0},{"had_liked":false,"id":121214,"user_name":"木易","can_delete":false,"product_type":"c1","uid":1043508,"ip_address":"","ucode":"FF7396B53C2164","user_header":"","comment_is_top":false,"comment_ctime":1565079673,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1565079673","product_id":100026901,"comment_content":"为什么第一题中的l1和l2不指向同一个对象，但是a=1, b=1中的a和b却指向同一个对象？","like_count":0,"discussions":[{"author":{"id":1248307,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/33/c5026169.jpg","nickname":"hiyang","note":"","ucode":"E521EE72C0F247","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157218,"discussion_content":"不可变对象 immutable（整数、字符串、元组）本身不可变，不存在指向的内容被修改的可能，所以多个变量都能指向这块内存空间；\n可变对象（列表、字典）每次赋值都会开辟新的内存空间，来保证只有一个变量指向这块内存空间，避免指向的内容被修改的可能；\n描述可能不准确，但大概意思应该是对的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1580455901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118775,"user_name":"江南皮革厂研发中心保安队长","can_delete":false,"product_type":"c1","uid":1099584,"ip_address":"","ucode":"231419643A5CC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/40/66a203cd.jpg","comment_is_top":false,"comment_ctime":1564446878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1564446878","product_id":100026901,"comment_content":"老师，func4的原因我个人觉得跟作用域的关系比较大，不知道理解对不对","like_count":0},{"had_liked":false,"id":118766,"user_name":"江南皮革厂研发中心保安队长","can_delete":false,"product_type":"c1","uid":1099584,"ip_address":"","ucode":"231419643A5CC5","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/40/66a203cd.jpg","comment_is_top":false,"comment_ctime":1564446465,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1564446465","product_id":100026901,"comment_content":"老师，我试了 l2 = l2 + [4] 和 l2 += [4] 两个操作l2 的id值会不同，l2 += [4] 是不是和 l2.append(4)的效果是一模一样的啊？","like_count":0,"discussions":[{"author":{"id":1248307,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/33/c5026169.jpg","nickname":"hiyang","note":"","ucode":"E521EE72C0F247","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":157209,"discussion_content":"我理解 l2+=[4]等价于 l2=l2+[4]，之所以 id 不一样，是因为可变对象赋值后会开辟新的内存空间。l2.append(4) 是在 list 末未追加，id 不变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580455161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111636,"user_name":"清风","can_delete":false,"product_type":"c1","uid":1260138,"ip_address":"","ucode":"75FE83C1309C2D","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/6a/daf11ddd.jpg","comment_is_top":false,"comment_ctime":1562576540,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1562576540","product_id":100026901,"comment_content":"请教一个问题<br>a=1000<br>内存中会开辟两块空间分别存这两个值吗？<br>是在内存中还是在寄存器，还是在几级缓存里？","like_count":0,"discussions":[{"author":{"id":1005520,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/d0/b9312769.jpg","nickname":"北斗(宇)","note":"","ucode":"9532B48D7C29C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541943,"discussion_content":"内存里，建议你看看计算机组成原理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640610632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109726,"user_name":"且听疯吟","can_delete":false,"product_type":"c1","uid":1159459,"ip_address":"","ucode":"B010B16E5465F4","user_header":"https://static001.geekbang.org/account/avatar/00/11/b1/23/5df1f341.jpg","comment_is_top":false,"comment_ctime":1562082680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562082680","product_id":100026901,"comment_content":"第一题中，<br>l1 = [1, 2, 3]<br>l2 = [1, 2, 3]<br>l3 = l2<br>l1 与 l2表示不同的对象，l3 = l2表示l3指向l2, 与l2为同一对象。<br><br>def func(d):<br>    d[&#39;a&#39;] = 10<br>\td[&#39;b&#39;] = 20<br><br>d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br>func(d)<br>print(d)<br><br>改变了d的值","like_count":0},{"had_liked":false,"id":108849,"user_name":"magician","can_delete":false,"product_type":"c1","uid":1483968,"ip_address":"","ucode":"1BD1125C7C907A","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/c0/c6880c07.jpg","comment_is_top":false,"comment_ctime":1561900709,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561900709","product_id":100026901,"comment_content":"1.l2,l3指向相同对象，l1指向另一个对象<br>2.d={&#39;a&#39;:  10, &#39;b&#39;: 20}","like_count":0},{"had_liked":false,"id":108499,"user_name":"flying","can_delete":false,"product_type":"c1","uid":1298279,"ip_address":"","ucode":"69AB7872B36B23","user_header":"https://static001.geekbang.org/account/avatar/00/13/cf/67/057e5d93.jpg","comment_is_top":false,"comment_ctime":1561785682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561785682","product_id":100026901,"comment_content":"提个问题，func3和func5，老师更倾向于func5，因为清晰明了，明确l1发生了变化。这确实是一个优点，但是如果list很大，占了很多内存，func5的做法是不是效率就特别低了？因为要讲list里面的值copy一份到另一个空间。","like_count":0},{"had_liked":false,"id":107033,"user_name":"小胖","can_delete":false,"product_type":"c1","uid":1022958,"ip_address":"","ucode":"1B8D884D254070","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/ee/8950c240.jpg","comment_is_top":false,"comment_ctime":1561442212,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561442212","product_id":100026901,"comment_content":"1、 l1 和 l2不是指向同一个对象，l2和l3是指向同一个对象<br>2、{&#39;a&#39;: 10, &#39;b&#39;: 20}","like_count":0},{"had_liked":false,"id":106636,"user_name":"水木湘","can_delete":false,"product_type":"c1","uid":1248580,"ip_address":"","ucode":"244145E95FBC64","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/44/ae66732d.jpg","comment_is_top":false,"comment_ctime":1561361705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561361705","product_id":100026901,"comment_content":"能理解C中的指针就能轻松理解python的赋值和引用了","like_count":0},{"had_liked":false,"id":106172,"user_name":"Monroe  He","can_delete":false,"product_type":"c1","uid":1348219,"ip_address":"","ucode":"D04ECB2EF2E0DA","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/7b/8c7e3e61.jpg","comment_is_top":false,"comment_ctime":1561194632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561194632","product_id":100026901,"comment_content":"Python里所有的数据类型都是对象。Python中分可变对象（列表、集合、字典）与不可变对象（字符串、整型、元组)<br>对于可变对象的参数传递（对象的引用传递），因为对象可变，当改变对象时，所有指向这个对象的变量值都会改变。<br>对于不可变对象的赋值与参数传递，改变对象只能新建一个对象，原对象与新建对象之间没有联系，只改变新建对象与之相联系变量的值。<br>思考题：<br>1、l2与l3指向同一个对象，l1指向另一个对象。<br>因为列表是可变对象，当为变量赋值时会新建列表，只有显示赋值另一个变量时，才指向同一个对象。<br>2、{&#39;a&#39;: 10, &#39;b&#39;: 20}","like_count":0},{"had_liked":false,"id":106094,"user_name":"爬行的蜗牛","can_delete":false,"product_type":"c1","uid":1033956,"ip_address":"","ucode":"6623B62DE63CE9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/QD6bf8hkS5dHrabdW7M7Oo9An1Oo3QSxqoySJMDh7GTraxFRX77VZ2HZ13x3R4EVYddIGXicRRDAc7V9z5cLDlA/132","comment_is_top":false,"comment_ctime":1561172823,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561172823","product_id":100026901,"comment_content":"1. 是的。 <br>2. {a:10, b:20 } 因为字典对象是可变的。","like_count":0},{"had_liked":false,"id":105540,"user_name":"cuikt","can_delete":false,"product_type":"c1","uid":1242702,"ip_address":"","ucode":"9A1DB426CEFEEA","user_header":"https://static001.geekbang.org/account/avatar/00/12/f6/4e/0066303c.jpg","comment_is_top":false,"comment_ctime":1561024917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561024917","product_id":100026901,"comment_content":"老师你好，有个问题请教一下，如果在函数内部创建新的对象并且返回的话，那么已有的对象是不是需要等到python解释器GC后才会释放，这样是否会增加python的内存消耗？","like_count":0},{"had_liked":false,"id":105448,"user_name":"图·美克尔","can_delete":false,"product_type":"c1","uid":1076720,"ip_address":"","ucode":"021FB5AE110066","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eppQqDE6TNibvr3DNdxG323AruicIgWo5DpVr6U7yZVNkbF2rKluyDfhdpgAEcYEOZTAnbrMdTzFkUw/0","comment_is_top":false,"comment_ctime":1561002932,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1561002932","product_id":100026901,"comment_content":"深拷贝是否等价于值传递？浅拷贝是否等价于引用传递或者赋值传递？","like_count":0},{"had_liked":false,"id":105178,"user_name":"converse✪","can_delete":false,"product_type":"c1","uid":1433812,"ip_address":"","ucode":"0CC4C24A6458B6","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/d4/bdd3ed27.jpg","comment_is_top":false,"comment_ctime":1560933658,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560933658","product_id":100026901,"comment_content":"思考1：L1和L2都进行初始化，分配不同的内存空间，所以指向的不同对象，而L2和L3是赋值得到的，指向同一对象。<br>思考2：字典是可变的，所以提前猜测是可以改变为 {&#39;a&#39;: 10, &#39;b&#39;: 20}的。<br>但是在突然想到文章中的list例子无返回也不能改变？<br>在例子中用到的是<br>    def func(l):<br>        l = l+[4]<br>d = [1,2,3]<br>func(d)<br>print(d)<br>这是创建了新的列表赋值给新的l，而不影响外面的d。<br>但是如果函数中是<br>    def func(l):<br>        l += [4]<br>或者<br>    def func(l):<br>        l.append(4)<br>由于l和d指向同一对象，而list可变，可以直接在列表末尾加上数字，所以不用返回也可以改变外面的值。list数据类型的+=操作符应该是重载了，实现效果和append一致。","like_count":0},{"had_liked":false,"id":104722,"user_name":"乔克","can_delete":false,"product_type":"c1","uid":1315273,"ip_address":"","ucode":"28A797A4235B78","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/c9/c3eae895.jpg","comment_is_top":false,"comment_ctime":1560822068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560822068","product_id":100026901,"comment_content":"（1）、l1 = [1,2,3]，创建一块内存区域指向l1，l2 = [1,2,3]，创建另一块内存区域指向l2，l3=l2，表示l3和l2指向同一块内存区域，它们的id是一样的。<br>（2）、字典的键是不可变的，值是可变的，所以d的值是{&#39;a&#39;: 10, &#39;b&#39;: 20}","like_count":0},{"had_liked":false,"id":104446,"user_name":"周平","can_delete":false,"product_type":"c1","uid":1047936,"ip_address":"","ucode":"CA1869B139A4F6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fd/80/52763d62.jpg","comment_is_top":false,"comment_ctime":1560756318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560756318","product_id":100026901,"comment_content":"思考题：<br>1.L2和L3变量指向同一个对象，而L1变量指向另一个变量<br>2. d={}<br>def func(d):<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br>    d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br><br><br>d=func(d)<br>print(d)<br><br>打印结果是{&#39;a&#39;: 10, &#39;b&#39;: 20}，指向新对象的变量没有赋值给d，d还是指向原对象","like_count":0},{"had_liked":false,"id":104354,"user_name":"Feng","can_delete":false,"product_type":"c1","uid":1015205,"ip_address":"","ucode":"42DB60B7BF69D0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/a5/930c9103.jpg","comment_is_top":false,"comment_ctime":1560735796,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1560735796","product_id":100026901,"comment_content":"函数中的参数d用另一个名称def func(v)代替会不会好理解些","like_count":0},{"had_liked":false,"id":104206,"user_name":"Danpier","can_delete":false,"product_type":"c1","uid":1463474,"ip_address":"","ucode":"11E208FDE34961","user_header":"https://static001.geekbang.org/account/avatar/00/16/54/b2/5ea0b709.jpg","comment_is_top":false,"comment_ctime":1560680981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560680981","product_id":100026901,"comment_content":"Python del 语句只删除对象的引用，那如果要销毁对象释放内存，除了粗暴的 del + gc.collect() 还有什么方法吗？","like_count":0},{"had_liked":false,"id":104060,"user_name":"路伴友行","can_delete":false,"product_type":"c1","uid":1506974,"ip_address":"","ucode":"96B54B7EEAEDAD","user_header":"https://static001.geekbang.org/account/avatar/00/16/fe/9e/8165b0a0.jpg","comment_is_top":false,"comment_ctime":1560607225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560607225","product_id":100026901,"comment_content":"emmm  思考题2的那个函数缩减是认真的吗？","like_count":0},{"had_liked":false,"id":104054,"user_name":"小侠龙旋风","can_delete":false,"product_type":"c1","uid":1126441,"ip_address":"","ucode":"073F3924A99835","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/29/d6816ebf.jpg","comment_is_top":false,"comment_ctime":1560605251,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560605251","product_id":100026901,"comment_content":"第一题：l2和l3指向同一个对象，l1和它们不同。可用id()测试查看。<br>第二题：字典的d[&#39;a&#39;] = 10此类操作相当于list的append函数，不会创建一个新的字典，而是在原字典中添加or改变key和value。函数中的局部变量d和函数外的全局变量d都被改成{&#39;a&#39;:10,&#39;b&#39;:20}后，局部变量d又指向了新创建的字典对象{&#39;a&#39;:1,&#39;b&#39;:2}。打印输出的是全局变量d，所以是{&#39;a&#39;:10,&#39;b&#39;:20}。","like_count":0},{"had_liked":false,"id":103801,"user_name":"Fergus","can_delete":false,"product_type":"c1","uid":1277066,"ip_address":"","ucode":"3A8AC741C49CEB","user_header":"https://static001.geekbang.org/account/avatar/00/13/7c/8a/bdeb76ac.jpg","comment_is_top":false,"comment_ctime":1560516030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560516030","product_id":100026901,"comment_content":"答1：是<br>答2：看完文章以为自己懂了，通过这个题才真正学会区分：改变变量 &amp; 重新赋值。<br>d = {}<br><br>def func(d):<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br>    d = {&#39;a&#39;:1, &#39;b&#39;:2}<br><br>func(d)<br><br>d<br>Out[13]: {&#39;a&#39;: 10, &#39;b&#39;: 20}<br><br>def func(d):<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br>    d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br><br>d<br>Out[15]: {&#39;a&#39;: 10, &#39;b&#39;: 20}<br><br>a = {}<br><br>a[&#39;a&#39;] = 1<br><br>a[&#39;b&#39;] = 2<br><br>a<br>Out[19]: {&#39;a&#39;: 1, &#39;b&#39;: 2}<br><br>a = {&#39;a&#39;: 2, &#39;b&#39;: 4}<br><br>a<br>Out[21]: {&#39;a&#39;: 2, &#39;b&#39;: 4}","like_count":0},{"had_liked":false,"id":103793,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1138652,"ip_address":"","ucode":"8DE0C2FD586EFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/dc/1e1f28b4.jpg","comment_is_top":false,"comment_ctime":1560513933,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560513933","product_id":100026901,"comment_content":"感觉和Java还是挺像的","like_count":0},{"had_liked":false,"id":103764,"user_name":"lipan","can_delete":false,"product_type":"c1","uid":1347460,"ip_address":"","ucode":"76E2CEEE454017","user_header":"https://static001.geekbang.org/account/avatar/00/14/8f/84/2c2d8c47.jpg","comment_is_top":false,"comment_ctime":1560505485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560505485","product_id":100026901,"comment_content":"第一题：l2和l3指向同一个对象，l1指向另一个对象。<br>第二题：打印结果是{&#39;a&#39;: 10, &#39;b&#39;: 20}<br><br>另外，无祖看不习惯，改成元组就更好了^^","like_count":0},{"had_liked":false,"id":103711,"user_name":"tux","can_delete":false,"product_type":"c1","uid":1477811,"ip_address":"","ucode":"BB7202009FC885","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/b3/a74a7125.jpg","comment_is_top":false,"comment_ctime":1560496403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560496403","product_id":100026901,"comment_content":"总能见到老朋友的身影","like_count":0},{"had_liked":false,"id":103709,"user_name":"John Si","can_delete":false,"product_type":"c1","uid":1526611,"ip_address":"","ucode":"705B90724A4BD4","user_header":"https://static001.geekbang.org/account/avatar/00/17/4b/53/67c08006.jpg","comment_is_top":false,"comment_ctime":1560496170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560496170","product_id":100026901,"comment_content":"1. 每次创建一个新的可变对象如列表，字典等，内存会分配一个新的位置给它，故l1, 与l2, l3所指向的位置有所不同，而l2 与l3 是浅复制关系，故l2,l3均指向同一位置<br><br>2. 在调用函数时，字典d 作为对象传入函数中，并透过d[&#39;a&#39;] = 10, d[&#39;b&#39;] = 20 赋值, 其后d = {&#39;a&#39;:1, &#39;b &#39;:2} 语句等于创建一个新字典,会重新分配位置给它，因此该字典跟外部字典是两个不同的对象，故答案为：{&#39;a&#39;:10, &#39;b&#39;:20}.<br><br>3.老师好，请看下列代码，如果一个函数返回None, Python会创建一个None 对象，并让该变量指向它，对吗？如果一个变量指向None，Python 会如何处理该变量呢？ Python会把它删除还是继续保留呢？恳请老师解讲一下，谢谢！ <br><br>def my_func1(a):<br>     b = 2<br>a = 1<br>print(&#39;before id(a):{} &#39;.format(id(a)))<br>a = my_func1(a)<br>print(&#39;After id(a):{}&#39;.format(id(a)))<br>print(a)<br>＝＝＝＝＝＝＝＝＝<br>Before id(a):4399348912 <br>After id(a):4399046760<br>None<br><br>","like_count":0},{"had_liked":false,"id":103699,"user_name":"刘朋","can_delete":false,"product_type":"c1","uid":1075141,"ip_address":"","ucode":"7B7B8E4776C22E","user_header":"https://static001.geekbang.org/account/avatar/00/10/67/c5/63b09189.jpg","comment_is_top":false,"comment_ctime":1560493794,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560493794","product_id":100026901,"comment_content":"第一个问题: <br>并不是指向同一个对象. l2 和 l3 指向同一个对象, l1 和 l2&#47;l3 指向不同的对象.<br><br>第二个问题:<br>如果按示例给出的代码,则会报错, 提示 d 没有被定义.<br><br>如果改为如下:<br>def func(d):<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br>    d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br><br>d = {}<br>func(d)<br>print(d)<br><br>则结果返回: {&#39;a&#39;: 10, &#39;b&#39;: 20}","like_count":0},{"had_liked":false,"id":103698,"user_name":"kevinsu","can_delete":false,"product_type":"c1","uid":1078506,"ip_address":"","ucode":"BAD46B815D6A5C","user_header":"https://static001.geekbang.org/account/avatar/00/10/74/ea/10661bdc.jpg","comment_is_top":false,"comment_ctime":1560493573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560493573","product_id":100026901,"comment_content":"第一题：<br>l1 = [1,2,3]<br>l2 = [1,2,3]<br>print(id(l1),id(l2))<br>l3 = l2<br>print(id(l3))<br>4404613192 4404466760<br>4404466760<br>so l1指向一个，l2和l3指向同一个<br><br>第二题：<br>d没有定义，NameError: name &#39;d&#39; is not defined","like_count":0},{"had_liked":false,"id":103666,"user_name":"吴小智","can_delete":false,"product_type":"c1","uid":1310798,"ip_address":"","ucode":"C7C9F58B5C9F7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","comment_is_top":false,"comment_ctime":1560485382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560485382","product_id":100026901,"comment_content":"赞了，文章讲的都是自己之前没怎么关注的点","like_count":0},{"had_liked":false,"id":103661,"user_name":"炸糕","can_delete":false,"product_type":"c1","uid":1334386,"ip_address":"","ucode":"B93B5D72F67542","user_header":"https://static001.geekbang.org/account/avatar/00/14/5c/72/fc5fd68a.jpg","comment_is_top":false,"comment_ctime":1560484555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560484555","product_id":100026901,"comment_content":"第二个问题应该是这么缩进的吧<br><br>def func(d):<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br><br>d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br><br>func(d)<br>print(d)<br>","like_count":0},{"had_liked":false,"id":103635,"user_name":"夜路破晓","can_delete":false,"product_type":"c1","uid":1353577,"ip_address":"","ucode":"9B875F94B759B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3hZfficKPGCq2kjFBu9SgaMjibJTEl7iaW1ta6pZNyiaWP8XEsNpunlnsiaOtBpWTXfT5BvRP3qNByml6p9rtBvqewg/132","comment_is_top":false,"comment_ctime":1560480007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560480007","product_id":100026901,"comment_content":"在Python中，变量就好比是那只指着太阳说日的猴子，那对象就是太阳咯。<br>我爱我的老婆！","like_count":0},{"had_liked":false,"id":103619,"user_name":"张丽娜","can_delete":false,"product_type":"c1","uid":1032331,"ip_address":"","ucode":"D70CFF68E72DAF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/8b/0371baee.jpg","comment_is_top":false,"comment_ctime":1560477946,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1560477946","product_id":100026901,"comment_content":"有些不理解，为什么return之后，a的值就会变化<br>def my_func2(b):<br>    b = 2<br>    return b<br><br><br>a = 1<br>a = my_func2(a)<br>print(a)","like_count":0,"discussions":[{"author":{"id":1032331,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c0/8b/0371baee.jpg","nickname":"张丽娜","note":"","ucode":"D70CFF68E72DAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245348,"discussion_content":"非常感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587656052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1764941,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ee/4d/5d021e4c.jpg","nickname":"向左看齐","note":"","ucode":"2E0AC7D59AF85C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241765,"discussion_content":"# a指向1\na = my_func2(a)  #b指向1，b断开指向2，函数返回2给a\n对比看：\ndef my_fun1(b):\n    b = 2\n\na = 1\nmy_fun1(a)\nprint(a)\n# 1\n#a指向1，b先指向1，断开指向2\n\ndef my_fun2(b):\n  b = 2\n  return b\n\n\na = 1\na = my_fun2(a)\nprint(a)\n# 2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587439243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103613,"user_name":"张丽娜","can_delete":false,"product_type":"c1","uid":1032331,"ip_address":"","ucode":"D70CFF68E72DAF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/8b/0371baee.jpg","comment_is_top":false,"comment_ctime":1560477461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560477461","product_id":100026901,"comment_content":"l1 4386000712<br>l2 4386000776<br>l3 4386000776","like_count":0},{"had_liked":false,"id":103610,"user_name":"张丽娜","can_delete":false,"product_type":"c1","uid":1032331,"ip_address":"","ucode":"D70CFF68E72DAF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/8b/0371baee.jpg","comment_is_top":false,"comment_ctime":1560477332,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560477332","product_id":100026901,"comment_content":"原来是缩进有问题啊。<br>def func(d):<br>    # d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br>    d[&#39;a&#39;] = 10<br>    d[&#39;b&#39;] = 20<br><br><br>d = {&#39;a&#39;: 1, &#39;b&#39;: 2}<br>func(d)<br>print(d)<br>","like_count":0},{"had_liked":false,"id":103598,"user_name":"Geek_d848f7","can_delete":false,"product_type":"c1","uid":1524021,"ip_address":"","ucode":"F24BC59B6E9E6B","user_header":"","comment_is_top":false,"comment_ctime":1560476034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560476034","product_id":100026901,"comment_content":"题目一：\r   l3 和 l2指向的是同一个对象[1,2,3]，l1不是\r题目2：\r  d没有初始化，直接报错？猜测应该是缩进问题，如果：d[&#39;b&#39;]=20在函数内，则print(d) 结果为：{&#39;a&#39;: 10, &#39;b&#39;: 20}","like_count":0},{"had_liked":false,"id":103597,"user_name":"张丽娜","can_delete":false,"product_type":"c1","uid":1032331,"ip_address":"","ucode":"D70CFF68E72DAF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/8b/0371baee.jpg","comment_is_top":false,"comment_ctime":1560476027,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560476027","product_id":100026901,"comment_content":"第2题有些不理解，我觉得输出应该是a:1, b:2.一会儿外电脑上实际操作下","like_count":0},{"had_liked":false,"id":103570,"user_name":"Hoo-Ah","can_delete":false,"product_type":"c1","uid":1306913,"ip_address":"","ucode":"823093A6C7DEE7","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/21/52e8267b.jpg","comment_is_top":false,"comment_ctime":1560473890,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560473890","product_id":100026901,"comment_content":"第一个问题：l2和l3指向同一个对象；第二个问题：传入的d没有赋值？<br>假设传入的是个字典，那么d里面有两个键a和b，分别指向10和20。","like_count":0},{"had_liked":false,"id":103520,"user_name":"里昂.玛蒂达","can_delete":false,"product_type":"c1","uid":1541974,"ip_address":"","ucode":"703097D99C8109","user_header":"https://static001.geekbang.org/account/avatar/00/17/87/56/9ec5c90d.jpg","comment_is_top":false,"comment_ctime":1560471224,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560471224","product_id":100026901,"comment_content":"如果函数的参数是可变类型的，在外部定义一个列表，传递到函数内部的时候，按照py的参数传递原理对象的引用传递，这个变量的作用域怎么理解，在函数内部并没有发生内存拷贝，同时在函数返回变量的时候，相当于这个函数内的变量作用域会消失的吧？是否会发生内存拷贝到外部的全局变量？还是将函数内部的对象引用到外部变量？这块一直不是很理解。希望解答一下，谢谢","like_count":0},{"had_liked":false,"id":103484,"user_name":"farFlight","can_delete":false,"product_type":"c1","uid":1245211,"ip_address":"","ucode":"B0872D3ECBEC38","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epbRibsic15KXfGEN3SSjnLhXGyhK2Uyrj5ibBJsKAjicNqtafDaQOLH4xpSJRZD1vmibFPJER1ySmwP9A/132","comment_is_top":false,"comment_ctime":1560449686,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560449686","product_id":100026901,"comment_content":"第一题：<br>l2和l3是同一个对象，而l1不是。<br><br>第二题的缩进应该是错了，在函数中可变数据类型字典的值是会修改字典本身的。<br>运行后会得到d[&#39;a&#39;] = 10; d[&#39;b&#39;] = 20;<br><br>“创建一个新变量，来保存修改后的值，然后将其返回给原变量”。对于修改字典或者按索引修改列表的函数而言，是否要在函数中采用深度拷贝的方式来创造新变量呢？<br><br>","like_count":0}]}