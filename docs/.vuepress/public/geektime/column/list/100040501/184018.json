{"id":184018,"title":"16 | 函数对象和lambda：进入函数式编程","content":"<p>你好，我是吴咏炜。</p><p>本讲我们将介绍函数对象，尤其是匿名函数对象——lambda 表达式。今天的内容说难不难，但可能跟你的日常思维方式有较大的区别，建议你一定要试验一下文中的代码（使用 xeus-cling 的同学要注意：xeus-cling 似乎不太喜欢有 lambda 的代码😓；遇到有问题时，还是只能回到普通的编译执行方式了）。</p><h2>C++98 的函数对象</h2><p>函数对象（function object）<span class=\"orange\">[1]</span> 自 C++98 开始就已经被标准化了。从概念上来说，函数对象是一个可以被当作函数来用的对象。它有时也会被叫做 functor，但这个术语在范畴论里有着完全不同的含义，还是不用为妙——否则玩函数式编程的人可能会朝着你大皱眉头的。</p><p>下面的代码定义了一个简单的加 <em>n</em> 的函数对象类（根据一般的惯例，我们使用了 <code>struct</code> 关键字而不是 <code>class</code> 关键字）：</p><pre><code class=\"language-c++\">struct adder {\n  adder(int n) : n_(n) {}\n  int operator()(int x) const\n  {\n    return x + n_;\n  }\nprivate:\n  int n_;\n};\n</code></pre><p>它看起来相当普通，唯一有点特别的地方就是定义了一个 <code>operator()</code>，这个运算符允许我们像调用函数一样使用小括号的语法。随后，我们可以定义一个实际的函数对象，如 C++11 形式的：</p><!-- [[[read_end]]] --><pre><code class=\"language-c++\">auto add_2 = adder(2);\n</code></pre><p>或 C++98 形式的：</p><pre><code class=\"language-c++\">adder add_2(2);\n</code></pre><p>得到的结果 <code>add_2</code> 就可以当作一个函数来用了。你如果写下 <code>add_2(5)</code> 的话，就会得到结果 7。</p><p>C++98 里也定义了少数高阶函数：你可以传递一个函数对象过去，结果得到一个新的函数对象。最典型的也许是目前已经从 C++17 标准里移除的 <code>bind1st</code> 和 <code>bind2nd</code> 了（在 &lt;functional&gt; 头文件中提供）：</p><pre><code class=\"language-c++\">auto add_2 = bind2nd(plus&lt;int&gt;(), 2);\n</code></pre><p>这样产生的 <code>add_2</code> 功能和前面相同，是把参数 <code>2</code> 当作第二个参数绑定到函数对象 <code>plus&lt;int&gt;</code>（它的 <code>operator()</code> 需要两个参数）上的结果。当然，<code>auto</code> 在 C++98 里是没有的，结果要赋给一个变量就有点别扭了，得写成：</p><pre><code class=\"language-c++\">binder2nd&lt;plus&lt;int&gt; &gt; add_2(\n  plus&lt;int&gt;(), 2);\n</code></pre><p>因此，在 C++98 里我们通常会直接使用绑定的结果：</p><pre><code class=\"language-c++\">#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvector v{1, 2, 3, 4, 5};\ntransform(v.begin(), v.end(),\n          v.begin(),\n          bind2nd(plus&lt;int&gt;(), 2));\n</code></pre><p>上面的代码会将容器里的每一项数值都加上 2（<code>transform</code> 函数模板在 &lt;algorithm&gt; 头文件中提供）。可以验证结果：</p><pre><code class=\"language-c++\">v\n</code></pre><blockquote>\n<p><code>{ 3, 4, 5, 6, 7 }</code></p>\n</blockquote><h3>函数的指针和引用</h3><p>除非你用一个引用模板参数来捕捉函数类型，传递给一个函数的函数实参会退化成为一个函数指针。不管是函数指针还是函数引用，你也都可以当成函数对象来用。</p><p>假设我们有下面的函数定义：</p><pre><code class=\"language-c++\">int add_2(int x)\n{\n  return x + 2;\n};\n</code></pre><p>如果我们有下面的模板声明：</p><pre><code class=\"language-c++\">template &lt;typename T&gt;\nauto test1(T fn)\n{\n  return fn(2);\n}\n\ntemplate &lt;typename T&gt;\nauto test2(T&amp; fn)\n{\n  return fn(2);\n}\n\ntemplate &lt;typename T&gt;\nauto test3(T* fn)\n{\n  return (*fn)(2);\n}\n</code></pre><p>当我们拿 <code>add_2</code> 去调用这三个函数模板时，<code>fn</code> 的类型将分别被推导为 <code>int (*)(int)</code>、<code>int (&amp;)(int)</code> 和 <code>int (*)(int)</code>。不管我们得到的是指针还是引用，我们都可以直接拿它当普通的函数用。当然，在函数指针的情况下，我们直接写 <code>*value</code> 也可以。因而上面三个函数拿 <code>add_2</code> 作为实参调用的结果都是 <code>4</code>。</p><p>很多接收函数对象的地方，也可以接收函数的指针或引用。但在个别情况下，需要通过函数对象的类型来区分函数对象的时候，就不能使用函数指针或引用了——原型相同的函数，它们的类型也是相同的。</p><h2>Lambda 表达式</h2><p>Lambda 表达式 <span class=\"orange\">[2]</span> 是一个源自阿隆佐·邱奇（Alonzo Church）——艾伦·图灵（Alan Turing）的老师——的术语。邱奇创立了 λ 演算 <span class=\"orange\">[3]</span>，后来被证明和图灵机是等价的。</p><p>我们先不看数学上的 λ 表达式，看一下上一节给出的代码在使用 lambda 表达式时可以如何简化。</p><pre><code class=\"language-c++\">auto add_2 = [](int x) {\n  return x + 2;\n};\n</code></pre><p>显然，定义 <code>add_2</code> 不再需要定义一个额外的类型了，我们可以直接写出它的定义。理解它只需要注意下面几点：</p><ul>\n<li>Lambda 表达式以一对中括号开始（中括号中是可以有内容的；稍后我们再说）</li>\n<li>跟函数定义一样，我们有参数列表</li>\n<li>跟正常的函数定义一样，我们会有一个函数体，里面会有 <code>return</code> 语句</li>\n<li>Lambda 表达式一般不需要说明返回值（相当于 <code>auto</code>）；有特殊情况需要说明时，则应使用箭头语法的方式（参见<a href=\"https://time.geekbang.org/column/article/176850\">[第 8 讲]</a>）：<code>[]​(int x) -&gt; int { … }</code></li>\n<li>每个 lambda 表达式都有一个全局唯一的类型，要精确捕捉 lambda 表达式到一个变量中，只能通过 <code>auto</code> 声明的方式</li>\n</ul><p>当然，我们想要定义一个通用的 <code>adder</code> 也不难：</p><pre><code class=\"language-c++\">auto adder = [](int n) {\n  return [n](int x) {\n    return x + n;\n  };\n};\n</code></pre><p>这次我们直接返回了一个 lambda 表达式，并且中括号中写了 <code>n</code> 来捕获变量 <code>n</code> 的数值。这个函数的实际效果和前面的 <code>adder</code> 函数对象完全一致。也就是说，捕获 <code>n</code> 的效果相当于在一个函数对象中用成员变量存储其数值。</p><p>纯粹为了满足你可能有的好奇心，上面的 <code>adder</code> 相当于这样一个 λ 表达式：</p><p>$$<br>\n\\mathrm{adder} = \\lambda n.(\\lambda x.(+ \\ x \\ n))<br>\n$$</p><p>如果你去学 Lisp 或 Scheme 的话，你就会发现这些语言和 λ 表达式几乎是一一映射了。在 C++ 里，表达虽然稍微啰嗦一点，但也比较接近了。用我上面的 <code>adder</code> ，就可以得到类似于函数式编程语言里的 currying <span class=\"orange\">[4]</span> 的效果——把一个操作（此处是加法）分成几步来完成。没见过函数式编程的，可能对下面的表达式感到奇怪吧：</p><pre><code class=\"language-c++\">auto seven = adder(2)(5);\n</code></pre><p>不过，最常见的情况是，写匿名函数就是希望不需要起名字。以前面的把所有容器元素值加 2 的操作为例，使用匿名函数可以得到更简洁可读的代码：</p><pre><code class=\"language-c++\">transform(v.begin(), v.end(),\n          v.begin(),\n          [](int x) {\n            return x + 2;\n          });\n</code></pre><p>到了可以使用 ranges（已在 C++20 标准化）的时候，代码可以更短、更灵活。这个我们就留到后面再说了。</p><p>一个 lambda 表达式除了没有名字之外，还有一个特点是你可以立即进行求值。这就使得我们可以把一段独立的代码封装起来，达到更干净、表意的效果。</p><p>先看一个简单的例子：</p><pre><code class=\"language-c++\">[](int x) { return x * x; }(3)\n</code></pre><p>这个表达式的结果是 3 的平方 9。即使这个看似无聊的例子，都是有意义的，因为它免去了我们定义一个 constexpr 函数的必要。只要能满足 constexpr 函数的条件，一个 lambda 表达式默认就是 constexpr 函数。</p><p>另外一种用途是解决多重初始化路径的问题。假设你有这样的代码：</p><pre><code class=\"language-c++\">Obj obj;\nswitch (init_mode) {\ncase init_mode1:\n  obj = Obj(…);\n  break;\ncase init_mode2;\n  obj = Obj(…);\n  break;\n…\n}\n</code></pre><p>这样的代码，实际上是调用了默认构造函数、带参数的构造函数和（移动）赋值函数：既可能有性能损失，也对 <code>Obj</code> 提出了有默认构造函数的额外要求。对于这样的代码，有一种重构意见是把这样的代码分离成独立的函数。不过，有时候更直截了当的做法是用一个 lambda 表达式来进行改造，既可以提升性能（不需要默认函数或拷贝/移动），又让初始化部分显得更清晰：</p><pre><code class=\"language-c++\">auto obj = [init_mode]() {\n  switch (init_mode) {\n  case init_mode1:\n    return Obj(…);\n    break;\n  case init_mode2:\n    return Obj(…);\n    break;\n  …\n  }\n}();\n</code></pre><h3>变量捕获</h3><p>现在我们来细看一下 lambda 表达式中变量捕获的细节。</p><p>变量捕获的开头是可选的默认捕获符 <code>=</code> 或 <code>&amp;</code>，表示会自动按值或按引用捕获用到的本地变量，然后后面可以跟（逗号分隔）：</p><ul>\n<li>本地变量名标明对其按值捕获（不能在默认捕获符 <code>=</code> 后出现；因其已自动按值捕获所有本地变量）</li>\n<li><code>&amp;</code> 加本地变量名标明对其按引用捕获（不能在默认捕获符 <code>&amp;</code> 后出现；因其已自动按引用捕获所有本地变量）</li>\n<li><code>this</code> 标明按引用捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况）；注意默认捕获符 <code>=</code> 和 <code>&amp;</code> 号可以自动捕获 <code>this</code>（并且在 C++20 之前，在 <code>=</code> 后写 <code>this</code> 会导致出错）</li>\n<li><code>*this</code> 标明按值捕获外围对象（针对 lambda 表达式定义出现在一个非静态类成员内的情况；C++17 新增语法）</li>\n<li><code>变量名 = 表达式</code> 标明按值捕获表达式的结果（可理解为 <code>auto 变量名 = 表达式</code>）</li>\n<li><code>&amp;变量名 = 表达式</code> 标明按引用捕获表达式的结果（可理解为 <code>auto&amp; 变量名 = 表达式</code>）</li>\n</ul><p>从工程的角度，大部分情况不推荐使用默认捕获符。更一般化的一条工程原则是：<strong>显式的代码比隐式的代码更容易维护。</strong>当然，在这条原则上走多远是需要权衡的，你也不愿意写出非常啰嗦的代码吧？否则的话，大家就全部去写 C 了。</p><p>一般而言，按值捕获是比较安全的做法。按引用捕获时则需要更小心些，必须能够确保被捕获的变量和 lambda 表达式的生命期至少一样长，并在有下面需求之一时才使用：</p><ul>\n<li>需要在 lambda 表达式中修改这个变量并让外部观察到</li>\n<li>需要看到这个变量在外部被修改的结果</li>\n<li>这个变量的复制代价比较高</li>\n</ul><p>如果希望以移动的方式来捕获某个变量的话，则应考虑 <code>变量名 = 表达式</code> 的形式。表达式可以返回一个 prvalue 或 xvalue，比如可以是 <code>std::move(需移动捕获的变量)</code>。</p><p>上一节我们已经见过简单的按值捕获。下面是一些更多的演示变量捕获的例子。</p><p>按引用捕获：</p><pre><code class=\"language-c++\">vector&lt;int&gt; v1;\nvector&lt;int&gt; v2;\n…\nauto push_data = [&amp;](int n) {\n  // 或使用 [&amp;v1, &amp;v2] 捕捉\n  v1.push_back(n);\n  v2.push_back(n)\n};\n\npush_data(2);\npush_data(3);\n</code></pre><p>这个例子很简单。我们按引用捕获 <code>v1</code> 和 <code>v2</code>，因为我们需要修改它们的内容。</p><p>按值捕获外围对象：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nint get_count()\n{\n  static int count = 0;\n  return ++count;\n}\n\nclass task {\npublic:\n  task(int data) : data_(data) {}\n  auto lazy_launch()\n  {\n    return\n      [*this, count = get_count()]()\n      mutable {\n        ostringstream oss;\n        oss &lt;&lt; \"Done work \" &lt;&lt; data_\n            &lt;&lt; \" (No. \" &lt;&lt; count\n            &lt;&lt; \") in thread \"\n            &lt;&lt; this_thread::get_id()\n            &lt;&lt; '\\n';\n        msg_ = oss.str();\n        calculate();\n      };\n  }\n  void calculate()\n  {\n    this_thread::sleep_for(100ms);\n    cout &lt;&lt; msg_;\n  }\n\nprivate:\n  int data_;\n  string msg_;\n};\n\nint main()\n{\n  auto t = task{37};\n  thread t1{t.lazy_launch()};\n  thread t2{t.lazy_launch()};\n  t1.join();\n  t2.join();\n}\n</code></pre><p>这个例子稍复杂，演示了好几个 lambda 表达式的特性：</p><ul>\n<li><code>mutable</code> 标记使捕获的内容可更改（缺省不可更改捕获的值，相当于定义了 <code>operator()(…) const</code>）；</li>\n<li><code>[*this]</code> 按值捕获外围对象（<code>task</code>）；</li>\n<li><code>[count = get_count()]</code> 捕获表达式可以在生成 lambda 表达式时计算并存储等号后表达式的结果。</li>\n</ul><p>这样，多个线程复制了任务对象，可以独立地进行计算。请自行运行一下代码，并把 <code>*this</code> 改成 <code>this</code>，看看输出会有什么不同。</p><h2>泛型 lambda 表达式</h2><p>函数的返回值可以 auto，但参数还是要一一声明的。在 lambda 表达式里则更进一步，在参数声明时就可以使用 <code>auto</code>（包括 <code>auto&amp;&amp;</code> 等形式）。不过，它的功能也不那么神秘，就是给你自动声明了模板而已。毕竟，在 lambda 表达式的定义过程中是没法写 <code>template</code> 关键字的。</p><p>还是拿例子说话：</p><pre><code class=\"language-c++\">template &lt;typename T1,\n          typename T2&gt;\nauto sum(T1 x, T2 y)\n{\n  return x + y;\n}\n</code></pre><p>跟上面的函数等价的 lambda 表达式是：</p><pre><code class=\"language-c++\">auto sum = [](auto x, auto y)\n{\n  return x + y;\n}\n</code></pre><p>是不是反而更简单了？😂</p><p>你可能要问，这么写有什么用呢？问得好。简单来说，答案是可组合性。上面这个 <code>sum</code>，就跟标准库里的 <code>plus</code> 模板一样，是可以传递给其他接受函数对象的函数的，而 <code>+</code> 本身则不行。下面的例子虽然略有点无聊，也可以演示一下：</p><pre><code class=\"language-c++\">#include &lt;array&gt;    // std::array\n#include &lt;iostream&gt; // std::cout/endl\n#include &lt;numeric&gt;  // std::accumulate\n\nusing namespace std;\n\nint main()\n{\n  array a{1, 2, 3, 4, 5};\n  auto s = accumulate(\n    a.begin(), a.end(), 0,\n    [](auto x, auto y) {\n      return x + y;\n    });\n  cout &lt;&lt; s &lt;&lt; endl;\n}\n</code></pre><p>虽然函数名字叫 <code>accumulate</code>——累加——但它的行为是通过第四个参数可修改的。我们把上面的加号 <code>+</code> 改成星号 <code>*</code>，上面的计算就从从 1 加到 5 变成了算 5 的阶乘了。</p><h2>bind 模板</h2><p>我们上面提到了 <code>bind1st</code> 和 <code>bind2nd</code> 目前已经从 C++ 标准里移除。原因实际上有两个：</p><ul>\n<li>它的功能可以被 lambda 表达式替代</li>\n<li>有了一个更强大的 <code>bind</code> 模板 <span class=\"orange\">[5]</span></li>\n</ul><p>拿我们之前给出的例子：</p><pre><code class=\"language-c++\">transform(v.begin(), v.end(),\n          v.begin(),\n          bind2nd(plus&lt;int&gt;(), 2));\n</code></pre><p>现在我们可以写成：</p><pre><code class=\"language-c++\">using namespace std::\n  placeholders;  // for _1, _2...\ntransform(v.begin(), v.end(),\n          v.begin(),\n          bind(plus&lt;&gt;(), _1, 2));\n</code></pre><p>原先我们只能把一个给定的参数绑定到第一个参数或第二个参数上，现在则可以非常自由地适配各种更复杂的情况！当然，<code>bind</code> 的参数数量，必须是第一个参数（函数对象）所需的参数数量加一。而 <code>bind</code> 的结果的参数数量则没有限制——你可以无聊地写出 <code>bind(plus&lt;&gt;(), _1, _3)(1, 2, 3)</code>，而结果是 4（完全忽略第二个参数）。</p><p>你可能会问，它的功能是不是可以被 lambda 表达式替代呢。回答是“是”。对 <code>bind</code> 只需要稍微了解一下就好——在 C++14 之后的年代里，已经没有什么地方必须要使用 <code>bind</code> 了。</p><h2>function 模板</h2><p>每一个 lambda 表达式都是一个单独的类型，所以只能使用 <code>auto</code> 或模板参数来接收结果。在很多情况下，我们需要使用一个更方便的通用类型来接收，这时我们就可以使用 <code>function</code> 模板 <span class=\"orange\">[6]</span>。<code>function</code> 模板的参数就是函数的类型，一个函数对象放到 <code>function</code> 里之后，外界可以观察到的就只剩下它的参数、返回值类型和执行效果了。注意 <code>function</code> 对象的创建还是比较耗资源的，所以请你只在用 <code>auto</code> 等方法解决不了问题的时候使用这个模板。</p><p>下面是个简单的例子。</p><pre><code class=\"language-c++\">map&lt;string, function&lt;int(int, int)&gt;&gt;\n  op_dict{\n    {\"+\",\n     [](int x, int y) {\n       return x + y;\n     }},\n    {\"-\",\n     [](int x, int y) {\n       return x - y;\n     }},\n    {\"*\",\n     [](int x, int y) {\n       return x * y;\n     }},\n    {\"/\",\n     [](int x, int y) {\n       return x / y;\n     }},\n  };\n</code></pre><p>这儿，由于要把函数对象存到一个 <code>map</code> 里，我们必须使用 <code>function</code> 模板。随后，我们就可以用类似于 <code>op_dict.at(\"+\")(1, 6)</code> 这样的方式来使用 <code>function</code> 对象。这种方式对表达式的解析处理可能会比较有用。</p><h2>内容小结</h2><p>在这一讲中，我们了解了函数对象和 lambda 表达式的基本概念，并简单介绍了 <code>bind</code> 模板和 <code>function</code> 模板。它们在泛型编程和函数式编程中都是重要的基础组成部分，你应该熟练掌握。</p><h2>课后思考</h2><p>请：</p><ol>\n<li>尝试一下，把文章的 lambda 表达式改造成完全不使用 lambda。</li>\n<li>体会一下，lambda 表达式带来了哪些表达上的好处。</li>\n</ol><p>欢迎留言和我分享你的想法。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Wikipedia, “Function object”. <a href=\"https://en.wikipedia.org/wiki/Function_object\">https://en.wikipedia.org/wiki/Function_object</a> </span></p><p><span class=\"reference\">[1a] 维基百科, “函数对象”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1\">https://zh.wikipedia.org/zh-cn/函数对象</a> </span></p><p><span class=\"reference\">[2] Wikipedia, “Anonymous function”.<a href=\"https://en.wikipedia.org/wiki/Anonymous_function\">https://en.wikipedia.org/wiki/Anonymous_function</a> </span></p><p><span class=\"reference\">[2a] 维基百科, “匿名函数”. <a href=\"https://zh.wikipedia.org/zh-cn/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\">https://zh.wikipedia.org/zh-cn/匿名函数</a> </span></p><p><span class=\"reference\">[3] Wikipedia, “Lambda calculus”. <a href=\"https://en.wikipedia.org/wiki/Lambda_calculus\">https://en.wikipedia.org/wiki/Lambda_calculus</a> </span></p><p><span class=\"reference\">[3a] 维基百科, “λ演算”. <a href=\"https://zh.wikipedia.org/zh-cn/%CE%9B%E6%BC%94%E7%AE%97\">https://zh.wikipedia.org/zh-cn/Λ演算</a> </span></p><p><span class=\"reference\">[4] Wikipedia, “Currying”. <a href=\"https://en.wikipedia.org/wiki/Currying\">https://en.wikipedia.org/wiki/Currying</a> </span></p><p><span class=\"reference\">[4a] 维基百科, “柯里化”. <a href=\"https://zh.wikipedia.org/zh-cn/%E6%9F%AF%E9%87%8C%E5%8C%96\">https://zh.wikipedia.org/zh-cn/柯里化</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “std::bind”. <a href=\"https://en.cppreference.com/w/cpp/utility/functional/bind\">https://en.cppreference.com/w/cpp/utility/functional/bind</a> </span></p><p><span class=\"reference\">[5a] cppreference.com, “std::bind”. <a href=\"https://zh.cppreference.com/w/cpp/utility/functional/bind\">https://zh.cppreference.com/w/cpp/utility/functional/bind</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::function”. <a href=\"https://en.cppreference.com/w/cpp/utility/functional/function\">https://en.cppreference.com/w/cpp/utility/functional/function</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::function”. <a href=\"https://zh.cppreference.com/w/cpp/utility/functional/function\">https://zh.cppreference.com/w/cpp/utility/functional/function</a> </span></p>","neighbors":{"left":{"article_title":"15 | constexpr：一个常态的世界","id":182902},"right":{"article_title":"17 | 函数式编程：一种越来越流行的编程范式","id":185189}},"comments":[{"had_liked":false,"id":233561,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1594354792,"is_pvip":false,"replies":[{"id":"86231","content":"还真不是函数指针。可以认为编译器帮你组合出了一个唯一的类型名称吧。<br><br>举一个例子，如果你写：<br><br>auto adder = [n](int x) { return n + x; };<br><br>编译器产生的代码类似于：<br><br>struct lambda_1266ab7e {<br>  lambda_1266ab7e(int n) : n_{n} {}<br>  auto operator()(int x) const<br>  {<br>    return n_ + x;<br>  }<br>private:<br>  int n_;<br>};<br><br>auto adder = lambda_1266ab7e(n);","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1594378448,"ip_address":"","comment_id":233561,"utype":1}],"discussion_count":1,"race_medal":0,"score":"100378602600","product_id":100040501,"comment_content":"吴老师，您好。<br>四刷本讲。<br>我对您文中的这一句介绍有点好奇，“每个 lambda 表达式都有一个全局唯一的类型”。 请问这是怎么做到的？本质上不应该是一个函数指针么？这么规定的目的是什么？","like_count":23,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501087,"discussion_content":"还真不是函数指针。可以认为编译器帮你组合出了一个唯一的类型名称吧。\n\n举一个例子，如果你写：\n\nauto adder = [n](int x) { return n + x; };\n\n编译器产生的代码类似于：\n\nstruct lambda_1266ab7e {\n  lambda_1266ab7e(int n) : n_{n} {}\n  auto operator()(int x) const\n  {\n    return n_ + x;\n  }\nprivate:\n  int n_;\n};\n\nauto adder = lambda_1266ab7e(n);","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594378448,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167831,"user_name":"廖熊猫","can_delete":false,"product_type":"c1","uid":1141444,"ip_address":"","ucode":"8E8C475CD11FBC","user_header":"https://static001.geekbang.org/account/avatar/00/11/6a/c4/8679ca8a.jpg","comment_is_top":false,"comment_ctime":1577946185,"is_pvip":false,"replies":[{"id":"65178","content":"新年快乐。<br><br>对，概念上就是这样。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577962864,"ip_address":"","comment_id":167831,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57412521033","product_id":100040501,"comment_content":"老师新年快乐。<br>lambda表达式大概是生成了一个匿名的struct吧，实现了operator(), 捕获的话对应struct上的字段。","like_count":13,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480014,"discussion_content":"新年快乐。\n\n对，概念上就是这样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577962864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167742,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1577926655,"is_pvip":false,"replies":[{"id":"65177","content":"对，就是闭包。<br><br>Stackful 协程见 Boost.Coroutine2。Stackless 协程已经进入 C++20，第 30 讲讨论。🤓<br><br>新年快乐！","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577962836,"ip_address":"","comment_id":167742,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35937665023","product_id":100040501,"comment_content":"1、感觉lambda表达式就是C++中的闭包。<br><br>2、lambda表达式可以立即进行求职，这一点和JavaScript里的立即执行函数（Imdiately Invoked Function Expression，IIFE）一样。在JavaScript里，它是用来解决作用域缺陷的。<br><br>感觉在动态语言里被用到极致的闭包等特性，因为C++的强大、完备，在C++里很普通。<br><br>lambda的定义对应一个匿名函数对象，捕获就是构造这个对象时某种方式的初始化过程，用lambda表达式隐藏了这个过程，只保留了这个意思，更直观和写意。<br><br>老师，我对协程很感兴趣，C++会有协程么？隐约感觉捕获变量这个东西是不是可以用在实现协程上？<br><br>最后，祝老师新年快乐！","like_count":8,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479971,"discussion_content":"对，就是闭包。\n\nStackful 协程见 Boost.Coroutine2。Stackless 协程已经进入 C++20，第 30 讲讨论。🤓\n\n新年快乐！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577962836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178288,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1581651159,"is_pvip":false,"replies":[{"id":"69162","content":"注意我这儿用的是 return Obj(…) 的形式，不是有名变量的返回（Obj a{…} 然后 再 return a），不属于 named return value optimization 的情况。NRVO 指的是本地变量的返回。C++17 开始，prvalue 从语言上作了特殊解释，要求这样的返回直接构造到目的位置。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1581661463,"ip_address":"","comment_id":178288,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18761520343","product_id":100040501,"comment_content":"老师，回过头来看得时候，遇到了一个问题。<br><br>在用LAMBDA表达式解决多重初始化路径的问题时，说到这样还可以提高性能，因为不需要默认构造和不需要拷贝&#47;移动。可是在第10讲中讲返回值优化的时候，不是说如果返回值时有条件判断，编译器都被会难倒，从而导致NRVO失效么（函数getA_duang）？","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483744,"discussion_content":"注意我这儿用的是 return Obj(…) 的形式，不是有名变量的返回（Obj a{…} 然后 再 return a），不属于 named return value optimization 的情况。NRVO 指的是本地变量的返回。C++17 开始，prvalue 从语言上作了特殊解释，要求这样的返回直接构造到目的位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581661463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1184280,"avatar":"https://static001.geekbang.org/account/avatar/00/12/12/18/3fd57334.jpg","nickname":"~天了噜~","note":"","ucode":"745847776A9CD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567052,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650815298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167491,"user_name":"总统老唐","can_delete":false,"product_type":"c1","uid":1490070,"ip_address":"","ucode":"F2CC66E5BB4871","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/96/c679bb3d.jpg","comment_is_top":false,"comment_ctime":1577842193,"is_pvip":false,"replies":[{"id":"65021","content":"谢谢🙏。在这儿也顺祝所有的同学们新年好！😇🎈🎊","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577845530,"ip_address":"","comment_id":167491,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18757711377","product_id":100040501,"comment_content":"2020第一课，吴老师新年好","like_count":4,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479882,"discussion_content":"谢谢🙏。在这儿也顺祝所有的同学们新年好！😇🎈🎊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577845530,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339024,"user_name":"Daniel","can_delete":false,"product_type":"c1","uid":1664804,"ip_address":"","ucode":"F4EFE2D2A3E118","user_header":"https://static001.geekbang.org/account/avatar/00/19/67/24/32c58f77.jpg","comment_is_top":false,"comment_ctime":1647863363,"is_pvip":false,"replies":[{"id":"124038","content":"是这样。😊","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1648040154,"ip_address":"","comment_id":339024,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10237797955","product_id":100040501,"comment_content":"class task {<br>public:<br>  task(int data) : data_(data) {}<br>  auto lazy_launch()<br>  {<br>    return<br>      [this, count = get_count()]()<br>      mutable {<br>        ostringstream oss;<br>        oss &lt;&lt; &quot;Done work &quot; &lt;&lt; data_<br>            &lt;&lt; &quot; (No. &quot; &lt;&lt; count<br>            &lt;&lt; &quot;) in thread &quot;<br>            &lt;&lt; this_thread::get_id()<br>            &lt;&lt; &#39;\\n&#39;;<br>        msg_ = oss.str();<br>        calculate();<br>      };<br>  }<br>  void calculate()<br>  {<br>    this_thread::sleep_for(100ms);<br>    cout &lt;&lt; msg_;<br>  }<br><br>private:<br>  int data_;<br>  string msg_;<br>};<br><br>输出：<br>Done work 37 (No. 2) in thread 3<br>Done work 37 (No. 2) in thread 3<br><br>按引用捕获，应该是线程1输出之前msg_被线程2覆盖了。","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557998,"discussion_content":"是这样。😊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648040154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167596,"user_name":"罗 乾 林","can_delete":false,"product_type":"c1","uid":1188222,"ip_address":"","ucode":"D0406F95176ABA","user_header":"https://static001.geekbang.org/account/avatar/00/12/21/7e/fb725950.jpg","comment_is_top":false,"comment_ctime":1577871348,"is_pvip":false,"replies":[{"id":"65079","content":"lambda表达式的理解没啥问题。<br><br>int(int, int) 也是一个类型：一个接受两个整数参数、返回一个整数的函数。function 的主要复杂性，应该是需要处理函数、函数指针、函数对象等各种情况。函数对象的大小不确定，因而 function 需要在堆上分配内存。operator() 我记得相当于一个虚函数调用的复杂度。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577929427,"ip_address":"","comment_id":167596,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10167805940","product_id":100040501,"comment_content":"编译器遇到lambda 表达式时，产生一个匿名的函数对象，各种捕获相当于按值或者按引用设置给匿名对象的成员字段。<br>不对的地方，望老师指正。<br>对function&lt;int(int, int)&gt;这货怎么实现的比较好奇，大多数模板参数都是类型，做的都是是类型推导，这货居然是int(int, int)","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479911,"discussion_content":"lambda表达式的理解没啥问题。\n\nint(int, int) 也是一个类型：一个接受两个整数参数、返回一个整数的函数。function 的主要复杂性，应该是需要处理函数、函数指针、函数对象等各种情况。函数对象的大小不确定，因而 function 需要在堆上分配内存。operator() 我记得相当于一个虚函数调用的复杂度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577929427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348281,"user_name":"mawei","can_delete":false,"product_type":"c1","uid":1712470,"ip_address":"","ucode":"07DACA0F8BA65D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/21/56/91669d26.jpg","comment_is_top":false,"comment_ctime":1654930150,"is_pvip":false,"replies":[{"id":"126949","content":"我的意思是，可以写 [&amp;a, &amp;b]，也可以写 [=, &amp;a, &amp;b]，但不能写 [&amp;, &amp;a, &amp;b]。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1655131261,"ip_address":"","comment_id":348281,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5949897446","product_id":100040501,"comment_content":"&amp; 加本地变量名标明对其按引用捕获（不能在默认捕获符 &amp; 后出现；因其已自动按引用捕获所有本地变量）<br>老师这句话有问题么？括号内外感觉描述矛盾<br>&amp;本地变量名：这种写法不被允许么？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575837,"discussion_content":"我的意思是，可以写 [&amp;a, &amp;b]，也可以写 [=, &amp;a, &amp;b]，但不能写 [&amp;, &amp;a, &amp;b]。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655131262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170278,"user_name":"EncodedStar","can_delete":false,"product_type":"c1","uid":1504234,"ip_address":"","ucode":"03958CA7DDD6AE","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/ea/2b2adda5.jpg","comment_is_top":false,"comment_ctime":1578560241,"is_pvip":false,"replies":[{"id":"66043","content":"不是。你漏看了这句话：<br><br>“除非你用一个引用模板参数来捕捉函数类型，传递给一个函数的函数实参会退化成为一个函数指针。”","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578569289,"ip_address":"","comment_id":170278,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873527537","product_id":100040501,"comment_content":"函数指针和引用这个模块中<br>当我们拿 add_2 去调用这三个函数模板时，fn 的类型将分别被推导为 int (*)(int)、int (&amp;)(int) 和 int (*)(int)。<br>第一个和第三个都是 int (*)(int) 第一个是不是  int (int)","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480918,"discussion_content":"不是。你漏看了这句话：\n\n“除非你用一个引用模板参数来捕捉函数类型，传递给一个函数的函数实参会退化成为一个函数指针。”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578569289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168745,"user_name":"空气","can_delete":false,"product_type":"c1","uid":1307602,"ip_address":"","ucode":"45F9574A02343D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep73FalJJ7FPUJAcK2Ket1Qia1HOHhmaEcd8zdr4O6LHHk5NwzyUTnBAOzgmMtR3H0gSgYcbH6N5Vg/132","comment_is_top":false,"comment_ctime":1578149526,"is_pvip":false,"replies":[{"id":"65500","content":"你如果不是频繁创建 function 对象的话，关系也不大吧。我觉得多考虑移动就行了。除非性能测试工具报告瓶颈就在这儿了，用智能指针去优化不太值（毕竟需要修改使用的代码）。<br><br>每个 lambda 都有自己的独特类型，每次定义相当于编译器帮你产生了一个函数对象（就像这一讲里定义的那些函数对象一样）。<br><br>具体如何实现，我倒没读到过相关的文章。你可以网上搜搜看，或者阅读标准库里的源码。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578223249,"ip_address":"","comment_id":168745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873116822","product_id":100040501,"comment_content":"吴老师，我在工作中很经常用到function。文中讲到function对象的创建比较耗资源，能否介绍一下原因，或者可以参考哪些资料？确实要使用的话，是否有必要使用共享指针管理来减轻复制和转移消耗？<br>如果lambda的推导类型不是function，那是什么类型呢？和function有什么区别？","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480317,"discussion_content":"你如果不是频繁创建 function 对象的话，关系也不大吧。我觉得多考虑移动就行了。除非性能测试工具报告瓶颈就在这儿了，用智能指针去优化不太值（毕竟需要修改使用的代码）。\n\n每个 lambda 都有自己的独特类型，每次定义相当于编译器帮你产生了一个函数对象（就像这一讲里定义的那些函数对象一样）。\n\n具体如何实现，我倒没读到过相关的文章。你可以网上搜搜看，或者阅读标准库里的源码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578223249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356791,"user_name":"你好梦梦","can_delete":false,"product_type":"c1","uid":1259578,"ip_address":"上海","ucode":"17A25B7AE62549","user_header":"https://static001.geekbang.org/account/avatar/00/13/38/3a/102afd91.jpg","comment_is_top":false,"comment_ctime":1662598503,"is_pvip":false,"replies":[{"id":"129864","content":"function 对象不算小（你可以用 sizeof 检查一下）。因此，一般用引用传参。<br><br>另外参考第 41 讲。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1662637214,"ip_address":"上海","comment_id":356791,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1662598503","product_id":100040501,"comment_content":"老师，对于一个function类型，如果把他作为函数型参，是用引用好，还是直接传值好","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586977,"discussion_content":"function 对象不算小（你可以用 sizeof 检查一下）。因此，一般用引用传参。\n\n另外参考第 41 讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662637215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":355616,"user_name":"当初莫相识","can_delete":false,"product_type":"c1","uid":2768765,"ip_address":"上海","ucode":"313917BB360D48","user_header":"https://static001.geekbang.org/account/avatar/00/2a/3f/7d/f624fa69.jpg","comment_is_top":false,"comment_ctime":1661565960,"is_pvip":false,"replies":[{"id":"129526","content":"[=] 捕获了 this（不建议，C++20 开始会报错），不是 *this。也就是说，只捕获了外围对象的指针，而不是复制了一份外围对象。","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1661836582,"ip_address":"上海","comment_id":355616,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1661565960","product_id":100040501,"comment_content":"关于多线程那里，有个疑问。我在尝试将*this换为=，同样都是按值捕获，为什么结果却不同呢<br>return [=, count = get_count()]()。<br>我记得[]里=是按值捕获，&amp;引用捕获，是我哪里没理解对吗，还是C++标准不同所致。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585810,"discussion_content":"[=] 捕获了 this（不建议，C++20 开始会报错），不是 *this。也就是说，只捕获了外围对象的指针，而不是复制了一份外围对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661836582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":328482,"user_name":"莫言","can_delete":false,"product_type":"c1","uid":2174219,"ip_address":"","ucode":"7B4A0D0FF49806","user_header":"https://static001.geekbang.org/account/avatar/00/21/2d/0b/e6836053.jpg","comment_is_top":false,"comment_ctime":1640749954,"is_pvip":false,"replies":[{"id":"119893","content":"get_count返回的值不一样。你看到输出的样子，是其他原因引起的。再仔细想想。😉","user_name":"作者回复","user_name_real":"编辑","uid":"1645639","ctime":1641202234,"ip_address":"","comment_id":328482,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1640749954","product_id":100040501,"comment_content":"请问下吴老师，this按引用捕获的时候，为什么get_count返回的值也是一样的呢？虽然引用不产生拷贝，但是get_count不是实实在在的执行了两次么","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543553,"discussion_content":"get_count返回的值不一样。你看到输出的样子，是其他原因引起的。再仔细想想。😉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641202234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2119142,"avatar":"https://static001.geekbang.org/account/avatar/00/20/55/e6/6a89ccc4.jpg","nickname":"韦少","note":"","ucode":"7255683605E0C5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546521,"discussion_content":"操作的是同一个对象。 你把sleep函数放到『cout &lt;&lt;msg_;』 后面 或许会有点启发","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642332715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284223,"user_name":"薛凯文","can_delete":false,"product_type":"c1","uid":2098241,"ip_address":"","ucode":"92EDBE7FADB41F","user_header":"https://static001.geekbang.org/account/avatar/00/20/04/41/a044b81c.jpg","comment_is_top":false,"comment_ctime":1616126443,"is_pvip":false,"replies":[{"id":"103112","content":"因为你产生了未定义行为。如果使用按引用捕获，你需要保证这个变量一直存在。<br><br>事实上，clang 对这种情况是可以直接报警的：<br><br>warning: address of stack memory associated with parameter &#39;n&#39; returned [-Wreturn-stack-address]","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1616155294,"ip_address":"","comment_id":284223,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616126443","product_id":100040501,"comment_content":"Hello，老师。关于lambda adder。 <br>auto adder = [](int n) {<br>  return [n](int x) {<br>    return x + n;<br>  };<br>};<br>如果里面的lambda改成引用捕获，如下所示：<br>auto adder = [](int n) {<br>  return [&amp;n](int x) {<br>    return x + n;<br>  };<br>};<br>结果就是不对的了. adder(3)(5)的结果是10(5 + 5). 请问是什么原因啊？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517275,"discussion_content":"因为你产生了未定义行为。如果使用按引用捕获，你需要保证这个变量一直存在。\n\n事实上，clang 对这种情况是可以直接报警的：\n\nwarning: address of stack memory associated with parameter &amp;#39;n&amp;#39; returned [-Wreturn-stack-address]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616155294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279910,"user_name":"蔡冰成","can_delete":false,"product_type":"c1","uid":1795821,"ip_address":"","ucode":"A1C50B0121C6C4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/66/ed/a1233b74.jpg","comment_is_top":false,"comment_ctime":1613999167,"is_pvip":false,"replies":[{"id":"101735","content":"我猜是没开优化？我试下来没问题啊：<br><br>https:&#47;&#47;godbolt.org&#47;z&#47;M73ccj","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1614096332,"ip_address":"","comment_id":279910,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1613999167","product_id":100040501,"comment_content":"hi, 吴老师<br>    auto dbl_lambda = [](const int&amp; x) {return x * x;};<br>    int dbl1 = dbl_lambda(3);<br>关于&quot;只要能满足 constexpr 函数的条件，一个 lambda 表达式默认就是 constexpr 函数&quot;这个结论, 我用上面对代码编译之后, 计算3*3依然是运行时调用, 使用的是https:&#47;&#47;gcc.godbolt.org&#47;, 编译环境x86-64 gcc10.2<br> call   401172 &lt;main::{lambda(int)#1}::operator()(int) const&gt;<br> mov    DWORD PTR [rbp-0x4],eax<br>请问是有什么地方不正确吗? 如果使用正常对函数加constexpr声明则是编译期计算的","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515920,"discussion_content":"我猜是没开优化？我试下来没问题啊：\n\nhttps://godbolt.org/z/M73ccj","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614096332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1795821,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/66/ed/a1233b74.jpg","nickname":"蔡冰成","note":"","ucode":"A1C50B0121C6C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357282,"discussion_content":"感谢回复, 用您的方法验证了一下看起来是优化参数的区别. 另外一个问题是, lambda可以做编译期计算其实就是在编译展开的时候添加了constexpr关键词吗? 这里看起来是这样的 ,但是我不是很确定 : https://cppinsights.io/s/80abc66f","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615776389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230795,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1593496121,"is_pvip":false,"replies":[{"id":"85388","content":"std::placeholders？那只是用于 bind 的。lambda 里完全没看到有需要要用类似的东西。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1593650698,"ip_address":"","comment_id":230795,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1593496121","product_id":100040501,"comment_content":"吴老师您好。<br>请问利用lamda表达式来替换bind,是否要使用std::thresholders来传递参数?","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500040,"discussion_content":"std::placeholders？那只是用于 bind 的。lambda 里完全没看到有需要要用类似的东西。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593650698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287646,"discussion_content":"看来小编睡醒了：）\n补充一下问题细节吧：\n我尝试了一下用lambda替换bind,发现thresholder不知道该如何处理，用了auto提示无法匹配。难道必须要具名化处理吗？\n谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593503458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290274,"discussion_content":"拿具体例子吧。\n\n另，你这样回复我收不到提醒的。原先那样提问题我能收到提醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594394127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":287646,"ip_address":""},"score":290274,"extra":""}]}]},{"had_liked":false,"id":230784,"user_name":"zhengfan","can_delete":false,"product_type":"c1","uid":1020160,"ip_address":"","ucode":"B3AC0E10BF7A14","user_header":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","comment_is_top":false,"comment_ctime":1593491421,"is_pvip":false,"replies":[{"id":"85229","content":"有意思的问题。实测下来，C++ 不看形式，而是看实质。按你这个形式，能编译过。但如果这个 lambda 表达式真的会修改自己的存储的数值，则不可以是 constexpr。<br><br>见：<br><br>https:&#47;&#47;godbolt.org&#47;z&#47;wc5axG<br><br>写<br><br>auto l = [x = 1]() { return x++; };<br>constexpr auto l = [x = 1]() mutable { return x++; };<br><br>都不行。<br><br>auto l = [x = 1]() mutable { return x++; };<br><br>可以。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1593499619,"ip_address":"","comment_id":230784,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1593491421","product_id":100040501,"comment_content":"吴老师您好，请教一下：<br>对于形如[]() mutable {}的lamda表达式 还能够被认为是一个constexpr吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500036,"discussion_content":"有意思的问题。实测下来，C++ 不看形式，而是看实质。按你这个形式，能编译过。但如果这个 lambda 表达式真的会修改自己的存储的数值，则不可以是 constexpr。\n\n见：\n\nhttps://godbolt.org/z/wc5axG\n\n写\n\nauto l = [x = 1]() { return x++; };\nconstexpr auto l = [x = 1]() mutable { return x++; };\n\n都不行。\n\nauto l = [x = 1]() mutable { return x++; };\n\n可以。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593499619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/00/2007d2f3.jpg","nickname":"zhengfan","note":"","ucode":"B3AC0E10BF7A14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287645,"discussion_content":"诶呀吴老师居然秒回！太感动了…\n另外还有个问题，不知道小编为何留中不发，一并在这里问了吧：\n我尝试了一下用lambda替换bind,发现thresholder不知道该如何处理，用了auto提示无法匹配。难道必须要具名化处理吗？\n谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593502711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180518,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1582302359,"is_pvip":false,"replies":[{"id":"70056","content":"「若不对类类型（struct、class 或 union）提供任何用户声明的构造函数，则编译器将始终声明一个作为其类的 inline public 成员的默认构造函数。 」<br><br>https:&#47;&#47;zh.cppreference.com&#47;w&#47;cpp&#47;language&#47;default_constructor","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1582335412,"ip_address":"","comment_id":180518,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582302359","product_id":100040501,"comment_content":"老师，一个空类，编译器没有生成默认的构造函数是吗？😂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484691,"discussion_content":"「若不对类类型（struct、class 或 union）提供任何用户声明的构造函数，则编译器将始终声明一个作为其类的 inline public 成员的默认构造函数。 」\n\nhttps://zh.cppreference.com/w/cpp/language/default_constructor","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582335412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168547,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1578107928,"is_pvip":false,"replies":[{"id":"65374","content":"libgo 我没有任何使用经验，不过，看起来它和大部分库实现的协程一样，都是 stackful coroutine。我第 30 讲会讲的是会进入 C++20 的 stackless coroutine。<br><br>每个 libgo 的协程都有自己的独立栈空间，因此，协程唤起和休眠时都需要进行栈切换。无栈协程则跟唤起者使用同一个栈。有栈的协程实现另外还有 libco、Boost.Coroutine2 等。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1578124433,"ip_address":"","comment_id":168547,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1578107928","product_id":100040501,"comment_content":"最近项目里使用到了libgo这个C++写的协程库，示例代码中用到了好多老师今天讲的知识点：<br>void foo()<br>{<br>    printf(&quot;function pointer\\n&quot;);<br>}<br><br>struct A {<br>    void fA() { printf(&quot;std::bind\\n&quot;); }<br>    void fB() { printf(&quot;std::function\\n&quot;); }<br>};<br>int main()<br>{<br>    go foo;<br><br>    go []{<br>        printf(&quot;lambda\\n&quot;);<br>    };<br><br>    go std::bind(&amp;A::fA, A());<br><br>    std::function&lt;void()&gt; fn(std::bind(&amp;A::fB, A()));<br>    go fn;<br>}<br>其中跟在&quot;go&quot;后面的内容总算能理解了，但是&quot;go&quot;的实现原理还是没搞懂，不知道后面协程这块的内容会不会有讲到。<br>另外对老师今天讲的 ”一般而言，按值捕获是比较安全的做法。按引用捕获时则需要更小心些，必须能够确保被捕获的变量和 lambda 表达式的生命期至少一样长“ 这句话深有体会，我在项目里按值捕获指针给协程用，结果调试的时候就是各种随机的崩溃。。。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480247,"discussion_content":"libgo 我没有任何使用经验，不过，看起来它和大部分库实现的协程一样，都是 stackful coroutine。我第 30 讲会讲的是会进入 C++20 的 stackless coroutine。\n\n每个 libgo 的协程都有自己的独立栈空间，因此，协程唤起和休眠时都需要进行栈切换。无栈协程则跟唤起者使用同一个栈。有栈的协程实现另外还有 libco、Boost.Coroutine2 等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578124433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217554,"avatar":"https://static001.geekbang.org/account/avatar/00/12/94/12/15558f28.jpg","nickname":"Jason","note":"","ucode":"C5A540BC5A60B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185363,"discussion_content":"正巧我也在集成libgo，你说的go后面的处理，其实go是一个宏定义。\n#define go_alias ::co::__go(__FILE__, __LINE__)-\n#define go go_alias\n\n这里你可能看到一个减号很疑惑，其实是__go这个结构做了运算符重载，建议看下syntax_helper.h这个头文件","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582620370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167962,"user_name":"李亮亮","can_delete":false,"product_type":"c1","uid":1116508,"ip_address":"","ucode":"290907F930B261","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","comment_is_top":false,"comment_ctime":1577969785,"is_pvip":false,"replies":[{"id":"65233","content":"是说有线程的那个例子吗？我刚又试了，没问题的。<br><br>你是不是没有设定语言标准为 c++17？但你评论里又说设了……不设是确实不行的。<br><br>我编译的命令行是：<br><br>cl &#47;EHsc &#47;std:c++17 test16.cpp<br><br>如果你遇到错误了，又不贴出错误信息，别人也没法帮你啊……","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577974351,"ip_address":"","comment_id":167962,"utype":1}],"discussion_count":6,"race_medal":0,"score":"1577969785","product_id":100040501,"comment_content":"Microsoft Visual Studio Community 2019  版本 16.4.2，语言标准：C++17 例子编译不过，水平又菜，不会改。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480072,"discussion_content":"是说有线程的那个例子吗？我刚又试了，没问题的。\n\n你是不是没有设定语言标准为 c++17？但你评论里又说设了……不设是确实不行的。\n\n我编译的命令行是：\n\ncl /EHsc /std:c++17 test16.cpp\n\n如果你遇到错误了，又不贴出错误信息，别人也没法帮你啊……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577974351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115130,"discussion_content":"没有使用命令，直接点的 run，后面我使用在线的C++ 编译器测试了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577980552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115485,"discussion_content":"只要出错，总有错误信息的……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578015918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":115130,"ip_address":""},"score":115485,"extra":""},{"author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":115578,"discussion_content":"吴老师，这是vs提示的错误：\n\n[*this, count = get_count()]​() 这行提示：\nE1758\t应输入“{”以引入 lambda 体\t，\t\nC3260\t“标识符”: 跳过 lambda 主体之前的意外标记\n\nmsg_ = oss.str(); 这行提示：\nC2678\t二进制“=”: 没有找到接受“const std::string”类型的左操作数的运算符(或没有可接受的转换)\n\ncalculate(); 这行提示：\nC2662\t“void task::calculate(void)”: 不能将“this”指针从“const task”转换为“task &amp;”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578020693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":115485,"ip_address":""},"score":115578,"extra":""},{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":115644,"discussion_content":"哈，不是你的问题。是“[*this, count = get_count()]​()” 这行，在结束的“()”前有个不可见字符，需要删掉才能正确编译。我在联系编辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578025257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":115578,"ip_address":""},"score":115644,"extra":""}]}]},{"had_liked":false,"id":167678,"user_name":"禾桃","can_delete":false,"product_type":"c1","uid":1477855,"ip_address":"","ucode":"9FE85C34A9E9E0","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","comment_is_top":false,"comment_ctime":1577892347,"is_pvip":false,"replies":[{"id":"65082","content":"就是让你想一想的呀。提示：按引用捕获的后果。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577929706,"ip_address":"","comment_id":167678,"utype":1}],"discussion_count":9,"race_medal":0,"score":"1577892347","product_id":100040501,"comment_content":"&quot;请自行运行一下代码，并把 *this 改成 this，看看输出会有什么不同。&quot;<br><br>int get_count()<br>{<br>    static int count = 0;<br>    return ++count;<br>}<br><br>class task {<br>public:<br>    task(int data) : data_(data) { cout &lt;&lt; __func__ &lt;&lt; &quot;|&quot; &lt;&lt; this &lt;&lt; endl; }<br>    auto lazy_launch()<br>    {<br>        return<br>            &#47;&#47; *this 标明按值捕获外围对象<br>            &#47;&#47; 变量名 = 表达式 标明按值捕获表达式的结果<br>                [this, count = get_count()]()<br>                        mutable { &#47;&#47; mutable 标记使捕获的内容可更改<br>                    cout &lt;&lt; __func__ &lt;&lt; &quot;|&quot; &lt;&lt; this &lt;&lt; endl;<br>                    ostringstream oss;<br>                    oss &lt;&lt; &quot;Done work &quot; &lt;&lt; data_<br>                        &lt;&lt; &quot; (No. &quot; &lt;&lt; count<br>                        &lt;&lt; &quot;) in thread &quot;<br>                        &lt;&lt; this_thread::get_id()<br>                        &lt;&lt; &#39;\\n&#39;;<br>                    msg_ = oss.str();<br>                    calculate();<br>                };<br>    }<br>    void calculate()<br>    {<br>        this_thread::sleep_for(100ms);<br>        cout &lt;&lt; msg_;<br>    }<br><br>private:<br>    int data_;<br>    string msg_;<br>};<br><br>int main()<br>{<br>    auto t = task{37};<br>    thread t1{t.lazy_launch()};<br>    thread t2{t.lazy_launch()};<br>    t1.join();<br>    t2.join();<br>}<br><br> 打印输出<br>task|0x7ffe6f0e7120<br>operator()|0x7ffe6f0e7120<br>operator()|0x7ffe6f0e7120<br>Done work 37 (No. 2) in thread 140331800897280 <br>Done work 37 (No. 2) in thread 140331800897280<br><br>不太明白为什么，<br>#1 t1, t2这两个thread有同样的thread id(140331800897280)？<br>#2 为什么 count在， t1, t2运行时，打印出的都是2(No. 2)？<br><br>多谢！","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479941,"discussion_content":"就是让你想一想的呀。提示：按引用捕获的后果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577929706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114226,"discussion_content":"哈，多谢！ 比较tricky的是this_thread::sleep_for(100ms); 由于他的存在， msg_虽然已经被两个线程里的代码分别更新了一次， 但是当执行到cout << msg_（不管是哪个线程）， 看到的都是msg_被更新完两次以后的最终状态。  去掉this_thread::sleep_for(100ms)， 就能看到 msg_被两个线程分别更新后的中间状态了。有意思！","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1577964382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1757384,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL41RCmZy6An5SLXPmXU6ea5yvweBGPicedqQ0xjuaYp1PY1CSlUuNwgV3BNpbWzdJwXlWZAVicrtPg/132","nickname":"啦啦啦","note":"","ucode":"76BBA994C40F23","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114094,"discussion_content":"我觉得这个就是因为按引用捕获，所以前面的内容都被后面的覆盖了，最后输出的都是最后赋值的内容了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577957096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1757384,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL41RCmZy6An5SLXPmXU6ea5yvweBGPicedqQ0xjuaYp1PY1CSlUuNwgV3BNpbWzdJwXlWZAVicrtPg/132","nickname":"啦啦啦","note":"","ucode":"76BBA994C40F23","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114203,"discussion_content":"这位同学正解。😎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577963668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114094,"ip_address":""},"score":114203,"extra":""},{"author":{"id":1188173,"avatar":"https://static001.geekbang.org/account/avatar/00/12/21/4d/90ea92f8.jpg","nickname":"光城~兴","note":"","ucode":"55A0D25BFCDD47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":129870,"discussion_content":"最主要还是有个sleep过程，哈哈～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578743007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114203,"ip_address":""},"score":129870,"extra":""},{"author":{"id":1311125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","nickname":"布拉姆","note":"","ucode":"479FF27D73BCAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":353324,"discussion_content":"那么老师，C++17之前，比如C++14在捕获列表内无法使用[*this], 这种情况下是否有替代方法？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615127204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114203,"ip_address":""},"score":353324,"extra":""}]},{"author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114437,"discussion_content":"值捕获就是操作备份，引用捕获操作的是同一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577972091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1477855,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8c/df/77acb793.jpg","nickname":"禾桃","note":"","ucode":"9FE85C34A9E9E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1116508,"avatar":"https://static001.geekbang.org/account/avatar/00/11/09/5c/b5d79d20.jpg","nickname":"李亮亮","note":"","ucode":"290907F930B261","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114825,"discussion_content":"嗯，引用捕获那部分理解没问题。开始疑惑的是，既然是引用捕获，msg_在每个线程里都被修改过一次，但是两个线程中的函数cout的一样。后来明白了，是由于sleep的存在，两个cout 执行的时间都要比msg_第二次被更新的时间要晚，所以两次cout反应的都是msg_第二次被更新后的值。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577977774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":114437,"ip_address":""},"score":114825,"extra":""}]}]},{"had_liked":false,"id":167585,"user_name":"泰伦卢","can_delete":false,"product_type":"c1","uid":1141994,"ip_address":"","ucode":"FEA6B43C8D4FF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6c/ea/e03fec22.jpg","comment_is_top":false,"comment_ctime":1577868965,"is_pvip":true,"replies":[{"id":"65041","content":"不会。谈这个的书和文章够多了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577873337,"ip_address":"","comment_id":167585,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577868965","product_id":100040501,"comment_content":"请问老师后续会讲关于类对象及虚函数表相关知识吗，这块比较薄弱","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479907,"discussion_content":"不会。谈这个的书和文章够多了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577873337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167499,"user_name":"viper","can_delete":false,"product_type":"c1","uid":1265184,"ip_address":"","ucode":"1BD8983502436C","user_header":"https://static001.geekbang.org/account/avatar/00/13/4e/20/83151e94.jpg","comment_is_top":false,"comment_ctime":1577845177,"is_pvip":false,"replies":[{"id":"65119","content":"谢谢反馈。已更正。","user_name":"作者回复","user_name_real":"吴咏炜","uid":"1645639","ctime":1577936630,"ip_address":"","comment_id":167499,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1577845177","product_id":100040501,"comment_content":"老师，为什么上面会说用add_2去调用那三模版函数返回值都是2，不该是4吗？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479884,"discussion_content":"谢谢反馈。已更正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577936630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1271183,"avatar":"","nickname":"nelson","note":"","ucode":"773BE75A23C1C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":113510,"discussion_content":"还有返回值是void？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577898242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}