{"id":741064,"title":"第 9 章 指标与监控(2)","content":"<h2 id=\"nav_point_176\">9.5　监控系统的分层</h2>\n<p>监控系统的分类谈完了，我们换个角度，通常任何架构都会分层，在架构的各个层级中都能找到监控的身影。分布式系统也是一样，为了实现全链路的监控，将其分为如下五层。</p>\n<ul>\n<li><strong>客户端监控</strong>：例如用户行为信息、业务返回码、客户端性能、运营商、版本、操作系统等。</li>\n<li><strong>业务层监控</strong>：核心业务的监控，例如登录、注册、下单、支付等。</li>\n<li><strong>应用层监控</strong>：相关的技术参数，例如 URL 请求次数、Service 请求数量、SQL 执行的结果、Cache 的利用率、QPS 等。</li>\n<li><strong>系统层监控</strong>：物理主机，虚拟主机以及操作系统的参数，例如 CPU 利用率、内存利用率、磁盘空间情况。</li>\n<li><strong>网络层监控</strong>：网络情况参数，例如网关流量情况、丢包率、错包率、连接数等。</li>\n</ul>\n<p>从分层可以看出，监控系统包含的范围是很广的。网络、系统、应用、业务、客户端都是监控的对象，那么如何着手，使用什么工具对这些对象展开监控就是接下来要面对的问题。通过观察监控系统的分层可以发现，应用层、系统层、网络层针对的主要是一些通用硬件、系统和应用，对它们的监控和业务是毫无关系的，主要偏向于系统应用参数，因此可以使用度量类监控平台。而客户端、业务层的监控以业务为主，需要我们根据实现的业务场景编写对应日志，所以比较适合日志类监控。经过分析可以发现，每层关心的内容不尽相同，但都需要通过监控的方式获取信息，从而实现监控和优化。</p>\n<p>针对不同的层级涌现出了不同的监控系统，例如网络层、系统层有 Zabbix、Prometheus；应用层有 Prometheus、CAT、ELK；业务层有 Prometheus；客户端有听云等优秀的产品。后面两节会就其中两个使用比较广泛的监控架构展开讲解：Zabbix 作为老牌监控平台被一直使用至今，Prometheus 作为新晋的时序数据库监控平台势头正猛。</p><!-- [[[read_end]]] -->\n<h2 id=\"nav_point_177\">9.6　Zabbix 实现监控系统</h2>\n<p>众所周知，Zabbix 是一款优秀的监控系统，可以监控互联网中的设备和应用。在详细介绍其实现方式之前，先来看看它的结构图，如图 9-21 所示。图中左侧“被监控设备”中包含的设备类型可以是服务器、交换机或者网络打印机，以下将这些被监控设备称作 Host，设备的分组称作 Host Group，分组时可以依据地域、机房、应用。从“监控方式”部分可以看出，Zabbix 会为每个 Host 安装 Zabbix Agent，这是 Zabbix 在 Host 上的客户端，负责将 Zabbix 需要监控的信息上传到 Zabbix Server 进行分析和处理。但并不是所有网络设备都能够安装 Zabbix Agent，对于那些无法安装的设备来说，要是支持 IPMI（Intelligent Platform Management Interface，智能平台管理接口）或者 SNMP（Simple Network Management Protocol，简单网络管理协议），也是可以被 Zabbix 监控到的。另外，如果是监控 Java 应用程序，也可以通过 JMX 实现。从“监控内容”部分可以看出，Zabbix 通过 Zabbix Agent 监控应用信息、通过 IPMI 监控设备硬件信息、通过 SNMP 监控网络信息。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00585.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-21　Zabbix 架构图</strong></p>\n<p>图中的 Host 区域与右边 Zabbix Server 之间有一个双向箭头，这种由 Host 直接连到 Zabbix Server 的方式叫作通用架构，类似于常说的 C/S 架构。可在实际应用中使用更多的是分布式架构，也就是 Host 先连接 Zabbix Proxy，Zabbix Proxy 再连接右边的 Zabbix Server，从而构成一条信息通路。在“Zabbix 监控服务器”区域，包含几个监控服务器，其中“Zabbix Server”主要负责配置和接收/发送监控信息。处理完毕的信息会存储到 Database 中，这里的 Database 可以指定 MySQL 或 Oracle 以及其他数据库源。另外，Zabbix UI 负责展示配置信息和监控信息。不仅如此，Zabbix 还为第三方应用提供了 Zabbix API，通过它来客制化 Zabbix 规则，当然出于对稳定性的考虑，可以通过 keepalived 之类的软件建立含有 Master、Slave 节点的 HA（High Availability，高可用）机制。</p>\n<h3 id=\"nav_point_178\">9.6.1　Zabbix 构建监控系统过程</h3>\n<p>通过图 9-21，想必大家已经对 Zabbix 的工作原理有了基本了解。现在趁热打铁来看看 Zabbix 架构的安装和配置步骤，图 9-22 已经直观展示出来了。泳道图将架构分为“Host”（被监控的主机）和“Zabbix 监控服务器”，步骤从左到右、从上到下顺着箭头的方向依次是：安装 Zabbix Agent → 配置信息 → 安装 Zabbix Server/UI → 配置 Host → 配置监控项（Items）→ 配置触发器（Trigger）→ 配置处理动作（Action）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00586.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-22　Zabbix 架构安装和配置示意图</strong></p>\n<p>下一节会以图 9-22 中的流程为主线推进，主要目的是通过分析 Zabbix 的安装和配置流程，了解分布式监控需要准备哪些工作，为上面的理论做实践方面的扩展。</p>\n<h3 id=\"nav_point_179\">9.6.2　Zabbix 架构的安装和配置</h3>\n<p>本节会详细介绍 Zabbix 架构的整个安装和配置过程，这里都没有标注具体命令。如果有需要安装和配置过程的同学，可以下载 Zabbix 用户手册，这里因为篇幅不展开描述。</p>\n<ul>\n<li><p><strong>安装 Zabbix Server 和 Zabbix Agent</strong></p>\n<p>首先在 Zabbix 监控服务器上，安装 Zabbix Server 和 Zabbix UI（Web）。前者用来接收和发送监控信息，后者用来配置 Zabbix Server 的各项功能。</p>\n<p>在 Host 上安装 Zabbix Agent，安装完毕后，需要配置 zabbix_agentd.conf 文件中的 <code>Server</code> 和 <code>ServerActive</code> 参数。Zabbix Agent 分被动模式和主动模式。被动模式下，是 Zabbix Server 从 Zabbix Agent 上获取数据。主动模式下，是 Zabbix Agent 主动将信息上传到 Zabbix Server。因此，这两个参数的内容都是 Zabbix Server 的 IP 地址。参数 <code>Server</code> 配置的是被动模式下 Zabbix Server 的 IP 地址，<code>ServerActive</code> 配置的是主动模式下 Zabbix Server 的 IP 地址。当然，除了配置参数，还需要更新防火墙配置，并打开 Zabbix 的访问端口（10050 和 10051）。最后给 Host 起一个主机名（Hostname），这个名字在下面配置 Zabbix Server 的时候会用到。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置 Zabbix Server 和 Host</strong></p>\n<p>搞定 Zabbix Agent 以后，对 Zabbix Server 进行配置。Zabbix Server 和 Zabbix UI（Web）已经安装完毕，可以通过 Zabbix UI（Web）访问配置界面，如图 9-23 所示。前面曾提到每个被监控的设备都是一个 Host，对多个 Host 按照地理位置、业务单位、机器用途、系统版本等方式分组，就得到了 Host Group。因此我们先建立一个 Host Group，再在其中建立一个 Host，这个 Host 就是刚才安装 Zabbix Agent 的设备在 Zabbix Server 上的概念设备。在配置 Host 的时候，注意要让这里的“主机名称”和上一段中定义的主机名保持一致，以便辨识。图 9-23 中配置了“主机名称”，定义了 Host 对应的“群组”（Groups），在“agent 代理程序的接口”中配置的 IP 是被监控设备 Host 的 IP，给“端口”（Port）配置的值是 Zabbix 的主动访问端口 10050。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00587.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-23　在 Zabbix Server 上配置 Host</strong></p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置监控项（Items）</strong></p>\n<p>配置完 Host 之后，需要告诉 Zabbix 监控 Host 中的哪些数据，这部分数据叫作监控项。监控项包括以什么方式监控数据、取值的数据类型、获取数值的时间间隔、历史数据的保存时间、趋势数据的保存时间、监控键的分组等信息。配置监控项时，要先选择“类型”，具体是要监听的 Zabbix 客户端的类型。一般安装 Zabbix Agent 以后，这个类型就是“Zabbix 客户端”，当然也可以选择 SNMP、IMPI 或者其他类型。如图 9-24 所示，在“类型”的下拉框中展示了全部监控项所需的类型。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00588.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-24　配置监控项</strong></p>\n<p>其次要注意“键值”（Key）的选择，键是来确定具体监控项的，对于同一个 Host 来说，键具有唯一性。Zabbix 自带一些默认键值以供选择，例如 <code>vm.memory.size[total]</code>，表示获取内存大小的键。然后由于是针对 Host 进行配置的，因此也会指定对应的 Host IP 和 Port，即“主机接口”。另外，还需配置其他一些数据，包括信息类型、单位、更新间隔、历史数据保留时长、趋势存储时间，如图 9-25 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00589.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-25　监控项的配置全景图</strong></p>\n<p>细心的读者会发现图 9-25 中有一个应用集（Applications）选项，这实际是监控项的集合，例如要监控 MySQL，就可以定义一个 MySQL 的应用集，把相关的监控项，包括 availability of MySQL、disk space、processor load、transactions per second、number of slow queries 全部放到这个应用集中，方便选择和管理操作。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置触发器（Trigger）</strong></p>\n<p>前面提到，监控项是用来配置监控哪些数据的，并不判断数据是否正常。触发器的作用就是对采集到的数据进行判断。通常会设置判断规则或者阈值，一旦数据满足某种规则或者超过对应的阈值，就产生一个事件，同时处理动作（Action）对满足触发条件的数据执行操作。其中提到的规则通常使用正则表达式来定义。如图 9-26 所示，沿着箭头的方向从左往右，Host 通过 Zabbix agent 连接到 Zabbix Server 并注册以后，会指定对应的监控项作为要监控的内容，然后通过触发器定义规则，当监控项对应的规则触发后，就执行对应的处理动作。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00590.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-26　从接收消息到触发动作</strong></p>\n<p>采集到的数据经过表达式判断，会产生两种触发器状态：OK（正常）和 PROBLEM（异常）。每个触发器都会对应一个监控项，每个监控项又都对应多个触发器。同时，触发器可以设置不同的事件级别，并且根据这些级别设置多重告警。如图 9-27 所示，列举了 5 类触发器事件级别。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00591.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-27　触发器事件级别示意图</strong></p>\n<p>配置触发器主要是添加正则表达式。Zabbix 会根据和监控项对应的函数生成相应的正则表达式。如图 9-28 所示，触发器是检测登录 Linux 系统的人数，选择“监控项”为 Template OS linux: Number of logged in users（<code>Last()</code> - 最后(最近) 的 <code>T</code> 值），对应的函数是 <code>Last(most recent) T value is = N</code>。意思是获取最近登录 Linux 系统的人数 <code>T</code>，当 <code>T</code> 值和 <code>N</code> 相等的时候触发触发器。这个 <code>N</code> 就是需要我们配置的值，比如填写 <code>2</code>，意味着登录人数等于 2 的时候触发触发器。当你配置完毕后，就会生成正则表达式，类似于 <code>=2</code>。上述整个过程不需要你输入表达式，只通过选择和配置就可以完成。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00592.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-28　触发器配置监控项表达式</strong></p>\n<p>图 9-28 中有一个 Tab 项叫依赖关系（Dependencies），这是触发器的告警依赖，在实际场景中非常有用。它被使用在特殊场景中，例如当整个 IDC 机房的路由出现故障时，机房里所有机器的网络状态都会出现异常，Zabbix Server 会收到大量异常报警，运维人员会被报警信息淹没，而且不知道故障的真正原因。此时就可以在依赖关系中选择对应规则，并且勾选 Multiple PROBLEM events generation 选项。之后，会收到一条报警信息某 IDC 机房路由器 X 发生故障，这是聚合其他报警信息得到的结果。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置处理动作（Action）</strong></p>\n<p>触发器用于定义触发事件的规则，此处的处理动作就是触发事件后所做的事情。也就是说当触发器条件为真时，处理动作会执行一些操作。比如发送事件通知（短信、钉钉、邮件）、远程执行命令（重启服务）。配置处理动作需要遵从图 9-29 中的几个步骤：选择事件来源 → 基本信息 → 条件设置 → 操作设置。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00593.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-29　配置处理动作的步骤</strong></p>\n<p>Zabbix 中有多种事件类型，触发器只是其中一种，例如自动发现监控设备、自动注册监控设备等。如图 9-30 所示，在“新的触发条件”的下拉框中可以选择诸如触发器名称、触发器、应用集、主机之类的选项。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00594.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-30　选择触发条件</strong></p>\n<p>然后，填写处理动作的基本信息，例如名字、主题、默认发送的消息内容、异常恢复主题及其对应的消息内容。这些信息可以填写字符串，但更多时候会使用宏，其实就是替换字符，比如填写 <code></code> 表示事件名字、<code></code> 表示触发事件的条件。把这些字符串或者宏拼接起来，就形成了最终的信息。如图 9-31 所示，在“默认标题”和“消息内容”中都是使用宏填写了一些与触发事件有关的信息。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00595.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-31　处理动作操作内容</strong></p>\n<p>接下来配置条件（Condition），由于处理动作可以面对一个或者多个触发器，每个触发器又都有一个或者多个条件，因此为了保证灵活性，使用 AND（和）、OR（或）、AND/OR（和/或）对条件进行组合。如图 9-32 所示，使用 AND（和）将条件 A 和条件 B 组合起来，意为当这两个条件同时满足时触发后续操作。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00596.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-32　配置条件</strong></p>\n<p>当然处理动作的目的是在事件触发以后进行操作（Operation），也可以对操作进行定义，包括执行操作的时间间隔、执行操作的次数、每次执行的时间、操作类型（发送消息、执行命令）、发送给哪些用户/用户组等。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置模板（Template）</strong></p>\n<p>如果有多个监控设备需要配置，那么运维人员将面对巨大的工作量。于是，Zabbix 会将相同的监控项、触发器、应用集等规则项放到一起，于是产生了模板（Template）。例如当需要配置监控项的设备都是同类型时，就可以选择现成的监控项模板，这样便减少了运维人员的工作量。在创建模板的时候，需要输入模板名字，以及对应的分组。</p>\n<p>如果需要继承模板，可以在 Linked template 中进行配置。模板继承可以理解为模板嵌套，例如事先定义了一个基础模板，监控项（CPU、内存、硬盘、网卡等）也配置好了，如果需要在这个基础模板上扩展其他模板，比如 MySQL 监控模板或者 WEB 监控模板，那么在配置的时候，就可以继承基础模板，而不需要重新定义。模板创建完毕后，就可以添加监控项、触发器、应用集等信息，具体的添加方式和前面所讲内容类似。</p>\n<p>至此 Zabbix 构建监控系统的过程已经讲述完毕。为了方便记忆，这里做个总结。Zabbix 构建监控系统时，先安装 Zabbix Agent 到 Host 上收集信息，Zabbix Server 用来获取信息，Zabbix UI（Web）用来展示和配置信息。Zabbix Agent 在 Host 中配置好监控服务器的 IP 地址和 Port 之后，回到 Zabbix Server 上，通过 Zabbix UI（Web）对要监控的 Host 进行配置，依次配置监控项（监控什么数据）、触发器（故障触发条件）和 Action（故障触发后的动作）。</p>\n</li>\n</ul>\n<h3 id=\"nav_point_180\">9.6.3　Zabbix 监控方式</h3>\n<p>9.6.1 节曾提到 Zabbix Agent 监控，这只是 Zabbix 监控方式的一种。针对不同情况，Zabbix 还提供了 SNMP、IPMI、JMX 等多种方式。即使是 Zabbix Agent 方式，也分为主动和被动两种。如图 9-33 所示，处在图中间的 Zabbix Server 通过 TCP 协议与左上角的 Zabbix Agent 连接起来，根据主动和被动两种监控方式，Zabbix Server 占用两个不同的端口号。针对 Java 应用程序，Zabbix Server 通过 JMX 方式和左下角的 Zabbix Java Gateway 连接起来。另外，Zabbix Server 通过 SNMP 协议连接右上角的网络设备，通过 IPMI 协议连接右下角的硬件设备。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00597.jpeg\" alt=\"\" width=\"95%\" style=\"width: 95%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-33　Zabbix 监控方式逻辑图</strong></p>\n<p>上图集中介绍了 Zabbix 的几种监控方式，下面展开进行说明。</p>\n<ul>\n<li><p><strong>Zabbix Agent 监控方式</strong></p>\n<p>该方式分为主动模式（Active）和被动模式（Passive）。Zabbix Server 和 Zabbix Agent 之间的通信是通过 Zabbix 专用协议完成的，数据格式为 JSON。</p>\n<p>Zabbix Agent 默认工作在被动模式下，由 Zabbix Server 向 Zabbix Agent 获取信息。安装完 Zabbix Agent 以后，通过修改 zabbix_agentd.conf 文件中的 <code>Server</code> 参数设置 Zabbix Server 的 IP 地址。被动模式下，Zabbix Agent 与 Zabbix Server 的通信流程如图 9-34 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00598.jpeg\" alt=\"\" width=\"88%\" style=\"width: 88%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-34　被动模式流程图</strong></p>\n<p>图中的各步骤如下。</p>\n<p>(1) Zabbix Server 打开一个 TCP 连接。</p>\n<p>(2) Zabbix Server 发送一个 Key（<code>agent.ping\\n</code>）给 Zabbix Agent。</p>\n<p>(3) Zabbix Agent 接收到请求，然后响应请求，返回信息 <code>&lt;HEADER&gt;&lt;DATALEN&gt;</code> 给 Zabbix Server。</p>\n<p>(4) Zabbix Server 接收客户端返回的数据，并进行处理。</p>\n<p>(5) Zabbix Server 关闭 TCP 连接。</p>\n<p>接着再来看看主动模式下，Zabbix Agent 与 Zabbix Server 的通信。</p>\n<p>这种模式下，Zabbix Agent 会主动上报监控信息给 Zabbix Server。通过修改 zabbix_agentd.conf 文件中的 <code>ActiveServer</code> 参数配置 Zabbix Server 的 IP 地址。还需配置 Zabbix Server 上的监控项类型，设置为 Zabbix 客户端（主动式）即可。依旧来看看流程图，如图 9-35 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00599.jpeg\" alt=\"\" width=\"73%\" style=\"width: 73%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-35　主动模式流程图</strong></p>\n<p>图中的各步骤如下。</p>\n<p>(1) Zabbix Agent 向 Zabbix Server 建立一个 TCP 连接。</p>\n<p>(2) Zabbix Agent 请求需要监控的数据列表。</p>\n<p>(3) Zabbix Server 响应 Zabbix Agent，发送一个监控项列表，包括 <code>Item key</code> 和 <code>delay</code>。</p>\n<p>(4) Zabbix Agent 响应 Zabbix Server 的请求。</p>\n<p>(5) Zabbix Server 接收请求数据，关闭 TCP 连接。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>SNMP 监控方式</strong></p>\n<p>SNMP（Simple Network Management Protocol，简单网络管理协议）是一个标准的管理 IP 网络设备的协议，包括路由器、交换机、UPS、打印机等。尤其是当 Host 无法安装 Zabbix Agent 的时候，会使用这种监控方式。先来一起看看 SNMP 的架构，如图 9-36 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00600.jpeg\" alt=\"\" width=\"75%\" style=\"width: 75%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-36　SNMP 架构图</strong></p>\n<p>NMS 是 Network Management System（网络管理系统，又名网络管理站）的缩写，集成在 Zabbix Server 中，采用 SNMP 协议管理和监控网络设备。NMS 既可以发送请求给 Zabbix Agent，查询或修改监控的具体参数值，也可以接收 Zabbix Agent 主动发来的信息，得知所管理设备的状态。</p>\n<p>Agent 是 SNMP 访问 Host 的代理，为设备提供使用 SNMP 协议的能力，负责 Host 与 NMS 之间的通信。SNMP Agent 是 Host 上运行的一个代理进程，用来维护 Host 的信息数据，以及响应来自 NMS 的请求，并把管理数据汇报给发送请求的 NMS。Agent 接收到 NMS 的请求信息后，通过 MIB 表完成相应指令，然后把操作结果响应给 NMS。当 Host 发生故障时，Agent 会主动发消息通知 NMS，报告 Host 的状态变化。</p>\n<p>MIB（Management Information Base）是一个数据库，保存 Host 维护的变量信息，例如内存空间、磁盘大小。变量结构包含对象的名称、对象的状态、对象的访问权限和对象的数据类型等。MIB 通常以树结构形式存在，每个叶子结点各保存一条数据，数据以 OID（Object Identifier）作为唯一标识。也可以把 MIB 看作 NMS 和 Host 之间的接口，NMS 通过它对 Host 维护的变量进行查询、设置。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>IPMI 监控方式</strong></p>\n<p>IPMI（Intelligent Platform Management Interface）即智能平台管理接口，原本是 Intel 架构中企业系统的周边设备采用的一种工业标准，后来成为了业界的通用标准。用户可以通过 IPMI 监视服务器的物理特征，例如温度、电压、电风扇工作状态、电源供应等。IPMI 独立于 CPU BIOS 和操作系统存在，也就是说即使在缺少操作系统和管理软件的情况下，依旧可以监控硬件信息。IPMI 在 Zabbix 中的具体配置，这里不展开描述。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>JMX 监控方式</strong></p>\n<p>JMX（Java Management Extensions）框架用于为 Java 应用程序植入管理功能，是一套标准的代理和服务，用户可以在任何 Java 应用程序中使用它。在 Zabbix 中，JMX 通过专门的代理程序获取监控数据，即 Zabbix Java Gateway，它负责采集数据，通过和 JMX 的 Java 应用程序通信来获取数据。Zabbix Server 和 Zabbix Java Gateway 的关系如图 9-37 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00601.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-37　JMX 调用流程</strong></p>\n<p>JMX 在 Zabbix 中的具体配置过程如下。</p>\n<p>(1) 选择一个单独的服务器安装 Zabbix Java Gateway，最好和 Zabbix Server 安装在不同服务器上。</p>\n<p>(2) 在安装 Zabbix Java Gateway 的服务器上，针对 zabbix_java_gateway.conf 文件进行参数配置。主要是配置 Gateway 监听的服务器的 IP 地址和 Port，目的是让 Gateway 找到要监听的设备。</p>\n<p>(3) 在 Zabbix Server 上配置 zabbix_server.conf 文件中的参数。主要是配置 Gateway 的 IP 地址和 Port，以及 Java 监控的进程数，目的是让 Zabbix Server 找到 Gateway。</p>\n<p>(4) 在 Host 上，针对 Java 应用程序开启 JMX 协议。</p>\n<p>(5) 回到 Zabbix UI（Web），配置由 JMX 监控的 Java 应用程序。</p>\n</li>\n</ul>\n<h2 id=\"nav_point_181\">9.7　Prometheus 实现监控系统</h2>\n<p>Prometheus 是一套基于时序数据库的系统监控报警框架，由 SoundCloud 的工程师（前 Google 工程师）建立，其受 Google 公司 Borgmon 监控系统的启发而产生。</p>\n<h3 id=\"nav_point_182\">9.7.1　Prometheus 系统架构</h3>\n<p>和其他监控系统一样，Prometheus 也是由若干个组件组成，这些组件合作完成监控、存储、查询、报警、展示等工作。这里我们来看看其架构是怎样设计的，如图 9-38 所示，这是 Prometheus 官网的架构图，直观起见，我们给图中关键的组件交互标上数字。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00602.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-38　Prometheus 的架构图</strong></p>\n<p>下面跟着图中的数字记号来了解一下整个系统是如何运作的。</p>\n<p>① Prometheus 属于时序数据库，其数据结构以 Metric 方式存在，为了获取这些 Metric 中的数据，Prometheus 会在系统或者应用上安装对应的 Exporter 去拉取数据。尽管有些系统会自带一些 Metric 的数据接口，但是对于那些未提供此接口的系统或者应用，就需要 Prometheus 为其提供对应的 Exporter，例如 MySQL server exporter、InfluxDB exporter、AWS CloudWatch exporter 等。</p>\n<p>② Exporter 提供的是 Pull（拉）的方式，意思是由 Prometheus 主动请求系统或者应用，从而拉取它们上面的数据。但是一些周期性运行的服务，特别是短时间运行的作业（Short-lived jobs），就不能采取 Pull（拉）的方式了，它们需要主动把数据 Push（推）到 Prometheus Server 上，这个过程中会经过 Pushgateway，Pushgateway 会暴露 Metric 端点，由此端点将收集的数据传递到 Prometheus Server 中。</p>\n<p>③ Prometheus 可以建立集群，这样单个 Prometheus Server 也可以拉取其他 Prometheus Server 上的 Metric 数据。</p>\n<p>④ 由于 Prometheus 是主动拉取系统或者服务的数据，因此会涉及服务发现问题，也就是说从哪些服务上获取 Metric 信息，搞清楚这点在分布式微服务场景中尤为重要。因此这里引入了 Service Discovery 机制，通过它注册的服务去拉取信息，目前 Prometheus 支持 DNS、Kubernetes、Consul 等服务发现方式。</p>\n<p>⑤ 说完了 Prometheus 外围的几个组件以后，回到 Prometheus Server 内部的几个核心模块。Retrieval 是负责数据拉取的模块，它通过配置信息或者服务发现机制获取 Metric 信息。Storage 模块将 Retrieval 模块获取的信息存储到本地的磁盘上（HDD/SSD）。如果需要查询存储的信息，则可以通过 PromQL，也就是 Prometheus 查询语言，它能够通过外部 Web UI 或者第三方接口的方式查询磁盘中存储的监控信息。</p>\n<p>⑥ 右上角的 Alertmanager 顾名思义是告警模块。Prometheus Server 会定义告警规则，一旦其规则被满足，就会触发告警事件，从而通知 Alertmanager 告警模块发起消息告警。这里的 Alertmanager 可以对接多个外部的告警接口，例如 Email（邮件）等，同时它还对告警信息起到去重、分类、路由的作用。</p>\n<p>⑦ 右下角的部分是 Prometheus 的展示模块，虚线包围的是 Prometheus 自带的展示模块，例如 Web UI、PromDash。实线包围的是 Prometheus 对接的第三方展示模块，例如 Grafana。同时，Prometheus 还可以通过 API 的方式与其他展示平台做对接。</p>\n<h3 id=\"nav_point_183\">9.7.2　时间序列与 Metric 数据模型</h3>\n<p>由于 Prometheus 属于度量类监控系统，因此会使用时序数据库保存监控信息。其存储数据的模型与图 9-17 相似，只是在具体实现上有所不同，如图 9-39 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00603.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-39　Prometheus 时间序列与 Metric 数据模型</strong></p>\n<p>下面跟着图 9-39 中的序号来看看 Prometheus 数据模型的构成。</p>\n<p>① 图中画了一个坐标轴，横轴表示时间，从左往右意味着时间的流逝。图中每一个黑点都表示对应时间点的监控值或者采样样本。被框起来的第一行黑点组成的序列就是时间序列，这个时间序列监控的内容由其右边虚线框中的 Metric 描述。此描述中的 <code>http_request_total</code> 就是 Metric Name，用来描述对应时间序列监控的内容是请求数，<code>status=\"200\"</code> 和 <code>method=\"GET\"</code> 是 Label 或者 Tag，作用是对监控内容进行条件约束，具体是采集请求状态为 200，并且请求方式为 GET 的 HTTP 请求的数量。</p>\n<p>② 时间序列由一连串描述监控目标的点组成，其中每个监控点的内容更为具体。聚焦到单个监控点，我们会发现其内容中除了第 ① 步里 Metric 描述中的 Metric Name 和 Labels（多个 Label），还包含用来描述采集时间的 Timestamp（时间戳），以及用来描述具体监控值的 Value，这 4 部分元素组成了单个监控点的完整内容。</p>\n<p>③ 时序数据库通过键值对的方式保存数据，Prometheus 也不例外，Metric Name、Labels 和 Timestamp 组成了键，用来唯一标识监控点，再加上具体监控值 Value，便组成了键值对。而且这里和 9.4.3 节中描述的一样，时序数据最开始是放到内存中的，随着时间的推移和阈值的设置，会被合并保存到磁盘中。</p>\n<p>从数据模型或者存储结构的角度讲，Prometheus 中的 Metric 描述结构都相同，但其实不同场景下的 Metric 描述是存在差异性的。例如 <code>node_load1</code> 用于反映当前系统的负载状态，其值会随着系统负载的不同而上下变化，且变化方向不定；而 <code>node_cpu</code> 反映的是 CPU 的累计使用时间，随着 CPU 的使用，这个值是持续增大的，或者说是只增不减的。</p>\n<p>为了方便识别监控指标，Prometheus 将 Metric 描述分为四类，分别是 Counter、Gauge、Histogram、Summary。</p>\n<ul>\n<li><strong>Counter</strong>：计数器，特点是只增不减。常见的 Counter 类监控指标如 <code>http_requests_total</code>（HTTP 请求数）、<code>node_cpu</code>（CPU 累计使用时间）。为这种类型的指标定义名称时，大多会以 <code>_total</code> 作为后缀。</li>\n<li><p><strong>Gauge</strong>：仪表盘，可增可减，用于反映系统的当前状态。常见的 Gauge 类指标如 <code>node_memory_MemFree</code>（节点空闲内存）。</p>\n</li>\n<li><p><strong>Histogram</strong>：直方图，用于展示一段时间内的数据采样，并对指定区间内的数据进行统计，通常以直方图的形式展示。例如 <code>prometheus_local_storage_series_chunks_persisted</code>（每个时序需要存储的 chunk 数量）。</p>\n</li>\n<li><strong>Summary</strong>：摘要，用于展示一段时间内的数据采样结果，常用于跟踪事件发生的规模，例如请求耗时、响应大小。提供计数和求和功能，并且支持计算分位点，能够以百分比的形式划分跟踪结果。</li>\n</ul>\n<h3 id=\"nav_point_184\">9.7.3　Exporter 采集数据与服务发现</h3>\n<p>明确了采集内容，就需要有采集机制去实施采集，本节要讲的就是 Prometheus 提供的用来监控样本数据的程序——Exporter，它会运行在各个不同的系统或者应用上。由于 Prometheus 是通过 Pull（拉）的方式获取监控信息的，因此 Exporter 的运行实例称为 Target，同时 Prometheus Server 通过轮询的方式定期从 Target 上获取样本数据。</p>\n<p>Exporter 作为数据采集的重要组件，有两个实现来源。</p>\n<ul>\n<li><strong>社区提供</strong>：Prometheus 社区提供了丰富的 Exporter 实现，包括数据库、硬件、消息队列、存储、HTTP 服务、API 服务、日志、对接其他监控系统等。</li>\n<li><strong>用户自定义</strong>：用户可以通过 Prometheus 提供的 Client Library 创建自己的 Exporter 程序。目前 Prometheus 社区官方提供对 Go、Java/Scala、Python、Ruby 等语言的支持。</li>\n</ul>\n<p>Exporter 的运行方式可分为如下两类。</p>\n<ul>\n<li><strong>独立式</strong>：由于系统或者应用本身并不支持 Prometheus，因此为了实现与 Prometheus Server 的信息交互，就需要在监控的机器上安装 Export。Export 通过独立运行的方式，将系统的运行数据样本转换为可供 Prometheus Server 读取的数据。MySQL Exporter、Redis Exporter 等都属于这种方式。这种 Exporter 可以理解为代理、Carside，起到了转换器（adapter）的作用。</li>\n<li><strong>集成式</strong>：有些系统架构对 Prometheus 比较友好，同时也为了能够更好地监控系统运行状态，会通过 Prometheus 中的 Client Library，在代码中实现对 Prometheus Server 信息格式的转换和传输。例如 Kubernetes 就在代码中集成了对 Prometheus 的支持。说白了就是通过客制化的方式，让应用程序直接将运行数据暴露给 Prometheus。</li>\n</ul>\n<p>可以使用 Exporter 采集系统、应用（数据库、缓存等）中的静态资源。由于 Prometheus 采用的 Pull 模式获取这些数据，因此需要在 Prometheus Server 上配置 static_configs 文件，以获得对应系统服务的 IP 地址和 Port，从而让 Prometheus Server 发现要监控的资源。这种方式需要手动在配置文件中添加监控信息，适用于监控资源不多的情况，随着监控的节点数量的增加，特别是对于拥有成百上千个节点的集群，手动方式就不太理想了。Prometheus 为这种场景提供了一套服务发现功能，这种方式能够自动识别新增节点和变更节点。特别是在通过容器部署的环境或者云平台中，服务发现功能可以自动发现并监控节点或更新节点，动态地与监控节点和应用建立联系。目前 Prometheus 已经支持多种服务发现模式，其中使用较多的是 sd_config、DNS、Kubernetes、Consul 等。</p>\n<p>Prometheus 的服务发现模式的原理实际上和 3.3 节服务发现与注册的原理如出一辙，核心都是引入服务发现中心充当代理。把原来从静态文件 static_configs 中获取服务信息的方式，转换为从这个代理中获取，这个代理中包括服务的所有信息。Prometheus 要拉取信息时，只需要从代理这里获取服务的访问方式就可以了。如图 9-40 所示，这里通过四步完成服务信息的拉取。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00604.jpeg\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-40　Prometheus 的服务发现模式</strong></p>\n<p>图中的 4 个步骤分别如下。</p>\n<p>① 服务一旦上线，就将自身的信息（访问方式）注册到 Service Discovery 中，因此 Service Discovery 中保存着所有服务的信息列表。</p>\n<p>② 同时，Prometheus Server 会找 Service Discovery 订阅服务的信息。</p>\n<p>③ Service Discovery 一旦检测到服务的上线、下线或者变更，就会通知 Prometheus Server 更新服务列表。</p>\n<p>④ 在获取了服务的具体访问方式以后，Prometheus Server 会主动地定期到具体服务上拉取监控数据。</p>\n<p>前面提到 Prometheus 的服务发现和注册是一个抽象概念，它作为代理，在不同场景下会有不同的实现。例如在 Kubernetes 容器管理平台中，Kubernetes 管理所有的容器以及服务信息，那么此时 Prometheus Server 就需要与 Kubernetes 通信，才能发现容器和服务信息。又如在微服务架构中，会通过 Consul 完成服务发现与注册。除此之外，Prometheus 还支持基于 DNS 以及文件的方式动态发现监控目标，从而减少了在云原生与微服务模式下实施监控的难度。</p>\n<h3 id=\"nav_point_185\">9.7.4　报警规则的定义和报警路由的分发</h3>\n<p>正如上一节讲的，Prometheus 会在监控节点上安装 Exporter，Exporter 的运行实例是 Target，Prome-theus 通过 Pull 的方式获取 Target 采集的 Metric 信息。监控的目的其实是获取数据，及时发现异常，然后进行报警或者数据分析。其中报警机制是监控系统非常重要的组成部分，在 Prometheus 中，报警由两部分组成：报警规则的定义和报警路由的分发。Prometheus 报警架构如图 9-41 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00605.jpeg\" alt=\"\" width=\"95%\" style=\"width: 95%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-41　Prometheus 报警架构</strong></p>\n<p>下面看看 Prometheus 报警架构中的各部分。</p>\n<p>① Prometheus Server 通过 Target 拉取分布式节点上的 Metric 信息，在拉取的同时会根据“报警规则”文件中定义的内容触发报警。一旦触发报警，就会通知 Alertmanager 执行具体报警信息的路由和发送。</p>\n<p>② Alertmanager 会对报警信息进行分组，通过报警路由（Route）将报警信息发送给对应的报警接收者（Receiver），方式包括 Email 等。Alertmanager 会对全局配置、报警模板、报警路由、报警接收者、抑制规则等展开具体配置。</p>\n<p>③ 由针对静默规则的配置需要 Web UI 和 amtool 来完成，因此静默规则被放到 Alertmanager 之外。</p>\n<p>图 9-41 描述的是 Prometheus 报警的架构和流程，下面给大家展开介绍报警规则的定义和报警路由的分发两方面内容。</p>\n<ul>\n<li><p><strong>报警规则的定义（Prometheus Server）</strong></p>\n<p>在讲解图 9-41 的时候我们提到，Prometheus Server 会通过文件的方式配置报警规则，我们截取该文件的一个片段，其中就定义了一个报警规则：</p>\n<pre class=\"code-rows\"><code>groups:\n- name: node_alert\nrules:\n- alert: HighCPURate  ①\nexpr: 100 - avg(irate(node_cpu_seconds_total[5m])) by (\n    instance) *100 &gt; 80    ②\nfor: 10m   ③\nlabels:\nseverity: page\nannotations:    ④\nsummary:  CPU rate latency</code></pre>\n<p>下面我们通过代码中的序号来看看都有哪些内容。</p>\n<p>① 在报警规则文件中，可以将一组具有相关性的规则定义在一个 <code>groups</code> 下，每个 <code>groups</code> 中都可以定义一个或者多个报警规则。定义一个报警首先就是定义报警规则的名称。这个例子是监控 CPU 使用率，因此将名称起为 CPURate，于是有了 <code>alert: HighCPURate</code> 的定义。</p>\n<p>② 设置好报警名称后，就是设置具体的报警规则了，在 <code>expr</code> 后面加上一串 PromQL 的表达式来定义触发报警的条件。PromQL 是 Prometheus Query Language 的缩写，是 Prometheus 查询数据的一种方法。具体到这块代码中，<code>expr</code> 后面跟着的表达式的意思是每 5 分钟查询一次节点上的 CPU 使用率是否大于 80%，如果满足这个条件就会触发报警。在了解完配置文件后，我们会详细分析这里提到的 PromQL。</p>\n<p>③ <code>for</code> 参数的含义是评估等待时间，意思是在满足触发条件持续一段时间后再发送报警信息。这里设置的参数值是 <code>10m</code>，也就是当节点上的 CPU 使用率持续 10 分钟都大于 80% 后，才会发送报警信息。这种限制一方面是为了避免误报，一方面是考虑到某些参数可能存在暂时状态。</p>\n<p>④ <code>annotations</code> 下面的 <code>summary</code>，顾名思义，用于添加一段附加信息，例如报警详情，这段信息会和报警消息一同发送给 Alertmanager。</p>\n<p>以上只是众多报警规则文件中的一个，在 Prometheus 全局配置文件中可以定义 <code>rule_files</code>，使之对应多个报警规则文件的访问路径，Prometheus 启动后便会自动扫描这些路径下的规则文件，从而实现对多个报警规则的加载和应用。</p>\n<p>现在补充一下 PromQL 的知识，这里就拿上述代码中出现的那段 PromQL 表达式进行讲解。如图 9-42 所示，将 PromQL 语句拆解成四层。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100014/image00606.jpeg\" alt=\"\" width=\"95%\" style=\"width: 95%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 9-42　拆解 PromQL 语句</strong></p>\n<p>① <code>node_cpu_seconds_total</code> 函数是计算节点上 CPU 运行时间的 Metric，这里是计算 CPU 的总共运行时长（单位是秒）。这里在其参数中加入了两个 label 作为条件，<code>job=\"node\"</code> 指定的是作业名称，描述具有同样监控实例的集合；<code>mode=\"idle\"</code> 指的是 CPU 的空闲状态。将整个语句合起来，意思就是查询节点上 CPU 的空闲时间。</p>\n<p>② 在 <code>node_cpu_seconds_total</code> 函数外边包裹了 <code>irate</code> 函数，用来计算一定时间范围内 Metric 增加的速率，因此在函数的后面加入 <code>[5m]</code> 作为参数，意思是计算五分钟内节点的 CPU 空闲率是多少。</p>\n<p>③ <code>irate</code> 函数外面包裹着一个 <code>avg</code> 聚合函数，该函数通过 <code>by(instance)</code> 的方式获得集群中节点 CPU 的平均空闲率。实际就是对多个节点的 CPU 空闲率求平均值。</p>\n<p>④ 通过前三步获得了集群中节点 CPU 的平均空闲率，用 1 减去这个值就得到了 CPU 的使用率。对使用率和 80% 做比较，如果 CPU 使用率大于 80%，就触发报警。这里的 PromQL 语句是先给空闲率乘以 100，将其转换成整数做的比较。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>报警路由的分发（Alertmanager）</strong></p>\n<p>报警规则的定义负责按照规则触发报警，报警路由的分发则把关注点放到如何处理报警信息，以及将这些信息发给谁上。和定义报警规则时一样，Alertmanager 的路由分发规则也是通过配置文件实现的，路由配置文件是一个基于 label 匹配的树状结构。Alertmanager 在接收到报警信息以后，会根据配置文件中的处理规则进行处理。配置文件中的内容分为以下几个部分。</p>\n<ul>\n<li><code>global</code>：全局配置。用于定义全局的公共参数，例如全局的 SMTP 配置、邮箱地址、邮箱的用户名、密码。</li>\n<li><code>templates</code>：报警模板。这是定义报警通知时的模板，可以通过替换字符和固定字符串的方式配置出想要发送的信息。例如 HTML 模板、邮件模板等。</li>\n<li><code>route</code>：报警路由。根据 label 匹配，确定应该如何处理当前的报警。</li>\n<li><code>receivers</code>：报警接收者。也就是谁来接收报警，可以是邮箱、微信、Slack、Webhook 等。通过配置路由将报警指向对应的接收人。</li>\n<li><code>inhibit_rules</code>：抑制规则。通过设置该规则，可以屏蔽一些不必要产生的报警信息。</li>\n</ul>\n<p>由于篇幅有限，无法逐个讲述以上配置内容，这里挑选 <code>route</code> 和 <code>receivers</code> 的部分给大家讲解，相关代码如下：</p>\n<pre class=\"code-rows\"><code>route:\nreceiver: 'default-receiver'   ①\ngroup_by: ['instance']   ②\ngroup_wait: 30s      ③\ngroup_interval: 5m  ④\n  routes:\n  - match:\n        severity: critical  ⑤\n        receiver: 'database-team'\n  -match_re:\n        severity: ^( information|warning)$\n        receiver: 'support-team'\nreceivers:      ⑥\n-name: 'database-team'\n email_config:\n -to: 'database-team@sample.com'\n-name: ' support-team'\n email_config:\n -to: 'support-team@sample.com'</code></pre>\n<p>下面我们逐条看看其中的内容。</p>\n<p>① 配置文件中的 <code>route</code> 节点定义了 <code>receiver</code>，对应的值是 <code>default-receiver</code>。在默认情况下，所有的报警信息都会发送给集群管理员 default-receiver。</p>\n<p>② <code>group by</code> 后面紧跟着 <code>instance</code>，意思是针对 label 是 <code>instance</code> 的报警信息进行分组。分组的意思就是把多条报警信息合并到一条中。假设在生产环境中，有 100 台具有 <code>instance</code> 标签的设备同时发出报警信息，这样在没有做分组的情况下就会收到 100 条报警信息，但如果做了分组，这 100 条信息就会汇集成 1 条，说白了就是将同类型的报警信息合并到一起。</p>\n<p>③ 设置 <code>group_wait</code>，这相当于缓冲，意思是将分组报警信息发出之前，先等待一段时间，利用这段时间把分组的报警信息全部收集完毕。这里设置的 <code>30s</code> 就是 30 秒的意思，也就是同组信息并且在 30 秒内出现相同报警，作为一条信息发送。</p>\n<p>④ 设置 <code>group_interval</code>，作用是在分组报警信息发出以后，如果接收到的新报警信息也来自该分组，就先等待指定的一段时间（这里设置的是 <code>5m</code>，也就是 5 分钟），再发送新报警信息。</p>\n<p>⑤ 以上几步定义的 <code>route</code> 标签作为默认路由对报警信息进行处理，这里的 <code>routes</code> 节点是对路由进行进一步的细分，细分的依据是对报警信息进行匹配。这里提供两种匹配方式：字符串验证和正则表达式验证。<code>match</code> 对应的是字符串匹配，需要对报警信息和 <code>severity</code> 标签为 <code>critical</code> 的字符串进行匹配，匹配成功后把这条报警信息转发给接收者 database-team 做处理。与此不同，<code>match_re</code> 对应的是正则表达式匹配，依旧是与 <code>severity</code> 对应的标签做匹配，由于使用了正则表达式，因此这里只要匹配到 <code>information</code> 或者 <code>warning</code> 的标签值，就把报警信息发送给对应的 support-team。</p>\n<p>⑥ 说完了 <code>route</code>，再来看看 <code>receivers</code>。<code>receivers</code> 节点中定义了接收者的名称和发送邮件的地址。此处设置的意思是在把报警消息发送给接收者 database-team 的同时，会将具体信息通过电子邮件发送到它对应的邮箱：database-team@sample.com。同理 support-team 对应的报警信息会被发送到邮箱 support-team@sample.com。</p>\n</li>\n</ul>\n<h2 id=\"nav_point_186\">9.8　总结</h2>\n<p>本章围绕着分布式监控系统的主题展开，按照为什么、是什么、怎么做的思路推进讲解。在为什么部分，提出了分布式应用和服务的分散性、复杂性、烦琐性、及时性，引出分布式监控的本质就是数据收集、分析、异常报警。既然监控系统如此重要，那么哪些数据是需要关注的，本章列举了 Google SRE 手册中的四大监控指标，即延迟、流量、错误和饱和度，并且阐明了创建监控系统的步骤。在是什么部分，对监控系统按照类型和层级进行区分。在监控分类中，讲解了日志类监控（ELK、FileBeat、Logstash）、调用链类监控（ASM、Zipkin）和度量类监控（LSM Tree、LevelDB）。在监控系统分层中，将其从下往上依次分为：网络层、系统层、应用层、业务层、客户端。最后是怎么做，通过介绍 Zabbix 和 Prometheus 这两个监控架构，为本章画上圆满的句号。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 9 章 指标与监控(1)","id":741063},"right":{"article_title":"第 10 章 架构设计思路和要点","id":741065}},"comments":[{"had_liked":false,"id":390070,"user_name":"尹瑞","can_delete":false,"product_type":"c1","uid":1458455,"ip_address":"上海","ucode":"18C63E1780B203","user_header":"","comment_is_top":false,"comment_ctime":1714285482,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636612,"comment_content":"大框架非常有利于从业者建立全局思维","like_count":0}]}