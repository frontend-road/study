{"id":561904,"title":"17｜RISC-V指令精讲（二）：算术指令实现与调试","content":"<p>你好，我是LMOS。</p><p>上节课，我们学习了算术指令中的加减指令和比较指令。不过一个CPU只能实现这两类指令还不够。如果你学过C语言，应该对“&lt;&lt;、&gt;&gt;、&amp;、|、!”这些运算符并不陌生，这些运算符都需要CPU提供逻辑和移位指令才可以实现。</p><p>今天我们就继续学习逻辑指令（and、or、xor）和移位指令 （sll、srl、sra）。代码你可以从<a href=\"https://gitee.com/lmos/Geek-time-computer-foundation/tree/master/lesson16~17\">这里</a>下载。话不多说，我们开始吧。</p><h2>逻辑指令</h2><p>从CPU芯片电路角度来看，其实CPU更擅长执行逻辑操作，如与、或、异或。至于为什么，你可以看看CPU的基础门电路。</p><p>RISC-V指令集中包含了三种逻辑指令，这些指令又分为立即数版本和寄存器版本，分别是andi、and、ori、or、xori、xor这六条指令。我们学习这些指令的方法和上节课类似，也涉及到写代码验证调试的部分。</p><h3>按位与操作：andi、and指令</h3><p>首先我们来学习一下andi、and指令，它们的形式如下所示：</p><pre><code class=\"language-plain\">andi rd，rs1，imm\n#andi 立即数按位与指令\n#rd 目标寄存器\n#rs1 源寄存器1\n#imm 立即数\nand rd，rs1，rs2\n#and 寄存器按位与指令\n#rd 目标寄存器\n#rs1 源寄存器1\n#rs2 源寄存器2\n</code></pre><p>上述代码中rd、rs1、rs2可以是任何通用寄存器，imm是立即数。</p><!-- [[[read_end]]] --><p>andi、and这两个指令完成的操作，我们用伪代码描述如下：</p><pre><code class=\"language-plain\">//andi\nrd = rs1 &amp; imm\n//and\nrd = rs1 &amp; rs2\n</code></pre><p>按位与的操作，就是把rs1与imm或者rs1与rs2其中的每个数据位两两相与。两个位都是1，结果为1，否则结果为0。</p><p>下面我们在工程目录下建立一个and.S文件，写代码验证一下这两个指令，如下所示：</p><pre><code class=\"language-plain\">.globl andi_ins\nandi_ins:\n    andi a0，a0，0xff       #a0 = a0&amp;0xff，a0是C语言调用者传递的参数，a0也是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n\n.globl and_ins\nand_ins:\n    and a0，a0，a1          #a0 = a0&amp;a1，a0、a1是C语言调用者传递的参数，a0是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n</code></pre><p>这里我们已经写好了andi_ins与and_ins函数，分别去执行andi和and指令。</p><p>andi指令是拿a0寄存器和立即数0xff进行与操作。由于立即数是0xff，所以总是返回a0的低8位数据；and指令则是拿a0和a1寄存器进行与操作，再把结果写入到a0寄存器。</p><p>下面我们用VSCode打开工程按下“F5”调试一下，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/9f/85/9fa8f30d6acbe99195857b5412cab385.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是执行完andi a0，a0，0xff指令之后，执行jr ra指令之前的状态。可以看到，a0寄存器中的值确实已经变成2了，这说明运算的结果是符合预期的。</p><p>andi_ins函数返回后，输出的结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/bf/cf81a2914a7d4a04abb5f33b886a53bf.jpg?wh=1920x1018\" alt=\"图片\"></p><p>因为2的二进制数据是（0b00000000000000000000000000000010）与上0xff的二进制数据是（0b00000000000000000000000011111111）结果确实是2，所以返回2，结果是正确的。</p><p>接下来，我们对and_ins函数进行调试。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/ba/26b174f2983d6fcb3f1bee6a2a1513ba.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图展示的是执行完and a0，a0，a1指令之后，执行jr ra指令之前的状态。我们看到a0寄存器中的值已经变成了1，这说明运算的结果是正确的。</p><p>and_ins函数返回后，输出的结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/07/d8923c72b17aa6653ef814ba9a9a4a07.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中因为1的二进制数据是（0b00000000000000000000000000000001）与上1的二进制数据是（0b00000000000000000000000000000001）确实是1，所以返回1，结果完全正确。</p><h3>按位或操作：ori、or指令</h3><p>按位与操作说完了，我们接着来学习一下或指令ori、or，它们的形式如下：</p><pre><code class=\"language-plain\">ori rd，rs1，imm\n#ori 立即数按位或指令\n#rd 目标寄存器\n#rs1 源寄存器1\n#imm 立即数\nor rd，rs1，rs2\n#or 寄存器按位或指令\n#rd 目标寄存器\n#rs1 源寄存器1\n#rs2 源寄存器2\n</code></pre><p>同样地，上述代码中rd、rs1、rs2可以是任何通用寄存器，imm表示立即数。</p><p>我们还是从伪代码的描述入手，看看ori、or完成的操作。</p><pre><code class=\"language-plain\">//ori\nrd = rs1 | imm\n//or\nrd = rs1 | rs2\n</code></pre><p>按位或的操作就是把rs1与imm或者rs1与rs2其中的每个数据位两两相或，两个位有一位为1，结果为1，否则结果为0。</p><p>我们在and.S文件中写写代码，做个验证，如下所示：</p><pre><code class=\"language-plain\">.globl ori_ins\nori_ins:\n    ori a0，a0，0           #a0 = a0|0，a0是C语言调用者传递的参数，a0也是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n\n.globl or_ins\nor_ins:\n    or a0，a0，a1           #a0 = a0|a1，a0、a1是C语言调用者传递的参数，a0是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n</code></pre><p>上述代码中ori_ins与or_ins函数，分别执行了ori和or指令。</p><p>ori指令是拿a0寄存器和立即数0进行或操作，由于立即数是0，所以总是返回a0原本的数据；or指令是拿a0和a1寄存器进行或操作，再把结果写入到a0寄存器。</p><p>我们还是到VSCode里，按下“F5”调试一下，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/0a/5e5ce8070d974bf0e52e754d79007d0a.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是执行完ori a0，a0，0指令之后，执行jr ra指令之前的状态。如果a0寄存器中的值确实已经变成0xf0f0了，就说明运算的结果正确。</p><p>ori_ins函数返回后，输出的结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e6/cc/e61ddf5e843338ea343fa574cf1164cc.jpg?wh=1920x1018\" alt=\"图片\"></p><p>因为0xf0f0的二进制数据是（0b00000000000000001111000011110000）或上0的二进制数据是（0b00000000000000000000000000000000）按位或操作是“有1为1”，所以返回0xf0f0，结果是正确的。</p><p>我们再用同样的方法调试一下or_ins函数，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/c0/5f8a306758312ded463bb189338db7c0.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图展示的是执行完or a0，a0，a1指令之后，执行jr ra指令之前的状态。如果我们看到a0寄存器中的值确实已经变成0x1111了，就说明运算的结果正确，符合预期。</p><p>or_ins函数返回后，输出的结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/57/2d/5757744ae7ef2f103052bdd73c4fee2d.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中or_ins函数第一个参数为0x1000的二进制数据是（0b00000000000000000001000000000000）第二个参数为0x1111的二进制数据是（0b00000000000000000001000100010001）两个参数相或，而按位或操作是“有1为1”，所以返回0x1111，结果是正确的。</p><h3>按位异或操作：xori、xor指令</h3><p>最后，我们再说说逻辑指令中的最后两条指令xori、xor，即异或指令的立即数版本和寄存器版本，它们的形式如下所示：</p><pre><code class=\"language-plain\">xori rd，rs1，imm\n#xori 立即数按位异或指令\n#rd 目标寄存器\n#rs1 源寄存器1\n#imm 立即数\nxor rd，rs1，rs2\n#xor 寄存器按位异或指令\n#rd 目标寄存器\n#rs1 源寄存器1\n#rs2 源寄存器2\n</code></pre><p>形式上和前面与操作、或操作差不多，就不过多重复了。</p><p>xori、xor完成的操作用伪代码描述如下：</p><pre><code class=\"language-plain\">//xori\nrd = rs1 ^ imm\n//xor\nrd = rs1 ^ rs2\n</code></pre><p>按位异或的操作是把rs1与imm或者rs1与rs2其中的每个数据位两两相异或，两个位如果不相同，结果为1。如果两个位相同，结果为0。</p><p>在and.S文件中写代码验证一下，如下所示。</p><pre><code class=\"language-plain\">.globl xori_ins\nxori_ins:\n    xori a0，a0，0          #a0 = a0^0，a0是C语言调用者传递的参数，a0也是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n\n.globl xor_ins\nxor_ins:\n    xor a0，a0，a1          #a0 = a0^a1，a0、a1是C语言调用者传递的参数，a0是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n</code></pre><p>我们已经写好了xori_ins与xor_ins函数，分别是执行xori和xor指令。xori指令是拿a0寄存器和立即数0进行异或操作，由于立即数是0，而且各个数据位相同为0，不同为1，所以同样会返回a0原本的数据 ；而xor指令是拿a0和a1寄存器进行或操作，再把结果写入到a0寄存器。</p><p>下面我们按下“F5”调试一下，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/18/c1526857c0858d8a3aaa677a9f0c2218.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是执行完xori a0，a0，0指令之后，执行jr ra指令之前的状态，我们已经看到a0寄存器中的值已经变成0xff了，这说明运算的结果正确。</p><p>xori_ins函数返回后，输出的结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/14/c1/14b11e93584c57fdd1ff280963fe8fc1.jpg?wh=1920x1018\" alt=\"图片\"></p><p>结合上面这张截图不难发现，我们传递给xori_ins函数的参数是0xff，因为0xff的二进制数据是（0b00000000000000000000000011111111）异或上0的二进制数据是（0b00000000000000000000000000000000）按位异或操作是“相同为0，不同为1”，所以返回0xff，结果是正确的。</p><p>我们再来调试一下xor_ins函数。xor a0，a0，a1指令执行完成之后，执行jr ra指令之前的状态如图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/2d/5f7f46c2d0bfb3606fb3688ba0a2df2d.jpg?wh=1920x1018\" alt=\"图片\"></p><p>我们看到a0寄存器中的值已经变成0了，这说明运算的结果正确，符合预期。</p><p>xor_ins函数返回后，输出的结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/77/50/7715a7a17fb10ce1b92f927af3df6050.jpg?wh=1920x1018\" alt=\"图片\"></p><p>由于我们给xor_ins函数传递了两个相同的参数都是0xffff。因为0xffff的二进制数据是（0b00000000000000001111111111111111）两者异或，按位异或操作是“相同为0，不同为1”，所以返回0，结果是正确的。</p><p>下面我们看一下andi、and、ori、or、xori、xor这六条指令的二进制数据。</p><p>我们打开工程目录下的and.bin文件，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/14/e88bced6c98efd0fc41c012da6581b14.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上述图中的12个32位数据是12条指令，其中六个0x00008067数据是六个函数的返回指令。</p><p>具体的指令形式，还有对应的汇编语句，我用表格帮你做了整理。</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/0c/a26bb58d2d217a803ee0cd37dbfa950c.jpg?wh=1990x1077\" alt=\"\"></p><p>同样地，我带你拆分一下andi、and、ori、or、xori、xor指令的各位段的数据，看看它们是如何编码的。</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/05/f2a7d01e3f94fyyf939a2890e0925e05.jpg?wh=1920x2118\" alt=\"图片\"></p><p>从上图中可以发现，立即数版本和寄存器版本的and、or、xor指令通过<strong>操作码</strong>区分，而它们之间的寄存器和立即数版本是靠<strong>功能位段</strong>来区分，立即数位段和源寄存器与目标寄存器位段和之前的指令是相同的。</p><p>到这里六条逻辑指令已经拿下了，咱们继续学习移位指令。</p><h2>移位指令</h2><p>移位指令和逻辑操作指令一样，都是CPU电路很容易就能实现的。</p><p>RISC-V指令集中的移位指令包括逻辑左移、逻辑右移和算术右移，它们分别有立即数和寄存器版本，所以一共有六条。逻辑右移和算术右移是不同的，等我们后面用到时再专门讲解。</p><h3>逻辑左移指令：slli、sll指令</h3><p>我们先看看逻辑左移指令，也就是slli、sll指令，它们的形式如下所示：</p><pre><code class=\"language-plain\">slli rd，rs1，imm\n#slli 立即数逻辑左移指令\n#rd 目标寄存器\n#rs1 源寄存器1\n#imm 立即数，rs1左移的位数，0~31\nsll rd，rs1，rs2\n#sll 寄存器逻辑左移指令\n#rd 目标寄存器\n#rs1 源寄存器1\n#rs2 源寄存器2，rs1左移的位数\n</code></pre><p>上述代码中rd、rs1、rs2可以是任何通用寄存器。imm是立即数，其实在官方文档中，这里是shamt，表示rs1 左移 shamt 位。这里我为了和之前的形式保持一致，才继续沿用了imm。</p><p><img src=\"https://static001.geekbang.org/resource/image/31/93/31d86b306ec670c9b13ce51a8f898f93.jpg?wh=4127x668\" alt=\"\"></p><p>slli、sll它们俩完成的操作，用伪代码描述如下：</p><pre><code class=\"language-plain\">//slli\nrd = rs1 &lt;&lt; imm\n//sll\nrd = rs1 &lt;&lt; rs2\n</code></pre><p>逻辑左移的操作是把rs1中的数据向左移动imm位，或者把rs1中的数据向左移动rs2位，右边多出的空位填 0 并写入 rd 中。</p><p>我们用图解来表达这一过程，这样你就能一目了然了。</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/4f/7a38a717cfce6c6a07afdeae71b44e4f.jpg?wh=1920x887\" alt=\"图片\"></p><p>接下来我们在工程目录下，建立一个sll.S文件，写代码验证一下，如下所示：</p><pre><code class=\"language-plain\">.globl slli_ins\nslli_ins:\n    slli a0, a0, 4          #a0 = a0&lt;&lt;4，a0是C语言调用者传递的参数，a0也是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n\n.globl sll_ins\nsll_ins:\n    sll a0, a0, a1          #a0 = a0&lt;&lt;a1，a0、a1是C语言调用者传递的参数，a0是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n</code></pre><p>这里已经写好了slli_ins与sll_ins函数，它们会分别执行slli和sll指令。立即数逻辑左移slli指令是把a0中的数据左移4位。而逻辑左移sll指令是把a0中的数据左移，左移多少位要取决于a1中的数据，完成移动后再把结果写入到a0寄存器。</p><p>我们还是用VSCode打开工程，按下“F5”调试，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/14/81/14ce5c27f3821d280a89473f1be2f881.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是进入slli_ins函数，执行完slli a0，a0，4指令之后，执行jr ra指令之前的状态，我们给slli_ins函数传进来的参数是0xffff。现在对照图示就能看到，a0寄存器中的值确实已经变成0xffff0了，这说明运算结果是正确的。</p><p>slli_ins函数返回后，输出的结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/54/96/54b331abb31b9c670501801d9b1a4196.jpg?wh=1920x1018\" alt=\"图片\"></p><p>因为0xffff二进制数据是（0b00000000000000001111111111111111），逻辑左移4位后的结果是0xffff0，它的二进制数据是（0b00000000000011111111111111110000），结果正确无误。</p><p>下面我们接着对sll_ins函数进行调试，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/e6/fd743ff7bc5a08326a930117a312e9e6.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是进入sll_ins函数，执行完sll a0，a0，a1指令之后，执行jr ra指令之前的状态，我们给sll_ins函数传进来的参数是0xeeeeeeee和31（a1寄存器）。如果看到a0寄存器中的值确实已经变成0了，这说明运算结果是正确的。</p><p>sll_ins函数返回后，输出的结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/dc/40/dcd32534bbb191edea2863106173fc40.jpg?wh=1920x1018\" alt=\"图片\"></p><p>第一个参数0xeeeeeeee的二进制数据是（0b11101110111011101110111011101110），逻辑左移31位后的结果是0，因为它把所有的二进制数据位都移出去了，然后空位补0，所以结果正确无误。</p><h3>逻辑右移指令：srli、srl</h3><p>有逻辑左移就有逻辑右移。逻辑右移指令srli、srl，分别对应着立即数和寄存器版本，它们的形式如下：</p><pre><code class=\"language-plain\">srli rd，rs1，imm\n#srli 立即数逻辑右移指令\n#rd 目标寄存器\n#rs1 源寄存器1\n#imm 立即数，rs1右移的位数，0~31\nsrl rd，rs1，rs2\n#srl 寄存器逻辑右移指令\n#rd 目标寄存器\n#rs1 源寄存器1\n#rs2 源寄存器2，rs1右移的位数\n</code></pre><p>上述代码中rd、rs1、rs2可以是任何通用寄存器。imm是立即数。为了和之前的形式保持一致，我们还是沿用imm，而非官方文档中的shamt。</p><p>srli、srl完成的操作，可以用后面的伪代码来描述：</p><pre><code class=\"language-plain\">//srli\nrd = rs1 &gt;&gt; imm\n//srl\nrd = rs1 &gt;&gt; rs2\n</code></pre><p>逻辑右移的操作是把rs1中的数据向右移动imm位。或者把rs1中的数据向右移动rs2位，左边多出的空位填 0 并写入 rd 中。</p><p>你可以对照我画的图示来理解这一过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/ef/96/efabf037545b87932a801fd0d0f52b96.jpg?wh=1920x852\" alt=\"图片\"></p><p>光看看格式自然不够，我们在sll.S文件中写段代码来验证一下，如下所示：</p><pre><code class=\"language-plain\">.globl srli_ins\nsrli_ins:\n    srli a0, a0, 8          #a0 = a0&gt;&gt;8,a0是C语言调用者传递的参数，a0也是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n\n.globl srl_ins\nsrl_ins:\n    srl a0, a0, a1          #a0 = a0&gt;&gt;a1,a0、a1是C语言调用者传递的参数，a0是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n</code></pre><p>逻辑右移的两个函数srli_ins与srl_ins，我已经帮你写好了。代码中立即数逻辑右移srli指令是把a0中的数据右移8位。逻辑右移srl指令，则是把a0中的数据右移，右移多少位要看a1中数据表示的位数是多少，再把结果写入到a0寄存器。<br>\n两条右移指令做了哪些事儿咱们说完了，老规矩，打开工程按下“F5”就可以调试了，效果如图：</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/9c/5a31254538411e323fde6aa4a9a8189c.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是进入srli_ins函数，执行完srli a0，a0，8指令之后，执行jr ra指令之前的状态，我们给srli_ins函数传进来的参数是0xffff。现在，对照截图可以看到a0寄存器中的值确实已经变成0xff了，这说明运算结果正确。</p><p>srli_ins函数返回后，输出的结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/54/2e/54e7a1bfa5d16657c44006a2145fa12e.jpg?wh=1920x1018\" alt=\"图片\"></p><p>因为调用函数srli_ins的参数0xffff的二进制数据是（0b00000000000000001111111111111111），逻辑右移8位后的结果是0xff，它的二进制数据是（0b00000000000000000000000011111111），结果正确，符合我们的预期。</p><p>拿下了srli_ins函数，接下来就是srl_ins函数的调试，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c9/6f/c93920be7759af658c978a26327e756f.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是调用进入srl_ins函数，执行完srl a0，a0，a1指令之后，执行jr ra指令之前的状态，给srl_ins函数传进来的参数是0xaaaaaaaa。可以看到，a0寄存器中的值确实已经变成0xaaaa了，所以运算结果也是正确的。</p><p>srl_ins函数返回后，输出的结果如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/03/b7/03e4500cb8544ab75f8634094f7b67b7.jpg?wh=1920x1018\" alt=\"图片\"></p><p>给srl_ins函数传进来的第一个参数是0xaaaaaaaa的二进制数据是（0b10101010101010101010101010101010），逻辑右移16位后的结果是0xaaaa，其二进制数据为（0b00000000000000001010101010101010 ），因为它把低16位二进制数据位移出去了，然后高16位的空位补0，所以结果正确无误。</p><h3>算术右移指令：srai、sra</h3><p>最后还有两个算术右移指令，它们和逻辑右移的最大区别是，<strong>数据在逻辑右移之后左边多出空位用0填充，而数据在算术右移之后左边多出的空位是用数据的符号位填充。</strong>如果数据的符号位为1就填充1，如果为0就填充0。</p><p>它们的形式和伪代码与逻辑右移是一样的，只不过指令助记符由srli、srl，变成了srai、sra。</p><p>下面我们直接在sll.S文件中，写代码进行验证。</p><pre><code class=\"language-plain\">.globl srai_ins\nsrai_ins:\n    srai a0, a0, 8          #a0 = a0&gt;&gt;8,a0是C语言调用者传递的参数，a0也是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n\n.globl sra_ins\nsra_ins:\n    sra a0, a0, a1          #a0 = a0&gt;&gt;a1,a0、a1是C语言调用者传递的参数，a0是返回值，这样计算结果就返回了\n    jr ra                   #函数返回\n</code></pre><p>上述代码中的两个函数srai_ins与sra_ins，可以实现算术右移。先看立即数算术右移srai指令，它把a0中的数据右移了8位。而算术右移srl指令是把a0中的数据右移，右移多少位由a1中的数据表示的位数来决定，之后再把结果写入到a0寄存器。</p><p>我们按下“F5”，调试的结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/9a/2b/9aa7f0f2aa4a9abaf23ed0d592d6aa2b.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是进入立即数算术右移函数srai_ins，执行完srai a0，a0，8指令之后，执行jr ra指令之前的状态。对照图里红框的内容可以看到，给srai_ins函数传进来的参数是0x1111。如果a0寄存器中的值确实已经变成0x11了，就代表运算结果正确。</p><p>srai_ins函数返回后，输出的结果如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/90/b8/90f4c5995f6bbcbca6cee49e4ebyy6b8.jpg?wh=1920x1018\" alt=\"图片\"></p><p>因为我们给立即数算术右移函数srai_ins的参数0x1111，其二进制数据是（0b00000000000000000001000100010001），符号位为0，所以算术右移8位后的结果是0x11，它的二进制数据是（0b00000000000000000000000000010001），结果非常正确。</p><p>我们接着调试一下sra_ins函数，如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/35/1d/35de77c0e524003a44025e2be12cb31d.jpg?wh=1920x1018\" alt=\"图片\"></p><p>上图中是进入算术右移函数sra_ins，执行完sra a0，a0，a1指令之后，执行jr ra指令之前的状态。对照图里左侧红框的部分，我们就能知道sra_ins函数传进来的参数是0xaaaaaaaa，你可能判断a0寄存器里输出的结果应该是0x0000aaaa，但调试显示的实际结果却是0xffffaaaa。</p><p>出现这个结果，你很奇怪是不是？但这恰恰说明运算结果是正确的。我们先看看sra_ins函数返回后输出的结果是什么，然后再分析原因。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/18/d885d37ca6d113bdb94f9bdb2edf1318.jpg?wh=1920x1018\" alt=\"图片\"></p><p>因为我们给算术右移函数sra_ins的参数是0xaaaaaaaa和16，这表明对0xaaaaaaaa算术右移16，0xaaaaaaaa的二进制数据是（0b10101010101010101010101010101010），注意<strong>其符号位为1，所以算术右移16位后的结果是0xffffaaaa</strong>，它的二进制数据是（0b11111111111111111010101010101010），结果是符合预期的。输出的结果也证实了这一点。</p><p>下面我们还是要看一下slli、sll、srli、srl、srai、sra这六条指令的二进制数据，我们打开工程目录下的sll.bin文件。</p><p><img src=\"https://static001.geekbang.org/resource/image/fc/22/fc286f7194da0c7d3f8e70b56488fa22.jpg?wh=1920x1018\" alt=\"图片\"></p><p>可以看出，图中的12个32位数据是12条指令，其中六个0x00008067数据是六个函数的返回指令。具体的指令形式，还有对应的汇编语句，你可以参考后面的表格。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/fd/2684dc87df76536ffce7868f50e42dfd.jpg?wh=1920x1002\" alt=\"图片\"></p><p>我们拆分一下slli、sll、srli、srl、srai、sra指令的各位段的数据，看看它们是在内存中如何编码的，你可以结合示意图来理解。</p><p><img src=\"https://static001.geekbang.org/resource/image/21/62/2112acb08732cbbd227b777407a5b262.jpg?wh=1920x1930\" alt=\"图片\"></p><p>我虽然给你详细展示了这些指令如何编码，但并不需要你把细节全部硬记下来，重点是观察其中的规律。</p><p>从上图中我们可以发现，sll、srl、sra指令的立即数版本和寄存器版本要通过操作码区分，而它们之间是靠功能位段来区分的，<strong>源寄存器与目标寄存器所在的位段和之前的指令是相同的</strong>。需要注意的是，这些立即数版本的立即数位段在官方文档中叫shamt位段，并且只占5位，而其它指令的立即数占12位，这里为了一致性还是沿用立即数。</p><p>到这里，六条移位指令我们就讲完了。</p><h2>重点回顾</h2><p>今天我们学习了逻辑指令和移位指令。</p><p>逻辑操作的指令包括andi、ori、or、xori、xor，分别能对寄存器与寄存器、寄存器与立即数进行与、或、异或操作。有了这些操作，CPU才能对数据进行逻辑运算，在一些情况下还能提升CPU的执行性能。更多的应用，后面课程里我们还会继续学习。</p><p>数据移位指令包括slli、sll、srli、srl、srai、sra，也能分别能对寄存器与寄存器、寄存器与立即数进行逻辑左移、逻辑右移、算术右移操作。这些指令与逻辑指令一起执行数据的位运算时，相当有用，在特定情况下能代替乘除法指令。</p><p><img src=\"https://static001.geekbang.org/resource/image/04/f3/0463e88de6e311593bbc497eb8779bf3.jpg?wh=1920x1707\" alt=\"图片\"></p><p>经过漫长的学习，我们用两节课程的篇幅，一鼓作气学习了RISC-V全部的算术指令，分为加减、比较、逻辑、移位四大类别，一共有19条指令。这些指令作用于数据的运算，在应用程序中扮演着重要角色。</p><p>但是CPU有了这些算术指令就够了吗？这显然是不行的，起码还需要流程控制指令和数据加载储存指令，我们会在后续课程中继续讨论。</p><h2>思考题</h2><p>为什么指令编码中，目标寄存器，源寄存器1，源寄存器2，占用的位宽都是5位呢？</p><p>欢迎你在留言区记录自己的疑问或收获，参与越多，你对内容的理解也更深入。如果觉得这节课内容不错，别忘了分享给更多朋友。</p>","comments":[{"had_liked":false,"id":356269,"user_name":"苏流郁宓","can_delete":false,"product_type":"c1","uid":2729645,"ip_address":"湖北","ucode":"AD07BD9CE03047","user_header":"https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg","comment_is_top":false,"comment_ctime":1662100353,"is_pvip":false,"replies":[{"id":129730,"content":"是的 你理解 相当透彻","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1662255752,"ip_address":"湖北","comment_id":356269,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"逻辑运算有时效率高于加减乘除法，就好比十进制运算，有九九乘法表等加持，20个3直接等于60它的效率优于累计加20个3算出，但cpu的算力是软硬件共同的努力，软件方面通过优化算法结构能够直接提升效率，甚至在浮点运算中，好的算法结构能起事半功倍的效果！","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586475,"discussion_content":"是的 你理解 相当透彻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662255752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356267,"user_name":"苏流郁宓","can_delete":false,"product_type":"c1","uid":2729645,"ip_address":"湖北","ucode":"AD07BD9CE03047","user_header":"https://static001.geekbang.org/account/avatar/00/29/a6/ad/e65aec4c.jpg","comment_is_top":false,"comment_ctime":1662099898,"is_pvip":false,"replies":[{"id":129729,"content":"对 ","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1662255715,"ip_address":"湖北","comment_id":356267,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"答案简单，RISCV寄存器一共32个的啊","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586474,"discussion_content":"对 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662255715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356238,"user_name":"贾献华","can_delete":false,"product_type":"c1","uid":1065314,"ip_address":"湖北","ucode":"4D69C026FF8D3D","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/62/33520c3e.jpg","comment_is_top":false,"comment_ctime":1662082241,"is_pvip":true,"replies":[{"id":129732,"content":"对","user_name":"作者回复","user_name_real":"编辑","uid":1345199,"ctime":1662255867,"ip_address":"湖北","comment_id":356238,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"寄存器共 32 位。\n2^5 = 32。","like_count":1,"discussions":[{"author":{"id":1345199,"avatar":"https://static001.geekbang.org/account/avatar/00/14/86/af/99219321.jpg","nickname":"LMOS","note":"","ucode":"B037712C8B8B3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586477,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662255867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1065314,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/62/33520c3e.jpg","nickname":"贾献华","note":"","ucode":"4D69C026FF8D3D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586265,"discussion_content":"寄存器一共 32 个 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662085064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385744,"user_name":"徐大雷","can_delete":false,"product_type":"c1","uid":2548016,"ip_address":"湖北","ucode":"4D6F0D4C58CE93","user_header":"https://static001.geekbang.org/account/avatar/00/26/e1/30/56151c95.jpg","comment_is_top":false,"comment_ctime":1703220893,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100117801,"comment_content":"CPU更擅长计算逻辑操作  -   老师能大致讲解一下为啥么？谢谢","like_count":0}]}