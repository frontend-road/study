{"id":210170,"title":"56 | 观察者模式（上）：详解各种应用场景下观察者模式的不同实现方式","content":"<p>我们常把23种经典的设计模式分为三类：创建型、结构型、行为型。前面我们已经学习了创建型和结构型，从今天起，我们开始学习行为型设计模式。我们知道，创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，那行为型设计模式主要解决的就是“类或对象之间的交互”问题。</p><p>行为型设计模式比较多，有11个，几乎占了23种经典设计模式的一半。它们分别是：观察者模式、模板模式、策略模式、职责链模式、状态模式、迭代器模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。</p><p>今天，我们学习第一个行为型设计模式，也是在实际的开发中用得比较多的一种模式：观察者模式。根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。今天我会重点讲解原理、实现、应用场景。下一节课，我会带你一块实现一个基于观察者模式的异步非阻塞的EventBus，加深你对这个模式的理解。</p><p>话不多说，让我们正式开始今天的学习吧！</p><h2>原理及应用场景剖析</h2><p><strong>观察者模式</strong>（Observer Design Pattern）也被称为<strong>发布订阅模式</strong>（Publish-Subscribe Design Pattern）。在GoF的《设计模式》一书中，它的定义是这样的：</p><!-- [[[read_end]]] --><blockquote>\n<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p>\n</blockquote><p>翻译成中文就是：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><p>一般情况下，被依赖的对象叫作<strong>被观察者</strong>（Observable），依赖的对象叫作<strong>观察者</strong>（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p><p>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式，待会我们会详细地讲到。现在，我们先来看其中最经典的一种实现方式。这也是在讲到这种模式的时候，很多书籍或资料给出的最常见的实现方式。具体的代码如下所示：</p><pre><code>public interface Subject {\n  void registerObserver(Observer observer);\n  void removeObserver(Observer observer);\n  void notifyObservers(Message message);\n}\n\npublic interface Observer {\n  void update(Message message);\n}\n\npublic class ConcreteSubject implements Subject {\n  private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();\n\n  @Override\n  public void registerObserver(Observer observer) {\n    observers.add(observer);\n  }\n\n  @Override\n  public void removeObserver(Observer observer) {\n    observers.remove(observer);\n  }\n\n  @Override\n  public void notifyObservers(Message message) {\n    for (Observer observer : observers) {\n      observer.update(message);\n    }\n  }\n\n}\n\npublic class ConcreteObserverOne implements Observer {\n  @Override\n  public void update(Message message) {\n    //TODO: 获取消息通知，执行自己的逻辑...\n    System.out.println(&quot;ConcreteObserverOne is notified.&quot;);\n  }\n}\n\npublic class ConcreteObserverTwo implements Observer {\n  @Override\n  public void update(Message message) {\n    //TODO: 获取消息通知，执行自己的逻辑...\n    System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);\n  }\n}\n\npublic class Demo {\n  public static void main(String[] args) {\n    ConcreteSubject subject = new ConcreteSubject();\n    subject.registerObserver(new ConcreteObserverOne());\n    subject.registerObserver(new ConcreteObserverTwo());\n    subject.notifyObservers(new Message());\n  }\n}\n</code></pre><p>实际上，上面的代码算是观察者模式的“模板代码”，只能反映大体的设计思路。在真实的软件开发中，并不需要照搬上面的模板代码。观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如register函数还可以叫作attach，remove函数还可以叫作detach等等。不过，万变不离其宗，设计思路都是差不多的。</p><p>原理和代码实现都非常简单，也比较好理解，不需要我过多的解释。我们还是通过一个具体的例子来重点讲一下，什么情况下需要用到这种设计模式？或者说，这种设计模式能解决什么问题呢？</p><p>假设我们在开发一个P2P投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p><pre><code>public class UserController {\n  private UserService userService; // 依赖注入\n  private PromotionService promotionService; // 依赖注入\n\n  public Long register(String telephone, String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-catch代码\n    long userId = userService.register(telephone, password);\n    promotionService.issueNewUserExperienceCash(userId);\n    return userId;\n  }\n}\n</code></pre><p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，如果没有扩展和修改的需求，现在的代码实现是可以接受的。如果非得用观察者模式，就需要引入更多的类和更加复杂的代码结构，反倒是一种过度设计。</p><p>相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改register()函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那register()函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。</p><p>这个时候，观察者模式就能派上用场了。利用观察者模式，我对上面的代码进行了重构。重构之后的代码如下所示：</p><pre><code>public interface RegObserver {\n  void handleRegSuccess(long userId);\n}\n\npublic class RegPromotionObserver implements RegObserver {\n  private PromotionService promotionService; // 依赖注入\n\n  @Override\n  public void handleRegSuccess(long userId) {\n    promotionService.issueNewUserExperienceCash(userId);\n  }\n}\n\npublic class RegNotificationObserver implements RegObserver {\n  private NotificationService notificationService;\n\n  @Override\n  public void handleRegSuccess(long userId) {\n    notificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);\n  }\n}\n\npublic class UserController {\n  private UserService userService; // 依赖注入\n  private List&lt;RegObserver&gt; regObservers = new ArrayList&lt;&gt;();\n\n  // 一次性设置好，之后也不可能动态的修改\n  public void setRegObservers(List&lt;RegObserver&gt; observers) {\n    regObservers.addAll(observers);\n  }\n\n  public Long register(String telephone, String password) {\n    //省略输入参数的校验代码\n    //省略userService.register()异常的try-catch代码\n    long userId = userService.register(telephone, password);\n\n    for (RegObserver observer : regObservers) {\n      observer.handleRegSuccess(userId);\n    }\n\n    return userId;\n  }\n}\n</code></pre><p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController类的register()函数完全不需要修改，只需要再添加一个实现了RegObserver接口的类，并且通过setRegObservers()函数将它注册到UserController类中即可。</p><p>不过，你可能会说，当我们把发送体验金替换为发送优惠券的时候，需要修改RegPromotionObserver类中handleRegSuccess()函数的代码，这还是违反开闭原则呀？你说得没错，不过，相对于register()函数来说，handleRegSuccess()函数的逻辑要简单很多，修改更不容易出错，引入bug的风险更低。</p><p>前面我们已经学习了很多设计模式，不知道你有没有发现，实际上，<strong>设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。</strong>借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p><h2>基于不同应用场景的不同实现方式</h2><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。</p><p>不同的应用场景和需求下，这个模式也有截然不同的实现方式，开篇的时候我们也提到，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p><p>之前讲到的实现方式，从刚刚的分类方式上来看，它是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码。对照上面讲到的用户注册的例子，register()函数依次调用执行每个观察者的handleRegSuccess()函数，等到都执行完成之后，才会返回结果给客户端。</p><p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能短，那我们可以将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间。具体来讲，当userService.register()函数执行完成之后，我们启动一个新的线程来执行观察者的handleRegSuccess()函数，这样userController.register()函数就不需要等到所有的handleRegSuccess()函数都执行完成之后才返回结果给客户端。userController.register()函数从执行3个SQL语句才返回，减少到只需要执行1个SQL语句就返回，响应时间粗略来讲减少为原来的1/3。</p><p>那如何实现一个异步非阻塞的观察者模式呢？简单一点的做法是，在每个handleRegSuccess()函数中，创建一个新的线程执行代码。不过，我们还有更加优雅的实现方式，那就是基于EventBus来实现。今天，我们就不展开讲解了。在下一讲中，我会用一节课的时间，借鉴Google Guava EventBus框架的设计思想，手把手带你开发一个支持异步非阻塞的EventBus框架。它可以复用在任何需要异步非阻塞观察者模式的应用场景中。</p><p>刚刚讲到的两个场景，不管是同步阻塞实现方式还是异步非阻塞实现方式，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的，那如何实现一个跨进程的观察者模式呢？</p><p>如果大数据征信系统提供了发送用户注册信息的RPC接口，我们仍然可以沿用之前的实现思路，在handleRegSuccess()函数中调用RPC接口来发送数据。但是，我们还有更加优雅、更加常用的一种实现方式，那就是基于消息队列（Message Queue，比如ActiveMQ）来实现。</p><p>当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成本。不过，它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。</p><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。</p><p>设计模式要干的事情就是解耦，创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚低耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。不同的应用场景和需求下，这个模式也有截然不同的实现方式，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p><h2>课堂讨论</h2><ol>\n<li>请对比一下“生产者-消费者”模型和观察者模式的区别和联系。</li>\n<li>除了今天提到的观察者模式的几个应用场景，比如邮件订阅，你还能想到有哪些其他的应用场景吗？</li>\n</ol><p>欢迎留言和我分享你的想法。如果有收获，欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"55 | 享元模式（下）：剖析享元模式在Java Integer、String中的应用","id":209343},"right":{"article_title":"57 | 观察者模式（下）：如何实现一个异步非阻塞的EventBus框架？","id":211239}},"comments":[{"had_liked":false,"id":186553,"user_name":"Sinclairs","can_delete":false,"product_type":"c1","uid":1019373,"ip_address":"","ucode":"0042C53C86E3A2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/ed/ea2cbf3a.jpg","comment_is_top":false,"comment_ctime":1583872008,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"723138377736","product_id":100039001,"comment_content":"发布-订阅模型，是一对多的关系，可以以同步的方式实现，也可以以异步的方式实现。<br>生产-消费模型，是多对多的关系，一般以异步的方式实现<br>两者都可以达到解耦的作用","like_count":169,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368507,"discussion_content":"感觉说的不是很准确吧: 发布-订阅模型, 是一对多关系,  多个订阅者可以同时消费到同一个消息; 生产-消费模型, 是多对多关系, 按照生产者-消费者 模型的定义生产者生产的数据一般情况下只会被一个消费者消费","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1618736975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1903790,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/iaQgtbE98VGIVIyribdo6dgLOnaNoe7ZdUuPr60ibsduibscrzQCTzdW2AfL9nxwe8YlSK75gOnK3YbAJKTaFPxibdg/132","nickname":"小李","note":"","ucode":"30BD251EE1B1E2","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590345,"discussion_content":"你这认识有点儿片面和狭隘了，你上面两个模型本质不就是说的一件事儿吗？非得套个不同的名词，发布（生产）—订阅（消费），点对点，一对多，多对多都是可以去理解的啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665668598,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186558,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1583881996,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"426785644300","product_id":100039001,"comment_content":"区别在于生产消费模型以异步形式实现，消费者之间存在竞争关系。发布订阅以同步或异步的方式实现，订阅者之间没有竞争关系。联系在于两者在流程上都有先后关系。","like_count":100,"discussions":[{"author":{"id":2062402,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOnpl8fRB9r2vED2s8j7Arwbn2K6M6HUBWNjgoqV4uqe94fTGK4WGpOJLeRxXcBXk3dp23eQR0AQ/132","nickname":"吴钩","note":"","ucode":"0EB50E8144BCDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570423,"discussion_content":"发布-订阅的异步模式，订阅者之间也可以是并发的，即所谓竞争关系。发布-订阅和生产-消费模型之间界限很模糊，比如kafka两种模式都说得通。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651760525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2870321,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLE9hv64CEabxt76tQQcWDicx0sucpAApFvYoM8eXBViaJgz06EjcfJjiamSFWY9aAuxjILaPoiaa0lNw/132","nickname":"Soil","note":"","ucode":"3B353BC858B5AE","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561439,"discussion_content":"这个可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649641064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311125,"avatar":"https://static001.geekbang.org/account/avatar/00/14/01/95/fd09e8a8.jpg","nickname":"布拉姆","note":"","ucode":"479FF27D73BCAD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392299,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630938051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384835,"discussion_content":"这个还行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626766476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187292,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1584075715,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"319411655619","product_id":100039001,"comment_content":"1.生产消费，一条消息只会被一个消费者消费（评论有人提多对多，确实是区别，但感觉有点误导）。发布订阅，一条消费可以被多个消费者共同消费。<br>2.两者都是行为模式，其实都是切分发布和消费这两个行为。就生产和发布这两个行为来说，只是换了名字，本质上是一样的。而消费和订阅，其实也都是消费消息，只是前者只能有一人来消费，后者是订阅的每个人都可以来消费。<br><br>3.状态机，状态流转的事件发布。（各种有状态业务线都可以用到）。","like_count":75,"discussions":[{"author":{"id":2401303,"avatar":"","nickname":"Geek_bb536a","note":"","ucode":"E85CBFDFDFD7D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574301,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653962488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1115945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/29/e5537b9e.jpg","nickname":"冲鸭","note":"","ucode":"0EF69B02188A73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304337,"discussion_content":"正解，生产消费是观察者的一个特例仅此吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599549174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1115945,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/29/e5537b9e.jpg","nickname":"冲鸭","note":"","ucode":"0EF69B02188A73","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327275,"discussion_content":"消费者是主动拉取\n观察者是被动接收\n\n这点不一样","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1605780351,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304337,"ip_address":""},"score":327275,"extra":""},{"author":{"id":2016408,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","nickname":"罗杰.菲の樂","note":"","ucode":"63590706846EEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1114093,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ed/b2fc0e7c.jpg","nickname":"7","note":"","ucode":"10A6E57A027D42","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562450,"discussion_content":"这个说的好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649827811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327275,"ip_address":""},"score":562450,"extra":""}]}]},{"had_liked":false,"id":187836,"user_name":"一剑","can_delete":false,"product_type":"c1","uid":1022127,"ip_address":"","ucode":"93ADD5B5215D4C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/af/3945cea4.jpg","comment_is_top":false,"comment_ctime":1584256899,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"302231967619","product_id":100039001,"comment_content":"发布订阅和生产消费模型最大的区别在于：发布者（可观测对象）是知道订阅者（观察对象）的存在，因为它需要遍历订阅列表去发布事件；而生产消费模型因为有中间消息代理的存在，生产者和消费者完全不知道对方的存在，完全解耦！","like_count":71},{"had_liked":false,"id":186613,"user_name":"Yeoman","can_delete":false,"product_type":"c1","uid":1350359,"ip_address":"","ucode":"63048466933961","user_header":"https://static001.geekbang.org/account/avatar/00/14/9a/d7/d8520096.jpg","comment_is_top":false,"comment_ctime":1583891314,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"143317812082","product_id":100039001,"comment_content":"一路学来，看着下面的评论越来越少，终于跟上进度，继续加油。小争哥的栏目做的真的很好，干货满满，与看书感觉完全不同，关键是对读者的思想启发深远。","like_count":34,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502968,"discussion_content":"不是，orm实体类不应该有业务逻辑的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597454612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1707561,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/0e/29/6c8034e3.jpg","nickname":"double mu","note":"","ucode":"62F82999EDDA56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297277,"discussion_content":"orm的实体类，需要转换成自己的业务模型所使用的数据结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596853836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186615,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1583891532,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"104663106636","product_id":100039001,"comment_content":"我负责的软件是一个网关软件，主要是协议转换并且与外部不同厂商的系统进行数据交换。<br>我目前采用分进程的方式，各个接口进程启动的时候会连接主进程，并在主进程进行注册。<br>主进程在有内容更新的时候会采用观察者模式群发给需要的接口进程。由接口进程去完成协议转换并发给外部厂商。","like_count":25,"discussions":[{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384837,"discussion_content":"进程通信","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626766622,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186612,"user_name":"gogo","can_delete":false,"product_type":"c1","uid":1003104,"ip_address":"","ucode":"E8F0F3B000020A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","comment_is_top":false,"comment_ctime":1583891313,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"53123498865","product_id":100039001,"comment_content":"个人认为，广义上，&quot;生产者-消费者&quot;模型属于观察者模式","like_count":12,"discussions":[{"author":{"id":2358638,"avatar":"https://static001.geekbang.org/account/avatar/00/23/fd/6e/1913dbb6.jpg","nickname":"Amber","note":"","ucode":"650FE5C46CCD1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336339,"discussion_content":"说反了吧？我觉得观察者模式 属于 Producer-Consumer模型；按照GOF的定义。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608554998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231744,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1593762951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44543435911","product_id":100039001,"comment_content":"生成-消费者模型：意图是保证生产消费，按节奏进行，可以通过阻塞队列和限流器控制节奏的快慢，更加关注的是生产和消费的数据；<br>观察者模式：更加倾向的是通知的行为，意图就是通知为主。","like_count":11},{"had_liked":false,"id":188463,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1584357524,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"44534030484","product_id":100039001,"comment_content":"问题：<br>创建型模式4种，结构型7种，行为型11种，共22种，23种从哪来的？","like_count":10,"discussions":[{"author":{"id":1948635,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/bb/db/f8c74599.jpg","nickname":"学了忘","note":"","ucode":"00789BBC1E51E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384720,"discussion_content":"把这22种模式合起来就是第23种花模式 😄","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1626711002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136352,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/e0/91e485b9.jpg","nickname":"弋言","note":"","ucode":"507418B211EC07","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291724,"discussion_content":"听课不认真，出去罚站。哈哈哈","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594918062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1576240,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlibCGekRp9bxJ3dGfOWghhNVdF771ejzwqKnicKFBpmGuutwNGF3HGZz7KEEz2mdvPckibReRsVtDw/132","nickname":"Geek_e6159b","note":"","ucode":"0684569F9B114D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274996,"discussion_content":"工厂方法、抽象工厂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1590642735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1132304,"avatar":"https://static001.geekbang.org/account/avatar/00/11/47/10/2d673601.jpg","nickname":"好饿早知道送外卖了","note":"","ucode":"AED22DB5BF8FC7","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232079,"discussion_content":"打开评论，然后默默关闭。哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586851039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1213078,"avatar":"https://static001.geekbang.org/account/avatar/00/12/82/96/aa795685.jpg","nickname":"mghio","note":"","ucode":"74883EDE4FD0DC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213449,"discussion_content":"工厂模式包含了简单和抽象工厂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585095095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033240,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkwbyTYtSCx6Qc7cQPnnRWv38Jybh3etziaPmuP8gHcgS6FMxcdftrKgWiamH6fc2iciaicDKDVEwcEibQ/132","nickname":"sami","note":"","ucode":"9A66FCA00D8A37","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206176,"discussion_content":"工厂模式细分为两种","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584370416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1702886,"avatar":"https://static001.geekbang.org/account/avatar/00/19/fb/e6/1b9edb91.jpg","nickname":"练习生","note":"","ucode":"60203A2AA0EA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1033240,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkwbyTYtSCx6Qc7cQPnnRWv38Jybh3etziaPmuP8gHcgS6FMxcdftrKgWiamH6fc2iciaicDKDVEwcEibQ/132","nickname":"sami","note":"","ucode":"9A66FCA00D8A37","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":359569,"discussion_content":"我也纠结这个，其实工厂模式可以拆成工厂模式和抽象工厂模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616230505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206176,"ip_address":""},"score":359569,"extra":""},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1033240,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkwbyTYtSCx6Qc7cQPnnRWv38Jybh3etziaPmuP8gHcgS6FMxcdftrKgWiamH6fc2iciaicDKDVEwcEibQ/132","nickname":"sami","note":"","ucode":"9A66FCA00D8A37","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":384838,"discussion_content":"不是三种吗  简单工厂模式 工厂方法模式 抽象工厂模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626766678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206176,"ip_address":""},"score":384838,"extra":""},{"author":{"id":2853072,"avatar":"","nickname":"小杰同学","note":"","ucode":"C6FC59D58F772C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579351,"discussion_content":"简单工厂模式就是工厂模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657368573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384838,"ip_address":""},"score":579351,"extra":""}]},{"author":{"id":1135900,"avatar":"https://static001.geekbang.org/account/avatar/00/11/55/1c/c76abe73.jpg","nickname":"大叶子","note":"","ucode":"31CCDE9E88C023","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":274128,"discussion_content":"哈哈 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590544210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206107,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1586787745,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"40241493409","product_id":100039001,"comment_content":"目前Java响应式编程中的RxJava和Vert.X都是基于观察者模式实现的，且都是异步方式。","like_count":9,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502943,"discussion_content":"可以先用一个，必要的时候再分开多个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597454272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190644,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584675880,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31649446952","product_id":100039001,"comment_content":"今天学了观察者模式过后<br>我觉得平时工作当中还是用了很多的设计模式,只是我们自己不知道而已","like_count":7,"discussions":[{"author":{"id":2282974,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d5/de/f9a465ab.jpg","nickname":"成长型思维","note":"","ucode":"2FCE2C05FFCC83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327454,"discussion_content":"设计模式学完之后全部忘记 只要根据业务问题来 使用原则 解耦代码就行","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605841985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1252813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","nickname":"徐同学呀","note":"","ucode":"03383EE820514D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2282974,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d5/de/f9a465ab.jpg","nickname":"成长型思维","note":"","ucode":"2FCE2C05FFCC83","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374838,"discussion_content":"说得好，无招胜有招，设计模式的作用本身就是解构，将变化的解耦出来，达到开闭原则的效果。实际工作中也是很多原则概念和设计模式混合一起使用。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621386384,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327454,"ip_address":""},"score":374838,"extra":""}]}]},{"had_liked":false,"id":188715,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1584407389,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23059243869","product_id":100039001,"comment_content":"消息队列就是用了观察者模式","like_count":5},{"had_liked":false,"id":189357,"user_name":"www","can_delete":false,"product_type":"c1","uid":1275203,"ip_address":"","ucode":"951B364F2CB211","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/43/c6058200.jpg","comment_is_top":false,"comment_ctime":1584504875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18764374059","product_id":100039001,"comment_content":"Youtube订阅发布机制也是很好的例子：普通用户订阅youtuber的频道，一旦youtuber发布新视频，普通用户收到频道更新的通知","like_count":4},{"had_liked":false,"id":190163,"user_name":"Remember九离","can_delete":false,"product_type":"c1","uid":1237327,"ip_address":"","ucode":"97EE6E6344689F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","comment_is_top":false,"comment_ctime":1584608662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14469510550","product_id":100039001,"comment_content":"PHP 实现的简易版本:https:&#47;&#47;github.com&#47;wuqinqiang&#47;php-design-patterns&#47;tree&#47;master&#47;src&#47;object&#47;patterns&#47;Observer","like_count":3},{"had_liked":false,"id":186589,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1583888951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14468790839","product_id":100039001,"comment_content":"打卡 今日学习观察者模式，收获如下：观察者模式在开发中比较常见，小到代码层面的解耦，大到架构层面的系统结构设计，或者是一些产品的设计思路。之前在学习ActiveMQ的发布订阅模型的时候，就对观察者模式有过了解，但是只知道它使用到了观察者模式这种设计思路。通过今天的学习进一步理解了为什么需要总结出这么多的设计模式，回归到本质上还是为了写出“高质量”的代码，即满足单一职责，开闭原则、高内聚松耦合等特性，依次来控制和应对代码的复杂性，提高代码的可扩展性，可读性等。事件是不是也可以理解为观察者模式的一种实现？在JavaBeans的的架构中，事件是其核心特征之一, 在实际开发中事件也比较常见，比如AWT ，Netty编程中的IO事件，Spring和SpringBoot中的事件等。","like_count":3},{"had_liked":false,"id":186576,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1583887340,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"14468789228","product_id":100039001,"comment_content":"生产者消费者模型和观察者模型的相同之处是一方数据状态变化，另一方获取通知并做相关工作，不同之处是生产者消费者模型是个异步模型，生产者不知道有多少消费者消费消息，而观察者模型是个同步模型，而且被观察者知道有有多少观察者观察它的状态变化。应用场景除了文中提到的，还有微博用户关注等。","like_count":3},{"had_liked":false,"id":282522,"user_name":"snake","can_delete":false,"product_type":"c1","uid":2347137,"ip_address":"","ucode":"47BFFE4D048156","user_header":"https://static001.geekbang.org/account/avatar/00/23/d0/81/d5c8e46e.jpg","comment_is_top":false,"comment_ctime":1615291154,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10205225746","product_id":100039001,"comment_content":"没太看懂setRegObservers 方法在哪里使用的，怎么把上面两个observier添加进来的","like_count":2,"discussions":[{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394754,"discussion_content":"在生产代码中, 使用Spring配置文件把observer注入进来; 如果不使用Spring, 那么就只能手动new Observer(), 然后调用被观察者的setRegObservers()方法把观察者添加进来.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632036835,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238748,"user_name":"Chris","can_delete":false,"product_type":"c1","uid":1689346,"ip_address":"","ucode":"50A51AE2110A7A","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/02/8346ebf6.jpg","comment_is_top":false,"comment_ctime":1596280573,"is_pvip":false,"replies":[{"id":"89273","content":"可以算是应用","user_name":"作者回复","comment_id":238748,"uid":"1190123","ip_address":"","utype":1,"ctime":1597454375,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"10186215165","product_id":100039001,"comment_content":"生产-消费模型 是不是可以算是 观察者模式的一种异步非阻塞的实现呢","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502842,"discussion_content":"可以算是应用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597454375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189728,"user_name":"小七","can_delete":false,"product_type":"c1","uid":1154980,"ip_address":"","ucode":"5C314CC4123CB3","user_header":"https://static001.geekbang.org/account/avatar/00/11/9f/a4/a68e8403.jpg","comment_is_top":false,"comment_ctime":1584543206,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"10174477798","product_id":100039001,"comment_content":"看了适配器模式，观察者模式感觉代码结构的组织上区别不大啊，有种换汤不换药的感觉，如何区分到底是啥模式，总不能说你给方法赋予了一个接收和响应的语义他就是观察者模式了，换个语义就成了另一种设计模式了吧，请老师赐教","like_count":2,"discussions":[{"author":{"id":1734795,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/78/8b/421cb2c4.jpg","nickname":"成活","note":"","ucode":"F8840EE4DC3969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":248623,"discussion_content":"前几章里有说，目的和意图也是区分两种模式的标准，要解决的问题不一样，使用场景不一样。而且适配器模式和观察者模式差别还是挺大的吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587882001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019588,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","nickname":"Richie","note":"","ucode":"12314EF0347693","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211439,"discussion_content":"意图明显不同，一个是结构型模式，一个是行为型模式，差远了啊","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1584850796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1358045,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","nickname":"小马哥","note":"","ucode":"B2C0FF38F8C9BC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394758,"discussion_content":"其实设计模式学到最后, 好多模式是类似的, 这个类似基本都使用了多态语法; 不同的的确是语义和场景不同; 不仅你觉得适配器和观察者, 你去看看责任链的语法是否也有点类似, 然后再看看装饰器还有代理模式, 和这个也类似. 但是责任链的不同在于链条上有的责任类可以不放行, 装饰器装饰的作用和被装饰类功能相似,进行了增强而已, 代理的作用是切入另一个不同的功能...\n所以, 不同的模式在于语义与场景的不同.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632037103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2122539,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","nickname":"阿骨打","note":"","ucode":"35EADA5550162A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308362,"discussion_content":"适配器：优化接口、整合多个第三方类，提供一个接口、向下兼容等等，\n观察者：1个通知，N个实现，完全不同好嘛\n你要说真相同，观察者和桥接模式有点类似，只不过行为目的不同，桥接是做什么？-->怎么做，抽象和实现分开开发。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600929958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138645,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5f/d5/2fec2911.jpg","nickname":"yu","note":"","ucode":"56856DCC0C8387","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219793,"discussion_content":"观察者是一对多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585809348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189219,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1584489719,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10174424311","product_id":100039001,"comment_content":"我们现在源数据后台系统在治理平台发布批量接口，导出数据，目标系统在治理平台订阅批量接口，数据导出后就会推送到目标系统，只不过中间的推送动作是ADE中间系统处理的，源系统只负责推送到ADE目标目录，ade触发推送数据住订阅系统.<br>还有我们系统用的发布服务订阅服务也是类似观察者模式，只不过是双向服务，主题发布订阅是单向服务而已","like_count":2},{"had_liked":false,"id":187070,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1584005156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10173939748","product_id":100039001,"comment_content":"对于第一个问题,两者之间没有太大的联系,只能说,在异步实现观察者模式的时候,可以选择使用生产者消费者模式,当然也可以不选择这种模式,直接使用线程也行,而且生产者消费者之间可以做到多对多,解耦更加具体,更加适合于对于系统压力的降低<br>对于第二个问题,在某个云平台开发一个创建云服务器的逻辑,要求是可以在一个请求中创建多个云服务器,大概的实现是这样的,前端在发送一个请求给后端服务器,并创建一个websocket连接,客户可以无需等待了,后端会根据创建的数量开启countDownLatch,然后异步的发送创建请求,等创建完成后,会将计数器减一,直到计数器归零,就会通过websocket将哪些创建成功的消息推给网页,然后提示客户","like_count":2},{"had_liked":false,"id":276374,"user_name":"零零玲","can_delete":false,"product_type":"c1","uid":2326769,"ip_address":"","ucode":"F993CC91AF3FE1","user_header":"","comment_is_top":false,"comment_ctime":1611904328,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5906871624","product_id":100039001,"comment_content":"仅从语法上看，观察者模式的经典实现方式很像职责链模式啊","like_count":1,"discussions":[{"author":{"id":1252813,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1d/cd/3819726f.jpg","nickname":"徐同学呀","note":"","ucode":"03383EE820514D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374840,"discussion_content":"使用设计模式的目的就是解构，而这些模式也都是前辈总结出来的。实际工作中会有多种模式混合使用的情况，或者也会和定义偏离，但是只要达到解构，开闭等原则即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621386573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270942,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1609324180,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5904291476","product_id":100039001,"comment_content":"生产者-消费者模型更具一般性，观察者模式是生产者-消费者的一种特定实现。有些同学说采用队列也是观察者模式不能说不对，不过我还是倾向于将没有队列的情况下，在原始服务类（即Obserable）中组合能实施触发行为对象（即Observer）的这种原教旨形式称为观察者模式。","like_count":1},{"had_liked":false,"id":262856,"user_name":"Laughing","can_delete":false,"product_type":"c1","uid":1002134,"ip_address":"","ucode":"F68F1E000CA800","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/96/99466a06.jpg","comment_is_top":false,"comment_ctime":1605860656,"is_pvip":false,"replies":[{"id":"96118","content":"������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700911,"ip_address":"","comment_id":262856,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5900827952","product_id":100039001,"comment_content":"1. 生产消费应该是多对多的关系。<br>2. 消息通知、推送，应该都是基于这种设计模式应用而来的。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510002,"discussion_content":"������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229311,"user_name":"懒散","can_delete":false,"product_type":"c1","uid":1193385,"ip_address":"","ucode":"6FC704ABE5A9E1","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/a9/e2a0ad48.jpg","comment_is_top":false,"comment_ctime":1592963429,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5887930725","product_id":100039001,"comment_content":"功能代码和行为代码是什么区别呢？","like_count":1,"discussions":[{"author":{"id":1455958,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","nickname":"倡印","note":"","ucode":"4F53AA5D017D89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362935,"discussion_content":"我也好奇俩者的区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617076210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206576,"user_name":"ttxser","can_delete":false,"product_type":"c1","uid":1022694,"ip_address":"","ucode":"47C3FCB59F8027","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/e6/e8439f9a.jpg","comment_is_top":false,"comment_ctime":1586887398,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5881854694","product_id":100039001,"comment_content":"没有什么区别","like_count":1},{"had_liked":false,"id":196274,"user_name":"阿卡牛","can_delete":false,"product_type":"c1","uid":1022247,"ip_address":"","ucode":"0BC43A904C3199","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/27/47aa9dea.jpg","comment_is_top":false,"comment_ctime":1585268892,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880236188","product_id":100039001,"comment_content":"生产者-消费者本质上也是观察者模式，通过引入队列，是一种非阻塞异步的实现方式","like_count":1},{"had_liked":false,"id":188963,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1584439836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879407132","product_id":100039001,"comment_content":"打卡打卡,滴,学生卡","like_count":1},{"had_liked":false,"id":186795,"user_name":"Jimbol","can_delete":false,"product_type":"c1","uid":1178008,"ip_address":"","ucode":"8D9190B3B3E08B","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/98/95b13446.jpg","comment_is_top":false,"comment_ctime":1583928023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878895319","product_id":100039001,"comment_content":"生产者消费者一条消息只能被一个消费者消费，实现上需要依赖队列，生产者消费者各自有独立的工作线程<br>观察者模式可以一个事件被多个观察者处理，观察者之间相互独立。实现本质上是接口回调。","like_count":1},{"had_liked":false,"id":186611,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1583891295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878858591","product_id":100039001,"comment_content":"个人认为观察者模式的应用范围更广吧，两者的目的都是解耦，生产-消费模型主要用于系统间解耦。而观察者模式既可以用于线程内代码解耦（同步阻塞），也可以用于线程间解耦（异步非阻塞），还可以用于进程间解耦（RPC或生产-消费模型）","like_count":1},{"had_liked":false,"id":351385,"user_name":"邓嘉文","can_delete":false,"product_type":"c1","uid":2332845,"ip_address":"","ucode":"FCEDFABFB48055","user_header":"https://static001.geekbang.org/account/avatar/00/23/98/ad/f9d755f2.jpg","comment_is_top":false,"comment_ctime":1657764745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657764745","product_id":100039001,"comment_content":"所有的生产者消费者模型都是观察模式<br>","like_count":0},{"had_liked":false,"id":350604,"user_name":"小马哥","can_delete":false,"product_type":"c1","uid":1358045,"ip_address":"","ucode":"B2C0FF38F8C9BC","user_header":"https://static001.geekbang.org/account/avatar/00/14/b8/dd/37726c34.jpg","comment_is_top":false,"comment_ctime":1657033934,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657033934","product_id":100039001,"comment_content":"回答问题1: 请对比一下“生产者 - 消费者”模型和观察者模式的区别和联系。<br>首先说区别: <br>1, 生产者-消费者模型是一种代码模型, 观察者是一种设计模式;模型可以使用模式来实现;<br>2, 生产者-消费者模型天然解耦的, 解耦的手段是使用了队列, 或者是阻塞队列; 观察者模式的角色可以解耦, 也可以不解耦;<br><br>两者之间的联系: <br>都可以实现发布订阅功能.","like_count":0},{"had_liked":false,"id":347453,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1724215,"ip_address":"","ucode":"FA8E8FD88886AF","user_header":"https://static001.geekbang.org/account/avatar/00/1a/4f/37/ad1ca21d.jpg","comment_is_top":false,"comment_ctime":1654052283,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654052283","product_id":100039001,"comment_content":"其他应用场景：<br>妈妈做熟饭叫全家人吃饭属于观察者模式，<br>妈妈做熟饭这个事儿是被观察者<br>全家每一个人是观察者<br>观察者都有自己的行为，比如儿子听到叫吃饭要先去洗手，再到饭桌前。爸爸听到叫吃饭要先准备餐具。爷爷听到叫吃饭要先拿出自己的酒到餐桌前。","like_count":0},{"had_liked":false,"id":319136,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1635608340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635608340","product_id":100039001,"comment_content":"生产消费是有一方生成，多方消费，而且多方都是必须处理的。观察者模式是，观察了有变动，但也可以不执行任何逻辑。","like_count":0},{"had_liked":false,"id":318581,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1635339390,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635339390","product_id":100039001,"comment_content":"观察者模式可以应用在，发送异步发送用户短信，订单完成发放优惠券等等。","like_count":0},{"had_liked":false,"id":316124,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1634171606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634171606","product_id":100039001,"comment_content":"思考：<br>1.区别是，观察者模式中被被观察着的状态变化，会被每一个观察者进行处理。而生产消费中，生产者生产的消息，只会被一个消费者消费。<br>2.场景：场景1-电商中购买商品后，会写日志，加积分等等操作，这时购买行为是被观察者，其他行为是观察者。<br>  场景2：前端框架React中，数据变化，组件自动重新渲染，也是一种观察者模式。<br>场景3：Android开发中的RxJava 响应式编程，数据和UI组件的联动变化，也是观察者模式","like_count":0},{"had_liked":false,"id":308782,"user_name":"eggsy","can_delete":false,"product_type":"c1","uid":1141155,"ip_address":"","ucode":"90459029E5B2BC","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/a3/025fef27.jpg","comment_is_top":false,"comment_ctime":1629795989,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629795989","product_id":100039001,"comment_content":"生产者消费者模型 vs 观察者被观察者模型<br>1. 生产者消费者模型可以做到更解耦，生产者和消费者可以不用显示的引用对方，知道对方的存在。被观察者需要直接或者间接的持有观察者，被观察者行为变化时需要手动通知观察者。<br>2. 生产者消费者模型可以做到多对多，观察者被观察者模型一般是多对一。<br>3. 生产者消费者模型在生产者与消费者之间是异步，观察者被观察者可以使用同步或者异步方式执行。","like_count":0},{"had_liked":false,"id":302252,"user_name":"Kenneth。🌞","can_delete":false,"product_type":"c1","uid":1786752,"ip_address":"","ucode":"299ADF236395CC","user_header":"https://static001.geekbang.org/account/avatar/00/1b/43/80/b1ae32cd.jpg","comment_is_top":false,"comment_ctime":1626146353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626146353","product_id":100039001,"comment_content":"处理上：生产-消费是异步，观察者是同步<br>生产-消费者模式 会维护一个队列，生产者向队列发送消息，消费者从队列获取消息消费。<br>还需要关心如果队列满了，生产者阻塞等待，队列为空，消费者等待，线程级别，生产者和消费者需要线程通信，可以是juc 的lock + condition 或者jvm 提供的notify 和 wait <br>如果需要更丰富的特性，比如 点对点，组播，一对多可以细化具体的状态，然后消费者只消费感兴趣状态<br><br>观察者模式 首先会注册监听对象，当被观察者状态发生改变，会通知所有观察者（默认是同步，可以通过线程异步）<br><br>关于上文subject 就是被观察者， obeserver 就是观察者， message 就是状态，状态改变，被观察者通过迭代方式依次通知observer","like_count":0},{"had_liked":false,"id":290612,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1619659399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619659399","product_id":100039001,"comment_content":"生产者消费者模型是一个多对多的关联关系，而观察者模型是一个一对多的关联关系，二者都是为了将行为代码解耦，可以实现进程内也都可以实现跨进程，跨进程可以引用MQ，也可以采取回调方式均可","like_count":0},{"had_liked":false,"id":290163,"user_name":"成业梁","can_delete":false,"product_type":"c1","uid":1149564,"ip_address":"","ucode":"530EB2C9718699","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/7c/949163dd.jpg","comment_is_top":false,"comment_ctime":1619410881,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619410881","product_id":100039001,"comment_content":"基于线程的异步观察者模式，如果涉及到数据库操作，是否需要解决多线程事务隔离问题（spring 场景下），即一个观察者事务回滚，如何触发主线程事物回滚和其他观察者事物回滚。基于进程的观察者模式涉及上述问题，我理解就是分布式事务的范畴了。","like_count":0},{"had_liked":false,"id":288395,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1618454052,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618454052","product_id":100039001,"comment_content":"“生产者 - 消费者”模型：<br>生产者，异步通知，对消费者无感知<br>下游消费者，有竞争关系<br>观察者模式：<br>被观察者，同步或异步，对消费者有感知<br>观察者，无竞争关系","like_count":0},{"had_liked":false,"id":281732,"user_name":"御风","can_delete":false,"product_type":"c1","uid":1812807,"ip_address":"","ucode":"51C8212BE06364","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/47/ded5da90.jpg","comment_is_top":false,"comment_ctime":1614862630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614862630","product_id":100039001,"comment_content":"【收获】<br>1.创建型解决&quot;对象创建&quot;问题，结构型解决类和对象的组合或组装问题，行为型解决类和对象的交互问题。<br>2.同步阻塞，进程内异步非阻塞，进程间异步非阻塞。<br>同步阻塞，在一个线程内，A事件先做，B事件后做，两件事件就是同步阻塞的。<br>异步非阻塞，异步，首先肯定不是同一线程。<br>B事件不用等A事件做完，两个各开一个线程，这就是进程内的异步非阻塞。<br>如果不同进程，就是进程间的异步非阻塞。<br>3.多态与抽象<br>代码设计时，先明确要设计目标(要做什么)，然后再划分职责(怎么做)，接着就能确定创建什么对象，然后将对象和方法抽象一下，抽象出接口和接口方法，方便将来拓展，这就是多态，最后流程组装一下。<br>文中的注册流程中，发体验金和发短信的设计不就是这样么？","like_count":0},{"had_liked":false,"id":277328,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1612360052,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612360052","product_id":100039001,"comment_content":"问个题外的：<br>       同步 为啥 叫 同步， 按道理 同步 同时运行，它的效果应该是并行非阻塞的。 <br>       为啥 要叫同步呢， 我知道同步的的机制， 就是感觉 这个名词和他的机制 不符啊，","like_count":0},{"had_liked":false,"id":274507,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1611041725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611041725","product_id":100039001,"comment_content":"可以参考 spring Application 事件机制，运用观察者模式","like_count":0},{"had_liked":false,"id":271400,"user_name":"程序员老王","can_delete":false,"product_type":"c1","uid":1025340,"ip_address":"","ucode":"28577A15F064CF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a5/3c/7c0d2e57.jpg","comment_is_top":false,"comment_ctime":1609596568,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609596568","product_id":100039001,"comment_content":"它是将观察者和被观察者代码解耦。他们之间不相互依赖吧","like_count":0},{"had_liked":false,"id":269857,"user_name":"赵达铭","can_delete":false,"product_type":"c1","uid":1438212,"ip_address":"","ucode":"8ED742EA118285","user_header":"https://static001.geekbang.org/account/avatar/00/15/f2/04/993ec92d.jpg","comment_is_top":false,"comment_ctime":1608813798,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608813798","product_id":100039001,"comment_content":"消费模型相比于观察者模型.有一个队列的概念.相比于发布订阅.更加的解耦.<br>观察者模型中,主题需要保存一个观察者列表,当事件发生时.轮训并调用每个观察者.<br>生产者消费者模型中.生产者和消费者都不知道对方的存在.只和队列交互","like_count":0},{"had_liked":false,"id":268454,"user_name":"大鹏","can_delete":false,"product_type":"c1","uid":1004481,"ip_address":"","ucode":"F56D9D1DE892D8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/c1/34bb9b24.jpg","comment_is_top":false,"comment_ctime":1608204219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608204219","product_id":100039001,"comment_content":"生产者-消费者是完全不同的进程，之间相互隔离的，互不影响，互不感知；<br>观察者模式是一对多(包括一对一) 被观察者会与观察者进行互动，当被观察者有变动时，会引起观察者的改变；","like_count":0},{"had_liked":false,"id":267506,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1607778210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607778210","product_id":100039001,"comment_content":"打卡：用Java实现了文中观察者模式的Demo。","like_count":0},{"had_liked":false,"id":265215,"user_name":"hex","can_delete":false,"product_type":"c1","uid":1757301,"ip_address":"","ucode":"B983D40DCD159F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d0/75/3e034f71.jpg","comment_is_top":false,"comment_ctime":1606814755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606814755","product_id":100039001,"comment_content":"说一个注册中心的例子,注册中心中注册有服务提供者和服务调用者,假设都是多节点部署,服务调用者和多个服务提供者的关系类似消费和生产者的关系,调用者调用接口只会调用某一台提供者去消费.但是注册中心和服务之间的心跳轮询机制类似于发布和订阅的关系,只要注册上的都会去发心跳!","like_count":0},{"had_liked":false,"id":265027,"user_name":"exception","can_delete":false,"product_type":"c1","uid":1180979,"ip_address":"","ucode":"F35ACB5B921353","user_header":"https://static001.geekbang.org/account/avatar/00/12/05/33/c33c0e8a.jpg","comment_is_top":false,"comment_ctime":1606739009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606739009","product_id":100039001,"comment_content":"观察者和生产-消费者，只能符合场景，完全都可以是多对多。<br>观察者模式就是一种解耦思想，实现的方式很多，而生产-消费者可以理解为观察者的一种实现方式。","like_count":0},{"had_liked":false,"id":261437,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1605336297,"is_pvip":false,"replies":[{"id":"96145","content":"哈哈，加油","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606701447,"ip_address":"","comment_id":261437,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605336297","product_id":100039001,"comment_content":"这个实际开发 真的超级超级常用！ 希望大家都能吃透了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509486,"discussion_content":"哈哈，加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606701447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254556,"user_name":"曙光","can_delete":false,"product_type":"c1","uid":1476450,"ip_address":"","ucode":"04D65BF7F19845","user_header":"https://static001.geekbang.org/account/avatar/00/16/87/62/f99b5b05.jpg","comment_is_top":false,"comment_ctime":1603130430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603130430","product_id":100039001,"comment_content":"“生产者 - 消费者”模型和观察者模式的区别和联系：区别在于实时性，观察者模式，在被观察者执行update时会及时通知观察者，并且是单向触发。但生产者-消费者模式，有延迟，队列可以为空或满，多个消费者可以竞争消费，消费所有信息。生产者也可以多个，如果队列为空时，竞争生产，可能一个生产者让整个队列占满。所以生产者-消费者模型时双向触发的。<br>联系：两个都是通过队列，将AB角色关联起来(被观察者保存所有观察者引用，生产-消费用队列缓存消息)。<br>2  对象A发生变化，对象B需做出反应的场景。例如鼠标事件监听，当点击鼠标时，页面做出相应的反应。公众号的信息推送。定时任务。事件循环+GPS定位+观察者模式，实现固定区域打卡并发送邮件功能","like_count":0},{"had_liked":false,"id":253470,"user_name":"阿骨打","can_delete":false,"product_type":"c1","uid":2122539,"ip_address":"","ucode":"35EADA5550162A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/BOEEDquKAT3WLFjFlwcyVvKvoW7hgXHtbtBC4YzOtQoAat7eAtnBDjjWsEY5g4JJEj7jvPuboT8LoSGCrAbcgA/132","comment_is_top":false,"comment_ctime":1602747518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602747518","product_id":100039001,"comment_content":"我返回来看，总感觉观察者模式，应该放在 结构型当中。。。。<br>观察者模式是一个非常简单 概念又宽泛的概念，感觉只要是个人 就能想到用观察者。。。<br>A输出结果， BCD调用，只是天经地义的逻辑","like_count":0},{"had_liked":false,"id":251050,"user_name":"查理","can_delete":false,"product_type":"c1","uid":1111297,"ip_address":"","ucode":"A9FEA901E3A05D","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/01/5389295c.jpg","comment_is_top":false,"comment_ctime":1601345476,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1601345476","product_id":100039001,"comment_content":"不是非常理解结构型，行为型的区别。不同功能的代码和不同行为的代码，好像不是互斥的，功能和行为不都可以理解为函数，方法吗？","like_count":0},{"had_liked":false,"id":250916,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1601280493,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1601280493","product_id":100039001,"comment_content":"同步实现场景下的观察者模式和生产者-消费者模式差异最大在后者基本就是一种异步模式；而对于异步的观察者模式，我感觉两者差异就不是那么大了，只是前者是在对象交互的维度上实现多对象之间的协作，后者是从执行过程中的角度来看，但是程序运行过程中，对象也是需要执行对象来承载的，所以这两个总的来说不觉得有多大的差异","like_count":0},{"had_liked":false,"id":250373,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1601040954,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601040954","product_id":100039001,"comment_content":"这种模式unity开发里用的蛮多的 event解决各种gameobject直接的信息更新。有用到event manager基本可以解耦所有类 避免交叉引用 项目干净不少","like_count":0},{"had_liked":false,"id":248027,"user_name":"CptW","can_delete":false,"product_type":"c1","uid":2108743,"ip_address":"","ucode":"A3174302EBD4B2","user_header":"https://static001.geekbang.org/account/avatar/00/20/2d/47/6a5ab601.jpg","comment_is_top":false,"comment_ctime":1599985766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599985766","product_id":100039001,"comment_content":"Vue.js的响应式原理，本质上也是观察者模式","like_count":0},{"had_liked":false,"id":238973,"user_name":"SeamanW","can_delete":false,"product_type":"c1","uid":1683192,"ip_address":"","ucode":"477CE695121A04","user_header":"https://static001.geekbang.org/account/avatar/00/19/ae/f8/2860ac98.jpg","comment_is_top":false,"comment_ctime":1596386958,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596386958","product_id":100039001,"comment_content":"应用场景：<br>1. 公司、单位的公告栏：一个公告栏发布消息；公司所有员工去获取消息，执行动作。<br>2. 微信群聊：群主发布一个消息，并@所有人；所有人收到提醒，查看消息。","like_count":0},{"had_liked":false,"id":234472,"user_name":"。。。。","can_delete":false,"product_type":"c1","uid":1107784,"ip_address":"","ucode":"0163FD085D4293","user_header":"https://static001.geekbang.org/account/avatar/00/10/e7/48/df149c8d.jpg","comment_is_top":false,"comment_ctime":1594697913,"is_pvip":false,"replies":[{"id":"86613","content":"没怎么看懂你的意思，你是说怎么注册观察者吗？调用setRegObservers函数来完成的。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594781890,"ip_address":"","comment_id":234472,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1594697913","product_id":100039001,"comment_content":"当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，UserController 类的 register() 函数完全不需要修改，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。这一段是怎么注册进来的，不是很明白","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482238,"discussion_content":"1. 可以不用bo了，不过看情况，如果你的service有组合多个domain的业务逻辑，可能还是需要bo\n2. 直接返回domain也可以，毕竟到了controller层就会转化成vo","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580112486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1230837,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c7/f5/4e9a82e9.jpg","nickname":"燃着的半支烟","note":"","ucode":"23C7B588F400A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154080,"discussion_content":"好的，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580114342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234266,"user_name":"Giacomo","can_delete":false,"product_type":"c1","uid":1478055,"ip_address":"","ucode":"BE5B1E68BCDBB3","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","comment_is_top":false,"comment_ctime":1594631701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594631701","product_id":100039001,"comment_content":"之前自己写过一个元胞自动机对程序，我觉得我就是用了这个模式完成Cell之间的通讯的了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480613,"discussion_content":"后台补漏更好点。因为回滚也不一定能成功，也有可能会失败。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578489306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232824,"user_name":"maybe","can_delete":false,"product_type":"c1","uid":1475528,"ip_address":"","ucode":"93D160F617E750","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/c8/5ce842f6.jpg","comment_is_top":false,"comment_ctime":1594124691,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1594124691","product_id":100039001,"comment_content":"生产者消费者模型多对多，可以多个生产者和多个消费者，意图更侧重性能提升。观察者模式更侧重行为解耦。两者都实现行为上解耦，其实生产者消费者模式也是一种观察者模式<br>","like_count":0},{"had_liked":false,"id":232244,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1593933893,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593933893","product_id":100039001,"comment_content":"设计模式一个是为了解耦，一个是为了方便扩展<br>创建型是为了使用者可以不关心创建对象的复杂逻辑，是一个解耦的过程。而对于扩展则是工厂方法中有体现扩展。即对于一个业务，对象可以按类别进行分类进行工厂模式创建。比如车子，分为电车，汽油车。<br>结构型也是功能代码解耦以及扩展问题。如代理模式是在原有功能上做了一个增强，将调用者不用耦合这个增强的功能逻辑，典型的应用是缓存，事务aop代理。扩展问题的结构型设计模式有：装饰者，桥接模式。适配器模式有个作用是防腐层，用于proxy层对于外部系统的调用可以做一个防腐层。<br>这节的行为模式，观察者模式，就是解决要发生的事件，和对应这个事件的处理逻辑的解耦。被观察者提的是这个事件，观察者就是这个事件的处理者。而发送者，订阅者是一种观察者的实现形式。","like_count":0},{"had_liked":false,"id":231473,"user_name":"kyl","can_delete":false,"product_type":"c1","uid":1406090,"ip_address":"","ucode":"DBDFD0FEB5A135","user_header":"https://static001.geekbang.org/account/avatar/00/15/74/8a/d5b0cf30.jpg","comment_is_top":false,"comment_ctime":1593682476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593682476","product_id":100039001,"comment_content":"以前一直对观察者模式很模糊，看了这篇文章收获不少，可以自己写出来了。","like_count":0},{"had_liked":false,"id":230314,"user_name":"数学汤家凤","can_delete":false,"product_type":"c1","uid":2029485,"ip_address":"","ucode":"DE84E777C384AD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","comment_is_top":false,"comment_ctime":1593346041,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1593346041","product_id":100039001,"comment_content":"ActiveMQ 中 Queue 生产-消费，Topic 发布-订阅","like_count":0,"discussions":[{"author":{"id":1079816,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/08/4d3e47dd.jpg","nickname":"Aaron Cheung","note":"","ucode":"03972759C53667","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306278,"discussion_content":"汤老师好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600238854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":227352,"user_name":"HF","can_delete":false,"product_type":"c1","uid":1060150,"ip_address":"","ucode":"EA504931C0B932","user_header":"https://static001.geekbang.org/account/avatar/00/10/2d/36/d3c8d272.jpg","comment_is_top":false,"comment_ctime":1592361689,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592361689","product_id":100039001,"comment_content":"生产消费模型依赖关系弱<br>观察者模型依赖关系强<br>两者实现方式可以同步也可以异步，都没法依赖倒置控制反转","like_count":0},{"had_liked":false,"id":227033,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1592270319,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592270319","product_id":100039001,"comment_content":"其他应用场景：<br>表删除实体listener，学校表，班级表，学生表。删除学校时，需要将班级表相关字段删除，删除班级表时需要将学生表相关字段删除。<br>首先处理是，service对内屏蔽批量删除接口，批量删除内部多次调用删除单记录方式实现。删除时，向订阅者广播删除消息，订阅者根据删除消息作处理。例如，删除学校时，广播给班级，班级做删除操作。班级删除时，广播给学生表，删除学生或者将学生的关系指向另一个临时学校等等。","like_count":0},{"had_liked":false,"id":226458,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1592109567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592109567","product_id":100039001,"comment_content":"“生产者 - 消费者”模型和观察者模式，本质联系都是产生对象让其他对象去处理；本质区别是“生产者 - 消费者”产生的对象只能被用一次（消费掉了），而观察者模式产生的对象，不会被消耗，所有的监听对象都能得到","like_count":0},{"had_liked":false,"id":225615,"user_name":"好久不见","can_delete":false,"product_type":"c1","uid":1391249,"ip_address":"","ucode":"283FDB7580D398","user_header":"https://static001.geekbang.org/account/avatar/00/15/3a/91/d894a61f.jpg","comment_is_top":false,"comment_ctime":1591800320,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591800320","product_id":100039001,"comment_content":"观察者模式（Observer Design Pattern）也被称为发布订阅模式（Publish-Subscribe Design Pattern）","like_count":0},{"had_liked":false,"id":216711,"user_name":"旭东(Frank)","can_delete":false,"product_type":"c1","uid":1024486,"ip_address":"","ucode":"176FA629800062","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a1/e6/50da1b2d.jpg","comment_is_top":false,"comment_ctime":1589331094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589331094","product_id":100039001,"comment_content":"生产者 - 消费者”模型和观察者模式的区别:<br>生产者 - 消费者 侧重应用中数据的加工，两个公用一个数据缓存池子<br>观察者模式 侧重的使用事件、动作的变化对客户端行为的影响。不需要共享数据，每个客户端直接那一份数据拷贝即可<br><br>生产者 - 消费者”模型和观察者模式的联系:<br>都有一个生产一个消费的角色<br>都可以有多个数据（或者事件）生产者，多个消费者（但生产者消费者模式一般只有一个消费者消费即可）<br><br><br>","like_count":0},{"had_liked":false,"id":216490,"user_name":"新世界","can_delete":false,"product_type":"c1","uid":1079495,"ip_address":"","ucode":"4473DC1505F158","user_header":"https://static001.geekbang.org/account/avatar/00/10/78/c7/083a3a0b.jpg","comment_is_top":false,"comment_ctime":1589270666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589270666","product_id":100039001,"comment_content":"推送系统，比如苹果的APNS 一个andriod阵营中的各种推送系统、消息队列，spring  中的eventLister","like_count":0},{"had_liked":false,"id":216265,"user_name":"KID","can_delete":false,"product_type":"c1","uid":1867938,"ip_address":"","ucode":"EE80B7CA7CC2A2","user_header":"https://static001.geekbang.org/account/avatar/00/1c/80/a2/96dcd1fa.jpg","comment_is_top":false,"comment_ctime":1589211801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589211801","product_id":100039001,"comment_content":"生产者-消费者 为异步调用，消费者之间互相竞争生产者的资源<br>观察者-被观察者可以同步或异步调用，观察者之间都能得到被观察者的回应，人人有份","like_count":0},{"had_liked":false,"id":213244,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1588339810,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588339810","product_id":100039001,"comment_content":"发布-订阅模型，是一对多的关系，可以以同步的方式实现，也可以以异步的方式实现。<br>生产-消费模型，是多对多的关系，一般以异步的方式实现<br>两者都可以达到解耦的作用","like_count":0},{"had_liked":false,"id":202831,"user_name":"FIRE","can_delete":false,"product_type":"c1","uid":1670763,"ip_address":"","ucode":"85861D990FB3AB","user_header":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","comment_is_top":false,"comment_ctime":1586074937,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586074937","product_id":100039001,"comment_content":"private List&lt;RegObserver&gt; regObservers = new ArrayList&lt;&gt;();<br>这里我可以使用spring的注解，自动注入所有的RegObserver实现类","like_count":0},{"had_liked":false,"id":202808,"user_name":"makermade","can_delete":false,"product_type":"c1","uid":1133194,"ip_address":"","ucode":"03386B90CB8F20","user_header":"https://static001.geekbang.org/account/avatar/00/11/4a/8a/c1069412.jpg","comment_is_top":false,"comment_ctime":1586072423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586072423","product_id":100039001,"comment_content":"生产-消费，有broker的存在。导致p和s完全透明化","like_count":0},{"had_liked":false,"id":201405,"user_name":"玩家","can_delete":false,"product_type":"c1","uid":1187094,"ip_address":"","ucode":"75BC2C2B4FC391","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/16/b75d040a.jpg","comment_is_top":false,"comment_ctime":1585778908,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"1585778908","product_id":100039001,"comment_content":"为什么会有人认为发布&#47;订阅模式就是观察者模式呢 一直在查资料 这两个好像是不一样的","like_count":0,"discussions":[{"author":{"id":1670763,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","nickname":"FIRE","note":"","ucode":"85861D990FB3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221869,"discussion_content":"我也觉得是不一样的。又有点说不出为啥不一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586073260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1187094,"avatar":"https://static001.geekbang.org/account/avatar/00/12/1d/16/b75d040a.jpg","nickname":"玩家","note":"","ucode":"75BC2C2B4FC391","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1670763,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7e/6b/36fc4516.jpg","nickname":"FIRE","note":"","ucode":"85861D990FB3AB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222213,"discussion_content":"发布订阅这两个可以互相不知道对方","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586101969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":221869,"ip_address":""},"score":222213,"extra":""}]}]},{"had_liked":false,"id":200894,"user_name":"谷雨","can_delete":false,"product_type":"c1","uid":1225827,"ip_address":"","ucode":"E8566AD0E2A521","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkkZBpiaOo4dGUuOXnRusBwcYCcwPTU8Pn41zbKh9py4Nwcf1rtc8A6yH5AtVVbkv8iaoS6hFgKevg/132","comment_is_top":false,"comment_ctime":1585669061,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585669061","product_id":100039001,"comment_content":"在前端中，有两块观察者模型：<br>* 事件驱动的场景，如点击事件、键盘输入事件，通过监听事件，进行逻辑处理<br>* 数据驱动的场景，现在流行的前端框架，如react、vue，通过监听数据的变动，进行逻辑处理","like_count":0},{"had_liked":false,"id":200571,"user_name":"L","can_delete":false,"product_type":"c1","uid":1024906,"ip_address":"","ucode":"EDA19E20BE3B81","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a3/8a/b8b6ef13.jpg","comment_is_top":false,"comment_ctime":1585619573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585619573","product_id":100039001,"comment_content":"生产者-消费者模型中，生产者一般是通过一个中间存储和消费者解耦，而消费者又是通过观察者模式来分发不同类型的消息。文章中用户注册的例子里，UserController和RegObserver 也可以看做是一个生产者-消费者模型，只不过这里的生产者和消费者是紧耦合的，如果再加一个中间存储，那么就可以实现生产者和消费者的解耦","like_count":0},{"had_liked":false,"id":196781,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1585312443,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585312443","product_id":100039001,"comment_content":"1、生产者-消费者是观察者模式的一种实现方式，需要一个中间件作为媒介。观察者模式是一种解决一对多，多对多的解决思路。两者都可以达到解耦的目的。<br>2、朋友圈，微信通知，QQ群消息、事件流","like_count":0},{"had_liked":false,"id":196764,"user_name":"小二","can_delete":false,"product_type":"c1","uid":1482571,"ip_address":"","ucode":"38636D40BF4820","user_header":"https://static001.geekbang.org/account/avatar/00/16/9f/4b/93f3e8f8.jpg","comment_is_top":false,"comment_ctime":1585311220,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585311220","product_id":100039001,"comment_content":"设计模式真是集编码艺术之大成之作，以前开发过消息处理插件的功能，由于插件是灵活配置的，无意中使用了观察者模式，今天终于找到出处了，感谢争哥~","like_count":0},{"had_liked":false,"id":195253,"user_name":"嘻哈","can_delete":false,"product_type":"c1","uid":1402535,"ip_address":"","ucode":"AEE1512822A399","user_header":"https://static001.geekbang.org/account/avatar/00/15/66/a7/5b7a7523.jpg","comment_is_top":false,"comment_ctime":1585150355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585150355","product_id":100039001,"comment_content":"“观察者模式“ ：观察者与被观察者之间 相互感知<br>“生产者 - 消费者”模型：生产者和消费者消费者可能互不知道彼此的存在","like_count":0},{"had_liked":false,"id":194922,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1585121077,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585121077","product_id":100039001,"comment_content":"晦涩难懂","like_count":0},{"had_liked":false,"id":194892,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1585117025,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585117025","product_id":100039001,"comment_content":"感觉写个方法a()，里面注入一个handler的map，用来处理handler。而调用这个方法a的时候，就会执行到里面所有的handler。这样子的模式都可以算是观察者模式。","like_count":0},{"had_liked":false,"id":192468,"user_name":"霍霍","can_delete":false,"product_type":"c1","uid":1542586,"ip_address":"","ucode":"A483D42AD7F72D","user_header":"https://static001.geekbang.org/account/avatar/00/17/89/ba/009ee13c.jpg","comment_is_top":false,"comment_ctime":1584852745,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1584852745","product_id":100039001,"comment_content":"第一次留言，学了这么久，自己在看一些设计模式还是有点吃力，所以每次都会看评论区的大神发言，受益匪浅，紧跟争哥步伐，争取结课的时候把所有设计模式都能做到知道使用场景，后面在项目中在深挖学习。最近在做监控系统，有2000个客户端状态需要监控。不知道适合用消息队列么，我只有一个服务器消费，感觉消费不过来","like_count":0},{"had_liked":false,"id":191216,"user_name":"胖子","can_delete":false,"product_type":"c1","uid":1037760,"ip_address":"","ucode":"E6371346288A87","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIuRQaZX70dsBg6khub2VPM1eQAP9IWRWxgOFed3ia4kXyNJInFRicWJ0ibf2YmLsOvJa1sGygGpmJg/132","comment_is_top":false,"comment_ctime":1584755328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584755328","product_id":100039001,"comment_content":"能否借用日常生活中的例子说明一下什么是行为解耦吗？","like_count":0},{"had_liked":false,"id":190734,"user_name":"djfhchdh","can_delete":false,"product_type":"c1","uid":1484184,"ip_address":"","ucode":"E71D75328CE398","user_header":"https://static001.geekbang.org/account/avatar/00/16/a5/98/a65ff31a.jpg","comment_is_top":false,"comment_ctime":1584688282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584688282","product_id":100039001,"comment_content":"2、比如插件化的思想，把模块、子系统当成一个插件，插入到整个代码框架中。","like_count":0},{"had_liked":false,"id":190694,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1584683670,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584683670","product_id":100039001,"comment_content":"1. 我去查了一下生产者-消费者模型 他们之间是通过消息队列的方式解偶了,而观察者模式 还没有解偶！<br>2. 观察者模型 在我们项目中用得最多的就是充值回调 进入游戏回调等等回调事件中","like_count":0},{"had_liked":false,"id":190657,"user_name":"sumi","can_delete":false,"product_type":"c1","uid":1253691,"ip_address":"","ucode":"753E0F46956E90","user_header":"https://static001.geekbang.org/account/avatar/00/13/21/3b/904ec8ab.jpg","comment_is_top":false,"comment_ctime":1584678381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584678381","product_id":100039001,"comment_content":"生产者 - 消费者，事件-观察者对比：<br>1 生产者-事件对比：生产者可以有多个（生产者之间可能是竞争关系，比如共同生产n个商品）；事件只能有一个<br>2 消费者-观察者：消费者可以有多个，消费者之间是竞争关系；多个观察者之间无关系<br>3 生产者 - 消费者，事件-观察者各自之间的联系：生产者 - 消费者会存在互动（生产者生产商品需要通知消费者，消费者消费了商品也要通知生产者）; 事件-观察者里观察者不同通知事件","like_count":0},{"had_liked":false,"id":190624,"user_name":"Wind","can_delete":false,"product_type":"c1","uid":1586425,"ip_address":"","ucode":"3679663B706C86","user_header":"https://static001.geekbang.org/account/avatar/00/18/34/f9/c46c0fff.jpg","comment_is_top":false,"comment_ctime":1584673721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584673721","product_id":100039001,"comment_content":"生产-消费模型：一个生产一个消费<br>发布-订阅模型：一个生产多个消费<br><br>生产-消费模型是发布-订阅模型的退化版<br>当只有一个订阅者的时候，发布订阅模型，就是生产-消费模型","like_count":0},{"had_liked":false,"id":190409,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1584640680,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584640680","product_id":100039001,"comment_content":"期待下一篇EventBus","like_count":0},{"had_liked":false,"id":189033,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1584448845,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584448845","product_id":100039001,"comment_content":"设计模式_56:<br># 作业<br>- 区别<br>  观察者模式: 每一个观察者都可以收到所有的通知。<br>  生产者-消费者: 每一次生产内容只能被某一个消费者消费。<br>- 联系<br>  都可以一个对多个，生产行为与消费行为解耦。<br><br># 感想<br>设计模式是为了解耦，而不是为了使用设计模式。解耦之后，人更不容易犯错，系统表现更好。","like_count":0},{"had_liked":false,"id":188722,"user_name":"冯琦","can_delete":false,"product_type":"c1","uid":1237163,"ip_address":"","ucode":"17AEE214897924","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/ab/fb5a0b66.jpg","comment_is_top":false,"comment_ctime":1584408646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584408646","product_id":100039001,"comment_content":"感觉和组合模式大同小异，区别只在于，组合：注册的元素和本身是同一类型，","like_count":0},{"had_liked":false,"id":188656,"user_name":"Bern","can_delete":false,"product_type":"c1","uid":1765806,"ip_address":"","ucode":"5A979552D5800D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlxr0eX6ZPlpiaUkH8SXoNibmOK9MJz2ZDYq5y57UfFHBu6dDc5VxKic1rAPiawLBVdSMl8y1Mwtp9Yg/132","comment_is_top":false,"comment_ctime":1584400718,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584400718","product_id":100039001,"comment_content":"对我的帮助很大。继续努力学习","like_count":0},{"had_liked":false,"id":188240,"user_name":"匿名","can_delete":false,"product_type":"c1","uid":1265774,"ip_address":"","ucode":"BAA596254FE0EB","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/6e/8bd276a5.jpg","comment_is_top":false,"comment_ctime":1584330357,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584330357","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":188019,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1584313385,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584313385","product_id":100039001,"comment_content":"1. 生产者-消费者模式中，生产者可以有多个，属于多对多，并且数据只会被消费者中的一个消费；观察者模式则是一对多，并且数据会广播gei各个被观察者<br>2. 电商系统中，交易系统在达成交易后，需要通知下游的营销、物流、支付、客服等子系统，这个场景是非常经典的观察者模式","like_count":0},{"had_liked":false,"id":187965,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1584284909,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584284909","product_id":100039001,"comment_content":"前端组件化中，组件一般是单向数据流的，这是为了防止子组件意外改变父级组件的状态。如果要改变子组件的状态，我们会通过自定义事件的方式通知父组件去修改状态。如果组件嵌套过深，可以考虑使用 eventBus 的方法来进行通知，具体就是维护一个 eventBus 对象，子组件在这个对象上注册一个自定义事件，祖先组件则监听这个事件，当子组件触发了这个事件时，祖先组件就会触发对应的操作（比如修改状态）。","like_count":0},{"had_liked":false,"id":187903,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1056019,"ip_address":"","ucode":"C53CB64E8E7D19","user_header":"https://static001.geekbang.org/account/avatar/00/10/1d/13/31ea1b0b.jpg","comment_is_top":false,"comment_ctime":1584272066,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584272066","product_id":100039001,"comment_content":"结构型设计模式帮助我们设计类对象的继承组合关系，创建型设计模式把相关的对象创建出来，行为型设计模式关注这些对象之间的交互，比如观察者模式，被观察者对象通知观察者对象，对这种交互而言，被观察者不需要知道观察者具体是什么，从而将其解耦。","like_count":0},{"had_liked":false,"id":187839,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1584257816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584257816","product_id":100039001,"comment_content":"理论上生产者消费者模式不需要通知机制，用消息队列来进行解偶，消费者轮寻消息队列；发布订阅模式需要一个通知机制，发布者发布消息后需要通知订阅者。<br>这只是理论，实际使用上是非常灵活的，比如使用rabbitmq,direct exchange更类似于观察者模式，topic exchange更类似于发布订阅模式，都是可以通知消息接收方的。<br>","like_count":0},{"had_liked":false,"id":187803,"user_name":"YourSweetHeart","can_delete":false,"product_type":"c1","uid":1242122,"ip_address":"","ucode":"38843F447B03F2","user_header":"https://static001.geekbang.org/account/avatar/00/12/f4/0a/cf728857.jpg","comment_is_top":false,"comment_ctime":1584246380,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584246380","product_id":100039001,"comment_content":"终于知道了为什么用php套这些设计模式的时候，为什么那么别扭的原因了","like_count":0,"discussions":[{"author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":89159,"discussion_content":"代码是有点问题. virtualWalletRepo这个应该是写错了, 正确的应该是walletRepo. 另外为什么获取余额分别拿了两个不同地方的数据, 可能也是写错了.....也可能是缓存设计, 毕竟读数据库需要时间. ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576752713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1392730,"avatar":"https://static001.geekbang.org/account/avatar/00/15/40/5a/e65e8c40.jpg","nickname":"wl","note":"","ucode":"45062AA2460F1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1337598,"avatar":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","nickname":"岁月","note":"","ucode":"29A2A2BC3C4FE4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":98437,"discussion_content":"谢谢帮忙解释！因为没有后端经验，看起来确实很吃力…尤其代码有问题，就更加难","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577163378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":89159,"ip_address":""},"score":98437,"extra":""}]}]},{"had_liked":false,"id":187759,"user_name":"码农","can_delete":false,"product_type":"c1","uid":1265015,"ip_address":"","ucode":"D8E688844EDA69","user_header":"https://static001.geekbang.org/account/avatar/00/13/4d/77/c877d970.jpg","comment_is_top":false,"comment_ctime":1584233822,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584233822","product_id":100039001,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":187604,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1584170683,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584170683","product_id":100039001,"comment_content":"一、定义（理解）：<br>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）<br><br>二、使用场景：<br>小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。<br><br>三、实现方式：<br>一般是定义一个观察者接口：<br>public interface Observer {  void update(Message message);}<br>被观察者通过registerObserver，removeObserver和notifyObservers实现对观察者的通知<br><br>四、创建型模式、结构型模式和行为型模式解决的问题<br>创建型：解决的是对象创建的问题，将创建和使用代码解耦<br>结构型：解决的是类和对象的组合的问题，将不同功能代码解耦<br>行为型：解决的是类和对象的交互问题，将不同行为的代码解耦<br>设计模式本质都是对代码和功能进行解耦，借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚低耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。<br>","like_count":0,"discussions":[{"author":{"id":1002095,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","nickname":"xzy","note":"","ucode":"1A44368083A19E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80857,"discussion_content":"转账时，扣出了转出账户的余额，然后被转入的账户会增加余额。\n假如瞬间发生两次转账，也不会出现转出的钱比自己的余额多的情况！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576200390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187419,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1584105865,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584105865","product_id":100039001,"comment_content":"最近在研究ROS（Robotic Operating System），里面有“节点”的概念，节点之间的通信采用订阅-发布模式实现。<br>生产-消费模型通常在多线程环境使用，生产者将消息丢到缓冲区，消费者去拿。本质上我觉着和观察者模式没啥区别，可以算上特殊的观察者模式。<br>生产者消费者关系可以是1对1，1对多，多对1，多对多关系。而观察者模式被观察者和观察者可以是1对多（包含1对1）的关系。","like_count":0},{"had_liked":false,"id":187240,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1584067756,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1584067756","product_id":100039001,"comment_content":"作为一个Javaer，观察者模式用的真的还是挺多的；作为一个Andorider，EventBus就是常用的框架，也是基于观察者模式而来，应用实在是广泛。<br><br>生产者-消费者，我是从学习操作系统的角度来看，有多个生产者，以及多个消费者，而且存在竞争，处于多对多的关系，执行的不好还会有死锁的情况发生；观察者没竞争，而且消息发布方只有一个。","like_count":0},{"had_liked":false,"id":187128,"user_name":"此鱼不得水","can_delete":false,"product_type":"c1","uid":1257453,"ip_address":"","ucode":"95268E823FB4D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ed/a87bb8fa.jpg","comment_is_top":false,"comment_ctime":1584022019,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584022019","product_id":100039001,"comment_content":"加粗的几句话应该是本文的精髓了，一语点破梦中人的感觉","like_count":0},{"had_liked":false,"id":186850,"user_name":"zx","can_delete":false,"product_type":"c1","uid":1059177,"ip_address":"","ucode":"444F6FF495BC2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/29/69/c1575a7a.jpg","comment_is_top":false,"comment_ctime":1583938337,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583938337","product_id":100039001,"comment_content":"在UserController 中 没看到private List regObservers = new ArrayList&lt;&gt;();  是如何添加被依赖的对象，下面setRegObservers的值，也不会有新的对象加入啊<br><br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476841,"discussion_content":"继续拆分成更细粒度的domain","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575897836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186814,"user_name":"小刀","can_delete":false,"product_type":"c1","uid":1351063,"ip_address":"","ucode":"94DF8C45E09E42","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaByN5IfYbE9jMtWrtTDXtPEIHeV77KW1p7ZkiasiaGgA50VXaibo4fbp5ib2JkFP3iaIe4AUudLibufkEIofu5euCNHg/132","comment_is_top":false,"comment_ctime":1583933328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583933328","product_id":100039001,"comment_content":"一对多   多对多","like_count":0},{"had_liked":false,"id":186764,"user_name":"jaryoung","can_delete":false,"product_type":"c1","uid":1077406,"ip_address":"","ucode":"6E72D107DB7E51","user_header":"https://static001.geekbang.org/account/avatar/00/10/70/9e/5095f881.jpg","comment_is_top":false,"comment_ctime":1583919161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583919161","product_id":100039001,"comment_content":"问题2，ddd的事件驱动？","like_count":0},{"had_liked":false,"id":186688,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1583902219,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583902219","product_id":100039001,"comment_content":"观察者模式，一对多的关系；生产-消费者模式，多对多的关系，通常有一个中间件做消息管道。","like_count":0},{"had_liked":false,"id":186653,"user_name":"，","can_delete":false,"product_type":"c1","uid":1701867,"ip_address":"","ucode":"A5543C8DFEB198","user_header":"https://static001.geekbang.org/account/avatar/00/19/f7/eb/e7127bb8.jpg","comment_is_top":false,"comment_ctime":1583895625,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583895625","product_id":100039001,"comment_content":"课后题:<br>1.个人认为生产者消费者模式可以属于观察者模式的一种更具体的描述,他们的相同之处是将生产者与消费者解耦,不同之处则是生产者消费者模式通常在不同的进程之间使用,而观察者模式则没有这个要求<br>2.项目中用到物联网设备,天线扫描仓库的库位,将扫描到的标签推送到第三方的应用里,在对第三方应用做扩展时,就是实现了一个接口,然后将它添加到一个list中,物联网设备就可以推到我的实现类里","like_count":0},{"had_liked":false,"id":186639,"user_name":"大头","can_delete":false,"product_type":"c1","uid":1315367,"ip_address":"","ucode":"C1FB2C8A0FB0C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/27/32746bbf.jpg","comment_is_top":false,"comment_ctime":1583894443,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583894443","product_id":100039001,"comment_content":"非常期待下节课的学习，已经想好应用场景了。我们系统的员工会调用部门，调动后很多关联数据需要更新，觉得比较适合观察者模式，部门变化后通知不同的接口，做异步数据处理","like_count":0},{"had_liked":false,"id":186622,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1583892577,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583892577","product_id":100039001,"comment_content":"1. 生产者-消费者 模式 是多对多依赖关系, 观察者模式是一对多依赖关系. <br>2. 微信公众号符合观察者模式的定义: publisher发布消息, 所有observer都会收到消息.<br>","like_count":0},{"had_liked":false,"id":186594,"user_name":"业余爱好者","can_delete":false,"product_type":"c1","uid":1482915,"ip_address":"","ucode":"A890935A982988","user_header":"https://static001.geekbang.org/account/avatar/00/16/a0/a3/8da99bb0.jpg","comment_is_top":false,"comment_ctime":1583889858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583889858","product_id":100039001,"comment_content":"好代码的设计有很多标准，可读性，扩展性等。设计模式主要解决了软件需求频繁变更面临的扩展性的问题。解决方法是面向接口编程。将变化点与稳定点分离，抽象出接口。<br><br>设计模式不光适用于面向对象的代码设计。架构设计同样受益。其中很重要的能力就是抽象。<br><br><br>把相似的东西放在一起比较是种很好的学习方法。","like_count":0},{"had_liked":false,"id":186584,"user_name":"何妨","can_delete":false,"product_type":"c1","uid":1385377,"ip_address":"","ucode":"EC3983BFF7992A","user_header":"https://static001.geekbang.org/account/avatar/00/15/23/a1/b08f3ee7.jpg","comment_is_top":false,"comment_ctime":1583888566,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583888566","product_id":100039001,"comment_content":"类似于微信公众号吧","like_count":0},{"had_liked":false,"id":186559,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1583882437,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1583882437","product_id":100039001,"comment_content":"观察者模式跟之前看到的回调模式有点像，许多worker订阅boss，worker干完活把结果回调通知给boss。worker就像是observer,boss就像是subject.不一样的是观察者模式是subject主动通知observers,而回调模式是worker干完活通知boss.<br>还有个疑问:文中说的异步非阻塞模式去调用observers时，如果还想知道每个observer执行后的返回值怎么办？比如后边的逻辑依赖于这些返回值。请老师解答。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476673,"discussion_content":"是有这个问题 我改下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575424827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}