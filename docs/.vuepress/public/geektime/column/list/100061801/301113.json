{"id":301113,"title":"08 | Once：一个简约而不简单的并发原语","content":"<p>你好，我是鸟窝。</p><p>这一讲我来讲一个简单的并发原语：Once。为什么要学习Once呢？我先给你答案：<strong>Once可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。</strong></p><p>那这节课，我们就从对单例对象进行初始化这件事儿说起。</p><p>初始化单例资源有很多方法，比如定义package级别的变量，这样程序在启动的时候就可以初始化：</p><pre><code>package abc\n\nimport time\n\nvar startTime = time.Now()\n</code></pre><p>或者在init函数中进行初始化：</p><pre><code>package abc\n\nvar startTime time.Time\n\nfunc init() {\n  startTime = time.Now()\n}\n\n</code></pre><p>又或者在main函数开始执行的时候，执行一个初始化的函数：</p><pre><code>package abc\n\nvar startTime time.Tim\n\nfunc initApp() {\n    startTime = time.Now()\n}\nfunc main() {\n  initApp()\n}\n</code></pre><p>这三种方法都是线程安全的，并且后两种方法还可以根据传入的参数实现定制化的初始化操作。</p><p>但是很多时候我们是要延迟进行初始化的，所以有时候单例资源的初始化，我们会使用下面的方法：</p><pre><code>package main\n\nimport (\n    &quot;net&quot;\n    &quot;sync&quot;\n    &quot;time&quot;\n)\n\n// 使用互斥锁保证线程(goroutine)安全\nvar connMu sync.Mutex\nvar conn net.Conn\n\nfunc getConn() net.Conn {\n    connMu.Lock()\n    defer connMu.Unlock()\n\n    // 返回已创建好的连接\n    if conn != nil {\n        return conn\n    }\n\n    // 创建连接\n    conn, _ = net.DialTimeout(&quot;tcp&quot;, &quot;baidu.com:80&quot;, 10*time.Second)\n    return conn\n}\n\n// 使用连接\nfunc main() {\n    conn := getConn()\n    if conn == nil {\n        panic(&quot;conn is nil&quot;)\n    }\n}\n</code></pre><p>这种方式虽然实现起来简单，但是有性能问题。一旦连接创建好，每次请求的时候还是得竞争锁才能读取到这个连接，这是比较浪费资源的，因为连接如果创建好之后，其实就不需要锁的保护了。怎么办呢？</p><p>这个时候就可以使用这一讲要介绍的Once并发原语了。接下来我会详细介绍Once的使用、实现和易错场景。</p><h1>Once的使用场景</h1><p><strong>sync.Once只暴露了一个方法Do，你可以多次调用Do方法，但是只有第一次调用Do方法时f参数才会执行，这里的f是一个无参数无返回值的函数。</strong></p><!-- [[[read_end]]] --><pre><code>func (o *Once) Do(f func())\n</code></pre><p>因为当且仅当第一次调用Do方法的时候参数f才会执行，即使第二次、第三次、第n次调用时f参数的值不一样，也不会被执行，比如下面的例子，虽然f1和f2是不同的函数，但是第二个函数f2就不会执行。</p><pre><code>package main\n\n\nimport (\n    &quot;fmt&quot;\n    &quot;sync&quot;\n)\n\nfunc main() {\n    var once sync.Once\n\n    // 第一个初始化函数\n    f1 := func() {\n        fmt.Println(&quot;in f1&quot;)\n    }\n    once.Do(f1) // 打印出 in f1\n\n    // 第二个初始化函数\n    f2 := func() {\n        fmt.Println(&quot;in f2&quot;)\n    }\n    once.Do(f2) // 无输出\n}\n</code></pre><p>因为这里的f参数是一个无参数无返回的函数，所以你可能会通过闭包的方式引用外面的参数，比如：</p><pre><code>    var addr = &quot;baidu.com&quot;\n\n    var conn net.Conn\n    var err error\n\n    once.Do(func() {\n        conn, err = net.Dial(&quot;tcp&quot;, addr)\n    })\n</code></pre><p>而且在实际的使用中，绝大多数情况下，你会使用闭包的方式去初始化外部的一个资源。</p><p>你看，Once的使用场景很明确，所以，在标准库内部实现中也常常能看到Once的身影。</p><p>比如标准库内部<a href=\"https://github.com/golang/go/blob/f0e97546962736fe4aa73b7c7ed590f0134515e1/src/cmd/go/internal/cache/default.go\">cache</a>的实现上，就使用了Once初始化Cache资源，包括defaultDir值的获取：</p><pre><code>    func Default() *Cache { // 获取默认的Cache\n\t\tdefaultOnce.Do(initDefaultCache) // 初始化cache\n\t\treturn defaultCache\n\t}\n\t\n    // 定义一个全局的cache变量，使用Once初始化，所以也定义了一个Once变量\n\tvar (\n\t\tdefaultOnce  sync.Once\n\t\tdefaultCache *Cache\n\t)\n\n    func initDefaultCache() { //初始化cache,也就是Once.Do使用的f函数\n\t\t......\n\t\tdefaultCache = c\n\t}\n\n    // 其它一些Once初始化的变量，比如defaultDir\n    var (\n\t\tdefaultDirOnce sync.Once\n\t\tdefaultDir     string\n\t\tdefaultDirErr  error\n\t)\n\n\n</code></pre><p>还有一些测试的时候初始化测试的资源（<a href=\"https://github.com/golang/go/blob/50bd1c4d4eb4fac8ddeb5f063c099daccfb71b26/src/time/export_windows_test.go\">export_windows_test</a>）：</p><pre><code>    // 测试window系统调用时区相关函数\n    func ForceAusFromTZIForTesting() {\n\t\tResetLocalOnceForTest()\n        // 使用Once执行一次初始化\n\t\tlocalOnce.Do(func() { initLocalFromTZI(&amp;aus) })\n\t}\n</code></pre><p>除此之外，还有保证只调用一次copyenv的envOnce，strings包下的Replacer，time包中的<a href=\"https://github.com/golang/go/blob/b71eafbcece175db33acfb205e9090ca99a8f984/src/time/export_test.go#L12\">测试</a>，Go拉取库时的<a href=\"https://github.com/golang/go/blob/8535008765b4fcd5c7dc3fb2b73a856af4d51f9b/src/cmd/go/internal/modfetch/proxy.go#L103\">proxy</a>，net.pipe，crc64，Regexp，……，数不胜数。我给你重点介绍一下很值得我们学习的 math/big/sqrt.go中实现的一个数据结构，它通过Once封装了一个只初始化一次的值：</p><pre><code>   // 值是3.0或者0.0的一个数据结构\n   var threeOnce struct {\n\t\tsync.Once\n\t\tv *Float\n\t}\n\t\n    // 返回此数据结构的值，如果还没有初始化为3.0，则初始化\n\tfunc three() *Float {\n\t\tthreeOnce.Do(func() { // 使用Once初始化\n\t\t\tthreeOnce.v = NewFloat(3.0)\n\t\t})\n\t\treturn threeOnce.v\n\t}\n</code></pre><p>它将sync.Once和*Float封装成一个对象，提供了只初始化一次的值v。 你看它的three方法的实现，虽然每次都调用threeOnce.Do方法，但是参数只会被调用一次。</p><p>当你使用Once的时候，你也可以尝试采用这种结构，将值和Once封装成一个新的数据结构，提供只初始化一次的值。</p><p>总结一下Once并发原语解决的问题和使用场景：<strong>Once常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源</strong>。</p><p>了解了Once的使用场景，那应该怎样实现一个Once呢？</p><h1>如何实现一个Once？</h1><p>很多人认为实现一个Once一样的并发原语很简单，只需使用一个flag标记是否初始化过即可，最多是用atomic原子操作这个flag，比如下面的实现：</p><pre><code>type Once struct {\n    done uint32\n}\n\nfunc (o *Once) Do(f func()) {\n    if !atomic.CompareAndSwapUint32(&amp;o.done, 0, 1) {\n        return\n    }\n    f()\n}\n</code></pre><p>这确实是一种实现方式，但是，这个实现有一个很大的问题，就是如果参数f执行很慢的话，后续调用Do方法的goroutine虽然看到done已经设置为执行过了，但是获取某些初始化资源的时候可能会得到空的资源，因为f还没有执行完。</p><p>所以，<strong>一个正确的Once实现要使用一个互斥锁，<strong>这样初始化的时候如果有并发的goroutine，就会进入</strong>doSlow方法</strong>。互斥锁的机制保证只有一个goroutine进行初始化，同时利用<strong>双检查的机制</strong>（double-checking），再次判断o.done是否为0，如果为0，则是第一次执行，执行完毕后，就将o.done设置为1，然后释放锁。</p><p>即使此时有多个goroutine同时进入了doSlow方法，因为双检查的机制，后续的goroutine会看到o.done的值为1，也不会再次执行f。</p><p>这样既保证了并发的goroutine会等待f完成，而且还不会多次执行f。</p><pre><code>type Once struct {\n    done uint32\n    m    Mutex\n}\n\nfunc (o *Once) Do(f func()) {\n    if atomic.LoadUint32(&amp;o.done) == 0 {\n        o.doSlow(f)\n    }\n}\n\n\nfunc (o *Once) doSlow(f func()) {\n    o.m.Lock()\n    defer o.m.Unlock()\n    // 双检查\n    if o.done == 0 {\n        defer atomic.StoreUint32(&amp;o.done, 1)\n        f()\n    }\n}\n</code></pre><p>好了，到这里我们就了解了Once的使用场景，很明确，同时呢，也感受到Once的实现也是相对简单的。在实践中，其实很少会出现错误使用Once的情况，但是就像墨菲定律说的，凡是可能出错的事就一定会出错。使用Once也有可能出现两种错误场景，尽管非常罕见。我这里提前讲给你，咱打个预防针。</p><h1>使用Once可能出现的2种错误</h1><h2>第一种错误：死锁</h2><p>你已经知道了Do方法会执行一次f，但是如果f中再次调用这个Once的Do方法的话，就会导致死锁的情况出现。这还不是无限递归的情况，而是的的确确的Lock的递归调用导致的死锁。</p><pre><code>func main() {\n    var once sync.Once\n    once.Do(func() {\n        once.Do(func() {\n            fmt.Println(&quot;初始化&quot;)\n        })\n    })\n}\n</code></pre><p>当然，想要避免这种情况的出现，就不要在f参数中调用当前的这个Once，不管是直接的还是间接的。</p><h2>第二种错误：未初始化</h2><p>如果f方法执行的时候panic，或者f执行初始化资源的时候失败了，这个时候，Once还是会认为初次执行已经成功了，即使再次调用Do方法，也不会再次执行f。</p><p>比如下面的例子，由于一些防火墙的原因，googleConn并没有被正确的初始化，后面如果想当然认为既然执行了Do方法googleConn就已经初始化的话，会抛出空指针的错误：</p><pre><code>func main() {\n    var once sync.Once\n    var googleConn net.Conn // 到Google网站的一个连接\n\n    once.Do(func() {\n        // 建立到google.com的连接，有可能因为网络的原因，googleConn并没有建立成功，此时它的值为nil\n        googleConn, _ = net.Dial(&quot;tcp&quot;, &quot;google.com:80&quot;)\n    })\n    // 发送http请求\n    googleConn.Write([]byte(&quot;GET / HTTP/1.1\\r\\nHost: google.com\\r\\n Accept: */*\\r\\n\\r\\n&quot;))\n    io.Copy(os.Stdout, googleConn)\n}\n</code></pre><p>既然执行过Once.Do方法也可能因为函数执行失败的原因未初始化资源，并且以后也没机会再次初始化资源，那么这种初始化未完成的问题该怎么解决呢？</p><p>这里我来告诉你一招独家秘笈，我们可以<strong>自己实现一个类似Once的并发原语</strong>，既可以返回当前调用Do方法是否正确完成，还可以在初始化失败后调用Do方法再次尝试初始化，直到初始化成功才不再初始化了。</p><pre><code>// 一个功能更加强大的Once\ntype Once struct {\n    m    sync.Mutex\n    done uint32\n}\n// 传入的函数f有返回值error，如果初始化失败，需要返回失败的error\n// Do方法会把这个error返回给调用者\nfunc (o *Once) Do(f func() error) error {\n    if atomic.LoadUint32(&amp;o.done) == 1 { //fast path\n        return nil\n    }\n    return o.slowDo(f)\n}\n// 如果还没有初始化\nfunc (o *Once) slowDo(f func() error) error {\n    o.m.Lock()\n    defer o.m.Unlock()\n    var err error\n    if o.done == 0 { // 双检查，还没有初始化\n        err = f()\n        if err == nil { // 初始化成功才将标记置为已初始化\n            atomic.StoreUint32(&amp;o.done, 1)\n        }\n    }\n    return err\n}\n</code></pre><p>我们所做的改变就是Do方法和参数f函数都会返回error，如果f执行失败，会把这个错误信息返回。</p><p>对slowDo方法也做了调整，如果f调用失败，我们不会更改done字段的值，这样后续的goroutine还会继续调用f。如果f执行成功，才会修改done的值为1。</p><p>可以说，真是一顿操作猛如虎，我们使用Once有点得心应手的感觉了。等等，还有个问题，我们怎么查询是否初始化过呢？</p><p>目前的Once实现可以保证你调用任意次数的once.Do方法，它只会执行这个方法一次。但是，有时候我们需要打一个标记。如果初始化后我们就去执行其它的操作，标准库的Once并不会告诉你是否初始化完成了，只是让你放心大胆地去执行Do方法，所以，<strong>你还需要一个辅助变量，自己去检查是否初始化过了</strong>，比如通过下面的代码中的inited字段：</p><pre><code>type AnimalStore struct {once   sync.Once;inited uint32}\nfunc (a *AnimalStore) Init() // 可以被并发调用\n\ta.once.Do(func() {\n\t\tlongOperationSetupDbOpenFilesQueuesEtc()\n\t\tatomic.StoreUint32(&amp;a.inited, 1)\n\t})\n}\nfunc (a *AnimalStore) CountOfCats() (int, error) { // 另外一个goroutine\n\tif atomic.LoadUint32(&amp;a.inited) == 0 { // 初始化后才会执行真正的业务逻辑\n\t\treturn 0, NotYetInitedError\n\t}\n        //Real operation\n}\n</code></pre><p>当然，通过这段代码，我们可以解决这类问题，但是，如果官方的Once类型有Done这样一个方法的话，我们就可以直接使用了。这是有人在Go代码库中提出的一个issue(<a href=\"https://github.com/golang/go/issues/41690\">#41690</a>)。对于这类问题，一般都会被建议采用其它类型，或者自己去扩展。我们可以尝试扩展这个并发原语：</p><pre><code>// Once 是一个扩展的sync.Once类型，提供了一个Done方法\ntype Once struct {\n    sync.Once\n}\n\n// Done 返回此Once是否执行过\n// 如果执行过则返回true\n// 如果没有执行过或者正在执行，返回false\nfunc (o *Once) Done() bool {\n    return atomic.LoadUint32((*uint32)(unsafe.Pointer(&amp;o.Once))) == 1\n}\n\nfunc main() {\n    var flag Once\n    fmt.Println(flag.Done()) //false\n\n    flag.Do(func() {\n        time.Sleep(time.Second)\n    })\n\n    fmt.Println(flag.Done()) //true\n}\n</code></pre><p>好了，到这里关于并发原语Once的内容我讲得就差不多了。最后呢，和你分享一个Once的踩坑案例。</p><p>其实啊，使用Once真的不容易犯错，想犯错都很困难，因为很少有人会傻傻地在初始化函数f中递归调用f，这种死锁的现象几乎不会发生。另外如果函数初始化不成功，我们一般会panic，或者在使用的时候做检查，会及早发现这个问题，在初始化函数中加强代码。</p><p>所以查看大部分的Go项目，几乎找不到Once的错误使用场景，不过我还是发现了一个。这个issue先从另外一个需求(<a href=\"https://github.com/golang/go/issues/25955\">go#25955</a>)谈起。</p><h1>Once的踩坑案例</h1><p>go#25955有网友提出一个需求，希望Once提供一个Reset方法，能够将Once重置为初始化的状态。比如下面的例子，St通过两个Once控制它的Open/Close状态。但是在Close之后再调用Open的话，不会再执行init函数，因为Once只会执行一次初始化函数。</p><pre><code>type St struct {\n    openOnce *sync.Once\n    closeOnce *sync.Once\n}\n\nfunc(st *St) Open(){\n    st.openOnce.Do(func() { ... }) // init\n    ...\n}\n\nfunc(st *St) Close(){\n    st.closeOnce.Do(func() { ... }) // deinit\n    ...\n}\n</code></pre><p>所以提交这个Issue的开发者希望Once增加一个Reset方法，Reset之后再调用once.Do就又可以初始化了。</p><p>Go的核心开发者Ian Lance Taylor给他了一个简单的解决方案。在这个例子中，只使用一个ponce *sync.Once 做初始化，Reset的时候给ponce这个变量赋值一个新的Once实例即可(ponce = new(sync.Once))。Once的本意就是执行一次，所以Reset破坏了这个并发原语的本意。</p><p>这个解决方案一点都没问题，可以很好地解决这位开发者的需求。Docker较早的版本（1.11.2）中使用了它们的一个网络库libnetwork，这个网络库在使用Once的时候就使用Ian Lance Taylor介绍的方法，但是不幸的是，它的Reset方法中又改变了Once指针的值，导致程序panic了。原始逻辑比较复杂，一个简化版可重现的<a href=\"https://play.golang.org/p/xPULnrVKiY\">代码</a>如下：</p><pre><code>package main\n\nimport (\n\t&quot;fmt&quot;\n\t&quot;sync&quot;\n\t&quot;time&quot;\n)\n\n// 一个组合的并发原语\ntype MuOnce struct {\n\tsync.RWMutex\n\tsync.Once\n\tmtime time.Time\n\tvals  []string\n}\n\n// 相当于reset方法，会将m.Once重新复制一个Once\nfunc (m *MuOnce) refresh() {\n\tm.Lock()\n\tdefer m.Unlock()\n\tm.Once = sync.Once{}\n\tm.mtime = time.Now()\n\tm.vals = []string{m.mtime.String()}\n}\n\n// 获取某个初始化的值，如果超过某个时间，会reset Once\nfunc (m *MuOnce) strings() []string {\n\tnow := time.Now()\n\tm.RLock()\n\tif now.After(m.mtime) {\n\t\tdefer m.Do(m.refresh) // 使用refresh函数重新初始化\n\t}\n\tvals := m.vals\n\tm.RUnlock()\n\treturn vals\n}\n\nfunc main() {\n\tfmt.Println(&quot;Hello, playground&quot;)\n\tm := new(MuOnce)\n\tfmt.Println(m.strings())\n\tfmt.Println(m.strings())\n}\n</code></pre><p>如果你执行这段代码就会panic:</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/af/f3401f75a86e1d0c3b257f52696228af.png?wh=1323*482\" alt=\"\"></p><p>原因在于第31行执行m.Once.Do方法的时候，使用的是m.Once的指针，然后调用m.refresh，在执行m.refresh的时候Once内部的Mutex首先会加锁（可以再翻看一下这一讲的Once的实现原理）， 但是，在refresh中更改了Once指针的值之后，结果在执行完refresh释放锁的时候，释放的是一个刚初始化未加锁的Mutex，所以就panic了。</p><p>如果你还不太明白，我再给你简化成一个更简单的例子：</p><pre><code>package main\n\n\nimport (\n    &quot;sync&quot;\n)\n\ntype Once struct {\n    m sync.Mutex\n}\n\nfunc (o *Once) doSlow() {\n    o.m.Lock()\n    defer o.m.Unlock()\n\n    // 这里更新的o指针的值!!!!!!!, 会导致上一行Unlock出错\n    *o = Once{}\n}\n\nfunc main() {\n    var once Once\n    once.doSlow()\n}\n</code></pre><p>doSlow方法就演示了这个错误。Ian Lance Taylor介绍的Reset方法没有错误，但是你在使用的时候千万别再初始化函数中Reset这个Once，否则势必会导致Unlock一个未加锁的Mutex的错误。</p><p>总的来说，这还是对Once的实现机制不熟悉，又进行复杂使用导致的错误。不过最新版的libnetwork相关的地方已经去掉了Once的使用了。所以，我带你一起来看这个案例，主要目的还是想巩固一下我们对Once的理解。</p><h1>总结</h1><p>今天我们一起学习了Once，我们常常使用它来实现单例模式。</p><p>单例是23种设计模式之一，也是常常引起争议的设计模式之一，甚至有人把它归为反模式。为什么说它是反模式呢，我拿标准库中的单例模式给你介绍下。</p><p>因为Go没有immutable类型，导致我们声明的全局变量都是可变的，别的地方或者第三方库可以随意更改这些变量。比如package io中定义了几个全局变量，比如io.EOF：</p><pre><code>var EOF = errors.New(&quot;EOF&quot;)\n</code></pre><p>因为它是一个package级别的变量，我们可以在程序中偷偷把它改了，这会导致一些依赖io.EOF这个变量做判断的代码出错。</p><pre><code>io.EOF = errors.New(&quot;我们自己定义的EOF&quot;)\n</code></pre><p>从我个人的角度来说，一些单例（全局变量）的确很方便，比如Buffer池或者连接池，所以有时候我们也不要谈虎色变。虽然有人把单例模式称之为反模式，但毕竟只能代表一部分开发者的观点，否则也不会把它列在23种设计模式中了。</p><p>如果你真的担心这个package级别的变量被人修改，你可以不把它们暴露出来，而是提供一个只读的GetXXX的方法，这样别人就不会进行修改了。</p><p>而且，Once不只应用于单例模式，一些变量在也需要在使用的时候做延迟初始化，所以也是可以使用Once处理这些场景的。</p><p>总而言之，Once的应用场景还是很广泛的。<strong>一旦你遇到只需要初始化一次的场景，首先想到的就应该是Once并发原语。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/4b/ba/4b1721a63d7bd3f3995eb18cee418fba.jpg?wh=2250*880\" alt=\"\"></p><h1>思考题</h1><ol>\n<li>\n<p>我已经分析了几个并发原语的实现，你可能注意到总是有些slowXXXX的方法，从XXXX方法中单独抽取出来，你明白为什么要这么做吗，有什么好处？</p>\n</li>\n<li>\n<p>Once在第一次使用之后，还能复制给其它变量使用吗？</p>\n</li>\n</ol><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得有所收获，也欢迎你把今天的内容分享给你的朋友或同事。</p>","comments":[{"had_liked":false,"id":260823,"user_name":"端贺","can_delete":false,"product_type":"c1","uid":1121588,"ip_address":"","ucode":"80F1400B138055","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/34/8201baab.jpg","comment_is_top":false,"comment_ctime":1605137605,"is_pvip":false,"replies":[{"id":"94718","content":"对","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605142963,"ip_address":"","comment_id":260823,"utype":1}],"discussion_count":3,"race_medal":0,"score":"66029647045","product_id":100061801,"comment_content":"问题一：分离固定内容和非固定内容，使得固定的内容能被内联调用，从而优化执行过程。<br>问题二：Once被拷贝的过程中内部的已执行状态不会改变，所以Once不能通过拷贝多次执行。<br>不知道回答对不对，请老师指点。","like_count":16,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509297,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605142963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1629565,"avatar":"https://static001.geekbang.org/account/avatar/00/18/dd/7d/5d3ab033.jpg","nickname":"不求闻达","note":"","ucode":"B265859B9566D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329485,"discussion_content":"可以拷贝，但这样拷贝不会执行多次，所以拷贝没有意义。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606390500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385865,"discussion_content":"非固定的内容指什么呀，有代码示例吗？对比一下固定与非固定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627305169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261660,"user_name":"大力","can_delete":false,"product_type":"c1","uid":1199805,"ip_address":"","ucode":"29785E3575761C","user_header":"https://static001.geekbang.org/account/avatar/00/12/4e/bd/4b19cda0.jpg","comment_is_top":false,"comment_ctime":1605485569,"is_pvip":false,"replies":[{"id":"94988","content":"你可以搜一下golang inline,有几位大牛已经介绍了内联优化的知识","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1605512515,"ip_address":"","comment_id":261660,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27375289345","product_id":100061801,"comment_content":"请教这里所说的内联，提高执行效率是什么意思？","like_count":6,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509556,"discussion_content":"你可以搜一下golang inline,有几位大牛已经介绍了内联优化的知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605512515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257098,"user_name":"🍀柠檬鱼也是鱼","can_delete":false,"product_type":"c1","uid":2178501,"ip_address":"","ucode":"DCF033636465F3","user_header":"https://static001.geekbang.org/account/avatar/00/21/3d/c5/f43fa619.jpg","comment_is_top":false,"comment_ctime":1603851973,"is_pvip":false,"replies":[{"id":"93591","content":"因为有并发初始化的问题","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603861913,"ip_address":"","comment_id":257098,"utype":1}],"discussion_count":4,"race_medal":0,"score":"27373655749","product_id":100061801,"comment_content":"once为什么不直接加锁，还需要加多一个 双重检测呢？这块不太懂，望老师解答，我的理解是，调用do()之后直接上锁，等执行完f()再解锁不就行了吗","like_count":6,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508222,"discussion_content":"因为有并发初始化的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603861913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1217952,"avatar":"","nickname":"xueleixi","note":"","ucode":"C2F25B4D1FEF76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318871,"discussion_content":"第一次检测不需要加锁，性能高","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1603870986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1556358,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bf/86/c0cb35f0.jpg","nickname":"8.13.3.27.30","note":"","ucode":"2DE3CE3E338BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535554,"discussion_content":"下面是我的理解: \n先直接回答你的问题,如果直接加锁,从结果上看没有区别,都能实现只做一次\n\n问题在于lock的性能问题,就是上面xueleixi说的,lock可能会导致goroutine休眠\n\n为什么是可能呢\n\nmutex那一章节说过如果lock没有被人占用,那么他就愉快的执行了\n\n如果在做do的时候发现另外一个goruotine正在执行lock,那系统可能就要对不起你了,\n\n你先休息一会,导致goroutine休眠,goroutine休眠是有代价的，cpu会进行上下文的切换,\n\n导致的结果就是上面同学说的性能不高了。\n\n另外,我认为这个lock的目的是为了最开始调用这个do的时候,如果有并发,能保证并发的所有do结束的时候f函数已经被调用完成。之后的do不需要执行函数了也就没必要去做个lock了,做了就会像上面说的一样性能变差\n\n以上个人理解,仅供参考,如有理解问题,望指点\n\n\n\n\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638459252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1556358,"avatar":"https://static001.geekbang.org/account/avatar/00/17/bf/86/c0cb35f0.jpg","nickname":"8.13.3.27.30","note":"","ucode":"2DE3CE3E338BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535557,"discussion_content":"补充一点,老师说的fast path 应该就是这个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638459412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257337,"user_name":"moooofly","can_delete":false,"product_type":"c1","uid":1008348,"ip_address":"","ucode":"4A20795C281B6F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","comment_is_top":false,"comment_ctime":1603940749,"is_pvip":false,"replies":[{"id":"93741","content":"fast path中读取o.done,并没有在mutex保护之下","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604014175,"ip_address":"","comment_id":257337,"utype":1}],"discussion_count":10,"race_medal":0,"score":"23078777229","product_id":100061801,"comment_content":"请教一个问题，在示例代码中有如下片段<br><br>```<br>func (o *Once) doSlow(f func()) {<br>    o.m.Lock()<br>    defer o.m.Unlock()<br>    &#47;&#47; 双检查<br>    if o.done == 0 {<br>        defer atomic.StoreUint32(&amp;o.done, 1)<br>        f()<br>    }<br>}<br>```<br><br>在双检查整改地方，读取 o.done 的值并没有使用使用 atomic.LoadUint32(&amp;o.done) 的方式，按照我的理解，是因为已经处于 o.m.Lock() 的保护下的缘故；那是否 atomic.StoreUint32(&amp;o.done, 1) 也可以直接 o.done = 1 呢？毕竟这个代码也在 o.m.Lock() 的保护下","like_count":5,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508299,"discussion_content":"fast path中读取o.done,并没有在mutex保护之下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604014175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411473,"discussion_content":"moooofly 说的是 「 if o.done == 0 」 这个地方是在 o.m.Lock() 读取的。老师说的：「fast path中读取o.done,并没有在mutex保护之下」是 「atomic.LoadUint32(&amp;o.done)」 没有加锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635936028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055479,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/f7/cb61b37f.jpg","nickname":"Tatum 苏天斌","note":"","ucode":"75F09E6C5FB27B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388611,"discussion_content":"可能这个有用： https://github.com/wisecsj/wisecsj.github.io/issues/25","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628847682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382058,"discussion_content":"同没理解老师的回答，fast path 的读，是指那个读？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625391849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1196531,"avatar":"https://static001.geekbang.org/account/avatar/00/12/41/f3/8bca4aba.jpg","nickname":"普通熊猫 ଘ(੭ˊ꒳​ˋ)੭✧","note":"","ucode":"7FEF9C72B4801B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326053,"discussion_content":"关于这个问题，一直没有找到相关资料的解释","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605507875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319379,"discussion_content":"你这回答的不是我问的问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604019678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1136236,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/6c/042a2e41.jpg","nickname":"David","note":"","ucode":"8277D3CE881053","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339991,"discussion_content":"老师说的没错，是你应该没理解到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609856423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319379,"ip_address":""},"score":339991,"extra":""},{"author":{"id":1157786,"avatar":"https://static001.geekbang.org/account/avatar/00/11/aa/9a/92d2df36.jpg","nickname":"tianfeiyu","note":"","ucode":"E65E6841AD5D7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1136236,"avatar":"https://static001.geekbang.org/account/avatar/00/11/56/6c/042a2e41.jpg","nickname":"David","note":"","ucode":"8277D3CE881053","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387438,"discussion_content":"同没理解老师的意思，希望大佬给详细解释下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628170872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339991,"ip_address":""},"score":387438,"extra":""},{"author":{"id":1368768,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e2/c0/e7a59706.jpg","nickname":"chongsheng","note":"","ucode":"859DF328FCA608","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543996,"discussion_content":"老师回答没问题，只是你没get到点。\n老师的意思是，如果使用defer once.done=1，那么这个修改不会被fast path里的Load观察到，可以用-race测一下会有并发读写问题。\n除非对fast path里获取once.done值也用once.m加锁，根据lock的happens-before原则，才会被fast path观测到。\n都用atomic操作保证了可见性和原子性，就不会有并发问题了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1641376977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319379,"ip_address":""},"score":543996,"extra":""}]}]},{"had_liked":false,"id":257101,"user_name":"Linuxer","can_delete":false,"product_type":"c1","uid":1153978,"ip_address":"","ucode":"272D9D8089C3D6","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/ba/333b59e5.jpg","comment_is_top":false,"comment_ctime":1603852078,"is_pvip":false,"replies":[{"id":"93594","content":"fast path的一个好处是此方法可以内联","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1603862129,"ip_address":"","comment_id":257101,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18783721262","product_id":100061801,"comment_content":"第一个思考题：Linux内核也有很多这种fast code path和slow  code path，我想这样划分是不是内聚性更好，实现更清晰呢,从linux性能分析来看，貌似更多关注点是在slow code path<br>第二个思考题：应该不可以吧，Once的内部状态已经被改变了","like_count":4,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508224,"discussion_content":"fast path的一个好处是此方法可以内联","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603862129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257259,"user_name":"Remember九离","can_delete":false,"product_type":"c1","uid":1237327,"ip_address":"","ucode":"97EE6E6344689F","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","comment_is_top":false,"comment_ctime":1603896804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898864100","product_id":100061801,"comment_content":"一个once,看着就一点代码还能这么玩������，今日份整理：https:&#47;&#47;github.com&#47;wuqinqiang&#47;Go_Concurrency&#47;tree&#47;main&#47;class_8","like_count":1},{"had_liked":false,"id":352684,"user_name":"踢车牛","can_delete":false,"product_type":"c1","uid":1200020,"ip_address":"","ucode":"D6D793EF5314A0","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/94/05044c31.jpg","comment_is_top":false,"comment_ctime":1658880647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658880647","product_id":100061801,"comment_content":"写了一篇文章从介绍了单例模式，也介绍了 sync.once 的又来，感兴趣的可以读一下，保准你有收获<br><br>https:&#47;&#47;juejin.cn&#47;post&#47;7124720007447052302","like_count":0},{"had_liked":false,"id":352371,"user_name":"i_chase","can_delete":false,"product_type":"c1","uid":1795511,"ip_address":"","ucode":"09C41C863F4EA3","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/b7/058276dc.jpg","comment_is_top":false,"comment_ctime":1658590731,"is_pvip":true,"replies":[{"id":"128194","content":"内联整个函数","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1658705707,"ip_address":"","comment_id":352371,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1658590731","product_id":100061801,"comment_content":"还可以只内联函数在doSlow的前的部分吗，一直以为内联是将整个函数内联上去了","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581275,"discussion_content":"内联整个函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658705707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333497,"user_name":"xl666","can_delete":false,"product_type":"c1","uid":2046604,"ip_address":"","ucode":"CF9A8086F91053","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3a/8c/fc2c3e5c.jpg","comment_is_top":false,"comment_ctime":1644387396,"is_pvip":false,"replies":[{"id":"121867","content":"其它goroutine也在等待锁啊，等第一个释放锁后就进来了","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1644401606,"ip_address":"","comment_id":333497,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644387396","product_id":100061801,"comment_content":"‘’这确实是一种实现方式，但是，这个实现有一个很大的问题，就是如果参数 f 执行很慢的话，后续调用 Do 方法的 goroutine 虽然看到 done 已经设置为执行过了，但是获取某些初始化资源的时候可能会得到空的资源，因为 f 还没有执行完。‘’老师我们运行Do初始化的时候 一般加锁保证线程安全 那就就是说 抢到锁的gofunc在初始化fn()没有运行结束时不会释放锁 其他gofunc进不来 所以不会导致上面说的那种情况<br><br>我是这样理解的<br><br>要是初始化不加锁倒是会 ","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550168,"discussion_content":"其它goroutine也在等待锁啊，等第一个释放锁后就进来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644401606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":326868,"user_name":"Bynow","can_delete":false,"product_type":"c1","uid":2735072,"ip_address":"","ucode":"1E4F3ADD65CF18","user_header":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","comment_is_top":false,"comment_ctime":1639727912,"is_pvip":false,"replies":[{"id":"118825","content":"这是unsafe.Pointer常用方法，你可以找这个类型的教程深入了解下","user_name":"作者回复","user_name_real":"编辑","uid":"1066613","ctime":1639806978,"ip_address":"","comment_id":326868,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1639727912","product_id":100061801,"comment_content":"请问：(*uint32)(unsafe.Pointer(&amp;o.Once))  这个表达式为什么会是1？<br>","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539701,"discussion_content":"这是unsafe.Pointer常用方法，你可以找这个类型的教程深入了解下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639806979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309653,"user_name":"斯蒂芬.赵","can_delete":false,"product_type":"c1","uid":1200179,"ip_address":"","ucode":"AA0FF2DA654418","user_header":"https://static001.geekbang.org/account/avatar/00/12/50/33/9dcd30c4.jpg","comment_is_top":false,"comment_ctime":1630291229,"is_pvip":true,"replies":[{"id":"112418","content":"如何修？","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1630589842,"ip_address":"","comment_id":309653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630291229","product_id":100061801,"comment_content":"既然有未初始化错误的问题，为啥官方不去修复它呢","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525948,"discussion_content":"如何修？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630589842,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":302906,"user_name":"Yayu","can_delete":false,"product_type":"c1","uid":1058015,"ip_address":"","ucode":"5E7842458D8229","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","comment_is_top":false,"comment_ctime":1626429249,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626429249","product_id":100061801,"comment_content":"“如果你真的担心这个 package 级别的变量被人修改，你可以不把它们暴露出来，而是提供一个只读的 GetXXX 的方法，这样别人就不会进行修改了。”<br><br>这个方法没法解决全局变量是指针类型或者结构内包含指针类型的变量呀，这种情况又该如何解决呢？","like_count":0},{"had_liked":false,"id":299550,"user_name":"Geek_c0a611","can_delete":false,"product_type":"c1","uid":2398259,"ip_address":"","ucode":"B4E036C6690DBB","user_header":"https://static001.geekbang.org/account/avatar/00/24/98/33/04e9d1a4.jpg","comment_is_top":false,"comment_ctime":1624701247,"is_pvip":false,"replies":[{"id":"108651","content":"这里倒不是控制并发写，而是保证可用性。在intelcpu可能没问题，但是对arm,要保证读取这个flag的时候看到先前的写","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1624764883,"ip_address":"","comment_id":299550,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1624701247","product_id":100061801,"comment_content":"func (a *AnimalStore) Init() {<br>        a.once.Do(func() { <br>            longOperationSetupDbOpenFilesQueuesEtc() <br>             atomic.StoreUint32(&amp;a.inited, 1) <br>        })<br>}<br><br>老师，感觉这里的atomic.StoreUint32是不没必要呀，因为Do在执行f()的时候是已经加了锁的","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522469,"discussion_content":"这里倒不是控制并发写，而是保证可用性。在intelcpu可能没问题，但是对arm,要保证读取这个flag的时候看到先前的写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624764883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1310798,"avatar":"https://static001.geekbang.org/account/avatar/00/14/00/4e/be2b206b.jpg","nickname":"吴小智","note":"","ucode":"C7C9F58B5C9F7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382220,"discussion_content":"https://colobu.com/2021/05/05/triple-gates-of-sync-Once/#more","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625477321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275735,"user_name":"Panda","can_delete":false,"product_type":"c1","uid":1095740,"ip_address":"","ucode":"911A200C7B18BE","user_header":"https://static001.geekbang.org/account/avatar/00/10/b8/3c/1a294619.jpg","comment_is_top":false,"comment_ctime":1611654642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611654642","product_id":100061801,"comment_content":"一旦你遇到只需要初始化一次的场景，首先想到的就应该是 Once 并发原语。","like_count":0},{"had_liked":false,"id":272668,"user_name":"K菌无惨","can_delete":false,"product_type":"c1","uid":2194764,"ip_address":"","ucode":"97A532D588FD49","user_header":"","comment_is_top":false,"comment_ctime":1610196036,"is_pvip":false,"replies":[{"id":"98836","content":"不会","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1610239541,"ip_address":"","comment_id":272668,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1610196036","product_id":100061801,"comment_content":"鸟窝老师,我之前单例模式的时候说double-checking机制可能会由于cpu对代码语句执行顺序的优化导致双检查机制失败,我想知道sync.Once里面的双检查机制会出现同样的情况吗","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513347,"discussion_content":"不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610239541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":268961,"user_name":"( ･᷄ὢ･᷅ )","can_delete":false,"product_type":"c1","uid":2234129,"ip_address":"","ucode":"E5F5EDEBB74C46","user_header":"https://static001.geekbang.org/account/avatar/00/22/17/11/a63acc6a.jpg","comment_is_top":false,"comment_ctime":1608450430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608450430","product_id":100061801,"comment_content":"1.slow 为了内联<br>2.不能复制 once里面有mutex 这玩意本身就不能复制","like_count":0},{"had_liked":false,"id":263399,"user_name":"假期","can_delete":false,"product_type":"c1","uid":2226920,"ip_address":"","ucode":"CF6464E859E1F2","user_header":"https://static001.geekbang.org/account/avatar/00/21/fa/e8/45211b5a.jpg","comment_is_top":false,"comment_ctime":1606124604,"is_pvip":false,"replies":[{"id":"95570","content":"其它goroutine看到的可能是这样的","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1606132851,"ip_address":"","comment_id":263399,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1606124604","product_id":100061801,"comment_content":"func (o *Once) doSlow(f func()) {<br>    o.m.Lock()<br>    defer o.m.Unlock()<br>    &#47;&#47; 双检查<br>    if o.done == 0 {<br>        defer atomic.StoreUint32(&amp;o.done, 1)<br>        f()<br>    }<br>}<br><br>老师你好，我看了一些内存模型资料之后想问，<br>defer atomic.StoreUint32(&amp;o.done, 1)这一行如果换成o.done = 1 的话是不是不能保证<br>o.done=1 和 f()的执行顺序 ？<br>","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510172,"discussion_content":"其它goroutine看到的可能是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606132851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1265260,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4e/6c/71020c59.jpg","nickname":"王麒","note":"","ucode":"330017C5A911B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369561,"discussion_content":"这里不是加锁了吗。。为什么不能保证？ 加锁了为啥还要用原子操作呢。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1619079185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257565,"user_name":"悦悦","can_delete":false,"product_type":"c1","uid":1032388,"ip_address":"","ucode":"7D20EFCFC0546C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/c4/3f7b5eed.jpg","comment_is_top":false,"comment_ctime":1604028735,"is_pvip":false,"replies":[{"id":"93803","content":"看go内存模型。需要保证happen-before关系","user_name":"作者回复","user_name_real":"鸟窝","uid":"1066613","ctime":1604034602,"ip_address":"","comment_id":257565,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1604028735","product_id":100061801,"comment_content":"package sync_once<br><br>import (<br>\t&quot;sync&quot;<br>)<br><br>type Once struct {<br>\tdone uint32<br>\tm    sync.Mutex<br>}<br><br>func (o *Once) Do(f func()) {<br>\t&#47;&#47;if atomic.LoadUint32(&amp;o.done) == 0 {<br>\t&#47;&#47;\to.doSlow(f)<br>\t&#47;&#47;}<br><br>\tif o.done == 0 {<br>\t\to.doSlow(f)<br>\t}<br>}<br><br>func (o *Once) doSlow(f func()) {<br>\to.m.Lock()<br>\tdefer o.m.Unlock()<br>\t&#47;&#47; 双检查<br>\tif o.done == 0 {<br>\t\t&#47;&#47;defer atomic.StoreUint32(&amp;o.done, 1)<br>\t\tdefer func() { o.done = 1 }()<br>\t\tf()<br>\t}<br>}<br><br><br>与不使用atomic有什么区别","like_count":0,"discussions":[{"author":{"id":1066613,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/75/d35c7623.jpg","nickname":"鸟窝","note":"","ucode":"E49D44F9613F17","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508377,"discussion_content":"看go内存模型。需要保证happen-before关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604034602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008348,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/62/dc/8876c73b.jpg","nickname":"moooofly","note":"","ucode":"4A20795C281B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320159,"discussion_content":"这个地方确实没弄明白，另外老师的解释也不是很明白，咋整","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604279864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1207372,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6c/4c/d87bb144.jpg","nickname":"Geek_771dd0","note":"","ucode":"FC8F77F7D75EE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331673,"discussion_content":"除了不能保证happens before，应该还有竞态问题吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606924983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257510,"user_name":"gitxuzan","can_delete":false,"product_type":"c1","uid":1081566,"ip_address":"","ucode":"B0E20F892DA716","user_header":"https://static001.geekbang.org/account/avatar/00/10/80/de/c6191045.jpg","comment_is_top":false,"comment_ctime":1604017882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604017882","product_id":100061801,"comment_content":"第二个坑前几天就采了，从数据库拉一份缓存，结果刚好数据库重启，导致初始化失败了，后面改成 == nil，最多是不是那一刻并发执行了，因为是缓存数据问题不大，是不是如果单实例没加锁就不能用 nil这么判断？","like_count":0},{"had_liked":false,"id":257341,"user_name":"fsyyft","can_delete":false,"product_type":"c1","uid":1348727,"ip_address":"","ucode":"AF966553B607BB","user_header":"","comment_is_top":false,"comment_ctime":1603941489,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603941489","product_id":100061801,"comment_content":"这样扩展是否可以？<br><br>type (<br>\tOnceDo interface {<br>\t\tDoOnce(p ...interface{}) (interface{}, error)<br>\t}<br><br>\tOnceFunc func(p ...interface{}) (interface{}, error)<br>)<br><br>func (o OnceFunc) DoOnce(p ...interface{}) (interface{}, error) {<br>\treturn o(p)<br>}<br><br>type (<br>\tOnce struct {<br>\t\tdone uint32<br>\t\tm    sync.Mutex<br>\t}<br>)<br><br>func (o *Once) Do(i OnceDo, p ...interface{}) (interface{}, error) {<br>\treturn o.DoFunc(i.DoOnce, p)<br>}<br><br>func (o *Once) DoFunc(f OnceFunc, p ...interface{}) (interface{}, error) {<br>\tvar v interface{}<br>\tvar err error<br><br>\tif atomic.LoadUint32(&amp;o.done) == 0 {<br>\t\tv, err = o.doSlow(f, p)<br>\t}<br><br>\treturn v, err<br>}<br><br>func (o *Once) Done() bool {<br>\treturn atomic.LoadUint32(&amp;o.done) == 1<br>}<br><br>func (o *Once) doSlow(f OnceFunc, p ...interface{}) (interface{}, error) {<br>\to.m.Lock()<br>\tdefer o.m.Unlock()<br><br>\tvar v interface{}<br>\tvar err error<br><br>\t&#47;&#47; 已经加锁了，可以不需要使用 atomic.LoadUint32(&amp;o.done) == 0 判断。<br>\tif o.done == 0 {<br>\t\tdefer func() {<br>\t\t\tif r := recover(); nil != r {<br>\t\t\t\t&#47;&#47; 如果出现 panic 了，recover 后，继续向外抛出。<br>\t\t\t\tpanic(r)<br>\t\t\t} else if nil == err {<br>\t\t\t\t&#47;&#47; 没有异常时，才设置完成。<br>\t\t\t\tatomic.StoreUint32(&amp;o.done, 1)<br>\t\t\t}<br>\t\t}()<br>\t\tv, err = f(p)<br>\t}<br><br>\treturn v, err<br>}","like_count":0},{"had_liked":false,"id":257161,"user_name":"大漠胡萝卜","can_delete":false,"product_type":"c1","uid":1198953,"ip_address":"","ucode":"FBE51E4A13EF4F","user_header":"https://static001.geekbang.org/account/avatar/00/12/4b/69/c02eac91.jpg","comment_is_top":false,"comment_ctime":1603867717,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603867717","product_id":100061801,"comment_content":"```go<br>atomic.LoadUint32((*uint32)(unsafe.Pointer(&amp;o.Once))) == 1<br>```<br>这个是怎么判断执行完的呢","like_count":0,"discussions":[{"author":{"id":1237327,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/4f/00476b4c.jpg","nickname":"Remember九离","note":"","ucode":"97EE6E6344689F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318990,"discussion_content":"可以回头看看Mutex那几篇，能找到你的答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603896613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257109,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1603852736,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1603852736","product_id":100061801,"comment_content":"slowXXXX 的方法，从 XXXX 方法中单独抽取出来，是为了优化代码，方便内联","like_count":0},{"had_liked":false,"id":257103,"user_name":"🍀柠檬鱼也是鱼","can_delete":false,"product_type":"c1","uid":2178501,"ip_address":"","ucode":"DCF033636465F3","user_header":"https://static001.geekbang.org/account/avatar/00/21/3d/c5/f43fa619.jpg","comment_is_top":false,"comment_ctime":1603852205,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603852205","product_id":100061801,"comment_content":"噢噢理解了，呜呜，双重检测是为了避免重复执行f()","like_count":0,"discussions":[{"author":{"id":2735072,"avatar":"https://static001.geekbang.org/account/avatar/00/29/bb/e0/c7cd5170.jpg","nickname":"Bynow","note":"","ucode":"1E4F3ADD65CF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539490,"discussion_content":"我觉得主要还是因为锁对性能的消耗太大，你看可以假设没有第一层检查，然后 goroutine 并发时都要先拿到锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639728608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257042,"user_name":"橙子888","can_delete":false,"product_type":"c1","uid":1447790,"ip_address":"","ucode":"8FB8A9AAE526E3","user_header":"https://static001.geekbang.org/account/avatar/00/16/17/6e/76b4aa3d.jpg","comment_is_top":false,"comment_ctime":1603843480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603843480","product_id":100061801,"comment_content":"打卡。","like_count":0}]}