{"id":491021,"title":"19 | Channel：为什么说Channel是“热”的？","content":"<p>你好，我是朱涛。</p><p>前面我们学习的挂起函数、async，它们一次都只能返回一个结果。但在某些业务场景下，我们往往需要协程返回多个结果，比如微信等软件的IM通道接收的消息，或者是手机GPS定位返回的经纬度坐标需要实时更新。那么，在这些场景下，我们之前学习的协程知识就无法直接解决了。</p><p>而今天我要讲解的Kotlin协程中的Channel，就是专门用来做这种事情的。类似的需求，如果我们不使用Channel而是用其他的并发手段配合集合来做的话，其实也能实现，但复杂度会大大增加。那么接下来，我们就一起来学习下Channel。</p><h2>Channel就是管道</h2><p>顾名思义，Channel就是一个管道。我们可以用这个概念，先来建立一个思维模型：</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/e7/6e3884f46932e80f080191d20cc26be7.gif?wh=1080x270\" alt=\"\"></p><p>Channel这个管道的其中一端，是发送方；管道的另一端是接收方。而管道本身，则可以用来传输数据。</p><p>所以，我们根据上面的思维模型，很容易就能写出下面的代码。</p><pre><code class=\"language-plain\">// 代码段1\n\nfun main() = runBlocking {\n    // 1，创建管道\n    val channel = Channel&lt;Int&gt;()\n\n    launch {\n        // 2，在一个单独的协程当中发送管道消息\n        (1..3).forEach {\n            channel.send(it) // 挂起函数\n            logX(\"Send: $it\")\n        }\n    }\n\n    launch {\n        // 3，在一个单独的协程当中接收管道消息\n        for (i in channel) {  // 挂起函数\n            logX(\"Receive: $i\")\n        }\n    }\n\n    logX(\"end\")\n}\n\n/*\n================================\nend\nThread:main @coroutine#1\n================================\n================================\nReceive: 1\nThread:main @coroutine#3\n================================\n================================\nSend: 1\nThread:main @coroutine#2\n================================\n================================\nSend: 2\nThread:main @coroutine#2\n================================\n================================\nReceive: 2\nThread:main @coroutine#3\n================================\n================================\nReceive: 3\nThread:main @coroutine#3\n================================\n================================\nSend: 3\nThread:main @coroutine#2\n================================\n// 4，程序不会退出\n*/\n</code></pre><!-- [[[read_end]]] --><p>通过运行的结果，我们首先可以看到的就是：coroutine#2、coroutine#3，这两个协程是交替执行的。这段代码，其实和我们<a href=\"https://time.geekbang.org/column/article/485632\">第13讲</a>当中提到的“互相协作”的模式是类似的，两个协程会轮流执行。</p><p>我们还可以看出来，Channel可以跨越不同的协程进行通信。我们是在“coroutine#1”当中创建的Channel，然后分别在coroutine#2、coroutine#3当中使用Channel来传递数据。</p><p>另外在代码中，还有四个注释，我们一个个来看：</p><ul>\n<li>注释1，我们通过“Channel()”这样的方式，就可以创建一个管道。其中传入的泛型Int，就代表了这个管道里面传递的数据类型。也就是说这里创建的Channel，就是用于传递Int数据的。</li>\n<li>注释2，我们创建了一个新的协程，然后在协程当中调用了send()方法，发送数据到管道里。其中的send()方法是一个挂起函数。</li>\n<li>注释3，在另一个协程当中，我们通过遍历channel，将管道当中的数据都取了出来。这里，我们使用的是for循环。</li>\n<li>注释4，通过运行结果，我们还可以发现一个细节，那就是程序在输出完所有的结果以后，并不会退出。主线程不会结束，整个程序还会处于运行状态。</li>\n</ul><p>而如果要解决上面的问题，其实也不难，只需要加上一行代码即可：</p><pre><code class=\"language-plain\">// 代码段2\n\nfun main() = runBlocking {\n    val channel = Channel&lt;Int&gt;()\n\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n            logX(\"Send: $it\")\n        }\n\n        channel.close() // 变化在这里\n    }\n\n    launch {\n        for (i in channel) {\n            logX(\"Receive: $i\")\n        }\n    }\n\n    logX(\"end\")\n}\n</code></pre><p>所以，channel其实也是一种<strong>协程资源</strong>，在用完channel以后，如果我们不去主动关闭它的话，是会造成不必要的资源浪费的。在上面的案例中，如果我们忘记调用“channel.close()”，程序将永远不会停下来。</p><p>现在，我们来看看创建Channel的源代码。</p><pre><code class=\"language-plain\">// 代码段3\n\npublic fun &lt;E&gt; Channel(\n    capacity: Int = RENDEZVOUS,\n    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND,\n    onUndeliveredElement: ((E) -&gt; Unit)? = null\n): Channel&lt;E&gt; {}\n</code></pre><p>可以看到，当我们调用“Channel()”的时候，感觉像是在调用一个构造函数，但实际上它却只是一个普通的顶层函数。这个函数带有一个泛型参数E，另外还有三个参数。</p><p>第一个参数，<strong>capacity</strong>，代表了管道的容量。这个也很好理解，我们日常生活中的管道，自身也是有容量的，即使接收方不将数据取走，管道本身也可以存储一些数据。而Kotlin的Channel，在默认情况下是“RENDEZVOUS”，也就代表了Channel的容量为0。</p><blockquote>\n<p>题外话：RENDEZVOUS这个单词源自法语。它有约会、碰面的意思，我们可以理解为“发送方、接收方，不见不散”。</p>\n</blockquote><p>除此之外，capacity还有其他几种情况，比如说：</p><ul>\n<li>UNLIMITED，代表了无限容量；</li>\n<li>CONFLATED，代表了容量为1，新的数据会替代旧的数据；</li>\n<li>BUFFERED，代表了具备一定的缓存容量，默认情况下是64，具体容量由这个VM参数决定 <code>\"kotlinx.coroutines.channels.defaultBuffer\"</code>。</li>\n</ul><p>第二个参数，<strong>onBufferOverflow</strong>，也就是指当我们指定了capacity的容量，等管道的容量满了时，Channel的应对策略是怎么样的。这里，它主要有三种做法：</p><ul>\n<li>SUSPEND，当管道的容量满了以后，如果发送方还要继续发送，我们就会挂起当前的send()方法。由于它是一个挂起函数，所以我们可以以非阻塞的方式，将发送方的执行流程<strong>挂起</strong>，等管道中有了空闲位置以后再<strong>恢复</strong>。</li>\n<li>DROP_OLDEST，顾名思义，就是丢弃最旧的那条数据，然后发送新的数据；</li>\n<li>DROP_LATEST，丢弃最新的那条数据。这里要注意，这个动作的含义是丢弃当前正准备发送的那条数据，而管道中的内容将维持不变。</li>\n</ul><p>由于这部分有点抽象，我画了一张图，来描述上面的几种模式，你可以看看。</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/9a/7f3e49c72caf6e12cafb79fb6affc69a.jpg?wh=2000x1125\" alt=\"\"></p><p>在创建Channel的方法中，还有第三个参数，<strong>onUndeliveredElement</strong>，它其实相当于一个异常处理回调。当管道中的某些数据没有被成功接收的时候，这个回调就会被调用。</p><p>这里，为了让你对这三个参数有个更具体的认识，我们来看几个代码的案例。</p><p>案例1：capacity = UNLIMITED</p><pre><code class=\"language-plain\">// 代码段4\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel = Channel&lt;Int&gt;(capacity = Channel.Factory.UNLIMITED)\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n            println(\"Send: $it\")\n        }\n        channel.close() // 变化在这里\n    }\n    launch {\n        for (i in channel) {\n            println(\"Receive: $i\")\n        }\n    }\n    println(\"end\")\n}}\n\n/*\n输出结果：\nend\nSend: 1\nSend: 2\nSend: 3\nReceive: 1\nReceive: 2\nReceive: 3\n*/\n</code></pre><p>以上代码对比代码段1，其实只改动了一点点。我们在创建Channel的时候，设置了 <code>capacity = Channel.Factory.UNLIMITED</code>。不过，通过分析运行的结果，可以发现代码的运行顺序就跟之前完全不一样了。</p><p>对于发送方来说，由于Channel的容量是无限大的，所以发送方可以一直往管道当中塞入数据，等数据都塞完以后，接收方才开始接收。这跟之前的交替执行是不一样的。</p><p>好，接下来我们看看capacity = CONFLATED的情况。</p><pre><code class=\"language-plain\">// 代码段5\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel = Channel&lt;Int&gt;(capacity = Channel.Factory.CONFLATED)\n\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n            println(\"Send: $it\")\n        }\n\n        channel.close()\n    }\n\n    launch {\n        for (i in channel) {\n            println(\"Receive: $i\")\n        }\n    }\n\n    println(\"end\")\n}\n\n/*\n输出结果：\nend\nSend: 1\nSend: 2\nSend: 3\nReceive: 3\n*/\n</code></pre><p>可以看到，当设置capacity = CONFLATED的时候，发送方也会一直发送数据，而且，对于接收方来说，它永远只能接收到最后一条数据。</p><p>我们再来看看onBufferOverflow的用法。其实，我们可以运用onBufferOverflow与capacity，来实现CONFLATED的效果。</p><pre><code class=\"language-plain\">// 代码段6\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel = Channel&lt;Int&gt;(\n        capacity = 1,\n        onBufferOverflow = BufferOverflow.DROP_OLDEST\n    )\n\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n            println(\"Send: $it\")\n        }\n\n        channel.close()\n    }\n\n    launch {\n        for (i in channel) {\n            println(\"Receive: $i\")\n        }\n    }\n\n    println(\"end\")\n}\n\n/*\n输出结果：\nend\nSend: 1\nSend: 2\nSend: 3\nReceive: 3\n*/\n</code></pre><p>从这个运行结果里，我们就可以看出来，其实 <code>capacity = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST</code>，就代表了capacity = CONFLATED。</p><p>对应的，我们再来看看 <code>onBufferOverflow = BufferOverflow.DROP_LATEST</code> 的情况。</p><pre><code class=\"language-plain\">// 代码段7\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel = Channel&lt;Int&gt;(\n        capacity = 3,\n        onBufferOverflow = BufferOverflow.DROP_LATEST\n    )\n\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n            println(\"Send: $it\")\n        }\n\n        channel.send(4) // 被丢弃\n        println(\"Send: 4\")\n        channel.send(5) // 被丢弃\n        println(\"Send: 5\") \n\n        channel.close()\n    }\n\n    launch {\n        for (i in channel) {\n            println(\"Receive: $i\")\n        }\n    }\n\n    println(\"end\")\n}\n\n/*\n输出结果：\nend\nSend: 1\nSend: 2\nSend: 3\nSend: 4\nSend: 5\nReceive: 1\nReceive: 2\nReceive: 3\n*/\n</code></pre><p>由此可见，<code>onBufferOverflow = BufferOverflow.DROP_LATEST</code> 就意味着，当Channel容量满了以后，之后再继续发送的内容，就会直接被丢弃。</p><p>最后，我们来看看onUndeliveredElement这个参数的作用。</p><pre><code class=\"language-plain\">// 代码段8\n\nfun main() = runBlocking {\n    // 无限容量的管道\n    val channel = Channel&lt;Int&gt;(Channel.UNLIMITED) {\n        println(\"onUndeliveredElement = $it\")\n    }\n\n    // 等价这种写法\n//    val channel = Channel&lt;Int&gt;(Channel.UNLIMITED, onUndeliveredElement = { println(\"onUndeliveredElement = $it\") })\n\n    // 放入三个数据\n    (1..3).forEach {\n        channel.send(it)\n    }\n\n    // 取出一个，剩下两个\n    channel.receive()\n\n    // 取消当前channel\n    channel.cancel()\n}\n\n/*\n输出结果：\nonUndeliveredElement = 2\nonUndeliveredElement = 3\n*/\n</code></pre><p>可以看到，onUndeliveredElement的作用，就是一个回调，当我们发送出去的Channel数据无法被接收方处理的时候，就可以通过onUndeliveredElement这个回调，来进行监听。</p><p>它的使用场景一般都是用于“接收方对数据是否被消费特别关心的场景”。比如说，我发送出去的消息，接收方是不是真的收到了？对于接收方没收到的信息，发送方就可以灵活处理了，比如针对这些没收到的消息，发送方可以先记录下来，等下次重新发送。</p><h2>Channel关闭引发的问题</h2><p>在前面提到的代码段1里，由于我们忘记调用了close()，所以会导致程序一直运行无法终止。这个问题其实是很严重的。我们有没有办法避免这个问题呢？</p><p>当然是有的。Kotlin官方其实还为我们提供了另一种创建Channel的方式，也就是 <strong>produce{} 高阶函数</strong>。</p><pre><code class=\"language-plain\">// 代码段9\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel: ReceiveChannel&lt;Int&gt; = produce {\n        (1..3).forEach {\n            send(it)\n            logX(\"Send: $it\")\n        }\n    }\n\n    launch {\n        // 3，接收数据\n        for (i in channel) {\n            logX(\"Receive: $i\")\n        }\n    }\n\n    logX(\"end\")\n}\n</code></pre><p>以上代码中，我们使用produce{} 以后，就不用再去调用close()方法了，因为produce{} 会自动帮我们去调用close()方法。具体的源码，我们会在源码篇的时候再去深入分析。不过，现在我们也可以通过代码来验证这一点。</p><pre><code class=\"language-plain\">// 代码段10\n\nfun main() = runBlocking {\n    // 1，创建管道\n    val channel: ReceiveChannel&lt;Int&gt; = produce {\n        // 发送3条数据\n        (1..3).forEach {\n            send(it)\n        }\n    }\n\n    // 调用4次receive()\n    channel.receive() // 1\n    channel.receive() // 2\n    channel.receive() // 3\n    channel.receive() // 异常\n\n    logX(\"end\")\n}\n\n/*\n输出结果：\nClosedReceiveChannelException: Channel was closed\n*/\n</code></pre><p>在前面所有的代码当中，我们都是以for循环来迭代channel当中的元素的，但实际上，channel还有一个 <strong>receive()方法</strong>，它是与send(it)对应的。在上面代码中，我们只调用了3次send()，却调用4次receive()。</p><p>当我们第4次调用receive()的时候，代码会抛出异常“ClosedReceiveChannelException”，这其实也代表：我们的Channel已经被关闭了。所以这也就说明了，produce {}确实会帮我们调用close()方法。不然的话，第4次receive()会被挂起，而不是抛出异常。</p><p>我们可以再写一段代码来验证下：</p><pre><code class=\"language-plain\">// 代码段11\n\nfun main() = runBlocking {\n    val channel: Channel&lt;Int&gt; = Channel()\n\n    launch {\n        (1..3).forEach {\n            channel.send(it)\n        }\n    }\n\n    // 调用4次receive()\n    channel.receive()       // 1\n    println(\"Receive: 1\")\n    channel.receive()       // 2\n    println(\"Receive: 2\")\n    channel.receive()       // 3\n    println(\"Receive: 3\")\n    channel.receive()       // 永远挂起\n\n    logX(\"end\")\n}\n\n/*\n输出结果\nReceive: 1\nReceive: 2\nReceive: 3\n*/\n</code></pre><p>可见，第4次调用receive()，就会导致程序被永久挂起，后面的 <code>logX(\"end\")</code> 是没有机会继续执行的。也就是说，我们<strong>直接使用receive()是很容易出问题的</strong>。这也是我在前面的代码中一直使用for循环，而没有用receive()的原因。</p><p>那么，有没有办法解决这个问题呢？如果你足够细心的话，你会发现Channel其实还有两个属性：isClosedForReceive、isClosedForSend。</p><p>这两个属性，就可以用来判断当前的Channel是否已经被关闭。由于Channel分为发送方和接收方，所以这两个参数也是针对这两者的。也就是说，对于发送方，我们可以使用“isClosedForSend”来判断当前的Channel是否关闭；对于接收方来说，我们可以用“isClosedForReceive”来判断当前的Channel是否关闭。</p><p>这时候，你也许就会想到用它们来改造前面的代码段10。</p><pre><code class=\"language-plain\">// 代码段12\n\nfun main() = runBlocking {\n    // 1，创建管道\n    val channel: ReceiveChannel&lt;Int&gt; = produce {\n        // 发送3条数据\n        (1..3).forEach {\n            send(it)\n            println(\"Send $it\")\n        }\n    }\n\n    // 使用while循环判断isClosedForReceive\n    while (!channel.isClosedForReceive) {\n        val i = channel.receive()\n        println(\"Receive $i\")\n    }\n\n    println(\"end\")\n}\n\n/*\n输出结果\nSend 1\nReceive 1\nReceive 2\nSend 2\nSend 3\nReceive 3\nend\n*/\n</code></pre><p>以上代码看起来是可以正常工作了。但是，我仍然不建议你用这种方式。<strong>因为，当你为管道指定了capacity以后，以上的判断方式将会变得不可靠</strong>！原因是目前的1.6.0版本的协程库，运行这样的代码会崩溃，如下所示：</p><pre><code class=\"language-plain\">// 代码段13\n\nfun main() = runBlocking {\n    // 变化在这里\n    val channel: ReceiveChannel&lt;Int&gt; = produce(capacity = 3) {\n        // 变化在这里\n        (1..300).forEach {\n            send(it)\n            println(\"Send $it\")\n        }\n    }\n\n\n\n    while (!channel.isClosedForReceive) {\n        val i = channel.receive()\n        println(\"Receive $i\")\n    }\n\n    logX(\"end\")\n}\n\n/*\n输出结果\n// 省略部分\nReceive 300\nSend 300\nClosedReceiveChannelException: Channel was closed\n*/\n</code></pre><p>所以，<strong>最好不要用channel.receive()</strong>。即使配合isClosedForReceive这个判断条件，我们直接调用channel.receive()仍然是一件非常危险的事情！</p><p>实际上，以上代码除了可以使用for循环以外，还可以使用Kotlin为我们提供的另一个高阶函数：<strong>channel.consumeEach {}</strong>。我们再来看一个例子：</p><pre><code class=\"language-plain\">// 代码段14\n\nfun main() = runBlocking {\n    val channel: ReceiveChannel&lt;Int&gt; = produce(capacity = 3) {\n        (1..300).forEach {\n            send(it)\n            println(\"Send $it\")\n        }\n    }\n\n    // 变化在这里\n    channel.consumeEach {\n        println(\"Receive $it\")\n    }\n\n    logX(\"end\")\n}\n\n/*\n输出结果：\n\n正常\n*/\n</code></pre><p>所以，当我们想要读取Channel当中的数据时，我们一定要使用for循环，或者是channel.consumeEach {}，千万不要直接调用channel.receive()。</p><blockquote>\n<p>补充：在某些特殊场景下，如果我们必须要自己来调用channel.receive()，那么可以考虑使用receiveCatching()，它可以防止异常发生。</p>\n</blockquote><h2>为什么说Channel是“热”的？</h2><p>我们现在已经知道了，Channel其实就是用来传递“数据流”的。注意，这里的数据流，指的是<strong>多个数据组合形成的流</strong>。前面挂起函数、async返回的数据，就像是水滴一样，而Channel则像是自来水管当中的水流一样。</p><p>在业界一直有一种说法：Channel是“热”的。也是因为这句话，在Kotlin当中，我们也经常把Channel称为“热数据流”。</p><p>这话我们乍一听，可能会有点懵。我们能直接把Channel想象成“热的自来水”吗？当然不能了。所以，为了对Channel的“热”有一个更具体的概念，我们可以来看一段代码：</p><pre><code class=\"language-plain\">// 代码段15\n\nfun main() = runBlocking {\n    // 只发送不接受\n    val channel = produce&lt;Int&gt;(capacity = 10) {\n        (1..3).forEach {\n            send(it)\n            println(\"Send $it\")\n        }\n    }\n\n    println(\"end\")\n}\n\n/*\n输出结果：\nend\nSend 1\nSend 2\nSend 3\n程序结束\n*/\n</code></pre><p>在上面的代码中，我们定义了一个Channel，管道的容量是10，然后我们发送了3个数据。但你是否注意到了，在代码中并没有消费Channel当中的数据。所以，这种“<strong>不管有没有接收方，发送方都会工作</strong>”的模式，就是我们将其认定为“热”的原因。</p><p>这就有点像是一个热心的饭店服务员，不管你有没有提要求，服务员都会给你端茶送水，把茶水摆在你的饭桌上。当你想要喝水的时候，就可以直接从饭桌上拿了（当你想要数据的时候，就可以直接从管道里取出来了）。</p><p>又或者，你可以接着前面的水龙头的思维模型去思考，Channel的发送方，其实就像是“自来水厂”，不管你是不是要用水，自来水厂都会把水送到你家门口的管道当中来。这样当你想要用水的时候，打开水龙头就会马上有水了。</p><p><img src=\"https://static001.geekbang.org/resource/image/df/bf/dfe483ec08baa56c7f5cf937fb93b7bf.jpg?wh=2000x646\" alt=\"\"></p><p>不过，也许你会想，是不是因为前面的代码中，设置了“capacity = 10”的原因？如果设置成“capacity = 0”，那Channel的发送方是不是就不会主动工作了？让我们来试试。</p><pre><code class=\"language-plain\">// 代码段16\n\nfun main() = runBlocking {\n    val channel = produce&lt;Int&gt;(capacity = 0) {\n        (1..3).forEach {\n            println(\"Before send $it\")\n            send(it)\n            println(\"Send $it\")\n        }\n    }\n\n    println(\"end\")\n}\n\n/*\n输出结果：\nend\nBefour send 1\n程序将无法退出\n*/\n</code></pre><p>当我们把capacity改成0以后，可以看到Channel的发送方仍然是会工作的，只是说，在它调用send()方法的时候，由于接收方还未就绪，且管道容量为0，所以它会被挂起。所以，它仍然还是有在工作的。最直接的证据就是：<strong>这个程序将无法退出，一直运行下去</strong>。这个后果是不是更加严重？</p><p>但是，总的来说，不管接收方是否存在，Channel的发送方一定会工作。对应的，你可以想象成：虽然你的饭桌已经没有空间了，但服务员还是端来了茶水站在了你旁边，只是没有把茶水放在你桌上，等饭桌有了空间，或者你想喝水了，你就能马上喝到。</p><p>至于自来水的那个场景，你可以想象成，你家就在自来水厂的门口，你们之间的管道容量为0，但这并不意味着自来水厂没有工作。</p><h2>思考与实战</h2><p>其实，如果你去看Channel的源代码定义，你会发现，Channel本身只是一个接口。</p><pre><code class=\"language-plain\">// 代码段17\n\npublic interface Channel&lt;E&gt; : SendChannel&lt;E&gt;, ReceiveChannel&lt;E&gt; {}\n</code></pre><p>而且，Channel本身并没有什么方法和属性，它其实只是SendChannel、ReceiveChannel这两个接口的组合。也就是说，Channel的所有能力，都是来自于SendChannel、ReceiveChannel这两个接口。</p><pre><code class=\"language-plain\">// 代码段18\n\npublic interface SendChannel&lt;in E&gt; \n    public val isClosedForSend: Boolean\n\n    public suspend fun send(element: E)\n\n    // 1，select相关\n    public val onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt;\n\n    // 2，非挂起函数的接收\n    public fun trySend(element: E): ChannelResult&lt;Unit&gt;\n\n    public fun close(cause: Throwable? = null): Boolean\n\n    public fun invokeOnClose(handler: (cause: Throwable?) -&gt; Unit)\n\n}\n\npublic interface ReceiveChannel&lt;out E&gt; {\n\n    public val isClosedForReceive: Boolean\n\n    public val isEmpty: Boolean\n\n    public suspend fun receive(): E\n\n    public suspend fun receiveCatching(): ChannelResult&lt;E&gt;\n    // 3，select相关\n    public val onReceive: SelectClause1&lt;E&gt;\n    // 4，select相关\n    public val onReceiveCatching: SelectClause1&lt;ChannelResult&lt;E&gt;&gt;\n\n    // 5，非挂起函数的接收\n    public fun tryReceive(): ChannelResult&lt;E&gt;\n\n    public operator fun iterator(): ChannelIterator&lt;E&gt;\n\n    public fun cancel(cause: CancellationException? = null)\n}\n</code></pre><p>在上面的源码中，大部分的接口我们其实已经见过了。只有5个我们还没见过：</p><ul>\n<li>注释1、3、4，它们是跟select相关的，我们会在第21讲介绍。</li>\n<li>注释2、5，是专门为非协程环境提供的API，也就是说，当我们不在协程作用域的时候，也可以调用这两个方法来操作Channel。不过大部分情况下，我们都应该优先使用挂起函数版本的API。</li>\n</ul><p>所以，如果说Channel是一个管道，那么SendChannel、ReceiveChannel就是组成这个管道的两个零件。</p><p><img src=\"https://static001.geekbang.org/resource/image/80/6c/8033b2962552e1f49b2c46e38a94256c.jpg?wh=2000x768\" alt=\"\"></p><p>还记得我们在之前<a href=\"https://time.geekbang.org/column/article/484631\">不变性思维</a>当中提到的，对外暴露不变性集合的思路吗？其实对于Channel来说，我们也可以做到类似的事情。</p><pre><code class=\"language-plain\">// 代码段19\n\nclass ChannelModel {\n    // 对外只提供读取功能\n    val channel: ReceiveChannel&lt;Int&gt; by ::_channel\n    private val _channel: Channel&lt;Int&gt; = Channel()\n\n    suspend fun init() {\n        (1..3).forEach {\n            _channel.send(it)\n        }\n    }\n}\n\nfun main() = runBlocking {\n    val model = ChannelModel()\n    launch {\n        model.init()\n    }\n\n    model.channel.consumeEach {\n        println(it)\n    }\n}\n</code></pre><p>也就是对于Channel来说，它的send()就相当于集合的写入API，当我们想要做到“对写入封闭，对读取开放”的时候，就可以用之前学过的知识轻松做到。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/53/6dfd13fb26053246662abeb692b00d53.jpg?wh=2000x1125\" alt=\"\"></p><p>而这一切，都得益于Channel的能力都是通过“组合”得来的。</p><h2>小结</h2><p>这节课的内容就到这里，我们来总结一下。</p><ul>\n<li>Channel是一个<strong>管道</strong>，当我们想要用协程传递多个数据组成的流的话，就没办法通过挂起函数、async来实现了。这时候，Channel是一个不错的选择。</li>\n<li>我们可以通过<strong>Channel()</strong>这个顶层函数来创建Channel管道。在创建Channel的时候，有三个重要参数：capacity代表了容量；onBufferOverflow代表容量满了以后的应对策略；onUndeliveredElement则是一个异常回调。在某些场景下，比如“<strong>发送方对于数据是否被接收方十分关心</strong>”的情况下，可以注册这个回调。</li>\n<li>Channel有两个关键的方法：send()、receive()，前者用于发送管道数据，后者用于接收管道数据。但是，由于Channel是存在关闭状态的，如果我们直接使用receive()，就会导致各种问题。因此，对于管道数据的接收方来说，我们应该尽可能地使用for循环、consumeEach {}。</li>\n<li>Channel是“热”的。这是因为“<strong>不管有没有接收方，发送方都会工作</strong>”。</li>\n<li>最后，我们也分析了Channel的源码定义，发现它其实是SendChannel、ReceiveChannel这两个接口的组合。而我们也可以借助它的这个特点，实现“对读取开放，对写入封闭”的设计。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/89/6f/893c15a694f0ce2b467b9a3220ef446f.jpg?wh=2000x1253\" alt=\"\"></p><p>其实Channel也不是Kotlin独创的概念，在某些其他编程语言当中，也有这样的组件，最典型的就是Go语言。所以，当你学会Kotlin的Channel，以后在别的语言中再遇到Channel，或者是基于Channel的Actor，你也就能快速地把Kotlin的知识迁移过去。</p><p>另外，学到这里相信你也发现了：编程语言里面的概念都是互通的。为什么有些人学习一门新的编程语言，可以特别快，还学得特别好？</p><p>原因往往就是，人家早已掌握了编程语言当中所有互通的概念。这就是所谓的<strong>触类旁通</strong>。学完这门课程以后，我相信，你也可以做到。</p><h2>思考题</h2><p>请问，Channel是“热”的，这一特点有什么坏处吗？为什么？ 欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"题目解答 | 期中考试版本参考实现","id":490408},"right":{"article_title":"20 | Flow：为什么说Flow是“冷”的？","id":491632}},"comments":[{"had_liked":false,"id":336482,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1127306,"ip_address":"","ucode":"3F69DAC14260DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","comment_is_top":false,"comment_ctime":1646183540,"is_pvip":false,"replies":[{"id":"122978","content":"总结到位~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646187729,"ip_address":"","comment_id":336482,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40300889204","product_id":100103401,"comment_content":"Channel 是“热”的可能会导致一下几个问题：<br>1. 可能会导致数据的丢失。<br>2. 浪费不必要的程序资源，类似于非懒加载的情况。<br>3. 如果未及时 close 的话，可能会导致内存泄露。","like_count":10,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554017,"discussion_content":"总结到位~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646187729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341410,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1649585444,"is_pvip":false,"replies":[{"id":"124972","content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649953933,"ip_address":"","comment_id":341410,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10239520036","product_id":100103401,"comment_content":"1、最开始  channel.receive () 先调用，但是 channel 没有 item，所以挂起；<br><br>2、协程启动要时间，send(it) 后调用，发送 item，然后 输入 “send1”；<br><br>3、 协程循环再调用 send(it)，此时队列已经满了，所以挂起，并唤起接收协程，然后 输入 “receive1”；<br><br>3、接收协程... ... ...","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563254,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649953933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336483,"user_name":"êｗěｎ","can_delete":false,"product_type":"c1","uid":1066707,"ip_address":"","ucode":"5000233111BEFA","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/d3/e25d104a.jpg","comment_is_top":false,"comment_ctime":1646183793,"is_pvip":true,"replies":[{"id":"122977","content":"在Kotlin当中，我们调用cancel()以后，管道中的消息会被清空，同时，管道也会标记为cancel，这时候，我们已经可以认为它是关闭状态了。上游如果继续发送的话，会产生异常。具体可以看看下面这个代码：<br><br>```<br>fun main() = runBlocking {<br>    &#47;&#47; 无限容量的管道<br>    val channel = Channel&lt;Int&gt;(Channel.UNLIMITED) {<br>        println(&quot;onUndeliveredElement = $it&quot;)<br>    }<br><br>    &#47;&#47; 等价这种写法<br>&#47;&#47;    val channel = Channel&lt;Int&gt;(Channel.UNLIMITED, onUndeliveredElement = { println(&quot;onUndeliveredElement = $it&quot;) })<br><br>    &#47;&#47; 放入三个数据<br>    (1..3).forEach {<br>        channel.send(it)<br>    }<br><br>    &#47;&#47; 取出一个，剩下两个<br>    channel.receive()<br><br>    &#47;&#47; 取消当前channel<br>    println(channel.isClosedForReceive)<br>    println(channel.isClosedForSend)<br>    channel.cancel()<br>    println(channel.isClosedForReceive)<br>    println(channel.isClosedForSend)<br>    channel.send(4)<br>}<br>```","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646187716,"ip_address":"","comment_id":336483,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10236118385","product_id":100103401,"comment_content":"Recieve的cancel是清空channel中的消息，但不会close吧？ 像go中如果在consumer 中关闭，会导致sender的panic。感觉kotlin也有这种陷阱。","like_count":3,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554016,"discussion_content":"在Kotlin当中，我们调用cancel()以后，管道中的消息会被清空，同时，管道也会标记为cancel，这时候，我们已经可以认为它是关闭状态了。上游如果继续发送的话，会产生异常。具体可以看看下面这个代码：\n\n```\nfun main() = runBlocking {\n    // 无限容量的管道\n    val channel = Channel&lt;Int&gt;(Channel.UNLIMITED) {\n        println(&#34;onUndeliveredElement = $it&#34;)\n    }\n\n    // 等价这种写法\n//    val channel = Channel&lt;Int&gt;(Channel.UNLIMITED, onUndeliveredElement = { println(&#34;onUndeliveredElement = $it&#34;) })\n\n    // 放入三个数据\n    (1..3).forEach {\n        channel.send(it)\n    }\n\n    // 取出一个，剩下两个\n    channel.receive()\n\n    // 取消当前channel\n    println(channel.isClosedForReceive)\n    println(channel.isClosedForSend)\n    channel.cancel()\n    println(channel.isClosedForReceive)\n    println(channel.isClosedForSend)\n    channel.send(4)\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646187716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2697815,"avatar":"https://static001.geekbang.org/account/avatar/00/29/2a/57/6629c858.jpg","nickname":"阿康","note":"","ucode":"DF20E1E33A8A34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580353,"discussion_content":"false\nfalse\nonUndeliveredElement = 2\nonUndeliveredElement = 3\ntrue\ntrue\nonUndeliveredElement = 4","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658125602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340265,"user_name":"jim","can_delete":false,"product_type":"c1","uid":1491946,"ip_address":"","ucode":"C12DB0F2B570F6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Urc67zDC8R6dh9U1ZFTF36icXewM1seehvOUYUs4hyWSsFzS5WQc2RcrE1Mzs8qtgib5SM5wFrVh22QcQd0JUUBw/132","comment_is_top":false,"comment_ctime":1648709380,"is_pvip":false,"replies":[{"id":"124475","content":"常规业务开发其实很少会需要用到Channel，Channel的使用场景其实是比较偏底层的，比如说我在课程开头提到的IM消息通道、股票行情实时刷新，等等。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648813944,"ip_address":"","comment_id":340265,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5943676676","product_id":100103401,"comment_content":"Channel平时工作中有 哪些使用场景？？？","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559548,"discussion_content":"常规业务开发其实很少会需要用到Channel，Channel的使用场景其实是比较偏底层的，比如说我在课程开头提到的IM消息通道、股票行情实时刷新，等等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648813944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339392,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1648068302,"is_pvip":false,"replies":[{"id":"124300","content":"没错，所以多个Channel组合的情况，我们需要三思而后行。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648521480,"ip_address":"","comment_id":339392,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5943035598","product_id":100103401,"comment_content":"对于接收方而言，热的Channel状态是时刻改变的，数据之间是强依赖。简单的情况还好，如果Channel的数据级联了几次之后，调试就成了噩梦，这和滥用EventBus一样。<br>","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558910,"discussion_content":"没错，所以多个Channel组合的情况，我们需要三思而后行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648521480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337209,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1646701590,"is_pvip":false,"replies":[{"id":"123272","content":"你说的produce{}吗？在它的Lambda当中，我们是可以调用send()方法的，而它的返回值是ReceiveChannel。这不是一个概念哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646753562,"ip_address":"","comment_id":337209,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5941668886","product_id":100103401,"comment_content":"为什么例子中是ReceiveChannel 在send？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555121,"discussion_content":"你说的produce{}吗？在它的Lambda当中，我们是可以调用send()方法的，而它的返回值是ReceiveChannel。这不是一个概念哈。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646753562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","nickname":"梁中华","note":"","ucode":"52FE40242CBAD0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557588,"discussion_content":"看produce的签名：\npublic fun &lt;E&gt; CoroutineScope.produce(\n    context: CoroutineContext = EmptyCoroutineContext,\n    capacity: Int = 0,\n    @BuilderInference block: suspend ProducerScope&lt;E&gt;.() -&gt; Unit\n): ReceiveChannel&lt;E&gt; \nlambda表达式的接收者是：ProducerScope类型的\npublic interface ProducerScope&lt;in E&gt; : CoroutineScope, SendChannel&lt;E&gt;  \n而ProducerScope正好集成SendChannel接口，而SendChannel接口有send方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647872353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337159,"user_name":"Geek_8a5ee1","can_delete":false,"product_type":"c1","uid":2667006,"ip_address":"","ucode":"67375AD694E987","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL11eYiaBo5voEzTIEkNgOgZ0KSsMw9UeStPgfEUVEndUhG2nxL5WnLaQ9sEDWctVZJ9Lgyn9iaCh1A/132","comment_is_top":false,"comment_ctime":1646655470,"is_pvip":false,"replies":[{"id":"123274","content":"viewModelScope是Android当中的内容，三言两语讲不清，我会尝试在Android篇里加入一些内容，请留意之后的第34讲的内容。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646753926,"ip_address":"","comment_id":337159,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5941622766","product_id":100103401,"comment_content":"可以讲一下viewModelScope的区别吗","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555125,"discussion_content":"viewModelScope是Android当中的内容，三言两语讲不清，我会尝试在Android篇里加入一些内容，请留意之后的第34讲的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646753926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349364,"user_name":"Geek_b8faf4","can_delete":false,"product_type":"c1","uid":3005840,"ip_address":"","ucode":"1EA43210AB2268","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er7DPjeHkPLcAJYvlhTjezPfj8sw8ZJAM93ZMSIERVUvLs0K5qSZzZJhtar1mp7tN4GdLkyCfpmbg/132","comment_is_top":false,"comment_ctime":1655910787,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655910787","product_id":100103401,"comment_content":"```<br>fun main() = runBlocking {<br>    val channel = Channel&lt;Int&gt;(<br>        capacity = Channel.RENDEZVOUS<br>    ) {<br>        println(&quot;Undelivered: $it&quot;)<br>    }<br>    launch {<br>        (1..3).forEach {<br>            channel.send(it)<br>            println(&quot;Send: $it&quot;)<br>        }<br><br>        channel.close()<br>    }<br><br>    println( channel.receive() )<br>    channel.cancel()<br>    println(&quot;end&quot;)<br>}<br><br>Send: 1<br>1<br>Undelivered: 2<br>end<br>```<br>3没有Undelivered我可以理解，因为onUndeliveredElement只有在Element进入了管道，但是没有被接收的时候触发，3没有机会进入管道。我不太理解2为什么能进入管道。我的管道capacity是RENDEZVOUS，只调用了一次receive，1进入了管道并且被接收了，2应该没有机会进入管道啊，为什么会触发onUndeliveredElement？","like_count":0},{"had_liked":false,"id":339675,"user_name":"Xs.Ten","can_delete":false,"product_type":"c1","uid":1128376,"ip_address":"","ucode":"2368B9BDDDEE2B","user_header":"https://static001.geekbang.org/account/avatar/00/11/37/b8/c887a5ea.jpg","comment_is_top":false,"comment_ctime":1648286604,"is_pvip":true,"replies":[{"id":"124289","content":"Channel的接口本身是通过组合得来的，理论上我们是可以让它们互换的，但不建议这么干。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648520850,"ip_address":"","comment_id":339675,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648286604","product_id":100103401,"comment_content":"老师好，请问Channel 里面 Sender 和 Receiver 的身份可以发生互换么？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558896,"discussion_content":"Channel的接口本身是通过组合得来的，理论上我们是可以让它们互换的，但不建议这么干。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648520851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339046,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1647872064,"is_pvip":true,"replies":[{"id":"124003","content":"这是Kotlin 命名的一种特色。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648029799,"ip_address":"","comment_id":339046,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1647872064","product_id":100103401,"comment_content":"public fun &lt;E&gt; Channel(<br>    capacity: Int = RENDEZVOUS,<br>    onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND,<br>    onUndeliveredElement: ((E) -&gt; Unit)? = null<br>): Channel&lt;E&gt;<br><br>Channel居然也是个方法，为啥方法名是大写字母开头的? 难道是因为它是顶层方法?","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557949,"discussion_content":"这是Kotlin 命名的一种特色。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648029800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2697815,"avatar":"https://static001.geekbang.org/account/avatar/00/29/2a/57/6629c858.jpg","nickname":"阿康","note":"","ucode":"DF20E1E33A8A34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580358,"discussion_content":"我感觉是源码写错了。。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658126209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339045,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1647871482,"is_pvip":true,"replies":[{"id":"124002","content":"你可以去看看它的源代码，这样你会发现是一个函数。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648029764,"ip_address":"","comment_id":339045,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1647871482","product_id":100103401,"comment_content":"val channel: ReceiveChannel by ::_channel<br> private val _channel: Channel = Channel()<br><br>Channel既然是个接口，为啥还能直接实例化？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557948,"discussion_content":"你可以去看看它的源代码，这样你会发现是一个函数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648029764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2697815,"avatar":"https://static001.geekbang.org/account/avatar/00/29/2a/57/6629c858.jpg","nickname":"阿康","note":"","ucode":"DF20E1E33A8A34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580361,"discussion_content":"这里是方法。。。不是接口。。。这个方法命名很奇特，首字母大写。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658126312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338160,"user_name":"学习中...","can_delete":false,"product_type":"c1","uid":1126774,"ip_address":"","ucode":"AF180F386ABC09","user_header":"https://static001.geekbang.org/account/avatar/00/11/31/76/8e3347a1.jpg","comment_is_top":false,"comment_ctime":1647329562,"is_pvip":true,"replies":[{"id":"123648","content":"你说得对，笔误了，感谢这位同学的提醒。","user_name":"作者回复","user_name_real":"作者","uid":"1180670","ctime":1647407413,"ip_address":"","comment_id":338160,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647329562","product_id":100103401,"comment_content":"协程库最新不是1.6.0吗，怎么有1.6.10呢<br>https:&#47;&#47;github.com&#47;Kotlin&#47;kotlinx.coroutines&#47;releases","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556511,"discussion_content":"你说得对，笔误了，感谢这位同学的提醒。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647407413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338076,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1647268646,"is_pvip":false,"replies":[{"id":"123604","content":"这位同学很用心，赞！<br><br>答案：出现这个现象的原因在于，send(it)、receive()它们两个是轮流挂起的。当数据是偶数条的时候，receive()会多调用一次。你通过对这两个函数打断点，就可以发现这一点了。<br><br>PS：请继续加油~","user_name":"作者回复","user_name_real":"作者","uid":"1180670","ctime":1647306175,"ip_address":"","comment_id":338076,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1647268646","product_id":100103401,"comment_content":"老师好，我又重新发了一遍哈<br><br>代码段12<br>发送【奇数】条数据的时候正常，发送【偶数】条数据的时候就会异常崩溃<br>例如   (1..2)   (1..4)   (1..6) 都会异常<br>这是什么原因呢？<br><br>fun main() = runBlocking {<br>    val channel: ReceiveChannel&lt;Int&gt; = produce {<br>        (1..2).forEach { &#47;&#47; 发送【奇数】条数据时是正常的，发送【偶数】条数据时就会崩溃<br>            send(it)<br>            println(&amp;#34;Send: $it&amp;#34;)<br>        }<br>    }<br>    while (!channel.isClosedForReceive) {<br>        val i = channel.receive()<br>        println(&amp;#34;Receive: $i&amp;#34;)<br>    }<br>    println(&amp;#34;end&amp;#34;)<br>}<br><br>代码接报错信息如下图：<br>https:&#47;&#47;gitee.com&#47;baiqiantao&#47;blogPic&#47;raw&#47;master&#47;img&#47;2020&#47;20220314204734.png","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556300,"discussion_content":"这位同学很用心，赞！\n\n答案：出现这个现象的原因在于，send(it)、receive()它们两个是轮流挂起的。当数据是偶数条的时候，receive()会多调用一次。你通过对这两个函数打断点，就可以发现这一点了。\n\nPS：请继续加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647306175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1723397,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/4c/05/4fe55808.jpg","nickname":"没名儿","note":"","ucode":"65B48705171730","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557018,"discussion_content":"这里当数据是偶数条的时候，receive()会多调用一次是底层原因吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647609155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337828,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1647080255,"is_pvip":false,"replies":[{"id":"123589","content":"原因就是：到目前为止isClosedForReceive是ExperimentalCoroutinesApi，它的功能仍然是有缺陷的。当Channel有capacity 以后，Kotlin官方支持的并不好，所以我们暂时不应该用它。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1647235997,"ip_address":"","comment_id":337828,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647080255","product_id":100103401,"comment_content":"以上代码看起来是可以正常工作了。但是，我仍然不建议你用这种方式。因为，当你为管道指定了 capacity 以后，以上的判断方式将会变得不可靠！原因是目前的 1.6.10 版本的协程库，运行这样的代码会崩溃，如下所示：<br><br>-------------<br><br>这是现象，而不是原因呀，具体原因是什么呢？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556166,"discussion_content":"原因就是：到目前为止isClosedForReceive是ExperimentalCoroutinesApi，它的功能仍然是有缺陷的。当Channel有capacity 以后，Kotlin官方支持的并不好，所以我们暂时不应该用它。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647235997,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336748,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1646353475,"is_pvip":false,"replies":[{"id":"123157","content":"Channel的使用场景其实是比较偏底层的，比如说我在课程开头提到的IM消息通道、股票行情实时刷新，等等。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646581848,"ip_address":"","comment_id":336748,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646353475","product_id":100103401,"comment_content":"老师你好，能举几个实际场景中channel使用例子吗？什么时候需要使用这种双向数据流呢？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554762,"discussion_content":"Channel的使用场景其实是比较偏底层的，比如说我在课程开头提到的IM消息通道、股票行情实时刷新，等等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646581848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336512,"user_name":"tedzyc","can_delete":false,"product_type":"c1","uid":1357882,"ip_address":"","ucode":"3419900FBBE2A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epW39iazElic8B436AHhEePqOibvHr2lSXJ0LMwiavicmCPtXwXxBuxyy6l7pEiblo198fTpFiayCoyoj8Jw/132","comment_is_top":false,"comment_ctime":1646195544,"is_pvip":true,"replies":[{"id":"123021","content":"好的，记下了~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646271390,"ip_address":"","comment_id":336512,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646195544","product_id":100103401,"comment_content":"老师能有空能讲讲Android Jetpack的paging3这个库吗？里面用BroadcastChannel通信那块能否帮着分析一下。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554214,"discussion_content":"好的，记下了~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646271391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336505,"user_name":"L先生","can_delete":false,"product_type":"c1","uid":2879424,"ip_address":"","ucode":"D1E567ED3377CE","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ef/c0/537b3905.jpg","comment_is_top":false,"comment_ctime":1646192219,"is_pvip":false,"replies":[{"id":"123020","content":"嗯，是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646271339,"ip_address":"","comment_id":336505,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646192219","product_id":100103401,"comment_content":"个人理解。因为是热管道，如果开发者不注意或者因为某些意外原因，可能会导致挂起，或者队列过大的情况。参考eventbus,除非是sticky状态，否则没有注册接受事件的话，是发不出去的","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554213,"discussion_content":"嗯，是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646271339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336495,"user_name":"7Promise","can_delete":false,"product_type":"c1","uid":2879220,"ip_address":"","ucode":"BF7C7F042E51F3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/f4/27a5080a.jpg","comment_is_top":false,"comment_ctime":1646189117,"is_pvip":false,"replies":[{"id":"123018","content":"分析的很好！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646271312,"ip_address":"","comment_id":336495,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1646189117","product_id":100103401,"comment_content":"Channel是“热”的，导致想接收数据时会接收到之前的旧数据，而可能只希望接收当前开始发送的数据。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554211,"discussion_content":"分析的很好！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646271312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1339841,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","nickname":"白乾涛","note":"","ucode":"0C704B0B90C8D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":555856,"discussion_content":"接收数据时【不一定】会接收到之前的旧数据吧？\n\n比如使用 DROP_OLDEST + capacity = 1，就不会收到旧数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647086107,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":554211,"ip_address":""},"score":555856,"extra":""},{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339841,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","nickname":"白乾涛","note":"","ucode":"0C704B0B90C8D7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592060,"discussion_content":"他的意思是可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667051296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":555856,"ip_address":"河北"},"score":592060,"extra":""}]}]},{"had_liked":false,"id":336484,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1127306,"ip_address":"","ucode":"3F69DAC14260DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","comment_is_top":false,"comment_ctime":1646184370,"is_pvip":false,"replies":[{"id":"122976","content":"问题1，2，在源码篇的21讲会解释哈。<br><br>问题3：打印结果不是严格交替的。如果一直是send挂起，那我们的结果就会是严格的交替执行。但实际上，send、received是轮流挂起的。（如果你去调试一下，就会发现了。）","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646187338,"ip_address":"","comment_id":336484,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1646184370","product_id":100103401,"comment_content":"涛哥，我有几个问题问一下哈：<br>1. send 函数是如何挂起的？虽然它是一个 suspend 函数，但它可以连续发多个数据（容量足够的情况下），直到数据发送完后才被挂起？<br>2. 当 send 函数被挂起后，是如何恢复的？<br>3.代码段 1 的例子，打印的结果为什么不是交替的，而是乱序的？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554012,"discussion_content":"问题1，2，在源码篇的21讲会解释哈。\n\n问题3：打印结果不是严格交替的。如果一直是send挂起，那我们的结果就会是严格的交替执行。但实际上，send、received是轮流挂起的。（如果你去调试一下，就会发现了。）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646187338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1127306,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","nickname":"Allen","note":"","ucode":"3F69DAC14260DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554033,"discussion_content":"但是我认为的是，在那个例子中，由于 channel 容量的限制，每次 send 一个数据后，都会被挂起，挂起之后，received 会从挂起后恢复，并去消费对应的数据。不知道这个想法哪里出了问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646191730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1090798,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","nickname":"魏全运","note":"","ucode":"3FED702C724E2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1127306,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","nickname":"Allen","note":"","ucode":"3F69DAC14260DC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554346,"discussion_content":"是否在发送一次后挂起，取决于channel的容量和策略吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646353543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":554033,"ip_address":""},"score":554346,"extra":""}]}]},{"had_liked":false,"id":336480,"user_name":"A Lonely Cat","can_delete":false,"product_type":"c1","uid":2885349,"ip_address":"","ucode":"382EBFDD8E5115","user_header":"https://static001.geekbang.org/account/avatar/00/2c/06/e5/51ef9735.jpg","comment_is_top":false,"comment_ctime":1646182949,"is_pvip":false,"replies":[{"id":"122979","content":"总结很棒！","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646187746,"ip_address":"","comment_id":336480,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646182949","product_id":100103401,"comment_content":"一直没懂“冷”和“热”的概念，今天似乎明白了。<br><br>思考题：<br>有坏处。因为不管有没有接受都在一直工作，那么势必会造成资源的浪费。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554018,"discussion_content":"总结很棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646187746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}