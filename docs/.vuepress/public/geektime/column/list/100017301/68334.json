{"id":68334,"title":"24 | 二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？","content":"<p>上一节我们学习了树、二叉树以及二叉树的遍历，今天我们再来学习一种特殊的二叉树，二叉查找树。二叉查找树最大的特点就是，支持动态数据集合的快速插入、删除、查找操作。</p><p>我们之前说过，散列表也是支持这些操作的，并且散列表的这些操作比二叉查找树更高效，时间复杂度是O(1)。<strong><span class=\"orange\">既然有了这么高效的散列表，使用二叉树的地方是不是都可以替换成散列表呢？有没有哪些地方是散列表做不了，必须要用二叉树来做的呢？</span></strong></p><p>带着这些问题，我们就来学习今天的内容，二叉查找树！</p><h2>二叉查找树（Binary Search Tree）</h2><p>二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。它是怎么做到这些的呢？</p><p>这些都依赖于二叉查找树的特殊结构。<strong>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong> 我画了几个二叉查找树的例子，你一看应该就清楚了。</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/ae/f3bb11b6d4a18f95aa19e11f22b99bae.jpg?wh=1142*515\" alt=\"\"></p><p>前面我们讲到，二叉查找树支持快速查找、插入、删除操作，现在我们就依次来看下，这三个操作是如何实现的。</p><h3>1.二叉查找树的查找操作</h3><p>首先，我们看如何在二叉查找树中查找一个节点。我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/96/2a/96b3d86ed9b7c4f399e8357ceed0db2a.jpg?wh=1142*616\" alt=\"\"></p><p>这里我把查找的代码实现了一下，贴在下面了，结合代码，理解起来会更加容易。</p><pre><code>public class BinarySearchTree {\n  private Node tree;\n\n  public Node find(int data) {\n    Node p = tree;\n    while (p != null) {\n      if (data &lt; p.data) p = p.left;\n      else if (data &gt; p.data) p = p.right;\n      else return p;\n    }\n    return null;\n  }\n\n  public static class Node {\n    private int data;\n    private Node left;\n    private Node right;\n\n    public Node(int data) {\n      this.data = data;\n    }\n  }\n}\n</code></pre><h3>2.二叉查找树的插入操作</h3><p>二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p><p><img src=\"https://static001.geekbang.org/resource/image/da/c5/daa9fb557726ee6183c5b80222cfc5c5.jpg?wh=1142*602\" alt=\"\"></p><p>同样，插入的代码我也实现了一下，贴在下面，你可以看看。</p><pre><code>public void insert(int data) {\n  if (tree == null) {\n    tree = new Node(data);\n    return;\n  }\n\n  Node p = tree;\n  while (p != null) {\n    if (data &gt; p.data) {\n      if (p.right == null) {\n        p.right = new Node(data);\n        return;\n      }\n      p = p.right;\n    } else { // data &lt; p.data\n      if (p.left == null) {\n        p.left = new Node(data);\n        return;\n      }\n      p = p.left;\n    }\n  }\n}\n</code></pre><h3>3.二叉查找树的删除操作</h3><p>二叉查找树的查找、插入操作都比较简单易懂，但是它的删除操作就比较复杂了 。针对要删除节点的子节点个数的不同，我们需要分三种情况来处理。</p><p>第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null。比如图中的删除节点55。</p><p>第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点13。</p><p>第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点18。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/2c/299c615bc2e00dc32225f4d9e3490e2c.jpg?wh=1142*620\" alt=\"\"></p><p>老规矩，我还是把删除的代码贴在这里。</p><pre><code>public void delete(int data) {\n  Node p = tree; // p指向要删除的节点，初始化指向根节点\n  Node pp = null; // pp记录的是p的父节点\n  while (p != null &amp;&amp; p.data != data) {\n    pp = p;\n    if (data &gt; p.data) p = p.right;\n    else p = p.left;\n  }\n  if (p == null) return; // 没有找到\n\n  // 要删除的节点有两个子节点\n  if (p.left != null &amp;&amp; p.right != null) { // 查找右子树中最小节点\n    Node minP = p.right;\n    Node minPP = p; // minPP表示minP的父节点\n    while (minP.left != null) {\n      minPP = minP;\n      minP = minP.left;\n    }\n    p.data = minP.data; // 将minP的数据替换到p中\n    p = minP; // 下面就变成了删除minP了\n    pp = minPP;\n  }\n\n  // 删除节点是叶子节点或者仅有一个子节点\n  Node child; // p的子节点\n  if (p.left != null) child = p.left;\n  else if (p.right != null) child = p.right;\n  else child = null;\n\n  if (pp == null) tree = child; // 删除的是根节点\n  else if (pp.left == p) pp.left = child;\n  else pp.right = child;\n}\n</code></pre><p>实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p><h3>4.二叉查找树的其他操作</h3><p>除了插入、删除、查找操作之外，二叉查找树中还可以支持<strong>快速地查找最大节点和最小节点、前驱节点和后继节点</strong>。这些操作我就不一一展示了。我会将相应的代码放到GitHub上，你可以自己先实现一下，然后再去上面看。</p><p>二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是<strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)，非常高效</strong>。因此，二叉查找树也叫作二叉排序树。</p><h2>支持重复数据的二叉查找树</h2><p>前面讲二叉查找树的时候，我们默认树中节点存储的都是数字。很多时候，在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。</p><p>前面我们讲的二叉查找树的操作，针对的都是不存在键值相同的情况。那如果存储的两个对象键值相同，这种情况该怎么处理呢？我这里有两种解决方法。</p><p>第一种方法比较容易。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p><p>第二种方法比较不好理解，不过更加优雅。</p><p>每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p><p><img src=\"https://static001.geekbang.org/resource/image/3f/5f/3f59a40e3d927f567022918d89590a5f.jpg?wh=1142*555\" alt=\"\"></p><p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p><p><img src=\"https://static001.geekbang.org/resource/image/fb/ff/fb7b320efd59a05469d6d6fcf0c98eff.jpg?wh=1142*577\" alt=\"\"></p><p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p><p><img src=\"https://static001.geekbang.org/resource/image/25/17/254a4800703d31612c0af63870260517.jpg?wh=1142*608\" alt=\"\"></p><h2>二叉查找树的时间复杂度分析</h2><p>好了，对于二叉查找树常用操作的实现方式，你应该掌握得差不多了。现在，我们来分析一下，二叉查找树的插入、删除、查找操作的时间复杂度。</p><p>实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了O(n)。</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/d9/e3d9b2977d350526d2156f01960383d9.jpg?wh=1142*765\" alt=\"\"></p><p>我刚刚其实分析了一种最糟糕的情况，我们现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。这个时候，插入、删除、查找的时间复杂度是多少呢？</p><p>从我前面的例子、图，以及还有代码来看，不管操作是插入、删除还是查找，<strong>时间复杂度<strong><strong>其实</strong></strong>都跟树的高度成正比，也就是O(height)</strong>。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含n个节点的完全二叉树的高度？</p><p>树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含n个节点的完全二叉树中，第一层包含1个节点，第二层包含2个节点，第三层包含4个节点，依次类推，下面一层节点个数是上一层的2倍，第K层包含的节点个数就是2^(K-1)。</p><p>不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在1个到2^(L-1)个之间（我们假设最大层数是L）。如果我们把每一层的节点个数加起来就是总的节点个数n。也就是说，如果节点的个数是n，那么n满足这样一个关系：</p><pre><code>n &gt;= 1+2+4+8+...+2^(L-2)+1\nn &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)\n</code></pre><p>借助等比数列的求和公式，我们可以计算出，L的范围是[log<sub>2</sub>(n+1), log<sub>2</sub>n +1]。完全二叉树的层数小于等于log<sub>2</sub>n +1，也就是说，完全二叉树的高度小于等于log<sub>2</sub>n。</p><p>显然，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除、插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树，这就是我们下一节课要详细讲的，一种特殊的二叉查找树，平衡二叉查找树。平衡二叉查找树的高度接近logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是O(logn)。</p><h2>解答开篇</h2><p>我们在散列表那节中讲过，散列表的插入、删除、查找操作的时间复杂度可以做到常量级的O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？</p><p>我认为有下面几个原因：</p><p>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在O(n)的时间复杂度内，输出有序的数据序列。</p><p>第二，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)。</p><p>第三，笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定比O(logn)快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</p><p>第四，散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</p><p>最后，为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</p><p>综合这几点，平衡二叉查找树在某些方面还是优于散列表的，所以，这两者的存在并不冲突。我们在实际的开发过程中，需要结合具体的需求来选择使用哪一个。</p><h2>内容小结</h2><p>今天我们学习了一种特殊的二叉树，二叉查找树。它支持快速地查找、插入、删除操作。</p><p>二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值。不过，这只是针对没有重复数据的情况。对于存在重复数据的二叉查找树，我介绍了两种构建方法，一种是让每个节点存储多个值相同的数据；另一种是，每个节点中存储一个数据。针对这种情况，我们只需要稍加改造原来的插入、删除、查找操作即可。</p><p>在二叉查找树中，查找、插入、删除等很多操作的时间复杂度都跟树的高度成正比。两个极端情况的时间复杂度分别是O(n)和O(logn)，分别对应二叉树退化成链表的情况和完全二叉树。</p><p>为了避免时间复杂度的退化，针对二叉查找树，我们又设计了一种更加复杂的树，平衡二叉查找树，时间复杂度可以做到稳定的O(logn)，下一节我们具体来讲。</p><h2>课后思考</h2><p>今天我讲了二叉树高度的理论分析方法，给出了粗略的数量级。如何通过编程，求出一棵给定二叉树的确切高度呢？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p><hr><p><span class=\"orange\">我已将本节内容相关的详细代码更新到GitHub，<a href=\"https://github.com/wangzheng0822/algo\">戳此</a>即可查看。</span></p>","neighbors":{"left":{"article_title":"23 | 二叉树基础（上）：什么样的二叉树适合用数组来存储？","id":67856},"right":{"article_title":"25 | 红黑树（上）：为什么工程中都用红黑树这种二叉树？","id":68638}},"comments":[{"had_liked":true,"id":38784,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1542126475,"is_pvip":false,"replies":[{"id":"13894","content":"👍 大家可以看看这条留言","user_name":"作者回复","comment_id":38784,"uid":"1190123","ip_address":"","utype":1,"ctime":1542159574,"user_name_real":"gg"}],"discussion_count":36,"race_medal":0,"score":"2484033223563","product_id":100017301,"comment_content":"确定二叉树高度有两种思路：第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1；第二种可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从0开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。","like_count":579,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428810,"discussion_content":"👍 大家可以看看这条留言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542159574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78889,"discussion_content":"层次遍历求高度的代码\n public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        TreeNode node = root;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(node);\n        int front = 0;// 队头\n        int rear = queue.size();// 队尾\n        int floor = 1;\n        while (!queue.isEmpty()){\n            node = queue.poll();\n            front++;\n            if(node.left != null){\n                queue.offer(node.left);\n            }\n            if(node.right != null){\n                queue.offer(node.right);\n            }\n            if(front == rear){// 进入下一层\n                front = 0;\n                rear = queue.size();\n                floor++;// 层数+1\n            }\n        }\n        return floor;\n    }","likes_number":52,"is_delete":false,"is_hidden":false,"ctime":1576030318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":11,"child_discussions":[{"author":{"id":1476144,"avatar":"https://static001.geekbang.org/account/avatar/00/16/86/30/8c639ac6.jpg","nickname":"rocky青苔","note":"","ucode":"78B81801802B9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":190814,"discussion_content":"代码写的很清晰，看懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582978293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78889,"ip_address":""},"score":190814,"extra":""},{"author":{"id":1972505,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/19/19/d82e24fb.jpg","nickname":"李润东","note":"","ucode":"65CFEA3C8B27C4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260166,"discussion_content":"👍👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588852432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78889,"ip_address":""},"score":260166,"extra":""},{"author":{"id":1194060,"avatar":"https://static001.geekbang.org/account/avatar/00/12/38/4c/5426e2e0.jpg","nickname":"CJJ","note":"","ucode":"7E02A6A8547559","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261547,"discussion_content":"想问一下floor初始值是不是应该为0呢？不然进入下一层会++，如果只有两个叶子节点，算出来有三层喔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588983060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":78889,"ip_address":""},"score":261547,"extra":""}]},{"author":{"id":1474214,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7e/a6/4e331ef4.jpg","nickname":"骑行的掌柜J","note":"","ucode":"3163102651C653","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383358,"discussion_content":"没想到力扣的题解大佬失火 也在这里","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1626067990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2292598,"avatar":"https://static001.geekbang.org/account/avatar/00/22/fb/76/71877cfc.jpg","nickname":"Geek_cec571","note":"","ucode":"19727B27AD904F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384081,"discussion_content":"//深度优先思想的递归 是否如下呢；感觉更像分治呢\npublic static int getTreeFloor(Node root) {\n        if(root == null){\n            return 0;\n        }\n        if(root.left == null &amp;&amp; root.right == null){\n            return 1;\n        }\n        //获取右子树高度\n        int rFloor = getTreeFloor(root.right);\n        //获取左子树高度\n        int lFloor = getTreeFloor(root.left);\n        return Math.max(rFloor,lFloor)+1;\n    }\n\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626357262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1686410,"avatar":"https://static001.geekbang.org/account/avatar/00/19/bb/8a/d33d9d3f.jpg","nickname":"小菠萝🍍","note":"","ucode":"DA814203C6C062","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371979,"discussion_content":"深度优先遍历和广度优先遍历的典型！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620114147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296791,"discussion_content":"其实就是借助二叉树层序遍历的思想，每一层遍历完让高度加1，最后所有层遍历完就得到了树的高度","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596652979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172368,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e3/90/84eb5682.jpg","nickname":"zouz","note":"","ucode":"EBC8E9DD8EB0B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204251,"discussion_content":"我想到了第一个，没想到第二个。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584148239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1717549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/35/2d/a2bde67e.jpg","nickname":"SapereAude","note":"","ucode":"C5D61C535B7B10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53440,"discussion_content":"C++实现：https://blog.csdn.net/SoftpaseFar/article/details/101758653","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574168927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2035271,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/0e/47/cb39bcb1.jpg","nickname":"Json","note":"","ucode":"2C28E0CBEB2FBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403066,"discussion_content":"优秀！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634002915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2133309,"avatar":"https://static001.geekbang.org/account/avatar/00/20/8d/3d/91b1afd3.jpg","nickname":"小北","note":"","ucode":"8FE84905F0E073","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304674,"discussion_content":"答案好像确实不对唉 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599639302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2133309,"avatar":"https://static001.geekbang.org/account/avatar/00/20/8d/3d/91b1afd3.jpg","nickname":"小北","note":"","ucode":"8FE84905F0E073","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305620,"discussion_content":"哪里不对？如果你看的是评论，后面再加一个判断就行了，我已经加上去了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600041168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304674,"ip_address":""},"score":305620,"extra":""}]},{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261106,"discussion_content":"优秀了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588940931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1812840,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a9/68/ec442a70.jpg","nickname":"王jojo","note":"","ucode":"1ABE7FA2614F86","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234093,"discussion_content":"想到了第二种, 没想到第一种,学到了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586957914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73174,"discussion_content":"深度优先的思想，就是分治思想，递归算 对吧，看起来是这样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575554717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73681,"discussion_content":"深度广度都行，时间复杂度也一样，就是思路不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575588765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73174,"ip_address":""},"score":73681,"extra":""}]},{"author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49575,"discussion_content":"层次遍历也没太看懂。\n其实上一节中提到过按层遍历二叉树的节点问题，非递归的实现就是借助了队列，将每一层的节点入队，然后将每层的节点值写入结果集（全局变量）。再把该层所有节点出队，将所有节点的子节点再入队做重复操作。\n那这里如果只是求树的高度的话，则仍可参考上面的思路，只是无需写入结果集了，只要记录层数即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573614714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1014550,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/16/ca250e8c.jpg","nickname":"王木公","note":"","ucode":"F049AEBFA0338D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50042,"discussion_content":"就是记录当前层数所有节点是否都出队完成，队列长度一直在变化，上一层开始下标都是0，结束下标就是当前队列的长度，当两个下标重合的时候，当前层遍历完毕，进入下一层，继续之前的操作。你不记录节点，怎么知道当前层是否遍历完成，怎么知道现在到了哪一层呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573658374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49575,"ip_address":""},"score":50042,"extra":""},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73169,"discussion_content":"上一节 Jerry银银 的代码中，有一个中间队列 curLevelNodes ，其遍历完成，当前层就结束了，可以用来计层数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575554645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50042,"ip_address":""},"score":73169,"extra":""},{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73682,"discussion_content":"我是觉得没有必要再建立一个队列了。一开始就用两个整数来记录队头和队尾。每出一个节点，队头下标加1，到了队头等于队尾就表示当前层结束了。然后队头规0，队尾继续等于当前队列长度。一直走到队列空为止。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575588966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73169,"ip_address":""},"score":73682,"extra":""}]},{"author":{"id":1513887,"avatar":"https://static001.geekbang.org/account/avatar/00/17/19/9f/55770fd3.jpg","nickname":"瑞杰_Zhang🎋","note":"","ucode":"1DA514F5353741","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40192,"discussion_content":"我也没太明白。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572101359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1513887,"avatar":"https://static001.geekbang.org/account/avatar/00/17/19/9f/55770fd3.jpg","nickname":"瑞杰_Zhang🎋","note":"","ucode":"1DA514F5353741","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78891,"discussion_content":"我把代码贴上来了，自己看吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576030339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40192,"ip_address":""},"score":78891,"extra":""}]},{"author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":23398,"discussion_content":"层次遍历没看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569812306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1738212,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/85/e4/36280ed0.jpg","nickname":"炎动尘璃","note":"","ucode":"1E20DB38C108B7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52539,"discussion_content":"可以了解一下广度优先，应该就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574064205,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":23398,"ip_address":""},"score":52539,"extra":""},{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1127175,"avatar":"https://static001.geekbang.org/account/avatar/00/11/33/07/8f351609.jpg","nickname":"JustDoDT","note":"","ucode":"6AF0B80F00EAEF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":78890,"discussion_content":"我把代码贴上来了，自己看吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576030336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":23398,"ip_address":""},"score":78890,"extra":""}]}]},{"had_liked":true,"id":38885,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1542156934,"is_pvip":false,"replies":[{"id":"13889","content":"👍 精髓","user_name":"作者回复","comment_id":38885,"uid":"1190123","ip_address":"","utype":1,"ctime":1542159466,"user_name_real":"gg"}],"discussion_count":1,"race_medal":0,"score":"1182658163334","product_id":100017301,"comment_content":"递归法，根节点高度=max(左子树高度，右子树高度)+1","like_count":275,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428839,"discussion_content":"👍 精髓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542159466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":39529,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1542296282,"is_pvip":false,"replies":[{"id":"14184","content":"好像也可以 👍","user_name":"作者回复","comment_id":39529,"uid":"1190123","ip_address":"","utype":1,"ctime":1542334131,"user_name_real":"gg"}],"discussion_count":15,"race_medal":0,"score":"628607521498","product_id":100017301,"comment_content":"老师我有一个疑问，二叉树删除时，如果待删除节点有两个子节点，能否用左子树中的最大值来替换待删除节点呢？","like_count":146,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429100,"discussion_content":"好像也可以 👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542334131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1200478,"avatar":"https://static001.geekbang.org/account/avatar/00/12/51/5e/729bee30.jpg","nickname":"芥末鸭掌","note":"","ucode":"F2B2D564990F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":555287,"discussion_content":"好像不太对，如果18的左子树17存在一个20的右子节点，那选择20替换18后19的节点位置就不对了呢？可能是我理解的有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646835217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":429100,"ip_address":""},"score":555287,"extra":""},{"author":{"id":1544342,"avatar":"https://static001.geekbang.org/account/avatar/00/17/90/96/8e12e7c8.jpg","nickname":"Gemrain","note":"","ucode":"880093FAFD721D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1200478,"avatar":"https://static001.geekbang.org/account/avatar/00/12/51/5e/729bee30.jpg","nickname":"芥末鸭掌","note":"","ucode":"F2B2D564990F57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556080,"discussion_content":"不可能的，添加节点是从根节点开始的，当20走到18这个节点时，判断到20&gt;18，就直接进入右子树了，所以根本不可能出现17存在一个20的右子节点这个说法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647187915,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":555287,"ip_address":""},"score":556080,"extra":""}]},{"author":{"id":1062997,"avatar":"https://static001.geekbang.org/account/avatar/00/10/38/55/a719a520.jpg","nickname":"Marshal丶","note":"","ucode":"15A3EB0F06E42C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312531,"discussion_content":"Data Structure Visualizations网站上的搜索二叉树删除，就是用左子树的最大节点来替换被删除节点的","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1602729134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1991279,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/62/6f/06d476f7.jpg","nickname":"Geek_Akara","note":"","ucode":"E86A5A9EEC8BFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":270593,"discussion_content":"右子树的最小节点有两种情况：\n一  最小节点是叶子节点，直接遍历到底不用处理其子节点。\n二  最小节点A带一个右子树C，这样最小节点A直接替换被删除的节点，右子树C取代A原来的位置，因为A没有左子树，所以C可以直接取代A的位置。\n\n用左子树最大值取代删除节点有两种情况：\n一 该节点是叶子节点，直接取代没有问题。\n二 该节点有一个左子树，直接取代，左子树取代该节点位置，同上。\n\n所以两种方法是一样的。证明完毕！","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1590028253,"is_liked":true,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1221991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","nickname":"AllenGFLiu","note":"","ucode":"90FA8A619A2629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4446,"discussion_content":"如果左子树的最大值节点自己本身还有一个左子节点呢？删除该最大值节点后，会比用右子树中最小值的方式多一个指定语句。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1565427938,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1221991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","nickname":"AllenGFLiu","note":"","ucode":"90FA8A619A2629","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5319,"discussion_content":"其实老师描述删除的第三种情况不严谨，还有他在支持重复数据的二叉查找树部分说明也是不严谨，右子树中最小值也可能有右儿子节点，但是你可以看下老师给定的删除部分的代码，代码中已经包含了这种情况！","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1566176922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4446,"ip_address":""},"score":5319,"extra":""},{"author":{"id":1258401,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a1/f3835f01.jpg","nickname":"社会猪","note":"","ucode":"CFF5EA7F247373","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1221991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","nickname":"AllenGFLiu","note":"","ucode":"90FA8A619A2629","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20356,"discussion_content":"哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569304873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4446,"ip_address":""},"score":20356,"extra":""},{"author":{"id":1258401,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/a1/f3835f01.jpg","nickname":"社会猪","note":"","ucode":"CFF5EA7F247373","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1193468,"avatar":"https://static001.geekbang.org/account/avatar/00/12/35/fc/6d3e0035.jpg","nickname":"saber","note":"","ucode":"D02F8D129DB41C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20360,"discussion_content":"带射手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569305138,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5319,"ip_address":""},"score":20360,"extra":""}]},{"author":{"id":2667834,"avatar":"https://static001.geekbang.org/account/avatar/00/28/b5/3a/606c0461.jpg","nickname":"方帆","note":"","ucode":"A64549063EC3C2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385202,"discussion_content":"从数组存储来看，往完全二叉树那个结构靠，会更紧密，节约空间，这是用右子树最小节点和左子树最大节点替换的区别之一吧","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1626942222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2189412,"avatar":"https://static001.geekbang.org/account/avatar/00/21/68/64/7f6f0dfd.jpg","nickname":"凌风","note":"","ucode":"7069D4BD8C8DCB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309468,"discussion_content":"你这不是明摆着可以吗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601297296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1939316,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/97/74/a933d664.jpg","nickname":"莜戏","note":"","ucode":"C3488A2BB44359","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2189412,"avatar":"https://static001.geekbang.org/account/avatar/00/21/68/64/7f6f0dfd.jpg","nickname":"凌风","note":"","ucode":"7069D4BD8C8DCB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381241,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624965420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309468,"ip_address":""},"score":381241,"extra":""}]},{"author":{"id":1039466,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/dc/6a/b5478b65.jpg","nickname":"Ab","note":"","ucode":"8E9261782F025D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164005,"discussion_content":"精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581136590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":39921,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1542385470,"is_pvip":false,"replies":[{"id":"14690","content":"是的 钻研精神值得称赞👍","user_name":"作者回复","comment_id":39921,"uid":"1190123","ip_address":"","utype":1,"ctime":1542680370,"user_name_real":"gg"}],"discussion_count":9,"race_medal":0,"score":"572773035838","product_id":100017301,"comment_content":"1、思考题：leetcode 104 题，可以使用递归法。<br>递归公式： depth =Math.max(maxDepth(node.left), maxDepth(node.right) )+ 1;<br>递归出口： depth = 0 (node == null)<br>2、二叉查找树的删除操作（无重复的数据）leetcode 450。<br>根据老师的思路，先不看代码，自己写了好长段时间，写出来都跑过leetcode的所有案例。回过头来再看老师的删除的代码，感觉到了巧妙之处就是：当删除节点有两个子节点的情况，很巧得一起套用了删除结点子节点个数小于1的两种场景。","like_count":133,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429295,"discussion_content":"是的 钻研精神值得称赞👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542680370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1270780,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8AdNibZHbZriaqLQZrNPcX8hVOpY91o0ELl7eOq7qy3aTibjia10ymIsKUKW6Ucs9SuXBDWlg6sjahw/132","nickname":"逆舟","note":"","ucode":"B303B4B8E10E0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":230633,"discussion_content":"我觉得这个套用并不好，为了套用2行对性能影响很小的代码，牺牲了可读性。我当时看到一半都有点懵，为啥不直接删了了事，还在那里保存赋值。看到后面才明白是为了复用逻辑。问题是这个删除并不费事，而且代码量也不大，没有复用的必要吧","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1586758348,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2895981,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/30/6d/a678c9a2.jpg","nickname":"Return to zero","note":"","ucode":"074C9B1B4CBF18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572235,"discussion_content":"我觉的这个更好理解\n\n找到右子树的最小值，赋给要删除的节点，再将右子树的最小值删除；\n左子树同理\n\n\n\nclass Solution {\n\tpublic int rightMin(TreeNode root) {//1.找到以某个结点为根节点的右子树最小值。\n\t\troot = root.right;\n\t\twhile (root.left != null) root = root.left;\n\t\treturn root.val;\n\t}\n\n\tpublic int leftMax(TreeNode root) {//2.找到以某个结点为根节点的左子树最大值。\n\t\troot = root.left;\n\t\twhile (root.right != null) root = root.right;\n\t\treturn root.val;\n\t}\n\n\tpublic TreeNode deleteNode(TreeNode root, int key) {\n\t\tif (root == null) {//3.递归终止条件\n\t\t\treturn null;\n\t\t}\n\t\tif (key &gt; root.val) {//4.如果查找的结点比根节点大，继续在右子树查找删除该结点\n\t\t\troot.right = deleteNode(root.right, key);\n\t\t} else if (key &lt; root.val) {//5.如果查找的结点比根节点小，继续在左子树查找删除该结点\n\t\t\troot.left = deleteNode(root.left, key);\n\t\t} else {//6.如果找到了该结点，删除它\n\t\t\tif (root.left == null &amp;&amp; root.right == null) {//7.以叶子节点为根节点的二叉搜索树只有一个元素，可以直接删除。\n\t\t\t\troot = null;\n\t\t\t} else if (root.right != null) {//8.如果有右子树，只要找到该右子树的最小值来替换，之后将它删除即可。\n\t\t\t\troot.val = rightMin(root);\n\t\t\t\troot.right = deleteNode(root.right, root.val);//9.将这个右子树的最小值替换根节点，此时存在两个相同节点，将这个节点删除即可。\n\t\t\t} else {//10.如果有左子树，只要找到该左子树的最大值来替换，之后将它删除即可。\n\t\t\t\troot.val = leftMax(root);\n\t\t\t\troot.left = deleteNode(root.left, root.val);//9.将这个左子树的最大值替换根节点，此时存在两个相同节点，将这个节点删除即可。\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t}\n}","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1652668945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1412958,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJfUqEKHvN0oBKV9aGhrNNLfVyQnAjYCTDPqAZicS8Eu2R5tfUHB0LbyhBTtdxaSG3b4SsPLM18MUg/132","nickname":"TBAB","note":"","ucode":"E44FFC17C45E08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250017,"discussion_content":"是的，这个删除贼溜","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587983910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319218,"discussion_content":"技巧确实很巧。但是易读性不好。。哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603964766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2285861,"avatar":"https://static001.geekbang.org/account/avatar/00/22/e1/25/4b4e8c69.jpg","nickname":"liuzhijie","note":"","ucode":"5D475A9FF41E10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1204353,"avatar":"https://static001.geekbang.org/account/avatar/00/12/60/81/eaf6d0ac.jpg","nickname":"拉布拉多","note":"","ucode":"637A88D9F29F57","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334899,"discussion_content":"我刚开始都没有看懂，后来自己写了一个，根据删除节点有无左右子节点，分了4种情况。。。。写完后再回头看老师的代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608022324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319218,"ip_address":""},"score":334899,"extra":""}]},{"author":{"id":2172520,"avatar":"https://static001.geekbang.org/account/avatar/00/21/26/68/b86dc4df.jpg","nickname":"R","note":"","ucode":"3721FC8C8DE174","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308898,"discussion_content":"是的，这个特别厉害，表面上是有三种情况，然后就转换成了两种情况。其一，待删除结点有左子结点或右子结点；其二，待删除结点无子结点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601115699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004953,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/55/99/4bdadfd3.jpg","nickname":"Chloe","note":"","ucode":"C4848ED5B35752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245753,"discussion_content":"我觉得老师的写法非常妙，可能是我自己写完code 自认为太长不满意，回头看老师的，觉得太巧妙了，反而大赞老师的写法妙！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587697333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1339712,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/40/46e1e8b5.jpg","nickname":"北方有盛筵","note":"","ucode":"CFA8ADA67B30CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36803,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571444641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38946,"user_name":"一般社员","can_delete":false,"product_type":"c1","uid":1065903,"ip_address":"","ucode":"BC2E4C9E57E3AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/af/08fc10fe.jpg","comment_is_top":false,"comment_ctime":1542161270,"is_pvip":false,"discussion_count":17,"race_medal":0,"score":"216290526070","product_id":100017301,"comment_content":"老师，不理解删除有两个子节点那段代码，最后删除minp，不是minpp.left =null,minp =null吗","like_count":50,"discussions":[{"author":{"id":1238514,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/f2/21ea4d37.jpg","nickname":"独舟泛海","note":"","ucode":"E35C8CEFAF062D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":45647,"discussion_content":"删除具有左右子节点是分为两步：\n1.找到要删除节点的右子树中的最小节点，将后将其值copy到要删除的节点\n2.删除右子树中的最小节点\n\n由于右子树中的最小节点只可能是有一个右子节点或者没有子节点，所以，老师的代码中，是将第二步骤，放到了删除只有一个子节点或者没有子节点的范围内\n\n不知道我是否讲清楚了？","likes_number":17,"is_delete":false,"is_hidden":false,"ctime":1573053312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1238514,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/f2/21ea4d37.jpg","nickname":"独舟泛海","note":"","ucode":"E35C8CEFAF062D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293121,"discussion_content":"也就是说删除节点只有一个子节点或没有子节点的逻辑也包含了对删除节点有2个子节点这种情况的处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595435768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":45647,"ip_address":""},"score":293121,"extra":""}]},{"author":{"id":1154688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9e/80/b87f8b49.jpg","nickname":"LongXiaJun","note":"","ucode":"B5246BF0DAF4F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2708,"discussion_content":"这个地方的精妙之处在于，将所有的实际删除操作放到了最后，你这样的话需要直接return才行。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1563872787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1154688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9e/80/b87f8b49.jpg","nickname":"LongXiaJun","note":"","ucode":"B5246BF0DAF4F7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7268,"discussion_content":"不懂你这句是什么意思，能否再仔细说明一下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567442186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2708,"ip_address":""},"score":7268,"extra":""},{"author":{"id":1647304,"avatar":"https://static001.geekbang.org/account/avatar/00/19/22/c8/f2892022.jpg","nickname":"科科","note":"","ucode":"7DAE6FE781172E","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1250807,"avatar":"https://static001.geekbang.org/account/avatar/00/13/15/f7/744720a2.jpg","nickname":"DriveMan_邱佳源","note":"","ucode":"A4C83BF07DEE7A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29226,"discussion_content":"仔细看一下代码里面只是确认了值为data的那个结点的位置，然后将该位置的data替换为右子树中的最小值。节点的删除操作是放在下面的，就是在Node child下面。首先是确定删除的那个节点是否是有左右子树的，找到它的继任者。之后就是判断这个位置是否是root。因为是root的话还需要进行特殊的处理。多看几遍就清楚了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1570756208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7268,"ip_address":""},"score":29226,"extra":""},{"author":{"id":1134861,"avatar":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","nickname":"James","note":"","ucode":"48B0F2A334D1C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1154688,"avatar":"https://static001.geekbang.org/account/avatar/00/11/9e/80/b87f8b49.jpg","nickname":"LongXiaJun","note":"","ucode":"B5246BF0DAF4F7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37247,"discussion_content":"最好边看老师的图,看代码就自然而然就明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571558645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":2708,"ip_address":""},"score":37247,"extra":""}]},{"author":{"id":2206029,"avatar":"https://static001.geekbang.org/account/avatar/00/21/a9/4d/c64803ea.jpg","nickname":"ZJUZZ","note":"","ucode":"E1E3446BC85592","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323799,"discussion_content":"现在回复是不是有点晚了。我也看了两遍。p和pp是用来删除叶子节点或者有一个子节点的。minp和minpp是将右子树最小值换到需要删除位置之后，在叶子部分需要删除的节点，刚好套用下面的代码，代码更简洁。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1604997834,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2528400,"avatar":"https://static001.geekbang.org/account/avatar/00/26/94/90/6179f6a3.jpg","nickname":"吴云展","note":"","ucode":"1EC1594D1CE5EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2206029,"avatar":"https://static001.geekbang.org/account/avatar/00/21/a9/4d/c64803ea.jpg","nickname":"ZJUZZ","note":"","ucode":"E1E3446BC85592","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393454,"discussion_content":"看了半天没看懂，直奔评论区，看了你的回复终于明白了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631439437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":323799,"ip_address":""},"score":393454,"extra":""}]},{"author":{"id":1463926,"avatar":"https://static001.geekbang.org/account/avatar/00/16/56/76/e8200041.jpg","nickname":"沐风","note":"","ucode":"6675574198ABCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":262517,"discussion_content":"这里首先要理解值传递和引用传递的区别，\n可以结合删除那段代码上面的那张图来理解：\n需要删除的是18那个节点，而18有两个子节点，删除之后需要补上来，究其根本，最终只需要将18后最左边的节点（也就是19那个节点）与18节点替换就可以了，有点李代桃僵的意思。\np.data = minP.data; // 就是需要将19节点的值传给18节点位置，注意此时p指代的依旧是18那个节点\np = minP; // p用来指向最终需要被删除的那个节点，即图中的19节点（此时已经和之前的18节点没有半毛钱关系了），后续操作只需要考虑p就可以了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1589109165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2440496,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3d/30/9e5e5d4d.jpg","nickname":"巴菲特不非","note":"","ucode":"9E2B911ED5BF08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1463926,"avatar":"https://static001.geekbang.org/account/avatar/00/16/56/76/e8200041.jpg","nickname":"沐风","note":"","ucode":"6675574198ABCE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353111,"discussion_content":"那p指向19节点后，不用将它的左子树和右子树分别指向17节点和25节点吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615012896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":262517,"ip_address":""},"score":353111,"extra":""},{"author":{"id":1248350,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/5e/7fda4bd1.jpg","nickname":"skyimple","note":"","ucode":"15BEDC0F0854EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2440496,"avatar":"https://static001.geekbang.org/account/avatar/00/25/3d/30/9e5e5d4d.jpg","nickname":"巴菲特不非","note":"","ucode":"9E2B911ED5BF08","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551468,"discussion_content":"【值传递】p.data = minP.data只是把 原始图18位置的值替换为了19，没有改变18的左子树和右子树，此时p还是原始图18的位置；\n【引用传递】p = minP 此时p已经不是原始图18的位置，已经是原始图19的位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645021369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":353111,"ip_address":""},"score":551468,"extra":""}]},{"author":{"id":1107204,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/04/c3ea6b49.jpg","nickname":"maxiaowen","note":"","ucode":"A3747CDC98E2BA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281753,"discussion_content":"\n想请教下各位，删除节点有左右子节点的情况，算删除节点右子树中的最小节点时，代码中只一直在删除节点右子节点的左子节点中找最小值，有没有可能其右子节点的右子节点27还有个左子节点数据值比19小","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591800355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2064338,"avatar":"","nickname":"janeing","note":"","ucode":"CE091BAF9645E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1107204,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e5/04/c3ea6b49.jpg","nickname":"maxiaowen","note":"","ucode":"A3747CDC98E2BA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293224,"discussion_content":"25的右子树的所有节点都大于25  不然查找树就没意义了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595485968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":281753,"ip_address":""},"score":293224,"extra":""}]},{"author":{"id":1274922,"avatar":"https://static001.geekbang.org/account/avatar/00/13/74/2a/c66beb00.jpg","nickname":"山子","note":"","ucode":"39289FB65FB834","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255022,"discussion_content":"简单来说，p就是要删除的节点，老师的代码是先交换，交换后，删除的就变成叶子节点了，很容易理解啊，不要把p当成data，p是要删除的节点的引用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588349552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":43536,"user_name":"沉稳心","can_delete":false,"product_type":"c1","uid":1238450,"ip_address":"","ucode":"C91CD532ECDE0C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/b2/56498c5c.jpg","comment_is_top":false,"comment_ctime":1543237845,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"199111733461","product_id":100017301,"comment_content":"姜威老大没写总结笔记了吗？我是个算法菜鸟萌新，一直看着姜大佬的笔记总结学习。。。","like_count":45,"discussions":[{"author":{"id":1994946,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/70/c2/d3b890ec.jpg","nickname":"刘晓冬","note":"","ucode":"0AC9F3B87FB9C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299865,"discussion_content":"我也找了半天","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597843670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1239546,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKWiaZb7a2JAcIVlXYuZ3iaPfSF6vBbg3yUps6LKpsZarftyXufMHYKJmMKzH3bIpVkDAVNXE9q0oOw/132","nickname":"Mr_scx","note":"","ucode":"28B5CE68A5A339","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":101068,"discussion_content":"同问哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577283623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39353,"user_name":"Geek_41d472","can_delete":false,"product_type":"c1","uid":1247965,"ip_address":"","ucode":"DEC2B6329460CF","user_header":"https://static001.geekbang.org/account/avatar/00/13/0a/dd/88fa7b52.jpg","comment_is_top":false,"comment_ctime":1542252447,"is_pvip":false,"replies":[{"id":"14106","content":"😄 是不好看懂","user_name":"作者回复","comment_id":39353,"uid":"1190123","ip_address":"","utype":1,"ctime":1542280040,"user_name_real":"gg"}],"discussion_count":6,"race_medal":0,"score":"138981205919","product_id":100017301,"comment_content":"p.data = minP.data; &#47;&#47; 将 minP 的数据替换到 p 中<br>p = minP; &#47;&#47; 下面就变成了删除 minP 了<br>pp = minPP;<br><br><br>总于看明白这段代码了……各位老铁，单纯看这3行代码是看不出是删除后继节点的，是要结合后面的代码来看的……不过说实话这种代码是不好看的懂……","like_count":32,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429024,"discussion_content":"😄 是不好看懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2449060,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","nickname":"Geek_sz","note":"","ucode":"72E86D7D6554CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":591317,"discussion_content":"那段删除的代码有问题哦，能不能专业点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666494860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":429024,"ip_address":"广东"},"score":591317,"extra":""}]},{"author":{"id":1412958,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJfUqEKHvN0oBKV9aGhrNNLfVyQnAjYCTDPqAZicS8Eu2R5tfUHB0LbyhBTtdxaSG3b4SsPLM18MUg/132","nickname":"TBAB","note":"","ucode":"E44FFC17C45E08","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":250019,"discussion_content":"这三行是把要删除的节点的值替换为某一个叶节点的值，然后删除该叶节点","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1587984082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1712470,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/21/56/91669d26.jpg","nickname":"mawei","note":"","ucode":"07DACA0F8BA65D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51628,"discussion_content":"还是没看懂，p=minP 难道不会把minP.data赋值给p.data, 这样赋值不会改变原先p的左右指针指向？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573910869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1593762,"avatar":"https://static001.geekbang.org/account/avatar/00/18/51/a2/84e9efe2.jpg","nickname":"马祖晖","note":"","ucode":"7866916C8EF9DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1712470,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/21/56/91669d26.jpg","nickname":"mawei","note":"","ucode":"07DACA0F8BA65D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326869,"discussion_content":"我是用python写的，在python里面如果一个引用指向的是一个可变对象（在这个例子里面就是p.value），前面那个可变对象的值会被修改为等号后面的值；如果该引用指向一个不可变对象（一个Node实例，也就是王争老师的做法），该引用（也就是p）会指向等号后面的对象，引用原本指向的对象不会被修改。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605692277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51628,"ip_address":""},"score":326869,"extra":""}]},{"author":{"id":1677187,"avatar":"https://static001.geekbang.org/account/avatar/00/19/97/83/845b48e2.jpg","nickname":"Allen_","note":"","ucode":"CA5E00E4644CD5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":96707,"discussion_content":"谢谢你的分享，其他同学学一下这位怎么回答问题。而不是说多看几遍就行了。实在分享其实也会使你进步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577087856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":75750,"user_name":"陆老师","can_delete":false,"product_type":"c1","uid":1203293,"ip_address":"","ucode":"0EA27C4755FF4A","user_header":"https://static001.geekbang.org/account/avatar/00/12/5c/5d/974b033f.jpg","comment_is_top":false,"comment_ctime":1552463078,"is_pvip":false,"replies":[{"id":"27709","content":"是的，👍","user_name":"作者回复","comment_id":75750,"uid":"1190123","ip_address":"","utype":1,"ctime":1552531654,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"100336710886","product_id":100017301,"comment_content":"有一种更容易理解复杂度的思路，二叉查找树类似二分法搜索，每次缩小一半的区间，而二分查找法时间复杂度就是logN","like_count":23,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443014,"discussion_content":"是的，👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552531654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2743868,"avatar":"https://static001.geekbang.org/account/avatar/00/29/de/3c/95daef8d.jpg","nickname":"东哥的小弟c","note":"","ucode":"471B2683393D4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390602,"discussion_content":"你得是平衡的才是log N","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629928841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1007000,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/98/98fe8de3.jpg","nickname":"zcqshine","note":"","ucode":"9DABA78369344E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":17398,"discussion_content":"binary search； binary search tree，看名称就有相通之处","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568967286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39216,"user_name":"一个慢慢爬行的普通人","can_delete":false,"product_type":"c1","uid":1193589,"ip_address":"","ucode":"D38C25E119BCD7","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/75/e346e04e.jpg","comment_is_top":false,"comment_ctime":1542210948,"is_pvip":false,"replies":[{"id":"14042","content":"好的。我们用后继节点替换到要删除节点的位置。 然后就变成删除后继节点的问题了。为了逻辑统一 代码书写简洁。我们把后继节点赋给了p","user_name":"作者回复","comment_id":39216,"uid":"1190123","ip_address":"","utype":1,"ctime":1542247045,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"74556654980","product_id":100017301,"comment_content":"p = minP; &#47;&#47; 下面就变成了删除 minP 了...<br>pp = minPP;<br>老师，对这里不太搞懂，似乎也有些人对这里感到困惑，老师可以对这两句集中解释下嘛","like_count":17,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428967,"discussion_content":"好的。我们用后继节点替换到要删除节点的位置。 然后就变成删除后继节点的问题了。为了逻辑统一 代码书写简洁。我们把后继节点赋给了p","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542247045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575684,"discussion_content":"如果不理解老师写的，可以自己尝试去用自己理解的方式去写，然后再来对比老师写的，就知道老师为啥要这么写了。另外，如果实在钻不透，不要硬看，用IDE把老师的代码debug一遍就啥都明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655024515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":60441,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1547472467,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"57382047315","product_id":100017301,"comment_content":"连续看好几遍，每一次的感受都更深刻，谢谢老师。可是有一点要吐槽下，老师给变量命名也有点太随意了啊，二叉树删除节点那个，好多p啊，看的晕了都","like_count":13,"discussions":[{"author":{"id":2449060,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/a4/d48b8298.jpg","nickname":"Geek_sz","note":"","ucode":"72E86D7D6554CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591318,"discussion_content":"老王想p了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666494928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396126,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","nickname":"SteelHuaSheng","note":"","ucode":"BC8127FC5207FC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215144,"discussion_content":"其实变量名称还好，起的都是符合实际的名称，就是“下面就变成了删除minP了”这时候p和pp复用了一下。多看两遍，我刚开始也是懵逼。看半天。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585290797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1270780,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er8AdNibZHbZriaqLQZrNPcX8hVOpY91o0ELl7eOq7qy3aTibjia10ymIsKUKW6Ucs9SuXBDWlg6sjahw/132","nickname":"逆舟","note":"","ucode":"B303B4B8E10E0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1396126,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","nickname":"SteelHuaSheng","note":"","ucode":"BC8127FC5207FC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":230637,"discussion_content":"哈哈 看来同感啊 更可恶是那个注释误导人，不加注释还好些。 我说怎么 赋值就成了删除了呢。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586758466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":215144,"ip_address":""},"score":230637,"extra":""}]}]},{"had_liked":true,"id":38875,"user_name":"莫弹弹","can_delete":false,"product_type":"c1","uid":1239978,"ip_address":"","ucode":"60A25C709A665F","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/aa/db213a66.jpg","comment_is_top":false,"comment_ctime":1542156343,"is_pvip":false,"replies":[{"id":"13891","content":"👍","user_name":"作者回复","comment_id":38875,"uid":"1190123","ip_address":"","utype":1,"ctime":1542159485,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"53081763895","product_id":100017301,"comment_content":"在sf的微信公众号上刚好看到二叉树相关的文章，二叉树常规操作都有了，基本思路是：<br><br>- 只有一个根结点时，二叉树深度为 1<br>- 只有左子树时，二叉树深度为左子树深度加 1<br>- 只有右子树时，二叉树深度为右子树深度加 1<br>- 同时存在左右子树时，二叉树深度为左右子树中深度最大者加 1<br><br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;ONKJyusGCIE2ctwT9uLv9g","like_count":12,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428835,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542159485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1454534,"avatar":"https://static001.geekbang.org/account/avatar/00/16/31/c6/f08d1ac5.jpg","nickname":"康","note":"","ucode":"4B1D729C903D1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545478,"discussion_content":"这个说法和你画图的解释冲突，为什么也是点赞？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641972460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":428835,"ip_address":""},"score":545478,"extra":""},{"author":{"id":1454534,"avatar":"https://static001.geekbang.org/account/avatar/00/16/31/c6/f08d1ac5.jpg","nickname":"康","note":"","ucode":"4B1D729C903D1F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545479,"discussion_content":"我结合了之前写的计算深度的代码，你画图的那个深度的计算，是不是错了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641972680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":428835,"ip_address":""},"score":545479,"extra":""}]}]},{"had_liked":false,"id":90858,"user_name":"李沁","can_delete":false,"product_type":"c1","uid":1042928,"ip_address":"","ucode":"A7239F8C2470B8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/f0/7c8ea410.jpg","comment_is_top":false,"comment_ctime":1556694715,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"48801334971","product_id":100017301,"comment_content":"这两句代码一开始看得很晕<br>p = minP; &#47;&#47; 下面就变成了删除 minP 了<br>pp = minPP;<br><br>后面想到其实代码还没有终结，如果minP是右子树的最左节点，那么这个节点肯定是没有左子树的。<br>这步操作其实可以理解为把这个节点标记要删除，用后面的删除只有一个子树或没有子树的节点的逻辑去做","like_count":11,"discussions":[{"author":{"id":2813766,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erX65FTLyn3JMbqLKdFkkv9okdx7qmVIibl1zKB7pnCIbtElSgibULma5cTsSMyS5KGMBy5MRdXtN8g/132","nickname":"小竹子","note":"","ucode":"D20F56114426EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532541,"discussion_content":"谢谢，结合后面的代码看，看明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637638895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1396126,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","nickname":"SteelHuaSheng","note":"","ucode":"BC8127FC5207FC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215146,"discussion_content":"是的，这两句刚看容易犯糊涂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585290858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":40139,"user_name":"PhilZhang","can_delete":false,"product_type":"c1","uid":1088010,"ip_address":"","ucode":"383F1A792C7DF9","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/0a/922615cf.jpg","comment_is_top":false,"comment_ctime":1542521638,"is_pvip":false,"replies":[{"id":"14490","content":"👍 ","user_name":"作者回复","comment_id":40139,"uid":"1190123","ip_address":"","utype":1,"ctime":1542589046,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"44492194598","product_id":100017301,"comment_content":"对于二叉搜索树各种操作的复杂度，有更容易理解的解释方法:每次操作后数据量都减少了一半，所以复杂度自然是logN。","like_count":10,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429391,"discussion_content":"👍 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542589046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374625,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/a1/ac36884c.jpg","nickname":"胡光","note":"","ucode":"601F29A45FC1E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239420,"discussion_content":"树形结构本来就代表了集合关系，本来就应该这样理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587299713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38950,"user_name":"Ryan-Hou","can_delete":false,"product_type":"c1","uid":1006864,"ip_address":"","ucode":"5B703C1E1596A5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5d/10/0acf7cbc.jpg","comment_is_top":false,"comment_ctime":1542161473,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40196867137","product_id":100017301,"comment_content":"平衡树相比于哈希表，保存了节点数据间的顺序信息，所以操作的时间复杂度上会比哈希表大(因为额外的提供了顺序性，对应的会有代价)。也正因为保存了顺序性，平衡树可以方便的实现min, max, ceil, floor 等操作，所以个人认为这两种数据结构最大的不同在于这里，有不同的取舍","like_count":9,"discussions":[{"author":{"id":1115041,"avatar":"https://static001.geekbang.org/account/avatar/00/11/03/a1/e6a0f60b.jpg","nickname":"Sid","note":"","ucode":"0461B574B2736B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540475,"discussion_content":"以及range查询，hash表更适用于单值查询","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640064740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40112,"user_name":"TryTs","can_delete":false,"product_type":"c1","uid":1036276,"ip_address":"","ucode":"1DD1E974D461A1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/f4/26b95f0b.jpg","comment_is_top":false,"comment_ctime":1542505766,"is_pvip":false,"replies":[{"id":"14492","content":"编程能带来成就感 而且这种成就感很容易获得   <br>最有创意的我一时半会还真想不起来 感觉做的项目都一般","user_name":"作者回复","comment_id":40112,"uid":"1190123","ip_address":"","utype":1,"ctime":1542589371,"user_name_real":"gg"}],"discussion_count":3,"race_medal":0,"score":"35902244134","product_id":100017301,"comment_content":"老师我想请教一下你，就你而言，编程最大的乐趣在什么地方？你用编程做过最有创意的项目是什么？","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429376,"discussion_content":"编程能带来成就感 而且这种成就感很容易获得   \n最有创意的我一时半会还真想不起来 感觉做的项目都一般","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542589371,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2609930,"avatar":"https://static001.geekbang.org/account/avatar/00/27/d3/0a/92640aae.jpg","nickname":"我爱夜来香","note":"","ucode":"10761E677EF05F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574055,"discussion_content":"搁这面试呢\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653815546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1611025,"avatar":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","nickname":"沈康","note":"","ucode":"02AFA50738AB8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291465,"discussion_content":"牛啊，感觉都一般。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594825507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54665,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1545926933,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"31610698005","product_id":100017301,"comment_content":"装载因子太大，不是浪费空间，而是节省空间吧？","like_count":7,"discussions":[{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383007,"discussion_content":"老师的意思是：为了减少散列冲突，需要装载因子不能太大，因此会浪费空间","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1625821893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2435907,"avatar":"https://static001.geekbang.org/account/avatar/00/25/2b/43/f168aa47.jpg","nickname":"一叶知秋","note":"","ucode":"617B8DC737BE43","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351520,"discussion_content":"把不然两个字去掉就通顺了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614310666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003207,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4e/c7/8c2d0a3d.jpg","nickname":"余泽锋","note":"","ucode":"5AB1499746C003","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308294,"discussion_content":"装载因子过大，哈希冲突概率变大，影响散列表性能发挥，也可以算是存储的浪费。调小装载因子，提高散列表性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600909528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1268797,"avatar":"https://static001.geekbang.org/account/avatar/00/13/5c/3d/e8325811.jpg","nickname":"对白","note":"","ucode":"3183E5ADBC794B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296792,"discussion_content":"填装因子大说明散列表中空位很少，用开放寻址法解决散列冲突就需要对散列表进行扩容，而扩容一般是扩大一倍散列表，因此会浪费一定的存储空间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596653911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":237690,"discussion_content":"装载因子大，哈希冲突概率增大，链表法需要额外的空间保存数据。如果是开放地址法，说明哈希冲突概率低，哈希表空间就可以保存，不需要额外的空间。这两者都是在不扩容的前提下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587177972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39356,"user_name":"追风者","can_delete":false,"product_type":"c1","uid":1055092,"ip_address":"","ucode":"879BC372A6B605","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","comment_is_top":false,"comment_ctime":1542253113,"is_pvip":false,"replies":[{"id":"14105","content":"好的 基础篇完了后会集中答疑一下","user_name":"作者回复","comment_id":39356,"uid":"1190123","ip_address":"","utype":1,"ctime":1542280023,"user_name_real":"gg"}],"discussion_count":2,"race_medal":0,"score":"31607024185","product_id":100017301,"comment_content":"更新二十多篇了，王老师把前面文章的课后思考题都总结回答一下吧。","like_count":7,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429026,"discussion_content":"好的 基础篇完了后会集中答疑一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1716067,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","nickname":"梨子苹果","note":"","ucode":"3666813FEE31D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":86935,"discussion_content":"老师先处理有两个子节点的用意总算是看明白了，因为处理有两个子节点的删除，会遗留右子树最小节点删除的问题，因为右子树最小节点删除的场景也是只有一个子节点的情况，所以就和删除节点只有左或者右节点的场景相同了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576633120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":164257,"user_name":"punnpkin","can_delete":false,"product_type":"c1","uid":1691517,"ip_address":"","ucode":"E635BD016D892F","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/7d/d9085aaa.jpg","comment_is_top":false,"comment_ctime":1576917514,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27346721290","product_id":100017301,"comment_content":"删除节点的第三种情况，最后要删除节点的右子树的最小节点，其实就是删除节点的前两种（因为它不会有左子树，只可能有右子树或是没有子树）","like_count":6,"discussions":[{"author":{"id":1232033,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cc/a1/688f86f3.jpg","nickname":"闻人正卿","note":"","ucode":"0C0DD391DF8F7F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355114,"discussion_content":"一样的想法。老师贴出来的删除代码中获取Node child这一块应该是可以直接改成Node child = p.right","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615383841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1243570,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/b2/2ed800b4.jpg","nickname":"社会你强哥","note":"","ucode":"325B9005588D9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174699,"discussion_content":"说得很对，我也在这个地方疑惑着。想法相同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581935965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115679,"user_name":"Edward Lee","can_delete":false,"product_type":"c1","uid":1228518,"ip_address":"","ucode":"156223F1D7E94A","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","comment_is_top":false,"comment_ctime":1563695956,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27333499732","product_id":100017301,"comment_content":"虽然删除算法容易理解，但写起来真的非常吃力，通过不断优化的方式写出让自己感到最满意的代码才能印象深刻。<br><br>递归方式<br>var deleteNode = function(root, key) {<br>    if (!root) return null<br>    if (key &gt; root.val) {<br>        root.right = deleteNode(root.right, key)<br>    } else if (key &lt; root.val) {<br>        root.left = deleteNode(root.left, key)<br>    } else {<br>        if (!root.right) return root.left<br>        if (!root.left) return root.right<br>        let n = root.right<br>        while (n.left) n = n.left<br>        n.left = root.left<br>        return root.right<br>    }<br>    return root<br>}<br><br><br>非递归方式<br>var deleteNode = function(root, key) {<br>    if (!root) return null<br>    let n = root, p<br>    while (n &amp;&amp; n.val !== key) {<br>        p = n<br>        key &gt; n.val ? n = n.right : n = n.left<br>    }<br>    if (!n) return root<br>    let remainNode<br>    if (!n.left) remainNode = n.right<br>    if (!n.right) remainNode = n.left<br>    if (n.left &amp;&amp; n.right) {<br>        let min = n.right<br>        while (min.left) min = min.left<br>        min.left = n.left<br>        remainNode = n.right<br>    }<br>    if (!p) return remainNode<br>    p.left === n ? p.left = remainNode : p.right = remainNode<br>    return root<br>}","like_count":6,"discussions":[{"author":{"id":2016408,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","nickname":"罗杰.菲の樂","note":"","ucode":"63590706846EEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553667,"discussion_content":"这个算法通过了LeetCode所有test case么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646019109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1228518,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/e6/7808520d.jpg","nickname":"Edward Lee","note":"","ucode":"156223F1D7E94A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2016408,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c4/98/9c7a1a23.jpg","nickname":"罗杰.菲の樂","note":"","ucode":"63590706846EEA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554529,"discussion_content":"印象中是, leetcode 450","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646449953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553667,"ip_address":""},"score":554529,"extra":""}]}]},{"had_liked":false,"id":39330,"user_name":"李建辉","can_delete":false,"product_type":"c1","uid":1260109,"ip_address":"","ucode":"55999CB5FFA3B3","user_header":"https://static001.geekbang.org/account/avatar/00/13/3a/4d/a3237b34.jpg","comment_is_top":false,"comment_ctime":1542249900,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27312053676","product_id":100017301,"comment_content":"看了下老师显示的代码，发现老师的删除二叉查找树节点的代码写的有点问题，为此自己实现了一下，希望老师指正：<br>先说老师代码问题所在：<br>    p.data = minP.data; &#47;&#47; 将 minP 的数据替换到 p 中<br>    p = minP; &#47;&#47; 下面就变成了删除 minP 了<br>    pp = minPP;<br>这里是有问题的，感觉正确的应该是<br>findNode.setData(minP.getData());&#47;&#47;覆盖原来的值<br>minPP.setLeftNode(minP.getRightNode());&#47;&#47;替代删除节点的父节点的左节点指向替代删除节点的右节点<br><br>贴上自己的删除代码：<br>\t&#47;**<br>\t * 删除查找二叉树的一个节点<br>\t * @param root<br>\t * @param value<br>\t *&#47;<br>\tpublic static void delete(Node root,int value) {<br>\t\tNode findNode = root; &#47;&#47;记录当前要删除的节点<br>\t\tNode fatherNode = null; &#47;&#47;记录删除节点的父节点<br>\t\twhile (findNode != null &amp;&amp; findNode.getData() != value) {<br>\t\t\tfatherNode = findNode;<br>\t\t\tif (findNode.getData() &lt; value) {<br>\t\t\t\tfindNode = findNode.getRightNode();<br>\t\t\t} else if (findNode.getData() &gt; value) {<br>\t\t\t\tfindNode = findNode.getLeftNode();<br>\t\t\t}<br>\t\t}<br>\t\tif (findNode != null) {<br>\t\t\tif (findNode.getLeftNode() != null &amp;&amp; findNode.getRightNode() != null) {&#47;&#47;要删除节点 左节点和右节点都存在<br>\t\t\t\tNode minP = findNode.getRightNode(); &#47;&#47;minP是获取右节点下面的最小节点<br>\t\t\t\tNode minPP = findNode; &#47;&#47;minPP是minP的父节点<br>\t\t\t\twhile (minP.getLeftNode() != null) {<br>\t\t\t\t\tminPP = minP;<br>\t\t\t\t\tminP = minP.getLeftNode();<br>\t\t\t\t}<br>\t\t\t\tfindNode.setData(minP.getData());&#47;&#47;覆盖原来的值<br>\t\t\t\tminPP.setLeftNode(minP.getRightNode());&#47;&#47;替代删除节点的父节点的左节点指向替代删除节点的右节点<br>\t\t\t}else{&#47;&#47;要删除节点 左节点和右节点有一个存在  或全部都不存在<br>\t\t\t\tNode tidai = null;<br>\t\t\t\tif (findNode.getLeftNode() == null &amp;&amp; findNode.getRightNode() != null) {<br>\t\t\t\t\ttidai = findNode.getRightNode();<br>\t\t\t\t}<br>\t\t\t\tif (findNode.getLeftNode() != null &amp;&amp; findNode.getRightNode() == null) {<br>\t\t\t\t\ttidai = findNode.getLeftNode();<br>\t\t\t\t}<br>\t\t\t\tif (fatherNode == null) { &#47;&#47;父节点为空 即为根节点<br>\t\t\t\t\troot = tidai;<br>\t\t\t\t} else if (fatherNode.getRightNode().getData() == value) {<br>\t\t\t\t\tfatherNode.setRightNode(tidai);<br>\t\t\t\t} else {<br>\t\t\t\t\tfatherNode.setLeftNode(tidai);<br>\t\t\t\t}<br>\t\t\t}<br>\t\t}<br><br>\t}<br>","like_count":6,"discussions":[{"author":{"id":1650217,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/IiaDOdzAIYuicHsy8NRHzmCFib31kuMoNl89SVBicG5xnsV63lelyTFDFEcz8AvAUAZQh7JRdfjV65p00K8kq3b9JA/132","nickname":"Geek_03b663","note":"","ucode":"329CC5F2D489ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380061,"discussion_content":"应该是没问题的，data赋值后，p等于被删除了，p的子节点关系也就不用改变了，然后需要改变的就是minp的上下级关系了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624323886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41581,"user_name":"王子瑞Aliloke有事电联","can_delete":false,"product_type":"c1","uid":1249400,"ip_address":"","ucode":"9ABE8E475E336B","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/78/29bd3f1e.jpg","comment_is_top":false,"comment_ctime":1542809489,"is_pvip":false,"replies":[{"id":"14965","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542851478,"ip_address":"","comment_id":41581,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23017645969","product_id":100017301,"comment_content":"老师我有一个疑问，二叉树删除时，如果待删除节点有两个子节点，能否用左子树中的最大值来替换待删除节点呢？<br><br>是可以的，如果是用顺序存储，更容易浪费内存。更容易变成非完全二叉树。","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429848,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542851478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":44385,"user_name":"kakasi","can_delete":false,"product_type":"c1","uid":1237297,"ip_address":"","ucode":"64F357E6A08CA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/e1/31/eb103bdc.jpg","comment_is_top":false,"comment_ctime":1543417994,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"18723287178","product_id":100017301,"comment_content":"老师，看了二叉树的优点和适用场景，跳表不是都满足吗？","like_count":4,"discussions":[{"author":{"id":1221991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","nickname":"AllenGFLiu","note":"","ucode":"90FA8A619A2629","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286376,"discussion_content":"我認為我們現在學到的普通的二叉搜索樹確實意義不大,實際用的是後面的平衡二叉搜索樹,更穩定;而跳表中新插入節點時的不確定性相比而言可能不如平衡二叉查找樹.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1593151947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1640978,"avatar":"https://static001.geekbang.org/account/avatar/00/19/0a/12/f8b988b8.jpg","nickname":"Kyle(","note":"","ucode":"0C14C4C086CAA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1221991,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/67/bf286335.jpg","nickname":"AllenGFLiu","note":"","ucode":"90FA8A619A2629","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370499,"discussion_content":"台湾同胞吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619435580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286376,"ip_address":""},"score":370499,"extra":""}]},{"author":{"id":1488048,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/b0/508cbd6c.jpg","nickname":"phonexi","note":"","ucode":"ABCB885542617A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286935,"discussion_content":"跳表实现起来更难吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593327307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1900831,"avatar":"","nickname":"201200949","note":"","ucode":"7D0951A02248B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":275622,"discussion_content":"跳表不能做到有序吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590741549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1177430,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f7/56/b82eeac7.jpg","nickname":"champ可口可乐了","note":"","ucode":"EA75C67E9124C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1900831,"avatar":"","nickname":"201200949","note":"","ucode":"7D0951A02248B0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":283693,"discussion_content":"跳表本身不就是有序的吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592328310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":275622,"ip_address":""},"score":283693,"extra":""}]},{"author":{"id":1652836,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epKJlW7sqts2ZbPuhMbseTAdvHWnrc4ficAeSZyKibkvn6qyxflPrkKKU3mH6XCNmYvDg11tB6y0pxg/132","nickname":"pc","note":"","ucode":"1AD538B9A900B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":251076,"discussion_content":"再去看看跳跃表那篇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588063472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41944,"user_name":"james","can_delete":false,"product_type":"c1","uid":1260477,"ip_address":"","ucode":"CB62CF7C4EF92D","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/bd/f9f780a4.jpg","comment_is_top":false,"comment_ctime":1542878843,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18722748027","product_id":100017301,"comment_content":"散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费内存空间。<br>修改：应该是装在因子不能太小吧","like_count":4,"discussions":[{"author":{"id":1128059,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/7b/3788ca13.jpg","nickname":"冰风落叶","note":"","ucode":"E4DE480B95A17D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24909,"discussion_content":"应该是装载因子不能太大吧，达到装载因子才扩容，如果装载因子太大的话，证明散列表中的数据已经快满了，发生散列冲突的概率也就越大","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570328547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39088,"user_name":"雨天","can_delete":false,"product_type":"c1","uid":1056406,"ip_address":"","ucode":"FD9FB404ECA463","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/96/3162d51f.jpg","comment_is_top":false,"comment_ctime":1542186020,"is_pvip":false,"replies":[{"id":"14047","content":"图已经改正 多谢指出。<br>代码应该没错","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542247434,"ip_address":"","comment_id":39088,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18722055204","product_id":100017301,"comment_content":"老师:删除示例的25节点的右节点[21]错误;<br>删除节点有两个节点<br>p = minP; &#47;&#47; 下面就变成了删除 minP 了...<br>pp = minPP;<br>是不是应该改成: minPP.Left = minP.Right;","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428913,"discussion_content":"图已经改正 多谢指出。\n代码应该没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542247434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215720,"user_name":"Geek_ac7784","can_delete":false,"product_type":"c1","uid":1981613,"ip_address":"","ucode":"62F0E5E6D6F4BA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/8Dj4ugujXwY24G8pcpgDFGiciarXetG3ItQ4M9mSQMLyRdRRXEXXJVfib48mGUQAu87QcvImwyJIVJlEFeEguV44w/132","comment_is_top":false,"comment_ctime":1589083610,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14473985498","product_id":100017301,"comment_content":"学习笔记:<br>二叉查找树<br>1. 构建、插入:做大又小<br>2. 查询: 简单<br>3. 删除：前学过，但是从来没有记住过，这是最难的地方了。思考切入点在分类讨论。删除的节点有3种情况，没有孩子，有一个孩子，有两个孩子。0个一个孩子容易，将孩子给父节点就行了。两个孩子，就要找大于它的最小节点minP来替代它(应该小于它的最大值也行)了，然后再删除minP。大类分成两种情况。<br>4. 前驱后继、最大最小的代码<br>5. 处理相同数据：节点用动态扩容的数组或者链表来存储<br>6. 复杂度分析跟树的高度相关，最优O(logn),最差O(n)退化成链表。<br>7. 引出平衡二叉树。<br>8. 与散列表对比:顺序输出问题、哈希表复杂度(哈希函数、冲突解决)问题、空间浪费问题等决定哈希表不是万能的。<br>思考题:<br>        递归:  本树的高度等于子树的高度+1；终止条件子树为空，高度为0.","like_count":3},{"had_liked":false,"id":195185,"user_name":"谭方敏","can_delete":false,"product_type":"c1","uid":1710960,"ip_address":"","ucode":"728DC7ECB7C902","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1b/70/547042ee.jpg","comment_is_top":false,"comment_ctime":1585145205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14470047093","product_id":100017301,"comment_content":"二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值.<br><br>查找操作:<br>先取根节点，如果它等于我们要查找的数据，那就返回。<br>如果要查找的数据比根节点的值小，那就在左子树中递归查找。<br>如果要查找的数据比根节点的值大，那就在右子树递归查找.<br><br>插入操作：<br>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将数据直接插到右子节点的位置。<br>如果不为空，就再递归遍历右子树，查找插入位置。<br>如果要插入的数据比节点数值小，并且节点的左子树为空，就将数据插入到左子节点的位置<br>如果不为空，就再递归遍历左子树，查找插入位置。<br><br>删除操作：<br>1）要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null, 比如图中的删除节点55.<br>2）要删除的节点只有一个子节点(只有左子节点或者右子节点),我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就好了。<br>3）要删除的节点有两个子节点，我们需要找到这个节点的右子树中的最小节点，把他替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点(如果没有左子结点，那就不是最小节点了).<br><br>二叉查找树可以支持快速地查找最大节点和最小节点，前驱节点和后继节点.<br>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n),非常高效。<br><br>完全二叉树的高度小于等于log2n<br>平衡二叉查找树的高度接近logn.<br>插入，删除，查找的时间复杂度比较稳定，为O(logn).<br><br>散列表 vs 二叉查找树<br>1） 散列表是无序存储的，要有序的话，需要先排序， 二叉查找树，只需要中序遍历，就可以在O(n)时间复杂度内，输出有序的数据序列。<br><br>2) 散列表扩容耗时多，遇到散列冲突时，性能不稳定，常用的平衡二叉树性能稳定，时间复杂度稳定在O(logn)<br><br>3）一般来说，散列表查找，删除，插入操作的时间复杂度是常量级的。但因哈希冲突的存在，这个常量不一定比logn小，加上哈希函数的耗时，也就未必比平衡二叉查找树的效率高.<br><br>4) 散列表构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计，冲突接近方法，扩容，缩容等.<br>平衡二叉查找树只需要考虑平衡性这个问题。<br><br>5）为了避免过多的散列冲突，散列表装在因子不能太大，特别是基于开放寻址法接近冲突的散列表.<br><br>问题：<br>可以采用递归的办法max(depth(left), depth(right)) + 1.<br><br><br>","like_count":3},{"had_liked":false,"id":174272,"user_name":"【K E D E】","can_delete":false,"product_type":"c1","uid":1756555,"ip_address":"","ucode":"6206DD40FA7364","user_header":"https://static001.geekbang.org/account/avatar/00/1a/cd/8b/71b356ec.jpg","comment_is_top":false,"comment_ctime":1580115144,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14465017032","product_id":100017301,"comment_content":"确定二叉树的高度两种思路的代码（python）贴一下<br>1、递归，DFS<br>    def maxDepth(root: TreeNode) -&gt; int:<br>        if not root: return 0<br>        return max(maxDepth(root.left), maxDepth(root.right)) + 1<br>2、利用队列加序号的层序遍历<br>    import collections<br>    def maxDepth(root: TreeNode) -&gt; int:<br>        if not root: return 0<br>        deque = collections.deque([root])<br>        height = 0<br>        front, rear = 0, 1<br>        while(len(deque)):<br>            front += 1<br>            root = deque.popleft()<br>            if root.left: deque.append(root.left)<br>            if root.right: deque.append(root.right)<br>            if front == rear:<br>                front = 0<br>                rear = len(deque)<br>                height += 1<br>        return height","like_count":3,"discussions":[{"author":{"id":1238436,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/a4/e16dca6a.jpg","nickname":"阿凯文","note":"","ucode":"F17CF201E74849","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293126,"discussion_content":"广度优先你参考第一遍留言重写的吧，height+=1要有个条件判断if（len(deque)）hight+1才对，也就是队列里还有元素高度才+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595440526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108857,"user_name":"建强","can_delete":false,"product_type":"c1","uid":1397126,"ip_address":"","ucode":"62B03D0E0C64EC","user_header":"https://static001.geekbang.org/account/avatar/00/15/51/86/b5fd8dd8.jpg","comment_is_top":false,"comment_ctime":1561903213,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14446805101","product_id":100017301,"comment_content":"求二叉树的高度，采用递归算法，分别求出左子树高度和右子树高度，然后取两者中的最大值，以下是我自己写的算法源码，里面包括了随机生成任意二叉树，求二叉树高度等方法。<br><br>package alg;<br><br>import java.util.*;<br><br>public class BinaryTree {<br>\t<br>\tclass Node{<br>\t\tint data;<br>\t\tNode left;<br>\t\tNode right;<br>\t}<br><br>\tclass NodeFlag{<br>\t\tNode node;<br>\t\tchar flag;\t&#47;&#47;l表示左节点；r表示右节点<br>\t\t<br>\t\tNodeFlag(Node node, char flag){<br>\t\t\tthis.node = node;<br>\t\t\tthis.flag =  flag;<br>\t\t}<br>\t}<br>\t<br>\tprivate Node root;<br>\t<br>\tpublic Node getRoot(){<br>\t\treturn root;<br>\t}<br>\t<br>\tpublic void setRoot(Node root){<br>\t\tthis.root = root;<br>\t}<br>\t<br>\t&#47;&#47;求二叉树的高度，采用递归算法，分别求出左子树高度和右子树高度，然后取两者中的最大值<br>\tpublic int getTreeHight(Node root){<br>\t\t<br>\t\tif(root == null) return 0;<br>\t\tint lchildhight = (root.left == null ?  0 : getTreeHight(root.left) + 1);<br>\t\tint rchildhight = (root.right == null ? 0 : getTreeHight(root.right) + 1);<br>\t\treturn lchildhight &gt; rchildhight ? lchildhight : rchildhight;<br>\t}<br>\t<br>\t&#47;&#47;构造一颗随机二叉树,参数n表示节点数<br>\tpublic void makeBinaryTree(int n){<br>\t\t<br>\t\tif(n&lt;=0) {<br>\t\t\troot = null;<br>\t\t\treturn;<br>\t\t}<br>\t\t<br>\t\tRandom rand = new Random();<br>\t\t<br>\t\t&#47;&#47;产生根节点<br>\t\troot = new Node();<br>\t\troot.data = rand.nextInt(100);<br>\t\troot.left = root.right = null;<br>\t\t<br>\t\tList&lt;NodeFlag&gt; nodeSet = new ArrayList&lt;NodeFlag&gt;();<br>\t\tnodeSet.add(new NodeFlag(root,&#39;l&#39;));<br>\t\tnodeSet.add(new NodeFlag(root,&#39;r&#39;));<br><br>\t\tfor(int i=0;i&lt;n-1;i++){<br>\t\t\tNode datanode = new Node();<br>\t\t\tdatanode.data = rand.nextInt(100);<br>\t\t\tdatanode.left = datanode.right = null;<br>\t\t\t<br>\t\t\t&#47;&#47;为新节点找一个在现有二叉树中的随机位置<br>\t\t\tint pos = rand.nextInt(nodeSet.size());<br>\t\t\tNodeFlag p = nodeSet.get(pos);<br>\t\t\t<br>\t\t\t&#47;&#47;把新节点挂到新位置，然后在位置集合中删除该位置<br>\t\t\tif(p.flag == &#39;l&#39;)<br>\t\t\t\tp.node.left = datanode;<br>\t\t\telse<br>\t\t\t\tp.node.right = datanode;<br>\t\t\t<br>\t\t\t&#47;&#47;新位置挂上节点后就删除<br>\t\t\tnodeSet.remove(pos);<br>\t\t\t<br>\t\t\t&#47;&#47;再把新节点的左、右子树作为新位置放入位置集合中<br>\t\t\tnodeSet.add(new NodeFlag(datanode,&#39;l&#39;));<br>\t\t\tnodeSet.add(new NodeFlag(datanode,&#39;r&#39;));<br>\t\t}<br>\t}<br>\t<br>\tpublic static void main(String[] args) {<br>\t\t&#47;&#47;构造随机二叉树<br>\t\tBinaryTree bt = new BinaryTree();<br>\t\tbt.makeBinaryTree(10);<br>\t\t<br>\t\t&#47;&#47;求二叉树高度<br>\t\tSystem.out.println(&quot;\\n二叉树高度=&quot; + bt.getTreeHight(bt.getRoot()));<br>\t}<br>}<br>","like_count":3,"discussions":[{"author":{"id":1396126,"avatar":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","nickname":"SteelHuaSheng","note":"","ucode":"BC8127FC5207FC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215148,"discussion_content":"删除算法容易理解，但写起来真的非常吃力。是了，感觉删除真的不好写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585290971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249363,"user_name":"jun","can_delete":false,"product_type":"c1","uid":1451721,"ip_address":"","ucode":"7FC7F746FA2DF3","user_header":"https://static001.geekbang.org/account/avatar/00/16/26/c9/b263648e.jpg","comment_is_top":false,"comment_ctime":1600610653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10190545245","product_id":100017301,"comment_content":"老师您好，插入那里的代码有问题，没有考虑相等的情况，如果要插入的值已经存在就会进入死循环","like_count":2},{"had_liked":false,"id":131438,"user_name":"倡印","can_delete":false,"product_type":"c1","uid":1455958,"ip_address":"","ucode":"4F53AA5D017D89","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/56/11068390.jpg","comment_is_top":false,"comment_ctime":1567752238,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10157686830","product_id":100017301,"comment_content":"一个二叉树的查找感觉就像一个二分查找 嘿嘿","like_count":2},{"had_liked":false,"id":109031,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1561950903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10151885495","product_id":100017301,"comment_content":"二叉树常用操作：根据性质查找 &amp; 前中后序遍历 &amp; 层次遍历 &amp; 高度深度层次计算 &amp; 查找某结点右子树的最小子节点 &amp; 查找某结点左子树的最大子节点 &amp; 查找前驱结点和后继结点 &amp; 左右旋 &amp; 根据子节点情况进行插入和删除操作 &amp; 根据父节点和叔叔结点情况进行旋转<br><br>重复数据的二叉查找树：<br>1. 每个结点通过链表或动态扩容数组的方式把相同值存储在同一个结点上<br>2. 统一一种CRD规则，如在插入时相同值插入到该结点的右子树中，查询和删除时类似，需要在右子树中查找直到遇到叶子结点<br><br>计算一种结构多变的数据结构的时间复杂度（如无特定限制的二叉查找树）：计算上下界时间复杂度范围<br><br>二叉查找树相对散列表的优势：<br><br>1. 从对有序的支持上来看，二叉查找树天然支持有序输出（中序遍历），散列表则需要事先排序<br>2. 从数据结构稳定性上来看，常用的平衡二叉查找树性能稳定，散列表性能不稳定，不稳定因素在于其扩容和散列冲突<br>3. 从时间复杂度上看，平衡二叉查找树的o(logn)在实际情况下可能比散列表的o(1)要好（散列冲突的存在）<br>4. 从设计的复杂度上看，平衡二叉查找树只需要考虑平衡性，而散列表的构造更为复杂，如散列函数的设计、冲突解决办法、扩容和缩容等<br>5. 从空间复杂度上看，散列表为了避免较多散列冲突需要控制装载因子，因此有一定的冗余存储空间（虽然二叉查找树每个结点都会有指针空间的浪费）","like_count":2},{"had_liked":false,"id":39424,"user_name":"追风者","can_delete":false,"product_type":"c1","uid":1055092,"ip_address":"","ucode":"879BC372A6B605","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIjUDIRQ0gRiciax3Wo78c5rVjuWDiaw4ibcCiby8xiaMXJh5ibjU5242vfCGOK4ehibe1IKyxex2A4IX4XSA/132","comment_is_top":false,"comment_ctime":1542272840,"is_pvip":false,"replies":[{"id":"14096","content":"已经回复其他同学的留言了 你扒拉扒拉看看","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542279713,"ip_address":"","comment_id":39424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10132207432","product_id":100017301,"comment_content":"老师，删除操作的代码有点不明白下面这三行在搞什么？<br><br>p.data = minP.data; &#47;&#47; 将minP的数据替换到p中<br>p = minP; &#47;&#47; 下面就变成了删除minP了<br>pp = minPP;<br>","like_count":2,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429060,"discussion_content":"已经回复其他同学的留言了 你扒拉扒拉看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542279713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39361,"user_name":"feifei","can_delete":false,"product_type":"c1","uid":1105431,"ip_address":"","ucode":"B1F8AE3AD82C51","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/17/75e2b624.jpg","comment_is_top":false,"comment_ctime":1542254160,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10132188752","product_id":100017301,"comment_content":"<br>  &#47;**<br>   * 计算层级的重点于在写出递推公式<br>   *<br>   * count(level) = max(count(level.left),count(level.right))<br>   *<br>   * @param root <br>   * @param index<br>   * @return<br>   *&#47;<br>  public int getBinaryLevel(treeNode root, int index) {<br>    if (null == root) {<br>      return index;<br>    }<br><br>    int maxleftLevel = 0;<br>    if (root.left != null) {<br>      maxleftLevel = getBinaryLevel(root.left, index + 1);<br>    }<br><br>    int maxRightLevel = 0;<br><br>    if (root.right != null) {<br>      maxRightLevel = getBinaryLevel(root.right, index + 1);<br>    }<br><br>    return Math.max(maxleftLevel, maxRightLevel) + 1;<br>  }","like_count":2},{"had_liked":false,"id":294103,"user_name":"颜桦","can_delete":false,"product_type":"c1","uid":1099576,"ip_address":"","ucode":"1CD7250E052B32","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/38/d1a50cd6.jpg","comment_is_top":false,"comment_ctime":1621762179,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5916729475","product_id":100017301,"comment_content":"老师，如果有两个相同的数据，在这种树结构如何存储？","like_count":1},{"had_liked":false,"id":274961,"user_name":"慕高迪","can_delete":false,"product_type":"c1","uid":1448126,"ip_address":"","ucode":"EB1CB5EA4E3A90","user_header":"https://static001.geekbang.org/account/avatar/00/16/18/be/ad3127e0.jpg","comment_is_top":false,"comment_ctime":1611234247,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5906201543","product_id":100017301,"comment_content":"总结：<br><br>1. 特点<br><br>任意节点的左子树都比当前节点的值小，右子树都比当前节点的值大。<br><br>2. 三种具体的操作<br><br>它支持快速的查找，添加和删除操作。其中添加和查找操作都比较简单，只需要按照二叉查找树的特点进行搜索就可以了，比较麻烦的是删除操作，它会涉及到以下三种情况：<br>（1）要删除的节点是叶子节点。直接让其父节点指向该叶子节点的指针置为空即可<br>（2）要删除的节点存在一个子节点，不论子节点是作为左节点还是右节点。可以找到要删除的节点的父节点，然后将其指向被删除节点的指针指向被删除节点的子节点。<br>（3）要删除的节点存在两个节点。当出现这种情况时，我们需要先找到有右子树中最小的节点（这个节点一定是个左节点），并将该节点的值赋值给要删除节点的值（相当于给这个最小节点挪了位置）；然后再进行删除这个最小节点，<br>此时最小节点可能出现的情况只有（1）或者是（2）。然后再按照（1）或者是（2）的步骤进行删除即可。此外，还有一种比较浪费内存的做法，让删除变得没有这么麻烦，那就是采用伪删除的做法，直接将要删除的节点标记删除。<br><br>3. 特殊的操作<br><br>除了查找，插入，删除操作外，它还支持快速的查找最大节点，最小节点等操作。而且中序遍历二叉查找树，可以有序的输出树中的元素<br><br>4. 当存在重复元素的情况时<br><br>上述讨论的都是二叉查找树中不存在重复元素的情况。当树中存在重复元素时，我们可以采用两种策略：<br>（1）第一种策略：一个节点存储多个相同的元素，使用可扩容的数组存储<br>（2）第二种策略：相同的节点进行二次插入的时候，作为比其大的节点进行处理，这种这个相同的元素一定会出现再其右子树中。此时进行查找操作，当查找到相同元素后不应停止，而应该再去其右子树继续寻找，从而找到所有的元素；删除操作同理。<br><br>5. 复杂度分析<br><br>二叉查找树的查找过程，是按层进行查找的。所以时间复杂度跟树的层数有关系。可以表示为O(layer)<br><br>最坏情况下，当元素按照升序或降序的顺序进行插入时，就会导致二叉查找树出现一边倒的情况，此时树的层数就等于树中元素的个数，时间复杂度为O(N)<br>最好情况下，二叉查找树是一棵完全二叉树，完全二叉树的层数k 可以表示为：n&gt;= 1 + 2 + 4 +...+ 2^(k-2); n&lt;= 1+ 2 + 4 +...+ 2^(k-2) + 2^(k -1)  。从而可以推导出 k &lt;= logN 。所以时间复杂度为O(logN)<br><br>当对二叉查找树进行频繁的添加和删除时，可能会造成失衡，从而导致复杂度下降，最坏情况下降低至O(N)。<br><br>6.扩展：有了散列表的存在，为什么还需要二叉查找树？<br>（1）散列表无法有序输出元素，如果要想达到有序的输出元素，需要先进行排序。而二叉查找树直接中序遍历就可以得到<br>（2）散列表的实现过程需要考虑的因素比较多，比如散列函数的选择，散列冲突的解决办法等，而用二叉查找树就没有这些问题<br>（3）散列表虽然插入，删除，查找的时间复杂度是常量级别的，但是在出现散列冲突时，加上散列函数计算哈希值所耗费的时间而言，可能也没有logN快<br>（4）散列表虽然是常量时间复杂度，但是当出现散列冲突时，性能是不稳定的，而平衡二叉查找树确是非常稳定的<br>（5）散列表的填充因子不能太大，比较耗费内存，尤其是采用开发寻址法解决散列冲突时<br><br>总之每种数据结构都有其特点，具体情况具体分析，每一种数据结构都有适用其特点的场景，我们只需要在正确的场景下正确的使用合适的数据结构就好了。正所谓：存在即合理。<br>","like_count":1},{"had_liked":false,"id":232172,"user_name":"Javatar","can_delete":false,"product_type":"c1","uid":2032840,"ip_address":"","ucode":"E216645CDF632C","user_header":"https://static001.geekbang.org/account/avatar/00/1f/04/c8/3c7af100.jpg","comment_is_top":false,"comment_ctime":1593880583,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5888847879","product_id":100017301,"comment_content":"直接贴代码吧，一颗树的高度，就是左右子树高度最大者再加一，同时没有左右子树时，该树高度就是0.<br>public static int height(Node node) {<br>        if (node == null) {<br>            return 0;<br>        }<br>        if (node.left != null || node.right != null) {<br>            return Math.max(height(node.left), height(node.right)) + 1;<br>        }<br>        return 0;<br>    }<br>","like_count":1},{"had_liked":false,"id":227723,"user_name":"Deep","can_delete":false,"product_type":"c1","uid":1486168,"ip_address":"","ucode":"EF3281F0A5824A","user_header":"https://static001.geekbang.org/account/avatar/00/16/ad/58/7d6a0b8e.jpg","comment_is_top":false,"comment_ctime":1592464303,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5887431599","product_id":100017301,"comment_content":"只想到递归的方式求层高<br><br> int height(node* p){<br>        if(!p)<br>            return 0;<br>        else<br>        {<br>            if(height(p-&gt;left) &gt; height(p-&gt;right))<br>                return 1+height(p-&gt;left);<br>            else<br>                return 1+height(p-&gt;right);<br>        }<br>    }","like_count":1},{"had_liked":false,"id":166240,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1577421796,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5872389092","product_id":100017301,"comment_content":"1，二叉查找树最大的特点是：支持动态数据集合的快速插入，删除，查找操作<br>2，二叉查找树的要求：在树中的任意一个节点，其中左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。<br>3，二叉查找树的查找操作<br>先取根节点，如果他等于要查找的数据，就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找<br>4，二叉查找树的插入操作<br>二叉查找树的插入过程有些类似查找操作。新插入的数据一般都是在叶子节点上，所以只需要从根节点开始，依次比较要插入的数据和节点的大小关系。<br>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插入右子节点的位置；如果不为空，就在递归遍历右子树，查找插入位置。<br>5，二叉查找树的删除操作<br>二叉查找树的删除要分三种情况：<br>①：如果要删除的节点没有子节点，只需要直接将父节点中指向要删除节点的指针置为为null。<br>②：如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。<br>③：如果要删除的节点有两个子节点，我们需要找到这个节点的右子节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以就可以应用上面两条规则来删除这个最小节点。<br>\t\t<br>6，二叉查找树的其他操作<br>除了插入，删除，查找操作之外，二叉查找树中还可以可以支持快速地查找最大节点和最小节点，前驱节点和后继节点。<br>二叉查找树还有一个重要的特性：中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是O(n)，非常高效。因此，二叉查找树也叫二叉排序树。<br><br>7，二叉查找树支持重复数据<br>在实际开发中，是在二叉查找树中存储的对象，我们利用对象的某个字段作为键值（key）来构建二叉查找树，并把对象中的其他字段叫作卫星数据。<br><br>针对：如果存储两个对象键值相同的处理方式：<br>\t第一种方式：二叉查找树中每个节点不仅会存储一个数据，因此可通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。<br>\t第二种方式：每个节点仍然只存储一个数据，在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，即把这个新插入的数据当做大于这个节点的值来处理。<br>\t<br>\t这样当要查找数据时，遇到值相同的节点，不通知查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。<br>\t删除操作，也需要先查找到每个要删除的节点，然后在按前面讲的删除操作的方法，依次删除。<br><br>8，二叉查找树的时间复杂度分析<br>\t\t二叉查找树的形态多种多样，每种的查找，插入，删除操作的执行效率都不一样。<br>\t\t但，不管操作是插入，删除还是查找，时间复杂度其实都根树的高度正比，即O(height)。<br>树的高度等于最大层数减一，每层包含的节点个数是2^(k-1)。但对于完全二叉树，最后一层节点个数不遵守这个规律。它包含的节点个数在1个到2^(L-1)个之间（假设最大层数是L）。<br>如果将每一层的节点数加起来就是总的节点个数n。则n满足以下关系：<br>n&gt;=1+2+4+8+……+2^(L-2)+1<br>n&lt;=1+2+4+8+……+2^(L-2)+2^(L-1)<br>得到L的范围是[log2^(n+1)，log2^n +1]。<br>完全二叉树的层数小于等于log2^n + 1，即完全二叉树的高度小于等于log2^n<br>\t所以，极度不平衡的二叉查找树，它的查找性能肯定不能满足我们的需求。我们需要构建一种不管怎么删除，插入数据，在任何时候，都能保持任意节点左右子树都比较平衡的二叉查找树—平衡二叉查找树。<br><br>\t散列表无法替代二分查找树的原因：<br>\t1，散列表中的数据是无序存储的，若要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在O(n)的时间复杂度内，输出有序的数据序列。<br>\t2，散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，在工程中常用的二叉查找树的性能非常稳定，时间复杂度稳定在O(logn。<br>\t3，笼统地讲，虽然散列表的查找操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个个常量不一定比logn小，所以实际查找速度可能不一定比O(logn)快。加上哈希函数的耗时，也不一定比平衡二叉查找树的效率高。<br>\t4，散列表的构造比二叉查找树要复杂，需要考虑的东西很多，如散列函数的设计，冲突解决办法，扩容，缩容等。而平衡二叉树只需要考虑平衡性这个一个问题，且这个问题的解决方案比较成熟，固定。<br>\t同时，为了避免过多的散列冲突，散列表的装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。<br>","like_count":1},{"had_liked":false,"id":139246,"user_name":"Geek_b617bf","can_delete":false,"product_type":"c1","uid":1220552,"ip_address":"","ucode":"9BAFC3B184B1D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/c8/0318c83e.jpg","comment_is_top":false,"comment_ctime":1570591906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865559202","product_id":100017301,"comment_content":"第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或右节点)  就把该节点的父节点指向该节点的子节点          如果这个子节点的大小不符合二叉查找树的规则怎么办呢,例如该节点的右子节点,可能比该节点的父节点要大<br><br>","like_count":1},{"had_liked":false,"id":77968,"user_name":"Robert","can_delete":false,"product_type":"c1","uid":1057914,"ip_address":"","ucode":"594538993C02ED","user_header":"https://static001.geekbang.org/account/avatar/00/10/24/7a/6ee10cc8.jpg","comment_is_top":false,"comment_ctime":1553047185,"is_pvip":false,"replies":[{"id":"28466","content":"链表中用的结点，树中用的节点。这样比较形象、会意，你自己感受下：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553054533,"ip_address":"","comment_id":77968,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5848014481","product_id":100017301,"comment_content":"我吹毛求疵一下，应该是“结点”，而不是“节点”。我记得老师之前的课程写的都是“结点”。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443914,"discussion_content":"链表中用的结点，树中用的节点。这样比较形象、会意，你自己感受下：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553054533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63068,"user_name":"落叶飞逝的恋","can_delete":false,"product_type":"c1","uid":1046429,"ip_address":"","ucode":"F9A95DB28BCF1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/9d/be04b331.jpg","comment_is_top":false,"comment_ctime":1548242453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5843209749","product_id":100017301,"comment_content":"老师，关于插入重复的数据的，还有一种思路，就是在Node类中，增加count，每次遇到重复的数据，直接在count+1。而对于本篇比较难理解的二叉搜索树的删除操作，我也将代码进行的命名规范的，并且每行都增加了注释，小白也可以看得懂！请老师指教下！<br>  public void delete(int data) {<br>        Node currentDeleteNode = root;<br>        Node currentDeleteParentNode = null;<br>        if (currentDeleteNode == null) {<br>            return;<br>        }<br>        while (currentDeleteNode.e != data) {<br>            currentDeleteParentNode = currentDeleteNode;<br>            &#47;&#47;当前节点的值大于要删除的值，则查询在左子树<br>            if (currentDeleteNode.e &gt; data) {<br>                currentDeleteNode = currentDeleteNode.left;<br>            } else {<br>                currentDeleteNode = currentDeleteNode.right;<br>            }<br>        }<br>        &#47;&#47;当前遍历的节点，拥有左右子树的情况<br>        if (currentDeleteNode.left != null &amp;&amp; currentDeleteNode.right != null) {<br>            &#47;&#47;当前节点的右子树，来查询接近删除的值的节点<br>            Node curMinNode = currentDeleteNode.right;<br>            Node curMinParentNode = currentDeleteNode;<br>            &#47;&#47;若当前最小节点的还存在左子树，说明，当前节点还不是最小值<br>            while (curMinNode.left != null) {<br>                curMinNode = curMinNode.left;<br>                curMinParentNode = curMinNode;<br>            }<br>     &#47;&#47;直接将最小值覆盖到当前要删除元素的节点，其他关联关系不变<br>            currentDeleteNode.e = curMinNode.e;<br><br>            &#47;&#47;此时删除元素的节点就是变成了删除后继节点的最小值了。所以要把删除对象指向最小值<br>            currentDeleteNode = curMinNode;<br>            currentDeleteParentNode = curMinParentNode;<br>        }<br>        &#47;&#47;只有当前遍历节点，只有一个<br>        Node onlyChild = null;<br>        if (currentDeleteNode.left != null) {<br>            onlyChild = currentDeleteNode.left;<br>        } else {<br>            onlyChild = currentDeleteNode.right;<br>        } &#47;&#47;当删除的节点父节点没有，说明删除的是根节点，所以原先的根节点使用父节点替代<br>        if (currentDeleteParentNode == null) {<br>            root = onlyChild;<br>        }<br>        &#47;&#47;这边判断删除的元素是删除元素的父节点的左子树还是右子树<br>        else if (currentDeleteParentNode.left == currentDeleteNode) {<br>            currentDeleteParentNode.left = onlyChild;<br>        } else {<br>            currentDeleteParentNode.right = onlyChild;<br>        }<br>        &#47;&#47;需要维护下节点个数<br>        size--;<br>    }","like_count":1},{"had_liked":false,"id":40999,"user_name":"产品助理","can_delete":false,"product_type":"c1","uid":1019821,"ip_address":"","ucode":"39A76D346A96E9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/ad/6e3e9e15.jpg","comment_is_top":false,"comment_ctime":1542710930,"is_pvip":false,"replies":[{"id":"14793","content":"文章没写错 你的公式怎么来的呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542765298,"ip_address":"","comment_id":40999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5837678226","product_id":100017301,"comment_content":"n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)<br><br>应该是 &lt; 吧？ 或者是：<br><br>n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)-1<br><br>?","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429669,"discussion_content":"文章没写错 你的公式怎么来的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542765298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39059,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1542180584,"is_pvip":false,"replies":[{"id":"14049","content":"嗯嗯 多谢建议 非常好。不过专栏已经定稿的差不多了。估计临时改也来不及了。抱歉","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542247649,"ip_address":"","comment_id":39059,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5837147880","product_id":100017301,"comment_content":"hi，老师。一直都每天在专栏里学习，我希望可以向你提点课程设计上的建议。<br>算法的学习过程整体来说还是由浅入深的，从线性结构到非线性结构，从树概念深入学习二叉树等等，我觉得文章末尾的习题可以有一道和下一篇文章有所关联的问题，方便我们思考过后可以更容易地学习下一篇文章，也算是一个链表的思维方式。<br>专栏至此非常有用，深入浅出，谈及了很多算法书本上没说到的点。感谢老师","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428898,"discussion_content":"嗯嗯 多谢建议 非常好。不过专栏已经定稿的差不多了。估计临时改也来不及了。抱歉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542247649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38993,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1542168817,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5837136113","product_id":100017301,"comment_content":"template&lt;typename T&gt;<br>int getTreeHeight(TreeNode&lt;T&gt; *node) {<br>\tif (node == NULL) {<br>\t\treturn -1;<br>\t}<br>\tint leftHeight = getTreeHeight(node-&gt;left);<br>\tint rightHeight = getTreeHeight(node-&gt;right);<br>\treturn (leftHeight &gt; rightHeight ? leftHeight : rightHeight) + 1;<br>}","like_count":1},{"had_liked":false,"id":38964,"user_name":"徐凯","can_delete":false,"product_type":"c1","uid":1244991,"ip_address":"","ucode":"12F82BA3649CD5","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/3f/bbb8a88c.jpg","comment_is_top":false,"comment_ctime":1542162893,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5837130189","product_id":100017301,"comment_content":"int ret_height（treenode* T）<br>｛<br>   if（！T）<br>     return 0；<br>  int Lh=0,Rh=0;<br>   if（T-&gt;left)<br>     Lh=ret_height(T-&gt;left);<br>   If(T-&gt;right)<br>     Rh =ret_height(T-&gt;right);<br>return max(Lh,Rh)+1;<br>}<br>刚起床写的一段 不知道漏没漏东西。zz","like_count":1,"discussions":[{"author":{"id":1503916,"avatar":"","nickname":"Geek_ba213c","note":"","ucode":"C25B5BCC576AFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79719,"discussion_content":"之前没想明白，在最后加的1，利用栈来累加，是没有问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576107363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1503916,"avatar":"","nickname":"Geek_ba213c","note":"","ucode":"C25B5BCC576AFD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79716,"discussion_content":"感觉有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576106645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38959,"user_name":"王小李","can_delete":false,"product_type":"c1","uid":1108833,"ip_address":"","ucode":"64B703781E0A0E","user_header":"https://static001.geekbang.org/account/avatar/00/10/eb/61/45c3a047.jpg","comment_is_top":false,"comment_ctime":1542162196,"is_pvip":false,"replies":[{"id":"14125","content":"感觉～","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542281108,"ip_address":"","comment_id":38959,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5837129492","product_id":100017301,"comment_content":"为什么第二种实现更优雅？","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428864,"discussion_content":"感觉～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542281108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358917,"user_name":"111","can_delete":false,"product_type":"c1","uid":3109487,"ip_address":"北京","ucode":"D6E8E83A118A3E","user_header":"https://static001.geekbang.org/account/avatar/00/2f/72/6f/44c10658.jpg","comment_is_top":false,"comment_ctime":1665024293,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665024293","product_id":100017301,"comment_content":"总结：<br>1. 查找二叉树概念，插入，删除，查找<br>2. 为什么有了散列表还考虑二叉树，工程上越简单的越可靠，越容易实现。而查找二叉树易于实现且在某些情况可以替代散列表。所以用的比较多<br><br>1. 找到高度，使用递归，保存一个最大值，时刻更新。得到的就是高度","like_count":0},{"had_liked":false,"id":357645,"user_name":"Geek_4ad8e3","can_delete":false,"product_type":"c1","uid":3178368,"ip_address":"江苏","ucode":"0A539E3A710B76","user_header":"","comment_is_top":false,"comment_ctime":1663513601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663513601","product_id":100017301,"comment_content":"老师你好，在二叉查找树插入的时候，是不是少了一个data == p.data条件","like_count":0},{"had_liked":false,"id":356414,"user_name":"蒋慕平","can_delete":false,"product_type":"c1","uid":2302901,"ip_address":"重庆","ucode":"57B8FF7F00C042","user_header":"https://static001.geekbang.org/account/avatar/00/23/23/b5/639a12ec.jpg","comment_is_top":false,"comment_ctime":1662284351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662284351","product_id":100017301,"comment_content":"Sort Tree VS Hash<br>1. Hash 查找是O(1) tree 插入，删除、查找比较稳定 O(logN)<br>2. Hash 无序存储,需要把排序，对于排序二叉树。直接中序遍历<br>3. Hash不稳定","like_count":0},{"had_liked":false,"id":347438,"user_name":"Geek_48edaa","can_delete":false,"product_type":"c1","uid":2318422,"ip_address":"","ucode":"E10AEC9A0AC609","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIJ9Kyict83d8Y95iavUqHsiaJVKbHdcTEKdsubAYvBr6FkzNicS3hGd2MRclrG2XZ0KGcgtHsCPluaNA/132","comment_is_top":false,"comment_ctime":1654039974,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654039974","product_id":100017301,"comment_content":"请教一个问题，为什么删除两个字节点的树的时候，要把右子树最小的节点替换。为啥不是替换左子树最大节点？","like_count":0},{"had_liked":false,"id":347403,"user_name":"Geek_c2a2be","can_delete":false,"product_type":"c1","uid":2914259,"ip_address":"","ucode":"ECAE3C732915CC","user_header":"","comment_is_top":false,"comment_ctime":1653991435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653991435","product_id":100017301,"comment_content":"&quot;二叉查找树中，每个节点的值都大于左子树节点的值，小于右子树节点的值&quot;<br><br>这句话描述的不太具体，或者说不太准确。应该是每个节点的值都大于其左子树的所有节点的值，或者说大于其左子树的最大值；小于其右子树的最小值。","like_count":0},{"had_liked":false,"id":338804,"user_name":"woJA1wCgAAcQSG4cC0RrRLQoo4JPVq7Q","can_delete":false,"product_type":"c1","uid":2922217,"ip_address":"","ucode":"331691EB69ACB2","user_header":"","comment_is_top":false,"comment_ctime":1647746435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647746435","product_id":100017301,"comment_content":"老师你好，二叉搜索树是不是不能含有相同的元素啊","like_count":0},{"had_liked":false,"id":337479,"user_name":"Today","can_delete":false,"product_type":"c1","uid":1235000,"ip_address":"","ucode":"4FA397F0BD8C6E","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/38/41027bda.jpg","comment_is_top":false,"comment_ctime":1646840166,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646840166","product_id":100017301,"comment_content":"思考题：<br>1. 可以通过递归的方式转成左右子树之间的最大高度问题<br>2. 使用队列进行层层出队入队也可以","like_count":0},{"had_liked":false,"id":318341,"user_name":"瓜牛","can_delete":false,"product_type":"c1","uid":2273620,"ip_address":"","ucode":"5EB7D2F4400A70","user_header":"https://static001.geekbang.org/account/avatar/00/22/b1/54/6d663b95.jpg","comment_is_top":false,"comment_ctime":1635249122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635249122","product_id":100017301,"comment_content":"删除那里没太看懂","like_count":0},{"had_liked":false,"id":314476,"user_name":"华小乱","can_delete":false,"product_type":"c1","uid":1040471,"ip_address":"","ucode":"FBDF93883BE251","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e0/57/69df215e.jpg","comment_is_top":false,"comment_ctime":1633101971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633101971","product_id":100017301,"comment_content":"删除的操作其实可以这样想，用手将二叉树从根节点往下压平。<br>这个抽象可以做到的话，能得出来很多结论：<br>1. 在不考虑重复数据的情况下，插入操作一定可以插入在最深的那一层；<br>2. 删除操作中，如果只有一个子节点，也可以按照两个子节点的方式处理（左子树取最大、右子树取最小），因为将树压平后，没啥区别。","like_count":0},{"had_liked":false,"id":314104,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1632838259,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632838259","product_id":100017301,"comment_content":"1.散列表存储的数据是无序的，如果要有序输出需要排序。<br>2.散列表扩容耗时长。<br>3.散列表有冲突问题，查找数据未必比平衡二叉树的O(logN)效率高<br>4.散列表需要考虑散列函数，冲突处理，扩容，缩容等问题，平衡二叉树只需要考虑平衡一个问题，而且已经有成熟的方案。","like_count":0},{"had_liked":false,"id":308255,"user_name":"JayGaoPku","can_delete":false,"product_type":"c1","uid":2199307,"ip_address":"","ucode":"FB95B347299D4B","user_header":"","comment_is_top":false,"comment_ctime":1629475215,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629475215","product_id":100017301,"comment_content":"妙啊","like_count":0},{"had_liked":false,"id":305365,"user_name":"叶致习","can_delete":false,"product_type":"c1","uid":1510429,"ip_address":"","ucode":"38E399769699D9","user_header":"https://static001.geekbang.org/account/avatar/00/17/0c/1d/f21977c8.jpg","comment_is_top":false,"comment_ctime":1627924992,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627924992","product_id":100017301,"comment_content":"我怎么觉得针对第二种情况代码会有问题呢？这里默认了左&#47;右子节点没有子节点了，但实际可能是会有的。我觉得应该是下面这样。<br>1，如果只有左子节点，则父节点应该指向要删除节点的前驱节点；<br>2，如果只有右子节点，则父节点指向要删除节点的后继节点；<br><br>Successor 代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。<br><br>前驱节点定义类似。","like_count":0},{"had_liked":false,"id":301123,"user_name":"吃东西就变脸","can_delete":false,"product_type":"c1","uid":2576790,"ip_address":"","ucode":"D01832CAB0B8C3","user_header":"https://static001.geekbang.org/account/avatar/00/27/51/96/e969cc89.jpg","comment_is_top":false,"comment_ctime":1625545268,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625545268","product_id":100017301,"comment_content":"感觉大家的疑问其实是在<br>p.data = minP.data; <br>&#47;&#47; 将minP的数据替换到p中 <br>p = minP; <br>&#47;&#47; 下面就变成了删除minP了 <br>pp = minPP;<br>这里的p.data = minP.data; 和p = minP;  怎么看都像是同一个操作<br>其实不一样，<br>p.data = minP.data; 是在给 p对象的data属性赋值 因为我们要删除minP 但又要将 minP的值留下来<br>p =minP 是让变量p指向 minP的内存地址<br>变化如下<br>p--&gt;是一直指向要被删的数据<br>开始 <br>p--&gt;指向18 这个node  并将18替换成了19<br>替换后<br>p--&gt;指向19这个node<br>18还是那个18 只不过值被替换成了19  不会因为后续p指向minP 它就变了  p只是一个指向堆内存地址的一个变量 ","like_count":0},{"had_liked":false,"id":296641,"user_name":"青青子衿","can_delete":false,"product_type":"c1","uid":2427556,"ip_address":"","ucode":"0D719FD7317BE5","user_header":"https://static001.geekbang.org/account/avatar/00/25/0a/a4/be7deb33.jpg","comment_is_top":false,"comment_ctime":1623077343,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1623077343","product_id":100017301,"comment_content":"老师删除节点的代码 19行和20行 我百思不得其解为什么要先值替换在引用替换 为什么直接引用替换不行呢？请老师解答下","like_count":0,"discussions":[{"author":{"id":2052843,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoCZfMvnQdibYUlvcHnCIu3nO5T2EffF3H35zibcI0sne0xic7OyGO9WicBIM1cjd4PCfzFMGcXbPjiaGA/132","nickname":"Geek_24a140","note":"","ucode":"D884D7715D944D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386299,"discussion_content":"你看下如果要删除的节点如果有两个子节点的删除逻辑。\n需要找到对应节点右子树的最小节点将其替换到要删除的节点P上，然后将这个最小节点删除(也就是minp）.\n把minp的值赋给p说明已经完成了值的替换，也就是说现在剩下的就是要删除minp这个节点了。\n为了兼容只有一个左节点或者一个右节点的删除逻辑，把之前遍历找到的要删除的节点p指向这个minp，接下来的就是删除p节点，而不用去考虑minp了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627521290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295664,"user_name":"JoJi","can_delete":false,"product_type":"c1","uid":2066986,"ip_address":"","ucode":"B88997A80E76AC","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8a/2a/f94db4dc.jpg","comment_is_top":false,"comment_ctime":1622537989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622537989","product_id":100017301,"comment_content":"如果要查某个范围，是不是哈希不得行，而二叉树查找树可以?","like_count":0},{"had_liked":false,"id":291454,"user_name":"南荣牧歌","can_delete":false,"product_type":"c1","uid":1765050,"ip_address":"","ucode":"2DFD9B50955C5A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ee/ba/ac07d5a4.jpg","comment_is_top":false,"comment_ctime":1620292780,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620292780","product_id":100017301,"comment_content":"class Solution {<br>    public int maxDepth(TreeNode root) {<br>        if (Objects.isNull(root)) {<br>            return 0;<br>        }<br>        int l = maxDepth(root.left);<br>        int r = maxDepth(root.right);<br>        return Math.max(l,r) + 1;<br>    }<br>}","like_count":0},{"had_liked":false,"id":291414,"user_name":"小福","can_delete":false,"product_type":"c1","uid":1899911,"ip_address":"","ucode":"C5D78EAD860498","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fd/87/24a3553c.jpg","comment_is_top":false,"comment_ctime":1620282564,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620282564","product_id":100017301,"comment_content":"使用二叉树做数据分片可以吗，当一个服务器上的数据满了后，直接一分两半","like_count":0},{"had_liked":false,"id":291212,"user_name":"双木公子","can_delete":false,"product_type":"c1","uid":1116567,"ip_address":"","ucode":"751885864D3AB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/97/4314e2d8.jpg","comment_is_top":false,"comment_ctime":1620119454,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620119454","product_id":100017301,"comment_content":"老师辛苦了，本文的算法详细整理内容见：https:&#47;&#47;blog.csdn.net&#47;BruceLee1314&#47;article&#47;details&#47;116398662?spm=1001.2014.3001.5501","like_count":0},{"had_liked":false,"id":280790,"user_name":"罗耀龙@坐忘","can_delete":false,"product_type":"c1","uid":1917663,"ip_address":"","ucode":"3CEA258DE7F3C7","user_header":"https://static001.geekbang.org/account/avatar/00/1d/42/df/a034455d.jpg","comment_is_top":false,"comment_ctime":1614392138,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1614392138","product_id":100017301,"comment_content":"茶艺师学编程<br><br>思考题<br>用C语言实现<br>int max(int a, int b){    return a &gt; b ? a : b;<br>}<br>int maxDepth(struct TreeNode* root){<br>    if (!root) return 0;<br>    return max(maxDepth(root -&gt; left) + 1, maxDepth(root -&gt; right) + 1);<br>}<br>","like_count":0},{"had_liked":false,"id":279486,"user_name":"Eason","can_delete":false,"product_type":"c1","uid":1032955,"ip_address":"","ucode":"25644E24732D1E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c2/fb/3b64b8dd.jpg","comment_is_top":false,"comment_ctime":1613802480,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613802480","product_id":100017301,"comment_content":"右子树上min &gt; 左子树max","like_count":0},{"had_liked":false,"id":279014,"user_name":"子房","can_delete":false,"product_type":"c1","uid":1438860,"ip_address":"","ucode":"CB05938C248BB3","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/8c/0866b228.jpg","comment_is_top":false,"comment_ctime":1613545646,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613545646","product_id":100017301,"comment_content":"作业 ：<br>    public int maxDepth(TreeNode root) {<br>        if(root == null ) return 0;<br>        if(root.left == null &amp;&amp; root.right == null){<br>            return 1;<br>        }<br>        <br>        return Math.max(maxDepth(root.left) , maxDepth(root.right))+1;<br>    }","like_count":0},{"had_liked":false,"id":277853,"user_name":"xxx","can_delete":false,"product_type":"c1","uid":1356978,"ip_address":"","ucode":"E78B1F15BC10F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIcLjatV3GHdibZXCTIgL1X2A7jpByIeLH3Zyia8KXdT4JRcicmVSgq5ekRHCFCFenMqicsAwaWYibHkTw/132","comment_is_top":false,"comment_ctime":1612622500,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612622500","product_id":100017301,"comment_content":"以前看数据结构与算法的书开篇时，总会介绍很多概念，比如存储结构、逻辑结构等等，但说实话那些知识点根本联系不起来。王争老师讲的真好，我的理解给大概串起来了。存储结构：链表、数组、散列表（数组的特殊情况）；逻辑结构：线性、二叉树、图等。","like_count":0},{"had_liked":false,"id":272954,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1610363015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610363015","product_id":100017301,"comment_content":"课后思考：一棵确切的二叉树高度，需要我们按照层次遍历二叉树，直到没有子节点。","like_count":0},{"had_liked":false,"id":270738,"user_name":"河山","can_delete":false,"product_type":"c1","uid":1348214,"ip_address":"","ucode":"501AF235E0DAD3","user_header":"https://static001.geekbang.org/account/avatar/00/14/92/76/343c8497.jpg","comment_is_top":false,"comment_ctime":1609232893,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609232893","product_id":100017301,"comment_content":"请教大佬们个问题哈,假设一个散列表hash函数没有冲突.被存储的数值value存放在hash(value)的位置上,那么散列表可以有序吗.","like_count":0},{"had_liked":false,"id":270401,"user_name":"I LOVE JAVASCRIPT","can_delete":false,"product_type":"c1","uid":1242543,"ip_address":"","ucode":"66D9EB7395662B","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/af/a457bdb2.jpg","comment_is_top":false,"comment_ctime":1609116738,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609116738","product_id":100017301,"comment_content":"当前的节点类没有指向父节点的指针，如果没有子树，是不是只能通过栈来记录入栈、出栈得到前驱和后继？哪位大佬有前驱和后继的完整代码？github上眼熟的几门语言也没看到实现","like_count":0},{"had_liked":false,"id":258395,"user_name":"收腹，你咋有肚子","can_delete":false,"product_type":"c1","uid":1431088,"ip_address":"","ucode":"F51B6450B41150","user_header":"https://static001.geekbang.org/account/avatar/00/15/d6/30/1c7f1c39.jpg","comment_is_top":false,"comment_ctime":1604408804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604408804","product_id":100017301,"comment_content":"删除二叉树的最后一步：<br>if (pp == null) tree = child; &#47;&#47; 删除的是根节点 else if (pp.left == p) pp.left = child; else pp.right = child;<br>这个里面：<br> pp.right = child<br>这个方式是用来干什么的？这样不会覆盖原本的左节点？","like_count":0},{"had_liked":false,"id":253936,"user_name":"光脚造轮子","can_delete":false,"product_type":"c1","uid":1238238,"ip_address":"","ucode":"7B1485B7045D15","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/de/deaa9da1.jpg","comment_is_top":false,"comment_ctime":1602957697,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1602957697","product_id":100017301,"comment_content":"p.data = minP.data; &#47;&#47; 将 minP 的数据替换到 p 中<br>p = minP; &#47;&#47; 下面就变成了删除 minP 了<br>pp = minPP;<br><br>第一步和第二步是节点本身的替换，<br>第三步是，将前两步替换后的节点的父节点替换为原来节点的父节点，这样就好理解一些","like_count":0},{"had_liked":false,"id":253464,"user_name":"Grocker","can_delete":false,"product_type":"c1","uid":2204462,"ip_address":"","ucode":"DF2E19A65DEAD6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/IY4fLqdVwCPlW7xJicz3nZm4OePT0o20tDZj1Hiauk2b0iaHMQcSOGpamLt9b72hYVG72sgRWic1BHY3uCvibWcfickw/132","comment_is_top":false,"comment_ctime":1602746161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602746161","product_id":100017301,"comment_content":"https:&#47;&#47;www.cs.usfca.edu&#47;~galles&#47;visualization&#47;BST.html 配合Canvas动图看更直观","like_count":0},{"had_liked":false,"id":249730,"user_name":"Jeff","can_delete":false,"product_type":"c1","uid":1344632,"ip_address":"","ucode":"3E22C18FF4986F","user_header":"https://static001.geekbang.org/account/avatar/00/14/84/78/c246f6d5.jpg","comment_is_top":false,"comment_ctime":1600772963,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600772963","product_id":100017301,"comment_content":"根据「失火的夏天」的留言与demo，改了一下最后的判读条件。否则，在queue最后一次为空时，仍然 +1 ，造成结果比实际情况多一层。<br>    public int maxDepth(TreeNode root) {<br>        if(root == null){<br>            return 0;<br>        }<br>        TreeNode node = root;<br>        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();<br>        queue.offer(node);<br>        int front = 0;&#47;&#47; 队头<br>        int rear = queue.size();&#47;&#47; 队尾<br>        int floor = 1;<br>        while (!queue.isEmpty()){<br>            node = queue.poll();<br>            front++;<br>            if(node.left != null){<br>                queue.offer(node.left);<br>            }<br>            if(node.right != null){<br>                queue.offer(node.right);<br>            }<br>            if(front == rear &amp;&amp; queue.size() &gt; 0){&#47;&#47; 进入下一层 queue.size&gt; 0 保证进入下次循环时，有节点。防止空，造成多➕1<br>                front = 0;<br>                rear = queue.size();<br>                floor++;&#47;&#47; 层数+1<br>            }<br>        }<br>        return floor;<br>    }","like_count":0},{"had_liked":false,"id":247213,"user_name":"小北","can_delete":false,"product_type":"c1","uid":2133309,"ip_address":"","ucode":"8FE84905F0E073","user_header":"https://static001.geekbang.org/account/avatar/00/20/8d/3d/91b1afd3.jpg","comment_is_top":false,"comment_ctime":1599634868,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599634868","product_id":100017301,"comment_content":"删除  这个想法有点强","like_count":0},{"had_liked":false,"id":245471,"user_name":"uprightclear","can_delete":false,"product_type":"c1","uid":2137408,"ip_address":"","ucode":"BCA9CAE1C9A3CE","user_header":"https://static001.geekbang.org/account/avatar/00/20/9d/40/1062dbe7.jpg","comment_is_top":false,"comment_ctime":1598952655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598952655","product_id":100017301,"comment_content":"class Solution {<br>    public int maxDepth(TreeNode root) {<br>        if(root == null){<br>            return 0;<br>        }<br>        int left = maxDepth(root.left);<br>        int right = maxDepth(root.right);<br>        return Math.max(left, right) + 1;<br>    }<br>}","like_count":0},{"had_liked":false,"id":245003,"user_name":"JerryZhu","can_delete":false,"product_type":"c1","uid":1591223,"ip_address":"","ucode":"76850CD45786C1","user_header":"https://static001.geekbang.org/account/avatar/00/18/47/b7/b30472fd.jpg","comment_is_top":false,"comment_ctime":1598779244,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598779244","product_id":100017301,"comment_content":"    p = minP; &#47;&#47; 下面就变成了删除minP了    <br>pp = minPP; <br><br>这个完全没看懂啊！  minP是右子树说最小的 左子树吗？ 为啥还要覆盖p？ 那不就没有维护新的左右节点吗？  原p 有左右节点啊","like_count":0},{"had_liked":false,"id":243745,"user_name":"犀利鬼","can_delete":false,"product_type":"c1","uid":1600746,"ip_address":"","ucode":"E02388EC88D4ED","user_header":"https://static001.geekbang.org/account/avatar/00/18/6c/ea/65cfa066.jpg","comment_is_top":false,"comment_ctime":1598263217,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598263217","product_id":100017301,"comment_content":"看删除代码最后三行，开始确实没有看懂，根据图来理解以为是先获取要替换的对象，然后删除掉要删除的对象，最后将要替换的对象转移过去。<br>其实这三行代码的真正含义是，直接将要替换的对象的值赋值上去，这个时候那个要删除的对象就不用删除了，然后把要替换的那个对象删除就好了。这个时候因为那个要替换的对象只可能存在一个右子树或者是没有子树。这就又变成了删除只有一个子树或者没有子树的问题，这段代码写的确实非比寻常，点个赞","like_count":0},{"had_liked":false,"id":239698,"user_name":"一点点就好","can_delete":false,"product_type":"c1","uid":1055913,"ip_address":"","ucode":"3082B6E93FA7D8","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/a9/49ffc8c7.jpg","comment_is_top":false,"comment_ctime":1596619426,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596619426","product_id":100017301,"comment_content":"老师请教一个问题，上述案例使用中序打印，打印结果root=33打印了两次，感觉不太符合要求，应该只打印一次才对吧","like_count":0},{"had_liked":false,"id":238539,"user_name":"酸辣土豆丝","can_delete":false,"product_type":"c1","uid":1751234,"ip_address":"","ucode":"0E3E4AFB31E1E6","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b8/c2/d1904d74.jpg","comment_is_top":false,"comment_ctime":1596191692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596191692","product_id":100017301,"comment_content":"统计各个叶子节点的高度，最后输出里面的最大值","like_count":0},{"had_liked":false,"id":234828,"user_name":"极客学子","can_delete":false,"product_type":"c1","uid":1149510,"ip_address":"","ucode":"40051597564EB7","user_header":"https://static001.geekbang.org/account/avatar/00/11/8a/46/71747b18.jpg","comment_is_top":false,"comment_ctime":1594805559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594805559","product_id":100017301,"comment_content":"运用递归的原理，某个节点的高度等于左右子节点的高度的最大值+1，而树的高度即根节点的高度，由此可通过递归求解树的高度","like_count":0},{"had_liked":false,"id":224458,"user_name":"Shanks-王冲","can_delete":false,"product_type":"c1","uid":1042983,"ip_address":"","ucode":"C4B90A17850E20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","comment_is_top":false,"comment_ctime":1591407795,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591407795","product_id":100017301,"comment_content":"二分查找树(Binary Search Tree) vs 二分查找(Binary Search)算法？后者是一种思想，前者是(树 + 二分查找的思想)","like_count":0},{"had_liked":false,"id":222741,"user_name":"唯心主义蠢货🍁","can_delete":false,"product_type":"c1","uid":1941034,"ip_address":"","ucode":"836B09E0459953","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9e/2a/f1d8913f.jpg","comment_is_top":false,"comment_ctime":1590903343,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590903343","product_id":100017301,"comment_content":"把两个子节点的情况先做处理，交换查找到节点和要删除节点的值<br>然后再将要删除的节点的指针指向后来查找到的节点<br>【这一步好巧妙！！！！】然后就变成了再进行一个或者零个子节点的判断，因为此时被删node已经没有left节点，只有right存在和不存在两种情况","like_count":0},{"had_liked":false,"id":222702,"user_name":"唯心主义蠢货🍁","can_delete":false,"product_type":"c1","uid":1941034,"ip_address":"","ucode":"836B09E0459953","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9e/2a/f1d8913f.jpg","comment_is_top":false,"comment_ctime":1590895728,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590895728","product_id":100017301,"comment_content":"function maxDepth(root){<br>   if(!root){<br>      return 0;<br>   }<br>   return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1<br>}","like_count":0},{"had_liked":false,"id":221604,"user_name":"Sudouble","can_delete":false,"product_type":"c1","uid":1365574,"ip_address":"","ucode":"B369B09DAF8D20","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/46/5eb5261b.jpg","comment_is_top":false,"comment_ctime":1590548106,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590548106","product_id":100017301,"comment_content":"结合二叉树的特性，因无法预知树的结构，所以这里利用递归的原理，分别求每个分支的高度，最后合并出层数最大的树。","like_count":0},{"had_liked":false,"id":219466,"user_name":"Geek_Akara","can_delete":false,"product_type":"c1","uid":1991279,"ip_address":"","ucode":"E86A5A9EEC8BFF","user_header":"https://static001.geekbang.org/account/avatar/00/1e/62/6f/06d476f7.jpg","comment_is_top":false,"comment_ctime":1590028519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590028519","product_id":100017301,"comment_content":"Node 是结点吧！ 节点是milestone！ 写着笔记总有一种要交项目的莫名的压力。","like_count":0},{"had_liked":false,"id":216890,"user_name":"mqray","can_delete":false,"product_type":"c1","uid":1336634,"ip_address":"","ucode":"15664507AD7033","user_header":"https://static001.geekbang.org/account/avatar/00/14/65/3a/bc801fb2.jpg","comment_is_top":false,"comment_ctime":1589363084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589363084","product_id":100017301,"comment_content":"&#39;&#39;&#39;<br>求解二叉树的高度<br>&#39;&#39;&#39;<br>#1.DFS 深度遍历<br>def DFS_heigh_tree(root):<br>    if not root:<br>        return  0<br>    return max(DFS_heigh_tree(root.left),DFS_heigh_tree(root.right))+1<br><br>#2.BFS 层次遍历<br>def BFS_height_tree(root):<br>    if not root:<br>        return 0<br>    quene,height = [root],0#使用队列记录<br><br>    while quene:#这一行代码够精髓，确保了每一层都计数了<br>        for i in range(len(quene)):#这个length在每一层遍历时是不会变的<br>            tmp = quene.pop(0)#出队列<br>            if tmp.left:<br>                quene.append(tmp.left)<br>            if tmp.right:<br>                quene.append(tmp.right)<br>        height += 1<br>    return height","like_count":0},{"had_liked":false,"id":216864,"user_name":"你在不远的未来","can_delete":false,"product_type":"c1","uid":1318404,"ip_address":"","ucode":"5B34C8BD03B71A","user_header":"https://static001.geekbang.org/account/avatar/00/14/1e/04/f902047e.jpg","comment_is_top":false,"comment_ctime":1589356897,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589356897","product_id":100017301,"comment_content":"static void delete(TreeNode root, int val) {<br>        TreeNode p = root;<br>        TreeNode pp = null;<br><br>        &#47;&#47;查找等值节点<br>        while (null != p &amp;&amp; val != p.getValue()) {<br>            if (val &lt; p.getValue()) {<br>                pp = p;<br>                p = p.getLeft();<br>            }<br>            else {<br>                pp = p;<br>                p = p.getRight();<br>            }<br>        }<br><br>        &#47;&#47;未找到节点，或者删除节点为根节点不做删除操作<br>        if (p == null || pp == null) return;<br><br><br>        if (null != p.getLeft() &amp;&amp; null != p.getRight()) {<br>            TreeNode minRight = min(p.getRight());<br>            p.setValue(minRight.getValue());<br>            delete(p.getRight(), minRight.getValue());<br>        }<br><br>        else {<br>            &#47;&#47;单子节点或者无子节点情况<br>            TreeNode child = null;<br>            if (p.getLeft() == null) child = p.getRight();<br>            if (p.getRight() == null) child = p.getLeft();<br><br>            if (pp.getLeft() == p)<br>                pp.setLeft(child);<br>            else<br>                pp.setRight(child);<br>        }<br><br>    }<br><br>    &#47;**<br>     * 查找最小值节点<br>     * @param root 查找节点<br>     * @return<br>     *&#47;<br>    private static TreeNode min(TreeNode root) {<br>        while (root.getLeft() != null)<br>            root = root.getLeft();<br>        return root;<br>    }","like_count":0},{"had_liked":false,"id":216601,"user_name":"Geek_24a055","can_delete":false,"product_type":"c1","uid":1879556,"ip_address":"","ucode":"1DFFE6E7C0A75D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI735OGP6zMxdhVRdiaP5ice2ibdtOk1XkdzIqRiawy5NUCYh4iaWhr9f4CUW7gatnZMicL6vZJjCgY8TDg/132","comment_is_top":false,"comment_ctime":1589293821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589293821","product_id":100017301,"comment_content":"二叉查找树的删除节点时，只能选取其子节点的叶子节点来替换当前要删除的节点，因为只有这样才能保证每个节点最多只有两个节点，选取替换子节点只有两个人选，左子树的最右节点和右子树的最左节点，因为选这两个节点不会破坏二叉查找树的这种特殊结构，不知这样理解正不正确","like_count":0},{"had_liked":false,"id":215786,"user_name":"RedDevil","can_delete":false,"product_type":"c1","uid":1131128,"ip_address":"","ucode":"F8F5DC209BB3B9","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","comment_is_top":false,"comment_ctime":1589102927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589102927","product_id":100017301,"comment_content":"老师的代码太优雅了，难以企及","like_count":0},{"had_liked":false,"id":215534,"user_name":"陈小狮","can_delete":false,"product_type":"c1","uid":1458026,"ip_address":"","ucode":"7679BA5775DC9C","user_header":"https://static001.geekbang.org/account/avatar/00/16/3f/6a/e68b9f23.jpg","comment_is_top":false,"comment_ctime":1589012122,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589012122","product_id":100017301,"comment_content":"看了老师github上的findMax和findMin代码，个人稍微修改了一下第一条判断语句，不知是否合适：<br>findMax时 if ( tree == null || tree.right == null ) return tree;<br>findMin时  if ( tree == null || tree.left == null ) return tree;","like_count":0},{"had_liked":false,"id":214995,"user_name":"亢（知行合一的路上）","can_delete":false,"product_type":"c1","uid":1347013,"ip_address":"","ucode":"958AF7C96EB9E8","user_header":"https://static001.geekbang.org/account/avatar/00/14/8d/c5/898b13b4.jpg","comment_is_top":false,"comment_ctime":1588864994,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588864994","product_id":100017301,"comment_content":"关于重复数据如何存储，老师说第二种方法优雅，是不是不需要借助其它链表，重复内容的节点通过父子关系连在一起，本身就是一个链表了？妙啊","like_count":0},{"had_liked":false,"id":213869,"user_name":"道道","can_delete":false,"product_type":"c1","uid":1441363,"ip_address":"","ucode":"556FCCBFB46C25","user_header":"https://static001.geekbang.org/account/avatar/00/15/fe/53/3e712c6a.jpg","comment_is_top":false,"comment_ctime":1588580736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588580736","product_id":100017301,"comment_content":"争哥，写的真是好，第二遍学习了，打个卡","like_count":0},{"had_liked":false,"id":213434,"user_name":"严丹","can_delete":false,"product_type":"c1","uid":1798204,"ip_address":"","ucode":"96FA634D06C3FD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/70/3c/a002615b.jpg","comment_is_top":false,"comment_ctime":1588413107,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1588413107","product_id":100017301,"comment_content":"树这一块以前基础薄弱，感觉难度慢慢上来了","like_count":0},{"had_liked":false,"id":213402,"user_name":"Allan","can_delete":false,"product_type":"c1","uid":1310388,"ip_address":"","ucode":"8DA4DBECC2C45C","user_header":"https://static001.geekbang.org/account/avatar/00/13/fe/b4/295338e7.jpg","comment_is_top":false,"comment_ctime":1588404815,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588404815","product_id":100017301,"comment_content":"二叉树基础（下）：有了如此高效的散列表，为什么还需要二叉树？（一）<br><br>今天是二叉树基础的第三部分。二叉查找树和散列表一样，都支持动态数据集合的快速插入、删除、查找操作。通过学习这些操作，我们可以深入理解二叉查找树的特殊结构。<br><br>1.二叉查找树的查找操作<br>如果比父节点小，则往左节点走，比父节点大则走右边的节点。<br>2.二叉查找树的插入操作<br>插入操作同样是先判断它插入的位置大于父节点 右边，小于走左边，直到比的这个节点左节点，或者右节点为空，那么就是插入的位置。<br>3.二叉查找树的删除操作<br>删除要分三种情况，删除的节点没有子节点，那么直接删除 给 null；有一个节点，那么直接把引用指向子节点；有两个节点，比较复杂，需要找到这个节点右子树的最小左节点，因为最小左节点就是左子树的最大节点，用它来替换删除的节点正合适。<br>4.二叉查找树的其他操作<br>支持重复数据的二叉查找树 插入相同的值，那么就当作大于这个值来处理。<br><br>高度：遍历二叉树，按照右子树或者左子树都可以，每找一步加一，直到找到右子树或者左子树最后的一个为空节点，比较左子树于右子树的遍历大小，谁的大就是树的高度。","like_count":0},{"had_liked":false,"id":212559,"user_name":"默默","can_delete":false,"product_type":"c1","uid":1006635,"ip_address":"","ucode":"AF798B9D327F24","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/2b/8b771383.jpg","comment_is_top":false,"comment_ctime":1588148922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588148922","product_id":100017301,"comment_content":"可以用递归解决<br>递推公式：height = max(height(node.right) + height(node.left)) + 1<br>终止条件：node == null return -1","like_count":0},{"had_liked":false,"id":210271,"user_name":"骞子 ©","can_delete":false,"product_type":"c1","uid":1032130,"ip_address":"","ucode":"4267E454874518","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bf/c2/d9b4a584.jpg","comment_is_top":false,"comment_ctime":1587711063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587711063","product_id":100017301,"comment_content":"老师您好，<br>在删除代码中有一段为 pp = minPP;没有想明白含义，如果看到了能帮忙解答一下吗？","like_count":0},{"had_liked":false,"id":206761,"user_name":"梅端","can_delete":false,"product_type":"c1","uid":1525335,"ip_address":"","ucode":"FEC08731457770","user_header":"https://static001.geekbang.org/account/avatar/00/17/46/57/fe38a6db.jpg","comment_is_top":false,"comment_ctime":1586930939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586930939","product_id":100017301,"comment_content":"由于没有手动实现过二叉查找树，所以感觉理解得还不是很到位，coding起。。","like_count":0},{"had_liked":false,"id":205913,"user_name":"子铭","can_delete":false,"product_type":"c1","uid":1156419,"ip_address":"","ucode":"221383803E5732","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/43/d32dd35a.jpg","comment_is_top":false,"comment_ctime":1586756078,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586756078","product_id":100017301,"comment_content":"如果要删除的节点下有两个节点，为什么要从右边找一个最小子节点呢？如何证明这个就比要删除节点的左节点大呢？<br>没有明白","like_count":0},{"had_liked":false,"id":205656,"user_name":"artshell","can_delete":false,"product_type":"c1","uid":1122074,"ip_address":"","ucode":"A74C45DA8FC550","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/1a/54a00fdb.jpg","comment_is_top":false,"comment_ctime":1586696589,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586696589","product_id":100017301,"comment_content":"“L 的范围是[log2(n+1), log2n +1]。完全二叉树的层数小于等于 log2n +1，也就是说，完全二叉树的高度小于等于 log2n” <br><br>这里应该是：<br><br>“L 的范围是[log2n+1), log2(n +1)]。完全二叉树的层数小于等于 log2(n +1)，也就是说，完全二叉树的高度小于等于 log2(n +1)-1”","like_count":0},{"had_liked":false,"id":202441,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585988968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585988968","product_id":100017301,"comment_content":"&#47;&#47; 删除指定值的节点<br>\tpublic function delete($data) {<br>\t\t<br>\t\twhile (true) {<br>\t\t\t$p = $this-&gt;root;<br>\t\t\t$pp = null;<br>\t\t\t$childType = 0; &#47;&#47; 用来保存当前节点是父节点的左子节点还是右子节点 1左节点  2右节点<br>\t\t\twhile (!empty($p) &amp;&amp; ($p-&gt;data != $data)) {<br>\t\t\t\t$pp = $p;<br>\t\t\t\tif ($data &gt; $p-&gt;data) { &#47;&#47; 要删除的节点的右子树上<br>\t\t\t\t\t$p = $p-&gt;rightChild;<br>\t\t\t\t\t$childType = 2; &#47;&#47; 右子节点<br>\t\t\t\t} elseif ($data &lt; $p-&gt;data) { &#47;&#47; 要删除的节点的左子树上 <br>\t\t\t\t\t$p = $p-&gt;leftChild;<br>\t\t\t\t\t$childType = 1; &#47;&#47; 左子节点<br>\t\t\t\t} <br>\t\t\t\t<br>\t\t\t}<br>\t\t\tif (empty($p)) { &#47;&#47; 说明没有找到相关节点<br>\t\t\t\techo &quot;所有的节点都删除完了&lt;br&gt;&quot;;<br>\t\t\t\treturn;<br>\t\t\t}<br>\t\t\t<br>\t\t\t<br>\t\t\tif (!empty($p-&gt;leftChild) &amp;&amp; !empty($p-&gt;rightChild)) { &#47;&#47; 如果节点右两个子节点<br>\t\t\t\t&#47;&#47; 要删除的节点有两个子节点时，获取他的右子树上的最小节点<br>\t\t\t\t$minP = $p-&gt;rightChild;<br>\t\t\t\t$minPP = $p;<br>\t\t\t\t$childType=2;<br>\t\t\t\twhile (!empty($minP-&gt;leftChild)) {<br>\t\t\t\t\t$minPP = $minP;<br>\t\t\t\t\t$minP = $minP-&gt;leftChild;<br>\t\t\t\t\t$childType = 1; &#47;&#47; 要删除的节点是父节点的左子节点<br>\t\t\t\t}<br>\t\t\t\t$p-&gt;data = $minP-&gt;data;<br>\t\t\t\t$p = $minP; &#47;&#47; 需要删除的节点赋值给$p<br>\t\t\t\t$pp = $minPP;<br>\t\t\t\t<br>\t\t\t} <br>\t\t\t&#47;&#47; 删除节点<br>\t\t\tif (!empty($p-&gt;leftChild)) {<br>\t\t\t\t$child = $p-&gt;leftChild;<br>\t\t\t} elseif (!empty($p-&gt;rightChild)) {<br>\t\t\t\t$child = $p-&gt;rightChild;<br>\t\t\t} else {<br>\t\t\t\t$child = null;<br>\t\t\t}<br>\t\t\t<br>\t\t\tif (empty($pp)) { &#47;&#47; 删除根节点<br>\t\t\t\t$this-&gt;root = $child;<br>\t\t\t} else {<br>\t\t\t\tif($childType == 1) {<br>\t\t\t\t\t$pp-&gt;leftChild=$child;<br>\t\t\t\t} elseif($childType ==2 ) {<br>\t\t\t\t\t$pp-&gt;rightChild=$child;<br>\t\t\t\t}<br>\t\t\t}<br>\t\t\tunset($p);<br>\t\t\techo &quot;删除掉一个节点&lt;br&gt;&quot;;<br>\t\t}<br>\t}","like_count":0},{"had_liked":false,"id":202440,"user_name":"喻茂","can_delete":false,"product_type":"c1","uid":1318661,"ip_address":"","ucode":"C8BD8086A17365","user_header":"https://static001.geekbang.org/account/avatar/00/14/1f/05/8a06692e.jpg","comment_is_top":false,"comment_ctime":1585988951,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585988951","product_id":100017301,"comment_content":"&#47;&#47; 插入节点<br>\tpublic function insert($data) {<br>\t\tif (empty($this-&gt;root)) { &#47;&#47; 空树<br>\t\t\t$this-&gt;root = new Node($data);<br>\t\t\treturn;<br>\t\t}<br>\t\t<br>\t\t$p = $this-&gt;root;<br>\t\twhile (!empty($p)) {<br>\t\t\tif ($data &gt;= $p-&gt;data) { &#47;&#47; 说明数据要插入右子树<br>\t\t\t\tif (empty($p-&gt;rightChild)){<br>\t\t\t\t\t$p-&gt;rightChild = new Node($data);<br>\t\t\t\t\treturn;<br>\t\t\t\t}<br>\t\t\t\t$p = $p-&gt;rightChild;<br>\t\t\t} else { &#47;&#47; 插入左子树<br>\t\t\t\tif (empty($p-&gt;leftChild)) {<br>\t\t\t\t\t$p-&gt;leftChild = new Node($data);<br>\t\t\t\t\treturn;<br>\t\t\t\t}<br>\t\t\t\t$p = $p-&gt;leftChild;<br>\t\t\t}<br>\t\t}<br>\t}","like_count":0},{"had_liked":false,"id":201168,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1086220,"ip_address":"","ucode":"01CC18F12E556D","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/0c/0a6a0d5e.jpg","comment_is_top":false,"comment_ctime":1585726619,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585726619","product_id":100017301,"comment_content":"深度和层","like_count":0},{"had_liked":false,"id":196531,"user_name":"SteelHuaSheng","can_delete":false,"product_type":"c1","uid":1396126,"ip_address":"","ucode":"BC8127FC5207FC","user_header":"https://static001.geekbang.org/account/avatar/00/15/4d/9e/04ec08bf.jpg","comment_is_top":false,"comment_ctime":1585290448,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1585290448","product_id":100017301,"comment_content":"二叉树的删除逻辑理解了，但是代码看了好半天，还是不熟悉，要多练啊。<br>数学都还给老师了，太忧伤了。","like_count":0},{"had_liked":false,"id":194197,"user_name":"小谢","can_delete":false,"product_type":"c1","uid":1879476,"ip_address":"","ucode":"82D54A61D2FDB9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ad/b4/e4dcd4d7.jpg","comment_is_top":false,"comment_ctime":1585036739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585036739","product_id":100017301,"comment_content":"感觉当只有一个节点的时候代码还是存在漏洞，如果直接让待删除节点的父节点指向待删除节点的子节点的话，可能会丢失二叉查找树的特点，就像删除13一样如果它的右子节点是17那么就不符合二叉搜索树的特点了","like_count":0},{"had_liked":false,"id":191408,"user_name":"叮叮叮","can_delete":false,"product_type":"c1","uid":1914201,"ip_address":"","ucode":"956C42489F25DB","user_header":"https://static001.geekbang.org/account/avatar/00/1d/35/59/3a7219de.jpg","comment_is_top":false,"comment_ctime":1584771124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584771124","product_id":100017301,"comment_content":"方法一：递归，root的高度等于 max{左子树高度，右子树高度}+1<br>方法二：层次遍历做个level标记","like_count":0},{"had_liked":false,"id":190708,"user_name":"小谢","can_delete":false,"product_type":"c1","uid":1879476,"ip_address":"","ucode":"82D54A61D2FDB9","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ad/b4/e4dcd4d7.jpg","comment_is_top":false,"comment_ctime":1584685458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584685458","product_id":100017301,"comment_content":"二叉查找树<br>开篇问题：为什么散列表删除插入查找都是O(1)比二叉查找树效率高还要存在二叉查找树<br>1.散列冲突的性能不稳定,时间也不一定更短<br>2.动态扩容耗时较长<br>3.数据无序,如果要求有序输出,还需要额外排序<br>二叉树的操作<br>1.查找<br>2.插入<br>3.删除(三种情况)","like_count":0},{"had_liked":false,"id":189995,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1584590173,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584590173","product_id":100017301,"comment_content":"  def maxDepth(self, root: TreeNode) -&gt; int:<br>        if not root:<br>            return 0<br>        leftDepth = self.maxDepth(root.left)<br>        rightDepth = self.maxDepth(root.right)<br>        return max(leftDepth, rightDepth) + 1","like_count":0},{"had_liked":false,"id":189037,"user_name":"面向百度编程","can_delete":false,"product_type":"c1","uid":1732780,"ip_address":"","ucode":"8FE04A019D71D1","user_header":"https://static001.geekbang.org/account/avatar/00/1a/70/ac/83bc14c0.jpg","comment_is_top":false,"comment_ctime":1584449146,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584449146","product_id":100017301,"comment_content":"装载因子不是太小，才浪费空间么，说反了吧","like_count":0},{"had_liked":false,"id":184635,"user_name":"长期规划","can_delete":false,"product_type":"c1","uid":1019332,"ip_address":"","ucode":"5EF65E9115834B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8d/c4/6f97daea.jpg","comment_is_top":false,"comment_ctime":1583375634,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583375634","product_id":100017301,"comment_content":"删除时，用左子树的最大节点，或右子树的最小节点填补删除节点应该都可以。因为对于删除节点X来说，有left &lt; X &lt; right，即X大于左子树的所有节点，小于右子树的所有节点。即left &lt; right，左子树的所有节点小于右子树的所有节点。即left(去掉最大节点) &lt; max(left) &lt; right，用max(left)当新的根节点是可以的","like_count":0},{"had_liked":false,"id":183123,"user_name":"Jacky","can_delete":false,"product_type":"c1","uid":1520450,"ip_address":"","ucode":"8EFB6DB3C0CA49","user_header":"https://static001.geekbang.org/account/avatar/00/17/33/42/780b7855.jpg","comment_is_top":false,"comment_ctime":1582956769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582956769","product_id":100017301,"comment_content":"删除这块写的妙，👍🏻","like_count":0},{"had_liked":false,"id":182377,"user_name":"云之崖","can_delete":false,"product_type":"c1","uid":1003366,"ip_address":"","ucode":"724C0614F40EC1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4f/66/1f8fccfb.jpg","comment_is_top":false,"comment_ctime":1582775860,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582775860","product_id":100017301,"comment_content":"kotlin代码层序遍历，以及打印出树的总高度算法：<br><br>class TreeNode&lt;T&gt; {<br>    var data: T? = null<br>    var left: TreeNode&lt;T&gt;? = null<br>    var right: TreeNode&lt;T&gt;? = null<br>}<br><br>&#47;**<br> * 层序遍历<br> *&#47;<br>fun &lt;T&gt; levelOrder(root: TreeNode&lt;T&gt;?): List&lt;T?&gt; {<br>    root ?: return ArrayList(0)<br>    val result = ArrayList&lt;T?&gt;()<br>    &#47;&#47;创建一个队列<br>    val queue = LinkedList&lt;TreeNode&lt;T&gt;&gt;()<br>    var levelCount = 0<br><br>    &#47;&#47;先将根节点入队<br>    queue.offer(root)<br>    &#47;&#47;第1层只有一个根节点<br>    var currLevelNodeCount = 1<br>    &#47;&#47;记录下一层有几个节点<br>    var nextLevelNodeCount = 0<br><br>    while (queue.isNotEmpty()) {<br>        &#47;&#47;先出队1个节点<br>        var node = queue.poll()<br>        result.add(node.data)<br>        &#47;&#47;当前层的节点数-1<br>        currLevelNodeCount--<br><br>        node.left?.let {<br>            queue.offer(node.left)<br>            &#47;&#47;下一层节点数+1<br>            nextLevelNodeCount++<br>        }<br>        node.right?.let {<br>            queue.offer(node.right)<br>            &#47;&#47;下一层节点数+1<br>            nextLevelNodeCount++<br>        }<br><br>        &#47;&#47;如果当前层的节点全部出队完毕<br>        if (currLevelNodeCount == 0) {<br>            &#47;&#47;树的总层数+1<br>            levelCount++<br>            &#47;&#47;开始遍历下一层节点了<br>            currLevelNodeCount = nextLevelNodeCount<br>            nextLevelNodeCount = 0<br>        }<br>    }<br><br>    println(&quot;level count = $levelCount&quot;)<br>    return result<br>}","like_count":0},{"had_liked":false,"id":181139,"user_name":"种个大西瓜","can_delete":false,"product_type":"c1","uid":1079643,"ip_address":"","ucode":"CC55BA6F0EB065","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/5b/ca9de5a2.jpg","comment_is_top":false,"comment_ctime":1582504687,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1582504687","product_id":100017301,"comment_content":"二叉树在实际工程代码应用中，通常解决了哪些问题，哪些场景下会用到","like_count":0},{"had_liked":false,"id":174291,"user_name":"【K E D E】","can_delete":false,"product_type":"c1","uid":1756555,"ip_address":"","ucode":"6206DD40FA7364","user_header":"https://static001.geekbang.org/account/avatar/00/1a/cd/8b/71b356ec.jpg","comment_is_top":false,"comment_ctime":1580123809,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580123809","product_id":100017301,"comment_content":"（接上条）<br>2、使用老师的思路，将既拥有左孩子又拥有右孩子的该删除结点转移成为用于接替他的结点，这个结点必不可能有左孩子，最后删除的就是只有左孩子、只有右孩子、或者叶子节点。<br>    def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode:<br>        del_node = root<br>        del_father_node = None<br>        while(del_node and del_node.val != key):<br>            del_father_node = del_node<br>            if del_node.val &gt; key: del_node = del_node.left<br>            else: del_node = del_node.right<br>        if not del_node: return root<br>        if del_node.left and del_node.right:<br>            min_node = del_node.right<br>            min_node_father = del_node<br>            while(min_node and min_node.left):<br>                min_node_father = min_node<br>                min_node = min_node.left<br>            del_node.val = min_node.val<br>            key = min_node.val<br>            del_node = min_node<br>            del_father_node = min_node_father<br>        # child是左孩子或者右孩子<br>        if del_node.left: child = del_node.left<br>        elif del_node.right: child = del_node.right<br>        else: child = None<br>        if not del_father_node: root = child #删除的是根节点<br>        elif del_father_node.left == del_node: del_father_node.left = child<br>        else: del_father_node.right = child<br>        return root","like_count":0},{"had_liked":false,"id":174290,"user_name":"【K E D E】","can_delete":false,"product_type":"c1","uid":1756555,"ip_address":"","ucode":"6206DD40FA7364","user_header":"https://static001.geekbang.org/account/avatar/00/1a/cd/8b/71b356ec.jpg","comment_is_top":false,"comment_ctime":1580123797,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580123797","product_id":100017301,"comment_content":"二叉查找树的删除操作（无重复数据）python代码<br>1、递归实现<br>    def deleteNode(self, root: TreeNode, key: int) -&gt; TreeNode:<br>        if not root: return <br>        if key &lt; root.val:<br>            root.left = self.deleteNode(root.left, key)<br>            return root<br>        elif key &gt; root.val:<br>            root.right = self.deleteNode(root.right, key)<br>            return root<br>        else:<br>            if not root.left and not root.right:<br>                return None<br>            elif not root.left and root.right:<br>                p = root.right<br>                root.right = None<br>                return p<br>            elif root.left and not root.right:<br>                p = root.left<br>                root.left = None<br>                return p<br>            else:<br>                minNode = self.__getmin(root.right)<br>                root.val = minNode.val<br>                root.right = self.deleteNode(root.right, minNode.val)<br>                return root<br>    def __getmin(self, root):<br>        while(root.left):<br>            root = root.left<br>        return root<br>","like_count":0},{"had_liked":false,"id":174189,"user_name":"pikachu122","can_delete":false,"product_type":"c1","uid":1689365,"ip_address":"","ucode":"43FE4DBC872FFA","user_header":"https://static001.geekbang.org/account/avatar/00/19/c7/15/24bf166a.jpg","comment_is_top":false,"comment_ctime":1580053725,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580053725","product_id":100017301,"comment_content":"1、二叉查找树是最常用的一种二叉树。它要求左子树中每一个节点的值都小于这个节点的值，右子树中每一个结点的值都大于这个节点的值。<br>2、对于有重复数据的情况，可以有两种解决方法，一是把所有相同数据都存储在一个节点上（利用链表或者可扩容数组），二是把所有相同值都放在右子节点上，当作大于这个节点处理。每当查找时找到这个节点不停止查找，而是沿着右子节点一直查找到叶子节点为止。<br>3、二叉搜索树的查找操作：从根节点开始，比较这个值与被查找值是否相等，相等则返回，大于被找值则在左子树找，小于被找值则在右子树找。<br>4、二叉搜索树的插入操作：从根节点开始，如果插入数大于该节点，则看右子节点，为空就插入该数，不为空则继续比较。如果插入数小于该节点，则看左子节点，为空就插入该数，不为空则继续比较。<br>5、二叉搜索树的删除操作：如果没有子节点，直接移除该点（父节点指向该点指针设为null）。如果有一个子结点，就把父节点指向该节点的指针指向它的子节点。如果有两个子节点，先找出该节点右子树中的最小节点，将要删除节点的值设为这个最小节点，然后删除原先的最小节点。<br>6、二叉查找树的插入、删除、查找等操作的时间复杂度与树的高度成正比，树为完全二叉树时时间复杂度最小，为O(logn)，树退化为链表时时间复杂度最大，为O(n)。<br>7、为了防止时间复杂度退化，我们设计了更加复杂的树——平衡二叉树，它的时间复杂度可以稳定在O(logn)。","like_count":0},{"had_liked":false,"id":171940,"user_name":"geek_syk","can_delete":false,"product_type":"c1","uid":1684882,"ip_address":"","ucode":"1CAA40765D1F23","user_header":"https://static001.geekbang.org/account/avatar/00/19/b5/92/ac0d4705.jpg","comment_is_top":false,"comment_ctime":1579055901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579055901","product_id":100017301,"comment_content":"二叉树的删除操作的第三种情况，准确来说应该是要找叶子节点","like_count":0},{"had_liked":false,"id":169878,"user_name":"风骑","can_delete":false,"product_type":"c1","uid":1017289,"ip_address":"","ucode":"D96526F7F37442","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKDe7Ep3YW87sWJLc9GzgA2z1CSyHI3iaZQpCLzM2O1e30CQywGsMj5cQyh6pTGybvFgN0bTuWE8nA/132","comment_is_top":false,"comment_ctime":1578467661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578467661","product_id":100017301,"comment_content":"二叉树的数组存储的话，每一层的数组索引存储应该是从2^i 到 2^(i+1) -1吧，因为王争老师提到这块的时候，只是提了2^i和2^i+1，不知道我计算的对不对","like_count":0},{"had_liked":false,"id":167378,"user_name":"秀秀","can_delete":false,"product_type":"c1","uid":1145162,"ip_address":"","ucode":"9D4D327324570B","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/4a/10348395.jpg","comment_is_top":false,"comment_ctime":1577780318,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577780318","product_id":100017301,"comment_content":"&#47;&#47; 要删除的节点有两个子节点<br>    if (p.left != null &amp;&amp; p.right != null) { &#47;&#47; 查找右子树中最小节点<br>      Node minP = p.right;<br>      Node minPP = p; &#47;&#47; minPP表示minP的父节点<br>      while (minP.left != null) {<br>        minPP = minP;<br>        minP = minP.left;<br>      }<br>      p.data = minP.data; &#47;&#47; 将minP的数据替换到p中<br>      p = minP; &#47;&#47; 下面就变成了删除minP了<br>      pp = minPP;<br>    }<br><br>最后那里，是不是应该<br>p.data = minP.data;<br>minPP.left = null;","like_count":0},{"had_liked":false,"id":166532,"user_name":"Momentum","can_delete":false,"product_type":"c1","uid":1398396,"ip_address":"","ucode":"9822B01061FE79","user_header":"https://static001.geekbang.org/account/avatar/00/15/56/7c/a30223c1.jpg","comment_is_top":false,"comment_ctime":1577480981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577480981","product_id":100017301,"comment_content":"删除只要取离他最近的值就行了","like_count":0},{"had_liked":false,"id":165789,"user_name":"Mr_scx","can_delete":false,"product_type":"c1","uid":1239546,"ip_address":"","ucode":"28B5CE68A5A339","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKWiaZb7a2JAcIVlXYuZ3iaPfSF6vBbg3yUps6LKpsZarftyXufMHYKJmMKzH3bIpVkDAVNXE9q0oOw/132","comment_is_top":false,"comment_ctime":1577323123,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577323123","product_id":100017301,"comment_content":"“为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间”<br>请问作者，这里说装载因子不能太大，不然会浪费存储空间，也就是说，装载因子小一点比较节省内存？装载因子的定义：已经填入散列表中的元素个数&#47;散列表长度，那么装载因子小，意味着空位更多，比如申请了一个数组空间，比较多地方不存储数据，这不是更加浪费内存吗？而装载因子大一点，易发生冲突，但是搜索的范围还在这个数组空间中，所以请问整句话该如何理解呢？谢谢~","like_count":0},{"had_liked":false,"id":163998,"user_name":"技术小生","can_delete":false,"product_type":"c1","uid":1692743,"ip_address":"","ucode":"18B7751498029F","user_header":"https://static001.geekbang.org/account/avatar/00/19/d4/47/0deb44d6.jpg","comment_is_top":false,"comment_ctime":1576843876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576843876","product_id":100017301,"comment_content":"通过广度优先是否可以计算树的高度","like_count":0},{"had_liked":false,"id":162956,"user_name":"梨子苹果","can_delete":false,"product_type":"c1","uid":1716067,"ip_address":"","ucode":"3666813FEE31D3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/2f/63/7a048d46.jpg","comment_is_top":false,"comment_ctime":1576634541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576634541","product_id":100017301,"comment_content":"按层次遍历的话也可以求出树的高度就是出队那一层的节点的最右节点的时候给右节点记录层数加一即可，最后一个出队的节点就知道层数了","like_count":0},{"had_liked":false,"id":162954,"user_name":"dream","can_delete":false,"product_type":"c1","uid":1117793,"ip_address":"","ucode":"65B33D32FA8BE9","user_header":"https://static001.geekbang.org/account/avatar/00/11/0e/61/ae68f8eb.jpg","comment_is_top":false,"comment_ctime":1576634474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576634474","product_id":100017301,"comment_content":"老师，请问一下，二叉查找树中有两个相同的值怎么存储的呢？","like_count":0},{"had_liked":false,"id":162665,"user_name":"昨天的你的现在的未来","can_delete":false,"product_type":"c1","uid":1511709,"ip_address":"","ucode":"1B4D6188759089","user_header":"https://static001.geekbang.org/account/avatar/00/17/11/1d/d86814d8.jpg","comment_is_top":false,"comment_ctime":1576575435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576575435","product_id":100017301,"comment_content":"有的资料说，删除18那个节点的时候，应该是把17和18换位置，然后删除18","like_count":0},{"had_liked":false,"id":161461,"user_name":"春和景明","can_delete":false,"product_type":"c1","uid":1272482,"ip_address":"","ucode":"A27970A276ECD6","user_header":"https://static001.geekbang.org/account/avatar/00/13/6a/a2/f9efd9dc.jpg","comment_is_top":false,"comment_ctime":1576209816,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1576209816","product_id":100017301,"comment_content":"对于删除节点，我的代码是这样写的：<br><br>from typing import TypeVar, Generic, Optional, Generator<br><br>T = TypeVar(&quot;T&quot;)<br><br><br>class TreeNode(Generic[T]):<br>    def __init__(self, value):<br>        self.value = value<br>        self.left = None<br>        self.right = None<br><br>def remove(node: Optional[TreeNode], data: Generic[T]) -&gt; Optional[TreeNode]:<br>    pp = None<br>    while node and node.value != data:<br>        pp = node  # 被删除节点的父节点<br>        node = node.left if node.value &gt; data else node.right  # node是被删除节点<br><br>    if node is None:  # 没找到<br>        return None<br><br>    # 被删除的节点有两个子节点<br>    if node.left and node.right:  # 寻找右子树的最小节点（这个节点肯定没有左子节点，要么是叶子节点要么只有一个右子节点）<br>        min_p = node.right  # 最小节点，初始化为被删除节点的右节点<br>        min_pp = node  # 最小节点的父节点，初始化为被删除节点<br>        while min_p.left:  # 最小节点肯定在被删除节点的右子树的左子树中<br>            min_p = min_p.left<br>            min_pp = min_p<br>        node.value = min_p.value  # 最小节点的值放到node上<br>        # 这两句话就是把问题转化为删除最小节点min_p的问题了（画下图就能明白了）<br>        pp = min_pp<br>        node = min_p<br><br>    # 删除的节点是叶子节点或者仅有一个子节点（如果上面的if成立，这里的node就是min_p了）<br>    if node.left:  # 当有一个左子节点，找到它的子节点child<br>        child = node.left<br>    elif node.right:  # 当有一个右子节点，找到它的子节点child<br>        child = node.right<br>    else:  # node是叶子节点，它的子节点就是None<br>        child = None<br>    if pp is None:<br>        node = child<br>    elif pp.left == node:<br>        pp.left = child<br>    else:<br>        pp.right = child<br><br><br>if __name__ == &#39;__main__&#39;:<br>    root = TreeNode(16)<br>    first = TreeNode(10)<br>    second = TreeNode(9)<br>    third = TreeNode(13)<br>    fourth = TreeNode(11)<br>    fifth = TreeNode(14)<br>    seven = TreeNode(18)<br>    root.left = first<br>    root.right = seven<br>    first.left = second<br>    first.right = third<br>    third.left = fourth<br>    third.right = fifth<br><br>    remove(root, 16)<br>    print(list(in_order(root)))<br><br>但是发现如果注释掉 root.right = seven 之后，删除根节点就不work了。也即是只有左子树或者右子树的根节点，在用我的方法删除时，不能正常工作。请各位高手指点。","like_count":0},{"had_liked":false,"id":161354,"user_name":"梦想的优惠券","can_delete":false,"product_type":"c1","uid":1257418,"ip_address":"","ucode":"D3B44F6C618CA7","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ca/cbce6e94.jpg","comment_is_top":false,"comment_ctime":1576197684,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1576197684","product_id":100017301,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":161141,"user_name":"唯威奋斗","can_delete":false,"product_type":"c1","uid":1329103,"ip_address":"","ucode":"B6BC3B145D1593","user_header":"","comment_is_top":false,"comment_ctime":1576129758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576129758","product_id":100017301,"comment_content":"不好意思，删除18的时候没有看明白，删除18的时候是不是把18和19的数据部分替换一下，然后将25的左字节点指向null就i可以了？请老师指点，谢谢啦","like_count":0},{"had_liked":false,"id":159811,"user_name":"1011001","can_delete":false,"product_type":"c1","uid":1573301,"ip_address":"","ucode":"8658491E9386FB","user_header":"https://static001.geekbang.org/account/avatar/00/18/01/b5/3fd2a38d.jpg","comment_is_top":false,"comment_ctime":1575795932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575795932","product_id":100017301,"comment_content":"dfs解法<br>class Solution:       <br>    def maxDepth(self, root: TreeNode) -&gt; int:<br>        if root is None:<br>            return 0<br>        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1","like_count":0},{"had_liked":false,"id":159462,"user_name":"帽子丨影","can_delete":false,"product_type":"c1","uid":1225395,"ip_address":"","ucode":"2B34892A2DE83E","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/b3/798a4bb2.jpg","comment_is_top":false,"comment_ctime":1575629324,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575629324","product_id":100017301,"comment_content":"辅助学习神器，直观的输出二叉树代码 https:&#47;&#47;blog.csdn.net&#47;lenfranky&#47;article&#47;details&#47;89645755","like_count":0},{"had_liked":false,"id":158812,"user_name":"何雷","can_delete":false,"product_type":"c1","uid":1737805,"ip_address":"","ucode":"FA9BCE7DD9C8C4","user_header":"https://static001.geekbang.org/account/avatar/00/1a/84/4d/84371716.jpg","comment_is_top":false,"comment_ctime":1575457488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575457488","product_id":100017301,"comment_content":"不是很理解，怎么通过链表和动态扩容的数组在一个节点上存储多个key相同的数据。再维护一个指针指向这个链表吗","like_count":0},{"had_liked":false,"id":156362,"user_name":"Geek_949cc1","can_delete":false,"product_type":"c1","uid":1690476,"ip_address":"","ucode":"F8ACDBF2FA8CC2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKFRiaFrpOTVBuKicMficasBFuF2VY7EnUnLeFcvIn0R5OiaQsOcpJHNM5TusoPHMjIvSfia46c0EWH9mQ/132","comment_is_top":false,"comment_ctime":1574861971,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574861971","product_id":100017301,"comment_content":"二叉查找树&#47;二叉排序树：在树中的任意一个节点，其左子节点都要小于它，右子节点都要大于它。<br>二叉查找树的查找操作：节点node，数据data，如果data&lt;node就在左子树中查找，大于node就在右子树中查找，等于这返回。<br>二叉查找树的插入操作：跟查找差不多，只是在找数据data的插入位置。<br>二叉查找树的删除操作：1：没有叶子节点，这只需要将它的父节点指向null 2：有一个叶子节点，就需要将父节点指向该叶子节点，在释放空间。 3：有左右节点，首先需要找到该删除节点右子树中的最小节点，然后用右子树中的最小节点来替换该要删除的节点即可。<br>二叉查找树的中序遍历就是一个有序序列，从小到大的。<br>对重复数据的处理：当遇见重复数据将其存储在右子树中，这样在查找的时候，当遇见键相同时，我们还需要在其右子树中进行查找，直到查找到叶子节点才结束。<br>时间复杂度：跟树的高度有关，最差为O(n),对于满二叉树或者完全二叉树，时间复杂度在【log2(n+1),log2(n)+1】<br>散列表和二叉查找树的比较：<br>1：散列表中的数据是无序的，如果要输出有效数据需要先排序，对于二叉查找树来说只需要中序遍历。<br>2：散列表扩容耗时很多，而且当遇到散列冲突时，性能很不稳定，尽管二叉查找树的性能也不稳定，但是平衡二叉查找树很稳定，时间复杂度是O（n）.<br>3：散列表由于散列冲突，散列函数计算等时间的花费，导致其时间不一定比二叉查找树块。<br>4：散列表的设计很复杂，需要考虑很多东西，比如散列函数的设计，冲突的解决办法，扩容，缩容等。但是平衡二叉查找树只需要考虑平衡性。<br>5：散列表比较浪费内存，除非用开放寻址法，但是开放寻址法，在装载因子过大时，无论查找，插入都很费时。","like_count":0},{"had_liked":false,"id":156215,"user_name":"文古","can_delete":false,"product_type":"c1","uid":1313934,"ip_address":"","ucode":"9A3991AA033EB4","user_header":"https://static001.geekbang.org/account/avatar/00/14/0c/8e/8a39ee55.jpg","comment_is_top":false,"comment_ctime":1574837438,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1574837438","product_id":100017301,"comment_content":"终于认识到自己对数据结构与算法的薄弱","like_count":0},{"had_liked":false,"id":155261,"user_name":"Sun Fei","can_delete":false,"product_type":"c1","uid":1032631,"ip_address":"","ucode":"092EC0992050BB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/b7/57f153f6.jpg","comment_is_top":false,"comment_ctime":1574672408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574672408","product_id":100017301,"comment_content":"打卡<br>","like_count":0},{"had_liked":false,"id":154936,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1574599921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574599921","product_id":100017301,"comment_content":"删除看不懂的同学可以看https:&#47;&#47;blog.csdn.net&#47;isea533&#47;article&#47;details&#47;80345507","like_count":0},{"had_liked":false,"id":154932,"user_name":"汤小高","can_delete":false,"product_type":"c1","uid":1555565,"ip_address":"","ucode":"D4AB7766273D52","user_header":"https://static001.geekbang.org/account/avatar/00/17/bc/6d/f6f0a442.jpg","comment_is_top":false,"comment_ctime":1574599704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574599704","product_id":100017301,"comment_content":"删除看不懂的建议看装修一共以花124607  本人已付116607","like_count":0},{"had_liked":false,"id":154033,"user_name":"常文龙","can_delete":false,"product_type":"c1","uid":1204525,"ip_address":"","ucode":"4A126159D24766","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/2d/5ca0a3da.jpg","comment_is_top":false,"comment_ctime":1574351082,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574351082","product_id":100017301,"comment_content":"用过bfs层次遍历可以求得树的高度","like_count":0},{"had_liked":false,"id":153171,"user_name":"W","can_delete":false,"product_type":"c1","uid":1010571,"ip_address":"","ucode":"62AE242DD703B7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6b/8b/ccdb819a.jpg","comment_is_top":false,"comment_ctime":1574173836,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574173836","product_id":100017301,"comment_content":"我的学习笔记 https:&#47;&#47;www.notion.so&#47;guoweidong&#47;24-07208445176042f8852a66a8c74d905a","like_count":0},{"had_liked":false,"id":153152,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1574169305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574169305","product_id":100017301,"comment_content":"<br>public void delete(int value) {<br>        ListTree p = tree;<br>        &#47;&#47;待删除节点的父节点 f<br>        ListTree f = null;<br>        while (p != null &amp;&amp; p.getVal() != value) {<br>            f = p;<br>            if (p.getVal() &lt; value) {<br>                p = p.right;<br>            } else {<br>                p = p.left;<br>            }<br>        }<br>        if (p == null) return;<br><br>        &#47;&#47;可能指向新的待删除节点的父节点<br>        ListTree father = f;<br>        &#47;&#47;待删除结点有左右子树，找右子树中的最小节点。需要结合接下来对于待删除结点均没有左右子树的代码<br>        if (p.right != null &amp;&amp; p.left != null) {<br>            ListTree r = p.right; &#47;&#47; 右子树的第一个结点<br>            while (r != null) {<br>                &#47;&#47; r 有左子结点，必须进入,且这种情况出现，后面就始终判断有没有左子节点即可<br>                &#47;&#47; 直到是叶子节点，替换值，更新 p 指向 r，father 指向 p 的父结点<br>                &#47;&#47; 更下面的一步再处理这个结点的删除,且这时候的情况属于第一或者第二种删除情况<br>                if (r.left != null) {<br>                    &#47;&#47;flag = true; &#47;&#47; 第一次如果有进入左子结点，flag就始终变成true<br>                    father = r;<br>                    r = r.left;<br>                } else { &#47;&#47; 只要 r 的左子结点为空，说明找到了右子树中的最小元素<br>                         &#47;&#47; 就进行值的替换，且把 p 指向新的待删除结点<br>                    int small = r.getVal();<br>                    p.setVal(small);<br>                    &#47;&#47;father = p;<br>                    p = r;<br>                    r = null;<br>                }<br>            }<br>        }<br>        &#47;*<br>          到这步，如果待删除节点有左右子节点，那待删除节点的值已经被其右子树中的最小值替代<br>          且这个最小值肯定没有左子树(如果有左子树那代表它不是最小值)<br>          p 指针指向待删除结点，如果进入的上方的判断条件，p 则指向了新的待删除节点<br>          同理，father 指针将更新成 p 的父结点<br>          接下来的对于 p 指针指向结点的删除情况只剩 1.只有左右其中一个子节点 2.没有子结点 两种情况<br>          这时候，把 father 指针指向 待删除结点的 子节点 或者 null<br>         *&#47;<br><br>        &#47;&#47;找待删除节点的孩子结点<br>        ListTree child;<br>        if (p.left != null) {<br>            child = p.left;<br>        } else if (p.right != null) {<br>            child = p.right;<br>        } else child = null;<br><br>        &#47;&#47;更新father结点指向孩子结点，即删除 待删除结点<br>        if (father == null) {<br>            tree = child;<br>        } else if (father.right == p) {<br>            father.right = child;<br>        } else father.left = child;<br><br>    }","like_count":0},{"had_liked":false,"id":152193,"user_name":"mawei","can_delete":false,"product_type":"c1","uid":1712470,"ip_address":"","ucode":"07DACA0F8BA65D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/21/56/91669d26.jpg","comment_is_top":false,"comment_ctime":1573909355,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1573909355","product_id":100017301,"comment_content":"二叉查找树的删除操作中的代码感觉有点问题：<br>第22行，如果把minP 节点赋值给 p 则会改变原来p的左右指针结构，即18不会再指向 17和25了","like_count":0,"discussions":[{"author":{"id":1712470,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/21/56/91669d26.jpg","nickname":"mawei","note":"","ucode":"07DACA0F8BA65D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51651,"discussion_content":"感觉再重新定义这个节点，表示要删除节点，就不会有问题了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573912898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151293,"user_name":"Mew151","can_delete":false,"product_type":"c1","uid":1002201,"ip_address":"","ucode":"D4793F5874F345","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/d9/75dd7cf9.jpg","comment_is_top":false,"comment_ctime":1573696759,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573696759","product_id":100017301,"comment_content":"想知道如何能直观的把一棵树打印到控制台上","like_count":0},{"had_liked":false,"id":149795,"user_name":"Geek_ff334e","can_delete":false,"product_type":"c1","uid":1657421,"ip_address":"","ucode":"F35A9BC2B7F6B8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJEGRf488zB6kRDic691OicZcr5tbice0wP4xMevdtYEcBJoS5wzG2cUXhicsXLvX8fmLfgvgVibofJM2w/132","comment_is_top":false,"comment_ctime":1573379472,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573379472","product_id":100017301,"comment_content":"没明白为什么p=minP前还要讲p.data = minP.data","like_count":0},{"had_liked":false,"id":142909,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1571581573,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571581573","product_id":100017301,"comment_content":"使用层级遍历的方法即可知道树的确切高度","like_count":0},{"had_liked":false,"id":141518,"user_name":"刘楠","can_delete":false,"product_type":"c1","uid":1120773,"ip_address":"","ucode":"9F19D44CBEE039","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/05/f154d134.jpg","comment_is_top":false,"comment_ctime":1571187446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571187446","product_id":100017301,"comment_content":"   p.data = minP.data; &#47;&#47; 将 minP 的数据替换到 p 中<br>          p = minP; &#47;&#47; 下面就变成了删除 minP 了<br>          pp = minPP;这3行没看明白，有知道的吗","like_count":0},{"had_liked":false,"id":136873,"user_name":"L.","can_delete":false,"product_type":"c1","uid":1543396,"ip_address":"","ucode":"9803C2EDC799DC","user_header":"https://static001.geekbang.org/account/avatar/00/17/8c/e4/ad3e7c39.jpg","comment_is_top":false,"comment_ctime":1569546275,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1569546275","product_id":100017301,"comment_content":"如果删除的节点有左右孩子节点，那么一定是找右子树最小，找左子树最大可以伐？","like_count":0},{"had_liked":false,"id":135008,"user_name":"Magic","can_delete":false,"product_type":"c1","uid":1272047,"ip_address":"","ucode":"FD9CEDAA419EB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/68/ef/6264ca3d.jpg","comment_is_top":false,"comment_ctime":1568974498,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568974498","product_id":100017301,"comment_content":"课后习题：递归方法求解","like_count":0},{"had_liked":false,"id":133663,"user_name":"秋","can_delete":false,"product_type":"c1","uid":1664774,"ip_address":"","ucode":"776A98C92BD57A","user_header":"https://static001.geekbang.org/account/avatar/00/19/67/06/8cd746bc.jpg","comment_is_top":false,"comment_ctime":1568630457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568630457","product_id":100017301,"comment_content":"def depth(root):<br>        if root == None:<br>            return 0<br>        else:<br>            return max(depth(root.left), depth(root.right)) + 1","like_count":0},{"had_liked":false,"id":133247,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1568463541,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568463541","product_id":100017301,"comment_content":"哈希表+链表，可以克服快速输出有序队列的问题，不过装载因子这个卡，存储空间上哈希表确实比不过，且哈希表还需要连续的存储空间吧；着也是链表优于队列的地方吧，关键是应对动态的情况，如果静态，数组应该厉害一点","like_count":0},{"had_liked":false,"id":133167,"user_name":"谜底","can_delete":false,"product_type":"c1","uid":1617609,"ip_address":"","ucode":"39A4A21B7C4CA0","user_header":"https://static001.geekbang.org/account/avatar/00/18/ae/c9/daf70d22.jpg","comment_is_top":false,"comment_ctime":1568425696,"is_pvip":false,"replies":[{"id":"51226","content":"是的，要一直查到最后。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1568589037,"ip_address":"","comment_id":133167,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1568425696","product_id":100017301,"comment_content":"“要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。”这个在查找的时候，如何知道我要查找的值是否还有相同的节点呢？比如根节点就是我要找的节点的话，我不知道他还有没有相同的节点，在这种方法下，我还得把右子树的都查找一遍。<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467277,"discussion_content":"是的，要一直查到最后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568589037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130822,"user_name":"对方正在输入。。。","can_delete":false,"product_type":"c1","uid":1179298,"ip_address":"","ucode":"7B0DEB4D9B43D2","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/a2/5252a278.jpg","comment_is_top":false,"comment_ctime":1567557004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567557004","product_id":100017301,"comment_content":"二叉搜索树进行删除操作时，按道理找左子树中最大值应该也可以的吧","like_count":0},{"had_liked":false,"id":129337,"user_name":"小k","can_delete":false,"product_type":"c1","uid":1304236,"ip_address":"","ucode":"AE0C5ADEB489F5","user_header":"https://static001.geekbang.org/account/avatar/00/13/e6/ac/5b99aa18.jpg","comment_is_top":false,"comment_ctime":1567090740,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567090740","product_id":100017301,"comment_content":"老师，删除操作对于有左右子节点的节点，为何不能找该节点的左子树里最大的节点替换该节点呢？这样做也可以的吧？","like_count":0},{"had_liked":false,"id":124948,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1566024742,"is_pvip":false,"replies":[{"id":"46787","content":"不是啊 为啥是多余的呢","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1566422671,"ip_address":"","comment_id":124948,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1566024742","product_id":100017301,"comment_content":"根节点那个删除那句是不是多余了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463372,"discussion_content":"不是啊 为啥是多余的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566422671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1486168,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ad/58/7d6a0b8e.jpg","nickname":"Deep","note":"","ucode":"EF3281F0A5824A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284180,"discussion_content":"我开始也感觉是多余的。\n后面想通了，其实是考虑到如果这个树只有一个根节点 或者 只有两个节点的情况。 可以找两个这样的例子带进去看一下。那行代码是走到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592464404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124025,"user_name":"Harvey","can_delete":false,"product_type":"c1","uid":1254112,"ip_address":"","ucode":"164D1178DA091A","user_header":"https://static001.geekbang.org/account/avatar/00/13/22/e0/6295a753.jpg","comment_is_top":false,"comment_ctime":1565793468,"is_pvip":true,"replies":[{"id":"45698","content":"你看看代码，自己debug一下就清楚了啊","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1565909679,"ip_address":"","comment_id":124025,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565793468","product_id":100017301,"comment_content":"删除节点的时候，如果被删除节点有左右子节点，此时如果右子节点没有左子节点，或者左子节点没有右子节点，如何交换？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":462966,"discussion_content":"你看看代码，自己debug一下就清楚了啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565909679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":123819,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1565766976,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565766976","product_id":100017301,"comment_content":"完全二叉树的节点数统计 正好leetcode上有这道题","like_count":0},{"had_liked":false,"id":121112,"user_name":"Geek_86533a","can_delete":false,"product_type":"c1","uid":1610333,"ip_address":"","ucode":"6961C429E8953A","user_header":"","comment_is_top":false,"comment_ctime":1565060213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565060213","product_id":100017301,"comment_content":"思路一：利用后序遍历，使用递归求解，current_height = max(left, right)+1<br>思路二：利用层次遍历，记录层数：<br>class Solution:<br>    def maxDepth(self, root: TreeNode) -&gt; int:<br>        if not root:<br>            return 0<br>        <br>        stack=[root]<br>        level = 0<br>        <br>        while stack:<br>            length = len(stack)<br>            <br>            for i in range(length):<br>                p = stack[0]<br>                stack.remove(stack[0])<br>                <br>                if p.left:<br>                    stack.append(p.left)<br>                if p.right:<br>                    stack.append(p.right)<br>            level+=1<br>        return level","like_count":0},{"had_liked":false,"id":119729,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1564666378,"is_pvip":false,"replies":[{"id":"44227","content":"你理解的没错，后面那句应该去掉！","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1564960463,"ip_address":"","comment_id":119729,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564666378","product_id":100017301,"comment_content":"解答开篇那几个原因的最后一点，散列表正是因为装载因子不能太大，所以才导致内存浪费吧，而不是“不然”，老师，是我理解错了吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461042,"discussion_content":"你理解的没错，后面那句应该去掉！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564960463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115184,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1563504324,"is_pvip":false,"replies":[{"id":"42202","content":"大小有关。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1563575318,"ip_address":"","comment_id":115184,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563504324","product_id":100017301,"comment_content":"老是，所谓前驱节点和后继节点应该是跟二叉树的前、中、后序遍历方式有关系吧","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":459003,"discussion_content":"大小有关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563575318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":109226,"user_name":"Better","can_delete":false,"product_type":"c1","uid":1515024,"ip_address":"","ucode":"4170A84A7EB378","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL7J5Yb5nofkD1Wp7gEtoEhNCuv70DUDcu26XtOK0UrFyuQltje0P1icTLMOW2unCa5u6nCdWQNrlg/132","comment_is_top":false,"comment_ctime":1561984066,"is_pvip":false,"replies":[{"id":"39583","content":"二叉查找树有红黑树、avl树...这些树的应用场景很多，你可以看后面的文章，就知道了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1562024404,"ip_address":"","comment_id":109226,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561984066","product_id":100017301,"comment_content":"老师，二叉排序树的应用场景有哪些？？？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456309,"discussion_content":"二叉查找树有红黑树、avl树...这些树的应用场景很多，你可以看后面的文章，就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562024404,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103970,"user_name":"咸鱼与果汁","can_delete":false,"product_type":"c1","uid":1283861,"ip_address":"","ucode":"F79383599ACB02","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoRyUPicEMqGsbsMicHPuvwM8nibfgK8Yt0AibAGUmnic7rLF4zUZ4dBj4ialYz54fOD6sURKwuJIWBNjhg/132","comment_is_top":false,"comment_ctime":1560577437,"is_pvip":false,"replies":[{"id":"37642","content":"你说的没错，你可以看下我之前写的这篇文章：<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;Md8tprLiESR6oQKXs_Aihw","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560640826,"ip_address":"","comment_id":103970,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560577437","product_id":100017301,"comment_content":"老师你好，我有个疑惑，二叉树的插入删除时间复杂度起始是包含了查找的， 按这个逻辑链表对应的时间复杂度应该是log(n)，而不是log(1)？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454074,"discussion_content":"你说的没错，你可以看下我之前写的这篇文章：\nhttps://mp.weixin.qq.com/s/Md8tprLiESR6oQKXs_Aihw","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560640826,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103682,"user_name":"G.S.K","can_delete":false,"product_type":"c1","uid":1222966,"ip_address":"","ucode":"88217F9289EB48","user_header":"https://static001.geekbang.org/account/avatar/00/12/a9/36/d054c979.jpg","comment_is_top":false,"comment_ctime":1560489445,"is_pvip":false,"replies":[{"id":"37647","content":"貌似不好实现快速的范围查找。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1560641939,"ip_address":"","comment_id":103682,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1560489445","product_id":100017301,"comment_content":"请教老师，二叉查找树怎么进行范围查找呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":453962,"discussion_content":"貌似不好实现快速的范围查找。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560641939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":92119,"user_name":"qisucha","can_delete":false,"product_type":"c1","uid":1238803,"ip_address":"","ucode":"6F27247179C18D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKINKlibnXtBgJzDDfUSPvQX3ibGU8cUNaOgc409lia3JPLmdk0Q7bQCKbUiaibLrvfRpOr8AwF8MSIJCg/132","comment_is_top":false,"comment_ctime":1557190542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557190542","product_id":100017301,"comment_content":"有个问题删除操作中，如果替换的19改成13的话，13能替换18吗？如果替换了那昨子树岂不是比根大了？","like_count":0},{"had_liked":false,"id":91174,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1556889123,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1556889123","product_id":100017301,"comment_content":"  &#47;**<br>   * get the height of a binary tree<br>   * @param n<br>   * @return<br>   *&#47;<br>  public static int height(Node n) {<br>    if (n == null) {<br>      return -1;<br>    }<br>    return Math.max(height(n.left), height(n.right)) + 1;<br>  }<br>","like_count":0},{"had_liked":false,"id":90531,"user_name":"小邓","can_delete":false,"product_type":"c1","uid":1474505,"ip_address":"","ucode":"1E903D5622D39F","user_header":"https://static001.geekbang.org/account/avatar/00/16/7f/c9/40c609ee.jpg","comment_is_top":false,"comment_ctime":1556548654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556548654","product_id":100017301,"comment_content":"按照@失火的夏天 的思路，我写了按层次遍历计算层数的C#代码，感谢这位同学！<br>代码地址：https:&#47;&#47;github.com&#47;CaigerDeng&#47;-DataStructure-BeautyOfAlgorithm-Homework&#47;blob&#47;master&#47;Main&#47;Main&#47;Chapter23.cs（搜索PrintLevel(Node node) 即可）","like_count":0},{"had_liked":false,"id":90485,"user_name":"gico","can_delete":false,"product_type":"c1","uid":1167345,"ip_address":"","ucode":"AE40E8717A4F60","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/f1/057899c7.jpg","comment_is_top":false,"comment_ctime":1556533808,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1556533808","product_id":100017301,"comment_content":"关于代码中怎样添加重复节点的删除：<br>找到下面这段代码<br>····<br> while (minRightNode.leftChild != null) {<br>                minParentRightNode = minRightNode;<br>                minRightNode = minRightNode.leftChild;<br>  }<br>···<br>修改为<br>···<br> &#47;&#47; 查找右子树中最小节点<br>            while (minRightNode.leftChild != null) {<br>                &#47;&#47;重复的节点处理<br>                if (minRightNode.leftChild.value == node.value) {<br>                    minRightNode.leftChild = minRightNode.leftChild.rightChlid;<br>                    continue;<br>                }<br>                minParentRightNode = minRightNode;<br>                minRightNode = minRightNode.leftChild;<br>  }<br>···<br><br>另外老师代码二叉查找树支持插入重复数字的代码 请见鄙人的github：<br>https:&#47;&#47;github.com&#47;StriverBlog&#47;data-structure-java&#47;blob&#47;master&#47;base&#47;src&#47;structure&#47;tree&#47;BinarySearchTree.java","like_count":0,"discussions":[{"author":{"id":1169063,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","nickname":"better","note":"","ucode":"AF1DB566EBB8A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163965,"discussion_content":"感谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581131621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169063,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","nickname":"better","note":"","ucode":"AF1DB566EBB8A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163956,"discussion_content":"赞一个。解决了问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581131059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90328,"user_name":"小哥","can_delete":false,"product_type":"c1","uid":1273603,"ip_address":"","ucode":"17539138CB054C","user_header":"https://static001.geekbang.org/account/avatar/00/13/6f/03/c17130c5.jpg","comment_is_top":false,"comment_ctime":1556496496,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556496496","product_id":100017301,"comment_content":"那三行删除代码，结合后面才能看懂。后面统一删除根结点或者叶节点。那三行代码就是让p，pp都指向要minpp叶节点，后续代码会把它删了","like_count":0},{"had_liked":false,"id":90166,"user_name":"Renext","can_delete":false,"product_type":"c1","uid":1020838,"ip_address":"","ucode":"3C4418F7E86CD6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","comment_is_top":false,"comment_ctime":1556437876,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556437876","product_id":100017301,"comment_content":"二叉树：每个节点最多包含左右两个子节点。<br>完全二叉树：除去最后一层节点，是一个满二叉树，并且，最后一层节点都是靠左连续排列的，无中断节点。<br>满二叉树：特殊的完全二叉树","like_count":0},{"had_liked":false,"id":88547,"user_name":"寐宕","can_delete":false,"product_type":"c1","uid":1025273,"ip_address":"","ucode":"69C43B1C9BE330","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKOZf3YABdvdOLqmian8spReO86uZCTUbzWdHUOzV3Kmm8dmxl1ibg6niaDN70JbxaCOTD5Hu3j28a3w/132","comment_is_top":false,"comment_ctime":1555940170,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555940170","product_id":100017301,"comment_content":"那三行代码，似乎理解了，p只是个引用。<br>p.data = minP.data; &#47;&#47; 这一步已经完成了p的删除，删除了要删除的，并把替换的换上保持结构<br>p = minP;  &#47;&#47;p之前指向的节点该怎样还怎样，此处只是指向了新的节点<br>pp = minPP;&#47;&#47; 后两行相当于把刚才转移了的节点删除掉，但是算是套上了删除p的马甲，因为此时删除这个minP就是 删除节点是叶子节点或者仅有一个子节点的问题","like_count":0},{"had_liked":false,"id":88363,"user_name":"马源","can_delete":false,"product_type":"c1","uid":1183937,"ip_address":"","ucode":"9B12311D6BA5A7","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/c1/18b41ced.jpg","comment_is_top":false,"comment_ctime":1555911468,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555911468","product_id":100017301,"comment_content":"对于重复数据的处理:<br>1. 节点存储链表<br>2. 右子树存储大于等于父节点的值","like_count":0},{"had_liked":false,"id":87091,"user_name":"ly","can_delete":false,"product_type":"c1","uid":1365025,"ip_address":"","ucode":"6A1B6FEE6A9676","user_header":"https://static001.geekbang.org/account/avatar/00/14/d4/21/b8c36a35.jpg","comment_is_top":false,"comment_ctime":1555510083,"is_pvip":false,"replies":[{"id":"31494","content":"普通的树，掌握前中后序遍历就可以了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1555639877,"ip_address":"","comment_id":87091,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1555510083","product_id":100017301,"comment_content":"问一下老师，普通的树 有什么要学习的点吗？比如全国行政区划的树，<br>查找<br>插入<br>删除","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":447307,"discussion_content":"普通的树，掌握前中后序遍历就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555639877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82330,"user_name":"ok绷","can_delete":false,"product_type":"c1","uid":1441991,"ip_address":"","ucode":"7B2303B3319C4D","user_header":"https://static001.geekbang.org/account/avatar/00/16/00/c7/59caefa7.jpg","comment_is_top":false,"comment_ctime":1554186301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554186301","product_id":100017301,"comment_content":"p.data = minP.data; &#47;&#47; 将 minP 的数据替换到 p 中<br>p = minP; &#47;&#47; 下面就变成了删除 minP 了<br>pp = minPP;<br><br>这段看了好久，都没看明白什么删除的minP , 原来是要结合下面的代码一起看的<br>","like_count":0},{"had_liked":false,"id":81721,"user_name":"track","can_delete":false,"product_type":"c1","uid":1018464,"ip_address":"","ucode":"1D5307F197A877","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/60/50f88b0a.jpg","comment_is_top":false,"comment_ctime":1554018382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554018382","product_id":100017301,"comment_content":"Java实现的二叉树的标记删除，可以使用一个固定对象表示已删除对象，将需要删除的对象释放回收","like_count":0},{"had_liked":false,"id":80332,"user_name":"海军上校","can_delete":false,"product_type":"c1","uid":1104290,"ip_address":"","ucode":"7B0D9EC01A3F36","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/a2/afbc447c.jpg","comment_is_top":false,"comment_ctime":1553649748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553649748","product_id":100017301,"comment_content":"mark","like_count":0},{"had_liked":false,"id":79090,"user_name":"康斯坦丁","can_delete":false,"product_type":"c1","uid":1368096,"ip_address":"","ucode":"C130E800E8D5C9","user_header":"https://static001.geekbang.org/account/avatar/00/14/e0/20/003190c1.jpg","comment_is_top":false,"comment_ctime":1553349505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553349505","product_id":100017301,"comment_content":"int tierCount = 0;<br>List&lt;Node&gt; nodes = new ArrayList&lt;&gt;();<br>nodes.add(root);<br>while(true){<br>\tList&lt;Node&gt; nextTierNodes =  new ArrayList&lt;&gt;();<br>\ttierCount++;<br>\tfor(Node node :nodes){<br>\t\tif(node.left !=null ) nextTierNodes.add(node.left);<br>\t\tif(node.right !=null ) nextTierNodes.add(node.right);<br>\t}<br>\tnodes = nextTierNodes;<br>\tif(nextTierNodes.size() &lt;= 0){<br>\t\tbreak;<br>\t}<br>}<br>return tierCount","like_count":0},{"had_liked":false,"id":78512,"user_name":"第一印象","can_delete":false,"product_type":"c1","uid":1460200,"ip_address":"","ucode":"952AF3AFEC9CA3","user_header":"https://static001.geekbang.org/account/avatar/00/16/47/e8/e117c43d.jpg","comment_is_top":false,"comment_ctime":1553163731,"is_pvip":false,"replies":[{"id":"28615","content":"为啥呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1553217807,"ip_address":"","comment_id":78512,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553163731","product_id":100017301,"comment_content":"删除操作中，如果19下面有个23，23下面有个20和24，这么写是不是就不合适了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444126,"discussion_content":"为啥呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553217807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":72623,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1551680651,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551680651","product_id":100017301,"comment_content":"mysql用的是b+树索引，跟文章中的有点不同，所有叶子节点包含所有元素信息，而且b+树的只有叶子节点才有卫星数据，其他的都不包含，只报存对应位置索引，并且区间访问的效率比b树高，而且查询稳定数要比b树稳定，因为每次查询都要查到叶子节点，而b树查询可能最优查询根节点，最坏查询是叶子节点，所以b+树的查询稳定性比b树好，还有一个东西就是b+树比较怪，它可能一个节点会存储两个以上的元素，所以b+树的层数比b树更加矮胖。。。","like_count":0},{"had_liked":false,"id":72286,"user_name":"xfan","can_delete":false,"product_type":"c1","uid":1315147,"ip_address":"","ucode":"48ED8D498D7F56","user_header":"https://static001.geekbang.org/account/avatar/00/14/11/4b/fa64f061.jpg","comment_is_top":false,"comment_ctime":1551575413,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551575413","product_id":100017301,"comment_content":"对于二叉树多个相同元素的插入和删除方法，我有一个简单的，就是定义一个属性size表示相同元素的个数，如果查找到要插入的元素在树中，就将size加一，反之删除就减一，不知道这个方法能都可以","like_count":0},{"had_liked":false,"id":71783,"user_name":"JJj","can_delete":false,"product_type":"c1","uid":1196463,"ip_address":"","ucode":"EA53F2CEAFCFF1","user_header":"https://static001.geekbang.org/account/avatar/00/12/41/af/4307867a.jpg","comment_is_top":false,"comment_ctime":1551431496,"is_pvip":false,"replies":[{"id":"26271","content":"你可以自己debug一下：）","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1551666288,"ip_address":"","comment_id":71783,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1551431496","product_id":100017301,"comment_content":"请问下，删除的时，如要删的节点存在两个子节点的时候，其父节点pp.right=null是不是遗漏了？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":441327,"discussion_content":"你可以自己debug一下：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1551666288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":70909,"user_name":"华杉","can_delete":false,"product_type":"c1","uid":1085340,"ip_address":"","ucode":"F9CE26923F4B9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/8f/9c/ef58929f.jpg","comment_is_top":false,"comment_ctime":1551227514,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551227514","product_id":100017301,"comment_content":"最关键的还是有序性，如果要用大于，小于，like查找，散列表就搞不定了，所以MySql的默认索引是B+树","like_count":0},{"had_liked":false,"id":70206,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1551051668,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551051668","product_id":100017301,"comment_content":"我在做leetcode题目就是max比较左右节点高度+1","like_count":0},{"had_liked":false,"id":68952,"user_name":"1024","can_delete":false,"product_type":"c1","uid":1086407,"ip_address":"","ucode":"DCC31F6EC54F43","user_header":"https://static001.geekbang.org/account/avatar/00/10/93/c7/86352ccc.jpg","comment_is_top":false,"comment_ctime":1550632905,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550632905","product_id":100017301,"comment_content":"新插入的节点都是在叶子节点，二叉查找树的插入可以这么写吗？<br>public void insert(int data) {<br>        Node node = tree;<br>        while (node != null) {<br>            if (node.data &lt; data) {<br>                node = node.right;<br>            } else {<br>                node = node.left;<br>            }<br>        }<br>        node = new Node(data);<br>    }","like_count":0},{"had_liked":false,"id":63546,"user_name":"泉","can_delete":false,"product_type":"c1","uid":1099760,"ip_address":"","ucode":"914709BE802A8D","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/f0/aa2e0749.jpg","comment_is_top":false,"comment_ctime":1548397678,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1548397678","product_id":100017301,"comment_content":"平衡二叉查找树，O( logn)","like_count":0},{"had_liked":false,"id":61958,"user_name":"睡痴儿😑","can_delete":false,"product_type":"c1","uid":1187204,"ip_address":"","ucode":"750EF858EF2042","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/84/d0ec0064.jpg","comment_is_top":false,"comment_ctime":1547866819,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547866819","product_id":100017301,"comment_content":"使用递归的方式，计算左子树和右子树的最大高度。取其中较大的那个。","like_count":0},{"had_liked":false,"id":61910,"user_name":"兔斯基","can_delete":false,"product_type":"c1","uid":1061320,"ip_address":"","ucode":"146A5FE2D8B301","user_header":"https://static001.geekbang.org/account/avatar/00/10/31/c8/a64e4aef.jpg","comment_is_top":false,"comment_ctime":1547854579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547854579","product_id":100017301,"comment_content":"二叉查找树区间找数据速度要快的多的吧？而hash没办法实现区间查找，只能遍历","like_count":0},{"had_liked":false,"id":61249,"user_name":"Diane__Yan","can_delete":false,"product_type":"c1","uid":1356664,"ip_address":"","ucode":"B071258BC7AE87","user_header":"https://static001.geekbang.org/account/avatar/00/14/b3/78/a335089a.jpg","comment_is_top":false,"comment_ctime":1547645926,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547645926","product_id":100017301,"comment_content":"Smallfly说的问题，应该不可以吧，左树里面的值都比根节点小呀","like_count":0},{"had_liked":false,"id":61244,"user_name":"AnT—路","can_delete":false,"product_type":"c1","uid":1274018,"ip_address":"","ucode":"1F09BB7BED0539","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/a2/e7921fa8.jpg","comment_is_top":false,"comment_ctime":1547645438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547645438","product_id":100017301,"comment_content":"根据二叉查找树的定义“对任意一个节点（A），其右子树（A_R）的全部节点的值都要大于该节点的值，其左子树（A_L）的全部节点的值都要小于该节点的值”，建立该搜索二叉树的大致思路是怎样的呢？<br>因为无论是A_R还是A_L，其后面还有多层的节点，后面的节点同时要满足A层的条件，想不明白怎么建立起这个搜索二叉树了。。。","like_count":0},{"had_liked":false,"id":60391,"user_name":"超人卟会飛丷","can_delete":false,"product_type":"c1","uid":1262245,"ip_address":"","ucode":"029853FC94E135","user_header":"https://static001.geekbang.org/account/avatar/00/13/42/a5/741cefb1.jpg","comment_is_top":false,"comment_ctime":1547468119,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547468119","product_id":100017301,"comment_content":"老师在删除 18节点的时候  如果把25变为当前节点，把当前节点的左子节点17更新为19的左子节点  这样可以吗？","like_count":0},{"had_liked":false,"id":58544,"user_name":"Lisa Li","can_delete":false,"product_type":"c1","uid":1046663,"ip_address":"","ucode":"4F7CF929FF4C6B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/87/0491e9e5.jpg","comment_is_top":false,"comment_ctime":1547110451,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547110451","product_id":100017301,"comment_content":"支持重复数据的二叉查找树-文中提到把相同的节点往右子树查，可以往左子树上查吗？查找的时候找到了第一个不停，继续往左，一直找到叶子节点为止？","like_count":0},{"had_liked":false,"id":58448,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1547084676,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547084676","product_id":100017301,"comment_content":"知道了data再去查找是为了判断在不在树上？或者是有其他使用场景啊，请老师举个例子","like_count":0},{"had_liked":false,"id":57314,"user_name":"Jack_Cui","can_delete":false,"product_type":"c1","uid":1246643,"ip_address":"","ucode":"A2C44AB026245A","user_header":"https://static001.geekbang.org/account/avatar/00/13/05/b3/a8a835cf.jpg","comment_is_top":false,"comment_ctime":1546744676,"is_pvip":false,"replies":[{"id":"20711","content":"树是图的一种特殊情况 dfs应该是一样的 而且更简单些","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546825468,"ip_address":"","comment_id":57314,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546744676","product_id":100017301,"comment_content":"老师，您有考虑讲树的dfs吗。。。我看到您写了图的。。。虽然可能都是一样的。。。但是LeetCode上的树的dfs+递归我一做就懵。。。。。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435521,"discussion_content":"树是图的一种特殊情况 dfs应该是一样的 而且更简单些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546825468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56783,"user_name":"Dale","can_delete":false,"product_type":"c1","uid":1010056,"ip_address":"","ucode":"DD4717C06E417D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/69/88/528442b0.jpg","comment_is_top":false,"comment_ctime":1546561302,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1546561302","product_id":100017301,"comment_content":"能想到的是用递归方法，分别递归计算左子树和右子树的高度，然后取儿二者中最大值加1。层次遍历方法没有想到，学习一下。","like_count":0},{"had_liked":false,"id":55940,"user_name":"尘封","can_delete":false,"product_type":"c1","uid":1247006,"ip_address":"","ucode":"CEE0C006387A03","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/1e/bdbe93f4.jpg","comment_is_top":false,"comment_ctime":1546352137,"is_pvip":false,"replies":[{"id":"20175","content":"后面高级篇会讲的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1546393774,"ip_address":"","comment_id":55940,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546352137","product_id":100017301,"comment_content":"老师，高度为1的B+树是什么样子的？假设一个表中有10条数据，那是不是这颗树只有一层？是如何存储的？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":434893,"discussion_content":"后面高级篇会讲的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1546393774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":54970,"user_name":"charles","can_delete":false,"product_type":"c1","uid":1270127,"ip_address":"","ucode":"936B89B442DB7B","user_header":"https://static001.geekbang.org/account/avatar/00/13/61/6f/f072c3d1.jpg","comment_is_top":false,"comment_ctime":1545990097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545990097","product_id":100017301,"comment_content":"儿叉查找树删除第三种情况，可以把删除节点的右子节点替换为删除节点，然后把左子节点放到右子节点的最小节点的左节点，这样可以吗。","like_count":0},{"had_liked":false,"id":54936,"user_name":"水户洋平","can_delete":false,"product_type":"c1","uid":1009140,"ip_address":"","ucode":"806545270EB6C0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/65/f4/bb81f857.jpg","comment_is_top":false,"comment_ctime":1545985227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545985227","product_id":100017301,"comment_content":"这一节容易混淆的地方还真需要对指针有一定的了解 不然真看不到了","like_count":0},{"had_liked":false,"id":52609,"user_name":"dead_lock","can_delete":false,"product_type":"c1","uid":1135475,"ip_address":"","ucode":"BE4398D8DF32C6","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/73/b0e54c79.jpg","comment_is_top":false,"comment_ctime":1545452169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545452169","product_id":100017301,"comment_content":"老师您好，删除节点有左右子节点的代码，下面这段，我理解的是在做删除节点操作，但是前面说，找到要删除节点右子树的最小值，一定没有左子节点，为什么下面这段代码里还有p.left！=null的处理，希望老师有时间解答一下谢谢老师<br><br>&#47;&#47; 删除节点是叶子节点或者仅有一个子节点<br>  Node child; &#47;&#47; p 的子节点<br>  if (p.left != null) child = p.left;<br>  else if (p.right != null) child = p.right;<br>  else child = null;<br> <br>  if (pp == null) tree = child; &#47;&#47; 删除的是根节点<br>  else if (pp.left == p) pp.left = child;<br>  else pp.right = child;<br>}<br>","like_count":0},{"had_liked":false,"id":52069,"user_name":"匆匆","can_delete":false,"product_type":"c1","uid":1333414,"ip_address":"","ucode":"4DB39C6CD5743B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/H8NxrljQXliccaT5fjdXJQYS3ou3Z9ykAuKw6EgicicEA9L4jQLz3h85P0odgDSaK0cA9oTyUKibbiagdNvnHuuV5mQ/132","comment_is_top":false,"comment_ctime":1545305054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545305054","product_id":100017301,"comment_content":"二叉查找树：在树中的每一个节点，其左子树的每个节点值都小于这个节点，其右子树中的每个节点值都大于这个节点值。<br><br>查找：每次和节点比较，小则再从左子树找，大则从右子树找。<br>插入：同查找类似，直到左子树或者右子树为空则插入。<br>删除：分三种情况。1、如果要删除的节点没有子节点，则将指向该节点的指针置为null即可。2、如果要删除的节点只有一个子节点，只需要将指向要删除节点的指针指向其子节点即可。3、如果要删除的节点有两个子节点，那么需要找到其右子树上的最小节点来替换要删除的这个节点。<br><br>其实删除有个取巧的操作：即把要删除的节点标记为已删除。只是删的多了会比较占内存。<br><br>二叉查找树其他操作：快速查找最大最小节点、前驱结点、后继节点。中序遍历可快速输出有序序列，实践复杂度O(n)。<br><br>效率：极度不平衡的二叉查找树（退化成链表）层数为n，时间复杂度O(n)，完全二叉树复杂度O(logn)，因为层数小于等于logn。所以我们尽可能构建左右子树都比较平衡的二叉树。<br><br>所以散列的查找、删除、插入时间复杂度可以做到常量级O(1),为什么还要为二叉查找树？优势再哪里？","like_count":0},{"had_liked":false,"id":51812,"user_name":"cw","can_delete":false,"product_type":"c1","uid":1264296,"ip_address":"","ucode":"82A6B50462F9F9","user_header":"https://static001.geekbang.org/account/avatar/00/13/4a/a8/b7e36dd2.jpg","comment_is_top":false,"comment_ctime":1545266407,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545266407","product_id":100017301,"comment_content":"递归，二叉树高度=max（左子树高度，右子树高度）+1 <br>定义变量 广度优先搜索，每次深度+1","like_count":0},{"had_liked":false,"id":50339,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1544955413,"is_pvip":false,"replies":[{"id":"18161","content":"接近o（1） 如果大量冲突才会你说的情况 我们这里的比较不考虑大量冲突","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1545010268,"ip_address":"","comment_id":50339,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1544955413","product_id":100017301,"comment_content":"老师   散列表的删除与查找是O(1)？？   这个不是绝对吧<br><br>如果采用了链表法解决冲突，时间复杂度就不是O(1)了吧  应该是O(n)  ，如果使用开放寻址法也是O(n)  只要在无冲突的情况才是O(1)","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":432948,"discussion_content":"接近o（1） 如果大量冲突才会你说的情况 我们这里的比较不考虑大量冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1545010268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49352,"user_name":"色即是空","can_delete":false,"product_type":"c1","uid":1189638,"ip_address":"","ucode":"46B8975ED087B8","user_header":"https://static001.geekbang.org/account/avatar/00/12/27/06/7ab75a5b.jpg","comment_is_top":false,"comment_ctime":1544669753,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544669753","product_id":100017301,"comment_content":"二叉查找树可以快速输出有序数据序列<br>平衡二叉查找树性能稳定，而散列表有冲突，扩容等问题的困扰<br>哈希查找的O(1)有冲突的情况下可能比O(logn)慢<br>考虑问题的复杂度来看，散列表复杂不稳定，二叉树成熟固定<br>散列表浪费空间<br>所以各有优劣，所以得以并存（其实有的东西即便有升级版，原版也得以存在）<br><br><br>二叉查找树最大的特点就是，支持动态的插入、删除、查找操作；散列表也有这个特点<br>散列表和二叉树的应用有什么区别，跟别在那些地方实用，那些地方不行<br>二叉查找树，二叉搜索树，二叉排序树------左子树比节点都小，右子树比节点都大<br><br>查、改、删；删除时最复杂，特别是有两个节点的情况，采用了取右侧最小的方式（其实去左侧最大的也可以只是，面对的问他会更加复杂，综合考虑使用这种最简单的方式解决）<br><br>中序遍历二叉查找树，可以输出一个有序的数据序列，时间复杂度是O(n),非常高效<br><br>二叉排序树中有重复数据的处理方式，一个相同的放在同一个节点，一个是放到他的右子树中（为什么不放在左子树，觉得是左子树会导致不能形成完全二叉树），从而使得查找的方式变成查找到根结点，<br><br>思考题：简单的穷举","like_count":0},{"had_liked":false,"id":48683,"user_name":"蓝与白","can_delete":false,"product_type":"c1","uid":1241198,"ip_address":"","ucode":"FC335F2AFCAFE7","user_header":"https://static001.geekbang.org/account/avatar/00/12/f0/6e/ef6763ff.jpg","comment_is_top":false,"comment_ctime":1544515011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544515011","product_id":100017301,"comment_content":"老师请教个问题，在删除操作时，找出删除节点的右子树中的最小节点minP之后，将它替换删除节点。如果minP有右子树，之后不应该将minPP（指向minP的指针）指向minP的右子树吗，minP替换到新位置之后，它的右子树指针也要指向删除节点的右子树吧？是不是少了这两步操作","like_count":0},{"had_liked":false,"id":46977,"user_name":"秋天","can_delete":false,"product_type":"c1","uid":1057056,"ip_address":"","ucode":"A7E1D953EF7E17","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/20/1299e137.jpg","comment_is_top":false,"comment_ctime":1544014128,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1544014128","product_id":100017301,"comment_content":"使用深度优先遍历法 就可以得到树的高度吧","like_count":0},{"had_liked":false,"id":45702,"user_name":"qinggeouye","can_delete":false,"product_type":"c1","uid":1251536,"ip_address":"","ucode":"5B53EEDD7BEC9C","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/d0/49b06424.jpg","comment_is_top":false,"comment_ctime":1543755189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543755189","product_id":100017301,"comment_content":"交作业，使用本节例子 BinarySearchTree 类中的 Node ：<br>public int getTreeHeight(Node p){&#47;&#47; 最开始 p 指向根节点<br>    if(p == null) return -1;<br>    int leftTreeHeight = getTreeHeight(p.left);<br>    int rightTreeHeight = getTreeHeight(p.right);<br>    &#47;&#47; 返回子树的高度 + 1<br>    return (leftTreeHeight &gt; rightTreeHeight) ? leftTreeHeight : rightTreeHeight + 1;<br>    &#47;&#47; 或者返回写成<br>    return Math.max(leftTreeHeight, rightTreeHeight) + 1;<br>}","like_count":0},{"had_liked":false,"id":45156,"user_name":"Laughing_Lz","can_delete":false,"product_type":"c1","uid":1251342,"ip_address":"","ucode":"7A7445E96F2978","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg","comment_is_top":false,"comment_ctime":1543551534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543551534","product_id":100017301,"comment_content":"实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。  想到了gc的标记清除算法。这些引申知识让我能逐渐把知识串起来。之前看过好几次算法的书籍，都觉得太过独立，好像用不到的样子。老师想这些课非常好，结合实际应用，我觉得这才是课程的最大收货！","like_count":0},{"had_liked":false,"id":44981,"user_name":"Laughing_Lz","can_delete":false,"product_type":"c1","uid":1251342,"ip_address":"","ucode":"7A7445E96F2978","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/0e/39307052.jpg","comment_is_top":false,"comment_ctime":1543537525,"is_pvip":false,"replies":[{"id":"16024","content":"不存在插入中间的情况 因为没理由插入中间呢","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543542365,"ip_address":"","comment_id":44981,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543537525","product_id":100017301,"comment_content":"插入操作，都是插入在叶子结点吗？如果要插入的位置在中间某层，那整个树的结构不就要重新调整了吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430887,"discussion_content":"不存在插入中间的情况 因为没理由插入中间呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543542365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":44154,"user_name":"园园","can_delete":false,"product_type":"c1","uid":1257028,"ip_address":"","ucode":"2A34FD1FC31042","user_header":"https://static001.geekbang.org/account/avatar/00/13/2e/44/b6f5b1fd.jpg","comment_is_top":false,"comment_ctime":1543375613,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543375613","product_id":100017301,"comment_content":"老师，在实际情况中能不能把散列和二叉查找树结合起来。比如，用散列函数计算出Key的散列值，然后再使用散列值构造二叉查找树？","like_count":0},{"had_liked":false,"id":43840,"user_name":"蠢蠢欲动的腹肌","can_delete":false,"product_type":"c1","uid":1007326,"ip_address":"","ucode":"B10550BF463017","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/de/4e7ec66d.jpg","comment_is_top":false,"comment_ctime":1543308098,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1543308098","product_id":100017301,"comment_content":"老师，我有一点不太懂，二叉查找树删除节点有两个子节点的情况，在找到右子树中最小节点后，把值赋给要删除节点，然后minpp.left=null不就可以了吗，为什么p=minp，这样不就丢了要删除节点的左子节点了吗？<br><br>望老师指教","like_count":0},{"had_liked":false,"id":43244,"user_name":"pyhhou","can_delete":false,"product_type":"c1","uid":1256496,"ip_address":"","ucode":"31EF8D50CF91A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","comment_is_top":false,"comment_ctime":1543199242,"is_pvip":false,"replies":[{"id":"15599","content":"怎么说都无所谓 只是个定义而已 我觉得我讲的是比较正规的叫法了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1543285312,"ip_address":"","comment_id":43244,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1543199242","product_id":100017301,"comment_content":"这里不太理解的地方是，树的高度到底是什么呢？看前一篇章节上面说树的高度是根节点到叶子节点的最长路径或者说是边数，例如单单一个根节点的高度就是0。但是看到其他地方，例如leetcode上面把高度，或是深度看作是层，例如单单一个根节点的高度就是1。这样子的话是不是就和层弄混淆了？还请老师解答，谢谢","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430335,"discussion_content":"怎么说都无所谓 只是个定义而已 我觉得我讲的是比较正规的叫法了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543285312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":42008,"user_name":"H+","can_delete":false,"product_type":"c1","uid":1235602,"ip_address":"","ucode":"FBAAE3BD6A5769","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/92/8826f642.jpg","comment_is_top":false,"comment_ctime":1542891117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542891117","product_id":100017301,"comment_content":"老师，请问下为什么二叉查找树的一个节点的右子树的数值一定比这个节点的父节点的值小呢？概念里只规定了一个节点的左子树比他小右子树比他大啊？后面好多的解决思路都是基于了这个特性的。但是概念里完全没有这么定义，请问下是我理解得不对嘛？","like_count":0},{"had_liked":false,"id":41492,"user_name":"ZX","can_delete":false,"product_type":"c1","uid":1235583,"ip_address":"","ucode":"0D2622FE6D1774","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/7f/8069035d.jpg","comment_is_top":false,"comment_ctime":1542793840,"is_pvip":false,"replies":[{"id":"14970","content":"嗯嗯 没错","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542852235,"ip_address":"","comment_id":41492,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542793840","product_id":100017301,"comment_content":"老师，散列表中的每个元素，也可以用链表按顺序串起来，达成有序的目的。我觉得散列表最大的特点在于hash的巧妙运用，二叉平衡树性能稳定，代码直观，浪费的内存较少，这样理解对吗","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429820,"discussion_content":"嗯嗯 没错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542852235,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41491,"user_name":"ECHO","can_delete":false,"product_type":"c1","uid":1237109,"ip_address":"","ucode":"08CDD0AC92E20C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e0/75/1763638a.jpg","comment_is_top":false,"comment_ctime":1542793691,"is_pvip":false,"replies":[{"id":"14969","content":"java代码不需要手动free的","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542852033,"ip_address":"","comment_id":41491,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542793691","product_id":100017301,"comment_content":"请问 删除节点 不需要free么？还是为了代码的间接而忽略了free呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429819,"discussion_content":"java代码不需要手动free的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542852033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41374,"user_name":"产品助理","can_delete":false,"product_type":"c1","uid":1019821,"ip_address":"","ucode":"39A76D346A96E9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/ad/6e3e9e15.jpg","comment_is_top":false,"comment_ctime":1542770449,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542770449","product_id":100017301,"comment_content":"n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)<br><br>应该是 &lt; 吧？ 或者是：<br><br>n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)-1<br><br>?<br><br>老师好，看了您的回复，我的理解是这样的：<br>1、完全二叉树，最后一层它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L），则最后一层的可能是[1, 2^(L-1)) —— 左开右闭<br><br>2、到倒数第二层的时候节点有：1+2+4+8+...+2^(L-2)<br><br>3、最后一层的节点数是最少1个，最多2^(L-1）-1个<br><br>4、所以结果最多是： 1+2+4+8+...+2^(L-2)+2^(L-1)-1 <br><br>梳理的可能不对，辛苦老师了！<br><br>","like_count":0},{"had_liked":false,"id":41192,"user_name":"荒","can_delete":false,"product_type":"c1","uid":1234098,"ip_address":"","ucode":"2B750654AF38EA","user_header":"https://static001.geekbang.org/account/avatar/00/12/d4/b2/43cb498b.jpg","comment_is_top":false,"comment_ctime":1542758802,"is_pvip":false,"replies":[{"id":"14783","content":"删除的逻辑有什么问题呢 能说详细点吗","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542764809,"ip_address":"","comment_id":41192,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542758802","product_id":100017301,"comment_content":"感觉删除的逻辑有问题，应该分为三类：<br><br>1. 有右子树，找出右子树最小的节点替换删除节点<br>2. 没有右子树，但是有左子树，找出左子树里面最大的节点替换要删除节点<br>3. 没有左右子树，直接删除节点就可以了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429728,"discussion_content":"删除的逻辑有什么问题呢 能说详细点吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542764809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":41068,"user_name":"肖小强","can_delete":false,"product_type":"c1","uid":1245065,"ip_address":"","ucode":"A929A8D1DAD3C4","user_header":"https://static001.geekbang.org/account/avatar/00/12/ff/89/32e3f682.jpg","comment_is_top":false,"comment_ctime":1542720995,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542720995","product_id":100017301,"comment_content":"求高度是不是有点类似于求二叉树的最小值呢，只要在求最小值时，遇到p=p-&gt;left或者是p=p-&gt;right，就令height++，然后height就是对应高度","like_count":0},{"had_liked":false,"id":40625,"user_name":"Random.nextName()","can_delete":false,"product_type":"c1","uid":1244960,"ip_address":"","ucode":"8D18D91B8D3BC7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ0lHhbutibIdWRv0pm2EPtvxqcVz0PblEic7GDxHK8JUSkyuWQl1B1NVQTzEowQIxfOf3saRBOTtog/132","comment_is_top":false,"comment_ctime":1542637274,"is_pvip":false,"replies":[{"id":"14658","content":"我觉得可以","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542678268,"ip_address":"","comment_id":40625,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542637274","product_id":100017301,"comment_content":"感觉二叉树和跳表很像啊，都是动态数据结构，都可以用链表作为底层，查找、插入、删除的时间复杂度都是O(logn)（平衡二叉树），那跳表是不是可以替代（平衡）二叉树呢？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429575,"discussion_content":"我觉得可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542678268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":40109,"user_name":"舍得","can_delete":false,"product_type":"c1","uid":1147685,"ip_address":"","ucode":"2146A08D2D79B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/25/10dac87c.jpg","comment_is_top":false,"comment_ctime":1542505090,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542505090","product_id":100017301,"comment_content":"我怎么觉得删除具有两个子节点的代码有问题，最后两行不应该是minPP.left=null吗？按照你写的我觉得p.data=minP.data是多余的而且被删除节点的子节点丢失，上移的节点又没有置null","like_count":0},{"had_liked":false,"id":39949,"user_name":"nothing","can_delete":false,"product_type":"c1","uid":1250912,"ip_address":"","ucode":"49058C9095281D","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/60/d6024ae8.jpg","comment_is_top":false,"comment_ctime":1542418482,"is_pvip":false,"replies":[{"id":"14687","content":"你可以参考下二叉树的遍历","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542680135,"ip_address":"","comment_id":39949,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542418482","product_id":100017301,"comment_content":"老师请问，求树的深度的递归算法应该如何分析它的时间复杂度呢？ 百度查了很久也没找到答案。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429304,"discussion_content":"你可以参考下二叉树的遍历","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542680135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39653,"user_name":"世龙","can_delete":false,"product_type":"c1","uid":1240509,"ip_address":"","ucode":"233A97EC15C228","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/bd/c72c3844.jpg","comment_is_top":false,"comment_ctime":1542331734,"is_pvip":false,"replies":[{"id":"14177","content":"不会插到中间的 因为没必要。插在叶子上最好处理了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542333549,"ip_address":"","comment_id":39653,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542331734","product_id":100017301,"comment_content":"插入操作，是不是少考虑了，如果插入一个中间值，现在讲的默认插入叶子节点","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429162,"discussion_content":"不会插到中间的 因为没必要。插在叶子上最好处理了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542333549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39536,"user_name":"往事随风，顺其自然","can_delete":false,"product_type":"c1","uid":1235692,"ip_address":"","ucode":"F266EC6B143E38","user_header":"https://static001.geekbang.org/account/avatar/00/12/da/ec/779c1a78.jpg","comment_is_top":false,"comment_ctime":1542297710,"is_pvip":false,"replies":[{"id":"14183","content":"具体说说","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542334056,"ip_address":"","comment_id":39536,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1542297710","product_id":100017301,"comment_content":"老师，用你的代码删除不对，删除不了对应的","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429104,"discussion_content":"具体说说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542334056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1542987,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8b/4b/fa52d222.jpg","nickname":"行则将至","note":"","ucode":"DB972F2DF059C4","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575686,"discussion_content":"多半是你构建的树有问题。要严格按照二叉树的要求去构建，左节点值小于父节点，右节点值大于父节点。这样构建出来的树可以正常删除的，你检查检查","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655025198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39510,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1542292939,"is_pvip":false,"replies":[{"id":"14185","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542334154,"ip_address":"","comment_id":39510,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542292939","product_id":100017301,"comment_content":"那些 觉得代码不好理解的同学我建议你们画个图 我本来也不太理解 删除的节点左右子树都存在的情况，可是画个图把结点值一更新 就很容易理解了","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429089,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542334154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39509,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1542292783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542292783","product_id":100017301,"comment_content":"思考题 我觉得可以这样做 递归遍历根节点的左子树和右子树 每次递归传递当前深度( 这个深度是从根节点深度， 每次递归加1 ) 然后和一个总深度 进行一个比较如果比总得深度深则更新总深 直到所有子树递归完毕 总深度即位实际高度","like_count":0},{"had_liked":false,"id":39497,"user_name":"我能走多远","can_delete":false,"product_type":"c1","uid":1240465,"ip_address":"","ucode":"07DF5D5DADFA3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","comment_is_top":false,"comment_ctime":1542290705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542290705","product_id":100017301,"comment_content":"删除操作中，p.data = minP.data; &#47;&#47; 将 minP 的数据替换到 p 中；既然是替换最好还是写全比较好。如果是data是个指针的话，这块就是个大问题了。 <br>删除操作中第三点也可以从左孩子找最大的数值吧。<br><br>","like_count":0},{"had_liked":false,"id":39393,"user_name":"JerryLuo","can_delete":false,"product_type":"c1","uid":1006681,"ip_address":"","ucode":"7C549DA1F328B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/59/4401c327.jpg","comment_is_top":false,"comment_ctime":1542263165,"is_pvip":false,"replies":[{"id":"14097","content":"👍","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542279749,"ip_address":"","comment_id":39393,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542263165","product_id":100017301,"comment_content":"我已经看出来我错在哪了!<br>感谢老师!","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429045,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542279749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39371,"user_name":"一般社员","can_delete":false,"product_type":"c1","uid":1065903,"ip_address":"","ucode":"BC2E4C9E57E3AB","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/af/08fc10fe.jpg","comment_is_top":false,"comment_ctime":1542258291,"is_pvip":false,"replies":[{"id":"14101","content":"放一篇文章里太长 我就拆开了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542279854,"ip_address":"","comment_id":39371,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542258291","product_id":100017301,"comment_content":"终于看懂了昨天不懂的，原来需要上下连接起来看","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429035,"discussion_content":"放一篇文章里太长 我就拆开了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542279854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39346,"user_name":"JerryLuo","can_delete":false,"product_type":"c1","uid":1006681,"ip_address":"","ucode":"7C549DA1F328B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/59/4401c327.jpg","comment_is_top":false,"comment_ctime":1542251778,"is_pvip":false,"replies":[{"id":"14109","content":"等比数列求和公式对 但计算的时候就不对了 估计是粗心 仔细再看看","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280277,"ip_address":"","comment_id":39346,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542251778","product_id":100017301,"comment_content":"app中没看到有可以回复的地方，重新留言贴下计算步骤<br><br>假设最大层数是 L<br>总的节点个数 n<br>那么 n 满足这样一个关系：<br><br>n &gt;= 1+2+4+8+...+2^(L-2)+1<br>n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1)<br><br>根据等比数列求和公式<br>Sn=a1*(1-q^n)&#47;(1-q)<br>得<br><br>n &gt;= 1+2+4+8+...+2^(L-2)+1 = 2^(L-2)<br>n &lt;= 1+2+4+8+...+2^(L-2)+2^(L-1) = 2^(L-1)-1<br><br>n &gt;= 2^(L-2)<br>n &lt;= 2^(L-1)-1<br><br>n &gt;= 2^(L-2)<br>n+1 &lt;= 2^(L-1)<br><br>logn &gt;= L-2<br>log(n+1) &lt;= L-1<br><br>logn+2&gt;=L<br>log(n+1)+1&lt;=L<br><br>数学基础不好，还请老师多多指教!😁","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":429020,"discussion_content":"等比数列求和公式对 但计算的时候就不对了 估计是粗心 仔细再看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39148,"user_name":"P@tricK","can_delete":false,"product_type":"c1","uid":1233716,"ip_address":"","ucode":"293B2B3261A793","user_header":"https://static001.geekbang.org/account/avatar/00/12/d3/34/5dee4f70.jpg","comment_is_top":false,"comment_ctime":1542199243,"is_pvip":false,"replies":[{"id":"14045","content":"理论上肯定是可以的。估计是你代码书写的有问题","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542247325,"ip_address":"","comment_id":39148,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542199243","product_id":100017301,"comment_content":"老师，在码二叉树代码时遇到一个问题：<br><br>我想将任意一颗二叉树转成数组打印出来（甚至想画出树结构），然而当我遇到 一些**非完全二叉树 ** 时，转换出来的数组和我预想的不一致。<br><br>我在leetcode做题，538，我去看他的树和数组相互转换的代码，然后用在我代码上有问题的用例去测试：[7, 5, null, 4, null, null, null, 2]，还报错了。<br><br>所以我想问，非完全二叉树可以100%正确地用数组保存吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428940,"discussion_content":"理论上肯定是可以的。估计是你代码书写的有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542247325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39071,"user_name":"Ricky","can_delete":false,"product_type":"c1","uid":1238256,"ip_address":"","ucode":"0B29C730CAD29C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e4/f0/82281239.jpg","comment_is_top":false,"comment_ctime":1542183120,"is_pvip":false,"replies":[{"id":"14118","content":"是的 你说的没错 插入不一定非得放的叶子节点了 遇到一个标记为删除 并且key与要插入的数据key一样的时候 可以直接讲已经标记删除的节点替换为要插入的数据","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280650,"ip_address":"","comment_id":39071,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542183120","product_id":100017301,"comment_content":"老师，请问二叉搜索树如果删除仅设置状态的话，难道删除节点后树的结构一直保持不变吗？那插入数值时该怎么插呢，如果遍历到已删除节点，那直接继续往下遍历吗？或者当删除节点是叶子节点，插入位置正好在该节点，直接替换？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428905,"discussion_content":"是的 你说的没错 插入不一定非得放的叶子节点了 遇到一个标记为删除 并且key与要插入的数据key一样的时候 可以直接讲已经标记删除的节点替换为要插入的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39064,"user_name":"alic","can_delete":false,"product_type":"c1","uid":1240077,"ip_address":"","ucode":"47E9D22030CA01","user_header":"https://static001.geekbang.org/account/avatar/00/12/ec/0d/43d46889.jpg","comment_is_top":false,"comment_ctime":1542181124,"is_pvip":false,"replies":[{"id":"14120","content":"有同学在github上提交了python代码 你可以去看看","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280727,"ip_address":"","comment_id":39064,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542181124","product_id":100017301,"comment_content":"怎么没有python代码呢老师","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428901,"discussion_content":"有同学在github上提交了python代码 你可以去看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39063,"user_name":"JerryLuo","can_delete":false,"product_type":"c1","uid":1006681,"ip_address":"","ucode":"7C549DA1F328B6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/59/4401c327.jpg","comment_is_top":false,"comment_ctime":1542180977,"is_pvip":false,"replies":[{"id":"14048","content":"你贴下你的吧 我看看你哪里错了","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542247505,"ip_address":"","comment_id":39063,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542180977","product_id":100017301,"comment_content":"为什么我算出来的L的范围是[log(n+1) +1, logn +2]，找不出哪里算错了，老师可以贴下计算步骤吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428900,"discussion_content":"你贴下你的吧 我看看你哪里错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542247505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":39061,"user_name":"三个石头","can_delete":false,"product_type":"c1","uid":1110384,"ip_address":"","ucode":"A863A416D65217","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/70/a64d9498.jpg","comment_is_top":false,"comment_ctime":1542180906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542180906","product_id":100017301,"comment_content":"应该只能遍历一遍吧","like_count":0},{"had_liked":false,"id":39046,"user_name":"DebugDog","can_delete":false,"product_type":"c1","uid":1027798,"ip_address":"","ucode":"1664D37CE03B9D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ae/d6/fbb8236d.jpg","comment_is_top":false,"comment_ctime":1542178263,"is_pvip":true,"replies":[{"id":"14121","content":"已经回复其他同学的留言了 你扒拉扒拉看看","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280738,"ip_address":"","comment_id":39046,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542178263","product_id":100017301,"comment_content":"老师你好，对于删除两个节点的最后两行代码：p = minP; pp = minPP;<br>不是很理解这两句意思，说是删除，但是不太明白，能否解释一下。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428891,"discussion_content":"已经回复其他同学的留言了 你扒拉扒拉看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38997,"user_name":"牵手约定","can_delete":false,"product_type":"c1","uid":1249461,"ip_address":"","ucode":"01AF328FDDD38C","user_header":"https://static001.geekbang.org/account/avatar/00/13/10/b5/0813608c.jpg","comment_is_top":false,"comment_ctime":1542169747,"is_pvip":false,"replies":[{"id":"14122","content":"多看几遍吧","user_name":"作者回复","user_name_real":"gg","uid":"1190123","ctime":1542280750,"ip_address":"","comment_id":38997,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1542169747","product_id":100017301,"comment_content":"有点懵了，","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428876,"discussion_content":"多看几遍吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1542280750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":38982,"user_name":"thsai","can_delete":false,"product_type":"c1","uid":1182996,"ip_address":"","ucode":"8DBD57C52809E6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Mp7LOnopozAkwaOCaTR9tWSUe1NmAsGHMbaoo0O6EfXVebOaBibOGBJgfqpGrqZvb6lGcCy0TMYYInveglFFRFg/132","comment_is_top":false,"comment_ctime":1542166579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542166579","product_id":100017301,"comment_content":"删除的第三种情况里，如果找到最小的叶子节点是有右子节点的呢，比如删除前的那棵树中删除50，此时找到最小叶子节点是51，那55这个节点怎么办？代码里面好像没有体现出来","like_count":0},{"had_liked":false,"id":38864,"user_name":"Dream.","can_delete":false,"product_type":"c1","uid":1187286,"ip_address":"","ucode":"49B94CE5BA0D21","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/d6/76fe5259.jpg","comment_is_top":false,"comment_ctime":1542155167,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542155167","product_id":100017301,"comment_content":"是否可以当标记删除的节点到了一定的阀值时，再一次性删除？<br>一次性删除又可能会导致在某次触发删除时会非常慢。<br>是否可以在每次查询的时候，顺带将标记已删除的节点给删除掉？<br>但是这样的操作，与直接删除元素相比，还影响查询速度。<br>所以只能舍弃空间换取时间了吗？","like_count":0},{"had_liked":false,"id":38854,"user_name":"杨伟","can_delete":false,"product_type":"c1","uid":1239937,"ip_address":"","ucode":"D5B521A0688E02","user_header":"https://static001.geekbang.org/account/avatar/00/12/eb/81/43f4b52c.jpg","comment_is_top":false,"comment_ctime":1542154520,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1542154520","product_id":100017301,"comment_content":"遍历一遍","like_count":0}]}