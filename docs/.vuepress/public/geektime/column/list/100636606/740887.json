{"id":740887,"title":"第 13 章 服务注册与发现(1)","content":"<blockquote>\n<p><strong>本章内容</strong></p>\n<ul>\n<li>常见的微服务负载均衡方案</li>\n<li>基于 Spring Cloud 的微服务注册与发现机制</li>\n<li>Spring Cloud DiscoveryClient 的实现原理</li>\n<li>Spring Cloud 中的几种常见服务注册中心</li>\n</ul>\n</blockquote>\n<p>为了提供稳定的服务，系统通常都会采取一些高可用方案，其中集群化就是比较常用的做法。系统一般会部署为一个或者多个集群，集群内的实例都是无状态的，此时就需要考虑如何将请求合理地分发到集群中的各个实例上——这就是负载均衡。负载均衡有很多种方案，有硬件的，也有软件的，有集中式的，也有分布式的。本章就让我们来了解一下 Spring Cloud 为我们提供的微服务负载均衡方案——这是一套分布式的软负载解决方案，而且还支持多种注册中心，使用起来非常方便灵活。</p>\n<h2 id=\"nav_point_203\">13.1　常见的负载均衡方案</h2>\n<p>在开始接触 Spring Cloud 的负载均衡方案前，先让我们来了解一下业界一直以来所使用的负载均衡方案，其中用到的一些技术有的历史悠久，而有的算是新技术。</p>\n<h3 id=\"nav_point_204\">13.1.1　集中式方案</h3>\n<p>所谓集中式方案，通常会有个集中的流量入口，就像图 13-1 里画的那样。其中服务消费者就是服务的调用方，它可以是一个集群，也可以是真实用户（针对对外的服务或者页面）。负载背后真正提供服务的节点，我们可以称其为 Real Server，即真实服务器。服务消费者并不能直接访问真实的服务提供者，需要通过负载均衡器来进行中转，这里介绍的负载均衡器是集中式的，因此在图中将其标注为集中负载。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00788.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 13-1　常见的集中式负载均衡方案</strong></p>\n<ol>\n<li><p><strong>商业硬件方案</strong></p>\n<p>谈到商业负载均衡，比较有名的就是 F5 Networks 的 BIG-IP 了。有些时候我们在交流时甚至会用 F5 来指代硬件负载均衡设备。F5 可以工作在 OSI<span class=\"comment-number\">1</span> 的四层到七层，一般我们会使用四层负载和七层负载。四层负载直接根据 IP 和端口对请求进行负载，发送到后端的服务器上。七层负载则在四层的基础上，可以根据应用的特点再做分发，例如一个 HTTP 的负载均衡器，除了 IP 和端口，还能根据 URL、HTTP 头等信息决定请求如何负载。</p><!-- [[[read_end]]] -->\n<p>硬件负载均衡设备的特点就是处理能力强，单台设备就能扛下巨大的流量；但缺点也很明显，成本太高，而为了保障系统的高可用性，通常还需要准备冗余的硬件，更是进一步加大了投入。除了前面提到的 F5，行业里还有些厂商也提供专业的负载均衡硬件，例如 Array、A10 和 Citrix 等。在做商业硬件方案时，不妨货比三家，除了先期投入，后续的维保和技术支持都是不小的花销。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>开源软件方案</strong></p>\n<p>有硬件方案，自然就会有软件方案；有软件方案，我们就一定会想有没有开源的方案。讲到负载均衡软件，就一定要先介绍一下 LVS（Linux Virtual Server）。LVS 是由章文嵩博士主导开发的一个开源负载均衡器项目，自 1998 年 5 月第一行 LVS 代码诞生后，已经被无数人用在了真实的项目中。而且，LVS 也早已是 Linux 内核的一部分了。LVS 在内核中实现了基于 IP 的请求负载均衡，它属于四层负载均衡，在用户访问负载均衡器后，能根据预先设定好的策略将请求发送到后端具体的某台服务器上。LVS 的常用工作模式有 NAT（Network Address Translation，网络地址转换）模式、DR（Direct Routing，直接路由）模式和 TUN（Tunneling，隧道）模式等。常用的调度策略有轮询调度（Round Robin）、最小连接调度、目标地址 Hash 调度、源地址 Hash 调度和最短期望延迟等。</p>\n<p>LVS 作为请求的入口，自然也要实现高可用，不然图 13-1 中的集中负载一出问题，就算后端的服务提供者都是好的，也没有办法提供服务。网上用的最多的就是搭两台 LVS，一主一备，通过 Keepalived 来监控节点的状态，一旦主节点出问题了，备节点就能自动接管。Keepalived 之所以能实现这一功能，背后靠的是 VRRP（Virtual Router Redundancy Protocol，虚拟路由冗余协议）。它把几台路由设备联合组成一台虚拟的路由设备，当主机的下一跳路由设备出现故障时，及时将业务切换到备份路由设备。这样一来，对外是同一个 VIP（Virtual IP，虚拟 IP），我们无须关注背后具体连的是哪个 LVS 节点，系统会自己来保证总有可用的 LVS。</p>\n<p>聊完了四层上的 LVS，再来看看常用于七层的 Nginx。Nginx 是由俄罗斯程序员 Igor Sysoev 开发的一款高性能 Web 服务器和反向代理服务器，现在它早已成功取代了 Apache HTTP Server 的位置，成为首选的 Web 服务器。Nginx 在开源七层负载均衡器中的地位似乎也已经难以撼动了。Nginx 的七层负载非常灵活，除了根据 URL、HTTP 头匹配规则，还能对请求进行改写，如果搭配 Lua 脚本，可以实现更多“神奇”的效果，可定制性极强。Nginx 同样支持多种调度策略，例如轮询、加权轮询、基于 IP Hash、基于 URL Hash 等。从 1.9.0 版本开始，Nginx 中增加了 Stream 模块，也开始支持 TCP 代理和负载均衡，能够提供四层负载均衡。</p>\n<p>总体上来看，四层负载均衡只需处理底层的数据包，没有复杂的逻辑，性能更好；但七层负载均衡更贴近应用，更加灵活——两者各有利弊。在实际使用过程中，通常会将两者结合起来，最外层用 LVS 搭配 Keepalived 提供高性能高可靠的四层负载，主备 LVS 背后都挂上一组对等的 Nginx 集群提供七层负载，再在 Nginx 中配置具体的应用服务器地址和端口。具体如图 13-2 所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00789.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 13-2　LVS 与 Nginx 搭配的负载均衡方案</strong></p>\n<p>除了上面提到的 LVS 和 Nginx，业界还有一些其他的知名开源负载均衡软件，例如 HAProxy 是一款同时支持四层和七层高性能负载均衡的老牌软件，国内的爱奇艺基于 DPDK 开发了一款高效的四层负载均衡器 DPVS。DPVS 全称是 DPDK-LVS，从名字中就能看出它是从 LVS 修改而来的，两者的主要区别就是 DPVS 引入了 DPDK。DPDK 的全称是 Data Plane Development Kit，能为系统提供更高效的数据包处理能力，核心思想就是 DPDK 应用在 Linux 用户态直接用自己的库来收发数据包，绕过 Linux 内核协议栈的处理过程，节省了很多开销。相比传统 LVS，采用 DPDK 技术后能大幅提升数据包的转发性能。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_205\">13.1.2　分布式方案</h3>\n<p>13.1.1 节中介绍的方案都需要经过一个集中的点，虽然这个点也可以是一个集群，但逻辑上会有个流量进入的中心。只要存在中心点，那这个中心点就可能成为系统的瓶颈或者高危区域，我们能不能消除它呢？答案必然是肯定的。</p>\n<p>大家可以试想一下平时下载东西的过程。当你从一个网站用 HTTP 协议下载文件时，网站就是下载过程中的中心点，一旦网站崩溃，下载就会失败。但如果用 P2P（Point-to-Point，点对点）协议来下载，例如用 BT 工具，我们只需要从 Tracker 服务器上获取目前正在下载和“做种”的节点信息，随后就能直接连上分散在各地的节点去下载，这样就不存在中心了。</p>\n<p>在系统内部的服务调用方式上，我们也可以参考 P2P 的方案，实现分布式负载均衡。服务的提供者在启动后将自己提供的服务信息注册到服务注册中心，而服务的消费者则从注册中心获取自己需要的服务的提供者信息。在发生实际调用时，消费者直接根据策略从提供者列表中选择一个节点发起调用，具体如图 13-3 所示。与集中式方案相比，分布式方案每次调用无须经过独立的负载均衡器，而是直接请求实际的提供者。在具体实现该方案时当然情况会复杂很多，我们要考虑各种异常和特殊场景，例如如何应对注册中心整体故障，如何感知节点发生变化，等等，但整体的流程和结构大致上是这样的。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00790.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 13-3　分布式负载均衡方案</strong></p>\n<p>Spring Cloud 早期支持 Netflix 公司开源的 Eureka 来充当服务的注册中心，后来还提供了对 HashiCorp Consul 和 Apache Zookeeper 的支持，阿里巴巴也贡献了 Nacos 相关的支持。在本章的后续部分，我们会分别来看看这些组件的概况和具体使用方法。</p>\n<h2 id=\"nav_point_206\">13.2　使用 Spring Cloud 实现负载均衡</h2>\n<p>正如在 12.3 节中所介绍的那样，Spring Cloud 为构建云原生应用提供了一系列完整的解决方案，其中之一就是服务的注册与发现机制。Spring Cloud 可以轻松实现微服务的软负载均衡，还自带了对多种注册中心的支持。得益于 Spring 一贯强大的抽象，在切换不同的配置中心时，应用代码几乎无须改动。在接下来的部分中，让我们通过二进制奶茶店的一个例子来了解一下如何使用 Spring Cloud 实现负载均衡。</p>\n<blockquote>\n<p><strong>需求描述</strong>　我们的二进制奶茶店系统慢慢变大了，不再是单机系统，服务端变成了集群。因为不想运维集中式的硬件或者软件负载均衡设施，我们选择了分布式方案，打算用 Spring Cloud 来实现服务的注册和发现。至于注册中心，先不着急决定，都试试吧。</p>\n</blockquote>\n<h3 id=\"nav_point_207\">13.2.1　在 Zookeeper 中注册服务</h3>\n<p>要在项目中使用 Spring Cloud 相关的能力，通常的做法是先在 <code>&lt;dependencyManagement/&gt;</code> 中导入 Spring Cloud 的 pom 文件，具体的版本可以配置在 <code>&lt;properties/&gt;</code> 中，后面用到 Spring Cloud 的依赖时，大多都需要先在这里导入 <code>spring-cloud-dependencies</code>，届时就不再赘述了：</p>\n<pre class=\"code-rows\"><code>&lt;properties&gt;\n    &lt;spring-cloud.version&gt;2021.0.1&lt;/spring-cloud.version&gt;\n&lt;/properties&gt;\n\n&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;$&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;</code></pre>\n<p>随后，引入所需的依赖，例如我们这里希望使用 Zookeeper 来做服务的注册中心，自动实现服务的注册与发现，就在 pom.xml 的 <code>&lt;dependencies/&gt;</code> 中增加如下的起步依赖，版本由上面的 <code>spring-cloud-dependencies</code> 统一管理：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>作为服务提供者的程序在引入依赖后，不需要我们做什么改动，只需调整一些配置即可，例如，在 <code>application.properties</code> 里增加如下内容 <span class=\"comment-number\">2</span>：</p>\n\n<pre class=\"code-rows\"><code>spring.application.name=binarytea\nspring.cloud.zookeeper.connect-string=localhost:2181</code></pre>\n<p>第一行的 <code>spring.application.name</code> 是使用 Spring Cloud 的服务注册、服务发现和配置管理功能等诸多功能时都需要用到的配置，代表了当前应用的应用名称。第二行的 <code>spring.cloud.zookeeper.connect-string</code> 是具体要连接的 Zookeeper 地址，这里我们使用了监听本机 <code>2181</code> 端口的 Zookeeper，记得先把它启动起来，当然，也可以换别的地址。如果使用 Docker 的话，可以用如下命令在本地启动一个 Zookeeper：</p>\n<pre class=\"code-rows\"><code>▸ docker pull zookeeper\n▸ docker run --name zookeeper -p 2181:2181 -d zookeeper</code></pre>\n<p>在启动我们的 BinaryTea 程序后，Spring Cloud 会帮我们把实例注册到 Zookeeper 上，如果我们用 <code>zkCli.sh</code> 命令连上 Zookeepr，通过命令可以查看到具体的信息，大致是这样的：</p>\n<pre class=\"code-rows\"><code>[zk: localhost:2181(CONNECTED) 3] ls /services/binarytea\n[5ff82111-04c2-4b13-ba52-3c69f5468691]\n[zk: localhost:2181(CONNECTED) 5] get /services/binarytea/5ff82111-04c2-4b13-ba52-3c69f5468691\n{\"name\":\"binarytea\",\"id\":\"5ff82111-04c2-4b13-ba52-3c69f5468691\",\"address\":\"192.168.3.7\",\"port\":8080,\n\"sslPort\":null,\"payload\":{\"@class\":\"org.springframework.cloud.zookeeper.discovery.ZookeeperInstance\",\n\"id\":\"binarytea\",\"name\":\"binarytea\",\"metadata\":{\"instance_status\":\"UP\"}},\"registrationTimeUTC\":\n1621778230330,\"serviceType\":\"DYNAMIC\",\"uriSpec\":{\"parts\":[{\"value\":\"scheme\",\"variable\":true},{\"value\":\n\"://\",\"variable\":false},{\"value\":\"address\",\"variable\":true},{\"value\":\":\",\"variable\":false},{\"value\":\n\"port\",\"variable\":true}]}}</code></pre>\n<p>从上面的信息可以看到，服务名是 <code>binarytea</code>，也就是 <code>spring.application.name</code> 里配置的值，实例 ID 默认是 Spring 上下文 ID，地址就是注册上去的本机 IP，端口是 <code>server.port</code>，当前实例的状态是 <code>UP</code>。</p>\n<p>Spring Cloud 的 Zookeeper 支持还有些别的配置，通常用默认值也够了，但还是可以了解一下，具体如表 13-1 所示。</p>\n<p><strong>表 13-1　Spring Cloud Zookeeper 与服务注册与发现有关的一些配置</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>配置项</p></th>\n<th><p>默认值</p></th>\n<th><p>说明</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>spring.cloud.service-registry.auto-registration.enabled</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否开启服务自动注册</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.zookeeper.enabled</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否开启 Zookeeper 相关支持</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.zookeeper.connect-string</code></p></td>\n<td><p><code>localhost:2181</code></p></td>\n<td><p>Zookeeper 的连接串</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.zookeeper.connection-timeout</code></p></td>\n<td><p><code>15000ms</code></p></td>\n<td><p>Zookeeper 的连接超时时间</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.zookeeper.session-timeout</code></p></td>\n<td><p><code>60000ms</code></p></td>\n<td><p>Zookeeper 的会话超时时间</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.zookeeper.discovery.register</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否开启 Zookeeper 服务注册</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.zookeeper.discovery.enabled</code></p></td>\n<td><p><code>true</code></p></td>\n<td><p>是否开启 Zookeeper 服务发现</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.zookeeper.discovery.prefer-ip-address</code></p></td>\n<td><p><code>false</code></p></td>\n<td><p>是否优先使用 IP 地址</p></td>\n</tr>\n<tr>\n<td><p><code>spring.cloud.zookeeper.discovery.root</code></p></td>\n<td><p><code>/services</code></p></td>\n<td><p>服务注册与发现的根目录</p></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p><strong>茶歇时间：为什么 Zookeeper 不适合做服务注册中心</strong></p>\n<p>虽然在书中我们首先介绍了如何使用 Zookeeper 来充当服务的注册中心，在实际工作中的确也有很多人是这么用的，但这<strong>并不代表 Zookeeper 就是最合适的选择，甚至可以说它不是个理想的选择</strong>，这是为什么呢？</p>\n<p>在分布式系统中有一个著名的 CAP 定理，其中 C 是指一致性（Consistency），A 是指可用性（Availability），而 P 则指分区容错性（Partition tolerance）。这条定理说的是 <strong>CAP 中的三个要素最多只能同时满足两个，不能三者兼顾</strong>。也就是说一个系统要么是 CA 的，要么是 CP 的，要么是 AP 的，不可能同时满足 CAP 三个要素。</p>\n<p>Zookeeper 作为一款知名的分布式协调系统，追求一致性，满足 CP，在关键时刻会放弃可用性。这个关键的设计注定了在这个场景下它不是一个合理的选择，因为服务的注册中心需要是个 AP 系统。在极端情况下，注册中心活着往往比服务提供者和消费者的准确性更重要，少一个可用服务提供者并不会影响请求调用，但注册中心全崩溃了，所有服务都找不到自己需要调用的下游，那才是一个灾难。</p>\n<p>此外，Zookeeper 本身在选举、保持一致性方面有较高要求，官方推荐配置集群在 5 节点或者 7 节点这种规模，面对日益庞大的应用系统规模，终将面对自己的性能瓶颈，即使增加观察者模式的节点，也会很快面临需要拆分的那一天。还有类似服务健康检查等其他的问题，都让 Zookeeper 这个明星在服务注册中心场景下的表现不尽如人意。</p>\n<p>关于这个问题的讨论，阿里巴巴和 Netflix 的技术专家都曾经撰写过文章，讲述自己为何不选择 Zookeeper 而是自己开发了一套服务注册中心，感兴趣的朋友可以读读《阿里巴巴为什么不用 ZooKeeper 做服务发现？》和“Eureka! Why You Shouldn't Use ZooKeeper for Service Discovery”。</p>\n</blockquote>\n<h3 id=\"nav_point_208\">13.2.2　使用 Spring Cloud LoadBalancer 访问服务</h3>\n<p>有了服务的提供者，自然就会有服务的消费者，在消费者这一端，同样需要引入 13.1 中的各种依赖。<span class=\"comment-number\">3</span> 最重要的是让 <code>RestTemplate</code> 支持从注册中心获取对应服务的列表，需要在声明 Bean 的时候增加 <code>@LoadBalanced</code> 注解，以便为我们的 <code>RestTemplate</code> 增加 <code>LoadBalancerInterceptor</code>，就像下面这样：</p>\n\n<pre class=\"code-rows\"><code>@Bean\n@LoadBalanced\npublic RestTemplate restTemplate(RestTemplateBuilder builder) {}</code></pre>\n<blockquote>\n<p><strong>茶歇时间：<code>@LoadBalanced</code> 是如何工作的</strong></p>\n<p><code>RestTemplate</code> 扩展了 <code>InterceptingHttpAccessor</code>，其中包含一个 <code>List&lt;ClientHttpRequestInterceptor&gt;</code>，可以插入各种用于拦截请求进行处理的拦截器，上面提到的 <code>LoadBalancerInterceptor</code> 就是其中之一。它会从请求的 URL 中取出主机信息，将其视为服务名，随后通过 <code>LoadBalancerRequestFactory</code> 基于现有请求封装一个新的 HTTP 请求，用 <code>LoadBalancerClient</code> 来执行请求。</p>\n<p>Spring Cloud Commons 中的自动配置类 <code>LoadBalancerAutoConfiguration.LoadBalancerInterceptorConfig</code> 中会自动创建一个 <code>LoadBalancerInterceptor</code>，并通过 <code>RestTemplateCustomizer</code> 将前者注入每个带有 <code>@LoadBalanced</code> 的 <code>RestTemplate</code> 中。</p>\n</blockquote>\n<p>随后，在 <code>RestTemplate</code> 发起调用时，我们就可以在目标 URL 中使用目标服务名来代替具体的主机与端口，例如 http://binarytea/token 就可以代替之前的 http://localhost:8080/token，<code>binarytea</code> 会被替换成具体的目标。在 <code>application.properties</code> 中同样做些微调：</p>\n<pre class=\"code-rows\"><code>spring.application.name=customer\nspring.cloud.zookeeper.connect-string=localhost:2181\n\nbinarytea.url=http://binarytea</code></pre>\n<p>这里因为存在 <code>JwtClientHttpRequestInitializer</code>，我们在请求时会添加 JWT 令牌，而之前的示例中，获取令牌的动作每次会创建一个新的 <code>RestTemplate</code>，显然它没被 <code>@LoadBalanced</code> 增强过，所以 10.4 节中的 Customer 示例不能只改配置，还需对 <code>JwtClientHttpRequestInitializer</code> 做些微调，具体的改动如下：</p>\n<ul>\n<li>直接注入一个上下文中的 <code>RestTemplate</code>，不再通过 <code>ClientHttpRequestFactory</code> 来自己创建；</li>\n<li>为了避免循环依赖，注入的 <code>RestTemplate</code> 上要添加 <code>@Lazy</code>，同时 <code>initToken()</code> 不能在构建后自动执行，也就是要去掉 <code>@PostConstruct</code>；</li>\n<li>由于注入的 <code>RestTemplate</code> 也会执行 <code>JwtClientHttpRequestInitializer</code>，所以针对 <em>/token</em> 的请求要跳过添加令牌的动作。</li>\n</ul>\n<p>大致上的代码如代码示例 13-1 所示。<span class=\"comment-number\">4</span></p>\n\n<blockquote>\n<p><strong>代码示例 13-1</strong>　修改后的 <code>JwtClientHttpRequestInitializer</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class JwtClientHttpRequestInitializer implements RestTemplateRequestCustomizer {\n    // 省略部分属性\n    @Autowired\n    @Lazy\n    private RestTemplate restTemplate;\n    // 去掉了@PostConstruct\n    public void initToken() {...}\n\n    @Override\n    public void customize(ClientHttpRequest request) {\n        if (request.getURI().getPath().equalsIgnoreCase(\"/token\")) {\n            // /token的路径不添加令牌\n            return;\n        }\n        // 省略未改动的代码\n    }\n\n    private ResponseEntity&lt;TokenResponse&gt; acquireToken() {\n        return restTemplate // 直接用RestTemplate来获取Token，这里要跳过令牌校验\n                .postForEntity(binarytea + \"/token\",\n                        new TokenRequest(username, password), TokenResponse.class);\n    }\n}</code></pre>\n<p>通常我们都会希望开着服务发现功能，但如果出于某些原因，CLASSPATH 里存在相关依赖，又希望关闭这个功能，可以配置 <code>spring.cloud.discovery.enabled=false</code>。其他还有一些 <code>spring.cloud.loadbalancer</code> 打头的配置项，可以参考 <code>LoadBalancerProperties</code> 类。</p>\n<h3 id=\"nav_point_209\">13.2.3　使用 OpenFeign 访问服务</h3>\n<p>使用 <code>RestTemplate</code> 已经可以方便地调用 REST 服务了，可是在编写调用代码时多少还有些“刻意”的味道，要专门用 <code>RestTemplate</code> 中与 HTTP 动作对应的方法，既要传递参数，又要处理结果类型。如果能像调用普通业务逻辑代码那样来调用远程的服务，代码看起来就会舒服很多。</p>\n<blockquote>\n<p><strong>请注意</strong>　虽然这里的代码调用看上去和普通的本地方法调用没什么区别，但一定要时刻提醒自己，这是个远程调用，各种异常、时延的问题还是要处理的。</p>\n</blockquote>\n<p>OpenFeign<span class=\"comment-number\">5</span> 是一款声明式的 Web 服务客户端，将 Java 代码和 HTTP 接口绑定到一起，让开发者可以轻松地编写 Web 服务客户端。原本 OpenFeign 要求创建一个接口，随后加上 OpenFeign 或者 JAX-RS 的注解来声明服务；在 Spring Cloud OpenFeign 的加持下，现在我们也可以使用 Spring MVC 的注解来做声明，还可以充分利用 Spring Cloud 提供的服务注册与发现能力。</p>\n\n<ol>\n<li><p><strong>OpenFeign 的基本用法</strong></p>\n<p>这里我们仍旧以 Customer 项目为例，在 13.2 节中的例子的基础上，引入 Spring Cloud OpenFeign 的依赖。关于服务负载均衡相关的能力，并不包含在这个依赖中，如果需要，我们可以自己添加 <code>spring-cloud-starter-loadbalancer</code> 依赖，或者是添加间接包含它的依赖，例如 <code>spring-cloud-starter-zookeeper-discovery</code>。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!-- 下面不是必需的 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>随后调整客户端代码，定义远程服务的接口。其实有了 Spring Cloud 的帮助，我们可以直接将 BinaryTea 中的控制器类复制过来，删掉具体的方法实现，按需留下带有注解的方法声明就可以了。当然，在实际工作中，还是会稍作修改，例如代码示例 13-2<span class=\"comment-number\">6</span> 就是我们迁移到客户端的订单服务。</p>\n<blockquote>\n<p><strong>代码示例 13-2</strong>　对应了 <code>OrderController</code> 的 Feign 服务接口</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@FeignClient(contextId = \"orderService\", name = \"binarytea\", path = \"/order\")\npublic interface OrderService {\n    @GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)\n    List&lt;Order&gt; listOrders();\n\n    @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE,\n                  produces = MediaType.APPLICATION_JSON_VALUE)\n    ResponseEntity&lt;Order&gt; createNewOrder(@RequestBody NewOrderForm form);\n}</code></pre>\n<p>在上面的接口定义中，我们去除了呈现页面的部分，只留下了 REST 服务的接口。<code>@FeignClient</code> 注解告诉 Spring Cloud 这是一个 Feign 的 <code>Client</code>，只需在配置类上添加 <code>@EnableFeignClients</code>，Spring 会自动扫描带有 <code>@FeignClient</code> 的接口并注册对应的 Bean，而 Bean 的 ID 就是 <code>contextId</code> 中所指定的。<code>name</code> 属性是服务名，通过它在注册中心找到对应的服务提供者，其中可以带上 <code>http://</code> 这样的协议，也可以使用 <code>${}</code> 这样的占位符。<code>path</code> 是接口中所有方法的路径前缀，定义方法时也可以在注解里添加自己的 <code>path</code> 属性，如果有公共的路径前缀就用这种方式配置，不要再配置 <code>@RequestMapping</code> 之类的注解。返回的 <code>Order</code> 对象可以直接从 BinaryTea 工程中复制过来，去掉不需要的注解和一些属性即可，此处就不再赘述了，大家可以直接参考示例代码。</p>\n<p>有了 <code>OrderService</code> 后，我们就不再需要用 <code>RestTemplate</code> 发起订单调用了，新的 <code>OrderRunner</code> 可以改成代码示例 13-3 这样，直接使用 <code>OrderService</code> 让代码逻辑看起来更自然了。</p>\n<blockquote>\n<p><strong>代码示例 13-3</strong>　使用了 Feign 客户端的 <code>OrderRunner</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Component\n@Order(5)\n@Setter\n@Slf4j\npublic class OrderRunner implements ApplicationRunner {\n    @Autowired\n    private OrderService orderService;\n\n    @Override\n    public void run(ApplicationArguments args) throws Exception {\n        List&lt;learning.spring.customer.model.Order&gt; orders = orderService.listOrders();\n        log.info(\"调用前的订单数量: {}\", orders.size());\n        NewOrderForm form = NewOrderForm.builder()\n            .itemIdList(Arrays.asList(\"1\"))\n            .discount(90).build();\n        ResponseEntity&lt;learning.spring.customer.model.Order&gt; response =\n                orderService.createNewOrder(form);\n        log.info(\"HTTP Status: {}, Headers: {}\", response.getStatusCode(), response.getHeaders());\n        log.info(\"Body: {}\", response.getBody());\n    }\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>请求拦截器</strong></p>\n<p>到目前为止，我们的 <code>OrderRunner</code> 还不能正常工作，因为服务端针对 <code>/order</code> 需要进行 JWT 令牌认证。之前我们用 <code>RestTemplate</code> 时写过一个 <code>JwtClientHttpRequestInitializer</code> 对每个请求进行定制，现在也是一样的。OpenFeign 提供了一个 <code>RequestInterceptor</code> 接口，用来对请求进行拦截，我们可以写一个类似的 <code>JwtClientHttpRequestInterceptor</code>，为请求添加 JWT 令牌相关的 HTTP 头。具体如代码示例 13-4 所示，其主要代码与 <code>JwtClientHttpRequestInitializer</code> 几乎相同。</p>\n<blockquote>\n<p><strong>代码示例 13-4</strong>　处理 JWT 认证相关拦截工作的 <code>JwtClientHttpRequestInterceptor</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Slf4j\npublic class JwtClientHttpRequestInterceptor implements RequestInterceptor {\n    // 所有要注入的属性与JwtClientHttpRequestInitializer相同，此处省略\n    @Override\n    public void apply(RequestTemplate requestTemplate) {\n        if (StringUtils.isBlank(token)) {\n            initToken();\n        }\n        requestTemplate.header(HttpHeaders.AUTHORIZATION, \"Bearer \" + token);\n    }\n    // initToken()等方法与JwtClientHttpRequestInitializer相同，此处省略\n}</code></pre>\n<p>只需把这个类配置为 Bean，Spring 会自动将上下文中 <code>RequestInterceptor</code> 类型的 Bean 注入 OpenFeign 客户端里，所以配置类大概就像代码示例 13-5 这样。现在只要启动 BinaryTea 工程，让其注册到注册中心上，我们的整个客户端代码就能正常工作了。</p>\n<blockquote>\n<p><strong>代码示例 13-5</strong>　增加了 <code>@EnableFeignClients</code> 和 <code>JwtClientHttpRequestInterceptor</code> 的配置类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@Slf4j\n@EnableFeignClients\npublic class CustomerApplication {\n    @Bean\n    public JwtClientHttpRequestInterceptor jwtClientHttpRequestInterceptor() {\n        return new JwtClientHttpRequestInterceptor();\n    }\n    // 省略其他内容\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>切换不同的 HTTP 客户端</strong></p>\n<p>与 <code>RestTemplate</code> 一样，OpenFeign 底层也支持多种 HTTP 客户端，默认的 <code>Client.Default</code> 客户端实例使用 Java 自带的 <code>HttpURLConnnection</code>，如果 CLASSPATH 中存在对应的客户端与封装类，就能替换客户端，具体如表 13-2 所示 <span class=\"comment-number\">7</span>。</p>\n<p><strong>表 13-2　OpenFeign 支持的 HTTP 客户端</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>客户端</th><th>封装类</th><th>依赖</th><th>配置项</th></tr><tr><td>Apache Http Client</td><td><code>ApacheHttpClient</code></td><td>feign-httpclient</td><td><code>feign.httpclient.enabled</code></td></tr><tr><td>Apache HttpComponents Client 5</td><td><code>ApacheHttp5Client</code></td><td>feign-hc5</td><td><code>feign.httpclient.hc5.enabled</code></td></tr><tr><td>OkHttp3</td><td><code>OkHttpClient</code></td><td>feign-okhttp</td><td><code>feign.okhttp.enabled</code></td></tr></table>\n\n<p>Spring Cloud OpenFeign 的 <code>FeignAutoConfiguration</code> 自动配置类会根据 CLASSPATH 和上下文的情况自动为我们配置对应的客户端。下面的配置代码会自动创建 Apache Http Client 的 <code>CloseableHttpClient</code>，并用它来创建 <code>feignClient</code> Bean，<code>feign.httpclient.enabled</code> 不配置的话默认是 <code>true</code>，所以也可以不写。当然，我们也可以自己动手覆盖这些配置，比如用 <code>HttpClientBuilder</code> 配置一个自己的 <code>CloseableHttpClient</code>。</p>\n<pre class=\"code-rows\"><code>@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass(Feign.class)\n@EnableConfigurationProperties({ FeignClientProperties.class, FeignHttpClientProperties.class, FeignEncoderProperties.class })\n@Import(DefaultGzipDecoderConfiguration.class)\npublic class FeignAutoConfiguration {\n    @Configuration(proxyBeanMethods = false)\n    @ConditionalOnClass(ApacheHttpClient.class)\n    @ConditionalOnMissingBean(CloseableHttpClient.class)\n    @ConditionalOnProperty(value = \"feign.httpclient.enabled\", matchIfMissing = true)\n    @Conditional(HttpClient5DisabledConditions.class)\n    protected static class HttpClientFeignConfiguration {}\n    // 省略其他代码\n}</code></pre>\n<p>从上面的代码中可以看出只要 CLASSPATH 里存在 <code>ApacheHttpClient</code> 类，上下文里没有 <code>CloseableHttpClient</code> 类型的 Bean，又不是 HC5 的情况，Spring Cloud 就会自动为我们配置基于 Http Client 的 Feign 客户端，所以最简单的方法就是在 pom.xml 的 <code>&lt;dependencies/&gt;</code> 里加上下面这些依赖。在之前用 <code>RestTemplate</code> 时我们用过 Http Client，而 <code>feign-httpclient</code> 就是包含了 <code>ApacheHttpClient</code> 封装类的依赖。这里的版本需要我们根据 Spring Cloud OpenFeign 依赖的 OpenFeign 版本进行微调，例如这里用的是 11.8。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;\n    &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;\n    &lt;version&gt;11.8&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;\n    &lt;artifactId&gt;httpclient&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>OpenFeign 的常用配置</strong></p>\n<p>在前面的例子中，我们已经看到了 Spring Cloud OpenFeign 会为我们自动应用上下文中的 <code>RequestInterceptor</code>。除了这个类型的 Bean，还有一些其他类型的 Bean 也有类似的效果，我们在上下文里配置自己的 Bean 就行了，例如：</p>\n<ul>\n<li><code>Logger.Level</code>，OpenFeign 的日志级别，可以是 <code>NONE</code>、<code>BASIC</code>、<code>HEADERS</code> 和 <code>FULL</code>；</li>\n<li><code>Retryer</code>，重试相关的配置，默认会创建一个 <code>Retryer.NEVER_RETRY</code> 类型的 Bean，表示不做重试；</li>\n<li><code>Request.Options</code>，请求相关的配置，例如连接超时、读取超时等；</li>\n<li><code>Capability</code>，可以在构建客户端时，针对部分核心能力进行自定义，例如在引入了 <code>feign-micrometer</code> 后自动配置的 <code>MicrometerCapability</code>。</li>\n</ul>\n<p>当然，Spring Cloud OpenFeign 还是为我们做了大量的自动配置工作的，例如 <code>FeignLoadBalancerAutoConfiguration</code> 和前面提到的 <code>FeignAutoConfiguration</code>。默认的 <code>FeignContext</code> 中包含了很多东西，OpenFeign 中需要用到 <code>Contract</code>、<code>Encoder</code>、<code>Decoder</code> 和 <code>Logger</code>，<code>FeignClientsConfiguration</code> 就分别配置了 <code>SpringMvcContract</code>、<code>SpringEncoder</code>、<code>ResponseEntityDecoder</code> 和 <code>Slf4jLogger</code>（<code>DefaultFeignLoggerFactory</code> 默认创建的就是这个 <code>Logger</code>）。此外，还有 <code>Feign.Builder</code> 和 <code>Client</code> 的默认值。</p>\n<p>上面提到的默认配置都加了 <code>@ConditionalOnMissingBean</code> 注解，所以只需要我们在配置类里提供自己的 Bean 就能取代默认值。如果是用于特定的 <code>@FeignClient</code> 中，注解里还有一个 <code>configuration</code> 属性，可以提供配置类，这里为了避免配置类被自动扫描，可以不用添加 <code>@Configuration</code> 注解。</p>\n<p>除了配置类的方式，我们也可以选择用配置文件来设置 OpenFeign 的各项属性，相关属性大部分都用 <code>feign.client.config.&lt;contextId&gt;</code> 开头，如果是默认属性可以用 <code>feign.client.config.default</code> 开头。表 13-3 罗列了一些常用的配置。</p>\n<p><strong>表 13-3　Spring Cloud OpenFeign 提供的一些常用配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>说明</th></tr><tr><td><code>feign.client.default-to-properties</code></td><td>如果同时存在配置类和配置文件，是否默认用配置文件的内容</td></tr><tr><td><code>feign.client.config.&lt;contextId&gt;.connect-timeout</code></td><td>连接超时，单位毫秒</td></tr><tr><td><code>feign.client.config.&lt;contextId&gt;.read-timeout</code></td><td>读取超时，单位毫秒</td></tr><tr><td><code>feign.client.config.&lt;contextId&gt;.encoder</code></td><td><code>Encoder</code> 类名</td></tr><tr><td><code>feign.client.config.&lt;contextId&gt;.decoder</code></td><td><code>Decoder</code> 类名</td></tr><tr><td><code>feign.client.config.&lt;contextId&gt;.logger-level</code></td><td>日志级别，注意是 Feign 的 <code>Logger.Level</code> 枚举值，不是一般的日志级别</td></tr><tr><td><code>feign.client.config.&lt;contextId&gt;.follow-redirects</code></td><td>是否依据响应内容做重定向</td></tr></table>\n\n<p>更多的配置项可以参考 <code>FeignClientProperties.FeignClientConfiguration</code> 类，如果用了 Apache Http Client，还有一些 <code>feign.httpclient</code> 开头的配置项，可以参考 <code>FeignHttpClientProperties</code> 类。</p>\n</li>\n</ol>\n\n\n","neighbors":{"left":{"article_title":"第 12 章 微服务与云原生应用","id":740886},"right":{"article_title":"第 13 章 服务注册与发现(2)","id":740888}},"comments":[{"had_liked":false,"id":394699,"user_name":"Mr.Apresunday","can_delete":false,"product_type":"c1","uid":3892913,"ip_address":"安徽","ucode":"6504EF144E0FAB","user_header":"https://static001.geekbang.org/account/avatar/00/3b/66/b1/b5e6e452.jpg","comment_is_top":false,"comment_ctime":1727748198,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100636606,"comment_content":"书中的源码、组件包哪里可以下载","like_count":0,"discussions":[{"author":{"id":3968220,"avatar":"https://static001.geekbang.org/account/avatar/00/3c/8c/dc/e0f3cbca.jpg","nickname":"hhh啦啦啦","note":"","ucode":"67EB52A6701ADB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653857,"discussion_content":"「前言」里有源码链接","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731484998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}