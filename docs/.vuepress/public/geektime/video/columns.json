[{"id":100044601,"n":".NET Core开发实战","a":"肖伟宇","f":true,"c":61,"p":61,"l":[{"id":188694,"t":"01 | 课程介绍"},{"id":188695,"t":"02 | 内容综述"},{"id":188698,"t":"03 | .NET Core的现状、未来以及环境搭建"},{"id":188699,"t":"04 | Startup：掌握ASP.NET Core的启动过程"},{"id":188700,"t":"05 | 依赖注入：良好架构的起点"},{"id":188701,"t":"06 | 作用域与对象释放行为：你知道IDisposable对象释放的时机和坑吗？"},{"id":188702,"t":"07 | 用Autofac增强容器能力：引入面向切面编程（AOP）的能力"},{"id":188705,"t":"08 | 配置框架：让服务无缝适应各种环境"},{"id":191455,"t":"09 | 命令行配置提供程序：最简单快捷的配置注入方法"},{"id":191492,"t":"10 | 环境变量配置提供程序：容器环境下配置注入的最佳途径"},{"id":191493,"t":"11 | 文件配置提供程序：自由选择配置的格式"},{"id":191494,"t":"12 | 配置变更监听：配置热更新能力的核心"},{"id":191491,"t":"13 | 配置绑定：使用强类型对象承载配置数据"},{"id":191495,"t":"14 | 自定义配置数据源：低成本实现定制化配置方案"},{"id":195328,"t":"15 | 选项框架：服务组件集成配置的最佳实践"},{"id":195329,"t":"16 | 选项数据热更新：让服务感知配置的变化"},{"id":195330,"t":"17 | 为选项数据添加验证：避免错误配置的应用接收用户流量"},{"id":195332,"t":"18 | 日志框架：聊聊记日志的最佳姿势"},{"id":195333,"t":"19 | 日志作用域：解决不同请求之间的日志干扰"},{"id":195334,"t":"20 | 结构化日志组件Serilog：记录对查询分析友好的日志"},{"id":198262,"t":"21 | 中间件：掌控请求处理过程的关键"},{"id":198261,"t":"22 | 异常处理中间件：区分真异常与逻辑异常"},{"id":198260,"t":"23 | 静态文件中间件：前后端分离开发合并部署骚操作"},{"id":198258,"t":"24 | 文件提供程序：让你可以将文件放在任何地方"},{"id":198257,"t":"25 | 路由与终结点：如何规划好你的Web API"},{"id":198256,"t":"26 | 工程结构概览：定义应用分层及依赖关系"},{"id":201160,"t":"27 | 定义Entity：区分领域模型的内在逻辑和外在行为"},{"id":201162,"t":"28 | 工作单元模式（UnitOfWork）：管理好你的事务"},{"id":201163,"t":"29 | 定义仓储：使用EF Core实现仓储层"},{"id":201164,"t":"30 | 领域事件：提升业务内聚，实现模块解耦"},{"id":201165,"t":"31 | APIController：定义API的最佳实践"},{"id":201166,"t":"32 | 集成事件：解决跨微服务的最终一致性"},{"id":205637,"t":"33 | 集成事件：使用RabbitMQ来实现EventBus"},{"id":205636,"t":"34 | MediatR：轻松实现命令查询职责分离模式（CQRS）"},{"id":205635,"t":"35 | MediatR：让领域事件处理更加优雅"},{"id":226756,"t":"36 | HttpClientFactory：管理向外请求的最佳实践"},{"id":226759,"t":"37 | gRPC：内部服务间通讯利器"},{"id":226760,"t":"38 | gRPC：用代码生成工具提高生产效率"},{"id":226773,"t":"39 | Polly：用失败重试机制提升服务可用性"},{"id":228419,"t":"40 | Polly：熔断慢请求避免雪崩效应"},{"id":228411,"t":"41 | 网关与BFF：区分场景与职责"},{"id":228418,"t":"42 | 网关与BFF：使用JWT来实现身份认证与授权"},{"id":230076,"t":"43 | 安全：反跨站请求伪造"},{"id":230077,"t":"44 | 安全：防开放重定向攻击"},{"id":230086,"t":"45 | 安全：防跨站脚本"},{"id":230087,"t":"46 | 安全：跨域请求"},{"id":231235,"t":"47 | 缓存：为不同的场景设计合适的缓存策略"},{"id":231236,"t":"48 | 部署：演示一个部署流程"},{"id":231237,"t":"49 | ConfigMap：实现基本配置方案"},{"id":231239,"t":"50 | 配置：使用分布式配置中心方案版本化管理配置"},{"id":232437,"t":"51 | 健康检查：与Liveness、Readiness、Startup探测集成实现高可用"},{"id":232438,"t":"52 | 健康检查：搭建全量健康检查探针和看板"},{"id":232440,"t":"53 | ForwardedHeaders：确保服务在负载均衡下正常工作"},{"id":232441,"t":"54 | 安全：介绍强制HTTPS的两种方式"},{"id":233266,"t":"55 | 日志：与EFK日志三件套集成"},{"id":233267,"t":"56 | 日志：Exceptionless日志系统"},{"id":233268,"t":"57 | 追踪：集成SkyWalking .NET实现追踪"},{"id":233269,"t":"58 | 监控与告警：Prometheus与AlertManager"},{"id":233270,"t":"59 | 监控与告警：用Granfana实现监控看板"},{"id":233272,"t":"60 | prometheus-net：自定义监控指标利器"},{"id":233273,"t":"61 | 结课测试&结束语"}]},{"id":100801301,"n":"AI Agent入门实战","a":"周文洋","f":true,"c":21,"p":21,"l":[{"id":804380,"t":"01｜大佬视角解读AI Agent"},{"id":804383,"t":"02｜​什么是AI Agent？"},{"id":804386,"t":"03｜学会使用AI智能体"},{"id":804389,"t":"04｜AI Agent硬件场景分析"},{"id":804390,"t":"05｜AI Agent深度解析"},{"id":804392,"t":"06｜AI Agent各行业应用场景解析​"},{"id":804393,"t":"07｜AI Agent主流框架介绍​​"},{"id":806259,"t":"08｜Coze基本介绍​"},{"id":806310,"t":"09｜Coze个人空间​"},{"id":806311,"t":"10｜Coze Bot商店"},{"id":808278,"t":"11｜Coze插件商店以及工作流商店"},{"id":808279,"t":"12｜Coze机器人编排介绍"},{"id":809080,"t":"13｜Coze插件使用讲解"},{"id":809081,"t":"14｜Coze工作流详解"},{"id":809082,"t":"15｜Coze人设与回复详解"},{"id":809083,"t":"16｜Coze图像流详解"},{"id":812649,"t":"17｜Coze文本知识库（课程咨询顾问 ）"},{"id":812650,"t":"18｜Coze图片知识库（ 产品查询助手）"},{"id":812662,"t":"19｜Coze表格知识库（学员信息查询）"},{"id":812663,"t":"20｜Coze记忆（学员信息登记）"},{"id":812664,"t":"结束语｜AI Agent总结"}]},{"id":100775901,"n":"AI Agent智能体实战课","a":"周文洋","f":true,"c":56,"p":56,"l":[{"id":786502,"t":"01｜人工智能的发展阶段"},{"id":786504,"t":"02｜什么是Agent？"},{"id":786506,"t":"03｜零基础搭建第一个智能体：语音汇报小秘书"},{"id":786507,"t":"04｜零基础搭建第二个智能体：抖音热点短视频文案助理"},{"id":786510,"t":"05｜了解GPTs"},{"id":786512,"t":"06｜GPTs智能体案例解析：小红书文案、流程图设计与编辑"},{"id":786519,"t":"07｜GPTs智能体案例解析：数据分析"},{"id":786524,"t":"08｜案例演示：打造一个集成国内上百款工具的GPTs"},{"id":786525,"t":"09｜详细配置：打造一个集成国内上百款工具的GPTs"},{"id":786531,"t":"10｜智能客服Agent：实战演示"},{"id":786534,"t":"11｜智能客服Agent：整体设计流程解析"},{"id":786536,"t":"12｜智能客服Agent：后端解析（Assistants API）"},{"id":786538,"t":"13｜智能客服Agent：工作流配置"},{"id":786539,"t":"14｜智能客服Agent：后端配置"},{"id":786541,"t":"15｜智能客服Agent：集成外部统计工具"},{"id":786548,"t":"16｜FastGPT介绍"},{"id":786550,"t":"17｜FastGPT创建知识库详解"},{"id":786554,"t":"18｜FastGPT知识库应用配置详解"},{"id":786557,"t":"19｜FastGPT测试并发布应用"},{"id":786559,"t":"20｜FastGPT智能客服搭建：高级编排介绍"},{"id":786561,"t":"21｜FastGPT智能客服搭建：基础配置"},{"id":786563,"t":"22｜FastGPT智能客服搭建：结构化数据提取"},{"id":786564,"t":"23｜FastGPT智能客服搭建：集成外部工具"},{"id":786566,"t":"24｜FastGPT私有部署"},{"id":786567,"t":"25｜FastGPT接入云端：Azure + ChatGLM"},{"id":786570,"t":"26｜FastGPT接入本地大模型：ChatGLM3"},{"id":786571,"t":"27｜FastGPT接入本地大模型：详细配置"},{"id":786587,"t":"28｜AutoGen框架介绍"},{"id":786590,"t":"29｜AutoGen基础环境安装"},{"id":786591,"t":"30｜AutoGen基本使用介绍"},{"id":786596,"t":"31｜AutoGen模型配置以及场景演示"},{"id":786606,"t":"32｜AutoGen添加自定义技能"},{"id":786608,"t":"33｜AutoGen基于外部API创建技能"},{"id":786609,"t":"34｜AutoGen集成API平台"},{"id":786611,"t":"35｜AutoGen API接口转换为技能"},{"id":786612,"t":"36｜AutoGen特定业务场景下的智能工作流"},{"id":786613,"t":"37｜AutoGen多智能体协作演示"},{"id":786623,"t":"38｜AutoGen搭建多智能体团队为你工作"},{"id":786625,"t":"39｜AutoGen工作流接入实际业务应用：实战演示"},{"id":786626,"t":"40｜AutoGen工作流接入实际业务应用：详细配置"},{"id":786674,"t":"41｜手把手带你本地部署大模型"},{"id":786676,"t":"42｜手工下载大模型"},{"id":786678,"t":"43｜接入本地部署大模型"},{"id":786679,"t":"44｜RAG基本工作原理介绍"},{"id":786680,"t":"45｜接入本地知识库"},{"id":786681,"t":"46｜RAG技能添加"},{"id":786682,"t":"47｜GPU服务器部署大模型"},{"id":786684,"t":"48｜HuggingFace模型百倍速下载"},{"id":786686,"t":"49｜模型微调：手把手带你微调ChatGLM3"},{"id":786687,"t":"50｜模型微调：导出并应用训练后的ChatGLM模型"},{"id":786677,"t":"51｜DB-GPT介绍"},{"id":786688,"t":"52｜DB-GPT环境安装"},{"id":786689,"t":"53｜DB-GPT Excel对话"},{"id":786690,"t":"54｜DB-GPT数据库对话"},{"id":786691,"t":"55｜DB-GPT图表统计"},{"id":786693,"t":"56｜DB-GPT多智能体协作"}]},{"id":100768201,"n":"AI Excel从入门到实战","a":"张海航","f":true,"c":16,"p":16,"l":[{"id":778171,"t":"开篇词  |  在Excel数字世界中探索AI奥秘，打开提效大门！"},{"id":778172,"t":"01  |  Excel基础介绍"},{"id":778178,"t":"02  |  公式与函数"},{"id":778173,"t":"03  |  数据透视表与图表"},{"id":778176,"t":"04  |  人工智能基础与技术简介"},{"id":779588,"t":"05  |  AI技术在Excel中的工具概览"},{"id":779590,"t":"06  |  AI技术在Excel中的应用全景图"},{"id":779591,"t":"07  |  跨表格数据处理"},{"id":779594,"t":"08  |  数据分析与预测"},{"id":779595,"t":"09  |  自动化处理与优化"},{"id":782618,"t":"10  |  文本分析与图像识别"},{"id":782619,"t":"11  |  案例一：销售数据分析与预测"},{"id":782620,"t":"12  |  案例二：自动化报表生成"},{"id":785159,"t":"13  |  案例三：文本情感分析"},{"id":785161,"t":"14  |  案例四：图像识别与处理"},{"id":785162,"t":"15  |  课程总结与展望"}]},{"id":100769901,"n":"AI PPT创作实战课","a":"小6","f":true,"c":24,"p":24,"l":[{"id":782593,"t":"开篇词｜AI赋能，开启高效、创意的AI PPT创作之旅！"},{"id":782594,"t":"01｜ AI与PPT设计概述"},{"id":782595,"t":"02｜ PPT设计基本原则"},{"id":782598,"t":"03｜ PPT设计的AI工具推荐"},{"id":784447,"t":"04｜ AI在PPT中设计的注意事项"},{"id":784448,"t":"05｜ AI一键生成PPT模板"},{"id":785960,"t":"06｜ AI辅助内容创建与优化"},{"id":787911,"t":"07｜ AI辅助色彩与字体选择"},{"id":789104,"t":"08｜ AI智能布局与排版"},{"id":790302,"t":"09｜ AI处理多媒体图像（上）"},{"id":790839,"t":"09｜ AI处理多媒体图像（下）"},{"id":791350,"t":"10｜ AI设计交互式元素"},{"id":792522,"t":"11｜ 数据可视化的AI应用"},{"id":793515,"t":"12｜文件一键转换PPT"},{"id":793960,"t":"13｜AI插件高级优化PPT技巧"},{"id":794397,"t":"14｜AI设计定制化专业PPT"},{"id":794822,"t":"15｜AI辅助多语言PPT设计"},{"id":795406,"t":"16｜多平台PPT设计与适配"},{"id":796064,"t":"17｜AI创意动画与效果切换"},{"id":796863,"t":"18｜AI自动生成适配PPT的演讲稿"},{"id":796923,"t":"19｜AI在PPT反馈信息收集中的应用"},{"id":797635,"t":"20｜经典实战案例分析"},{"id":797863,"t":"21｜进阶实战案例分析"},{"id":797864,"t":"结束语｜展望未来，AI赋能下的无限可能"}]},{"id":100779801,"n":"AIGC如何加速企业数智化进程","a":"周健","f":false,"c":8,"p":8,"l":[{"id":788008,"t":"01 | 世界已经进入新的AI时代"},{"id":788010,"t":"02 | AIGC基本概念与原理"},{"id":787987,"t":"03 | 生成式AI已显现出通用人工智能的雏形"},{"id":787989,"t":"04 | 生成式AI在企业中的应用场景"},{"id":787990,"t":"05 | GenAI时代下企业数智化转型战略框架"},{"id":787992,"t":"06 | 企业如何根据自身业务需求构建自己的模型"},{"id":787993,"t":"07 | SaaS vs 开源 vs 私有化模型之间的优劣势对比"},{"id":788007,"t":"08 | 企业AIGC战略落地的框架与关键要素"}]},{"id":100768001,"n":"AI原生应用入门课","a":"李梦冉/程默","f":true,"c":12,"p":12,"l":[{"id":776319,"t":"01｜AI能力：大模型时代下职场人面临的新挑战"},{"id":776321,"t":"02｜对比：传统大模型应用开发范式 VS AI原生应用开发新范式"},{"id":776322,"t":"03｜Prompt工程必知必会：从入门到进阶掌握必备技巧"},{"id":776323,"t":"04｜RAG必知必会：初探RAG工作原理与调优技巧"},{"id":776326,"t":"05｜Agent必知必会：Agent+工具=业务场景可用性"},{"id":776327,"t":"06｜零代码/低代码态开发技巧：玩转内置模版攻略"},{"id":776328,"t":"07｜代码态开发技巧：搞定原子能力+Assistant+端到端应用3种开发范式"},{"id":776330,"t":"08｜拆解：如何根据自己的业务设计自己的 AI 应用"},{"id":776333,"t":"09｜教育场景类案例解析：怎么做一个益智游戏&拍照答题助手？"},{"id":776334,"t":"10｜效率工具类案例解析：怎么做一款智能文档问答工具？"},{"id":776335,"t":"11｜RAG类应用案例解析：怎么做一个“民法典助手”？"},{"id":776336,"t":"12｜多模态应用案例解析：怎么搞定更复杂的业务场景需求？"}]},{"id":100625601,"n":"AI大模型企业应用实战","a":"蔡超","f":true,"c":23,"p":23,"l":[{"id":711588,"t":"课程介绍"},{"id":711601,"t":"内容综述"},{"id":711617,"t":"01 | 第一个大模型程序：Hello GPT"},{"id":711690,"t":"02｜提示词技巧：获得代码友好的回复"},{"id":711805,"t":"03 | 初识LangChain：你的瑞士军刀"},{"id":711843,"t":"04｜保持会话状态：让Chatbot获得记忆"},{"id":714024,"t":"05 | 对话启发式UI：交互方式的新思考"},{"id":717796,"t":"06 | Function Calling：让GPT学会使用工具"},{"id":714025,"t":"07｜LangChain Agent：让GPT学会使用工具"},{"id":717797,"t":"08｜In-context learning：学习解决特定任务"},{"id":717798,"t":"09｜ReAct模式：构建自己的AutoGPT"},{"id":717819,"t":"10｜文本分片及向量化：让大模型应用企业内部数据"},{"id":717820,"t":"11｜LangChain Retrieval：连接大模型和内部文本"},{"id":717821,"t":"12｜整合所学：构建多模态Chatbot"},{"id":719698,"t":"13｜研发全过程中的应用：硅基工程师诞生"},{"id":719699,"t":"14｜代码生成：解决代码生成的依赖性并增强确定性"},{"id":719701,"t":"15｜有效利用LLM开发：编写大模型友好的代码"},{"id":719702,"t":"16｜云原生部署任务实践：让你成为更好的DevOps工程师"},{"id":719703,"t":"17｜HuggingFace与Pre-trained Model：借助AI社区的力量"},{"id":719704,"t":"18｜架构展望：集成大模型的应用参考架构"},{"id":740138,"t":"直播回放｜Semantic-Kernel大模型开发实战"},{"id":719705,"t":"结束语｜道阻且长，行则将至"},{"id":722217,"t":"结课测试｜来赴一场满分之约吧！"}]},{"id":100633001,"n":"AI应用实战课","a":"黄佳","f":true,"c":25,"p":25,"l":[{"id":723514,"t":"课程介绍｜成为AI Native个体"},{"id":723519,"t":"01｜理论：监督学习、无监督学习、强化学习"},{"id":723535,"t":"02｜实战：如何使用Jupyter Notebook？"},{"id":723536,"t":"03｜工具：机器学习框架scikit-learn"},{"id":723537,"t":"04｜理论：AI项目实战5大环节"},{"id":723541,"t":"05｜实战：预测直播带货销售额"},{"id":723639,"t":"06｜探索数据中蕴含的故事和商机"},{"id":723641,"t":"07｜工具：Matplotlib和Seaborn"},{"id":723642,"t":"08｜实战：医疗数据集大揭秘"},{"id":723646,"t":"09｜各种各样的回归算法"},{"id":723648,"t":"10｜实战：通过回归模型预测电商用户的生命周期价值（LTV）"},{"id":723651,"t":"11｜分类算法：非常广泛的AI应用场景"},{"id":723652,"t":"12｜实战：通过分类算法辅助疾病诊断"},{"id":723655,"t":"13｜理论：聚类算法的核心原理"},{"id":723656,"t":"14｜实战：通过RFM值给用户画像"},{"id":723657,"t":"15｜降维算法能用来做什么？"},{"id":723658,"t":"16｜实战：通过降维算法做商品的品类分析"},{"id":723661,"t":"17｜大数据和GPU时代的深度学习"},{"id":723662,"t":"18｜工具：Pytorch深度学习框架"},{"id":723664,"t":"19｜实战：用CNN网络做图像分类"},{"id":723665,"t":"20｜实战：用RNN做时序预测"},{"id":723666,"t":"21｜横空出世的大语言模型"},{"id":723667,"t":"22｜工具：大语言模型开发框架LangChain"},{"id":723669,"t":"23｜实战：构建基于垂直行业内部文档的问答系统"},{"id":729073,"t":"结束语 & 结课测试"}]},{"id":100769301,"n":"AI数据分析课","a":"尹会生","f":true,"c":34,"p":34,"l":[{"id":777353,"t":"开篇词｜AIGC时代，数据分析可以很简单"},{"id":777362,"t":"01｜数据分析入门：从掌握基础流程开始"},{"id":777364,"t":"02｜大模型基础：掌握核心原理，知其所以然"},{"id":777365,"t":"03｜Prompt提示词：与大模型交互的主要方式"},{"id":777366,"t":"04｜让大模型替你干活：数据清洗之自动识别数据格式与纠正异常"},{"id":779806,"t":"05｜让大模型帮你干活：数据清洗之处理数据存储形式不一致"},{"id":779807,"t":"06｜AI工具：不用手写代码，让大模型帮你搞定爬虫"},{"id":779808,"t":"07｜让大模型扮演教练教你SQL基础：学会数据提取、查询与管理"},{"id":780500,"t":"08｜让大模型扮演你的数据分析专家：跨越通用方法的障碍"},{"id":780502,"t":"09｜数据探索：用和大模型交互的方式做探索性数据分析"},{"id":780505,"t":"10｜让大模型为你绘图：利用ChatGPT创建直观且有洞察力的图表"},{"id":782514,"t":"11｜让大模型提升你的叙事技巧：ChatGP帮助你打造更有说服力的数据报告"},{"id":782557,"t":"12｜数据导入及清洗：ChatGPT在数据处理过程中的完整应用（上）"},{"id":782586,"t":"13｜数据分析及展示：ChatGPT在数据处理过程中的完整应用（下）"},{"id":782752,"t":"14｜预测与优化：ChatGPT在数据驱动决策中的综合应用（上）"},{"id":782768,"t":"15｜预测与优化：ChatGPT在数据驱动决策中的综合应用（下）"},{"id":785098,"t":"16｜战略咨询新伙伴：ChatGPT在SWOT与PEST分析中的实用性"},{"id":785130,"t":"17｜用户洞察全面探索：ChatGPT在用户行为分析中的应用"},{"id":785136,"t":"18｜数据驱动的产品策略：利用ChatGPT优化产品生命周期"},{"id":785201,"t":"19｜构建知识库：利用Coze通过自然语言查询数据（上）"},{"id":785210,"t":"20｜深度优化：为Coze知识库实现更准确的数据查询（中）"},{"id":790991,"t":"21｜联网与实时更新：利用技能模块为Coze知识库提高查询准确性（下）"},{"id":790998,"t":"22｜打造专属助手：利用OpenAI Playground构建可控的数据分析工具"},{"id":792593,"t":"23｜对话智能：使用OpenAI Assistants构建支持文件搜索的机器人"},{"id":794469,"t":"24｜全面联网：三种方式让ChatGPT接入网络，提高回答精度"},{"id":794693,"t":"25｜自动化数据处理：利用AgentGPT进行数据任务拆解与分析"},{"id":794695,"t":"26｜数据一体化：集成不同来源的数据资产，打造统一数据湖支持大模型分析"},{"id":796093,"t":"27｜云上构建：利用云计算的弹性和可扩展性，构建高性能的大模型数据分析平台"},{"id":796976,"t":"28｜数据保密：利用ChatGPT实现数据脱敏和匿名化"},{"id":797137,"t":"29｜数据伦理与隐私保护：确保数据使用的道德与合法性"},{"id":798123,"t":"30｜工具扩展：利用GPT-4o模型识别文字与图像"},{"id":798131,"t":"31｜资讯获取：怎样获取第一手的AI数据分析资讯？"},{"id":798665,"t":"32｜未来展望：探讨大语言模型在数据分析中的发展方向和创新应用"},{"id":798666,"t":"结束语｜插上AI工具的羽翼，开启你的数据分析之旅"}]},{"id":100768401,"n":"AI智能办公实战课","a":"李晓华","f":true,"c":23,"p":23,"l":[{"id":778445,"t":"课程介绍"},{"id":778340,"t":"01｜来龙去脉：AIGC发展历程及国内外发展现状"},{"id":778341,"t":"02｜模型原理：深度学习是如何在大模型中起作用的？"},{"id":778895,"t":"03｜Prompt 对话技巧：如何精准地向大模型提问？"},{"id":781880,"t":"04｜文案生成与优化：AI如何赋能新媒体写作？"},{"id":781881,"t":"05｜汇报与总结：AI如何生成各种类型的报告？"},{"id":781882,"t":"06｜外文资料看不懂？AI来帮你！"},{"id":783522,"t":"07｜WPS 在线版 AI 的应用"},{"id":783523,"t":"08｜智能函数计算：AI如何帮助我们解决数据繁琐等难题？"},{"id":785643,"t":"09｜AI 辅助 Excel 高效办公，轻松驾驭 VBA 批量处理表格"},{"id":790333,"t":"10｜可视化：如何通过 AI 实现可视化图表？"},{"id":797041,"t":"11｜如何通过 AI 提炼汇报内容？"},{"id":797043,"t":"12｜如何用 AI 快速生成PPT？"},{"id":797044,"t":"13｜如何用 AI 制作 PPT 背景音乐？"},{"id":797045,"t":"14｜如何用AI生成演讲稿？"},{"id":797046,"t":"15｜图片创作：如何运用 AI 进行图片创作？"},{"id":797047,"t":"16｜视频生成：如何运用 AI 生成宣传片和短视频？"},{"id":798395,"t":"17｜思维导图：如何运用 AI 构建思维导图创建头脑风暴？"},{"id":798400,"t":"18｜邮件自动化处理：如何快速写邮件并进行批量化处理？"},{"id":804361,"t":"19｜如何利用 AI 工具生成营销策划方案？"},{"id":804362,"t":"20｜AI 如何助力销售与商务谈判？"},{"id":804363,"t":"21｜AI 如何赋能自媒体运营？"},{"id":804364,"t":"22｜AI 辅助广告宣传设计，效率UP UP！"}]},{"id":100767501,"n":"AI绘画创作入门课","a":"西瓜","f":true,"c":24,"p":24,"l":[{"id":777015,"t":"开篇词｜探索艺术的新边界：Midjourney与Stable Diffusion的创新融合"},{"id":777017,"t":"01｜探索AI绘画世界：Midjourney入门指南"},{"id":777018,"t":"02｜云端之旅：Stable Diffusion快速部署攻略"},{"id":777019,"t":"03｜本地部署与个性化设置：Stable Diffusion深度解析"},{"id":777020,"t":"04｜文本的力量：打造高效Prompt"},{"id":777875,"t":"05（上）｜Midjourney指令大全：文本生成图像的秘籍"},{"id":777876,"t":"05（下）｜Midjourney指令大全：文本生成图像的秘籍"},{"id":777877,"t":"06｜艺术风格的探索之旅：Midjourney图生图技巧"},{"id":777878,"t":"07｜Stable Diffusion模型大观：选择与安装"},{"id":777883,"t":"08｜Stable Diffusion图像生成：从文本到画面"},{"id":780292,"t":"09｜图像再创造：Stable Diffusion进阶应用"},{"id":780293,"t":"10｜细节至上：Stable Diffusion三种局部编辑技巧"},{"id":780294,"t":"11｜作品升级：图像高清放大技术"},{"id":780295,"t":"12｜创意插画与头像：艺术风格创作"},{"id":781715,"t":"13｜IP形象设计：角色三视图创作"},{"id":781716,"t":"14｜艺术海报设计：视觉传达的艺术"},{"id":781721,"t":"15｜产品设计：从概念到实现"},{"id":781723,"t":"16（上）｜AI辅助绘本设计：从创意构思到成品实现"},{"id":781725,"t":"16（下）｜AI辅助绘本设计：从创意构思到成品实现"},{"id":783676,"t":"17｜AI光影文字教程：光影与文字的艺术结合"},{"id":783677,"t":"18｜品牌标识设计：个性化Logo创作"},{"id":783682,"t":"19｜风格与参数的深度应用：图像氛围调整"},{"id":783678,"t":"20｜AI绘画版权问题"},{"id":784658,"t":"21｜ 商业化路径：如何将AI绘画作品变现？"}]},{"id":100768301,"n":"AI音视频创作入门课","a":"唐子轩","f":true,"c":22,"p":22,"l":[{"id":776927,"t":"课程介绍｜音视频创作：开启AI时代下半场的钥匙"},{"id":776928,"t":"01｜ AI音视频创作工作流认知：技术路线初探与案例"},{"id":776929,"t":"02｜图像类AI工程化探索：ComfyUI的介绍与安装"},{"id":777055,"t":"03｜人人都是音乐家：声音设计与AI音频技术初探"},{"id":777802,"t":"04｜AI音视频生成工作流程（一）：剧本创作"},{"id":777803,"t":"05｜AI音视频生成工作流程（二）：分镜创作关键帧生成"},{"id":777804,"t":"06｜AI音视频生成工作流程（三）：视频片段生成"},{"id":777805,"t":"07｜AI音视频生成工作流程（四）：声音设计的音效匹配"},{"id":777806,"t":"08｜AI音视频生成工作流程（五）：剪辑与成片"},{"id":780304,"t":"09｜Stable Diffusion的工作原理解析"},{"id":780305,"t":"10｜Stable Diffusion ComfyUI基础工作流搭建实操"},{"id":780306,"t":"11｜SD ComfyUI提示词技巧"},{"id":780307,"t":"12｜ComfyUI视觉关键帧生成工作流及相关节点实操"},{"id":781895,"t":"13｜ComfyUI局部修复及相关节点实操"},{"id":781896,"t":"14｜ComfyUI+AnimateDiff+PrompTravel基础视频工作流与相关节点实操"},{"id":781897,"t":"15｜ComfyUI+AnimateDiff+ControlNet视频生成工作流"},{"id":781898,"t":"16｜ComfyUI+AnimateDiff+IPAdapter视频生成工作流"},{"id":783127,"t":"17｜Stable Diffusion+LcLight+BrushNet+Runway完成动态产品图"},{"id":783128,"t":"18｜Stable Diffusion+Deforum AI带你瞬息全宇宙"},{"id":783129,"t":"19｜Stable Diffusion+SVD创作古诗视频"},{"id":783130,"t":"20｜ComfyUI+AnimateDiff折纸风格化转绘"},{"id":783132,"t":"结束语｜AI时代的底层逻辑，人类与AI的共生协同"}]},{"id":100548001,"n":"B端产品经理入门课","a":"董小圣","f":true,"c":12,"p":12,"l":[{"id":654476,"t":"01｜开篇：B端产品，下一个十年的统治者"},{"id":655617,"t":"02｜出发原点：深度理解B端产品本质"},{"id":655641,"t":"03｜工作特征：B端产品经理如何设计产品？"},{"id":655642,"t":"04｜能力模型：优秀B端产品经理能力全图"},{"id":655643,"t":"05｜行业趋势：全局视角分析，看透B端产品大周期"},{"id":655644,"t":"06｜行业分析：实用技巧快速了解新行业"},{"id":655645,"t":"07｜专业工具：大壮创业故事，解析B端产品4+1专业工具"},{"id":655646,"t":"08｜产品价值：系统分析，挖掘产品价值点"},{"id":655647,"t":"09｜产品方案：“好产品”八大要素"},{"id":655648,"t":"10｜设计要素：专业B端产品经理如何避免设计事故？"},{"id":655650,"t":"11｜项目管理：能设计能落地，复杂场景推进实施案例"},{"id":655651,"t":"12｜职业破局：主动规划，画出自己高光的“职业生涯曲线”"}]},{"id":100760301,"n":"Coze：零基础开发对话机器人","a":"郭旭","f":true,"c":54,"p":54,"l":[{"id":768554,"t":"课程介绍"},{"id":768555,"t":"01｜主页对话框"},{"id":768556,"t":"02｜个人空间"},{"id":768558,"t":"03｜Bot 商店"},{"id":768559,"t":"04｜插件商店"},{"id":768561,"t":"05｜团队空间"},{"id":768564,"t":"06｜查询天气机器人的最终效果"},{"id":768565,"t":"07｜创建你的第一个机器人"},{"id":768587,"t":"08｜用自然语言优化输出结果"},{"id":768589,"t":"09｜用工作流优化输出结果"},{"id":768590,"t":"10｜发布机器人到豆包"},{"id":770839,"t":"加餐｜解决天气查询机器人星期几会混乱的问题"},{"id":770607,"t":"11｜知识库效果展示"},{"id":770608,"t":"12｜导入 txt、PDF 和 Word"},{"id":770609,"t":"13｜导入网页内容（自动采集）"},{"id":770610,"t":"14｜导入网页内容（手动采集）"},{"id":770611,"t":"15｜导入 Notion 页面和数据库"},{"id":770612,"t":"16 | 导入飞书文档"},{"id":770613,"t":"17｜自定义文本内容"},{"id":770614,"t":"18｜导入 Excel"},{"id":770615,"t":"19｜导入 API（json 格式）"},{"id":770617,"t":"20｜导入飞书表格"},{"id":770618,"t":"21｜自定义表格内容"},{"id":771363,"t":"22｜卡片效果展示"},{"id":771364,"t":"23｜建立使用卡片的新闻机器人"},{"id":771365,"t":"24｜插件的作用"},{"id":771368,"t":"25｜可托管部署的代码插件"},{"id":771366,"t":"26｜无授权插件：获得一句名言"},{"id":771367,"t":"27｜Service 授权插件：用机器人发邮件"},{"id":773147,"t":"28｜工作流的作用"},{"id":773148,"t":"29｜节点的输入与输出"},{"id":773149,"t":"30｜大模型节点：自然语言变参数"},{"id":773150,"t":"31｜代码节点：根据参数做判断"},{"id":773152,"t":"32｜知识库节点：根据参数取数据"},{"id":773153,"t":"33｜选择器节点：不用代码也能做判断"},{"id":773154,"t":"34｜数据库节点：信息记录和查询"},{"id":773155,"t":"35｜插件节点：应答结果加名言"},{"id":773156,"t":"36｜工作流组合：让功能扩展变强大"},{"id":773195,"t":"37｜创建智能客服机器人"},{"id":773196,"t":"38｜完善机器人逻辑"},{"id":773197,"t":"39｜发布到飞书"},{"id":773198,"t":"40｜发布到微信客服"},{"id":773199,"t":"41｜发布到微信公众号（订阅号）"},{"id":773200,"t":"42｜发布到微信公众号（服务号）"},{"id":773201,"t":"43｜发布到掘金"},{"id":773202,"t":"44｜案例：生成情绪文案+配图"},{"id":773203,"t":"45｜案例：生成旅行目的地天气+游玩安排（上）"},{"id":773204,"t":"46｜案例：生成旅行目的地天气+游玩安排（中）"},{"id":773205,"t":"47｜案例：生成旅行目的地天气+游玩安排（下）"},{"id":783759,"t":"48｜工作流：选择器节点和变量节点"},{"id":783760,"t":"49｜Bot编辑界面：快捷指令"},{"id":783761,"t":"50｜Bot编辑界面：触发器"},{"id":783762,"t":"51｜知识库：照片知识库"},{"id":783763,"t":"52｜多Agent模式"}]},{"id":100117302,"n":"Excel-PowerBI 高级数据分析","a":"尹航","f":true,"c":15,"p":15,"l":[{"id":540080,"t":"00 | 先导篇"},{"id":540198,"t":"01 | PowerBI 所需要的电脑环境"},{"id":540204,"t":"02 | PowerBI 的组成"},{"id":540212,"t":"03 | 用Power Query导入Excel表并追加数据"},{"id":540219,"t":"04 | 用Power Query导入Access数据库和关系"},{"id":540222,"t":"05 | 数据挖掘"},{"id":540223,"t":"06 | 从网页导入数据表"},{"id":540224,"t":"07 | 加载 PowerPivot 和加载数据建立关系"},{"id":540226,"t":"08 | 加载数据模型后进行透视表分析"},{"id":540233,"t":"09 | 添加PowerView实现多图表联动（一）"},{"id":540240,"t":"10 | 添加PowerView实现多图表联动（二）"},{"id":540242,"t":"11 | PowerView实现多图表联动（三）"},{"id":540245,"t":"12 | 第1-2场景设计"},{"id":540247,"t":"13 | 第3-4场景设计和特效"},{"id":722991,"t":"结课测试｜EXCEL-PowerBI 高级数据分析"}]},{"id":100117328,"n":"Excel商业分析实战","a":"叶风哲","f":true,"c":21,"p":21,"l":[{"id":618533,"t":"01 | 商业分析对企业发展的重要作用"},{"id":618543,"t":"02 | 商业分析的思路"},{"id":618546,"t":"03 | 商业分析流程"},{"id":618547,"t":"04 | 商业分析相关工具"},{"id":618548,"t":"05 | 商业分析常用方法及对应行业场景"},{"id":618550,"t":"06 | 数据分析指标体系搭建的关键术语"},{"id":618551,"t":"07 | 用户维度下的指标体系搭建"},{"id":618554,"t":"08 | 产品维度下的指标体系搭建"},{"id":618555,"t":"09 | 运营维度下的指标体系搭建"},{"id":618556,"t":"10 | 金融业务场景中的指标体系"},{"id":618579,"t":"11 | 零售业务场景中的指标体系"},{"id":618580,"t":"12 | 制造业务场景中的指标体系"},{"id":618581,"t":"13 | 商业分析报告撰写要求与技巧"},{"id":618582,"t":"14 | Excel 可视化功能在商业分析报告撰写中的应用"},{"id":618583,"t":"15 | 金融行业商业分析案例：信贷逾期分析"},{"id":618584,"t":"16 | 金融行业商业分析案例：风控策略分析"},{"id":618585,"t":"17 | 金融行业商业分析案例：金融第三方支付案例分析"},{"id":618586,"t":"18 | 零售行业商业分析案例：人货场分析"},{"id":618587,"t":"19 | 零售行业商业分析案例：业务问题剖析"},{"id":618588,"t":"20 | 制造行业商业分析案例：思路解析"},{"id":618589,"t":"21 | 制造行业商业分析案例：数据实操"}]},{"id":100117329,"n":"Excel数据可视化实战","a":"王忠超","f":true,"c":38,"p":38,"l":[{"id":619206,"t":"先导篇"},{"id":618699,"t":"01 | 数据分析的流程"},{"id":619083,"t":"02 | Excel数据可视化的工具"},{"id":618701,"t":"03 | 数据规范化的三大工具"},{"id":618738,"t":"04 | 数据清洗工具（一）数据清洗的利器-Power Query"},{"id":619079,"t":"05 | 数据清洗工具（二）用Power Query实现数据规范"},{"id":619081,"t":"06 | 数据清洗工具（三）数据结构调整"},{"id":619084,"t":"07 | 用条件格式实现提醒预警（一）条件格式突出显示"},{"id":619086,"t":"08 | 用条件格式实现提醒预警（二）条件格式三大可视化工具"},{"id":619087,"t":"09 | 双轴线柱组合图：同比环比分析图表"},{"id":619089,"t":"10 | 图片柱形图：产品图片层叠嵌入"},{"id":619090,"t":"11 | 直方图：客户订单数据分区间频次统计"},{"id":619091,"t":"12 | 帕累托图：客户TOP 5订单收入统计"},{"id":619092,"t":"13 | 散点图气泡图：市场占有率和市场容量图"},{"id":619093,"t":"14 | 仪表板：销售关键绩效指标KPI呈现"},{"id":619096,"t":"15 | 迷你图表：多只股票月度年度价格变化趋势"},{"id":619098,"t":"16 | 旋风条形图：公司财务指标对比图"},{"id":619099,"t":"17 | 复合饼图：费用项目先总后分"},{"id":619101,"t":"18 | 瀑布图：利润表从收入到净利润的变化过程"},{"id":619103,"t":"19 | 动态标记费用超标数据"},{"id":619105,"t":"20 | 按指定月份显示子公司财务指标"},{"id":619108,"t":"21 | 按指定月份批量显示子公司业务数据"},{"id":619123,"t":"22 | 按指定月份显示区间内销售数据"},{"id":619125,"t":"23 | 从复选框选择不同产品实现对比呈现"},{"id":619129,"t":"24 | 自动标记年度股票价格最高点与最低点"},{"id":619136,"t":"25 | 四象限矩阵图：不同门店分区域不同策略管理"},{"id":619137,"t":"26 | 动态盈亏平衡图：投资项目量本利分析"},{"id":619148,"t":"27 | 投资项目敏感性分析图"},{"id":619152,"t":"28 | 数据透视图：多维度动态统计呈现"},{"id":619153,"t":"29 | 动态仪表板：多个透视图表交互呈现"},{"id":619154,"t":"30 | 数据建模（一）认识数据模型Power Pivot"},{"id":619158,"t":"31 | 数据建模（二）销售数据建模"},{"id":619162,"t":"32 | 数据建模（三）超级透视图"},{"id":619163,"t":"33 | 经营管理实战驾驶舱（一）销售管理"},{"id":619164,"t":"34 | 经营管理实战驾驶舱（二）运营管理"},{"id":619166,"t":"35 | 经营管理实战驾驶舱（三）金融投资管理"},{"id":619167,"t":"36 | 经营管理实战驾驶舱（四）仓储物流管理"},{"id":619169,"t":"37 | 表单控件设置"}]},{"id":100058801,"n":"Flink核心技术与实战","a":"张利兵","f":true,"c":91,"p":91,"l":[{"id":278249,"t":"01 | 课程介绍"},{"id":278252,"t":"02 | 内容综述"},{"id":278253,"t":"03 | 流处理技术概览"},{"id":278255,"t":"04 | Flink发展历史与应用场景"},{"id":278256,"t":"05 | Flink核心特性"},{"id":278257,"t":"06 | Flink集群架构"},{"id":278258,"t":"07 | Flink集群运行模式"},{"id":278259,"t":"08 | Flink集群资源管理器支持"},{"id":281848,"t":"09 | Standalone原理讲解与实操演示"},{"id":281845,"t":"10 | Flink On Yarn部署讲解"},{"id":281855,"t":"11 | Flink On Yarn实操演示"},{"id":281856,"t":"12 | Flink On Kubernetes部署讲解"},{"id":281857,"t":"13 | Flink On Kubernetes实操：Session模式"},{"id":284062,"t":"14 | Flink On Kubernetes实操：Per-job模式"},{"id":284063,"t":"15 | Flink On Kubernetes Native部署讲解"},{"id":284064,"t":"16 | Flink On Kubernetes Native实操演示"},{"id":284065,"t":"17 | Flink高可用配置原理讲解"},{"id":284060,"t":"18 | Flink高可用配置实操演示"},{"id":287037,"t":"19 | 分布式流处理模型"},{"id":287038,"t":"20 | DataStream API实践原理"},{"id":287039,"t":"21 | Flink时间概念"},{"id":287040,"t":"22 | Watermark实践原理"},{"id":287041,"t":"23 | Watermark与Window的关系"},{"id":289852,"t":"24 | Watermark Generator"},{"id":289853,"t":"25 | Windows窗口计算"},{"id":289854,"t":"26 | Window Assigner"},{"id":289855,"t":"27 | Window Trigger"},{"id":289856,"t":"28 | Window Evictors"},{"id":292574,"t":"29 | Window Function"},{"id":292575,"t":"30 | Windows多流合并"},{"id":292576,"t":"31 | Process Function应用"},{"id":292577,"t":"32 | SideOutput旁路输出"},{"id":292578,"t":"33 | Asynchronous I/O异步操作"},{"id":292587,"t":"34 | Pipeline与StreamGraph转换"},{"id":293870,"t":"35 | Flink类型系统"},{"id":293871,"t":"36 | 自定义SourceFunction"},{"id":293873,"t":"37 | 项目实战：基于DataStream API实现PV，UV统计"},{"id":293874,"t":"38 | 有状态计算概念"},{"id":296572,"t":"39 | 状态类型及应用"},{"id":296573,"t":"40 | KeyedState介绍与使用"},{"id":296574,"t":"41 | OperatorState介绍与使用"},{"id":296575,"t":"42 | BroadcastState介绍与使用"},{"id":296576,"t":"43 | Checkpoint实现原理"},{"id":298920,"t":"44 | Savepoint与Checkpoint"},{"id":298921,"t":"45 | StateBackends状态管理器"},{"id":298922,"t":"46 | State Schema Evolution"},{"id":298923,"t":"47 | State序列化与反序列化"},{"id":298924,"t":"48 | Queryable State介绍与使用"},{"id":301772,"t":"49｜项目实战：实时交易反欺诈项目介绍"},{"id":301773,"t":"50｜项目实战：实时交易反欺诈项目演示"},{"id":301774,"t":"51｜Flink Table API/SQL介绍与使用"},{"id":301775,"t":"52｜Table API/SQL核心概念"},{"id":301776,"t":"53｜DataStream & DataSet 与Table相互转换"},{"id":304670,"t":"54｜Table Connector介绍与使用"},{"id":304671,"t":"55｜Querying Dynamic  Tables"},{"id":304672,"t":"56｜TimeStamp与Watermark时间属性定义"},{"id":304673,"t":"57｜Query  With Temporal Condition"},{"id":304674,"t":"58｜Join  With Dynamic  Table"},{"id":306921,"t":"59｜Join With Temporal Function"},{"id":306922,"t":"60｜Join With Temporal Tables"},{"id":306923,"t":"61｜Catalog原理与使用"},{"id":306924,"t":"62｜Apache Hive集成"},{"id":306925,"t":"63｜SQL Client介绍与使用"},{"id":310222,"t":"64｜Flink SQL Table数据类型"},{"id":310223,"t":"65｜自定义Function"},{"id":310226,"t":"66｜Table Connector使用"},{"id":310227,"t":"67｜自定义Connector"},{"id":310228,"t":"68｜new tablesource & tablesink api"},{"id":310938,"t":"69｜项目实战：基于Flink SQL实现Top10商品统计"},{"id":310939,"t":"70｜Runtime整体架构"},{"id":310950,"t":"71｜Flink Client实现原理"},{"id":310956,"t":"72｜ResourceManager资源管理"},{"id":310958,"t":"73｜Dispatcher任务分发器"},{"id":317000,"t":"74｜JobGraph提交与运行（上）"},{"id":319020,"t":"75｜JobGraph提交与运行（下）"},{"id":319021,"t":"76｜Task执行与调度"},{"id":319023,"t":"77｜Task重启和容错策略"},{"id":319024,"t":"78｜集群组件RPC通信机制"},{"id":321946,"t":"79｜NetworkStatck实现原理"},{"id":321947,"t":"80｜Flink内存管理"},{"id":321948,"t":"81｜Metric指标分类与采集"},{"id":321949,"t":"82｜Flink REST API介绍与使用"},{"id":321951,"t":"83｜Checkpoint监控与调优"},{"id":324877,"t":"84｜反压监控与原理"},{"id":324878,"t":"85｜Flink内存配置与调优"},{"id":324879,"t":"86｜PyFlink实践与应用"},{"id":324881,"t":"87｜Flink复杂事件处理：Complex event process"},{"id":324882,"t":"88｜Alink机器学习框架介绍与使用"},{"id":327899,"t":"89｜Stateful Function介绍与使用"},{"id":327900,"t":"90｜实时推荐系统项目设计与实现"},{"id":327901,"t":"91｜结束语"}]},{"id":100024001,"n":"Go语言从入门到实战","a":"蔡超","f":true,"c":55,"p":55,"l":[{"id":84335,"t":"01 | Go语言课程介绍"},{"id":84354,"t":"02 | 内容综述"},{"id":84355,"t":"03 | Go语言简介：历史背景、发展现状及语言特性"},{"id":84356,"t":"04 | 编写第一个Go程序"},{"id":84357,"t":"05 | 变量、常量以及与其他语言的差异"},{"id":84358,"t":"06 | 数据类型"},{"id":84359,"t":"07 | 运算符"},{"id":84360,"t":"08 | 条件和循环"},{"id":84361,"t":"09 | 数组和切片"},{"id":84629,"t":"10 | Map声明、元素访问及遍历"},{"id":84630,"t":"11 | Map与工厂模式，在Go语言中实现Set"},{"id":85348,"t":"12 | 字符串"},{"id":85350,"t":"13 | Go语言的函数"},{"id":85466,"t":"14 | 可变参数和defer"},{"id":85465,"t":"15 | 行为的定义和实现"},{"id":85770,"t":"16 | Go语言的相关接口"},{"id":85776,"t":"17 | 扩展与复用"},{"id":85777,"t":"18 | 不一样的接口类型，一样的多态"},{"id":85953,"t":"19 | 编写好的错误处理"},{"id":85954,"t":"20 | panic和recover"},{"id":85955,"t":"21 | 构建可复用的模块（包）"},{"id":85956,"t":"22 | 依赖管理"},{"id":86799,"t":"23 | 协程机制"},{"id":86537,"t":"24 | 共享内存并发机制"},{"id":86538,"t":"25 | CSP并发机制"},{"id":86539,"t":"26 | 多路选择和超时"},{"id":86540,"t":"27 | channel的关闭和广播"},{"id":85957,"t":"28 | 任务的取消"},{"id":85958,"t":"29 | Context与任务取消"},{"id":86541,"t":"30 | 只运行一次"},{"id":86544,"t":"31 | 仅需任意任务完成"},{"id":86545,"t":"32 | 所有任务完成"},{"id":87730,"t":"33 | 对象池"},{"id":87731,"t":"34 | sync.pool对象缓存"},{"id":87732,"t":"35 | 单元测试"},{"id":87733,"t":"36 | Benchmark"},{"id":87734,"t":"37 | BDD"},{"id":87797,"t":"38 | 反射编程"},{"id":88531,"t":"39 | 万能程序"},{"id":88539,"t":"40 | 不安全编程"},{"id":88542,"t":"41 | 实现pipe-filter framework"},{"id":88543,"t":"42 | 实现micro-kernel framework"},{"id":88544,"t":"43 | 内置JSON解析"},{"id":88545,"t":"44 | easyjson"},{"id":88546,"t":"45 | HTTP服务"},{"id":91446,"t":"46 | 构建RESTful服务"},{"id":91253,"t":"47 | 性能分析工具"},{"id":91255,"t":"48 | 性能调优示例"},{"id":91258,"t":"49 | 别让性能被锁住"},{"id":91261,"t":"50 | GC友好的代码"},{"id":91264,"t":"51 | 高效字符串连接"},{"id":91265,"t":"52 | 面向错误的设计"},{"id":91270,"t":"53 | 面向恢复的设计"},{"id":91299,"t":"54 | Chaos Engineering"},{"id":91302,"t":"55 | 结课测试&结束语"}]},{"id":100085801,"n":"HarmonyOS快速入门与实战","a":"QCon+案例研习社","f":true,"c":9,"p":9,"l":[{"id":411604,"t":"01｜如何快速上手HarmonyOS实践？"},{"id":412101,"t":"02｜宝宝巴士：HarmonyOS如何让亲子互动更有趣？"},{"id":412117,"t":"03｜宝宝巴士：全场景分布式的亲子乐园是怎么实现的？"},{"id":412831,"t":"04｜如何用Cocos引擎开启你HarmonyOS游戏之旅？"},{"id":412834,"t":"05｜在线教育和小游戏在HarmonyOS上有什么解决方案？"},{"id":413770,"t":"06｜HarmonyOS是怎么让多设备融合成一个“超级终端”的？"},{"id":413771,"t":"07｜如何在HarmonyOS上做在线教育和游戏开发？"},{"id":414505,"t":"08｜商家直播：如何实现互动跨端迁移流转？"},{"id":414512,"t":"09｜商家直播：如何实现多设备协同的开播方案？"}]},{"id":100757801,"n":"Midjourney入门实践课","a":"Jovi","f":true,"c":24,"p":24,"l":[{"id":758975,"t":"01｜如何自建频道，添加 MJ 服务？"},{"id":758994,"t":"02｜Midjourney 初上手 - 基础操作"},{"id":758996,"t":"03｜Midjourney 模型及版本介绍"},{"id":758997,"t":"04｜什么是 Prompt？提四次的类型及使用技巧"},{"id":758998,"t":"05｜Midjourney 的订阅计划 Subscription plan"},{"id":758999,"t":"06｜Midjourney 账户信息的查看及说明"},{"id":759000,"t":"07｜不同的画面比例，不同的视觉冲击 --ar 详解"},{"id":759001,"t":"08｜情侣头像+漫画制作 --seed 详解"},{"id":759002,"t":"09｜要风格一致还是来点惊喜，AI 设计抽卡必备技能 --chaos 详解"},{"id":759003,"t":"10｜AI绘画去除不想要的物体 --no 详解"},{"id":759004,"t":"11｜写实摄影+配图插画+儿童绘本+表情包制作 --style 详解"},{"id":759005,"t":"12｜艺术海报+工艺画制作 --stylize 详解"},{"id":759006,"t":"13｜批量出图 --Repeat 详解"},{"id":759007,"t":"14｜面料纹理+壁纸背景图制作 --tile 详解"},{"id":759008,"t":"15｜画面质量控制？--Quality 详解"},{"id":759009,"t":"16｜创意图制作，自媒体神图神器 --blend 详解"},{"id":759010,"t":"17｜设置常用模版和风格 --设置和预设详解"},{"id":759011,"t":"18｜转移图片+找回丢失的图片 --show 命令详解"},{"id":759012,"t":"19｜风格复制利器 --describe 详解"},{"id":759013,"t":"20｜真人皮克斯风格卡通头像制作:垫图 --iw 详解"},{"id":759014,"t":"21｜构图复用利器:重混 --remix 详解"},{"id":759015,"t":"22｜特殊的画面内容控制 --权重详解"},{"id":759016,"t":"23｜大括号神奇用法，个性化批量出图神器 --组合提示详解"},{"id":759017,"t":"24｜无限拓展画面，穿过多重宇宙 --Zoom 和 pan 详解"}]},{"id":100040001,"n":"MongoDB高手课","a":"唐建法（TJ）","f":true,"c":53,"p":53,"l":[{"id":165249,"t":"01 | 课程介绍"},{"id":165250,"t":"02 | 内容综述"},{"id":165252,"t":"03 | 认识文档数据库MongoDB"},{"id":165253,"t":"04 | MongoDB特色及优势"},{"id":165255,"t":"05 | 实验：安装MongoDB"},{"id":165256,"t":"06 | MongoDB基本操作"},{"id":165257,"t":"07 | 实验：Hello World程序开发"},{"id":165258,"t":"08 | 聚合查询"},{"id":165265,"t":"09 | 实验：聚合查询"},{"id":167678,"t":"10 | 复制集机制及原理"},{"id":167679,"t":"11 | 实验：搭建MongoDB复制集"},{"id":167681,"t":"12 | MongoDB全家桶"},{"id":174551,"t":"13 | 模型设计基础"},{"id":174552,"t":"14 | JSON文档模型设计特点"},{"id":174555,"t":"15 | 文档模型设计之一：基础设计"},{"id":174556,"t":"16 | 文档模型设计之二：工况细化"},{"id":174557,"t":"17 | 文档模型设计之三：模式套用"},{"id":174558,"t":"18 | 设计模式集锦"},{"id":174559,"t":"19 | 事务开发：写操作事务"},{"id":176897,"t":"20 | 事务开发：读操作事务之一"},{"id":176900,"t":"21 |  事务开发：读操作事务之二"},{"id":176901,"t":"22 | 事务开发：多文档事务"},{"id":176902,"t":"23 | Change Stream"},{"id":176904,"t":"24 | MongoDB开发最佳实践"},{"id":177101,"t":"25 | 分片集群机制及原理"},{"id":177102,"t":"26 | 分片集群设计"},{"id":184037,"t":"27 | 实验：分片集群搭建及扩容"},{"id":184039,"t":"28 | MongoDB监控最佳实践"},{"id":184040,"t":"29 | MongoDB备份与恢复"},{"id":184042,"t":"30 | 备份与恢复操作"},{"id":186411,"t":"31 | MongoDB安全架构"},{"id":186412,"t":"32 | MongoDB安全加固实践"},{"id":186413,"t":"33 | MongoDB索引机制（一）"},{"id":186414,"t":"34 | MongoDB索引机制（二）"},{"id":186415,"t":"35 | MongoDB读写性能机制"},{"id":186416,"t":"36 | 性能诊断工具"},{"id":186417,"t":"37 | 高级集群设计：两地三中心"},{"id":186418,"t":"38 | 实验：搭建两地三中心集群"},{"id":186419,"t":"39 | 高级集群设计：全球多写"},{"id":186420,"t":"40 | MongoDB上线及升级"},{"id":193615,"t":"41 | MongoDB应用场景及选型"},{"id":193616,"t":"42 | MongoDB典型案例（一）"},{"id":193617,"t":"43 | MongoDB典型案例（二）"},{"id":200154,"t":"44 | 关系型数据库迁移"},{"id":200155,"t":"45 | 数据库迁移方式及工具"},{"id":200156,"t":"46 | Oracle迁移实战"},{"id":200157,"t":"47 | MongoDB + Spark实时大数据"},{"id":200158,"t":"48 | MongoDB + Spark连接实战"},{"id":200159,"t":"49 | MongoDB SQL套接件"},{"id":200160,"t":"50 | MongoDB与微服务"},{"id":200161,"t":"51 | MongoDB与数据中台"},{"id":200162,"t":"52 | MongoDB数据中台案例"},{"id":200163,"t":"53 | 结果测试&结束语"}]},{"id":100046401,"n":"NLP实战高手课","a":"王然","f":true,"c":160,"p":160,"l":[{"id":202859,"t":"01 | 课程介绍"},{"id":202861,"t":"02 | 内容综述"},{"id":202862,"t":"03 | AI概览：宣传片外的人工智能"},{"id":202872,"t":"04 | AI项目流程：从实验到落地"},{"id":202899,"t":"05 | NLP领域简介：NLP基本任务及研究方向"},{"id":202901,"t":"06 | NLP应用：智能问答系统"},{"id":202902,"t":"07 | NLP应用：文本校对系统"},{"id":202903,"t":"08 | NLP的学习方法：如何在AI爆炸时代快速上手学习？"},{"id":202904,"t":"09 | 深度学习框架简介：如何选择合适的深度学习框架？"},{"id":206512,"t":"10 | 深度学习与硬件：CPU"},{"id":206513,"t":"11 | 深度学习与硬件：GPU"},{"id":206514,"t":"12 | 深度学习与硬件：TPU"},{"id":206515,"t":"13 | AI项目部署：基本原则"},{"id":208138,"t":"14 | AI项目部署：框架选择"},{"id":208139,"t":"15 | AI项目部署：微服务简介"},{"id":208140,"t":"16 | 统计学基础：随机性是如何改变数据拟合的本质的？"},{"id":208142,"t":"17 | 神经网络基础：神经网络还是复合函数"},{"id":209425,"t":"18 | 神经网络基础：训练神经网络"},{"id":209422,"t":"19 | 神经网络基础：神经网络的基础构成"},{"id":209434,"t":"20 | Embedding简介：为什么Embedding更适合编码文本特征？"},{"id":209436,"t":"21 | RNN简介：马尔可夫过程和隐马尔可夫过程"},{"id":210361,"t":"22 | RNN简介：RNN和LSTM"},{"id":210363,"t":"23 | CNN：卷积神经网络是什么？"},{"id":210857,"t":"24 | 环境部署：如何构建简单的深度学习环境？"},{"id":213841,"t":"25 | PyTorch简介：Tensor和相关运算"},{"id":213843,"t":"26 | PyTorch简介：如何构造Dataset和DataLoader？"},{"id":213845,"t":"27 | PyTorch简介：如何构造神经网络？"},{"id":213846,"t":"28 | 文本分类实践：如何进行简单的文本分类？"},{"id":213847,"t":"29 | 文本分类实践的评价：如何提升进一步的分类效果？"},{"id":215188,"t":"30 | 经典的数据挖掘方法：数据驱动型开发早期的努力"},{"id":215213,"t":"31 | 表格化数据挖掘基本流程：看看现在的数据挖掘都是怎么做的？"},{"id":215212,"t":"32 | Pandas简介：如何使用Pandas对数据进行处理？"},{"id":215226,"t":"33 | Matplotlib简介：如何进行简单的可视化分析？"},{"id":216726,"t":"34 | 半自动特征构建方法：Target Mean Encoding"},{"id":216727,"t":"35 | 半自动特征构建方法：Categorical Encoder"},{"id":216728,"t":"36 | 半自动特征构建方法：连续变量的离散化"},{"id":216729,"t":"37 | 半自动特征构建方法：Entity Embedding"},{"id":218494,"t":"38 | 半自动构建方法：Entity Embedding的实现"},{"id":218495,"t":"39 | 半自动特征构建方法：连续变量的转换"},{"id":218496,"t":"40 | 半自动特征构建方法：缺失变量和异常值的处理"},{"id":218497,"t":"41 | 自动特征构建方法：Symbolic learning和AutoCross简介"},{"id":219758,"t":"42 | 降维方法：PCA、NMF 和 tSNE"},{"id":219759,"t":"43 | 降维方法：Denoising Auto Encoders"},{"id":219760,"t":"44 | 降维方法：Variational Auto Encoder"},{"id":219761,"t":"45 | 变量选择方法"},{"id":220611,"t":"46 | 集成树模型：如何提升决策树的效果"},{"id":220617,"t":"47 | 集成树模型：GBDT和XgBoost的数学表达"},{"id":220620,"t":"48 | 集成树模型：LightGBM简介"},{"id":220622,"t":"49 | 集成树模型：CatBoost和NGBoost简介"},{"id":222035,"t":"50 | 神经网络建模：如何让神经网络实现你的数据挖掘需求"},{"id":222044,"t":"51 | 神经网络的构建：Residual Connection和Dense Connection"},{"id":222053,"t":"52 | 神经网络的构建：Network in Network"},{"id":222054,"t":"53 | 神经网络的构建：Gating Mechanism和Attention"},{"id":225501,"t":"54 | 神经网络的构建：Memory"},{"id":225502,"t":"55 | 神经网络的构建：Activation Function"},{"id":225503,"t":"56 | 神经网络的构建：Normalization"},{"id":225504,"t":"57 | 神经网络的训练：初始化"},{"id":225505,"t":"58 | 神经网络的训练：学习率和Warm-up"},{"id":228338,"t":"59 | 神经网络的训练：新的PyTorch训练框架"},{"id":228341,"t":"60 | Transformer：如何通过Transformer榨取重要变量？"},{"id":228343,"t":"61 | Transformer代码实现剖析"},{"id":228345,"t":"62 | xDeepFM：如何用神经网络处理高维的特征？"},{"id":228352,"t":"63 | xDeepFM的代码解析"},{"id":231152,"t":"64 | 时序建模：如何用神经网络解决时间序列的预测问题？"},{"id":231153,"t":"65 | 图嵌入：如何将图关系纳入模型？"},{"id":231154,"t":"66 | 图网络简介：如何在图结构的基础上建立神经网络？"},{"id":231155,"t":"67 | 模型融合基础：如何让你所学到的模型方法一起发挥作用？"},{"id":231156,"t":"68 | 高级模型融合技巧：Metades是什么？"},{"id":233377,"t":"69 | 挖掘自然语言中的人工特征：如何用传统的特征解决问题？"},{"id":233378,"t":"70 | 重新审视Word Embedding：Negative Sampling和Contextual Embedding"},{"id":233380,"t":"71 | 深度迁移学习模型：从ELMo到BERT"},{"id":233382,"t":"72 | 深度迁移学习模型：RoBERTa、XLNet、ERNIE和T5"},{"id":233387,"t":"73 | 深度迁移学习模型：ALBERT和ELECTRA"},{"id":235663,"t":"74 | 深度迁移学习模型的微调：如何使用TensorFlow在TPU对模型进行微调"},{"id":235666,"t":"75 | 深度迁移学习模型的微调：TensorFlow BERT代码简析"},{"id":235667,"t":"76 | 深度迁移学习的微调：如何利用PyTorch实现深度迁移学习模型的微调及代码简析"},{"id":235669,"t":"77 | 优化器：Adam和AdamW"},{"id":235670,"t":"78 | 优化器：Lookahead，Radam和Lamb"},{"id":238493,"t":"79 | 多重loss的方式：如何使用多重loss来提高模型准确率？"},{"id":238494,"t":"80 | 数据扩充的基本方法：如何从少部分数据中扩充更多的数据并避免过拟合？"},{"id":238497,"t":"81 | UDA：一种系统的数据扩充框架"},{"id":238502,"t":"82 | Label Smoothing和Logit Squeezing"},{"id":238503,"t":"83 | 底层模型拼接：如何让不同的语言模型融合在一起从而达到更好的效果？"},{"id":241452,"t":"84 | 上层模型拼接：如何在语言模型基础上拼接更多的模型？"},{"id":241453,"t":"85 | 长文本分类：截取、关键词拼接和预测平均"},{"id":241456,"t":"86 | Virtual Adverserial Training：如何减少一般对抗训练难收敛的问题并提高结果的鲁棒性？"},{"id":241457,"t":"87 | 其他Embedding的训练：还有哪些Embedding方法？"},{"id":241458,"t":"88 | 训练预语言模型"},{"id":247394,"t":"89 | 多任务训练：如何利用多任务训练来提升效果？"},{"id":247396,"t":"90 | Domain Adaptation：如何利用其它有标注语料来提升效果？"},{"id":247397,"t":"91 | Few-shot Learning：是否有更好的利用不同任务的方法？"},{"id":247399,"t":"92 | 半监督学习：如何让没有标注的数据也派上用场？"},{"id":247401,"t":"93 | 依存分析和Semantic Parsing概述"},{"id":249772,"t":"94 | 依存分析和Universal Depdency Relattions"},{"id":249776,"t":"95 | 如何在Stanza中实现Dependency Parsing"},{"id":249778,"t":"96 | Shift Reduce算法"},{"id":249780,"t":"97 | 基于神经网络的依存分析算法"},{"id":249783,"t":"98 | 树神经网络：如何采用Tree LSTM和其它拓展方法？"},{"id":252803,"t":"99 | Semantic Parsing基础：Semantic Parsing的任务是什么？"},{"id":252804,"t":"100 | WikiSQL任务简介"},{"id":252805,"t":"101 | ASDL和AST"},{"id":252806,"t":"102 | Tranx简介"},{"id":252807,"t":"103 | Lambda Caculus概述"},{"id":256114,"t":"104 | Lambda-DCS概述"},{"id":256115,"t":"105 | Inductive Logic Programming：基本设定"},{"id":256112,"t":"106 | Inductive Logic Programming：一个可微的实现"},{"id":256110,"t":"107 | 增强学习的基本设定：增强学习与传统的预测性建模有什么区别？"},{"id":256109,"t":"108 | 最短路问题和Dijkstra Algorithm"},{"id":258668,"t":"109 | Q-learning：如何进行Q-learning算法的推导？"},{"id":258669,"t":"110 | Rainbow：如何改进Q-learning算法？"},{"id":258670,"t":"111 | Policy Gradient：如何进行Policy Gradient的基本推导？"},{"id":258671,"t":"112 | A2C和A3C：如何提升基本的Policy Gradient算法"},{"id":258672,"t":"113 | Gumbel-trick：如何将离散的优化改变为连续的优化问题？"},{"id":261944,"t":"114 | MCTS简介：如何将“推理”引入到强化学习框架中"},{"id":261945,"t":"115 | Direct Policty Gradient：基本设定及Gumbel-trick的使用"},{"id":261946,"t":"116 | Direct Policty Gradient：轨迹生成方法"},{"id":261947,"t":"117 | AutoML及Neural Architecture Search简介"},{"id":261948,"t":"118 | AutoML网络架构举例"},{"id":264699,"t":"119 | RENAS：如何使用遗传算法和增强学习探索网络架构"},{"id":264701,"t":"120 | Differentiable Search：如何将NAS变为可微的问题"},{"id":264702,"t":"121 | 层次搜索法：如何在模块之间进行搜索？"},{"id":264707,"t":"122 | LeNAS：如何搜索搜索space"},{"id":264710,"t":"123 | 超参数搜索：如何寻找算法的超参数"},{"id":266945,"t":"124 | Learning to optimize：是否可以让机器学到一个新的优化器"},{"id":266951,"t":"125 | 遗传算法和增强学习的结合"},{"id":266956,"t":"126 | 使用增强学习改进组合优化的算法"},{"id":266957,"t":"127 | 多代理增强学习概述：什么是多代理增强学习？"},{"id":266959,"t":"128 | AlphaStar介绍：AlphaStar中采取了哪些技术？"},{"id":269181,"t":"129 | IMPALA：多Agent的Actor-Critic算法"},{"id":269184,"t":"130 | COMA:Agent之间的交流"},{"id":269185,"t":"131 | 多模态表示学习简介"},{"id":269186,"t":"132 | 知识蒸馏：如何加速神经网络推理"},{"id":269187,"t":"133 | DeepGBM：如何用神经网络捕捉集成树模型的知识"},{"id":272509,"t":"134 | 文本推荐系统和增强学习"},{"id":272511,"t":"135 | RL训练方法集锦：简介"},{"id":272512,"t":"136 | RL训练方法:RL实验的注意事项"},{"id":272513,"t":"137 | PPO算法"},{"id":272514,"t":"138 | Reward设计的一般原则"},{"id":274757,"t":"139 | 解决Sparse Reward的一些方法"},{"id":274763,"t":"140 | Imitation Learning和Self-imitation Learning"},{"id":274768,"t":"141 | 增强学习中的探索问题"},{"id":274770,"t":"142 | Model-based Reinforcement Learning"},{"id":274771,"t":"143 | Transfer Reinforcement Learning和Few-shot Reinforcement Learning"},{"id":281524,"t":"144 | Quora问题等价性案例学习：预处理和人工特征"},{"id":281525,"t":"145 | Quora问题等价性案例学习：深度学习模型"},{"id":281526,"t":"146 | 文本校对案例学习"},{"id":281528,"t":"147 | 微服务和Kubernetes简介"},{"id":281530,"t":"148 | Docker简介"},{"id":283957,"t":"149 | Docker部署实践"},{"id":283958,"t":"150 | Kubernetes基本概念"},{"id":283959,"t":"151 | Kubernetes部署实践"},{"id":283960,"t":"152 | Kubernetes自动扩容"},{"id":283961,"t":"153 | Kubernetes服务发现"},{"id":286558,"t":"154 | Kubernetes Ingress"},{"id":286559,"t":"155 | Kubernetes健康检查"},{"id":286560,"t":"156 | Kubernetes灰度上线"},{"id":286571,"t":"157 | Kubernetes Stateful Sets"},{"id":286572,"t":"158 | Istio简介：Istio包含哪些功能？"},{"id":289811,"t":"159 | Istio实例和Circuit Breaker"},{"id":289813,"t":"160 | 结束语"}]},{"id":100036701,"n":"Netty源码剖析与实战","a":"傅健","f":true,"c":60,"p":60,"l":[{"id":146703,"t":"01 | 课程介绍"},{"id":146715,"t":"02 | 内容综述"},{"id":146722,"t":"03 | 揭开Netty面纱"},{"id":146726,"t":"04 | 为什么舍近求远：不直接用JDK NIO？"},{"id":146729,"t":"05 | 为什么孤注一掷：独选Netty？"},{"id":146739,"t":"06 | Netty的前尘往事"},{"id":146740,"t":"07 | Netty的现状与趋势"},{"id":147214,"t":"08 | Netty怎么切换三种I/O模式？"},{"id":147215,"t":"09 | 源码剖析：Netty对I/O模式的支持"},{"id":147216,"t":"10 | Netty如何支持三种Reactor？"},{"id":147896,"t":"11 | 源码剖析：Netty对Reactor的支持"},{"id":151113,"t":"12 | TCP粘包/半包Netty全搞定"},{"id":151118,"t":"13 | 源码剖析：Netty对处理粘包/半包的支持"},{"id":151119,"t":"14 | 常用的“二次”编解码方式"},{"id":151120,"t":"15 | 源码剖析：Netty对常用编解码的支持"},{"id":151121,"t":"16 | keepalive与idle监测"},{"id":154687,"t":"17 | 源码剖析：Netty对keepalive与idle监测的支持"},{"id":154688,"t":"18 | Netty的那些“锁”事"},{"id":154690,"t":"19 | Netty如何玩转内存使用"},{"id":154689,"t":"20 | 源码解析：Netty对堆外内存和内存池的支持"},{"id":154691,"t":"21 | Netty代码编译与总览"},{"id":158209,"t":"22 | 源码剖析：启动服务"},{"id":158156,"t":"23 | 源码剖析：构建连接"},{"id":158157,"t":"24 | 源码剖析：接收数据"},{"id":158158,"t":"25 | 源码剖析：业务处理"},{"id":158159,"t":"26 | 源码剖析：发送数据"},{"id":159454,"t":"27 | 源码剖析：断开连接"},{"id":159455,"t":"28 | 源码剖析：关闭服务"},{"id":159456,"t":"29 | 编写网络应用程序的基本步骤"},{"id":159457,"t":"30 | 案例介绍和数据结构设计"},{"id":159459,"t":"31 | 实现服务器端编解码"},{"id":164828,"t":"32 | 实现一个服务器端"},{"id":164829,"t":"33 | 实现客户端编解码"},{"id":164831,"t":"34 | 完成一个客户端雏形"},{"id":164833,"t":"35 | 引入\"响应分发\"完善客户端"},{"id":164834,"t":"36 | Netty编码中易错点解析"},{"id":168358,"t":"37 | 调优参数：调整System参数夯实基础"},{"id":168359,"t":"38 | 调优参数：权衡Netty核心参数"},{"id":168360,"t":"39 | 调优参数：图解费脑的三个参数"},{"id":168361,"t":"40 | 跟踪诊断：如何让应用易诊断？"},{"id":168362,"t":"41 | 跟踪诊断：应用能可视，心里才有底"},{"id":171282,"t":"42 | 跟踪诊断：让应用内存不“泄露”？"},{"id":171283,"t":"43 | 优化使用：用好自带注解省点心"},{"id":171284,"t":"44 | 优化使用：“整改”线程模型让\"响应\"健步如飞"},{"id":171285,"t":"45 | 优化使用：增强写，延迟与吞吐量的抉择"},{"id":171286,"t":"46 | 优化使用：如何让应用丝般“平滑”？"},{"id":171287,"t":"47 | 优化使用：为不同平台开启native"},{"id":174506,"t":"48 | 安全增强：设置“高低水位线”等保护好自己"},{"id":174507,"t":"49 | 安全增强：启用空闲监测"},{"id":174509,"t":"50 | 安全增强：简单有效的黑白名单"},{"id":174511,"t":"51 | 安全增强：少不了的自定义授权"},{"id":174512,"t":"52 | 安全增强：拿来即用的SSL-对话呈现表象"},{"id":174513,"t":"53 | 安全增强：拿来即用的SSL-抓包暴露本质"},{"id":174514,"t":"54 | 安全增强：拿来即用的SSL-轻松融入案例"},{"id":176974,"t":"55 | Cassandra如何使用Netty ？"},{"id":176976,"t":"56 | Dubbo如何使用Netty ？"},{"id":176978,"t":"57 | Hadoop如何使用Netty ？"},{"id":176979,"t":"58 | 赏析Netty之美"},{"id":176980,"t":"59 | 如何给Netty贡献代码？"},{"id":176981,"t":"60 | 结课测试&结束语"}]},{"id":100616701,"n":"PPT设计进阶 · 从基础操作到高级创意","a":"李金宝（Bobbie）","f":true,"c":32,"p":32,"l":[{"id":700329,"t":"特别放送｜输入主题，一键生成PPT"},{"id":693849,"t":"01｜你必须掌握的PPT最基本操作"},{"id":693850,"t":"02｜形状原来还能这么玩"},{"id":693851,"t":"03｜形状创意高级玩法"},{"id":693852,"t":"04｜你可能忽略了的文字处理技巧"},{"id":693853,"t":"05｜轻松拿捏PPT文字特效"},{"id":693854,"t":"06｜PPT高手都在用的图片处理技法"},{"id":693855,"t":"07｜效果炸裂的PPT图片处理技巧"},{"id":693873,"t":"08｜PPT制作的全局化设计思维"},{"id":693891,"t":"09｜彻底搞懂PPT中的母版与版式"},{"id":694671,"t":"10｜极具吸引力的PPT封面设计"},{"id":694592,"t":"11｜灵活多变的目录页设计"},{"id":694582,"t":"12｜章节过渡页设计参考"},{"id":694495,"t":"13｜印象深刻的结束页这样设计"},{"id":694612,"t":"14｜文字内容的图示化表达"},{"id":694584,"t":"15｜网页端快速完成PPT制作"},{"id":693874,"t":"16｜平面设计四原则：对齐"},{"id":693875,"t":"17｜平面设计四原则：亲密性"},{"id":693876,"t":"18｜平面设计四原则：对比"},{"id":693878,"t":"19｜平面设计四原则：重复"},{"id":693879,"t":"20｜成为PPT高手！PPT大括号"},{"id":693880,"t":"21｜排版神器：PPT高手必备，大括号还能这样用"},{"id":693881,"t":"22｜PPT图片处理技巧（上）"},{"id":693882,"t":"23｜PPT图片处理技巧（下）"},{"id":693883,"t":"24｜PPT常用技巧：蒙版篇之纯色蒙版"},{"id":693884,"t":"25｜PPT常用技巧：蒙版篇之渐变蒙版"},{"id":693885,"t":"26｜PPT常用技巧：蒙版篇之镂空蒙版"},{"id":693886,"t":"27｜PPT常用技巧：蒙版篇之镂空蒙版"},{"id":693887,"t":"28｜PPT封面很low，试试文字笔画拆分"},{"id":693888,"t":"29｜PPT高手都在用的形状布尔运算"},{"id":693889,"t":"30｜PPT创意进度条制作"},{"id":693890,"t":"31｜弥散风格PPT原来要这样做"}]},{"id":100761601,"n":"QCon 北京 2024 · 大模型篇","a":"InfoQ","f":true,"c":22,"p":22,"l":[{"id":772984,"t":"01 | 饿了么垂域大模型 EGPT 训练与 C 端应用实践"},{"id":772988,"t":"02 | 大模型技术在快手搜索的应用"},{"id":772985,"t":"03 | 通义灵码技术解析，打造 AI 原生开发新范式"},{"id":772989,"t":"04 | 智能编码工具 Comate 的核心能力揭秘"},{"id":772992,"t":"05 | AI Agent 在企业经营分析场景的落地"},{"id":772995,"t":"06 | 面向办公自动化领域的 AI Agent 建设思考与分享"},{"id":772997,"t":"07 | 大模型原生应用产品设计的前沿探索"},{"id":772998,"t":"08 | 大模型的三次触动、两个难题、一个参考答案"},{"id":773008,"t":"09 | 大模型在信也对话机器人中的应用"},{"id":773005,"t":"10 | 百度营销智能体：从对话式投放到多智能体协同"},{"id":773012,"t":"11 | 教育大模型，说你行你才行"},{"id":773004,"t":"12 | 模型基座应用为团队带来的机会与挑战"},{"id":773003,"t":"13 | RAG 商业落地实践踩坑"},{"id":773002,"t":"14 | 大模型应用开发新范式"},{"id":773001,"t":"15 | LLM 和 Multi-agent 在运维领域的实验探索"},{"id":772999,"t":"16 | MFTcoder：大模型多任务微调框架"},{"id":772996,"t":"17 | SRE－Copliot：基于大语言模型的智能运维架构"},{"id":772993,"t":"18 | 快意大模型在短视频互动场景的应用探索"},{"id":772990,"t":"19 | 海天瑞声在大模型数据的探索与实践"},{"id":772987,"t":"20 | 基于 AI 大模型生成微信小程序的探索与实践"},{"id":772986,"t":"21 | AI 大模型技术在数据库 DevOps 的实践"},{"id":772983,"t":"22 | CodeGeeX：构建项目级代码智能助手"}]},{"id":100799801,"n":"RAG前沿入门课","a":"老刘","f":true,"c":12,"p":12,"l":[{"id":802441,"t":"课程介绍"},{"id":802476,"t":"01｜从LangChain了解RAG"},{"id":802477,"t":"02｜LangChain中，RAG有哪些优化策略？"},{"id":802478,"t":"03｜为什么我们需要KG- RAG？"},{"id":802479,"t":"04｜KG-RAG有哪些常见的实现思路？"},{"id":802480,"t":"05｜快速了解7个KG- RAG的简单项目"},{"id":802481,"t":"06｜什么是KG-enhanced prompt？"},{"id":802482,"t":"07｜拆解HiQA和Linkedin kG-RAG：实现文档层级结构细分召回和双层嵌入索引"},{"id":802483,"t":"08｜UniQA-Text2cypher的KG-RAG是什么？"},{"id":802484,"t":"09｜考虑实体特异性的HippoRAG与考虑拓扑的结构GRAG"},{"id":802485,"t":"10｜微软的GraphRAG方案是什么样的？"},{"id":802486,"t":"结束语｜我怎么看KG-RAG的现在和未来？"}]},{"id":100824301,"n":"RAG在企业数智化场景下的设计与改进","a":"张颖峰","f":true,"c":10,"p":10,"l":[{"id":812476,"t":"01｜从基础设施看数智化系统架构的演变趋势"},{"id":812477,"t":"02｜从数智化场景看RAG：是临时方案，还是终局架构？"},{"id":812900,"t":"03｜国内和海外企业对于GenAI的需求的共识和差异"},{"id":813207,"t":"04｜数据清洗和解析对RAG的影响和解决方案"},{"id":813741,"t":"05｜如何保证高命中率，如何选型向量数据库？"},{"id":813756,"t":"06｜如何解决复杂问答？"},{"id":813757,"t":"07｜如何构建企业级Agent？"},{"id":813758,"t":"08｜如何构建企业级的RAG和Agent集群架构？"},{"id":813759,"t":"09｜多模态RAG的技术进展和发展路线"},{"id":813760,"t":"10｜未来的RAG和Agent如何发展？"}]},{"id":100055601,"n":"Selenium自动化测试实战","a":"郭宏志","f":true,"c":69,"p":69,"l":[{"id":260627,"t":"01 | 课程介绍"},{"id":260639,"t":"02 | 内容综述"},{"id":260640,"t":"03 | 聊聊Web自动化测试：黑盒、白盒、α测试、β测试、冒烟测试、回归测试"},{"id":260641,"t":"04 | Selenium三剑客：WebDriver、IDE、Grid一网打尽"},{"id":260643,"t":"05 | Selenium开发环境搭建"},{"id":260644,"t":"06 | 下载安装浏览器驱动：教你解决最麻烦的版本匹配问题"},{"id":260645,"t":"07 | 第一个Selenium测试：Selenium测试流程、源码分析"},{"id":260646,"t":"08 | 实现元素定位：掌握Selenium八大定位方法"},{"id":260647,"t":"09 | 通过打车生活案例，深入剖析WebDriver运行原理"},{"id":260648,"t":"10 | 掌握WebDriver核心方法和属性的使用"},{"id":262226,"t":"11 | 掌握WebElement核心方法和属性的使用"},{"id":262228,"t":"12 | form表单：熟练掌握form表单操作步骤"},{"id":262746,"t":"13 | 掌握checkbox和radiobutton的定位技巧"},{"id":262748,"t":"14 | 下拉列表：熟练使用Select类，来实现下拉列表定位"},{"id":263693,"t":"15 | 弹框处理：掌握alert、confirm、prompt三种弹出的用法"},{"id":263694,"t":"16 | Selenium三种等待方式：剖析原理、用法和应用场景"},{"id":263695,"t":"17 | Selenium等待条件：掌握17种元素等待条件"},{"id":263696,"t":"18 | 掌握鼠标单击、双击、右击，键盘输入、键盘组合键的应用"},{"id":263697,"t":"19 | 熟练执行JavaScript的方法和技巧，掌握JavaScript操作滚动条"},{"id":263699,"t":"20 | Selenium屏幕截图：实现屏幕截屏、按照日期时间格式保存图片"},{"id":263700,"t":"21 | 掌握frame、iframe定位，熟练frame的切入和切出"},{"id":266872,"t":"22 | 下载安装Selenium IDE：下载安装Chrome、Firefox插件IDE"},{"id":266873,"t":"23 | 熟练Selenium IDE菜单栏、工具类、命令窗口的使用"},{"id":266874,"t":"24 | Selenium IDE实现录制和回放及脚本导出"},{"id":266906,"t":"25 | 项目环境搭建：安装JDK、MySQL、Tomcat和测试系统"},{"id":266877,"t":"26 | 需求分析和用例设计：深度挖掘需求，掌握测试用例设计范式"},{"id":266878,"t":"27 | 项目架构设计：掌握分层设计思想，合理设计目录和包结构"},{"id":269721,"t":"28 | 解决验证码问题-方案一：使用pytesseract和Pillow实现验证码识别"},{"id":269722,"t":"29 | 解决验证码问题-方案二：通过第三方AI库识别验证码"},{"id":269703,"t":"30 | 实现工具类：设计获得验证码、随机字符串生成、cookie操作工具类"},{"id":269704,"t":"31 | 完成用户注册测试用例：解决验证码、等待弹框等复杂内容"},{"id":269705,"t":"32 | 完成用户登录测试用例：实现登录成功和失败测试"},{"id":269706,"t":"33 | 完成管理员登录测试用例：完成验证码正确和错误测试用例"},{"id":269707,"t":"34 | 完成文章分类测试用例：解决测试用例依赖问题"},{"id":269711,"t":"35 | 完成添加、删除文章测试用例"},{"id":272566,"t":"36 | unittest简介：测试用例、测试套件、测试运行器、测试加载器"},{"id":272568,"t":"37 | unittest中的方法：掌握各种setup、teardown和断言方法"},{"id":272569,"t":"38 | 测试用例、测试套件和测试加载器：掌握加载测试用例的四种方法"},{"id":272570,"t":"39 | 使用unittest重构测试用例：掌握使用unittest模块的方法和技巧"},{"id":272572,"t":"40 | 为项目添加测试报告：使用第三方模块实现测试报告"},{"id":274472,"t":"41 | pytest框架简介：pytest安装、用例编写规则、执行用例"},{"id":274473,"t":"42 | pytest标记：查找测试策略、标记测试函数"},{"id":274475,"t":"43 | pytest参数化处理：使用参数化装饰器、解析列表、元组、字典等数据"},{"id":274481,"t":"44 | pytest Fixture：使用fixture实现用例之间的调用"},{"id":274482,"t":"45 | pytest setup 和 teardown"},{"id":274484,"t":"46 | pytest allure生成测试报告"},{"id":274485,"t":"47 | 使用pytest重构项目：实现用例依赖、测试报告、数据参数化"},{"id":277794,"t":"48 | logging模块简介：日志的作用、等级和常用函数"},{"id":277796,"t":"49 | logging日志格式输出：日志发生的时间、文件、模块、行号等信息格式输出"},{"id":277797,"t":"50 | logging模块四大组件：Logger、Handler、Formatter、Filter的用法"},{"id":277799,"t":"51 | 为项目添加日志：将日志应用到项目"},{"id":277800,"t":"52 | 使用csv模块读取CSV文件，使用pytest参数化实现DDT"},{"id":277801,"t":"53 | 使用json模块读取json文件，使用pytest参数化实现DDT"},{"id":277802,"t":"54 | 使用xlrd模块读取excel文件，使用pytest参数化实现DDT"},{"id":277803,"t":"55 | Selenium读取数据库数据：将数据保存到数据库，实现数据驱动的测试"},{"id":277805,"t":"56 | Selenium DDT：使用DDT模块实现数据驱动的测试"},{"id":277806,"t":"57 | 使用DDT思想重构项目：使用数据库保存数据，将数据驱动思想应用到项目"},{"id":280752,"t":"58 | POM设计模式简介：理解页面-对象-模型设计模式，实现代码的松耦合"},{"id":280759,"t":"59 | 设计BasePage类：设计基类，提高项目的代码重用性"},{"id":280760,"t":"60 | 设计项目页面对应的PO类：使用POM设计模式设计PO类"},{"id":280761,"t":"61 | 设计项目测试用例：将POM设计模式应用到项目"},{"id":280763,"t":"62 | Selenium Grid下载安装：配置Java运行环境，下载安装Selenium Grid"},{"id":280764,"t":"63 | Selenium注册node节点"},{"id":280766,"t":"64 | 使用Selenium执行远程测试"},{"id":280767,"t":"65 | Jenkins环境搭建：下载安装Jenkins"},{"id":280769,"t":"66 | 在Jenkins中运行项目"},{"id":280770,"t":"67 | 邮件通知：实现邮件通知功能"},{"id":280771,"t":"68 | 定时运行项目，实现真正的自动化测试"},{"id":280772,"t":"69 | 结课测试&结束语"}]},{"id":100049401,"n":"Service Mesh实战","a":"马若飞","f":true,"c":41,"p":41,"l":[{"id":221497,"t":"01 | 课程介绍"},{"id":221498,"t":"02 | 内容综述"},{"id":221499,"t":"03 | Service Mesh的起源：为什么会出现Service Mesh技术？"},{"id":221500,"t":"04 | Service Mesh的发展：Service Mesh技术是如何演进的？"},{"id":221501,"t":"05 | 微服务通信的济世良方：什么是Service Mesh？它能帮你做什么？"},{"id":221502,"t":"06 | 列王的纷争：市面上有哪些主流的Service Mesh产品？"},{"id":222358,"t":"07 | 王者的诞生：为什么Istio有如此高的呼声？"},{"id":222373,"t":"08 | Istio的自我救赎：为什么Istio发生了两次重大的架构变更？"},{"id":222374,"t":"09 | 核心功能之流量控制：Istio是如何实现流量控制功能的？"},{"id":222381,"t":"10 | 服务的可观察性：如何理解服务可视化的重要性？"},{"id":222382,"t":"11 | 保卫你的网格：Istio是如何设计安全架构的？"},{"id":224520,"t":"12 | 安装与部署：如何安装Istio？它都支持哪些环境和部署方式？"},{"id":224521,"t":"13 | 动态路由：用Virtual Service和Destination Rule设置路由规则"},{"id":224529,"t":"14 | 网关：用Gateway管理进入网格的流量"},{"id":224523,"t":"15 | 服务入口：用Service Entry扩展你的网格服务"},{"id":224524,"t":"16 | 流量转移：灰度发布是如何实现的？"},{"id":224525,"t":"17 | Ingress：控制进入网格的请求"},{"id":229805,"t":"18 | Egress：用Egress实现访问外部服务"},{"id":229807,"t":"19 | 超时重试：提升系统的健壮性和可用性"},{"id":229860,"t":"20 | 熔断：“秒杀”场景下的过载保护是如何实现的？"},{"id":229808,"t":"21 | 故障注入：在Istio中实现一个“Chaos Monkey”"},{"id":229841,"t":"22 | 流量镜像：解决线上问题排查的难题"},{"id":230978,"t":"23 | 洞察你的服务：使用Kiali观测你的微服务应用"},{"id":230980,"t":"24 | 指标：使用Prometheus收集指标"},{"id":230981,"t":"25 | 监控：使用Grafana查看系统的整体状态"},{"id":230982,"t":"26 | 日志：如何获取Envoy的日志并进行调试"},{"id":233613,"t":"27 | 分布式追踪：使用Jeager对应用进行分布式追踪"},{"id":233614,"t":"28 | 守卫网格：配置TLS安全网关"},{"id":233615,"t":"29 | 双重保障：为应用设置不同级别的双向TLS"},{"id":233616,"t":"30 | 授权策略：如何实现JWT身份认证与授权？"},{"id":233617,"t":"31 | 实战演练（一）：项目准备和构建过程"},{"id":238687,"t":"32 | 实战演练（二）：实现自动化灰度发布"},{"id":238686,"t":"33 | 实战演练（三）：提升系统的弹性能力"},{"id":238685,"t":"34 | 实战演练（四）：配置安全策略"},{"id":238684,"t":"35 | 实战演练（五）：收集指标并监控应用"},{"id":238682,"t":"36 | 实战演练（六）：集成 ELK Stack 日志套件"},{"id":240678,"t":"37 | 实战演练（七）：集成分布式追踪工具"},{"id":240679,"t":"38 | 调试工具和方法：调试网格的工具和方法有哪些？"},{"id":240680,"t":"39 | 实践经验总结：实际落地中的常见问题有哪些？"},{"id":240681,"t":"40 | 未来架构——从Service Mesh迈向云原生"},{"id":240683,"t":"41 |  结果测试&结束语"}]},{"id":100031401,"n":"Spring Boot与Kubernetes云原生微服务实践","a":"杨波","f":true,"c":94,"p":94,"l":[{"id":106105,"t":"01 | 课程介绍"},{"id":106044,"t":"02 | 背景说明"},{"id":106045,"t":"03 | 课程目标和主要内容"},{"id":106046,"t":"04 | 课程案例需求"},{"id":106106,"t":"05 | 课程补充说明"},{"id":106047,"t":"06 | 为何采用微服务架构？"},{"id":106151,"t":"07 | 架构设计和技术栈选型"},{"id":106048,"t":"08 | 数据和接口模型设计：账户服务"},{"id":106153,"t":"09 | 数据和接口模型设计：业务服务"},{"id":106168,"t":"10 | Dubbo、Spring Cloud和Kubernetes该如何选型（上）"},{"id":108180,"t":"11 | Dubbo、Spring Cloud和Kubernetes该如何选型（中）"},{"id":108197,"t":"12 | Dubbo、Spring Cloud和Kubernetes该如何选型（下）"},{"id":108199,"t":"13 | 技术中台到底讲什么？"},{"id":108200,"t":"14 | Staffjoy项目结构组织"},{"id":108201,"t":"15 | 谷歌为何采用单体仓库（Mono-Repo）？"},{"id":108202,"t":"16 | 微服务接口参数校验为何重要？"},{"id":108204,"t":"17 | 如何实现统一异常处理？"},{"id":108203,"t":"18 | DTO和DMO为什么要互转？"},{"id":108206,"t":"19 | 如何实现基于Feign的强类型接口？"},{"id":108205,"t":"20 | 为什么框架层就要考虑分环境配置？"},{"id":109712,"t":"21 | 异步处理为何要复制线程上下文信息？"},{"id":109713,"t":"22 | 为你的接口添加Swagger文档"},{"id":109714,"t":"23 | 主流微服务框架概览"},{"id":109715,"t":"24 | 网关和BFF是如何演化出来的（上）"},{"id":109716,"t":"25 | 网关和BFF是如何演化出来的（下）"},{"id":109717,"t":"26 | 网关和反向代理是什么关系？"},{"id":109718,"t":"27 | 网关需要分集群部署吗？"},{"id":109719,"t":"28 | 如何设计一个最简网关？"},{"id":109729,"t":"29 | Faraday网关代码解析（上）"},{"id":109730,"t":"30 | Faraday网关代码解析（下）"},{"id":111471,"t":"31 | 生产级网关需要考虑哪些环节？"},{"id":111472,"t":"32 | 主流开源网关概览"},{"id":111473,"t":"33 | 安全认证架构演进：单块阶段（上）"},{"id":111477,"t":"34 | 安全认证架构演进：单块阶段（下）"},{"id":111478,"t":"35 | 安全认证架构演进：微服务阶段"},{"id":111479,"t":"36 | 基于JWT令牌的安全认证架构"},{"id":111480,"t":"37 | JWT的原理是什么？"},{"id":111481,"t":"38 | JWT有哪两种主要流程？"},{"id":111482,"t":"39 | Staffjoy安全认证架构和SSO"},{"id":111483,"t":"40 | 用户认证代码剖析"},{"id":113644,"t":"41 | 服务调用鉴权代码剖析"},{"id":113645,"t":"42 | 如何设计用户角色鉴权？"},{"id":113646,"t":"43 | Spring Boot微服务测试该如何分类？"},{"id":113647,"t":"44 | 什么是契约驱动测试？"},{"id":113648,"t":"45 | 什么是测试金字塔？"},{"id":113649,"t":"46 | 单元测试案例分析"},{"id":113650,"t":"47 | 集成测试案例分析"},{"id":113651,"t":"48 | 组件测试案例分析"},{"id":113653,"t":"49 | Mock vs Spy"},{"id":113654,"t":"50 | 何谓生产就绪(Production Ready)？"},{"id":117986,"t":"51 | Spring Boot如何实现分环境配置"},{"id":117990,"t":"52 | Apollo vs SpringCloudConfig vs K8s ConfigMap"},{"id":117993,"t":"53 | CAT vs Zipkin vs Skywalking(上)"},{"id":117994,"t":"54 | CAT vs Zipkin vs Skywalking(下)"},{"id":117995,"t":"55 | 结构化日志和业务审计日志"},{"id":117996,"t":"56 | 集中异常监控和Sentry"},{"id":117999,"t":"57 | EFK & Prometheus & Skywalking + Kubernetes 集成架构"},{"id":118000,"t":"58 | 本地开发部署架构和软件需求"},{"id":118001,"t":"59 | 手工服务部署和测试(上)"},{"id":118002,"t":"60 | 手工服务部署和测试(中)"},{"id":120167,"t":"61 | 手工服务部署和测试(下)"},{"id":120169,"t":"62 | SkyWalking调用链监控实验"},{"id":120170,"t":"63 | Docker和Docker Compose简介"},{"id":120171,"t":"64 | 容器镜像构建Dockerfile解析"},{"id":120172,"t":"65 | Docker Compose服务部署文件剖析"},{"id":120173,"t":"66 | 将Staffjoy部署到本地Docker Compose环境(上)"},{"id":120174,"t":"67 | 将Staffjoy部署到本地Docker Compose环境(下)"},{"id":120175,"t":"68 | 到底什么是云原生架构？"},{"id":120176,"t":"69 | Kubernetes背景和架构"},{"id":120177,"t":"70 | Kubernetes有哪些基本概念(上)"},{"id":127766,"t":"71 | Kubernetes有哪些基本概念(下)"},{"id":127768,"t":"72 | 理解Kubernetes节点网络和Pod网络"},{"id":127769,"t":"73 | 深入理解Service和ServiceDiscovery"},{"id":127771,"t":"74 | NodePort vs LoadBalancer vs Ingress"},{"id":127773,"t":"75 | 本地测试Kubernetes部署文件剖析"},{"id":127774,"t":"76 | 本地测试Kubernetes环境搭建"},{"id":127775,"t":"77 | 将Staffjoy部署到本地Kubernetes环境(上)"},{"id":127776,"t":"78 | 将Staffjoy部署到本地Kubernetes环境(下)"},{"id":127777,"t":"79 | 生产环境Kubernetes部署文件剖析"},{"id":127825,"t":"80 | 阿里云Kubernetes环境创建"},{"id":131493,"t":"81 | 将Staffjoy部署到阿里云Kubernetes环境"},{"id":131494,"t":"82 | Kubernetes应用动态配置实验"},{"id":131495,"t":"83 | Kubernetes应用金丝雀发布实验"},{"id":131496,"t":"84 | 阿里云资源释放"},{"id":131497,"t":"85 | 课程复盘"},{"id":131536,"t":"86 | 项目扩展和应用"},{"id":131537,"t":"87 | Account服务"},{"id":131538,"t":"88 | Company服务"},{"id":131539,"t":"89 | Mail、SMS和Bot服务"},{"id":131540,"t":"90 | Faraday服务"},{"id":131541,"t":"91 | WhoAmI服务"},{"id":131542,"t":"92 | WWW服务"},{"id":131543,"t":"93 | 前端应用"},{"id":131892,"t":"94 | 结课测试&结束语"}]},{"id":100769401,"n":"Stable Diffusion实战课​","a":"夜月 ​& 散步​","f":true,"c":37,"p":37,"l":[{"id":778432,"t":"01｜课程介绍及生成式AI常见应用"},{"id":778433,"t":"02｜扩散模型原理"},{"id":778435,"t":"03｜扩散模型代码演示"},{"id":778437,"t":"04｜Stable Diffusion详解"},{"id":778438,"t":"05｜为什么需要微调?"},{"id":778551,"t":"06｜SD常用微调方法：LoRA、DreamBooth"},{"id":778552,"t":"07｜SD常用微调方法：Textural Inversion"},{"id":778553,"t":"08｜可控生成ControINet"},{"id":778554,"t":"09｜基于SD Attention机制的图片编辑"},{"id":778555,"t":"10｜真实图片的反推与编辑"},{"id":778579,"t":"11｜SD的扩展应用：3D生成与编辑"},{"id":778580,"t":"12｜SD的扩展应用：视频生成（Sora原理讲解）"},{"id":778581,"t":"13｜Stable Diffusion基础介绍"},{"id":778582,"t":"14｜Stable Diffusion WebUI安装与配置"},{"id":778583,"t":"15｜第三方模型获取与使用"},{"id":778586,"t":"16｜WenUI基本页面介绍与功能说明"},{"id":778587,"t":"17｜获取第三方Checkpoint和LoRA"},{"id":778588,"t":"18｜图生图体验"},{"id":778589,"t":"19｜如何安装第三方插件？"},{"id":778590,"t":"20｜如何使用ControINet插件？"},{"id":778597,"t":"21｜如何使用roop换脸插件？"},{"id":778598,"t":"22｜ComfyUI基础介绍"},{"id":778599,"t":"23｜ComfyUI的安装与配置"},{"id":778601,"t":"24｜ComfyUI基本操作与工作流"},{"id":778602,"t":"25｜ComfyUI管理器"},{"id":778619,"t":"26｜安装InstantID节点"},{"id":778620,"t":"27｜LoRA的原理与优势介绍"},{"id":778621,"t":"28｜使用lora-scripts训练LoRA（上）"},{"id":778622,"t":"29｜使用lora-scripts训练LoRA（下）"},{"id":778623,"t":"30｜使用训练好的LoRA生成图片"},{"id":778624,"t":"31｜妙鸭相机基础介绍"},{"id":778625,"t":"32｜训练个人数据LoRA并实践生成数字写真"},{"id":778626,"t":"33｜使用换脸插件实现风格化数字写真"},{"id":781930,"t":"34｜Stable Diffusion应用场景入门：从粘土人到动漫游戏世界"},{"id":781931,"t":"35｜Stable Diffusion在2D、3D、Video中的应用"},{"id":784475,"t":"36｜Stable Diffusion应用场景入门：加速电商美术设计"},{"id":784476,"t":"37｜SD3究竟好不好？全面大测评"}]},{"id":100034001,"n":"Swift核心技术与实战","a":"张杰","f":true,"c":120,"p":120,"l":[{"id":117737,"t":"01 | 课程介绍"},{"id":117731,"t":"02 | 内容综述"},{"id":117732,"t":"03 | Swift版本历史和各版本特性快览"},{"id":117726,"t":"04 | Swift和Objective-C的主要区别"},{"id":117738,"t":"05 | swiftc：强大的命令行工具"},{"id":117727,"t":"06 | REPL：Swift交互式解释器"},{"id":117756,"t":"07 | Playground：Swift学习的乐园"},{"id":117728,"t":"08 | 如何在Swift中定义常量和变量"},{"id":117729,"t":"09 | Swift中的数值类型"},{"id":117730,"t":"10 | 如何使用Tuple组合多个值"},{"id":120352,"t":"11 | 如何在Swift中使用Optional"},{"id":120353,"t":"12 | Optional实现原理探究"},{"id":120354,"t":"13 | 如何在Swift中创建和初始化字符串"},{"id":120355,"t":"14 | Swift字符串的常见操作"},{"id":120357,"t":"15 | 如何使用索引访问和修改字符串"},{"id":120358,"t":"16 | 如何在Swift中获取子串和进行字符串比较"},{"id":128178,"t":"17 | 赋值和算数运算符"},{"id":128179,"t":"18 | 在Swift里如何处理算术结果溢出"},{"id":128180,"t":"19 | 为了Optional：合并空值运算符"},{"id":128181,"t":"20 | Swift的新宠：区间运算符"},{"id":128183,"t":"21 | 强大的位运算符"},{"id":128185,"t":"22 | 位运算符应用举例（1）"},{"id":128186,"t":"23 | 位运算符应用举例（2）"},{"id":131658,"t":"24 | 运算符优先级和结合性"},{"id":131657,"t":"25 | 如何为类和结构体自定义运算符实现"},{"id":131656,"t":"26 | 如在Swift中定义自己的运算符"},{"id":131655,"t":"27 | 如何在Swift里进行循环控制"},{"id":131654,"t":"28 | 更加强大的switch"},{"id":131653,"t":"29 | 如何在Swift里进行控制转移"},{"id":131652,"t":"30 | 如何使用guard来改善你的条件判断"},{"id":131651,"t":"31 | Swift中的模式和模式匹配"},{"id":134747,"t":"32 | 在Swift中创建数组的N种方式"},{"id":134748,"t":"33 | 访问和操作数组：遍历和索引"},{"id":134749,"t":"34 | 访问和操作数组：查找操作"},{"id":134750,"t":"35 | 访问和操作数组：添加和删除"},{"id":134751,"t":"36 | 访问和操作数组：ArraySlice"},{"id":134764,"t":"37 | 访问和操作数组：重排操作"},{"id":137232,"t":"38丨访问和操作数组：拼接操作"},{"id":137231,"t":"39丨深入理解数组：底层实现探究"},{"id":137230,"t":"40丨如何用数组来实现栈和队列"},{"id":137229,"t":"41丨Set：定义和创建"},{"id":137228,"t":"42丨Set：访问和修改"},{"id":137227,"t":"43丨Set：执行Set计算和判断"},{"id":140446,"t":"44 | 实现自己的集合算法"},{"id":140445,"t":"45 | 深入理解集合：底层实现探究"},{"id":140444,"t":"46 | Dictionary：Swift中的字典类型"},{"id":140443,"t":"47 | 字典的常见操作"},{"id":140442,"t":"48 | 深入理解字典：底层实现探究"},{"id":144678,"t":"49 | Swift中如何定义和使用函数"},{"id":144677,"t":"50 | 函数的形式参数和返回值"},{"id":144676,"t":"51 | 函数类型和内嵌函数"},{"id":144675,"t":"52 | 闭包和闭包表达式"},{"id":144674,"t":"53 | 闭包捕获值"},{"id":144673,"t":"54 | 逃逸闭包和自动闭包"},{"id":146947,"t":"55 | 如何使用Swift中的高阶函数"},{"id":146948,"t":"56 | 函数式编程（1）"},{"id":146949,"t":"57 | 函数式编程（2）"},{"id":146950,"t":"58 | Swift面向对象概述"},{"id":150851,"t":"59 | 枚举从此站起来了"},{"id":150850,"t":"60 | 如何为类、结构体以及枚举添加属性"},{"id":150849,"t":"61 | 如何为类、结构体以及枚举添加方法"},{"id":150848,"t":"62 | 像访问数组和字典一样访问类和结构体：下标和下标重载"},{"id":154566,"t":"63 | 如何进行类的初始化和反初始化"},{"id":154565,"t":"64 | 如何在Swift中实现继承"},{"id":154564,"t":"65 | 如何在Swift中实现多态和进行类型转换"},{"id":154563,"t":"66 | 如何为现有的类、结构体、枚举或协议添加新功能"},{"id":158105,"t":"67丨Swift中的协议"},{"id":158104,"t":"68丨协议和扩展"},{"id":158103,"t":"69丨面向协议编程初探（1）"},{"id":158101,"t":"70丨面向协议编程初探（2）"},{"id":158102,"t":"71丨泛型的发展历史与泛型的概述"},{"id":158122,"t":"72丨如何在Swift中定义泛型函数"},{"id":158123,"t":"73丨如何在Swift中定义泛型类型"},{"id":158124,"t":"74丨Swift泛型中的类型约束"},{"id":161807,"t":"75 | 为了协议：关联类型"},{"id":161806,"t":"76 | 如何为泛型定义要求：where字句"},{"id":161805,"t":"77 | 泛型下标"},{"id":161813,"t":"78丨泛型编程思想浅谈"},{"id":161803,"t":"79 | 如何在Swift中创建一个线程"},{"id":161802,"t":"80 | 更高级的抽象：Cocoa Operation"},{"id":161814,"t":"81丨多线程编程新思路：GCD概览"},{"id":161815,"t":"82 | 如何使用GCD：基本操作指南"},{"id":161823,"t":"83 | 深度使用GCD：高级特性指南"},{"id":161822,"t":"84 | 深入理解GCD：源码剖析"},{"id":161821,"t":"85 | 如何保证线程安全和同步"},{"id":161820,"t":"86 | 实践出真知：多线程典型应用场景分析"},{"id":161819,"t":"87 | 拓宽思路：其他常见的多线程编程模式"},{"id":165144,"t":"88 | SwiftUI：Apple全新的UI框架"},{"id":165145,"t":"89 | SwiftUI设计工具使用指南"},{"id":165146,"t":"90 | 如何使用SwiftUI构建可复用的组件"},{"id":165147,"t":"91 | 如何用SwiftUI实现动画"},{"id":165148,"t":"92 | 深入理解SwiftUI：实现原理探秘"},{"id":165164,"t":"93 | 如何在Swift里进行错误处理"},{"id":165163,"t":"94 | Swift中代码访问权限控制"},{"id":165162,"t":"95 | 不透明类型"},{"id":165161,"t":"96 | Swift中的自动引用计数"},{"id":165160,"t":"97 | Swift中的内存安全性"},{"id":167212,"t":"98 | 如何在项目中进行网络请求"},{"id":167213,"t":"99 | 如何进行JSON的序列化和反序列化"},{"id":167214,"t":"100 | 没有最方便，只有更方便：对Swift标准库的一些扩展"},{"id":167215,"t":"101 | 如何在Swift中进行自动布局"},{"id":167216,"t":"102 | 如何进行图片加载和缓存"},{"id":167217,"t":"103 | 以一种优雅安全的方式使用资源文件"},{"id":167233,"t":"104 | 如何在项目中将内容分享到社交平台"},{"id":167227,"t":"105 | Swift和Objective-C的运行时简介"},{"id":167226,"t":"106 | 桥接问题"},{"id":167225,"t":"107 | 如何在Swift和Objective-C中相互调用"},{"id":167224,"t":"108 | Swift和Objective-C混合编程踩坑指南"},{"id":171419,"t":"109 | 如何搭建一个iOS Swift工程"},{"id":171418,"t":"110 | 商城整体架构、UI设计和模块拆分"},{"id":171417,"t":"111 | 编写mock API"},{"id":172894,"t":"112 | 登录注册页模块开发"},{"id":172895,"t":"113 | 商城列表页模块开发"},{"id":172896,"t":"114 | 商城详情页模块开发"},{"id":172897,"t":"115 | 商城个人中心页模块开发"},{"id":172898,"t":"116 | 商城订单页模块开发"},{"id":172899,"t":"117 | 结束语"},{"id":177119,"t":"118｜加餐1：可选链"},{"id":177118,"t":"119｜加餐2：Swift KVC"},{"id":177117,"t":"120｜加餐3：Swift面试中的要点注意事项&结课测试"}]},{"id":100053201,"n":"TensorFlow 2项目进阶实战","a":"彭靖田","f":true,"c":56,"p":56,"l":[{"id":244109,"t":"01 | 课程介绍：AI进阶需要落地实战"},{"id":244111,"t":"02 | 内容综述：如何快速⾼效学习AI与TensorFlow 2"},{"id":244110,"t":"03 | TensorFlow 2新特性"},{"id":244112,"t":"04 | TensorFlow 2核心模块"},{"id":244113,"t":"05 | TensorFlow 2 vs TensorFlow 1.x"},{"id":244114,"t":"06 | TensorFlow 2落地应⽤"},{"id":244115,"t":"07 | TensorFlow 2开发环境搭建"},{"id":244118,"t":"08 | TensorFlow 2数据导入与使⽤"},{"id":247402,"t":"09 | 使用tf.keras.datasets加载数据"},{"id":247403,"t":"10 | 使用tf.keras管理Sequential模型"},{"id":247404,"t":"11 | 使用tf.keras管理functional API"},{"id":247409,"t":"12 | Fashion MNIST数据集介绍"},{"id":247411,"t":"13 | 使用TensorFlow2训练分类网络"},{"id":247957,"t":"14 | 行业背景：AI新零售是什么?"},{"id":247959,"t":"15 |  用户需求：线下门店业绩如何提升？"},{"id":247960,"t":"16 | 长期⽬标：货架数字化与业务智能化"},{"id":247961,"t":"17 | 短期目标：自动化陈列审核和促销管理"},{"id":247963,"t":"18 | 方案设计：基于深度学习的检测/分类的AI流水线"},{"id":252134,"t":"19 | 方案交付：支持在线识别和API调用的AI SaaS"},{"id":252135,"t":"20 | 基础：目标检测问题定义与说明"},{"id":252136,"t":"21 | 基础：深度学习在目标检测中的应用"},{"id":252145,"t":"22 | 理论：R-CNN系列二阶段模型综述"},{"id":252147,"t":"23 | 理论：YOLO系列一阶段模型概述"},{"id":255668,"t":"24 | 应用：RetinaNet 与 Facol Loss 带来了什么"},{"id":255669,"t":"25 | 应用：检测数据标注方法与流程"},{"id":258358,"t":"26 | 应用：划分检测训练集与测试集"},{"id":258359,"t":"27 | 应用：生成 CSV 格式数据集与标注"},{"id":258360,"t":"28 | 应用：使用TensorFlow 2训练RetinaNet"},{"id":258361,"t":"29 | 应用：使用RetinaNet检测货架商品"},{"id":258362,"t":"30 | 扩展：目标检测常用数据集综述"},{"id":258363,"t":"31 | 扩展：目标检测更多应用场景介绍"},{"id":258365,"t":"32 | 基础：图像分类问题定义与说明"},{"id":258366,"t":"33 | 基础：越来越深的图像分类网络"},{"id":260909,"t":"34 | 应⽤：检测SKU抠图与分类标注流程"},{"id":260911,"t":"35 | 应⽤：分类训练集与验证集划分"},{"id":260912,"t":"36 | 应⽤：使⽤TensorFlow 2训练ResNet"},{"id":260913,"t":"37 | 应用：使用ResNet识别货架商品"},{"id":260914,"t":"38 | 扩展：图像分类常用数据集综述"},{"id":260915,"t":"39 | 扩展：图像分类更多应⽤场景介绍"},{"id":267178,"t":"40 | 串联AI流程理论：商品检测与商品识别"},{"id":267180,"t":"41 | 串联AI流程实战：商品检测与商品识别"},{"id":267181,"t":"42 | 展现AI效果理论：使用OpenCV可视化识别结果"},{"id":267182,"t":"43 | 展现AI效果实战：使用OpenCV可视化识别结果"},{"id":267183,"t":"44 | 搭建AI SaaS理论：Web框架选型"},{"id":269010,"t":"45 | 搭建AI SaaS理论：数据库ORM选型"},{"id":269012,"t":"46 | 搭建AI SaaS理论：10分钟快速开发AI SaaS"},{"id":269013,"t":"47 | 搭建AI SaaS实战：10 分钟快速开发AI SaaS"},{"id":269014,"t":"48 | 交付AI SaaS：10分钟快速掌握容器部署"},{"id":269015,"t":"49 | 交付AI SaaS：部署和测试AI SaaS"},{"id":271879,"t":"50 | 使⽤TensorFlow 2实现图像数据增强"},{"id":271881,"t":"51 | 使⽤TensorFlow 2实现分布式训练"},{"id":271882,"t":"52 | 使⽤TensorFlow Hub迁移学习"},{"id":271884,"t":"53 | 使⽤@tf.function提升性能"},{"id":271885,"t":"54 | 使⽤TensorFlow Serving部署云端服务"},{"id":271887,"t":"55 | 使⽤TensorFlow Lite实现边缘智能"},{"id":271889,"t":"56 | 结束语"}]},{"id":100023001,"n":"TensorFlow快速入门与实战","a":"彭靖田","f":true,"c":67,"p":67,"l":[{"id":108833,"t":"01 | 课程介绍"},{"id":76547,"t":"02 | 课程内容综述"},{"id":76546,"t":"03 | 第一章内容概述"},{"id":76548,"t":"04 | TensorFlow产生的历史必然性"},{"id":76549,"t":"05 | TensorFlow与Jeff Dean的那些事"},{"id":76550,"t":"06 | TensorFlow的应用场景"},{"id":76551,"t":"07 | TensorFlow的落地应用"},{"id":76552,"t":"08 | TensorFlow的发展现状"},{"id":76553,"t":"09 | 第二章内容概述"},{"id":76554,"t":"10 | 搭建你的TensorFlow开发环境"},{"id":76555,"t":"11 | Hello TensorFlow"},{"id":76556,"t":"12 | 在交互环境中使用TensorFlow"},{"id":76557,"t":"13 | 在容器中使用TensorFlow"},{"id":76954,"t":"14 | 第三章内容概述"},{"id":76955,"t":"15 | TensorFlow模块与架构介绍"},{"id":76956,"t":"16 | TensorFlow数据流图介绍"},{"id":77203,"t":"17 | 张量（Tensor）是什么（上）"},{"id":77204,"t":"18 | 张量（Tensor）是什么（下）"},{"id":77205,"t":"19 | 变量（Variable）是什么（上）"},{"id":77207,"t":"20 | 变量（Variable）是什么（下）"},{"id":77209,"t":"21 | 操作（Operation）是什么（上）"},{"id":77210,"t":"22 | 操作（Operation）是什么（下）"},{"id":77212,"t":"23 | 会话（Session）是什么"},{"id":77215,"t":"24 | 优化器（Optimizer）是什么"},{"id":78978,"t":"25 | 第四章内容概述"},{"id":78981,"t":"26 | 房价预测模型的前置知识"},{"id":78979,"t":"27 | 房价预测模型介绍"},{"id":79136,"t":"28 | 房价预测模型之数据处理"},{"id":79138,"t":"29 | 房价预测模型之创建与训练"},{"id":79411,"t":"30 | TensorBoard可视化工具介绍"},{"id":80135,"t":"31 | 使用TensorBoard可视化数据流图"},{"id":80136,"t":"32 | 实战房价预测模型：数据分析与处理"},{"id":80137,"t":"33 | 实战房价预测模型：创建与训练"},{"id":80142,"t":"34 | 实战房价预测模型：可视化数据流图"},{"id":81594,"t":"35 | 第五章内容概述"},{"id":81596,"t":"36 | 手写体数字数据集MNIST介绍（上）"},{"id":81598,"t":"37 | 手写体数字数据集MNIST介绍（下）"},{"id":81600,"t":"38 | MNIST Softmax网络介绍（上）"},{"id":81602,"t":"39 | MNIST Softmax网络介绍（下）"},{"id":81843,"t":"40 | 实战MNIST Softmax网络（上）"},{"id":81844,"t":"41 | 实战MNIST Softmax网络（下）"},{"id":81845,"t":"42 | MNIST CNN网络介绍"},{"id":81846,"t":"43 | 实战MNIST CNN网络"},{"id":83923,"t":"44 | 第六章内容概述"},{"id":83924,"t":"45 | 准备模型开发环境"},{"id":83925,"t":"46 | 生成验证码数据集"},{"id":84142,"t":"47 | 输入与输出数据处理"},{"id":84149,"t":"48 | 模型结构设计"},{"id":84154,"t":"49 | 模型损失函数设计"},{"id":84160,"t":"50 | 模型训练过程分析"},{"id":84163,"t":"51 | 模型部署与效果演示"},{"id":84661,"t":"52 | 第七部分内容介绍"},{"id":84701,"t":"53 | 人脸识别问题概述"},{"id":84704,"t":"54 | 典型人脸相关数据集介绍"},{"id":84706,"t":"55 | 人脸检测算法介绍"},{"id":84707,"t":"56 | 人脸识别算法介绍"},{"id":84751,"t":"57 | 人脸检测工具介绍"},{"id":84765,"t":"58 | 解析FaceNet人脸识别模型"},{"id":84771,"t":"59 | 实战FaceNet人脸识别模型"},{"id":84948,"t":"60 | 测试与可视化分析"},{"id":85703,"t":"61 | 番外篇内容介绍"},{"id":85704,"t":"62 | TensorFlow社区介绍"},{"id":85708,"t":"63 | TensorFlow生态：TFX"},{"id":85710,"t":"64 | TensorFlow生态：Kubeflow"},{"id":85712,"t":"65 | 如何参与TensorFlow社区开源贡献"},{"id":85721,"t":"66 | ML GDE是TensorFlow社区与开发者的桥梁"},{"id":85715,"t":"67 | 课程总结"}]},{"id":100024601,"n":"Vue开发实战","a":"唐金州","f":true,"c":53,"p":53,"l":[{"id":86419,"t":"01 | 课程介绍"},{"id":86447,"t":"02 | Vue简介"},{"id":86423,"t":"03 | 内容综述"},{"id":86424,"t":"04 | 第一个Vue程序"},{"id":87489,"t":"05 | 组件基础及组件注册"},{"id":86426,"t":"06 | Vue组件的核心概念：事件"},{"id":86427,"t":"07 | Vue组件的核心概：插槽"},{"id":86428,"t":"08 | 理解单文件组件"},{"id":86429,"t":"09 | 双向绑定和单向数据流不冲突"},{"id":86448,"t":"10 | 理解虚拟DOM及key属性的作用"},{"id":86449,"t":"11 | 如何触发组件的更新"},{"id":86620,"t":"12 | 合理应用计算属性和侦听器"},{"id":86621,"t":"13 | 生命周期的应用场景和函数式组件"},{"id":86623,"t":"14 | 指令的本质是什么"},{"id":86625,"t":"15 | 常用高级特性provide/inject"},{"id":86626,"t":"16 | 如何优雅地获取跨层级组件实例（拒绝递归）"},{"id":86701,"t":"17 | template和JSX的对比以及它们的本质"},{"id":87629,"t":"18 | 为什么需要Vuex"},{"id":87630,"t":"19 | 如何在Vue中使用Vuex"},{"id":88100,"t":"20 | Vuex核心概念及底层原理"},{"id":88392,"t":"21 | Vuex最佳实践"},{"id":88390,"t":"22 | Vue Router的使用场景"},{"id":88393,"t":"23 | 选择何种模式的路由及底层原理"},{"id":88394,"t":"24 | Nuxt解决了哪些问题？"},{"id":88395,"t":"25 | Nuxt核心原理是什么？"},{"id":88396,"t":"26 | UI组件库对比：Element UI、Ant Design Vue、iView"},{"id":88861,"t":"27 | 提升开发效率和体验的常用工具：ESLint、Prettier、vue-devtools"},{"id":88863,"t":"28 | 单元测试的重要性及其使用"},{"id":88885,"t":"29 | 生态篇习题解答（上）"},{"id":88886,"t":"30 | 生态篇习题解答（下）"},{"id":89256,"t":"31 | Ant Design Pro介绍"},{"id":89259,"t":"32 | 使用Vue CLI 3快速创建项目"},{"id":89474,"t":"33 | 如何自定义Webpack和Babel配置"},{"id":91010,"t":"34 | 如何设计一个高扩展性的路由"},{"id":91450,"t":"35 | 实现一个可动态改变的页面布局"},{"id":92224,"t":"36 | 如何将菜单和路由结合"},{"id":92512,"t":"37 | 如何使用路由管理用户权限"},{"id":92513,"t":"38 | 更加精细化的权限设计（权限组件、权限指令）"},{"id":93226,"t":"39 | 如何在组件中使用ECharts、Antv等其他第三方库"},{"id":93790,"t":"40 | 如何高效地使用Mock数据进行开发"},{"id":93791,"t":"41 | 如何与服务端进行交互（Axios）"},{"id":94404,"t":"42 | 创建一个普通表单"},{"id":94405,"t":"43 | 初始数据、自动校验、动态赋值"},{"id":94406,"t":"44 | 创建一个分步表单"},{"id":94407,"t":"45 | 自己封装一个支持自动校验的表单项"},{"id":94601,"t":"46 | 如何管理系统中使用的图标"},{"id":94602,"t":"47 | 如何定制主题及动态切换主题"},{"id":95243,"t":"48 | 如何做好国际化"},{"id":95437,"t":"49 | 如何高效地构建打包发布"},{"id":95438,"t":"50 | 如何构建可交互的组件文档"},{"id":96177,"t":"51 | 如何做好组件的单元测试"},{"id":96178,"t":"52 | 如何发布组件到npm"},{"id":96179,"t":"53 | 结课测试&GitHub相关生态应用（持续集成、单测覆盖率、文档发布、issue管理）"}]},{"id":100034201,"n":"ZooKeeper实战与源码剖析","a":"么敬国","f":true,"c":47,"p":47,"l":[{"id":119488,"t":"01 | 课程介绍"},{"id":119489,"t":"02 | 内容综述"},{"id":119490,"t":"03 | 什么是ZooKeeper？"},{"id":119491,"t":"04 | ZooKeeper提供什么服务？"},{"id":119492,"t":"05 | 开始使用ZooKeeper"},{"id":119493,"t":"06 | 使用ZooKeeper实现Master-Worker协同"},{"id":119494,"t":"07 | ZooKeeper架构解析"},{"id":119495,"t":"08 | ZooKeeper API简介"},{"id":119497,"t":"09 | ZooKeeper API：Watch示例"},{"id":119498,"t":"10 | 使用ZooKeeper实现分布式队列"},{"id":119499,"t":"11 | 使用ZooKeeper实现分布式锁"},{"id":119500,"t":"12 | 使用ZooKeeper实现选举"},{"id":126440,"t":"13 | 使用Apache Curator简化ZooKeeper开发"},{"id":126441,"t":"14 | 如何安装配置一个ZooKeeper生产环境？"},{"id":126442,"t":"15 | 如何进行ZooKeeper的监控？"},{"id":126443,"t":"16 | 通过ZooKeeper Observer实现跨区域部署"},{"id":126444,"t":"17 | 通过动态配置实现不中断服务的集群成员变更"},{"id":126446,"t":"18 | ZooKeeper节点是如何存储数据的?"},{"id":131268,"t":"19 | 使用ZooKeeper实现服务发现（1）"},{"id":131270,"t":"20 | 使用ZooKeeper实现服务发现（2）"},{"id":134829,"t":"21 |  使用ZooKeeper实现服务发现（3）"},{"id":134814,"t":"22 | Kafka是如何使用ZooKeeper的?"},{"id":136825,"t":"23 | 什么是Paxos协议?"},{"id":136826,"t":"24 | 对比Chubby和ZooKeeper"},{"id":136827,"t":"25 | Raft协议解析"},{"id":140285,"t":"26 | 什么是etcd？"},{"id":140287,"t":"27 | etcd API： KV部分"},{"id":140294,"t":"28 | etcd API：Watch和Lease部分"},{"id":141388,"t":"29 | 使用etcd实现分布式队列"},{"id":141389,"t":"30 | 使用etcd实现分布式锁"},{"id":141390,"t":"31 | 如何搭建一个etcd生产环境？"},{"id":143652,"t":"32 | 存储数据结构之B+tree"},{"id":143669,"t":"33 | 存储数据结构之LSM"},{"id":143698,"t":"34 | 本地存储技术总结"},{"id":150560,"t":"35 | ZooKeeper本地存储源码解析"},{"id":150561,"t":"36 | 网络编程基础"},{"id":150562,"t":"37 | 事件驱动的网络编程"},{"id":153668,"t":"38 | Java的事件驱动网络编程"},{"id":153673,"t":"39 | ZooKeeper的客户端网络通信源码解读"},{"id":154123,"t":"40 | ZooKeeper的服务器网络通信源码解读"},{"id":154124,"t":"41 | ZooKeeper的Request Processor源码解读"},{"id":154127,"t":"42 | Standalone的ZooKeeper是如何处理客户端请求的？"},{"id":157573,"t":"43 | Quorum模式下ZooKeeper节点的Request Processor Pipeline"},{"id":157581,"t":"44 | ZooKeeper的Leader Election"},{"id":157583,"t":"45 | ZooKeeper的Zab协议"},{"id":157585,"t":"46 | 客户端和服务器端交互：Watch和Session"},{"id":157586,"t":"47 | 结课测试&结束语"}]},{"id":100122501,"n":"云计算必修小课","a":"吕蕴偲","f":true,"c":10,"p":10,"l":[{"id":573177,"t":"01｜拨云见日——云上架构一点儿也不神秘"},{"id":573178,"t":"02｜飞云掣电——澎湃算力的云中服务器"},{"id":573180,"t":"03｜青云万里——10分钟带你了解Serverless平台"},{"id":573181,"t":"04｜风轻云淡——如何用好对象存储（上）？"},{"id":573182,"t":"05｜风轻云淡——如何用好对象存储（下）？"},{"id":573183,"t":"06｜云净天空——谈云中负载均衡器（上）"},{"id":573184,"t":"07｜云净天空——谈云中负载均衡器（下）"},{"id":573185,"t":"08｜云合景从——弹性扩展，永无止境的伸缩"},{"id":573187,"t":"09｜风虎云龙——云端存储十大技巧"},{"id":573188,"t":"10｜行云流水——如何选择合适的方式迁移上云？"}]},{"id":100637901,"n":"互联网人的数字化企业生存指南","a":"沈欣","f":true,"c":12,"p":12,"l":[{"id":736430,"t":"01｜趁大势而为大事：到底什么是数字化？"},{"id":736448,"t":"02｜浪潮：数字化碰到了AI，就像石油碰到了炼油厂"},{"id":736454,"t":"03｜转行：互联网转向传统行业，需要注意些什么？"},{"id":736458,"t":"04｜7个架构思维：如何推动传统企业的数字化转型？"},{"id":736463,"t":"05｜企业生命周期：如何抓住重点实现有限资源价值最大化？"},{"id":736606,"t":"06｜量化能力：如何在传统企业中扬长避短？"},{"id":736614,"t":"07｜数字业务化：如何通过数据揭露细节？"},{"id":736619,"t":"08｜元问题库：如何理解传统行业的具体业务？"},{"id":736637,"t":"09｜势道法术器用：如何评估传统企业中的数字化体系？"},{"id":736896,"t":"10｜构建闭环=正确数据&算法+参与流程+切实执行"},{"id":736902,"t":"11｜数学化：公式拆解明确价值，解决人的问题才是真正解决问题"},{"id":736906,"t":"12｜从生存指南到发展指南：保持谦逊，心怀敬畏"}]},{"id":100767801,"n":"人人都是prompt工程师","a":"北冥","f":true,"c":15,"p":15,"l":[{"id":778255,"t":"01｜人工智能新篇章，prompt工程为何成为必修课?"},{"id":778256,"t":"02｜理解ChatGPT的局限性和响应机制"},{"id":778257,"t":"03｜构建你的第一条prompt"},{"id":778283,"t":"04｜思维的边界：批判性思维如何塑造prompt？"},{"id":778286,"t":"05｜苏格拉底写prompt"},{"id":780828,"t":"06｜避免常见陷阱：prompt设计误区"},{"id":780829,"t":"07｜如何设计高效的prompt模式，提高ChatGPT的输出质量?"},{"id":780833,"t":"08｜遇到ChatGPT响应不理想时，如何进行精细调优?"},{"id":780832,"t":"09｜多轮对话中如何保持话题连贯，避免混乱?"},{"id":780830,"t":"10｜缺乏创意灵感时，如何利用prompt激发创新思维?"},{"id":783350,"t":"11｜案例分析：技术小白如何快速学会 Python 编程?"},{"id":783351,"t":"12｜案例分析：学术论文写作遇到瓶颈，ChatGPT 如何助你一臂之力？"},{"id":783352,"t":"13｜案例分析：市场分析新手如何迅速提升分析能力？"},{"id":783353,"t":"14｜案例分析：客户服务人员如何应对海量反馈?"},{"id":783355,"t":"15｜prompt工程的未来与持续学习"}]},{"id":100779901,"n":"从0到1布局AIGC","a":"李洋","f":false,"c":10,"p":10,"l":[{"id":787951,"t":"01 | 企业AIGC战略布局准备"},{"id":787953,"t":"02 | 国内外主流AIGC产品及差异"},{"id":787954,"t":"03 | AIGC技术框架及核心组件解析"},{"id":787956,"t":"04 | 企业布局AIGC的必要性"},{"id":787957,"t":"05 | 如何将AIGC技术与企业业务相结合"},{"id":787971,"t":"06 | 什么是提示工程（Prompt）以及该如何使用它"},{"id":787973,"t":"07 | 检索增强生成（RAG）实操"},{"id":787975,"t":"08 | 大模型精调（Fine-Tuning）实操"},{"id":787976,"t":"09 | 大模型预训练工程实操"},{"id":787970,"t":"10 | AI重塑商业未来：把握行业变革的新趋势"}]},{"id":100025901,"n":"从0开发一款iOS App","a":"朱德权","f":true,"c":106,"p":106,"l":[{"id":90962,"t":"01 | 课程介绍"},{"id":90963,"t":"02 | 内容综述"},{"id":90966,"t":"03 | 常见App类型及技术栈浅析"},{"id":90968,"t":"04 | 使用Xcode创建第一个工程"},{"id":90969,"t":"05 | MVC模式：iOS中的架构基石"},{"id":90971,"t":"06 | iOS中的视图UIView"},{"id":90972,"t":"07 | 了解UIView的生命周期"},{"id":90974,"t":"08 | 视图的控制器UIViewController"},{"id":90976,"t":"09 | 结合视图和控制器构建Tabbar样式页面"},{"id":90977,"t":"10 | 使用Navigation构建App的基础交互"},{"id":91819,"t":"11 | iOS基本页面框架的构成和实现"},{"id":91977,"t":"12 | 系统函数中常见模式Delegate"},{"id":91988,"t":"13 | UITableView简介"},{"id":91989,"t":"14 | UITableView中Delegate和Datasource的使用"},{"id":91990,"t":"15 | UITableViewCell的复用及原理"},{"id":91987,"t":"16 | 结合子视图实现完整的列表界面"},{"id":92389,"t":"17 | UICollectionView的基本应用和实现"},{"id":93482,"t":"18 | UICollectionViewLayout的应用"},{"id":93484,"t":"19 | 基本列表视图的选择和使用"},{"id":93918,"t":"20 | 滚动视图的基类UIScrollView简介"},{"id":93944,"t":"21 | 应用UIScrollViewDelegate实现复杂逻辑"},{"id":93948,"t":"22 | iOS中滚动视图对比及App内应用场景浅析"},{"id":93951,"t":"23 | iOS中文字的展示：UILabel的使用与布局"},{"id":93954,"t":"24 | iOS中图片的展示：UIImage与UIImageView的应用"},{"id":93956,"t":"25 | iOS中按钮的实现：UIButton的使用"},{"id":93958,"t":"26 | UIControl以及Target-Action模式"},{"id":93959,"t":"27 | 使用UIGestureRecognizer实现自定义点击与手势"},{"id":93960,"t":"28 | 通过UIAlertView了解UIKit系统函数的设计和使用"},{"id":95614,"t":"29 | Web基础知识及WKWebView 介绍"},{"id":95615,"t":"30 | 使用WKWebView及Delgate实现简单的页面加载"},{"id":96340,"t":"31 | 认识观察者模式KVO并展示页面加载进度"},{"id":96341,"t":"32 | iOS开发中的Web应用浅析"},{"id":96449,"t":"33 | 使用UIView动画完善界面的交互"},{"id":97536,"t":"34 | 动画背后的CALayer基本应用"},{"id":97539,"t":"35 | CoreAnimation及开源动画框架介绍"},{"id":98035,"t":"36 | 常用代码规范和重构方式"},{"id":98036,"t":"37 | 结合UIKit分析常用App的页面结构"},{"id":98364,"t":"38 | 网络基础及请求的封装"},{"id":98365,"t":"39 | NSURLSession基础原理、组织和使用"},{"id":98366,"t":"40 | 使用系统网络架构NSURLSession加载网络数据"},{"id":98368,"t":"41 | 常用框架集成方式Submodule、Carthage和CocoaPods对比和使用"},{"id":98369,"t":"42 | 集成和使用开源网络框架"},{"id":98370,"t":"43 | iOS中的JSON解析"},{"id":98371,"t":"44 | 使用结构化的数据进行解析和展示"},{"id":98372,"t":"45 | 实现列表数据加载、解析和展示的完整流程"},{"id":98373,"t":"46 | iOS沙盒机制和文件结构"},{"id":98375,"t":"47 | 使用NSFileManager操作和管理文件"},{"id":98376,"t":"48 | iOS中的序列化NSCoding"},{"id":98377,"t":"49 | 开源存储方案对比与分析"},{"id":98379,"t":"50 | 缓存新闻列表数据及已读状态"},{"id":99259,"t":"51 | iOS中线程的基础知识及NSThread"},{"id":99260,"t":"52 | GCD的常用方法分析和使用"},{"id":99261,"t":"53 | 了解Operation、Runloop以及多线程开发总结"},{"id":99262,"t":"54 | 如何管理App中的图片下载与存储"},{"id":99263,"t":"55 | 开源图片框架接触的架构和使用"},{"id":103560,"t":"56 | 了解iOS系统的音视频框架"},{"id":103734,"t":"57 | 重构视频列表展示视频"},{"id":103735,"t":"58 | 实现简单视频播放器AVPlayer"},{"id":104527,"t":"59 | iOS消息机制NSNotification简介"},{"id":104630,"t":"60 | 使用Notification接收和处理播放状态通知"},{"id":104631,"t":"61 | 使用KVO监听和处理播放资源的状态变化"},{"id":104632,"t":"62 | CMTime及播放缓冲进度的获取和使用"},{"id":104633,"t":"63 | 使用单例模式重构播放器业务逻辑"},{"id":104634,"t":"64 | 常用App视频业务及流程浅析"},{"id":104635,"t":"65 | AutoLayout简介"},{"id":104636,"t":"66 | 使用AutoLayout实现通用ToolBar视图"},{"id":104638,"t":"67 | iOS常用布局方式选择"},{"id":104639,"t":"68 | 逻辑分辨率适配"},{"id":104640,"t":"69 | 物理分辨率适配"},{"id":104641,"t":"70 | 使用ImageAsset管理图片资源"},{"id":104643,"t":"71 | iPhone X适配"},{"id":104644,"t":"72 | iOS开发适配常用方法总结"},{"id":104645,"t":"73 | App启动过程及生命周期分析"},{"id":107763,"t":"74 | 通过App生命周期回调实现启动页"},{"id":107764,"t":"75 | 使用URL Scheme进行App间的唤起和通信"},{"id":107765,"t":"76 | Universal Link简介"},{"id":107766,"t":"77 | 常用组件化Target-Action方案"},{"id":107767,"t":"78 | 常用组件化URL Scheme方案"},{"id":107768,"t":"79 | 常用组件化Protocol-Class方案"},{"id":107769,"t":"80 | 实现简单的第三方登录和分享功能"},{"id":107770,"t":"81 | iOS中静态库的制作和使用"},{"id":107771,"t":"82 | iOS当中Framework的制作和使用"},{"id":107772,"t":"83 | OAuth和OpenID原理和使用"},{"id":107773,"t":"84 | 集成QQ SDK实现登录和分享功能"},{"id":107774,"t":"85 | iOS中常用日志和上报系统浅析"},{"id":107775,"t":"86 | 类CocoaLumberjack日志框架架构浅析"},{"id":107789,"t":"87 | Crash的类型介绍和常用收集方案"},{"id":107776,"t":"88 | 常用上报技术方案对比和分析"},{"id":107777,"t":"89 | iOS中定位和定位权限"},{"id":107778,"t":"90 | 定位功能实现和位置信息的获取"},{"id":107779,"t":"91 | iOS中推送和推送权限"},{"id":107780,"t":"92 | 使用UserNotifications实现本地推送"},{"id":107781,"t":"93 | 远程推送与APNs简介"},{"id":107782,"t":"94 | 使用UserNotifications接收远程推送"},{"id":107783,"t":"95 | iOS图标管理和动态更新"},{"id":107784,"t":"96 | iOS App Extension简介"},{"id":107785,"t":"97 | 实现Today Extension以及数据共享"},{"id":107786,"t":"98 | UITextField和UITextView"},{"id":107787,"t":"99 | 使用UITextField实现搜索条"},{"id":107788,"t":"100 | 使用UITextView实现输入框"},{"id":113826,"t":"101 | 复杂列表页实现方案及IGListKit浅析"},{"id":113831,"t":"102 | 复杂内容页展示逻辑及实现方案浅析"},{"id":113834,"t":"103 | App的签名原理和证书申请"},{"id":113836,"t":"104 | 常用iOS唯一标识符"},{"id":113837,"t":"105 | App的打包和上架流程"},{"id":113838,"t":"106 | 结课测试&结束语"}]},{"id":100053601,"n":"分布式系统案例课","a":"杨波","f":true,"c":66,"p":66,"l":[{"id":248858,"t":"01 | 课程介绍"},{"id":248859,"t":"02 | 内容综述"},{"id":248861,"t":"03 | 需求收集和总体架构设计"},{"id":248862,"t":"04 | 存储设计"},{"id":248863,"t":"05 | 计数服务设计（上）"},{"id":248864,"t":"06 | 计数服务设计（下）"},{"id":249784,"t":"07 | 查询服务设计"},{"id":249785,"t":"08 | 技术栈选型"},{"id":249787,"t":"09 | 进一步考量和总结"},{"id":253293,"t":"10 | PMQ 2.0项目背景"},{"id":253299,"t":"11 | PMQ 2.0的设计解析（上）"},{"id":253300,"t":"12 | PMQ 2.0的设计解析（中）"},{"id":253301,"t":"13 | PMQ 2.0的设计解析（下）"},{"id":256705,"t":"14 | PMQ 3.0的演进"},{"id":256708,"t":"15 | Kafka的动态重平衡是如何工作的？（上）"},{"id":256709,"t":"16 | Kafka的动态重平衡是如何工作的？（下）"},{"id":256710,"t":"17 | 消息队列设计和治理最佳实践"},{"id":258662,"t":"18 | 第四章目录和大纲"},{"id":258664,"t":"19 | 微服务的四大技术难题是什么？"},{"id":258666,"t":"20 | 如何解决微服务的数据一致性分发问题？"},{"id":258667,"t":"21 | 如何解决微服务的数据聚合Join问题？"},{"id":261111,"t":"22 | 如何解决微服务的分布式事务问题？（上）"},{"id":261112,"t":"23 | 如何解决微服务的分布式事务问题？（下）"},{"id":261113,"t":"24 | 阿里分布式事务中间件Seata解析"},{"id":261114,"t":"25 | Uber微服务编排引擎Cadence解析"},{"id":264150,"t":"26 | 如何理解Uber Cadence的架构设计？"},{"id":264163,"t":"27 | 如何实现遗留系统的解耦拆分？"},{"id":264164,"t":"28 | 拍拍贷系统拆分项目案例"},{"id":264175,"t":"29 | CQRS/CDC技术在Netflix的实践"},{"id":264176,"t":"30 | 第四章总结"},{"id":267340,"t":"31 | SessionServer项目背景"},{"id":267342,"t":"32 | 总体架构设计"},{"id":267343,"t":"33 | 如何设计一个高性能基于内存的LRU Cache？"},{"id":267344,"t":"34 | 如何设计一个高性能大容量持久化的ConcurrentHashmap？"},{"id":267345,"t":"35 | 设计评估和总结"},{"id":269149,"t":"36 | SaaS项目healthchecks.io的背景和架构（上）"},{"id":269150,"t":"37 | SaaS项目healthchecks.io的背景和架构（下）"},{"id":269158,"t":"38 | 如何设计一个轻量级的基于DB的延迟任务队列？"},{"id":269159,"t":"39 | 如何设计一把轻量级的锁？"},{"id":269160,"t":"40 | 如何设计一个分布式限流系统？"},{"id":269161,"t":"41 | 如何设计一个分布式TopK系统实现实时防爬虫？"},{"id":272500,"t":"42 | 第七章目标和大纲"},{"id":272501,"t":"43 | 为什么说ServiceMesh是微服务的未来(上)"},{"id":272503,"t":"44 | 为什么说ServiceMesh是微服务的未来(下)"},{"id":272504,"t":"45 | 解析Envoy Proxy(上)"},{"id":272506,"t":"46 | 解析Envoy Proxy(下)"},{"id":272507,"t":"47 | Envoy在Lyft的实践"},{"id":274743,"t":"48 | 解析Istio"},{"id":274748,"t":"49 | K8s Ingress、Istio Gateway和API Gateway该如何选择？(上)"},{"id":274749,"t":"50 | K8s Ingress、Istio Gateway和API Gateway该如何选择？(下)"},{"id":274751,"t":"51 | Spring Cloud、K8s和Istio该如何集成？"},{"id":278276,"t":"52 | 第八章目标和大纲"},{"id":278278,"t":"53 | 拍拍贷案例：大型网站架构是如何演进的？"},{"id":278282,"t":"54 | 最小可用架构：Minimum Viable Architecture（上）"},{"id":278283,"t":"55 | 最小可用架构：Minimum Viable Architecture（下）"},{"id":278284,"t":"56 | 如何构建基于OAuth2/JWT的微服务架构？（上）"},{"id":278288,"t":"57 | 如何构建基于OAuth2/JWT的微服务架构？（下）"},{"id":278290,"t":"58 | 拍拍贷案例：如何实现数据中心机房的迁移？"},{"id":278291,"t":"59 | 携程/Netflix案例：如何实现同城双活和异地多活？"},{"id":280829,"t":"60 | 第九章大纲"},{"id":280830,"t":"61 | 学习开源项目的6个层次和8种方法（上）"},{"id":280832,"t":"62 | 学习开源项目的6个层次和8种方法（中）"},{"id":280833,"t":"63 | 学习开源项目的6个层次和8种方法（下）"},{"id":280834,"t":"64 | 百万年薪架构师是如何炼成的？"},{"id":280835,"t":"65 | 解读一份大厂的研发岗职级体系"},{"id":280836,"t":"66 | 结课测试&结束语"}]},{"id":100768101,"n":"大模型微调实践课","a":"赵鹏昊/李杰","f":true,"c":12,"p":12,"l":[{"id":776559,"t":"01｜大模型的发展：从GPT-1到ChatGPT的发展历程"},{"id":776560,"t":"02｜Prompt调教指南：大模型的正确打开方式"},{"id":776561,"t":"03｜大模型的基石：认识Transformer"},{"id":776562,"t":"04｜检索增强生成（RAG）：如何让大模型回答更准确？"},{"id":776563,"t":"05｜模型评估：如何准确测评大模型的能力？"},{"id":776564,"t":"06｜微调数据准备：如何构造高质量微调数据？"},{"id":776565,"t":"07｜全量参数微调：如何让大模型完成特定领域任务？"},{"id":776566,"t":"08｜LoRA微调：如何高效微调大模型？"},{"id":776567,"t":"09｜Post-Pretrain：如何进一步注入领域知识？"},{"id":776568,"t":"10｜案例1：如何微调一个英语口语练习大模型？"},{"id":776569,"t":"11｜案例2：如何微调一个作文批改大模型？"},{"id":776570,"t":"12｜案例3：如何微调一个角色扮演大模型？"}]},{"id":100085401,"n":"如何讲好一堂课","a":"薛雨","f":true,"c":9,"p":9,"l":[{"id":408824,"t":"课程介绍"},{"id":408825,"t":"01 | 以学生为中心的课程设计底层逻辑"},{"id":408826,"t":"02 | 如何准备课程内容与素材"},{"id":408829,"t":"03 | 如何设计课程结构与逻辑"},{"id":408830,"t":"04 | 如何包装课程形式与呈现"},{"id":408831,"t":"05 | 还原一个真实的课堂：教学七步法"},{"id":408832,"t":"06 | 教学工作的基本环节与优秀课堂的标准"},{"id":408833,"t":"07 | 教学与备课进阶过程：七步迭代法打磨课程"},{"id":408834,"t":"08 | 如何设计课程亮点与互动：锁定学生的注意力"}]},{"id":100060601,"n":"张汉东的Rust实战课","a":"张汉东","f":true,"c":174,"p":174,"l":[{"id":286518,"t":"01 | 课程介绍"},{"id":286519,"t":"02 | 内容综述"},{"id":312303,"t":"学习方法推荐与课程组织逻辑"},{"id":286520,"t":"03 | Rust语言学习观"},{"id":286521,"t":"04 | Rust语言概览"},{"id":286522,"t":"05 | 语法面面观：词法结构"},{"id":289993,"t":"06 | 语法面面观：面向表达式（一）"},{"id":289994,"t":"07 | 语法面面观：面向表达式（二）"},{"id":290168,"t":"08 | 语法面面观：面向表达式（三）"},{"id":292838,"t":"09 | 语法面面观：数据类型 （一）"},{"id":292839,"t":"10 | 语法面面观：数据类型 （二）"},{"id":294648,"t":"11 | 语法面面观：函数与闭包（一）"},{"id":294649,"t":"12 | 语法面面观：函数与闭包（二）"},{"id":294650,"t":"13 | 语法面面观：函数与闭包（三）"},{"id":294651,"t":"14 | 语法面面观：模式匹配"},{"id":296421,"t":"15 | 语法面面观：智能指针（一）"},{"id":296422,"t":"16 | 语法面面观：智能指针（二）"},{"id":298930,"t":"17 | 语法面面观：字符与字符串（一）"},{"id":298931,"t":"18 | 语法面面观：字符与字符串（二）"},{"id":298932,"t":"19 | 语法面面观：集合容器（一）"},{"id":301762,"t":"20 | 语法面面观：集合容器（二）"},{"id":301763,"t":"21 | 语法面面观：迭代器（一）"},{"id":301765,"t":"22 | 语法面面观：迭代器（二）"},{"id":304936,"t":"23 | Rust语法面面观：模块"},{"id":304935,"t":"24 | 语法面面观：Cargo包管理器（一）"},{"id":304934,"t":"25 | 语法面面观：Cargo包管理器（二）"},{"id":307549,"t":"26 | 语法面面观：实际项目的组织结构（一）"},{"id":307550,"t":"27 | 语法面面观：实际项目的组织结构（二）"},{"id":309715,"t":"28 | 语法面面观：定义自己的Crate（一）"},{"id":309723,"t":"29 | 语法面面观：定义自己的Crate（二）"},{"id":309722,"t":"30 | 语法面面观：定义自己的Crate（三）"},{"id":307551,"t":"31 | 作业&第二章预告"},{"id":312825,"t":"32 | 本章内容介绍：Rust语言架构"},{"id":312827,"t":"33 | 所有权：内存管理基础知识"},{"id":312826,"t":"34 | 所有权：安全管理之内存安全"},{"id":316828,"t":"35 | 所有权：Copy语义和Copy trait"},{"id":316829,"t":"36 | 所有权：深入理解Copy行为"},{"id":316827,"t":"37 | 所有权：深入理解Move语义"},{"id":319371,"t":"38 | 所有权：Move与析构"},{"id":319372,"t":"39 | 借用检查： 完全理解Scope和NLL"},{"id":319373,"t":"40 | 借用检查： 深入理解生命周期和生命周期参数"},{"id":322364,"t":"41 | 借用检查： 深入理解生命周期参数Early bound"},{"id":322365,"t":"42 | 借用检查：深入理解生命周期参数Tvs&T"},{"id":322366,"t":"43 | 借用检查： 深入理解生命周期参数： trait对象的生命周期参数"},{"id":324835,"t":"44 | 借用检查： 深入理解生命周期参数：高阶生命周期（一）"},{"id":324836,"t":"45 | 借用检查： 深入理解生命周期参数：高阶生命周期（二）"},{"id":324837,"t":"46 | 借用检查： 深入理解生命周期参数：高阶生命周期（三）"},{"id":327158,"t":"47 | 线程与并发：理解线程与并发"},{"id":327159,"t":"48 | 线程与并发：线程间安全共享数据"},{"id":330078,"t":"49 | 线程与并发：构建「无悔」并发系统（一）"},{"id":330080,"t":"50 | 线程与并发：构建「无悔」并发系统（二）"},{"id":330081,"t":"51 | 线程与并发：构建「无悔」并发系统（三）"},{"id":342125,"t":"52 | 线程与并发：构建「无悔」并发系统（四）"},{"id":342126,"t":"53 | 线程与并发：无锁并发（一）"},{"id":342127,"t":"54 | 线程与并发：无锁并发（二）"},{"id":342128,"t":"55 | 线程与并发：无锁并发（三）"},{"id":342129,"t":"56 | trait与泛型：trait静态分发"},{"id":342130,"t":"57 | trait与泛型：认识trait对象"},{"id":342135,"t":"58 | trait与泛型：泛型和trait实现模板方法"},{"id":342136,"t":"59 | trait与泛型：trait对象本质"},{"id":342137,"t":"60 | trait与泛型：对象安全本质"},{"id":342138,"t":"61 | trait与泛型：利用Enum代替trait对象"},{"id":342139,"t":"62 | trait与泛型：trait覆盖实现的一个解决方案"},{"id":346352,"t":"63 | trait与泛型：trait对象与Sized"},{"id":346353,"t":"64 | trait与泛型：trait对象与Box Self"},{"id":346354,"t":"65 | 编程范式：Rust语言编程范式讨论（一）"},{"id":347426,"t":"66 | 编程范式：Rust语言编程范式讨论（二）"},{"id":347427,"t":"67 | Rust错误处理概要"},{"id":347429,"t":"68 | Rust错误处理：Option"},{"id":348797,"t":"69 | Rust错误处理：Result（一）"},{"id":348798,"t":"70 | Rust错误处理：Result（二）"},{"id":348799,"t":"71 | Rust错误处理：try"},{"id":348800,"t":"72 | Rust错误处理：Panic"},{"id":352950,"t":"73 | Rust元编程之反射"},{"id":352951,"t":"74 | Rust元编程之反射的两种应用思路"},{"id":354760,"t":"75 | Rust元编程之编译过程与宏展开概述"},{"id":354761,"t":"76 | Rust元编程之声明宏（一）"},{"id":354762,"t":"77 | Rust元编程之声明宏（二）"},{"id":357554,"t":"78 | Rust元编程之过程宏：三件套介绍"},{"id":357556,"t":"79 | Rust元编程之过程宏：Bang宏实现原理"},{"id":357558,"t":"80 | Rust元编程之过程宏：使用配置文件动态生成代码"},{"id":357936,"t":"81 | Rust元编程之过程宏：Derive宏案例"},{"id":357938,"t":"82 | Rust元编程之过程宏：属性宏"},{"id":357941,"t":"83 | 客观理解Unsafe Rust"},{"id":362929,"t":"84 | Unsafe Rust安全抽象"},{"id":362930,"t":"85 | Unsafe Rust安全抽象：Drop检查"},{"id":362931,"t":"86 | Unsafe Rust安全抽象：型变"},{"id":365834,"t":"87 | UnsafeRust的其他知识点"},{"id":365835,"t":"88 | Rust异步编程之IO模型"},{"id":365838,"t":"89 | Rust异步编程之epoll和io_uring"},{"id":367808,"t":"90 | Rust异步编程之事件驱动编程模型"},{"id":367809,"t":"91 | Rust异步编程之epoll代码实践"},{"id":367810,"t":"92 | Rust异步编程之Reactor代码实践"},{"id":367816,"t":"93 | Rust异步编程之MiniMio代码实践"},{"id":367817,"t":"94 | Rust异步编程之Mio代码实践（一）"},{"id":367818,"t":"95 | Rust异步编程之Mio代码实践（二）"},{"id":373285,"t":"96 | Rust异步编程之异步编程模型概要"},{"id":373286,"t":"97 | Rust异步编程之Future和Futures-rs介绍"},{"id":373287,"t":"98 | Rust异步编程之编写异步echo服务（一）"},{"id":375586,"t":"99 | Rust异步编程之编写异步echo服务（二）"},{"id":375588,"t":"100 | Rust异步编程之编写异步echo服务（三）"},{"id":375589,"t":"101 | Rust异步编程之深入理解异步Task模型"},{"id":375590,"t":"102 | Rust异步编程之Waker实现"},{"id":375591,"t":"103 | Rust异步编程之Futures库源码导读（一）"},{"id":375594,"t":"104 | Rust异步编程之Futures库源码导读（二）"},{"id":380720,"t":"105 | Rust异步编程之Futures库源码导读（三）"},{"id":380721,"t":"106 | Rust异步编程之Futures库源码导读（四）"},{"id":380722,"t":"107 | Rust异步编程之async-await语法背后"},{"id":380723,"t":"108 | Rust异步编程之生成器（一）"},{"id":380725,"t":"109 | Rust异步编程之生成器（二）"},{"id":385493,"t":"110 | Rust异步编程之Pin与Unpin(一)"},{"id":385494,"t":"111 | Rust异步编程之Pin与Unpin(二)"},{"id":385495,"t":"112 | Rust异步编程之Pin与Unpin(三）"},{"id":387983,"t":"113 | Rust异步编程之Pin与Unpin（四）"},{"id":387984,"t":"114 | Rust异步编程之no-std异步生态介绍"},{"id":389757,"t":"115 | Rust异步编程之实现异步缓存（一）"},{"id":389759,"t":"116 | Rust异步编程之实现异步缓存（二）"},{"id":389878,"t":"117 | Rust异步编程之异步运行时生态介绍"},{"id":389879,"t":"118 | Rust异步编程之smol运行时（一）"},{"id":389881,"t":"119 | Rust异步编程之smol运行时（二）"},{"id":394373,"t":"120 | Rust异步编程之smol运行时（三）"},{"id":394379,"t":"121 | Rust异步编程之smol运行时（四）"},{"id":394381,"t":"122 | Rust异步编程之smol运行时（五）"},{"id":394384,"t":"123 | Rust异步编程之smol运行时（六）"},{"id":394387,"t":"124 | Rust异步编程之smol运行时（七）"},{"id":394435,"t":"125 | Rust异步编程之smol运行时（八）"},{"id":394436,"t":"126 | Rust异步编程之smol运行时（九）"},{"id":394438,"t":"127 | Rust异步编程之smol运行时（十）"},{"id":394440,"t":"128 | Rust异步编程之async-std运行时（一）"},{"id":394443,"t":"129 | Rust异步编程之async-std运行时（二）"},{"id":407241,"t":"130 | Rust异步编程之tokio运行时（一）"},{"id":407242,"t":"131 | Rust异步编程之tokio运行时（二）"},{"id":407244,"t":"132 | Rust异步编程之tokio运行时（三）"},{"id":407245,"t":"133 | Rust异步编程之tokio运行时（四）"},{"id":407247,"t":"134 | Rust异步编程之tokio运行时（五）"},{"id":407248,"t":"135 | Rust异步编程之tokio运行时（六）"},{"id":409097,"t":"136 | Rust异步编程之tokio运行时（七）"},{"id":409098,"t":"137 | Rust异步编程之tokio运行时（八）"},{"id":409100,"t":"138 | Rust异步编程之tokio运行时（九）"},{"id":409107,"t":"139 | Rust异步编程之tokio运行时（十）"},{"id":413457,"t":"140 | Rust异步Web框架开篇"},{"id":413462,"t":"141 | Rust异步Web框架之Rocket（一）"},{"id":413464,"t":"142 | Rust异步Web框架之Rocket（二）"},{"id":413465,"t":"143 | Rust异步Web框架之Rocket（三）"},{"id":413466,"t":"144 | Rust异步Web框架之tide"},{"id":413467,"t":"145 | Rust异步Web框架之actix-web（一）"},{"id":413468,"t":"146 | Rust异步Web框架之actix-web（二）"},{"id":413469,"t":"147 | Rust异步Web框架之gotham-and-thruster"},{"id":413470,"t":"148 | Rust异步Web框架之tower（一）"},{"id":413471,"t":"149 | Rust异步Web框架之tower（二）"},{"id":413472,"t":"150 | Rust异步Web框架之hyper（一）"},{"id":413473,"t":"151 | Rust异步Web框架之hyper（二）"},{"id":413474,"t":"152 | Rust异步Web框架之hyper（三）"},{"id":413475,"t":"153 | Rust异步Web框架之warp"},{"id":422148,"t":"154 | Web框架实战之HTTP库介绍"},{"id":422149,"t":"155 | Web框架实战之了解hyper-tower_http-http-body之间的层次关系"},{"id":422151,"t":"156 | Web框架实战之创建初始项目"},{"id":422152,"t":"157 | Web框架实战之设计框架接口"},{"id":422155,"t":"158 | Web框架实战之实现路由结构"},{"id":422167,"t":"159 | Web框架实战之实现路由结构（二）"},{"id":422169,"t":"160 | Web框架实战之实现路由结构（三）"},{"id":423696,"t":"161 | Web 框架实战之实现路由结构（四）"},{"id":423695,"t":"162 | Web 框架实战之实现路由结构（五）"},{"id":423694,"t":"163 | Web 框架实战之实现 Handler（一）"},{"id":423693,"t":"164 | Web 框架实战之实现 Handler（二）"},{"id":423692,"t":"165 | Web 框架实战之实现 Handler（三）"},{"id":423698,"t":"166 | Web 框架实战之实现 Handler（四）"},{"id":423699,"t":"167 | Web 框架实战之添加 tracing 打印"},{"id":423700,"t":"168 | Web 框架实战之实现提取器（一）"},{"id":423701,"t":"169 | Web 框架实战之实现提取器（二）"},{"id":423702,"t":"170 | Web 框架实战之实现提取器（三）"},{"id":423703,"t":"171 | Web 框架实战之实现提取器和中间件（四）"},{"id":423704,"t":"172 | Web 框架实战之错误处理支持"},{"id":423705,"t":"173 | 课程完结回顾"}]},{"id":100821001,"n":"循序渐进精通AI编程之道","a":"蒋志伟","f":true,"c":27,"p":27,"l":[{"id":810601,"t":"课程介绍｜智能编程对企业及个人的价值"},{"id":810602,"t":"01｜Transformer模型等技术带来的AI发展里程碑"},{"id":810603,"t":"02｜AI大模型影响下智能编程的发展和演变"},{"id":810604,"t":"03｜国内外优秀智能编程工具汇总介绍"},{"id":812829,"t":"04｜代码大模型测评集HumanEval、MBPP介绍和评分原理"},{"id":812830,"t":"05｜主流编程工具的安装和使用模式"},{"id":812833,"t":"06｜基本使用实操：代码提示补全"},{"id":812854,"t":"07｜基本使用实操：高频致命缺陷查找"},{"id":812955,"t":"08｜基本使用实操：报错排查"},{"id":812956,"t":"09｜基本使用实操：辅助编程工具库与代码解释"},{"id":812957,"t":"10｜工程师如何通过AI编程全面提升技术能力？"},{"id":816247,"t":"11｜如何设计Prompt？仿写服务技巧和思路"},{"id":816248,"t":"12｜API和开发文档生成技巧和模版设计"},{"id":816249,"t":"13｜单元测试、接口服务测试技巧和模版设计"},{"id":816273,"t":"14｜数据建模表设计和SQL生成"},{"id":816289,"t":"15｜代码大模型检索增强生成RAG和微调Fine-tuning"},{"id":816290,"t":"16｜项目构建和多轮对话技巧与实操"},{"id":816294,"t":"17｜真实项目0-1完整实操低代码生成"},{"id":818131,"t":"18｜火爆全球的Cursor AI编程工具介绍"},{"id":818132,"t":"19｜Cursor AI 功能亮点实操1：代码自动补全多行编辑"},{"id":818133,"t":"20｜Cursor AI 功能亮点实操2：Inline Chat 和上下文增强"},{"id":822339,"t":"21｜Cursor AI 功能亮点实操3：Composer"},{"id":822340,"t":"22｜Cursor代码生成质量和业界编程工具测评对比"},{"id":818836,"t":"23｜企业级智能编程解决方案介绍和思考"},{"id":818837,"t":"24｜企业级智能编程提效真实落地案例分享"},{"id":818838,"t":"25｜企业引入智能编程提效的解决方案入门"},{"id":818839,"t":"26｜企业级智能编程解决方案选型总结"}]},{"id":100007001,"n":"微服务架构实战160讲","a":"杨波","f":true,"c":171,"p":171,"l":[{"id":6932,"t":"01 | 第一模块课程介绍"},{"id":6933,"t":"02 | 微服务安全要解决什么问题"},{"id":6934,"t":"03 | 白话 OAuth2"},{"id":6936,"t":"04 | OAuth2 的正式定义"},{"id":6937,"t":"05 | OAuth2 有哪些典型模式"},{"id":6938,"t":"06 | OAuth2 模式该如何选型"},{"id":6945,"t":"07 | Spring Security OAuth2 架构简介"},{"id":6948,"t":"08 |【实验】授权码模式授权服务器"},{"id":6947,"t":"09 |【实验】简化模式授权服务器"},{"id":6949,"t":"10 |【实验】密码模式授权服务器"},{"id":7153,"t":"11 |【实验】客户端模式授权服务器"},{"id":7154,"t":"12 | 实验一扩展环节"},{"id":7155,"t":"13 |【实验】Web 应用接入授权服务器"},{"id":7156,"t":"14 | 实验二扩展环节"},{"id":7157,"t":"15 | 什么是 JWT 令牌"},{"id":7158,"t":"16 |【实验】授权服务器支持 JWT 令牌"},{"id":7159,"t":"17 | 实验三扩展环节"},{"id":7160,"t":"18 |【实验】Android 无线应用接入授权服务器"},{"id":7507,"t":"19 |【实验】AngularJS 单页应用实验和课后扩展"},{"id":7508,"t":"20 |【实验】GitHub社交登录实验和课后扩展"},{"id":7509,"t":"21 | 【实验】OAuth2安全风险CSRF实验"},{"id":7510,"t":"22 | OpenId Connect简介"},{"id":7511,"t":"23 | 下一代微服务安全架构"},{"id":7512,"t":"24 | 参考资源和后续课程预览"},{"id":8832,"t":"25 | Apollo作者的产品介绍"},{"id":8833,"t":"26 | 第二模块课程介绍"},{"id":8834,"t":"27 | 课程概述"},{"id":8835,"t":"28 | 业务需求"},{"id":8836,"t":"29 | 配置定义和场景"},{"id":8838,"t":"30 | 开关驱动开发原理"},{"id":8839,"t":"31 | 携程 Apollo 配置中心介绍"},{"id":8840,"t":"32 | Apollo核心概念"},{"id":8841,"t":"33 | Apollo快速起步(Lab01)"},{"id":8842,"t":"34 | Apollo快速起步扩展实验"},{"id":8843,"t":"35 | Apollo架构设计之服务器端"},{"id":8844,"t":"36 | Apollo架构设计之客户端"},{"id":8845,"t":"37 | Apollo架构设计之高可用和监控"},{"id":8846,"t":"38 | Apollo分布式部署指南"},{"id":8847,"t":"39 | Apollo Java客户端和多语言接入"},{"id":8848,"t":"40 | Apollo Client API实操(Lab02)"},{"id":8849,"t":"41 | Apollo Client和Spring集成~XML方式(Lab03)"},{"id":8850,"t":"42 | Apollo Client和Spring集成~代码方式(Lab04)"},{"id":8851,"t":"43 | Apollo Client和Spring Boot集成(Lab05)"},{"id":8907,"t":"44 |  Apollo开放平台接入实操(Lab06)"},{"id":8908,"t":"45 | Spring Cloud Config简介"},{"id":8909,"t":"46 | Apollo vs Spring Cloud Config"},{"id":8910,"t":"47 | Apollo FAQ和开发常见问题"},{"id":8911,"t":"48 | 参考资源和后续课程预览"},{"id":10577,"t":"49 | 第三模块课程介绍"},{"id":10578,"t":"50 | Zuul网关和基本应用场景"},{"id":10579,"t":"51 | Zuul网关高级应用场景"},{"id":10580,"t":"52 | Zuul网关架构剖析"},{"id":10581,"t":"53 | Zuul网关代码剖析(Code Review)"},{"id":10582,"t":"54 | Zuul网关过滤器管理工具(Code Review)"},{"id":10583,"t":"55 | 前置过滤器实验(Lab01)"},{"id":10584,"t":"56 | 路由过滤器实验(Lab02)"},{"id":10585,"t":"57 | 后置过滤器实验(Lab03)"},{"id":10586,"t":"58 | Zuul网关对接Apollo(Lab04)"},{"id":10587,"t":"59 | Zuul网关生产部署实践"},{"id":10588,"t":"60 | Zuul网关路由管理实践"},{"id":10589,"t":"61 | 基于网关的两层路由体系"},{"id":10590,"t":"62 | Spring Cloud Zuul(Lab05)"},{"id":10591,"t":"63 | Zuul2.0简介"},{"id":10592,"t":"64 | Zuul网关生产最佳实践"},{"id":10593,"t":"65 | 参考资源和后续课程预览"},{"id":12677,"t":"66 | 第四模块课程介绍"},{"id":12680,"t":"67 | 调用链监控业务需求"},{"id":12681,"t":"68 | 调用链监控原理"},{"id":12692,"t":"69 | 调用链监控产品和比较"},{"id":12693,"t":"70 | 点评 CAT 背景介绍"},{"id":12694,"t":"71 | CAT 典型报表"},{"id":12695,"t":"72 | CAT 告警简介"},{"id":12696,"t":"73 | CAT 架构设计"},{"id":12697,"t":"74 |【实验】CAT 本地部署"},{"id":12698,"t":"75 | CAT 埋点案例和代码剖析（Code Review）"},{"id":12709,"t":"76 |【实验】CAT 埋点案例"},{"id":12710,"t":"77 | Zuul 网关集成 CAT 代码剖析（Code Review）"},{"id":12711,"t":"78 |【实验】Zuul 网关集成 CAT"},{"id":12712,"t":"79 | CAT 生产埋点实践"},{"id":12713,"t":"80 | CAT 生产部署实践"},{"id":12714,"t":"81 | CAT 生产治理实践"},{"id":12716,"t":"82 | Spring Cloud Sleuth 简介"},{"id":12717,"t":"83 |【实验】Spring Cloud Sleuth"},{"id":12720,"t":"84 | 参考资源和后续课程预览"},{"id":17774,"t":"85 | 第五模块课程介绍"},{"id":17778,"t":"86 | 容错限流需求"},{"id":17782,"t":"87 | 容错限流原理"},{"id":17787,"t":"88 | Netflix Hystrix 背景介绍"},{"id":17791,"t":"89 | Hystrix 设计原理"},{"id":17794,"t":"90 | Hystrix 主要概念"},{"id":17798,"t":"91 | 信号量 vs 线程池隔离"},{"id":17801,"t":"92 | Hystrix 主要配置项"},{"id":17804,"t":"93 |【实验】Hystrix 基础实验"},{"id":17807,"t":"94 | Hystrix 模拟案例分析 (Code Review)"},{"id":17811,"t":"95 |【实验】Hystrix + Dashboard 实验（上）"},{"id":17814,"t":"96 |【实验】Hystrix + Dashboard 实验（下）"},{"id":17815,"t":"97 | 网关集成 Hystrix (Code Review)"},{"id":17818,"t":"98 |【实验】Spring Cloud Hystrix 实验"},{"id":17819,"t":"99 | Netflix Turbine 简介"},{"id":17820,"t":"100 | Hystrix 生产最佳实践"},{"id":17821,"t":"101 | 参考资源和后续课程预览"},{"id":41722,"t":"102 | 第六模块课程介绍"},{"id":41723,"t":"103 | 服务发现需求和模式（上）"},{"id":41724,"t":"104 | 服务发现需求和模式（下）"},{"id":41725,"t":"105 | Netflix Eureka 和 Ribbon 背景介绍"},{"id":41726,"t":"106 | Eureka 和 Ribbon 架构设计原理"},{"id":41727,"t":"107 |【实验】Spring Cloud Eureka 和 Ribbon 基础实战"},{"id":41728,"t":"108 |【实验】Spring Cloud Eureka 和 Ribbon 高级实验"},{"id":41729,"t":"109 | Spring Cloud Eureka 和 Ribbon 主要配置项"},{"id":41750,"t":"110 | Eureka进阶：自保护模式"},{"id":41752,"t":"111 | Eureka进阶：健康检查和蓝绿部署"},{"id":41753,"t":"112 |【实验】Spring Cloud Zuul、Eureka 和 Ribbon 集成实验（上）"},{"id":41754,"t":"113 |【实验】Spring Cloud Zuul、Eureka 和 Ribbon 集成实验（下）"},{"id":41755,"t":"114 | 常用服务发现组件比较"},{"id":41756,"t":"115 | ServiceMesh 和 Istio 简介"},{"id":41757,"t":"116 | 基于 Eureka、Zuul 和容器云的持续交付架构"},{"id":41759,"t":"117 | 参考资源和后续课程预览"},{"id":67668,"t":"118 | 第七模块课程介绍"},{"id":67669,"t":"119 | 监控模式分类"},{"id":67670,"t":"120 | BusDevOps 和测量驱动开发 MDD"},{"id":67671,"t":"121 | Prometheus 简介"},{"id":67672,"t":"122 | Prometheus 架构设计"},{"id":67673,"t":"123 | Prometheus 基本概念"},{"id":67674,"t":"124 |【实验】Prometheus 起步查询实验（上）"},{"id":67675,"t":"125 |【实验】Prometheus起步查询实验（中）"},{"id":67676,"t":"126 |【实验】Prometheus起步查询实验（下）"},{"id":67677,"t":"127 |【实验】Prometheus + Grafana 展示实验（上）"},{"id":67678,"t":"128 |【实验】Prometheus + Grafana 展示实验（下）"},{"id":67679,"t":"129 |【实验】Prometheus + Alertmanager 告警实验（上）"},{"id":67680,"t":"130 |【实验】Prometheus + Alertmanager 告警实验（下）"},{"id":67681,"t":"131 |【实验】Java 应用埋点和监控实验"},{"id":67682,"t":"132 |【实验】NodeExporter 系统监控实验"},{"id":67683,"t":"133 |【实验】Spring Boot Actuator 监控实验"},{"id":67684,"t":"134 | Prometheus 监控最佳实践"},{"id":67685,"t":"135 | 主流开源时序数据库比较"},{"id":67686,"t":"136 | 开源分布式监控平台 ZMon 简介"},{"id":67687,"t":"137 | 微服务监控体系总结"},{"id":67688,"t":"138 | 参考资源和后续课程预览"},{"id":72975,"t":"139 | 课程概述和背景"},{"id":72976,"t":"140 | 架构和设计"},{"id":74202,"t":"141 | 开发环境搭建"},{"id":72978,"t":"142 | 基础代码(code review)"},{"id":72979,"t":"143 | 数据访问模块(code review)"},{"id":72980,"t":"144 | OAuth2服务模块(code review)"},{"id":72981,"t":"145 | Web服务模块(code review)"},{"id":72982,"t":"146 | 启动流程(code review)"},{"id":72983,"t":"147 | 起步准备实验(lab02)"},{"id":72984,"t":"148 | OAuth2授权码模式实验(lab03)"},{"id":72985,"t":"149 | OAuth2简化模式实验(lab04)"},{"id":72986,"t":"150 | OAuth2用户名密码模式实验(lab05)"},{"id":72987,"t":"151 | OAuth2客户端模式实验(lab06)"},{"id":72988,"t":"152 | OAuth2令牌校验实验(lab07)"},{"id":72989,"t":"153 | OAuth2令牌刷新实验(lab08)"},{"id":72990,"t":"154 | 项目复盘和扩展环节"},{"id":72991,"t":"155 | 参考资源和后续课程预览"},{"id":73095,"t":"156 | 课程概述和背景"},{"id":73938,"t":"157 | 需求和架构设计"},{"id":73939,"t":"158 | 开发环境搭建(lab01)（上）"},{"id":73941,"t":"159 | 开发环境搭建(lab01)（下）"},{"id":73942,"t":"160 | 项目业务代码(Code Review)"},{"id":73943,"t":"161 | Apollo配置中心集成(lab02)"},{"id":73944,"t":"162 | Zuul-Eureka-Ribbon-Hystrix集成(Code Review)"},{"id":73945,"t":"163 | Gravitee OAuth2集成(lab03)"},{"id":73946,"t":"164 | Zuul网关集中令牌校验(Code Review)"},{"id":73947,"t":"165 | CAT调用链集成(lab04)（上）"},{"id":73948,"t":"166 | CAT调用链集成(lab04)（下）"},{"id":73949,"t":"167 | Demo展示(lab05)（上）"},{"id":73950,"t":"168 | Demo展示(lab05)（下）"},{"id":73951,"t":"169 | Prometheus监控集成(Code Review)"},{"id":73952,"t":"170 | 生产扩展环节"},{"id":73953,"t":"171 | 课程复盘总结&结课测试"}]},{"id":100003901,"n":"微服务架构核心20讲","a":"杨波","f":true,"c":20,"p":20,"l":[{"id":2184,"t":"01 | 什么是微服务架构？"},{"id":2185,"t":"02 | 架构师如何权衡微服务的利弊？"},{"id":2154,"t":"03 | 康威法则和微服务给架构师怎样的启示？"},{"id":2186,"t":"04 | 企业应该在什么时候开始考虑引入微服务？"},{"id":2187,"t":"05 | 什么样的组织架构更适合微服务？"},{"id":2188,"t":"06 | 如何理解阿里巴巴提出的微服务中台战略？"},{"id":2189,"t":"07 | 如何给出一个清晰简洁的服务分层方式？"},{"id":2222,"t":"08 | 微服务总体技术架构体系是怎样设计的？"},{"id":2269,"t":"09 | 微服务最经典的三种服务发现机制"},{"id":2270,"t":"10 | 微服务 API 服务网关（一）原理"},{"id":2271,"t":"11 | 微服务 API 服务网关（二）开源网关 Zuul"},{"id":2272,"t":"12 | 跟 Netflix 学习微服务路由发现体系"},{"id":2273,"t":"13 | 集中式配置中心的作用和原理是什么？"},{"id":2274,"t":"14 | 微服务通讯方式 RPC vs REST"},{"id":2275,"t":"15 | 微服务框架需要考虑哪些治理环节？"},{"id":2276,"t":"16 | 微服务监控系统分层和监控架构"},{"id":2277,"t":"17 | 微服务的调用链监控该如何选型？"},{"id":2278,"t":"18 | 微服务的容错限流是如何工作的？"},{"id":2279,"t":"19 | Docker 容器部署技术 & 持续交付流水线"},{"id":2280,"t":"20 | 容器集群调度和基于容器的发布体系&结课测试"}]},{"id":100009801,"n":"快速上手Kotlin开发","a":"张涛","f":true,"c":50,"p":50,"l":[{"id":10663,"t":"01 | 讲给你的 Kotlin 快速上手课程"},{"id":10664,"t":"02 | Kotlin 最基础语法"},{"id":10665,"t":"03 | Kotlin 与 Java 完全兼容，就可以随便调用了吗？"},{"id":10666,"t":"04 | 新手使用 Kotlin 常碰到的问题"},{"id":10667,"t":"05 | 函数也能嵌套？这个特性要注意"},{"id":10668,"t":"06 | 用扩展函数简化代码调用"},{"id":10669,"t":"07 | DSL的基础 : Lambda闭包的语法"},{"id":10670,"t":"08 | 函数的参数是函数 : 高阶函数的注意事项"},{"id":10671,"t":"09 | 创建对象的关键 : Kotlin的构造函数"},{"id":10672,"t":"10 | 伴生对象 : Kotlin 特有的单例对象"},{"id":10673,"t":"11 | by关键字的使用"},{"id":10674,"t":"12 | Kotlin 独有的特殊类"},{"id":12036,"t":"13 | 解构 : 特殊的数据拆箱方式"},{"id":12037,"t":"14 | Kotlin 的循环语法"},{"id":12038,"t":"15 | Kotlin海量的集合操作符"},{"id":12039,"t":"16 | 作用域函数 : 你会爱上的自带函数"},{"id":12040,"t":"17 | 运算符与中缀 : 定义你的专有运算符"},{"id":12041,"t":"18 | 神奇的符号 : Kotlin 的反引号"},{"id":12042,"t":"19 | DSL 是什么，原来早就用过了"},{"id":12043,"t":"20 | 构建 DSL 的常用方式"},{"id":12044,"t":"21 | 定义自己的 DSL"},{"id":12045,"t":"22 | 理解 Kotlin 中的常量与只读"},{"id":12046,"t":"23 | Kotlin 的空安全是如何实现的"},{"id":12047,"t":"24 | Kotlin 内联 : noinline与crossinline"},{"id":12048,"t":"25 | Kotlin 的真泛型与实现方式"},{"id":12049,"t":"26 | 协程 : 提升性能的利器"},{"id":12050,"t":"27 | 在Kotlin 中使用协程"},{"id":12051,"t":"28 | 协程的启动参数"},{"id":12052,"t":"29 | 协程的语法糖"},{"id":12053,"t":"30 | suspend : 知其然知其所以然"},{"id":12054,"t":"31 | 协程的内部实现原理"},{"id":12055,"t":"32 | 动手设计Kotlin 协程的yield"},{"id":12056,"t":"33 | 协程通信：Channel的使用"},{"id":12106,"t":"34 | 小结 : 动手设计Channel版的EventBus"},{"id":13363,"t":"35 | NIO 与 BIO"},{"id":13364,"t":"36 | Kotlinx-io 的对象缓存池"},{"id":13365,"t":"37 | Google 推出 KTX 的目的"},{"id":13366,"t":"38 | KTX 的实现"},{"id":13367,"t":"39 | KTX 小结"},{"id":13368,"t":"40 | 在团队中使用 Kotlin"},{"id":13369,"t":"41 | 用 Kotlin 改写现有工程"},{"id":13370,"t":"42 | 滥用特性的后果：没人懂的代码"},{"id":13371,"t":"43 | Kotlin 服务端开发框架"},{"id":13372,"t":"44 | Http Servlet 创建 Kotlin 版 Web 应用"},{"id":13373,"t":"45 | Spring Boot 创建 RESTful Web 服务"},{"id":13374,"t":"46 | Kotlin 开发 Web 前端"},{"id":13375,"t":"47 | Kotlin Native 开发"},{"id":13376,"t":"48 | 创建 Kotlin Native 基础库"},{"id":13377,"t":"49 | 如何用 Kotlin 实现 Android MVP"},{"id":13378,"t":"50 | Android MVP 的 Kotlin 代码&结课测试"}]},{"id":100824501,"n":"深入拆解数字化智能文档处理","a":"老刘","f":true,"c":14,"p":14,"l":[{"id":812722,"t":"01｜智能文档处理基本认知及处理流程"},{"id":812721,"t":"02｜智能文档处理 pipeline 式方案及数据集"},{"id":812732,"t":"03｜智能文档处理 end2end 式方案及数据集"},{"id":812723,"t":"04｜文档图表理解能够做的一些事儿"},{"id":812730,"t":"05｜大模型进行文档图表理解的代表项目"},{"id":813487,"t":"06｜多模态大模型到底理不理解文档图表"},{"id":813488,"t":"07｜大模型落地表格场景常见应用场景"},{"id":813489,"t":"08｜面向大模型处理的表格表示方案"},{"id":813490,"t":"09｜多模态大模型之 Visual-ChatGLM 及 MiniGPT4 系列"},{"id":813491,"t":"10｜多模态大模型之 Blip-2 图文模型"},{"id":813502,"t":"11｜多模态大模型之 CLIP 及 Qwen-VL"},{"id":813503,"t":"12｜文档智能的技术界定与核心环节"},{"id":813504,"t":"13｜文档智能的可用开源项目与实操案例"},{"id":813505,"t":"14｜文档智能与大模型结合的场景及方向"}]},{"id":100076701,"n":"爆款文案修炼手册","a":"乐剑峰","f":true,"c":33,"p":33,"l":[{"id":361651,"t":"01 | 关于这门课程：爆款文案的6项核心技能是什么？"},{"id":361662,"t":"02 | 商人还是艺人？职业文案的三观"},{"id":361664,"t":"03 | 月薪3万的文案，哪些是必备的独门技能？"},{"id":361666,"t":"04 | 5条路径，爆款标题不求人"},{"id":361668,"t":"05 | 5个标准，起个响亮好名字"},{"id":361669,"t":"06 | 6重境界，轻松写出广告语"},{"id":361670,"t":"07 | 文字传播力：案例揭秘"},{"id":361676,"t":"08 | 4W原则：如何寻找你的沟通指南针？"},{"id":361680,"t":"09 | WHY：如何瞄准文案的传播目标？"},{"id":361682,"t":"10 | WHO：如何圈定文案的接收人群？"},{"id":361683,"t":"11 | WHAT：如何用文案诠释产品的卖点？"},{"id":361685,"t":"12 | HOW：如何设计文案的沟通语感？"},{"id":361704,"t":"13 | 向经典致敬：为什么说现在的刷屏级创意，都是它们的二手货？"},{"id":361706,"t":"14 | 哪些广告，只用文案就够了？"},{"id":361708,"t":"15 | 哪些广告，不用文案也可以？"},{"id":361709,"t":"16 | 容易得奖的创意，都在用这6大模板（上）"},{"id":361711,"t":"17 | 容易得奖的创意，都在用这6大模板（下）"},{"id":361715,"t":"18 | 阅读心理学：如何打造文案的黄金结构？"},{"id":361725,"t":"19 | 克服冷脑：如何开始你的第一句？"},{"id":361726,"t":"20 | 5个结尾技巧，精彩不重样"},{"id":361727,"t":"21 | 8种方法，让长文案更好读"},{"id":361728,"t":"22 | 变废为宝：不放过任何边角料"},{"id":361730,"t":"23 | 刷牙测试法：如何修订你的文案"},{"id":361732,"t":"24 | 如何选择字体，让阅读成为悦读？"},{"id":362416,"t":"25 | 如何编排版式，建立视觉流通的秩序？"},{"id":362417,"t":"26 | 如何运用图片，让读者的眼睛乖乖听话？"},{"id":362418,"t":"27 | 如何制造文与图的化学反应？"},{"id":362419,"t":"28 | 文稿管理：公司没空教你的4个基本动作"},{"id":362422,"t":"29 | 创意，是个什么玩意？"},{"id":362425,"t":"30 | 5步秘笈，掌握创意诞生的规律"},{"id":362426,"t":"31 | 3种动脑游戏，学会“多快好省”"},{"id":362427,"t":"32 | 迷宫理论：创意的评判法则"},{"id":362430,"t":"33 | 如何找到最难的核心创意，并延展成系列广告"}]},{"id":100769201,"n":"玩转AI创意写作","a":"于菁健","f":true,"c":26,"p":26,"l":[{"id":777261,"t":"前言｜AI可以代替人创作吗？"},{"id":777262,"t":"01｜写作是工程：用工程思维理解写作"},{"id":777263,"t":"02｜写作是模仿：解决模糊量化，实现精准表达"},{"id":777264,"t":"03｜写作是整合：主题+逻辑+形式=有效整合"},{"id":777265,"t":"04｜写作是选择：AI给你更多选择，你怎样选择更好"},{"id":777266,"t":"05｜写作是抒情：让AI帮你做情感观察员"},{"id":777267,"t":"06｜写作是迭代：从控制论透彻理解反馈的思想内涵"},{"id":777268,"t":"07｜写作是个性：人类的天性是成为少数人"},{"id":777269,"t":"08｜模块一总结课：AI+写作"},{"id":777270,"t":"09｜结构之美：超级结构是写作的基石"},{"id":777271,"t":"10｜节奏之美：写作是一门语言的艺术"},{"id":777272,"t":"11｜风格之美：形成风格是写作的最高境界"},{"id":777273,"t":"12｜逻辑之美：发挥AI逻辑论证的能力"},{"id":777274,"t":"13｜故事之美：戏剧手法是写作的核武器"},{"id":777275,"t":"14｜模式之美：抓住每一个跑通的文本模式"},{"id":777276,"t":"15｜想象之美：AI助力与你一起头脑风暴"},{"id":779991,"t":"16｜模块二总结课：写作+AI"},{"id":781225,"t":"17｜个体认知：我们究竟为什么而写作"},{"id":781226,"t":"18｜个体系统：AI助你书写你的人生"},{"id":781227,"t":"19｜个体定位：找到你从事写作的目标和定位"},{"id":781228,"t":"20｜个体升级：为什么伟大不可以被计划"},{"id":781229,"t":"21｜模仿+：用人工拆解解决AI模仿"},{"id":781230,"t":"22｜迭代+：高级的迭代就有高级的收获"},{"id":781231,"t":"23｜整合+：整合是一项系统工程"},{"id":781232,"t":"24｜个体+：AI陪伴你走向超级个体"},{"id":781233,"t":"结语｜致敬超级个体的英雄之旅"}]},{"id":100843901,"n":"玩转AI大模型时代的数据思维","a":"王曦 ","f":true,"c":26,"p":26,"l":[{"id":831979,"t":"01｜AI 时代，⽤冷静的数据思维，解决复杂的商业问题"},{"id":832029,"t":"02｜了解你的市场：⽤ “概率逻辑” 做出最有⼒的商业计划"},{"id":832334,"t":"03｜让⽤户看到你：⽤ “习惯逻辑” 抓住⽤户的注意⼒"},{"id":832385,"t":"04｜让⽤户选择你：⽤ “价值逻辑” 赢得关键⽤户（上）"},{"id":832387,"t":"05｜让⽤户选择你：⽤ “价值逻辑” 赢得关键⽤户（下）"},{"id":832388,"t":"06｜让⽤户依赖你：⽤ “迭代逻辑” 增加⽤户黏性（上）"},{"id":832389,"t":"07｜让⽤户依赖你：⽤ “迭代逻辑” 增加⽤户黏性（下）"},{"id":832451,"t":"08｜总结与加餐：上个台阶"},{"id":833289,"t":"09｜降本增效：让 “优化逻辑” 帮你实现智慧运营（上）"},{"id":833303,"t":"10｜降本增效：让 “优化逻辑” 帮你实现智慧运营（下）"},{"id":833304,"t":"11｜抵御⻛险：让 “柔性逻辑” 帮你从容应对变局"},{"id":833305,"t":"12｜数字化建设：让 “决策逻辑” 帮你选择⽅向（上）"},{"id":833306,"t":"13｜数字化建设：让 “决策逻辑” 帮你选择⽅向（下）"},{"id":833307,"t":"14｜总结与加餐：上个台阶"},{"id":834645,"t":"15｜打造团队⽂化：你得拥有 “算法逻辑” （上）"},{"id":834646,"t":"16｜打造团队⽂化：你得拥有 “算法逻辑” （下）"},{"id":834647,"t":"17｜选⼈：⽤ “画像逻辑” 帮你找到最佳⼈选"},{"id":834713,"t":"18｜⽤⼈：⽤ “⼤数逻辑” 将授权进⾏到底"},{"id":834666,"t":"19｜管⼈：⽤ “⼯具逻辑” 看清量化管理⽅式的⻓与短"},{"id":834714,"t":"20｜总结与加餐：上个台阶"},{"id":835067,"t":"21｜选赛道：成为⼤江中的⼤⻥，你得学会 “先验逻辑”"},{"id":835069,"t":"22｜⽤数据驱动创新：你得探索 “回收逻辑” （上）"},{"id":835070,"t":"23｜⽤数据驱动创新：你得探索 “回收逻辑” （下）"},{"id":835072,"t":"24｜跳出舒适区：押注新⽅向，你得有 “庄家逻辑” （上）"},{"id":835073,"t":"25｜跳出舒适区：押注新⽅向，你得有 “庄家逻辑” （下）"},{"id":835068,"t":"26｜总结与加餐：上个台阶，玩转 AI ⼤模型时代的数据思维"}]},{"id":100038001,"n":"移动端自动化测试实战","a":"思寒","f":true,"c":59,"p":59,"l":[{"id":154541,"t":"01 | 课程介绍"},{"id":154542,"t":"02 | 内容综述"},{"id":154544,"t":"03 | 自动化测试的价值"},{"id":154545,"t":"04 | 自动化测试常见误区"},{"id":154567,"t":"05 | 自动化测试的技术体系"},{"id":154569,"t":"06 | UI分层测试体系"},{"id":154570,"t":"07 | Android App的常见概念"},{"id":154573,"t":"08 | Android调试桥adb命令详解"},{"id":154576,"t":"09 | 自动化测试常用命令"},{"id":159022,"t":"10 | Appium架构介绍"},{"id":159021,"t":"11 | Appium Desktop安装"},{"id":159020,"t":"12 | Appium Server安装"},{"id":159019,"t":"13 | Appium Desktop用例录制"},{"id":159018,"t":"14 | 用例结构解析"},{"id":159017,"t":"15 | 使用隐式等待让用例更稳定"},{"id":162231,"t":"16 | 控件定位方法"},{"id":162232,"t":"17 | 常用自动化API"},{"id":162235,"t":"18 | 长按/滑动等TouchAction应用"},{"id":162237,"t":"19 | 测试用例的改造"},{"id":162239,"t":"20 | capability使用进阶"},{"id":165690,"t":"21 | Appium设备交互API"},{"id":165504,"t":"22 | 使用显式等待处理复杂等待条件"},{"id":165505,"t":"23 | 高级XPath定位"},{"id":165506,"t":"24 | Android Toast识别"},{"id":165654,"t":"25 | 使用断言验证预期结果"},{"id":168764,"t":"26 | 参数化与数据驱动"},{"id":168768,"t":"27 | Native原生App的自动化测试"},{"id":168771,"t":"28 | Hybrid混合App的自动化测试"},{"id":168769,"t":"29 | 纯HTML5站自动化测试"},{"id":168770,"t":"30 | 小程序自动化测试"},{"id":171273,"t":"31 | iOS测试工具体系"},{"id":171274,"t":"32 | App Store与苹果证书体系"},{"id":171275,"t":"33 | iOS模拟器自动化测试"},{"id":171276,"t":"34 | iOS真机测试"},{"id":171277,"t":"35 | iOS WebView测试"},{"id":174571,"t":"36 | Safari测试"},{"id":174572,"t":"37 | Page Object设计模式"},{"id":174573,"t":"38 | Page Object六大设计原则"},{"id":174574,"t":"39 | Page Object第一个例子"},{"id":176986,"t":"40 | 基于Page Object模式的移动自动化测试实战"},{"id":174703,"t":"41 | BasePage封装改进"},{"id":176987,"t":"42 | Appium错误排查与日志分析"},{"id":176988,"t":"43 | Appium原理与JSONWP协议分析"},{"id":176989,"t":"44 | Appium源代码分析"},{"id":176990,"t":"45 | Appium二次封装实战"},{"id":179574,"t":"46 | 自动遍历测试方法与常见技术介绍"},{"id":179576,"t":"47 | Monkey Maxim遍历测试工具"},{"id":179577,"t":"48 | AppCrawler跨平台自动遍历测试"},{"id":179578,"t":"49 | 移动自动化测试平台价值"},{"id":179579,"t":"50 | 技术架构与智能设备选型"},{"id":181507,"t":"51 | 多设备管理平台STF"},{"id":181508,"t":"52 | Selenium Grid方案剖析"},{"id":181509,"t":"53 | 基于Jenkins的自动化调度详解"},{"id":181512,"t":"54 | 多设备回归测试"},{"id":181511,"t":"55 | 多设备多分辨率的兼容性测试方法"},{"id":181513,"t":"56 | 测试用例调度"},{"id":181534,"t":"57 | 手机等智能设备调度"},{"id":181536,"t":"58 | 测试报告定制"},{"id":181537,"t":"59 | 结课测试&结束语"}]},{"id":100611101,"n":"结构会议力","a":"李忠秋","f":true,"c":10,"p":10,"l":[{"id":682339,"t":"01｜开篇：什么样的会议才是高效的会议？"},{"id":682340,"t":"02｜高效会议的基本原则"},{"id":682342,"t":"03｜用5W2H框架和BP法则，设计好会议"},{"id":682343,"t":"04｜用COF主持模式和理解三步骤，主持好会议"},{"id":682345,"t":"05｜用讲故事的模式和说三点法则，参与好会议"},{"id":682354,"t":"06｜为了提升管理效率的例会，要怎么开？"},{"id":682356,"t":"07｜为了解决问题的研讨会，要怎么开？"},{"id":682358,"t":"08｜为了便捷实用的视频会，要怎么开？"},{"id":682359,"t":"09｜用好两种模版，做好会议纪要"},{"id":682362,"t":"10｜重视会议结果的落实与监督"}]},{"id":100611001,"n":"结构写作力","a":"李忠秋","f":true,"c":16,"p":16,"l":[{"id":682173,"t":"01｜开篇：职业发展需要强大的说服性写作能力"},{"id":682265,"t":"02｜设计标题：设计一个吸引读者眼球的标题"},{"id":682268,"t":"03｜撰写序言：写一段让读者愿意看下去的精彩开头"},{"id":682269,"t":"04｜展开内容：快速构建职场常见场景下的行文脉络"},{"id":682270,"t":"05｜成果分类：找到为自己加分的关键工作成果，并进行分类"},{"id":682275,"t":"06｜排序整理：让工作总结清晰、一目了然"},{"id":682276,"t":"07｜概括总结：将自己的工作业绩写出高度"},{"id":682280,"t":"08｜明确观点：说服他人的前提是一个鲜明的观点"},{"id":682283,"t":"09｜疑问回答：用充分的依据回答读者心中的疑问"},{"id":682289,"t":"10｜逻辑归整：用逻辑论证让说服更有力量"},{"id":682290,"t":"11｜综合应用：基于三层次模型的说服性五步骤"},{"id":682292,"t":"12｜描述问题：挖掘需求，锁定写作方向"},{"id":682295,"t":"13｜基于目标定主题：确定目标、设计序言、设定主题"},{"id":682298,"t":"14｜纵向结构分层次：自上而下+自下而上搭建结构"},{"id":682299,"t":"15｜横向结构选顺序：选择演绎或者归纳顺序"},{"id":682300,"t":"16｜形象表达做演示：形象化表达利器"}]},{"id":100610501,"n":"结构学习力","a":"李忠秋","f":true,"c":15,"p":15,"l":[{"id":681752,"t":"01｜学习的本质、误区及原则"},{"id":681755,"t":"02｜认识3A学习螺旋"},{"id":681756,"t":"03｜信息超载时代如何精准获取知识？"},{"id":681757,"t":"04｜明确来源定目标"},{"id":681758,"t":"05｜解构能力定内容"},{"id":681760,"t":"06｜分配资源定规划"},{"id":681761,"t":"07｜构建思维模型，掌握知识本质"},{"id":681762,"t":"08｜理解：分析阅读，读懂一本书（上）"},{"id":681763,"t":"09｜理解：分析阅读，读懂一本书（下）"},{"id":681764,"t":"10｜重构：系统阅读，读懂一套书"},{"id":681765,"t":"11｜建模：概念阅读，模型化"},{"id":681766,"t":"12｜先让自己受益（上）"},{"id":681767,"t":"13｜先让自己受益（下）"},{"id":681768,"t":"14｜讲给身边的人"},{"id":681769,"t":"15｜影响更多的人"}]},{"id":100610301,"n":"结构思考力 · 透过结构看思考","a":"李忠秋","f":true,"c":15,"p":15,"l":[{"id":682296,"t":"01｜透过结构看世界，洞悉事物本质"},{"id":682306,"t":"02｜三层次模型：结构思考力的核心理念"},{"id":682315,"t":"03｜金字塔结构：结构思考力的训练工具"},{"id":682326,"t":"04｜如何打破“只可意会、不可言传”的僵局？"},{"id":682327,"t":"05｜面对纷繁复杂的信息，有自己审视问题的坐标系"},{"id":682329,"t":"06｜任何复杂信息，都可一句话讲清楚"},{"id":682335,"t":"07｜重构四核：结构思考力的四项基本原则"},{"id":682336,"t":"08｜论：结论先行，一句话100%传达你的意思"},{"id":682337,"t":"09｜证：以上统下，让你的观点经得住挑战质疑"},{"id":682338,"t":"10｜类：归类分组，让你的表达清晰全面且容易记"},{"id":682341,"t":"11｜比：逻辑递进，让你的观点逻辑严谨且有说服力"},{"id":682349,"t":"12｜结构罗盘：一张图说清所有工内容"},{"id":682350,"t":"13｜配关系：如何把脑子里的各种想法串联起来？"},{"id":682351,"t":"14｜得图示：如何把一个想法形象化表达出来？"},{"id":682352,"t":"15｜上包装：如何让观点更吸引人、更容易记？"}]},{"id":100610601,"n":"结构思考力 · 透过结构看表达","a":"李忠秋","f":true,"c":13,"p":13,"l":[{"id":682449,"t":"01｜描述问题定方向，5W2H描述清楚问题"},{"id":682453,"t":"02｜确定目标：AB法则让表达有的放矢"},{"id":682456,"t":"03｜设计序言：SCQA获得领导赏识的高效沟通公式"},{"id":682457,"t":"04｜设定标题：使用SAP法则设计一个吸引读者眼球的标题"},{"id":682458,"t":"05｜自上而下：疑问回答搭建框架"},{"id":682459,"t":"06｜自下而上：概括总结做聚合"},{"id":682460,"t":"07｜横向结构选顺序"},{"id":682461,"t":"08｜选择演绎：让说服更有力"},{"id":682475,"t":"09｜选择归纳：让要点更清晰"},{"id":682476,"t":"10｜配关系：如何把脑子里的各种想法串联起来？"},{"id":682478,"t":"11｜得图示：如何把一个想法形象化表达出来？"},{"id":682479,"t":"12｜上包装：如何让观点更吸引人、更容易记？"},{"id":682482,"t":"13｜实践：从个人、组织到社会层面"}]},{"id":100610701,"n":"结构思考力 · 透过结构看问题解决","a":"李忠秋","f":true,"c":16,"p":16,"l":[{"id":682261,"t":"01｜开篇：为什么学习问题解决？"},{"id":682262,"t":"02｜避开思维误区，理性看待问题"},{"id":682264,"t":"03｜巧用5W1H描述客观现实"},{"id":682266,"t":"04｜用问题描述自检表澄清现状"},{"id":682267,"t":"05｜借助SMART工具搞清期望"},{"id":682353,"t":"06｜确定目的与期望的一致性从而界定问题"},{"id":682363,"t":"07｜拆解时根据场景选择相应方法"},{"id":682364,"t":"08｜运用框架提升拆解效率（一）"},{"id":682365,"t":"09｜运用框架提升拆解效率（二）"},{"id":682367,"t":"10｜定量原因分析锁定根本原因"},{"id":682368,"t":"11｜学会借鉴，想出对策易如反掌"},{"id":682378,"t":"12｜逆向思维，让缺点变方案"},{"id":682379,"t":"13｜三种决策工具破解决策难题"},{"id":682380,"t":"14｜掌握优选矩阵，对抗选择困难"},{"id":682381,"t":"15｜做好计划，行动才能变结果（一）"},{"id":682385,"t":"16｜做好计划，行动才能变结果（二）"}]},{"id":100610401,"n":"结构执行力","a":"李忠秋","f":true,"c":20,"p":20,"l":[{"id":681784,"t":"01｜每个人都需要高效执行"},{"id":681785,"t":"02｜充分认识高效执行"},{"id":681786,"t":"03｜高效执行需要结构化"},{"id":681787,"t":"04｜目标的本质与三种类型"},{"id":681788,"t":"05｜目标的三种类型都有主动被动之分"},{"id":681790,"t":"06｜目标的描述要遵循SMART原则"},{"id":681791,"t":"07｜掌握资源提升执行，借助模型确定盘点项"},{"id":681792,"t":"08｜使用清单，盘点资源量"},{"id":681793,"t":"09｜理解目标拆解的根本目的"},{"id":681795,"t":"10｜巧用MECE和逻辑排序原则"},{"id":681796,"t":"11｜目标拆解，逐级细化"},{"id":681797,"t":"12｜三种方法分解任务"},{"id":681798,"t":"13｜串联并联统筹任务"},{"id":681799,"t":"14｜绘制甘特图展示任务"},{"id":681800,"t":"15｜用黄金圈作动员，解决不想干"},{"id":681801,"t":"16｜结构化高效学习，解决不会干"},{"id":681802,"t":"17｜管理时间用三清单，解决没时间（一）"},{"id":681803,"t":"18｜管理时间用三清单，解决没时间（二）"},{"id":681804,"t":"19｜精力管理金字塔，解决没精力干"},{"id":681805,"t":"20｜避免集体无行动"}]},{"id":100610901,"n":"结构沟通力","a":"李忠秋","f":true,"c":22,"p":22,"l":[{"id":682477,"t":"01｜开篇：说服他人的能力，决定了你的职场上限"},{"id":682480,"t":"02｜会议发言：如何在会议中侃侃而谈，展现个人魅力？"},{"id":682483,"t":"03｜工作汇报：如何通过条理清晰的汇报，得到领导重用？"},{"id":682484,"t":"04｜客户沟通：如何在与客户谈话时，更有说服力并达成业绩？"},{"id":682485,"t":"05｜需求配合：如何在工作难度大、任务重时，寻求同事的配合？"},{"id":682486,"t":"06｜请求支持：如何在工作难度大、搞不定时，请求领导的支持？"},{"id":682489,"t":"07｜跨部门沟通：如何顺畅地跨部门沟通，提升部门形象？"},{"id":682490,"t":"08｜领导闲聊：如何在与领导闲聊时，轻松地表现自己？"},{"id":682492,"t":"09｜提出建议：如何向领导提出建议，帮助领导决策？"},{"id":682493,"t":"10｜工作总结：如何通过工作总结，让领导认可你的工作？"},{"id":682495,"t":"11｜项目总结：如何通过项目总结，展示你的工作成果？"},{"id":682496,"t":"12｜销售提案：如何写出让老板认可、客户点头的提案？"},{"id":682499,"t":"13｜产品介绍：如何写出打动用户或客户的产品介绍？"},{"id":682500,"t":"14｜个人简历：如何让你的简历在众多候选人中脱颖而出？"},{"id":682502,"t":"15｜竞聘报告：如何 100% 展示工作成果，抓住晋升机会？"},{"id":682504,"t":"16｜会议纪要：如何用看似简单的会议纪要展示你的工作能力？"},{"id":682505,"t":"17｜邮件写作：如何让邮件的书面沟通更高效？"},{"id":682506,"t":"18｜演示说话：如何有效地组织演示内容，用 PPT 展现你的实力？"},{"id":682507,"t":"19｜图表说话：如何把数据变成令人信服、有影响力的图表？"},{"id":682508,"t":"20｜图示说话：如何把信息变成让听众准确理解你意图的图示？"},{"id":682509,"t":"21｜视觉引导：如何用手绘图解决会议和沟通中的一切难题？"},{"id":682510,"t":"22｜学习笔记：如何用方格本记笔记，让头脑越来越聪明？"}]},{"id":100670901,"n":"给程序员的写作课","a":"高磊","f":true,"c":49,"p":49,"l":[{"id":747510,"t":"开篇词｜写作是最综合的一种能力"},{"id":747513,"t":"01｜写作价值与认知误区"},{"id":747514,"t":"02｜简洁的作用与误区"},{"id":747515,"t":"03｜追求热点的误区"},{"id":747516,"t":"04｜风格的作用与误区"},{"id":747519,"t":"05｜实践论的价值与误区"},{"id":747521,"t":"06｜写作心态相关问题"},{"id":747524,"t":"07｜为什么阅读非常重要"},{"id":747526,"t":"08｜如何实现高效阅读"},{"id":747527,"t":"09｜如何构建自己的知识体系"},{"id":747528,"t":"10｜写作基本技法1：怎么用好最常见的顺叙和倒叙结构"},{"id":747529,"t":"11｜写作基本技法2：日常工作也能运用的3种进阶叙事结构"},{"id":747531,"t":"12｜写作基本技法3：精进中观、微观结构"},{"id":747533,"t":"13｜写作基本技法4：怎么提升表达，让文字更有魅力"},{"id":747534,"t":"14｜写作离不开的沟通能力"},{"id":747535,"t":"15｜ChatGPT和Notion在写作领域有哪些可落地场景"},{"id":747536,"t":"16｜熟练使用ChatGPT的6个基本参数"},{"id":747537,"t":"17｜Notion操作入门，简单且强大"},{"id":747539,"t":"18｜应用场景1：AI辅助写日常文案，提质提效"},{"id":747540,"t":"19｜应用场景2：新手怎么利用AI高效学编程"},{"id":747541,"t":"20｜应用场景3：以PPT为例，看AI辅助提升办公效率"},{"id":749150,"t":"21｜技术文档的本质、结构与用语规范"},{"id":749156,"t":"22｜带你拆解技术文档用语案例"},{"id":749158,"t":"23｜技术文档案例与作图技法"},{"id":749159,"t":"24｜技术文档更新策略与总结"},{"id":749160,"t":"25｜如何写好汇报：能实现目标的汇报才是好汇报"},{"id":749161,"t":"26｜如何写好邮件：有效利用这种最自由的写作载体"},{"id":749162,"t":"27｜如何写好简历：通过简历更好地了解自己"},{"id":749163,"t":"28｜如何写好技术文章：把博客、公众号文章作为你的灵感快照"},{"id":750587,"t":"29｜如何写好一本书1：技术书也是一种产品"},{"id":756810,"t":"30｜如何写好一本书2：案例分析之无架构就无书"},{"id":756811,"t":"31｜如何写好一本书3：案例分析之如何写图书大纲"},{"id":756812,"t":"32｜如何写好一本书4：写书挑战及应对方法"},{"id":757282,"t":"33｜如何写好一本书5：写书准备及注意事项"},{"id":758161,"t":"34｜如何写好一本书6：结构化写作法案例精讲"},{"id":758171,"t":"35｜如何写好一本书7：深入浅出写作秘法"},{"id":759339,"t":"36｜如何做好一门课1：讲课的价值与好课标准"},{"id":759341,"t":"37｜如何做好一门课2：怎么做知识盘点&设定教学目标"},{"id":759342,"t":"38｜如何做好一门课3：怎么确定课程结构&设计学习体验"},{"id":759343,"t":"39｜如何做好一门课4：怎么运用自检清单来保证质量"},{"id":759344,"t":"40｜如何做好一门课5：怎么讲好课并做好课程营销"},{"id":761448,"t":"41｜如何做好一个短视频1：短视频价值及如何起号"},{"id":761449,"t":"42｜如何做好一个短视频2：理解平台调性&设计吸引人的标题"},{"id":761462,"t":"43｜如何做好一个短视频3：怎么撰写短视频文案和脚本"},{"id":761463,"t":"44｜如何做好一个短视频4：怎么拍摄短视频"},{"id":761464,"t":"45｜如何做好一个短视频5：短视频剪辑与发布"},{"id":761465,"t":"46｜如何做好一个短视频6：怎么策划一场直播"},{"id":761466,"t":"47｜如何做好一个短视频7：怎么基于数据做运营"},{"id":761467,"t":"结束语｜写作离我们很近，我的写作“三不”心得"}]},{"id":100761001,"n":"重学TypeScript","a":"周爱民","f":true,"c":66,"p":66,"l":[{"id":769350,"t":"开篇词｜TypeScript 高手修炼指南"},{"id":769613,"t":"课程导学｜如何高效学习这门课？"},{"id":769610,"t":"01 | 我们为什么要用TypeScript?"},{"id":769614,"t":"02｜怎样标注类型？"},{"id":769615,"t":"03｜TS与JS相关的那些类型"},{"id":769617,"t":"04｜联合和交叉"},{"id":769618,"t":"05｜TypeScript类型系统全景"},{"id":771333,"t":"06｜接口类型的联合与交叉"},{"id":771334,"t":"07｜类的声明与使用"},{"id":771335,"t":"08｜类与接口的相互操作"},{"id":771336,"t":"09｜函数签名与传统的类（构造器）"},{"id":773267,"t":"10｜索引签名与列表（数组和元组）"},{"id":773268,"t":"11｜TypeScript中的同名处理策略"},{"id":773270,"t":"12｜枚举类型"},{"id":775876,"t":"13｜类型守护与类型收窄"},{"id":775880,"t":"14｜在JS与TS之间互通访问的技术"},{"id":775881,"t":"15｜在TypeScript中的“语句”与“名字”"},{"id":777720,"t":"16｜表达式类型及其基本性质"},{"id":777721,"t":"17｜作为表达式类型的联合与交叉"},{"id":777722,"t":"18｜元组中的...和索引存取表达式（用Key）"},{"id":780315,"t":"19｜keyof的特殊性（取Key）"},{"id":780316,"t":"20｜映射类型（映射key）"},{"id":780317,"t":"21｜模板字面量类型"},{"id":781899,"t":"22｜条件类型概要"},{"id":781900,"t":"23｜赋值兼容性的再说明"},{"id":781904,"t":"24｜将条件类型用作操作数（X、Y）"},{"id":783737,"t":"25｜在条件中使用其它类型（L、R）"},{"id":783738,"t":"26｜分布式条件类型的应用"},{"id":783739,"t":"27｜理解推断（infer）"},{"id":786122,"t":"28｜理解约束（constraint）"},{"id":786123,"t":"29｜泛型基本概念和泛型工具"},{"id":786124,"t":"30｜泛型声明（一）：一般类型的泛型声明"},{"id":789323,"t":"31｜泛型声明 （二）：函数与类"},{"id":789324,"t":"32｜泛型中的推断、约束和缺省"},{"id":789325,"t":"33｜泛型工具实践（一）：推断-上篇"},{"id":789326,"t":"33｜泛型工具实践（一）：推断-下篇"},{"id":791511,"t":"34｜泛型工具实践（二）：转换"},{"id":791512,"t":"35｜泛型工具实践（三）：列举"},{"id":791513,"t":"36｜在VSCode中管理TypeScript"},{"id":793865,"t":"37｜在VSCode环境下的TypeScript开发过程全解（上）"},{"id":793866,"t":"37｜在VSCode环境下的TypeScript开发过程全解（下）"},{"id":793867,"t":"38｜在VSCode中使用JSDoc/TSDoc"},{"id":795250,"t":"39｜从传统到智能：抽取类声明的接口"},{"id":795251,"t":"40｜让AI参与VSCode与TypeScript的开发全程"},{"id":795252,"t":"41｜TypeScript扩展了哪些应用特性"},{"id":797403,"t":"42｜管理与组织TypeScript文件与工具套件"},{"id":797404,"t":"43｜装饰器的用法"},{"id":797405,"t":"44｜为TypeScript代码写测试用例"},{"id":799034,"t":"45｜配置基础概念之模块：解析、目标和映射"},{"id":799035,"t":"46｜配置选项详解（一）：Node.js集成"},{"id":799036,"t":"47｜配置选项详解（二）：浏览器输出"},{"id":800603,"t":"48｜配置选项详解（三）：第三方工具集成"},{"id":800604,"t":"49｜配置选项详解（四）：其它编译选项与环境"},{"id":800605,"t":"50｜生成器、迭代器与集合类型的一般应用"},{"id":802140,"t":"51｜this类型的深度讲解"},{"id":802141,"t":"52｜Promise、异步以及链式调用中的特殊处理"},{"id":802148,"t":"53｜不是类型的类型：模块"},{"id":803633,"t":"54｜跨模块扩展技术"},{"id":803634,"t":"55｜声明文件与全局模块的写法（Globals.d.ts）"},{"id":803635,"t":"56｜复杂参数的写法"},{"id":805099,"t":"57｜泛型表达式中的上下文与递归"},{"id":805932,"t":"58｜如何在回调设计中使用泛型函数"},{"id":806242,"t":"59｜泛型声明的子类化问题"},{"id":806358,"t":"直播课预告&问题征集"},{"id":807814,"t":"结课测试｜检验一下自己的学习成果吧"},{"id":813297,"t":"结束语｜为何TypeScript要对我们如此刻薄？"}]},{"id":100310001,"n":"零基础学Python（2023版）","a":"尹会生","f":true,"c":124,"p":124,"l":[{"id":600017,"t":"课程介绍：这次我们都做了哪些升级？"},{"id":600293,"t":"内容综述：明确学习目的"},{"id":600294,"t":"01｜如何配置 Python 开发环境？"},{"id":600750,"t":"02 | 常用 IDE：如何提高开发效率？"},{"id":600751,"t":"03 | 如何站在官方文档的肩膀上自己“造轮子”？"},{"id":600752,"t":"04 | 怎样运行你的第一行代码？"},{"id":600753,"t":"05 | 怎样使用 Gitee 管理你的代码？"},{"id":600779,"t":"06 | 学习编程有问题？去这里找答案！"},{"id":600796,"t":"07｜跨越门槛：Python 开发环境总结及实现原理"},{"id":601823,"t":"08 | 修炼基本功：浅析输入输出"},{"id":601825,"t":"09 | 变量：如何让计算机临时存储数据？"},{"id":603112,"t":"10｜字符串（上）：Python 是如何处理单词的？"},{"id":603113,"t":"11｜字符串（下）：Python 是如何处理单词的？"},{"id":603128,"t":"12｜存储数字应该采用哪种数据类型？"},{"id":603129,"t":"13｜何时使用数，何时使用字符串？"},{"id":603130,"t":"14｜注释：如何写程序的说明书？"},{"id":603131,"t":"15｜小试牛刀：如何制作简单计算器？"},{"id":603132,"t":"16｜变量命名规范：如何编写优雅的程序？"},{"id":603468,"t":"17｜告别新手村：Python 编程基础知识"},{"id":605128,"t":"18｜内置数据类型包括哪几种？"},{"id":605202,"t":"19｜列表如何处理同类数据？"},{"id":605144,"t":"20｜常见常新：列表的常见操作"},{"id":605146,"t":"21｜元组：如何处理一次性数据？"},{"id":605153,"t":"22｜常见常新：集合的常见操作"},{"id":605154,"t":"23｜字典：如何处理映射类型的数据？"},{"id":605156,"t":"24｜常见常新：字典的常见操作（上）"},{"id":605158,"t":"25｜常见常新：字典的常见操作（下）"},{"id":605161,"t":"26｜小试牛刀：如何利用类型转换实现手机通讯录？（上）"},{"id":605162,"t":"27｜小试牛刀：如何利用类型转换实现手机通讯录？（下）"},{"id":605165,"t":"28｜常见的内置数据类型都何时使用？"},{"id":605167,"t":"29｜避坑指南：内置数据类型的常见错误"},{"id":605169,"t":"30｜内置数据类型参考：如何使用官方文档与帮助？"},{"id":606202,"t":"31｜再回首：“内置数据类型”单元小结"},{"id":608140,"t":"32｜if 语句：数据流程出现分支时，怎样编写程序？"},{"id":608141,"t":"33｜match 语句：如何通过 match 关键字来处理程序的分支逻辑？"},{"id":608143,"t":"34｜while 循环：需要多次重复执行某段程序时，怎么做？"},{"id":608142,"t":"35｜for 循环：如何遍历一个对象里的所有元素？"},{"id":608145,"t":"36｜语句嵌套：如何处理多重循环的问题？"},{"id":608146,"t":"37｜小试牛刀：如何设计一个飞机大战的程序？"},{"id":608147,"t":"38｜避坑指南：判断和循环中的常见错误"},{"id":608154,"t":"39｜再回首：“判断循环”单元小结"},{"id":610658,"t":"40｜输入：如何接收用户通过键盘输入的数据？"},{"id":610660,"t":"41｜格式化输出：如何将执行结果通过屏幕输出？"},{"id":610667,"t":"42｜F-strings：如何通过定义好的格式进行输出？"},{"id":610669,"t":"43 | 常见常新：文件的打开"},{"id":610670,"t":"44｜文件编码：如何解决不同操作系统的文件乱码问题？"},{"id":610695,"t":"45｜常见常新：文件的读写"},{"id":610688,"t":"46｜常见常新：文件的关闭"},{"id":610692,"t":"47｜小试牛刀：如何使用 Python 合并多个文件？"},{"id":610750,"t":"48｜再回首：“输入输出与文件操作”单元小结"},{"id":613047,"t":"49｜函数的定义：如何优雅地反复引用同一段代码？"},{"id":613046,"t":"50｜函数的参数：怎样实现函数与外部数据通信？"},{"id":613049,"t":"51｜函数的参数：当函数操作对象不固定时怎么处理？"},{"id":613051,"t":"52｜函数的返回值：如何得到函数的执行结果？"},{"id":613052,"t":"53｜小试牛刀：如何利用函数实现电商购物车功能？"},{"id":613054,"t":"54｜避坑指南：列表作为参数传递出错了怎么办？"},{"id":613055,"t":"55｜高阶函数：函数对象与函数调用的用法区别"},{"id":613056,"t":"56｜装饰器：函数嵌套的定义与调用的区别"},{"id":613063,"t":"57｜再回首：“函数”单元小结"},{"id":615007,"t":"58｜编程思想不同会导致怎样的代码差异？"},{"id":615008,"t":"59｜类与实例：如何使用面向对象的思想编写程序？"},{"id":615010,"t":"60｜类的继承：如何解决代码重用的问题？"},{"id":615011,"t":"61｜类的装饰器：如何改变类方法的功能？"},{"id":615016,"t":"62｜小试牛刀：如何开发自动咖啡机？"},{"id":615018,"t":"63｜避坑指南：类的常见错误"},{"id":615020,"t":"64｜init 方法：如何为对象传递参数？"},{"id":615037,"t":"65｜再回首：“类”单元小结"},{"id":617637,"t":"66 | 模块的导入：如何使用其他人编写好的代码功能？"},{"id":617638,"t":"67 | 标准库：Python 默认提供的便捷功能有哪些？"},{"id":617639,"t":"68 | 自定义模块：如何编写一个完整功能？"},{"id":617640,"t":"69 | 第三方模块的使用：如何使用其他人编写的代码？"},{"id":617641,"t":"70 | 小试牛刀：如何使用 Python 为函数求导？"},{"id":619907,"t":"71｜再回首：“模块与标准库”单元小结"},{"id":619939,"t":"72｜初识异常：异常的产生与分类"},{"id":619938,"t":"73｜异常捕获：出现异常时，如何利用程序进行处理？"},{"id":619937,"t":"74｜自定义异常捕获：如何定义业务异常？"},{"id":619936,"t":"75｜避坑指南：编写捕获异常程序时经常出现的问题"},{"id":619908,"t":"76｜再回首：“异常处理”单元小结"},{"id":621928,"t":"77｜扩展数据类型：怎样使用更复杂的数据类型？"},{"id":621929,"t":"78｜魔术方法：怎样通过类构造自己需要的数据类型？"},{"id":621930,"t":"79｜怎样将 Python 和 C++ 结合起来混合编程？"},{"id":621934,"t":"80｜怎样将已有算法改造成符合项目的特定算法？"},{"id":621938,"t":"81｜设计模式：怎样合理组合多个函数和类？"},{"id":621940,"t":"82｜Redis 数据库：怎样使用 NoSQL 数据库？"},{"id":621941,"t":"83｜关系型数据库：怎样使用关系型数据库？"},{"id":621942,"t":"84｜计算资源充足时，如何通过并行设计提高效率？"},{"id":621943,"t":"85｜多进程间如何通信？"},{"id":621948,"t":"86｜再回首：“高级数据类型与算法”单元小结"},{"id":623418,"t":"87｜理论盘点：数据分析的流程及对应的 Python 库"},{"id":623419,"t":"88｜理论盘点：数据采集的方法与 HTTP 协议"},{"id":623420,"t":"89｜理论盘点：任务的并行执行原理"},{"id":623423,"t":"90｜理论盘点：非规范化数据处理的基础与正则表达式"},{"id":623424,"t":"91｜如何获取网页上的数据并存储到文件？"},{"id":623427,"t":"92｜小试牛刀：如何将数据进行图形化展示？"},{"id":623445,"t":"93｜再回首：“数据分析”单元小结"},{"id":624254,"t":"94｜理论盘点：文件类型与对应的 Python 函数库"},{"id":624255,"t":"95｜如何批量读取 Excel 文件？"},{"id":624256,"t":"96｜如何实现数据的批量格式转换？"},{"id":624257,"t":"97｜如何扩展数据类型？"},{"id":624613,"t":"98｜再回首：“办公自动化”单元小结"},{"id":625469,"t":"99｜理论盘点：Web 客户端与服务端"},{"id":625470,"t":"100｜理论盘点：MVC 模型是什么？"},{"id":625472,"t":"101｜如何使用Django搭建简单的Web服务器？"},{"id":625484,"t":"102｜如何使用Django-admin实现文章上传？"},{"id":625474,"t":"103｜如何使用Django实现文章发布？"},{"id":625574,"t":"104｜再回首：“Web开发”单元小结"},{"id":627581,"t":"105｜理论盘点：人脸识别的一般步骤"},{"id":627583,"t":"106｜理论盘点：人脸识别常用的 Python 库有哪些？"},{"id":627584,"t":"107｜怎样通过 OpenCV 采集视频信号？"},{"id":627586,"t":"108｜如何训练人脸模型？"},{"id":627587,"t":"109｜怎样设计人脸识别系统？"},{"id":627590,"t":"110｜再回首：“计算机视觉”单元小结"},{"id":629857,"t":"111｜聚焦异同：物联网与互联网有啥不一样？"},{"id":629859,"t":"112｜理论盘点：基础但不简单的 TCP 协议"},{"id":629860,"t":"113｜理论盘点：物模型与模组"},{"id":629862,"t":"114｜如何为 ESP32 安装 MicroPython?"},{"id":629866,"t":"115｜怎样通过 MQTT 协议构建消息队列？"},{"id":629869,"t":"116｜小试牛刀：在 OLED 屏幕和手机远程同时显示室内温度"},{"id":629903,"t":"117｜再回首：“物联网”单元小结"},{"id":632467,"t":"118｜结束语：人生苦短，我用Pyhon"},{"id":720748,"t":"结课测试｜来赴一场满分之约吧！"},{"id":684475,"t":"直播加餐｜与AI共同编程，用ChatGPT学Python"},{"id":696325,"t":"直播加餐｜用OpenAI API理解Python数据类型"},{"id":701751,"t":"直播加餐｜掌握Gradio框架：为 AI Agent 程序定制界面"}]},{"id":100839601,"n":"零基础开发Agent智能体","a":"李永恒","f":true,"c":9,"p":9,"l":[{"id":824861,"t":"01｜大模型引领第四次工业革命"},{"id":824864,"t":"02｜了解大模型的能力"},{"id":824874,"t":"03｜大模型能力分级"},{"id":824876,"t":"04｜大模型行业落地步骤"},{"id":824877,"t":"05｜智能体是什么，和大模型有什么关系？"},{"id":824879,"t":"06｜为什么需要智能体？"},{"id":824881,"t":"07｜智能体的架构是怎样的？"},{"id":824883,"t":"08｜大智能体在金融、自动驾驶场景中的应用案例"},{"id":824884,"t":"09｜智能体和开发工具的区别"}]},{"id":100824401,"n":"领域大模型微调案例课","a":"老刘","f":true,"c":14,"p":14,"l":[{"id":812737,"t":"01｜为什么要做领域模型？"},{"id":812738,"t":"02｜ChatGPT 训练回顾及领域模型微调范式"},{"id":812739,"t":"03｜领域微调基础模型选择 LLaMA、GLM、BLoom 及其对比"},{"id":812736,"t":"04｜领域微调微调加速 prompt tuningLoRAadapter"},{"id":812756,"t":"05｜金融领域微调模型项目解读：FinGPT、Cornucopia-LLaMA-Fin-Chinese 等"},{"id":813493,"t":"06｜法律领域微调模型项目解读：LawGPT_zh、 Lawyer LLaMA 等"},{"id":813494,"t":"07｜医疗领域微调模型项目解读：ChatDoctor、 Huatuo 等"},{"id":813495,"t":"08｜教育领域微调模型项目解读：Taoli、Media LLaMA 等"},{"id":813496,"t":"09｜多步骤微调、扩充 LLAma 词表、遗忘问题、幻觉问题的一些思考"},{"id":813497,"t":"10｜大模型长文本技术实现思路及代表案例"},{"id":813498,"t":"11｜大模型长文本技术主流评测"},{"id":813499,"t":"12｜嫁接模型 SOLAR 及 Moe 模型基本理解"},{"id":813500,"t":"13｜Moe 模型的优缺点"},{"id":813501,"t":"14｜现有开源的代表 Moe 模型项目"}]}]