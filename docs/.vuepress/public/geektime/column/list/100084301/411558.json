{"id":411558,"title":"14 | 从代码实现看分布式锁的原子性保证","content":"<p>你好，我是蒋德钧。</p><p>分布式锁是Redis在实际业务场景中的一个重要应用。当有多个客户端并发访问某个共享资源时，比如要修改数据库中的某条记录，为了避免记录修改冲突，我们可以让所有客户端从Redis上获取分布式锁，只有拿到锁的客户端才能操作共享资源。</p><p>那么，对于分布式锁来说，它实现的关键就是要保证加锁和解锁两个操作是原子操作，这样才能保证多客户端访问时锁的正确性。而通过前面课程的学习，你知道Redis能通过事件驱动框架同时捕获多个客户端的可读事件，也就是命令请求。此外，在Redis 6.0版本中，多个IO线程会被用于并发地读取或写回数据。</p><p>而既然如此，你就可以来思考一个问题：<strong>分布式锁的原子性还能得到保证吗？</strong></p><p>今天这节课呢，我就带你来了解下一条命令在Redis server中的执行过程，然后结合分布式锁的要求，来带你看下命令执行的原子性是如何保证的。同时，我们再来看看在有IO多路复用和多IO线程的情况下，分布式锁的原子性是否会受到影响。</p><p>这样一来，你就既可以掌握客户端的一条命令是如何完成执行的，其原子性是如何得到保证的，而且还可以把之前学习到的知识点串接应用起来。要知道，了解客户端命令的执行过程，对于日常排查Redis问题也是非常有帮助的，你可以在命令执行的过程中加入检测点，以便分析和排查运行问题。</p><!-- [[[read_end]]] --><p>好，那么接下来，我们就先来了解下分布式锁的实现方法，这样就能知道分布式锁对应的实现命令，以便进行进一步分析。</p><h2>分布式锁的实现方法</h2><p>我们在第一季的课程中，有学习过<a href=\"https://time.geekbang.org/column/article/301092\">分布式锁的实现</a>，你可以再去回顾下。这里，我再来简要介绍下分布式锁的加锁和解锁实现的命令。</p><p>首先，对于分布式锁的<strong>加锁</strong>操作来说，我们可以使用<strong>Redis的SET命令</strong>。Redis SET命令提供了NX和EX选项，这两个选项的含义分别是：</p><ul>\n<li><strong>NX</strong>，表示当操作的key不存在时，Redis会直接创建；当操作的key已经存在了，则返回NULL值，Redis对key不做任何修改。</li>\n<li><strong>EX</strong>，表示设置key的过期时间。</li>\n</ul><p>因此，我们可以让客户端发送以下命令来进行加锁。其中，lockKey是锁的名称，uid是客户端可以用来唯一标记自己的ID，expireTime是这个key所代表的锁的过期时间，当这个过期时间到了之后，这个key会被删除，相当于锁被释放了，这样就避免了锁一直无法释放的问题。</p><pre><code>SET lockKey uid EX expireTime NX\n</code></pre><p>而如果还没有客户端创建过锁，那么，假设客户端A发送了这个SET命令给Redis，如下所示：</p><pre><code>SET stockLock 1033 EX 30 NX\n</code></pre><p>这样，Redis就会创建对应的key为stockLock，而键值对的value就是这个客户端的ID 1033。此时，假设有另一个客户端B也发送了SET命令，如下所示，表示要把key为stockLock的键值对值，改为客户端B的ID 2033，也就是要加锁。</p><pre><code>SET stockLock 2033 EX 30 NX\n</code></pre><p>由于使用了NX选项，如果stockLock的key已经存在了，客户端B就无法对其进行修改了，也就无法获得锁了，这样就实现了加锁的效果。</p><p>而对于<strong>解锁</strong>来说，我们可以使用如下的<strong>Lua脚本</strong>来完成，而Lua脚本会以EVAL命令的形式在Redis server中执行。客户端会使用GET命令读取锁对应key的value，并判断value是否等于客户端自身的ID。如果等于，就表明当前客户端正拿着锁，此时可以执行DEL命令删除key，也就是释放锁；如果value不等于客户端自身ID，那么该脚本会直接返回。</p><pre><code>if redis.call(&quot;get&quot;,lockKey) == uid then\n   return redis.call(&quot;del&quot;,lockKey)\nelse\n   return 0\nend\n</code></pre><p>这样一来，客户端就不会误删除别的客户端获得的锁了，从而保证了锁的安全性。</p><p>好，现在我们就了解了分布式锁的实现命令。那么在这里，我们需要搞明白的问题就是：无论是加锁的SET命令，还是解锁的Lua脚本和EVAL命令，在有IO多路复用时，会被同时执行吗？或者<strong>当我们使用了多IO线程后，会被多个线程同时执行吗？</strong></p><p>这就和Redis中命令的执行过程有关了。下面，我们就来了解下，一条命令在Redis是如何完成执行的。同时，我们还会学习到，IO多路复用引入的多个并发客户端，以及多IO线程是否会破坏命令的原子性。</p><h2>一条命令的处理过程</h2><p>现在我们知道，Redis server一旦和一个客户端建立连接后，就会在事件驱动框架中注册可读事件，这就对应了客户端的命令请求。而对于整个命令处理的过程来说，我认为主要可以分成四个阶段，它们分别对应了Redis源码中的不同函数。这里，我把它们对应的入口函数，也就是它们是从哪个函数开始进行执行的，罗列如下：</p><ul>\n<li>命令读取，对应readQueryFromClient函数；</li>\n<li>命令解析，对应processInputBufferAndReplicate函数；</li>\n<li>命令执行，对应processCommand函数；</li>\n<li>结果返回，对应addReply函数；</li>\n</ul><p>那么下面，我们就来分别看下这四个入口函数的基本流程，以及为了完成命令执行，它们内部的主要调用关系都是怎样的。</p><h3>命令读取阶段：readQueryFromClient函数</h3><p>首先，我们来了解下readQueryFromClient函数的基本流程。</p><p>readQueryFromClient函数会从客户端连接的socket中，读取最大为readlen长度的数据，readlen值大小是宏定义PROTO_IOBUF_LEN。该宏定义是在<a href=\"https://github.com/redis/redis/tree/5.0/src/server.h\">server.h</a>文件中定义的，默认值为16KB。</p><p>紧接着，readQueryFromClient函数会根据读取数据的情况，进行一些异常处理，比如数据读取失败或是客户端连接关闭等。此外，如果当前客户端是主从复制中的主节点，readQueryFromClient函数还会把读取的数据，追加到用于主从节点命令同步的缓冲区中。</p><p>最后，readQueryFromClient函数会调用processInputBufferAndReplicate函数，这就进入到了命令处理的下一个阶段，也就是命令解析阶段。</p><pre><code>void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {\n   ...\n   readlen = PROTO_IOBUF_LEN;  //从客户端socket中读取的数据长度，默认为16KB\n   ...\n   c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);  //给缓冲区分配空间\n   nread = read(fd, c-&gt;querybuf+qblen, readlen);  //调用read从描述符为fd的客户端socket中读取数据\n    ...\n    processInputBufferAndReplicate(c);  //调用processInputBufferAndReplicate进一步处理读取内容\n}   \n</code></pre><p>我在下面画了张图，展示了readQueryFromClient函数的基本流程，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/da/12/da8d14b131cb3c82b88ce5c3dcf6df12.jpg?wh=2000x1125\" alt=\"\"></p><h3>命令解析阶段：processInputBufferAndReplicate函数</h3><p>processInputBufferAndReplicate函数（在<a href=\"http://github.com/redis/redis/tree/5.0/src/networking.c\">networking.c</a>文件中）会根据当前客户端是否有CLIENT_MASTER标记，来执行两个分支。</p><ul>\n<li><strong>分支一</strong></li>\n</ul><p>这个分支对应了<strong>客户端没有CLIENT_MASTER标记</strong>，也就是说当前客户端不属于主从复制中的主节点。那么，processInputBufferAndReplicate函数会直接调用processInputBuffer（在networking.c文件中）函数，对客户端输入缓冲区中的命令和参数进行解析。所以在这里，实际执行命令解析的函数就是processInputBuffer函数。我们一会儿来具体看下这个函数。</p><ul>\n<li><strong>分支二</strong></li>\n</ul><p>这个分支对应了<strong>客户端有CLIENT_MASTER标记</strong>，也就是说当前客户端属于主从复制中的主节点。那么，processInputBufferAndReplicate函数除了调用processInputBuffer函数，解析客户端命令以外，它还会调用replicationFeedSlavesFromMasterStream函数（在<a href=\"https://github.com/redis/redis/tree/5.0/src/replication.c\">replication.c</a>文件中），将主节点接收到的命令同步给从节点。</p><p>下图就展示了processInputBufferAndReplicate函数的基本执行逻辑，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/b0/0b/b051c8659de6fd532fa90f20555ddc0b.jpg?wh=2000x949\" alt=\"\"></p><p>好了，我们刚才了解了，<strong>命令解析实际是在processInputBuffer函数中执行的</strong>，所以下面，我们还需要清楚这个函数的基本流程是什么样的。</p><p>首先，processInputBuffer函数会执行一个while循环，不断地从客户端的输入缓冲区中读取数据。然后，它会<strong>判断读取到的命令格式，是否以“*”开头</strong>。</p><p>如果命令是以“*”开头，那就表明这个命令是PROTO_REQ_MULTIBULK类型的命令请求，也就是符合RESP协议（Redis客户端与服务器端的标准通信协议）的请求。那么，processInputBuffer函数就会进一步调用processMultibulkBuffer（在networking.c文件中）函数，来解析读取到的命令。</p><p>而如果命令不是以“*”开头，那则表明这个命令是PROTO_REQ_INLINE类型的命令请求，并不是RESP协议请求。这类命令也被称为<strong>管道命令</strong>，命令和命令之间是使用换行符“\\r\\n”分隔开来的。比如，我们使用Telnet发送给Redis的命令，就是属于PROTO_REQ_INLINE类型的命令。在这种情况下，processInputBuffer函数会调用processInlineBuffer（在networking.c文件中）函数，来实际解析命令。</p><p>这样，等命令解析完成后，processInputBuffer函数就会调用processCommand函数，开始进入命令处理的第三个阶段，也就是命令执行阶段。</p><p>下面的代码展示了processInputBuffer函数解析命令时的主要流程，你可以看下。</p><pre><code>void processInputBuffer(client *c) {\n   while(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) {\n      ...\n       if (!c-&gt;reqtype) {\n            //根据客户端输入缓冲区的命令开头字符判断命令类型\n            if (c-&gt;querybuf[c-&gt;qb_pos] == '*') {\n                c-&gt;reqtype = PROTO_REQ_MULTIBULK; //符合RESP协议的命令\n            } else {\n                c-&gt;reqtype = PROTO_REQ_INLINE; //管道类型命令\n            }\n        }\n        if (c-&gt;reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;  //对于管道类型命令，调用processInlineBuffer函数解析\n        } else if (c-&gt;reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break; //对于RESP协议命令，调用processMultibulkBuffer函数解析\n        }\n        ... \n       if (c-&gt;argc == 0) {\n            resetClient(c);\n        } else {\n            //调用processCommand函数，开始执行命令\n            if (processCommand(c) == C_OK) {\n               ...   } \n            ... }\n        }\n        ...\n}\n</code></pre><p>下图展示了processInputBuffer函数的基本执行流程，你可以再回顾下。</p><p><img src=\"https://static001.geekbang.org/resource/image/59/f8/59e07442a5f5531f3859a1af43b148f8.jpg?wh=2000x1125\" alt=\"\"></p><p>好，那么下面，我们接着来看第三个阶段，也就是命令执行阶段的processCommand函数的基本处理流程。</p><h3>命令执行阶段：processCommand函数</h3><p>首先，我们要知道，processCommand函数是在<a href=\"http://github.com/redis/redis/tree/5.0/src/server.c\">server.c</a>文件中实现的。它在实际执行命令前的主要逻辑可以分成三步：</p><ul>\n<li>第一步，processCommand函数会调用moduleCallCommandFilters函数（在<a href=\"http://github.com/redis/redis/tree/5.0/src/module.c\">module.c</a>文件），将Redis命令替换成module中想要替换的命令。</li>\n<li>第二步，processCommand函数会判断当前命令是否为quit命令，并进行相应处理。</li>\n<li>第三步，processCommand函数会调用lookupCommand函数，在全局变量server的commands成员变量中查找相关的命令。</li>\n</ul><p>这里，你需要注意下，全局变量server的<strong>commands成员变量是一个哈希表</strong>，它的定义是在<a href=\"http://github.com/redis/redis/tree/5.0/src/server.h\">server.h</a>文件中的redisServer结构体里面，如下所示：</p><pre><code>struct redisServer {\n   ...\n   dict *commands; \n   ...\n}\n</code></pre><p>另外，commands成员变量的初始化是在initServerConfig函数中，通过调用dictCreate函数完成哈希表创建，再通过调用populateCommandTable函数，将Redis提供的命令名称和对应的实现函数，插入到哈希表中的。</p><pre><code>void initServerConfig(void) {\n...\nserver.commands = dictCreate(&amp;commandTableDictType,NULL);\n...\npopulateCommandTable();\n...\n}\n</code></pre><p>而这其中的populateCommandTable函数，实际上是使用到了redisCommand结构体数组redisCommandTable。</p><p><strong>redisCommandTable数组</strong>是在server.c文件中定义的，它的每一个元素是一个redisCommand结构体类型的记录，对应了Redis实现的一条命令。也就是说，redisCommand结构体中就记录了当前命令所对应的实现函数是什么。</p><p>比如，以下代码展示了GET和SET这两条命令的信息，它们各自的实现函数分别是getCommand和setCommand。当然，如果你想进一步了解redisCommand结构体，也可以去看下它的定义，在server.h文件当中。</p><pre><code>struct redisCommand redisCommandTable[] = {\n    ...\n    {&quot;get&quot;,getCommand,2,&quot;rF&quot;,0,NULL,1,1,1,0,0},\n    {&quot;set&quot;,setCommand,-3,&quot;wm&quot;,0,NULL,1,1,1,0,0},\n    ...\n}\n</code></pre><p>好了，到这里，你就了解了lookupCommand函数会根据解析的命令名称，在commands对应的哈希表中查找相应的命令。</p><p>那么，一旦查到对应命令后，processCommand函数就会进行多种检查，比如命令的参数是否有效、发送命令的用户是否进行过验证、当前内存的使用情况，等等。这部分的处理逻辑比较多，你可以进一步阅读processCommand函数来了解下。</p><p>这样，等到processCommand函数对命令做完各种检查后，它就开始执行命令了。<strong>它会判断当前客户端是否有CLIENT_MULTI标记</strong>，如果有的话，就表明要处理的是Redis事务的相关命令，所以它会按照事务的要求，调用queueMultiCommand函数将命令入队保存，等待后续一起处理。</p><p>而如果没有，processCommand函数就会调用call函数来实际执行命令了。以下代码展示了这部分的逻辑，你可以看下。</p><pre><code>//如果客户端有CLIENT_MULTI标记，并且当前不是exec、discard、multi和watch命令\nif (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;\n        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;\n        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)\n    {\n        queueMultiCommand(c);  //将命令入队保存，等待后续一起处理\n        addReply(c,shared.queued);\n    } else {\n        call(c,CMD_CALL_FULL);  //调用call函数执行命令\n        ...\n    }\n</code></pre><p>这里你要知道，call函数是在server.c文件中实现的，它执行命令是通过调用命令本身，即redisCommand结构体中定义的函数指针来完成的。而就像我刚才所说的，每个redisCommand结构体中都定义了它对应的实现函数，在redisCommandTable数组中能查找到。</p><p>因为分布式锁的加锁操作就是使用SET命令来实现的，所以这里，我就以SET命令为例来介绍下它的实际执行过程。</p><p>SET命令对应的实现函数是<strong>setCommand</strong>，这是在<a href=\"http://github.com/redis/redis/tree/5.0/src/t_string.c\">t_string.c</a>文件中定义的。setCommand函数首先会对命令参数进行判断，比如参数是否带有NX、EX、XX、PX等这类命令选项，如果有的话，setCommand函数就会记录下这些标记。</p><p>然后，setCommand函数会调用setGenericCommand函数，这个函数也是在t_string.c文件中实现的。setGenericCommand函数会根据刚才setCommand函数记录的命令参数的标记，来进行相应处理。比如，如果命令参数中有NX选项，那么，setGenericCommand函数会调用lookupKeyWrite函数（在<a href=\"http://github.com/redis/redis/tree/5.0/src/db.c\">db.c</a>文件中），查找要执行SET命令的key是否已经存在。</p><p>如果这个key已经存在了，那么setGenericCommand函数就会调用addReply函数，返回NULL空值，而这也正是符合分布式锁的语义的。</p><p>下面的代码就展示了这个执行逻辑，你可以看下。</p><pre><code>//如果有NX选项，那么查找key是否已经存在\nif ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != NULL) ||\n        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == NULL))\n    {\n        addReply(c, abort_reply ? abort_reply : shared.nullbulk);  //如果已经存在，则返回空值\n        return;\n    }\n</code></pre><p>好，那么如果SET命令可以正常执行的话，也就是说命令带有NX选项但是key并不存在，或者带有XX选项但是key已经存在，这样setGenericCommand函数就会调用setKey函数（在db.c文件中）来完成键值对的实际插入，如下所示：</p><pre><code>setKey(c-&gt;db,key,val);\n</code></pre><p>然后，如果命令设置了过期时间，setGenericCommand函数还会调用setExpire函数设置过期时间。最后，setGenericCommand函数会<strong>调用addReply函数，将结果返回给客户端</strong>，如下所示：</p><pre><code>addReply(c, ok_reply ? ok_reply : shared.ok);\n</code></pre><p>好了，到这里，SET命令的执行就结束了，你也可以再看下下面的基本流程图。</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/2a/b35026e984a057ef9968afe8dafc9c2a.jpg?wh=2000x1125\" alt=\"\"></p><p>而且你也可以看到，无论是在命令执行的过程中，发现不符合命令的执行条件，或是命令能成功执行，addReply函数都会被调用，用来返回结果。所以，这就进入到我所说的命令处理过程的最后一个阶段：结果返回阶段。</p><h3>结果返回阶段：addReply函数</h3><p>addReply函数是在networking.c文件中定义的。它的执行逻辑比较简单，主要是调用prepareClientToWrite函数，并在prepareClientToWrite函数中调用clientInstallWriteHandler函数，将待写回客户端加入到全局变量server的clients_pending_write列表中。</p><p>然后，addReply函数会调用_addReplyToBuffer等函数（在networking.c中），将要返回的结果添加到客户端的输出缓冲区中。</p><p>好，现在你就了解一条命令是如何从读取，经过解析、执行等步骤，最终将结果返回给客户端的了。下图展示了这个过程以及涉及的主要函数，你可以再回顾下。</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/39/3c784ab5359bdd8ac4fc34a8a3e9a839.jpg?wh=2000x1125\" alt=\"\"></p><p>不过除此之外，你还需要注意一点，就是如果在前面的命令处理过程中，都是由IO主线程处理的，那么命令执行的原子性肯定能得到保证，分布式锁的原子性也就相应能得到保证了。</p><p>但是，如果这个处理过程配合上了我们前面介绍的IO多路复用机制和多IO线程机制，那么，这两个机制是在这个过程的什么阶段发挥作用的呢，以及会不会影响命令执行的原子性呢？</p><p>所以接下来，我们就来看下它们各自对原子性保证的影响。</p><h2>IO多路复用对命令原子性保证的影响</h2><p>首先你要知道，<strong>IO多路复用机制是在readQueryFromClient函数执行前发挥作用的</strong>。它实际是在事件驱动框架中调用aeApiPoll函数，获取一批已经就绪的socket描述符。然后执行一个循环，针对每个就绪描述符上的读事件，触发执行readQueryFromClient函数。</p><p>这样一来，即使IO多路复用机制同时获取了多个就绪socket描述符，在实际处理时，Redis的主线程仍然是针对每个事件逐一调用回调函数进行处理的。而且对于写事件来说，IO多路复用机制也是针对每个事件逐一处理的。</p><p>下面的代码展示了IO多路复用机制通过aeApiPoll函数获取一批事件，然后逐一处理的逻辑，你可以再看下。</p><pre><code>numevents = aeApiPoll(eventLoop, tvp);\n\nfor (j = 0; j &lt; numevents; j++) {\n   aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];\n   if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) {\n                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);\n                fired++;\n   }\n</code></pre><p>所以这也就是说，<strong>即使使用了IO多路复用机制，命令的整个处理过程仍然可以由IO主线程来完成，也仍然可以保证命令执行的原子性。</strong>下图就展示了IO多路复用机制和命令处理过程的关系，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/24/1a/24744c89c31c2ee3eyy37fd69f67661a.jpg?wh=2000x1125\" alt=\"\"></p><p>接下来，我们再来看下多IO线程对命令原子性保证的影响。</p><h2>多IO线程对命令原子性保证的影响</h2><p>我们知道，多IO线程可以执行读操作或是写操作。那么，对于读操作来说，readQueryFromClient函数会在执行过程中，调用postponeClient将待读客户端加入clients_pending_read等待列表。这个过程你可以再回顾下<a href=\"https://time.geekbang.org/column/article/410666\">第13讲</a>。</p><p>然后，待读客户端会被分配给多IO线程执行，每个IO线程执行的函数就是readQueryFromClient函数，readQueryFromClient函数会读取命令，并进一步调用processInputBuffer函数解析命令，这个基本过程和Redis 6.0前的代码是一样的。</p><p>不过，相比于Redis 6.0前的代码，在Redis 6.0版本中，processInputBuffer函数中<strong>新增加了一个判断条件</strong>，也就是当客户端标识中有CLIENT_PENDING_READ的话，那么在解析完命令后，processInputBuffer函数只会把客户端标识改为CLIENT_PENDING_COMMAND，就退出命令解析的循环流程了。</p><p>此时，processInputBuffer函数只是解析了第一个命令，也并不会实际调用processCommand函数来执行命令，如下所示：</p><pre><code>void processInputBuffer(client *c) {\n    /* Keep processing while there is something in the input buffer */\n    while(c-&gt;qb_pos &lt; sdslen(c-&gt;querybuf)) {\n    ...\n   if (c-&gt;argc == 0) {\n            resetClient(c);\n        } else {\n            //如果客户端有CLIENT_PENDING_READ标识，将其改为CLIENT_PENDING_COMMAND，就退出循环，并不调用processCommandAndResetClient函数执行命令\n            if (c-&gt;flags &amp; CLIENT_PENDING_READ) {\n                c-&gt;flags |= CLIENT_PENDING_COMMAND;\n                break;\n            }\n            if (processCommandAndResetClient(c) == C_ERR) {\n                return;\n            }\n        }\n   }\n}\n</code></pre><p>这样，等到所有的IO线程都解析完了第一个命令后，IO主线程中执行的handleClientsWithPendingReadsUsingThreads函数，会再调用processCommandAndResetClient函数执行命令，以及调用processInputBuffer函数解析剩余命令，这部分的内容你也可以再回顾下第13讲。</p><p>所以现在，你就可以知道，<strong>即使使用了多IO线程，其实命令执行这一阶段也是由主IO线程来完成的，所有命令执行的原子性仍然可以得到保证</strong>，也就是说分布式锁的原子性也仍然可以得到保证。</p><p>我们再来看下写回数据的流程。</p><p>在这个阶段，addReply函数是将客户端写回操作推迟执行的，而此时Redis命令已经完成执行了，所以，即使有多个IO线程在同时将客户端数据写回，也只是把结果返回给客户端，并不影响命令在Redis server中的执行结果。也就是说，<strong>即使使用了多IO线程写回，Redis同样可以保证命令执行的原子性。</strong></p><p>下图展示了使用多IO线程机制后，命令处理过程各个阶段是由什么线程执行的，你可以再看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/bb/7e5ba301bc334983e77206c52024cebb.jpg?wh=2000x1125\" alt=\"\"></p><h2>小结</h2><p>今天这节课我主要结合分布式锁的原子性保证需求，带你学习了Redis处理一条命令的整个过程。其中，你需要重点关注<strong>分布式锁实现的方法</strong>。</p><p>我们知道，加锁和解锁操作分别可以使用SET命令和Lua脚本与EVAL命令来完成。那么，分布式锁的原子性保证，就主要依赖SET和EVAL命令在Redis server中执行时的原子性保证了。</p><p>紧接着，我还带你具体剖析了下Redis中命令处理的整个过程。我把这个过程分成了四个阶段，分别是<strong>命令读取、命令解析、命令执行和结果返回</strong>。所以，你还需要了解这四个阶段中所执行函数的主要流程。</p><p>这四个阶段在Redis 6.0版本前都是由主IO线程来执行完成的。虽然Redis使用了IO多路复用机制，但是该机制只是一次性获取多个就绪的socket描述符，对应了多个发送命令请求的客户端。而Redis在主IO线程中，还是逐一来处理每个客户端上的命令的，所以命令执行的原子性依然可以得到保证。</p><p>而当使用了Redis 6.0版本后，命令处理过程中的读取、解析和结果写回，就由多个IO线程来处理了。不过你也不用担心，多个IO线程只是完成解析第一个读到的命令，命令的实际执行还是由主IO线程处理。当多个IO线程在并发写回结果时，命令就已经执行完了，不存在多IO线程冲突的问题。所以，使用了多IO线程后，命令执行的原子性仍然可以得到保证。</p><p>好，最后，我也想再说下我对多IO线程的看法。从今天课程介绍的内容中，你可以看到，<strong>多IO线程实际并不会加快命令的执行</strong>，而是只会将读取解析命令并行化执行，以及写回结果并行化执行，并且读取解析命令还是针对收到的第一条命令。实际上，这一设计考虑还是由于网络IO需要加速处理。那么，如果命令执行本身成为Redis运行时瓶颈了，你其实可以考虑使用Redis切片集群来提升处理效率。</p><h2>每课一问</h2><p>如果将命令处理过程中的命令执行也交给多IO线程执行，你觉得除了对原子性会有影响，还会有什么好处或是其他不好的影响吗？</p><p>欢迎在留言区分享你的答案和见解。如果觉得有收获，也欢迎你把今天的内容分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"13 | Redis 6.0多IO线程的效率提高了吗？","id":410666},"right":{"article_title":"15 | 为什么LRU算法原理和代码实现不一样？","id":412164}},"comments":[{"had_liked":false,"id":309063,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1629910587,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"66054420027","product_id":100084301,"comment_content":"1、无论是 IO 多路复用，还是 Redis 6.0 的多 IO 线程，Redis 执行具体命令的主逻辑依旧是「单线程」的<br><br>2、执行命令是单线程，本质上就保证了每个命令必定是「串行」执行的，前面请求处理完成，后面请求才能开始处理<br><br>3、所以 Redis 在实现分布式锁时，内部不需要考虑加锁问题，直接在主线程中判断 key 是否存在即可，实现起来非常简单<br><br>课后题：如果将命令处理过程中的命令执行也交给多 IO 线程执行，除了对原子性会有影响，还会有什么好处和坏处？<br><br>好处：<br><br>- 每个请求分配给不同的线程处理，一个请求处理慢，并不影响其它请求<br>- 请求操作的 key 越分散，性能会变高（并行处理比串行处理性能高）<br>- 可充分利用多核 CPU 资源<br><br>坏处：<br><br>- 操作同一个 key 需加锁，加锁会影响性能，如果是热点 key，性能下降明显<br>- 多线程上下文切换存在性能损耗<br>- 多线程开发和调试不友好","like_count":16,"discussions":[{"author":{"id":1657561,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4a/d9/b8046b4b.jpg","nickname":"zhangm365","note":"","ucode":"60E7DEFB3F5840","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394869,"discussion_content":"大佬，tql。就是一点疑问，感觉老师没有出现在评论区互动啊","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632108382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1009527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/77/c1310aad.jpg","nickname":"剑衣清风","note":"","ucode":"470CD81F6612F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1657561,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4a/d9/b8046b4b.jpg","nickname":"zhangm365","note":"","ucode":"60E7DEFB3F5840","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414861,"discussion_content":"是的，寥寥无几","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636905052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":394869,"ip_address":""},"score":414861,"extra":""}]}]},{"had_liked":false,"id":310549,"user_name":"林风自在","can_delete":false,"product_type":"c1","uid":1123468,"ip_address":"","ucode":"C347C10040FD55","user_header":"https://static001.geekbang.org/account/avatar/00/11/24/8c/9f38c9ac.jpg","comment_is_top":false,"comment_ctime":1630738304,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10220672896","product_id":100084301,"comment_content":"老师，有个疑问，多线程版本是在命令读取，解析和返回结果是并行的，执行是在主线程处理，是串行的。那样从整个数据流来看，是不是就保证不了命令的执行顺序了?比如命令A比命令B先到Redis服务，但是有可能B会比A先被执行了。","like_count":3,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400981,"discussion_content":"有可能，这种情况不可避免，即使redis能保证先到的命令先执行，但先到的命令也不一定是客户端先发出的命令 还要考虑网络延迟","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633510495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2879707,"avatar":"","nickname":"Geek_e5b6ba","note":"","ucode":"DFEE3444B56FD2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543716,"discussion_content":"即使不是IO多线程的情况，依然无法保证A比B先执行。单线程情况下，这取决于当前客户端在IO事件表中注册位置的先后顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641280629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310013,"user_name":"自律给我自由","can_delete":false,"product_type":"c1","uid":1322799,"ip_address":"","ucode":"6F40A68CD0B606","user_header":"https://static001.geekbang.org/account/avatar/00/14/2f/2f/1e6503bb.jpg","comment_is_top":false,"comment_ctime":1630457322,"is_pvip":true,"discussion_count":1,"race_medal":4,"score":"10220391914","product_id":100084301,"comment_content":"多线程读取命令是怎么保证顺序的？业务上是A客户端先读，B客户端再写，同时到了Redis服务端后，执行B客户端的线程比执行A客户端的线程先完成了，那给到主线程的命令执行阶段顺序不是就错了？","like_count":2,"discussions":[{"author":{"id":1043475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","nickname":"neohope","note":"","ucode":"C0268F6E7E2B6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549229,"discussion_content":"说一下个人的理解：\n1、和网络游戏等场景不同，redis并不需要保证跨客户端命令的执行顺序，也不会为了等待一个高延迟的客户端，刻意阻塞其他客户端的命令执行\n2、这些方面的保证，是要从业务层面进行设计的。比如本节提到的“分布式锁”，并非redis本身的功能，而是从业务角度来看可以这样使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643733239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311517,"user_name":"小五","can_delete":false,"product_type":"c1","uid":1411419,"ip_address":"","ucode":"B7B1F121837CD9","user_header":"https://static001.geekbang.org/account/avatar/00/15/89/5b/b014ce14.jpg","comment_is_top":false,"comment_ctime":1631265749,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5926233045","product_id":100084301,"comment_content":"为什么 IO 线程只是完成解析第一个读到的命令，而不是直接将Client输入缓冲解析完？","like_count":2,"discussions":[{"author":{"id":1043475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","nickname":"neohope","note":"","ucode":"C0268F6E7E2B6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549230,"discussion_content":"说一下个人的理解：\n主要是为了尽快完成这一轮的消息循环，进行下一轮操作，防止主线程没有响应。\nIO线程每一轮都会等待全部线程执行完毕的，其实就是卡住了主线程。\n后续命令解析，也不是一次性把全部客户端的全部命令解析完毕的，也是分开处理的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643733550,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2112229,"avatar":"https://static001.geekbang.org/account/avatar/00/20/3a/e5/1a1b08ad.jpg","nickname":"乘风","note":"","ucode":"D25976CDD1D39B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538142,"discussion_content":"从源码里看应该是全部命令都会解析完，才执行的命令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639336381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315592,"user_name":"云海","can_delete":false,"product_type":"c1","uid":1365206,"ip_address":"","ucode":"0C6CA0BE58EA21","user_header":"https://static001.geekbang.org/account/avatar/00/14/d4/d6/1d4543ac.jpg","comment_is_top":false,"comment_ctime":1633926698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633926698","product_id":100084301,"comment_content":"1，客户端A 先发起请求1，后客户端B发起请求2，服务端【无法保证】先接收到 请求1后接收到请求2，因为网络传输时间不同。<br>2，客户端A 先发起请求1，后客户端A再次发起请求2，服务端 【可以保证】 先接收到请求1后接收到请求2，这个由TCP来保证。<br>3，服务端先接收到请求1，后接收到请求2，在多io环境下，redis【可以保证】先执行请求1后执行请求2。请求会先放到列表里，多IO线程从列表依次获取请求，进行命令读取及解析，io线程都解析完第一个请求后，主线程是按序执行。","like_count":1},{"had_liked":false,"id":309510,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1630204980,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"1630204980","product_id":100084301,"comment_content":"redisCommand 结构体中 每一个代表什么什么意思的？<br>struct redisCommand {<br>    char *name;<br>    redisCommandProc *proc;<br>    int arity;<br>    char *sflags; &#47;* Flags as string representation, one char per flag. *&#47;<br>    int flags;    &#47;* The actual flags, obtained from the &#39;sflags&#39; field. *&#47;<br>    &#47;* Use a function to determine keys arguments in a command line.<br>     * Used for Redis Cluster redirect. *&#47;<br>    redisGetKeysProc *getkeys_proc;<br>    &#47;* What keys should be loaded in background when calling this command? *&#47;<br>    int firstkey; &#47;* The first argument that&#39;s a key (0 = no keys) *&#47;<br>    int lastkey;  &#47;* The last argument that&#39;s a key *&#47;<br>    int keystep;  &#47;* The step between first and last key *&#47;<br>    long long microseconds, calls;<br>};","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400989,"discussion_content":"从上到下依次表示：\n1、name 命令名字\n2、proc 命令的实现函数\n3、arity 命令参数个数，不固定可以用负数-N表示>N\n4、sflags 命令的flag，表示这个命令的属性，比如w表示写入命令，m表示会使内存增加，可以有多个属性 比如set就是wm\n5、flags 位形式的，但不是在redisCommandTable中写死，而是在populateCommandTable函数中根据sflags计算得出，比如set经过计算得到的是101(w是1，m是100)。这么转换的原因是方便判断，比如判断是否是写命令时直接flags &amp; 1 == true，进而做相应的逻辑\n6、getkeys_proc 用于识别命令中的key参数，只有在下面几个参数表示不出key参数时使用，我们常见的命令getkeys_proc 都是NULL\n7、firstkey 第一个key的位置\n8、lastkey 最后一个key的位置，如果未知，也就是可以跟不固定数量的key，直接用-1表示\n9、keystep key之间间隔的步长，主要还是为了能准确找到key。例 mset key value [key value]这三个参数为 1  -1  2\n10、microseconds 统计用，表示这个命令一共耗费的总微秒数\n11、calls 统计用，表示这个命令一共被执行的总次数\n每个命令的统计信息可以通过info commandstats查看，config resetstats重置统计\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633514103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309097,"user_name":"Milittle","can_delete":false,"product_type":"c1","uid":1045455,"ip_address":"","ucode":"80E566639A8ABB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","comment_is_top":false,"comment_ctime":1629943335,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1629943335","product_id":100084301,"comment_content":"这节课在学习之前，有80%内容是之前通过学习前面课程结合源码知晓的，老师再一串更加完整了。<br>有一个问题是：单机redis，在开启多线程读写的时候，qps最高可以打到多少？多谢老师","like_count":0,"discussions":[{"author":{"id":1066191,"avatar":"https://static001.geekbang.org/account/avatar/00/10/44/cf/a0315a85.jpg","nickname":"lzh2nix","note":"","ucode":"2B9AC282082F7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391973,"discussion_content":"官方说是可以提高一倍，具体可以redis-benchmark一把","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630742517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}