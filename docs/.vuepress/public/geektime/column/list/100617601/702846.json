{"id":702846,"title":"07｜输出解析：用OutputParser生成鲜花推荐列表","content":"<p>你好，我是黄佳，欢迎来到LangChain实战课！</p><p>首先请你回忆一下<a href=\"https://time.geekbang.org/column/article/700699\">第4课</a>中我们学了什么: 为一些花和价格生成吸引人的描述，并将这些描述和原因存储到一个CSV文件中。为了实现这个目标，程序调用了OpenAI模型，并利用了结构化输出解析器，以及一些数据处理和存储的工具。</p><p>今天我要带着你深入研究一下LangChain中的输出解析器，并用一个新的解析器——Pydantic 解析器来重构第4课中的程序。这节课也是模型I/O框架的最后一讲。</p><p><img src=\"https://static001.geekbang.org/resource/image/62/2d/6215fdd31373523a46bb02f86283522d.jpg?wh=4000x1536\" alt=\"\" title=\"模型 I/O Pipeline\"></p><p>下面先来看看LangChain中的输出解析器究竟是什么，有哪些种类。</p><h2>LangChain 中的输出解析器</h2><p>语言模型输出的是文本，这是给人类阅读的。但很多时候，你可能想要获得的是程序能够处理的结构化信息。这就是输出解析器发挥作用的地方。</p><p>输出解析器是<strong>一种专用于处理和构建语言模型响应的类</strong>。一个基本的输出解析器类通常需要实现两个核心方法。</p><ul>\n<li>get_format_instructions：这个方法需要返回一个字符串，用于指导如何格式化语言模型的输出，告诉它应该如何组织并构建它的回答。</li>\n<li>parse：这个方法接收一个字符串（也就是语言模型的输出）并将其解析为特定的数据结构或格式。这一步通常用于确保模型的输出符合我们的预期，并且能够以我们需要的形式进行后续处理。</li>\n</ul><!-- [[[read_end]]] --><p>还有一个可选的方法。</p><ul>\n<li>parse_with_prompt：这个方法接收一个字符串（也就是语言模型的输出）和一个提示（用于生成这个输出的提示），并将其解析为特定的数据结构。这样，你可以根据原始提示来修正或重新解析模型的输出，确保输出的信息更加准确和贴合要求。</li>\n</ul><p>下面是一个基于上述描述的简单伪代码示例：</p><pre><code class=\"language-plain\">class OutputParser:\n&nbsp; &nbsp; def __init__(self):\n&nbsp; &nbsp; &nbsp; &nbsp; pass\n\n&nbsp; &nbsp; def get_format_instructions(self):\n&nbsp; &nbsp; &nbsp; &nbsp; # 返回一个字符串，指导如何格式化模型的输出\n&nbsp; &nbsp; &nbsp; &nbsp; pass\n\n&nbsp; &nbsp; def parse(self, model_output):\n&nbsp; &nbsp; &nbsp; &nbsp; # 解析模型的输出，转换为某种数据结构或格式\n&nbsp; &nbsp; &nbsp; &nbsp; pass\n\n&nbsp; &nbsp; def parse_with_prompt(self, model_output, prompt):\n&nbsp; &nbsp; &nbsp; &nbsp; # 基于原始提示解析模型的输出，转换为某种数据结构或格式\n&nbsp; &nbsp; &nbsp; &nbsp; pass\n</code></pre><p>在LangChain中，通过实现get_format_instructions、parse 和 parse_with_prompt 这些方法，针对不同的使用场景和目标，设计了各种输出解析器。让我们来逐一认识一下。</p><ol>\n<li>列表解析器（List Parser）：这个解析器用于处理模型生成的输出，当需要模型的输出是一个列表的时候使用。例如，如果你询问模型“列出所有鲜花的库存”，模型的回答应该是一个列表。</li>\n<li>日期时间解析器（Datetime Parser）：这个解析器用于处理日期和时间相关的输出，确保模型的输出是正确的日期或时间格式。</li>\n<li>枚举解析器（Enum Parser）：这个解析器用于处理预定义的一组值，当模型的输出应该是这组预定义值之一时使用。例如，如果你定义了一个问题的答案只能是“是”或“否”，那么枚举解析器可以确保模型的回答是这两个选项之一。</li>\n<li>结构化输出解析器（Structured Output Parser）：这个解析器用于处理复杂的、结构化的输出。如果你的应用需要模型生成具有特定结构的复杂回答（例如一份报告、一篇文章等），那么可以使用结构化输出解析器来实现。</li>\n<li>Pydantic（JSON）解析器：这个解析器用于处理模型的输出，当模型的输出应该是一个符合特定格式的JSON对象时使用。它使用Pydantic库，这是一个数据验证库，可以用于构建复杂的数据模型，并确保模型的输出符合预期的数据模型。</li>\n<li>自动修复解析器（Auto-Fixing Parser）：这个解析器可以自动修复某些常见的模型输出错误。例如，如果模型的输出应该是一段文本，但是模型返回了一段包含语法或拼写错误的文本，自动修复解析器可以自动纠正这些错误。</li>\n<li>重试解析器（RetryWithErrorOutputParser）：这个解析器用于在模型的初次输出不符合预期时，尝试修复或重新生成新的输出。例如，如果模型的输出应该是一个日期，但是模型返回了一个字符串，那么重试解析器可以重新提示模型生成正确的日期格式。</li>\n</ol><p>上面的各种解析器中，前三种很容易理解，而结构化输出解析器你已经用过了。所以接下来我们重点讲一讲Pydantic（JSON）解析器、自动修复解析器和重试解析器。</p><h2>Pydantic（JSON）解析器实战</h2><p>Pydantic (JSON) 解析器应该是最常用也是最重要的解析器，我带着你用它来重构鲜花文案生成程序。</p><blockquote>\n<p><span class=\"reference\">Pydantic 是一个 Python 数据验证和设置管理库，主要基于 Python 类型提示。尽管它不是专为 JSON 设计的，但由于 JSON 是现代 Web 应用和 API 交互中的常见数据格式，Pydantic 在处理和验证 JSON 数据时特别有用。</span></p>\n</blockquote><h3>第一步：创建模型实例</h3><p>先通过环境变量设置OpenAI API密钥，然后使用LangChain库创建了一个OpenAI的模型实例。这里我们仍然选择了text-davinci-003作为大语言模型。</p><pre><code class=\"language-plain\"># ------Part 1\n# 设置OpenAI API密钥\nimport os\nos.environ[\"OPENAI_API_KEY\"] = '你的OpenAI API Key'\n\n# 创建模型实例\nfrom langchain import OpenAI\nmodel = OpenAI(model_name='gpt-3.5-turbo-instruct')\n</code></pre><h3>第二步：定义输出数据的格式</h3><p>先创建了一个空的DataFrame，用于存储从模型生成的描述。接下来，通过一个名为FlowerDescription的Pydantic BaseModel类，定义了期望的数据格式（也就是数据的结构）。</p><pre><code class=\"language-plain\"># ------Part 2\n# 创建一个空的DataFrame用于存储结果\nimport pandas as pd\ndf = pd.DataFrame(columns=[\"flower_type\", \"price\", \"description\", \"reason\"])\n\n# 数据准备\nflowers = [\"玫瑰\", \"百合\", \"康乃馨\"]\nprices = [\"50\", \"30\", \"20\"]\n\n# 定义我们想要接收的数据格式\nfrom pydantic import BaseModel, Field\nclass FlowerDescription(BaseModel):\n&nbsp; &nbsp; flower_type: str = Field(description=\"鲜花的种类\")\n&nbsp; &nbsp; price: int = Field(description=\"鲜花的价格\")\n&nbsp; &nbsp; description: str = Field(description=\"鲜花的描述文案\")\n&nbsp; &nbsp; reason: str = Field(description=\"为什么要这样写这个文案\")\n</code></pre><p>在这里我们用到了负责数据格式验证的Pydantic库来创建带有类型注解的类FlowerDescription，它可以自动验证输入数据，确保输入数据符合你指定的类型和其他验证条件。</p><p>Pydantic有这样几个特点。</p><ol>\n<li>数据验证：当你向Pydantic类赋值时，它会自动进行数据验证。例如，如果你创建了一个字段需要是整数，但试图向它赋予一个字符串，Pydantic会引发异常。</li>\n<li>数据转换：Pydantic不仅进行数据验证，还可以进行数据转换。例如，如果你有一个需要整数的字段，但你提供了一个可以转换为整数的字符串，如 <code>\"42\"</code>，Pydantic会自动将这个字符串转换为整数42。</li>\n<li>易于使用：创建一个Pydantic类就像定义一个普通的Python类一样简单。只需要使用Python的类型注解功能，即可在类定义中指定每个字段的类型。</li>\n<li>JSON支持：Pydantic类可以很容易地从JSON数据创建，并可以将类的数据转换为JSON格式。</li>\n</ol><p>下面，我们基于这个Pydantic数据格式类来创建LangChain的输出解析器。</p><h3>第三步：创建输出解析器</h3><p>在这一步中，我们创建输出解析器并获取输出格式指示。先使用LangChain库中的PydanticOutputParser创建了输出解析器，该解析器将用于解析模型的输出，以确保其符合FlowerDescription的格式。然后，使用解析器的get_format_instructions方法获取了输出格式的指示。</p><pre><code class=\"language-plain\"># ------Part 3\n# 创建输出解析器\nfrom langchain.output_parsers import PydanticOutputParser\noutput_parser = PydanticOutputParser(pydantic_object=FlowerDescription)\n\n# 获取输出格式指示\nformat_instructions = output_parser.get_format_instructions()\n# 打印提示\nprint(\"输出格式：\",format_instructions)\n</code></pre><p>程序输出如下：</p><pre><code class=\"language-plain\">输出格式： The output should be formatted as a JSON instance that conforms to the JSON schema below.\n\nAs an example, for the schema {\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \"required\": [\"foo\"]}}\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema. The object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\n\nHere is the output schema:\n\n{\"properties\": {\"flower_type\": {\"title\": \"Flower Type\", \"description\": \"\\u9c9c\\u82b1\\u7684\\u79cd\\u7c7b\", \"type\": \"string\"}, \"price\": {\"title\": \"Price\", \"description\": \"\\u9c9c\\u82b1\\u7684\\u4ef7\\u683c\", \"type\": \"integer\"}, \"description\": {\"title\": \"Description\", \"description\": \"\\u9c9c\\u82b1\\u7684\\u63cf\\u8ff0\\u6587\\u6848\", \"type\": \"string\"}, \"reason\": {\"title\": \"Reason\", \"description\": \"\\u4e3a\\u4ec0\\u4e48\\u8981\\u8fd9\\u6837\\u5199\\u8fd9\\u4e2a\\u6587\\u6848\", \"type\": \"string\"}}, \"required\": [\"flower_type\", \"price\", \"description\", \"reason\"]}\n</code></pre><p>上面这个输出，这部分是通过output_parser.get_format_instructions()方法生成的，这是Pydantic (JSON) 解析器的核心价值，值得你好好研究研究。同时它也算得上是一个很清晰的提示模板，能够为模型提供良好的指导，描述了模型输出应该符合的格式。（其中description中的中文被转成了UTF-8编码。）</p><p>它指示模型输出JSON Schema的形式，定义了一个有效的输出应该包含哪些字段，以及这些字段的数据类型。例如，它指定了 <code>\"flower_type\"</code> 字段应该是字符串类型，<code>\"price\"</code> 字段应该是整数类型。这个指示中还提供了一个例子，说明了什么是一个格式良好的输出。</p><p>下面，我们会把这个内容也传输到模型的提示中，<strong>让输入模型的提示和输出解析器的要求相互吻合，前后就呼应得上</strong>。</p><h3>第四步：创建提示模板</h3><p>我们定义了一个提示模板，该模板将用于为模型生成输入提示。模板中包含了你需要模型填充的变量（如价格和花的种类），以及之前获取的输出格式指示。</p><pre><code class=\"language-plain\"># ------Part 4\n# 创建提示模板\nfrom langchain import PromptTemplate\nprompt_template = \"\"\"您是一位专业的鲜花店文案撰写员。\n对于售价为 {price} 元的 {flower} ，您能提供一个吸引人的简短中文描述吗？\n{format_instructions}\"\"\"\n\n# 根据模板创建提示，同时在提示中加入输出解析器的说明\nprompt = PromptTemplate.from_template(prompt_template, \n&nbsp; &nbsp; &nbsp;  partial_variables={\"format_instructions\": format_instructions}) \n\n# 打印提示\nprint(\"提示：\", prompt)\n</code></pre><p>输出：</p><pre><code class=\"language-plain\">提示： \ninput_variables=['flower', 'price'] \n\noutput_parser=None \n\npartial_variables={'format_instructions': 'The output should be formatted as a JSON instance that conforms to the JSON schema below.\\n\\n\nAs an example, for the schema {\n\"properties\": {\"foo\": {\"title\": \"Foo\", \"description\": \"a list of strings\", \"type\": \"array\", \"items\": {\"type\": \"string\"}}}, \n\"required\": [\"foo\"]}}\\n\nthe object {\"foo\": [\"bar\", \"baz\"]} is a well-formatted instance of the schema. \nThe object {\"properties\": {\"foo\": [\"bar\", \"baz\"]}} is not well-formatted.\\n\\n\nHere is the output schema:\\n```\\n\n{\"properties\": {\n\"flower_type\": {\"title\": \"Flower Type\", \"description\": \"\\\\u9c9c\\\\u82b1\\\\u7684\\\\u79cd\\\\u7c7b\", \"type\": \"string\"}, \n\"price\": {\"title\": \"Price\", \"description\": \"\\\\u9c9c\\\\u82b1\\\\u7684\\\\u4ef7\\\\u683c\", \"type\": \"integer\"}, \n\"description\": {\"title\": \"Description\", \"description\": \"\\\\u9c9c\\\\u82b1\\\\u7684\\\\u63cf\\\\u8ff0\\\\u6587\\\\u6848\", \"type\": \"string\"}, \n\"reason\": {\"title\": \"Reason\", \"description\": \"\\\\u4e3a\\\\u4ec0\\\\u4e48\\\\u8981\\\\u8fd9\\\\u6837\\\\u5199\\\\u8fd9\\\\u4e2a\\\\u6587\\\\u6848\", \"type\": \"string\"}}, \n\"required\": [\"flower_type\", \"price\", \"description\", \"reason\"]}\\n```'} \n\ntemplate='您是一位专业的鲜花店文案撰写员。\n\\n对于售价为 {price} 元的 {flower} ，您能提供一个吸引人的简短中文描述吗？\\n\n{format_instructions}' \n\ntemplate_format='f-string' \n\nvalidate_template=True\n</code></pre><p>这就是包含了format_instructions信息的提示模板。</p><ol>\n<li><code>input_variables=['flower', 'price']</code>：这是一个包含你想要在模板中使用的输入变量的列表。我们在模板中使用了 <code>'flower'</code> 和 <code>'price'</code> 两个变量，后面我们会用具体的值（如玫瑰、20元）来替换这两个变量。</li>\n<li><code>output_parser=None</code>：这是你可以选择在模板中使用的一个输出解析器。在此例中，我们并没有选择在模板中使用输出解析器，而是在模型外部进行输出解析，所以这里是 <code>None</code>。</li>\n<li><code>partial_variables</code>：包含了你想要在模板中使用，但在生成模板时无法立即提供的变量。在这里，我们通过 <code>'format_instructions'</code> 传入输出格式的详细说明。</li>\n<li><code>template</code>：这是模板字符串本身。它包含了你想要模型生成的文本的结构。在此例中，模板字符串是你询问鲜花描述的问题，以及关于输出格式的说明。</li>\n<li><code>template_format='f-string'</code>：这是一个表示模板字符串格式的选项。此处是f-string格式。</li>\n<li><code>validate_template=True</code>：表示是否在创建模板时检查模板的有效性。这里选择了在创建模板时进行检查，以确保模板是有效的。</li>\n</ol><p>总的来说，这个提示模板是一个用于生成模型输入的工具。你可以在模板中定义需要的输入变量，以及模板字符串的格式和结构，然后使用这个模板来为每种鲜花生成一个描述。</p><p>后面，我们还要把实际的信息，循环传入提示模板，生成一个个的具体提示。下面让我们继续。</p><h3>第五步：生成提示，传入模型并解析输出</h3><p>这部分是程序的主体，我们循环来处理所有的花和它们的价格。对于每种花，都根据提示模板创建了输入，然后获取模型的输出。然后使用之前创建的解析器来解析这个输出，并将解析后的输出添加到DataFrame中。最后，你打印出了所有的结果，并且可以选择将其保存到CSV文件中。</p><pre><code class=\"language-plain\"># ------Part 5\nfor flower, price in zip(flowers, prices):\n&nbsp; &nbsp; # 根据提示准备模型的输入\n&nbsp; &nbsp; input = prompt.format(flower=flower, price=price)\n&nbsp; &nbsp; # 打印提示\n&nbsp; &nbsp; print(\"提示：\", input)\n\n&nbsp; &nbsp; # 获取模型的输出\n&nbsp; &nbsp; output = model(input)\n\n&nbsp; &nbsp; # 解析模型的输出\n&nbsp; &nbsp; parsed_output = output_parser.parse(output)\n&nbsp; &nbsp; parsed_output_dict = parsed_output.dict() &nbsp;# 将Pydantic格式转换为字典\n\n&nbsp; &nbsp; # 将解析后的输出添加到DataFrame中\n&nbsp; &nbsp; df.loc[len(df)] = parsed_output.dict()\n\n# 打印字典\nprint(\"输出的数据：\", df.to_dict(orient='records'))\n</code></pre><p>这一步中，你使用你的模型和输入提示（由鲜花种类和价格组成）生成了一个具体鲜花的文案需求（同时带有格式描述），然后传递给大模型，也就是说，提示模板中的 flower 和 price，此时都被具体的花取代了，而且模板中的 {format_instructions}，也被替换成了 JSON Schema 中指明的格式信息。</p><p>具体来说，输出的一个提示是这样的：</p><blockquote>\n<p><strong>提示</strong>： 您是一位专业的鲜花店文案撰写员。<br>\n对于售价为 20 元的 康乃馨 ，您能提供一个吸引人的简短中文描述吗？<br>\n&nbsp;<br>\nThe output should be formatted as a JSON instance that conforms to the JSON schema below.<br>\n&nbsp;<br>\nAs an example, for the schema {“properties”: {“foo”: {“title”: “Foo”, “description”: “a list of strings”, “type”: “array”, “items”: {“type”: “string”}}}, “required”: [“foo”]}}<br>\nthe object {“foo”: [“bar”, “baz”]} is a well-formatted instance of the schema. The object {“properties”: {“foo”: [“bar”, “baz”]}} is not well-formatted.<br>\n&nbsp;<br>\nHere is the output schema:</p>\n<pre><code>{&quot;properties&quot;: {&quot;flower_type&quot;: {&quot;title&quot;: &quot;Flower Type&quot;, &quot;description&quot;: &quot;\\u9c9c\\u82b1\\u7684\\u79cd\\u7c7b&quot;, &quot;type&quot;: &quot;string&quot;}, &quot;price&quot;: {&quot;title&quot;: &quot;Price&quot;, &quot;description&quot;: &quot;\\u9c9c\\u82b1\\u7684\\u4ef7\\u683c&quot;, &quot;type&quot;: &quot;integer&quot;}, &quot;description&quot;: {&quot;title&quot;: &quot;Description&quot;, &quot;description&quot;: &quot;\\u9c9c\\u82b1\\u7684\\u63cf\\u8ff0\\u6587\\u6848&quot;, &quot;type&quot;: &quot;string&quot;}, &quot;reason&quot;: {&quot;title&quot;: &quot;Reason&quot;, &quot;description&quot;: &quot;\\u4e3a\\u4ec0\\u4e48\\u8981\\u8fd9\\u6837\\u5199\\u8fd9\\u4e2a\\u6587\\u6848&quot;, &quot;type&quot;: &quot;string&quot;}}, &quot;required&quot;: [&quot;flower_type&quot;, &quot;price&quot;, &quot;description&quot;, &quot;reason&quot;]}\n</code></pre>\n</blockquote><p>下面，程序解析模型的输出。在这一步中，你使用你之前定义的输出解析器（output_parser）将模型的输出解析成了一个FlowerDescription的实例。FlowerDescription是你之前定义的一个Pydantic类，它包含了鲜花的类型、价格、描述以及描述的理由。</p><p>然后，将解析后的输出添加到DataFrame中。在这一步中，你将解析后的输出（即FlowerDescription实例）转换为一个字典，并将这个字典添加到你的DataFrame中。这个DataFrame是你用来存储所有鲜花描述的。</p><p>模型的最后输出如下：</p><pre><code class=\"language-plain\">输出的数据： \n[{'flower_type': 'Rose', 'price': 50, 'description': '玫瑰是最浪漫的花，它具有柔和的粉红色，有着浓浓的爱意，价格实惠，50元就可以拥有一束玫瑰。', 'reason': '玫瑰代表着爱情，是最浪漫的礼物，以实惠的价格，可以让您尽情体验爱的浪漫。'}, \n{'flower_type': '百合', 'price': 30, 'description': '这支百合，柔美的花蕾，在你的手中摇曳，仿佛在与你深情的交谈', 'reason': '营造浪漫氛围'}, \n{'flower_type': 'Carnation', 'price': 20, 'description': '艳丽缤纷的康乃馨，带给你温馨、浪漫的气氛，是最佳的礼物选择！', 'reason': '康乃馨是一种颜色鲜艳、芬芳淡雅、具有浪漫寓意的鲜花，非常适合作为礼物，而且20元的价格比较实惠。'}]\n</code></pre><p>因此，Pydantic的优点就是容易解析，而解析之后的字典格式的列表在进行数据分析、处理和存储时非常方便。每个字典代表一条记录，它的键（ 即 <code>\"flower_type\"</code>、<code>\"price\"</code>、<code>\"description\"</code> 和 <code>\"reason\"</code>）是字段名称，对应的值是这个字段的内容。这样一来，每个字段都对应一列，每个字典就是一行，适合以DataFrame的形式来表示和处理。</p><h2>自动修复解析器（OutputFixingParser）实战</h2><p>下面咱们来看看如何使用自动修复解析器。</p><p>首先，让我们来设计一个解析时出现的错误。</p><pre><code class=\"language-plain\"># 导入所需要的库和模块\nfrom langchain.output_parsers import PydanticOutputParser\nfrom pydantic import BaseModel, Field\nfrom typing import List\n\n# 使用Pydantic创建一个数据格式，表示花\nclass Flower(BaseModel):\n&nbsp; &nbsp; name: str = Field(description=\"name of a flower\")\n&nbsp; &nbsp; colors: List[str] = Field(description=\"the colors of this flower\")\n# 定义一个用于获取某种花的颜色列表的查询\nflower_query = \"Generate the charaters for a random flower.\"\n\n# 定义一个格式不正确的输出\nmisformatted = \"{'name': '康乃馨', 'colors': ['粉红色','白色','红色','紫色','黄色']}\"\n\n# 创建一个用于解析输出的Pydantic解析器，此处希望解析为Flower格式\nparser = PydanticOutputParser(pydantic_object=Flower)\n# 使用Pydantic解析器解析不正确的输出\nparser.parse(misformatted)\n</code></pre><p>这段代码如果运行，会出现错误。</p><pre><code class=\"language-plain\">langchain.schema.output_parser.OutputParserException: Failed to parse Flower from completion {'name': '康乃馨', 'colors': ['粉红色','白色']}. Got: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)\n</code></pre><p>这个错误消息来自Python的内建JSON解析器发现我们输入的JSON格式不正确。程序尝试用PydanticOutputParser来解析JSON字符串时，Python期望属性名称被双引号包围，但在给定的JSON字符串中是单引号。</p><p>当这个错误被触发后，程序进一步引发了一个自定义异常：OutputParserException，它提供了更多关于错误的上下文。这个自定义异常的消息表示在尝试解析flower对象时遇到了问题。</p><p>刚才说了，问题在于misformatted字符串的内容：</p><p><code>\"{'name': '康乃馨', 'colors': ['粉红色','白色','红色','紫色','黄色']}\"</code></p><p>应该改为：</p><p><code>'{\"name\": \"康乃馨\", \"colors\": [\"粉红色\",\"白色\",\"红色\",\"紫色\",\"黄色\"]}'</code></p><p>这样，你的JSON字符串就会使用正确的双引号格式，应该可以被正确地解析。</p><p>不过，这里我并不想这样解决问题，而是尝试使用OutputFixingParser来帮助咱们自动解决类似的格式错误。</p><pre><code class=\"language-plain\"># 从langchain库导入所需的模块\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.output_parsers import OutputFixingParser\n\n# 设置OpenAI API密钥\nimport os\nos.environ[\"OPENAI_API_KEY\"] = '你的OpenAI API Key'\n\n# 使用OutputFixingParser创建一个新的解析器，该解析器能够纠正格式不正确的输出\nnew_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())\n\n# 使用新的解析器解析不正确的输出\nresult = new_parser.parse(misformatted) # 错误被自动修正\nprint(result) # 打印解析后的输出结果\n</code></pre><p>用上面的新的new_parser来代替Parser进行解析，你会发现，JSON格式的错误问题被解决了，程序不再出错。</p><p>输出如下：</p><pre><code class=\"language-plain\">name='Rose' colors=['red', 'pink', 'white']\n</code></pre><p>这里的秘密在于，在OutputFixingParser内部，调用了原有的PydanticOutputParser，如果成功，就返回；如果失败，它会将格式错误的输出以及格式化的指令传递给大模型，并要求LLM进行相关的修复。</p><p>神奇吧，大模型不仅给我们提供知识，还随时帮助分析并解决程序出错的信息。</p><h2>重试解析器（RetryWithErrorOutputParser）实战</h2><p>OutputFixingParser不错，但它只能做简单的格式修复。如果出错的不只是格式，比如，输出根本不完整，有缺失内容，那么仅仅根据输出和格式本身，是无法修复它的。</p><p>此时，通过实现输出解析器中parse_with_prompt方法，LangChain提供的重试解析器可以帮助我们利用大模型的推理能力根据原始提示找回相关信息。</p><p>我们通过分析一个重试解析器的用例来理解上面的这段话。</p><p>首先还是设计一个解析过程中的错误。</p><pre><code class=\"language-plain\"># 定义一个模板字符串，这个模板将用于生成提问\ntemplate = \"\"\"Based on the user question, provide an Action and Action Input for what step should be taken.\n{format_instructions}\nQuestion: {query}\nResponse:\"\"\"\n\n# 定义一个Pydantic数据格式，它描述了一个\"行动\"类及其属性\nfrom pydantic import BaseModel, Field\nclass Action(BaseModel):\n&nbsp; &nbsp; action: str = Field(description=\"action to take\")\n&nbsp; &nbsp; action_input: str = Field(description=\"input to the action\")\n\n# 使用Pydantic格式Action来初始化一个输出解析器\nfrom langchain.output_parsers import PydanticOutputParser\nparser = PydanticOutputParser(pydantic_object=Action)\n\n# 定义一个提示模板，它将用于向模型提问\nfrom langchain.prompts import PromptTemplate\nprompt = PromptTemplate(\n&nbsp; &nbsp; template=\"Answer the user query.\\n{format_instructions}\\n{query}\\n\",\n&nbsp; &nbsp; input_variables=[\"query\"],\n&nbsp; &nbsp; partial_variables={\"format_instructions\": parser.get_format_instructions()},\n)\nprompt_value = prompt.format_prompt(query=\"What are the colors of Orchid?\")\n\n# 定义一个错误格式的字符串\nbad_response = '{\"action\": \"search\"}'\nparser.parse(bad_response) # 如果直接解析，它会引发一个错误\n</code></pre><p>由于bad_response只提供了action字段，而没有提供action_input字段，这与Action数据格式的预期不符，所以解析会失败。</p><p>我们首先尝试用OutputFixingParser来解决这个错误。</p><pre><code class=\"language-plain\">from langchain.output_parsers import OutputFixingParser\nfrom langchain.chat_models import ChatOpenAI\nfix_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())\nparse_result = fix_parser.parse(bad_response)\nprint('OutputFixingParser的parse结果:',parse_result)\n</code></pre><p>OutputFixingParser的parse结果：<code>action='search' action_input='query'</code></p><p>我们来看看这个尝试解决了什么问题，没解决什么问题。</p><p><strong>解决的问题有：</strong></p><ul>\n<li>不完整的数据：原始的bad_response只提供了action字段而没有action_input字段。OutputFixingParser已经填补了这个缺失，为action_input字段提供了值 <code>'query'</code>。</li>\n</ul><p><strong>没解决的问题有：</strong></p><ul>\n<li>具体性：尽管OutputFixingParser为action_input字段提供了默认值 <code>'query'</code>，但这并不具有描述性。真正的查询是 “Orchid（兰花）的颜色是什么？”。所以，这个修复只是提供了一个通用的值，并没有真正地回答用户的问题。</li>\n<li>可能的误导：<code>'query'</code> 可能被误解为一个指示，要求进一步查询某些内容，而不是作为实际的查询输入。</li>\n</ul><p>当然，还有更鲁棒的选择，我们最后尝试一下RetryWithErrorOutputParser这个解析器。</p><pre><code class=\"language-plain\"># 初始化RetryWithErrorOutputParser，它会尝试再次提问来得到一个正确的输出\nfrom langchain.output_parsers import RetryWithErrorOutputParser\nfrom langchain.llms import OpenAI\nretry_parser = RetryWithErrorOutputParser.from_llm(\n&nbsp; &nbsp; parser=parser, llm=OpenAI(temperature=0)\n)\nparse_result = retry_parser.parse_with_prompt(bad_response, prompt_value)\nprint('RetryWithErrorOutputParser的parse结果:',parse_result)\n</code></pre><p>这个解析器没有让我们失望，成功地还原了格式，甚至也根据传入的原始提示，还原了action_input字段的内容。</p><p>RetryWithErrorOutputParser的parse结果：<code>action='search' action_input='colors of Orchid'</code></p><h2>总结时刻</h2><p>结构化解析器和Pydantic解析器都旨在从大型语言模型中获取格式化的输出。结构化解析器更适合简单的文本响应，而Pydantic解析器则提供了对复杂数据结构和类型的支持。选择哪种解析器取决于应用的具体需求和输出的复杂性。</p><p>自动修复解析器主要适用于纠正小的格式错误，它更加“被动”，仅在原始输出出现问题时进行修复。重试解析器则可以处理更复杂的问题，包括格式错误和内容缺失。它通过重新与模型交互，使得输出更加完整和符合预期。</p><p>在选择哪种解析器时，需要考虑具体的应用场景。如果仅面临格式问题，自动修复解析器可能足够；但如果输出的完整性和准确性至关重要，那么重试解析器可能是更好的选择。</p><h2>思考题</h2><ol>\n<li>到目前为止，我们已经使用了哪些LangChain输出解析器？请你说一说它们的用法和异同。同时也请你尝试使用其他类型的输出解析器，并把代码与大家分享。</li>\n<li>为什么大模型能够返回JSON格式的数据，输出解析器用了什么魔法让大模型做到了这一点？</li>\n<li>自动修复解析器的“修复”功能具体来说是怎样实现的？请做debug，研究一下LangChain在调用大模型之前如何设计“提示”。</li>\n<li>重试解析器的原理是什么？它主要实现了解析器类的哪个可选方法？</li>\n</ol><p>题目较多，可以选择性思考，期待在留言区看到你的分享。如果你觉得内容对你有帮助，也欢迎分享给有需要的朋友！最后如果你学有余力，可以进一步学习下面的延伸阅读。</p><h2>延伸阅读</h2><ol>\n<li>工具：<a href=\"https://docs.pydantic.dev/latest/\">Pydantic</a> 是一个Python库，用于数据验证，可以确保数据符合特定的格式</li>\n<li>文档：LangChain中的各种 <a href=\"https://python.langchain.com/docs/modules/model_io/output_parsers/\">Output Parsers</a></li>\n</ol>","neighbors":{"left":{"article_title":"06｜调用模型：使用OpenAI API还是微调开源Llama2/ChatGLM？","id":702140},"right":{"article_title":"08｜链（上）：写一篇完美鲜花推文？用SequencialChain链接不同的组件","id":703296}},"comments":[{"had_liked":false,"id":381431,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1402511,"ip_address":"广东","ucode":"6E31908EFE1107","user_header":"https://static001.geekbang.org/account/avatar/00/15/66/8f/02be926d.jpg","comment_is_top":false,"comment_ctime":1695199544,"is_pvip":false,"replies":[{"id":138946,"content":"总结的清晰透彻 🧑‍🎓","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1695226179,"ip_address":"新加坡","comment_id":381431,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"从源码上看，OutputFixingParser和RetryWithErrorOutputParser的本质是相同的，都是当PydanticOutputParser.parse(input)解析失败，通过语言模型分析抛出的异常，修正input。\n不同之处在于，OutputFixingParser利用input schema、input、exception来修正input，RetryWithErrorOutputParser除了利用input schema、input、exception，还利用一个额外的prompt来修正input，有了额外的prompt，自然就能够既修正input格式，又补全input内容。","like_count":22,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628363,"discussion_content":"总结的清晰透彻 🧑‍🎓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695226179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383296,"user_name":"高源","can_delete":false,"product_type":"c1","uid":1048887,"ip_address":"吉林","ucode":"751B41FD38EF7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","comment_is_top":false,"comment_ctime":1698826070,"is_pvip":false,"replies":[{"id":139678,"content":"你的问题涉及到大型预训练模型在企业应用中的微调、性能比较以及企业落地实现的可行性和条件。我给出比较官方的回答。\n微调大模型\n对于企业来说，确实，将一个通用的大型语言模型直接用于特定业务场景通常是不够的，因为通用模型在预训练时使用的是跨领域的数据集，这可能无法充分覆盖企业特定的术语、风格或任务。因此，微调是一种常用的技术，可以提高模型在特定应用上的表现。\n微调过程通常包括以下几个步骤：\n数据准备：收集和整理企业相关的数据集，如内部文档、日志、对话记录等。\n预处理：对数据进行清洗和格式化，使其适合模型输入。\n微调：在企业数据上继续训练模型，以适应特定任务。\n评估：测试微调后模型的性能，确保其满足业务需求。\n部署：将微调后的模型部署到生产环境中。\n对于模型的层次结构和架构熟悉程度，实际上现在有很多工具和库已经简化了这一过程，使得即使不是深度学习专家也能进行基本的微调工作。当然，更深入的定制化和优化仍然需要对模型的工作原理和机器学习的相关知识有较深入的理解。\n大模型性能比较\n关于模型性能的比较，如百度的文心一言，科大的星火认知，与OpenAI的GPT-3或GPT-4的比较，不好比较。需要根据具体任务和独立评估来考量。不同的模型可能在不同的任务上表现出不同的性能水平，而且性能也受数据集、评估指标、测试条件等因素的影响。因此，没有绝对的“最好”模型，只有最适合特定任务和条件的模型。\n企业落地自建模型的现实性\n对于企业来说，自己从头开始训练一个大型语言模型通常是不现实的，原因有以下几个方面：\n成本：训练大型模型需要大量的计算资源，这意味着高昂的硬件和电力成本。\n数据：需要大规模的、高质量的训练数据。\n专业知识：需要有经验的数据科学家和机器学习工程师。\n时间：训练可能需要数周甚至数月的时间。\n维护：模型训练后还需要持续的维护和更新。\n因此，大多数企业会选择使用现成的预训练模型，并在此基础上进行微调来满足自己的需要，而不是从零开始训练。\n企业自建模型需要的条件\n如果企业确实想要自建模型，那么需要：\n团队：由数据科学家、机器学习工程师和领域专家组成的团队。\n数据：访问或创建足够的训练数据。\n计算资源：高性能的计算硬件或云计算资源。\n时间和耐心：模型开发是一个长期的过程。\n策略：清晰的业务理解和战略，以确定模型的具体用途和ROI。\n结合外部服务提供商的专业知识和资源可能是一个更实际的途径。通过合作，企业可以在不承担全部开发负担的情况下，有效利用大型语言模型。\n希望你有什么疑问可以继续探讨。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1699003287,"ip_address":"瑞士","comment_id":383296,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"老师有个问题请教，例如目前大模型比较多，我的理解如果满足企业内部自己使用，是需要对大模型微调吧才能完全满足定制，例如输出企业自己相关数据，文档，代码等，而不是简单把提示写好弄个差不多开源大模型上去。我的理解是需要微调吧，针对自己企业数据进行训练对模型，但这块听老师课我理解需要对模型层次熟悉才能下手进行微调吧，我自己理解目前从效果上还是gpt其它模型还是比较弱，百度说他的2.0已经超过gpt3.5，比gpt4差点，我觉得没那么快吧，另外训练模型机器硬件人员等各种因素叠加，不是说都能做好了吧，企业自己落地自己模型这块现实吗，自己做需要那些条件，例如人员要求等，谢谢","like_count":9,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630885,"discussion_content":"你的问题涉及到大型预训练模型在企业应用中的微调、性能比较以及企业落地实现的可行性和条件。我给出比较官方的回答。\n微调大模型\n对于企业来说，确实，将一个通用的大型语言模型直接用于特定业务场景通常是不够的，因为通用模型在预训练时使用的是跨领域的数据集，这可能无法充分覆盖企业特定的术语、风格或任务。因此，微调是一种常用的技术，可以提高模型在特定应用上的表现。\n微调过程通常包括以下几个步骤：\n数据准备：收集和整理企业相关的数据集，如内部文档、日志、对话记录等。\n预处理：对数据进行清洗和格式化，使其适合模型输入。\n微调：在企业数据上继续训练模型，以适应特定任务。\n评估：测试微调后模型的性能，确保其满足业务需求。\n部署：将微调后的模型部署到生产环境中。\n对于模型的层次结构和架构熟悉程度，实际上现在有很多工具和库已经简化了这一过程，使得即使不是深度学习专家也能进行基本的微调工作。当然，更深入的定制化和优化仍然需要对模型的工作原理和机器学习的相关知识有较深入的理解。\n大模型性能比较\n关于模型性能的比较，如百度的文心一言，科大的星火认知，与OpenAI的GPT-3或GPT-4的比较，不好比较。需要根据具体任务和独立评估来考量。不同的模型可能在不同的任务上表现出不同的性能水平，而且性能也受数据集、评估指标、测试条件等因素的影响。因此，没有绝对的“最好”模型，只有最适合特定任务和条件的模型。\n企业落地自建模型的现实性\n对于企业来说，自己从头开始训练一个大型语言模型通常是不现实的，原因有以下几个方面：\n成本：训练大型模型需要大量的计算资源，这意味着高昂的硬件和电力成本。\n数据：需要大规模的、高质量的训练数据。\n专业知识：需要有经验的数据科学家和机器学习工程师。\n时间：训练可能需要数周甚至数月的时间。\n维护：模型训练后还需要持续的维护和更新。\n因此，大多数企业会选择使用现成的预训练模型，并在此基础上进行微调来满足自己的需要，而不是从零开始训练。\n企业自建模型需要的条件\n如果企业确实想要自建模型，那么需要：\n团队：由数据科学家、机器学习工程师和领域专家组成的团队。\n数据：访问或创建足够的训练数据。\n计算资源：高性能的计算硬件或云计算资源。\n时间和耐心：模型开发是一个长期的过程。\n策略：清晰的业务理解和战略，以确定模型的具体用途和ROI。\n结合外部服务提供商的专业知识和资源可能是一个更实际的途径。通过合作，企业可以在不承担全部开发负担的情况下，有效利用大型语言模型。\n希望你有什么疑问可以继续探讨。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1699003287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048887,"avatar":"https://static001.geekbang.org/account/avatar/00/10/01/37/12e4c9c9.jpg","nickname":"高源","note":"","ucode":"751B41FD38EF7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647279,"discussion_content":"老师微调具体方法和实战你的新课程里有具体说明和调试方法吗，我比较感兴趣的是如何针对某一领域知识你给模型加载专业数据后，是如何微调参数让模型对此专业回答更准确的，另外之前提到模型根据你的问题如何得出正确答案输出，我指的是具体怎么给答案的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1719805935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"吉林","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382083,"user_name":"棟","can_delete":false,"product_type":"c1","uid":2050798,"ip_address":"广东","ucode":"D85800A3BA3CF8","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4a/ee/fe035424.jpg","comment_is_top":false,"comment_ctime":1696669650,"is_pvip":false,"replies":[{"id":139199,"content":"这里示例的意思是action_input是必须的字段，但是我们并没有pass到模型里面去。要确保你在传递数据之前将JSON字符串解析为Python字典。可以使用 json.loads() 方法来实现这一点：\nimport json\nbad_response = &#39;{&quot;action&quot;: &quot;search&quot;}&#39;\nparsed_response = json.loads(bad_response)\n不知道我这里是否理解了同学的具体问题。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1696846382,"ip_address":"瑞士","comment_id":382083,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"老师，请教一个问题，\nfix_parser或retry_parser中，如果错误的输出是json格式会报如下错误：\naction_input\n  Field required [type=missing, input_value={&#39;action&#39;: &#39;search&#39;}, input_type=dict]\n    For further information visit https:&#47;&#47;errors.pydantic.dev&#47;2.3&#47;v&#47;missing\n\n我是将错误bad_response = &#39;{&quot;action&quot;: &quot;search&quot;}&#39;  --&gt; 更改为bad_response = &quot;{&#39;action&#39;: &#39;search&#39;}&quot;才能正常调用模型，这个要怎么修复。\n知道的朋友也请指点，感谢！","like_count":1,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629228,"discussion_content":"这里示例的意思是action_input是必须的字段，但是我们并没有pass到模型里面去。要确保你在传递数据之前将JSON字符串解析为Python字典。可以使用 json.loads() 方法来实现这一点：\nimport json\nbad_response = &#39;{&#34;action&#34;: &#34;search&#34;}&#39;\nparsed_response = json.loads(bad_response)\n不知道我这里是否理解了同学的具体问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696846382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2050798,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/4a/ee/fe035424.jpg","nickname":"棟","note":"","ucode":"D85800A3BA3CF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":629232,"discussion_content":"感谢老师的指点，是这个意思。现在看报错明白是pysantic要求传入LLM的必须是dict类型数据了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696847201,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":629228,"ip_address":"广东","group_id":0},"score":629232,"extra":""}]},{"author":{"id":3600600,"avatar":"https://static001.geekbang.org/account/avatar/00/36/f0/d8/c344594a.jpg","nickname":"🇾.🇨.","note":"","ucode":"C033E961553EA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640865,"discussion_content":"我真是服了，刚写完，更新了一下langchain，看了眼langchain的仓库发现这个问题修掉了，1个小时前。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711952934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3600600,"avatar":"https://static001.geekbang.org/account/avatar/00/36/f0/d8/c344594a.jpg","nickname":"🇾.🇨.","note":"","ucode":"C033E961553EA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":640864,"discussion_content":"在老哥你帖子下面补一下：\n直到24/04/01：langchain任然只支持pydantic.v1，在PydanticOutputParser类有一段描述：\nclass PydanticOutputParser(JsonOutputParser, Generic[TBaseModel]):\n    &#34;&#34;&#34;Parse an output using a pydantic model.&#34;&#34;&#34;\n\n    pydantic_object: Type[TBaseModel]\n    &#34;&#34;&#34;The pydantic model to parse.\n    \n    Attention: To avoid potential compatibility issues, it&#39;s recommended to use\n        pydantic &lt;2 or leverage the v1 namespace in pydantic &gt;= 2.\n    &#34;&#34;&#34;\n上文提到目前还是推荐使用pydantic1或者使用from pydantic.v1 import BaseModel,Field","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1711951864,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391132,"user_name":"曹胖子","can_delete":false,"product_type":"c1","uid":1374648,"ip_address":"湖南","ucode":"8911E5DA412E59","user_header":"https://static001.geekbang.org/account/avatar/00/14/f9/b8/0f3bd8ec.jpg","comment_is_top":false,"comment_ctime":1717397713,"is_pvip":false,"replies":[{"id":142251,"content":"谢谢同学","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1717498861,"ip_address":"新加坡","comment_id":391132,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"parsed_output = output_parser.parse(output.content)   会报异常， 目前我尝试打印了 output的数据类型和结构，感觉是返回的数据结构出现的变动，最终我调整为 parsed_output = output_parser.parse(output.content) 后代码可执行。","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646179,"discussion_content":"谢谢同学","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717498861,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385455,"user_name":"风隼[咖啡]","can_delete":false,"product_type":"c1","uid":1044188,"ip_address":"上海","ucode":"075116DF9B0D88","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/dc/39fa0a55.jpg","comment_is_top":false,"comment_ctime":1702635183,"is_pvip":false,"replies":[{"id":140830,"content":"好嘞，谢谢您的分享！！","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1704803147,"ip_address":"新加坡","comment_id":385455,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"    # parsed_output_dict = parsed_output.dict()  # 将Pydantic格式转化位字典\n    # Pydantic 格式转化为字典,Pydantic V2dict 方法已经被废弃，推荐使用 model_dump 方法来代替\n    parsed_output_dict = parsed_output.model_dump()","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635402,"discussion_content":"好嘞，谢谢您的分享！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704803147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384968,"user_name":"rick009","can_delete":false,"product_type":"c1","uid":1016406,"ip_address":"北京","ucode":"8F931876692B7B","user_header":"","comment_is_top":false,"comment_ctime":1701859258,"is_pvip":false,"replies":[{"id":140845,"content":"可能这个格式过于复杂了，需要简化任务。另外，用最新的gpt-4-1106-preview模型试试？","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1704816924,"ip_address":"瑞士","comment_id":384968,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"老师您好，有个问题请教一下，我想要从给定的一段文本中抽离一些FAQ，然后想返回JSON数组的格式，以下是prompt：\ntemplate = &quot;&quot;&quot;你是一名知识库管理员，需将以下内容拆分成 {nums} 个问答对，确保准确无误且只从文献中获取，不得扩散。你的算法或流程应该能够准确抽取关键信息，并生成准确的问答对，以充分利用文献。\n    {doc_content}\n    {format_instructions}  \n    &quot;&quot;&quot;\n想要返回的格式为\nThe output should be formatted as a JSON instance that conforms to the JSON schema below.\\n\\nAs an example, for the schema {&quot;properties&quot;: {&quot;foo&quot;: {&quot;title&quot;: &quot;Foo&quot;, &quot;description&quot;: &quot;a list of strings&quot;, &quot;type&quot;: &quot;array&quot;, &quot;items&quot;: {&quot;type&quot;: &quot;string&quot;}}}, &quot;required&quot;: [&quot;foo&quot;]}\\nthe object {&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]} is a well-formatted instance of the schema. The object {&quot;properties&quot;: {&quot;foo&quot;: [&quot;bar&quot;, &quot;baz&quot;]}} is not well-formatted.\\n\\nHere is the output schema:\\n```\\n{&quot;$defs&quot;: {&quot;QA&quot;: {&quot;properties&quot;: {&quot;Q&quot;: {&quot;description&quot;: &quot;\\\\u95ee\\\\u9898&quot;, &quot;title&quot;: &quot;Q&quot;, &quot;type&quot;: &quot;string&quot;}, &quot;A&quot;: {&quot;description&quot;: &quot;\\\\u7b54\\\\u6848&quot;, &quot;title&quot;: &quot;A&quot;, &quot;type&quot;: &quot;string&quot;}}, &quot;required&quot;: [&quot;Q&quot;, &quot;A&quot;], &quot;title&quot;: &quot;QA&quot;, &quot;type&quot;: &quot;object&quot;}}, &quot;items&quot;: {&quot;$ref&quot;: &quot;#&#47;$defs&#47;QA&quot;}}\\n```\nclass QA(BaseModel):\n    Q: str = Field(description=&quot;问题&quot;)\n    A: str = Field(description=&quot;答案&quot;)\n\nclass QAList(RootModel):\n    root: List[QA] = Field(description=&quot;FAQ问答对列表&quot;)\n但是返回的格式总是不停的在变，都无法返回希望的数据结构","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635428,"discussion_content":"可能这个格式过于复杂了，需要简化任务。另外，用最新的gpt-4-1106-preview模型试试？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704816924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382965,"user_name":"鲸鱼","can_delete":false,"product_type":"c1","uid":1052643,"ip_address":"北京","ucode":"71437C1C601040","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/e3/c49aa508.jpg","comment_is_top":false,"comment_ctime":1698241206,"is_pvip":false,"replies":[{"id":139531,"content":"同学的这个观察很好。也很有用。可以再LangChain中Log一个Issue一起讨论一下解决方案。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1698382135,"ip_address":"瑞士","comment_id":382965,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"我遇到一个问题，目前的langchain必须使用v1版本的pydantic，如果使用了v2版本抛出的异常类型不对，会导致PydanticOutputParser无法捕获正常的ValidationError异常，从而不会去请求openAI修复response。\nPydanticOutputParser的具体捕获代码是这里\n\nclass PydanticOutputParser(BaseOutputParser[T]):\n    &quot;&quot;&quot;Parse an output using a pydantic model.&quot;&quot;&quot;\n\n    pydantic_object: Type[T]\n    &quot;&quot;&quot;The pydantic model to parse.&quot;&quot;&quot;\n\n    def parse(self, text: str) -&gt; T:\n        try:\n            # Greedy search for 1st json candidate.\n            match = re.search(\n                r&quot;\\{.*\\}&quot;, text.strip(), re.MULTILINE | re.IGNORECASE | re.DOTALL\n            )\n            json_str = &quot;&quot;\n            if match:\n                json_str = match.group()\n            json_object = json.loads(json_str, strict=False)\n            return self.pydantic_object.parse_obj(json_object)\n\n        except (json.JSONDecodeError, ValidationError) as e: # 这里只能捕获v1版本的ValidationError\n            name = self.pydantic_object.__name__\n            msg = f&quot;Failed to parse {name} from completion {text}. Got: {e}&quot;\n            raise OutputParserException(msg, llm_output=text)\n","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630394,"discussion_content":"同学的这个观察很好。也很有用。可以再LangChain中Log一个Issue一起讨论一下解决方案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698382135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"瑞士","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381428,"user_name":"在路上","can_delete":false,"product_type":"c1","uid":1402511,"ip_address":"广东","ucode":"6E31908EFE1107","user_header":"https://static001.geekbang.org/account/avatar/00/15/66/8f/02be926d.jpg","comment_is_top":false,"comment_ctime":1695197072,"is_pvip":false,"replies":[{"id":138945,"content":"很好的尝试，谢谢分享！！","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1695226120,"ip_address":"新加坡","comment_id":381428,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"佳哥好，我发现在OutputFixingParser示例中，如果做如下修改：\nnew_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI(temperature=0))\n或者\nnew_parser = OutputFixingParser.from_llm(parser=parser, llm=OpenAI(temperature=0))\n可以得到稳定的输出：\nname=&#39;康乃馨&#39; colors=[&#39;粉红色&#39;, &#39;白色&#39;, &#39;红色&#39;, &#39;紫色&#39;, &#39;黄色&#39;]\n而不是：\nname=&#39;Rose&#39; colors=[&#39;red&#39;, &#39;pink&#39;, &#39;white&#39;]","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628362,"discussion_content":"很好的尝试，谢谢分享！！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695226120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392877,"user_name":"yanyu-xin","can_delete":false,"product_type":"c1","uid":1899757,"ip_address":"广东","ucode":"3AA389F9E4C236","user_header":"","comment_is_top":false,"comment_ctime":1722050823,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"重试解析器（RetryWithErrorOutputParser）实战学习，修改代码如下。注意：要设置max_retries=3，增加重试次数，解析成功率会极大提高\n（1）原代码：\nfix_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())\n新代码：\nos.environ[&quot;BAICHUAN_API_KEY&quot;] =&quot;xxx&quot; # 请替换为你的百川模型 BAICHUAN API Key\nfrom langchain_community.llms import BaichuanLLM\n# 加载百川模型\nllm = BaichuanLLM()\nfix_parser = OutputFixingParser.from_llm(parser=parser, llm=llm, max_retries=3) # 使用百川模型，增加重试次数:3\n（2）\n原代码：\nfrom langchain.llms import OpenAI\nretry_parser = RetryWithErrorOutputParser.from_llm(\n    parser=parser, llm=OpenAI(temperature=0)\n)\n新代码：\nfrom langchain_community.llms import BaichuanLLM\n# 初始化百川智能模型\nbaichuan_llm = BaichuanLLM()\n# 初始化RetryWithErrorOutputParser，使用百川智能模型\nretry_parser = RetryWithErrorOutputParser.from_llm(\n    parser=parser, llm=baichuan_llm  , max_retries=3     # 使用百川模型\n)","like_count":1},{"had_liked":false,"id":392876,"user_name":"yanyu-xin","can_delete":false,"product_type":"c1","uid":1899757,"ip_address":"广东","ucode":"3AA389F9E4C236","user_header":"","comment_is_top":false,"comment_ctime":1722047404,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100617601,"comment_content":"继续使用国产大模型替代OpenAI进行代码学习。\n在自动修复解析器（OutputFixingParser）实战中发现，使用通义千问模型调用时出错，无法解析。但是用百川智能模型能够正确解析。\n使用百川模型修正代码如下：\n原代码：\nnew_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())\n新代码：\nos.environ[&quot;BAICHUAN_API_KEY&quot;] =&quot;xxx&quot; # 请替换为你的百川模型 BAICHUAN API Key\nfrom langchain_community.llms import BaichuanLLM\nllm = BaichuanLLM()  # 加载百川模型\nnew_parser = OutputFixingParser.from_llm(parser=parser, llm=llm, max_retries=3) # 增加重试次数:3","like_count":1},{"had_liked":false,"id":392404,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"北京","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1720838095,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":2,"score":3,"product_id":100617601,"comment_content":"第7讲打卡~\n再补充一个最简单的StrOutputParser字符串解析器，它将LLM的输出结果直接解析成字符串，在客服系统、聊天机器人等场景中使用得比较多。","like_count":1},{"had_liked":false,"id":393350,"user_name":"勤小码","can_delete":false,"product_type":"c1","uid":1071860,"ip_address":"日本","ucode":"E9813F165F5EA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKr3ZPRg8ECLpOkfpN1ny8HGV8DIkQ0fo4blKFSQgK0x76C5WiaxFXQpoIqTHWEV3bia603bBmtwZcg/132","comment_is_top":false,"comment_ctime":1723567625,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100617601,"comment_content":"2024&#47;8 目前使 langchain==0.2.12，运行文中示例代码会抛异常。参考官方文档发现需要修改两处导入：\n\nfrom langchain_core.pydantic_v1 import BaseModel, Field\nfrom langchain.output_parsers import RetryOutputParser\n\n具体内容见官方How-to文档\nhttps:&#47;&#47;python.langchain.com&#47;v0.2&#47;docs&#47;how_to&#47;output_parser_retry&#47;\n\nlangchain 目前更新比较快，各种API也不稳定，容易出现各种意想不到的问题。本示例异常原因后续再debug详细看看。\n","like_count":0},{"had_liked":false,"id":392805,"user_name":"核桃爸爸","can_delete":false,"product_type":"c1","uid":1269052,"ip_address":"陕西","ucode":"EF5C6132724FB3","user_header":"https://static001.geekbang.org/account/avatar/00/13/5d/3c/2253daa8.jpg","comment_is_top":false,"comment_ctime":1721818955,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100617601,"comment_content":"2024年7月24日，最新版本的 langchain 库无法运行成功","like_count":0},{"had_liked":false,"id":392337,"user_name":"chenyang","can_delete":false,"product_type":"c1","uid":3692736,"ip_address":"上海","ucode":"3E56A8A605C619","user_header":"https://static001.geekbang.org/account/avatar/00/38/58/c0/d1d488b0.jpg","comment_is_top":false,"comment_ctime":1720625430,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100617601,"comment_content":"老师你好，\n02_OutputFixParser.py 和 03_RetryParser.py 运行时，都会报\nKeyError: &quot;Input to PromptTemplate is missing variables {&#39;completion&#39;}.  Expected: [&#39;completion&#39;, &#39;error&#39;, &#39;instructions&#39;] Received: [&#39;instructions&#39;, &#39;input&#39;, &#39;error&#39;]&quot;\n请问是什么原因呀","like_count":0},{"had_liked":false,"id":391981,"user_name":"eagle","can_delete":false,"product_type":"c1","uid":1129632,"ip_address":"江苏","ucode":"D7601A2AFC1D17","user_header":"https://static001.geekbang.org/account/avatar/00/11/3c/a0/8b9d5aca.jpg","comment_is_top":false,"comment_ctime":1719568416,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100617601,"comment_content":"对于RetryWithErrorOutputParser，template 变量的目的是什么？ 似乎没有被引用啊？\n\ntemplate = &quot;&quot;&quot;Based on the user question, provide an Action and Action Input for what step should be taken.{format_instructions}Question: {query}Response:&quot;&quot;&quot;","like_count":0},{"had_liked":false,"id":388239,"user_name":"zhang","can_delete":false,"product_type":"c1","uid":1517047,"ip_address":"北京","ucode":"650C292030057B","user_header":"https://static001.geekbang.org/account/avatar/00/17/25/f7/4cc60573.jpg","comment_is_top":false,"comment_ctime":1709694317,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100617601,"comment_content":"老师你好，我是一个从事了几年的C语言开发者。计划在机器学习领域拓展拓展。可是我看了LangChain的一些基本理念之后，使用提示模板在性能方面比直接用代码处理异常开销要差很多吧。\n\n比如作为一个server对外提供服务的时候，它的延迟、并发数等又该如何考量呢？","like_count":0},{"had_liked":false,"id":387160,"user_name":"Geek_a23cc7","can_delete":false,"product_type":"c1","uid":3819862,"ip_address":"黑龙江","ucode":"70341CF4FDCD10","user_header":"","comment_is_top":false,"comment_ctime":1706593761,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100617601,"comment_content":"Traceback (most recent call last):\n  File &quot;E:\\Code-python\\langchain-main\\langchain-main\\07_解析输出\\01_Pydantic_Parser.py&quot;, line 71, in &lt;module&gt;\n    parsed_output = output_parser.parse(output)\n  File &quot;D:\\Anaconda\\envs\\python3.10\\lib\\site-packages\\langchain\\output_parsers\\pydantic.py&quot;, line 34, in parse\n    return self.pydantic_object.parse_obj(json_object)\n  File &quot;D:\\Anaconda\\envs\\python3.10\\lib\\site-packages\\typing_extensions.py&quot;, line 2499, in wrapper\n    return arg(*args, **kwargs)\n  File &quot;D:\\Anaconda\\envs\\python3.10\\lib\\site-packages\\pydantic\\main.py&quot;, line 1027, in parse_obj\n    return cls.model_validate(obj)\n  File &quot;D:\\Anaconda\\envs\\python3.10\\lib\\site-packages\\pydantic\\main.py&quot;, line 503, in model_validate\n    return cls.__pydantic_validator__.validate_python(\npydantic_core._pydantic_core.ValidationError: 4 validation errors for FlowerDescription\nflower_type\n  Field required [type=missing, input_value={&#39;properties&#39;: {&#39;flower_t...description&#39;, &#39;reason&#39;]}, input_type=dict]\n    For further information visit https:&#47;&#47;errors.pydantic.dev&#47;2.5&#47;v&#47;missing\nprice\n  Field required [type=missing, input_value={&#39;properties&#39;: {&#39;flower_t...description&#39;, &#39;reason&#39;]}, input_type=dict]\n    For further information visit https:&#47;&#47;errors.pydantic.dev&#47;2.5&#47;v&#47;missing\ndescription\n  Field required [type=missing, input_value={&#39;properties&#39;: {&#39;flower_t...description&#39;, &#39;reason&#39;]}, input_type=dict]\n    For further information visit https:&#47;&#47;errors.pydantic.dev&#47;2.5&#47;v&#47;missing\nreason\n  Field required [type=missing, input_value={&#39;properties&#39;: {&#39;flower_t...description&#39;, &#39;reason&#39;]}, input_type=dict]\n    For further information visit https:&#47;&#47;errors.pydantic.dev&#47;2.5&#47;v&#47;missing\n黄老师您看一下我这个问题","like_count":0,"discussions":[{"author":{"id":1285971,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9f/53/0979bba2.jpg","nickname":"HashMap","note":"","ucode":"078992C980734E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637520,"discussion_content":"我也遇到过类似的问题，基本上是ChatGPT输出的内容有问题，比如我遇到过下面这种。\n```\n{&#34;properties&#34;: {&#34;flower_type&#34;: {&#34;description&#34;: &#34;鲜花的种类&#34;, &#34;title&#34;: &#34;Flower Type&#34;, &#34;type&#34;: &#34;string&#34;}, &#34;price&#34;: {&#34;description&#34;: &#34;鲜花的价格&#34;, &#34;title&#34;: &#34;Price&#34;, &#34;type&#34;: &#34;integer&#34;}, &#34;description&#34;: {&#34;description&#34;: &#34;鲜花的描述文案&#34;, &#34;title&#34;: &#34;Description&#34;, &#34;type&#34;: &#34;string&#34;}, &#34;reason&#34;: {&#34;description&#34;: &#34;为什么要写这个文案&#34;, &#34;title&#34;: &#34;Reason&#34;, &#34;type&#34;: &#34;string&#34;}}, &#34;required&#34;: [&#34;flower_type&#34;, &#34;price&#34;, &#34;description&#34;, &#34;reason&#34;]}\n```\n\n换一个API_KEY可能会有改善，但我也遇到过，玫瑰和百合的结果都是正确的，康乃馨的返回结构不正确这种奇怪的事情。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1708586484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}