{"id":741033,"title":"第 11 章 正则表达式","content":"\n<p>这部分内容可以说是学习shell脚本之前的必学内容，这部分内容学得越好，你编写shell脚本的能力就会越强。所以你要用心学习，多加练习，练习多了就能熟练掌握shell脚本了。如果在本章遇到困难，可以通过阿铭的微信获取帮助。</p>\n<p>在计算机科学中，对“正则表达式”的定义是：它使用单个字符串来描述或匹配一系列符合某个句法规则的字符串。在很多文本编辑器或其他工具里，正则表达式通常用来检索和替换那些符合某个模式的文本内容。许多程序设计语言也都支持利用正则表达式进行字符串操作。对于系统管理员来讲，正则表达式贯穿在日常运维工作中，无论是查找某个文档，还是查询某个日志文件并分析其内容，都会用到正则表达式。</p>\n<p>其实正则表达式只是一种思想、一种表示方法。只要我们使用的工具支持这种表示方法，那么这个工具就可以处理正则表达式的字符串。常用的工具有grep、sed、awk等，其中grep、sed和awk都是针对文本的行进行操作的，下面阿铭就分别介绍一下这3种工具的使用方法。</p>\n<h2 id=\"nav_point_191\">11.1 grep/egrep工具的使用</h2>\n<p>阿铭在前面多次用到了<code>grep</code>命令，可见它的重要性。该命令的格式为：<code>grep [-cinvABC] 'word' filename</code>，其常用的选项如下所示。</p>\n<ul>\n<li><strong><code>-c</code></strong>：表示打印符合要求的行数。</li>\n<li><strong><code>-i</code></strong>：表示忽略大小写。</li>\n<li><strong><code>-n</code></strong>：表示输出符合要求的行及其行号。</li>\n<li><strong><code>-v</code></strong>：表示打印不符合要求的行。</li>\n<li><strong><code>-A</code></strong>：后面跟一个数字（有无空格都可以），例如<code>-A2</code>表示打印符合要求的行及其下面两行。</li>\n<li><strong><code>-B</code></strong>：后面跟一个数字，例如<code>-B2</code>表示打印符合要求的行及其上面两行。</li>\n<li><strong><code>-C</code></strong>：后面跟一个数字，例如<code>-C2</code>表示打印符合要求的行及其上下各两行。</li>\n</ul>\n<p>首先看看<code>-A</code>、<code>-B</code>和<code>-C</code>这3个选项的用法。</p>\n<ul>\n<li><p><code>-A2</code>会把包含<code>halt</code>的行以及这行下面的两行都打印出来：</p><!-- [[[read_end]]] -->\n<pre class=\"code-rows\"><code># grep -A2 'halt' /etc/passwd\nhalt:x:7:0:halt:/sbin:/sbin/halt\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\noperator:x:11:0:operator:/root:/sbin/nologin</code></pre>\n<blockquote>\n<p><strong>说明</strong> 在CentOS 8系统中，<code>grep</code>默认帮我们把匹配到的字符串标注成了红色，这点还是挺贴心的。其实大家可以用<code>which</code>命令看一下<code>grep</code>，你会发现grep其实是<code>grep --color=auto</code>，这个选项就是颜色显示。</p>\n</blockquote>\n</li>\n<li><p><code>-B2</code>会把包含<code>halt</code>的行以及这行上面的两行都打印出来：</p>\n<pre class=\"code-rows\"><code># grep -B2 'halt' /etc/passwd\nsync:x:5:0:sync:/sbin:/bin/sync\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\nhalt:x:7:0:halt:/sbin:/sbin/halt</code></pre>\n</li>\n<li><p><code>-C2</code>会把包含<code>halt</code>的行以及这行上下各两行都打印出来：</p>\n<pre class=\"code-rows\"><code># grep -C2 'halt' /etc/passwd\nsync:x:5:0:sync:/sbin:/bin/sync\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\nhalt:x:7:0:halt:/sbin:/sbin/halt\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\noperator:x:11:0:operator:/root:/sbin/nologin</code></pre>\n</li>\n</ul>\n<p>下面阿铭举几个典型实例来帮你更深刻地理解<code>grep</code>。</p>\n<h3 id=\"nav_point_192\">11.1.1 过滤出带有某个关键词的行，并输出行号</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># grep -n 'root' /etc/passwd\n1:root:x:0:0:root:/root:/bin/bash\n10:operator:x:11:0:operator:/root:/sbin/nologin</code></pre>\n<blockquote>\n<p><strong>说明</strong> 结果每行前面的数字显示为绿色，表示行号。</p>\n</blockquote>\n<h3 id=\"nav_point_193\">11.1.2 过滤出不带有某个关键词的行，并输出行号</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># grep -nv 'nologin' /etc/passwd\n1:root:x:0:0:root:/root:/bin/bash\n6:sync:x:5:0:sync:/sbin:/bin/sync\n7:shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\n8:halt:x:7:0:halt:/sbin:/sbin/halt\n45:aminglinux:x:1000:1000:aminglinux:/home/aminglinux:/bin/bash</code></pre>\n<h3 id=\"nav_point_194\">11.1.3 过滤出所有包含数字的行</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># grep '[0-9]' /etc/inittab\n# multi-user.target: analogous to runlevel 3\n# graphical.target: analogous to runlevel 5</code></pre>\n<blockquote>\n<p><strong>说明</strong> 某行中只要有一个数字就算匹配到了。</p>\n</blockquote>\n<h3 id=\"nav_point_195\">11.1.4 过滤出所有不包含数字的行</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># grep -v '[0-9]' /etc/inittab\n# inittab is no longer used.\n#\n# ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.\n#\n# Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target\n#\n# systemd uses 'targets' instead of runlevels. By default, there are two main targets:\n#\n#\n# To view current default target, run:\n# systemctl get-default\n#\n# To set a default target, run:\n# systemctl set-default TARGET.target</code></pre>\n<blockquote>\n<p><strong>说明</strong> 和上一例的结果正好相反，某行中只要包含一个数字，就不显示。</p>\n</blockquote>\n<h3 id=\"nav_point_196\">11.1.5 过滤掉所有以<code>#</code>开头的行</h3>\n<p>操作样例文档/etc/sos.conf的内容如下：</p>\n<pre class=\"code-rows\"><code>[plugins]\n\n#disable = rpm, selinux, dovecot\n\n[tunables]\n\n#rpm.rpmva = off\n#general.syslogsize = 15\n\n# grep -v '^#' /etc/sos.conf\n[plugins]\n\n\n[tunables]</code></pre>\n<blockquote>\n<p><strong>说明</strong> 这里面是含有空行的。</p>\n</blockquote>\n<p>那么如何将空行删除呢？示例命令如下：</p>\n<pre class=\"code-rows\"><code># grep -v '^#' /etc/sos.conf |grep -v '^$'\n[plugins]\n[tunables]</code></pre>\n<p>在正则表达式中，<code>^</code>表示行的开始，<code>$</code>表示行的结尾，那么空行就可以表示为<code>^$</code>。如何打印出不以英文字母开头的行呢？我们先来自定义一个文件，如下所示：</p>\n<pre class=\"code-rows\"><code># mkdir /tmp/1\n# cd /tmp/1\n# vim test.txt // 内容如下\n123\nabc\n456\n\nabc2323\n#laksdjf\nAlllllllll</code></pre>\n<p>接下来看两个例子：</p>\n<pre class=\"code-rows\"><code># grep '^[^a-zA-Z]' test.txt\n123\n456\n#laksdjf\n# grep '[^a-zA-Z]' test.txt\n123\n456\nabc2323\n#laksdjf</code></pre>\n<p>前面也提到过中括号<code>[]</code>的应用，如果是数字就用<code>[0-9]</code>这样的形式（当遇到类似<code>[15]</code>的形式时，表示只含有<code>1</code>或者<code>5</code>）。如果要过滤数字以及大小写字母，则要写成类似<code>[0-9a-zA-Z]</code>的形式。另外，<code>[^字符]</code>表示除<code>[]</code>内字符之外的字符。请注意，把<code>^</code>写到方括号里面和外面是有区别的。</p>\n<h3 id=\"nav_point_197\">11.1.6 过滤出任意一个字符和重复字符</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># grep 'r.o' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\noperator:x:11:0:operator:/root:/sbin/nologin</code></pre>\n<p><code>.</code>表示任意一个字符。上例中，<code>r.o</code>表示把有<code>r</code>与<code>o</code>之间任意一个字符的行过滤出来。</p>\n<pre class=\"code-rows\"><code># grep 'ooo*' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\noperator:x:11:0:operator:/root:/sbin/nologin\nsetroubleshoot:x:981:979::/var/lib/setroubleshoot:/sbin/nologin</code></pre>\n<p><code>*</code>表示零个或多个<code>*</code>前面的字符。上例中，<code>ooo*</code>表示<code>oo</code>、<code>ooo</code>、<code>oooo...</code>或者更多的<code>o</code>。</p>\n<pre class=\"code-rows\"><code># grep '.*' /etc/passwd |wc -l\n45\n# wc -l /etc/passwd\n45 /etc/passwd</code></pre>\n<p>上例中，<code>.*</code>表示零个或多个任意字符，空行也包含在内，它会把 /etc/passwd文件里面的所有行都匹配到，你也可以不加<code>|wc -l</code>看一下效果。</p>\n<h3 id=\"nav_point_198\">11.1.7 指定要过滤出的字符出现次数</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># grep 'o\\' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\noperator:x:11:0:operator:/root:/sbin/nologin\nsetroubleshoot:x:981:979::/var/lib/setroubleshoot:/sbin/nologin</code></pre>\n<p>这里用到了符号<code>{}</code>，其内部为数字，表示前面的字符要重复的次数。需要强调的是，<code>{}</code>左右都需要加上转义字符<code>\\</code>。另外，使用“<code>{ }</code>”还可以表示一个范围，具体格式为<code></code>，其中<code>n1</code> &lt; <code>n2</code>，表示重复<code>n1</code>到<code>n2</code>次前面的字符，<code>n2</code>还可以为空，这时表示大于等于<code>n1</code>次。</p>\n<p>除grep工具外，阿铭也常常用到egrep这个工具，后者是前者的扩展版本，可以完成grep不能完成的工作。下面阿铭介绍egrep不同于grep的几个用法。为了试验方便，阿铭把test.txt编辑成如下内容：</p>\n<pre class=\"code-rows\"><code>rot:x:0:0:/rot:/bin/bash\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<h3 id=\"nav_point_199\">11.1.8 过滤出一个或多个指定的字符</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># egrep 'o+' test.txt\nrot:x:0:0:/rot:/bin/bash\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n# egrep 'oo+' test.txt\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n# egrep 'ooo+' test.txt\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash</code></pre>\n<p>和<code>grep</code>不同，这里<code>egrep</code>使用的是符号<code>+</code>，它表示匹配1个或多个<code>+</code>前面的字符，但这个“<code>+</code>”是不支持被<code>grep</code>直接使用的。上面的<code>{}</code>也类似，可以直接被<code>egrep</code>使用，而不用加<code>\\</code>转义。示例如下：</p>\n<pre class=\"code-rows\"><code># egrep 'o' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\noperator:x:11:0:operator:/root:/sbin/nologin\nsetroubleshoot:x:981:979::/var/lib/setroubleshoot:/sbin/nologin</code></pre>\n<h3 id=\"nav_point_200\">11.1.9 过滤出零个或一个指定的字符</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># egrep 'o?' test.txt\nrot:x:0:0:/rot:/bin/bash\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n# egrep 'ooo?' test.txt\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n# egrep 'oooo?' test.txt\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash</code></pre>\n<h3 id=\"nav_point_201\">11.1.10 过滤出字符串<code>1</code>或者字符串<code>2</code></h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># egrep 'aaa|111|ooo' test.txt\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<h3 id=\"nav_point_202\">11.1.11 <code>egrep</code>中<code>()</code>的应用</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># egrep 'r(oo|at)o' test.txt\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash</code></pre>\n<p>这里用<code>()</code>表示一个整体，上例中会把包含<code>rooo</code>或者<code>rato</code>的行过滤出来，另外也可以把<code>()</code>和其他符号组合在一起，例如<code>(oo)+</code>就表示1个或者多个<code>oo</code>。如下所示：</p>\n<pre class=\"code-rows\"><code># egrep '(oo)+' test.txt\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash</code></pre>\n<h2 id=\"nav_point_203\">11.2 sed工具的使用</h2>\n<p>其实grep工具的功能还不够强大，它实现的只是查找功能，而不能把查找的内容替换。以前用<code>vim</code>操作文档的时候，可以查找也可以替换，但只限于在文本内部操作，而不能输出到屏幕上。sed工具以及后面要介绍的awk工具就能把替换的文本输出到屏幕上，而且还有其他更丰富的功能。sed和awk都是流式编辑器，是针对文档的行来操作的。</p>\n<h3 id=\"nav_point_204\">11.2.1 打印某行</h3>\n<p><code>sed</code>命令的格式为：<code>sed -n 'n'p filename</code>，单引号内的<code>n</code>是一个数字，表示第几行。<code>-n</code>选项的作用是只显示我们要打印的行，无关紧要的内容则不显示。示例命令如下：</p>\n<pre class=\"code-rows\"><code># sed -n '2'p /etc/passwd\nbin:x:1:1:bin:/bin:/sbin/nologin</code></pre>\n<p>你可以去掉<code>-n</code>选项对比一下差异。要想把所有行都打印出来，可以使用命令<code>sed -n '1,$'p filename</code>，如下所示：</p>\n<pre class=\"code-rows\"><code># sed -n '1,$'p test.txt\nrot:x:0:0:/rot:/bin/bash\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<p>当然，我们也可以指定一个区间打印，如下所示：</p>\n<pre class=\"code-rows\"><code># sed -n '1,3'p test.txt\nrot:x:0:0:/rot:/bin/bash\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin</code></pre>\n<h3 id=\"nav_point_205\">11.2.2 打印包含某个字符串的行</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># sed -n '/root/'p test.txt\noperator:x:11:0:operator:/root:/sbin/nologin</code></pre>\n<p>这种用法就类似于<code>grep</code>了，在<code>grep</code>中使用的特殊字符（如<code>^</code>、<code>$</code>、<code>.</code>、<code>*</code>等）同样也能在<code>sed</code>中使用，如下所示：</p>\n<pre class=\"code-rows\"><code># sed -n '/^1/'p test.txt\n1111111111111111111111111111111\n# sed -n '/in$/'p test.txt\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\n# sed -n '/r..o/'p test.txt\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n# sed -n '/ooo*/'p test.txt\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash</code></pre>\n<p><code>sed</code>命令加上<code>-e</code>选项可以实现多个行为，如下所示：</p>\n<pre class=\"code-rows\"><code># sed -e '1'p -e '/111/'p -n test.txt\nrot:x:0:0:/rot:/bin/bash\n1111111111111111111111111111111</code></pre>\n<h3 id=\"nav_point_206\">11.2.3 删除某些行</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># sed '1'd test.txt\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n# sed '1,3'd test.txt\nroooot:x:0:0:/rooooot:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n# sed '/oot/'d test.txt\nrot:x:0:0:/rot:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<p>这里参数<code>d</code>表示删除的动作，它不仅可以删除指定的单行以及多行，而且可以删除匹配某个字符的行，还可以删除从某一行开始到文档最后一行的所有行。不过，这个操作仅仅是在显示器屏幕上不显示这些行而已，文档还好好的，请不要担心。</p>\n<h3 id=\"nav_point_207\">11.2.4 替换字符或者字符串</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># sed '1,2s/ot/to/g' test.txt\nrto:x:0:0:/rto:/bin/bash\noperator:x:11:0:operator:/roto:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<p>上例中的参数<code>s</code>就表示替换的动作，参数<code>g</code>表示本行全局替换，如果不加<code>g</code>则只替换本行出现的第一个，这个用法其实和<code>vim</code>的替换大同小异。</p>\n<p>除了可以使用<code>/</code>作为分隔符外，我们还可以使用其他特殊字符，例如<code>#</code>和<code>@</code>。如下所示：</p>\n<pre class=\"code-rows\"><code># sed 's#ot#to#g' test.txt\nrto:x:0:0:/rto:/bin/bash\noperator:x:11:0:operator:/roto:/sbin/nologin\noperator:x:11:0:operator:/rooto:/sbin/nologin\nroooto:x:0:0:/rooooto:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n# sed 's@ot@to@g' test.txt\nrto:x:0:0:/rto:/bin/bash\noperator:x:11:0:operator:/roto:/sbin/nologin\noperator:x:11:0:operator:/rooto:/sbin/nologin\nroooto:x:0:0:/rooooto:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<p>现在思考一下：如何删除文档中所有的数字或者字母？示例命令如下：</p>\n<pre class=\"code-rows\"><code># sed 's/[0-9]//g' test.txt\nrot:x:::/rot:/bin/bash\noperator:x:::operator:/root:/sbin/nologin\noperator:x:::operator:/rooot:/sbin/nologin\nroooot:x:::/rooooot:/bin/bash\n\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<p>其中<code>[0-9]</code>表示任意的数字。这里你也可以写成<code>[a-zA-Z]</code>或者<code>[0-9a-zA-Z]</code>。如下所示：</p>\n<pre class=\"code-rows\"><code># sed 's/[a-zA-Z]//g' test.txt\n::0:0:/://\n::11:0::/://\n::11:0::/://\n::0:0:/://\n1111111111111111111111111111111</code></pre>\n<h3 id=\"nav_point_208\">11.2.5 调换两个字符串的位置</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># sed 's/\\(rot\\)\\(.*\\)\\(bash\\)/\\3\\2\\1/' test.txt\nbash:x:0:0:/rot:/bin/rot\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<p>小括号在<code>sed</code>中属于特殊符号，必须在其前面加转义字符<code>\\</code>，替换时则写成类似<code>\\1</code>、<code>\\2</code>或<code>\\3</code>的形式。上例中用<code>()</code>把想要替换的字符打包成了一个整体。有这个转义字符<code>\\</code>，会让这个表达式看起来乱糟糟的，阿铭有个方法可以省略它。如下所示：</p>\n<pre class=\"code-rows\"><code># sed -r 's/(rot)(.*)(bash)/\\3\\2\\1/' test.txt\nbash:x:0:0:/rot:/bin/rot\noperator:x:11:0:operator:/root:/sbin/nologin\noperator:x:11:0:operator:/rooot:/sbin/nologin\nroooot:x:0:0:/rooooot:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<p>没错，正如你看到的，就是这个<code>-r</code>选项让这个表达式更加清晰了，<code>-r</code>的作用跟<code>grep</code>的<code>-E</code>的作用是一样的，它让<code>sed</code>支持扩展正则，扩展正则其实就是使用了诸如<code>()</code>、<code>{}</code>、<code>|</code>、<code>+</code>、<code>?</code>等特殊符号的正则。</p>\n<p>除了调换两个字符串的位置，阿铭还常常用<code>sed</code>在某一行前后增加指定内容，如下所示：</p>\n<pre class=\"code-rows\"><code># sed 's/^.*$/123&amp;/' test.txt\n123rot:x:0:0:/rot:/bin/bash\n123operator:x:11:0:operator:/root:/sbin/nologin\n123operator:x:11:0:operator:/rooot:/sbin/nologin\n123roooot:x:0:0:/rooooot:/bin/bash\n1231111111111111111111111111111111\n123aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<h3 id=\"nav_point_209\">11.2.6 直接修改文件的内容</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># sed -i 's/ot/to/g' test.txt\n# cat test.txt\nrto:x:0:0:/rto:/bin/bash\noperator:x:11:0:operator:/roto:/sbin/nologin\noperator:x:11:0:operator:/rooto:/sbin/nologin\nroooto:x:0:0:/rooooto:/bin/bash\n1111111111111111111111111111111\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</code></pre>\n<p>这样就可以直接更改test.txt文件中的内容了。但必须注意，在修改前最好先备份一下文件，以免改错。</p>\n<p>关于sed工具的用法，阿铭就介绍这么多，这些足够你在日常工作中使用了，当你遇到复杂的需求时，查一下资料就可以找到答案。</p>\n<h3 id=\"nav_point_210\">11.2.7 <code>sed</code>练习题</h3>\n<p><code>sed</code>的常用功能基本上都介绍了，只要你多加练习就行。为了能让你更加牢固地掌握<code>sed</code>的应用，阿铭留几个练习题，希望你能认真完成。</p>\n<p>(1) 把/etc/passwd复制到/root/test.txt，用<code>sed</code>打印所有行。</p>\n<p>(2) 打印test.txt的第3行~第10行。</p>\n<p>(3) 打印test.txt中包含<code>root</code>的行。</p>\n<p>(4) 删除test.txt的第15行以及后面的所有行。</p>\n<p>(5) 删除test.txt中包含<code>bash</code>的行。</p>\n<p>(6) 将test.txt中的<code>root</code>替换为<code>toor</code>。</p>\n<p>(7) 将test.txt中的/sbin/nologin替换为/bin/login。</p>\n<p>(8) 删除test.txt中第5行~第10行中所有的数字。</p>\n<p>(9) 删除test.txt中所有的特殊字符（除了数字以及大小写字母）。</p>\n<p>(10) 把test.txt中第一个单词和最后一个单词调换位置。</p>\n<p>(11) 把test.txt中出现的第一组数字（1个或多个）和最后一个单词调换位置。</p>\n<p>(12) 把test.txt中第一个数字移动到本行末尾。</p>\n<p>(13) 在test.txt第20行到最后一行最前面加<code>aaa:</code>。</p>\n<p>阿铭希望你能尽量多动动脑筋，下面是以上习题的答案，仅作参考。如果有不懂的地方，不要忘记通过阿铭提供的微信求助哦。</p>\n<p>(1) <code>/bin/cp /etc/passwd&nbsp;&nbsp;/root/test.txt ;&nbsp;&nbsp;sed -n '1,$'p test.txt</code></p>\n<p>(2) <code>sed -n '3,10'p test.txt</code></p>\n<p>(3) <code>sed -n '/root/'p test.txt</code></p>\n<p>(4) <code>sed '15,$'d&nbsp;&nbsp;test.txt</code></p>\n<p>(5) <code>sed '/bash/'d test.txt</code></p>\n<p>(6) <code>sed 's/root/toor/g' test.txt</code></p>\n<p>(7) <code>sed 's#sbin/nologin#bin/login#g' test.txt</code></p>\n<p>(8) <code>sed '5,10s/[0-9]//g' test.txt</code></p>\n<p>(9) <code>sed 's/[^0-9a-zA-Z]//g' test.txt</code></p>\n<p>(10) <code>sed -r 's/(^[a-zA-Z]+)([^a-zA-Z].*[^a-zA-Z])([a-zA-Z]+$)/\\3\\2\\1/' test.txt</code></p>\n<p>(11) <code>sed -r 's/(^[^0-9]*)([0-9]+)([^0-9].*[^a-zA-Z])([a-zA-Z]+$)/\\1\\4\\3\\2/' test.txt</code></p>\n<p>(12) <code>sed -r 's/(^[^0-9]*)([0-9]+)([^0-9].*$)/\\1\\3\\2/' test.txt</code></p>\n<p>(13) <code>sed '20,$s/^.*$/aaa:&amp;/' test.txt</code></p>\n<h2 id=\"nav_point_211\">11.3 awk工具的使用</h2>\n<p>awk也是流式编辑器，针对文档中的行来操作，一行一行地执行。awk兼具sed的所有功能，而且更加强大。awk工具其实是很复杂的（有专门的书来介绍它的应用），对于初学者来说，只要能处理日常管理工作中的问题即可。鉴于此，阿铭仅介绍比较常见的awk应用，如果你感兴趣再去深入研究吧！</p>\n<h3 id=\"nav_point_212\">11.3.1 截取文档中的某个段</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># head -n2 test.txt |awk -F ':' ''\nroot\nbin</code></pre>\n<p>本例中，<code>-F</code>选项的作用是指定分隔符。如果不加<code>-F</code>选项，则以空格或者<code>tab</code>为分隔符。<code>print</code>为打印的动作，用来打印某个字段。<code>$1</code>为第1个字段，<code>$2</code>为第2个字段，以此类推。但<code>$0</code>比较特殊，它表示整行：</p>\n<pre class=\"code-rows\"><code># head -n2 test.txt |awk -F':' ''\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin</code></pre>\n<p>注意<code>awk</code>的格式，<code>-F</code>后面紧跟单引号，单引号里面为分隔符。<code>print</code>的动作要用<code>{}</code>括起来，否则会报错。<code>print</code>还可以打印自定义的内容，但是自定义的内容要用双引号括起来，如下所示：</p>\n<pre class=\"code-rows\"><code># head -n2 test.txt |awk -F ':' ''\nroot#x#0#0\nbin#x#1#1</code></pre>\n<h3 id=\"nav_point_213\">11.3.2 匹配字符或者字符串</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># awk '/oo/' test.txt\nroot:x:0:0:root:/root:/bin/bash\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\noperator:x:11:0:operator:/root:/sbin/nologin\npostfix:x:89:89::/var/spool/postfix:/sbin/nologin\nsetroubleshoot:x:992:990::/var/lib/setroubleshoot:/sbin/nologin</code></pre>\n<p>这跟<code>sed</code>的用法类似，能实现<code>grep</code>的功能，但没有颜色显示，肯定没有<code>grep</code>用起来方便。不过<code>awk</code>还有比<code>sed</code>更强大的匹配，如下所示：</p>\n<pre class=\"code-rows\"><code># awk -F ':' '$1 ~/oo/' test.txt\nroot:x:0:0:root:/root:/bin/bash\nsetroubleshoot:x:992:990::/var/lib/setroubleshoot:/sbin/nologin</code></pre>\n<p>它可以让某个段去匹配，这里的<code>~</code>就是匹配的意思。<code>awk</code>还可以多次匹配，如下所示：</p>\n<pre class=\"code-rows\"><code># awk -F ':' '/root/ /test/ ' test.txt\nroot 0\noperator 11\ntest 1006</code></pre>\n<p>本例中<code>awk</code>匹配完<code>root</code>，再匹配<code>test</code>，它还可以只打印所匹配的段。</p>\n<h3 id=\"nav_point_214\">11.3.3 条件操作符</h3>\n<p>示例命令如下：</p>\n<pre class=\"code-rows\"><code># awk -F ':' '$3==\"0\"' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash</code></pre>\n<p><code>awk</code>中可以用逻辑符号进行判断，比如<code>==</code>就是等于，也可以理解为精确匹配。另外还有<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>!=</code>等。值得注意的是，在和数字比较时，若把要比较的数字用双引号引起来，那么<code>awk</code>不会将其认为是数字，而会认为是字符，不加双引号就会认为是数字。示例命令如下：</p>\n<pre class=\"code-rows\"><code># awk -F ':' '$3&gt;=\"500\"' /etc/passwd\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\nhalt:x:7:0:halt:/sbin:/sbin/halt\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\nnobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin\ndbus:x:81:81:System message bus:/:/sbin/nologin\nsystemd-coredump:x:999:997:systemd Core Dumper:/:/sbin/nologin\ntss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin\npolkitd:x:998:996:User for polkitd:/:/sbin/nologin\ngeoclue:x:997:995:User for geoclue:/var/lib/geoclue:/sbin/nologin\nunbound:x:996:991:Unbound DNS resolver:/etc/unbound:/sbin/nologin\ngluster:x:995:990:GlusterFS daemons:/run/gluster:/sbin/nologin\nchrony:x:994:989::/var/lib/chrony:/sbin/nologin\nlibstoragemgmt:x:993:987:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologin\nsaslauth:x:992:76:Saslauthd user:/run/saslauthd:/sbin/nologin\ndnsmasq:x:986:986:Dnsmasq DHCP and DNS server:/var/lib/dnsmasq:/sbin/nologin\nradvd:x:75:75:radvd user:/:/sbin/nologin\nclevis:x:985:984:Clevis Decryption Framework unprivileged user:/var/cache/clevis:/sbin/nologin\ncockpit-ws:x:984:982:User for cockpit-ws:/:/sbin/nologin\ncolord:x:983:981:User for colord:/var/lib/colord:/sbin/nologin\nsssd:x:982:980:User for sssd:/:/sbin/nologin\nsetroubleshoot:x:981:979::/var/lib/setroubleshoot:/sbin/nologin\npipewire:x:980:978:PipeWire System Daemon:/var/run/pipewire:/sbin/nologin\ngnome-initial-setup:x:979:977::/run/gnome-initial-setup/:/sbin/nologin\ninsights:x:978:976:Red Hat Insights:/var/lib/insights:/sbin/nologin\nsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin\navahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin\ntcpdump:x:72:72::/:/sbin/nologin</code></pre>\n<p>本例中，阿铭本想把<code>uid</code>大于等于<code>500</code>的行打印出来，但是结果并不理想。这是因为<code>awk</code>把所有的数字都当作字符了，就跟上一章中提到的<code>sort</code>排序原理一样。但，如果不加双引号就得到了想要的结果：</p>\n<pre class=\"code-rows\"><code># awk -F ':' '$3&gt;=500' /etc/passwd\nnobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin\nsystemd-coredump:x:999:997:systemd Core Dumper:/:/sbin/nologin\npolkitd:x:998:996:User for polkitd:/:/sbin/nologin\ngeoclue:x:997:995:User for geoclue:/var/lib/geoclue:/sbin/nologin\nunbound:x:996:991:Unbound DNS resolver:/etc/unbound:/sbin/nologin\ngluster:x:995:990:GlusterFS daemons:/run/gluster:/sbin/nologin\nchrony:x:994:989::/var/lib/chrony:/sbin/nologin\nlibstoragemgmt:x:993:987:daemon account for libstoragemgmt:/var/run/lsm:/sbin/nologin\nsaslauth:x:992:76:Saslauthd user:/run/saslauthd:/sbin/nologin\ndnsmasq:x:986:986:Dnsmasq DHCP and DNS server:/var/lib/dnsmasq:/sbin/nologin\nclevis:x:985:984:Clevis Decryption Framework unprivileged user:/var/cache/clevis:/sbin/nologin\ncockpit-ws:x:984:982:User for cockpit-ws:/:/sbin/nologin\ncolord:x:983:981:User for colord:/var/lib/colord:/sbin/nologin\nsssd:x:982:980:User for sssd:/:/sbin/nologin\nsetroubleshoot:x:981:979::/var/lib/setroubleshoot:/sbin/nologin\npipewire:x:980:978:PipeWire System Daemon:/var/run/pipewire:/sbin/nologin\ngnome-initial-setup:x:979:977::/run/gnome-initial-setup/:/sbin/nologin\ninsights:x:978:976:Red Hat Insights:/var/lib/insights:/sbin/nologin\naminglinux:x:1000:1000:aminglinux:/home/aminglinux:/bin/bash\n# awk -F ':' '$7!=\"/sbin/nologin\"' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nsync:x:5:0:sync:/sbin:/bin/sync\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\nhalt:x:7:0:halt:/sbin:/sbin/halt\naminglinux:x:1000:1000:aminglinux:/home/aminglinux:/bin/bash</code></pre>\n<p>上例中，<code>!=</code>表示不匹配，它除了针对某一个段的字符进行逻辑比较外，还可以在两个段之间进行逻辑比较。如下所示：</p>\n<pre class=\"code-rows\"><code># awk -F ':' '$3&lt;$4' /etc/passwd\nadm:x:3:4:adm:/var/adm:/sbin/nologin\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\ngames:x:12:100:games:/usr/games:/sbin/nologin\nftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</code></pre>\n<p>另外还可以使用<code>&amp;&amp;</code>和<code>||</code>，它们分别表示“并且”和“或者”。<code>&amp;&amp;</code>的用法如下：</p>\n<pre class=\"code-rows\"><code># awk -F ':' '$3&gt;\"5\" &amp;&amp; $3&lt;\"7\"' /etc/passwd\nshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown\nnobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin\ntss:x:59:59:Account used by the trousers package to sandbox the tcsd daemon:/dev/null:/sbin/nologin</code></pre>\n<p><code>||</code>的用法如下：</p>\n<pre class=\"code-rows\"><code># awk -F ':' '$3&gt;1000 || $7==\"/bin/bash\"' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nnobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin\naminglinux:x:1000:1000:aminglinux:/home/aminglinux:/bin/bash</code></pre>\n<h3 id=\"nav_point_215\">11.3.4 <code>awk</code>的内置变量</h3>\n<p><code>awk</code>常用的变量有<code>OFS</code>、<code>NF</code>和<code>NR</code>。<code>OFS</code>和<code>-F</code>选项有类似的功能，也是用来定义分隔符的，但是它是在输出的时候定义。<code>NF</code>表示用分隔符分隔后一共有多少段。<code>NR</code>表示行号。</p>\n<p><code>OFS</code>的用法示例如下：</p>\n<pre class=\"code-rows\"><code># head -5 /etc/passwd |awk -F ':' ' '\nroot#0#0\nbin#1#1\ndaemon#2#2\nadm#3#4\nlp#4#7</code></pre>\n<p>还有更高级一些的用法：</p>\n<pre class=\"code-rows\"><code># awk -F ':' ' }' /etc/passwd\nnobody#x#65534#65534\naminglinux#x#1000#1000</code></pre>\n<p>变量<code>NF</code>的具体用法如下：</p>\n<pre class=\"code-rows\"><code># head -n3 /etc/passwd | awk -F ':' ''\n7\n7\n7\n# head -n3 /etc/passwd | awk -F ':' ''\n/bin/bash\n/sbin/nologin\n/sbin/nologin</code></pre>\n<p>这里<code>NF</code>是多少段，<code>$NF</code>是最后一段的值。变量<code>NR</code>的具体用法如下：</p>\n<pre class=\"code-rows\"><code># head -n3 /etc/passwd | awk -F ':' ''\n1\n2\n3</code></pre>\n<p>我们还可以使用<code>NR</code>作为判断条件，如下所示：</p>\n<pre class=\"code-rows\"><code># awk 'NR&gt;40' /etc/passwd\ninsights:x:978:976:Red Hat Insights:/var/lib/insights:/sbin/nologin\nsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin\navahi:x:70:70:Avahi mDNS/DNS-SD Stack:/var/run/avahi-daemon:/sbin/nologin\ntcpdump:x:72:72::/:/sbin/nologin\naminglinux:x:1000:1000:aminglinux:/home/aminglinux:/bin/bash</code></pre>\n<p><code>NR</code>也可以配合段匹配一起使用，如下所示：</p>\n<pre class=\"code-rows\"><code># awk -F ':' 'NR&lt;20 &amp;&amp; $1 ~ /roo/' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash</code></pre>\n<h3 id=\"nav_point_216\">11.3.5 <code>awk</code>中的数学运算</h3>\n<p><code>awk</code>可以更改段值，示例命令如下：</p>\n<pre class=\"code-rows\"><code># head -n 3 /etc/passwd |awk -F ':' '$1=\"root\"'\nroot x 0 0 root /root /bin/bash\nroot x 1 1 bin /bin /sbin/nologin\nroot x 2 2 daemon /sbin /sbin/nologin</code></pre>\n<p><code>awk</code>也可以对各个段的值进行数学运算，示例命令如下：</p>\n<pre class=\"code-rows\"><code># head -n2 /etc/passwd\nroot:x:0:0:root:/root:/bin/bash\nbin:x:1:1:bin:/bin:/sbin/nologin\n# head -n2 /etc/passwd |awk -F ':' '{$7=$3+$4}'\n# head -n2 /etc/passwd |awk -F ':' '{$7=$3+$4; print $0}'\nroot x 0 0 root /root 0\nbin x 1 1 bin /bin 2</code></pre>\n<p><code>awk</code>还可以计算某个段的总和，示例命令如下：</p>\n<pre class=\"code-rows\"><code># awk -F ':' '{(tot=tot+$3)}; END ' /etc/passwd\n84699</code></pre>\n<p>这里的<code>END</code>是<code>awk</code>特有的语法，表示所有的行都已经执行。其实<code>awk</code>连同<code>sed</code>都可以写成一个脚本文件，而且有它们特有的语法。在<code>awk</code>中使用<code>if</code>判断、<code>for</code>循环都可以，只是阿铭认为在日常管理工作中，没有必要使用那么复杂的语句而已。如下所示：</p>\n<pre class=\"code-rows\"><code># awk -F ':' '}' /etc/passwd\nroot:x:0:0:root:/root:/bin/bash</code></pre>\n<p>最后要提醒你一下，阿铭介绍的这些仅仅是正则表达式中最基本的内容，对<code>sed</code>和<code>awk</code>并没有深入讲解，但足以满足日常工作所需。如果你碰到比较复杂的需求，实在搞不定了，可以来求助阿铭。下面阿铭出几道关于<code>awk</code>的练习题，希望你认真完成。</p>\n<h3 id=\"nav_point_217\">11.3.6 <code>awk</code>练习题</h3>\n<p>(1) 用<code>awk</code>打印整个test.txt。（以下操作都是针对test.txt的，用<code>awk</code>工具实现。）</p>\n<p>(2) 查找所有包含<code>bash</code>的行。</p>\n<p>(3) 用<code>:</code>作为分隔符，查找第3个字段等于<code>0</code>的行。</p>\n<p>(4) 用<code>:</code>作为分隔符，查找第1个字段为<code>root</code>的行，并把该段的<code>root</code>换成<code>toor</code>。（可以连同<code>sed</code>一起使用。）</p>\n<p>(5) 用<code>:</code>作为分隔符，打印最后一个字段。</p>\n<p>(6) 打印行数大于20的所有行。</p>\n<p>(7) 用<code>:</code>作为分隔符，打印所有第3个字段小于第4个字段的行。</p>\n<p>(8) 用<code>:</code>作为分隔符，打印第1个字段以及最后一个字段，并且中间用<code>@</code>连接（例如，第1行应该是这样的形式：<code>root@/bin/bash</code>）。</p>\n<p>(9) 用<code>:</code>作为分隔符，把整个文档的第4个字段相加，求和。</p>\n<p>下面是以上习题的答案，仅作参考。</p>\n<p>(1) <code>awk '' test.txt</code></p>\n<p>(2) <code>awk '/bash/' test.txt</code></p>\n<p>(3) <code>awk -F':' '$3==\"0\"' test.txt</code></p>\n<p>(4) <code>awk -F':' '$1==\"root\"' test.txt |sed 's/root/toor/'</code></p>\n<p>(5) <code>awk -F':' '' test.txt</code></p>\n<p>(6) <code>awk -F':' 'NR&gt;20' test.txt</code></p>\n<p>(7) <code>awk -F':' '$3&lt;$4' test.txt</code></p>\n<p>(8) <code>awk -F':' '' test.txt</code></p>\n<p>(9) <code>awk -F':' '{(sum+=$4)}; END ' test.txt</code></p>\n<h2 id=\"nav_point_218\">11.4 课后习题</h2>\n<p>(1) 如何把/etc/passwd中用户<code>uid</code>大于<code>500</code>的行打印出来？</p>\n<p>(2) <code>awk</code>中变量<code>NR</code>和<code>NF</code>分别表示什么含义？命令<code>awk -F ':' '' /etc/passwd</code>会打印出什么结果？</p>\n<p>(3) 用<code>grep</code>把1.txt文档中包含<code>abc</code>或者<code>123</code>的行过滤出来，并在过滤出来的行前面加上行号。</p>\n<p>(4) 命令<code>grep -v '^$' 1.txt</code>会过滤出哪些行？</p>\n<p>(5) 符号<code>.</code>、<code>.*</code>和<code>*</code>分别表示什么含义？符号<code>+</code>和<code>?</code>表示什么含义？这5个符号是否可以在<code>grep</code>、<code>egrep</code>、<code>sed</code>以及<code>awk</code>中使用？</p>\n<p>(6) <code>grep</code>里面的符号<code>{}</code>用在什么情况下？</p>\n<p>(7) <code>sed</code>有一个选项可以直接更改文本文件，是哪个选项？</p>\n<p>(8) <code>sed -i 's/.* ie//;s/[\"|&amp;].*//' file</code>这条命令表示什么操作呢？</p>\n<p>(9) 如何删除一个文档中的所有数字或者字母？</p>\n<p>(10) 截取日志1.log的第1个字段（以空格为分隔符），按数字排序，然后去重，但是需要保留重复的数量，如何做？</p>\n<p>(11) 使用<code>awk</code>过滤出1.log中第7个字段（以空格为分隔符）为<code>200</code>并且第8个字段为<code>11897</code>的行。</p>\n<p>(12) 请比较这两个命令的异同：<code>grep -v '^[0-9]' 1.txt</code>和<code>grep '^[^0-9]' 1.txt。</code></p>\n<p>(13) <code>awk</code>中的<code>$0</code>表示什么？为什么以下两条命令的<code>$0</code>结果不一致呢？</p>\n<pre class=\"code-rows\"><code>awk -F ':' '' 1.txt\nawk -F ':' '$7=1 ' 1.txt</code></pre>\n<p>(14) 使用<code>grep</code>过滤某个关键词时，如何把包含关键词的行连同上面一行打印出来？连同下面一行也打印呢？同时打印上下各一行呢？</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 10 章 shell基础知识","id":741032},"right":{"article_title":"第 12 章 shell脚本","id":741034}},"comments":[{"had_liked":false,"id":387343,"user_name":"无咎","can_delete":false,"product_type":"c1","uid":1479120,"ip_address":"天津","ucode":"B9759B5646F3AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","comment_is_top":false,"comment_ctime":1707016554,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636611,"comment_content":"建议所有演示的文件，比如：test.txt，内容托管到服务器如github，这样便于读者联系命令，复现结果。","like_count":0}]}