{"id":740937,"title":"2.2 归并排序","content":"\n<p>在本节中我们所讨论的算法都基于<strong>归并</strong>这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。很快人们就根据这个操作发明了一种简单的递归排序算法：<strong>归并排序</strong>。要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。你将会看到，归并排序最吸引人的性质是它能够保证将任意长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的数组排序所需时间和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00918.gif\" alt=\"N\\log N\" inline-img=\"true\" /> 成正比；它的主要缺点则是它所需的额外空间和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 成正比。简单的归并排序如图 2.2.1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01119.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.2.1　归并排序示意图</strong></p>\n<h3 id=\"nav_point_81\">2.2.1　原地归并的抽象方法</h3>\n<p>实现归并的一种直截了当的办法是将两个不同的有序数组归并到第三个数组中，两个数组中的元素应该都实现了 <code>Comparable</code> 接口。实现的方法很简单，创建一个适当大小的数组然后将两个输入数组中的元素一个个从小到大放入这个数组中。</p>\n<p>但是，当用归并将一个大数组排序时，我们需要进行很多次归并，因此在每次归并时都创建一个新数组来存储排序结果会带来问题。我们更希望有一种能够在原地归并的方法，这样就可以先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要使用额外的空间。你可以先停下来想想应该如何实现这一点，乍一看很容易做到，但实际上已有的实现都非常复杂，尤其是和使用额外空间的方法相比。</p>\n<p>尽管如此，将原地归并<strong>抽象化</strong>仍然是有帮助的。与之对应的是我们的方法签名 <code>merge(a, lo, mid, hi)</code>，它会将子数组 <code>a[lo..mid]</code> 和 <code>a[mid+1..hi]</code> 归并成一个有序的数组并将结果存放在 <code>a[lo..hi]</code> 中。下面的代码只用几行就实现了这种归并。它将涉及的所有元素复制到一个辅助数组中，再把归并的结果放回原数组中。实现的另一种方法请见练习 2.2.10。</p><!-- [[[read_end]]] -->\n<blockquote>\n<p><strong>原地归并的抽象方法</strong></p>\n<pre class=\"code-rows\"><code>public static void merge(Comparable[] a, int lo, int mid, int hi)\n{  // 将a[lo..mid] 和 a[mid+1..hi] 归并\n   int i = lo, j = mid+1;\n\n   for (int k = lo; k &lt;= hi; k++)  // 将a[lo..hi]复制到aux[lo..hi]\n      aux[k] = a[k];\n\n   for (int k = lo; k &lt;= hi; k++)  // 归并回到a[lo..hi]\n      if      (i &gt; mid)              a[k] = aux[j++];\n      else if (j &gt; hi )              a[k] = aux[i++];\n      else if (less(aux[j], aux[i])) a[k] = aux[j++];\n      else a[k] =                    aux[i++];\n}</code></pre>\n<p>该方法先将所有元素复制到 <code>aux[]</code> 中，然后再归并回 <code>a[]</code> 中。方法在归并时（第二个 <code>for</code> 循环）进行了 4 个条件判断：左半边用尽（取右半边的元素）、右半边用尽（取左半边的元素）、右半边的当前元素小于左半边的当前元素（取右半边的元素）以及右半边的当前元素大于等于左半边的当前元素（取左半边的元素）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01120.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p><strong>原地归并的抽象方法的轨迹</strong></p>\n</blockquote>\n<h3 id=\"nav_point_82\">2.2.2　自顶向下的归并排序</h3>\n<p>算法 2.4 基于原地归并的抽象实现了另一种递归归并，这也是应用高效算法设计中<strong>分治思想</strong>的最典型的一个例子。这段递归代码是归纳证明算法能够正确地将数组排序的基础：如果它能将两个子数组排序，它就能够通过归并两个子数组来将整个数组排序。</p>\n<blockquote>\n<p><strong>算法 2.4　自顶向下的归并排序</strong></p>\n<pre class=\"code-rows\"><code>public class Merge\n{\n   private static Comparable[] aux;      // 归并所需的辅助数组\n\n   public static void sort(Comparable[] a)\n\n   {\n      aux = new Comparable[a.length];    // 一次性分配空间\n      sort(a, 0, a.length - 1);\n   }\n\n   private static void sort(Comparable[] a, int lo, int hi)\n   {  // 将数组a[lo..hi]排序\n      if (hi &lt;= lo) return;\n      int mid = lo + (hi - lo)/2;\n      sort(a, lo, mid);       // 将左半边排序\n      sort(a, mid+1, hi);     // 将右半边排序\n      merge(a, lo, mid, hi);  // 归并结果（代码见“原地归并的抽象方法”）\n   }\n}</code></pre>\n<p>要对子数组 <code>a[1o..hi]</code> 进行排序，先将它分为 <code>a[1o..mid]</code> 和 <code>a[mid+1..hi]</code> 两部分，分别通过递归调用将它们单独排序，最后将有序的子数组归并为最终的排序结果。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01121.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p style=\"text-align: center\">自顶向下的归并排序中归并结果的轨迹</p>\n</blockquote>\n<p>要理解归并排序就要仔细研究该方法调用的动态情况，如图 2.2.2 中的轨迹所示。要将 <code>a[0..15]</code> 排序，<code>sort()</code> 方法会调用自己将 <code>a[0..7]</code> 排序，再在其中调用自己将 <code>a[0..3]</code> 和 <code>a[0..1]</code> 排序。在将 <code>a[0]</code> 和 <code>a[1]</code> 分别排序之后，终于才会开始将 <code>a[0]</code> 和 <code>a[1]</code> 归并（简单起见，我们在轨迹中把对单个元素的数组进行排序的调用省略了）。第二次归并是 <code>a[2]</code> 和 <code>a[3]</code>，然后是 <code>a[0..1]</code> 和 <code>a[2..3]</code>，以此类推。从这段轨迹可以看到，<code>sort()</code> 方法的作用其实在于安排多次 <code>merge()</code> 方法调用的正确顺序。后面几节还会用到这个发现。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01122.gif\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.2.2　自顶向下的归并排序的调用轨迹</strong></p>\n<p>这段代码也是我们分析归并排序的运行时间的基础。因为归并排序是算法设计中分治思想的典型应用，我们会详细对它进行分析。</p>\n<p>我们也可以通过图 2.2.3 所示的树状图来理解命题 F。每个结点都表示一个 <code>sort()</code> 方法通过 <code>merge()</code> 方法归并而成的子数组。这棵树正好有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01076.gif\" alt=\"n\" inline-img=\"true\" /> 层。对于 0 到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01123.gif\" alt=\"n-1\" inline-img=\"true\" /> 之间的任意 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" />，自顶向下的第 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 层有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01124.gif\" alt=\"2^k\" inline-img=\"true\" /> 个子数组，每个数组的长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01125.gif\" alt=\"2^\" inline-img=\"true\" />，归并最多需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01125.gif\" alt=\"2^\" inline-img=\"true\" /> 次比较。因此每层的比较次数为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01126.gif\" alt=\"2^k\\times2^=2^n\" inline-img=\"true\" />，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01076.gif\" alt=\"n\" inline-img=\"true\" /> 层总共为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01127.gif\" alt=\"n2^n=N\\lg N\" inline-img=\"true\" />。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01128.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.2.3　<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01129.gif\" alt=\"N=16\" inline-img=\"true\" /> 时归并排序中子数组的依赖树</strong></p>\n<blockquote>\n<p><strong>命题 F</strong>。对于长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的任意数组，自顶向下的归并排序需要 ½<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00960.gif\" alt=\"N\\lg N\" inline-img=\"true\" /> 至 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00960.gif\" alt=\"N\\lg N\" inline-img=\"true\" /> 次比较。</p>\n<p><strong>证明</strong>。令 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01130.gif\" alt=\"C(N)\" inline-img=\"true\" /> 表示将一个长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的数组排序时所需要的比较次数。我们有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01131.gif\" alt=\"C(0)=C(1)=0\" inline-img=\"true\" />，对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01132.gif\" alt=\"N&gt;0\" inline-img=\"true\" />，通过递归的 <code>sort()</code> 方法我们可以由相应的归纳关系得到比较次数的上限：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01133.gif\" alt=\"C(N)\\leqslant C(\\lceil N/2\\rceil)+C(\\lfloor N/2\\rfloor)+N\" /></p>\n<p>右边的第一项是将数组的左半部分排序所用的比较次数，第二项是将数组的右半部分排序所用的比较次数，第三项是归并所用的比较次数。因为归并所需的比较次数最少为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01134.gif\" alt=\"\\lfloor N/2\\rfloor\" inline-img=\"true\" />，比较次数的下限是：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01135.gif\" alt=\"C(N)\\geqslant C(\\lceil N/2\\rceil)+C(\\lfloor N/2\\rfloor)+\\lfloor N/2\\rfloor\" /></p>\n<p>当 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 为 2 的幂（即 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00952.gif\" alt=\"N=2^n\" inline-img=\"true\" />）且等号成立时我们能够得到一个解。首先，因为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01136.gif\" alt=\"\\lfloor N/2\\rfloor=\\lceil N/2\\rceil=2^\" inline-img=\"true\" />，可以得到：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01137.gif\" alt=\"C(2^n)=2C(2^)+2^n\" /></p>\n<p>将两边同时除以 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01075.gif\" alt=\"2^n\" inline-img=\"true\" /> 可得：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01138.gif\" alt=\"C(2^n)/2^n=C(2^))/2^+1\" /></p>\n<p>用这个公式替换右边的第一项，可得：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01139.gif\" alt=\"C(2^n)/2^n=C(2^))/2^+1+1\" /></p>\n<p>将上一步重复 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01123.gif\" alt=\"n-1\" inline-img=\"true\" /> 遍可得：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01140.gif\" alt=\"C(2^n)/2^n=C(2^0)/2^0+n\" /></p>\n<p>将两边同时乘以 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01075.gif\" alt=\"2^n\" inline-img=\"true\" /> 就可以解得：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01141.gif\" alt=\"C(N)=C(2^n)=n2^n=N\\lg N\" /></p>\n<p>对于一般的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />，得到的准确值要更复杂一些。但对比较次数的上下界不等式使用相同的方法不难证明前面所述的对于任意 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的结论。这个结论对于任意输入值和顺序都成立。</p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>命题 G</strong>。对于长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的任意数组，自顶向下的归并排序最多需要访问数组 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01142.gif\" alt=\"6N\\lg N\" inline-img=\"true\" /> 次。</p>\n<p><strong>证明</strong>。每次归并最多需要访问数组 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01143.gif\" alt=\"6N\" inline-img=\"true\" /> 次（<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01046.gif\" alt=\"2N\" inline-img=\"true\" /> 次用来复制，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01046.gif\" alt=\"2N\" inline-img=\"true\" /> 次用来将排好序的元素移动回去，另外最多比较 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01046.gif\" alt=\"2N\" inline-img=\"true\" /> 次），根据命题 F 即可得到这个命题的结果。</p>\n</blockquote>\n<p>命题 F 和命题 G 告诉我们归并排序所需的时间和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00960.gif\" alt=\"N\\lg N\" inline-img=\"true\" /> 成正比。这和 2.1 节所述的初级排序方法不可同日而语，它表明我们只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序。可以用归并排序处理数百万甚至更大规模的数组，这是插入排序或者选择排序做不到的。归并排序的主要缺点是辅助数组所使用的额外空间和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的大小成正比。另一方面，通过一些细致的思考我们还能够大幅度缩短归并排序的运行时间。</p>\n<h4>2.2.2.1　对小规模子数组使用插入排序</h4>\n<p>用不同的方法处理小规模问题能改进大多数递归算法的性能，因为递归会使小规模问题中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法。对排序来说，我们已经知道插入排序（或者选择排序）非常简单，因此很可能在小数组上比归并排序更快。和之前一样，一幅可视轨迹图能够很好地说明归并排序的行为方式。图 2.2.4 中的可视轨迹图显示的是改良后的归并排序的所有操作。使用插入排序处理小规模的子数组（比如长度小于 15）一般可以将归并排序的运行时间缩短 10% ～ 15%（请见练习 2.2.23）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01144.gif\" alt=\"\" width=\"80%\" style=\"width: 80%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.2.4　改进了小规模子数组排序方法后的自顶向下的归并排序的可视轨迹</strong></p>\n<h4>2.2.2.2　测试数组是否已经有序</h4>\n<p>我们可以添加一个判断条件，如果 <code>a[mid]</code> 小于等于 <code>a[mid+1]</code>，我们就认为数组已经是有序的并跳过 <code>merge()</code> 方法。这个改动不影响排序的递归调用，但是任意有序的子数组算法的运行时间就变为线性的了（请见练习 2.2.8）。</p>\n<h4>2.2.2.3　不将元素复制到辅助数组</h4>\n<p>我们可以节省将数组元素复制到用于归并的辅助数组所用的时间（但空间不行）。要做到这一点我们要调用两种排序方法，一种将数据从输入数组排序到辅助数组，一种将数据从辅助数组排序到输入数组。这种方法需要一些技巧，我们要在递归调用的每个层次交换输入数组和辅助数组的角色（请见练习 2.2.11）。</p>\n<p>这里我们要重新强调第 1 章中提出的一个很容易遗忘的要点。在每一节中，我们会将书中的每个算法都看做某种应用的关键。但在整体上，我们希望学习的是为每种应用找到最合适的算法。我们并不是在推荐读者一定要实现所提到的这些改进方法，而是提醒大家不要对算法初始实现的性能盖棺定论。研究一个新问题时，最好的方法是先实现一个你能想到的最简单的程序，当它成为瓶颈的时候再继续改进它。实现那些只能把运行时间缩短某个常数因子的改进措施可能并不值得。你需要用实验来检验一项改进，正如本书中所有练习所演示的那样。</p>\n<p>对于归并排序，刚才列出的三个建议都很容易实现且在应用归并排序时是十分有吸引力的——比如本章最后讨论的情况。</p>\n<h3 id=\"nav_point_83\">2.2.3　自底向上的归并排序</h3>\n<p>递归实现的归并排序是算法设计中<strong>分治思想</strong>的典型应用。我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。尽管我们考虑的问题是归并两个大数组，实际上我们归并的数组大多数都非常小。实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。这种实现方法比标准递归方法所需要的代码量更少。首先我们进行的是两两归并（把每个元素想象成一个大小为 1 的数组），然后是四四归并（将两个大小为 2 的数组归并成一个有 4 个元素的数组），然后是八八的归并，一直下去。在每一轮归并中，最后一次归并的第二个子数组可能比第一个子数组要小（但这对 <code>merge()</code> 方法不是问题），如果不是的话所有的归并中两个数组大小都应该一样，而在下一轮中子数组的大小会翻倍。此过程的可视轨迹如图 2.2.5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01145.gif\" alt=\"\" width=\"50%\" style=\"width: 50%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 2.2.5　自底向上的归并排序的可视轨迹</strong></p>\n<p>自底向上的归并排序算法的实现如下。</p>\n<blockquote>\n<p><strong>自底向上的归并排序</strong></p>\n<pre class=\"code-rows\"><code>public class MergeBU\n{\n   private static Comparable[] aux;      // 归并所需的辅助数组\n   // merge()方法的代码请见“原地归并的抽象方法”\n   public static void sort(Comparable[] a)\n   {  //  进行lgN次两两归并\n      int N = a.length;\n      aux = new Comparable[N];\n      for (int sz = 1; sz &lt; N; sz = sz+sz)        // sz子数组大小\n         for (int lo = 0; lo &lt; N-sz; lo += sz+sz) // lo:子数组索引\n            merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));\n   }\n}</code></pre>\n<p>自底向上的归并排序会多次遍历整个数组，根据子数组大小进行两两归并。子数组的大小 <code>sz</code> 的初始值为 1，每次加倍。最后一个子数组的大小只有在数组大小是 <code>sz</code> 的偶数倍的时候才会等于 <code>sz</code>（否则它会比 <code>sz</code> 小）。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01146.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p><strong>自底向上的归并排序的归并结果</strong></p>\n</blockquote>\n<p>　</p>\n<blockquote>\n<p><strong>命题 H</strong>。对于长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的任意数组，自底向上的归并排序需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00959.gif\" alt=\"1/2N\\lg N\" inline-img=\"true\" /> 至 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00960.gif\" alt=\"N\\lg N\" inline-img=\"true\" /> 次比较，最多访问数组 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01142.gif\" alt=\"6N\\lg N\" inline-img=\"true\" /> 次。</p>\n<p><strong>证明</strong>。处理一个数组的遍数正好是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01147.gif\" alt=\"\\lceil\\lg N\\rceil\" inline-img=\"true\" /> 。每一遍会访问数组 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01143.gif\" alt=\"6N\" inline-img=\"true\" /> 次，比较次数在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00986.gif\" alt=\"N/2\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 之间。</p>\n</blockquote>\n<p><strong>当数组长度为 2 的幂时</strong>，自顶向下和自底向上的归并排序所用的比较次数和数组访问次数正好相同，只是顺序不同。其他时候，两种方法的比较和数组访问的次序会有所不同（请见练习 2.2.5）。</p>\n<p>自底向上的归并排序比较适合<strong>用链表</strong>组织的数据。想象一下将链表先按大小为 1 的子链表进行排序，然后是大小为 2 的子链表，然后是大小为 4 的子链表等。这种方法只需要重新组织链表链接就能将链表<strong>原地</strong>排序（不需要创建任何新的链表结点）。</p>\n<p>用自顶向下或是自底向上的方式实现任何分治类的算法都很自然。归并排序告诉我们，当能够用其中一种方法解决一个问题时，你都应该试试另一种。你是希望像 <code>Merge.sort()</code> 中那样化整为零（然后递归地解决它们）的方式解决问题，还是希望像 <code>MergeBU.sort()</code> 中那样循序渐进地解决问题呢？</p>\n<h3 id=\"nav_point_84\">2.2.4　排序算法的复杂度</h3>\n<p>学习归并排序的一个重要原因是它是证明计算复杂性领域的一个重要结论的基础，而计算复杂性能够帮助我们理解排序自身固有的难易程度。计算复杂性在算法设计中扮演着非常重要的角色，而这个结论正是和排序算法的设计直接相关的，因此接下来我们就要详细地讨论它。</p>\n<p>研究复杂度的第一步是建立一个计算模型。一般来说，研究者会尽量寻找一个和问题相关的最简单的模型。对排序来说，我们的研究对象是基于比较的算法，它们对数组元素的操作方式是由主键的比较决定的。一个基于比较的算法在两次比较之间可能会进行任意规模的计算，但它只能通过主键之间的比较得到关于某个主键的信息。因为我们局限于实现了 <code>Comparable</code> 接口的对象，本章中的所有算法都属于这一类（注意，我们忽略了访问数组的开销）。在第 5 章中，我们会讨论不局限于 <code>Comparable</code> 元素的算法。</p>\n<blockquote>\n<p><strong>命题 I</strong>。没有任何基于比较的算法能够保证使用少于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01148.gif\" alt=\"\\lg(N!)\\sim N\\lg N\" inline-img=\"true\" /> 次比较将长度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 的数组排序。</p>\n<p><strong>证明</strong>。首先，假设没有重复的主键，因为任何排序算法都必须能够处理这种情况。我们使用二叉树来表示所有的比较。树中的<strong>结点</strong>要么是一片<strong>叶子</strong><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01149.gif\" alt=\"\" width=\"18%\" style=\"width: 18%\" inline-img=\"true\" />，表示排序完成且原输入的排列顺序是 <code>a[i<sub>0</sub>], a[i<sub>1</sub>], ..., a[i<sub>N-1</sub>]</code>，要么是一个<strong>内部结点</strong><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01150.gif\" alt=\"\" width=\"4%\" style=\"width: 4%\" inline-img=\"true\" />，表示 <code>a[i]</code> 和 <code>a[j]</code> 之间的一次比较操作，它的左子树表示 <code>a[i]</code> 小于 <code>a[j]</code> 时进行的其他比较，右子树表示 <code>a[i]</code> 大于 <code>a[j]</code> 时进行的其他比较。从根结点到叶子结点每一条路径都对应着算法在建立叶子结点所示的顺序时进行的所有比较。例如，这是一棵 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01151.gif\" alt=\"N=3\" inline-img=\"true\" /> 时的比较树：</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01152.gif\" alt=\"\" width=\"65%\" style=\"width: 65%\" /></p>\n<p>我们从来没有明确地构造这棵树——它只是用来描述算法中的比较的一个数学工具。</p>\n<p>从比较树观察得到的第一个重要结论是这棵树应该至少有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00845.gif\" alt=\"N!\" inline-img=\"true\" /> 个叶子结点，因为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个不同的主键会有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00845.gif\" alt=\"N!\" inline-img=\"true\" /> 种不同的排列。如果叶子结点少于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00845.gif\" alt=\"N!\" inline-img=\"true\" />，那肯定有一些排列顺序被遗漏了。算法对于那些被遗漏的输入肯定会失败。</p>\n<p>从根结点到叶子结点的一条路径上的内部结点的数量即是某种输入下算法进行比较的次数。我们感兴趣的是这种路径能有多长（也就是树的<strong>高度</strong>），因为这也就是算法比较次数的最坏情况。二叉树的一个基本的组合学性质就是高度为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00826.gif\" alt=\"h\" inline-img=\"true\" /> 的树最多只可能有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01153.gif\" alt=\"2^h\" inline-img=\"true\" /> 个叶子结点，拥有 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01153.gif\" alt=\"2^h\" inline-img=\"true\" /> 个结点的树是完美平衡的，或称为<strong>完全树</strong>。下图所示的就是一个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01154.gif\" alt=\"h=4\" inline-img=\"true\" /> 的例子。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01155.gif\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p>结合前两段的分析可知，任意基于比较的排序算法都对应着一棵高 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00826.gif\" alt=\"h\" inline-img=\"true\" /> 的比较树（如下图所示），其中：</p>\n<p style=\"text-align: center\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01156.gif\" alt=\"N!\\leqslant\" inline-img=\"true\" /> 叶子结点的数量 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01157.gif\" alt=\"\\leqslant2^h\" inline-img=\"true\" /></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01158.jpeg\" alt=\"\" width=\"90%\" style=\"width: 90%\" /></p>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00826.gif\" alt=\"h\" inline-img=\"true\" /> 的值就是最坏情况下的比较次数，因此对不等式的两边取对数即可得到任意算法的比较次数至少是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01159.gif\" alt=\"\\lg N!\" inline-img=\"true\" />。根据斯特灵公式对阶乘函数的近似（见表 1.4.6）可得 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01160.gif\" alt=\"\\lg N!\\sim N\\lg N\" inline-img=\"true\" />。</p>\n</blockquote>\n<p>这个结论告诉了我们在设计排序算法的时候能够达到的最佳效果。例如，如果没有这个结论，我们可能会去尝试设计一个在最坏情况下比较次数只有归并排序的一半的基于比较的算法。命题 I 中的下限告诉我们这种努力是没有意义的——这样的算法不存在。这是一个重要结论，适用于任何我们能够想到的基于比较的算法。</p>\n<p>命题 H 表明归并排序在最坏情况下的比较次数为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01161.gif\" alt=\"\\sim N\\lg N\" inline-img=\"true\" />。这是其他排序算法复杂度的<strong>上限</strong>，也就是说更好的算法需要保证使用的比较次数更少。命题 I 说明没有任何排序算法能够用少于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01161.gif\" alt=\"\\sim N\\lg N\" inline-img=\"true\" /> 次比较将数组排序，这是其他排序算法复杂度的<strong>下限</strong>。也就是说，即使是最好的算法在最坏的情况下也至少需要这么多次比较。将两者结合起来也就意味着：</p>\n<blockquote>\n<p><strong>命题 J</strong>。归并排序是一种渐进最优的基于比较排序的算法。</p>\n<p><strong>证明</strong>。更准确地说，这句话的意思是，归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01161.gif\" alt=\"\\sim N\\lg N\" inline-img=\"true\" />。命题 H 和命题 I 证明了这些结论。</p>\n</blockquote>\n<p>需要强调的是，和计算模型一样，我们需要精确地定义最优算法。例如，我们可以<strong>严格地</strong>认为仅仅只需要 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01159.gif\" alt=\"\\lg N!\" inline-img=\"true\" /> 次比较的算法才是最优的排序算法。我们不这么做的原因是，即使对于很大的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />，这种算法和（比如说）归并排序之间的差异也并不明显。或者我们也可以放宽最优的定义，使之包含任意在最坏情况下的比较次数都在 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00960.gif\" alt=\"N\\lg N\" inline-img=\"true\" /> 的某个常数因子范围之内的排序算法。我们不这么做的原因是对于很大的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />，这种算法和归并排序之间的差距还是很明显的。</p>\n<p>计算复杂度的概念可能会让人觉得很抽象，但解决可计算问题内在困难的基础性研究则不管怎么说都是非常必要的。而且，在适用的情况下，关键在于计算复杂度会影响优秀软件的开发。首先，准确的上界为软件工程师保证性能提供了空间。很多例子表明，平方级别排序的性能低于线性排序。其次，准确的下界可以为我们节省很多时间，避免因不可能的性能改进而投入资源。</p>\n<p>但归并排序的最优性并不是结束，也不代表在实际应用中我们不会考虑其他的方法了，因为本节中的理论还是有许多局限性的，例如：</p>\n<ul>\n<li>归并排序的空间复杂度不是最优的；</li>\n<li>在实践中不一定会遇到最坏情况；</li>\n<li>除了比较，算法的其他操作（例如访问数组）也可能很重要；</li>\n<li><strong>不进行</strong>比较也能将某些数据排序。</li>\n</ul>\n<p>因此在本书中我们还将继续学习其他一些排序算法。</p>\n<h3 id=\"nav_point_85\">答疑</h3>\n<p><strong>问</strong>　归并排序比希尔排序快吗？</p>\n<p><strong>答</strong>　在实际应用中，它们的运行时间之间的差距在常数级别之内（希尔排序使用的是像算法 2.3 中那样的经过验证的递增序列），因此相对性能取决于具体的实现。</p>\n<pre class=\"code-rows\"><code>% java SortCompare Merge Shell 100000\nFor 100000 random Double values\n    Merge is 1.2 times faster than Shell</code></pre>\n<p>　理论上来说，还没有人能够证明希尔排序对于随机数据的运行时间是线性对数级别的，因此存在平均情况下希尔排序的性能的渐进增长率<span class=\"comment-number\">1</span>更高的可能性。在最坏情况下，这种差距的存在已经被证实了，但这对实际应用没有影响。</p>\n\n<p><strong>问</strong>　为什么不把数组 <code>aux[]</code> 声明为 <code>merge()</code> 方法的局部变量？</p>\n<p><strong>答</strong>　这是为了避免每次归并时，即使是归并很小的数组，都创建一个新的数组。如果这么做，那么创建新数组将成为归并排序运行时间的主要部分（请见练习 2.2.26）。更好的解决方案是将 <code>aux[]</code> 变为 <code>sort()</code> 方法的局部变量，并将它作为参数传递给 <code>merge()</code> 方法（为了简化代码我们没有在例子中这么做，请见练习 2.2.9）。</p>\n<p><strong>问</strong>　当数组中存在重复的元素时归并排序的表现如何？</p>\n<p><strong>答</strong>　如果所有的元素都相同，那么归并排序的运行时间将是线性的（需要一个额外的测试来避免归并已经有序的数组）。但如果有多个不同的重复值，这样做的性能收益就不是很明显了。例如，假设输入数组的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个奇数位上的元素都是同一个值，另外 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个偶数位上的元素都是另一个值，此时算法的运行时间是线性对数的（这样的数组和所有元素都不重复的数组满足了相同的循环条件），而非线性的。</p>\n<h3 id=\"nav_point_86\">练习</h3>\n<p><strong>2.2.1</strong>　按照本节开头所示轨迹的格式给出原地归并的抽象 <code>merge()</code> 方法是如何将数组 <code>A E Q S U Y E I N O S T</code> 排序的。</p>\n<p><strong>2.2.2</strong>　按照算法 2.4 所示轨迹的格式给出自顶向下的归并排序是如何将数组 <code>E A S Y Q U E S T I O N</code> 排序的。</p>\n<p><strong>2.2.3</strong>　用自底向上的归并排序解答练习 2.2.2。</p>\n<p><strong>2.2.4</strong>　是否当且仅当两个输入的子数组都有序时原地归并的抽象方法才能得到正确的结果？证明你的结论，或者给出一个反例。</p>\n<p><strong>2.2.5</strong>　当输入数组的大小 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01162.gif\" alt=\"N=39\" inline-img=\"true\" /> 时，给出自顶向下和自底向上的归并排序中各次归并子数组的大小及顺序。</p>\n<p><strong>2.2.6</strong>　编写一个程序来计算自顶向下和自底向上的归并排序访问数组的准确次数。使用这个程序将 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01163.gif\" alt=\"N=1\" inline-img=\"true\" /> 至 512 的结果绘成曲线图，并将其和上限 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01142.gif\" alt=\"6N\\lg N\" inline-img=\"true\" /> 比较。</p>\n<p><strong>2.2.7</strong>　证明归并排序的比较次数是单调递增的（即对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01132.gif\" alt=\"N&gt;0\" inline-img=\"true\" />，<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01164.gif\" alt=\"C(N+1)&gt;C(N)\" inline-img=\"true\" />）。</p>\n<p><strong>2.2.8</strong>　假设将算法 2.4 修改为：只要 <code>a[mid] &lt;= a[mid+1]</code> 就不调用 <code>merge()</code> 方法，请证明用归并排序处理一个已经有序的数组所需的比较次数是线性级别的。</p>\n<p><strong>2.2.9</strong>　在库函数中使用 <code>aux[]</code> 这样的静态数组是不妥当的，因为可能会有多个程序同时使用这个类。实现一个不用静态数组的 <code>Merge</code> 类，但也<strong>不要</strong>将 <code>aux[]</code> 变为 <code>merge()</code> 的局部变量（请见本节的答疑部分）。<strong>提示</strong>：可以将辅助数组作为参数传递给递归的 <code>sort()</code> 方法。</p>\n<h3 id=\"nav_point_87\">提高题</h3>\n<p><strong>2.2.10</strong>　<strong>快速归并</strong>。实现一个 <code>merge()</code> 方法，按<strong>降序</strong>将 <code>a[]</code> 的后半部分复制到 <code>aux[]</code>，然后将其归并回 <code>a[]</code> 中。这样就可以去掉内循环中检测某半边是否用尽的代码。<strong>注意</strong>：这样的排序产生的结果是不稳定的（请见 2.5.1.8 节）。</p>\n<p><strong>2.2.11</strong>　<strong>改进</strong>。实现 2.2.2 节所述的对归并排序的三项改进：加快小数组的排序速度，检测数组是否已经有序以及通过在递归中交换参数来避免数组复制。</p>\n<p><strong>2.2.12</strong>　<strong>次线性的额外空间</strong>。用大小 M 将数组分为 N/M 块（简单起见，设 M 是 N 的约数）。实现一个归并方法，使之所需的额外空间减少到 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01165.gif\" alt=\"\\max(M,N/M)\" inline-img=\"true\" />：(i) 可以先将一个块看做一个元素，将块的第一个元素作为块的主键，用选择排序将块排序；(ii) 遍历数组，将第一块和第二块归并，完成后将第二块和第三块归并，等等。</p>\n<p><strong>2.2.13</strong>　<strong>平均情况的下限</strong>。请证明任意基于比较的排序算法的预期比较次数至少为 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01161.gif\" alt=\"\\sim N\\lg N\" inline-img=\"true\" />（假设输入元素的所有排列的出现概率是均等的）。<strong>提示</strong>：比较次数至少是比较树的外部路径的长度（根结点到所有叶子结点的路径长度之和），当树平衡时该值最小。</p>\n<p><strong>2.2.14</strong>　<strong>归并有序的队列</strong>。编写一个静态方法，将两个有序的队列作为参数，返回一个归并后的有序队列。</p>\n<p><strong>2.2.15</strong>　<strong>自底向上的有序队列归并排序</strong>。用下面的方法编写一个自底向上的归并排序：给定 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个元素，创建 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个队列，每个队列包含其中一个元素。创建一个由这 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个队列组成的队列，然后不断用练习 2.2.14 中的方法将队列的头两个元素归并，并将结果重新加入到队列结尾，直到队列的队列只剩下一个元素为止。</p>\n<p><strong>2.2.16</strong>　<strong>自然的归并排序</strong>。编写一个自底向上的归并排序，当需要将两个子数组排序时能够利用数组中已经有序的部分。首先找到一个有序的子数组（移动指针直到当前元素比上一个元素小为止），然后再找出另一个并将它们归并。根据数组大小和数组中递增子数组的最大长度分析算法的运行时间。</p>\n<p><strong>2.2.17</strong>　<strong>链表排序</strong>。实现对链表的自然排序（这是将链表排序的最佳方法，因为它不需要额外的空间，且运行时间是线性对数级别的）。</p>\n<p><strong>2.2.18</strong>　<strong>打乱链表</strong>。实现一个分治算法，使用线性对数级别的时间和对数级别的额外空间随机打乱一条链表。</p>\n<p><strong>2.2.19</strong>　<strong>倒置</strong>。编写一个线性对数级别的算法统计给定数组中的“倒置”数量（即插入排序所需的交换次数，请见 2.1 节）。这个数量和 <em>Kendal1 tau</em> 距离有关，请见 2.5 节。</p>\n<p><strong>2.2.20</strong>　<strong>间接排序</strong>。编写一个不改变数组的归并排序，它返回一个 <code>int[]</code> 数组 <code>perm</code>，其中 <code>perm[i]</code> 的值是原数组中第 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01071.gif\" alt=\"i\" inline-img=\"true\" /> 小的元素的位置。</p>\n<p><strong>2.2.21</strong>　<strong>一式三份</strong>。给定三个列表，每个列表中包含 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" /> 个名字，编写一个线性对数级别的算法来判定三份列表中是否含有公共的名字，如果有，返回第一个被找到的这种名字。</p>\n<p><strong>2.2.22</strong>　<strong>三向归并排序</strong>。假设每次我们是把数组分成三个部分而不是两个部分并将它们分别排序，然后进行三向归并。这种算法的运行时间的增长数量级是多少？</p>\n<h3 id=\"nav_point_88\">实验题</h3>\n<p><strong>2.2.23</strong>　<strong>改进</strong>。用实验评估正文中所提到的归并排序的三项改进（请见练习 2.2.11）的效果，并比较正文中实现的归并和练习 2.2.10 所实现的归并之间的性能。根据经验给出应该在何时为子数组切换到插入排序。</p>\n<p><strong>2.2.24</strong>　<strong>改进的有序测试</strong>。在实验中用大型随机数组评估练习 2.2.8 所做的修改的效果。根据经验用 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />（被排序的原始数组的大小）的函数描述条件语句（<code>a[mid] &lt; =a[mid+1]</code>）成立（无论数组是否有序）的平均次数。</p>\n<p><strong>2.2.25</strong>　<strong>多向归并排序</strong>。实现一个 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 向（相对双向而言）归并排序程序。分析你的算法，估计最佳的 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00842.gif\" alt=\"k\" inline-img=\"true\" /> 值并通过实验验证猜想。</p>\n<p><strong>2.2.26</strong>　<strong>创建数组</strong>。使用 <code>SortCompare</code> 粗略比较在你的计算机上在 <code>merge()</code> 中和在 <code>sort()</code> 中创建 <code>aux[]</code> 的性能差异。</p>\n<p><strong>2.2.27</strong>　<strong>子数组长度</strong>。用归并将大型随机数组排序，根据经验用 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00798.gif\" alt=\"N\" inline-img=\"true\" />（某次归并时两个子数组的长度之和）的函数估计当一个子数组用尽时另一个子数组的平均长度。</p>\n<p><strong>2.2.28</strong>　<strong>自顶向下与自底向上</strong>。对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00846.gif\" alt=\"N=10^3\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00847.gif\" alt=\"10^4\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00848.gif\" alt=\"10^5\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" />，使用 <code>SortCompare</code> 比较自顶向下和自底向上的归并排序的性能。</p>\n<p><strong>2.2.29</strong>　<strong>自然的归并排序</strong>。对于 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00846.gif\" alt=\"N=10^3\" inline-img=\"true\" />、<img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image00849.gif\" alt=\"10^6\" inline-img=\"true\" /> 和 <img img src=\"https://static001.geekbang.org/files/resource/ebook/100010/image01092.gif\" alt=\"10^9\" inline-img=\"true\" />，类型为 <code>Long</code> 的随机主键数组，根据经验给出自然的归并排序（请见练习 2.2.16）所需要的遍数。<strong>提示</strong>：不需要实现这个排序（甚至不需要生成所有完整的 64 位主键）也能完成这道练习。</p>\n","neighbors":{"left":{"article_title":"2.1 初级排序算法","id":740936},"right":{"article_title":"2.3 快速排序","id":740938}},"comments":[]}