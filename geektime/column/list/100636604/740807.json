{"id":740807,"title":"第 8 章 crate 与模块(1)","content":"<blockquote>\n<p>这是 Rust 主题下的小小理念之一：系统程序员也能享受美好。</p>\n<p style=\"text-align: right\">——Robert O'Callahan，“Random Thoughts on Rust: crates.io and IDEs”</p>\n</blockquote>\n<p>&nbsp;</p>\n<p>假设你正在编写一个程序，用来模拟蕨类植物从单个细胞开始的生长过程。你的程序，也像蕨类植物一样，一开始会非常简单，所有的代码也许都在一个文件中——这只是想法的萌芽。随着成长，它将开始分化出内部结构，不同的部分会有不同的用途。然后它将分化成多个文件，可能遍布在各个目录中。随着时间的推移，它可能会成为整个软件生态系统的重要组成部分。对于任何超出几个数据结构或几百行代码的程序，进行适当的组织都是很有必要的。</p>\n<p>本章介绍了 Rust 的一些特性（crate 与模块），这些特性有助于你的程序保持井井有条。我们还将涵盖其他与 Rust crate 的结构和分发有关的主题，包括如何记录与测试 Rust 代码、如何消除不必要的编译器警告、如何使用 Cargo 管理项目依赖项和版本控制、如何在 Rust 的公共 crate 存储库 crates.io 上发布开源库、Rust 如何通过语言版本进行演进等。本章将使用蕨类模拟器作为运行示例。</p><!-- [[[read_end]]] -->\n<h2 id=\"nav_point_128\">8.1　crate</h2>\n<p>Rust 程序由 crate（板条箱）组成。每个 crate 都是既完整又内聚的单元，包括单个库或可执行程序的所有源代码，以及任何相关的测试、示例、工具、配置和其他杂项。对于蕨类植物模拟器，我们可以使用第三方库完成 3D 图形、生物信息学、并行计算等工作。这些库以 crate 的形式分发，如图 8-1 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00845.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8-1：一个 crate 及其依赖</strong></p>\n<p>弄清楚 crate 是什么以及它们如何协同工作的最简单途径是，使用带有 <code>--verbose</code> 标志的 <code>cargo build</code> 来构建具有某些依赖项的现有项目。我们以 2.6.6 节的“并发曼德博程序”为例来执行此操作。结果如下所示：</p>\n<pre class=\"code-rows\"><code>$ cd mandelbrot\n$ cargo clean    # 删除之前编译的代码\n$ cargo build --verbose\n    Updating registry `https://github.com/rust-lang/crates.io-index`\n Downloading autocfg v1.0.0\n Downloading semver-parser v0.7.0\n Downloading gif v0.9.0\n Downloading png v0.7.0\n\n... (downloading and compiling many more crates)\n\nCompiling jpeg-decoder v0.1.18\n     Running `rustc\n        --crate-name jpeg_decoder\n        --crate-type lib\n        ...\n        --extern byteorder=.../libbyteorder-29efdd0b59c6f920.rmeta\n        ...\n   Compiling image v0.13.0\n     Running `rustc\n        --crate-name image\n        --crate-type lib\n        ...\n        --extern byteorder=.../libbyteorder-29efdd0b59c6f920.rmeta\n        --extern gif=.../libgif-a7006d35f1b58927.rmeta\n        --extern jpeg_decoder=.../libjpeg_decoder-5c10558d0d57d300.rmeta\n   Compiling mandelbrot v0.1.0 (/tmp/rustbook-test-files/mandelbrot)\n     Running `rustc\n        --edition=2021\n        --crate-name mandelbrot\n        --crate-type bin\n        ...\n        --extern crossbeam=.../libcrossbeam-f87b4b3d3284acc2.rlib\n        --extern image=.../libimage-b5737c12bd641c43.rlib\n        --extern num=.../libnum-1974e9a1dc582ba7.rlib -C link-arg=-fuse-ld=lld`\n    Finished dev [unoptimized + debuginfo] target(s) in 16.94s\n$</code></pre>\n<p>这里重新格式化了 <code>rustc</code> 命令行以提高可读性，我们删除了很多与本次讨论无关的编译器选项，然后将它们替换成了省略号（<code>...</code>）。</p>\n<p>你可能还记得，当“并发曼德博程序”的例子完成时，曼德博程序的 main.rs 包含几个来自其他 crate 的语法项的 <code>use</code> 声明：</p>\n<pre class=\"code-rows\"><code>use num::Complex;\n// ...\nuse image::ColorType;\nuse image::png::PNGEncoder;</code></pre>\n<p>并且 Cargo.toml 文件中指定了我们想要的每个 crate 的版本：</p>\n<pre class=\"code-rows\"><code>[dependencies]\nnum = \"0.4\"\nimage = \"0.13\"\ncrossbeam = \"0.8\"</code></pre>\n<p>单词 dependencies 在这里是指这个项目使用的其他 crate，也就是我们所依赖的代码。我们在 crates.io（Rust 社区的开源 crate 站点）上找到了这些 crate。例如，通过访问 crates.io 我们搜索并找到了 <code>image</code> 库。crates.io 上的每个 crate 页面都显示了其 README.md 文件及文档和源代码的链接，以及像 <code>image = \"0.13\"</code> 这样的可以复制并添加到 Cargo.toml 中的配置行。这里展示的版本号只是我们编写本程序时这 3 个包的最新版本。</p>\n<p>Cargo 清单讲述了如何使用这些信息。运行 <code>cargo build</code> 时，Cargo 首先会从 crates.io 下载这些 crate 的指定版本的源代码。然后，它会读取这些 crate 的 Cargo.toml 文件、下载<strong>它们</strong>的依赖项，并递归地进行。例如，<code>0.13.0</code> 版的 <code>image</code> crate 的源代码包含一个 Cargo.toml 文件，其中列出了如下内容：</p>\n<pre class=\"code-rows\"><code>[dependencies]\nbyteorder = \"1.0.0\"\nnum-iter = \"0.1.32\"\nnum-rational = \"0.1.32\"\nnum-traits = \"0.1.32\"\nenum_primitive = \"0.1.0\"</code></pre>\n<p>看到这个文件，Cargo 就知道在它使用 <code>image</code> 之前，必须先获取这些 crate。稍后你将看到如何要求 Cargo 从 Git 存储库或本地文件系统而非 crates.io 获取源代码。</p>\n<p>由于 <code>mandelbrot</code> 通过使用 <code>image</code> crate 间接依赖于这些 crate，因此我们称它们为 <code>mandelbrot</code> 的<strong>传递</strong>依赖。所有这些依赖关系的集合，会告诉 Cargo 关于要构建什么 crate 以及应该按什么顺序构建的全部知识，这叫作该 crate 的<strong>依赖图</strong>。Cargo 对依赖图和传递依赖的自动处理可以显著节省程序员的时间和精力。</p>\n<p>一旦有了源代码，Cargo 就会编译所有的 crate。它会为项目依赖图中的每个 crate 都运行一次 <code>rustc</code>（Rust 编译器）。编译库时，Cargo 会使用 <code>--crate-type lib</code> 选项。这会告诉 <code>rustc</code> 不要寻找 <code>main()</code> 函数，而是生成一个 .rlib 文件，其中包含一些已编译代码，可用于创建二进制文件和其他 .rlib 文件。</p>\n<p>编译程序时，Cargo 会使用 <code>--crate-type bin</code>，结果是目标平台的二进制可执行文件，比如 Windows 上的 mandelbrot.exe。</p>\n<p>对于每个 <code>rustc</code> 命令，Cargo 都会传入 <code>--extern</code> 选项，给出 crate 将使用的每个库的文件名。这样，当 <code>rustc</code> 看到一行代码（如 <code>use image::png::PNGEncoder</code>）时，就可以确定 <code>image</code> 是另一个 crate 的名称。感谢 Cargo，它知道在哪里可以找到磁盘上已编译的 crate。Rust 编译器需要访问这些 .rlib 文件，因为它们包含库的已编译代码。Rust 会将代码静态链接到最终的可执行文件中。.rlib 也包含一些类型信息，这样 Rust 就可以检查我们在代码中使用的库特性是否确实存在于 crate 中，以及我们是否正确使用了它们。.rlib 文件中还包含此 crate 的公共内联函数、泛型和宏这三者的副本，在 Rust 知道我们将如何使用它们之前，这些特性无法完全编译为机器码。</p>\n<p><code>cargo build</code> 支持各种选项，其中大部分超出了本书的范畴，我们在这里只提一个：<code>cargo build --release</code> 会生成优化过的程序。这种程序运行得更快，但它们的编译时间更长、运行期不会检查整数溢出、会跳过 <code>debug_assert!()</code> 断言，并且在 panic 时生成的调用栈跟踪通常不太可靠。</p>\n<h3 id=\"nav_point_129\">8.1.1　版本</h3>\n<p>Rust 具有极强的兼容性保证。任何能在 Rust 1.0 上编译的代码在 Rust 1.50 或 Rust 1.900（如果已经发布的话）上都必然编译得一样好。</p>\n<p>但有时会有一些必要的扩展提议加入语言中，这有可能导致旧代码无法再编译。例如，经过多次讨论，Rust 确定了一种支持异步编程的语法，该语法将标识符 <code>async</code> 和 <code>await</code> 重新用作关键字（参见第 20 章）。但是这种语言更改会破坏任何使用 <code>async</code> 或 <code>await</code> 作为变量名的现有代码。</p>\n<p>为了在不破坏现有代码的情况下继续演进，Rust 会使用<strong>版本</strong>。2015 版 Rust 会与 Rust 1.0 兼容。2018 版 Rust 将 <code>async</code> 和 <code>await</code> 改为关键字并精简了模块系统，而 2021 版 Rust 则提升了数组对人类的友好性，并默认让一些广泛使用的库定义随处可用。虽然这些都是对该语言的重要改进，但会破坏现有代码。为避免这种情况，每个 crate 都在其 Cargo.toml 文件顶部的 <code>[package]</code> 部分使用下面这样的行来表明自己是用哪个版本的 Rust 编写的：</p>\n<pre class=\"code-rows\"><code>edition = \"2021\"</code></pre>\n<p>如果该关键字不存在，则假定为 2015 版，因此旧 crate 根本不必更改。但是如果你想使用异步函数或新的模块系统，就要在 Cargo.toml 文件中添加一句“<code>edition = \"2018\"</code> 或更高版本”。</p>\n<p>Rust 承诺编译器将始终接受该语言的所有现存版本，并且程序可以自由混用以不同版本编写的 crate。2015 版的 crate 甚至可以依赖 2021 版的 crate。换句话说，crate 的版本只影响其源代码的解释方式，编译代码时，版本的差异已然消失。这意味着你无须为了继续参与到现代 Rust 生态系统中而更新旧的 crate。同样，你也不必为了避免给用户带来不便而被迫使用旧的 crate。当你想在自己的代码中使用新的语言特性时，只要更改版本就可以了。</p>\n<p>Rust 项目组不会每年都发布新版本，只有认为确有必要时才会发布。例如，没有 2020 版 Rust。将 <code>edition</code> 设置为 <code>\"2020\"</code> 会导致错误。Rust 版本指南涵盖了每个版本中引入的更改，并提供了有关版本体系的完善的背景知识。</p>\n<p>使用最新版本几乎总是更好的做法，尤其是对于新代码。<code>cargo new</code> 默认会在最新版本上创建新项目。本书全程使用 2021 版。</p>\n<p>如果你有一个用旧版本的 Rust 编写的 crate，则 <code>cargo fix</code> 命令能帮助你自动将代码升级到新版本。Rust 版本指南详细解释了 <code>cargo fix</code> 命令。</p>\n<h3 id=\"nav_point_130\">8.1.2　创建配置文件</h3>\n<p>你可以在 Cargo.toml 文件中放置几个配置设定区段，这些设定会影响 <code>cargo</code> 生成的 <code>rustc</code> 命令行，如表 8-1 所示。</p>\n<p><strong>表 8-1：Cargo.toml 的配置设定区段</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>命令行</p></th>\n<th><p>使用的 Cargo.toml 区段</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>cargo build</code></p></td>\n<td><p><code>[profile.dev]</code></p></td>\n</tr>\n<tr>\n<td><p><code>cargo build --release</code></p></td>\n<td><p><code>[profile.release]</code></p></td>\n</tr>\n<tr>\n<td><p><code>cargo test</code></p></td>\n<td><p><code>[profile.test]</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>通常情况下，默认设置是可以使用的，但当你想要使用剖析器（一种用来测量程序在哪些地方消耗了 CPU 时间的工具）时会出现例外情况。要从剖析器中获得最佳数据，需要同时启用优化（通常仅在发布构建中启用）和调试符号（通常仅在调试构建中启用）这两个选项。要同时启用它们，请将如下代码添加到你的 Cargo.toml 中：</p>\n<pre class=\"code-rows\"><code>[profile.release]\ndebug = true  # 在release构建中启用debug符号</code></pre>\n<p><code>debug</code> 设定会控制 <code>rustc</code> 的 <code>-g</code> 选项。通过这个配置，当你键入 <code>cargo build --release</code> 时，将获得带有调试符号的二进制文件。而优化设置未受影响。</p>\n<p>Cargo 文档中列出了可以在 Cargo.toml 中调整的许多其他设定。</p>\n<h2 id=\"nav_point_131\">8.2　模块</h2>\n<p>crate 是关于项目间代码共享的，而<strong>模块</strong>是关于项目内代码组织的。它们扮演着 Rust 命名空间的角色，是构成 Rust 程序或库的函数、类型、常量等的容器。一个模块看起来是这样的：</p>\n<pre class=\"code-rows\"><code>mod spores {\n    use cells::;\n\n    /// 由成年蕨类植物产生的细胞。作为蕨类植物生命周期的一部分，细胞会随风\n    /// 传播。一个孢子会长成原叶体（一个完整的独立有机体，最大直径达5毫米），\n    /// 原叶体产生的受精卵会长成新的蕨类植物（植物的性别很复杂）\n    pub struct Spore {\n        ...\n    }\n\n    /// 模拟减数分裂产生孢子\n    pub fn produce_spore(factory: &amp;mut Sporangium) -&gt; Spore {\n        ...\n    }\n\n    /// 提取特定孢子中的基因\n    pub(crate) fn genes(spore: &amp;Spore) -&gt; Vec&lt;Gene&gt; {\n        ...\n    }\n\n    /// 混合基因以准备减数分裂（细胞分裂间期的一部分）\n    fn recombine(parent: &amp;mut Cell) {\n        ...\n    }\n\n    ...\n}</code></pre>\n<p>模块是一组<strong>语法项</strong>的集合，这些语法项具有命名的特性，比如此示例中的 <code>Spore</code> 结构体和 3 个函数。<code>pub</code> 关键字会使某个语法项声明为公共项，这样它就可以从模块外部访问了。</p>\n<p>如果把一个函数标记为 <code>pub(crate)</code>，那么就意味着它可以在这个 crate 中的任何地方使用，但不会作为外部接口的一部分公开。它不能被其他 crate 使用，也不会出现在这个 crate 的文档中。</p>\n<p>任何未标记为 <code>pub</code> 的内容都是私有的，只能在定义它的模块及其任意子模块中使用：</p>\n<pre class=\"code-rows\"><code>let s = spores::produce_spore(&amp;mut factory);  // 正确\n\nspores::recombine(&amp;mut cell);  // 错误：`recombine`是私有的</code></pre>\n<p>将某个语法项标记为 <code>pub</code> 通常称为“导出”该语法项。</p>\n<p>本节的其余部分涵盖了要想充分利用模块所需了解的详细信息。</p>\n<ul>\n<li>我们会展示如何嵌套模块并在需要时将它们分散到不同的文件和目录中。</li>\n<li>我们会解释 Rust 使用的路径语法，以引用来自其他模块的语法项，并展示如何导入这些语法项，以便你使用它们而不必写出其完整路径。</li>\n<li>我们会触及 Rust 对结构体字段的细粒度控制。</li>\n<li>我们会介绍<strong>预导入</strong>（prelude，原意为“序曲”）模块，它们通过收集几乎所有用户都需要的常用导入，减少了样板代码的编写。</li>\n<li>为了提高代码的清晰性和一致性，我们还会介绍<strong>常量</strong>和<strong>静态变量</strong>这两种定义命名值的方法。</li>\n</ul>\n<h3 id=\"nav_point_132\">8.2.1　嵌套模块</h3>\n<p>模块可以嵌套，通常可以看到某个模块仅仅是一组子模块集合：</p>\n<pre class=\"code-rows\"><code>mod plant_structures {\n    pub mod roots {\n        ...\n    }\n    pub mod stems {\n        ...\n    }\n    pub mod leaves {\n        ...\n    }\n}</code></pre>\n<p>如果你希望嵌套模块中的语法项对其他 crate 可见，请务必将<strong>它和它所在的模块</strong>标记为公开的。否则可能会看到这样的警告：</p>\n<pre class=\"code-rows\"><code>warning: function is never used: `is_square`\n   |\n23 | /         pub fn is_square(root: &amp;Root) -&gt; bool {\n24 | |             root.cross_section_shape().is_square()\n25 | |         }\n   | |_________^\n   |</code></pre>\n<p>也许这个函数目前确实是无用的代码。但是，如果你打算在其他 crate 中使用它，那么 Rust 就会提示你这个函数对它们实际上是不可见的。你应该确保它所在的模块也是 <code>pub</code> 形式。</p>\n<p>也可以指定 <code>pub(super)</code>，让语法项只对其父模块可见。还可以指定 <code>pub(in &lt;path&gt;)</code>，让语法项在特定的父模块及其后代中可见。这对于深度嵌套的模块特别有用：</p>\n<pre class=\"code-rows\"><code>mod plant_structures {\n    pub mod roots {\n        pub mod products {\n            pub(in crate::plant_structures::roots) struct Cytokinin {\n                ...\n            }\n        }\n\n        use products::Cytokinin; // 正确：在`roots`模块中可见\n    }\n\n    use roots::products::Cytokinin; // 错误：`Cytokinin`是私有的\n}\n\n// 错误：`Cytokinin`是私有的\nuse plant_structures::roots::products::Cytokinin;</code></pre>\n<p>通过这种方式，我们可以写出一个完整的程序，把大量代码和完整的模块层次结构以我们想要的任何方式关联起来，并放在同一个源文件中。</p>\n<p>但实际上，以这种方式写代码相当痛苦，因此还有另一种选择。</p>\n<h3 id=\"nav_point_133\">8.2.2　单独文件中的模块</h3>\n<p>模块还可以这样写：</p>\n<pre class=\"code-rows\"><code>mod spores;</code></pre>\n<p>前面我们一直把 <code>spores</code> 模块的主体代码包裹在花括号中。在这里，我们告诉 Rust 编译器，<code>spores</code> 模块保存在一个单独的名为 spores.rs 的文件中：</p>\n<pre class=\"code-rows\"><code>// spores.rs\n\n/// 由成年蕨类植物产生的细胞……\npub struct Spore {\n    ...\n}\n\n/// 模拟减数分裂产生孢子\npub fn produce_spore(factory: &amp;mut Sporangium) -&gt; Spore {\n    ...\n}\n\n/// 提取特定孢子中的基因\npub(crate) fn genes(spore: &amp;Spore) -&gt; Vec&lt;Gene&gt; {\n    ...\n}\n\n/// 混合基因以准备减数分裂（细胞分裂间期的一部分）\nfn recombine(parent: &amp;mut Cell) {\n    ...\n}</code></pre>\n<p>spores.rs 仅包含构成该模块的那些语法项，它不需要任何样板代码来声明自己是一个模块。</p>\n<p>代码的位置是这个 <code>spores</code> 模块与 8.2.1 节中展示的版本之间的<strong>唯一</strong>区别。Rust 遵循同样的规则，以决定什么是公共的以及什么是私有的。而且即便模块在单独的文件中，Rust 也永远不会分别编译它们，因为只要你构建 Rust crate，就会重新编译它的所有模块。</p>\n<p>模块可以有自己的目录。当 Rust 看到 <code>mod spore;</code> 时，会同时检查 spores.rs 和 spores/mod.rs，如果两个文件都不存在，或者都存在，就会报错。对于这个例子，我们使用了 spores.rs，因为 <code>spores</code> 模块没有任何子模块。但是考虑一下我们之前编写的 <code>plant_structures</code> 模块。如果将该模块及其 3 个子模块拆分到它们自己的文件中，则会生成如下项目：</p>\n<pre class=\"code-rows\"><code>fern_sim/\n├── Cargo.toml\n└── src/\n    ├── main.rs\n    ├── spores.rs\n    └── plant_structures/\n        ├── mod.rs\n        ├── leaves.rs\n        ├── roots.rs\n        └── stems.rs</code></pre>\n<p>在 main.rs 中，我们声明了 <code>plant_structures</code> 模块：</p>\n<pre class=\"code-rows\"><code>pub mod plant_structures;</code></pre>\n<p>这会导致 Rust 加载 plant_structures/mod.rs，该文件声明了 3 个子模块：</p>\n<pre class=\"code-rows\"><code>// 在plant_structures/mod.rs中\npub mod roots;\npub mod stems;\npub mod leaves;</code></pre>\n<p>这 3 个模块的内容存储在 leaves.rs、roots.rs 和 stems.rs 这 3 个单独的文件中，与 mod.rs 一样位于 plant_structures 目录下。</p>\n<p>也可以使用同名的文件和目录来组成模块。如果 <code>stems</code>（茎）需要包含称为 <code>xylem</code>（木质部）和 <code>phloem</code>（韧皮部）的模块，那么可以选择将 <code>stems</code> 保留在 plant_structures/stems.rs 中并添加一个 stems 目录：</p>\n<pre class=\"code-rows\"><code>fern_sim/\n├── Cargo.toml\n└── src/\n    ├── main.rs\n    ├── spores.rs\n    └── plant_structures/\n        ├── mod.rs\n        ├── leaves.rs\n        ├── roots.rs\n        ├── stems/\n        │   ├── phloem.rs\n        │   └── xylem.rs\n        └── stems.rs</code></pre>\n<p>然后，在 stems.rs 中，我们声明了两个新的子模块：</p>\n<pre class=\"code-rows\"><code>// 在plant_structures/stems.rs中\npub mod xylem;\npub mod phloem;</code></pre>\n<p>这 3 种选项（模块位于自己的文件中、模块位于自己的带有 mod.rs 的目录中，以及模块在自己的文件中，并带有包含子模块的补充目录）为模块系统提供了足够的灵活性，以支持你可能用到的几乎任何项目结构。</p>\n<h3 id=\"nav_point_134\">8.2.3　路径与导入</h3>\n<p><code>::</code> 运算符用于访问模块中的各项特性。项目中任何位置的代码都可以通过写出其路径来引用标准库特性：</p>\n<pre class=\"code-rows\"><code>if s1 &gt; s2 {\n    std::mem::swap(&amp;mut s1, &amp;mut s2);\n}</code></pre>\n<p><code>std</code> 是标准库的名称。路径 <code>std</code> 指的是标准库的顶层模块。<code>std::mem</code> 是标准库中的子模块，而 <code>std::mem::swap</code> 是该模块中的公共函数。</p>\n<p>可以用这种方式编写所有代码：如果你想要一个圆或字典，就明确写出 <code>std::f64::consts::PI</code> 或 <code>std::collections::HashMap::new</code>。但这样做会很烦琐并且难以阅读。另一种方法是将这些特性<strong>导入</strong>使用它们的模块中：</p>\n<pre class=\"code-rows\"><code>use std::mem;\n\nif s1 &gt; s2 {\n    mem::swap(&amp;mut s1, &amp;mut s2);\n}</code></pre>\n<p>这条 <code>use</code> 声明导致名称 <code>mem</code> 在整个封闭块或模块中成了 <code>std::mem</code> 的本地别名。</p>\n<p>可以通过写 <code>use std::mem::swap;</code> 来导入 <code>swap</code> 函数本身，而不是 <code>mem</code> 模块。然而，我们之前的编写风格通常被认为是最好的：导入类型、特型和模块（如 <code>std::mem</code>），然后使用相对路径访问其中的函数、常量和其他成员。</p>\n<p>可以一次导入多个名称：</p>\n<pre class=\"code-rows\"><code>use std::collections::;  // 同时导入两个模块\n\nuse std::fs::; // 同时导入`std::fs`和`std::fs::File`\n\nuse std::io::prelude::*;  // 导入所有语法项</code></pre>\n<p>上述代码只是对“明确写出所有单独导入”的简写：</p>\n<pre class=\"code-rows\"><code>use std::collections::HashMap;\nuse std::collections::HashSet;\n\nuse std::fs;\nuse std::fs::File;\n\n// std::io::prelude中的全部公开语法项:\nuse std::io::prelude::Read;\nuse std::io::prelude::Write;\nuse std::io::prelude::BufRead;\nuse std::io::prelude::Seek;</code></pre>\n<p>可以使用 <code>as</code> 导入一个语法项，但在本地赋予它一个不同的名称：</p>\n<pre class=\"code-rows\"><code>use std::io::Result as IOResult;\n\n// 这个返回类型只是`std::io::Result&lt;()&gt;`的另一种写法：\nfn save_spore(spore: &amp;Spore) -&gt; IOResult&lt;()&gt;\n...</code></pre>\n<p>模块<strong>不会</strong>自动从其父模块继承名称。假设 proteins/mod.rs 中有如下代码：</p>\n<pre class=\"code-rows\"><code>// proteins/mod.rs\npub enum AminoAcid { ... }\npub mod synthesis;</code></pre>\n<p>那么 synthesis.rs 中的代码不会自动“看到”类型 <code>`AminoAcid`</code>：</p>\n<pre class=\"code-rows\"><code>// proteins/synthesis.rs\npub fn synthesize(seq: &amp;[AminoAcid])  // 错误：找不到类型AminoAcid\n    ...</code></pre>\n<p>其实，每个模块都会以“白板”开头，并且必须导入它使用的名称：</p>\n<pre class=\"code-rows\"><code>// proteins/synthesis.rs\nuse super::AminoAcid;  // 从父模块显式导入\n\npub fn synthesize(seq: &amp;[AminoAcid])  // 正确\n    ...</code></pre>\n<p>默认情况下，路径是相对于当前模块的：</p>\n<pre class=\"code-rows\"><code>// in proteins/mod.rs\n\n// 从某个子模块导入\nuse synthesis::synthesize;</code></pre>\n<p><code>self</code> 也是当前模块的同义词，所以可以这样写：</p>\n<pre class=\"code-rows\"><code>// in proteins/mod.rs\n\n// 从枚举中导入名称，因此可以把赖氨酸写成`Lys`，而不是`AminoAcid::Lys`\nuse self::AminoAcid::*;</code></pre>\n<p>或者简单地写成如下形式。</p>\n<pre class=\"code-rows\"><code>// 在proteins/mod.rs中\n\nuse AminoAcid::*;</code></pre>\n<p>（当然，这里的 <code>AminoAcid</code> 示例偏离了之前提到过的仅导入类型、特型和模块的样式规则。如果我们的程序中包含长氨基酸序列，那么这种调整就符合奥威尔第六规则：“为了表达准确，宁可打破上述规则”。）</p>\n<p>关键字 <code>super</code> 和 <code>crate</code> 在路径中有着特殊的含义：<code>super</code> 指的是父模块，<code>crate</code> 指的是当前模块所在的 crate。</p>\n<p>使用相对于 crate 根而不是当前模块的路径可以更容易地在项目中移动代码，因为如果当前模块的路径发生了变化，则不会破坏任何导入。例如，我们可以使用 <code>crate</code> 编写 synthesis.rs：</p>\n<pre class=\"code-rows\"><code>// proteins/synthesis.rs\nuse crate::proteins::AminoAcid;  // 显式导入相对于crate根路径的语法项\n\npub fn synthesize(seq: &amp;[AminoAcid])  // 正确\n    ...</code></pre>\n<p>子模块可以使用 <code>use super::*</code> 访问其父模块中的私有语法项。</p>\n<p>如果有一个与你正使用的 crate 同名的模块，那么引用它们的内容时有一些注意事项。如果你的程序在其 Cargo.toml 文件中将 <code>image</code> crate 列为依赖项，但还有另一个名为 <code>image</code> 的模块，那么以 <code>image</code> 开头的路径就是有歧义的：</p>\n<pre class=\"code-rows\"><code>mod image {\n    pub struct Sampler {\n        ...\n    }\n}\n\n// 错误：它引用的是我们的`image`模块还是`image crate`？\nuse image::Pixels;</code></pre>\n<p>即使 <code>image</code> 模块中没有 <code>Pixels</code> 类型，这种歧义仍然是有问题的：如果模块中稍后添加了这样的定义，则可能会默默地改变程序中其他地方引用到的路径，而这将给人带来困扰。</p>\n<p>为了解决歧义，Rust 有一种特殊的路径，称为<strong>绝对路径</strong>，该路径以 <code>::</code> 开头，总会引用外部 crate。要引用 <code>image</code> crate 中的 <code>Pixels</code> 类型，可以这样写：</p>\n<pre class=\"code-rows\"><code>use ::image::Pixels;        // `image crate`中的`Pixels`</code></pre>\n<p>要引用你自己模块中的 <code>Sampler</code> 类型，可以这样写：</p>\n<pre class=\"code-rows\"><code>use self::image::Sampler;   // `image`模块中的`Sampler`</code></pre>\n<p>模块与文件不是一回事，但模块与 Unix 文件系统中的目录和文件有些相似之处。<code>use</code> 关键字会创建别名，就像用 <code>ln</code> 命令创建链接一样。路径和文件名一样，有绝对和相对两种形式。<code>self</code> 和 <code>super</code> 类似于 <code>.</code> 和 <code>..</code> 这样的特殊目录。</p>\n<h3 id=\"nav_point_135\">8.2.4　标准库预导入</h3>\n<p>我们刚才说过，就导入的名称而言，每个模块都以“白板”开头。但这个“白板”并不是<strong>完全</strong>空白的。</p>\n<p>一方面，标准库 <code>std</code> 会自动链接到每个项目。这意味着你始终可以使用 <code>use std::whatever</code>，或者就按名称引用 <code>std</code> 中的语法项，比如代码中内联的 <code>std::mem::swap()</code>。另一方面，还有一些特别的便捷名称（如 <code>Vec</code> 和 <code>Result</code>）会包含在<strong>标准库预导入</strong>中并自动导入。Rust 的行为就好像每个模块（包括根模块）都用以下导入语句开头一样：</p>\n<pre class=\"code-rows\"><code>use std::prelude::v1::*;</code></pre>\n<p>标准库预导入包含几十个常用的特型和类型。</p>\n<p>我们在第 2 章中提到的那些库有时会提供一些名为 <code>prelude</code>（预导入）的模块。但 <code>std::prelude::v1</code> 是唯一会自动导入的预导入。把一个模块命名为 <code>prelude</code> 只是一种约定，旨在告诉用户应该使用 <code>*</code> 导入它。</p>\n<h3 id=\"nav_point_136\">8.2.5　公开 <code>use</code> 声明</h3>\n<p>虽然 <code>use</code> 声明只是个别名，但也可以公开它们：</p>\n<pre class=\"code-rows\"><code>// 在plant_structures/mod.rs中\n...\npub use self::leaves::Leaf;\npub use self::roots::Root;</code></pre>\n<p>这意味着 <code>Leaf</code> 和 <code>Root</code> 是 <code>plant_structures</code> 模块的公共语法项。它们还是 <code>plant_structures::leaves::Leaf</code> 和 <code>plant_structures::roots::Root</code> 的简单别名。</p>\n<p>标准库预导入就是像这样编写的一系列 <code>pub</code> 导入。</p>\n<h3 id=\"nav_point_137\">8.2.6　公开结构体字段</h3>\n<p>模块可以包含用户定义的一些结构体类型（使用 <code>struct</code> 关键字引入）。第 9 章会详细介绍这些内容，但现在可以简单讲讲模块与结构体字段的可见性之间是如何相互作用的。</p>\n<p>一个简单的结构体如下所示：</p>\n<pre class=\"code-rows\"><code>pub struct Fern {\n    pub roots: RootSet,\n    pub stems: StemSet\n}</code></pre>\n<p>结构体的字段，甚至是私有字段，都可以在声明该结构体的整个模块及其子模块中访问。在模块之外，只能访问公共字段。</p>\n<p>事实证明，通过模块而不是像 Java 或 C++ 那样通过类来强制执行访问控制对软件设计非常有帮助。它减少了样板“getter”方法和“setter”方法，并且在很大程度上消除了对诸如 C++ <code>friend</code>（友元）声明等语法的需求。单个模块可以定义多个紧密协作的类型，例如 <code>frond::LeafMap</code> 和 <code>frond::LeafMapIter</code>，它们可以根据需要访问彼此的私有字段，同时仍然对程序的其余部分隐藏这些实现细节。</p>\n<h3 id=\"nav_point_138\">8.2.7　静态变量与常量</h3>\n<p>除了函数、类型和嵌套模块，模块还可以定义<strong>常量</strong>和<strong>静态变量</strong>。</p>\n<p>关键字 <code>const</code> 用于引入常量，其语法和 <code>let</code> 一样，只是它可以标记为 <code>pub</code>，并且必须写明类型。此外，常量的命名规约是 <code>UPPERCASE_NAMES</code>：</p>\n<pre class=\"code-rows\"><code>pub const ROOM_TEMPERATURE: f64 = 20.0;  // 摄氏度</code></pre>\n<p><code>static</code> 关键字引入了一个静态语法项，跟常量几乎是一回事：</p>\n<pre class=\"code-rows\"><code>pub static ROOM_TEMPERATURE: f64 = 68.0;  // 华氏度</code></pre>\n<p>常量有点儿像 C++ 的 <code>#define</code>：该值在每个使用了它的地方都会编译到你的代码中。静态变量是在程序开始运行之前设置并持续到程序退出的变量。在代码中对魔数和字符串要使用常量，而在处理大量的数据或需要借用常量值的引用时则要使用静态变量。</p>\n<p>没有 <code>mut</code> 常量。静态变量可以标记为 <code>mut</code>，但正如第 5 章所述，Rust 没有办法强制执行其关于 <code>mut</code> 静态变量的独占访问规则。因此，<code>mut</code> 静态变量本质上是非线程安全的，安全代码根本不能使用它们：</p>\n<pre class=\"code-rows\"><code>static mut PACKETS_SERVED: usize = 0;\n\nprintln!(\"{} served\", PACKETS_SERVED);  // 错误：使用了mut静态变量</code></pre>\n<p>Rust 不鼓励使用全局可变状态。有关备选方案的讨论，请参阅 19.3.11 节。</p>\n<h2 id=\"nav_point_139\">8.3　将程序变成库</h2>\n<p>随着蕨类植物模拟器成功运行，你会发现你所需要的不仅仅是单个程序。假设你有一个运行此模拟并将结果保存在文件中的命令行程序。现在，你想编写其他程序对这些保存下来的结果进行科学分析、实时显示正在生长的植物的 3D 渲染图、渲染足以乱真的图片，等等。所有这些程序都需要共享基本的蕨类植物模拟代码。这时候你应该建立一个库。</p>\n<p>第一步是将现有的项目分为两部分：一个库 crate，其中包含所有共享代码；一个可执行文件，其中只包含你现在的命令行程序才需要的代码。</p>\n<p>为了展示如何做到这一点，要使用一个极度简化的示例程序：</p>\n<pre class=\"code-rows\"><code>struct Fern {\n    size: f64,\n    growth_rate: f64\n}\n\nimpl Fern {\n    /// 模拟一株蕨类植物在一天内的生长\n    fn grow(&amp;mut self) {\n        self.size *= 1.0 + self.growth_rate;\n    }\n}\n\n/// 执行days天内某株蕨类植物的模拟\nfn run_simulation(fern: &amp;mut Fern, days: usize) {\n    for _ in 0 .. days {\n        fern.grow();\n    }\n}\n\nfn main() {\n    let mut fern = Fern {\n        size: 1.0,\n        growth_rate: 0.001\n    };\n    run_simulation(&amp;mut fern, 1000);\n    println!(\"final fern size: {}\", fern.size);\n}</code></pre>\n<p>假设这个程序有一个简单的 Cargo.toml 文件。</p>\n<pre class=\"code-rows\"><code>[package]\nname = \"fern_sim\"\nversion = \"0.1.0\"\nauthors = [\"You &lt;you@example.com&gt;\"]\nedition = \"2021\"</code></pre>\n<p>很容易将这个程序变成库，步骤如下。</p>\n<ol>\n<li class=\"第1级有序列表\">将文件 src/main.rs 重命名为 src/lib.rs。</li>\n<li class=\"第1级有序列表\">将 <code>pub</code> 关键字添加到 src/lib.rs 中的语法项上，这些语法项将成为这个库的公共特性。</li>\n<li class=\"第1级有序列表\">将 <code>main</code> 函数移动到某个临时文件中。（我们暂时不同管它。）</li>\n</ol>\n<p>生成的 src/lib.rs 文件如下所示：</p>\n<pre class=\"code-rows\"><code>pub struct Fern {\n    pub size: f64,\n    pub growth_rate: f64\n}\n\nimpl Fern {\n    /// 模拟一株蕨类植物在一天内的生长\n    pub fn grow(&amp;mut self) {\n        self.size *= 1.0 + self.growth_rate;\n    }\n}\n\n/// 执行days天内某株蕨类植物的模拟\npub fn run_simulation(fern: &amp;mut Fern, days: usize) {\n    for _ in 0 .. days {\n        fern.grow();\n    }\n}</code></pre>\n<p>请注意，不需要更改 Cargo.toml 中的任何内容。这是因为这个最小化的 Cargo.toml 文件只是为了让 Cargo 保持默认行为而已。默认设定下，<code>cargo build</code> 会查看源目录中的文件并根据文件名确定要构建的内容。当它发现存在文件 src/lib.rs 时，就知道要构建一个库。</p>\n<p>src/lib.rs 中的代码构成了库的<strong>根模块</strong>。其他使用这个库的 crate 只能访问这个根模块的公共语法项。</p>\n<h2 id=\"nav_point_140\">8.4　src/bin 目录</h2>\n<p>要让原来的命令行程序 <code>fern_sim</code> 再次运行起来也很简单，因为 Cargo 对和库位于同一个 crate 中的小型程序有一些内置支持。</p>\n<p>其实 Cargo 本身就是用这样的方式编写的。它的大部分代码在一个 Rust 库中。本书中一直使用的 <code>cargo</code> 命令行程序只是一个很薄的包装程序，它会调用库来完成所有繁重的工作。库和命令行程序都位于同一个源代码存储库中。</p>\n<p>你也可以将自己的程序和库放在同一个 crate 中。请将下面这段代码放入名为 src/bin/efern.rs 的文件中：</p>\n<pre class=\"code-rows\"><code>use fern_sim::;\n\nfn main() {\n    let mut fern = Fern {\n        size: 1.0,\n        growth_rate: 0.001\n    };\n    run_simulation(&amp;mut fern, 1000);\n    println!(\"final fern size: {}\", fern.size);\n}</code></pre>\n<p><code>main</code> 函数就是之前搁置的那个。我们为 <code>fern_sim</code> crate 中的一些语法项（<code>Fern</code> 和 <code>run_simulation</code>）添加了 <code>use</code> 声明。换句话说，我们在把这个 crate 当库来用。</p>\n<p>因为我们已将这个文件放入了 src/bin 中，所以 Cargo 将在我们下次运行 <code>cargo build</code> 时同时编译 <code>fern_sim</code> 库和这个程序。可以使用 <code>cargo run --bin efern</code> 来运行 <code>efern</code> 程序。下面是它的输出，使用 <code>--verbose</code> 可以展示 Cargo 正在运行的命令：</p>\n<pre class=\"code-rows\"><code>$ cargo build --verbose\n   Compiling fern_sim v0.1.0 (file:///.../fern_sim)\n     Running `rustc src/lib.rs --crate-name fern_sim --crate-type lib ...`\n     Running `rustc src/bin/efern.rs --crate-name efern --crate-type bin ...`\n$ cargo run --bin efern --verbose\n       Fresh fern_sim v0.1.0 (file:///.../fern_sim)\n     Running `target/debug/efern`\nfinal fern size: 2.7169239322355985</code></pre>\n<p>我们仍然不必对 Cargo.toml 进行任何修改，因为 Cargo 的默认设定就是查看你的源文件并自行决定做什么。Cargo 会自动将 src/bin 中的 .rs 文件视为应该构建的额外程序。</p>\n<p>还可以利用子目录在 src/bin 目录中构建更大的程序。假设我们要提供第二个在屏幕上绘制蕨类植物的程序，但绘制代码规模很大而且是模块化的，因此它拥有自己的文件。我们可以给第二个程序建立它自己的子目录：</p>\n<pre class=\"code-rows\"><code>fern_sim/\n├── Cargo.toml\n└── src/\n    └── bin/\n        ├── efern.rs\n        └── draw_fern/\n            ├── main.rs\n            └── draw.rs</code></pre>\n<p>这样做的好处是能让更大的二进制文件拥有自己的子模块，而不会弄乱库代码或 src/bin 目录。</p>\n<p>不过，既然 <code>fern_sim</code> 现在是一个库，那么我们也就多了一种选择：把这个程序放在它自己的独立项目中，再保存到一个完全独立的目录中，然后在它自己的 Cargo.toml 中将 <code>fern_sim</code> 列为依赖项：</p>\n<pre class=\"code-rows\"><code>[dependencies]\nfern_sim = { path = \"../fern_sim\" }</code></pre>\n<p>也许这就是你以后要为其他蕨类植物模拟程序专门做的事。src/bin 目录只适合像 <code>efern</code> 和 <code>draw_fern</code> 这样的简单程序。</p>\n<h2 id=\"nav_point_141\">8.5　属性</h2>\n<p>Rust 程序中的任何语法项都可以用<strong>属性</strong>进行装饰。属性是 Rust 的通用语法，用于向编译器提供各种指令和建议。假设你收到了如下警告：</p>\n<pre class=\"code-rows\"><code>libgit2.rs: warning: type `git_revspec` should have a camel case name\n    such as `GitRevspec`, #[warn(non_camel_case_types)] on by default</code></pre>\n<p>但是你选择这个名字是有特别原因的，只希望 Rust 对此“闭嘴”。那么通过在此类型上添加 <code>#[allow]</code> 属性就可以禁用这条警告：</p>\n<pre class=\"code-rows\"><code>#[allow(non_camel_case_types)]\npub struct git_revspec {\n    ...\n}</code></pre>\n<p>条件编译是使用名为 <code>#[cfg]</code> 的属性编写的另一项特性：</p>\n<pre class=\"code-rows\"><code>// 只有当我们为Android构建时才在项目中包含此模块\n#[cfg(target_os = \"android\")]\nmod mobile;</code></pre>\n<p><code>#[cfg]</code> 的完整语法可以到 Rust 参考手册中查看，表 8-2 列出了最常用的选项。</p>\n<p><strong>表 8-2：最常用的 <code>#[cfg]</code> 选项</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p><code>#[cfg(...)]</code> 选项</p></th>\n<th><p>当启用时·····</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>test</code></p></td>\n<td><p>启用测试（使用 <code>cargo test</code> 或 <code>rustc --test</code> 编译）</p></td>\n</tr>\n<tr>\n<td><p><code>debug_assertions</code></p></td>\n<td><p>启用调试断言（通常在非优化构建中）</p></td>\n</tr>\n<tr>\n<td><p><code>unix</code></p></td>\n<td><p>为 Unix（包括 macOS）编译</p></td>\n</tr>\n<tr>\n<td><p><code>windows</code></p></td>\n<td><p>为 Windows 编译</p></td>\n</tr>\n<tr>\n<td><p><code>target_pointer_width = \"64\"</code></p></td>\n<td><p>针对 64 位平台。另一个可能的值是 <code>\"32\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>target_arch = \"x86_64\"</code></p></td>\n<td><p>特别针对 x86-64。其他值有：<code>\"x86\"</code>、<code>\"arm\"</code>、<code>\"aarch64\"</code>、<code>\"powerpc\"</code>、<code>\"powerpc64\"</code> 和 <code>\"mips\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>target_os = \"macos\"</code></p></td>\n<td><p>为 macOS 编译。其他值有：<code>\"windows\"</code>、<code>\"ios\"</code>、<code>\"android\"</code>、<code>\"linux\"</code>、<code>\"freebsd\"</code>、<code>\"openbsd\"</code>、<code>\"netbsd\"</code> 和 <code>\"dragonfly\"</code></p></td>\n</tr>\n<tr>\n<td><p><code>feature = \"robots\"</code></p></td>\n<td><p>启用名为 <code>\"robots\"</code> 的用户自定义特性（用 <code>cargo build --feature robots</code> 或 <code>rustc --cfg feature='\"robots\"'</code> 编译）。这些特性是在 Cargo.toml 的 <code>[features]</code> 区段中声明的</p></td>\n</tr>\n<tr>\n<td><p><code>not(</code><i>A</i><code>)</code></p></td>\n<td><p>不满足条件 <i>A</i> 时。如果要提供某函数的两种实现，请将其中一个标记为 <code>#[cfg(X)]</code>，另一个标记为 <code>#[cfg(not(X))]</code></p></td>\n</tr>\n<tr>\n<td><p><code>all(</code><i>A</i><code>,</code><i>B</i><code>)</code></p></td>\n<td><p>同时满足 <i>A</i> 和 <i>B</i>（相当于 <code>&amp;&amp;</code>）</p></td>\n</tr>\n<tr>\n<td><p><code>any(</code><i>A</i><code>,</code><i>B</i><code>)</code></p></td>\n<td><p>只要满足 <i>A</i> 或 <i>B</i> 之一（相当于 <code>||</code>）</p></td>\n</tr>\n</tbody>\n</table>\n<p>有时，可能需要对函数的内联展开进行微观管理，但我们通常会把这种优化留给编译器。可以使用 <code>#[inline]</code> 属性进行微观管理：</p>\n<pre class=\"code-rows\"><code>/// 由于相邻细胞之间存在渗透作用，因此需要调整它们的离子水平等\n#[inline]\nfn do_osmosis(c1: &amp;mut Cell, c2: &amp;mut Cell) {\n    ...\n}</code></pre>\n<p>在一种特定的情况下，如果没有 <code>#[inline]</code>，<strong>就不会</strong>发生内联。当在一个 crate 中定义的函数或方法在另一个 crate 中被调用时，Rust 不会将其内联，除非它是泛型的（具有类型参数）或明确标记为 <code>#[inline]</code>。</p>\n<p>在其他情况下，编译器只会将 <code>#[inline]</code> 视为建议。Rust 还支持更坚定的 <code>#[inline(always)]</code>（要求函数在每个调用点内联展开）和 <code>#[inline(never)]</code>（要求函数永不内联）。</p>\n<p>一些属性（如 <code>#[cfg]</code> 和 <code>#[allow]</code>）可以附着到整个模块上并对其中的所有内容生效。另一些属性（如 <code>#[test]</code> 和 <code>#[inline]</code>）则必须附着到单个语法项上。正如你对这种包罗万象的语法特性的预期一样，每个属性都是定制的，并且有自己所支持的一组参数。Rust 参考文档详细记录了它支持的全套属性。</p>\n<p>要将属性附着到整个 crate 上，请将其添加到 main.rs 文件或 lib.rs 文件的顶部，放在任何语法项之前，并写成 <code>#!</code>，而不是 <code>#</code>，就像这样：</p>\n<pre class=\"code-rows\"><code>// libgit2_sys/lib.rs\n#![allow(non_camel_case_types)]\n\npub struct git_revspec {\n    ...\n}\n\npub struct git_error {\n    ...\n}</code></pre>\n<p><code>#!</code> 要求 Rust 将一个属性附着到整个封闭区中的语法项而不只是紧邻其后的内容上：在这种情况下，<code>#![allow]</code> 属性会附着到整个 <code>libgit2_sys</code> 包而不仅仅是 <code>struct git_revspec</code> 上</p>\n<p><code>#!</code> 也可以在函数、结构体等内部使用（但 <code>#!</code> 通常只用在文件的开头，以将属性附着到整个模块或 crate 上）。某些属性始终使用 <code>#!</code> 语法，因为它们只能应用于整个 crate。</p>\n<p>例如，<code>#![feature]</code> 属性用于启用 Rust 语言和库的<strong>不稳定</strong>特性，这些特性是实验性的，因此可能有 bug 或者未来可能会被更改或移除。例如，在我们撰写本章时，Rust 实验性地支持跟踪像 <code>assert!</code> 这样的宏的展开。但由于此支持是实验性的，因此你只能通过两种方式来使用：安装 Rust 的夜间构建版或明确声明你的 crate 使用宏跟踪。</p>\n<pre class=\"code-rows\"><code>#![feature(trace_macros)]\n\nfn main() {\n    // 我想知道这个使用assert_eq!的代码替换（展开）后会是什么样子！\n    trace_macros!(true);\n    assert_eq!(10*10*10 + 9*9*9, 12*12*12 + 1*1*1);\n    trace_macros!(false);\n}</code></pre>\n<p>随着时间的推移，Rust 团队有时会将实验性特性<strong>稳定</strong>下来，使其成为语言标准的一部分。那时这个 <code>#![feature]</code> 属性就会变得多余，因此 Rust 会生成一个警告，建议你将其移除。</p>\n","comments":[{"had_liked":false,"id":389983,"user_name":"一位不愿透露姓名的王先生","can_delete":false,"product_type":"c1","uid":1031394,"ip_address":"福建","ucode":"EB2C9420B3484A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/e2/e760c8e2.jpg","comment_is_top":false,"comment_ctime":1714034210,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636604,"comment_content":"use fern_sim::;  \n这个会报错， 不应该是 use fern_sim::*; 吗？ ","like_count":1}]}