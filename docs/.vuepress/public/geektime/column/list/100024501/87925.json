{"id":87925,"title":"09 | 无侵入的埋点方案如何实现？","content":"<p>你好，我是戴铭。</p><p>在iOS开发中，埋点可以解决两大类问题：一是了解用户使用App的行为，二是降低分析线上问题的难度。目前，iOS开发中常见的埋点方式，主要包括代码埋点、可视化埋点和无埋点这三种。</p><ul>\n<li>\n<p>代码埋点主要就是通过手写代码的方式来埋点，能很精确的在需要埋点的代码处加上埋点的代码，可以很方便地记录当前环境的变量值，方便调试，并跟踪埋点内容，但存在开发工作量大，并且埋点代码到处都是，后期难以维护等问题。</p>\n</li>\n<li>\n<p>可视化埋点，就是将埋点增加和修改的工作可视化了，提升了增加和维护埋点的体验。</p>\n</li>\n<li>\n<p>无埋点，并不是不需要埋点，而更确切地说是“全埋点”，而且埋点代码不会出现在业务代码中，容易管理和维护。它的缺点在于，埋点成本高，后期的解析也比较复杂，再加上view_path的不确定性。所以，这种方案并不能解决所有的埋点需求，但对于大量通用的埋点需求来说，能够节省大量的开发和维护成本。</p>\n</li>\n</ul><p>在这其中，可视化埋点和无埋点，都属于是无侵入的埋点方案，因为它们都不需要在工程代码中写入埋点代码。所以，采用这样的无侵入埋点方案，既可以做到埋点被统一维护，又可以实现和工程代码的解耦。</p><p>接下来，我们就通过今天这篇文章，一起来分析一下无侵入埋点方案的实现问题吧。</p><!-- [[[read_end]]] --><h2>运行时方法替换方式进行埋点</h2><p>我们都知道，在iOS开发中最常见的三种埋点，就是对页面进入次数、页面停留时间、点击事件的埋点。对于这三种常见情况，我们都可以通过运行时方法替换技术来插入埋点代码，以实现无侵入的埋点方法。具体的实现方法是：先写一个运行时方法替换的类SMHook，加上替换的方法 hookClass:fromSelector:toSelector，代码如下：</p><pre><code>#import &quot;SMHook.h&quot;\n#import &lt;objc/runtime.h&gt;\n\n@implementation SMHook\n\n+ (void)hookClass:(Class)classObject fromSelector:(SEL)fromSelector toSelector:(SEL)toSelector {\n    Class class = classObject;\n    // 得到被替换类的实例方法\n    Method fromMethod = class_getInstanceMethod(class, fromSelector);\n    // 得到替换类的实例方法\n    Method toMethod = class_getInstanceMethod(class, toSelector);\n    \n    // class_addMethod 返回成功表示被替换的方法没实现，然后会通过 class_addMethod 方法先实现；返回失败则表示被替换方法已存在，可以直接进行 IMP 指针交换 \n    if(class_addMethod(class, fromSelector, method_getImplementation(toMethod), method_getTypeEncoding(toMethod))) {\n    \t// 进行方法的替换\n        class_replaceMethod(class, toSelector, method_getImplementation(fromMethod), method_getTypeEncoding(fromMethod));\n    } else {\n    \t// 交换 IMP 指针\n        method_exchangeImplementations(fromMethod, toMethod);\n    }\n\n}\n\n@end\n</code></pre><p>这个方法利用运行时 method_exchangeImplementations 接口将方法的实现进行了交换，原方法调用时就会被 hook 住，从而去执行指定的方法。</p><p><strong>页面进入次数、页面停留时间都需要对 UIViewController 生命周期进行埋点</strong>，你可以创建一个 UIViewController 的 Category，代码如下：</p><pre><code>@implementation UIViewController (logger)\n+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^{\n        // 通过 @selector 获得被替换和替换方法的 SEL，作为 SMHook:hookClass:fromeSelector:toSelector 的参数传入 \n        SEL fromSelectorAppear = @selector(viewWillAppear:);\n        SEL toSelectorAppear = @selector(hook_viewWillAppear:);\n        [SMHook hookClass:self fromSelector:fromSelectorAppear toSelector:toSelectorAppear];\n        \n        SEL fromSelectorDisappear = @selector(viewWillDisappear:);\n        SEL toSelectorDisappear = @selector(hook_viewWillDisappear:);\n        \n        [SMHook hookClass:self fromSelector:fromSelectorDisappear toSelector:toSelectorDisappear];\n    });\n}\n\n- (void)hook_viewWillAppear:(BOOL)animated {\n    // 先执行插入代码，再执行原 viewWillAppear 方法\n    [self insertToViewWillAppear];\n    [self hook_viewWillAppear:animated];\n}\n- (void)hook_viewWillDisappear:(BOOL)animated {\n    // 执行插入代码，再执行原 viewWillDisappear 方法\n    [self insertToViewWillDisappear];\n    [self hook_viewWillDisappear:animated];\n}\n\n- (void)insertToViewWillAppear {\n    // 在 ViewWillAppear 时进行日志的埋点\n    [[[[SMLogger create]\n       message:[NSString stringWithFormat:@&quot;%@ Appear&quot;,NSStringFromClass([self class])]]\n      classify:ProjectClassifyOperation]\n     save];\n}\n- (void)insertToViewWillDisappear {\n    // 在 ViewWillDisappear 时进行日志的埋点\n    [[[[SMLogger create]\n       message:[NSString stringWithFormat:@&quot;%@ Disappear&quot;,NSStringFromClass([self class])]]\n      classify:ProjectClassifyOperation]\n     save];\n}\n@end\n</code></pre><p>可以看到，Category 在 +load() 方法里使用了 SMHook 进行方法替换，在替换的方法里执行需要埋点的方法 [self insertToViewWillAppear]。这样的话，每个 UIViewController 生命周期到了 ViewWillAppear 时都会去执行 insertToViewWillAppear 方法。</p><p>那么，我们要怎么区别不同的 UIViewController 呢？我一般采取的做法都是，使用NSStringFromClass([self class]) 方法来取类名。这样，我就能够通过类名来区别不同的UIViewController了。</p><p><strong>对于点击事件来说，我们也可以通过运行时方法替换的方式进行无侵入埋点。</strong>这里最主要的工作是，找到这个点击事件的方法 sendAction:to:forEvent:，然后在 +load() 方法使用 SMHook 替换成为你定义的方法。完整代码实现如下：</p><pre><code>+ (void)load {\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^{\n        // 通过 @selector 获得被替换和替换方法的 SEL，作为 SMHook:hookClass:fromeSelector:toSelector 的参数传入\n        SEL fromSelector = @selector(sendAction:to:forEvent:);\n        SEL toSelector = @selector(hook_sendAction:to:forEvent:);\n        [SMHook hookClass:self fromSelector:fromSelector toSelector:toSelector];\n    });\n}\n\n- (void)hook_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {\n    [self insertToSendAction:action to:target forEvent:event];\n    [self hook_sendAction:action to:target forEvent:event];\n}\n- (void)insertToSendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {\n    // 日志记录\n    if ([[[event allTouches] anyObject] phase] == UITouchPhaseEnded) {\n        NSString *actionString = NSStringFromSelector(action);\n        NSString *targetName = NSStringFromClass([target class]);\n        [[[SMLogger create] message:[NSString stringWithFormat:@&quot;%@ %@&quot;,targetName,actionString]] save];\n    }\n}\n</code></pre><p>和 UIViewController 生命周期埋点不同的是，UIButton 在一个视图类中可能有多个不同的继承类，相同 UIButton 的子类在不同视图类的埋点也要区别开。所以，我们需要通过 “action 选择器名 NSStringFromSelector(action)” +“视图类名 NSStringFromClass([target class])”组合成一个唯一的标识，来进行埋点记录。</p><p>除了UIViewController、UIButton控件以外，Cocoa 框架的其他控件都可以使用这种方法来进行无侵入埋点。以 Cocoa 框架中最复杂的 UITableView 控件为例，你可以使用hook setDelegate 方法来实现无侵入埋点。另外，对于Cocoa 框架中的手势事件（Gesture Event），我们也可以通过hook initWithTarget:action: 方法来实现无侵入埋点。</p><h2>事件唯一标识</h2><p>通过运行时方法替换的方式，我们能够 hook 住所有的 Objective-C 方法，可以说是大而全了，能够帮助我们解决绝大部分的埋点问题。</p><p>但是，这种方案的精确度还不够高，还无法区分相同类在不同视图树节点的情况。比如，一个视图下相同 UIButton 的不同实例，仅仅通过 “action 选择器名”+“视图类名”的组合还不能够区分开。这时，我们就需要有一个唯一标识来区分不同的事件。接下来，我就跟你说说<strong>如何制定出这个唯一标识</strong>。</p><p>这时，我首先想到的就是，能不能通过视图层级的路径来解决这个问题。因为每个页面都有一个视图树结构，通过视图的 superview 和 subviews 的属性，我们就能够还原出每个页面的视图树。视图树的顶层是 UIWindow，每个视图都在树的子节点上。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/cb/52/cbfb127db8ed2545fd3ce0aa3ae6f452.png?wh=1920*1080\" alt=\"\"><br>\n一个视图下的子节点可能是同一个视图的不同实例，比如上图中 UIView 视图节点下的两个 UIButton 是同一个类的不同实例，所以光靠视图树的路径还是没法唯一确定出视图的标识。那么，这种情况下，我们又应该如何区别不同的视图呢？</p><p>这时，我们想到了索引：每个子视图在父视图中都会有自己的索引，所以如果我们再加上这个索引的话，每个视图的标识就是唯一的了。</p><p>接下来的一个问题是，视图层级路径加上在父视图中的索引来进行唯一标识，是不是就能够涵盖所有情况了呢？</p><p>当然不是。我们还需要考虑类似 UITableViewCell 这种具有可复用机制的视图，Cell 会在页面滚动时不断复用，所以加索引的方式还是没法用。</p><p>但这个问题也并不是无解的。UITableViewCell 需要使用 indexPath，这个值里包含了 section 和 row 的值。所以，我们可以通过 indexPath 来确定每个 Cell 的唯一性。</p><p>除了 UITableViewCell 这种情况之外， UIAlertController也比较特殊。它的特殊性在于视图层级的不固定，因为它可能出现在任何页面中。但是，我们都知道它的功能区分往往通过弹窗内容来决定，所以可以通过内容来确定它的唯一标识。</p><p>除此之外，还有更多需要特殊处理的情况，但我们总是可以通过一些办法去确定它们的唯一性，所以我在这里也就不再一一列举了。思路上来说就是，想办法找出元素间不相同的因素然后进行组合，最后形成一个能够区别于其他元素的标识来。</p><p>除了上面提到的这些特殊情况外，还有一种情况使得我们也难以得到准确的唯一标识。如果视图层级在运行时会被更改，比如执行 insertSubView:atIndex:、removeFromSuperView 等方法时，我们也无法得到唯一标识，即使只截取部分路径也无法保证后期代码更新时不会动到这个部分。就算是运行时视图层级不会修改，以后需求迭代页面更新频繁的话，视图唯一标识也需要同步的更新维护。</p><p>这种问题就不好解决了，事件唯一标识的准确性难以保障，这也是通过运行时方法替换进行无侵入埋点很难在各个公司全面铺开的原因。虽然无侵入埋点无法覆盖到所有情况，全面铺开面临挑战，但是无侵入埋点还是解决了大部分的埋点需求，也节省了大量的人力成本。</p><h2>小结</h2><p>今天这篇文章，我与你分享了运行时替换方法进行无侵入埋点的方案。这套方案由于唯一标识难以维护和准确性难以保障的原因，很难被全面采用，一般都只是用于一些功能和视图稳定的地方，手动侵入式埋点方式依然占据大部分场景。</p><p>无侵入埋点也是业界一大难题，目前还只是初级阶段，还有很长的路要走。我认为，运行时替换方法的方式也只是一种尝试，但是现实中业务代码太过复杂。同时，为了使无侵入的埋点能够覆盖得更全、准确度更高，代价往往是对埋点所需的标识维护成本不断增大。</p><p>所以说，我觉得这种方案并不一定是未来的方向。我倒是觉得使用 Clang AST 的接口，在构建时遍历 AST，通过定义的规则将所需要的埋点代码直接加进去，可能会更加合适。这时，我们可以使用前一篇文章“如何利用 Clang 为 App 提质？”中提到的 LibTooling 来开发一个独立的工具，专门以静态方式插入埋点代码。这样做，既可以享受到手动埋点的精确性，还能够享受到无侵入埋点方式的统一维护、开发解耦、易维护的优势。</p><h2>课后作业</h2><p>今天我和你具体说了下 UIViewController 生命周期和 UIButton 点击事件的无侵入埋点方式，并给了具体的实现代码。那么，对于 UITableViewCell 点击事件的无侵入埋点，应该怎么来实现的代码，就当做一个课后小作业留给你来完成吧。</p><p>感谢你的收听，欢迎你在评论区给我留言分享你的观点，也欢迎把它分享给更多的朋友一起阅读。</p><p></p>","neighbors":{"left":{"article_title":"08 | 如何利用 Clang 为 App 提质？","id":87844},"right":{"article_title":"10 | 包大小：如何从资源和代码层面实现全方位瘦身？","id":88573}},"comments":[{"had_liked":false,"id":81436,"user_name":"小前端","can_delete":false,"product_type":"c1","uid":1271383,"ip_address":"","ucode":"F9C45FDF0E9084","user_header":"https://static001.geekbang.org/account/avatar/00/13/66/57/f76f20b6.jpg","comment_is_top":false,"comment_ctime":1553913580,"is_pvip":false,"replies":[{"id":"29901","content":"客户端只能负责采集数据，采集的数据到了服务端，还需要进行功能标注。关于业务数据依赖在服务端做关联，不过标注的内容维护成本依然很大，对于客户端开发人员来说是减轻了工作量，而工作量转接到了维护标注的人那。","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1554301673,"ip_address":"","comment_id":81436,"utype":1}],"discussion_count":2,"race_medal":0,"score":"186237507308","product_id":100024501,"comment_content":"感觉这篇文章适合做原理讲解，实用性不大。实际业务场景中会需要抓取页面id，控件id，控件内容,事件类型，埋点类型(比如曝光还是事件)，很复杂的，而这些信息都需要在具体的业务中获取。至少本文这套理论是做不到的。运营和产品也不会按照什么view path来分析结果。","like_count":43,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445196,"discussion_content":"客户端只能负责采集数据，采集的数据到了服务端，还需要进行功能标注。关于业务数据依赖在服务端做关联，不过标注的内容维护成本依然很大，对于客户端开发人员来说是减轻了工作量，而工作量转接到了维护标注的人那。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554301673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1454681,"avatar":"https://static001.geekbang.org/account/avatar/00/16/32/59/adcd805b.jpg","nickname":"shall we talk？","note":"","ucode":"ADA702C38489E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38974,"discussion_content":"业务数据通过实现接口方法进行返回就行了。 采集时对对象调用接口方法，有数据就返回，没数据就通过实现方法转发返回空或者定义的其他格式数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571873984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81875,"user_name":"鹏哥","can_delete":false,"product_type":"c1","uid":1459217,"ip_address":"","ucode":"FFF5EBDF4606CA","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/11/37ec1136.jpg","comment_is_top":false,"comment_ctime":1554077072,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"87453422992","product_id":100024501,"comment_content":"交换方法的代码有的说放在load方法，有的说放在load方法里面影响了启动速度，应该移到initalize方法中，所以，老师，你怎么看的？","like_count":20,"discussions":[{"author":{"id":2132638,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ergjleMbtpL8qcTqBxShJ8oD6ibfdSuvu0XZtadpj9AB8JicAIkiaQC837NRmwXPQ689wxqPAHwcAMqw/132","nickname":"Geek_3ef812","note":"","ucode":"00339A90F9C117","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302808,"discussion_content":"+load 方法和 +initalize 调用时机是不同的 如果使用initalize可能替换方法就没有成功，更不要说埋点了。必要+load还是需要的，戴老师的意思是去除load方法中没必要的代码","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599035189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2022825,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/dd/a9/b2aad3b0.jpg","nickname":"Andy","note":"","ucode":"3DCE688BC2305E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276248,"discussion_content":"个人觉得还是得在+load中，因为后者会因为复写而被覆盖以致代码失效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590846337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1472981,"avatar":"https://static001.geekbang.org/account/avatar/00/16/79/d5/4dee8730.jpg","nickname":"波儿菜","note":"","ucode":"4084D02C277D40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42069,"discussion_content":"使用链式Hook方式可能更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572579984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81426,"user_name":"张蒙","can_delete":false,"product_type":"c1","uid":1035858,"ip_address":"","ucode":"CF8727F5DCFD55","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/52/4f1911b5.jpg","comment_is_top":false,"comment_ctime":1553912180,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"65978421620","product_id":100024501,"comment_content":"利用Aspects，实现面向横切编程，在加上资源增量更新可以实现动态无痕埋点。","like_count":15,"discussions":[{"author":{"id":1823275,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/d2/2b/7a93d588.jpg","nickname":"低调的魅力","note":"","ucode":"AE5CA2986B5A95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553251,"discussion_content":"Aspects原理也是方法交换啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645785044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94410,"user_name":"Damon","can_delete":false,"product_type":"c1","uid":1458957,"ip_address":"","ucode":"318F0D8C8D0B52","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/7IvaucOdCqF6HLA3aC7YzYzv9GGJ26Wz5XESWMAoycSO2KQIibBxmaMc4E2icjJoO1gP5GqqJspt6ZPuxd5EKBag/132","comment_is_top":false,"comment_ctime":1557803030,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"57392377878","product_id":100024501,"comment_content":"hook最好放在load中而不是InInitialize中，是跟调用的机制有关系，同时类别中实现了InInitialize会覆盖本类的InInitialize方法，有些场景不适用（比如本类和类别都做了方法hook），而load则能满足这种场景，所以最好在load中做hook，也可以根据业务场景选择是在load还是在InInitialize中hook","like_count":13},{"had_liked":false,"id":82314,"user_name":"ssala","can_delete":false,"product_type":"c1","uid":1005356,"ip_address":"","ucode":"CCD82C81756FC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","comment_is_top":false,"comment_ctime":1554183779,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48798824035","product_id":100024501,"comment_content":"埋点如果要携带业务数据的话，本身就是一件很复杂很特化的问题了，除了手动埋点以外没有更好的方式，硬是把无埋点这套逻辑往上套的话，除了徒增复杂度以外，没什么好处。","like_count":11},{"had_liked":false,"id":82632,"user_name":"Geek_d4991f","can_delete":false,"product_type":"c1","uid":1388977,"ip_address":"","ucode":"4CF1398F8EB6B0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep5UuuSVCMz72V8SpR6vWiaibMq8yBICQJ2DAj72DO8BoUQTFc5BM9cmGtMPsiaywpwWicjicnnqHztmbA/132","comment_is_top":false,"comment_ctime":1554263445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44503936405","product_id":100024501,"comment_content":"建议可以读下mixpanel，基本市面上的全埋点、无埋点都是基于此方案的优化，不过mixpanel的hook存在递归无法退出问题，需要优化","like_count":10},{"had_liked":false,"id":81798,"user_name":"drunkenMouse","can_delete":false,"product_type":"c1","uid":1454037,"ip_address":"","ucode":"AA8CEA703ECBE8","user_header":"","comment_is_top":false,"comment_ctime":1554037871,"is_pvip":false,"replies":[{"id":"29813","content":"实际工程可以这么做，没有问题的","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1554198858,"ip_address":"","comment_id":81798,"utype":1}],"discussion_count":5,"race_medal":0,"score":"31618808943","product_id":100024501,"comment_content":"1.为什么不把+load方法移到initalize？既然是单例的话，不用担心子类调用父类的重复调用吧？<br>2.为什么不建一个基于UIViewController的基类，然后重写ViewWillAppear与ViewDidAppear？只要保证所有的UIViewController都继承这个基类就可以的吧。<br>","like_count":7,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445350,"discussion_content":"实际工程可以这么做，没有问题的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554198858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1457792,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3e/80/31782d05.jpg","nickname":"Crazy_cc","note":"","ucode":"1F826C25B75D88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311971,"discussion_content":"继承耦合太高，以后不利于复用或者拆分组件化，用分类明显更好一些","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1602553860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2067646,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8c/be/eeda0ed0.jpg","nickname":"我爱钢铁侠！","note":"","ucode":"C1AFF814B18BDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291775,"discussion_content":"搞个基类的问题就是耦合度太高，推荐使用分类或者协议","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594951538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1651522,"avatar":"https://static001.geekbang.org/account/avatar/00/19/33/42/a981ef2e.jpg","nickname":"费城","note":"","ucode":"0009EA55E63DC5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290003,"discussion_content":"关于你的第二点，假如是接收别人的项目，那修改工作量可能会很大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594298282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2022825,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/dd/a9/b2aad3b0.jpg","nickname":"Andy","note":"","ucode":"3DCE688BC2305E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276249,"discussion_content":"耦合度高，是个问题…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590846428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81632,"user_name":"Geek_53637b","can_delete":false,"product_type":"c1","uid":1455746,"ip_address":"","ucode":"3C90226702E1FC","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJJiajCGR28j4RDeUuBnfKGANicgT1nHyibKNHGibAK2R8zTz3LKl4QtJ0Aypj0zke6oeydYZJKgPRPlQ/132","comment_is_top":false,"comment_ctime":1553992124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31618763196","product_id":100024501,"comment_content":"实际埋点需求中，埋点往往和业务数据强相关，比如点击页面上的加车按钮，埋点上报的数据中需要有商品id，当前商品的促销类型，商家id等等，这类需求暂时没有很好的无痕埋点方案","like_count":7},{"had_liked":false,"id":82087,"user_name":"Geek_de8948","can_delete":false,"product_type":"c1","uid":1459920,"ip_address":"","ucode":"102103B560A2B5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoyET5yKaDHyZEDAG3Lsy1B0gKMNATGIVDuJibfnWLZhwqOOOLtLL1F7qXmegLBfJZiaZUUicBKNtqPg/132","comment_is_top":false,"comment_ctime":1554116279,"is_pvip":false,"replies":[{"id":"29811","content":"是的，从发展来看，通过 Clang 打桩可能更适合","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1554198735,"ip_address":"","comment_id":82087,"utype":1}],"discussion_count":4,"race_medal":0,"score":"27323920055","product_id":100024501,"comment_content":"一直觉得采用切面编程实现埋点都是理论上，实际是不可行的。<br>因为如果项目集成bugly这种第三方sdk时，他们也是切面，你埋掉也切，这种相互各种交换方法系统方面，肯定会导致一个失效。<br>这个问题困扰了很久，不知道老师咋看。<br>比如我现在项目由于早期就使用了bugly，导致我现在就不敢随意切。","like_count":6,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445461,"discussion_content":"是的，从发展来看，通过 Clang 打桩可能更适合","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554198735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1458649,"avatar":"https://static001.geekbang.org/account/avatar/00/16/41/d9/755ff886.jpg","nickname":"风言风语","note":"","ucode":"FBF87744A4FD10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65662,"discussion_content":"其实如果在同一个系统控件的不同分类里对同一个系统方法进行方法交换，最终的结果是不会导致有一个方法失效的，只是会增加调用的层级关系，被替换掉的系统方法的实现会在最后才能调用到，前面会在不同的自定义的方法中流转一遍","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575019367,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1455880,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/08/e25813c0.jpg","nickname":"落夏","note":"","ucode":"A5A2A5C4EF9E54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282040,"discussion_content":"如果引入的两个第三方同时hook了一个系统的方法，如何保证两个三方能正常运行，而不会被对方影响，想不通","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591866324,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2067646,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8c/be/eeda0ed0.jpg","nickname":"我爱钢铁侠！","note":"","ucode":"C1AFF814B18BDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1455880,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/08/e25813c0.jpg","nickname":"落夏","note":"","ucode":"A5A2A5C4EF9E54","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291776,"discussion_content":"这点你可以看看第三方的优质源码，别人的实现代码是怎么在进行方法交换时候做了处理，保证方法交换的结果是正确的的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594951718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":282040,"ip_address":""},"score":291776,"extra":""}]}]},{"had_liked":false,"id":81421,"user_name":"筇琼","can_delete":false,"product_type":"c1","uid":1458239,"ip_address":"","ucode":"A0DB5CC0884E64","user_header":"https://static001.geekbang.org/account/avatar/00/16/40/3f/63fc1b53.jpg","comment_is_top":false,"comment_ctime":1553910856,"is_pvip":false,"replies":[{"id":"29533","content":"需要避免 hook 冲突","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553941323,"ip_address":"","comment_id":81421,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18733780040","product_id":100024501,"comment_content":"戴老师，你好，当我有两个类扩展，都通过运行时交换了ViewWillAppear方法，此时会崩溃，请问这个改如何避免，这个崩溃是必然的吗？还是由于我加入扩展的顺序导致的？","like_count":4,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445190,"discussion_content":"需要避免 hook 冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553941323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1455880,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/08/e25813c0.jpg","nickname":"落夏","note":"","ucode":"A5A2A5C4EF9E54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282041,"discussion_content":"如何避免 hook 冲突","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591866383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1458239,"avatar":"https://static001.geekbang.org/account/avatar/00/16/40/3f/63fc1b53.jpg","nickname":"筇琼","note":"","ucode":"A0DB5CC0884E64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1455880,"avatar":"https://static001.geekbang.org/account/avatar/00/16/37/08/e25813c0.jpg","nickname":"落夏","note":"","ucode":"A5A2A5C4EF9E54","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305586,"discussion_content":"可以选择别的时机去hook，别人的是load方法，你可以在initialize方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600009758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":282041,"ip_address":""},"score":305586,"extra":""}]}]},{"had_liked":false,"id":101467,"user_name":"Kim","can_delete":false,"product_type":"c1","uid":1459100,"ip_address":"","ucode":"E3C8D1C0E9C0A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLJzrtHs9DeaIR6eSlo2DKm93q69AWaB9ibEmlO6PDbic9iajFSwZLhAGLtbDgrbUI7aadyEiaK6lL4FA/132","comment_is_top":false,"comment_ctime":1559813889,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"14444715777","product_id":100024501,"comment_content":"我的实现方案<br><br>```<br>@implementation UITableView (SMHook)<br>+ (void)load {<br>    SEL fromSelector = @selector(setDelegate:);<br>    SEL toSelector = @selector(sm_toDelegate:);<br>    <br>    [SMHook hookClass:self fromSelector:fromSelector toSelector:toSelector];<br>}<br><br>- (void)sm_toDelegate:(id &lt;UITableViewDelegate&gt;)delegate {<br>    [self sm_toDelegate:delegate];<br>    &#47;&#47; 得到代理对象,代理对象会调用代理方法<br>    SEL fromSelector = @selector(tableView:didSelectRowAtIndexPath:);<br>    SEL toSelector = @selector(sm_tableView:didSelectRowAtIndexPath:);<br>    <br>    &#47;&#47; 得到被替换的类的实例方式<br>    Method fromMethod = class_getInstanceMethod(delegate.class, fromSelector);<br>    &#47;&#47; 得到替换的类的实例方法<br>    Method toMethod = class_getInstanceMethod(self.class, toSelector);<br>    <br>    &#47;&#47; class_addMethod 添加要替换的方法<br>    class_addMethod(delegate.class, toSelector, method_getImplementation(toMethod), method_getTypeEncoding(toMethod));<br>    Method hookMethod = class_getInstanceMethod(delegate.class, toSelector);<br>    method_exchangeImplementations(fromMethod, hookMethod);<br>    <br>}<br><br>-(void)sm_tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {<br>    NSLog(@&quot;aaa&quot;);<br>    [self sm_tableView:tableView didSelectRowAtIndexPath:indexPath];<br>}<br><br><br>@end<br>```","like_count":3,"discussions":[{"author":{"id":2382667,"avatar":"","nickname":"文培定","note":"","ucode":"A13E83C4FFDEBC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373879,"discussion_content":"调试发现setdelegate调用了两次，所以这里也需要dispatch_once:\n (void)swDelegate:(id <UITableViewDelegate>) delegate{\n    [self swDelegate:delegate];\n    NSLog(@&#34;swDelegate&#34;);\n    \n    static dispatch_once_t once_token;\n    dispatch_once(&amp;once_token, ^{\n        SEL fromSelector = @selector(tableView:didSelectRowAtIndexPath:);\n        SEL toSelector = @selector(sw_tableView:didSelectRowAtIndexPath:);\n        \n        Method fromMethod = class_getInstanceMethod(delegate.class, fromSelector);\n        Method toMethod = class_getInstanceMethod(self.class, toSelector);\n\n        class_addMethod(delegate.class, toSelector, method_getImplementation(toMethod), method_getTypeEncoding(toMethod));\n        Method hookMethod = class_getInstanceMethod(delegate.class, toSelector);\n        method_exchangeImplementations(fromMethod, hookMethod);\n        \n    });\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620902472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240497,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/b1/0a4df685.jpg","nickname":"L_m","note":"","ucode":"EDC8F36E292336","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357830,"discussion_content":"请问外部如果多次设置delegate，didSelect不是又回换回来了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615877884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1456751,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3a/6f/6ae4bcfd.jpg","nickname":"麦子","note":"","ucode":"160838EC0CED4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201715,"discussion_content":"您这个是有侵入的埋点方式了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583829581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1471806,"avatar":"https://static001.geekbang.org/account/avatar/00/16/75/3e/71b16443.jpg","nickname":"Struggle","note":"","ucode":"C769D8FFD9C1B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1456751,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3a/6f/6ae4bcfd.jpg","nickname":"麦子","note":"","ucode":"160838EC0CED4F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271021,"discussion_content":"啊？ 无侵入吧这个\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590073382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":201715,"ip_address":""},"score":271021,"extra":""},{"author":{"id":2263862,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8b/36/958d1837.jpg","nickname":"彩色石头","note":"","ucode":"9C205C5244D64D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1456751,"avatar":"https://static001.geekbang.org/account/avatar/00/16/3a/6f/6ae4bcfd.jpg","nickname":"麦子","note":"","ucode":"160838EC0CED4F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320811,"discussion_content":"无侵入也只是针对业务层来说，并不是说不增加代码；他这个是无侵入的，和课程举得例子很类似","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604483709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":201715,"ip_address":""},"score":320811,"extra":""}]}]},{"had_liked":false,"id":82099,"user_name":"元","can_delete":false,"product_type":"c1","uid":1460708,"ip_address":"","ucode":"A9027950494C1D","user_header":"https://static001.geekbang.org/account/avatar/00/16/49/e4/d476bd8c.jpg","comment_is_top":false,"comment_ctime":1554119908,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14439021796","product_id":100024501,"comment_content":"编程过程中还是尽量少用runtime，不能作为优先选择的方案，不然工程对程序员的要求会越来越高。","like_count":3,"discussions":[{"author":{"id":2067646,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8c/be/eeda0ed0.jpg","nickname":"我爱钢铁侠！","note":"","ucode":"C1AFF814B18BDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291777,"discussion_content":"这是什么奇怪的想法？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594951882,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1961314,"avatar":"","nickname":"0770","note":"","ucode":"CC55AB48F23C3E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2067646,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8c/be/eeda0ed0.jpg","nickname":"我爱钢铁侠！","note":"","ucode":"C1AFF814B18BDE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320511,"discussion_content":"团队初级程序员很多的时候，这样的想法就会有了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604386663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291777,"ip_address":""},"score":320511,"extra":""}]},{"author":{"id":1823275,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/d2/2b/7a93d588.jpg","nickname":"低调的魅力","note":"","ucode":"AE5CA2986B5A95","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553252,"discussion_content":"runtime很难吗？不就是调用接口吗。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645785194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182753,"user_name":"Geek_96040c","can_delete":false,"product_type":"c1","uid":1676890,"ip_address":"","ucode":"BFD6F1B277F647","user_header":"","comment_is_top":false,"comment_ctime":1582860174,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10172794766","product_id":100024501,"comment_content":"老师，想问您一下，Swift如何做无埋点？","like_count":2,"discussions":[{"author":{"id":2061978,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/76/9a/d26031bc.jpg","nickname":"MINT🍀","note":"","ucode":"ED50ED615749B7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363476,"discussion_content":"一样的，建议疯狂魔改神策开源的无侵入埋点。哈哈哈哈改一路骂一路。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617202039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1454049,"avatar":"https://static001.geekbang.org/account/avatar/00/16/2f/e1/efc15eb1.jpg","nickname":"liaoing","note":"","ucode":"EF6F64650EAA9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":224494,"discussion_content":"我们项目还是用oc桥接来做的埋点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586311175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94399,"user_name":"Geek_麟凤来思","can_delete":false,"product_type":"c1","uid":1457551,"ip_address":"","ucode":"7ADF5585765A42","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/8f/4d1ffc7f.jpg","comment_is_top":false,"comment_ctime":1557801105,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10147735697","product_id":100024501,"comment_content":"老师，能每篇做个demo吗？只说没具体实现，还是不会啊！","like_count":2,"discussions":[{"author":{"id":1467400,"avatar":"","nickname":"Geek_ea2f98","note":"","ucode":"FA715D80F5BBB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328,"discussion_content":"老师写的代码，估计大量运用了底层的东西，可能看代码也有点复杂哟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561452429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82405,"user_name":"家有萌柴fries","can_delete":false,"product_type":"c1","uid":1048179,"ip_address":"","ucode":"EE96CBDF30E99C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/73/7c56ed19.jpg","comment_is_top":false,"comment_ctime":1554202314,"is_pvip":false,"replies":[{"id":"29892","content":"会的","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1554285563,"ip_address":"","comment_id":82405,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10144136906","product_id":100024501,"comment_content":"“我倒是觉得使用 Clang AST 的接口，在构建时遍历在构建时遍历 AST，通过定义的规则将所需要的埋点代码直接加”，这个会在之后的文章再具体介绍介绍么？","like_count":2,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445579,"discussion_content":"会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554285563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81769,"user_name":"追想画廊","can_delete":false,"product_type":"c1","uid":1454690,"ip_address":"","ucode":"44F1F7CDA185B7","user_header":"https://static001.geekbang.org/account/avatar/00/16/32/62/09735a2c.jpg","comment_is_top":false,"comment_ctime":1554030790,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10143965382","product_id":100024501,"comment_content":"课后作业 hook tableView: didSelectRowAtIndexPath:就好了 不过得hook NSObject这种基类 <br>需要注意的是为了避免其他类出现的同名的方法 还得判断一下 tableView是不是UITableView的子类","like_count":2},{"had_liked":false,"id":105443,"user_name":"白浩泉","can_delete":false,"product_type":"c1","uid":1456681,"ip_address":"","ucode":"B884A2B813762A","user_header":"https://static001.geekbang.org/account/avatar/00/16/3a/29/2cf8f516.jpg","comment_is_top":false,"comment_ctime":1561001367,"is_pvip":false,"replies":[{"id":"38597","content":"Clang AST 不是运行时的，静态可以通过代码级逻辑精准控制","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1561387090,"ip_address":"","comment_id":105443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5855968663","product_id":100024501,"comment_content":"戴老师您好，我理解Clang AST类似的插装技术只是解决了hook的问题，在添加埋点代码的时候一样要解决view唯一标识的问题，目前最大的问题就是没法找到一个稳定的view标识 望解答，谢谢！","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454686,"discussion_content":"Clang AST 不是运行时的，静态可以通过代码级逻辑精准控制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561387090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":84623,"user_name":"🐰先生","can_delete":false,"product_type":"c1","uid":1456447,"ip_address":"","ucode":"DF74D705496928","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/3f/26210f39.jpg","comment_is_top":false,"comment_ctime":1554886917,"is_pvip":false,"replies":[{"id":"30723","content":"关键是 tag 映射说明表的维护成本还是有的","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1555140187,"ip_address":"","comment_id":84623,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5849854213","product_id":100024501,"comment_content":"给button 或者其他View 埋点的时候，可不可以通过给这个Button设置 Tag值，来达到唯一标识的目的","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":446407,"discussion_content":"关键是 tag 映射说明表的维护成本还是有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1555140187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2022825,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/dd/a9/b2aad3b0.jpg","nickname":"Andy","note":"","ucode":"3DCE688BC2305E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":276251,"discussion_content":"而且逐个设置 tag，也是一种侵入吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590846646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82726,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1455709,"ip_address":"","ucode":"8F54852E0A95C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/36/5d/f73cc877.jpg","comment_is_top":false,"comment_ctime":1554287784,"is_pvip":false,"replies":[{"id":"29900","content":"1.subviews 遍历索引<br>2.在后台标注，可以配合测试过程中上传截图做匹配。","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1554301256,"ip_address":"","comment_id":82726,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5849255080","product_id":100024501,"comment_content":"有两个问题请教：<br>1.事件唯一标识：子视图在父视图中的索引怎么获取<br>2.统计到数据后怎么根据这个事件唯一标识分析数据，大数据分析师怎么知道这个唯一标识是哪个业务按钮或业务事件","like_count":1,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445702,"discussion_content":"1.subviews 遍历索引\n2.在后台标注，可以配合测试过程中上传截图做匹配。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554301256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358465,"user_name":"思成","can_delete":false,"product_type":"c1","uid":2273777,"ip_address":"福建","ucode":"57D23C9467E59A","user_header":"https://static001.geekbang.org/account/avatar/00/22/b1/f1/2cdde841.jpg","comment_is_top":false,"comment_ctime":1664336008,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664336008","product_id":100024501,"comment_content":"+load方法不是只会调用一次吗，为什么里面还要用dispatch_once ","like_count":0},{"had_liked":false,"id":294626,"user_name":"Geek_474d69","can_delete":false,"product_type":"c1","uid":1523323,"ip_address":"","ucode":"FF162456D85B16","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJQjaibDIKHPj2zdJdZu0JIQlia3Na0iblq7wsG9qOmXI36JMW48icckJbkFjBskS16kOn7r2aCF1rULw/132","comment_is_top":false,"comment_ctime":1622023642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622023642","product_id":100024501,"comment_content":"你好老师，请问swift项目的话有什么好的埋点方案呢？","like_count":0},{"had_liked":false,"id":209537,"user_name":"枫林","can_delete":false,"product_type":"c1","uid":1236190,"ip_address":"","ucode":"6BB5534162CBDB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xVcA2wzqLYZaeTo7cSA2k3cJVylT3sibmcauzQRUVpJqfxkIJetkCUV7iaVWQuSuCSBICV2AfF2AS5xl1Fgo0pcw/132","comment_is_top":false,"comment_ctime":1587565054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587565054","product_id":100024501,"comment_content":"+ (void)load {<br>    void (^Block)(id, SEL, id) = ^(id tableview, SEL cmd, id delegate) {<br>        if ([delegate respondsToSelector:@selector(tableView:didSelectRowAtIndexPath:)]) {<br>            void (^tableViewBlock)(id, SEL, id, id) = ^(id view, SEL command, UITableView *tableView, NSIndexPath *indexPath) {<br>                NSLog(@&quot;-&gt; %zd_%zd&quot;,indexPath.section, indexPath.row);<br>            };<br>            &#47;&#47; hook ‘-tableview:didSelectRowAtIndexPath:’<br>            [SASwizzler swizzleSelector:@selector(tableView:didSelectRowAtIndexPath:) onClass:[delegate class] withBlock:tableViewBlock named:@&quot;trackTableView&quot;];<br>        }<br>    };<br>    &#47;&#47; hook delegate<br>    [SASwizzler swizzleSelector:@selector(setDelegate:) onClass:[self class] withBlock:Block named:@&quot;UITableView&quot;  ];<br>}","like_count":0},{"had_liked":false,"id":151779,"user_name":"木昜","can_delete":false,"product_type":"c1","uid":1460998,"ip_address":"","ucode":"0244408219F7F8","user_header":"https://static001.geekbang.org/account/avatar/00/16/4b/06/de6df7e4.jpg","comment_is_top":false,"comment_ctime":1573790479,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573790479","product_id":100024501,"comment_content":"老师，问一下，针对tap手势进行作业时，先hook掉initwithtarget方法，然后再交换传递进来的action方法，那么针对vc里面添加了多个Ges对应的action操作，怎么保证action和我们写的swizzle_action是一一对应的…就是ac1对应swizzle_ac1，ac2对应swizzle_ac2，能动态实现吗？根据外界传入不同的action，生成不同的swizzle_ac……求指点","like_count":0},{"had_liked":false,"id":131230,"user_name":"Baan","can_delete":false,"product_type":"c1","uid":1458782,"ip_address":"","ucode":"7F45FA71BD2D0C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqgOhFt6gicfcyhIW871VmmBribmianxqd5K9iaUe6b0vvcS8zFzLMtG9v7ELkfPRhQlMeW5TjJ6mKq6w/132","comment_is_top":false,"comment_ctime":1567675765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567675765","product_id":100024501,"comment_content":"学到了","like_count":0},{"had_liked":false,"id":126367,"user_name":"Swift_yong","can_delete":false,"product_type":"c1","uid":1260782,"ip_address":"","ucode":"19AE116EB7BCF0","user_header":"https://static001.geekbang.org/account/avatar/00/13/3c/ee/18f48590.jpg","comment_is_top":false,"comment_ctime":1566373485,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566373485","product_id":100024501,"comment_content":"看了好多， Clang 编译层面的东西不会写， 我太难了， 感觉找不到学习这部分的入口一样","like_count":0},{"had_liked":false,"id":98588,"user_name":"景天儿","can_delete":false,"product_type":"c1","uid":1018983,"ip_address":"","ucode":"1A5EFE9DE2597B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/67/e91fe8d3.jpg","comment_is_top":false,"comment_ctime":1559035770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1559035770","product_id":100024501,"comment_content":"正好我们也做了无侵入埋点的组件，有几点收获和体会说一下。<br>1. 点击事件，通过touch.tapCount==1 &amp;&amp; event.allTouches.count==1，可以进一步降低日志数<br>2. 点击事件的唯一标示挺有启发的<br>另外，有个问题是，对于child controller方式实现的类似头条版块的界面，每个板块的进入和退出，有可能实现无侵入埋点吗？","like_count":0},{"had_liked":false,"id":96035,"user_name":"daniel","can_delete":false,"product_type":"c1","uid":1370456,"ip_address":"","ucode":"3516AF7F9A4DEA","user_header":"https://static001.geekbang.org/account/avatar/00/14/e9/58/397a4ab2.jpg","comment_is_top":false,"comment_ctime":1558314861,"is_pvip":false,"replies":[{"id":"35010","content":"我在答疑4里专门说下","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1558846796,"ip_address":"","comment_id":96035,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1558314861","product_id":100024501,"comment_content":"SMLogger怎么实现。。这里没讲吗","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":450686,"discussion_content":"我在答疑4里专门说下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558846796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":94679,"user_name":"zhuge","can_delete":false,"product_type":"c1","uid":1454644,"ip_address":"","ucode":"B950491F9C1F03","user_header":"https://static001.geekbang.org/account/avatar/00/16/32/34/076046ca.jpg","comment_is_top":false,"comment_ctime":1557881955,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557881955","product_id":100024501,"comment_content":"觉得对唯一表示的讲述还不够满足产品和数据分析方的要求。没有人比开发更了解自己写了啥。所以这种对照表更多还是由开发自己维护，需求方提供需求，开发提供对照关系。采用类似URI的路径标示控件唯一性可能更加实用。但是对开发的描述水平有一定要求，不然可能看不太懂","like_count":0},{"had_liked":false,"id":91621,"user_name":"mrchen","can_delete":false,"product_type":"c1","uid":1453541,"ip_address":"","ucode":"A1D1767CAB0243","user_header":"https://static001.geekbang.org/account/avatar/00/16/2d/e5/d32e602b.jpg","comment_is_top":false,"comment_ctime":1557062103,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557062103","product_id":100024501,"comment_content":"一个按钮点击时间，如果需要统计在各种业务状态下的点击事件，这种是不是感觉做不到。如果把状态放后台分析是不是不太合适。","like_count":0},{"had_liked":false,"id":89490,"user_name":"青冈","can_delete":false,"product_type":"c1","uid":1080446,"ip_address":"","ucode":"8E54B939937E6D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoYBX95GZxEdKz9LQJVwohUiaRxNge5WpHRbeOC2tGc2rsdpfYKCTKdQicBn8MvSrlZTX7HY2jS3YFA/132","comment_is_top":false,"comment_ctime":1556184391,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556184391","product_id":100024501,"comment_content":"bugly的实现原理也是hook方法么？要是我也hook的话，那是不就可能hook冲突？","like_count":0},{"had_liked":false,"id":87207,"user_name":"Tony","can_delete":false,"product_type":"c1","uid":1455102,"ip_address":"","ucode":"D44982C4AF06D3","user_header":"https://static001.geekbang.org/account/avatar/00/16/33/fe/b30a2d3e.jpg","comment_is_top":false,"comment_ctime":1555548007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555548007","product_id":100024501,"comment_content":"性能怎么样呢？","like_count":0},{"had_liked":false,"id":86967,"user_name":"Geek__7610d3f0e3f8","can_delete":false,"product_type":"c1","uid":1454467,"ip_address":"","ucode":"21BC66C605E07E","user_header":"","comment_is_top":false,"comment_ctime":1555488667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555488667","product_id":100024501,"comment_content":"有关手势事件埋点，你说的是hook init(target:action)方法，如果调用者是通过gesture.add(target:action)方式添加，你能监听到相关手势嘛？能否hook UIView的addgesture方法呢？<br>","like_count":0},{"had_liked":false,"id":86169,"user_name":"hao","can_delete":false,"product_type":"c1","uid":1455940,"ip_address":"","ucode":"174B855F3768CE","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/44/6a0b759f.jpg","comment_is_top":false,"comment_ctime":1555318880,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555318880","product_id":100024501,"comment_content":"而实际情况是，业务复杂的 App 轻轻松松就超过了 60MB。虽然我们可以通过静态库转动态库的方式来快速避免这个限制，但是静态库转动态库后，动态库的大小差不多会增加一倍，这样 150MB 的限制就更难守住。<br><br>提问：这句话的理解是，使用动态库会增大安装包体积？<br><br>能解答一下吗","like_count":0},{"had_liked":false,"id":82719,"user_name":"宇文","can_delete":false,"product_type":"c1","uid":1455782,"ip_address":"","ucode":"985C1E1C028F54","user_header":"https://static001.geekbang.org/account/avatar/00/16/36/a6/f3003aa8.jpg","comment_is_top":false,"comment_ctime":1554284361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554284361","product_id":100024501,"comment_content":"这种方法并不能兜住所有的场景，实际开发中，可能还会要求一个Event事件关联不同的状态值，运营和产品也不会通过view Path去分析用户行为，同时还得考虑两端的开发","like_count":0},{"had_liked":false,"id":82433,"user_name":"自由无用","can_delete":false,"product_type":"c1","uid":1457440,"ip_address":"","ucode":"33479BF0BAF11F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epsMTPfFsbEVMsCYocUufOpricictCts1ZqOG46vWuM6I8eklzYlib6pCKmLbc9MrXnzmgj0CibtOz0aw/132","comment_is_top":false,"comment_ctime":1554210543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554210543","product_id":100024501,"comment_content":"控件复用就不好弄了，还是手动老实点比较好","like_count":0},{"had_liked":false,"id":82134,"user_name":"三件事","can_delete":false,"product_type":"c1","uid":1055819,"ip_address":"","ucode":"BCC867C8961A24","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/4b/2e5df06f.jpg","comment_is_top":false,"comment_ctime":1554128351,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554128351","product_id":100024501,"comment_content":"老师可否总结讲解一下实现一个埋点SDK库的设计思路和主要的问题？","like_count":0},{"had_liked":false,"id":82019,"user_name":"李乾坤David","can_delete":false,"product_type":"c1","uid":1454334,"ip_address":"","ucode":"295D0234582979","user_header":"https://static001.geekbang.org/account/avatar/00/16/30/fe/fc686f23.jpg","comment_is_top":false,"comment_ctime":1554104582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554104582","product_id":100024501,"comment_content":"load方法不是会增加启动时间吗？","like_count":0},{"had_liked":false,"id":81971,"user_name":"陈庆明","can_delete":false,"product_type":"c1","uid":1455463,"ip_address":"","ucode":"DC248FEAF6F7DA","user_header":"https://static001.geekbang.org/account/avatar/00/16/35/67/a5f7d3ba.jpg","comment_is_top":false,"comment_ctime":1554092640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554092640","product_id":100024501,"comment_content":"在 `- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath` 方法中打个断点，然后观察调用栈会发现在调用该方法是由一个私有方法 `-[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:]` 调用的(没有严谨调查过，不确定有没有其它条件分支，假设都是由该方法调用的)，那么就可以通过 `[SMHook hookClass:self fromSelector:@selector(_selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:) toSelector:@selector(...)];` 给 Cell 点击事件埋点了。但有个问题就是不确定 `-[UITableView _selectRowAtIndexPath:animated:scrollPosition:notifyDelegate:]` 的参数类型和返回类型，可以通过 runtime 的 `method_getTypeEncoding` 方法获取到该方法的参数类型描述为 &quot;v40@0:8@16B24q28B36&quot;，也就是 &quot;v40(Void) @0(self) :8(SEL) B24(BOOL) q28(enum) B36(BOOL)&quot;，所以 `- (void)hook_selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)position notifyDelegate:(BOOL)notifyDelegate`","like_count":0},{"had_liked":false,"id":81916,"user_name":"痞子胡","can_delete":false,"product_type":"c1","uid":1471412,"ip_address":"","ucode":"4A8751A1A522DB","user_header":"https://static001.geekbang.org/account/avatar/00/16/73/b4/afcf095e.jpg","comment_is_top":false,"comment_ctime":1554082513,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554082513","product_id":100024501,"comment_content":"之前有做过无痕埋点的技术探究。利用这种方案，hook之后和业务数据的绑定其实也需要很大的改造，相比于传统的打点方案有更多的坑需要去解决。","like_count":0},{"had_liked":false,"id":81842,"user_name":"Geek_304562","can_delete":false,"product_type":"c1","uid":1455992,"ip_address":"","ucode":"404DFC9F130CD2","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/78/e2a21f66.jpg","comment_is_top":false,"comment_ctime":1554048034,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554048034","product_id":100024501,"comment_content":"戴老师，有个关键技术需要请教下你。就是hook 手势，你在文章里面简单的进行了介绍，有没有实例呀。 我做的总是崩溃。而且错误看不懂","like_count":0},{"had_liked":false,"id":81687,"user_name":"GODV","can_delete":false,"product_type":"c1","uid":1454163,"ip_address":"","ucode":"DB311A5D9EE770","user_header":"https://static001.geekbang.org/account/avatar/00/16/30/53/01a6c4da.jpg","comment_is_top":false,"comment_ctime":1554007135,"is_pvip":false,"replies":[{"id":"29814","content":"会的","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1554199379,"ip_address":"","comment_id":81687,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1554007135","product_id":100024501,"comment_content":"戴老师，后面会有动画讲解吗，比如经典的第三方POP介绍。","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445299,"discussion_content":"会的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554199379,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81509,"user_name":"文盲","can_delete":false,"product_type":"c1","uid":1012495,"ip_address":"","ucode":"C0CC0CAFADD41A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/73/0f/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1553930453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553930453","product_id":100024501,"comment_content":"之前用过plist 去埋点。发现两个问题 。第一 就是 加载plist 会影响到启动速度。第二。这个如果进行代码修改。那真的是恶心了。后来我们改成了keypath的方式。用分类去记录业务数据。","like_count":0},{"had_liked":false,"id":81396,"user_name":"小飞侠","can_delete":false,"product_type":"c1","uid":1455353,"ip_address":"","ucode":"93A34A9DCD7E01","user_header":"https://static001.geekbang.org/account/avatar/00/16/34/f9/c6c1dbe1.jpg","comment_is_top":false,"comment_ctime":1553902395,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553902395","product_id":100024501,"comment_content":"我的做法是写个plist文件，文件中记录类名、函数名和埋点值。利用runtime插入埋点。这样做plist文件维护确实是个问题，还有就是碰到作者说的不好区分问题比较难解决。感觉作者说的利用Clang解决思路很好，学习学习","like_count":0},{"had_liked":false,"id":81395,"user_name":"skywalker","can_delete":false,"product_type":"c1","uid":1453861,"ip_address":"","ucode":"2BBCC9D6562F5D","user_header":"https://static001.geekbang.org/account/avatar/00/16/2f/25/2d2cc1c5.jpg","comment_is_top":false,"comment_ctime":1553902379,"is_pvip":false,"replies":[{"id":"29496","content":"自己的数据需要搭建服务器来收集","user_name":"作者回复","user_name_real":"戴铭","uid":"1140280","ctime":1553913030,"ip_address":"","comment_id":81395,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1553902379","product_id":100024501,"comment_content":"不好意思，问个问题，一直用的百度统计，如果我们代码手动加埋点，后期在哪看数据呢？通过调用接口在自己服务器后台看嘛？","like_count":0,"discussions":[{"author":{"id":1140280,"avatar":"https://static001.geekbang.org/account/avatar/00/11/66/38/f9999b2b.jpg","nickname":"戴铭","note":"","ucode":"D61E685F962387","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445179,"discussion_content":"自己的数据需要搭建服务器来收集","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553913030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81392,"user_name":"CoderJJMa","can_delete":false,"product_type":"c1","uid":1199251,"ip_address":"","ucode":"9A16138343D733","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/93/28bbf22e.jpg","comment_is_top":false,"comment_ctime":1553900327,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553900327","product_id":100024501,"comment_content":"板凳","like_count":0},{"had_liked":false,"id":81389,"user_name":"李凯","can_delete":false,"product_type":"c1","uid":1456082,"ip_address":"","ucode":"834970D9BA21A5","user_header":"https://static001.geekbang.org/account/avatar/00/16/37/d2/24c81feb.jpg","comment_is_top":false,"comment_ctime":1553890673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553890673","product_id":100024501,"comment_content":"抢个沙发","like_count":0}]}