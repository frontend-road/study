{"id":820960,"title":"33｜ InnoDB锁定和死锁问题：为什么我的SQL锁超时了？","content":"<p>你好，我是俊达。</p><p>这一讲我们来聊一聊MySQL中的锁。MySQL中，存在很多不同类型的锁，我们先来大致了解下不同锁的作用。</p><h2>MySQL中的锁</h2><p>MySQL使用锁来控制多个并发的进程或线程对共享资源的访问。那么在MySQL中，有哪些共享资源呢？</p><p>我总结起来，大致有下面这几种类型。</p><ul>\n<li>\n<p>内存中的数据结构。</p>\n<ul>\n<li>\n<p>内存中的链表结构，如会话列表、活跃事务列表、InnoDB Buffer Pool 中LRU链表、Flush链表、Hash链表等等。</p>\n</li>\n<li>\n<p>内存中的变量，如REDO日志序列号、下一个事务的事务ID。</p>\n</li>\n<li>\n<p>缓存的页面。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>元数据，包括表、SCHEMA、存储过程等。</p>\n</li>\n<li>\n<p>表和表里的记录。</p>\n</li>\n</ul><p>MySQL使用了不同类型的锁，来保护这些不同类型的共享资源，对于上面提到的这几类资源，MySQL分别使用了下面这些类型的锁。</p><ul>\n<li>\n<p>mutex和rw-lock，用于保护内存中的数据结构。使用show engine innodb status、show engine innodb mutex等命令可以查看到一些mutex的信息。</p>\n</li>\n<li>\n<p>元数据锁（metadata lock），用于管理对数据库对象的并发访问。查询数据（Select）、修改数据（insert、update、delete）、修改表结构时都需要先获取表的元数据锁。</p>\n</li>\n</ul><!-- [[[read_end]]] --><p>ProcessList中，状态为“Waiting for table metadata lock”的线程就是在等待元数据锁。</p><pre><code class=\"language-plain\">mysql&gt; show processlist\\G\n\n     Id: 396\n   User: root\n   Host: localhost:41640\n     db: rep\nCommand: Query\n   Time: 81\n  State: Waiting for table metadata lock\n   Info: alter table tx add ccc int\n</code></pre><p>可以通过performance_schema.metadata_locks表来查看元数据锁的请求状态。</p><pre><code class=\"language-plain\">mysql&gt; select object_type, object_name, lock_type, lock_duration, lock_status \n    from performance_schema.metadata_locks;\n+-------------+----------------+---------------------+---------------+-------------+\n| object_type | object_name    | lock_type           | lock_duration | lock_status |\n+-------------+----------------+---------------------+---------------+-------------+\n| TABLE       | tx             | SHARED_READ         | TRANSACTION   | GRANTED     |\n| GLOBAL      | NULL           | INTENTION_EXCLUSIVE | STATEMENT     | GRANTED     |\n| BACKUP LOCK | NULL           | INTENTION_EXCLUSIVE | TRANSACTION   | GRANTED     |\n| SCHEMA      | NULL           | INTENTION_EXCLUSIVE | TRANSACTION   | GRANTED     |\n| TABLE       | tx             | SHARED_UPGRADABLE   | TRANSACTION   | GRANTED     |\n| TABLESPACE  | rep/tx         | INTENTION_EXCLUSIVE | TRANSACTION   | GRANTED     |\n| TABLE       | #sql-553c_18c  | EXCLUSIVE           | STATEMENT     | GRANTED     |\n| TABLE       | tx             | EXCLUSIVE           | TRANSACTION   | PENDING     |\n| TABLE       | metadata_locks | SHARED_READ         | TRANSACTION   | GRANTED     |\n+-------------+----------------+---------------------+---------------+-------------+\n</code></pre><ul>\n<li>InnoDB存储引擎的表锁和记录锁，用于管理事务对表和记录的并发访问。平时我们使用MySQL遇到的锁超时（Lock wait timeout exceeded）或死锁（Deadlock found when trying to get lock），大部分情况下和InnoDB的表锁或行锁有关。</li>\n</ul><p>接下来，我们来看看InnoDB中的表锁和记录锁。</p><h2>InnoDB锁的类型</h2><p>InnoDB中的锁，还可以分为表锁、意向锁、行锁和自增ID锁。这些锁都是内存中的结构，可以在performance_schema库中的data_locks表和data_lock_waits表中查看当前系统中有哪些锁，以及锁等待关系。后续我们会使用这两个表来观察不同情况下锁的情况。我把这两个表字段的含义整理在了下面两个表格中。</p><ul>\n<li>data_locks表</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/2b/4a/2b7ee784c3a7yyb7b95355167902284a.jpg?wh=1920x2573\" alt=\"图片\"></p><ul>\n<li>data_lock_waits</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/c7/c7/c74d6d5ebd7e39085a496b46234d73c7.png?wh=1700x1304\" alt=\"图片\"></p><h3>表锁</h3><p>表锁通过lock tables命令获取。需要注意的是，只有关闭会话的自动提交（set autocommit=0）后，执行lock tables命令才会获取InnoDB层的表锁。在data_locks表中，表锁LOCK_TYPE为TABLE，LOCK_MODE为X或S。</p><p>lock tables命令会在MySQL层和InnoDB层会分别对表加锁。InnoDB层的表锁会在事务提交时释放，MySQL层的元数据锁会在执行unlock tables命令后释放。当然，会话退出时，也会释放元数据锁。</p><pre><code class=\"language-plain\">mysql&gt; set autocommit=0;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; lock table t1 read, t2 write;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select engine, object_schema, object_name, lock_type, lock_mode \n  from data_locks;\n+--------+---------------+-------------+-----------+-----------+\n| engine | object_schema | object_name | lock_type | lock_mode |\n+--------+---------------+-------------+-----------+-----------+\n| INNODB | rep           | t2          | TABLE     | X         |\n| INNODB | rep           | t1          | TABLE     | S         |\n+--------+---------------+-------------+-----------+-----------+\n\nmysql&gt; select object_type, object_name, lock_type, lock_status  \n  from metadata_locks;\n+-------------+----------------+----------------------+-------------+\n| object_type | object_name    | lock_type            | lock_status |\n+-------------+----------------+----------------------+-------------+\n| GLOBAL      | NULL           | INTENTION_EXCLUSIVE  | GRANTED     |\n| SCHEMA      | NULL           | INTENTION_EXCLUSIVE  | GRANTED     |\n| TABLE       | t1             | SHARED_READ_ONLY     | GRANTED     |\n| TABLE       | t2             | SHARED_NO_READ_WRITE | GRANTED     |\n| TABLESPACE  | rep/t2         | INTENTION_EXCLUSIVE  | GRANTED     |\n| TABLE       | metadata_locks | SHARED_READ          | GRANTED     |\n+-------------+----------------+----------------------+-------------+\n</code></pre><p>一个会话以读的模式锁定一个表后，只能执行查询操作，不能修改数据，修改数据时会错“Table xxx was locked with a READ lock and can’t be updated”。其他会话可以查询这个表的数据，但是无法修改数据。</p><p>一个会话以写的模式锁定一个表后，其他会话无法查询或修改这个表的数据。</p><p>表锁在业务系统中可能比较少用。使用mysqldump备份数据时，如果不加skip-lock-tables或single-transaction参数，会使用lock tables锁表。</p><h3>意向锁</h3><p>InnoDB给表中的记录加锁时，需要先获取表级别的意向锁。如果对记录加X模式的锁，那么意向锁的模式是IX，如果对记录加S模式的锁，那么意向锁的模式为IS。在data_locks表中，InnoDB意向锁的lock_type为TABLE，lock_mode为IS或IX。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from t1 for share;\nEmpty set (0.00 sec)\n\nmysql&gt; select * from t2 for update;\nEmpty set (0.00 sec)\n\nmysql&gt; mysql&gt; select object_schema, object_name, lock_type, lock_mode, lock_data    from data_locks order by lock\n_mode, object_name;\n+---------------+-------------+-----------+-----------+------------------------+\n| object_schema | object_name | lock_type | lock_mode | lock_data              |\n+---------------+-------------+-----------+-----------+------------------------+\n| rep           | t1          | TABLE     | IS        | NULL                   |\n| rep           | t2          | TABLE     | IX        | NULL                   |\n| rep           | t1          | RECORD    | S         | supremum pseudo-record |\n| rep           | t2          | RECORD    | X         | supremum pseudo-record |\n+---------------+-------------+-----------+-----------+------------------------+\n</code></pre><p>InnoDB为什么要使用意向锁呢？</p><p>考虑这么一种情况，会话1锁定了表tab中的一行数据，在会话1提交前，会话2想使用lock tables命令锁住tab表。如果没有意向锁，InnoDB怎么判断会话2能不能获取到这个表锁呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/11/25/11e0a33659c8fcb17c25e1784bc51b25.png?wh=1772x552\" alt=\"图片\"></p><p>不过实际上，在上面这个场景中，MySQL使用了元数据锁。从Processlist中可以发现会话2的状态是“Waiting for table metadata lock”，从metadata_locks表也可以查到会话2在等待元数据锁。</p><pre><code class=\"language-plain\">select object_type, object_name, lock_type, lock_status     \n  from metadata_locks where object_name='tab';\n+-------------+-------------+------------------+-------------+\n| object_type | object_name | lock_type        | lock_status |\n+-------------+-------------+------------------+-------------+\n| TABLE       | tab         | SHARED_WRITE     | GRANTED     |\n| TABLE       | tab         | SHARED_READ_ONLY | PENDING     |\n+-------------+-------------+------------------+-------------+\n</code></pre><h3>记录锁（行锁）</h3><p>MySQL执行普通的Select语句时，并不会对记录加锁，只有执行insert、update、delete时，或者执行select for share、select for update时，才会加锁。对哪些记录加锁及锁的模式跟事务的隔离级别、执行的SQL语句、语句的执行计划相关，这里的情况比较多，接下来我们分别讨论。先准备测试表和测试数据。</p><pre><code class=\"language-plain\">create table test_lock(\n    id varchar(10) not null, \n    a varchar(10) ,\n    b varchar(10) not null, \n    c varchar(10) not null, \n    d int,\n    primary key(id), \n    unique key uk_ac(a,c), \n    key idx_b(b));\n\n\ninsert into test_lock(id,a,b,c,d) values \n    ('pk10','a10','b10','c10',10),\n    ('pk20','a20','b20','c20',20),\n    ('pk30','a30','b30','c30',30);\n</code></pre><p>InnoDB中的行锁，又可以细分为记录锁、GAP锁、Next-Key锁、插入意向锁。接下来我们通过一些具体的例子来演示这些锁。</p><h4>1. 记录锁</h4><p>当事务的隔离级别为READ COMMITTED，或使用唯一索引或主键以等值条件匹配时，只锁定记录，不锁定记录前的间隙（GAP）。记录锁的lock_type为RECORD，lock_mode为“X,REC_NOT_GAP”或“S,REC_NOT_GAP”。</p><ul>\n<li>read commited隔离模式下，只需要获取记录上的锁，不需要锁记录间的GAP。</li>\n</ul><pre><code class=\"language-plain\">mysql&gt; set transaction isolation level read committed;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from test_lock where b='b20' for update;\n+------+------+-----+-----+------+\n| id   | a    | b   | c   | d    |\n+------+------+-----+-----+------+\n| pk20 | a20  | b20 | c20 |   20 |\n+------+------+-----+-----+------+\n1 row in set (0.01 sec)\n\nmysql&gt; select object_name, index_name, lock_type, lock_mode, lock_data \n  from data_locks order by  object_name;\n+-------------+------------+-----------+---------------+---------------+\n| object_name | index_name | lock_type | lock_mode     | lock_data     |\n+-------------+------------+-----------+---------------+---------------+\n| test_lock   | NULL       | TABLE     | IX            | NULL          |\n| test_lock   | idx_b      | RECORD    | X,REC_NOT_GAP | 'b20', 'pk20' |\n| test_lock   | PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk20'        |\n+-------------+------------+-----------+---------------+---------------+\n</code></pre><p>上面这个例子中，使用了索引idx_b，获取了索引idx_b上记录（b20, pk20）和主键pk20的记录锁，注意lock_mode中有REC_NOT_GAP。</p><ul>\n<li>repeatable read隔离模式下，使用主键或唯一索引的等值查询，获取的是记录锁。</li>\n</ul><pre><code class=\"language-plain\">mysql&gt; set transaction isolation level repeatable read;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from test_lock where a='a20' and c='c20' for update;\n+------+------+-----+-----+------+\n| id   | a    | b   | c   | d    |\n+------+------+-----+-----+------+\n| pk20 | a20  | b20 | c20 |   20 |\n+------+------+-----+-----+------+\n1 row in set (0.00 sec)\n\n\nmysql&gt; select object_name, index_name, lock_type, lock_mode, lock_data from data_locks order by  object_name;\n+-------------+------------+-----------+---------------+----------------------+\n| object_name | index_name | lock_type | lock_mode     | lock_data            |\n+-------------+------------+-----------+---------------+----------------------+\n| test_lock   | NULL       | TABLE     | IX            | NULL                 |\n| test_lock   | uk_ac      | RECORD    | X,REC_NOT_GAP | 'a20', 'c20', 'pk20' |\n| test_lock   | PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk20'               |\n+-------------+------------+-----------+---------------+----------------------+\n3 rows in set (0.00 sec)\n</code></pre><p>上面这个例子中，使用唯一索引uk_ac访问，获取了uk_ac上记录（a20，c20，pk20）和主键pk20上的锁，lock_mode有REC_NOT_GAP。</p><ul>\n<li>repeatable read隔离级别下，如果使用唯一索引没有匹配到相关记录。或者唯一索引为组合索引的情况下，没有匹配所有的索引字段，则还需要锁定记录前的GAP。</li>\n</ul><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from test_lock where a='a15' and c='c15' for update;\nEmpty set (0.00 sec)\n\nmysql&gt; select object_name, index_name, lock_type, lock_mode, lock_data from data_locks order by  object_name;\n+-------------+------------+-----------+-----------+----------------------+\n| object_name | index_name | lock_type | lock_mode | lock_data            |\n+-------------+------------+-----------+-----------+----------------------+\n| test_lock   | NULL       | TABLE     | IX        | NULL                 |\n| test_lock   | uk_ac      | RECORD    | X,GAP     | 'a20', 'c20', 'pk20' |\n+-------------+------------+-----------+-----------+----------------------+\n</code></pre><p>这个例子中，不存在a=‘a15’, b=‘b15’的记录，锁的模式为“X,GAP”，锁的是包含记录（‘a15’, ‘c15’）的区间，也就是记录(‘a20’, ‘b20’)前的GAP。</p><p>我们再来看一个例子，使用了唯一索引，但是只用了唯一索引的前缀。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from test_lock where a='a20' for update;\n+------+------+-----+-----+------+\n| id   | a    | b   | c   | d    |\n+------+------+-----+-----+------+\n| pk20 | a20  | b20 | c20 |   20 |\n+------+------+-----+-----+------+\n1 row in set (0.00 sec)\n\nmysql&gt; select object_name, index_name, lock_type, lock_mode, lock_data \nfrom data_locks order by  object_name;\n+-------------+------------+-----------+---------------+----------------------+\n| object_name | index_name | lock_type | lock_mode     | lock_data            |\n+-------------+------------+-----------+---------------+----------------------+\n| test_lock   | NULL       | TABLE     | IX            | NULL                 |\n| test_lock   | uk_ac      | RECORD    | X             | 'a20', 'c20', 'pk20' |\n| test_lock   | PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk20'               |\n| test_lock   | uk_ac      | RECORD    | X,GAP         | 'a30', 'c30', 'pk30' |\n+-------------+------------+-----------+---------------+----------------------+\n4 rows in set (0.01 sec)\n</code></pre><p>唯一索引idx_ac是一个组合索引（a,c），where条件中缺少字段C的条件，这个SQL锁定了记录（‘a20’, ‘c20’）以及记录前的GAP，lock_mode为X。lock_mode X的锁就是后面会讨论的Next-Key锁。这个SQL还锁定了记录(‘a20’, ‘c20’)之后的区间，也就是记录（‘a30’,‘c30’）前的GAP，锁的模式为“X,GAP”，这是接下来会讨论的GAP锁。</p><h4>2. GAP锁</h4><p>GAP锁用于锁住索引中相邻记录之间的区间。GAP锁的lock_mode为“X,GAP”或“S,GAP”，lock data为区间的右边界。在REPEATABLE READ或更高的隔离级别下，为了避免出现幻读，InnoDB使用了GAP锁，阻止其他事务往被锁定的区间内插入数据。</p><p>在实现上，GAP锁加在索引叶子节点中的记录上。在测试表中，索引idx_b有3条用户记录，形成了4个区间。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/29/d5e708f4daf4bcfd8d9d6fc19bc2de29.jpg?wh=1368x646\" alt=\"图片\"></p><p>下面是GAP锁的一个例子。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from test_lock where b='b15' for update;\nEmpty set (0.00 sec)\n\n\nmysql&gt; select object_name, index_name, lock_type, lock_mode, lock_data \n  from data_locks order by  object_name, index_name;\n+-------------+------------+-----------+-----------+---------------+\n| object_name | index_name | lock_type | lock_mode | lock_data     |\n+-------------+------------+-----------+-----------+---------------+\n| test_lock   | NULL       | TABLE     | IX        | NULL          |\n| test_lock   | idx_b      | RECORD    | X,GAP     | 'b20', 'pk20' |\n+-------------+------------+-----------+-----------+---------------+\n</code></pre><p>测试表中不存在b=‘b15’的记录，通过b=‘b15’的条件查询，使用了字段b上的索引idx_b。基于B+数据索引列数据有序的特点，记录’b15’应该位于区间（‘b10’，‘b20’）内，因此锁住了这个区间，就能阻止其他会话插入b=‘15’的记录，从而通过b=‘15’条件查询数据时，不会出现新的记录，从而避免了幻读。</p><p>当然，这个GAP锁，还会阻止其他会话写入(b10, pk10)到(b20, pk20)之间的任意数据。这个GAP锁，还会阻止其他会话把字段b的值更新到b10和b20之间的值。</p><h4>3. Next-Key锁</h4><p>Next-key锁是记录锁和GAP锁的一个组合，不仅锁定了记录，也锁定了记录之前的GAP。next-key锁的lock_type为RECORD，lock_mode为X或S。next-key锁也是Repeatable READ隔离级别下用来防止幻读的。</p><p>下面是Next-key锁的一个例子。</p><pre><code class=\"language-plain\">mysql&gt; begin;\n\nmysql&gt; select * from test_lock where b = 'b20' for update;\n+------+------+-----+-----+------+\n| id   | a    | b   | c   | d    |\n+------+------+-----+-----+------+\n| pk20 | a20  | b20 | c20 |   20 |\n+------+------+-----+-----+------+\n1 row in set (0.00 sec)\n\n\nmysql&gt; select object_name, index_name, lock_type, lock_mode, lock_data \n  from data_locks order by  object_name, index_name;\n+-------------+------------+-----------+---------------+---------------+\n| object_name | index_name | lock_type | lock_mode     | lock_data     |\n+-------------+------------+-----------+---------------+---------------+\n| test_lock   | NULL       | TABLE     | IX            | NULL          |\n| test_lock   | idx_b      | RECORD    | X             | 'b20', 'pk20' |\n| test_lock   | idx_b      | RECORD    | X,GAP         | 'b30', 'pk30' |\n| test_lock   | PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk20'        |\n+-------------+------------+-----------+---------------+---------------+\n4 rows in set (0.00 sec)\n</code></pre><p>上例中，记录(b20, pk20)上的锁就是Next-key锁，而记录(b30, pk30)上的锁是GAP锁，主键记录pk20上的锁是普通的记录锁。</p><p>下面是Next-key锁的另外一个例子。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt;。select * from test_lock where b &gt;= 'b11' and b &lt;= 'b12' for update;\nEmpty set (0.00 sec)\n\nmysql&gt; select object_name, index_name, lock_type, lock_mode, lock_data \n  from data_locks order by  object_name, index_name;\n+-------------+------------+-----------+-----------+---------------+\n| object_name | index_name | lock_type | lock_mode | lock_data     |\n+-------------+------------+-----------+-----------+---------------+\n| test_lock   | NULL       | TABLE     | IX        | NULL          |\n| test_lock   | idx_b      | RECORD    | X         | 'b20', 'pk20' |\n+-------------+------------+-----------+-----------+---------------+\n2 rows in set (0.00 sec)\n</code></pre><p>这个例子中，使用了范围查询，获取了Next-key锁。可以对比一下下面这种情况，获取的是GAP锁。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from test_lock where b in ('b11', 'b12') for update;\nEmpty set (0.01 sec)\n\nmysql&gt; select object_name, index_name, lock_type, lock_mode, lock_data    from data_locks order by  object_name, index_name;\n+-------------+------------+-----------+-----------+---------------+\n| object_name | index_name | lock_type | lock_mode | lock_data     |\n+-------------+------------+-----------+-----------+---------------+\n| test_lock   | NULL       | TABLE     | IX        | NULL          |\n| test_lock   | idx_b      | RECORD    | X,GAP     | 'b20', 'pk20' |\n+-------------+------------+-----------+-----------+---------------+\n</code></pre><h4>4. 插入意向（Insert Intention）锁</h4><p>InnoDB中插入数据时，需要获取记录所在区间的插入意向锁。InnoDB中，使用间隙锁和插入意向锁来避免幻读。</p><p>下面是插入意向锁的一个例子。</p><p>会话1先获取GAP锁：</p><pre><code class=\"language-plain\">\nmysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from test_lock where b = 'b15' for update;\nEmpty set (0.01 sec)\n</code></pre><p>会话2执行insert时被阻塞：</p><pre><code class=\"language-plain\">mysql&gt; insert into test_lock values('pk99', 'a15', 'b15', 'c15', 0);\nmysql&gt; select thread_id, index_name, lock_type, lock_mode, lock_data, lock_status\n  from data_locks order by  thread_id;\nmysql&gt; select thread_id, index_name, lock_type, lock_mode, lock_data, lock_status\n    -&gt;   from data_locks order by  thread_id;\n+-----------+------------+-----------+------------------------+---------------+-------------+\n| thread_id | index_name | lock_type | lock_mode              | lock_data     | lock_status |\n+-----------+------------+-----------+------------------------+---------------+-------------+\n|       504 | NULL       | TABLE     | IX                     | NULL          | GRANTED     |\n|       504 | idx_b      | RECORD    | X,GAP,INSERT_INTENTION | 'b20', 'pk20' | WAITING     |\n|       506 | NULL       | TABLE     | IX                     | NULL          | GRANTED     |\n|       506 | idx_b      | RECORD    | X,GAP                  | 'b20', 'pk20' | GRANTED     |\n+-----------+------------+-----------+------------------------+---------------+-------------+\n</code></pre><p>上例中，thead_id为506的会话获取了区间(‘b10’, ‘b20’)的GAP锁。会话504插入记录时，数据b15位于区间 (b20, b20) 之间，因此被阻塞，这里阻塞的原因是INSERT_INTENTION锁和GAP锁不兼容。</p><h3>自增ID锁（auto-inc锁）</h3><p>自增ID锁是InnoDB中的一种特殊的锁，如果插入数据时用到了自增ID，则需要先获取自增ID锁。获取自增ID锁的方式受参数innodb_autoinc_lock_mode控制。</p><h3>InnoDB锁兼容模式</h3><p>锁兼容模式决定了多个会话是否能同时持有某个资源的锁。InnoDB中，表锁对应的资源就是表，而记录锁（包括GAP锁、Next-key锁）对应的资源是索引中的记录。</p><p>下面的表格中记录了不同模式的锁之间的兼容性。</p><p><img src=\"https://static001.geekbang.org/resource/image/26/f3/261b8e72a59c8f829ca2bb0f2135ecf3.png?wh=1920x738\" alt=\"图片\"></p><ol>\n<li>\n<p>表级别的意向锁IX、IS之间互相兼容。表级别的意向锁和记录锁之间兼容。</p>\n</li>\n<li>\n<p>表级别的排他锁和任何其他锁都不兼容。表级别的共享锁只和共享模式的锁兼容。如果一个会话持有了某个表的表级别排他锁，则其它会话无法以共享或排他模式对该表加任何锁。如果一个会话持有了某个表的表级别共享锁，则其它会话无法得到该表的排他模式的任何锁。</p>\n</li>\n<li>\n<p>GAP锁之间互相兼容，共享和排他模式的GAP锁之间互相兼容。多个会话可以同时持有同一个GAP的共享或排他模式的锁。GAP锁只阻止其他会话往区间中插入新的数据。Next-key锁是GAP锁和记录锁的组合，Next-key锁中的GAP锁部分和普通GAP遵循同样的规则。</p>\n</li>\n<li>\n<p>对于记录级别的锁，多个会话可以同时持有一条记录的共享锁。如果一个会话持有了某条记录的排他锁，其他会话无法同时持有该记录的共享锁和排他锁。Next-key锁是GAP锁和记录锁的组合，Next-key锁中的记录锁部分和普通记录锁遵循同样的规则。</p>\n</li>\n</ol><h2>语句的加锁逻辑</h2><p>MySQL是怎么给记录加锁的呢？这跟SQL语句的执行过程息息相关。我们先来回顾下，使用索引访问数据的基本步骤（InnoDB使用了聚簇索引，因此全表扫描也可以看作是一种特殊的索引访问）。</p><p>使用B+树索引访问数据大致可以分为这四个步骤。</p><p>步骤1：将游标定位到叶子节点中的某条记录。</p><p><img src=\"https://static001.geekbang.org/resource/image/b9/79/b91b020d1205bb31ddf5a9d240d70779.jpg?wh=812x410\" alt=\"图片\"></p><p>上图这个图里的是一个索引的叶子页面。在使用索引顺序扫描时，有几种不同的情况。</p><ul>\n<li>\n<p>如果边界条件为K &gt; Kj，那么游标要指向Pos 1，也就是K值为Kk的第一条记录。</p>\n</li>\n<li>\n<p>如果边界条件为K &gt;= Kj，那么游标要指向到Pos 0，也就是K值为Kj的第一条记录。</p>\n</li>\n<li>\n<p>如果边界值Ks在Ki和Kj之间（Ki &lt; Ks &lt; Kj）, where条件为K &gt;= Ks或K &gt; Ks时，游标都指向到Pos 0。</p>\n</li>\n</ul><p>如果使用锁索引逆序扫描（比如语句是select * from t where k &gt;= Kj order by k desc），那么情况会有一点不同。</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/49/8a4b0c0bbe8be095e60d33e114ffcd49.jpg?wh=803x396\" alt=\"图片\"></p><ul>\n<li>\n<p>如果边界条件为K &lt; Kj，那么游标指向Pos 2。</p>\n</li>\n<li>\n<p>如果边界条件为K &lt;= Kj，那么游标指向Pos 3。</p>\n</li>\n<li>\n<p>如果边界值Ks在Ki和Kj之间（Ki &lt; Ks &lt; Kj）, where条件为K &lt;= Ks或K &lt; Ks，那么游标指向Pos 2。</p>\n</li>\n</ul><p>步骤2：读取游标指向的索引记录，根据获取到的主键值到聚簇索引获取记录，一般也将这一个过程称为回表。下面几种情况下可能不需要回表。</p><ul>\n<li>\n<p>使用了覆盖索引。</p>\n</li>\n<li>\n<p>使用了索引下推条件（Index Condition Pushdown, ICP），并且索引记录不满足下推的条件。</p>\n</li>\n</ul><ol>\n<li>判断获取到的记录是否在扫描的范围内。</li>\n</ol><p>根据MySQL Server层传过来的范围条件，判断当前读到记录是否在扫描范围内，如果记录已经超出了范围，就说明索引中已经没有更多满足条件的记录了，可以结束索引扫描。</p><p>比如下面这个SQL语句。</p><pre><code class=\"language-plain\">select * from tab \nwhere K &gt; Ks and K &lt; Kt\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/66/fc/660cc324a6b3f8b3ef4f9610fb9873fc.jpg?wh=948x378\" alt=\"图片\"><br>\n其中Ki &lt; Ks &lt; Kt &lt; Kj。游标开始时指向Pos 0，并且范围扫描的右边界Kt &lt; Kj，说明索引中没有满足查询条件的记录。这种情况下，InnoDB会返回一个特殊的标记（DB_RECORD_NOT_FOUND）给Server层。</p><ol start=\"2\">\n<li>Server层根据InnoDB层的返回值进行后续处理。</li>\n</ol><p>如果InnoDB层返回正常，则Server层对记录进行后续处理，包括判断记录是否满足SQL中的其他条件，如果满足条件，则进行相应的处理，如对记录进行更新或删除操作。处理完当前记录后，按顺序（正序或逆序），将游标指向索引页面中的下一行记录，回到步骤2继续处理。如果InnoDB层返回没有更多的记录，就说明语句执行完了。</p><p>MySQL对记录加锁的顺序，和上面描述的在B+树叶子页面中读取记录的顺序一致。接下来我们来看一下不同隔离级别下加锁的过程。</p><h3>REPEATABLE READ隔离级别下的几种锁定情况</h3><p>先准备测试表和测试数据。</p><pre><code class=\"language-plain\">CREATE TABLE `test_lock2` (\n  `id` varchar(10) NOT NULL,\n  `a` varchar(10) NOT NULL,\n  `b` varchar(10) NOT NULL,\n  `c` int DEFAULT NULL,\n  `d` int DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_ac` (`a`,`c`),\n  KEY `idx_b` (`b`)\n) ENGINE=InnoDB;\n\ninsert into test_lock2 values \n  ('pk11', 'a10', 'b10', 1, 0),\n  ('pk12', 'a20', 'b10', 2, 0),\n  ('pk21', 'a30', 'b20', 1, 0),\n  ('pk22', 'a40', 'b20', 2, 0),\n  ('pk23', 'a50', 'b20', 1, 0),\n  ('pk31', 'a60', 'b30', 2, 0),\n  ('pk32', 'a70', 'b30', 1, 0);\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/98/64/984715a849abd88ab10d81byydedd264.jpg?wh=1028x474\" alt=\"图片\"></p><h4>情况1：使用普通索引执行等值匹配。</h4><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where b='b15';\nQuery OK, 0 rows affected (0.00 sec)\nRows matched: 0  Changed: 0  Warnings: 0\n</code></pre><p>这个例子中，索引字段b使用等值匹配，并且记录不存在，因此获取了记录(b20, pk21)的gap锁。</p><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data \n    from data_locks;\n+------------+-----------+-----------+---------------+\n| index_name | lock_type | lock_mode | lock_data     |\n+------------+-----------+-----------+---------------+\n| NULL       | TABLE     | IX        | NULL          |\n| idx_b      | RECORD    | X,GAP     | 'b20', 'pk21' |\n+------------+-----------+-----------+---------------+\n</code></pre><p>下面是等值匹配的另外一个例子。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where b='b20';\nQuery OK, 3 rows affected (0.00 sec)\nRows matched: 3  Changed: 3  Warnings: 0\n</code></pre><p>除了给匹配到的3条记录加上Next-key锁，还给下一条记录(b30, pk31)加上了GAP锁。</p><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data \n    from data_locks;\n+------------+-----------+---------------+---------------+\n| index_name | lock_type | lock_mode     | lock_data     |\n+------------+-----------+---------------+---------------+\n| NULL       | TABLE     | IX            | NULL          |\n| idx_b      | RECORD    | X             | 'b20', 'pk21' |\n| idx_b      | RECORD    | X             | 'b20', 'pk22' |\n| idx_b      | RECORD    | X             | 'b20', 'pk23' |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk21'        |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk22'        |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk23'        |\n| idx_b      | RECORD    | X,GAP         | 'b30', 'pk31' |\n+------------+-----------+---------------+---------------+\n</code></pre><h4>情况2：使用普通索引执行范围扫描。</h4><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where b &gt;= 'b11' and b &lt;= 'b19';\nQuery OK, 0 rows affected (0.00 sec)\nRows matched: 0  Changed: 0  Warnings: 0\n</code></pre><p>范围匹配时，加锁的情况和等值匹配的情况有一点区别，这次给记录(b20, pk21)加上了Next-key锁。</p><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data \nfrom data_locks;\n+------------+-----------+---------------+---------------+\n| index_name | lock_type | lock_mode     | lock_data     |\n+------------+-----------+---------------+---------------+\n| NULL       | TABLE     | IX            | NULL          |\n| idx_b      | RECORD    | X             | 'b20', 'pk21' |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk21'        |\n+------------+-----------+---------------+---------------+\n</code></pre><p>下面是另外一个范围扫描的例子。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where b &gt;= 'b15' and b &lt;= 'b25';\nQuery OK, 3 rows affected (0.01 sec)\nRows matched: 3  Changed: 3  Warnings: 0\n</code></pre><p>除了给匹配到的记录加上了Next-key锁，还给下一条记录(b30, pk31)加上了Next-key锁。</p><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data from data_locks;\n+------------+-----------+---------------+---------------+\n| index_name | lock_type | lock_mode     | lock_data     |\n+------------+-----------+---------------+---------------+\n| NULL       | TABLE     | IX            | NULL          |\n| idx_b      | RECORD    | X             | 'b20', 'pk21' |\n| idx_b      | RECORD    | X             | 'b20', 'pk22' |\n| idx_b      | RECORD    | X             | 'b20', 'pk23' |\n| idx_b      | RECORD    | X             | 'b30', 'pk31' |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk21'        |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk22'        |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk23'        |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk31'        |\n+------------+-----------+---------------+---------------+\n</code></pre><h4>情况3：使用唯一索引</h4><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where a = 'a20' and c=2;\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n</code></pre><p>如果使用唯一索引，并且查找的记录存在，则只需要给记录加普通的记录锁，而不需要锁记录前的区间。</p><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data \n  from data_locks;\n+------------+-----------+---------------+------------------+\n| index_name | lock_type | lock_mode     | lock_data        |\n+------------+-----------+---------------+------------------+\n| NULL       | TABLE     | IX            | NULL             |\n| uk_ac      | RECORD    | X,REC_NOT_GAP | 'a20', 2, 'pk12' |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk12'           |\n+------------+-----------+---------------+------------------+\n</code></pre><p>如果查询的记录不存在，还是需要加GAP锁。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where a = 'a20' and c=1;\nQuery OK, 0 rows affected (0.00 sec)\nRows matched: 0  Changed: 0  Warnings: 0\n</code></pre><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data \n  from data_locks;\n+------------+-----------+-----------+------------------+\n| index_name | lock_type | lock_mode | lock_data        |\n+------------+-----------+-----------+------------------+\n| NULL       | TABLE     | IX        | NULL             |\n| uk_ac      | RECORD    | X,GAP     | 'a20', 2, 'pk12' |\n+------------+-----------+-----------+------------------+\n</code></pre><p>如果唯一索引字段的条件没有使用等值匹配，而是使用了is null、is not null，或者干脆没有传入部分字段的条件，则还是需要获取next-key锁。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where a = 'a20' and c is not null;\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n</code></pre><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data \n  from data_locks;\n+------------+-----------+---------------+------------------+\n| index_name | lock_type | lock_mode     | lock_data        |\n+------------+-----------+---------------+------------------+\n| NULL       | TABLE     | IX            | NULL             |\n| uk_ac      | RECORD    | X             | 'a20', 2, 'pk12' |\n| uk_ac      | RECORD    | X             | 'a30', 1, 'pk21' |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk12'           |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk21'           |\n+------------+-----------+---------------+------------------+\n</code></pre><h4>情况4：使用主键</h4><p>对于主键，如果where条件中主键的边界条件在聚簇索引中实际上也存在，MySQL在加锁时做了一些优化。下面这个例子中，SQL语句的数据扫描范围是[pk21, pk23]，索引中也存在pk21，pk23这两条记录。因此对记录pk21只加上了普通的记录锁，没有锁记录前的区间。对于记录pk23之后的记录，也就是记录pk31，也不需要加锁。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where id &gt;= 'pk21' and id &lt;= 'pk23';\nQuery OK, 3 rows affected (0.00 sec)\nRows matched: 3  Changed: 3  Warnings: 0\n</code></pre><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data from data_locks;\n+------------+-----------+---------------+-----------+\n| index_name | lock_type | lock_mode     | lock_data |\n+------------+-----------+---------------+-----------+\n| NULL       | TABLE     | IX            | NULL      |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk21'    |\n| PRIMARY    | RECORD    | X             | 'pk22'    |\n| PRIMARY    | RECORD    | X             | 'pk23'    |\n+------------+-----------+---------------+-----------+\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/d9/60/d98f70e5f9cfa3fd4d182b2ba059a360.jpg?wh=852x321\" alt=\"图片\"></p><p>如果SQL语句的边界条件在聚簇索引中并不存在，则还是跟使用普通索引时一样，需要锁定相关的区间。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where id &gt; 'pk20' and id &lt; 'pk30';\nQuery OK, 3 rows affected (0.00 sec)\nRows matched: 3  Changed: 3  Warnings: 0\n</code></pre><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data from data_locks;\n+------------+-----------+-----------+-----------+\n| index_name | lock_type | lock_mode | lock_data |\n+------------+-----------+-----------+-----------+\n| NULL       | TABLE     | IX        | NULL      |\n| PRIMARY    | RECORD    | X         | 'pk21'    |\n| PRIMARY    | RECORD    | X         | 'pk22'    |\n| PRIMARY    | RECORD    | X         | 'pk23'    |\n| PRIMARY    | RECORD    | X,GAP     | 'pk31'    |\n+------------+-----------+-----------+-----------+\n</code></pre><h4>情况5：索引逆序扫描</h4><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from test_lock2\n       where b='b20'\n       order by id desc for update;\n+------+-----+-----+------+------+\n| id   | a   | b   | c    | d    |\n+------+-----+-----+------+------+\n| pk23 | a50 | b20 |    1 |    1 |\n| pk22 | a40 | b20 |    2 |    1 |\n| pk21 | a30 | b20 |    1 |    1 |\n+------+-----+-----+------+------+\n3 rows in set (0.00 sec)\nmysql&gt; explain select * from test_lock2 \n  where b='b20'  \n  order by id desc for update\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: test_lock2\n   partitions: NULL\n         type: ref\npossible_keys: idx_b\n          key: idx_b\n      key_len: 42\n          ref: const\n         rows: 3\n     filtered: 100.00\n        Extra: Backward index scan\n1 row in set, 1 warning (0.00 sec)\n</code></pre><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data \n  from data_locks;\n+------------+-----------+---------------+---------------+\n| index_name | lock_type | lock_mode     | lock_data     |\n+------------+-----------+---------------+---------------+\n| NULL       | TABLE     | IX            | NULL          |\n| idx_b      | RECORD    | X,GAP         | 'b30', 'pk31' |\n| idx_b      | RECORD    | X             | 'b10', 'pk12' |\n| idx_b      | RECORD    | X             | 'b20', 'pk21' |\n| idx_b      | RECORD    | X             | 'b20', 'pk22' |\n| idx_b      | RECORD    | X             | 'b20', 'pk23' |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk12'        |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk21'        |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk22'        |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk23'        |\n+------------+-----------+---------------+---------------+\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/c4/e0/c427f29839a0d57ce4c590205fc748e0.jpg?wh=1040x481\" alt=\"图片\"></p><p>在这个例子中，游标先定位到索引记录(b20, pk23)，然后获取该记录的下一条记录，也就是记录(b30, pk31)的GAP锁。然后再根据索引逆序分别获取记录(b20, pk23)、(b20, pk22)、(b20, pk21)、(b10, k12)的next-key锁。在处理记录(b10, pk12)时，发现该记录已经不在索引扫描范围内，因此结束处理。</p><h3>READ COMMITTED隔离级别下的锁定</h3><p>在READ COMMITTED隔离级别下面，SQL不需要GAP锁，只需要获取普通的记录锁。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where b &gt;=  'b15' and b &lt;= 'b25';\nQuery OK, 3 rows affected (0.01 sec)\nRows matched: 3  Changed: 3  Warnings: 0\n</code></pre><p>上面这个SQL，只锁定了表中实际存在的记录，lock_mode都是REC_NOT_GAP。</p><pre><code class=\"language-plain\">mysql&gt; select index_name, lock_type, lock_mode, lock_data from data_locks;\n+------------+-----------+---------------+---------------+\n| index_name | lock_type | lock_mode     | lock_data     |\n+------------+-----------+---------------+---------------+\n| NULL       | TABLE     | IX            | NULL          |\n| idx_b      | RECORD    | X,REC_NOT_GAP | 'b20', 'pk21' |\n| idx_b      | RECORD    | X,REC_NOT_GAP | 'b20', 'pk22' |\n| idx_b      | RECORD    | X,REC_NOT_GAP | 'b20', 'pk23' |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk21'        |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk22'        |\n| PRIMARY    | RECORD    | X,REC_NOT_GAP | 'pk23'        |\n+------------+-----------+---------------+---------------+\n</code></pre><h4>半一致性读取</h4><p>通常，update语句在查找需要更新的记录的过程中，会给记录加锁，如果记录已经被其他事务锁定了，那么update就需要等待锁。但是，如果满足几点条件，那么update语句在查找记录时，可以使用一致性读取，先不加锁。如果获取的记录满足update语句的其他条件，再使用加锁的方式重新读取这行记录。如果获取的记录不满足update语句的其他条件，就可以跳过这行记录，继续处理下一行记录。这种机制就称为半一致性读取。</p><p>如果满足下面这几个条件，就可以使用半一致性读取。</p><ol>\n<li>\n<p>事务隔离级别为READ COMMITTED或READ UNCOMITTED。</p>\n</li>\n<li>\n<p>update语句使用主键来查找记录。</p>\n</li>\n<li>\n<p>where条件没有使用主键的全字段等值匹配。</p>\n</li>\n</ol><p>下面是使用半一致性读取的一个例子。先准备测试数据。</p><pre><code class=\"language-plain\">mysql&gt; create table test_semi(a int, b int, c int, primary key(a));\nQuery OK, 0 rows affected (0.52 sec)\n\nmysql&gt; insert into test_semi values(10, 1, 0),(11, 2, 0),(12,1,0),(13,2,0),(14,1,0);\nQuery OK, 5 rows affected (0.00 sec)\nRecords: 5  Duplicates: 0  Warnings: 0\n\nmysql&gt; select * from test_semi;\n+----+------+------+\n| a  | b    | c    |\n+----+------+------+\n| 10 |    1 |    0 |\n| 11 |    2 |    0 |\n| 12 |    1 |    0 |\n| 13 |    2 |    0 |\n| 14 |    1 |    0 |\n+----+------+------+\n5 rows in set (0.00 sec)\n</code></pre><p>会话1执行下面的SQL。</p><pre><code class=\"language-plain\">mysql&gt; set transaction isolation level read committed;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; update test_semi set c=c+10 where b=1;\nQuery OK, 3 rows affected (0.01 sec)\nRows matched: 3  Changed: 3  Warnings: 0\n\nmysql&gt; select * from test_semi;\n+----+------+------+\n| a  | b    | c    |\n+----+------+------+\n| 10 |    1 |   10 |\n| 11 |    2 |    0 |\n| 12 |    1 |   10 |\n| 13 |    2 |    0 |\n| 14 |    1 |   10 |\n+----+------+------+\n5 rows in set (0.00 sec)\n</code></pre><p>会话1更新了b=1的记录，更新后不提交，事务持有主键为10、12、14的这几条记录的锁。</p><p>会话2执行下面这几个SQL。</p><pre><code class=\"language-plain\">mysql&gt; set transaction isolation level read committed;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\n-- update 1\nmysql&gt; update test_semi set c=c+9 where b=2;\nQuery OK, 2 rows affected (0.00 sec)\nRows matched: 2  Changed: 2  Warnings: 0\n\nmysql&gt; select * from test_semi;\n+----+------+------+\n| a  | b    | c    |\n+----+------+------+\n| 10 |    1 |    0 |\n| 11 |    2 |    9 |\n| 12 |    1 |    0 |\n| 13 |    2 |    9 |\n| 14 |    1 |    0 |\n+----+------+------+\n5 rows in set (0.00 sec)\n</code></pre><p>会话2执行update语句时，读取a=10的记录时，虽然该记录已经被会话1锁定，但是由于采用了半一致性读取，可以在不加锁的情况下获取到记录，该记录不满足b=2的条件，所以跳过了这条记录，不需要等待锁。同样update还跳过了主键为12和14的记录，完成了更新操作。</p><p>如果会话1或会话2使用了REPEATABLE READ隔离级别，那么会话2的这个更新语句就要等会话1提交后才能执行下去。</p><h3>INSERT语句如何获取锁？</h3><h4>插入意向锁</h4><p>Insert数据时，要获取插入意向锁。Update主键或二级索引字段时，实际上会将update转换成delete加insert，因此也需要获取插入意向锁。</p><p>执行下面这个SQL时，索引记录(b20, pk25)会插入到记录(b30, pk31)之前。</p><pre><code class=\"language-plain\">insert into test_lock2(id, a,b,c,d) \nvalues('pk25', 'a99', 'b20', 0,0);\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/79/22/79626df040e2ea428b5138f7160dc922.jpg?wh=996x425\" alt=\"图片\"></p><p>如果记录(b30, pk31)之前的GAP已经被其他会话锁定（GAP锁或Next-key锁），insert就需要等待。</p><pre><code class=\"language-plain\">-- 会话1获取记录(b30, pk31)的GAP锁\nmysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; select * from test_lock2 where b='b25' for update;\nEmpty set (0.01 sec)\n\n\nmysql&gt; select thread_id, index_name, lock_type, lock_mode, lock_data, lock_status\n       from data_locks;\n+-----------+------------+-----------+-----------+---------------+-------------+\n| thread_id | index_name | lock_type | lock_mode | lock_data     | lock_status |\n+-----------+------------+-----------+-----------+---------------+-------------+\n|       506 | NULL       | TABLE     | IX        | NULL          | GRANTED     |\n|       506 | idx_b      | RECORD    | X,GAP     | 'b30', 'pk31' | GRANTED     |\n+-----------+------------+-----------+-----------+---------------+-------------+\n</code></pre><p>会话2执行insert语句时被阻塞。</p><pre><code class=\"language-plain\">mysql&gt; insert into test_lock2(id, a,b,c,d) values('pk25', 'a99', 'b20', 0,0);\n-- 等待中\nmysql&gt; select thread_id, index_name, lock_type, lock_mode, lock_data, lock_status    from data_locks;\n+-----------+------------+-----------+------------------------+---------------+-------------+\n| thread_id | index_name | lock_type | lock_mode              | lock_data     | lock_status |\n+-----------+------------+-----------+------------------------+---------------+-------------+\n|       504 | NULL       | TABLE     | IX                     | NULL          | GRANTED     |\n|       504 | idx_b      | RECORD    | X,GAP,INSERT_INTENTION | 'b30', 'pk31' | WAITING     |\n|       506 | NULL       | TABLE     | IX                     | NULL          | GRANTED     |\n|       506 | idx_b      | RECORD    | X,GAP                  | 'b30', 'pk31' | GRANTED     |\n+-----------+------------+-----------+------------------------+---------------+-------------+\n</code></pre><p>你可以使用下面这个SQL查看insert是被哪个会话阻塞了。</p><pre><code class=\"language-plain\">mysql&gt; select\n  t3.PROCESSLIST_ID as blocking_processlist_id,\n  t3.PROCESSLIST_COMMAND as blocking_processlist_command,\n  t3.PROCESSLIST_INFO as blocking_processlist_info,\n  t3.PROCESSLIST_STATE as blocking_processlist_state,\n  t3.PROCESSLIST_TIME as blocking_processlist_time,\n  t5.object_name, \n  t5.lock_type blocking_lock_type, \n  t5.lock_mode blocking_lock_mode, \n  t5.lock_data blocking_lock_data, \n  t4.lock_mode waiting_lock_mode,\n  t4.lock_status wait_status,\n  t2.PROCESSLIST_ID as waiting_processlist_id,\n  t2.PROCESSLIST_COMMAND as waiting_processlist_command,\n  t2.PROCESSLIST_INFO as waiting_processlist_info,\n  t2.PROCESSLIST_STATE as waiting_processlist_state,\n  t2.PROCESSLIST_TIME as waiting_processlist_time\nfrom data_lock_waits t1, data_locks t4, data_locks t5, threads t2, threads t3\nwhere t1.REQUESTING_ENGINE_LOCK_ID = t4.ENGINE_LOCK_ID\nand t1.BLOCKING_ENGINE_LOCK_ID = t5.ENGINE_LOCK_ID\nand t1.REQUESTING_THREAD_ID = t2.thread_id\nand t1.BLOCKING_THREAD_ID = t3.thread_id;\n\n*************************** 1. row ***************************\n     blocking_processlist_id: 398\nblocking_processlist_command: Sleep\n   blocking_processlist_info: NULL\n  blocking_processlist_state: NULL\n   blocking_processlist_time: 658\n                 object_name: test_lock2\n          blocking_lock_type: RECORD\n          blocking_lock_mode: X,GAP\n          blocking_lock_data: 'b30', 'pk31'\n           waiting_lock_mode: X,GAP,INSERT_INTENTION\n                 wait_status: WAITING\n      waiting_processlist_id: 396\n waiting_processlist_command: Query\n    waiting_processlist_info: insert into test_lock2(id, a,b,c,d) values('pk25', 'a99', 'b20', 0,0)\n   waiting_processlist_state: update\n    waiting_processlist_time: 26\n</code></pre><h4>隐藏的锁</h4><p>如果一开始insert语句就执行成功了，并不会给记录加上显式的锁。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into test_lock2(id,a,b,c,d) values('pk99', 'a99', 'b99', 1,0);\nQuery OK, 1 row affected (0.00 sec)\n\nmysql&gt; select thread_id, index_name, lock_type, lock_mode, lock_data, lock_status from data_locks;\n+-----------+------------+-----------+-----------+-----------+-------------+\n| thread_id | index_name | lock_type | lock_mode | lock_data | lock_status |\n+-----------+------------+-----------+-----------+-----------+-------------+\n|       211 | NULL       | TABLE     | IX        | NULL      | GRANTED     |\n+-----------+------------+-----------+-----------+-----------+-------------+\n</code></pre><p>其他会话修改这行新插入的记录时，在获取锁的过程中，会发现记录上没有锁，但是最后一次修改记录的事务还没有提交，则会帮忙给记录加上相关的锁。</p><p>下面的例子中，thread_id 506在获取记录(b99, pk99)的锁时，发现最后一次修改这条记录的事务还没有提交，就帮忙创建了一个锁。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; update test_lock2 set d=d+1 where b='b99';\n</code></pre><pre><code class=\"language-plain\">mysql&gt; select thread_id, index_name, lock_type, lock_mode, lock_data, lock_status \n  from data_locks;\n+-----------+------------+-----------+---------------+---------------+-------------+\n| thread_id | index_name | lock_type | lock_mode     | lock_data     | lock_status |\n+-----------+------------+-----------+---------------+---------------+-------------+\n|       506 | NULL       | TABLE     | IX            | NULL          | GRANTED     |\n|       506 | idx_b      | RECORD    | X             | 'b99', 'pk99' | WAITING     |\n|       504 | NULL       | TABLE     | IX            | NULL          | GRANTED     |\n|       506 | idx_b      | RECORD    | X,REC_NOT_GAP | 'b99', 'pk99' | GRANTED     |\n+-----------+------------+-----------+---------------+---------------+-------------+\n</code></pre><p>上面的例子中，持有锁和等待锁的线程ID都是506。</p><h4>唯一索引和主键</h4><p>为了保证唯一性约束，insert时需要获取主键和唯一索引相应记录上的锁。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into test_lock2 values ('pk99', 'a40', 'b40', 2, 0);\nERROR 1062 (23000): Duplicate entry 'a40-2' for key 'test_lock2.uk_ac'\n</code></pre><p>上面这个例子中，insert的数据违反了唯一约束，SQL执行报错后，获取的uk_ac上的锁没有自动释放掉。</p><pre><code class=\"language-plain\">mysql&gt; select thread_id, index_name, lock_type, lock_mode, lock_data, lock_status\n    from data_locks;\n+-----------+------------+-----------+-----------+------------------+-------------+\n| thread_id | index_name | lock_type | lock_mode | lock_data        | lock_status |\n+-----------+------------+-----------+-----------+------------------+-------------+\n|       211 | NULL       | TABLE     | IX        | NULL             | GRANTED     |\n|       211 | uk_ac      | RECORD    | S         | 'a40', 2, 'pk22' | GRANTED     |\n+-----------+------------+-----------+-----------+------------------+-------------+\n</code></pre><h4>外键约束</h4><p>如果表存在外键，那么往子表插入数据时，需要获取父表对应记录的锁。</p><pre><code class=\"language-plain\">CREATE TABLE `parent` (\n  `id` varchar(10) NOT NULL,\n  `pid` varchar(10) DEFAULT NULL,\n  `a` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  key idx_pid(pid)\n) ENGINE=InnoDB \n\nCREATE TABLE `child` (\n  `id` varchar(10) NOT NULL,\n  `pid` varchar(10) DEFAULT NULL,\n  `a` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `fk` (`pid`),\n  CONSTRAINT `child_fk_pid` FOREIGN KEY (`pid`) REFERENCES `parent` (`pid`)\n) ENGINE=InnoDB;\n\ninsert into parent values('parent-01', 'parent-01', 'parent row');\n</code></pre><p>往子表INSERT数据时，需要获取父表对应记录上的S锁。</p><pre><code class=\"language-plain\">mysql&gt; begin;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql&gt; insert into child values('child-01', 'parent-01', 'child row');\nQuery OK, 1 row affected (0.00 sec)\n</code></pre><pre><code class=\"language-plain\">mysql&gt; select object_name, index_name, lock_type, lock_mode, lock_data, lock_status \n  from data_locks;\n+-------------+------------+-----------+---------------+--------------------------+-------------+\n| object_name | index_name | lock_type | lock_mode     | lock_data                | lock_status |\n+-------------+------------+-----------+---------------+--------------------------+-------------+\n| parent      | NULL       | TABLE     | IS            | NULL                     | GRANTED     |\n| child       | NULL       | TABLE     | IX            | NULL                     | GRANTED     |\n| parent      | idx_pid    | RECORD    | S,REC_NOT_GAP | 'parent-01', 'parent-01' | GRANTED     |\n+-------------+------------+-----------+---------------+--------------------------+-------------+\n</code></pre><h2>死锁的一个例子</h2><p>死锁也是平时比较容易遇到的一个问题。死锁的情况很多，对于一些偶发的死锁，业务上做好重试，应该能解决大部分的问题。使用show engine innodb status命令可以查看最新的死锁。如果设置了innodb_print_all_deadlocks参数，还会在错误日志中记录死锁信息。</p><p>下面是死锁的一个例子。先创建一个表，准备一些数据。</p><pre><code class=\"language-plain\">create table test_lck2(a int, b int, c int, primary key(a), key idx_b(b));\n\ninsert into test_lck2 values(11,11,11),(15,15,15),(19,19,19);\n\nmysql&gt;  select * from test_lck2;\n+----+------+------+\n| a  | b    | c    |\n+----+------+------+\n| 11 |   11 |   11 |\n| 15 |   15 |   15 |\n| 19 |   19 |   19 |\n+----+------+------+\n3 rows in set (0.00 sec)\n</code></pre><p>开启两个会话，按顺序执行SQL。</p><p><img src=\"https://static001.geekbang.org/resource/image/63/e5/63fc2899532ce97e49d0c07cbb5c99e5.png?wh=1380x1422\" alt=\"图片\"></p><p>从死锁日志里可以看出。</p><ul>\n<li>\n<p>事务1持有idx_b的记录15上的锁，锁模式为“lock_mode X locks gap before rec”。</p>\n</li>\n<li>\n<p>事务1在等待idx_b的记录15上的锁，锁模式为“lock_mode X locks gap before rec insert intention”。</p>\n</li>\n<li>\n<p>事务2持有idx_b的记录15上的锁，锁模式为“lock_mode X”。</p>\n</li>\n<li>\n<p>事务2也在等待idx_b的记录15上的锁，锁模式为“lock_mode X locks gap before rec insert intention waiting”</p>\n</li>\n</ul><pre><code class=\"language-plain\">*** (1) TRANSACTION:\nTRANSACTION 163825, ACTIVE 46 sec inserting\nmysql tables in use 1, locked 1\nLOCK WAIT 5 lock struct(s), heap size 1128, 4 row lock(s), undo log entries 2\nMySQL thread id 46, OS thread handle 140019091113536, query id 84199 localhost 127.0.0.1 root update\ninsert into test_lck2 values(12,12,12)\n\n*** (1) HOLDS THE LOCK(S):\nRECORD LOCKS space id 10018 page no 5 n bits 80 index idx_b of table `test_lock`.`test_lck2` trx id 163825 lock_mode X locks gap before rec\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0\n 0: len 4; hex 8000000f; asc     ;;\n 1: len 4; hex 8000000f; asc     ;;\n\n\n*** (1) WAITING FOR THIS LOCK TO BE GRANTED:\nRECORD LOCKS space id 10018 page no 5 n bits 80 index idx_b of table `test_lock`.`test_lck2` trx id 163825 lock_mode X locks gap before rec insert intention waiting\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0\n 0: len 4; hex 8000000f; asc     ;;\n 1: len 4; hex 8000000f; asc     ;;\n\n\n*** (2) TRANSACTION:\nTRANSACTION 163826, ACTIVE 33 sec inserting\nmysql tables in use 1, locked 1\nLOCK WAIT 5 lock struct(s), heap size 1128, 4 row lock(s), undo log entries 2\nMySQL thread id 49, OS thread handle 140019090056768, query id 84200 localhost 127.0.0.1 root update\ninsert into test_lck2 values(14,14,14)\n\n*** (2) HOLDS THE LOCK(S):\nRECORD LOCKS space id 10018 page no 5 n bits 80 index idx_b of table `test_lock`.`test_lck2` trx id 163826 lock_mode X\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0\n 0: len 4; hex 8000000f; asc     ;;\n 1: len 4; hex 8000000f; asc     ;;\n\n\n*** (2) WAITING FOR THIS LOCK TO BE GRANTED:\nRECORD LOCKS space id 10018 page no 5 n bits 80 index idx_b of table `test_lock`.`test_lck2` trx id 163826 lock_mode X locks gap before rec insert intention waiting\nRecord lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0\n 0: len 4; hex 8000000f; asc     ;;\n 1: len 4; hex 8000000f; asc     ;;\n\n*** WE ROLL BACK TRANSACTION (2)\n</code></pre><p>现实中的死锁可能会比上面这个例子复杂很多，一个死锁可能会涉及到更多的会话。但分析思路上是类似的，要分析各个会话加锁的顺序、锁的模式。</p><h2>总结</h2><p>锁是数据库中很重要的一个机制。MySQL中，我们主要会关注元数据锁和InnoDB的行锁。这一讲中，我们对行锁做了比较详细的介绍。REPEATABLE READ隔离级别下，使用了Gap锁、Next-key锁，锁的范围更大，因此也更容易引起死锁。应用程序遇到锁的问题时，首先要确定是锁超时还是死锁。你可以查询data_locks、data_lock_waits表来分析锁等待关系。</p><h2>思考题</h2><p>长时间的锁等待会严重影响数据库的性能，频繁的死锁也会影响业务，怎么监控数据库中的锁等待和死锁呢？</p><p>期待你的思考，欢迎在留言区中与我交流。如果今天的课程让你有所收获，也欢迎转发给有需要的朋友。我们下节课再见。</p>","neighbors":{"left":{"article_title":"32｜隔离级别对应用程序有什么影响？","id":819420},"right":{"article_title":"34｜MySQL数据库高可用架构部署和维护","id":820990}},"comments":[]}