{"id":205635,"title":"35 | MediatR：让领域事件处理更加优雅","content":"<p><strong>课件和Demo地址</strong><br>\n<a href=\"https://gitee.com/geektime-geekbang/NET-Core\">https://gitee.com/geektime-geekbang/NET-Core</a></p>","comments":[{"had_liked":false,"id":186780,"user_name":"SuperSnow","can_delete":false,"product_type":"c3","uid":1065351,"ip_address":"","ucode":"84C89AA8083E6A","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","comment_is_top":false,"comment_ctime":1583922958,"is_pvip":false,"replies":[{"id":72454,"content":"可以为查询的Request类型标注特定的Attribute或者接口，在PipelineBehavior识别并跳过","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1584241586,"ip_address":"","comment_id":186780,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"老师好，对于IPipelineBehavior接口中的Handle方法，由于该方法会对所有event事件的处理方法都会拦截，有没有什么注解可以标注不拦截的。因为在进行select请求操作时，没必要还加事务控制，所以有没有什么方法可以取消？","like_count":2,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486869,"discussion_content":"可以为查询的Request类型标注特定的Attribute或者接口，在PipelineBehavior识别并跳过","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584241586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213973,"user_name":"mars","can_delete":false,"product_type":"c3","uid":1407604,"ip_address":"","ucode":"1C57AEC0AC60D7","user_header":"https://static001.geekbang.org/account/avatar/00/15/7a/74/fcb8bc4c.jpg","comment_is_top":false,"comment_ctime":1588603981,"is_pvip":false,"replies":[{"id":79639,"content":"是这样的，但并不是所有的“副作用&quot;都需要通过eventbus传递，有一部分领域事件，仅仅在领域内发生作用，则不需要通过eventbus，通过MediatR在进程内处理即可","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1588939764,"ip_address":"","comment_id":213973,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"在实现领域驱动一书中一再强调不要在应用层处理副作用，因为会有事务问题，所以是不是应该都通过领域事件放到eventbus然后异步处理?","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493917,"discussion_content":"是这样的，但并不是所有的“副作用&amp;quot;都需要通过eventbus传递，有一部分领域事件，仅仅在领域内发生作用，则不需要通过eventbus，通过MediatR在进程内处理即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588939764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208984,"user_name":"峰","can_delete":false,"product_type":"c3","uid":1390326,"ip_address":"","ucode":"527BB65559F0B0","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/f6/d65b7302.jpg","comment_is_top":false,"comment_ctime":1587477892,"is_pvip":false,"replies":[{"id":79654,"content":"你特别指出是异步，不是async，那说明你期望命令的处理不等待事件处理器的处理，那就需要每个处理器来自己处理异常了，这种情况CAP组件能够很好的处理这种情况","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1588943030,"ip_address":"","comment_id":208984,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"请问老师两个问题\n1.多个订阅处理器是异步执行吗？我指的异步不是async。\n2.如果事件处理器中有异常如何提示出来？","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492692,"discussion_content":"你特别指出是异步，不是async，那说明你期望命令的处理不等待事件处理器的处理，那就需要每个处理器来自己处理异常了，这种情况CAP组件能够很好的处理这种情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588943030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204330,"user_name":"提姆","can_delete":false,"product_type":"c3","uid":1103960,"ip_address":"","ucode":"F2A339CC9AC594","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/58/1f5f7aed.jpg","comment_is_top":false,"comment_ctime":1586367409,"is_pvip":false,"replies":[{"id":77423,"content":"1.是的，领域事件的处理应该专注于一个业务目的，多个影响可以分多个handler。\n\n2.建议尽量使用async await的方式，避免同步异步代码混用。","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1587041105,"ip_address":"","comment_id":204330,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"老师你好，有两点想请问一下\n1. 领域事件的处理是不是尽可能不要有相依性，而是自己独立完成一件事情呢\n2. 有关MediatR实作Handler的部分，有关数据库的读取是否要加上async await? 还是其实没有差呢","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491145,"discussion_content":"1.是的，领域事件的处理应该专注于一个业务目的，多个影响可以分多个handler。\n\n2.建议尽量使用async await的方式，避免同步异步代码混用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587041105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1554764,"avatar":"https://static001.geekbang.org/account/avatar/00/17/b9/4c/8c9edc85.jpg","nickname":"小庞","note":"","ucode":"7C8367CDB47163","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289907,"discussion_content":"我看到您的IRepository里面大都是同步方法，而异步方法也是同步方法的Task.FromResult的封装，为什么不用efcore里面的异步方法来实现呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594264601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184095,"user_name":"任高良","can_delete":false,"product_type":"c3","uid":1380555,"ip_address":"","ucode":"7C97A6902B4013","user_header":"https://static001.geekbang.org/account/avatar/00/15/10/cb/2a7ef76b.jpg","comment_is_top":false,"comment_ctime":1583221595,"is_pvip":false,"replies":[{"id":71579,"content":"你的理解是对的，应该定义新用户注册领域事件的优惠券发放handler，来处理优惠券的发放。\n\n集成事件的目的是将事件传播给其它的微服务，它本质上也是为了传递领域事件。\n\n领域事件处理handler一般会组织到以各自聚合根命名的目录下，用以区分。","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1583565136,"ip_address":"","comment_id":184095,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"老师你好，下面的场景，如何使用领域事件进行优雅地处理呢？\n用户注册成功之后做两件事情：1、创建一个新的购物车；2、发放新用户注册100元优惠券到账户中。\n注：用户注册、购物车、优惠券这些功能在一个项目中，并且使用的同一个数据库。\n\n我的思考是：\n在用户注册成功之后发布UserRegisteredDomainEvent事件，然后在系统中写2个handler，分别处理“新建购物车”和“发放优惠券”这两件事情。\n但是看到老师的代码中，对于OrderCreatedDomainEvent只有一个领域事件的handler，其逻辑是发布一个集成事件，所以我比较疑惑：\n 我应该在集成事件处理器里做这两件事还是在领域事件处理器里做这两件事呢？\n如果一个事件被多个handler订阅，对于处理器的命名有没有什么约定和建议呢？\n谢谢老师解答~","like_count":1,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485882,"discussion_content":"你的理解是对的，应该定义新用户注册领域事件的优惠券发放handler，来处理优惠券的发放。\n\n集成事件的目的是将事件传播给其它的微服务，它本质上也是为了传递领域事件。\n\n领域事件处理handler一般会组织到以各自聚合根命名的目录下，用以区分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583565136,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809168,"avatar":"","nickname":"Geek_7c4953","note":"","ucode":"359745D4725D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196912,"discussion_content":"我的理解是新建购物车和发放优惠券肯定会在其他事件或者命令中用到.所以这两个是命令的响应(Response).而领域事件处理器只需要发送创建购物车命令,发送发放优惠券命令和发布集成事件三行代码.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583383991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274950,"user_name":"石马猿","can_delete":false,"product_type":"c3","uid":1113675,"ip_address":"","ucode":"A3D219DC6C9161","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/4b/98ce96e1.jpg","comment_is_top":false,"comment_ctime":1611227926,"is_pvip":false,"replies":[{"id":100366,"content":"感谢提醒，努力改进中","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1612011227,"ip_address":"","comment_id":274950,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"感觉老师的内容确实不错，挺用心准备的，但是英文发音不敢恭维，内容这么好，发音拖后踢了，😳","like_count":0,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514169,"discussion_content":"感谢提醒，努力改进中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612011227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183013,"user_name":"stg609","can_delete":false,"product_type":"c3","uid":1073025,"ip_address":"","ucode":"FB70A75A891BB8","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/81/1c614f4a.jpg","comment_is_top":false,"comment_ctime":1582911624,"is_pvip":false,"replies":[{"id":70993,"content":"Event Handler是处理业务副作用的逻辑，本质上与用户发起的命令是一样的，只是它的发起是由事件驱动的，因此与命令处理Handler处于同层。","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1583044877,"ip_address":"","comment_id":183013,"utype":1}],"discussion_count":5,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"Domain event handler 放在应用层的考虑是什么？","like_count":0,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485529,"discussion_content":"Event Handler是处理业务副作用的逻辑，本质上与用户发起的命令是一样的，只是它的发起是由事件驱动的，因此与命令处理Handler处于同层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583044877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194551,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/37/06440c7f.jpg","nickname":"fish","note":"","ucode":"ABA0945C8B9615","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238740,"discussion_content":"个人理解，领域层是界限内聚合的数据处理，应用层主要作用是对各聚合，领域服务和限界外的领域元素进行编排。集成事件handler很大可能是跨限界使用，所以放在应用层更合适","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587226689,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809168,"avatar":"","nickname":"Geek_7c4953","note":"","ucode":"359745D4725D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196908,"discussion_content":"我也在想这个,不太能理解老师这里说的&#34;副作用&#34;.领域事件的处理不应该是正常的业务逻辑吗?不应该放在核心的领域层吗?\n相对的命令是外部来的,放在应用层是合情合理.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583383597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809168,"avatar":"","nickname":"Geek_7c4953","note":"","ucode":"359745D4725D4F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200165,"discussion_content":"你要从两个层面来理解：\n一、同一个微服务中，如果有两个聚合，那当访问A聚合时，发现还要操作B聚合，传统的三层那种思路是直接引用就行，java里面有一个领域服务层的概念，当然这里也有这个意思，只是体现的不明显，像handler就是领域服务。通过在领域层定义event，然后在通过该事件触发应用层中的Handler，此时这个handler可以操作B聚合的业务了。以达到跨聚合业务操作的目的。\n二、在一个微服务中，想调用另外一个微服务的功能，此时按照一的流程照样操作，只不过handler中的调用就不是B聚合了，而是通过CAP通过发布/订阅的方式调用另外一个微服务的功能。\n所以，应用层中的handler是可以变向的理解为领域服务，但还是建议将handler放置在应用层这个目录中。而command和query文件夹相当于真正的应用层了。以上仅为个人理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583663266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":196908,"ip_address":"","group_id":0},"score":200165,"extra":""},{"author":{"id":1809168,"avatar":"","nickname":"Geek_7c4953","note":"","ucode":"359745D4725D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1065351,"avatar":"https://static001.geekbang.org/account/avatar/00/10/41/87/d26efb2e.jpg","nickname":"SuperSnow","note":"","ucode":"84C89AA8083E6A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201734,"discussion_content":"我看了老师上面的回复，感觉是跟我后来想的一样。就是发布集成事件的Handler在应用层（符合老师说的副作用），而调用领域实体的Handler放在领域层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583832707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":200165,"ip_address":"","group_id":0},"score":201734,"extra":""}]}]},{"had_liked":false,"id":182437,"user_name":"木风","can_delete":false,"product_type":"c3","uid":1339677,"ip_address":"","ucode":"3BAA80C2F1FB68","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/1d/8d1d27b2.jpg","comment_is_top":false,"comment_ctime":1582788197,"is_pvip":false,"replies":[{"id":70999,"content":"DispatchDomainEventsAsync仅在领域模型持久化保存时触发，这时它会对领域模型里记录的事件进行处理，不会不断地主动扫。","user_name":"作者回复","user_name_real":"肖伟宇","uid":1756585,"ctime":1583045166,"ip_address":"","comment_id":182437,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"肖老师，请问DispatchDomainEventsAsync是通过判断领域实体内是否有事件产生，有则发布，对吧？如果是这样，是不是意味着这DispatchDomainEventsAsync需要循环被调用，不断地扫描看是否有新事件产生？\n如果是的话，这任务又在哪里被循环调用了？ 谢谢","like_count":0,"discussions":[{"author":{"id":1756585,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/a9/791d0f5e.jpg","nickname":"老肖想当外语大佬","note":"","ucode":"F662D1BF671E92","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485337,"discussion_content":"DispatchDomainEventsAsync仅在领域模型持久化保存时触发，这时它会对领域模型里记录的事件进行处理，不会不断地主动扫。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583045166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1158550,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ad/96/249d1643.jpg","nickname":"moonfeeling","note":"","ucode":"85A2EAFF2ABA36","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":188631,"discussion_content":"是没有任务不停的扫描的。而是利用DBContext的实体跟踪能力，实体中有一个集合，集合里存放有领域事件，每次SaveEntitiesAsync的时候会调用DispatchDomainEventsAsync进而把实体中的领域事件发送出去。SaveEntitiesAsync是在你每次写操作执行的，执行的同事就抛出领域事件了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582815965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243331,"user_name":"峰","can_delete":false,"product_type":"c3","uid":1390326,"ip_address":"","ucode":"527BB65559F0B0","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/f6/d65b7302.jpg","comment_is_top":false,"comment_ctime":1598063148,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"在大量请求时会发送很多命令，使用mediatr 会造成消息阻塞吗？","like_count":1},{"had_liked":false,"id":233225,"user_name":"小庞","can_delete":false,"product_type":"c3","uid":1554764,"ip_address":"","ucode":"7C8367CDB47163","user_header":"https://static001.geekbang.org/account/avatar/00/17/b9/4c/8c9edc85.jpg","comment_is_top":false,"comment_ctime":1594264438,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100044601,"comment_content":"IPipeLineBehavior只能用于处理IRequestHandler，不能用于处理INotificationHandler\nhttps:&#47;&#47;github.com&#47;jbogard&#47;MediatR&#47;wiki&#47;Behaviors\nThe pipeline behaviors are only compatible with IRequestHandler&lt;TRequest,TResponse&gt; and can&#39;t be used with INotificationHandler&lt;TRequest&gt;.","like_count":1},{"had_liked":false,"id":349568,"user_name":"再见理想","can_delete":false,"product_type":"c3","uid":1245999,"ip_address":"","ucode":"FAC88B3F6F6DFD","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/2f/0a5e0751.jpg","comment_is_top":false,"comment_ctime":1656071165,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100044601,"comment_content":"builder.Services.AddCap(options =&gt;\n    {\n        options.UseEntityFramework&lt;CraneDbContext&gt;();\n        options.UseRabbitMQ(options =&gt;\n        {\n            builder.Configuration.GetSection(&quot;RabbitMQ&quot;).Bind(options);\n        });\n    });\n\nCraneDbContext构造函数中有ICapPublisher ，ICapPublisher无法通过依赖注入获取到，不知道大家有没有遇到这个问题","like_count":0,"discussions":[{"author":{"id":3048731,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/85/1b/a3a307ca.jpg","nickname":"WEIW","note":"","ucode":"3F99E124FB9301","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589139,"discussion_content":"是的，CAP和DbContext循环依赖了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664442294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}