{"id":502058,"title":"13 ｜DI Container（1）：如何实现基本的DI容器结构？","content":"<p>你好，我是徐昊。从今天开始，我们就来使用TDD的方式实现注入依赖容器。</p><p>在上节课，我们参照其他依赖注入容器，介绍了依赖注入容器的大致功能。现在请回想一下TDD的流程（参看<a href=\"https://time.geekbang.org/column/article/496703\">第11讲</a>）：</p><p><img src=\"https://static001.geekbang.org/resource/image/a5/9c/a5a74d26cf9581064420d81cff7da89c.jpg?wh=2284x1285\" alt=\"\"><br>\n现在我们需要将需求分解为功能点，并构想架构愿景。</p><h2>将需求分解为功能点</h2><p>对于组件构造部分，我分解的任务如下：</p><ul>\n<li>\n<p>无需构造的组件——组件实例</p>\n</li>\n<li>\n<p>如果注册的组件不可实例化，则抛出异常</p>\n<ul>\n<li>抽象类</li>\n<li>接口</li>\n</ul>\n</li>\n<li>\n<p>构造函数注入</p>\n<ul>\n<li>无依赖的组件应该通过默认构造函数生成组件实例</li>\n<li>有依赖的组件，通过Inject标注的构造函数生成组件实例</li>\n<li>如果所依赖的组件也存在依赖，那么需要对所依赖的组件也完成依赖注入</li>\n<li>如果组件有多于一个Inject标注的构造函数，则抛出异常</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>字段注入</p>\n<ul>\n<li>通过Inject标注将字段声明为依赖组件</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果字段为final则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n<li>\n<p>方法注入</p>\n<ul>\n<li>通过Inject标注的方法，其参数为依赖组件</li>\n<li>通过Inject标注的无参数方法，会被调用</li>\n<li>按照子类中的规则，覆盖父类中的Inject方法</li>\n<li>如果组件需要的依赖不存在，则抛出异常</li>\n<li>如果方法定义类型参数，则抛出异常</li>\n<li>如果组件间存在循环依赖，则抛出异常</li>\n</ul>\n</li>\n</ul><!-- [[[read_end]]] --><p>对于依赖选择部分，我分解的任务列表如下：</p><ul>\n<li>\n<p>对Provider类型的依赖</p>\n<ul>\n<li>注入构造函数中可以声明对于Provider的依赖</li>\n<li>注入字段中可以声明对于Provider的依赖</li>\n<li>注入方法中可声明对于Provider的依赖</li>\n</ul>\n</li>\n<li>\n<p>自定义Qualifier的依赖</p>\n<ul>\n<li>注册组件时，可额外指定Qualifier</li>\n<li>注册组件时，可从类对象上提取Qualifier</li>\n<li>寻找依赖时，需同时满足类型与自定义Qualifier标注</li>\n<li>支持默认Qualifier——Named</li>\n</ul>\n</li>\n</ul><p>对于生命周期管理部分，我分解的任务列表如下：</p><ul>\n<li>\n<p>Singleton生命周期</p>\n<ul>\n<li>注册组件时，可额外指定是否为Singleton</li>\n<li>注册组件时，可从类对象上提取Singleton标注</li>\n<li>对于包含Singleton标注的组件，在容器范围内提供唯一实例</li>\n<li>容器组件默认不是Single生命周期</li>\n</ul>\n</li>\n<li>\n<p>自定义Scope标注</p>\n<ul>\n<li>可向容器注册自定义Scope标注的回调</li>\n</ul>\n</li>\n</ul><p>对于架构构想，我倾向于使用类似Guice、PicoContainer等框架，以代码方式来配置容器。而不是像Spring一样，主要依赖配置文件。</p><p>由于依赖注入容器的问题规模较小，我将采用经典TDD模式进行开发，因而也不需要对功能点进行进一步的分解了。</p><p>在进入红/绿/重构循环之前，我的build.gradle.kts文件如下所示：</p><pre><code>plugins {\n    `java-library`\n    &quot;jacoco&quot;\n}\nrepositories {\n    mavenCentral()\n}\ndependencies {\n    implementation(&quot;jakarta.inject:jakarta.inject-api:2.0.1&quot;)\n    testImplementation(&quot;org.junit.jupiter:junit-jupiter-api:5.8.2&quot;)\n    testImplementation(&quot;org.junit.jupiter:junit-jupiter-params:5.8.2&quot;)\n    testRuntimeOnly(&quot;org.junit.jupiter:junit-jupiter-engine:5.8.2&quot;)\n    testRuntimeOnly(&quot;org.junit.vintage:junit-vintage-engine:5.8.2&quot;)\n    testRuntimeOnly(&quot;org.junit.platform:junit-platform-runner:1.8.2&quot;)\n    testImplementation(&quot;org.mockito:mockito-core:4.3.1&quot;)\n    testImplementation(&quot;jakarta.inject:jakarta.inject-tck:2.0.1&quot;)\n}\ntasks.withType&lt;Test&gt;() {\n    useJUnitPlatform()\n}\njava {\n    sourceCompatibility = JavaVersion.VERSION_17\n    targetCompatibility = JavaVersion.VERSION_17\n}\n</code></pre><h2>进入红/绿/重构循环</h2><p>下面让我们进入TDD的红/绿/重构循环：</p><p><video poster=\"https://media001.geekbang.org/f659c14170b74b3abe8a5d9e7f7e6190/snapshots/a6670a01de8340fea4888aa4dbd15650-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/41cbc02-18016ad7d04-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/dbf1a284629c4fb49fb25eef4c132f52/43c50f60dfbd4299adee249bb54c901f-cb82b162cdd2b54e8d1c1747fef54fad-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>到这里，我们引入了Provider这样一个类似于Factory工厂方法的结构，得到了整个依赖注入容器的基本结构。</p><p>那么剩下的事情就是，我们要围绕DI容器的基本结构，对其进行更多功能上的完善。</p><h2>思考题</h2><p>在重构的时候，我采用的是增加一个平行实现（Parallel Implementation）。用平行实现替换原有功能，然后再删除原有实现的做法。你有没有不一样的做法？</p><p>欢迎把你的思考和想法分享在留言区，也欢迎你扫描详情页的二维码加入读者交流群。我们下节课再见！</p>","neighbors":{"left":{"article_title":"12｜实战中的TDD：RESTful API的开发框架","id":502056},"right":{"article_title":"14｜DI Container（2）：如何通过Sad Path为容器增加功能？","id":502584}},"comments":[{"had_liked":false,"id":343907,"user_name":"🐑","can_delete":false,"product_type":"c1","uid":2189689,"ip_address":"","ucode":"DE34B3B14287D1","user_header":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","comment_is_top":true,"comment_ctime":1651116035,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233720385059e+18","product_id":100109401,"comment_content":"TDD专栏福利大合集：<br><br>1、打卡赢好礼（4月23日-5月10日）：正在进行中，学习专栏第1-10讲并在留言区打卡，结束后奖励；<br><br>2、代码亲手评（5月底）：预计打卡结束后启动，完成前10讲的打卡，即可提交代码练习作业，徐昊老师会亲自点评；<br><br>3、线上带你练：根据专栏更新节奏和老师时间安排确定，徐昊老师会线上带四个同学手把手地改代码，敬请期待！<br><br>具体活动介绍见 👉 http:&#47;&#47;gk.link&#47;a&#47;11jPi","like_count":0},{"had_liked":false,"id":358029,"user_name":"努力努力再努力","can_delete":false,"product_type":"c1","uid":1493907,"ip_address":"广东","ucode":"0C6EEA28FCE8C7","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","comment_is_top":false,"comment_ctime":1663837261,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663837261","product_id":100109401,"comment_content":"问题： 在重构的时候，我采用的是增加一个平行实现（Parallel Implementation）。用平行实现替换原有功能，然后再删除原有实现的做法。你有没有不一样的做法？<br><br>1. 可以先新增一个新的方法 private static &lt;ComponentType&gt; void bind(Class&lt;ComponentType&gt; clazz, Provider&lt;ComponentType&gt; provider)<br>2. 调整原有的旧 bind 方法，改成调用 bind 方法 -----&gt;  此时需要重新执行测试，验证重构是否影响测试结果<br>3. 通过 inline method，消除上方的private方法","like_count":1},{"had_liked":false,"id":343695,"user_name":"keep_curiosity","can_delete":false,"product_type":"c1","uid":1246273,"ip_address":"","ucode":"794DC1D3FB9214","user_header":"https://static001.geekbang.org/account/avatar/00/13/04/41/082e2706.jpg","comment_is_top":false,"comment_ctime":1650985545,"is_pvip":false,"replies":[{"id":"125433","content":"jsr330里有一个 provider 就用了","user_name":"作者回复","user_name_real":"编辑","uid":"2537798","ctime":1650991650,"ip_address":"","comment_id":343695,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650985545","product_id":100109401,"comment_content":"Java8不是就提供了Supplier函数式接口么？为什么又搞一个Provider呢？有什么区别吗？","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567800,"discussion_content":"jsr330里有一个 provider 就用了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650991650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343575,"user_name":"lj","can_delete":false,"product_type":"c1","uid":2670731,"ip_address":"","ucode":"D4290EDA64CD73","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/JJuLc4x3zjuRHWI1bYDgCySL7bAKRjH9YCxgEXgicSVrQkZyyBFj1IF5SHxVgjqJQrXOoHaRU9FUp2Qsn45Lu3A/132","comment_is_top":false,"comment_ctime":1650938553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650938553","product_id":100109401,"comment_content":"老师，请问为啥在no args这个任务，测的是componentImplement会构造出component这个接口类型？我原本理解这个任务是对某个类能支持以默认构造函数构建就可以了，不理解的点是为啥要搞个interface，感觉应该是另外的一个任务。","like_count":0},{"had_liked":false,"id":342070,"user_name":"Geek_7c0961","can_delete":false,"product_type":"c1","uid":2277181,"ip_address":"","ucode":"B1482E64FF9E4E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ8aLz0tWdsZuMiaNUAd0dicSD9M6A77seMGFdHgvsQwOzN8ztYPiaJSo53DcbjQWUQpw4pf4rI2f7vg/132","comment_is_top":false,"comment_ctime":1649998934,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1649998934","product_id":100109401,"comment_content":"这节课确实和java语言关系不算太大了.还是希望老师能够再讲解的过程中淡化语言本身的特性.","like_count":0}]}