{"id":614501,"title":"12｜受控表单组件：如何开发受控的表单组件？","content":"<p>你好，我是杨文坚。今天我们为自研组件库增加表单组件。</p><p>表单技术，日常业务运用非常广泛，除了常见的用户注册和登录场景，信息填写操作、信息编辑操作和上传文件图片等操作都是基于表单技术的。所以很多前端组件库都会实现相关的表单组件，提供给开发者使用，尽量减少表单的开发工作量。</p><p>而表单组件的实现，都是基于“受控组件”的技术概念来实现的。那什么是受控组件和非受控组件呢？</p><h2>什么是受控组件和非受控组件？</h2><p>“受控组件”和“非受控组件”，是谁最先提出来的，目前无从得知，比较流行的描述来自React官方官网。</p><p>受控组件，按照React官网的<a href=\"https://zh-hans.reactjs.org/docs/forms.html#controlled-components\">描述</a>，就是用React.js 内部state来管理HTML表单的数据状态，同时也控制用户操作表单时的数据输入。这类被 React.js 以这种方式控制取值的表单输入元素就叫做“受控组件”。</p><p>非受控组件，React 官网的<a href=\"https://zh-hans.reactjs.org/docs/uncontrolled-components.html\">描述</a>是这样的，“在大多数情况下，我们推荐使用<strong>受控组件</strong>来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理”。</p><p>从描述可以得知，“受控组件”和“非受控组件”的技术概念，跟React.js等框架的关系耦合不大。简单来讲，<strong>“受控组件”就是通过内置统一状态或者数据管理来控制表单操作，而“非受控组件”就是使用原生HTML的表单特性来实现表操作</strong>。</p><!-- [[[read_end]]] --><p>因为这个技术概念，主要应用场景是表单场景，所以为了统一语义，避免产生歧义，我们对“受控组件”和“非受控组件”统一称为“受控表单组件”和“非受控表单组件”。而“受控组件”的理念，可以更优雅地设计实现表单组件的功能，也是业界Vue.js和React.js开发表单组件的首选技术方案，所以<strong>今天要实现的“表单组件”都是“受控表单组件”类型</strong>。</p><p>知道了两种表单组件的技术概念，那么两种组件各有什么优劣呢？在日常工作开发中又要怎么选择使用呢？</p><h2>受控表单组件和非受控表单组件各有什么优劣？</h2><p>我们直接看代码案例，用 Vue.js 3.x 实现一个注册表单的功能代码，做个实际的效果对比。</p><p>先用 Vue.js 3.x 基于非受控表单组件的概念实现一个注册表单：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;h1&gt;这是一个非受控表单组件&lt;/h1&gt;\n  &lt;form @submit=\"onSubmit\"&gt;\n    &lt;div&gt;\n      &lt;span&gt;用户名称：&lt;/span&gt;\n      &lt;input ref=\"inputUserName\" name=\"username\" type=\"text\" /&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;span&gt;密码：&lt;/span&gt;\n      &lt;input ref=\"inputPassword\" name=\"password\" type=\"password\" /&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;span&gt;确认密码：&lt;/span&gt;\n      &lt;input\n        ref=\"inputConfirmPassword\"\n        name=\"confirmPassword\"\n        type=\"password\"\n      /&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;button&gt;提交注册&lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/form&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { ref } from 'vue';\nconst inputUserName = ref&lt;HTMLInputElement&gt;();\nconst inputPassword = ref&lt;HTMLInputElement&gt;();\nconst inputConfirmPassword = ref&lt;HTMLInputElement&gt;();\n\nconst onSubmit = (e: Event) =&gt; {\n  e.preventDefault();\n  const formData = {\n    userName: inputUserName?.value?.value,\n    password: inputPassword?.value?.value,\n    confirmPassword: inputConfirmPassword?.value?.value\n  };\n  window.alert(`提交数据：${JSON.stringify(formData)}`);\n};\n&lt;/script&gt;\n</code></pre><p>然后再用&nbsp; Vue.js 3.x 基于受控表单组件概念，实现一个注册表单：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;h1&gt;这是一个受控表单组件&lt;/h1&gt;\n  &lt;form @submit=\"onSubmit\"&gt;\n    &lt;div&gt;\n      &lt;span&gt;用户名称：&lt;/span&gt;\n      &lt;input v-model=\"state.userName\" type=\"text\" /&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;span&gt;密码：&lt;/span&gt;\n      &lt;input v-model=\"state.password\" type=\"password\" /&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;span&gt;确认密码：&lt;/span&gt;\n      &lt;input v-model=\"state.confirmPassword\" type=\"password\" /&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n      &lt;button&gt;提交注册&lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/form&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { reactive, toRaw } from 'vue';\nconst state = reactive({\n  userName: '',\n  password: '',\n  confirmPassword: ''\n});\n\nconst onSubmit = (e: Event) =&gt; {\n  e.preventDefault();\n  const formData = toRaw(state);\n  window.alert(`提交数据：${JSON.stringify(formData)}`);\n};\n&lt;/script&gt;\n</code></pre><p>以上就是“非受控表单组件”和“受控表单组件”这两种表单组件的Vue.js 3.x代码实现方式，我们简单对比一下代码实现的复杂度和代码量：</p><p><img src=\"https://static001.geekbang.org/resource/image/05/8e/05cc464938c659822e30b920f5c0568e.jpg?wh=5000x1556\" alt=\"图片\"></p><p>如果我们在Vue.js 3.x环境里，再加上“数据监听”和“数据校验”这两个功能维度，会是怎样呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/98/93/98f2d8e0d47d072f2916e9425fab7b93.jpg?wh=5000x1862\" alt=\"图片\"></p><p>实现同样的注册表单的功能代码，受控表单组件的实现方式，明显比非受控表单组件更简单，而且更加方便数据字段的扩展。所以一般在开发组件库里的表单组件时，我们都基于“受控组件”的技术理念来开发“受控表单组件”。</p><p>但是，开发组件库的表单组件，使用“受控组件”的概念是远远不够的，组件库，一个很重要的优势是复用性，实际工作开发需求时，表单的功能需求是多种多样的。</p><p>举个例子，注册表单需要账号密码，输入框的表单要实现字段布局、数据定义和数据校验的操作，如果再加上一个协议同意的选择框，是不是表单布局需要改一下？表单校验函数也需要改一下？以此类推，每添加一个表单字段内容，都需要重复做一堆开发琐碎工作。</p><p>所以想要开发组件库里的表单组件，我们需要将“重复工作”抽象成组件库里的组件，提升表单开发的复用性和易用性，也就是要<strong>抽象表单通用逻辑，封装成统一受控的表单组件</strong>。那么，如何封装Vue.js 3.x的受控表单组件呢？</p><h2>怎么封装Vue.js3.x的受控表单组件？</h2><p>首先，我们要明白，传统表单是由一个个数据字段组成的，承载这些数据的显示和输入的是HTML里的&lt;input&gt;、&lt;select&gt;和&lt;option&gt;等元素。</p><p>这些元素，在组件库里承载表单字段里数据操作，通常有很多种称呼，例如“表单数据组件”“数据输入组件”“数据录入组件”，为了避免歧义，表单里类似&lt;input&gt;、&lt;select&gt;等承载表单数据功能的组件，我们就统一称为“表单数据组件”。同时，承载表单提交的能力的组件，比如HTML里&lt;form&gt;标签类似功能组件，我们就称为“表单组件”。</p><p>统一好组件库里各类组件的称呼，接下来，我们就开始分析如何封装Vue.js 3.x的受控表单组件，主要为三步。</p><p><strong>第一步，梳理出表单操作中可复用的逻辑。</strong>表单操作可以复用的逻辑是什么呢？</p><p>我们先来看看表单的主要操作，“数据显示”“数据输入”“数据校验”和“数据提交”这四个操作逻辑。</p><p>数据显示和输入，不同表单数据组件的操作会有差异。比如，&lt;input&gt;是输入内容，类似“填空题”，&lt;select&gt;是选择数据内容，类似“选择题”。这相当于两种不同类型“题目”，它们的“答题卷”都是分开的，无法统一。但，我们可以从这两种操作中抽象出一个共性，定义数据的字段名称，也就是在表单数据里定义这个数据的名称。</p><p>因此，这里我们就梳理出了第一个可复用逻辑，<strong>数据字段名称</strong>。</p><p>接下来是表单里的“数据校验”操作逻辑。数据校验的核心就是数据在“改变”和“提交”这两个时间点做处理，不受不同类型表单数据组件的用户使用方式差异的影响。那么我们可以再抽象出一个复用逻辑，就是<strong>数据校验</strong>。</p><p>小结一下，表单场景里，我们可以复用的逻辑是“数据字段名称”和“数据校验”，那接下来就要实现这个逻辑复用的实际功能组件了。</p><p><strong>第二步，把可以复用的逻辑功能封装成通用表单逻辑功能组件</strong>。“数据字段名称”和“数据校验”操作，都是跟着作用于每个表单里的“数据字段”的。通常在英文语境里，我们称呼这个表单的数据字段为“Field”，在此我们就统一用中文描述为“表单字段”。</p><p>现在要做什么就清晰了，我们要实现一个通用的“表单字段组件”，来统一管理“表单数据组件”里的“字段名称”和“数据校验”，同时也要“辅助”支持“表单组件”提交数据时候做统一的数据字段收集和统一的提交前校验，这个“辅助操作”我们后面再详讲。</p><p><strong>第三步，也就是实现代码的阶段。</strong>我们先画图设计一下实现流程，“表单字段组件”其实就是“表单数据组件”和“表单组件”之间的“桥梁”：</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/cb/cac23960d1a5190aeaef566381aeabcb.jpg?wh=6000x3543\" alt=\"图片\"></p><p>那我们再进一步细化“表单字段组件”发挥的具体的桥梁作用：</p><p><img src=\"https://static001.geekbang.org/resource/image/8c/2a/8c39bec076060639e1ff4a269a6cd52a.jpg?wh=6000x3151\" alt=\"图片\"></p><p>表单字段组件，给表单数据组件传递“字段名称”和“字段校验规则”，给表单组件也是传递“字段名称”和“字段校验规则”。</p><p>通过两张图，我们可以总结出一个实现代码的要素，需要一个“上下文”来给整个表单共享“字段名称”和“字段校验规则”的内容，而“表单字段组件”只是作为一个入口，在使用时帮忙把“字段名称”和“字段校验规则”注册到这个共享内容的“上下文”里。</p><p><strong>那么，要在Vue.js 3.x里实现跨组件的数据共享，有哪些方式呢？</strong></p><p>还记得前面我们讲过的内容不？在Vue.js 3.x里实现跨组件的数据共享，有Props结合Emits组件间数据通信、有用共享响应式数据文件方式，还有引入Pinia这个数据状态管理库等多种方式，但是实现起来太麻烦了。</p><p>我这里选择了Vue.js 3.x 的新特性， provide和inject。我们可以在父级组件用provide定义一个“共享数据”及其名称，在子组件里用inject，通过这个数据名称拿到这个父级组件的“共享数据”。如果这个“共享数据”是“响应式数据”类型，我们在子组件里修改这个“共享数据”就可以触发响应式特性，影响到父组件和其他子组件的操作。反之，如果“共享数据”是“普通变量数据”，子组件里是无法修改影响父组件的。</p><p>好，我们现在就来实现具体的代码。</p><p>先定义各种数据类型：</p><pre><code class=\"language-typescript\">// 表单组件 实例的数据类型\nexport interface FormInstance {\n  addField(field: FormItemContext): void;\n}\n\n// 表单字段组件 实例的数据类型\nexport interface FormItemInstance {\n  validateField(): Promise&lt;ValidateResult&gt;;\n}\n\n// 表单字段组件 内置数据类型\nexport interface FormItemContext extends FormItemInstance {\n  label?: string;\n  name?: string;\n  rule?: ValidateRule;\n}\n\n// 表单组件 共享数据类型\nexport interface FormContext extends FormInstance {\n  model?: {\n    [key: string]: unknown;\n  };\n  formInstance?: FormInstance;\n}\n\n// 校验结果数据类型\nexport interface ValidateResult {\n  hasError: boolean;\n  name?: string;\n  value?: unknown;\n  message?: string;\n}\n\n// 校验规则数据类型\nexport interface ValidateRule {\n  // 字段校验方法\n  validator?: (value: unknown) =&gt; ValidateResult | Promise&lt;ValidateResult&gt;;\n}\n</code></pre><p>然后实现表单组件的代码，也是父级组件，用provide提供了一个“共享数据”：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;form :class=\"{ [className]: true }\"&gt;\n    &lt;slot /&gt;\n  &lt;/form&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { reactive, provide } from 'vue';\nimport { prefixName } from '../theme';\nimport { FORM_CONTEXT_KEY } from './common';\nimport type { FormInstance, FormContext, FormItemContext } from './types';\nconst className = `${prefixName}-form`;\n\nconst props = defineProps&lt;{ model?: FormContext['model'] }&gt;();\n\nconst fieldList: FormItemContext[] = [];\n\nconst addField = (field: FormItemContext) =&gt; {\n  fieldList.push(field);\n};\n\n// 共享数据 (共享上下文)\nconst formContext = reactive&lt;FormContext&gt;({\n  model: props.model,\n  addField\n});\n\nprovide&lt;FormContext&gt;(FORM_CONTEXT_KEY, formContext);\n\ndefineExpose&lt;FormInstance&gt;({\n  addField\n});\n&lt;/script&gt;\n\n</code></pre><p>现在我们再来实现“表单字段组件”：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;Row :class=\"{ [baseClassName]: true }\"&gt;\n    &lt;Row :class=\"labelClassName\"&gt;\n      &lt;Col :span=\"labelCol\"&gt;\n        &lt;span&gt;{{ props.label }}&lt;/span&gt;\n      &lt;/Col&gt;\n      &lt;Col :span=\"wrapperCol\"&gt;&lt;slot /&gt;&lt;/Col&gt;\n    &lt;/Row&gt;\n    &lt;Row :class=\"wrapperClassName\" v-if=\"props.name\"&gt;\n      &lt;Col :span=\"labelCol\"&gt;&lt;/Col&gt;\n      &lt;Col :span=\"wrapperCol\"&gt;\n        &lt;span v-if=\"errorTip\" :style=\"{ fontSize: 12, color: 'red' }\"&gt;{{\n          errorTip\n        }}&lt;/span&gt;\n      &lt;/Col&gt;\n    &lt;/Row&gt;\n  &lt;/Row&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { inject, onMounted, ref, toRaw, watch } from 'vue';\nimport Col from '../col';\nimport Row from '../row';\nimport { prefixName } from '../theme';\nimport { FORM_CONTEXT_KEY } from './common';\nimport type {\n  FormItemInstance,\n  FormContext,\n  ValidateRule,\n  ValidateResult\n} from './types';\n\nconst labelCol = 8;\nconst wrapperCol = 16;\n\nconst baseClassName = `${prefixName}-form-item`;\nconst labelClassName = `${baseClassName}-label`;\nconst wrapperClassName = `${baseClassName}-wrapper`;\n\nconst errorTip = ref&lt;string&gt;('');\n\nconst formContext: FormContext | undefined =\n  inject&lt;FormContext&gt;(FORM_CONTEXT_KEY);\n\nconst props = defineProps&lt;{\n  name?: string;\n  label?: string;\n  rule?: ValidateRule;\n}&gt;();\n\nasync function validateFieldValue(val: unknown): Promise&lt;ValidateResult&gt; {\n  if (props.rule?.validator) {\n    const result = await props.rule?.validator?.(val);\n    if (result.hasError &amp;&amp; result.message) {\n      errorTip.value = result.message;\n    } else {\n      errorTip.value = '';\n    }\n    return { ...result, ...{ name: props.name, value: toRaw(val) } };\n  }\n  return {\n    hasError: false\n  };\n}\n\nasync function validateField(): Promise&lt;ValidateResult&gt; {\n  if (props.rule?.validator &amp;&amp; props.name) {\n    const result = await validateFieldValue(formContext?.model?.[props?.name]);\n    if (result.hasError &amp;&amp; result.message) {\n      errorTip.value = result.message;\n    } else {\n      errorTip.value;\n    }\n    return result;\n  }\n  return {\n    hasError: false\n  };\n}\n\nonMounted(() =&gt; {\n  if (formContext?.model &amp;&amp; props.name &amp;&amp; formContext?.model?.[props?.name]) {\n    formContext?.addField({\n      name: props.name,\n      rule: props.rule,\n      validateField\n    });\n\n    watch([() =&gt; formContext?.model?.[props.name as string]], ([newValue]) =&gt; {\n      validateFieldValue(newValue);\n    });\n  }\n});\n\ndefineExpose&lt;FormItemInstance&gt;({\n  validateField\n});\n&lt;/script&gt;\n\n</code></pre><p>可以看出，这个表单字段组件，作为表单里子组件的身份使用时，将“字段名称”和“字段校验规则”存入统一上下文的“共享数据” （formContext）。</p><p>表单字段组件里，能根据字段名称，从共享数据里拿到当前管理的“字段数据”，就是包裹在表单数据组件里的数据。拿到这个字段数据和字段数据校验规则，我们可以在表单字段组件内部，监听这个数据变化，实现实时校验和提醒用户是否数据填写正确。</p><p>现在我们实现一个表单字段校验功能效果：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;div class=\"example\"&gt;\n    &lt;Form ref=\"formRef\" :model=\"model\"&gt;\n      &lt;FormItem label=\"数据1(数字校验)\" name=\"data1\" :rule=\"rule1\"&gt;\n        &lt;input v-model=\"model.data1\" /&gt;\n      &lt;/FormItem&gt;\n      &lt;FormItem label=\"数据2(字母校验)\" name=\"data2\" :rule=\"rule2\"&gt;\n        &lt;input v-model=\"model.data2\" /&gt;\n      &lt;/FormItem&gt;\n    &lt;/Form&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { ref, reactive } from 'vue';\nimport { Form } from '../src';\nimport { FormInstance } from '../src';\n\nconst { FormItem } = Form;\nconst formRef = ref&lt;FormInstance&gt;();\nconst model = reactive&lt;{ data1: string; data2: string }&gt;({\n  data1: '123',\n  data2: 'abc'\n});\n\nconst rule1 = {\n  validator: (val: string) =&gt; {\n    const hasError = /^[0-9]{1,}$/gi.test(`${val || ''}`) !== true;\n    return {\n      hasError,\n      message: hasError ? '仅支持0-9的数字' : ''\n    };\n  }\n};\n\nconst rule2 = {\n  validator: (val: string) =&gt; {\n    const hasError = /^[a-z]{1,}$/gi.test(`${val || ''}`) !== true;\n    return {\n      hasError,\n      message: hasError ? '仅支持a-z的大小写字母' : ''\n    };\n  }\n};\n&lt;/script&gt;\n</code></pre><p>代码是用表单组件、表单字段组件集合表单数据组件（原生HTML的&lt;input&gt;标签）实现的一个表单的实时数据校验，最终实现效果如动图所示：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c8/50/c8fd002b23d022ceb3032bcdb9069050.gif?wh=600x450\" alt=\"图片\"></p><p>好了，我们已经用表单组件里通用的“表单字段组件”，来管理每个“表单数据组件”，也就是实现了“桥梁”的一端，接下来就是要连接“桥梁”的另一端，也就是“表单组件”的提交数据的统一校验。</p><h2>如何给封装的受控表单组件做统一提交校验？</h2><p>在HTML里，原生的表单标签&lt;form&gt;是支持统一的submit事件的。我们现在要做的是，拦截这个表单事件，在提交数据前，从“共享数据”里拿到校验规则和所有数据来做数据校验，校验不通过就阻断表单提交。</p><p>具体代码如下：</p><pre><code class=\"language-xml\">&lt;template&gt;\n  &lt;form :class=\"{ [className]: true }\" @submit=\"handleSubmit\"&gt;\n    &lt;slot /&gt;\n  &lt;/form&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\" setup&gt;\nimport { reactive, provide, toRaw } from 'vue';\nimport { prefixName } from '../theme';\nimport { FORM_CONTEXT_KEY } from './common';\nimport type { FormInstance, FormContext, FormItemContext } from './types';\nconst className = `${prefixName}-form`;\n\nconst props = defineProps&lt;{ model?: FormContext['model'] }&gt;();\n\nconst fieldList: FormItemContext[] = [];\n\nconst addField = (field: FormItemContext) =&gt; {\n  fieldList.push(field);\n};\n\nconst resetFields = () =&gt; {\n  fieldList.forEach((field) =&gt; {\n    field?.resetField();\n  });\n};\n\nconst formContext = reactive&lt;FormContext&gt;({\n  model: props.model,\n  addField,\n  resetFields\n});\n\nprovide&lt;FormContext&gt;(FORM_CONTEXT_KEY, formContext);\n\ndefineExpose&lt;FormInstance&gt;({\n  addField,\n  resetFields\n});\n\nconst emits = defineEmits&lt;{\n  (event: 'submit', e: Event): void;\n  (event: 'finish', e: unknown): void;\n  (event: 'finishFail', e: unknown): void;\n}&gt;();\n\nconst validateFields = async () =&gt; {\n  const errorList = [];\n  for (let i = 0; i &lt; fieldList.length; i++) {\n    const field = fieldList[i];\n    const result = await field?.validateField();\n    if (result?.hasError) {\n      errorList.push(result);\n    }\n  }\n  return errorList;\n};\n\n// 统一处理表单提交\nconst handleSubmit = (e: Event) =&gt; {\n  e.stopPropagation();\n  e.preventDefault();\n  emits('submit', e);\n  if (props.model) {\n    // 表单提交前 处理所有字段校验\n    validateFields()\n      .then((errorList) =&gt; {\n        if (errorList.length &gt; 0) {\n          emits('finishFail', errorList);\n        } else {\n          emits('finish', toRaw(props.model));\n        }\n      })\n      .catch((e) =&gt; {\n        emits('finishFail', e);\n      });\n  }\n};\n&lt;/script&gt;\n\n</code></pre><p>好了，至此我们就实现了一个完整的“受控表单组件”的基本组件内容，更多详细的代码实现细节，你可以查看完整代码案例。</p><h2>总结</h2><p>这节课我们主要学习了如何在Vue.js 自研组件库场景下实现“受控表单组件”，有两个掌握重点。</p><p>第一个重点“什么是受控组件和非受控组件”，我们了解了“受控组件”的技术概念，同时如何在Vue.js 3.x的框架环境，实现它描述的“受控”能力。</p><p>当然，你也要知道，这个技术概念并不是React.js或者Vue.js专有的，任何Web框架，只要能以统一的“数据状态”来代替HTML原生能力管理表单，就可以算是“受控组件”概念的技术实现。</p><p>第二个重点“如何抽象表单组件的复用逻辑”。这里你会发现最终抽选出来的逻辑核心就是“表单数据校验”。没错，表单最复杂、最核心的一个逻辑就是“数据校验”，如果以后你遇到要实现表单场景的功能，我希望你把数据校验操作作为首要的技术考虑点。</p><h2>思考题</h2><p>表单组件除了劫持代理“submit”事件，还有其它的方式来管理表单提交数据的操作吗？</p><p>欢迎你留言参与讨论，如果有疑问也欢迎评论，下一讲见。</p><h3><a href=\"https://github.com/FE-star/vue3-course/tree/main/chapter/12\">完整的代码在这里</a></h3>","comments":[{"had_liked":false,"id":364951,"user_name":"初烬","can_delete":false,"product_type":"c1","uid":1507277,"ip_address":"陕西","ucode":"7ED4A301A7CC11","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/rUqhSN2OVg5aHw10Hxib61nGv1SXxD6zowFl27oSm9Y6g8grRpTxCxwk7qg14a1TtmpzMTM2y810MnibBhwn75Mg/132","comment_is_top":false,"comment_ctime":1671778385,"is_pvip":false,"replies":[{"id":134981,"content":"您好，谢谢指正，本课的案例是优先实现功能点，部分边缘场景没考虑到或者考虑不周。本课中动态表单数据，一开始的最简单的设计思路中，默认都是字符串数据。","user_name":"作者回复","user_name_real":"编辑","uid":3217031,"ctime":1678613934,"ip_address":"浙江","comment_id":364951,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"if (formContext?.model &amp;&amp; props.name &amp;&amp; formContext?.model?.[props?.name]) 这里是不是写错了。如果model[&#39;name&#39;],初始化为null 岂不是不执行addField方法？","like_count":2,"discussions":[{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":608698,"discussion_content":"您好，谢谢指正，本课的案例是优先实现功能点，部分边缘场景没考虑到或者考虑不周。本课中动态表单数据，一开始的最简单的设计思路中，默认都是字符串数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678613934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394111,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1725858286,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100311101,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":368808,"user_name":"庄周梦蝶","can_delete":false,"product_type":"c1","uid":1693576,"ip_address":"浙江","ucode":"7878ED3EB11E97","user_header":"https://static001.geekbang.org/account/avatar/00/19/d7/88/7dcde249.jpg","comment_is_top":false,"comment_ctime":1676732903,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100311101,"comment_content":"感觉难的是各种不满足需求的表单组件，要自己二次封装。比如可编辑列表，作为表单的输入组件，然可编辑列表里面又有各种组件","like_count":0},{"had_liked":false,"id":364894,"user_name":"ll","can_delete":false,"product_type":"c1","uid":1296458,"ip_address":"四川","ucode":"57C5DAC5B51036","user_header":"https://static001.geekbang.org/account/avatar/00/13/c8/4a/3a322856.jpg","comment_is_top":false,"comment_ctime":1671675414,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":1,"score":2,"product_id":100311101,"comment_content":"看完思考题突然有个疑问，就是一定要用 form 吗？因为受控表单很重要一点就是劫持代理 submit 事件，那换一个没有原生 submit 事件的元素，像是div，会不会方便点，不知可行不，会不会有意想不到的效果？","like_count":0,"discussions":[{"author":{"id":2625788,"avatar":"https://static001.geekbang.org/account/avatar/00/28/10/fc/213c381f.jpg","nickname":"请叫我潜水员","note":"","ucode":"9AF80FF19CD6F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597545,"discussion_content":"不用form的submit，也可以直接写一个button提交，form提供一个检验函数，然后通过$refs执行这个函数，通过了再提交数据也是可以的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1671999333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3217031,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/TZnA0PlXExlp9byxOxCeOG6ia0ykwfpxqAq2vslTzL1z5ibTBsgf1nYx0bUXgrOTnSOnmdXQZZibYx9tRSPHFjibPQ/132","nickname":"文坚老师","note":"","ucode":"4E0C838B2A3725","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599758,"discussion_content":"其实是可以的，很复杂场景甚至不能用form。但用form也有一些好处，例如无障碍化之类的会相对好做些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673771388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}