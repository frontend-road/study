{"id":740897,"title":"附录 A 从 Spring Boot 2. 升级到 3.0","content":"\n<p>截至本书编写时，Spring Framework 和 Spring Boot 都分别发布了 6.0.0-M3 和 3.0.0-M2 版本，这是大版本正式发布前的里程碑版本，预计正式版本将在 2022 年底发布。届时，我们将会面临是否要使用新版本进行开发，或者是否要对现有系统进行升级的问题。所以在本书的附录部分，介绍一下与升级有关的内容。</p>\n<h2 id=\"nav_point_258\">A.1 升级判断标准</h2>\n<p>先来回答第一个问题——要不要使用新版本呢？我们可以从以下几个角度来衡量。</p>\n<ul>\n<li>能否使用 Java 17 版本。从 Spring Framework 6 开始，支持的最低版本就是 Java 17，如果无法满足这条硬性要求，那就不用考虑其他问题了。<span class=\"comment-number\">1</span></li>\n<li>组织上是否有统一的安排。例如很多公司都有负责框架等组件的中间件团队，对于内部使用的框架都有一定要求，那应该遵循公司标准进行版本选型。</li>\n<li>框架及系统周边的生态是否提供了完整的支持。在开发过程中除了 Spring 家族的一系列组件，还会用到很多东西，这些组件或设施是否能够满足新版本的最低要求，能否提供一定的兼容性是需要进行评估的。</li>\n<li>是否有比较重的技术债。大版本升级不是没有成本的，此次升级就涉及了不少代码的修改。一些老系统本身就非常复杂，再对系统进行基础组件升级会带来很多不确定性。</li>\n</ul>\n\n<p>对于大部分系统来说，<strong>满足业务需求会比使用新技术重要得多</strong>，所以如果没有很强烈的诉求，可以不用急着去升级。但如果条件允许，又有使用新版本的意愿，那可以按照官方的指引，结合实际系统情况进行升级或者从零开始搭建新系统。</p>\n<h2 id=\"nav_point_259\">A.2 升级操作</h2>\n<p>这部分我们仍然会用二进制奶茶店的例子来做演示，将它从 Spring Boot 2.6.3 升级到 Spring Boot 3.0.0-M2，同时将 Spring Boot 底层依赖的 Spring Framework 从 5.3.15 升级到 6.0.0-M3。在开始项目升级之前，<strong>记得先安装好 JDK 17</strong>。<span class=\"comment-number\">2</span></p><!-- [[[read_end]]] -->\n\n<blockquote>\n<p><strong>请注意</strong> 目前 Spring Cloud 2021.0.x 还只能兼容到 Spring Boot 2.6.<em>x</em> 版本，相关组件还不能完全适配 Spring Boot 3.0.0-M2。这是上文提到的周边生态的支持尚不完善的例子。所以我们在演示时会使用第 10 章的 binarytea-jwt-auth 和 customer-jwt-auth 作为基础来进行升级。</p>\n</blockquote>\n<h3 id=\"nav_point_260\">A.2.1 依赖组件升级</h3>\n<p>升级的第一步就是在 pom.xml 中升级所依赖的各个组件的版本，其实主要是升级 Spring Boot 的版本，这样就能间接完成大部分依赖的升级，如代码示例 A-1 所示 <span class=\"comment-number\">3</span>，我们将 <code>&lt;parent/&gt;</code> 中的版本修改为 3.0.0-M2。由于 Spring Framework 6.0 的最低 Java 版本要求是 17，所以将 <code>java.version</code> 改为 17。</p>\n\n<blockquote>\n<p><strong>代码示例 A-1</strong> pom.xml 中的 Spring Boot 版本配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n &lt;parent&gt;\n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n &lt;version&gt;3.0.0-M2&lt;/version&gt;\n &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n &lt;/parent&gt;\n &lt;groupId&gt;learning.spring&lt;/groupId&gt;\n &lt;artifactId&gt;binarytea&lt;/artifactId&gt;\n &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n &lt;name&gt;BinaryTea&lt;/name&gt;\n &lt;description&gt;BinaryTea Service&lt;/description&gt;\n &lt;properties&gt;\n &lt;java.version&gt;17&lt;/java.version&gt;\n &lt;/properties&gt;\n &lt;!-- 省略部分内容 --&gt;\n&lt;/project&gt;</code></pre>\n<p>第二步是调整非 Spring Boot 管理依赖项的版本，在 BinaryTea 工程中，主要是我们用到的 Jadira UserType 和 Jackson DataType，如代码示例 A-2 所示。</p>\n<blockquote>\n<p><strong>代码示例 A-2</strong> pom.xml 中的依赖版本</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n &lt;!-- 省略部分内容 --&gt;\n &lt;dependencies&gt;\n &lt;dependency&gt;\n &lt;groupId&gt;org.jadira.usertype&lt;/groupId&gt;\n &lt;artifactId&gt;usertype.core&lt;/artifactId&gt;\n &lt;version&gt;7.0.0.CR1&lt;/version&gt;\n &lt;/dependency&gt;\n &lt;dependency&gt;\n &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;\n &lt;artifactId&gt;jackson-datatype-joda-money&lt;/artifactId&gt;\n &lt;version&gt;2.13.2&lt;/version&gt;\n &lt;/dependency&gt;\n &lt;dependency&gt;\n &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;\n &lt;artifactId&gt;jackson-datatype-hibernate5-jakarta&lt;/artifactId&gt;\n &lt;version&gt;2.13.2&lt;/version&gt;\n &lt;/dependency&gt;\n &lt;!-- 省略部分内容 --&gt;\n &lt;/dependencies&gt;\n &lt;!-- 省略部分内容 --&gt;\n&lt;/project&gt;</code></pre>\n<p>usertype.core 6.0.1.GA 不支持 Java 17，启动时就会报错，需要升级到 7.0.0.CR1。此外，老版本中还会依赖 Hibernate，在 Jakarta EE 9 下，需要排除这个依赖，不过 7.0.0.CR1 中没有这个依赖。Jackson DataType 的版本主要跟随 Spring Boot 中的 Jackson JSON 版本而定，这里就需要升级到 2.13.2。</p>\n<blockquote>\n<p><strong>请注意</strong> 由于 Jakarta EE 9 中更换了大量 API 和注解的包名，所以在这次版本升级后，很多组件都要做针对性的适配，至少也要适配 <code>javax</code> 包名到 <code>jakarta</code> 包名的变化。很多组件给出了带 <code>-jakarta</code> 后缀的 ArtifactId，例如 Hibernate Core 就有 hibernate-core-jakarta，Spring Boot Data JPA 已经调整了依赖项，而对应的 Jackson DataType 就有 jackson-datatype-hibernate5-jakarta。Tomcat 10 支持 Jakarta EE 9，tomcat-embed-core 的 10.0.18 包里就直接内置了 <code>jakarta.servlet</code> 的包。</p>\n</blockquote>\n<p>最后，由于我们还在使用 Milestone 版本的 Spring Boot，所以需要额外配置 Spring 的 Maven 仓库，具体如代码示例 A-3 所示。</p>\n<blockquote>\n<p><strong>代码示例 A-3</strong> pom.xml 中的仓库配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n &lt;!-- 省略部分内容 --&gt;\n &lt;repositories&gt;\n &lt;repository&gt;\n &lt;id&gt;spring-milestones&lt;/id&gt;\n &lt;name&gt;Spring Milestones&lt;/name&gt;\n &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n &lt;snapshots&gt;\n &lt;enabled&gt;false&lt;/enabled&gt;\n &lt;/snapshots&gt;\n &lt;/repository&gt;\n &lt;/repositories&gt;\n &lt;pluginRepositories&gt;\n &lt;pluginRepository&gt;\n &lt;id&gt;spring-milestones&lt;/id&gt;\n &lt;name&gt;Spring Milestones&lt;/name&gt;\n &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;\n &lt;snapshots&gt;\n &lt;enabled&gt;false&lt;/enabled&gt;\n &lt;/snapshots&gt;\n &lt;/pluginRepository&gt;\n &lt;/pluginRepositories&gt;\n&lt;/project&gt;</code></pre>\n<h3 id=\"nav_point_261\">A.2.2 代码修改</h3>\n<p>在升级到了 Jakarta EE 9 的前提下，原先很多以 <code>javax</code> 打头的包名都需要调整为以 <code>jakarta</code> 打头的包名，虽然 Spring Boot 兼容了一部分新老包名，但仍有一些代码需要调整，至少需要重新 <code>import</code> 代码。例如，JSR 202 Java Persistence API（JPA）的注解需要调整，JSR 303 Java Validation API 的注解也需要调整。</p>\n<p>我们从 Web 层开始往下逐层调整代码。在 <code>Controller</code> 类中，我们用到了 JSR 315 Java Servlet 和 JSR 303 Java Validation API，以 <code>MenuController</code> 和 <code>NewOrderForm</code> 为例，再加上 <code>JwtAuthenticationFilter</code> 中涉及的代码，需要改动的 <code>import</code> 内容如表 A-1 所示。<span class=\"comment-number\">4</span></p>\n\n<p><strong>表 A-1 Web 层要调整的 <code>import</code> 内容</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>调整前</p></th>\n<th><p>调整后</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>javax.servlet.http.HttpServletRequest</code></p></td>\n<td><p><code>jakarta.servlet.http.HttpServletRequest</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.servlet.http.HttpServletResponse</code></p></td>\n<td><p><code>jakarta.servlet.http.HttpServletResponse</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.validation.Valid</code></p></td>\n<td><p><code>jakarta.validation.Valid</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.validation.constraints.Max</code></p></td>\n<td><p><code>jakarta.validation.constraints.Max</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.validation.constraints.Min</code></p></td>\n<td><p><code>jakarta.validation.constraints.Min</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.validation.constraints.NotEmpty</code></p></td>\n<td><p><code>jakarta.validation.constraints.NotEmpty</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>在 Service 层里，主要添加了 <code>@Transactional</code> 注解，它属于 JSR 907 Java Transaction API（JTA），<code>import</code> 需要从 <code>javax.transaction.Transactional</code> 调整为 <code>jakarta.transaction.Transactional</code>。</p>\n<p>到了 Model 层的 <code>MenuItem</code>、<code>Order</code> 和 <code>Amount</code> 类上，我们使用了大量的 JPA 注解，具体的对应关系如表 A-2 所示。在单元测试中也有用到 JPA 注解，需要一并调整。</p>\n<p><strong>表 A-2 Model 层要调整的 <code>import</code> 内容</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>调整前</p></th>\n<th><p>调整后</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>javax.persistence.Column</code></p></td>\n<td><p><code>jakarta.persistence.Column</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.Embeddable</code></p></td>\n<td><p><code>jakarta.persistence.Embeddable</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.Entity</code></p></td>\n<td><p><code>jakarta.persistence.Entity</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.EnumType</code></p></td>\n<td><p><code>jakarta.persistence.EnumType</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.Enumerated</code></p></td>\n<td><p><code>jakarta.persistence.Enumerated</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.FetchType</code></p></td>\n<td><p><code>jakarta.persistence.FetchType</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.GeneratedValue</code></p></td>\n<td><p><code>jakarta.persistence.GeneratedValue</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.GenerationType</code></p></td>\n<td><p><code>jakarta.persistence.GenerationType</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.Id</code></p></td>\n<td><p><code>jakarta.persistence.Id</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.JoinColumn</code></p></td>\n<td><p><code>jakarta.persistence.JoinColumn</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.JoinTable</code></p></td>\n<td><p><code>jakarta.persistence.JoinTable</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.ManyToMany</code></p></td>\n<td><p><code>jakarta.persistence.ManyToMany</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.ManyToOne</code></p></td>\n<td><p><code>jakarta.persistence.ManyToOne</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.OneToMany</code></p></td>\n<td><p><code>jakarta.persistence.OneToMany</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.OrderBy</code></p></td>\n<td><p><code>jakarta.persistence.OrderBy</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.Table</code></p></td>\n<td><p><code>jakarta.persistence.Table</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.Temporal</code></p></td>\n<td><p><code>jakarta.persistence.Temporal</code></p></td>\n</tr>\n<tr>\n<td><p><code>javax.persistence.TemporalType</code></p></td>\n<td><p><code>jakarta.persistence.TemporalType</code></p></td>\n</tr>\n</tbody>\n</table>\n<p>在 Customer 项目中也要做类似的调整，在 <code>JwtClientHttpRequestInitializer</code> 中还用到了 <code>@PostConstruct</code> 注解，它属于 JSR 250，需要从 <code>javax.annotation.PostConstruct</code> 调整为 <code>jakarta.annotation.PostConstruct</code>。</p>\n<blockquote>\n<p><strong>请注意</strong> 在 BinaryTea 的 <code>OrderRepositoryTest</code> 测试类中，执行到 <code>testFindByMaker_NameLikeOrderByUpdateTimeDescId()</code> 测试时会抛出如下的异常：</p>\n<pre class=\"code-rows\"><code>org.springframework.dao.InvalidDataAccessApiUsageException: Parameter value [%lei%] did not match expected type [java.lang.Character (n/a)]; nested exception is java.lang.IllegalArgumentException: Parameter value [%lei%] did not match expected type [java.lang.Character (n/a)]</code></pre>\n<p>这是 Hibernate 5.6.6 和 5.6.7 中的一个已知缺陷，Hibernate 官方问题号是 HHH-15142，Spring Data JPA 的问题号是 2472。在 <code>CriteriaQuery</code> 中包含 <code>like</code> 谓语，且带有模式参数和转义符时，重复执行 <code>entityManager.createQuery()</code> 来创建该 <code>CriteriaQuery</code> 就会抛出 <code>IllegalArgumentException</code>。</p>\n<p>由于本书的示例选择了 Spring Boot 3.0.0-M2 来做演示，spring-boot-starter-data-jpa 依赖了 5.6.7.Final 的 hibernate-core-jakarta，所以有机会遇到这个缺陷，可以考虑将 Hibernate 降级到 5.6.5，或者等待官方提供补丁，升级到新版本。<span class=\"comment-number\">5</span></p>\n</blockquote>\n\n\n<br style=\"page-break-after:always\" />","comments":[]}