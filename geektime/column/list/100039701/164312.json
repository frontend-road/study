{"id":164312,"title":"01 | delete 0：JavaScript中到底有什么是可以销毁的","content":"<p>你好，我是周爱民，感谢你来听我的专栏。</p><p>今天是这个系列的第一讲，我将从JavaScript中最不起眼的、使用率最低的一个运算——delete讲起。</p><p>你知道，JavaScript是一门面向对象的语言。它很早就支持了delete运算，这是一个元老级的语言特性。但细追究起来，delete其实是从JavaScript 1.2中才开始有的，与它一同出现的，是对象和数组的字面量语法。</p><p>有趣的是，JavaScript中最具恶名的typeof运算其实是在1.1版本中提供的，比delete运算其实还要早。这里提及typeof这个声名狼藉的运算符，主要是因为delete的操作与类型的识别其实是相关的。</p><h2>习惯中的“引用”</h2><p>早期的JavaScript在推广时，仍然采用传统的数据类型的分类方法，也就是说，它宣称自己同时支持值类型和引用类型的数据，并且，所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的。这些都是当时“开发人员的概念集”中已经有的、容易理解的知识，不需要特别解释。</p><p>但是<span class=\"orange\">什么是引用类型呢？</span></p><p>在这件事上，JavaScript偷了个懒，它强行定义了“Object和Function就是引用类型”。这样一来，引用类型和值类型就给开发人员讲清楚了，对象和函数呢，也就可以理解了：它们按引用来传递和使用。</p><!-- [[[read_end]]] --><p>绝大多数情况下，这样解释起来是行得通的。但是到了delete运算这里，就不行。</p><p>因为这样一来，<code>delete 0</code>就是删除一个值，而<code>delete x</code>就既可能是删除一个值，也可能是删除一个引用。然而，当时JavaScript又同时约定：那些在global对象上声明的属性，就“等同于”全局变量。于是，这就带来了第三个问题：<code>delete x</code>还可能是删除一个global对象上的属性。而它在执行这个操作的时候，看起来却像是一个全局变量（的名字）。</p><p>这中间有哪些细节的区别呢？</p><p>delete这个运算的表面意思，是该运算试图销毁某种东西。然而，<code>delete 0</code>中的0是一个具体的、字面量表示的“值”。一个字面量值“0”如何在现实世界中销毁呢？假定它销毁了，那是不是说，在这个语言当前的运行环境中，就不能使用0这个值了呢？显然，这不合理。</p><p>所以，JavaScript认为“<strong>所有删除值的delete就直接返回true</strong>”，表明该行为过程中没有异常。很不幸，JavaScript 1.2的时代并没有结构化异常处理（即try…catch语句）。所以，通过函数调用中返回true来表明“没有异常”，其实是很常规的做法。</p><p>然而，返回值只表明执行过程中没有异常，但实际的执行行为是“什么也没发生”。你显然不可能真的将“0”从执行系统中清理出去。</p><p>那么接下来，就还剩下删除变量和删除属性。由于全局变量实际上是通过全局对象的属性来实现的，因此删除变量也就存在识别这两种行为的必要性。例如：</p><pre><code>delete x\n</code></pre><p>这行代码究竟是在删除什么呢？出于JavaScript是动态语言这项特性，从根本上来说，我们是没有办法在语法分析期来判断<code>x</code>的性质的。所以现在，需要有一种方法在运行期来标识<code>x</code>的性质，以便进一步地处理它。</p><p>这就导致了一种新的“引用”类型呼之欲出。</p><h2>到底在删除什么？</h2><p>探索工作往往如此，是所谓“进五退一”，甚至是“进五退四”。在今后的专栏文章中，你往往会看到，我在碰触到一种新东西的时候会竭力向前，但随后又后退好几步，再来讨论一些更基础层面的东西。这是因为如果不把这些基础概念说得清楚明白，那么往前冲的那几步常常就被带偏了方向。</p><p>一如现在这个问题：<span class=\"orange\"><code>delete 0</code>到底是在删除什么？</span></p><p>对于一门编译型语言来说，所谓“0”，就是上面所述的一个值，它可以是基础值（Primitive values），也可以是数值类型。但如果将这个问题上升到编译之前的、所谓语法分析的阶段，那么“0”就会被称为一个记号（Tokens）。一个记号是没有语义的，记号既可以是语言能识别的，也可以是语言不能识别的。唯有把这二者同时纳入语言范畴，那么这个语言才能识别所谓的“语法错误”。</p><p>delete不仅仅是要操作0或x这样的单个记号或标识符（例如变量）。因为这个语法实际起作用的是一个对象的属性，也就是“删除对象的成员”。那么它真正需要的语法其实是：</p><pre><code>delete obj.x\n</code></pre><p>只不过因为全局对象的成员可以用全局变量的形式来存取，所以它才有了</p><pre><code>delete x\n</code></pre><p>这样的语法语义而已。所以，这正好将你之前所认识的倒转过来，是删除x这个成员，而不是删除x这个值。不过终归有一点是没错的：既然没办法表达异常，而delete 0又不产生异常，那么它自然就该返回true。</p><p>然而，如果你理解了<code>delete obj.x</code>，那么就一定会想到：<code>obj.x</code>既不是之前说过的引用类型，也不是之前说过的值类型，它与<code>typeof(x)</code>识别的所有类型都无关。因为，它是一个表达式。</p><p>所以，delete这个操作的正式语法设计并不是“删除某个东西”，而是“<span class=\"orange\">删除一个表达式的结果</span>”：</p><pre><code>delete UnaryExpression\n</code></pre><h2>表达式的结果是什么？</h2><p>在JavaScript中表达式是一个很独特的东西，所有一切表达式运算的终极目的都是为了得到一个值，例如字符串。然后再用另外一些操作将这个值输出出来，例如变成网页中的一个元素（element）。这是JavaScript语言创生的原力，也是它的基础设计。也只是因为有了这种设计，它才变得既像面向对象的，又像函数式语言的样子。</p><p>表达式的执行特性，以及表达式与语句的关系等等细节，回头我放在第二阶段的内容中讲给你听。现在我们只需要关注一个要点，表达式计算的结果到底是什么？因为就像上面所说的，这个结果，才是<code>delete</code>这个操作要删除的东西。</p><p>在JavaScript中，有两个东西可以被执行并存在执行结果（Result），包括语句和表达式。比如你用<code>eval()</code>来执行一个字符串，那么实际上，你执行的是一个语句，并返回了语句的值；而如果你使用一对括号来强制一个表达式执行，那么这个括号运算得到的，就是这个表达式的值。</p><p>表达式的值，在ECMAScript的规范中，称为“引用”。</p><p>这是一种称为“规范类型”的东西。</p><h2>规范中的“引用”</h2><p>实际上这个概念出现得也很早。从JavaScript 1.3开始，ECMAScript规范就在语言定义的层面，正式地将上述的天坑补起来，推出了上面说到的这个“（真正的）引用类型”。</p><p>但是，由于这个时候规范的影响力在开发人员中并不那么大，所以开发人员还是习惯性地将对象和函数称为引用，而其它类型就称为值，并且继续按照传统的理解来解释JavaScript中对数据的处理。</p><p>这种情况下，一个引用只是在语法层面上表达“它是对某种语法元素的引用”，而与在执行层面的值处理或引用处理没关系。所以，下面这行简短的语句：</p><pre><code>delete 0\n</code></pre><p>实际上是在说：JavaScript将0视为一个表达式，并尝试删除它的求值结果。</p><p>所以，现在这里的0，其实不是值（Value）类型的数据，而是一个表达式运算的结果（Result）。而在进一步的删除操作之前，JavaScript需要检测这个Result的类型：</p><ul>\n<li>如果它是值，则按照传统的JavaScript的约定返回true；</li>\n<li>如果它是一个引用，那么对该引用进行分析，以决定如何操作。</li>\n</ul><p>这个检测过程说明，ECMAScript约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用。并且需要留意的是，在这个描述中，所谓对象，其实也是值。准确地说，是“非引用类型”。例如：</p><pre><code>delete {}\n</code></pre><p>那么显然，这里要删除的一对大括号是表示一个字面量的对象，当它被作为表达式执行的时候，结果也是一个值。这也是我常常将所有这类表达式称为“单值表达式”的原因，这里并没有所谓的“引用”。</p><p>你可以像下面这样，非常细致而准确地解释这一行代码：<span class=\"orange\">单值表达式的运算结果返回那个“对象字面量”的单值</span>。然后，<code>delete</code>运算发现它的操作数是“值/非引用类型”，就直接返回了true。</p><p>所以，什么也没有发生。</p><h2>还会发生什么</h2><p>那么到底还会发生什么呢？</p><p>在JavaScript的内部，所谓“引用”是可以转换为“值”，以便参与值运算的。因为表达式的本质是求值运算，所以引用是不能直接作为最终求值的操作数的。这依赖于一个非常核心的、称为“GetValue()”的内部操作。所谓内部操作，也称为内部抽象操作（internal abstract operations），是ECMAScript描述一个符合规范的引擎在具体实现时应当处理的那些行为。</p><p><code>GetValue()</code>是从一个引用中取出值来的行为。这有什么用呢？比如说下面这行代码：</p><pre><code>x = x\n</code></pre><p>我们上面说过，所谓x其实是一个引用。上面的表达式其实是一个赋值表达式，那么“引用x赋值给引用x”有什么意义呢？其实这在语法层面来解释是非常直接的：</p><blockquote>\n<p>所有赋值操作的含义，是将右边的“值”，赋给左边用于包含该值的“引用”。</p>\n</blockquote><p>那么上面的<code>x=x</code>，其实就是被翻译成：</p><pre><code>x = GetValue(x)\n</code></pre><p>来执行的。而JavaScript识别两个x的不同的方法，就称为“手性”，即是所谓“左手端(<em>lhs, left hand side</em>)”和“右手端(<em>rhs</em>)”。它本来是用来描述自然语言的语法中，一个修饰词应该是放在它的主体的前面或是后面的。而在程序设计语言中，它用来说明一个记号（Token）是放在了赋值符号（例如“=”号）的左边或是右边。作为一个简单的结论，区别上例中的两个x的方法就是：</p><blockquote>\n<p>如果x放在左边作为lhs，那么它是引用；如果放在右边作为rhs，那么就是值。</p>\n</blockquote><p>所以<code>x=x</code>的语义并不是“x赋给x”，而是“<strong>把值x赋给引用x</strong>”。</p><p>所以，“delete x”归根到底，是在<strong>删除一个表达式的、引用类型的结果（Result）</strong>，而不是在<strong>删除x表达式</strong>，或者这个<strong>删除表达式的值（Value）</strong>。</p><p>是的，在JavaScript中的<code>delete</code>是一个很罕见的、能直接操作“引用”的语法元素。由于这里的“引用”是在ECMAScript规范层面的概念，因此在JavaScript语言中能操作它的语法元素其实非常少。</p><p>然而很不幸，delete就是其中之一。</p><h2>告诉我这些有什么用</h2><p>等等，我想你一定会问了：神啊，让我知道这些究竟有什么用呢？我永远也不会去执行<code>delete 0</code>这样的操作啊！</p><p>是的。但是我接下来要告诉你的事实是：<code>obj.x</code>也是一个引用。对象属性存取是JavaScript的面向对象的基本操作之一，所以本质上我们早就在使用“引用”这个东西了，只不过它太习以为常，所以大家都视而不见。</p><p>“属性存取（\".\"运算符）”返回一个关于“x”的引用，然后它可以作为下一个操作符（例如函数调用运算“()”）的左手端来使用，这才有了著名的<span class=\"orange\">“对象方法调用”运算</span>：</p><pre><code>obj.x()\n</code></pre><p>因为在对象方法调用的时候，函数_x()_是来自于<code>obj.x</code>这个引用的，所以这个引用将<code>obj</code>这个对象传递给x()，这才会让函数_x()_内部通过this来访问到obj。</p><p>根本上来说，如果<code>obj.x</code>只是值，或者它作为右手端，那么它就不能“携带”obj这个对象，也就完成不了后续的方法调用操作。</p><blockquote>\n<p>对象存取 + 函数调用 = 方法调用</p>\n</blockquote><p>这是JavaScript通过连续表达式运算来实现新的语义/语法的经典示例。</p><p>而所谓“连续运算”其实是函数式运算范式的基本原则。也就是说，<code>obj.x()</code>是在JavaScript中集合了“引用规范类型操作”“函数式”“面向对象”和“动态语言”等多种特性于一体的一个简单语法。</p><p>而它对语言的基础特性的依赖，就在于：</p><ul>\n<li><code>delete 0</code>中的这个<code>0</code>是一个表达式求值；</li>\n<li><code>delete x</code>中的<code>x</code>是一个引用；</li>\n<li><code>delete obj.x</code>中<code>obj.x</code>是一组表达式连续运算的结果（Result/引用）；</li>\n</ul><p>于是，我们现在可以解释，当x是全局对象global的属性时，所谓<code>delete x</code>其实只需要返回<code>global.x</code>这个引用就可以了。而当它不是全局对象global的属性时，那么就需要从当前环境中找到一个名为<code>x</code>的引用。找到这两种不同的引用的过程，称为ResolveBinding；而这两种不同的<code>x</code>，称为不同环境下绑定的标识符/名字。</p><h2>知识回顾</h2><p>下一讲我将给你讲述的，就是这个名字从声明到发现的全过程。至于现在，这一讲就要告一段落了。今天的内容中，有一些知识点我来带你回顾一下。</p><ul>\n<li>delete 运算符尝试删除值数据时，会返回true，用于表示没有错误（Error）。</li>\n<li>delete 0的本质是删除一个表达式的值（Result）。</li>\n<li>delete x与上述的区别只在于Result是一个引用（Reference）。</li>\n<li>delete其实只能删除一种引用，即对象的成员（Property）。</li>\n</ul><p>所以，只有在<code>delete x</code>等值于<code>delete obj.x</code>时delete才会有执行意义。例如<code>with (obj) ...</code>语句中的delete x，以及全局属性global.x。</p><h2>思考题</h2><ul>\n<li>delete x中，如果x根本不存在，会发生什么？</li>\n<li>delete object.x中，如果x是只读的，会发生什么？</li>\n</ul><p>希望你喜欢我的分享。</p>","comments":[{"had_liked":false,"id":153190,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1574177447,"is_pvip":false,"replies":[{"id":"58951","content":"Oh~ 哈哈，你是说昨天有一个问题我只回复了3，没有回复1和2两条吗？那两条，是全对的，所以……嗯嗯，我只是没有回复确认而已。你对ECMAScript中的“引用规范类型”的使用场景和过程推演都是正确的。<br><br>关于今天的前3个问题，1是正确的。<br><br>2你也是对的。但是有一点，这个x的确会得到一个引用，称为（UnresolvableReference）。而这一段逻辑在ECMAScript里面写的是“if IsUnresolvableReference, then return true”。也就是说，ECMAScript约定对于这种情况就是这么返回的，这属于规范约定（并且如果在这时发现是严格模式，就抛异常了）。关于这里，你可以看一看：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-delete-operator-runtime-semantics-evaluation<br><br>不过问题3，你倒是提到了一个“少有人知”问题，哈哈，这个问题我是漏讲了，而且其实还挺有趣、挺关键的。<br><br>是这样，早期的JavaScript中，undefined是一个特殊值，是在运行期中通过void运算，或者不返回值的函数，又或者一个声明了但未赋值的变量，等等类似这样的情况来“计算得到”的。所以在JavaScript的早期版本中，你没有办法直接判断“undefined是undefined”，例如无法写出“x === undefined”这样的代码，而你只能写类似“typeof(x) ===&#39;undefined&#39;”这样的代码。<br><br>后来（其实也没有太久），规范就约定把undefined作为可以缺省访问的名字，类似于null。但是这个时候就带来了一个矛盾，因为这个undefined很重要，早期的绝大多数框架或引擎都把它作为一个“全局名字”给声明了。也就是说，ECMAScript现在既没有办法将它规范成一个keyword，也没有办法处理成保留字等等，它看起来像null，但又没有办法在规范层面强制它。所以……ECMAScript就搞了一个“奇招”：<br><br>&gt; 我们把undefined声明成全局的属性，怎么样？！<br><br>嗯嗯，很好。所以你看，现在的引擎上面undefined看起来长得跟null值差不多，而且在ECMAScript规范中它们都还是平级的（是原始值），而且它们的作用也很接近，最后他们都还是从最初的JavaScript 1.x中就存在的概念，但是undefined&#47;null两者却在实现上完全不同：undefined是一个全局属性，而null是一个关键字。<br><br>由于undefined是全局属性，所以`delete undefined`其实就是`delete global.undefined`，是删除引用，而不是删除值。而这个属性是只读的，所以就返回false了。<br><br>例如你可以试试下面的代码：<br><br>&gt; Object.getOwnPropertyDescriptor(global, &#39;undefined&#39;)<br>{ value: undefined,<br>  writable: false,<br>  enumerable: false,<br>  configurable: false }","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574222971,"ip_address":"","comment_id":153190,"utype":1}],"discussion_count":11,"race_medal":0,"score":"413891037863","product_id":100039701,"comment_content":"老师好，我又来了:-)<br><br>1.<br><br>delete 0<br><br>这里的0是一个值（就当前情况），而不是引用是吗？<br><br>2.<br><br>delete x (x不存在)<br><br>返回true<br><br>x 表达式返回的应该是一个引用，并且环境中并没有表示这个引用不能被删除，这个理解对吗？<br><br>但是文章中有提到delete只能删除属性这一种引用，糊涂了，估计这里的理解还是有问题。<br><br>3.<br><br>delete null 返回true<br><br>delete undefined 返回false 为啥啊？不都是值吗？<br><br>4. 还想知道昨天提问的1和2两条是不是漏洞百出啊，就想知道个结果😁。","like_count":96,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475076,"discussion_content":"Oh~ 哈哈，你是说昨天有一个问题我只回复了3，没有回复1和2两条吗？那两条，是全对的，所以……嗯嗯，我只是没有回复确认而已。你对ECMAScript中的“引用规范类型”的使用场景和过程推演都是正确的。\n\n关于今天的前3个问题，1是正确的。\n\n2你也是对的。但是有一点，这个x的确会得到一个引用，称为（UnresolvableReference）。而这一段逻辑在ECMAScript里面写的是“if IsUnresolvableReference, then return true”。也就是说，ECMAScript约定对于这种情况就是这么返回的，这属于规范约定（并且如果在这时发现是严格模式，就抛异常了）。关于这里，你可以看一看：\nhttps://tc39.es/ecma262/#sec-delete-operator-runtime-semantics-evaluation\n\n不过问题3，你倒是提到了一个“少有人知”问题，哈哈，这个问题我是漏讲了，而且其实还挺有趣、挺关键的。\n\n是这样，早期的JavaScript中，undefined是一个特殊值，是在运行期中通过void运算，或者不返回值的函数，又或者一个声明了但未赋值的变量，等等类似这样的情况来“计算得到”的。所以在JavaScript的早期版本中，你没有办法直接判断“undefined是undefined”，例如无法写出“x === undefined”这样的代码，而你只能写类似“typeof(x) ===&amp;#39;undefined&amp;#39;”这样的代码。\n\n后来（其实也没有太久），规范就约定把undefined作为可以缺省访问的名字，类似于null。但是这个时候就带来了一个矛盾，因为这个undefined很重要，早期的绝大多数框架或引擎都把它作为一个“全局名字”给声明了。也就是说，ECMAScript现在既没有办法将它规范成一个keyword，也没有办法处理成保留字等等，它看起来像null，但又没有办法在规范层面强制它。所以……ECMAScript就搞了一个“奇招”：\n\n&amp;gt; 我们把undefined声明成全局的属性，怎么样？！\n\n嗯嗯，很好。所以你看，现在的引擎上面undefined看起来长得跟null值差不多，而且在ECMAScript规范中它们都还是平级的（是原始值），而且它们的作用也很接近，最后他们都还是从最初的JavaScript 1.x中就存在的概念，但是undefined/null两者却在实现上完全不同：undefined是一个全局属性，而null是一个关键字。\n\n由于undefined是全局属性，所以`delete undefined`其实就是`delete global.undefined`，是删除引用，而不是删除值。而这个属性是只读的，所以就返回false了。\n\n例如你可以试试下面的代码：\n\n&amp;gt; Object.getOwnPropertyDescriptor(global, &amp;#39;undefined&amp;#39;)\n{ value: undefined,\n  writable: false,\n  enumerable: false,\n  configurable: false }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574222971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":530617,"discussion_content":"老师，这里的delete null 返回true 的原因是不是null被当做了“值类型”，于是乎直接返回true?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637112640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":475076,"ip_address":""},"score":530617,"extra":"{\"user_type\":1}"},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530702,"discussion_content":"在ECMAScript中，null是“非对象”。所以你理解成值类型是没错的。——注意ECMAScript的表现，跟typeof的结果并不一致，这些在很后面的内容中是会讨论到的。从这一讲的话题来说，这里理解成“null是个值，是非引用的”，所以不能删除但返回true（采用于值数据一致的处理），是可行的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637130542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":530617,"ip_address":""},"score":530702,"extra":""},{"author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":534788,"discussion_content":"老师，你太好了吧，这个专栏这么久了还保持回复，我吹爆你，极客里面最良心的大佬，没有之一","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638277424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":530702,"ip_address":""},"score":534788,"extra":""}]},{"author":{"id":1293057,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/01/568ac2d6.jpg","nickname":"K4SHIFZ","note":"","ucode":"BFB49AAC0E4C74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54145,"discussion_content":"庆幸翻到这里了，又学到一点知识，哈哈","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574262164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1163321,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c0/39/16340f72.jpg","nickname":"zlxag","note":"","ucode":"136FB0201B64A3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260425,"discussion_content":"看懂了你们的对讲 难受","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1588863519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1596788,"avatar":"https://static001.geekbang.org/account/avatar/00/18/5d/74/2762a847.jpg","nickname":"流乔","note":"","ucode":"98956AC607DAF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208431,"discussion_content":"先看加餐，才到这里来捡豆，表示看懂了😂😂😂","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584544250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2393393,"avatar":"","nickname":"邬昌明","note":"","ucode":"30838A94D4D244","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342601,"discussion_content":"我对第二条delete x有疑问～\ndelete UnaryExpression  \n按照老师说的这行代码试图“删除表达式的值”， x首先被强行看成表达式，然后ResolveBinding去找x, 再后面我就和你的意见不同了。\n\n你的解释是“x 表达式返回的是一个引用，并且环境中并没有表示这个引用不能被删除”。\n我觉得 &#34;x表达式返回的就是getValue(window.x), 删除window.x的值就是在删除undefined, 如果删除了undefined,程序里就不能再用了，那显然是不合理的。所以delete x 什么都没做&#34;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610726298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1042089,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e6/a9/b459efb7.jpg","nickname":"如故","note":"","ucode":"F6895792309942","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2393393,"avatar":"","nickname":"邬昌明","note":"","ucode":"30838A94D4D244","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351116,"discussion_content":"然而x表达式返回的是一个UnresolvableReference，规范约定遇到这个就返回true；并且 delete undefined；会返回false，因为undefined是只读的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614156967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342601,"ip_address":""},"score":351116,"extra":""},{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2393393,"avatar":"","nickname":"邬昌明","note":"","ucode":"30838A94D4D244","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414460,"discussion_content":"我觉得“如故”童鞋的回复有道理，在x被标识为一个UnresolvableReference，之后就不会有接下来的getValue取值的步骤了。即识别标识符应该是在从标识符获取值之前----之前理解ResolveBinding发生在编译阶段，其实在此看文章，ResolveBinding应该是发生在运行阶段","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636774418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":342601,"ip_address":""},"score":414460,"extra":""},{"author":{"id":1601296,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","nickname":"海绵薇薇","note":"","ucode":"37C7CC2EB81909","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591683,"discussion_content":"是的，https://tc39.es/ecma262/#prod-UnaryExpression 规范中规定删除UnresolvableReference 在非严格模式下返回false。整个delete的过程中都没有涉及到求值也就是getValue的操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666765612,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":414460,"ip_address":"北京"},"score":591683,"extra":""}]}]},{"had_liked":false,"id":154129,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1574383825,"is_pvip":false,"replies":[{"id":"59198","content":"强烈点赞！你这个就属于一通百通的例子。弄明白了Result用来做引用和值的方法&#47;原理，一些具体现象就迎刃而解了！<br><br>^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574400325,"ip_address":"","comment_id":154129,"utype":1}],"discussion_count":9,"race_medal":0,"score":"254977454289","product_id":100039701,"comment_content":"hello 老师好，感谢老师之前的回答：）<br>突然想到，访问不存在的变量x报ReferenceError错误，其实是对x表达式的的Result引用做getValue的时候报的错误，然后为啥typeof x和delete x不报错，因为这两个操作没有求值。","like_count":59,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475383,"discussion_content":"强烈点赞！你这个就属于一通百通的例子。弄明白了Result用来做引用和值的方法/原理，一些具体现象就迎刃而解了！\n\n^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574400325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1568263,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ee/07/465058c7.jpg","nickname":"Even.Yu","note":"","ucode":"D55F190AC6E4FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381559,"discussion_content":"想请教下 如何理解这段代码呢?  let number = 1；  delete number  === false","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625126389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1601296,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","nickname":"海绵薇薇","note":"","ucode":"37C7CC2EB81909","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1568263,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ee/07/465058c7.jpg","nickname":"Even.Yu","note":"","ucode":"D55F190AC6E4FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591682,"discussion_content":"let number = 1; delete number === false; delete number 中的number计算结果是一个引用，{base: 环境记录, name: &#39;number&#39;} 类似这样的，当delete操作这个引用的时候发现是环境记录的引用（base值是环境记录），会调用环境记录的deleteDeleteBinding方法，这个方法在发现let 声明的标识符 number无法被删除会返回false。所以delete操作会返回false。\n参考：https://tc39.es/ecma262/#prod-UnaryExpression\nhttps://tc39.es/ecma262/#sec-declarative-environment-records-deletebinding-n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666764910,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":381559,"ip_address":"北京"},"score":591682,"extra":""}]},{"author":{"id":1030409,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b9/09/00112351.jpg","nickname":"清心萌","note":"","ucode":"25CFEB8829C553","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77061,"discussion_content":"我大概懂了。是解析x变量时，往上依次寻找base，发现base是undefined，所以IsUnresolvableReference(ref)为true，规范约定此种情况非严格模式下返回true。系不系酱","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575885710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1601296,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","nickname":"海绵薇薇","note":"","ucode":"37C7CC2EB81909","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1030409,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b9/09/00112351.jpg","nickname":"清心萌","note":"","ucode":"25CFEB8829C553","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591684,"discussion_content":"我理解是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666765649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77061,"ip_address":"北京"},"score":591684,"extra":""}]},{"author":{"id":1030409,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b9/09/00112351.jpg","nickname":"清心萌","note":"","ucode":"25CFEB8829C553","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":77045,"discussion_content":"请问，delete x; 即delete x= GetValue(x); ，删除这个表达式的结果，这是不是算做了求值运算？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575883292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1601296,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","nickname":"海绵薇薇","note":"","ucode":"37C7CC2EB81909","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1030409,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b9/09/00112351.jpg","nickname":"清心萌","note":"","ucode":"25CFEB8829C553","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591685,"discussion_content":"delete这个操作符，在规范中并没有涉及到GetValue，x表达式的计算结果是{base: 环境记录, name: &#39;x&#39;} 类似这样的，如果执行删除会是这样&#34;环境记录.delete(&#39;x&#39;)&#34; 类似这样，如果是属性记录的话，就是把环境记录变成对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666765761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":77045,"ip_address":"北京"},"score":591685,"extra":""}]},{"author":{"id":1049741,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","nickname":"weineel","note":"","ucode":"6DC6EF4F256A53","race_medal":2,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65598,"discussion_content":"typeof x; 没有求值是怎么知道类型的呢？是引用中保存了类型吗？每一次给引用赋值都会更新引用的类型吗？\n我一直觉得是 typeof 是根据值推断的类型。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575015044,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1601296,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","nickname":"海绵薇薇","note":"","ucode":"37C7CC2EB81909","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1049741,"avatar":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","nickname":"weineel","note":"","ucode":"6DC6EF4F256A53","race_medal":2,"user_type":1,"is_pvip":true},"discussion":{"id":69559,"discussion_content":"Hello：\ntypeof 的具体的过程是。如果一元表达式的Result是引用的话会先判断 IsUnresolvableReference(val)，结果是true就直接返回undefined了，不会再调用GetValue(val)。否则才会GetValue(val)再获取对应类型。所以理解了&#34;引用&#34;就有了弄清楚这个现象的线索。","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1575293430,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":65598,"ip_address":""},"score":69559,"extra":""}]}]},{"had_liked":false,"id":150171,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1573472657,"is_pvip":false,"replies":[{"id":"57795","content":"赞的！+1<br><br>其实第1个问题的潜在问题是：这种情况下，x是什么呢？它显然是语法可以识别的东西，但如果这样，在语法上它是什么，且在执行环境中它又是什么？<br><br>而第二个问题的答案，其实也会回到第一个问题上。如果是在严格模式上，第一个问题的答案是什么？并且，为什么它们不同？<br><br>所以，呵呵，其实细一点的看，这两个问题还可以挖更多的呢。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573489802,"ip_address":"","comment_id":150171,"utype":1}],"discussion_count":4,"race_medal":0,"score":"130422491537","product_id":100039701,"comment_content":"1、如果x根本不存在，delete x什么也不做，返回true<br>2、如果x只读，delete object.x不能删除掉x属性，返回false；如果在严格模式下，会报错：TypeError: Cannot delete property &#39;c&#39;","like_count":30,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474082,"discussion_content":"赞的！+1\n\n其实第1个问题的潜在问题是：这种情况下，x是什么呢？它显然是语法可以识别的东西，但如果这样，在语法上它是什么，且在执行环境中它又是什么？\n\n而第二个问题的答案，其实也会回到第一个问题上。如果是在严格模式上，第一个问题的答案是什么？并且，为什么它们不同？\n\n所以，呵呵，其实细一点的看，这两个问题还可以挖更多的呢。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573489802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":530717,"discussion_content":"关于这个问题应该是规范里的这段说明：\nNOTE When a delete operator occurs within strict mode code, a SyntaxError exception is thrown if its UnaryExpression is a direct reference to a variable, function argument, or function name. In addition, if a delete operator occurs within strict mode code and the property to be deleted has the attribute { [[Configurable]]: false }, a TypeError exception is thrown.\nhttp://es5.github.io/#x11.4.1\n即：在严格模式下如果“一元运算符（表达式的结果）”是一个对于变量、方法参数或方法名的直接引用，那么就抛出SyntaxError；而如果属性是只读的，那么就抛出TypeError。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637133297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":474082,"ip_address":""},"score":530717,"extra":"{\"user_type\":1}"}]},{"author":{"id":1251429,"avatar":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","nickname":"潇潇雨歇","note":"","ucode":"4BD52BF0F0A084","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48787,"discussion_content":"如果第一个在严格模式下会报SyntaxError: Delete of an unqualified identifier in strict mode.第一个是报SyntaxError，试图删除一个不合格的标识符。第二个是TypeError，\b属性存在，但是是删除一个DontDelete属性。对于删除不存在的属性，还是不太明白，还得去研究研究。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1573526714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63060,"discussion_content":"老师第一个问题的延伸，x 在语法成面上是一个未声明的标识符；在执行环境中是一个 Unresolved 的引用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574866041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150201,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1573477863,"is_pvip":false,"replies":[{"id":"57801","content":"谢谢 @潇潇雨歇","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573490808,"ip_address":"","comment_id":150201,"utype":1}],"discussion_count":7,"race_medal":0,"score":"100357725671","product_id":100039701,"comment_content":"关于delete的知识，大家可以看下MDN的讲解：https:&#47;&#47;developer.mozilla.org&#47;zh-CN&#47;docs&#47;Web&#47;JavaScript&#47;Reference&#47;Operators&#47;delete<br>以及这篇深入delete博客：http:&#47;&#47;perfectionkills.com&#47;understanding-delete&#47;","like_count":24,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474091,"discussion_content":"谢谢 @潇潇雨歇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573490808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1527824,"avatar":"https://static001.geekbang.org/account/avatar/00/17/50/10/f7f9065f.jpg","nickname":"lucy","note":"","ucode":"0D892A9C0B2A56","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374654,"discussion_content":"mdn 的文章好理解些","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1621303392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435011,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e5/83/8abd9534.jpg","nickname":"嘉","note":"","ucode":"044CF069B5BE35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52927,"discussion_content":"下面这个文章才是正解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574092309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1005356,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","nickname":"ssala","note":"","ucode":"CCD82C81756FC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50271,"discussion_content":"看了这篇博客，作者为了解释delete的原理，引入了多个规则，但在最后的时候，解释不下去了。原因是下述代码：\n\nvar x = 1;\n\n  /* Can&#39;t delete, `x` has DontDelete */\n\n  delete x; // false\n  typeof x; // &#34;number&#34;\n\n  eval(&#39;function x(){}&#39;);\n\n  /* `x` property now references function, and should have no DontDelete */\n\n  typeof x; // &#34;function&#34;\n  delete x; // should be `true`\n  typeof x; // should be &#34;undefined&#34;\n\n按作者的理论，eval以后，x属性的特性应该没有donotdelete，也即可以删除，但是却无法删除。请问老师有什么见解吗？如何解释这段代码的输出及背后的原因？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573698196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1251429,"avatar":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","nickname":"潇潇雨歇","note":"","ucode":"4BD52BF0F0A084","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1005356,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","nickname":"ssala","note":"","ucode":"CCD82C81756FC6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50337,"discussion_content":"我这边测试是可以删除的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573707682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50271,"ip_address":""},"score":50337,"extra":""},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1005356,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","nickname":"ssala","note":"","ucode":"CCD82C81756FC6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50699,"discussion_content":"Oh... 这个博客中的这个示例实际主是相当于声明了两次x，因为var声明和函数声明用的是同一个名字。多次声明其实只有第一次有效（不会重复声明，但会再次绑定值，即“一次声明，多次绑定”），因此第二次typeof x的结果是函数，表明值的重写/重新绑定是成功了，但是由于声明本身没关（所以仍然是不能删除的var声明），所以删除的效果也没有变。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573745035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50271,"ip_address":""},"score":50699,"extra":""},{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":530722,"discussion_content":"其实这里的原因是调用Object.getOwnPropertyDescriptor(window, &#39;x&#39;)时候，configurable依然是false。这个在ECMAScript 中有解释  \nThe concrete Environment Record method DeleteBinding for object environment records can only delete bindings that correspond to properties of the environment object whose [[Configurable]] attribute have the value true. \n对于“对象环境记录”而言（全局对象在执行环境时应该是对象环境记录），只有当属性的Configurable为true的时候才能够被删除\nhttp://es5.github.io/#x10.2.1.2.5","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637134489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50699,"ip_address":""},"score":530722,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":154065,"user_name":"SOneDiGo","can_delete":false,"product_type":"c1","uid":1312874,"ip_address":"","ucode":"2F7073D7A06CA6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep7yaY0ibpBicMhk0gr01lZrn2Sj9SJU0OdFMWWZbicx1JFVEycKkw3xMoFFs5STPoXhTp823nPtkJjw/132","comment_is_top":false,"comment_ctime":1574374578,"is_pvip":false,"replies":[{"id":"59203","content":"对于array来说，你理解为一个普通对象就可以了，只是一些array原型上的方法能帮助你处理array.length这个属性而已。<br>有多少个有效的element，那么就有多少个同名的（数字下标的）属性；而array.length记录着这个最大值。除了这一点，没有任何与其它对象不同。<br>所以你用array.pop()或array.push()等操作，甚至直接使用array[i]都可以影响到array.length这个属性——因为这些操作内部都会处理它。但是，你用delete去根本不会处理这个属性——因为delete是把array[i]当一个一般属性处理的，根本不知道array.length的存在。<br><br>例如：<br>```<br>&gt; x = new Array(8)<br>&gt; x.length<br>8<br>&gt; x[x.length] = 8 &#47;&#47; add to last<br>&gt; x.length<br>9<br>&gt; x.push(10)  &#47;&#47; push<br>10<br><br>&gt; x.pop() &#47;&#47; pop<br>&gt; x.length<br>9<br><br>&gt; delete x[8]<br>true<br>&gt; x.length<br>9<br>```<br><br>至于删除delete array[2]，则array[2]位置上是undefined，这个与delete操作无关。而是因为你“读取一个不存在的属性，它的值就是undefined”。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574401298,"ip_address":"","comment_id":154065,"utype":1}],"discussion_count":1,"race_medal":0,"score":"83178753202","product_id":100039701,"comment_content":"想问下老师如何理解用delete处理array element实际上在底层是如何操作的?<br>例如：array = [1,2,&#39;1&#39;]<br>为什么 delete array[2] 后数组就成了[1,2,undefined&#47;empty]?","like_count":19,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475368,"discussion_content":"对于array来说，你理解为一个普通对象就可以了，只是一些array原型上的方法能帮助你处理array.length这个属性而已。\n有多少个有效的element，那么就有多少个同名的（数字下标的）属性；而array.length记录着这个最大值。除了这一点，没有任何与其它对象不同。\n所以你用array.pop()或array.push()等操作，甚至直接使用array[i]都可以影响到array.length这个属性——因为这些操作内部都会处理它。但是，你用delete去根本不会处理这个属性——因为delete是把array[i]当一个一般属性处理的，根本不知道array.length的存在。\n\n例如：\n```\n&amp;gt; x = new Array(8)\n&amp;gt; x.length\n8\n&amp;gt; x[x.length] = 8 // add to last\n&amp;gt; x.length\n9\n&amp;gt; x.push(10)  // push\n10\n\n&amp;gt; x.pop() // pop\n&amp;gt; x.length\n9\n\n&amp;gt; delete x[8]\ntrue\n&amp;gt; x.length\n9\n```\n\n至于删除delete array[2]，则array[2]位置上是undefined，这个与delete操作无关。而是因为你“读取一个不存在的属性，它的值就是undefined”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574401298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152835,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1574085862,"is_pvip":false,"replies":[{"id":"58769","content":"关于3，我一般是用Result来表达它是表达式执行结果的“未决状态”。就是执行出结果来了，但没确定是作为lrs还是rhs，所以这种情况下，它就是未决的。<br><br>当你确定了一个Result用作lrs，那么它就是引用；如果确定它用作rhs，那么它就是值（将由引擎隐式地调用`GetValue()`）。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574132503,"ip_address":"","comment_id":152835,"utype":1}],"discussion_count":3,"race_medal":0,"score":"83178464486","product_id":100039701,"comment_content":"感谢老师指点😁<br><br>ref：语法上的引用<br><br>我又看了几遍文章并根据提供的连接，得出如下结论：<br><br>1.<br><br>var x<br><br>x = 0<br>console.log(x)<br><br>x 表达式返回的是一个ref（{referencedName: &#39;x&#39;, base: Environment Record}），然后计算值getValue(ref)得到具体的值，具体的值会分为传统意义上的基本类型和引用类型<br><br>2. 衍生出下面的猜想<br><br>var obj<br><br>obj = {a: 1}<br><br>console.log(obj.a)<br><br>obj.a 也是一个ref（{referencedName: &#39;a&#39;, base: obj}），然后计算值的时候getValue(ref)得到具体的值1<br><br>3. 关于表达式的结果Result的疑问。<br><br>文中说：表达式的值，在 ECMAScript 的规范中，称为“引用”。（表达式的结果（Result）是引用。）<br><br>但是后文说Result可能是引用&#47;值。<br><br>这里的值我不能很好的理解。值指的是另一种引用的格式吗？例如链接文档中提到的base其实有很多种值 undefined, Object, a Boolean, a String, a Symbol, a Number。值指的是{base: 0}这种引用吗？如果不是这样的话base的Boolean等基本值类型有啥用啊？<br><br>还是说 0 这个表达式的Result就是0这个值？<br><br>期待老师的指点😁","like_count":19,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474958,"discussion_content":"关于3，我一般是用Result来表达它是表达式执行结果的“未决状态”。就是执行出结果来了，但没确定是作为lrs还是rhs，所以这种情况下，它就是未决的。\n\n当你确定了一个Result用作lrs，那么它就是引用；如果确定它用作rhs，那么它就是值（将由引擎隐式地调用`GetValue()`）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574132503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1632773,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","nickname":"westfall","note":"","ucode":"F3F5CB7DF695FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576755,"discussion_content":"hello，请问你是怎么得到这个 ref 的？\n\n{referencedName: &#39;x&#39;, base: Environment Record}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655778444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1601296,"avatar":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","nickname":"海绵薇薇","note":"","ucode":"37C7CC2EB81909","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1632773,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","nickname":"westfall","note":"","ucode":"F3F5CB7DF695FC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591688,"discussion_content":"我理解应执行代码的引擎解析代码的时候输出的引用，这个过程是在JS引擎里面完成的。只能理解到这里的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666766375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":576755,"ip_address":"北京"},"score":591688,"extra":""}]}]},{"had_liked":false,"id":152073,"user_name":"潇潇雨歇","can_delete":false,"product_type":"c1","uid":1251429,"ip_address":"","ucode":"4BD52BF0F0A084","user_header":"https://static001.geekbang.org/account/avatar/00/13/18/65/35361f02.jpg","comment_is_top":false,"comment_ctime":1573870658,"is_pvip":false,"replies":[{"id":"58499","content":"：）<br>+1","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573904209,"ip_address":"","comment_id":152073,"utype":1}],"discussion_count":2,"race_medal":0,"score":"70293347394","product_id":100039701,"comment_content":"看的第三遍。还是要去看看规范加深理解。<br>如果x根本不存在，delete x操作时，x首先是一个表达式，语义上是一个引用，然后去寻找该引用的result，但是x根本不存在，是找不到的。也就做不了什么，返回ture。<br>如果obj.x是只读的或者不可配置的，表示他是不能删除的，但是他是实实在在的引用，是可以求值得到Result的，所以返回false。表示不能删除。","like_count":16,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474707,"discussion_content":"：）\n+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573904209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361002,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c4/6a/e45bbb6b.jpg","nickname":"Smile","note":"","ucode":"674C2361FFB807","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560886,"discussion_content":"很清晰","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649482670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150210,"user_name":"Ming","can_delete":false,"product_type":"c1","uid":1358174,"ip_address":"","ucode":"A94E8D8433E54F","user_header":"https://static001.geekbang.org/account/avatar/00/14/b9/5e/a8f6f7db.jpg","comment_is_top":false,"comment_ctime":1573479089,"is_pvip":true,"replies":[{"id":"57803","content":"其实这一讲的核心是关于“引用&#47;值”在ECMAScript规范类型中的使用与理解，而不是（不仅仅是）delete的使用。所以呢，解释delete这个操作的种种现象，最好是在ECMAScript规范所讨论的语言模型中来叙述，这样更容易讲得清楚。<br><br>比如说，`x`如果是一个属性（包括是global的属性），那么`delete x`的是否成功就取决于属性描述符，以及属性存取的过程（是否在严格模式中等等）。这样就Ok了，而不需要细致地列举每一种情况。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573491294,"ip_address":"","comment_id":150210,"utype":1}],"discussion_count":4,"race_medal":0,"score":"70292955825","product_id":100039701,"comment_content":"乍一读，云里雾里。翻了文档并做测试，总结如下：<br><br>delete 操作符用于删除对象的属性，它接收一个表达式，该表达式应返回对象属性的引用。<br><br>1. 如果表达式返回的结果是引用：<br>当该引用是 let 或 const 定义的，delete 执行结果总是 false；<br>当引用作为对象的属性不存在时，delete 对象的属性，执行结果为 true，表示未处理；<br>当该引用为 window 对象的属性且是 var 定义的，delete window 对象的属性，执行结果为 false，表示处理失败（获取属性描述符时为不可配置）；<br>如果在全局环境下显示定义一个属性描述符为可配置的全局属性，执行 delete，结果是 true，表示操作成功；<br>当该引用为非 window 对象的属性且是 var 定义的，delete 非 window 对象的属性，执行结果为 true，表示处理成功（获取属性描述符时为可配置）。<br><br>2. 如果表达式返回的结果是值，如数字、字符串等，delete 执行结果为 true，表示未处理。","like_count":16,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474095,"discussion_content":"其实这一讲的核心是关于“引用/值”在ECMAScript规范类型中的使用与理解，而不是（不仅仅是）delete的使用。所以呢，解释delete这个操作的种种现象，最好是在ECMAScript规范所讨论的语言模型中来叙述，这样更容易讲得清楚。\n\n比如说，`x`如果是一个属性（包括是global的属性），那么`delete x`的是否成功就取决于属性描述符，以及属性存取的过程（是否在严格模式中等等）。这样就Ok了，而不需要细致地列举每一种情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573491294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52078,"discussion_content":"在JS中，这是个历史误区，所以在第一小节“习惯中的“引用””里面讲的就这个历史与它的成因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573992455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162891,"avatar":"https://static001.geekbang.org/account/avatar/00/11/be/8b/e772a193.jpg","nickname":"leason","note":"","ucode":"A90FC5D56424B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51403,"discussion_content":"文中的值与引用是规范中的概念，并不是我们使用js中的值与引用的概念。\n不知道我们常说js的值与引用的概念是否有存在的必要，是否是一种误导或者对初学者的一种简化概念？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573865895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1162891,"avatar":"https://static001.geekbang.org/account/avatar/00/11/be/8b/e772a193.jpg","nickname":"leason","note":"","ucode":"A90FC5D56424B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530752,"discussion_content":"“常用的值和引用概念” 是先于ECMAScript中的引用概念，正如文中老师所说刚开始很多写js的程序员都是从其他语言切过来的，比如java。而他们脑中对于引用和值的理解就是基于之前的语言的，所以用户很难去重新被植入规范中对于“引用”的概念了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637140320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":51403,"ip_address":""},"score":530752,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":150545,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":false,"comment_ctime":1573552661,"is_pvip":false,"replies":[{"id":"57887","content":"赞的！就是这样！","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573556357,"ip_address":"","comment_id":150545,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61703094805","product_id":100039701,"comment_content":"即便 obj.x 是一个 function，当 obj.x 作为右手端时，也会被 GetValue 方法抽取出值来，而这个“值”并不是直觉上的数字或字符串。这里是有恍然大悟的感觉的，“值”和“引用”应当从严格的规范定义层面理解，而不能从直觉上来理解，只要满足定义，那就是“值”&#47;“引用”。","like_count":14,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474196,"discussion_content":"赞的！就是这样！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573556357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150198,"user_name":"隔夜果酱","can_delete":false,"product_type":"c1","uid":1319638,"ip_address":"","ucode":"5AFEB62E832BCB","user_header":"https://static001.geekbang.org/account/avatar/00/14/22/d6/9378f4d5.jpg","comment_is_top":false,"comment_ctime":1573477512,"is_pvip":false,"replies":[{"id":"57800","content":"这个问题就牵扯得大了。<br><br>最早javascript中是没有明确、显式的global这个对象的，在宿主环境（例如浏览器中）你可以用window.x去访问它，这算是宿主在实现引擎的时候的约定。但是，仅只从引擎的角度上来说，既没有window，也没有global，更没有Global。所以，全局的变量虽然是作为全局属性名存在着，却没有办法写成global.x这样的引用。<br><br>而global这个全局名字，直到现在在ECMAScript中都还是个没被规范的东西。TC39有一个提案（https:&#47;&#47;github.com&#47;tc39&#47;proposal-global）专门来定义它，现在到了stage3，应该不会被否决了。但即使如此，这个东东也不叫global，而改名成了globalThis。——原本提案阶段是叫global的，但应用中有问题，所以就改了。<br><br>关于globalThis这个说法，又得是一段历史了。因为早期的JavaScript约定普通函数在“不作为对象方法调用”的时候，this值默认指向这个全局的global。所以，这也就是著名的代码“global = (new Function(&#39;return this&#39;)()”，或“global = Function(&#39;return this&#39;)()”的由来。<br><br>^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573490771,"ip_address":"","comment_id":150198,"utype":1}],"discussion_count":1,"race_medal":0,"score":"61703019656","product_id":100039701,"comment_content":"既然delete这么鸡肋,只能删除对象的成员.<br>那么后来的版本中为什么不进行改进呢?<br>比如限定其只能用delete obj.x这种语法格式.<br>或者加入trycatch,对删除value的操作直接报错呢?","like_count":14,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474089,"discussion_content":"这个问题就牵扯得大了。\n\n最早javascript中是没有明确、显式的global这个对象的，在宿主环境（例如浏览器中）你可以用window.x去访问它，这算是宿主在实现引擎的时候的约定。但是，仅只从引擎的角度上来说，既没有window，也没有global，更没有Global。所以，全局的变量虽然是作为全局属性名存在着，却没有办法写成global.x这样的引用。\n\n而global这个全局名字，直到现在在ECMAScript中都还是个没被规范的东西。TC39有一个提案（https://github.com/tc39/proposal-global）专门来定义它，现在到了stage3，应该不会被否决了。但即使如此，这个东东也不叫global，而改名成了globalThis。——原本提案阶段是叫global的，但应用中有问题，所以就改了。\n\n关于globalThis这个说法，又得是一段历史了。因为早期的JavaScript约定普通函数在“不作为对象方法调用”的时候，this值默认指向这个全局的global。所以，这也就是著名的代码“global = (new Function(&amp;#39;return this&amp;#39;)()”，或“global = Function(&amp;#39;return this&amp;#39;)()”的由来。\n\n^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573490771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150220,"user_name":"余文郁","can_delete":false,"product_type":"c1","uid":1388319,"ip_address":"","ucode":"A51117A929EBD8","user_header":"https://static001.geekbang.org/account/avatar/00/15/2f/1f/f95bd8c9.jpg","comment_is_top":false,"comment_ctime":1573480216,"is_pvip":false,"replies":[{"id":"57804","content":"在后面我会再着重地讲到JavaScript对面向对象的理解。<br><br>如今我们对OOP的理解其实添加了太多应用的色彩。事实上，JavaScript对OOP的理解是很精彩、很学术，以及很完整的。不过这些内容大概要到第11讲之后了。<br><br>至于“面向对象”还是“基于对象”，其实JavaScript 1.0是有类而无继承的，而JavaScript 1.1才开始使用原型来实现继承，这个时候它又抛弃了（严格意义上的）类。<br><br>当然，上面看起来有点儿绕着你的问题在讲。所以，如果再确切地、准确无误地回复你的问题，那么应该是说：所谓面向对象的三个原则（封装、继承与多态），在严格意义上，后两者是多余的。所以不必过度去强调这些性质之于面向对象的重要性。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573491855,"ip_address":"","comment_id":150220,"utype":1}],"discussion_count":5,"race_medal":0,"score":"53113087768","product_id":100039701,"comment_content":"老师，JS是基于对象的语言，不是面象对象的语言吧，感觉第二段这有点不妥，虽然ES6增加了class语法，但只是原型的语法糖而已<br>","like_count":12,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474097,"discussion_content":"在后面我会再着重地讲到JavaScript对面向对象的理解。\n\n如今我们对OOP的理解其实添加了太多应用的色彩。事实上，JavaScript对OOP的理解是很精彩、很学术，以及很完整的。不过这些内容大概要到第11讲之后了。\n\n至于“面向对象”还是“基于对象”，其实JavaScript 1.0是有类而无继承的，而JavaScript 1.1才开始使用原型来实现继承，这个时候它又抛弃了（严格意义上的）类。\n\n当然，上面看起来有点儿绕着你的问题在讲。所以，如果再确切地、准确无误地回复你的问题，那么应该是说：所谓面向对象的三个原则（封装、继承与多态），在严格意义上，后两者是多余的。所以不必过度去强调这些性质之于面向对象的重要性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573491855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293057,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/01/568ac2d6.jpg","nickname":"K4SHIFZ","note":"","ucode":"BFB49AAC0E4C74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53882,"discussion_content":"js基于原型的面向对象编程语言。java基于类的面向对象编程语言。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574228698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390756,"avatar":"https://static001.geekbang.org/account/avatar/00/15/38/a4/608e86ff.jpg","nickname":"Sixty","note":"","ucode":"F8C7FB86C50608","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49215,"discussion_content":"JavaScript 是一门面相对象的语言，只是它不是用 类来实现面向对象这个范式的。我们要想正确理解JavaScript 面相对象就要抛开传统基于类实现面相对象的方式，忘掉类的基础设施。其实JavaScript 是用原型实现了面相对象的范式，同时也能实现函数式编程范式！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573564868,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028811,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f5/0b/73628618.jpg","nickname":"兔嘟嘟","note":"","ucode":"5A9042B4C7670C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566446,"discussion_content":"go也是面向对象语言……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650687768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015535,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7tEdeN11bEZsc4XWXpT2Xbp8pecwfdiceovTetW7JGHL5esbhAP48LmWKzgK3QOPRibZAic7Al7JVFwWW1I4o0vDQ/132","nickname":"尤利西斯的微笑","note":"","ucode":"7413231B6B78A7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50355,"discussion_content":"JS 就是OOP啊！面向对象三个原则JS完全可以。https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573710482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153874,"user_name":"渭河","can_delete":false,"product_type":"c1","uid":1376031,"ip_address":"","ucode":"8983C4DFAED2A6","user_header":"https://static001.geekbang.org/account/avatar/00/14/ff/1f/4f927519.jpg","comment_is_top":false,"comment_ctime":1574323454,"is_pvip":false,"replies":[{"id":"59201","content":"这就是“传统中的‘引用’”用来解释这类现象的时候出现的麻烦。很典型的一个例子，话表达的是正确的，内容是正确的，说法也正确，就是特别特别难于理解。<br><br>首先，“值类型中的字符串”是指什么呢？是指typeof(x) === &#39;string&#39;中的那个`x`。在传统的javaScript概念中，这样的x是值类型，而不是引用类型。<br><br>那么值“该怎么赋值和传递”呢？如果x的值是1，那么y = x的话，就是把1这个值“抄写”到y里面去。这是“正常的值”的处理方法，但是如果“字符串值”也这么处理，就完蛋了，因为字符串可能无数多个字符，那么当`y = x`按照“正常的值处理方法”来实现的话，这个“值的复制”的开销就受不了。<br><br>所以：<br>1. “值类型中的字符串”，是指照<br>2. “引用来赋值和传递引用”的；且，<br>3. 它是只传递引用（而不是传递值）的。<br><br>如上。只是说起来特别麻烦而已。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574400707,"ip_address":"","comment_id":153874,"utype":1}],"discussion_count":2,"race_medal":0,"score":"48818963710","product_id":100039701,"comment_content":"这句话要怎么理解呀 <br>所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的","like_count":11,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475303,"discussion_content":"这就是“传统中的‘引用’”用来解释这类现象的时候出现的麻烦。很典型的一个例子，话表达的是正确的，内容是正确的，说法也正确，就是特别特别难于理解。\n\n首先，“值类型中的字符串”是指什么呢？是指typeof(x) === &amp;#39;string&amp;#39;中的那个`x`。在传统的javaScript概念中，这样的x是值类型，而不是引用类型。\n\n那么值“该怎么赋值和传递”呢？如果x的值是1，那么y = x的话，就是把1这个值“抄写”到y里面去。这是“正常的值”的处理方法，但是如果“字符串值”也这么处理，就完蛋了，因为字符串可能无数多个字符，那么当`y = x`按照“正常的值处理方法”来实现的话，这个“值的复制”的开销就受不了。\n\n所以：\n1. “值类型中的字符串”，是指照\n2. “引用来赋值和传递引用”的；且，\n3. 它是只传递引用（而不是传递值）的。\n\n如上。只是说起来特别麻烦而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574400707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":530767,"discussion_content":"老师，这里有一点不明白的地方：\n如果把 x 理解为“规范中的引用”类型，那么在 y = x; 中x位于rhs，此时会x做getValue()操作获取x对应的值。将getValue(x)传递给y时，这时候传递的到底是什么，是不是可以理解为将x对应的字符串的地址值拷贝一份然后赋给了 y 呢（即让y也指向这个字符串），而字符串在内存中还是只有一份而没有复制多份。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637144341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":475303,"ip_address":""},"score":530767,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":189796,"user_name":"桃翁","can_delete":false,"product_type":"c1","uid":1044036,"ip_address":"","ucode":"CB438AF450DC00","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/44/26ac883e.jpg","comment_is_top":false,"comment_ctime":1584552065,"is_pvip":false,"replies":[{"id":"73078","content":"Yes！+5","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1584588621,"ip_address":"","comment_id":189796,"utype":1}],"discussion_count":3,"race_medal":0,"score":"44534225025","product_id":100039701,"comment_content":"我突然 明白了 (obj.func=obj.func)()这种方式会丢掉obj里面的this，因为等号右边的obj.func是值，所以得到的仅仅是个函数这个值，而不是引用。 老师我理解得是对的吗？","like_count":10,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487797,"discussion_content":"Yes！+5","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584588621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1345524,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aficKW6UecZ2KiaNVC0t5xicEZelCNLtQ8t4WOwUpFT8MQyBicS9RNhp04o6XZIneeeQhdrSJiaqpK21X0urQ0e1QUA/132","nickname":"Yijx","note":"","ucode":"1B306B80E1EDD8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312335,"discussion_content":"这个地方这么理解就很奇怪了\n(obj.func=obj.func)()是表达式(obj.func=obj.func) 即分组运算符 里有赋值操作 + 一个函数执行运算符\n得到该结果的原因不是因为:  &#34;赋值表达式 返回的结果就是一个单值表达式即obj.func函数的内容,(可能为  &#34;ƒ () {console.log(this)}&#34;),随后执行它,这样才使this指向变成windows,因为这就是个函数表达式而已&#34; 这样么","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1602666303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1640823,"avatar":"","nickname":"Geek_zy1991","note":"","ucode":"3E9DBB03DE6D9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1345524,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aficKW6UecZ2KiaNVC0t5xicEZelCNLtQ8t4WOwUpFT8MQyBicS9RNhp04o6XZIneeeQhdrSJiaqpK21X0urQ0e1QUA/132","nickname":"Yijx","note":"","ucode":"1B306B80E1EDD8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326230,"discussion_content":"应该是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605545744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312335,"ip_address":""},"score":326230,"extra":""}]}]},{"had_liked":false,"id":151333,"user_name":"ssala","can_delete":false,"product_type":"c1","uid":1005356,"ip_address":"","ucode":"CCD82C81756FC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","comment_is_top":false,"comment_ctime":1573701124,"is_pvip":false,"replies":[{"id":"58233","content":"Yes. 对的。<br><br>其实只要理解到`delete {}`中的对象字面量其实是“值”，那么就一通百通了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573716488,"ip_address":"","comment_id":151333,"utype":1}],"discussion_count":2,"race_medal":0,"score":"40228406788","product_id":100039701,"comment_content":"关于delete，搜集了一些资料，结合代码测试，我目前是这样理解的：delete为一元操作符，其操作数为一个表达式，如果表达式的求值结果是一个值，那么`delete 值`直接返回true，表示该操作没有异常。如果表达式求值结果是一个引用，那么`delete 引用`则会有如下表现，如果引用是可删除的，则直接删除该引用，返回true，否则返回false。<br><br>关于属性&#47;property的可删除特性，参照这篇文章：http:&#47;&#47;perfectionkills.com&#47;understanding-delete&#47;<br><br>关于引用和值的理解，我用段代码说明，如下：<br>```<br>var x = {a: 20}<br>```<br>代码中，x是引用，它&quot;指向&quot;执行系统中{a: 20}的一个对象，而{2: 20}则是值，它对应执行系统中内存上的一块区域。x.a是引用，它&quot;指向&quot;执行系统中内存20这个值，而20是值，它也对应执行系统中内存上的一块区域。因此：<br>```<br>delete x &#47;&#47; `false` ，x为表达式，求值结果为global.x，且该属性是用var来声明的，其特性是不可删除<br><br>delete 20 &#47;&#47; `true`，当执行系统遇到20字面量时，认为其为表达式，对其求值以后得到20这个值，delete 值返回true<br><br>delete x.a &#47;&#47; `true` x.a 为引用，且可以删除<br>```<br><br>另外关于delete x，若x不存在，我的解释是：x为表达式，由于未定义，表达式求值结果是未定义的，但是虽然未定义，但求值结果仍然是值，而delete 值就返回true。不知这种解释是否正确？<br>","like_count":9,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474441,"discussion_content":"Yes. 对的。\n\n其实只要理解到`delete {}`中的对象字面量其实是“值”，那么就一通百通了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573716488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":532166,"discussion_content":"看了这条评论突然想到，理解“引用”可以从字面意思出发。“引用”一词本身就包含了“指向”的动作意味。delete {}; 和 var b = {}; delete b; 这两种写法中，一个尝试删除指向性内容，只一个删除本身。（可能表达上有点拗口了😅 ）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637548453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":474441,"ip_address":""},"score":532166,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":180460,"user_name":"blueBean","can_delete":false,"product_type":"c1","uid":1816697,"ip_address":"","ucode":"6A68D2414BD904","user_header":"https://static001.geekbang.org/account/avatar/00/1b/b8/79/a4dbe9ee.jpg","comment_is_top":false,"comment_ctime":1582286818,"is_pvip":false,"replies":[{"id":"70053","content":"并不是矛盾，只是这里解释起来比较别扭。因为“Value”和“Result”，以及“值和引用”在上下文中都存在多种含义。<br><br><br>【第一句】<br>```<br>表达式的值，在 ECMAScript 的规范中称为“引用”。<br>```<br>这一句讲的时候，上下文中是将表达式与语句放在一起讨论的。原文是“（你）执行的是一个语句，那么……；而如果你使用……表达式执行，那么……”。前者是语句的值，后者表达式的值。——它们都分别是“一个称为结果（Result）的东西”。<br><br>这样对比来讲的时候，我向来会解释成：<br><br>&gt; 语句和表达式都是有值的，语句的值是“完成（规范类型）”，而表达式的值是“引用（规范类型）”。<br><br>这个区别在后面的章节里面还会有，而且也还会这么讲。主要是这样讲起来清晰、简单，分别起来也很容易。——但是，这样讲并不“准确”。因为事实上表达式的“结果（Result）”也可以是完成类型，而语句的结果还包括一个所谓的“Empty”值。<br><br>在第一章中，要把所有关系到的概念讲清楚是很难的，真要那样讲概念，大概也让人读不下去。所以这里说的是一个简单的区分，也就是如何区别“表达式的值 vs 语句的值”。<br><br><br>【第二句】<br>```<br>ECMAScript 约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用。<br>```<br>这一句是完整而正确的。但是如同上面的讨论中所说的，它其实也并不“绝对完整”，因为有一部分表达式事实上是在返回“完成（规范类型）”。只不过当这种情况发生时，后续的计算过程会从“完成（规范类型）”中直接取值，因此在计算过程中感觉不到“非值”的结果（Result），这是一种中间状态。<br><br>总之，这些内容在后续的章节中还会介绍。会逐渐更新和补全。第一章，以及前几章的内容，要通贯起来看，有很多地方的写法或者讲法，是不得以而（暂且）为之的。关于这一点，我在“加餐（选学的章节）”里面说过，也就可以先略过去，看不明白，或者看起来矛盾的地方，后面再读到的时候，就了解了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1582298019,"ip_address":"","comment_id":180460,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35942025186","product_id":100039701,"comment_content":"表达式的值，在 ECMAScript 的规范中称为“引用”。<br>ECMAScript 约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用。<br>上面这两句话矛盾了吧<br>","like_count":8,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484672,"discussion_content":"并不是矛盾，只是这里解释起来比较别扭。因为“Value”和“Result”，以及“值和引用”在上下文中都存在多种含义。\n\n\n【第一句】\n```\n表达式的值，在 ECMAScript 的规范中称为“引用”。\n```\n这一句讲的时候，上下文中是将表达式与语句放在一起讨论的。原文是“（你）执行的是一个语句，那么……；而如果你使用……表达式执行，那么……”。前者是语句的值，后者表达式的值。——它们都分别是“一个称为结果（Result）的东西”。\n\n这样对比来讲的时候，我向来会解释成：\n\n&amp;gt; 语句和表达式都是有值的，语句的值是“完成（规范类型）”，而表达式的值是“引用（规范类型）”。\n\n这个区别在后面的章节里面还会有，而且也还会这么讲。主要是这样讲起来清晰、简单，分别起来也很容易。——但是，这样讲并不“准确”。因为事实上表达式的“结果（Result）”也可以是完成类型，而语句的结果还包括一个所谓的“Empty”值。\n\n在第一章中，要把所有关系到的概念讲清楚是很难的，真要那样讲概念，大概也让人读不下去。所以这里说的是一个简单的区分，也就是如何区别“表达式的值 vs 语句的值”。\n\n\n【第二句】\n```\nECMAScript 约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用。\n```\n这一句是完整而正确的。但是如同上面的讨论中所说的，它其实也并不“绝对完整”，因为有一部分表达式事实上是在返回“完成（规范类型）”。只不过当这种情况发生时，后续的计算过程会从“完成（规范类型）”中直接取值，因此在计算过程中感觉不到“非值”的结果（Result），这是一种中间状态。\n\n总之，这些内容在后续的章节中还会介绍。会逐渐更新和补全。第一章，以及前几章的内容，要通贯起来看，有很多地方的写法或者讲法，是不得以而（暂且）为之的。关于这一点，我在“加餐（选学的章节）”里面说过，也就可以先略过去，看不明白，或者看起来矛盾的地方，后面再读到的时候，就了解了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582298019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150174,"user_name":"仰望星空","can_delete":false,"product_type":"c1","uid":1117087,"ip_address":"","ucode":"4EA928AC927055","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/9f/788b964e.jpg","comment_is_top":false,"comment_ctime":1573473245,"is_pvip":false,"replies":[{"id":"57796","content":"这个这个，惭愧呀惭愧~ <br><br>我的口语不是一点半点的糟糕（当然，其实不仅仅只是口语糟糕）。我尽量……注意……后面的课程~ 多谢多谢~<br><br>惭愧呀~<br><br>:(~","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573489922,"ip_address":"","comment_id":150174,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31638244317","product_id":100039701,"comment_content":"老师的英语发音delete偏差的有点多","like_count":7,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474083,"discussion_content":"这个这个，惭愧呀惭愧~ \n\n我的口语不是一点半点的糟糕（当然，其实不仅仅只是口语糟糕）。我尽量……注意……后面的课程~ 多谢多谢~\n\n惭愧呀~\n\n:(~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573489922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153441,"user_name":"Marvin","can_delete":false,"product_type":"c1","uid":1138706,"ip_address":"","ucode":"D955A98C48CBEF","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/12/268826e6.jpg","comment_is_top":false,"comment_ctime":1574236277,"is_pvip":false,"replies":[{"id":"59076","content":"哦。确实是这样的。<br><br>但是这个问题与delete运算符无关，这个取决于`delete`将`apple`作为一个名字被&quot;发现(resolving)&quot;的过程。<br><br>由于全局环境的作用域是由global对象和一个词法环境（共同）构成的，所以它查找上面这个名字的顺序是先词法声明，然后才是global对象上的属性的。这个部分请参见ECMAScript：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-global-environment-records-getbindingvalue-n-s<br><br>&gt; If DclRec.HasBinding then return DclRec.GetBindingValue();<br>&gt; else return ObjRec.GetBindingValue()","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574304338,"ip_address":"","comment_id":153441,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27344040053","product_id":100039701,"comment_content":"关于文中delete x的解释，我有一点疑问。<br>文中是这样说的：<br>于是，我们现在可以解释，当 x 是全局对象 global 的属性时，所谓delete x其实只需要返回global.x这个引用就可以了。而当它不是全局对象 global 的属性时，那么就需要从当前环境中找到一个名为x的引用。找到这两种不同的引用的过程，称为 ResolveBinding；而这两种不同的x，称为不同环境下绑定的标识符 &#47; 名字。<br>如果把x解释为引用，而且先寻找global.x，当不是全局属性再寻找当前环境的话：<br>```<br>window.apple = 10;<br>let apple = 10;<br>delete apple; &#47;&#47; false<br>```<br>上面的代码应该先去全局寻找apple引用，那么删除就成功了，应该返回true才对，而不是false。","like_count":6,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475166,"discussion_content":"哦。确实是这样的。\n\n但是这个问题与delete运算符无关，这个取决于`delete`将`apple`作为一个名字被&amp;quot;发现(resolving)&amp;quot;的过程。\n\n由于全局环境的作用域是由global对象和一个词法环境（共同）构成的，所以它查找上面这个名字的顺序是先词法声明，然后才是global对象上的属性的。这个部分请参见ECMAScript：\nhttps://tc39.es/ecma262/#sec-global-environment-records-getbindingvalue-n-s\n\n&amp;gt; If DclRec.HasBinding then return DclRec.GetBindingValue();\n&amp;gt; else return ObjRec.GetBindingValue()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574304338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150468,"user_name":"Mr_Liu","can_delete":false,"product_type":"c1","uid":1472199,"ip_address":"","ucode":"64114CD2E78AB3","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/c7/74d54fb5.jpg","comment_is_top":false,"comment_ctime":1573541450,"is_pvip":false,"replies":[{"id":"57880","content":"问题1中，你的思考方向错了。`delete a`不起作用的原因是`var`声明导致的，而不是因为`a 是基本数据类型`。举例来说，<br><br>`with (x = {a: 100}) delete a;` <br><br>这个例子的结果中x.a是不存在的，但`a 也是基本数据类型`呀。所以是无关的。<br><br>“delete x 还有什么存在的意义么”这个问题我之前回复过另一个留言，你找找。<br><br>关于问题二，关键在于你所理解的“引用与值”，跟JavaScript内部所理解的“引用与值”是不一样的。也正是因此，我在这一讲的一开始用大量文字讨论了二者的区别。简单地来说，如果有表达式`x = x`，那么同一个变量`x`，在上述表达式中，左侧的这个是它的引用，左侧的是它的值。如果放在代码中看：<br><br>x = 5; &#47;&#47; 在JavaScript语言中，&#39;5&#39;是“值类型”<br>x = x; &#47;&#47; 在ECMAScript规范中，左侧是“引用x”，右侧是“值x”。<br><br>我一直用“结果（Result）”来强调表达式“表达式计算的结果”，就是因为对于`x = x`来说，左侧和右侧都是表达式，左侧的结果是“lhs&#47;引用（reference）”，而右侧的结果是“rhs&#47;值（value）”。<br><br>所以所谓“结果（Result）”，在不明确它的手性或用处之前，是二个意思都包含的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573550302,"ip_address":"","comment_id":150468,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27343345226","product_id":100039701,"comment_content":"思考题1：delete x  x不存在返回的是true<br>2:  删除会返回false,严格模式会报错<br>第一遍听感觉有些云里雾里的感觉，又听了一遍加实践。但是有一点不理解或者不知道理解的对不对，希望老师解答一下<br>问题一：<br>例如var a = &#39;123&#39;  delete a 返回的是false , <br>再次输入a 得到结果依然是 ‘123’，<br>这是说明delete  没有起作用，其没有起作用的原因是因为 var a = &#39;123&#39; 中的a 是基本数据类型，不是引用类型，所以删除a 元素失败，借此印证了所讲的delete 删除的是表达式或者引用类型的结果。印证这句话的另一个例子是:<br>var obj = {<br>   a: &#39;123&#39;<br>},<br>var b = obj.a<br>delete b  返回false , 因为b = obj.a  属于一个赋值语句，b 也是个基本数据类型，所以也不起作用<br>那么修改成<br>var obj = {<br>a: &#39;123&#39;,<br>b: {<br>\tname: &#39;123&#39;<br>}<br>}<br>var val = obj.b<br>deletet val 返回的依然是false 后来会读了一下，有这样一句话：delete 其实只能删除一种引用，即对象的成员（Property）<br>那么 delete x 还有什么存在的意义么。<br><br>问题二：<br>接着我使用delete obj.a   返回的是true ,再次输入 obj.a   返回的就是undefined<br>但如果我使用<br>var val = obj.b<br>delete obj.b  返回的是true<br>然后打印 obj.b  为undefined;   val 为 {name: &#39;123&#39;}<br>，那老师的那句delete实际上是删除一个表达式的、引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）。是否可以理解为实际是是删除一直引用呢。","like_count":6,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474168,"discussion_content":"问题1中，你的思考方向错了。`delete a`不起作用的原因是`var`声明导致的，而不是因为`a 是基本数据类型`。举例来说，\n\n`with (x = {a: 100}) delete a;` \n\n这个例子的结果中x.a是不存在的，但`a 也是基本数据类型`呀。所以是无关的。\n\n“delete x 还有什么存在的意义么”这个问题我之前回复过另一个留言，你找找。\n\n关于问题二，关键在于你所理解的“引用与值”，跟JavaScript内部所理解的“引用与值”是不一样的。也正是因此，我在这一讲的一开始用大量文字讨论了二者的区别。简单地来说，如果有表达式`x = x`，那么同一个变量`x`，在上述表达式中，左侧的这个是它的引用，左侧的是它的值。如果放在代码中看：\n\nx = 5; // 在JavaScript语言中，&amp;#39;5&amp;#39;是“值类型”\nx = x; // 在ECMAScript规范中，左侧是“引用x”，右侧是“值x”。\n\n我一直用“结果（Result）”来强调表达式“表达式计算的结果”，就是因为对于`x = x`来说，左侧和右侧都是表达式，左侧的结果是“lhs/引用（reference）”，而右侧的结果是“rhs/值（value）”。\n\n所以所谓“结果（Result）”，在不明确它的手性或用处之前，是二个意思都包含的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573550302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1378133,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEODRricvc32UpO3PxoPrFBDgmoGXdiagcibNh0outmZicXFg1icV4c5ibSknc4be3PWUPsIa3OjdMmlwA/132","nickname":"study","note":"","ucode":"078517D3EF2413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":79044,"discussion_content":"我理解的第二个问题：val和obj.b都是引用，指向地址是{name:&#39;123&#39;}；obj.b被删除了，val的指向地址未变","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576049510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179043,"user_name":"James","can_delete":false,"product_type":"c1","uid":1513489,"ip_address":"","ucode":"953966DEFE4461","user_header":"https://static001.geekbang.org/account/avatar/00/17/18/11/f1f37801.jpg","comment_is_top":false,"comment_ctime":1581902326,"is_pvip":false,"replies":[{"id":"69500","content":"没说它是只读的呀。<br><br>configurable: false，说明它是不可变更配置的，亦即是不能删除该属性，也不能修改属性描述符。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1581917582,"ip_address":"","comment_id":179043,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23056738806","product_id":100039701,"comment_content":"老师问你一个问题。<br>var a = 1<br>delete(a) &#47;&#47; false<br>这个为什么返回false啊，我查看不是只读的。<br>Obect.getOwnPropertyDescriptor(window, &#39;a&#39;)<br>{<br>value: 1<br>writable: true<br>enumerable: true<br>configurable: false<br>}","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484072,"discussion_content":"没说它是只读的呀。\n\nconfigurable: false，说明它是不可变更配置的，亦即是不能删除该属性，也不能修改属性描述符。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581917582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168663,"user_name":"老姚","can_delete":false,"product_type":"c1","uid":1373570,"ip_address":"","ucode":"2008BA6C001B13","user_header":"https://static001.geekbang.org/account/avatar/00/14/f5/82/af81ab59.jpg","comment_is_top":false,"comment_ctime":1578134134,"is_pvip":false,"replies":[{"id":"65444","content":"谢谢。赞的！<br><br>关于ES6之前的ECMAScript翻译，大概最精良的算是w3c的那一份，这在加餐的下节（https:&#47;&#47;time.geekbang.org&#47;column&#47;article&#47;175261）里专门说了一下。这门课程有意地避开了ECMAScript的一些讲述方法（当然也有一些地方是特意去讲ECMAScript的），主要是考虑到课程自己的整体体系和讲述的逻辑，还是与ECMAScript有些差异的。而且，讲ECMAScript的话……讲不完啊。哈哈哈~<br><br>多谢。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1578196897,"ip_address":"","comment_id":168663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23052970614","product_id":100039701,"comment_content":"下面从5.1语言规范上找到的，希望能辅助大家理解。内容copy于某个版本的翻译。<br><br>一、类型分类<br><br>类型分为 ECMAScript 语言类型 与 规范类型 。<br><br> ECMAScript 语言类型 是 ECMAScript 程序员使用 ECMAScript 语言直接操作的值对应的类型。ECMAScript 语言类型包括 未定义 （Undefined）、 空值 （Null）、 布尔值（Boolean）、 字符串 （String）、 数值 （Number）、 对象 （Object）。<br><br> 规范类型 是描述 ECMAScript 语言构造与 ECMAScript 语言类型语意的算法所用的元值对应的类型。规范类型包括 引用 、 列表 、 完结 、 属性描述式 、 属性标示 、 词法环境（Lexical Environment）、 环境纪录（Environment Record）。规范类型的值是不一定对应 ECMAScript 实现里任何实体的虚拟对象。规范类型可用来描述 ECMAScript 表式运算的中途结果，但是这些值不能存成对象的变量或是 ECMAScript 语言变量的值。<br><br> 在本规范中，我们将「x 的类型」简写为 Type(x) ，而类型指的就是上述的 ECMAScript 语言类型 与 规范类型 。<br><br>二、规范类型中的引用类型定义<br> 引用类型用来说明 delete，typeof，赋值运算符这些运算符的行为。例如，在赋值运算中左边的操作数期望产生一个引用。通过赋值运算符左侧运算子的语法案例分析可以但不能完全解释赋值行为，还有个难点：函数调用允许返回引用。承认这种可能性纯粹是为了宿主对象。本规范没有定义返回引用的内置 ECMAScript 函数，并且也不提供返回引用的用户定义函数。（另一个不使用语法案列分析的原因是，那样将会影响规范的很多地方，冗长并且别扭。）<br><br> 一个 引用 (Reference) 是个已解决的命名绑定。一个引用由三部分组成， 基 (base) 值， 引用名称（referenced name） 和布尔值 严格引用 (strict reference) 标志。基值是 undefined, 一个 Object, 一个 Boolean, 一个 String, 一个 Number, 一个 environment record 中的任意一个。基值是 undefined 表示此引用可以不解决一个绑定。引用名称是一个字符串。<br><br> 本规范中使用以下抽象操作接近引用的组件：<br><br>GetBase(V)。 返回引用值 V 的基值组件。<br>GetReferencedName(V)。 返回引用值 V 的引用名称组件。<br>IsStrictReference(V)。 返回引用值 V 的严格引用组件。<br>HasPrimitiveBase(V)。 如果基值是 Boolean, String, Number，那么返回 true。<br>IsPropertyReference(V)。 如果基值是个对象或 HasPrimitiveBase(V) 是 true，那么返回 true；否则返回 false。<br>IsUnresolvableReference(V)。 如果基值是 undefined 那么返回 true，否则返回 false。<br><br>三、delete运算符<br>产生式 UnaryExpression : delete UnaryExpression 按照下面的过程执行 :<br><br>1.令 ref 为解释执行 UnaryExpression 的结果。<br>2.如果 Type(ref) 不是 Reference，返回 true。<br>3.若 IsUnresolvableReference(ref) 则 , 如果 IsStrictReference(ref) 为 true ，抛出一个 SyntaxError 异常。 否则，返回 true。<br>4.如果 IsPropertyReference(ref) 为 true 则： 返回以 GetReferencedName(ref) 和 IsStrictReference(ref) 做为参数调用 ToObject(GetBase(ref)) 的 [[Delete]] 内置方法的结果。<br>5.否则 , ref 是到环境记录项绑定的 Reference，所以： 如果 IsStrictReference(ref) 为 true ，抛出一个 SyntaxError 异常 . 令 bindings 为 GetBase(ref). 返回以 GetReferencedName(ref) 为参数调用绑定的 DeleteBinding 具体方法的结果。<br><br>","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480287,"discussion_content":"谢谢。赞的！\n\n关于ES6之前的ECMAScript翻译，大概最精良的算是w3c的那一份，这在加餐的下节（https://time.geekbang.org/column/article/175261）里专门说了一下。这门课程有意地避开了ECMAScript的一些讲述方法（当然也有一些地方是特意去讲ECMAScript的），主要是考虑到课程自己的整体体系和讲述的逻辑，还是与ECMAScript有些差异的。而且，讲ECMAScript的话……讲不完啊。哈哈哈~\n\n多谢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578196897,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156414,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1574867882,"is_pvip":false,"replies":[{"id":"60101","content":"&gt; 在 ECMAScript 规范中，引用的构成至少需要 base value、referenced name、strict reference flag，具体引擎实现应该会把它们封装成一种数据结构来，从而来操作引用。<br>在ECMAScript中，它就是一种数据结构啊。我们称byte&#47;word&#47;array&#47;map为数据结构，为什么“Specification Types”就不是呢？你看ECMAScript规范里面，“Specification Types”就是在“Data Types”这一章中的一节啊。<br><br>&gt; 而文中把 x = x 中的 x 叫做一个引用，应该不是很精确，x 只是引用的 referenced name。<br>不对。左侧的x就是引用，而不仅仅是referenced name。只是代码文本（在静态读代码的情况下）它是个名字x而已。<br><br>&gt; 因为我们代码层面无法获取引用，也就没有名字，所以这里用 x 指代规范中的引用。<br>代码层面是可以获取所谓“引用”的，而且是“规范类型”中的引用。例如delete obj.x中的`obj.x`整体上就是一个引用。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574909139,"ip_address":"","comment_id":156414,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23049704362","product_id":100039701,"comment_content":"在 ECMAScript 规范中，引用的构成至少需要 base value、referenced name、strict reference flag，具体引擎实现应该会把它们封装成一种数据结构来，从而来操作引用。<br><br>而文中把 x = x 中的 x 叫做一个引用，应该不是很精确，x 只是引用的 referenced name。<br><br>因为我们代码层面无法获取引用，也就没有名字，所以这里用 x 指代规范中的引用。<br><br>请问老师这样理解对么？","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476099,"discussion_content":"&amp;gt; 在 ECMAScript 规范中，引用的构成至少需要 base value、referenced name、strict reference flag，具体引擎实现应该会把它们封装成一种数据结构来，从而来操作引用。\n在ECMAScript中，它就是一种数据结构啊。我们称byte/word/array/map为数据结构，为什么“Specification Types”就不是呢？你看ECMAScript规范里面，“Specification Types”就是在“Data Types”这一章中的一节啊。\n\n&amp;gt; 而文中把 x = x 中的 x 叫做一个引用，应该不是很精确，x 只是引用的 referenced name。\n不对。左侧的x就是引用，而不仅仅是referenced name。只是代码文本（在静态读代码的情况下）它是个名字x而已。\n\n&amp;gt; 因为我们代码层面无法获取引用，也就没有名字，所以这里用 x 指代规范中的引用。\n代码层面是可以获取所谓“引用”的，而且是“规范类型”中的引用。例如delete obj.x中的`obj.x`整体上就是一个引用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574909139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150258,"user_name":"半橙汁","can_delete":false,"product_type":"c1","uid":1477902,"ip_address":"","ucode":"BB93BB9CCB7FA2","user_header":"https://static001.geekbang.org/account/avatar/00/16/8d/0e/5e97bbef.jpg","comment_is_top":false,"comment_ctime":1573485463,"is_pvip":false,"replies":[{"id":"57806","content":"那三本书很不错！值得一读。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573492060,"ip_address":"","comment_id":150258,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23048321943","product_id":100039701,"comment_content":"在《你不知道JavaScript-上》中，看到过关于lhs和rhs的相关介绍，涉及到很多编译，语法解析的知识，真的很难肯...<br>希望通过对老师专栏的学习，能够更加顺畅地去啃另外的中、下两本😂😂😂","like_count":5,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474108,"discussion_content":"那三本书很不错！值得一读。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573492060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160303,"user_name":"leslee","can_delete":false,"product_type":"c1","uid":1384326,"ip_address":"","ucode":"DB1CBF9F8D16BF","user_header":"https://static001.geekbang.org/account/avatar/00/15/1f/86/3a7eeac4.jpg","comment_is_top":false,"comment_ctime":1575910097,"is_pvip":false,"replies":[{"id":"61198","content":"这里一直存在两个概念：“引用”是JavaScript“语言类型”中的一种分类方式，引用包括对象和函数；“引用（规范类型）”是ECMAScript的“规范类型”中的一个数据类型。<br><br>有两个措辞上的区别：1、语言类型与规范类型是不同的；2、一种分类方式与一个数据类型是不同的。<br><br>在ECMAScript中，引用是一个数据类型，它是一个记录，有几个字段（域&#47;成员），可以存放一个指向某种数据的结构。ECMAScript是为了实现一门语言而设计的，所以这些数据类型是实现用的组件，而不是语言（例如一门具体的JavaScript语言）本身的数据类型，更不是它们的“某种分类”。<br><br>而在JavaScript中，显然数字2，与字符串&quot;abc&quot;都是值类型。但是，无论是在JavaScript还是在其它语言中，通常这两种值的处理方式都有着区别，就是所谓的“字符串是值类型，但按引用方式传递和赋值”。通常大家都是如此。比如一个引用传递的过程：<br>```<br>a = &#39;abc&#39;<br>b = a<br>c = b<br>```<br>如果第二、三行代码都是每个字符都复制给b、c的话，那么代价就特别高（例如字符串可能1K字节长、或者1T字节长），所以它们在赋值中就只是传递了a的一个引用。——并且，事实上，在第一行赋值时，a也只是拿到了字符串字面量（值）的一个引用而已。<br><br>这一讲的内容，就是在前面部分说“传统的引用”，在后面部分说“ECMAScript中的引用（规范类型）”。两种概念就是不同的，仔细看看各小节的标题，就能发现这个转折了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575944170,"ip_address":"","comment_id":160303,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18755779281","product_id":100039701,"comment_content":"所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的<br><br>看了一些老师的解释还是有点疑惑， 这句话可以拆成两部分，值类型的字符串是按照引用来赋值的， 与值类型的字符串是按照引用来传递引用的，但是又说这里的引用不是规范类型引用， 那这里的引用如何理解， 因为在代码中字符串的赋值表现，也是抄写。","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477328,"discussion_content":"这里一直存在两个概念：“引用”是JavaScript“语言类型”中的一种分类方式，引用包括对象和函数；“引用（规范类型）”是ECMAScript的“规范类型”中的一个数据类型。\n\n有两个措辞上的区别：1、语言类型与规范类型是不同的；2、一种分类方式与一个数据类型是不同的。\n\n在ECMAScript中，引用是一个数据类型，它是一个记录，有几个字段（域/成员），可以存放一个指向某种数据的结构。ECMAScript是为了实现一门语言而设计的，所以这些数据类型是实现用的组件，而不是语言（例如一门具体的JavaScript语言）本身的数据类型，更不是它们的“某种分类”。\n\n而在JavaScript中，显然数字2，与字符串&amp;quot;abc&amp;quot;都是值类型。但是，无论是在JavaScript还是在其它语言中，通常这两种值的处理方式都有着区别，就是所谓的“字符串是值类型，但按引用方式传递和赋值”。通常大家都是如此。比如一个引用传递的过程：\n```\na = &amp;#39;abc&amp;#39;\nb = a\nc = b\n```\n如果第二、三行代码都是每个字符都复制给b、c的话，那么代价就特别高（例如字符串可能1K字节长、或者1T字节长），所以它们在赋值中就只是传递了a的一个引用。——并且，事实上，在第一行赋值时，a也只是拿到了字符串字面量（值）的一个引用而已。\n\n这一讲的内容，就是在前面部分说“传统的引用”，在后面部分说“ECMAScript中的引用（规范类型）”。两种概念就是不同的，仔细看看各小节的标题，就能发现这个转折了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575944170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152335,"user_name":"鹿由菌","can_delete":false,"product_type":"c1","uid":1013622,"ip_address":"","ucode":"B080A242DF1C8D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/76/68d93fe8.jpg","comment_is_top":false,"comment_ctime":1573976886,"is_pvip":false,"replies":[{"id":"58558","content":"谢谢。<br><br>不过这一篇确实是这么写的呀？第一节是“习惯中的引用”，然后写到第四节指明“规范中的引用”。从第1~3节是讲历史，和在这个背景下出现的问题。然后第4节提出ECMAScript中在规范类型中的“引用”，用来解决这些问题。所以也是从第3节末尾才提出Result这个东西，并一并提出了引用。——大概，整体上是这么个叙述路径。<br><br>因为我的课程本意上不是为了讲`delete x`这么个运算，让读者知道答案。而是讲背后的这些基础原理、概念和核心的逻辑等等，所以通常标题中的问题只是个引子，讲述的过程也不是直奔答案，而是把答案关联的所有东西全带出来。所以“整个的过程”很重要，过程中涉及到的东西很重要，反倒是答案，并不太重要。<br><br>^^. 再次谢谢你的建议。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573991925,"ip_address":"","comment_id":152335,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18753846070","product_id":100039701,"comment_content":"提个不成熟的建议，老师不如先明确解释出规范中的Reference Specification Type，然后再讨论delete相关的问题，不然XXX表达式的Result、“引用”，“值”就太懵逼了。","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474786,"discussion_content":"谢谢。\n\n不过这一篇确实是这么写的呀？第一节是“习惯中的引用”，然后写到第四节指明“规范中的引用”。从第1~3节是讲历史，和在这个背景下出现的问题。然后第4节提出ECMAScript中在规范类型中的“引用”，用来解决这些问题。所以也是从第3节末尾才提出Result这个东西，并一并提出了引用。——大概，整体上是这么个叙述路径。\n\n因为我的课程本意上不是为了讲`delete x`这么个运算，让读者知道答案。而是讲背后的这些基础原理、概念和核心的逻辑等等，所以通常标题中的问题只是个引子，讲述的过程也不是直奔答案，而是把答案关联的所有东西全带出来。所以“整个的过程”很重要，过程中涉及到的东西很重要，反倒是答案，并不太重要。\n\n^^. 再次谢谢你的建议。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573991925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":213446,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1588416622,"is_pvip":false,"replies":[{"id":"79167","content":"Oh... 为了避免误会，我先强调一下：<br><br>&gt; 我在这篇文章中说对于全局的`var x`来说，`delete x`等义于`delete global.x`，但没说`delete global.x`是不是真能“删除得掉”。<br><br>我只是在说实现上它们两者的关联。<br><br>而回到 @HoSalt 你的问题。全局作用域中，函数声明其实跟`var x`声明一样，都是放在global.xxx的属性值中的，它们的实现机制是一样的，这是早期JavaScript设计中就约定过的。函数声明不能删除，同样，`var x`声明也如此，也是不能删除掉的。如下例：<br><br>```<br>&gt; node -e &#39;var x = 100; delete x; console.log(typeof x)&#39;<br>&#39;number&#39;<br>```<br>你这里换成函数foo的声明，也是一样的。<br><br>至于实现方式上，这样的`var x`与`function foo() ...`都被声明为global上的不可删除的属性（configurable: false）。例如：<br><br>```<br>&gt; node -p &#39;functoin foo() {};  console.log(Object.getOwnPropertyDescriptor(global, &quot;foo&quot;))&#39;<br>{ value: [Function: foo],<br>  writable: true,<br>  enumerable: true,<br>  configurable: false }<br>```<br><br>好的。关于你的第二个问题，其实严格模式与非严格模式在这个问题上并没有不同，它们的base都是指向null的。他们的差异是一个执行效果：<br><br>&gt; 如果foo“在执行时”没有传入this，那么在严格模式中，它缺省使用null，而在非严格模式中，它缺省使用global。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1588473900,"ip_address":"","comment_id":213446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14473318510","product_id":100039701,"comment_content":"老师，我有两个问题想问下<br>1. 为什么全局作用域下函数的声明无法删除，其也是windows的属性值<br>2. 全局作用域下声明的函数，调用时其base是否指向windows，在严格模式下全局作用域下的函数内的this指向了undefined","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493782,"discussion_content":"Oh... 为了避免误会，我先强调一下：\n\n&amp;gt; 我在这篇文章中说对于全局的`var x`来说，`delete x`等义于`delete global.x`，但没说`delete global.x`是不是真能“删除得掉”。\n\n我只是在说实现上它们两者的关联。\n\n而回到 @HoSalt 你的问题。全局作用域中，函数声明其实跟`var x`声明一样，都是放在global.xxx的属性值中的，它们的实现机制是一样的，这是早期JavaScript设计中就约定过的。函数声明不能删除，同样，`var x`声明也如此，也是不能删除掉的。如下例：\n\n```\n&amp;gt; node -e &amp;#39;var x = 100; delete x; console.log(typeof x)&amp;#39;\n&amp;#39;number&amp;#39;\n```\n你这里换成函数foo的声明，也是一样的。\n\n至于实现方式上，这样的`var x`与`function foo() ...`都被声明为global上的不可删除的属性（configurable: false）。例如：\n\n```\n&amp;gt; node -p &amp;#39;functoin foo() {};  console.log(Object.getOwnPropertyDescriptor(global, &amp;quot;foo&amp;quot;))&amp;#39;\n{ value: [Function: foo],\n  writable: true,\n  enumerable: true,\n  configurable: false }\n```\n\n好的。关于你的第二个问题，其实严格模式与非严格模式在这个问题上并没有不同，它们的base都是指向null的。他们的差异是一个执行效果：\n\n&amp;gt; 如果foo“在执行时”没有传入this，那么在严格模式中，它缺省使用null，而在非严格模式中，它缺省使用global。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588473900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194572,"user_name":"张木公","can_delete":false,"product_type":"c1","uid":1042672,"ip_address":"","ucode":"6165970C6FE179","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/f0/b7206e15.jpg","comment_is_top":false,"comment_ctime":1585068736,"is_pvip":false,"replies":[{"id":"74098","content":"这个与“一切皆对象”没关系，JavaScript的这个口号是从Java来的，所以事实上JavaScript的对象概念以及对象系统（就是那些类）很多在设计上都跟Java相似。<br>内存模型在JavaScirpt中没有堆&#47;栈的问题，解释执行技术与原生执行是有区别的。ECMAScript也没有约定执行js代码的内存模型或回收机制，因此这与具体的实现有关。<br>最后，关于对象、全局对象以及对象模型等等，在后面的课程中会更细的讲到。大概是在12~13节之后吧。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1585114024,"ip_address":"","comment_id":194572,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14469970624","product_id":100039701,"comment_content":"由于全局变量实际上是通过全局对象的属性来实现的<br>这个知识点初学者都知道，但是听老师一说才把这个点和js的对象模型联系起来<br>请问老师，是不是因为这个知识点所以才有很多人说 js一切皆对象 。<br>函数作用域中定义的变量是哪个对象的属性<br>js内存模型是不是不分堆栈了，因为基本类型其实是引用类型的属性","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488848,"discussion_content":"这个与“一切皆对象”没关系，JavaScript的这个口号是从Java来的，所以事实上JavaScript的对象概念以及对象系统（就是那些类）很多在设计上都跟Java相似。\n内存模型在JavaScirpt中没有堆/栈的问题，解释执行技术与原生执行是有区别的。ECMAScript也没有约定执行js代码的内存模型或回收机制，因此这与具体的实现有关。\n最后，关于对象、全局对象以及对象模型等等，在后面的课程中会更细的讲到。大概是在12~13节之后吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585114024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174231,"user_name":"h.g.","can_delete":false,"product_type":"c1","uid":1108490,"ip_address":"","ucode":"2F362C03BCE5EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/ea/0a/f82fa85d.jpg","comment_is_top":false,"comment_ctime":1580101160,"is_pvip":true,"replies":[{"id":"67843","content":"尝试一下<br><br>```<br>&gt; Object.getOwnPropertyDescriptor(global, &#39;a&#39;)<br>{ value: 1,<br>  writable: true,<br>  enumerable: true,<br>  configurable: false }<br>```<br>其configurable为false，所以不能删除。<br><br>所有使用`var x`来声明的全局变量`x`的configurable为 false，所以不能删除，且它放在varNames中的名字`x`也不能被移除。<br><br>但是如果使用`eval(&quot;var a=1&quot;)`来实现在全局声明`x`，那么这个configurable将为true，所以它能被移除，且varNames中的名字也可以移除掉。这是唯一能操作到varNames中名字的方法。并且这也导致了全局的变量环境（这个在后面的课程中会讲到）可以被操作。<br><br>最后，如果直接使用`x = 1`通过变量名泄露来在全局创建名字x，那么这个x不会出现在varNames中，且它作为global上的属性时的configurable为true。所以也是可以被移除掉的。<br><br>多试一下，就有结论了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1580272717,"ip_address":"","comment_id":174231,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14465003048","product_id":100039701,"comment_content":"&gt; var a = 1<br>undefined<br>&gt; global.a<br>1<br>&gt; delete global.a<br>false<br>&gt; global.a<br>1<br>&gt; <br><br>咨询一下，为什么，这种挂载全局的变量，无法删除，<br>这个也满足 delete --&gt; a = object.a 的条件","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482340,"discussion_content":"尝试一下\n\n```\n&amp;gt; Object.getOwnPropertyDescriptor(global, &amp;#39;a&amp;#39;)\n{ value: 1,\n  writable: true,\n  enumerable: true,\n  configurable: false }\n```\n其configurable为false，所以不能删除。\n\n所有使用`var x`来声明的全局变量`x`的configurable为 false，所以不能删除，且它放在varNames中的名字`x`也不能被移除。\n\n但是如果使用`eval(&amp;quot;var a=1&amp;quot;)`来实现在全局声明`x`，那么这个configurable将为true，所以它能被移除，且varNames中的名字也可以移除掉。这是唯一能操作到varNames中名字的方法。并且这也导致了全局的变量环境（这个在后面的课程中会讲到）可以被操作。\n\n最后，如果直接使用`x = 1`通过变量名泄露来在全局创建名字x，那么这个x不会出现在varNames中，且它作为global上的属性时的configurable为true。所以也是可以被移除掉的。\n\n多试一下，就有结论了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580272717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":155235,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1037234,"ip_address":"","ucode":"08CA8F4F4F20A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d3/b2/4a4cc464.jpg","comment_is_top":false,"comment_ctime":1574669778,"is_pvip":true,"replies":[{"id":"59903","content":"Yes. 不过问题1中的`delete x`并不简单，明天的课程（加餐）里面，正好会再讲一点这个方面的东西，会有一个更深度的解析。<br>所以这里就先不多讲了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574777003,"ip_address":"","comment_id":155235,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14459571666","product_id":100039701,"comment_content":"1、delete x 中，如果 x 根本不存在，会发生什么？<br>直接返回true，不做任何处理。<br>x是未声明的变量，会被当成全局对象的属性，且是可以被删除的<br>严格模式下会报错：Delete of an unqualified identifier in strict mode<br>2、delete object.x 中，如果 x 是只读的，会发生什么？<br>返回false，不删除属性x<br>属性的特性是不可删除(只读)，所以不能被删除<br>严格模式下会报错：Cannot delete property &#39;x&#39; of object....<br><br>他俩最根本的差别在于：属性的特性是否有DontDelete","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475700,"discussion_content":"Yes. 不过问题1中的`delete x`并不简单，明天的课程（加餐）里面，正好会再讲一点这个方面的东西，会有一个更深度的解析。\n所以这里就先不多讲了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574777003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154565,"user_name":"不负","can_delete":false,"product_type":"c1","uid":1238323,"ip_address":"","ucode":"147F5860711811","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/33/ff5c52ad.jpg","comment_is_top":false,"comment_ctime":1574480473,"is_pvip":true,"replies":[{"id":"59531","content":"1. 从＜规范中的“引用”＞这个小节之后，所使用的“引用”都是ECMAScript规范中的定义。<br><br>2. 正是为了避免你说的“判断表达式的值是值还是引用”这样的说法，所以我才一直使用“结果(Result)”。而且事实上，在ECMAScript里面，对于语句或表达式执行的“结果”用的都是Result，而不是Value这个词。<br><br>&gt; <br>&gt; “{}计算结果就是{}，{}是一个值”<br>&gt;<br><br>的确如此。这里没有讲错。“结果（Result）”是一个“值”。——它既然不是一个ECMAScript中的引用，就必然是一个ECMAScript中的值。<br><br>你去看ECMAScript中的完成记录类型，它有一个成员称为“[Value]”，例如有一个函数返回一个obj时，那这个obj就填入“[Value]”这个成员里面。——如果obj不是值，那么它怎么填进去？<br><br>在这里：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-completion-record-specification-type","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574659881,"ip_address":"","comment_id":154565,"utype":1}],"discussion_count":1,"race_medal":1,"score":"14459382361","product_id":100039701,"comment_content":"1）“表达式的结果是什么”这一段中表述了&#39; 表达式的值，在 ECMAScript 的规范中，称为“引用” &#39;，之后用到引用是传统理解的引用还是ECMAScript规范中定义的（表达式的值）？<br>2）这一段后对“引用”这个词很懵逼，如：表达式计算的结果再判断是值还是引用，① 如果此处的“引用”指ECMAScript定义的，就变成了“判断表达式的值是值还是引用”，表达式的值不是值？②在&#39; {} 表示一个字面量的对象，当它被作为表达式执行的时候，结果也是一个值。&#39; 这里的{}计算结果就是{}，{}是一个值？不太理解这个","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475509,"discussion_content":"1. 从＜规范中的“引用”＞这个小节之后，所使用的“引用”都是ECMAScript规范中的定义。\n\n2. 正是为了避免你说的“判断表达式的值是值还是引用”这样的说法，所以我才一直使用“结果(Result)”。而且事实上，在ECMAScript里面，对于语句或表达式执行的“结果”用的都是Result，而不是Value这个词。\n\n&amp;gt; \n&amp;gt; “{}计算结果就是{}，{}是一个值”\n&amp;gt;\n\n的确如此。这里没有讲错。“结果（Result）”是一个“值”。——它既然不是一个ECMAScript中的引用，就必然是一个ECMAScript中的值。\n\n你去看ECMAScript中的完成记录类型，它有一个成员称为“[Value]”，例如有一个函数返回一个obj时，那这个obj就填入“[Value]”这个成员里面。——如果obj不是值，那么它怎么填进去？\n\n在这里：\nhttps://tc39.es/ecma262/#sec-completion-record-specification-type","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574659881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150646,"user_name":"ssala","can_delete":false,"product_type":"c1","uid":1005356,"ip_address":"","ucode":"CCD82C81756FC6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/2c/b0793828.jpg","comment_is_top":false,"comment_ctime":1573573783,"is_pvip":false,"replies":[{"id":"57985","content":"语句有值的问题，在我之前的博客文章中有一篇写得比较详细。你不妨看看：https:&#47;&#47;blog.csdn.net&#47;aimingoo&#47;article&#47;details&#47;51136511","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573611705,"ip_address":"","comment_id":150646,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14458475671","product_id":100039701,"comment_content":"我先不求甚解吧，因为好多概念我不理解，或者以往理解有误，表达式和语句跟我之前的理解都不一样，我一直以为语句可能不产生值。<br><br>感谢老师如此较真地探讨这些问题，期待后续更新。","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474230,"discussion_content":"语句有值的问题，在我之前的博客文章中有一篇写得比较详细。你不妨看看：https://blog.csdn.net/aimingoo/article/details/51136511","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573611705,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150115,"user_name":"文全","can_delete":false,"product_type":"c1","uid":1390436,"ip_address":"","ucode":"0E8AB17F90A91C","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/64/dfba5f1c.jpg","comment_is_top":false,"comment_ctime":1573464148,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14458366036","product_id":100039701,"comment_content":"作为一个工作几年的前端，急需这部分底层原理","like_count":3,"discussions":[{"author":{"id":1003716,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/50/c4/c311b591.jpg","nickname":"Amundsen","note":"","ucode":"10F828DD46E762","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":117655,"discussion_content":"哈哈哈，今天再看文章，看到文全你了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578133726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374615,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f9/97/ecd93d91.jpg","nickname":"张雪飞","note":"","ucode":"6A00E3A595EBD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":48222,"discussion_content":"第一个 true 第二个返回 false","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573465637,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300805,"user_name":"向上","can_delete":false,"product_type":"c1","uid":1465483,"ip_address":"","ucode":"914DF6837E85AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/5c/8b/a9df379f.jpg","comment_is_top":false,"comment_ctime":1625393426,"is_pvip":false,"replies":[{"id":"109046","content":"赞！@向上 同学<br><br>我很仔细地读了您全部的问题，老实说开始的时候觉得很乱，但读了几遍之后，发现你是真的想得很深入，才会像这样问的。很多地方，问得非常到位。<br><br>先回答最后一个点，它可能是你解开疑惑的关键。其它部分若相互有关联，我会再解释。再次地说，你真的提出了很多好问题！<br><br>Q：为什么需要引用类型?是因为表达式运算会用到操作数的环境信息？<br>---<br>是的。这非常重要。所以我只是强调、并重复你的话：引用类型的存在，就是因为某些情况下表达式需要引用操作数的环境信息！<br><br><br>Q：表达式的结果什么时候作为ref使用，什么时候作为value = getValue(ref)使用？与运算符相关吗？还是类似symbol.toPrimitive有预期hint?<br>----<br>与运算符直接相关（后面我会列到）。没有预期的hint，只有手性的问题，也就是结果是作为rhs还是lhs，这是运算符对运算数的约定。<br><br>Q：……，这个表达式运算是否可以理解为在执行环境中查找 obj 和 key 的 ref，然后getValue(ref)得到 {x() {}} 和 &#39;x&#39; 两个值，结合属性读取表达式[]得到 ({ x() {} })[&quot;x&quot;] 表达式的运算结果；<br>----<br>这里你的思路是对的，用这种替代的法子可以解释一些东西。但是并没有“getValue(ref)来取{x(){}}”这个值——你说得没有错，它在语言的层面是一个对象（引用类型），但在引擎层面，它就是一个值（是一个操作数）。但是因为这里的obj是运算符“[]”的左手端，所以这个操作数是使用引用ref的，而不是使用值，所以并没有对它使用getValue(ref)。<br><br>Q：rst = obj[key]、fn(obj[key])、return obj[key]、（true &amp;&amp; obj[key])() 等场景下这个结果作为 value 来使用，obj[key]()、(obj[key])()等场景作为ref使用;<br>----<br>你举的例子很好，这的确可以看成两种场景。前一种场景下它（将obj[key]结果作为ref）都将进一步地作为value，所以会调用一次getValue(ref)。例如实际的效果是`return getValue(obj[key])`，所以并没有办法在函数中返回一个对象属性的“引用(ref)”。同理，后一场景下它就作为ref直接返回了。——所以(obj[key])()能使用到ref，并且在函数调用过程中能从ref中找到this。<br><br>Q：这个结果如果不参与其他运算，其表现是否与单值表达式相同？<br>----<br>总有一个最后“运算”的结果的。一个表达式结束，它总会返回结果（Result），哪怕它作为值或作为引用被弃用，都无关。而在语句中也是类似的，总会有最后一个结果作为语句的值。但是二者还是有一点点儿不同，表达式的结果总是不分“引用&#47;值”的Result——如果它没有下一个表达式来使用的话，它就不需要判断最终形态。但语句的结果值“总是”值，这是因为语句的结果值是用“完成记录类型（ECMAScript规范类型）”来达的，因为CompletionRecord.value这个域只能存放值而不能存放引用，所以语句完成时无论有没有人使用这个值，ref都将调用getValue(ref)并把值放到这个域中。——eval()是执行语句，并将语句的结果值返回的，所以无论eval()执行的是哪种表达式，结果都不会返回引用。这是`(obj.key)`和`eval(&quot;(obj.key)&quot;)`存在不同的根源。<br><br>Q：是否可以理解为表达式结果少数情况（delete、typeof、属性读取）会作为ref使用，其余作为value使用？<br>怎么区分，……<br>------<br>是的。但我说过，这取决于“运算符”，而不是“少数情况”或“场景”。尽管看起来可能意思差不多，但用运算符（的运算数）来确指它，更科学。^^.<br><br>Q：有哪些运算符限定操作数是“引用”？<br>-----<br>赋值运算符的左端，例如x = 1；<br>属性存取运算符的左端，例如x.a，或者x[&quot;a&quot;]；<br>分组运算符——就是一对()——的运算数，例如(x)<br>删除运算符：delete x<br>类型运算符：typeof x<br>另外，用名称引用的单值表达式（一般来说称为变量名），例如“x”是一个引用。但是它没在我们说的“某个运算符的操作数”的范畴内。这包括在with语句中，属性名充作的变量名，例如：with ({x:1}) { x }中的后一个x。<br><br>差不多我一时间就能想起这些了。这些“限定引用”的地方其实也能用值，就好象`delete 1`一样，只不过当那个操作数是“引用(ref)”时不会隐式地用getValue(ref)来取出值。同样的，这也才能进一步讲通`true.toString()`的语义。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1625498743,"ip_address":"","comment_id":300805,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10215328018","product_id":100039701,"comment_content":"各位同学好，爱民老师好，我有几个问题<br>表达式的结果什么时候作为ref使用，什么时候作为value = getValue(ref)使用？与运算符相关吗？还是类似symbol.toPrimitive有预期hint?<br><br>x = x，赋值表达式：ref = value；<br>x，单值表达式：value， 使用未声明的变量会报 ref 错误，是因为对其进行了求值；<br><br>复杂表达式运算时，会先对其中简单表达式进行求值然后结合运算符进行后续运算<br><br>let obj = { x() {} }, key = &#39;x&#39;;<br>obj[key];<br><br>这个表达式运算是否可以理解为在执行环境中查找 obj 和 key 的 ref，然后getValue(ref)得到 {x() {}} 和 &#39;x&#39; 两个值，结合属性读取表达式[]得到 ({ x() {} })[&quot;x&quot;] 表达式的运算结果；<br><br>rst = obj[key]、fn(obj[key])、return obj[key]、（true &amp;&amp; obj[key])() 等场景下这个结果作为 value 来使用，obj[key]()、(obj[key])()等场景作为ref使用;<br><br>这个结果如果不参与其他运算，其表现是否与单值表达式相同？<br><br>是否可以理解为表达式结果少数情况（delete、typeof、属性读取）会作为ref使用，其余作为value使用？<br><br>怎么区分？<br>以运算符作为区分的话，例子中同样的两个操作数和一个属性访问操作符在不同场景下表达式的表现不同？<br>场景区分的话，少数情况包含哪些场景？<br><br>表达式的结果为什么这样设计?为什么需要引用类型?是因为表达式运算会用到操作数的环境信息？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522822,"discussion_content":"赞！@向上 同学\n\n我很仔细地读了您全部的问题，老实说开始的时候觉得很乱，但读了几遍之后，发现你是真的想得很深入，才会像这样问的。很多地方，问得非常到位。\n\n先回答最后一个点，它可能是你解开疑惑的关键。其它部分若相互有关联，我会再解释。再次地说，你真的提出了很多好问题！\n\nQ：为什么需要引用类型?是因为表达式运算会用到操作数的环境信息？\n---\n是的。这非常重要。所以我只是强调、并重复你的话：引用类型的存在，就是因为某些情况下表达式需要引用操作数的环境信息！\n\n\nQ：表达式的结果什么时候作为ref使用，什么时候作为value = getValue(ref)使用？与运算符相关吗？还是类似symbol.toPrimitive有预期hint?\n----\n与运算符直接相关（后面我会列到）。没有预期的hint，只有手性的问题，也就是结果是作为rhs还是lhs，这是运算符对运算数的约定。\n\nQ：……，这个表达式运算是否可以理解为在执行环境中查找 obj 和 key 的 ref，然后getValue(ref)得到 {x() {}} 和 &amp;#39;x&amp;#39; 两个值，结合属性读取表达式[]得到 ({ x() {} })[&amp;quot;x&amp;quot;] 表达式的运算结果；\n----\n这里你的思路是对的，用这种替代的法子可以解释一些东西。但是并没有“getValue(ref)来取{x(){}}”这个值——你说得没有错，它在语言的层面是一个对象（引用类型），但在引擎层面，它就是一个值（是一个操作数）。但是因为这里的obj是运算符“[]”的左手端，所以这个操作数是使用引用ref的，而不是使用值，所以并没有对它使用getValue(ref)。\n\nQ：rst = obj[key]、fn(obj[key])、return obj[key]、（true &amp;amp;&amp;amp; obj[key])() 等场景下这个结果作为 value 来使用，obj[key]()、(obj[key])()等场景作为ref使用;\n----\n你举的例子很好，这的确可以看成两种场景。前一种场景下它（将obj[key]结果作为ref）都将进一步地作为value，所以会调用一次getValue(ref)。例如实际的效果是`return getValue(obj[key])`，所以并没有办法在函数中返回一个对象属性的“引用(ref)”。同理，后一场景下它就作为ref直接返回了。——所以(obj[key])()能使用到ref，并且在函数调用过程中能从ref中找到this。\n\nQ：这个结果如果不参与其他运算，其表现是否与单值表达式相同？\n----\n总有一个最后“运算”的结果的。一个表达式结束，它总会返回结果（Result），哪怕它作为值或作为引用被弃用，都无关。而在语句中也是类似的，总会有最后一个结果作为语句的值。但是二者还是有一点点儿不同，表达式的结果总是不分“引用/值”的Result——如果它没有下一个表达式来使用的话，它就不需要判断最终形态。但语句的结果值“总是”值，这是因为语句的结果值是用“完成记录类型（ECMAScript规范类型）”来达的，因为CompletionRecord.value这个域只能存放值而不能存放引用，所以语句完成时无论有没有人使用这个值，ref都将调用getValue(ref)并把值放到这个域中。——eval()是执行语句，并将语句的结果值返回的，所以无论eval()执行的是哪种表达式，结果都不会返回引用。这是`(obj.key)`和`eval(&amp;quot;(obj.key)&amp;quot;)`存在不同的根源。\n\nQ：是否可以理解为表达式结果少数情况（delete、typeof、属性读取）会作为ref使用，其余作为value使用？\n怎么区分，……\n------\n是的。但我说过，这取决于“运算符”，而不是“少数情况”或“场景”。尽管看起来可能意思差不多，但用运算符（的运算数）来确指它，更科学。^^.\n\nQ：有哪些运算符限定操作数是“引用”？\n-----\n赋值运算符的左端，例如x = 1；\n属性存取运算符的左端，例如x.a，或者x[&amp;quot;a&amp;quot;]；\n分组运算符——就是一对()——的运算数，例如(x)\n删除运算符：delete x\n类型运算符：typeof x\n另外，用名称引用的单值表达式（一般来说称为变量名），例如“x”是一个引用。但是它没在我们说的“某个运算符的操作数”的范畴内。这包括在with语句中，属性名充作的变量名，例如：with ({x:1}) { x }中的后一个x。\n\n差不多我一时间就能想起这些了。这些“限定引用”的地方其实也能用值，就好象`dele","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625498743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289971,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1100750,"ip_address":"","ucode":"768098DBDBE333","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/ce/d9e00eb5.jpg","comment_is_top":false,"comment_ctime":1619285896,"is_pvip":false,"replies":[{"id":"105318","content":"有关GetBase，可以参考我之前的一个视频【JS在引擎级别的执行过程】，在这里：<br>https:&#47;&#47;www.bilibili.com&#47;s&#47;video&#47;BV1Wy4y1b7PG<br><br>其中对“引用（规范类型）”的结构有过讲述，那里面的base，就是这里GetBase()操作的对象。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1619666051,"ip_address":"","comment_id":289971,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10209220488","product_id":100039701,"comment_content":"- 本篇似乎是整个专栏中评论最多的一讲。或许因为这是第一篇实际内容，更或许，如果理解了本文的内容，后续的文章就容易理解多了，导致后续的评论相对较少。<br>- 设问环节<br>  - delete 操作符的用法<br>  - delete 0 是在删除什么<br>  - 什么是引用<br>  - JavaScript 中的引用和 Java 中的引用有什么区别<br>  - 引用和指针的区别<br>  - 可以操作引用的运算符或行为有哪些<br>  - 标题中的 &quot;销毁&quot; 指的是什么<br>  - try catch 出现于什么时候<br>  - strict mode 出现于什么时候<br>  - 为什么要提到 typeof<br>- 文章的表述思路<br>  - 什么是引用类型<br>  - delete x 要面临的多种情况<br>  - delete 0 到底是在做什么<br>  - 删除一个表达式的结果，那么表达式的结果又是什么<br>  - 规范中的引用<br>  - 引用和值的运算<br>  - 对象存取 + 函数调用 = 方法调用<br>  - delete 其实只能删除一种引用，即对象的成员<br>- 文中的部分知识点<br>  - typeof 出现于 JavaScript 1.1 | 1997<br>  - delete 出现于 JavaScript 1.2 | 1998<br>  - Object 和 Function 就是引用类型<br>  - 所有删除值的 delete 就直接返回 true<br>  - delete 是在删除一个表达式的结果<br>  - 表达式的值是什么？规范中的 &quot;引用&quot;<br>  - 任何表达式计算的结果（Result）要么是一个值，要么是一个引用。<br>  - obj.x() 是在 JavaScript 中集合了“引用规范类型操作”、“函数式”、“面向对象”和“动态语言”等多种特性于一体的一个简单语法。<br>- 思考题<br>  - delete x 中，如果 x 根本不存在，会发生什么？<br>  - delete object.x 中，如果 x 是只读的，会发生什么？<br>- 自问自答<br>  - try catch 出现于 JavaScript 1.3 | 1999<br>  - strict mode 出现于 ES 5 | 2009<br>  - 规范中 引用 支持的操作<br>  - delete UnaryExpression 的处理过程<br>    - 计算 UnaryExpression 作为 ref<br>    - 如果 Type(ref) 的结果不是 引用，则直接返回 True<br>    - 如果 IsUnresolvableReference(ref)<br>      - 判断是否为严格模式 IsStrictReference(ref) ，如果是，抛出 SyntaxError 异常<br>      - 如果不是，返回 True<br>    - 判断是否为属性 IsPropertyReference(ref) ，如果是，则执行内部方法 Delete<br>    - 如果执行到这里，表示 ref 是 Environment Record 绑定中的引用，需要继续判断<br>      - 如果是严格模式，抛出 SyntaxError 异常<br>      - Let bindings be GetBase(ref)<br>      - Return the result of calling the DeleteBinding concrete method of bindings, providing GetReferencedName(ref) as the argument.<br>  - {{[[TODO]]}} 目前对 GetBase 的行为尚未完全理解<br>  - The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators.<br>  - A Reference is a resolved name binding.<br>  - A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.<br>  - typeof 的执行过程<br>- 参考链接<br>  - The Reference Specification Type<br>  - JavaScript Versions<br>","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519075,"discussion_content":"有关GetBase，可以参考我之前的一个视频【JS在引擎级别的执行过程】，在这里：\nhttps://www.bilibili.com/s/video/BV1Wy4y1b7PG\n\n其中对“引用（规范类型）”的结构有过讲述，那里面的base，就是这里GetBase()操作的对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619666051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250410,"user_name":"G","can_delete":false,"product_type":"c1","uid":2189373,"ip_address":"","ucode":"C267833DBBE254","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/3lp20weUpmEjiaLAS6umkKRGB7WicIPGWQ7sjRsxbw0EAiapnslID17FfmrMFppSDw7vn0A8bu1icBBmPXGGweGhjQ/132","comment_is_top":false,"comment_ctime":1601057496,"is_pvip":false,"replies":[{"id":"91706","content":"不是的。你最好先看看我给你的视频，理解一下什么是“引用”。<br>关于你所提及的解析为“var a”和“a = 5”这个说法，在早期我的文档（以及早期的书）里面的确是这样解释的，但这只是表面现象，并不是ECMAScript真正的处理方式。在ECMAScript里面“=5”是作为一个特殊的东西来处理的，是语句的语法组件——需要强调的是，这里的“=”号并不是赋值运算符，更确切地说，就不是运算符。<br><br>Ok~ 我之前在另一个回复中提到过=号的特殊性，这里抄了过来，无论如何，你再看看，或者有助于你理解它：<br>-----------------------<br>“=”是有二义性的。在表达式的概念集合中，它确实是运算符；而在语句的概念集合中（例如“var x = 1”），它只是语法符号。对于后者，也就是语句来说，“var x”是声明，其中“x”称为“（被绑定的）标识符”；而“= 1”是作为单独一个语法组件来解释的，称为“初始绑定（初始器）”——而并不是“赋值”。<br><br>关于后面这一点，可以参考：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#prod-VariableDeclaration<br>","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1601135679,"ip_address":"","comment_id":250410,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10190992088","product_id":100039701,"comment_content":"非常感谢老师的回答<br>关于第五点<br>var a = 5<br>应该实际上是被解析成这样的代码<br>var a<br>a = 5<br>这里有一个赋值操作，所以老师在回复里说，a是一个引用，是这样吗？而delete a 返回false的真正原因是这本身是es规范中约定好的","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506199,"discussion_content":"不是的。你最好先看看我给你的视频，理解一下什么是“引用”。\n关于你所提及的解析为“var a”和“a = 5”这个说法，在早期我的文档（以及早期的书）里面的确是这样解释的，但这只是表面现象，并不是ECMAScript真正的处理方式。在ECMAScript里面“=5”是作为一个特殊的东西来处理的，是语句的语法组件——需要强调的是，这里的“=”号并不是赋值运算符，更确切地说，就不是运算符。\n\nOk~ 我之前在另一个回复中提到过=号的特殊性，这里抄了过来，无论如何，你再看看，或者有助于你理解它：\n-----------------------\n“=”是有二义性的。在表达式的概念集合中，它确实是运算符；而在语句的概念集合中（例如“var x = 1”），它只是语法符号。对于后者，也就是语句来说，“var x”是声明，其中“x”称为“（被绑定的）标识符”；而“= 1”是作为单独一个语法组件来解释的，称为“初始绑定（初始器）”——而并不是“赋值”。\n\n关于后面这一点，可以参考：\nhttps://tc39.es/ecma262/#prod-VariableDeclaration\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601135679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169418,"user_name":"balance","can_delete":false,"product_type":"c1","uid":1007182,"ip_address":"","ucode":"324D909BBE69DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/4e/85502e98.jpg","comment_is_top":false,"comment_ctime":1578342192,"is_pvip":false,"replies":[{"id":"65754","content":"1和2都没有问题，3稍稍一点不同。<br><br>在3里面，如果是“object.x”这个语法，那么这个`x`将是语法解析阶段得到的一个标识符名（IdentifierName），所以它不会视为“表达式的值”。但是，在执行“object.x”这个东西时，它确实是以“某个值”的形式传给“点号”这个运算符的。你可以理解为，“object.x”是指：opPropertyAccessor(object, IdentifierName_to_NameString(x))<br><br>亦即是说，对于1和2来说，x是一个单值表达式，而在3中，x不是表达式。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1578381241,"ip_address":"","comment_id":169418,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10168276784","product_id":100039701,"comment_content":"<br>(1) delete x<br>(2) x=x<br>(3) object. x()<br><br>(1)中的x，(2)中等号左边的x，(3)中的x是同一种行态：表达式的result。老师，对吗？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480547,"discussion_content":"1和2都没有问题，3稍稍一点不同。\n\n在3里面，如果是“object.x”这个语法，那么这个`x`将是语法解析阶段得到的一个标识符名（IdentifierName），所以它不会视为“表达式的值”。但是，在执行“object.x”这个东西时，它确实是以“某个值”的形式传给“点号”这个运算符的。你可以理解为，“object.x”是指：opPropertyAccessor(object, IdentifierName_to_NameString(x))\n\n亦即是说，对于1和2来说，x是一个单值表达式，而在3中，x不是表达式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578381241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361489,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","nickname":"🇧🇪 Hazard🇦🇷","note":"","ucode":"E2C44FAFDFAA88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229525,"discussion_content":"我之前以为单值表达式是一些字面量表达式的意思。。。那 x 表达式的结果是一个单值，这个单值是啥意思？ 是表示这个表达式不需要再进行拆分，比如 obj.x 中这个表达式中有一个 “.” 运算符，其中的x又是一个表达式，所以这种就不是单值表达式的意思吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586661010,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156395,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1574866371,"is_pvip":false,"replies":[{"id":"60096","content":"是。writable不决定是否删除。属性表像一个数据库的表一样，可以增删查改，显然writable决定的是“改”，而不是“删”。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574908173,"ip_address":"","comment_id":156395,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164800963","product_id":100039701,"comment_content":"看了其他同学的答案和老师的回答，感觉挺疑惑的，属性能否被 delete 是由 configurable 决定的，跟是否只读没有关系吧？<br><br>const object1 = {};<br><br>Object.defineProperty(object1, &#39;p&#39;, {<br>  value: 42,<br>  writable: false,<br>  configurable: true,<br>});<br><br>delete object1.p<br><br>console.log(object1.p); &#47;&#47; undefined<br> ","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476095,"discussion_content":"是。writable不决定是否删除。属性表像一个数据库的表一样，可以增删查改，显然writable决定的是“改”，而不是“删”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574908173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156246,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1574842465,"is_pvip":false,"replies":[{"id":"60098","content":"`delete null`和`delete 0`在性质上没什么区别呀。所以返回true不是正常的么？","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574908259,"ip_address":"","comment_id":156246,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10164777057","product_id":100039701,"comment_content":"老师，undefined作为window的属性不可删除，然后delete undefined返回false我理解了；但是为什么delete null会返回true呢？null不是一个值吗？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476047,"discussion_content":"`delete null`和`delete 0`在性质上没什么区别呀。所以返回true不是正常的么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574908259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748640,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","nickname":"穿秋裤的男孩","note":"","ucode":"D0F48C66377893","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65276,"discussion_content":"懂了懂了，看来有时候还是分不清值和引用，惭愧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574992840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150241,"user_name":"杨尚坤","can_delete":false,"product_type":"c1","uid":1464887,"ip_address":"","ucode":"0B14209A41C139","user_header":"https://static001.geekbang.org/account/avatar/00/16/5a/37/7dca1edc.jpg","comment_is_top":false,"comment_ctime":1573483137,"is_pvip":false,"replies":[{"id":"57805","content":"多谢。我努力~努力~持续努力~<br><br>^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573492016,"ip_address":"","comment_id":150241,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10163417729","product_id":100039701,"comment_content":"写的很好","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474102,"discussion_content":"多谢。我努力~努力~持续努力~\n\n^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573492016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330043,"user_name":"Kids See Ghost","can_delete":false,"product_type":"c1","uid":1390088,"ip_address":"","ucode":"DA57BB8327BB01","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/08/c77d8a5a.jpg","comment_is_top":false,"comment_ctime":1641756400,"is_pvip":false,"replies":[{"id":"120255","content":"关于“引用（规范类型）”在出现和使用，在下面这个视频里面有讲（前12分钟）：<br>https:&#47;&#47;www.bilibili.com&#47;video&#47;BV1Wy4y1b7PG<br><br>“引用（规范类型）”是一个结构，用于保存名字或标识符（包括属性等），以便在执行过程中传递——但不能在函数界面上传入或传出。<br><br>在ECMAScript规范中，一个字面量的对象也是“值”，而一个数字的名字也是“引用（规范类型）”。这与他们的使用方式有关，而不是传统中按他们的存储或指针结构来理解的。<br>例如：<br>```<br>console.log({}); &#47;&#47; &lt;-的对象字面量是一个“值”<br>let x = {}; &#47;&#47; 或者 x = 5<br>console.log(x); &#47;&#47; &lt;- 这里的x是一个“引用（规范类型）”<br>```<br>在后面的console.log(x)中，x——作为一个“引用（规范类型）”——必须先求值，再传入函数log()。","user_name":"作者回复","user_name_real":"作者","uid":"1521669","ctime":1641792296,"ip_address":"","comment_id":330043,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5936723696","product_id":100039701,"comment_content":"请问老师：可以把文中的引用理解为变量的值的内存首地址，getValue()就是从该内存地址中读取相应的值吗？<br>假如我申明一个变量a, 其内存地址是0x1234<br>const a = 1<br>那我在js里面使用a的时候，getValue(a)就等于从0x1234开始读区内存大小为4*sizeof(int)的内容吗？<br>还是没太懂这里JS规范里的引用和我们常说的“引用” - 指向一个存储在内存中的实例，该实例对应一个内存地址和相应的实例大小、实例的数据类型等等 - 的区别在哪里。","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544969,"discussion_content":"关于“引用（规范类型）”在出现和使用，在下面这个视频里面有讲（前12分钟）：\nhttps://www.bilibili.com/video/BV1Wy4y1b7PG\n\n“引用（规范类型）”是一个结构，用于保存名字或标识符（包括属性等），以便在执行过程中传递——但不能在函数界面上传入或传出。\n\n在ECMAScript规范中，一个字面量的对象也是“值”，而一个数字的名字也是“引用（规范类型）”。这与他们的使用方式有关，而不是传统中按他们的存储或指针结构来理解的。\n例如：\n```\nconsole.log({}); // <-的对象字面量是一个“值”\nlet x = {}; // 或者 x = 5\nconsole.log(x); // <- 这里的x是一个“引用（规范类型）”\n```\n在后面的console.log(x)中，x——作为一个“引用（规范类型）”——必须先求值，再传入函数log()。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641792296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321963,"user_name":"明月","can_delete":false,"product_type":"c1","uid":1338736,"ip_address":"","ucode":"D6586156BF09CF","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","comment_is_top":false,"comment_ctime":1637118726,"is_pvip":false,"replies":[{"id":"116939","content":"你的两个猜测都是对的。只是var虽然是全局对象，但也确实有一些特殊的处理，例如它在（引擎内核的）全局环境中有一个称为varNames的表，在删除时还需要在这个表中确认一次。所以直接声明成“var x = ...”与使用eval(&amp;quot;var x = ...&amp;quot;)带来的效果会不一样。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1637130751,"ip_address":"","comment_id":321963,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5932086022","product_id":100039701,"comment_content":"在尝试例子时遇到一些问题，希望老师帮忙解答：<br>var num = 1; delete num; &#47;&#47;false <br>var obj = {a: 1}; delete obj; &#47;&#47;false delete obj.a; &#47;&#47;true<br>按照之前老师说的，Object.getOwnPropertyDescriptor(window, &#39;num&#39;);  &#47;&#47;{value: 1, writable: true, enumerable: true, configurable: false} 按照老师稳重所讲，我有两种猜测<br>1.num 被挂载到了全局对象，同时其是可写的。那么delete num 应该返回true<br>2.delete xx 这里的 xx 应该是 lhs的，那么他就是一个引用类型。delete 应该也会返回true吧？<br>","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530703,"discussion_content":"你的两个猜测都是对的。只是var虽然是全局对象，但也确实有一些特殊的处理，例如它在（引擎内核的）全局环境中有一个称为varNames的表，在删除时还需要在这个表中确认一次。所以直接声明成“var x = ...”与使用eval(&amp;quot;var x = ...&amp;quot;)带来的效果会不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637130751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":313985,"user_name":"波哥","can_delete":false,"product_type":"c1","uid":1998183,"ip_address":"","ucode":"373D587C2BD8AB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIoYNYqumlObe08Gjq5PoHKn1gnKhoajZ1sc9AQ3xdJuXhnnLQ9HwPxTFSDo8G7YdL2Pk1rkiaibbNg/132","comment_is_top":false,"comment_ctime":1632791475,"is_pvip":false,"replies":[{"id":"113770","content":"这个在之前的留言中有过回复的。希望对你理解起来有所帮助：<br>----<br>我一般是用Result来表达它是表达式执行结果的“未决状态”。就是执行出结果来了，但没确定是作为lrs还是rhs，所以这种情况下，它就是未决的。<br><br>当你确定了一个Result用作lrs，那么它就是引用；如果确定它用作rhs，那么它就是值（将由引擎隐式地调用`GetValue()`）。<br>----","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1632843577,"ip_address":"","comment_id":313985,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5927758771","product_id":100039701,"comment_content":"老师，为啥能删除表达式的结果，不能删除表达式的值，结果和值有啥区别。我理解的是表达式结果就是值或者undefined，结果和值类似等价的。","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527538,"discussion_content":"这个在之前的留言中有过回复的。希望对你理解起来有所帮助：\n----\n我一般是用Result来表达它是表达式执行结果的“未决状态”。就是执行出结果来了，但没确定是作为lrs还是rhs，所以这种情况下，它就是未决的。\n\n当你确定了一个Result用作lrs，那么它就是引用；如果确定它用作rhs，那么它就是值（将由引擎隐式地调用`GetValue()`）。\n----","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632843577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309112,"user_name":"明月","can_delete":false,"product_type":"c1","uid":1338736,"ip_address":"","ucode":"D6586156BF09CF","user_header":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","comment_is_top":false,"comment_ctime":1629946346,"is_pvip":false,"replies":[{"id":"111998","content":"是的。手性的说法是在赋值表达式中解释“x = x”这样的模式的。推而广之，变成了用来分别“引用&#47;值”的通用语。所以尽管`delete obj.x`中obj.x的结果（result）是在delete运算符的右边，但实际上还是称之为左手端的（或者理解为“that result as lhs”）。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1630074007,"ip_address":"","comment_id":309112,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5924913642","product_id":100039701,"comment_content":"老师好，我想提问一个关于“手性”的问题。如您在文章中所说，表达式的结果(Result)到底是引用（Reference）还是值（GetValue()）取决于它处在左手端还是右手端。而判断手性的方式是看起在赋值符号的左边还是右边。那么，形如 delete obj.x 这种语句中，以obj.x 的最终取值还看，是可以认为是其处在左手端的么","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525745,"discussion_content":"是的。手性的说法是在赋值表达式中解释“x = x”这样的模式的。推而广之，变成了用来分别“引用/值”的通用语。所以尽管`delete obj.x`中obj.x的结果（result）是在delete运算符的右边，但实际上还是称之为左手端的（或者理解为“that result as lhs”）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630074007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286376,"user_name":"羲和","can_delete":false,"product_type":"c1","uid":1903752,"ip_address":"","ucode":"2B420888B5EB70","user_header":"https://static001.geekbang.org/account/avatar/00/1d/0c/88/aaf7bde9.jpg","comment_is_top":false,"comment_ctime":1617272883,"is_pvip":false,"replies":[{"id":"104025","content":"因为从运算符优先级上来说，是先计算`delete x`。这里的删除一个常值整数的结果，都将是true。所以你的4个case都等同于`true + n`。<br><br>`+`运算符会将true转换为1。关于类型转换的问题，要到很后面才会讲，是属于动态语言方面的特性。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1617295181,"ip_address":"","comment_id":286376,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5912240179","product_id":100039701,"comment_content":"delete 1+1<br>2<br>delete 2+1<br>2<br>delete 2+2<br>3<br>delete 0+1<br>2<br><br><br>这是为什么？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517963,"discussion_content":"因为从运算符优先级上来说，是先计算`delete x`。这里的删除一个常值整数的结果，都将是true。所以你的4个case都等同于`true + n`。\n\n`+`运算符会将true转换为1。关于类型转换的问题，要到很后面才会讲，是属于动态语言方面的特性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617295181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285494,"user_name":"Imart","can_delete":false,"product_type":"c1","uid":1499790,"ip_address":"","ucode":"373C0803485335","user_header":"https://static001.geekbang.org/account/avatar/00/16/e2/8e/b4ccfa02.jpg","comment_is_top":false,"comment_ctime":1616843773,"is_pvip":true,"replies":[{"id":"103680","content":"函数参数是采用跟var变量类似的方法创建的，所以也一样是无法删除的。另外，由于函数有一个.length属性，指明它被显式声明的（有名字的）参数的个数，因此“假定”可以删除的话，那么这个属性也无法有效的处理，进而导致不可知的错误。<br><br>还有一个更重要的原因，在JavaScript中函数参数名字（和函数内的局部变量名一样）是“屏蔽”了对函数外的名字的访问的——亦即是局部变量优先于全局同名变量。但是如果局部变量名或参数名可以删除的话，那么用户代码就无法明确自己是在访问局部的还是全局的数据了，这也是不可行的。<br><br>总之，从“代码需要尽可能确定的语义&#47;语法”的角度上来说，删除参数名或变量名都是不可取的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1617002168,"ip_address":"","comment_id":285494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5911811069","product_id":100039701,"comment_content":"function func(param) {<br>  console.log(delete param); &#47;&#47; false<br>  console.log(param) &#47;&#47; 1<br>}<br>func(1)<br><br>老师您好，为什么不能删除一个函数的参数啊？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517691,"discussion_content":"函数参数是采用跟var变量类似的方法创建的，所以也一样是无法删除的。另外，由于函数有一个.length属性，指明它被显式声明的（有名字的）参数的个数，因此“假定”可以删除的话，那么这个属性也无法有效的处理，进而导致不可知的错误。\n\n还有一个更重要的原因，在JavaScript中函数参数名字（和函数内的局部变量名一样）是“屏蔽”了对函数外的名字的访问的——亦即是局部变量优先于全局同名变量。但是如果局部变量名或参数名可以删除的话，那么用户代码就无法明确自己是在访问局部的还是全局的数据了，这也是不可行的。\n\n总之，从“代码需要尽可能确定的语义/语法”的角度上来说，删除参数名或变量名都是不可取的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617002168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259425,"user_name":"油菜","can_delete":false,"product_type":"c1","uid":2263588,"ip_address":"","ucode":"DB3334BC1720F1","user_header":"","comment_is_top":false,"comment_ctime":1604722566,"is_pvip":false,"replies":[{"id":"94396","content":"文章中的叙述确有令人混淆不清的部分，尽量参考我在评论回复中的解释来看，尤其是对“海绵薇薇”的解释。另外，非常非常重要的是，建议对照“加餐：让JavaScript运行起来”中的那张图片来读，它解释了“最核心的两种执行过程（它们都被称为 evaluating）”，也解释了什么是result，以及哪些情况下它们是value。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1604852317,"ip_address":"","comment_id":259425,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5899689862","product_id":100039701,"comment_content":"通读了5、6遍，文章中有几个混淆点，我先列举出来：<br>1 表达式的值，在 ECMAScript 的规范中，称为“引用”。（本人的理解，“表达式，在 ECMAScript 的规范中，称为“引用””）；<br>2 任何表达式计算的结果（Result）要么是一个值，要么是一个引用。(本人理解，delete 0 中，0是表达式，该计算结果(result)，是一个值)；<br>3 “delete x”归根到底，是在删除一个表达式的、引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）。（本人理解，文中“表达的值”有两种写法，一个是result,一个是value，非常容易混淆。表达式的值（Value）= getValue(表达式的值，即引用)。本人总结，delete x 是删除表达式计算的结果（result））；<br>4 delete 0中的这个0是一个表达式求值；delete x中的x是一个引用；（本人理解，0是一个表达式，计算的结果是值，等于0；x是一个表达式，计算的结果是引用）<br>5 delete 0 的本质是删除一个表达式的值（Result）。delete x 与上述的区别只在于 Result 是一个引用（Reference） （本人理解，表达式的值（Result）= 表达式计算结果，如果1，2，3，4的理解正确，就可以得出5的结论）。<br>目前本人的理解，表达式就是引用，表达式的值（result）就是表达式计算的结果，计算的结果可能是value，也可能是一个引用。<br><br>如果本人理解错了，那说明下面几个概念理解错了。<br>1 表达式的值，在 ECMAScript 的规范中，称为“引用”，这个“表达式的值”指value还是result?<br>2 ECMAScript 约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用。如果result是“表达式的值”，那就说明“表达式的值”，在 ECMAScript 的规范中，称为“引用”或者“值”。<br>3 文中表达式的值（value）和表达式的值（result）有什么区别？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508935,"discussion_content":"文章中的叙述确有令人混淆不清的部分，尽量参考我在评论回复中的解释来看，尤其是对“海绵薇薇”的解释。另外，非常非常重要的是，建议对照“加餐：让JavaScript运行起来”中的那张图片来读，它解释了“最核心的两种执行过程（它们都被称为 evaluating）”，也解释了什么是result，以及哪些情况下它们是value。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604852317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249494,"user_name":"G","can_delete":false,"product_type":"c1","uid":2189373,"ip_address":"","ucode":"C267833DBBE254","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/3lp20weUpmEjiaLAS6umkKRGB7WicIPGWQ7sjRsxbw0EAiapnslID17FfmrMFppSDw7vn0A8bu1icBBmPXGGweGhjQ/132","comment_is_top":false,"comment_ctime":1600672928,"is_pvip":false,"replies":[{"id":"91675","content":"1. 不是的。类似于if&#47;else之类还是逻辑语句的，不能说除了声明语句就是表达式。<br>2. 是的。本质上就是删除属性（成员）。<br>3. 这里说到的“引用”与通常说的不同，你到后文中会再次看到它们的更确切的解释的。不过你对左值和右值的理解是对的。<br>4. 你的结论是对的：“delete并不会对值（value）类型做任何操作”。<br>5. a是引用，b也是。引用在本质上就是“名字”，只要是一个名字访问，那么它作为左值的时候就是引用。关于这一点，你可以再看一份视频（里面讲到了4种名字引用，PPT很容易找到下载的）：<br>https:&#47;&#47;v.youku.com&#47;v_show&#47;id_XNDUwNTc3MjUzMg==.html<br>","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1601055687,"ip_address":"","comment_id":249494,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5895640224","product_id":100039701,"comment_content":"老师好，我从这篇文章总结了一些收获，如果有错误的地方，请老师指正<br>1.  js中，除了声明语句，其他的都可以视为表达式<br>2.delete本质是删除 object.x 的求值结果<br>3.表达式的求值结果，可以是一个引用，也可以是一个值（value），而究竟是引用还是值，要取决于这个求值结果是一个左值 还是 非左值。这里我有一个比较疑惑的地方，因为delete给我的感觉，不像是console.log（）这样，是明确的取右值的操作。文中所举的例子：delete { }，{ }是一个单值表达式，这是一个非引用类型。是如何判断一个值是不是非引用类型的呢？我目前的理解是这样，object.x 的求值结果是一个引用，因为它可以作为一个左值使用，而{ }的求值结果无法当做一个左值使用，所以是一个非引用类型。<br>4. 文中有一句话：所以，“delete x”归根到底，是在删除一个表达式的、引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）。这整句话我没有理解清楚，前半句 ` “delete x”归根到底，是在删除一个表达式的、引用类型的结果（Result）`，这个“引用类型的结果”依然极有可能是值类型也有可能是引用类型吗？ 后半句 `而不是在删除 x 表达式，或者这个删除表达式的值（Value） `,这句话是指 delete 并不会值（value）类型做任何操作吗？<br>5.var a = 5<br>   delete  a       &#47;&#47;false<br>   window.b = 6<br>   delete  b     &#47;&#47;true<br>   这应该怎么理解呢<br><br>以上就是我的部分问题，希望老师指正<br>","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505938,"discussion_content":"1. 不是的。类似于if/else之类还是逻辑语句的，不能说除了声明语句就是表达式。\n2. 是的。本质上就是删除属性（成员）。\n3. 这里说到的“引用”与通常说的不同，你到后文中会再次看到它们的更确切的解释的。不过你对左值和右值的理解是对的。\n4. 你的结论是对的：“delete并不会对值（value）类型做任何操作”。\n5. a是引用，b也是。引用在本质上就是“名字”，只要是一个名字访问，那么它作为左值的时候就是引用。关于这一点，你可以再看一份视频（里面讲到了4种名字引用，PPT很容易找到下载的）：\nhttps://v.youku.com/v_show/id_XNDUwNTc3MjUzMg==.html\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601055687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242551,"user_name":"青山入我怀","can_delete":false,"product_type":"c1","uid":2129828,"ip_address":"","ucode":"0A712556F4D7A3","user_header":"https://static001.geekbang.org/account/avatar/00/20/7f/a4/34955365.jpg","comment_is_top":false,"comment_ctime":1597758323,"is_pvip":false,"replies":[{"id":"89508","content":"1. 指的是规范类型中的“引用（规范类型）”。<br>2. 当它作为左操作数，以及作为函数参数或结果传入&#47;传出时，他会被隐式的调用getValue。—这些情况下它将被作为值（而非引用规范类型）来参与后续计算。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1597808847,"ip_address":"","comment_id":242551,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5892725619","product_id":100039701,"comment_content":"老师好，请问，1.表达式的计算结果Result可以是引用也可以值，这里的引用即可以表示原始的引用和reference吗，还是说只能是reference. <br>2.表达式的计算必须要执行getValue吗，什么时候会发生表达式的计算呢？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504036,"discussion_content":"1. 指的是规范类型中的“引用（规范类型）”。\n2. 当它作为左操作数，以及作为函数参数或结果传入/传出时，他会被隐式的调用getValue。—这些情况下它将被作为值（而非引用规范类型）来参与后续计算。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597808847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2263588,"avatar":"","nickname":"油菜","note":"","ucode":"DB3334BC1720F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322287,"discussion_content":"&#34; 当它作为左操作数&#34;, 是“右操作数”吧？ x=getValue(x)，是右操作数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604719410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242537,"user_name":"青山入我怀","can_delete":false,"product_type":"c1","uid":2129828,"ip_address":"","ucode":"0A712556F4D7A3","user_header":"https://static001.geekbang.org/account/avatar/00/20/7f/a4/34955365.jpg","comment_is_top":false,"comment_ctime":1597753436,"is_pvip":false,"replies":[{"id":"89507","content":"<br>对的。<br>稍强调一下，是“表示左侧表达式的Result”","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1597808537,"ip_address":"","comment_id":242537,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5892720732","product_id":100039701,"comment_content":"老师，请问：<br>所有赋值操作的含义，是将右边的“值”，赋给左边用于包含该值的“引用”。<br>这里的“引用”是引用规范类型（表示左侧表达式的值）的粗略说法，而值指的是传统意义上的值吗？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504033,"discussion_content":"\n对的。\n稍强调一下，是“表示左侧表达式的Result”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597808537,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223612,"user_name":"bright","can_delete":false,"product_type":"c1","uid":1797351,"ip_address":"","ucode":"397D66D4CDDA1B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/6c/e7/c8645b9c.jpg","comment_is_top":false,"comment_ctime":1591144786,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5886112082","product_id":100039701,"comment_content":"三刷留个言，文章很赞，痛苦并快乐着","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278107,"discussion_content":"快乐+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591151345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214825,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1588825702,"is_pvip":false,"replies":[{"id":"79737","content":"如果你把对象理解为“所有属性的表”，那么以关系型sql数据库的“表（table）”作为参照来理解：<br><br>&gt; propertyKey，就是属性（作为记录）的主键；而<br><br>&gt; delete table.key，就是从table中删除掉以key为键的记录。<br><br>所以不是删除关系，而是删除掉该key指向的属性项。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1588997624,"ip_address":"","comment_id":214825,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5883792998","product_id":100039701,"comment_content":"delete 删除的对象和对象值之间的关联关系？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494212,"discussion_content":"如果你把对象理解为“所有属性的表”，那么以关系型sql数据库的“表（table）”作为参照来理解：\n\n&amp;gt; propertyKey，就是属性（作为记录）的主键；而\n\n&amp;gt; delete table.key，就是从table中删除掉以key为键的记录。\n\n所以不是删除关系，而是删除掉该key指向的属性项。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588997624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207727,"user_name":"思不歌","can_delete":false,"product_type":"c1","uid":1919738,"ip_address":"","ucode":"FD8F500D5FC8DC","user_header":"https://static001.geekbang.org/account/avatar/00/1d/4a/fa/7937b03c.jpg","comment_is_top":false,"comment_ctime":1587168289,"is_pvip":false,"replies":[{"id":"77626","content":"&gt;&gt; 观念1：对象是带有一系列相关性质的数据。除此之外，它不带有任何必须附加的概念。明确这一点，有利于我们看到对象系统的本质与构建 过程。<br><br>&gt;&gt; 观念2：（1）程序是由对象组成的;（2）对象之间互相发送消息，协作完成任务。其中第一条，是对象系统的基本特性，是谓系统成员; 第二条，是对象系统如何演进为系统的特性，是谓系统通信。一个系统的约束， 既包括其成员(以及成员的组织规则)，也包括成员间的通信。<br><br>这里的两个观念，一是言“何为对象”，它在《程序原本》的第“10.2 继承和多态都是多余的概念”节中；二是言“何为对象系统”，也在该书所收“附录二：继承与混合，略谈系统的构建方式”中。<br><br>至于“面向（或不面向）”，其实并不要紧。<br><br>《程序原本》在这里：<br>https:&#47;&#47;github.com&#47;aimingoo&#47;my-ebooks","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1587234786,"ip_address":"","comment_id":207727,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5882135585","product_id":100039701,"comment_content":"老师，语言具有哪些特征，才能称为面向对象，网上的回答，感觉回答不到本质。","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492223,"discussion_content":"&amp;gt;&amp;gt; 观念1：对象是带有一系列相关性质的数据。除此之外，它不带有任何必须附加的概念。明确这一点，有利于我们看到对象系统的本质与构建 过程。\n\n&amp;gt;&amp;gt; 观念2：（1）程序是由对象组成的;（2）对象之间互相发送消息，协作完成任务。其中第一条，是对象系统的基本特性，是谓系统成员; 第二条，是对象系统如何演进为系统的特性，是谓系统通信。一个系统的约束， 既包括其成员(以及成员的组织规则)，也包括成员间的通信。\n\n这里的两个观念，一是言“何为对象”，它在《程序原本》的第“10.2 继承和多态都是多余的概念”节中；二是言“何为对象系统”，也在该书所收“附录二：继承与混合，略谈系统的构建方式”中。\n\n至于“面向（或不面向）”，其实并不要紧。\n\n《程序原本》在这里：\nhttps://github.com/aimingoo/my-ebooks","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587234786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169421,"user_name":"balance","can_delete":false,"product_type":"c1","uid":1007182,"ip_address":"","ucode":"324D909BBE69DE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/4e/85502e98.jpg","comment_is_top":false,"comment_ctime":1578343646,"is_pvip":false,"replies":[{"id":"65745","content":"👍<br><br>这是一个非常简洁和正确的解释。^^.<br><br>(1)在ECMAScript中使用“引用（规范类型）”来表示，(2)是通过对一个“引用（规范类型）”的取值`GetValue(ref)`来得到的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1578380035,"ip_address":"","comment_id":169421,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873310942","product_id":100039701,"comment_content":"对于语言系统来说，在碰到x这个标记时，它要解决这两个层面的问题，（1）x是谁？（2）x是多少？<br><br>本节内容要说明的是（1）问题","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480549,"discussion_content":"👍\n\n这是一个非常简洁和正确的解释。^^.\n\n(1)在ECMAScript中使用“引用（规范类型）”来表示，(2)是通过对一个“引用（规范类型）”的取值`GetValue(ref)`来得到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578380035,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161172,"user_name":"隔夜果酱","can_delete":false,"product_type":"c1","uid":1319638,"ip_address":"","ucode":"5AFEB62E832BCB","user_header":"https://static001.geekbang.org/account/avatar/00/14/22/d6/9378f4d5.jpg","comment_is_top":false,"comment_ctime":1576137084,"is_pvip":false,"replies":[{"id":"61514","content":"JavaScript的语法解析中，0是作为一个标识符来理解的，而不是作为一个字面量值。因为如果要作为字面量值，那么就得对每一个解析出来的标识符做类型检查（类型检查不单单是指整型、字符串这种，还包括常量或是变量这样的可写性）。而JavaScript的语言设计和引擎设计又决定了它是不支持静态类型检查的。<br><br>所以delete 0是一个动态执行结果，而不是静态语法检查结果。还有所谓的严格模式，很多人的理解是错误的，事实上严格模式是一个执行环境模式，而不是一个语法（是否严格的）模式。所以事实上它对静态语法检查的影响极小极小——当然也不能说没有。^^.<br><br>&quot;同样的在严格模式下删除对象不存在的属性,为什么也不报错呢或返回false呢?&quot;<br>---<br>这个问题倒是好解释，因为“对象不存在的属性”本质上是一个无效的属性引用，删除无效的属性引用不必触发异常，而写这个属性的时候，就需要根据对象的状态（冻结之类的）来动态决定了。<br><br>当然所有这些方面的问题，本质上还只是ECMAScript中的一些语言设计喜好问题， 以及——非常关键的——兼容旧代码的问题，不能让绝大多数旧代码在新规范中出运行出错，这是硬性要求。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576205600,"ip_address":"","comment_id":161172,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5871104380","product_id":100039701,"comment_content":"老师:我有个疑问,<br>既然在严格模式下删除变量会直接报语法错误.<br>那为什么不一并将delete 0,这种写法一并化作语法错误呢?<br>这和删除变量一样可以直接在语法检测阶段就发现呀,<br>严格模式下还有什么历史包袱么?是我理解有问题?还是说因为别的原因?<br>同样的在严格模式下删除对象不存在的属性,为什么也不报错呢或返回false呢?<br>这也是可以明确发现的错误呀,为什么严格模式没有处理?","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477626,"discussion_content":"JavaScript的语法解析中，0是作为一个标识符来理解的，而不是作为一个字面量值。因为如果要作为字面量值，那么就得对每一个解析出来的标识符做类型检查（类型检查不单单是指整型、字符串这种，还包括常量或是变量这样的可写性）。而JavaScript的语言设计和引擎设计又决定了它是不支持静态类型检查的。\n\n所以delete 0是一个动态执行结果，而不是静态语法检查结果。还有所谓的严格模式，很多人的理解是错误的，事实上严格模式是一个执行环境模式，而不是一个语法（是否严格的）模式。所以事实上它对静态语法检查的影响极小极小——当然也不能说没有。^^.\n\n&amp;quot;同样的在严格模式下删除对象不存在的属性,为什么也不报错呢或返回false呢?&amp;quot;\n---\n这个问题倒是好解释，因为“对象不存在的属性”本质上是一个无效的属性引用，删除无效的属性引用不必触发异常，而写这个属性的时候，就需要根据对象的状态（冻结之类的）来动态决定了。\n\n当然所有这些方面的问题，本质上还只是ECMAScript中的一些语言设计喜好问题， 以及——非常关键的——兼容旧代码的问题，不能让绝大多数旧代码在新规范中出运行出错，这是硬性要求。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576205600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154469,"user_name":"青史成灰","can_delete":false,"product_type":"c1","uid":1514406,"ip_address":"","ucode":"C28AB62034B833","user_header":"https://static001.geekbang.org/account/avatar/00/17/1b/a6/6373416f.jpg","comment_is_top":false,"comment_ctime":1574436721,"is_pvip":false,"replies":[{"id":"59533","content":"Early Errors是在纯粹的语法分析期发生的错误，这个不会带来任何代码执行效果。例如你写一个标识符，用非法的字符开头了，那么它就会是一个Early Errors，因为这连语法都通不过。<br><br>strict reference是在“引用（规范类型）”内部的一个标记，是个布尔值。表明这个“引用”是不是在严格模式下得到的。例如一个`x`，它声明的环境是严格模式的，那么这个strict reference值就会是true。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574660356,"ip_address":"","comment_id":154469,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869404017","product_id":100039701,"comment_content":"看了下规范文档，对于规范中的```Static Semantics: Early Errors```中的解释不是很明白，以及```Runtime Semantics: Evaluation```中的`strict reference`不是很理解，希望老师能简单的点拨下^^","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475481,"discussion_content":"Early Errors是在纯粹的语法分析期发生的错误，这个不会带来任何代码执行效果。例如你写一个标识符，用非法的字符开头了，那么它就会是一个Early Errors，因为这连语法都通不过。\n\nstrict reference是在“引用（规范类型）”内部的一个标记，是个布尔值。表明这个“引用”是不是在严格模式下得到的。例如一个`x`，它声明的环境是严格模式的，那么这个strict reference值就会是true。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574660356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152708,"user_name":"萃萃🇨🇳","can_delete":false,"product_type":"c1","uid":1164958,"ip_address":"","ucode":"D3A0967F643EBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/c6/9e/8dfd538e.jpg","comment_is_top":false,"comment_ctime":1574067747,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5869035043","product_id":100039701,"comment_content":"delete 的真正语法应该是 delete obj.x，因为全局对象的成员可以用全局变量的形式来存取，所以它才有了 delete x，但 obj.x 既不是引用类型，也不是值类型，与 typeof(x) 识别的所有类型都无关。因为，它是一个表达式。delete 这个操作的正式语法设计并不是`删除某个东西`，而是`删除一个表达式的结果`。因此 delete 0 其实是将 0 视为一个表达式（单值表达式），并尝试删除它的求值结果。<br><br>表达式的值，在 ECMAScript 的规范中，称为“引用”。<br><br>任何表达式计算的结果（Result）要么是一个值，要么是一个引用。对象，其实也是值。<br>delete {} 过程同 delete 0，删除的是 单值表达式的执行结果，返回 true。什么也没发生<br><br>所以，“delete x”归根到底，是在删除一个表达式的、引用类型的结果（Result），而不是在删除 x 表达式，或者这个删除表达式的值（Value）。","like_count":1,"discussions":[{"author":{"id":1361489,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","nickname":"🇧🇪 Hazard🇦🇷","note":"","ucode":"E2C44FAFDFAA88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229515,"discussion_content":"你这里的“表达式的值”是啥意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586659889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152431,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1574000180,"is_pvip":false,"replies":[{"id":"58617","content":"问题1：<br>====<br>从对“var b = {}”的分析来看，你仍然是混淆了JavaScript的引用（后者，亦即是“{}”对象），与ECMAScript规范类型中的“引用”。表达式的结果（Result）是一个“未确定引用&#47;值”的东西，如果它用作lhs，就是引用(ref)；如果它用作rhs，那么js会使用GetValue(ref）来得到它的值。——所以关于这个lhs&#47;rhs的使用，也正好解释了你的“问题2”的部分疑问。<br><br>但是“var a = ...”这个语法并不是表达式，这个是声明语句。声明语句在处理上主要是第2讲在讨论，并且在第2讲中也讨论了“声明语句”与“表达式”的不同，例如“var a = ...”的语义，是将“...”作为初始值绑定给a；而“x = x”的语义，是“x = GetValue(x)”，是将值赋给引用。所以，两个东西不要混为一谈，它们只是形似而已。——并且，在第3讲里，把“var a = b = ...”和“a = b = ...”两个并列起来讨论了，解释了第2讲中的“var ...”并没有实际带来“连等”的效果，这个就算是“后话”了。<br><br>问题2：<br>====<br>我详细地说明一下，一个赋值是如何完成的。<br><br>在这个问题上，你最好能看一下ECMAScript中“引用（规范类型）”的定义，在这里：https:&#47;&#47;tc39.es&#47;ecma262&#47;#sec-reference-specification-type<br><br>这个规范的这一部分内容，解释了所谓引用，实际上是一个拥有“base和referencedName”等字段的记录。而对于我们这里讨论的“变量x”来说，base就是它的环境上下文，referencedName就是&#39;x&#39;这个名字——注意这个记录（或称之为C语言中的结构）中根本没有“值是多少”这样的东西。<br><br>所以，对于“赋值（x = x）”这个行为来说，如果是一个引用(ref)，那么它作为引用就可以理解为一个存储的位置，即“base[referencedName]”——注意这只是说明“该名字x在base环境中的位置”；作为右侧的时候，就是GetValue(ref)，这样GetValue()操作就是去取ref指向的值，因为ref作为结构体，本身并没有包含它指向的值。<br><br>问题3：<br>====<br>0是表达式。<br><br>在JavaScript中这称为单值表达式。脚本中的任何文本，要么它是静态的声明，因此会被语法分析过程处理成标识符或者环境中的声明；要么它是一个表达式或语句，总是要被“求值”之后才能使用。“0”作为表达式的求值，仍然是0。<br><br>——之所以`delete 0`符合`delete`语句的语法“delete UnaryExpression”，正因为“0”是`UnaryExpression`。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574045260,"ip_address":"","comment_id":152431,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5868967476","product_id":100039701,"comment_content":"我这是进五退四还是直接退四还望老师指点了，拜谢<br><br>问题1：<br><br>表达式会返回一个“引用”意思是：<br><br>var a = 1;<br><br>console.log(a);<br><br>表达式a返回的是一个“引用”，这个“引用”指向的是值1<br><br>var b = {};<br><br>console.log(b);<br><br>表达式b返回的是一个“引用”，这个“引用”指向另一个引用（指向{}的引用）。<br><br>问题2：<br><br>除了delete可以操作“引用”，上面提到的 = 我理解也可以。<br><br>x = x<br><br>左边是“引用”，那么赋值是咋完成的？是通过左值的“引用”找到内存地址然后直接替换的吗？<br><br>问题3：<br><br>0 是表达式吗？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474814,"discussion_content":"问题1：\n====\n从对“var b = {}”的分析来看，你仍然是混淆了JavaScript的引用（后者，亦即是“{}”对象），与ECMAScript规范类型中的“引用”。表达式的结果（Result）是一个“未确定引用/值”的东西，如果它用作lhs，就是引用(ref)；如果它用作rhs，那么js会使用GetValue(ref）来得到它的值。——所以关于这个lhs/rhs的使用，也正好解释了你的“问题2”的部分疑问。\n\n但是“var a = ...”这个语法并不是表达式，这个是声明语句。声明语句在处理上主要是第2讲在讨论，并且在第2讲中也讨论了“声明语句”与“表达式”的不同，例如“var a = ...”的语义，是将“...”作为初始值绑定给a；而“x = x”的语义，是“x = GetValue(x)”，是将值赋给引用。所以，两个东西不要混为一谈，它们只是形似而已。——并且，在第3讲里，把“var a = b = ...”和“a = b = ...”两个并列起来讨论了，解释了第2讲中的“var ...”并没有实际带来“连等”的效果，这个就算是“后话”了。\n\n问题2：\n====\n我详细地说明一下，一个赋值是如何完成的。\n\n在这个问题上，你最好能看一下ECMAScript中“引用（规范类型）”的定义，在这里：https://tc39.es/ecma262/#sec-reference-specification-type\n\n这个规范的这一部分内容，解释了所谓引用，实际上是一个拥有“base和referencedName”等字段的记录。而对于我们这里讨论的“变量x”来说，base就是它的环境上下文，referencedName就是&amp;#39;x&amp;#39;这个名字——注意这个记录（或称之为C语言中的结构）中根本没有“值是多少”这样的东西。\n\n所以，对于“赋值（x = x）”这个行为来说，如果是一个引用(ref)，那么它作为引用就可以理解为一个存储的位置，即“base[referencedName]”——注意这只是说明“该名字x在base环境中的位置”；作为右侧的时候，就是GetValue(ref)，这样GetValue()操作就是去取ref指向的值，因为ref作为结构体，本身并没有包含它指向的值。\n\n问题3：\n====\n0是表达式。\n\n在JavaScript中这称为单值表达式。脚本中的任何文本，要么它是静态的声明，因此会被语法分析过程处理成标识符或者环境中的声明；要么它是一个表达式或语句，总是要被“求值”之后才能使用。“0”作为表达式的求值，仍然是0。\n\n——之所以`delete 0`符合`delete`语句的语法“delete UnaryExpression”，正因为“0”是`UnaryExpression`。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574045260,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151900,"user_name":"qqq","can_delete":false,"product_type":"c1","uid":1006786,"ip_address":"","ucode":"91B0ACF8CBE7BD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c2/8ffd2ad0.jpg","comment_is_top":false,"comment_ctime":1573809420,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5868776716","product_id":100039701,"comment_content":"第一个问题：x 的结果是 1 个 ReferenceError instances<br>第二个问题：obj.x 的结果是 1 个 TypeError instances","like_count":1},{"had_liked":false,"id":150464,"user_name":"天方夜","can_delete":false,"product_type":"c1","uid":1034749,"ip_address":"","ucode":"5D17D55B0CE10C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c9/fd/5ac43929.jpg","comment_is_top":false,"comment_ctime":1573541112,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868508408","product_id":100039701,"comment_content":"1. x 不存在，表达式运算结果也是一个表示不存在的值，然后 delete 运算发现它的操作数是“值 &#47; 非引用类型”，就直接返回了 true。<br><br>2. delete object.x 中，如果 x 是只读的，即 writable: false 也可以删除。只有 configurable: false 才不能删除。","like_count":1},{"had_liked":false,"id":150429,"user_name":"Geeker","can_delete":false,"product_type":"c1","uid":1032345,"ip_address":"","ucode":"9937127DE96D78","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/99/259a412f.jpg","comment_is_top":false,"comment_ctime":1573533436,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5868500732","product_id":100039701,"comment_content":"学到了以下几点：<br>1. JavaScript 中的值与引用；<br>2. 左值与右值；<br>3. 属性操作符返回的是对象属性的引用；<br>4. delete 是删除表达式、引用类型的结果。<br>目前看了两遍，只能体会这么多，另外感觉老师在带着读规范，nice。","like_count":1},{"had_liked":false,"id":150381,"user_name":"Charles","can_delete":false,"product_type":"c1","uid":1027892,"ip_address":"","ucode":"F0605C817C36D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/af/34/c7081824.jpg","comment_is_top":false,"comment_ctime":1573524859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868492155","product_id":100039701,"comment_content":"太喜欢听周老师这种方式解释问题👏","like_count":1},{"had_liked":false,"id":150354,"user_name":"Valar Morghulis","can_delete":false,"product_type":"c1","uid":1567422,"ip_address":"","ucode":"346880FDB41ED8","user_header":"https://static001.geekbang.org/account/avatar/00/17/ea/be/68706e54.jpg","comment_is_top":false,"comment_ctime":1573522410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868489706","product_id":100039701,"comment_content":"执行结果随便找个环境一执行就知道。<br>重要的是“为什么”，期待后面的课程","like_count":1},{"had_liked":false,"id":150237,"user_name":"妮露杜","can_delete":false,"product_type":"c1","uid":1260371,"ip_address":"","ucode":"D4FD03DCC6FC13","user_header":"https://static001.geekbang.org/account/avatar/00/13/3b/53/f4e15994.jpg","comment_is_top":false,"comment_ctime":1573482493,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868449789","product_id":100039701,"comment_content":"very good。喜欢老师的这种程度的深度。","like_count":1},{"had_liked":false,"id":150170,"user_name":"锅巴GG𐂅ં","can_delete":false,"product_type":"c1","uid":1002816,"ip_address":"","ucode":"9A6181D37C633B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/40/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1573472363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5868439659","product_id":100039701,"comment_content":"追更！","like_count":1},{"had_liked":false,"id":358579,"user_name":"Guan-Ym","can_delete":false,"product_type":"c1","uid":1590225,"ip_address":"江苏","ucode":"1C015C36876A5A","user_header":"https://static001.geekbang.org/account/avatar/00/18/43/d1/b3a8165b.jpg","comment_is_top":false,"comment_ctime":1664440339,"is_pvip":true,"replies":[{"id":"130727","content":"完全正确👍🏻","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1665551722,"ip_address":"江苏","comment_id":358579,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1664440339","product_id":100039701,"comment_content":"老师，可以帮忙看看我的总结有没有问题吗~ <br><br><br>- 任何表达式的结果要不是一个 值（就是以前传统的基本数据类型和引用类型），要不就是一个引用；<br> - 如果表达式的结果是一个 对象，那么他也是一个值（或者说非引用类型）<br> - delete 发现他的操作数是 值&#47;非引用类型，就直接返回了 true<br> - 在 js 内部中，所谓的引用是可以转化成值的，GetValue() 是从一个引用中取出值来的行为。<br> - x = x 的语义是把值x赋给引用x<br> - delete 删除的是一个表达式的、引用类型的结果（如果这个结果是值的话，直接返回 true；如果是引用的话，判断这个引用是否正确，如果无法解析的话，也是返回 true），而不是删除这个表达式或者表达式的值<br> - &quot;.&quot;运算符返回的是一个&quot;x&quot;的引用，注意不是返回一个值。<br> - obj.x()  从根本上说如果 obk.x 返回的是一个值，就不能携带 obj 这个对象，函数中也不能通过 this 来访问 obj.<br> - delete 只能删除一种引用，就是对象的成员<br> - 对于`x = x`来说，左侧和右侧都是表达式，左侧的结果是“lhs&#47;引用（reference）”，而右侧的结果是“rhs&#47;值（value）”<br> - 在 undefined 是个全局变量，在 es5 还是 es6 之前，undefined = &#39;sth&#39;，是可以成功赋值的，在之后，只有块级作用域能成功赋值了。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590138,"discussion_content":"完全正确👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665551722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346892,"user_name":"戴飞","can_delete":false,"product_type":"c1","uid":2702083,"ip_address":"","ucode":"6FC3463BD5BD22","user_header":"https://static001.geekbang.org/account/avatar/00/29/3b/03/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1653525621,"is_pvip":false,"replies":[{"id":"126533","content":"这里写得是有点不清晰的~ 原本是想避免太早进入一些概念细节。<br><br>关于这个，在第11讲后的加餐里面，有一张图来说明表达式执行与语句执行的差异，其中专门指明了这个Result和“引用（规范类型）”，以及一般值类型（Value）之间的关系。<br><br>你可以参考着看看。在这里：<br>https:&#47;&#47;static001.geekbang.org&#47;resource&#47;image&#47;b2&#47;11&#47;b281ed38f4894823bdb0daf771d27311.jpg<br><br>实在理解不了也没关系，读了后面的一些知识点，再回来看这里，就清晰了。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1653639819,"ip_address":"","comment_id":346892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1653525621","product_id":100039701,"comment_content":"周老师，您好，想请教下个问题，前文中说表达式的值，在 ECMAScript 的规范中，称为“引用，后面又提出检测过程说明，ECMAScript 约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用，这里有点矛盾有点理解不了","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573786,"discussion_content":"这里写得是有点不清晰的~ 原本是想避免太早进入一些概念细节。\n\n关于这个，在第11讲后的加餐里面，有一张图来说明表达式执行与语句执行的差异，其中专门指明了这个Result和“引用（规范类型）”，以及一般值类型（Value）之间的关系。\n\n你可以参考着看看。在这里：\nhttps://static001.geekbang.org/resource/image/b2/11/b281ed38f4894823bdb0daf771d27311.jpg\n\n实在理解不了也没关系，读了后面的一些知识点，再回来看这里，就清晰了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653639819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346275,"user_name":"阿超.","can_delete":false,"product_type":"c1","uid":1576230,"ip_address":"","ucode":"2B96DE690C98DB","user_header":"https://static001.geekbang.org/account/avatar/00/18/0d/26/73411dd3.jpg","comment_is_top":false,"comment_ctime":1652968409,"is_pvip":true,"replies":[{"id":"126375","content":"`delete a.x`中，“a.x的值”并不是“12这个变量”，而是“一个包括12这个值的引用”。<br><br>一个表达式的结果值（Result）可以是引用（Reference），也可以是值（Value）。这一章本来 就是讲这个核心话题的，不过你仍然还混淆着。再提示一下，`delete a.x`这行表达式删除的是`a.x`这个运算的结果值（Result），是一个引用，亦即是对&#39;x&#39;这个属性名字的引用，所以它就从对象a中除去了这个名字，所以Object.keys(a)就不会再列举出来。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1653101769,"ip_address":"","comment_id":346275,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652968409","product_id":100039701,"comment_content":"您好, 我看您文中说delete a.x,是删除了a.x这个表达式的值;<br>此时有一和对象a = {x:12};<br>我现在要执行delete a.x 这个运算, 按照您文中所说, delete a.x 其实是是删除了a.x的值,既12这个变量. <br>所以此时a.x 等于undefined, 那么a的x属性应该存在, 上面只是删除了x属性代表的值,<br>那么我可以通过Object.keys, 就可以打印出这个x, 实际上是没有的, <br>我在声明一个变量 b = {x:undefined}, 此时打印Object.keys(b), 返回结果为[&#39;x&#39;];<br>是我理解有问题吗?","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572953,"discussion_content":"`delete a.x`中，“a.x的值”并不是“12这个变量”，而是“一个包括12这个值的引用”。\n\n一个表达式的结果值（Result）可以是引用（Reference），也可以是值（Value）。这一章本来 就是讲这个核心话题的，不过你仍然还混淆着。再提示一下，`delete a.x`这行表达式删除的是`a.x`这个运算的结果值（Result），是一个引用，亦即是对&#39;x&#39;这个属性名字的引用，所以它就从对象a中除去了这个名字，所以Object.keys(a)就不会再列举出来。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653101769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340553,"user_name":"尘一粒","can_delete":false,"product_type":"c1","uid":2082196,"ip_address":"","ucode":"1BBB911123BDED","user_header":"https://static001.geekbang.org/account/avatar/00/1f/c5/94/658c7e4c.jpg","comment_is_top":false,"comment_ctime":1648899068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648899068","product_id":100039701,"comment_content":"delete删除，其实是删除表达式的结果，或者引用，返回true只是表示没有保存，而不是“删除成功”","like_count":0},{"had_liked":false,"id":334531,"user_name":"Karboo","can_delete":false,"product_type":"c1","uid":1152129,"ip_address":"","ucode":"29874DFF0CB338","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL9vzK97QaNGJrwUp6rrXEbjurgqaGm3RBPFHib3nwDlic0616fpbNUXDJLGQPYIGibrBxwQ1l2iab6MA/132","comment_is_top":false,"comment_ctime":1644989440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644989440","product_id":100039701,"comment_content":"感觉作者讲了好多，又感觉作者什么都没讲。<br>给个建议吧，不太建议花时间来继续看。<br><br>作者问题：原理不是黑盒，你不用通过现象去推断。真想讲原理就讲透，真不懂就不要讲。","like_count":0},{"had_liked":false,"id":331996,"user_name":"Geek_a44db9","can_delete":false,"product_type":"c1","uid":2835868,"ip_address":"","ucode":"8D58329B4F1689","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJWOyzdmdY17rolD2WqfvMNpUeXCCHwjnOOsRvqU5ib9LGXtxrGnYiaY04xZ4yomwiaeulnZEQ2Pfz9A/132","comment_is_top":false,"comment_ctime":1642951874,"is_pvip":false,"replies":[{"id":"121317","content":"obj.x不是单值表达式，obj.x是一个双运算元的表达式，运算符是.号，而obj和x都是运算数。<br><br>在ECMAScript规范中单值表达式称为“Primary Expression”。单值表达式没有运算符，就是一个值或者是一个变量名。在js的语法概念里面，字面量值本身也是一个表达式。例如说“1”，它是表达式，所以在后面可以加一个“分号”表明它是一个“单值表达式语句”。<br><br>```<br># 这是表达式1，结果是1<br>&gt; 1<br>1<br><br># 这是语句&quot;1;&quot;，结果是1，不过是由语句返回的<br>&gt; 1;<br>1<br>```<br><br>又，.号是一个运算符，所以你能在MDN里面查到它的运算符优先级。这是一个判断“是不是运算符”的简单方法。<br>https:&#47;&#47;developer.mozilla.org&#47;zh-CN&#47;docs&#47;Web&#47;JavaScript&#47;Reference&#47;Operators&#47;Operator_Precedence","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1643010967,"ip_address":"","comment_id":331996,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1642951874","product_id":100039701,"comment_content":"亲爱的周爱民老师，关于单值表达式<br>是否是在说这样的一个事情<br>x = GetValue（x）<br>obj.x = GetValue(obj.x)<br>单值表达式的值其就是其本身，因为单值表达式不涉及到运算符号<br>所以 obj.x 中间的 . 也不是一个运算符号，而是一个属性访问表达式的语法结构的一部分，对吧？<br>","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548050,"discussion_content":"obj.x不是单值表达式，obj.x是一个双运算元的表达式，运算符是.号，而obj和x都是运算数。\n\n在ECMAScript规范中单值表达式称为“Primary Expression”。单值表达式没有运算符，就是一个值或者是一个变量名。在js的语法概念里面，字面量值本身也是一个表达式。例如说“1”，它是表达式，所以在后面可以加一个“分号”表明它是一个“单值表达式语句”。\n\n```\n# 这是表达式1，结果是1\n&gt; 1\n1\n\n# 这是语句&#34;1;&#34;，结果是1，不过是由语句返回的\n&gt; 1;\n1\n```\n\n又，.号是一个运算符，所以你能在MDN里面查到它的运算符优先级。这是一个判断“是不是运算符”的简单方法。\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643010967,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2835868,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJWOyzdmdY17rolD2WqfvMNpUeXCCHwjnOOsRvqU5ib9LGXtxrGnYiaY04xZ4yomwiaeulnZEQ2Pfz9A/132","nickname":"Geek_a44db9","note":"","ucode":"8D58329B4F1689","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547964,"discussion_content":"属性访问表达式：之前一直以为跟在对象后面的句点或者方括号是运算符，实际上不是，它们是属性访问表达式的语法结构的一部分。属性访问表达式语法如下：\n\nexpression.identifier 其中，expression可以是任意的表达式，identifier是属性名（必须合法） \n\n或者\n\nexpression1[expression2] \n\n\n\n作者：郑航\n链接：https://www.zhihu.com/question/39420977/answer/81250170\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642957043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2835868,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJWOyzdmdY17rolD2WqfvMNpUeXCCHwjnOOsRvqU5ib9LGXtxrGnYiaY04xZ4yomwiaeulnZEQ2Pfz9A/132","nickname":"Geek_a44db9","note":"","ucode":"8D58329B4F1689","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548070,"discussion_content":"他解释得不对。他承认是表达式，但如果是表达式，那就问：是单值的（无运算符），还是有运算符的表达式？如果是无运算符的，那么为什么.和[]有运算符的优先级？所以，.和[]是运算符，而obj.x并不是单值的（或无运算符的）表达式。但是，new.target和import.meta里面的.号就不是运算符，这两个东东都是单值，其中的.就只是语法。仔细区分的话，看相关的规范在这里：https://tc39.es/ecma262/#sec-left-hand-side-expressions ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643019568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547964,"ip_address":""},"score":548070,"extra":""}]}]},{"had_liked":false,"id":329557,"user_name":"Kids See Ghost","can_delete":false,"product_type":"c1","uid":1390088,"ip_address":"","ucode":"DA57BB8327BB01","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/08/c77d8a5a.jpg","comment_is_top":false,"comment_ctime":1641418061,"is_pvip":false,"replies":[{"id":"120092","content":"&quot;早期JavaScript推广……&quot;这样的说法现在很难在web上搜到了，旧资料很难查。不过这里有一个：<br>https:&#47;&#47;www.cs.unc.edu&#47;Courses&#47;comp416-f10&#47;lectures&#47;lecture09&#47;lecture09.html<br>参见其中的“Value Types vs Reference Types”小节，大意是一样的。早期（尤其是js 1.x的时代）对类型的介绍就没有统一过。<br><br>现在JS都不这样来讨论类型问题了，现在普遍的方法是将除Object之外的都归到值类型里去，因为ECMAScript上就是这么写的。关于类型问题，很多历史因素都在《JavaScript语言精髓与编程实践》里面讲过，那里面分析得更细致。<br><br>“规范类型”就是&quot;Specification Types&quot;，ECMAScript里面原文就是如此。“引用（规范类型）”在ECMAScript里的原文是“The Reference Record Specification Type”。因为如果要用ECMAScript里的直译的话，那就还得解释规范中的Record类型，以及List、Set、Relation等等类型，又是另外一整套了，也与JS没什么关系，所以只称为“引用（规范类型）”。<br><br>ECMAScript中的“引用（规范类型）”与我们常常说的“引用&#47;值”其实不是一回事情，差别还特别的大。但是他们的作用又有些相通的地方，很容易混淆。这个课程中在本讲之后讲的“引用”，如果没有特别的说明，都是指“引用（规范类型）”。多读几讲，你应该就有体会了。<br><br>最新的规范在这里：https:&#47;&#47;tc39.es&#47;ecma262&#47;","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1641489142,"ip_address":"","comment_id":329557,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1641418061","product_id":100039701,"comment_content":"不知道现在老师还会不会出来答疑了。<br>“早期的 JavaScript 在推广时，仍然采用传统的数据类型的分类方法，也就是说，它宣称自己同时支持值类型和引用类型的数据，并且，所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的。这些都是当时“开发人员的概念集”中已经有的、容易理解的知识，不需要特别解释。” <br>“早期的 JavaScript 在推广时，仍然采用传统的数据类型的分类方法” 言下之意是现在JavaScript已经不这么宣传了吗？<br>另外请问这个说法有出处吗？您可以贴一个链接吗？<br><br>另一个问题是规范类型的：<br>您说“关于表达式的值，在 ECMAScript 的规范中，称为“引用”。” <br>然后下一个自然段您说 “这是一种称为“规范类型”的东西。” ，”这“指代的是上面那个“引用”？ 所以连起来读是：<br>在 ECMAScript 的规范中被称为“引用”的东西也是被称为“规范类型”的东西？<br><br>另外请问您能给一下“规范类型”的英语原文吗？没有原文对照很多时候很容易产生歧义。<br>","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544386,"discussion_content":"&#34;早期JavaScript推广……&#34;这样的说法现在很难在web上搜到了，旧资料很难查。不过这里有一个：\nhttps://www.cs.unc.edu/Courses/comp416-f10/lectures/lecture09/lecture09.html\n参见其中的“Value Types vs Reference Types”小节，大意是一样的。早期（尤其是js 1.x的时代）对类型的介绍就没有统一过。\n\n现在JS都不这样来讨论类型问题了，现在普遍的方法是将除Object之外的都归到值类型里去，因为ECMAScript上就是这么写的。关于类型问题，很多历史因素都在《JavaScript语言精髓与编程实践》里面讲过，那里面分析得更细致。\n\n“规范类型”就是&#34;Specification Types&#34;，ECMAScript里面原文就是如此。“引用（规范类型）”在ECMAScript里的原文是“The Reference Record Specification Type”。因为如果要用ECMAScript里的直译的话，那就还得解释规范中的Record类型，以及List、Set、Relation等等类型，又是另外一整套了，也与JS没什么关系，所以只称为“引用（规范类型）”。\n\nECMAScript中的“引用（规范类型）”与我们常常说的“引用/值”其实不是一回事情，差别还特别的大。但是他们的作用又有些相通的地方，很容易混淆。这个课程中在本讲之后讲的“引用”，如果没有特别的说明，都是指“引用（规范类型）”。多读几讲，你应该就有体会了。\n\n最新的规范在这里：https://tc39.es/ecma262/","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641489142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273811,"user_name":"修亦然","can_delete":false,"product_type":"c1","uid":1297494,"ip_address":"","ucode":"5B18DCEF1FF80B","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/56/9f5f9abd.jpg","comment_is_top":false,"comment_ctime":1610685158,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610685158","product_id":100039701,"comment_content":"delete obj =&gt; 判断要删除的属性不存在 <br>1. delete x: 非声明的变量是可配置的, 删除的是一个引用<br>2. delete 0: 删除的是一个表达式的值<br><br>对比 void 0<br>1. void 会执行 getValue<br><br>obj.a(): this 的指向wen","like_count":0},{"had_liked":false,"id":259443,"user_name":"油菜","can_delete":false,"product_type":"c1","uid":2263588,"ip_address":"","ucode":"DB3334BC1720F1","user_header":"","comment_is_top":false,"comment_ctime":1604728552,"is_pvip":false,"replies":[{"id":"94397","content":"对于`var x = 0`是全局声明的情况来说，你的第一个解释是对的。但当`var x = 0`是函数内的声明时，这个声明并不以对象属性（例如全局对象的属性）的形式来存放，因此也就没有DontDelete attribute，所以还存在别的解释。<br><br>第2~3个示例，你的解释没问题。不过强调一下，`this.z`与`obj.z`的逻辑一样的。——所以`delete z`与`delete x`效果一致，只是针对global===this的特例。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1604852853,"ip_address":"","comment_id":259443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604728552","product_id":100039701,"comment_content":"var x=0;<br>console.log(delete x); &#47;&#47; false;  删除一个存在引用，返回false,是因为var来声明的，有DontDelete attribute，function也有DontDelete attribute。<br>console.log(delete y); &#47;&#47; true;   删除一个不存在的引用，返回true;是因为ECMAScript约定if Is UnresolvableReference, then return true”。（如果在这时发现是严格模式，就抛异常了）<br>this.z=1234;<br>console.log(delete z); &#47;&#47; true;   it is created via property assignment and so has no DontDelete attribute<br>console.log(delete 0); &#47;&#47; true;","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508939,"discussion_content":"对于`var x = 0`是全局声明的情况来说，你的第一个解释是对的。但当`var x = 0`是函数内的声明时，这个声明并不以对象属性（例如全局对象的属性）的形式来存放，因此也就没有DontDelete attribute，所以还存在别的解释。\n\n第2~3个示例，你的解释没问题。不过强调一下，`this.z`与`obj.z`的逻辑一样的。——所以`delete z`与`delete x`效果一致，只是针对global===this的特例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604852853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257168,"user_name":"心平气和的韩丽媛","can_delete":false,"product_type":"c1","uid":1177510,"ip_address":"","ucode":"ADB7DB7383EA4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/a6/0b590c34.jpg","comment_is_top":false,"comment_ctime":1603870345,"is_pvip":false,"replies":[{"id":"93715","content":"谢谢点赞支持。:)","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1603967968,"ip_address":"","comment_id":257168,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1603870345","product_id":100039701,"comment_content":"这个课也太值了，精选留言从头到尾读了一遍，我的问题都从老师的解答和大家的疑惑里找到了解答，老师的解答非常良心，点赞","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508240,"discussion_content":"谢谢点赞支持。:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603967968,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215140,"user_name":"我来人间一趟","can_delete":false,"product_type":"c1","uid":1733144,"ip_address":"","ucode":"15CAF96EF899E2","user_header":"https://static001.geekbang.org/account/avatar/00/1a/72/18/d9e2fcf9.jpg","comment_is_top":false,"comment_ctime":1588913130,"is_pvip":false,"replies":[{"id":"79735","content":"这个我确切地说是不了解的。<br>ECMAScript规范中没有对这个有任何的说明，因为这个涉及到具体引擎实现时对properties这个结构的内存回收机制，所以应该是不同引擎自己决定如何实现的。<br><br>不过有一点需要补充的。由于在ES6之后约定了Object.keys()返回是有序的，因此属性名如果移除，那么确实需要一点代价来维护keys顺序（属性名的列出顺序是它加入到属性表中的先后顺序）。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1588995889,"ip_address":"","comment_id":215140,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1588913130","product_id":100039701,"comment_content":"爱民老师 我有个疑问想请教一下哈 就是之前听一个老师讲过使用delete删除一个对象的属性会导致js的隐藏类重新创建 但是通过d8试了一下 我发现隐藏类map的内存地址没有改变 只是properties的内存地址变化了 这是不是说明使用delete删除一个属性值不会导致隐藏类重新创建呀？ ","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494328,"discussion_content":"这个我确切地说是不了解的。\nECMAScript规范中没有对这个有任何的说明，因为这个涉及到具体引擎实现时对properties这个结构的内存回收机制，所以应该是不同引擎自己决定如何实现的。\n\n不过有一点需要补充的。由于在ES6之后约定了Object.keys()返回是有序的，因此属性名如果移除，那么确实需要一点代价来维护keys顺序（属性名的列出顺序是它加入到属性表中的先后顺序）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588995889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1733144,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/72/18/d9e2fcf9.jpg","nickname":"我来人间一趟","note":"","ucode":"15CAF96EF899E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":261716,"discussion_content":"感谢🙏爱民老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588996018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212802,"user_name":"Ppei","can_delete":false,"product_type":"c1","uid":1369514,"ip_address":"","ucode":"C354F8EF0C5814","user_header":"https://static001.geekbang.org/account/avatar/00/14/e5/aa/57926594.jpg","comment_is_top":false,"comment_ctime":1588213609,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588213609","product_id":100039701,"comment_content":"```<br>const obj = {<br>        name: &#39;obj&#39;,<br>        getThis() {<br>          console.log(this);<br>        }<br>      };<br><br>      const obj1 = {<br>        name: &#39;obj1&#39;<br>      };<br><br>      obj.getThis();<br><br>      const getThis = obj.getThis;<br><br>      obj1.getThis = obj.getThis;<br><br>      getThis();<br><br>      obj1.getThis();<br>```<br><br>这个例子也能帮助我理解老师说的。","like_count":0},{"had_liked":false,"id":211977,"user_name":"香瓜","can_delete":false,"product_type":"c1","uid":1749354,"ip_address":"","ucode":"0C728853739313","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b1/6a/7bd83c94.jpg","comment_is_top":false,"comment_ctime":1588042019,"is_pvip":false,"replies":[{"id":"78774","content":"加油+5","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1588044991,"ip_address":"","comment_id":211977,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588042019","product_id":100039701,"comment_content":"第三遍的时候能懂了，估计还会有第四遍，加油","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493404,"discussion_content":"加油+5","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588044991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208730,"user_name":"魔灵","can_delete":false,"product_type":"c1","uid":1526838,"ip_address":"","ucode":"0655821F0668EE","user_header":"https://static001.geekbang.org/account/avatar/00/17/4c/36/d9e4a206.jpg","comment_is_top":false,"comment_ctime":1587429965,"is_pvip":false,"replies":[{"id":"78530","content":"不能。这样讲在概念上仍然是混乱的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1587915134,"ip_address":"","comment_id":208730,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587429965","product_id":100039701,"comment_content":"Delete obj.x是删除obj对象的x属性，同时删除其对应的值！可以这么说吗？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492596,"discussion_content":"不能。这样讲在概念上仍然是混乱的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587915134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194562,"user_name":"张木公","can_delete":false,"product_type":"c1","uid":1042672,"ip_address":"","ucode":"6165970C6FE179","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/f0/b7206e15.jpg","comment_is_top":false,"comment_ctime":1585067501,"is_pvip":false,"replies":[{"id":"74099","content":"如果用ref来代表x的引用，那么当它作为lhs时，会有一个潜在的操作称为GetValue(ref)。这时，如果ref是无效的（也就是x不存在），那么GetValue()就会抛一个执行异常。——这就是说，lhs是“取值”。<br><br>而当ref作为rhs的时候，是直接使用ref的，没有GetValue()的行为，因此也不会检查x存不存在。所以就不会报错。——这就是rhs是“取引用”的源由。<br><br>所以当使用代码`x = x`的时候，本质上是在做ref = GetValue(ref)，也因此“不存在的x”导致了取值操作（GetValue）出错。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1585114303,"ip_address":"","comment_id":194562,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1585067501","product_id":100039701,"comment_content":"老师好，请教下<br>文中：如果 x 放在左边作为 lhs，那么它是引用；如果放在右边作为 rhs，那么就是值。<br>那为什么x放在右手端，比如 var a=x，x不存在会报引用错误呢，reference error  ，我之前的理解是 LHS是赋值操作，RHS是引用变量值的操作，望老师指正","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488844,"discussion_content":"如果用ref来代表x的引用，那么当它作为lhs时，会有一个潜在的操作称为GetValue(ref)。这时，如果ref是无效的（也就是x不存在），那么GetValue()就会抛一个执行异常。——这就是说，lhs是“取值”。\n\n而当ref作为rhs的时候，是直接使用ref的，没有GetValue()的行为，因此也不会检查x存不存在。所以就不会报错。——这就是rhs是“取引用”的源由。\n\n所以当使用代码`x = x`的时候，本质上是在做ref = GetValue(ref)，也因此“不存在的x”导致了取值操作（GetValue）出错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585114303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1094421,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b3/15/01ef8470.jpg","nickname":"人间动物园","note":"","ucode":"FAF6DC16334C2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277119,"discussion_content":"老师的前两段关于lhs和rhs应该是说反了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1591003003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361002,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c4/6a/e45bbb6b.jpg","nickname":"Smile","note":"","ucode":"674C2361FFB807","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553120,"discussion_content":"感觉是反了吧？本来就晕，这么绕一下更晕","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645717877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192940,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1584879218,"is_pvip":false,"replies":[{"id":"73651","content":"@HoSalt 你的两个问题正好在留言中都有，但是由于这个极客时间没有办法贴留言的url，所以你得自己查找一下。按你引用的文字的原文就行，有相同的提问。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1584887526,"ip_address":"","comment_id":192940,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584879218","product_id":100039701,"comment_content":"「表达式的值，在 ECMAScript 的规范中，称为“引用”。」<br>「ECMAScript 约定：任何表达式计算的结果（Result）要么是一个值，要么是一个引用」<br>这两句是不是有冲突？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488483,"discussion_content":"@HoSalt 你的两个问题正好在留言中都有，但是由于这个极客时间没有办法贴留言的url，所以你得自己查找一下。按你引用的文字的原文就行，有相同的提问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584887526,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182470,"user_name":"心平气和的韩丽媛","can_delete":false,"product_type":"c1","uid":1177510,"ip_address":"","ucode":"ADB7DB7383EA4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/f7/a6/0b590c34.jpg","comment_is_top":false,"comment_ctime":1582793017,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582793017","product_id":100039701,"comment_content":"delete删除的是某个属性的引用，删除的不合规范，严格模式报错，非严格模式返回false","like_count":0},{"had_liked":false,"id":181726,"user_name":"大树","can_delete":false,"product_type":"c1","uid":1390549,"ip_address":"","ucode":"0B4C9091520DFA","user_header":"https://static001.geekbang.org/account/avatar/00/15/37/d5/22299804.jpg","comment_is_top":false,"comment_ctime":1582624701,"is_pvip":false,"replies":[{"id":"70392","content":"服你，哥哥","user_name":"编辑回复","user_name_real":"郭蕾","uid":"1000473","ctime":1582626055,"ip_address":"","comment_id":181726,"utype":2}],"discussion_count":3,"race_medal":1,"score":"1582624701","product_id":100039701,"comment_content":"看第一遍  想骂娘    静下来看多看几遍 收获满满","like_count":0,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485097,"discussion_content":"服你，哥哥","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582626055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1301767,"avatar":"https://static001.geekbang.org/account/avatar/00/13/dd/07/d9d9a72c.jpg","nickname":"abnormal","note":"","ucode":"41EF736F9ADF16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":538025,"discussion_content":"hhh同样，第一遍看下来，想骂娘","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639302822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293057,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/01/568ac2d6.jpg","nickname":"K4SHIFZ","note":"","ucode":"BFB49AAC0E4C74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222424,"discussion_content":"40米长刀刚拔出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586143437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181261,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1879993,"ip_address":"","ucode":"E8DA0D100F123E","user_header":"https://static001.geekbang.org/account/avatar/00/1c/af/b9/de81b5c8.jpg","comment_is_top":false,"comment_ctime":1582528768,"is_pvip":false,"replies":[{"id":"70317","content":"将这里的“引用（规范类型）”理解为一个语言实现用的语法组件就好了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1582554095,"ip_address":"","comment_id":181261,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582528768","product_id":100039701,"comment_content":"是否可以这样理解文章中的&quot;引用&quot;，这里的引用是语法层面的，是表达式的计算结果。而传统的引用是针对数据对象本身而言的。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484976,"discussion_content":"将这里的“引用（规范类型）”理解为一个语言实现用的语法组件就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582554095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161304,"user_name":"Bayes","can_delete":false,"product_type":"c1","uid":1539608,"ip_address":"","ucode":"2F83B2EFCE6B5D","user_header":"https://static001.geekbang.org/account/avatar/00/17/7e/18/c3ed4650.jpg","comment_is_top":false,"comment_ctime":1576171274,"is_pvip":false,"replies":[{"id":"61506","content":"多谢Bayes，总结简单到位！👍","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576203743,"ip_address":"","comment_id":161304,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576171274","product_id":100039701,"comment_content":"收获：<br>1. delete用于删除对象的属性<br>2. 如果属性是只读的，那么delete操作会返回false，在严格模型下还会报错<br>3. delete删除值，什么也不做并直接返回true<br>4. 我们经常说的undefined其实是global对象的一个只读属性，而null不仅是一个关键字而且是一个值，表示空<br>5. delete数组的某个元素会变成empty","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477684,"discussion_content":"多谢Bayes，总结简单到位！👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576203743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":160846,"user_name":"study","can_delete":false,"product_type":"c1","uid":1378133,"ip_address":"","ucode":"078517D3EF2413","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIEODRricvc32UpO3PxoPrFBDgmoGXdiagcibNh0outmZicXFg1icV4c5ibSknc4be3PWUPsIa3OjdMmlwA/132","comment_is_top":false,"comment_ctime":1576045881,"is_pvip":false,"replies":[{"id":"61339","content":"赞的。完全正确。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576047105,"ip_address":"","comment_id":160846,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576045881","product_id":100039701,"comment_content":"1、delete x 中，如果 x 根本不存在，什么也不做，返回true<br>2、delete object.x 中，如果 x 是只读的，删除失败。宽松模式下返回false；严格模式下报错","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477500,"discussion_content":"赞的。完全正确。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576047105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151300,"user_name":"nullday","can_delete":false,"product_type":"c1","uid":1739811,"ip_address":"","ucode":"CFCEA326A87B17","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8c/23/675bf0f3.jpg","comment_is_top":false,"comment_ctime":1573697556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573697556","product_id":100039701,"comment_content":"我以前去实现一个js引擎是，有一些原则<br>lhs(x) = rhs(2)<br>我总是认为lhs = getReference, 而 rhs = getValue, 我并不总认为 getValue 所得到的就一定是 value<br>我认为 getValue 和 getReference 只是一个 method, 与上面我们提到的值和应用并不完全指的一个意义，也就是getValue(Array) 不一定是值<br>","like_count":0},{"had_liked":false,"id":150643,"user_name":"雪松","can_delete":false,"product_type":"c1","uid":1373359,"ip_address":"","ucode":"A4F66814E642E6","user_header":"https://static001.geekbang.org/account/avatar/00/14/f4/af/5b8dfa74.jpg","comment_is_top":false,"comment_ctime":1573573209,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573573209","product_id":100039701,"comment_content":"一：<br>1 let a = {name:&#39;lxs&#39;,age:22}<br>2 delete a.name ===&gt;删掉了a对象的成员name，白话就是断开name和a的联系。此时name为undefined,返回true<br>3 &#39;name&#39; in a===&gt;返回false，验证上一步<br>4 delete a.name ===&gt; 什么都没有 返回true<br>二：<br>左值是引用，右值是表达式的结果<br>三：<br>删除writable，configurable，不严格环境下返回false，strict下会报错<br>四：<br>期待下一节","like_count":0},{"had_liked":false,"id":150626,"user_name":"郭纯","can_delete":false,"product_type":"c1","uid":1314521,"ip_address":"","ucode":"2613860B4642C4","user_header":"https://static001.geekbang.org/account/avatar/00/14/0e/d9/e61ce097.jpg","comment_is_top":false,"comment_ctime":1573569866,"is_pvip":false,"replies":[{"id":"57963","content":"以既有观念理解js，非常容易跳坑。这样的事我就干过😭","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573609619,"ip_address":"","comment_id":150626,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573569866","product_id":100039701,"comment_content":"其实 obj.x  在底层就是取得是指针也就是内存地址. 只是在配合运算符使用的时候取得是值. delete 就是删除这段地址 也就是  free 释放掉申请的内存空间.","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474224,"discussion_content":"以既有观念理解js，非常容易跳坑。这样的事我就干过😭","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573609619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150623,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1573569756,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1573569756","product_id":100039701,"comment_content":"delete 基础值 实际上什么都没干，返回true只是代表执行过程中没有异常<br><br>delete 这个操作的设计是删除一个表达式的结果","like_count":0},{"had_liked":false,"id":150546,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1573552669,"is_pvip":false,"replies":[{"id":"57902","content":"错很多了。不过前面说过，这些不是这一节的重点，后面会再讲的。不可能用一节课把读者的知识来个大翻盘嘛，做不到嘛。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573560213,"ip_address":"","comment_id":150546,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573552669","product_id":100039701,"comment_content":"「JS有两种东西可以被执行并存在结果，包括语句和表达式」，语句和表达式应该是包含关系？<br><br>语句的执行并不一定存在结果，比如 while 语句, delete (while(0){})，会输出错误，老师这里说的表达式是不是应该叫一元表达式呢？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474197,"discussion_content":"错很多了。不过前面说过，这些不是这一节的重点，后面会再讲的。不可能用一节课把读者的知识来个大翻盘嘛，做不到嘛。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573560213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49148,"discussion_content":"我觉得后面的课程中，你还需要回到这里（这一讲和这一个问题）来review，你可能会渐渐地就贯通了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573560334,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150543,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1573552504,"is_pvip":false,"replies":[{"id":"57898","content":"<br>^^.<br>慢慢听哇。不着急。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573560032,"ip_address":"","comment_id":150543,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573552504","product_id":100039701,"comment_content":"「在 JavaScript 中表达式是一个很独特的东西，所有一切表达式运算的终极目的都是为了得到一个值，例如字符串。然后再用另外一些操作将这个值输出出来，例如变成网页中的一个元素（element）」 这里存在函数式的思想，但没看出来和面向对象有什么关系呀","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474195,"discussion_content":"\n^^.\n慢慢听哇。不着急。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573560032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150530,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1573550476,"is_pvip":false,"replies":[{"id":"57896","content":"此引用非彼引用。在“习惯中的引用”中讲的引用，与后面ECMAScript引用是不同的。<br>类型系统中，Number()与number指的不是同一个东西。Number()指的是一数值对象，typeof(new Number)返回的是&#39;object&#39;，是引用类型；而number指的是123这样的，例如typeof(123)，返回的是&#39;number&#39;。——number是值类型。<br><br>类型系统也是以后要讲的东西，不是这里讲的重点。这里提到“习惯中的引用”，是为了将它跟后面的“ECMAScript中的引用”区分开。这一讲以及后面的两三讲都是讲的“ECMAScript中的引用（规范类型）”。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573559824,"ip_address":"","comment_id":150530,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573550476","product_id":100039701,"comment_content":"老师文中说「所谓值类型中的字符串是按照引用来赋值和传递引用（而不是传递值）的」 那是不是值类型的 Number 也是按照引用来赋值的，既然是传递引用为什么又说是值类型。它和 Object 传递的引用有怎么区别呢？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474193,"discussion_content":"此引用非彼引用。在“习惯中的引用”中讲的引用，与后面ECMAScript引用是不同的。\n类型系统中，Number()与number指的不是同一个东西。Number()指的是一数值对象，typeof(new Number)返回的是&amp;#39;object&amp;#39;，是引用类型；而number指的是123这样的，例如typeof(123)，返回的是&amp;#39;number&amp;#39;。——number是值类型。\n\n类型系统也是以后要讲的东西，不是这里讲的重点。这里提到“习惯中的引用”，是为了将它跟后面的“ECMAScript中的引用”区分开。这一讲以及后面的两三讲都是讲的“ECMAScript中的引用（规范类型）”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573559824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013841,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","nickname":"Smallfly","note":"","ucode":"D388D5E0249A69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49164,"discussion_content":"感谢老师的耐心解答。期待后续^^","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573561089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150441,"user_name":"Smallfly","can_delete":false,"product_type":"c1","uid":1013841,"ip_address":"","ucode":"D388D5E0249A69","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/51/4790e13e.jpg","comment_is_top":false,"comment_ctime":1573534637,"is_pvip":false,"replies":[{"id":"57867","content":"“而从实现角度看”这部分说得挺含糊的，这个需要再整理一下。不过我后续还会再讲，我们持续讨论吧。<br><br>^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1573549434,"ip_address":"","comment_id":150441,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1573534637","product_id":100039701,"comment_content":"写了一年多 JS，看了老师这篇后，对值类型和引用类型又有了一些新的理解。<br><br>从使用者的角度看：<br><br>值类型的变量 x 赋值给变量 y，在之后对 y 的任何操作都不会影响 x 的值。<br><br>引用类型的变量 x 赋值给 y，如果修改 y 的属性 a，x 的属性 a 也会被修改。<br><br>而从实现角度看：<br><br>值类型传递的是引用，比如字符串 x = &quot;abc&quot;；y=x；其实 x 和y引用的是同一块内存。<br><br>引用类型传递的也是值，这个值是指针地址。<br><br>———<br><br>还有挺多疑问的，后续还会持续留言向老师请教。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474161,"discussion_content":"“而从实现角度看”这部分说得挺含糊的，这个需要再整理一下。不过我后续还会再讲，我们持续讨论吧。\n\n^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573549434,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1293057,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/01/568ac2d6.jpg","nickname":"K4SHIFZ","note":"","ucode":"BFB49AAC0E4C74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":113125,"discussion_content":"值类型传递的是引用，比如字符串 x = &#34;abc&#34;；y=x；其实 x 和y引用的是同一块内存。\n这句话错了吧？x. y引用的并不是同一块内存，因为x改变了，y并没有变","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577890036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1361002,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c4/6a/e45bbb6b.jpg","nickname":"Smile","note":"","ucode":"674C2361FFB807","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1293057,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/01/568ac2d6.jpg","nickname":"K4SHIFZ","note":"","ucode":"BFB49AAC0E4C74","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553083,"discussion_content":"我也觉得说的不对，但是老师回复了没否认，有点费解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645711750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":113125,"ip_address":""},"score":553083,"extra":""}]}]},{"had_liked":false,"id":150356,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":1100750,"ip_address":"","ucode":"768098DBDBE333","user_header":"https://static001.geekbang.org/account/avatar/00/10/cb/ce/d9e00eb5.jpg","comment_is_top":false,"comment_ctime":1573522707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573522707","product_id":100039701,"comment_content":"所以，delelet 这个操作的正式语法设计并不是“删除某个东西”，<br><br>delete typo","like_count":0},{"had_liked":false,"id":150345,"user_name":"做最好的自己","can_delete":false,"product_type":"c1","uid":1742040,"ip_address":"","ucode":"170C91380FEEB3","user_header":"https://static001.geekbang.org/account/avatar/00/1a/94/d8/f2cf87ba.jpg","comment_is_top":false,"comment_ctime":1573521143,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573521143","product_id":100039701,"comment_content":"我太难了，突然发现以前的JS太浅薄了","like_count":0}]}