{"id":740846,"title":"第 8 章 装饰器","content":"\n<p>在大约十年前，我从事着 Python Web 开发相关的工作，用的是 Django 框架。那时 Django 是整个 Python 生态圈里最流行的开源 Web 开发框架 <span class=\"comment-number\">1</span>。</p>\n\n<p>作为最流行的 Web 开发框架，Django 提供了非常强大的功能。它有一个清晰的 MTV（model-template-view，模型—模板—视图）分层架构和开箱即用的 ORM<span class=\"comment-number\">2</span> 引擎，以及丰富到令人眼花缭乱的可配置项。</p>\n\n<p>但正因为提供了这些强大的功能，Django 的学习与使用成本也非常高。假如你从来没有接触过 Django，想要用它开发一个 Web 网站，得先学习一大堆框架配置、路由视图相关的东西，一晃大半天就过去了。</p>\n<p>在 Django 几乎统治了 Python Web 开发的那段日子里，不知从哪一天开始，越来越多的人突然开始谈论起另一个叫 Flask 的 Web 开发框架。</p><!-- [[[read_end]]] -->\n<p>出于好奇，我点开了 Flask 框架的官方文档，很快就被它的简洁性吸引了。举个例子，使用 Flask 开发一个 Hello World 站点，只需要下面这寥寥几行代码：</p>\n<pre class=\"code-rows\"><code>from flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello, World!'</code></pre>\n<p>作为对比，假如用 Django 开发这么一个站点，光配置文件 settings.py 里的代码就远比这些多。</p>\n<p>虽然在之后的好几个月，在我深入学习使用 Flask 的过程中，发现它有许多值得称道的设计，但在当时，在我刚看到官网的 Hello World 样例代码的那一刻，最吸引我的，其实是那一行路由注册代码：<code>@app.route('/')</code>。</p>\n<p>在接触 Flask 之前，虽然我已经使用过装饰器，也自己实现过装饰器，但从来没想过，装饰器原来可以用在 Web 站点中注册访问路由，而且这套 API 看起来居然特别自然、符合直觉。</p>\n<p>再后来，我接触到更多和装饰器有关的模块，比如基于装饰器的缓存模块、基于装饰器的命令行工具集 Click 等，如代码清单 8-1 所示。</p>\n<blockquote>\n<p><strong>代码清单 8-1</strong>　使用 Click 模块定义的一个简单的命令行工具 <span class=\"comment-number\">3</span></p>\n</blockquote>\n\n<pre class=\"code-rows\"><code>import click\n\n@click.command()\n@click.option('--count', default=1, help='Number of greetings.')\n@click.option('--name', prompt='Your name',\n              help='The person to greet.')\ndef hello(count, name):　　\n    \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\"\n    for x in range(count):\n        click.echo('Hello %s!' % name)\n\nif __name__ == '__main__':\n    hello()</code></pre>\n<p>这些模块和工具，无一例外地使用装饰器实现了简单好用的 API，为我的开发工作带来了极大便利。</p>\n<p>不过，虽然 Python 里的<strong>装饰器</strong>（decorator）很有用，但它本身并不复杂，只是 Python 语言的一颗小小的语法糖。如你所知，这样的装饰器应用代码：</p>\n<pre class=\"code-rows\"><code>@cache\ndef function():\n    ...</code></pre>\n<p>完全等同于下面这样：</p>\n<pre class=\"code-rows\"><code>def function():\n    ...\n\nfunction = cache(function)</code></pre>\n<p>装饰器并不提供任何独特的功能，它所做的，只是让我们可以在函数定义语句上方，直接添加用来修改函数行为的装饰器函数。假如没有装饰器，我们也可以在完成函数定义后，手动做一次包装和重新赋值。</p>\n<p>但正是因为装饰器提供的这一丁点儿好处，“通过包装函数来修改函数”这件事变得简单和自然起来。</p>\n<p>在日常工作中，如果你掌握了如何编写装饰器，并在恰当的时机使用装饰器，就可以写出更易复用、更好扩展的代码。在本章中，我将分享一些在 Python 中编写装饰器的技巧，以及几个用于编写装饰器的常见工具，希望它们能助你写出更好的代码。</p>\n<h2 id=\"nav_point_130\">8.1　基础知识</h2>\n<h3 id=\"nav_point_131\">8.1.1　装饰器基础</h3>\n<p><strong>装饰器</strong>是一种通过包装目标函数来修改其行为的特殊高阶函数，绝大多数装饰器是利用函数的闭包原理实现的。</p>\n<p>代码清单 8-2 所示的 <code>timer</code> 是个简单的装饰器，它会记录并打印函数的每次调用耗时。</p>\n<blockquote>\n<p><strong>代码清单 8-2</strong>　打印函数耗时的无参数装饰器 <code>timer</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>def timer(func):\n    \"\"\"装饰器：打印函数耗时\"\"\"\n\n    def decorated(*args, **kwargs):\n        st = time.perf_counter()\n        ret = func(*args, **kwargs)\n        print('time cost: {} seconds'.format(time.perf_counter() - st))\n        return ret\n\n    return decorated</code></pre>\n<p>在上面的代码中，<code>timer</code> 装饰器接收待装饰函数 <code>func</code> 作为唯一的位置参数，并在函数内定义了一个新函数：<code>decorated</code>。</p>\n<p>在写装饰器时，我一般把 <code>decorated</code> 叫作“包装函数”。这些包装函数通常接收任意数目的可变参数 <code>(*args, **kwargs)</code>，主要通过调用原始函数 <code>func</code> 来完成工作。在包装函数内部，常会增加一些额外步骤，比如打印信息、修改参数等。</p>\n<p>当其他函数应用了 <code>timer</code> 装饰器后，包装函数 <code>decorated</code> 会作为装饰器的返回值，完全替换被装饰的原始函数 <code>func</code>。</p>\n<p><code>random_sleep()</code> 使用了 <code>timer</code> 装饰器：</p>\n<pre class=\"code-rows\"><code>@timer\ndef random_sleep():\n    \"\"\"随机睡眠一小会儿\"\"\"\n    time.sleep(random.random())</code></pre>\n<p>调用结果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; random_sleep()\ntime cost: 0.8360576540000002 seconds ➊</code></pre>\n<blockquote>\n<p>❶ 由 <code>timer</code> 装饰器打印的耗时信息</p>\n</blockquote>\n<p><code>timer</code> 是一个无参数装饰器，实现起来较为简单。假如你想实现一个接收参数的装饰器，代码会更复杂一些。</p>\n<p>代码清单 8-3 给 <code>timer</code> 增加了额外的 <code>print_args</code> 参数。</p>\n<blockquote>\n<p><strong>代码清单 8-3</strong>　增加 <code>print_args</code> 的有参数装饰器 `timer</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def timer(print_args=False):\n    \"\"\"装饰器：打印函数耗时\n\n    :param print_args: 是否打印方法名和参数，默认为 False\n    \"\"\"\n\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            st = time.perf_counter()\n            ret = func(*args, **kwargs)\n            if print_args:\n                print(f'\"\", args: , kwargs: ')\n            print('time cost: {} seconds'.format(time.perf_counter() - st))\n            return ret\n\n        return wrapper\n\n    return decorator</code></pre>\n<p>可以看到，为了增加对参数的支持，装饰器在原本的两层嵌套函数上又加了一层。这是由于整个装饰过程发生了变化所导致的。</p>\n<p>具体来说，下面的装饰器应用代码：</p>\n<pre class=\"code-rows\"><code>@timer(print_args=True)\ndef random_sleep(): ...</code></pre>\n<p>展开后等同于下面的调用：</p>\n<pre class=\"code-rows\"><code>_decorator = timer(print_args=True) ➊\nrandom_sleep = _decorator(random_sleep) ➋</code></pre>\n<blockquote>\n<p>❶ 先进行一次调用，传入装饰器参数，获得第一层内嵌函数 <code>decorator</code></p>\n<p>❷ 进行第二次调用，获取第二层内嵌函数 <code>wrapper</code></p>\n</blockquote>\n<p>在应用有参数装饰器时，一共要做两次函数调用，所以装饰器总共得包含三层嵌套函数。正因为如此，有参数装饰器的代码一直都难写、难读。但不要紧，在 8.1.4 节中，我会介绍如何用类来实现有参数装饰器，减少代码的嵌套层级。</p>\n<h3 id=\"nav_point_132\">8.1.2　使用 <code>functools.wraps()</code> 修饰包装函数</h3>\n<p>在装饰器包装目标函数的过程中，常会出现一些副作用，其中一种是丢失函数元数据。</p>\n<p>在前一节的例子里，我用 <code>timer</code> 装饰了 <code>random_sleep()</code> 函数。现在，假如我想读取 <code>random_sleep()</code> 函数的名称、文档等属性，就会碰到一件尴尬的事情——函数的所有元数据都变成了装饰器的内层包装函数 <code>decorated</code> 的值：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; random_sleep.__name__\n'decorated'\n&gt;&gt;&gt; print(random_sleep.__doc__)\nNone</code></pre>\n<p>对于装饰器来说，上面的元数据丢失问题只能算一个常见的小问题。但如果你的装饰器会做一些更复杂的事，比如为原始函数增加额外属性（或函数）等，那你就会踏入一个更大的陷阱。</p>\n<p>举个例子，现在有一个装饰器 <code>calls_counter</code>，专门用来记录函数一共被调用了多少次，并且提供一个额外的函数来打印总次数，如代码清单 8-4 所示。</p>\n<blockquote>\n<p><strong>代码清单 8-4</strong>　记录函数调用次数的装饰器 <code>calls_counter</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>def calls_counter(func):\n    \"\"\"装饰器：记录函数被调用了多少次\n\n    使用 func.print_counter() 可以打印统计到的信息\n    \"\"\"\n    counter = 0\n\n    def decorated(*args, **kwargs):\n        nonlocal counter\n        counter += 1\n        return func(*args, **kwargs)\n\n    def print_counter():\n        print(f'Counter: ')\n\n    decorated.print_counter = print_counter ➊\n    return decorated</code></pre>\n<blockquote>\n<p>❶ 为被装饰函数增加额外函数，打印统计到的调用次数</p>\n</blockquote>\n<p>装饰器的执行效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; random_sleep()\n&gt;&gt;&gt; random_sleep()\n&gt;&gt;&gt; random_sleep.print_counter()\nCounter: 2</code></pre>\n<p>在单独使用 <code>calls_counter</code> 装饰器时，程序可以正常工作。但是，当你把前面的 <code>timer</code> 与 <code>calls_counter</code> 装饰器组合在一起使用时，就会出现问题：</p>\n<pre class=\"code-rows\"><code>@timer\n@calls_counter\ndef random_sleep():\n    \"\"\"随机睡眠一小会儿\"\"\"\n    time.sleep(random.random())</code></pre>\n<p>调用效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; random_sleep()\nfunction took: 0.36080002784729004 seconds\n\n&gt;&gt;&gt; random_sleep.print_counter()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'function' object has no attribute 'print_counter'</code></pre>\n<p>虽然 <code>timer</code> 装饰器仍在工作，函数执行时会打印耗时信息，但本该由 <code>calls_counter</code> 装饰器给函数追加的 <code>print_counter</code> 属性找不到了。</p>\n<p>为了分析原因，首先我们得把上面的装饰器调用展开成下面这样的语句：</p>\n<pre class=\"code-rows\"><code>random_sleep = calls_counter(random_sleep) ➊\nrandom_sleep = timer(random_sleep) ➋</code></pre>\n<blockquote>\n<p>❶ 首先，由 <code>calls_counter</code> 对函数进行包装，此时的 <code>random_sleep</code> 变成了新的包装函数，包含 <code>print_counter</code> 属性</p>\n<p>❷ 使用 <code>timer</code> 包装后，<code>random_sleep</code> 变成了 <code>timer</code> 提供的包装函数，原包装函数额外的 <code>print_counter</code> 属性被自然地丢掉了</p>\n</blockquote>\n<p>要解决这个问题，我们需要在装饰器内包装函数时，保留原始函数的额外属性。而 <code>functools</code> 模块下的 <code>wraps()</code> 函数正好可以完成这件事情。</p>\n<p>使用 <code>wraps()</code>，装饰器只需要做一点儿改动：</p>\n<pre class=\"code-rows\"><code>from functools import wraps\n\n\ndef timer(func):\n\n    @wraps(func) ➊\n    def decorated(*args, **kwargs):\n        ...\n\n    return decorated</code></pre>\n<blockquote>\n<p>❶ 添加 <code>@wraps(wrapped)</code> 来装饰 <code>decorated</code> 函数后，<code>wraps()</code> 首先会基于原函数 <code>func</code> 来更新包装函数 <code>decorated</code> 的名称、文档等内置属性，之后会将 <code>func</code> 的所有额外属性赋值到 <code>decorated</code> 上</p>\n</blockquote>\n<p>在 <code>timer</code> 和 <code>calls_counter</code> 装饰器里增加 <code>wraps</code> 后，前面的所有问题都可以得到圆满的解决。</p>\n<p>首先，被装饰函数的名称和文档等元数据会保留：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; random_sleep.__name__\n'random_sleep'\n&gt;&gt;&gt; random_sleep.__doc__\n'随机睡眠一小会儿'</code></pre>\n<p><code>calls_counter</code> 装饰器为函数追加的额外函数也可以正常访问了：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; random_sleep()\nfunction took: 0.9187359809875488 seconds\n&gt;&gt;&gt; random_sleep()\nfunction took: 0.8986420631408691 seconds\n&gt;&gt;&gt; random_sleep.print_counter()\nCounter: 2</code></pre>\n<p>正因为如此，在编写装饰器时，切记使用 <code>@functools.wraps()</code> 来修饰包装函数。</p>\n<h3 id=\"nav_point_133\">8.1.3　实现可选参数装饰器</h3>\n<p>假如你用嵌套函数来实现装饰器，接收参数与不接收参数的装饰器代码有很大的区别——前者总是比后者多一层嵌套。</p>\n<pre class=\"code-rows\"><code># 1. 接收参数的装饰器：2 层嵌套\ndef delayed_start(duration=1):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            ...\n        return wrapper\n    return decorator\n\n# 2. 不接收参数的装饰器：1 层嵌套\ndef delayed_start(func):\n    def wrapper(*args, **kwargs):\n        ...\n    return wrapper</code></pre>\n<p>当你实现了一个接收参数的装饰器后，即便所有参数都是有默认值的可选参数，你也必须在使用装饰器时加上括号：</p>\n<pre class=\"code-rows\"><code>@delayed_start(duration=2) ➊\n\n@delayed_start() ➋</code></pre>\n<blockquote>\n<p>❶ 使用装饰器时提供参数</p>\n<p>❷ 不提供参数，也需要使用括号调用装饰器</p>\n</blockquote>\n<p>有参数装饰器的这个特点提高了它的使用成本——如果使用者忘记添加那对括号，程序就会出错。</p>\n<p>那么有没有什么办法，能让我们省去那对括号，直接使用 <code>@delayed_start</code> 这种写法呢？答案是肯定的，利用仅限关键字参数，你可以很方便地做到这一点。</p>\n<p>代码清单 8-5 里的 <code>delayed_start</code> 装饰器就定义了可选的 <code>duration</code> 参数。</p>\n<blockquote>\n<p><strong>代码清单 8-5</strong>　定义了可选参数的装饰器 <code>delayed_start</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>def delayed_start(func=None, *, duration=1): ➊\n    \"\"\"装饰器：在执行被装饰函数前，等待一段时间\n\n    :param duration: 需要等待的秒数\n    \"\"\"\n\n    def decorator(_func):\n        def wrapper(*args, **kwargs):\n            print(f'Wait for  second before starting...')\n            time.sleep(duration)\n            return _func(*args, **kwargs)\n\n        return wrapper\n    if func is None: ➋\n        return decorator\n    else:\n        return decorator(func) ➌</code></pre>\n<blockquote>\n<p>❶ 把所有参数都变成提供了默认值的可选参数</p>\n<p>❷ 当 <code>func</code> 为 <code>None</code> 时，代表使用方提供了关键字参数，比如 <code>@delayed_start(duration=2)</code>，此时返回接收单个函数参数的内层子装饰器 <code>decorator</code></p>\n<p>❸ 当位置参数 <code>func</code> 不为 <code>None</code> 时，代表使用方没提供关键字参数，直接用了无括号的 <code>@ delayed_start</code> 调用方式，此时返回内层包装函数 <code>wrapper</code></p>\n</blockquote>\n<p>这样定义装饰器以后，我们可以通过多种方式来使用它：</p>\n<pre class=\"code-rows\"><code># 1. 不提供任何参数\n@delayed_start\ndef hello(): ...\n\n# 2. 提供可选的关键字参数\n@delayed_start(duration=2)\ndef hello(): ...\n\n# 3. 提供括号调用，但不提供任何参数\n@delayed_start()\ndef hello(): ...</code></pre>\n<blockquote>\n<p><img img src=\"https://static001.geekbang.org/files/resource/ebook/100007/image00371.jpeg\" alt=\"\" width=\"5%\" style=\"width: 5%\" inline-img=\"true\" />　把参数变为可选能有效降低使用者的心智负担，让装饰器变得更易用。标准库 <code>dataclasses</code> 模块里的 <code>@dataclass</code> 装饰器就使用了这个小技巧。</p>\n</blockquote>\n<h3 id=\"nav_point_134\">8.1.4　用类来实现装饰器（函数替换）</h3>\n<p>绝大多数情况下，我们会选择用嵌套函数来实现装饰器，但这并非构造装饰器的唯一方式。事实上，某个对象是否能通过装饰器（<code>@decorator</code>）的形式使用只有一条判断标准，那就是 <code>decorator</code> 是不是一个可调用的对象。</p>\n<p>函数自然是可调用对象，除此之外，类同样也是可调用对象。</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; class Foo:\n...     pass\n...\n&gt;&gt;&gt; callable(Foo) ➊\nTrue</code></pre>\n<blockquote>\n<p>❶ 使用 <code>callable()</code> 内置函数可以判断某个对象是否可调用</p>\n</blockquote>\n<p>如果一个类实现了 <code>__call__</code> 魔法方法，那么它的实例也会变成可调用对象：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; class Foo:\n...     def __call__(self, name): ➊\n...         print(f'Hello, ')\n...\n&gt;&gt;&gt; foo = Foo()\n&gt;&gt;&gt; callable(foo)\nTrue\n&gt;&gt;&gt; foo('World') ➋\nHello, World</code></pre>\n<blockquote>\n<p>❶ <code>__call__</code> 魔法方法是用来实现可调用对象的关键方法</p>\n<p>❷ 调用类实例时，可以像调用普通函数一样提供额外参数</p>\n</blockquote>\n<p>基于类的这些特点，我们完全可以用它来实现装饰器。</p>\n<p>如果按装饰器用于替换原函数的对象类型来分类，类实现的装饰器可分为两种，一种是“函数替换”，另一种是“实例替换”。下面我们先来看一下前者。</p>\n<p>函数替换装饰器虽然是基于类实现的，但用来替换原函数的对象仍然是个普通的包装函数。这种技术最适合用来实现接收参数的装饰器。</p>\n<p>代码清单 8-6 用类的方式重新实现了接收参数的 <code>timer</code> 装饰器。</p>\n<blockquote>\n<p><strong>代码清单 8-6</strong>　用类实现的 <code>timer</code> 装饰器</p>\n</blockquote>\n<pre class=\"code-rows\"><code>class timer:\n    \"\"\"装饰器：打印函数耗时\n\n    :param print_args: 是否打印方法名和参数，默认为 False\n    \"\"\"\n\n    def __init__(self, print_args):\n        self.print_args = print_args\n\n    def __call__(self, func):\n        @wraps(func)\n        def decorated(*args, **kwargs):\n            st = time.perf_counter()\n            ret = func(*args, **kwargs)\n            if self.print_args:\n                print(f'\"\", args: , kwargs: ')\n            print('time cost: {} seconds'.format(time.perf_counter() - st))\n            return ret\n\n        return decorated</code></pre>\n<p>还记得我之前说过，有参数装饰器一共得提供两次函数调用吗？通过类实现的装饰器，其实就是把原本的两次函数调用替换成了类和类实例的调用。</p>\n<p>(1) 第一次调用：<code>_deco = timer(print_args=True)</code> 实际上是在初始化一个 <code>timer</code> 实例。</p>\n<p>(2) 第二次调用：<code>func = _deco(func)</code> 是在调用 <code>timer</code> 实例，触发 <code>__call__</code> 方法。</p>\n<p>相比三层嵌套的闭包函数装饰器，上面这种写法在实现有参数装饰器时，代码更清晰一些，里面的嵌套也少了一层。不过，虽然装饰器是用类实现的，但最终用来替换原函数的对象，仍然是一个处在 <code>__call__</code> 方法里的闭包函数 <code>decorated</code>。</p>\n<p>虽然“函数替换”装饰器的代码更简单，但它和普通装饰器并没有本质区别。下面我会介绍另一种更强大的装饰器——用实例来替换原函数的“实例替换”装饰器。</p>\n<h3 id=\"nav_point_135\">8.1.5　用类来实现装饰器（实例替换）</h3>\n<p>和“函数替换”装饰器不一样，“实例替换”装饰器最终会用一个类实例来替换原函数。通过组合不同的工具，它既能实现无参数装饰器，也能实现有参数装饰器。</p>\n<ol>\n<li><p><strong>实现无参数装饰器</strong></p>\n<p>用类来实现装饰器时，被装饰的函数 <code>func</code> 会作为唯一的初始化参数传递到类的实例化方法 <code>__init__</code> 中。同时，类的实例化结果——<strong>类实例</strong>（class instance），会作为包装对象替换原始函数。</p>\n<p>代码清单 8-7 实现了一个延迟函数执行的装饰器。</p>\n<blockquote>\n<p><strong>代码清单 8-7</strong>　实例替换的无参数装饰器 <code>DelayedStart</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>class DelayedStart:\n    \"\"\"在执行被装饰函数前，等待 1 秒钟\"\"\"\n\n    def __init__(self, func):\n        update_wrapper(self, func) ➊\n        self.func = func\n\n    def __call__(self, *args, **kwargs): ➋\n        print(f'Wait for 1 second before starting...')\n        time.sleep(1)\n        return self.func(*args, **kwargs)\n\n    def eager_call(self, *args, **kwargs): ➌\n        \"\"\"跳过等待，立刻执行被装饰函数\"\"\"\n        print('Call without delay')\n        return self.func(*args, **kwargs)</code></pre>\n<blockquote>\n<p>❶ <code>update_wrapper</code> 与前面的 <code>wraps</code> 一样，都是把被包装函数的元数据更新到包装者（在这里是 <code>DelayedStart</code> 实例）上</p>\n<p>❷ 通过实现 <code>__call__</code> 方法，让 <code>DelayedStart</code> 的实例变得可调用，以此模拟函数的调用行为</p>\n<p>❸ 为装饰器类定义额外方法，提供更多样化的接口</p>\n</blockquote>\n<p>执行效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; @DelayedStart\n... def hello():\n...     print(\"Hello, World.\")\n\n&gt;&gt;&gt; hello\n&lt;__main__.DelayedStart object at 0x100b71130&gt;\n&gt;&gt;&gt; type(hello)\n&lt;class '__main__.DelayedStart'&gt;\n&gt;&gt;&gt; hello.__name__ ➊\n'hello'\n\n&gt;&gt;&gt; hello() ➋\nWait for 1 second before starting...\nHello, World.\n&gt;&gt;&gt; hello.eager_call() ➌\nCall without delay\nHello, World.</code></pre>\n<blockquote>\n<p>❶ 被装饰的 <code>hello</code> 函数已经变成了装饰器类 <code>DelayedStart</code> 的实例，但是因为 <code>update_wrapper</code> 的作用，这个实例仍然保留了被装饰函数的元数据</p>\n<p>❷ 此时触发的其实是装饰器类实例的 <code>__call__</code> 方法</p>\n<p>❸ 使用额外的 <code>eager_call</code> 接口调用函数</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>实现有参数装饰器</strong></p>\n<p>同普通装饰器一样，“实例替换”装饰器也可以支持参数。为此我们需要先修改类的实例化方法，增加额外的参数，再定义一个新函数，由它来负责基于类创建新的可调用对象，这个新函数同时也是会被实际使用的装饰器。</p>\n<p>在代码清单 8-8 中，我为 <code>DelayedStart</code> 增加了控制调用延时的 <code>duration</code> 参数，并定义了 <code>delayed_start()</code> 函数。</p>\n<blockquote>\n<p><strong>代码清单 8-8</strong>　实例替换的有参数装饰器 <code>delayed_start</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>class DelayedStart:\n    \"\"\"在执行被装饰函数前，等待一段时间\n    :param func: 被装饰的函数\n    :param duration: 需要等待的秒数\n    \"\"\"\n\n    def __init__(self, func, *, duration=1): ➊\n        update_wrapper(self, func)\n        self.func = func\n        self.duration = duration\n\n    def __call__(self, *args, **kwargs):\n        print(f'Wait for  second before starting...')\n        time.sleep(self.duration)\n        return self.func(*args, **kwargs)\n\n    def eager_call(self, *args, **kwargs): ...\n\ndef delayed_start(**kwargs):\n    \"\"\"装饰器：推迟某个函数的执行\"\"\"\n    return functools.partial(DelayedStart, **kwargs) ➋</code></pre>\n<blockquote>\n<p>❶ 把 <code>func</code> 参数以外的其他参数都定义为“仅限关键字参数”，从而更好地区分原始函数与装饰器的其他参数</p>\n<p>❷ 通过 <code>partial</code> 构建一个新的可调用对象，这个对象接收的唯一参数是待装饰函数 <code>func</code>，因此可以用作装饰器</p>\n</blockquote>\n<p>使用样例如下：</p>\n<pre class=\"code-rows\"><code>@delayed_start(duration=2)\ndef hello():\n    print(\"Hello, World.\")</code></pre>\n<p>相比传统做法，用类来实现装饰器（实例替换）的主要优势在于，你可以更方便地管理装饰器的内部状态，同时也可以更自然地为被装饰对象追加额外的方法和属性。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_136\">8.1.6　使用 <code>wrapt</code> 模块助力装饰器编写</h3>\n<p>在编写通用装饰器时，我常常会遇到一类麻烦事。</p>\n<p>如代码清单 8-9 所示，我实现了一个自动注入函数参数的装饰器 <code>provide_number</code>，它在装饰函数后，会在后者被调用时自动生成一个随机数，并将其注入为函数的第一个位置参数。</p>\n<blockquote>\n<p><strong>代码清单 8-9</strong>　注入数字的装饰器 <code>provide_number</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>import random\n\ndef provide_number(min_num, max_num):\n    \"\"\"\n    装饰器：随机生成一个在 [min_num, max_num] 范围内的整数，\n    并将其追加为函数的第一个位置参数\n    \"\"\"\n\n    def wrapper(func):\n        def decorated(*args, **kwargs):\n            num = random.randint(min_num, max_num)\n            # 将 num 追加为第一个参数，然后调用函数\n            return func(num, *args, **kwargs)\n\n        return decorated\n\n    return wrapper</code></pre>\n<p>使用效果如下：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; @provide_number(1, 100)\n... def print_random_number(num):\n...     print(num)\n...\n&gt;&gt;&gt; print_random_number()\n57</code></pre>\n<p><code>@provide_number</code> 装饰器的功能看上去很不错，但当我用它来修饰类方法时，就会碰上“麻烦事”：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; class Foo:\n...     @provide_number(1, 100)\n...     def print_random_number(self, num):\n...         print(num)\n...\n&gt;&gt;&gt; Foo().print_random_number()\n&lt;__main__.Foo object at 0x100f70460&gt;\nprint_random_number()</code></pre>\n<p>如你所见，类实例中的 <code>print_random_number()</code> 方法并没有打印我期望中的随机数字 <code>num</code>，而是输出了类实例 <code>self</code> 对象。</p>\n<p>这是因为类<strong>方法</strong>（method）和<strong>函数</strong>（function）在工作机制上有细微的区别。当类实例方法被调用时，第一个位置参数总是当前绑定的类实例 <code>self</code> 对象。因此，当装饰器向 <code>*args</code> 前追加随机数时，其实已经把 <code>*args</code> 里的 <code>self</code> 挤到了 <code>num</code> 参数所在的位置，从而导致了上面的问题。</p>\n<p>为了修复这个问题，<code>provide_number</code> 装饰器在追加位置参数时，必须聪明地判断当前被修饰的对象是普通函数还是类方法。假如被修饰的对象是类方法，那就得跳过藏在 <code>*args</code> 里的类实例变量，才能正确将 <code>num</code> 作为第一个参数注入。</p>\n<p>假如要手动实现这个判断，装饰器内部必须增加一些烦琐的兼容代码，费工费时。幸运的是，<code>wrapt</code> 模块可以帮我们轻松处理好这类问题。</p>\n<p><code>wrapt</code> 是一个第三方装饰器工具库，利用它，我们可以非常方便地改造 <code>provide_number</code> 装饰器，完美地解决这个问题。</p>\n<p>使用 <code>wrapt</code> 改造过的装饰器如代码清单 8-10 所示。</p>\n<blockquote>\n<p><strong>代码清单 8-10</strong>　基于 <code>wrapt</code> 模块实现的 <code>provide_number</code> 装饰器</p>\n</blockquote>\n<pre class=\"code-rows\"><code>import wrapt\n\n\ndef provide_number(min_num, max_num):\n    @wrapt.decorator\n    def wrapper(wrapped, instance, args, kwargs):\n        # 参数含义：\n        #\n        # - wrapped：被装饰的函数或类方法\n        # - instance：\n        # - 如果被装饰者为普通类方法，则该值为类实例\n        # - 如果被装饰者为 classmethod 类方法，则该值为类\n        # - 如果被装饰者为类/函数/静态方法，则该值为 None\n        #\n        # - args：调用时的位置参数（注意没有 * 符号）\n        # - kwargs：调用时的关键字参数（注意没有 ** 符号）\n        #\n        num = random.randint(min_num, max_num)\n        # 无须关注 wrapped 是类方法还是普通函数，直接在头部追加参数\n        args = (num,) + args\n        return wrapped(*args, **kwargs)\n\nreturn wrapper</code></pre>\n<p>新装饰器可以完美兼容普通函数与类方法两种情况：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; print_random_number()\n22\n&gt;&gt;&gt; Foo().print_random_number()\n93</code></pre>\n<p>使用 <code>wrapt</code> 模块编写的装饰器，除了解决了类方法兼容问题以外，代码嵌套层级也比普通装饰器少，变得更扁平、更易读。如果你有兴趣，可以参阅 <code>wrapt</code> 模块的官方文档了解更多信息。</p>\n<h2 id=\"nav_point_137\">8.2　编程建议</h2>\n<h3 id=\"nav_point_138\">8.2.1　了解装饰器的本质优势</h3>\n<p>当我们向其他人介绍装饰器时，常常会说：“装饰器为我们提供了一种<strong>动态修改函数</strong>的能力。”这么说有一定道理，但是并不准确。“动态修改函数”的能力，其实并不是由装饰器提供的。假如没有装饰器，我们也能在定义完函数后，手动调用装饰函数来修改它。</p>\n<p>装饰器带来的改变，主要在于把修改函数的调用提前到了函数定义处，而这一点儿位置上的小变化，重塑了读者理解代码的整个过程。</p>\n<p>比如，当人们读到下面的函数定义语句时，马上就能明白：“哦，原来这个视图函数需要登录才能访问。”</p>\n<pre class=\"code-rows\"><code>@login_requried\ndef view_function(request):\n    ...</code></pre>\n<p>所以，装饰器的优势并不在于它提供了动态修改函数的能力，而在于它把影响函数的装饰行为移到了函数头部，降低了代码的阅读与理解成本。</p>\n<p>为了充分发挥这个优势，装饰器特别适合用来实现以下功能。</p>\n<p>(1) <strong>运行时校验</strong>：在执行阶段进行特定校验，当校验通不过时终止执行。</p>\n<ul>\n<li>适合原因：装饰器可以方便地在函数执行前介入，并且可以读取所有参数辅助校验。</li>\n<li>代表样例：Django 框架中的用户登录态校验装饰器 <code>@login_required</code>。</li>\n</ul>\n<p>(2) <strong>注入额外参数</strong>：在函数被调用时自动注入额外的调用参数。</p>\n<ul>\n<li>适合原因：装饰器的位置在函数头部，非常靠近参数被定义的位置，关联性强。</li>\n<li>代表样例：<code>unittest.mock</code> 模块的装饰器 <code>@patch</code>。</li>\n</ul>\n<p>(3) <strong>缓存执行结果</strong>：通过调用参数等输入信息，直接缓存函数执行结果。</p>\n<ul>\n<li>适合原因：添加缓存不需要侵入函数内部逻辑，并且功能非常独立和通用。</li>\n<li>代表样例：<code>functools</code> 模块的缓存装饰器 <code>@lru_cache</code>。</li>\n</ul>\n<p>(4) <strong>注册函数</strong>：将被装饰函数注册为某个外部流程的一部分。</p>\n<ul>\n<li>适合原因：在定义函数时可以直接完成注册，关联性强。</li>\n<li>代表样例：Flask 框架的路由注册装饰器 <code>@app.route</code>。</li>\n</ul>\n<p>(5) <strong>替换为复杂对象</strong>：将原函数（方法）替换为更复杂的对象，比如类实例或特殊的描述符对象（见 12.1.3 节）。</p>\n<ul>\n<li>适合原因：在执行替换操作时，装饰器语法天然比 <code>foo = staticmethod(foo)</code> 的写法要直观得多。</li>\n<li>代表样例：静态类方法装饰器 <code>@staticmethod</code>。</li>\n</ul>\n<p>在设计新的装饰器时，你可以先参考上面的常见装饰器功能列表，琢磨琢磨自己的设计是否能很好地发挥装饰器的优势。切勿滥用装饰器技术，设计出一些天马行空但难以理解的 API。吸取前人经验，同时在设计上保持克制，才能写出更好用的装饰器。</p>\n<h3 id=\"nav_point_139\">8.2.2　使用类装饰器替代元类</h3>\n<p>Python 中的<strong>元类</strong>（metaclass）是一种特殊的类。就像类可以控制实例的创建过程一样，元类可以控制类的创建过程。通过元类，我们能实现各种强大的功能。比如下面的代码就利用元类统一注册所有 <code>Validator</code> 类：</p>\n<pre class=\"code-rows\"><code>_validators = {}\n\nclass ValidatorMeta(type):\n    \"\"\"元类：统一注册所有校验器类，方便后续使用\"\"\"\n\n    def __new__(cls, name, bases, attrs):\n        ret = super().__new__(cls, name, bases, attrs)\n        _validators[attrs['name']] = ret\n        return ret\n\n\nclass StringValidator(metaclass=ValidatorMeta):\n    name = 'string'\n\nclass IntegerValidator(metaclass=ValidatorMeta):\n    name = 'int'</code></pre>\n<p>查看注册结果：</p>\n<pre class=\"code-rows\"><code>&gt;&gt;&gt; _validators\n{'string': &lt;class '__main__.StringValidator'&gt;, 'int': &lt;class '__main__.IntegerValidator'&gt;}</code></pre>\n<p>虽然元类的功能很强大，但它的学习与理解成本非常高。其实，对于实现上面这种常见需求，并不是非使用元类不可，使用类装饰器也能非常方便地完成同样的工作。</p>\n<p>类装饰器的工作原理与普通装饰器类似。下面的代码就用类装饰器实现了 <code>ValidatorMeta</code> 元类的功能：</p>\n<pre class=\"code-rows\"><code>def register(cls):\n    \"\"\"装饰器：统一注册所有校验器类，方便后续使用\"\"\"\n    _validators[cls.name] = cls\n    return cls\n\n@register\nclass StringValidator:\n    name = 'string'\n\n@register\nclass IntegerValidator:\n    name = 'int'</code></pre>\n<p>相比元类，使用类装饰器的代码要容易理解得多。</p>\n<p>除了上面的注册功能以外，你还可以用类装饰器完成许多实用的事情，比如实现单例设计模式、自动为类追加方法，等等。</p>\n<p>虽然类装饰器并不能覆盖元类的所有功能，但在许多场景下，类装饰器可能比元类更合适，因为它不光写起来容易，理解起来也更简单。像广为人知的标准库模块 <code>dataclasses</code> 里的 <code>@ dataclass</code> 就选择了类装饰器，而不是元类。</p>\n<h3 id=\"nav_point_140\">8.2.3　别弄混装饰器和装饰器模式</h3>\n<p>1994 年出版的经典软件开发著作《设计模式：可复用面向对象软件的基础》中，一共介绍了 23 种经典的面向对象设计模式。这些设计模式为编写好代码提供了许多指导，影响了一代又一代的程序员。</p>\n<p>在这 23 种设计模式中，有一种“装饰器模式”。也许是因为装饰器模式和 Python 里的装饰器使用了同一个名字：<strong>装饰器</strong>（decorator），导致经常有人把它俩当成一回事儿，认为使用 Python 里的装饰器就是在实践装饰器模式。</p>\n<p>但事实上，《设计模式》一书中的“装饰器模式”与 Python 里的“装饰器”截然不同。</p>\n<p>装饰器模式属于面向对象领域。实现装饰器模式，需要具备以下关键要素：</p>\n<ul>\n<li>设计一个统一的接口；</li>\n<li>编写多个符合该接口的装饰器类，每个类只实现一个简单的功能；</li>\n<li>通过组合的方式嵌套使用这些装饰器类；</li>\n<li>通过类和类之间的层层包装来实现复杂的功能。</li>\n</ul>\n<p>代码清单 8-11 是我用 Python 实现的一个简单的装饰器模式。</p>\n<blockquote>\n<p><strong>代码清单 8-11</strong>　装饰器模式示例</p>\n</blockquote>\n<pre class=\"code-rows\"><code>class Numbers:\n    \"\"\"一个包含多个数字的简单类\"\"\"\n\n    def __init__(self, numbers):\n        self.numbers = numbers\n\n    def get(self):\n        return self.numbers\n\n\nclass EvenOnlyDecorator:\n    \"\"\"装饰器类：过滤所有偶数\"\"\"\n\n    def __init__(self, decorated):\n        self.decorated = decorated\n\n    def get(self):\n        return [num for num in self.decorated.get() if num % 2 == 0]\n\n\nclass GreaterThanDecorator:\n    \"\"\"装饰器类：过滤大于某个数的数\"\"\"\n\n    def __init__(self, decorated, min_value):\n        self.decorated = decorated\n        self.min_value = min_value\n\n    def get(self):\n        return [num for num in self.decorated.get() if num &gt; self.min_value]\n\n\nobj = Numbers([42, 12, 13, 17, 18, 41, 32])\neven_obj = EvenOnlyDecorator(obj)\ngt_obj = GreaterThanDecorator(even_obj, min_value=30)\nprint(gt_obj.get())</code></pre>\n<p>执行结果如下：</p>\n<pre class=\"code-rows\"><code>[42, 32]</code></pre>\n<p>从上面的代码中你能发现，装饰器模式和 Python 里的装饰器毫不相干。如果硬要找一点儿联系，它俩可能都和“包装”有关——一个包装函数，另一个包装类。</p>\n<p>所以，请不要混淆装饰器和装饰器模式，它们只是名字里刚好都有“装饰器”而已。</p>\n<h3 id=\"nav_point_141\">8.2.4　浅装饰器，深实现</h3>\n<p>在编写装饰器时，人们很容易产生这样的想法：“我的装饰器要实现某个功能，所以我要把所有逻辑都放在装饰器里实现。”抱着这样的想法去写代码，很容易写出异常复杂的装饰器代码。</p>\n<p>在编写了许多装饰器后，我发现了一种更好的代码组织思路，那就是：<strong>浅装饰器，深实现</strong>。</p>\n<p>举个例子，流行的第三方命令行工具包 Click 里大量使用了装饰器。但如果你查看 Click 包的源码，就会发现 Click 的所有装饰器都在一个不到 400 行代码的 decorators.py 文件中，里面的大部分装饰器的代码不超过 10 行，如代码清单 8-12 所示。</p>\n<blockquote>\n<p><strong>代码清单 8-12</strong>　<code>@click.command</code> 装饰器源码</p>\n</blockquote>\n<pre class=\"code-rows\"><code>def command(name=None, cls=None, **attrs):\n    if cls is None:\n        cls = Command\n\n    def decorator(f):\n        cmd = _make_command(f, name, attrs, cls)\n        cmd.__doc__ = f.__doc__\n        return cmd\n\n    return decorator</code></pre>\n<p>即便是 Click 的核心装饰器 <code>@command</code>，也只有短短 8 行代码。它所做的，只是简单地把被装饰函数替换为 <code>Command</code> 实例，而所有核心逻辑都在 <code>Command</code> 实例中。</p>\n<p>这样的装饰器很浅，只做一些微小的工作，但这样的代码扩展性其实更强。</p>\n<p>因为归根结底，装饰器其实只是一类特殊的 API，一种提供服务的方式。比起把所有核心逻辑都放在装饰器内，不如让装饰器里只有一层浅浅的包装层，而把更多的实现细节放在其他函数或类中。</p>\n<p>这样做之后，假如你未来需要为模块增加装饰器以外的其他 API，比如上下文管理器，就会发现自己之前写的大部分核心代码仍然可以复用，因为它们并没有和装饰器耦合。</p>\n<h2 id=\"nav_point_142\">8.3　总结</h2>\n<p>在本章中，我分享了一些与装饰器有关的知识。</p>\n<p>装饰器是 Python 为我们提供的一颗语法糖，它和“装饰器模式”没有任何关系。任何可调用对象都可以当作装饰器来使用，因此，除了最常见的用嵌套函数来实现装饰器外，我们也可以用类来实现装饰器。</p>\n<p>在装饰器包装原始函数的过程中，会产生“元数据丢失”副作用，你可以通过 <code>functools.wraps()</code> 来解决这个问题。</p>\n<p>用类实现的装饰器分为两种：“函数替换”与“实例替换”。后者可以有效地实现状态管理、追加行为功能。在实现有参数“实例替换”装饰器时，你需要定义一个额外的函数来配合装饰器类。</p>\n<p>在编写装饰器时，第三方工具包 <code>wrapt</code> 非常有用，借助它能写出更扁平的装饰器，也更容易兼容装饰函数与类方法两种场景。</p>\n<p>装饰器是一个有趣且非常独特的语言特性。虽然它不提供什么无法替代的功能，但在 API 设计领域给了我们非常大的想象空间。发挥想象力，同时保持克制，也许这就是设计出人人喜爱的装饰器的秘诀。</p>\n<p>以下是本章要点知识总结。</p>\n<p>(1) 基础与技巧</p>\n<ul>\n<li>装饰器最常见的实现方式，是利用闭包原理通过多层嵌套函数实现</li>\n<li>在实现装饰器时，请记得使用 <code>wraps()</code> 更新包装函数的元数据</li>\n<li><code>wraps()</code> 不光可以保留元数据，还能保留包装函数的额外属性</li>\n<li>利用仅限关键字参数，可以很方便地实现可选参数的装饰器</li>\n</ul>\n<p>(2) 使用类来实现装饰器</p>\n<ul>\n<li>只要是可调用的对象，都可以用作装饰器</li>\n<li>实现了 <code>__call__</code> 方法的类实例可调用</li>\n<li>基于类的装饰器分为两种：“函数替换”与“实例替换”</li>\n<li>“函数替换”装饰器与普通装饰器没什么区别，只是嵌套层级更少</li>\n<li>通过类来实现“实例替换”装饰器，在管理状态和追加行为上有天然的优势</li>\n<li>混合使用类和函数来实现装饰器，可以灵活满足各种场景</li>\n</ul>\n<p>(3) 使用 <code>wrapt</code> 模块</p>\n<ul>\n<li>使用 <code>wrapt</code> 模块可以方便地让装饰器同时兼容函数和类方法</li>\n<li>使用 <code>wrapt</code> 模块可以帮你写出结构更扁平的装饰器代码</li>\n</ul>\n<p>(4) 装饰器设计技巧</p>\n<ul>\n<li>装饰器将包装调用提前到了函数被定义的位置，它的大部分优点也源于此</li>\n<li>在编写装饰器时，请考虑你的设计是否能很好发挥装饰器的优势</li>\n<li>在某些场景下，类装饰器可以替代元类，并且代码更简单</li>\n<li>装饰器和装饰器模式截然不同，不要弄混它们</li>\n<li>装饰器里应该只有一层浅浅的包装代码，要把核心逻辑放在其他函数与类中</li>\n</ul>\n\n<br style=\"page-break-after:always\" />","comments":[{"had_liked":false,"id":391716,"user_name":"噜噜噜","can_delete":false,"product_type":"c1","uid":1984457,"ip_address":"上海","ucode":"B37C2CD3B836DB","user_header":"https://static001.geekbang.org/account/avatar/00/1e/47/c9/1bf79dfa.jpg","comment_is_top":false,"comment_ctime":1718884806,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636605,"comment_content":"很好～","like_count":0}]}