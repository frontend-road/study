{"id":607567,"title":"16｜本地缓存：用本地缓存做服务会遇到哪些坑？","content":"<p>你好，我是徐长龙。</p><p>这一章我们来学习如何应对读多写多的系统。微博Feed、在线游戏、IM、在线课堂、直播都属于读多写多的系统，这类系统里的很多技术都属于行业天花板级别，毕竟线上稍有点问题，都极其影响用户体验。</p><p>说到读多写多不得不提缓存，因为目前只有缓存才能够提供大流量的数据服务，而常见的缓存架构，基本都会使用集中式缓存方式来对外提供服务。</p><p>但是，集中缓存在<strong>读多写多</strong>的场景中有上限，当流量达到一定程度，集中式缓存和无状态服务的大量网络损耗会越来越严重，这导致高并发读写场景下，缓存成本高昂且不稳定。</p><p>为了降低成本、节省资源，我们会在业务服务层再增加一层缓存，放弃强一致性，保持最终一致性，以此来降低核心缓存层的读写压力。</p><h2>虚拟内存和缺页中断</h2><p>想做好业务层缓存，我们需要先了解一下操作系统底层是如何管理内存的。</p><p>对照后面这段C++代码，你可以暂停思考一下，这个程序如果在环境不变的条件下启动多次，变量内存地址输出是什么样的？</p><pre><code class=\"language-c++\">int testvar = 0;\nint main(int argc, char const *argv[])\n{\n  testvar += 1;\n  sleep(10);\n  printf(\"address: %x, value: %d\\n\", &amp;testvar, testvar );\n  return 0;\n}\n</code></pre><!-- [[[read_end]]] --><p>答案可能出乎你的意料，试验一下，你就会发现变量内存地址输出一直是固定的，这证明了程序见到的内存是独立的。如果我们的服务访问的是物理内存，就不会发生这种情况。</p><p>为什么结果是这样呢？这就要说到Linux的内存管理方式，它用虚拟内存的方式管理内存，因此每个运行的进程都有自己的虚拟内存空间。</p><p>回过头来看，我们对外提供缓存数据服务时，如果想提供更高效的并发读写服务，就需要把数据放在本地内存中，一般会实现为一个进程内的多个线程来共享缓存数据。不过在这个过程中，我们还会遇到缺页问题，我们一起来看看。</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/a6/4c9ce299afe1f12501eacbb6012758a6.jpg?wh=1920x1088\" alt=\"图片\" title=\"虚拟内存及 page fault\"></p><p>如上图所示，我们的服务在Linux申请的内存不会立刻从物理内存划分出来。系统数据修改时，才会发现物理内存没有分配，此时CPU会产生缺页中断，操作系统才会以page为单位把物理内存分配给程序。系统这么设计，主要是为了降低系统的内存碎片，并且减少内存的浪费。</p><p>不过系统分配的页很小，一般是4KB，如果我们一次需要把1G的数据插入到内存中，写入数据到这块内存时就会频繁触发缺页中断，导致程序响应缓慢、服务状态不稳定的问题。</p><p>所以，当我们确认需要高并发读写内存时，都会先申请一大块内存并填0，然后再使用，这样可以减少数据插入时产生的大量缺页中断。我额外补充一个注意事项，这种申请大内存并填0的操作很慢，尽量在服务启动时去做。</p><p>前面说的操作虽然立竿见影，但资源紧张的时候还会有问题。现实中<strong>很多服务刚启动就会申请几G的内存，但是实际运行过程中活跃使用的内存不到10%，Linux会根据统计将我们长时间不访问的数据从内存里挪走，留出空间给其他活跃的内存使用，这个操作叫Swap Out</strong>。</p><p>为了降低 <strong>Swap Out</strong> 的概率，就需要给内存缓存服务提供充足的内存空间和系统资源，让它在一个相对专用的系统空间对外提供服务。</p><p>但我们都知道内存空间是有限的，所以需要精心规划内存中的数据量，确认这些数据会被频繁访问。我们还需要控制缓存在系统中的占用量，因为系统资源紧张时OOM会优先杀掉资源占用多的服务，同时为了防止内存浪费，我们需要通过LRU淘汰掉一些不频繁访问的数据，这样才能保证资源不被浪费。</p><p>即便这样做还可能存在漏洞，因为业务情况是无法预测的。所以建议对内存做定期扫描续热，以此预防流量突增时触发大量缺页中断导致服务卡顿、最终宕机的情况。</p><h2>程序容器锁粒度</h2><p>除了保证内存不放冷数据外，我们放在内存中的公共数据也需要加锁，如果不做互斥锁，就会出现多线程修改不一致的问题。</p><p>如果读写频繁，我们常常会对相应的struct增加单条数据锁或map锁。但你要注意，锁粒度太大会影响到我们的服务性能。</p><p>因为实际情况往往会和我们预计有一些差异，建议你在具体使用时，在本地多压测测试一下。就像我之前用C++ 11写过一些内存服务，就遇到过读写锁性能反而比不上自旋互斥锁，还有压缩传输效率不如不压缩效率高的情况。</p><p>那么我们再看一下业务缓存常见的加锁方式。</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/5b/e2aa69de7ddb2d1518421e62a777405b.jpg?wh=1920x1088\" alt=\"图片\" title=\"多线程修改一个数据，配一个锁\"></p><p>为了减少锁冲突，我常用的方式是将一个放大量数据的经常修改的map拆分成256份甚至更多的分片，每个分片会有一个互斥锁，以此方式减少锁冲突，提高并发读写能力。</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/8e/b21b7bb457b274eb9c7b5480c5c7628e.jpg?wh=3489x2260\" alt=\"\" title=\"多线程 多个分块锁\"></p><p>除此之外还有一种方式，就是将我们的修改、读取等变动只通过一个线程去执行，这样能够减少锁冲突加强执行效率，我们常用的Redis就是使用类似的方式去实现的，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/5b/e5/5b419ba2020228edb12e2dccf82869e5.jpg?wh=1920x1088\" alt=\"图片\" title=\"单线程更新，配合 sync.map\"></p><p>如果我们接受半小时或一小时全量更新一次，可以制作map，通过替换方式实现数据更新。</p><p>具体的做法是用两个指针分别指向两个map，一个map用于对外服务，当拿到更新数据离线包时，另一个指针指向的map会加载离线全量数据。加载完毕后，两个map指针指向互换，以此实现数据的批量更新。这样实现的缓存我们可以不加互斥锁，性能会有很大的提升。</p><p><img src=\"https://static001.geekbang.org/resource/image/5d/0a/5d624742723a4c9cba4c41f09eb7530a.jpg?wh=1920x1088\" alt=\"图片\" title=\"第一步，更新内存 1，并切换阅读指针\"></p><p><img src=\"https://static001.geekbang.org/resource/image/7c/56/7cab748543fedc7f17ed4f565db32756.jpg?wh=1920x1088\" alt=\"图片\" title=\"切换后效果，对外提供 memory 1 的数据，开始更新内存 2\"></p><p>当然行业也存在一些无锁的黑科技，这些方法都可以减少我们的锁争抢，比如atomic、Go的sync.Map、sync.Pool、Java的volidate。感兴趣的话，你可以找自己在用的语言查一下相关知识。除此之外，无锁实现可以看看MySQL InnoDB的MVCC。</p><h2>GC和数据使用类型</h2><p>当做缓存时，我们的数据struct直接放到map一类的容器中就很完美了吗？事实上我<strong>并不建议这么做</strong>。这个回答可能有些颠覆你的认知，但看完后面的分析你就明白了。</p><p>当我们将十万条数据甚至更多的数据放到缓存中时，编程语言的GC会定期扫描这些对象，去判断这些对象是否能够回收。这个机制导致map中的对象越多，服务GC的速度就会越慢。</p><p>因此，很多语言为了能够将业务缓存数据放到内存中，做了很多特殊的优化，这也是为什么高级语言做缓存服务时，很少将数据对象放到一个大map中。</p><p>这里我以Go语言为例带你看看。为了减少扫描对象个数，Go对map做了一个特殊标记，如果map中没有指针，则GC不会遍历它保存的对象。</p><p>为了方便理解举个例子：我们不再用map保存具体的对象数据，只是使用简单的结构作为查询索引，如使用map[int]int，其中key是string通过hash算法转成的int，value保存的内容是数据所在的offset和长度。</p><p>对数据做了<strong>序列化后</strong>，我们会把它保存在一个很长的byte数组中，通过这个方式缓存数据，但是这个实现很难删除修改数据，所以删除的一般只是map索引记录。</p><p><img src=\"https://static001.geekbang.org/resource/image/21/9f/21349be2e6268c7c1cb8668e124af19f.jpg?wh=1920x1088\" alt=\"图片\" title=\"索引、位置映射和保存在数组的数据关系\"></p><p>这也导致了我们做缓存时，要根据缓存的数据特点分情况处理。</p><p>如果我们的数据量少，且特点是读多写多（意味着会频繁更改），那么将它的struct放到map中对外服务更合理；如果我们的数据量大，且特点是读多写少，那么把数据放到一个连续内存中，通过offset和length访问会更合适。</p><p>分析了GC的问题之后，相信你已经明白了很多高级语言宁可将数据放到公共的基础服务中，也不在本地做缓存的原因。</p><p>如果你仍旧想这么做，这里我推荐一个有趣的项目 <a href=\"https://github.com/heiyeluren/xmm\">XMM</a> 供你参考，它是一个能躲避Golang GC的内存管理组件。事实上，其他语言也存在类似的组件，你可以自己探索一下。</p><h2>内存对齐</h2><p>前面提到，数据放到一块虚拟地址连续的大内存中，通过offse和length来访问不能修改的问题，这个方式其实还有一些提高的空间。</p><p>在讲优化方案前，我们需要先了解一下内存对齐，在计算机中很多语言都很关注这一点，究其原因，内存对齐后有很多好处，比如我们的数组内所有数据长度一致的话，就可以快速对其定位。</p><p>举个例子，如果我想快速找到数组中第6个对象，可以用如下方式来实现：</p><p>sizeof(obj) * index =&gt; offset</p><p>使用这个方式，要求我们的 <strong>struct必须是定长的，并且长度要按2的次方倍数做对齐</strong>。另外，也可以把变长的字段，用指针指向另外一个内存空间</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/da/d3649e5bc39100dc8e37fa7e9caa50da.jpg?wh=1920x669\" alt=\"图片\"></p><p>通过这个方式，我们可以通过索引直接找到对象在内存中的位置，并且它的长度是固定的，无需记录length，只需要根据index即可找到数据。</p><p>这么设计也可以让我们在读取内存数据时，能快速拿到数据所在的整块内存页，然后就能从内存快速查找要读取索引的数据，无需读取多个内存页，毕竟内存也属于外存，访问次数少一些更有效率。这种按页访问内存的方式，不但可以快速访问，还更容易被CPU L1、L2 缓存命中。</p><h2>SLAB内存管理</h2><p>除了以上的方式外，你可能好奇过，基础内存服务是怎么管理内存的。我们来看后面这个设计。</p><p><img src=\"https://static001.geekbang.org/resource/image/76/0c/7689a2654b89f90d1e9de53bd7ed340c.jpg?wh=1920x1244\" alt=\"图片\"></p><p><strong>如上图，主流语言为了减少系统内存碎片，提高内存分配的效率，基本都实现了类似Memcache的伙伴算法内存管理，甚至高级语言的一些内存管理库也是通过这个方式实现的。</strong></p><p>我举个例子，Redis里可以选择用jmalloc减少内存碎片，我们来看看jmalloc的实现原理。</p><p>jmalloc会一次性申请一大块儿内存，然后将其拆分成多个组，为了适应我们的内存使用需要，会把每组切分为相同的chunk size，而每组的大小会逐渐递增，如第一组都是32byte，第二组都是64byte。</p><p>需要存放数据的时候，jmalloc会查找空闲块列表，分配给调用方，如果想放入的数据没找到相同大小的空闲数据块，就会分配容量更大的块。虽然这么做有些浪费内存，但可以大幅度减少内存的碎片，提高内存利用率。</p><p>很多高级语言也使用了这种实现方式，当本地内存不够用的时候，我们的程序会再次申请一大块儿内存用来继续服务。这意味着，除非我们把服务重启，不然即便我们在业务代码里即使释放了临时申请的内存，编程语言也不会真正释放内存。所以，如果我们使用时遇到临时的大内存申请，务必想好是否值得这样做。</p><h2>总结</h2><p>学完这节课，你应该明白，为什么行业中，我们都在尽力避免业务服务缓存应对高并发读写的情况了。</p><p>因为我们实现这类服务时，不但要保证当前服务能够应对高并发的网络请求，还要减少内部修改和读取导致的锁争抢，并且要关注高级语言GC原理、内存碎片、缺页等多种因素，同时我们还要操心数据的更新、一致性以及内存占用刷新等问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/d0/23/d0315cc3ce6ee08e86bb2eca9f8d1e23.jpg?wh=1920x1244\" alt=\"图片\"></p><p>即便特殊情况下我们用上了业务层缓存的方式，在业务稳定后，几乎所有人都在尝试把这类服务做降级，改成单纯的<strong>读多写少</strong>或<strong>写多读少</strong>的服务。</p><p>更常见的情况是，如果不得不做，我们还可以考虑在业务服务器上启动一个小的Redis分片去应对线上压力。当然这种方式，我们同样需要考虑清楚如何做数据同步。</p><p>除了今天讲的踩坑点，内存对外服务的过程中，我们还会碰到一些其他问题，我们下节课再展开。</p><h2>思考题</h2><p>使用了大数组来保存数据，用offset+length实现的数据缓存，有什么办法修改数据？</p><p>欢迎你在评论区与我交流讨论，我们下节课见！</p>","comments":[{"had_liked":false,"id":368946,"user_name":"杜杜杜的杜","can_delete":false,"product_type":"c1","uid":2423536,"ip_address":"浙江","ucode":"B2AB226AEF1F5E","user_header":"https://static001.geekbang.org/account/avatar/00/24/fa/f0/7af35520.jpg","comment_is_top":true,"comment_ctime":1676943438,"is_pvip":false,"replies":[{"id":134373,"content":"你好，感觉文中举的例子让你误会了，但是不确定具体，所以我再补充过一下。\n\nJava程序启动后会申请一大块内存，但是这个内存是虚拟的内存，只有实际使用时，linux才会分配给他真实的物理内存，访问没分配内存的虚拟内存空间时内核会产生缺页中断分配真实物理内存。而在应用过程中，如果我们把业务数据放到服务内，如果内存使用过多可能会碰到后面这几种情况。\n\n1.高级语言的GC会定期扫描这些对象，确定哪些可以回收来节省内存，导致服务周期卡顿。\n\n2.内存申请过多，导致系统资源不够，这时linux会偷偷把你不怎么用的内存区域落磁盘，等你用的时候产生缺页再给从磁盘放回来给程序用。\n\n3.有的高级语言底层使用了slab方式，而不是linux管理的内存，这相比malloc方式会高效一些，因为malloc很慢并且如果申请1M以上内存，会请求多次导致卡顿。如果频繁malloc free服务，会从内核卡住，影响响应速度。同时，因为内存碎片会增多，就会导致内存 malloc 操作 分配越来越慢，最后整体表现就是服务体验很差。\n\n综合上面的情况，我们要注意的是，使用内存缓存数据时，要计算好容量，控制好存放的对象类型和数量，尽量避免GC扫描，避免内存使用过多被linux置换。不知道是否解决了你的疑问，可以在留言区继续交流。","user_name":"作者回复","user_name_real":"作者","uid":1004527,"ctime":1676973909,"ip_address":"北京","comment_id":368946,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"缺页中断：\nJava程序，向本地缓存插入大数据量时，会频繁触发缺页中断，导致不断申请内存。过程中会占用资源(包括等待申请内存时间)，导致服务器响应可能缓慢，甚至系统不稳定。\n\n是这个意思吗？","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606153,"discussion_content":"你好，感觉文中举的例子让你误会了，但是不确定具体，所以我再补充过一下。\n\nJava程序启动后会申请一大块内存，但是这个内存是虚拟的内存，只有实际使用时，linux才会分配给他真实的物理内存，访问没分配内存的虚拟内存空间时内核会产生缺页中断分配真实物理内存。而在应用过程中，如果我们把业务数据放到服务内，如果内存使用过多可能会碰到后面这几种情况。\n\n1.高级语言的GC会定期扫描这些对象，确定哪些可以回收来节省内存，导致服务周期卡顿。\n\n2.内存申请过多，导致系统资源不够，这时linux会偷偷把你不怎么用的内存区域落磁盘，等你用的时候产生缺页再给从磁盘放回来给程序用。\n\n3.有的高级语言底层使用了slab方式，而不是linux管理的内存，这相比malloc方式会高效一些，因为malloc很慢并且如果申请1M以上内存，会请求多次导致卡顿。如果频繁malloc free服务，会从内核卡住，影响响应速度。同时，因为内存碎片会增多，就会导致内存 malloc 操作 分配越来越慢，最后整体表现就是服务体验很差。\n\n综合上面的情况，我们要注意的是，使用内存缓存数据时，要计算好容量，控制好存放的对象类型和数量，尽量避免GC扫描，避免内存使用过多被linux置换。不知道是否解决了你的疑问，可以在留言区继续交流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676973909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368618,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"广东","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1676506509,"is_pvip":true,"replies":[{"id":134255,"content":"核心是读写并发过高，后来做了相应的调整，当明星出事的时候紧急扩充服务器以及数据缓存层来应对","user_name":"作者回复","user_name_real":"编辑","uid":1004527,"ctime":1676511462,"ip_address":"北京","comment_id":368618,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"微博长年出现挂是什么原因啊？读可以本地缓存，写需要通过热key发现来异步写，是聚合的地方挂吗？","like_count":1,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604932,"discussion_content":"核心是读写并发过高，后来做了相应的调整，当明星出事的时候紧急扩充服务器以及数据缓存层来应对","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1676511462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654702,"discussion_content":"突发极热流量应对 确实难度很大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733278061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010680,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6b/f8/b4da7936.jpg","nickname":"大魔王汪汪","note":"","ucode":"4B205CB52FC95F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637339,"discussion_content":"根本原因是高并发时候资源不够，服务挂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708394169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363381,"user_name":"John","can_delete":false,"product_type":"c1","uid":1036468,"ip_address":"北京","ucode":"449164FE4255CB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d0/b4/a6c27fd0.jpg","comment_is_top":false,"comment_ctime":1669612711,"is_pvip":false,"replies":[{"id":132101,"content":"你好，John，这个方式很有趣，即节省空间又方便，并且如果配合slab方式更好","user_name":"作者回复","user_name_real":"编辑","uid":1004527,"ctime":1669624392,"ip_address":"北京","comment_id":363381,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"如果用大数组管理缓存，应该需要用bitmap或链表来管理哪些地方已使用，哪些未使用。如果修改的数据小于原来的length，则原地更新，或大于，则从空闲列表或bitmap中找到合适的位置存放新的数据，并将原数据标识为删除。是不是可以认为就是自己实现一个简易的内存分配器？","like_count":1,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594990,"discussion_content":"你好，John，这个方式很有趣，即节省空间又方便，并且如果配合slab方式更好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669624392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378288,"user_name":"千锤百炼领悟之极限","can_delete":false,"product_type":"c1","uid":1744257,"ip_address":"广东","ucode":"224B5CF2101716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9d/81/d748b7eb.jpg","comment_is_top":false,"comment_ctime":1690024857,"is_pvip":false,"replies":[{"id":137931,"content":"没错，这里可以用两个map分别存开始和长度","user_name":"作者回复","user_name_real":"编辑","uid":1004527,"ctime":1690353453,"ip_address":"北京","comment_id":378288,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"文中提到如使用 map[int]int，其中 key 是 string 通过 hash 算法转成的 int，value 保存的内容是数据所在的 offset 和长度。\n\n这里map的value是个数组吧，因为要存offset与length，例如：map[int][2]int","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624237,"discussion_content":"没错，这里可以用两个map分别存开始和长度","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690353453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2037522,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/YbUxEV3741vKZAiasOXggWucQbmicJwIjg3HDE58oyibYXbSop9QQFqZ7X6OhynDoo6rDHwzK8njSeJjN9hx3pJXg/132","nickname":"黄堃健","note":"","ucode":"B4AD5250A41B3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637493,"discussion_content":"老师， 文中提到如使用 map[int]int，其中 key 是 string 通过 hash 算法转成的 int，这样做，不同string通过hash转换  成相同的int，这种场景怎么处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708566396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366434,"user_name":"ARM","can_delete":false,"product_type":"c1","uid":2314165,"ip_address":"河南","ucode":"788FD0DBD39B94","user_header":"https://static001.geekbang.org/account/avatar/00/23/4f/b5/bd6140a5.jpg","comment_is_top":false,"comment_ctime":1673777766,"is_pvip":false,"replies":[{"id":133731,"content":"你好，ARM，感觉还需要补充下信息～","user_name":"作者回复","user_name_real":"编辑","uid":1004527,"ctime":1674871995,"ip_address":"北京","comment_id":366434,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"比如IM场景，A发给B消息，用户A输入后，直接前端显示在页面不管是否落库（用户无感知提升体验感），然后前端异步落库。然后再查询数据库 A发送给B的信息，显示出来。将A-B这两个字段设置为联合索引","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600765,"discussion_content":"你好，ARM，感觉还需要补充下信息～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1674871995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364584,"user_name":"徐石头","can_delete":false,"product_type":"c1","uid":1035885,"ip_address":"内蒙古","ucode":"D8FA8A64FB7E33","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ce/6d/530df0dd.jpg","comment_is_top":false,"comment_ctime":1671161621,"is_pvip":true,"replies":[{"id":132523,"content":"你好，不同语言规避GC方式不同，可以先找下相关语言用的人多的组件加入大量数据，压测观测gc性能监控。redis虽然浪费一些但是比自己实现快一些，掏钱就可用，笑，等量级上来后再优化来得及，如果量很大了，本地缓存也行，就是一致性很难","user_name":"作者回复","user_name_real":"编辑","uid":1004527,"ctime":1671169789,"ip_address":"内蒙古","comment_id":364584,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"所以不推荐在业务层内以map的形式做一级缓存？最近在优化产品Redis缓存的内存占用，考虑在redis前面增加一级缓存，有没有比较好的解决方案吗？或者关于优化Redis内存占用相关的解决方案","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596641,"discussion_content":"你好，不同语言规避GC方式不同，可以先找下相关语言用的人多的组件加入大量数据，压测观测gc性能监控。redis虽然浪费一些但是比自己实现快一些，掏钱就可用，笑，等量级上来后再优化来得及，如果量很大了，本地缓存也行，就是一致性很难","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671169789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"内蒙古","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1666025,"avatar":"https://static001.geekbang.org/account/avatar/00/19/6b/e9/7620ae7e.jpg","nickname":"雨落～紫竹","note":"","ucode":"33CED2F34E708F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":602224,"discussion_content":"内存组件 比如guava  caffeine","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675680686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2314165,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4f/b5/bd6140a5.jpg","nickname":"ARM","note":"","ucode":"788FD0DBD39B94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599771,"discussion_content":"如果不是那种高并发写的场景，加一层本地缓存也没问题啊，谷歌的guava包就可以支持啊。数据变更的时候，顺道清除这个本地缓存key就可以，业务读取再加载进去。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673779173,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363913,"user_name":"Geek_2c6ea9","can_delete":false,"product_type":"c1","uid":2309622,"ip_address":"北京","ucode":"5B36C3250705D1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/KR3mVqvUy9VaUO1qFmib85WveR0wvMVzAdztwDFYtUc9iagKmRjRibmIKnS8XVvf6CkXo9SssUaiaQ1YNFdFuyUMuA/132","comment_is_top":false,"comment_ctime":1670335903,"is_pvip":false,"replies":[{"id":132283,"content":"你好，很高兴你关注这里，对于临时缓存一般这里放的数据都需要提前计算好增长量，并且搭配LRU，最后要设计好数据分片规则才行。对于业务缓存最好是放不经常更新的数据。现在这类服务的业务服务器都会配上16g以上内存，相对会好一些","user_name":"作者回复","user_name_real":"编辑","uid":1004527,"ctime":1670373684,"ip_address":"北京","comment_id":363913,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"缓存的容量怎么设置比较好，一直往里面存会不会爆掉啊。","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595784,"discussion_content":"你好，很高兴你关注这里，对于临时缓存一般这里放的数据都需要提前计算好增长量，并且搭配LRU，最后要设计好数据分片规则才行。对于业务缓存最好是放不经常更新的数据。现在这类服务的业务服务器都会配上16g以上内存，相对会好一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1670373684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363564,"user_name":"第一装甲集群司令克莱斯特","can_delete":false,"product_type":"c1","uid":1265707,"ip_address":"北京","ucode":"4E8FBB23AD860B","user_header":"https://static001.geekbang.org/account/avatar/00/13/50/2b/2344cdaa.jpg","comment_is_top":false,"comment_ctime":1669814048,"is_pvip":false,"replies":[{"id":132132,"content":"你好，克莱斯特，这两个都很有趣～我本意是提及volidate","user_name":"作者回复","user_name_real":"编辑","uid":1004527,"ctime":1669817978,"ip_address":"北京","comment_id":363564,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100309001,"comment_content":"Java 的 volidate ，还是volatile?","like_count":0,"discussions":[{"author":{"id":1004527,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/53/ef/5cdaa18b.jpg","nickname":"thinkpc","note":"","ucode":"0EBF75B8707584","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":595204,"discussion_content":"你好，克莱斯特，这两个都很有趣～我本意是提及volidate","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1669817978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}