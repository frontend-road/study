{"id":514479,"title":"10 | 代码现代化 ：代码的分层重构","content":"<p>你好，我是姚琪琳。</p><p>上节课，我带你学习了重构遗留代码的倚天剑和屠龙刀，也就是<strong>拆分阶段</strong>和<strong>方法对象。</strong>面对遗留代码，它们是披荆斩棘的利器。</p><p>不过，单块逻辑的代码重构好了之后，我们还要迎接新的挑战。今天我们就来看看如何重构整体的代码，也就是如何对代码分层。</p><h2>遗留系统中常见的模式</h2><p>我还记得大学时做的编程作业，用VB6做一个学校图书馆的借书系统。当时的做法十分“朴素”，在点击“借阅”按钮的事件处理器中，我直接读取借书列表中的书籍ID，然后连接数据库，执行一条update语句，把这些书籍的借阅者字段改成当前的学生ID。</p><p>后来，我看到了Eric Evans的《领域驱动设计》这本书，才发现这种做法就是书中介绍的<strong>Smart UI模式</strong>。它虽然简单好理解，但归根结底还是一种面向过程的编程思想。一旦逻辑变得更复杂，这种模式的问题就会凸显出来。</p><p>举个最简单的例子，比如借书前需要校验学生的类型，本科生最多可以借3本，而研究生最多可以借10本。如果本科生借阅了5本书，在点击按钮的时候就会弹出错误消息。我们用伪代码来表示就是：</p><pre><code class=\"language-java\">var bookCount = bookDataTable.count\nvar studentType = DB.query(\"SELECT TYPE FROM STUDENTS WHERE ID = \" + studentId)\nif (studentType = \"本科生\" &amp;&amp; bookCount &gt; 3)\n  MessageBox.error(\"本科生一次最多借阅3本图书\")\nif (studentType = \"研究生\" &amp;&amp; bookCount &gt; 10)\n  MessageBox.error(\"研究生一次最多借阅10本图书\")\n\nfor(var book in bookDataTable.values)\n  DB.update(\"UPDATE BOOKS SET BORROWER_ID = \" + studentId + \" WHERE BOOK_ID = \" + book.id)\n</code></pre><!-- [[[read_end]]] --><p>也许只是添加这几行代码，你并不觉是什么大问题，但紧接着教师的借阅数量也需要校验，讲师和教授的借阅数量也会有不同的限制。当逻辑越来越复杂，这种过程式的代码就只能向一个地方堆代码。即使可以抽一些函数出来，也只能是杯水车薪。</p><p>其实还有更严重的问题：由于将界面展示、业务逻辑、数据库访问都放在一个文件中，<strong>发散式变化</strong>的坏味道十分严重。调整界面布局要改这个文件，修改业务逻辑要改这个文件，甚至修改表名、列名也要修改这个文件。</p><p>除了早期的桌面客户端应用，还有在JSP和ASP中直接写业务逻辑并访问数据库的，也属于Smart UI。除此之外，Martin Fowler在《企业应用架构模式》还提出了<strong>事务脚本（Transaction Script）模式</strong>。该模式分离了用户界面和业务逻辑，但仍然还是按数据的方式去组织业务，没有建立对象模型。</p><p>为了改善这种状况，人们开始重构这种模式。将界面逻辑、业务逻辑和数据库访问分离开来，形成了UI、Service、Dao这样的三层结构。</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/c3/d39636411e3263c192453a7c5495c8c3.jpg?wh=1920x1256\" alt=\"图片\"></p><p>上面的代码也就变成了下面这样（让我们从伪代码切换回Java）。</p><pre><code class=\"language-java\">// UI层\nBookService bookService = new BookService();\nbookService.borrowBook(userData, bookDataList);\n\n// Service层\nif (\"教师\".equals(userData.getType())) {\n  if (\"讲师\".equals(userData.getLevel()) || \"助教\".equals(userData.getLevel())) {\n    if (bookDataList.count() &gt; 20) {\n      throw new BookBorrowException(\"讲师和助教一次最多借阅20本图书\");\n    }\n  }\n  else if (\"教授\".equals(userData.getLevel()) || \"副教授\".equals(userData.getLevel())) {\n    if (bookDataList.count() &gt; 50) {\n      throw new BookBorrowException(\"教授和副教授一次最多借阅50本图书\");\n    }\n  }\n}\nelse if (\"学生\".equals(userData.getType())) {\n  if (\"本科生\".equals(userData.getLevel())) {\n    if (bookDataList.count() &gt; 3) {\n      throw new BookBorrowException(\"本科生一次最多借阅3本图书\");\n    }\n  }\n  else if (\"研究生\".equals(userData.getLevel())) {\n    if (bookDataList.count() &gt; 10) {\n      throw new BookBorrowException(\"研究生一次最多借阅50本图书\");\n    }\n  }\n}\nBookDao bookDao = new BookDao();\nbookDao.borrowBook(userData.getUserId(), bookDataList)\n\n// Dao层\nfor(var book in bookDataList)\n  DB.update(\"UPDATE BOOKS SET BORROWER_ID = \" + userId + \" WHERE BOOK_ID = \" + book.getId())\n</code></pre><p>感觉是不是跟你平时编写的代码十分类似？</p><p>然而在我看来，这样的分层仍然是过程式的，和事务脚本相比，并没有本质区别。它虽然在Service层向Dao层传递数据时使用了对象，但这种不含任何行为的<strong>贫血模型</strong>也只是起了数据传递的作用。</p><p>而且，像代码中的UserData和BookData所定义的位置往往都是很随意的，有时定义在UI层，有时定义在Service层，有时定义在Dao层。上面图中所画的箭头只是代表了数据流动的方向，而不是对象依赖的方向。</p><p>这种模式最大的问题在于，当逻辑变得复杂时，服务层的代码会变得越来越臃肿，不同的服务之间也很难相互调用和复用逻辑，每一个服务类都将变成上帝类（God Class）。</p><h2>领域模型</h2><p>随着面向对象编程范式的流行，越来越多的人倾向于<strong>用对象为要解决的问题建立模型（Domain Model）</strong>，<strong>用对象来描述问题中的不同元素</strong>。<strong>元素中所有的数据和行为都将在对象中有所体现</strong>。也就是说，我们不再用过程来控制逻辑，而是将逻辑分别放入不同的对象中。</p><p>对于上面借书的例子，如果我们把各种判断借书数量是否合规的逻辑，放到不同的User对象中去，将书籍借阅的逻辑，也就是设置书籍借阅状态的逻辑，放到Book中去，就会得到这样的代码：</p><pre><code class=\"language-java\">public abstract class User {\n    public abstract void borrow(Book[] books);\n}\n\npublic class UndergraduateStudent extends User {\n    @Override\n    public void borrow(Book[] books) {\n        if (books.length &gt; 3) {\n            throw new BookBorrowException(\"本科生一次最多借阅3本图书\");\n        }\n        for(Book book : books) {\n          book.lendTo(this);\n        }\n    }\n}\n\npublic class Book {\n    public void lendTo(User user) {\n        status = BookStatus.LEND_OUT;\n        borrowerId = user.getId();\n    }\n}\n</code></pre><p>可以看到，这段代码充分利用了面向对象继承和封装的优势，分解了原来的复杂逻辑，将其分散到不同的对象中去。</p><p>乍一看你也许有点困惑，因为逻辑十分分散，而且想看懂一个业务场景，要在不同的对象之间来回跳转，远不如过程式代码那样直观。而且还会有各种纠结的地方，比如到底是“人借阅书”，还是“书借给人”。</p><p>但这其实就是面向对象的优雅之处，它对客观世界进行了建模，但是并不需要完全去照搬客观世界。</p><p>“人借阅书”还是“书借给人”并不重要，重要的是如何更顺畅地编写代码。比如在我的例子中，既有“人借阅书”，又有“书借给人”。“人借阅书”是为了解决在借阅时的校验问题，“书借给人”是为了将人的信息标记在书上。</p><p>在了解了领域模型模式后，你一定迫不及待地想把事务脚本模式的代码都重构成领域模型了吧？这个重构过程中，你可能分辨不出自己的代码到底属于哪种模式。我可以教你一个小技巧，就是看你要获取一个值的时候，是<strong>从对象中获取</strong>，还是<strong>直接从数据库中查询</strong>。</p><p>比如你想查询一本书是否被借出了，你查询数据库BOOKS表，如果BORROWER_ID这个字段为空，就返回1，那这就是事务脚本模式：</p><pre><code class=\"language-java\">String sql = \"SELECT COUNT(*) FROM BOOKS WHERE BOOK_ID = :bookId AND BORROWER_ID IS NULL\";\"\n\nboolean isBorrowed = DB.query(sql) == 0;\n</code></pre><p>这种处理方式把数据和模型割裂开了，而且IS NULL和==0大概率会把人搞晕，认知负载非常高。</p><p>如果你用SQL去获取一个模型，然后在代码中判断getBorrowerId方法的返回值是否为空，那就是贫血模型模式：</p><pre><code class=\"language-java\">String sql = \"SELECT * FROM BOOKS WHERE BOOK_ID = :bookId\";\nBook book = DB.query(sql);\nif (book.getBorrowerId() != null) { }\n</code></pre><p>这种处理方式把模型当做数据的载体，比单纯的事务脚本要好很多。但是所有判断逻辑都会落在客户端代码处。</p><p>如果你用SQL去获取一个模型，然后调用模型的isBorrowed方法来判断书籍是否被借出，就是领域模型模式：</p><pre><code class=\"language-java\">String sql = \"SELECT * FROM BOOKS WHERE BOOK_ID = :bookId\";\nBook book = DB.query(sql);\nif (book.isBorrowed()) { }\n</code></pre><p>这种处理方式把模型当做数据和行为的载体，把行为封装在了领域模型内部。</p><p><strong>领域模型最重要的一点是，要随着业务的变化而不断演进</strong>。尽管上面的模型对于大学编程课的作业，可能还说得过去，但真实的借阅场景显然更复杂。</p><p>比如，我希望查询一本书籍的所有借阅历史。再比如，书籍的借阅是有有效期的，当有效期快到了的时候，我希望给用户发短信提醒，有效期过了就会有相应的惩罚逻辑。当“借阅”这个名词在业务的描述中频繁出现时，就是一种要为它建模的信号了。</p><p>对于现在的模型来说，“借阅”体现在Book对象的borrowerId这个字段上。你也可以继续在Book上添加validTo这种字段来表示借阅的有效期，但显然借阅历史是无法表示出来的。对于持久化来讲，借阅历史的多条数据显然无法用书籍的一条数据来表示。</p><p>这时，我们就需要为“借阅”来单独建模了。作为书籍和用户之间的关联关系，它其实是某种<strong>关联对象（Association Object）</strong>。</p><pre><code class=\"language-java\">public class Borrowing {\n  private User user;\n  private Book book;\n}\n\npublic class User {\n  private List&lt;Borrowing&gt; borrowings;\n  public void borrow(Book[] books) {\n    for(Book book : books)\n      borrowings.add(new Borrowing(this, book));\n  }\n}\n</code></pre><p>当Borrowing这个模型建立起来后，它就可以持久化起来作为借阅的历史记录，也可以在它上面添加各种业务字段，如有效期等。</p><h2>数据映射器和仓库</h2><p>你可能注意到了，在上面的代码中，我并没有添加任何数据访问相关的逻辑。这也是领域模型模式的一个难点。<strong>领域模型中的字段需要与数据库中的表字段进行双向映射</strong>，通常来说，你可以继续使用之前的Dao来实现这种映射。</p><p>例如当一个借阅发生时，你可以：</p><pre><code class=\"language-java\">public class BorrowingDao {\n  public void insert(Borrowing borrowing) {\n    String sql = \"INSERT INTO BORROWINGS...\";\n    // 执行SQL\n  }\n}\n</code></pre><p>我们把这种方式叫做<strong>数据映射器（Data Mapper）模式</strong>，它<strong>分离了领域模型和数据库访问代码的细节，也封装了数据映射的细节</strong>。</p><p>然而不管是叫BorrowingDao还是BorrowingMapper，都暗示了它们与数据库的关系。在领域模型中，我们往往希望模型更加“干净”，希望使用的是一种和数据访问无关的组件。</p><p>另一方面，这种模式也导致表和领域对象的一一对应。在简单的业务场景下这并不是问题，但在复杂的情况下，你就无法设计出合理的模型。比如上面的例子，一个借阅就是一个Borrowing，这时你很可能放弃给User和Book建模，而直接去构建Borrowing模型，这就又回到<strong>事务脚本</strong>的老路上去了。</p><p>还有一点就是，当查询的需求变得复杂时，数据映射器就显得力不从心了。</p><p>这时我们需要使用的是<strong>仓库（Repository）模式</strong>，让它来负责协调领域模型和数据映射器。仓库模式又被翻译为资源库或者仓储，不过我更倾向于翻译为仓库。在领域驱动设计中，构造一个新的复杂的领域模型时，我们可以使用<strong>工厂（Factory）模式</strong>，那工厂“生产”出来的“产品”，自然要放到仓库中了。</p><p>Repository还有一层意思，就是“知识库”或“智囊团”。之所以把它放在数据映射器之前，就是因为它比数据映射器更懂得如何去查询领域对象，你可以基于它来设计任何你想要的查询。</p><p>仓库的接口与集合的接口十分接近，你可以向仓库中添加对象，也可以从中删除对象，就好像是在操作内存中的集合一样。而实际上，真正执行操作的，是封装在仓库内部的数据映射器。仓库不过是提供了一个更加面向对象的方式，将领域对象和数据访问隔离开来。</p><pre><code class=\"language-java\">public class UserRepository {\n  public void add(User user) { }\n  public void save(User user) { }\n  public User findById(long userId) { }\n}\n</code></pre><p>你还可以为各个仓库创建接口，定义在领域对象所在的包中。将仓库的实现类和数据映射器定义在一起，这样领域模型不依赖任何数据访问的组件，就显得十分整洁了。</p><p>在使用仓库模式时，我们只从领域对象的源头操作。我们不会去对Borrowing创建一个BorrowingRepository，而是将Borrowing放到User内部，然后通过UserRepository去获取User，进而获取到当前User所有的Borrowing。</p><p>这么做的原因是，Borrowing只是一个关联对象，并不是一个所谓的“源头”。如果用领域驱动设计中的术语来说就是，Borrowing不是一个<strong>聚合根（Aggregate Root）</strong>。你也可以将这个“源头”理解为工厂模式创建出来的产品。你要去仓库中取的是一个产品（聚合根），而不是这个产品的某个零件（关联对象）。这也是为什么在DDD中，仓库只是针对聚合根的，只有聚合根才有仓库，聚合根上的其他实体或值对象是没有仓库的。</p><p>最后，由于仓库的接口是面向集合的，复杂查询自然也不在话下。</p><p>我们在实际设计时，为了实现依赖倒置，即领域层不依赖数据访问组件，可以将仓库的接口定义在领域层，而将实现类和数据映射器定义在数据访问层。</p><h2>应用服务</h2><p>解决了业务逻辑和数据访问分离的问题，我们把目光向“前”看，看看业务逻辑之前的逻辑应该如何处理。</p><p>一个软件系统，除了业务逻辑之外，还存在一些非业务的逻辑。比如用户认证、事务、日志记录等。像前面说过的如果一个借阅快到期了就发送通知，这种对于第三方（短信通知）服务的编排，也属于这类逻辑。Martin Fowler等人把这类逻辑叫做<strong>应用逻辑（Application Logic）</strong>。你可以理解成是因为有了应用程序，才会有的逻辑。</p><p>为了把业务逻辑和应用逻辑分离，我们可以使用<strong>服务层（Service Layer）模式</strong>。它是一组在领域模型之上构建的<strong>应用服务（Application Service）</strong>，用来处理某个业务场景相关的应用逻辑。</p><p>从某种意义上，也可以认为服务层是对领域模型的封装，可以对UI层提供更加友好的接口。由于它跟业务场景一一对应，所以Bob大叔在整洁架构里，管它叫做<strong>用例（Usecase）</strong>。</p><p>对于短信通知的场景，应用服务的代码如下所示：</p><pre><code class=\"language-java\">public class BorrowingValidityService {\n  public void validate(long userId) {\n    User user = userRepository.findById(userId);\n    for(Borrowing borrowing : users.allBorowings()) {\n      if(!borrowing.isValid()) {\n        notificationService.send(new BorrowingInvalidMessage(borrowing.getBook()));\n      }\n    }\n  }\n}\n</code></pre><p>注意，判断一个借阅是否有效属于业务逻辑，而在无效时发送短信则属于应用逻辑，要在应用服务中处理。这相当于，领域模型提供了判断借阅是否有效的能力，而如何使用这种能力，是应用逻辑来决定的，不同的场景有不同的用法。</p><p>而对于借阅的应用服务，代码如下：</p><pre><code class=\"language-java\">public class BorrowService {\n  public void borrow(long userId, long[] bookIds) {\n    User user = userRepository.findById(userId);\n    Book[] books = bookRepository.findByIds(bookIds);\n    user.borrow(books);\n    userRepository.update(user);\n  }\n}\n</code></pre><p>我们在应用服务中，通过仓库获取领域模型，调用领域模型中的方法，然后再通过仓库更新领域模型。</p><p>如果你了解领域驱动设计（DDD），一定会相当熟悉应用服务、领域模型、仓库这些模式。但这些模式并不只属于DDD。在DDD诞生之前，这些模式就已经存在了，《企业应用架构模式》中甚至还提出了很多可以替代的模式。DDD只是把这些模式进行组合，形成了一套以领域模型模式为基础的最佳实践。</p><p><img src=\"https://static001.geekbang.org/resource/image/5y/4d/5yy3d4bcb26dd4yyc15dc82c7343ac4d.jpg?wh=1920x1138\" alt=\"图片\"></p><h2>小结</h2><p>我们今天从遗留系统中常见的代码样例说起，将一个事务脚本一步步重构成了DDD中常见的分层架构。这期间穿插着介绍了领域模型、数据映射器、仓库、应用服务等多种模式。不管你的系统位于这个路线的哪个阶段，你都应该有能力把它重构好。</p><p>你可能会说，你的项目业务没有这么复杂，事务脚本也能解决绝大部分应用场景。没错，事务脚本本身就是一种解决领域逻辑位置的模式，但以我的经验，这条路最终会走向混乱。</p><p>有的时候，你之所以觉得业务没那么复杂，是因为在脑子里将业务映射成了数据库表，那么写出的代码自然是事务脚本。如果你不用大脑做这一层映射，而是先将业务直接反映到领域模型中，然后再用代码去实现到数据库表的映射，往往情况就会有所好转。</p><p>你应该刻意培养自己领域建模的意识，如果没有这种意识，那么绝大多数软件对你来说，都只不过是CRUD。</p><p><a href=\"https://time.geekbang.org/column/article/514516\">下节课</a>我们开启架构现代化的挑战，从建设新城区说起，敬请期待。</p><h2>思考题</h2><p>感谢你学完了今天的内容，今天的思考题是这样的。请你把自己的项目对号入座，看看属于哪种模式，你们有没有计划去重构它们呢 ？</p><p>感谢你学完了今天的课程，欢迎你把它分享给你的同事或朋友，我们一起来重构遗留代码。</p>","neighbors":{"left":{"article_title":"09 | 代码现代化：如何将一个300行的方法重构为3行？","id":513599},"right":{"article_title":"11 | 架构现代化 ：在气泡上下文中打造你的新城区","id":514516}},"comments":[{"had_liked":false,"id":344307,"user_name":"下弦の月","can_delete":false,"product_type":"c1","uid":1909916,"ip_address":"","ucode":"57D924C51679D4","user_header":"https://static001.geekbang.org/account/avatar/00/1d/24/9c/e32fe600.jpg","comment_is_top":false,"comment_ctime":1651459794,"is_pvip":false,"replies":[{"id":"125691","content":"第二种属于事务脚本模式。Repository要么操作领域模型，要么返回领域模型，想这种既不操作也不返回的，实际上是吧Repository当Dao用了。<br><br>用第二种带来的所谓性能提升其实微乎其微，没有必要为了它而放弃面向对象。一旦你用了第二种，未来任何类似的方法都将加到Repository上，User很快就变回了贫血模型。","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1651461978,"ip_address":"","comment_id":344307,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18831328978","product_id":100111101,"comment_content":"public class UserRepository {<br>    public void add(User user) { } <br>    public void save(User user) { } <br>    public User findById(long userId) { }<br>    public boolean isBorrowedWith(long bookId) { }<br>}<br><br>UserRepository.findById(1000L).isBorrowed()<br><br>UserRepository.isBorrowedWith(1000L)<br><br>isBorrowed逻辑如果刚好是检查对象上的某个字段的值，那么第一种领域驱动的查询方式会将对象上所有不会使用到的数据都加载到内存。而第二种面相过程的方式则看起来性能更优。<br><br>这两种方式如何取舍呢？第二种查询到底属于领域模式，还是传统的事物脚本模式呢？","like_count":4,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569507,"discussion_content":"第二种属于事务脚本模式。Repository要么操作领域模型，要么返回领域模型，想这种既不操作也不返回的，实际上是吧Repository当Dao用了。\n\n用第二种带来的所谓性能提升其实微乎其微，没有必要为了它而放弃面向对象。一旦你用了第二种，未来任何类似的方法都将加到Repository上，User很快就变回了贫血模型。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1651461978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1460961,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/e1/2a498473.jpg","nickname":"李威","note":"","ucode":"3409A9390BD1FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569605,"discussion_content":"我也一直纠结这个，以后不再纠结这点想当然的性能问题了，感谢同学提出这么好的问题，感谢老师的解答！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1651494811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":349359,"user_name":"雨落～紫竹","can_delete":false,"product_type":"c1","uid":1666025,"ip_address":"","ucode":"33CED2F34E708F","user_header":"https://static001.geekbang.org/account/avatar/00/19/6b/e9/7620ae7e.jpg","comment_is_top":false,"comment_ctime":1655908560,"is_pvip":true,"replies":[{"id":"127321","content":"要给技术债建卡","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1656380714,"ip_address":"","comment_id":349359,"utype":1}],"discussion_count":1,"race_medal":1,"score":"10245843152","product_id":100111101,"comment_content":"现在一直是服务于业务 项目都是倒排期 能自己回头看代码的时间很少 难搞喔","like_count":2,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577831,"discussion_content":"要给技术债建卡","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656380714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":347271,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1015222,"ip_address":"","ucode":"27EB4A725CE14E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/b6/abdebdeb.jpg","comment_is_top":false,"comment_ctime":1653892922,"is_pvip":false,"replies":[{"id":"126648","content":"它们解决的问题是不同的，Domain Service解决的领域逻辑，Application Service解决的是应用逻辑，这两种逻辑的区别就是，领域逻辑是和具体的软件系统无关的，是线下操作的时候就有的逻辑，比如去菜市场买菜，一手交钱一手交菜，而应用逻辑是因为有了软件系统才附加上去的，比如在线支付的安全问题，数据一致性问题。<br><br>可以参考我以前写的一篇文章以及后面和同事的讨论：https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;ZkpVELpKVmmwyG9kP7wvxw","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1653960306,"ip_address":"","comment_id":347271,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10243827514","product_id":100111101,"comment_content":"老师能不能再讲讲DDD里面的 Application Service, Domain Service之间的区别啊？","like_count":3,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574296,"discussion_content":"它们解决的问题是不同的，Domain Service解决的领域逻辑，Application Service解决的是应用逻辑，这两种逻辑的区别就是，领域逻辑是和具体的软件系统无关的，是线下操作的时候就有的逻辑，比如去菜市场买菜，一手交钱一手交菜，而应用逻辑是因为有了软件系统才附加上去的，比如在线支付的安全问题，数据一致性问题。\n\n可以参考我以前写的一篇文章以及后面和同事的讨论：https://mp.weixin.qq.com/s/ZkpVELpKVmmwyG9kP7wvxw","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653960306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344519,"user_name":"favorlm","can_delete":false,"product_type":"c1","uid":1120997,"ip_address":"","ucode":"CFD52127AA6E1D","user_header":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","comment_is_top":false,"comment_ctime":1651623323,"is_pvip":false,"replies":[{"id":"125771","content":"这种查询业界一般有两种方案：<br>1. 读写分离（CQRS）。领域模型处理的是领域状态的更改，更适合写操作。读操作，特别是查询，有时候跟模型并不是十分匹配，比如管理员在查询书籍的时候，还想知道是谁借阅了这个书籍，这个模型是从Book到Borrowing的，和我们模型中User到Borrowing不匹配，如果为了查询去修改模型显然是不合适的。读写分离的思想是，在进行复杂查询时不走领域模型那一套写模型，而是重新写一套读模型，在读模型中不适用repo，而是可以直接写SQL，因为有些查询很复杂。<br>2. 仍然使用原来的模型，只是模型可能会稍作一些修改。<br><br>我建议能用原来的写模型就用写模型，实在不行的时候，也可以考虑CQRS。但CQRS的认知负载偏高，很多团队应对不了，所以要慎重。","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1651709599,"ip_address":"","comment_id":344519,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10241557915","product_id":100111101,"comment_content":"请问老师，应用中最常用的多条件查询功能，例如 ，根据书籍类型 关键字查询书籍，那么使用仓储模式，会把其他无关书籍也查询到内存里<br>这种情况下，我会被直接写sql吸引，老师认为要如何取舍呢？","like_count":2,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570204,"discussion_content":"这种查询业界一般有两种方案：\n1. 读写分离（CQRS）。领域模型处理的是领域状态的更改，更适合写操作。读操作，特别是查询，有时候跟模型并不是十分匹配，比如管理员在查询书籍的时候，还想知道是谁借阅了这个书籍，这个模型是从Book到Borrowing的，和我们模型中User到Borrowing不匹配，如果为了查询去修改模型显然是不合适的。读写分离的思想是，在进行复杂查询时不走领域模型那一套写模型，而是重新写一套读模型，在读模型中不适用repo，而是可以直接写SQL，因为有些查询很复杂。\n2. 仍然使用原来的模型，只是模型可能会稍作一些修改。\n\n我建议能用原来的写模型就用写模型，实在不行的时候，也可以考虑CQRS。但CQRS的认知负载偏高，很多团队应对不了，所以要慎重。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651709600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570396,"discussion_content":"姚琪琳老师的答案扩展阅读：郑烨老师的专栏 软件设计之美 | 02 | 分离关注点：软件设计至关重要的第一步","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651754747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1121758,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","nickname":"aoe","note":"","ucode":"1C6201EDB4E954","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570395,"discussion_content":"在老师的答案中看到了郑烨老师说的“分离关注点”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651754575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344936,"user_name":"FelixFly","can_delete":false,"product_type":"c1","uid":1160461,"ip_address":"","ucode":"1D39A7C3D0E31F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg","comment_is_top":false,"comment_ctime":1651888190,"is_pvip":true,"replies":[{"id":"125922","content":"对于用户验证、日志记录、事务、性能等非功能需求，显然是应用逻辑，这个自不用说。<br><br>对于一些难以说清楚的逻辑，我是这么区分的（不一定正确，但你可以参考）：对于传统行业来说，将原来的手动流程变为信息化流程的，都属于业务逻辑；而由信息化带来的增值服务（比如自动发短信通知），就属于应用逻辑，也就是软件系统给我们带来的那些逻辑。<br><br>对于你的场景，如果事件发送给另一个上下文，我认为发送事件是属于应用逻辑。但也有不少人认为这是领域层的某些业务触发的领域事件，是领域逻辑。","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1651996818,"ip_address":"","comment_id":344936,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5946855486","product_id":100111101,"comment_content":"老师，业务逻辑与应用逻辑如何判别？借阅到期发送通知，借阅到期理解为业务逻辑，发送通知为应用逻辑。假如说借阅成功就需要发送通知，这个发送通知作为事件发送，这个应该理解为是业务逻辑还是应用逻辑，是否也应该是应用逻辑？","like_count":1,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570929,"discussion_content":"对于用户验证、日志记录、事务、性能等非功能需求，显然是应用逻辑，这个自不用说。\n\n对于一些难以说清楚的逻辑，我是这么区分的（不一定正确，但你可以参考）：对于传统行业来说，将原来的手动流程变为信息化流程的，都属于业务逻辑；而由信息化带来的增值服务（比如自动发短信通知），就属于应用逻辑，也就是软件系统给我们带来的那些逻辑。\n\n对于你的场景，如果事件发送给另一个上下文，我认为发送事件是属于应用逻辑。但也有不少人认为这是领域层的某些业务触发的领域事件，是领域逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651996818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1160461,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b5/0d/0e65dee6.jpg","nickname":"FelixFly","note":"","ucode":"1D39A7C3D0E31F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"discussion":{"id":571631,"discussion_content":"谢谢老师提供建议参考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652319004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":570929,"ip_address":""},"score":571631,"extra":""}]}]},{"had_liked":false,"id":358896,"user_name":"花花大脸猫","can_delete":false,"product_type":"c1","uid":1117318,"ip_address":"江苏","ucode":"8ABDB3F7F4FB0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/86/8e52afb8.jpg","comment_is_top":false,"comment_ctime":1664980051,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1664980051","product_id":100111101,"comment_content":"介于第二种与第三种之间，目前对于DDD的了解还不够全面，仅停留于了解的层面，还不能用于实践，只能按照自己的想法将一部分行为控制于模型对象内部，但是具体按照DDD中什么指导来说，没有明确的概念。大部分都是基于自己的经验以及对于业务的了解程度","like_count":0},{"had_liked":false,"id":353220,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1155437,"ip_address":"广东","ucode":"0FF1C4EAF7F98A","user_header":"https://static001.geekbang.org/account/avatar/00/11/a1/6d/a4ff33bb.jpg","comment_is_top":false,"comment_ctime":1659277775,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659277775","product_id":100111101,"comment_content":"自己还是对于值对象、聚合根这块理解不到位，现在又多了业务逻辑和应用逻辑的区分哈哈哈哈","like_count":0},{"had_liked":false,"id":348813,"user_name":"hzecool","can_delete":false,"product_type":"c1","uid":1670714,"ip_address":"","ucode":"03D764F717852A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkOBhbBYIlfyo8oibrrJPjz4BJIdR2DPVxfXSOlfcg8icAKRwtibj0W1gJ1C3HT2GLs7zWQjLBdhz3A/132","comment_is_top":false,"comment_ctime":1655429919,"is_pvip":true,"replies":[{"id":"127140","content":"好问题。基础设施层并不属于领域层的下层，它不是一个层，而是属于能力提供商模式，是可以依赖任何层的。注意看最后那幅图中的箭头。","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1655880495,"ip_address":"","comment_id":348813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1655429919","product_id":100111101,"comment_content":"老师，上面提到仓库接口放在领域层，仓库接口里涉及到的输入输出参数应该有领域对象吧？<br><br>而仓库的实现类是要放在更下层的（算基础设施层吧），这样岂不是下层的实现类也要引用到上层的领域对象了，感觉不合适呀。","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577006,"discussion_content":"好问题。基础设施层并不属于领域层的下层，它不是一个层，而是属于能力提供商模式，是可以依赖任何层的。注意看最后那幅图中的箭头。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655880495,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348803,"user_name":"hzecool","can_delete":false,"product_type":"c1","uid":1670714,"ip_address":"","ucode":"03D764F717852A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkOBhbBYIlfyo8oibrrJPjz4BJIdR2DPVxfXSOlfcg8icAKRwtibj0W1gJ1C3HT2GLs7zWQjLBdhz3A/132","comment_is_top":false,"comment_ctime":1655425351,"is_pvip":true,"replies":[{"id":"127338","content":"当然可以，一个订单包含多个商品，订单的总价就依赖了商品的价格。","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1656402450,"ip_address":"","comment_id":348803,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1655425351","product_id":100111101,"comment_content":"老师，一个领域模型能直接同步调用另外一个领域模型吗？还是需要在domainService里对这两个领域模型进行集成？","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577883,"discussion_content":"当然可以，一个订单包含多个商品，订单的总价就依赖了商品的价格。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656402450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348483,"user_name":"Marx","can_delete":false,"product_type":"c1","uid":1029143,"ip_address":"","ucode":"1506FEA531551E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b4/17/0b5aad57.jpg","comment_is_top":false,"comment_ctime":1655129816,"is_pvip":true,"replies":[{"id":"127335","content":"参考这节课的数据映射器和仓库模式。更多内容可以看看《企业应用架构模式》。","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1656401467,"ip_address":"","comment_id":348483,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1655129816","product_id":100111101,"comment_content":"领域对象和数据库的映射是怎么解决的呢？","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577877,"discussion_content":"参考这节课的数据映射器和仓库模式。更多内容可以看看《企业应用架构模式》。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656401467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345259,"user_name":"飞翔","can_delete":false,"product_type":"c1","uid":1068571,"ip_address":"","ucode":"65AF6AF292DAD6","user_header":"https://static001.geekbang.org/account/avatar/00/10/4e/1b/f4b786b9.jpg","comment_is_top":false,"comment_ctime":1652161069,"is_pvip":true,"replies":[{"id":"126056","content":"没太理解你的意思。你是指业务代码用DDD的时候，类似使用zookeeper的代码怎样写到infra层？还是你的工作是写zookeeper这样的工具，应该怎么开发？<br><br>如果前者，只是在infra层封装就好了，没什么特别的。如果是后者，也是可以用DDD的，你要分析一下zookeeper这样的工具，它的核心业务是什么，并为此建立模型。","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1652197788,"ip_address":"","comment_id":345259,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652161069","product_id":100111101,"comment_content":"老师业务代码用ddd 但是写infra 框架 比如zookeeper等用什么指导呀 也用ddd嘛？","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571419,"discussion_content":"没太理解你的意思。你是指业务代码用DDD的时候，类似使用zookeeper的代码怎样写到infra层？还是你的工作是写zookeeper这样的工具，应该怎么开发？\n\n如果前者，只是在infra层封装就好了，没什么特别的。如果是后者，也是可以用DDD的，你要分析一下zookeeper这样的工具，它的核心业务是什么，并为此建立模型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652197788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344807,"user_name":"刘大明","can_delete":false,"product_type":"c1","uid":1035081,"ip_address":"","ucode":"83C063FBD9BF2B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/49/0b9ffc8e.jpg","comment_is_top":false,"comment_ctime":1651801278,"is_pvip":false,"replies":[{"id":"125843","content":"这的确是Message Chains坏味道，解决方案可以按照《重构》中说的，使用Hide Delegate手法，将委托关系隐藏到User或Flight里。但这样往往也会造成Middle Man坏味道，比如Code放到User里可能就不合适。所以还是要结合业务来综合对比。<br><br>一种可能的方案是，将Flight隐藏到User，将Code隐藏到Flight，得到一个还算OK的设计。<br><br>空指针可以在封装的get方法里去处理，不要放在客户端。","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1651806641,"ip_address":"","comment_id":344807,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651801278","product_id":100111101,"comment_content":"如果从领域中获取其他信息，是否会存在过长的消息链的坏味道呢？<br>例如这样<br>user.getTravel().getFlights().getCabin().getCode();<br>之前项目中，总是会有get值报空指针的问题。<br>请问下老师，这种代码要怎么处理？","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570535,"discussion_content":"这的确是Message Chains坏味道，解决方案可以按照《重构》中说的，使用Hide Delegate手法，将委托关系隐藏到User或Flight里。但这样往往也会造成Middle Man坏味道，比如Code放到User里可能就不合适。所以还是要结合业务来综合对比。\n\n一种可能的方案是，将Flight隐藏到User，将Code隐藏到Flight，得到一个还算OK的设计。\n\n空指针可以在封装的get方法里去处理，不要放在客户端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651806641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344762,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1651755000,"is_pvip":false,"replies":[{"id":"125846","content":"遗留系统不能一直keep，还是要让它变得更好的~","user_name":"作者回复","user_name_real":"编辑","uid":"1009237","ctime":1651807480,"ip_address":"","comment_id":344762,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651755000","product_id":100111101,"comment_content":"目前系统中已完成功能都是 CRUD<br>部分新功能我们在尝试使用 DDD<br>原来改造遗留系统还需要掌握 DDD","like_count":0,"discussions":[{"author":{"id":1009237,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/55/098b3396.jpg","nickname":"姚琪琳","note":"","ucode":"68EB7FFC9B8A6F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570541,"discussion_content":"遗留系统不能一直keep，还是要让它变得更好的~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651807480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}