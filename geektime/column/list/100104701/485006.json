{"id":485006,"title":"07｜分布式锁：所有的分布式锁都是错误的？","content":"<p>你好，我是陈现麟。</p><p>通过学习“配置中心”的内容，你已经理解了在分布式系统中，为什么需要配置中心，以及怎么去实现一个设计良好的配置中心，现在，你终于不用再为管理极客时间后端各种服务的配置而烦恼了，这是一件值得高兴的事情。</p><p>但是，在极客时间后端系统快速迭代的过程中，你发现了一个服务中的代码逻辑问题：在有些场景下，你并不想让所有的实例都一起运行，只需要一个实例运行就够了，比如在用户生日当天，给用户发的祝福短信等类似定时通知的情况。</p><p>目前同一个服务的所有实例都是对等的，只能每一个实例都运行。如果将这个服务运行的实例修改为一个，虽然能解决刚才讨论的问题，但是这个实例就变成了一个单点，会面临性能瓶颈和单点故障的风险。</p><p>这真是一个两难的问题，我们应该如何解决呢？其实，这个问题的本质在于，我们希望同一个服务的多个实例，按照一定的逻辑来进行协同，比如刚才讨论的定时任务的逻辑。<strong>那么多个实例在同一时刻只能有一个实例运行，它就是一个典型的分布式锁的场景</strong>。</p><p>所以，在本节课中，我们将从“为什么需要分布式锁”，“怎么实现分布式锁”和“分布式锁的挑战”这三个层次依次递进，和你一起来讨论分布式锁相关的内容，解决你的困惑。</p><h2>为什么需要分布式锁</h2><!-- [[[read_end]]] --><p>在探讨分布式锁之前，我们先来了解一下锁的定义：锁是操作系统的基于原语，它是用于并发控制的，能够确保在多 CPU 、多个线程的环境中，某一个时间点上，只能有一个线程进入临界区代码，从而保证临界区中操作数据的一致性。</p><p>在我们日常的研发工作中，经常会在进程内部缓存一些状态信息，通过锁可以很方便地控制、修改这些内部状态信息的临界区代码，确保不会出现多个线程同时修改临界区的资源这种情况，防止异常问题的发生。所以，锁是我们研发工作中一个非常重要的工具。</p><p>其实，我们将锁的定义推广到分布式系统的场景中，也是依然成立的。只不过锁控制的对象从一个进程内部的多个线程，变成了分布式场景下的多个进程，同时，临界区的资源也从进程内多个线程共享的资源，变成了分布式系统内部共享的中心存储上的资源。<strong>但是，锁的定义在本质上没有任何的改变，只有持有锁的线程或进程才能执行临界区的代码</strong>。</p><p>这句话如何理解呢？我们来看看这个例子。在进程内部，多个线程同时修改一个变量，可能会出现多个线程每个都写一部分，导致变量写入冲突的情况发生。那么在分布式系统中，如果多个进程，同时往一个中心存储的同一个位置写入一个文件，同样也会出现文件写入冲突的情况。所以，锁的定义在本质上没有任何的改变。</p><p>另外，我们从课程开头提到的定时任务代码的例子里，可以知道在同一时间内，临界区只能由一个进程来执行，而只有持有锁的线程或进程才能执行临界区的代码。</p><p>所以我们可以这样理解，分布式锁是一个跨进程的锁，是一个更高维度的锁。我们在进程内部碰到的临界区问题，在分布式系统中依然存在，我们需要通过分布式锁，来解决分布式系统中的多进程的临界区问题。</p><h2>怎么实现分布式锁</h2><p>我认为锁可以分为三个不同的层次，除了我们上面讨论过的，进程内部的锁和跨进程、跨机器之间的分布式锁外，还有介于它们之间的，同一台机器上的多进程之间的锁。</p><p>进程内的锁，是操作系统直接提供的，它本质上是内存中的一个整数，用不同的数值表示不同的状态，比如用 0 表示空闲状态。加锁时，判断锁是否空闲，如果空闲，修改为加锁态 1，并且返回成功，如果已经是加锁状态，则返回失败，而解锁时，则将锁状态修改为空闲状态 0。整个加锁或者解锁的过程，操作系统保证它的原子性。</p><p>对于同一台机器上的多进程之间，我们可以直接通过操作系统的锁来实现，只不过由于协调的是多个进程，需要将锁存放在所有进程都可以访问的共享内存中，所有进程通过共享内存中的锁来进行加锁和解锁。</p><p>到这里，你应该明白了，对于跨进程、跨机器之间的分布式锁的实现也是同样的思路，通过一个状态来表示加锁和解锁，只不过要让所有需要锁的服务，都能访问到状态存放的位置。在分布式系统中，一个非常自然的方案就是，将锁的状态信息存放在一个存储服务，即锁服务中，其他的服务再通过网络去访问锁服务来修改状态信息，最后进行加锁和解锁。</p><p>上面讨论的就是分布式锁最核心的原理，不过从分布式锁的场景出发，如果我们想实现一把完备的分布式锁，需要满足以下几个特性，接下来我们就一起来讨论具体怎么实现。</p><p>第一个特性就是<strong>互斥</strong>，即保证不同节点、不同线程的互斥访问，这部分知识我们在上面已经讨论过，就不再赘述了。</p><p>第二个特性是<strong>超时机制</strong>，即超时设置，防止死锁，分布式锁才有这个特性。在概述篇的第二节课“新的挑战”中，我们讨论过部分失败和异步网络的问题，而这个问题在分布式锁的场景下就会出现。因为锁服务和请求锁的服务分散在不同的机器上面，它们之间是通过网络来通信的，所以我们需要用超时机制，来避免获得锁的节点故障或者网络异常，导致它持有的锁不能归还，出现死锁的情况。</p><p>同时，我们还要考虑，持有锁的节点需要处理的临界区代码非常耗时这种问题，我们可以通过另一个线程或者协程不断延长超时时间，避免出现锁操作还没有处理完，锁就被释放，之后其他的节点再获得锁，导致锁的互斥失败这种情况。</p><p>对于超时机制，我们可以在每一次成功获得锁的时候，为锁设置一个超时时间，获得锁的节点与锁服务保持心跳，锁服务每一次收到心跳，就延长锁的超时时间，这样就可以解决上面的两个问题了。</p><p>第三个特性是<strong>完备的锁接口</strong>，即阻塞接口 Lock 和非阻塞接口 tryLock。通过阻塞 Lock 接口获取锁，如果当前锁已经被其他节点获得了，锁服务将获取锁的请求挂起，直到获得锁为止，才响应获取锁的请求；通过 tryLock 接口获取锁，如果当前锁已经被其他节点获得了，锁服务直接返回失败，不会挂起当前锁的请求。</p><p>第四个特性是<strong>可重入性</strong>，即一个节点的一个线程已经获取了锁，那么该节点持有锁的这个线程可以再次成功获取锁。我们只需在锁服务处理加锁请求的时候，记录好当前获取锁的节点 + 线程组合的唯一标识，然后在后续的加锁请求时，如果当前请求的节点 + 线程的唯一标识和当前持有锁的相同，那么就直接返回加锁成功，如果不相同，则按正常加锁流程处理。</p><p>最后是<strong>公平性</strong>，即对于 Lock 接口获取锁失败被阻塞等待的加锁请求，在锁被释放后，如果按先来后到的顺序，将锁颁发给等待时间最长的一个加锁请求，那么就是公平锁，否则就是非公平锁。锁的公平性的实现也非常简单，对于被阻塞的加锁请求，我们只要先记录好它们的顺序，在锁被释放后，按顺序颁发就可以了。</p><h2>分布式锁的挑战</h2><p>通过上面的学习，你已经学会了分布式锁的基本原理，不过在分布式系统中，由于部分失败和异步网络的问题，分布式锁会面临正确性、高可用和高性能这三点的权衡问题的挑战。所以，我们接下来讨论一下分布式锁的挑战问题，这样你在以后的工作中，就可以依据业务场景来实现合适的分布式锁了。</p><h3>分布式锁的正确性</h3><p>首先，我们一起来讨论分布式锁的正确性问题。我们在使用分布式锁的情况下，是否有办法做到，不论出现怎样的异常情况，都能保证分布式锁互斥语义的正确性呢？</p><p>那么这里，我们将从进程内的锁如何保证互斥语义的正确性出发，分析在分布式锁的场景中，部分失败和异步网络同时存在的情况下，是否能确保分布式锁互斥语义正确性的问题。</p><p>对于进程内的锁，如果一个线程持有锁，只要它不释放，就只有它能操作临界区的资源。同时，因为进程内锁的场景中，不会出现部分失败的情况，所以在它崩溃时，虽然没有去做解锁操作，但是整个进程都会崩溃，不会出现死锁的情况。</p><p>这里要说明一下，我们讨论出现死锁的情况，不包括业务逻辑层面出现死锁，因为这个与锁本身的正确性没有关系。我们讨论的是与业务逻辑无关的原因，导致的死锁问题，这个是锁自身的问题，需要锁自己来解决。</p><p>另一个方面，进程内锁的解锁操作是进程内部的函数调用，这个过程是同步的。不论是硬件或者其他方面的原因，只要发起解锁操作就一定会成功，如果出现失败的情况，整个进程或者机器都会挂掉。<strong>所以，因为整体失败和同步通信这两点，我们可以保证进程内的锁有绝对的正确性</strong>。</p><p>接下来，我们再来用同样的思路，讨论一下同一台机器上多进程锁的正确性问题。在这个情况下，由于锁是存放在多进程的共享内存中，所以进程和锁之间的通信，依然是同步的函数调用，不会出现解锁后信息丢失，导致死锁的情况。</p><p>但是，因为是多个进程来使用锁，所以会出现一个进程获取锁后崩溃，导致死锁的情况，这个就是部分失败导致的。</p><p>不过，在单机情况下，我们可以非常方便地通过操作系统提供的机制，来正确判断一个进程是否存活，比如，父进程在获得进程挂掉的信号后，可以去查看当前挂掉的进程是否持有锁，如果持有就进行释放，这可以当作是进程崩溃后清理工作的一部分。</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/38/8a9a9e7383e4e8287b3bd51a52672a38.jpg?wh=2284x1256\" alt=\"\"></p><p>讨论完进程内的锁和同一台机器上多进程锁的正确性问题后，我们还需要考虑到，在分布式锁的场景中，部分失败和异步网络这两个问题是同时存在的。如果一个进程获得了锁，但是这个进程与锁服务之间的网络出现了问题，导致无法通信，那么这个情况下，如果锁服务让它一直持有锁，就会导致死锁的发生。</p><p>一般在这种情况下，锁服务在进程加锁成功后，会设置一个超时时间，如果进程持有锁超时后，将锁再颁发给其他的进程，就会导致一把锁被两个进程持有的情况出现，使锁的互斥语义被破坏。那么出现这个问题的根本原因是超时后，锁的服务自动释放锁的操作，它是建立在这样一个假设之上的：</p><center>\n<p><strong>锁的超时时间 &gt;&gt; 获取锁的时延 + 执行临界区代码的时间 + 各种进程的暂停（比如 GC）</strong></p>\n</center><p>对于这个假设，我们暂且认为“执行临界区代码的时间 + 各种进程的暂停”是非常小的，而“获取锁的时延”在一个异步网络环境中是不确定的，它的时间从非常小，到很大，再到因为网络隔离变得无穷大都是有可能的，所以这个假设不成立。</p><p>如果你计划让客户端在“获取锁的时延”上加心跳和超时机制，这是一个聪明的想法，但是这可能会导致锁服务给客户端颁发了锁，但是因为响应超时，客户端以为自己没有获取锁的情况发生。这样一来，依然会在一定程度上，影响锁的互斥语义的正确性，并且会在某些场景下，影响系统的可用性。</p><p>对于这些问题，如果我们获得锁是为了写一个共享存储，那么有一种方案可以解决上面的问题，那就是在获得锁的时候，锁服务生成一个全局递增的版本号，在写数据的时候，需要带上版本号。共享存储在写入数据的时候，会检查版本号，如果版本号回退了，就说明当前锁的互斥语义出现了问题，那么就拒绝当前请求的写入，如果版本号相同或者增加了，就写入数据和当前操作的版本号。</p><p>但是这个方案其实只是将问题转移了，如果一个存储系统能通过版本号，来检测写入冲突，那么它已经支持多版本并发控制（MVCC）了，这本身是乐观锁的实现原理。那么我们相当于是用共享存储自身的乐观锁，来解决分布式锁在异常情况下，互斥语义失败的问题，这就和我们设计分布式锁的初衷背道而驰了。</p><p>所以，我认为对于在共享存储中写入数据等等，完全不能容忍分布式锁互斥语义失败的情况，不应该借助分布式锁从外部来实现，而是应该在共享存储内部来解决。比如，在数据库的实现中，隔离性就是专门来解决这个问题的。<strong>分布式锁的设计，应该多关注高可用与性能，以及怎么提高正确性，而不是追求绝对的正确性</strong>。</p><h3>分布式锁的权衡</h3><p>接下来，我们一起来讨论关于分布式锁的高可用、高性能与正确性之间的权衡问题。</p><p>关于正确性的问题，我们从上面的讨论中，明白了在分布式锁的场景下，没有办法保证 100% 的正确性，所以，我们要避免通过外部分布式锁，来保证需要 100% 正确性的场景，将分布式锁定位为，可以容忍非常小概率互斥语义失效场景下的锁服务。<strong>一般来说，一个分布式锁服务，它的正确性要求越高，性能可能就会越低</strong>。</p><p>对于高可用的问题，我认为它是在设计分布式锁时，需要考虑的关键因素。我们必须提供非常高的 SLA ，<strong>因为分布式锁是一个非常底层的服务组件，是整个分布式系统的基石之一</strong>，所以一般来说，越底层、越基础的组件，依赖它的功能和服务就会越多，那么它的影响面就会越大。如果它出现了故障，必然会导致整个分布式系统大面积出现故障。</p><p>对于高性能的问题，这是一个由业务场景来决定的因素，我们需要通过业务场景，来决定提供什么性能的分布式锁服务。<strong>一般来说，我们可以在成本可接受的范围内，提供性能最好的分布式锁服务</strong>。如果我们提供的分布式锁服务的性能不佳，一定要在文档甚至接口的名字中体现出来，否则如果被误用的话，可能会导致分布式锁服务故障，系统将出现非常大的事故。</p><p>基于以上三点权衡，我们就可以根据业务情况，来实现或者选择自己的分布式锁服务了。其中关于分布式锁服务的存储的选择问题，因为对于主流存储系统的选择与对比，已经在第 4 讲“注册发现”和第 6 讲“配置中心”中讨论过，所以这里就不再赘述了。</p><h2>总结</h2><p>到这里，我们一起讨论了分布式系统场景下的分布式锁的相关问题，接下来我们一起来总结一下这节课的主要内容：</p><p>首先，我们讨论了单进程内和单节点内进程的临界区问题，并且这个问题在分布式系统中依然存在，那么对于分布式场景下的临界区问题，我们需要用分布式锁服务来解决。</p><p>其次，我们一起讨论了，怎么实现分布式锁服务的互斥、超时机制、完备的锁接口、可重入和公平性等特性，基于这些知识和原理，我们就可以很轻松地实现自己的分布式锁服务了。</p><p>最后，我们一起探讨了在分布式场景下的正确性问题，发现分布式场景下，锁服务没有办法保证 100% 的正确性，并且，<strong>我们认为可用性是设计分布式锁服务非常关键的一个目标</strong>。这样，我们就可以依据不同的业务场景，来设计和权衡我们的分布式锁服务了。</p><h2>思考题</h2><p>根据本节课讨论的情况，在实现分布式锁服务的时候，你认为应该以什么样的原则来选择我们的存储系统呢？</p><p>欢迎你在留言区发表你的看法。如果这节课对你有帮助，也推荐你分享给更多的同事、朋友。</p>","comments":[{"had_liked":false,"id":334094,"user_name":"啊树","can_delete":false,"product_type":"c1","uid":1281551,"ip_address":"","ucode":"F1072F4610B6F8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pZ5ibu3jOPTfWVtzTeNTiaL2PiabGT2Y2yKd2TNDcZMkIY34T5fhGcSnBjgpkd54Q3S6b3gRW3yYTxZk0QHYB0qnw/132","comment_is_top":false,"comment_ctime":1644742306,"is_pvip":true,"replies":[{"id":"122130","content":"我觉得学习技术可以分两个维度：<br><br> 1、一个原理论上或者广度上的，通过了解技术的业务场景、解决问题的原理和方案，以及这个技术需要注意和思辨的地方来掌握这个技术，这样在我们碰到这个业务场景是，能立即明白这是什么问题，应该怎么解决，难度和注意点是什么。一般来说，一些技术上不正确的决策，都是由于这些知识盲区导致的。<br><br>2、另一个是实践上或者深度上的，在业务上确定需要这个技术的时候，依据之前的理论知识，对开源项目进行选型或者选择自研都可以。这一部分可以在有需要的时候再做，现在可以先快速拓宽知识的边界。<br><br>一般理论上的知识会比较稳定，不容易过时，而具体项目的实现，首先项目本身会迭代而改变，另外后面也会有其他新的项目出来，是会快速改变的。所以这个专栏主要是对技术原理上的讨论，这个部分是需要对这个方向有一定经验的人来总结的，如果你对某一个知识点非常感兴趣，那么在学习好技术原理后，可以对你感兴趣的一个或几个项目来做具体的分析，一定会受益匪浅。","user_name":"作者回复","comment_id":334094,"uid":"1047808","ip_address":"","utype":1,"ctime":1644894392,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"96134022818","product_id":100104701,"comment_content":"建议老师结合目前主流组件介绍哪些组件如何运用这些知识点，不然有点懵，不知道能干嘛","like_count":22,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551087,"discussion_content":"我觉得学习技术可以分两个维度：\n\n 1、一个原理论上或者广度上的，通过了解技术的业务场景、解决问题的原理和方案，以及这个技术需要注意和思辨的地方来掌握这个技术，这样在我们碰到这个业务场景是，能立即明白这是什么问题，应该怎么解决，难度和注意点是什么。一般来说，一些技术上不正确的决策，都是由于这些知识盲区导致的。\n\n2、另一个是实践上或者深度上的，在业务上确定需要这个技术的时候，依据之前的理论知识，对开源项目进行选型或者选择自研都可以。这一部分可以在有需要的时候再做，现在可以先快速拓宽知识的边界。\n\n一般理论上的知识会比较稳定，不容易过时，而具体项目的实现，首先项目本身会迭代而改变，另外后面也会有其他新的项目出来，是会快速改变的。所以这个专栏主要是对技术原理上的讨论，这个部分是需要对这个方向有一定经验的人来总结的，如果你对某一个知识点非常感兴趣，那么在学习好技术原理后，可以对你感兴趣的一个或几个项目来做具体的分析，一定会受益匪浅。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1644894392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335948,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1645783899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44595456859","product_id":100104701,"comment_content":"1.大部分时候控制好超时间隔，防止删除别人的锁，满足可重入和嵌套锁其实就好了。其他的概率靠对账去兜，roi问题。<br>2.有现成资源，无脑redis。有特殊性能要求，可以基于db走乐观锁。<br>3.懂的听起来没难度，不懂的可能有点抽象。而且这块东西感觉听懂了具体实现也就理解了上面提炼的所有思路。反而直接理解思路对新手可能会难些。对于幼儿，身体和意识是一体的。怎么讲取决于人群，和理解效率。分布式锁这个其实可以拿具体存储在多场景的实现方式的利弊来讲。抽象的知识依赖具象的实例来呈现。","like_count":10},{"had_liked":false,"id":337035,"user_name":"刘章","can_delete":false,"product_type":"c1","uid":1009693,"ip_address":"","ucode":"7608C518D49AE4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJLxEbhSEziblPNVkr9XFIAzPCib0TQvBxHYwiaKiaib7ExZ8dmUWyqWoibSedACTHCf52INMib80ic92G6wQ/132","comment_is_top":false,"comment_ctime":1646560968,"is_pvip":false,"replies":[{"id":"123148","content":"👍👍","user_name":"作者回复","comment_id":337035,"uid":"1047808","ip_address":"","utype":1,"ctime":1646571298,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"14531462856","product_id":100104701,"comment_content":"高可用我会选zookeeper，要求不高，选Redis","like_count":3,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554727,"discussion_content":"👍👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646571298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341828,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1649851258,"is_pvip":false,"replies":[{"id":"124875","content":"👍","user_name":"作者回复","comment_id":341828,"uid":"1047808","ip_address":"","utype":1,"ctime":1649870874,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"10239785850","product_id":100104701,"comment_content":"当初看martin kleppmann与antirez的争论，学到了不少东西","like_count":2,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":562745,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649870874,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346634,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1653306831,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5948274127","product_id":100104701,"comment_content":"可以总结下zk和redis锁的优缺点和如何选择吗？现在网上的说发版本太多了。","like_count":1},{"had_liked":false,"id":343609,"user_name":"面试官问","can_delete":false,"product_type":"c1","uid":1009375,"ip_address":"","ucode":"F9CE89589772F4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/66/df/501ba989.jpg","comment_is_top":false,"comment_ctime":1650952689,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5945919985","product_id":100104701,"comment_content":"https:&#47;&#47;github.com&#47;baomidou&#47;lock4j<br>这个开源的分布式锁组件还不错。","like_count":1},{"had_liked":false,"id":338395,"user_name":"处女座♍️","can_delete":false,"product_type":"c1","uid":1954858,"ip_address":"","ucode":"E126518FC0D436","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoxPxEURiaoe5Px5iaTN2lYuGkyljx5AoAa61Qg1nPAKBX57ldwRCqpWSYklIoNkqT0eluB66Yibgx7Q/132","comment_is_top":false,"comment_ctime":1647484175,"is_pvip":true,"replies":[{"id":"123788","content":"几乎不是要求非常高正确性的场景，都可以用Redis，不过业务量上来后，换成zk要好好评估，zk的性能比Redis要差了一个数量级。<br><br>比较好的方式还是以性能和正确性来选择分布式锁，课程中有讨论。","user_name":"作者回复","comment_id":338395,"uid":"1047808","ip_address":"","utype":1,"ctime":1647652512,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5942451471","product_id":100104701,"comment_content":"结合业务实践，项目初步阶段用redis作为分布式锁，业务量上来后考虑安全可用会改成zk，不过目前redis能满足80%业务。。","like_count":1,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557074,"discussion_content":"几乎不是要求非常高正确性的场景，都可以用Redis，不过业务量上来后，换成zk要好好评估，zk的性能比Redis要差了一个数量级。\n\n比较好的方式还是以性能和正确性来选择分布式锁，课程中有讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647652512,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335277,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1645438022,"is_pvip":true,"replies":[{"id":"122462","content":"etcd做分布式锁，在存储上的选择是没有问题，已经是一致性最好的存储了。<br><br>文章讨论的是分布式锁的正确性问题：一般在这种情况下，锁服务在进程加锁成功后，会设置一个超时时间，如果进程持有锁超时后，将锁再颁发给其他的进程，就会导致一把锁被两个进程持有的情况出现，使锁的互斥语义被破坏。","user_name":"作者回复","comment_id":335277,"uid":"1047808","ip_address":"","utype":1,"ctime":1645483922,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5940405318","product_id":100104701,"comment_content":"老师，如果etcd作为分布式锁，我能想到的是网络分区时，少数节点会有问题。还有其他方面的问题吗？","like_count":1,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552457,"discussion_content":"etcd做分布式锁，在存储上的选择是没有问题，已经是一致性最好的存储了。\n\n文章讨论的是分布式锁的正确性问题：一般在这种情况下，锁服务在进程加锁成功后，会设置一个超时时间，如果进程持有锁超时后，将锁再颁发给其他的进程，就会导致一把锁被两个进程持有的情况出现，使锁的互斥语义被破坏。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645483922,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334448,"user_name":"HappyHasson","can_delete":false,"product_type":"c1","uid":2911084,"ip_address":"","ucode":"B84CC43E349CFA","user_header":"https://static001.geekbang.org/account/avatar/00/2c/6b/6c/3e80afaf.jpg","comment_is_top":false,"comment_ctime":1644941620,"is_pvip":true,"replies":[{"id":"122287","content":"可以在加锁成功的时候，写入当前获得锁的进程ID，这样父进程在子进程崩溃的时候，去检查一下当前锁是否为挂掉的子进程持有的，如果是的，就释放锁。","user_name":"作者回复","comment_id":334448,"uid":"1047808","ip_address":"","utype":1,"ctime":1645110908,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5939908916","product_id":100104701,"comment_content":"请教老师：<br>“在单机情况下，我们可以非常方便地通过操作系统提供的机制，来正确判断一个进程是否存活，比如，父进程在获得进程挂掉的信号后，可以去查看当前挂掉的进程是否持有锁，如果持有就进行释放”<br>----老师能否举个例子，我没在实际项目中见到过这种实现。父进程需要知道子进程的具体逻辑才能帮忙释放锁吧？","like_count":1,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551787,"discussion_content":"可以在加锁成功的时候，写入当前获得锁的进程ID，这样父进程在子进程崩溃的时候，去检查一下当前锁是否为挂掉的子进程持有的，如果是的，就释放锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645110908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334421,"user_name":"陈阳","can_delete":false,"product_type":"c1","uid":2653715,"ip_address":"","ucode":"C8E676C967D23A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","comment_is_top":false,"comment_ctime":1644928356,"is_pvip":true,"replies":[{"id":"122285","content":"比如 a 操作或者锁了，并且版本号为 1，但是由于 GC 等原因，操作被挂起了。在 a 操作挂起的时候，锁过期了，b操作又获得了锁，版本号为 2，并且写入成功。这个时候，a 操作已经恢复了，再进行写入操作的时候，就会出现版本回退的问题。","user_name":"作者回复","comment_id":334421,"uid":"1047808","ip_address":"","utype":1,"ctime":1645110561,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5939895652","product_id":100104701,"comment_content":"老师  对于这些问题，如果我们获得锁是为了写一个共享存储，那么有一种方案可以解决上面的问题，那就是在获得锁的时候，锁服务生成一个全局递增的版本号，在写数据的时候，需要带上版本号。共享存储在写入数据的时候，会检查版本号，如果版本号回退了，就说明当前锁的互斥语义出现了问题，那么就拒绝当前请求的写入，如果版本号相同或者增加了，就写入数据和当前操作的版本号。  什么情况下会出现版本号回退？","like_count":1,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551785,"discussion_content":"比如 a 操作或者锁了，并且版本号为 1，但是由于 GC 等原因，操作被挂起了。在 a 操作挂起的时候，锁过期了，b操作又获得了锁，版本号为 2，并且写入成功。这个时候，a 操作已经恢复了，再进行写入操作的时候，就会出现版本回退的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645110561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334106,"user_name":"shuff1e","can_delete":false,"product_type":"c1","uid":1756280,"ip_address":"","ucode":"85601271951B5A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep075ibtmxMf3eOYlBJ96CE9TEelLUwePaLqp8M75gWHEcM3za0voylA0oe9y3NiaboPB891rypRt7w/132","comment_is_top":false,"comment_ctime":1644747467,"is_pvip":false,"replies":[{"id":"122107","content":"我们往共享存储中写入数据的正确性：<br>一种是从外部通过 fencing token 来保证，其实是一种抽象泄漏。<br>另一种是由共享存储自身来保证，所有的分布式数据库都是这样做的，这样的抽象对使用者更友好。","user_name":"作者回复","comment_id":334106,"uid":"1047808","ip_address":"","utype":1,"ctime":1644891347,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5939714763","product_id":100104701,"comment_content":"请教老师：<br><br>所以，我认为对于在共享存储中写入数据等等，完全不能容忍分布式锁互斥语义失败的情况，不应该借助分布式锁从外部来实现，而是应该在共享存储内部来解决。<br><br>在共享存储内部解决什么问题？和文章中所说的fencing token有什么关系？","like_count":1,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551060,"discussion_content":"我们往共享存储中写入数据的正确性：\n一种是从外部通过 fencing token 来保证，其实是一种抽象泄漏。\n另一种是由共享存储自身来保证，所有的分布式数据库都是这样做的，这样的抽象对使用者更友好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644891347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333911,"user_name":"葡萄糖sugar","can_delete":false,"product_type":"c1","uid":2600726,"ip_address":"","ucode":"82559E37922976","user_header":"https://static001.geekbang.org/account/avatar/00/27/af/16/51149d2b.jpg","comment_is_top":false,"comment_ctime":1644576046,"is_pvip":false,"replies":[{"id":"121965","content":"这里的意思是指互斥语义是一定能保证同一时刻有一个客户端能获取锁的，但是现在的情况是所有的客户端都不能获取到锁。","user_name":"作者回复","comment_id":333911,"uid":"1047808","ip_address":"","utype":1,"ctime":1644581675,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"5939543342","product_id":100104701,"comment_content":"“但是因为响应超时，客户端以为自己没有获取锁的情况发生。这样一来，依然会在一定程度上，影响锁的互斥语义的正确性”。老师，这段我不是很理解，为什么会影响到锁的互斥？客户端以为自己没有获得过锁，然后另一个竞争锁的客户端会尝试获得锁，此时并不会出现同时拥有同一个锁的问题，那为什么还会影响锁的互斥呢？","like_count":1,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550545,"discussion_content":"这里的意思是指互斥语义是一定能保证同一时刻有一个客户端能获取锁的，但是现在的情况是所有的客户端都不能获取到锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644581675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333882,"user_name":"魏颖琪","can_delete":false,"product_type":"c1","uid":1184964,"ip_address":"","ucode":"097544C71EBDA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/14/c4/e354d8ba.jpg","comment_is_top":false,"comment_ctime":1644569866,"is_pvip":false,"replies":[{"id":"121964","content":"这里的意思是指互斥语义是一定能保证同一时刻有一个客户端能获取锁的，但是现在的情况是所有的客户端都不能获取到锁。","user_name":"作者回复","comment_id":333882,"uid":"1047808","ip_address":"","utype":1,"ctime":1644581669,"user_name_real":"编辑"}],"discussion_count":3,"race_medal":0,"score":"5939537162","product_id":100104701,"comment_content":"心跳+超时机制的方式，提到“因为响应超时，客户端以为自己没有获取锁的情况发生。”这会在超时时间内，浪费了锁，但不认为会“影响锁的互斥语义的正确性”，请问老师，这具体怎么理解，怎么会影响锁的互斥语义的正确性？","like_count":1,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550544,"discussion_content":"这里的意思是指互斥语义是一定能保证同一时刻有一个客户端能获取锁的，但是现在的情况是所有的客户端都不能获取到锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644581670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2653715,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","nickname":"陈阳","note":"","ucode":"C8E676C967D23A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551205,"discussion_content":"感觉这里理解为互斥有点牵强啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644927549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":2653715,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","nickname":"陈阳","note":"","ucode":"C8E676C967D23A","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":551296,"discussion_content":"所以说的是一定程度上会影响正确性。\n正确性的保障还依赖这个：“执行临界区代码的时间 + 各种进程的暂停” 是非常小的，这个没有办法百分之百来保证的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644977573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":551205,"ip_address":""},"score":551296,"extra":""}]}]},{"had_liked":false,"id":358816,"user_name":"不吃辣👾","can_delete":false,"product_type":"c1","uid":1333649,"ip_address":"浙江","ucode":"B25E0725B5E85F","user_header":"https://static001.geekbang.org/account/avatar/00/14/59/91/fa2d8bb2.jpg","comment_is_top":false,"comment_ctime":1664842620,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1664842620","product_id":100104701,"comment_content":"仅仅靠一端锁服务是不能保证100%正确性的，需要客户端支持mvcc才能共同保证。","like_count":0},{"had_liked":false,"id":341415,"user_name":"GaryYu","can_delete":false,"product_type":"c1","uid":2625540,"ip_address":"","ucode":"667D780E74DBC8","user_header":"","comment_is_top":false,"comment_ctime":1649590823,"is_pvip":true,"replies":[{"id":"124989","content":"比如 锁服务 的逻辑颁发锁成功，但是通过网络到客户端的时候发生丢包，还没有重试的时候，客户端已经超时了，或者是客户端已经收到锁，但是响应发送到锁服务的时候超时了。<br><br>对于锁服务来说，它不能区分超时是发生在客户端收到锁之前还是锁之后。","user_name":"作者回复","comment_id":341415,"uid":"1047808","ip_address":"","utype":1,"ctime":1649987094,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1649590823","product_id":100104701,"comment_content":"什么情况会发生 响应超时客户端以为没获取锁 但锁服务已经颁发锁 <br>若响应超时客户端不会返回error给锁服务让这次获取锁失败吗?","like_count":0,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563376,"discussion_content":"比如 锁服务 的逻辑颁发锁成功，但是通过网络到客户端的时候发生丢包，还没有重试的时候，客户端已经超时了，或者是客户端已经收到锁，但是响应发送到锁服务的时候超时了。\n\n对于锁服务来说，它不能区分超时是发生在客户端收到锁之前还是锁之后。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649987094,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339339,"user_name":"study的程序员","can_delete":false,"product_type":"c1","uid":1023101,"ip_address":"","ucode":"E5AE9037D24429","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","comment_is_top":false,"comment_ctime":1648040060,"is_pvip":false,"replies":[{"id":"124509","content":"可重入锁是锁的实现，业务层可以不关心是否重入了。","user_name":"作者回复","comment_id":339339,"uid":"1047808","ip_address":"","utype":1,"ctime":1648861994,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1648040060","product_id":100104701,"comment_content":"“但是因为响应超时，客户端以为自己没有获取锁的情况发生。这样一来，依然会在一定程度上，影响锁的互斥语义的正确性”<br>对于可重入锁这个问题有什么好的解决办法吗？<br>是不是可以在获取锁之前先查询自身是否拥有锁已经重入的次数，获取超时后需要再查询重入次数，如果+1了就相当于已经获得锁了，否则继续获取锁。","like_count":0,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559624,"discussion_content":"可重入锁是锁的实现，业务层可以不关心是否重入了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648861994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339337,"user_name":"study的程序员","can_delete":false,"product_type":"c1","uid":1023101,"ip_address":"","ucode":"E5AE9037D24429","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9c/7d/774e07f9.jpg","comment_is_top":false,"comment_ctime":1648039957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648039957","product_id":100104701,"comment_content":"“但是因为响应超时，客户端以为自己没有获取锁的情况发生。这样一来，依然会在一定程度上，影响锁的互斥语义的正确性”","like_count":0},{"had_liked":false,"id":334203,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1644808723,"is_pvip":true,"replies":[{"id":"122106","content":"可以在 github 上搜索 “distributed lock”，上面有不少项目，不过没有见到特别知名的，可能的原因有：<br>1、一般的框架中都集成了分布式锁，不需要单独引入；<br>2、不同的分布式锁的实现的性能差别非常大，并且这些差别主要是存储系统的选择上面，和实现逻辑关系不大；<br>3、实现的代码量也不大，很多时候大家也不想因为分布式锁再引入一个项目","user_name":"作者回复","comment_id":334203,"uid":"1047808","ip_address":"","utype":1,"ctime":1644890726,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"1644808723","product_id":100104701,"comment_content":"老师，现在分布式锁有什么开源解决项目？","like_count":0,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551058,"discussion_content":"可以在 github 上搜索 “distributed lock”，上面有不少项目，不过没有见到特别知名的，可能的原因有：\n1、一般的框架中都集成了分布式锁，不需要单独引入；\n2、不同的分布式锁的实现的性能差别非常大，并且这些差别主要是存储系统的选择上面，和实现逻辑关系不大；\n3、实现的代码量也不大，很多时候大家也不想因为分布式锁再引入一个项目","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644890726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1030862,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","nickname":"bearlu","note":"","ucode":"14F260C8B24E27","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":551059,"discussion_content":"好的，谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644890892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":551058,"ip_address":""},"score":551059,"extra":""}]}]},{"had_liked":false,"id":333926,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1644589656,"is_pvip":true,"replies":[{"id":"121976","content":"Q1：分布式锁是解决分布式场景下的临界区互斥的问题，不同的服务也可能会出现这样的情况的，只不过在实际工作中很少出进行这样的设计，因为这样会导致这些服务之间紧耦合。<br>Q2：是同一个线程是没有问题的，当然能避免这样的情况会让代码的可读性更强。","user_name":"作者回复","comment_id":333926,"uid":"1047808","ip_address":"","utype":1,"ctime":1644630686,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644589656","product_id":100104701,"comment_content":"请教老师两个问题：<br>Q1：不同的服务会有分布式锁的问题吗？<br>文章中从相同服务的不同实例提出分布式锁的问题，那么，不同服务之间是否也有分布式锁的问题？<br>Q2：锁的可重入性，是指获得锁的线程还在处理，没有释放锁之前再次获得锁吗？如果是这样，算不算是代码的错误呢？因为获得锁的线程并没有处理完，不应该去再次获取锁。","like_count":0,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550593,"discussion_content":"Q1：分布式锁是解决分布式场景下的临界区互斥的问题，不同的服务也可能会出现这样的情况的，只不过在实际工作中很少出进行这样的设计，因为这样会导致这些服务之间紧耦合。\nQ2：是同一个线程是没有问题的，当然能避免这样的情况会让代码的可读性更强。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644630686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333793,"user_name":"陈迪","can_delete":false,"product_type":"c1","uid":1019744,"ip_address":"","ucode":"1A64122CC47337","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/60/be0a8805.jpg","comment_is_top":false,"comment_ctime":1644540278,"is_pvip":false,"replies":[{"id":"121949","content":"对的，对于分布式锁我们需要尽可能提高它的正确性，所以存储系统的强一致性是必须的，容忍部分结点失败，来保障还不错的可用性也是必须的","user_name":"作者回复","comment_id":333793,"uid":"1047808","ip_address":"","utype":1,"ctime":1644578008,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644540278","product_id":100104701,"comment_content":"思考题，存储系统需要1 强一致 2 容忍部分结点失败，来保障还不错的可用性","like_count":0,"discussions":[{"author":{"id":1047808,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fd/00/f5d19a8b.jpg","nickname":"伴鱼技术团队","note":"","ucode":"C7FAC706B18376","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550527,"discussion_content":"对的，对于分布式锁我们需要尽可能提高它的正确性，所以存储系统的强一致性是必须的，容忍部分结点失败，来保障还不错的可用性也是必须的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644578008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}