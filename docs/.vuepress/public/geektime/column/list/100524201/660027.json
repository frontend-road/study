{"id":660027,"title":"42｜串的KMP模式匹配算法之实现与性能分析：代码实现简单","content":"<p>你好，我是王健伟。</p><p>上节课我们针对串的KMP模式匹配算法配以了大量的图形进行了非常仔细的观察，而观察的目的，就是为了这节课代码的实现。</p><p>串的KMP模式匹配算法实现代码并不多，但只有你学好了上节课的内容，对该算法有详细的理解，才能理解本节这样写代码的含义。</p><h2>KMP模式匹配算法实现代码</h2><p>KMP模式匹配算法实现代码各式各样，有些实现方法虽然简洁，但并不好理解，我这里先以比较容易理解的方式进行代码实现。你可以先仔细读一遍。</p><pre><code class=\"language-plain\">//求本串的next数组\nvoid getNextArray( int next[])\n{\n\t//next数组下标为0和为1的元素值固定为0和1。其实next[0]里的值并没有用到\n\tif (length &lt; 1)\n\t\treturn;\n\t\n\t//next数组的前两个元素肯定是0和1\n\tif (length == 1) //只有一个字符\n\t{\n\t\tnext[0] = 0;\n\t\treturn;\n\t}\n\t\t\n\tnext[0] = 0;\n\tnext[1] = 1;\n\tif (length == 2) //只有二个字符\n\t{\n\t\treturn;\n\t}\n\t\t\n\t//至少三个字符\n\tint nextarry_idx = 2; //当前要处理的next数组下标\n\tint max_pub_zhui = 0; //max_pub_zhui：最大公共前后缀包含的字符数量\n\t\n\t//循环的目的是给next数组赋值\n\twhile (nextarry_idx &lt; length)&nbsp;\n\t{\n\t\tint left_RMC_count = nextarry_idx; //left_RMC_count：如果当前字符与主串的字符不匹配，当前字符左侧有多少个字符\n\t\tint max_pub_zhui = left_RMC_count - 1; //max_pub_zhui：最大公共前后缀包含的字符数量\n\t\t\n\t\tint start1idx = 0;\n\t\tint start2idx = left_RMC_count - max_pub_zhui;\n\t\t\n\t\tint xhtimes = max_pub_zhui; //循环次数\n\t\t\n\t\t//本循环的目的是获取最长公共前后缀长度，代码写法无固定方式，选择自己容易理解的方式写即可\n\t\twhile (xhtimes &gt; 0)\n\t\t{\n\t\t\tif (ch[start1idx] != ch[start2idx])\n\t\t\t{\n\t\t\t\tmax_pub_zhui--;\n\t\t\t\tstart1idx = 0;\n\t\t\t\tstart2idx = left_RMC_count - max_pub_zhui;\n\t\t\t\txhtimes = max_pub_zhui;\n\t\t\t\tcontinue; //要回去重新循环\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstart1idx++;\n\t\t\t\tstart2idx++;\n\t\t\t}\n\t\t\txhtimes--;\n\t\t} //end while (xhtimes &gt; 0)\n\t\tnext[nextarry_idx] = max_pub_zhui + 1; //如果公共前后缀长度为n，那么就需要用子串的第n+1个字符与主串当前位做比较。\n\t\tnextarry_idx++;\n\t} //end while\n\treturn;\n}\n\t\n//KMP模式匹配算法接口，返回子串中第一个字符在主串中的下标，如果没找到子串，则返回-1\n//next：下一步数组（前缀表/前缀数组）\n//pos：从主串的什么位置开始匹配子串，默认从位置0开始匹配子串\nint StrKMPIndex(const MySString&amp; substr, int next[], int pos = 0)\n{\n\tif (length &lt; substr.length) //主串还没子串长，那不可能找到\n\t\treturn -1;\t\t\n\t\n\tint point1 = pos; //指向主串\n\tint point2 = 0;&nbsp; //指向子串\n\t\n\twhile (ch[point1] != '\\0' &amp;&amp; substr.ch[point2] != '\\0')\n\t{\n\t\tif (ch[point1] == substr.ch[point2])\n\t\t{\n\t\t\t//两个指针都向后走\n\t\t\tpoint1++;\n\t\t\tpoint2++;\n\t\t}\n\t\telse //两者不同\n\t\t{\n\t\t\t//point1和point2两个指针的处理\n\t\t\t\n\t\t\tif (point2 == 0) //下标0号位置子串的字符如果与主串字符不匹配则后续就要用子串的第1个字符（字符a）与主串下一位（1号下标位）字符做比较&nbsp;\n\t\t\t{\n\t\t\t\tpoint1++; //主串指针指向下一位\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//走到这个分支的，主串指针point1不用动，只动子串指针point2\n\t\t\t\tpoint2 = next[point2] - 1; //第这些个子串中的字符与主串当前位字符做比较\n\t\t\t}\n\t\t}\n\t}//end while\n\t\n\tif (substr.ch[point2] == '\\0')\n\t{\n\t\t//找到了子串\n\t\treturn point1 - point2;\n\t}\n\treturn -1;\n}\n</code></pre><!-- [[[read_end]]] --><p>在main主函数中继续增加测试代码。</p><pre><code class=\"language-plain\">//KMP模式匹配算法接口，返回子串中第一个字符在主串中的下标，如果没找到子串，则返回-1\nMySString mys13sub; //子串\nmys13sub.StrAssign(\"ababaaababaa\");\nint* mynextarray = new int[mys13sub.length];\nmys13sub.getNextArray(mynextarray); //获取next数组\nMySString mys13master; //主串\nmys13master.StrAssign(\"abbabbababaaababaaa\");\t\ncout &lt;&lt;\"StrKMPIndex()结果为\"&lt;&lt; mys13master.StrKMPIndex(mys13sub, mynextarray) &lt;&lt; endl;\ndelete[]mynextarray; //释放资源\n</code></pre><p>新增代码执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/55/57/55d4789cb3493a7393000c88cbeae657.jpg?wh=2126x102\" alt=\"\"></p><p>求解next数组是实现KMP模式匹配算法最重要的一环，它的代码也是最不好写的一环。上述我实现getNextArray()成员函数来求一个串的next数组，写法上比较暴力和繁琐，代码执行效率也不高，但优点是代码比较容易理解。</p><p><strong>另一种典型的KMP算法求解next数组的代码写法很简洁执行效率更高</strong>但很不好理解。为了能够理解下面我要书写的求解next数组的高效新版本代码，这里必须要先讲述一些理论知识。</p><p>首先，假设主串用S表示，子串用T表示。point1指向主串当前位置，point2指向子串当前位置。通过之前的学习你已经知道，next[point2]的含义表示当S[point1]≠ T[point2]时，point2指针需要退到的位置。这里提示一下，对应参考的代码是：point2 = next[point2] - 1;。</p><p>如果已知next数组中的前面元素值，能否根据这些值推出下一个next数组元素值呢？比如已经知道next数组中下标0~15的值，能否根据这些已知值推出next数组中下一个未知的值即下标为16的值？如果能推导出来就意味着根据前面的next元素值能够快速求出下个next元素值，那么对于求解整个next数组值的效率将提高数倍。</p><p>为了更明晰地阐述问题，这里以一个新范例来说明。假设next数组中下标0~15的值已知，试求解一下next[16]的值。如图1所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f2/e2/f21bb211b8b2c2cfc51fa9c181f4cfe2.jpg?wh=2268x454\" alt=\"\" title=\"图1 一个子串T和一个next数组，其中不重要的内容未在图中标注出来\"></p><p>图1中，因为next[15]=8，根据公共前后缀原理，意味着T[0]~T[6]的内容和T[8]~T[14]的内容相同。如图2中子串T的粗线标注部分：</p><p><img src=\"https://static001.geekbang.org/resource/image/5f/69/5f8a5e8c44b9a10da596dffe2c6c3d69.jpg?wh=2268x464\" alt=\"\" title=\"图2&nbsp; 公共前后缀：T[0]~T[6]的内容和T[8]~T[14]的内容相同\"></p><p>这里我给每一个关键分析步骤标上序号，方便你拆解之后慢慢理解。</p><ol>\n<li>此时比较子串中的T[7]和T[15]这两个字符，<strong>如果两者相等</strong>，即T[7]=T[15]，说明子串T的T[0]~T[14]之间公共前后缀长度由原来的7个增加到了8个，也就是意味着next[16]=next[15]+1=9。<strong>总结：已知next[15]，如果T[7] = T[15]，那么next[16]就可以直接用next[15]+1求得</strong>。这是<strong>最好</strong>的情形，<strong>通过next[15]就能求得next[16]</strong>，如图3所示：</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/a5/c9/a5ab5d1510cc879380273324a70200c9.jpg?wh=2268x434\" alt=\"\" title=\"图3&nbsp; 因为T[7] = T[15]，所以可以通过next[15]求得next[16]（next[16] = next[15]+1）\"></p><ol start=\"2\">\n<li>但是，如果T[7]和T[15]这两个字符<strong>不相等</strong>，即T[7]≠T[15]，这种情况没有办法直接通过next[15]求得next[16]的值。那么有没有办法通过前面已知的next元素值间接求得next[16]值呢？又该如何思考呢？</li>\n</ol><p>观察next[7]。注意，7这个值是T[15]位置的一半，其实就是next[15]-1得来的，我们发现它的值是4，根据公共前后缀原理，意味着T[0]~T[2]的内容和T[4]~T[6]的内容相同。如图4所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/6e/b2002248b1e44a89c7e4c473cd0d906e.jpg?wh=2268x442\" alt=\"\" title=\"图4&nbsp; 公共前后缀：T[0]~T[2]的内容和T[4]~T[6]的内容相同\"></p><p>结合图2和图4，可以得到这么几个结论。</p><ul>\n<li>T[0]~T[2]的内容和T[4]~T[6]的内容相等。</li>\n<li>T[4]~T[6]的内容和T[8]~T[10]的内容相等。</li>\n<li>T[8]~T[10]的内容和T[12]~T[14]的内容相等。</li>\n<li>也就是T[0]~T[2]=T[4]~T[6]=T[8]~T[10]=T[12]~T[14]。</li>\n</ul><p>如图5所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/90/ea93c40b4fdb03781c191b7f7849fb90.jpg?wh=2268x421\" alt=\"\" title=\"图5&nbsp; 公共前后缀：T[0]~T[2]=T[4]~T[6]=T[8]~T[10]=T[12]~T[14]\"></p><p>图5中，重点观察T[0]~T[2]= T[12]~T[14]这组。单独绘制出来如图6所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/7f/3b/7f1ac22339cdf87a48bfd51953b8bf3b.jpg?wh=2268x425\" alt=\"\" title=\"图6&nbsp; 观察T[0]~T[2]=T[12]~T[14]这组\"></p><p>图6中，如果T[3]=T[15]，这意味着T[0]~T[3]=T[12]~T[15]，此时根据公共前后缀原理，next[16]=next[7]+1=4+1=5。如图7所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b2/f3/b201766497c43bd8737ec2dabb8ecef3.jpg?wh=2268x475\" alt=\"\" title=\"图7&nbsp; T[3] = T[15]，所以可以求得next[16]（next[16]=next[7]+1=4+1=5）\"></p><p><strong>图7所示的情形也很好，通过next[7]能求得next[16]。</strong></p><ol start=\"3\">\n<li>但是，如果T[3]和T[15]这两个字符不相等，即T[3]≠T[15]，这种情况没有办法通过next[7]求得next[16]值。那么还要怎样求得next[16]值呢？可以看到，这是一个<strong>递推的过程</strong>，继续重复前面的步骤。</li>\n</ol><p>观察next[3]，也就是T[7]位置的一半，发现其值为2，根据公共前后缀原理，意味着T[0]的内容和T[2]的内容相同，如图8所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/12/1defc034d235780fbfcaaea8c79c2112.jpg?wh=2268x442\" alt=\"\" title=\"图8&nbsp; 公共前后缀：T[0]的内容和T[2]的内容相同\"></p><p>结合图2、图4和图8，其实也就是结合next[15]、next[7]、next[3]，可以得到结论即T[0]=T[2]=T[4]=T[6]=T[8]=T[10]=T[12]=T[14]。如图9所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/0a/c16c62d44287d00ddc113bd178c0890a.jpg?wh=2268x438\" alt=\"\" title=\"图9&nbsp; 公共前后缀：T[0]=T[2]=T[4]=T[6]=T[8]=T[10]=T[12]=T[14]\"></p><p>图9中，重点观察T[0] = T[14]这组。单独绘制出来如图10所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/44/d304d24bc0de352592237d9a1d987644.jpg?wh=2268x419\" alt=\"\" title=\"图10&nbsp; 观察T[0] = T[14]这一组\"></p><p>图10中，如果T[1]=T[15]，这意味着T[0]~T[1]=T[14]~T[15]，此时根据公共前后缀原理，next[16]=next[3]+1=2+1=3。如图11所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/11/18/11852e6559cc0f5f810c1abfcd581218.jpg?wh=2268x414\" alt=\"\" title=\"图11&nbsp; T[1] = T[15]，所以可以求得next[16]（next[16]= next[3]+1=2+1=3）\"></p><p><strong>图11所示的情形也还不错，通过next[3]能求得next[16]</strong>。</p><ol start=\"4\">\n<li>但是，如果T[1]和T[15]这两个字符<strong>不相等</strong>，即T[1]≠T[15]，这种情况没有办法通过next[3]求得next[16]值。那么还要怎样求得next[16]值呢？</li>\n</ol><p>观察next[1]（T[3]位置的一半），next[1]的固定值是1，这表示没有前后缀信息。</p><p>观察next[0]（T[1]位置的一半），next[0]的固定值是0，当遇到next元素值为0的情形时，表示这个递推过程就结束了，如果递推过程结束，也没得到next[16]的结果，那么next[16]的结果就为<strong>1</strong>（没有公共前后缀）。</p><p>基于上面这些理论知识，我们开始实现典型的KMP算法，求解next数组的实现代码如下：</p><pre><code class=\"language-plain\">//求本串的next数组——典型的KMP算法求解next数组的代码写法\nvoid getNextArray_Classic(int next[])\n{\n\tif (length &lt; 1)\n\t\treturn;\n\t\n\t//next数组的前两个元素肯定是0和1\n\tif (length == 1) //只有一个字符\n\t{\n\t\tnext[0] = 0;\n\t\treturn;\n\t}\n\t\t\n\tnext[0] = 0;\n\tnext[1] = 1;\n\tif (length == 2) //只有二个字符\n\t{\n\t\treturn;\n\t}\n\t\t\n\t//至少三个字符\n\tint next_idx = 2;&nbsp; &nbsp; //需要求的next数组中下标为2的元素值\n\tint qz_tail_idx = 0; //前缀末尾位置\n\t\n\twhile (next_idx &lt; length)\n\t{\n\t\tif (ch[qz_tail_idx] == ch[next_idx - 1])//next_idx-1代表后缀末尾位置\n\t\t{\n\t\t\tnext[next_idx] = (qz_tail_idx + 1) + 1;&nbsp; &nbsp;//qz_tail_idx+1就是前缀的宽度\n\t\t\tnext_idx++; \t\t\t\t\t\n\t\t\tqz_tail_idx++; //前缀末尾位置：其实这样写也OK：qz_tail_idx = next[next_idx - 1] - 1;&nbsp;\n\t\t}\n\t\telse&nbsp;&nbsp;\n\t\t{\t\n\t\t\tqz_tail_idx = next[qz_tail_idx] - 1; //这句是最难理解的代码\n\t\t\t\n\t\t\t//qz_tail_idx允许等于0，等于0有机会下次while时再比较一次，所以下面只判断qz_tail_idx &lt; 0 的情形\n\t\t\tif (qz_tail_idx &lt; 0)\n\t\t\t{\n\t\t\t\t//没找到前缀\n\t\t\t\tqz_tail_idx = 0;\n\t\t\t\tnext[next_idx] = 1;\n\t\t\t\t++next_idx;\n\t\t\t}\n\t\t}\n\t} //end while (next_idx &lt; length)\n\treturn;\n}\n</code></pre><p>在main主函数中继续增加测试代码。</p><pre><code class=\"language-plain\">//求本串的next数组——典型的KMP算法求解next数组的代码写法\nMySString mys14sub; //子串\nmys14sub.StrAssign(\"ababaaababaa\");\nint* mynextarray14 = new int[mys14sub.length];\ncout &lt;&lt;\"本次采用典型的KMP算法求解next数组：----\"&lt;&lt; endl;\nmys14sub.getNextArray_Classic(mynextarray14);\nMySString mys14master; //主串\nmys14master.StrAssign(\"abbabbababaaababaaa\");\ncout &lt;&lt;\"StrKMPIndex()结果为\"&lt;&lt; mys14master.StrKMPIndex(mys14sub, mynextarray14) &lt;&lt; endl;\ndelete[]mynextarray14; //释放资源\n</code></pre><p>新增代码执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c3/76/c3738f1beyyf216e3571434a4327aa76.jpg?wh=2132x174\" alt=\"\"></p><p>新实现的求next数组的getNextArray_Classic()成员函数比getNextArray()成员函数代码更简洁，执行效率更高，但理解难度更大。其实，getNextArray_Classic()这段短短的数行代码却是KMP算法中最难理解的代码段。</p><h2>KMP模式匹配算法性能分析</h2><p>最后，我们来看看这个算法的性能分析。假设子串（模式串）长度为m，主串长度为n。</p><p>整个KMP模式匹配算法所花费的时间应该是求解next数组的时间以及利用next模式数组进行模式匹配的时间。</p><p>先来看<strong>next数组的时间</strong>：getNextArray_Classic()作为获取next数组的函数，实现得比较精炼高效，时间复杂度为O(m)。</p><p>再来<strong>根据next数组在主串中寻找子串的时间</strong>。StrKMPIndex()成员函数用于在主串中寻找子串。它的实现代码的主while循环中，因为point1指针永远不回退，整个while循环的时间复杂度为O(n)。所以KMP算法的时间复杂度是O(m+n)。另外，因为KMP算法只需要一个额外的next数组，因此空间复杂度为O(m)。</p><p>KMP算法是利用让主串中的指针（point1）不回退甚至子串一次可能会右移多个位置的实现方式达到提升字符串匹配效率的目的。如果在字符串匹配过程中不经常出现子串中的部分内容与主串匹配的情形，那么与串的朴素模式匹配算法相比，串的KMP模式匹配算法的优势就不太明显，所以，串的朴素模式匹配算法目前也仍然有着广泛的使用。</p><h2>小结</h2><p>本节我带你实现了串的KMP模式匹配算法的相关代码，在代码中，我们先求得next数组内容，然后利用next数组内容就可以快速在主串中寻找子串。</p><p>KMP模式匹配算法的重点是求解next数组，我首先采用一种代码上比较容易理解的方式来实现next数组求解，目的就是为了让你透彻理解求解next数组的过程，但这种实现方式的缺陷是代码书写相对繁琐，执行效率也不高。</p><p>典型的KMP算法求解next数组的代码写法很简洁执行效率更高但很不好理解。为了能够让你理解典型的KMP算法求解next数组的代码，我又为你讲解了一些如何用更高效率的手段来求解next数组元素的理论知识。</p><p>有了这些理论知识做铺垫，我为你提供了典型的KMP算法求解next数组的实现代码从而以更高的效率求得next数组，这自然也就意味着整个在主串中寻找子串的执行效率会得到进一步提高。</p><p>KMP算法借助next数组，利用让主串中的指针不回退甚至子串一次可能会右移多个位置的实现方式达到提升字符串匹配效率的目的。假设子串长度为m，主串长度为n，那么KMP算法的时间复杂度是O(m+n)，空间复杂度为O(m)。</p><p>当然，KMP模式匹配算法的使用也有其制约性，也就是如果在字符串匹配过程中不经常出现子串中的部分内容与主串匹配的情形，那么与串的朴素模式匹配算法相比，串的KMP模式匹配算法的优势就不太明显，所以，串的朴素模式匹配算法目前也仍然有着广泛的使用。</p><h2>思考题</h2><ol>\n<li>给定一个子串，求解该子串的next数组，分析一下生成next数组的时间复杂度。</li>\n<li>比较KMP模式匹配算法和朴素模式匹配算法的时间复杂度和空间复杂度，尝试说明KMP模式匹配算法的优势和不足之处。</li>\n</ol><p>欢迎你在留言区和我互动。如果觉得有所收获，也可以把这节课分享给更多的朋友一起学习。我们下节课见！</p>","comments":[]}