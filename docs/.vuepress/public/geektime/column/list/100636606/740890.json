{"id":740890,"title":"第 14 章 服务配置管理(2)","content":"<h2 id=\"nav_point_222\">14.2　服务配置的实现原理与应用</h2>\n<p>Spring Cloud Config 基于 Spring Boot 和 Spring Framework 提供的机制，为开发者封装了一套开箱即用的分布式配置管理解决方案。在上一节里，我们已经通过实际的例子看到了如何使用 Spring Cloud Config Server 和对应的客户端来集中管理配置，并在应用中加载远程配置。这一切是如何实现的？Spring Cloud Config 还支持用其他几种基础设施来充当配置中心，又该如何使用它们呢？</p>\n<h3 id=\"nav_point_223\">14.2.1　服务配置的实现原理</h3>\n<p>在 2.4 节中，我们介绍过 Spring Framework 的环境抽象，尤其是 <code>PropertySource</code>，各种属性其实都是在一个个的 <code>PropertySource</code> 里查找和解析的。所以，如果用一句话来解释 Spring Cloud Config 的工作原理，那就是它在 <code>Environment</code> 里增加了一个或几个可以从远端加载配置项的 <code>PropertySource</code>。</p>\n<p>仍然以 Spring Cloud Config Client 为例，我们可以想象到客户端其实是用 <code>RestTemplate</code> 来请求服务端获取配置的，事实也是如此，但它们又是怎么变成 <code>PropertySource</code> 的呢？</p>\n<ol>\n<li><p><strong>对 spring.config.import 的支持</strong></p>\n<p>Spring Boot 2.4 开始提供这种导入配置的方式，<code>ConfigDataImporter</code> 负责用 <code>ConfigDataLoader</code> 加载配置并存进 <code>ConfigData</code>，而 <code>ConfigDataEnvironmentPostProcessor</code> 又将 <code>ConfigData</code> 的属性放进 <code>Environment</code>，整个过程一环扣一环。</p><!-- [[[read_end]]] -->\n<p>回到 Spring Cloud Config Client，<code>META-INF/spring.factories</code> 里有如下的定义：</p>\n<pre class=\"code-rows\"><code># ConfigData Location Resolvers\norg.springframework.boot.context.config.ConfigDataLocationResolver=\\\norg.springframework.cloud.config.client.ConfigServerConfigDataLocationResolver\n\n# ConfigData Loaders\norg.springframework.boot.context.config.ConfigDataLoader=\\\norg.springframework.cloud.config.client.ConfigServerConfigDataLoader</code></pre>\n<p>所以我们可以先去读一下 <code>ConfigServerConfigDataLocationResolver</code>，看到 <code>PREFIX = \"configserver:\"</code> 是否有似曾相识的感觉？没错，之前 <code>spring.config.import=optional:configserver:</code> 中的 <code>configserver:</code> 就是在这里定义的。而且它会负责解析出 <code>ConfigServerConfigDataResource</code>，后续 <code>ConfigServerConfigDataLoader</code> 再从里面去加载配置，保存到 <code>ConfigData</code> 里，其中的 <code>MapPropertySource</code> 名字为 <code>configClient</code>。感兴趣的可以看看 <code>ConfigServerConfigDataLoader.load()</code> 方法，它是负责加载具体配置的方法。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>对 Bootstrap 方式的支持</strong></p>\n<p>再来看看 Bootstrap 方式又是怎么实现的，同样是从 <code>META-INF/spring.factories</code> 里寻找突破口，我们发现了两个配置类，<code>ConfigServiceBootstrapConfiguration</code> 做基本配置，<code>DiscoveryClientConfigServiceBootstrapConfiguration</code> 提供一些从服务注册中心获取 Spring Cloud Config Server 实例的配置：</p>\n<pre class=\"code-rows\"><code># Bootstrap components\norg.springframework.cloud.bootstrap.BootstrapConfiguration=\\\norg.springframework.cloud.config.client.ConfigServiceBootstrapConfiguration,\\\norg.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration</code></pre>\n<p>这里最重要的就是根据 <code>spring.cloud.config.enabled</code> 配置注册了一个 <code>ConfigServicePropertySourceLocator</code> Bean，而这个 Bean 会使用 <code>RestTemplate</code> 从远端加载配置，并返回名为 <code>configService</code> 的 <code>OriginTrackedCompositePropertySource</code>。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>刷新配置</strong></p>\n<p>在 14.1.1 中我们说过，对于配置中心，我们有两个基本要求：其一是希望能集中管理，其二是希望能在配置变更后快速生效。我们已经知道了 Spring Cloud Config 是如何集中管理配置并让客户端按需获取配置的，那又该如何实现第二点呢？Spring Cloud Context 为我们提供了一个 <code>@RefreshScope</code> 注解，添加了该注解的 Bean 会被放到名为 <code>refresh</code> 的作用域里（对应 <code>RefreshScope</code> 类），其中的 Bean 能在运行时被刷新，依赖它们的组件在下次调用其中的方法前会拿到新的实例。</p>\n<p>为了触发带 <code>@RefreshScope</code> 注解的 Bean 的刷新，Spring Cloud Context 还提供了一个 Actuator 端点——<code>RefreshEndpoint</code>。如果没有调整过 Actuator 的 URL，可以通过 <code>/actuator/refresh</code> 来触发 <code>ContextRefresher</code> 刷新这些 Bean。让我们通过一个例子来看看如何实现配置快速生效。</p>\n<blockquote>\n<p><strong>需求描述</strong>　现在流行一句话—“让听得到炮声的人来决策”。如果门店的店长发现同一条街上又新开了家奶茶店，可以临时决定调整营业时间和折扣力度，而且有权要求即刻生效。</p>\n</blockquote>\n<p>在二进制奶茶店的例子中，这个需求可以翻译为“能够按需调整 <code>binarytea.open-hours</code> 和 <code>binarytea.discount</code> 的值，并且快速生效”。在 14.1.2 节里，这两个参数都已经被我们放到 Spring Cloud Config Server 对应的仓库里了，现在要做的就是调整 BinaryTea 的代码。<span class=\"comment-number\">7</span></p>\n<p>首先，在 <code>binarytea.*</code> 配置对应的 <code>BinaryTeaProperties</code> 里增加折扣的属性，同时为它加上 <code>@RefreshScope</code> 注解以便后续可以刷新配置，具体如代码示例 14-6 所示。</p>\n<blockquote>\n<p><strong>代码示例 14-6</strong>　增加了注解和属性的 <code>BinaryTeaProperties</code> 代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@ConfigurationProperties(\"binarytea\")\n@RefreshScope\npublic class BinaryTeaProperties {\n    private boolean ready;\n    private String openHours;\n    private int discount = 100;\n    // 省略其他代码\n}</code></pre>\n<p>接下来，需要调整与折扣相关的代码逻辑。本来折扣都是通过 <code>HTTP</code> 请求提交上来的，现在我们要增加一个逻辑：如果请求中给出的折扣是 100（也就是不打折），而我们在后台配置了一个折扣，那就要以后台配置的折扣为准；如果前台传入了具体的折扣，则以传入的为准。这段逻辑可以放在 <code>OrderService.createOrder()</code> 里，具体如代码示例 14-7 所示。</p>\n<blockquote>\n<p><strong>代码示例 14-7</strong>　增加了折扣逻辑的 <code>OrderService</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Service\n@Transactional\npublic class OrderService {\n    @Autowired\n    private OrderRepository orderRepository;\n    @Autowired\n    private BinaryTeaProperties binaryTeaProperties;\n\n    @RolesAllowed({ \"MANAGER\", \"TEA_MAKER\" })\n    public Order createOrder(List&lt;MenuItem&gt; itemList, int discount) {\n        int newDiscount = discount == 100 ? binaryTeaProperties.getDiscount() : discount;\n        Money total = itemList.stream().map(i -&gt; i.getPrice())\n            .collect(Collectors.collectingAndThen(Collectors.toList(),\n                l -&gt; Money.total(l)));\n        Money pay = total.multipliedBy(newDiscount / 100d, RoundingMode.HALF_DOWN);\n\n        Amount amount = Amount.builder()\n                                .discount(newDiscount)\n                                .totalAmount(total)\n                                .payAmount(pay)\n                                .build();\n        Order order = Order.builder()\n                             .amount(amount)\n                             .status(OrderStatus.ORDERED)\n                             .items(itemList)\n                             .build();\n        return orderRepository.save(order);\n    }\n    // 省略其他代码\n}</code></pre>\n<p>最后，为了让配置的变更能快速生效，我们打算通过 <code>/actuator/refresh</code> 来手动触发刷新，为此，还需要将它暴露在 Web 端点里，所以要像代码示例 14-8 那样，调整 <code>application.properties</code> 里的端点配置，增加 <code>refresh</code>。</p>\n<blockquote>\n<p><strong>代码示例 14-8</strong>　调整后的端点配置</p>\n</blockquote>\n<pre class=\"code-rows\"><code>management.endpoints.web.exposure.include=health,info,shop,metrics,refresh</code></pre>\n<p>在运行程序后，一开始我们取到的折扣是 100，然后调整一下 <code>binarytea.properties</code> 中的 <code>binarytea.discount</code> 配置，像下面这样用 curl 命令强制刷新一下，程序里的折扣就改变了：</p>\n<pre class=\"code-rows\"><code>▸ curl -X POST http://localhost:8080/actuator/refresh</code></pre>\n<p>像 Spring Cloud Config Client 这种主动去加载配置的客户端，想要感知配置是否发生了变化只能不断尝试加载远端的配置，这种方式比较低效。好在 Spring Cloud Config Server 在这方面也做了一些工作，对于那些支持 WebHook 发送变更通知的仓库，它可以向客户端推送通知，这里需要用到 Spring Cloud Bus。稍后在介绍其他配置中心时，我们会看到，由于那些设施本身就有监听和通知的功能，这个功能会更容易实现。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_224\">14.2.2　基于 Zookeeper 的配置中心</h3>\n<p>本章前面的部分一直在介绍使用 Spring Cloud Config Server 来实现服务配置的管理，其实除了它，Spring Cloud Config 还支持好几种配置中心，例如我们之前用作服务注册中心的 Apache Zookeeper。在 Zookeeper 官网的介绍中，第一条就说它是一款用于维护配置信息的集中化服务 <span class=\"comment-number\">8</span>，所以拿它来做配置中心应该没有太大问题。我们要做的仅仅是将之前存放在 Git 仓库里的配置按照一定的结构保存到 Zookeeper 中，让应用程序直接连上 Zookeeper 获取配置即可。</p>\n\n<ol>\n<li><p><strong>客户端启用 Zookeeper 配置支持</strong></p>\n<p>在应用的 pom.xml 中，增加 <code>spring-cloud-starter-zookeeper-config</code> 依赖，其中会传递依赖 Apache Curator 和 Apache Zookeeper 的库，如果这些库与正在使用的 Zookeeper 有版本不兼容的情况，可以手动排除 <code>org.apache.zookeeper:zookeeper</code>，再引入对应的版本。</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-zookeeper-config&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>随后，在 <code>application.properties</code> 中配置与之前类似的 <code>spring.config.import</code>，只不过这次我们要用 <code>zookeeper:</code>，而不是 <code>configserver:</code>。格式大概是下面这样的，<code>optional:</code> 表示是否是可选配置，导入不成功可以跳过。</p>\n<pre class=\"code-rows\"><code>spring.config.import=[optional:]zookeeper:[Zookeeper连接串]</code></pre>\n<p>如果同时还用 Zookeeper 来做服务注册中心，两个 Zookeeper 正好又是公用的，我们可以直接使用 <code>spring.cloud.zookeeper.connect-string</code> 来配置连接串；如果是不同的，那用作配置中心的 Zookeeper 连接串可以直接写在 <code>spring.config.import</code> 里。我们的 BinaryTea 项目的配置文件可以像代码示例 14-9<span class=\"comment-number\">9</span> 那样稍作调整，从 Zookeeper 中获取配置。</p>\n<blockquote>\n<p><strong>代码示例 14-9</strong>　从 <code>localhost:2181</code> 导入配置的 <code>application.properties</code> 文件片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.application.name=binarytea\n\nspring.config.import=zookeeper:\nspring.cloud.zookeeper.connect-string=localhost:2181\n# 省略其他配置</code></pre>\n<p>如果希望使用 Bootstrap 方式，和 14.1.3 里介绍的一样，选用三种启用 Bootstrap 方式中的一种，随后将 <code>spring.cloud.zookeeper.config.*</code> 相关的配置放到 <code>bootstrap.properties</code> 文件里就行了。表 14-5 中罗列了一些常用的 Spring Cloud Zookeeper Config 配置项。</p>\n<p><strong>表 14-5　Spring Cloud Zookeeper Config 的常用配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>spring.cloud.zookeeper.config.enabled</code></td><td><code>true</code></td><td>是否开启 Zookeeper 配置支持</td></tr><tr><td><code>spring.cloud.zookeeper.config.root</code></td><td><code>config</code></td><td>Zookeeper 中保存配置的根路径</td></tr><tr><td><code>spring.cloud.zookeeper.config.default-context</code></td><td><code>application</code></td><td>默认配置的应用名</td></tr><tr><td><code>spring.cloud.zookeeper.config.profile-separator</code></td><td><code>,</code></td><td>Profile 分隔符</td></tr><tr><td><code>spring.cloud.zookeeper.config.fail-fast</code></td><td><code>true</code></td><td>无法加载时是否快速失败</td></tr></table>\n\n<p>请注意，此时先不要启动项目，因为我们还没有在 Zookeeper 里放配置项，也没有在 <code>spring.config.import</code> 里加 <code>optional:</code> 前缀，<code>application.properties</code> 里也没有之前 Git 仓库里的配置，总之就是会启动失败。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置信息在 Zookeeper 中的存储结构</strong></p>\n<p>在 Zookeeper 中，我们的配置是按 <code>/config/</code> 应用名 <code>[,Profile]/key=value</code> 的结构来保存的，其中的 Profile 部分属于可选项，看过表 14-5 之后，相信大家应该能看出些端倪：</p>\n<ul>\n<li><code>config</code> 是 <code>spring.cloud.zookeeper.config.root</code> 的值，所以想改成 <code>/configuration/ 应用名 , Profile/</code> 也是可以的；</li>\n<li>应用名和 Profile 之间用 <code>,</code> 隔开，可以用 <code>spring.cloud.zookeeper.config.profile-separator</code> 来修改分隔符；</li>\n<li><code>spring.cloud.zookeeper.config.default-context</code> 默认是 <code>application</code>，所以默认配置可以放在 <code>/config/application/</code> 下。</li>\n</ul>\n<p>我们可以用 Zookeeper 里自带的 zkCli.sh 客户端连上 Zookeeper<span class=\"comment-number\">10</span>，通过命令方式做些配置的导入，例如下面这些命令。不像之前用的 Spring Cloud Config Server，暂时我们还<strong>不能</strong>在 Zookeeper 上实现敏感配置信息的“自动”加解密，所以只能以<strong>明文</strong>存储；如果确实有需要，请在客户端自行实现密文配置项的解密工作吧。</p>\n<pre class=\"code-rows\"><code>create /config/binarytea\ncreate /config/binarytea/binarytea.ready true\ncreate /config/binarytea/binarytea.open-hours 9:00-21:00\ncreate /config/binarytea/binarytea.discount 60\ncreate /config/binarytea/spring.security.user.name binarytea\ncreate /config/binarytea/spring.security.user.password showmethemoney\ncreate /config/binarytea/jwt.secret gR6cytlUlgMfVh08nLFZf8hMk4mdJDX5rWBVlsCbKvRlWcLwNRU6+rIPcLx21x191kJg\nP8udtoZuHt5yUDWtgg==</code></pre>\n<p>如果对 Zookeeper 中的某个配置值做了变更，不用再去调用 <code>/actuator/refresh</code> 也能生效，因为我们的程序会监听对应配置的 Zookeeper 节点，所以应用程序能收到 Zookeeper 的变更推送，具体的代码在 Spring Cloud Zookeeper Config 的 <code>ConfigWatcher</code> 类中。现在可以启动前面修改过的 BinaryTea 程序了，看看它是否如预期的那样获取到配置，并且正常运行了呢？</p>\n</li>\n</ol>\n\n\n<h3 id=\"nav_point_225\">14.2.3　基于 Consul 的配置中心</h3>\n<p>看过了基于 Zookeeper 的用法，我们再来看看怎么用 Consul 来充当配置中心，要知道 Consul 也是可以提供 KV 存储服务的。在 Spring Cloud Config 的统一抽象下，应用里使用 Consul 和 Zookeeper 从代码层面来看几乎没有区别，修改下依赖和配置即可。</p>\n<ol>\n<li><p><strong>客户端启用 Consul 配置支持</strong></p>\n<p>与之前一样，先在 pom.xml 中引入 Consul 配置相关的 <code>spring-cloud-starter-consul-config</code> 依赖：</p>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-consul-config&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>\n<p>随后，在 <code>application.properties</code> 中配置 Consul 相关信息，以及 <code>spring.config.import</code>，这次的格式是下面这样的：</p>\n<pre class=\"code-rows\"><code>spring.config.import=[optional:]consul:[Consul Agent地址]</code></pre>\n<p>如果要用 Bootstrap 的方式，先用 14.1.3 里介绍的方法启用相关的支持，随后像代码示例 14-10 这样配置 <code>bootstrap.properties</code>。<span class=\"comment-number\">11</span></p>\n<blockquote>\n<p><strong>代码示例 14-10</strong>　增加了 Consul 相关配置的 <code>bootstrap.properties</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.application.name=binarytea\n\nspring.cloud.consul.host=localhost\nspring.cloud.consul.port=8500\nspring.cloud.consul.config.enabled=true</code></pre>\n<p>其实上面 3 个 Consul 相关的配置项都是默认值，这里只是为了做演示才写的，表 14-6 列举了常用的 Consul 服务配置有关的配置项。</p>\n<p><strong>表 14-6　Spring Cloud Consul Config 相关配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>spring.cloud.consul.config.enabled</code></td><td><code>true</code></td><td>是否开启 Consul 配置支持</td></tr><tr><td><code>spring.cloud.consul.config.name</code></td><td><code>$</code></td><td>Consul 中存储配置的对应名称</td></tr><tr><td><code>spring.cloud.consul.config.prefixes</code></td><td><code>config</code></td><td>Consul 中配置的前缀，可以配置一个列表</td></tr><tr><td><code>spring.cloud.consul.config.format</code></td><td><code>KEY_VALUE</code></td><td>Consul 中配置的存储格式，下文会对其中的集中格式做详细说明</td></tr><tr><td><code>spring.cloud.consul.config.data-key</code></td><td><code>data</code></td><td>在使用 YAML 和 PROPERTIES 格式时，在 Consul 中保存数据的键名</td></tr><tr><td><code>spring.cloud.consul.config.default-context</code></td><td><code>application</code></td><td>默认配置使用的应用名</td></tr><tr><td><code>spring.cloud.consul.config.profile-separator</code></td><td><code>,</code></td><td>Profile 分隔符</td></tr><tr><td><code>spring.cloud.consul.config.fail-fast</code></td><td><code>true</code></td><td>无法加载时是否快速失败</td></tr><tr><td><code>spring.cloud.consul.config.watch.enabled</code></td><td><code>true</code></td><td>是否开启变更监测</td></tr><tr><td><code>spring.cloud.consul.config.watch.delay</code></td><td><code>1000</code></td><td>两次监测之间的间隔时间，单位为毫秒</td></tr><tr><td><code>spring.cloud.consul.config.watch.wait-time</code></td><td><code>55</code></td><td>对 Consul 发起阻塞查询的等待时间，有些查询支持长连接等待，这个时间要小于请求超时时间，单位为秒</td></tr></table>\n\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置信息在 Consul 中的存储结构</strong></p>\n<p>与 Zookeeper 相似，Consul 在保存配置项时采用类似的目录结构，形如 <code>config/&lt; 应用名 &gt;[,Profile]/</code>。默认配置项都放在 <code>application</code> 应用下，类似前缀、默认应用、Profile 分隔符这些内容都可以用表 14-6 中的配置项来调整。在 Consul 中保存配置时有以下 4 种格式可供选择，它们被定义在 <code>ConsulConfigProperties.Format</code> 枚举中，可以通过 <code>spring.cloud.consul.config.format</code> 配置项进行调整。</p>\n<ul>\n<li><code>KEY_VALUE</code>，键值对格式，以 <code>/config/binarytea/foo/bar/baz</code> 的形式来表示 <code>binarytea</code> 应用下的 <code>foo.bar.baz</code> 配置项，其中的值就是配置值。</li>\n<li><code>PROPERTIES</code>，Properties 格式，<code>binarytea</code> 应用的配置会集中存放在 <code>/config/binarytea/data</code> 中，其中的 <code>data</code> 可以用 <code>spring.cloud.consul.config.data-key</code> 来修改。</li>\n<li><code>YAML</code>，YAML 格式，存放的位置与 <code>PROPERTIES</code> 相同，只是内容格式不同。</li>\n<li><code>FILES</code>，文件格式，在用 git2consul 这类把 Git 文件载入 Consul 的工具时使用。</li>\n</ul>\n<p>我们先来演示一下如何用 <code>KEY_VALUE</code> 格式存储配置。在 Consul Web 界面的 Key/Value 中，按表 14-7 来创建对应的键并填值。由于 <code>spring.cloud.consul.config.format</code> 的默认值就是 <code>KEY_VALUE</code>，所以可以直接依赖默认值或者明确写出格式。运行程序查看是否能正常获取到配置值。</p>\n<p><strong>表 14-7　用于二进制奶茶店的键值类型的 Consul 配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>键</th><th>对应配置</th><th>值</th></tr><tr><td><code>config/binarytea/binarytea/ready</code></td><td><code>binarytea.ready</code></td><td><code>true</code></td></tr><tr><td><code>config/binarytea/binarytea/open-hours</code></td><td><code>binarytea.open-hours</code></td><td><code>9:00-21:00</code></td></tr><tr><td><code>config/binarytea/binarytea/discount</code></td><td><code>binarytea.discount</code></td><td><code>60</code></td></tr><tr><td><code>config/binarytea/spring/security/user/name</code></td><td><code>spring.security.user.name</code></td><td><code>binarytea</code></td></tr><tr><td><code>config/binarytea/spring/security/user/password</code></td><td><code>spring.security.user.password</code></td><td><code>showmethemoney</code></td></tr><tr><td><code>config/binarytea/jwt/secret</code></td><td><code>jwt.secret</code></td><td>与前文 <code>jwt.secret</code> 相同</td></tr></table>\n\n<p>随后再来看看使用 <code>YAML</code> 格式又该怎么存储？同样是在 Key/Value 界面中，我们直接创建一个 <code>config/binarytea/data</code> 键，值的内容如代码示例 14-11 所示（注意缩进必须用空格，不能用 Tab）。</p>\n<blockquote>\n<p><strong>代码示例 14-11</strong>　<code>config/binarytea/data</code> 节点中写入的 YAML 配置信息</p>\n</blockquote>\n<pre class=\"code-rows\"><code>binarytea:\n    ready: true\n    open-hours: 9:00-21:00\n    discount: 60\nspring:\n    security:\n        user:\n            name: binarytea\n            password: showmethemoney\njwt:\n    secret: gR6cytlUlgMfVh08nLFZf8hMk4mdJDX5rWBVlsCbKvRlWcLwNRU6+rIPcLx21x191kJgP8udtoZuHt5yUDWtgg==</code></pre>\n<p>这时需要将 <code>spring.cloud.consul.config.format</code> 的值改为 <code>YAML</code>，随后重新启动程序观察运行效果。同样地，Consul 上配置内容的变更也能在应用端自动刷新。</p>\n</li>\n</ol>\n\n<h3 id=\"nav_point_226\">14.2.4　基于 Alibaba Nacos 的配置中心</h3>\n<p>Spring Cloud 对阿里巴巴组件的支持基本都是由阿里的开发者维护的，所以 Spring Cloud Alibaba Nacos Config 会和前面谈到的 Zookeeper 与 Consul 稍有不同。</p>\n<ol>\n<li><p><strong>客户端启用 Nacos 配置支持</strong></p>\n<p>第一步的操作，大家大同小异，都是在 pom.xml 中引入依赖，只不过这次需要在 <code>&lt;dependencyManagement /&gt;</code> 里多导入一个 pom。大概会是下面这样的，其中 <code>spring-cloud-dependencies</code> 是之前一直在用的，而 <code>spring-cloud-alibaba-dependencies</code> 则专门用来管理 Spring Cloud Alibaba 的依赖，两者作用不同。之前在介绍基于 Nacos 的服务注册与发现机制时介绍过了，这里再次强调一下。</p>\n<pre class=\"code-rows\"><code>&lt;dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;$&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;\n            &lt;version&gt;$&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n&lt;/dependencyManagement&gt;\n\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- 省略其他依赖 --&gt;\n&lt;/dependencies&gt;</code></pre>\n<p><code>spring-cloud-starter-alibaba-nacos-config</code> 是专门用来支持 Nacos 服务配置的依赖，也是这部分的重点，由于 2.2.1.RELEASE 版本的 Spring Cloud Alibaba 暂时还不支持 <code>spring.config.import</code> 方式，所以只能使用传统的 Bootstrap 方式，因此可以考虑像上面那样多加一个 <code>spring-cloud-starter-bootstrap</code>。如果是 2021.0.1.0 版本，则已经支持 <code>spring.config.import</code> 方式了，可以根据实际使用的版本来选择配置导入的方式。</p>\n<p>接下来就是配置 <code>bootstrap.properties</code>，其中需要配置 Nacos 服务器的地址，还有一些 Nacos Config 相关的配置，当然，用默认值通常也行，就像代码示例 14-12<span class=\"comment-number\">12</span> 那样。</p>\n<blockquote>\n<p><strong>代码示例 14-12</strong>　开启了 Nacos Config 的 <code>bootstrap.properties</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>spring.application.name=binarytea\n\nspring.cloud.nacos.config.server-addr=http://localhost:8848\nspring.cloud.nacos.config.enabled=true\nspring.cloud.nacos.config.file-extension=yaml</code></pre>\n<p>Spring Cloud Alibaba Nacos Config 也有很多可以设置的参数，表 14-8 就罗列了一些可能用到的配置项。</p>\n<p><strong>表 14-8　Spring Cloud Alibaba Nacos Config 的常用配置项</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>spring.cloud.nacos.config.enabled</code></td><td><code>true</code></td><td>是否开启 Nacos 配置</td></tr><tr><td><code>spring.cloud.nacos.config.server-addr</code></td><td><code>localhost:8848</code></td><td>提供配置服务的 Nacos 地址</td></tr><tr><td><code>spring.cloud.nacos.config.prefix</code></td><td></td><td>用来配置 <code>dataId</code> 前缀，先取 <code>prefix</code>，再取 <code>name</code>，没有再用 <code>$</code><sup><b>13</b></sup></td></tr><tr><td><code>spring.cloud.nacos.config.name</code></td><td></td><td>同上</td></tr><tr><td><code>spring.cloud.nacos.config.group</code></td><td><code>DEFAULT_GROUP</code></td><td>配置所用的组</td></tr><tr><td><code>spring.cloud.nacos.config.cluster-name</code></td><td></td><td>集群名</td></tr><tr><td><code>spring.cloud.nacos.config.namespace</code></td><td></td><td>Nacos 中配置的名字空间，默认有个 <code>Public</code> 名字空间</td></tr><tr><td><code>spring.cloud.nacos.config.timeout</code></td><td><code>3000</code></td><td>连接 Nacos 的超时时间，单位为秒</td></tr><tr><td><code>spring.cloud.nacos.config.file-extension</code></td><td><code>properties</code></td><td>配置内容的后缀，会和 <code>dataId</code> 的前缀合并，支持 <code>properties</code> 和 <code>yaml</code></td></tr><tr><td><code>spring.cloud.nacos.config.shared-configs</code></td><td></td><td>共享配置，是个 <code>Config</code> 类型的列表，需要具体设置里面的值</td></tr><tr><td><code>spring.cloud.nacos.config.extension-configs</code></td><td></td><td>扩展配置，是个 <code>Config</code> 类型的列表，需要具体设置里面的值</td></tr><tr><td><code>spring.cloud.nacos.config.refresh.enabled</code></td><td><code>true</code></td><td>是否开启配置刷新</td></tr><tr><td><code>spring.cloud.nacos.config.accessKey</code></td><td></td><td>阿里云账号的 Access Key，使用阿里云时配置</td></tr><tr><td><code>spring.cloud.nacos.config.secretKey</code></td><td></td><td>阿里云账号的 Secret Key，使用阿里云时配置</td></tr></table>\n\n<blockquote>\n<p><sup><b>13</b></sup>具体可以参考 <code>NacosPropertySourceLocator</code> 类。</p>\n</blockquote>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置信息在 Nacos 中的存储结构</strong></p>\n<p>在 Nacos 中保存配置时，也有一些与 Zookeeper 和 Consul 不同的规则，例如配置的加载顺序就是下面这样的，后面加载的配置优先级高于前面的。</p>\n<p>(1) 从 <code>spring.cloud.nacos.config.shared-configs</code> 配置的 <code>Config</code> 中加载配置。</p>\n<p>(2) 从 <code>spring.cloud.nacos.config.extension-configs</code> 配置的 <code>Config</code> 中加载配置。</p>\n<p>(3) 从应用自己的 <code>dataId</code> 中加载配置，默认组合规则为 <code>$[-Profile].</code> 后缀。</p>\n<p>仍然以 BinaryTea 项目为例，我们可以在 Nacos 控制台中创建一个 <code>binarytea</code> 节点，具体如图 14-2 所示，其中填入的 YAML 配置和代码示例 14-11 是一样的。根据代码示例 14-12 的配置，我们的程序最终会在 <code>DEFAULT_GROUP</code> 中找到 <code>binarytea.yaml</code>，从这个文件中加载配置。在开启了配置刷新功能后，Nacos 上的配置变更也能自动生效。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100008/image00796.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 14-2　Nacos 里的二进制奶茶店配置</strong></p>\n</li>\n</ol>\n\n<h2 id=\"nav_point_227\">14.3　小结</h2>\n<p>本章我们了解了在微服务系统中如何管理服务的配置。出于各方面考虑，复杂的微服务系统需要能够方便地管理各种配置，还要让配置的变更及时生效。Spring Cloud Config 就是专门用来解决这个问题的，我们大致介绍了它的实现机制。在实践中，无论是 Spring Cloud Config Server、Zookeeper、Consul，还是 Nacos，抑或是本书中未展开介绍的 Apollo，都是不错的选择。</p>\n<p>下一章，我们会切换到与高可用和稳定性相关的话题上。对于由大量微服务构成的业务，如果当中某些节点出了问题该怎么办，流量太大了该怎么办，又如何让系统自动应对这类情况呢？</p>\n<blockquote>\n<p style=\"text-align: center\"><strong>二进制奶茶店项目开发小结</strong></p>\n<p>到目前为止，我们的重点还是在二进制奶茶店点单系统的建设上。单实例无法满足业务量时，可以扩展为集群，变成集群后又需要负载均衡。Spring Cloud 的服务注册与发现机制可以很好地解决集群实例管理的问题，客户端系统可以很方便地找到下单服务。<span class=\"comment-number\">14</span></p>\n<p>系统变复杂了之后，各种配置的管理也要跟上，像改个营业时间、订单折扣，这些动作都要高效快捷。用配置文件能解决一部分问题，毕竟比什么都写死在代码里强，但还远远不够。这时引入 Spring Cloud Config，既能保留配置文件的体验，又能实现大规模系统配置集中化管理，还“顺带”实现了配置变更快速生效。</p>\n<p>无论是服务的注册与发现，还是服务的配置管理，我们都没有被绑死在特定的基础设施上—Zookeeper、Consul 和 Nacos 都在我们的候选列表里，可以根据情况选择。</p>\n</blockquote>\n\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 14 章 服务配置管理(1)","id":740889},"right":{"article_title":"第 15 章 服务容错保护(1)","id":740891}},"comments":[]}