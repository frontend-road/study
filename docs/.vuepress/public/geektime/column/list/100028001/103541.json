{"id":103541,"title":"17 | 并发容器的使用：识别不同场景下最优容器","content":"<p>你好，我是刘超。</p><p>在并发编程中，我们经常会用到容器。今天我要和你分享的话题就是：在不同场景下我们该如何选择最优容器。</p><h2>并发场景下的Map容器</h2><p>假设我们现在要给一个电商系统设计一个简单的统计商品销量TOP 10的功能。常规情况下，我们是用一个哈希表来存储商品和销量键值对，然后使用排序获得销量前十的商品。在这里，哈希表是实现该功能的关键。那么请思考一下，如果要你设计这个功能，你会使用哪个容器呢？</p><p>在07讲中，我曾详细讲过HashMap的实现原理，以及HashMap结构的各个优化细节。我说过HashMap的性能优越，经常被用来存储键值对。那么这里我们可以使用HashMap吗？</p><p>答案是不可以，我们切忌在并发场景下使用HashMap。因为在JDK1.7之前，在并发场景下使用HashMap会出现死循环，从而导致CPU使用率居高不下，而扩容是导致死循环的主要原因。虽然Java在JDK1.8中修复了HashMap扩容导致的死循环问题，但在高并发场景下，依然会有数据丢失以及不准确的情况出现。</p><p><span class=\"orange\">这时为了保证容器的线程安全，Java实现了Hashtable、ConcurrentHashMap以及ConcurrentSkipListMap等Map容器。</span></p><!-- [[[read_end]]] --><p>Hashtable、ConcurrentHashMap是基于HashMap实现的，对于小数据量的存取比较有优势。</p><p>ConcurrentSkipListMap是基于TreeMap的设计原理实现的，略有不同的是前者基于跳表实现，后者基于红黑树实现，ConcurrentSkipListMap的特点是存取平均时间复杂度是O（log（n）），适用于大数据量存取的场景，最常见的是基于跳跃表实现的数据量比较大的缓存。</p><p>回归到开始的案例再看一下，如果这个电商系统的商品总量不是特别大的话，我们可以用Hashtable或ConcurrentHashMap来实现哈希表的功能。</p><h3>Hashtable 🆚 ConcurrentHashMap</h3><p>更精准的话，我们可以进一步对比看看以上两种容器。</p><p>在数据不断地写入和删除，且不存在数据量累积以及数据排序的场景下，我们可以选用Hashtable或ConcurrentHashMap。</p><p>Hashtable使用Synchronized同步锁修饰了put、get、remove等方法，因此在高并发场景下，读写操作都会存在大量锁竞争，给系统带来性能开销。</p><p>相比Hashtable，ConcurrentHashMap在保证线程安全的基础上兼具了更好的并发性能。在JDK1.7中，ConcurrentHashMap就使用了分段锁Segment减小了锁粒度，最终优化了锁的并发操作。</p><p>到了JDK1.8，ConcurrentHashMap做了大量的改动，摒弃了Segment的概念。由于Synchronized锁在Java6之后的性能已经得到了很大的提升，所以在JDK1.8中，Java重新启用了Synchronized同步锁，通过Synchronized实现HashEntry作为锁粒度。这种改动将数据结构变得更加简单了，操作也更加清晰流畅。</p><p>与JDK1.7的put方法一样，JDK1.8在添加元素时，在没有哈希冲突的情况下，会使用CAS进行添加元素操作；如果有冲突，则通过Synchronized将链表锁定，再执行接下来的操作。</p><p><img src=\"https://static001.geekbang.org/resource/image/42/92/42b1a374f1d35789024291a4141d6192.png?wh=1027*461\" alt=\"\"></p><p>综上所述，我们在设计销量TOP10功能时，首选ConcurrentHashMap。</p><p>但要注意一点，虽然ConcurrentHashMap的整体性能要优于Hashtable，但在某些场景中，ConcurrentHashMap依然不能代替Hashtable。例如，在强一致的场景中ConcurrentHashMap就不适用，原因是ConcurrentHashMap中的get、size等方法没有用到锁，ConcurrentHashMap是弱一致性的，因此有可能会导致某次读无法马上获取到写入的数据。</p><h3>ConcurrentHashMap 🆚 ConcurrentSkipListMap</h3><p>我们再看一个案例，我上家公司的操作系统中有这样一个功能，提醒用户手机卡实时流量不足。主要的流程是服务端先通过虚拟运营商同步用户实时流量，再通过手机端定时触发查询功能，如果流量不足，就弹出系统通知。</p><p>该功能的特点是用户量大，并发量高，写入多于查询操作。这时我们就需要设计一个缓存，用来存放这些用户以及对应的流量键值对信息。那么假设让你来实现一个简单的缓存，你会怎么设计呢？</p><p>你可能会考虑使用ConcurrentHashMap容器，但我在07讲中说过，该容器在数据量比较大的时候，链表会转换为红黑树。红黑树在并发情况下，删除和插入过程中有个平衡的过程，会牵涉到大量节点，因此竞争锁资源的代价相对比较高。</p><p>而跳跃表的操作针对局部，需要锁住的节点少，因此在并发场景下的性能会更好一些。你可能会问了，在非线程安全的Map容器中，我并没有看到基于跳跃表实现的SkipListMap呀？这是因为在非线程安全的Map容器中，基于红黑树实现的TreeMap在单线程中的性能表现得并不比跳跃表差。</p><p>因此就实现了<span class=\"orange\">在非线程安全的Map容器中，用TreeMap容器来存取大数据；在线程安全的Map容器中，用SkipListMap容器来存取大数据。</span></p><p>那么ConcurrentSkipListMap是如何使用跳跃表来提升容器存取大数据的性能呢？我们先来了解下跳跃表的实现原理。</p><p><strong>什么是跳跃表</strong></p><p>跳跃表是基于链表扩展实现的一种特殊链表，类似于树的实现，跳跃表不仅实现了横向链表，还实现了垂直方向的分层索引。</p><p>一个跳跃表由若干层链表组成，每一层都实现了一个有序链表索引，只有最底层包含了所有数据，每一层由下往上依次通过一个指针指向上层相同值的元素，每层数据依次减少，等到了最顶层就只会保留部分数据了。</p><p>跳跃表的这种结构，是利用了空间换时间的方法来提高了查询效率。程序总是从最顶层开始查询访问，通过判断元素值来缩小查询范围。我们可以通过以下几张图来了解下跳跃表的具体实现原理。</p><p>首先是一个初始化的跳跃表：</p><p><img src=\"https://static001.geekbang.org/resource/image/42/80/42f26c3109f56803a8f19bf7fb181c80.jpg?wh=2330*520\" alt=\"\"></p><p>当查询key值为9的节点时，此时查询路径为：</p><p><img src=\"https://static001.geekbang.org/resource/image/21/eb/21b0cc4361d662642bddbaf773931feb.jpg?wh=2370*524\" alt=\"\"></p><p>当新增一个key值为8的节点时，首先新增一个节点到最底层的链表中，根据概率算出level值，再根据level值新建索引层，最后链接索引层的新节点。新增节点和链接索引都是基于CAS操作实现。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/1f/d8de8217c34be6af856773b63c7b7e1f.jpg?wh=2366*494\" alt=\"\"></p><p>当删除一个key值为7的结点时，首先找到待删除结点，将其value值设置为null；之后再向待删除结点的next位置新增一个标记结点，以便减少并发冲突；然后让待删结点的前驱节点直接越过本身指向的待删结点，直接指向后继结点，中间要被删除的结点最终将会被JVM垃圾回收处理掉；最后判断此次删除后是否导致某一索引层没有其它节点了，并视情况删除该层索引 。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/11/a76f5f8f4fcf23a6f0785d0412bfb911.jpg?wh=2360*420\" alt=\"\"></p><p>通过以上两个案例，我想你应该清楚了Hashtable、ConcurrentHashMap以及ConcurrentSkipListMap这三种容器的适用场景了。</p><p><span class=\"orange\">如果对数据有强一致要求，则需使用Hashtable；在大部分场景通常都是弱一致性的情况下，使用ConcurrentHashMap即可；如果数据量在千万级别，且存在大量增删改操作，则可以考虑使用ConcurrentSkipListMap。</span></p><h2>并发场景下的List容器</h2><p>下面我们再来看一个实际生产环境中的案例。在大部分互联网产品中，都会设置一份黑名单。例如，在电商系统中，系统可能会将一些频繁参与抢购却放弃付款的用户放入到黑名单列表。想想这个时候你又会使用哪个容器呢？</p><p>首先用户黑名单的数据量并不会很大，但在抢购中需要查询该容器，快速获取到该用户是否存在于黑名单中。其次用户ID是整数类型，因此我们可以考虑使用数组来存储。那么ArrayList是否是你第一时间想到的呢？</p><p>我讲过ArrayList是非线程安全容器，在并发场景下使用很可能会导致线程安全问题。这时，我们就可以考虑使用Java在并发编程中提供的线程安全数组，包括Vector和CopyOnWriteArrayList。</p><p>Vector也是基于Synchronized同步锁实现的线程安全，Synchronized关键字几乎修饰了所有对外暴露的方法，所以在读远大于写的操作场景中，Vector将会发生大量锁竞争，从而给系统带来性能开销。</p><p>相比之下，CopyOnWriteArrayList是java.util.concurrent包提供的方法，它实现了读操作无锁，写操作则通过操作底层数组的新副本来实现，是一种读写分离的并发策略。我们可以通过以下图示来了解下CopyOnWriteArrayList的具体实现原理。</p><p><img src=\"https://static001.geekbang.org/resource/image/4a/eb/4a7e3d6b77645b3258ba1680aa8087eb.jpg?wh=1762*1094\" alt=\"\"></p><p>回到案例中，我们知道黑名单是一个读远大于写的操作业务，我们可以固定在某一个业务比较空闲的时间点来更新名单。</p><p>这种场景对写入数据的实时获取并没有要求，因此我们只需要保证最终能获取到写入数组中的用户ID就可以了，而CopyOnWriteArrayList这种并发数组容器无疑是最适合这类场景的了。</p><h2>总结</h2><p>在并发编程中，我们经常会使用容器来存储数据或对象。Java在JDK1.1到JDK1.8这个漫长的发展过程中，依据场景的变化实现了同类型的多种容器。我将今天的主要内容为你总结了一张表格，希望能对你有所帮助，也欢迎留言补充。</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/99/6d6371fda6214743d69c54528cd8ff99.jpg?wh=1342*624\" alt=\"\"></p><h2>思考题</h2><p>在抢购类系统中，我们经常会使用队列来实现抢购的排队等待，<span class=\"orange\">如果要你来选择或者设计一个队列，你会怎么考虑呢？</span></p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起学习。</p><p></p>","neighbors":{"left":{"article_title":"16 | 多线程调优（下）：如何优化多线程上下文切换？","id":102974},"right":{"article_title":"18 | 如何设置线程池大小？","id":104094}},"comments":[{"had_liked":false,"id":108175,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1561690813,"is_pvip":false,"replies":[{"id":"39348","content":"对的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561862177,"ip_address":"","comment_id":108175,"utype":1}],"discussion_count":3,"race_medal":0,"score":"181950317245","product_id":100028001,"comment_content":"可以用ConcurrentLinkedQueue，优势如下：<br>1、抢购场景一般都是写多读少，该队列基于链表实现，所以新增和删除元素性能较高<br>2、写数据时通过cas操作，性能较高。<br>但是LinkedQueue有一个普遍存在的问题，就是该队列是无界的，需要控制容量，否则可能引起内存溢出","like_count":43,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455857,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561862177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1230293,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c5/d5/90ca8efe.jpg","nickname":"拉可里啦","note":"","ucode":"26E20DF096BDAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257536,"discussion_content":"请问怎么设置为有界队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588584942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066705,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/d1/a1ddf49f.jpg","nickname":"阿杜","note":"","ucode":"349D3572F5ABE7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":85659,"discussion_content":"同想","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576563752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107929,"user_name":"东方奇骥","can_delete":false,"product_type":"c1","uid":1354850,"ip_address":"","ucode":"DEE7085F7E55A4","user_header":"https://static001.geekbang.org/account/avatar/00/14/ac/62/37912d51.jpg","comment_is_top":false,"comment_ctime":1561635198,"is_pvip":true,"replies":[{"id":"39196","content":"对的，CopyOnWriteArrayList只适合偶尔一两次数据更改的操作。我们很多缓存数据往往是在深夜在没有读操作时，进行修改。这种场景适合使用CopyOnWriteArrayList。<br><br>我们先来理解下happens-before规则中，对锁的规则：<br>一个unLock操作先行发生于后面对同一个锁的lock操作；<br><br>也就是说，ConcurrentHashMap中的get如果有锁操作，在put操作之后，get操作是一定能拿到put后的数据；而实际上get操作时没有锁的，也就是说下面这种情况：<br>void func(){<br>map.put(key1,value1);<br>map.get(key1);<br>.<br>.<br>&#47;&#47;use key1 value to do something<br>}<br>此时，get获取值的可能不是put修改的值，而此时get没有获取到真正要获取的值，此时就是弱一致了。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561692657,"ip_address":"","comment_id":107929,"utype":1}],"discussion_count":6,"race_medal":0,"score":"113230784894","product_id":100028001,"comment_content":"如果数据变动频繁，就不建议使用CopyOnWriteArrayList了，因为每次写都要拷贝一份，代价太大。老师，怎么直观理解强一致性和弱一致性？之前一直觉得ConcurrentHashMap就是用来代替HashTable的，因为HashTable并发时因为同步锁性能差。","like_count":27,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455749,"discussion_content":"对的，CopyOnWriteArrayList只适合偶尔一两次数据更改的操作。我们很多缓存数据往往是在深夜在没有读操作时，进行修改。这种场景适合使用CopyOnWriteArrayList。\n\n我们先来理解下happens-before规则中，对锁的规则：\n一个unLock操作先行发生于后面对同一个锁的lock操作；\n\n也就是说，ConcurrentHashMap中的get如果有锁操作，在put操作之后，get操作是一定能拿到put后的数据；而实际上get操作时没有锁的，也就是说下面这种情况：\nvoid func(){\nmap.put(key1,value1);\nmap.get(key1);\n.\n.\n//use key1 value to do something\n}\n此时，get获取值的可能不是put修改的值，而此时get没有获取到真正要获取的值，此时就是弱一致了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561692657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1037708,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/8c/c0200a17.jpg","nickname":"M#","note":"","ucode":"1C80F782036173","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40203,"discussion_content":"您的例子可以理解，但是map中的值都是被volatile修饰过的，volatile可以保证hp的，这个说法对吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572103948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1136420,"avatar":"https://static001.geekbang.org/account/avatar/00/11/57/24/2d942948.jpg","nickname":"Eaglet","note":"","ucode":"AC20EDC1204860","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3195,"discussion_content":"老师，你这个举得这个例子我还是不太理解， 在同一个方法中，程序总是线性执行的把，先 put，再 get，get 总能拿到最新值吧？\n您这里意思是不是这样的，两个线程A和 B，A线程获取了 put 锁进入 put 方法去修改数据，与此同时，B线程后 A 一步执行同一段代码段，这时候 A 继续往下执行get 方法，只能 get 到自己修改的，B 刚刚修改的最新数据 A 可能就 get 不到了，是这样吗？\n请老师解惑，谢谢老师","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1564294278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2055554,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","nickname":"keep_it_real","note":"","ucode":"F5057CAF752FF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577004,"discussion_content":"Node类型的table加了volatile修饰词意味着这个table的引用是线程间可见的，但对于里面的元素并不可见，每个线程拿到的都是CPU缓存，在修改后同步到内存之前，其他线程获取到的值都是修改前的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655880174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1759325,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","nickname":"杯莫停","note":"","ucode":"4FA1D5CBBEF702","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2055554,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","nickname":"keep_it_real","note":"","ucode":"F5057CAF752FF3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581295,"discussion_content":"实际上table中存的是对每个Node对象的引用，并不是node对象本身，所以引用被volatile修饰只是意味着 table对象是线程间可见的而node不是。因此线程修改的是CPU缓存中的node的数据，如果还未同步到内存，put操作在没有同步到内存之前 就get不到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658715212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":577004,"ip_address":""},"score":581295,"extra":""}]},{"author":{"id":2055554,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","nickname":"keep_it_real","note":"","ucode":"F5057CAF752FF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577002,"discussion_content":"就是线程A的put还在临界区，线程B的get去获取，获取到的值是A put之前的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655879926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150457,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1573539942,"is_pvip":false,"replies":[{"id":"57991","content":"这跟并发有关系，我们知道ConcurrentHashMap和HashTable都是线程安全的，假设允许key和value为null，有以下代码：<br><br>if (map.containsKey(key)) {&#47;&#47;代码1<br>   return map.get(key);&#47;&#47;代码2<br>} else {<br>   throw new KeyNotPresentException();<br>}<br><br>当在并发情况下，有两个线程分别在操作map容器，此时线程1在运行以上代码，当线程1运行到代码1与代码2中间时，刚好有另外一个线程2执行了map.remove(key)操作，此时继续运行代码2时，依然会返回null值。而此时的null实际上是map中真实的不存在该key值，应该throw new KeyNotPresentException()的。所以为了保证线程安全，这两个Map容器是不允许key和value为null。<br><br>而HashMap是非线程安全的，不存在以上我们所说的并发情况。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573615051,"ip_address":"","comment_id":150457,"utype":1}],"discussion_count":6,"race_medal":0,"score":"100357787750","product_id":100028001,"comment_content":"为什么ConcurrentHashMap和HashTable的key和value不能为空，而HashMap却可以，这么设计的原因是什么呢","like_count":22,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474165,"discussion_content":"这跟并发有关系，我们知道ConcurrentHashMap和HashTable都是线程安全的，假设允许key和value为null，有以下代码：\n\nif (map.containsKey(key)) {//代码1\n   return map.get(key);//代码2\n} else {\n   throw new KeyNotPresentException();\n}\n\n当在并发情况下，有两个线程分别在操作map容器，此时线程1在运行以上代码，当线程1运行到代码1与代码2中间时，刚好有另外一个线程2执行了map.remove(key)操作，此时继续运行代码2时，依然会返回null值。而此时的null实际上是map中真实的不存在该key值，应该throw new KeyNotPresentException()的。所以为了保证线程安全，这两个Map容器是不允许key和value为null。\n\n而HashMap是非线程安全的，不存在以上我们所说的并发情况。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573615051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1304195,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtlEYuHnR8VdRkNPcmkIqTM9DKahpcpicDdBvcmBWMIAAhBrd0QNWvl09slqrzB5TibryVcIfPmb7Q/132","nickname":"raisecomer","note":"","ucode":"32EA488E46471F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301900,"discussion_content":"应该和putIfAbsent方法有关，如果允许null，那么当putIfAbsent返回null时，是map中不存在该键值呢，还是存在一个null的value呢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598704300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","nickname":"每天晒白牙","note":"","ucode":"A1B102CD933DEA","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204835,"discussion_content":"ConcurrentHashMap也会出现老师您说的这种问题吧？两个线程按照上面的顺序执行，也会出现null的情况，还望指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584231857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1254493,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","nickname":"听雨","note":"","ucode":"252754F9FCFF0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","nickname":"每天晒白牙","note":"","ucode":"A1B102CD933DEA","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":205673,"discussion_content":"我想老师的意思是，如果为null不能区分两种情况：一种是值为null，另一种是值不存在。concurrenthashmap插入有一段分支逻辑是通过key找到对应的槽位，如果槽位是null，就插入数据，否则走另一个分支。如果concurrenthashmap的值允许为null，在这种情况下是不能区分的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584330776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204835,"ip_address":""},"score":205673,"extra":""},{"author":{"id":1190150,"avatar":"https://static001.geekbang.org/account/avatar/00/12/29/06/0b327738.jpg","nickname":"Gankki","note":"","ucode":"399C6F74286590","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1004698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","nickname":"每天晒白牙","note":"","ucode":"A1B102CD933DEA","race_medal":1,"user_type":1,"is_pvip":false},"discussion":{"id":224200,"discussion_content":"这是作者Doug Lea关于这个问题的解答http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002485.html\n一：关于老师的回答，首先HashTable中的方法都是用Synchronized，所以在当一个线程获取到锁之后，另外一个线程在代码一和二之间是不能获取到这个对象的锁的，就不存在上面的情况。\n二：ConcurrentHashMap和ConcurrentSkipListHashMap，它们的get方法是不加锁的（containsKey也是根据get方法判断的），如果key/value允许为null，代码一为true则说明存在key为null的键值对，此时在代码一与二之间另外一个线程将这个为null的key删除了，此时代码2返回为null，根据逻辑返回的是key为null的value，实际上key已经被另外一个线程删除，这个时候就有了歧义，关于代码二返回的值，到底是存在key为null的键值对还是不存在是有歧义的。所以为了避免这种歧义，线程安全的Map就不允许key/value为null，不允许了返回为null就是容器中不存在key/value为null的键值对，不用再纠结是key/valueweinull了。\n\n综上：线程安全的map不允许key/value为null，因为在多线程条件下，对于key/value是否真的存在有歧义。\n\n个人理解，仅供参考。","likes_number":14,"is_delete":false,"is_hidden":false,"ctime":1586272559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":204835,"ip_address":""},"score":224200,"extra":""},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190150,"avatar":"https://static001.geekbang.org/account/avatar/00/12/29/06/0b327738.jpg","nickname":"Gankki","note":"","ucode":"399C6F74286590","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381221,"discussion_content":"总结得非常好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624957773,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":224200,"ip_address":""},"score":381221,"extra":""}]}]},{"had_liked":false,"id":107669,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1561594959,"is_pvip":false,"replies":[{"id":"38960","content":"对的，ConcurrentLinkedQueue是基于CAS乐观锁来实现线程安全。ConcurrentLinkedQueue是无界的，所以使用的时候要特别注意内存溢出问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561599206,"ip_address":"","comment_id":107669,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53101202511","product_id":100028001,"comment_content":"抢购的过程中存在并发操作，所以需要用线程安全的容器，同时，抢购的用户会很多，应当使用链表的数据结构，这种场景往往是写多读少，还需要排队，所以 ConcurrentLinkedQueue应该是最合适的","like_count":13,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455619,"discussion_content":"对的，ConcurrentLinkedQueue是基于CAS乐观锁来实现线程安全。ConcurrentLinkedQueue是无界的，所以使用的时候要特别注意内存溢出问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561599206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107988,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1561644040,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48806284296","product_id":100028001,"comment_content":"麻烦老师加餐出个queue并发相关的文章，感激不尽！！！","like_count":12},{"had_liked":false,"id":107745,"user_name":"大雁小鱼","can_delete":false,"product_type":"c1","uid":1101017,"ip_address":"","ucode":"44090581E59FDA","user_header":"https://static001.geekbang.org/account/avatar/00/10/cc/d9/20d4f7c2.jpg","comment_is_top":false,"comment_ctime":1561602885,"is_pvip":false,"replies":[{"id":"39183","content":"因为ConcurrentHashMap有些方法是没有锁的，例如get 方法。假设A修改了数据，而B后于A一瞬间去获取数据，有可能拿到的数据是A修改之前的数据。<br><br>还有 clear foreach方法在操作时，都有可能存在数据不确定性。<br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561690253,"ip_address":"","comment_id":107745,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31626373957","product_id":100028001,"comment_content":"老师，ConcurrentHashMap为啥是弱一致性的？","like_count":7,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455651,"discussion_content":"因为ConcurrentHashMap有些方法是没有锁的，例如get 方法。假设A修改了数据，而B后于A一瞬间去获取数据，有可能拿到的数据是A修改之前的数据。\n\n还有 clear foreach方法在操作时，都有可能存在数据不确定性。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561690253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211199,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1587912878,"is_pvip":false,"replies":[{"id":"78607","content":"虽然Node&lt;k,v&gt;和value被volatile修饰，可以获取到最新值，如果是一个新Node，那么就不能马上在table中看到。虽然Node的数组table被volatile修饰，但是这样只是代表table的引用地址被修改，其他线程可以立马看到，并不代表table里的数据被修改立马可以看到。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1587987059,"ip_address":"","comment_id":211199,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23062749358","product_id":100028001,"comment_content":"ConcurrentHashMap 是弱一致性的，因此有可能会导致某次读无法马上获取到写入的数据。这句话不理解啊，为什么会无法马上获取到写入的数据呢？又不像mysql那样存在事务隔离。","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493218,"discussion_content":"虽然Node&amp;lt;k,v&amp;gt;和value被volatile修饰，可以获取到最新值，如果是一个新Node，那么就不能马上在table中看到。虽然Node的数组table被volatile修饰，但是这样只是代表table的引用地址被修改，其他线程可以立马看到，并不代表table里的数据被修改立马可以看到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587987059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107864,"user_name":"陆离","can_delete":false,"product_type":"c1","uid":1483932,"ip_address":"","ucode":"2C8C206CE36A81","user_header":"https://static001.geekbang.org/account/avatar/00/16/a4/9c/b32ed9e9.jpg","comment_is_top":false,"comment_ctime":1561625201,"is_pvip":false,"replies":[{"id":"39049","content":"多留言哦～说不定在下一期的加餐中就惊现福利了！😎ི","user_name":"编辑回复","user_name_real":"王冬青","uid":"1356014","ctime":1561638350,"ip_address":"","comment_id":107864,"utype":2}],"discussion_count":1,"race_medal":0,"score":"23036461681","product_id":100028001,"comment_content":"这一节要是有Queue就更好了，那几个blockingQueue还是很有意思的","like_count":6,"discussions":[{"author":{"id":1356014,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b0/ee/d0871efd.jpg","nickname":"冬青","note":"","ucode":"14576781B499FB","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455714,"discussion_content":"多留言哦～说不定在下一期的加餐中就惊现福利了！😎ི","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561638350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132244,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568069474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18747938658","product_id":100028001,"comment_content":"还不错，今天认识到ConcurrentHashMap存在数据弱一致性问题，发生弱一致性问题应该是个小概率事件吧!老师清楚大概什么数据量什么概率嘛？<br>老师讲解的不全呀😄JUC中并发容器可多了，最典型的都没讲全，建议列个全一些的对照表更好一些。<br>不过，他们的特点其实和非多线程安全的主要就差在是否安全，然后就是自身结构决定的一些特性啦！<br>比如：读写性能、是否有界、是否阻塞、MAP存储键值对、LIST通常适合写多的场景、QUEUE适合排队等待等等。","like_count":5},{"had_liked":false,"id":107949,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1561639162,"is_pvip":false,"replies":[{"id":"39186","content":"1、两者的平均查询复杂度都是O(logn)，所以查询性能差不多。而在新增和删除操作，红黑树有平衡操作，但跳跃表也有建立索引层操作。跳跃表的结构简单易懂。<br><br>2、这里是基于数据量比较大（例如千万级别）且写入操作多的情况下，ConcurrentSkipListMap性能要比ConcurrentHashMap好一些，并不是在任何情况下都要优于ConcurrentHashMap的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561691081,"ip_address":"","comment_id":107949,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18741508346","product_id":100028001,"comment_content":"请问一下老师两个问题:<br>1. 为什么在无锁是红黑树和跳表的性能差不多呢, 红黑树再平衡的操作会不会更复杂一些.<br>2. 从本篇文章看好像ConcurrentSkipListMap的性能比ConcurrentHashMap性能要好, 那为啥平时还是用后者的人更多呢, 我想很定是后者相对前者也有一定的优势吧, 但我自己没想出来, 老师能不能指点一下是啥优势.","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455761,"discussion_content":"1、两者的平均查询复杂度都是O(logn)，所以查询性能差不多。而在新增和删除操作，红黑树有平衡操作，但跳跃表也有建立索引层操作。跳跃表的结构简单易懂。\n\n2、这里是基于数据量比较大（例如千万级别）且写入操作多的情况下，ConcurrentSkipListMap性能要比ConcurrentHashMap好一些，并不是在任何情况下都要优于ConcurrentHashMap的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561691081,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1357623,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJmBKrLvqOIXDDbj3ocEIJzqsQx2e5VLDBSX6LmofYtprWwKaVAmHUqU2z3mjREHX8n9eLLiavlPg/132","nickname":"wg1993","note":"","ucode":"D5112FEFDB1DF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40300,"discussion_content":"ConcurrentHashMap只有在数据量特别大的时候才会出现很多hash碰撞，只有hash冲突很多时链表才会很长，才会需要红黑树，才会有红黑树再平衡问题。。。而跳表每次插入，删除都会有跳表再平衡，也就是索引的增删问题","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1572155690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1357623,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJmBKrLvqOIXDDbj3ocEIJzqsQx2e5VLDBSX6LmofYtprWwKaVAmHUqU2z3mjREHX8n9eLLiavlPg/132","nickname":"wg1993","note":"","ucode":"D5112FEFDB1DF7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301114,"discussion_content":"但是并发量上来以后，ConcurrentHashMap会锁住整个红黑树，跳表锁住单个节点，所以锁粒度更小性能就更好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598410798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40300,"ip_address":""},"score":301114,"extra":""}]}]},{"had_liked":false,"id":108523,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1561791299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14446693187","product_id":100028001,"comment_content":"赞成讲下那几个blockingQueue","like_count":3},{"had_liked":false,"id":107654,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1561593847,"is_pvip":false,"replies":[{"id":"39197","content":"ConcurrentSkipListMap只是key值的升排序，并没有对value进行排序；<br><br>CopyOnWrite在副本写时，是需要加锁的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561693029,"ip_address":"","comment_id":107654,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10151528439","product_id":100028001,"comment_content":"老师，我有2个问题:<br><br>1 top 10 问题涉及到排序, 我感觉用优先级队列或带排序功能的ConcurrentSkipListMap更合适？ConcurrentHashMap不支持排序吧<br><br>2 CopyOnWrite的list为什么还要加锁呢，副本不是线程独享的吗？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455607,"discussion_content":"ConcurrentSkipListMap只是key值的升排序，并没有对value进行排序；\n\nCopyOnWrite在副本写时，是需要加锁的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561693029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151031,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1573645188,"is_pvip":false,"replies":[{"id":"58544","content":"如果是一个新Node，那么就不能马上看到，虽然Node的数组table被volatile修饰，但是这样只是代表table的引用地址如果被修改，其他线程可以立马看到，并不代表table里的数据被修改立马可以看到。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573983508,"ip_address":"","comment_id":151031,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5868612484","product_id":100028001,"comment_content":"老师，我的意思是Unsafe#compareAndSetObject和Unsafe#getObjectVolatile方法，这两个方法的volatile语义可以保证数组元素的可见性。这样即使新增一个node，这俩方法也可以保证其他线程可以读到。还是说我对这两个方法有误解，请老师解惑！","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474344,"discussion_content":"如果是一个新Node，那么就不能马上看到，虽然Node的数组table被volatile修饰，但是这样只是代表table的引用地址如果被修改，其他线程可以立马看到，并不代表table里的数据被修改立马可以看到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573983508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1012369,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/72/91/73235447.jpg","nickname":"Steve","note":"","ucode":"C79D2A4C7B081D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293557,"discussion_content":"我觉得get操作是强一致性的，即使是新增节点，因为Unsafe#getObjectVolatile就是获取偏移量位置上最新的引用，并且是一个Volatile读，也就是说有修改也是能够读取到的。举个反例，若get不是强一致性读，如果get读之前有一个线程已经执行put操作在get要获取的槽位加了一个节点，由于get所在线程读取不到最新 提交到主内存的值，get是不是就一直读取不到最新值。我读10次和读1次的结果都一样。\n所以我觉得get还是强一致性的。\n但concurrentHashMap依旧是一个弱一致性的容器，因为有迭代器的存在。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595580698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":118206,"user_name":"Eaglet","can_delete":false,"product_type":"c1","uid":1136420,"ip_address":"","ucode":"AC20EDC1204860","user_header":"https://static001.geekbang.org/account/avatar/00/11/57/24/2d942948.jpg","comment_is_top":false,"comment_ctime":1564291064,"is_pvip":false,"replies":[{"id":"43378","content":"会涉及到排序问题，如果数据量特别大，CurrentHashMap就没有优势了。一般销量top10是基于自营型商城或某一类型的商品来做的，所以商品数量不会太大，商品在一段时间内是固定的，所以不会有数据累计问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564364640,"ip_address":"","comment_id":118206,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5859258360","product_id":100028001,"comment_content":"老师，top10的问题，你说：在数据不断地写入和删除，且不存在数据量累积以及数据排序的场景，可以选用 CurrentHashMap。可是top10问题有排序，数据量也在实时的累积，感觉用 CurrentHashMap 也不是最合适吧？这里不太懂，请老师解释下我是否对 top10这个问题本身理解有问题。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460301,"discussion_content":"会涉及到排序问题，如果数据量特别大，CurrentHashMap就没有优势了。一般销量top10是基于自营型商城或某一类型的商品来做的，所以商品数量不会太大，商品在一段时间内是固定的，所以不会有数据累计问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564364640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107715,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561598764,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5856566060","product_id":100028001,"comment_content":"老师好!为啥没有CopyOnWriteMap啊，ConpOnwriteArrayList。时间复杂度还是O(n)吧。","like_count":1,"discussions":[{"author":{"id":1006789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","nickname":"梁中华","note":"","ucode":"52FE40242CBAD0","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465,"discussion_content":"我也感觉这个例子有点奇怪，查找黑名单Map结构更快啊，为啥用ArrayList呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1561602513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1235750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","nickname":"天使梦泪","note":"","ucode":"782991747DD424","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1314,"discussion_content":"应该是复制时LIST移动数组内存，比较简单，Map还要重新计算hash，冲突率会增大，性能会降低。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562558591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107652,"user_name":"张学磊","can_delete":false,"product_type":"c1","uid":1250029,"ip_address":"","ucode":"F545F384A6F1E1","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotSSnZic41tGkbflx0ogIg3ia6g2muFY1hCgosL2t3icZm7I8Ax1hcv1jNgr6vrZ53dpBuGhaoc6DKg/132","comment_is_top":false,"comment_ctime":1561593632,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5856560928","product_id":100028001,"comment_content":"个人认为抢购的排队等待应该使用ConcurrentLinkedQueue，相比于ArrayBlockingQueue(一把全局锁)和LinkedBlockingQueue(存取采用两把锁)，CLQ是无锁的，使用CAS操作，不存在锁的争抢性能有很大的优势，适用于单生产者多消费者情况","like_count":2},{"had_liked":false,"id":300792,"user_name":"平民人之助","can_delete":false,"product_type":"c1","uid":2658705,"ip_address":"","ucode":"5CCEC0BAC08AEC","user_header":"https://static001.geekbang.org/account/avatar/00/28/91/91/428a27a3.jpg","comment_is_top":false,"comment_ctime":1625388288,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625388288","product_id":100028001,"comment_content":"抢购的队列用redis的ZSET，其实就是基于跳表排序，redisson提供了juc的所有支持，一般抢购就是用信号灯来处理。","like_count":0},{"had_liked":false,"id":283016,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1096397,"ip_address":"","ucode":"14C0858C413E00","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/cd/1f91aa44.jpg","comment_is_top":false,"comment_ctime":1615519914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615519914","product_id":100028001,"comment_content":"JDK1.8中，ConcurrentHashMap的get方法没有锁，但是val和next属性都是用volatile关键字修饰的，这就保证了可见行，这个还有弱一致性的问题吗？","like_count":0},{"had_liked":false,"id":238212,"user_name":"Gavin","can_delete":false,"product_type":"c1","uid":1616970,"ip_address":"","ucode":"A5735665E303FD","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UXuSevhia94o9Eky4OfMuSictaldxcqpjGuvRCOcvjIIoVBAENLEZbv2lgwmwC8icK1ZrUcneNtiaeFBV8MT3uzNg/132","comment_is_top":false,"comment_ctime":1596096331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596096331","product_id":100028001,"comment_content":"假设我们现在要给一个电商系统设计一个简单的统计商品销量 TOP 10 的功能。常规情况下，我们是用一个哈希表来存储商品和销量键值对，然后使用排序获得销量前十的商品。在这里，哈希表是实现该功能的关键。那么请思考一下，如果要你设计这个功能，你会使用哪个容器呢？<br><br><br>这个用优先队列，是不是更好，不需要排序了","like_count":0},{"had_liked":false,"id":226952,"user_name":"耿嘉艺","can_delete":false,"product_type":"c1","uid":2023401,"ip_address":"","ucode":"727A22BD41E8AF","user_header":"","comment_is_top":false,"comment_ctime":1592234446,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592234446","product_id":100028001,"comment_content":"既然concurrenthashmap是弱一致性，修改结果不一定能及时看到，那不是不应该用于查询操作吗？","like_count":0},{"had_liked":false,"id":201258,"user_name":"will","can_delete":false,"product_type":"c1","uid":1156207,"ip_address":"","ucode":"7A7DBE3E0EEAEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/6f/672a27d4.jpg","comment_is_top":false,"comment_ctime":1585741057,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585741057","product_id":100028001,"comment_content":"重新认识一下这些数据结构","like_count":0},{"had_liked":false,"id":196304,"user_name":"脱缰的野马__","can_delete":false,"product_type":"c1","uid":1447569,"ip_address":"","ucode":"D5F993E7232C61","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/WtHCCMoLJ2DvzqQwPYZyj2RlN7eibTLMHDMTSO4xIKjfKR1Eh9L98AMkkZY7FmegWyGLahRQJ5ibPzeeFtfpeSow/132","comment_is_top":false,"comment_ctime":1585271258,"is_pvip":false,"replies":[{"id":"75253","content":"是的，需要遍历，这里的黑名单前提是数量很小，在数据量比较大的情况下使用线程安全map更佳。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585743901,"ip_address":"","comment_id":196304,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585271258","product_id":100028001,"comment_content":"老师您好，黑名单的案例为什么不用线程安全的map啊，这样便于查询吧，如果总链表，要查询某个用户是否在黑名单不是要遍历整个链表吗？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489263,"discussion_content":"是的，需要遍历，这里的黑名单前提是数量很小，在数据量比较大的情况下使用线程安全map更佳。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585743901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190059,"user_name":"Lambor","can_delete":false,"product_type":"c1","uid":1275494,"ip_address":"","ucode":"0E3C3C39A22495","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/66/cbd6013c.jpg","comment_is_top":false,"comment_ctime":1584599427,"is_pvip":false,"replies":[{"id":"74194","content":"这个场景使用redis更佳，作为分布式缓存。CopyOnWriteArrayList同样可以实现，但实现起来就更繁琐一些，例如你说的要保证各个实例的数据一致性。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585139640,"ip_address":"","comment_id":190059,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1584599427","product_id":100028001,"comment_content":"老师，您好！一直有个疑惑，现在基本都是微服务架构，服务都是多实例运行，例如黑名单那个场景，数据应该不是直接使用 CopyOnWriteArrayList 保存在内存中的，这样多个实例的数据可能不一致，而是用 redis 这类中间件保存起来，服务中每次查询黑名单时从 redis 查询，写入应该也是写入到 redis 的。所以这个场景使用 CopyOnWriteArrayList 我不知道是不是能满足实际的业务需求。还望解答。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487875,"discussion_content":"这个场景使用redis更佳，作为分布式缓存。CopyOnWriteArrayList同样可以实现，但实现起来就更繁琐一些，例如你说的要保证各个实例的数据一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585139640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181457,"user_name":"L!en6o","can_delete":false,"product_type":"c1","uid":1054472,"ip_address":"","ucode":"E0931CB8998260","user_header":"https://static001.geekbang.org/account/avatar/00/10/17/08/566fb246.jpg","comment_is_top":false,"comment_ctime":1582543584,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582543584","product_id":100028001,"comment_content":"Concurrent*都是典型的并发容器，修改开销较低。 ","like_count":0},{"had_liked":false,"id":157592,"user_name":"奋斗的小白鼠","can_delete":false,"product_type":"c1","uid":1743483,"ip_address":"","ucode":"752BB901FFB7CE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/icHicAP9M4M4DIjAvlj5FDdFxIeA0pR3J15QdvVjXQXbznwunDN8OvrYqnsFchtBTNrZCCfGTE2RpPzIxjkvFAKg/132","comment_is_top":false,"comment_ctime":1575205822,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575205822","product_id":100028001,"comment_content":"老师，我看了您的解释还是不明白，node数组和node数组里面的node节点以及node结点的的value都是被volatile修饰，为什么你说新增就未必能，能解释的详细点不，谢谢","like_count":0},{"had_liked":false,"id":150920,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1573628651,"is_pvip":false,"replies":[{"id":"58089","content":"如果是一个新Node，那么就不能马上看到，虽然Node的数组table被volatile修饰，但是这样只是代表table的引用地址如果被修改，其他线程可以立马看到，并不代表table里的数据被修改立马可以看到。<br><br>这里解释的很清楚了，已经存在的value是可以马上看到，但是一个新增的就未必能了。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573639639,"ip_address":"","comment_id":150920,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573628651","product_id":100028001,"comment_content":"concurrentHashMap添加元素用了Unsafe#compareAndSetObject方法，获取元素使用Unsafe#getObjectVolatile方法，这两个方法不是都有volatile语义吗，按道理来说都能获取到最新值呀","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474311,"discussion_content":"如果是一个新Node，那么就不能马上看到，虽然Node的数组table被volatile修饰，但是这样只是代表table的引用地址如果被修改，其他线程可以立马看到，并不代表table里的数据被修改立马可以看到。\n\n这里解释的很清楚了，已经存在的value是可以马上看到，但是一个新增的就未必能了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573639639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150515,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1573548736,"is_pvip":false,"replies":[{"id":"57987","content":"ConcurrentHashMap是volatile关键字保证了可见性。<br><br>我们知道Node&lt;k,v&gt;以及Node&lt;k,v&gt;的value是volatile修饰的，所以在一个线程对其进行修改后，另一个线程可以马上看到。<br>如果是一个新Node，那么就不能马上看到，虽然Node的数组table被volatile修饰，但是这样只是代表table的引用地址如果被修改，其他线程可以立马看到，并不代表table里的数据被修改立马可以看到。—— 《加餐 | 什么是数据的强、弱一致性？》","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573612913,"ip_address":"","comment_id":150515,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573548736","product_id":100028001,"comment_content":"老师，1.7ConcurrentHashMap弱一致性我理解，但是1.8为什么呀，1.8使用CAS可以保证可见性吧","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474186,"discussion_content":"ConcurrentHashMap是volatile关键字保证了可见性。\n\n我们知道Node&amp;lt;k,v&amp;gt;以及Node&amp;lt;k,v&amp;gt;的value是volatile修饰的，所以在一个线程对其进行修改后，另一个线程可以马上看到。\n如果是一个新Node，那么就不能马上看到，虽然Node的数组table被volatile修饰，但是这样只是代表table的引用地址如果被修改，其他线程可以立马看到，并不代表table里的数据被修改立马可以看到。—— 《加餐 | 什么是数据的强、弱一致性？》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573612913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135388,"user_name":"菜菜","can_delete":false,"product_type":"c1","uid":1393550,"ip_address":"","ucode":"2CEBA98DA63362","user_header":"https://static001.geekbang.org/account/avatar/00/15/43/8e/2c1ce77b.jpg","comment_is_top":false,"comment_ctime":1569144078,"is_pvip":false,"replies":[{"id":"52258","content":"在留言中已经解释过了，再翻一翻","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569415471,"ip_address":"","comment_id":135388,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1569144078","product_id":100028001,"comment_content":"concurrentHashMap中的value不是加了volatile修饰吗? 为什么还存在数据弱一致性拿不到最新值的情况？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468169,"discussion_content":"在留言中已经解释过了，再翻一翻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569415471,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127381,"user_name":"小笨蛋","can_delete":false,"product_type":"c1","uid":1118331,"ip_address":"","ucode":"7065FB157C4B70","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/7b/eed9d6d6.jpg","comment_is_top":false,"comment_ctime":1566684525,"is_pvip":true,"replies":[{"id":"50380","content":"数据量大的情况下，再好的hash分散，链表的长度也会随着数据量的增加而变长","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567944340,"ip_address":"","comment_id":127381,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1566684525","product_id":100028001,"comment_content":"我有个疑问，你有提到ConcurrntHashMap里面数据量比较大的情况下会有很多的红黑树的转化操作，但是据我了解Java里面的Hash算法是采用的分散很好的Time33算法，这份hash还是很均匀的，应该不会出现大量的红黑树的转化工作。能麻烦老师解答一下吗？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":464465,"discussion_content":"数据量大的情况下，再好的hash分散，链表的长度也会随着数据量的增加而变长","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567944340,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124591,"user_name":"老杨在努力","can_delete":false,"product_type":"c1","uid":1614410,"ip_address":"","ucode":"AA541B3BAD53A7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","comment_is_top":false,"comment_ctime":1565925662,"is_pvip":false,"replies":[{"id":"50705","content":"Disruptor是一个高性能队列","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568168050,"ip_address":"","comment_id":124591,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565925662","product_id":100028001,"comment_content":"个人感觉可以使用LinkedTransferQueue或者Disruptor来实现都可以，但是更倾向于后者，老师认为哪个更好？？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463237,"discussion_content":"Disruptor是一个高性能队列","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568168050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":124111,"user_name":"博弈","can_delete":false,"product_type":"c1","uid":1433344,"ip_address":"","ucode":"B1A69837E41972","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/EcYNib1bnDf5dz6JcrE8AoyZYMdqic2VNmbBtCcVZTO9EoDZZxqlQDEqQKo6klCCmklOtN9m0dTd2AOXqSneJYLw/132","comment_is_top":false,"comment_ctime":1565827617,"is_pvip":false,"replies":[{"id":"45554","content":"在答疑课堂已经做了补充","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565831766,"ip_address":"","comment_id":124111,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1565827617","product_id":100028001,"comment_content":"老师，可以把几个QUENE讲一讲","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463016,"discussion_content":"在答疑课堂已经做了补充","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565831766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":117877,"user_name":"颉","can_delete":false,"product_type":"c1","uid":1147843,"ip_address":"","ucode":"2DCF7391851427","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/c3/7bca8cbf.jpg","comment_is_top":false,"comment_ctime":1564159829,"is_pvip":false,"replies":[{"id":"44480","content":"这个没有强调连续性，只是陈述不是一个大对象，而是一个整数类型。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565055516,"ip_address":"","comment_id":117877,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1564159829","product_id":100028001,"comment_content":"其次用户 ID 是整数类型，因此我们可以考虑使用数组来存储。----老师 这个弯没转过来 请教下 为什么id是整数类型 就要用数组？用户id可能是极度分散的…","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460155,"discussion_content":"这个没有强调连续性，只是陈述不是一个大对象，而是一个整数类型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565055516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114809,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1563410979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563410979","product_id":100028001,"comment_content":"redis中map的实现就是通过跳表来做的，简单高效。","like_count":1},{"had_liked":false,"id":114525,"user_name":"Johnny","can_delete":false,"product_type":"c1","uid":1125191,"ip_address":"","ucode":"180AAF61AD0BCA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIBpUsdg3ytlZrm9y64c5cq58iaqoh8kfp4rfYFqZQF8vdJ8mSCNSgbBgp1CHNrTHiaL5ibFEXZoqRoQ/132","comment_is_top":false,"comment_ctime":1563329256,"is_pvip":false,"replies":[{"id":"42040","content":"我已经在评论中回复相关问题了，麻烦查下。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563493502,"ip_address":"","comment_id":114525,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563329256","product_id":100028001,"comment_content":"还是不明白，concurrenthashmap的数组不是有volatile属性吗，就算没有锁变更了可以保证其他线程可见呀。happenbefore规则也是有这个的。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458703,"discussion_content":"我已经在评论中回复相关问题了，麻烦查下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563493502,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111384,"user_name":"Chaos","can_delete":false,"product_type":"c1","uid":1580479,"ip_address":"","ucode":"34704023199A43","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqw0R25Bt0iahFo3tfriat5ic3rto3u1qLdRlMI0ibGLwGR8MqiaU04N7VKsW8icpGLibo1ic0ebojUc5fNRA/132","comment_is_top":false,"comment_ctime":1562549692,"is_pvip":false,"replies":[{"id":"40615","content":"请问Chaos同学说的是用redis分布式锁实现抢购队列吗？","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562574955,"ip_address":"","comment_id":111384,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562549692","product_id":100028001,"comment_content":"老师，您好，如果这个业务用分布式锁，分布式锁是根据业务来决定锁定时间，但是如果业务没有执行完，但是redis释放了锁，这时应该怎么办啊？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457328,"discussion_content":"请问Chaos同学说的是用redis分布式锁实现抢购队列吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562574955,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108773,"user_name":"李","can_delete":false,"product_type":"c1","uid":1396623,"ip_address":"","ucode":"426288EBB410C2","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIfQFSpQJNKeqW5Q9PfciaLyDDFm9heqW5SHQCzlrajXO8f38RCH3BE5k8QHGPMictbbAM9IGvicj5EQ/132","comment_is_top":false,"comment_ctime":1561878801,"is_pvip":false,"replies":[{"id":"39616","content":"一般分布式的缓存，我们都是基于redis实现存储。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562033162,"ip_address":"","comment_id":108773,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1561878801","product_id":100028001,"comment_content":"在目前线上机器都是多台部署的，想问下老师，如上的数据结构如何选择，或者用不到如上的选择，都彩玉第3方存储，比如redis实现","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":456109,"discussion_content":"一般分布式的缓存，我们都是基于redis实现存储。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562033162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138821,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","nickname":"与路同飞","note":"","ucode":"2985F1440A1962","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308321,"discussion_content":"如果是多机部署，那岂不是上面的数据接口都用不上了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600915982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108090,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1561681328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561681328","product_id":100028001,"comment_content":"抢购队列我觉得写大于读，链表比较合适，但是抢购数据确定，可以用linkedBlockQueue设置长度为抢购数据，就算分布式部署，为非也就是抢购数量乘以机器数据，ConcurentLinkedDeque无界队列不合适","like_count":0},{"had_liked":false,"id":108070,"user_name":"左瞳","can_delete":false,"product_type":"c1","uid":1206589,"ip_address":"","ucode":"B262A3E99C8605","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/3d/3cfb9b87.jpg","comment_is_top":false,"comment_ctime":1561679192,"is_pvip":false,"replies":[{"id":"39151","content":"如果是单线程写入，可以考虑使用HashSet。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561684321,"ip_address":"","comment_id":108070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561679192","product_id":100028001,"comment_content":"黑名单查询用户是否存在不是应该用HashSet吗？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455811,"discussion_content":"如果是单线程写入，可以考虑使用HashSet。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561684321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108038,"user_name":"....","can_delete":false,"product_type":"c1","uid":1104022,"ip_address":"","ucode":"C9F7F89CD00B13","user_header":"https://static001.geekbang.org/account/avatar/00/10/d8/96/60e0d8fe.jpg","comment_is_top":false,"comment_ctime":1561651599,"is_pvip":false,"replies":[{"id":"39347","content":"在新增时，是通过随机算出level值，根据level新建垂直索引链。<br><br>&#47;&#47;获取一个线程无关的随机数，占四个字节，32 个比特位<br>int rnd = ThreadLocalRandom.nextSecondarySeed();<br>    &#47;&#47;和 1000 0000 0000 0000 0000 0000 0000 0001 与<br>    &#47;&#47;如果等于 0，说明这个随机数最高位和最低位都为 0，这种概率很大<br>    &#47;&#47;如果不等于 0，那么将仅仅把新节点插入到最底层的链表中即可，不会往上层递归<br>    if ((rnd &amp; 0x80000001) == 0) { <br>        int level = 1, max;<br>        &#47;&#47;用低位连续为 1 的个数作为 level 的值，也是一种概率策略<br>        while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0)<br>            ++level;<br>        Index&lt;K,V&gt; idx = null;<br>        HeadIndex&lt;K,V&gt; h = head;<br>        &#47;&#47;如果概率算得的 level 在当前跳表 level 范围内<br>        &#47;&#47;构建一个从 1 到 level 的纵列 index 结点引用<br>        if (level &lt;= (max = h.level)) {<br>            for (int i = 1; i &lt;= level; ++i)<br>                idx = new Index&lt;K,V&gt;(z, idx, null);<br>        }<br>        &#47;&#47;否则需要新增一个 level 层<br>        else { <br>            level = max + 1; <br>            @SuppressWarnings(&quot;unchecked&quot;)<br>            Index&lt;K,V&gt;[] idxs =(Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[level+1];<br>            for (int i = 1; i &lt;= level; ++i)<br>                idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null);<br>            for (;;) {<br>                h = head;<br>                int oldLevel = h.level;<br>                &#47;&#47;level 肯定是比 oldLevel 大一的，如果小了说明其他线程更新过表了<br>                if (level &lt;= oldLevel) <br>                    break;<br>                HeadIndex&lt;K,V&gt; newh = h;<br>                Node&lt;K,V&gt; oldbase = h.node;<br>                &#47;&#47;正常情况下，循环只会执行一次，如果由于其他线程的并发操作导致 oldLevel 的值不稳定，那么会执行多次循环体<br>                for (int j = oldLevel+1; j &lt;= level; ++j)<br>                    newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);<br>                &#47;&#47;更新头指针<br>                if (casHead(h, newh)) {<br>                    h = newh;<br>                    idx = idxs[level = oldLevel];<br>                    break;<br>                }<br>            }<br>        }<br><br>在删除时，会先删除底层的节点，最后通过扫描索引层是否失去了底层节点来回收掉索引层。<br><br>&#47;&#47;判断此次删除后是否导致某一索引层没有其他节点了，并删除该层索引  <br>if (head.right == null)<br>      ryReduceLevel();<br><br>建议具体的可以深入到源码中查看。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561862121,"ip_address":"","comment_id":108038,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561651599","product_id":100028001,"comment_content":"元素增减对每层链表的变化是怎么样的","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455799,"discussion_content":"在新增时，是通过随机算出level值，根据level新建垂直索引链。\n\n//获取一个线程无关的随机数，占四个字节，32 个比特位\nint rnd = ThreadLocalRandom.nextSecondarySeed();\n    //和 1000 0000 0000 0000 0000 0000 0000 0001 与\n    //如果等于 0，说明这个随机数最高位和最低位都为 0，这种概率很大\n    //如果不等于 0，那么将仅仅把新节点插入到最底层的链表中即可，不会往上层递归\n    if ((rnd &amp;amp; 0x80000001) == 0) { \n        int level = 1, max;\n        //用低位连续为 1 的个数作为 level 的值，也是一种概率策略\n        while (((rnd &amp;gt;&amp;gt;&amp;gt;= 1) &amp;amp; 1) != 0)\n            ++level;\n        Index&amp;lt;K,V&amp;gt; idx = null;\n        HeadIndex&amp;lt;K,V&amp;gt; h = head;\n        //如果概率算得的 level 在当前跳表 level 范围内\n        //构建一个从 1 到 level 的纵列 index 结点引用\n        if (level &amp;lt;= (max = h.level)) {\n            for (int i = 1; i &amp;lt;= level; ++i)\n                idx = new Index&amp;lt;K,V&amp;gt;(z, idx, null);\n        }\n        //否则需要新增一个 level 层\n        else { \n            level = max + 1; \n            @SuppressWarnings(&amp;quot;unchecked&amp;quot;)\n            Index&amp;lt;K,V&amp;gt;[] idxs =(Index&amp;lt;K,V&amp;gt;[])new Index&amp;lt;?,?&amp;gt;[level+1];\n            for (int i = 1; i &amp;lt;= level; ++i)\n                idxs[i] = idx = new Index&amp;lt;K,V&amp;gt;(z, idx, null);\n            for (;;) {\n                h = head;\n                int oldLevel = h.level;\n                //level 肯定是比 oldLevel 大一的，如果小了说明其他线程更新过表了\n                if (level &amp;lt;= oldLevel) \n                    break;\n                HeadIndex&amp;lt;K,V&amp;gt; newh = h;\n                Node&amp;lt;K,V&amp;gt; oldbase = h.node;\n                //正常情况下，循环只会执行一次，如果由于其他线程的并发操作导致 oldLevel 的值不稳定，那么会执行多次循环体\n                for (int j = oldLevel+1; j &amp;lt;= level; ++j)\n                    newh = new HeadIndex&amp;lt;K,V&amp;gt;(oldbase, newh, idxs[j], j);\n                //更新头指针\n                if (casHead(h, newh)) {\n                    h = ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561862121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":108019,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1561648183,"is_pvip":false,"replies":[{"id":"39195","content":"我们先来理解下happens-before规则中，对锁的规则：<br>一个unLock操作先行发生于后面对同一个锁的lock操作；<br><br>也就是说，ConcurrentHashMap中的get如果有锁操作，在put操作之后，get操作是一定能拿到put后的数据；而实际上get操作时没有锁的，也就是说下面这种情况：<br>void func(){<br>map.put(key1,value1);<br>map.get(key1);<br>.<br>.<br>&#47;&#47;use key1 value to do something<br>}<br>此时，get获取值的可能不是put修改的值，而此时get没有获取到真正要获取的值，此时就是弱一致了。<br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561692457,"ip_address":"","comment_id":108019,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1561648183","product_id":100028001,"comment_content":"我也没太明白什么叫弱一致性","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455791,"discussion_content":"我们先来理解下happens-before规则中，对锁的规则：\n一个unLock操作先行发生于后面对同一个锁的lock操作；\n\n也就是说，ConcurrentHashMap中的get如果有锁操作，在put操作之后，get操作是一定能拿到put后的数据；而实际上get操作时没有锁的，也就是说下面这种情况：\nvoid func(){\nmap.put(key1,value1);\nmap.get(key1);\n.\n.\n//use key1 value to do something\n}\n此时，get获取值的可能不是put修改的值，而此时get没有获取到真正要获取的值，此时就是弱一致了。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561692457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441546,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","nickname":"晓杰","note":"","ucode":"1174C88EEBF8A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544,"discussion_content":"根据happenbefore的原则，synchronize表示一个锁的解锁对后续对这个锁的加锁是可见的，因此，通过用synchronize修饰的put方法修改或者新增元素，因为get方法没有用synchronize修饰，所以看不到put方法对元素的修改，所以它是弱一致性的。\n请问老师，我这样的解释正确吗@刘超","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561686496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1117597,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0d/9d/58d09086.jpg","nickname":"达达队长","note":"","ucode":"1C3F2E4F6B7637","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1441546,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","nickname":"晓杰","note":"","ucode":"1174C88EEBF8A6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220624,"discussion_content":"牵扯到重排序了，get在put之前执行了\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585908310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":544,"ip_address":""},"score":220624,"extra":""}]}]},{"had_liked":false,"id":107985,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1561643927,"is_pvip":false,"replies":[{"id":"39152","content":"我们后面说了，在获取排名时，需要对concurrentHashMap进行排序。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561684453,"ip_address":"","comment_id":107985,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561643927","product_id":100028001,"comment_content":"我想问下老师，concurrentHashMap是无序的，我不太明白是如何完成Top10这个需求的，麻烦解答","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455774,"discussion_content":"我们后面说了，在获取排名时，需要对concurrentHashMap进行排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561684453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107752,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1561603431,"is_pvip":true,"replies":[{"id":"39209","content":"ConcurrentSkipListMap的key值是一个升序，而ConcurrentHashmap的默认没有排序。在查询速率来说，两者区别不大，区别在于存储大量数据情况下的写操作性能不一样。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561694474,"ip_address":"","comment_id":107752,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1561603431","product_id":100028001,"comment_content":"ConcurrentHashmap和ConcurrentSkipListMap在功能上的主要区别是前者不排序，后者自动排序。并非数据量上的区别吧。控制好ConcurrentHashmap里元素key的hashcode值，尽量减少碰撞，在数据量比较大的情况下可能比ConcurrentSkipListMap的效率更好。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455655,"discussion_content":"ConcurrentSkipListMap的key值是一个升序，而ConcurrentHashmap的默认没有排序。在查询速率来说，两者区别不大，区别在于存储大量数据情况下的写操作性能不一样。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561694474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107712,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1561598685,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561598685","product_id":100028001,"comment_content":"采用disruptor队列。一次性初始化所有元素。类似对象池；占位防止伪共享导致锁净增；元素存在相近的内存块","like_count":0},{"had_liked":false,"id":107706,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561598242,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561598242","product_id":100028001,"comment_content":"感觉跳跃表和B+树有点像","like_count":0},{"had_liked":false,"id":107692,"user_name":"大卫","can_delete":false,"product_type":"c1","uid":1019127,"ip_address":"","ucode":"D861709E483793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/f7/a4de6f64.jpg","comment_is_top":false,"comment_ctime":1561597151,"is_pvip":false,"replies":[{"id":"38952","content":"下一讲是线程池大小设置。分片到各个服务器上也是一种方案，这种方案问题就在可能有些服务库存没有了，其他服务上依然有库存。一般是基于分布式缓存来实现的，例如基于redis分布式锁来实现库存的扣减。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561598332,"ip_address":"","comment_id":107692,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561597151","product_id":100028001,"comment_content":"老师，这一讲不是讲的线程池大小如何设置哈。<br><br>抢购场景后端服务是分布式部署的，是将库存分片放到不同服务器上吗，然后考虑容器的选择么","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455627,"discussion_content":"下一讲是线程池大小设置。分片到各个服务器上也是一种方案，这种方案问题就在可能有些服务库存没有了，其他服务上依然有库存。一般是基于分布式缓存来实现的，例如基于redis分布式锁来实现库存的扣减。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561598332,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107691,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1561597087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561597087","product_id":100028001,"comment_content":"谢谢老师:以前听过跳跃表，今天认识跳跃表了","like_count":0},{"had_liked":false,"id":107683,"user_name":"听雨","can_delete":false,"product_type":"c1","uid":1254493,"ip_address":"","ucode":"252754F9FCFF0C","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","comment_is_top":false,"comment_ctime":1561596591,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561596591","product_id":100028001,"comment_content":"老师，在大数据量的情况下，可以把ConcurrentHashmap的长度放大点，这样元素碰撞的几率会小点，不容易出现链表或红黑树，相应的查询速度是不是也会很快呀，所以有点不理解为什么ConcurrentHashmap就适合小数据量。还是说ConcurrentHashmap原理不是这样，因为我没看过它的源码，只看过Hashmap的，但是我感觉这俩原理是类似的","like_count":0},{"had_liked":false,"id":107667,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1561594840,"is_pvip":false,"replies":[{"id":"38961","content":"如果是一个排队等待的队列，我们无需要特别在意强一致性。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1561599310,"ip_address":"","comment_id":107667,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1561594840","product_id":100028001,"comment_content":"抢购类，资源是固定的。那么说队列的长度就确定了。而消费者会特别多。需要一个强一致性进行维护。我觉得，vect比较好。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":455617,"discussion_content":"如果是一个排队等待的队列，我们无需要特别在意强一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561599310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}