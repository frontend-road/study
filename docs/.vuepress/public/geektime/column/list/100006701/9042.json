{"id":9042,"title":"第16讲 | synchronized底层如何实现？什么是锁的升级、降级？","content":"<p>我在<a href=\"http://time.geekbang.org/column/article/8799\">上一讲</a>对比和分析了synchronized和ReentrantLock，算是专栏进入并发编程阶段的热身，相信你已经对线程安全，以及如何使用基本的同步机制有了基础，今天我们将深入了解synchronize底层机制，分析其他锁实现和应用场景。</p>\n<p>今天我要问你的问题是 ，<span class=\"orange\">synchronized底层如何实现？什么是锁的升级、降级？</span></p>\n<!-- [[[read_end]]] -->\n<h2>典型回答</h2>\n<p>在回答这个问题前，先简单复习一下上一讲的知识点。synchronized代码块是由一对儿monitorenter/monitorexit指令实现的，Monitor对象是同步的基本实现<a href=\"https://docs.oracle.com/javase/specs/jls/se10/html/jls-8.html#d5e13622\">单元</a>。</p>\n<p>在Java 6之前，Monitor的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。</p>\n<p>现代的（Oracle）JDK中，JVM对此进行了大刀阔斧地改进，提供了三种不同的Monitor实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>\n<p>所谓锁的升级、降级，就是JVM优化synchronized运行的机制，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p>\n<p>当没有竞争出现时，默认会使用偏斜锁。JVM会利用CAS操作（<a href=\"https://en.wikipedia.org/wiki/Compare-and-swap\">compare and swap</a>），在对象头上的Mark Word部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p>\n<p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖CAS操作Mark Word来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>\n<p>我注意到有的观点认为Java不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当JVM进入安全点（<a href=\"http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html\">SafePoint</a>）的时候，会检查是否有闲置的Monitor，然后试图进行降级。</p>\n<h2>考点分析</h2>\n<p>今天的问题主要是考察你对Java内置锁实现的掌握，也是并发的经典题目。我在前面给出的典型回答，涵盖了一些基本概念。如果基础不牢，有些概念理解起来就比较晦涩，我建议还是尽量理解和掌握，即使有不懂的也不用担心，在后续学习中还会逐步加深认识。</p>\n<p>我个人认为，能够基础性地理解这些概念和机制，其实对于大多数并发编程已经足够了，毕竟大部分工程师未必会进行更底层、更基础的研发，很多时候解决的是知道与否，真正的提高还要靠实践踩坑。</p>\n<p>后面我会进一步分析：</p>\n<ul>\n<li>\n<p>从源码层面，稍微展开一些synchronized的底层实现，并补充一些上面答案中欠缺的细节，有同学反馈这部分容易被问到。如果你对Java底层源码有兴趣，但还没有找到入手点，这里可以成为一个切入点。</p>\n</li>\n<li>\n<p>理解并发包中java.util.concurrent.lock提供的其他锁实现，毕竟Java可不是只有ReentrantLock一种显式的锁类型，我会结合代码分析其使用。</p>\n</li>\n</ul>\n<h2>知识扩展</h2>\n<p>我在<a href=\"http://time.geekbang.org/column/article/8799\">上一讲</a>提到过synchronized是JVM内部的Intrinsic Lock，所以偏斜锁、轻量级锁、重量级锁的代码实现，并不在核心类库部分，而是在JVM的代码中。</p>\n<p>Java代码运行可能是解释模式也可能是编译模式（如果不记得，请复习<a href=\"http://time.geekbang.org/column/article/6845\">专栏第1讲</a>），所以对应的同步逻辑实现，也会分散在不同模块下，比如，解释器版本就是：</p>\n<p><a href=\"http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/interpreter/interpreterRuntime.cpp\">src/hotspot/share/interpreter/interpreterRuntime.cpp</a></p>\n<p>为了简化便于理解，我这里会专注于通用的基类实现：</p>\n<p><a href=\"http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/\">src/hotspot/share/runtime/</a></p>\n<p>另外请注意，链接指向的是最新JDK代码库，所以可能某些实现与历史版本有所不同。</p>\n<p>首先，synchronized的行为是JVM runtime的一部分，所以我们需要先找到Runtime相关的功能实现。通过在代码中查询类似“monitor_enter”或“Monitor Enter”，很直观的就可以定位到：</p>\n<ul>\n<li>\n<p><a href=\"http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/sharedRuntime.cpp\">sharedRuntime.cpp</a>/hpp，它是解释器和编译器运行时的基类。</p>\n</li>\n<li>\n<p><a href=\"https://hg.openjdk.java.net/jdk/jdk/file/896e80158d35/src/hotspot/share/runtime/synchronizer.cpp\">synchronizer.cpp</a>/hpp，JVM同步相关的各种基础逻辑。</p>\n</li>\n</ul>\n<p>在sharedRuntime.cpp中，下面代码体现了synchronized的主要逻辑。</p>\n<p></p>\n<pre><code>Handle h_obj(THREAD, obj);\n  if (UseBiasedLocking) {\n    // Retry fast entry if bias is revoked to avoid unnecessary inflation\n    ObjectSynchronizer::fast_enter(h_obj, lock, true, CHECK);\n  } else {\n    ObjectSynchronizer::slow_enter(h_obj, lock, CHECK);\n  }\n</code></pre>\n<p>其实现可以简单进行分解：</p>\n<ul>\n<li>UseBiasedLocking是一个检查，因为，在JVM启动时，我们可以指定是否开启偏斜锁。</li>\n</ul>\n<p>偏斜锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，只有当存在较多不会真正竞争的synchronized块儿时，才能体现出明显改善。实践中对于偏斜锁的一直是有争议的，有人甚至认为，当你需要大量使用并发类库时，往往意味着你不需要偏斜锁。从具体选择来看，我还是建议需要在实践中进行测试，根据结果再决定是否使用。</p>\n<p>还有一方面是，偏斜锁会延缓JIT 预热的进程，所以很多性能测试中会显式地关闭偏斜锁，命令如下：</p>\n<pre><code>-XX:-UseBiasedLocking\n\n</code></pre>\n<ul>\n<li>fast_enter是我们熟悉的完整锁获取路径，slow_enter则是绕过偏斜锁，直接进入轻量级锁获取逻辑。</li>\n</ul>\n<p>那么fast_enter是如何实现的呢？同样是通过在代码库搜索，我们可以定位到synchronizer.cpp。 类似fast_enter这种实现，解释器或者动态编译器，都是拷贝这段基础逻辑，所以如果我们修改这部分逻辑，要保证一致性。这部分代码是非常敏感的，微小的问题都可能导致死锁或者正确性问题。</p>\n<pre><code>void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock,\n                                \tbool attempt_rebias, TRAPS) {\n  if (UseBiasedLocking) {\n    if (!SafepointSynchronize::is_at_safepoint()) {\n      BiasedLocking::Condition cond = BiasedLocking::revoke_and_rebias(obj, attempt_rebias, THREAD);\n      if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) {\n        return;\n      }\n\t} else {\n      assert(!attempt_rebias, &quot;can not rebias toward VM thread&quot;);\n      BiasedLocking::revoke_at_safepoint(obj);\n\t}\n    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by now&quot;);\n  }\n \n  slow_enter(obj, lock, THREAD);\n}\n\n</code></pre>\n<p>我来分析下这段逻辑实现：</p>\n<ul>\n<li>\n<p><a href=\"http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/biasedLocking.cpp\">biasedLocking</a>定义了偏斜锁相关操作，revoke_and_rebias是获取偏斜锁的入口方法，revoke_at_safepoint则定义了当检测到安全点时的处理逻辑。</p>\n</li>\n<li>\n<p>如果获取偏斜锁失败，则进入slow_enter。</p>\n</li>\n<li>\n<p>这个方法里面同样检查是否开启了偏斜锁，但是从代码路径来看，其实如果关闭了偏斜锁，是不会进入这个方法的，所以算是个额外的保障性检查吧。</p>\n</li>\n</ul>\n<p>另外，如果你仔细查看<a href=\"https://hg.openjdk.java.net/jdk/jdk/file/896e80158d35/src/hotspot/share/runtime/synchronizer.cpp\">synchronizer.cpp</a>里，会发现不仅仅是synchronized的逻辑，包括从本地代码，也就是JNI，触发的Monitor动作，全都可以在里面找到（jni_enter/jni_exit）。</p>\n<p>关于<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/6659a8f57d78/src/hotspot/share/runtime/biasedLocking.cpp\">biasedLocking</a>的更多细节我就不展开了，明白它是通过CAS设置Mark Word就完全够用了，对象头中Mark Word的结构，可以参考下图：</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/b1/fc/b1221c308d2aaf13d0d677033ee406fc.png?wh=1005*314\" alt=\"\" /></p>\n<p>顺着锁升降级的过程分析下去，偏斜锁到轻量级锁的过程是如何实现的呢？</p>\n<p>我们来看看slow_enter到底做了什么。</p>\n<pre><code>void ObjectSynchronizer::slow_enter(Handle obj, BasicLock* lock, TRAPS) {\n  markOop mark = obj-&gt;mark();\n if (mark-&gt;is_neutral()) {\n       // 将目前的Mark Word复制到Displaced Header上\n\tlock-&gt;set_displaced_header(mark);\n\t// 利用CAS设置对象的Mark Word\n    if (mark == obj()-&gt;cas_set_mark((markOop) lock, mark)) {\n      TEVENT(slow_enter: release stacklock);\n      return;\n    }\n    // 检查存在竞争\n  } else if (mark-&gt;has_locker() &amp;&amp;\n             THREAD-&gt;is_lock_owned((address)mark-&gt;locker())) {\n\t// 清除\n    lock-&gt;set_displaced_header(NULL);\n    return;\n  }\n \n  // 重置Displaced Header\n  lock-&gt;set_displaced_header(markOopDesc::unused_mark());\n  ObjectSynchronizer::inflate(THREAD,\n                          \tobj(),\n                              inflate_cause_monitor_enter)-&gt;enter(THREAD);\n}\n\n</code></pre>\n<p>请结合我在代码中添加的注释，来理解如何从试图获取轻量级锁，逐步进入锁膨胀的过程。你可以发现这个处理逻辑，和我在这一讲最初介绍的过程是十分吻合的。</p>\n<ul>\n<li>\n<p>设置Displaced Header，然后利用cas_set_mark设置对象Mark Word，如果成功就成功获取轻量级锁。</p>\n</li>\n<li>\n<p>否则Displaced Header，然后进入锁膨胀阶段，具体实现在inflate方法中。</p>\n</li>\n</ul>\n<p>今天就不介绍膨胀的细节了，我这里提供了源代码分析的思路和样例，考虑到应用实践，再进一步增加源代码解读意义不大，有兴趣的同学可以参考我提供的<a href=\"http://hg.openjdk.java.net/jdk/jdk/file/896e80158d35/src/hotspot/share/runtime/synchronizer.cpp\">synchronizer.cpp</a>链接，例如：</p>\n<ul>\n<li>\n<p><strong>deflate_idle_monitors</strong>是分析<strong>锁降级</strong>逻辑的入口，这部分行为还在进行持续改进，因为其逻辑是在安全点内运行，处理不当可能拖长JVM停顿（STW，stop-the-world）的时间。</p>\n</li>\n<li>\n<p>fast_exit或者slow_exit是对应的锁释放逻辑。</p>\n</li>\n</ul>\n<p>前面分析了synchronized的底层实现，理解起来有一定难度，下面我们来看一些相对轻松的内容。 我在上一讲对比了synchronized和ReentrantLock，Java核心类库中还有其他一些特别的锁类型，具体请参考下面的图。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/f5/11/f5753a4695fd771f8178120858086811.png?wh=751*310\" alt=\"\" /></p>\n<p></p>\n<p>你可能注意到了，这些锁竟然不都是实现了Lock接口，ReadWriteLock是一个单独的接口，它通常是代表了一对儿锁，分别对应只读和写操作，标准类库中提供了再入版本的读写锁实现（ReentrantReadWriteLock），对应的语义和ReentrantLock比较相似。</p>\n<p>StampedLock竟然也是个单独的类型，从类图结构可以看出它是不支持再入性的语义的，也就是它不是以持有锁的线程为单位。</p>\n<p>为什么我们需要读写锁（ReadWriteLock）等其他锁呢？</p>\n<p>这是因为，虽然ReentrantLock和synchronized简单实用，但是行为上有一定局限性，通俗点说就是“太霸道”，要么不占，要么独占。实际应用场景中，有的时候不需要大量竞争的写操作，而是以并发读取为主，如何进一步优化并发操作的粒度呢？</p>\n<p>Java并发包提供的读写锁等扩展了锁的能力，它所基于的原理是多个读操作是不需要互斥的，因为读操作并不会更改数据，所以不存在互相干扰。而写操作则会导致并发一致性的问题，所以写线程之间、读写线程之间，需要精心设计的互斥逻辑。</p>\n<p>下面是一个基于读写锁实现的数据结构，当数据量较大，并发读多、并发写少的时候，能够比纯同步版本凸显出优势。</p>\n<pre><code>public class RWSample {\n\tprivate final Map&lt;String, String&gt; m = new TreeMap&lt;&gt;();\n\tprivate final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n\tprivate final Lock r = rwl.readLock();\n\tprivate final Lock w = rwl.writeLock();\n\tpublic String get(String key) {\n    \tr.lock();\n    \tSystem.out.println(&quot;读锁锁定！&quot;);\n    \ttry {\n        \treturn m.get(key);\n    \t} finally {\n        \tr.unlock();\n    \t}\n\t}\n\n\tpublic String put(String key, String entry) {\n    \tw.lock();\n\tSystem.out.println(&quot;写锁锁定！&quot;);\n\t    \ttry {\n\t        \treturn m.put(key, entry);\n\t    \t} finally {\n\t        \tw.unlock();\n\t    \t}\n\t\t}\n\t// …\n\t}\n\n</code></pre>\n<p>在运行过程中，如果读锁试图锁定时，写锁是被某个线程持有，读锁将无法获得，而只好等待对方操作结束，这样就可以自动保证不会读取到有争议的数据。</p>\n<p>读写锁看起来比synchronized的粒度似乎细一些，但在实际应用中，其表现也并不尽如人意，主要还是因为相对比较大的开销。</p>\n<p>所以，JDK在后期引入了StampedLock，在提供类似读写锁的同时，还支持优化读模式。优化读基于假设，大多数情况下读操作并不会和写操作冲突，其逻辑是先试着读，然后通过validate方法确认是否进入了写模式，如果没有进入，就成功避免了开销；如果进入，则尝试获取读锁。请参考我下面的样例代码。</p>\n<pre><code>public class StampedSample {\n\tprivate final StampedLock sl = new StampedLock();\n\n\tvoid mutate() {\n    \tlong stamp = sl.writeLock();\n    \ttry {\n        \twrite();\n    \t} finally {\n        \tsl.unlockWrite(stamp);\n    \t}\n\t}\n\n\tData access() {\n    \tlong stamp = sl.tryOptimisticRead();\n    \tData data = read();\n    \tif (!sl.validate(stamp)) {\n        \tstamp = sl.readLock();\n        \ttry {\n            \tdata = read();\n        \t} finally {\n            \tsl.unlockRead(stamp);\n        \t}\n    \t}\n    \treturn data;\n\t}\n\t// …\n}\n\n</code></pre>\n<p>注意，这里的writeLock和unLockWrite一定要保证成对调用。</p>\n<p>你可能很好奇这些显式锁的实现机制，Java并发包内的各种同步工具，不仅仅是各种Lock，其他的如<a href=\"https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/Semaphore.html\">Semaphore</a>、<a href=\"https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/CountDownLatch.html\">CountDownLatch</a>，甚至是早期的<a href=\"https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/FutureTask.html\">FutureTask</a>等，都是基于一种<a href=\"https://docs.oracle.com/javase/10/docs/api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html\">AQS</a>框架。</p>\n<p>今天，我全面分析了synchronized相关实现和内部运行机制，简单介绍了并发包中提供的其他显式锁，并结合样例代码介绍了其使用方法，希望对你有所帮助。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的你做到心中有数了吗？思考一个问题，你知道“自旋锁”是做什么的吗？它的使用场景是什么？</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n","neighbors":{"left":{"article_title":"第15讲 | synchronized和ReentrantLock有什么区别呢？","id":8799},"right":{"article_title":"第17讲 | 一个线程两次调用start()方法会出现什么情况？","id":9103}},"comments":[{"had_liked":false,"id":12357,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1528779132,"is_pvip":true,"replies":[{"id":"4073","content":"不错，自旋是种乐观情况的优化","user_name":"作者回复","comment_id":12357,"uid":"1009360","ip_address":"","utype":1,"ctime":1528816671,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"766032957820","product_id":100006701,"comment_content":"自旋锁:竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。<br><br>适用场景:自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。<br>如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，线程自旋的消耗大于线程阻塞挂起操作的消耗，造成cpu的浪费。","like_count":179,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419229,"discussion_content":"不错，自旋是种乐观情况的优化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528816671,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1792698,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/5a/ba/596d6ae3.jpg","nickname":"MENGXIANGING","note":"","ucode":"B51414E230D6A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585930,"discussion_content":"同时自旋也是导致synchronized为非公平锁的原因之一，当一个新的线程竞争当前锁的对象时会先自旋，而不是进入等待队列，这对等待队列里面的线程是不公平的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661912312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12379,"user_name":"yearning","can_delete":false,"product_type":"c1","uid":1011455,"ip_address":"","ucode":"4C7522ADEAC837","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6e/ff/bcbfae67.jpg","comment_is_top":false,"comment_ctime":1528788718,"is_pvip":false,"replies":[{"id":"4072","content":"很不错总结","user_name":"作者回复","comment_id":12379,"uid":"1009360","ip_address":"","utype":1,"ctime":1528816563,"user_name_real":"杨晓峰"}],"discussion_count":4,"race_medal":0,"score":"327946303214","product_id":100006701,"comment_content":"这次原理真的看了很久，一直鼓劲自己，看不懂就是说明自己有突破。<br><br>下面看了并发编程对于自旋锁的了解，同时更深刻理解同步锁的性能。<br><br>自旋锁采用让当前线程不停循环体内执行实现，当循环条件被其他线程改变时，才能进入临界区。<br><br>由于自旋锁只是将当前线程不停执行循环体，不进行线程状态的改变，所以响应会更快。但当线程不停增加时，性能下降明显。<br>线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。<br><br>为什么会提出自旋锁，因为互斥锁，在线程的睡眠和唤醒都是复杂而昂贵的操作，需要大量的CPU指令。如果互斥仅仅被锁住是一小段时间，<br>用来进行线程休眠和唤醒的操作时间比睡眠时间还长，更有可能比不上不断自旋锁上轮询的时间长。<br><br>当然自旋锁被持有的时间更长，其他尝试获取自旋锁的线程会一直轮询自旋锁的状态。这将十分浪费CPU。<br><br>在单核CPU上，自旋锁是无用，因为当自旋锁尝试获取锁不成功会一直尝试，这会一直占用CPU，其他线程不可能运行，<br>同时由于其他线程无法运行，所以当前线程无法释放锁。<br><br>混合型互斥锁， 在多核系统上起初表现的像自旋锁一样， 如果一个线程不能获取互斥锁， 它不会马上被切换为休眠状态，在一段时间依然无法获取锁，进行睡眠状态。<br><br>混合型自旋锁，起初表现的和正常自旋锁一样，如果无法获取互斥锁，它也许会放弃该线程的执行，并允许其他线程执行。<br><br>切记，自旋锁只有在多核CPU上有效果，单核毫无效果，只是浪费时间。<br><br><br>以上基本参考来源于：<br>http:&#47;&#47;ifeve.com&#47;java_lock_see1&#47;<br>http:&#47;&#47;ifeve.com&#47;practice-of-using-spinlock-instead-of-mutex&#47;","like_count":77,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419236,"discussion_content":"很不错总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528816563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188054,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/d6/c5295b7d.jpg","nickname":"潇如辰枫","note":"","ucode":"77232E4D186792","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4906,"discussion_content":"单核不是也有时间分片么？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1565826628,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1557371,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/ficTmdLUSNV1ZkQVKU8Ww3wiclCyW2cicesUPxzuDT7qEvKibkiciaxe03We1ibPicZF0gnfiaBjtWKRdll0VfWxcX5icPTQ/132","nickname":"长安贱","note":"","ucode":"287BD843D16ACB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290851,"discussion_content":"&#34;在单核CPU上，自旋锁是无用，因为当自旋锁尝试获取锁不成功会一直尝试，这会一直占用CPU，其他线程不可能运行 &#34;  这是你自己意淫的吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1594623092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125281,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2b/a1/d40cc39d.jpg","nickname":"煜城骁特","note":"","ucode":"F4939490CF38FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206750,"discussion_content":"单cpu上的自旋锁实际没有“自旋功能”。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584437470,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13085,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1529368828,"is_pvip":false,"replies":[{"id":"4375","content":"不错","user_name":"作者回复","comment_id":13085,"uid":"1009360","ip_address":"","utype":1,"ctime":1529421076,"user_name_real":"杨晓峰"}],"discussion_count":4,"race_medal":1,"score":"138968322300","product_id":100006701,"comment_content":"看了大家对自旋锁的评论，我的收获如下:<br>1.基于乐观情况下推荐使用，即锁竞争不强，锁等待时间不长的情况下推荐使用<br>2.单cpu无效，因为基于cas的轮询会占用cpu,导致无法做线程切换<br>3.轮询不产生上下文切换，如果可估计到睡眠的时间很长，用互斥锁更好<br>","like_count":33,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419530,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529421076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1397010,"avatar":"https://static001.geekbang.org/account/avatar/00/15/51/12/aea3f511.jpg","nickname":"蹲街丶惜流年","note":"","ucode":"012A398FE80975","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41302,"discussion_content":"谁说的cas就一直占cpu，这怎么可能，从流行操作系统上来说，cpu只支持绑定到进程粒度，怎么可能到线程。准确的说cas的优势只是在短时间内不用去写进程表。在往深一点就是如果涉及到内核态的话，少了软中断。当然在极端情况下寄存器，内存等也是需要考虑的。不喜勿喷","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1572397824,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1188054,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/d6/c5295b7d.jpg","nickname":"潇如辰枫","note":"","ucode":"77232E4D186792","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4907,"discussion_content":"为什么基于cas会一直占用CPU？\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1565826818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1323223,"avatar":"https://static001.geekbang.org/account/avatar/00/14/30/d7/4999e677.jpg","nickname":"大王叫我来巡山","note":"","ucode":"DC23F4F0444F4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1188054,"avatar":"https://static001.geekbang.org/account/avatar/00/12/20/d6/c5295b7d.jpg","nickname":"潇如辰枫","note":"","ucode":"77232E4D186792","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55942,"discussion_content":"我觉的不会一直占用 ,毕竟时间片用完了 就收回了cpu使用权了. ","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1574415319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4907,"ip_address":""},"score":55942,"extra":""}]}]},{"had_liked":false,"id":12275,"user_name":"sunlight001","can_delete":false,"product_type":"c1","uid":1126975,"ip_address":"","ucode":"A72C4274D5DE8A","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/3f/fa4ac035.jpg","comment_is_top":false,"comment_ctime":1528759504,"is_pvip":false,"replies":[{"id":"4086","content":"不错","user_name":"作者回复","comment_id":12275,"uid":"1009360","ip_address":"","utype":1,"ctime":1528818378,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"121787843792","product_id":100006701,"comment_content":"自旋锁是尝试获取锁的线程不会立即阻塞，采用循环的方式去获取锁，好处是减少了上下文切换，缺点是消耗cpu","like_count":29,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419186,"discussion_content":"不错","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528818378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":67989,"user_name":"Roysatm","can_delete":false,"product_type":"c1","uid":1049199,"ip_address":"","ucode":"B9ACD64AB61861","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/6f/301b1381.jpg","comment_is_top":false,"comment_ctime":1550378498,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"104629593602","product_id":100006701,"comment_content":"<br>1.synchronized锁，可分为偏向锁、轻量级锁、重量级锁。在jvm没有显示关闭偏向锁的情况下，初始状态时默认是偏向锁时，<br>线程请求先通过CAS替换mark word中threadId,如果替换成功则该线程持有当前锁。如果替换失败，锁会升级为轻量级锁，<br>线程请求会尝试CAS替换mark word中指向栈中锁记录的指针，如果替换成功则该线程持有当前锁。<br>如果替换失败，当前线程会自旋一定次数，继续尝试获取CAS替换，如果超过一定自旋次数，锁升级为重量级锁。<br><br>synchronized锁是调用系统内核互斥锁实现的，线程在获取synchronized锁失败后，也会进入一个等待获取锁队列中（系统内核实现的），<br>线程会由运行态切换到阻塞态，让出CPU，待其他线程释放锁后唤醒它。<br><br>synchronize锁重（1.6之后jvm有优化）就是重在两点，一是调用内核互斥锁实现，二是线程获取锁失败会变成阻塞态，让出CPU，等待唤醒（有一定的上下文切换）","like_count":25,"discussions":[{"author":{"id":2506417,"avatar":"https://static001.geekbang.org/account/avatar/00/26/3e/b1/46f42c7e.jpg","nickname":"花臂Seven","note":"","ucode":"DBF07141BDE7A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531862,"discussion_content":"轻量级锁没有自旋","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637425544,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1393840,"avatar":"https://static001.geekbang.org/account/avatar/00/15/44/b0/c196c056.jpg","nickname":"SeaYang","note":"","ucode":"F44622A44CE8B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578529,"discussion_content":"在这看见你的评论好巧啊，by tuyang","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656858508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/10/4d2d6e64.jpg","nickname":"劳动维权","note":"","ucode":"1D5CEB96618E01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268671,"discussion_content":"别忘了偏向锁的撤销","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589812328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12414,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1528809017,"is_pvip":false,"replies":[{"id":"4069","content":"我理解偏斜锁就是为了优化那些没有并发却写了同步逻辑的代码；javac编译时能判断的是有限的；一旦有另外线程想获取，就会revoke，而且开销明显","user_name":"作者回复","comment_id":12414,"uid":"1009360","ip_address":"","utype":1,"ctime":1528816257,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"96018089529","product_id":100006701,"comment_content":"杨老师，偏斜锁有什么作用？还是没有看明白，如果只是被一个线程获取，那么锁还有什么意义？<br>另外，如果我有两个线程明确定义调用同一个对象的Synchronized块，JVM默认肯定先使用偏斜锁，之后在升级到轻量级所，必须经过撤销Revoke吗？编译的时候不会自动优化？","like_count":23,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419252,"discussion_content":"我理解偏斜锁就是为了优化那些没有并发却写了同步逻辑的代码；javac编译时能判断的是有限的；一旦有另外线程想获取，就会revoke，而且开销明显","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528816257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1250907,"avatar":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","nickname":"Monday","note":"","ucode":"77B9BACC783598","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293811,"discussion_content":"那这是程序员用错了锁，jvm来的补救咯？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595677652,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12335,"user_name":"陈一嘉","can_delete":false,"product_type":"c1","uid":1087070,"ip_address":"","ucode":"B189852AB2F168","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/5e/8bba3a8a.jpg","comment_is_top":false,"comment_ctime":1528766985,"is_pvip":false,"replies":[{"id":"4083","content":"差不多","user_name":"作者回复","comment_id":12335,"uid":"1009360","ip_address":"","utype":1,"ctime":1528818239,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"53068374537","product_id":100006701,"comment_content":"自旋锁 for(;;)结合cas确保线程获取取锁","like_count":13,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419220,"discussion_content":"差不多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528818239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":68137,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1550446493,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27320250269","product_id":100006701,"comment_content":"轻量级锁和重量级锁没有详细说明和区别，仅从名字不好区别","like_count":7,"discussions":[{"author":{"id":1033240,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkwbyTYtSCx6Qc7cQPnnRWv38Jybh3etziaPmuP8gHcgS6FMxcdftrKgWiamH6fc2iciaicDKDVEwcEibQ/132","nickname":"sami","note":"","ucode":"9A66FCA00D8A37","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":195342,"discussion_content":"轻量级锁不需要使用操作系统内部的互斥锁，减少了用户态到内核态的切换开销","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583255318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":29294,"user_name":"stephen chow","can_delete":false,"product_type":"c1","uid":1179504,"ip_address":"","ucode":"E4CA2B13BF2AFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/70/9329316e.jpg","comment_is_top":false,"comment_ctime":1538327654,"is_pvip":false,"replies":[{"id":"12431","content":"嗯，是有点写跑偏了，看上下文倒也能理解，谢谢指出","user_name":"作者回复","comment_id":29294,"uid":"1009360","ip_address":"","utype":1,"ctime":1540312634,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"27308131430","product_id":100006701,"comment_content":"StampLock是先试着读吧？你写的先试着修改。。","like_count":6,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425542,"discussion_content":"嗯，是有点写跑偏了，看上下文倒也能理解，谢谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540312634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12279,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1528761578,"is_pvip":false,"replies":[{"id":"4079","content":"我理解是，cas是基于特定指令","user_name":"作者回复","comment_id":12279,"uid":"1009360","ip_address":"","utype":1,"ctime":1528817127,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"27298565354","product_id":100006701,"comment_content":"老师 AQS就不涉及用户态和内核态的切换了 对吧？","like_count":7,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419189,"discussion_content":"我理解是，cas是基于特定指令","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528817127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15672,"user_name":"刘杰","can_delete":false,"product_type":"c1","uid":1106503,"ip_address":"","ucode":"4B91701B322624","user_header":"https://static001.geekbang.org/account/avatar/00/10/e2/47/e910afec.jpg","comment_is_top":false,"comment_ctime":1531372627,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18711241811","product_id":100006701,"comment_content":"偏斜锁和轻量级锁的区别不是很清晰","like_count":4},{"had_liked":false,"id":12511,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1528882781,"is_pvip":false,"replies":[{"id":"4119","content":"自旋是基于乐观假设，就是等待中锁被释放了，单核cpu就自己占着cpu，别人没机会让","user_name":"作者回复","comment_id":12511,"uid":"1009360","ip_address":"","utype":1,"ctime":1528896259,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"18708751965","product_id":100006701,"comment_content":"关于自旋转锁不适合单核CPU的问题，下来查找了一下资料:<br>1.JVM在操作系统中是作为一个进程存在，但是OS一般都将将线程作为最小调度单位，进程是资源分配的最小单位。这就是说进程是不活动的，只是作为线程的容器，那么Java的线程是在JVM进程中，也被CPU调度。<br>2.单核CPU使用多线程时，一个线程被CPU执行，其它处于等待轮巡状态。<br>3.为什么多线程跑在单核CPU上也比较快呢？是由于这种线程还有其它IO操作(File,Socket)，可以跟CPU运算并行。<br>4.结论，根据前面3点的分析，与自旋转锁的优点冲突：线程竞争不激烈，占用锁时间短。","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419282,"discussion_content":"自旋是基于乐观假设，就是等待中锁被释放了，单核cpu就自己占着cpu，别人没机会让","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528896259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12483,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1528856319,"is_pvip":false,"replies":[{"id":"4120","content":"已回复，我也认为单核无用","user_name":"作者回复","comment_id":12483,"uid":"1009360","ip_address":"","utype":1,"ctime":1528896318,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"18708725503","product_id":100006701,"comment_content":"杨老师，看到有回复说自旋锁在单核CPU上是无用，感觉这个理论不准确，因为Java多线程在很早时候单核CPC的PC上就能运行，计算机原理中也介绍，控制器会轮巡各个进程或线程。而且多线程是运行在JVM上，跟物理机没有很直接的关系吧？","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419272,"discussion_content":"已回复，我也认为单核无用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528896318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":65108,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1549064386,"is_pvip":false,"replies":[{"id":"23356","content":"谢谢指出","user_name":"作者回复","comment_id":65108,"uid":"1009360","ip_address":"","utype":1,"ctime":1549819984,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"14433966274","product_id":100006701,"comment_content":"『其逻辑是先试着修改，然后通过 validate 方法确认是否...』    <br>这里面先试着修改写错了，小编帮忙改下吧，应该是：『其逻辑是先试着读，然后....』 我看到留言中，有其它同学早就提出了，但是一直没有被修正。。。。","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":438321,"discussion_content":"谢谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549819984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":32799,"user_name":"大熊","can_delete":false,"product_type":"c1","uid":1101491,"ip_address":"","ucode":"DBD3FEE0AA6DB6","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/b3/804aa247.jpg","comment_is_top":false,"comment_ctime":1539697987,"is_pvip":false,"replies":[{"id":"12432","content":"针对不同场景，例如，并发读比写多，比较适合readwritelock；readlock不是排他的（exclusive），保证看到的data是更新过的","user_name":"作者回复","comment_id":32799,"uid":"1009360","ip_address":"","utype":1,"ctime":1540312841,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"14424599875","product_id":100006701,"comment_content":"老师，请问下为什么要有读锁？读不会改变数据为什么还要加锁呢","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426894,"discussion_content":"针对不同场景，例如，并发读比写多，比较适合readwritelock；readlock不是排他的（exclusive），保证看到的data是更新过的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1540312841,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217030,"discussion_content":"要保证数据的准确性呀。如果读的时候 也在写，那数据不就不准了吗\n所以，都是读的时候，就不加锁，读的时候 有在写的时候，还是要加锁的，即 互斥","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585495704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":18572,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1533461009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10123395601","product_id":100006701,"comment_content":"自旋锁是一种乐观优化<br>自旋锁:竞争锁的失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几个空循环(基于预测在不久的将来就能获得)，在经过若干次循环后，如果可以获得锁，那么进入临界区，如果还不能获得锁，才会真实的将线程在操作系统层面进行挂起。<br><br>适用场景:自旋锁可以减少线程的阻塞，这对于锁竞争不激烈，且占用锁时间非常短的代码块来说，有较大的性能提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗。","like_count":2},{"had_liked":false,"id":270324,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1609067199,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5904034495","product_id":100006701,"comment_content":"syncronized为了性能优化按场景将锁分为几个阶段：<br>无锁，偏向锁，轻量级，重量级<br>相应的应用场景也是从竞争无，竞争少，竞争多<br>同步加锁都是在对象上的，相应信息也是在对象的MARK WORD上<br>偏向锁是在有一个线程获取锁时直接在对应锁对象的MARK WORD上设置当前为偏向锁模式及对应的偏向锁线程ID<br>偏向锁到轻量级的切换是2个及以上线程发生了竞争，如果竞争的线程CAS能替换获取到锁，则进入轻量级锁，否则进入重量级锁<br>轻量级锁有线程在获取锁时使用CAS自旋<br>进入重量级锁则获取不到锁的线程就会进入到系统挂起的状态了，涉及到用户态到系统态的切换<br>这里涉及到JAVA的线程模型是与操作系统线程一对一的","like_count":1},{"had_liked":false,"id":131039,"user_name":"rong","can_delete":false,"product_type":"c1","uid":1128740,"ip_address":"","ucode":"637A27C532D817","user_header":"https://static001.geekbang.org/account/avatar/00/11/39/24/ab14f6cf.jpg","comment_is_top":false,"comment_ctime":1567606675,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5862573971","product_id":100006701,"comment_content":"老师，有个问题不明白，就是锁代码块的时候，只有一个monitorenter指令，那怎么知道这个锁绑定的是哪个对象呢？比如我自定义了Person类，他的实例person，@synchronized（person），我看到字节码中只有monitorenter，没看到他和person对象的绑定关系啊？","like_count":1,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384710,"discussion_content":"在对象头中有记录的，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626706563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1022282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/99/4a/bdf26d5c.jpg","nickname":"石头汤","note":"","ucode":"45E4578E54F585","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352855,"discussion_content":"这部分要去看JVM的源码，比如Hotspot","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614870147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82002,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1554101058,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5849068354","product_id":100006701,"comment_content":"自旋锁我理解了，但是没用过，请问其对于Java来说是jdk提供的api还是JVM层面的实现，还是OS层面的实现呢？","like_count":1},{"had_liked":false,"id":50176,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1544885966,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5839853262","product_id":100006701,"comment_content":"自旋锁，之前知乎上看过一个比喻，一辆车遇到红灯，一看还有5秒就变绿了，那就不熄火等一下。发动机类比CPU，先占一会，就能获取锁（绿灯），如果要等5分钟，就熄火等待，时间到了再打火成本也合算。<br>恩，还是回到，锁本质的问题上来理解锁吧！<br>锁-本质就是一种多线程同步机制，各种锁华丽花哨的是对锁特征的描述。<br>本节需要扩充，然后多看几遍。","like_count":1},{"had_liked":false,"id":21154,"user_name":"哦哦","can_delete":false,"product_type":"c1","uid":1160363,"ip_address":"","ucode":"417DEAA0992667","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/ab/75e254cf.jpg","comment_is_top":false,"comment_ctime":1534941701,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5829908997","product_id":100006701,"comment_content":"自旋锁失败后，不是进入同步等待队列吗？","like_count":1},{"had_liked":false,"id":18469,"user_name":"gesanri","can_delete":false,"product_type":"c1","uid":1121174,"ip_address":"","ucode":"AE3B97DC3ED668","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELtOO0HKrj5SI5JSlmwiaCvaF6GLiaTmf5NX88OZaO3HymTAGTeIoicBUjqzmMF6sF5raPFjuqLFibrrw/132","comment_is_top":false,"comment_ctime":1533351186,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828318482","product_id":100006701,"comment_content":"我有一个疑问，最后这个stampedlock的例子，access方法中，调用读乐观锁之后直接就进行read操作，但这个时候不知道validate的结果，如果validate为false，还要再read一次，为什么不先判断validate为true再read呢？是因为read这个操作太轻量级了吗？","like_count":1},{"had_liked":false,"id":18463,"user_name":"苍天大树","can_delete":false,"product_type":"c1","uid":1105668,"ip_address":"","ucode":"DB56B976E8CE5F","user_header":"https://static001.geekbang.org/account/avatar/00/10/df/04/ca6e1f76.jpg","comment_is_top":false,"comment_ctime":1533344616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5828311912","product_id":100006701,"comment_content":"第一次回答问题哈，自旋锁就是当获取锁失败后，自己定时循环去获取锁，不进入休眠状态。这样的好处就是快，坏处就是消耗cpu","like_count":1},{"had_liked":false,"id":13484,"user_name":"Cui","can_delete":false,"product_type":"c1","uid":1106775,"ip_address":"","ucode":"169F6EEEEE7E5E","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/57/e5de0216.jpg","comment_is_top":false,"comment_ctime":1529671163,"is_pvip":false,"replies":[{"id":"4592","content":"LockSupport park是waiting，另一个是blocked；具体底层，马上一篇有说明","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529946020,"ip_address":"","comment_id":13484,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5824638459","product_id":100006701,"comment_content":"老师你好 心中一直有个疑问：synchronize和AQS的LockSupport同样起到阻塞线程的作用，这两者的区别是什么？能不能从实现原理和使用效果的角度说说？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419664,"discussion_content":"LockSupport park是waiting，另一个是blocked；具体底层，马上一篇有说明","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529946020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12486,"user_name":"THROW","can_delete":false,"product_type":"c1","uid":1112141,"ip_address":"","ucode":"A3C089A8F5F941","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/4d/4b748ff1.jpg","comment_is_top":false,"comment_ctime":1528858858,"is_pvip":false,"replies":[{"id":"4128","content":"非常感谢，这话写的是有问题","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528898274,"ip_address":"","comment_id":12486,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823826154","product_id":100006701,"comment_content":"StampedLock那里乐观读锁好像是说写操作不需要等待读操作完成，而不是&quot;读操作并不需要等待写完成&quot;吧","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419274,"discussion_content":"非常感谢，这话写的是有问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528898274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12451,"user_name":"食指可爱多","can_delete":false,"product_type":"c1","uid":1045721,"ip_address":"","ucode":"B918E07F55AB9E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/d9/e572ae4d.jpg","comment_is_top":false,"comment_ctime":1528848334,"is_pvip":true,"replies":[{"id":"4121","content":"是的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528896335,"ip_address":"","comment_id":12451,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823815630","product_id":100006701,"comment_content":"以前写过自旋锁的实现，当某个线程调用自旋锁实例的lock方法时，使用cas进行设置，cas（lockThread, null, currentThread）,也就是当前无锁定时当前线程会成功,失败则循环尝试直到成功。利用cas保证操作的原子性，成员变量lockThread设置为volatile保证并发时线程间可见性。所以从机制上可以看到，若是在高并发场景，成功拿到锁之外的所有线程会继续努力尝试持有锁，造成CPU资源的浪费。如评论中其它同学所说适合在低并发场景使用。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419262,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528896335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12333,"user_name":"爪哇夜未眠","can_delete":false,"product_type":"c1","uid":1006025,"ip_address":"","ucode":"BBEB80EB670770","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/c9/f44cb7f3.jpg","comment_is_top":false,"comment_ctime":1528766821,"is_pvip":false,"replies":[{"id":"4075","content":"有的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528816844,"ip_address":"","comment_id":12333,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823734117","product_id":100006701,"comment_content":"老师后面会详细讲 AQS 吗","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419219,"discussion_content":"有的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528816844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12326,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1528766264,"is_pvip":true,"replies":[{"id":"4076","content":"差不多，算是种乐观主义的“优化”","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528816916,"ip_address":"","comment_id":12326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823733560","product_id":100006701,"comment_content":"今天老师讲这个真够我喝一壶的，而且老师总结的角度启发性很大，最近也再读JCIP，对比起来很有意思，对于自旋锁这个理解，我一直还是蛮肤浅的，顾名思义比较多，就是在那里兜几个圈子——写个循环——试几次，好处是减少线程切换导致的开销，一般也需要有底层有CAS能力的构件支持一下，比如用Atomic开头那些类，当然也未必，比如说nio读不出来东西的时候，也先尝试几次，总之就是暂时不把cpu让度出去，先在占着坑来几次，大概可能这么个意思吧","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419213,"discussion_content":"差不多，算是种乐观主义的“优化”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528816916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12294,"user_name":"肖一林","can_delete":false,"product_type":"c1","uid":1113317,"ip_address":"","ucode":"1DE45D906EB836","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/e5/605f423f.jpg","comment_is_top":false,"comment_ctime":1528762994,"is_pvip":false,"replies":[{"id":"4077","content":"是的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528816959,"ip_address":"","comment_id":12294,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5823730290","product_id":100006701,"comment_content":"重量级锁还是互斥锁吗？自旋锁应该是线程拿不到锁的时候，采取重试的办法，适合重试次数不多的场景，如果重试次数过多还是会被系统挂起，这种情况下还不如没有自旋锁。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419196,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528816959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332203,"user_name":"DoctorDeng","can_delete":false,"product_type":"c1","uid":1122760,"ip_address":"","ucode":"116378F7377768","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/c8/c2343cb6.jpg","comment_is_top":false,"comment_ctime":1643095141,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1643095141","product_id":100006701,"comment_content":"看了 JVM 源码，严格意义上讲 synchronized 中的重量级锁不是直接通过 mutex 实现，而是在实现上使用到了 mutex。具体而言当线程要进入 monitor 时，会尝试通过 CAS 将 monitor 的所有者设置为自己，如果成功，则相当于获取到锁。如果失败，线程会被添加到 _cxq 队列中，并调用 park() 方法来阻塞当前线程，而 park() 方法在 posix 系统上实际是调用 pthread_mutex_lock 方法，该方法在获取 mutex 失败时会阻塞当前线程。","like_count":0,"discussions":[{"author":{"id":1122760,"avatar":"https://static001.geekbang.org/account/avatar/00/11/21/c8/c2343cb6.jpg","nickname":"DoctorDeng","note":"","ucode":"116378F7377768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550997,"discussion_content":"自旋操作是重量级锁（ObjectMonitor）实现的一部分，网上有些文章说这是自旋锁或这是轻量级锁实现的一部分都是错误的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644841488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122760,"avatar":"https://static001.geekbang.org/account/avatar/00/11/21/c8/c2343cb6.jpg","nickname":"DoctorDeng","note":"","ucode":"116378F7377768","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550993,"discussion_content":"上面说的有点小错误，重量级锁在获取锁失败，在休眠(park()) 和唤醒(unpark()) 线程时在 posix 系统上基于 mutex 实现。而获取锁的操作始终都基于 CAS 实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644841075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296948,"user_name":"AAA_叶子","can_delete":false,"product_type":"c1","uid":1325994,"ip_address":"","ucode":"1E93617D308EE0","user_header":"https://static001.geekbang.org/account/avatar/00/14/3b/aa/e8dfcd7e.jpg","comment_is_top":false,"comment_ctime":1623236152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623236152","product_id":100006701,"comment_content":"jvm考虑到线程持有锁时间一般不会很长，然后线程切换开销又很大，所以采用自旋一段时间来获取锁，","like_count":0},{"had_liked":false,"id":291511,"user_name":"枫中浪子","can_delete":false,"product_type":"c1","uid":2351949,"ip_address":"","ucode":"860BEA32059B37","user_header":"https://static001.geekbang.org/account/avatar/00/23/e3/4d/8a26dbb2.jpg","comment_is_top":false,"comment_ctime":1620315221,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620315221","product_id":100006701,"comment_content":"请问老师synchronized偏向锁撤销的时候为什么用cas，只有一个线程可以解锁，感觉完全可以不用cas啊","like_count":0},{"had_liked":false,"id":273825,"user_name":"张新亮","can_delete":false,"product_type":"c1","uid":2406845,"ip_address":"","ucode":"B68A71CDEA551A","user_header":"https://static001.geekbang.org/account/avatar/00/24/b9/bd/7fef12c8.jpg","comment_is_top":false,"comment_ctime":1610690484,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"1610690484","product_id":100006701,"comment_content":"有个问题，轻量级锁膨胀为重量级锁的条件，有人说是CAS尝试获取对象的Mark Word失败后，自旋一定次数之后膨胀。<br>我的问题，为什么要自旋一定次数？自旋次数在哪里配置？源码里并没找到相关逻辑。","like_count":0,"discussions":[{"author":{"id":1303914,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e5/6a/3c618346.jpg","nickname":"二桃杀三士","note":"","ucode":"5D7CAB540B0DF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353839,"discussion_content":"那就不自旋，直接升级。https://mp.weixin.qq.com/s/3PBGQBR9DNphE7jSMvOHXQ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615208266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":254019,"user_name":"影山飞雄","can_delete":false,"product_type":"c1","uid":1626622,"ip_address":"","ucode":"127F4CA21207D8","user_header":"https://static001.geekbang.org/account/avatar/00/18/d1/fe/2ca6f40a.jpg","comment_is_top":false,"comment_ctime":1603018425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603018425","product_id":100006701,"comment_content":"平时用的多的可能就是线程池去处理，因为没有什么大数据量访问的场景。读这篇，能学到Synchronized升降级的原理，偏向锁 轻量级锁和重量级锁，jvm底层会根据共享状态的竞争环境去升级锁，降级的出发也是jvm在处于安全点时，检查空闲的Monitor选择降级。思考题部分，在看几种几种自选锁的实现中，顺带了看了下ThreadLocal的源码，看到处理hash冲突也理解了变量0x61c88647的作用，这个确实很神奇。。。","like_count":0},{"had_liked":false,"id":242530,"user_name":"超","can_delete":false,"product_type":"c1","uid":1100075,"ip_address":"","ucode":"0E4C60D9238851","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hDFZJXfNCG9cIXaysJZEZ931YIdeyRWzUP1oxNCdBZUyjmWtMzM05GibKb8F04m235kCMz4fINK6Q6A9l3DRvvg/132","comment_is_top":false,"comment_ctime":1597752159,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597752159","product_id":100006701,"comment_content":"关于锁降级这个点没理解，老师能否说的在详细些，或者发个链接","like_count":0},{"had_liked":false,"id":236651,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1595490716,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595490716","product_id":100006701,"comment_content":"“很多时候解决的是知道与否，真正的提高还是要实践踩坑”这句话深有感触","like_count":0},{"had_liked":false,"id":235696,"user_name":"陈狄","can_delete":false,"product_type":"c1","uid":2011954,"ip_address":"","ucode":"456F00EB2EB43D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b3/32/0ee78a1a.jpg","comment_is_top":false,"comment_ctime":1595152529,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1595152529","product_id":100006701,"comment_content":"老师我在看书的时候，看到重量级锁的时候，对象头的mark word里会保存“指向互斥量（重量级锁）的指针“，这句话一直理解不了。<br>轻量级锁的时候mark word的指针会指向栈帧里的锁空间，但是这个“指向互斥量”里的互斥量是什么？也是一块空间吗？互斥量是保存在哪里呢？","like_count":0,"discussions":[{"author":{"id":2406845,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b9/bd/7fef12c8.jpg","nickname":"张新亮","note":"","ucode":"B68A71CDEA551A","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342467,"discussion_content":"操作系统内置的一个对象，ObjectMonitor类型，轻量级锁膨胀为重量级锁时创建。具体去openjdk中看下synchronizer.cpp和objectMonitor.cpp这两个文件的源码","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610689248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2314165,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4f/b5/bd6140a5.jpg","nickname":"ARM","note":"","ucode":"788FD0DBD39B94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387465,"discussion_content":"重量级锁的MARK WORD锁标记指向加锁对象objectmonitor，轻量级锁指向第一次加锁的所记录","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628183485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193933,"user_name":"白不吃","can_delete":false,"product_type":"c1","uid":1033578,"ip_address":"","ucode":"F019914D8819C2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c5/6a/7f858f1f.jpg","comment_is_top":false,"comment_ctime":1584988979,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1584988979","product_id":100006701,"comment_content":"感觉还是讲的不清楚， ReentrantLock相比于StampedLock优势到低在哪里， ReentrantReadWriteLock在多线程读取的时候也不会阻塞，只有一个线程开始修改数据（写数据）的时候才会阻塞读取操作。这一点StampedLock9也是同样的思路，为啥就性能好一些？","like_count":0},{"had_liked":false,"id":192695,"user_name":"护爽使者","can_delete":false,"product_type":"c1","uid":1275464,"ip_address":"","ucode":"12DC35DD74671C","user_header":"https://static001.geekbang.org/account/avatar/00/13/76/48/5ab89daa.jpg","comment_is_top":false,"comment_ctime":1584868740,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584868740","product_id":100006701,"comment_content":"锁 不能降级吧","like_count":0,"discussions":[{"author":{"id":2314165,"avatar":"https://static001.geekbang.org/account/avatar/00/23/4f/b5/bd6140a5.jpg","nickname":"ARM","note":"","ucode":"788FD0DBD39B94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387466,"discussion_content":"开启偏向锁的话，会有锁撤销，偏向锁转为无锁；在轻量级锁切换时也会转为无锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628183554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187155,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1584027283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584027283","product_id":100006701,"comment_content":"第一次接触到StampedLock,学习了","like_count":0},{"had_liked":false,"id":166571,"user_name":"Lh","can_delete":false,"product_type":"c1","uid":1102951,"ip_address":"","ucode":"19CA4286A49DB7","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/67/0eaa81a4.jpg","comment_is_top":false,"comment_ctime":1577504474,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577504474","product_id":100006701,"comment_content":"请问下老师！分布式应用，为了保证db和cache的一致，去实现一个分布式读写锁有没有必要？","like_count":0},{"had_liked":false,"id":152553,"user_name":"Geek_032104","can_delete":false,"product_type":"c1","uid":1298282,"ip_address":"","ucode":"25542A2348F99F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/G61OS6hibNG7iakUmXeKmcY5VtFWnPpywzjOcUCm3t0HsibCibm3jzLNbdvjKQ8G8WSIkicBiaqoCsvHibn3M7wV4YbrA/132","comment_is_top":false,"comment_ctime":1574042124,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574042124","product_id":100006701,"comment_content":"在读比写多的情况下，synchronize，readwriteLock，Stamped Lock它们的性能是依次递增的吗？","like_count":0},{"had_liked":false,"id":149489,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1573247403,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573247403","product_id":100006701,"comment_content":"偏斜锁 对于一个线程独占的应用场景有性能优势。<br>轻量级锁和重量级锁都是针对多线程并发环境。老师能否讲讲两者的本质区别，多谢！","like_count":0},{"had_liked":false,"id":142933,"user_name":"KAGEMUSHA","can_delete":false,"product_type":"c1","uid":1144504,"ip_address":"","ucode":"DFC05BE62A9C10","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","comment_is_top":false,"comment_ctime":1571589423,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571589423","product_id":100006701,"comment_content":"相比基础部分，进阶真的有些难，不过难度高点是好事情，这样的文章值得在不同水平的阶段反复阅读，每次都会有不同的收获","like_count":0},{"had_liked":false,"id":134261,"user_name":"随心而至","can_delete":false,"product_type":"c1","uid":1097836,"ip_address":"","ucode":"31866865255101","user_header":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","comment_is_top":false,"comment_ctime":1568786259,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568786259","product_id":100006701,"comment_content":"AtomicInteger中使用的自旋spin, 其实就是不断尝试，直到CAS成功。 <br>public final int getAndUpdate(IntUnaryOperator updateFunction) {<br>        int prev, next;<br>        do {<br>            prev = get();<br>            next = updateFunction.applyAsInt(prev);<br>        } while (!compareAndSet(prev, next));<br>        return prev;<br>    }","like_count":0,"discussions":[{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287496,"discussion_content":"是自旋spin但不是自旋锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593448365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":127003,"user_name":"王博","can_delete":false,"product_type":"c1","uid":1364095,"ip_address":"","ucode":"3D463574542A11","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/7f/1ad28cd3.jpg","comment_is_top":false,"comment_ctime":1566532656,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1566532656","product_id":100006701,"comment_content":"老师，我有两点不太明白，如果方便希望能够得到解答<br>1、为什么非公平锁的吞吐量比公平锁的吞吐量高<br>2、synchronized锁的升级是偏向锁-轻量级锁-重量级锁，但是代码是两个逻辑if...偏向锁else...轻量级锁...怎么升级重量级锁","like_count":0},{"had_liked":false,"id":109046,"user_name":"核桃","can_delete":false,"product_type":"c1","uid":1385204,"ip_address":"","ucode":"7AB05270CBCCCB","user_header":"https://static001.geekbang.org/account/avatar/00/15/22/f4/9fd6f8f0.jpg","comment_is_top":false,"comment_ctime":1561952235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1561952235","product_id":100006701,"comment_content":"关于synchronzied这个关键字的实现，我在网上查看了一些资料。<br>1.首先这个有多个队列，每次所有的请求都会进入到ContentionList 竞争队列当中，<br>2.然后有资格获取候选资源的线程会被移动到Entry List当中,<br>3.如果线程被阻塞了就会扔到Wait Set当中。<br>4.那么当争夺资源的时候，就保证任意一个时刻最多只有一个线程获取到资源，该线程成为OneDeck,<br><br>那么这里其实包括重入锁的实现，就是在释放锁的时候，线程还会再次进入到Entry List去竞争资源导致的，但是很有意思的是，本人实验过发现，一般重入两次之后就不没有再次重入了，可能是jvm做了优化了。<br><br>另外这里还有公平性的保证，其实就是在竞争队列里面对同步队列中当前节点是否有前驱节点进行判断。<br>","like_count":0},{"had_liked":false,"id":81744,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1554024506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554024506","product_id":100006701,"comment_content":"想知道AQS是什么？","like_count":0},{"had_liked":false,"id":71024,"user_name":"康","can_delete":false,"product_type":"c1","uid":1435518,"ip_address":"","ucode":"8BDC8135070244","user_header":"https://static001.geekbang.org/account/avatar/00/15/e7/7e/34fa766f.jpg","comment_is_top":false,"comment_ctime":1551247560,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551247560","product_id":100006701,"comment_content":"单cpu应该也是有效的，多个线程抢一个cpu时间，保证线程是活的，没有切换上下文即可。","like_count":0},{"had_liked":false,"id":62196,"user_name":"……","can_delete":false,"product_type":"c1","uid":1116443,"ip_address":"","ucode":"DA4B01EDFA3B1C","user_header":"https://static001.geekbang.org/account/avatar/00/11/09/1b/8665aa89.jpg","comment_is_top":false,"comment_ctime":1547976617,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1547976617","product_id":100006701,"comment_content":"自旋锁就是消耗CPU资源，采用CAS方式，避免线程进入阻塞状态，自旋失败，是不是就会升级为重量级锁","like_count":0},{"had_liked":false,"id":21558,"user_name":"一个坏人","can_delete":false,"product_type":"c1","uid":1032305,"ip_address":"","ucode":"4AF05BF008095A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c0/71/c83d8b15.jpg","comment_is_top":false,"comment_ctime":1535167883,"is_pvip":true,"replies":[{"id":"8295","content":"这个...还真没想过，“对齐”就是原因吧，更高效的访问，处理器操作方便","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1536075169,"ip_address":"","comment_id":21558,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1535167883","product_id":100006701,"comment_content":"老师好，请教一下：“自动内存管理系统为什么要求对象的大小必须是8字节的整数倍？”，即内存对齐的根本原因在于？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422738,"discussion_content":"这个...还真没想过，“对齐”就是原因吧，更高效的访问，处理器操作方便","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1536075169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2351949,"avatar":"https://static001.geekbang.org/account/avatar/00/23/e3/4d/8a26dbb2.jpg","nickname":"枫中浪子","note":"","ucode":"860BEA32059B37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372437,"discussion_content":"缓存一个cache line大小是8字节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620315198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1103445,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d6/55/47e76936.jpg","nickname":"叶易","note":"","ucode":"0983EA217ACF28","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":182446,"discussion_content":"这应该是为了解决不同cpu架构下面的缓存行伪共享问题吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582426013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20611,"user_name":"小飞哥 ‍超級會員","can_delete":false,"product_type":"c1","uid":1110049,"ip_address":"","ucode":"417F9563B3005B","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/21/104b9565.jpg","comment_is_top":false,"comment_ctime":1534590733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534590733","product_id":100006701,"comment_content":"太底层了，在应用过程中如何解决这些种类的锁呢？","like_count":0},{"had_liked":false,"id":20400,"user_name":"July","can_delete":false,"product_type":"c1","uid":1005384,"ip_address":"","ucode":"553873BE26CDA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/48/3da605c6.jpg","comment_is_top":false,"comment_ctime":1534420728,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1534420728","product_id":100006701,"comment_content":"这一节看的好晕 得反复多看几遍","like_count":0,"discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":149529,"discussion_content":"最后看懂了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579761305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20002,"user_name":"四阿哥","can_delete":false,"product_type":"c1","uid":1104580,"ip_address":"","ucode":"3296E89174D370","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/c4/270db3ad.jpg","comment_is_top":false,"comment_ctime":1534208353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1534208353","product_id":100006701,"comment_content":"这里说的普通轻量级锁，没明白具体是什么","like_count":0},{"had_liked":false,"id":18116,"user_name":"小逗宝","can_delete":false,"product_type":"c1","uid":1190032,"ip_address":"","ucode":"6F0B3050A579EB","user_header":"","comment_is_top":false,"comment_ctime":1533138773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1533138773","product_id":100006701,"comment_content":"请问，针对大量数据的并发读取和写入，章节最后的例子适合吗？如果不适合，该如何设计呢？希望老师能指导一下，谢谢","like_count":0},{"had_liked":false,"id":17174,"user_name":"Azhen","can_delete":false,"product_type":"c1","uid":1126448,"ip_address":"","ucode":"B34A8157A0DD7D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/30/439c6b43.jpg","comment_is_top":false,"comment_ctime":1532480886,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1532480886","product_id":100006701,"comment_content":"优化读基于假设，大多数情况下读操作并不会和写操作冲突，其逻辑是先试着修改，然后通过 validate 方法确认是否进入了写模式，如果没有进入，就成功避免了开销；如果进入，则尝试获取读锁。<br><br>应该是先试着读","like_count":0},{"had_liked":false,"id":16364,"user_name":"Xiao","can_delete":false,"product_type":"c1","uid":1179212,"ip_address":"","ucode":"71FFCCEEDE09E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/4c/46eb517a.jpg","comment_is_top":false,"comment_ctime":1531908235,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1531908235","product_id":100006701,"comment_content":"杨老师，麻烦您给详细解释了偏向锁、轻量级锁的膨胀过程呢","like_count":0},{"had_liked":false,"id":15908,"user_name":"宾语","can_delete":false,"product_type":"c1","uid":1122907,"ip_address":"","ucode":"1864868143FB67","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/5b/18c9f040.jpg","comment_is_top":false,"comment_ctime":1531638007,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1531638007","product_id":100006701,"comment_content":"挺不错","like_count":0},{"had_liked":false,"id":15038,"user_name":"有福","can_delete":false,"product_type":"c1","uid":1045377,"ip_address":"","ucode":"3DEAB5CEBE0F85","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f3/81/42e29d40.jpg","comment_is_top":false,"comment_ctime":1530834223,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530834223","product_id":100006701,"comment_content":"自旋锁基本形式就是通过while循环加上cpu指令级别保证的cas原子操作来判断某一个共享变量内存的值是否被其他线程修改，如果没有修改那么就认为获取到了锁。<br>这个变量需要设置为volatile.否则容易被指令重排引发bug。<br><br>之前实际应用的场景就是开发多核处理器下的core to core的高性能无锁队列。<br><br>由于是一直while循环，所以cpu在检查锁状态的时候基本上是100%，所以自旋锁基本上是用来判断某个状态是否发生，也就是用来同步的，而不是用来互斥的。","like_count":0},{"had_liked":false,"id":14607,"user_name":"安徒生童话","can_delete":false,"product_type":"c1","uid":1160292,"ip_address":"","ucode":"70E9DFCBFAA3BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/b4/64/98a3df60.jpg","comment_is_top":false,"comment_ctime":1530575356,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530575356","product_id":100006701,"comment_content":"可是我还是不清楚偏斜锁和轻量级锁的区别","like_count":0},{"had_liked":false,"id":13489,"user_name":"Cui","can_delete":false,"product_type":"c1","uid":1106775,"ip_address":"","ucode":"169F6EEEEE7E5E","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/57/e5de0216.jpg","comment_is_top":false,"comment_ctime":1529673356,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1529673356","product_id":100006701,"comment_content":"基于AQS的锁是属于哪种级别的锁？","like_count":0},{"had_liked":false,"id":12791,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1529033371,"is_pvip":false,"replies":[{"id":"4307","content":"我记得validate会返回false，如果输入stamp是0，所以程序并没有漏洞","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529170450,"ip_address":"","comment_id":12791,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529033371","product_id":100006701,"comment_content":"杨老师，StampedSample这个例子，access方法是不是写错了？<br>long stamp = sl.tryOptimisticRead();<br>Data data = read();<br>应该是先判断tryOptimisticRead的结果，如果获取了所，才进入Read()吧？因为没有获取锁的读，可能是脏读。<br>自己代码调试，发现即使try Optimistic的结果为0, 也会向下执行read().<br><br>","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419411,"discussion_content":"我记得validate会返回false，如果输入stamp是0，所以程序并没有漏洞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529170450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12507,"user_name":"I.am DZX","can_delete":false,"product_type":"c1","uid":1122095,"ip_address":"","ucode":"DBE2B7A50C423A","user_header":"https://static001.geekbang.org/account/avatar/00/11/1f/2f/e35d6a1d.jpg","comment_is_top":false,"comment_ctime":1528875149,"is_pvip":false,"replies":[{"id":"4126","content":"我理解非公平是不保证，另外自旋抢到的线程不见得就是等的久的","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528897067,"ip_address":"","comment_id":12507,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528875149","product_id":100006701,"comment_content":"请问自旋锁和非公平获取锁是不是有点冲突了","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419281,"discussion_content":"我理解非公平是不保证，另外自旋抢到的线程不见得就是等的久的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528897067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12441,"user_name":"Geek_e61ae8","can_delete":false,"product_type":"c1","uid":1132704,"ip_address":"","ucode":"B478AF24631581","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqqQYBLvb0h2SjjZpRFicPb6LHWflobgRs8gicBn5N3QIEUnpJDmaRxUMvTJ1nZfmNwZ7L6Cq71R2YA/132","comment_is_top":false,"comment_ctime":1528823016,"is_pvip":false,"replies":[{"id":"4131","content":"我建议用StampedLock或读写锁","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528902062,"ip_address":"","comment_id":12441,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528823016","product_id":100006701,"comment_content":"老师讲到读写锁，这里涉及到读并发高，当我更改要加载的数据，这时需要写，读到内存后准备切换，但是一直获取不了写锁。这种采用自己boolean值来控制，让读sleep等待，或者直接返回不进锁（已经获取读锁的线程等处理结束）。写获取锁后更新，替换boolean值。另一种采用公平锁。老师觉得建议那种？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419258,"discussion_content":"我建议用StampedLock或读写锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528902062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12440,"user_name":"Geek_e61ae8","can_delete":false,"product_type":"c1","uid":1132704,"ip_address":"","ucode":"B478AF24631581","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqqQYBLvb0h2SjjZpRFicPb6LHWflobgRs8gicBn5N3QIEUnpJDmaRxUMvTJ1nZfmNwZ7L6Cq71R2YA/132","comment_is_top":false,"comment_ctime":1528822638,"is_pvip":false,"replies":[{"id":"4125","content":"没看懂，是说让读线程不停的检查boolean值等待吗？自己控制要达到的目的是什么呢","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528896899,"ip_address":"","comment_id":12440,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528822638","product_id":100006701,"comment_content":"这块老师讲了读写锁，如果读并发高，当配置更改，触发了写，但是又获取不了锁，这种情况可以采用boolean值自己控制当写完，替换内存时，让读的线程等待。（已经获取锁的等处理完）没处理的等待。 这种是建议加上公平锁好，还是说自己控制好","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419257,"discussion_content":"没看懂，是说让读线程不停的检查boolean值等待吗？自己控制要达到的目的是什么呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528896899,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12426,"user_name":"cxzm","can_delete":false,"product_type":"c1","uid":1076899,"ip_address":"","ucode":"E94ACEF9D507A6","user_header":"https://static001.geekbang.org/account/avatar/00/10/6e/a3/bec136c0.jpg","comment_is_top":false,"comment_ctime":1528815673,"is_pvip":false,"replies":[{"id":"4130","content":"这个还是请看操作系统相关代码或资料，原理上mutex和只有0、1值的semaphore是近似的，但现代操作系统怎么实现我真没研究过，谁有空儿补充下？","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528901931,"ip_address":"","comment_id":12426,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528815673","product_id":100006701,"comment_content":"杨老师，操作系统的互斥锁要怎么理解","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419255,"discussion_content":"这个还是请看操作系统相关代码或资料，原理上mutex和只有0、1值的semaphore是近似的，但现代操作系统怎么实现我真没研究过，谁有空儿补充下？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528901931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12408,"user_name":"张玮(大圣)","can_delete":false,"product_type":"c1","uid":1111343,"ip_address":"","ucode":"D567C4BE87D116","user_header":"https://static001.geekbang.org/account/avatar/00/10/f5/2f/56117bab.jpg","comment_is_top":false,"comment_ctime":1528805279,"is_pvip":false,"replies":[{"id":"4070","content":"嗯，我理解是一个意思","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528816308,"ip_address":"","comment_id":12408,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528805279","product_id":100006701,"comment_content":"自旋锁类似和忙等待一个套路","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419249,"discussion_content":"嗯，我理解是一个意思","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528816308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12341,"user_name":"tyson","can_delete":false,"product_type":"c1","uid":1110943,"ip_address":"","ucode":"E88F630B53C743","user_header":"https://static001.geekbang.org/account/avatar/00/10/f3/9f/3e4e8d46.jpg","comment_is_top":false,"comment_ctime":1528768075,"is_pvip":true,"replies":[{"id":"4082","content":"差不多，也要考虑退出自旋的情况","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528818228,"ip_address":"","comment_id":12341,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528768075","product_id":100006701,"comment_content":"简单来说就是while，一直cas直到成功吧。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419223,"discussion_content":"差不多，也要考虑退出自旋的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528818228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12301,"user_name":"浩","can_delete":false,"product_type":"c1","uid":1112961,"ip_address":"","ucode":"B07923D03AC193","user_header":"https://static001.geekbang.org/account/avatar/00/10/fb/81/f41482ff.jpg","comment_is_top":false,"comment_ctime":1528763462,"is_pvip":false,"replies":[{"id":"4078","content":"基本正确","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528817030,"ip_address":"","comment_id":12301,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1528763462","product_id":100006701,"comment_content":"自旋就是空转，什么都不干，就在循环等待锁，相当于缓冲一段时间，看能否获得锁，如果此次自旋获得锁，那么下次，会比此次更长时间自旋，增大获得锁的概率，否则，减少自旋次数。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419200,"discussion_content":"基本正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528817030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}