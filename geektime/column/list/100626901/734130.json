{"id":734130,"title":"22｜Web开发（下）：如何实现一个Todo List应用？","content":"<p>你好，我是Mike，今天我们继续讲如何使用Axum开发Web后端。学完这节课的内容后，你应该能使用Axum独立开发一个简单的Web后端应用了。</p><p>第21讲，我们已经讲到了第4步，处理Get query请求，拿到query中的参数。下面我们讲如何处理Post请求并拿到参数。</p><p>这节课的代码适用于 Axum v0.7 版本。</p><h2>基本步骤</h2><h3>第五步：解析 Post 请求参数</h3><p>当我们想向服务端提交一些数据的时候，一般使用HTTP POST方法。Post的数据会放在HTTP的body中，在HTML页面上，通常会使用表单form收集数据。</p><p>和前面的Query差不多，Axum给我们提供了Form解包器，可以方便地取得form表单数据。你可以参考下面的示例。</p><pre><code class=\"language-plain\">#[derive(Deserialize, Debug)]\nstruct Input {\n&nbsp; &nbsp; name: String,\n&nbsp; &nbsp; email: String,\n}\n\nasync fn accept_form(Form(input): Form&lt;Input&gt;) -&gt; Html&lt;&amp;'static str&gt; {\n&nbsp; &nbsp; tracing::debug!(\"form params {:?}\", input);\n\n&nbsp; &nbsp; Html(\"&lt;h3&gt;Form posted&lt;/h3&gt;\")\n}\n</code></pre><!-- [[[read_end]]] --><p>可以看到，相比于前面的Query示例，form示例代码结构完全一致，只是解包器由Query换成了 Form。这体现了Axum具有相当良好的人体工程学，让我们非常省力。</p><p>我们这里在结构体上derive了 Deserialize，它是serde库提供的反序列化宏。serde库是Rust生态中用得最广泛的序列化和反序列化框架。</p><p>要测试Post请求，你需要安装一个浏览器插件，比如 Postman，它可以让你在浏览器中方便地构建一个Form格式的Post请求。</p><p>完整代码示例在<a href=\"https://github.com/miketang84/jikeshijian/tree/master/2122-axumapp_stepbystep/axumapp05_form\">这里</a>，这个示例运行后，访问 <code>http://127.0.0.1:3000/form</code>，会出现一个表单。</p><p><img src=\"https://static001.geekbang.org/resource/image/86/e1/8648455e46194dc0d9d1828d304364e1.png?wh=1356x196\" alt=\"\"></p><p>在表单中填入数据后，可以观察到日志输出像下面这个样子：</p><pre><code class=\"language-plain\">2023-12-11T07:08:33.520071Z DEBUG axumapp05: listening on 127.0.0.1:3000\n2023-12-11T07:08:33.720071Z DEBUG request{method=GET uri=/ version=HTTP/1.1}: tower_http::trace::on_request: started processing request\n2023-12-11T07:08:33.720274Z DEBUG request{method=GET uri=/ version=HTTP/1.1}: tower_http::trace::on_response: finished processing request latency=0 ms status=200\n2023-12-11T07:08:33.833684Z DEBUG request{method=GET uri=/favicon.ico version=HTTP/1.1}: tower_http::trace::on_request: started processing request\n2023-12-11T07:08:33.833779Z DEBUG request{method=GET uri=/favicon.ico version=HTTP/1.1}: tower_http::trace::on_response: finished processing request latency=0 ms status=404\n2023-12-11T07:09:09.309848Z DEBUG request{method=GET uri=/form version=HTTP/1.1}: tower_http::trace::on_request: started processing request\n2023-12-11T07:09:09.309975Z DEBUG request{method=GET uri=/form version=HTTP/1.1}: tower_http::trace::on_response: finished processing request latency=0 ms status=200\n2023-12-11T07:09:13.964549Z DEBUG request{method=POST uri=/form version=HTTP/1.1}: tower_http::trace::on_request: started processing request\n2023-12-11T07:09:13.964713Z DEBUG request{method=POST uri=/form version=HTTP/1.1}: axumapp05: form params Input { name: \"111\", email: \"2222\" }\n2023-12-11T07:09:13.964796Z DEBUG request{method=POST uri=/form version=HTTP/1.1}: tower_http::trace::on_response: finished processing request latency=0 ms status=200\n</code></pre><p>我们可以看到，在日志的第9行 form 表单的数据已经解析出来了。</p><p>下一步我们研究如何处理传上来的Json格式的请求。</p><h3>第六步：解析 Json 请求参数</h3><p>在现代Web开发中，发POST请求更多的时候是提交Json数据，这时HTTP请求的content-type 是 application/json。这种情况Axum应该怎么处理呢？</p><p>还是一样的，非常简单。Axum提供了解包器Json，只需要把参数解包器修改一下就可以了，解析后的类型都不用变。你可以看一下修改后的代码。</p><pre><code class=\"language-plain\">#[derive(Deserialize, Debug)]\nstruct Input {\n&nbsp; &nbsp; name: String,\n&nbsp; &nbsp; email: String,\n}\n\nasync fn accept_json(Json(input): Json&lt;Input&gt;) -&gt; Html&lt;&amp;'static str&gt; {\n&nbsp; &nbsp; tracing::debug!(\"json params {:?}\", input);\n&nbsp; &nbsp; Html(\"&lt;h3&gt;Json posted&lt;/h3&gt;\")\n}\n</code></pre><p>完整代码示例在<a href=\"https://github.com/miketang84/jikeshijian/tree/master/2122-axumapp_stepbystep/axumapp06_jsoninput\">这里</a>。这种Post请求在浏览器URL地址栏里面就不太好测试了。最好安装Postman等工具来测试。我用的Postwoman插件操作界面如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/bc/2d374c92df13c23394c1d18835ae53bc.png?wh=1920x957\" alt=\"图片\"></p><p>控制台log输出为：</p><pre><code class=\"language-plain\">2023-12-11T07:37:02.093884Z DEBUG axumapp06: listening on 127.0.0.1:3000\n2023-12-11T07:37:07.665064Z DEBUG request{method=POST uri=/json version=HTTP/1.1}: tower_http::trace::on_request: started processing request\n2023-12-11T07:37:07.665244Z DEBUG request{method=POST uri=/json version=HTTP/1.1}: axumapp06: json params Input { name: \"mike\", email: \"mike@jksj.com\" }\n2023-12-11T07:37:07.665309Z DEBUG request{method=POST uri=/json version=HTTP/1.1}: tower_http::trace::on_response: finished processing request latency=0 ms status=200\n</code></pre><p>可以看到，我们成功解析出了json参数，并转换成了Rust结构体。</p><p>截止目前，我们接触到了三个解包器：Query、Form、Json。Axum还内置很多高级解包器，感兴趣的话你可以点击这个<a href=\"https://docs.rs/axum/latest/axum/extract/index.html\">链接</a>了解一下。</p><h3>解析出错了怎么办？</h3><p>这里我们先暂停一下，回头想想。Axum帮我们自动做了参数的解析，这点固然很好、很方便。但是，如果参数没有解析成功，Axum就会自动返回一些信息，而这些信息我们根本没有接触到，好像也不能控制，这就一点也不灵活了。</p><p>Axum的设计者其实考虑到了这个问题，也提供了相应的解决方案——Rejection。只需要在写解包器的时候，把参数类型改成使用 Result 包起来，Result的错误类型为相应的解包器对应的Rejection类型就行了。比如Json解包器就对应JsonRejection，Form解包器就对应FormRejection。</p><pre><code class=\"language-plain\">async fn create_user(payload: Result&lt;Json&lt;Value&gt;, JsonRejection&gt;) {\n</code></pre><p>用这种方式，我们能获得解析被驳回的详细错误原因，还可以根据这些原因来具体处理。比如我们可以返回自定义的错误信息模板。</p><p>比如：</p><pre><code class=\"language-plain\">use axum::{\n    extract::{Json, rejection::JsonRejection},\n    routing::post,\n    Router,\n};\nuse serde_json::Value;\nasync fn create_user(payload: Result&lt;Json&lt;Value&gt;, JsonRejection&gt;) {\n    match payload {\n        Ok(payload) =&gt; {\n            // We got a valid JSON payload\n        }\n        Err(JsonRejection::MissingJsonContentType(_)) =&gt; {\n            // Request didn't have `Content-Type: application/json`\n            // header\n        }\n        Err(JsonRejection::JsonDataError(_)) =&gt; {\n            // Couldn't deserialize the body into the target type\n        }\n        Err(JsonRejection::JsonSyntaxError(_)) =&gt; {\n            // Syntax error in the body\n        }\n        Err(JsonRejection::BytesRejection(_)) =&gt; {\n            // Failed to extract the request body\n        }\n        Err(_) =&gt; {\n            // `JsonRejection` is marked `#[non_exhaustive]` so match must\n            // include a catch-all case.\n        }\n    }\n}\nlet app = Router::new().route(\"/users\", post(create_user));\n</code></pre><p>更多详细的Rejection的信息，请参考<a href=\"https://docs.rs/axum/latest/axum/extract/rejection/index.html\">这里</a>。</p><h3>自定义Extractor</h3><p>当然，面对业务的千变万化，Axum还给了我们自定义解包器的能力。平时用得不多，但必要的时候你不会感觉被限制住。</p><p>这方面的内容属于扩展内容，有兴趣的话你可以自己研究一下。请参考<a href=\"https://docs.rs/axum/latest/axum/extract/index.html#defining-custom-extractors\">这里</a>。</p><h3>第七步：Handler返回值</h3><p>Axum handler的返回类型也很灵活。除了前面例子里提到的 HTML 类型的返回之外，常见的还有 String、Json、Redirect 等类型。实际上，只要实现了 IntoResponse 这个 trait 的类型，都能用作 handler 的返回值。Axum会根据返回值的类型，对Http Response 的status code和header等进行自动配置，减少了开发者对细节的处理。</p><p>比如返回一个HTML：</p><pre><code class=\"language-plain\">async fn query(Json(params): Json&lt;InputParams&gt;) -&gt; impl IntoResponse {\n&nbsp; &nbsp; Html(\"&lt;h3&gt;Test json&lt;/h3&gt;\")\n}\n</code></pre><p>返回一个String：</p><pre><code class=\"language-plain\">async fn query(Json(params): Json&lt;InputParams&gt;) -&gt; impl IntoResponse {\n&nbsp; &nbsp; \"Hello, world\".\n}\n</code></pre><p>返回一个Json：</p><pre><code class=\"language-plain\">async fn query(Json(params): Json&lt;InputParams&gt;) -&gt; impl IntoResponse {\n&nbsp; &nbsp; let ajson = ...;\n    Json(ajson)\n}\n</code></pre><p>从上面代码中可以看到，在Axum里Json既是解包器，又可以用在response里面。<br>\n在Rust中，借助serde_json提供的json!宏，你可以像下面这样方便地构造Json对象：</p><pre><code class=\"language-plain\">async fn accept_json(Json(input): Json&lt;Input&gt;) -&gt; impl IntoResponse {\n&nbsp; &nbsp; tracing::debug!(\"json params {:?}\", input);\n&nbsp; &nbsp; Json(json!({\n&nbsp; &nbsp; &nbsp; &nbsp; \"result\": \"ok\",\n&nbsp; &nbsp; &nbsp; &nbsp; \"number\": 1,\n&nbsp; &nbsp; }))\n}\n</code></pre><p>你还可以返回一个Redirect，自动重定向页面。</p><pre><code class=\"language-plain\">async fn query(Json(params): Json&lt;InputParams&gt;) -&gt; impl IntoResponse {\n    Redirect::to(\"/\")\n}\n</code></pre><p>你甚至可以返回一个 <code>(StatusCode, String)</code>。</p><pre><code class=\"language-plain\">async fn query(Json(params): Json&lt;InputParams&gt;) -&gt; impl IntoResponse {\n    (StatusCode::Ok, \"Hello, world!\")\n}\n</code></pre><p>可以看到，形式变化多端，非常灵活。至于你可以返回哪些形式，可以在<a href=\"https://docs.rs/axum/latest/axum/response/trait.IntoResponse.html#foreign-impls\">这里</a>看到。</p><p>注意，如果一个handler里需要返回两个或多个不同的类型，那么需要调用 .into_response() 转换一下。这里你可以回顾一下<a href=\"https://time.geekbang.org/column/article/726207\">第14讲</a>的知识点：impl trait 这种在函数中的写法，本质上仍然是编译期单态化，每次编译都会替换成一个具体的类型。</p><pre><code class=\"language-plain\">async fn query(Json(params): Json&lt;InputParams&gt;) -&gt; impl IntoResponse {\n    if some_flag {\n        let ajson = ...;\n        Json(ajson).into_response()\n    } else {\n        Redirect::to(\"/\").into_response()\n    }\n}\n</code></pre><p>有没有感觉到一丝丝震撼。Rust虽然是强类型语言，但是感觉Axum把它玩出了弱（动态）类型语言的效果。这固然是Axum的优秀之处，不过主要还是Rust太牛了。</p><p>关于返回Json的完整示例，请参考<a href=\"https://github.com/miketang84/jikeshijian/tree/master/2122-axumapp_stepbystep/axumapp07_jsonres\">这里</a>。</p><p>测试效果图：</p><p><img src=\"https://static001.geekbang.org/resource/image/84/cb/8414fb520b8a8b63f45cf9dyya221ecb.png?wh=1920x860\" alt=\"图片\"></p><h3>第八步：全局404 Fallback</h3><p>有时，我们希望给全局的Router添加一个统一的404自定义页面，这在Axum中很简单，只需要一句话，像下面这样：</p><pre><code class=\"language-plain\">&nbsp; &nbsp; let app = Router::new()\n&nbsp; &nbsp; &nbsp; &nbsp; .route(\"/\", get(handler))\n&nbsp; &nbsp; &nbsp; &nbsp; .route(\"/query\", get(query))\n&nbsp; &nbsp; &nbsp; &nbsp; .route(\"/form\", get(show_form).post(accept_form))\n&nbsp; &nbsp; &nbsp; &nbsp; .route(\"/json\", post(accept_json));\n\n&nbsp; &nbsp; let app = app.fallback(handler_404);\n</code></pre><p>上面第7行就给没有匹配到任何一个url pattern的情况配置了一个 fallback，给了一个 404 handler，你自行在那个handler里面写你的处理逻辑就好了，比如直接返回一个404页面。</p><p>完整代码示例在<a href=\"https://github.com/miketang84/jikeshijian/tree/master/2122-axumapp_stepbystep/axumapp08_global404\">这里</a>。</p><h3>第九步：模板渲染</h3><p>这里的模板渲染指服务端渲染，一般是在服务端渲染HTML页面。在Rust生态中有非常多的模板渲染库。常见的有 Askama、Terra等。这里我们以Askama为例来介绍一下。</p><p>Askama是一种Jinja-like语法的模板渲染引擎，支持使用Rust语言在模板中写逻辑。作为模板渲染库，它很有Rust的味道，<strong>通过类型来保证写出的模板是正确的</strong>。如果模板中有任何非逻辑错误，在编译的时候就能发现问题。带来的直接效果就是，可以节约开发者大量调试页面模板的时间。凡是使用过的人，都体会到了其中的便利。</p><p>先引入 askama。</p><pre><code class=\"language-plain\">cargo add askama\n</code></pre><p>使用的时候，也很简单，你可以参考下面的代码示例。</p><pre><code class=\"language-plain\">#[derive(Template)]\n#[template(path = \"hello.html\")]\nstruct HelloTemplate {\n&nbsp; &nbsp; name: String,\n}\n\nasync fn greet(Path(name): Path&lt;String&gt;) -&gt; impl IntoResponse {\n&nbsp; &nbsp; HelloTemplate { name } .to_string()\n}\n</code></pre><p>模板中使用的是Jinja语法，这是一种很常见的模板语法，如果不了解的可查阅<a href=\"https://docs.jinkan.org/docs/jinja2/\">相关资料</a>。Askama的完整文档，请参考<a href=\"https://djc.github.io/askama/askama.html\">链接</a></p><p>本小节完整可运行示例，请参考<a href=\"https://github.com/miketang84/jikeshijian/tree/master/2122-axumapp_stepbystep/axumapp09_template\">这里</a>。</p><p>运行效果：</p><p><img src=\"https://static001.geekbang.org/resource/image/1y/d7/1yy39ee412661fca7c8bdb8a4c5f89d7.png?wh=1126x302\" alt=\"\"></p><h3>第十步：使用连接池连接 PostgreSQL DB</h3><p>一个真正的互联网应用大部分情况下都会用数据库来存储数据。因此，操作数据库是最常见的需求，而Axum就内置了这方面的支持。下面我们用 Postgres 来举例。</p><p>一般来讲，我们会定义一个全局应用状态，把所有需要全局共享的信息放进去。</p><pre><code class=\"language-plain\">struct AppState {\n    // ...\n}\n</code></pre><p>全局状态能够被所有handler、中间件layer访问到，是一种非常有效的设计模式。</p><p>在下面示例中，我们用 Pool::builder()创建一个连接池对象，并传送到AppState的实例里。</p><pre><code class=\"language-plain\">let manager = PostgresConnectionManager::new_from_stringlike(\n&nbsp; &nbsp; &nbsp; &nbsp; \"host=localhost user=postgres dbname=postgres password=123456\",\n&nbsp; &nbsp; &nbsp; &nbsp; NoTls,\n&nbsp; &nbsp; )\n&nbsp; &nbsp; .unwrap();\nlet pool = Pool::builder().build(manager).await.unwrap();\n\nlet app_state = AppState { dbpool: pool};\n</code></pre><p>再使用 router 的 .with_state() 方法就可以把这个全局状态传递到每一个handler和中间件里了。</p><pre><code class=\"language-plain\">.with_state(app_state);\n</code></pre><p>另一方面，在 handler 中使用 State 解包器来解出 app_state 。</p><pre><code class=\"language-plain\">async fn handler(\n    State(app_state): State&lt;AppState&gt;,\n) {\n    // use `app_state`...\n}\n</code></pre><p>这里，取出来的这个app_state 就是前面创建的AppState的实例，在handler里直接使用就可以了。</p><p>当然除了上面的这些知识，你还需要在本地环境安装 PostgreSQL，或使用 Docker Compose 之类的工具快速构建依赖环境。这个步骤的完整可运行的代码在<a href=\"https://github.com/miketang84/jikeshijian/tree/master/2122-axumapp_stepbystep/axumapp10_db\">这里</a>，你可以在安装好PostgreSQL数据库后，设置好数据库的密码等配置，编译此代码连上去测试。</p><p>在Ubuntu/Debian下，安装配置PostgreSQL可能用到的指令有下面这几种。</p><pre><code class=\"language-plain\">sudo apt install postgresql\nsudo su postgres\npsql\npostgres=# ALTER USER postgres WITH PASSWORD '123456'; # 配置默认用户密码\n</code></pre><p>测试界面：</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/y9/c165807a7b9c109f928a64fdb2ae4yy9.png?wh=1354x348\" alt=\"\"></p><p>这个示例输出log类似如下：</p><pre><code class=\"language-plain\">2023-12-11T09:20:41.919226Z DEBUG axumapp10: listening on 127.0.0.1:3000\n2023-12-11T09:20:50.224031Z DEBUG request{method=GET uri=/query_from_db version=HTTP/1.1}: tower_http::trace::on_request: started processing request\n2023-12-11T09:20:50.224099Z DEBUG request{method=GET uri=/query_from_db version=HTTP/1.1}: axumapp10: get db conn Pool(PoolInner(0x557c6994ed80))\n2023-12-11T09:20:50.255306Z DEBUG request{method=GET uri=/query_from_db version=HTTP/1.1}: axumapp10: query_from_db: 1\n2023-12-11T09:20:50.256060Z DEBUG request{method=GET uri=/query_from_db version=HTTP/1.1}: axumapp10: query_from_db: 2\n2023-12-11T09:20:50.256109Z DEBUG request{method=GET uri=/query_from_db version=HTTP/1.1}: axumapp10: query_from_db: 3\n2023-12-11T09:20:50.256134Z DEBUG request{method=GET uri=/query_from_db version=HTTP/1.1}: axumapp10: calc_result 2\n2023-12-11T09:20:50.256218Z DEBUG request{method=GET uri=/query_from_db version=HTTP/1.1}: tower_http::trace::on_response: finished processing request latency=32 ms status=200\n</code></pre><p>跟我们预期一致，说明成功连上了数据库。</p><p>下面，我们通过一个综合示例，把这些工作整合起来，构建一个Todo List应用的后端服务。</p><h2>综合示例：实现一个 Todo List 应用</h2><p>TodoList是最常见的Web应用示例，相当于前后端分离型Web应用领域中的Helloworld。一般说来，我们要做一个简单的互联网应用，最基本的步骤有下面几个：</p><ol>\n<li>设计准备db schema。</li>\n<li>对应 db schema 生成对应的 Rust model types。</li>\n<li>规划 Router，加入需要的 http endpoints。</li>\n<li>规划 handlers。</li>\n<li>规划前后端数据交互方式，是用 form 格式还是 json 格式前后端交互数据，或者是否统一使用 Graphql 进行query和mutation。</li>\n<li>代码实现。</li>\n<li>测试。</li>\n</ol><p>下面我们就按照这个流程一步步来实现。</p><h3>第一步：建立模型</h3><p>这一步需要你对sql数据库的基本操作有一些了解。这里我们要创建数据库和表。</p><p>创建数据库：</p><pre><code class=\"language-plain\">create database todolist;\n</code></pre><p>在 psql 中 使用 <code>\\c todolist</code> 连上刚创建的todolist数据库，然后创建表。</p><pre><code class=\"language-plain\">create table todo (\n   id varchar not null,\n   description varchar not null,\n   completed bool not null);\n</code></pre><p>然后在psql中使用  <code>\\d</code> 指令查看已经创建好的table。</p><pre><code class=\"language-plain\">todolist=# \\d\n&nbsp; &nbsp; &nbsp; &nbsp; List of relations\n&nbsp;Schema | Name | Type&nbsp; |&nbsp; Owner\n--------+------+-------+----------\n&nbsp;public | todo | table | postgres\n(1 row)\n</code></pre><p>如果你对SQL还不太熟悉，这里有一个简单的教程可供参考：<a href=\"https://www.runoob.com/postgresql/postgresql-tutorial.html\">PostgreSQL 教程 | 菜鸟教程 (runoob.com)</a></p><h3>第二步：创建对应的Rust Struct</h3><p>对应上面创建的todo table，我们设计出如下结构体类型：</p><pre><code class=\"language-plain\">#[derive(Debug, Serialize, Clone)]\nstruct Todo {\n&nbsp; &nbsp; id: String,\n&nbsp; &nbsp; description: String,\n&nbsp; &nbsp; completed: bool,\n}\n</code></pre><h3>第三步：规划Router</h3><p>Todolist会有增删改查的操作，也就是4个基本的url endpoints。另外，需要将数据库连接的全局状态传到各个handler中。</p><pre><code class=\"language-plain\">let app = Router::new()\n&nbsp; &nbsp; .route(\"/todos\", get(todos_list))\n&nbsp; &nbsp; .route(\"/todo/new\", post(todo_create))\n&nbsp; &nbsp; .route(\"/todo/update\", post(todo_update))\n&nbsp; &nbsp; .route(\"/todo/delete/:id\", post(todo_delete))\n&nbsp; &nbsp; .with_state(pool);\n</code></pre><p>我们在这里添加了4个URL，分别对应query list、create、update、delete 四种操作。</p><h3>第四步：设计业务对应的handler</h3><p>一个标准的Todo List的后端服务，只需要对Todo模型做基本的增删改查就可以了。</p><ol>\n<li>create 创建一个Todo item。</li>\n<li>update 更新一个Todo item。</li>\n<li>delete 删除一个Todo item。</li>\n<li>query list，加载一个Todo item list。在这个TodoList应用里，我们不需要对一个具体的item做query。</li>\n</ol><p>于是对应的，我们会有4个handlers。我们先把框架写出来。</p><pre><code class=\"language-plain\">async fn todo_create(\n&nbsp; &nbsp; State(pool): State&lt;ConnectionPool&gt;,\n&nbsp; &nbsp; Json(input): Json&lt;CreateTodo&gt;,\n) -&gt; Result&lt;(StatusCode, Json&lt;Todo&gt;), (StatusCode, String)&gt; {\n\nasync fn todo_update(\n&nbsp; &nbsp; State(pool): State&lt;ConnectionPool&gt;,\n&nbsp; &nbsp; Json(utodo): Json&lt;UpdateTodo&gt;,\n) -&gt; Result&lt;(StatusCode, Json&lt;String&gt;), (StatusCode, String)&gt; {\n\nasync fn todo_delete(\n&nbsp; &nbsp; Path(id): Path&lt;String&gt;,\n&nbsp; &nbsp; State(pool): State&lt;ConnectionPool&gt;,\n) -&gt; Result&lt;(StatusCode, Json&lt;String&gt;), (StatusCode, String)&gt; {\n\nasync fn todos_list(\n&nbsp; &nbsp; pagination: Option&lt;Query&lt;Pagination&gt;&gt;,\n&nbsp; &nbsp; State(pool): State&lt;ConnectionPool&gt;,\n) -&gt; Result&lt;Json&lt;Vec&lt;Todo&gt;&gt;, (StatusCode, String)&gt; {\n</code></pre><p>上面我们设计好了 4 个handler的函数签名，这就相当于我们写了书的目录，后面要完成哪些东西就能心中有数了。函数签名里有一些信息还需要补充，比如HTTP请求上来后的入参类型。</p><p>下面定义了创建新item和更新item的入参DTO（data transform object），用来在Axum里把Http Request的参数信息直接转化成Rust的struct类型。</p><pre><code class=\"language-plain\">#[derive(Debug, Deserialize)]\nstruct CreateTodo {\n&nbsp; &nbsp; description: String,\n}\n\n#[derive(Debug, Deserialize)]\nstruct UpdateTodo {\n&nbsp; &nbsp; id: String,\n&nbsp; &nbsp; description: Option&lt;String&gt;,\n&nbsp; &nbsp; completed: Option&lt;bool&gt;,\n}\n</code></pre><p>有了这些类型，Axum会自动为我们做转换工作，我们在handler中拿到这些类型的实例，就可以直接写业务了。</p><h3>第五步：规划前后端的数据交互方式</h3><p>这一步需要做4件事情。</p><ul>\n<li>query参数放在URL里面，用GET指令提交。</li>\n<li>delete操作的参数放在path里面，用 /todo/delete/:id 这种形式表达。</li>\n<li>create和update参数是放在body里面，用POST指令提交，用json格式上传。</li>\n<li>从服务端返回给前端的数据都是以json格式返回。</li>\n</ul><p>这一步定义好了，就可以重新审视一下4个handler的函数签名，看是否符合我们的要求。</p><h3>第六步：代码实现</h3><p>前面那些步骤设计规划好后，实现代码就是一件非常轻松的事情了。基本上就是按照Axum的要求，写出相应的部分就行了。</p><p>你可以看一下完整可运行的<a href=\"https://github.com/miketang84/jikeshijian/tree/master/2122-axumapp_stepbystep/axumapp11_todo\">示例</a>。在示例里，我们使用了bb8这个数据库连接池来连接pg数据库。这样我们就不需要去担心连接断开、重连这些底层的琐事了。</p><h3>第七步：测试</h3><p>一般，测试后端服务有几种方式：</p><ol>\n<li>框架的单元和集成测试方法，不同的框架有不同的实现和使用方式，Axum里也有配套的设施。</li>\n<li>Curl 命令行脚本测试。</li>\n<li>Web浏览器插件工具测试。</li>\n</ol><p>三种方式并不冲突，是相互补充的。第3种方式常见的有Postman这种浏览器插件，它们可以很方便地帮我们对Web应用进行测试。</p><p>测试创建一个Item：</p><p><img src=\"https://static001.geekbang.org/resource/image/82/29/823ab4dd841a844b0247be8cecf7ff29.png?wh=1920x921\" alt=\"图片\"></p><p>我们也可以多创建几个。</p><p>以下是创建了5个item的list返回，通过Get 方法访问 <code>http://127.0.0.1:3000/todos</code>。</p><pre><code class=\"language-plain\">[\n{\n\"id\": \"77de4aa746c74eb19b8bf451eab6fbf3\",\n\"description\": \"hello, item 1\",\n\"completed\": false\n},\n{\n\"id\": \"3c158df02c724695ac67d4cbff180717\",\n\"description\": \"hello, item 2\",\n\"completed\": false\n},\n{\n\"id\": \"0c687f7b4d4442dc9c3381cc4d0e4a1d\",\n\"description\": \"hello, item 3\",\n\"completed\": false\n},\n{\n\"id\": \"df0bb07aa0f84696896ad86d8f13a61c\",\n\"description\": \"hello, item 4\",\n\"completed\": false\n},\n{\n\"id\": \"3ec8f48f5fd34cf9afa299427066ef35\",\n\"description\": \"hello, item 5\",\n\"completed\": false\n}\n]\n</code></pre><p>其他的更新和删除操作，你可以自己动手测试一下。</p><p>你阅读代码时，有3个地方需要注意：</p><ol>\n<li>注意参数传入中的可省参数 Option 的处理。</li>\n<li>handler的返回值用的Result，请注意业务处理过程中的错误转换。</li>\n<li>pg db 的操作，因为我们没有使用ORM这种东西，因此纯靠手动拼sql字符串，并且手动转换从pg db返回的row值的类型。这比较原始，也比较容易出错。但是对于我们学习来讲，是有好处的。后面你做Web应用的时候，可以选择一个ORM，Rust生态中比较出名的有 sqlx、SeaORM、Rbatis 等。</li>\n</ol><h2>小结</h2><p>这节课我们学会了如何使用Axum进行Web后端开发。Web开发本身是一个庞大的领域，要精通需要花费大量的时间。我通过两节课的时间，抽出了里面的思路和重要步骤，快速带你体验了如何实现一个todolist app。</p><p>这节课我们贯彻了循序渐进的学习方式。先对大目标进行分解，了解要完成一个目标之前，需要掌握多少基础的知识点。然后，就一点一点去掌握好，理解透。这样一步一步把积木搭上来，实际也花不了多少时间。这实际是一种似慢实快的方法。在Rust中，这种方法比那种先总体瞟一眼教程，直接动手做开发，不清楚的地方再去查阅相关资料的方式，效果要好一些，并且会扎实很多。</p><p>Axum是一个相当强大灵活的框架，里面还有很多东西（比如：如何写一个中间件，自定义extractor，如何处理流文件上传等）值得你去探索。好在，我们已经掌握了Axum的基本使用方法了，Web开发的特点让我们可以小步快跑，一点一点加功能，能立即看到效果。只要肯花时间，这些都不是问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/d6/fd0af99a9a7ce1814947fa2240a015d6.jpg?wh=2646x2777\" alt=\"\"></p><h2>思考题</h2><p>当Axum Handler中有多个参数的时候，你可以试着改变一下参数的顺序，看看效果有没有变化。并在这个基础上说一说你对<a href=\"https://docs.rs/axum/latest/axum/index.html#high-level-features\">声明式参数</a>概念的理解。</p><p>请你展开聊一聊，欢迎你留言和我分享、讨论，也欢迎你把这节课的内容分享给其他朋友，邀他一起学习，我们下节课再见！</p>","comments":[{"had_liked":false,"id":385312,"user_name":"小虎子🐯","can_delete":false,"product_type":"c1","uid":2843479,"ip_address":"北京","ucode":"4C9530B3FB407B","user_header":"https://static001.geekbang.org/account/avatar/00/2b/63/57/cba4c68b.jpg","comment_is_top":true,"comment_ctime":1702430483,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"因为刚刚更新了版本，文字内容有调整，所以需要一些时间处理音频，所以今天的音频中午发布哦","like_count":2},{"had_liked":false,"id":385573,"user_name":"天穹智能","can_delete":false,"product_type":"c1","uid":2853524,"ip_address":"上海","ucode":"989318E61BDDCB","user_header":"https://static001.geekbang.org/account/avatar/00/2b/8a/94/cbbf8b4d.jpg","comment_is_top":false,"comment_ctime":1702914783,"is_pvip":false,"replies":[{"id":140559,"content":"你好，这个就按rust的规范命名就可以了。Rust的社区项目命名都比较一致的，这样大家都会比较习惯。目录组织的话，用 2015 风格 和 2018 风格的都有，另外，如果项目比较大，现在推荐使用 workspace：https:&#47;&#47;doc.rust-lang.org&#47;cargo&#47;reference&#47;workspaces.html","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1703122918,"ip_address":"重庆","comment_id":385573,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师，请教一下axum开发web的包结构命名组织规范有没有相对比较正式点的，最近公司在用axum开发一个项目，一直在构思模块和包的结构组织。","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634235,"discussion_content":"你好，这个就按rust的规范命名就可以了。Rust的社区项目命名都比较一致的，这样大家都会比较习惯。目录组织的话，用 2015 风格 和 2018 风格的都有，另外，如果项目比较大，现在推荐使用 workspace：https://doc.rust-lang.org/cargo/reference/workspaces.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703122918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1228080,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bd/30/55488a4c.jpg","nickname":"李志勇(Leo)","note":"","ucode":"5833C0831DD271","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634544,"discussion_content":"你们使用DDD，简洁架构这些东西吗？\n你们现在的模块和包结构大致是怎么样的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1703642308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385396,"user_name":"My dream","can_delete":false,"product_type":"c1","uid":1077733,"ip_address":"四川","ucode":"2FEFB344230C17","user_header":"https://static001.geekbang.org/account/avatar/00/10/71/e5/bcdc382a.jpg","comment_is_top":false,"comment_ctime":1702559074,"is_pvip":false,"replies":[{"id":140457,"content":"https:&#47;&#47;crates.io&#47;crates&#47;xlsxwriter\nhttps:&#47;&#47;crates.io&#47;crates&#47;calamine\nhttps:&#47;&#47;crates.io&#47;crates&#47;docx-rs\nhttps:&#47;&#47;crates.io&#47;crates&#47;cairo-rs\nhttps:&#47;&#47;crates.io&#47;crates&#47;lopdf","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702610752,"ip_address":"重庆","comment_id":385396,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"怎么实现生成pdf文件，生成xls文档导入导出？生成word导出？","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633775,"discussion_content":"https://crates.io/crates/xlsxwriter\nhttps://crates.io/crates/calamine\nhttps://crates.io/crates/docx-rs\nhttps://crates.io/crates/cairo-rs\nhttps://crates.io/crates/lopdf","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702610752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385370,"user_name":"-","can_delete":false,"product_type":"c1","uid":1546505,"ip_address":"北京","ucode":"7B34258D346793","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/09/29c46a7b.jpg","comment_is_top":false,"comment_ctime":1702524012,"is_pvip":false,"replies":[{"id":140455,"content":"非常棒的发现！\n\nAxum会对handler里面的解包器参数按顺序对Request进行处理。\n\n如果你尝试将State放在Json解包器的后面，编译器会报错。这是因为Json解包器会消耗请求的主体（body），而在请求的主体被消耗之后，State就无法再从请求中提取数据（需要研究Axum内部的实现）。因此，你需要先使用State提取器，然后再使用Json解包器。详情见这里：⚠️ Since parsing JSON requires consuming the request body, the Json extractor must be last if there are multiple extractors in a handler. See “the order of extractors”\n\nhttps:&#47;&#47;docs.rs&#47;axum&#47;latest&#47;axum&#47;struct.Json.html\n\n所以，Axum虽然说它的handler里面的参数顺序是声明式的（也就是可以随意换位置），但也不是对所有参数都平等对待。对于会消耗body的解包器，还是要注意一下其顺序。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702610320,"ip_address":"重庆","comment_id":385370,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"我发现一个问题，就是同样的State,handler中我放第一个参数没问题，我放到Json参数后报错，希望老师协助分析下","like_count":2,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633773,"discussion_content":"非常棒的发现！\n\nAxum会对handler里面的解包器参数按顺序对Request进行处理。\n\n如果你尝试将State放在Json解包器的后面，编译器会报错。这是因为Json解包器会消耗请求的主体（body），而在请求的主体被消耗之后，State就无法再从请求中提取数据（需要研究Axum内部的实现）。因此，你需要先使用State提取器，然后再使用Json解包器。详情见这里：⚠️ Since parsing JSON requires consuming the request body, the Json extractor must be last if there are multiple extractors in a handler. See “the order of extractors”\n\nhttps://docs.rs/axum/latest/axum/struct.Json.html\n\n所以，Axum虽然说它的handler里面的参数顺序是声明式的（也就是可以随意换位置），但也不是对所有参数都平等对待。对于会消耗body的解包器，还是要注意一下其顺序。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702610320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1979955,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/36/33/3411df0d.jpg","nickname":"seven9t","note":"","ucode":"B7CA7D62C56938","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635919,"discussion_content":"问的好像是State和Json的顺序？State不消耗输入吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705379045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388281,"user_name":"meteor","can_delete":false,"product_type":"c1","uid":1438402,"ip_address":"上海","ucode":"E7B1A2AD359D69","user_header":"https://static001.geekbang.org/account/avatar/00/15/f2/c2/939bec1c.jpg","comment_is_top":false,"comment_ctime":1709791458,"is_pvip":false,"replies":[{"id":141752,"content":"这个需要查一下，Rust在前端组件这一块，还有很多工作要做。你可以看看 dioxus 或 tauri 社区有没有相关组件。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1713028759,"ip_address":"加拿大","comment_id":388281,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"请问下，rust有什么好用的表格组件吗，可以编译成wasm的。我们的网页需要一个高性能表格，想用rust开发，然后编译为wasm。目前看了egui,请问还有其他好用的库吗","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641834,"discussion_content":"这个需要查一下，Rust在前端组件这一块，还有很多工作要做。你可以看看 dioxus 或 tauri 社区有没有相关组件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1713028759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386335,"user_name":"-Hedon🍭","can_delete":false,"product_type":"c1","uid":3176234,"ip_address":"湖北","ucode":"FAE541E7A2B88F","user_header":"https://static001.geekbang.org/account/avatar/00/30/77/2a/0cd4c373.jpg","comment_is_top":false,"comment_ctime":1704605274,"is_pvip":false,"replies":[{"id":140811,"content":"rust语言里面不推荐用全局变量，因为很不利于并发编程。实际state就可以扮演一全局变量的作用。多个元素就声明struct，都放一个struct里面管理起来就行。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704684711,"ip_address":"重庆","comment_id":386335,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"思考题：声明式参数，我个人觉得有一点“强类型”的味道，这要求把参数是什么明确表示出来，即利于代码的可读性，也有助于类型检查。\n\n另外，想问一下老师，示例代码中数据库连接池通过 State 的方式来传递，这种方式跟声明全局变量相比有什么优劣呢？以及，如果我有多个对象需要共享，那怎么做呢？","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635272,"discussion_content":"rust语言里面不推荐用全局变量，因为很不利于并发编程。实际state就可以扮演一全局变量的作用。多个元素就声明struct，都放一个struct里面管理起来就行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704684711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385320,"user_name":"不忘初心","can_delete":false,"product_type":"c1","uid":3737491,"ip_address":"四川","ucode":"8262D42405F4E2","user_header":"https://static001.geekbang.org/account/avatar/00/39/07/93/710c7ee2.jpg","comment_is_top":false,"comment_ctime":1702445341,"is_pvip":false,"replies":[{"id":140454,"content":"bb8不支持mysql。你可以用 r2d2 https:&#47;&#47;github.com&#47;sfackler&#47;r2d2","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702609718,"ip_address":"重庆","comment_id":385320,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"bb8 有mysql的crate吗? crates.io上没有找到哦","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633771,"discussion_content":"bb8不支持mysql。你可以用 r2d2 https://github.com/sfackler/r2d2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702609718,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385309,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"广东","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1702428526,"is_pvip":false,"replies":[{"id":140428,"content":"打错啦，由于 换成 没有，我给小编反馈。感谢感谢","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702436066,"ip_address":"重庆","comment_id":385309,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"本文是用了 ORM 吗？\n\n因为我们由于使用 ORM 这种东西，因此纯靠手动拼 sql 字符串","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633650,"discussion_content":"打错啦，由于 换成 没有，我给小编反馈。感谢感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702436066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385305,"user_name":"伯阳","can_delete":false,"product_type":"c1","uid":1596631,"ip_address":"北京","ucode":"DBDC8735AA54AD","user_header":"https://static001.geekbang.org/account/avatar/00/18/5c/d7/3b92bb0d.jpg","comment_is_top":false,"comment_ctime":1702422396,"is_pvip":false,"replies":[{"id":140429,"content":"支持的，有mysql驱动，用法基本一样","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1702436088,"ip_address":"重庆","comment_id":385305,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"确实挺方便，天生支持MySQL么","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633651,"discussion_content":"支持的，有mysql驱动，用法基本一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1702436088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391081,"user_name":"山茶花","can_delete":false,"product_type":"c1","uid":1014676,"ip_address":"河南","ucode":"103BF2B46C5E56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/94/8f68c15b.jpg","comment_is_top":false,"comment_ctime":1717239061,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"bb8好像没有mysql驱动，r2d2的mysql驱动不太会用，网上找了个sqlx来用\n\ndb初始化:\n```\nuse sqlx::{MySql, Pool};\nuse sqlx::mysql::MySqlPoolOptions;\n\nlet url = &quot;mysql:&#47;&#47;username:password@127.0.0.1:3306&#47;test&quot;;\nlet pool = MySqlPoolOptions::new().connect(&amp;url).await.unwrap();\n```\n\n用法:\n```\nasync fn todo_list(pagination: Option&lt;Query&lt;Pagination&gt;&gt;,\n                   State(pool): State&lt;ConnectionPool&gt;,\n) -&gt; Result&lt;Json&lt;Vec&lt;Todo&gt;&gt;, (StatusCode, String)&gt; {\n    let Query(patination) = pagination.unwrap_or_default();\n    let offset = patination.offset.unwrap_or(0);\n    let limit = patination.limit.unwrap_or(100);\n\n    let mut conn = pool.acquire().await.map_err(internal_error)?;\n    let todos = sqlx::query_as::&lt;_, Todo&gt;(&quot;select id, description, completed from todo limit ?, ?&quot;)\n        .bind(&amp;offset)\n        .bind(&amp;limit)\n        .fetch_all(&amp;mut conn)\n        .await\n        .map_err(internal_error)?;\n    \n    Ok(Json(todos))\n}\n```","like_count":0}]}