{"id":8053,"title":"第9讲 | 对比Hashtable、HashMap、TreeMap有什么不同？","content":"<p>Map是广义Java集合框架中的另外一部分，HashMap作为框架中使用频率最高的类型之一，它本身以及相关类型自然也是面试考察的热点。</p>\n<p>今天我要问你的问题是，<span class=\"orange\">对比Hashtable、HashMap、TreeMap有什么不同？</span>谈谈你对HashMap的掌握。</p>\n<h2>典型回答</h2>\n<p>Hashtable、HashMap、TreeMap都是最常见的一些Map实现，是以<strong>键值对</strong>的形式存储和操作数据的容器类型。</p>\n<p>Hashtable是早期Java类库提供的一个<a href=\"https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8\">哈希表</a>实现，本身是同步的，不支持null键和值，由于同步导致的性能开销，所以已经很少被推荐使用。</p>\n<p>HashMap是应用更加广泛的哈希表实现，行为上大致上与HashTable一致，主要区别在于HashMap不是同步的，支持null键和值等。通常情况下，HashMap进行put或者get操作，可以达到常数时间的性能，所以<strong>它是绝大部分利用键值对存取场景的首选</strong>，比如，实现一个用户ID和用户信息对应的运行时存储结构。</p>\n<p>TreeMap则是基于红黑树的一种提供顺序访问的Map，和HashMap不同，它的get、put、remove之类操作都是O（log(n)）的时间复杂度，具体顺序可以由指定的Comparator来决定，或者根据键的自然顺序来判断。</p>\n<h2>考点分析</h2>\n<p>上面的回答，只是对一些基本特征的简单总结，针对Map相关可以扩展的问题很多，从各种数据结构、典型应用场景，到程序设计实现的技术考量，尤其是在Java 8里，HashMap本身发生了非常大的变化，这些都是经常考察的方面。</p>\n<p>很多朋友向我反馈，面试官似乎钟爱考察HashMap的设计和实现细节，所以今天我会增加相应的源码解读，主要专注于下面几个方面：</p>\n<ul>\n<li>\n<p>理解Map相关类似整体结构，尤其是有序数据结构的一些要点。</p>\n</li>\n<li>\n<p>从源码去分析HashMap的设计和实现要点，理解容量、负载因子等，为什么需要这些参数，如何影响Map的性能，实践中如何取舍等。</p>\n</li>\n<li>\n<p>理解树化改造的相关原理和改进原因。</p>\n</li>\n</ul>\n<p>除了典型的代码分析，还有一些有意思的并发相关问题也经常会被提到，如HashMap在并发环境可能出现<a href=\"https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6423457\">无限循环占用CPU</a>、size不准确等诡异的问题。</p>\n<p>我认为这是一种典型的使用错误，因为HashMap明确声明不是线程安全的数据结构，如果忽略这一点，简单用在多线程场景里，难免会出现问题。</p>\n<p>理解导致这种错误的原因，也是深入理解并发程序运行的好办法。对于具体发生了什么，你可以参考这篇很久以前的<a href=\"http://mailinator.blogspot.com/2009/06/beautiful-race-condition.html\">分析</a>，里面甚至提供了示意图，我就不再重复别人写好的内容了。</p>\n<h2>知识扩展</h2>\n<p>1.Map整体结构</p>\n<p>首先，我们先对Map相关类型有个整体了解，Map虽然通常被包括在Java集合框架里，但是其本身并不是狭义上的集合类型（Collection），具体你可以参考下面这个简单类图。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/26/7c/266cfaab2573c9777b1157816784727c.png?wh=768*493\" alt=\"\" /></p>\n<p>Hashtable比较特别，作为类似Vector、Stack的早期集合相关类型，它是扩展了Dictionary类的，类结构上与HashMap之类明显不同。</p>\n<p>HashMap等其他Map实现则是都扩展了AbstractMap，里面包含了通用方法抽象。不同Map的用途，从类图结构就能体现出来，设计目的已经体现在不同接口上。</p>\n<!-- [[[read_end]]] -->\n<p>大部分使用Map的场景，通常就是放入、访问或者删除，而对顺序没有特别要求，HashMap在这种情况下基本是最好的选择。<strong>HashMap的性能表现非常依赖于哈希码的有效性，请务必掌握hashCode和equals的一些基本约定</strong>，比如：</p>\n<ul>\n<li>\n<p>equals相等，hashCode一定要相等。</p>\n</li>\n<li>\n<p>重写了hashCode也要重写equals。</p>\n</li>\n<li>\n<p>hashCode需要保持一致性，状态改变返回的哈希值仍然要一致。</p>\n</li>\n<li>\n<p>equals的对称、反射、传递等特性。</p>\n</li>\n</ul>\n<p>这方面内容网上有很多资料，我就不在这里详细展开了。</p>\n<p>针对有序Map的分析内容比较有限，我再补充一些，虽然LinkedHashMap和TreeMap都可以保证某种顺序，但二者还是非常不同的。</p>\n<ul>\n<li>LinkedHashMap通常提供的是遍历顺序符合插入顺序，它的实现是通过为条目（键值对）维护一个双向链表。注意，通过特定构造函数，我们可以创建反映访问顺序的实例，所谓的put、get、compute等，都算作“访问”。</li>\n</ul>\n<p>这种行为适用于一些特定应用场景，例如，我们构建一个空间占用敏感的资源池，希望可以自动将最不常被访问的对象释放掉，这就可以利用LinkedHashMap提供的机制来实现，参考下面的示例：</p>\n<pre><code>import java.util.LinkedHashMap;\nimport java.util.Map;  \npublic class LinkedHashMapSample {\n    public static void main(String[] args) {\n        LinkedHashMap&lt;String, String&gt; accessOrderedMap = new LinkedHashMap&lt;String, String&gt;(16, 0.75F, true){\n            @Override\n            protected boolean removeEldestEntry(Map.Entry&lt;String, String&gt; eldest) { // 实现自定义删除策略，否则行为就和普遍Map没有区别\n                return size() &gt; 3;\n            }\n        };\n        accessOrderedMap.put(&quot;Project1&quot;, &quot;Valhalla&quot;);\n        accessOrderedMap.put(&quot;Project2&quot;, &quot;Panama&quot;);\n        accessOrderedMap.put(&quot;Project3&quot;, &quot;Loom&quot;);\n        accessOrderedMap.forEach( (k,v) -&gt; {\n            System.out.println(k +&quot;:&quot; + v);\n        });\n        // 模拟访问\n        accessOrderedMap.get(&quot;Project2&quot;);\n        accessOrderedMap.get(&quot;Project2&quot;);\n        accessOrderedMap.get(&quot;Project3&quot;);\n        System.out.println(&quot;Iterate over should be not affected:&quot;);\n        accessOrderedMap.forEach( (k,v) -&gt; {\n            System.out.println(k +&quot;:&quot; + v);\n        });\n        // 触发删除\n        accessOrderedMap.put(&quot;Project4&quot;, &quot;Mission Control&quot;);\n        System.out.println(&quot;Oldest entry should be removed:&quot;);\n        accessOrderedMap.forEach( (k,v) -&gt; {// 遍历顺序不变\n            System.out.println(k +&quot;:&quot; + v);\n        });\n    }\n}\n\n</code></pre>\n<ul>\n<li>对于TreeMap，它的整体顺序是由键的顺序关系决定的，通过Comparator或Comparable（自然顺序）来决定。</li>\n</ul>\n<p>我在上一讲留给你的思考题提到了，构建一个具有优先级的调度系统的问题，其本质就是个典型的优先队列场景，Java标准库提供了基于二叉堆实现的PriorityQueue，它们都是依赖于同一种排序机制，当然也包括TreeMap的马甲TreeSet。</p>\n<p>类似hashCode和equals的约定，为了避免模棱两可的情况，自然顺序同样需要符合一个约定，就是compareTo的返回值需要和equals一致，否则就会出现模棱两可情况。</p>\n<p>我们可以分析TreeMap的put方法实现：</p>\n<pre><code>public V put(K key, V value) {\n    Entry&lt;K,V&gt; t = …\n    cmp = k.compareTo(t.key);\n    if (cmp &lt; 0)\n        t = t.left;\n    else if (cmp &gt; 0)\n        t = t.right;\n    else\n        return t.setValue(value);\n        // ...\n   }\n</code></pre>\n<p>从代码里，你可以看出什么呢？ 当我不遵守约定时，两个不符合唯一性（equals）要求的对象被当作是同一个（因为，compareTo返回0），这会导致歧义的行为表现。</p>\n<p>2.HashMap源码分析</p>\n<p>前面提到，HashMap设计与实现是个非常高频的面试题，所以我会在这进行相对详细的源码解读，主要围绕：</p>\n<ul>\n<li>\n<p>HashMap内部实现基本点分析。</p>\n</li>\n<li>\n<p>容量（capacity）和负载系数（load factor）。</p>\n</li>\n<li>\n<p>树化 。</p>\n</li>\n</ul>\n<p>首先，我们来一起看看HashMap内部的结构，它可以看作是数组（Node&lt;K,V&gt;[] table）和链表结合组成的复合结构，数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组的寻址；哈希值相同的键值对，则以链表形式存储，你可以参考下面的示意图。这里需要注意的是，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），图中的链表就会被改造为树形结构。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/1f/56/1f72306a9d8719c66790b56ef7977c56.png?wh=808*446\" alt=\"\" /></p>\n<p>从非拷贝构造函数的实现来看，这个表格（数组）似乎并没有在最初就初始化好，仅仅设置了一些初始值而已。</p>\n<pre><code>public HashMap(int initialCapacity, float loadFactor){  \n    // ... \n    this.loadFactor = loadFactor;\n    this.threshold = tableSizeFor(initialCapacity);\n}\n\n</code></pre>\n<p>所以，我们深刻怀疑，HashMap也许是按照lazy-load原则，在首次使用时被初始化（拷贝构造函数除外，我这里仅介绍最通用的场景）。既然如此，我们去看看put方法实现，似乎只有一个putVal的调用：</p>\n<pre><code>public V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n</code></pre>\n<p>看来主要的秘密似乎藏在putVal里面，到底有什么秘密呢？为了节省空间，我这里只截取了putVal比较关键的几部分。</p>\n<pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbent,\n               boolean evit) {\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int , i;\n    if ((tab = table) == null || (n = tab.length) = 0)\n        n = (tab = resize()).length;\n    if ((p = tab[i = (n - 1) &amp; hash]) == ull)\n        tab[i] = newNode(hash, key, value, nll);\n    else {\n        // ...\n        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for first \n           treeifyBin(tab, hash);\n        //  ... \n     }\n}\n\n</code></pre>\n<p>从putVal方法最初的几行，我们就可以发现几个有意思的地方：</p>\n<ul>\n<li>\n<p>如果表格是null，resize方法会负责初始化它，这从tab = resize()可以看出。</p>\n</li>\n<li>\n<p>resize方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容（resize）。</p>\n</li>\n<li>\n<p>在放置新的键值对的过程中，如果发生下面条件，就会发生扩容。</p>\n</li>\n</ul>\n<pre><code>if (++size &gt; threshold)\n    resize();\n</code></pre>\n<ul>\n<li>具体键值对在哈希表中的位置（数组index）取决于下面的位运算：</li>\n</ul>\n<pre><code>i = (n - 1) &amp; hash\n</code></pre>\n<p>仔细观察哈希值的源头，我们会发现，它并不是key本身的hashCode，而是来自于HashMap内部的另外一个hash方法。注意，为什么这里需要将高位数据移位到低位进行异或运算呢？<strong>这是因为有些数据计算出的哈希值差异主要在高位，而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</strong></p>\n<pre><code>static final int hash(Object kye) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt;16;\n}\n</code></pre>\n<ul>\n<li>我前面提到的链表结构（这里叫bin），会在达到一定门限值时，发生树化，我稍后会分析为什么HashMap需要对bin进行处理。</li>\n</ul>\n<p>可以看到，putVal方法本身逻辑非常集中，从初始化、扩容到树化，全部都和它有关，推荐你阅读源码的时候，可以参考上面的主要逻辑。</p>\n<p>我进一步分析一下身兼多职的resize方法，很多朋友都反馈经常被面试官追问它的源码设计。</p>\n<pre><code>final Node&lt;K,V&gt;[] resize() {\n    // ...\n    else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACIY &amp;&amp;\n                oldCap &gt;= DEFAULT_INITIAL_CAPAITY)\n        newThr = oldThr &lt;&lt; 1; // double there\n       // ... \n    else if (oldThr &gt; 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {  \n        // zero initial threshold signifies using defaultsfults\n        newCap = DEFAULT_INITIAL_CAPAITY;\n        newThr = (int)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；\n    }\n    if (newThr ==0) {\n        float ft = (float)newCap * loadFator;\n        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE);\n    }\n    threshold = neThr;\n    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newap];\n    table = n；\n    // 移动到新的数组结构e数组结构 \n   }\n\n</code></pre>\n<p>依据resize源码，不考虑极端情况（容量理论最大极限由MAXIMUM_CAPACITY指定，数值为 1&lt;&lt;30，也就是2的30次方），我们可以归纳为：</p>\n<ul>\n<li>\n<p>门限值等于（负载因子）x（容量），如果构建HashMap的时候没有指定它们，那么就是依据相应的默认常量值。</p>\n</li>\n<li>\n<p>门限通常是以倍数进行调整 （newThr = oldThr &lt;&lt; 1），我前面提到，根据putVal中的逻辑，当元素个数超过门限大小时，则调整Map大小。</p>\n</li>\n<li>\n<p>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</p>\n</li>\n</ul>\n<p>3.容量、负载因子和树化</p>\n<p>前面我们快速梳理了一下HashMap从创建到放入键值对的相关逻辑，现在思考一下，为什么我们需要在乎容量和负载因子呢？</p>\n<p>这是因为容量和负载系数决定了可用的桶的数量，空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能。极端情况下，假设只有一个桶，那么它就退化成了链表，完全不能提供所谓常数时间存的性能。</p>\n<p>既然容量和负载因子这么重要，我们在实践中应该如何选择呢？</p>\n<p>如果能够知道HashMap要存取的键值对数量，可以考虑预先设置合适的容量大小。具体数值我们可以根据扩容发生的条件来做简单预估，根据前面的代码分析，我们知道它需要符合计算条件：</p>\n<pre><code> 负载因子 * 容量 &gt; 元素数量\n\n</code></pre>\n<p>所以，预先设置的容量需要满足，大于“预估元素数量/负载因子”，同时它是2的幂数，结论已经非常清晰了。</p>\n<p>而对于负载因子，我建议：</p>\n<ul>\n<li>\n<p>如果没有特别需求，不要轻易进行更改，因为JDK自身的默认负载因子是非常符合通用场景的需求的。</p>\n</li>\n<li>\n<p>如果确实需要调整，建议不要设置超过0.75的数值，因为会显著增加冲突，降低HashMap的性能。</p>\n</li>\n<li>\n<p>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</p>\n</li>\n</ul>\n<p>我们前面提到了树化改造，对应逻辑主要在putVal和treeifyBin中。</p>\n<pre><code>final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {\n    int n, index; Node&lt;K,V&gt; e;\n    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)\n        resize();\n    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {\n        //树化改造逻辑\n    }\n}\n\n</code></pre>\n<p>上面是精简过的treeifyBin示意，综合这两个方法，树化改造的逻辑就非常清晰了，可以理解为，当bin的数量大于TREEIFY_THRESHOLD时：</p>\n<ul>\n<li>\n<p>如果容量小于MIN_TREEIFY_CAPACITY，只会进行简单的扩容。</p>\n</li>\n<li>\n<p>如果容量大于MIN_TREEIFY_CAPACITY ，则会进行树化改造。</p>\n</li>\n</ul>\n<p>那么，为什么HashMap要树化呢？</p>\n<p><strong>本质上这是个安全问题。</strong>因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，会严重影响存取的性能。</p>\n<p>而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端交互，导致服务器端CPU大量占用，这就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似攻击事件。</p>\n<p>今天我从Map相关的几种实现对比，对各种Map进行了分析，讲解了有序集合类型容易混淆的地方，并从源码级别分析了HashMap的基本结构，希望对你有所帮助。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？留一道思考题给你，解决哈希冲突有哪些典型方法呢？</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习鼓励金，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n","comments":[{"had_liked":false,"id":9881,"user_name":"天凉好个秋","can_delete":false,"product_type":"c1","uid":1136145,"ip_address":"","ucode":"E11B5F990A4000","user_header":"https://static001.geekbang.org/account/avatar/00/11/56/11/5d113d5c.jpg","comment_is_top":true,"comment_ctime":1527142515,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"9.2233730434043003e+18","product_id":100006701,"comment_content":"解决哈希冲突的常用方法有：<br><br>开放定址法<br>基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。<br><br>再哈希法<br>这种方法是同时构造多个不同的哈希函数：<br>Hi=RH1（key）  i=1，2，…，k<br>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。<br><br>链地址法<br>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。<br><br>建立公共溢出区<br>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。","like_count":235,"discussions":[{"author":{"id":1092044,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a9/cc/c417c886.jpg","nickname":"湮灭星空","note":"","ucode":"B1061A4C298E13","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322015,"discussion_content":"受教了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604662810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9893,"user_name":"三口先生","can_delete":false,"product_type":"c1","uid":1117257,"ip_address":"","ucode":"8E8672321FE510","user_header":"https://static001.geekbang.org/account/avatar/00/11/0c/49/d71e939d.jpg","comment_is_top":true,"comment_ctime":1527147671,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"9.2233721543460004e+18","product_id":100006701,"comment_content":"最常用的方法就是线性再散列。即插入元素时，没有发生冲突放在原有的规则下的空槽下，发生冲突时，简单遍历hash表，找到表中下一个空槽，进行元素插入。查找元素时，找到相应的位置的元素，如果不匹配则进行遍历hash表。<br>然后就是我们非线性再散列，就是冲突时，再hash，核心思想是，如果产生冲突，产生一个新的hash值进行寻址，如果还是冲突，则继续。<br>上述的方法，主要的缺点在于不能从表中删除元素。<br>还有就是我们hashmap的思想外部拉链。","like_count":27},{"had_liked":false,"id":9814,"user_name":"公号-技术夜未眠","can_delete":false,"product_type":"c1","uid":1013683,"ip_address":"","ucode":"83825B57CBD952","user_header":"https://static001.geekbang.org/account/avatar/00/0f/77/b3/991f3f9b.jpg","comment_is_top":false,"comment_ctime":1527118489,"is_pvip":true,"discussion_count":8,"race_medal":0,"score":"1324377045657","product_id":100006701,"comment_content":"Hashtable、HashMap、TreeMap心得<br><br>三者均实现了Map接口，存储的内容是基于key-value的键值对映射，一个映射不能有重复的键，一个键最多只能映射一个值。<br><br>（1）\t元素特性<br>HashTable中的key、value都不能为null；HashMap中的key、value可以为null，很显然只能有一个key为null的键值对，但是允许有多个值为null的键值对；TreeMap中当未实现 Comparator 接口时，key 不可以为null；当实现 Comparator 接口时，若未对null情况进行判断，则key不可以为null，反之亦然。<br><br>（2）顺序特性<br>HashTable、HashMap具有无序特性。TreeMap是利用红黑树来实现的（树中的每个节点的值，都会大于或等于它的左子树种的所有节点的值，并且小于或等于它的右子树中的所有节点的值），实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行，默认为升序排序方式（深度优先搜索），可自定义实现Comparator接口实现排序方式。<br><br>（3）初始化与增长方式<br>初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。<br>扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。<br><br>（4）线程安全性<br>HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。<br>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步（1）可以用 Collections的synchronizedMap方法；（2）使用ConcurrentHashMap类，相较于HashTable锁住的是对象整体， ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。<br><br>(5)一段话HashMap<br>HashMap基于哈希思想，实现对数据的读写。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。","like_count":309,"discussions":[{"author":{"id":1259292,"avatar":"https://static001.geekbang.org/account/avatar/00/13/37/1c/b0805822.jpg","nickname":"itlemon","note":"","ucode":"2F2CAF40E5AC5D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":258155,"discussion_content":"我对最后一句话“如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。”进行完善：链表长度达到8的时候，就会去调用链表转换为红黑树的方法，但是这个方法里面会对整个bucket数组进行检查，看看数组长度是否达到64，如果没有达到64，则进行扩容处理，如果达到了64，则进行红黑树转换。我就补充这么多。","likes_number":31,"is_delete":false,"is_hidden":false,"ctime":1588655449,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1312184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","nickname":"JulyRemember","note":"","ucode":"9E3D5D60D82999","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318847,"discussion_content":"concurrenthashmap在1.8版本已经不采用分段锁的方式保证线程安全了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603864985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2293677,"avatar":"https://static001.geekbang.org/account/avatar/00/22/ff/ad/e4a54355.jpg","nickname":"木头","note":"","ucode":"0810F92FEEA917","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1312184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","nickname":"JulyRemember","note":"","ucode":"9E3D5D60D82999","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352071,"discussion_content":"采用的是CAS算法保证线程安全的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614590368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318847,"ip_address":""},"score":352071,"extra":""}]},{"author":{"id":1898336,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f7/60/4553c6e5.jpg","nickname":"奔跑","note":"","ucode":"4A98A8A1CA2540","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219702,"discussion_content":"思路清晰许多，谢谢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585797040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1497346,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d9/02/c4e2d7e8.jpg","nickname":"Geek_Huahui","note":"","ucode":"A688B183E5CE5E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2439,"discussion_content":"学到了，谢谢","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1563617342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2455712,"avatar":"https://static001.geekbang.org/account/avatar/00/25/78/a0/7a248ddc.jpg","nickname":"福","note":"","ucode":"F2FC7AF5D433C6","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549899,"discussion_content":"直接来看大佬的评论就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644289269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2635281,"avatar":"","nickname":"Geek_9ce374","note":"","ucode":"13530B757C8701","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377974,"discussion_content":"1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622985766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1263466,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/2UW4tvsLn61NwNc2vlvxLJggTthc1vKTn4ibzeBic2ibiczCj9pDNMKmMFtZ1t7yAiaGFuthZNRkJiao9JC8fGxcuq1w/132","nickname":"xxmodd","note":"","ucode":"98ED0846635E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312337,"discussion_content":"补充：树化本质上是个安全问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602666756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15004,"user_name":"Q","can_delete":false,"product_type":"c1","uid":1018221,"ip_address":"","ucode":"133B4A7AE88366","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/6d/5f445f2f.jpg","comment_is_top":false,"comment_ctime":1530796615,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"1307200854599","product_id":100006701,"comment_content":"感觉每个知识点都很重要，但又点到为止，感觉读完不痛不痒，好像学到什么，但细想又没掌握什么，希望能够深入一点！","like_count":305,"discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":147683,"discussion_content":"是的  没🐦用","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1579666420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1176548,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f3/e4/42f1609c.jpg","nickname":"小玉壶","note":"","ucode":"BE86FEC7A35E8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246048,"discussion_content":"确实有点浅，感觉都没有详细讲扩容后的rehash过程","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587721827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4903,"discussion_content":"说的有道理，需要自己的深入学习和研究","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1565826277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2305453,"avatar":"","nickname":"Geek_679db3","note":"","ucode":"3AAAC61486EE3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326539,"discussion_content":"感觉跟自己看网上博客没有区别了。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1605614713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4903,"ip_address":""},"score":326539,"extra":""}]},{"author":{"id":1446471,"avatar":"https://static001.geekbang.org/account/avatar/00/16/12/47/8e0310e8.jpg","nickname":"Wellwell","note":"","ucode":"35D7C063C194B3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395036,"discussion_content":"确实体验不好，希望改进","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632196204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2682956,"avatar":"","nickname":"Geek_0b712d","note":"","ucode":"AE90721749391D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382711,"discussion_content":"幸好没有花钱买，对着念而已。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1625701166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1178888,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/08/c039f840.jpg","nickname":"小鳄鱼","note":"","ucode":"9C30CAFB41A263","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588376,"discussion_content":"泛泛而谈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663722441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008809,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/64/a9/27d63f2e.jpg","nickname":"佳楠","note":"","ucode":"A1698AE91992AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335905,"discussion_content":"师傅领进门，学艺在自身","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608377129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":15568,"user_name":"amourling","can_delete":false,"product_type":"c1","uid":1157578,"ip_address":"","ucode":"8E1A73B717A554","user_header":"https://static001.geekbang.org/account/avatar/00/11/a9/ca/2d8c4733.jpg","comment_is_top":false,"comment_ctime":1531297943,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"890589528215","product_id":100006701,"comment_content":"提个意见，文章中请不要出现太多似乎，怀疑之类的必须，该是什么就是什么，不确定的不要拿出来。","like_count":208},{"had_liked":false,"id":43913,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1543322820,"is_pvip":false,"replies":[{"id":"16128","content":"竟然无法反驳，哈哈","user_name":"作者回复","comment_id":43913,"uid":"1009360","ip_address":"","utype":1,"ctime":1543625283,"user_name_real":"杨晓峰"}],"discussion_count":6,"race_medal":0,"score":"289306131652","product_id":100006701,"comment_content":"为什么HashMap要树化？<br><br>文章说『本质是个安全问题』，但是导致安全问题的本质其实是性能问题。哈希碰撞频繁，导致链表过长，查询时间陡升，黑客则会利用这个『漏洞』来攻击服务器，让服务器CPU被大量占用，从而引起了安全问题。 而树化(使用红黑树）能将时间复杂度降到O(logn)，从而避免查询时间过长。所以说，本质还是个性能问题。    <br><br>----------<br>个人理解哈<br><br><br>","like_count":67,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":430546,"discussion_content":"竟然无法反驳，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1543625283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116327,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/a7/80266beb.jpg","nickname":"平凡是唯一答案","note":"","ucode":"D41654FF061947","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4753,"discussion_content":"对对，说实话我读到这里，也有这样的疑惑。其实我觉得应该是文字表达出现了偏差。应该就是【本质是个性能问题】。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1565704738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1008404,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","nickname":"Jerry银银","note":"","ucode":"80DA1172A2360A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1116327,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/a7/80266beb.jpg","nickname":"平凡是唯一答案","note":"","ucode":"D41654FF061947","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":29663,"discussion_content":"握手","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570778195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":4753,"ip_address":""},"score":29663,"extra":""}]},{"author":{"id":1129591,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3c/77/0df86f45.jpg","nickname":"༺NPE༻","note":"","ucode":"F06A89BFBDE949","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341404,"discussion_content":"为什么要使用红黑树，红黑树是近似平衡二叉树，为了防止在频繁进行删除操作而导致树退化成链表，降低查找性能","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610412199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1440185,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f9/b9/21b0553f.jpg","nickname":"叶少波","note":"","ucode":"CDF3DEEC7DFEA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":180059,"discussion_content":"王争的算法课里详细讲了为什么要树化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582274185,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1148845,"avatar":"https://static001.geekbang.org/account/avatar/00/11/87/ad/50a85a04.jpg","nickname":"hao","note":"","ucode":"997F2B57E2F556","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323686,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604981884,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16690,"user_name":"小飞哥 ‍超級會員","can_delete":false,"product_type":"c1","uid":1110049,"ip_address":"","ucode":"417F9563B3005B","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/21/104b9565.jpg","comment_is_top":false,"comment_ctime":1532097839,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"267820070191","product_id":100006701,"comment_content":"总觉得还是不太深，只是每个map的区别。我觉得每个map的实现都能讲出很多问题来，在面试时也经常碰壁，看完但也没觉得学到什么深入的地方","like_count":62,"discussions":[{"author":{"id":1897251,"avatar":"","nickname":"刘haha","note":"","ucode":"91827CAC4B1831","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234946,"discussion_content":"我也感觉讲的太浅了，面试中按老师的回答，基本过不了关","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1587007464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079811,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/03/c9b43b21.jpg","nickname":"BewhY","note":"","ucode":"4BC26D47A79967","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6959,"discussion_content":"每个map的实现都从头到位详细讲的话，这一整个栏目估计都讲不完","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1567221725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10475,"user_name":"鲤鱼","can_delete":false,"product_type":"c1","uid":1022480,"ip_address":"","ucode":"1049AF40716EE7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/10/7b4a2ecc.jpg","comment_is_top":false,"comment_ctime":1527557993,"is_pvip":false,"replies":[{"id":"3357","content":"感谢反馈，最近几章篇幅都超标了……只能照顾大多数需求，抱歉","user_name":"作者回复","comment_id":10475,"uid":"1009360","ip_address":"","utype":1,"ctime":1527607898,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"104606773097","product_id":100006701,"comment_content":"读到最后链表树化刚准备开始飙车，结果突然跳车。树化讲细点更好","like_count":25,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418491,"discussion_content":"感谢反馈，最近几章篇幅都超标了……只能照顾大多数需求，抱歉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527607898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1153455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","nickname":"饭粒","note":"","ucode":"4C3220B0D43997","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206400,"discussion_content":"极客上其系列篇幅有比这长的多的，相反这个系列是订阅中较短的了，搞不懂有啥篇幅限制，问题是都点一下，着实无语。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1584403893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17525,"user_name":"Darcy","can_delete":false,"product_type":"c1","uid":1188358,"ip_address":"","ucode":"CFC39EA9EC15FD","user_header":"https://static001.geekbang.org/account/avatar/00/12/22/06/9549f55d.jpg","comment_is_top":false,"comment_ctime":1532708607,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"87432054527","product_id":100006701,"comment_content":"equals 的对称、反射、传递等特性。<br>这里的反射是不是写错了，应该是自反性，对称性，传递性，一致性等等","like_count":20},{"had_liked":false,"id":9810,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1527117376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"70246594112","product_id":100006701,"comment_content":"我一直认为：JAVA集合类是非常好的学习材料。<br><br>如果敢说精通JAVA集合类，计算机功底肯定不会太差","like_count":17},{"had_liked":false,"id":22408,"user_name":"睡骨","can_delete":false,"product_type":"c1","uid":1220172,"ip_address":"","ucode":"BEB7767B531BE7","user_header":"https://static001.geekbang.org/account/avatar/00/12/9e/4c/fd6e6116.jpg","comment_is_top":false,"comment_ctime":1535672601,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"61665214745","product_id":100006701,"comment_content":"希望作者分享源码的时候，最好备注是基于哪个版本的 毕竟有些地方不同版本差异较大","like_count":14},{"had_liked":false,"id":17591,"user_name":"陈大麦","can_delete":false,"product_type":"c1","uid":1065774,"ip_address":"","ucode":"9DBECA412C9E99","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/2e/b816a431.jpg","comment_is_top":false,"comment_ctime":1532763916,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"61662306060","product_id":100006701,"comment_content":"老师我想问一下，hashmap明明继承了abstractmap，而abstractmap已经实现了map接口，为什么hashmap还要实现map接口呢?","like_count":14,"discussions":[{"author":{"id":1254601,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/c9/5006ef39.jpg","nickname":"tianshb","note":"","ucode":"FBE2723325BBDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42931,"discussion_content":"这里相当于把map作为标记接口了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572831196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10462,"user_name":"xinfangke","can_delete":false,"product_type":"c1","uid":1142403,"ip_address":"","ucode":"F6459459089BF9","user_header":"https://static001.geekbang.org/account/avatar/00/11/6e/83/a912bfb4.jpg","comment_is_top":false,"comment_ctime":1527556185,"is_pvip":false,"replies":[{"id":"3360","content":"我理解是","user_name":"作者回复","comment_id":10462,"uid":"1009360","ip_address":"","utype":1,"ctime":1527608243,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"57362131033","product_id":100006701,"comment_content":"老师 如果hashmap中不存在hash冲突 是不是就相当于一个数组结构呢 就不存在链表了呢","like_count":13,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418487,"discussion_content":"我理解是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527608243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9848,"user_name":"j.c.","can_delete":false,"product_type":"c1","uid":1004961,"ip_address":"","ucode":"909571207BAA63","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/a1/ed52e319.jpg","comment_is_top":false,"comment_ctime":1527124323,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"53066731875","product_id":100006701,"comment_content":"这是面试必问题。什么时候也能讲讲红黑树的树化具体过程，那个旋转一直没搞懂。另外treeifyBin这个单词的词面意思是什么？","like_count":12,"discussions":[{"author":{"id":1617059,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJ4C5xMfrgT207aLahibGGaeQGKMGwIiclYxZDcQpnJ05PsKFHn7ZX75sE3z8lbIryyVmL1DCML1Q3Q/132","nickname":"Geek_a3c961","note":"","ucode":"8CCD690FD0535A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20176,"discussion_content":"旋转建议看看动态图，一目了然","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569287048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1477505,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4wTiaiadFDXTwFLM0eWE8ptbkRNxRxfIiccY4O3SGKecibOuqsrwShs3UPED7T9PgBwqH8Uaf5E99KBA/132","nickname":"Geek_64de3f","note":"","ucode":"541835544BE692","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556607,"discussion_content":"treeify binary ，二叉树化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647425203,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1523124,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erQ6wts5MoOC23bxHMHgSQekwOTouJT056W3zQcq12EGqnjt4Lua1ctLWTRp47A0tDZib5DhpJ9zTw/132","nickname":"Geek_AllenShen","note":"","ucode":"94B95495698BDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246803,"discussion_content":"tree if y bin","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587779127,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":28311,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":1116383,"ip_address":"","ucode":"FB40E04E1BD446","user_header":"https://static001.geekbang.org/account/avatar/00/11/08/df/bc98ecda.jpg","comment_is_top":false,"comment_ctime":1538048057,"is_pvip":false,"replies":[{"id":"11444","content":"嗯，谢谢指出","user_name":"作者回复","comment_id":28311,"uid":"1009360","ip_address":"","utype":1,"ctime":1539274525,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"48782688313","product_id":100006701,"comment_content":"看不太懂，讲的还不是不太浅显，既然是面试题，最好不要太浅，但也不要太深，你这个度掌握的不是很好","like_count":11,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":425225,"discussion_content":"嗯，谢谢指出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539274525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1079811,"avatar":"https://static001.geekbang.org/account/avatar/00/10/7a/03/c9b43b21.jpg","nickname":"BewhY","note":"","ucode":"4BC26D47A79967","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":6960,"discussion_content":"大兄弟，作者这算是讲的很浅了，基本上你瞄过Map的源码就不存在看不太懂的情况，建议先自己补充下基础再看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567221916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":24283,"user_name":"硅谷居士","can_delete":false,"product_type":"c1","uid":1018463,"ip_address":"","ucode":"BD3D3BA142F280","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/5f/c60d0ffe.jpg","comment_is_top":false,"comment_ctime":1536890012,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"48781530268","product_id":100006701,"comment_content":"为什么重写了 hashCode 也要重写 equals 呢？官方文档写的是重写了 equals 一定要重写 hashCode","like_count":11,"discussions":[{"author":{"id":1055854,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","nickname":"终结者999号","note":"","ucode":"33ADE61580B6DD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165124,"discussion_content":"刚开始我也不明白，但是看了stackoverflow这篇文章后了解了一些：https://stackoverflow.com/questions/2707541/why-should-i-override-hashcode-when-i-override-equals-method","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581255797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1622022,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJia6zEsh2u119zJicmq7wApvnricZEKiawaZicice1cOzujWdFicFwPtavlHiaVpCNgCpxBtdl7ynd3y0wkQ/132","nickname":"james_xu","note":"","ucode":"12E50291F5BA89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1055854,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","nickname":"终结者999号","note":"","ucode":"33ADE61580B6DD","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":373601,"discussion_content":"谢谢分享","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620796706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165124,"ip_address":""},"score":373601,"extra":""}]},{"author":{"id":1667541,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epIMwPE6FwsicXKA1os2M1sVHpZ6J9up5ufG3nib14wJSibudqDgqvsje0ZaCj72kHbkh0F21jicqlRXQ/132","nickname":"Itdotaer","note":"","ucode":"B31AD8A980EE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109769,"discussion_content":"我和你有同样的疑惑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577710677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":69190,"user_name":"Lh","can_delete":false,"product_type":"c1","uid":1102951,"ip_address":"","ucode":"19CA4286A49DB7","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/67/0eaa81a4.jpg","comment_is_top":false,"comment_ctime":1550675207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44500348167","product_id":100006701,"comment_content":"Hashtable、HashMap、TreeMap心得<br><br>三者均实现了Map接口，存储的内容是基于key-value的键值对映射，一个映射不能有重复的键，一个键最多只能映射一个值。<br><br>（1）\t元素特性<br>HashTable中的key、value都不能为null；HashMap中的key、value可以为null，很显然只能有一个key为null的键值对，但是允许有多个值为null的键值对；TreeMap中当未实现 Comparator 接口时，key 不可以为null；当实现 Comparator 接口时，若未对null情况进行判断，则key不可以为null，反之亦然。<br><br>（2）顺序特性<br>HashTable、HashMap具有无序特性。TreeMap是利用红黑树来实现的（树中的每个节点的值，都会大于或等于它的左子树种的所有节点的值，并且小于或等于它的右子树中的所有节点的值），实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行，默认为升序排序方式（深度优先搜索），可自定义实现Comparator接口实现排序方式。<br><br>（3）初始化与增长方式<br>初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。<br>扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。<br><br>（4）线程安全性<br>HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。<br>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步（1）可以用 Collections的synchronizedMap方法；（2）使用ConcurrentHashMap类，相较于HashTable锁住的是对象整体， ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。<br><br>(5)一段话HashMap<br>HashMap基于哈希思想，实现对数据的读写。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。","like_count":10},{"had_liked":false,"id":9945,"user_name":"代码狂徒","can_delete":false,"product_type":"c1","uid":1030100,"ip_address":"","ucode":"F5918543E90321","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b7/d4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1527175310,"is_pvip":false,"replies":[{"id":"3138","content":"冲突可能会增加,影响查询之类性能，当然看具体的需求","user_name":"作者回复","comment_id":9945,"uid":"1009360","ip_address":"","utype":1,"ctime":1527233130,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"31591946382","product_id":100006701,"comment_content":"针对负载因子，您所指的存太满会影响性能是指什么？毕竟已经开辟了相应内存空间的，没什么不用呢？","like_count":7,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418270,"discussion_content":"冲突可能会增加,影响查询之类性能，当然看具体的需求","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527233130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13566,"user_name":"coolboy","can_delete":false,"product_type":"c1","uid":1160559,"ip_address":"","ucode":"248918FCC9E65D","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/6f/7c964414.jpg","comment_is_top":false,"comment_ctime":1529774707,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"27299578483","product_id":100006701,"comment_content":"removeEldestEntry这个方法是不是指移除最旧的对象，也就是按照最先被put进来的顺序，而不是指不常访问的对象。","like_count":6,"discussions":[{"author":{"id":1829607,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/K8uoNDBqLNQicA8KOecJIb9ngLYoACBcKzRiaJFtAqVMZyQztGrDYvGCnKc9D5FI9diab0eNwpg0QialGEial8Bicic5g/132","nickname":"赵睿琦","note":"","ucode":"57059319BFBCDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":222390,"discussion_content":"可以看下源码，我看了大概是这样子的，被访问过的元素会被移动到尾部，访问过包括get,insert等。删除就是删除头部的元素。。个人理解","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1586141360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1955253,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/d5/b5/1ba37129.jpg","nickname":"zero_宇","note":"","ucode":"27E77FAD77F3F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336228,"discussion_content":"accessOrder 的属性为 true","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608535847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1555180,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/ec/2b1c6afc.jpg","nickname":"李飞","note":"","ucode":"930458850AA05B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242857,"discussion_content":"源码里对【eldest】的解释： The least recently inserted entry in the map, or if\n                this is an access-ordered map, the least recently accessed\n                entry.  This is the entry that will be removed it this\n                method returns true.  If the map was empty prior\n                to the put or putAll invocation resulting\n                in this invocation, this will be the entry that was just\n                inserted; in other words, if the map contains a single\n                entry, the eldest entry is also the newest.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587485887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1555180,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/ec/2b1c6afc.jpg","nickname":"李飞","note":"","ucode":"930458850AA05B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242848,"discussion_content":"根据你的疑问，跑了下示例代码，并不是你你理解的样子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587485559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":12416,"user_name":"吴较瘦","can_delete":false,"product_type":"c1","uid":1018859,"ip_address":"","ucode":"8B69D8F32C2361","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8b/eb/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1528809559,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27298613335","product_id":100006701,"comment_content":"我觉得树化的前提有两点，第一点是当前桶内元素个数大于8，第二点是数组的长度大于64。同时满足以上两点时，才会将当前桶内的线性链表转化为以key值排序的红黑树。","like_count":6},{"had_liked":false,"id":10368,"user_name":"zjh","can_delete":false,"product_type":"c1","uid":1125747,"ip_address":"","ucode":"3AB3862247BEF9","user_header":"","comment_is_top":false,"comment_ctime":1527509452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23002345932","product_id":100006701,"comment_content":"受教了，把java集合的源代码掌握了，对java和数据结构的了解都会有很大的提升","like_count":5},{"had_liked":false,"id":11213,"user_name":"鲲鹏飞九万里","can_delete":false,"product_type":"c1","uid":1093920,"ip_address":"","ucode":"82BD0C789DF612","user_header":"https://static001.geekbang.org/account/avatar/00/10/b1/20/8718252f.jpg","comment_is_top":false,"comment_ctime":1527942495,"is_pvip":false,"replies":[{"id":"3590","content":"加油","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527979166,"ip_address":"","comment_id":11213,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18707811679","product_id":100006701,"comment_content":"这个内容延展的好多，这要补多少天的功课，才能搞定😂","like_count":4,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418755,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527979166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":81533,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1553937569,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14438839457","product_id":100006701,"comment_content":"其实我觉得掌握这么多差不多了（数组，链表，扩容），基本的原理并不复杂，至于红黑树的代码真的有必要掌握那么清楚吗，我觉得没啥意义。","like_count":3},{"had_liked":false,"id":13864,"user_name":"沈琦斌","can_delete":false,"product_type":"c1","uid":1160094,"ip_address":"","ucode":"6C97F7C7A9ED0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/9e/c88ac921.jpg","comment_is_top":false,"comment_ctime":1530029186,"is_pvip":false,"replies":[{"id":"4635","content":"这个树实现提供可靠的logn访问性能，哈希表好的时候比它强，问题是出在最差情况，退化成链表了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530074621,"ip_address":"","comment_id":13864,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14414931074","product_id":100006701,"comment_content":"老师，感觉最后讲为什么要树化的时候结尾有点突然。既然您说了树化本质上是个安全问题，那么树化以后怎么就解决安全问题了呢，这个我没有理解，谢谢。","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419791,"discussion_content":"这个树实现提供可靠的logn访问性能，哈希表好的时候比它强，问题是出在最差情况，退化成链表了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530074621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9944,"user_name":"代码狂徒","can_delete":false,"product_type":"c1","uid":1030100,"ip_address":"","ucode":"F5918543E90321","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b7/d4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1527175136,"is_pvip":false,"replies":[{"id":"3249","content":"回复了，数据少的时候，平均访问长度很小，没必要麻烦；0.75是通用场景建议，取个平衡，具体看你调整它目标是什么了","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527484247,"ip_address":"","comment_id":9944,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14412077024","product_id":100006701,"comment_content":"为什么不是一开始就树化，而是要等到一定程度再树化，链表一开始就是消耗查找性能啊？另外其实不太明白为什么是0.75的负载因子，如果是.08或者0.9会有什么影响吗？毕竟已经开辟了相关内存空间","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418269,"discussion_content":"回复了，数据少的时候，平均访问长度很小，没必要麻烦；0.75是通用场景建议，取个平衡，具体看你调整它目标是什么了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527484247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9822,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1527119858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14412021746","product_id":100006701,"comment_content":"这是1.7的hashmap吧？","like_count":3},{"had_liked":false,"id":225804,"user_name":"晓风残月","can_delete":false,"product_type":"c1","uid":1132290,"ip_address":"","ucode":"6FC53AD0BF170D","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/02/b9386dfa.jpg","comment_is_top":false,"comment_ctime":1591863505,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10181798097","product_id":100006701,"comment_content":"预先设置的容量需要满足，大于“预估元素数量 &#47; 负载因子”，同时它是 2 的幂数,这是有问题的，并不一定需要设置为2的幂数，在tableSizeFor方法中会自动将其变为2的幂数。","like_count":2},{"had_liked":false,"id":21451,"user_name":"Meteor","can_delete":false,"product_type":"c1","uid":1180548,"ip_address":"","ucode":"3938D2A1474DD1","user_header":"https://static001.geekbang.org/account/avatar/00/12/03/84/791fb8f1.jpg","comment_is_top":false,"comment_ctime":1535093902,"is_pvip":false,"replies":[{"id":"8082","content":"这个已经有很多讲解，一般来说重写一个，也会要求重写另一个；俩对象equals，那么hashcode通常会要求也相等，但反之不要求；Javadoc也有说明；<br><br>如果你对更细节的、学术性探讨有兴趣，可以看看Java中类似Value-Based class的定义，比较特别","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1535723904,"ip_address":"","comment_id":21451,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10125028494","product_id":100006701,"comment_content":"hashCode() 和equals()两个方法之间什么关系","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422684,"discussion_content":"这个已经有很多讲解，一般来说重写一个，也会要求重写另一个；俩对象equals，那么hashcode通常会要求也相等，但反之不要求；Javadoc也有说明；\n\n如果你对更细节的、学术性探讨有兴趣，可以看看Java中类似Value-Based class的定义，比较特别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535723904,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":20289,"user_name":"allean","can_delete":false,"product_type":"c1","uid":1051470,"ip_address":"","ucode":"A0D2DB4F219EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/4e/fd946cb2.jpg","comment_is_top":false,"comment_ctime":1534348064,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10124282656","product_id":100006701,"comment_content":"很开心能够阅读杨老师的专栏，收获很多。跟着杨老师的指引，一点点的深入，层层迷雾慢慢剥开，仔细思索顿时豁然开朗，这种感觉真是太好了！<br>有一个问题想请教杨老师，当链表长度达到阙值时，【容量】大于MIN_TREEIFY_CAPACITY会触发树化改造，我有两个疑问，<br>1.【容量】是指单个桶的链表长度还是指元素数量，或者是指hashmap的initialCapacity呢？<br>2.MIN_TREEIFY_CAPACITY这个值是固定的还是计算出来的，如果是固定的是多少啊？如果是计算得来的，是如何计算得呢？<br>麻烦杨老师解答一下，非常感谢！<br>","like_count":2,"discussions":[{"author":{"id":1849931,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/3a/4b/defd0082.jpg","nickname":"你好呀_","note":"","ucode":"C76AD754E32AF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298846,"discussion_content":"桶中链表长度大于8且数组长度大于64时树化，是固定的，翻源码可以知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597421269,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11378,"user_name":"影随","can_delete":false,"product_type":"c1","uid":1088169,"ip_address":"","ucode":"48BC4CFCAD3C2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/a9/ae10f6cd.jpg","comment_is_top":false,"comment_ctime":1528101924,"is_pvip":false,"replies":[{"id":"3669","content":"什么错？Java版本是不是太老了？示例是运行过的，不过我本地最低版本是9","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528155179,"ip_address":"","comment_id":11378,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10118036516","product_id":100006701,"comment_content":"LinkedHashMapSample 那个示例，为什么<br><br>accessOrderedMap<br>@Override 的 removeEldestEntry()方法报错？  <br>只有我这儿报错吗？","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418814,"discussion_content":"什么错？Java版本是不是太老了？示例是运行过的，不过我本地最低版本是9","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528155179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11294,"user_name":"江昆","can_delete":false,"product_type":"c1","uid":1102624,"ip_address":"","ucode":"38E3F57BEEDA92","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/20/e93190e2.jpg","comment_is_top":false,"comment_ctime":1528035344,"is_pvip":true,"replies":[{"id":"3670","content":"可以构建合适的数据进行哈希碰撞攻击","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1528155352,"ip_address":"","comment_id":11294,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10117969936","product_id":100006701,"comment_content":"为什么 HashMap 要树化呢？因为在最坏条件下，链表的查询时间是O(N），数的查询时间是O(LOG N）？能请老师解释一下为什么说本质上是因为安全呢？谢谢老师","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418780,"discussion_content":"可以构建合适的数据进行哈希碰撞攻击","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1528155352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":10699,"user_name":"沉默的雪人","can_delete":false,"product_type":"c1","uid":1107012,"ip_address":"","ucode":"1154625C92B54B","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/44/c4eadde0.jpg","comment_is_top":false,"comment_ctime":1527651535,"is_pvip":false,"replies":[{"id":"3422","content":"对","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527695436,"ip_address":"","comment_id":10699,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10117586127","product_id":100006701,"comment_content":"hashmap的树化，我记得是Jdk1.8的内容吧","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418568,"discussion_content":"对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527695436,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343623,"user_name":"非洲的小白","can_delete":false,"product_type":"c1","uid":2846786,"ip_address":"","ucode":"497F9AC3F74D02","user_header":"","comment_is_top":false,"comment_ctime":1650958837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5945926133","product_id":100006701,"comment_content":"关于 HashMap 计算key的hash值时，为什么使用以下方式：<br>static final int hash(Object key) {<br>    int h;<br>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>}<br><br>简单来说：就是减少哈希碰撞。<br>详细分析：首先是因为 HashMap 的哈希寻址（找到key对应的数组下标）是忽略容量以上的高位的，具体怎么忽略，代码及解释如下：<br>i = (n - 1) &amp; hash  &#47;&#47; n为HashMap 数组容量（必定为2的次方）<br>&#47;&#47; 任意一个值 与 2的次方-1 进行&amp;(并)运算时，得到的值就是hash求余n后的余数<br><br>然而，有些数据计算出的哈希值差异主要在高位。<br>所以，HashMap 在计算key的hash值时，采用了这种（高位保留 + 高位与低位^(异或)运算)方式。<br>关于哈希碰撞的举例说明，个人认为应该结合 HashMap 本身的哈希寻址特点来举例。假设 HashMap 现在的 table 数组容量为16，并且hash方法的右移位数为 h &gt;&gt;&gt; 4，现在有3个key，对应的hash值恰好是1*16+1=17、2*16+1=33、3*16+1=49，如果不进行高低位异或运算，那么它们在哈希寻址后都会存放到 table[1] 的哈希桶下（也就是所为的哈希碰撞）。如果进行了高低位异或运算，最终这三个key就可能存放在不同的哈希桶下，具体的高低位异或运算如下：<br>&#47;&#47; 下面每一段的第一行表示hash值，第二行表示二进制，第三行表示右移4位后的结果，第四行表示高低位异或运算后的结果<br><br>&#47;&#47; 17<br>&#47;&#47; 0001 0001<br>&#47;&#47; 0000 0001<br>&#47;&#47; 0001 0000<br><br>&#47;&#47; 33<br>&#47;&#47; 0010 0001<br>&#47;&#47; 0000 0010<br>&#47;&#47; 0010 0011<br><br>&#47;&#47; 49<br>&#47;&#47; 0011 0001<br>&#47;&#47; 0000 0011<br>&#47;&#47; 0011 0010<br><br>最后，个人思考，会不会出现一种情况，明明几个key的hash值直接进行哈希寻址不会发生碰撞，但进行高低位异或运算后，反而发生了碰撞？<br>这种情况下，肯定是各自的高位和低位都互不相同，但经过高低位异或运算后，恰好导致低位相同了。不过这种数据的出现率应该是远远小于上面所说的高位不同而低位相同的数据。","like_count":1},{"had_liked":false,"id":263247,"user_name":"yami粉丝","can_delete":false,"product_type":"c1","uid":1707976,"ip_address":"","ucode":"0F2E8121697A6C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0f/c8/99e873a4.jpg","comment_is_top":false,"comment_ctime":1606058175,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5901025471","product_id":100006701,"comment_content":"看到树化马上就打起精神了，结果太监了，后面没有了。。。。。","like_count":1},{"had_liked":false,"id":103111,"user_name":"ゞ﹏雨天____゛","can_delete":false,"product_type":"c1","uid":1451392,"ip_address":"","ucode":"9639F0340C6C91","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/80/fdd5a88f.jpg","comment_is_top":false,"comment_ctime":1560385835,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5855353131","product_id":100006701,"comment_content":"大家可能希望看这个专栏，想学习到很多很多知识，说实话，我也是。但是，因为专栏篇幅有限，所以，杨老师肯定无法面面俱到。通过认真反复读文稿，再结合评论，我感觉对知识内容HashMap有了基本认识，所以以后还要自己学习总结。给老师点赞！","like_count":1,"discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":147686,"discussion_content":"也没看你看几篇嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579666525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":59942,"user_name":"whhbbq","can_delete":false,"product_type":"c1","uid":1018494,"ip_address":"","ucode":"4A93F3E375CB44","user_header":"","comment_is_top":false,"comment_ctime":1547432621,"is_pvip":false,"replies":[{"id":"23324","content":"inner class 使用 &lt;&gt; operator需要jdk 9以后","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549811859,"ip_address":"","comment_id":59942,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5842399917","product_id":100006701,"comment_content":"LinkedHashMapSample这段代码编译通不过吧？","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":436421,"discussion_content":"inner class 使用 &amp;lt;&amp;gt; operator需要jdk 9以后","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549811859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":49785,"user_name":"樱小路依然","can_delete":false,"product_type":"c1","uid":1269957,"ip_address":"","ucode":"DBA9FF68015FE5","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/c5/69286d58.jpg","comment_is_top":false,"comment_ctime":1544769199,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5839736495","product_id":100006701,"comment_content":"感觉还是自己的java知识底子太薄了，听老师讲课，除了小部分能够完全理解，大部分知识感觉都是雾里看花~一些JDK新特性也不懂...很多知识感觉是老师用一个我不懂的知识来解释另一个我不懂的知识...做好笔记，希望有朝一日能够完全理解。","like_count":1},{"had_liked":false,"id":37245,"user_name":"志林","can_delete":false,"product_type":"c1","uid":1120409,"ip_address":"","ucode":"6F27616857A46F","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/99/f27997e1.jpg","comment_is_top":false,"comment_ctime":1541504044,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5836471340","product_id":100006701,"comment_content":"开放定址法，再哈希法，链地址法，建立公共溢出区","like_count":1},{"had_liked":false,"id":30545,"user_name":"小时候可笨了","can_delete":false,"product_type":"c1","uid":1066608,"ip_address":"","ucode":"8F272AD9B33C0C","user_header":"https://static001.geekbang.org/account/avatar/00/10/46/70/e5ae5890.jpg","comment_is_top":false,"comment_ctime":1538917483,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5833884779","product_id":100006701,"comment_content":"老师，问个问题，hashmap的put操作是没有加锁的，那么在转红黑树的时候遇到并发场景，比如，红黑树转一半的时候，有个新node插进当前链表来，怎么办？","like_count":1,"discussions":[{"author":{"id":2057933,"avatar":"","nickname":"Geek_6f325e","note":"","ucode":"6B7F1D8AAEF2BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382581,"discussion_content":"直接推荐用 并发map","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625640791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1101070,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cd/0e/3b42e6d2.jpg","nickname":"Happy","note":"","ucode":"40BF820FDCFF25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177785,"discussion_content":"你这是不是多线程了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582121328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":17846,"user_name":"clz1341521","can_delete":false,"product_type":"c1","uid":1179557,"ip_address":"","ucode":"3BDB4AB454C918","user_header":"https://static001.geekbang.org/account/avatar/00/11/ff/a5/eccc7653.jpg","comment_is_top":false,"comment_ctime":1532996582,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5827963878","product_id":100006701,"comment_content":"解决哈希冲突的常用方法有4种：<br><br>开放定址法<br>基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。<br><br>再哈希法<br>这种方法是同时构造多个不同的哈希函数：<br>Hi=RH1（key）  i=1，2，…，k<br>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。<br><br>链地址法<br>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。<br><br>建立公共溢出区<br>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表","like_count":1,"discussions":[{"author":{"id":1541386,"avatar":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","nickname":"N_H","note":"","ucode":"109B67557AB3CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2029,"discussion_content":"第三种方法不就是jdk1.7中实现的hashmap的链地址法么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563185295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":14920,"user_name":"Yonei","can_delete":false,"product_type":"c1","uid":1118139,"ip_address":"","ucode":"BBB9320420B822","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/bb/eed7b035.jpg","comment_is_top":false,"comment_ctime":1530751728,"is_pvip":false,"replies":[{"id":"5083","content":"是的，树性能恶化不会太剧烈","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530894099,"ip_address":"","comment_id":14920,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5825719024","product_id":100006701,"comment_content":"我感觉树化一个目的是防止hash冲突导致的resize时的死循环，还有就是减少查找遍历路径，毕竟树的查找不用遍历全部，特别像是平衡二叉树的遍历。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420172,"discussion_content":"是的，树性能恶化不会太剧烈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530894099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13301,"user_name":"A_吖我去","can_delete":false,"product_type":"c1","uid":1133984,"ip_address":"","ucode":"AE8CEF4DD1234A","user_header":"https://static001.geekbang.org/account/avatar/00/11/4d/a0/af1f53f0.jpg","comment_is_top":false,"comment_ctime":1529508304,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5824475600","product_id":100006701,"comment_content":"所以，并发访问hashmap为啥会死循环，那个链接我访问不到","like_count":1},{"had_liked":false,"id":10715,"user_name":"Miaozhe","can_delete":false,"product_type":"c1","uid":1113660,"ip_address":"","ucode":"62872E8C138B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/3c/13175251.jpg","comment_is_top":false,"comment_ctime":1527667941,"is_pvip":false,"replies":[{"id":"3424","content":"没错，第一个就是访问最少的元素，所以按照访问顺序会被删除","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527695732,"ip_address":"","comment_id":10715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5822635237","product_id":100006701,"comment_content":"杨老师，我使用你提供的LinkedHashMap Simple样例，.get()方法感觉没有效果，新增后，触发删除，删除的还是第一个插入的数据。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418577,"discussion_content":"没错，第一个就是访问最少的元素，所以按照访问顺序会被删除","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527695732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9873,"user_name":"Libra","can_delete":false,"product_type":"c1","uid":1114307,"ip_address":"","ucode":"30356CFF4C8E35","user_header":"https://static001.geekbang.org/account/avatar/00/11/00/c3/266f9e8d.jpg","comment_is_top":false,"comment_ctime":1527135781,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5822103077","product_id":100006701,"comment_content":"首先，hashmap的扩容一定是容量不满足要求(cap==0或者cap==阈值).树化的目的是减少访问时用时。如果沿用1.7的链表设计，在哈希碰撞比较多的情况下会大幅度降低性能。","like_count":1},{"had_liked":false,"id":9862,"user_name":"df1996","can_delete":false,"product_type":"c1","uid":1124110,"ip_address":"","ucode":"3C94215CAB74F4","user_header":"","comment_is_top":false,"comment_ctime":1527129147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5822096443","product_id":100006701,"comment_content":"老师，我只是为了测试链表转为红黑树 构造函数设置了长度1，负载因子10，插入8条的时候是正常的8长度链表，put9个的时候就自动扩容了而不是转为红黑树，我在treeifyBin方法中看到当前数组长度小于64就会resize ，这是对不合理的负载因子设置的一种保护吗？","like_count":1},{"had_liked":false,"id":9845,"user_name":"极客er","can_delete":false,"product_type":"c1","uid":1061466,"ip_address":"","ucode":"43A30683884E2E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/5a/347570e6.jpg","comment_is_top":false,"comment_ctime":1527124001,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5822091297","product_id":100006701,"comment_content":"那如何避免 哈希碰撞拒绝服务攻击 呢？","like_count":1},{"had_liked":false,"id":9829,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1527121063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5822088359","product_id":100006701,"comment_content":"很多hashmap的负载因子都用0.75，这是业内共识？有论文？","like_count":1},{"had_liked":false,"id":351404,"user_name":"restart","can_delete":false,"product_type":"c1","uid":3027603,"ip_address":"","ucode":"8D43E02B0EC02C","user_header":"https://static001.geekbang.org/account/avatar/00/2e/32/93/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1657770141,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657770141","product_id":100006701,"comment_content":"&quot;扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。&quot;<br>请教下，hashmap扩容时，是重新开辟两倍的空间，还是在原来老数组基础上扩大一倍空间","like_count":0},{"had_liked":false,"id":348665,"user_name":"Geek_db5fa0","can_delete":false,"product_type":"c1","uid":3025184,"ip_address":"","ucode":"6FC423922CCD4C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eovjNRNjPcwyre1uDWKdC6vA4hcJSicpVoqpaoNR9PFomTAJfMCTjgSzUqe7RuflhSSCYmBaW5RzicQ/132","comment_is_top":false,"comment_ctime":1655286949,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655286949","product_id":100006701,"comment_content":"现在多线程的话concurrentHashMap比hashtable好用吧","like_count":0},{"had_liked":false,"id":336229,"user_name":"键盘上的魔术","can_delete":false,"product_type":"c1","uid":2697700,"ip_address":"","ucode":"A731D721FB8D3A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","comment_is_top":false,"comment_ctime":1646017586,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1646017586","product_id":100006701,"comment_content":"我看树化前的判断是binCount &gt;= TREEIFY_THRESHOLD - 1。 也就是单个链表长度达到7就行了。 为什么你们都在说是8？","like_count":0,"discussions":[{"author":{"id":2846786,"avatar":"","nickname":"非洲的小白","note":"","ucode":"497F9AC3F74D02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567619,"discussion_content":"因为binCount从0开始啊。。。 0到7 不就是8个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650958933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303673,"user_name":"别人家的康少","can_delete":false,"product_type":"c1","uid":1192871,"ip_address":"","ucode":"90047378D529FA","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/a7/b1c90605.jpg","comment_is_top":false,"comment_ctime":1626923458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626923458","product_id":100006701,"comment_content":"有一点没理解一个过程<br>当&gt;threadshold, 会进行treeify(), 链表转化为树化结构<br>后面说&gt;MIN_TREEIFY_CAPACTITY,会进行树化， 否则进行简单扩容<br>问题: 第一次的树化结构指的是什么？是变为红黑树吗<br>第一次的树化结构跟第二次是一样的吗？<br>简单扩容具体是什么意思","like_count":0},{"had_liked":false,"id":298208,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1120186,"ip_address":"","ucode":"8094E8A5C8A5C9","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/ba/47e464ea.jpg","comment_is_top":false,"comment_ctime":1623950803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623950803","product_id":100006701,"comment_content":"老师，请教一下，如果在resize的过程中发生了put操作，可能会导致什么后果？","like_count":0},{"had_liked":false,"id":293972,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1621661236,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621661236","product_id":100006701,"comment_content":"HashMap采用的链地址法，还有开放定址法，再哈希法","like_count":0},{"had_liked":false,"id":289463,"user_name":"Rorchachl","can_delete":false,"product_type":"c1","uid":1895320,"ip_address":"","ucode":"7AABFF65A0033C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/KiaBJsepm9fHHicfPxiahhR3RqRaR4QH6YFibIHV5o5VspTIXmH72iaiaotb4cRpWtRvLC7mnh5KH1KlSNLGWlI7wUicQ/132","comment_is_top":false,"comment_ctime":1619022257,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619022257","product_id":100006701,"comment_content":"解决散列冲突有哪些典型的方法<br><br>1.拉链法<br>将大小为M的数组中的每个元素指向一条链表 链表中的每个节点都存储了散列值为该元素的索引的键值对<br> 2.基于线性探测法<br>当碰撞发生时，直接检查散列表中的下一个位置 将索引加一 知道找到该键或者遇到一个null元素","like_count":0},{"had_liked":false,"id":288685,"user_name":"let_me_go","can_delete":false,"product_type":"c1","uid":1510177,"ip_address":"","ucode":"A5936F5C5E3D65","user_header":"https://static001.geekbang.org/account/avatar/00/17/0b/21/f1aea35b.jpg","comment_is_top":false,"comment_ctime":1618624991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618624991","product_id":100006701,"comment_content":"Map 以&lt;key, value&gt; 键值对的形式来存放数据。key 经过 Hash 运算，得到一个定长的整数，将这个定长的整数进行取模，得到一个处于我们规定范围内的 index，这个 index 就像是数组的下标，我们将该元素放在 第 index 这个位置。由于我们的存储空间不可能无限大，Hash 函数也无法保证不同的 key 经过计算得到的这个整数一定唯一，因此一定会有多个元素可能会被映射到同一个位置（这称为 Hash 冲突）。对于一个数组，一个位置只能放一个元素，在这一点上，HashMap就表现的和简单的数组不一样了，一个位置我们可以放多个元素，因此称其为桶更合适。当多个元素被映射到同一个桶时，在 Java 8 之前采用的是链表法，将元素通过链表一个个串起来。当我们通过key来获取某个元素时，同样是将该 key 进行 hash 运算，得到一个 index，根据该index 去对应的桶找元素，如果桶中有且仅有一个元素，毫无疑问应该就是这个元素，可以直接取出，如果有多个元素（多个元素就是以链表的形式串起来的），就遍历链表。Java 8 开始，有了一些调整，在一定条件下（Map的容量 &gt; 64 且 某个桶中的元素 &gt; 8）桶中的元素会转化为以红黑树的形式来进行存储，相比于链表，红黑树的查找速度更快。<br><br>当Map中的元素的个数达到一定门限值时，得进行扩容。HashMap 的扩容机制和 ArrayList 这些不同，ArrayList 的数组大小就是整个存储空间的大小，比如数组长度为 10，就说明能存储 10 个元素，但是 Map 不一样，表现得稍微复杂一些。整个 Map 的容量 = loadFactor（负载因子） *  capacity。在创建一个 HashMap 时，我们可以在构造函数中进行指定整个 Map 的初始化容量 initCapacity ，loadFactor 默认的值为 0.75f，不建议进行调整。为什么需要使用 loadFactor *  capacity 来表示 Map 的容量呢，当loadFactor = 0.75 时，实际能存储的数据量只有 0.75 * capacity  ，这么做不是有些浪费空间吗。为什么不等到满了再扩容？这个和我们的 Hash 函数有关，上面我们已经知道了，hash 函数的一个重要作用就是将 key 值经过计算得到一个定长的整数，然后取模得到一个 index ，数据就存储在该index对应的桶中。当整个 Map 的数据量比较大，比较满的时候，说明很多桶都有元素了，如果再往里面放元素，很难避免重复放在一个桶中的情况。虽然桶已经进行优化了，使用红黑树来存放，使用红黑树比链表的查询效率高，但是相比Map O(1) 的查询时间复杂度，还是退化了不少，所以不能让 Map 完完全全装满，到达一定的限制就可以开始扩容，这么做的目的就是减少 Hash 冲突，避免多个元素都放在了同一个桶中。","like_count":0},{"had_liked":false,"id":287637,"user_name":"Rorchachl","can_delete":false,"product_type":"c1","uid":1895320,"ip_address":"","ucode":"7AABFF65A0033C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/KiaBJsepm9fHHicfPxiahhR3RqRaR4QH6YFibIHV5o5VspTIXmH72iaiaotb4cRpWtRvLC7mnh5KH1KlSNLGWlI7wUicQ/132","comment_is_top":false,"comment_ctime":1618061875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618061875","product_id":100006701,"comment_content":"预先设置的容量需要满足，大于“预估元素数量 &#47; 负载因子”  <br>为什么要这么做 而不直接是预估元素数量<br>因为 当thesold小与map.size（map中键值对的数量 如果指定初始化时的容量此时的size为0 每put一次+1）的时候会发生扩容<br>如何避免初始化的时候再一次的扩容 <br>负载因子*元素  &gt; 预估数量   所以预估数量应该 大于 预估元素数量&#47;负载因子<br>不知道对不对<br>","like_count":0},{"had_liked":false,"id":287360,"user_name":"Rorchachl","can_delete":false,"product_type":"c1","uid":1895320,"ip_address":"","ucode":"7AABFF65A0033C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/KiaBJsepm9fHHicfPxiahhR3RqRaR4QH6YFibIHV5o5VspTIXmH72iaiaotb4cRpWtRvLC7mnh5KH1KlSNLGWlI7wUicQ/132","comment_is_top":false,"comment_ctime":1617901068,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617901068","product_id":100006701,"comment_content":"红黑树  红黑树是二-三树的高效实现  <br>它是用标准的二叉查找树和一些额外信息来表示2-3树<br>它分为两种链接<br>红连接 有且只能左斜  它相连的两个2–节点表示一个3-节点，黑链接则是2-3树的普通连接 不限制 是否左斜或者右斜<br><br>红黑树的出现优化了二分查找树 在最坏情况的时间复杂度  比如 讲一个有序的数组中的元素依次插入二分查找树他的时间复杂度是线性的<br>而红黑树能保证树的平衡性 所以每次查询操作都能在对数时间内完成<br><br><br>红黑树中的红链接必须是左链接<br>并且没有任何一个节点同时和两个红链接想连<br><br>左旋，右旋 是为了解决插入过程中出现一个节点同时和两个红链接想连<br><br>左旋，和右旋<br>左旋的参数 一条红色的右链接<br>本质是讲原本 两个节点中键较小者变为较大者作为根节点<br>右旋和左旋类似 只是把右链接变为左链接","like_count":0},{"had_liked":false,"id":268836,"user_name":"acqierement","can_delete":false,"product_type":"c1","uid":1234980,"ip_address":"","ucode":"AC8DA74B9CB924","user_header":"https://static001.geekbang.org/account/avatar/00/12/d8/24/f48a38f4.jpg","comment_is_top":false,"comment_ctime":1608367192,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608367192","product_id":100006701,"comment_content":"评论里说，老师讲的不详细，如果真的要详细，那真的是需要把源码拎出来一点点讲。我想老师只是起到一个提纲挈领的作用，告诉我们大概要关注的点，让你更有方向。比如hashcoe和equals讲解，《effective java》是单独拿一条来讲的。所以，可能阅读这个专栏的目的要改变一下。","like_count":0},{"had_liked":false,"id":254094,"user_name":"小一","can_delete":false,"product_type":"c1","uid":1129360,"ip_address":"","ucode":"2732EF8D1008DF","user_header":"https://static001.geekbang.org/account/avatar/00/11/3b/90/e8982641.jpg","comment_is_top":false,"comment_ctime":1603065390,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603065390","product_id":100006701,"comment_content":"这个课程讲的都很细，值得慢慢琢磨","like_count":0},{"had_liked":false,"id":235889,"user_name":"looper","can_delete":false,"product_type":"c1","uid":1238396,"ip_address":"","ucode":"DA4BCE83836C04","user_header":"https://static001.geekbang.org/account/avatar/00/12/e5/7c/2a5a418b.jpg","comment_is_top":false,"comment_ctime":1595235131,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595235131","product_id":100006701,"comment_content":"解决hash冲突的方法：<br>1.开发寻址法<br>2.链表法，即hashmap没有超过阈值的时候使用的算法","like_count":0},{"had_liked":false,"id":235638,"user_name":"Arthur","can_delete":false,"product_type":"c1","uid":1222441,"ip_address":"","ucode":"FF96EEDEBF7E3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/29/977c3280.jpg","comment_is_top":false,"comment_ctime":1595132856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595132856","product_id":100006701,"comment_content":"【重写了 hashCode 也要重写 equals】，重写equals也要重写hashCode，因为如果对象在哈希表处理，比如HashMap，HashSet中，因为 在这些类中，判断对象是否存在，使用的是 hashCode 比较，如果两个对象仅仅是 equals，而 hashCode方法没有重写，当 对象作为 key 存入哈希表，会导致 containsKey方法失效","like_count":0},{"had_liked":false,"id":235636,"user_name":"Arthur","can_delete":false,"product_type":"c1","uid":1222441,"ip_address":"","ucode":"FF96EEDEBF7E3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/29/977c3280.jpg","comment_is_top":false,"comment_ctime":1595132611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595132611","product_id":100006701,"comment_content":"【hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致】<br>保持一致性，是指【参与HashCode计算的关键属性】不改变时，HashCode要保持一致性，而【状态改变】对应的值，不参与hashCode计算，否则hashCode不能保持一致性。","like_count":0},{"had_liked":false,"id":235513,"user_name":"Arthur","can_delete":false,"product_type":"c1","uid":1222441,"ip_address":"","ucode":"FF96EEDEBF7E3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/29/977c3280.jpg","comment_is_top":false,"comment_ctime":1595069741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595069741","product_id":100006701,"comment_content":"解决Hash冲突的办法<br>1、开放地址法：H = ( H(key) + d )  MOD m，<br>其中： H(key) 为哈希函数；m 为哈希表表长；d为增量序列；<br>2、再Hash法：H = RH(key)，R 和 H 是不同的哈希函数，再产生哈希冲突时计算另一个哈希函数地址，直到冲突不再发生；好处：不易产生“聚集”；坏处：增加计算时间；<br>3、链地址法：关键字的哈希值相同的记录存储在同一线性链表上，每个值的初始状态都是空指针；（较常用的办法，比如HashMap中使用链地址法解决冲突）；<br>4、建立一个公共溢出区：哈希函数的值的范围[0, m-1]，则HashTable为[0 ... m -1 ] 的基本表，每个值存放一个记录；在另外创建一个向量 OverTable[0 ... V] 为溢出表；所有关键字和基本表中的关键字为同义词记录，一旦发生冲突，都填入溢出表；","like_count":0},{"had_liked":false,"id":227999,"user_name":"Geek_36d","can_delete":false,"product_type":"c1","uid":1994930,"ip_address":"","ucode":"CEC91FE5451247","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/nULtwydx55TA3Kp1ribC1B2Ia4NJBuHrbj8RDFNa9ciab1MepC5iaUBmPUL5B6J71IKy3Of85TFdqEkkukR05sF3Q/132","comment_is_top":false,"comment_ctime":1592535177,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592535177","product_id":100006701,"comment_content":"作者大大是手巧的代码嘛，putval里<br>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,<br>                   boolean evict) {<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;<br>        if ((tab = table) == null || (n = tab.length) == 0)<br>            n = (tab = resize()).length;<br>        if ((p = tab[i = (n - 1) &amp; hash]) == null)<br>            tab[i] = newNode(hash, key, value, null);<br>        else {<br>            Node&lt;K,V&gt; e; K k;<br>            if (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                e = p;<br>            else if (p instanceof TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);<br>            else {<br>                for (int binCount = 0; ; ++binCount) {<br>                    if ((e = p.next) == null) {<br>                        p.next = newNode(hash, key, value, null);<br>                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) &#47;&#47; -1 for 1st<br>                            treeifyBin(tab, hash);<br>                        break;<br>                    }<br>                    if (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                        break;<br>                    p = e;<br>                }<br>            }<br>            if (e != null) { &#47;&#47; existing mapping for key<br>                V oldValue = e.value;<br>                if (!onlyIfAbsent || oldValue == null)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                return oldValue;<br>            }<br>        }<br>        ++modCount;<br>        if (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        return null;<br>    }","like_count":0},{"had_liked":false,"id":194004,"user_name":"gank","can_delete":false,"product_type":"c1","uid":1905793,"ip_address":"","ucode":"F252EBD049596F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKVYFEMns6dNNncJfhydDULz1x1SEDF8b323icwiaYrHqjwPib1Z8eUDumQ68zd1oCaECoSBAiaXXytIg/132","comment_is_top":false,"comment_ctime":1585013216,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585013216","product_id":100006701,"comment_content":"链表的遍历时间复杂度O(n),红黑树的时间复杂度是O（logn）。这就是原因","like_count":0},{"had_liked":false,"id":179843,"user_name":"少年锦时","can_delete":false,"product_type":"c1","uid":1313379,"ip_address":"","ucode":"70E2CFF88A0ACB","user_header":"https://static001.geekbang.org/account/avatar/00/14/0a/63/165b0d40.jpg","comment_is_top":false,"comment_ctime":1582108970,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582108970","product_id":100006701,"comment_content":"equals 重写 要遵循 自反省、一致性、传递性、对称性","like_count":0},{"had_liked":false,"id":160431,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1575949839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575949839","product_id":100006701,"comment_content":"看了一下老师给的文章，关于HashMap的问题，其实就是并发情况下可能会出现循环的情况就是，就拿文章中的例子为例，会出现本应该B节点指向null，结果插入一个A节点，他又去指向A，造成了一个循环。","like_count":0},{"had_liked":false,"id":152917,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1574124131,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1574124131","product_id":100006701,"comment_content":"9 9.1 HashTable HashMap和TreeMap，HashTable继承于Dictionary，HashMap和TreeMap继承于AbstractMap，HashTable是线程同步的哈希表结构，HashMap和TreeMap不是线程同步，支持键值为null，get和put时间复杂度O(1)，他们都是存放键值对的容器，TreeMap基于红黑树提供的顺序访问的Map，时间复杂度O(lgn) 9.2 用Map的场景一般都是随机读取，写入和删除，不保证顺序，HashMap的时间复杂度O(1)，是最好的选择，HashMap非常依赖于哈希码的有效性，Hash码和equals有一些约定，equals相等，哈希码也一定相等，重写了hashCode，也一定要重写equals，LinkedHashMap和TreeMap保证了有序性，LinkedHashMap提供了遍历顺序，符合插入顺序，他是维护了一个双向链表，对于TreeMap，他的整体顺序由键的顺序关系决定 9.3 HashMap源码分析 HashMap底层是数组和链表的复合结构，每一个值都可以看成一个桶，相同的值组成链表，如果值多了，退化成树","like_count":0,"discussions":[{"author":{"id":1092044,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a9/cc/c417c886.jpg","nickname":"湮灭星空","note":"","ucode":"B1061A4C298E13","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322035,"discussion_content":"链表转为红黑树结构，不是应该叫进化吗？退化成树怎么理解？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604666072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146212,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1572468741,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1572468741","product_id":100006701,"comment_content":"哈希表是数组的推广，数组是按照下标访问目标对象，哈希表是增加了键值到下标的映射，按照键值访问对象。键值适用的范围比下标广。但是这种灵活性也不是没有代价的。代价是需要一个哈希函数，还要处理冲突。围绕哈希函数会有一堆数学证明，但主要的目的是最小化冲突。围绕处理冲突，需要哈希表要有空间冗余，常用的方法有链表法，树化，开放地址法等。","like_count":0},{"had_liked":false,"id":131695,"user_name":"Geek_f98786","can_delete":false,"product_type":"c1","uid":1588146,"ip_address":"","ucode":"48049CEE62049A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ajNVdqHZLLBtGJZdVW9XicpaW93YhyIiaELTkkSrQrZ4SNfMsVC2ibOGYCfEmIPhqiaO76piaKicHk53NbiaNibBYrfttw/132","comment_is_top":false,"comment_ctime":1567851690,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1567851690","product_id":100006701,"comment_content":" 可以讲一讲 HashMap怎么从链表转换为红黑树的吗","like_count":0},{"had_liked":false,"id":113921,"user_name":"N_H","can_delete":false,"product_type":"c1","uid":1541386,"ip_address":"","ucode":"109B67557AB3CE","user_header":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","comment_is_top":false,"comment_ctime":1563185705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563185705","product_id":100006701,"comment_content":"老师用非常精炼的语言讲述了主要的特性，将整个框架整理出来了，类似一个提纲，需要自己在下面进行扩展，觉得这种方式挺好.","like_count":0},{"had_liked":false,"id":107279,"user_name":"小马豆","can_delete":false,"product_type":"c1","uid":1327748,"ip_address":"","ucode":"6475DAFB48701E","user_header":"https://static001.geekbang.org/account/avatar/00/14/42/84/3df6764b.jpg","comment_is_top":false,"comment_ctime":1561511286,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1561511286","product_id":100006701,"comment_content":"老师好，文中说“如果链表大小超过阈值（TREEIFY_THRESHOLD,8）”我想请教一下这里的默认阈值8指的是单个链表的阈值达到8还是不同链表数据的加和超过8，才会触发扩容或者树化","like_count":0,"discussions":[{"author":{"id":1092044,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a9/cc/c417c886.jpg","nickname":"湮灭星空","note":"","ucode":"B1061A4C298E13","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322039,"discussion_content":"是单个链表的节点数量达到 8，另外还要求数组的大小大于 64","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604666395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541386,"avatar":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","nickname":"N_H","note":"","ucode":"109B67557AB3CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2025,"discussion_content":"单个链表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563185075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106497,"user_name":"xmy","can_delete":false,"product_type":"c1","uid":1259490,"ip_address":"","ucode":"B625313A67EED7","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/e2/86a115b3.jpg","comment_is_top":false,"comment_ctime":1561336746,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1561336746","product_id":100006701,"comment_content":"一直有个疑问，hashmap发生碰撞以后进入一个list，如何获取这些值呢","like_count":0,"discussions":[{"author":{"id":1092044,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a9/cc/c417c886.jpg","nickname":"湮灭星空","note":"","ucode":"B1061A4C298E13","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":322040,"discussion_content":"在桶的链表中使用遍历的方法取值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604666432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541386,"avatar":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","nickname":"N_H","note":"","ucode":"109B67557AB3CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2026,"discussion_content":"比较hash值和key值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563185106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":98360,"user_name":"Aven","can_delete":false,"product_type":"c1","uid":1066230,"ip_address":"","ucode":"E2B1D0B57F18D1","user_header":"https://static001.geekbang.org/account/avatar/00/10/44/f6/60f948e1.jpg","comment_is_top":false,"comment_ctime":1558967322,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1558967322","product_id":100006701,"comment_content":"老师，您好，在讲述LinkedHashMap的时候，关于removeEldestEntry这个说法是不是在JDK7&#47;8中其实是不同的实现呢？在JDK7中，其实每次删除的都是最先put进去的key，而在JDK8中才是删除「最不常使用的元素」？","like_count":0},{"had_liked":false,"id":92173,"user_name":"流光","can_delete":false,"product_type":"c1","uid":1434612,"ip_address":"","ucode":"2B41D1B890018D","user_header":"https://static001.geekbang.org/account/avatar/00/15/e3/f4/ecb33aef.jpg","comment_is_top":false,"comment_ctime":1557194770,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557194770","product_id":100006701,"comment_content":"你的源代码多局部变量都没头没尾的;threshold = neThr;<br>这个neThr应该是newThr吧; 源码这段和你copy的有太大区别:<br>  threshold = newThr;<br>        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})<br>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];<br><br>希望能注意下","like_count":0},{"had_liked":false,"id":91184,"user_name":"码上Java","can_delete":false,"product_type":"c1","uid":1295726,"ip_address":"","ucode":"C616EC77DE6695","user_header":"https://static001.geekbang.org/account/avatar/00/13/c5/6e/82ef354b.jpg","comment_is_top":false,"comment_ctime":1556891964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556891964","product_id":100006701,"comment_content":"Hashtable、HashMap、TreeMap心得<br><br>三者均实现了Map接口，存储的内容是基于key-value的键值对映射，一个映射不能有重复的键，一个键最多只能映射一个值。<br><br>（1） 元素特性<br>HashTable中的key、value都不能为null；HashMap中的key、value可以为null，很显然只能有一个key为null的键值对，但是允许有多个值为null的键值对；TreeMap中当未实现 Comparator 接口时，key 不可以为null；当实现 Comparator 接口时，若未对null情况进行判断，则key不可以为null，反之亦然。<br><br>（2）顺序特性<br>HashTable、HashMap具有无序特性。TreeMap是利用红黑树来实现的（树中的每个节点的值，都会大于或等于它的左子树种的所有节点的值，并且小于或等于它的右子树中的所有节点的值），实现了SortMap接口，能够对保存的记录根据键进行排序。所以一般需要排序的情况下是选择TreeMap来进行，默认为升序排序方式（深度优先搜索），可自定义实现Comparator接口实现排序方式。<br><br>（3）初始化与增长方式<br>初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。<br>扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。<br><br>（4）线程安全性<br>HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。<br>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步（1）可以用 Collections的synchronizedMap方法；（2）使用ConcurrentHashMap类，相较于HashTable锁住的是对象整体， ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升。<br><br>(5)一段话HashMap<br>HashMap基于哈希思想，实现对数据的读写。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。","like_count":0},{"had_liked":false,"id":84779,"user_name":"wei","can_delete":false,"product_type":"c1","uid":1494857,"ip_address":"","ucode":"D733C223BFBA4A","user_header":"https://static001.geekbang.org/account/avatar/00/16/cf/49/af338c0f.jpg","comment_is_top":false,"comment_ctime":1554906434,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554906434","product_id":100006701,"comment_content":"hashmap的区别还是要分jdk版本来阐述吧，主要是1.7和1.8之间的区别。<br>","like_count":0},{"had_liked":false,"id":82814,"user_name":"逍遥","can_delete":false,"product_type":"c1","uid":1070213,"ip_address":"","ucode":"95C583EF780159","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/85/081804f7.jpg","comment_is_top":false,"comment_ctime":1554334271,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1554334271","product_id":100006701,"comment_content":"造成哈希冲突的主要原因能分析一下吗","like_count":0},{"had_liked":false,"id":80770,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1553733054,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1553733054","product_id":100006701,"comment_content":"只知道多次hash😂","like_count":0},{"had_liked":false,"id":77193,"user_name":"Neil","can_delete":false,"product_type":"c1","uid":1101485,"ip_address":"","ucode":"9C0450E9BB5081","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/ad/84056510.jpg","comment_is_top":false,"comment_ctime":1552881152,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1552881152","product_id":100006701,"comment_content":"HashMap和ConcurrentHashMap的最大容量为什么是1 &lt;&lt; 30，而不是int最大值呢","like_count":0},{"had_liked":false,"id":71779,"user_name":"青山","can_delete":false,"product_type":"c1","uid":1131070,"ip_address":"","ucode":"749BAD1834AC0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/42/3e/c1f76202.jpg","comment_is_top":false,"comment_ctime":1551431166,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1551431166","product_id":100006701,"comment_content":"hasMap 截取的putVa这部分源码不完整  ,源码 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; 现在的代码少了n","like_count":0},{"had_liked":false,"id":70708,"user_name":"江少","can_delete":false,"product_type":"c1","uid":1011384,"ip_address":"","ucode":"65168433D91B49","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJnsdQt6bQdHsfE33231sgDfQicRJLekuGLZmghUp0D9DPsOnN4LamhoquSu8S9rKXow9pgyE235xg/132","comment_is_top":false,"comment_ctime":1551167843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1551167843","product_id":100006701,"comment_content":"并发情况下的问题并没有聊啊，老师","like_count":0},{"had_liked":false,"id":68385,"user_name":"不忘初心","can_delete":false,"product_type":"c1","uid":1015494,"ip_address":"","ucode":"5B5F45564DDBE7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/c6/83684988.jpg","comment_is_top":false,"comment_ctime":1550492104,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1550492104","product_id":100006701,"comment_content":"remove()--&gt;如果桶原来是tree，删除元素后，数量小于一定值后又会退化成链表。","like_count":0},{"had_liked":false,"id":56590,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1546501210,"is_pvip":false,"replies":[{"id":"23308","content":"谢谢指出，开发环境用了最新版本的jdk；8的时候&lt;&gt;操作符还不能用在inner class里，这是JDK 9的特性","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1549803460,"ip_address":"","comment_id":56590,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1546501210","product_id":100006701,"comment_content":"jdk8 下 LinkedHashMapSample 示例的 new LinkedHashMap&lt;String, String&gt;(16, 0.75F, true)，&lt;&gt;的泛型要填上。","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":435134,"discussion_content":"谢谢指出，开发环境用了最新版本的jdk；8的时候&amp;lt;&amp;gt;操作符还不能用在inner class里，这是JDK 9的特性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1549803460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":56226,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1546408472,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1546408472","product_id":100006701,"comment_content":"老师你好。<br>有2个疑问。<br><br>（1）关于加载因子 查了一下资料，然后您帮我看一下，加载因子大小的影响我理解的是否正确。<br> <br>问题1：查询到的资料如下:<br><br>加载因子是表示Hsah表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.<br><br>冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小.<br><br>因此,必须在 &quot;冲突的机会&quot;与&quot;空间利用率&quot;之间寻找一种平衡与折衷. 这种平衡与折衷本质上是数据结构中有名的&quot;时-空&quot;矛盾的平衡与折衷.<br><br>---手动分割---<br><br>分析： 默认容量为16，加载因子0.75<br><br>（1）当加载因子大的时候为：0.875，此时我们有16*0.875=14个位置，可以填充数据，那么利用率确实高了，但是当我们数据即将达到临界的时候，再去填入新元素，此时hash值非常容易碰撞冲突，所以链表长度会越来越长。<br>（2）当加载因子小的时候为：0.625，此时我们有16*0.625-=10个位置，那么利用率低了，当我们计算hash的时候，碰撞相对来说，会小一些，但是其余的位置空闲，导致了浪费资源。<br><br>因此加载因子大小采用通用场景下的0.75. <br><br>引申问题：<br>  加载因子0.75 这个值是怎么计算的呢？<br><br><br> 问题2 ： jdk 1.8 内部，新增数据的时候，默认的就是链表法防止hash冲突的吧？<br>","like_count":0,"discussions":[{"author":{"id":2697700,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/LFJZ4x47rvShGhsePLIxc8EzdlBxAmVAIjJ2FQZ4NEpo8E4JCZQEOb2NIfOuiaQLL6Otkt7W3Rmu6Tv3AkgYdRA/132","nickname":"键盘上的魔术","note":"","ucode":"A731D721FB8D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553665,"discussion_content":"0.75是经验值，大了频繁hash冲突，小了频繁扩容，都会影响性能。设小了不单单浪费空间，频繁resize才是主要因素","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1646018032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":51174,"user_name":"木偶人King","can_delete":false,"product_type":"c1","uid":1028805,"ip_address":"","ucode":"0BDCA51E6F0B76","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b2/c5/6ae0be56.jpg","comment_is_top":false,"comment_ctime":1545125555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1545125555","product_id":100006701,"comment_content":"才发现有不少例子中都用到了1.9 的特性","like_count":0},{"had_liked":false,"id":49659,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1544750614,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1544750614","product_id":100006701,"comment_content":"很好，建议结合源码一块阅读，效果会更好。<br>内容相当丰富了，有些扩展必须自己课后补充才可以理解。<br>有同样的疑问❓<br>hashtable为什么设计成不支持null key和value呢？<br>知识密度过大，需要更多时间消化","like_count":0},{"had_liked":false,"id":32809,"user_name":"Linus","can_delete":false,"product_type":"c1","uid":1215909,"ip_address":"","ucode":"791F5DB48A0469","user_header":"https://static001.geekbang.org/account/avatar/00/12/8d/a5/5d2acc00.jpg","comment_is_top":false,"comment_ctime":1539698534,"is_pvip":false,"replies":[{"id":"11960","content":"不是一定，看是否有需求，例如师傅要更加value或者state来比较对象，是则实现equals；hashCode这是影响到你使用hash数据结构时；不是确定的要求，可以看一下比较特别的value-bssed类型，看特定语义导致的需求https:&#47;&#47;docs.oracle.com&#47;javase&#47;8&#47;docs&#47;api&#47;java&#47;lang&#47;doc-files&#47;ValueBased.html","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1539736631,"ip_address":"","comment_id":32809,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1539698534","product_id":100006701,"comment_content":"为什么hashcode与equals方法一定都要重写呢？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":426895,"discussion_content":"不是一定，看是否有需求，例如师傅要更加value或者state来比较对象，是则实现equals；hashCode这是影响到你使用hash数据结构时；不是确定的要求，可以看一下比较特别的value-bssed类型，看特定语义导致的需求https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1539736631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":25363,"user_name":"孟令伟","can_delete":false,"product_type":"c1","uid":1178374,"ip_address":"","ucode":"96848CA3223E4F","user_header":"https://static001.geekbang.org/account/avatar/00/11/fb/06/372120d1.jpg","comment_is_top":false,"comment_ctime":1537319360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1537319360","product_id":100006701,"comment_content":"hashmap影响因子为何设置为0.75，根本没讲，面试常遇到","like_count":0},{"had_liked":false,"id":24467,"user_name":"小豆子","can_delete":false,"product_type":"c1","uid":1221275,"ip_address":"","ucode":"F57A176ADB0571","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/9b/cd664e55.jpg","comment_is_top":false,"comment_ctime":1537056922,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1537056922","product_id":100006701,"comment_content":"杨老师，最近面试遇到这样一个问题面试官问：hashmap底层结构是什么？在我答了数组+链表以后他问我，数组里面存的是什么？请问数组里面存的是什么呢？","like_count":0,"discussions":[{"author":{"id":1113469,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fd/7d/a4bda9ce.jpg","nickname":"B 612 星球来客","note":"","ucode":"CBFB05B1F1B178","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310946,"discussion_content":"。。这不是存的是Entry么。。稍微看过源码也该知道吧。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602150483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1016533,"avatar":"","nickname":"April","note":"","ucode":"382C462BA054D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":36423,"discussion_content":"哈希值吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571375064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1583833,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/E3XKbwTv6WTssolgqZjZCkiazHgl2IdBYfwVfAcB7Ff3krsIQeBIBFQLQE1Kw91LFbl3lic2EzgdfNiciaYDlJlELA/132","nickname":"rike","note":"","ucode":"920AAD0BD9245C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1016533,"avatar":"","nickname":"April","note":"","ucode":"382C462BA054D8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":184070,"discussion_content":"个人理解是key的hash值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582544134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":36423,"ip_address":""},"score":184070,"extra":""}]}]},{"had_liked":false,"id":22070,"user_name":"李继武","can_delete":false,"product_type":"c1","uid":1192250,"ip_address":"","ucode":"FA1261D43D0091","user_header":"https://static001.geekbang.org/account/avatar/00/12/31/3a/206598a3.jpg","comment_is_top":false,"comment_ctime":1535469898,"is_pvip":false,"replies":[{"id":"8079","content":"这在哈希表里是一个意思吧","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1535722708,"ip_address":"","comment_id":22070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1535469898","product_id":100006701,"comment_content":"哈希碰撞是指key算出来的哈希值相同还是说根据哈希值得到的索引值相同","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":422986,"discussion_content":"这在哈希表里是一个意思吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1535722708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":21793,"user_name":"扬～","can_delete":false,"product_type":"c1","uid":1208163,"ip_address":"","ucode":"6FA7D8FE188341","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/63/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1535339100,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1535339100","product_id":100006701,"comment_content":"容量与桶的数量有什么关系吗","like_count":0},{"had_liked":false,"id":14724,"user_name":"t","can_delete":false,"product_type":"c1","uid":1153833,"ip_address":"","ucode":"84FA886A94B603","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/29/c50118cf.jpg","comment_is_top":false,"comment_ctime":1530620931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1530620931","product_id":100006701,"comment_content":"分析HashMap源码那一段是基于JDK8的，我对着JDK7看了半天……发现不对😂","like_count":0},{"had_liked":false,"id":13565,"user_name":"coolboy","can_delete":false,"product_type":"c1","uid":1160559,"ip_address":"","ucode":"248918FCC9E65D","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/6f/7c964414.jpg","comment_is_top":false,"comment_ctime":1529773386,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1529773386","product_id":100006701,"comment_content":"杨老师，那个LinkedhashMap例子，我现在改调用两次get(“Project1”)，但是project4 put后，把Preject1给删除了，按照不常访问的情况的话，不应该删除Project1呀，本地jdk1.8","like_count":0,"discussions":[{"author":{"id":1955253,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/d5/b5/1ba37129.jpg","nickname":"zero_宇","note":"","ucode":"27E77FAD77F3F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336230,"discussion_content":"调用父类的构造方法时、将 accessOrder 属性设置为 true、这个属性默认为 false、开启之后、移除的元素才是经常不访问的那个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608536168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11956,"user_name":"影随","can_delete":false,"product_type":"c1","uid":1088169,"ip_address":"","ucode":"48BC4CFCAD3C2F","user_header":"https://static001.geekbang.org/account/avatar/00/10/9a/a9/ae10f6cd.jpg","comment_is_top":false,"comment_ctime":1528463611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1528463611","product_id":100006701,"comment_content":"您的留言不能直接回复，我是11楼读者。我用的jdk版本是1.8.0。  报错的内容为: both methods have same ensure, yet neither overrides the other。<br><br>目前正在试着装10，9貌似已经被废弃了","like_count":0},{"had_liked":false,"id":11127,"user_name":"老实人Honey","can_delete":false,"product_type":"c1","uid":1080653,"ip_address":"","ucode":"EA4AB5C0C33090","user_header":"https://static001.geekbang.org/account/avatar/00/10/7d/4d/d98865b2.jpg","comment_is_top":false,"comment_ctime":1527866080,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1527866080","product_id":100006701,"comment_content":"load factor我觉得叫负载系数好那么一点点，系数有比值的意思，个人看法","like_count":0},{"had_liked":false,"id":10373,"user_name":"刘煜","can_delete":false,"product_type":"c1","uid":1130278,"ip_address":"","ucode":"3118EA6DB8A6DE","user_header":"https://static001.geekbang.org/account/avatar/00/11/3f/26/b8dd7c5d.jpg","comment_is_top":false,"comment_ctime":1527511518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527511518","product_id":100006701,"comment_content":"不懂红黑树","like_count":0},{"had_liked":false,"id":10195,"user_name":"爪哇夜未眠","can_delete":false,"product_type":"c1","uid":1006025,"ip_address":"","ucode":"BBEB80EB670770","user_header":"https://static001.geekbang.org/account/avatar/00/0f/59/c9/f44cb7f3.jpg","comment_is_top":false,"comment_ctime":1527341512,"is_pvip":false,"replies":[{"id":"3221","content":"才回来，倒时差，回复不及时；<br>链表短时访问看不出明显差异，但构建简单多了；<br>记得回答过了，这不是规定是通常建议，填充多了，冲突可能就大了，再说所谓调优总是有个前提、目标的，看具体情况","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527468732,"ip_address":"","comment_id":10195,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527341512","product_id":100006701,"comment_content":"同问：<br>请问老师，为什么不是一开始就树化，而是要等到一定程度再树化，链表一开始就是消耗查找性能啊？另外其实不太明白为什么是0.75的负载因子，如果是0.8或者0.9会有什么影响吗？毕竟已经开辟了相关内存空间<br>","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418387,"discussion_content":"才回来，倒时差，回复不及时；\n链表短时访问看不出明显差异，但构建简单多了；\n记得回答过了，这不是规定是通常建议，填充多了，冲突可能就大了，再说所谓调优总是有个前提、目标的，看具体情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527468732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9930,"user_name":"Key","can_delete":false,"product_type":"c1","uid":1130319,"ip_address":"","ucode":"E912F21286A2EF","user_header":"https://static001.geekbang.org/account/avatar/00/11/3f/4f/16c0f70d.jpg","comment_is_top":false,"comment_ctime":1527168856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527168856","product_id":100006701,"comment_content":"hashtable为什么不能有key和value为空的情况 一直搞不懂这个","like_count":0},{"had_liked":false,"id":9927,"user_name":"叶易","can_delete":false,"product_type":"c1","uid":1103445,"ip_address":"","ucode":"0983EA217ACF28","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/55/47e76936.jpg","comment_is_top":false,"comment_ctime":1527165278,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527165278","product_id":100006701,"comment_content":"hashMap里面再hash，综合高位与低位的特征是个很好的方法，值得借鉴","like_count":0},{"had_liked":false,"id":9924,"user_name":"鹤鸣","can_delete":false,"product_type":"c1","uid":1113118,"ip_address":"","ucode":"60660865470C35","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/1e/a06abc12.jpg","comment_is_top":false,"comment_ctime":1527162595,"is_pvip":false,"replies":[{"id":"3250","content":"非常感谢","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1527484283,"ip_address":"","comment_id":9924,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1527162595","product_id":100006701,"comment_content":"写的真好，感谢","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":418258,"discussion_content":"非常感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1527484283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":9838,"user_name":"昵称而已，何必执着","can_delete":false,"product_type":"c1","uid":1057139,"ip_address":"","ucode":"D8F0D534D7450F","user_header":"https://static001.geekbang.org/account/avatar/00/10/21/73/2da558bb.jpg","comment_is_top":false,"comment_ctime":1527123348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1527123348","product_id":100006701,"comment_content":"再hash，线性探测，线性平方探测！","like_count":0}]}