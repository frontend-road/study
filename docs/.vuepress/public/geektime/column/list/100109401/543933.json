{"id":543933,"title":"61 ｜RESTful Web Services（25）：如何重构DefaultResourceRouter中的Result结构？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式实现RESTful Web Services。</p><h2>回顾架构愿景与任务列表</h2><p>目前我们已经实现了ResourceRouter，和UriTemplate整体的架构愿景如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/yy/6c626153c86cd68fec66b5ce9d9cb1yy.jpg?wh=2284x1285\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/0b/36/0be0e96754f217b36d12e1edeb9ba936.jpg?wh=2284x1285\" alt=\"\"></p><p>目前的任务列表：</p><ul>\n<li>Resource/RootResource/ResourceMethod\n<ul>\n<li><s>从Path标注中获取UriTemplate</s>\n<ul>\n<li>如不存在Path标注，则抛出异常</li>\n</ul>\n</li>\n<li><s>在处理请求派分时，可以根据客户端提供的Http方法，选择对应的资源方法</s>\n<ul>\n<li><s>当请求与资源方法的Uri模版一致，且Http方法一致时，派分到该方法</s></li>\n<li><s>没有资源方法于请求的Uri和Http方法一致时，返回404</s></li>\n</ul>\n</li>\n<li>在处理请求派分时，可以支持多级子资源\n<ul>\n<li>当没有资源方法可以匹配请求时，选择最优匹配SubResourceLocater，通过它继续进行派分</li>\n<li>如果SubResourceLocator也无法找到满足的请求时，返回404</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul><p>代码为：</p><pre><code>package geektime.tdd.rest;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.ws.rs.HttpMethod;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.container.ResourceContext;\nimport jakarta.ws.rs.core.GenericEntity;\nimport jakarta.ws.rs.core.HttpHeaders;\nimport jakarta.ws.rs.core.Response;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\ninterface ResourceRouter {\n    OutboundResponse dispatch(HttpServletRequest request, ResourceContext resourceContext);\n    interface Resource {\n        Optional&lt;ResourceMethod&gt; match(UriTemplate.MatchResult result, String method, String[] mediaTypes, UriInfoBuilder builder);\n    }\n    interface RootResource extends Resource, UriHandler {\n    }\n    interface ResourceMethod extends UriHandler {\n        String getHttpMethod();\n        GenericEntity&lt;?&gt; call(ResourceContext resourceContext, UriInfoBuilder builder);\n    }\n    interface SubResourceLocator extends UriHandler {\n    }\n    interface UriHandler {\n        UriTemplate getUriTemplate();\n    }\n}\nclass DefaultResourceRouter implements ResourceRouter {\n    private Runtime runtime;\n    private List&lt;RootResource&gt; rootResources;\n    public DefaultResourceRouter(Runtime runtime, List&lt;RootResource&gt; rootResources) {\n        this.runtime = runtime;\n        this.rootResources = rootResources;\n    }\n    @Override\n    public OutboundResponse dispatch(HttpServletRequest request, ResourceContext resourceContext) {\n        String path = request.getServletPath();\n        UriInfoBuilder uri = runtime.createUriInfoBuilder(request);\n        Optional&lt;ResourceMethod&gt; method = rootResources.stream().map(resource -&gt; match(path, resource))\n                .filter(Result::isMatched).sorted().findFirst().flatMap(result -&gt; result.findResourceMethod(request, uri));\n        if (method.isEmpty()) return (OutboundResponse) Response.status(Response.Status.NOT_FOUND).build();\n        return (OutboundResponse) method.map(m -&gt; m.call(resourceContext, uri)).map(entity -&gt; Response.ok(entity).build())\n                .orElseGet(() -&gt; Response.noContent().build());\n    }\n    private Result match(String path, RootResource resource) {\n        return new Result(resource.getUriTemplate().match(path), resource);\n    }\n    record Result(Optional&lt;UriTemplate.MatchResult&gt; matched, RootResource resource) implements Comparable&lt;Result&gt; {\n        private boolean isMatched() {\n            return matched.isPresent();\n        }\n        @Override\n        public int compareTo(Result o) {\n            return matched.flatMap(x -&gt; o.matched.map(x::compareTo)).orElse(0);\n        }\n        private Optional&lt;ResourceMethod&gt; findResourceMethod(HttpServletRequest request, UriInfoBuilder uri) {\n            return matched.flatMap(result -&gt; resource.match(result, request.getMethod(),\n                    Collections.list(request.getHeaders(HttpHeaders.ACCEPT)).toArray(String[]::new), uri));\n        }\n    }\n}\nclass RootResourceClass implements ResourceRouter.RootResource {\n    private PathTemplate uriTemplate;\n    private Class&lt;?&gt; resourceClass;\n    private ResourceMethods resourceMethods;\n    public RootResourceClass(Class&lt;?&gt; resourceClass) {\n        this.resourceClass = resourceClass;\n        this.uriTemplate = new PathTemplate(resourceClass.getAnnotation(Path.class).value());\n        this.resourceMethods = new ResourceMethods(resourceClass.getMethods());\n    }\n    @Override\n    public Optional&lt;ResourceRouter.ResourceMethod&gt; match(UriTemplate.MatchResult result, String method, String[] mediaTypes, UriInfoBuilder builder) {\n        String remaining = Optional.ofNullable(result.getRemaining()).orElse(&quot;&quot;);\n        return resourceMethods.findResourceMethods(remaining, method);\n    }\n    @Override\n    public UriTemplate getUriTemplate() {\n        return uriTemplate;\n    }\n}\nclass SubResource implements ResourceRouter.Resource {\n    private Object subResource;\n    private ResourceMethods resourceMethods;\n    public SubResource(Object subResource) {\n        this.subResource = subResource;\n        this.resourceMethods = new ResourceMethods(subResource.getClass().getMethods());\n    }\n    @Override\n    public Optional&lt;ResourceRouter.ResourceMethod&gt; match(UriTemplate.MatchResult result, String method, String[] mediaTypes, UriInfoBuilder builder) {\n        String remaining = Optional.ofNullable(result.getRemaining()).orElse(&quot;&quot;);\n        return resourceMethods.findResourceMethods(remaining, method);\n    }\n}\nclass DefaultResourceMethod implements ResourceRouter.ResourceMethod {\n    private String httpMethod;\n    private UriTemplate uriTemplate;\n    private Method method;\n    public DefaultResourceMethod(Method method) {\n        this.method = method;\n        this.uriTemplate = new PathTemplate(Optional.ofNullable(method.getAnnotation(Path.class)).map(Path::value).orElse(&quot;&quot;));\n        this.httpMethod = Arrays.stream(method.getAnnotations()).filter(a -&gt; a.annotationType().isAnnotationPresent(HttpMethod.class))\n                .findFirst().get().annotationType().getAnnotation(HttpMethod.class).value();\n    }\n    @Override\n    public String getHttpMethod() {\n        return httpMethod;\n    }\n    @Override\n    public UriTemplate getUriTemplate() {\n        return uriTemplate;\n    }\n    @Override\n    public GenericEntity&lt;?&gt; call(ResourceContext resourceContext, UriInfoBuilder builder) {\n        return null;\n    }\n    @Override\n    public String toString() {\n        return method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName();\n    }\n}\nclass ResourceMethods {\n    private Map&lt;String, List&lt;ResourceRouter.ResourceMethod&gt;&gt; resourceMethods;\n    public ResourceMethods(Method[] methods) {\n        this.resourceMethods = getResourceMethods(methods);\n    }\n    private static Map&lt;String, List&lt;ResourceRouter.ResourceMethod&gt;&gt; getResourceMethods(Method[] methods) {\n        return Arrays.stream(methods).filter(m -&gt; Arrays.stream(m.getAnnotations())\n                        .anyMatch(a -&gt; a.annotationType().isAnnotationPresent(HttpMethod.class)))\n                .map(DefaultResourceMethod::new)\n                .collect(Collectors.groupingBy(ResourceRouter.ResourceMethod::getHttpMethod));\n    }\n    public Optional&lt;ResourceRouter.ResourceMethod&gt; findResourceMethods(String path, String method) {\n        return Optional.ofNullable(resourceMethods.get(method)).flatMap(methods -&gt; Result.match(path, methods, r -&gt; r.getRemaining() == null));\n    }\n}\nrecord Result&lt;T extends ResourceRouter.UriHandler&gt;\n        (Optional&lt;UriTemplate.MatchResult&gt; matched,\n         T handler, Function&lt;UriTemplate.MatchResult, Boolean&gt; matchFunction) implements Comparable&lt;Result&lt;T&gt;&gt; {\n    public static &lt;T extends ResourceRouter.UriHandler&gt; Optional&lt;T&gt; match(String path, List&lt;T&gt; handlers, Function&lt;UriTemplate.MatchResult, Boolean&gt; matchFunction) {\n        return handlers.stream().map(m -&gt; new Result&lt;&gt;(m.getUriTemplate().match(path), m, matchFunction))\n                .filter(Result::isMatched).sorted().findFirst().map(Result::handler);\n    }\n    public static &lt;T extends ResourceRouter.UriHandler&gt; Optional&lt;T&gt; match(String path, List&lt;T&gt; handlers) {\n        return match(path, handlers, r -&gt; true);\n    }\n    public boolean isMatched() {\n        return matched.map(matchFunction::apply).orElse(false);\n    }\n    @Override\n    public int compareTo(Result&lt;T&gt; o) {\n        return matched.flatMap(x -&gt; o.matched.map(x::compareTo)).orElse(0);\n    }\n}\nclass SubResourceLocators {\n    private final List&lt;ResourceRouter.SubResourceLocator&gt; subResourceLocators;\n    public SubResourceLocators(Method[] methods) {\n        subResourceLocators = Arrays.stream(methods).filter(m -&gt; m.isAnnotationPresent(Path.class) &amp;&amp;\n                        Arrays.stream(m.getAnnotations()).noneMatch(a -&gt; a.annotationType().isAnnotationPresent(HttpMethod.class)))\n                .map((Function&lt;Method, ResourceRouter.SubResourceLocator&gt;) DefaultSubResourceLocator::new).toList();\n    }\n    public Optional&lt;ResourceRouter.SubResourceLocator&gt; findSubResource(String path) {\n        return Result.match(path, subResourceLocators);\n    }\n    static class DefaultSubResourceLocator implements ResourceRouter.SubResourceLocator {\n        private PathTemplate uriTemplate;\n        private Method method;\n        public DefaultSubResourceLocator(Method method) {\n            this.method = method;\n            this.uriTemplate = new PathTemplate(method.getAnnotation(Path.class).value());\n        }\n        @Override\n        public UriTemplate getUriTemplate() {\n            return uriTemplate;\n        }\n        @Override\n        public String toString() {\n            return method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName();\n        }\n    }\n}\n</code></pre><h2>视频演示</h2><p>进入今天的环节：</p><p><video poster=\"https://media001.geekbang.org/c6dd662fef4c4d36a1d941b6d42df768/snapshots/a2ae062ebb6f435cb7e19198be742a31-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/6299e09b-18234c3ccf7-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/6f88a271ef2a4c4487c0d18c1ea6b862/45d10d1dbcab41eeb1fdab18f8c1844a-cef9ea65bcb8ae84739f5492723148f5-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>如何继续划分ResourceLocator的任务？</p><p>欢迎把你的想法分享在留言区，也欢迎把你的项目代码分享出来。相信经过你的思考与实操，学习效果会更好！</p><!-- [[[read_end]]] -->","comments":[{"had_liked":false,"id":356735,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1510910,"ip_address":"上海","ucode":"FC7849B6F0FA9F","user_header":"https://static001.geekbang.org/account/avatar/00/17/0d/fe/4e5ba578.jpg","comment_is_top":false,"comment_ctime":1662540150,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"函数式接口有点难懂","like_count":0}]}