{"id":549015,"title":"65｜RESTful Web Services（29）：后续任务将要如何划分与实现？","content":"<p>你好，我是徐昊。今天我们继续使用TDD的方式实现RESTful Web Services。</p><h2>回顾架构愿景与任务列表</h2><p>目前我们已经实现了ResourceRouter，和UriTemplate整体的架构愿景如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/bd/c1a8d4b80fcf2c009a448d996594b6bd.jpg?wh=2284x1264\" alt=\"\"><br>\n<img src=\"https://static001.geekbang.org/resource/image/fd/06/fd32fcbe73cb3d406f7473a0798a8d06.jpg?wh=2284x1285\" alt=\"\"></p><p>目前的任务列表：</p><ul>\n<li><s>Resource/RootResource/ResourceMethod</s>\n<ul>\n<li><s>从Path标注中获取UriTemplate</s>\n<ul>\n<li>如不存在Path标注，则抛出异常</li>\n</ul>\n</li>\n<li><s>在处理请求派分时，可以根据客户端提供的Http方法，选择对应的资源方法</s>\n<ul>\n<li><s>当请求与资源方法的Uri模版一致，且Http方法一致时，派分到该方法</s></li>\n<li><s>没有资源方法于请求的Uri和Http方法一致时，返回404</s></li>\n</ul>\n</li>\n<li><s>在处理请求派分时，可以支持多级子资源</s>\n<ul>\n<li><s>当没有资源方法可以匹配请求时，选择最优匹配SubResourceLocater，通过它继续进行派分</s></li>\n<li><s>如果SubResourceLocator也无法找到满足的请求时，返回404</s></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul><p>代码为：</p><pre><code>package geektime.tdd.rest;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.ws.rs.HttpMethod;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.container.ResourceContext;\nimport jakarta.ws.rs.core.GenericEntity;\nimport jakarta.ws.rs.core.HttpHeaders;\nimport jakarta.ws.rs.core.Response;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\ninterface ResourceRouter {\n    OutboundResponse dispatch(HttpServletRequest request, ResourceContext resourceContext);\n    interface Resource extends UriHandler {\n        Optional&lt;ResourceMethod&gt; match(UriTemplate.MatchResult result, String httpMethod, String[] mediaTypes, ResourceContext resourceContext, UriInfoBuilder builder);\n    }\n    interface ResourceMethod extends UriHandler {\n        String getHttpMethod();\n        GenericEntity&lt;?&gt; call(ResourceContext resourceContext, UriInfoBuilder builder);\n    }\n}\nclass DefaultResourceRouter implements ResourceRouter {\n    private Runtime runtime;\n    private List&lt;Resource&gt; rootResources;\n    public DefaultResourceRouter(Runtime runtime, List&lt;Resource&gt; rootResources) {\n        this.runtime = runtime;\n        this.rootResources = rootResources;\n    }\n    @Override\n    public OutboundResponse dispatch(HttpServletRequest request, ResourceContext resourceContext) {\n        String path = request.getServletPath();\n        UriInfoBuilder uri = runtime.createUriInfoBuilder(request);\n        Optional&lt;ResourceMethod&gt; method = UriHandlers.mapMatched(path, rootResources, (result, resource) -&gt; findResourceMethod(request, resourceContext, uri, result, resource));\n        if (method.isEmpty()) return (OutboundResponse) Response.status(Response.Status.NOT_FOUND).build();\n        return (OutboundResponse) method.map(m -&gt; m.call(resourceContext, uri)).map(entity -&gt; Response.ok(entity).build())\n                .orElseGet(() -&gt; Response.noContent().build());\n    }\n    private Optional&lt;ResourceMethod&gt; findResourceMethod(HttpServletRequest request, ResourceContext resourceContext, UriInfoBuilder uri, Optional&lt;UriTemplate.MatchResult&gt; matched, Resource handler) {\n        return handler.match(matched.get(), request.getMethod(),\n                Collections.list(request.getHeaders(HttpHeaders.ACCEPT)).toArray(String[]::new), resourceContext, uri);\n    }\n}\n\n\nclass DefaultResourceMethod implements ResourceRouter.ResourceMethod {\n    private String httpMethod;\n    private UriTemplate uriTemplate;\n    private Method method;\n    public DefaultResourceMethod(Method method) {\n        this.method = method;\n        this.uriTemplate = new PathTemplate(Optional.ofNullable(method.getAnnotation(Path.class)).map(Path::value).orElse(&quot;&quot;));\n        this.httpMethod = Arrays.stream(method.getAnnotations()).filter(a -&gt; a.annotationType().isAnnotationPresent(HttpMethod.class))\n                .findFirst().get().annotationType().getAnnotation(HttpMethod.class).value();\n    }\n    @Override\n    public String getHttpMethod() {\n        return httpMethod;\n    }\n    @Override\n    public UriTemplate getUriTemplate() {\n        return uriTemplate;\n    }\n    @Override\n    public GenericEntity&lt;?&gt; call(ResourceContext resourceContext, UriInfoBuilder builder) {\n        return null;\n    }\n    @Override\n    public String toString() {\n        return method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName();\n    }\n}\nclass   ResourceMethods {\n    private Map&lt;String, List&lt;ResourceRouter.ResourceMethod&gt;&gt; resourceMethods;\n    public ResourceMethods(Method[] methods) {\n        this.resourceMethods = getResourceMethods(methods);\n    }\n    private static Map&lt;String, List&lt;ResourceRouter.ResourceMethod&gt;&gt; getResourceMethods(Method[] methods) {\n        return Arrays.stream(methods).filter(m -&gt; Arrays.stream(m.getAnnotations())\n                        .anyMatch(a -&gt; a.annotationType().isAnnotationPresent(HttpMethod.class)))\n                .map(DefaultResourceMethod::new)\n                .collect(Collectors.groupingBy(ResourceRouter.ResourceMethod::getHttpMethod));\n    }\n    public Optional&lt;ResourceRouter.ResourceMethod&gt; findResourceMethods(String path, String method) {\n        return Optional.ofNullable(resourceMethods.get(method)).flatMap(methods -&gt; UriHandlers.match(path, methods, r -&gt; r.getRemaining() == null));\n    }\n}\nclass SubResourceLocators {\n    private final List&lt;ResourceRouter.Resource&gt; subResourceLocators;\n    public SubResourceLocators(Method[] methods) {\n        subResourceLocators = Arrays.stream(methods).filter(m -&gt; m.isAnnotationPresent(Path.class) &amp;&amp;\n                        Arrays.stream(m.getAnnotations()).noneMatch(a -&gt; a.annotationType().isAnnotationPresent(HttpMethod.class)))\n                .map((Function&lt;Method, ResourceRouter.Resource&gt;) SubResourceLocator::new).toList();\n    }\n    public Optional&lt;ResourceRouter.ResourceMethod&gt; findSubResourceMethods(String path, String method, String[] mediaTypes, ResourceContext resourceContext, UriInfoBuilder builder) {\n        return UriHandlers.mapMatched(path, subResourceLocators, (result, locator) -&gt; locator.match(result.get(), method, mediaTypes, resourceContext, builder));\n    }\n    static class SubResourceLocator implements ResourceRouter.Resource {\n        private PathTemplate uriTemplate;\n        private Method method;\n        public SubResourceLocator(Method method) {\n            this.method = method;\n            this.uriTemplate = new PathTemplate(method.getAnnotation(Path.class).value());\n        }\n        @Override\n        public UriTemplate getUriTemplate() {\n            return uriTemplate;\n        }\n        @Override\n        public String toString() {\n            return method.getDeclaringClass().getSimpleName() + &quot;.&quot; + method.getName();\n        }\n        @Override\n        public Optional&lt;ResourceRouter.ResourceMethod&gt; match(UriTemplate.MatchResult result, String httpMethod, String[] mediaTypes, ResourceContext resourceContext, UriInfoBuilder builder) {\n            Object resource = builder.getLastMatchedResource();\n            try {\n                Object subResource = method.invoke(resource);\n                return new ResourceHandler(subResource, uriTemplate).match(result, httpMethod, mediaTypes, resourceContext, builder);\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}\nclass ResourceHandler implements ResourceRouter.Resource {\n    private UriTemplate uriTemplate;\n    private ResourceMethods resourceMethods;\n    private SubResourceLocators subResourceLocators;\n    private Function&lt;ResourceContext, Object&gt; resource;\n\n\n    public ResourceHandler(Class&lt;?&gt; resourceClass) {\n        this(resourceClass, new PathTemplate(getTemplate(resourceClass)), rc -&gt; rc.getResource(resourceClass));\n    }\n    private static String getTemplate(Class&lt;?&gt; resourceClass) {\n        if (!resourceClass.isAnnotationPresent(Path.class)) throw new IllegalArgumentException();\n        return resourceClass.getAnnotation(Path.class).value();\n    }\n    public ResourceHandler(Object resource, UriTemplate uriTemplate) {\n        this(resource.getClass(), uriTemplate, rc -&gt; resource);\n    }\n    private ResourceHandler(Class&lt;?&gt; resourceClass, UriTemplate uriTemplate, Function&lt;ResourceContext, Object&gt; resource) {\n        this.uriTemplate = uriTemplate;\n        this.resourceMethods = new ResourceMethods(resourceClass.getMethods());\n        this.subResourceLocators = new SubResourceLocators(resourceClass.getMethods());\n        this.resource = resource;\n    }\n    @Override\n    public Optional&lt;ResourceRouter.ResourceMethod&gt; match(UriTemplate.MatchResult result, String httpMethod, String[] mediaTypes, ResourceContext resourceContext, UriInfoBuilder builder) {\n        builder.addMatchedResource(resource.apply(resourceContext));\n        String remaining = Optional.ofNullable(result.getRemaining()).orElse(&quot;&quot;);\n        return resourceMethods.findResourceMethods(remaining, httpMethod)\n                .or(() -&gt; subResourceLocators.findSubResourceMethods(remaining, httpMethod, mediaTypes, resourceContext, builder));\n    }\n    @Override\n    public UriTemplate getUriTemplate() {\n        return uriTemplate;\n    }\n}\n</code></pre><h2>视频演示</h2><p>进入今天的环节：</p><p><video poster=\"https://media001.geekbang.org/9323795c1d2d4cdc916515eb264422dc/snapshots/a0ac5b4f527e43ecb482c4ebb43a0443-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/154a7746-18280dd4008-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/0d4e064a94e54186a3a8dfb7c07a4190/0b6af1e09ae54532860e48d9a0f6bf69-9bf66bad6357e88492dc69670f90e753-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>今天的思考题有两道，请选择你最有感触的一道来回答。</p><ol>\n<li>学习到现在，你有向其他朋友或同事推荐过TDD吗？成功还是失败了？如果失败了，那么在你看来可能的原因是什么呢？</li>\n<li>如何实现head方法不去调用get的内容？</li>\n</ol><!-- [[[read_end]]] --><p>欢迎把你的思考或想法分享在留言区，咱们下节课再见！</p>","neighbors":{"left":{"article_title":"64｜RESTful Web Services（28）：如何重构Resource、SubResource等接口与实现？","id":545235},"right":{"article_title":"66｜RESTful Web Services（30）：什么情况下应该使用行为验证？","id":549017}},"comments":[{"had_liked":false,"id":355045,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"浙江","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1661005594,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"推荐过，基本失败了，简单介绍一下我的想法：\n1、对通过跳槽增加收入没有直接帮助：招聘信息中用“TDD”搜索不到结果，用“设计模式”能搜到很多信息，那为什么不去学设计模式？\n2、大多数情况下只要代码能运行就可以，至于功能扩展那可是要另算工时的！\n3、要写出对测试友好的代码太难，不仅要理解基本的设计原则，还要能运用在日常的开发中。比学习算法还难！《算法图解》+ 极客时间 ｜ 数据结构与算法之美 + 极客时间 ｜ 算法训练营（按覃超老师的“五毒法”刷完200道针对各种常用算法的练习题），这一套下来基本可以掌握针对几类特定问题的解题思路。\n算法好比小朋友的看图说话：根据四季选合适的衣服，根据常识选就行；TDD好比当你遇到不同的小姐姐，为她推荐穿着搭配：既要符合季节，又要时尚靓丽、或古朴大方、或可御可甜……","like_count":2},{"had_liked":false,"id":357314,"user_name":"Jason","can_delete":false,"product_type":"c1","uid":1510910,"ip_address":"上海","ucode":"FC7849B6F0FA9F","user_header":"https://static001.geekbang.org/account/avatar/00/17/0d/fe/4e5ba578.jpg","comment_is_top":false,"comment_ctime":1663150823,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"推荐过，大家对TDD还是比较认可的，只是对如何落地到项目的开发中还有很多疑问，毕竟实际项目有很多难点。\n比如可能是在一个遗留系统中做维护工作，大多数feature都是修修补补，这种情况下重构比用TDD开发新功能用的更多。\n或者是做前端工作开发任务都和界面相关，用TDD些业务逻辑的机会比较少。\n或者项目管理人员没有意识到代码质量的重要性，只是希望尽快的交付功能，然后有很多bug再加班改。","like_count":1}]}