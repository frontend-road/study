{"id":399307,"title":"26 | IAM项目是如何设计和实现访问认证功能的？","content":"<p>你好，我是孔令飞。</p><p>上一讲，我们学习了应用认证常用的四种方式：Basic、Digest、OAuth、Bearer。这一讲，我们再来看下IAM项目是如何设计和实现认证功能的。</p><p>IAM项目用到了Basic认证和Bearer认证。其中，Basic认证用在前端登陆的场景，Bearer认证用在调用后端API服务的场景下。</p><p>接下来，我们先来看下IAM项目认证功能的整体设计思路。</p><h2>如何设计IAM项目的认证功能？</h2><p>在认证功能开发之前，我们要根据需求，认真考虑下如何设计认证功能，并在设计阶段通过技术评审。那么我们先来看下，如何设计IAM项目的认证功能。</p><p>首先，我们要<strong>梳理清楚认证功能的使用场景和需求</strong>。</p><ul>\n<li>IAM项目的iam-apiserver服务，提供了IAM系统的管理流功能接口，它的客户端可以是前端（这里也叫控制台），也可以是App端。</li>\n<li>为了方便用户在Linux系统下调用，IAM项目还提供了iamctl命令行工具。</li>\n<li>为了支持在第三方代码中调用iam-apiserver提供的API接口，还支持了API调用。</li>\n<li>为了提高用户在代码中调用API接口的效率，IAM项目提供了Go SDK。</li>\n</ul><p>可以看到，iam-apiserver有很多客户端，每种客户端适用的认证方式是有区别的。</p><!-- [[[read_end]]] --><p>控制台、App端需要登录系统，所以需要使用<code>用户名：密码</code>这种认证方式，也即Basic认证。iamctl、API调用、Go SDK因为可以不用登录系统，所以可以采用更安全的认证方式：Bearer认证。同时，Basic认证作为iam-apiserver已经集成的认证方式，仍然可以供iamctl、API调用、Go SDK使用。</p><p>这里有个地方需要注意：如果iam-apiserver采用Bearer Token的认证方式，目前最受欢迎的Token格式是JWT Token。而JWT Token需要密钥（后面统一用secretKey来指代），因此需要在iam-apiserver服务中为每个用户维护一个密钥，这样会增加开发和维护成本。</p><p>业界有一个更好的实现方式：将iam-apiserver提供的API接口注册到API网关中，通过API网关中的Token认证功能，来实现对iam-apiserver API接口的认证。有很多API网关可供选择，例如腾讯云API网关、Tyk、Kong等。</p><p>这里需要你注意：通过iam-apiserver创建的密钥对是提供给iam-authz-server使用的。</p><p>另外，我们还需要调用iam-authz-server提供的RESTful API接口：<code>/v1/authz</code>，来进行资源授权。API调用比较适合采用的认证方式是Bearer认证。</p><p>当然，<code>/v1/authz</code>也可以直接注册到API网关中。在实际的Go项目开发中，也是我推荐的一种方式。但在这里，为了展示实现Bearer认证的过程，iam-authz-server自己实现了Bearer认证。讲到iam-authz-server Bearer认证实现的时候，我会详细介绍这一点。</p><p>Basic认证需要用户名和密码，Bearer认证则需要密钥，所以iam-apiserver需要将用户名/密码、密钥等信息保存在后端的MySQL中，持久存储起来。</p><p>在进行认证的时候，需要获取密码或密钥进行反加密，这就需要查询密码或密钥。查询密码或密钥有两种方式。一种是在请求到达时查询数据库。因为数据库的查询操作延时高，会导致API接口延时较高，所以不太适合用在数据流组件中。另外一种是将密码或密钥缓存在内存中，这样请求到来时，就可以直接从内存中查询，从而提升查询速度，提高接口性能。</p><p>但是，将密码或密钥缓存在内存中时，就要考虑内存和数据库的数据一致性，这会增加代码实现的复杂度。因为管控流组件对性能延时要求不那么敏感，而数据流组件则一定要实现非常高的接口性能，所以iam-apiserver在请求到来时查询数据库，而iam-authz-server则将密钥信息缓存在内存中。</p><p>那在这里，可以总结出一张IAM项目的认证设计图：</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/b6/7eed8e2364d358a8483c671d972fd2b6.jpg?wh=2248x1094\" alt=\"\"></p><p>另外，为了将控制流和数据流区分开来，密钥的CURD操作也放在了iam-apiserver中，但是iam-authz-server需要用到这些密钥信息。为了解决这个问题，目前的做法是：</p><ul>\n<li>iam-authz-server通过gRPC API请求iam-apiserver，获取所有的密钥信息；</li>\n<li>当iam-apiserver有密钥更新时，会Pub一条消息到Redis Channel中。因为iam-authz-server订阅了同一个Redis Channel，iam-authz-searver监听到channel有新消息时，会获取、解析消息，并更新它缓存的密钥信息。这样，我们就能确保iam-authz-server内存中缓存的密钥和iam-apiserver中的密钥保持一致。</li>\n</ul><p>学到这里，你可能会问：将所有密钥都缓存在iam-authz-server中，那岂不是要占用很大的内存？别担心，这个问题我也想过，并且替你计算好了：8G的内存大概能保存约8千万个密钥信息，完全够用。后期不够用的话，可以加大内存。</p><p>不过这里还是有个小缺陷：如果Redis down掉，或者出现网络抖动，可能会造成iam-apiserver中和iam-authz-server内存中保存的密钥数据不一致，但这不妨碍我们学习认证功能的设计和实现。至于如何保证缓存系统的数据一致性，我会在新一期的特别放送里专门介绍下。</p><p>最后注意一点：Basic 认证请求和 Bearer 认证请求都可能被截获并重放。所以，为了确保Basic认证和Bearer认证的安全性，<strong>和服务端通信时都需要配合使用HTTPS协议</strong>。</p><h2>IAM项目是如何实现Basic认证的？</h2><p>我们已经知道，IAM项目中主要用了Basic 和 Bearer 这两种认证方式。我们要支持Basic认证和Bearer认证，并根据需要选择不同的认证方式，这很容易让我们想到使用设计模式中的策略模式来实现。所以，在IAM项目中，我将每一种认证方式都视作一个策略，通过选择不同的策略，来使用不同的认证方法。</p><p>IAM项目实现了如下策略：</p><ul>\n<li><a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/pkg/middleware/auth/auto.go\">auto策略</a>：该策略会根据HTTP头<code>Authorization: Basic XX.YY.ZZ</code>和<code>Authorization: Bearer XX.YY.ZZ</code>自动选择使用Basic认证还是Bearer认证。</li>\n<li><a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/pkg/middleware/auth/basic.go\">basic策略</a>：该策略实现了Basic认证。</li>\n<li><a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/pkg/middleware/auth/jwt.go\">jwt策略</a>：该策略实现了Bearer认证，JWT是Bearer认证的具体实现。</li>\n<li><a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/pkg/middleware/auth/cache.go\">cache策略</a>：该策略其实是一个Bearer认证的实现，Token采用了JWT格式，因为Token中的密钥ID是从内存中获取的，所以叫Cache认证。这一点后面会详细介绍。</li>\n</ul><p>iam-apiserver通过创建需要的认证策略，并加载到需要认证的API路由上，来实现API认证。具体代码如下：</p><pre><code>jwtStrategy, _ := newJWTAuth().(auth.JWTStrategy)\ng.POST(&quot;/login&quot;, jwtStrategy.LoginHandler)\ng.POST(&quot;/logout&quot;, jwtStrategy.LogoutHandler)\n// Refresh time can be longer than token timeout\ng.POST(&quot;/refresh&quot;, jwtStrategy.RefreshHandler)\n</code></pre><p>上述代码中，我们通过<a href=\"https://github.com/marmotedu/iam/blob/75b978b722f0af3d6aefece3f9668269be3f5b2e/internal/apiserver/auth.go#L59\">newJWTAuth</a>函数创建了<code>auth.JWTStrategy</code>类型的变量，该变量包含了一些认证相关函数。</p><ul>\n<li>LoginHandler：实现了Basic认证，完成登陆认证。</li>\n<li>RefreshHandler：重新刷新Token的过期时间。</li>\n<li>LogoutHandler：用户注销时调用。登陆成功后，如果在Cookie中设置了认证相关的信息，执行LogoutHandler则会清空这些信息。</li>\n</ul><p>下面，我来分别介绍下LoginHandler、RefreshHandler和LogoutHandler。</p><ol>\n<li>LoginHandler</li>\n</ol><p>这里，我们来看下LoginHandler Gin中间件，该函数定义位于<code>github.com/appleboy/gin-jwt</code>包的<a href=\"https://github.com/appleboy/gin-jwt/blob/v2.6.4/auth_jwt.go#L431\">auth_jwt.go</a>文件中。</p><pre><code>func (mw *GinJWTMiddleware) LoginHandler(c *gin.Context) {\n\tif mw.Authenticator == nil {\n\t\tmw.unauthorized(c, http.StatusInternalServerError, mw.HTTPStatusMessageFunc(ErrMissingAuthenticatorFunc, c))\n\t\treturn\n\t}\n\n\tdata, err := mw.Authenticator(c)\n\n\tif err != nil {\n\t\tmw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(err, c))\n\t\treturn\n\t}\n\n\t// Create the token\n\ttoken := jwt.New(jwt.GetSigningMethod(mw.SigningAlgorithm))\n\tclaims := token.Claims.(jwt.MapClaims)\n\n\tif mw.PayloadFunc != nil {\n\t\tfor key, value := range mw.PayloadFunc(data) {\n\t\t\tclaims[key] = value\n\t\t}\n\t}\n\n\texpire := mw.TimeFunc().Add(mw.Timeout)\n\tclaims[&quot;exp&quot;] = expire.Unix()\n\tclaims[&quot;orig_iat&quot;] = mw.TimeFunc().Unix()\n\ttokenString, err := mw.signedString(token)\n\n\tif err != nil {\n\t\tmw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(ErrFailedTokenCreation, c))\n\t\treturn\n\t}\n\n\t// set cookie\n\tif mw.SendCookie {\n\t\texpireCookie := mw.TimeFunc().Add(mw.CookieMaxAge)\n\t\tmaxage := int(expireCookie.Unix() - mw.TimeFunc().Unix())\n\n\t\tif mw.CookieSameSite != 0 {\n\t\t\tc.SetSameSite(mw.CookieSameSite)\n\t\t}\n\n\t\tc.SetCookie(\n\t\t\tmw.CookieName,\n\t\t\ttokenString,\n\t\t\tmaxage,\n\t\t\t&quot;/&quot;,\n\t\t\tmw.CookieDomain,\n\t\t\tmw.SecureCookie,\n\t\t\tmw.CookieHTTPOnly,\n\t\t)\n\t}\n\n\tmw.LoginResponse(c, http.StatusOK, tokenString, expire)\n}\n</code></pre><p>从LoginHandler函数的代码实现中，我们可以知道，LoginHandler函数会执行<code>Authenticator</code>函数，来完成Basic认证。如果认证通过，则会签发JWT Token，并执行 <code>PayloadFunc</code>函数设置Token Payload。如果我们设置了 <code>SendCookie=true</code> ，还会在Cookie中添加认证相关的信息，例如 Token、Token的生命周期等，最后执行 <code>LoginResponse</code> 方法返回Token和Token的过期时间。</p><p><code>Authenticator</code>、<code>PayloadFunc</code>、<code>LoginResponse</code>这三个函数，是我们在创建JWT认证策略时指定的。下面我来分别介绍下。</p><p>先来看下<a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/apiserver/auth.go#L97\">Authenticator</a>函数。Authenticator函数从HTTP Authorization Header中获取用户名和密码，并校验密码是否合法。</p><pre><code>func authenticator() func(c *gin.Context) (interface{}, error) {\n\treturn func(c *gin.Context) (interface{}, error) {\n\t\tvar login loginInfo\n\t\tvar err error\n\n\t\t// support header and body both\n\t\tif c.Request.Header.Get(&quot;Authorization&quot;) != &quot;&quot; {\n\t\t\tlogin, err = parseWithHeader(c)\n\t\t} else {\n\t\t\tlogin, err = parseWithBody(c)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn &quot;&quot;, jwt.ErrFailedAuthentication\n\t\t}\n\n\t\t// Get the user information by the login username.\n\t\tuser, err := store.Client().Users().Get(c, login.Username, metav1.GetOptions{})\n\t\tif err != nil {\n\t\t\tlog.Errorf(&quot;get user information failed: %s&quot;, err.Error())\n\n\t\t\treturn &quot;&quot;, jwt.ErrFailedAuthentication\n\t\t}\n\n\t\t// Compare the login password with the user password.\n\t\tif err := user.Compare(login.Password); err != nil {\n\t\t\treturn &quot;&quot;, jwt.ErrFailedAuthentication\n\t\t}\n\n\t\treturn user, nil\n\t}\n}\n</code></pre><p><code>Authenticator</code>函数需要获取用户名和密码。它首先会判断是否有<code>Authorization</code>请求头，如果有，则调用<code>parseWithHeader</code>函数获取用户名和密码，否则调用<code>parseWithBody</code>从Body中获取用户名和密码。如果都获取失败，则返回认证失败错误。</p><p>所以，IAM项目的Basic支持以下两种请求方式：</p><pre><code>$ curl -XPOST -H&quot;Authorization: Basic YWRtaW46QWRtaW5AMjAyMQ==&quot; http://127.0.0.1:8080/login # 用户名:密码通过base64加码后，通过HTTP Authorization Header进行传递，因为密码非明文，建议使用这种方式。\n$ curl -s -XPOST -H'Content-Type: application/json' -d'{&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;Admin@2021&quot;}' http://127.0.0.1:8080/login # 用户名和密码在HTTP Body中传递，因为密码是明文，所以这里不建议实际开发中，使用这种方式。\n</code></pre><p>这里，我们来看下 <code>parseWithHeader</code> 是如何获取用户名和密码的。假设我们的请求为：</p><pre><code>$ curl -XPOST -H&quot;Authorization: Basic YWRtaW46QWRtaW5AMjAyMQ==&quot; http://127.0.0.1:8080/login\n</code></pre><p>其中，<code>YWRtaW46QWRtaW5AMjAyMQ==</code>值由以下命令生成：</p><pre><code>$ echo -n 'admin:Admin@2021'|base64\nYWRtaW46QWRtaW5AMjAyMQ==\n</code></pre><p><code>parseWithHeader</code>实际上执行的是上述命令的逆向步骤：</p><ol>\n<li>获取<code>Authorization</code>头的值，并调用strings.SplitN函数，获取一个切片变量auth，其值为 <code>[\"Basic\",\"YWRtaW46QWRtaW5AMjAyMQ==\"]</code> 。</li>\n<li>将<code>YWRtaW46QWRtaW5AMjAyMQ==</code>进行base64解码，得到<code>admin:Admin@2021</code>。</li>\n<li>调用<code>strings.SplitN</code>函数获取 <code>admin:Admin@2021</code> ，得到用户名为<code>admin</code>，密码为<code>Admin@2021</code>。</li>\n</ol><p><code>parseWithBody</code>则是调用了Gin的<code>ShouldBindJSON</code>函数，来从Body中解析出用户名和密码。</p><p>获取到用户名和密码之后，程序会从数据库中查询出该用户对应的加密后的密码，这里我们假设是<code>xxxx</code>。最后<code>authenticator</code>函数调用<code>user.Compare</code>来判断 <code>xxxx</code> 是否和通过<code>user.Compare</code>加密后的字符串相匹配，如果匹配则认证成功，否则返回认证失败。</p><p>再来看下<code>PayloadFunc</code>函数：</p><pre><code>func payloadFunc() func(data interface{}) jwt.MapClaims {\n    return func(data interface{}) jwt.MapClaims {\n        claims := jwt.MapClaims{\n            &quot;iss&quot;: APIServerIssuer,\n            &quot;aud&quot;: APIServerAudience,\n        }\n        if u, ok := data.(*v1.User); ok {\n            claims[jwt.IdentityKey] = u.Name\n            claims[&quot;sub&quot;] = u.Name\n        }\n\n        return claims\n    }\n}\n</code></pre><p>PayloadFunc函数会设置JWT Token中Payload部分的 iss、aud、sub、identity字段，供后面使用。</p><p>再来看下我们刚才说的第三个函数，LoginResponse函数：</p><pre><code>func loginResponse() func(c *gin.Context, code int, token string, expire time.Time) {\n    return func(c *gin.Context, code int, token string, expire time.Time) {\n        c.JSON(http.StatusOK, gin.H{\n            &quot;token&quot;:  token,\n            &quot;expire&quot;: expire.Format(time.RFC3339),\n        })\n    }\n}\n</code></pre><p>该函数用来在Basic认证成功之后，返回Token和Token的过期时间给调用者：</p><pre><code>$ curl -XPOST -H&quot;Authorization: Basic YWRtaW46QWRtaW5AMjAyMQ==&quot; http://127.0.0.1:8080/login\n{&quot;expire&quot;:&quot;2021-09-29T01:38:49+08:00&quot;,&quot;token&quot;:&quot;XX.YY.ZZ&quot;}\n</code></pre><p>登陆成功后，iam-apiserver会返回Token和Token的过期时间，前端可以将这些信息缓存在Cookie中或LocalStorage中，之后的请求都可以使用Token来进行认证。使用Token进行认证，不仅能够提高认证的安全性，还能够避免查询数据库，从而提高认证效率。</p><ol start=\"2\">\n<li>RefreshHandler</li>\n</ol><p><code>RefreshHandler</code>函数会先执行Bearer认证，如果认证通过，则会重新签发Token。</p><ol start=\"3\">\n<li>LogoutHandler</li>\n</ol><p>最后，来看下<code>LogoutHandler</code>函数：</p><pre><code>func (mw *GinJWTMiddleware) LogoutHandler(c *gin.Context) {\n    // delete auth cookie\n    if mw.SendCookie {\n        if mw.CookieSameSite != 0 {\n            c.SetSameSite(mw.CookieSameSite)\n        }\n\n        c.SetCookie(\n            mw.CookieName,\n            &quot;&quot;,\n            -1,\n            &quot;/&quot;,\n            mw.CookieDomain,\n            mw.SecureCookie,\n            mw.CookieHTTPOnly,\n        )\n    }\n\n    mw.LogoutResponse(c, http.StatusOK)\n}\n</code></pre><p>可以看到，LogoutHandler其实是用来清空Cookie中Bearer认证相关信息的。</p><p>最后，我们来做个总结：Basic认证通过用户名和密码来进行认证，通常用在登陆接口/login中。用户登陆成功后，会返回JWT Token，前端会保存该JWT Token在浏览器的Cookie或LocalStorage中，供后续请求使用。</p><p>后续请求时，均会携带该Token，以完成Bearer认证。另外，有了登陆接口，一般还会配套/logout接口和/refresh接口，分别用来进行注销和刷新Token。</p><p>这里你可能会问，为什么要刷新Token？因为通过登陆接口签发的Token有过期时间，有了刷新接口，前端就可以根据需要，自行刷新Token的过期时间。过期时间可以通过iam-apiserver配置文件的<a href=\"https://github.com/marmotedu/iam/blob/master/configs/iam-apiserver.yaml#L66\">jwt.timeout</a>配置项来指定。登陆后签发Token时，使用的密钥（secretKey）由<a href=\"https://github.com/marmotedu/iam/blob/master/configs/iam-apiserver.yaml#L65\">jwt.key</a>配置项来指定。</p><h2>IAM项目是如何实现Bearer认证的？</h2><p>上面我们介绍了Basic认证。这里，我再来介绍下IAM项目中Bearer认证的实现方式。</p><p>IAM项目中有两个地方实现了Bearer认证，分别是 iam-apiserver 和 iam-authz-server。下面我来分别介绍下它们是如何实现Bearer认证的。</p><h3>iam-authz-server Bearer认证实现</h3><p>先来看下iam-authz-server是如何实现Bearer认证的。</p><p>iam-authz-server通过在 <code>/v1</code> 路由分组中加载cache认证中间件来使用cache认证策略：</p><pre><code>auth := newCacheAuth()\napiv1 := g.Group(&quot;/v1&quot;, auth.AuthFunc())\n</code></pre><p>来看下<a href=\"https://github.com/marmotedu/iam/blob/v1.0.4/internal/authzserver/jwt.go#L15\">newCacheAuth</a>函数：</p><pre><code>func newCacheAuth() middleware.AuthStrategy {\n    return auth.NewCacheStrategy(getSecretFunc())\n}\n\nfunc getSecretFunc() func(string) (auth.Secret, error) {\n    return func(kid string) (auth.Secret, error) {\n        cli, err := store.GetStoreInsOr(nil)\n        if err != nil {\n            return auth.Secret{}, errors.Wrap(err, &quot;get store instance failed&quot;)\n        }\n\n        secret, err := cli.GetSecret(kid)\n        if err != nil {\n            return auth.Secret{}, err\n        }\n\n        return auth.Secret{\n            Username: secret.Username,\n            ID:       secret.SecretId,\n            Key:      secret.SecretKey,\n            Expires:  secret.Expires,\n        }, nil\n    }\n}\n</code></pre><p>newCacheAuth函数调用<code>auth.NewCacheStrategy</code>创建了一个cache认证策略，创建时传入了<code>getSecretFunc</code>函数，该函数会返回密钥的信息。密钥信息包含了以下字段：</p><pre><code>type Secret struct {\n    Username string\n    ID       string\n    Key      string\n    Expires  int64\n}\n</code></pre><p>再来看下cache认证策略实现的<a href=\"https://github.com/marmotedu/iam/blob/master/internal/pkg/middleware/auth/cache.go#L48\">AuthFunc</a>方法：</p><pre><code>func (cache CacheStrategy) AuthFunc() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\theader := c.Request.Header.Get(&quot;Authorization&quot;)\n\t\tif len(header) == 0 {\n\t\t\tcore.WriteResponse(c, errors.WithCode(code.ErrMissingHeader, &quot;Authorization header cannot be empty.&quot;), nil)\n\t\t\tc.Abort()\n\n\t\t\treturn\n\t\t}\n\n\t\tvar rawJWT string\n\t\t// Parse the header to get the token part.\n\t\tfmt.Sscanf(header, &quot;Bearer %s&quot;, &amp;rawJWT)\n\n\t\t// Use own validation logic, see below\n\t\tvar secret Secret\n\n\t\tclaims := &amp;jwt.MapClaims{}\n\t\t// Verify the token\n\t\tparsedT, err := jwt.ParseWithClaims(rawJWT, claims, func(token *jwt.Token) (interface{}, error) {\n\t\t\t// Validate the alg is HMAC signature\n\t\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\t\treturn nil, fmt.Errorf(&quot;unexpected signing method: %v&quot;, token.Header[&quot;alg&quot;])\n\t\t\t}\n\n\t\t\tkid, ok := token.Header[&quot;kid&quot;].(string)\n\t\t\tif !ok {\n\t\t\t\treturn nil, ErrMissingKID\n\t\t\t}\n\n\t\t\tvar err error\n\t\t\tsecret, err = cache.get(kid)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, ErrMissingSecret\n\t\t\t}\n\n\t\t\treturn []byte(secret.Key), nil\n\t\t}, jwt.WithAudience(AuthzAudience))\n\t\tif err != nil || !parsedT.Valid {\n\t\t\tcore.WriteResponse(c, errors.WithCode(code.ErrSignatureInvalid, err.Error()), nil)\n\t\t\tc.Abort()\n\n\t\t\treturn\n\t\t}\n\n\t\tif KeyExpired(secret.Expires) {\n\t\t\ttm := time.Unix(secret.Expires, 0).Format(&quot;2006-01-02 15:04:05&quot;)\n\t\t\tcore.WriteResponse(c, errors.WithCode(code.ErrExpired, &quot;expired at: %s&quot;, tm), nil)\n\t\t\tc.Abort()\n\n\t\t\treturn\n\t\t}\n\n\t\tc.Set(CtxUsername, secret.Username)\n\t\tc.Next()\n\t}\n}\n\n// KeyExpired checks if a key has expired, if the value of user.SessionState.Expires is 0, it will be ignored.\nfunc KeyExpired(expires int64) bool {\n\tif expires &gt;= 1 {\n\t\treturn time.Now().After(time.Unix(expires, 0))\n\t}\n\n\treturn false\n}\n</code></pre><p>AuthFunc函数依次执行了以下四大步来完成JWT认证，每一步中又有一些小步骤，下面我们来一起看看。</p><p>第一步，从Authorization: Bearer XX.YY.ZZ请求头中获取XX.YY.ZZ，XX.YY.ZZ即为JWT Token。</p><p>第二步，调用github.com/dgrijalva/jwt-go包提供的ParseWithClaims函数，该函数会依次执行下面四步操作。</p><p>调用ParseUnverified函数，依次执行以下操作：</p><p>从Token中获取第一段XX，base64解码后得到JWT Token的Header{“alg”:“HS256”,“kid”:“a45yPqUnQ8gljH43jAGQdRo0bXzNLjlU0hxa”,“typ”:“JWT”}。</p><p>从Token中获取第二段YY，base64解码后得到JWT Token的Payload{“aud”:“iam.authz.marmotedu.com”,“exp”:1625104314,“iat”:1625097114,“iss”:“iamctl”,“nbf”:1625097114}。</p><p>根据Token Header中的alg字段，获取Token加密函数。</p><p>最终ParseUnverified函数会返回Token类型的变量，Token类型包含 Method、Header、Claims、Valid这些重要字段，这些字段会用于后续的认证步骤中。</p><p>调用传入的keyFunc获取密钥，这里来看下keyFunc的实现：</p><pre><code>func(token *jwt.Token) (interface{}, error) {\n\t// Validate the alg is HMAC signature\n\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\treturn nil, fmt.Errorf(&quot;unexpected signing method: %v&quot;, token.Header[&quot;alg&quot;])\n\t}\n\n\tkid, ok := token.Header[&quot;kid&quot;].(string)\n\tif !ok {\n\t\treturn nil, ErrMissingKID\n\t}\n\n\tvar err error\n\tsecret, err = cache.get(kid)\n\tif err != nil {\n\t\treturn nil, ErrMissingSecret\n\t}\n\n\treturn []byte(secret.Key), nil\n}\n</code></pre><p>可以看到，keyFunc接受 <code>*Token</code> 类型的变量，并获取Token Header中的kid，kid即为密钥ID：secretID。接着，调用cache.get(kid)获取密钥secretKey。cache.get函数即为getSecretFunc，getSecretFunc函数会根据kid，从内存中查找密钥信息，密钥信息中包含了secretKey。</p><ol start=\"3\">\n<li>从Token中获取Signature签名字符串ZZ，也即Token的第三段。</li>\n<li>获取到secretKey之后，token.Method.Verify验证Signature签名字符串ZZ，也即Token的第三段是否合法。token.Method.Verify实际上是使用了相同的加密算法和相同的secretKey加密XX.YY字符串。假设加密之后的字符串为WW，接下来会用WW和ZZ base64解码后的字符串进行比较，如果相等则认证通过，如果不相等则认证失败。</li>\n</ol><p><strong>第三步，</strong>调用KeyExpired，验证secret是否过期。secret信息中包含过期时间，你只需要拿该过期时间和当前时间对比就行。</p><p><strong>第四步，</strong>设置HTTP Header<code>username: colin</code>。</p><p>到这里，iam-authz-server的Bearer认证分析就完成了。</p><p>我们来做个总结：iam-authz-server通过加载Gin中间件的方式，在请求<code>/v1/authz</code>接口时进行访问认证。因为Bearer认证具有过期时间，而且可以在认证字符串中携带更多有用信息，还具有不可逆加密等优点，所以<strong>/v1/authz采用了Bearer认证，Token格式采用了JWT格式</strong>，这也是业界在API认证中最受欢迎的认证方式。</p><p>Bearer认证需要secretID和secretKey，这些信息会通过gRPC接口调用，从iam-apisaerver中获取，并缓存在iam-authz-server的内存中供认证时查询使用。</p><p>当请求来临时，iam-authz-server Bearer认证中间件从JWT Token中解析出Header，并从Header的kid字段中获取到secretID，根据secretID查找到secretKey，最后使用secretKey加密JWT Token的Header和Payload，并与Signature部分进行对比。如果相等，则认证通过；如果不等，则认证失败。</p><h3>iam-apiserver Bearer认证实现</h3><p>再来看下 iam-apiserver的Bearer认证。</p><p>iam-apiserver的Bearer认证通过以下代码（位于<a href=\"https://github.com/marmotedu/iam/blob/v1.1.0/internal/apiserver/router.go#L65\">router.go</a>文件中）指定使用了auto认证策略：</p><pre><code>v1.Use(auto.AuthFunc())\n</code></pre><p>我们来看下<a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/pkg/middleware/auth/auto.go#L38\">auto.AuthFunc()</a>的实现：</p><pre><code>func (a AutoStrategy) AuthFunc() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\toperator := middleware.AuthOperator{}\n\t\tauthHeader := strings.SplitN(c.Request.Header.Get(&quot;Authorization&quot;), &quot; &quot;, 2)\n\n\t\tif len(authHeader) != authHeaderCount {\n\t\t\tcore.WriteResponse(\n\t\t\t\tc,\n\t\t\t\terrors.WithCode(code.ErrInvalidAuthHeader, &quot;Authorization header format is wrong.&quot;),\n\t\t\t\tnil,\n\t\t\t)\n\t\t\tc.Abort()\n\n\t\t\treturn\n\t\t}\n\n\t\tswitch authHeader[0] {\n\t\tcase &quot;Basic&quot;:\n\t\t\toperator.SetStrategy(a.basic)\n\t\tcase &quot;Bearer&quot;:\n\t\t\toperator.SetStrategy(a.jwt)\n\t\t\t// a.JWT.MiddlewareFunc()(c)\n\t\tdefault:\n\t\t\tcore.WriteResponse(c, errors.WithCode(code.ErrSignatureInvalid, &quot;unrecognized Authorization header.&quot;), nil)\n\t\t\tc.Abort()\n\n\t\t\treturn\n\t\t}\n\n\t\toperator.AuthFunc()(c)\n\n\t\tc.Next()\n\t}\n}\n</code></pre><p>从上面代码中可以看到，AuthFunc函数会从Authorization Header中解析出认证方式是Basic还是Bearer。如果是Bearer，就会使用JWT认证策略；如果是Basic，就会使用Basic认证策略。</p><p>我们再来看下JWT认证策略的<a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/pkg/middleware/auth/jwt.go#L30\">AuthFunc</a>函数实现：</p><pre><code>func (j JWTStrategy) AuthFunc() gin.HandlerFunc {\n\treturn j.MiddlewareFunc()\n}\n</code></pre><p>我们跟随代码，可以定位到<code>MiddlewareFunc</code>函数最终调用了<code>github.com/appleboy/gin-jwt</code>包<code>GinJWTMiddleware</code>结构体的<a href=\"https://github.com/appleboy/gin-jwt/blob/v2.6.4/auth_jwt.go#L369\">middlewareImpl</a>方法：</p><pre><code>func (mw *GinJWTMiddleware) middlewareImpl(c *gin.Context) {\n\tclaims, err := mw.GetClaimsFromJWT(c)\n\tif err != nil {\n\t\tmw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(err, c))\n\t\treturn\n\t}\n\n\tif claims[&quot;exp&quot;] == nil {\n\t\tmw.unauthorized(c, http.StatusBadRequest, mw.HTTPStatusMessageFunc(ErrMissingExpField, c))\n\t\treturn\n\t}\n\n\tif _, ok := claims[&quot;exp&quot;].(float64); !ok {\n\t\tmw.unauthorized(c, http.StatusBadRequest, mw.HTTPStatusMessageFunc(ErrWrongFormatOfExp, c))\n\t\treturn\n\t}\n\n\tif int64(claims[&quot;exp&quot;].(float64)) &lt; mw.TimeFunc().Unix() {\n\t\tmw.unauthorized(c, http.StatusUnauthorized, mw.HTTPStatusMessageFunc(ErrExpiredToken, c))\n\t\treturn\n\t}\n\n\tc.Set(&quot;JWT_PAYLOAD&quot;, claims)\n\tidentity := mw.IdentityHandler(c)\n\n\tif identity != nil {\n\t\tc.Set(mw.IdentityKey, identity)\n\t}\n\n\tif !mw.Authorizator(identity, c) {\n\t\tmw.unauthorized(c, http.StatusForbidden, mw.HTTPStatusMessageFunc(ErrForbidden, c))\n\t\treturn\n\t}\n\n\tc.Next()\n}\n</code></pre><p>分析上面的代码，我们可以知道，middlewareImpl的Bearer认证流程为：</p><p><strong>第一步</strong>：调用<code>GetClaimsFromJWT</code>函数，从HTTP请求中获取Authorization Header，并解析出Token字符串，进行认证，最后返回Token Payload。</p><p><strong>第二步</strong>：校验Payload中的<code>exp</code>是否超过当前时间，如果超过就说明Token过期，校验不通过。</p><p><strong>第三步</strong>：给gin.Context中添加<code>JWT_PAYLOAD</code>键，供后续程序使用（当然也可能用不到）。</p><p><strong>第四步</strong>：通过以下代码，在gin.Context中添加IdentityKey键，IdentityKey键可以在创建<code>GinJWTMiddleware</code>结构体时指定，这里我们设置为<code>middleware.UsernameKey</code>，也就是username。</p><pre><code>identity := mw.IdentityHandler(c)\n\nif identity != nil {\n    c.Set(mw.IdentityKey, identity)\n}\n</code></pre><p>IdentityKey键的值由IdentityHandler函数返回，IdentityHandler函数为：</p><pre><code>func(c *gin.Context) interface{} {\n    claims := jwt.ExtractClaims(c)\n\n    return claims[jwt.IdentityKey]\n}\n</code></pre><p>上述函数会从Token的Payload中获取identity域的值，identity域的值是在签发Token时指定的，它的值其实是用户名，你可以查看<a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/apiserver/auth.go#L177\">payloadFunc</a>函数了解。</p><p><strong>第五步</strong>：接下来，会调用<code>Authorizator</code>方法，<code>Authorizator</code>是一个callback函数，成功时必须返回真，失败时必须返回假。<code>Authorizator</code>也是在创建GinJWTMiddleware时指定的，例如：</p><pre><code>func authorizator() func(data interface{}, c *gin.Context) bool {    \n    return func(data interface{}, c *gin.Context) bool {    \n        if v, ok := data.(string); ok {    \n            log.L(c).Infof(&quot;user `%s` is authenticated.&quot;, v)         \n                                                                     \n            return true                            \n        }                                                        \n                                                                 \n        return false                     \n    }    \n}    \n</code></pre><p><code>authorizator</code>函数返回了一个匿名函数，匿名函数在认证成功后，会打印一条认证成功日志。</p><h2>IAM项目认证功能设计技巧</h2><p>我在设计IAM项目的认证功能时，也运用了一些技巧，这里分享给你。</p><h3>技巧1：面向接口编程</h3><p>在使用<a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/pkg/middleware/auth/auto.go#L30\">NewAutoStrategy</a>函数创建auto认证策略时，传入了<a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/pkg/middleware/auth.go#L12\">middleware.AuthStrategy</a>接口类型的参数，这意味着Basic认证和Bearer认证都可以有不同的实现，这样后期可以根据需要扩展新的认证方式。</p><h3>技巧2：使用抽象工厂模式</h3><p><a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/apiserver/auth.go\">auth.go</a>文件中，通过newBasicAuth、newJWTAuth、newAutoAuth创建认证策略时，返回的都是接口。通过返回接口，可以在不公开内部实现的情况下，让调用者使用你提供的各种认证功能。</p><h3>技巧3：使用策略模式</h3><p>在auto认证策略中，我们会根据HTTP 请求头<code>Authorization: XXX X.Y.X</code>中的XXX来选择并设置认证策略（Basic 或 Bearer）。具体可以查看<code>AutoStrategy</code>的<a href=\"https://github.com/marmotedu/iam/blob/v1.0.0/internal/pkg/middleware/auth/auto.go#L38\">AuthFunc</a>函数：</p><pre><code>func (a AutoStrategy) AuthFunc() gin.HandlerFunc {\n\treturn func(c *gin.Context) {\n\t\toperator := middleware.AuthOperator{}\n\t\tauthHeader := strings.SplitN(c.Request.Header.Get(&quot;Authorization&quot;), &quot; &quot;, 2)\n        ...\n\t\tswitch authHeader[0] {\n\t\tcase &quot;Basic&quot;:\n\t\t\toperator.SetStrategy(a.basic)\n\t\tcase &quot;Bearer&quot;:\n\t\t\toperator.SetStrategy(a.jwt)\n\t\t\t// a.JWT.MiddlewareFunc()(c)\n\t\tdefault:\n\t\t\tcore.WriteResponse(c, errors.WithCode(code.ErrSignatureInvalid, &quot;unrecognized Authorization header.&quot;), nil)\n\t\t\tc.Abort()\n\n\t\t\treturn\n\t\t}\n\n\t\toperator.AuthFunc()(c)\n\n\t\tc.Next()\n\t}\n}\n</code></pre><p>上述代码中，如果是Basic，则设置为Basic认证方法<code>operator.SetStrategy(a.basic)</code>；如果是Bearer，则设置为Bearer认证方法<code>operator.SetStrategy(a.jwt)</code>。 <code>SetStrategy</code>方法的入参是AuthStrategy类型的接口，都实现了<code>AuthFunc() gin.HandlerFunc</code>函数，用来进行认证，所以最后我们调用<code>operator.AuthFunc()(c)</code>即可完成认证。</p><h2>总结</h2><p>在IAM项目中，iam-apiserver实现了Basic认证和Bearer认证，iam-authz-server实现了Bearer认证。这一讲重点介绍了iam-apiserver的认证实现。</p><p>用户要访问iam-apiserver，首先需要通过Basic认证，认证通过之后，会返回JWT Token和JWT Token的过期时间。前端将Token缓存在LocalStorage或Cookie中，后续的请求都通过Token来认证。</p><p>执行Basic认证时，iam-apiserver会从HTTP Authorization Header中解析出用户名和密码，将密码再加密，并和数据库中保存的值进行对比。如果不匹配，则认证失败，否则认证成功。认证成功之后，会返回Token，并在Token的Payload部分设置用户名，Key为 username 。</p><p>执行Bearer认证时，iam-apiserver会从JWT Token中解析出Header和Payload，并从Header中获取加密算法。接着，用获取到的加密算法和从配置文件中获取到的密钥对Header.Payload进行再加密，得到Signature，并对比两次的Signature是否相等。如果不相等，则返回 HTTP 401 Unauthorized 错误；如果相等，接下来会判断Token是否过期，如果过期则返回认证不通过，否则认证通过。认证通过之后，会将Payload中的username添加到gin.Context类型的变量中，供后面的业务逻辑使用。</p><p>我绘制了整个流程的示意图，你可以对照着再回顾一遍。</p><p><img src=\"https://static001.geekbang.org/resource/image/64/7e/642a010388e759dd76d411055bbd637e.jpg?wh=2248x1104\" alt=\"\"></p><h2>课后练习</h2><ol>\n<li>走读<code>github.com/appleboy/gin-jwt</code>包的<code>GinJWTMiddleware</code>结构体的<a href=\"https://github.com/appleboy/gin-jwt/blob/v2.6.4/auth_jwt.go#L407\">GetClaimsFromJWT</a>方法，分析一下：GetClaimsFromJWT方法是如何从gin.Context中解析出Token，并进行认证的？</li>\n<li>思考下，iam-apiserver和iam-authzserver是否可以使用同一个认证策略？如果可以，又该如何实现？</li>\n</ol><p>欢迎你在留言区与我交流讨论，我们下一讲见。</p>","neighbors":{"left":{"article_title":"25 | 认证机制：应用程序如何进行访问认证？","id":398410},"right":{"article_title":"27 | 权限模型：5大权限模型是如何进行资源授权的？","id":400213}},"comments":[{"had_liked":false,"id":304091,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1627230341,"is_pvip":false,"replies":[{"id":"110141","content":"老哥理解的没毛病","user_name":"作者回复","user_name_real":"CK1.0","uid":"1167883","ctime":1627382055,"ip_address":"","comment_id":304091,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31692001413","product_id":100079601,"comment_content":"本文的意思是说正常的生产环境下，iam-apiserver和iam-authz-server的api的认证功能其实都应该放到网关来实现的，本文之所以由iam项目亲自来实现就是为了方便讲解认证的具体实现方法，我理解的对不对？","like_count":7,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523927,"discussion_content":"老哥理解的没毛病","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627382055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307227,"user_name":"Sch0ng","can_delete":false,"product_type":"c1","uid":1145554,"ip_address":"","ucode":"73F6113931B1AC","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/d2/4ba67c0c.jpg","comment_is_top":false,"comment_ctime":1628949858,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18808819042","product_id":100079601,"comment_content":"服务端实现Basic和Bearer认证的详细方案。<br>配合源码和架构图理解。","like_count":4},{"had_liked":false,"id":347174,"user_name":"Geek_f23c82","can_delete":false,"product_type":"c1","uid":2725008,"ip_address":"","ucode":"40BABEF7078F37","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIW5xLKMIwlibBXdP5sGVqhXAGuLYk7XFBrhzkFytlKicjNpSHIKXQclDUlSbD9s2HDuOiaBXslCqVbg/132","comment_is_top":false,"comment_ctime":1653792927,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10243727519","product_id":100079601,"comment_content":"麻烦问下authserver什么时候派发的jwt token？","like_count":2},{"had_liked":false,"id":307521,"user_name":"冷峰","can_delete":false,"product_type":"c1","uid":1266052,"ip_address":"","ucode":"E6B7DA545E7961","user_header":"https://static001.geekbang.org/account/avatar/00/13/51/84/5b7d4d95.jpg","comment_is_top":false,"comment_ctime":1629129686,"is_pvip":false,"replies":[{"id":"111379","content":"这样不安全了，A、B、C都使用同一个secretKey，那都依赖于同一个secretKey，如果A想更改secretKey的过期时间，不就影响到B、C了。secretKey也属于用户资源，每个用于都应该有一个，符合产品设计思路","user_name":"作者回复","user_name_real":"CK1.0","uid":"1167883","ctime":1629242513,"ip_address":"","comment_id":307521,"utype":1}],"discussion_count":9,"race_medal":0,"score":"10219064278","product_id":100079601,"comment_content":"为什么每个用户都要有一个SecretKey， 所有的用户用同一个SecretKey不行吗？","like_count":2,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525187,"discussion_content":"这样不安全了，A、B、C都使用同一个secretKey，那都依赖于同一个secretKey，如果A想更改secretKey的过期时间，不就影响到B、C了。secretKey也属于用户资源，每个用于都应该有一个，符合产品设计思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629242513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102656,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d3/40/0067d6db.jpg","nickname":"AKA三皮","note":"","ucode":"D3BC5C60025E9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581703,"discussion_content":"再多说一些，jwt的优势就在于它是无状态的（认证服务器不需要去存储它），网关的验证也因为是缓存了密钥，可以做到本地（不需要远程访问认证服务器）。这种效率很高。但是有一个问题：客户有注销账号的需求，如果账号注销，但是token没有过期，就会给客户产生误解：我明明注销了，为什么还能访问。这就要求做token黑名单了。你会发现，诶，这变矛盾了，jwt变成有状态的了～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658927365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102656,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d3/40/0067d6db.jpg","nickname":"AKA三皮","note":"","ucode":"D3BC5C60025E9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581702,"discussion_content":"jwt其实还有一种方式是非对称加密， 通常在网关处缓存公钥（多租户模式下，每个租户的密钥不同），然后通过公钥去verify token","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658927189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2628969,"avatar":"https://static001.geekbang.org/account/avatar/00/28/1d/69/c21d2644.jpg","nickname":"josephzxy","note":"","ucode":"71E8006733420D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393103,"discussion_content":"用于JWT加密的secret_key，我的理解是，比较简单的场景可以服务端只有一个secret_key，缺点是如果该key泄露，就会影响所有之前签发的JWT token。所以也可以为每个用户生成一个secret_id/secret_key 对，并存入缓存，签发把secret_id写入JWT header 的kid字段，校验时用secret_id去缓存拿到secret_key进行校验。这样如果一个secret_key泄露，只影响一个用户的JWT token。为了提高安全性，也可以允许用户注销之前的secret_id/secret_key 对并创建新的，当然secret_key应该始终对用户不可见，否则用户就可以伪造JWT token了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631250999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2654999,"avatar":"https://static001.geekbang.org/account/avatar/00/28/83/17/df99b53d.jpg","nickname":"随风而过","note":"","ucode":"FFD17BAA3B2312","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392158,"discussion_content":"此secretKey非彼secretKey，估计是java 做jwt认证习惯了，这位同学说的我也经常用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630858152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1266052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/51/84/5b7d4d95.jpg","nickname":"冷峰","note":"","ucode":"E6B7DA545E7961","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389351,"discussion_content":"这里还是没太明白，我的理解是secretKey是服务端自己配置的，只是用来做jwt的签名使用的，为什么用户能修改secretKey的过期时间？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629249682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1174794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","nickname":"Juniper","note":"","ucode":"1BC24554034BD3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1266052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/51/84/5b7d4d95.jpg","nickname":"冷峰","note":"","ucode":"E6B7DA545E7961","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400504,"discussion_content":"这里的secretKey其实是有两个概念。一个是IAM系统的secretKey，对于IAM系统来说是唯一的，所以写在配置里。用户登录系统之后，要根据这个secretKey，生成jwt-token。这里的jwt-token跟iam-authz-server的资源授权没有关系，是iam-apiserver接口操作的令牌。然后第二个secretKey，就是跟iam-authz-server的资源授权相关的，是在IAM系统里创建的，所以老师说是一种资源。每个用户需要维护自己的secretKey，需要secretID和它配对。既然是一种资源，那么肯定可以做CURD操作，所以可以修改过期时间（过期时间也是密钥的属性）。参考微信公众号，在后台可以重置AppSecret","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1633278132,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":389351,"ip_address":""},"score":400504,"extra":""},{"author":{"id":1146983,"avatar":"https://static001.geekbang.org/account/avatar/00/11/80/67/4e381da5.jpg","nickname":"Derek","note":"","ucode":"A4D5DED1E00F60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1174794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","nickname":"Juniper","note":"","ucode":"1BC24554034BD3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408679,"discussion_content":"牛掰，我看懂了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635302115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":400504,"ip_address":""},"score":408679,"extra":""},{"author":{"id":1836188,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIs6XNf3fE2EOFnIvb29kodcBJxBRAiaVKyUD1p8voIopOpb75P5hS9fMSxbhVCgHIA7dadGD4I1bQ/132","nickname":"秦进","note":"","ucode":"517CB977F0BE0D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1174794,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ed/0a/18201290.jpg","nickname":"Juniper","note":"","ucode":"1BC24554034BD3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":570110,"discussion_content":"这里作者没有讲清楚。应该在文中说明一下，这个kid把我弄晕了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651666624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":400504,"ip_address":""},"score":570110,"extra":""}]}]},{"had_liked":false,"id":358312,"user_name":"🌀🐑hfy🐣","can_delete":false,"product_type":"c1","uid":1254367,"ip_address":"广东","ucode":"8A7E4BDC46CB35","user_header":"https://static001.geekbang.org/account/avatar/00/13/23/df/367f2c75.jpg","comment_is_top":false,"comment_ctime":1664185221,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5959152517","product_id":100079601,"comment_content":"请问老师为什么bearer认证里面还要basic认证？<br>","like_count":1,"discussions":[{"author":{"id":2894734,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/2b/8e/4d24c872.jpg","nickname":"season","note":"","ucode":"1CBBFCC58A245E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590320,"discussion_content":"总结里面的流程示意图  bearer认证里面为什么有basic认证？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665652405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321043,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1636630753,"is_pvip":false,"replies":[{"id":"116886","content":"这样做不太合理：<br>1. 如果很多用户，那应用程序会缓存并维护很多session，对应用程序是一种压力，如果应用程序重启，那登录会失效，这种是不合理的<br>2. jwt token中能够包含很多信息，可以基于这些信息做更多的认证逻辑","user_name":"作者回复","user_name_real":"编辑","uid":"1167883","ctime":1637077711,"ip_address":"","comment_id":321043,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5931598049","product_id":100079601,"comment_content":"jwt需要后端解析并从缓存中拿用户对应秘钥在进行运算进行鉴权，这些流程是不是有点复杂和多余啊，登录时候直接随机生成一个token（uuid hash）传给前端并保存到缓存中，缓存中token直接对应用户的session，每次前端传过来token 根据是否能用token获取缓存中的session来鉴权 这样岂不是实现简单 也安全啊  ","like_count":1,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530503,"discussion_content":"这样做不太合理：\n1. 如果很多用户，那应用程序会缓存并维护很多session，对应用程序是一种压力，如果应用程序重启，那登录会失效，这种是不合理的\n2. jwt token中能够包含很多信息，可以基于这些信息做更多的认证逻辑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637077711,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310615,"user_name":"types","can_delete":false,"product_type":"c1","uid":2449777,"ip_address":"","ucode":"8B50927EF1804F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLDUJyeq54fiaXAgF62tNeocO3lHsKT4mygEcNoZLnibg6ONKicMgCgUHSfgW8hrMUXlwpNSzR8MHZwg/132","comment_is_top":false,"comment_ctime":1630775291,"is_pvip":false,"replies":[{"id":"112564","content":"1. IAM项目写了一个工具来生成jwt token:<br><br>iamctl jwt sign &lt;secretID&gt; &lt;secretKey&gt;<br><br>2. 其实，这里有2个维度，需要解释。<br><br>第一个token vs password的优势对比：<br><br>token相比password更加安全 - token有过期时间，经过加密。<br>更丰富的信息 - 可以在token的payload中，携带更丰富的信息，实现更强大的认证功能。<br><br>第二个API通过密钥访问 VS 控制台通过密码访问。<br><br>通过第一个对比，显然Token比password更安全。<br><br>但如果是控制台，我们需要提供给用户一个友好的登陆界面，所以控制台一般通过密码登陆。登陆后生成临时token，后面继续走token认证。<br><br>当然，随着技术的发展，目前也有很多其它登陆方式比如：扫一扫、安全令牌等","user_name":"作者回复","user_name_real":"CK1.0","uid":"1167883","ctime":1630862310,"ip_address":"","comment_id":310615,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5925742587","product_id":100079601,"comment_content":"根据文中所说<br> 秘钥对是给iam-authz-server使用的<br> 每个用户维护一个密钥<br>请问:<br>1. iam-authz-server jwt认证中的jwt token谁谁生成的？是客户端还是iam-auth-server<br>2. 如果是客户端生成的jwt token，说明客户端是需要有secret秘钥对的信息的，请问这样设计有什么优势？<br>跟通过用户名密码登陆后，由服务端生成jwt token这种方式相比较有什么优势<br>","like_count":1,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526292,"discussion_content":"1. IAM项目写了一个工具来生成jwt token:\n\niamctl jwt sign &amp;lt;secretID&amp;gt; &amp;lt;secretKey&amp;gt;\n\n2. 其实，这里有2个维度，需要解释。\n\n第一个token vs password的优势对比：\n\ntoken相比password更加安全 - token有过期时间，经过加密。\n更丰富的信息 - 可以在token的payload中，携带更丰富的信息，实现更强大的认证功能。\n\n第二个API通过密钥访问 VS 控制台通过密码访问。\n\n通过第一个对比，显然Token比password更安全。\n\n但如果是控制台，我们需要提供给用户一个友好的登陆界面，所以控制台一般通过密码登陆。登陆后生成临时token，后面继续走token认证。\n\n当然，随着技术的发展，目前也有很多其它登陆方式比如：扫一扫、安全令牌等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630862310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2654999,"avatar":"https://static001.geekbang.org/account/avatar/00/28/83/17/df99b53d.jpg","nickname":"随风而过","note":"","ucode":"FFD17BAA3B2312","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392157,"discussion_content":"问题重复了，下面有回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630858065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359593,"user_name":"season","can_delete":false,"product_type":"c1","uid":2894734,"ip_address":"浙江","ucode":"1CBBFCC58A245E","user_header":"https://static001.geekbang.org/account/avatar/00/2c/2b/8e/4d24c872.jpg","comment_is_top":false,"comment_ctime":1665664735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665664735","product_id":100079601,"comment_content":"第四步，设置HTTP Header username: colin 。<br><br>应该是 第四步，给gin.Context中添加 username: colin 。  ？<br>","like_count":0},{"had_liked":false,"id":359576,"user_name":"season","can_delete":false,"product_type":"c1","uid":2894734,"ip_address":"浙江","ucode":"1CBBFCC58A245E","user_header":"https://static001.geekbang.org/account/avatar/00/2c/2b/8e/4d24c872.jpg","comment_is_top":false,"comment_ctime":1665653518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665653518","product_id":100079601,"comment_content":"ParseWithClaims怎么理解？<br>func (p *Parser) ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) {}<br><br>使用Claims来解析，并返回 token？","like_count":0},{"had_liked":false,"id":359567,"user_name":"season","can_delete":false,"product_type":"c1","uid":2894734,"ip_address":"浙江","ucode":"1CBBFCC58A245E","user_header":"https://static001.geekbang.org/account/avatar/00/2c/2b/8e/4d24c872.jpg","comment_is_top":false,"comment_ctime":1665647939,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665647939","product_id":100079601,"comment_content":"技巧2:使用抽象工厂模式<br>auth.go文件中，通过newBasicAuth、newJWTAuth、newAutoAuth创建认证策略时，返回的 都是接口。通过返回接口，可以在不公开内部实现的情况下，让调用者使用你提供的各种认证 功能。<br><br><br>1. 不公开内部实现的情况下，是指不公开哪个函数的内部实现？<br>2. 让调用者使用你提供的各种认证功能，指的是哪些方法？","like_count":0},{"had_liked":false,"id":323785,"user_name":"党","can_delete":false,"product_type":"c1","uid":1071974,"ip_address":"","ucode":"EE531DB3EA124D","user_header":"https://static001.geekbang.org/account/avatar/00/10/5b/66/ad35bc68.jpg","comment_is_top":false,"comment_ctime":1638161019,"is_pvip":false,"replies":[{"id":"117672","content":"这个JWT是没这种功能的","user_name":"作者回复","user_name_real":"编辑","uid":"1167883","ctime":1638361466,"ip_address":"","comment_id":323785,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1638161019","product_id":100079601,"comment_content":"jwt貌似不可以实现实时踢人吧 一个账号登录了 在登录一次 让上次的token失效 这个jwt不可以吧","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535147,"discussion_content":"这个JWT是没这种功能的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638361466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1363131,"avatar":"","nickname":"yk","note":"","ucode":"5F3F199EB45CE3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552323,"discussion_content":"把token存下来，另一个点登陆 直接拉黑老的token就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645411809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1284855,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/f7/6ff76318.jpg","nickname":"Dolphin","note":"","ucode":"0481DE78AE7CB5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537114,"discussion_content":"在payload中保存一个登录时间，同时库中也保存一个登录时间，在获取到用户后判断payload登录时间小于数据库中的视为失败，这样改造可以吧？（假设每次请求都需要去库中取这个用户做鉴权，这样也不会带来额外的数据库查询）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638960651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1001225,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/09/316b0aa1.jpg","nickname":"张浩","note":"","ucode":"DBEAFFB7660813","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1284855,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9a/f7/6ff76318.jpg","nickname":"Dolphin","note":"","ucode":"0481DE78AE7CB5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576456,"discussion_content":"这样应该是可以的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655560039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":537114,"ip_address":""},"score":576456,"extra":""}]}]},{"had_liked":false,"id":323593,"user_name":"yandongxiao","can_delete":false,"product_type":"c1","uid":1017700,"ip_address":"","ucode":"D397F4DB0109C8","user_header":"https://static001.geekbang.org/account/avatar/00/0f/87/64/3882d90d.jpg","comment_is_top":false,"comment_ctime":1638008318,"is_pvip":false,"replies":[{"id":"117670","content":"总结的好细！","user_name":"作者回复","user_name_real":"编辑","uid":"1167883","ctime":1638361391,"ip_address":"","comment_id":323593,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638008318","product_id":100079601,"comment_content":"总结：<br>IAM系统采用 Basic + bearer 两种认证方式。Basic 认证要求输入用户名和密码，返回 JWT Token；虽然客户端在访问 iam-apiserver 或者 iam-auth-server 时，在 bearer 认证中携带该 Token，服务端对该请求进行认证。<br>1. 服务端basic认证实现逻辑：通过 gin middleware 实现了签发 JWT 的功能。jwt.New 对象在实例化时，传递多个回调函数，比如 Authentiactor, LoginResponse 等。<br>2. 服务端bearer认证实现逻辑：在 gin 中以 middleware 的方式存在，借助 jwt package 完成认证。认证完成后，会在 Context 中保存Username，方便后面的handler使用","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535145,"discussion_content":"总结的好细！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638361391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":318739,"user_name":"姚力晓","can_delete":false,"product_type":"c1","uid":2447778,"ip_address":"","ucode":"64DE7980555B88","user_header":"https://static001.geekbang.org/account/avatar/00/25/59/a2/b28b1ffb.jpg","comment_is_top":false,"comment_ctime":1635408319,"is_pvip":false,"replies":[{"id":"115965","content":"文章已经写完了，打磨后马上放出来","user_name":"作者回复","user_name_real":"孔令飞","uid":"1167883","ctime":1636004268,"ip_address":"","comment_id":318739,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1635408319","product_id":100079601,"comment_content":"如果 Redis down 掉，或者出现网络抖动，老师说会在新一期的特别放送里专门介绍下， 这个内容没看到？","like_count":0,"discussions":[{"author":{"id":1167883,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d2/0b/cdd0787a.jpg","nickname":"孔令飞","note":"","ucode":"8363EA4BD0AAF0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":529365,"discussion_content":"文章已经写完了，打磨后马上放出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636004268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2894734,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/2b/8e/4d24c872.jpg","nickname":"season","note":"","ucode":"1CBBFCC58A245E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589946,"discussion_content":"+1  文章放出来了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665409534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1090196,"avatar":"https://static001.geekbang.org/account/avatar/00/10/a2/94/ae0a60d8.jpg","nickname":"江山未","note":"","ucode":"5293DD9482717F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545671,"discussion_content":"出来了波，需要这篇文章","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642038394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008597,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/d5/a300899a.jpg","nickname":"杨丁","note":"","ucode":"D469B0BCA86587","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534701,"discussion_content":"+1，文章还没放出来么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638259066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2004616,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/96/88/454e401c.jpg","nickname":"销毁first","note":"","ucode":"34685269D0CDD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411624,"discussion_content":"用户数据缺失时，主动去redis查一次就行了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635953818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314733,"user_name":"指尖”^^的童话","can_delete":false,"product_type":"c1","uid":2381061,"ip_address":"","ucode":"C496CF8604F62B","user_header":"https://static001.geekbang.org/account/avatar/00/24/55/05/72d9aa41.jpg","comment_is_top":false,"comment_ctime":1633362345,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1633362345","product_id":100079601,"comment_content":"项目有点大，如果是一步步实现的就更好了","like_count":0,"discussions":[{"author":{"id":1001225,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/09/316b0aa1.jpg","nickname":"张浩","note":"","ucode":"DBEAFFB7660813","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576460,"discussion_content":"感觉现在老师讲的比较详细，可能要是一步一步实现，课程会很长，主要的方面课程都讲解了，一步一步地实现需要跟着源码操作了。\n对于没有接触过Go的，可以从整体上对大型项目有一个概览，能够知道来龙去脉，第一遍可以快速地掠过一遍，整体上有印象，第二遍再按照老师的操作实际操作，等第二遍完成以后，后面就遇到类似问题的时候，再来查询，看看有哪些可以借鉴或者可以做的更好的地方，目前自己是按照这样的方式来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655560429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}