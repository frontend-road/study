{"id":309423,"title":"02 | 理解进程（1）：为什么我在容器中不能kill 1号进程？","content":"<p>你好，我是程远。</p><p>今天，我们正式进入理解进程的模块。我会通过3讲内容，带你了解容器init进程的特殊之处，还有它需要具备哪些功能，才能保证容器在运行过程中不会出现类似僵尸进程，或者应用程序无法graceful shutdown的问题。</p><p>那么通过这一讲，我会带你掌握init进程和Linux信号的核心概念。</p><h2>问题再现</h2><p>接下来，我们一起再现用 <code>kill 1</code> 命令重启容器的问题。</p><p>我猜你肯定想问，为什么要在容器中执行 <code>kill 1</code> 或者 <code>kill -9 1</code> 的命令呢？其实这是我们团队里的一位同学提出的问题。</p><p>这位同学当时遇到的情况是这样的，他想修改容器镜像里的一个bug，但因为网路配置的问题，这个同学又不想为了重建pod去改变pod IP。</p><p>如果你用过Kubernetes的话，你也肯定知道，Kubernetes上是没有 <code>restart pod</code> 这个命令的。这样看来，他似乎只能让pod做个原地重启了。<strong>当时我首先想到的，就是在容器中使用kill pid 1的方式重启容器。</strong></p><p>为了模拟这个过程，我们可以进行下面的这段操作。</p><p>如果你没有在容器中做过 <code>kill 1</code> ，你可以下载我在GitHub上的这个<a href=\"https://github.com/chengyli/training/tree/master/init_proc/handle_sig\">例子</a>，运行 <code>make image</code> 来做一个容器镜像。</p><p>然后，我们用Docker构建一个容器，用例子中的 <strong>init.sh脚本</strong>作为这个容器的init进程。</p><!-- [[[read_end]]] --><p>最后，我们在容器中运行 <code>kill 1</code> 和 <code>kill -9 1</code> ，看看会发生什么。</p><pre><code class=\"language-shell\"># docker stop sig-proc;docker rm sig-proc\n# docker run --name sig-proc -d registry/sig-proc:v1 /init.sh\n# docker exec -it sig-proc bash\n[root@5cc69036b7b2 /]# ps -ef\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 07:23 ?        00:00:00 /bin/bash /init.sh\nroot         8     1  0 07:25 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 100\nroot         9     0  6 07:27 pts/0    00:00:00 bash\nroot        22     9  0 07:27 pts/0    00:00:00 ps -ef\n\n[root@5cc69036b7b2 /]# kill 1\n[root@5cc69036b7b2 /]# kill -9 1\n[root@5cc69036b7b2 /]# ps -ef\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 07:23 ?        00:00:00 /bin/bash /init.sh\nroot         9     0  0 07:27 pts/0    00:00:00 bash\nroot        23     1  0 07:27 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 100\nroot        24     9  0 07:27 pts/0    00:00:00 ps -ef\n</code></pre><p>当我们完成前面的操作，就会发现无论运行 <code>kill 1</code> （对应Linux中的SIGTERM信号）还是 <code>kill -9 1</code>（对应Linux中的SIGKILL信号），都无法让进程终止。</p><p>那么问题来了，这两个常常用来终止进程的信号，都对容器中的init进程不起作用，这是怎么回事呢？</p><p>要解释这个问题，我们就要回到容器的两个最基本概念——init进程和Linux信号中寻找答案。</p><h2>知识详解</h2><h3>如何理解init进程？</h3><p>init进程的意思并不难理解，你只要认真听我讲完，这块内容基本就不会有问题了。我们下面来看一看。</p><p>使用容器的理想境界是<strong>一个容器只启动一个进程</strong>，但这在现实应用中有时是做不到的。</p><p>比如说，在一个容器中除了主进程之外，我们可能还会启动辅助进程，做监控或者rotate logs；再比如说，我们需要把原来运行在虚拟机（VM）的程序移到容器里，这些原来跑在虚拟机上的程序本身就是多进程的。</p><p>一旦我们启动了多个进程，那么容器里就会出现一个pid 1，也就是我们常说的1号进程或者init进程，然后<strong>由这个进程创建出其他的子进程。</strong></p><p>接下来，我带你梳理一下init进程是怎么来的。</p><p>一个Linux操作系统，在系统打开电源，执行BIOS/boot-loader之后，就会由boot-loader负责加载Linux内核。</p><p>Linux内核执行文件一般会放在/boot目录下，文件名类似vmlinuz*。在内核完成了操作系统的各种初始化之后，<strong>这个程序需要执行的第一个用户态程就是init进程。</strong></p><p>内核代码启动1号进程的时候，在没有外面参数指定程序路径的情况下，一般会从几个缺省路径尝试执行1号进程的代码。这几个路径都是Unix常用的可执行代码路径。</p><p>系统启动的时候先是执行内核态的代码，然后在内核中调用1号进程的代码，从内核态切换到用户态。</p><p>目前主流的Linux发行版，无论是RedHat系的还是Debian系的，都会把/sbin/init作为符号链接指向Systemd。Systemd是目前最流行的Linux init进程，在它之前还有SysVinit、UpStart等Linux init进程。</p><p><strong>但无论是哪种Linux init进程，它最基本的功能都是创建出Linux系统中其他所有的进程，并且管理这些进程。</strong>具体在kernel里的代码实现如下：</p><pre><code class=\"language-shell\">init/main.c\n\n        /*\n         * We try each of these until one succeeds.\n         *\n         * The Bourne shell can be used instead of init if we are\n         * trying to recover a really broken machine.\n         */\n\n        if (execute_command) {\n                ret = run_init_process(execute_command);\n                if (!ret)\n                        return 0;\n                panic(\"Requested init %s failed (error %d).\",\n                      execute_command, ret);\n        }\n\n        if (!try_to_run_init_process(\"/sbin/init\") ||\n            !try_to_run_init_process(\"/etc/init\") ||\n            !try_to_run_init_process(\"/bin/init\") ||\n            !try_to_run_init_process(\"/bin/sh\"))\n                return 0;\n\n\n        panic(\"No working init found.  Try passing init= option to kernel. \"\n              \"See Linux Documentation/admin-guide/init.rst for guidance.\");\n</code></pre><pre><code class=\"language-shell\">$ ls -l /sbin/init\nlrwxrwxrwx 1 root root 20 Feb  5 01:07 /sbin/init -&gt; /lib/systemd/systemd\n</code></pre><p>在Linux上有了容器的概念之后，一旦容器建立了自己的Pid Namespace（进程命名空间），这个Namespace里的进程号也是从1开始标记的。所以，容器的init进程也被称为1号进程。</p><p>怎么样，1号进程是不是不难理解？关于这个知识点，你只需要记住： <strong>1号进程是第一个用户态的进程，由它直接或者间接创建了Namespace中的其他进程。</strong></p><h3>如何理解Linux信号？</h3><p>刚才我给你讲了什么是1号进程，要想解决“为什么我在容器中不能kill 1号进程”这个问题，我们还得看看kill命令起到的作用。</p><p>我们运行kill命令，其实在Linux里就是发送一个信号，那么信号到底是什么呢？这就涉及到Linux信号的概念了。</p><p>其实信号这个概念在很早期的Unix系统上就有了。它一般会从1开始编号，通常来说，信号编号是1到31，这个编号在所有的Unix系统上都是一样的。</p><p>在Linux上我们可以用 <code>kill -l</code> 来看这些信号的编号和名字，具体的编号和名字我给你列在了下面，你可以看一看。</p><pre><code class=\"language-shell\">$ kill -l\n 1) SIGHUP      2) SIGINT    3) SIGQUIT    4) SIGILL    5) SIGTRAP\n 6) SIGABRT     7) SIGBUS    8) SIGFPE     9) SIGKILL  10) SIGUSR1\n11) SIGSEGV    12) SIGUSR2  13) SIGPIPE   14) SIGALRM  15) SIGTERM\n16) SIGSTKFLT  17) SIGCHLD  18) SIGCONT   19) SIGSTOP  20) SIGTSTP\n21) SIGTTIN    22) SIGTTOU  23) SIGURG    24) SIGXCPU  25) SIGXFSZ\n26) SIGVTALRM  27) SIGPROF  28) SIGWINCH  29) SIGIO    30) SIGPWR\n31) SIGSYS\n</code></pre><p>用一句话来概括，<strong>信号（Signal）其实就是Linux进程收到的一个通知。</strong>这些通知产生的源头有很多种，通知的类型也有很多种。</p><p>比如下面这几个典型的场景，你可以看一下：</p><ul>\n<li>如果我们按下键盘“Ctrl+C”，当前运行的进程就会收到一个信号SIGINT而退出；</li>\n<li>如果我们的代码写得有问题，导致内存访问出错了，当前的进程就会收到另一个信号SIGSEGV；</li>\n<li>我们也可以通过命令kill &lt;pid&gt;，直接向一个进程发送一个信号，缺省情况下不指定信号的类型，那么这个信号就是SIGTERM。也可以指定信号类型，比如命令 \"kill -9 &lt;pid&gt;\", 这里的9，就是编号为9的信号，SIGKILL信号。</li>\n</ul><p>在这一讲中，我们主要用到<strong> SIGTERM（15）和SIGKILL（9）这两个信号</strong>，所以这里你主要了解这两个信号就可以了，其他信号以后用到时再做介绍。</p><p>进程在收到信号后，就会去做相应的处理。怎么处理呢？对于每一个信号，进程对它的处理都有下面三个选择。</p><p>第一个选择是<strong>忽略（Ignore）</strong>，就是对这个信号不做任何处理，但是有两个信号例外，对于SIGKILL和SIGSTOP这个两个信号，进程是不能忽略的。这是因为它们的主要作用是为Linux kernel和超级用户提供删除任意进程的特权。</p><p>第二个选择，就是<strong>捕获（Catch）</strong>，这个是指让用户进程可以注册自己针对这个信号的handler。具体怎么做我们目前暂时涉及不到，你先知道就行，我们在后面课程会进行详细介绍。</p><p><strong>对于捕获，SIGKILL和SIGSTOP这两个信号也同样例外，这两个信号不能有用户自己的处理代码，只能执行系统的缺省行为。</strong></p><p>还有一个选择是<strong>缺省行为（Default）</strong>，Linux为每个信号都定义了一个缺省的行为，你可以在Linux系统中运行 <code>man 7 signal</code>来查看每个信号的缺省行为。</p><p>对于大部分的信号而言，应用程序不需要注册自己的handler，使用系统缺省定义行为就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/da/0d/dae0e2bdfb4bae2d900e58cb3490dc0d.jpeg?wh=3200*1800\" alt=\"\"></p><p>我刚才说了，SIGTERM（15）和SIGKILL（9）这两个信号是我们重点掌握的。现在我们已经讲解了信号的概念和处理方式，我就拿这两个信号为例，再带你具体分析一下。</p><p>首先我们来看SIGTERM（15），这个信号是Linux命令kill缺省发出的。前面例子里的命令 <code>kill 1</code> ，就是通过kill向1号进程发送一个信号，在没有别的参数时，这个信号类型就默认为SIGTERM。</p><p>SIGTERM这个信号是可以被捕获的，这里的“捕获”指的就是用户进程可以为这个信号注册自己的handler，而这个handler，我们后面会看到，它可以处理进程的graceful-shutdown问题。</p><p>我们再来了解一下SIGKILL (9)，这个信号是Linux里两个<strong>特权信号</strong>之一。什么是特权信号呢？</p><p>前面我们已经提到过了，<strong>特权信号就是Linux为kernel和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获。</strong>那么进程一旦收到SIGKILL，就要退出。</p><p>在前面的例子里，我们运行的命令 <code>kill -9 1</code> 里的参数“-9”，其实就是指发送编号为9的这个SIGKILL信号给1号进程。</p><h2>现象解释</h2><p>现在，你应该理解init进程和Linux信号这两个概念了，让我们回到开头的问题上来：“为什么我在容器中不能kill 1号进程，甚至SIGKILL信号也不行？”</p><p>你还记得么，在课程的最开始，我们已经尝试过用bash作为容器1号进程，这样是无法把1号进程杀掉的。那么我们再一起来看一看，用别的编程语言写的1号进程是否也杀不掉。</p><p>我们现在<strong>用C程序作为init进程</strong>，尝试一下杀掉1号进程。和bash init进程一样，无论SIGTERM信号还是SIGKILL信号，在容器里都不能杀死这个1号进程。</p><pre><code class=\"language-shell\"># cat c-init-nosig.c\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nint main(int argc, char *argv[])\n{\n       printf(\"Process is sleeping\\n\");\n       while (1) {\n              sleep(100);\n       }\n\n       return 0;\n}\n</code></pre><pre><code class=\"language-shell\"># docker stop sig-proc;docker rm sig-proc\n# docker run --name sig-proc -d registry/sig-proc:v1 /c-init-nosig\n# docker exec -it sig-proc bash\n[root@5d3d42a031b1 /]# ps -ef\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 07:48 ?        00:00:00 /c-init-nosig\nroot         6     0  5 07:48 pts/0    00:00:00 bash\nroot        19     6  0 07:48 pts/0    00:00:00 ps -ef\n[root@5d3d42a031b1 /]# kill 1\n[root@5d3d42a031b1 /]# kill -9 1\n[root@5d3d42a031b1 /]# ps -ef\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 07:48 ?        00:00:00 /c-init-nosig\nroot         6     0  0 07:48 pts/0    00:00:00 bash\nroot        20     6  0 07:49 pts/0    00:00:00 ps -ef\n</code></pre><p>我们是不是这样就可以得出结论——“容器里的1号进程，完全忽略了SIGTERM和SIGKILL信号了”呢？你先别着急，我们再拿其他语言试试。</p><p>接下来，我们用<strong> Golang程序作为1号进程</strong>，我们再在容器中执行 <code>kill -9 1</code> 和 <code>kill 1</code> 。</p><p>这次，我们发现 <code>kill -9 1</code> 这个命令仍然不能杀死1号进程，也就是说，SIGKILL信号和之前的两个测试一样不起作用。</p><p><strong>但是，我们执行 <code>kill 1</code> 以后，SIGTERM这个信号把init进程给杀了，容器退出了。</strong></p><pre><code class=\"language-shell\"># cat go-init.go\npackage main\n\nimport (\n       \"fmt\"\n       \"time\"\n)\n\nfunc main() {\n       fmt.Println(\"Start app\\n\")\n       time.Sleep(time.Duration(100000) * time.Millisecond)\n}\n</code></pre><pre><code class=\"language-shell\"># docker stop sig-proc;docker rm sig-proc\n# docker run --name sig-proc -d registry/sig-proc:v1 /go-init\n# docker exec -it sig-proc bash\n\n\n[root@234a23aa597b /]# ps -ef\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  1 08:04 ?        00:00:00 /go-init\nroot        10     0  9 08:04 pts/0    00:00:00 bash\nroot        23    10  0 08:04 pts/0    00:00:00 ps -ef\n[root@234a23aa597b /]# kill -9 1\n[root@234a23aa597b /]# kill 1\n[root@234a23aa597b /]# [~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n</code></pre><p>对于这个测试结果，你是不是反而觉得更加困惑了？</p><p>为什么使用不同程序，结果就不一样呢？接下来我们就看看kill命令下达之后，Linux里究竟发生了什么事，我给你系统地梳理一下整个过程。</p><p>在我们运行 <code>kill 1</code> 这个命令的时候，希望把SIGTERM这个信号发送给1号进程，就像下面图里的<strong>带箭头虚线</strong>。</p><p>在Linux实现里，kill命令调用了 <strong>kill()的这个系统调用</strong>（所谓系统调用就是内核的调用接口）而进入到了内核函数sys_kill()， 也就是下图里的<strong>实线箭头</strong>。</p><p>而内核在决定把信号发送给1号进程的时候，会调用sig_task_ignored()这个函数来做个判断，这个判断有什么用呢？</p><p>它会决定内核在哪些情况下会把发送的这个信号给忽略掉。如果信号被忽略了，那么init进程就不能收到指令了。</p><p>所以，我们想要知道init进程为什么收到或者收不到信号，都要去看看 <strong>sig_task_ignored()的这个内核函数的实现。</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/ce/7f/cec445b6af1c0f678cc1b538bb03d67f.jpeg?wh=3200*1800\" alt=\"\" title=\"sig_task_ignored()内核函数实现示意图\"></p><p>在sig_task_ignored()这个函数中有三个if{}判断，第一个和第三个if{}判断和我们的问题没有关系，并且代码有注释，我们就不讨论了。</p><p>我们重点来看第二个if{}。我来给你分析一下，在容器中执行 <code>kill 1</code> 或者 <code>kill -9 1</code> 的时候，这第二个if{}里的三个子条件是否可以被满足呢？</p><p>我们来看下面这串代码，这里表示<strong>一旦这三个子条件都被满足，那么这个信号就不会发送给进程。</strong></p><pre><code class=\"language-shell\">kernel/signal.c\nstatic bool sig_task_ignored(struct task_struct *t, int sig, bool force)\n{\n        void __user *handler;\n        handler = sig_handler(t, sig);\n\n        /* SIGKILL and SIGSTOP may not be sent to the global init */\n        if (unlikely(is_global_init(t) &amp;&amp; sig_kernel_only(sig)))\n\n                return true;\n\n        if (unlikely(t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;\n            handler == SIG_DFL &amp;&amp; !(force &amp;&amp; sig_kernel_only(sig)))\n                return true;\n\n        /* Only allow kernel generated signals to this kthread */\n        if (unlikely((t-&gt;flags &amp; PF_KTHREAD) &amp;&amp;\n                     (handler == SIG_KTHREAD_KERNEL) &amp;&amp; !force))\n                return true;\n\n        return sig_handler_ignored(handler, sig);\n}\n\n</code></pre><p>接下来，我们就逐一分析一下这三个子条件，我们来说说这个\"!(force &amp;&amp; sig_kernel_only(sig))\" 。</p><p>第一个条件里force的值，对于同一个Namespace里发出的信号来说，调用值是0，所以这个条件总是满足的。</p><p>我们再来看一下第二个条件 “handler == SIG_DFL”，第二个条件判断信号的handler是否是SIG_DFL。</p><p>那么什么是SIG_DFL呢？<strong>对于每个信号，用户进程如果不注册一个自己的handler，就会有一个系统缺省的handler，这个缺省的handler就叫作SIG_DFL。</strong></p><p>对于SIGKILL，我们前面介绍过它是特权信号，是不允许被捕获的，所以它的handler就一直是SIG_DFL。这第二个条件对SIGKILL来说总是满足的。</p><p>对于SIGTERM，它是可以被捕获的。也就是说如果用户不注册handler，那么这个条件对SIGTERM也是满足的。</p><p>最后再来看一下第三个条件，\"t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE\"，这里的条件判断是这样的，进程必须是SIGNAL_UNKILLABLE的。</p><p>这个SIGNAL_UNKILLABLE flag是在哪里置位的呢？</p><p>可以参考我们下面的这段代码，在每个Namespace的init进程建立的时候，就会打上 <strong>SIGNAL_UNKILLABLE</strong> 这个标签，也就是说只要是1号进程，就会有这个flag，这个条件也是满足的。</p><pre><code class=\"language-shell\">kernel/fork.c\n                       if (is_child_reaper(pid)) {\n                                ns_of_pid(pid)-&gt;child_reaper = p;\n                                p-&gt;signal-&gt;flags |= SIGNAL_UNKILLABLE;\n                        }\n\n/*\n * is_child_reaper returns true if the pid is the init process\n * of the current namespace. As this one could be checked before\n * pid_ns-&gt;child_reaper is assigned in copy_process, we check\n * with the pid number.\n */\n\nstatic inline bool is_child_reaper(struct pid *pid)\n{\n        return pid-&gt;numbers[pid-&gt;level].nr == 1;\n}\n</code></pre><p>我们可以看出来，其实<strong>最关键的一点就是<span class=\"orange\"> <code>handler == SIG_DFL</code> </span>。Linux内核针对每个Nnamespace里的init进程，把只有default handler的信号都给忽略了。</strong></p><p>如果我们自己注册了信号的handler（应用程序注册信号handler被称作\"Catch the Signal\"），那么这个信号handler就不再是SIG_DFL 。即使是init进程在接收到SIGTERM之后也是可以退出的。</p><p>不过，由于SIGKILL是一个特例，因为SIGKILL是不允许被注册用户handler的（还有一个不允许注册用户handler的信号是SIGSTOP），那么它只有SIG_DFL handler。</p><p>所以init进程是永远不能被SIGKILL所杀，但是可以被SIGTERM杀死。</p><p>说到这里，我们该怎么证实这一点呢？我们可以做下面两件事来验证。</p><p><strong>第一件事，你可以查看1号进程状态中SigCgt Bitmap。</strong></p><p>我们可以看到，在Golang程序里，很多信号都注册了自己的handler，当然也包括了SIGTERM(15)，也就是bit 15。</p><p>而C程序里，缺省状态下，一个信号handler都没有注册；bash程序里注册了两个handler，bit 2和bit 17，也就是SIGINT和SIGCHLD，但是没有注册SIGTERM。</p><p>所以，C程序和bash程序里SIGTERM的handler是SIG_DFL（系统缺省行为），那么它们就不能被SIGTERM所杀。</p><p>具体我们可以看一下这段/proc系统的进程状态：</p><pre><code class=\"language-shell\">### golang init\n# cat /proc/1/status | grep -i SigCgt\nSigCgt:     fffffffe7fc1feff\n\n### C init\n# cat /proc/1/status | grep -i SigCgt\nSigCgt:     0000000000000000\n\n### bash init\n# cat /proc/1/status | grep -i SigCgt\nSigCgt:     0000000000010002\n\n</code></pre><p><strong>第二件事，给C程序注册一下SIGTERM handler，捕获SIGTERM。</strong></p><p>我们调用signal()系统调用注册SIGTERM的handler，在handler里主动退出，再看看容器中 <code>kill 1</code> 的结果。</p><p>这次我们就可以看到，<strong>在进程状态的SigCgt bitmap里，bit 15 (SIGTERM)已经置位了。同时，运行 <code>kill 1</code> 也可以把这个C程序的init进程给杀死了。</strong></p><pre><code class=\"language-shell\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid sig_handler(int signo)\n{\n    if (signo == SIGTERM) {\n           printf(\"received SIGTERM\\n\");\n           exit(0);\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    signal(SIGTERM, sig_handler);\n\n    printf(\"Process is sleeping\\n\");\n    while (1) {\n           sleep(100);\n    }\n    return 0;\n}\n</code></pre><pre><code class=\"language-shell\"># docker stop sig-proc;docker rm sig-proc\n# docker run --name sig-proc -d registry/sig-proc:v1 /c-init-sig\n# docker exec -it sig-proc bash\n[root@043f4f717cb5 /]# ps -ef\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0 09:05 ?        00:00:00 /c-init-sig\nroot         6     0 18 09:06 pts/0    00:00:00 bash\nroot        19     6  0 09:06 pts/0    00:00:00 ps -ef\n\n[root@043f4f717cb5 /]# cat /proc/1/status | grep SigCgt\nSigCgt: 0000000000004000\n[root@043f4f717cb5 /]# kill 1\n# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n</code></pre><p>好了，到这里我们可以确定这两点：</p><ol>\n<li><code>kill -9 1</code> 在容器中是不工作的，内核阻止了1号进程对SIGKILL特权信号的响应。</li>\n<li><code>kill 1</code> 分两种情况，如果1号进程没有注册SIGTERM的handler，那么对SIGTERM信号也不响应，如果注册了handler，那么就可以响应SIGTERM信号。</li>\n</ol><h2>重点总结</h2><p>好了，今天的内容讲完了。我们来总结一下。</p><p>这一讲我们主要讲了init进程。围绕这个知识点，我提出了一个真实发生的问题：“为什么我在容器中不能kill 1号进程?”。</p><p>想要解决这个问题，我们需要掌握两个基本概念。</p><p>第一个概念是Linux 1号进程。<strong>它是第一个用户态的进程。它直接或者间接创建了Namespace中的其他进程。</strong></p><p>第二个概念是Linux信号。Linux有31个基本信号，进程在处理大部分信号时有三个选择：<strong>忽略、捕获和缺省行为。其中两个特权信号SIGKILL和SIGSTOP不能被忽略或者捕获。</strong></p><p>只知道基本概念还不行，我们还要去解决问题。我带你尝试了用bash, C语言还有Golang程序作为容器init进程，发现它们对 kill 1的反应是不同的。</p><p>因为信号的最终处理都是在Linux内核中进行的，因此，我们需要对Linux内核代码进行分析。</p><p>容器里1号进程对信号处理的两个要点，这也是这一讲里我想让你记住的两句话：</p><ol>\n<li><strong>在容器中，1号进程永远不会响应SIGKILL和SIGSTOP这两个特权信号；</strong></li>\n<li><strong>对于其他的信号，如果用户自己注册了handler，1号进程可以响应。</strong></li>\n</ol><h2>思考题</h2><p>这一讲的最开始，有这样一个C语言的init进程，它没有注册任何信号的handler。如果我们从Host Namespace向它发送SIGTERM，会发生什么情况呢？</p><p>欢迎留言和我分享你的想法。如果你的朋友也对1号进程有困惑，欢迎你把这篇文章分享给他，说不定就帮他解决了一个难题。</p>","comments":[{"had_liked":false,"id":263020,"user_name":"赵守忠[开心每一天]","can_delete":false,"product_type":"c1","uid":1042303,"ip_address":"","ucode":"B5A60C6AB6B098","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e7/7f/78401028.jpg","comment_is_top":false,"comment_ctime":1605950041,"is_pvip":false,"replies":[{"id":"95489","content":"@赵守忠[开心每一天]<br>非常好的发现啊！<br>tini的确没有注册SIGTERM，它的退出并不是因为SIGTERM的信号让它退出的，而是它发现它子进程都退出之后，主动退出的，这样容器也退出了。<br><br>可以看一下tini的源代码，它把所有接收到的信号(除了SIGHILD)都转发给了子进程，也包括了SIGTERM, 那么子进程收到SIGTERM就退出了，而tini自己可以收到SIGHILD, 然后tini自己退出，并且容器退出。<br><br>tini 的源代码和主循环：<br>https:&#47;&#47;github.com&#47;krallin&#47;tini&#47;blob&#47;master&#47;src&#47;tini.c<br>        while (1) {<br>                &#47;* Wait for one signal, and forward it *&#47;<br>                if (wait_and_forward_signal(&amp;parent_sigset, child_pid)) {<br>                        return 1;<br>                }<br><br>                &#47;* Now, reap zombies *&#47;<br>                if (reap_zombies(child_pid, &amp;child_exitcode)) {<br>                        return 1;<br>                }<br><br>                if (child_exitcode != -1) {<br>                        PRINT_TRACE(&quot;Exiting: child has exited&quot;);<br>                        return child_exitcode;<br>                }<br>        }","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606017699,"ip_address":"","comment_id":263020,"utype":1}],"discussion_count":3,"race_medal":0,"score":"203469412953","product_id":100063801,"comment_content":"kill 1 分两种情况，如果 1 号进程没有注册 SIGTERM 的 handler，那么对 SIGTERM 信号也不响应，如果注册了 handler，那么就可以响应 SIGTERM 信号。<br>---在k8s的容器环境内测试，基于tini。和老师讲的有些出入：<br>bash-5.0# ps -ef<br>PID   USER     TIME  COMMAND<br>    1 root      0:00 &#47;tini -- &#47;bin&#47;sh -c java  -javaagent:&#47;opt&#47;jmx&#47;jmx.jar=7080:config.yaml  $JAVA_OPTS  -jar &#47;app.jar<br>bash-5.0# cat &#47;proc&#47;1&#47;status|grep SigCgt<br>SigCgt: 0000000000000000<br>bash-5.0# kill 1<br>bash-5.0# command terminated with non-zero exit code: Error executing in Docker Container: 137<br><br>实际情况是容器重启了。响应了kill 1操作。","like_count":48,"discussions":[{"author":{"id":1156557,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/cd/3aff5d57.jpg","nickname":"Alery","note":"","ucode":"08F3F49181E67B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":330509,"discussion_content":"老师，我有个疑问哈，tini没有注册SIGTERM，按照前面将的，内核是不会把这个信号发送给tini进程的，为啥它又能接收所有的信号(除了SIGHILD)并转发给子进程呢？我对这块的理解的不是很清晰，望指教。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1606638175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1160951,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b6/f7/3c3b1385.jpg","nickname":"海胆阶段","note":"","ucode":"7A8C4BB4D0CDB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1156557,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a5/cd/3aff5d57.jpg","nickname":"Alery","note":"","ucode":"08F3F49181E67B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543464,"discussion_content":"因为tini 通过的是先block信号再unblock的方式，而blocked的信号是不能被忽视的，所以tini会收到并且转发给child process。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641171069,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":330509,"ip_address":""},"score":543464,"extra":""}]},{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510073,"discussion_content":"@赵守忠[开心每一天]\n非常好的发现啊！\ntini的确没有注册SIGTERM，它的退出并不是因为SIGTERM的信号让它退出的，而是它发现它子进程都退出之后，主动退出的，这样容器也退出了。\n\n可以看一下tini的源代码，它把所有接收到的信号(除了SIGHILD)都转发给了子进程，也包括了SIGTERM, 那么子进程收到SIGTERM就退出了，而tini自己可以收到SIGHILD, 然后tini自己退出，并且容器退出。\n\ntini 的源代码和主循环：\nhttps://github.com/krallin/tini/blob/master/src/tini.c\n        while (1) {\n                /* Wait for one signal, and forward it */\n                if (wait_and_forward_signal(&amp;amp;parent_sigset, child_pid)) {\n                        return 1;\n                }\n\n                /* Now, reap zombies */\n                if (reap_zombies(child_pid, &amp;amp;child_exitcode)) {\n                        return 1;\n                }\n\n                if (child_exitcode != -1) {\n                        PRINT_TRACE(&amp;quot;Exiting: child has exited&amp;quot;);\n                        return child_exitcode;\n                }\n        }","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606017699,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262481,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1605749349,"is_pvip":false,"replies":[{"id":"95265","content":"@Helios,<br>很好的一个问题。<br>很多介绍容器的文章可能都会强调容器是进程，不过它们讨论的背景应该是和虚拟机做比较之后这么说的，因为在容器之前虚拟机是云平台上最流行的技术。强调容器是进程的目的是区分容器与虚拟机的差别，但是我不认为这个是容器的本质。<br><br>其实无论是namespace (pid namespace)还是cgroups都是在管理进程， 容器中运行是进程，这个是个明显的特征了，但不是本质。<br><br>我们如果换一个角度去思考，如果容器流行先于虚拟机技术， 我们是否还会强调容器是进程了呢？","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605759446,"ip_address":"","comment_id":262481,"utype":1}],"discussion_count":4,"race_medal":0,"score":"117569866341","product_id":100063801,"comment_content":"有一种老师说了一大圈，但是没有说容器的本质就是宿主机上的一个进程这个本质。","like_count":28,"discussions":[{"author":{"id":1035744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","nickname":"朱雯","note":"","ucode":"064C45FBF6B51F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327186,"discussion_content":"进程发明是计算机最有利的发明之一 但是在进程发明之前 计算机是怎么工作的呢 我的理解是 其实就是相当于单进程运行  进程可以管理文件 io 网络 主存等等 一定程度上来说 操作系统能做的 进程都能做 所以我在很久之前一直认为进程就是操作系统的一种抽象。docker容器本质上是进程其实在我看来是相对于操作系统来说的 只要你跑起来 我就觉得你是进程 这种情况下 tomcat是进程 docker是进程 除了虚拟机以外都是进程 但是站在程序员甚至用户的角度来看 他有是啥呢 是服务？是操作系统 还是程序。 老师的回答里面问了一个问题 那就是如果容器技术出现在虚拟机之前 那还会强调他进程的本质吗 其实这并非一个假设 而是已经发生的历史 borg系统解决的不就是进程的调度问题吗 解决进程调度问题的时候  也没有特别强调这个进程是进程 然后给了他进行各种设置。另外还有一点我的想法是 强调容器是进程其实是为了告诉我们k8s是操作系统。如果综合两种看法 最后我的结论是 容器是准虚拟机。   有点乱 希望能带来思考","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1605762291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1419387,"avatar":"https://static001.geekbang.org/account/avatar/00/15/a8/7b/98f4a8b9.jpg","nickname":"糖果罐","note":"","ucode":"112D36DEC528BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555904,"discussion_content":"之前接收到的说法一直是容器的本质是进程，但今天听到认同老师的说法，觉得更贴切，容器的本质是通过Linux内核Namespace和Cgroups配合管理行程的一种模式，这种管理进程的模式才是容器本质，而不是进程本身，因为在linux中运行的都是进程，个人认为进程二字不足以表达容器的核心思想。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1647096999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509851,"discussion_content":"@Helios,\n很好的一个问题。\n很多介绍容器的文章可能都会强调容器是进程，不过它们讨论的背景应该是和虚拟机做比较之后这么说的，因为在容器之前虚拟机是云平台上最流行的技术。强调容器是进程的目的是区分容器与虚拟机的差别，但是我不认为这个是容器的本质。\n\n其实无论是namespace (pid namespace)还是cgroups都是在管理进程， 容器中运行是进程，这个是个明显的特征了，但不是本质。\n\n我们如果换一个角度去思考，如果容器流行先于虚拟机技术， 我们是否还会强调容器是进程了呢？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605759446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1380758,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","nickname":"Helios","note":"","ucode":"BE6B98EE8F0D09","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327369,"discussion_content":"容器肯定是后于物理机的吧，这个不能还顺序了。把时间驳回八年前，kvm还不咋地，我们只能把程序放在物理机，承载服务的最小单位就是物理机，对于外界服务和物理机可以画等号，能操作服务基本等于能操作机器了。\n\n容器呢，和谁画等号，操作容器等于操作谁？\n\n只是发表自己的看法，本质这个东西还是要有对比的，没有对比谁知道本质是啥，思维还是要和存在比才能辩论何者为本源的。\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605804041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264643,"user_name":"daydreamer","can_delete":false,"product_type":"c1","uid":1339168,"ip_address":"","ucode":"375D9D4F9A7AF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/6f/20/53cb569d.jpg","comment_is_top":false,"comment_ctime":1606556709,"is_pvip":false,"replies":[{"id":"97564","content":"@daydreamer<br>赞！","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1608476934,"ip_address":"","comment_id":264643,"utype":1}],"discussion_count":3,"race_medal":0,"score":"53146164261","product_id":100063801,"comment_content":"思考题：<br>kill &lt;pid&gt; 不可以杀掉容器init进程<br>kill -9 &lt;pid&gt; 可以<br>不同点在于SIGTERM不是内核信号，所以!(force &amp;&amp; sig_kernel_only(sig)为True，加上前面两个if也为true，所以忽略；SIGKILL是内核信号 !(force &amp;&amp; sig_kernel_only(sig)为False，信号没有办法忽略，所以被杀掉","like_count":13,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510635,"discussion_content":"@daydreamer\n赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608476934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1160951,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b6/f7/3c3b1385.jpg","nickname":"海胆阶段","note":"","ucode":"7A8C4BB4D0CDB8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543183,"discussion_content":"Likewise, a process in an ancestor namespace can—subject to the\nusual permission checks described in kill(2)—send signals to the\n&#34;init&#34; process of a child PID namespace only if the &#34;init&#34;\nprocess has established a handler for that signal. (Within the\nhandler, the siginfo_t si_pid field described in sigaction(2)\nwill be zero.) SIGKILL or SIGSTOP are treated exceptionally:\nthese signals are forcibly delivered when sent from an ancestor\nPID namespace. Neither of these signals can be caught by the\n&#34;init&#34; process, and so will result in the usual actions\nassociated with those signals (respectively, terminating and\nstopping the process).","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640999798,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2608728,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ce/58/71ed845f.jpg","nickname":"Dexter","note":"","ucode":"909CABC4AC4AC9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409998,"discussion_content":"如何知道这个信号是不是内核信号？怎么查看的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635566878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262935,"user_name":"上邪忘川","can_delete":false,"product_type":"c1","uid":1276588,"ip_address":"","ucode":"1C4459917B038D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIz9dKN1C8rKQoaVtmEGdzObhlia6zAfTsPYOm4ibz39VjTbu7Aia1LyeedHR26b6nxUtcCufpichcYgw/132","comment_is_top":false,"comment_ctime":1605888027,"is_pvip":false,"replies":[{"id":"95384","content":"谢谢 @上邪忘川， 很好的补充材料！<br>","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605918088,"ip_address":"","comment_id":262935,"utype":1}],"discussion_count":1,"race_medal":0,"score":"53145495579","product_id":100063801,"comment_content":"从网上找到了不错的关于SigCgt 掩码位的解释，不懂的可以看一下，豁然开朗。https:&#47;&#47;qastack.cn&#47;unix&#47;85364&#47;how-can-i-check-what-signals-a-process-is-listening-to","like_count":13,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510040,"discussion_content":"谢谢 @上邪忘川， 很好的补充材料！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605918088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262469,"user_name":"莫名","can_delete":false,"product_type":"c1","uid":1007254,"ip_address":"","ucode":"E28F2602BA25DD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","comment_is_top":false,"comment_ctime":1605747316,"is_pvip":false,"replies":[{"id":"95244","content":"谢谢 @莫名！<br>仔细读文档也是很有用的！","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605753888,"ip_address":"","comment_id":262469,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40260452980","product_id":100063801,"comment_content":"man pid_namespace 提到了老师在文中强调的两个细节。<br><br>-----------------------------<br><br>Only signals for which the &quot;init&quot; process has established a signal<br>       handler can be sent to the &quot;init&quot; process by other members of the PID<br>       namespace.  This restriction applies even to privileged processes,<br>       and prevents other members of the PID namespace from accidentally<br>       killing the &quot;init&quot; process.<br><br>       Likewise, a process in an ancestor namespace can—subject to the usual<br>       permission checks described in kill(2)—send signals to the &quot;init&quot;<br>       process of a child PID namespace only if the &quot;init&quot; process has<br>       established a handler for that signal.  SIGKILL or SIGSTOP are treated exceptionally: these signals are<br>       forcibly delivered when sent from an","like_count":10,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509844,"discussion_content":"谢谢 @莫名！\n仔细读文档也是很有用的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605753888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265766,"user_name":"维c","can_delete":false,"product_type":"c1","uid":2048787,"ip_address":"","ucode":"FAD5EE298D5F2D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/43/13/9b24c185.jpg","comment_is_top":false,"comment_ctime":1607006320,"is_pvip":false,"replies":[{"id":"96611","content":"@维c<br>很好的分析！force 由发送信号的进程和接受信号进程是否在同一个namespace里决定。你可以再看一下代码。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1607056895,"ip_address":"","comment_id":265766,"utype":1}],"discussion_count":2,"race_medal":0,"score":"31671777392","product_id":100063801,"comment_content":"查了一下资料，貌似sig_kernel_only函数是用了判断信号是不是kill或者stop的，是这两个信号才会返回true，这就意味着force不为0，同时信号是kill或者stop的时候信号是不会被忽略的，这也就解释了为什么宿主机是可以通过kill信号来杀掉容器里的进程，而sigterm由于force的值可能会被忽略，那么force的值又是又什么决定的呢？","like_count":8,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511035,"discussion_content":"@维c\n很好的分析！force 由发送信号的进程和接受信号进程是否在同一个namespace里决定。你可以再看一下代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607056895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2608728,"avatar":"https://static001.geekbang.org/account/avatar/00/27/ce/58/71ed845f.jpg","nickname":"Dexter","note":"","ucode":"909CABC4AC4AC9","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544638,"discussion_content":"很好的解释，force是由发送信号进程和接受信号进程是否在同一个ns决定","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641613085,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262733,"user_name":"良凯尔","can_delete":false,"product_type":"c1","uid":1806492,"ip_address":"","ucode":"8204DA338BA8F4","user_header":"https://static001.geekbang.org/account/avatar/00/1b/90/9c/288e4db2.jpg","comment_is_top":false,"comment_ctime":1605834387,"is_pvip":true,"replies":[{"id":"95350","content":"在宿主机上kill容器的1号进程是可以的。不过，有时候容器的用户没有宿主机登陆的权限。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605847076,"ip_address":"","comment_id":262733,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27375638163","product_id":100063801,"comment_content":"虽然在容器内kill 1号进程行不通，但是我可以在宿主上kill容器的1号进程来达到重启容器的目的，是这样吗？","like_count":7,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509946,"discussion_content":"在宿主机上kill容器的1号进程是可以的。不过，有时候容器的用户没有宿主机登陆的权限。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605847076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2027828,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f1/34/6978db6a.jpg","nickname":"果果","note":"","ucode":"458AC5EC0A8790","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":570898,"discussion_content":"为什么宿主机能kill 一号进程啊，这个不是也是得看容器中的一号进程是否监听了对应的信号来进行判断的吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651987877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":509946,"ip_address":""},"score":570898,"extra":""}]}]},{"had_liked":false,"id":271839,"user_name":"Action","can_delete":false,"product_type":"c1","uid":1239234,"ip_address":"","ucode":"FFFD1537C6BB3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/c2/77a413a7.jpg","comment_is_top":false,"comment_ctime":1609835208,"is_pvip":false,"replies":[{"id":"98655","content":"至于为什么即使在宿主机机上向容器1号进程发送SIGTERM，在1号进程没有注册handler的情况下，不能被杀死的问题 （思考题）， 原因是这样的：<br><br>开始要看内核里的那段代码，“ !(force &amp;&amp; sig_kernel_only(sig))”，<br>虽然由不同的namespace发送信号， 虽然force是1了，但是sig_kernel_only(sig)对于SIGTERM来说还是0， 这里是个&amp;&amp;, 那么 !(1 &amp;&amp; 0) = 1。<br><br>#define sig_kernel_only(sig) siginmask(sig, SIG_KERNEL_ONLY_MASK)<br>#define SIG_KERNEL_ONLY_MASK (\\<br>        rt_sigmask(SIGKILL) | rt_sigmask(SIGSTOP))","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1609946052,"ip_address":"","comment_id":271839,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23084671688","product_id":100063801,"comment_content":"Host Namespace 向c程序init进程，发送SIGTERM，忽略了，发送SIGKILL杀掉了，是特权信号就给杀掉了对吧？ 还有一块不明白，在handler == SIG_DFL这里，SIGTERM，它是可以被捕获的。也就是说如果用户不注册handler，那么这个条件对 SIGTERM 也是满足的，为什么呢？","like_count":6,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513062,"discussion_content":"至于为什么即使在宿主机机上向容器1号进程发送SIGTERM，在1号进程没有注册handler的情况下，不能被杀死的问题 （思考题）， 原因是这样的：\n\n开始要看内核里的那段代码，“ !(force &amp;amp;&amp;amp; sig_kernel_only(sig))”，\n虽然由不同的namespace发送信号， 虽然force是1了，但是sig_kernel_only(sig)对于SIGTERM来说还是0， 这里是个&amp;amp;&amp;amp;, 那么 !(1 &amp;amp;&amp;amp; 0) = 1。\n\n#define sig_kernel_only(sig) siginmask(sig, SIG_KERNEL_ONLY_MASK)\n#define SIG_KERNEL_ONLY_MASK (\\\n        rt_sigmask(SIGKILL) | rt_sigmask(SIGSTOP))","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609946052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262426,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1605715402,"is_pvip":true,"replies":[{"id":"95262","content":"@朱雯<br>很好的问题！我在文中只是说了31个posix标准里的signal. Linux 里还有编号32-64的real-time signal的扩展定义。因为和这一讲的问题没有太大的关系，我没有具体展开了。<br>","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605758761,"ip_address":"","comment_id":262426,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23080551882","product_id":100063801,"comment_content":"关于SigCgt bitmap 其实我是有些疑惑的，第一为什么是16位？我最开始是这样猜测的，就是一个位置代表一个信号量，那最多只能说明第一到第十六的信号量。 后面看到加了handle处理的函数是这个样子<br><br>if (signo == SIGTERM) { printf(&quot;received SIGTERM\\n&quot;); exit(0); }<br>然后他的sigcgt bitmap是:0000000000004000 ，如果按照这样的算法，一个数字代表4位，那一共16位，应该有64种信号量，为啥只有31种还是32种，剩下的是没定义？","like_count":5,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509826,"discussion_content":"@朱雯\n很好的问题！我在文中只是说了31个posix标准里的signal. Linux 里还有编号32-64的real-time signal的扩展定义。因为和这一讲的问题没有太大的关系，我没有具体展开了。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605758761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274735,"user_name":"白夜行","can_delete":false,"product_type":"c1","uid":2170645,"ip_address":"","ucode":"6D9ED88EA1B8FB","user_header":"https://static001.geekbang.org/account/avatar/00/21/1f/15/bacf9770.jpg","comment_is_top":false,"comment_ctime":1611139361,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18791008545","product_id":100063801,"comment_content":"老师讲的太棒了！　留言区也能学到很多。<br><br>请教老师一个可能不太相关的问题，golang为什么要默认注册很多信号处理函数，而不是保持C的行为？　","like_count":4},{"had_liked":false,"id":262497,"user_name":"1900","can_delete":false,"product_type":"c1","uid":1449081,"ip_address":"","ucode":"1C031D7B7AD884","user_header":"https://static001.geekbang.org/account/avatar/00/16/1c/79/5ec77bcd.jpg","comment_is_top":false,"comment_ctime":1605751550,"is_pvip":false,"replies":[{"id":"95303","content":"@1900, 如果可以的话，你可以动手试一下，看看结果是不是和你分析的一样 :-)","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605797507,"ip_address":"","comment_id":262497,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18785620734","product_id":100063801,"comment_content":"在容器中不能响应SIGKILL 和 SIGSTOP，但是在宿主机中可以响应，因为在宿主机中所看到的“容器1号进程”在宿主机上只是一个普通进程","like_count":4,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509858,"discussion_content":"@1900, 如果可以的话，你可以动手试一下，看看结果是不是和你分析的一样 :-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605759707,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361330,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c5/b2/5b339c64.jpg","nickname":"K-Li","note":"","ucode":"3091322142E43E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329364,"discussion_content":"我验证了下，在宿主机上可以通过 SIGKILL来杀掉容器1号进程。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1606372304,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1442097,"avatar":"https://static001.geekbang.org/account/avatar/00/16/01/31/4d116521.jpg","nickname":"鹏鹏哥","note":"","ucode":"28452AB202EA9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332559,"discussion_content":"请教怎么实现的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607260741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262479,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1605749107,"is_pvip":false,"replies":[{"id":"95241","content":"&gt; 不知道什么要在容器内执行，直接在去宿主机上docker kill不行么。或者直接edit一下编排文件加个环境变量啥的，不就能触发原地升级么。<br><br>在生产环境中，用户是没有权限登陆宿主机的。 在Pod spec部分，runtime允许修改的只有 cotainer image了。 <br><br>&gt; 比较新的信号应该不止31个了，还增加了31个可靠信号，为了解决以前linux中信号堆积忽略信号的问题。<br><br>你说的没错，还有新的 32-64 可靠信号。因为和这一讲的问题没有太大关系，在这里就不展开了。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605753487,"ip_address":"","comment_id":262479,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18785618291","product_id":100063801,"comment_content":"不知道什么要在容器内执行，直接在去宿主机上docker kill不行么。或者直接edit一下编排文件加个环境变量啥的，不就能触发原地升级么。<br>比较新的信号应该不止31个了，还增加了31个可靠信号，为了解决以前linux中信号堆积忽略信号的问题。<br><br>","like_count":5,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509850,"discussion_content":"&amp;gt; 不知道什么要在容器内执行，直接在去宿主机上docker kill不行么。或者直接edit一下编排文件加个环境变量啥的，不就能触发原地升级么。\n\n在生产环境中，用户是没有权限登陆宿主机的。 在Pod spec部分，runtime允许修改的只有 cotainer image了。 \n\n&amp;gt; 比较新的信号应该不止31个了，还增加了31个可靠信号，为了解决以前linux中信号堆积忽略信号的问题。\n\n你说的没错，还有新的 32-64 可靠信号。因为和这一讲的问题没有太大关系，在这里就不展开了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605753487,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262179,"user_name":"Geek_71d4ac","can_delete":false,"product_type":"c1","uid":1513070,"ip_address":"","ucode":"81FBA4DA79F5E4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibb1HJTBX85TuIYRQv3eUxib5Zdc5paH1mULBaLFZf0N6C1WxLrw6ZUc4oiaEPQEdfrQMkIjIYtTib66l8VfgrtHRQ/132","comment_is_top":false,"comment_ctime":1605659452,"is_pvip":false,"replies":[{"id":"95137","content":"@Geek_71d4ac<br>你说的没错， D state (uninterruptible) 进程 还有 Zombie进程都是不能接受任何信号的。我在后面的章节里还有介绍。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605668539,"ip_address":"","comment_id":262179,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18785528636","product_id":100063801,"comment_content":"关于特权信号的那一段表述，我觉得是有问题的。当任务处于task uninterrupt状态时，是不能接收任何信号的。","like_count":4,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509720,"discussion_content":"@Geek_71d4ac\n你说的没错， D state (uninterruptible) 进程 还有 Zombie进程都是不能接受任何信号的。我在后面的章节里还有介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605668539,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262647,"user_name":"JianXu","can_delete":false,"product_type":"c1","uid":1033219,"ip_address":"","ucode":"2A61BDBB573BDC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/03/f753fda7.jpg","comment_is_top":false,"comment_ctime":1605791215,"is_pvip":false,"replies":[{"id":"95307","content":"@JIanxu, <br>&gt; 因为不是宿主机上的第一个进程所以 UNKILLABLE 也没有置位<br><br>这个SIGNAL_UNKILLABLE 是目标进程（容器里的1号进程）在创建的时候置位的，所以无论发送信号的进程在容器namespace还是在host namespace, 这个flag都是存在的。<br><br>&gt; 能不能进一步介绍一下为什么在Kernel 里面要放置这三个 if 语句来 ignore signal 呢？<br><br>这里可以看一下这段代码最初check-in的comments. 我的理解是如果1号进程被杀，会是整个系统处于混乱并且难调试的状态，我们要尽量的避免这种情况。<br><br>commit 86989c41b5ea08776c450cb759592532314a4ed6<br>Author: Eric W. Biederman &lt;ebiederm@xmission.com&gt;<br>Date:   Thu Jul 19 19:47:27 2018 -0500<br><br>    signal: Always ignore SIGKILL and SIGSTOP sent to the global init<br><br>    If the first process started (aka &#47;sbin&#47;init) receives a SIGKILL it<br>    will panic the system if it is delivered.  Making the system unusable<br>    and undebugable.  It isn&#39;t much better if the first process started<br>    receives SIGSTOP.<br><br>    So always ignore SIGSTOP and SIGKILL sent to init.<br><br>    This is done in a separate clause in sig_task_ignored as force_sig_info<br>    can clear SIG_UNKILLABLE and this protection should work even then.<br><br>    Reviewed-by: Thomas Gleixner &lt;tglx@linutronix.de&gt;<br>    Signed-off-by: &quot;Eric W. Biederman&quot; &lt;ebiederm@xmission.com&gt;<br>","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605799133,"ip_address":"","comment_id":262647,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10195725807","product_id":100063801,"comment_content":"if (unlikely(t-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp; handler == SIG_DFL &amp;&amp; !(force &amp;&amp; sig_kernel_only(sig))) { return true;}<br><br>老师, 我是不是可以这样理解，在容器内部的时候对于没有安装SIGTERM handler的情况下，force=0 并且SIGNAL_UNKILLABLE 也是置位的，所以这个if 语句返回真，所以SIGTERM 被忽略。但是在宿主机上的时候，因为不是同一个namespace 所以force = 1 ，因为不是宿主机上的第一个进程所以 UNKILLABLE 也没有置位(其实在force=1的时候已经不重要了) 所以这个 if 返回false,  而因为不是Kernal sig, 所以接下来第三个 if 也不会返回true,  于是这三个if 都不会起作用，所以从宿主机可以干掉该进程。<br><br>能不能进一步介绍一下为什么在Kernel 里面要放置这三个 if 语句来 ignore signal 呢？","like_count":2,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509914,"discussion_content":"@JIanxu, \n&amp;gt; 因为不是宿主机上的第一个进程所以 UNKILLABLE 也没有置位\n\n这个SIGNAL_UNKILLABLE 是目标进程（容器里的1号进程）在创建的时候置位的，所以无论发送信号的进程在容器namespace还是在host namespace, 这个flag都是存在的。\n\n&amp;gt; 能不能进一步介绍一下为什么在Kernel 里面要放置这三个 if 语句来 ignore signal 呢？\n\n这里可以看一下这段代码最初check-in的comments. 我的理解是如果1号进程被杀，会是整个系统处于混乱并且难调试的状态，我们要尽量的避免这种情况。\n\ncommit 86989c41b5ea08776c450cb759592532314a4ed6\nAuthor: Eric W. Biederman &amp;lt;ebiederm@xmission.com&amp;gt;\nDate:   Thu Jul 19 19:47:27 2018 -0500\n\n    signal: Always ignore SIGKILL and SIGSTOP sent to the global init\n\n    If the first process started (aka /sbin/init) receives a SIGKILL it\n    will panic the system if it is delivered.  Making the system unusable\n    and undebugable.  It isn&amp;#39;t much better if the first process started\n    receives SIGSTOP.\n\n    So always ignore SIGSTOP and SIGKILL sent to init.\n\n    This is done in a separate clause in sig_task_ignored as force_sig_info\n    can clear SIG_UNKILLABLE and this protection should work even then.\n\n    Reviewed-by: Thomas Gleixner &amp;lt;tglx@linutronix.de&amp;gt;\n    Signed-off-by: &amp;quot;Eric W. Biederman&amp;quot; &amp;lt;ebiederm@xmission.com&amp;gt;\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605799133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262443,"user_name":"争光 Alan","can_delete":false,"product_type":"c1","uid":1336328,"ip_address":"","ucode":"338534F909AF03","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/08/0287f41f.jpg","comment_is_top":false,"comment_ctime":1605728224,"is_pvip":false,"replies":[{"id":"95250","content":"@争光Alan, 谢谢，很好的建议！<br>我在这一章的最后，也拿了tini做了example来做一些简单best practice的说明。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605754350,"ip_address":"","comment_id":262443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10195662816","product_id":100063801,"comment_content":"能不能讲完后，讲下社区的最佳实践，比如docker现在提供了docker run --init参数避免这个问题，内核层面有没有相关的优化跟进","like_count":2,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509834,"discussion_content":"@争光Alan, 谢谢，很好的建议！\n我在这一章的最后，也拿了tini做了example来做一些简单best practice的说明。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605754350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262427,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1605715784,"is_pvip":true,"replies":[{"id":"95299","content":"&gt; 啥叫从host namespace向他发送sigterm，这是啥意思，是宿主机对他发送sigterm吗<br>是的，在宿主机上的缺省namespace是host namespace.<br><br>&gt; 不同的namespace，force不一定为0<br>是的， signal sender不在同一个namespace的时候， force不为0.<br><br>&gt; 我的问题在于SIGNAL_UNKILLABLE 标签还会不会打上，打上以后是对宿主机这个标签也生效吗。<br>进程创建后这个标签是一直有的，只是pid在容器namespace里看到的是1，而在宿主机的namespace里是另外一个pid值","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605793895,"ip_address":"","comment_id":262427,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10195650376","product_id":100063801,"comment_content":"关于思考题：<br>这一讲的最开始，有这样一个 C 语言的 init 进程，它没有注册任何信号的 handler。如果我们从 Host Namespace 向它发送 SIGTERM，会发生什么情况呢？<br>啥叫从host namespace向他发送sigterm，这是啥意思，是宿主机对他发送sigterm吗，宿主机发送，那就直接把他杀了，不仅法sigterm会杀，发kill也多半会杀，因为在宿主机，不同的namespace，force不一定为0，所以肯定不会被忽略，我的问题在于SIGNAL_UNKILLABLE 标签还会不会打上，打上以后是对宿主机这个标签也生效吗。","like_count":2,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509827,"discussion_content":"&amp;gt; 啥叫从host namespace向他发送sigterm，这是啥意思，是宿主机对他发送sigterm吗\n是的，在宿主机上的缺省namespace是host namespace.\n\n&amp;gt; 不同的namespace，force不一定为0\n是的， signal sender不在同一个namespace的时候， force不为0.\n\n&amp;gt; 我的问题在于SIGNAL_UNKILLABLE 标签还会不会打上，打上以后是对宿主机这个标签也生效吗。\n进程创建后这个标签是一直有的，只是pid在容器namespace里看到的是1，而在宿主机的namespace里是另外一个pid值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605757724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324772,"user_name":"寻道客小林","can_delete":false,"product_type":"c1","uid":1599380,"ip_address":"","ucode":"DA14317DC1D8FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/67/94/cc1cbccd.jpg","comment_is_top":false,"comment_ctime":1638613309,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5933580605","product_id":100063801,"comment_content":"真的很干！这一节专注的学了3个小时，只有自己动手实现才能体会的更深入。感谢程远老师的精彩讲解！就羡慕这种懂技术又会布道的老师！<br>关于信号的资料，大家可以参考《深入理解Linux内核》第十一章","like_count":1},{"had_liked":false,"id":307441,"user_name":"xuelangos","can_delete":false,"product_type":"c1","uid":1284091,"ip_address":"","ucode":"E05A015BF8957A","user_header":"https://static001.geekbang.org/account/avatar/00/13/97/fb/2737a4e4.jpg","comment_is_top":false,"comment_ctime":1629103850,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5924071146","product_id":100063801,"comment_content":"那么Java有没有注册handler呢","like_count":1},{"had_liked":false,"id":274442,"user_name":"Geek_8664a7","can_delete":false,"product_type":"c1","uid":1932583,"ip_address":"","ucode":"86F71BFF814D77","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqiapnDZCf0DZvvzcB5CGibib5QDNhAX8nGY9Y5ygC9DUUwJwN4ASVv7MmIzM5vhS03zSfxibKgYTXyKg/132","comment_is_top":false,"comment_ctime":1611023588,"is_pvip":false,"replies":[{"id":"99956","content":"1. 你可以解决程序无法连接数据而退出的问题。<br>2. 或者你需要一个controllerl来监控容器状态，自动使容器重启，这个如果使用kubernetes就可以了","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1611546984,"ip_address":"","comment_id":274442,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5905990884","product_id":100063801,"comment_content":"老师，请教下，我用docker方式起了MSSQL server exporter来监控数据库，但容器经常会退出(系统资源充足)，我看日志最后是无法连接数据库了，但数据库是Azure上的，都是正常的，是否有办法让容器自动重连数据库","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514019,"discussion_content":"1. 你可以解决程序无法连接数据而退出的问题。\n2. 或者你需要一个controllerl来监控容器状态，自动使容器重启，这个如果使用kubernetes就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611546984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265133,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1606788873,"is_pvip":false,"replies":[{"id":"96378","content":"谢谢，华仔！<br>","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606831213,"ip_address":"","comment_id":265133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5901756169","product_id":100063801,"comment_content":"讲解的很深入，这是我学到讲解最深的，跟着老师好好学","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510816,"discussion_content":"谢谢，华仔！\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606831213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262916,"user_name":"po","can_delete":false,"product_type":"c1","uid":1023905,"ip_address":"","ucode":"7DB36C278F34D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/a1/d75219ee.jpg","comment_is_top":false,"comment_ctime":1605882816,"is_pvip":true,"replies":[{"id":"95470","content":"&gt; 问题A<br>在容器内部无法kill 1&#47; kill -9 1, 但是在宿主机上是可以SIGKILL 容器pid1在host namespace里对应的pid的。<br><br>&gt; 问题B<br>是的。在宿主机上SIGKILL肯定可以杀掉容器的pid1, 而SIGTERM也要看情况。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606014970,"ip_address":"","comment_id":262916,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5900850112","product_id":100063801,"comment_content":"老师，<br>问题A: 那么对于容器内无法通过sigterm或者sigkill杀掉容器PID1，那么如何重启容器呢？<br><br>问题B：对于容器内无法通过sigterm或者sigkill杀掉容器，是不是在宿主机上可以直接通过sigterm或者sigkill杀掉容器在宿主机上的那个进程？","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510031,"discussion_content":"&amp;gt; 问题A\n在容器内部无法kill 1/ kill -9 1, 但是在宿主机上是可以SIGKILL 容器pid1在host namespace里对应的pid的。\n\n&amp;gt; 问题B\n是的。在宿主机上SIGKILL肯定可以杀掉容器的pid1, 而SIGTERM也要看情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606014970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354908,"user_name":"事已至此开始撤退","can_delete":false,"product_type":"c1","uid":2901316,"ip_address":"","ucode":"1076FDF53DA81D","user_header":"https://static001.geekbang.org/account/avatar/00/2c/45/44/8df79d3c.jpg","comment_is_top":false,"comment_ctime":1660876910,"is_pvip":false,"replies":[{"id":"129107","content":"收到反馈，可以分享一下你的理解～","user_name":"编辑回复","user_name_real":"编辑","uid":"1501385","ctime":1660895194,"ip_address":"","comment_id":354908,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1660876910","product_id":100063801,"comment_content":"linux相关的讲的很好，但容器感觉没有讲到本质","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584528,"discussion_content":"收到反馈，可以分享一下你的理解～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660895194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":8}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342900,"user_name":"takumi","can_delete":false,"product_type":"c1","uid":1439928,"ip_address":"","ucode":"780B10D8BEBDA6","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/b8/0398768b.jpg","comment_is_top":false,"comment_ctime":1650527667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650527667","product_id":100063801,"comment_content":"我这边的 kill -l 有64个，系统是Ubuntu 20.04","like_count":0},{"had_liked":false,"id":331469,"user_name":"ch_ort","can_delete":false,"product_type":"c1","uid":1580926,"ip_address":"","ucode":"B79746E687F29E","user_header":"","comment_is_top":false,"comment_ctime":1642595877,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1642595877","product_id":100063801,"comment_content":"“ 容器中，1 号进程永远不会响应 SIGKILL 和 SIGSTOP 这两个特权信号 ”<br>容器外，1号进程响应 SIGKILL和SIGSTOP吗？ <br><br>核心问题是：是所有1号进程都忽略了缺省行为的信号，还是只有容器的1号进程？","like_count":0,"discussions":[{"author":{"id":2139471,"avatar":"https://static001.geekbang.org/account/avatar/00/20/a5/4f/772dd0f3.jpg","nickname":"zlel","note":"","ucode":"D98D44B933D6D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560523,"discussion_content":"1. gloal init进程会忽略SIGKILL和SIGSTOP。\n2. 同一个namespace下，init进程会忽略SIGKILL和SIGSTOP。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649380504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324169,"user_name":"cola","can_delete":false,"product_type":"c1","uid":1134445,"ip_address":"","ucode":"CA313F0A0A7303","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/6d/6387eebb.jpg","comment_is_top":false,"comment_ctime":1638325522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638325522","product_id":100063801,"comment_content":"简单记录下：从host namespace中可以kill 掉init进程（容器退出时打印 SIGKILL对应Killed，SIGTERM对应Terminated）<br>但是docker ps 仍然能看到container。还需要docker stop &lt;container-name&gt; 以及docker rm &lt;container-name&gt; 后才能重新docker run相同的container-name","like_count":0},{"had_liked":false,"id":310737,"user_name":"罗峰","can_delete":false,"product_type":"c1","uid":1218501,"ip_address":"","ucode":"5F3D6AF8F28322","user_header":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","comment_is_top":false,"comment_ctime":1630889208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630889208","product_id":100063801,"comment_content":"好奇，容器内不能用kill stop杀死一号，那么docker退出容器是通过啥方式呢？","like_count":1},{"had_liked":false,"id":308240,"user_name":"Tim","can_delete":false,"product_type":"c1","uid":2734095,"ip_address":"","ucode":"772DAF08FB182E","user_header":"https://static001.geekbang.org/account/avatar/00/29/b8/0f/cfadd241.jpg","comment_is_top":false,"comment_ctime":1629466008,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629466008","product_id":100063801,"comment_content":"请教个问题，以命令： docker run --name sig-proc -d registry&#47;sig-proc:v1 &#47;init.sh 运行容器后，在通过 docker exec -it sig-proc bash 进入容器，接下来执行: 1. kill 1, 2. kill -9 1, 实验结果都符合预期，进程没有被终止掉，但是我在容器所在主机通过 strace -p 2136, 2136进程号对应位 &#47;init.sh 在主机中的进程号，接下来我还是回到kill的窗口，执行kill 1, 符合预期进程未被终止，但是kill -9 1 却成功的将进程终止了，容器退出，strace 输出：wait4(-1, 0x7fff63d2ec50, 0, NULL)      = ? ERESTARTSYS (To be restarted if SA_RESTART is set)<br>+++ killed by SIGKILL +++<br><br>这是什么原因呢？","like_count":0,"discussions":[{"author":{"id":1132009,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/e9/133553d1.jpg","nickname":"晴天🍃","note":"","ucode":"5AE4A042B94010","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541549,"discussion_content":"我也试了下strace后的行为，没有复现你说的情况，在容器内 kill -9 1 容器不会退出","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640441516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306274,"user_name":"🐭","can_delete":false,"product_type":"c1","uid":2384580,"ip_address":"","ucode":"E5CA01ACAEDFC1","user_header":"https://static001.geekbang.org/account/avatar/00/24/62/c4/be92518b.jpg","comment_is_top":false,"comment_ctime":1628482075,"is_pvip":false,"replies":[{"id":"110965","content":"每个容器进程空间 (pid namespace)内的1号进程不能响应SIGKILL, 但是可以在host 进程空间对容器进程发送SIGKILL来杀死容器中的进程。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1628598482,"ip_address":"","comment_id":306274,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628482075","product_id":100063801,"comment_content":"既然一号进程不能响应sigkill信号，那么容器又是如何被杀死的呢？麻烦老师回复一下，好几个问题都没得到回复了","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524696,"discussion_content":"每个容器进程空间 (pid namespace)内的1号进程不能响应SIGKILL, 但是可以在host 进程空间对容器进程发送SIGKILL来杀死容器中的进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628598482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304175,"user_name":"Geek_Edric","can_delete":false,"product_type":"c1","uid":1638812,"ip_address":"","ucode":"1C7E1882C7936F","user_header":"https://static001.geekbang.org/account/avatar/00/19/01/9c/f7c2a01e.jpg","comment_is_top":false,"comment_ctime":1627286683,"is_pvip":false,"replies":[{"id":"110065","content":"谢谢肯定，后续更精彩，期待你多多留言～","user_name":"编辑回复","user_name_real":"赵宇新","uid":"1501385","ctime":1627291655,"ip_address":"","comment_id":304175,"utype":2}],"discussion_count":1,"race_medal":0,"score":"1627286683","product_id":100063801,"comment_content":"真的涨知识了，感谢分享","like_count":0,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523960,"discussion_content":"谢谢肯定，后续更精彩，期待你多多留言～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627291655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293208,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1621264990,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1621264990","product_id":100063801,"comment_content":"老师，我在容器中使用SIGSTOP，1号进程可以响应，没整明白。<br>操作环境：<br>Ubuntu 20.04.2 LTS  x86-64<br>Linux 5.8.0-50-generic<br>Docker Client&#47;Server Version: 20.10.5<br>-------<br>demonlee@demonlee-ubuntu:process$ cat ProcKill.c<br>#include &lt;stdio.h&gt;<br>#include &lt;unistd.h&gt;<br>#include &lt;time.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;sys&#47;types.h&gt;<br>#include &lt;sys&#47;wait.h&gt;<br><br>void sig_handler(int signo)<br>{<br>\tif (signo == SIGTERM) {<br>\t\tprintf(&quot;received SIGTERM: %d...\\n&quot;, signo);<br>\t\texit(0);<br>\t}<br>}<br><br>int main(int argc, char *argv[]) {<br>\tsetbuf(stdout, NULL);<br>\tsignal(SIGTERM, sig_handler);<br>\ttime_t t;<br>\twhile (1) {<br>\t\tsleep(2);<br>\t\ttime(&amp;t);<br>\t\tprintf(&quot;current time is : %s&quot;,ctime(&amp;t));<br>\t}<br><br>\treturn 0;<br>}<br>demonlee@demonlee-ubuntu:process$ cat Dockerfile_c<br>FROM centos:8.1.1911<br>WORKDIR &#47;home&#47;proc<br>COPY .&#47;ProcKill &#47;home&#47;proc<br>CMD [&quot;.&#47;ProcKill&quot;]<br><br>demonlee@demonlee-ubuntu:process$ docker exec -it c-kill-demo-signal bash<br>[root@df1a729eeb4f proc]# ps aux<br>USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br>root           1  0.1  0.0   4340   696 ?        Ss   15:17   0:00 .&#47;ProcKill<br>root           8  0.6  0.0  12028  3376 pts&#47;0    Ss   15:17   0:00 bash<br>root          23  0.0  0.0  43964  3368 pts&#47;0    R+   15:17   0:00 ps aux<br>[root@df1a729eeb4f proc]# <br>[root@df1a729eeb4f proc]# <br>[root@df1a729eeb4f proc]# kill -19 1<br>[root@df1a729eeb4f proc]# <br><br><br>另一个终端：<br>demonlee@demonlee-ubuntu:process$ sudo strace -p 50269<br>[sudo] password for demonlee: <br>strace: Process 50269 attached<br>restart_syscall(&lt;... resuming interrupted read ...&gt;) = 0<br>stat(&quot;&#47;etc&#47;localtime&quot;, {st_mode=S_IFREG|0644, st_size=127, ...}) = 0<br>.....<br>nanosleep({tv_sec=2, tv_nsec=0}, {tv_sec=0, tv_nsec=887619019}) = ? ERESTART_RESTARTBLOCK (Interrupted by signal)<br>--- SIGSTOP {si_signo=SIGSTOP, si_code=SI_USER, si_pid=8, si_uid=0} ---<br>--- stopped by SIGSTOP ---<br><br>","like_count":0},{"had_liked":false,"id":290680,"user_name":"徐少文","can_delete":false,"product_type":"c1","uid":1670331,"ip_address":"","ucode":"8E35B10DA44EE3","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/bb/635a2710.jpg","comment_is_top":false,"comment_ctime":1619685300,"is_pvip":false,"replies":[{"id":"105511","content":"是的，在task_struct中的pid (pid_t)的值是host pid namespace中的pid值。要拿到容器pid namespace中的pid_t值可以用task_pid_nr_ns()","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1620202046,"ip_address":"","comment_id":290680,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1619685300","product_id":100063801,"comment_content":"老师，我最近在做一些容器安全加固的东西。想到了一个问题，就是我现在在host上有一个内核模块，我想让它去找容器中init进程的task_struct，从内核模块上看到的task_struct中pid_t应该是在pid namespace外的吧，也就是host上看到的进程pid。我想确定这个进程是不是容器中的init进程是不是应当再做更多的判断，比如nsproxy域等？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519260,"discussion_content":"是的，在task_struct中的pid (pid_t)的值是host pid namespace中的pid值。要拿到容器pid namespace中的pid_t值可以用task_pid_nr_ns()","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620202046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":284113,"user_name":"@@fighting","can_delete":false,"product_type":"c1","uid":1236394,"ip_address":"","ucode":"7235C1E74549AE","user_header":"https://static001.geekbang.org/account/avatar/00/12/dd/aa/859544fd.jpg","comment_is_top":false,"comment_ctime":1616068435,"is_pvip":false,"replies":[{"id":"103141","content":"是的！","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1616244039,"ip_address":"","comment_id":284113,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1616068435","product_id":100063801,"comment_content":"根据go官方文档来看，是因为 go 的 runtime，自动注册了 SIGTERM 信号，https:&#47;&#47;pkg.go.dev&#47;os&#47;signal#section-directories","like_count":1,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517240,"discussion_content":"是的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616244039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283021,"user_name":"垂死挣扎的咸鱼","can_delete":false,"product_type":"c1","uid":1194388,"ip_address":"","ucode":"79143A61A5599E","user_header":"","comment_is_top":false,"comment_ctime":1615520981,"is_pvip":false,"replies":[{"id":"102733","content":"这里的df 进程一直hang， 很可能是对应的磁盘有问题，很大的概率是D state了，不能被删，我觉得还是D state的问题。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1615638731,"ip_address":"","comment_id":283021,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615520981","product_id":100063801,"comment_content":"老师，我们今天遇到了一个非常奇怪的现象，容器宿主机上有一个df进程（不确定是怎么产生的），这个进程是非一号进程且这个进程不断在R状态与D状态中切换，这边使用多次kill -9 想杀死该进程（试验了20几遍确保不可能每次kill -9 都发到状态是D的时候），但是这个进程杀不死。这边根据之前课程中的内容学习到，force是同一namespace（都在宿主机上）为0，cat &#47;proc&#47;1932819&#47;status | grep -i SigCgt<br>SigCgt: 0000000000000000<br>所以handler == SIG_DFL，然后是非init进程所以应该不是SIGNAL_UNKILLABLE ，然后这边就很奇怪这个进程杀不死<br><br> ps -aux | grep df<br>。。。。。<br>docker   1932819  4.5  0.0   4448  1584 ?        R     2020 5084:33 df<br>。。。。<br><br>kill -9 1932819<br><br> ps -aux | grep df<br>docker   1932819  4.5  0.0   4448  1584 ?        R     2020 5084:33 df<br><br><br>","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516912,"discussion_content":"这里的df 进程一直hang， 很可能是对应的磁盘有问题，很大的概率是D state了，不能被删，我觉得还是D state的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615638731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266738,"user_name":"InfoQ_31da8ff7fcb1","can_delete":false,"product_type":"c1","uid":1485279,"ip_address":"","ucode":"AEF58B6E4F9E59","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIzVGyhMctYa2jumzLicZVLia0UCTqrWfiaY8pY4c3AbGH2tH5TxONcbicoXGdE3ia43TpXxbZWPZoS6Jg/132","comment_is_top":false,"comment_ctime":1607476459,"is_pvip":false,"replies":[{"id":"96956","content":"&gt; 1 <br>至于为什么即使在宿主机机上向容器1号进程发送SIGTERM，在1号进程没有注册handler的情况下，不能被杀死的问题 （思考题）， 原因是这样的：<br><br>开始要看内核里的那段代码，“ !(force &amp;&amp; sig_kernel_only(sig))”，<br>虽然由不同的namespace发送信号， 虽然force是1了，但是sig_kernel_only(sig)对于SIGTERM来说还是0， 这里是个&amp;&amp;, 那么 !(1 &amp;&amp; 0) = 1。<br><br>#define sig_kernel_only(sig) siginmask(sig, SIG_KERNEL_ONLY_MASK)<br>#define SIG_KERNEL_ONLY_MASK (\\<br>        rt_sigmask(SIGKILL) | rt_sigmask(SIGSTOP))<br><br>&gt; 2<br>对于SIGKILL信号，上面的代码也解释了。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1607615796,"ip_address":"","comment_id":266738,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607476459","product_id":100063801,"comment_content":"很早以前就有课后题目相同的疑问，之前做过测试：<br>1. 在主机上kill容器1号进程，如果进程处理了SIGTERM那么会走到handler中（如go），如果进程没有处理是不会被干掉的。（怀疑和sig_task_ignored有关）<br>2. 如果在主机上kill -9容器1号进程会直接干掉<br>不知道是什么原因，求老师解答","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511370,"discussion_content":"&amp;gt; 1 \n至于为什么即使在宿主机机上向容器1号进程发送SIGTERM，在1号进程没有注册handler的情况下，不能被杀死的问题 （思考题）， 原因是这样的：\n\n开始要看内核里的那段代码，“ !(force &amp;amp;&amp;amp; sig_kernel_only(sig))”，\n虽然由不同的namespace发送信号， 虽然force是1了，但是sig_kernel_only(sig)对于SIGTERM来说还是0， 这里是个&amp;amp;&amp;amp;, 那么 !(1 &amp;amp;&amp;amp; 0) = 1。\n\n#define sig_kernel_only(sig) siginmask(sig, SIG_KERNEL_ONLY_MASK)\n#define SIG_KERNEL_ONLY_MASK (\\\n        rt_sigmask(SIGKILL) | rt_sigmask(SIGSTOP))\n\n&amp;gt; 2\n对于SIGKILL信号，上面的代码也解释了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607615796,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266286,"user_name":"feihui","can_delete":false,"product_type":"c1","uid":1007294,"ip_address":"","ucode":"13F1D4A82BC650","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5e/be/9ea55f46.jpg","comment_is_top":false,"comment_ctime":1607269510,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607269510","product_id":100063801,"comment_content":"关于课后思考题，个人觉得差异点在于 sig_handler这个函数逻辑中","like_count":0},{"had_liked":false,"id":263849,"user_name":"po","can_delete":false,"product_type":"c1","uid":1023905,"ip_address":"","ucode":"7DB36C278F34D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/a1/d75219ee.jpg","comment_is_top":false,"comment_ctime":1606280442,"is_pvip":true,"replies":[{"id":"95702","content":"@po, <br>- 对于“kill 1”, 你可以看一下 &quot;cat &#47;proc&#47;1&#47;status | grep SigCgt&quot;吗？ Bit 15 (SIGTERM) 上的值应该是0.<br><br>- 对于&quot;kill -9 1&quot;的问题，你可以share 一下你的image 和 docker启动命令吗？","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606283325,"ip_address":"","comment_id":263849,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1606280442","product_id":100063801,"comment_content":"老师，我做了个测试，我发现kill 1杀不掉进程，kill -9 1把进程杀了，步骤如下：<br><br>1. 首先启动一个容器，使用sleep命令启动，然后使用kill去杀：<br>[root@254fb2b3843a &#47;]# ps -ef<br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         1     0  0 02:20 ?        00:00:00 sleep 30000<br>root        19     0  1 04:25 ?        00:00:00 bash<br>root        31    19  0 04:25 ?        00:00:00 ps -ef<br>[root@254fb2b3843a &#47;]# kill 1<br>[root@254fb2b3843a &#47;]#<br>[root@254fb2b3843a &#47;]#<br>[root@254fb2b3843a &#47;]# kill -9 1<br>[root@254fb2b3843a &#47;]# [root@ocp3 ~]#<br><br>2. 追踪到的信息：<br># strace -p 2675<br>strace: Process 2675 attached<br>restart_syscall(&lt;... resuming interrupted nanosleep ...&gt;) = ? ERESTART_RESTARTBLOCK (Interrupted by signal)<br>--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=19, si_uid=0} ---<br>restart_syscall(&lt;... resuming interrupted restart_syscall ...&gt;) = ? ERESTART_RESTARTBLOCK (Interrupted by signal)<br>+++ killed by SIGKILL +++<br><br>3. 我有点不理解了，不是说kill -9 1是杀不掉1号进程的吗？kill 1在有handler的时候会杀掉，我有点不理解了。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510331,"discussion_content":"@po, \n- 对于“kill 1”, 你可以看一下 &amp;quot;cat /proc/1/status | grep SigCgt&amp;quot;吗？ Bit 15 (SIGTERM) 上的值应该是0.\n\n- 对于&amp;quot;kill -9 1&amp;quot;的问题，你可以share 一下你的image 和 docker启动命令吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606283325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329129,"discussion_content":"@po,\n&#34;SigCgt: 0000000000000000&#34;,  Bit 15 (SIGTERM) 是0， 所以 “kill 1” 在容器内不起作用，这一点，你应该没有问题了吧？\n\n至于，为什么 &#34;kill -9 1&#34; 导致容器退出，目前，我在我运行的环境中始终没有见到过。你可以把你的内核版本给我看一下， 运行一下 &#34;uname -a&#34;。\n还有，这个&#34;kill -9 1&#34; 在你这里是可以稳定重现的吗？  \n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606315631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/a1/d75219ee.jpg","nickname":"po","note":"","ucode":"7DB36C278F34D7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328956,"discussion_content":"# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n254fb2b3843a        centos:7            &#34;sleep 30000&#34;       4 hours ago         Up 6 seconds                            keen_brahmagupta\n[root@ocp3 ~]# docker exec -it 254fb2b3843a bash\n[root@254fb2b3843a /]# cat /proc/1/status | grep SigCgt\nSigCgt:\t0000000000000000","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606285091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263390,"user_name":"王小飞","can_delete":false,"product_type":"c1","uid":1275284,"ip_address":"","ucode":"D93B4C654526F2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/94/e785c2c8.jpg","comment_is_top":false,"comment_ctime":1606122828,"is_pvip":false,"replies":[{"id":"95589","content":"对的宿主机上kill -9去杀容器的1 号进程没有问题，那么用kill &lt;pid&gt; (SIGTERM)呢？","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606143521,"ip_address":"","comment_id":263390,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606122828","product_id":100063801,"comment_content":"1. &#47;sys&#47;fs&#47;cgroup&#47;memory&#47;docker&#47;[container_id]&#47;cgroups.proc 可以查看当前容器内所有进程的 ID<br>2. 宿主机上 kill -9 [进程号] 可以杀掉容器的 1 号进程。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510169,"discussion_content":"对的宿主机上kill -9去杀容器的1 号进程没有问题，那么用kill &amp;lt;pid&amp;gt; (SIGTERM)呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606143521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263282,"user_name":"思维决定未来","can_delete":false,"product_type":"c1","uid":1412891,"ip_address":"","ucode":"88CC245B3C6E2D","user_header":"","comment_is_top":false,"comment_ctime":1606091730,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606091730","product_id":100063801,"comment_content":"回到这一节最前面的场景，我也有同样的问题，如何在pod不退出的情况下重载容器，不是重启，重启即使pod还在，对应容器也有一次restart次数的","like_count":0},{"had_liked":false,"id":263086,"user_name":"谢哈哈","can_delete":false,"product_type":"c1","uid":2326880,"ip_address":"","ucode":"5AADE70B5AFE27","user_header":"https://static001.geekbang.org/account/avatar/00/23/81/60/71ed6ac7.jpg","comment_is_top":false,"comment_ctime":1605975764,"is_pvip":false,"replies":[{"id":"95472","content":"@谢哈哈<br>是这样的！<br>&gt; 如果不注册默认的handler，在host namespace空间对容器里的C只响应kill -9<br><br>可以再想想，为什么这种情况，在host namespace还是不能相应SIGTERM?","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606015282,"ip_address":"","comment_id":263086,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1605975764","product_id":100063801,"comment_content":"己在linux下确认C与GO的程序，如果不注册默认的handler，在host namespace空间对容器里的C只响应kill -9，而容器里的GO都可以响应","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510091,"discussion_content":"@谢哈哈\n是这样的！\n&amp;gt; 如果不注册默认的handler，在host namespace空间对容器里的C只响应kill -9\n\n可以再想想，为什么这种情况，在host namespace还是不能相应SIGTERM?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606015282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2326880,"avatar":"https://static001.geekbang.org/account/avatar/00/23/81/60/71ed6ac7.jpg","nickname":"谢哈哈","note":"","ucode":"5AADE70B5AFE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327929,"discussion_content":"在hostnamespace中，容器进程也是进程，给进程发送信号，如果没注册默认handler，则返回一个正数值的errno，进程可不处理，而-9信号是不可捕获或不可忽略的信号，那么就会返回EINVAL，且hostbamespace拥有root权限的管理，进程必须响应强制终止进程信号","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606020046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262922,"user_name":"closer","can_delete":false,"product_type":"c1","uid":1368990,"ip_address":"","ucode":"69F38480DF8491","user_header":"https://static001.geekbang.org/account/avatar/00/14/e3/9e/b26da70d.jpg","comment_is_top":false,"comment_ctime":1605884835,"is_pvip":false,"replies":[{"id":"95471","content":"对的，SIGKILL肯定可以。那么SIGTERM呢？","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1606015005,"ip_address":"","comment_id":262922,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605884835","product_id":100063801,"comment_content":"我觉得思考题的答案是这样的 从宿主机找到docker 映射到物理机的进程pid 直接 kill -9就行","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510033,"discussion_content":"对的，SIGKILL肯定可以。那么SIGTERM呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606015005,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262909,"user_name":"Ethan Liu","can_delete":false,"product_type":"c1","uid":1070043,"ip_address":"","ucode":"231F944F7CD56A","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","comment_is_top":false,"comment_ctime":1605879458,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605879458","product_id":100063801,"comment_content":"1.是否是1号进程；<br>2.是否有注册handler；<br>3.是否在同一namespace","like_count":0},{"had_liked":false,"id":262907,"user_name":"Ethan Liu","can_delete":false,"product_type":"c1","uid":1070043,"ip_address":"","ucode":"231F944F7CD56A","user_header":"https://static001.geekbang.org/account/avatar/00/10/53/db/858337e3.jpg","comment_is_top":false,"comment_ctime":1605879293,"is_pvip":true,"replies":[{"id":"95442","content":"@Ethan Liu<br>似乎你的这句话没有写完。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605944031,"ip_address":"","comment_id":262907,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605879293","product_id":100063801,"comment_content":"老师，是不是可以这样理解，是否会忽略信号，跟以下三个因素有关：","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510025,"discussion_content":"@Ethan Liu\n似乎你的这句话没有写完。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605944031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262895,"user_name":"Acter","can_delete":false,"product_type":"c1","uid":1082561,"ip_address":"","ucode":"EF747BEAD2A797","user_header":"https://static001.geekbang.org/account/avatar/00/10/84/c1/dfcad82a.jpg","comment_is_top":false,"comment_ctime":1605872348,"is_pvip":true,"replies":[{"id":"95365","content":"@Acter, 在宿主机上只是用&quot;ps -ef&quot;是无法判断一个进程是否属于一个容器。<br><br>可以看一下 对应进程&#47;proc&#47;&lt;pid&gt;&#47;ns&#47;pid 值，来判断它们是不是在不同的namespace. <br><br># ls -l &#47;proc&#47;28725&#47;ns&#47;pid<br>lrwxrwxrwx 1 root root 0 Nov 20 03:31 &#47;proc&#47;28725&#47;ns&#47;pid -&gt; &#39;pid:[4026532248]&#39;<br># ls -l &#47;proc&#47;1&#47;ns&#47;pid<br>lrwxrwxrwx 1 root root 0 Nov 18 03:55 &#47;proc&#47;1&#47;ns&#47;pid -&gt; &#39;pid:[4026531836]&#39;","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605875900,"ip_address":"","comment_id":262895,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1605872348","product_id":100063801,"comment_content":"看得不是很懂。想问个问题：在宿主机上ps -ef，怎么判断某个进程是否为容器里的进程？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510020,"discussion_content":"@Acter, 在宿主机上只是用&amp;quot;ps -ef&amp;quot;是无法判断一个进程是否属于一个容器。\n\n可以看一下 对应进程/proc/&amp;lt;pid&amp;gt;/ns/pid 值，来判断它们是不是在不同的namespace. \n\n# ls -l /proc/28725/ns/pid\nlrwxrwxrwx 1 root root 0 Nov 20 03:31 /proc/28725/ns/pid -&amp;gt; &amp;#39;pid:[4026532248]&amp;#39;\n# ls -l /proc/1/ns/pid\nlrwxrwxrwx 1 root root 0 Nov 18 03:55 /proc/1/ns/pid -&amp;gt; &amp;#39;pid:[4026531836]&amp;#39;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605875900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1275284,"avatar":"https://static001.geekbang.org/account/avatar/00/13/75/94/e785c2c8.jpg","nickname":"王小飞","note":"","ucode":"D93B4C654526F2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328309,"discussion_content":"/sys/fs/cgroup/memory/docker/[container_id]/cgroup.procs 里面有容器所有进程ID ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606122581,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1276588,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIz9dKN1C8rKQoaVtmEGdzObhlia6zAfTsPYOm4ibz39VjTbu7Aia1LyeedHR26b6nxUtcCufpichcYgw/132","nickname":"上邪忘川","note":"","ucode":"1C4459917B038D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327672,"discussion_content":"可以用ps aux|grep 容器id值来过滤","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605886896,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262826,"user_name":"wuqilv","can_delete":false,"product_type":"c1","uid":1169314,"ip_address":"","ucode":"B9C4A2C2FF32AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/d7/a2/5f6b90a9.jpg","comment_is_top":false,"comment_ctime":1605854737,"is_pvip":false,"replies":[{"id":"95371","content":"@wuqilv, 可以再说一下是那种“权限”吗？","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605877409,"ip_address":"","comment_id":262826,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1605854737","product_id":100063801,"comment_content":"看进程status的flags 内外一样的，在宿主机上没有权限的话，kill 和 kill -9 都执行不了；有权限的话 kill -9 才可以使得进程退出。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509986,"discussion_content":"@wuqilv, 可以再说一下是那种“权限”吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605877409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1169314,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d7/a2/5f6b90a9.jpg","nickname":"wuqilv","note":"","ucode":"B9C4A2C2FF32AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328191,"discussion_content":"在ubuntu上我用的是root权限去执行命令。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606098587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262549,"user_name":"po","can_delete":false,"product_type":"c1","uid":1023905,"ip_address":"","ucode":"7DB36C278F34D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9f/a1/d75219ee.jpg","comment_is_top":false,"comment_ctime":1605765820,"is_pvip":true,"replies":[{"id":"95306","content":"@po, 这个需要看容器启动后你的应用中间件是不是容器中的1号进程。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605798078,"ip_address":"","comment_id":262549,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1605765820","product_id":100063801,"comment_content":"老师，现在有的应用中间件自己有启动脚本和关闭脚本，我们在把这些应用中间件容器化后，通过关闭脚本来关闭应用中间件，是不是也是kill掉1号进程呢？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509880,"discussion_content":"@po, 这个需要看容器启动后你的应用中间件是不是容器中的1号进程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605798078,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1023905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9f/a1/d75219ee.jpg","nickname":"po","note":"","ucode":"7DB36C278F34D7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327362,"discussion_content":"如果应用中间件是1号进程，那么关闭脚本也是通过15来关闭中间件了吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605801445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262536,"user_name":"sotey","can_delete":false,"product_type":"c1","uid":1221689,"ip_address":"","ucode":"7D3B7E45FC18BA","user_header":"https://static001.geekbang.org/account/avatar/00/12/a4/39/6a5cd1d8.jpg","comment_is_top":false,"comment_ctime":1605760171,"is_pvip":false,"replies":[{"id":"95301","content":"@sotey, 如果可以的话，你可以动手试一下，看看结果是不是和你分析的一样 :-)","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605797376,"ip_address":"","comment_id":262536,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605760171","product_id":100063801,"comment_content":"思考题：这一讲的最开始，有这样一个 C 语言的 init 进程，它没有注册任何信号的 handler。如果我们从 Host Namespace 向它发送 SIGTERM，会发生什么情况呢？<br><br>按照老师的讲解，init进程没有注册handler在docker的Namespace内是kill不掉的，但是在Host Namespace也就是操作系统如果是root用户，这个docker的init进程相当于是普通进程，可以被kill掉。<br><br>那么操作系统的init进程是不是就算root用户也应该不能kill 掉？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509874,"discussion_content":"@sotey, 如果可以的话，你可以动手试一下，看看结果是不是和你分析的一样 :-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605791543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262502,"user_name":"kimoti","can_delete":false,"product_type":"c1","uid":1897671,"ip_address":"","ucode":"0A78077408C2B1","user_header":"https://static001.geekbang.org/account/avatar/00/1c/f4/c7/037235c9.jpg","comment_is_top":false,"comment_ctime":1605752456,"is_pvip":false,"replies":[{"id":"95302","content":"@kimoti, 如果可以的话，你可以动手试一下，看看结果是不是和你分析的一样 :-)","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605797475,"ip_address":"","comment_id":262502,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605752456","product_id":100063801,"comment_content":"从hostname namespace向容器发信号是可以杀死1号进程的。因为host的namespace和容器的namespace是不一样的。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509861,"discussion_content":"@kimoti, 如果可以的话，你可以动手试一下，看看结果是不是和你分析的一样 :-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605762753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262455,"user_name":"谢哈哈","can_delete":false,"product_type":"c1","uid":2326880,"ip_address":"","ucode":"5AADE70B5AFE27","user_header":"https://static001.geekbang.org/account/avatar/00/23/81/60/71ed6ac7.jpg","comment_is_top":false,"comment_ctime":1605745037,"is_pvip":false,"replies":[{"id":"95249","content":"@谢哈哈，你可以动手试一试。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605754165,"ip_address":"","comment_id":262455,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1605745037","product_id":100063801,"comment_content":"有这样一个 C 语言的 init 进程，它没有注册任何信号的 handler。如果我们从 Host Namespace 向它发送 SIGTERM，会发生什么情况呢？<br><br>应该与容器里的情况一样，如果注册了默认的sigterm 信号的handler，就可以响应，否则不会响应，容器与宿主机是共享内核的","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509840,"discussion_content":"@谢哈哈，你可以动手试一试。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605754165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1035744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","nickname":"朱雯","note":"","ucode":"064C45FBF6B51F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327181,"discussion_content":"不是共享内核 而是pidnamespace问题吧 而且内核源码讲解中也说明了 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605761458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2326880,"avatar":"https://static001.geekbang.org/account/avatar/00/23/81/60/71ed6ac7.jpg","nickname":"谢哈哈","note":"","ucode":"5AADE70B5AFE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1035744,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","nickname":"朱雯","note":"","ucode":"064C45FBF6B51F","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":327872,"discussion_content":"已经手动在linux下论证，go的可以正常接受kill 与kill -9信号并且都能正常终止进程，而C程序只接受kill -9不可捕捉且必须要响应的信号，kill的sigterm信号默认没有注册handler不给于响应","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1605975636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":327181,"ip_address":""},"score":327872,"extra":""}]}]},{"had_liked":false,"id":262424,"user_name":"朱雯","can_delete":false,"product_type":"c1","uid":1035744,"ip_address":"","ucode":"064C45FBF6B51F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cd/e0/c85bb948.jpg","comment_is_top":false,"comment_ctime":1605714161,"is_pvip":true,"replies":[{"id":"95372","content":"@朱雯， 对于#3， 信号没有注册自己的handler, 不等于就是忽略，而是要看信号原来的系统缺省handler是怎么工作的。比如SIGTERM, 没有注册handler, 在大多数情况下，就是使进程退出。<br><br>信号(signal)是进程间的一种异步通讯机制, 这里和信号量（Semphore)是两个不同的概念。","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605877745,"ip_address":"","comment_id":262424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605714161","product_id":100063801,"comment_content":"关于信号量的猜测，老师看看对吗<br>1. 特权信号特别处理，比如kill -9 -19 sigkill和sigstop<br>2. 普通信号看看有没有注册handle，如果注册了handle，那就按照handle操作，每次我们打开一个bash，其实就是一个linux进程，这个进程注册了handle，只要接受到了ctrl c那就等于是要执行打断输出的操作，其实就是注册了handle。<br>3. 如果不是特别信号，也没有注册handle，那就干脆直接忽略。<br><br>为啥要有信号，这里也是一种猜测。那就是os必须要有一种异常处理机制，否则线程进程一旦占有cpu而不退出，那就会阻塞整个操作系统，这些异常机制包括，硬件的时钟，各种软硬中断和系统调用，异常等等，而其中信号量就是一种直接对外的api接口，因为你无法对普通用户直接暴露，如何操作硬件时钟和软件件中断系统调用等等，所以必须封装一种特殊的类型，也就是事件，这种事件，就是信号量，其实如果可以重新编译或者编写新的进程，那么信号量也就可以重新定义。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509825,"discussion_content":"@朱雯， 对于#3， 信号没有注册自己的handler, 不等于就是忽略，而是要看信号原来的系统缺省handler是怎么工作的。比如SIGTERM, 没有注册handler, 在大多数情况下，就是使进程退出。\n\n信号(signal)是进程间的一种异步通讯机制, 这里和信号量（Semphore)是两个不同的概念。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605877745,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262348,"user_name":"王建","can_delete":false,"product_type":"c1","uid":1153792,"ip_address":"","ucode":"68000818D8AA41","user_header":"https://static001.geekbang.org/account/avatar/00/11/9b/00/8c1b9631.jpg","comment_is_top":false,"comment_ctime":1605696796,"is_pvip":false,"replies":[{"id":"95304","content":"@王建， 如果可以的话，你可以动手试一下，看看结果是不是和你分析的一样 :-)","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605797562,"ip_address":"","comment_id":262348,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605696796","product_id":100063801,"comment_content":"Host Namespace 像容器发送 SIGTERM 如果是root用户应该可以停掉docker,在宿也是个进程！","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509794,"discussion_content":"@王建， 如果可以的话，你可以动手试一下，看看结果是不是和你分析的一样 :-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605704412,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262312,"user_name":"徐少文","can_delete":false,"product_type":"c1","uid":1670331,"ip_address":"","ucode":"8E35B10DA44EE3","user_header":"https://static001.geekbang.org/account/avatar/00/19/7c/bb/635a2710.jpg","comment_is_top":false,"comment_ctime":1605691522,"is_pvip":false,"replies":[{"id":"95159","content":"@徐少文<br>是的，需要golang的编译器。你可以参考下面的连接装一下， https:&#47;&#47;golang.org&#47;doc&#47;install<br><br>或者你可以直接运行 make_image.sh， binary我也放了一份。<br>https:&#47;&#47;github.com&#47;chengyli&#47;training&#47;blob&#47;main&#47;init_proc&#47;handle_sig&#47;make_image.sh","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605704673,"ip_address":"","comment_id":262312,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1605691522","product_id":100063801,"comment_content":"老师好，我没接触过go语言，我在进行第一个小实验执行make image的时候系统提示<br>&#47;bin&#47;sh: 1: go: not found<br>Makefile:10: recipe for target &#39;go-init&#39; failed<br>make: *** [go-init] Error 127<br>是不是需要安装go相关编译器啊，<br>ubuntu 18.04 内核5.4.0-53-generic","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509777,"discussion_content":"@徐少文\n是的，需要golang的编译器。你可以参考下面的连接装一下， https://golang.org/doc/install\n\n或者你可以直接运行 make_image.sh， binary我也放了一份。\nhttps://github.com/chengyli/training/blob/main/init_proc/handle_sig/make_image.sh","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605704673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670331,"avatar":"https://static001.geekbang.org/account/avatar/00/19/7c/bb/635a2710.jpg","nickname":"徐少文","note":"","ucode":"8E35B10DA44EE3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327175,"discussion_content":"谢谢老师，我已经自己装好了。期待我们的下一讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605759366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262308,"user_name":"Geek2014","can_delete":false,"product_type":"c1","uid":2028957,"ip_address":"","ucode":"9EB356D8DF287E","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/9d/104bb8ea.jpg","comment_is_top":false,"comment_ctime":1605689990,"is_pvip":false,"replies":[{"id":"95251","content":"@Geek2014 你的问题是介绍一下golang最这些注册了的信号是怎么处理的？","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605754410,"ip_address":"","comment_id":262308,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605689990","product_id":100063801,"comment_content":"后面能否考虑简单聊下golang对默认信号的处理机制？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509773,"discussion_content":"@Geek2014 你的问题是介绍一下golang最这些注册了的信号是怎么处理的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605754410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262283,"user_name":"Geek2014","can_delete":false,"product_type":"c1","uid":2028957,"ip_address":"","ucode":"9EB356D8DF287E","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/9d/104bb8ea.jpg","comment_is_top":false,"comment_ctime":1605684414,"is_pvip":false,"replies":[{"id":"95305","content":"@Geek2014, 如果可以的话，你可以动手试一下，看看结果是不是和你分析的一样 :-)","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605797730,"ip_address":"","comment_id":262283,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605684414","product_id":100063801,"comment_content":"有这样一个 C 语言的 init 进程，它没有注册任何信号的 handler。如果我们从 Host Namespace 向它发送 SIGTERM，会发生什么情况呢<br><br>按照老师对信号的讲解，我理解，由于是在Host Namespace，该进程就没有1号init进程的光环，会被当作普通进程看待，sig_task_ignored不会忽略SIGTERM信号，进程应该会退出。","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509767,"discussion_content":"@Geek2014, 如果可以的话，你可以动手试一下，看看结果是不是和你分析的一样 :-)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605797730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262220,"user_name":"水蒸蛋","can_delete":false,"product_type":"c1","uid":1809160,"ip_address":"","ucode":"6F7F853A4BF901","user_header":"https://static001.geekbang.org/account/avatar/00/1b/9b/08/27ac7ecd.jpg","comment_is_top":false,"comment_ctime":1605667354,"is_pvip":false,"replies":[{"id":"95139","content":"宿主机也一样","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605668793,"ip_address":"","comment_id":262220,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605667354","product_id":100063801,"comment_content":"容器是这样的原理，那宿主机系统是不是也是这样的原理，那就是所有系统都不能通过kill -9 1来杀死进程","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509739,"discussion_content":"宿主机也一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605668793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262204,"user_name":"海盗船长","can_delete":false,"product_type":"c1","uid":1363634,"ip_address":"","ucode":"ECB28BA21A4113","user_header":"https://static001.geekbang.org/account/avatar/00/14/ce/b2/1f914527.jpg","comment_is_top":false,"comment_ctime":1605663895,"is_pvip":false,"replies":[{"id":"95138","content":"在下面那个代码块里，查看SigCgtSigCgt bitmap.<br><br>### golang init# cat &#47;proc&#47;1&#47;status | grep -i SigCgtSigCgt: fffffffe7fc1feff","user_name":"作者回复","user_name_real":"CY","uid":"2070138","ctime":1605668721,"ip_address":"","comment_id":262204,"utype":1}],"discussion_count":5,"race_medal":0,"score":"1605663895","product_id":100063801,"comment_content":"“在 Golang 程序里，很多信号都注册了自己的 handler，当然也包括了 SIGTERM(15)，也就是 bit 15。”请问老师，这段源码在哪呀？","like_count":0,"discussions":[{"author":{"id":2070138,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/96/7a/8a14d008.jpg","nickname":"CY","note":"","ucode":"4AF98230985918","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509733,"discussion_content":"在下面那个代码块里，查看SigCgtSigCgt bitmap.\n\n### golang init# cat /proc/1/status | grep -i SigCgtSigCgt: fffffffe7fc1feff","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605668721,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1500876,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIM4iamRcx1aa74SSJibGNOGF6MKE5iaN1vByHAD9fF0vTJTTRkc9umEb3XcXa0Ak0S6fvDkXic8I03Gg/132","nickname":"Kaven","note":"","ucode":"0154555B3C8FE1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328240,"discussion_content":"宿主机为什么能kill -9 容器进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606111483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1005391,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","nickname":"一步","note":"","ucode":"73CEA468CE70C3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1500876,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIM4iamRcx1aa74SSJibGNOGF6MKE5iaN1vByHAD9fF0vTJTTRkc9umEb3XcXa0Ak0S6fvDkXic8I03Gg/132","nickname":"Kaven","note":"","ucode":"0154555B3C8FE1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328812,"discussion_content":"因为容器的 init 进程相对于宿主机来说就是普通的进程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606230749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":328240,"ip_address":""},"score":328812,"extra":""}]},{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327252,"discussion_content":"第3讲明天更新哦～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605776695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2326747,"avatar":"https://static001.geekbang.org/account/avatar/00/23/80/db/2e5e27e6.jpg","nickname":"Michael Dong ²⁰¹⁸","note":"","ucode":"B3EB15FB6D9366","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327246,"discussion_content":"第3讲今天能出来吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605774207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}