{"id":476214,"title":"36｜数据流原理：Vuex & Pinia源码剖析","content":"<p>你好，我是大圣。</p><p>上一讲我们分析了Vite原理，今天我们来剖析Vuex的原理。其实在之前的课程中，我们已经实现过一个迷你的Vuex，整体代码逻辑比较简单，基于Vue提供的响应式函数reactive和computed的能力，我们封装了一个独立的共享数据的store，并且对外暴露了commit和dispatch方法修改和更新数据，这些原理就不赘述了。</p><p>今天我们探讨一下下一代Vuex5的提案，并且看一下实际的代码是如何实现的，你学完之后可以对比之前gvuex mini版本，感受一下两者的区别。</p><h2>Vuex5提案</h2><p>由于Vuex有模块化namespace的功能，所以模块user中的mutation add方法，我们需要使用 <code>commit('user/add')</code> 来触发。这样虽然可以让Vuex支持更复杂的项目，但是<strong>这种字符串类型的拼接功能，在TypeScript4之前的类型推导中就很难实现</strong>。然后就有了Vuex5相关提案的讨论，整个讨论过程都是在GitHub的issue里推进的，你可以访问<a href=\"https://github.com/vuejs/rfcs/pull/271\">GitHub链接</a>去围观。</p><p>Vuex5的提案相比Vuex4有很大的改进，解决了一些Vuex4中的缺点。Vuex5能够同时支持Composition API和Option API，并且去掉了namespace模式，使用组合store的方式更好地支持了TypeScript的类型推导，还去掉了容易混淆的Mutation和Action概念，只保留了Action，并且<strong>支持自动的代码分割</strong>。</p><!-- [[[read_end]]] --><p>我们也可以通过对这个提案的研究，来体验一下在一个框架中如何讨论新的语法设计和实现，以及如何通过API的设计去解决开发方式的痛点。你可以在Github的提案RFCs中看到<a href=\"https://github.com/vuejs/rfcs/blob/34a8b0d541a361a37d05de8d67cb44a7b6f6fd12/active-rfcs/0000-vuex-5.md\">Vuex5的设计文稿</a>，而Pinia正是基于Vuex5设计的框架。</p><p>现在Pinia已经正式合并到Vue组织下，成为了Vue的官方项目，尤雨溪也在多次分享中表示<strong>Pinia就是未来的Vuex</strong>，接下来我们就好好学习一下Pinia的使用方式和实现的原理。</p><h2>Pinia</h2><p>下图是Pinia官网的介绍，可以看到类型安全、Vue 的Devtools支持、易扩展、只有1KB的体积等优点。快来看下Pinia如何使用吧。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/6c/41f8301ee6610c3892f6530f6061ff6c.png?wh=1941x736\" alt=\"\"></p><p>首先我们在项目根目录下执行下面的命令去<strong>安装Pinia的最新版本</strong>。</p><pre><code class=\"language-javascript\">npm install pinia@next\n</code></pre><p>然后在src/main.js中，我们导入createPinia方法，通过createPinia方法创建Pinia的实例后，再通过app.use方法注册Pinia。</p><pre><code class=\"language-javascript\">import { createApp } from 'vue'\nimport { createPinia } from 'pinia'\nimport App from './App.vue'\nconst pinia = createPinia()\nconst app = createApp(App)\napp.use(pinia).mount('#app')\n\n</code></pre><p>然后我们可以在store文件夹中创建一个count.js。下面的代码中我们通过Pinia的defineStore方法定义了一个store，store内部通过state返回一个对象，并且通过Actions配置修改数据的方法add。这里使用的语法和Vuex比较类似，只是删除了Mutation的概念，<strong>统一使用Actions来配置</strong>。</p><pre><code class=\"language-javascript\">\n\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('count', {\n  id:'count',\n&nbsp; state: () =&gt; {\n&nbsp; &nbsp; return { count: 1 }\n&nbsp; },\n&nbsp; actions: {\n&nbsp; &nbsp; add() {\n&nbsp; &nbsp; &nbsp; this.count++\n&nbsp; &nbsp; },\n&nbsp; },\n})\n\n</code></pre><p>然后我们可以使用Composition的方式在代码中使用store。注意上面的store返回的其实就是一个Composition风格的函数，使用useCounterStore返回count后，可以在add方法中直接使用count.add触发Actions，实现数据的修改。</p><pre><code class=\"language-javascript\">import { useCounterStore } from '../stores/count'\n\nconst count = useCounterStore()\nfunction add(){\n  count.add()\n}\n\n    \n</code></pre><p><strong>我们也可以使用Composition风格的语法，去创建一个store。</strong>使用ref或者reactive包裹后，通过defineStore返回，这样store就非常接近我们自己分装的Composition语法了，也去除了很多Vuex中特有的概念，学习起来更加简单。</p><pre><code class=\"language-javascript\">export const useCounterStore = defineStore('count', () =&gt; {\n&nbsp; const count = ref(0)\n&nbsp; function increment() {\n&nbsp; &nbsp; count.value++\n&nbsp; }\n\n&nbsp; return { count, increment }\n})\n\n</code></pre><h2>Pinna源码</h2><p>然后我们通过阅读Pinia的源码，来看下Pinia是如何实现的。</p><p>首先我们进入到Pinia的GitHub中，我们可以在packages/pinia/src/createPinia.ts中看到createPinia函数的实现。</p><p>下面的代码中，我们通过effectScope创建一个作用域对象，并且通过ref创建了响应式的数据对象state。然后通过install方法支持了app.use的注册，内部通过provide的语法和全局的$pinia变量配置Pinia对象，并且通过use方法和toBeInstalled数组实现了Pinia的插件机制。<strong>最后还通过pinia.use(devtoolsPlugin) 实现了对VueDevtools的支持。</strong></p><pre><code class=\"language-javascript\">export function createPinia(): Pinia {\n  const scope = effectScope(true)\n  // NOTE: here we could check the window object for a state and directly set it\n  // if there is anything like it with Vue 3 SSR\n  const state = scope.run(() =&gt; ref&lt;Record&lt;string, StateTree&gt;&gt;({}))!\n\n  let _p: Pinia['_p'] = []\n  // plugins added before calling app.use(pinia)\n  let toBeInstalled: PiniaPlugin[] = []\n\n  const pinia: Pinia = markRaw({\n    install(app: App) {\n      // this allows calling useStore() outside of a component setup after\n      // installing pinia's plugin\n      setActivePinia(pinia)\n      if (!isVue2) {\n        pinia._a = app\n        app.provide(piniaSymbol, pinia)\n        app.config.globalProperties.$pinia = pinia\n        toBeInstalled.forEach((plugin) =&gt; _p.push(plugin))\n        toBeInstalled = []\n      }\n    },\n\n    use(plugin) {\n      if (!this._a &amp;&amp; !isVue2) {\n        toBeInstalled.push(plugin)\n      } else {\n        _p.push(plugin)\n      }\n      return this\n    },\n\n    _p,\n    _a: null,\n    _e: scope,\n    _s: new Map&lt;string, StoreGeneric&gt;(),\n    state,\n  })\n  if (__DEV__ &amp;&amp; IS_CLIENT) {\n    pinia.use(devtoolsPlugin)\n  }\n\n  return pinia\n}\n\n</code></pre><p>通过上面的代码，我们可以看到Pinia实例就是 ref({}) 包裹的响应式对象，项目中用到的state都会挂载到Pinia这个响应式对象内部。</p><p>然后我们去看下创建store的defineStore方法,  defineStore内部通过useStore方法去定义store，并且每个store都会标记唯一的ID。</p><p>首先通过getCurrentInstance获取当前组件的实例，如果useStore参数没有Pinia的话，就使用inject去获取Pinia实例，<strong>这里inject的数据就是createPinia函数中install方法提供的</strong>。</p><p>然后设置activePinia，项目中可能会存在很多Pinia的实例，设置activePinia就是设置当前活跃的Pinia实例。这个函数的实现方式和Vue中的componentInstance很像，每次创建组件的时候都设置当前的组件实例，这样就可以在组件的内部通过getCurrentInstance获取，最后通过createSetupStore或者createOptionsStore创建组件。</p><p>这就是上面代码中我们使用Composition和Option两种语法创建store的不同执行逻辑，最后通过pinia._s缓存创建后的store，_s就是在createPinia的时候创建的一个Map对象，防止store多次重复创建。<strong>到这store创建流程就结束了。</strong></p><pre><code class=\"language-javascript\">export function defineStore(\n  // TODO: add proper types from above\n  idOrOptions: any,\n  setup?: any,\n  setupOptions?: any\n): StoreDefinition {\n  let id: string\n  let options:...\n  const isSetupStore = typeof setup === 'function'\n  if (typeof idOrOptions === 'string') {\n    id = idOrOptions\n    // the option store setup will contain the actual options in this case\n    options = isSetupStore ? setupOptions : setup\n  } else {\n    options = idOrOptions\n    id = idOrOptions.id\n  }\n\n  function useStore(pinia?: Pinia | null, hot?: StoreGeneric): StoreGeneric {\n    const currentInstance = getCurrentInstance()\n    pinia =\n      // in test mode, ignore the argument provided as we can always retrieve a\n      // pinia instance with getActivePinia()\n      (__TEST__ &amp;&amp; activePinia &amp;&amp; activePinia._testing ? null : pinia) ||\n      (currentInstance &amp;&amp; inject(piniaSymbol))\n    if (pinia) setActivePinia(pinia)\n\n    pinia = activePinia!\n\n    if (!pinia._s.has(id)) {\n      // creating the store registers it in `pinia._s`\n      if (isSetupStore) {\n        createSetupStore(id, setup, options, pinia)\n      } else {\n        createOptionsStore(id, options as any, pinia)\n      }\n\n      /* istanbul ignore else */\n      if (__DEV__) {\n        // @ts-expect-error: not the right inferred type\n        useStore._pinia = pinia\n      }\n    }\n\n    const store: StoreGeneric = pinia._s.get(id)!\n\n    // save stores in instances to access them devtools\n    if (\n      __DEV__ &amp;&amp;\n      IS_CLIENT &amp;&amp;\n      currentInstance &amp;&amp;\n      currentInstance.proxy &amp;&amp;\n      // avoid adding stores that are just built for hot module replacement\n      !hot\n    ) {\n      const vm = currentInstance.proxy\n      const cache = '_pStores' in vm ? vm._pStores! : (vm._pStores = {})\n      cache[id] = store\n    }\n\n    // StoreGeneric cannot be casted towards Store\n    return store as any\n  }\n\n  useStore.$id = id\n\n  return useStore\n}\n\n</code></pre><p>在Pinia中createOptionsStore内部也是调用了createSetupStore来创建store对象。下面的代码中，我们通过assign方法实现了setup函数，这里可以看到computed的实现，内部就是通过pinia._s缓存获取store对象，调用store的getters方法来模拟，最后依然通过createSetupStore创建。</p><pre><code class=\"language-javascript\">function createOptionsStore&lt;\n  Id extends string,\n  S extends StateTree,\n  G extends _GettersTree&lt;S&gt;,\n  A extends _ActionsTree\n&gt;(\n  id: Id,\n  options: DefineStoreOptions&lt;Id, S, G, A&gt;,\n  pinia: Pinia,\n  hot?: boolean\n): Store&lt;Id, S, G, A&gt; {\n  const { state, actions, getters } = options\n\n  const initialState: StateTree | undefined = pinia.state.value[id]\n\n  let store: Store&lt;Id, S, G, A&gt;\n\n  function setup() {\n\n    pinia.state.value[id] = state ? state() : {}\n    return assign(\n      localState,\n      actions,\n      Object.keys(getters || {}).reduce((computedGetters, name) =&gt; {\n        computedGetters[name] = markRaw(\n          computed(() =&gt; {\n            setActivePinia(pinia)\n            // it was created just before\n            const store = pinia._s.get(id)!\n            return getters![name].call(store, store)\n          })\n        )\n        return computedGetters\n      }, {} as Record&lt;string, ComputedRef&gt;)\n    )\n  }\n\n  store = createSetupStore(id, setup, options, pinia, hot)\n\n  return store as any\n}\n</code></pre><p>最后我们来看一下createSetupStore函数的实现。这个函数也是Pinia中最复杂的函数实现，内部的$patch函数可以实现数据的更新。如果传递的参数partialStateOrMutator是函数，则直接执行，否则就通过mergeReactiveObjects方法合并到state中，最后生成subscriptionMutation对象，<strong>通过triggerSubscriptions方法触发数据的更新</strong>。</p><pre><code class=\"language-javascript\">  function $patch(\n    partialStateOrMutator:\n      | _DeepPartial&lt;UnwrapRef&lt;S&gt;&gt;\n      | ((state: UnwrapRef&lt;S&gt;) =&gt; void)\n  ): void {\n    let subscriptionMutation: SubscriptionCallbackMutation&lt;S&gt;\n    isListening = isSyncListening = false\n    // reset the debugger events since patches are sync\n    /* istanbul ignore else */\n    if (__DEV__) {\n      debuggerEvents = []\n    }\n    if (typeof partialStateOrMutator === 'function') {\n      partialStateOrMutator(pinia.state.value[$id] as UnwrapRef&lt;S&gt;)\n      subscriptionMutation = {\n        type: MutationType.patchFunction,\n        storeId: $id,\n        events: debuggerEvents as DebuggerEvent[],\n      }\n    } else {\n      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator)\n      subscriptionMutation = {\n        type: MutationType.patchObject,\n        payload: partialStateOrMutator,\n        storeId: $id,\n        events: debuggerEvents as DebuggerEvent[],\n      }\n    }\n    nextTick().then(() =&gt; {\n      isListening = true\n    })\n    isSyncListening = true\n    // because we paused the watcher, we need to manually call the subscriptions\n    triggerSubscriptions(\n      subscriptions,\n      subscriptionMutation,\n      pinia.state.value[$id] as UnwrapRef&lt;S&gt;\n    )\n  }\n\n</code></pre><p>然后定义partialStore对象去存储ID、$patch、Pinia实例，并且新增了subscribe方法。再调用reactive函数把partialStore包裹成响应式对象，通过pinia._s.set的方法实现store的挂载。</p><p>最后我们通过pinia._s.get获取的就是partialStore对象，defineStore返回的方法useStore就可以通过useStore去获取缓存的Pinia对象，实现对数据的更新和读取。</p><p>这里我们也可以看到，除了直接执行Action方法，还可以通过调用内部的 <code>count.$patch({count:count+1})</code> 的方式来实现数字的累加。</p><pre><code class=\"language-javascript\">  const partialStore = {\n    _p: pinia,\n    // _s: scope,\n    $id,\n    $onAction: addSubscription.bind(null, actionSubscriptions),\n    $patch,\n    $reset,\n    $subscribe(callback, options = {}) {\n      const removeSubscription = addSubscription(\n        subscriptions,\n        callback,\n        options.detached,\n        () =&gt; stopWatcher()\n      )\n      const stopWatcher = scope.run(() =&gt;\n        watch(\n          () =&gt; pinia.state.value[$id] as UnwrapRef&lt;S&gt;,\n          (state) =&gt; {\n            if (options.flush === 'sync' ? isSyncListening : isListening) {\n              callback(\n                {\n                  storeId: $id,\n                  type: MutationType.direct,\n                  events: debuggerEvents as DebuggerEvent,\n                },\n                state\n              )\n            }\n          },\n          assign({}, $subscribeOptions, options)\n        )\n      )!\n\n      return removeSubscription\n    }\n    \n\n  const store: Store&lt;Id, S, G, A&gt; = reactive(\n    assign({}， partialStore )\n  )\n\n  // store the partial store now so the setup of stores can instantiate each other before they are finished without\n  // creating infinite loops.\n  pinia._s.set($id, store)\n\n\n\n</code></pre><p><strong>我们可以看出一个简单的store功能，真正需要支持生产环境的时候，也需要很多逻辑的封装。</strong></p><p>代码内部除了__dev__调试环境中对Devtools支持的语法，还有很多适配Vue 2的语法，并且同时支持Optipn风格和Composition风格去创建store。createSetupStore等方法内部也会通过Map的方式实现缓存，并且setActivePinia方法可以在多个Pinia实例的时候获取当前的实例。</p><p>这些思路在Vue、vue-router源码中都能看到类似的实现方式，这种性能优化的思路和手段也值得我们学习，在项目开发中也可以借鉴。</p><h2>总结</h2><p>最后我们总结一下今天学到的内容吧。由于课程之前的内容已经手写了一个迷你的Vuex，这一讲我们就越过Vuex4，直接去研究了Vuex5的提案。</p><p>Vuex5针对Vuex4中的几个痛点，去掉了容易混淆的概念Mutation，并且去掉了对TypeScript不友好的namespace功能，使用组合store的方式让Vuex对TypeScript更加友好。</p><p>Pinia就是Vuex5提案产出的框架，现在已经是Vue官方的框架了，也就是Vuex5的实现。在Pinia的代码中，我们通过createPinia创建Pinia实例，并且可以通过Option和Composition两种风格的API去创建store，返回 useStore 函数获取Pinia的实例后，就可以进行数据的修改和读取。</p><h2>思考</h2><p>最后留一个思考题吧。对于数据共享语法，还有provide/inject和自己定义的Composition，什么时候需要使用Pinia呢？</p><p>欢迎到评论区分享你的想法，也欢迎你把这一讲的内容分享给你的朋友们，我们下一讲再见！</p>","neighbors":{"left":{"article_title":"35｜Vite原理：写一个迷你的Vite","id":476156},"right":{"article_title":"37｜前端路由原理：vue-router源码剖析","id":476717}},"comments":[]}