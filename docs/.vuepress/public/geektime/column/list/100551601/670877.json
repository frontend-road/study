{"id":670877,"title":"07｜超时控制：怎么保证用户一定能在1s内拿到响应？","content":"<p>你好，我是大明。今天我们来聊一个非常常见但是经常被忽略的话题——超时控制。</p><p>和前面我们讲的熔断、限流、降级和隔离一样，超时控制也是构建高可用系统的一环，因为<strong>它能够节省系统资源，提高资源的有效利用率。</strong></p><p>一般在面试的时候，关于超时控制，被问得最多的问题就是调用某个接口时的超时时间是多长，以及你为什么认为这个超时设置是合理的。一般我们都能给出一个差不多的回答，不过如果你能够在超时控制的话题下稍微深入一点，比如聊一聊监听超时时间、链路超时控制，那你绝对能成为所有候选人中最靓的仔。</p><p>所以今天我就带你来了解超时控制的方方面面，同时会给出全链路超时控制方案，让你在面试中更加出彩。</p><h2>前置知识</h2><p>超时控制是一个非常简单的东西，它是指在规定的时间内完成操作，如果不能完成，那么就返回一个超时响应。</p><p>和超时控制有关的内容，你需要记住以下几点：</p><ul>\n<li>超时控制的目标或者说好处。</li>\n<li>超时控制的形态。</li>\n<li>如何确定超时时间？这会是一个面试热点。</li>\n<li>超时之后能不能中断业务？</li>\n<li>谁来监听超时时间？</li>\n</ul><p>那么我们一个个看。</p><h3>超时控制目标</h3><p>超时控制有两个目标，一是<strong>确保客户端能在预期的时间内拿到响应</strong>。这其实是用户体验一个重要理念“坏响应也比没响应好”的体现。</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/49/b4541b78dc513da2591028a317404d49.png?wh=1920x1158\" alt=\"图片\"></p><p>二是<strong>及时释放资源</strong>。这其中影响最大的是线程和连接两种资源。</p><!-- [[[read_end]]] --><ul>\n<li>释放线程：在超时的情况下，客户端收到了超时响应之后就可以继续往后执行，等执行完毕，这个线程就可以被用于执行别的业务。而如果没有超时控制，那么这个线程就会被一直占有。而像Go这种语言，协程会被一直占有。</li>\n<li>释放连接：连接可以是 RPC 连接，也可以是数据库连接。类似的道理，如果没有拿到响应，客户端会一直占据这个连接。</li>\n</ul><p><strong>及时释放资源是提高系统可用性的有效做法</strong>，现实中经常遇到的一类事故就是因为缺乏超时控制引起了连接泄露、线程泄露。</p><p><img src=\"https://static001.geekbang.org/resource/image/29/d7/294bf1836d832237c5192528d3f764d7.png?wh=1920x1087\" alt=\"图片\"></p><h3>超时控制形态</h3><p>超时控制从形态上来看分成两种。</p><ul>\n<li>调用超时控制，比如说你在调用下游接口的时候，为这一次调用设置一个超时时间。</li>\n<li>链路超时控制，是指整条调用链路被一个超时时间控制。比如说你的业务有一条链路是 A 调用 B，B 调用 C。如果链路超时时间是 1s，首先 A 调用 B 的超时时间是 1s，如果 B 收到请求的时候已经过去了 200ms，那么 B 调用 C 的超时时间就不能超过 800ms。</li>\n</ul><p>链路超时控制在微服务架构里面用得比较多，一般在核心服务或者非常看重响应时间的服务里面采用。</p><p><img src=\"https://static001.geekbang.org/resource/image/46/84/468d49acc6e79ec7a9c75431552a0084.png?wh=1920x1195\" alt=\"图片\"></p><p>比如说大厂的 App 首页接口响应时间都有硬性规定。就像某司的要求是 50ms，也就是说不管你后端多复杂，不管你后面调用多少个服务，你的响应时间都必须控制在 50ms 以内。我后面会再深入讨论这个问题，它是你刷亮点的关键。</p><h3>确定超时时间</h3><p>确定超时时间是一个我们在面试中经常碰到的问题，常见的4种确定超时时间的方式是<strong>根据用户体验来确定、根据被调用接口的响应时间来确定、根据压测结果来确定、根据代码来确定</strong>。</p><p>超时时间要设置合理，过长可能会因为资源释放不及时而出事故，过短可能调用者会频繁超时，业务几乎没有办法执行。</p><h4>根据用户体验</h4><p>一般的做法就是根据用户体验来决定超时时间。比如说产品经理认为这个用户最多只能在这里等待 300ms，那么你的超时时间就最多设置为 300ms。</p><p>但如果仅仅依靠用户体验来决定超时时间也是不现实的，比如说当你去问产品经理某个接口对性能要求的时候，他让你看着办。那么这个时候你就要选择下一种策略了。</p><p><img src=\"https://static001.geekbang.org/resource/image/1f/f4/1f0358de4e5230b915699b487c6f82f4.png?wh=1920x1030\" alt=\"图片\"></p><h4>根据响应时间</h4><p>在实践中，大多数时候都是根据被调用接口的响应时间来确定超时时间。一般情况下，你可以选择使用 <strong>99 线</strong>或者 <strong>999 线</strong>来作为超时时间。</p><p>所谓的 99 线是指 99% 的请求，响应时间都在这个值以内。比如说 99 线为 1s，那么意味着 99% 的请求响应时间都在 1s 以内。999 线也是类似的含义。</p><p><img src=\"https://static001.geekbang.org/resource/image/c1/e4/c1b6d12ab861e298f93ccdf4d92768e4.png?wh=1920x1104\" alt=\"图片\"></p><p>但是使用这种方式要求这个接口已经接入了类似 Prometheus 之类的可观测性工具，能够算出 99 线或者 999 线。如果一个接口是新接口，你要调用它，而这时候根本没有 99 线或者 999 线的数据。那么你可以考虑使用压力测试。</p><h4>压力测试</h4><p>简单来说，你可以通过压力测试来找到被调用接口的 99 线和 999 线。而且压力测试应该尽可能在和线上一样的环境下进行。但是就像我在限流里面提到的，很多公司其实内部没有什么压测环境，也不可能让你停下新功能开发去做压力测试。那么就无法采用压力测试来采集到响应时间数据。</p><p>所以你就只剩下最后一个手段，根据代码来计算。</p><h4>根据代码计算</h4><p>根据代码计算和我在限流里面讲的差不多。假如说你现在有一个接口，里面有三次数据库操作，还有一次访问 Redis 的操作和一次发送消息的操作，那么你接口的响应时间就应该这样计算：<br>\n$$接口的响应时间=数据库响应时间 \\times 3 + Redis 响应时间 + 发送消息的响应时间$$</p><p>如果你觉得不保险，那么你可以在计算出来的结果上再加一点作为余量。比如说你通过分析代码认为响应时间应该在 200ms，那么你完全可以加上 100ms 作为余量。你可以告诉这个接口的调用者，将超时时间设置为 300ms。</p><h3>超时中断业务</h3><p>在面试的时候，还有一个值得和面试官深入讨论的问题——超时中断业务。所谓的中断业务是指，当调用一个服务超时之后，这个服务还会继续执行吗？</p><p>答案是基本上会继续执行，除非服务端自己主动检测一下本次收到的请求是否已经超时了。</p><p>举例来说，如果你的业务逻辑有 A、B、C 三个步骤。假如说你执行到 B 的时候超时了，如果你的代码里面没有检测到，那么还是会继续执行 C。但是如果你<strong>主动</strong>检测了超时，那么你就可以在 B 执行之后就返回。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/5d/a7581ccd86b90323e8e7053edb06905d.png?wh=1920x1033\" alt=\"图片\"></p><p>但是正常在实践中，我们是不会写这种手动检测的繁琐代码的。所以经常出现一个问题，就是客户端虽然超时了，但是实际上服务端已经执行成功了。</p><p>你可以看一下我给出的这张示意图，用户第一次提交注册的时候拿到了超时响应，但是实际上他注册成功了，数据库写入了注册信息。所以当他第二次尝试重试的时候，立刻遇到了重复手机号码的错误。</p><p><img src=\"https://static001.geekbang.org/resource/image/18/b2/182364b44ec65fa6a9ac40862961edb2.png?wh=1920x1033\" alt=\"图片\"></p><p>不过如果中间件监听超时时间部分设计得好，它可以帮我们中断一些步骤。</p><h3>监听超时时间</h3><p>在微服务框架里面，一般都是微服务框架客户端来监听超时时间。在一些特殊的微服务框架里面，框架服务端也会同步监听超时时间。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/89/41997c02b991a271232eb8c29131be89.png?wh=1920x1033\" alt=\"图片\"></p><p>框架客户端监听超时时间的情况下，如果在发起请求之前，就已经超时了，那么框架客户端根本不会发起请求，而是直接返回超时响应。这等于直接帮我们中断了业务的后续步骤。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/75/4d0237cdc6ab4330aaf328024f44a975.png?wh=1920x1033\" alt=\"图片\"></p><p>如果框架客户端已经发出了请求，之后触发了超时时间，那么框架客户端就会直接返回一个超时错误给应用代码。后续服务端返回了响应，框架客户端会直接丢弃。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/bd/d85df1a056b5ec775d4f1383c992bfbd.png?wh=1920x1033\" alt=\"图片\"></p><p>而框架服务端监听超时的情况下，如果在收到请求的时候就已经超时了，那么框架服务端根本不会调用服务端应用代码，而是直接给框架客户端返回一个超时响应。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/d3/4d5431398940776d93981a1eed6a28d3.png?wh=1920x1033\" alt=\"图片\"></p><p>而如果在等待业务响应的时候触发了超时，框架服务端会立刻释放连接，继续处理下一个请求。那么当应用返回响应的时候，它会直接丢弃，不会再回写响应。</p><p><img src=\"https://static001.geekbang.org/resource/image/c0/f2/c0cd1c7a467b58149d3dyy123d395ef2.png?wh=1920x1033\" alt=\"图片\"></p><p>所以你可以看出来不管是客户端根本不发请求，还是服务端根本不把请求转交给业务，都能够避免把资源花在没有意义的超时请求上。为什么超时请求没有意义呢？因为用户都已经看到超时的页面了，所以后端继续处理已经没有意义了。</p><p>总体来说，监听超时时间这个知识点面试官还是不太容易能想到的，所以在面试的时候如果你能深入讨论一下这个问题，应该可以增加一些亮点。</p><h2>面试准备</h2><p>前面我们讲到的超时控制的目标、两种形态以及确定超时时间的方法你都要记住。此外你要弄清楚公司内是怎么使用超时时间的，你可以收集一些资料。</p><ul>\n<li>你所在公司的核心业务，尤其是App首页之类的，公司层面上的性能要求是什么？也就是说响应时间必须控制在多少以内，然后进一步了解有没有采用链路超时控制。</li>\n<li>你自己维护的服务调用下游的时候有没有设置超时时间，超时时间都是多长？</li>\n<li>数据库查询有没有设置超时时间？</li>\n<li>跟任何第三方中间件打交道的代码有没有设置超时时间？例如查询 Redis，发送消息到 Kafka等。</li>\n</ul><p>然后你要注意在公司里面收集一些跟超时控制相关的事故报告。例如因为没有设置超时时间，导致数据库连接耗尽或者线程数量飙升等事故报告。这些事故报告你可以在面试的过程中用来解释超时控制的必要性，或者用来凸显你解决事故的能力。</p><p>在面试前我们也需要提前设想一下，关于超时控制，面试官会问到哪些问题？我整理了一下最常见的几个问题，你也可以借助这几个问题回忆一下前面的几个知识点。</p><p><img src=\"https://static001.geekbang.org/resource/image/a0/d7/a082eb211df1011a25c86e28d1a160d7.jpg?wh=1920x1315\" alt=\"图片\"></p><p>如果你现在调用别的服务、第三方接口、中间件都没有设置任何超时时间，或者使用的是默认超时时间，那么你就可以尝试自己先手动设置一下超时时间。这也是为了加深你的印象，更好地把控细节。</p><h2>基本思路</h2><p>大多数时候面试官可能就是随便问一下你在调用别的服务的时候有没有设置超时时间，那么你可以简单回答，关键词是<strong>超时控制目标</strong>。</p><blockquote>\n<p>我会设置超时时间，一般来说设置超时时间是为了用户体验和及时释放资源。比如说我有一个接口是提供给首页使用的，整个接口要求的超时时间是不超过 100ms。这个 100ms 就是公司规定的，是从用户体验出发确定的超时时间。</p>\n</blockquote><p>这一步，我们只是说了一个硬性规定 100ms 的例子，换句话说是从用户体验出发确定的 100ms。那么面试官就可能会追问：“如果公司没这种规定你怎么确定合理的超时时间呢？”。这时候你就可以回答前置知识里面提到的<strong>四种手段</strong>。</p><blockquote>\n<p>没有规定的话，最好的办法就是从用户体验的角度出发确定超时时间，这个可以考虑咨询一下产品经理。如果这个方式不行的话，就可以考虑根据被调用接口的响应时间，来确定调用者的超时时间。比如说我要调用 A 接口，如果 A 接口的 999 线是 200ms，那么我就可以把我这一次调用的超时时间设置成 200ms。除了 999 线，99 线也可以作为超时时间。<br>\n&nbsp;<br>\n如果我要调用的是一个新接口，没有性能数据，那么就可以考虑执行压测，然后根据结果选用 99 线或者 999 线。压测的结果也不仅仅可以用在这里，也可以用在限流那里。实在没办法，我们还可以根据代码里面的复杂操作来计算一个时间。</p>\n</blockquote><p>在这个回答里面，面试官可能从两个角度继续深挖。第一个是99 线和 999 线究竟选哪个比较好。那么你可以抓住关键词<strong>可用性</strong>来回答。</p><blockquote>\n<p>原则上是看公司的可用性要求，要求几个 9 就要几个 9。如果没有硬性规定，那么看 99 线和 999 线相差多不多。不多的话就用 999 线，多的话就用 99 线。</p>\n</blockquote><p>第二个是面试官可能会把问题切换到限流相关的内容上，因为你这里提到了<a href=\"https://time.geekbang.org/column/article/670039\">限流</a>，所以需要做好被提问的心理准备。</p><p>紧接着，你可以补一个因为超时控制设置不合理而出现的事故。这里我用一个数据库超时的例子，你可以参考，关键词是<strong>数据库连接</strong>。</p><blockquote>\n<p>正常来说，对任何第三方的调用我都会设置超时时间。如果没有设置超时时间或者超时时间过长，都可能引起资源泄露。比如说早期我们公司就出现过一个事故，某个同事的数据库查询超时时间设置得过长，在数据库性能出现抖动的时候，客户端的所有查询都被长时间阻塞，导致连接池中的连接耗尽。</p>\n</blockquote><p>你可以把这个案例替换成实际工作中发生的事故，它能够进一步说明超时控制在保障系统可用性中的作用。</p><p>如果想要尽量避免这样的事故发生，更好地用超时保护我们的系统，那就需要一个更加周全的方案了，就是为我们的系统接入链路超时控制，这样做用户体验会更好。</p><h2>链路超时控制</h2><p>链路超时控制就是我们今天的亮点方案，本身链路超时就是一个非常适合“一杆子”打到底的话题。也就是说从链路超时控制本身可以延伸出许多问题，所以你千万要记得做好话术引导。当面试官问你链路超时控制是什么的时候，你就可以先简单介绍链路超时的基本特征，关键词是<strong>链路</strong>。</p><blockquote>\n<p>链路超时控制和普通超时控制最大的区别是链路超时控制会作用于整条链路上的任何一环。例如在 A 调用 B，B 调用 C 的链路中，如果 A 设置了超时时间 1s，那么 A 调用 B 不能超过 1s。然后当 B 收到请求之后，如果已经过去了 200ms，那么 B 调用 C 的超时时间就不能超过 800ms。因此链路超时的关键是<strong>在链路中传递超时时间</strong>。</p>\n</blockquote><p>在最后一句话里面，你提到了传递超时时间，但是并没有说怎么传递超时时间，这就是给面试官追问的机会。如果面试官追问了，你可以这么回答，关键词是<strong>协议头</strong>。</p><blockquote>\n<p>大部分情况下，链路超时时间在网络中传递是放在协议头的。如果是 RPC 协议，那么就放在 RPC 协议头，比如说 Dubbo 的头部；如果是 HTTP 那么就是放在 HTTP 头部。比较特殊的是 gRPC 这种基于 HTTP 的 RPC 协议，它是利用 HTTP 头部作为 RPC 的头部，所以也是放在 HTTP 头部的。至于放的是什么东西，就取决于不同的协议是如何设计的了。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/08/11/08f6c43b8344e63166805b4ea54fa211.png?wh=1920x1031\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/55/b0/557433a1f110b645f4ab81cffe9324b0.png?wh=2540x1084\" alt=\"\" title=\"gRPC 官网对超时字段的说明\"></p><p>在最后一句，你依旧留了一个小尾巴。这句话是引导向超时时间传递的值究竟是什么的问题。正常来说，在链路中传递的可以是<strong>剩余超时时间</strong>，也可以是<strong>超时时间戳</strong>。</p><p><img src=\"https://static001.geekbang.org/resource/image/30/47/30492551b757691bffb1cde3b629d847.png?wh=1920x1033\" alt=\"图片\"></p><p>这两者是各有优缺点的。目前来说剩余超时时间用得比较多，一般是以毫秒作为单位传递一个数值。它的缺点是服务端收到请求之后需要减去网络传输时间，得到真正的超时时间。</p><p>而超时时间戳则涉及到时钟同步的问题，不过大多数情况下时钟之间的差值都很小，和超时时间动辄几百毫秒比起来，不值一提。所以如果面试官感兴趣，你就继续回答，关键词是<strong>剩余超时时间或超时时间戳</strong>。</p><blockquote>\n<p>一般超时时间传递的就两种：剩余超时时间或者超时时间戳。比如说剩余 1s，那么就用毫秒作为单位，数值是 1000。这种做法的缺陷就是服务端收到请求之后，要减去请求在网络中传输的时间。比如说 C 收到请求，剩余超时时间是 500ms，如果它知道 B 到 C 之间请求传输要花去 10ms，那么 C 应该用 500ms 减去 10 ms 作为真实的剩余超时时间。不过现实中比较难知道网络传输花了 10ms 这件事。<br>\n&nbsp;<br>\n而传递超时时间戳，那么就会受到时钟同步影响。假如说此时此刻，A 的时钟是 00:00:00，而 B 的时钟是 00:00:01，也就是 A 的时钟比 B 的时钟慢了一秒。那么如果 A 传递的超时时间戳是 00:00:01，那么 B 一收到请求，就会认为这个请求已经超时了。<br>\n&nbsp;<br>\n当然，正常来说时钟同步不至于出现那么大的偏差，大多数时钟偏差几乎可以忽略不计。不过在时钟回拨的场景下，还是会有问题。我之前听说不同云服务商之间的时钟同步问题比较严重，可能也需要注意。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/07/93/0729f5336243806eaf335031fbba4e93.png?wh=1920x1001\" alt=\"图片\"></p><p>在这个回答里面，你提到了难以知道 10ms 的问题，那么面试官自然就会问你该怎么知道网络传输耗时 10ms。换句话来说，你怎么计算请求的网络传输时间。你就可以这样回答：</p><blockquote>\n<p>计算网络传输时间最好的方式就是使用性能测试。在模拟线上环境的情况下，让客户端发送平均大小的请求到服务端，采集传输时间，取一个平均值作为网络传输时间。另外一个方式就是不管。比如说正常情况下，A 调用 B，A 和 B 都在同一个机房，网络传输连 1ms 都不用。相比我们超时时间动辄设置为几百毫秒，这一点时间完全可以忽略不计。不过万一服务涉及到了跨机房，尤其是那种机房在两个城市的，城市还离得远的，这部分时间就要计算在内。</p>\n</blockquote><p>你还可以额外强调一下，性能测试要完全模拟线上环境，否则计算就会有偏差。</p><blockquote>\n<p>性能测试一定要尽可能模拟线上环境，尤其是线上环境可能会有更加复杂的网关和防火墙设置，这部分也会影响传输速率。</p>\n</blockquote><p>链路超时还有一个弊端，也是面试官经常问的，就是如果 A 调用 B，B 调用 C 的这条链路的超时时间设置为 1s，但是 B 这个服务的提供者就说自己是不可能在 1s 内返回响应的，那么该怎么办？</p><p>这时候你要坚持最正确的做法，要求 B <strong>优化性能</strong>。</p><blockquote>\n<p>这个时候最好的做法是强制要求 B 优化它的性能。比如说产品经理明确说这条链路就是要在 1s 内返回，那么 B 就应该去优化性能，而不是在这里抱怨不可能在 1s 内返回。不过要是 A 本身超时时间可以妥协的话，那么 A 调大一点也可以。</p>\n</blockquote><p>最后的妥协话术，就是想表达你并不是完全不通人情的。如果面试你的人是CTO 之类的领导，那么他们可能会看重软技能，就会问你如何推动 B 优化性能。这方面你按照你们公司的跨部门合作流程来回答就可以。</p><p>不过我还有一个不那么正统充满了人情世故的解决方案，你可以参考。</p><blockquote>\n<p>可以考虑请 B 的维护者喝杯奶茶，吃顿小烧烤，基本上都能解决问题。实在不行，就只能走官方渠道，找领导和产品经理出面，去找 B 的维护者的上级。不过闹到这一步关系就会比较僵，还是优先考虑请奶茶小烧烤的方案。</p>\n</blockquote><h2>面试思路总结</h2><p>现在我再来问你，怎么保证用户能够在1秒内拿到响应，你应该对答案了然于胸了吧？这也是我们这节课的主题超时控制的目标之一，也就是确保客户端能在预期的时间内拿到响应，保证用户的体验。此外超时控制还能通过在客户端或服务端监听超时时间来感应到系统超时，及时释放线程和连接，保证系统的可用性。</p><p>而这个1秒又是怎么算出来的呢？实际上我们可以通过用户体验、响应时间、压力测试和根据代码计算这四种方式来确定具体的超时时间，不宜过长或过短，过长，会浪费客户端资源；过短，可能导致客户端无法处理响应。</p><p>在实际的工作场景中，超时控制有调用超时控制和链路超时控制两种形态，而在微服务架构中链路超时控制比较常用。所以我们在亮点方案部分对链路超时控制进行了深入的讨论，你需要记住里面的几个关键词：<strong>链路、协议头、剩余超时时间与超时时间戳</strong>。你可以从这几个关键词出发，整理自己的思路。</p><p>在最后，我同样给出了这节课的思维导图，你可以参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/16/6a130372a33674045441yyd254f3b216.png?wh=1920x1345\" alt=\"图片\"></p><h2>思考题</h2><p>最后你来思考几个问题。</p><ul>\n<li>在根据被调用接口的响应时间来确定超时时间里面，我说可以使用 99 线或者 999 线来作为超时时间。那么平均响应时间和响应时间中位数，能不能作为超时时间？</li>\n<li>在监听超时那里，能不能只在服务端那边监听超时，而客户端完全不管？</li>\n</ul><p>欢迎你把你的答案分享在评论区，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"06｜隔离：怎么保证尊贵的VIP用户体验不受损？","id":670854},"right":{"article_title":"08｜调用第三方：下游的接口不稳定性能又差怎么办？","id":672238}},"comments":[{"had_liked":false,"id":377427,"user_name":"penbox","can_delete":false,"product_type":"c1","uid":1052938,"ip_address":"四川","ucode":"59C4F47ACCB7F2","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/0a/59639f1f.jpg","comment_is_top":false,"comment_ctime":1688480605,"is_pvip":true,"replies":[{"id":137608,"content":"赞，回答得很对！","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688830592,"ip_address":"广东","comment_id":377427,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"1. 在根据被调用接口的响应时间来确定超时时间里面，提到可以使用 99 线或 999 线来作为超时时间。那么平均响应时间和响应时间的中位数，能不能作为超时时间？\n不能，这意味着一半的请求都会超时，业务基本处于不可用的状态了。\n2. 在监听超时那里，能不能只在服务端那边监听超时，而客户端完全不管？\n我觉得不行，客户端不能保证所有服务端都是做了超时控制的，也不能保证请求就一定就能到服务端那边。\n假如发生了网络故障，服务端根本收不到请求，客户端本地没做超时控制的话，就会发生线程泄露。","like_count":16,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622941,"discussion_content":"赞，回答得很对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688830592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383220,"user_name":"傲娇的小宝","can_delete":false,"product_type":"c1","uid":1493922,"ip_address":"北京","ucode":"C079B19BCC1B7C","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/a2/5e7c557e.jpg","comment_is_top":false,"comment_ctime":1698714950,"is_pvip":false,"replies":[{"id":139756,"content":"赞。\n问题二还涉及到一个问题，那就是即便服务端返回了超时响应，但是客户端也有可能收不到，因为网络通信总是不稳定的。又或者收到了超时的时候，已经过去了很久了，远大于超时时间。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1699282818,"ip_address":"广东","comment_id":383220,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"关于问题一：我和马云一平均我也资产上e呢，中位数对于超时场景没有意义。而且既然是中，说明有一半达不到，那服务总不能只为剩下能达到的提供正确返回呐。\n关于问题二：如果客户端不管，不太保险，因为是否超时就完全取决于服务端了，一方面可能与业务要求不符，另一方面可能引发一些无法判断的问题。","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631071,"discussion_content":"赞。\n问题二还涉及到一个问题，那就是即便服务端返回了超时响应，但是客户端也有可能收不到，因为网络通信总是不稳定的。又或者收到了超时的时候，已经过去了很久了，远大于超时时间。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699282818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382520,"user_name":"Geek_680632","can_delete":false,"product_type":"c1","uid":3730160,"ip_address":"浙江","ucode":"9421FB33A0C6A9","user_header":"","comment_is_top":false,"comment_ctime":1697515278,"is_pvip":false,"replies":[{"id":139348,"content":"赞！\n2 主要是因为，服务端的超时响应，客户端可能完全收不到，比如说网络出现了问题。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1697724428,"ip_address":"广东","comment_id":382520,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"1.不能，这里需要考虑的是最差的情况；2.不行，客户端需要在超时展示相应的处理方案。","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629851,"discussion_content":"赞！\n2 主要是因为，服务端的超时响应，客户端可能完全收不到，比如说网络出现了问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697724429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378602,"user_name":"浩仔是程序员","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"广东","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1690466351,"is_pvip":false,"replies":[{"id":137978,"content":"是的，对于客户端来说，超时控制能够释放自己的资源；对于服务端来说，就要考虑限流之类的措施了。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1690605469,"ip_address":"广东","comment_id":378602,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"在调用第三方接口设置超时时间还应该考虑接口的qps，服务部署导致的网络因素等，如果qps很高，超时时间太长，就容易把自己系统的线程打爆","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624477,"discussion_content":"是的，对于客户端来说，超时控制能够释放自己的资源；对于服务端来说，就要考虑限流之类的措施了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690605469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389850,"user_name":"黄堃健","can_delete":false,"product_type":"c1","uid":2037522,"ip_address":"广东","ucode":"B4AD5250A41B3A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/YbUxEV3741vKZAiasOXggWucQbmicJwIjg3HDE58oyibYXbSop9QQFqZ7X6OhynDoo6rDHwzK8njSeJjN9hx3pJXg/132","comment_is_top":false,"comment_ctime":1713659541,"is_pvip":false,"replies":[{"id":141978,"content":"再难也比搞一个压测容易啊！","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1715230790,"ip_address":"广东","comment_id":389850,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"大明哥， 根据代码计算和我在限流里面讲的差不多。假如说你现在有一个接口，里面有三次数据库操作，还有一次访问 Redis 的操作和一次发送消息的操作，那么你接口的响应时间就应该这样计算：   一般代码都是多分支，似乎不好估算","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644398,"discussion_content":"再难也比搞一个压测容易啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715230791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383490,"user_name":"IT小村","can_delete":false,"product_type":"c1","uid":1330357,"ip_address":"北京","ucode":"BDFEE0D821CB6E","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/b5/fcede1a9.jpg","comment_is_top":false,"comment_ctime":1699156671,"is_pvip":false,"replies":[{"id":139750,"content":"没有，我用的不是老外思维中的 Down stream  up stream 的说法，就是比较符合中文语境下的那种说法。如果你不习惯的话，你可以自动在脑海里面替换一下，问题也不大。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1699282535,"ip_address":"广东","comment_id":383490,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"上下游反了吧","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631065,"discussion_content":"没有，我用的不是老外思维中的 Down stream  up stream 的说法，就是比较符合中文语境下的那种说法。如果你不习惯的话，你可以自动在脑海里面替换一下，问题也不大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699282535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378595,"user_name":"ZhiguoXue_IT","can_delete":false,"product_type":"c1","uid":2639055,"ip_address":"北京","ucode":"EAA83F53B54520","user_header":"https://static001.geekbang.org/account/avatar/00/28/44/cf/791d0f5e.jpg","comment_is_top":false,"comment_ctime":1690463720,"is_pvip":false,"replies":[{"id":137975,"content":"我这里用的都是服务 A 调用服务 B  的例子。如果你是浏览器那边过来，那么只能是浏览器那边设置超时。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1690605347,"ip_address":"广东","comment_id":378595,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"现在的开发接口的时候，都给前端承诺当前接口的tp99，之前没实现过在服务端自己控制时长，也就是服务端是如何控制如果1s没有执行完就给客户端返回特殊的值？","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624473,"discussion_content":"我这里用的都是服务 A 调用服务 B  的例子。如果你是浏览器那边过来，那么只能是浏览器那边设置超时。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690605347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377830,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"浙江","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1689313160,"is_pvip":false,"replies":[{"id":137705,"content":"如果相差很多话，有点不太值得选 999 线。我举个例子，比如说有些系统会有很明显的长尾请求。假设说 99 线可能是 1s，结果 999 线是 3s。正常来说这种时候我都不会考虑 999 线。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1689423604,"ip_address":"广东","comment_id":377830,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"原则上是看公司的可用性要求，要求几个 9 就要几个 9。如果没有硬性规定，那么看 99 线和 999 线相差多不多。不多的话就用 999 线，多的话就用 99 线。\n\n这里为什么99线和999线差的多的话用99线呢？如果两者差距比较大，不是应该选999线更好吗，这样超时报错会少很多","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623402,"discussion_content":"如果相差很多话，有点不太值得选 999 线。我举个例子，比如说有些系统会有很明显的长尾请求。假设说 99 线可能是 1s，结果 999 线是 3s。正常来说这种时候我都不会考虑 999 线。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689423604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1015205,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/a5/930c9103.jpg","nickname":"Feng","note":"","ucode":"42DB60B7BF69D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623388,"discussion_content":"我理解相差太大的话，说明那0.9%区间请求已经让系统的响应快速变慢了，999线的超时时间太大会导致资源来不及释放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689402822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377693,"user_name":"Geek_18dfaf","can_delete":false,"product_type":"c1","uid":1543018,"ip_address":"上海","ucode":"CFC27E78220E2D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqw0R25Bt0iahFhEHfnxmzr9iaZf0eLsDQtFUJzgGkYwHTqicU9TydMngrJ4yL7D50awD2VibHBAdqplQ/132","comment_is_top":false,"comment_ctime":1689048154,"is_pvip":false,"replies":[{"id":137652,"content":"实际上，超时是在 RPC 协议上做的。如果 RPC 协议设计了超时字段，那么基本上服务端都会处理，比如说 gRPC 就做了","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1689068505,"ip_address":"广东","comment_id":377693,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"老师，在哪些微服务框架里面，服务端做了超时时间的监听","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623137,"discussion_content":"实际上，超时是在 RPC 协议上做的。如果 RPC 协议设计了超时字段，那么基本上服务端都会处理，比如说 gRPC 就做了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689068505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377647,"user_name":"信客","can_delete":false,"product_type":"c1","uid":3019142,"ip_address":"北京","ucode":"C9A871FEDEBA55","user_header":"https://static001.geekbang.org/account/avatar/00/2e/11/86/3ef486e0.jpg","comment_is_top":false,"comment_ctime":1688954362,"is_pvip":false,"replies":[{"id":137642,"content":"1. 你说得对，因为你做不到彻底中断业务。比如插入这个例子，你在等待 MySQL 返回响应，那么你肯定没办法让 MySQL 插入一半之后就不插入了\n2. 并没有什么好的手段，你只能提示一下用户，然后让用户跳转登录。","user_name":"作者回复","user_name_real":"作者","uid":1176655,"ctime":1689047891,"ip_address":"广东","comment_id":377647,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"老师，针对“用户看到失败响应，但实际已经执行成功”这种现象\n1. 感觉不论是客户端监听，还是客户端和服务端都监听（比如，服务端执行完了，但恰好在传输结果时，客户端发生超时，返回了失败响应），都可能发生这种现象？\n2. 站在用户的角度来说，很confusing，明明看到失败，但第二次说已经有人注册。这种情况一般要怎么处理呢？","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623111,"discussion_content":"1. 你说得对，因为你做不到彻底中断业务。比如插入这个例子，你在等待 MySQL 返回响应，那么你肯定没办法让 MySQL 插入一半之后就不插入了\n2. 并没有什么好的手段，你只能提示一下用户，然后让用户跳转登录。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689047891,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1172050,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e2/52/56dbb738.jpg","nickname":"牙小木","note":"","ucode":"E5C12D37A62949","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623063,"discussion_content":"low的方法就是报警人工处理了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688989712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377225,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1688102753,"is_pvip":false,"replies":[{"id":137485,"content":"1. 有的，但是要少一点。比如说你服务端处理一个异步任务，然后发现执行超过了预期时间，你强制杀掉，也算是释放资源。\n2. 如果 A 调用了 B，那么 A 就是 B 的客户端，B 就是 A 的服务端。一般我们说的客户端都不会指用户的那个终端，后面也是这样。\n\n后面三个问题我都回过你了，只不过那时候我还不太熟练，所以用的不是作者身份回你。你可以回去看看。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688215589,"ip_address":"广东","comment_id":377225,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"请教老师几个问题：\n本课有一个疑问：\nQ1：“释放资源”，服务端也有这个需要吧。\n超时后释放资源，文中都是针对客户端讲的。服务端没有释放资源这个需求吗？\n\n下面是02课的问题，因为我阅读的晚，所以也发的晚，这里补上：\nQ1：“客户端”并不是指终端，对吗？\n本课中用到的“客户端”，我理解并不是通常意义上的网页或APP，而是相对于“服务端”的客户端；从后面的内容来看，也不是指Nginx或网关。那在微服务架构中，具体是指什么？\nQ2：哈希算法怎么保证均匀吗？\n文中“所以要尽可能保证哈希值计算出来的结果是均匀的”，有什么具体方法来保证哈希的均匀性？\nQ3：负载均衡有多种算法，对于一个公司来说，是确定用其中的某一种吗？或者是不同的子系统可能采用不同的算法？或者有多种算法，会根据情况动态选用其中的某一种？\nQ4：“响应+元数据”这种，消息是怎么发送的？\n响应是给用户的，通常就是HTTP消息，元数据是内部用的，这两种怎么处理？定义一个内部消息，包含这两种，Nginx收到后取出元数据然后将响应发给用户吗？\n","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622401,"discussion_content":"1. 有的，但是要少一点。比如说你服务端处理一个异步任务，然后发现执行超过了预期时间，你强制杀掉，也算是释放资源。\n2. 如果 A 调用了 B，那么 A 就是 B 的客户端，B 就是 A 的服务端。一般我们说的客户端都不会指用户的那个终端，后面也是这样。\n\n后面三个问题我都回过你了，只不过那时候我还不太熟练，所以用的不是作者身份回你。你可以回去看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688215589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377217,"user_name":"木几丶","can_delete":false,"product_type":"c1","uid":2420294,"ip_address":"福建","ucode":"FFDB958DA64F8C","user_header":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","comment_is_top":false,"comment_ctime":1688095629,"is_pvip":true,"replies":[{"id":137462,"content":"1. 对的。用平均数或者中位数就意味着你有接近一半的请求会超时。所以肯定不能用。\n2. 正解，在经过网络传输之后，服务端返回的超时响应可能直接就没收到。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688107315,"ip_address":"广东","comment_id":377217,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"回答问题：\n1、我觉得不能，暂时想不出用中位数或平均值作为超时时间的场景，当然可能有特殊业务场景也为可知\n2、不能。服务端可以不管，客户端一定要管，因为请求经过网络，不一定会到达服务端，或者说到达服务端的时间不可控","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622322,"discussion_content":"1. 对的。用平均数或者中位数就意味着你有接近一半的请求会超时。所以肯定不能用。\n2. 正解，在经过网络传输之后，服务端返回的超时响应可能直接就没收到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688107315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377205,"user_name":"Johar","can_delete":false,"product_type":"c1","uid":1101969,"ip_address":"重庆","ucode":"834136A6F64CDC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/91/89123507.jpg","comment_is_top":false,"comment_ctime":1688086291,"is_pvip":false,"replies":[{"id":137465,"content":"1. 正确。平均响应时间和中位数都意味着有大量请求会超时。\n2. 正确。在分布式系统里面，客户端并不一定能够拿到响应，所以客户端必须要做超时控制。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688107570,"ip_address":"广东","comment_id":377205,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"1.超时时间主要看的大部分请求的响应时间，一般情况下，都是选择T99或者T999。当然具体问题具体分析，要是当前业务有长尾效应，也可以取平均响应时间或者响应时间中位数。\n2. 客户端也需要监听是否超时，一般ToC的业务，客户端的请求要通过公网才能到达后端，公网的网络情况有很大未知性，不可控，也有一定的丢包率，所以在客户端监听超时，可以给客户更好的用户体验，另外也就将超时数据传回服务端，作为监控指标，方便后续优化。","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622325,"discussion_content":"1. 正确。平均响应时间和中位数都意味着有大量请求会超时。\n2. 正确。在分布式系统里面，客户端并不一定能够拿到响应，所以客户端必须要做超时控制。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688107570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377203,"user_name":"我好像一点都不像程序员","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"广东","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/63189817.jpg","comment_is_top":false,"comment_ctime":1688083618,"is_pvip":false,"replies":[{"id":137464,"content":"正确！\n对于我们研发来说当然是为了系统保护，不过站在政治正确的角度，也是为了用户体验。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688107479,"ip_address":"广东","comment_id":377203,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"作为中台后端，经常被要求提高相关的公共接口性能，以避免拖前台的后腿。对于超时控制，日常用的最多的还是对服务的自我保护，避免由于调用第三方服务(下游服务，第三方接口，数据库等)，在第三方由于各种问题导致长时间不返回，导致调用方而无法及时释放协程等资源，也无法释放内存，在突然的大流量情况下，很容易出事故。因此，业务方代码会有超时控制，网关层也可以设置超时。","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622324,"discussion_content":"正确！\n对于我们研发来说当然是为了系统保护，不过站在政治正确的角度，也是为了用户体验。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688107479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377201,"user_name":"TimJuly","can_delete":false,"product_type":"c1","uid":1065064,"ip_address":"北京","ucode":"56FE7BF7447DEA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eooNCNEO0vhRiagdrCnNW2LWzzV4g5tXJ9KkTu9hegCTx6lBrA06AZ3Uylb2wdKjvtrmZUWkKKHTGA/132","comment_is_top":false,"comment_ctime":1688062746,"is_pvip":false,"replies":[{"id":137463,"content":"你说的是性能优化，这里提到的是超时控制。\n\n超时控制本身也不是解决容量问题，就是我说的要在给定的时间内返回响应。而且，超时控制也不太能解决雪崩问题，尤其是在没有办法中断业务的情况下，只能说缓解一下，效果不如熔断。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688107422,"ip_address":"广东","comment_id":377201,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"这篇感觉有点儿跑题了\n要在规定时间内做出响应，无非就是提高并发度，做好性能优化、缓存优化、强弱依赖的容错等，文章中提到的不多，建议后面也讲讲～\n文章里提到的的超时时间传递和超时控制策略我感觉更多的是解决容量问题，防止服务雪崩","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622323,"discussion_content":"你说的是性能优化，这里提到的是超时控制。\n\n超时控制本身也不是解决容量问题，就是我说的要在给定的时间内返回响应。而且，超时控制也不太能解决雪崩问题，尤其是在没有办法中断业务的情况下，只能说缓解一下，效果不如熔断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688107422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1065064,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eooNCNEO0vhRiagdrCnNW2LWzzV4g5tXJ9KkTu9hegCTx6lBrA06AZ3Uylb2wdKjvtrmZUWkKKHTGA/132","nickname":"TimJuly","note":"","ucode":"56FE7BF7447DEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":622364,"discussion_content":"我看到过的雪崩往往来自于不合理的超时重试策略，一个小的故障被放大，出现了之后当然是熔断更有效，但是合理的策略可以尽量降低走到这一步的可能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688132714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":622323,"ip_address":"北京","group_id":0},"score":622364,"extra":""}]},{"author":{"id":1052938,"avatar":"https://static001.geekbang.org/account/avatar/00/10/11/0a/59639f1f.jpg","nickname":"penbox","note":"","ucode":"59C4F47ACCB7F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622619,"discussion_content":"按我的理解，把响应时间控制到规定时间内，是我们开发的目标。而超时控制，是一种兜底的手段。这两者并不冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688480985,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389061,"user_name":"lip","can_delete":false,"product_type":"c1","uid":3215925,"ip_address":"浙江","ucode":"1E72A22F1214D1","user_header":"https://static001.geekbang.org/account/avatar/00/31/12/35/4ca3cc7d.jpg","comment_is_top":false,"comment_ctime":1711468177,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"请问在应用链路超时场景下，如果出现数据重复的场景该如何处理？判断是否超时，然后选择是否回滚吗","like_count":0}]}