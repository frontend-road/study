{"id":216778,"title":"10 | 集合类：坑满地的List列表操作","content":"<p>你好，我是朱晔。今天，我来和你说说List列表操作有哪些坑。</p><p>Pascal之父尼克劳斯 · 维尔特（Niklaus Wirth），曾提出一个著名公式“程序=数据结构+算法”。由此可见，数据结构的重要性。常见的数据结构包括List、Set、Map、Queue、Tree、Graph、Stack等，其中List、Set、Map、Queue可以从广义上统称为集合类数据结构。</p><p>现代编程语言一般都会提供各种数据结构的实现，供我们开箱即用。Java也是一样，比如提供了集合类的各种实现。Java的集合类包括Map和Collection两大类。Collection包括List、Set和Queue三个小类，其中List列表集合是最重要也是所有业务代码都会用到的。所以，今天我会重点介绍List的内容，而不会集中介绍Map以及Collection中其他小类的坑。</p><p>今天，我们就从把数组转换为List集合、对List进行切片操作、List搜索的性能问题等几个方面着手，来聊聊其中最可能遇到的一些坑。</p><h2>使用Arrays.asList把数据转换为List的三个坑</h2><p>Java 8中Stream流式处理的各种功能，大大减少了集合类各种操作（投影、过滤、转换）的代码量。所以，在业务开发中，我们常常会把原始的数组转换为List类数据结构，来继续展开各种Stream操作。</p><!-- [[[read_end]]] --><p>你可能也想到了，使用Arrays.asList方法可以把数组一键转换为List，但其实没这么简单。接下来，就让我们看看其中的缘由，以及使用Arrays.asList把数组转换为List的几个坑。</p><p>在如下代码中，我们初始化三个数字的int[]数组，然后使用Arrays.asList把数组转换为List：</p><pre><code>int[] arr = {1, 2, 3};\nList list = Arrays.asList(arr);\nlog.info(&quot;list:{} size:{} class:{}&quot;, list, list.size(), list.get(0).getClass());\n</code></pre><p>但，这样初始化的List并不是我们期望的包含3个数字的List。通过日志可以发现，这个List包含的其实是一个int数组，整个List的元素个数是1，元素类型是整数数组。</p><pre><code>12:50:39.445 [main] INFO org.geekbang.time.commonmistakes.collection.aslist.AsListApplication - list:[[I@1c53fd30] size:1 class:class [I\n</code></pre><p>其原因是，只能是把int装箱为Integer，不可能把int数组装箱为Integer数组。我们知道，Arrays.asList方法传入的是一个泛型T类型可变参数，最终int数组整体作为了一个对象成为了泛型类型T：</p><pre><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a) {\n    return new ArrayList&lt;&gt;(a);\n}\n</code></pre><p>直接遍历这样的List必然会出现Bug，修复方式有两种，如果使用Java8以上版本可以使用Arrays.stream方法来转换，否则可以把int数组声明为包装类型Integer数组：</p><pre><code>int[] arr1 = {1, 2, 3};\nList list1 = Arrays.stream(arr1).boxed().collect(Collectors.toList());\nlog.info(&quot;list:{} size:{} class:{}&quot;, list1, list1.size(), list1.get(0).getClass());\n\n\nInteger[] arr2 = {1, 2, 3};\nList list2 = Arrays.asList(arr2);\nlog.info(&quot;list:{} size:{} class:{}&quot;, list2, list2.size(), list2.get(0).getClass());\n</code></pre><p>修复后的代码得到如下日志，可以看到List具有三个元素，元素类型是Integer：</p><pre><code>13:10:57.373 [main] INFO org.geekbang.time.commonmistakes.collection.aslist.AsListApplication - list:[1, 2, 3] size:3 class:class java.lang.Integer\n</code></pre><p>可以看到第一个坑是，<strong>不能直接使用Arrays.asList来转换基本类型数组</strong>。那么，我们获得了正确的List，是不是就可以像普通的List那样使用了呢？我们继续往下看。</p><p>把三个字符串1、2、3构成的字符串数组，使用Arrays.asList转换为List后，将原始字符串数组的第二个字符修改为4，然后为List增加一个字符串5，最后数组和List会是怎样呢？</p><pre><code>String[] arr = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;};\nList list = Arrays.asList(arr);\narr[1] = &quot;4&quot;;\ntry {\n    list.add(&quot;5&quot;);\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\nlog.info(&quot;arr:{} list:{}&quot;, Arrays.toString(arr), list);\n</code></pre><p>可以看到，日志里有一个UnsupportedOperationException，为List新增字符串5的操作失败了，而且把原始数组的第二个元素从2修改为4后，asList获得的List中的第二个元素也被修改为4了：</p><pre><code>java.lang.UnsupportedOperationException\n\tat java.util.AbstractList.add(AbstractList.java:148)\n\tat java.util.AbstractList.add(AbstractList.java:108)\n\tat org.geekbang.time.commonmistakes.collection.aslist.AsListApplication.wrong2(AsListApplication.java:41)\n\tat org.geekbang.time.commonmistakes.collection.aslist.AsListApplication.main(AsListApplication.java:15)\n13:15:34.699 [main] INFO org.geekbang.time.commonmistakes.collection.aslist.AsListApplication - arr:[1, 4, 3] list:[1, 4, 3]\n</code></pre><p>这里，又引出了两个坑。</p><p>第二个坑，<strong>Arrays.asList返回的List不支持增删操作。</strong>Arrays.asList返回的List并不是我们期望的java.util.ArrayList，而是Arrays的内部类ArrayList。ArrayList内部类继承自AbstractList类，并没有覆写父类的add方法，而父类中add方法的实现，就是抛出UnsupportedOperationException。相关源码如下所示：</p><pre><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a) {\n    return new ArrayList&lt;&gt;(a);\n}\n\nprivate static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n    implements RandomAccess, java.io.Serializable\n{\n    private final E[] a;\n\n\n    ArrayList(E[] array) {\n        a = Objects.requireNonNull(array);\n    }\n...\n\n    @Override\n    public E set(int index, E element) {\n        E oldValue = a[index];\n        a[index] = element;\n        return oldValue;\n    }\n    ...\n}\n\npublic abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; {\n...\npublic void add(int index, E element) {\n        throw new UnsupportedOperationException();\n    }\n}\n</code></pre><p>第三个坑，<strong>对原始数组的修改会影响到我们获得的那个List</strong>。看一下ArrayList的实现，可以发现ArrayList其实是直接使用了原始的数组。所以，我们要特别小心，把通过Arrays.asList获得的List交给其他方法处理，很容易因为共享了数组，相互修改产生Bug。</p><p>修复方式比较简单，重新new一个ArrayList初始化Arrays.asList返回的List即可：</p><pre><code>String[] arr = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;};\nList list = new ArrayList(Arrays.asList(arr));\narr[1] = &quot;4&quot;;\ntry {\n    list.add(&quot;5&quot;);\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\nlog.info(&quot;arr:{} list:{}&quot;, Arrays.toString(arr), list);\n</code></pre><p>修改后的代码实现了原始数组和List的“解耦”，不再相互影响。同时，因为操作的是真正的ArrayList，add也不再出错：</p><pre><code>13:34:50.829 [main] INFO org.geekbang.time.commonmistakes.collection.aslist.AsListApplication - arr:[1, 4, 3] list:[1, 2, 3, 5]\n</code></pre><h2>使用List.subList进行切片操作居然会导致OOM？</h2><p>业务开发时常常要对List做切片处理，即取出其中部分元素构成一个新的List，我们通常会想到使用List.subList方法。但，和Arrays.asList的问题类似，List.subList返回的子List不是一个普通的ArrayList。这个子List可以认为是原始List的视图，会和原始List相互影响。如果不注意，很可能会因此产生OOM问题。接下来，我们就一起分析下其中的坑。</p><p>如下代码所示，定义一个名为data的静态List来存放Integer的List，也就是说data的成员本身是包含了多个数字的List。循环1000次，每次都从一个具有10万个Integer的List中，使用subList方法获得一个只包含一个数字的子List，并把这个子List加入data变量：</p><pre><code>private static List&lt;List&lt;Integer&gt;&gt; data = new ArrayList&lt;&gt;();\n\nprivate static void oom() {\n    for (int i = 0; i &lt; 1000; i++) {\n        List&lt;Integer&gt; rawList = IntStream.rangeClosed(1, 100000).boxed().collect(Collectors.toList());\n        data.add(rawList.subList(0, 1));\n    }\n}\n</code></pre><p>你可能会觉得，这个data变量里面最终保存的只是1000个具有1个元素的List，不会占用很大空间，但程序运行不久就出现了OOM：</p><pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space\n\tat java.util.Arrays.copyOf(Arrays.java:3181)\n\tat java.util.ArrayList.grow(ArrayList.java:265)\n</code></pre><p><strong>出现OOM的原因是，循环中的1000个具有10万个元素的List始终得不到回收，因为它始终被subList方法返回的List强引用。</strong>那么，返回的子List为什么会强引用原始的List，它们又有什么关系呢？我们再继续做实验观察一下这个子List的特性。</p><p>首先初始化一个包含数字1到10的ArrayList，然后通过调用subList方法取出2、3、4；随后删除这个SubList中的元素数字3，并打印原始的ArrayList；最后为原始的ArrayList增加一个元素数字0，遍历SubList输出所有元素：</p><pre><code>List&lt;Integer&gt; list = IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toList());\nList&lt;Integer&gt; subList = list.subList(1, 4);\nSystem.out.println(subList);\nsubList.remove(1);\nSystem.out.println(list);\nlist.add(0);\ntry {\n    subList.forEach(System.out::println);\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\n</code></pre><p>代码运行后得到如下输出：</p><pre><code>[2, 3, 4]\n[1, 2, 4, 5, 6, 7, 8, 9, 10]\njava.util.ConcurrentModificationException\n\tat java.util.ArrayList$SubList.checkForComodification(ArrayList.java:1239)\n\tat java.util.ArrayList$SubList.listIterator(ArrayList.java:1099)\n\tat java.util.AbstractList.listIterator(AbstractList.java:299)\n\tat java.util.ArrayList$SubList.iterator(ArrayList.java:1095)\n\tat java.lang.Iterable.forEach(Iterable.java:74)\n</code></pre><p>可以看到两个现象：</p><ul>\n<li>原始List中数字3被删除了，说明删除子List中的元素影响到了原始List；</li>\n<li>尝试为原始List增加数字0之后再遍历子List，会出现ConcurrentModificationException。</li>\n</ul><p>我们分析下ArrayList的源码，看看为什么会是这样。</p><pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable\n{\n    protected transient int modCount = 0;\n\tprivate void ensureExplicitCapacity(int minCapacity) {\n        modCount++;\n        // overflow-conscious code\n        if (minCapacity - elementData.length &gt; 0)\n            grow(minCapacity);\n    }\n\tpublic void add(int index, E element) {\n\t\trangeCheckForAdd(index);\n\n\t\tensureCapacityInternal(size + 1);  // Increments modCount!!\n\t\tSystem.arraycopy(elementData, index, elementData, index + 1,\n\t\t                 size - index);\n\t\telementData[index] = element;\n\t\tsize++;\n\t}\n\n\tpublic List&lt;E&gt; subList(int fromIndex, int toIndex) {\n\t\tsubListRangeCheck(fromIndex, toIndex, size);\n\t\treturn new SubList(this, offset, fromIndex, toIndex);\n\t}\n\n\tprivate class SubList extends AbstractList&lt;E&gt; implements RandomAccess {\n\t\tprivate final AbstractList&lt;E&gt; parent;\n\t\tprivate final int parentOffset;\n\t\tprivate final int offset;\n\t\tint size;\n\n\t\tSubList(AbstractList&lt;E&gt; parent,\n\t        int offset, int fromIndex, int toIndex) {\n\t\t    this.parent = parent;\n\t\t    this.parentOffset = fromIndex;\n\t\t    this.offset = offset + fromIndex;\n\t\t    this.size = toIndex - fromIndex;\n\t\t    this.modCount = ArrayList.this.modCount;\n\t\t}\n\n        public E set(int index, E element) {\n            rangeCheck(index);\n            checkForComodification();\n            return l.set(index+offset, element);\n        }\n\n\t\tpublic ListIterator&lt;E&gt; listIterator(final int index) {\n\t\t            checkForComodification();\n\t\t            ...\n\t\t}\n\n\t\tprivate void checkForComodification() {\n\t\t    if (ArrayList.this.modCount != this.modCount)\n\t\t        throw new ConcurrentModificationException();\n\t\t}\n\t\t...\n\t}\n}\n</code></pre><p>第一，ArrayList维护了一个叫作modCount的字段，表示集合结构性修改的次数。所谓结构性修改，指的是影响List大小的修改，所以add操作必然会改变modCount的值。</p><p>第二，分析第21到24行的subList方法可以看到，获得的List其实是<strong>内部类SubList</strong>，并不是普通的ArrayList，在初始化的时候传入了this。</p><p>第三，分析第26到39行代码可以发现，这个SubList中的parent字段就是原始的List。SubList初始化的时候，并没有把原始List中的元素复制到独立的变量中保存。我们可以认为SubList是原始List的视图，并不是独立的List。双方对元素的修改会相互影响，而且SubList强引用了原始的List，所以大量保存这样的SubList会导致OOM。</p><p>第四，分析第47到55行代码可以发现，遍历SubList的时候会先获得迭代器，比较原始ArrayList modCount的值和SubList当前modCount的值。获得了SubList后，我们为原始List新增了一个元素修改了其modCount，所以判等失败抛出ConcurrentModificationException异常。</p><p>既然SubList相当于原始List的视图，那么避免相互影响的修复方式有两种：</p><ul>\n<li>一种是，不直接使用subList方法返回的SubList，而是重新使用new ArrayList，在构造方法传入SubList，来构建一个独立的ArrayList；</li>\n<li>另一种是，对于Java 8使用Stream的skip和limit API来跳过流中的元素，以及限制流中元素的个数，同样可以达到SubList切片的目的。</li>\n</ul><pre><code>//方式一：\nList&lt;Integer&gt; subList = new ArrayList&lt;&gt;(list.subList(1, 4));\n\n//方式二：\nList&lt;Integer&gt; subList = list.stream().skip(1).limit(3).collect(Collectors.toList());\n</code></pre><p>修复后代码输出如下：</p><pre><code>[2, 3, 4]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n2\n4\n</code></pre><p>可以看到，删除SubList的元素不再影响原始List，而对原始List的修改也不会再出现List迭代异常。</p><h2>一定要让合适的数据结构做合适的事情</h2><p>在介绍<a href=\"https://time.geekbang.org/column/article/209494\">并发工具</a>时，我提到要根据业务场景选择合适的并发工具或容器。在使用List集合类的时候，不注意使用场景也会遇见两个常见误区。</p><p><strong>第一个误区是，使用数据结构不考虑平衡时间和空间</strong>。</p><p>首先，定义一个只有一个int类型订单号字段的Order类：</p><pre><code>@Data\n@NoArgsConstructor\n@AllArgsConstructor\nstatic class Order {\n    private int orderId;\n}\n</code></pre><p>然后，定义一个包含elementCount和loopCount两个参数的listSearch方法，初始化一个具有elementCount个订单对象的ArrayList，循环loopCount次搜索这个ArrayList，每次随机搜索一个订单号：</p><pre><code>private static Object listSearch(int elementCount, int loopCount) {\n    List&lt;Order&gt; list = IntStream.rangeClosed(1, elementCount).mapToObj(i -&gt; new Order(i)).collect(Collectors.toList());\n    IntStream.rangeClosed(1, loopCount).forEach(i -&gt; {\n        int search = ThreadLocalRandom.current().nextInt(elementCount);\n        Order result = list.stream().filter(order -&gt; order.getOrderId() == search).findFirst().orElse(null);\n        Assert.assertTrue(result != null &amp;&amp; result.getOrderId() == search);\n    });\n    return list;\n}\n</code></pre><p>随后，定义另一个mapSearch方法，从一个具有elementCount个元素的Map中循环loopCount次查找随机订单号。Map的Key是订单号，Value是订单对象：</p><pre><code>private static Object mapSearch(int elementCount, int loopCount) {\n    Map&lt;Integer, Order&gt; map = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toMap(Function.identity(), i -&gt; new Order(i)));\n    IntStream.rangeClosed(1, loopCount).forEach(i -&gt; {\n        int search = ThreadLocalRandom.current().nextInt(elementCount);\n        Order result = map.get(search);\n        Assert.assertTrue(result != null &amp;&amp; result.getOrderId() == search);\n    });\n    return map;\n}\n</code></pre><p>我们知道，搜索ArrayList的时间复杂度是O(n)，而HashMap的get操作的时间复杂度是O(1)。<strong>所以，要对大List进行单值搜索的话，可以考虑使用HashMap，其中Key是要搜索的值，Value是原始对象，会比使用ArrayList有非常明显的性能优势。</strong></p><p>如下代码所示，对100万个元素的ArrayList和HashMap，分别调用listSearch和mapSearch方法进行1000次搜索：</p><pre><code>int elementCount = 1000000;\nint loopCount = 1000;\nStopWatch stopWatch = new StopWatch();\nstopWatch.start(&quot;listSearch&quot;);\nObject list = listSearch(elementCount, loopCount);\nSystem.out.println(ObjectSizeCalculator.getObjectSize(list));\nstopWatch.stop();\nstopWatch.start(&quot;mapSearch&quot;);\nObject map = mapSearch(elementCount, loopCount);\nstopWatch.stop();\nSystem.out.println(ObjectSizeCalculator.getObjectSize(map));\nSystem.out.println(stopWatch.prettyPrint());\n</code></pre><p>可以看到，仅仅是1000次搜索，listSearch方法耗时3.3秒，而mapSearch耗时仅仅108毫秒。</p><pre><code>20861992\n72388672\nStopWatch '': running time = 3506699764 ns\n---------------------------------------------\nns         %     Task name\n---------------------------------------------\n3398413176  097%  listSearch\n108286588  003%  mapSearch\n</code></pre><p>即使我们要搜索的不是单值而是条件区间，也可以尝试使用HashMap来进行“搜索性能优化”。如果你的条件区间是固定的话，可以提前把HashMap按照条件区间进行分组，Key就是不同的区间。</p><p>的确，如果业务代码中有频繁的大ArrayList搜索，使用HashMap性能会好很多。类似，如果要对大ArrayList进行去重操作，也不建议使用contains方法，而是可以考虑使用HashSet进行去重。说到这里，还有一个问题，使用HashMap是否会牺牲空间呢？</p><p>为此，我们使用ObjectSizeCalculator工具打印ArrayList和HashMap的内存占用，可以看到ArrayList占用内存21M，而HashMap占用的内存达到了72M，是List的三倍多。进一步使用MAT工具分析堆可以再次证明，ArrayList在内存占用上性价比很高，77%是实际的数据（如第1个图所示，16000000/20861992），<strong>而HashMap的“含金量”只有22%</strong>（如第2个图所示，16000000/72386640）。</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/24/1e8492040dd4b1af6114a6eeba06e524.png?wh=1428*226\" alt=\"\"></p><p><img src=\"https://static001.geekbang.org/resource/image/53/c7/53d53e3ce2efcb081f8d9fa496cb8ec7.png?wh=1762*290\" alt=\"\"></p><p>所以，在应用内存吃紧的情况下，我们需要考虑是否值得使用更多的内存消耗来换取更高的性能。这里我们看到的是平衡的艺术，空间换时间，还是时间换空间，只考虑任何一个方面都是不对的。</p><p><strong>第二个误区是，过于迷信教科书的大O时间复杂度</strong>。</p><p>数据结构中要实现一个列表，有基于连续存储的数组和基于指针串联的链表两种方式。在Java中，有代表性的实现是ArrayList和LinkedList，前者背后的数据结构是数组，后者则是（双向）链表。</p><p>在选择数据结构的时候，我们通常会考虑每种数据结构不同操作的时间复杂度，以及使用场景两个因素。查看<a href=\"https://www.bigocheatsheet.com/\">这里</a>，你可以看到数组和链表大O时间复杂度的显著差异：</p><ul>\n<li>对于数组，随机元素访问的时间复杂度是O(1)，元素插入操作是O(n)；</li>\n<li>对于链表，随机元素访问的时间复杂度是O(n)，元素插入操作是O(1)。</li>\n</ul><p>那么，在大量的元素插入、很少的随机访问的业务场景下，是不是就应该使用LinkedList呢？接下来，我们写一段代码测试下两者随机访问和插入的性能吧。</p><p>定义四个参数一致的方法，分别对元素个数为elementCount的LinkedList和ArrayList，循环loopCount次，进行随机访问和增加元素到随机位置的操作：</p><pre><code>//LinkedList访问\nprivate static void linkedListGet(int elementCount, int loopCount) {\n    List&lt;Integer&gt; list = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toCollection(LinkedList::new));\n    IntStream.rangeClosed(1, loopCount).forEach(i -&gt; list.get(ThreadLocalRandom.current().nextInt(elementCount)));\n}\n\n//ArrayList访问\nprivate static void arrayListGet(int elementCount, int loopCount) {\n    List&lt;Integer&gt; list = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toCollection(ArrayList::new));\n    IntStream.rangeClosed(1, loopCount).forEach(i -&gt; list.get(ThreadLocalRandom.current().nextInt(elementCount)));\n}\n\n//LinkedList插入\nprivate static void linkedListAdd(int elementCount, int loopCount) {\n    List&lt;Integer&gt; list = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toCollection(LinkedList::new));\n    IntStream.rangeClosed(1, loopCount).forEach(i -&gt; list.add(ThreadLocalRandom.current().nextInt(elementCount),1));\n}\n\n//ArrayList插入\nprivate static void arrayListAdd(int elementCount, int loopCount) {\n    List&lt;Integer&gt; list = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toCollection(ArrayList::new));\n    IntStream.rangeClosed(1, loopCount).forEach(i -&gt; list.add(ThreadLocalRandom.current().nextInt(elementCount),1));\n}\n</code></pre><p>测试代码如下，10万个元素，循环10万次：</p><pre><code>int elementCount = 100000;\nint loopCount = 100000;\nStopWatch stopWatch = new StopWatch();\nstopWatch.start(&quot;linkedListGet&quot;);\nlinkedListGet(elementCount, loopCount);\nstopWatch.stop();\nstopWatch.start(&quot;arrayListGet&quot;);\narrayListGet(elementCount, loopCount);\nstopWatch.stop();\nSystem.out.println(stopWatch.prettyPrint());\n\n\nStopWatch stopWatch2 = new StopWatch();\nstopWatch2.start(&quot;linkedListAdd&quot;);\nlinkedListAdd(elementCount, loopCount);\nstopWatch2.stop();\nstopWatch2.start(&quot;arrayListAdd&quot;);\narrayListAdd(elementCount, loopCount);\nstopWatch2.stop();\nSystem.out.println(stopWatch2.prettyPrint());\n</code></pre><p>运行结果可能会让你大跌眼镜。在随机访问方面，我们看到了ArrayList的绝对优势，耗时只有11毫秒，而LinkedList耗时6.6秒，这符合上面我们所说的时间复杂度；<strong>但，随机插入操作居然也是LinkedList落败，耗时9.3秒，ArrayList只要1.5秒</strong>：</p><pre><code>---------------------------------------------\nns         %     Task name\n---------------------------------------------\n6604199591  100%  linkedListGet\n011494583  000%  arrayListGet\n\n\nStopWatch '': running time = 10729378832 ns\n---------------------------------------------\nns         %     Task name\n---------------------------------------------\n9253355484  086%  linkedListAdd\n1476023348  014%  arrayListAdd\n</code></pre><p>翻看LinkedList源码发现，插入操作的时间复杂度是O(1)的前提是，你已经有了那个要插入节点的指针。但，在实现的时候，我们需要先通过循环获取到那个节点的Node，然后再执行插入操作。前者也是有开销的，不可能只考虑插入操作本身的代价：</p><pre><code>public void add(int index, E element) {\n    checkPositionIndex(index);\n\n    if (index == size)\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\n\nNode&lt;E&gt; node(int index) {\n    // assert isElementIndex(index);\n\n    if (index &lt; (size &gt;&gt; 1)) {\n        Node&lt;E&gt; x = first;\n        for (int i = 0; i &lt; index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node&lt;E&gt; x = last;\n        for (int i = size - 1; i &gt; index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n</code></pre><p>所以，对于插入操作，LinkedList的时间复杂度其实也是O(n)。继续做更多实验的话你会发现，在各种常用场景下，LinkedList几乎都不能在性能上胜出ArrayList。</p><p>讽刺的是，LinkedList的作者约书亚 · 布洛克（Josh Bloch），在其推特上回复别人时说，虽然LinkedList是我写的但我从来不用，有谁会真的用吗？</p><p><img src=\"https://static001.geekbang.org/resource/image/12/cc/122a469eb03f16ab61d893ec57b34acc.png?wh=2658*1210\" alt=\"\"></p><p>这告诉我们，任何东西理论上和实际上是有差距的，请勿迷信教科书的理论，最好在下定论之前实际测试一下。抛开算法层面不谈，由于CPU缓存、内存连续性等问题，链表这种数据结构的实现方式对性能并不友好，即使在它最擅长的场景都不一定可以发挥威力。</p><h2>重点回顾</h2><p>今天，我分享了若干和List列表相关的错误案例，基本都是由“想当然”导致的。</p><p>第一，想当然认为，Arrays.asList和List.subList得到的List是普通的、独立的ArrayList，在使用时出现各种奇怪的问题。</p><ul>\n<li>Arrays.asList得到的是Arrays的内部类ArrayList，List.subList得到的是ArrayList的内部类SubList，不能把这两个内部类转换为ArrayList使用。</li>\n<li>Arrays.asList直接使用了原始数组，可以认为是共享“存储”，而且不支持增删元素；List.subList直接引用了原始的List，也可以认为是共享“存储”，而且对原始List直接进行结构性修改会导致SubList出现异常。</li>\n<li>对Arrays.asList和List.subList容易忽略的是，新的List持有了原始数据的引用，可能会导致原始数据也无法GC的问题，最终导致OOM。</li>\n</ul><p>第二，想当然认为，Arrays.asList一定可以把所有数组转换为正确的List。当传入基本类型数组的时候，List的元素是数组本身，而不是数组中的元素。</p><p>第三，想当然认为，内存中任何集合的搜索都是很快的，结果在搜索超大ArrayList的时候遇到性能问题。我们考虑利用HashMap哈希表随机查找的时间复杂度为O(1)这个特性来优化性能，不过也要考虑HashMap存储空间上的代价，要平衡时间和空间。</p><p>第四，想当然认为，链表适合元素增删的场景，选用LinkedList作为数据结构。在真实场景中读写增删一般是平衡的，而且增删不可能只是对头尾对象进行操作，可能在90%的情况下都得不到性能增益，建议使用之前通过性能测试评估一下。</p><p>今天用到的代码，我都放在了GitHub上，你可以点击<a href=\"https://github.com/JosephZhu1983/java-common-mistakes\">这个链接</a>查看。</p><h2>思考与讨论</h2><p>最后，我给你留下与ArrayList在删除元素方面的坑有关的两个思考题吧。</p><ol>\n<li>调用类型是Integer的ArrayList的remove方法删除元素，传入一个Integer包装类的数字和传入一个int基本类型的数字，结果一样吗？</li>\n<li>循环遍历List，调用remove方法删除元素，往往会遇到ConcurrentModificationException异常，原因是什么，修复方式又是什么呢？</li>\n</ol><p>你还遇到过与集合类相关的其他坑吗？我是朱晔，欢迎在评论区与我留言分享你的想法，也欢迎你把这篇文章分享给你的朋友或同事，一起交流。</p>","comments":[{"had_liked":false,"id":200592,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":true,"comment_ctime":1585622027,"is_pvip":true,"replies":[{"id":"75021","content":"点赞","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585624062,"ip_address":"","comment_id":200592,"utype":1}],"discussion_count":4,"race_medal":0,"score":"9.2233724378724004e+18","product_id":100047701,"comment_content":"哈哈，好巧，前两年有段时间比较闲，研究ArrayList和LinkedList，也对于所谓的ArrayList查询快，增删慢以及LinkedList查询慢，增删快提出过疑问，也做过类似的实验，然后去年给19年校招生入职培训的时候还专门分享过。要打破常规思维，多问为什么，要多听多看，多实验。<br>回答下问题：<br>1、int类型是index，也就是索引，是按照元素位置删除的；Integer是删除某个元素，内部是通过遍历数组然后对比，找到指定的元素，然后删除；两个都需要进行数组拷贝，是通过System.arraycopy进行的<br>2、以foreach为例说，遍历删除实质是变化为迭代器实现，不管是迭代器里面的remove()还是next()方法,都会checkForComodification();而这个方法是判断modCount和expectedModCount是否相等，这个modCount是这个list集合修改的次数，每一次add或者remove都会增加这个变量，然后迭代器每次去next或者去remove的时候检查checkForComodification();发现expectedModCount(这个迭代器修改的次数)和modCount(这个集合实际修改的次数)不相等，就会抛出ConcurrentModificationException，迭代器里面没有add方法，用迭代器时，可以删除原来集合的元素，但是！一定要用迭代器的remove方法而不是集合自身的remove方法，否则抛异常。","like_count":94,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490078,"discussion_content":"点赞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585624062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100750,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cb/ce/d9e00eb5.jpg","nickname":"undefined","note":"","ucode":"768098DBDBE333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363414,"discussion_content":"赞了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617191268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1666025,"avatar":"https://static001.geekbang.org/account/avatar/00/19/6b/e9/7620ae7e.jpg","nickname":"雨落～紫竹","note":"","ucode":"33CED2F34E708F","race_medal":4,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304980,"discussion_content":"早点看到这专栏  也不会在二面吃那么多亏  唉","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599730350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1075267,"avatar":"https://static001.geekbang.org/account/avatar/00/10/68/43/1fe64086.jpg","nickname":"zero_","note":"","ucode":"14D3AD3D997112","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552971,"discussion_content":"遍历删除实质是变化为迭代器实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645672464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200637,"user_name":"eazonshaw","can_delete":false,"product_type":"c1","uid":1493784,"ip_address":"","ucode":"423952F7CEF475","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/18/4877c08b.jpg","comment_is_top":false,"comment_ctime":1585626842,"is_pvip":false,"replies":[{"id":"75036","content":"这个回复挺有我的写作风格 😄","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585627394,"ip_address":"","comment_id":200637,"utype":1}],"discussion_count":1,"race_medal":0,"score":"143319547610","product_id":100047701,"comment_content":"思考题：<br>1. 不一样。使用 ArrayList 的 remove方法，如果传参是 Integer类型的话，表示的是删除元素，如果传参是int类型的话，表示的是删除相对应索引位置的元素。<br>同时，做了个小实验，如果是String类型的ArrayList，传参是Integer类型时，remove方法只是返回false，视为元素不存在。<br>2. 原因：查看源码可以发现，remove方法会发生结构化修改，也就是 modCount 会增加。当循环过程中，比较当前 List 的 modCount 与初始的 modCount 不相等，就会报 ConcurrentModificationException。解决方法：1.使用 ArrayList 的迭代器 iterator，并调用之中的remove方法。查看源码可以发现，内部类的remove方法，会维护一个expectedModCount，使其与 ArrayList 的modCount保持一致。2.如果是java 8，可以使用removeIf方法进行删除操作。<br><br>```<br>int expectedModCount = modCount;<br>public void remove() {<br>    ...<br>    checkForComodification();<br><br>    try {<br>        ...<br>        expectedModCount = modCount;<br>    } catch (IndexOutOfBoundsException ex) {<br>        throw new ConcurrentModificationException();<br>    }<br>}<br>final void checkForComodification() {<br>    if (modCount != expectedModCount)<br>        throw new ConcurrentModificationException();<br>}<br>```","like_count":33,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490084,"discussion_content":"这个回复挺有我的写作风格 😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585627394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200552,"user_name":"秋水","can_delete":false,"product_type":"c1","uid":1803454,"ip_address":"","ucode":"84F6843986CDE2","user_header":"https://static001.geekbang.org/account/avatar/00/1b/84/be/0370eae1.jpg","comment_is_top":false,"comment_ctime":1585618023,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"134729604199","product_id":100047701,"comment_content":"真的是迷信了LinkedList","like_count":32},{"had_liked":false,"id":200578,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1585620063,"is_pvip":false,"replies":[{"id":"75015","content":"👍🏻，源码ListRemoveApplication中也有我的实现","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585621156,"ip_address":"","comment_id":200578,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44535293023","product_id":100047701,"comment_content":"思考题2：<br>便利通常的实现方式for冒号的实现，其实底层还是用Iterator 删除元素，查看class文件大概是这样：<br><br>Iterator var2 = list.iterator();<br>    while(var2.hasNext()) {<br>      Integer integer = (Integer)var2.next();<br>      list.remove(integer);<br>    }<br><br>删除元素后会调用next方法，next调用checkForComodification方法：<br>final void checkForComodification() {<br>            if (modCount != expectedModCount)<br>                throw new ConcurrentModificationException();<br>        }<br>expectedModCount是初始化时，数组的modCount ，也就是说——初始化的数组长度和调用next方法时数组长度不一样时，就会ConcurrentModificationException，理论上讲，不仅仅remove，甚至是add也一样会报错。<br><br>尝试测试，将remove改为add：<br>while(var2.hasNext()) {<br>      Integer integer = (Integer)var2.next();<br>      list.add(integer);<br>    }<br>确实会报错。<br><br>知道了报错的原因，要修复倒也不难。<br>首先，摒弃for冒号，使用迭代器（其实迭代器也是for冒号）<br>既然，迭代器在List长度与迭代器初始化时识别到的List长度不一致就会报错。那就顺着它的意思来处理，每次List长度修改时，重新初始化迭代器。相当于长度重新初始化。<br><br>假设数组初始长度时10，形成的结果就是：<br>Iterator 初始化 expectedModCount = 10；<br>然后删除某元素，数组长度9，Iterator 长度10，这时候如果调用next就会报错，所以，在这时候，重新初始化Iterator <br>Iterator  长度初始化为9，与数组长度一致，就避免了报错。<br>代码实现如下：<br>Iterator var2 = list.iterator();<br>    while(var2.hasNext()) {<br>      Integer integer = (Integer)var2.next();<br>      if (integer.equals(2)){<br>        list.remove(integer);<br>        var2 = list.iterator();<br>      }<br>    }<br><br>代码写的比较随意，可能存在纰漏。欢迎指点<br><br>","like_count":11,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490074,"discussion_content":"👍🏻，源码ListRemoveApplication中也有我的实现","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585621156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200559,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1585618429,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"44535291389","product_id":100047701,"comment_content":"思考题1：<br>不一样，<br>remove 的两实现，<br>包装类型调用的是 boolean remove(Object o);方法，本质上是寻找集合中是否有该元素，有则删除。<br>基本类型int 调用的是public E remove(int index)方法，实现是直接删除下标。<br>另外返回值也有区别，<br>包装类型remove返回布尔，有该对象则返回true并删除，没有则返回false<br>基本类型的remove返回泛型对象，有则返回该对象，因为是跟据下标删除，所以不存在没有的情况，除非下标越界<br>","like_count":10},{"had_liked":false,"id":200548,"user_name":"👽","can_delete":false,"product_type":"c1","uid":1274117,"ip_address":"","ucode":"D313AF941B412D","user_header":"https://static001.geekbang.org/account/avatar/00/13/71/05/db554eba.jpg","comment_is_top":false,"comment_ctime":1585617968,"is_pvip":false,"replies":[{"id":"75005","content":"很不错的总结","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585618794,"ip_address":"","comment_id":200548,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23060454448","product_id":100047701,"comment_content":"感触颇深：<br>Arrays的asList和subList，使用过程中需要谨慎，甚至可以考虑直接不用。<br>要熟悉数据结构。ArrayList 和 HashMap就是典型对比，ArrayList更适合随机访问，节约内存空间，大多数情况下性能不错。但，因为其本质上是数组，所以，无法实现快速找到想要的值。<br>LinkedList  没有想象中好用，使用前请考虑清楚。<br>","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490062,"discussion_content":"很不错的总结","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585618794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200523,"user_name":"hellojd","can_delete":false,"product_type":"c1","uid":1341697,"ip_address":"","ucode":"4E51807AE7E472","user_header":"https://static001.geekbang.org/account/avatar/00/14/79/01/e71510dc.jpg","comment_is_top":false,"comment_ctime":1585615660,"is_pvip":false,"replies":[{"id":"75004","content":"：）","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585618766,"ip_address":"","comment_id":200523,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23060452140","product_id":100047701,"comment_content":"学习到了老师的探索精神，linedlist随机插入性能居然不高，刷新了认知。","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490055,"discussion_content":"：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585618766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200473,"user_name":"失火的夏天","can_delete":false,"product_type":"c1","uid":1241770,"ip_address":"","ucode":"10C6E66EB2A65F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","comment_is_top":false,"comment_ctime":1585602527,"is_pvip":false,"replies":[{"id":"74993","content":"1. 从完备性角度说sdk需要这样的数据结构<br>2. 就这个数据结构本身实现上并无问题<br>3. 也完全不是一无是处任何场景都没有优势<br>还是留着吧","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585616417,"ip_address":"","comment_id":200473,"utype":1}],"discussion_count":2,"race_medal":0,"score":"23060439007","product_id":100047701,"comment_content":"1.remove包装类数字是删除对象，基本类型的int数字是删除下标。<br>2.好像是modcount和什么东西对不上来着，具体忘记了，看看其他大佬怎么说。解决这玩意就是改用迭代器遍历，调用迭代器的remove方法。<br><br>话说到这个linkedlist，真是感觉全面被arraylist压制。那这数据结构还留着干嘛呢？为什么不删掉算了。。。我个人感觉linekdlist只有在头尾加入删除元素的时候有一点点优势了吧。用队列或者双端队列的时候会偶然用到。但是感觉用对应的数组模式实现，效率会更高些，就是要考虑扩容的问题。<br><br>老师能帮忙解答一下linkedlist留下没删是因为什么吗？","like_count":5,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490039,"discussion_content":"1. 从完备性角度说sdk需要这样的数据结构\n2. 就这个数据结构本身实现上并无问题\n3. 也完全不是一无是处任何场景都没有优势\n还是留着吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585616417,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225974,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b4/f6/e39d5af1.jpg","nickname":"钱米","note":"","ucode":"07AA44C6A40D34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389487,"discussion_content":"我可以不用，你不能没有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629292016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202030,"user_name":"汝林外史","can_delete":false,"product_type":"c1","uid":1188906,"ip_address":"","ucode":"3C66C0F0537A99","user_header":"https://static001.geekbang.org/account/avatar/00/12/24/2a/33441e2b.jpg","comment_is_top":false,"comment_ctime":1585890273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14470792161","product_id":100047701,"comment_content":"1. int会调用 public E remove(int index)方法   Integer会调用public boolean remove(Object o)方法<br><br>2.modcount改变导致的异常  改用foreach的方式。","like_count":3},{"had_liked":false,"id":201727,"user_name":"看不到de颜色","can_delete":false,"product_type":"c1","uid":1162714,"ip_address":"","ucode":"88348CCAE81931","user_header":"https://static001.geekbang.org/account/avatar/00/11/bd/da/3d76ea74.jpg","comment_is_top":false,"comment_ctime":1585826634,"is_pvip":false,"replies":[{"id":"75523","content":"有共鸣就好","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585898741,"ip_address":"","comment_id":201727,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14470728522","product_id":100047701,"comment_content":"老师这期的课程太让人产生共鸣了。之前生产就出过问题。调用方法，达到了用Arrays.asList返回的集合，然后对集合操作时就出了一场。当时看了asList的源码时才发现JDK居然还有这种坑。subList也确实是一个很容易采坑的地方，subList本质上就是把原List报了层皮返回了。关于ListList，头插的话性能应该是会碾压ArrayList，但是就看有没有这种场景了。<br>课后练习：<br>1.根据API可以看出，remove(int index) &#47; remove(Object element)<br>2.Iterator过程中集合结构不能发生变化，通常是遍历过程中其他线程对集合进行了add&#47;remove。可以用CopyOnWrite集合来避免。<br>","like_count":3,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490404,"discussion_content":"有共鸣就好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585898741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205175,"user_name":"大大大熊myeh","can_delete":false,"product_type":"c1","uid":1139413,"ip_address":"","ucode":"4832C2E7CEB151","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/d5/1f5c5ab6.jpg","comment_is_top":false,"comment_ctime":1586565506,"is_pvip":false,"replies":[{"id":"76680","content":"👍🏻","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1586571602,"ip_address":"","comment_id":205175,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10176500098","product_id":100047701,"comment_content":"巧了，思考题1与我之前遇到的问题一样，List#remove方法竟然没删掉里面的元素，最后才发现原来是重载方法的锅，int是删List中该索引的元素，Integer是删除List中值为该Integer的元素。<br><br>当时还写了篇博客记录，恬不知耻的放上来：https:&#47;&#47;planeswalker23.github.io&#47;2018&#47;09&#47;10&#47;List-remove&#47;<br><br>本篇收获颇多，特别是关于LinkedList的增删复杂度，之前也没看过LinkedList源码，于是一直以为增删很快。<br><br>得到一个结论：任何总结，还是得以源码为基础。所有不看源码的总结都是耍流氓。","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491414,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586571602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205034,"user_name":"程序员小跃","can_delete":false,"product_type":"c1","uid":1015483,"ip_address":"","ucode":"25BB96E0791A60","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","comment_is_top":false,"comment_ctime":1586512251,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10176446843","product_id":100047701,"comment_content":"真的是巧，在隔壁《设计模式》的迭代器模式里，也学了关于List的一些知识，今天的课后习题2，我又重新复习了两个课","like_count":2},{"had_liked":false,"id":201519,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1585798377,"is_pvip":false,"replies":[{"id":"75379","content":"jdk几？","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585800383,"ip_address":"","comment_id":201519,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10175732969","product_id":100047701,"comment_content":"int[] arr = {1, 2, 3};<br>List list = Arrays.asList(arr);<br>System.out.println(list + &quot; &quot; + list.size() + &quot; &quot; + list.get(0).getClass());<br><br><br>[1, 2, 3] 3 class java.lang.Integer 为何我本地和老师演示的不一样？？","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490358,"discussion_content":"jdk几？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585800383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1050508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","nickname":"蚂蚁内推+v","note":"","ucode":"24B10AEE54B3FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219802,"discussion_content":"抱歉，我用错库了，我用的是这个org.assertj.core.util.Arrays","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1585810844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232090,"discussion_content":"好吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586852197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":201314,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1585749543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10175684135","product_id":100047701,"comment_content":"Arrays.asList 返回的 List 不支持增删操作。 这个坑一直都知道，只是没去看源码，今天学到了，原来是Arrays的内部类ArrayList没有重写add方法，而是extends AbstractList的add()，后者会抛出UnsupportedOperationException","like_count":2},{"had_liked":false,"id":200558,"user_name":"pedro","can_delete":false,"product_type":"c1","uid":1200704,"ip_address":"","ucode":"F40C839DDFD599","user_header":"https://static001.geekbang.org/account/avatar/00/12/52/40/e57a736e.jpg","comment_is_top":false,"comment_ctime":1585618319,"is_pvip":false,"replies":[{"id":"75006","content":"👍🏻","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585618804,"ip_address":"","comment_id":200558,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175552911","product_id":100047701,"comment_content":"第二个问题，使用 for-each 或者 iterator 进行迭代删除 remove 时，容易导致 next() 检测的 modCount 不等于 expectedModCount 从而引发 ConcurrentModificationException。<br>在单线程下，推荐使用 next() 得到元素，然后直接调用 remove(),注意是无参的 remove; 多线程情况下还是使用并发容器吧😃","like_count":2,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490067,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585618804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247138,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1599617032,"is_pvip":false,"replies":[{"id":"90812","content":"是","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1599654274,"ip_address":"","comment_id":247138,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5894584328","product_id":100047701,"comment_content":"问题二可以用迭代器进行删除。<br>看源码遍历的remove是代参数的remove方法,会导致ModCount++，但expectedModCount不会改变，next会检查两值是否相等，因此会抛异常。从代码上也可以读出作者的想法，就是通过此种方式来禁止遍历时直接remove。<br><br>迭代器删除是用的无参数remove，删除后会执行expectedModCount = modCount，将两值置为相等。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":505323,"discussion_content":"是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599654274,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247133,"user_name":"jacy","can_delete":false,"product_type":"c1","uid":1103456,"ip_address":"","ucode":"0022A8759DDCE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/60/f21b2164.jpg","comment_is_top":false,"comment_ctime":1599615952,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5894583248","product_id":100047701,"comment_content":"问题一传int是直接删除数组对应下标的元素，返回被删除的元素，传Object时需要遍历查询与Object equal的元素，再进行删除，返回true or false。<br>问题二不知道原因，可以用迭代器进行删除。<br><br>整理：<br>1、ArrayLists.asList无法将基础类型的数组打散重组，即参入基础类型数组时，会被构建成二维数组（仅一个元素，元素为输入数组）结构，而不是一维数组结构。<br>2、ArrayLists.asList 或subList实则是对原数据的强引用，会导致原数据无法回收，修改结果也会应用到原数组。可以用截取结果构建新的List，防止出现修改异常。<br>3、考虑时间与空间的关系，选择合理的数据结构。<br>4、算法大O时间只是理论上的时间，真实场景下可能还需要做额外的操作才能达到算法的启动条件，比如链表的理论插入时间为O(1)，但查找到前向节点还需要花费O(n)的时间。","like_count":1},{"had_liked":false,"id":227710,"user_name":"Avalon","can_delete":false,"product_type":"c1","uid":1664805,"ip_address":"","ucode":"8FB5370C1FBB68","user_header":"https://static001.geekbang.org/account/avatar/00/19/67/25/d413adc8.jpg","comment_is_top":false,"comment_ctime":1592461427,"is_pvip":false,"replies":[{"id":"84090","content":"LinkedList的addFirst性能肯定优于ArrayList的add(0,x)","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1592550849,"ip_address":"","comment_id":227710,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5887428723","product_id":100047701,"comment_content":"我有一个疑问，在LinkedList中addFirst方法调用的私有方法linkFirst方法如下：<br>```<br>    private void linkFirst(E e) {<br>        LinkedList.Node&lt;E&gt; f = this.first;<br>        LinkedList.Node&lt;E&gt; newNode = new LinkedList.Node((LinkedList.Node)null, e, f);<br>        this.first = newNode;<br>        if (f == null) {<br>            this.last = newNode;<br>        } else {<br>            f.prev = newNode;<br>        }<br><br>        ++this.size;<br>        ++this.modCount;<br>    }<br>```<br>这段代码里面仅针对一个位置进行了增加节点的操作，为什么addFirst的性能还是不及ArrayList的add方法呢？<br>","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498757,"discussion_content":"LinkedList的addFirst性能肯定优于ArrayList的add(0,x)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592550849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218840,"user_name":"LovePeace","can_delete":false,"product_type":"c1","uid":1010319,"ip_address":"","ucode":"5BA5B11FAF953E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/8f/5b224f54.jpg","comment_is_top":false,"comment_ctime":1589885009,"is_pvip":false,"replies":[{"id":"80874","content":"可以用JMH再试试，毕竟时间太短了，这样看不一定准确","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1589889654,"ip_address":"","comment_id":218840,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5884852305","product_id":100047701,"comment_content":"大量的业务开发其实没那么大的数据,linkendList在插入小量数据的时候还是比arraylist有优势的<br>        int loopCount = 100;<br>        StopWatch stopWatch = new StopWatch();<br>        stopWatch.start(&quot;linkedListadd&quot;);<br>        linkedListadd(loopCount);<br>        stopWatch.stop();<br>        stopWatch.start(&quot;arrayListadd&quot;);<br>        arrayListadd(loopCount);<br>        stopWatch.stop();<br>        System.out.println(stopWatch.prettyPrint());<br>    }<br><br>    private static void linkedListadd(int loopCount) {<br>        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();<br>        for (int i = 0; i &lt; loopCount; i++) {<br>            list.add(i);<br>        }<br>    }<br><br>    private static void arrayListadd(int loopCount) {<br>        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();<br>        for (int i = 0; i &lt; loopCount; i++) {<br>            list.add(i);<br>        }<br>    }<br>######################################<br>StopWatch &#39;&#39;: running time = 93300 ns<br>---------------------------------------------<br>ns         %     Task name<br>---------------------------------------------<br>000025500  027%  linkedListadd<br>000067800  073%  arrayListadd","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495595,"discussion_content":"可以用JMH再试试，毕竟时间太短了，这样看不一定准确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589889654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215511,"user_name":"苏暮沉觞","can_delete":false,"product_type":"c1","uid":1577580,"ip_address":"","ucode":"532B816D4EF47B","user_header":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","comment_is_top":false,"comment_ctime":1589006398,"is_pvip":false,"replies":[{"id":"79793","content":"你可以自己做一下实验","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1589016811,"ip_address":"","comment_id":215511,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5883973694","product_id":100047701,"comment_content":"老师，对于ArrayList和LinkedList插入性能测试有点疑问：我们这是测量10W的数据量下的结果，如果数据量达到100W，推论还是成立吗？（想测试100W数据量，但是数据量逐步提高到30W以后，程序就运行很久很久）。判断两种数据类型的速度，能不能简单归纳为判断LinkedList查找下一个节点的时间和（ArrayList数组后移一个数据时间+扩容平均时间）哪个比较短？","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494462,"discussion_content":"你可以自己做一下实验","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589016811,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202343,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1585971843,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880939139","product_id":100047701,"comment_content":"第一个问题，remove int是删除下标元素，删除Integer是删除某个元素<br>第二个问题，因为迭代器为了防止在遍历时删除插入的操作导致漏遍历到某个元素，所以禁止在遍历时插入和删除元素，解决方法想到的是copy on write。","like_count":1},{"had_liked":false,"id":201015,"user_name":"终结者999号","can_delete":false,"product_type":"c1","uid":1055854,"ip_address":"","ucode":"33ADE61580B6DD","user_header":"https://static001.geekbang.org/account/avatar/00/10/1c/6e/6c5f5734.jpg","comment_is_top":false,"comment_ctime":1585705679,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5880672975","product_id":100047701,"comment_content":"在转成stream的时候，linkedlist是不是要好于ArrayList呢？","like_count":1},{"had_liked":false,"id":200753,"user_name":"csyangchsh","can_delete":false,"product_type":"c1","uid":1002939,"ip_address":"","ucode":"8604F5C839710B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/bb/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1585646397,"is_pvip":false,"replies":[{"id":"75101","content":"是的，JMH做微基准测试更严谨一些","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585648849,"ip_address":"","comment_id":200753,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880613693","product_id":100047701,"comment_content":"ArrayList分配的内存空间是连续的，对会CPU Cache很友好。LinkedList还要包装成Node，又增加了开销。这个测试使用JMH，根据CPU Cache大小，定义不同的元素个数，可能更严谨一点。","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490125,"discussion_content":"是的，JMH做微基准测试更严谨一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585648849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200631,"user_name":"mgs2002","can_delete":false,"product_type":"c1","uid":1812970,"ip_address":"","ucode":"F5931108BD509B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/a9/ea/5bfce6c5.jpg","comment_is_top":false,"comment_ctime":1585626527,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880593823","product_id":100047701,"comment_content":"第二题可以使用并发容器CopyOnWriteArrayList解决，删除和添加都是在快照上面的，不会影响原有的List","like_count":1},{"had_liked":false,"id":200590,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":false,"comment_ctime":1585621666,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5880588962","product_id":100047701,"comment_content":"这么看来 LinkedList 没有什么优势，随机插入败了，随机删除也差不多，只剩尾插了。尾插其实也没有多少优势，最多就是arrayList底层满了以后需要扩容，linkedList 不需要。估算下来，大概只有在插入只是海量尾插、查询只是遍历的情况下才有点优势","like_count":1},{"had_liked":false,"id":200497,"user_name":"梦倚栏杆","can_delete":false,"product_type":"c1","uid":1095857,"ip_address":"","ucode":"BDEB97F2822445","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/bvj76PmeUvW8kokyu91IZWuRATKmabibDWbzAj2TajeEic7WvKCJOLaOh6jibEmdQ36EO3sBUZ0HibAiapsrZo64U8w/132","comment_is_top":false,"comment_ctime":1585613295,"is_pvip":false,"replies":[{"id":"75007","content":"java 1.2的时候List接口已经是这样了，泛型后面出来的","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1585619538,"ip_address":"","comment_id":200497,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5880580591","product_id":100047701,"comment_content":"1. 刚好是看到案例时我想问的问题，答案知道，但是为什么呢？是规定为了区分？那为什么创建数组时可以自动装箱呢？<br>2.用迭代器可以，但是为什么其实也不能说出个所以然<br><br><br>我没想到的是linklist的性能问题，sublist也没想到，是不是这种很多返回的都是视图呀","like_count":1,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490047,"discussion_content":"java 1.2的时候List接口已经是这样了，泛型后面出来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585619538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351570,"user_name":"| ~浑蛋~","can_delete":false,"product_type":"c1","uid":3024820,"ip_address":"","ucode":"B6904B44DFA805","user_header":"https://static001.geekbang.org/account/avatar/00/2e/27/b4/df65c0f7.jpg","comment_is_top":false,"comment_ctime":1657940210,"is_pvip":true,"discussion_count":0,"race_medal":4,"score":"1657940210","product_id":100047701,"comment_content":"ArrayList和linkedlist的性能差异跟计算机内存访问的局部性原理有关","like_count":0},{"had_liked":false,"id":346051,"user_name":"Geek_7cf7af","can_delete":false,"product_type":"c1","uid":2685579,"ip_address":"","ucode":"A8611750FDE7E0","user_header":"","comment_is_top":false,"comment_ctime":1652790859,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652790859","product_id":100047701,"comment_content":"最后一个插入数据数组比链表快，是不是还可以从cpu的cache缓存来考虑，数组是连续存储的，所以在读取数据进入cpu的时候，会把一批数据都读入，提高了cache的命中率","like_count":0},{"had_liked":false,"id":340132,"user_name":"文涛","can_delete":false,"product_type":"c1","uid":2005349,"ip_address":"","ucode":"1265BA251859E4","user_header":"https://static001.geekbang.org/account/avatar/00/1e/99/65/f1f1643a.jpg","comment_is_top":false,"comment_ctime":1648619414,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648619414","product_id":100047701,"comment_content":"Integer[] arr1 = {1, 2, 3};<br>List&lt;Integer&gt; collect = Arrays.stream(arr1).collect(Collectors.toList());<br> collect.add(4);<br> System.out.println(collect);<br>这种转换的是可以对得到的集合进行操作的","like_count":0},{"had_liked":false,"id":340131,"user_name":"文涛","can_delete":false,"product_type":"c1","uid":2005349,"ip_address":"","ucode":"1265BA251859E4","user_header":"https://static001.geekbang.org/account/avatar/00/1e/99/65/f1f1643a.jpg","comment_is_top":false,"comment_ctime":1648619365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648619365","product_id":100047701,"comment_content":"Integer[] arr1 = {1, 2, 3};","like_count":0},{"had_liked":false,"id":339477,"user_name":"到道可道","can_delete":false,"product_type":"c1","uid":1031181,"ip_address":"","ucode":"12B94B6C26BE0D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bc/0d/00424e81.jpg","comment_is_top":false,"comment_ctime":1648121689,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1648121689","product_id":100047701,"comment_content":"1.调用类型是 Integer 的 ArrayList 的 remove 方法删除元素，传入一个 Integer 包装类的数字和传入一个 int 基本类型的数字，结果一样吗？<br>答：结果不一样，传入的是int基本类型，即删除的是索引，执行的方法是remove(int)，直接按照索引位置来删除元素，如果不是最后一个，则还需要System.arraycopy来数组拷贝；如果传入的是Integer，执行的方法是remove(Object)，需要遍历数组，找到指定元素再删除，如果不是最后一个，则还需要System.arraycopy来数组拷贝。<br><br>2.循环遍历 List，调用 remove 方法删除元素，往往会遇到 ConcurrentModificationException 异常，原因是什么，修复方式又是什么呢？<br>答：以foreach为例说，遍历删除实质是变化为迭代器实现，不管是迭代器里面的remove()还是next()方法,都会checkForComodification();而这个方法是判断modCount和expectedModCount是否相等，这个modCount是这个list集合修改的次数，每一次add或者remove都会增加这个变量，然后迭代器每次去next或者去remove的时候检查checkForComodification();发现expectedModCount(这个迭代器修改的次数)和modCount(这个集合实际修改的次数)不相等，就会抛出ConcurrentModificationException，迭代器里面没有add方法，用迭代器时，可以删除原来集合的元素，但是！一定要用迭代器的remove方法而不是集合自身的remove方法，否则抛异常。","like_count":0},{"had_liked":false,"id":309138,"user_name":"SharpBB","can_delete":false,"product_type":"c1","uid":2014573,"ip_address":"","ucode":"D30C5B798B8E8C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","comment_is_top":false,"comment_ctime":1629959187,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629959187","product_id":100047701,"comment_content":"太赞了 我之前就测试过链表与动态数组  发现怎么和我学的不一样呢。。。","like_count":0},{"had_liked":false,"id":275980,"user_name":"nanamin","can_delete":false,"product_type":"c1","uid":2403829,"ip_address":"","ucode":"9C794FD4EEA167","user_header":"https://static001.geekbang.org/account/avatar/00/24/ad/f5/68a2b581.jpg","comment_is_top":false,"comment_ctime":1611736037,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611736037","product_id":100047701,"comment_content":"LinkedList这个还是第一次知道","like_count":0},{"had_liked":false,"id":271946,"user_name":"Geek_f87599","can_delete":false,"product_type":"c1","uid":2206025,"ip_address":"","ucode":"E5EDD1B1D8EBE8","user_header":"","comment_is_top":false,"comment_ctime":1609892605,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609892605","product_id":100047701,"comment_content":"测试性能不应该使用基准测试吗？使用这种方式会有很大的干扰吧","like_count":0},{"had_liked":false,"id":262007,"user_name":"wenpin","can_delete":false,"product_type":"c1","uid":1134027,"ip_address":"","ucode":"A66E3A4A59093A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WSClHmjiaTh5D3lKAia9CBiaUqFf46ZludOVk9S5GnElUSDsH9ZzBtVktF5xEEQq4VCFXM0lgKdbzFTHateKylmibw/132","comment_is_top":false,"comment_ctime":1605604373,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605604373","product_id":100047701,"comment_content":"觉得 LinkedList 这里并不是说迷信教科书的原因，反而是没理解教科书的原因吧，链表本来随机插入的性能就很低下，它的适用场景是作为栈或者队列一类的只需要作头尾操作的底层数据结构。","like_count":0},{"had_liked":false,"id":260830,"user_name":"Geek_c5c988","can_delete":false,"product_type":"c1","uid":2284289,"ip_address":"","ucode":"353DCC036E2918","user_header":"","comment_is_top":false,"comment_ctime":1605140682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605140682","product_id":100047701,"comment_content":"害，Java新人一枚，老师写的这些都是之前踩过的坑，今天总算是明白了","like_count":0},{"had_liked":false,"id":254162,"user_name":"向幸福出发","can_delete":false,"product_type":"c1","uid":1471769,"ip_address":"","ucode":"EC08B7FB081674","user_header":"https://static001.geekbang.org/account/avatar/00/16/75/19/9b6e00f2.jpg","comment_is_top":false,"comment_ctime":1603073655,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603073655","product_id":100047701,"comment_content":"老师讲的很到位","like_count":0},{"had_liked":false,"id":242517,"user_name":"逆光","can_delete":false,"product_type":"c1","uid":1008873,"ip_address":"","ucode":"474C1CFF5EC70C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/64/e9/dbb30482.jpg","comment_is_top":false,"comment_ctime":1597746913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597746913","product_id":100047701,"comment_content":"List.subList 得到的 List不可序列化","like_count":0},{"had_liked":false,"id":240367,"user_name":"cky.宇","can_delete":false,"product_type":"c1","uid":1369447,"ip_address":"","ucode":"93A3EAD9D50A5F","user_header":"https://static001.geekbang.org/account/avatar/00/14/e5/67/16322a5d.jpg","comment_is_top":false,"comment_ctime":1596877975,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596877975","product_id":100047701,"comment_content":"总结一下：当要一个List是做为“数组”用时（涉及随机读写）使用ArrayList更好。当List是用来做为Queue（队列）或者Stack（栈）来用时，使用LinkedList更优，因为这种数据结构都是对表头或表尾读写，大数据量时性能会比ArrayList更好。","like_count":0},{"had_liked":false,"id":239716,"user_name":"学习使人快乐","can_delete":false,"product_type":"c1","uid":1478759,"ip_address":"","ucode":"1EC27CE663EE65","user_header":"https://static001.geekbang.org/account/avatar/00/16/90/67/106306e7.jpg","comment_is_top":false,"comment_ctime":1596622400,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596622400","product_id":100047701,"comment_content":"老师的课程很结合实际的场景，另外评论区也是精华","like_count":0},{"had_liked":false,"id":235637,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1595132770,"is_pvip":false,"replies":[{"id":"87084","content":"1、泛型不支持基本类型<br>2、自动装箱只针对单个元素，无法给基本类型数组做自动装箱","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1595214633,"ip_address":"","comment_id":235637,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1595132770","product_id":100047701,"comment_content":"源码中的注释<br>@param &lt;T&gt; the class of the objects in the array<br>List&lt;T&gt; asList(T... a)<br>是不是因为基本类型是不能作为对象的,所以程序只能将int[]数组类型可以作为对象","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501794,"discussion_content":"1、泛型不支持基本类型\n2、自动装箱只针对单个元素，无法给基本类型数组做自动装箱","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595214633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235635,"user_name":"James","can_delete":false,"product_type":"c1","uid":1134861,"ip_address":"","ucode":"48B0F2A334D1C1","user_header":"https://static001.geekbang.org/account/avatar/00/11/51/0d/fc1652fe.jpg","comment_is_top":false,"comment_ctime":1595132590,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595132590","product_id":100047701,"comment_content":"还是不知道为啥<br>int[] arr = {1, 2, 3};List list = Arrays.asList(arr);<br>把数组类型变为包装类就是正常的.<br>是因为包装类会遍历出来,而基本类型就只会当作一个整体吗.<br><br>看源码没看到在哪里转换的,请问老师,","like_count":0},{"had_liked":false,"id":233106,"user_name":"夜涛","can_delete":false,"product_type":"c1","uid":1507783,"ip_address":"","ucode":"672CC53663710B","user_header":"https://static001.geekbang.org/account/avatar/00/17/01/c7/549b5616.jpg","comment_is_top":false,"comment_ctime":1594218297,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1594218297","product_id":100047701,"comment_content":"第一题，传入integer是删除元素，通过对象比较equals方法实现删除元素搜索，删除；传入int，是传入索引，删除list第n个元素，结果是不一样的；特殊情况：list.get（n）.equals（Integer.valueOf(n)）为true，那么结果是相同的。","like_count":0},{"had_liked":false,"id":232041,"user_name":"pepsi","can_delete":false,"product_type":"c1","uid":1940540,"ip_address":"","ucode":"D588411A200C76","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9c/3c/0583e01e.jpg","comment_is_top":false,"comment_ctime":1593840486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593840486","product_id":100047701,"comment_content":"LinkedList 长知识了o(￣▽￣)ｄ","like_count":0},{"had_liked":false,"id":223034,"user_name":"学要有所用","can_delete":false,"product_type":"c1","uid":1446644,"ip_address":"","ucode":"7CB34E7DE21558","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/f4/1bf8568e.jpg","comment_is_top":false,"comment_ctime":1590984646,"is_pvip":false,"replies":[{"id":"82210","content":"不太对，如果反过来还稍微有点说得过去","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1590993772,"ip_address":"","comment_id":223034,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590984646","product_id":100047701,"comment_content":"通常看到技术文章里会提到链表查找容易，增删困难，这是否不正确？","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496993,"discussion_content":"不太对，如果反过来还稍微有点说得过去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590993772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1664805,"avatar":"https://static001.geekbang.org/account/avatar/00/19/67/25/d413adc8.jpg","nickname":"Avalon","note":"","ucode":"8FB5370C1FBB68","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284844,"discussion_content":"理论上，单链表的话，查找的时候需要从头开始扫描整个链表（一个一个找），这种效率应该是不及顺序数组的，而链表增删的话，除非是需要先进行查找再进行删除的情况，链表的删除、增加的基本操作时间复杂度都是O(1)的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592659506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":210256,"user_name":"自暴自弃","can_delete":false,"product_type":"c1","uid":1301921,"ip_address":"","ucode":"F9DEA202A695D4","user_header":"https://static001.geekbang.org/account/avatar/00/13/dd/a1/222b0e4e.jpg","comment_is_top":false,"comment_ctime":1587707681,"is_pvip":false,"replies":[{"id":"78374","content":"：）","user_name":"作者回复","user_name_real":"朱晔","uid":"1001470","ctime":1587714673,"ip_address":"","comment_id":210256,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587707681","product_id":100047701,"comment_content":"java很多人用了这么久的List都用错了！看完这篇文章小伙惊呼这么多年白学了！","like_count":0,"discussions":[{"author":{"id":1001470,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/fe/d0e25d57.jpg","nickname":"朱晔","note":"","ucode":"0B7F0BADE6AAB8","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492983,"discussion_content":"：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587714673,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205743,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1586731712,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586731712","product_id":100047701,"comment_content":"之前一直以为Arrays.asList返回的是java.util.ArrayList","like_count":0}]}