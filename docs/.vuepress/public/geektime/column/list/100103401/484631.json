{"id":484631,"title":"加餐三 | 什么是“不变性思维”？","content":"<p>你好，我是朱涛。</p><p>在<a href=\"https://time.geekbang.org/column/article/472129\">开篇词</a>里，我提到过学习Kotlin的五种思维转变，包括前面加餐中讲过的函数思维、表达式思维，以及接下来要给你介绍的不变性思维、空安全思维以及协程思维。所以今天，我们就一起来聊聊Kotlin的不变性思维。</p><p>Kotlin将不变性的思想发挥到了极致，并将其融入到了语法当中。当开发者想要定义一个变量的时候，必须明确规定这个变量是<strong>可变的</strong>（var），还是<strong>不可变的</strong>（val）。在定义集合变量的时候，也同样需要明确规定这个集合是可变的（比如MutableList），还是不可变的（比如List）。</p><p>不过，不变性其实会被很多Kotlin初学者所忽略。尤其是有Java、C经验的开发者，很容易将老一套思想照搬到Kotlin当中来，为了方便，写出来的变量全部都是var的，写出来的集合都是MutableXXX。</p><p>事实上，不变性思维，对我们写出优雅且稳定的Kotlin代码很关键。要知道，我们代码中很多的Bug都是因为某个变量被多个调用方改来改去，最后导致状态错误才出问题的。毕竟，变动越多，就越容易出错！</p><p><strong>那么，既然可变性这么“可恶”，我们为何不干脆直接在语法层面消灭var、MutableXXX这样的概念呢</strong>？</p><!-- [[[read_end]]] --><p>这当然是不行的，因为我们的程序本身就是“为了产生变化而生的”。你想想，如果你的程序在运行过程中不会改变任何数据，那程序运行还有什么意义呢？而且你可以再想象一下，如果没有可变性，你打游戏的时候，画面根本就不会动啊！游戏数据不变，画面自然也不会动了。</p><p>所以说，<strong>所谓不变性思维，是一种反直觉的思路</strong>。这也是Kotlin从函数式编程领域借鉴过来的思想。在Kotlin当中，所谓的不变性思维，其实就是在满足程序功能可变性需求的同时，尽可能地消灭可变性。</p><p>这颇有一种“戴着镣铐跳舞”的意味。其实换句话理解一下，就是说我们应该：尽可能消灭那些<strong>非必要</strong>可变性。</p><p>下面，我们就一起来看几个代码案例吧，在解读案例的过程中，我们来具体理解下究竟什么是不变性思维。</p><h2>表达式思维消灭var</h2><p>那么现在，我们的目标就变成了<strong>尽可能消灭那些非必要可变性</strong>。沿着这个思路，我们很容易就可以想到一个方向：尽可能将var变成val。就比如下面这段代码：</p><pre><code class=\"language-plain\">fun testExp(data: Any) {\n    var i = 0\n\n    if (data is Number) {\n        i = data.toInt()\n    } else if (data is String) {\n        i = data.length\n    } else {\n        i = 0\n    }\n}\n</code></pre><p>在这段代码中，我们定义了一个可变的变量i，它的初始值是0，如果data是数字类型，我们就将其转换成整型，赋值给i；如果data是String类型，我们就将字符串的长度赋值给i，否则就用0赋值。</p><p>这段代码虽然没什么实际用途，但它代表了Java、C当中普遍存在的代码模式。这里的i，就是我们需要消灭的<strong>非必要</strong>可变性。其实，在学了上节课“表达式思维”以后，这个问题我们不费吹灰之力就可以解决了，也就是把整体的赋值逻辑变成一个表达式，代码示例如下所示：</p><pre><code class=\"language-plain\">fun testExp(data: Any) {\n    val i = when (data) {\n        is Number -&gt; {\n            data.toInt()\n        }\n        is String -&gt; {\n            data.length\n        }\n        else -&gt; {\n            0\n        }\n    }\n}\n</code></pre><p>在这里你要注意，如果你把这个当做一道题目来做的话，它无疑是很容易的。但我想强调的是：在写Kotlin代码的时候，需要<strong>一步到位</strong>直接写出上面这样的代码。而想要做到这一点，你就一定要将不变性的思维铭记在心。因为要做到这一点其实不太容易，尤其是对Java、C开发者而言。</p><p>另外，如果你足够细心的话，相信你也发现了：我们上节课刚学的“表达式的思维”，对于我们的不变性思维，也是很有用的。</p><p>好，至此，我们就可以总结出不变性思维的第一条准则：<strong>尽可能使用条件表达式消灭var。</strong></p><h2>消灭数据类当中的可变性</h2><p>在<a href=\"https://time.geekbang.org/column/article/473349\">第2讲</a>里，我们曾经简单学习过数据类，它是专门用来存放数据的类。它与Java当中的“Java Bean”是类似的，它的优势在于简洁。</p><p>不过，我仍然见过有人在Kotlin当中写出类似这样的代码：</p><pre><code class=\"language-plain\">class Person {\n    private var name: String? = null\n    private var age: Int? = 0\n\n    fun getName(): String? {\n        return name\n    }\n\n    fun setName(n: String?) {\n        name = n\n    }\n\n    fun getAge(): Int? {\n        return age\n    }\n\n    fun setAge(a: Int?) {\n        age = a\n    }\n}\n</code></pre><p>上面的代码就是明显在用Java思维写Kotlin代码，有时候，我还能看到这样的代码：</p><pre><code class=\"language-plain\">class Person {\n    var name: String? = null\n    var age: Int? = 0\n}\n</code></pre><p>这样的代码呢，看起来问题要小一些，但实际上呢，开发者脑子里想的可能是类似Java这样的代码模式：</p><pre><code class=\"language-java\">public class Person {\n    public String name = null;\n    public int age = 0;\n}\n</code></pre><p>不过，总的来说，大部分Kotlin开发者都能写出类似这样的代码：</p><pre><code class=\"language-plain\">data class Person(\n    var name: String?,\n    var age: Int?\n)\n</code></pre><p>但这段代码其实还可以继续优化。我们可以将var都改为val，就像下面这样：</p><pre><code class=\"language-plain\">// var -&gt; val\ndata class Person(\n    val name: String?, \n    val age: Int?\n)\n</code></pre><p>而到这里，你可能就会产生一个疑问：<strong>Person的所有属性都改为val以后，万一想要修改它的值该怎么办呢？</strong></p><p>比如说，直接修改它的值的话，这段代码就会报错：</p><pre><code class=\"language-plain\">class ImmutableExample {\n    // 修改Person的name，然后返回Person对象\n    fun changeUserName(person: Person, newName: String): Person {\n        person.name = newName // 报错，val无法修改\n        return person\n    }\n}\n</code></pre><p>这一点也是我们要尤为注意的：我们从Java、C那边带来的习惯，会促使我们第一时间想到上面这样的解决方案。但实际上，Kotlin更加推崇我们用下面的方式来解决：</p><pre><code class=\"language-plain\">class ImmutableExample {\n    fun changeUserName(person: Person, newName: String): Person =\n        person.copy(name = newName)\n}\n</code></pre><p>在这段代码中，我们并没有直接修改参数person的值，而是返回了一个新的person对象。我们借助数据类的copy方法，快速创建了一份拷贝的同时，还完成了对name属性的修改。类似这样的代码模式，就可以极大地减少程序出Bug的可能。</p><p>那么到这里，我们也就能总结出Kotlin不变性思维的第二条准则了：<strong>使用数据类来存储数据，消灭数据类的可变性</strong>。</p><h2>集合的不变性</h2><p>在Kotlin当中，提到不变性，我们就不得不谈它的<strong>集合库</strong>。我们在学习数据结构的时候，都会学到：数组、列表、HashMap、HashSet、栈、队列。这些概念在大部分的编程语言里都会存在，不过Kotlin在这方面的设计，却与Java之类的语言不太一样。</p><p>以最常见的列表（List）为例：</p><ul>\n<li>在Java当中，List是一个接口，它代表了一个可变的列表，会包含add()、remove()方法；</li>\n<li>在Kotlin当中，List也是一个接口，但是它代表了一个不可变的列表，或者说是“只读的列表”。在它的接口当中，是没有add()、remove()方法的，当我们想要使用可变列表的时候，必须使用MutableList。</li>\n</ul><p>关于集合的不变性，我们其实在第9讲<a href=\"https://time.geekbang.org/column/article/479112\">委托</a>当中就提到了：</p><pre><code class=\"language-plain\">class Model {\n    val data: MutableList&lt;String&gt; = mutableListOf()\n\n    private fun load() {\n        // 网络请求\n        data.add(\"Hello\")\n    }\n}\n\nfun main() {\n    val model = Model()\n    // 类的外部仍然可以修改data\n    model.data.add(\"World\")\n}\n</code></pre><p>当我们将类内部的集合对象暴露给外部以后，我们其实没办法阻止外部对集合的修改。在第9讲当中，我们是通过<strong>属性之间的直接委托</strong>来解决这个问题的：</p><pre><code class=\"language-plain\">class Model {\n    val data: List&lt;String&gt; by ::_data\n    private val _data: MutableList&lt;String&gt; = mutableListOf()\n\n    fun load() {\n        _data.add(\"Hello\")\n    }\n}\n</code></pre><p>但其实，要解决这个问题，我们也可以借助其他的方法，比如像下面这样：</p><pre><code class=\"language-plain\">class Model {\n    val data: List&lt;String&gt;\n        get() = _data // 自定义get\n    private val _data: MutableList&lt;String&gt; = mutableListOf()\n\n    fun load() {\n        _data.add(\"Hello\")\n    }\n}\n</code></pre><p>在这段代码中，我们为data属性自定义了get()方法，然后返回了_data这个集合的值。这种方式也可以实现目的。</p><p>另外，我们其实还有其他的办法：</p><pre><code class=\"language-plain\">class Model {\n    private val data: MutableList&lt;String&gt; = mutableListOf()\n\n    fun load() {\n        data.add(\"Hello\")\n    }\n\n    // 变化在这里\n    fun getData(): List&lt;String&gt; = data\n}\n</code></pre><p>上面这种解决方案也很简单，我们直接对外暴露了一个方法，把这个方法的返回值类型改成了List类型，这样一来，外部访问这个集合以后就无法直接修改了。</p><p>以上这三种方式，本质上都是对外暴露了一个“不可变的集合”，完成了可变性的封装，它们基本上可以满足大部分的使用需求。不过啊，这三种方式其实还是会<strong>存在一定的风险</strong>，那就是外部可以进行类型转换，就像下面这样：</p><pre><code class=\"language-plain\">fun main() {\n    val model = Model()\n    println(\"Before:${model.getData()}\")\n    val data = model.getData()\n    (data as? MutableList)?.add(\"Some data\")\n    println(\"After:${model.getData()}\")\n}\n\n结果：\nBefore:[]\nAfter:[Some data]\n</code></pre><p>针对这种特殊情况，我们可以根据实际情况来决定是否要规避这个问题。其实要解决这个问题的话也很容易，我们只需要借助Kotlin提供的toList函数，让data变成真正的List类型即可。</p><p>比如像下面这样：</p><pre><code class=\"language-plain\">class Model {\n    private val data: MutableList&lt;String&gt; = mutableListOf()\n\n    fun load() {\n        data.add(\"Hello\")\n    }\n\n    //                                 变化在这里\n    //                                    ↓\n    fun getData(): List&lt;String&gt; = data.toList()\n}\n\n// 改完以后的输出结果\nBefore:[]\nAfter:[]\n</code></pre><p>这段代码基本上可以帮助我们完成集合可变性的封装，不过在这里，有一点我们需要格外<strong>注意</strong>：当data集合数据量很大的时候，toList()操作可能会比较耗时。</p><p>好了，至此，相信你很快就能总结出第三条准则了：<strong>尽可能对外暴露只读集合</strong>。</p><h2>只读集合与Java</h2><p>另外，还有一点需要注意，当只读集合在Java代码中被访问的时候，它的不变性将会被破坏，因为Java当中不存在“不可变的集合”的概念。比如说，你在Java当中，仍然可以调用这个集合的set()方法。</p><pre><code class=\"language-plain\">public List&lt;String&gt; test() {\n    Model model = new Model();\n    List&lt;String&gt; data = model.getData();\n    data.set(0， \"Some Data\"); // 抛出异常 UnsupportedOperationException\n    return data;\n}\n</code></pre><p>因此，当我们在与Java混合编程的时候，Java里使用Kotlin集合的时候一定要足够小心，最好要有详细的文档。就比如说在上面的例子当中，虽然我们可以在Java当中调用set()方法，但是这行代码最终会抛出异常，引起崩溃。而引起崩溃的原因，是Kotlin的List最终会变成Java当中的“<strong>SingletonList</strong>”，它是Java当中的不可变List，在它的add()、remove()方法被调用的时候，会抛出一个异常。</p><p>不得不说，Java这样的实现方式真的很丑陋。我相信，可能很多Java开发者甚至都不知道Java居然还有SingletonList这个私有的类。</p><p>并且，只读集合在和Java混编的时候，不仅仅只有这一个问题。毕竟，当我们尝试修改只读集合的值的时候，Java可以抛出一个异常的话，那也算是一个可以勉强接受的结局了。</p><p>但实际的情况还会更差，如果我们将代码改成这样：</p><pre><code class=\"language-plain\">class Model1 {\n    val list: List&lt;String&gt; = listOf(\"hello\", \"world\")\n}\n\npublic class ImmutableJava {\n    public List&lt;String&gt; test1() {\n        Model1 model = new Model1();\n        List&lt;String&gt; data = model.getList();\n        System.out.println(data.get(0));\n        data.set(0, \"some data\"); // 注意这里\n        System.out.println(data.get(0));\n        return data;\n    }\n}\n\n// 结果\nhello\nsome data\n</code></pre><p>我们在Java代码当中调用data.set()方法，并没有引起异常，程序也正常执行完毕，并且结果也符合预期。在这种情况下，Kotlin的List被编译器转换成了 <code>java.util.Arrays$ArrayList</code> 类型。因此，我们Kotlin当中的只读集合，在Java当中就变成了一个普通的可变集合了。</p><p>事实上，对于Kotlin的List类型来说，在它转换成Java字节码以后，可能会变成多种类型，比如前面我们看到的SingletonList、<code>java.util.Arrays$ArrayList</code>，甚至还可能会变成java.util.ArrayList。在这里，我们完全不必去深究编译器背后的翻译规则，我们只需要时刻记住，Kotlin当中的只读集合，在Java看来和普通的可变集合是一样的。</p><p>至此，我们就能总结出第四条准则了：<strong>只读集合底层不一定是不可变的，要警惕Java代码中的只读集合访问行为</strong>。</p><h2>反思：val 一定不可变吗？</h2><p>最后，我们再来反思一下Kotlin的不变性。通常来说，我们用val定义的临时变量，都会将其看做是不可变的，也就是只读变量。但是别忘了，<strong>val还可以定义成员属性</strong>。而在这种情况下，它意味着：属性+ get方法。而且，我们还可以自定义get()方法。</p><p>所以这时候，我们就要睁大眼睛看清楚它的本质了。比如我们可以来看看下面这段代码：</p><pre><code class=\"language-plain\">object TestVal {\n    val a: Double\n        get() = Random.nextDouble()\n\n    fun testVal() {\n        println(a)\n        println(a)\n    }\n}\n\n// 结果\n0.0071073054825220305\n0.6478886064282862\n</code></pre><p>很明显，在上面的代码中，我们通过自定义get()方法，打破了val的不变性。我们两次访问属性a所得到的值都不一样。对于val定义的成员属性，我们得到这样的结果并不会觉得奇怪，上面代码的运行结果也十分符合直觉。</p><p>那么你也许会这样想：我们用val定义的<strong>局部变量</strong>，那就一定是不可变的了吧？</p><p>答案仍然是<strong>否定</strong>的！</p><p>我们可以看看下面这个例子，这里我们同样是借助了委托相关的知识点：</p><pre><code class=\"language-plain\">class RandomDelegate() : ReadOnlyProperty&lt;Any?, Double&gt; {\n    override operator fun getValue(thisRef: Any?, property: KProperty&lt;*&gt;): Double {\n        return Random.nextDouble()\n    }\n}\n\nfun testLocalVal() {\n    val i: Double by RandomDelegate()\n\n    println(i)\n    println(i)\n}\n\n// 输出结果\n0.1959507495773669\n0.5166803777645403\n</code></pre><p>在这段代码中，我们定义了一个委托RandomDelegate，然后把局部变量委托给了这个RandomDelegate，之后每次访问i这个变量，它的值都是不一样的。</p><p>那么，到这里，相信你马上就可以总结出第五条准则了：<strong>val并不意味着绝对的不可变</strong>。</p><h2>小结</h2><p>好了，我们来做一个简单的总结吧。所谓Kotlin的不变性思维，就是尽可能消灭代码中<strong>非必要</strong>的可变性。具体来说，一共有5大准则。</p><ul>\n<li>第一，<strong>尽可能使用条件表达式消灭var</strong>。由于Kotlin当中大部分语句都是表达式，我们可以借助这种思路减少var变量的定义。</li>\n<li>第二，<strong>使用数据类来存储数据，消灭数据类的可变性</strong>。我们应该充分发挥Kotlin数据类的优势，借助它提供的copy方法，我们可以轻松实现不变性。</li>\n<li>第三，<strong>尽可能对外暴露只读集合</strong>。根据<a href=\"https://en.wikipedia.org/wiki/Open%25E2%2580%2593closed_principle\">开放封闭原则</a>，我们的程序应该尽量对修改封闭。借助Kotlin的只读集合，我们在这方面可以做得比Java更好。</li>\n<li>第四，<strong>只读集合底层不一定是不可变的，要警惕Java代码中的只读集合访问行为</strong>。Kotlin为了兼容Java，它的集合类型必须要与Java兼容，因此它不能创造出Java以外的集合类型，这也就决定了它只能是语法层面的不可变性。Kotlin官方也在考虑进一步的优化，期待后续的版本能有更加优雅的处理方式。</li>\n<li>第五，<strong>val并不意味着绝对的不可变</strong>。在Kotlin当中定义的val变量与属性，它们并非绝对不可变的。由于Kotlin的语法十分灵活，我们完全可以用val写出可变的局部变量和成员属性。这一点，我们一定要小心。</li>\n</ul><h2>思考题</h2><p>简单的五个准则，是不可能完全概括出Kotlin的不变性思维的。请问你还能想到其他的不变性准则吗？欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p>","comments":[{"had_liked":false,"id":346599,"user_name":"BUG君","can_delete":false,"product_type":"c1","uid":1143211,"ip_address":"","ucode":"B7513F37026E5F","user_header":"https://static001.geekbang.org/account/avatar/00/11/71/ab/b19a1ba2.jpg","comment_is_top":false,"comment_ctime":1653273719,"is_pvip":false,"replies":[{"id":"126596","content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1653818289,"ip_address":"","comment_id":346599,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23128110199","product_id":100103401,"comment_content":"使用copy()方法,  每次都会创建一个新的对象, 如果不注意在for循环里面使用该方法, 很可能会造成内存抖动","like_count":6,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574061,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653818289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333302,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1644280808,"is_pvip":false,"replies":[{"id":"121802","content":"说的很好，感谢这位同学的补充！<br><br>Kotlin不变性思维有利也有弊，在有些高性能场景下，我们要进行取舍。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644289738,"ip_address":"","comment_id":333302,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14529182696","product_id":100103401,"comment_content":"kotlin 的函数式不变性思维也有一些不好的地方，比如对集合使用各种内置操作符链式调用时，每个操作都会new一个新的拷贝，这时候可以把集合在开始时转成sequence 来操作，避免构造太多中间变量。当然，这也不是万能的，sequence 是一个迭代器，不能覆盖所有场景","like_count":4,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549900,"discussion_content":"说的很好，感谢这位同学的补充！\n\nKotlin不变性思维有利也有弊，在有些高性能场景下，我们要进行取舍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644289738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591915,"discussion_content":"要想更健壮就不得不牺牲一定程度的性能，有点时间换空间的感觉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666929485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338976,"user_name":"爱学习的小羊","can_delete":false,"product_type":"c1","uid":2883920,"ip_address":"","ucode":"9984EB84D7715B","user_header":"https://static001.geekbang.org/account/avatar/00/2c/01/50/c1556a25.jpg","comment_is_top":false,"comment_ctime":1647846410,"is_pvip":false,"replies":[{"id":"124013","content":"可以这样：Copy一下创建新的对象，然后用新的对象更新UI，这时候可能需要考虑Diff。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648030734,"ip_address":"","comment_id":338976,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5942813706","product_id":100103401,"comment_content":"老师好，如果一个APP，需要有修改用户信息的功能，比如修改了用户信息里的身高，这个用数据类怎么处理呀","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557959,"discussion_content":"可以这样：Copy一下创建新的对象，然后用新的对象更新UI，这时候可能需要考虑Diff。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648030734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334326,"user_name":"Geek_66aa0c","can_delete":false,"product_type":"c1","uid":2881969,"ip_address":"","ucode":"372D66A4B962FC","user_header":"","comment_is_top":false,"comment_ctime":1644889245,"is_pvip":false,"replies":[{"id":"122169","content":"可以看看这位同学的补充。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644938924,"ip_address":"","comment_id":334326,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5939856541","product_id":100103401,"comment_content":"SingletonList是java.util.Collections类的内部类，只保存一个元素，在初始化需要赋值，如：<br>List&lt;String&gt; list = Collections.singletonList(&quot;ok&quot;);<br>并且不支持add、remove方法","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":551246,"discussion_content":"可以看看这位同学的补充。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644938925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333293,"user_name":"A Lonely Cat","can_delete":false,"product_type":"c1","uid":2885349,"ip_address":"","ucode":"382EBFDD8E5115","user_header":"https://static001.geekbang.org/account/avatar/00/2c/06/e5/51ef9735.jpg","comment_is_top":false,"comment_ctime":1644251089,"is_pvip":false,"replies":[{"id":"121813","content":"总结很到位。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644296160,"ip_address":"","comment_id":333293,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5939218385","product_id":100103401,"comment_content":"我对 val 不可变理解是：地址不变（在 kotlin 下无法二次赋值，类似Java中的 final 关键字修饰的属性），但是值可能会变（通过该对象的相关方法修改属性）","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549924,"discussion_content":"总结很到位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644296160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352934,"user_name":"郑峰","can_delete":false,"product_type":"c1","uid":1112517,"ip_address":"北京","ucode":"4D4C0C020E507C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/c5/95b97dfa.jpg","comment_is_top":false,"comment_ctime":1659022727,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1659022727","product_id":100103401,"comment_content":"为什么委托里面的by每次访问每次执行，by lazy就只执行一次呢？","like_count":0,"discussions":[{"author":{"id":1143211,"avatar":"https://static001.geekbang.org/account/avatar/00/11/71/ab/b19a1ba2.jpg","nickname":"BUG君","note":"","ucode":"B7513F37026E5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585053,"discussion_content":"可以看下源码, by lazy 有判空","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1661311618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1128983,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3a/17/c5196bb7.jpg","nickname":"Yqh♥","note":"","ucode":"BFF59A2F31722B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588494,"discussion_content":"by lazy这个函数体也会执行多次啊，只是给你返回的值做了判断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663806368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338867,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1647766011,"is_pvip":false,"replies":[{"id":"124009","content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648030207,"ip_address":"","comment_id":338867,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647766011","product_id":100103401,"comment_content":"尽量避免写操作，不得不写的时候，优先考虑拷贝返回，最后才是提供读写操作。读写操作最直观，但是太容易到处写，最后很可能导致全局变量一样的毛病，不知道哪里修改了状态，如果有多线程并发的情况下，更加难调试。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557955,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648030207,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336666,"user_name":"山河入梦","can_delete":false,"product_type":"c1","uid":1480185,"ip_address":"","ucode":"6B8C4896012092","user_header":"https://static001.geekbang.org/account/avatar/00/16/95/f9/0d4801ce.jpg","comment_is_top":false,"comment_ctime":1646280627,"is_pvip":false,"replies":[{"id":"123159","content":"目前我的做法是：使用Moshi进行JSON解析，再搭配一些自定义的配置。由于文字解释起来比较复杂，具体方案，我会在Android项目篇的时候详细介绍的，请留意。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646582075,"ip_address":"","comment_id":336666,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1646280627","product_id":100103401,"comment_content":"想请教一下老师，对于数据类用val声明的字段如果后台返回了null怎么办，尤其是“陈年接口”","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554765,"discussion_content":"目前我的做法是：使用Moshi进行JSON解析，再搭配一些自定义的配置。由于文字解释起来比较复杂，具体方案，我会在Android项目篇的时候详细介绍的，请留意。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646582075,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1174704,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ec/b0/4e22819f.jpg","nickname":"syz","note":"","ucode":"54AF17ACD72645","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555226,"discussion_content":"data class User(val name:String?=null)    这样呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646815030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335055,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1645276103,"is_pvip":false,"replies":[{"id":"122416","content":"是有这个可能的，Kotlin底层编译器的转换规则是不透明的。<br><br>不过，你可以运行时打断点看看，反编译的类型不一定就是运行时的，因为SingletonList也算是List的子类。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1645370717,"ip_address":"","comment_id":335055,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1645276103","product_id":100103401,"comment_content":"关于Java中的不变性集合，为什么我自动导了 java.util.List 而不是 SingletonList？<br>而且我报的错是 ClassCastException: java.lang.String cannot be cast to java.lang.Void ？<br><br>import java.util.List;<br>class Test {<br>\tpublic static void main(String[] args) {<br>\t\tList&lt;String&gt; data = new Model().getData();<br>\t\tdata.add(&quot;bqt&quot;); &#47;&#47; ClassCastException: java.lang.String cannot be cast to java.lang.Void<br>\t}<br>}","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552277,"discussion_content":"是有这个可能的，Kotlin底层编译器的转换规则是不透明的。\n\n不过，你可以运行时打断点看看，反编译的类型不一定就是运行时的，因为SingletonList也算是List的子类。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645370717,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333292,"user_name":"A Lonely Cat","can_delete":false,"product_type":"c1","uid":2885349,"ip_address":"","ucode":"382EBFDD8E5115","user_header":"https://static001.geekbang.org/account/avatar/00/2c/06/e5/51ef9735.jpg","comment_is_top":false,"comment_ctime":1644250661,"is_pvip":false,"replies":[{"id":"121811","content":"感谢这为同学指出的问题，当我脑子里想的是“可变性”的时候，写出来的却是“不变性”，是真的把自己绕晕了，会改回来的。<br><br>PS：补充的内容也很好，大家可以参考。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644295954,"ip_address":"","comment_id":333292,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1644250661","product_id":100103401,"comment_content":"感觉朱老师把自己写懵了。一会儿消除不变性，一会儿消除可变性。<br><br>例：<br>1、消灭数据类中的不变性。<br>2、数据类来存储数据，消灭数据的可变性。<br><br>类似的问题还有好多处🤔🤔<br><br>大家可以看看老外的这篇文章：https:&#47;&#47;commonsware.com&#47;AndroidArch&#47;pages&#47;chap-immutability-001<br><br><br>Immutability is one way of imposing a contract upon yourself, as a developer, to avoid side effects. Calling a setter is a very casual act in programming, even if calling that setter introduces a side effect. Immutability enforces the creation of new objects, ideal for use in pure functions, where the function can create objects to return but cannot change the parameters’ contents and cause side effects.<br><br>译：<br>不变性是作为开发人员将合同强加于自己以避免副作用的一种方式。调用 setter 在编程中是一种非常随意的行为，即使调用该 setter 会带来副作用。不变性强制创建新对象，非常适合在纯函数中使用，其中函数可以创建要返回的对象，但不能更改参数的内容并导致副作用。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549922,"discussion_content":"感谢这为同学指出的问题，当我脑子里想的是“可变性”的时候，写出来的却是“不变性”，是真的把自己绕晕了，会改回来的。\n\nPS：补充的内容也很好，大家可以参考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644295954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2885349,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/06/e5/51ef9735.jpg","nickname":"A Lonely Cat","note":"","ucode":"382EBFDD8E5115","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549926,"discussion_content":"属于是手比脑子快了😂😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644296283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333275,"user_name":"better","can_delete":false,"product_type":"c1","uid":1169063,"ip_address":"","ucode":"AF1DB566EBB8A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","comment_is_top":false,"comment_ctime":1644242741,"is_pvip":false,"replies":[{"id":"121812","content":"加油哈~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644295973,"ip_address":"","comment_id":333275,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1644242741","product_id":100103401,"comment_content":"加餐的内容，非常不错。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549923,"discussion_content":"加油哈~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644295973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333247,"user_name":"墨方","can_delete":false,"product_type":"c1","uid":1295549,"ip_address":"","ucode":"638AE114D4CAC5","user_header":"https://static001.geekbang.org/account/avatar/00/13/c4/bd/44757daf.jpg","comment_is_top":false,"comment_ctime":1644229215,"is_pvip":false,"replies":[{"id":"121771","content":"如果你追求“不变性”，那么数据类的copy就是最方便的选择了。否则你就得var来实现了，这其实是一种取舍。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1644250198,"ip_address":"","comment_id":333247,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1644229215","product_id":100103401,"comment_content":"数据类用copy做更改，太麻烦了吧，难道没有更好的方式了吗？","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549834,"discussion_content":"如果你追求“不变性”，那么数据类的copy就是最方便的选择了。否则你就得var来实现了，这其实是一种取舍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644250199,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020838,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","nickname":"Renext","note":"","ucode":"3C4418F7E86CD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549971,"discussion_content":"kotlin可以用copy。那java类引用这个对象要修改值怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644314670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}