{"id":9588,"title":"第20讲 | 并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？","content":"<p>在上一讲中，我分析了Java并发包中的部分内容，今天我来介绍一下线程安全队列。Java标准库提供了非常多的线程安全队列，很容易混淆。</p>\n<p>今天我要问你的问题是，<span class=\"orange\">并发包中的ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别？</span></p>\n<h2>典型回答</h2>\n<p>有时候我们把并发包下面的所有容器都习惯叫作并发容器，但是严格来讲，类似ConcurrentLinkedQueue这种“Concurrent*”容器，才是真正代表并发。</p>\n<p>关于问题中它们的区别：</p>\n<ul>\n<li>\n<p>Concurrent类型基于lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。</p>\n</li>\n<li>\n<p>而LinkedBlockingQueue内部则是基于锁，并提供了BlockingQueue的等待性方法。</p>\n</li>\n</ul>\n<p>不知道你有没有注意到，java.util.concurrent包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为Concurrent*、CopyOnWrite<em>和Blocking</em>等三类，同样是线程安全容器，可以简单认为：</p>\n<ul>\n<li>\n<p>Concurrent类型没有类似CopyOnWrite之类容器相对较重的修改开销。</p>\n</li>\n<li>\n<p>但是，凡事都是有代价的，Concurrent往往提供了较低的遍历一致性。你可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。</p>\n</li>\n<li>\n<p>与弱一致性对应的，就是我介绍过的同步容器常见的行为“fail-fast”，也就是检测到容器在遍历过程中发生了修改，则抛出ConcurrentModificationException，不再继续遍历。</p>\n</li>\n<li>\n<p>弱一致性的另外一个体现是，size等操作准确性是有限的，未必是100%准确。</p>\n</li>\n<li>\n<p>与此同时，读取的性能具有一定的不确定性。</p>\n</li>\n</ul><!-- [[[read_end]]] -->\n<h2>考点分析</h2>\n<p>今天的问题是又是一个引子，考察你是否了解并发包内部不同容器实现的设计目的和实现区别。</p>\n<p>队列是非常重要的数据结构，我们日常开发中很多线程间数据传递都要依赖于它，Executor框架提供的各种线程池，同样无法离开队列。面试官可以从不同角度考察，比如：</p>\n<ul>\n<li>\n<p>哪些队列是有界的，哪些是无界的？（很多同学反馈了这个问题）</p>\n</li>\n<li>\n<p>针对特定场景需求，如何选择合适的队列实现？</p>\n</li>\n<li>\n<p>从源码的角度，常见的线程安全队列是如何实现的，并进行了哪些改进以提高性能表现？</p>\n</li>\n</ul>\n<p>为了能更好地理解这一讲，需要你掌握一些基本的队列本身和数据结构方面知识，如果这方面知识比较薄弱，《数据结构与算法分析》是一本比较全面的参考书，专栏还是尽量专注于Java领域的特性。</p>\n<h2>知识扩展</h2>\n<p><strong>线程安全队列一览</strong></p>\n<p>我在<a href=\"http://time.geekbang.org/column/article/7810\">专栏第8讲</a>中介绍过，常见的集合中如LinkedList是个Deque，只不过不是线程安全的。下面这张图是Java并发类库提供的各种各样的<strong>线程安全</strong>队列实现，注意，图中并未将非线程安全部分包含进来。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/79/79/791750d6fe7ef88ecb3897e1d029f079.png?wh=851*359\" alt=\"\" /></p>\n<p>我们可以从不同的角度进行分类，从基本的数据结构的角度分析，有两个特别的<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html\">Deque</a>实现，ConcurrentLinkedDeque和LinkedBlockingDeque。Deque的侧重点是支持对队列头尾都进行插入和删除，所以提供了特定的方法，如:</p>\n<ul>\n<li>\n<p>尾部插入时需要的<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#addLast-E-\">addLast(e)</a>、<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#offerLast-E-\">offerLast(e)</a>。</p>\n</li>\n<li>\n<p>尾部删除所需要的<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#removeLast--\">removeLast()</a>、<a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/Deque.html#pollLast--\">pollLast()</a>。</p>\n</li>\n</ul>\n<p>从上面这些角度，能够理解ConcurrentLinkedDeque和LinkedBlockingQueue的主要功能区别，也就足够日常开发的需要了。但是如果我们深入一些，通常会更加关注下面这些方面。</p>\n<p>从行为特征来看，绝大部分Queue都是实现了BlockingQueue接口。在常规队列操作基础上，Blocking意味着其提供了特定的等待性操作，获取时（take）等待元素进队，或者插入时（put）等待队列出现空位。</p>\n<pre><code> /**\n * 获取并移除队列头结点，如果必要，其会等待直到队列出现元素\n…\n */\nE take() throws InterruptedException;\n\n/**\n * 插入元素，如果队列已满，则等待直到队列出现空闲空间\n   …\n */\nvoid put(E e) throws InterruptedException;  \n</code></pre>\n<p>另一个BlockingQueue经常被考察的点，就是是否有界（Bounded、Unbounded），这一点也往往会影响我们在应用开发中的选择，我这里简单总结一下。</p>\n<ul>\n<li>ArrayBlockingQueue是最典型的的有界队列，其内部以final的数组保存数据，数组的大小就决定了队列的边界，所以我们在创建ArrayBlockingQueue时，都要指定容量，如</li>\n</ul>\n<pre><code>public ArrayBlockingQueue(int capacity, boolean fair)\n</code></pre>\n<ul>\n<li>\n<p>LinkedBlockingQueue，容易被误解为无边界，但其实其行为和内部代码都是基于有界的逻辑实现的，只不过如果我们没有在创建队列时就指定容量，那么其容量限制就自动被设置为Integer.MAX_VALUE，成为了无界队列。</p>\n</li>\n<li>\n<p>SynchronousQueue，这是一个非常奇葩的队列实现，每个删除操作都要等待插入操作，反之每个插入操作也都要等待删除动作。那么这个队列的容量是多少呢？是1吗？其实不是的，其内部容量是0。</p>\n</li>\n<li>\n<p>PriorityBlockingQueue是无边界的优先队列，虽然严格意义上来讲，其大小总归是要受系统资源影响。</p>\n</li>\n<li>\n<p>DelayedQueue和LinkedTransferQueue同样是无边界的队列。对于无边界的队列，有一个自然的结果，就是put操作永远也不会发生其他BlockingQueue的那种等待情况。</p>\n</li>\n</ul>\n<p>如果我们分析不同队列的底层实现，BlockingQueue基本都是基于锁实现，一起来看看典型的LinkedBlockingQueue。</p>\n<pre><code>/** Lock held by take, poll, etc */\nprivate final ReentrantLock takeLock = new ReentrantLock();\n\n/** Wait queue for waiting takes */\nprivate final Condition notEmpty = takeLock.newCondition();\n\n/** Lock held by put, offer, etc */\nprivate final ReentrantLock putLock = new ReentrantLock();\n\n/** Wait queue for waiting puts */\nprivate final Condition notFull = putLock.newCondition();\n</code></pre>\n<p>我在介绍ReentrantLock的条件变量用法的时候分析过ArrayBlockingQueue，不知道你有没有注意到，其条件变量与LinkedBlockingQueue版本的实现是有区别的。notEmpty、notFull都是同一个再入锁的条件变量，而LinkedBlockingQueue则改进了锁操作的粒度，头、尾操作使用不同的锁，所以在通用场景下，它的吞吐量相对要更好一些。</p>\n<p>下面的take方法与ArrayBlockingQueue中的实现，也是有不同的，由于其内部结构是链表，需要自己维护元素数量值，请参考下面的代码。</p>\n<pre><code>public E take() throws InterruptedException {\n    final E x;\n    final int c;\n    final AtomicInteger count = this.count;\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lockInterruptibly();\n    try {\n        while (count.get() == 0) {\n            notEmpty.await();\n        }\n        x = dequeue();\n        c = count.getAndDecrement();\n        if (c &gt; 1)\n            notEmpty.signal();\n    } finally {\n        takeLock.unlock();\n    }\n    if (c == capacity)\n        signalNotFull();\n    return x;\n}\n</code></pre>\n<p>类似ConcurrentLinkedQueue等，则是基于CAS的无锁技术，不需要在每个操作时使用锁，所以扩展性表现要更加优异。</p>\n<p>相对比较另类的SynchronousQueue，在Java 6中，其实现发生了非常大的变化，利用CAS替换掉了原本基于锁的逻辑，同步开销比较小。它是Executors.newCachedThreadPool()的默认队列。</p>\n<p><strong>队列使用场景与典型用例</strong></p>\n<p>在实际开发中，我提到过Queue被广泛使用在生产者-消费者场景，比如利用BlockingQueue来实现，由于其提供的等待机制，我们可以少操心很多协调工作，你可以参考下面样例代码：</p>\n<pre><code>import java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.BlockingQueue;\n\npublic class ConsumerProducer {\n    public static final String EXIT_MSG  = &quot;Good bye!&quot;;\n    public static void main(String[] args) {\n// 使用较小的队列，以更好地在输出中展示其影响\n        BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(3);\n        Producer producer = new Producer(queue);\n        Consumer consumer = new Consumer(queue);\n        new Thread(producer).start();\n        new Thread(consumer).start();\n    }\n\n\n    static class Producer implements Runnable {\n        private BlockingQueue&lt;String&gt; queue;\n        public Producer(BlockingQueue&lt;String&gt; q) {\n            this.queue = q;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 20; i++) {\n                try{\n                    Thread.sleep(5L);\n                    String msg = &quot;Message&quot; + i;\n                    System.out.println(&quot;Produced new item: &quot; + msg);\n                    queue.put(msg);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            try {\n                System.out.println(&quot;Time to say good bye!&quot;);\n                queue.put(EXIT_MSG);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class Consumer implements Runnable{\n        private BlockingQueue&lt;String&gt; queue;\n        public Consumer(BlockingQueue&lt;String&gt; q){\n            this.queue=q;\n        }\n\n        @Override\n        public void run() {\n            try{\n                String msg;\n                while(!EXIT_MSG.equalsIgnoreCase( (msg = queue.take()))){\n                    System.out.println(&quot;Consumed item: &quot; + msg);\n                    Thread.sleep(10L);\n                }\n                System.out.println(&quot;Got exit message, bye!&quot;);\n            }catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>\n<p>上面是一个典型的生产者-消费者样例，如果使用非Blocking的队列，那么我们就要自己去实现轮询、条件判断（如检查poll返回值是否null）等逻辑，如果没有特别的场景要求，Blocking实现起来代码更加简单、直观。</p>\n<p>前面介绍了各种队列实现，在日常的应用开发中，如何进行选择呢？</p>\n<p>以LinkedBlockingQueue、ArrayBlockingQueue和SynchronousQueue为例，我们一起来分析一下，根据需求可以从很多方面考量：</p>\n<ul>\n<li>\n<p>考虑应用场景中对队列边界的要求。ArrayBlockingQueue是有明确的容量限制的，而LinkedBlockingQueue则取决于我们是否在创建时指定，SynchronousQueue则干脆不能缓存任何元素。</p>\n</li>\n<li>\n<p>从空间利用角度，数组结构的ArrayBlockingQueue要比LinkedBlockingQueue紧凑，因为其不需要创建所谓节点，但是其初始分配阶段就需要一段连续的空间，所以初始内存需求更大。</p>\n</li>\n<li>\n<p>通用场景中，LinkedBlockingQueue的吞吐量一般优于ArrayBlockingQueue，因为它实现了更加细粒度的锁操作。</p>\n</li>\n<li>\n<p>ArrayBlockingQueue实现比较简单，性能更好预测，属于表现稳定的“选手”。</p>\n</li>\n<li>\n<p>如果我们需要实现的是两个线程之间接力性（handoff）的场景，按照<a href=\"http://time.geekbang.org/column/article/9373\">专栏上一讲</a>的例子，你可能会选择CountDownLatch，但是<a href=\"http://www.baeldung.com/java-synchronous-queue\">SynchronousQueue</a>也是完美符合这种场景的，而且线程间协调和数据传输统一起来，代码更加规范。</p>\n</li>\n<li>\n<p>可能令人意外的是，很多时候SynchronousQueue的性能表现，往往大大超过其他实现，尤其是在队列元素较小的场景。</p>\n</li>\n</ul>\n<p>今天我分析了Java中让人眼花缭乱的各种线程安全队列，试图从几个角度，让每个队列的特点更加明确，进而希望减少你在日常工作中使用时的困扰。</p>\n<h2>一课一练</h2>\n<p>关于今天我们讨论的题目你做到心中有数了吗？ 今天的内容侧重于Java自身的角度，面试官也可能从算法的角度来考察，所以今天留给你的思考题是，指定某种结构，比如栈，用它实现一个BlockingQueue，实现思路是怎样的呢？</p>\n<p>请你在留言区写写你对这个问题的思考，我会选出经过认真思考的留言，送给你一份学习奖励礼券，欢迎你与我一起讨论。</p>\n<p>你的朋友是不是也在准备面试呢？你可以“请朋友读”，把今天的题目分享给好友，或许你能帮到他。</p>\n<p></p>\n","neighbors":{"left":{"article_title":"第19讲 | Java并发包提供了哪些并发工具类？","id":9373},"right":{"article_title":"第21讲 | Java并发类库提供的线程池有哪几种？ 分别有什么特点？","id":9712}},"comments":[{"had_liked":false,"id":13310,"user_name":"sunlight001","can_delete":false,"product_type":"c1","uid":1126975,"ip_address":"","ucode":"A72C4274D5DE8A","user_header":"https://static001.geekbang.org/account/avatar/00/11/32/3f/fa4ac035.jpg","comment_is_top":false,"comment_ctime":1529539149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"379486661197","product_id":100006701,"comment_content":"这个看着很吃力啊，都没接触过😂","like_count":89},{"had_liked":false,"id":24221,"user_name":"丘壑","can_delete":false,"product_type":"c1","uid":1118203,"ip_address":"","ucode":"ECFEDA5A93828D","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/fb/68196d4c.jpg","comment_is_top":false,"comment_ctime":1536850162,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"194810378482","product_id":100006701,"comment_content":"栈来实现blockqueue，个人感觉比较好的有<br>方案一：总共3个栈，其中2个写入栈（A、B），1个消费栈栈C（消费数据），但是有1个写入栈是空闲的栈（B），随时等待写入，当消费栈(C)中数据为空的时候，消费线程（await），触发数据转移，原写入栈(A)停止写入，，由空闲栈（B）接受写入的工作，原写入栈(A)中的数据转移到消费栈（C）中，转移完成后继续（sign）继续消费，2个写入栈，1个消费栈优点是：不会堵塞写入，但是消费会有暂停<br><br>方案二：总共4个栈，其中2个写入栈（A、B），2个消费栈（C、D）,其中B为空闲的写入栈，D为空闲的消费栈，当消费栈（C）中的数据下降到一定的数量，则触发数据转移，这时候A栈停止写入，由B栈接受写入数据，然后将A栈中的数据转入空闲的消费栈D，当C中的数据消费完了后，则C栈转为空闲，D栈转为激活消费状态，当D栈中的数据消费到一定比例后，重复上面过程，该方案优点即不堵塞写入，也不会造成消费线程暂停<br><br><br>","like_count":46,"discussions":[{"author":{"id":1330065,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N0NACGUr8dNAbN6BdiagPHBaB0EnyDsI9zWpwJteqTY38apOEnTOA7JkBAQnzYKJBgxu3Q8YMUILwLAB6camn4w/132","nickname":"Swing","note":"","ucode":"55FCA9ECEFBBEB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":217396,"discussion_content":"没看懂。。。让视线 blockingqueue。。。即 队列满时 堵塞写，队列空时 堵塞读。\n\n你这一个是实现 不堵塞写，堵塞读；一个是都 不堵塞？？\n\n思路不错。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585554516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1117302,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/76/0c07376d.jpg","nickname":"蒙奇君杰","note":"","ucode":"2DBCECD149730F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308992,"discussion_content":"这种冗余性的设计思路，确实不错。\n咱们开发中使用MQ，KafKa等消息队列，\n从广义上来说，也是一种生产者和消费者的冗余。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601162977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1117302,"avatar":"https://static001.geekbang.org/account/avatar/00/11/0c/76/0c07376d.jpg","nickname":"蒙奇君杰","note":"","ucode":"2DBCECD149730F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384917,"discussion_content":"RocketMQ和Kafka是消费者-生产者模式，RabbitMQ是队列模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626792650,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":308992,"ip_address":""},"score":384917,"extra":""}]},{"author":{"id":1298380,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cf/cc/8de5007b.jpg","nickname":"徐改","note":"","ucode":"82276A584AC602","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50882,"discussion_content":"很切实际的思路。点个赞！学到了！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573782250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1144504,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/b8/e4cd7997.jpg","nickname":"KAGEMUSHA","note":"","ucode":"DFC05BE62A9C10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37598,"discussion_content":"666666","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571643363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104470,"avatar":"https://static001.geekbang.org/account/avatar/00/10/da/56/004a3240.jpg","nickname":"ilife","note":"","ucode":"25ECBC1BC0F021","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":210855,"discussion_content":"让我想到了分代收集算法的GC过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584783479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":45987,"user_name":"吕倩","can_delete":false,"product_type":"c1","uid":1253300,"ip_address":"","ucode":"545518F3AA9788","user_header":"https://static001.geekbang.org/account/avatar/00/13/1f/b4/33099f97.jpg","comment_is_top":false,"comment_ctime":1543828634,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"74558272666","product_id":100006701,"comment_content":"老师你好，在读ArrayBlockingQueue源码的时候，发现很多地方都有 final ReentrantLock lock = this.lock; 这样的语句，处于什么原因会将类变量复制一份到局部变量，然后再使用呢？","like_count":18,"discussions":[{"author":{"id":2330905,"avatar":"https://static001.geekbang.org/account/avatar/00/23/91/19/6a3e7efc.jpg","nickname":"程序员9527","note":"","ucode":"1A1609F6BEAD84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384919,"discussion_content":"this.lock是类的成员变量，一般都是存到堆上，访问堆上的变量会涉及内存同步的操作(这个建议通过编译后的bytecode进行观察)，而将其copy到栈上，然后访问就不存在这个问题了\n\n在访问堆上的this.lock时，对于多个CPU，可能会存在cache命中的问题，这样必然会导致内存重新load，而copy到栈上，则直接是线程相关的，就不存在这个问题了。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1626793153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338531,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6c/a3/11df679f.jpg","nickname":"风吹过wu","note":"","ucode":"27E3133A52EA7D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384396,"discussion_content":"开","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626566665,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":90020,"user_name":"Lighters","can_delete":false,"product_type":"c1","uid":1229471,"ip_address":"","ucode":"AD6307C09DF273","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/9f/f8bc3520.jpg","comment_is_top":false,"comment_ctime":1556368553,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48801008809","product_id":100006701,"comment_content":"希望能够增加一些具体的业务使用场景，否则只是单纯的分析，太抽象了<br>","like_count":12},{"had_liked":false,"id":13331,"user_name":"石头狮子","can_delete":false,"product_type":"c1","uid":1118031,"ip_address":"","ucode":"3BABB93E552022","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/4f/c75c4889.jpg","comment_is_top":false,"comment_ctime":1529542968,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"48774183224","product_id":100006701,"comment_content":"实现课后题过程中把握以下几个维度，<br>1，数据操作的锁粒度。<br>2，计数，遍历方式。<br>3，数据结构空，满时线程的等待方式，有锁或无锁方式。<br>4，使用离散还是连续的存储结构。","like_count":12},{"had_liked":false,"id":13424,"user_name":"crazyone","can_delete":false,"product_type":"c1","uid":1115042,"ip_address":"","ucode":"705E34642E41F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/a2/ceb37046.jpg","comment_is_top":false,"comment_ctime":1529623732,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31594394804","product_id":100006701,"comment_content":"从上面这些角度，能够理解 ConcurrentLinkedDeque 和 LinkedBlockingQueue 的主要功能区别。  这段应该是 &quot;ConcurrentLinkedDeque 和 LinkedBlockingDeque 的主要功能区别&quot;","like_count":8},{"had_liked":false,"id":13418,"user_name":"猕猴桃 盛哥","can_delete":false,"product_type":"c1","uid":1102535,"ip_address":"","ucode":"D652436CB1E506","user_header":"https://static001.geekbang.org/account/avatar/00/10/d2/c7/14d235bb.jpg","comment_is_top":false,"comment_ctime":1529601811,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31594372883","product_id":100006701,"comment_content":"{<br>    &quot;test&quot;:[<br>        [<br>            89,<br>            90,<br>            [<br>                [<br>                    1093,<br>                    709<br>                ],<br>                [<br>                    1056,<br>                    709<br>                ]<br>            ]<br>        ]<br>    ]<br>}<br><br>测试题：这个json用java对象怎么表示？","like_count":8,"discussions":[{"author":{"id":2289255,"avatar":"https://static001.geekbang.org/account/avatar/00/22/ee/67/e97fea7d.jpg","nickname":"[ThumbsUp]","note":"","ucode":"428818387DE5F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325750,"discussion_content":"JSONObject 套 JSONArray, JSONArray又多重嵌套，套娃呢...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605423181,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":151775,"discussion_content":"盛哥你好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579885065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13970,"user_name":"无呢可称","can_delete":false,"product_type":"c1","uid":1079979,"ip_address":"","ucode":"0AAB6A3CA6685B","user_header":"https://static001.geekbang.org/account/avatar/00/10/7a/ab/342ec0ca.jpg","comment_is_top":false,"comment_ctime":1530090087,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"14414991975","product_id":100006701,"comment_content":"@Jerry银银。用两个栈可以实现fifo的队列<br><br>","like_count":3,"discussions":[{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219835,"discussion_content":"大神，能否详细说明下，两个栈如何实现fifo的队列？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585816031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1658079,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4c/df/09d0eb0d.jpg","nickname":"布莱安托","note":"","ucode":"D54973C93B6DE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":265082,"discussion_content":"A、B两个栈，先写A栈，A栈写满之后出栈压到B栈，B栈再出栈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589373223,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":219835,"ip_address":""},"score":265082,"extra":""},{"author":{"id":1148845,"avatar":"https://static001.geekbang.org/account/avatar/00/11/87/ad/50a85a04.jpg","nickname":"hao","note":"","ucode":"997F2B57E2F556","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1658079,"avatar":"https://static001.geekbang.org/account/avatar/00/19/4c/df/09d0eb0d.jpg","nickname":"布莱安托","note":"","ucode":"D54973C93B6DE8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":323700,"discussion_content":"有道理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604983151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":265082,"ip_address":""},"score":323700,"extra":""}]}]},{"had_liked":false,"id":13332,"user_name":"石头狮子","can_delete":false,"product_type":"c1","uid":1118031,"ip_address":"","ucode":"3BABB93E552022","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/4f/c75c4889.jpg","comment_is_top":false,"comment_ctime":1529542969,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14414444857","product_id":100006701,"comment_content":"实现课后题过程中把握以下几个维度，<br>1，数据操作的锁粒度。<br>2，计数，遍历方式。<br>3，数据结构空，满时线程的等待方式，有锁或无锁方式。<br>4，使用离散还是连续的存储结构。","like_count":3},{"had_liked":false,"id":18573,"user_name":"酱了个油","can_delete":false,"product_type":"c1","uid":1059627,"ip_address":"","ucode":"5A13CA4EAACB81","user_header":"https://static001.geekbang.org/account/avatar/00/10/2b/2b/bebf6eed.jpg","comment_is_top":false,"comment_ctime":1533461393,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10123395985","product_id":100006701,"comment_content":"队列的一个问题是不能持久化、不能做到分布式，有时候考虑到系统可靠性，使用的机会不多。杨老师可以给一些使用队列的例子吗？","like_count":2},{"had_liked":false,"id":16118,"user_name":"汉彬","can_delete":false,"product_type":"c1","uid":1122623,"ip_address":"","ucode":"088891C1D6C661","user_header":"https://static001.geekbang.org/account/avatar/00/11/21/3f/409aa5d2.jpg","comment_is_top":false,"comment_ctime":1531790386,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10121724978","product_id":100006701,"comment_content":"用栈实现BlockingQueue，我的理解是：栈是LIFO，BlockingQueue是FIFO，因此需要两个栈。take时先把栈A全部入栈到栈B，然后栈B出栈得到目标元素；put时把栈B全部入栈到栈A，然后栈A再入栈目标元素。相当于倒序一下。<br><br>不知道理解对不对，请老师指出。","like_count":3},{"had_liked":false,"id":14676,"user_name":"爱新觉罗老流氓","can_delete":false,"product_type":"c1","uid":1005661,"ip_address":"","ucode":"B13AC4DA358C15","user_header":"https://static001.geekbang.org/account/avatar/00/0f/58/5d/8de7f8dc.jpg","comment_is_top":false,"comment_ctime":1530591964,"is_pvip":false,"replies":[{"id":"4981","content":"谢谢指出，我查查是不是我记反了","user_name":"作者回复","comment_id":14676,"uid":"1009360","ip_address":"","utype":1,"ctime":1530664819,"user_name_real":"杨晓峰"}],"discussion_count":2,"race_medal":0,"score":"10120526556","product_id":100006701,"comment_content":"杨老师，“与弱一致性对应的，就是我介绍过的同步容器常见的行为“fast-fail”，也就是检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。” <br>这一段落里，快速失败的英文在doc上是“fail-fast”，在ArrayList源码中文档可以搜到。<br>还有，同步容器不应该是“fail-safe”吗？","like_count":3,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":420088,"discussion_content":"谢谢指出，我查查是不是我记反了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530664819,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1500880,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvNozkiaiao1I945xyUGC0vXZSnibImBPbf7CtibqKoGDsbmZGnia62zibv4s3grqtVllO82tILEJ1Dh2w/132","nickname":"惊蛰","note":"","ucode":"8A03CC80666787","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299314,"discussion_content":"是记反了， 同步容易因为会加锁操作，所以应该是 fail-safe的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597655554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265296,"user_name":"jiahua","can_delete":false,"product_type":"c1","uid":1154783,"ip_address":"","ucode":"A2B85DA49DC69D","user_header":"https://static001.geekbang.org/account/avatar/00/11/9e/df/ac5c60b5.jpg","comment_is_top":false,"comment_ctime":1606840448,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5901807744","product_id":100006701,"comment_content":"两个栈A和B, 一直向A中写，从B中读，B中没有时，把当前A中的放到B中","like_count":1},{"had_liked":false,"id":96230,"user_name":"拯救地球好累","can_delete":false,"product_type":"c1","uid":1339022,"ip_address":"","ucode":"7643439601EF4C","user_header":"https://static001.geekbang.org/account/avatar/00/14/6e/8e/5d309a85.jpg","comment_is_top":false,"comment_ctime":1558361093,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853328389","product_id":100006701,"comment_content":"从几个问题来学习新的框架或工具：<br>1.用来解决什么问题？常见的应用场景有哪些？<br>2.jdk内部或第三方框架在什么场景中如何运用？<br>3.有哪几种类似的实现或工具？它们之间有何区别？在结构层次上有何联系？<br>4.从源码上看关键代码有哪几个地方？","like_count":2},{"had_liked":false,"id":49839,"user_name":"南北少卿","can_delete":false,"product_type":"c1","uid":1018958,"ip_address":"","ucode":"DFCC59F2BBD8CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/4e/b81969fa.jpg","comment_is_top":false,"comment_ctime":1544778041,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5839745337","product_id":100006701,"comment_content":"杨老师,你好,最近我debug过ConcurrentLinkedQueue的源码,第一次添加元素的时候,为什么head指向添加的元素,而tail指向自己,始终搞不明白,经过p.casNext(null, newNode)操作之后,这中间的变化到底是怎么回事?您能解答下吗?望指点.我的微信号:LEE794112629","like_count":1,"discussions":[{"author":{"id":2837603,"avatar":"","nickname":"Geek_18e6f5","note":"","ucode":"3700BC57DD6FF3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":413165,"discussion_content":"其实这个思路很简单，你不可能让tail和next都原子的一起修改为新添加的节点，所以他干脆就不让tail一直都指向尾节点，只要next是对的就行了，然后在适当的时候把tail更新一下，防止tail落后太多。然后你要找lastno只要沿着tail一直找那个next为空的节点就是尾节点了，至于为啥不每次都读tail而要搞一个t(锚点)出来，是因为tail是一个volatile变量，而且tail本身就不准确，只在必要的时候读一下tail提高读性能，至于上面说的适当时候，必要时候，就是他的那个松弛度(就是2)。当然也不是说tail离lastnode一定不超过2，极端情况下，还是会超过2的。出队也是同一个思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636388179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":37943,"user_name":"杭州","can_delete":false,"product_type":"c1","uid":1121604,"ip_address":"","ucode":"2E5E330FAB24FA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIyqjqjTlaiavQb1I7d5au4A3mojticTXgBEu6picAv3qS7f1jhdq4bSS8mJpic1zWNhxaQWNPfYkQF0w/132","comment_is_top":false,"comment_ctime":1541819888,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5836787184","product_id":100006701,"comment_content":"杨老师你好，我碰到个问题： 200个线程池 阻塞读take（）linkblockingqueue队列，偶尔会发现线程池中的阻塞线程cpu突高。jstack看了有很多的lock。怀疑是池程离开线程池去干别的活，干了一半又回到线程池中，出现死锁表现cpu高。不知道是什么这个原因，不知道怎么解决？","like_count":1},{"had_liked":false,"id":13488,"user_name":"Jerry银银","can_delete":false,"product_type":"c1","uid":1008404,"ip_address":"","ucode":"80DA1172A2360A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/14/06eff9a4.jpg","comment_is_top":false,"comment_ctime":1529673015,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5824640311","product_id":100006701,"comment_content":"用栈来实现BlockingQueue，换句话是说，用先进后出的数据结构来实现先进先出的数据结构，怎么感觉听起来不那么对劲呢？请指点","like_count":1,"discussions":[{"author":{"id":1088710,"avatar":"https://static001.geekbang.org/account/avatar/00/10/9c/c6/05a6798f.jpg","nickname":"苗","note":"","ucode":"5ECCC6C855E541","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306790,"discussion_content":"应该还考了适配器模式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600390455,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13371,"user_name":"灰飞灰猪不会灰飞.烟灭","can_delete":false,"product_type":"c1","uid":1127314,"ip_address":"","ucode":"FF9FB4C902D1F5","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/92/99530cee.jpg","comment_is_top":false,"comment_ctime":1529562586,"is_pvip":false,"replies":[{"id":"4509","content":"所谓结束是指terminated？正常的线程池移除工作线程，要么线程意外退出，比如任务抛异常，要么线程闲置，又规定了闲置时间；线程池中线程是把额外封装的，本来下章写了，内容篇幅超标移到后面了，慢慢来；有，建议学会看文档，自己找答案","user_name":"作者回复","comment_id":13371,"uid":"1009360","ip_address":"","utype":1,"ctime":1529631556,"user_name_real":"杨晓峰"}],"discussion_count":1,"race_medal":0,"score":"5824529882","product_id":100006701,"comment_content":"老师 线程池中如果线程已经运行结束则删除该线程。如何判断线程已经运行结束了呢？源码中我看见按照线程的状态，我不清楚这些状态值哪来的。java代码有判断线程状态的方法吗？谢谢老师","like_count":2,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419630,"discussion_content":"所谓结束是指terminated？正常的线程池移除工作线程，要么线程意外退出，比如任务抛异常，要么线程闲置，又规定了闲置时间；线程池中线程是把额外封装的，本来下章写了，内容篇幅超标移到后面了，慢慢来；有，建议学会看文档，自己找答案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529631556,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":296881,"user_name":"Geek_6ce7fa","can_delete":false,"product_type":"c1","uid":2290464,"ip_address":"","ucode":"D4F334284E4482","user_header":"","comment_is_top":false,"comment_ctime":1623209481,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1623209481","product_id":100006701,"comment_content":"PriorityBlockingQueue是有界队列吧","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391002,"discussion_content":"无界的，只能设置初始长度，会不断扩容，扩容上限是MAX_VALUE-8，相当于无界","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630225266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":248697,"user_name":"Geek_154f14","can_delete":false,"product_type":"c1","uid":2181453,"ip_address":"","ucode":"F01FF696364E73","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJAnje12Sebss1BwgLF48Wk57zaMtMSWdStbC6R7l0ssCev0ddLPYd2QqGXBmpfNL89NtahYKVkVg/132","comment_is_top":false,"comment_ctime":1600265436,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600265436","product_id":100006701,"comment_content":"一般情况下用linked确实好点，他有俩把锁，粒度细效率更高<br>","like_count":0},{"had_liked":false,"id":230245,"user_name":"大成尊者","can_delete":false,"product_type":"c1","uid":1783367,"ip_address":"","ucode":"42473322052B11","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/47/8e80082c.jpg","comment_is_top":false,"comment_ctime":1593326672,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1593326672","product_id":100006701,"comment_content":"指定某种结构，比如栈，用它实现一个 BlockingQueue，实现思路是怎样的呢？<br>答：不能实现。因为栈遵循的是先进后出，你上面说的不管是ArrayBlockingQueue还是LinkedBlockingQueue，都是支持先进先出的，栈这个数据结构就不支持先进先出。","like_count":0,"discussions":[{"author":{"id":1297112,"avatar":"https://static001.geekbang.org/account/avatar/00/13/ca/d8/b109ed85.jpg","nickname":"Jack","note":"","ucode":"F3863DAEF449D5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365404,"discussion_content":"用两个栈就可以了，leetcode easy题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617796013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":224395,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1591365958,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1591365958","product_id":100006701,"comment_content":"真好","like_count":1,"discussions":[{"author":{"id":2238635,"avatar":"https://static001.geekbang.org/account/avatar/00/22/28/ab/b8905658.jpg","nickname":"AsYouWish99","note":"","ucode":"A5CE38DAD56115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579271,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657273178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196609,"user_name":"ilovealt","can_delete":false,"product_type":"c1","uid":1113180,"ip_address":"","ucode":"35CB4FD836135B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fc/5c/a3d42cdb.jpg","comment_is_top":false,"comment_ctime":1585297151,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585297151","product_id":100006701,"comment_content":"这个有点吃力，不懂的很多，看来我我还是一个菜鸟啊。","like_count":0,"discussions":[{"author":{"id":2238635,"avatar":"https://static001.geekbang.org/account/avatar/00/22/28/ab/b8905658.jpg","nickname":"AsYouWish99","note":"","ucode":"A5CE38DAD56115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579272,"discussion_content":"慢慢来呗\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657273194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192199,"user_name":"今天","can_delete":false,"product_type":"c1","uid":1532354,"ip_address":"","ucode":"F8577A2BABCD1F","user_header":"https://static001.geekbang.org/account/avatar/00/17/61/c2/94c1d4c9.jpg","comment_is_top":false,"comment_ctime":1584842950,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584842950","product_id":100006701,"comment_content":"并发都有消耗，就是看如何更适合的降低","like_count":0},{"had_liked":false,"id":175346,"user_name":"Geek_8c5f9c","can_delete":false,"product_type":"c1","uid":1596047,"ip_address":"","ucode":"70CD441EAF490F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIlZ9AObDSXrfSEibY94uyQvMQ4tOvbb7iaQH9H7QQ6ibNaqFKUGq1TboaFpBSLuP0MCcSXvmqHNg0IA/132","comment_is_top":false,"comment_ctime":1580663437,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1580663437","product_id":100006701,"comment_content":"fail-fast不是同步容器的行为， fail-safe才是。","like_count":1,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159586,"discussion_content":"建议写段代码验证一下，fail-fast简单说就是：迭代过程中，如果容器发生结构变化，例如添加或删除元素，迭代会抛出ConcurrentModificationException。同步容器行为就是如此。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1580710918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2238635,"avatar":"https://static001.geekbang.org/account/avatar/00/22/28/ab/b8905658.jpg","nickname":"AsYouWish99","note":"","ucode":"A5CE38DAD56115","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579273,"discussion_content":"确实","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657273216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173333,"user_name":"Comdotwang","can_delete":false,"product_type":"c1","uid":1180791,"ip_address":"","ucode":"505C65CB8E0B92","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/77/b0dbd680.jpg","comment_is_top":false,"comment_ctime":1579506196,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579506196","product_id":100006701,"comment_content":"老师 您好。 我看到SynchronousQueue 不能缓存任何元素。 但是据我所知，SynchronousQueue take和put操作都会生成一个SNode 或 QNode。放入栈或队列中。这些不算是缓存么。 我有些疑惑。","like_count":0},{"had_liked":false,"id":168489,"user_name":"天王","can_delete":false,"product_type":"c1","uid":1239337,"ip_address":"","ucode":"C074B2F9A5F007","user_header":"https://static001.geekbang.org/account/avatar/00/12/e9/29/629d9bb0.jpg","comment_is_top":false,"comment_ctime":1578098501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578098501","product_id":100006701,"comment_content":"20 ConcurrentLinkedQueue和LinkedBlockingQueue有什么区别 1 Java.util.concurrent包下面的所有容器都叫并发容器，concurrent开头的叫并发容器，concurrent基于lock-free模式，在多线程场景，能提供较大的吞吐量 ，LinkedBlocking是基于锁，提供了BlockingQueue的等待方法 2 线程安全容器大概可以分为concurrent*，CopyOnWrite和Blocking等三类，CopyOnWrite需要拷贝一份数据，在拷贝数据上修改，开销比较大，常见的容器，有比较强的一致性，如果遍历过程发生修改，会抛出ConcurrentModificationException，而Concurrent*容器可以继续遍历。3 Blocking同步容器，需要等待，以代码为例 用BlockingQueue去实现生产者消费者，不用自己手工去实现轮询，条件判断等逻辑。","like_count":1},{"had_liked":false,"id":155015,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1574627953,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574627953","product_id":100006701,"comment_content":"并发中的一致性是有代价的，如何支付这个代价延伸出不同的实现。ConcurrentLinkedQueue 就是提供较高的吞吐率而牺牲一部分一致性的解决方案，也就是遍历的时候，数据被修改了而不查，size也没有100%正确。要获得这些保证，就要加锁牺牲吞吐量 LinkedBlockingQueue 就是这种高准确度而相对较低吞吐量的解决方案。加入其他维度例如是否无限，Java还有其他选择。","like_count":0},{"had_liked":false,"id":135871,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1569291066,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569291066","product_id":100006701,"comment_content":"文章中关于生产者消费者的示例代码运行不能体现出blocking queue的特性，因为输出语句和操作不是原子性的，所以输出顺序会有问题","like_count":0},{"had_liked":false,"id":120674,"user_name":"wengyifa","can_delete":false,"product_type":"c1","uid":1158422,"ip_address":"","ucode":"C41E3894694D2B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/5fibB9p7PfndN4kU0lhHv4TyKRsibISvaxGdI4yviao0WcDS7rmEP9vqiaMiclxrs2GQJlRcCyZxTkRibK5r4uWQQBhg/132","comment_is_top":false,"comment_ctime":1564971893,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1564971893","product_id":100006701,"comment_content":"if (c == capacity)<br>            signalNotFull();<br>有点看不懂 take 方法中最后一段的内容，为何是在实际大小等于容量时，才去唤醒添加线程，而不是实际大小小于容量就去唤醒添加线程。在源码中 put 方法也看到类似的片段。<br>if (c == 0)<br>            signalNotEmpty();<br>老师能否解下惑？","like_count":0,"discussions":[{"author":{"id":1120345,"avatar":"https://static001.geekbang.org/account/avatar/00/11/18/59/daeb0b6c.jpg","nickname":"日光倾城","note":"","ucode":"E4329963F660DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9393,"discussion_content":"这里应该是指只有临界状态变化才发出通知，比如从空变为非空，从满变成非满的临界状态变化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568164249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1113744,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","nickname":"techwro","note":"","ucode":"7AF2B319F0AE1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4257,"discussion_content":"c = count.getAndDecrement();该方法是一个无限循环，直到减1成功为止，且返回旧值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565255878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":103734,"user_name":"colin","can_delete":false,"product_type":"c1","uid":1292206,"ip_address":"","ucode":"7A8849B8AE33E0","user_header":"https://static001.geekbang.org/account/avatar/00/13/b7/ae/a25fcb73.jpg","comment_is_top":false,"comment_ctime":1560499792,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560499792","product_id":100006701,"comment_content":"SynchronousQueue是不是相当于建立了一个“虫洞”？","like_count":0},{"had_liked":false,"id":90007,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1556364222,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556364222","product_id":100006701,"comment_content":"大致思路：（后续需要手动实现）<br>一把ReentrantLock<br>两个Condition notEmpty notFull<br><br>栈为空 notEmpty.await() --- 出栈阻塞<br>栈已满 notFull.await()     --- 入栈阻塞<br><br>栈不为空也不满 出栈 入栈 不阻塞<br><br>入栈： notEmpty.signal()<br>出栈： notFull.signal() <br><br>源码很经典，谢谢老师～！  <br>喜欢这个专栏，希望以后还能看到您写的专栏～！<br><br><br>","like_count":0},{"had_liked":false,"id":37953,"user_name":"杭州","can_delete":false,"product_type":"c1","uid":1121604,"ip_address":"","ucode":"2E5E330FAB24FA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIyqjqjTlaiavQb1I7d5au4A3mojticTXgBEu6picAv3qS7f1jhdq4bSS8mJpic1zWNhxaQWNPfYkQF0w/132","comment_is_top":false,"comment_ctime":1541824861,"is_pvip":false,"replies":[{"id":"13667","content":"没有太明白问题，线程离开线程池是什么情况？“很好”是很“高”吗？很多“锁”但并没有死锁，我的理解对吗？配合top，看看占cpu的线程栈具体是什么情况吧，","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1541905605,"ip_address":"","comment_id":37953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1541824861","product_id":100006701,"comment_content":"杨老师你好，遇到个问题，200个并发线程池阻塞读linkBlockingQueue队列，偶尔会出现阻塞时会线程cpu很好。jstack看了很多lock。会不会出现线程离开线程池，去干别的任务，干了一半又回到线程池中干活。两边出现死锁？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":428538,"discussion_content":"没有太明白问题，线程离开线程池是什么情况？“很好”是很“高”吗？很多“锁”但并没有死锁，我的理解对吗？配合top，看看占cpu的线程栈具体是什么情况吧，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1541905605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":31565,"user_name":"小飞哥 ‍超級會員","can_delete":false,"product_type":"c1","uid":1110049,"ip_address":"","ucode":"417F9563B3005B","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/21/104b9565.jpg","comment_is_top":false,"comment_ctime":1539231440,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1539231440","product_id":100006701,"comment_content":"向我们这些写业务代码的应该如何使用并发类和框架？","like_count":0},{"had_liked":false,"id":23742,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1536628560,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1536628560","product_id":100006701,"comment_content":"SynchronousQueue，删除操作依赖插入操作，而插入操作又依赖删除操作，死锁了么？<br>SynchronousQueue 一般应用在啥场景呢？","like_count":0,"discussions":[{"author":{"id":1541386,"avatar":"https://static001.geekbang.org/account/avatar/00/17/85/0a/e564e572.jpg","nickname":"N_H","note":"","ucode":"109B67557AB3CE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":10289,"discussion_content":"CachedThreadPoolExecutor","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568283148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":16516,"user_name":"纯爷们","can_delete":false,"product_type":"c1","uid":1105976,"ip_address":"","ucode":"E2F81E5076C850","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/38/c7b1e502.jpg","comment_is_top":false,"comment_ctime":1531999957,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1531999957","product_id":100006701,"comment_content":"Java并发包里的东西平时基本没怎么接触，这块知识太缺乏了，看这篇文章痛苦！","like_count":0,"discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":151776,"discussion_content":"所以不太适合两年的看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579885187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13956,"user_name":"Invocker.C","can_delete":false,"product_type":"c1","uid":1002492,"ip_address":"","ucode":"0C6610D0426548","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/fc/a535ce4f.jpg","comment_is_top":false,"comment_ctime":1530083852,"is_pvip":false,"replies":[{"id":"4654","content":"不清楚你的硬件、业务特点，一个大概原则是尽量让进和出的速率一致，不然出慢，进就block，反过来也不好；实际操作上，你试试找时机检查remaincapacity，就可以判断进出速率的对比","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1530118645,"ip_address":"","comment_id":13956,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1530083852","product_id":100006701,"comment_content":"求老师解答一个困扰已久的问题，就是初始化arrayblockingqueue的时候，capacity的大小如何评估和设置？望解答","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419822,"discussion_content":"不清楚你的硬件、业务特点，一个大概原则是尽量让进和出的速率一致，不然出慢，进就block，反过来也不好；实际操作上，你试试找时机检查remaincapacity，就可以判断进出速率的对比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1530118645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006922,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5d/4a/4b0d9ebc.jpg","nickname":"西伯利亚鼯鼠","note":"","ucode":"311ADB023935E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382998,"discussion_content":"我觉得队列容量，应该考虑对应抵消【消费者处理速率的抖动极限时长】和【生产者被阻塞的超时时长】。容量太大，可能导致后进的message必然被超时；太小则导致没能给到消费侧足够的buffer，阻塞了生产者，影响吞吐。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625818762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":13354,"user_name":"夏洛克的救赎","can_delete":false,"product_type":"c1","uid":1021334,"ip_address":"","ucode":"44453DD27A3216","user_header":"https://static001.geekbang.org/account/avatar/00/0f/95/96/0020bd67.jpg","comment_is_top":false,"comment_ctime":1529550501,"is_pvip":false,"replies":[{"id":"4503","content":"编码，区分拉丁和非拉丁语系","user_name":"作者回复","user_name_real":"杨晓峰","uid":"1009360","ctime":1529627663,"ip_address":"","comment_id":13354,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1529550501","product_id":100006701,"comment_content":"老师你好，问个题外问题，在jdk10源码  string类中，成员变量coder起到什么作用？如何理解？","like_count":0,"discussions":[{"author":{"id":1009360,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/66/d0/6541f1d5.jpg","nickname":"杨晓峰","note":"","ucode":"2BF255467A978F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":419621,"discussion_content":"编码，区分拉丁和非拉丁语系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1529627663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}