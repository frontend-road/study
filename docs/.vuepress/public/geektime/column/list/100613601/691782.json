{"id":691782,"title":"05｜机器与语言：JVM 中的字节码","content":"<p>你好，我是康杨。今天我们来聊聊JVM的语言——字节码。</p><p>在前面的介绍中，我们提到过Java语言的平台无关性，这也是Java能够快速崛起的原因之一。我们只需要用Java语言完成业务逻辑的开发，JVM就会帮助我们完成在物理服务器上的运行，而不用去关心底层硬件平台的差异性，能够达成这种效果的关键角色就是字节码。</p><p>借助字节码，JVM屏蔽了上层编程语言（Java、Scala ）和下层硬件平台的多样性。而JVM被认为是字节码的运行时。</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/c8/3b1c14f56ed0784ba781dc5894963dc8.png?wh=1920x595\" alt=\"图片\"></p><h2>字节码是什么?</h2><p>Java源代码经过编译器编译后，就会生成JVM字节码，它是Java程序在JVM上执行的中间表示形式。JVM字节码是一种基于栈的指令集架构（Stack-based Instruction Set Architecture）。每个字节码指令都会在JVM上执行一系列的操作，如加载、存储、运算、跳转等。</p><p>它使用基于操作数栈和局部变量表的执行模型。具有以下特点：</p><ul>\n<li>独立于具体的硬件和操作系统，不同平台上的JVM可以解释和执行相同的字节码文件。</li>\n<li>相对于机器码和源代码，JVM字节码是一种更高级别的抽象，并且比机器码更容易阅读和编写（理解）。</li>\n<li>JVM字节码通过运行时的即时编译器或解释器执行。</li>\n</ul><!-- [[[read_end]]] --><p>JVM字节码使Java语言具备了跨平台的能力，只需编写一次Java程序，然后在不同平台上安装相应的JVM，就能在这些平台上运行相同的字节码。这种特性为Java程序提供了很高的可移植性和兼容性。值得注意的是，其他编程语言也可以编译成JVM字节码，利用JVM的优势。这些编程语言叫做基于JVM的语言，例如Kotlin、Groovy等。</p><p>这些语言的代码编译后也会生成和Java程序相同的JVM字节码。</p><h2>获取字节码</h2><p>接下来，让我们看一下字节码到底长什么样。我们先编写一个简单的Java类作为示例，创建一个名为 <code>HelloWorld</code> 的Java文件，将以下代码添加到文件里。</p><pre><code class=\"language-java\">public class HelloWorld {\n&nbsp;&nbsp;&nbsp; public static void main(String[] args) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(\"Hello, World!\");\n&nbsp;&nbsp;&nbsp; }\n}\n</code></pre><p>接下来，编译Java源代码。使用Java编译器把Java源代码编译成字节码文件。在命令行中执行 <code>javac HelloWorld.java</code> 命令，会生成一个名叫 HelloWorld.class 的字节码文件。</p><h2>查看字节码文件</h2><p>我们使用Java反编译工具，如 <code>javap</code>，来查看字节码文件的内容。在命令行中执行 <code>javap -c HelloWorld</code> 命令，会显示 HelloWorld 类的字节码内容，包括方法和指令。</p><pre><code class=\"language-java\">public class HelloWorld {\n&nbsp; public HelloWorld();&nbsp; // 构造函数\n&nbsp;&nbsp;&nbsp; Code:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0: aload_0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 将局部变量表中的this加载到操作数栈上\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1: invokespecial #1 // 调用java/lang/Object类的构造函数\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4: return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 返回\n&nbsp; public static void main(java.lang.String[]);&nbsp; // 主方法\n&nbsp;&nbsp;&nbsp; Code:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0: getstatic &nbsp;&nbsp;&nbsp; #2 // 获取java/lang/System.out的静态字段\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3: ldc &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #3 // 加载字符串\"Hello, World!\"到操作数栈上\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5: invokevirtual #4 // 调用java/io/PrintStream类的println方法\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8: return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 返回\n}\n</code></pre><p>在上述示例中，你可以看到 <code>HelloWorld</code> 类的构造函数和 <code>main</code> 方法的字节码。每个方法都以 <code>Code:</code> 开头，后面就是一系列的指令。</p><h2>字节码指令集</h2><p>这些字节码指令都会在JVM上执行一系列的操作，如加载、存储、运算、跳转等。下面我们就一一来看下这些指令。</p><h3>栈操作指令</h3><p>操作数栈是 JVM 中的一个临时数据存储区域，用来存储局部变量和中间计算结果。栈操作指令主要负责操作这个操作数栈，包括push、pop、swap、dup等。</p><p>不过为了提高代码的性能，我们应该尽量减少对栈的操作，因为每次压入或弹出栈帧都需要消耗一定的时间和空间。而且在编写字节码的时候，要确保操作数栈的深度没有超过类文件的最大栈深度，否则将会抛出StackOverflowError异常，这个异常表示操作数栈溢出。</p><h3>加载和存储指令</h3><p>加载和存储指令用来在操作数栈和局部变量表之间传递数据。加载指令把数据从局部变量表加载到操作数栈，而存储指令则将操作数栈顶的数据存储到局部变量表。</p><p>在操作局部变量的时候，尽量使用索引为0～3的变量，这样可以使用更紧凑的字节码指令，如 iload_0、iload_1 等。</p><h3>数学指令</h3><p>数学指令主要用于执行基本的算术运算，加、减、乘、除、模等，可以根据操作数的类型，比如int、long、float、double等，选择相应的数学指令，避免在循环中进行重复计算，尽量把计算结果缓存起来以提高性能。</p><h3>类型转换指令</h3><p>类型转换指令用来把一种数值类型转换成另一种类型。比如，使用 i2f 指令把 int 类型转换成 float 类型。只在确实需要的时候执行类型转换，并尽量减少不必要的类型转换操作，以避免性能损失。</p><h3>对象和数组操作指令</h3><p>对象和数组操作指令涉及对象和数组的创建、访问和更新。这些指令包括 new、getfield、putfield、getstatic、putstatic 等。 编写代码的时候要遵守封装原则，保护对象的状态和行为，避免直接访问对象的成员变量。使用数组时，确保数组索引在有效范围内，以避免数组访问异常。</p><h3>控制转移指令</h3><p>控制转移指令用于更改程序的执行顺序。根据不同的条件，可以选择相应的指令，例如 ifeq、ifgt、goto、tableswitch 等。 在条件分支较多的情况下，尽量使用 tableswitch 或 lookupswitch 指令。使用简洁的控制语句，减少嵌套的深度。</p><h3>方法调用和返回指令</h3><p>方法调用和返回指令处理方法的调用和返回过程。这些指令包括 invokevirtual、invokespecial、invokestatic、invokeinterface、invokedynamic、return等。减少没有意义的方法调用，例如不必要的 getter 和 setter。对于已知目标方法的调用，尽量使用 invokevirtual 和 invokestatic，而不是 invokeinterface。</p><h3>异常处理指令</h3><p>异常处理指令用来创建、抛出和处理异常。这些指令包括 athrow、catch等。 尽量减少异常抛出，通过合理的检查和处理避免异常出现。对于已知的异常情况，尽量使用正常的控制流程进行处理，而不是依赖异常。</p><h2>字节码是如何执行的？</h2><p>在Java开发中，理解JVM如何执行字节码对于性能优化、问题排查具有重要意义。下面我将通过一个包含乘法和除法运算的简单Java程序，深入解析JVM是如何执行字节码的，还有字节码运算的最佳实践、需要注意的点、可以优化的点，以及在现实环境中的应用实例。</p><p>示例代码如下：</p><pre><code class=\"language-java\">public class Calculator {\n&nbsp; &nbsp; public static void main(String[] args) {\n&nbsp; &nbsp; &nbsp; &nbsp; int a = 6;\n&nbsp; &nbsp; &nbsp; &nbsp; int b = 2;\n&nbsp; &nbsp; &nbsp; &nbsp; int multiply = a * b;\n&nbsp; &nbsp; &nbsp; &nbsp; int divide = a / b;\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"The result of multiplication is: \" + multiply);\n&nbsp; &nbsp; &nbsp; &nbsp; System.out.println(\"The result of division is: \" + divide);\n&nbsp; &nbsp; }\n}\n</code></pre><p>在这段示例代码中，我定义了两个整型变量a和b，进行了一次乘法运算和一次除法运算，然后输出了结果。接下来我们详细了解一下JVM是怎么执行乘法和除法运算的字节码的。</p><p>首先，使用 <code>javap -c Calculator</code> 命令获取字节码。</p><pre><code class=\"language-java\">public static void main(java.lang.String[]);\n&nbsp; &nbsp; Code:\n&nbsp;&nbsp; &nbsp; &nbsp; 0: bipush&nbsp; &nbsp; &nbsp; &nbsp; 6\n&nbsp;&nbsp; &nbsp; &nbsp; 2: istore_1\n&nbsp;&nbsp; &nbsp; &nbsp; 3: iconst_2\n&nbsp;&nbsp; &nbsp; &nbsp; 4: istore_2\n&nbsp;&nbsp; &nbsp; &nbsp; 5: iload_1\n&nbsp;&nbsp; &nbsp; &nbsp; 6: iload_2\n&nbsp;&nbsp; &nbsp; &nbsp; 7: imul\n&nbsp;&nbsp; &nbsp; &nbsp; 8: istore_3\n&nbsp;&nbsp; &nbsp; &nbsp; 9: iload_1\n&nbsp; &nbsp; &nbsp; 10: iload_2\n&nbsp; &nbsp; &nbsp; 11: idiv\n&nbsp; &nbsp; &nbsp; 12: istore 4\n&nbsp; &nbsp; &nbsp; 14: getstatic &nbsp; &nbsp; #2\n&nbsp; &nbsp; &nbsp; 17: new &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #3\n&nbsp; &nbsp; &nbsp; 20: dup\n&nbsp; &nbsp; &nbsp; 21: invokespecial #4\n&nbsp; &nbsp; &nbsp; 24: ldc &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; #5\n&nbsp; &nbsp; &nbsp; 26: invokevirtual #6\n&nbsp; &nbsp; &nbsp; 29: invokevirtual #7\n&nbsp; &nbsp; &nbsp; 32: return\n</code></pre><p>我们来解析一下这些字节码。</p><ul>\n<li>0、2：<code>bipush 6</code> 和 <code>iconst_2</code>，把常数6和2分别压入操作数栈， <code>istore_1</code> 和 <code>istore_2</code> 把这两个常数存储到本地变量表对应的索引位置1和2里，相当于执行代码 <code>int a = 6; int b = 2</code>。</li>\n<li>5、6、7： <code>iload_1</code> 和 <code>iload_2</code> 将本地变量表中的变量a和b加载到操作数栈，<code>imul</code> 操作符执行栈顶两个元素的乘法，<code>istore_3</code> 将乘法结果存储到本地变量表索引3的位置，相当于执行代码 <code>int multiply = a * b</code>。</li>\n<li>9、10、11：与乘法操作类似，执行除法后，用 <code>istore 4</code> 将结果存储到本地变量表索引4位置，相当于执行代码 <code>int divide = a / b</code>。</li>\n<li>14-32：获取可打印输出的对象，输出乘除运算结果。</li>\n</ul><h3>需要注意的点</h3><p>写Java代码的时候要避免用大数做除法，比如Integer自动拆装箱导致的NPE问题，在进行除法运算时务必做除数为0的判断。</p><h3>优化点</h3><p>采用乘以反数的方式替代除法计算可以提高运算效率，例如 <code>a / 2</code> 可以优化为 <code>a * 0.5</code>。我们对于Java代码需要有深度的理解，更好地利用JVM字节码能够帮助我们快速排查问题，优化程序的性能。像Spring、MyBatis等框架底层也大量使用字节码生成技术来提高代码执行效率。</p><h2>如何优化字节码？</h2><p>假设我们需要操作一个大的字符串数组，可能会使用下面的模式。</p><pre><code class=\"language-java\">public class StringProcessor {\n&nbsp; &nbsp; public static void main(String[] args) {&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; String[] words = {\"big str\" ,\"big str \"} ; //大字符串数组\n&nbsp; &nbsp; &nbsp; &nbsp; for (String word : words) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (word != null &amp;&amp; !word.isEmpty()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(word.toUpperCase());\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>这种写法的问题在于当数组非常大，而且元素有很多为空或为空串的时候，可能会有性能问题。原因是它仍需要遍历每个单词，检查是否为空或空字符串，这是不必要的，我们可以通过JVM字节码动态生成一个新的字符串数组，把空的和空字符串剔除再进行操作。</p><pre><code class=\"language-java\">import java.lang.reflect.*;\nimport java.util.*;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\npublic class OptimizedStringProcessor {\n&nbsp; &nbsp; public static void main(String[] args) {\n&nbsp; &nbsp; &nbsp; &nbsp; List&lt;String&gt; words = Stream.of(\"big str\").collect(Collectors.toList()); //\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&lt;String&gt; filteredWords = (List&lt;String&gt;) Proxy.newProxyInstance(words.getClass().getClassLoader(), new Class[]{List.class}, (proxy, method, methodArgs) -&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (method.getName().equals(\"get\")) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String word = (String) method.invoke(words, methodArgs);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (word == null || word.isEmpty()) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return null;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return word.toUpperCase();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return method.invoke(words, methodArgs);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; for (String word : filteredWords) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (word != null) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println(word);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><p>使用这种方式，原始的字符串数组会先经过动态代理的处理，也就是利用动态代理生成类的字节码，重新定义获取元素的方法，剔除空元素，将非空元素转为大写，大大提升了性能，还能使代码更加整洁。在实际项目中，特别是大数据处理场景，了解并恰当应用字节码技术可以带来巨大的性能优势。</p><h2>重点回顾</h2><p>JVM字节码是JVM可直接执行的机器码形式，它是Java源码编译而来的，其实就是一个字节序列。因为它屏蔽了上层编程语言和下层硬件平台的差异性，所以Java语言借助它拥有了跨平台的能力。此外它使用操作数栈和局部变量表的执行模型，使Java具有了很高的可移植性和兼容性。除了Java，其他基于JVM的语言也可以编译为JVM字节码。</p><p>了解并恰当应用字节码技术可以优化性能，提升代码的简洁性。最佳实践包括减少栈操作、合理使用加载和存储指令、避免重复计算、减少类型转换、封装原则、控制转移的简洁性、减少不必要的方法调用和异常处理。在实际项目中，了解JVM如何执行字节码对于性能优化和问题排查具有重要意义。</p><h2>思考题</h2><p>如何利用字节码进行程序优化？请把你的想法分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p><h2>💡 点亮你的知识框架图</h2><p><img src=\"https://static001.geekbang.org/resource/image/a8/bd/a80736e1ac925314c1965aa6e69b0ebd.jpg?wh=6093x4342\" alt=\"\"></p>","neighbors":{"left":{"article_title":"04｜从JIT到AOT：JVM编译器的云原生演进之路","id":690327},"right":{"article_title":"06｜类加载子系统 （上）：类加载的流程与机制","id":692897}},"comments":[{"had_liked":false,"id":380355,"user_name":"浩仔是程序员","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"广东","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1693409089,"is_pvip":false,"replies":[{"id":139125,"content":"比如那些部分没有看明白呢","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1696512966,"ip_address":"北京","comment_id":380355,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"那个例子有点看不懂","like_count":6,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629005,"discussion_content":"比如那些部分没有看明白呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696512966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1444698,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0b/5a/453ad411.jpg","nickname":"C.","note":"","ucode":"5AE269220EFD73","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627298,"discussion_content":"判断的是List的get方法,把下面的for循环改为filteredWords.get(0)就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693980220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380354,"user_name":"临风","can_delete":false,"product_type":"c1","uid":1145430,"ip_address":"广东","ucode":"59A7F3DDD94D76","user_header":"https://static001.geekbang.org/account/avatar/00/11/7a/56/29877cb9.jpg","comment_is_top":false,"comment_ctime":1693408331,"is_pvip":true,"replies":[{"id":139152,"content":"\n动态代理生成的List比原来的性能更好，其主要原因在于动态代理可以在运行时生成代理对象，并动态地决定何时、如何和哪些方法去执行，避免了不必要的逻辑判断。\n比如我们在代理get方法时，本来需要检测参数是否为null，代理后我们可以预先设定null无效化，并在代理代码中直接跳过这个逻辑，避免进行null判断，这样就可以提升执行效率。\n至于字节码应用的例子，你的理解完全正确。像SkyWalking这样的性能监控工具就是通过字节码注入技术，将追踪代码注入到目标方法中，从而获取方法的调用链路、调用时长等信息。具体到SkyWalking，其实使用此种技术主要是为了完成对分布式链路追踪的功能。","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1696592017,"ip_address":"北京","comment_id":380354,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"老师，有个地方不太理解，为什么通过动态代理生成的List就比原来的性能更好，代理get方法后，不是也要执行判空逻辑吗？\n\n对于字节码的应用，我想到的一个是性能监控，大概了解了一下，像skywalking就是通过注入字节码，将trace ID保存到threadLocal中去，并在调用其他接口时设置到header中去，由此完成了链路跟踪的功能。\n\n","like_count":1,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629056,"discussion_content":"\n动态代理生成的List比原来的性能更好，其主要原因在于动态代理可以在运行时生成代理对象，并动态地决定何时、如何和哪些方法去执行，避免了不必要的逻辑判断。\n比如我们在代理get方法时，本来需要检测参数是否为null，代理后我们可以预先设定null无效化，并在代理代码中直接跳过这个逻辑，避免进行null判断，这样就可以提升执行效率。\n至于字节码应用的例子，你的理解完全正确。像SkyWalking这样的性能监控工具就是通过字节码注入技术，将追踪代码注入到目标方法中，从而获取方法的调用链路、调用时长等信息。具体到SkyWalking，其实使用此种技术主要是为了完成对分布式链路追踪的功能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696592017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1182516,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0b/34/f41d73a4.jpg","nickname":"王盛武","note":"","ucode":"DE7EF246D3DCE8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":630171,"discussion_content":"动态代理那段代码 看上去也有null判断和isempty判断， 哪里节省了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698147995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":629056,"ip_address":"广东","group_id":0},"score":630171,"extra":""}]},{"author":{"id":1051938,"avatar":"https://static001.geekbang.org/account/avatar/00/10/0d/22/fe6b9642.jpg","nickname":"twang","note":"","ucode":"44B8325E6DF106","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635736,"discussion_content":"有谁搞清楚了吗，希望分享一下。\n我觉得这个例子可能错了，我理解使用代理相比原来开销只多不少，不可能更快。\n例子中也有一个错误，for-each 循环使用的是 iterator，没有调用 get，所以代理中的代码没有执行，这么确实更快，但也没有转成大写。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705073338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380828,"user_name":"Geek_f46b9e","can_delete":false,"product_type":"c1","uid":3705971,"ip_address":"广东","ucode":"DD89BC5C720209","user_header":"","comment_is_top":false,"comment_ctime":1694249502,"is_pvip":false,"replies":[{"id":139128,"content":"这是因为在硬件或底层软件中实现除法运算，需要进行更复杂的算法和数学计算。因此，如果有可能，程序员倾向于使用其他方式（如乘法或位运算）来避免除法运算，以提高程序的运行效率","user_name":"作者回复","user_name_real":"编辑","uid":1366588,"ctime":1696514327,"ip_address":"北京","comment_id":380828,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"为什么  采用乘以反数的方式替代除法计算可以提高运算效率呢","like_count":0,"discussions":[{"author":{"id":1366588,"avatar":"https://static001.geekbang.org/account/avatar/00/14/da/3c/6ca50139.jpg","nickname":"Arthur king 微信超級會員","note":"","ucode":"79637F55F0ED85","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629009,"discussion_content":"这是因为在硬件或底层软件中实现除法运算，需要进行更复杂的算法和数学计算。因此，如果有可能，程序员倾向于使用其他方式（如乘法或位运算）来避免除法运算，以提高程序的运行效率","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696514328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380957,"user_name":"非洲黑猴子","can_delete":false,"product_type":"c1","uid":2639724,"ip_address":"美国","ucode":"F5FEAC07D562E0","user_header":"https://static001.geekbang.org/account/avatar/00/28/47/6c/78184d19.jpg","comment_is_top":false,"comment_ctime":1694507490,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":1,"score":2,"product_id":100613601,"comment_content":"最后这个例子不太明白, OptimizedStringProcessor怎么就快了? 谢谢","like_count":2},{"had_liked":false,"id":388236,"user_name":"JavaBit","can_delete":false,"product_type":"c1","uid":1185496,"ip_address":"上海","ucode":"9A03A5400C5B1E","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/d8/f15be64d.jpg","comment_is_top":false,"comment_ctime":1709691167,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"OptimizedStringProcessor这个例子出错了吧，我测试了下没有调用get方法，使用的是iterator的方法，字符串并没有变成大写。\n\n另外，这个例子哪里可以体现性能的优化呢，有没有大批量的数据验证呢","like_count":1},{"had_liked":false,"id":380347,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1693404076,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"请教老师几个问题：\nQ1：“利用动态代理生成类的字节码”，这句话不太理解：文中是Java代码啊，什么时候生成字节码？类编译后就是字节码，还需要二次生成字节码？\nQ2：#后面跟一个数字，比如#2表示什么意思？\nQ3：在进行底层运算之前，JVM进行了自己的字节码运算，是吗？\n如果是这样，相当于有两次运算，首先在JVM中进行了字节码级别的运算，然后交给系统CPU进行第二次运算，是吗？（我原来一直认为是把字节码翻译为机器码，然后运行）","like_count":1}]}