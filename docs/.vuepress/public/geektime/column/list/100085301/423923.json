{"id":423923,"title":"17｜数据结构：软件系统核心部件哈希表，内存如何布局？","content":"<p>你好，我是陈天。</p><p>上一讲我们深入学习了切片，对比了数组、列表、字符串和它们的切片以及切片引用的关系。今天就继续讲 Rust 里另一个非常重要的集合容器：HashMap，也就是哈希表。</p><p>如果谈论软件开发中最重要、出镜率最高的数据结构，那哈希表一定位列其中。很多编程语言甚至将哈希表作为一种内置的数据结构，做进了语言的核心。比如 PHP 的关联数组（associate array）、Python 的字典（dict）、JavaScript 的对象（object）和 Map。</p><p>Google 的工程师Matt Kulukundis 在 <a href=\"https://youtu.be/ncHmEUmJZf4?t=210\">cppCon 2017</a> 做的一个演讲，说：全世界 Google 的服务器上 1% 的 CPU 时间用来做哈希表的计算，超过 4% 的内存用来存储哈希表。足以证明哈希表的重要性。</p><p>我们知道，哈希表和列表类似，都用于处理需要随机访问的数据结构。如果数据结构的输入和输出能一一对应，那么可以使用列表，如果无法一一对应，那么就需要使用哈希表。<br>\n<img src=\"https://static001.geekbang.org/resource/image/4e/83/4e0c043a82e29886cd7b8e1dd79a5183.jpg?wh=2364x1304\" alt=\"\"></p><h2>Rust 的哈希表</h2><p>那 Rust 为我们提供了什么样的哈希表呢？它长什么样？性能如何？我们从官方文档学起。</p><p>如果你打开 <a href=\"https://doc.rust-lang.org/std/collections/struct.HashMap.html\">HashMap</a> 的文档，会看到这样一句话：</p><blockquote>\n<p>A hash map implemented with <strong>quadratic probing</strong> and <strong>SIMD lookup</strong>.</p>\n</blockquote><!-- [[[read_end]]] --><p>这一看就有点肾上腺素上升了，出现了两个高端词汇：二次探查（quadratic probing）和 SIMD 查表（SIMD lookup），都是什么意思？它们是Rust哈希表算法的设计核心，我们今天的学习也会围绕着这两个词展开，所以别着急，等学完相信你会理解这句话的。</p><p>先把基础理论扫一遍。哈希表最核心的特点就是：<strong>巨量的可能输入和有限的哈希表容量。</strong>这就会引发哈希冲突，也就是两个或者多个输入的哈希被映射到了同一个位置，所以我们要能够处理哈希冲突。</p><p>要解决冲突，首先可以通过更好的、分布更均匀的哈希函数，以及使用更大的哈希表来缓解冲突，但无法完全解决，所以我们还需要使用冲突解决机制。</p><h3>如何解决冲突？</h3><p>理论上，主要的冲突解决机制有链地址法（chaining）和开放寻址法（open addressing）。</p><p>链地址法，我们比较熟悉，就是把落在同一个哈希上的数据用单链表或者双链表连接起来。这样在查找的时候，先找到对应的哈希桶（hash bucket），然后再在冲突链上挨个比较，直到找到匹配的项：<img src=\"https://static001.geekbang.org/resource/image/a3/5d/a3334e4a3259e0bd231815a486b7c45d.jpg?wh=2364x1610\" alt=\"\"></p><p>冲突链处理哈希冲突非常直观，很容易理解和撰写代码，但缺点是哈希表和冲突链使用了不同的内存，对缓存不友好。</p><p>开放寻址法把整个哈希表看做一个大数组，不引入额外的内存，当冲突产生时，按照一定的规则把数据插入到其它空闲的位置。比如线性探寻（linear probing）在出现哈希冲突时，不断往后探寻，直到找到空闲的位置插入。</p><p>而<strong>二次探查</strong>，理论上是在冲突发生时，不断探寻哈希位置加减 n 的二次方，找到空闲的位置插入，我们看图，更容易理解：<br>\n<img src=\"https://static001.geekbang.org/resource/image/42/4e/42a18970ac2eec7510c69c1f8323bc4e.jpg?wh=2364x1304\" alt=\"\">（图中示意是理论上的处理方法，实际为了性能会有很多不同的处理。）</p><p>开放寻址还有其它方案，比如二次哈希什么的，今天就不详细介绍了。</p><p>好，搞明白哈希表的二次探查的理论知识，我们可以推测，Rust 哈希表不是用冲突链来解决哈希冲突，而是用开放寻址法的二次探查来解决的。当然，后面会讲到 Rust 的二次探查和理论的处理方式有些差别。</p><p>而另一个关键词，使用 SIMD 做单指令多数据的查表，也和一会要讲到 Rust 哈希表巧妙的内存布局息息相关。</p><h3>HashMap 的数据结构</h3><p>进入正题，我们来看看 Rust 哈希表的数据结构是什么样子的，打开标准库的 <a href=\"https://doc.rust-lang.org/src/std/collections/hash/map.rs.html#206-208\">源代码</a>：</p><pre><code class=\"language-rust\">use hashbrown::hash_map as base;\n\n#[derive(Clone)]\npub struct RandomState {\n    k0: u64,\n    k1: u64,\n}\n\npub struct HashMap&lt;K, V, S = RandomState&gt; {\n    base: base::HashMap&lt;K, V, S&gt;,\n}\n</code></pre><p>可以看到，HashMap 有三个泛型参数，K 和 V 代表 key / value 的类型，S 是哈希算法的状态，它默认是 RandomState，占两个 u64。RandomState 使用 SipHash 作为缺省的哈希算法，它是一个加密安全的哈希函数（cryptographically secure hashing）。</p><p>从定义中还能看到，Rust 的 HashMap 复用了 hashbrown 的 HashMap。hashbrown 是 Rust 下对 <a href=\"https://abseil.io/blog/20180927-swisstables\">Google Swiss Table</a> 的一个改进版实现，我们打开 hashbrown 的代码，看它的<a href=\"https://docs.rs/hashbrown/0.11.2/src/hashbrown/map.rs.html#192-195\">结构</a>：</p><pre><code class=\"language-rust\">pub struct HashMap&lt;K, V, S = DefaultHashBuilder, A: Allocator + Clone = Global&gt; {\n    pub(crate) hash_builder: S,\n    pub(crate) table: RawTable&lt;(K, V), A&gt;,\n}\n</code></pre><p>可以看到，HashMap 里有两个域，一个是 hash_builder，类型是刚才我们提到的标准库使用的 RandomState，还有一个是具体的 RawTable：</p><pre><code class=\"language-rust\">pub struct RawTable&lt;T, A: Allocator + Clone = Global&gt; {\n    table: RawTableInner&lt;A&gt;,\n    // Tell dropck that we own instances of T.\n    marker: PhantomData&lt;T&gt;,\n}\n\nstruct RawTableInner&lt;A&gt; {\n    // Mask to get an index from a hash value. The value is one less than the\n    // number of buckets in the table.\n    bucket_mask: usize,\n\n    // [Padding], T1, T2, ..., Tlast, C1, C2, ...\n    //                                ^ points here\n    ctrl: NonNull&lt;u8&gt;,\n\n    // Number of elements that can be inserted before we need to grow the table\n    growth_left: usize,\n\n    // Number of elements in the table, only really used by len()\n    items: usize,\n\n    alloc: A,\n}\n</code></pre><p>RawTable 中，实际上有意义的数据结构是 RawTableInner，前四个字段很重要，我们一会讲HashMap的内存布局会再提到：</p><ul>\n<li>usize 的 bucket_mask，是哈希表中哈希桶的数量减一；</li>\n<li>名字叫 ctrl 的指针，它指向哈希表堆内存末端的 ctrl 区；</li>\n<li>usize 的字段 growth_left，指哈希表在下次自动增长前还能存储多少数据；</li>\n<li>usize 的 items，表明哈希表现在有多少数据。</li>\n</ul><p>这里最后的 alloc 字段，和 RawTable 的 marker 一样，只是一个用来占位的类型，我们现在只需知道，它用来分配在堆上的内存。</p><h3>HashMap 的基本使用方法</h3><p>数据结构搞清楚，我们再看具体使用方法。Rust 哈希表的使用很简单，它提供了一系列很方便的方法，使用起来和其它语言非常类似，你只要看看<a href=\"https://doc.rust-lang.org/std/collections/struct.HashMap.html\">文档</a>，就很容易理解。我们来写段代码，尝试一下（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a0543e873c9b6ecb49f56755493dc968\">代码</a>）：</p><pre><code class=\"language-rust\">use std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    explain(\"empty\", &amp;map);\n\n    map.insert('a', 1);\n    explain(\"added 1\", &amp;map);\n\n    map.insert('b', 2);\n    map.insert('c', 3);\n    explain(\"added 3\", &amp;map);\n\n    map.insert('d', 4);\n    explain(\"added 4\", &amp;map);\n\n    // get 时需要使用引用，并且也返回引用\n    assert_eq!(map.get(&amp;'a'), Some(&amp;1));\n    assert_eq!(map.get_key_value(&amp;'b'), Some((&amp;'b', &amp;2)));\n\n    map.remove(&amp;'a');\n    // 删除后就找不到了\n    assert_eq!(map.contains_key(&amp;'a'), false);\n    assert_eq!(map.get(&amp;'a'), None);\n    explain(\"removed\", &amp;map);\n    // shrink 后哈希表变小\n    map.shrink_to_fit();\n    explain(\"shrinked\", &amp;map);\n}\n\nfn explain&lt;K, V&gt;(name: &amp;str, map: &amp;HashMap&lt;K, V&gt;) {\n    println!(\"{}: len: {}, cap: {}\", name, map.len(), map.capacity());\n}\n</code></pre><p>运行这段代码，我们可以看到这样的输出：</p><pre><code class=\"language-rust\">empty: len: 0, cap: 0\nadded 1: len: 1, cap: 3\nadded 3: len: 3, cap: 3\nadded 4: len: 4, cap: 7\nremoved: len: 3, cap: 7\nshrinked: len: 3, cap: 3\n</code></pre><p>可以看到，当 HashMap::new() 时，它并没有分配空间，容量为零，<strong>随着哈希表不断插入数据，它会以 2的幂减一的方式增长</strong>，最小是 3。当删除表中的数据时，原有的表大小不变，只有显式地调用 shrink_to_fit，才会让哈希表变小。</p><h2>HashMap 的内存布局</h2><p>但是通过 HashMap 的公开接口，我们无法看到 HashMap 在内存中是如何布局的，还是需要借助之前使用过的 std::mem::transmute 方法，来把数据结构打出来。我们把刚才的代码改一改（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=40a71cd4e349369e7255f173578ec9ae\">代码</a>）：</p><pre><code class=\"language-rust\">use std::collections::HashMap;\n\nfn main() {\n    let map = HashMap::new();\n    let mut map = explain(\"empty\", map);\n\n    map.insert('a', 1);\n    let mut map = explain(\"added 1\", map);\n    map.insert('b', 2);\n    map.insert('c', 3);\n\n    let mut map = explain(\"added 3\", map);\n\n    map.insert('d', 4);\n\n    let mut map = explain(\"added 4\", map);\n\n    map.remove(&amp;'a');\n\n    explain(\"final\", map);\n}\n\n// HashMap 结构有两个 u64 的 RandomState，然后是四个 usize，\n// 分别是 bucket_mask, ctrl, growth_left 和 items\n// 我们 transmute 打印之后，再 transmute 回去\nfn explain&lt;K, V&gt;(name: &amp;str, map: HashMap&lt;K, V&gt;) -&gt; HashMap&lt;K, V&gt; {\n    let arr: [usize; 6] = unsafe { std::mem::transmute(map) };\n    println!(\n        \"{}: bucket_mask 0x{:x}, ctrl 0x{:x}, growth_left: {}, items: {}\",\n        name, arr[2], arr[3], arr[4], arr[5]\n    );\n    unsafe { std::mem::transmute(arr) }\n}\n</code></pre><p>运行之后，可以看到：</p><pre><code class=\"language-rust\">empty: bucket_mask 0x0, ctrl 0x1056df820, growth_left: 0, items: 0\nadded 1: bucket_mask 0x3, ctrl 0x7fa0d1405e30, growth_left: 2, items: 1\nadded 3: bucket_mask 0x3, ctrl 0x7fa0d1405e30, growth_left: 0, items: 3\nadded 4: bucket_mask 0x7, ctrl 0x7fa0d1405e90, growth_left: 3, items: 4\nfinal: bucket_mask 0x7, ctrl 0x7fa0d1405e90, growth_left: 4, items: 3\n</code></pre><p>有意思，我们发现在运行的过程中，ctrl 对应的堆地址发生了改变。</p><p>在我的 OS X 下，一开始哈希表为空，ctrl 地址看上去是一个 TEXT/RODATA 段的地址，应该是指向了一个默认的空表地址；插入第一个数据后，哈希表分配了 4 个 bucket，ctrl 地址发生改变；在插入三个数据后，growth_left 为零，再插入时，哈希表重新分配，ctrl 地址继续改变。</p><p>刚才在探索 HashMap 数据结构时，说过 ctrl 是一个指向哈希表堆地址末端 ctrl 区的地址，所以我们可以通过这个地址，计算出哈希表堆地址的起始地址。</p><p>因为哈希表有 8 个 bucket（0x7 + 1），每个 bucket 大小是 key（char） + value（i32） 的大小，也就是 8 个字节，所以一共是 64 个字节。对于这个例子，<strong>通过 ctrl 地址减去 64，就可以得到哈希表的堆内存起始地址</strong>。然后，我们可以用 rust-gdb / rust-lldb 来打印这个内存（如果你对 rust-gdb / rust-lldb 感兴趣，可以看文末的参考阅读）。</p><p>这里我用 Linux 下的 rust-gdb 设置断点，依次查看哈希表有一个、三个、四个值，以及删除一个值的状态：</p><pre><code class=\"language-rust\">❯ rust-gdb ~/.target/debug/hashmap2\nGNU gdb (Ubuntu 9.2-0ubuntu2) 9.2\n...\n(gdb) b hashmap2.rs:32\nBreakpoint 1 at 0xa43e: file src/hashmap2.rs, line 32.\n(gdb) r\nStarting program: /home/tchen/.target/debug/hashmap2\n...\n# 最初的状态，哈希表为空\nempty: bucket_mask 0x0, ctrl 0x555555597be0, growth_left: 0, items: 0\n\nBreakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32\n32\t    unsafe { std::mem::transmute(arr) }\n(gdb) c\nContinuing.\n# 插入了一个元素后，bucket 有 4 个（0x3+1），堆地址起始位置 0x5555555a7af0 - 4*8(0x20)\nadded 1: bucket_mask 0x3, ctrl 0x5555555a7af0, growth_left: 2, items: 1\n\nBreakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32\n32\t    unsafe { std::mem::transmute(arr) }\n(gdb) x /12x 0x5555555a7ad0\n0x5555555a7ad0:\t0x00000061\t0x00000001\t0x00000000\t0x00000000\n0x5555555a7ae0:\t0x00000000\t0x00000000\t0x00000000\t0x00000000\n0x5555555a7af0:\t0x0affffff\t0xffffffff\t0xffffffff\t0xffffffff\n(gdb) c\nContinuing.\n# 插入了三个元素后，哈希表没有剩余空间，堆地址起始位置不变 0x5555555a7af0 - 4*8(0x20)\nadded 3: bucket_mask 0x3, ctrl 0x5555555a7af0, growth_left: 0, items: 3\n\nBreakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32\n32\t    unsafe { std::mem::transmute(arr) }\n(gdb) x /12x 0x5555555a7ad0\n0x5555555a7ad0:\t0x00000061\t0x00000001\t0x00000062\t0x00000002\n0x5555555a7ae0:\t0x00000000\t0x00000000\t0x00000063\t0x00000003\n0x5555555a7af0:\t0x0a72ff02\t0xffffffff\t0xffffffff\t0xffffffff\n(gdb) c\nContinuing.\n# 插入第四个元素后，哈希表扩容，堆地址起始位置变为 0x5555555a7b50 - 8*8(0x40)\nadded 4: bucket_mask 0x7, ctrl 0x5555555a7b50, growth_left: 3, items: 4\n\nBreakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32\n32\t    unsafe { std::mem::transmute(arr) }\n(gdb) x /20x 0x5555555a7b10\n0x5555555a7b10:\t0x00000061\t0x00000001\t0x00000000\t0x00000000\n0x5555555a7b20:\t0x00000064\t0x00000004\t0x00000063\t0x00000003\n0x5555555a7b30:\t0x00000000\t0x00000000\t0x00000062\t0x00000002\n0x5555555a7b40:\t0x00000000\t0x00000000\t0x00000000\t0x00000000\n0x5555555a7b50:\t0xff72ffff\t0x0aff6502\t0xffffffff\t0xffffffff\n(gdb) c\nContinuing.\n# 删除 a 后，剩余 4 个位置。注意 ctrl bit 的变化，以及 0x61 0x1 并没有被清除\nfinal: bucket_mask 0x7, ctrl 0x5555555a7b50, growth_left: 4, items: 3\n\nBreakpoint 1, hashmap2::explain (name=..., map=...) at src/hashmap2.rs:32\n32\t    unsafe { std::mem::transmute(arr) }\n(gdb) x /20x 0x5555555a7b10\n0x5555555a7b10:\t0x00000061\t0x00000001\t0x00000000\t0x00000000\n0x5555555a7b20:\t0x00000064\t0x00000004\t0x00000063\t0x00000003\n0x5555555a7b30:\t0x00000000\t0x00000000\t0x00000062\t0x00000002\n0x5555555a7b40:\t0x00000000\t0x00000000\t0x00000000\t0x00000000\n0x5555555a7b50:\t0xff72ffff\t0xffff6502\t0xffffffff\t0xffffffff\n</code></pre><p>这段输出蕴藏了很多信息，我们结合示意图来仔细梳理。</p><p>首先，插入第一个元素 ‘a’: 1 后，哈希表的内存布局如下：<img src=\"https://static001.geekbang.org/resource/image/d1/87/d126ceb74605b168d36bc1e83d4c9e87.jpg?wh=2364x1762\" alt=\"\"></p><p>key ‘a’ 的 hash 和 bucket_mask 0x3 运算后得到第 0 个位置插入。同时，这个 hash 的头 7 位取出来，在 ctrl 表中对应的位置，也就是第 0 个字节，把这个值写入。</p><p>要理解这个步骤，关键就是要搞清楚这个 ctrl 表是什么。</p><h3>ctrl 表</h3><p>ctrl 表的主要目的是快速查找。它的设计非常优雅，值得我们学习。</p><p>一张 ctrl 表里，有若干个 128bit 或者说 16 个字节的分组（group），group 里的每个字节叫 ctrl byte，对应一个 bucket，那么一个 group 对应 16 个 bucket。如果一个 bucket 对应的 ctrl byte 首位不为 1，就表示这个 ctrl byte 被使用；如果所有位都是 1，或者说这个字节是 0xff，那么它是空闲的。</p><p>一组 control byte 的整个 128 bit 的数据，可以通过一条指令被加载进来，然后和某个值进行 mask，找到它所在的位置。这就是一开始提到的<strong>SIMD 查表</strong>。</p><p>我们知道，现代 CPU 都支持单指令多数据集的操作，而Rust 充分利用了 CPU 这种能力，一条指令可以让多个相关的数据载入到缓存中处理，大大加快查表的速度。所以，Rust 的哈希表查询的效率非常高。</p><p>具体怎么操作，我们来看 HashMap 是如何通过 ctrl 表来进行数据查询的。假设这张表里已经添加了一些数据，我们现在要查找 key 为 ‘c’ 的数据：</p><ol>\n<li>首先对 ‘c’ 做哈希，得到一个哈希值 h；</li>\n<li>把 h 跟 bucket_mask 做与，得到一个值，图中是 139；</li>\n<li>拿着这个 139，找到对应的 ctrl group 的起始位置，因为 ctrl group 以 16 为一组，所以这里找到 128；</li>\n<li>用 SIMD 指令加载从 128 对应地址开始的 16 个字节；</li>\n<li>对 hash 取头 7 个 bit，然后和刚刚取出的 16 个字节一起做与，找到对应的匹配，如果找到了，它（们）很大概率是要找的值；</li>\n<li>如果不是，那么以二次探查（以 16 的倍数不断累积）的方式往后查找，直到找到为止。</li>\n</ol><p>你可以结合下图理解这个算法：<img src=\"https://static001.geekbang.org/resource/image/d2/60/d2a3cc569c9a9b0728a659c030eb6560.jpg?wh=2364x1762\" alt=\"\"></p><p>所以，当 HashMap 插入和删除数据，以及因此导致重新分配的时候，主要工作就是在维护这张 ctrl 表和数据的对应。</p><p>因为 ctrl 表是所有操作最先触及的内存，所以，在 HashMap 的结构中，<strong>堆内存的指针直接指向 ctrl 表</strong>，而不是指向堆内存的起始位置，这样可以减少一次内存的访问。</p><h3>哈希表重新分配与增长</h3><p>好，回到刚才讲的内存布局继续说。在插入第一条数据后，我们的哈希表只有 4 个 bucket，所以只有头 4 个字节的 ctrl 表有用。随着哈希表的增长，bucket 不够，就会导致重新分配。由于 bucket_mask 永远比 bucket 数量少 1，所以插入三个元素后就会重新分配。</p><p>根据 rust-gdb 中得到的信息，我们看插入三个元素后没有剩余空间的哈希表，在加入 ‘d’: 4 时，是如何增长的。</p><p>首先，<strong>哈希表会按幂扩容</strong>，从 4 个 bucket 扩展到 8 个 bucket。</p><p>这会导致分配新的堆内存，然后原来的 ctrl table 和对应的kv数据会被移动到新的内存中。这个例子里因为 char 和 i32 实现了 Copy trait，所以是拷贝；如果 key 的类型是 String，那么只有 String 的 24 个字节 (ptr|cap|len) 的结构被移动，String 的实际内存不需要变动。</p><p>在移动的过程中，会涉及<strong>哈希的重分配</strong>。从下图可以看到，‘a’ / ‘c’ 的相对位置和它们的 ctrl byte 没有变化，但重新做 hash 后，‘b’ 的 ctrl byte 和位置都发生了变化：<br>\n<img src=\"https://static001.geekbang.org/resource/image/ec/e0/ec62494f0c576f932c9716195a1ba6e0.jpg?wh=2364x1762\" alt=\"\"></p><h3>删除一个值</h3><p>明白了哈希表是如何增长的，我们再来看删除的时候会发生什么。</p><p>当要在哈希表中删除一个值时，整个过程和查找类似，先要找到要被删除的 key 所在的位置。在找到具体位置后，<strong>并不需要实际清除内存，只需要将它的 ctrl byte 设回 0xff</strong>（或者标记成删除状态）。这样，这个 bucket 就可以被再次使用了：<br>\n<img src=\"https://static001.geekbang.org/resource/image/82/9e/828f746528039b15b8601ee6f8cdd79e.jpg?wh=2364x1762\" alt=\"\"></p><p>这里有一个问题，当 key/value 有额外的内存时，比如 String，它的内存不会立即回收，只有在下一次对应的 bucket 被使用时，让 HashMap 不再拥有这个 String 的所有权之后，这个 String 的内存才被回收。我们看下面的示意图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/0d/4d/0d191c99c4201bb88fb5a11d70a9434d.jpg?wh=2364x1304\" alt=\"\"></p><p>一般来说，这并不会带来什么问题，顶多是内存占用率稍高一些。但某些极端情况下，比如在哈希表中添加大量内容，又删除大量内容后运行，这时你可以通过 shrink_to_fit / shrink_to 释放掉不需要的内存。</p><h3>让自定义的数据结构做 Hash key</h3><p>有时候，我们需要让自定义的数据结构成为 HashMap 的 key。此时，要使用到三个 trait：<a href=\"https://doc.rust-lang.org/std/hash/trait.Hash.html\">Hash</a>、<a href=\"https://doc.rust-lang.org/std/cmp/trait.PartialEq.html\">PartialEq</a>、<a href=\"https://doc.rust-lang.org/std/cmp/trait.Eq.html\">Eq</a>，不过这三个 trait 都可以通过派生宏自动生成。其中：</p><ul>\n<li>实现了 Hash ，可以让数据结构计算哈希；</li>\n<li>实现了 PartialEq/Eq，可以让数据结构进行相等和不相等的比较。Eq 实现了比较的自反性（a == a）、对称性（a == b 则 b == a）以及传递性（a == b，b == c，则 a == c），PartialEq 没有实现自反性。</li>\n</ul><p>我们可以写个例子，看看自定义数据结构如何支持 HashMap：</p><pre><code class=\"language-rust\">use std::{\n    collections::{hash_map::DefaultHasher, HashMap},\n    hash::{Hash, Hasher},\n};\n\n// 如果要支持 Hash，可以用 #[derive(Hash)]，前提是每个字段都实现了 Hash\n// 如果要能作为 HashMap 的 key，还需要 PartialEq 和 Eq\n#[derive(Debug, Hash, PartialEq, Eq)]\nstruct Student&lt;'a&gt; {\n    name: &amp;'a str,\n    age: u8,\n}\n\nimpl&lt;'a&gt; Student&lt;'a&gt; {\n    pub fn new(name: &amp;'a str, age: u8) -&gt; Self {\n        Self { name, age }\n    }\n}\nfn main() {\n    let mut hasher = DefaultHasher::new();\n    let student = Student::new(\"Tyr\", 18);\n    // 实现了 Hash 的数据结构可以直接调用 hash 方法\n    student.hash(&amp;mut hasher);\n    let mut map = HashMap::new();\n    // 实现了 Hash / PartialEq / Eq 的数据结构可以作为 HashMap 的 key\n    map.insert(student, vec![\"Math\", \"Writing\"]);\n    println!(\"hash: 0x{:x}, map: {:?}\", hasher.finish(), map);\n}\n</code></pre><h2>HashSet / BTreeMap / BTreeSet</h2><p>最后我们简单讲讲和 HashMap 相关的其它几个数据结构。</p><p>有时我们只需要简单确认元素是否在集合中，如果用 HashMap 就有些浪费空间了。这时可以用HashSet，它就是简化的 HashMap，可以用来存放无序的集合，定义直接是 HashMap&lt;K, ()&gt;：</p><pre><code class=\"language-rust\">use hashbrown::hash_set as base;\n\npub struct HashSet&lt;T, S = RandomState&gt; {\n    base: base::HashSet&lt;T, S&gt;,\n}\n\npub struct HashSet&lt;T, S = DefaultHashBuilder, A: Allocator + Clone = Global&gt; {\n    pub(crate) map: HashMap&lt;T, (), S, A&gt;,\n}\n</code></pre><p>使用 HashSet 查看一个元素是否属于集合的效率非常高。</p><p>另一个和 HashMap 一样常用的数据结构就是BTreeMap了。BTreeMap 是内部使用 <a href=\"https://en.wikipedia.org/wiki/B-tree\">B-tree</a> 来组织哈希表的数据结构。另外 BTreeSet 和 HashSet 类似，是 BTreeMap 的简化版，可以用来存放有序集合。</p><p>我们这里重点看下BTreeMap，它的数据结构如下：</p><pre><code class=\"language-rust\">pub struct BTreeMap&lt;K, V&gt; {\n    root: Option&lt;Root&lt;K, V&gt;&gt;,\n    length: usize,\n}\n\npub type Root&lt;K, V&gt; = NodeRef&lt;marker::Owned, K, V, marker::LeafOrInternal&gt;;\n\npub struct NodeRef&lt;BorrowType, K, V, Type&gt; {\n    height: usize,\n    node: NonNull&lt;LeafNode&lt;K, V&gt;&gt;,\n    _marker: PhantomData&lt;(BorrowType, Type)&gt;,\n}\n\nstruct LeafNode&lt;K, V&gt; {\n    parent: Option&lt;NonNull&lt;InternalNode&lt;K, V&gt;&gt;&gt;,\n    parent_idx: MaybeUninit&lt;u16&gt;,\n    len: u16,\n    keys: [MaybeUninit&lt;K&gt;; CAPACITY],\n    vals: [MaybeUninit&lt;V&gt;; CAPACITY],\n}\n\nstruct InternalNode&lt;K, V&gt; {\n    data: LeafNode&lt;K, V&gt;,\n    edges: [MaybeUninit&lt;BoxedNode&lt;K, V&gt;&gt;; 2 * B],\n}\n</code></pre><p>和 HashMap 不同的是，BTreeMap 是有序的。我们看个例子（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=711b0bd9ac7dbdd882c4b84809212778\">代码</a>）:</p><pre><code class=\"language-rust\">use std::collections::BTreeMap;\n\nfn main() {\n    let map = BTreeMap::new();\n    let mut map = explain(\"empty\", map);\n\n    for i in 0..16usize {\n        map.insert(format!(\"Tyr {}\", i), i);\n    }\n\n    let mut map = explain(\"added\", map);\n\n    map.remove(\"Tyr 1\");\n\n    let map = explain(\"remove 1\", map);\n\n    for item in map.iter() {\n        println!(\"{:?}\", item);\n    }\n}\n\n// BTreeMap 结构有 height，node 和 length\n// 我们 transmute 打印之后，再 transmute 回去\nfn explain&lt;K, V&gt;(name: &amp;str, map: BTreeMap&lt;K, V&gt;) -&gt; BTreeMap&lt;K, V&gt; {\n    let arr: [usize; 3] = unsafe { std::mem::transmute(map) };\n    println!(\n        \"{}: height: {}, root node: 0x{:x}, len: 0x{:x}\",\n        name, arr[0], arr[1], arr[2]\n    );\n    unsafe { std::mem::transmute(arr) }\n}\n</code></pre><p>它的输出如下：</p><pre><code class=\"language-rust\">empty: height: 0, root node: 0x0, len: 0x0\nadded: height: 1, root node: 0x7f8286406190, len: 0x10\nremove 1: height: 1, root node: 0x7f8286406190, len: 0xf\n(\"Tyr 0\", 0)\n(\"Tyr 10\", 10)\n(\"Tyr 11\", 11)\n(\"Tyr 12\", 12)\n(\"Tyr 13\", 13)\n(\"Tyr 14\", 14)\n(\"Tyr 15\", 15)\n(\"Tyr 2\", 2)\n(\"Tyr 3\", 3)\n(\"Tyr 4\", 4)\n(\"Tyr 5\", 5)\n(\"Tyr 6\", 6)\n(\"Tyr 7\", 7)\n(\"Tyr 8\", 8)\n(\"Tyr 9\", 9)\n</code></pre><p>可以看到，在遍历时，BTreeMap 会按照 key 的顺序把值打印出来。如果你想让自定义的数据结构可以作为 BTreeMap 的 key，那么需要实现 <a href=\"https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html\">PartialOrd</a> 和 <a href=\"https://doc.rust-lang.org/std/cmp/trait.Ord.html\">Ord</a>，这两者的关系和 PartialEq / Eq 类似，PartialOrd 也没有实现自反性。同样的，PartialOrd 和 Ord 也可以通过派生宏来实现。</p><h2>小结</h2><p>在学习数据结构的时候，常用数据结构的内存布局和基本算法你一定要理解清楚，对它在不同情况下如何增长，也要尽量做到心里有数。</p><p>这一讲我们花大精力详细学习了 HashMap 的数据结构以及算法的基本思路，算是抛砖引玉。这门课无论多深入讲解，也只能触及 Rust 整个生态圈的九牛一毛，不可能面面俱到。</p><p>我的原则是“授人以鱼不如授人以渔”，在你掌握这样的分析方法后，以后遇到标准库或者第三方库的其它的数据结构，也可以用类似的方法深入探索学习。</p><p>此外，我们程序员学东西，<strong>会用是第一层，知道它是如何设计的是第二层，能够自己写出来才是第三层</strong>。Rust借鉴的 Google Swiss table 算法简单精巧，虽然 hashbrown 在实现时，为了最大化性能和利用 SSE 指令集，使用了很多 unsafe 代码，但我们撰写一个性能不那么好的 safe 版本，并不是复杂的事情，非常推荐你实现一下。</p><p>集合类型我们就暂时讲解到这里，未来实战要使用到某些数据结构时，比如 VecDeque，我们再深入探索。其他的集合类型，你也可以在要用的时候自行阅读<a href=\"https://doc.rust-lang.org/std/collections/index.html\">文档</a>。</p><p>如果你想了解这两讲中集合类型的时间复杂度，可以看下表（<a href=\"https://doc.rust-lang.org/std/collections/index.html#performance\">来源</a>）：<img src=\"https://static001.geekbang.org/resource/image/60/2f/60733157bd6e6171a7fee22981469b2f.jpg?wh=2364x1304\" alt=\"\"></p><h3>思考题</h3><p>1.修改下面代码的错误，使其编译通过（<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c29bbe5c06183eec0892101298dfc510\">代码</a>）。</p><pre><code class=\"language-rust\">use std::collections::BTreeMap;\n\n#[derive(Debug)]\nstruct Name {\n&nbsp; &nbsp; pub name: String,\n&nbsp; &nbsp; pub flags: u32,\n}\n\nimpl Name {\n&nbsp; &nbsp; pub fn new(name: impl AsRef&lt;str&gt;, flags: u32) -&gt; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; Self {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: name.as_ref().to_string(),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags,\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\nfn main() {\n&nbsp; &nbsp; let mut map = BTreeMap::new();\n&nbsp; &nbsp; map.insert(Name::new(\"/etc/password\", 0x1), 12);\n&nbsp; &nbsp; map.insert(Name::new(\"/etc/hosts\", 0x1), 4);\n&nbsp; &nbsp; map.insert(Name::new(\"/home/tchen\", 0x0), 28);\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; for item in map.iter() {\n&nbsp; &nbsp; &nbsp; &nbsp; println!(\"{:?}\", item);\n&nbsp; &nbsp; }\n}\n\n</code></pre><p>2.思考一下，如果一个 session 表的 key 是 (Source IP、Source Port、Dst IP、Dst Port、Proto) 这样的长度 15 个字节的五元组，value 是 200 字节的 Session 结构，要容纳 1200000 个 Session，整个哈希表要占多大的堆内存？内存的利用率如何？</p><p>3.使用文中同样的方式，结合 rust-gdb / rust-lldb 探索 BTreeMap。你能画出来在插入以 26 个字母为 key，1～26 为 value 后的 BTreeMap 的内存布局么？</p><p>今天你完成了Rust学习的第17次打卡，我们下节课见。</p><h3>参考资料</h3><p>1.为什么 Rust 的 HashMap 要缺省采用加密安全的哈希算法？</p><p>我们知道哈希表在软件系统中的重要地位，但哈希表在最坏情况下，如果绝大多数 key 的 hash 都碰撞在一起，性能会到 O(n)，这会极大拖累系统的效率。</p><p>比如 1M 大小的 session 表，正常情况下查表速度是 O(1)，但极端情况下，需要比较 1M 个数据后才能找到，这样的系统就容易被 DoS 攻击。所以如果不是加密安全的哈希函数，只要黑客知道哈希算法，就可以构造出大量的 key 产生足够多的哈希碰撞，造成目标系统 DoS。</p><p><a href=\"https://en.wikipedia.org/wiki/SipHash\">SipHash</a> 就是为了回应 DoS 攻击而创建的哈希算法，虽然和 sha2 这样的加密哈希不同（不要将 SipHash 用于加密！），但它可以提供类似等级的安全性。把 SipHash 作为 HashMap 的缺省的哈希算法，Rust 可以避免开发者在不知情的情况下被 DoS，就像曾经在 <a href=\"https://arstechnica.com/information-technology/2011/12/huge-portions-of-web-vulnerable-to-hashing-denial-of-service-attack/\">Web 世界</a>发生的那样。</p><p>当然，这一切的代价是性能损耗，虽然 SipHash 非常快，但它比 hashbrown 缺省使用的 <a href=\"https://github.com/tkaitchuck/aHash\">Ahash</a> 慢了不少。如果你确定使用的 HashMap 不需要 DoS 防护（比如一个完全内部使用的 HashMap），那么可以用 Ahash 来替换。你只需要使用 Ahash 提供的 RandomState 即可：</p><pre><code class=\"language-rust\">use ahash::{AHasher, RandomState};\nuse std::collections::HashMap;\nlet mut map: HashMap&lt;char, i32, RandomState&gt; = HashMap::default();\nmap.insert('a', 1);\n</code></pre><p>2.如何使用 rust-gdb / rust-lldb？</p><p>之前的愚昧之巅<a href=\"https://time.geekbang.org/column/article/418778\">加餐</a>提过 <a href=\"https://www.gnu.org/software/gdb/\">gdb</a> / <a href=\"https://lldb.llvm.org/\">lldb</a> ，今天就是使用示例。没有使用过的朋友，可以看看它们的文档了解一下。</p><p>gdb 适合在 Linux 下，lldb 可以在 OS X 下调试 Rust 程序。<a href=\"https://github.com/rust-lang/rust/blob/master/src/etc/rust-gdb\">rust-gdb</a> / <a href=\"https://github.com/rust-lang/rust/blob/master/src/etc/rust-lldb\">rust-lldb</a> 提供了一些对 Rust 更友好的 pretty-print 功能，在安装 Rust 时，它们也会被安装。使用过 gdb 的同学，可以看 <a href=\"https://darkdust.net/files/GDB%20Cheat%20Sheet.pdf\">gdb 速查手册</a>，也可以看看 <a href=\"https://lldb.llvm.org/use/map.html\">gdb/lldb 命令对应手册</a>。</p><p>我一般不用它们调试程序。<strong>不管任何语言，如果开发时，你发现自己总在设置断点调试程序，说明你撰写代码的方式有问题</strong>。要么，没有把接口和算法设计清楚，想到哪写到哪；要么，是你的函数写得过于复杂，太多状态纠缠，没有遵循 SRP（Single Responsibility Principle）。</p><p><strong>好的代码是写出来的，不是调出来的。与其把时间花在调试上，不如把时间花在设计、日志，以及单元测试上</strong>。所以，gdb/lldb 对我来说，是一个理解数据结构在内存中布局以及探索算法如何运行的工具。你可以仔细阅读文中展示的 gdb session 和与之相关的代码，看看如何构造代码来结合 gdb 探索 HashMap 在不同状态下的行为。</p><p>如果你觉得有收获，也欢迎分享给你身边的朋友，邀TA一起讨论～</p>","neighbors":{"left":{"article_title":"16｜数据结构：Vec<T>、&[T]、Box<[T]> ，你真的了解集合容器么？","id":422975},"right":{"article_title":"18｜错误处理：为什么Rust的错误处理与众不同？","id":424002}},"comments":[{"had_liked":false,"id":314815,"user_name":"Geek_5244fa","can_delete":false,"product_type":"c1","uid":1072743,"ip_address":"","ucode":"B87A550526F74C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/67/133d2da6.jpg","comment_is_top":false,"comment_ctime":1633448830,"is_pvip":true,"replies":[{"id":"114173","content":"赞！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633813565,"ip_address":"","comment_id":314815,"utype":1}],"discussion_count":3,"race_medal":0,"score":"35993187198","product_id":100085301,"comment_content":"说一下对 hashbrown 的理解。<br><br>一般的哈希表是对数组大小取模（hash % len）来定位位置的，但是 hashbrown 把 hash 分两部分使用：<br><br>1. 低几位（&amp; bucket_size）定位在数组的位置<br>2. 高 7 位存到对应位置的 ctrl 块里，类似指纹的作用<br><br>一般哈希表获取时，取模定位到位置后，要完整对比 key 才能知道是找到（key相同）还是要探查（key 不同）。<br><br>而 hashbrown 可以利用 ctrl 里存起来的高 7 位快速发现冲突的情况（低几位相同但高7 位不同），直接进入下一步探查。","like_count":9,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527799,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633813565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1072743,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5e/67/133d2da6.jpg","nickname":"Geek_5244fa","note":"","ucode":"B87A550526F74C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401321,"discussion_content":"Go 的 map 也是类似的思路","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633624047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2806043,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLBFkSq1oiaEMRjtyyv4ZpCI0OuaSsqs04ODm0OkZF6QhsAh3SvqhxibS2n7PLAVZE3QRSn5Hic0DyXg/132","nickname":"ddh","note":"","ucode":"8E852375365F16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1072743,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5e/67/133d2da6.jpg","nickname":"Geek_5244fa","note":"","ucode":"B87A550526F74C","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":413888,"discussion_content":"是的， 当时学go的时候也有这个","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636597361,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":401321,"ip_address":""},"score":413888,"extra":""}]}]},{"had_liked":false,"id":314450,"user_name":"GeekCiao","can_delete":false,"product_type":"c1","uid":1850166,"ip_address":"","ucode":"D5DAB08E430AC7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM4D6vFOOEC0DiaTHdqmxKIWxRb9Tzt5koAQI3s4jKRNX5gfEHgu6S77AgjicpvWpKnmiah0TTEIiajGnA/132","comment_is_top":false,"comment_ctime":1633067057,"is_pvip":false,"replies":[{"id":"113973","content":"👍","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633320456,"ip_address":"","comment_id":314450,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27402870833","product_id":100085301,"comment_content":"aHash 已经可以做到DOS防护了：https:&#47;&#47;github.com&#47;tkaitchuck&#47;aHash&#47;wiki&#47;How-aHash-is-resists-DOS-attacks","like_count":7,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527683,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633320456,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314503,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1633156021,"is_pvip":true,"replies":[{"id":"113970","content":"这是个和 CPU 指令集紧密相关的操作。x86&#47;64 CPU 目前还是服务器的主流（虽然未来不一定）","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633320208,"ip_address":"","comment_id":314503,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14518057909","product_id":100085301,"comment_content":"SIMD lookup也只是在x86&#47;64上用sse2而已，据说avx&#47;neon效果不佳：<br><br>https:&#47;&#47;github.com&#47;rust-lang&#47;hashbrown&#47;blob&#47;cedc3267e4&#47;src&#47;raw&#47;mod.rs#L16<br><br>看了下其他平台也都还没稳定：<br><br>https:&#47;&#47;doc.rust-lang.org&#47;core&#47;arch&#47;index.html#modules","like_count":4,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527704,"discussion_content":"这是个和 CPU 指令集紧密相关的操作。x86/64 CPU 目前还是服务器的主流（虽然未来不一定）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633320208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":317241,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1634719179,"is_pvip":true,"replies":[{"id":"115243","content":"不是 usize 大小的指针。你可以自己想想 String 和 Vec&lt;T&gt; 的结构都是什么样子的。所以这里 key  是 24 个字节，value 也是 24 个字节，它们再通过结构里的指针指向额外的堆地址里的内容。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1635122543,"ip_address":"","comment_id":317241,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10224653771","product_id":100085301,"comment_content":"HashMap使用的一个问题：文章例子插入的元素是char和i32, 长度固定都是32字节，HashMap在插入数据时，从图上看，是直接将值记录在堆内存中数组对应的位置上。对于一个复杂的数据类型，比如说Key是String，Value是Vec&lt;String&gt;, 那么记录的是不是就是 大小为usize 的指针呢？","like_count":2,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":528730,"discussion_content":"不是 usize 大小的指针。你可以自己想想 String 和 Vec&amp;lt;T&amp;gt; 的结构都是什么样子的。所以这里 key  是 24 个字节，value 也是 24 个字节，它们再通过结构里的指针指向额外的堆地址里的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635122543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042983,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ea/27/a3737d61.jpg","nickname":"Shanks-王冲","note":"","ucode":"C4B90A17850E20","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583461,"discussion_content":"似乎 HashMap 的k v会分别存储对应 String 和 Vec&lt;String&gt; 的胖指针，刚好是24和24字节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660125007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324880,"user_name":"交流会","can_delete":false,"product_type":"c1","uid":2022072,"ip_address":"","ucode":"EA82C16C86FAEE","user_header":"https://static001.geekbang.org/account/avatar/00/1e/da/b8/3f80b8a5.jpg","comment_is_top":false,"comment_ctime":1638699421,"is_pvip":false,"replies":[{"id":"118861","content":"你可以在不同的系统上打印 main 函数的地址和 main 下一个 u32，一个 vec 的堆地址，就可以大概看到不同地址的区别了。比如：<br><br>```rust<br>fn main() {<br>    let a = 1;<br>    let arr = vec![1,2,3];<br>    <br>    println!(&quot;main: {:p}, a: {:p}, s: {:p}&quot;, main as *const (), &amp;a, &amp;arr[0]);<br>}<br>```<br><br>在 playground 下的打印（https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8003d4ccfbf6d63280b124811a219f4a）：<br>main: 0x55bcfa1f5100, a: 0x7ffcd8b6adec, s: 0x55bcfb6ca9d0<br><br>如果你想知道更详细的各个段的地址，可以使用 readelf 或者在 gdb 里面查看。","user_name":"作者回复","user_name_real":"编辑","uid":"1079375","ctime":1639848605,"ip_address":"","comment_id":324880,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5933666717","product_id":100085301,"comment_content":"老师您好，有个疑问不太懂请教一下：<br>您在文中说 ----<br>...在我的 OS X 下，一开始哈希表为空，ctrl 地址看上去是一个 TEXT&#47;RODATA 段的地址，...<br><br>想请问一下，通过看数据地址怎么能区分是在 段上还是堆栈上的？ 谢谢～","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539821,"discussion_content":"你可以在不同的系统上打印 main 函数的地址和 main 下一个 u32，一个 vec 的堆地址，就可以大概看到不同地址的区别了。比如：\n\n```rust\nfn main() {\n    let a = 1;\n    let arr = vec![1,2,3];\n    \n    println!(&#34;main: {:p}, a: {:p}, s: {:p}&#34;, main as *const (), &amp;a, &amp;arr[0]);\n}\n```\n\n在 playground 下的打印（https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8003d4ccfbf6d63280b124811a219f4a）：\nmain: 0x55bcfa1f5100, a: 0x7ffcd8b6adec, s: 0x55bcfb6ca9d0\n\n如果你想知道更详细的各个段的地址，可以使用 readelf 或者在 gdb 里面查看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639848605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":315085,"user_name":"Ixa","can_delete":false,"product_type":"c1","uid":2033305,"ip_address":"","ucode":"4F05A56E2E1C2C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKkPibGWUPadLGzn4aQ7dmSYJyiaic7LHL8icerLv7y3ZPiazOFnHHIk6icaOYJXTqLibiadYsYBy6VKAGVkA/132","comment_is_top":false,"comment_ctime":1633683896,"is_pvip":false,"replies":[{"id":"114160","content":"对！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633812189,"ip_address":"","comment_id":315085,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5928651192","product_id":100085301,"comment_content":"把 PartialOrd 和 PartialEq 实现即可解决报错。使用词典的cmp来进行对比<br><br>impl Ord for Name {<br>    fn cmp(&amp;self, other: &amp;Self) -&gt; Ordering {<br>        (self.flags, &amp;self.name).cmp(&amp;(other.flags, &amp;other.name))<br>    }<br>}<br><br>impl PartialOrd for Name {<br>    fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; {<br>        Some(self.cmp(other))<br>    }<br>}<br><br>impl PartialEq for Name {<br>    fn eq(&amp;self, other: &amp;Self) -&gt; bool {<br>        (self.flags, &amp;self.name) == (other.flags, &amp;other.name)<br>    }<br>}<br>","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527868,"discussion_content":"对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633812189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314740,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1633379124,"is_pvip":false,"replies":[{"id":"114178","content":"你可以参考：https:&#47;&#47;gankra.github.io&#47;blah&#47;rust-btree-case&#47; 来学习。虽然是比较旧的文章，但 Btreemap 的思想和大方向是一致的。<br><br>3. B=6,edges 是个数组，里面有 12 个元素，元素类型是可能未初始化（MaybeUninit）的BoxedNode&lt;K, V&gt;。这个代码开头处有伪代码表述想要达成的目的：<br><br>&#47;&#47; This is an attempt at an implementation following the ideal<br>&#47;&#47;<br>&#47;&#47; ```<br>&#47;&#47; struct BTreeMap&lt;K, V&gt; {<br>&#47;&#47;     height: usize,<br>&#47;&#47;     root: Option&lt;Box&lt;Node&lt;K, V, height&gt;&gt;&gt;<br>&#47;&#47; }<br>&#47;&#47;<br>&#47;&#47; struct Node&lt;K, V, height: usize&gt; {<br>&#47;&#47;     keys: [K; 2 * B - 1],<br>&#47;&#47;     vals: [V; 2 * B - 1],<br>&#47;&#47;     edges: [if height &gt; 0 { Box&lt;Node&lt;K, V, height - 1&gt;&gt; } else { () }; 2 * B],<br>&#47;&#47;     parent: Option&lt;(NonNull&lt;Node&lt;K, V, height + 1&gt;&gt;, u16)&gt;,<br>&#47;&#47;     len: u16,<br>&#47;&#47; }","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633814307,"ip_address":"","comment_id":314740,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5928346420","product_id":100085301,"comment_content":"第三题:<br>```<br>    # 最初 root insert a - k<br>    x&#47;24 0x100504080<br>    0x100504080: 0x004044a0 0x00000001 0x00000061 0x00000062<br>    0x100504090: 0x00000063 0x00000064 0x00000065 0x00000066<br>    0x1005040a0: 0x00000067 0x00000068 0x00000069 0x0000006a<br>    0x1005040b0: 0x0000006b 0x00000001 0x00000002 0x00000003<br>    0x1005040c0: 0x00000004 0x00000005 0x00000006 0x00000007<br>    0x1005040d0: 0x00000008 0x00000009 0x0000000a 0x0000000b<br>    # insert 第11个 出现新的root<br>    x 0x1004044a0<br>    0x1004044a0: 00 00 00 00 00 00 00 00 67 00 00 00 00 00 00 00 ........g.......<br>    0x1004044b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................<br>    ## 继续 insert 到 z<br>    x 0x1004044a0<br>    0x1004044a0: 00 00 00 00 00 00 00 00 67 00 00 00 6e 00 00 00 ........g...n...<br>    0x1004044b0: 5 00 00 00 ff ff ff ff ff ff ff ff ff ff ff ff  u...������������<br>```<br><br>`LeafNode`的capacity是11, 装满了过后就变成6个, 留5个slot以备depth加深<br><br>```<br>    root        &lt;g           n            u&gt; <br>    leaf &lt;a-f&gt;   &lt;h-m&gt;     &lt;o-t&gt;      &lt;v-z&gt;<br>```<br><br>疑问: <br><br><br>1. `LeafNode` 第一个field不是parent嘛? 为啥leaf 1的第一位是 `0x004044a0` 仅仅是32位? 我的机器是64位, 而且之后出现的parent的address是 `0x1004044a0`, 感觉这两个很接近? 不知道这是什么trick<br><br>2. 怎么从root node read leaf node的memory呢? root node的parent是null, 没找到怎么access leaf node. 我目前只能从最初的root node猜 (以为之后这个root变成了leaf)<br><br>3. 这个field能大概讲一讲big picture嘛? 目前读源码还是有难度...<br>```<br> struct InternalNode { data: LeafNode, edges: [MaybeUninit&gt;; 2 * B],}<br>````<br>","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527778,"discussion_content":"你可以参考：https://gankra.github.io/blah/rust-btree-case/ 来学习。虽然是比较旧的文章，但 Btreemap 的思想和大方向是一致的。\n\n3. B=6,edges 是个数组，里面有 12 个元素，元素类型是可能未初始化（MaybeUninit）的BoxedNode&amp;lt;K, V&amp;gt;。这个代码开头处有伪代码表述想要达成的目的：\n\n// This is an attempt at an implementation following the ideal\n//\n// ```\n// struct BTreeMap&amp;lt;K, V&amp;gt; {\n//     height: usize,\n//     root: Option&amp;lt;Box&amp;lt;Node&amp;lt;K, V, height&amp;gt;&amp;gt;&amp;gt;\n// }\n//\n// struct Node&amp;lt;K, V, height: usize&amp;gt; {\n//     keys: [K; 2 * B - 1],\n//     vals: [V; 2 * B - 1],\n//     edges: [if height &amp;gt; 0 { Box&amp;lt;Node&amp;lt;K, V, height - 1&amp;gt;&amp;gt; } else { () }; 2 * B],\n//     parent: Option&amp;lt;(NonNull&amp;lt;Node&amp;lt;K, V, height + 1&amp;gt;&amp;gt;, u16)&amp;gt;,\n//     len: u16,\n// }","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633814307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314677,"user_name":"Marvichov","can_delete":false,"product_type":"c1","uid":1111835,"ip_address":"","ucode":"7482099415C41C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","comment_is_top":false,"comment_ctime":1633323333,"is_pvip":false,"replies":[{"id":"113991","content":"注意看图，这句话之后的图，你看看图中前后对比。<br><br>&gt; 在移动的过程中，会涉及哈希的重分配。从下图可以看到，‘a’ &#47; ‘c’ 的相对位置和它们的 ctrl byte 没有变化，但重新做 hash 后，‘b’ 的 ctrl byte 和位置都发生了变化。<br><br>现在 ctrl bits 的位置是：5 6 7 8 1 2 3 4。所以 0a 对应第一项。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633326416,"ip_address":"","comment_id":314677,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5928290629","product_id":100085301,"comment_content":"对文中的例子有些疑问:<br><br>我的理解是, ctrl section, byte的postion, 对应着bucket的position<br><br>`a` 在第一个bucket, 为啥ctrl section的第一个byte不是`0x72` 呢? 和示意图 (`ctrl 表` 那一节) 对不上.<br><br>```<br>(gdb) c<br>Continuing.<br># 插入第四个元素后，哈希表扩容，堆地址起始位置变为 0x5555555a7b50 - 8*8(0x40)<br>added 4: bucket_mask 0x7, ctrl 0x5555555a7b50, growth_left: 3, items: 4<br><br>Breakpoint 1, hashmap2::explain (name=..., map=...) at src&#47;hashmap2.rs:32<br>32      unsafe { std::mem::transmute(arr) }<br>(gdb) x &#47;20x 0x5555555a7b10<br>0x5555555a7b10:  0x00000061  0x00000001  0x00000000  0x00000000<br>0x5555555a7b20:  0x00000064  0x00000004  0x00000063  0x00000003<br>0x5555555a7b30:  0x00000000  0x00000000  0x00000062  0x00000002<br>0x5555555a7b40:  0x00000000  0x00000000  0x00000000  0x00000000<br>0x5555555a7b50:  0xff72ffff  0x0aff6502  0xffffffff  0xffffffff<br>```<br><br>ctrl的start addr是0x5555555a7b50, 第一个byte不应该对应bucket 1吗? 然而`0a` 对应的是第5个bucket?","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527758,"discussion_content":"注意看图，这句话之后的图，你看看图中前后对比。\n\n&amp;gt; 在移动的过程中，会涉及哈希的重分配。从下图可以看到，‘a’ / ‘c’ 的相对位置和它们的 ctrl byte 没有变化，但重新做 hash 后，‘b’ 的 ctrl byte 和位置都发生了变化。\n\n现在 ctrl bits 的位置是：5 6 7 8 1 2 3 4。所以 0a 对应第一项。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633326416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2181012,"avatar":"https://static001.geekbang.org/account/avatar/00/21/47/94/46d6a079.jpg","nickname":"Siact","note":"","ucode":"0C294F4614D48C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":587362,"discussion_content":"为什么现在的ctrl bit 的位置不是：1 2 3 4 5 6 7 8 呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662994171,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":527758,"ip_address":"中国香港"},"score":587362,"extra":""}]},{"author":{"id":1111835,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f7/1b/db7a0edc.jpg","nickname":"Marvichov","note":"","ucode":"7482099415C41C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400681,"discussion_content":"1. 为啥ctrl bits不是natural order(1-8)呢? 感觉这样好理解一点\n\n2. 5-8, 1-4 这样的布局, 难道有什么优势嘛? 8-1我还可以理解, 直接用ctrl的addr - offset就能找到bucket addr.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633363860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314628,"user_name":"阿海","can_delete":false,"product_type":"c1","uid":1281585,"ip_address":"","ucode":"2589431F840C42","user_header":"https://static001.geekbang.org/account/avatar/00/13/8e/31/28972804.jpg","comment_is_top":false,"comment_ctime":1633266499,"is_pvip":true,"replies":[{"id":"113982","content":"1. 正确！<br>2. 需要内存 (200+15+1) * 2M = 432M，实际占用 (200+15) * 114M = 246M，利用率 57%。注意 HashMap  bucket 数量是指数增长的。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633322146,"ip_address":"","comment_id":314628,"utype":1}],"discussion_count":7,"race_medal":0,"score":"5928233795","product_id":100085301,"comment_content":"这一章看的比之前吃力很多，尤其是中间观察内存布局的内容。后面有机会再来仔细琢磨下。<br><br>尝试回答下问题吧：<br><br>1. Name需要实现 Debug, PartialEq, Eq, PartialOrd, Ord 这几个trait<br>```<br>#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]<br>struct Name {<br>    pub name: String,<br>    pub flags: u32,<br>}<br>```<br><br>2. 粗略算了下，(15 + 200) * 1200000  &#47; （1024 * 1024）大约需要246M内存。内存利用率不知道要怎么算了。<br><br>3. 等有时间再琢磨下","like_count":1,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527744,"discussion_content":"1. 正确！\n2. 需要内存 (200+15+1) * 2M = 432M，实际占用 (200+15) * 114M = 246M，利用率 57%。注意 HashMap  bucket 数量是指数增长的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633322146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1494311,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epdUKuOV21hnfTmXPibv5ReJCCIxiamtzXkibh9p41sSJeYQ87swreLWlTNEibh5ibefsoJfFppOvR088Q/132","nickname":"Geek_05de53","note":"","ucode":"20872B89D6A782","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":551033,"discussion_content":"请问老师(200+15+1)这其中每个+1是怎么来的呢？是每个数据对应的ctrl表的字节占用的么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644855458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":527744,"ip_address":""},"score":551033,"extra":""}]},{"author":{"id":1298252,"avatar":"","nickname":"Geek_b52974","note":"","ucode":"59884399646620","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411280,"discussion_content":"因為全部的數據大概是 1.14M 個 (1200000) bucket，前 1 一次擴展是 1M 個 bucket，塞不下了就會等比長到 2 M 個 bucket","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635878108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1494311,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epdUKuOV21hnfTmXPibv5ReJCCIxiamtzXkibh9p41sSJeYQ87swreLWlTNEibh5ibefsoJfFppOvR088Q/132","nickname":"Geek_05de53","note":"","ucode":"20872B89D6A782","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1298252,"avatar":"","nickname":"Geek_b52974","note":"","ucode":"59884399646620","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":551032,"discussion_content":"请问(200+15+1)这其中每个+1是怎么来的呢？是每个数据对应的ctrl表的字节占用的么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644855437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":411280,"ip_address":""},"score":551032,"extra":""}]},{"author":{"id":1298252,"avatar":"","nickname":"Geek_b52974","note":"","ucode":"59884399646620","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411279,"discussion_content":"這邊應該是 1.14 M ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635877703,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2738941,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ca/fd/4e6dd31c.jpg","nickname":"枸杞红茶","note":"","ucode":"03D80953AF984E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408344,"discussion_content":"请问，2M和114M分别是怎么得到的呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635231608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1166095,"avatar":"https://static001.geekbang.org/account/avatar/00/11/cb/0f/cc403ab4.jpg","nickname":"阿凯","note":"","ucode":"26310370149BFE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2738941,"avatar":"https://static001.geekbang.org/account/avatar/00/29/ca/fd/4e6dd31c.jpg","nickname":"枸杞红茶","note":"","ucode":"03D80953AF984E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559970,"discussion_content":"实际需要 1,200,000 个 bucket，即 1,200,000 / 1024 / 1024 ≈ 1.44M。\n而 HashMap 的容量是 2 的幂次方，所以分配内存时要向上取整到 2M，即 2,097,152 个 bucket。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649085632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":408344,"ip_address":""},"score":559970,"extra":""}]}]},{"had_liked":false,"id":358392,"user_name":"星宿海","can_delete":false,"product_type":"c1","uid":2189067,"ip_address":"安徽","ucode":"F49E70D579D59E","user_header":"https://static001.geekbang.org/account/avatar/00/21/67/0b/145e3804.jpg","comment_is_top":false,"comment_ctime":1664266575,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664266575","product_id":100085301,"comment_content":"https:&#47;&#47;play.rust-lang.org&#47;?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=213aeb2d1aada4cb3c1ede3f2e9c9e36<br>大佬，hashmap的capacity为何不是 2的幂-1，而是capacity= growth_left + items。","like_count":0},{"had_liked":false,"id":356481,"user_name":"Geek_a6c6ce","can_delete":false,"product_type":"c1","uid":3074996,"ip_address":"美国","ucode":"21DC76D3225403","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/TusRVU51UggZGpicXMgH64Cb8jek0wyTOpagtUHNAj0EPbhbEv0FJpFU2K3glbtOdJXiaQ9o6QoEfv5PiaIu7rwng/132","comment_is_top":false,"comment_ctime":1662356793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662356793","product_id":100085301,"comment_content":"咔哒","like_count":0},{"had_liked":false,"id":347919,"user_name":"ELSE","can_delete":false,"product_type":"c1","uid":1172907,"ip_address":"","ucode":"72448D7271C8B0","user_header":"https://static001.geekbang.org/account/avatar/00/11/e5/ab/56f348e5.jpg","comment_is_top":false,"comment_ctime":1654583348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654583348","product_id":100085301,"comment_content":"一路学到这里，感觉真是干货满满，作者用心了，虽然很多东西没能理解，但我想第二遍再看的时候应该收获更多。另外，非常赞叹学员里全是高手啊！","like_count":0},{"had_liked":false,"id":333471,"user_name":"慢慢最快","can_delete":false,"product_type":"c1","uid":2203460,"ip_address":"","ucode":"F15797874EB5ED","user_header":"https://static001.geekbang.org/account/avatar/00/21/9f/44/316f93a6.jpg","comment_is_top":false,"comment_ctime":1644376555,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644376555","product_id":100085301,"comment_content":"hash 法的对比，以及 swiss tables的详解，感觉看看这篇文章 https:&#47;&#47;zhuanlan.zhihu.com&#47;p&#47;277732297，理解起来还挺受用的","like_count":1},{"had_liked":false,"id":314808,"user_name":"Geek_5244fa","can_delete":false,"product_type":"c1","uid":1072743,"ip_address":"","ucode":"B87A550526F74C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5e/67/133d2da6.jpg","comment_is_top":false,"comment_ctime":1633444471,"is_pvip":true,"replies":[{"id":"114174","content":"对！","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633813587,"ip_address":"","comment_id":314808,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633444471","product_id":100085301,"comment_content":"&gt; 如果数据结构的输入和输出能一一对应，那么可以使用列表，如果无法一一对应，那么就需要使用哈希表。<br><br><br>这里说的一一对应，结合图来看，似乎说的是位置的映射。<br><br>HashMap 有两个映射关系，一个是 key 到位置的映射，一个到 value 的映射。不同 key 可能映射到相同的位置（冲突），也可以映射到相同的值。<br>","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527795,"discussion_content":"对！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633813587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314684,"user_name":"给我点阳光就灿烂","can_delete":false,"product_type":"c1","uid":1462209,"ip_address":"","ucode":"F3B0439BE0D062","user_header":"https://static001.geekbang.org/account/avatar/00/16/4f/c1/7f596aba.jpg","comment_is_top":false,"comment_ctime":1633326255,"is_pvip":true,"replies":[{"id":"114180","content":"hashmap 中所有的输入都来自于内部系统，比如你有个 database，使用 uuid 做主键，你要用 hashmap 来对 db 的数据做缓存，那么 key 就是 db 中的 uuid，这是你自己生成的数据，并非可以精心构造的用户输入，所以可以用非 DDOS resistent 的 hash 算法。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633814557,"ip_address":"","comment_id":314684,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1633326255","product_id":100085301,"comment_content":"比如一个完全内部使用的 HashMap，这个没太懂，如何判断项目中的hashmap是完全内部使用的呢？","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527761,"discussion_content":"hashmap 中所有的输入都来自于内部系统，比如你有个 database，使用 uuid 做主键，你要用 hashmap 来对 db 的数据做缓存，那么 key 就是 db 中的 uuid，这是你自己生成的数据，并非可以精心构造的用户输入，所以可以用非 DDOS resistent 的 hash 算法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633814557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314616,"user_name":"给我点阳光就灿烂","can_delete":false,"product_type":"c1","uid":1462209,"ip_address":"","ucode":"F3B0439BE0D062","user_header":"https://static001.geekbang.org/account/avatar/00/16/4f/c1/7f596aba.jpg","comment_is_top":false,"comment_ctime":1633259140,"is_pvip":true,"replies":[{"id":"113967","content":"hash 冲突，hash 原本对应的 bucket 被占用，这个时候就需要进行哈希冲突的处理了，需要找出来一个空闲的 bucket，这个时候用二次探查。<br><br>至于对原来的 key 的更新，查到 hash 对应的 slot 后，还会进一步和 key 做对比。发现key 相同，则做更新操作。","user_name":"作者回复","user_name_real":"Tyr","uid":"1079375","ctime":1633320000,"ip_address":"","comment_id":314616,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1633259140","product_id":100085301,"comment_content":"老师，有个不太懂的地方。文章里讲到了二次探查，但 Rust里面的hashmap 在插入的时候，对key进行hash，这个地方怎么区别hash出来的key要不要进行二次探查呢？因为现在有两种可能，第一种是这是一个新的key，hash冲突了，需要进行二次探查。第二种情况是，这还是原来的key，要更新value。","like_count":0,"discussions":[{"author":{"id":1079375,"avatar":"https://static001.geekbang.org/account/avatar/00/10/78/4f/e74f870c.jpg","nickname":"Tyr","note":"","ucode":"EAAFC8063202E0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527737,"discussion_content":"hash 冲突，hash 原本对应的 bucket 被占用，这个时候就需要进行哈希冲突的处理了，需要找出来一个空闲的 bucket，这个时候用二次探查。\n\n至于对原来的 key 的更新，查到 hash 对应的 slot 后，还会进一步和 key 做对比。发现key 相同，则做更新操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633320000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536336,"discussion_content":"你好像混淆了插入/更新操作与探查的关系，实际上两者没有实质上的关系。\n只有hash碰撞才会触发再次探查（二次探查不是再次探查的意思，而是指探查方式是二次幂），而hash碰撞发生在为值寻找插入位置的过程中，只有确定了这个key还没插入，才会执行真正的插入操作，才会在寻找插入位置的过程中发生再次探查。\n对于任意一个 key 调用 insert，首先会寻找 map 里有没有这个 key，如果找到了就直接更新，没找到才执行真正的插入操作。在真正的插入操作中，先得到 hash，然后找到插入的位置，找位置的过程中就可能发生 hash 碰撞，进而要再次探查下一个可能的位置，二次探查就发生在这个找位置的过程中。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638762012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390032,"avatar":"https://static001.geekbang.org/account/avatar/00/15/35/d0/f2ac6d91.jpg","nickname":"阿成","note":"","ucode":"CEC3CD65FB9333","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536339,"discussion_content":"不过，在确定“map 里有没有这个 key”的过程中，也运用了相同的探查方式来搜索这个key。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638762437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}