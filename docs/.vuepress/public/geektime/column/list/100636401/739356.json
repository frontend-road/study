{"id":739356,"title":"11｜ 多层容器：如何通过实现Context与Wrapper形成多层容器？","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上一节课结束后，我们引入了Container对Servlet进行管理，将原本的Connector功能职责进行拆分，让它专门负责通信的管理。并且在第二个部分中，把Container进一步封装成Wrapper，实现Servlet更加精确、完善的管理。</p><p>事实上，Tomcat把Wrapper也看作一种容器，也就是隶属于Context之下的子容器（Child Container），所以在原理上是存在多层容器的。一个Server对外提供HTTP服务，它的内部支持管理多个虚拟主机，而每个虚拟主机下又有多个应用，在每个应用内又包含多个Servlet。因此Container存在多个，属于层层嵌套的关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/5c/4d787012c15e8034a5167a341c3a0a5c.png?wh=1920x1184\" alt=\"图片\"></p><p>按照Tomcat官方的定义，自外向内分别分为Engine层、Host层、Context层与Wrapper层。我们也参考这个思路，把ServletContainer改成Context，但是我们不打算实现Engine和Host，只用两层Container。</p><p>不考虑使用这么多层Container的主要原因在于，Engine与Host本身的结构复杂，而且其思想已经不再符合现在的主流，现在我们使用了容器技术之后，Engine和Host的概念已经弱化很多了。实际上，当我们部署的时候，一个Tomcat一般就只用一个Engine和一个Host，如果需要多个，就用多个容器。用Context和Wrapper两层容器也可以明白地说明Tomcat的多层容器的概念。</p><!-- [[[read_end]]] --><p>实现了这些功能之后，我们的MiniTomcat也变得有模有样了。但是如果所有的类全部都放在Server包下，显然是不合适的，所以我们还会参考实际的Tomcat项目结构，把各部分代码文件分门别类地整理好。</p><p>接下来我们一起来动手实现。</p><h2>项目结构</h2><p>这节课的项目结构中我们新增Container接口和ContainerBase两个文件，把原来的ServletContainer改名为ServletContext，其他的暂时没有什么变化。</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ server\n│  │  │  │  ├─ Container.java\n│  │  │  │  ├─ ContainerBase.java\n│  │  │  │  ├─ CookieTools.java\n│  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  ├─ HttpConnector.java\n│  │  │  │  ├─ HttpHeader.java\n│  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  ├─ HttpRequest.java\n│  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  ├─ HttpResponse.java\n│  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  ├─ HttpServer.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ ServletContext.java\n│  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  ├─ ServletWrapper.java\n│  │  │  │  ├─ Session.java\n│  │  │  │  ├─ SessionFacade.java\n│  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  ├─ StatisResourceProcessor.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  │  │  ├─ TestServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  │  ├─ TestServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><h2>Context结构改造</h2><p>基于之前的积累，我们先进行一层抽象，定义一个Container类。</p><pre><code class=\"language-java\">package server;\npublic interface Container {\n    public static final String ADD_CHILD_EVENT = \"addChild\";\n    public static final String REMOVE_CHILD_EVENT = \"removeChild\";\n    public String getInfo();\n    public ClassLoader getLoader();\n    public void setLoader(ClassLoader loader);\n    public String getName();\n    public void setName(String name);\n    public Container getParent();\n    public void setParent(Container container);\n    public void addChild(Container child);\n    public Container findChild(String name);\n    public Container[] findChildren();\n    public void invoke(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException;\n    public void removeChild(Container child);\n}\n</code></pre><p>可以看到有Classloader的操作方法、Child和Parent的操作方法，还有invoke等基础方法。</p><p>因为存在多层Container，很多特性是共有的，所以我们再定义ContainerBase作为基础类，你可以看一下ContainerBase的定义。</p><pre><code class=\"language-java\">package server;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\npublic abstract class ContainerBase implements Container {\n    //子容器\n    protected Map&lt;String, Container&gt; children = new ConcurrentHashMap&lt;&gt;();\n    //类加载器\n    protected ClassLoader loader = null;\n    protected String name = null;\n    //父容器\n    protected Container parent = null;\n    \n    //下面是基本的get和set方法\n    public abstract String getInfo();\n    public ClassLoader getLoader() {\n        if (loader != null)\n            return (loader);\n        if (parent != null)\n            return (parent.getLoader());\n        return (null);\n    }\n    public synchronized void setLoader(ClassLoader loader) {\n        ClassLoader oldLoader = this.loader;\n        if (oldLoader == loader) {\n            return;\n        }\n        this.loader = loader;\n    }\n    public String getName() {\n        return (name);\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n    public Container getParent() {\n        return (parent);\n    }\n\n    public void setParent(Container container) {\n        Container oldParent = this.parent;\n        this.parent = container;\n    }\n\n    //下面是对children map的增删改查操作\n    public void addChild(Container child) {\n        addChildInternal(child);\n    }\n    private void addChildInternal(Container child) {\n        synchronized(children) {\n            if (children.get(child.getName()) != null)\n                throw new IllegalArgumentException(\"addChild:  Child name '\" +\n                        child.getName() +\n                        \"' is not unique\");\n            child.setParent((Container) this);  \n            children.put(child.getName(), child);\n        }\n    }\n    public Container findChild(String name) {\n        if (name == null)\n            return (null);\n        synchronized (children) {       // Required by post-start changes\n            return ((Container) children.get(name));\n        }\n    }\n\n    public Container[] findChildren() {\n        synchronized (children) {\n            Container results[] = new Container[children.size()];\n            return ((Container[]) children.values().toArray(results));\n        }\n    }\n    public void removeChild(Container child) {\n        synchronized(children) {\n            if (children.get(child.getName()) == null)\n                return;\n            children.remove(child.getName());\n        }\n        child.setParent(null);\n    }\n}\n</code></pre><p>通过上面这段代码，我们实现了Container接口，提供了部分方法的通用实现。</p><p>接下来要做的，就是把ServletContainer更名为ServletContext，我们需要改动几处内容。</p><p>第一处：HttpServer.java</p><pre><code class=\"language-java\">public class HttpServer {\n    public static final String WEB_ROOT =\n            System.getProperty(\"user.dir\") + File.separator + \"webroot\";\n    public static void main(String[] args) {\n        HttpConnector connector = new HttpConnector();\n        ServletContext container = new ServletContext();\n        connector.setContainer(container);\n        container.setConnector(connector);\n        connector.start();\n    }\n}\n</code></pre><p>这里的Container替换为ServletContext类了。</p><p>第二处：HttpConnector.java</p><pre><code class=\"language-java\">public class HttpConnector implements Runnable {\n    ServletContext container = null;\n    public ServletContext getContainer() {\n        return container;\n    }\n    public void setContainer(ServletContext container) {\n        this.container = container;\n    }\n}\n</code></pre><p>第三处：ServletWrapper.java</p><pre><code class=\"language-java\">public class ServletWrapper extends ContainerBase{\n    private Servlet instance = null;\n    private String servletClass;\n    public ServletWrapper(String servletClass,ServletContext parent) {\n        this.parent = parent;\n        this.servletClass = servletClass;\n        try {\n            loadServlet();\n        } catch (ServletException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>ServletContext是Wrapper的parent。</p><p>调整完类名之后，我们让ServletContext继承ContainerBase基类，ServletWrapper也可以算作Container，所以也继承ContainerBase基类。</p><p>首先是ServletContext.java，你可以看一下我们调整的部分。</p><pre><code class=\"language-java\">package server;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.URLStreamHandler;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\npublic class ServletContext extends ContainerBase{\n    //与本容器关联的connector\n    HttpConnector connector = null;\n    //内部管理的servlet类和实例\n    Map&lt;String,String&gt; servletClsMap = new ConcurrentHashMap&lt;&gt;(); //servletName - ServletClassName\n    Map&lt;String,ServletWrapper&gt; servletInstanceMap = new ConcurrentHashMap&lt;&gt;();//servletName - servletWrapper\n    public ServletContext() {\n        try {\n            // create a URLClassLoader\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(HttpServer.WEB_ROOT);\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            urls[0] = new URL(null, repository, streamHandler);\n            loader = new URLClassLoader(urls);\n        } catch (IOException e) {\n            System.out.println(e.toString() );\n        }\n    }\n    public String getInfo() {\n        return \"Minit Servlet Context, vesion 0.1\";\n    }\n    public HttpConnector getConnector() {\n        return connector;\n    }\n    public void setConnector(HttpConnector connector) {\n        this.connector = connector;\n    }\n    //调用servlet的方法\n    public void invoke(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        ServletWrapper servletWrapper = null;\n        String uri = ((HttpRequest)request).getUri();\n        String servletName = uri.substring(uri.lastIndexOf(\"/\") + 1);\n        String servletClassName = servletName;\n        //从容器中获取servlet wrapper\n        servletWrapper = servletInstanceMap.get(servletName);\n        if ( servletWrapper == null) {\n            servletWrapper = new ServletWrapper(servletClassName,this);\n            //servletWrapper.setParent(this);\n            this.servletClsMap.put(servletName, servletClassName);\n            this.servletInstanceMap.put(servletName, servletWrapper);\n        }\n        //将调用传递到下层容器即wrapper中\n        try {\n            HttpServletRequest requestFacade = new HttpRequestFacade(request);\n            HttpServletResponse responseFacade = new HttpResponseFacade(response);\n            System.out.println(\"Call service()\");\n            servletWrapper.invoke(requestFacade, responseFacade);\n        }\n        catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        catch (Throwable e) {\n            System.out.println(e.toString());\n        }\n    }\n}\n</code></pre><p>上述代码中，HttpRequestFacade和HttpResponseFacade两个类的构造函数的入参和invoke方法保持一致，也需要对应地做一些调整。</p><pre><code class=\"language-java\">package server;\npublic class HttpRequestFacade implements HttpServletRequest {\n    public HttpRequestFacade(HttpServletRequest request) {\n        this.request = request;\n    }\n}\n</code></pre><pre><code class=\"language-java\">package server;\npublic class HttpResponseFacade implements HttpServletResponse {\n    public HttpResponseFacade(HttpServletResponse response) {\n        this.response = response;\n    }\n}\n</code></pre><p>接下来我们关注一下ServletWrapper类的调整。</p><pre><code class=\"language-java\">package server;\npublic class ServletWrapper extends ContainerBase{\n    //wrapper内含了一个servlet实例和类\n    private Servlet instance = null;\n    private String servletClass;\n    \n    public ServletWrapper(String servletClass,ServletContext parent) {\n        //以ServletContext为parent\n        this.parent = parent;\n        this.servletClass = servletClass;\n        try {\n            loadServlet();\n        } catch (ServletException e) {\n            e.printStackTrace();\n        }\n    }\n    public String getServletClass() {\n        return servletClass;\n    }\n    public void setServletClass(String servletClass) {\n        this.servletClass = servletClass;\n    }\n    public Servlet getServlet(){\n        return this.instance;\n    }\n    //load servlet类，创建新实例，并调用init()方法\n    public Servlet loadServlet() throws ServletException {\n        if (instance!=null)\n            return instance;\n        Servlet servlet = null;\n        String actualClass = servletClass;\n        if (actualClass == null) {\n            throw new ServletException(\"servlet class has not been specified\");\n        }\n        ClassLoader classLoader = getLoader();\n        Class classClass = null;\n        try {\n            if (classLoader!=null) {\n                classClass = classLoader.loadClass(actualClass);\n            }\n        }\n        catch (ClassNotFoundException e) {\n            throw new ServletException(\"Servlet class not found\");\n        }\n        try {\n            servlet = (Servlet) classClass.newInstance();\n        }\n        catch (Throwable e) {\n            throw new ServletException(\"Failed to instantiate servlet\");\n        }\n        try {\n            servlet.init(null);\n        }\n        catch (Throwable f) {\n            throw new ServletException(\"Failed initialize servlet.\");\n        }\n        instance =servlet;\n        return servlet;\n    }\n    //wrapper是最底层容器，调用将转化为service()方法\n    public void invoke(HttpServletRequest request, HttpServletResponse response)\n            throws IOException, ServletException {\n        if (instance != null) {\n            instance.service(request, response);\n        }\n    }\n    @Override\n    public String getInfo() {\n        return \"Minit Servlet Wrapper, version 0.1\";\n    }\n    public void addChild(Container child) {}\n    public Container findChild(String name) {return null;}\n    public Container[] findChildren() {return null;}\n    public void removeChild(Container child) {}\n}\n</code></pre><p>ServletWrapper继承了ContainerBase抽象类，主要有两个变化。</p><ol>\n<li>原本定义的loader、name、parent域直接使用ContainerBase里的定义。</li>\n<li>实现getInfo、addChild、findChild、findChildren、removeChild方法。</li>\n</ol><p>到这里我们就改造完了。</p><h2>向Tomcat目录对齐</h2><p>在这一部分我们开始参考Tomcat的目录结构，来梳理MiniTomcat的程序结构。在Tomcat的项目结构中，主要的类都放在org.apache.catalina包里，基本的子包有startup、core、connector、loader、logger、session和util等等。</p><p>我们也参考这个结构，把大的包命名为com.minit，在这个包下构建startup、core、connector、loader、logger、session、util多个子包。</p><p>为了更加规范，我们在com.minit包下新增几个接口：Connector、Context、Wrapper、Request、Response、Session、Container。其中Container直接复用之前定义的同名接口，原本定义的Request与Response两个类不再需要使用，可以直接删除。</p><p>同时，修改下面这些类的名字并实现上述接口，尽可能和Tomcat保持一致。</p><pre><code class=\"language-plain\">ServletContext改为StandardContext\nServletWrapper改为StandardWrapper\nSession改为StandardSession\nSessionFacade改为StandardSessionFacade\nHttpRequest改为HttpRequestImpl\nHttpResponse改为HttpResponseImpl\nHttpServer改为Bootstrap\n</code></pre><p>改造后的项目结构如下：</p><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ com\n│  │  │  │  ├─ minit\n│  │  │  │  │  ├─ connector\n│  │  │  │  │  │  ├─ http\n│  │  │  │  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  │  │  │  ├─ HttpConnector.java\n│  │  │  │  │  │  │  ├─ HttpHeader.java\n│  │  │  │  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  │  │  │  ├─ HttpRequestImpl.java\n│  │  │  │  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  │  │  │  ├─ HttpResponseImpl.java\n│  │  │  │  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  │  │  │  ├─ StatisResourceProcessor.java\n│  │  │  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  │  ├─ core\n│  │  │  │  │  │  ├─ ContainerBase.java\n│  │  │  │  │  │  ├─ StandardContext.java\n│  │  │  │  │  │  ├─ StandardWrapper.java\n│  │  │  │  │  ├─ logger\n│  │  │  │  │  ├─ session\n│  │  │  │  │  │  ├─ StandardSession.java\n│  │  │  │  │  │  ├─ StandardSessionFacade.java\n│  │  │  │  │  ├─ startup\n│  │  │  │  │  │  ├─ Bootstrap.java\n│  │  │  │  │  ├─ util\n│  │  │  │  │  │  ├─ CookieTools.java\n│  │  │  │  ├─ Connector.java\n│  │  │  │  ├─ Container.java\n│  │  │  │  ├─ Contexts.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Responses.java\n│  │  │  │  ├─ Session.java\n│  │  │  │  ├─ Wrapper.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  │  │  ├─ TestServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ test\n│  │  ├─ HelloServlet.class\n│  │  ├─ TestServlet.class\n│  ├─ hello.txt\n├─ pom.xml\n</code></pre><p>接下来我们分别定义Connector、Context、Wrapper、Request、Response、Session这几个接口。</p><p>Connector.java：</p><pre><code class=\"language-java\">package com.minit;\npublic interface Connector {\n    public Container getContainer();\n    public void setContainer(Container container);\n    public String getInfo();\n    public String getScheme();\n    public void setScheme(String scheme);\n    public Request createRequest();\n    public Response createResponse();\n    public void initialize();\n}\n</code></pre><p>Context.java：</p><pre><code class=\"language-java\">package com.minit;\npublic interface Context extends Container {\n    public static final String RELOAD_EVENT = \"reload\";\n    public String getDisplayName();\n    public void setDisplayName(String displayName);\n    public String getDocBase();\n    public void setDocBase(String docBase);\n    public String getPath();\n    public void setPath(String path);\n    public ServletContext getServletContext();\n    public int getSessionTimeout();\n    public void setSessionTimeout(int timeout);\n    public String getWrapperClass();\n    public void setWrapperClass(String wrapperClass);\n    public Wrapper createWrapper();\n    public String findServletMapping(String pattern);\n    public String[] findServletMappings();\n    public void reload();\n}\n</code></pre><p>Wrapper.java：</p><pre><code class=\"language-java\">package com.minit;\npublic interface Wrapper {\n    public int getLoadOnStartup();\n    public void setLoadOnStartup(int value);\n    public String getServletClass();\n    public void setServletClass(String servletClass);\n    public void addInitParameter(String name, String value);\n    public Servlet allocate() throws ServletException;\n    public String findInitParameter(String name);\n    public String[] findInitParameters();\n    public void load() throws ServletException;\n    public void removeInitParameter(String name);\n}\n</code></pre><p>Request.java：</p><pre><code class=\"language-java\">package com.minit;\npublic interface Request {\n    public Connector getConnector();\n    public void setConnector(Connector connector);\n    public Context getContext();\n    public void setContext(Context context);\n    public String getInfo();\n    public ServletRequest getRequest();\n    public Response getResponse();\n    public void setResponse(Response response);\n    public Socket getSocket();\n    public void setSocket(Socket socket);\n    public InputStream getStream();\n    public void setStream(InputStream stream);\n    public Wrapper getWrapper();\n    public void setWrapper(Wrapper wrapper);\n    public ServletInputStream createInputStream() throws IOException;\n    public void finishRequest() throws IOException;\n    public void recycle();\n    public void setContentLength(int length);\n    public void setContentType(String type);\n    public void setProtocol(String protocol);\n    public void setRemoteAddr(String remote);\n    public void setScheme(String scheme);\n    public void setServerPort(int port);\n}\n</code></pre><p>Response.java：</p><pre><code class=\"language-java\">package com.minit;\npublic interface Response {\n    public Connector getConnector();\n    public void setConnector(Connector connector);\n    public int getContentCount();\n    public Context getContext();\n    public void setContext(Context context);\n    public String getInfo();\n    public Request getRequest();\n    public void setRequest(Request request);\n    public ServletResponse getResponse();\n    public OutputStream getStream();\n    public void setStream(OutputStream stream);\n    public void setError();\n    public boolean isError();\n    public ServletOutputStream createOutputStream() throws IOException;\n    public void finishResponse() throws IOException;\n    public int getContentLength();\n    public String getContentType();\n    public PrintWriter getReporter();\n    public void recycle();\n    public void resetBuffer();\n    public void sendAcknowledgement() throws IOException;\n}\n\n</code></pre><p>Session.java：</p><pre><code class=\"language-java\">package com.minit;\npublic interface Session {\n    public static final String SESSION_CREATED_EVENT = \"createSession\";\n    public static final String SESSION_DESTROYED_EVENT = \"destroySession\";\n    public long getCreationTime();\n    public void setCreationTime(long time);\n    public String getId();\n    public void setId(String id);\n    public String getInfo();\n    public long getLastAccessedTime();\n    public int getMaxInactiveInterval();\n    public void setMaxInactiveInterval(int interval);\n    public void setNew(boolean isNew);\n    public HttpSession getSession();\n    public void setValid(boolean isValid);\n    public boolean isValid();\n    public void access();\n    public void expire();\n    public void recycle();\n}\n</code></pre><p>最后再给StandardContext、StandardWrapper和StandardSession分别实现Context、Wrapper与Session接口，这节课的改造就实现完了。最后我们再来看一下调整后需要新增的实现方法。</p><p>StandardContext.java：</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardContext extends ContainerBase implements Context {\n    @Override\n    public String getDisplayName() {\n        return null;\n    }\n    @Override\n    public void setDisplayName(String displayName) {\n    }\n    @Override\n    public String getDocBase() {\n        return null;\n    }\n    @Override\n    public void setDocBase(String docBase) {\n    }\n    @Override\n    public String getPath() {\n        return null;\n    }\n    @Override\n    public void setPath(String path) {\n    }\n    @Override\n    public ServletContext getServletContext() {\n        return null;\n    }\n    @Override\n    public int getSessionTimeout() {\n        return 0;\n    }\n    @Override\n    public void setSessionTimeout(int timeout) {\n    }\n    @Override\n    public String getWrapperClass() {\n        return null;\n    }\n    @Override\n    public void setWrapperClass(String wrapperClass) {\n    }\n    @Override\n    public Wrapper createWrapper() {\n        return null;\n    }\n    @Override\n    public String findServletMapping(String pattern) {\n        return null;\n    }\n    @Override\n    public String[] findServletMappings() {\n        return null;\n    }\n    @Override\n    public void reload() {\n    }\n}\n</code></pre><p>StandardWrapper.java：</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardWrapper extends ContainerBase implements Wrapper {\n   @Override\n    public int getLoadOnStartup() {\n        return 0;\n    }\n    @Override\n    public void setLoadOnStartup(int value) {\n    }\n    @Override\n    public void addInitParameter(String name, String value) {\n    }\n    @Override\n    public Servlet allocate() throws ServletException {\n        return null;\n    }\n    @Override\n    public String findInitParameter(String name) {\n        return null;\n    }\n    @Override\n    public String[] findInitParameters() {\n        return null;\n    }\n    @Override\n    public void load() throws ServletException {\n    }\n    @Override\n    public void removeInitParameter(String name) {\n    }\n}\n</code></pre><p>StandardSession.java：</p><pre><code class=\"language-java\">package com.minit.session;\npublic class StandardSession implements HttpSession, Session {\n   @Override\n    public String getInfo() {\n        return null;\n    }\n    @Override\n    public void setNew(boolean isNew) {\n    }\n    @Override\n    public HttpSession getSession() {\n        return null;\n    }\n    @Override\n    public boolean isValid() {\n        return false;\n    }\n    @Override\n    public void access() {\n    }\n    @Override\n    public void expire() {\n    }\n    @Override\n    public void recycle() {\n    }\n}\n</code></pre><p>到这里我们就完成了项目结构的改造，可以看出，MiniTomcat和Tomcat已经长得比较像了。</p><h2>测试</h2><p>这节课没有新增什么对外的功能，所以测试还是和之前的测试方式一样。</p><h2>小结</h2><p>这节课我们把项目结构进一步抽象成了两层Container，分别是Context和Wrapper，Context对应于我们平常所说的一个应用，Wrapper是对应的一个Servlet的包装。在Context这个容器中有一个map包含了多个Wrapper，这样构成了父子容器的两层结构。</p><p>然后我们进一步通用化，提出ContainerBase，只要一个类基于base，就可以当成一个新的容器。通过这些手段实现了一个服务器管理多个容器，而容器又可以管理多个Servlet，层层嵌套，实现系统结构的扩展和管理清晰化。然后在此基础上，参考Tomcat的项目结构，进行对应调整，让它更贴近Tomcat源码本身。这样一来，你去阅读Tomcat源码，难度就会大大降低。</p><p>这节课代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter11\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter11</a></p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：我们现在的代码中，servletContext的invoke()方法仅仅只是简单地调用了子容器Wrapper的invoke()，但是原则上每一层的容器的invoke()可以另外加入本层容器特殊的逻辑，有没有合适的设计方案？</p><p>欢迎你把你想到的方案分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":386112,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1704117766,"is_pvip":false,"replies":[{"id":140774,"content":"用不同的域名表示不同主机，其实是虚拟主机\n将connector和host容器组合在一起的就是engine，由它来实现对外的service","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1704206287,"ip_address":"湖南","comment_id":386112,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师两个问题：\nQ1：Tomcat中怎么表示多个Host？用不同的IP吗？\nQ2：Engine主要功能是什么？感觉所有的主要功能都已经包含在连接处理、servlet处理了，还能有什么比较大的功能由Engine来处理？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634946,"discussion_content":"用不同的域名表示不同主机，其实是虚拟主机\n将connector和host容器组合在一起的就是engine，由它来实现对外的service","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704206287,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386090,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1704071708,"is_pvip":false,"replies":[{"id":140773,"content":"我最初也是这么想的，用interceptor，这么做是可以的。而Tomcat用了pipeline，结构更加宏大。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1704205210,"ip_address":"湖南","comment_id":386090,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"加入本层特殊逻辑，我的想法是加入一个前置方法和后置方法， 并且子类可以重写这两个方法。","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634945,"discussion_content":"我最初也是这么想的，用interceptor，这么做是可以的。而Tomcat用了pipeline，结构更加宏大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704205211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1133678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","nickname":"HH🐷🐠","note":"","ucode":"C50172BDA604D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634961,"discussion_content":"😄我得好好见识一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704241625,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634945,"ip_address":"广东","group_id":0},"score":634961,"extra":""}]}]},{"had_liked":false,"id":390914,"user_name":"偶来人间，风度翩翩","can_delete":false,"product_type":"c1","uid":1768374,"ip_address":"江苏","ucode":"DDABD0E3EB7104","user_header":"https://static001.geekbang.org/account/avatar/00/1a/fb/b6/728e2d02.jpg","comment_is_top":false,"comment_ctime":1716735345,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"文章一开头说的【并且在第二个部分中，把 Container 进一步封装成 Wrapper，实现 Servlet 更加精确、完善的管理。】，是不是应该是【把 Servlet 进一步封装成 Wrapper，】呀？","like_count":0}]}