{"id":741815,"title":"14｜多应用支持：拆分Context、BootStrap与路由转发","content":"<p>你好，我是郭屹。今天我们继续手写MiniTomcat。</p><p>上节课我们新增了<strong>过滤器Filter和监听器Listener</strong>。利用过滤器，对每一层的对象依次进行处理，最终构建出请求对象和返回对象；而监听器的存在，则是为了配合我们目前已有的Container、Session等机制，通过监听相关的事件，比如启动、超时、结束等，更好地对服务器进行管理。</p><p>目前我们的测试代码，都写在/webroot目录下，但如果有不同的应用，那就都混合在同一路径下了，这样不利于管理。所以这节课我们进一步考虑<strong>支持多路由的转发</strong>，通过路径的区分，将请求转发到不同应用之中，我们会引入<strong>Context</strong>这个概念来实现应用的相互隔离。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/b7/2c646316dc669f18ef13998bc56065b7.png?wh=1920x1119\" alt=\"图片\"></p><p>如图所示，用户在url中分别输入路径hello/和another/，这就代表了两个不同的context，以此路径分别定位于不同的应用中。</p><p>在此基础上，我们再优化Bootstrap，去除多余的功能，确保它只是一个启动器，贯彻各司其职的设计理念。</p><p>下面我们一起来动手实现。</p><h2>项目结构</h2><p>这节课我们主要新增了StandardHost、StandardHostValve，以及WebappClassClassLoader类。还有一个重要的变化是在/webroot目录下新增app1和app2目录，用来区分不同的应用。你可以看一下改动后的项目结构。</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">MiniTomcat\n├─ src\n│  ├─ main\n│  │  ├─ java\n│  │  │  ├─ com\n│  │  │  │  ├─ minit\n│  │  │  │  │  ├─ connector\n│  │  │  │  │  │  ├─ http\n│  │  │  │  │  │  │  ├─ DefaultHeaders.java\n│  │  │  │  │  │  │  ├─ HttpConnector.java\n│  │  │  │  │  │  │  ├─ HttpHeader.java\n│  │  │  │  │  │  │  ├─ HttpProcessor.java\n│  │  │  │  │  │  │  ├─ HttpRequestImpl.java\n│  │  │  │  │  │  │  ├─ HttpRequestLine.java\n│  │  │  │  │  │  │  ├─ HttpResponseImpl.java\n│  │  │  │  │  │  │  ├─ ServletProcessor.java\n│  │  │  │  │  │  │  ├─ SocketInputStream.java\n│  │  │  │  │  │  │  ├─ StatisResourceProcessor.java\n│  │  │  │  │  │  ├─ HttpRequestFacade.java\n│  │  │  │  │  │  ├─ HttpResponseFacade.java\n│  │  │  │  │  ├─ core\n│  │  │  │  │  │  ├─ ApplicationFilterChain.java\n│  │  │  │  │  │  ├─ ApplicationFilterConfig.java\n│  │  │  │  │  │  ├─ ContainerBase.java\n│  │  │  │  │  │  ├─ ContainerListenerDef.java\n│  │  │  │  │  │  ├─ FilterDef.java\n│  │  │  │  │  │  ├─ FilterMap.java\n│  │  │  │  │  │  ├─ StandardContext.java\n│  │  │  │  │  │  ├─ StandardContextValve.java\n│  │  │  │  │  │  ├─ StandardHost.java\n│  │  │  │  │  │  ├─ StandardHostValve.java\n│  │  │  │  │  │  ├─ StandardPipeline.java\n│  │  │  │  │  │  ├─ StandardWrapper.java\n│  │  │  │  │  │  ├─ StandardWrapperValve.java\n│  │  │  │  │  │  ├─ WebappClassLoader.java\n│  │  │  │  │  ├─ logger\n│  │  │  │  │  │  ├─ Constants.java\n│  │  │  │  │  │  ├─ FileLogger.java\n│  │  │  │  │  │  ├─ LoggerBase.java\n│  │  │  │  │  │  ├─ SystemErrLogger.java\n│  │  │  │  │  │  ├─ SystemOutLogger.java\n│  │  │  │  │  ├─ session\n│  │  │  │  │  │  ├─ StandardSession.java\n│  │  │  │  │  │  ├─ StandardSessionFacade.java\n│  │  │  │  │  ├─ startup\n│  │  │  │  │  │  ├─ BootStrap.java\n│  │  │  │  │  ├─ util\n│  │  │  │  │  │  ├─ CookieTools.java\n│  │  │  │  │  │  ├─ StringManager.java\n│  │  │  │  │  │  ├─ URLDecoder.java\n│  │  │  │  │  ├─ valves\n│  │  │  │  │  │  ├─ AccessLogValve.java\n│  │  │  │  │  │  ├─ ValveBase.java\n│  │  │  │  ├─ Connector.java\n│  │  │  │  ├─ Container.java\n│  │  │  │  ├─ ContainerEvent.java\n│  │  │  │  ├─ ContainerListener.java\n│  │  │  │  ├─ Context.java\n│  │  │  │  ├─ InstanceEvent.java\n│  │  │  │  ├─ InstanceListener.java\n│  │  │  │  ├─ Logger.java\n│  │  │  │  ├─ Pipeline.java\n│  │  │  │  ├─ Request.java\n│  │  │  │  ├─ Response.java\n│  │  │  │  ├─ Session.java\n│  │  │  │  ├─ SessionEvent.java\n│  │  │  │  ├─ SessionListener.java\n│  │  │  │  ├─ Valve.java\n│  │  │  │  ├─ ValveContext.java\n│  │  │  │  ├─ Wrapper.java\n│  │  ├─ resources\n│  ├─ test\n│  │  ├─ java\n│  │  │  ├─ test\n│  │  │  │  ├─ HelloServlet.java\n│  │  │  │  ├─ TestFilter.java\n│  │  │  │  ├─ TestListener.java\n│  │  │  │  ├─ TestServlet.java\n│  │  ├─ resources\n├─ webroot\n│  ├─ app1\n│  │  ├─ test\n│  │  │  ├─ HelloServlet.class\n│  │  │  ├─ TestFilter.class\n│  │  │  ├─ TestListener.class\n│  │  │  ├─ TestServlet.class\n│  │  ├─ hello.txt\n│  ├─ app2\n│  │  ├─ test\n│  │  │  ├─ HelloServlet.class\n│  │  │  ├─ TestFilter.class\n│  │  │  ├─ TestListener.class\n│  │  │  ├─ TestServlet.class\n│  │  ├─ hello.txt\n├─ pom.xml\n</code></pre><h2>引入多应用</h2><p>接下来我们开始正式进行多应用的改造，在改造前我们引入一个新的ClassLoader——WebappClassLoader，为后续应用拆分以及自定义类加载器做准备，你可以看一下WebappClassLoader的定义。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class WebappClassLoader {\n    ClassLoader classLoader;\n    String path;\n    String docbase;\n    Container container;\n    public Container getContainer() {\n        return container;\n    }\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n    public String getPath() {\n        return path;\n    }\n    public void setPath(String path) {\n        this.path = path;\n    }\n    public String getDocbase() {\n        return docbase;\n    }\n    public void setDocbase(String docbase) {\n        this.docbase = docbase;\n    }\n    public WebappClassLoader() {\n    }\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n    public String getInfo() {\n        return \"A simple loader\";\n    }\n    public void addRepository(String repository) {\n    }\n    public String[] findRepositories() {\n        return null;\n    }\n    public synchronized void start() {\n        System.out.println(\"Starting WebappLoader\");\n        try {\n            // 创建一个 URLClassLoader\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(System.getProperty(\"minit.base\"));\n            String repository = (new URL(\"file\", null, classPath.getCanonicalPath() + File.separator)).toString() ;\n            if (docbase!=null &amp;&amp; !docbase.equals(\"\")) {\n                repository = repository + docbase + File.separator;\n            }\n            urls[0] = new URL(null, repository, streamHandler);\n            System.out.println(\"Webapp classloader Repository : \"+repository);\n            classLoader = new URLClassLoader(urls);\n        }\n        catch (Exception e) {\n            System.out.println(e.toString() );\n        }\n    }\n    public void stop() {\n    }\n}\n</code></pre><p>从代码我们可以看出，一个WebappClassLoader主要包含了几个要素：classLoader、docBase、container。这个classLoader其实就是一个URLClassLoader，它的工作目录由docBase来决定。</p><p>要实现项目中/webroot目录下的多应用解析，在我们的实现里，其实对使用者而言就相当于目录上多了一个Context层级，比如请求 <code>http://localhost:8080/app1/servlet/test.TestServlet</code>，主机地址后面的app1就是context，这样可以有两个版本不一样的test.TestServlet，比如说另一个的请求地址为 <code>http://localhost:8080/app2/servlet/test.TestServlet</code>。</p><p>我们需要利用到的，正是刚刚我们定义的WebappClassLoader，由它来加载应用里的客户类。每一个WebappClassLoader都有一个docBase，比如例子里的app1或者app2，也就是context的目录。每一个context都对应一个不同的WebappClassLoader，根据Java类的管理机制，<strong>这些不同的classloader之间是<strong><strong>互相</strong></strong>隔离的，所以这些context代表的应用之间也就是互相隔离的</strong>，这就达到了我们的目的。</p><p>Java的这个机制是：不同classloader加载的类在JVM看来是两个不同的类，因为<strong>在JVM里一个类的唯一标识是classloader+类名</strong>。通过这种方式我们就能够实现类之间的隔离，甚至可以同时加载某个类的两个不同版本。</p><p>我们结合图示来看一下Tomcat通过Context达到应用隔离的原理。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/48/81c30e57bf4511120f9ca9ba6dd71048.png?wh=1920x1244\" alt=\"图片\"></p><p>而整个服务器的根工作目录存放在 <code>System.getProperty(\"minit.base\")</code> 里，这个property是BootStrap启动时指定的，所以在BootStrap中我们要定义 <code>System.setProperty(\"minit.base\", WEB_ROOT);</code>。</p><p>举个例子，如果Minit放在d:/minit目录下，那么WEB_ROOT目录为d:/minit/webroot，而app1的webclassloader的docbase是app1, 那么它加载的目录就是d:/minit/webroot/app1/。</p><h2>新的URI解析</h2><p>有了上面的WebappClassLoader作为基础，我们再来管理后端应用程序，从用户的角度来看，当他在客户端输入的URL是 <code>http://localhost:8080/app1/servlet/test.TestServlet</code> 的时候，我们要修改解析URL的程序，需要把URI解析成/servlet/test.TestServlet的这部分，修改成/app1/servlet/test.TestServlet，这样就能识别出这个servlet是哪一个context下的了。</p><p>这个步骤的实现，我们放在HttpRequestImpl.parseRequestLine()这个方法中调整，你可以看一下具体调整的核心代码。</p><pre><code class=\"language-java\">//get context from uri\nint contextslash = uri.indexOf(\"/\", 1);\nif (contextslash != -1) {\n    this.docbase = uri.substring(1, contextslash);\n    uri = uri.substring(contextslash);\n}\n</code></pre><p>其实比较简单，就是按照字符串分隔符来完成这个工作。你再来看完整的parseRequestLine()方法，在两个判断条件中都增加了解析实现。</p><pre><code class=\"language-java\">package com.minit.connector.http;\npublic class HttpRequestImpl implements HttpServletRequest, Request {\n    String docbase;\n    public String getDocbase() {\n        return docbase;\n    }\n    public void setDocbase(String docbase) {\n        this.docbase = docbase;\n    }\n\n    private void parseRequestLine() {\n        int question = requestLine.indexOf(\"?\");\n        if (question &gt;= 0) {\n            queryString = new String(requestLine.uri, question + 1, requestLine.uriEnd - question - 1);\n            uri = new String(requestLine.uri, 0, question);\n            String tmp = \";\" + DefaultHeaders.JSESSIONID_NAME + \"=\";\n            int semicolon = uri.indexOf(tmp);\n            if (semicolon &gt;= 0) {\n                sessionid = uri.substring(semicolon+tmp.length());\n                uri = uri.substring(0, semicolon);\n            }\n            int contextslash = uri.indexOf(\"/\", 1);\n            if (contextslash != -1) {\n                this.docbase = uri.substring(1, contextslash);\n                uri = uri.substring(contextslash);\n            }\n        } else {\n            queryString = null;\n            uri = new String(requestLine.uri, 0, requestLine.uriEnd);\n            String tmp = \";\" + DefaultHeaders.JSESSIONID_NAME + \"=\";\n            int semicolon = uri.indexOf(tmp);\n            if (semicolon &gt;= 0) {\n                sessionid = uri.substring(semicolon+tmp.length());\n                uri = uri.substring(0, semicolon);\n            }\n            int contextslash = uri.indexOf(\"/\", 1);\n            if (contextslash != -1) {\n                this.docbase = uri.substring(1, contextslash);\n                uri = uri.substring(contextslash);\n            }\n        }\n    }\n}\n</code></pre><p>到这里多应用的改造就告一段落了。</p><h2>独立服务器Host</h2><p>接下来我们还要继续精简启动类的工作，目前启动类BootStrap里，已经集成了监听器和过滤器的启动工作，其实这些都是服务器的功能，我们要进一步简化。我们的思路是把BootStrap仅仅当成一个服务器的启动器，它本身不是服务器，所以我们这里就要把服务器的功能代码从BootStrap中抽到一个服务器中，我们可以把实现服务器的代码定义在StandardHost类里面，你可以看一下代码。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardHost extends ContainerBase{\n    HttpConnector connector = null;\n    //host中用一个map存储了所管理的context，一个context代表了一个独立的web应用\n    Map&lt;String,StandardContext&gt; contextMap = new ConcurrentHashMap&lt;&gt;();//contextName - servletContext\n    //下面的listener是host本身的监听\n    private ArrayList&lt;ContainerListenerDef&gt; listenerDefs = new ArrayList&lt;&gt;();\n    private ArrayList&lt;ContainerListener&gt; listeners = new ArrayList&lt;&gt;();\n    public StandardHost(){\n        super();\n        pipeline.setBasic(new StandardHostValve());\n        log(\"Host created.\");\n    }\n    public String getInfo() {\n        return \"Minit host, vesion 0.1\";\n    }\n    public HttpConnector getConnector() {\n        return connector;\n    }\n    public void setConnector(HttpConnector connector) {\n        this.connector = connector;\n    }\n    public void invoke(Request request, Response response)\n            throws IOException, ServletException {\n        System.out.println(\"StandardHost invoke()\");\n        super.invoke(request, response);\n    }\n    //从host中根据context名(路径名)找到对应的context\n    //如果找不到就新建一个context\n    public StandardContext getContext(String name){\n        StandardContext context = contextMap.get(name);\n        if ( context == null) {\n            //创建新的context，有自己独立的根目录和类加载器\n            context = new StandardContext();\n            context.setDocBase(name);\n            context.setConnector(connector);\n            WebappClassLoader loader = new WebappClassLoader();\n            context.setLoader(loader);\n            loader.start();\n            this.contextMap.put(name, context);\n        }\n        return context;\n    }\n    //host的启动方法，现在没有做什么事情，仅仅是启用监听器\n    //在MiniTomcat中，Host是一个极简化的形态\n    public void start(){\n        fireContainerEvent(\"Host Started\",this);\n        Logger logger = new FileLogger();\n        setLogger(logger);\n        ContainerListenerDef listenerDef = new ContainerListenerDef();\n        listenerDef.setListenerName(\"TestListener\");\n        listenerDef.setListenerClass(\"test.TestListener\");\n        addListenerDef(listenerDef);\n        listenerStart();\n    }\n    public void addContainerListener(ContainerListener listener) {\n        synchronized (listeners) {\n            listeners.add(listener);\n        }\n    }\n    public void removeContainerListener(ContainerListener listener) {\n        synchronized (listeners) {\n            listeners.remove(listener);\n        }\n    }\n    public void fireContainerEvent(String type, Object data) {\n        if (listeners.size() &lt; 1)\n            return;\n        ContainerEvent event = new ContainerEvent(this, type, data);\n        ContainerListener list[] = new ContainerListener[0];\n        synchronized (listeners) {\n            list = (ContainerListener[]) listeners.toArray(list);\n        }\n        for (int i = 0; i &lt; list.length; i++)\n            ((ContainerListener) list[i]).containerEvent(event);\n    }\n    public void addListenerDef(ContainerListenerDef listenererDef) {\n        synchronized (listenerDefs) {\n            listenerDefs.add(listenererDef);\n        }\n    }\n    //初始化监听器\n    public boolean listenerStart() {\n        System.out.println(\"Listener Start..........\");\n        boolean ok = true;\n        synchronized (listeners) {\n            listeners.clear();\n            Iterator&lt;ContainerListenerDef&gt; defs = listenerDefs.iterator();\n            while (defs.hasNext()) {\n                ContainerListenerDef def = defs.next();\n                ContainerListener listener = null;\n                try {\n                    // Identify the class loader we will be using\n                    String listenerClass = def.getListenerClass();\n                    WebappClassLoader classLoader = null;\n                    //host对应的loader就是listener的loader\n                    classLoader = this.getLoader();\n                    ClassLoader oldCtxClassLoader =\n                            Thread.currentThread().getContextClassLoader();\n                    // Instantiate a new instance of this filter and return it\n                    Class&lt;?&gt; clazz = classLoader.getClassLoader().loadClass(listenerClass);\n                    listener = (ContainerListener) clazz.newInstance();\n                    addContainerListener(listener);\n                } catch (Throwable t) {\n                    t.printStackTrace();\n                    ok = false;\n                }\n            }\n        }\n        return (ok);\n    }\n}\n</code></pre><p>我们可以看到，我们新加的这个StandardHost里面包含了一个connector和下一级容器Context，另外Listener也由StandardHost来启动。Host本身也可以看成是一个大的容器，按照Tomcat的做法，相应地定义Valve。</p><pre><code class=\"language-java\">package com.minit.core;\npublic class StandardHostValve extends ValveBase{\n    @Override\n    public void invoke(Request request, Response response, ValveContext context) throws IOException, ServletException {\n        System.out.println(\"StandardHostValve invoke()\");\n        String docbase = ((HttpRequestImpl)request).getDocbase();\n        System.out.println(\"StandardHostValve invoke getdocbase : \" + docbase);\n        StandardHost host = (StandardHost)getContainer();\n        StandardContext servletContext = host.getContext(docbase);\n        try {\n            servletContext.invoke(request, response);\n        }\n        catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        catch (Throwable e) {\n            System.out.println(e.toString());\n        }\n    }\n}\n</code></pre><p>通过StandardHost类我们可以看到，许多以前在启动类中的代码都移到这个类里了。过滤器的启动被划在filterStart方法里了，而监听器的启动则由listenerStart方法负责，在调用StandardHost类中的start方法的时候，会调用这两个方法。</p><p>这时候，我们就可以把BootStrap中一大段服务器功能的实现，替换成使用Host，你可以看一下替换后的main方法。</p><pre><code class=\"language-java\">public static void main(String[] args) {\n    if (debug &gt;= 1)\n        log(\".... startup ....\");\n    System.setProperty(\"minit.base\", WEB_ROOT);\n    HttpConnector connector = new HttpConnector();\n    StandardHost container = new StandardHost();\n    WebappClassLoader loader = new WebappClassLoader();\n    container.setLoader(loader);\n    loader.start();\n    connector.setContainer(container);\n    container.setConnector(connector);\n    container.start();\n    connector.start();\n}\n</code></pre><p>这个时候StandardHost的start方法已经把之前的启动代码都涵盖了。可以看到这个BootStrap现在很简单，真的只是一个启动器。</p><h2>测试</h2><p>在这节课的测试中，我们先把原来/webroot目录下的文件全部移动到/webroot/app1里，随后我们修改TestServlet，人为地造出两个不同的应用，你可以看一下TestServlet修改后的代码。</p><pre><code class=\"language-java\">package test;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\npublic class TestServlet extends HttpServlet{\n    static int count = 0;\n    private static final long serialVersionUID = 1L;\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {\n        System.out.println(\"Another TestServlet Enter doGet()\");\n        System.out.println(\"Another TestServlet  parameter name : \"+request.getParameter(\"name\"));\n        TestServlet.count++;\n        System.out.println(\"::::::::Another TestServlet call count ::::::::: \" + TestServlet.count);\n        if (TestServlet.count&gt;2) {\n            response.addHeader(\"Connection\", \"close\");\n        }\n        HttpSession session = request.getSession(true);\n        String user = (String) session.getAttribute(\"user\");\n        System.out.println(\"get user from session : \" + user);\n        if (user == null || user.equals(\"\")) {\n            session.setAttribute(\"user\", \"yale\");\n        }\n\n        response.setCharacterEncoding(\"UTF-8\");\n        String doc = \"&lt;!DOCTYPE html&gt; \\n\" +\n                \"&lt;html&gt;\\n\" +\n                \"&lt;head&gt;&lt;meta charset=\\\"utf-8\\\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;\\n\"+\n                \"&lt;body bgcolor=\\\"#f0f0f0\\\"&gt;\\n\" +\n                \"&lt;h1 align=\\\"center\\\"&gt;\" + \"Test 你好\" + \"&lt;/h1&gt;\\n\";\n        System.out.println(doc);\n        response.getWriter().println(doc);\n    }\n    public void doPost(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException {\n        System.out.println(\"Enter doGet()\");\n        System.out.println(\"parameter name : \"+request.getParameter(\"name\"));\n        response.setCharacterEncoding(\"UTF-8\");\n        String doc = \"&lt;!DOCTYPE html&gt; \\n\" +\n                \"&lt;html&gt;\\n\" +\n                \"&lt;head&gt;&lt;meta charset=\\\"utf-8\\\"&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;\\n\"+\n                \"&lt;body bgcolor=\\\"#f0f0f0\\\"&gt;\\n\" +\n                \"&lt;h1 align=\\\"center\\\"&gt;\" + \"Test 你好\" + \"&lt;/h1&gt;\\n\";\n        System.out.println(doc);\n        response.getWriter().println(doc);\n    }\n}\n</code></pre><p>主要在于输出的日志不同，修改后用了“Another TestServlet”的标识，将修改后的TestServlet单独编译，参考前面的步骤把这些文件放入/webroot/app2里，用来区分，方便我们对两个应用的场景进行模拟测试。</p><p>最后还有个小调整，之前我们在HttpProcessor的process(Socket socket)方法中通过Header头Connection：Close判断是否要关闭长连接，现在简化一下，直接关闭。</p><pre><code class=\"language-plain\">//if (\"close\".equals(response.getHeader(\"Connection\"))) {\n    keepAlive = false;\n//}\n</code></pre><h2>小结</h2><p>这节课我们新增了多应用的支持，支持多路由转发，通过路径的区分，将请求转发到不同应用之中。比如用户在客户端输入地址 <code>http://address:port/app1/testservlet</code>，这个url中，app1将定位到某个应用context，testservlet将定位到具体的某个程序。这里的app1/目录就框定了一个应用，下面的各个程序都是在app1应用下运行的。而app2/目录就代表了另一个应用。</p><p>多个应用之间是独立的，但里面可以有同名的程序，那么我们怎么区分的呢？这里利用了我们自定义的WebappClassLoader对通用的ClassLoader进行了一层封装，实现了应用之间的相互隔离，并为接下来的自定义类加载器打下了基础。在这个基础上，我们又继续优化了Bootstrap，去除了多余的功能，确保它只是一个启动器。</p><p>这节课代码参见：<a href=\"https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter14\">https://gitee.com/yaleguo1/minit-learning-demo/tree/geek_chapter14</a></p><h2>思考题</h2><p>学完了这节课的内容，我们来思考一个问题：对于一个完整的url，比如 <code>http://address:port/context/servlet</code>，它的每一部分是如何与Tomcat的基本概念对应的？</p><p>欢迎你把你的答案分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":387759,"user_name":"Twein","can_delete":false,"product_type":"c1","uid":1309882,"ip_address":"海南","ucode":"83498605A39292","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/1G2rlRgNalXbcUnHibRNMibAeHQhWoKNl4e4EgkiawDynZZiaO4W3vSSMtlYEKrt6e7GW4mcu1sjcs7bGKjl0vRhWQ/132","comment_is_top":false,"comment_ctime":1708520119,"is_pvip":false,"replies":[{"id":141265,"content":"放到Context里面的","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1708823457,"ip_address":"澳大利亚","comment_id":387759,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"老师，上条留言说错了，应该是host的start方法没有启动过滤器的代码，源码少了这块逻辑","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":637690,"discussion_content":"放到Context里面的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1708823457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386842,"user_name":"Geek_50a5cc","can_delete":false,"product_type":"c1","uid":1786951,"ip_address":"北京","ucode":"0F6C1C2552261F","user_header":"","comment_is_top":false,"comment_ctime":1705653162,"is_pvip":false,"replies":[{"id":141017,"content":"要反复琢磨。再次看的时候，不要沉浸在细节，主要理解结构。","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705701093,"ip_address":"澳大利亚","comment_id":386842,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"感觉一路跟过来，好多概念有点模糊了，有空回头再看看","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636153,"discussion_content":"要反复琢磨。再次看的时候，不要沉浸在细节，主要理解结构。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1705701093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386589,"user_name":"HH🐷🐠","can_delete":false,"product_type":"c1","uid":1133678,"ip_address":"广东","ucode":"C50172BDA604D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/4c/6e/5435e214.jpg","comment_is_top":false,"comment_ctime":1705149550,"is_pvip":false,"replies":[{"id":140974,"content":"address:port对应host，http对应connector协议处理","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705401575,"ip_address":"澳大利亚","comment_id":386589,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"http:&#47;&#47;address:port&#47;context&#47;servlet\n从一个整体出发，url --&gt; HttpRequest,  context --&gt; StandardHost, servlet --&gt; StandardWrapper,  当然背后还有涉及 HttpHeader、Filter 等等","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635958,"discussion_content":"address:port对应host，http对应connector协议处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705401575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386393,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1704762829,"is_pvip":false,"replies":[{"id":140992,"content":"Q1，是的，不同的应用有一个不同的类加载器对应，这么设计是Tomcat的特性所要求的。因为Tomcat是一个应用服务器，它需要做到应用之间的隔离。\nQ2，对，后面我改成了webapps目录，这样能更好地与Tomcat运行时对应上。\nQ3，可以加载同一个类，因为用了不同的classloader。\nQ4，WebappClasLoader里面包含了一个URLClassLoader\nQ5，所有Gitub&#47;Gitee上的代码都是可以运行的","user_name":"作者回复","user_name_real":"编辑","uid":1864890,"ctime":1705446682,"ip_address":"澳大利亚","comment_id":386393,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"请教老师几个问题：\nQ1：不同应用对应不同的加载类吗？？\n本文中有这样一句话“每一个 context 都对应一个不同的 WebappClassLoader”，对于加载类，是不同的实例？还是不同的类？\n比如context1和context2，理解1：context1对应WebappClassLoaderA；context2对应WebappClassLoaderB，是不同的类。\n理解2：context1对应WebappClassLoader的实例1；context2对应WebappClassLoader的实例2，即同一个类的不同实例。\nQ2：webroot目录下的测试代码，在实际的Tomcat中就是具体的web应用，对吗？\nQ3：一个应用中，两个ClassLoader可以加载同一个类(版本也相同)吗？\nQ4：WebappClassLoader不需要继承已有的接口或方法吗？\nWebappClassLoader算是自定义ClassLoader吧。记得以前看过关于自定义ClassLoader的文章，好像要继承系统已有的接口或方法，就是说要和已有的东西建立联系。但本课中的WebappClassLoader是个单独的类，并无继承。\nQ5：运行后找不到类，报错：\njava.lang.ClassNotFoundException: test.TestListener\n(StandardHost.java:120)\n&#47;&#47; Instantiate a new instance of this filter and return it\n                    Class&lt;?&gt; clazz = classLoader.getClassLoader().loadClass(listenerClass);\n还没有调试。老师那边能正常运行吗？","like_count":0,"discussions":[{"author":{"id":1864890,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/cojb2AA3eM620kb7hj7YoOpq8XI0iaPyfajnQLO6icAhuSoYWR1vrdOZB2nmSuETxmuheo3sxec698SD6RhTFxgQ/132","nickname":"Yale Guo","note":"","ucode":"6736810620B3F0","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635989,"discussion_content":"Q1，是的，不同的应用有一个不同的类加载器对应，这么设计是Tomcat的特性所要求的。因为Tomcat是一个应用服务器，它需要做到应用之间的隔离。\nQ2，对，后面我改成了webapps目录，这样能更好地与Tomcat运行时对应上。\nQ3，可以加载同一个类，因为用了不同的classloader。\nQ4，WebappClasLoader里面包含了一个URLClassLoader\nQ5，所有Gitub/Gitee上的代码都是可以运行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705446683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"澳大利亚","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1572356,"avatar":"https://static001.geekbang.org/account/avatar/00/17/fe/04/bb427e47.jpg","nickname":"码哥字节","note":"","ucode":"362103AD52C8E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653174,"discussion_content":"Q5确实报错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1730365392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393694,"user_name":"毛竹","can_delete":false,"product_type":"c1","uid":1987536,"ip_address":"北京","ucode":"893C87E32AA5AA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/H6US70MyQlXGVIzSbrgdTiasc0mbJS503AJG9tuGwXL0cLTBmp1ib2yLQ7HeA8BKUX12TKHvgaDS3JfiacmuBBO4w/132","comment_is_top":false,"comment_ctime":1724635303,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"host  start代码里启用listenerStart 读的路径是 test.TestListener, 本章项目路径里并不存在这个路径","like_count":0},{"had_liked":false,"id":392642,"user_name":"silentyears","can_delete":false,"product_type":"c1","uid":1061748,"ip_address":"北京","ucode":"6E137BFEB874CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/33/74/d9d143fa.jpg","comment_is_top":false,"comment_ctime":1721376020,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636401,"comment_content":"standardContext$start()都没有任何地方调用吧","like_count":0}]}