{"id":447486,"title":"04 | 封闭类：怎么刹住失控的扩展性？","content":"<p>你好，我是范学雷。今天，我们聊一聊Java的封闭类。</p><p>封闭类这个特性，首先在JDK 15中以预览版的形式发布。在JDK 16中，改进的封闭类再次以预览版的形式发布。最后，封闭类在JDK 17正式发布。</p><p>那么，什么是封闭类呢？封闭类的英文，使用的词汇是\"sealed classes\"。从名字我们就可以感受到，封闭类首先是Java的类，然后它还是封闭的。</p><p>Java的类，我们都知道什么意思。那么，“封闭”又是什么意思呢？字面的意思，就是把一些东西封存起来，里面的东西出不去，外面的东西也进不来，所以可查可数。</p><p>“封闭”、“可查可数”，这些词汇字面看起来好像很通俗，但是实际上并不容易理解。我们还是通过案例和代码，一步一步地来了解封闭类吧。</p><h2>阅读案例</h2><p>在面向对象的编程语言中，研究表示形状的类，是一个常用的教学案例。今天的评审案例，我们也从形状这个类开始，来研究一下怎么判断一个形状是不是正方形吧。</p><p>下面的这段代码，就是一个简单的、抽象的形状类的定义。这个抽象类的名字是<strong>Shape</strong>。它有一个抽象方法area()，用来计算形状的面积。它还有一个公开的属性id，用来标识这个形状的对象。</p><pre><code class=\"language-java\">package co.ivi.jus.sealed.former;\n\npublic abstract class Shape {\n    public final String id;\n    \n    public Shape(String id) {\n        this.id = id;\n    }\n    \n    public abstract double area();\n}\n</code></pre><!-- [[[read_end]]] --><p>我们都知道，正方形是一个形状。正方形可以作为形状这个类的一个扩展类。它的代码可以是下面的样子。</p><pre><code class=\"language-java\">package co.ivi.jus.sealed.former;\n\npublic class Square extends Shape {\n    public final double side;\n    \n    public Square(String id, double side) {\n        super(id);\n        this.side = side;\n    }\n    \n    @Override\n    public double area() {\n        return side * side;\n    }\n}\n</code></pre><p>那么，到底怎么判断一个形状是不是正方形呢？这个问题的答案，表面上看起来很简单，只要判断这个形状的对象是不是一个正方形的实例就可以了。这个判断的例子，看起来可以是下面的样子。</p><pre><code class=\"language-java\">static boolean isSquare(Shape shape) {\n    return (shape instanceof Square);\n}\n</code></pre><p>你可以思考一下，这样是不是真的能判断一个形状是正方形？花几秒钟想想你的答案，我们接下来再继续分析。</p><h2>案例分析</h2><p>其实，上面的这个例子，判断的只是“一个形状的对象是不是一个正方形的实例”。但实际上，一个形状的对象即使不是一个正方形的类，它也有可能是一个正方形。什么意思呢？比如说有一个对象，表示它的类是长方形或者菱形的类。如果这个对象的每一个边的长度都是一样的，其实它就是一个正方形，但是表示它的类是长方形或者菱形的类，而不是正方形类。所以，上面的这段代码还是有缺陷的，并不总是能够正确判断一个形状是不是正方形。</p><p>详细地，我们来看下一段代码，你就对这个缺陷有一个更直观的了解了。我们都知道，长方形也是一个形状，它也可以作为形状这个类的一个扩展类。下面的这段代码，定义的就是一个长方形。这个类的名字是<strong>Rectangle</strong>，它是<strong>Shape</strong>的扩展类。</p><pre><code class=\"language-java\">package co.ivi.jus.sealed.former;\n\npublic class Rectangle extends Shape {\n    public final double length;\n    public final double width;\n    \n    public Rectangle(String id, double length, double width) {\n        super(id);\n        this.length = length;\n        this.width = width;\n    }\n    \n    @Override\n    public double area() {\n        return length * width;\n    }\n}\n</code></pre><p>代码读到这里，对于“怎么判断一个形状是不是正方形”这个问题，我觉得你可能已经有了一个更好的思路。没错，正方形是一个特殊的长方形。如果一个长方形的长和宽是相等的，那么它也是一个正方形。上面的那段“判断一个形状是不是正方形”的代码，就没有考虑到长方形的特例，所以它是有缺陷的实现。</p><p>知道了长方形这个类，我们就能改进我们的判断了。改进的代码，要把长方形考虑进去。它看起来可以是下面的样子。</p><pre><code class=\"language-java\">public static boolean isSquare(Shape shape) {\n    if (shape instanceof Rectangle rect) {\n        return (rect.length == rect.width);\n    }\n    \n    return (shape instanceof Square);\n}\n</code></pre><p>写完上面的代码，似乎就可以长舒一口气：哎，这难缠的正方形，我们终于搞定了。</p><p>但其实，这个问题我们还没有搞定。因为正方形也是一个特殊的菱形，如果一个对象是一个菱形类的实例，上面的代码就有缺陷。更令人窘迫的是，正方形还是一个特殊的梯形，还是一个特殊的多边形。随着我们学习一步一步的深入，我们知道还有很多形状的特殊形式是正方形，而且我们并不知道我们知识范围外的那些形状，当然更不能提穷举它们了。</p><p>这，实在有点让人抓狂！</p><p>问题出在哪里呢？<strong>无限制的扩展性，是问题的根源</strong>。正如现实世界里，我们没有办法穷举到底有多少形状的特殊形式是正方形；在计算机的世界里，我们也没有办法穷举到底有多少形状的对象可以是正方形。如果我们解决不了形状类的穷举问题，我们就不太容易使用代码来判断一个形状是不是正方形。</p><p>而解决问题的办法，就是限制可扩展类的扩展性。</p><h2>怎么限制住扩展性？</h2><p>你可能要问，可扩展性不是面向对象编程的一个重要指标吗？为什么要限制可扩展性呢？其实，面向对象编程的最佳实践之一，就是要把可扩展性限制在可以预测和控制的范围内，而不是无限的可扩展性。</p><p>除了上面穷举的问题之外，在极客时间专栏<a href=\"https://time.geekbang.org/column/intro/129\">《代码精进之路》</a>里，我们还讨论了继承的安全缺陷。其中，主要有两点值得我们格外小心：</p><blockquote>\n<p>一个可扩展的类，子类和父类可能会相互影响，从而导致不可预知的行为。<br>\n涉及敏感信息的类，增加可扩展性不一定是个优先选项，要尽量避免父类或者子类的影响。</p>\n</blockquote><p>虽然我们使用了 Java 语言来讨论继承的问题，但其实这些是面向对象机制的普遍问题，甚至它们也不单单是面向对象语言的问题，比如使用 C 语言的设计和实现，也存在类似的问题。</p><p>由于继承的安全问题，我们在设计 API 时，有两个要反省思考的点：</p><blockquote>\n<p>一个类，有没有真实的可扩展需求，能不能使用 final 修饰符？<br>\n一个方法，子类有没有重写的必要性，能不能使用 final 修饰符？</p>\n</blockquote><p>限制住不可预测的可扩展性，是实现安全代码、健壮代码的一个重要目标。</p><p>JDK 17之前的Java语言，限制住可扩展性只有两个方法，使用私有类或者 final 修饰符。显而易见，私有类不是公开接口，只能内部使用；而 final 修饰符彻底放弃了可扩展性。要么全开放，要么全封闭，可扩展性只能在可能性的两个极端游走。全封闭彻底没有了可扩展性，全开放又面临固有的安全缺陷，这种二选一的状况有时候很让人抓狂，特别是设计公开接口的时候。</p><p>JDK 17之后，有了第三种方法。这个办法，就是使用Java的<strong>sealed</strong>关键字。使用类修饰符<strong>sealed</strong>修饰的类是封闭类；使用类修饰符<strong>sealed</strong>修饰的接口是封闭接口。封闭类和封闭接口限制可以扩展或实现它们的其他类或接口。</p><p>通过把可扩展性的限制放在可以预测和控制的范围内，封闭类和封闭接口打开了全开放和全封闭两个极端之间的中间地带，为接口设计和实现提供了新的可能性。</p><h2>怎么声明封闭类</h2><p>那么，怎么使用封闭类呢？封闭类这个概念，涉及到两种类型的类。第一种是被扩展的父类，第二种是扩展而来的子类。通常地，我们把第一种称为封闭类，第二种称为许可类。</p><p>封闭类的声明使用 sealed 类修饰符，然后在所有的 extends 和 implements 语句之后，使用 permits 指定允许扩展该封闭类的子类。 比如，使用 sealed 类修饰符，我们可以把形状这个类声明为封闭类。下面的这个例子中，Shape是一个封闭类，可以扩展它的子类只有两个，分别为Circle和Square。也就是说，这里定义的形状这个类，只允许有圆形和正方形两个子类。</p><pre><code class=\"language-java\">package co.ivi.jus.sealed.modern;\n\npublic abstract sealed class Shape permits Circle, Square {\n    public final String id;\n\n    public Shape(String id) {\n        this.id = id;\n    }\n\n    public abstract double area();\n}\n</code></pre><p>由 permits 关键字指定的许可子类（permitted subclasses），必须和封闭类处于同一模块（module）或者包空间（package）里。如果封闭类和许可类是在同一个模块里，那么它们可以处于不同的包空间里，就像下面的例子。</p><pre><code class=\"language-java\">package co.ivi.jus.sealed.modern;\n\npublic abstract sealed class Shape\n    permits co.ivi.jus.ploar.Circle,\n            co.ivi.jus.quad.Square {\n    public final String id;\n\n    public Shape(String id) {\n        this.id = id;\n    }\n\n    public abstract double area();\n}\n</code></pre><p>如果允许扩展的子类和封闭类在同一个源代码文件里，封闭类可以不使用 permits 语句，Java 编译器将检索源文件，在编译期为封闭类添加上许可的子类。比如下面的两种 Shape 封闭类的声明，一个封闭类使用了 permits 语句，另外一个封闭类没有使用 permits 语句。但是，这两个声明具有完全一样的运行时效果。</p><pre><code class=\"language-java\">package co.ivi.jus.sealed.improved;\n\npublic abstract sealed class Shape {\n    public final String id;\n\n    public Shape(String id) {\n        this.id = id;\n    }\n\n    public abstract double area();\n\n    public static final class Circle extends Shape {\n        // snipped\n    }\n\n    public static final class Square extends Shape {\n        // snipped\n    }\n}\n</code></pre><pre><code class=\"language-java\">package co.ivi.jus.sealed.improved;\n\npublic abstract sealed class Shape\n         permits Shape.Circle, Shape.Square {\n    public final String id;\n\n    public Shape(String id) {\n        this.id = id;\n    }\n\n    public abstract double area();\n\n    public static final class Circle extends Shape {\n        // snipped\n    }\n\n    public static final class Square extends Shape {\n        // snipped\n    }\n}\n</code></pre><p>不过，如果你读过《代码精进之路》，你就会倾向于总是使用permits 语句。因为这样的话，代码的阅读者不需要去翻找上下文，也能一目了然地知道这个封闭类支持哪些许可类。这会给代码的阅读者带来很多的便利，包括节省时间以及少犯错误。</p><h2>怎么声明许可类</h2><p>许可类的声明需要满足下面的三个条件：</p><ul>\n<li>许可类必须和封闭类处于同一模块（module）或者包空间（package）里，也就是说，在编译的时候，封闭类必须可以访问它的许可类；</li>\n<li>许可类必须是封闭类的直接扩展类；</li>\n<li>许可类必须声明是否继续保持封闭：\n<ul>\n<li>许可类可以声明为终极类（final），从而关闭扩展性；</li>\n<li>许可类可以声明为封闭类（sealed），从而延续受限制的扩展性；</li>\n<li>许可类可以声明为解封类（non-sealed）, 从而支持不受限制的扩展性。</li>\n</ul>\n</li>\n</ul><p>比如在下面的例子中，许可类 Circle 是一个解封类；许可类 Square 是一个封闭类；许可类 ColoredSquare 是一个终极类；而 ColoredCircle 既不是封闭类，也不是许可类。</p><pre><code class=\"language-java\">package co.ivi.jus.sealed.propagate;\n\npublic abstract sealed class Shape {\n    public final String id;\n\n    public Shape(String id) {\n        this.id = id;\n    }\n\n    public abstract double area();\n    \n    public static non-sealed class Circle extends Shape {\n        // snipped\n    }\n    \n    public static sealed class Square extends Shape {\n        // snipped\n    }\n    \n    public static final class ColoredSquare extends Square {\n        // snipped\n    }\n\n    public static class ColoredCircle extends Circle {\n        // snipped\n    }\n}\n</code></pre><p>需要注意的是，<strong>由于许可类必须是封闭类的直接扩展，因此许可类不具备传递性。</strong>也就是说，上面的例子中，ColoredSquare 是 Square 的许可类，但不是 Shape 的许可类。</p><h2>案例回顾</h2><p>到这里，我们再回头看看前面的案例，怎么判断一个形状是不是正方形呢？封闭类能帮助我们解决这个问题吗？如果使用了封闭类，这个问题的答案也就呼之欲出了。</p><p>首先，我们要把形状这个类定义为封闭类。这样，所有形状的子类就可以穷举了。然后，我们寻找可以用来表示正方形的许可类。找到这些许可类后，只要我们能够判断这个形状的对象是不是一个正方形，问题就解决了。</p><p>比如下面的代码，形状被定义为封闭类Shape。而且，Shape这个封闭类只有两个终极的许可类。一个许可类是表示圆形的Circle，一个许可类是表示正方形的Square。</p><pre><code class=\"language-java\">package co.ivi.jus.sealed.improved;\n\npublic abstract sealed class Shape\n         permits Shape.Circle, Shape.Square {\n    public final String id;\n\n    public Shape(String id) {\n        this.id = id;\n    }\n\n    public abstract double area();\n\n    public static final class Circle extends Shape {\n        // snipped\n    }\n\n    public static final class Square extends Shape {\n        // snipped\n    }\n}\n</code></pre><p>由于Shape是个封闭类，在这段代码的许可范围内，一个形状Shape的对象要么是一个圆形Circle的实例，要么是一个正方形Square的实例，没有其他的可能性。</p><p>这样的话，判断一个形状是不是正方形这个问题就变得比较简单了。只要能够判断出来一个形状的对象是不是一个正方形的实例，这个问题就算是解决了。</p><pre><code class=\"language-java\">static boolean isSquare(Shape shape) {\n    return (shape instanceof Square);\n}\n</code></pre><p>这样的逻辑在案例分析那一小节的场景中并不成立，为什么现在就成立了呢？根本的原因，在案例分析那一小节的场景中，Shape类是一个不受限制的类，我们没有办法知道它所有的扩展类，因此我们也就没有办法穷尽正方形的所有可能性。而在使用封闭类的场景下，Shape类的所有扩展类，我们都是已知的，所以我们就有办法检查每一个扩展类的规范，从而对这个问题做出正确的判断。</p><h2>总结</h2><p>好，到这里，我来做个小结。从前面的讨论中，我们了解到，可扩展性的限定方法有四个：</p><ol>\n<li>使用私有类；</li>\n<li>使用final修饰符；</li>\n<li>使用sealed修饰符；</li>\n<li>不受限制的扩展性。</li>\n</ol><p>在我们日常的接口设计和编码实践中，使用这四个限定方法的优先级应该是由高到低的。最优先使用私有类，尽量不要使用不受限制的扩展性。</p><p>如果要丰富你的代码评审清单，有了封闭类后，你可以加入下面这一条：</p><blockquote>\n<p>一个类，如果有真实的可扩展需求，能不能枚举，可不可以使用 sealed 修饰符？</p>\n</blockquote><p>另外，通过今天的讨论，我拎出几个技术要点，这些都可能在你们面试中出现哦，通过学习，你应该能够：</p><ul>\n<li>知道Java支持封闭类，并且能够使用封闭类编写代码；\n<ul>\n<li>面试问题：你知道封闭类吗？会不会使用它？</li>\n</ul>\n</li>\n<li>了解封闭类的原理和它要解决的问题，知道限制住扩展性的办法；\n<ul>\n<li>面试问题：面向对象编程的可扩展性有什么问题吗？该怎么处理这些问题？</li>\n</ul>\n</li>\n<li>能够有意识地使用封闭类来限制类或者接口的扩展性。\n<ul>\n<li>面试问题：你写的这段代码，是不是应该使用 <strong>final</strong>修饰符或者 <strong>sealed</strong> 修饰符？</li>\n</ul>\n</li>\n</ul><p>如果你的代码里使用了封闭类，无论是面试的时候还是工作的时候，一定能够给人深刻的印象。因为，这意味着你已经了解了可扩展性的危害，并且有办法降低这种危害的影响，有能力编写出更健壮的代码。</p><h2>思考题</h2><p>在案例回顾这一小节里，我们使用了封闭类来解决“怎么判断一个形状是不是正方形”这个问题。我们假设案例回顾这一小节的代码是版本1.0。现在我们假设，在版本2.0里，需要增加另一个许可类，用来支持长方形（Rectangle）。那么：</p><ol>\n<li>封闭类的代码该怎么改动，才能支持长方形？</li>\n<li>“判断一个形状是不是正方形”的代码该怎么改动，才能适应封闭类的改变？</li>\n<li>增加一个许可类，会有兼容性的影响吗？比如说，使用版本1.0来判断一个形状是不是正方形的代码还能使用吗？</li>\n</ol><p>欢迎你在留言区留言、讨论，分享你的阅读体验以及对这些问题的思考。</p><p>注：本文使用的完整的代码可以从<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/sealed\">GitHub</a>下载，你可以通过修改<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/sealed\">GitHub</a>上<a href=\"https://github.com/XueleiFan/java-up/blob/main/src/main/java/co/ivi/jus/sealed/review/xuelei/Shape.java\">review template</a>代码，完成这次的思考题。如果你想要分享你的修改或者想听听评审的意见，请提交一个 GitHub的拉取请求（Pull Request），并把拉取请求的地址贴到留言里。这一小节的拉取请求代码，请在<a href=\"https://github.com/XueleiFan/java-up/tree/main/src/main/java/co/ivi/jus/sealed/review\">封闭类专用的代码评审目录</a>下，建一个以你的名字命名的子目录，代码放到你专有的子目录里。比如，我的代码，就放在sealed/review/xuelei的目录下面。</p>","comments":[{"had_liked":false,"id":322747,"user_name":"许灵","can_delete":false,"product_type":"c1","uid":1059926,"ip_address":"","ucode":"0296EC9929B570","user_header":"https://static001.geekbang.org/account/avatar/00/10/2c/56/ff7a9730.jpg","comment_is_top":false,"comment_ctime":1637573396,"is_pvip":true,"replies":[{"id":"117227","content":"代码干净利索！","user_name":"作者回复","user_name_real":"作者","uid":"1111315","ctime":1637661244,"ip_address":"","comment_id":322747,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14522475284","product_id":100097301,"comment_content":"https:&#47;&#47;github.com&#47;XueleiFan&#47;java-up&#47;pull&#47;7","like_count":3,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532653,"discussion_content":"代码干净利索！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637661244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322994,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1637680794,"is_pvip":false,"replies":[{"id":"117253","content":"哈哈，只是一部分工作。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1637723885,"ip_address":"","comment_id":322994,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10227615386","product_id":100097301,"comment_content":"我在openjdk的githubca仓库提交人员列表中看到老师了,https:&#47;&#47;github.com&#47;openjdk&#47;jdk&#47;graphs&#47;contributors,太强了,给老师点赞!","like_count":2,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532874,"discussion_content":"哈哈，只是一部分工作。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637723885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322659,"user_name":"雷霹雳的爸爸","can_delete":false,"product_type":"c1","uid":1119490,"ip_address":"","ucode":"99BBA6D83DD11F","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","comment_is_top":false,"comment_ctime":1637545007,"is_pvip":true,"replies":[{"id":"117119","content":"1）2）3）的判断都是对的。第3个问题，其实是我们讨论问题的重点。增加一个抽象方法当然是好办法，不过也有很多例子没有办法通过增加父类的方法来解决。封闭类需要和模式匹配一起使用，才能解决好问题3。模式匹配带来的变化，我们后面会讨论。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1637546289,"ip_address":"","comment_id":322659,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5932512303","product_id":100097301,"comment_content":"1. permits 得加上Rectangle，2. 要增加instance of Rectangle时候，长和宽是不是相等的逻辑，3. 正方形那段还是生效的，但是如果shape是Rect就不起作用了，所以还是应该认为1.0得isSquare不兼容新增加的许可类<br><br>假设我3判断的没错（确实还没去code...），那么我的问题也在这，因为岂不是这个例子整个逻辑链条都有问题了，这不就是一开始讲的不限制扩展性可能带来的问题么，进一步岂不是说明sealed classes并没法在强类型上带来太多有意义的约束...按着相对传统的——就是没有sealed语法得历史时间点那时得视角来看，应该是原来的isSquare（它是个静态方法）突破了Shape类型的约束（只定义了Area），如果想对未来潜在的变化有意义，那么应该让isSquare也作为Shape的一个抽象方法由子类型来复写，让Rect、Hex还是什么别的，根据自己类型特征得情况来确定isSquare得具体实现岂不是更合适...","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532149,"discussion_content":"1）2）3）的判断都是对的。第3个问题，其实是我们讨论问题的重点。增加一个抽象方法当然是好办法，不过也有很多例子没有办法通过增加父类的方法来解决。封闭类需要和模式匹配一起使用，才能解决好问题3。模式匹配带来的变化，我们后面会讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637546289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1119490,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/02/66f65388.jpg","nickname":"雷霹雳的爸爸","note":"","ucode":"99BBA6D83DD11F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532234,"discussion_content":"感谢老师的解释，同时我结合了老师在infoq之前一篇sealed文章、代码精进之路，和老师提到得模式匹配相关参考，大概有了一些新的理解，这确实即便是把isSquare放超类型也要面对一些互相矛盾得设计原则问题，具体我自己得结论我强烈期待老师讲到模式匹配时候我再进一步加以印证了...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637561427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359047,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1665200240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665200240","product_id":100097301,"comment_content":"无限制的扩展性，是问题的根源。--记下来","like_count":0},{"had_liked":false,"id":355477,"user_name":"qinghuazs","can_delete":false,"product_type":"c1","uid":1295111,"ip_address":"北京","ucode":"2CFFA349A3A71B","user_header":"https://static001.geekbang.org/account/avatar/00/13/c3/07/42188ca5.jpg","comment_is_top":false,"comment_ctime":1661414105,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661414105","product_id":100097301,"comment_content":"封闭性有了，扩展性没了","like_count":0},{"had_liked":false,"id":350908,"user_name":"xianbin.yang","can_delete":false,"product_type":"c1","uid":2151575,"ip_address":"","ucode":"A9D26D0D649932","user_header":"https://static001.geekbang.org/account/avatar/00/20/d4/97/2f01be06.jpg","comment_is_top":false,"comment_ctime":1657335291,"is_pvip":true,"replies":[{"id":"127780","content":"可以，不过形状很多。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1657694918,"ip_address":"","comment_id":350908,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1657335291","product_id":100097301,"comment_content":"让子类都实现一个isSquare的方法，判断自己是否正方形不行吗？","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579797,"discussion_content":"可以，不过形状很多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657694918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350583,"user_name":"Minos","can_delete":false,"product_type":"c1","uid":1520314,"ip_address":"","ucode":"C6E164A5973DF5","user_header":"https://static001.geekbang.org/account/avatar/00/17/32/ba/e9c6a37e.jpg","comment_is_top":false,"comment_ctime":1657014628,"is_pvip":true,"replies":[{"id":"127613","content":"谢谢","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1657176104,"ip_address":"","comment_id":350583,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1657014628","product_id":100097301,"comment_content":"表示它的类是长方形或者菱形的类。如果这个对象的每一个边的长度都是一样的，其实它就是一个正方形<br><br>菱形本身四条边都相等，只是夹角不是90度。夹角是90度的菱形是正方形；四条边相等的矩形是正方形；","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579104,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657176105,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346029,"user_name":"拉欧","can_delete":false,"product_type":"c1","uid":1206605,"ip_address":"","ucode":"40996A8093A95F","user_header":"https://static001.geekbang.org/account/avatar/00/12/69/4d/81c44f45.jpg","comment_is_top":false,"comment_ctime":1652778235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652778235","product_id":100097301,"comment_content":"和scala的seal关键字基本一致<br>不过个人不太喜欢scala, 语法糖加的太多太甜，符号漫天飞","like_count":0},{"had_liked":false,"id":323963,"user_name":"我要写代码！","can_delete":false,"product_type":"c1","uid":2851542,"ip_address":"","ucode":"0859B8BFA7834A","user_header":"","comment_is_top":false,"comment_ctime":1638241514,"is_pvip":false,"replies":[{"id":"117565","content":"该怎么理解ColoredSquare和Circle的关系（ColoredSquare extends Square）？","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1638257083,"ip_address":"","comment_id":323963,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1638241514","product_id":100097301,"comment_content":"需要注意的是，由于许可类必须是封闭类的直接扩展，因此许可类不具备传递性。也就是说，上面的例子中，ColoredSquare 是 Square 的许可类，但不是 Shape 的许可类。<br>是不是 Square应该写成 Circle<br>也就是说，上面的例子中，ColoredSquare 是 Circle 的许可类，但不是 Shape 的许可类。<br><br>","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534688,"discussion_content":"该怎么理解ColoredSquare和Circle的关系（ColoredSquare extends Square）？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638257083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322902,"user_name":"fatme","can_delete":false,"product_type":"c1","uid":1034451,"ip_address":"","ucode":"75A805D2BB2AD1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c8/d3/3020ae46.jpg","comment_is_top":false,"comment_ctime":1637651826,"is_pvip":false,"replies":[{"id":"117241","content":"这是一个权衡和妥协，封闭类的好处，可能要到第10讲，我们才能理解清楚。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1637681865,"ip_address":"","comment_id":322902,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637651826","product_id":100097301,"comment_content":"如果一开始设计封闭类的时候，对许可子类的预估不足，造成后续要增加新的许可子类。这样就要修改 permits 代码，这不太方便，也违背开闭原则。permits 是否能支持通配符呢？这样同一个包的所有直接子类都是许可类，在一定程度上可以减少需要修改 permits 的情况。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532773,"discussion_content":"这是一个权衡和妥协，封闭类的好处，可能要到第10讲，我们才能理解清楚。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637681865,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322792,"user_name":"ABC","can_delete":false,"product_type":"c1","uid":1054958,"ip_address":"","ucode":"7501AD9C0C4A70","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","comment_is_top":false,"comment_ctime":1637589347,"is_pvip":false,"replies":[{"id":"117226","content":"代码整体很好，只是我还有一个小的疑问，在PR里留言了。","user_name":"作者回复","user_name_real":"作者","uid":"1111315","ctime":1637661237,"ip_address":"","comment_id":322792,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637589347","product_id":100097301,"comment_content":"1. permits需要增加新增的类;2和3都用实例模式匹配修改了一下.源码里面删掉了isSquare方法,考虑向下兼容可以在isSquare方法中调用新增的getInstanceName方法进行兼容.<br><br>用了返回实例类名的方式来返回指定类,以此判断,如果还有更好的办法,请老师指点.<br><br>pr: <br><br>https:&#47;&#47;github.com&#47;XueleiFan&#47;java-up&#47;pull&#47;8","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532652,"discussion_content":"代码整体很好，只是我还有一个小的疑问，在PR里留言了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637661237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054958,"avatar":"https://static001.geekbang.org/account/avatar/00/10/18/ee/a1ed60d1.jpg","nickname":"ABC","note":"","ucode":"7501AD9C0C4A70","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532786,"discussion_content":"老师我在JDK18的源码里面找到了封闭类的使用,大概只有几个类,其中一个是: java.lang.reflect.Executable.java","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637683247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322763,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1637579150,"is_pvip":false,"replies":[{"id":"117228","content":"相对于继承，我更害怕组合的缺陷。<br><br>现实可能没有这么理想。 实际的情况往往是我们设计了1.0，用户实现了它们的逻辑，然后我们想在2.0里增加些什么（比如一个新方法），对用户来说已经太晚了（除非他知道并且愿意改代码）。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1637661463,"ip_address":"","comment_id":322763,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637579150","product_id":100097301,"comment_content":"课后题<br>3.向前兼容，向后不兼容。向前因为没有长方形的场景，所以是兼容的；向后因为有了长方形的场景，但没有对应的 是否正方形的判断逻辑，所以不兼容。但1.0的实现本身就不合适，这个是否正方形的实现应该要跟着子类走，也就是以抽象方法要求子类必须做实现。<br><br>体会<br>类声明增加了约束性的修饰。既是语义上的增强，也是权限控制上更细粒度的升级。不过继承很少用了，感觉哪怕加了这个，大家也习惯于用组合。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532654,"discussion_content":"相对于继承，我更害怕组合的缺陷。\n\n现实可能没有这么理想。 实际的情况往往是我们设计了1.0，用户实现了它们的逻辑，然后我们想在2.0里增加些什么（比如一个新方法），对用户来说已经太晚了（除非他知道并且愿意改代码）。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637661463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":532655,"discussion_content":"组合的缺陷，愿闻其详！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637661663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":532654,"ip_address":""},"score":532655,"extra":"{\"user_type\":1}"}]}]},{"had_liked":false,"id":322714,"user_name":"黄剑豪","can_delete":false,"product_type":"c1","uid":1143044,"ip_address":"","ucode":"F4C6A6821393A1","user_header":"https://static001.geekbang.org/account/avatar/00/11/71/04/e15c62e4.jpg","comment_is_top":false,"comment_ctime":1637563239,"is_pvip":true,"replies":[{"id":"117193","content":"嗯。 有没有什么好的例子的建议？选例子，可能是我花时间最多的地方，也是比较头疼的。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1637604942,"ip_address":"","comment_id":322714,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1637563239","product_id":100097301,"comment_content":"感觉这个例子举得不好，会让人不太理解使用场景，因为通常来说Shape本身不应该是个封闭场景。因为判断是否是正方形强行将其封闭，总觉得例子有点怪。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532461,"discussion_content":"嗯。 有没有什么好的例子的建议？选例子，可能是我花时间最多的地方，也是比较头疼的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637604942,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1898023,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f6/27/c27599ae.jpg","nickname":"术子米德","note":"","ucode":"382EA7E2AF0B56","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532466,"discussion_content":"同意你的观点，我也有类似感觉，例子举得不到位，极大影响知识的理解；反过来说，如果举不出好例子，是否间接说明应用场景的问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637619192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322711,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1637562467,"is_pvip":false,"replies":[{"id":"117194","content":"技术当然要服从于现实的需求。如果你的场景需要无限的扩展性，那当然就只能使用无限的扩展性。封闭类有它适合的场景，也有不便使用的地方。需求的扩展和类的扩展，有重合的部分，但是也可能要具体情况具体分析。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1637605198,"ip_address":"","comment_id":322711,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637562467","product_id":100097301,"comment_content":"我是在，现场进行开发的。一般都是，公司内出版本。客户现场接增量需求。但是没有，公司内部版本的源码。如果有这么封闭类，有些定制化需求，客户要的急，需要改版本的源码，这样是不是相当于把扩展性的通道，堵死了？","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532463,"discussion_content":"技术当然要服从于现实的需求。如果你的场景需要无限的扩展性，那当然就只能使用无限的扩展性。封闭类有它适合的场景，也有不便使用的地方。需求的扩展和类的扩展，有重合的部分，但是也可能要具体情况具体分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637605198,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322702,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1637558718,"is_pvip":false,"replies":[{"id":"117191","content":"&amp;quot;没有比正确运行更重要的了&amp;quot;! 这是一切原则能够成立的根本啊。","user_name":"作者回复","user_name_real":"编辑","uid":"1111315","ctime":1637604726,"ip_address":"","comment_id":322702,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637558718","product_id":100097301,"comment_content":"原来正方形变化多端！封闭类可以把无限多种情况变成有限数量的情况，从而达到了不可控到可控的目的。虽然在添加新许可类时必须修改封闭类（打破了开闭原则），但解决了因无限扩展可能导致的诡异Bug，保证的程序的正确性（没有比正确运行更重要的了）。","like_count":0,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532459,"discussion_content":"&amp;quot;没有比正确运行更重要的了&amp;quot;! 这是一切原则能够成立的根本啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637604726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}