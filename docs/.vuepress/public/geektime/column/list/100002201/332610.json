{"id":332610,"title":"114 | Go编程模式：Pipeline","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p><p>这节课，我着重介绍一下Go编程中的Pipeline模式。对于Pipeline，用过Unix/Linux命令行的人都不会陌生，<strong>它是一种把各种命令拼接起来完成一个更强功能的技术方法</strong>。</p><p>现在的流式处理、函数式编程、应用网关对微服务进行简单的API编排，其实都是受Pipeline这种技术方式的影响。Pipeline可以很容易地把代码按单一职责的原则拆分成多个高内聚低耦合的小模块，然后轻松地把它们拼装起来，去完成比较复杂的功能。</p><h2>HTTP 处理</h2><p>这种Pipeline的模式，我在<a href=\"https://time.geekbang.org/column/article/332608\">上节课</a>中有过一个示例，我们再复习一下。</p><p>上节课，我们有很多  <code>WithServerHead()</code> 、<code>WithBasicAuth()</code> 、<code>WithDebugLog()</code>这样的小功能代码，在需要实现某个HTTP API 的时候，我们就可以很轻松地把它们组织起来。</p><p>原来的代码是下面这个样子：</p><pre><code>http.HandleFunc(&quot;/v1/hello&quot;, WithServerHeader(WithAuthCookie(hello)))\nhttp.HandleFunc(&quot;/v2/hello&quot;, WithServerHeader(WithBasicAuth(hello)))\nhttp.HandleFunc(&quot;/v3/hello&quot;, WithServerHeader(WithBasicAuth(WithDebugLog(hello))))\n</code></pre><p>通过一个代理函数：</p><pre><code>type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc\nfunc Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {\n    for i := range decors {\n        d := decors[len(decors)-1-i] // iterate in reverse\n        h = d(h)\n    }\n    return h\n}\n</code></pre><p>我们就可以移除不断的嵌套，像下面这样使用了：</p><pre><code>http.HandleFunc(&quot;/v4/hello&quot;, Handler(hello,\n                WithServerHeader, WithBasicAuth, WithDebugLog))\n</code></pre><h2>Channel 管理</h2><p>当然，如果你要写出一个<a href=\"https://coolshell.cn/articles/17929.html#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%99%A8\">泛型的Pipeline框架</a>并不容易，可以使用<a href=\"https://coolshell.cn/articles/21179.html\">Go Generation</a>实现，但是，我们别忘了，Go语言最具特色的 Go Routine 和 Channel 这两个神器完全可以用来构造这种编程。</p><!-- [[[read_end]]] --><p>Rob Pike在 <a href=\"https://blog.golang.org/pipelines\">Go Concurrency Patterns: Pipelines and cancellation</a> 这篇博客中介绍了一种编程模式，下面我们来学习下。</p><h3>Channel转发函数</h3><p>首先，我们需要一个 <code>echo()</code>函数，它会把一个整型数组放到一个Channel中，并返回这个Channel。</p><pre><code>func echo(nums []int) &lt;-chan int {\n  out := make(chan int)\n  go func() {\n    for _, n := range nums {\n      out &lt;- n\n    }\n    close(out)\n  }()\n  return out\n}\n</code></pre><p>然后，我们依照这个模式，就可以写下下面的函数。</p><h3>平方函数</h3><pre><code>func sq(in &lt;-chan int) &lt;-chan int {\n  out := make(chan int)\n  go func() {\n    for n := range in {\n      out &lt;- n * n\n    }\n    close(out)\n  }()\n  return out\n}\n</code></pre><h3>过滤奇数函数</h3><pre><code>func odd(in &lt;-chan int) &lt;-chan int {\n  out := make(chan int)\n  go func() {\n    for n := range in {\n      if n%2 != 0 {\n        out &lt;- n\n      }\n    }\n    close(out)\n  }()\n  return out\n}\n</code></pre><h3>求和函数</h3><pre><code>func sum(in &lt;-chan int) &lt;-chan int {\n  out := make(chan int)\n  go func() {\n    var sum = 0\n    for n := range in {\n      sum += n\n    }\n    out &lt;- sum\n    close(out)\n  }()\n  return out\n}\n</code></pre><p>用户端的代码如下所示（注：你可能会觉得，sum()，odd() 和 sq()太过于相似，其实，你可以通过Map/Reduce编程模式或者是Go Generation的方式合并一下）：</p><pre><code>var nums = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nfor n := range sum(sq(odd(echo(nums)))) {\n  fmt.Println(n)\n}\n</code></pre><p>上面的代码类似于我们执行了Unix/Linux命令： <code>echo $nums | sq | sum</code>。同样，如果你不想有那么多的函数嵌套，就可以使用一个代理函数来完成。</p><pre><code>type EchoFunc func ([]int) (&lt;- chan int) \ntype PipeFunc func (&lt;- chan int) (&lt;- chan int) \n\nfunc pipeline(nums []int, echo EchoFunc, pipeFns ... PipeFunc) &lt;- chan int {\n  ch  := echo(nums)\n  for i := range pipeFns {\n    ch = pipeFns[i](ch)\n  }\n  return ch\n}\n</code></pre><p>然后，就可以这样做了：</p><pre><code>var nums = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}    \nfor n := range pipeline(nums, gen, odd, sq, sum) {\n    fmt.Println(n)\n  }\n</code></pre><h2>Fan in/Out</h2><p><strong>动用Go语言的 Go Routine和 Channel还有一个好处，就是可以写出1对多，或多对1的Pipeline，也就是Fan In/ Fan Out</strong>。下面，我们来看一个Fan in的示例。</p><p>假设我们要通过并发的方式对一个很长的数组中的质数进行求和运算，我们想先把数组分段求和，然后再把它们集中起来。</p><p>下面是我们的主函数：</p><pre><code>func makeRange(min, max int) []int {\n  a := make([]int, max-min+1)\n  for i := range a {\n    a[i] = min + i\n  }\n  return a\n}\n\nfunc main() {\n  nums := makeRange(1, 10000)\n  in := echo(nums)\n\n  const nProcess = 5\n  var chans [nProcess]&lt;-chan int\n  for i := range chans {\n    chans[i] = sum(prime(in))\n  }\n\n  for n := range sum(merge(chans[:])) {\n    fmt.Println(n)\n  }\n}\n</code></pre><p>再看我们的 <code>prime()</code> 函数的实现 ：</p><pre><code>func is_prime(value int) bool {\n  for i := 2; i &lt;= int(math.Floor(float64(value) / 2)); i++ {\n    if value%i == 0 {\n      return false\n    }\n  }\n  return value &gt; 1\n}\n\nfunc prime(in &lt;-chan int) &lt;-chan int {\n  out := make(chan int)\n  go func ()  {\n    for n := range in {\n      if is_prime(n) {\n        out &lt;- n\n      }\n    }\n    close(out)\n  }()\n  return out\n}\n</code></pre><p>我来简单解释下这段代码。</p><ul>\n<li>首先，我们制造了从1到10000的数组；</li>\n<li>然后，把这堆数组全部 <code>echo</code>到一个Channel里——  <code>in</code>；</li>\n<li>此时，生成 5 个 Channel，接着都调用 <code>sum(prime(in))</code> ，于是，每个Sum的Go Routine都会开始计算和；</li>\n<li>最后，再把所有的结果再求和拼起来，得到最终的结果。</li>\n</ul><p>其中的merge代码如下：</p><pre><code>func merge(cs []&lt;-chan int) &lt;-chan int {\n  var wg sync.WaitGroup\n  out := make(chan int)\n\n  wg.Add(len(cs))\n  for _, c := range cs {\n    go func(c &lt;-chan int) {\n      for n := range c {\n        out &lt;- n\n      }\n      wg.Done()\n    }(c)\n  }\n  go func() {\n    wg.Wait()\n    close(out)\n  }()\n  return out\n}\n</code></pre><p>整个程序的结构如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/b3/f9d2b599620d5bc191194ff239f0a1b3.jpg?wh=3875*2250\" alt=\"\"></p><h2>参考文档</h2><p>如果你还想了解更多类似的与并发相关的技术，我再给你推荐一些资源：</p><ul>\n<li><a href=\"https://www.youtube.com/watch?v=f6kdp27TYZs\">Go Concurrency Patterns – Rob Pike – 2012 Google I/O presents the basics of Go‘s concurrency primitives and several ways to apply them.</a></li>\n<li><a href=\"https://blog.golang.org/advanced-go-concurrency-patterns\">Advanced Go Concurrency Patterns – Rob Pike – 2013 Google I/O</a><br>\n<a href=\"https://blog.golang.org/advanced-go-concurrency-patterns\">covers more complex uses of Go’s primitives, especially select.</a></li>\n<li><a href=\"https://swtch.com/~rsc/thread/squint.pdf\">Squinting at Power Series – Douglas McIlroy’s paper</a><br>\n<a href=\"https://swtch.com/~rsc/thread/squint.pdf\">shows how Go-like concurrency provides elegant support for complex calculations.</a></li>\n</ul><p>好了，这节课就到这里。如果你觉得今天的内容对你有所帮助，欢迎你帮我分享给更多人。</p>","comments":[{"had_liked":false,"id":274641,"user_name":"Geek_Fantasy","can_delete":false,"product_type":"c1","uid":2216702,"ip_address":"","ucode":"5CC395D8552CCD","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/hNVMG2tFVzXzCYibhvOZ8wVBHicg5nicu0FSQdx0ItFZIoLSMC7AAbNL0fbPOuiaLqTsOkKe6BDKl6lcIXYH5vuRHg/132","comment_is_top":false,"comment_ctime":1611108865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14496010753","product_id":100002201,"comment_content":"判断一个数是否是质数的方法可以优化一下。只需要枚举到value的平方根就可以，可以把复杂度从O(n)降到O(sqrt(n))。","like_count":3},{"had_liked":false,"id":356342,"user_name":"ano","can_delete":false,"product_type":"c1","uid":1783342,"ip_address":"北京","ucode":"7DE64BDFA78550","user_header":"https://static001.geekbang.org/account/avatar/00/1b/36/2e/376a3551.jpg","comment_is_top":false,"comment_ctime":1662178342,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662178342","product_id":100002201,"comment_content":"merge 中的  wg.Wait() 为什么必须要放到一个单独的 goroutine 中呢？","like_count":0},{"had_liked":false,"id":332665,"user_name":"Geek_ce6971","can_delete":false,"product_type":"c1","uid":2016458,"ip_address":"","ucode":"8826A1C6BF8355","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAHCRt6dBUDTFX4EotyV5NDbYiaUXH109SOdRprLky1PUc9jm2K7QvoCpkZuCyqMCNSogUpdFzMJw/132","comment_is_top":false,"comment_ctime":1643445162,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1643445162","product_id":100002201,"comment_content":"pipeline 最后返回 &lt;- chan  类型，就像 java stream编程的输出流","like_count":0},{"had_liked":false,"id":328129,"user_name":"方勇(gopher)","can_delete":false,"product_type":"c1","uid":1290625,"ip_address":"","ucode":"D199911C4CFEF5","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/81/13f23d1e.jpg","comment_is_top":false,"comment_ctime":1640567846,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640567846","product_id":100002201,"comment_content":"Pipeline使用场景还是很多的，在做任务发布的时候会经常用到","like_count":0},{"had_liked":false,"id":307453,"user_name":"你为啥那么牛","can_delete":false,"product_type":"c1","uid":1503506,"ip_address":"","ucode":"1ABC604A54A8F6","user_header":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","comment_is_top":false,"comment_ctime":1629107877,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629107877","product_id":100002201,"comment_content":"没看明白 你是怎么分组的","like_count":0,"discussions":[{"author":{"id":1002569,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4c/49/d21c134f.jpg","nickname":"swordholder","note":"","ucode":"3D1361126AD3CB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406178,"discussion_content":"每次调用prime，都会启动一个goroutine，然后nProcess个goroutine都会从channel中“抢”数字，但每次只有一个goroutine能成功抢到，至于是哪个goroutine，那就是随机看运气，这样所有数字，基本平均的分成了nProcess组。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1634717586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}