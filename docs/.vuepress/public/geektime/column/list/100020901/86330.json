{"id":86330,"title":"49 | 案例篇：内核线程 CPU 利用率太高，我该怎么办？","content":"<p>你好，我是倪朋飞。</p><p>上一期，我们一起梳理了，网络时不时丢包的分析定位和优化方法。先简单回顾一下。</p><p>网络丢包，通常会带来严重的性能下降，特别是对 TCP 来说，丢包通常意味着网络拥塞和重传，进而会导致网络延迟增大以及吞吐量降低。</p><p>而分析丢包问题，还是用我们的老套路，从 Linux 网络收发的流程入手，结合 TCP/IP 协议栈的原理来逐层分析。</p><p>其实，在排查网络问题时，我们还经常碰到的一个问题，就是内核线程的 CPU 使用率很高。比如，在高并发的场景中，内核线程 ksoftirqd 的 CPU 使用率通常就会比较高。回顾一下前面学过的 CPU 和网络模块，你应该知道，这是网络收发的软中断导致的。</p><p>而要分析 ksoftirqd 这类 CPU 使用率比较高的内核线程，如果用我前面介绍过的那些分析方法，你一般需要借助于其他性能工具，进行辅助分析。</p><p>比如，还是以 ksoftirqd 为例，如果你怀疑是网络问题，就可以用 sar、tcpdump 等分析网络流量，进一步确认网络问题的根源。</p><p>不过，显然，这种方法在实际操作中需要步骤比较多，可能并不算快捷。你肯定也很想知道，有没有其他更简单的方法，可以直接观察内核线程的行为，更快定位瓶颈呢？</p><p>今天，我就继续以 ksoftirqd 为例，带你一起看看，如何分析内核线程的性能问题。</p><!-- [[[read_end]]] --><h2>内核线程</h2><p>既然要讲内核线程的性能问题，在案例开始之前，我们就先来看看，有哪些常见的内核线程。</p><p>我们知道，在 Linux 中，用户态进程的“祖先”，都是 PID 号为 1 的 init 进程。比如，现在主流的 Linux 发行版中，init 都是 systemd 进程；而其他的用户态进程，会通过 systemd 来进行管理。</p><p>稍微想一下 Linux 中的各种进程，除了用户态进程外，还有大量的内核态线程。按说内核态的线程，应该先于用户态进程启动，可是 systemd 只管理用户态进程。那么，内核态线程又是谁来管理的呢？</p><p>实际上，Linux 在启动过程中，有三个特殊的进程，也就是 PID 号最小的三个进程。</p><ul>\n<li>\n<p>0 号进程为 idle 进程，这也是系统创建的第一个进程，它在初始化 1 号和 2 号进程后，演变为空闲任务。当 CPU 上没有其他任务执行时，就会运行它。</p>\n</li>\n<li>\n<p>1 号进程为 init 进程，通常是 systemd 进程，在用户态运行，用来管理其他用户态进程。</p>\n</li>\n<li>\n<p>2 号进程为 kthreadd 进程，在内核态运行，用来管理内核线程。</p>\n</li>\n</ul><p>所以，要查找内核线程，我们只需要从 2 号进程开始，查找它的子孙进程即可。比如，你可以使用 ps 命令，来查找 kthreadd 的子进程：</p><pre><code>$ ps -f --ppid 2 -p 2\nUID         PID   PPID  C STIME TTY          TIME CMD\nroot          2      0  0 12:02 ?        00:00:01 [kthreadd]\nroot          9      2  0 12:02 ?        00:00:21 [ksoftirqd/0]\nroot         10      2  0 12:02 ?        00:11:47 [rcu_sched]\nroot         11      2  0 12:02 ?        00:00:18 [migration/0]\n...\nroot      11094      2  0 14:20 ?        00:00:00 [kworker/1:0-eve]\nroot      11647      2  0 14:27 ?        00:00:00 [kworker/0:2-cgr]\n</code></pre><p>从上面的输出，你能够看到，内核线程的名称（CMD）都在中括号里（这一点，我们前面内容也有提到过）。所以，更简单的方法，就是直接查找名称包含中括号的进程。比如：</p><pre><code>$ ps -ef | grep &quot;\\[.*\\]&quot;\nroot         2     0  0 08:14 ?        00:00:00 [kthreadd]\nroot         3     2  0 08:14 ?        00:00:00 [rcu_gp]\nroot         4     2  0 08:14 ?        00:00:00 [rcu_par_gp]\n...\n</code></pre><p>了解内核线程的基本功能，对我们排查问题有非常大的帮助。比如，我们曾经在软中断案例中提到过 ksoftirqd。它是一个用来处理软中断的内核线程，并且每个 CPU 上都有一个。</p><p>如果你知道了这一点，那么，以后遇到 ksoftirqd 的 CPU 使用高的情况，就会首先怀疑是软中断的问题，然后从软中断的角度来进一步分析。</p><p>其实，除了刚才看到的 kthreadd 和 ksoftirqd 外，还有很多常见的内核线程，我们在性能分析中都经常会碰到，比如下面这几个内核线程。</p><ul>\n<li>\n<p><strong>kswapd0</strong>：用于内存回收。在  <a href=\"https://time.geekbang.org/column/article/75797\">Swap变高</a> 案例中，我曾介绍过它的工作原理。</p>\n</li>\n<li>\n<p><strong>kworker</strong>：用于执行内核工作队列，分为绑定 CPU （名称格式为 kworker/CPU:ID）和未绑定 CPU（名称格式为 kworker/uPOOL:ID）两类。</p>\n</li>\n<li>\n<p><strong>migration</strong>：在负载均衡过程中，把进程迁移到 CPU 上。每个 CPU 都有一个 migration 内核线程。</p>\n</li>\n<li>\n<p><strong>jbd2</strong>/sda1-8：jbd 是 Journaling Block Device 的缩写，用来为文件系统提供日志功能，以保证数据的完整性；名称中的 sda1-8，表示磁盘分区名称和设备号。每个使用了 ext4 文件系统的磁盘分区，都会有一个 jbd2 内核线程。</p>\n</li>\n<li>\n<p><strong>pdflush</strong>：用于将内存中的脏页（被修改过，但还未写入磁盘的文件页）写入磁盘（已经在 3.10 中合并入了 kworker 中）。</p>\n</li>\n</ul><p>了解这几个容易发生性能问题的内核线程，有助于我们更快地定位性能瓶颈。接下来，我们来看今天的案例。</p><h2>案例准备</h2><p>今天的案例还是基于 Ubuntu 18.04，同样适用于其他的 Linux 系统。我使用的案例环境如下所示：</p><ul>\n<li>\n<p>机器配置：2 CPU，8GB 内存。</p>\n</li>\n<li>\n<p>预先安装 docker、perf、hping3、curl 等工具，如 apt install docker.io linux-tools-common hping3。</p>\n</li>\n</ul><p>本次案例用到两台虚拟机，我画了一张图来表示它们的关系。</p><p><img src=\"https://static001.geekbang.org/resource/image/7d/11/7dd0763a14713940e7c762a62387dd11.png?wh=816*516\" alt=\"\"></p><p>你需要打开两个终端，分别登录这两台虚拟机中，并安装上述工具。</p><p>注意，以下所有命令都默认以 root 用户运行，如果你用普通用户身份登陆系统，请运行 sudo su root 命令，切换到 root 用户。</p><blockquote>\n<p>如果安装过程有问题，你可以先上网搜索解决，实在解决不了的，记得在留言区向我提问。</p>\n</blockquote><p>到这里，准备工作就完成了。接下来，我们正式进入操作环节。</p><h2>案例分析</h2><p>安装完成后，我们先在第一个终端，执行下面的命令运行案例，也就是一个最基本的 Nginx 应用：</p><pre><code># 运行Nginx服务并对外开放80端口\n$ docker run -itd --name=nginx -p 80:80 nginx\n</code></pre><p>然后，在第二个终端，使用 curl 访问 Nginx 监听的端口，确认 Nginx 正常启动。假设 192.168.0.30 是 Nginx 所在虚拟机的 IP 地址，运行 curl 命令后，你应该会看到下面这个输出界面：</p><pre><code>$ curl http://192.168.0.30/\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n...\n</code></pre><p>接着，还是在第二个终端中，运行 hping3 命令，模拟 Nginx 的客户端请求：</p><pre><code># -S参数表示设置TCP协议的SYN（同步序列号），-p表示目的端口为80\n# -i u10表示每隔10微秒发送一个网络帧\n# 注：如果你在实践过程中现象不明显，可以尝试把10调小，比如调成5甚至1\n$ hping3 -S -p 80 -i u10 192.168.0.30\n</code></pre><p>现在，我们再回到第一个终端，你应该就会发现异常——系统的响应明显变慢了。我们不妨执行 top，观察一下系统和进程的 CPU 使用情况：</p><pre><code>$ top\ntop - 08:31:43 up 17 min,  1 user,  load average: 0.00, 0.00, 0.02\nTasks: 128 total,   1 running,  69 sleeping,   0 stopped,   0 zombie\n%Cpu0  :  0.3 us,  0.3 sy,  0.0 ni, 66.8 id,  0.3 wa,  0.0 hi, 32.4 si,  0.0 st\n%Cpu1  :  0.0 us,  0.3 sy,  0.0 ni, 65.2 id,  0.0 wa,  0.0 hi, 34.5 si,  0.0 st\nKiB Mem :  8167040 total,  7234236 free,   358976 used,   573828 buff/cache\nKiB Swap:        0 total,        0 free,        0 used.  7560460 avail Mem\n\n  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n    9 root      20   0       0      0      0 S   7.0  0.0   0:00.48 ksoftirqd/0\n   18 root      20   0       0      0      0 S   6.9  0.0   0:00.56 ksoftirqd/1\n 2489 root      20   0  876896  38408  21520 S   0.3  0.5   0:01.50 docker-containe\n 3008 root      20   0   44536   3936   3304 R   0.3  0.0   0:00.09 top\n    1 root      20   0   78116   9000   6432 S   0.0  0.1   0:11.77 systemd\n ...\n</code></pre><p>从 top 的输出中，你可以看到，两个 CPU 的软中断使用率都超过了 30%；而 CPU 使用率最高的进程，正好是软中断内核线程 ksoftirqd/0 和 ksoftirqd/1。</p><p>虽然，我们已经知道了 ksoftirqd 的基本功能，可以猜测是因为大量网络收发，引起了 CPU 使用率升高；但它到底在执行什么逻辑，我们却并不知道。</p><p>对于普通进程，我们要观察其行为有很多方法，比如 strace、pstack、lsof 等等。但这些工具并不适合内核线程，比如，如果你用 pstack ，或者通过 /proc/pid/stack 查看 ksoftirqd/0（进程号为 9）的调用栈时，分别可以得到以下输出：</p><pre><code>$ pstack 9\nCould not attach to target 9: Operation not permitted.\ndetach: No such process\n</code></pre><pre><code>$ cat /proc/9/stack\n[&lt;0&gt;] smpboot_thread_fn+0x166/0x170\n[&lt;0&gt;] kthread+0x121/0x140\n[&lt;0&gt;] ret_from_fork+0x35/0x40\n[&lt;0&gt;] 0xffffffffffffffff\n</code></pre><p>显然，pstack 报出的是不允许挂载进程的错误；而 /proc/9/stack 方式虽然有输出，但输出中并没有详细的调用栈情况。</p><p>那还有没有其他方法，来观察内核线程 ksoftirqd 的行为呢？</p><p>既然是内核线程，自然应该用到内核中提供的机制。回顾一下我们之前用过的 CPU 性能工具，我想你肯定还记得 perf ，这个内核自带的性能剖析工具。</p><p>perf 可以对指定的进程或者事件进行采样，并且还可以用调用栈的形式，输出整个调用链上的汇总信息。 我们不妨就用 perf ，来试着分析一下进程号为 9 的 ksoftirqd。</p><p>继续在终端一中，执行下面的 perf record 命令；并指定进程号 9 ，以便记录 ksoftirqd 的行为:</p><pre><code># 采样30s后退出\n$ perf record -a -g -p 9 -- sleep 30\n</code></pre><p>稍等一会儿，在上述命令结束后，继续执行 <code>perf report</code>命令，你就可以得到 perf 的汇总报告。按上下方向键以及回车键，展开比例最高的 ksoftirqd 后，你就可以得到下面这个调用关系链图：</p><p><img src=\"https://static001.geekbang.org/resource/image/73/01/73f5e9a9e510b9f3bf634c5e94e67801.png?wh=1494*1366\" alt=\"\"></p><p>从这个图中，你可以清楚看到 ksoftirqd 执行最多的调用过程。虽然你可能不太熟悉内核源码，但通过这些函数，我们可以大致看出它的调用栈过程。</p><ul>\n<li>\n<p>net_rx_action 和 netif_receive_skb，表明这是接收网络包（rx 表示 receive）。</p>\n</li>\n<li>\n<p>br_handle_frame ，表明网络包经过了网桥（br 表示 bridge）。</p>\n</li>\n<li>\n<p>br_nf_pre_routing ，表明在网桥上执行了 netfilter 的 PREROUTING（nf 表示 netfilter）。而我们已经知道 PREROUTING 主要用来执行 DNAT，所以可以猜测这里有 DNAT 发生。</p>\n</li>\n<li>\n<p>br_pass_frame_up，表明网桥处理后，再交给桥接的其他桥接网卡进一步处理。比如，在新的网卡上接收网络包、执行 netfilter 过滤规则等等。</p>\n</li>\n</ul><p>我们的猜测对不对呢？实际上，我们案例最开始用 Docker 启动了容器，而 Docker 会自动为容器创建虚拟网卡、桥接到 docker0 网桥并配置 NAT 规则。这一过程，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/72/70/72f2f1fa7a464e4465108d4eadcc1b70.png?wh=1244*1620\" alt=\"\"></p><p>当然了，前面 perf report 界面的调用链还可以继续展开。但很不幸，我的屏幕不够大，如果展开更多的层级，最后几个层级会超出屏幕范围。这样，即使我们能看到大部分的调用过程，却也不能说明后面层级就没问题。</p><p>那么，有没有更好的方法，来查看整个调用栈的信息呢？</p><h2>火焰图</h2><p>针对 perf 汇总数据的展示问题，Brendan Gragg 发明了<a href=\"http://www.brendangregg.com/flamegraphs.html\">火焰图</a>，通过矢量图的形式，更直观展示汇总结果。下图就是一个针对 mysql 的火焰图示例。</p><p><img src=\"https://static001.geekbang.org/resource/image/68/61/68b80d299b23b0cee518001f78960f61.png?wh=1976*1184\" alt=\"\"></p><p>（图片来自 Brendan Gregg <a href=\"http://www.brendangregg.com/flamegraphs.html\">博客</a>）</p><p>这张图看起来像是跳动的火焰，因此也就被称为火焰图。要理解火焰图，我们最重要的是区分清楚横轴和纵轴的含义。</p><ul>\n<li>\n<p><strong>横轴表示采样数和采样比例</strong>。一个函数占用的横轴越宽，就代表它的执行时间越长。同一层的多个函数，则是按照字母来排序。</p>\n</li>\n<li>\n<p><strong>纵轴表示调用栈</strong>，由下往上根据调用关系逐个展开。换句话说，上下相邻的两个函数中，下面的函数，是上面函数的父函数。这样，调用栈越深，纵轴就越高。</p>\n</li>\n</ul><p>另外，要注意图中的颜色，并没有特殊含义，只是用来区分不同的函数。</p><p>火焰图是动态的矢量图格式，所以它还支持一些动态特性。比如，鼠标悬停到某个函数上时，就会自动显示这个函数的采样数和采样比例。而当你用鼠标点击函数时，火焰图就会把该层及其上的各层放大，方便你观察这些处于火焰图顶部的调用栈的细节。</p><p>上面 mysql 火焰图的示例，就表示了 CPU 的繁忙情况，这种火焰图也被称为 on-CPU 火焰图。如果我们根据性能分析的目标来划分，火焰图可以分为下面这几种。</p><ul>\n<li>\n<p><strong>on-CPU 火焰图</strong>：表示 CPU 的繁忙情况，用在 CPU 使用率比较高的场景中。</p>\n</li>\n<li>\n<p><strong>off-CPU 火焰图</strong>：表示 CPU 等待 I/O、锁等各种资源的阻塞情况。</p>\n</li>\n<li>\n<p><strong>内存火焰图</strong>：表示内存的分配和释放情况。</p>\n</li>\n<li>\n<p><strong>热/冷火焰图</strong>：表示将 on-CPU 和 off-CPU 结合在一起综合展示。</p>\n</li>\n<li>\n<p><strong>差分火焰图</strong>：表示两个火焰图的差分情况，红色表示增长，蓝色表示衰减。差分火焰图常用来比较不同场景和不同时期的火焰图，以便分析系统变化前后对性能的影响情况。</p>\n</li>\n</ul><p>了解了火焰图的含义和查看方法后，接下来，我们再回到案例，运用火焰图来观察刚才 perf record 得到的记录。</p><h2>火焰图分析</h2><p>首先，我们需要生成火焰图。我们先下载几个能从 perf record 记录生成火焰图的工具，这些工具都放在 <a href=\"https://github.com/brendangregg/FlameGraph\">https://github.com/brendangregg/FlameGraph</a> 上面。你可以执行下面的命令来下载：</p><pre><code>$ git clone https://github.com/brendangregg/FlameGraph\n$ cd FlameGraph\n</code></pre><p>安装好工具后，要生成火焰图，其实主要需要三个步骤：</p><ol>\n<li>\n<p>执行 perf script ，将 perf record 的记录转换成可读的采样记录；</p>\n</li>\n<li>\n<p>执行 stackcollapse-perf.pl 脚本，合并调用栈信息；</p>\n</li>\n<li>\n<p>执行 flamegraph.pl 脚本，生成火焰图。</p>\n</li>\n</ol><p>不过，在 Linux 中，我们可以使用管道，来简化这三个步骤的执行过程。假设刚才用 perf record 生成的文件路径为 /root/perf.data，执行下面的命令，你就可以直接生成火焰图：</p><pre><code>$ perf script -i /root/perf.data | ./stackcollapse-perf.pl --all |  ./flamegraph.pl &gt; ksoftirqd.svg\n</code></pre><p>执行成功后，使用浏览器打开 ksoftirqd.svg ，你就可以看到生成的火焰图了。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/cd/6d4f1fece12407906aacedf5078e53cd.png?wh=2370*1360\" alt=\"\"></p><p>根据刚刚讲过的火焰图原理，这个图应该从下往上看，沿着调用栈中最宽的函数来分析执行次数最多的函数。这儿看到的结果，其实跟刚才的 perf report 类似，但直观了很多，中间这一团火，很明显就是最需要我们关注的地方。</p><p>我们顺着调用栈由下往上看（顺着图中蓝色箭头），就可以得到跟刚才 perf report 中一样的结果：</p><ul>\n<li>\n<p>最开始，还是 net_rx_action 到 netif_receive_skb 处理网络收包；</p>\n</li>\n<li>\n<p>然后， br_handle_frame 到 br_nf_pre_routing ，在网桥中接收并执行 netfilter 钩子函数；</p>\n</li>\n<li>\n<p>再向上， br_pass_frame_up 到 netif_receive_skb ，从网桥转到其他网络设备又一次接收。</p>\n</li>\n</ul><p>不过最后，到了 ip_forward 这里，已经看不清函数名称了。所以我们需要点击 ip_forward，展开最上面这一块调用栈：</p><p><img src=\"https://static001.geekbang.org/resource/image/41/a3/416291ba2f9c039a0507f913572a21a3.png?wh=2388*1374\" alt=\"\"></p><p>这样，就可以进一步看到 ip_forward 后的行为，也就是把网络包发送出去。根据这个调用过程，再结合我们前面学习的网络收发和 TCP/IP 协议栈原理，这个流程中的网络接收、网桥以及 netfilter 调用等，都是导致软中断 CPU 升高的重要因素，也就是影响网络性能的潜在瓶颈。</p><p>不过，回想一下网络收发的流程，你可能会觉得它缺了好多步骤。</p><p>比如，这个堆栈中并没有 TCP 相关的调用，也没有连接跟踪 conntrack 相关的函数。实际上，这些流程都在其他更小的火焰中，你可以点击上图左上角的“Reset Zoom”，回到完整火焰图中，再去查看其他小火焰的堆栈。</p><p>所以，在理解这个调用栈时要注意。从任何一个点出发、纵向来看的整个调用栈，其实只是最顶端那一个函数的调用堆栈，而非完整的内核网络执行流程。</p><p>另外，整个火焰图不包含任何时间的因素，所以并不能看出横向各个函数的执行次序。</p><p>到这里，我们就找出了内核线程 ksoftirqd 执行最频繁的函数调用堆栈，而这个堆栈中的各层级函数，就是潜在的性能瓶颈来源。这样，后面想要进一步分析、优化时，也就有了根据。</p><h2>小结</h2><p>今天这个案例，你可能会觉得比较熟悉。实际上，这个案例，正是我们专栏 CPU 模块中的  <a href=\"https://time.geekbang.org/column/article/72147\">软中断案例</a>。</p><p>当时，我们从软中断 CPU 使用率的角度入手，用网络抓包的方法找出了瓶颈来源，确认是测试机器发送的大量 SYN 包导致的。而通过今天的 perf 和火焰图方法，我们进一步找出了软中断内核线程的热点函数，其实也就找出了潜在的瓶颈和优化方向。</p><p>其实，如果遇到的是内核线程的资源使用异常，很多常用的进程级性能工具并不能帮上忙。这时，你就可以用内核自带的 perf 来观察它们的行为，找出热点函数，进一步定位性能瓶。当然，perf 产生的汇总报告并不够直观，所以我也推荐你用火焰图来协助排查。</p><p>实际上，火焰图方法同样适用于普通进程。比如，在分析 Nginx、MySQL 等各种应用场景的性能问题时，火焰图也能帮你更快定位热点函数，找出潜在性能问题。</p><h2>思考</h2><p>最后，我想邀请你一起来聊聊，你碰到过的内核线程性能问题。你是怎么分析它们的根源？又是怎么解决的？你可以结合我的讲述，总结自己的思路。</p><p>欢迎在留言区和我讨论，也欢迎把这篇文章分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p><p></p>","neighbors":{"left":{"article_title":"48 | 案例篇：服务器总是时不时丢包，我该怎么办？（下）","id":85688},"right":{"article_title":"50 | 案例篇：动态追踪怎么用？（上）","id":86490}},"comments":[{"had_liked":false,"id":82010,"user_name":"李逍遥","can_delete":false,"product_type":"c1","uid":1109750,"ip_address":"","ucode":"DB74823527E203","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xzHDjCSFicNY3MUMECtNz6sM8yDJhBoyGk5IRoOtUat6ZIkGzxjqEqwqKYWMD3GjehScKvMjicGOGDog5FF18oyg/132","comment_is_top":false,"comment_ctime":1554102137,"is_pvip":false,"replies":[{"id":"29831","content":"火焰图的结构是一样的，只是函数堆栈不一样，内存火焰图侧重于内存管理函数的调用栈","user_name":"作者回复","comment_id":82010,"uid":"1001282","ip_address":"","utype":1,"ctime":1554209408,"user_name_real":"倪朋飞"}],"discussion_count":1,"race_medal":0,"score":"31618873209","product_id":100020901,"comment_content":"cpu火焰图和内存火焰图，在生成数据时有什么不同？","like_count":8,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445427,"discussion_content":"火焰图的结构是一样的，只是函数堆栈不一样，内存火焰图侧重于内存管理函数的调用栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554209408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":82560,"user_name":"李逍遥","can_delete":false,"product_type":"c1","uid":1109750,"ip_address":"","ucode":"DB74823527E203","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/xzHDjCSFicNY3MUMECtNz6sM8yDJhBoyGk5IRoOtUat6ZIkGzxjqEqwqKYWMD3GjehScKvMjicGOGDog5FF18oyg/132","comment_is_top":false,"comment_ctime":1554251967,"is_pvip":false,"replies":[{"id":"30195","content":"要加上内存管理相关的事件（函数），比如perf record -e syscalls:sys_enter_mmap -a -g -- sleep 60","user_name":"作者回复","comment_id":82560,"uid":"1001282","ip_address":"","utype":1,"ctime":1554639382,"user_name_real":"倪朋飞"}],"discussion_count":1,"race_medal":0,"score":"23029088447","product_id":100020901,"comment_content":"老师，能讲讲内存火焰图生成perf.data数据时,perf record加哪些选项吗？","like_count":6,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":445638,"discussion_content":"要加上内存管理相关的事件（函数），比如perf record -e syscalls:sys_enter_mmap -a -g -- sleep 60","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1554639382,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174255,"user_name":"安排","can_delete":false,"product_type":"c1","uid":1260026,"ip_address":"","ucode":"F78CFA9624CAEF","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/fa/a7edbc72.jpg","comment_is_top":false,"comment_ctime":1580110535,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18759979719","product_id":100020901,"comment_content":"横轴的长短代表执行时间长短，一个函数被调用多次那横轴很长，一个函数执行一次但是在里面休眠了，这算执行时间很长吗？on-cpu火焰图是不是只记录真正的在cpu上的执行时间而不把睡眠时间算在内？","like_count":5},{"had_liked":false,"id":78716,"user_name":"青石","can_delete":false,"product_type":"c1","uid":1215531,"ip_address":"","ucode":"B0056AD6453322","user_header":"https://static001.geekbang.org/account/avatar/00/12/8c/2b/3ab96998.jpg","comment_is_top":false,"comment_ctime":1553223721,"is_pvip":false,"replies":[{"id":"28746","content":"内核里面其实就提供了很多工具，可以参考下50和51篇中的动态追踪方法","user_name":"作者回复","comment_id":78716,"uid":"1001282","ip_address":"","utype":1,"ctime":1553316460,"user_name_real":"倪朋飞"}],"discussion_count":1,"race_medal":0,"score":"10143158313","product_id":100020901,"comment_content":"两周时间，终于追上来了。<br><br>请问老师，有哪些书有助于通过内核函数来定位故障，Linux用了9年，看到这还是感觉有些吃力。<br><br>内核线程问题，我的环境和老师的有些区别，没有br_nf_pre_routing函数调用，但是从ip_forward推测与消息转发有关，sar发现有大量小包接收，conntrack -L看到大量本机到docker地址的SYN_SENT状态的连接、hping3服务器到测试服务器的SYN_RECV状态连接。初步定位到具体的docker。<br><br>上面思考的过程，有点因为知道问题点，所以朝这个方向走的感觉。","like_count":3,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":444204,"discussion_content":"内核里面其实就提供了很多工具，可以参考下50和51篇中的动态追踪方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1553316460,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77450,"user_name":"行者","can_delete":false,"product_type":"c1","uid":1063734,"ip_address":"","ucode":"EA31201A7C5AE1","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/36/2d61e080.jpg","comment_is_top":false,"comment_ctime":1552928084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5847895380","product_id":100020901,"comment_content":"很赞，准备回去用火焰图分析下我们后端服务。^ _ ^","like_count":1},{"had_liked":false,"id":77255,"user_name":"2xshu","can_delete":false,"product_type":"c1","uid":1188473,"ip_address":"","ucode":"71584CB9676EDF","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKsz8j0bAayjSne9iakvjzUmvUdxWEbsM9iasQ74spGFayIgbSE232sH2LOWmaKtx1WqAFDiaYgVPwIQ/132","comment_is_top":false,"comment_ctime":1552898555,"is_pvip":false,"replies":[{"id":"28162","content":"不是，看原来的目录，还有好些篇","user_name":"作者回复","comment_id":77255,"uid":"1001282","ip_address":"","utype":1,"ctime":1552903829,"user_name_real":"倪朋飞"}],"discussion_count":1,"race_medal":0,"score":"5847865851","product_id":100020901,"comment_content":"老师，这是最后一节课程吗？","like_count":1,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443658,"discussion_content":"不是，看原来的目录，还有好些篇","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552903829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345149,"user_name":"Geek_1b7d36","can_delete":false,"product_type":"c1","uid":2247772,"ip_address":"","ucode":"A003032EAD0CFD","user_header":"","comment_is_top":false,"comment_ctime":1652079522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652079522","product_id":100020901,"comment_content":"top发现load average : 2270.00  ,2270.26,  2270.26,<br>但是cpu使用率不超过10% ，32C64G的机器，其他的进程的CPU很低，就是这个负载很高，这个怎么排查呢，老师","like_count":0},{"had_liked":false,"id":333037,"user_name":"无","can_delete":false,"product_type":"c1","uid":1015918,"ip_address":"","ucode":"CF9F79815606F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/80/6e/7f78292e.jpg","comment_is_top":false,"comment_ctime":1644018278,"is_pvip":true,"replies":[{"id":"121728","content":"可以用 ebpf 跟踪调用栈","user_name":"作者回复","comment_id":333037,"uid":"1001282","ip_address":"","utype":1,"ctime":1644116428,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1644018278","product_id":100020901,"comment_content":"请问有没有可以表示调用顺序的火焰图? 或者类似的其它图??? 感觉这样更有用阿","like_count":1,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549585,"discussion_content":"可以用 ebpf 跟踪调用栈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644116429,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316351,"user_name":"AceslupK","can_delete":false,"product_type":"c1","uid":1284474,"ip_address":"","ucode":"048F84D019CBBB","user_header":"https://static001.geekbang.org/account/avatar/00/13/99/7a/558666a5.jpg","comment_is_top":false,"comment_ctime":1634281547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634281547","product_id":100020901,"comment_content":"此处火焰图，吃力了。依旧还是没看明白该怎么找出未知问题，还是觉得这次是有着方向的解决问题","like_count":0},{"had_liked":false,"id":301642,"user_name":"opdozz","can_delete":false,"product_type":"c1","uid":2641975,"ip_address":"","ucode":"25E81DC87D6213","user_header":"","comment_is_top":false,"comment_ctime":1625796638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625796638","product_id":100020901,"comment_content":"老师，最近碰到一个kworker内核进程问题，48C的服务器，docker宿主机， 某个kworker会占满两个CPU，一个sys跑满，另外一个iowait跑满，剩下的CPU都很空闲，但是业务处理很慢，重启之后就好了，但是过段时间又复发， 不规律。<br>perf收集了信息，__rpc_execute 这个调用占了很多，下层nfs4_xdr_enc_open调用也占了很多，和挂的nas存储有关系吗，但是存储那边排查没有任何问题。","like_count":1},{"had_liked":false,"id":268609,"user_name":"Geek_c2089d","can_delete":false,"product_type":"c1","uid":1489545,"ip_address":"","ucode":"C66D345042525F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/4Lprf2mIWpJOPibgibbFCicMtp5bpIibyLFOnyOhnBGbusrLZC0frG0FGWqdcdCkcKunKxqiaOHvXbCFE7zKJ8TmvIA/132","comment_is_top":false,"comment_ctime":1608272841,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1608272841","product_id":100020901,"comment_content":"执行  <br>perf script -i &#47;root&#47;perf.data | .&#47;stackcollapse-perf.pl --all |  .&#47;flamegraph.pl &gt; ksoftirqd.svg<br>会报ERROR: No stack counts found错误，但是权限是都777的","like_count":0,"discussions":[{"author":{"id":2104708,"avatar":"https://static001.geekbang.org/account/avatar/00/20/1d/84/c35e492e.jpg","nickname":"风清扬","note":"","ucode":"0505791F8EA497","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574877,"discussion_content":"是因为你的perf的pid里面没有函数对栈，我猜想你应该不是抓取了一个正常的有数据请求的进程吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654416390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190970,"user_name":"董皋","can_delete":false,"product_type":"c1","uid":1902756,"ip_address":"","ucode":"2F05C3DDBC18F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJGMphabeneYRlxs1biaO9oKic6Dwgbe312561lE56V93uUHgXXAsGmK1pH18mvpElygoJh8SUtQPUA/132","comment_is_top":false,"comment_ctime":1584714765,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584714765","product_id":100020901,"comment_content":"打卡","like_count":0},{"had_liked":false,"id":155848,"user_name":"Littlesoup","can_delete":false,"product_type":"c1","uid":1502232,"ip_address":"","ucode":"CA1A3AFE0B25D6","user_header":"","comment_is_top":false,"comment_ctime":1574766878,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574766878","product_id":100020901,"comment_content":"&quot;一个函数占用的横轴越宽，就代表它的执行时间越长。&quot;<br>&quot;另外，整个火焰图不包含任何时间的因素，所以并不能看出横向各个函数的执行次序。&quot;<br>原文这两句话读起来有点困惑，第二句的意思是不是不包含任何时序的因素？","like_count":0},{"had_liked":false,"id":141084,"user_name":"乖，摸摸头","can_delete":false,"product_type":"c1","uid":1611745,"ip_address":"","ucode":"BD92741A11D3CD","user_header":"https://static001.geekbang.org/account/avatar/00/18/97/e1/0f4d90ff.jpg","comment_is_top":false,"comment_ctime":1571111415,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1571111415","product_id":100020901,"comment_content":"为啥我的一值都是显示的16进制而不是函数名","like_count":0},{"had_liked":false,"id":86925,"user_name":"如果","can_delete":false,"product_type":"c1","uid":1320638,"ip_address":"","ucode":"138A3EEEE50850","user_header":"","comment_is_top":false,"comment_ctime":1555479940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1555479940","product_id":100020901,"comment_content":"DAY49，打卡<br>","like_count":0},{"had_liked":false,"id":77197,"user_name":"我来也","can_delete":false,"product_type":"c1","uid":1205253,"ip_address":"","ucode":"773D6104F56767","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/05/6989dce6.jpg","comment_is_top":false,"comment_ctime":1552881799,"is_pvip":false,"replies":[{"id":"28160","content":"嗯嗯 Go内置了pprof 工具，用起来更简单","user_name":"作者回复","comment_id":77197,"uid":"1001282","ip_address":"","utype":1,"ctime":1552903478,"user_name_real":"倪朋飞"}],"discussion_count":1,"race_medal":0,"score":"1552881799","product_id":100020901,"comment_content":"[D49打卡]<br>之前用火焰图分析过golang程序的内存分配及cpu使用率情况.感觉非常直观.能快速找到瓶颈.","like_count":1,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443633,"discussion_content":"嗯嗯 Go内置了pprof 工具，用起来更简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552903478,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":77136,"user_name":"ninuxer","can_delete":false,"product_type":"c1","uid":1243135,"ip_address":"","ucode":"5394ADAF2667D6","user_header":"https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEKQMM4m7NHuicr55aRiblTSEWIYe0QqbpyHweaoAbG7j2v7UUElqqeP3Ihrm3UfDPDRb1Hv8LvPwXqA/132","comment_is_top":false,"comment_ctime":1552867778,"is_pvip":false,"replies":[{"id":"28156","content":"嗯嗯","user_name":"作者回复","comment_id":77136,"uid":"1001282","ip_address":"","utype":1,"ctime":1552903018,"user_name_real":"倪朋飞"}],"discussion_count":1,"race_medal":0,"score":"1552867778","product_id":100020901,"comment_content":"打卡day52<br>有碰到一个内核问题，docker宿主机上kworker&#47;u80进程的cpu占用率一直100%，其他的kworker进程都正常，每隔几个月就会碰到一次，为了快速恢复业务，就直接重启了，主要是没办法在线下实验的时候复现问题，所以就没有深入的分析，后面碰到后，可以用老师的方法，把perf record采集一段时间的调用信息，然后拿出去分析下👍","like_count":0,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":443598,"discussion_content":"嗯嗯","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1552903018,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}