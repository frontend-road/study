{"id":101086,"title":"11 | 剖析Lua唯一的数据结构table和metatable特性","content":"<p>你好，我是温铭。今天我们一起学习下LuaJIT 中唯一的数据结构：<code>table</code>。</p><p>和其他具有丰富数据结构的脚本语言不同，LuaJIT 中只有 <code>table</code> 这一个数据结构，并没有区分开数组、哈希、集合等概念，而是揉在了一起。让我们先温习下之前提到过的一个例子：</p><pre><code>local color = {first = &quot;red&quot;, &quot;blue&quot;, third = &quot;green&quot;, &quot;yellow&quot;}\nprint(color[&quot;first&quot;])                 --&gt; output: red\nprint(color[1])                         --&gt; output: blue\nprint(color[&quot;third&quot;])                --&gt; output: green\nprint(color[2])                         --&gt; output: yellow\nprint(color[3])                         --&gt; output: nil\n</code></pre><p>这个例子中， <code>color</code> 这个 table 包含了数组和哈希，并且可以互不干扰地进行访问。比如，你可以用 <code>ipairs</code> 函数，只遍历数组部分的内容：</p><pre><code>$ resty -e 'local color = {first = &quot;red&quot;, &quot;blue&quot;, third = &quot;green&quot;, &quot;yellow&quot;}\nfor k, v in ipairs(color) do\n     print(k)\nend\n'\n</code></pre><p><code>table</code> 的操作是如此重要，以至于 LuaJIT 对标准 Lua 5.1 的 table 库做了扩展，而 OpenResty 又对 LuaJIT 的 table 库做了更进一步的扩展。下面，我们就一起来分别看下这些库函数。</p><h2>table 库函数</h2><p>先来看标准table 库函数。Lua 5.1 中自带的 table 库函数并不多，我们可以大概浏览一遍。</p><h3><code>table.getn</code> 获取元素个数</h3><p>我们在 <code>标准 Lua 和 LuaJIT</code> 章节中曾经提到过，想正确地获取到 table 所有元素的个数，在 LuaJIT 中是一个老大难问题。</p><p>对于序列，你用<code>table.getn</code> 或者一元操作符 <code>#</code> ，就可以正确返回元素的个数。比如下面这个例子，就会返回我们预期中的 3。</p><!-- [[[read_end]]] --><pre><code>$ resty -e 'local t = { 1, 2, 3 }\nprint(table.getn(t)) '\n</code></pre><p>而对于不是序列的 table，就无法返回正确的值。比如第二个例子，返回的就是 1。</p><pre><code>$ resty -e 'local t = { 1, a = 2 }\nprint(#t) '\n</code></pre><p>不过，幸运的是，这种难以理解的函数，已经被 LuaJIT 的扩展替代，后面我们会提到。所以在 OpenResty 的环境下，除非你明确知道，你正在获取序列的长度，否则请不要使用函数 <code>table.getn</code> 和一元操作符 <code>#</code> 。</p><p>另外，<code>table.getn</code> 和一元操作符 <code>#</code> 并不是 O(1) 的时间复杂度，而是 O(n)，这也是尽量避免使用它们的另外一个理由。</p><h3><code>table.remove</code> 删除指定元素</h3><p>第二个我们来看<code>table.remove</code> 函数，它的作用是在 table 中根据下标来删除元素，也就是说只能删除 table 中数组部分的元素。我们还是来看<code>color</code>的例子：</p><pre><code>$ resty -e 'local color = {first = &quot;red&quot;, &quot;blue&quot;, third = &quot;green&quot;, &quot;yellow&quot;}\n  table.remove(color, 1)\n  for k, v in pairs(color) do\n      print(v)\n  end'\n</code></pre><p>这段代码会把下标为 1 的 <code>blue</code> 删除掉。你可能会问，那该如何删除 table 中的哈希部分呢？也很简单，把 key 对应的 value 设置为 <code>nil</code> 即可。这样，<code>color</code>这个例子中，<code>third</code> 对应的<code>green</code>就被删除了。</p><pre><code>$ resty -e 'local color = {first = &quot;red&quot;, &quot;blue&quot;, third = &quot;green&quot;, &quot;yellow&quot;}\n  color.third = nil\n  for k, v in pairs(color) do\n      print(v)\n  end'\n</code></pre><h3><code>table.concat</code> 元素拼接函数</h3><p>第三个我们来看<code>table.concat</code> 元素拼接函数。它可以按照下标，把 table 中的元素拼接起来。既然这里又是根据下标来操作的，那么显然还是针对 table 的数组部分。同样还是<code>color</code>这个例子：</p><pre><code>$ resty -e 'local color = {first = &quot;red&quot;, &quot;blue&quot;, third = &quot;green&quot;, &quot;yellow&quot;}\nprint(table.concat(color, &quot;, &quot;))'\n</code></pre><p>使用<code>table.concat</code>函数后，它输出的是 <code>blue, yellow</code>，哈希的部分被跳过了。</p><p>另外，这个函数还可以指定下标的起始位置来做拼接，比如下面这样的写法：</p><pre><code>$ resty -e 'local color = {first = &quot;red&quot;, &quot;blue&quot;, third = &quot;green&quot;, &quot;yellow&quot;, &quot;orange&quot;}\nprint(table.concat(color, &quot;, &quot;, 2, 3))'\n</code></pre><p>这次输出是 <code>yellow, orange</code>，跳过了 <code>blue</code>。</p><p>你可能觉得这些操作还挺简单的，不过，我要说的是，函数不可貌相，海水不可。千万不要小看这个看上去没有太大用处的函数，在做性能优化时，它却会有意想不到的作用，也是我们后面性能优化章节中的主角之一。</p><h3><code>table.insert</code> 插入一个元素</h3><p>最后我们来看<code>table.insert</code> 函数。它可以下标插入一个新的元素，自然，影响的还是 table 的数组部分。还是用<code>color</code>例子来说明：</p><pre><code>$ resty -e 'local color = {first = &quot;red&quot;, &quot;blue&quot;, third = &quot;green&quot;, &quot;yellow&quot;}\ntable.insert(color, 1,  &quot;orange&quot;)\nprint(color[1])\n'\n</code></pre><p>你可以看到， color 的第一个元素变为了 orange。当然，你也可以不指定下标，这样就会默认插入队尾。</p><p>这里我必须说明的是，<code>table.insert</code> 虽然是一个很常见的操作，但性能并不乐观。如果你不是根据指定下标来插入元素，那么每次都需要调用 LuaJIT 的 <code>lj_tab_len</code> 来获取数组的长度，以便插入队尾。正如我们在 <code>table.getn</code> 中提到的，获取 table 长度的时间复杂度为 O(n) 。</p><p>所以，对于<code>table.insert</code> 操作，我们应该尽量避免在热代码中使用，比如：</p><pre><code>local t = {}\nfor i = 1, 10000 do\n     table.insert(t, i)\nend\n</code></pre><h2>LuaJIT 的 table 扩展函数</h2><p>接下来我们来看LuaJIT 的 table 扩展函数。LuaJIT 在标准 Lua 的基础上，扩展了两个很有用的 table 函数，分别用来新建和清空一个 table，下面我具体来介绍一下。</p><h3><code>table.new(narray, nhash)</code> 新建 table</h3><p>第一个是<code>table.new(narray, nhash)</code> 函数。这个函数，会预先分配好指定的数组和哈希的空间大小，而不是在插入元素时自增长，这也是它的两个参数 <code>narray</code> 和 <code>nhash</code> 的含义。自增长是一个代价比较高的操作，会涉及到空间分配、<code>resize</code> 和 <code>rehash</code> 等，我们应该尽量避免。</p><p>这里注意，<code>table.new</code> 的文档并没有出现在 LuaJIT 的官网，而是深藏在 GitHub 项目的<a href=\"https://github.com/openresty/luajit2/blob/v2.1-agentzh/doc/extensions.html\">扩展文档</a>中，即使你用谷歌也难觅其踪迹，所以知道的工程师并不多。</p><p>下面是一个简单的例子，我来带你看下它该怎么用。首先要说明，这个函数是扩展出来的，所以在使用它之前，你需要先 <code>require</code> 一下：</p><pre><code>local new_tab = require &quot;table.new&quot;\nlocal t = new_tab(100, 0)\nfor i = 1, 100 do\n   t[i] = i\nend\n</code></pre><p>你可以看到，这段代码新建了一个 table，里面包含 100 个数组元素和 0 个哈希元素。当然，你也可以根据实际需要，新建一个同时包含 100 个数组元素和 50 个 哈希元素的 table，这都是合法的：</p><pre><code>local t = new_tab(100, 50)\n</code></pre><p>另外，超出预设的空间大小，也可以正常使用，只不过性能会退化，也就失去了使用 <code>table.new</code> 的意义。</p><p>比如下面这个例子，我们预设大小为 100，而实际上却使用了 200：</p><pre><code>local new_tab = require &quot;table.new&quot;\nlocal t = new_tab(100, 0)\nfor i = 1, 200 do\n   t[i] = i\nend\n</code></pre><p>所以，你需要根据实际场景，来预设好 <code>table.new</code> 中数组和哈希空间的大小，这样才能在性能和内存占用上找到一个平衡点。</p><h3><code>table.clear()</code> 清空 table</h3><p>第二个我们来看清空函数<code>table.clear()</code> 。它用来清空某个 table 里的所有数据，但并不会释放数组和哈希部分占用的内存。所以，它在循环利用 Lua table 时非常有用，可以避免反复创建和销毁 table 的开销。</p><pre><code>$ resty -e 'local clear_tab =require &quot;table.clear&quot;\nlocal color = {first = &quot;red&quot;, &quot;blue&quot;, third = &quot;green&quot;, &quot;yellow&quot;}\nclear_tab(color)\nfor k, v in pairs(color) do\n     print(k)\nend'\n</code></pre><p>不过，事实上，能使用这个函数的场景并不算多，大多数情况下，我们还是应该把这个任务交给 LuaJIT GC 去完成。</p><h2>OpenResty 的 table 扩展函数</h2><p>开头我提到过，OpenResty 自己维护的 LuaJIT 分支，也对 table 做了扩展，它<a href=\"https://github.com/openresty/luajit2/#new-api\">新增了几个 API</a>：<code>table.isempty</code>、<code>table.isarray</code>、 <code>table.nkeys</code> 和 <code>table.clone</code>。</p><p>需要注意的是，在使用这几个新增的 API 前，请记住检查你使用的 OpenResty 的版本，这些API 大都只能在 OpenResty 1.15.8.1 之后的版本中使用。这是因为， OpenResty 在 1.15.8.1 版本之前，已经有一年左右没有发布新版本了，而这些 API 是在这个发布间隔中新增的。</p><p>文章中我已经附上了链接，这里我就只用 <code>table.nkeys</code> 来举例说明下，其他的三个 API 从命名上来说都非常容易理解，你自己翻阅 GitHub 上的文档就可以明白了。不得不说，OpenResty 的文档质量非常高，其中包含了代码示例、能否被 JIT、需要注意的事项等，比起 Lua 和 LuaJIT 的文档，着实高了好几个数量级。</p><p>好的，回到<code>table.nkeys</code>函数上，它的命名可能会让你迷惑，不过，它实际上是获取 table 长度的函数，返回的是 table 的元素个数，包括数组和哈希部分的元素。因此，我们可以用它来替代 <code>table.getn</code>，比如下面这样来用：</p><pre><code>local nkeys = require &quot;table.nkeys&quot;\n\nprint(nkeys({}))  -- 0\nprint(nkeys({ &quot;a&quot;, nil, &quot;b&quot; }))  -- 2\nprint(nkeys({ dog = 3, cat = 4, bird = nil }))  -- 2\nprint(nkeys({ &quot;a&quot;, dog = 3, cat = 4 }))  -- 3\n</code></pre><h2>元表</h2><p>讲完了table函数，我们再来看下由 <code>table</code> 引申出来的 <code>元表</code>（metatable）。元表是 Lua 中独有的概念，在实际项目中的使用非常广泛。不夸张地说，在几乎所有的 <code>lua-resty-*</code> 库中，你都能看到它的身影。</p><p>元表的表现行为类似于操作符重载，比如我们可以重载 <code>__add</code>，来计算两个 Lua 数组的并集；或者重载 <code>__tostring</code>，来定义转换为字符串的函数。</p><p>而Lua 提供了两个处理元表的函数：</p><ul>\n<li>第一个是<code>setmetatable(table, metatable)</code>, 用于为一个 table 设置元表；</li>\n<li>第二个是<code>getmetatable(table)</code>，用于获取 table 的元表。</li>\n</ul><p>介绍了这么半天，你可能更关心它的作用，我们接着就来看下元表具体有什么用处。下面是一段真实项目里的代码：</p><pre><code>$ resty -e ' local version = {\n  major = 1,\n  minor = 1,\n  patch = 1\n  }\nversion = setmetatable(version, {\n    __tostring = function(t)\n      return string.format(&quot;%d.%d.%d&quot;, t.major, t.minor, t.patch)\n    end\n  })\n  print(tostring(version))\n'\n</code></pre><p>我们首先定义了一个 名为 <code>version</code>的table ，你可以看到，这段代码的目的，是想把 <code>version</code> 中的版本号打印出来。但是，我们并不能直接打印 <code>version</code>，你可以试着操作一下，就会发现，直接打印的话，只会输出这个 table 的地址。</p><pre><code>print(tostring(version))\n</code></pre><p>所以，我们需要自定义这个 table 的字符串转换函数，也就是 <code>__tostring</code>，到这一步也就是元表的用武之地了。我们用 <code>setmetatable</code> ，重新设置 <code>version</code> 这个 table 的 <code>__tostring</code> 方法，就可以打印出版本号: 1.1.1。</p><p>其实，除了 <code>__tostring</code> 之外，在实际项目中，我们还经常重载元表中的以下两个元方法（metamethod）。</p><p><strong>其中一个是<code>__index</code></strong>。我们在 table 中查找一个元素时，首先会直接从 table 中查询，如果没有找到，就继续到元表的 <code>__index</code> 中查询。</p><p>比如下面这个例子，我们把 <code>patch</code> 从 <code>version</code> 这个 table 中去掉：</p><pre><code>$ resty -e ' local version = {\n  major = 1,\n  minor = 1\n  }\nversion = setmetatable(version, {\n     __index = function(t, key)\n         if key == &quot;patch&quot; then\n             return 2\n         end\n     end,\n     __tostring = function(t)\n      return string.format(&quot;%d.%d.%d&quot;, t.major, t.minor, t.patch)\n    end\n  })\n  print(tostring(version))\n'\n</code></pre><p>这样的话，<code>t.patch</code> 其实获取不到值，那么就会走到 <code>__index</code> 这个函数中，结果就会打印出 1.1.2。</p><p>事实上，<code>__index</code> 不仅可以是一个函数，也可以是一个 table。你试着运行下面这段代码，就会看到，它们实现的效果是一样的。</p><pre><code>$ resty -e ' local version = {\n  major = 1,\n  minor = 1\n  }\nversion = setmetatable(version, {\n     __index = {patch = 2},\n     __tostring = function(t)\n      return string.format(&quot;%d.%d.%d&quot;, t.major, t.minor, t.patch)\n    end\n  })\n  print(tostring(version))\n'\n</code></pre><p><strong>另一个元方法则是<code>__call</code></strong>。它类似于仿函数，可以让 table 被调用。</p><p>我们还是基于上面打印版本号的代码来做修改，看看如何调用一个 table：</p><pre><code>$ resty -e '\nlocal version = {\n  major = 1,\n  minor = 1,\n  patch = 1\n  }\n\nlocal function print_version(t)\n     print(string.format(&quot;%d.%d.%d&quot;, t.major, t.minor, t.patch))\nend\n\nversion = setmetatable(version,\n     {__call = print_version})\n\n  version()\n'\n</code></pre><p>这段代码中，我们使用 <code>setmetatable</code>，给 <code>version</code> 这个 table 增加了元表，而里面的 <code>__call</code> 元方法指向了函数 <code>print_version</code> 。那么，如果我们尝试把 <code>version</code> 当作函数调用，这里就会执行函数 <code>print_version</code>。</p><p>而 <code>getmetatable</code> 是和 <code>setmetatable</code> 配对的操作，可以获取到已经设置的元表，比如下面这段代码：</p><pre><code>$ resty -e ' local version = {\n  major = 1,\n  minor = 1\n  }\nversion = setmetatable(version, {\n     __index = {patch = 2},\n     __tostring = function(t)\n      return string.format(&quot;%d.%d.%d&quot;, t.major, t.minor, t.patch)\n    end\n  })\n  print(getmetatable(version).__index.patch)\n'\n</code></pre><p>自然，除了今天讲到的这三个元方法外，还有一些不经常使用的元方法，你可以在遇到的时候再去查阅<a href=\"http://lua-users.org/wiki/MetamethodsTutorial\">文档</a>了解。</p><h2>面向对象</h2><p>最后我们来聊聊面向对象。你可能知道，Lua 并不是一个面向对象（Object Orientation）的语言，但我们可以使用 metatable 来实现 OO。</p><p>我们来看一个实际的例子。<a href=\"https://github.com/openresty/lua-resty-mysql/blob/master/lib/resty/mysql.lua\">lua-resty-mysql</a>  是 OpenResty 官方的 MySQL 客户端，里面就使用元表<strong>模拟</strong>了类和类方法，它的使用方式如下所示：</p><pre><code>$ resty -e 'local mysql = require &quot;resty.mysql&quot; -- 先引用 lua-resty 库\nlocal db, err = mysql:new() -- 新建一个类的实例\ndb:set_timeout(1000) -- 调用类的方法'\n</code></pre><p>你可以直接用 <code>resty</code> 命令行来执行上述代码。这几行代码很好理解，唯一可能给你造成困扰的是：</p><p><strong>在调用类方法的时候，为什么是冒号而不是点号呢？</strong></p><p>其实，在这里冒号和点号都是可以的，<code>db:set_timeout(1000)</code> 和 <code>db.set_timeout(db, 1000)</code> 是完全等价的。冒号是 Lua 中的一个语法糖，可以省略掉函数的第一个参数 <code>self</code>。</p><p>众所周知，源码面前没有秘密，让我们来看看上述几行代码所对应的具体实现，以便你更好理解，如何用元表来模拟面向对象：</p><pre><code>local _M = { _VERSION = '0.21' } -- 使用 table 模拟类\nlocal mt = { __index = _M } -- mt 即 metatable 的缩写，__index 指向类自身\n\n-- 类的构造函数\nfunction _M.new(self) \n     local sock, err = tcp()\n     if not sock then\n         return nil, err\n     end\n     return setmetatable({ sock = sock }, mt) -- 使用 table 和 metatable 模拟类的实例\nend\n \n-- 类的成员函数\n function _M.set_timeout(self, timeout) -- 使用 self 参数，获取要操作的类的实例\n     local sock = self.sock\n     if not sock then\n        return nil, &quot;not initialized&quot;\n     end\n\n    return sock:settimeout(timeout)\nend\n</code></pre><p>你可以看到，<code>_M</code> 这个 table 模拟了一个类，初始化时，它只有 <code>_VERSION</code> 这一个成员变量，并在随后定义了 <code>_M.set_timeout</code> 等成员函数。在 <code>_M.new(self)</code> 这个构造函数中，我们返回了一个 table，这个 table 的元表就是 <code>mt</code>，而 <code>mt</code> 的 <code>__index</code> 元方法指向了 <code>_M</code>，这样，返回的这个 table 就模拟了类 <code>_M</code> 的实例。</p><h2>写在最后</h2><p>好的，到这里，今天的主要内容就结束了。事实上，table 和 metatable 会大量地用在 OpenResty 的 <code>lua-resty-*</code> 库以及基于 OpenResty 的开源项目中，我希望通过这节课的学习，可以让你更容易地读懂这些源代码。</p><p>自然，除了 table 外，Lua 中还有其他一些常用的函数，我们下节课再一起来学习。</p><p>最后，我想给你留一个思考题。为什么 <code>lua-resty-mysql</code> 库要模拟 OO 来做一层封装呢？欢迎在留言区一起讨论这个问题，也欢迎你把这篇文章分享给你的同事、朋友，我们一起交流，一起进步。</p><p></p>","neighbors":{"left":{"article_title":"10 | JIT编译器的死穴：为什么要避免使用 NYI ？","id":100912},"right":{"article_title":"12 | 高手秘诀：识别Lua的独有概念和坑","id":101706}},"comments":[{"had_liked":false,"id":109300,"user_name":"wusiration","can_delete":false,"product_type":"c1","uid":1104438,"ip_address":"","ucode":"A9403377054F1E","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/36/ac0ff6a7.jpg","comment_is_top":false,"comment_ctime":1561994624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"31626765696","product_id":100028301,"comment_content":"lua-resty-mysql 模拟OO，个人理解是便于复用mysql连接，无需反复开启mysql连接；麻烦老师解惑一下","like_count":8},{"had_liked":false,"id":105229,"user_name":"石头Rocky","can_delete":false,"product_type":"c1","uid":1250433,"ip_address":"","ucode":"70A3ED4EE0420C","user_header":"https://static001.geekbang.org/account/avatar/00/13/14/81/11cadd29.jpg","comment_is_top":false,"comment_ctime":1560942328,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23035778808","product_id":100028301,"comment_content":"setmetatable({ sock = sock }, mt) 构造函数返回的table是{ sock = sock }这个表。 <br>当调用方使用 set_timeout方法时，在表内找不到set_timeout方法，便会去__index所指的_M中去寻找。","like_count":6},{"had_liked":false,"id":104964,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1560899557,"is_pvip":true,"replies":[{"id":"38156","content":"因为 LuaJIT 是基于 Lua 5.1的语法来实现的，并没有跟随Lua 5.2 和 5.3 ","user_name":"作者回复","comment_id":104964,"uid":"1017955","ip_address":"","utype":1,"ctime":1560998688,"user_name_real":"温铭@OpenResty"}],"discussion_count":1,"race_medal":0,"score":"18740768741","product_id":100028301,"comment_content":"直接 lua 运行 table.getn 会报这样的错的 lua: table.lua:7: attempt to call a nil value (field &#39;getn&#39;)<br><br>我查了一下， lua5.1 之后把这方法去掉了，那么为什么 luajit 和 openresty 不把这个方法废弃呢？还保留呢？ ","like_count":4,"discussions":[{"author":{"id":1017955,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/88/63/88cf886d.jpg","nickname":"温铭@APISIX","note":"","ucode":"343567571DA16A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454508,"discussion_content":"因为 LuaJIT 是基于 Lua 5.1的语法来实现的，并没有跟随Lua 5.2 和 5.3 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560998688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":106122,"user_name":"小飞哥 ‍超級會員","can_delete":false,"product_type":"c1","uid":1110049,"ip_address":"","ucode":"417F9563B3005B","user_header":"https://static001.geekbang.org/account/avatar/00/10/f0/21/104b9565.jpg","comment_is_top":false,"comment_ctime":1561181926,"is_pvip":false,"replies":[{"id":"38906","content":"字典的顺序是不保证的，大部分语言都是如何","user_name":"作者回复","comment_id":106122,"uid":"1017955","ip_address":"","utype":1,"ctime":1561551288,"user_name_real":"温铭@OpenResty"}],"discussion_count":1,"race_medal":0,"score":"10151116518","product_id":100028301,"comment_content":"localhost: ~&#47;geektime&#47;lua $ resty -e &#39;local color = {first = &quot;red&quot;, &quot;blue&quot;, third = &quot;green&quot;, &quot;yellow&quot;}<br>&gt;   color.first = nil<br>&gt;   for k, v in pairs(color) do<br>&gt;       print(v)<br>&gt;   end&#39;<br>blue<br>yellow<br>green<br>localhost: ~&#47;geektime&#47;lua $ resty -e &#39;local color = {first = &quot;red&quot;, &quot;blue&quot;, third = &quot;green&quot;, &quot;yellow&quot;}<br>&gt;   table.remove(color, 1)<br>&gt;   for k, v in pairs(color) do<br>&gt;       print(v)<br>&gt;   end&#39;<br>yellow<br>green<br>red<br><br>看结果为什么打印一个是正序，一个是倒序呢？ ","like_count":2,"discussions":[{"author":{"id":1017955,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/88/63/88cf886d.jpg","nickname":"温铭@APISIX","note":"","ucode":"343567571DA16A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454963,"discussion_content":"字典的顺序是不保证的，大部分语言都是如何","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561551288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105186,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1560934733,"is_pvip":false,"replies":[{"id":"38154","content":"：）感谢 fix typo","user_name":"作者回复","comment_id":105186,"uid":"1017955","ip_address":"","utype":1,"ctime":1560998500,"user_name_real":"温铭@OpenResty"}],"discussion_count":1,"race_medal":0,"score":"5855902029","product_id":100028301,"comment_content":"函数不可貌相，海水不可（斗量）<br>:)","like_count":1,"discussions":[{"author":{"id":1017955,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/88/63/88cf886d.jpg","nickname":"温铭@APISIX","note":"","ucode":"343567571DA16A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454587,"discussion_content":"：）感谢 fix typo","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560998500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105184,"user_name":"helloworld","can_delete":false,"product_type":"c1","uid":1105161,"ip_address":"","ucode":"1EECCA0F43E278","user_header":"https://static001.geekbang.org/account/avatar/00/10/dd/09/feca820a.jpg","comment_is_top":false,"comment_ctime":1560934611,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5855901907","product_id":100028301,"comment_content":"一个是代码复用和代码缓存原因，性能可以提高；<br>另外一个是可读性高，便于维护","like_count":1},{"had_liked":false,"id":104976,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1560901911,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5855869207","product_id":100028301,"comment_content":"对于lua-resty-mysql 模拟 OO原因，理解为 mysql 的连接是需要保持的，需要复用的，当一个连接建立之后是需要复用的，不能频繁的断开连接，建立连接","like_count":1},{"had_liked":false,"id":104969,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1560900831,"is_pvip":true,"replies":[{"id":"38155","content":"需要 LuaJIT 2.1 的版本才行, 文档在这里：https:&#47;&#47;github.com&#47;LuaJIT&#47;LuaJIT&#47;blob&#47;v2.1&#47;doc&#47;extensions.html#L218","user_name":"作者回复","comment_id":104969,"uid":"1017955","ip_address":"","utype":1,"ctime":1560998642,"user_name_real":"温铭@OpenResty"}],"discussion_count":2,"race_medal":0,"score":"5855868127","product_id":100028301,"comment_content":"在luajit 扩展的table 函数中<br>local new_tab = require(&#39;table.new&#39;)<br>或者 require(&#39;table.clear&#39;)<br><br>用 luajit 去执行 都会报错找不动 moudule的错误的<br>luajit: table_luajit.lua:1: module &#39;table.new&#39; not found:<br>luajit 的版本 2.0.5","like_count":1,"discussions":[{"author":{"id":1017955,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/88/63/88cf886d.jpg","nickname":"温铭@APISIX","note":"","ucode":"343567571DA16A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454510,"discussion_content":"需要 LuaJIT 2.1 的版本才行, 文档在这里：https://github.com/LuaJIT/LuaJIT/blob/v2.1/doc/extensions.html#L218","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1560998642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110049,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f0/21/104b9565.jpg","nickname":"小飞哥 ‍超級會員","note":"","ucode":"417F9563B3005B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":160,"discussion_content":"我的luajit 版本是2.0.5 \n他的错误是因为 table.new  不是使用单 引号来引用， 请看下我执行的\nlocalhost: ~/geektime/lua $ luajit -v\nLuaJIT 2.0.5 -- Copyright (C) 2005-2017 Mike Pall. http://luajit.org/\nlocalhost: ~/geektime/lua $ resty -e &#39; local ntab = require(&#39;table.new&#39;)&#39;\nERROR: (command line -e):1: bad argument #1 to &#39;require&#39; (string expected, got function)\nstack traceback:\n\t(command line -e):1: in function &#39;inline_gen&#39;\n\tinit_worker_by_lua:45: in function <init_worker_by_lua:44>\n\t[C]: in function &#39;xpcall&#39;\n\tinit_worker_by_lua:53: in function <init_worker_by_lua:51>\nlocalhost: ~/geektime/lua $ resty -e &#39; local ntab = require(&#34;table.new&#34;)&#39;\nlocalhost: ~/geektime/lua $","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561205155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340004,"user_name":"无关风月","can_delete":false,"product_type":"c1","uid":1950389,"ip_address":"","ucode":"F5979EB048F7FE","user_header":"","comment_is_top":false,"comment_ctime":1648535922,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648535922","product_id":100028301,"comment_content":"t.patch 其实获取不到值，那么就会走到 __index 这个函数中，结果就会打印出 1.1.2  怎么打印出2的，不是不存在patch的吗","like_count":0},{"had_liked":false,"id":149519,"user_name":"卡卡","can_delete":false,"product_type":"c1","uid":1064855,"ip_address":"","ucode":"E696CC0386FA27","user_header":"https://static001.geekbang.org/account/avatar/00/10/3f/97/8d7a6460.jpg","comment_is_top":false,"comment_ctime":1573263964,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573263964","product_id":100028301,"comment_content":"前几节课不是说op的下标是从1开始吗？怎么这节课的例子又从0开始了？","like_count":0},{"had_liked":false,"id":138978,"user_name":"michael","can_delete":false,"product_type":"c1","uid":1669070,"ip_address":"","ucode":"35938429E3D0E9","user_header":"https://static001.geekbang.org/account/avatar/00/19/77/ce/f7ccd5ac.jpg","comment_is_top":false,"comment_ctime":1570521882,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1570521882","product_id":100028301,"comment_content":"请教一个问题，在大多数编写面向对象的情况下 采用如下方式<br>local instance ={}<br>self.__index = self<br>setmetatable(instance, self)<br>但是当我想实现一个类似于php的__get魔术方法时如下调用就出现了问题<br>local instance ={data={&quot;apple&quot; =1}}<br>self.__index = function(t,k) <br>if instance.data[k] ~= nil &#47;&#47;如果在data中存在则返回相应value<br> return instance.data[k] &#47;&#47;类似get魔术方法<br>end<br>return self &#47;&#47;这一步出现大问题，后面实例化无法调用类方法<br>setmetatable(instance, self)<br><br>想知道问题的原因和解决方案，非常感谢，还有想加一个咱们Lua的交流群，希望能一起学习。","like_count":0},{"had_liked":false,"id":122270,"user_name":"fjpcode","can_delete":false,"product_type":"c1","uid":1306092,"ip_address":"","ucode":"C32C5E3ECB9A90","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ61zTDmLk7IhLJn6seBPOwsVaKIWUWaxk5YmsdYBZUOYMQCsyl9iaQVSg9U5qJVLLOCFUoLUuYnRA/132","comment_is_top":false,"comment_ctime":1565327729,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1565327729","product_id":100028301,"comment_content":"lua-resty-mysql模拟oo封装一层，我的理解是：1. 屏蔽底层通信细节，统一使用or特色的cosocket实现非阻塞高效IO 2. 接口简单易用，让开发人员把精力聚焦在业务逻辑上，而不是这些底层的通信细节上。这也是OR秉承的里面。 ","like_count":0},{"had_liked":false,"id":112746,"user_name":"英雄","can_delete":false,"product_type":"c1","uid":1546612,"ip_address":"","ucode":"D1033C83C6CDE9","user_header":"https://static001.geekbang.org/account/avatar/00/17/99/74/0203bf17.jpg","comment_is_top":false,"comment_ctime":1562814269,"is_pvip":false,"replies":[{"id":"41176","content":"按照你的定义就是重写。Lua 没有类的概念，是模拟出来的，所以做不到重载这么高级。","user_name":"作者回复","comment_id":112746,"uid":"1017955","ip_address":"","utype":1,"ctime":1562904615,"user_name_real":"温铭@OpenResty"}],"discussion_count":1,"race_medal":0,"score":"1562814269","product_id":100028301,"comment_content":"是重载还是重写？java里面的重载是：指同一个类中的多个方法具有相同的名字,但这些方法具有不同的参数列表,即参数的数量或参数类型不能完全相同<br><br>方法重写是：存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字,相同的参数表和相同的返回类型 ","like_count":0,"discussions":[{"author":{"id":1017955,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/88/63/88cf886d.jpg","nickname":"温铭@APISIX","note":"","ucode":"343567571DA16A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457891,"discussion_content":"按照你的定义就是重写。Lua 没有类的概念，是模拟出来的，所以做不到重载这么高级。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562904615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":107344,"user_name":"HelloBug","can_delete":false,"product_type":"c1","uid":1249598,"ip_address":"","ucode":"E61A4AD5C2F724","user_header":"https://static001.geekbang.org/account/avatar/00/13/11/3e/925aa996.jpg","comment_is_top":false,"comment_ctime":1561516674,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1561516674","product_id":100028301,"comment_content":"温铭老师好， 如果table中有nil元素，这个元素是不是不占用内存空间？","like_count":0},{"had_liked":false,"id":105889,"user_name":"ArtEngr","can_delete":false,"product_type":"c1","uid":1544340,"ip_address":"","ucode":"719CA9C19DA9C7","user_header":"https://static001.geekbang.org/account/avatar/00/17/90/94/3949d451.jpg","comment_is_top":false,"comment_ctime":1561100206,"is_pvip":false,"replies":[{"id":"38902","content":"可以设置大一些，留一些缓存","user_name":"作者回复","comment_id":105889,"uid":"1017955","ip_address":"","utype":1,"ctime":1561551080,"user_name_real":"温铭@OpenResty"}],"discussion_count":1,"race_medal":0,"score":"1561100206","product_id":100028301,"comment_content":"“另外，超出预设的空间大小，也可以正常使用，只不过性能会退化” 很多时候与外界交互数据，无法准确知道table大小。","like_count":0,"discussions":[{"author":{"id":1017955,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/88/63/88cf886d.jpg","nickname":"温铭@APISIX","note":"","ucode":"343567571DA16A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454853,"discussion_content":"可以设置大一些，留一些缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561551080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":105549,"user_name":"John","can_delete":false,"product_type":"c1","uid":1458885,"ip_address":"","ucode":"ECACBE31D5D1A7","user_header":"https://static001.geekbang.org/account/avatar/00/16/42/c5/7913cdb0.jpg","comment_is_top":false,"comment_ctime":1561027098,"is_pvip":false,"replies":[{"id":"38900","content":"不推荐用 Lua 的 table 来模拟实现继承等这种复杂的功能，就像你说的一样，可读性太差，一般人的脑子都转不过来。。。","user_name":"作者回复","comment_id":105549,"uid":"1017955","ip_address":"","utype":1,"ctime":1561550892,"user_name_real":"温铭@OpenResty"}],"discussion_count":3,"race_medal":0,"score":"1561027098","product_id":100028301,"comment_content":"老师，能否专门讲解一下lua面向对象是如何实现继承，抽象类的，我看了orange的源码发现不太容易理解，源码如下：<br>-- local BasePlugin = Object:extend()<br>function Object:extend()<br>  local cls = {}<br>  for k, v in pairs(self) do<br>    if k:find(&quot;__&quot;) == 1 then<br>      cls[k] = v<br>    end<br>  end<br>  cls.__index = cls<br>  cls.super = self<br>  setmetatable(cls, self)<br>  return cls<br>end<br><br><br>function Object:implement(...)<br>  for _, cls in pairs({...}) do<br>    for k, v in pairs(cls) do<br>      if self[k] == nil and type(v) == &quot;function&quot; then<br>        self[k] = v<br>      end<br>    end<br>  end<br>end<br>","like_count":0,"discussions":[{"author":{"id":1017955,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/88/63/88cf886d.jpg","nickname":"温铭@APISIX","note":"","ucode":"343567571DA16A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":454722,"discussion_content":"不推荐用 Lua 的 table 来模拟实现继承等这种复杂的功能，就像你说的一样，可读性太差，一般人的脑子都转不过来。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561550892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1446375,"avatar":"https://static001.geekbang.org/account/avatar/00/16/11/e7/044a9a6c.jpg","nickname":"book尾汁","note":"","ucode":"AE2B8DFC643ACC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2081,"discussion_content":"问下这句 cls.__index = cls是什么意思，把cls这个表里的index属性设置为自己？这样做有什么用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563248913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318287,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1d/8f/4cdf87c7.jpg","nickname":"攻城狮","note":"","ucode":"DA106850494415","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1506,"discussion_content":"这个东西当时我也研究了好久，现在看又都忘了，记得kong也有这段代码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562667998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}