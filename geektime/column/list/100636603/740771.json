{"id":740771,"title":"第 8 章 挂载与更新(2)","content":"<h2 id=\"nav_point_82\">8.7　事件的处理</h2>\n<p>本节我们将讨论如何处理事件，包括如何在虚拟节点中描述事件，如何把事件添加到 DOM 元素上，以及如何更新事件。</p>\n<p>我们先来解决第一个问题，即如何在虚拟节点中描述事件。事件可以视作一种特殊的属性，因此我们可以约定，在 <code>vnode.props</code> 对象中，凡是以字符串 <code>on</code> 开头的属性都视作事件。例如：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'p',\n   props: {\n     // 使用 onXxx 描述事件\n     onClick: () =&gt; {\n       alert('clicked')\n     }\n   },\n   children: 'text'\n }\n</code></pre>\n<p>解决了事件在虚拟节点层面的描述问题后，我们再来看看如何将事件添加到 DOM 元素上。这非常简单，只需要在 <code>patchProps</code> 中调用 <code>addEventListener</code> 函数来绑定事件即可，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> patchProps(el, key, prevValue, nextValue) {\n   // 匹配以 on 开头的属性，视其为事件\n   if (/^on/.test(key)) {\n     // 根据属性名称得到对应的事件名称，例如 onClick ---&gt; click\n     const name = key.slice(2).toLowerCase()\n     // 绑定事件，nextValue 为事件处理函数\n     el.addEventListener(name, nextValue)\n   } else if (key === 'class') {\n     // 省略部分代码\n   } else if (shouldSetAsProps(el, key, nextValue)) {\n     // 省略部分代码\n   } else {\n     // 省略部分代码\n   }\n }\n</code></pre>\n<p>那么，更新事件要如何处理呢？按照一般的思路，我们需要先移除之前添加的事件处理函数，然后再将新的事件处理函数绑定到 DOM 元素上，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> patchProps(el, key, prevValue, nextValue) {\n   if (/^on/.test(key)) {\n     const name = key.slice(2).toLowerCase()\n     // 移除上一次绑定的事件处理函数\n     prevValue &amp;&amp; el.removeEventListener(name, prevValue)\n     // 绑定新的事件处理函数\n     el.addEventListener(name, nextValue)\n   } else if (key === 'class') {\n     // 省略部分代码\n   } else if (shouldSetAsProps(el, key, nextValue)) {\n     // 省略部分代码\n   } else {\n     // 省略部分代码\n   }\n }\n</code></pre>\n<p>这么做代码能够按照预期工作，但其实还有一种性能更优的方式来完成事件更新。在绑定事件时，我们可以绑定一个伪造的事件处理函数 <code>invoker</code>，然后把真正的事件处理函数设置为 <code>invoker.value</code> 属性的值。这样当更新事件的时候，我们将不再需要调用 <code>removeEventListener</code> 函数来移除上一次绑定的事件，只需要更新 <code>invoker.value</code> 的值即可，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> patchProps(el, key, prevValue, nextValue) {\n   if (/^on/.test(key)) {\n     // 获取为该元素伪造的事件处理函数 invoker\n     let invoker = el._vei\n     const name = key.slice(2).toLowerCase()\n     if (nextValue) {\n       if (!invoker) {\n         // 如果没有 invoker，则将一个伪造的 invoker 缓存到 el._vei 中\n         // vei 是 vue event invoker 的首字母缩写\n         invoker = el._vei = (e) =&gt; {\n           // 当伪造的事件处理函数执行时，会执行真正的事件处理函数\n           invoker.value(e)\n         }\n         // 将真正的事件处理函数赋值给 invoker.value\n         invoker.value = nextValue\n         // 绑定 invoker 作为事件处理函数\n         el.addEventListener(name, invoker)\n       } else {\n         // 如果 invoker 存在，意味着更新，并且只需要更新 invoker.value 的值即可\n         invoker.value = nextValue\n       }\n     } else if (invoker) {\n       // 新的事件绑定函数不存在，且之前绑定的 invoker 存在，则移除绑定\n       el.removeEventListener(name, invoker)\n     }\n   } else if (key === 'class') {\n     // 省略部分代码\n   } else if (shouldSetAsProps(el, key, nextValue)) {\n     // 省略部分代码\n   } else {\n     // 省略部分代码\n   }\n }\n</code></pre>\n<p>观察上面的代码，事件绑定主要分为两个步骤。</p>\n<ul>\n<li>先从 <code>el._vei</code> 中读取对应的 <code>invoker</code>，如果 <code>invoker</code> 不存在，则将伪造的 <code>invoker</code> 作为事件处理函数，并将它缓存到 <code>el._vei</code> 属性中。</li>\n<li>把真正的事件处理函数赋值给 <code>invoker.value</code> 属性，然后把伪造的 <code>invoker</code> 函数作为事件处理函数绑定到元素上。可以看到，当事件触发时，实际上执行的是伪造的事件处理函数，在其内部间接执行了真正的事件处理函数 <code>invoker.value(e)</code>。</li>\n</ul>\n<p>当更新事件时，由于 <code>el._vei</code> 已经存在了，所以我们只需要将 <code>invoker.value</code> 的值修改为新的事件处理函数即可。这样，在更新事件时可以避免一次 <code>removeEventListener</code> 函数的调用，从而提升了性能。实际上，伪造的事件处理函数的作用不止于此，它还能解决事件冒泡与事件更新之间相互影响的问题，下文会详细讲解。</p><!-- [[[read_end]]] -->\n<p>但目前的实现仍然存在问题。现在我们将事件处理函数缓存在 <code>el._vei</code> 属性中，问题是，在同一时刻只能缓存一个事件处理函数。这意味着，如果一个元素同时绑定了多种事件，将会出现事件覆盖的现象。例如同时给元素绑定 <code>click</code> 和 <code>contextmenu</code> 事件：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'p',\n   props: {\n     onClick: () =&gt; {\n       alert('clicked')\n     },\n     onContextmenu: () =&gt; {\n       alert('contextmenu')\n     }\n   },\n   children: 'text'\n }\n renderer.render(vnode, document.querySelector('#app'))\n</code></pre>\n<p>当渲染器尝试渲染这上面代码中给出的 <code>vnode</code> 时，会先绑定 <code>click</code> 事件，然后再绑定 <code>contextmenu</code> 事件。后绑定的 <code>contextmenu</code> 事件的处理函数将覆盖先绑定的 <code>click</code> 事件的处理函数。为了解决事件覆盖的问题，我们需要重新设计 <code>el._vei</code> 的数据结构。我们应该将 <code>el._vei</code> 设计为一个对象，它的键是事件名称，它的值则是对应的事件处理函数，这样就不会发生事件覆盖的现象了，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> patchProps(el, key, prevValue, nextValue) {\n   if (/^on/.test(key)) {\n     // 定义 el._vei 为一个对象，存在事件名称到事件处理函数的映射\n     const invokers = el._vei || (el._vei = {})\n     //根据事件名称获取 invoker\n     let invoker = invokers[key]\n     const name = key.slice(2).toLowerCase()\n     if (nextValue) {\n       if (!invoker) {\n         // 将事件处理函数缓存到 el._vei[key] 下，避免覆盖\n         invoker = el._vei[key] = (e) =&gt; {\n           invoker.value(e)\n         }\n         invoker.value = nextValue\n         el.addEventListener(name, invoker)\n       } else {\n         invoker.value = nextValue\n       }\n     } else if (invoker) {\n       el.removeEventListener(name, invoker)\n     }\n   } else if (key === 'class') {\n     // 省略部分代码\n   } else if (shouldSetAsProps(el, key, nextValue)) {\n     // 省略部分代码\n   } else {\n     // 省略部分代码\n   }\n }\n</code></pre>\n<p>另外，一个元素不仅可以绑定多种类型的事件，对于同一类型的事件而言，还可以绑定多个事件处理函数。我们知道，在原生 DOM 编程中，当多次调用 <code>addEventListener</code> 函数为元素绑定同一类型的事件时，多个事件处理函数可以共存，例如：</p>\n<pre class=\"code-rows\"><code> el.addEventListener('click', fn1)\n el.addEventListener('click', fn2)\n</code></pre>\n<p>当点击元素时，事件处理函数 <code>fn1</code> 和 <code>fn2</code> 都会执行。因此，为了描述同一个事件的多个事件处理函数，我们需要调整 <code>vnode.props</code> 对象中事件的数据结构，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'p',\n   props: {\n     onClick: [\n       // 第一个事件处理函数\n       () =&gt; {\n         alert('clicked 1')\n       },\n       // 第二个事件处理函数\n       () =&gt; {\n         alert('clicked 2')\n       }\n     ]\n   },\n   children: 'text'\n }\n renderer.render(vnode, document.querySelector('#app'))\n</code></pre>\n<p>在上面这段代码中，我们使用一个数组来描述事件，数组中的每个元素都是一个独立的事件处理函数，并且这些事件处理函数都能够正确地绑定到对应元素上。为了实现此功能，我们需要修改 <code>patchProps</code> 函数中事件处理相关的代码，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> patchProps(el, key, prevValue, nextValue) {\n   if (/^on/.test(key)) {\n     const invokers = el._vei || (el._vei = {})\n     let invoker = invokers[key]\n     const name = key.slice(2).toLowerCase()\n     if (nextValue) {\n       if (!invoker) {\n         invoker = el._vei[key] = (e) =&gt; {\n           // 如果 invoker.value 是数组，则遍历它并逐个调用事件处理函数\n           if (Array.isArray(invoker.value)) {\n             invoker.value.forEach(fn =&gt; fn(e))\n           } else {\n             // 否则直接作为函数调用\n             invoker.value(e)\n           }\n         }\n         invoker.value = nextValue\n         el.addEventListener(name, invoker)\n       } else {\n         invoker.value = nextValue\n       }\n     } else if (invoker) {\n       el.removeEventListener(name, invoker)\n     }\n   } else if (key === 'class') {\n     // 省略部分代码\n   } else if (shouldSetAsProps(el, key, nextValue)) {\n     // 省略部分代码\n   } else {\n     // 省略部分代码\n   }\n }\n</code></pre>\n<p>在这段代码中，我们修改了 <code>invoker</code> 函数的实现。当 <code>invoker</code> 函数执行时，在调用真正的事件处理函数之前，要先检查 <code>invoker.value</code> 的数据结构是否是数组，如果是数组则遍历它，并逐个调用定义在数组中的事件处理函数。</p>\n<h2 id=\"nav_point_83\">8.8　事件冒泡与更新时机问题</h2>\n<p>在上一节中，我们介绍了基本的事件处理。本节我们将讨论事件冒泡与更新时机相结合所导致的问题。为了更清晰地描述问题，我们需要构造一个小例子：</p>\n<pre class=\"code-rows\"><code> const { effect, ref } = VueReactivity\n<p>const bol = ref(false)</p>\n<p>effect(() =&gt; {<br />\n// 创建 vnode<br />\nconst vnode = {<br />\ntype: ‘div’,<br />\nprops: bol.value ? {<br />\nonClick: () =&gt; {<br />\nalert(‘父元素 clicked’)<br />\n}<br />\n} : {},<br />\nchildren: [<br />\n{<br />\ntype: ‘p’,<br />\nprops: {<br />\nonClick: () =&gt; {<br />\nbol.value = true<br />\n}<br />\n},<br />\nchildren: ‘text’<br />\n}<br />\n]<br />\n}<br />\n// 渲染 vnode<br />\nrenderer.render(vnode, document.querySelector(‘#app’))<br />\n})<br />\n</code></pre></p>\n<p>这个例子比较复杂。在上面这段代码中，我们创建一个响应式数据 <code>bol</code>，它是一个 <code>ref</code>，初始值为 <code>false</code>。接着，创建了一个 <code>effect</code>，并在副作用函数内调用 <code>renderer.render</code> 函数来渲染 <code>vnode</code>。这里的重点在于该 <code>vnode</code> 对象，它描述了一个 <code>div</code> 元素，并且该 <code>div</code> 元素具有一个 <code>p</code> 元素作为子节点。我们再来详细看看 <code>div</code> 元素以及 <code>p</code> 元素的特点。</p>\n<ul>\n<li><p><code>div</code> 元素</p>\n<p>它的 <code>props</code> 对象的值是由一个三元表达式决定的。在首次渲染时，由于 <code>bol.value</code> 的值为 <code>false</code>，所以它的 <code>props</code> 的值是一个空对象。</p>\n<p>&nbsp;</p>\n</li>\n<li><p><code>p</code> 元素</p>\n<p>它具有 <code>click</code> 点击事件，并且当点击它时，事件处理函数会将 <code>bol.value</code> 的值设置为 <code>true</code>。</p>\n</li>\n</ul>\n<p>结合上述特点，我们来思考一个问题：当首次渲染完成后，用鼠标点击 <code>p</code> 元素，会触发父级 <code>div</code> 元素的 <code>click</code> 事件的事件处理函数执行吗？</p>\n<p>答案其实很明显，在首次渲染完成之后，由于 <code>bol.value</code> 的值为 <code>false</code>，所以渲染器并不会为 <code>div</code> 元素绑定点击事件。当用鼠标点击 <code>p</code> 元素时，即使 <code>click</code> 事件可以从 <code>p</code> 元素冒泡到父级 <code>div</code> 元素，但由于 <code>div</code> 元素没有绑定 <code>click</code> 事件的事件处理函数，所以什么都不会发生。但事实是，当你尝试运行上面这段代码并点击 <code>p</code> 元素时，会发现父级 <code>div</code> 元素的 <code>click</code> 事件的事件处理函数竟然执行了。为什么会发生如此奇怪的现象呢？这其实与更新机制有关，我们来分析一下当点击 <code>p</code> 元素时，到底发生了什么。</p>\n<p>当点击 <code>p</code> 元素时，绑定到它身上的 <code>click</code> 事件处理函数会执行，于是 <code>bol.value</code> 的值被改为 <code>true</code>。接下来的一步非常关键，由于 <code>bol</code> 是一个响应式数据，所以当它的值发生变化时，会触发副作用函数重新执行。由于此时的 <code>bol.value</code> 已经变成了 <code>true</code>，所以在更新阶段，渲染器会为父级 <code>div</code> 元素绑定 <code>click</code> 事件处理函数。当更新完成之后，点击事件才从 <code>p</code> 元素冒泡到父级 <code>div</code> 元素。由于此时 <code>div</code> 元素已经绑定了 <code>click</code> 事件的处理函数，因此就发生了上述奇怪的现象。图 8-3 给出了当点击 <code>p</code> 元素后，整个更新和事件触发的流程图。</p>\n<p>根据图 8-3 我们能够发现，之所以会出现上述奇怪的现象，是因为更新操作发生在事件冒泡之前，即<strong>为 <code>div</code> 元素绑定事件处理函数发生在事件冒泡之前</strong>。那如何避免这个问题呢？一个很自然的想法是，能否将绑定事件的动作挪到事件冒泡之后？但这个想法不可靠，因为我们无法知道事件冒泡是否完成，以及完成到什么程度。你可能会想，Vue.js 的更新难道不是在一个异步的微任务队列中进行的吗？那是不是自然能够避免这个问题了呢？其实不然，换句话说，微任务会穿插在由事件冒泡触发的多个事件处理函数之间被执行。因此，即使把绑定事件的动作放到微任务中，也无法避免这个问题。</p>\n<p>那应该如何解决呢？其实，仔细观察图 8-3 就会发现，触发事件的时间与绑定事件的时间之间是有联系的，如图 8-4 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00525.jpeg\" alt=\"\" width=\"45%\" style=\"width: 45%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8-3　更新和事件触发的流程</strong></p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00526.jpeg\" alt=\"\" width=\"60%\" style=\"width: 60%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8-4　触发事件的时间与绑定事件的时间之间的联系</strong></p>\n<p>由图 8-4 可以发现，事件触发的时间要早于事件处理函数被绑定的时间。这意味着当一个事件触发时，目标元素上还没有绑定相关的事件处理函数，我们可以根据这个特点来解决问题：<strong>屏蔽所有绑定时间晚于事件触发时间的事件处理函数的执行</strong>。基于此，我们可以调整 <code>patchProps</code> 函数中关于事件的代码，如下：</p>\n<pre class=\"code-rows\"><code> patchProps(el, key, prevValue, nextValue) {\n   if (/^on/.test(key)) {\n     const invokers = el._vei || (el._vei = {})\n     let invoker = invokers[key]\n     const name = key.slice(2).toLowerCase()\n     if (nextValue) {\n       if (!invoker) {\n         invoker = el._vei[key] = (e) =&gt; {\n           // e.timeStamp 是事件发生的时间\n           // 如果事件发生的时间早于事件处理函数绑定的时间，则不执行事件处理函数\n           if (e.timeStamp &lt; invoker.attached) return\n           if (Array.isArray(invoker.value)) {\n             invoker.value.forEach(fn =&gt; fn(e))\n           } else {\n             invoker.value(e)\n           }\n         }\n         invoker.value = nextValue\n         // 添加 invoker.attached 属性，存储事件处理函数被绑定的时间\n         invoker.attached = performance.now()\n         el.addEventListener(name, invoker)\n       } else {\n         invoker.value = nextValue\n       }\n     } else if (invoker) {\n       el.removeEventListener(name, invoker)\n     }\n   } else if (key === 'class') {\n     // 省略部分代码\n   } else if (shouldSetAsProps(el, key, nextValue)) {\n     // 省略部分代码\n   } else {\n     // 省略部分代码\n   }\n }\n</code></pre>\n<p>如上面的代码所示，我们在原来的基础上只添加了两行代码。首先，我们为伪造的事件处理函数添加了 <code>invoker.attached</code> 属性，用来存储事件处理函数被绑定的时间。然后，在 <code>invoker</code> 执行的时候，通过事件对象的 <code>e.timeStamp</code> 获取事件发生的时间。最后，比较两者，如果事件处理函数被绑定的时间晚于事件发生的时间，则不执行该事件处理函数。</p>\n<p>这里有必要指出的是，在关于时间的存储和比较方面，我们使用的是高精时间，即 <code>performance.now</code>。但根据浏览器的不同，<code>e.timeStamp</code> 的值也会有所不同。它既可能是高精时间，也可能是非高精时间。因此，严格来讲，这里需要做兼容处理。不过在 Chrome 49、Firefox 54、Opera 36 以及之后的版本中，<code>e.timeStamp</code> 的值都是高精时间。</p>\n<h2 id=\"nav_point_84\">8.9　更新子节点</h2>\n<p>前几节我们讲解了元素属性的更新，包括普通标签属性和事件。接下来，我们将讨论如何更新元素的子节点。首先，回顾一下元素的子节点是如何被挂载的，如下面 <code>mountElement</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function mountElement(vnode, container) {\n   const el = vnode.el = createElement(vnode.type)\n<p>// 挂载子节点，首先判断 children 的类型<br />\n// 如果是字符串类型，说明是文本子节点<br />\nif (typeof vnode.children === ‘string’) {<br />\nsetElementText(el, vnode.children)<br />\n} else if (Array.isArray(vnode.children)) {<br />\n// 如果是数组，说明是多个子节点<br />\nvnode.children.forEach(child =&gt; {<br />\npatch(null, child, el)<br />\n})<br />\n}</p>\n<p>if (vnode.props) {<br />\nfor (const key in vnode.props) {<br />\npatchProps(el, key, null, vnode.props[key])<br />\n}<br />\n}</p>\n<p>insert(el, container)<br />\n}<br />\n</code></pre></p>\n<p>在挂载子节点时，首先要区分其类型：</p>\n<ul>\n<li>如果 <code>vnode.children</code> 是字符串，则说明元素具有文本子节点；</li>\n<li>如果 <code>vnode.children</code> 是数组，则说明元素具有多个子节点。</li>\n</ul>\n<p>这里需要思考的是，为什么要区分子节点的类型呢？其实这是一个规范性的问题，因为只有子节点的类型是规范化的，才有利于我们编写更新逻辑。因此，在具体讨论如何更新子节点之前，我们有必要先规范化 <code>vnode.children</code>。那应该设定怎样的规范呢？为了搞清楚这个问题，我们需要先搞清楚在一个 HTML 页面中，元素的子节点都有哪些情况，如下面的 HTML 代码所示：</p>\n<pre class=\"code-rows\"><code> &lt;!-- 没有子节点 --&gt;\n &lt;div&gt;&lt;/div&gt;\n &lt;!-- 文本子节点 --&gt;\n &lt;div&gt;Some Text&lt;/div&gt;\n &lt;!-- 多个子节点 --&gt;\n &lt;div&gt;\n   &lt;p/&gt;\n   &lt;p/&gt;\n &lt;/div&gt;\n</code></pre>\n<p>对于一个元素来说，它的子节点无非有以下三种情况。</p>\n<ul>\n<li>没有子节点，此时 <code>vnode.children</code> 的值为 <code>null</code>。</li>\n<li>具有文本子节点，此时 <code>vnode.children</code> 的值为字符串，代表文本的内容。</li>\n<li>其他情况，无论是单个元素子节点，还是多个子节点（可能是文本和元素的混合），都可以用数组来表示。</li>\n</ul>\n<p>如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 没有子节点\n vnode = {\n   type: 'div',\n   children: null\n }\n // 文本子节点\n vnode = {\n   type: 'div',\n   children: 'Some Text'\n }\n // 其他情况，子节点使用数组表示\n vnode = {\n   type: 'div',\n   children: [\n     { type: 'p' },\n     'Some Text'\n   ]\n }\n</code></pre>\n<p>现在，我们已经规范化了 <code>vnode.children</code> 的类型。既然一个 <code>vnode</code> 的子节点可能有三种情况，那么当渲染器执行更新时，新旧子节点都分别是三种情况之一。所以，我们可以总结出更新子节点时全部九种可能，如图 8-5 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00527.jpeg\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p class=\"ebook-image-title\"><strong>图 8-5　新旧子节点的关系</strong></p>\n<p>但落实到代码，我们会发现其实并不需要完全覆盖这九种可能。接下来我们就开始着手实现，如下面 <code>patchElement</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function patchElement(n1, n2) {\n   const el = n2.el = n1.el\n   const oldProps = n1.props\n   const newProps = n2.props\n   // 第一步：更新 props\n   for (const key in newProps) {\n     if (newProps[key] !== oldProps[key]) {\n       patchProps(el, key, oldProps[key], newProps[key])\n     }\n   }\n   for (const key in oldProps) {\n     if (!(key in newProps)) {\n       patchProps(el, key, oldProps[key], null)\n     }\n   }\n<p>// 第二步：更新 children<br />\npatchChildren(n1, n2, el)<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，更新子节点是对一个元素进行打补丁的最后一步操作。我们将它封装到 <code>patchChildren</code> 函数中，并将新旧 <code>vnode</code> 以及当前正在被打补丁的 DOM 元素 <code>el</code> 作为参数传递给它。</p>\n<p><code>patchChildren</code> 函数的实现如下：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   // 判断新子节点的类型是否是文本节点\n   if (typeof n2.children === 'string') {\n     // 旧子节点的类型有三种可能：没有子节点、文本子节点以及一组子节点\n     // 只有当旧子节点为一组子节点时，才需要逐个卸载，其他情况下什么都不需要做\n     if (Array.isArray(n1.children)) {\n       n1.children.forEach((c) =&gt; unmount(c))\n     }\n     // 最后将新的文本节点内容设置给容器元素\n     setElementText(container, n2.children)\n   }\n }\n</code></pre>\n<p>如上面这段代码所示，首先，我们检测新子节点的类型是否是文本节点，如果是，则还要检查旧子节点的类型。旧子节点的类型可能有三种情况，分别是：没有子节点、文本子节点或一组子节点。如果没有旧子节点或者旧子节点的类型是文本子节点，那么只需要将新的文本内容设置给容器元素即可；如果旧子节点存在，并且不是文本子节点，则说明它的类型是一组子节点。这时我们需要循环遍历它们，并逐个调用 <code>unmount</code> 函数进行卸载。</p>\n<p>如果新子节点的类型不是文本子节点，我们需要再添加一个判断分支，判断它是否是一组子节点，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   if (typeof n2.children === 'string') {\n     // 省略部分代码\n   } else if (Array.isArray(n2.children)) {\n     // 说明新子节点是一组子节点\n<pre><code> // 判断旧子节点是否也是一组子节点\n if (Array.isArray(n1.children)) {\n   // 代码运行到这里，则说明新旧子节点都是一组子节点，这里涉及核心的 Diff 算法\n } else {\n   // 此时：\n   // 旧子节点要么是文本子节点，要么不存在\n   // 但无论哪种情况，我们都只需要将容器清空，然后将新的一组子节点逐个挂载\n   setElementText(container, '')\n   n2.children.forEach(c =&amp;gt; patch(null, c, container))\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，我们新增了对 <code>n2.children</code> 类型的判断：检测它是否是一组子节点，如果是，接着再检查旧子节点的类型。同样，旧子节点也有三种可能：没有子节点、文本子节点和一组子节点。对于没有旧子节点或者旧子节点是文本子节点的情况，我们只需要将容器元素清空，然后逐个将新的一组子节点挂载到容器中即可。如果旧子节点也是一组子节点，则涉及新旧两组子节点的比对，这里就涉及我们常说的 Diff 算法。但由于我们目前还没有讲解 Diff 算法的工作方式，因此可以暂时用一种相对傻瓜式的方法来保证功能可用。这个方法很简单，即把旧的一组子节点全部卸载，再将新的一组子节点全部挂载，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   if (typeof n2.children === 'string') {\n     if (Array.isArray(n1.children)) {\n       n1.children.forEach((c) =&gt; unmount(c))\n     }\n     setElementText(container, n2.children)\n   } else if (Array.isArray(n2.children)) {\n     if (Array.isArray(n1.children)) {\n       // 将旧的一组子节点全部卸载\n       n1.children.forEach(c =&gt; unmount(c))\n       // 再将新的一组子节点全部挂载到容器中\n       n2.children.forEach(c =&gt; patch(null, c, container))\n     } else {\n       setElementText(container, '')\n       n2.children.forEach(c =&gt; patch(null, c, container))\n     }\n   }\n }\n</code></pre>\n<p>这样做虽然能够实现需求，但并不是最优解，我们将在下一章讲解如何使用 Diff 算法高效地更新两组子节点。现在，对于新子节点来说，还剩下最后一种情况，即新子节点不存在，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function patchChildren(n1, n2, container) {\n   if (typeof n2.children === 'string') {\n     if (Array.isArray(n1.children)) {\n       n1.children.forEach((c) =&gt; unmount(c))\n     }\n     setElementText(container, n2.children)\n   } else if (Array.isArray(n2.children)) {\n     if (Array.isArray(n1.children)) {\n       //\n     } else {\n       setElementText(container, '')\n       n2.children.forEach(c =&gt; patch(null, c, container))\n     }\n   } else {\n     // 代码运行到这里，说明新子节点不存在\n     // 旧子节点是一组子节点，只需逐个卸载即可\n     if (Array.isArray(n1.children)) {\n       n1.children.forEach(c =&gt; unmount(c))\n     } else if (typeof n1.children === 'string') {\n       // 旧子节点是文本子节点，清空内容即可\n       setElementText(container, '')\n     }\n     // 如果也没有旧子节点，那么什么都不需要做\n   }\n }\n</code></pre>\n<p>可以看到，如果代码走到了 <code>else</code> 分支，则说明新子节点不存在。这时，对于旧子节点来说仍然有三种可能：没有子节点、文本子节点以及一组子节点。如果旧子节点也不存在，则什么都不需要做；如果旧子节点是一组子节点，则逐个卸载即可；如果旧的子节点是文本子节点，则清空文本内容即可。</p>\n<h2 id=\"nav_point_85\">8.10　文本节点和注释节点</h2>\n<p>在前面的章节中，我们只讲解了一种类型的 <code>vnode</code>，即用于描述普通标签的 <code>vnode</code>，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'div'\n }\n</code></pre>\n<p>我们用 <code>vnode.type</code> 来描述元素的名称，它是一个字符串类型的值。</p>\n<p>接下来，我们讨论如何用虚拟 DOM 描述更多类型的真实 DOM。其中最常见的两种节点类型是文本节点和注释节点，如下面的 HTML 代码所示：</p>\n<pre class=\"code-rows\"><code> &lt;div&gt;&lt;!-- 注释节点 --&gt;我是文本节点&lt;/div&gt;\n</code></pre>\n<p><code>&lt;div&gt;</code> 是元素节点，它包含一个注释节点和一个文本节点。那么，如何使用 <code>vnode</code> 描述注释节点和文本节点呢？</p>\n<p>我们知道，<code>vnode.type</code> 属性能够代表一个 <code>vnode</code> 的类型。如果 <code>vnode.type</code> 的值是字符串类型，则代表它描述的是普通标签，并且该值就代表标签的名称。但注释节点与文本节点不同于普通标签节点，它们不具有标签名称，所以我们需要人为创造一些唯一的标识，并将其作为注释节点和文本节点的 <code>type</code> 属性值，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 文本节点的 type 标识\n const Text = Symbol()\n const newVNode = {\n   // 描述文本节点\n   type: Text,\n   children: '我是文本内容'\n }\n<p>// 注释节点的 type 标识<br />\nconst Comment = Symbol()<br />\nconst newVNode = {<br />\n// 描述注释节点<br />\ntype: Comment,<br />\nchildren: ‘我是注释内容’<br />\n}<br />\n</code></pre></p>\n<p>可以看到，我们分别为文本节点和注释节点创建了 <code>symbol</code> 类型的值，并将其作为 <code>vnode.type</code> 属性的值。这样就能够用 <code>vnode</code> 来描述文本节点和注释节点了。由于文本节点和注释节点只关心文本内容，所以我们用 <code>vnode.children</code> 来存储它们对应的文本内容。</p>\n<p>有了用于描述文本节点和注释节点的 <code>vnode</code> 对象后，我们就可以使用渲染器来渲染它们了，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function patch(n1, n2, container) {\n   if (n1 &amp;&amp; n1.type !== n2.type) {\n     unmount(n1)\n     n1 = null\n   }\n<p>const { type } = n2</p>\n<p>if (typeof type === ‘string’) {<br />\nif (!n1) {<br />\nmountElement(n2, container)<br />\n} else {<br />\npatchElement(n1, n2)<br />\n}<br />\n} else if (type === Text) { // 如果新 vnode 的类型是 Text，则说明该 vnode 描述的是文本节点<br />\n// 如果没有旧节点，则进行挂载<br />\nif (!n1) {<br />\n// 使用 createTextNode 创建文本节点<br />\nconst el = n2.el = document.createTextNode(n2.children)<br />\n// 将文本节点插入到容器中<br />\ninsert(el, container)<br />\n} else {<br />\n// 如果旧 vnode 存在，只需要使用新文本节点的文本内容更新旧文本节点即可<br />\nconst el = n2.el = n1.el<br />\nif (n2.children !== n1.children) {<br />\nel.nodeValue = n2.children<br />\n}<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>观察上面这段代码，我们增加了一个判断条件，即判断表达式 <code>type === Text</code> 是否成立，如果成立，则说明要处理的节点是文本节点。接着，还需要判断旧的虚拟节点（<code>n1</code>）是否存在，如果不存在，则直接挂载新的虚拟节点（<code>n2</code>）。这里我们使用 <code>createTextNode</code> 函数来创建文本节点，并将它插入到容器元素中。如果旧的虚拟节点（<code>n1</code>）存在，则需要更新文本内容，这里我们使用文本节点的 <code>nodeValue</code> 属性完成文本内容的更新。</p>\n<p>另外，从上面的代码中我们还能注意到，<code>patch</code> 函数依赖浏览器平台特有的 API，即 <code>createTextNode</code> 和 <code>el.nodeValue</code>。为了保证渲染器核心的跨平台能力，我们需要将这两个操作 DOM 的 API 封装到渲染器的选项中，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const renderer = createRenderer({\n   createElement(tag) {\n     // 省略部分代码\n   },\n   setElementText(el, text) {\n     // 省略部分代码\n   },\n   insert(el, parent, anchor = null) {\n     // 省略部分代码\n   },\n   createText(text) {\n     return document.createTextNode(text)\n   },\n   setText(el, text) {\n     el.nodeValue = text\n   },\n   patchProps(el, key, prevValue, nextValue) {\n     // 省略部分代码\n   }\n })\n</code></pre>\n<p>在上面这段代码中，我们在调用 <code>createRenderer</code> 函数创建渲染器时，传递的选项参数中封装了 <code>createText</code> 函数和 <code>setText</code> 函数。这两个函数分别用来创建文本节点和设置文本节点的内容。我们可以用这两个函数替换渲染器核心代码中所依赖的浏览器特有的 API，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function patch(n1, n2, container) {\n   if (n1 &amp;&amp; n1.type !== n2.type) {\n     unmount(n1)\n     n1 = null\n   }\n<p>const { type } = n2</p>\n<p>if (typeof type === ‘string’) {<br />\nif (!n1) {<br />\nmountElement(n2, container)<br />\n} else {<br />\npatchElement(n1, n2)<br />\n}<br />\n} else if (type === Text) {<br />\nif (!n1) {<br />\n// 调用 createText 函数创建文本节点<br />\nconst el = n2.el = createText(n2.children)<br />\ninsert(el, container)<br />\n} else {<br />\nconst el = n2.el = n1.el<br />\nif (n2.children !== n1.children) {<br />\n// 调用 setText 函数更新文本节点的内容<br />\nsetText(el, n2.children)<br />\n}<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>注释节点的处理方式与文本节点的处理方式类似。不同的是，我们需要使用 <code>document.createComment</code> 函数创建注释节点元素。</p>\n<h2 id=\"nav_point_86\">8.11　<code>Fragment</code></h2>\n<p><code>Fragment</code>（片断）是 Vue.js 3 中新增的一个 <code>vnode</code> 类型。在具体讨论 <code>Fragment</code> 的实现之前，我们有必要先了解为什么需要 <code>Fragment</code>。请思考这样的场景，假设我们要封装一组列表组件：</p>\n<pre class=\"code-rows\"><code> &lt;List&gt;\n   &lt;Items /&gt;\n &lt;/List&gt;\n</code></pre>\n<p>整体由两个组件构成，即 <code>&lt;List&gt;</code> 组件和 <code>&lt;Items&gt;</code> 组件。其中 <code>&lt;List&gt;</code> 组件会渲染一个 <code>&lt;ul&gt;</code> 标签作为包裹层：</p>\n<pre class=\"code-rows\"><code> &lt;!-- List.vue --&gt;\n &lt;template&gt;\n   &lt;ul&gt;\n     &lt;slot /&gt;\n   &lt;/ul&gt;\n &lt;/template&gt;\n</code></pre>\n<p>而 <code>&lt;Items&gt;</code> 组件负责渲染一组 <code>&lt;li&gt;</code> 列表：</p>\n<pre class=\"code-rows\"><code> &lt;!-- Items.vue --&gt;\n &lt;template&gt;\n   &lt;li&gt;1&lt;/li&gt;\n   &lt;li&gt;2&lt;/li&gt;\n   &lt;li&gt;3&lt;/li&gt;\n &lt;/template&gt;\n</code></pre>\n<p>这在 Vue.js 2 中是无法实现的。在 Vue.js 2 中，组件的模板不允许存在多个根节点。这意味着，一个 <code>&lt;Items&gt;</code> 组件最多只能渲染一个 <code>&lt;li&gt;</code> 标签：</p>\n<pre class=\"code-rows\"><code> &lt;!-- Item.vue --&gt;\n &lt;template&gt;\n   &lt;li&gt;1&lt;/li&gt;\n &lt;/template&gt;\n</code></pre>\n<p>因此在 Vue.js 2 中，我们通常需要配合 <code>v-for</code> 指令来达到目的：</p>\n<pre class=\"code-rows\"><code> &lt;List&gt;\n   &lt;Items v-for=\"item in list\" /&gt;\n &lt;/List&gt;\n</code></pre>\n<p>类似的组合还有 <code>&lt;select&gt;</code> 标签与 <code>&lt;option&gt;</code> 标签。</p>\n<p>而 Vue.js 3 支持多根节点模板，所以不存在上述问题。那么，Vue.js 3 是如何用 <code>vnode</code> 来描述多根节点模板的呢？答案是，使用 <code>Fragment</code>，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const Fragment = Symbol()\n const vnode = {\n   type: Fragment,\n   children: [\n     { type: 'li', children: 'text 1' },\n     { type: 'li', children: 'text 2' },\n     { type: 'li', children: 'text 3' }\n   ]\n }\n</code></pre>\n<p>与文本节点和注释节点类似，片段也没有所谓的标签名称，因此我们也需要为片段创建唯一标识，即 <code>Fragment</code>。对于 <code>Fragment</code> 类型的 <code>vnode</code> 的来说，它的 <code>children</code> 存储的内容就是模板中所有根节点。有了 <code>Fragment</code> 后，我们就可以用它来描述 <code>Items.vue</code> 组件的模板了：</p>\n<pre class=\"code-rows\"><code> &lt;!-- Items.vue --&gt;\n &lt;template&gt;\n   &lt;li&gt;1&lt;/li&gt;\n   &lt;li&gt;2&lt;/li&gt;\n   &lt;li&gt;3&lt;/li&gt;\n &lt;/template&gt;\n</code></pre>\n<p>这段模板对应的虚拟节点是：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: Fragment,\n   children: [\n     { type: 'li', children: '1' },\n     { type: 'li', children: '2' },\n     { type: 'li', children: '3' }\n   ]\n }\n</code></pre>\n<p>类似地，对于如下模板：</p>\n<pre class=\"code-rows\"><code> &lt;List&gt;\n   &lt;Items /&gt;\n &lt;/List&gt;\n</code></pre>\n<p>我们可以用下面这个虚拟节点来描述它：</p>\n<pre class=\"code-rows\"><code> const vnode = {\n   type: 'ul',\n   children: [\n     {\n       type: Fragment,\n       children: [\n         { type: 'li', children: '1' },\n         { type: 'li', children: '2' },\n         { type: 'li', children: '3' }\n       ]\n     }\n   ]\n }\n</code></pre>\n<p>可以看到，<code>vnode.children</code> 数组包含一个类型为 <code>Fragment</code> 的虚拟节点。</p>\n<p>当渲染器渲染 <code>Fragment</code> 类型的虚拟节点时，由于 <code>Fragment</code> 本身并不会渲染任何内容，所以渲染器只会渲染 <code>Fragment</code> 的子节点，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> function patch(n1, n2, container) {\n   if (n1 &amp;&amp; n1.type !== n2.type) {\n     unmount(n1)\n     n1 = null\n   }\n<p>const { type } = n2</p>\n<p>if (typeof type === ‘string’) {<br />\n// 省略部分代码<br />\n} else if (type === Text) {<br />\n// 省略部分代码<br />\n} else if (type === Fragment) { // 处理 Fragment 类型的 vnode<br />\nif (!n1) {<br />\n// 如果旧 vnode 不存在，则只需要将 Fragment 的 children 逐个挂载即可<br />\nn2.children.forEach(c =&gt; patch(null, c, container))<br />\n} else {<br />\n// 如果旧 vnode 存在，则只需要更新 Fragment 的 children 即可<br />\npatchChildren(n1, n2, container)<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>观察上面这段代码，我们在 <code>patch</code> 函数中增加了对 <code>Fragment</code> 类型虚拟节点的处理。渲染 <code>Fragment</code> 的逻辑比想象中要简单得多，因为从本质上来说，渲染 <code>Fragment</code> 与渲染普通元素的区别在于，<code>Fragment</code> 本身并不渲染任何内容，所以只需要处理它的子节点即可。</p>\n<p>但仍然需要注意一点，<code>unmount</code> 函数也需要支持 <code>Fragment</code> 类型的虚拟节点的卸载，如下面 <code>unmount</code> 函数的代码所示：</p>\n<pre class=\"code-rows\"><code> function unmount(vnode) {\n   // 在卸载时，如果卸载的 vnode 类型为 Fragment，则需要卸载其 children\n   if (vnode.type === Fragment) {\n     vnode.children.forEach(c =&gt; unmount(c))\n     return\n   }\n   const parent = vnode.el.parentNode\n   if (parent) {\n     parent.removeChild(vnode.el)\n   }\n }\n</code></pre>\n<p>当卸载 <code>Fragment</code> 类型的虚拟节点时，由于 <code>Fragment</code> 本身并不会渲染任何真实 DOM，所以只需要遍历它的 <code>children</code> 数组，并将其中的节点逐个卸载即可。</p>\n<h2 id=\"nav_point_87\">8.12　总结</h2>\n<p>在本章中，我们首先讨论了如何挂载子节点，以及节点的属性。对于子节点，只需要递归地调用 <code>patch</code> 函数完成挂载即可。而节点的属性比想象中的复杂，它涉及两个重要的概念：HTML Attributes 和 DOM Properties。为元素设置属性时，我们不能总是使用 <code>setAttribute</code> 函数，也不能总是通过元素的 DOM Properties 来设置。至于如何正确地为元素设置属性，取决于被设置属性的特点。例如，表单元素的 <code>el.form</code> 属性是只读的，因此只能使用 <code>setAttribute</code> 函数来设置。</p>\n<p>接着，我们讨论了特殊属性的处理。以 <code>class</code> 为例，Vue.js 对 <code>class</code> 属性做了增强，它允许我们为 <code>class</code> 指定不同类型的值。但在把这些值设置给 DOM 元素之前，要对值进行正常化。我们还讨论了为元素设置 <code>class</code> 的三种方式及其性能情况。其中，<code>el.className</code> 的性能最优，所以我们选择在 <code>patchProps</code> 函数中使用 <code>el.className</code> 来完成 <code>class</code> 属性的设置。除了 <code>class</code> 属性之外，Vue.js 也对 <code>style</code> 属性做了增强，所以 <code>style</code> 属性也需要做类似的处理。</p>\n<p>然后，我们讨论了卸载操作。一开始，我们直接使用 <code>innerHTML</code> 来清空容器元素，但是这样存在诸多问题。</p>\n<ul>\n<li>容器的内容可能是由某个或多个组件渲染的，当卸载操作发生时，应该正确地调用这些组件的 <code>beforeUnmount</code>、<code>unmounted</code> 等生命周期函数。</li>\n<li>即使内容不是由组件渲染的，有的元素存在自定义指令，我们应该在卸载操作发生时正确地执行对应的指令钩子函数。</li>\n<li>使用 <code>innerHTML</code> 清空容器元素内容的另一个缺陷是，它不会移除绑定在 DOM 元素上的事件处理函数。</li>\n</ul>\n<p>因此，我们不能直接使用 <code>innerHTML</code> 来完成卸载任务。为了解决这些问题，我们封装了 <code>unmount</code> 函数。该函数是以一个 <code>vnode</code> 的维度来完成卸载的，它会根据 <code>vnode.el</code> 属性取得该虚拟节点对应的真实 DOM，然后调用原生 DOM API 完成 DOM 元素的卸载。这样做还有两点额外的好处。</p>\n<ul>\n<li>在 <code>unmount</code> 函数内，我们有机会调用绑定在 DOM 元素上的指令钩子函数，例如 <code>beforeUnmount</code>、<code>unmounted</code> 等。</li>\n<li>当 <code>unmount</code> 函数执行时，我们有机会检测虚拟节点 <code>vnode</code> 的类型。如果该虚拟节点描述的是组件，则我们也有机会调用组件相关的生命周期函数。</li>\n</ul>\n<p>而后，我们讨论了 <code>vnode</code> 类型的区分。渲染器在执行更新时，需要优先检查新旧 <code>vnode</code> 所描述的内容是否相同。只有当它们所描述的内容相同时，才有打补丁的必要。另外，即使它们描述的内容相同，我们也需要进一步检查它们的类型，即检查 <code>vnode.type</code> 属性值的类型，据此判断它描述的具体内容是什么。如果类型是字符串，则它描述的是普通标签元素，这时我们会调用 <code>mountElement</code> 和 <code>patchElement</code> 来完成挂载和打补丁；如果类型是对象，则它描述的是组件，这时需要调用 <code>mountComponent</code> 和 <code>patchComponent</code> 来完成挂载和打补丁。</p>\n<p>我们还讲解了事件的处理。首先介绍了如何在虚拟节点中描述事件，我们把 <code>vnode.props</code> 对象中以字符串 <code>on</code> 开头的属性当作事件对待。接着，我们讲解了如何绑定和更新事件。在更新事件的时候，为了提升性能，我们伪造了 <code>invoker</code> 函数，并把真正的事件处理函数存储在 <code>invoker.value</code> 属性中，当事件需要更新时，只更新 <code>invoker.value</code> 的值即可，这样可以避免一次 <code>removeEventListener</code> 函数的调用。</p>\n<p>我们还讲解了如何处理事件与更新时机的问题。解决方案是，利用事件处理函数被绑定到 DOM 元素的时间与事件触发时间之间的差异。我们需要<strong>屏蔽所有绑定时间晚于事件触发时间的事件处理函数的执行</strong>。</p>\n<p>之后，我们讨论了子节点的更新。我们对虚拟节点中的 <code>children</code> 属性进行了规范化，规定 <code>vnode.children</code> 属性只能有如下三种类型。</p>\n<ul>\n<li>字符串类型：代表元素具有文本子节点。</li>\n<li>数组类型：代表元素具有一组子节点。</li>\n<li><code>null</code>：代表元素没有子节点。</li>\n</ul>\n<p>在更新时，新旧 <code>vnode</code> 的子节点都有可能是以上三种情况之一，所以在执行更新时一共要考虑九种可能，即图 8-5 所展示的那样。但落实到代码中，我们并不需要罗列所有情况。另外，当新旧 <code>vnode</code> 都具有一组子节点时，我们采用了比较笨的方式来完成更新，即卸载所有旧子节点，再挂载所有新子节点。更好的做法是，通过 Diff 算法比较新旧两组子节点，试图最大程度复用 DOM 元素。我们会在后续章节中详细讲解 Diff 算法的工作原理。</p>\n<p>我们还讨论了如何使用虚拟节点来描述文本节点和注释节点。我们利用了 <code>symbol</code> 类型值的唯一性，为文本节点和注释节点分别创建唯一标识，并将其作为 <code>vnode.type</code> 属性的值。</p>\n<p>最后，我们讨论了 <code>Fragment</code> 及其用途。渲染器渲染 <code>Fragment</code> 的方式类似于渲染普通标签，不同的是，<code>Fragment</code> 本身并不会渲染任何 DOM 元素。所以，只需要渲染一个 <code>Fragment</code> 的所有子节点即可。</p>\n<br style=\"page-break-after:always\" />","comments":[]}