{"id":739360,"title":"30｜Unsafe编程（下）：使用Rust为Python写一个扩展","content":"<p>你好，我是Mike。</p><p>上一讲我们了解了Unsafe Rust的所属定位和基本性质，这一讲我们就来看看Rust FFI编程到底是怎样一种形式。</p><p>FFI是与外部语言进行交互的接口，在Safe Rust看来，它是不可信的，也就是说Rust编译不能保证它是安全的，只能由程序员自己来保证，因此在Rust里调用这些外部的代码功能就需要把它们包在 <code>unsafe {}</code> 中。</p><p>Rust和C有血缘关系，具有ABI上的一致性，所以<strong>Rust和C之间可以实现双向互调，并且不会损失性能。</strong></p><h2>Rust调用C</h2><p>我们先来看在Rust中如何调用C库的代码。</p><p>一般各个平台下都有 libm 库，它是操作系统基本的数学math库。下面我们以Linux为例来说明。下面的示例代码来自 <a href=\"https://doc.rust-lang.org/rust-by-example/std_misc/ffi.html\">Rust By Example</a>。</p><pre><code class=\"language-plain\">use std::fmt;\n\n// 连接到系统的 libm 库\n#[link(name = \"m\")]\nextern {\n&nbsp; &nbsp; // 这是一个外部函数，计算单精度复数的方根\n&nbsp; &nbsp; fn csqrtf(z: Complex) -&gt; Complex;\n    // 计算复数的余弦值\n&nbsp; &nbsp; fn ccosf(z: Complex) -&gt; Complex;\n}\n\n// 对unsafe调用的safe封装，从此以后，就按safe函数方式使用这个接口\nfn cos(z: Complex) -&gt; Complex {\n&nbsp; &nbsp; unsafe { ccosf(z) }\n}\n\nfn main() {\n&nbsp; &nbsp; // z = -1 + 0i\n&nbsp; &nbsp; let z = Complex { re: -1., im: 0. };\n\n&nbsp; &nbsp; // 调用m库中的函数，需要用 unsafe {} 包起来\n&nbsp; &nbsp; let z_sqrt = unsafe { csqrtf(z) };\n\n&nbsp; &nbsp; println!(\"the square root of {:?} is {:?}\", z, z_sqrt);\n\n&nbsp; &nbsp; // 调用安全封装后的函数\n&nbsp; &nbsp; println!(\"cos({:?}) = {:?}\", z, cos(z));\n}\n\n// 用 repr(C) 标注，定义Rust结构体的ABI格式，按C的ABI来\n#[repr(C)]\n#[derive(Clone, Copy)]\nstruct Complex {\n&nbsp; &nbsp; re: f32,\n&nbsp; &nbsp; im: f32,\n}\n\n// 实现复数的打印输出\nimpl fmt::Debug for Complex {\n&nbsp; &nbsp; fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n&nbsp; &nbsp; &nbsp; &nbsp; if self.im &lt; 0. {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write!(f, \"{}-{}i\", self.re, -self.im)\n&nbsp; &nbsp; &nbsp; &nbsp; } else {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write!(f, \"{}+{}i\", self.re, self.im)\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><!-- [[[read_end]]] --><p>libm 库是用C语言实现的，我们要调用它，需要用这样的标注。</p><pre><code class=\"language-plain\">#[link(name = \"m\")]\nextern {\n}\n</code></pre><p>用 lnk 属性宏将libm库连接进来，以便去里面找对应的函数。然后把需要的外部函数导入进来。你可以看一下 <code>csqrtf()</code> 函数和 <code>ccosf()</code> 的C语言签名。</p><pre><code class=\"language-plain\">float complex csqrtf(float complex z);\nfloat complex ccosf (float complex z);\n</code></pre><p>导入的时候，要翻译成Rust函数的签名形式。</p><pre><code class=\"language-plain\">fn csqrtf(z: Complex) -&gt; Complex;\nfn ccosf(z: Complex) -&gt; Complex;\n</code></pre><p>调用这两个函数的时候，都需要用 <code>unsafe {}</code> 包起来。</p><p>然后我们仔细看一下在Rust中对应到libm中的复数的定义。</p><pre><code class=\"language-plain\">#[repr(C)]\n#[derive(Clone, Copy)]\nstruct Complex {\n&nbsp; &nbsp; re: f32,\n&nbsp; &nbsp; im: f32,\n}\n</code></pre><p>对应的C语言中的结构定义在 <a href=\"https://en.cppreference.com/w/c/numeric/complex\">complex.h 头文件</a>中，它是C99标准引入的数据类型。</p><p>本身这个定义非常简单，就是定义复数的实部和虚部就可以了，不过一定要用 <code>#[repr(C)]</code> 标注。它的意思是这个类型编译的时候，要使用C语言的ABI格式。我们一般都使用C语言ABI格式，但是也有一些其他的ABI格式，你可以点击我给出的<a href=\"https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions\">链接</a>，查到Rust中支持的ABI格式列表。</p><p>一般来讲，我们会使用Rust函数对这些外部unsafe函数做一下封装。像cos函数这样，你可以参看一下示例代码。</p><pre><code class=\"language-plain\">fn cos(z: Complex) -&gt; Complex {\n&nbsp; &nbsp; unsafe { ccosf(z) }\n}\n</code></pre><p>执行 <code>cargo run</code>，输出了下面这两行代码。</p><pre><code class=\"language-plain\">the square root of -1+0i is 0+1i\ncos(-1+0i) = 0.5403023+0i\n</code></pre><p><span class=\"reference\">注：项目代码链接</span><a href=\"https://github.com/miketang84/jikeshijian/tree/master/30-ffi/rust_call_c\">https://github.com/miketang84/jikeshijian/tree/master/30-ffi/rust_call_c</a></p><h3>bindgen</h3><p>Rust官方出了一个 <a href=\"https://github.com/rust-lang/rust-bindgen\">bindgen</a> 项目，可以帮助我们快速从C库的头文件生成Rust FFI绑定层代码。之所以能这样做，是因为我们发现，C的接口转换成Rust的接口形式是非常固定的，转换的过程需要写大量的样板代码，所以就可以用 bindgen 这种工具自动转换。</p><p>比如某个C头文件里定义了这样的类型和函数：</p><pre><code class=\"language-plain\">typedef struct Doggo {\n    int many;\n    char wow;\n} Doggo;\n\nvoid eleven_out_of_ten_majestic_af(Doggo* pupper);\n</code></pre><p>使用 bindgen 自动生成FFI绑定后，可以生成类似这样的代码：</p><pre><code class=\"language-plain\">/* automatically generated by rust-bindgen 0.99.9 */\n\n#[repr(C)]\npub struct Doggo {\n    pub many: ::std::os::raw::c_int,\n    pub wow: ::std::os::raw::c_char,\n}\n\nextern \"C\" {\n    pub fn eleven_out_of_ten_majestic_af(pupper: *mut Doggo);\n}\n</code></pre><p>你可能发现了，Rust里有一批类型，以 c_ 前缀开头。比如 C语言的 int 类型，对应 std 中的类型你可以通过我给出的<a href=\"https://doc.rust-lang.org/std/ffi/type.c_int.html\">链接</a>找到。</p><p>这些就是Rust里定义的与C完全相同的类型。我们可以看一下 <a href=\"https://doc.rust-lang.org/std/ffi/type.c_char.html\">c_char</a> 的定义。</p><pre><code class=\"language-plain\">pub type c_char = i8;\n</code></pre><p>竟然直接是一个 i8。因为C语言里的char就是一个普通字节，和Rust里的char完全不同。这是在Rust中完全兼容C必要的一步，就是<strong>把C中的类型全部映射过来，并加上c_ 前缀</strong>。这样单独搞一批类型就是因为有的类型没办法直接映射到 Rust 的 char 上来，比如刚刚说的这个 c_char。</p><p>典型的，还有 C 语言中的 void 类型，它在Rust里没有对应物，所以就映射成了 <a href=\"https://doc.rust-lang.org/std/ffi/enum.c_void.html\">c_void</a>，在Rust中定义成了一个 enum。</p><pre><code class=\"language-plain\">#[repr(u8)]\npub enum c_void {\n    // some variants omitted\n}\n</code></pre><p>下面我们继续看，反过来，在C中如何调用Rust代码。</p><h2>C调用Rust</h2><p>在C中调用Rust代码的基本思路是，Rust代码编译成 <code>.so</code> 或 <code>.dll</code> 动态链接库，在C语言里面编译的时候，连接就可以了。</p><p>在 lib.rs 文件中，写这样一个函数：</p><pre><code class=\"language-plain\">#[no_mangle]\npub extern \"C\" fn hello_from_rust() {\n&nbsp; &nbsp; println!(\"Hello from Rust!\");\n}\n</code></pre><p>注意属性宏 <code>#[no_mangle]</code>，在Rust中，no_mangle 用于告诉Rust编译器不要修改函数的名称，这种修改叫做Mangling，它是编译器在解析名称时，修改我们定义的函数名称，增加一些用于其编译过程的额外信息。但在和其他语言交互时，如果函数名称被编译器修改，程序开发者就没办法知道修改后的函数名称了，其他语言也无法按原名称调用。因此，#[no_mangle] 在这种场景下就非常有用了。</p><p>Cargo.toml 要加个配置，表示编译的这个库是 C ABI 格式的动态链接库。</p><pre><code class=\"language-plain\">[lib]\ncrate-type = [\"cdylib\"]\n</code></pre><p>然后用 <code>cargo build</code> 编译输出。你可以在 target/debug 目录下面看到你的 <code>.so</code> 库文件，比如下面这个样子：</p><pre><code class=\"language-plain\">$ ls target/debug/\nbuild&nbsp; deps&nbsp; examples&nbsp; incremental&nbsp; libc_call_rust.d&nbsp; libc_call_rust.so\n</code></pre><p>这里这个 libc_call_rust.so 就是我们的动态链接库，其中 <code>c_call_rust</code> 是我们这个 crate 的名字。</p><p>下面是C的部分，代码如下：</p><pre><code class=\"language-plain\">extern void hello_from_rust();\n\nint main(void) {\n&nbsp; &nbsp; hello_from_rust();\n&nbsp; &nbsp; return 0;\n}\n</code></pre><p>存成 call_rust.c 文件。用下面这种形式编译：</p><pre><code class=\"language-plain\">gcc call_rust.c -o call_rust -lc_call_rust -L./target/debug\n</code></pre><p>运行：</p><pre><code class=\"language-plain\">LD_LIBRARY_PATH=./target/debug ./call_rust\n</code></pre><p>你可以看到输出内容 <code>Hello from Rust!</code>。</p><p><span class=\"reference\">注：完整可测试代码</span><a href=\"https://github.com/miketang84/jikeshijian/tree/master/30-ffi/c_call_rust\">https://github.com/miketang84/jikeshijian/tree/master/30-ffi/c_call_rust</a></p><p>当然，这只是最简单的形式，万里长征我们刚踏出第一步，还有各种复杂的FFI场景等着你去探索。</p><h3>Cbindgen</h3><p>在实际工作中，当你需要以Rust仓库为主，为其他语言导出C接口的时候，一般还需要生成C的头文件，这时，你应该会对 <a href=\"https://github.com/mozilla/cbindgen\">cbindgen</a> 项目很感兴趣，它也算半官方的（在Mozilla名下），它的作用与前面的 bindgen 刚好相反，是从Rust代码中生成C可以调用的代码签名。</p><p>Rust与C的交互我们先讨论到这里，下面我们要研究一下如何用Rust给Python写扩展。</p><h2>使用Rust给Python写扩展</h2><p>标准的Python扩展是用 C/C++ 写的，Python 官方有<a href=\"https://docs.python.org/3/extending/extending.html\">教程</a>，感兴趣的话你可以研究一下。我们这节课聚焦于如何用Rust给Python写扩展。</p><p>其实，只要你将Rust的代码扩展到C可以调用，那么再进一步，按Python官方教程那样，继续将C代码封装成Python扩展就可以了，下面我们讲的基本思路也是这样。</p><p>在实际实现的时候，我们会写非常多的样板代码，写起来比较痛苦。但是Rust社区有非常优秀的项目：PyO3，它可以帮助我们减轻这种烦恼，自动帮我们处理好中间样板封装过程。</p><h3>PyO3</h3><p>PyO3是Rust社区里非常火的与Python绑定的框架，它不仅可以实现用Rust给Python写扩展，还能在Rust的二进制程序中直接执行Python代码。所以实际 PyO3 是一个双向绑定库。</p><p>PyO3封装了底层FFI绑定的各种细节。这些细节其实不是那么简单，你可以想一下，如何将Python的Class正确映射到Rust中对应的类型，如何正确处理模块、函数、参数、返回值类型，这里面有各种细节，想想就头痛。</p><p>而 PyO3 把这一切都封装在了Rust属性宏里面。我们来看一个示例。</p><pre><code class=\"language-plain\">use num_bigint::BigUint;\nuse num_traits::{One, Zero};\nuse pyo3::prelude::*;\n\n// Calculate large fibonacci numbers.\nfn fib(n: usize) -&gt; BigUint {\n&nbsp; &nbsp; let mut f0: BigUint = Zero::zero();\n&nbsp; &nbsp; let mut f1: BigUint = One::one();\n&nbsp; &nbsp; for _ in 0..n {\n&nbsp; &nbsp; &nbsp; &nbsp; let f2 = f0 + &amp;f1;\n&nbsp; &nbsp; &nbsp; &nbsp; f0 = f1;\n&nbsp; &nbsp; &nbsp; &nbsp; f1 = f2;\n&nbsp; &nbsp; }\n&nbsp; &nbsp; f0\n}\n\n#[pyfunction]\nfn calc_fib(n: usize) -&gt; PyResult&lt;()&gt; {\n&nbsp; &nbsp; let _ = fib(n);\n&nbsp; &nbsp; Ok(())\n}\n\n#[pymodule]\nfn rust_fib(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {\n&nbsp; &nbsp; m.add_function(wrap_pyfunction!(calc_fib, m)?)?;\n&nbsp; &nbsp; Ok(())\n}\n</code></pre><p>这个示例的作用是计算斐波那契数列的第N项。当这个N值比较大的时候，斐波那契数是一个非常大的数，一个u64装不下，因此我们要使用大数类型。在Rust中，num-bigint是一个常用的大数类型实现库。而在Python中，int默认就支持大数。</p><p>代码中，<code>fib()</code> 函数是真正计算斐波那契数的函数，然后在 <code>calc_fib()</code> 中封装给了 Python 使用，请注意这个函数头上的 <code>#[pyfunction]</code> 标注，它表明这个函数会导出给 Python 使用，是一个函数。</p><p>而下面的 <code>rust_fib()</code> 函数，则是标准的样板代码，它表示创建一个 Python 的模块，这个模块的名字叫做 <code>rust_fib</code>，这个名字会在Python代码中以 <code>import rust_fib</code> 的形式导入。<code>#[pymodule]</code> 就起这个自动转化的作用。这个函数中的 m 参数就表示模块实例，<code>m.add_function()</code> 将 <code>calc_fib()</code> 添加到这个模块中。所以我们这个 crate 库会被编译成一个共识库，并被导入为 Python 的一个模块。</p><p>你可以看一下 Cargo.toml 的新增配置。</p><pre><code class=\"language-plain\">[lib]\nname = \"rust_fib\"\ncrate-type = [\"cdylib\"]\n</code></pre><p>在Python中这样调用：</p><pre><code class=\"language-plain\">import rust_fib\nrust_fib.calc_fib(2000000)\n</code></pre><p><span class=\"reference\">注：完整的可运行代码</span><a href=\"https://github.com/miketang84/jikeshijian/blob/master/30-ffi/bigint-pyo3\">https://github.com/miketang84/jikeshijian/blob/master/30-ffi/bigint-pyo3</a></p><p>这样PyO3项目的一个关键是，需要使用 maturin 这种构建工具。你可以下载代码后，按下面的脚本准备好虚拟环境，并在这个虚拟环境里安装好 maturin。</p><pre><code class=\"language-plain\">$ cd bigint-pyo3\n$ python -m venv .env\n$ source .env/bin/activate\n$ pip install maturin\n</code></pre><p>在项目目录下运行：</p><pre><code class=\"language-plain\">maturin develop -r\n</code></pre><p>这个指令会编译Rust代码为 release 模式，并把编译后的文件安装到 Python module 库的目录组织里去。</p><p>然后运行：</p><pre><code class=\"language-plain\">$ time python fib_rust.py\n\nreal&nbsp; &nbsp; 0m12.452s\nuser&nbsp; &nbsp; 0m12.431s\nsys&nbsp; &nbsp; &nbsp;0m0.020s\n</code></pre><p>我们对比一下纯Python版本运行的时间。</p><pre><code class=\"language-plain\">$ time python fib.py\n\nreal&nbsp; &nbsp; 0m21.730s\nuser&nbsp; &nbsp; 0m21.490s\nsys&nbsp; &nbsp; &nbsp;0m0.240s\n</code></pre><p>这是计算第200万项斐波那契数，可以看到用Rust实现的版本快将近一倍。</p><p>PyO3给我们提供的编程界面非常清爽，只要你跟着操作一遍，很快就能用Rust给Python写扩展了。PyO3的<a href=\"https://pyo3.rs\">文档</a>也写得非常好，上面有更全面的功能介绍，一定要读一读。</p><h3>性能优化示例：文本单词统计</h3><p>Python的GIL（Global Interpreter Lock）是一个被人诟病的特性，它限制很多Python代码只能以单线程的形式来跑。因此也就大大限制了Python的性能。而Rust原生支持系统级多线程（thread）以及轻量级线程（tokio task 等），能够非常方便地充分压榨所有CPU核。既然我们可以使用Rust给Python写扩展，那一个点子就顺理成章冒出来了——可以使用Rust给Python写扩展实现并行计算。</p><p>下面我们就以官方的示例 word_count 来说明如何使用。这个程序要解决这样一个问题：统计出一个文本文件里，某一个单词出现的次数。这个文本文件是按换行符分隔成一行一行的，行与行之间互不干涉。因此可以采用按行分割的形式来并行化处理。</p><p>Rust中有一个著名的并行化库Rayon，可以将串行迭代器转换成一个并行化版本的迭代器，从而实现程序的并行化。下面我们来看代码：</p><pre><code class=\"language-plain\">use pyo3::prelude::*;\nuse rayon::prelude::*;\n\n/// 并行化版本的搜索功能实现\n#[pyfunction]\nfn search(contents: &amp;str, needle: &amp;str) -&gt; usize {\n&nbsp; &nbsp; contents\n&nbsp; &nbsp; &nbsp; &nbsp; .par_lines()\n&nbsp; &nbsp; &nbsp; &nbsp; .map(|line| count_line(line, needle))\n&nbsp; &nbsp; &nbsp; &nbsp; .sum()\n}\n\n/// 将行按空格分割，统计目标单词数目\nfn count_line(line: &amp;str, needle: &amp;str) -&gt; usize {\n&nbsp; &nbsp; let mut total = 0;\n&nbsp; &nbsp; for word in line.split(' ') {\n&nbsp; &nbsp; &nbsp; &nbsp; if word == needle {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total += 1;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n&nbsp; &nbsp; total\n}\n\n// 导出到Python module\n#[pymodule]\nfn word_count(_py: Python&lt;'_&gt;, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {\n&nbsp; &nbsp; m.add_function(wrap_pyfunction!(search, m)?)?;\n\n&nbsp; &nbsp; Ok(())\n}\n</code></pre><p>代码中，<code>search()</code> 函数中 <code>contents.par_lines()</code> 这一行就是使用的 Rayon 里的 <code>par_lines()</code> 迭代器，它是 <code>lines()</code> 迭代器的并行化版本。上面的 search 实现对应下面的 Python 版本。</p><pre><code class=\"language-plain\">def search_py(contents: str, needle: str) -&gt; int:\n&nbsp; &nbsp; total = 0\n&nbsp; &nbsp; for line in contents.splitlines():\n&nbsp; &nbsp; &nbsp; &nbsp; for word in line.split(\" \"):\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if word == needle:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total += 1\n&nbsp; &nbsp; return total\n</code></pre><p>你可以看一下<a href=\"https://github.com/miketang84/jikeshijian/tree/master/30-ffi/word-count\">项目代码</a>，这个项目使用 <code>pytest-benchmark</code> 来做性能评测。要运行性能评测，你需要安装 nox。</p><pre><code class=\"language-plain\">// 先安装项目依赖\npip install .\n// 再安装 nox 工具\npip install nox\n</code></pre><p>然后在项目根目录下运行：</p><pre><code class=\"language-plain\">nox -s bench\n</code></pre><p>稍等片刻，我们会得到如下输出：</p><pre><code class=\"language-plain\">$ nox -s bench\nnox &gt; Running session bench\nnox &gt; Creating virtual environment (virtualenv) using python3 in .nox/bench\nnox &gt; python -m pip install '.[dev]'\nnox &gt; pytest --benchmark-enable\n=========================================================== test session starts ============================================================\nplatform linux -- Python 3.10.12, pytest-7.4.3, pluggy-1.3.0\nbenchmark: 4.0.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)\nrootdir: /home/mike/works/pyo3works/word-count\nconfigfile: pyproject.toml\nplugins: benchmark-4.0.0\ncollected 2 items\n\ntests/test_word_count.py ..&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [100%]\n\n\n\n----------------------------------------------------------------------------------------- benchmark: 2 tests ----------------------------------------------------------------------------------------\nName (time in ms)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Min&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Max&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Mean&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StdDev&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Median&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;IQR&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Outliers&nbsp; &nbsp; &nbsp; OPS&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Rounds&nbsp; Iterations\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\ntest_word_count_rust_parallel&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;19.6740 (1.0)&nbsp; &nbsp; &nbsp; 50.2725 (1.0)&nbsp; &nbsp; &nbsp; 27.9049 (1.0)&nbsp; &nbsp; &nbsp; 9.7562 (2.27)&nbsp; &nbsp; &nbsp;22.9368 (1.0)&nbsp; &nbsp; &nbsp; 8.5993 (1.13)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2;2&nbsp; 35.8360 (1.0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 13&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1\ntest_word_count_python_sequential&nbsp; &nbsp; &nbsp;78.4158 (3.99)&nbsp; &nbsp; &nbsp;91.5790 (1.82)&nbsp; &nbsp; &nbsp;84.4852 (3.03)&nbsp; &nbsp; &nbsp;4.3023 (1.0)&nbsp; &nbsp; &nbsp; 84.7501 (3.69)&nbsp; &nbsp; &nbsp;7.6210 (1.0)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;5;0&nbsp; 11.8364 (0.33)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;13&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1\n-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nLegend:\n&nbsp; Outliers: 1 Standard Deviation from Mean; 1.5 IQR (InterQuartile Range) from 1st Quartile and 3rd Quartile.\n&nbsp; OPS: Operations Per Second, computed as 1 / Mean\n============================================================ 2 passed in 2.78s =============================================================\nnox &gt; Session bench was successful.\n</code></pre><p>可以看到，Rust并行化版本比Python顺序化版本的平均性能提升了3倍左右（并行化版本消耗时间为顺序化版本的1/3左右），实际上被处理的文件越大，这个性能提升就越明显。</p><h2>业界知名PyO3绑定项目介绍</h2><p>目前，Rust生态和Python之间已经有一些知名的项目使用 PyO3 实现绑定了，我选了几个比较不错的放在下面，你可以点击链接深入了解一下。</p><ul>\n<li>OpenDAL 的 Python 绑定：<a href=\"https://github.com/apache/incubator-opendal/tree/main/bindings/python\">https://github.com/apache/incubator-opendal/tree/main/bindings/python</a></li>\n<li>Polars 的 Python 绑定：<a href=\"https://github.com/pola-rs/polars/tree/main/py-polars\">https://github.com/pola-rs/polars/tree/main/py-polars</a></li>\n<li>Delta Lake 的 Python 绑定：<a href=\"https://github.com/delta-io/delta-rs/tree/main/python\">https://github.com/delta-io/delta-rs/tree/main/python</a></li>\n<li>Arrow-Datafusion 的 Python 绑定：<a href=\"https://github.com/apache/arrow-datafusion-python\">https://github.com/apache/arrow-datafusion-python</a></li>\n<li>tokenizers 的 Python 绑定：<a href=\"https://github.com/huggingface/tokenizers/tree/main/bindings/python\">https://github.com/huggingface/tokenizers/tree/main/bindings/python</a></li>\n</ul><h2>小结</h2><p>这节课我们通过4个示例展示了如何在Rust中调用C函数，如何在C函数中调用Rust函数，以及在Python中调用Rust实现的模块和函数。并且通过对比Rust的实现版本与Python原生的实现版本，我们发现使用Rust写Python扩展性能更好。</p><p>Unsafe Rust编程大量出现在底层性能的优化和与其他语言交互的场景中，体现了Rust这门语言一个奇特的地方：Rust语言本身对安全性和性能的追求，不但让Rust本身脱颖而出，而且还反哺了C语言的生态，用Rust重新实现一部分模块，同时还能无缝地接入之前的C系统中，提升了之前C系统的安全性。并且这是一种渐进的做法，非常有利于历史遗留系统的迭代更新。</p><p>此外，Unsafe Rust编程还可以赋能其他语言社区，将Rust的澎湃动力和安全扩展到了Python、JavaScript等其他语言。它们之前的扩展使用C/C++编写，同样会存在安全性和稳定性的问题，而Rust解决了这个问题。</p><p>不过涉及到Unsafe Rust和FFI的场景，想要封装一个真正好用的库或扩展，还有大量的细节知识待你探索。不管怎样，我们已经踏上了安全提升和性能提升之路，有Rust为你输出动力，保驾护航，你便可以放开手脚，大胆去干。</p><h2>思考题</h2><p>请你聊一聊，C语言中的char与Rust中的char的区别在哪里？C语言的字符串与Rust中的String区别在哪里？如何将C语言的字符串类型映射到Rust的类型中来？欢迎你把自己的思考分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"29｜Unsafe编程（上）： Unsafe Rust中那些被封印的能力","id":739345},"right":{"article_title":"结束语｜未来让Rust带你“锈”到起飞","id":740385}},"comments":[{"had_liked":false,"id":388309,"user_name":"小可爱(`へ´*)ノ","can_delete":false,"product_type":"c1","uid":1016404,"ip_address":"重庆","ucode":"E75189846F6616","user_header":"https://static001.geekbang.org/account/avatar/00/0f/82/54/b9cd3674.jpg","comment_is_top":false,"comment_ctime":1709857021,"is_pvip":false,"replies":[{"id":141473,"content":"谢谢","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1710434371,"ip_address":"加拿大","comment_id":388309,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"跟完了，很值得的，老师功底很厚。","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":639284,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710434372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"加拿大","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386094,"user_name":"一带一路","can_delete":false,"product_type":"c1","uid":1633613,"ip_address":"四川","ucode":"BD3E750A9EBF25","user_header":"https://static001.geekbang.org/account/avatar/00/18/ed/4d/7df516d5.jpg","comment_is_top":false,"comment_ctime":1704091394,"is_pvip":false,"replies":[{"id":140726,"content":"未来可期！","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704170660,"ip_address":"重庆","comment_id":386094,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"Rust 与 Python 绑定未来可期！","like_count":1,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634875,"discussion_content":"未来可期！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704170660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":387204,"user_name":"A0.何文祥","can_delete":false,"product_type":"c1","uid":1052569,"ip_address":"广东","ucode":"2549126DAEA15D","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/99/0d72321f.jpg","comment_is_top":false,"comment_ctime":1706699006,"is_pvip":false,"replies":[{"id":141162,"content":"我给的源代码里面有这个功能，注释掉了。你可以研究研究。关闭的原因是为了简化难度。","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1707198559,"ip_address":"四川","comment_id":387204,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"老师，我根据文档https:&#47;&#47;pyo3.rs&#47;v0.20.2&#47;parallelism了解到，如果要在PyO3里Release GIL需要执行Python::allow_threads，咱们实例是不是遗漏了这一步，实际跑的还是single CPU core。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636896,"discussion_content":"我给的源代码里面有这个功能，注释掉了。你可以研究研究。关闭的原因是为了简化难度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1707198559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386876,"user_name":"tan","can_delete":false,"product_type":"c1","uid":1477463,"ip_address":"中国香港","ucode":"20E176CB1EFD51","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/57/a3daeaae.jpg","comment_is_top":false,"comment_ctime":1705764378,"is_pvip":false,"replies":[{"id":141076,"content":"这种观测不准，因为混杂了加载文件的时间在里面。不过那个12秒多的差距有点吃惊了。你开了release编译没","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1705970862,"ip_address":"重庆","comment_id":386876,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"window 观测时间： Measure-Command {python .\\fib_rust.py}    。\nps: 为什么我在window10上测试 python自己写的函数只要 0.49s, 调用rust的需要12s\nps: 如果有同学不关心执行时间想要确定调用成功与否，需要`calc_fib` 把给这个函数返回值","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636341,"discussion_content":"这种观测不准，因为混杂了加载文件的时间在里面。不过那个12秒多的差距有点吃惊了。你开了release编译没","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705970862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386868,"user_name":"zxk","can_delete":false,"product_type":"c1","uid":1221195,"ip_address":"海南","ucode":"4BB2BD9D2BCD04","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/4b/b72f724f.jpg","comment_is_top":false,"comment_ctime":1705737981,"is_pvip":false,"replies":[{"id":141020,"content":"真棒👍！","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1705760738,"ip_address":"重庆","comment_id":386868,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"C 语言中的 char 是一个 8bit 大小的类型，一个 char 可以覆盖 ASCII 码表；而在 Rust 中 char 是一个 Unicode 字符，使用 32bit（即 UTF-32）进行存储。\n\nC 语言中的字符串其实就是一个 char 数组，并以 `\\0` 作为结束标志；而 Rust 中的 String 是经过 UTF-8 编码后的字节数组，一个实际的字符对应一个或多个字节（UTF-8 是可变长编码），通过一个长度来得出字符串的结束位置。\n\n若要将 C 语言的字符串类型映射到 Rust 中的类型，目前能想到两种方案：\n1. C 端以 UTF-8 的方式编码存储字符串，并传递给 Rust； Rust 可以选择使用 CString 存储在转化，或者自行解析并注意 `\\0` 的标识符；\n2. C 端自由选择编码，在传给 Rust 时告诉 Rust 编码方式，并由 Rust 自行解码，并转为内部的 UTF-8 编码。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636186,"discussion_content":"真棒👍！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1705760738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386217,"user_name":"Noya","can_delete":false,"product_type":"c1","uid":1519230,"ip_address":"浙江","ucode":"52EEB72E80BAF8","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/7e/a15b477c.jpg","comment_is_top":false,"comment_ctime":1704346812,"is_pvip":false,"replies":[{"id":140783,"content":"真棒👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704366240,"ip_address":"重庆","comment_id":386217,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"完结!","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":635063,"discussion_content":"真棒👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704366240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386102,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"广东","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1704106411,"is_pvip":false,"replies":[{"id":140721,"content":"只是一个示例，这里只是为了比较一下计算性能。你可以尝试改进一下这个示例。👍","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704162265,"ip_address":"重庆","comment_id":386102,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"请问在 calc_fib 函数里，为什么 fib 的计算结果被丢弃，而返回 Ok(()) 呢？\n","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634869,"discussion_content":"只是一个示例，这里只是为了比较一下计算性能。你可以尝试改进一下这个示例。👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704162265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1633613,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ed/4d/7df516d5.jpg","nickname":"一带一路","note":"","ucode":"BD3E750A9EBF25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634956,"discussion_content":"是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704208871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386101,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"广东","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1704105364,"is_pvip":false,"replies":[{"id":140727,"content":"这个工程文件是 maturin 创建的 . 没有创建这个文件也能正常运行, 我还没试过. 可能maturin能识别默认配置吧.","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704170877,"ip_address":"重庆","comment_id":386101,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"请问老师，pyproject.toml 这个文件是哪个工具需要的？ 我按本课教程操作，没有创建这个文件也能正常运行。","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634876,"discussion_content":"这个工程文件是 maturin 创建的 . 没有创建这个文件也能正常运行, 我还没试过. 可能maturin能识别默认配置吧.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704170877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1633613,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ed/4d/7df516d5.jpg","nickname":"一带一路","note":"","ucode":"BD3E750A9EBF25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634955,"discussion_content":"发布就不行了，PyPI发布这个库是需要的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704208847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634876,"ip_address":"四川","group_id":0},"score":634955,"extra":""}]},{"author":{"id":1081922,"avatar":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","nickname":"刘丹","note":"","ucode":"66594D1C957E15","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634960,"discussion_content":"在后面的例子里发现 pip install . 会识别使用到 pyproject.toml  这个文件","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704240248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":386100,"user_name":"Geek_72807e","can_delete":false,"product_type":"c1","uid":3570665,"ip_address":"山西","ucode":"9E9A6277605048","user_header":"","comment_is_top":false,"comment_ctime":1704103359,"is_pvip":false,"replies":[{"id":140728,"content":"陈天老师的课,教你完整地做一个kv db. 挺不错的.  陈老师的课可以看作是本课程的进阶课程.","user_name":"作者回复","user_name_real":"编辑","uid":2186062,"ctime":1704170914,"ip_address":"重庆","comment_id":386100,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100626901,"comment_content":"基本跟完了老师的课程，还有哪些进阶内容或参考资料老师推荐一下？！","like_count":0,"discussions":[{"author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634877,"discussion_content":"陈天老师的课,教你完整地做一个kv db. 挺不错的.  陈老师的课可以看作是本课程的进阶课程.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704170914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"重庆","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":1633613,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ed/4d/7df516d5.jpg","nickname":"一带一路","note":"","ucode":"BD3E750A9EBF25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2186062,"avatar":"https://static001.geekbang.org/account/avatar/00/21/5b/4e/8e1f699e.jpg","nickname":"Mike Tang","note":"","ucode":"55775BCEDB5937","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":634954,"discussion_content":"赞爆","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704208788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":634877,"ip_address":"四川","group_id":0},"score":634954,"extra":""}]}]},{"had_liked":false,"id":396323,"user_name":"陈卧虫","can_delete":false,"product_type":"c1","uid":1481979,"ip_address":"浙江","ucode":"44BB84712436AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/fb/7fe6df5b.jpg","comment_is_top":false,"comment_ctime":1733973754,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":5,"score":2,"product_id":100626901,"comment_content":"真的讲的很好，我学习 rust 的第一课，谢谢老师🙏","like_count":0}]}