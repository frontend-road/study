{"id":825578,"title":"18｜商业意义（上）：如何利用端侧重排提升转化率","content":"<p>你好，我是柳博文，欢迎和我一起学习前端工程师的AI实战课。</p><p>前面我们分析了用户点击行为数据，并按性别和年龄细分，探讨了不同群体的UI偏好。不过除了通过热力图的方式，还有更多挖掘和分析数据的方式。</p><p>接下来的两节课，我们来看看如何通过不同的算法模型，找到不同人群下的数据共性，再将算法跑在端侧来为不同人群推荐不同的UI结果，为产品转化做出更多贡献。</p><p>今天我们先来学习如何进行数据预处理，然后再看看怎么应用传统算法来处理这些数据。</p><h2>通过算法找到数据共性</h2><p>在上节课中，我们用热力图可视化的方式分析了用户的点击数据。不过对于这些数据，我们还有更科学的处理方式，那就是利用一些常规的算法模型来处理分析，从而找到这堆数据中的共性。</p><p>在这组数据中，每条记录都包含了用户的ID、性别、年龄等用户属性，同时还记录了用户在H5页面上的点击行为时间和位置。在上节课讨论长尾效应时，我们了解到，用户的点击位置实际上对应了页面中Feeds卡片的类型，而这些卡片类型具有特定的商业属性。</p><p>为了便于后续算法分析，我们将用户的点击位置与Feeds对应的卡片类型进行匹配绑定。具体来说，我们可以使用点击事件的y坐标来确定用户点击了哪个位置上的卡片类型。</p><!-- [[[read_end]]] --><p>以下是Feeds的结构映射，展示了各个y坐标区间与相应卡片类型之间的对应关系。这种映射方式将帮助我们更好地理解用户行为模式及其与页面元素之间的关系，从而优化用户体验、提升商业效果。</p><pre><code class=\"language-javascript\">const regions = {\n&nbsp; bar: [0, 100],\n&nbsp; seckill: [150, 350],\n&nbsp; item_1: [370, 470],\n&nbsp; banner: [490, 590],\n&nbsp; item_2: [610, 710],\n&nbsp; item_3: [830, 930],\n&nbsp; item_4: [950, 1050],\n&nbsp; item_5: [1070, 1170],\n&nbsp; item_6: [1190, 1290],\n&nbsp; item_7: [1310, 1410],\n&nbsp; item_8: [1430, 1530],\n&nbsp; item_9: [1550, 1650],\n&nbsp; item_10: [1670, 1770],\n&nbsp; item_11: [1790, 1890],\n&nbsp; item_12: [1910, 2010],\n&nbsp; item_13: [2030, 2130],\n&nbsp; item_14: [2150, 2250],\n&nbsp; item_15: [2270, 2370],\n&nbsp; item_16: [2390, 2490],\n&nbsp; item_17: [2510, 2610],\n&nbsp; item_18: [2630, 2730],\n&nbsp; item_19: [2750, 2850],\n&nbsp; item_20: [2870, 2970],\n&nbsp; item_21: [2990, 3090],\n&nbsp; item_22: [3110, 3210],\n&nbsp; item_23: [3230, 3330],\n&nbsp; item_24: [3350, 3450],\n&nbsp; item_25: [3470, 3570],\n&nbsp; item_26: [3590, 3690],\n&nbsp; item_27: [3710, 3810],\n&nbsp; item_28: [3830, 3930],\n&nbsp; item_29: [3950, 4050],\n&nbsp; item_30: [4070, 4170],\n&nbsp; item_31: [4190, 4290],\n&nbsp; item_32: [4310, 4410],\n&nbsp; item_33: [4430, 4530],\n&nbsp; item_34: [4550, 4650],\n&nbsp; item_35: [4670, 4770],\n&nbsp; item_36: [4790, 4890]\n};\n</code></pre><p>然后编写映射函数完成卡片类型的绑定，处理函数如下。在这个函数中，通过判断点击的y坐标值，就能确定点击的卡片类型。</p><pre><code class=\"language-javascript\">// 处理点击数据并为每个点击分配区域类型\nfunction assignClickCardType(clickData, regions) {\n&nbsp; clickData.forEach((click) =&gt; {\n&nbsp; &nbsp; const clickY = click.clickPosition.y;\n&nbsp; &nbsp; let foundRegion = null;\n\n&nbsp; &nbsp; for (const [regionName, [start, end]] of Object.entries(regions)) {\n&nbsp; &nbsp; &nbsp; if (clickY &gt;= start &amp;&amp; clickY &lt;= end) {\n&nbsp; &nbsp; &nbsp; &nbsp; foundRegion = regionName;\n&nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; click.clickCardType = foundRegion;\n&nbsp; });\n\n&nbsp; return clickData;\n}\n\n// 处理完成的数据结构\n// {\n// &nbsp; \"userId\": \"user_1\",\n// &nbsp; \"gender\": \"male\",\n// &nbsp; \"age\": 48,\n// &nbsp; \"clickTime\": \"2024-08-31T20:11:45.637Z\",\n// &nbsp; \"clickPosition\": {\n// &nbsp; &nbsp; \"x\": 319,\n// &nbsp; &nbsp; \"y\": 367\n// &nbsp; },\n// &nbsp; \"clickCardType\": null\n// }\n</code></pre><p>在下面算法的应用过程中，我们处理了生成的一排一UI结构和一排二UI结构的数据，为每条数据加上clickCradType字段，这么做是为了后续的对比试验做准备。为了方便，后面将一排一UI结构的数据描述为A数据，将一排二UI结构的数据描述为B数据。</p><p>好了，接下来我们就来进行算法的处理和分析吧。后面我们将分别从<strong>传统算法、机器学习算法、深度学习算法</strong>三个方面，选择了一些常用且适合我们需要的算法来演示与讲解。</p><p>这节课我们的重点是传统算法，后面两个方面的算法处理我们下节课再探讨。</p><h2>传统算法代表</h2><p>传统算法中，我们将会用到皮尔逊相关系数算法和&nbsp;Apriori 算法。</p><h3>皮尔逊相关系数</h3><p>皮尔逊相关系数是一种统计方法，用于衡量两个变量之间的线性相关性。是衡量两个变量之间线性关系强度和方向的统计量。其值范围从 -1 到 +1。</p><ul>\n<li>+1表示完全正相关，表示当一个变量增加时，另一个变量也相应增加。</li>\n<li>0表示无相关，表示两个变量之间没有线性关系。</li>\n<li>-1表示完全负相关，表示当一个变量增加时，另一个变量相应减少。</li>\n</ul><p>通过计算用户的年龄、性别与点击行为（如点击的卡片类型或位置）之间的相关性，我们可以观察到哪些用户属性对点击行为有显著影响。</p><p>在这个过程中，我们需要先完成数据的预处理，将数据中的性别、年龄和点击行为映射为数值特征，然后计算每个属性和点击行为之间的皮尔逊相关系数。</p><p>使用NodeJS来实现皮尔逊相关系数的代码如下：</p><pre><code class=\"language-javascript\">const fs = require('fs');\nconst math = require('mathjs');\n\n// 读取数据\nconst data = JSON.parse(fs.readFileSync('../data/onetwowithcardtype.json', 'utf-8'));\n\n// 定义所有的 clickCardType 区域\nconst regions = {\n&nbsp; bar: [0, 100],\n&nbsp; seckill: [150, 350],\n&nbsp; item_1: [370, 470],\n&nbsp; banner: [490, 590],\n&nbsp; item_2: [610, 710],\n&nbsp; item_3: [830, 930],\n&nbsp; item_4: [950, 1050],\n&nbsp; item_5: [1070, 1170],\n&nbsp; item_6: [1190, 1290],\n&nbsp; item_7: [1310, 1410],\n&nbsp; item_8: [1430, 1530],\n&nbsp; item_9: [1550, 1650],\n&nbsp; item_10: [1670, 1770],\n&nbsp; item_11: [1790, 1890],\n&nbsp; item_12: [1910, 2010],\n&nbsp; item_13: [2030, 2130],\n&nbsp; item_14: [2150, 2250],\n&nbsp; item_15: [2270, 2370],\n&nbsp; item_16: [2390, 2490],\n&nbsp; item_17: [2510, 2610],\n&nbsp; item_18: [2630, 2730],\n&nbsp; item_19: [2750, 2850],\n&nbsp; item_20: [2870, 2970],\n&nbsp; item_21: [2990, 3090],\n&nbsp; item_22: [3110, 3210],\n&nbsp; item_23: [3230, 3330],\n&nbsp; item_24: [3350, 3450],\n&nbsp; item_25: [3470, 3570],\n&nbsp; item_26: [3590, 3690],\n&nbsp; item_27: [3710, 3810],\n&nbsp; item_28: [3830, 3930],\n&nbsp; item_29: [3950, 4050],\n&nbsp; item_30: [4070, 4170],\n&nbsp; item_31: [4190, 4290],\n&nbsp; item_32: [4310, 4410],\n&nbsp; item_33: [4430, 4530],\n&nbsp; item_34: [4550, 4650],\n&nbsp; item_35: [4670, 4770],\n&nbsp; item_36: [4790, 4890]\n};\n\n// 将性别和年龄转换为数值\nconst numericData = data.map(({ gender, age, clickCardType }) =&gt; ({\n&nbsp; gender: gender === 'male' ? 0 : 1,\n&nbsp; age,\n&nbsp; ...Object.keys(regions).reduce((acc, key) =&gt; {\n&nbsp; &nbsp; acc[key] = clickCardType === key ? 1 : 0;\n&nbsp; &nbsp; return acc;\n&nbsp; }, {})\n}));\n\n// 计算皮尔逊相关系数\nconst pearsonCorrelation = (x, y) =&gt; {\n&nbsp; const meanX = math.mean(x);\n&nbsp; const meanY = math.mean(y);\n&nbsp; const numerator = math.sum(x.map((xi, i) =&gt; (xi - meanX) * (y[i] - meanY)));\n&nbsp; const denominator = Math.sqrt(\n&nbsp; &nbsp; math.sum(x.map(xi =&gt; (xi - meanX) ** 2)) * math.sum(y.map(yi =&gt; (yi - meanY) ** 2))\n&nbsp; );\n&nbsp; return numerator / denominator;\n};\n\n// 计算年龄和性别与每个 clickCardType 的相关性\nconst clickCardTypes = Object.keys(regions);\nconst correlations = clickCardTypes.reduce((acc, type) =&gt; {\n&nbsp; acc[type] = {\n&nbsp; &nbsp; ageCorrelation: pearsonCorrelation(\n&nbsp; &nbsp; &nbsp; numericData.map(d =&gt; d.age),\n&nbsp; &nbsp; &nbsp; numericData.map(d =&gt; d[type])\n&nbsp; &nbsp; ),\n&nbsp; &nbsp; genderCorrelation: pearsonCorrelation(\n&nbsp; &nbsp; &nbsp; numericData.map(d =&gt; d.gender),\n&nbsp; &nbsp; &nbsp; numericData.map(d =&gt; d[type])\n&nbsp; &nbsp; )\n&nbsp; };\n&nbsp; return acc;\n}, {});\n\n// 打印相关性结果\nclickCardTypes.forEach(type =&gt; {\n&nbsp; console.log(`Age-Click Correlation with ${type}:`, correlations[type].ageCorrelation);\n&nbsp; console.log(`Gender-Click Correlation with ${type}:`, correlations[type].genderCorrelation);\n});\n</code></pre><p>根据相关系数结果，我们可以了解年龄和性别对点击行为的影响，从而优化UI设计，比如针对不同年龄段的用户定制不同的UI布局。</p><p>将算法分别作用于A、B两组数据，就能得到对应的算法结果。因为结果比较长，后面我提供部分截图，你自己运行代码以后就可以看到全部结果了。</p><p><img src=\"https://static001.geekbang.org/resource/image/57/00/5732f7yy5a40b06928028yy876938700.jpg?wh=1323x910\" alt=\"\"></p><p>这个结论的推导过程需要了解皮尔逊相关系数，我这里也顺便补充一下。你也可以不必深究细节，只需要知道根据刚才的算法处理结果，可以发现年龄和性别对点击行为的影响比较小。</p><blockquote>\n<p>拓展知识点：皮尔逊相关系数，代表两个变量之间线性关系强度和方向的统计量。正数表示正相关，0表示无相关，-1表示负相关，范围是 -1 到 1。<br>\n<strong>　</strong><br>\n上图结果中可以看出，无论正负相关的数值基本都已经来到了小数点后的千分位或者更小的数值了，这就说明年龄和性别对点击行为的影响很小了。</p>\n</blockquote><p>理想状态是找到比较大的差异，这样后续的优化效果会更高。不过这里尽管影响比较小，根据微小的差异，还是可以提出一些优化点的，比如从这几个方面来优化：</p><ol>\n<li>可以考虑用户的年龄或性别，通过动态行为数据调整UI展示顺序；</li>\n<li>在特定卡片上优化色彩和设计以吸引目标用户；</li>\n<li>对性别有偏好的卡片进行布局调整；</li>\n<li>持续进行A/B测试并收集用户反馈，以基于数据进行优化。</li>\n</ol><p>需要注意的是，我们要确保优化过程中保持UI的多样性和包容性，避免偏见。</p><h3>Apriori算法</h3><p>其次是传统算法中的<strong>Apriori算法</strong>，这是一种广泛应用的算法，用来挖掘数据集中经常出现的数据项组合以及这些数据项组合之间关系规则。这个算法特别适合于事务型数据，例如购物篮分析。在电商页面点击数据的场景中，它可以帮助我们发现哪些用户属性（如性别和年龄）与某些点击行为（如点击某类型卡片）之间的关联。</p><p>在Apriori算法的算法原理中，有四个比较重要的概念需要我们掌握，它们是频繁项集、关联规则、支持度和置信度。</p><ul>\n<li>\n<p><strong>频繁项集</strong>是数据集中出现频率超过设定阈值的项组合。项是基本元素，比如对于商品来说，项集就是它们的集合。高支持度项集称为频繁项集。</p>\n</li>\n<li>\n<p><strong>关联规则</strong>用于揭示项集间的强关系，如点击了“item_1”的用户很可能也会点击 “item_2“。</p>\n</li>\n<li>\n<p><strong>支持度</strong>用来衡量项集或规则在数据中的普遍程度，即项集或规则出现的事务比例，高支持度表明常见。</p>\n</li>\n<li>\n<p><strong>置信度</strong>衡量关联规则的可靠性，即当前提发生时，结论发生的概率。高置信度表明规则可靠。</p>\n</li>\n</ul><p>了解了基础概念以后，我们再来看看Apriori算法的大致操作步骤。</p><ol>\n<li>\n<p><strong>生成候选项集</strong>：从数据中生成频繁 1-项集（每个单独的项），然后使用自底向上的方式生成更大项的候选项集。</p>\n</li>\n<li>\n<p><strong>剪枝</strong>：根据最小支持度阈值筛选候选项集，保留支持度大于等于阈值的项集。</p>\n</li>\n<li>\n<p><strong>生成频繁项集</strong>：从数据中筛选出经常一起出现的项组合。</p>\n</li>\n<li>\n<p><strong>生成关联规则</strong>：根据频繁项集生成可能的关联规则，并使用最小置信度阈值筛选有效的关联规则。</p>\n</li>\n</ol><p>同样我们可以使用NodeJ<s>S</s>实现Apriori算法，代码如下：</p><pre><code class=\"language-javascript\">const fs = require('fs');\nconst { Apriori } = require('node-apriori');\n\n// 读取 JSON 文件中的数据\nconst data = JSON.parse(fs.readFileSync('../data/onetwowithcardtype.json', 'utf-8'));\n\n// 转换数据格式：将每个用户的点击行为转化为一个事务\nconst transactions = data.map((entry) =&gt; {\n&nbsp; &nbsp; return [\n&nbsp; &nbsp; &nbsp; &nbsp; `userId_${entry.userId}`,\n&nbsp; &nbsp; &nbsp; &nbsp; `gender_${entry.gender}`,\n&nbsp; &nbsp; &nbsp; &nbsp; `age_${entry.age}`,\n&nbsp; &nbsp; &nbsp; &nbsp; `clickCardType_${entry.clickCardType}`\n&nbsp; &nbsp; ];\n});\n\n// 设置支持度阈值和置信度阈值\nconst support = 0.1;\n\n// 创建 Apriori 实例\nconst apriori = new Apriori(support);\n\n// 运行 Apriori 算法\napriori.exec(transactions)\n&nbsp; &nbsp; .then(result =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; console.log(`频繁项集：`, result.itemsets);\n\n&nbsp; &nbsp; &nbsp; &nbsp; // 计算关联规则\n&nbsp; &nbsp; &nbsp; &nbsp; const itemsets = result.itemsets;\n&nbsp; &nbsp; &nbsp; &nbsp; const rules = generateAssociationRules(itemsets, transactions, support);\n\n&nbsp; &nbsp; &nbsp; &nbsp; console.log(`关联规则：`, rules);\n&nbsp; &nbsp; })\n&nbsp; &nbsp; .catch(error =&gt; console.error('Apriori 执行出错:', error));\n\n// 生成关联规则的函数\nfunction generateAssociationRules(itemsets, transactions, minSupport) {\n&nbsp; &nbsp; const rules = [];\n\n&nbsp; &nbsp; itemsets.forEach(itemset =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; if (itemset.items.length &lt; 2) return;\n\n&nbsp; &nbsp; &nbsp; &nbsp; const subsets = getSubsets(itemset.items);\n\n&nbsp; &nbsp; &nbsp; &nbsp; subsets.forEach(subset =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const itemsetSubset = itemset.items.filter(item =&gt; !subset.includes(item));\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (itemsetSubset.length === 0) return;\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const subsetSupport = getSupport(subset, transactions);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const itemsetSupport = itemset.support;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const confidence = itemsetSupport / subsetSupport;\n\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (confidence &gt;= minSupport) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rules.push({\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; antecedent: subset,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; consequent: itemsetSubset,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; support: itemsetSupport / transactions.length,\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; confidence: confidence\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; });\n&nbsp; &nbsp; });\n\n&nbsp; &nbsp; return rules;\n}\n\nfunction getSubsets(items) {\n&nbsp; &nbsp; const subsets = [];\n&nbsp; &nbsp; const length = items.length;\n\n&nbsp; &nbsp; for (let i = 1; i &lt; (1 &lt;&lt; length); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; const subset = [];\n&nbsp; &nbsp; &nbsp; &nbsp; for (let j = 0; j &lt; length; j++) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (i &amp; (1 &lt;&lt; j)) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subset.push(items[j]);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; subsets.push(subset);\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; return subsets;\n}\n\nfunction getSupport(itemset, transactions) {\n&nbsp; &nbsp; let count = 0;\n&nbsp; &nbsp; transactions.forEach(transaction =&gt; {\n&nbsp; &nbsp; &nbsp; &nbsp; if (itemset.every(item =&gt; transaction.includes(item))) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; });\n&nbsp; &nbsp; return count;\n}\n</code></pre><p>分别作用于A数据和B数据，算法输出如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/8e/b1/8edaf57108a155f6eae03b4cfd631eb1.jpg?wh=1627x947\" alt=\"\"></p><p>分析了对比结果之后，不难得出这样一些优化策略。</p><ul>\n<li>\n<p>尽管性别对卡片类型点击影响较小，但可以在初始展示时保持界面一致，之后根据用户行为进行微调，测试个性化效果。</p>\n</li>\n<li>\n<p>提升 item_2 的可见性，将最受欢迎的 item_2 放在显眼位置，并在不同设备上保持突出展示，增加类似内容以提升用户参与度。</p>\n</li>\n<li>\n<p>突出秒杀活动，尤其针对女性用户，通过弹窗、倒计时等方式强调秒杀活动，对男性用户测试其他促销策略。</p>\n</li>\n<li>\n<p>新老用户策略：新用户展示多样化内容，老用户提供定制化推荐，提升用户粘性和转化率。</p>\n</li>\n</ul><p>通过使用 Apriori 算法，我们可以从用户点击数据中挖掘出有价值的模式和关联，为优化电商 H5 页面设计和用户体验提供依据。这种方法特别适用于<strong>发现不同用户群体的偏好和行为模式</strong>，有助于进行精细化的用户运营和个性化推荐。</p><h2>总结</h2><p>我们来做个总结吧！</p><p>在这节课中，为了更好地适配算法，我们对数据进行了预处理，在原有数据基础上将用户的点击位置与Feeds对应的卡片类型做了匹配绑定。这样就能将用户的点击位置和Feeds流中具体的卡片对应起来了。</p><p>然后，我们选择了皮尔逊系数和 Apriori 两种传统算法来对数据进行处理分析。皮尔逊系数是一种统计方法，用于衡量两个变量之间的线性相关性，我们可以用它来了解年龄和性别对点击行为的影响，从而优化UI设计，比如针对不同年龄段的用户定制不同的UI布局。</p><p>Apriori算法，这是一种广泛应用的算法，用来挖掘数据集中经常出现的数据项组合以及这些数据项组合之间关系规则，我们可以用它来发现用户属性（如性别和年龄）与点击行为（如点击某类型卡片）之间的关联。它同样可以用来优化UI设计。</p><h2>思考题</h2><p>这节课中，我们选择了 皮尔逊和 Apriori 两种传统算法来进行实验，那么，除此之外还有哪些适合课程实验数据结构和内容的传统算法呢？</p><p>欢迎你在留言区分享你的思考或疑问，如果这节课对你有启发，别忘了分享给身边更多朋友。</p>","comments":[]}