{"id":506682,"title":"35 | 用Kotlin写一个GitHub Trending App","content":"<p>你好，我是朱涛。</p><p>这节课，我们一起来用Kotlin和Jetpack写一个简单的Android应用。为了便于理解，这个应用的功能会尽量简单，即使你对Android不是特别熟悉，跟着课程的引导，你也能轻松完成。</p><h2>准备工作</h2><p>在之前的课程中，我们的实战项目都是基于JVM的，并没有涉及过Android相关的配置。因此，如果你的电脑没有Android开发的环境的话，那么可能需要做一些额外的配置。当然，在你已有Java环境的前提下，想要配置Android开发环境并不麻烦，你可以去搜索一些相关的<a href=\"https://www.google.com/search?q=Android+%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE\">Android开发环境配置</a>的教程。</p><p>那么，要进行Android开发，我们可以使用IntelliJ，也可以使用Android Studio，后者针对Android开发做了很多定制化，也是免费的，这里我也建议你去下载Android Studio。</p><p>当配置好所有的环境以后，我们就可以像创建Kotlin工程一样，来创建一个新的Android工程了。</p><p><img src=\"https://static001.geekbang.org/resource/image/f9/00/f9f6b73c7a09bac3ae5b3e15ff997000.gif?wh=900x650\" alt=\"图片\"></p><p>然后，当你创建好工程以后，就可以尝试运行代码了，这时候你大概率会看到一个Hello World的初始界面。</p><p>接下来，我们就正式进入开发吧。</p><h2>MVVM架构</h2><p>Android应用的架构，在过去的这些年里一直都在变化。最开始的Android其实没有什么明确的架构，大家习惯于把所有代码都往Activity里放，直到后来才开始有了MVC、MVP以及MVVM。</p><!-- [[[read_end]]] --><p>那么，站在现在这个时间节点上，当前Android中比较主流、比较受Google推崇的，是MVVM架构。这节课，我们就以 <strong>MVVM架构</strong>为基础，并且也尝试<strong>结合Clean架构</strong>来进行一些实践。</p><p>关于MVVM架构，它其实就是代表了Model — View — ViewModel，如果将其对应到Android当中来的话，它们之间大概会是这样的关系：</p><p><img src=\"https://static001.geekbang.org/resource/image/41/04/416e9447d2cfbe726154c25b6317f404.png?wh=771x232\" alt=\"图片\"></p><p>MVVM其实是一种广泛存在的架构模式，在Android当中也有类似的实现。ViewModel会连接View和Model，View和Model之间是隔离开的。而View和ViewModel之间，也往往会存在数据绑定，这里的数据绑定可以是一个组件（如Android的DataBinding），也可以是由代码来完成绑定。</p><p>而相比MVVM架构，Clean架构则是一种更加抽象的思维模式了。它将整个架构大致分为三层，由外到内分别是：表现层、领域层、数据层。它们之间的依赖关系也是由外到内的。</p><p><img src=\"https://static001.geekbang.org/resource/image/ae/0a/ae182ae3b475ff0289ce3653db6ec70a.png?wh=1656x1216\" alt=\"图片\"></p><p>不过 <strong>Clean架构只是一种思想</strong>，当我们尝试在Android中落地应用的时候，其实并不一定会完全按照这里的架构图来设计，目前比较常见的架构是下面这样的：</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/b2/5aa98ff8962f90dd47b479fee303dcb2.png?wh=928x687\" alt=\"图片\"></p><p>可以看到，上面这个架构，融入了MVVM与Clean两个架构的特点，让我们从下往上看：</p><ul>\n<li><strong>实体层</strong>，这里其实就是我们平时定义的一些Bean的实体类，用Kotlin的数据类即可。</li>\n<li><strong>数据层</strong>，这里一般会有两个概念，分别是DataSource与Repository，前者代表数据源，后者代表数据仓库。数据源一般会区分本地数据源和远程数据源，而数据仓库则会统筹它们两者。</li>\n<li><strong>领域层</strong>，这里一般会是一些相对具体一些的业务逻辑。</li>\n<li><strong>表现层</strong>，这里则是接近UI展示的上层逻辑了。</li>\n</ul><p>好，架构分析完了，接下来我们看看代码该怎么写，我们还是按照架构的分层，从下往上来实现。</p><h3>实体层</h3><p>首先，我们要定义一个密封类，来统一不同情况下的数据形式。</p><pre><code class=\"language-plain\">sealed class ResultX&lt;out R: Any&gt; {\n\n    data class Success&lt;out T: Any&gt;(val data: T) : ResultX&lt;T&gt;()\n    data class Error(val exception: Exception) : ResultX&lt;Nothing&gt;()\n    object Loading : ResultX&lt;Nothing&gt;()\n\n    override fun toString(): String {\n        return when (this) {\n            is Success&lt;*&gt; -&gt; \"Success[data=$data]\"\n            is Error -&gt; \"Error[exception=$exception]\"\n            Loading -&gt; \"Loading\"\n        }\n    }\n}\n</code></pre><p>这里，我们利用密封类和泛型，将数据的成功、失败、加载中都统一了起来。类似这样的做法，我们在课程的<a href=\"https://time.geekbang.org/column/article/473349\">第2讲</a>里也已经提到过了。</p><p>然后，由于我们是要实现一个GitHub Trending的应用，所以这里我们只需要找一个开源的API，通过分析它的JSON结构，然后定义出具体的Data Class就行了。这一步，我们其实在<a href=\"https://time.geekbang.org/column/article/481787\">第12讲</a>当中就已经完成了。</p><pre><code class=\"language-plain\">data class RepoList(\n    var count: Int?,\n    var items: List&lt;Repo&gt;?,\n    var msg: String?\n)\n\ndata class Repo(\n    var added_stars: String?,\n    var avatars: List&lt;String&gt;?,\n    var desc: String?,\n    var forks: String?,\n    var lang: String?,\n    var repo: String?,\n    var repo_link: String?,\n    var stars: String?\n)\n</code></pre><p>不过，在之前的课程当中，我提到过以这种方式定义的数据类，其实还存在2个问题。</p><ul>\n<li>问题1：不符合“不变性思维”，成员属性全部都是var定义的。</li>\n<li>问题2：不符合“空安全思维”，所有的类型都是可为空的。</li>\n</ul><p>那么针对这两个问题，我们像下面这样做，其实很容易就能搞定：</p><pre><code class=\"language-plain\">data class RepoList(\n    val count: Int = 0,\n    val items: List&lt;Repo&gt; = listOf(),\n    val msg: String = \"数据为空\"\n)\n\ndata class Repo(\n    val added_stars: String = \"\",\n    val avatars: List&lt;String&gt; = listOf(),\n    val desc: String = \"\",\n    val forks: String = \"\",\n    val lang: String = \"\",\n    val repo: String = \"\",\n    val repo_link: String = \"\",\n    val stars: String = \"\"\n)\n</code></pre><p>在这段代码中，我们是把var都替换成了val，把所有的可空类型都改成了不可空类型，同时也为属性都提供了默认值。</p><p>当然，仅仅只是改变底层的实体类的定义还远远不够，具体遇到的问题，我们会在后面分析。下面我们接着来看数据层。</p><h3>数据层</h3><p>在数据层当中，最关键的就是RepoDataSource和Repository。那么首先，我们就要定义它们对应的接口。你可以参考这里的实现：</p><pre><code class=\"language-plain\">interface RepoDataSource {\n    suspend fun getRepos(): ResultX&lt;RepoList&gt;\n}\n\ninterface IRepository {\n    suspend fun getRepoList(): ResultX&lt;RepoList&gt;\n}\n</code></pre><p>接下来，就是它们对应的实现类了，我们先来看看数据源怎么处理。</p><p>由于我们需要请求网络，所以这里我们自然就会想到OkHttp和Retrofit了。虽然我们也可以使用自己写的KtHttp，但它毕竟只是用于学习和研究目的而编写的，并不适合真的拿来用。</p><pre><code class=\"language-plain\">object RetrofitClient {\n\n    private const val TAG = \"OkHttp\"\n    private const val BASE_URL = \"https://baseUrl.com/\"\n    private const val TIME_OUT = 10\n\n    val moshi: Moshi by lazy {\n        Moshi.Builder()\n            .add(KotlinJsonAdapterFactory())\n            .build()\n    }\n\n    val service by lazy { getService(RepoService::class.java, BASE_URL) }\n\n    private val client: OkHttpClient by lazy {\n        val builder = OkHttpClient.Builder()\n        builder.connectTimeout(TIME_OUT.toLong(), TimeUnit.SECONDS)\n        builder.build()\n    }\n\n    private fun &lt;S&gt; getService(\n        serviceClass: Class&lt;S&gt;,\n        baseUrl: String,\n        client: OkHttpClient = this.client\n    ): S {\n        return Retrofit.Builder()\n            .client(client)\n            .addConverterFactory(MoshiConverterFactory.create(moshi))\n            .baseUrl(baseUrl)\n            .build().create(serviceClass)\n    }\n}\n\ninterface RepoService {\n    @GET(\"repo\")\n    suspend fun repos(@Query(\"lang\") lang: String = \"Kotlin\", @Query(\"since\") since: String = \"weekly\"): RepoList\n}\n</code></pre><p>其实，当我们自己手写了KtHttp的源码以后，Retrofit用起来就会非常顺手。这里我们是定义了一个单例RetrofitClient用来请求API，还有RepoService来代表具体的请求参数规则。</p><p>那么有了Retrofit以后，我们要处理数据源也就很容易了。</p><pre><code class=\"language-plain\">object RemoteRepoDataSource : RepoDataSource {\n    const val TAG = \"RemoteRepoDataSource\"\n    override suspend fun getRepos(): ResultX&lt;RepoList&gt; =\n        withContext(Dispatchers.IO) {\n            try {\n                Success(RetrofitClient.service.repos())\n            } catch (e: Exception) {\n                Log.e(TAG, e.message, e)\n                Error(e)\n            }\n        }\n}\n</code></pre><p>在这里，我们定义了一个RemoteRepoDataSource，它实现了RepoDataSource这个数据源的接口。而它具体的实现方法，是使用withContext{} 将API请求分发到了IO线程池，然后根据实际的运行结果，将数据封装成对应的ResultX的子类型。</p><p>接着就是数据仓库了，它一般是用于统筹缓存数据、远程数据的，这里为了不引入过多的复杂度，我们简单来实现：</p><pre><code class=\"language-plain\">class MainRepository(\n    private val dataSource: RepoDataSource = RemoteRepoDataSource,\n    private val localDataSource: RepoDataSource? = null\n) : IRepository {\n    override suspend fun getRepoList(): ResultX&lt;RepoList&gt; {\n        // 暂不处理缓存逻辑\n        return dataSource.getRepos()\n    }\n}\n</code></pre><p>你可以看到，它其实就是数据源的一层封装而已。</p><p>好，至此，我们的数据层就已经完成了。</p><h3>领域层</h3><p>所谓领域层，其实就像是业务逻辑的一个小单元，这里的小单元，我们可以将其称为UseCase。</p><pre><code class=\"language-plain\">class GetRepoListUseCase(private val repository: IRepository = MainRepository()) {\n    suspend operator fun invoke(): ResultX&lt;RepoList&gt; {\n        return repository.getRepoList()\n    }\n}\n</code></pre><p>在当前的案例中，我们只有一个业务场景，也就是获取GitHub仓库的列表，所以这个UseCase的逻辑也很简单。不过你要知道，在实际的工作场景中，UseCase是可以承载复杂的业务逻辑的。</p><p>接下来，我们往上看一下表现层。</p><h3>表现层</h3><p>到了表现层这里，我们其实就已经非常接近UI了，具体来说，这里主要涉及到ViewModel还有Activity、Fragment。我们先来看看ViewModel。</p><pre><code class=\"language-plain\">class MainViewModel(\n    val getRepoListUseCase: GetRepoListUseCase = GetRepoListUseCase()\n) : ViewModel() {\n    val repos: LiveData&lt;RepoList&gt;\n        get() = _repos\n    private val _repos = MutableLiveData&lt;RepoList&gt;()\n\n    fun loadRepos() {\n        viewModelScope.launch {\n            val result = getRepoListUseCase()\n            when (result) {\n                is ResultX.Success -&gt; {\n                    _repos.value = result.data\n                }\n                is ResultX.Error -&gt; {\n                    _repos.value = RepoList()\n                }\n                ResultX.Loading -&gt; {\n                    // 展示Loading\n                }\n            }\n        }\n    }\n}\n</code></pre><p>可以看到，我们在ViewModel当中定义了一组LiveData，并且针对它的读写做了限制，这一点，我们在讲<a href=\"https://time.geekbang.org/column/article/484631\">不变性思维</a>的时候提到过。</p><p>在loadRepos()这个方法中，我们用到了viewModelScope.launch {} 来启动协程。经过上节课的学习，我们知道以这种方式启动的协程是不会发生泄漏的，其中的协程任务会随着Activity的销毁而取消。</p><p>OK，最后，就是Activity当中的逻辑了。</p><pre><code class=\"language-plain\">class MainActivity : AppCompatActivity() {\n    // 1\n    private val viewModel: MainViewModel by viewModels()\n    // 2\n    private lateinit var binding: ActivityMainBinding\n\n    private lateinit var adapter: RepoAdapter\n    private val layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        viewModel.loadRepos()\n        observeData()\n    }\n\n    private fun observeData() {\n        // 3\n        viewModel.repos.observe(this) {\n            display(it)\n        }\n    }\n\n    private fun display(repoList: RepoList) {\n        adapter = RepoAdapter(repoList)\n        binding.recycler.layoutManager = layoutManager\n        binding.recycler.adapter = adapter\n    }\n}\n</code></pre><p>上面Activity的逻辑也很简单，其中有几个注释，我们一起来看看：</p><ul>\n<li>注释1，这里我们使用了委托的语法，将ViewModel的创建交给了\"by viewModels()\"。它其实是Activity的一个扩展函数，是由KTX实现的。</li>\n<li>注释2，ActivityMainBinding，这里我们使用了Jetpack当中的ViewBinding，这样我们就不用写烦人的findViewById()了。</li>\n<li>注释3，viewModel.repos.observe{}，这里我们完成了ViewModel当中LiveData的数据监听，当我们的网络请求有结果以后，它就会立刻被回调。</li>\n</ul><p>另外，以上代码中还涉及到了一些RecyclerView相关的适配器逻辑，也非常简单：</p><pre><code class=\"language-plain\">class RepoAdapter(private val repoList: RepoList): RecyclerView.Adapter&lt;RepoHolder&gt;() {\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RepoHolder {\n        return RepoHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_repo, parent, false))\n    }\n\n    override fun onBindViewHolder(holder: RepoHolder, position: Int) {\n        holder.text.text = repoList.items.getOrNull(position)?.repo\n    }\n\n    override fun getItemCount(): Int = repoList.count\n}\n\nclass RepoHolder(itemView: View): RecyclerView.ViewHolder(itemView) {\n    val text : TextView = itemView.findViewById(R.id.text)\n}\n</code></pre><p>也就是，为了让RecyclerView正确展示数据，我们需要实现一些方法，以上这些都是一些模板代码。</p><p>最后，在运行代码之前，我们还需要给App增加一个网络权限。</p><pre><code class=\"language-plain\">&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n</code></pre><p>这个时候，如果你在模拟器或者真机上运行的话，就会看到类似这样的一个效果：</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/0b/9d1b8168691b7b59a0dbf30cecbbbd0b.gif?wh=271x576\" alt=\"\"></p><p>那么，到这里，我们的代码是不是就写完了呢？其实并没有。</p><h2>空安全</h2><p>因为，我们还有一个问题没有解决：<strong>如果服务端返回的JSON字段是null的话，我们的程序仍然会出错。</strong>具体来说，我们可以用这个单元测试来模拟。</p><pre><code class=\"language-plain\">@Test\nfun test() {\n    //                  强行返回null\n    //                      ↓\n    val json = \"\"\"{\"repo\": null, \"repo_link\": \"https://github.com/JetBrains/kotlin\", \"desc\": \"The Kotlin Programming Language.\", \"lang\": \"Kotlin\", \"stars\": \"40,907\", \"forks\": \"5,067\", \"added_stars\": \"98 stars this week\", \"avatars\": [\"https://avatars.githubusercontent.com/u/292714?s=40&amp;v=4\", \"https://avatars.githubusercontent.com/u/1127631?s=40&amp;v=4\", \"https://avatars.githubusercontent.com/u/908958?s=40&amp;v=4\", \"https://avatars.githubusercontent.com/u/3007027?s=40&amp;v=4\", \"https://avatars.githubusercontent.com/u/888318?s=40&amp;v=4\"]}\"\"\"\n    val repo = RetrofitClient.moshi.adapter(Repo::class.java).fromJson(json)\n    println(repo?.repo)\n}\n\n/*\n报错：\nNon-null value 'repo' was null at $.repo at com.squareup.moshi.internal.Util\n*/\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/30/36/30b3bbf89b59c957801b1f75454a3236.gif?wh=1200x850\" alt=\"图片\"></p><p>其实，当我们利用<a href=\"https://time.geekbang.org/column/article/484921\">空安全思维</a>，将Repo中所有的成员都定义成“非空类型”以后，当API不返回某个字段的时候，程序是可以自动填充默认值的。但是，当API强行在接口当中返回null的时候，我们的程序还是会崩溃。</p><p>为了解决这个问题，我们需要为JSON解析框架Moshi，配置一个额外的规则：</p><pre><code class=\"language-plain\">object NullStringAdapter {\n    @FromJson\n    fun fromJson(reader: JsonReader): String {\n        if (reader.peek() != JsonReader.Token.NULL) {\n            return reader.nextString()\n        }\n        reader.nextNull&lt;Unit&gt;()\n        return \"\"\n    }\n\n    @ToJson\n    fun toJson(writer: JsonWriter, value: String?) {\n        writer.value(value)\n    }\n}\n</code></pre><p>这个Adapter，其实就是在服务端返回null的时候，我们做一层兼容，将其替换成默认值。它的用法也很简单：</p><pre><code class=\"language-plain\">object RetrofitClient {\n\n    // 省略\n\n    val moshi: Moshi by lazy {\n        Moshi.Builder()\n            .add(NullStringAdapter) // 变化在这里\n            .add(KotlinJsonAdapterFactory())\n            .build()\n    }\n\n}\n</code></pre><p>这样，当我们把这个Adapter配置到Moshi当中以后，单元测试就可以正常通过了。</p><p><img src=\"https://static001.geekbang.org/resource/image/19/88/197d46d4fe35edf1babbd0a9b15ff388.gif?wh=1198x822\" alt=\"图片\"></p><h2>小结</h2><p>好，这节课的内容到这里就差不多结束了。让我们来做一个简单的总结。</p><ul>\n<li>MVVM，是一种常见的架构模式，在Android当中，一般会借助ViewModel、LiveData之类的组件来实现。在实战当中，我们还可以将其跟Clean架构的思想相结合，将整体应用的架构分为四层：实体层、数据层、领域层、表现层。</li>\n<li>实体层，在大部分架构设计当中，实体层会和数据层进行融合，不过在这节课当中，我们将其单独抽了出来，放在了整个架构的最底层，通过密封类、数据类来实现的。</li>\n<li>数据层，这里有两个概念，分别是“数据源”和“数据仓库”。数据源一般会分为缓存数据与远程数据，数据仓库则负责统筹多种数据源。</li>\n<li>领域层，这里会涉及到业务逻辑的最小单元，我们一般将其称为UseCase。</li>\n<li>表现层，这里会涉及到数据与UI交互的逻辑。ViewModel当中会封装UseCase，并且持有数据和View进行交互。</li>\n<li>最后，我们还根据实际情况，对JSON解析库Moshi，做了额外配置，让它可以对服务端返回null的时候，仍然保持兼容，不会出现空指针异常。</li>\n</ul><p>那么，如果你本身对Android、MVVM、Clean架构都不是很熟悉，也许在学习这节课的过程中会有点不太适应。这时候，你可以去GitHub下载本课程对应的Demo，来实际运行和调试，以加深印象，链接在<a href=\"https://github.com/chaxiu/GitHubTrending.git\">这里</a>。</p><h2>思考题</h2><p>这节课，我们融合MVVM和Clean完成了一种混合架构，请问这种架构有什么样的优点和缺点呢？</p>","neighbors":{"left":{"article_title":"34 | Kotlin与Jetpack简直是天生一对！","id":505790},"right":{"article_title":"结课测试 | “Kotlin编程第一课”100分试卷等你来挑战！","id":507617}},"comments":[{"had_liked":false,"id":342766,"user_name":"百里路海","can_delete":false,"product_type":"c1","uid":1329412,"ip_address":"","ucode":"90AB7AE440978A","user_header":"https://static001.geekbang.org/account/avatar/00/14/49/04/152ecd3f.jpg","comment_is_top":false,"comment_ctime":1650451848,"is_pvip":false,"replies":[{"id":"125278","content":"这里取决于你是否需要通过Loading来传递数据，如果不需要传递的话，为了节省内容，全局使用同一个内存对象，这会更好一些。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1650553142,"ip_address":"","comment_id":342766,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18830321032","product_id":100103401,"comment_content":"实体层中的密封类定义中，Loading为什么用 object 而不是 data class，之前也在其他地方看过这种用法，没理解是有什么特别含义还是二者皆可混用，还请解惑。","like_count":5,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565894,"discussion_content":"这里取决于你是否需要通过Loading来传递数据，如果不需要传递的话，为了节省内容，全局使用同一个内存对象，这会更好一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650553142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341729,"user_name":"魏全运","can_delete":false,"product_type":"c1","uid":1090798,"ip_address":"","ucode":"3FED702C724E2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/a4/ee/cffd8ee6.jpg","comment_is_top":false,"comment_ctime":1649810896,"is_pvip":false,"replies":[{"id":"124963","content":"赞~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649952986,"ip_address":"","comment_id":341729,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10239745488","product_id":100103401,"comment_content":"MVVM+Clean架构的组合使得原先在VM里的数据处理逻辑转移到了usecase，这样VM的逻辑更加精简且清晰，并且由于clean架构的引入，数据层的代码将更加可测。但是，clean架构的缺点也很明显：代码臃肿、结构复杂。实际项目中很少会使用clean架构来实现一个业务模块。","like_count":3,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563242,"discussion_content":"赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649952986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344708,"user_name":"飓风","can_delete":false,"product_type":"c1","uid":1006197,"ip_address":"","ucode":"18D4E8139CD7B7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5a/75/4e0d7419.jpg","comment_is_top":false,"comment_ctime":1651732966,"is_pvip":false,"replies":[{"id":"125928","content":"“不知道还有没有其他好的方案可以对viewmodel做单元测试”，有的，只是比较麻烦，三言两语很难说清楚，你可以去看看官方文档。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1652024522,"ip_address":"","comment_id":344708,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5946700262","product_id":100103401,"comment_content":"usecase的好处感觉可以单元测试，一般我都是省去了直接在viewmodel单独定义一个suspend方法用来做单元测试，不知道还有没有其他好的方案可以对viewmodel做单元测试","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571000,"discussion_content":"“不知道还有没有其他好的方案可以对viewmodel做单元测试”，有的，只是比较麻烦，三言两语很难说清楚，你可以去看看官方文档。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652024522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344686,"user_name":"sunlight","can_delete":false,"product_type":"c1","uid":1684437,"ip_address":"","ucode":"9E8251F9281183","user_header":"https://static001.geekbang.org/account/avatar/00/19/b3/d5/93b704b6.jpg","comment_is_top":false,"comment_ctime":1651723198,"is_pvip":false,"replies":[{"id":"125930","content":"没有标准，但大部分情况是一一对应。viewModel可以跟Activity一一对应，也可以跟Fragment一一对应。但涉及到共用逻辑的时候，同一个viewModel可以对应多个Fragment、甚至多个Activity。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1652024653,"ip_address":"","comment_id":344686,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5946690494","product_id":100103401,"comment_content":"想请教下老师，一般view中对应一个viewModel还是多个viewModel，这个有统一标准吗","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571002,"discussion_content":"没有标准，但大部分情况是一一对应。viewModel可以跟Activity一一对应，也可以跟Fragment一一对应。但涉及到共用逻辑的时候，同一个viewModel可以对应多个Fragment、甚至多个Activity。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652024654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2250483,"avatar":"https://static001.geekbang.org/account/avatar/00/22/56/f3/85d08ac6.jpg","nickname":"格子","note":"","ucode":"AC43A48A0F5A5B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":576237,"discussion_content":"老师，对于同一个viewModel可以对应多个Fragment、Activity 的情况，怎么在多个 Fragment 或者 Activity 中获取同一个 viewModel 实例呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655364202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":571002,"ip_address":""},"score":576237,"extra":""},{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2250483,"avatar":"https://static001.geekbang.org/account/avatar/00/22/56/f3/85d08ac6.jpg","nickname":"格子","note":"","ucode":"AC43A48A0F5A5B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592121,"discussion_content":"我在项目中是同一个viewModel同时对应一个Activity和一个Fragment，直接引用就可以了啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667130433,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":576237,"ip_address":"河北"},"score":592121,"extra":""}]}]},{"had_liked":false,"id":342855,"user_name":"Geek_Adr","can_delete":false,"product_type":"c1","uid":2876897,"ip_address":"","ucode":"129E17B7D3EB88","user_header":"https://static001.geekbang.org/account/avatar/00/2b/e5/e1/a5064f88.jpg","comment_is_top":false,"comment_ctime":1650508508,"is_pvip":false,"replies":[{"id":"125280","content":"很棒的答案，赞~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1650553183,"ip_address":"","comment_id":342855,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5945475804","product_id":100103401,"comment_content":"我理解 解决复杂问题通用方法就是拆分或者说是分层，不管是MVVM或是Clean都是分层方法的一种，如何选择主要看复杂度。MVP或MVVM 可以理解为UI交互与业务逻辑 对等复杂度的分法，MVVM与Clean混合架构更重业务逻辑轻UI交互的分法，所以优点：应用在复杂业务场景合适，缺点：分层本身就需要理解，带来额外复杂度。HelloWorld 直写就好","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565896,"discussion_content":"很棒的答案，赞~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650553183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341783,"user_name":"杨小妞","can_delete":false,"product_type":"c1","uid":1657434,"ip_address":"","ucode":"DF5AE317301023","user_header":"https://static001.geekbang.org/account/avatar/00/19/4a/5a/14eb7973.jpg","comment_is_top":false,"comment_ctime":1649832086,"is_pvip":false,"replies":[{"id":"124960","content":"是的，这个理解很不错。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649952096,"ip_address":"","comment_id":341783,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5944799382","product_id":100103401,"comment_content":"个人理解：对于数据处理不是很复杂的场景，UseCase一般用得很少，直接在vm完成数据请求处理然后就抛出去了。<br>有一个设想，对于UI很复杂的页面，将其粗略拆分成上、中、下三个Delegate（包含UI+业务），这样Activity任务处理就能减轻不少。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563237,"discussion_content":"是的，这个理解很不错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649952096,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341719,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1649804726,"is_pvip":false,"replies":[{"id":"124962","content":"很棒的见解~Android的测试部分确实比较难，以后我会找机会在我的博客里分享的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649952949,"ip_address":"","comment_id":341719,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5944772022","product_id":100103401,"comment_content":"MVVM和Clean架构的融合，相对于原来逻辑都在Activity里，实现了较好的分层，单元测试也容易多了。相对于MVP架构，MVVM架构避免了presenter和view里面来回穿梭的调用，简化了逻辑，而且得到谷歌较好的支持。MVVM架构在Android系统中的问题是，Andorid应用多是UI重度型应用，UI中的逻辑太多，分层解决的主要是非UI部分的代码，对于UI部分的分层，方法论层面就没有系统的支持，实践中的自动化测试也很不方便。Jetpack Compose在一定程度上，提供了UI模块化的解决方案，但是自动化测试也远比非UI的单元测试要复杂。这方面我不太熟，期待老师将来的精彩讲解。<br>","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563241,"discussion_content":"很棒的见解~Android的测试部分确实比较难，以后我会找机会在我的博客里分享的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649952950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1005842,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/59/12/2034b163.jpg","nickname":"Android 技师","note":"","ucode":"F7691906C86655","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":564845,"discussion_content":"老师开门课吧，这方面绝大多数的人都不熟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650340012,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":563241,"ip_address":""},"score":564845,"extra":""}]}]},{"had_liked":false,"id":350460,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1500061,"ip_address":"","ucode":"31E35EFE05E0B0","user_header":"","comment_is_top":false,"comment_ctime":1656923972,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1656923972","product_id":100103401,"comment_content":"这个实战项目能给出git地址查看代码吗","like_count":0,"discussions":[{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592122,"discussion_content":"思考题上面的链接地址没看到？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667130561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350456,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1173761,"ip_address":"","ucode":"D1B972C9164641","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/01/2885812b.jpg","comment_is_top":false,"comment_ctime":1656922639,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656922639","product_id":100103401,"comment_content":"如果这个 NULL 对应到我们的实体类的字段是 Int，Boolean，另一个对象 时，就需要写多个 NullXXXAdapter 么？","like_count":0},{"had_liked":false,"id":346020,"user_name":"sunlight","can_delete":false,"product_type":"c1","uid":1684437,"ip_address":"","ucode":"9E8251F9281183","user_header":"https://static001.geekbang.org/account/avatar/00/19/b3/d5/93b704b6.jpg","comment_is_top":false,"comment_ctime":1652772280,"is_pvip":false,"replies":[{"id":"126597","content":"那就来看看我的技术博客吧：“朱涛的自习室”。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1653818395,"ip_address":"","comment_id":346020,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1652772280","product_id":100103401,"comment_content":"还有其他这么好的Android课程推荐么，这门课程收获很多。最近没东西看了。。","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574063,"discussion_content":"那就来看看我的技术博客吧：“朱涛的自习室”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653818395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344106,"user_name":"Geek_12f95b","can_delete":false,"product_type":"c1","uid":1162671,"ip_address":"","ucode":"D32E215DDD2685","user_header":"","comment_is_top":false,"comment_ctime":1651244939,"is_pvip":false,"replies":[{"id":"125935","content":"基本上都是PPT做的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1652025862,"ip_address":"","comment_id":344106,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651244939","product_id":100103401,"comment_content":"老师，问下你这个架构图 用啥软件画的呀","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571010,"discussion_content":"基本上都是PPT做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652025862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341761,"user_name":"ZircoN","can_delete":false,"product_type":"c1","uid":1033848,"ip_address":"","ucode":"E665DF0DBB7381","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c6/78/9b1e4b15.jpg","comment_is_top":false,"comment_ctime":1649824541,"is_pvip":false,"replies":[{"id":"124958","content":"是的，简单业务场景就显得有些多余。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649951725,"ip_address":"","comment_id":341761,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1649824541","product_id":100103401,"comment_content":"usecase google推荐是封装复杂逻辑或者逻辑复用时使用，正常情况如上面例子是可以去掉这一层的。","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563230,"discussion_content":"是的，简单业务场景就显得有些多余。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649951726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}