{"id":500420,"title":"29 | Dispatchers是如何工作的？","content":"<p>你好，我是朱涛。今天，我们来分析Kotlin协程当中的Dispatchers。</p><p>上节课里，我们分析了launch的源代码，从中我们知道，Kotlin的launch会调用startCoroutineCancellable()，接着又会调用createCoroutineUnintercepted()，最终会调用编译器帮我们生成SuspendLambda实现类当中的create()方法。这样，协程就创建出来了。不过，协程是创建出来了，可它是如何运行的呢？</p><p>另外我们也都知道，协程无法脱离线程运行，Kotlin当中所有的协程，最终都是运行在线程之上的。<strong>那么，协程创建出来以后，它又是如何跟线程产生关联的？</strong>这节课，我们将进一步分析launch的启动流程，去发掘上节课我们忽略掉的代码分支。</p><p>我相信，经过这节课的学习，你会对协程与线程之间的关系有一个更加透彻的认识。</p><h2>Dispatchers</h2><p>在上节课里我们学习过，launch{}本质上是调用了startCoroutineCancellable()当中的createCoroutineUnintercepted()方法创建了协程。</p><pre><code class=\"language-plain\">// 代码段1\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {\n    //                                        注意这里\n    //                                           ↓\n    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))\n}\n</code></pre><!-- [[[read_end]]] --><p>那么下面，我们就接着上节课的流程，继续分析createCoroutineUnintercepted(completion)之后的 <strong>intercepted()方法</strong>。</p><p>不过，在正式分析intercepted()之前，我们还需要弄清楚Dispatchers、CoroutineDispatcher、ContinuationInterceptor、CoroutineContext之间的关系。</p><pre><code class=\"language-plain\">// 代码段2\n\npublic actual object Dispatchers {\n\n    public actual val Default: CoroutineDispatcher = DefaultScheduler\n\n    public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher\n\n    public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined\n\n    public val IO: CoroutineDispatcher = DefaultIoScheduler\n\n    public fun shutdown() {    }\n}\n\npublic abstract class CoroutineDispatcher :\n    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {}\n\npublic interface ContinuationInterceptor : CoroutineContext.Element {}\n\npublic interface Element : CoroutineContext {}\n</code></pre><p>在<a href=\"https://time.geekbang.org/column/article/488571\">第17讲</a>当中，我们曾经分析过它们之间的继承关系。Dispatchers是一个单例对象，它当中的Default、Main、Unconfined、IO，类型都是CoroutineDispatcher，而它本身就是CoroutineContext。所以，它们之间的关系就可以用下面这个图来描述。</p><p><img src=\"https://static001.geekbang.org/resource/image/2c/d1/2cf4c3c45b6f6838e5fyy16a4fce02d1.jpg?wh=2000x1125\" alt=\"\"></p><p>让我们结合这张图，来看看下面这段代码：</p><pre><code class=\"language-plain\">// 代码段3\n\nfun main() {\n    testLaunch()\n    Thread.sleep(2000L)\n}\n\nprivate fun testLaunch() {\n    val scope = CoroutineScope(Job())\n    scope.launch{\n        logX(\"Hello!\")\n        delay(1000L)\n        logX(\"World!\")\n    }\n}\n\n/**\n * 控制台输出带协程信息的log\n */\nfun logX(any: Any?) {\n    println(\n        \"\"\"\n================================\n$any\nThread:${Thread.currentThread().name}\n================================\"\"\".trimIndent()\n    )\n}\n\n/*\n输出结果\n================================\nHello!\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n================================\nWorld!\nThread:DefaultDispatcher-worker-1 @coroutine#1\n================================\n*/\n</code></pre><p>在这段代码中，我们没有为launch()传入任何CoroutineContext参数，但通过执行结果，我们发现协程代码居然执行在DefaultDispatcher，并没有运行在main线程之上。这是为什么呢？</p><p>我们可以回过头来分析下launch的源代码，去看看上节课中我们刻意忽略的地方。</p><pre><code class=\"language-plain\">// 代码段4\n\npublic fun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    start: CoroutineStart = CoroutineStart.DEFAULT,\n    block: suspend CoroutineScope.() -&gt; Unit\n): Job {\n    // 1\n    val newContext = newCoroutineContext(context)\n    val coroutine = if (start.isLazy)\n        LazyStandaloneCoroutine(newContext, block) else\n        StandaloneCoroutine(newContext, active = true)\n    coroutine.start(start, coroutine, block)\n    return coroutine\n}\n</code></pre><p>首先，请留意launch的第一个参数，context，它的默认值是EmptyCoroutineContext。在第17讲里，我曾提到过，CoroutineContext就相当于Map，而EmptyCoroutineContext则相当于一个空的Map。所以，我们可以认为，这里的EmptyCoroutineContext传了也相当于没有传，它的目的只是为了让context参数不为空而已。<strong>这其实也体现出了Kotlin的空安全思维，Kotlin官方用EmptyCoroutineContext替代了null。</strong></p><p>接着，请留意上面代码的注释1，这行代码会调用newCoroutineContext(context)，将传入的context参数重新包装一下，然后返回。让我们看看它具体的逻辑：</p><pre><code class=\"language-plain\">// 代码段5\n\npublic actual fun CoroutineScope.newCoroutineContext(context: CoroutineContext): CoroutineContext {\n    // 1\n    val combined = coroutineContext.foldCopiesForChildCoroutine() + context\n    // 2\n    val debug = if (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) else combined\n    // 3\n    return if (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == null)\n        debug + Dispatchers.Default else debug\n}\n</code></pre><p>这段代码一共有三个注释，我们来分析一下：</p><ul>\n<li>注释1，由于newCoroutineContext()是CoroutineScope的扩展函数，因此，我们可以直接访问CoroutineScope的coroutineContext对象，它其实就是CoroutineScope对应的上下文。foldCopiesForChildCoroutine()的作用，其实就是将CoroutineScope当中的所有上下文元素都拷贝出来，然后跟传入的context参数进行合并。<strong>这行代码，可以让子协程继承父协程的上下文元素。</strong></li>\n<li>注释2，它的作用是在调试模式下，为我们的协程对象增加唯一的ID。我们在代码段3的输出结果中看到的“@coroutine#1”，其中的数字“1”就是在这个阶段生成的。</li>\n<li>注释3，如果合并过后的combined当中没有CoroutineDispatcher，那么，就会默认使用Dispatchers.Default。</li>\n</ul><p>看到这里，你也许会有一个疑问，为什么协程默认的线程池是Dispatchers.Default，而不是Main呢？答案其实也很简单，因为Kotlin协程是支持多平台的，<strong>Main线程只在UI编程平台才有可用</strong>。因此，当我们的协程没有指定Dispatcher的时候，就只能使用Dispatchers.Default了。毕竟，协程是无法脱离线程执行的。</p><p>那么现在，代码段3当中的协程执行在Dispatchers.Default的原因也就找到了：由于我们定义的scope没有指定Dispatcher，同时launch的参数也没有传入Dispatcher，最终在newCoroutineContext()的时候，会被默认指定为Default线程池。</p><p>好，有了前面的基础以后，接下来，我们就可以开始intercepted()的逻辑了。</p><h2>CoroutineDispatcher拦截器</h2><p>让我们回到课程开头提到过的startCoroutineCancellable()方法的源代码，其中的createCoroutineUnintercepted()方法，我们在上节课已经分析过了，它的返回值类型就是\u0010Continuation。而<strong>intercepted()方法，其实就是Continuation的扩展函数</strong>。</p><pre><code class=\"language-plain\">// 代码段6\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {\n    //                                        注意这里\n    //                                           ↓\n    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))\n}\n\n\npublic actual fun &lt;T&gt; Continuation&lt;T&gt;.intercepted(): Continuation&lt;T&gt; =\n    (this as? ContinuationImpl)?.intercepted() ?: this\n\ninternal abstract class ContinuationImpl(\n    completion: Continuation&lt;Any?&gt;?,\n    private val _context: CoroutineContext?\n) : BaseContinuationImpl(completion) {\n    constructor(completion: Continuation&lt;Any?&gt;?) : this(completion, completion?.context)\n\n    @Transient\n    private var intercepted: Continuation&lt;Any?&gt;? = null\n\n    // 1\n    public fun intercepted(): Continuation&lt;Any?&gt; =\n        intercepted\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted = it }\n}\n</code></pre><p>从上面的代码中，我们可以看到，startCoroutineCancellable()当中的intercepted()最终会调用BaseContinuationImpl的intercepted()方法。</p><p>这里，请你留意代码中我标记出的注释，intercepted()方法首先会判断它的成员变量 <strong>intercepted是否为空</strong>，如果为空，就会调用context[ContinuationInterceptor]，获取上下文当中的Dispatcher对象。以代码段3当中的逻辑为例，这时候的Dispatcher肯定是Default线程池。</p><p>然后，如果我们继续跟进interceptContinuation(this)方法的话，会发现程序最终会调用CoroutineDispatcher的interceptContinuation()方法。</p><pre><code class=\"language-plain\">// 代码段7\n\npublic abstract class CoroutineDispatcher :\n    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n\n    // 1\n    public final override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; =\n        DispatchedContinuation(this, continuation)\n}\n</code></pre><p>同样留意下这里的注释1，interceptContinuation()直接返回了一个DispatchedContinuation对象，并且将this、continuation作为参数传了进去。这里的this，其实就是Dispatchers.Default。</p><p>所以，如果我们把startCoroutineCancellable()改写一下，它实际上会变成下面这样：</p><pre><code class=\"language-plain\">// 代码段8\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {\n    createCoroutineUnintercepted(completion).intercepted().resumeCancellableWith(Result.success(Unit))\n}\n\n// 等价\n//  ↓\n\npublic fun &lt;T&gt; (suspend () -&gt; T).startCoroutineCancellable(completion: Continuation&lt;T&gt;): Unit = runSafely(completion) {\n    // 1\n    val continuation = createCoroutineUnintercepted(completion)\n    // 2\n    val dispatchedContinuation = continuation.intercepted()\n    // 3\n    dispatchedContinuation.resumeCancellableWith(Result.success(Unit))\n}\n</code></pre><p>在上面的代码中，注释1，2我们都已经分析完了，现在只剩下注释3了。这里的resumeCancellableWith()，其实就是真正将协程任务分发到线程上的逻辑。让我们继续跟进分析源代码：</p><pre><code class=\"language-plain\">// 代码段9\n\ninternal class DispatchedContinuation&lt;in T&gt;(\n    @JvmField val dispatcher: CoroutineDispatcher,\n    @JvmField val continuation: Continuation&lt;T&gt;\n) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation {\n\n    inline fun resumeCancellableWith(\n        result: Result&lt;T&gt;,\n        noinline onCancellation: ((cause: Throwable) -&gt; Unit)?\n    ) {\n        // 省略，留到后面分析\n    }\n\n}\n</code></pre><p>也就是，DispatchedContinuation是实现了Continuation接口，同时，它使用了“类委托”的语法，将接口的具体实现委托给了它的成员属性continuation。通过之前代码段7的分析，我们知道它的成员属性 <strong>dispatcher对应的就是Dispatcher.Default</strong>，而成员属性 <strong>continuation对应的则是launch当中传入的SuspendLambda实现类</strong>。</p><p>另外，DispatchedContinuation还继承自DispatchedTask，我们来看看DispatchedTask到底是什么。</p><pre><code class=\"language-plain\">internal abstract class DispatchedTask&lt;in T&gt;(\n    @JvmField public var resumeMode: Int\n) : SchedulerTask() {\n\n}\n\ninternal actual typealias SchedulerTask = Task\n\ninternal abstract class Task(\n    @JvmField var submissionTime: Long,\n    @JvmField var taskContext: TaskContext\n) : Runnable {\n    constructor() : this(0, NonBlockingContext)\n    inline val mode: Int get() = taskContext.taskMode // TASK_XXX\n}\n</code></pre><p>可以看到，DispatchedContinuation继承自DispatchedTask，而它则是SchedulerTask的子类，SchedulerTask是Task的类型别名，而Task实现了Runnable接口。因此，<strong>DispatchedContinuation不仅是一个Continuation，同时还是一个Runnable。</strong></p><p>那么，既然它是Runnable，也就意味着它可以被分发到Java的线程当中去执行了。所以接下来，我们就来看看resumeCancellableWith()当中具体的逻辑：</p><pre><code class=\"language-plain\">// 代码段9\n\ninternal class DispatchedContinuation&lt;in T&gt;(\n    @JvmField val dispatcher: CoroutineDispatcher,\n    @JvmField val continuation: Continuation&lt;T&gt;\n) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation {\n\n    inline fun resumeCancellableWith(\n        result: Result&lt;T&gt;,\n        noinline onCancellation: ((cause: Throwable) -&gt; Unit)?\n    ) {\n        val state = result.toState(onCancellation)\n        // 1\n        if (dispatcher.isDispatchNeeded(context)) {\n            _state = state\n            resumeMode = MODE_CANCELLABLE\n            // 2\n            dispatcher.dispatch(context, this)\n        } else {\n            // 3\n            executeUnconfined(state, MODE_CANCELLABLE) {\n                if (!resumeCancelled(state)) {\n                    resumeUndispatchedWith(result)\n                }\n            }\n        }\n    }\n\n}\n\npublic abstract class CoroutineDispatcher :\n    AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n    // 默认是true\n    public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true\n\n    public abstract fun dispatch(context: CoroutineContext, block: Runnable)\n}\n\ninternal object Unconfined : CoroutineDispatcher() {\n    // 只有Unconfined会重写成false\n    override fun isDispatchNeeded(context: CoroutineContext): Boolean = false\n}\n</code></pre><p>这段代码里也有三个注释，我们来分析一下：</p><ul>\n<li>注释1，dispatcher.isDispatchNeeded()，通过查看CoroutineDispatcher的源代码，我们发现它的返回值始终都是true。在它的子类当中，只有Dispatchers.Unconfined会将其重写成false。这也就意味着，除了Unconfined以外，其他的Dispatcher都会返回true。对于我们代码段3当中的代码而言，我们的Dispatcher是默认的Default，所以，代码将会进入注释2对应的分支。</li>\n<li>注释2，dispatcher.dispatch(context, this)，这里其实就相当于将代码的执行流程分发到Default线程池。dispatch()的第二个参数要求是Runnable，这里我们传入的是this，这是因为DispatchedContinuation本身就间接实现了Runnable接口。</li>\n<li>注释3，executeUnconfined{}，它其实就对应着Dispather是Unconfined的情况，这时候，协程的执行不会被分发到别的线程，而是直接在当前线程执行。</li>\n</ul><p>接下来，让我们继续沿着注释2进行分析，这里的dispatcher.dispatch()其实就相当于调用了Dispatchers.Default.dispatch()。让我们看看它的逻辑：</p><pre><code class=\"language-plain\">public actual object Dispatchers {\n\n    @JvmStatic\n    public actual val Default: CoroutineDispatcher = DefaultScheduler\n}\n\ninternal object DefaultScheduler : SchedulerCoroutineDispatcher(\n    CORE_POOL_SIZE, MAX_POOL_SIZE,\n    IDLE_WORKER_KEEP_ALIVE_NS, DEFAULT_SCHEDULER_NAME\n) {}\n</code></pre><p>那么，从上面的代码中，我们可以看到，<strong>Dispatchers.Default本质上是一个单例对象DefaultScheduler</strong>，它是SchedulerCoroutineDispatcher的子类。<br>\n我们也来看看SchedulerCoroutineDispatcher的源代码：</p><pre><code class=\"language-plain\">internal open class SchedulerCoroutineDispatcher(\n    private val corePoolSize: Int = CORE_POOL_SIZE,\n    private val maxPoolSize: Int = MAX_POOL_SIZE,\n    private val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,\n    private val schedulerName: String = \"CoroutineScheduler\",\n) : ExecutorCoroutineDispatcher() {\n\n    private var coroutineScheduler = createScheduler()\n\n    override fun dispatch(context: CoroutineContext, block: Runnable): Unit = coroutineScheduler.dispatch(block)\n}\n</code></pre><p>根据以上代码，我们可以看到Dispatchers.Default.dispatch()最终会调用SchedulerCoroutineDispatcher的dispatch()方法，而它实际上调用的是coroutineScheduler.dispatch()。</p><p>这里，我们同样再来看看CoroutineScheduler的源代码：</p><pre><code class=\"language-plain\">internal class CoroutineScheduler(\n    @JvmField val corePoolSize: Int,\n    @JvmField val maxPoolSize: Int,\n    @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS,\n    @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME\n) : Executor, Closeable {\n\n    override fun execute(command: Runnable) = dispatch(command)\n\n    fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) {\n        trackTask() \n        // 1\n        val task = createTask(block, taskContext)\n        // 2\n        val currentWorker = currentWorker()\n        // 3\n        val notAdded = currentWorker.submitToLocalQueue(task, tailDispatch)\n        if (notAdded != null) {\n            if (!addToGlobalQueue(notAdded)) {\n\n                throw RejectedExecutionException(\"$schedulerName was terminated\")\n            }\n        }\n        val skipUnpark = tailDispatch &amp;&amp; currentWorker != null\n\n        if (task.mode == TASK_NON_BLOCKING) {\n            if (skipUnpark) return\n            signalCpuWork()\n        } else {\n\n            signalBlockingWork(skipUnpark = skipUnpark)\n        }\n    }\n\n    private fun currentWorker(): Worker? = (Thread.currentThread() as? Worker)?.takeIf { it.scheduler == this }\n\n    // 内部类 Worker\n    internal inner class Worker private constructor() : Thread() {\n    }\n}\n</code></pre><p>你发现了吗？CoroutineScheduler其实是Java并发包下的Executor的子类，它的execute()方法也被转发到了dispatch()。</p><p>上面的代码里也有三个注释，我们分别来看看：</p><ul>\n<li>注释1，将传入的Runnable类型的block（也就是DispatchedContinuation），包装成Task。</li>\n<li>注释2，currentWorker()，拿到当前执行的线程。这里的Worker其实是一个内部类，它本质上仍然是Java的Thread。</li>\n<li>注释3，currentWorker.submitToLocalQueue()，将当前的Task添加到Worker线程的本地队列，等待执行。</li>\n</ul><p>那么接下来，我们就来分析下Worker是如何执行Task的。</p><pre><code class=\"language-plain\">internal inner class Worker private constructor() : Thread() {\n\n    override fun run() = runWorker()\n\n    @JvmField\n    var mayHaveLocalTasks = false\n\n    private fun runWorker() {\n        var rescanned = false\n        while (!isTerminated &amp;&amp; state != WorkerState.TERMINATED) {\n            // 1\n            val task = findTask(mayHaveLocalTasks)\n\n            if (task != null) {\n                rescanned = false\n                minDelayUntilStealableTaskNs = 0L\n                // 2\n                executeTask(task)\n                continue\n            } else {\n                mayHaveLocalTasks = false\n            }\n\n            if (minDelayUntilStealableTaskNs != 0L) {\n                if (!rescanned) {\n                    rescanned = true\n                } else {\n                    rescanned = false\n                    tryReleaseCpu(WorkerState.PARKING)\n                    interrupted()\n                    LockSupport.parkNanos(minDelayUntilStealableTaskNs)\n                    minDelayUntilStealableTaskNs = 0L\n                }\n                continue\n            }\n\n            tryPark()\n        }\n        tryReleaseCpu(WorkerState.TERMINATED)\n    }\n}\n</code></pre><p>实际上，Worker会重写Thread的run()方法，然后把执行流程交给runWorker()，以上代码里有两个关键的地方，我也用注释标记了。</p><ul>\n<li>注释1，在while循环当中，会一直尝试从Worker的本地队列取Task出来，如果存在需要执行的Task，就会进入下一步。</li>\n<li>注释2，executeTask(task)，其实就是执行对应的Task。</li>\n</ul><p>而接下来的逻辑，就是<strong>最关键的部分</strong>了：</p><pre><code class=\"language-plain\">internal inner class Worker private constructor() : Thread() {\n    private fun executeTask(task: Task) {\n        val taskMode = task.mode\n        idleReset(taskMode)\n        beforeTask(taskMode)\n        // 1\n        runSafely(task)\n        afterTask(taskMode)\n    }\n}\n\nfun runSafely(task: Task) {\n    try {\n        // 2\n        task.run()\n    } catch (e: Throwable) {\n        val thread = Thread.currentThread()\n        thread.uncaughtExceptionHandler.uncaughtException(thread, e)\n    } finally {\n        unTrackTask()\n    }\n}\n\ninternal abstract class Task(\n    @JvmField var submissionTime: Long,\n    @JvmField var taskContext: TaskContext\n) : Runnable {\n    constructor() : this(0, NonBlockingContext)\n    inline val mode: Int get() = taskContext.taskMode // TASK_XXX\n}\n</code></pre><p>在Worker的executeTask()方法当中，会调用runSafely()方法，而在这个方法当中，最终会调用task.run()。前面我们就提到过 <strong>Task本质上就是Runnable，而Runnable.run()其实就代表了我们的协程任务真正执行了！</strong></p><p>那么，task.run()具体执行的代码是什么呢？其实它是执行的 <strong>DispatchedTask.run()</strong>。这里的DispatchedTask实际上是DispatchedContinuation的父类。</p><pre><code class=\"language-plain\">internal class DispatchedContinuation&lt;in T&gt;(\n    @JvmField val dispatcher: CoroutineDispatcher,\n    @JvmField val continuation: Continuation&lt;T&gt;\n) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation {\n\n    public final override fun run() {\n\n        val taskContext = this.taskContext\n        var fatalException: Throwable? = null\n        try {\n            val delegate = delegate as DispatchedContinuation&lt;T&gt;\n            val continuation = delegate.continuation\n            withContinuationContext(continuation, delegate.countOrElement) {\n                val context = continuation.context\n                val state = takeState() \n                val exception = getExceptionalResult(state)\n\n                val job = if (exception == null &amp;&amp; resumeMode.isCancellableMode) context[Job] else null\n                if (job != null &amp;&amp; !job.isActive) {\n                    // 1\n                    val cause = job.getCancellationException()\n                    cancelCompletedResult(state, cause)\n                    continuation.resumeWithStackTrace(cause)\n                } else {\n                    if (exception != null) {\n                        // 2\n                        continuation.resumeWithException(exception)\n                    } else {\n                        // 3\n                        continuation.resume(getSuccessfulResult(state))\n                    }\n                }\n            }\n        } catch (e: Throwable) {\n\n            fatalException = e\n        } finally {\n            val result = runCatching { taskContext.afterTask() }\n            handleFatalException(fatalException, result.exceptionOrNull())\n        }\n    }\n}\n</code></pre><p>上面的代码有三个关键的注释，我们一起来分析：</p><ul>\n<li>注释1，在协程代码执行之前，它首先会判断当前协程是否已经取消。如果已经取消的话，就会调用continuation.resumeWithStackTrace(cause)将具体的原因传出去。</li>\n<li>注释2，判断协程是否发生了异常，如果已经发生了异常，则需要调用continuation.resumeWithException(exception)将异常传递出去。</li>\n<li>注释3，如果一切正常，则会调用continuation.resume(getSuccessfulResult(state))，这时候，协程才会正式启动，并且执行launch当中传入的Lambda表达式。</li>\n</ul><p>最后，按照惯例，我还是制作了一个视频，来向你展示整个Dispather的代码执行流程。</p><p><video poster=\"https://media001.geekbang.org/60e32fba628c47b299b6d8e7a80f8379/snapshots/ee285063538d488da66a8986948e5e10-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/2310ea02-17fd4a64006-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/67b93afae3c942789649155c1fb4bb34/846224bcab894329a030dbe0ef087544-af4fd499cd27e74109eba82f17247037-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>小结</h2><p>这节课，我们围绕着launch，着重分析了它的Dispatchers执行流程。Dispatchers是协程框架中与线程交互的关键，这里面主要涉及以下几个步骤：</p><ul>\n<li>第一步，createCoroutineUnintercepted(completion)创建了协程的Continuation实例，紧接着就会调用它的intercepted()方法，将其封装成DispatchedContinuation对象。</li>\n<li>第二步，DispatchedContinuation会持有CoroutineDispatcher、以及前面创建的Continuation对象。课程中的CoroutineDispatcher实际上就是Default线程池。</li>\n<li>第三步，执行DispatchedContinuation的resumeCancellableWith()方法，这时候，就会执行dispatcher.dispatch()，这就会将协程的Continuation封装成Task添加到Worker的本地任务队列，等待执行。这里的Worker本质上就是Java的Thread。<strong>在这一步，协程就已经完成了线程的切换</strong>。</li>\n<li>第四步，Worker的run()方法会调用runWork()，它会从本地的任务队列当中取出Task，并且调用task.run()。而它实际上调用的是DispatchedContinuation的run()方法，在这里，会调用continuation.resume()，它将执行原本launch当中生成的SuspendLambda子类。<strong>这时候，launch协程体当中的代码，就在线程上执行了</strong>。</li>\n</ul><h2>思考题</h2><p>经过这节课的学习以后，请问你是否对协程的本质有了更深入的认识？请讲讲你的心得体会吧！</p>","comments":[{"had_liked":false,"id":340077,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1648586257,"is_pvip":false,"replies":[{"id":"124482","content":"“协程的重点不在线程，而在线程之外的调度，异常处理和状态机。”这句话总结很到位。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648814243,"ip_address":"","comment_id":340077,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18828455441","product_id":100103401,"comment_content":"Kotlin在开启协程状态机之前做了大量的工作，从父协程那里继承了状态，重新设定了子协程运行线程，检查了各种异常情况，区分了程序异常和协程cancel的情况，最终在指定的线程里启动了状态机。协程的重点不在线程，而在线程之外的调度，异常处理和状态机。<br>","like_count":5,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559555,"discussion_content":"“协程的重点不在线程，而在线程之外的调度，异常处理和状态机。”这句话总结很到位。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648814243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340231,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1127306,"ip_address":"","ucode":"3F69DAC14260DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","comment_is_top":false,"comment_ctime":1648688796,"is_pvip":false,"replies":[{"id":"124474","content":"是的。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648813752,"ip_address":"","comment_id":340231,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10238623388","product_id":100103401,"comment_content":"协程本质上是对线程的封装，我们在使用协程的时候，并不需要直接与线程打交道，直接使用 Coroutine 提供的相关 API 以同步的方式就可以间接完成与线程之间的交互。","like_count":3,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559547,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648813752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340115,"user_name":"7Promise","can_delete":false,"product_type":"c1","uid":2879220,"ip_address":"","ucode":"BF7C7F042E51F3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/f4/27a5080a.jpg","comment_is_top":false,"comment_ctime":1648609044,"is_pvip":false,"replies":[{"id":"124478","content":"是的~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648814135,"ip_address":"","comment_id":340115,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10238543636","product_id":100103401,"comment_content":"kotlin的协程与java线程密不可分，协程最终是运行在线程中的Task。","like_count":3,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559551,"discussion_content":"是的~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648814135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342223,"user_name":"黑色毛衣","can_delete":false,"product_type":"c1","uid":1135912,"ip_address":"","ucode":"FF7E235F91BA5C","user_header":"https://static001.geekbang.org/account/avatar/00/11/55/28/31b0cf2f.jpg","comment_is_top":false,"comment_ctime":1650110940,"is_pvip":false,"replies":[{"id":"125112","content":"这个问题三言两语很难解释清楚了，给你个方向吧，你可以这样去做：<br><br>写一个简单的Demo，然后用课程当中的方法，去研究协程恢复之后的代码执行流程。其实，协程的基本元素理解透彻以后，协程的源码读起来就不是那么费力了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1650296850,"ip_address":"","comment_id":342223,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5945078236","product_id":100103401,"comment_content":"如果挂起后，再恢复，是如何恢复到之前的线程的呢？？<br><br>这个线程的是如何保存的呢？？","like_count":2,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564699,"discussion_content":"这个问题三言两语很难解释清楚了，给你个方向吧，你可以这样去做：\n\n写一个简单的Demo，然后用课程当中的方法，去研究协程恢复之后的代码执行流程。其实，协程的基本元素理解透彻以后，协程的源码读起来就不是那么费力了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650296850,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340099,"user_name":"Allen","can_delete":false,"product_type":"c1","uid":1127306,"ip_address":"","ucode":"3F69DAC14260DC","user_header":"https://static001.geekbang.org/account/avatar/00/11/33/8a/f7a3d5e6.jpg","comment_is_top":false,"comment_ctime":1648602726,"is_pvip":false,"replies":[{"id":"124468","content":"是的，笔误了，感谢指出来了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648805300,"ip_address":"","comment_id":340099,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648602726","product_id":100103401,"comment_content":"这里，请你留意代码中我标记出的注释，intercepted() 方法首先会判断它的成员变量 intercepted 是否为空，如果不为空，就会调用 context[ContinuationInterceptor]，获取上下文当中的 Dispatcher 对象。以代码段 3 当中的逻辑为例，这时候的 Dispatcher 肯定是 Default 线程池。<br><br>涛哥，这里应该是 intercepted 为空才会调用 context[ContinuationInterceptor] 吧？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559526,"discussion_content":"是的，笔误了，感谢指出来了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648805300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}