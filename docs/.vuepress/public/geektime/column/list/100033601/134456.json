{"id":134456,"title":"16 | WebAPI：setTimeout是如何实现的？","content":"<p>在<a href=\"https://time.geekbang.org/column/article/132931\">上一篇文章</a>中我们介绍了页面中的事件和消息队列，知道了<strong>浏览器页面是由消息队列和事件循环系统来驱动的</strong>。</p><p>那在接下来的两篇文章中，我会通过<strong>setTimeout</strong>和<strong>XMLHttpRequest</strong>这两个WebAPI来介绍事件循环的应用。这两个WebAPI是两种不同类型的应用，比较典型，并且在JavaScript中的使用频率非常高。你可能觉得它们太简单、太基础，但有时候恰恰是基础简单的东西才最重要，了解它们是如何工作的会有助于你写出更加高效的前端代码。</p><p>本篇文章主要介绍的是<strong>setTimeout</strong>。其实说起setTimeout方法，从事开发的同学想必都不会陌生，它就是一个<strong>定时器，用来指定某个函数在多少毫秒之后执行</strong>。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。下面的示例代码就演示了定时器最基础的使用方式：</p><pre><code>function showName(){\n  console.log(&quot;极客时间&quot;)\n}\nvar timerID = setTimeout(showName,200);\n</code></pre><p>执行上述代码，输出的结果也很明显，通过setTimeout指定在200毫秒之后调用showName函数，并输出“极客时间”四个字。</p><p>简单了解了setTimeout的使用方法后，那接下来我们就来看看浏览器是如何实现定时器的，然后再介绍下定时器在使用过程中的一些注意事项。</p><!-- [[[read_end]]] --><h2>浏览器怎么实现setTimeout</h2><p>要了解定时器的工作原理，就得先来回顾下之前讲的事件循环系统，我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。下面我们来看看那些典型的事件：</p><ul>\n<li>当接收到HTML文档数据，渲染引擎就会将“解析DOM”事件添加到消息队列中，</li>\n<li>当用户改变了Web页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。</li>\n<li>当触发了JavaScript引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。</li>\n<li>同样，如果要执行一段异步JavaScript代码，也是需要将执行任务添加到消息队列中。</li>\n</ul><p>以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。</p><p>所以说要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。</p><p>那么该怎么设计才能让定时器设置的回调事件在规定时间内被执行呢？你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？</p><p>在Chrome中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和Chromium内部一些需要延迟执行的任务。所以当通过JavaScript创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中。</p><p>如果感兴趣，你可以参考<a href=\"https://cs.chromium.org/chromium/src/base/task/sequence_manager/task_queue_impl.h\">Chromium中关于队列部分的源码</a>。</p><p>源码中延迟执行队列的定义如下所示：</p><pre><code> DelayedIncomingQueue delayed_incoming_queue;\n</code></pre><p>当通过JavaScript调用setTimeout设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数showName、当前发起时间、延迟执行时间，其模拟代码如下所示：</p><pre><code>struct DelayTask{\n  int64 id；\n  CallBackFunction cbf;\n  int start_time;\n  int delay_time;\n};\nDelayTask timerTask;\ntimerTask.cbf = showName;\ntimerTask.start_time = getCurrentTime(); //获取当前时间\ntimerTask.delay_time = 200;//设置延迟执行时间\n</code></pre><p>创建好回调任务之后，再将该任务添加到延迟执行队列中，代码如下所示：</p><pre><code>delayed_incoming_queue.push(timerTask)；\n</code></pre><p>现在通过定时器发起的任务就被保存到延迟队列中了，那接下来我们再来看看消息循环系统是怎么触发延迟队列的。</p><p>我们可以来完善<a href=\"https://time.geekbang.org/column/article/132931\">上一篇文章</a>中消息循环的代码，在其中加入执行延迟队列的代码，如下所示：</p><pre><code>void ProcessTimerTask(){\n  //从delayed_incoming_queue中取出已经到期的定时器任务\n  //依次执行这些任务\n}\n\nTaskQueue task_queue；\nvoid ProcessTask();\nbool keep_running = true;\nvoid MainTherad(){\n  for(;;){\n    //执行消息队列中的任务\n    Task task = task_queue.takeTask();\n    ProcessTask(task);\n    \n    //执行延迟队列中的任务\n    ProcessDelayTask()\n\n    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环\n        break; \n  }\n}\n</code></pre><p>从上面代码可以看出来，我们添加了一个<strong>ProcessDelayTask函数</strong>，该函数是专门用来处理延迟执行任务的。这里我们要重点关注它的执行时机，在上段代码中，处理完消息队列中的一个任务之后，就开始执行ProcessDelayTask函数。ProcessDelayTask函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。</p><p>设置一个定时器，JavaScript引擎会返回一个定时器的ID。那通常情况下，当一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用<strong>clearTimeout函数</strong>，并传入需要取消的定时器的ID。如下面代码所示：</p><pre><code>clearTimeout(timer_id)\n</code></pre><p>其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从delayed_incoming_queue延迟队列中，通过ID查找到对应的任务，然后再将其从队列中删除掉就可以了。</p><h2>使用setTimeout的一些注意事项</h2><p>现在你应该知道在浏览器内部定时器是如何工作的了。不过在使用定时器的过程中，如果你不了解定时器的一些细节，那么很有可能掉进定时器的一些陷阱里。所以接下来，我们就来讲解一下在使用定时器过程中存在的那些陷阱。</p><h3>1. 如果当前任务执行时间过久，会影响定时器任务的执行</h3><p>在使用setTimeout的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。我们先看下面这段代码：</p><pre><code>function bar() {\n    console.log('bar')\n}\nfunction foo() {\n    setTimeout(bar, 0);\n    for (let i = 0; i &lt; 5000; i++) {\n        let i = 5+8+8+8\n        console.log(i)\n    }\n}\nfoo()\n</code></pre><p>这段代码中，在执行foo函数的时候使用setTimeout设置了一个0延时的回调任务，设置好回调任务后，foo函数会继续执行5000次for循环。</p><p>通过setTimeout设置的回调任务被放入了消息队列中并且等待下一次执行，这里并不是立即执行的；要执行消息队列中的下个任务，需要等待当前的任务执行完成，由于当前这段代码要执行5000次的for循环，所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。</p><p>你也可以打开Performance来看看其执行过程，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/1a/4f/1adf4da8ca4315cfb565e798649bd74f.png?wh=1142*497\" alt=\"\"></p><center><span class=\"reference\">长任务导致定时器被延后执行</span></center><p>从图中可以看到，执行foo函数所消耗的时长是500毫秒，这也就意味着通过setTimeout设置的任务会被推迟到500毫秒以后再去执行，而设置setTimeout的回调延迟时间是0。</p><h3>2. 如果setTimeout存在嵌套调用，那么系统会设置最短时间间隔为4毫秒</h3><p>也就是说在定时器函数里面嵌套调用定时器，也会延长定时器的执行时间，可以先看下面的这段代码：</p><pre><code>function cb() { setTimeout(cb, 0); }\nsetTimeout(cb, 0);\n</code></pre><p>上述这段代码你有没有看出存在什么问题？</p><p>你还是可以通过Performance来记录下这段代码的执行过程，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/cb/cd/cbb3b2b1ac8eb4752a585df5445412cd.png?wh=1084*398\" alt=\"\"></p><center><span class=\"reference\">循环嵌套调用setTimeout</span></center><p>上图中的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是4毫秒。之所以出现这样的情况，是因为在Chrome中，定时器被嵌套调用5次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于4毫秒，那么浏览器会将每次调用的时间间隔设置为4毫秒。下面是<a href=\"https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/frame/dom_timer.cc\">Chromium实现4毫秒延迟的代码</a>，你可以看下：</p><pre><code>static const int kMaxTimerNestingLevel = 5;\n\n// Chromium uses a minimum timer interval of 4ms. We'd like to go\n// lower; however, there are poorly coded websites out there which do\n// create CPU-spinning loops.  Using 4ms prevents the CPU from\n// spinning too busily and provides a balance between CPU spinning and\n// the smallest possible interval timer.\nstatic constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4);\n</code></pre><pre><code>base::TimeDelta interval_milliseconds =\n      std::max(base::TimeDelta::FromMilliseconds(1), interval);\n\n  if (interval_milliseconds &lt; kMinimumInterval &amp;&amp;\n      nesting_level_ &gt;= kMaxTimerNestingLevel)\n    interval_milliseconds = kMinimumInterval;\n\n  if (single_shot)\n    StartOneShot(interval_milliseconds, FROM_HERE);\n  else\n    StartRepeating(interval_milliseconds, FROM_HERE);\n</code></pre><p>所以，一些实时性较高的需求就不太适合使用setTimeout了，比如你用setTimeout来实现JavaScript动画就不是一个很好的主意。</p><h3>3. 未激活的页面，setTimeout执行最小间隔是1000毫秒</h3><p>除了前面的4毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于1000毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是1000毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。</p><h3>4. 延时执行时间有最大值</h3><p>除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是Chrome、Safari、Firefox都是以32个bit来存储延时值的，32bit最大只能存放的数字是2147483647毫秒，这就意味着，如果setTimeout设置的延迟值大于 2147483647毫秒（大约24.8天）时就会溢出，那么相当于延时值被设置为0了，这导致定时器会被立即执行。你可以运行下面这段代码：</p><pre><code>function showName(){\n  console.log(&quot;极客时间&quot;)\n}\nvar timerID = setTimeout(showName,2147483648);//会被理解调用执行\n</code></pre><p>运行后可以看到，这段代码是立即被执行的。但如果将延时值修改为小于2147483647毫秒的某个值，那么执行时就没有问题了。</p><h3>5. 使用setTimeout设置的回调函数中的this不符合直觉</h3><p>如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。这点在前面介绍this的时候也提过，你可以看下面这段代码的执行结果：</p><pre><code>var name= 1;\nvar MyObj = {\n  name: 2,\n  showName: function(){\n    console.log(this.name);\n  }\n}\nsetTimeout(MyObj.showName,1000)\n</code></pre><p>这里输出的是1，因为这段代码在编译的时候，执行上下文中的this会被设置为全局window，如果是严格模式，会被设置为undefined。</p><p>那么该怎么解决这个问题呢？通常可以使用下面这两种方法。</p><p>第一种是将<code>MyObj.showName</code>放在匿名函数中执行，如下所示：</p><pre><code>//箭头函数\nsetTimeout(() =&gt; {\n    MyObj.showName()\n}, 1000);\n//或者function函数\nsetTimeout(function() {\n  MyObj.showName();\n}, 1000)\n</code></pre><p>第二种是使用bind方法，将showName绑定在MyObj上面，代码如下所示：</p><pre><code>setTimeout(MyObj.showName.bind(MyObj), 1000)\n</code></pre><h2>总结</h2><p>好了，今天我们就介绍到这里，下面我来总结下今天的内容。</p><ul>\n<li>首先，为了支持定时器的实现，浏览器增加了延时队列。</li>\n<li>其次，由于消息队列排队和一些系统级别的限制，通过setTimeout设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。</li>\n<li>最后，在定时器中使用过程中，还存在一些陷阱，需要你多加注意。</li>\n</ul><p>通过分析和讲解，你会发现函数setTimeout在时效性上面有很多先天的不足，所以对于一些时间精度要求比较高的需求，应该有针对性地采取一些其他的方案。</p><h2>思考时间</h2><p>今天我们介绍了setTimeout，相信你现在也知道它是怎么工作的了，不过由于使用setTimeout设置的回调任务实时性并不是太好，所以很多场景并不适合使用setTimeout。比如你要使用JavaScript来实现动画效果，函数requestAnimationFrame就是个很好的选择。</p><p>那么今天留给你的作业是：你需要网上搜索了解下requestAnimationFrame的工作机制，并对比setTimeout，然后分析出requestAnimationFrame实现的动画效果比setTimeout好的原因。</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"15 | 消息队列和事件循环：页面是怎么“活”起来的？","id":132931},"right":{"article_title":"17 | WebAPI：XMLHttpRequest是怎么实现的？","id":135127}},"comments":[{"had_liked":false,"id":132250,"user_name":"pyhhou","can_delete":false,"product_type":"c1","uid":1256496,"ip_address":"","ucode":"31EF8D50CF91A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ibZVAmmdAibBeVpUjzwId8ibgRzNk7fkuR5pgVicB5mFSjjmt2eNadlykVLKCyGA0GxGffbhqLsHnhDRgyzxcKUhjg/132","comment_is_top":false,"comment_ctime":1568072191,"is_pvip":false,"discussion_count":9,"race_medal":0,"score":"456834605567","product_id":100033601,"comment_content":"使用 requestAnimationFrame 不需要设置具体的时间，由系统来决定回调函数的执行时间，requestAnimationFrame 里面的回调函数是在页面刷新之前执行，它跟着屏幕的刷新频率走，保证每个刷新间隔只执行一次，内如果页面未激活的话，requestAnimationFrame 也会停止渲染，这样既可以保证页面的流畅性，又能节省主线程执行函数的开销","like_count":107,"discussions":[{"author":{"id":1265346,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4e/c2/9b7c7434.jpg","nickname":"stonelee","note":"","ucode":"E263025E8A5D26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":12157,"discussion_content":"但是从实际验证结果来看，在文章中的例子里，使用 requestAnimationFrame 代替 setTimeout，依然需要等后面的 5000 次循环完成后才会执行的。这说明 js 脚本阻塞了屏幕的刷新，requestAnimationFrame 也并不能一定确保 16ms 执行一次","likes_number":12,"is_delete":false,"is_hidden":false,"ctime":1568473573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1177430,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f7/56/b82eeac7.jpg","nickname":"champ可口可乐了","note":"","ucode":"EA75C67E9124C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1265346,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4e/c2/9b7c7434.jpg","nickname":"stonelee","note":"","ucode":"E263025E8A5D26","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304468,"discussion_content":"毕竟rAF也是运行在主线程上面的，肯定会被阻塞的","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1599576719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":12157,"ip_address":""},"score":304468,"extra":""},{"author":{"id":1374181,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","nickname":"张宗伟","note":"","ucode":"1447A20C7A8982","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1177430,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f7/56/b82eeac7.jpg","nickname":"champ可口可乐了","note":"","ucode":"EA75C67E9124C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357003,"discussion_content":"同意，感觉它同样会被其他任务阻塞，也可以阻塞其他任务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615724130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304468,"ip_address":""},"score":357003,"extra":""},{"author":{"id":2555447,"avatar":"https://static001.geekbang.org/account/avatar/00/26/fe/37/758249ef.jpg","nickname":"lxp","note":"","ucode":"FC33434C53B771","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1177430,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f7/56/b82eeac7.jpg","nickname":"champ可口可乐了","note":"","ucode":"EA75C67E9124C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368023,"discussion_content":"既然会被阻塞，那raf对比setTiomeout的具体优点在哪里呢？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618543122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304468,"ip_address":""},"score":368023,"extra":""}]},{"author":{"id":1341893,"avatar":"https://static001.geekbang.org/account/avatar/00/14/79/c5/4098108b.jpg","nickname":"夏超","note":"","ucode":"E66A8C8D802ECB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300424,"discussion_content":"不会丢帧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598091002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":132308,"user_name":"Angus","can_delete":false,"product_type":"c1","uid":1377467,"ip_address":"","ucode":"7CC3BA1550FB5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/bb/5e5c37c1.jpg","comment_is_top":false,"comment_ctime":1568081652,"is_pvip":false,"replies":[{"id":"50604","content":"我文章说是队列，为了和消息队列统一起来，不然表述起来有点拗口。<br><br>其实是一个hashmap结构，等到执行这个结构的时候，会计算hashmap中的每个任务是否到期了，到期了就去执行，直到所有到期的任务都执行结束，才会进入下一轮循环！","user_name":"作者回复","comment_id":132308,"uid":"1141464","ip_address":"","utype":1,"ctime":1568088559,"user_name_real":"李兵"}],"discussion_count":5,"race_medal":0,"score":"396705072884","product_id":100033601,"comment_content":"我没有太理解这个异步延迟队列，既然是队列，但好像完全不符合先进先出的特点。在每次执行完任务队列中的一个任务之后都会去执行那些已经到期的延迟任务，这些延迟的任务具体是如何取出的呢。","like_count":93,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466868,"discussion_content":"我文章说是队列，为了和消息队列统一起来，不然表述起来有点拗口。\n\n其实是一个hashmap结构，等到执行这个结构的时候，会计算hashmap中的每个任务是否到期了，到期了就去执行，直到所有到期的任务都执行结束，才会进入下一轮循环！","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568088559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2515553,"avatar":"https://static001.geekbang.org/account/avatar/00/26/62/61/5eb29199.jpg","nickname":"lynn","note":"","ucode":"BFEFDDE890C036","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358362,"discussion_content":"小顶堆在这个场景是不是比较适合","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1615972187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1253438,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/3e/e2f1b2af.jpg","nickname":"I WANN BE THAT GUY","note":"","ucode":"2B51E6A5452617","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2515553,"avatar":"https://static001.geekbang.org/account/avatar/00/26/62/61/5eb29199.jpg","nickname":"lynn","note":"","ucode":"BFEFDDE890C036","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359817,"discussion_content":"用红黑树可以在log(n)，搞定，小顶堆你需要不停地pop直到发现第一个没有过期的timer。渐进复杂度一样，常数红黑树要小一点","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616295602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":358362,"ip_address":""},"score":359817,"extra":""},{"author":{"id":1253438,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/3e/e2f1b2af.jpg","nickname":"I WANN BE THAT GUY","note":"","ucode":"2B51E6A5452617","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2515553,"avatar":"https://static001.geekbang.org/account/avatar/00/26/62/61/5eb29199.jpg","nickname":"lynn","note":"","ucode":"BFEFDDE890C036","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359818,"discussion_content":"删除一个指定id的timer，堆需要o(n),显然就不适合这种场景了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1616295668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":358362,"ip_address":""},"score":359818,"extra":""}]},{"author":{"id":1383156,"avatar":"https://static001.geekbang.org/account/avatar/00/15/1a/f4/a40453e7.jpg","nickname":"man-moonth","note":"","ucode":"145EED9CFA19E4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8853,"discussion_content":"我也很好奇，猜想了两种可能：\n1. 延迟队列的事件循环处理，每次取出队列头的消息后，判断是否到到达了执行的时间，没有到执行时间则重新推入队列。\n2. 延迟队列的插入操作不是push到队列尾，而是比较当前消息的执行时间和队列中下一个消息的执行时间，当执行时间不晚于下一个消息的执行时间时，插入到当前节点。这样，延迟队列每次消费消息只需要取尾就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568083977,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132502,"user_name":"mfist","can_delete":false,"product_type":"c1","uid":1373624,"ip_address":"","ucode":"4F99F422C23FB4","user_header":"https://static001.geekbang.org/account/avatar/00/14/f5/b8/9f165f4b.jpg","comment_is_top":false,"comment_ctime":1568156500,"is_pvip":false,"replies":[{"id":"50923","content":"回答的很棒，raf是按照系统刷新的节奏调用的！","user_name":"作者回复","comment_id":132502,"uid":"1141464","ip_address":"","utype":1,"ctime":1568279170,"user_name_real":"李兵"}],"discussion_count":3,"race_medal":0,"score":"220611488596","product_id":100033601,"comment_content":"requestAnimationFrame 提供一个原生的API去执行动画的效果，它会在一帧（一般是16ms）间隔内根据选择浏览器情况去执行相关动作。<br>setTimeout是在特定的时间间隔去执行任务，不到时间间隔不会去执行，这样浏览器就没有办法去自动优化。<br><br>今日得到<br>浏览器的页面是通过消息队列和事件循环系统来驱动的。settimeout的函数会被加入到延迟消息队列中，<br>等到执行完Task任务之后就会执行延迟队列中的任务。然后分析几种场景下面的setimeout的执行方式。<br>1. 如果执行一个很耗时的任务，会影响延迟消息队列中任务的执行<br>2. 存在嵌套带调用时候，系统会设置最短时间间隔为4s（超过5层）<br>3. 未激活的页面，setTimeout最小时间间隔为1000ms<br>4. 延时执行时间的最大值2147483647，溢出会导致定时器立即执行<br>5. setTimeout设置回调函数this会是回调时候对应的this对象，可以使用箭头函数解决","like_count":52,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466975,"discussion_content":"回答的很棒，raf是按照系统刷新的节奏调用的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568279170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1909693,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/23/bd/b150086a.jpg","nickname":"在路上_W","note":"","ucode":"632D9130F58D3A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":245572,"discussion_content":"2.中是4ms","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1587686854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1863552,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zFOVquVttt7aTLtyHhPvH1SCUk19Rd14XoGz9QrCpFefwun86CdBJB4rbsY1M5zywXHibvRs4EqJLoUjpNyknFQ/132","nickname":"v8","note":"","ucode":"22FE67E8C124DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366283,"discussion_content":"【等到执行完Task任务之后就会执行延迟队列中的任务。】中的延迟队列中的任务是在每一个宏任务的所有微任务执行完之后执行还是之前执行？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618021165,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143391,"user_name":"l1shu","can_delete":false,"product_type":"c1","uid":1624297,"ip_address":"","ucode":"FCF3E36905B404","user_header":"https://static001.geekbang.org/account/avatar/00/18/c8/e9/c7c5cbf5.jpg","comment_is_top":false,"comment_ctime":1571704225,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"74586148257","product_id":100033601,"comment_content":"为什么有些文章说渲染进程中有一个定时器线程用来计时的 到时间后会把回调函数塞到消息队列  而没有提到延迟队列这个说法  求老师解答","like_count":17,"discussions":[{"author":{"id":1624297,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c8/e9/c7c5cbf5.jpg","nickname":"l1shu","note":"","ucode":"FCF3E36905B404","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353095,"discussion_content":"回头给自己评论一下  setTimeout 是宿主环境提供的能力  不存在定时器线程  是用队列实现的没错","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1615002504,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748640,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","nickname":"穿秋裤的男孩","note":"","ucode":"D0F48C66377893","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234985,"discussion_content":"一个东西得不同解释，感觉作者为了讲得通俗易懂些，和其它得解释确实有点出入，不过并不影响我们学习","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1587009629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1376627,"avatar":"https://static001.geekbang.org/account/avatar/00/15/01/73/a3bbaab9.jpg","nickname":"Aiden","note":"","ucode":"3B0FA384541943","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":201647,"discussion_content":"一个是标准 一个是实现。标准中规定有，实现根据文中的讲解是没有的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583818974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1502796,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ee/4c/dc3da8f1.jpg","nickname":"π_π蔚","note":"","ucode":"DED817B325A9E9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":87431,"discussion_content":"同问，到底有没有定时器线程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576668338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134273,"user_name":"moss","can_delete":false,"product_type":"c1","uid":1485532,"ip_address":"","ucode":"8CAFA44546CCCF","user_header":"","comment_is_top":false,"comment_ctime":1568789620,"is_pvip":false,"replies":[{"id":"51493","content":"第一个问题我在18节也回答过了，一个是标准，一个是实现，标准定义了很多队列，而浏览器只实现了一个普通队列和一个延时队列！<br><br>第二个问题，你说的那个update the randering就是说rAF吧？rAF是用户调用的，重新布局是渲染引擎自动安排的任务，必然要放到消息队列中！<br><br>滚动一般默认都是在合成线程里面完成的，这种都没用到主线程","user_name":"作者回复","comment_id":134273,"uid":"1141464","ip_address":"","utype":1,"ctime":1568807041,"user_name_real":"李兵"}],"discussion_count":8,"race_medal":0,"score":"74583233652","product_id":100033601,"comment_content":"这一节学习到了不少setTimeout的知识。不过关于消息队列我有不同的理解。<br>1. 关于任务优先级。whatwg标准里，“An event loop has one or more task queues”。消息队列其实不算是队列，因为有很多个task queue。“a task queue is a set of tasks”。每一个task queue才是一个队列。而对于每一个task queue里的task，其task source是一致的，或者说不同的task source会被推入到不同的task queue。就是规范里说的“every task source must be associated with a specific task queue”。而task sources都有哪些呢？比如DOM操作，UI事件，网络事件等。这个setTimout应该也算是一种task source吧？会放到专门的队列里。上一轮事件循环结束后，会先选择一个高优先级的task queue，然后取出task queue的第一个task，也因此而有了事件的优先级，老师将的延时队列我有点不太知道怎么融入我现有的知识体系。<br>2. “重新布局”是task吗？<br>老师说“重新布局”的事件会被放到消息队列。我的理解是task -&gt; microtask -&gt; update the rendering。当然不是每次循环都走渲染过程，因为每次循环都特别快不可能每次都走一次渲染，浏览器会遵循17ms一桢的原则走一次update the rendering，其中rAF也在此阶段执行，也是老师题目里rAF更流畅的原因。而重新布局也是在update the rendering阶段执行的，resize和onscroll都是在update the rendering阶段。标准里在update the rendering阶段，会有“run the resize steps”，“run the scroll steps”，这也是为啥scrolling自带节流效果最多17ms触发一次回调的原因，所以我认为连续事件（resize，scroll）既然都不是task -&gt; microtask -&gt; update the rendering里的task，而是update the rendering阶段，应该不会推送到某一个task queue才对。","like_count":18,"discussions":[{"author":{"id":1485532,"avatar":"","nickname":"moss","note":"","ucode":"8CAFA44546CCCF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":15926,"discussion_content":"感谢老师，关于浏览器实现的消息队列大致理解了。不过还有些疑问。\n1. 如何实现任务优先级呢？\n如果只有一个普通队列，如果提升UI事件（比如click）的优先级呢？比如有现在消息队列里有很多任务待执行，但是这时候触发click，在当前任务结束后，会立刻触发click事件。click事件是如何做到插队的呢？\n2. update the rendering是渲染阶段，按照标准，该阶段包括resize/scroll处理, rAF, update the layer, paint, 合成等。\nhttps://html.spec.whatwg.org/multipage/webappapis.html#update-the-rendering​\n​标准里清空完microTask后，浏览器会判断是否进入渲染阶段，假如进入了渲染阶段则该阶段结束之后才会进入下一轮事件循环，这就是我的说task -> microTask -> update the rendering。\n​如果按照标准理解，因为resize, scroll, rAF都在渲染阶段，只要进入渲染阶段就会渲染出新的一帧，所以连续滚动时，scroll和rAF是一致的。如果只有一个队列，是如何做到scroll回调精确到每一帧呢？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568860277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1485532,"avatar":"","nickname":"moss","note":"","ucode":"8CAFA44546CCCF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223668,"discussion_content":"老师只会回答一个问题，后续不会回复了，哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586245137,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":15926,"ip_address":""},"score":223668,"extra":""},{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255580,"discussion_content":"大佬来回答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588412310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223668,"ip_address":""},"score":255580,"extra":""},{"author":{"id":2031263,"avatar":"http://thirdwx.qlogo.cn/mmopen/Q3auHgzwzM59nwkCA4OyQdf1YhZoFzrUcdfKzvNmYTO4vu796xvSFFXtx3X2qI2dTZILoiaYdibcrfPIsKNAIpicg/132","nickname":"Geek_7f1046","note":"","ucode":"E7BB361E560AAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1485532,"avatar":"","nickname":"moss","note":"","ucode":"8CAFA44546CCCF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":535052,"discussion_content":"我理解resize，scroll，raf这些都包含在update the rendering 里，update date rendering本身也是一个消息队列，上面的这些回调监听算是队列里的宏任务，等于说update date rendering包含的这些是一个整体的任务task等他执行完之后会进入合成线程的绘制图像操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638343036,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":15926,"ip_address":""},"score":535052,"extra":""}]},{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467687,"discussion_content":"第一个问题我在18节也回答过了，一个是标准，一个是实现，标准定义了很多队列，而浏览器只实现了一个普通队列和一个延时队列！\n\n第二个问题，你说的那个update the randering就是说rAF吧？rAF是用户调用的，重新布局是渲染引擎自动安排的任务，必然要放到消息队列中！\n\n滚动一般默认都是在合成线程里面完成的，这种都没用到主线程","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568807041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2021265,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d7/91/aa45c7a3.jpg","nickname":"六耳","note":"","ucode":"547AD58D9F5FF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555785,"discussion_content":"联想到浏览器现在拆分了网络进程等，感觉你说的更合理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647074055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1440735,"avatar":"https://static001.geekbang.org/account/avatar/00/15/fb/df/8615f2d3.jpg","nickname":"kaiking","note":"","ucode":"DBE91C5855B9FD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379230,"discussion_content":"好高深","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623762911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1311458,"avatar":"https://static001.geekbang.org/account/avatar/00/14/02/e2/f646601b.jpg","nickname":"爱烤火的鱼","note":"","ucode":"A12B4551D3B086","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297463,"discussion_content":"大佬方便加个联系方式，一起交流下吗？我也有次疑惑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596944959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132771,"user_name":"Helios","can_delete":false,"product_type":"c1","uid":1380758,"ip_address":"","ucode":"BE6B98EE8F0D09","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKJrOl63enWXCRxN0SoucliclBme0qrRb19ATrWIOIvibKIz8UAuVgicBMibIVUznerHnjotI4dm6ibODA/132","comment_is_top":false,"comment_ctime":1568216620,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"70287693356","product_id":100033601,"comment_content":"请问老师不是说settimeout属于宏任务不，不应该属于在上节课讲的消息队列中么<br>怎么这次有跑到延时队列中了呢，这两个队列有什么关系呢，延时队列也分宏任务和微任务？","like_count":16,"discussions":[{"author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223640,"discussion_content":"宏任务有很多种，普通的宏任务添加到消息队列，像定时器这种延迟执行的，就添加到延迟队列（实际上是一个 map 的数据结构，看其它评论中老师说的）","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1586242724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2913864,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MYShyjtRtib2GIQiaK4hV3ZP9pQ1qiaS74DA4K4YHY4SIiaFDfsCKgiaMWwm9zFsSn3bt5pawp5Kdn5MWgiaw5909nug/132","nickname":"Geek_aa1c31","note":"","ucode":"1AC14C053638AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552092,"discussion_content":"消息队列和延时队列都是宏任务.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645281682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645648,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/50/217d8bb4.jpg","nickname":"飏","note":"","ucode":"419D35CD60D280","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71482,"discussion_content":"我猜想是在任务队列中进入调用栈执行时执行ProcessDelayTask","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575424527,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645648,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/50/217d8bb4.jpg","nickname":"飏","note":"","ucode":"419D35CD60D280","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":71479,"discussion_content":"这节是settimeout的实现，实现中需要一种名为“延时队列”的一种数据结构","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575424387,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219885,"user_name":"吴海燕","can_delete":false,"product_type":"c1","uid":1994735,"ip_address":"","ucode":"F6257115953643","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo2GMhevabZrribH3tMFmIuLialgyyictMg1N3ZPPMjmGOdlZ3KXjzPBLWw2dhgR9UGtAXsmKaHCqicew/132","comment_is_top":false,"comment_ctime":1590114410,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"53129721962","product_id":100033601,"comment_content":"老师有空的时候能否画一个包含延时队列和微任务，宏任务，消息队列关系运行图","like_count":13},{"had_liked":true,"id":163531,"user_name":"Zzzrd","can_delete":false,"product_type":"c1","uid":1232242,"ip_address":"","ucode":"524593B1193AFE","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/72/b7083420.jpg","comment_is_top":false,"comment_ctime":1576737529,"is_pvip":false,"replies":[{"id":"62183","content":"延迟队列也是宏任务，实际上blink维护了很多不同优先级的队列，这些队列里面都是宏任务<br><br>微任务是在宏任务执行过程中的某个时间点执行的，通常是在宏任务快要结束的时候执行","user_name":"作者回复","comment_id":163531,"uid":"1141464","ip_address":"","utype":1,"ctime":1576749337,"user_name_real":"李兵"}],"discussion_count":4,"race_medal":0,"score":"40231443193","product_id":100033601,"comment_content":"看完还是很迷惑：<br>1. setTimeout是宏任务，宏任务应该放在消息队列中，文中说是放在延迟队列中，为什么？延迟队列和消息队列的区别是什么？<br>2. 延迟队列的任务是在当前宏任务执行完之后执行，微任务队列是在当前宏任务将要结束时执行对吗？<br>","like_count":9,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478432,"discussion_content":"延迟队列也是宏任务，实际上blink维护了很多不同优先级的队列，这些队列里面都是宏任务\n\n微任务是在宏任务执行过程中的某个时间点执行的，通常是在宏任务快要结束的时候执行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576749337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1588451,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3c/e3/aee9692f.jpg","nickname":"CMS","note":"","ucode":"30FAC843F9D153","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":131082,"discussion_content":"先执行宏任务还是微任务？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578824991,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1765894,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/f2/06/ebb5b764.jpg","nickname":"NikkiZeng","note":"","ucode":"F669C811773394","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1588451,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3c/e3/aee9692f.jpg","nickname":"CMS","note":"","ucode":"30FAC843F9D153","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":156567,"discussion_content":"按照老师文中写的,应该是所有主线程上的任务都会加入到消息队列中,那&#34;解析HTML&#34;就是一个宏任务,在解析HTML这个宏任务里还包含执行js脚本,执行js的过程中如果遇到定时器,就会将对应的回调加入到延迟队列,然后继续执行js脚本的其他代码,执行完js代码之后,继续把整个&#34;解析HTML&#34;的任务执行完,如果此时消息队列中没有其他任务了,就往下执行延迟队列,如果延迟队列中的回调没有到时间就等于是一个空的队列,那么会继续循环消息队列,如果消息队列仍是空的就继续走延迟队列,刚好延迟队列的定时器到时间,存在于延迟队列中了,那么主线程就会将这个回调执行,执行完毕继续循环","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580380751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":131082,"ip_address":""},"score":156567,"extra":""},{"author":{"id":1446810,"avatar":"https://static001.geekbang.org/account/avatar/00/16/13/9a/842a9dc6.jpg","nickname":"求求你，别卷了！","note":"","ucode":"8F7DE1DF8A0B29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1588451,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3c/e3/aee9692f.jpg","nickname":"CMS","note":"","ucode":"30FAC843F9D153","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391860,"discussion_content":"先执行微任务的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630662022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":131082,"ip_address":""},"score":391860,"extra":""}]}]},{"had_liked":true,"id":144610,"user_name":"Djan Unchained","can_delete":false,"product_type":"c1","uid":1387997,"ip_address":"","ucode":"FB5A37B0EE3E98","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/dd/f2e79297.jpg","comment_is_top":false,"comment_ctime":1571979785,"is_pvip":false,"replies":[{"id":"55773","content":"是的，raf的回调函数也是在主线程上执行的，如果其中的一个回调函数执行过久，会影响到其他的任务的","user_name":"作者回复","comment_id":144610,"uid":"1141464","ip_address":"","utype":1,"ctime":1572009764,"user_name_real":"李兵"}],"discussion_count":1,"race_medal":0,"score":"40226685449","product_id":100033601,"comment_content":"requestAnimationFrame 也是在主线程上执行吗？如果当前任务执行时间过久，也会导致 requestAnimationFrame 被延后执行吗？","like_count":9,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472030,"discussion_content":"是的，raf的回调函数也是在主线程上执行的，如果其中的一个回调函数执行过久，会影响到其他的任务的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572009764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":133999,"user_name":"淡","can_delete":false,"product_type":"c1","uid":1456392,"ip_address":"","ucode":"6856CA319DE2F0","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/08/09055b47.jpg","comment_is_top":false,"comment_ctime":1568713416,"is_pvip":false,"replies":[{"id":"51509","content":"没有之前之后啊，延时队列里面是宏任务，普通的消息队列里面也是宏任务，微任务是在宏任务快要执行结束之前执行的！","user_name":"作者回复","comment_id":133999,"uid":"1141464","ip_address":"","utype":1,"ctime":1568809757,"user_name_real":"李兵"}],"discussion_count":6,"race_medal":0,"score":"40223419080","product_id":100033601,"comment_content":"老师，你好。<br>请问微任务的执行是在延迟队列任务执行之前吗？","like_count":10,"discussions":[{"author":{"id":2140340,"avatar":"https://static001.geekbang.org/account/avatar/00/20/a8/b4/6a818036.jpg","nickname":"zhenzhenChange","note":"","ucode":"AFD74E6B4F0C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":317555,"discussion_content":"看那段代码\nprocessTask之后\nprocessDelayTask\n也就是说\n先执行消息队列的宏任务，然后该宏任务结束之前，检查该宏任务中的微任务队列。\n消息队列的当前宏任务执行完毕之后，就到了延迟队列里的宏任务执行(假如定时器到时间了)","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603558560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1059952,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2c/70/02b627a6.jpg","nickname":"coder","note":"","ucode":"F70511D614B9F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":94528,"discussion_content":"所以，先执行消息队列里的宏任务的同步代码，然后执行当前宏任务中的微任务队列里全部的代码，最后才执行延迟队列里的宏任务吗？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576945762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1742972,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/98/7c/07e6e7b7.jpg","nickname":"Tim","note":"","ucode":"F51593465157E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1059952,"avatar":"https://static001.geekbang.org/account/avatar/00/10/2c/70/02b627a6.jpg","nickname":"coder","note":"","ucode":"F70511D614B9F4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":242188,"discussion_content":"我觉得是这样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587469789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":94528,"ip_address":""},"score":242188,"extra":""}]},{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467577,"discussion_content":"没有之前之后啊，延时队列里面是宏任务，普通的消息队列里面也是宏任务，微任务是在宏任务快要执行结束之前执行的！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568809757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2481719,"avatar":"https://static001.geekbang.org/account/avatar/00/25/de/37/b6dc7091.jpg","nickname":"上班威龙","note":"","ucode":"432C4D78A92CD7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358975,"discussion_content":"这是我个人的看法：\nconsole.log(1);\nPromise.resolve().then((res) => {\n  console.log(2);\n});\nconsole.log(3);\nsetTimeout(() => {\n  Promise.resolve().then((res) => {\n    console.log(4);\n  });\n  console.log(5);\n}, 100);\n\n这一段js代码，首先setTimeout推入 延时队列中，其它同步代码推入普通的消息队列中，在这个宏任务中因为存在promise.then的微任务，所以会推入当前宏任务中的微任务队列中，当事件循环机制，在执行普通消息队列中的代码时，console.log(1),console.log(3)检测到当前宏任务的微任务队列中有任务，所以会执行改微任务，也就是console.log(2);当执行完微任务时，会检查延迟队列中是否有任务到期，如果到期了则会执行改宏任务，因为setTimeout也是一个宏任务，所以它也会携带自己的微任务队列，所以会先打印5 再打印4\n// 1 3 2 5 4","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616080080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1039904,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/de/20/03130a39.jpg","nickname":"沧海一声笑","note":"","ucode":"5297F2F4736B63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220631,"discussion_content":"不是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585909391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145346,"user_name":"Wlt","can_delete":false,"product_type":"c1","uid":1631750,"ip_address":"","ucode":"E8B095658FD88A","user_header":"https://static001.geekbang.org/account/avatar/00/18/e6/06/2045daa5.jpg","comment_is_top":false,"comment_ctime":1572256264,"is_pvip":false,"replies":[{"id":"56738","content":"延迟消息队列主要是放一些定时执行的任务，如JavaScript设置定时器的回调，还有浏览器内部的一些定时回调任务！ 这类任务需要等到指定时间间隔之后才会被执行！<br><br>而正常的消息队列中的任务只会按照顺序执行，执行完上个任务接着执行下个任务，不需要关系时间间隔！","user_name":"作者回复","comment_id":145346,"uid":"1141464","ip_address":"","utype":1,"ctime":1572670131,"user_name_real":"李兵"}],"discussion_count":1,"race_medal":0,"score":"35931994632","product_id":100033601,"comment_content":"老师，您好，延迟队列和消息队列是什么关系，怎么配合工作的？","like_count":8,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472349,"discussion_content":"延迟消息队列主要是放一些定时执行的任务，如JavaScript设置定时器的回调，还有浏览器内部的一些定时回调任务！ 这类任务需要等到指定时间间隔之后才会被执行！\n\n而正常的消息队列中的任务只会按照顺序执行，执行完上个任务接着执行下个任务，不需要关系时间间隔！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572670131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":132313,"user_name":"李懂","can_delete":false,"product_type":"c1","uid":1330436,"ip_address":"","ucode":"539E6639042C88","user_header":"https://static001.geekbang.org/account/avatar/00/14/4d/04/5e0d3713.jpg","comment_is_top":false,"comment_ctime":1568082270,"is_pvip":false,"replies":[{"id":"50607","content":"比如有五个定时的任务到期了,那么会分别把这个五个定时器的任务执行掉，再开始下次循环过程！<br><br>chromium中，当执行一个宏任务时，才会创建微任务队列，等遇到checkpoint时就会执行微任务！","user_name":"作者回复","comment_id":132313,"uid":"1141464","ip_address":"","utype":1,"ctime":1568088760,"user_name_real":"李兵"}],"discussion_count":3,"race_medal":0,"score":"31632853342","product_id":100033601,"comment_content":"1.执行延迟队列的任务，是一次循环只取出一个，还是检查只要时间到了，就执行？<br>2.微任务是在宏任务里的，是执行完一个宏任务，就去执行宏任务里面的微任务？","like_count":8,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466872,"discussion_content":"比如有五个定时的任务到期了,那么会分别把这个五个定时器的任务执行掉，再开始下次循环过程！\n\nchromium中，当执行一个宏任务时，才会创建微任务队列，等遇到checkpoint时就会执行微任务！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568088760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337746,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJS0jwYKhjm1hq96go05J4R7XDd5FFXXaoyIfX9TgoI3mLURAu2ET72SvYGM2iaET7IV3WDvMibAVfw/132","nickname":"tokey","note":"","ucode":"5278487F37D4EC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386109,"discussion_content":"1、「&#34;比如有五个定时的任务到期了,那么会分别把这个五个定时器的任务执行掉，再开始下次循环过程！&#34;」 这个是正确的，解释如下：\n\n五个定时任务到期了（就是告诉浏览器可以执行 宏任务 队列里的回调了），浏览器会依次把这 5 个回调任务清空，只不过每次拿出一个回调任务放入执行栈执行，单个回调任务执行的过程中，如果遇到宏任务，添加到下次的宏任务队列，遇到微任务，添加到本轮执行栈底部的微任务队里，等到执行栈清空当前的回调任务，再清空微任务队列（补充：微任务队列是每次执行栈清空都要执行完毕，所以会阻塞事件环）。\n然后拿出第二个回调任务继续执行以上操作，如此往复，直到清空这 5 个回调任务，本轮结束，进入下一轮循环。\n\n2、解释你 node 一次执行完宏任务队列的问题：\nNode 10 及以前的版本和浏览器不一致，表现是一次性把 已经到期宏任务队列全部压入执行栈，执行完在执行微任务队列。\n而 Node 11 及以上版本和浏览器一致了，具体执行顺序参考 解答1","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1627408033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1365541,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d6/25/a95a2064.jpg","nickname":"luwei","note":"","ucode":"0960A09F7B8D59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285958,"discussion_content":"老师说的&#34;比如有五个定时的任务到期了,那么会分别把这个五个定时器的任务执行掉，再开始下次循环过程！&#34;这个是不是不太对呢？在node环境下是这样的，但是在浏览器环境下不是这样的。\n在浏览器环境下的事件循环机制是：一个task执行完毕，然后再执行所有的micro-task，一次事件循环就结束了。然后继续循环....\n```\nwhile (true) {\n  宏任务队列.shift()\n  微任务队列全部任务()\n}\n```\n在node环境下的事件循环机制是：\n```\nwhile (true) {\n  loop.forEach((阶段) => {\n    阶段全部任务()\n    nextTick全部任务()\n    microTask全部任务()\n  })\n  loop = loop.next\n```\n\n以下代码\n```\nsetTimeout(() => {\n  console.log(&#39;setTimeout 1&#39;)\n  Promise.resolve().then(() => {\n    console.log(&#39;promise 1&#39;)\n  })\n}, 0)\nsetTimeout(() => {\n  console.log(&#39;setTimeout 2&#39;)\n  Promise.resolve().then(() => {\n    console.log(&#39;promise 2&#39;)\n  })\n}, 0)\n```\n在node环境下的打印结果是：\nsetTimeout 1\nsetTimeout 2\npromise 1\npromise 2\n但在浏览器环境下是\nsetTimeout 1\npromise 1\nsetTimeout 2\npromise 2","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592996325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174952,"user_name":"4!!","can_delete":false,"product_type":"c1","uid":1487663,"ip_address":"","ucode":"188445590D97DF","user_header":"https://static001.geekbang.org/account/avatar/00/16/b3/2f/867b94d8.jpg","comment_is_top":false,"comment_ctime":1580474520,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"27350278296","product_id":100033601,"comment_content":"传入requestAnimationFrame的回调并不会添加到消息队列或延迟队列中，传入requestAnimationFrame的回调会在页面下次重绘之前被调用，可以保证动画更实时准确。与setTimeout相比还有几个优点：1.当页面不可见或未被激活时，requestAnimationFrame的回调不会被调用；2.requestAnimationFrame的循环调用会有个自动节流处理，使得动画足够流畅，而函数不被过于频繁调用。","like_count":6,"discussions":[{"author":{"id":2752142,"avatar":"https://static001.geekbang.org/account/avatar/00/29/fe/8e/895f05a2.jpg","nickname":"A LETTER","note":"","ucode":"56C82015945CDE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401119,"discussion_content":"也不是说不会加入到延迟队列中，只是渲染引擎每隔17ms会将重新布局这个任务放入消息队列中，而重新布局任务中会去处理raf的回调函数，所以raf的回调会跟着浏览器的每一帧执行。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1633569975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1374181,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","nickname":"张宗伟","note":"","ucode":"1447A20C7A8982","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356869,"discussion_content":"&#34;传入requestAnimationFrame的回调并不会添加到消息队列或延迟队列中，传入requestAnimationFrame的回调会在页面下次重绘之前被调用&#34;，点睛之笔。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615692945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207121,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1587009707,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"18766878891","product_id":100033601,"comment_content":"评论好多说延迟队列得，其实就是一个定时器线程吧，定时器线程负责计时，到点了就把回掉push到消息队列中。","like_count":5,"discussions":[{"author":{"id":1147347,"avatar":"https://static001.geekbang.org/account/avatar/00/11/81/d3/f0a88806.jpg","nickname":"🍐 🍾 🔆","note":"","ucode":"1B7C90800AD4D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277851,"discussion_content":"老师写的可没重新推到消息队列里，每次执行任务都会去查一边延迟队列，如果已经到期，就会将这些到期的任务全部执行，再去继续下一次循环","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1591110305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2913864,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MYShyjtRtib2GIQiaK4hV3ZP9pQ1qiaS74DA4K4YHY4SIiaFDfsCKgiaMWwm9zFsSn3bt5pawp5Kdn5MWgiaw5909nug/132","nickname":"Geek_aa1c31","note":"","ucode":"1AC14C053638AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552096,"discussion_content":"差别很大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645283049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1892268,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM6fGV3BcHQHyNibzRhsPr6KqYzOtMF8G9fiaNvYUavdlhdqMugcHWggWGBbIibkYTibIXramEXsvg4aXA/132","nickname":"肖海涛","note":"","ucode":"5E4C20D5A69BEC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393142,"discussion_content":"不是定时器线程，是主线程从延迟队列里把所有任务循环一遍，对比开始时间和定时事件，看哪个到期了就执行哪个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631265230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2741739,"avatar":"","nickname":"Geek_1dcec7","note":"","ucode":"5D600692D19865","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390530,"discussion_content":"确实就是一个定时器线程,这个延迟队列说的我都凌乱了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629877846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168111,"user_name":"Cris","can_delete":false,"product_type":"c1","uid":1473520,"ip_address":"","ucode":"F8A287134F1078","user_header":"https://static001.geekbang.org/account/avatar/00/16/7b/f0/269139d5.jpg","comment_is_top":false,"comment_ctime":1578014908,"is_pvip":false,"replies":[{"id":"65297","content":"就是后台页面，比如你在浏览器中打开了多个标签，除了你当前操作的页面，其他的标签页都是后台页面","user_name":"作者回复","comment_id":168111,"uid":"1141464","ip_address":"","utype":1,"ctime":1578026397,"user_name_real":"李兵"}],"discussion_count":1,"race_medal":0,"score":"14462916796","product_id":100033601,"comment_content":"老师，您这里未激活的页面是什么意思？","like_count":3,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480140,"discussion_content":"就是后台页面，比如你在浏览器中打开了多个标签，除了你当前操作的页面，其他的标签页都是后台页面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578026397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163012,"user_name":"晓东","can_delete":false,"product_type":"c1","uid":1156331,"ip_address":"","ucode":"E86A18B72C6810","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/eb/c092f833.jpg","comment_is_top":false,"comment_ctime":1576639939,"is_pvip":true,"replies":[{"id":"61918","content":"是的","user_name":"作者回复","comment_id":163012,"uid":"1141464","ip_address":"","utype":1,"ctime":1576644396,"user_name_real":"李兵"}],"discussion_count":1,"race_medal":0,"score":"14461541827","product_id":100033601,"comment_content":"老师，对processDelayTask这块有个疑惑。这里会把所有的到期任务都执行完才会开始下一个while循环吗？","like_count":3,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478213,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576644396,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":true,"id":154662,"user_name":"纪年","can_delete":false,"product_type":"c1","uid":1230560,"ip_address":"","ucode":"63D3766F14F84D","user_header":"https://static001.geekbang.org/account/avatar/00/12/c6/e0/d2360a29.jpg","comment_is_top":false,"comment_ctime":1574502692,"is_pvip":false,"replies":[{"id":"59369","content":"是的，说立即执行的确有点不准确哈，这个我来优化下说法！","user_name":"作者回复","comment_id":154662,"uid":"1141464","ip_address":"","utype":1,"ctime":1574510533,"user_name_real":"李兵"}],"discussion_count":1,"race_medal":0,"score":"14459404580","product_id":100033601,"comment_content":"如果 setTimeout 设置的延迟值大于 2147483647 毫秒时就会溢出，这导致定时器会被立即执行。<br>问题：这里的立即执行其实是不是相当于setTimeout（fun, 0）的意思？","like_count":3,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475540,"discussion_content":"是的，说立即执行的确有点不准确哈，这个我来优化下说法！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574510533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151204,"user_name":"follaw","can_delete":false,"product_type":"c1","uid":1312822,"ip_address":"","ucode":"82A4275A34A6C8","user_header":"https://static001.geekbang.org/account/avatar/00/14/08/36/401ce5e8.jpg","comment_is_top":false,"comment_ctime":1573666901,"is_pvip":false,"replies":[{"id":"59306","content":"每次执行完一个任务后，都会计算下是否有定时器的任务到期","user_name":"作者回复","comment_id":151204,"uid":"1141464","ip_address":"","utype":1,"ctime":1574481521,"user_name_real":"李兵"}],"discussion_count":2,"race_medal":0,"score":"14458568789","product_id":100033601,"comment_content":"系统如何筛选出到期的任务，如果有10000个呢，是循环一万次？这个系统内部怎么处理的呢？","like_count":3,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474397,"discussion_content":"每次执行完一个任务后，都会计算下是否有定时器的任务到期","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574481521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1312822,"avatar":"https://static001.geekbang.org/account/avatar/00/14/08/36/401ce5e8.jpg","nickname":"follaw","note":"","ucode":"82A4275A34A6C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63832,"discussion_content":"如何计算的呢？请问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574915410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206524,"user_name":"以武会友-刘华强","can_delete":false,"product_type":"c1","uid":1640010,"ip_address":"","ucode":"DCA0DB27C36F8B","user_header":"https://static001.geekbang.org/account/avatar/00/19/06/4a/14c31e5c.jpg","comment_is_top":false,"comment_ctime":1586874194,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10176808786","product_id":100033601,"comment_content":"怎么优化setTimeout 时间值不准的问题呢？","like_count":2,"discussions":[{"author":{"id":2021265,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/d7/91/aa45c7a3.jpg","nickname":"六耳","note":"","ucode":"547AD58D9F5FF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555819,"discussion_content":"没办法优化 如果需要相对确定的时间间隔 。请使用rMF。\n\n以下是Opera浏览器的技术师Erik Möller设计的\n(function() {\n  var lastTime = 0;\n  var vendors = [&#39;webkit&#39;, &#39;moz&#39;];\n  //如果window.requestAnimationFrame为undefined先尝试浏览器前缀是否兼容\n  for(var x = 0; x &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + &#39;RequestAnimationFrame&#39;];\n    window.cancelAnimationFrame = window[vendors[x] + &#39;CancelAnimationFrame&#39;] ||//webkit中此取消方法的名字变了\n                                  window[vendors[x] + &#39;CancelRequestAnimationFrame&#39;];\n  }\n  //如果仍然不兼容，则使用setTimeOut进行兼容操作\n  if(!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback, element) {\n      var currTime = new Date().getTime();\n      var timeToCall = Math.max(0, 16.7 - (currTime - lastTime));\n      var id = window.setTimeout(function() {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id; \n    }\n  }\n \n  if(!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    }\n  }\n})();","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647076046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":159404,"user_name":"-_-|||","can_delete":false,"product_type":"c1","uid":1328142,"ip_address":"","ucode":"94B21594658BF9","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/0e/ce14b7d3.jpg","comment_is_top":false,"comment_ctime":1575615493,"is_pvip":false,"replies":[{"id":"60926","content":"因为要一位表示正负数啊","user_name":"作者回复","comment_id":159404,"uid":"1141464","ip_address":"","utype":1,"ctime":1575622636,"user_name_real":"李兵"}],"discussion_count":1,"race_medal":1,"score":"10165550085","product_id":100033601,"comment_content":"&#39;32bit 最大只能存放的数字是 2147483647 毫秒&#39;,最大能存放的数字不是2^32-1吗？4294967295，为什么是 2147483647 毫秒","like_count":2,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477039,"discussion_content":"因为要一位表示正负数啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575622636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144728,"user_name":"Djan Unchained","can_delete":false,"product_type":"c1","uid":1387997,"ip_address":"","ucode":"FB5A37B0EE3E98","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/dd/f2e79297.jpg","comment_is_top":false,"comment_ctime":1572014142,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10161948734","product_id":100033601,"comment_content":"setTimeout是在普通队列的当前一个任务结束之后，才去延迟队列查询并执行到期任务？还是在本轮事件循环的所有同步任务执行完？另外，怎么确定一轮事件循环是从哪儿到哪儿？","like_count":2,"discussions":[{"author":{"id":1374181,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","nickname":"张宗伟","note":"","ucode":"1447A20C7A8982","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356871,"discussion_content":"可以看上面的伪代码，放入延迟队列(其实不是队列，而是hash表)的延迟任务(例如setTimeout)，是在每次执行消息队列的一个任务(宏任务和微任务)后，执行到达指定的执行时间的延迟任务。---个人见解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615693299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136260,"user_name":"阿桐","can_delete":false,"product_type":"c1","uid":1160167,"ip_address":"","ucode":"E82211BD6E9E89","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/e7/227ee616.jpg","comment_is_top":false,"comment_ctime":1569399250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10159333842","product_id":100033601,"comment_content":"老师，假设在执行延迟队列中到期的任务时产生了新的到期任务如 setTimeout(foo, 0)，新的到期任务是在本次循环中执行还是推迟到下个循环中执行呢？<br><br>“如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒”，基于此，我猜测新产生的到期任务不超过5个的话，会在本次循环中执行","like_count":2},{"had_liked":false,"id":301021,"user_name":"zy","can_delete":false,"product_type":"c1","uid":1081089,"ip_address":"","ucode":"A2E318B40EECB5","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/01/aa7562e4.jpg","comment_is_top":false,"comment_ctime":1625486745,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5920454041","product_id":100033601,"comment_content":"有问题希望老师回答，setTimeOut是放在所谓的延迟队列里还是单独一个定时器线程，到期了就把任务放回任务队列，还是老师说的单独的队列，每次执行完任务队列的一个任务就去延迟队列里找到到期的任务","like_count":1},{"had_liked":false,"id":226316,"user_name":"趁你还年轻233","can_delete":false,"product_type":"c1","uid":1053875,"ip_address":"","ucode":"B7CC120EF42980","user_header":"https://static001.geekbang.org/account/avatar/00/10/14/b3/b6e1817a.jpg","comment_is_top":false,"comment_ctime":1592033727,"is_pvip":false,"replies":[{"id":"83356","content":"哈哈哈哈","user_name":"编辑回复","user_name_real":"郭蕾","uid":"1000473","ctime":1592054531,"ip_address":"","comment_id":226316,"utype":2}],"discussion_count":1,"race_medal":0,"score":"5887001023","product_id":100033601,"comment_content":"虽然老师的英语发音很不标准···<br>但是技术原理讲得还是不错的。","like_count":1,"discussions":[{"author":{"id":1000473,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/44/19/17fadc62.jpg","nickname":"郭蕾","note":"","ucode":"34F4C07D1C5FE8","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498189,"discussion_content":"哈哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592054531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":4}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":208391,"user_name":"我母鸡啊！","can_delete":false,"product_type":"c1","uid":1633705,"ip_address":"","ucode":"7BFB14BC99E978","user_header":"https://static001.geekbang.org/account/avatar/00/18/ed/a9/662318ab.jpg","comment_is_top":false,"comment_ctime":1587349044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882316340","product_id":100033601,"comment_content":"浏览器每秒执行60帧，大概一帧16ms，并且浏览器在每一帧都会去执行requestAnimationFrame函数，而setTimeout定时器存在不准时的情况，所以绘制动画选择requestAnimationFrame更好","like_count":1},{"had_liked":false,"id":207120,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1587009474,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5881976770","product_id":100033601,"comment_content":"感觉浏览器得事件循环架构和node得架构很相似，都说渲染线程是单线程架构，但是也会有一些其它线程来帮助它执行一些任务，比如定时器线程，请求线程等等。这些在node里面都有对应得线程。不知道理解得对不对","like_count":1,"discussions":[{"author":{"id":2349136,"avatar":"https://static001.geekbang.org/account/avatar/00/23/d8/50/151ef55a.jpg","nickname":"Zane","note":"","ucode":"4D51D7EAD62372","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377702,"discussion_content":"是渲染进程，不是渲染线程吧\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622781299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186566,"user_name":"houqx","can_delete":false,"product_type":"c1","uid":1380187,"ip_address":"","ucode":"71FDE1BDF1C649","user_header":"https://static001.geekbang.org/account/avatar/00/15/0f/5b/dc7589e0.jpg","comment_is_top":false,"comment_ctime":1583885460,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878852756","product_id":100033601,"comment_content":"关于setTimeout回调执行时机有个疑问，是当前任务执行完之后就执行到期的回调呢，还是跟后文讲的xmlhttprequest的回调一样，放在任务列表的结尾，等前面所有的任务执行完之后再执行?(在宏任务微任务章节说的xhr与settimeout机制是一样的)","like_count":1},{"had_liked":false,"id":140165,"user_name":"Debugger","can_delete":false,"product_type":"c1","uid":1475359,"ip_address":"","ucode":"8BDD5B0D966927","user_header":"https://static001.geekbang.org/account/avatar/00/16/83/1f/97011d77.jpg","comment_is_top":false,"comment_ctime":1570843297,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865810593","product_id":100033601,"comment_content":"请问老师，系统每隔16ms去刷新页面，那刷新页面这个操作是不是也是消息队列中的一个任务","like_count":2},{"had_liked":false,"id":133192,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1568439911,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5863407207","product_id":100033601,"comment_content":"在Nodejs中 有关 setTimeout 的执行的机制是和浏览器中一样的？ 事件循环机制是 V8引擎进行控制的吗？","like_count":1},{"had_liked":false,"id":132775,"user_name":"朱维娜🍍","can_delete":false,"product_type":"c1","uid":1625918,"ip_address":"","ucode":"2BE89ABFE2BF0C","user_header":"https://static001.geekbang.org/account/avatar/00/18/cf/3e/5c684022.jpg","comment_is_top":false,"comment_ctime":1568217285,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5863184581","product_id":100033601,"comment_content":"一次循环是指一个宏任务-&gt;宏任务产生的微任务-&gt;到期的延时任务，对吗？","like_count":1,"discussions":[{"author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223643,"discussion_content":"setTimeout 就属于宏任务的一种，所以当执行完上一轮的宏任务-微任务后，就开始下一轮的宏任务-微任务了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586243038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1147948,"avatar":"https://static001.geekbang.org/account/avatar/00/11/84/2c/1b0926b4.jpg","nickname":"Even","note":"","ucode":"C3555903EE9525","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338440,"discussion_content":"一次循环就是宏任务，然后快结束的时候跑微任务，定时器也是宏任务，不过它的执行时机是在每个宏任务执行结束后去检查有没有到期的定时器任务可以执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609291545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223645,"discussion_content":"补充一下，一轮循环应该是指 宏任务 -> 微任务，我是这样想的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586243232,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132283,"user_name":"Twilight","can_delete":false,"product_type":"c1","uid":1623240,"ip_address":"","ucode":"0EACC18263F567","user_header":"https://static001.geekbang.org/account/avatar/00/18/c4/c8/368fde9f.jpg","comment_is_top":false,"comment_ctime":1568078277,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5863045573","product_id":100033601,"comment_content":"requestAnimationFrame与浏览器刷新同步，而setTimeout就算设置了16.7延迟，也可能会因为当前任务的执行时间过长而延迟","like_count":1,"discussions":[{"author":{"id":2913864,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/MYShyjtRtib2GIQiaK4hV3ZP9pQ1qiaS74DA4K4YHY4SIiaFDfsCKgiaMWwm9zFsSn3bt5pawp5Kdn5MWgiaw5909nug/132","nickname":"Geek_aa1c31","note":"","ucode":"1AC14C053638AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577485,"discussion_content":"requestAnimationFrame也会因为当前任务的执行时间过长而延迟。 不管是setTimeout还是requestAnimationFrame都是在主线程上执行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656141362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346996,"user_name":"Jeff","can_delete":false,"product_type":"c1","uid":1895239,"ip_address":"","ucode":"B20FA0E5D40F54","user_header":"https://static001.geekbang.org/account/avatar/00/1c/eb/47/a9a9b52d.jpg","comment_is_top":false,"comment_ctime":1653610334,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653610334","product_id":100033601,"comment_content":"再来复习一遍，真不错","like_count":0},{"had_liked":false,"id":338155,"user_name":"zgy","can_delete":false,"product_type":"c1","uid":1387798,"ip_address":"","ucode":"05EA6845199250","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/16/b525a71d.jpg","comment_is_top":false,"comment_ctime":1647326311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647326311","product_id":100033601,"comment_content":"跑了一个动画的小脚本。通过requestAnimationFrame 去跑的话，基本上每一帧是16.7ms 也就是60fps，这也就代表不会卡顿。通过setTimeout则会出现低fps的情况。","like_count":0},{"had_liked":false,"id":331968,"user_name":"良xxxx","can_delete":false,"product_type":"c1","uid":1384286,"ip_address":"","ucode":"2E8A64C5B0C7ED","user_header":"https://static001.geekbang.org/account/avatar/00/15/1f/5e/e239e4a9.jpg","comment_is_top":false,"comment_ctime":1642928396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642928396","product_id":100033601,"comment_content":"“处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程”，这里好迷惑，如果按老师讲解的可以理解为宏任务插队吗？？","like_count":0},{"had_liked":false,"id":331214,"user_name":"谢谢","can_delete":false,"product_type":"c1","uid":1996800,"ip_address":"","ucode":"03457E973DCB2F","user_header":"","comment_is_top":false,"comment_ctime":1642488046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642488046","product_id":100033601,"comment_content":"老师好，想问下延迟队列中的任务到期后，是直接执行还是放到宏任务队列中呢（比如setTimeout）","like_count":0},{"had_liked":false,"id":317313,"user_name":"小太阳","can_delete":false,"product_type":"c1","uid":2579249,"ip_address":"","ucode":"D0C8778FEF772C","user_header":"https://static001.geekbang.org/account/avatar/00/27/5b/31/984c51a9.jpg","comment_is_top":false,"comment_ctime":1634737715,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634737715","product_id":100033601,"comment_content":"老师：我有个问题：如果专门为了异步设置了一个异步队列。当遇到延时器的时候，会添加延时器到异步队列，一旦监听到需要触发了，是不是会放到宏任务队列中，等待eventloop的循环执行，那如果宏任务队列中有很多待执行的任务，也会造成执行时间的误差啊","like_count":0},{"had_liked":false,"id":306882,"user_name":"光影","can_delete":false,"product_type":"c1","uid":2539250,"ip_address":"","ucode":"CE6EF591D3A7B5","user_header":"https://static001.geekbang.org/account/avatar/00/26/be/f2/60711467.jpg","comment_is_top":false,"comment_ctime":1628761158,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628761158","product_id":100033601,"comment_content":"感觉可以这么说，this就是获取运行时的执行上下文的，像上面setTimeout里面的函数，运行的时候上下文是全局，所以才会这样","like_count":0},{"had_liked":false,"id":301497,"user_name":"哦啦啦","can_delete":false,"product_type":"c1","uid":2104322,"ip_address":"","ucode":"5C0B035E261BBC","user_header":"https://static001.geekbang.org/account/avatar/00/20/1c/02/7d613e6c.jpg","comment_is_top":false,"comment_ctime":1625718228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625718228","product_id":100033601,"comment_content":"好多文章都说 setTimeout 的回调是由定时器线程推入消息队列的，所以 setTimeout(fn, 0) 的回调得等到消息队列前面的所有任务都执行完了才会执行；看了评论区，貌似确实没有定时器线程这个东西，那是不是说明，setTimeout(fn, 0) 的回调，最多只需要等待当前宏任务执行完，以及延迟队列里比它先进入队列的其他到期的定时器回调执行完？","like_count":0},{"had_liked":false,"id":300381,"user_name":"KeilingZhuang","can_delete":false,"product_type":"c1","uid":2114442,"ip_address":"","ucode":"CDBA0336FE3E26","user_header":"https://static001.geekbang.org/account/avatar/00/20/43/8a/9380fe92.jpg","comment_is_top":false,"comment_ctime":1625133046,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625133046","product_id":100033601,"comment_content":"1、延时任务产生的时间点为T1<br>2、当前任务执行完成<br>3、检查延时队列：<br>        没找到，开始下一个任务回到2<br>        找到了，执行符合条件的延时任务，时间点为T2<br><br>T2 - T1  &gt;=  delay ","like_count":0},{"had_liked":false,"id":300221,"user_name":"刘嘉皓","can_delete":false,"product_type":"c1","uid":1161639,"ip_address":"","ucode":"B8FB3EBC6545AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/b9/a7/341b716a.jpg","comment_is_top":false,"comment_ctime":1625051009,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625051009","product_id":100033601,"comment_content":"32bit = 2^32 - 1 = 4294967295<br>31bit = 2^31 - 1 = 2147483647 是只有31bit表示数吗？","like_count":0},{"had_liked":false,"id":288904,"user_name":"fakership","can_delete":false,"product_type":"c1","uid":1097136,"ip_address":"","ucode":"42B5F286B6CC19","user_header":"https://static001.geekbang.org/account/avatar/00/10/bd/b0/8b808d33.jpg","comment_is_top":false,"comment_ctime":1618756801,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618756801","product_id":100033601,"comment_content":"https:&#47;&#47;blog.csdn.net&#47;wangyoucaoxiaoxiao&#47;article&#47;details&#47;86232759<br><br>这篇文章所说的跟本内容有些冲突 其中对于网络我还是可以理解 但对于定时器这里还是无法准确理解 如果宏任务分散在各个优先级队列里头的话 那优先级是啥样子呢 跟微任务又是怎么串起来的呢","like_count":0},{"had_liked":false,"id":286610,"user_name":"哦啦啦","can_delete":false,"product_type":"c1","uid":2104322,"ip_address":"","ucode":"5C0B035E261BBC","user_header":"https://static001.geekbang.org/account/avatar/00/20/1c/02/7d613e6c.jpg","comment_is_top":false,"comment_ctime":1617425144,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617425144","product_id":100033601,"comment_content":"老师提到【处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。】<br>这跟我之前的理解有点出入，老师的意思是执行完一个宏任务，就会遍历并执行所有已到期的定时器回调？定时器不也是宏任务吗，按我的理解，主线程发现一个 setTimeout 后，会把它交给定时器线程，由定时器线程负责计时，到期后，定时器线程就会把相应的回调塞入消息队列，后续的处理跟队列里的其他宏任务没有区别。<br>也就是定时器到期后，起码要等到当前消息队列的所有宏任务都执行完后，定时器的回调才会被执行。请问我的理解有问题吗？","like_count":0},{"had_liked":false,"id":286371,"user_name":"影相随","can_delete":false,"product_type":"c1","uid":1296332,"ip_address":"","ucode":"A821EC04816992","user_header":"https://static001.geekbang.org/account/avatar/00/13/c7/cc/fc9232f6.jpg","comment_is_top":false,"comment_ctime":1617270867,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1617270867","product_id":100033601,"comment_content":"老师，那每次执行完消息队列里的一个宏任务后，都要先清空这个宏任务下的微任务队列，然后还要再清空延时任务队列，最后再执行下一个消息队列里面的宏任务吗？","like_count":0,"discussions":[{"author":{"id":3038571,"avatar":"","nickname":"Geek_63c17a","note":"","ucode":"1284F1FA3ECD4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577629,"discussion_content":"同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656239184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285144,"user_name":"小童","can_delete":false,"product_type":"c1","uid":1763395,"ip_address":"","ucode":"300444B520E79D","user_header":"https://static001.geekbang.org/account/avatar/00/1a/e8/43/f9c0faed.jpg","comment_is_top":false,"comment_ctime":1616641169,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616641169","product_id":100033601,"comment_content":"老师，问下 异步任务，是异步任务执行完，结果放消息队列中去的吗？异步任务是怎么执行的，是别的线程吗？","like_count":0},{"had_liked":false,"id":283967,"user_name":"l_j_dota_1111","can_delete":false,"product_type":"c1","uid":1490128,"ip_address":"","ucode":"4CA8A41F5107C7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJwHLLQK3AicN8XqichEbfqSACpRB5kry8bIMBcuB3bSiaeic9hABrmn7TZgqaWJ8Xc1gWh6icasZCt3Fg/132","comment_is_top":false,"comment_ctime":1616022932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616022932","product_id":100033601,"comment_content":"渲染进程的主线程执行任务都要先添加到消息队列？那js执行的同步代码也要先添加到消息对列？也就是说同步代码也是宏任务？","like_count":0},{"had_liked":false,"id":283352,"user_name":"张宗伟","can_delete":false,"product_type":"c1","uid":1374181,"ip_address":"","ucode":"1447A20C7A8982","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","comment_is_top":false,"comment_ctime":1615723736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615723736","product_id":100033601,"comment_content":"老师，针对 setTimeout 嵌套执行5次后会设置最小时间间隔为4ms，我有些疑问。我使用相同的代码，chrome浏览器，却发现前几次(不超过5次)都是 5ms，后面还有 2ms，之后才是 4ms。请问这是什么原因造成的呢？谢谢！<br>各位大佬有遇到过吗？能否评论下，谢谢！","like_count":0},{"had_liked":false,"id":283293,"user_name":"张宗伟","can_delete":false,"product_type":"c1","uid":1374181,"ip_address":"","ucode":"1447A20C7A8982","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","comment_is_top":false,"comment_ctime":1615694142,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615694142","product_id":100033601,"comment_content":"看完下面的精彩评论和老师的解答，学习了不少：<br>1. 延迟队列其实底层的存储结构是hashmap，等到执行这个结构的时候，会计算hashmap中的每个任务是否到期了，到期了就去执行，直到所有到期的任务都执行结束，才会进入下一轮循环。<br>2. requestAnimationFrame，是随着页面的刷新频率来执行的，通常是 60&#47;1s，不会进入消息队列或者延迟队列。但是也需要主线程去执行，所以如果传入requestAnimationFrame的callback执行时间太长，同样会阻塞其他的任务执行或者丢帧。<br>上面说的不一定对，欢迎大家指正。","like_count":0},{"had_liked":false,"id":277502,"user_name":"jarryLee","can_delete":false,"product_type":"c1","uid":1631921,"ip_address":"","ucode":"1392ED306DA5F2","user_header":"","comment_is_top":false,"comment_ctime":1612435416,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612435416","product_id":100033601,"comment_content":"个人理解：<br>渲染进程有主线程，宏任务队列，微任务队列，延时任务队列。主线程在执行一个宏任务后，会依次执行微任务中的任务。普通的宏任务是在满足执行条件之后加入宏任务队列的队尾，排队执行。而延时任务放在延时队列中，它的执行时机是在执行一个宏任务后且微任务队列已清空时，而不是按宏任务队列的顺序执行，可以理解为宏任务插队；","like_count":0},{"had_liked":false,"id":270759,"user_name":"kevinInsight","can_delete":false,"product_type":"c1","uid":1077414,"ip_address":"","ucode":"614B78965C5E10","user_header":"https://wx.qlogo.cn/mmopen/vi_32/6bCYR5TvPPNxBic9xBicXuyiaF0waeE71TTLRH0lM8OPnR0ibo40JlMplfmsuPuJevfxgbhDhFUqqp469lM3lGRqmg/0","comment_is_top":false,"comment_ctime":1609242508,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1609242508","product_id":100033601,"comment_content":"老师：请教下，下面这段代码每次执行结果不同？能分析下什么原因吗？<br><br>setTimeout(() =&gt;{<br>    console.log(2)<br>    setTimeout(() =&gt; {<br>       console.log(3)<br>    }, 99)<br>}, 100)<br>setTimeout(() =&gt; {<br>    console.log(1)<br>}, 200);","like_count":0},{"had_liked":false,"id":269464,"user_name":".7\\0","can_delete":false,"product_type":"c1","uid":2333006,"ip_address":"","ucode":"AC04CF998DDA37","user_header":"https://static001.geekbang.org/account/avatar/00/23/99/4e/03ad620e.jpg","comment_is_top":false,"comment_ctime":1608665051,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1608665051","product_id":100033601,"comment_content":"老师您好，我有一个小疑问，延时队列中的任务需要当前宏任务执行完成后执行，请问在执行延时队列中任务对应回调函数时如何是确定其自身的词法作用域、this的呢，在执行时与其执行上下文相关的上下文不应该已经被销毁了吗？","like_count":0,"discussions":[{"author":{"id":2114442,"avatar":"https://static001.geekbang.org/account/avatar/00/20/43/8a/9380fe92.jpg","nickname":"KeilingZhuang","note":"","ucode":"CDBA0336FE3E26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381586,"discussion_content":"闭包","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625133701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263105,"user_name":"snow","can_delete":false,"product_type":"c1","uid":1343414,"ip_address":"","ucode":"750FBF37CCFD86","user_header":"https://static001.geekbang.org/account/avatar/00/14/7f/b6/09efa8e5.jpg","comment_is_top":false,"comment_ctime":1606008434,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606008434","product_id":100033601,"comment_content":"老师我又有一个问题，可以帮我解答一下吗？问题：在一个按钮点击事件里面，有个定时器。首先这个点击事件被io线程封装成一个任务，放到了消息队列里面，渲染主线程执行这个任务的时候，看到有个定时器，此时主线程会把定时器任务再放到延迟队列吗？还是说完编译的时候，js引擎会将所有的定时器和对应关系，放到该放的地方？","like_count":0,"discussions":[{"author":{"id":1374181,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","nickname":"张宗伟","note":"","ucode":"1447A20C7A8982","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356873,"discussion_content":"执行的时候才放入吧。js编译也是执行这个函数才进行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615693402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":249537,"user_name":"聂成阳","can_delete":false,"product_type":"c1","uid":1388926,"ip_address":"","ucode":"BA339600C85E1D","user_header":"https://static001.geekbang.org/account/avatar/00/15/31/7e/ce1cf9b2.jpg","comment_is_top":false,"comment_ctime":1600686126,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1600686126","product_id":100033601,"comment_content":"异步延迟队列到期了会去执行，如果当前任务没有到期的话，是不是会开始下一轮循环，而不会在这一直等待它到期？","like_count":0},{"had_liked":false,"id":249444,"user_name":"佳期","can_delete":false,"product_type":"c1","uid":2195552,"ip_address":"","ucode":"A49D89C5CFA196","user_header":"","comment_is_top":false,"comment_ctime":1600659076,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600659076","product_id":100033601,"comment_content":"假如定时器计时完成的时候，点击按钮触发一个事件，这个时候，是先执行点击事件还是定时器回调呢？","like_count":0},{"had_liked":false,"id":241049,"user_name":"太白北路","can_delete":false,"product_type":"c1","uid":1516144,"ip_address":"","ucode":"3C7E54D38408A3","user_header":"https://static001.geekbang.org/account/avatar/00/17/22/70/ab911260.jpg","comment_is_top":false,"comment_ctime":1597158962,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1597158962","product_id":100033601,"comment_content":"requestAnimationFrame也是在主线程上进行循环的吧，这样的话，应该也是要加入事件队列里吧，在某一个任务挂起以后，还是会存在延迟吧","like_count":0,"discussions":[{"author":{"id":1374181,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","nickname":"张宗伟","note":"","ucode":"1447A20C7A8982","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356876,"discussion_content":"requestAnimationFrame 是随着页面的刷新率执行的，不加入事件队列。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615693494,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241048,"user_name":"太白北路","can_delete":false,"product_type":"c1","uid":1516144,"ip_address":"","ucode":"3C7E54D38408A3","user_header":"https://static001.geekbang.org/account/avatar/00/17/22/70/ab911260.jpg","comment_is_top":false,"comment_ctime":1597158756,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597158756","product_id":100033601,"comment_content":"setTimeout回调中的this，为什么要指向全局作用域，这样设计是基于什么原因吗，还是有什么好处？","like_count":0},{"had_liked":false,"id":240996,"user_name":"A君","can_delete":false,"product_type":"c1","uid":1940105,"ip_address":"","ucode":"FE96F089C2312C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9a/89/babe8b52.jpg","comment_is_top":false,"comment_ctime":1597145632,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597145632","product_id":100033601,"comment_content":"settiomout的机制很像是linux在处理中断处理程序，程序从注册上到被处理也是有延时，不同的是JavaScript delay的时间颗粒度可能会很大，它至少要等待一个事件处理结束才有可能被调度，如果该事件运行时间较长，而set time间隔较短就会产生overhead","like_count":0},{"had_liked":false,"id":235075,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1594885349,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594885349","product_id":100033601,"comment_content":"老师请问：<br>timeout最后一个this的问题，解决方案的关键不是箭头函数，而是使用MyObj.showName()替代this.showName()吧？也就是说这里不用箭头函数也是可以的，只要使用了MyObj.showName()","like_count":0},{"had_liked":false,"id":229441,"user_name":"luwei","can_delete":false,"product_type":"c1","uid":1365541,"ip_address":"","ucode":"0960A09F7B8D59","user_header":"https://static001.geekbang.org/account/avatar/00/14/d6/25/a95a2064.jpg","comment_is_top":false,"comment_ctime":1592996282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592996282","product_id":100033601,"comment_content":"老是说的&quot;比如有五个定时的任务到期了,那么会分别把这个五个定时器的任务执行掉，再开始下次循环过程！&quot;这个是不是不太对呢？在node环境下是这样的，但是在浏览器环境下不是这样的。<br>在浏览器环境下的事件循环机制是：一个task执行完毕，然后再执行所有的micro-task，一次事件循环就结束了。然后继续循环....<br>```<br>while (true) {<br>  宏任务队列.shift()<br>  微任务队列全部任务()<br>}<br>```<br>在node环境下的事件循环机制是：<br>```<br>while (true) {<br>  loop.forEach((阶段) =&gt; {<br>    阶段全部任务()<br>    nextTick全部任务()<br>    microTask全部任务()<br>  })<br>  loop = loop.next<br>```<br><br>以下代码<br>```<br>setTimeout(() =&gt; {<br>  console.log(&#39;setTimeout 1&#39;)<br>  Promise.resolve().then(() =&gt; {<br>    console.log(&#39;promise 1&#39;)<br>  })<br>}, 0)<br>setTimeout(() =&gt; {<br>  console.log(&#39;setTimeout 2&#39;)<br>  Promise.resolve().then(() =&gt; {<br>    console.log(&#39;promise 2&#39;)<br>  })<br>}, 0)<br>```<br>在node环境下的打印结果是：<br>setTimeout 1<br>setTimeout 2<br>promise 1<br>promise 2<br>但在浏览器环境下是<br>setTimeout 1<br>promise 1<br>setTimeout 2<br>promise 2","like_count":0},{"had_liked":false,"id":229294,"user_name":"静心","can_delete":false,"product_type":"c1","uid":1335457,"ip_address":"","ucode":"EB264FA6519FDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","comment_is_top":false,"comment_ctime":1592960467,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1592960467","product_id":100033601,"comment_content":"关于这节课，有个地方没太明白：普通队列和延时队列的消费是在同一个线程中消费的吗？","like_count":0},{"had_liked":false,"id":225069,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1591628622,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1591628622","product_id":100033601,"comment_content":"使用 requestAnimationFrame 不需要设置具体的时间，由系统来决定回调函数的执行时间，requestAnimationFrame 里面的回调函数是在页面下一次渲染之前执行，它跟着屏幕（计算机设备）的刷新频率走，因为屏幕的画面是按照一帧一帧连接渲染出来的，假如电脑的刷新频率是60HZ，那相当于是平均每16.66666667ms刷新一次屏幕，保证每个刷新间隔只执行一次，只是我们肉眼看不到而已，如果页面未激活的话，requestAnimationFrame 也会停止渲染，这样既可以保证页面的流畅性，又能节省主线程执行函数的开销","like_count":0},{"had_liked":false,"id":218231,"user_name":"sh","can_delete":false,"product_type":"c1","uid":1428920,"ip_address":"","ucode":"720991D01D50D9","user_header":"https://static001.geekbang.org/account/avatar/00/15/cd/b8/14597b01.jpg","comment_is_top":false,"comment_ctime":1589763306,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589763306","product_id":100033601,"comment_content":"所以定时器是一个单独的线程吗","like_count":0},{"had_liked":false,"id":213335,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1588388564,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1588388564","product_id":100033601,"comment_content":"请教老师：<br>1.事件循环会不停的从队列中取消息的时间间隔是多少呢？因为不可能是如老师简化的一个for的死循环吧<br>2.如果一次循环中事件处理时间过长，会有相关的超时处理机制吗？","like_count":0,"discussions":[{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255585,"discussion_content":"五一快乐","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1588413239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212298,"user_name":"Everlaa","can_delete":false,"product_type":"c1","uid":1708271,"ip_address":"","ucode":"9B4FFFABD62B07","user_header":"https://static001.geekbang.org/account/avatar/00/1a/10/ef/4c9b2383.jpg","comment_is_top":false,"comment_ctime":1588084961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588084961","product_id":100033601,"comment_content":"老师，想问一下setInterval的入队机制是怎样的？<br>我的想法是可以写成setTimeout先入队一个宏任务，然后执行这个回调的时候可以再创建一个宏任务入队？<br>还是setInterval执行的时候已经入队n个宏任务了？<br>如果理解有偏差还请老师指点一下，谢谢","like_count":0},{"had_liked":false,"id":206030,"user_name":"旺旺","can_delete":false,"product_type":"c1","uid":1159196,"ip_address":"","ucode":"FE2CF90F446BFB","user_header":"https://static001.geekbang.org/account/avatar/00/11/b0/1c/2e30eeb8.jpg","comment_is_top":false,"comment_ctime":1586776023,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1586776023","product_id":100033601,"comment_content":"问个外行问题，为啥setTimeout是WebAPI呢？","like_count":0,"discussions":[{"author":{"id":1503447,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f0/d7/82a2ffd4.jpg","nickname":"bingmo","note":"","ucode":"F92171460C0EA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284828,"discussion_content":"因为这个不是属于javascript规范里要求的，是浏览器自己实现的一个API","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592654726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255592,"discussion_content":"封装好可以直接调用的方法，由浏览器来调用这个定时器","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588413776,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204277,"user_name":"沧海一声笑","can_delete":false,"product_type":"c1","uid":1039904,"ip_address":"","ucode":"5297F2F4736B63","user_header":"https://static001.geekbang.org/account/avatar/00/0f/de/20/03130a39.jpg","comment_is_top":false,"comment_ctime":1586359024,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1586359024","product_id":100033601,"comment_content":"&lt;body&gt;<br>    &lt;h1&gt;hello JavaScript&lt;&#47;h1&gt;<br>    &lt;script&gt;<br>            console.log(&quot;script start&quot;)<br>            new Promise((resolve,reject)=&gt;{<br>                resolve(&quot;promise1&quot;)<br>            }).then(()=&gt;{<br>                console.log(&quot;promise1 then&quot;)<br>                setTimeout(()=&gt;{<br>                console.log(&quot;setTimeout4&quot;)<br>            },0)<br>            })<br>            console.log(&quot;script脚本即将执行结束🔚&quot;)<br>            setTimeout(()=&gt;{<br>                console.log(&quot;setTimeout1&quot;)<br>            },0) <br>            setTimeout(()=&gt;{<br>                console.log(&quot;setTimeout3&quot;)<br>            },0)<br>    &lt;&#47;script&gt;<br>    &lt;script&gt;<br>            console.log(&quot;script end&quot;)<br>            setTimeout(()=&gt;{<br>                console.log(&quot;setTimeout2&quot;)<br>            },0)<br>    &lt;&#47;script&gt;<br>    &lt;script&gt;<br>        console.log(&quot;last script&quot;)<br>    &lt;&#47;script&gt;<br>    &lt;span&gt;111&lt;&#47;span&gt;<br>&lt;&#47;body&gt;<br>求老师解答下","like_count":0,"discussions":[{"author":{"id":1910075,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/25/3b/a971fc8e.jpg","nickname":"阿感","note":"","ucode":"7BCB7E44A832D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":255716,"discussion_content":"好像宏任务和微任务也是有顺序的，一对script是一个宏任务，优先级高于setTimeout\nhttps://juejin.im/post/5bc1adc45188255c82553921\n等我找更多资料了解了解再说","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588424719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196843,"user_name":"墨灵","can_delete":false,"product_type":"c1","uid":1409700,"ip_address":"","ucode":"185D70CA20BEEE","user_header":"https://static001.geekbang.org/account/avatar/00/15/82/a4/a92c6eca.jpg","comment_is_top":false,"comment_ctime":1585317328,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1585317328","product_id":100033601,"comment_content":"延时队列本质应该是一个id=&gt;DelayTask的hashmap？这样可以简单地通过一个id去删除延时任务。<br>还有一个问题，延时任务是在宏任务之后才执行的，如果宏任务队列都是空的话，那延时任务还会不会执行？不过这种情况应该也是不存在的，引擎也会产生定时的垃圾回收宏任务。","like_count":0,"discussions":[{"author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223663,"discussion_content":"消息队列是一直循环去查找执行的，所以就算空了，也会去循环查找，顺便看看延迟队列有没有到期的任务需要执行。\n不过这里有个问题，也是前几章看到另一个人提的问题，消息队列什么时候会停止？一直循环会不会很占内存？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586244548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169873,"user_name":"肥嘟嘟左卫门","can_delete":false,"product_type":"c1","uid":1358889,"ip_address":"","ucode":"BA6D8E04C6B2CE","user_header":"https://static001.geekbang.org/account/avatar/00/14/bc/29/c248bfd1.jpg","comment_is_top":false,"comment_ctime":1578466355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578466355","product_id":100033601,"comment_content":"老师，这个延时队列里面的任务的执行时机还是有点懵，意思是每执行完一个消息队列中的任务就要去计算一下那边延时队列中是否有快要到期的延时任务吗？","like_count":0},{"had_liked":false,"id":158987,"user_name":"玉皇大亮","can_delete":false,"product_type":"c1","uid":1019849,"ip_address":"","ucode":"5C4FDF1FDCF8A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/c9/833d5060.jpg","comment_is_top":false,"comment_ctime":1575511228,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1575511228","product_id":100033601,"comment_content":"setTimeout总结：<br>浏览器怎么实现setTimeout？<br>在消息循环系统中，除了有任务处理队列，还有延时处理队列，浏览器将待延时的任务放在延时处理队列中<br>setTimeout使用注意事项：<br>1.如果当前执行任务时间过久，会影响延时任务的执行<br>2.如果setTimeout存在嵌套调用，系统回存在4ms的延时<br>3.未激活的页面下用的延时最小为1000ms，出于加载性能损耗以及降低耗电量<br>4.chrome、safari、firefox中最大延时为2147483647ms，如果超过这个阈值，那么溢出，延时为0，立即执行<br>5.setTimeout中的this不符合直觉，处理需要用箭头函数或者bind来强制改变this指向","like_count":0},{"had_liked":false,"id":158634,"user_name":"海之蓝心","can_delete":false,"product_type":"c1","uid":1098193,"ip_address":"","ucode":"C15210C86CDC13","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLReFZCZAq532WRg5Bjabx1WX997t0EVnsrLYcBnsNZDaDjk5jHvKDfRibjwibVjqtlm7S3eBJkwPtg/132","comment_is_top":false,"comment_ctime":1575425188,"is_pvip":false,"replies":[{"id":"60704","content":"和setTimeout一样的","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1575426933,"ip_address":"","comment_id":158634,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575425188","product_id":100033601,"comment_content":"老师，如果setInterval是怎么执行，是在延时队列还是微任务","like_count":0,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476788,"discussion_content":"和setTimeout一样的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575426933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098193,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLReFZCZAq532WRg5Bjabx1WX997t0EVnsrLYcBnsNZDaDjk5jHvKDfRibjwibVjqtlm7S3eBJkwPtg/132","nickname":"海之蓝心","note":"","ucode":"C15210C86CDC13","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":76781,"discussion_content":"老师，我的主要疑问是setInterval也会到延时列表中，当前任务执行完后根据设置的时间执行，那下次的执行是在下一个宏任务执行完后执行对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575854028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148497,"user_name":"","can_delete":false,"product_type":"c1","uid":1725340,"ip_address":"","ucode":"","user_header":"","comment_is_top":false,"comment_ctime":1573019538,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1573019538","product_id":100033601,"comment_content":"“这里我们要重点关注它的执行时机，在上段代码中，处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。”这里的意思是每执行一个宏任务就去检查异步队列，如果有 setTimeout 任务到期就执行。这里确定是执行吗？而不是将它们加入消息队列？","like_count":0,"discussions":[{"author":{"id":1480732,"avatar":"https://static001.geekbang.org/account/avatar/00/16/98/1c/d7a1439e.jpg","nickname":"KaKaKa","note":"","ucode":"07D1980A71F321","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223661,"discussion_content":"有答案了回复我一下，同问~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586244308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1098566,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c3/46/308c3958.jpg","nickname":"不蒸馒头","note":"","ucode":"EB26EC2B9CFC6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543964,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641367548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":141431,"user_name":"Andy Jiang","can_delete":false,"product_type":"c1","uid":1227279,"ip_address":"","ucode":"436609A0A445CF","user_header":"https://static001.geekbang.org/account/avatar/00/12/ba/0f/9789c2cc.jpg","comment_is_top":false,"comment_ctime":1571152060,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571152060","product_id":100033601,"comment_content":"一次循环里消息队列中的宏任务和延迟队列中的宏任务会各执行一个么？之前学习到的是一次循环只会执行一个宏任务，和老师讲的冲突了，有点懵","like_count":0},{"had_liked":false,"id":137513,"user_name":"Djan Unchained","can_delete":false,"product_type":"c1","uid":1387997,"ip_address":"","ucode":"FB5A37B0EE3E98","user_header":"https://static001.geekbang.org/account/avatar/00/15/2d/dd/f2e79297.jpg","comment_is_top":false,"comment_ctime":1569757087,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569757087","product_id":100033601,"comment_content":"普通消息队列和延迟执行队列的执行顺序是怎样的？执行完普通消息队列中的一个宏任务，就去查看延迟执行队列中是否有到期任务？有就先执行完延迟执行队列中的到期任务，没有就执行普通消息队列中的下一个宏任务？","like_count":0},{"had_liked":false,"id":137371,"user_name":"哪吒闹海","can_delete":false,"product_type":"c1","uid":1622684,"ip_address":"","ucode":"E0172967AE44AD","user_header":"https://wx.qlogo.cn/mmopen/vi_32/2iaMBjrfmDku5r5CyWA2O8EITxqhp9yMARSH76rtWV9944mDM3yac2COVOkFjYqdOj3fv3Y9h0d0icAQdLDV1aicA/132","comment_is_top":false,"comment_ctime":1569724885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569724885","product_id":100033601,"comment_content":"处理完消息队列的一个任务后才开始执行ProcessDelayTask,老师，我理解的不应该是执行完所有的任务后才去执行延时队列中的任务吗？","like_count":0},{"had_liked":false,"id":135250,"user_name":"AICC","can_delete":false,"product_type":"c1","uid":1020746,"ip_address":"","ucode":"C1D18B1E8B2DCE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/4a/de82f373.jpg","comment_is_top":false,"comment_ctime":1569084530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1569084530","product_id":100033601,"comment_content":"概括一下学习完后我对定时器的理解：<br>在浏览器渲染进程之外，可假定有一个定时器线程，用来管理定时器的延迟任务队列，这个任务队列会在每一次的事件循环中执行完消息队列的任务后被执行，所以影响到定时器执行的时间节点有两个，一是在当前执行线程中定时器被创建，进入下一个事件循环中，如果当前任务的执行时间过长，势必影响下一个事件循环中延迟队列的执行（因为定时器在当前执行任务中就开始计时）；二是，当下一次事件循环到来，如果在延迟队列被执行之前，有消息队列中的任务，那消息队列的任务是先执行，它的执行时间会影响到延迟队列的执行，只在当本轮的消息队列执行结束了，并且延迟队列中，有符合条件的定时器任务，这时定时器回调才会被执行","like_count":0},{"had_liked":false,"id":133593,"user_name":"拖鞋","can_delete":false,"product_type":"c1","uid":1089424,"ip_address":"","ucode":"09985C731090A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/9f/90/4656119a.jpg","comment_is_top":false,"comment_ctime":1568616860,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1568616860","product_id":100033601,"comment_content":"老师 requestAnimationFrame 有没有在非激活页也被调整间隔的问题呢？","like_count":0,"discussions":[{"author":{"id":1374181,"avatar":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","nickname":"张宗伟","note":"","ucode":"1447A20C7A8982","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356863,"discussion_content":"会被暂停","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615692416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133576,"user_name":"x","can_delete":false,"product_type":"c1","uid":1472233,"ip_address":"","ucode":"75FA829EA820AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/76/e9/73ed6cc1.jpg","comment_is_top":false,"comment_ctime":1568612184,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1568612184","product_id":100033601,"comment_content":"所以在消息队列中setTimeout并不能准时开始任务，需要等上一个任务完成？","like_count":0},{"had_liked":false,"id":133198,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1568440781,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1568440781","product_id":100033601,"comment_content":"在上面用 PerFormance 分析代码的执行时间，是需要把对应的代码写到 html 中，然后在用浏览器打开分析吗？<br>能不能任意打开一个页面打开控制台，把需要分析的代码在console 中执行，然后利用 PerFormance 进行分析的？","like_count":0},{"had_liked":false,"id":132549,"user_name":"abson","can_delete":false,"product_type":"c1","uid":1517591,"ip_address":"","ucode":"ED6E65CB4221AE","user_header":"https://static001.geekbang.org/account/avatar/00/17/28/17/2ee45db9.jpg","comment_is_top":false,"comment_ctime":1568164735,"is_pvip":false,"replies":[{"id":"50918","content":"<br>后面三节分别是：<br><br>微任务：MutationObserver<br>Promise <br>await&#47;async","user_name":"作者回复","user_name_real":"李兵","uid":"1141464","ctime":1568278738,"ip_address":"","comment_id":132549,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1568164735","product_id":100033601,"comment_content":"老师讲一下宏任务和微任务呗","like_count":0,"discussions":[{"author":{"id":1141464,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6a/d8/228449c9.jpg","nickname":"李兵","note":"","ucode":"3F3D3F6E20209E","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467001,"discussion_content":"\n后面三节分别是：\n\n微任务：MutationObserver\nPromise \nawait/async","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568278738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1624506,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/ba/f50e9ea4.jpg","nickname":"潘启宝","note":"","ucode":"8E697C7164F2E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9463,"discussion_content":"前面有讲过了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568170729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132544,"user_name":"子曰","can_delete":false,"product_type":"c1","uid":1161256,"ip_address":"","ucode":"34127192DD8876","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/28/8c83d109.jpg","comment_is_top":false,"comment_ctime":1568163923,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1568163923","product_id":100033601,"comment_content":"请问老师，未激活的页面这里具体指的是什么","like_count":0,"discussions":[{"author":{"id":1624506,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/ba/f50e9ea4.jpg","nickname":"潘启宝","note":"","ucode":"8E697C7164F2E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9466,"discussion_content":"就是你打开好多个页面或者标签，而你当前只看一个标签，其他的标签就是未激活的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568170800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1446810,"avatar":"https://static001.geekbang.org/account/avatar/00/16/13/9a/842a9dc6.jpg","nickname":"求求你，别卷了！","note":"","ucode":"8F7DE1DF8A0B29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1624506,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/ba/f50e9ea4.jpg","nickname":"潘启宝","note":"","ucode":"8E697C7164F2E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391861,"discussion_content":"错了，是未打开的页面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630662329,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9466,"ip_address":""},"score":391861,"extra":""},{"author":{"id":1446810,"avatar":"https://static001.geekbang.org/account/avatar/00/16/13/9a/842a9dc6.jpg","nickname":"求求你，别卷了！","note":"","ucode":"8F7DE1DF8A0B29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1624506,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c9/ba/f50e9ea4.jpg","nickname":"潘启宝","note":"","ucode":"8E697C7164F2E0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391863,"discussion_content":"我觉得应该是打开的标签切换有刷新，那其他标签就是未激活","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630662685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9466,"ip_address":""},"score":391863,"extra":""}]}]}]}