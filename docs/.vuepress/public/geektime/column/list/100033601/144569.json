{"id":144569,"title":"26 | 虚拟DOM：虚拟DOM和实际的DOM有何不同？","content":"<p>虚拟DOM是最近非常火的技术，两大著名前端框架React和Vue都使用了虚拟DOM，所以我觉得非常有必要结合浏览器的工作机制对虚拟DOM进行一次分析。当然了，React和Vue框架本身所蕴含的知识点非常多，而且也不是我们专栏的重点，所以在这里我们还是把重心聚焦在虚拟DOM上。</p><p>在本文我们会先聊聊DOM的一些缺陷，然后在此基础上介绍虚拟DOM是如何解决这些缺陷的，最后再站在双缓存和MVC的视角来聊聊虚拟DOM。理解了这些会让你对目前的前端框架有一个更加底层的认识，这也有助于你更好地理解这些前端框架。</p><h2>DOM的缺陷</h2><p>通过前面一系列文章的学习，你对DOM的生成过程应该已经有了比较深刻的理解，并且也知道了通过JavaScript操纵DOM是会影响到整个渲染流水线的。另外，DOM还提供了一组JavaScript接口用来遍历或者修改节点，这套接口包含了getElementById、removeChild、appendChild等方法。</p><p>比如，我们可以调用<code>document.body.appendChild(node)</code>往body节点上添加一个元素，调用该API之后会引发一系列的连锁反应。首先渲染引擎会将node节点添加到body节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为<strong>重排</strong>。除了重排之外，还有可能引起<strong>重绘</strong>或者<strong>合成</strong>操作，形象地理解就是“<strong>牵一发而动全身</strong>”。另外，对于DOM的不当操作还有可能引发<strong>强制同步布局</strong>和<strong>布局抖动</strong>的问题，这些操作都会大大降低渲染效率。因此，对于DOM的操作我们时刻都需要非常小心谨慎。</p><!-- [[[read_end]]] --><p>当然，对于简单的页面来说，其DOM结构还是比较简单的，所以以上这些操作DOM的问题并不会对用户体验产生太多影响。但是对于一些复杂的页面或者目前使用非常多的单页应用来说，其DOM结构是非常复杂的，而且还需要不断地去修改DOM树，每次操作DOM渲染引擎都需要进行重排、重绘或者合成等操作，因为DOM结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。</p><p>所以我们需要有一种方式来减少JavaScript对DOM的操作，这时候虚拟DOM就上场了。</p><h2>什么是虚拟DOM</h2><p>在谈论什么是虚拟DOM之前，我们先来看看虚拟DOM到底要解决哪些事情。</p><ul>\n<li>将页面改变的内容应用到虚拟DOM上，而不是直接应用到DOM上。</li>\n<li>变化被应用到虚拟DOM上时，虚拟DOM并不急着去渲染页面，而仅仅是调整虚拟DOM的内部状态，这样操作虚拟DOM的代价就变得非常轻了。</li>\n<li>在虚拟DOM收集到足够的改变时，再把这些变化一次性应用到真实的DOM上。</li>\n</ul><p>基于以上三点，我们再来看看什么是虚拟DOM。为了直观理解，你可以参考下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/90/cf2089ad62af94881757c2f2de277890.png?wh=1142*368\" alt=\"\"></p><center><span class=\"reference\">虚拟DOM执行流程</span></center><p>该图是我结合React流程画的一张虚拟DOM执行流程图，下面我们就结合这张图来分析下虚拟DOM到底怎么运行的。</p><ul>\n<li><strong>创建阶段</strong>。首先依据JSX和基础数据创建出来虚拟DOM，它反映了真实的DOM树的结构。然后由虚拟DOM树创建出真实DOM树，真实的DOM树生成完后，再触发渲染流水线往屏幕输出页面。</li>\n<li><strong>更新阶段</strong>。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟DOM树；然后React比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的DOM树上；最后渲染引擎更新渲染流水线，并生成新的页面。</li>\n</ul><p>既然聊到虚拟DOM的更新，那我们就不得不聊聊最新的<strong>React Fiber更新机制</strong>。通过上图我们知道，当有数据更新时，React会生成一个新的虚拟DOM，然后拿新的虚拟DOM和之前的虚拟DOM进行比较，这个过程会找出变化的节点，然后再将变化的节点应用到DOM上。</p><p>这里我们重点关注下比较过程，最开始的时候，比较两个虚拟DOM的过程是在一个递归函数里执行的，其<strong>核心算法是reconciliation</strong>。通常情况下，这个比较过程执行得很快，不过当虚拟DOM比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。为了解决这个问题，React团队重写了reconciliation算法，新的算法称为Fiber reconciler，之前老的算法称为Stack reconciler。</p><p>在前面<a href=\"https://time.geekbang.org/column/article/137827\">《20 | async/await：使用同步的方式去写异步代码》</a>那篇文章中我们介绍了协程，其实协程的另外一个称呼就是Fiber，所以在这里我们可以把Fiber和协程关联起来，那么所谓的Fiber reconciler相信你也很清楚了，就是在执行算法的过程中出让主线程，这样就解决了Stack reconciler函数占用时间过久的问题。至于具体的实现过程在这里我就不详细分析了，如果感兴趣的话，你可以自行查阅相关资料进行学习。</p><p>了解完虚拟DOM的大致执行流程，你应该也就知道为何需要虚拟DOM了。不过以上都从单纯的技术视角来分析虚拟DOM的，那接下来我们再从双缓存和MVC模型这两个视角来聊聊虚拟DOM。</p><h3>1. 双缓存</h3><p>在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。</p><p>而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</p><p>在这里，你可以把虚拟DOM看成是DOM的一个buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到DOM上，这样就能减少一些不必要的更新，同时还能保证DOM的稳定输出。</p><h3>2. MVC模式</h3><p>到这里我们了解了虚拟DOM是一种类似双缓存的实现。不过如果站在技术角度来理解虚拟缓存，依然不能全面理解其含义。那么接下来我们再来看看虚拟DOM在MVC模式中所扮演的角色。</p><p>在各大设计模式当中，MVC是一个非常重要且应用广泛的模式，因为它能将数据和视图进行分离，在涉及到一些复杂的项目时，能够大大减轻项目的耦合度，使得程序易于维护。</p><p>关于MVC的基础结构，你可以先参考下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/a6/4c03b5882878dcce2df01c1e2e8db8a6.png?wh=1142*617\" alt=\"\"></p><center><span class=\"reference\">MVC基础结构</span></center><p>通过上图你可以发现，MVC的整体结构比较简单，由模型、视图和控制器组成，其<strong>核心思想就是将数据和视图分离</strong>，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。当然还可以根据不同的通信路径和控制器不同的实现方式，基于MVC又能衍生出很多其他的模式，如MVP、MVVM等，不过万变不离其宗，它们的基础骨架都是基于MVC而来。</p><p>所以在分析基于React或者Vue这些前端框架时，我们需要先重点把握大的MVC骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析React项目时，我们可以把React的部分看成是一个MVC中的视图，在项目中结合Redux就可以构建一个MVC的模型结构，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e0/03/e024ba6c212a1d6bfa01b327e987e103.png?wh=1142*400\" alt=\"\"></p><center><span class=\"reference\">基于React和Redux构建MVC模型</span></center><p>在该图中，我们可以把虚拟DOM看成是MVC的视图部分，其控制器和模型都是由Redux提供的。其具体实现过程如下：</p><ul>\n<li>图中的控制器是用来监控DOM的变化，一旦DOM发生变化，控制器便会通知模型，让其更新数据；</li>\n<li>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；</li>\n<li>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟DOM；</li>\n<li>新的虚拟DOM生成好之后，就需要与之前的虚拟DOM进行比较，找出变化的节点；</li>\n<li>比较出变化的节点之后，React将变化的虚拟节点应用到DOM上，这样就会触发DOM节点的更新；</li>\n<li>DOM节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。</li>\n</ul><p>在实际工程项目中，你需要学会分析出这各个模块，并梳理出它们之间的通信关系，这样对于任何框架你都能轻松上手了。</p><h2>总结</h2><p>好了，今天就介绍到这里，下面我来总结下本文的主要内容。</p><p>首先我们分析了直接操作DOM会触发渲染流水线的一系列反应，如果对DOM操作不当的话甚至还会触发强制同步布局和布局抖动的问题，这也是我们在操作DOM时需要非常小心谨慎的原因。</p><p>在此分析的基础上，我们介绍了虚拟DOM是怎么解决直接操作DOM所带来的问题以及React Fiber更新机制。</p><p>要聊前端框架，就绕不开设计模式，所以接下来我们又从双缓存和MVC角度分析了虚拟DOM。双缓存是一种经典的思路，应用在很多场合，能解决页面无效刷新和闪屏的问题，虚拟DOM就是双缓存思想的一种体现。而基于MVC的设计思想也广泛地渗透到各种场合，并且基于MVC又衍生出了很多其他模式（如MVP、MVVM等），不过万变不离其宗，它们的基础骨架都是基于MVC而来。站在MVC视角来理解虚拟DOM能让你看到更为“广阔的世界”。</p><h2>思考时间</h2><p>今天留给你的思考题是：虚拟DOM都解决了哪些问题？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","comments":[{"had_liked":false,"id":138145,"user_name":"mfist","can_delete":false,"product_type":"c1","uid":1373624,"ip_address":"","ucode":"4F99F422C23FB4","user_header":"https://static001.geekbang.org/account/avatar/00/14/f5/b8/9f165f4b.jpg","comment_is_top":false,"comment_ctime":1570065361,"is_pvip":false,"discussion_count":10,"race_medal":0,"score":"126124116945","product_id":100033601,"comment_content":"1. 频繁更新dom引起的性能问题<br>2. 将真实DOM和js操作解耦，减少js操作dom复杂性。<br>老师答疑的时候可以介绍下react的fiber吗？感觉李老师的文章通俗易懂，很受益（网上文章分析参差不齐的）<br>今日总结：<br>为什么会出现虚拟DOM？javascript直接操作DOM可能会引起重排 重绘等操作（强制同步布局和布局抖动）引起性能问题。这是需要一个中间层来优化dom的操作（批量更新dom，优化更新dom细节），虚拟DOM就呼之欲出了。之后从双缓存和MVC模型的角度来解析了虚拟DOM。<br>","like_count":30,"discussions":[{"author":{"id":1437967,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/0f/8b36016d.jpg","nickname":"陈十二","note":"","ucode":"09D901552ABA78","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":80741,"discussion_content":"其实虚拟 DOM 主要是一个抽象层，用以描述视图，抽象视图变化，诞生主要目的是跨平台。所以才有 React Native，weex。解决 js 操作 dom 性能问题只是附带的，而且虚拟 DOM 是有代价的，在页面结构简单操作也简单的情况下相对 js 操作 DOM 并不一定会有优势。","likes_number":25,"is_delete":false,"is_hidden":false,"ctime":1576193250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1394238,"avatar":"https://static001.geekbang.org/account/avatar/00/15/46/3e/f9ae9462.jpg","nickname":"盖世英雄","note":"","ucode":"50CD6CCD4D8B76","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1437967,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/0f/8b36016d.jpg","nickname":"陈十二","note":"","ucode":"09D901552ABA78","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213418,"discussion_content":"回答的不错，虚拟DOM的主要目的是跨平台，解决DOM操作性能是次要的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1585074067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80741,"ip_address":""},"score":213418,"extra":""},{"author":{"id":1243584,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f9/c0/20b4a205.jpg","nickname":"啊哈哈","note":"","ucode":"A8542946C03707","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1437967,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/0f/8b36016d.jpg","nickname":"陈十二","note":"","ucode":"09D901552ABA78","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333298,"discussion_content":"正解！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607496805,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80741,"ip_address":""},"score":333298,"extra":""},{"author":{"id":2159152,"avatar":"https://static001.geekbang.org/account/avatar/00/20/f2/30/5b677e8d.jpg","nickname":"Yvan","note":"","ucode":"DA5BB215E65ED3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1437967,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/0f/8b36016d.jpg","nickname":"陈十二","note":"","ucode":"09D901552ABA78","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542256,"discussion_content":"发明之初就是为了解决性能问题，跨平台才是附带的。不然你给我解释一下react 和 react native 诞生的先后顺序。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1640692221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":80741,"ip_address":""},"score":542256,"extra":""}]},{"author":{"id":1473520,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7b/f0/269139d5.jpg","nickname":"Cris","note":"","ucode":"F8A287134F1078","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":30196,"discussion_content":"Fiber 的做法是：分片。\n\n把一个很耗时的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。而维护每一个分片的数据结构， 就是Fiber。","likes_number":18,"is_delete":false,"is_hidden":false,"ctime":1570804321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":2033513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/07/69/43cf2251.jpg","nickname":"Alan He","note":"","ucode":"A0780F4619D388","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1473520,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7b/f0/269139d5.jpg","nickname":"Cris","note":"","ucode":"F8A287134F1078","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356104,"discussion_content":"JS整体不是单线程吗。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615532939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":30196,"ip_address":""},"score":356104,"extra":""},{"author":{"id":1863552,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zFOVquVttt7aTLtyHhPvH1SCUk19Rd14XoGz9QrCpFefwun86CdBJB4rbsY1M5zywXHibvRs4EqJLoUjpNyknFQ/132","nickname":"v8","note":"","ucode":"22FE67E8C124DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2033513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/07/69/43cf2251.jpg","nickname":"Alan He","note":"","ucode":"A0780F4619D388","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366922,"discussion_content":"单线程并不影响任务的分片执行呀，你就可以理解为将10个任务分为一个一个的小任务，执行完一个小任务后就让出主线程，让其他的任务执行，待其他任务执行完再继续执行接下来的9个小任务。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1618218296,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":356104,"ip_address":""},"score":366922,"extra":""},{"author":{"id":1359476,"avatar":"https://static001.geekbang.org/account/avatar/00/14/be/74/0d900ed9.jpg","nickname":"Tristan","note":"","ucode":"DC454E16AAA66A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2033513,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/07/69/43cf2251.jpg","nickname":"Alan He","note":"","ucode":"A0780F4619D388","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552635,"discussion_content":"协程，可以看下那个生成器的设计原理，主要在协程之间控制权的转交。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645534337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":356104,"ip_address":""},"score":552635,"extra":""}]},{"author":{"id":1623567,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/0f/3937645e.jpg","nickname":"NBE01","note":"","ucode":"DF0D22D4495D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28405,"discussion_content":"fiber 其实和浏览器的渲染流程一样，把整个一坨的js执行代码，进行小任务划分，划分之后，按照小任务执行，中间的执行可以释放出来main thread，释放出来的main thread进行执行 浏览器的 其他任务执行，比方paint \\ update layer 等操作， 这样不会因为一致执行大段的js代码导致 block住主线程，导致整个页面卡死。 ","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1570695050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1394238,"avatar":"https://static001.geekbang.org/account/avatar/00/15/46/3e/f9ae9462.jpg","nickname":"盖世英雄","note":"","ucode":"50CD6CCD4D8B76","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213417,"discussion_content":"虚拟DOM解决了跨平台问题，还有虚拟DOM也是一种分层设计思维","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1585073846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295112,"user_name":"张宗伟","can_delete":false,"product_type":"c1","uid":1374181,"ip_address":"","ucode":"1447A20C7A8982","user_header":"https://static001.geekbang.org/account/avatar/00/14/f7/e5/ec543f3b.jpg","comment_is_top":false,"comment_ctime":1622251727,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"91816564943","product_id":100033601,"comment_content":"虚拟DOM的出现根本意义上不是为了解决 js 频繁操作DOM而引起的性能问题，因为如果通过 js 来操作DOM，那么无论用什么方式，多少动作都需要执行，虚拟DOM并没有减少操作。虚拟DOM的意义在于改变了开发模式，之前是需要手动管理DOM，数据和DOM操作糅合在一起，开发效率低下；之后是使用框架&#47;库自动管理DOM，数据驱动DOM的更新，只需要关注数据的变化即可。但是这会遇到一个问题，就是当数据改变时，框架需要更新全部的DOM吗？显然这是不可接受的，js 操作DOM的代价很高，所以当数据变化时并不直接对DOM进行更新，而是先对应在虚拟DOM上，通过与之前的虚拟DOM进行比较，确定需要更新的变动，然后在对应在真实的DOM上。","like_count":22,"discussions":[{"author":{"id":2211363,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoWoXojHwtbL72K6oXgbiaThl5UuNlkNyWFpw5klRzQ7RhIhNOXtkgmH4h4d0AyWShk2D41emXM5PQ/132","nickname":"玲珑佩","note":"","ucode":"57FEC507F8DEDB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378407,"discussion_content":"点赞，尤大讲过，极大的提升了开发效率，同时，又提供不错的性能","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1623210928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1390128,"avatar":"https://static001.geekbang.org/account/avatar/00/15/36/30/13e42374.jpg","nickname":"Yancey","note":"","ucode":"4276EA235F7BB7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566702,"discussion_content":"数据驱动; 从命令式变成声明式.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650730905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2004749,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIib8v6esIeeiaRbts7jrGQdFJpvE3Umm5GYibespJLBaZhiacXDplWMOafo5Q0f0LLZeA794d2EBYhNw/132","nickname":"王泽龙","note":"","ucode":"7C5B0F2F67FD2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391949,"discussion_content":"js 操作dom 是会生成一个新的dom替换之前旧的dom？\n 而通过虚拟dom 只是在原来的dom上做一些替换操作？？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630727924,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167190,"user_name":"AMIR","can_delete":false,"product_type":"c1","uid":1782777,"ip_address":"","ucode":"65142D9669071B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/33/f9/50b76abe.jpg","comment_is_top":false,"comment_ctime":1577712068,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"61707254212","product_id":100033601,"comment_content":"老师，我用js文件里面操作dom原生操作，不也是这个js文件执行完，也就是所有的dom原生操作都做完，才统一渲染页面么？我觉得虚拟dom只是对比innerHtml更有优势，并且屏蔽了原生的操作，可以使更多人来使用数据驱动视图，而不必要去操作麻烦的原生操作，就从效率来说，虚拟dom肯定比原生的差啊，虚拟dom对比完了，不还是得调用原生的操作么？他至少比原生多了diff算法的时间，麻烦老师解答下，提了挺多问题了，老师有空看一下","like_count":15,"discussions":[{"author":{"id":2015986,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c2/f2/b3b349a4.jpg","nickname":"OOP","note":"","ucode":"FA536DFBF793F8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295979,"discussion_content":"你说的有一定的道理，所以就有项目的技术选型这么一出，简单的项目可以使用原生来写，因为操作真实DOM性能没有很多人说的那样不堪，不然JQ也不会活那么久。但是当项目或者页面数据复杂到一定程度的时候，DOM操作变得多且繁杂的时候，虚拟DOM的优势也愈发明显，他会在DOM的整体操作之前去做一个diff算法，尽可能的去减少真实DOM的增删改，以达到优化性能的目的。所以用原生还是React等的js库，取决于项目的复杂程度，这其中肯定有个阙值，只不过现在大家的项目大部分都大于这个阙值，所以大家也都默认虚拟DOM的性能确实比直接操作原生DOM的性能要好。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1596419588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1553647,"avatar":"https://static001.geekbang.org/account/avatar/00/17/b4/ef/8d8a30b6.jpg","nickname":"黄浩","note":"","ucode":"4A849AB4BD9783","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2015986,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c2/f2/b3b349a4.jpg","nickname":"OOP","note":"","ucode":"FA536DFBF793F8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381713,"discussion_content":"阙值：主要在某些图像处理软件中又称为临界值，或者是差值，而这些说法都生动地表明了阙值的真正意义：它并不是一个单独存在的概念，而是两个像素之间的差值，而且，这个差值是个从低限到高限的范围。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625192422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":295979,"ip_address":""},"score":381713,"extra":""}]},{"author":{"id":2364198,"avatar":"https://static001.geekbang.org/account/avatar/00/24/13/26/8dfc7011.jpg","nickname":"唯唯喏","note":"","ucode":"F391E128E421AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545480,"discussion_content":"虚拟dom并不一定性能优于真实dom操作，他的优势在于，其对应框架能更好的输理和维护整个项目，减少负担，并且提供一个还不错的性能。这才是现在单页应用的主要优势。大家都知道直接用机器语言能更快被机器理解，但谁受得了一直编写机器语言。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1641973007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1533237,"avatar":"https://static001.geekbang.org/account/avatar/00/17/65/35/92b0f8ef.jpg","nickname":"🍁","note":"","ucode":"C3DBE6AEACA9F7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338702,"discussion_content":"还有一点，浏览器也在不断进步。你连续的用js去修改操作dom（不包括强制更新操作），现代浏览器也只渲染一次。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1609342257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1822733,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/d0/0d/752ff95f.jpg","nickname":"justorez","note":"","ucode":"071D8394E62D90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556550,"discussion_content":"我觉得虚拟DOM只是方便去做 diff。无论是直接使用 dom api，还是虚拟DOM中间层，都要做到局部更新，尽量保证只更新变化的部分；而简单 js 对象的比较，肯定比 HTMLElement 这类对象来的容易和高效，也节省内存开销。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1647415589,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":3004391,"avatar":"","nickname":"Geek_642b91","note":"","ucode":"EB9BED70420016","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1822733,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/d0/0d/752ff95f.jpg","nickname":"justorez","note":"","ucode":"071D8394E62D90","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573145,"discussion_content":"很正确。vnode所形成所谓的缓冲，并不是操作上的缓冲，而是数据查询上的缓冲。最终的操作仍是落在DOM上。\n最明显的，如果不使用vnode去对比DOM，那么如果同时存在对DOM的操作，则势必引起强制同步渲染，这将是极大的性能消耗。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1653219300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":556550,"ip_address":""},"score":573145,"extra":""}]},{"author":{"id":2448960,"avatar":"https://static001.geekbang.org/account/avatar/00/25/5e/40/dee7906c.jpg","nickname":"张欣","note":"","ucode":"557C42848C77E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358835,"discussion_content":"如果是大量操作，用原生写的话很难避免多次操作dom的问题。比如常做的复杂的后台管理系统，用原生不管是性能还是代码复杂度来说都是问题，如果是简单的操作的项目的话也没必要引入react，他本身就比较庞大，再first paint的时候会做很多前期处理和递归操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1616058937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1481079,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/0iaWEjweUtZrT9cDOQNxQDN8icibaNAkBfibBFoeea40Ko4TWqhbf2ibyk8yiaBKUibXzicMc4KpASicP0jyEAibiafVFW6eA/132","nickname":"Null","note":"","ucode":"EC523CBF7E2745","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351448,"discussion_content":"补充一点，个人的想法，也有可能是在计算过程中， DOM 本身会有很多变化，那么其实有些中间状态是不重要的，那么只有在计算出最终结果时，再去实际操作 DOM","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1614268590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2004749,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIib8v6esIeeiaRbts7jrGQdFJpvE3Umm5GYibespJLBaZhiacXDplWMOafo5Q0f0LLZeA794d2EBYhNw/132","nickname":"王泽龙","note":"","ucode":"7C5B0F2F67FD2A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1481079,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/0iaWEjweUtZrT9cDOQNxQDN8icibaNAkBfibBFoeea40Ko4TWqhbf2ibyk8yiaBKUibXzicMc4KpASicP0jyEAibiafVFW6eA/132","nickname":"Null","note":"","ucode":"EC523CBF7E2745","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391961,"discussion_content":"浏览器本身就会做 batch update。 也就是说，操作真实dom 也不会有这些中间状态","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1630730813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351448,"ip_address":""},"score":391961,"extra":""}]},{"author":{"id":1055763,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1c/13/676f87ca.jpg","nickname":"木山","note":"","ucode":"5288206CC91A76","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221882,"discussion_content":"咦, 这个观点新颖, 思考~","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586075001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1344810,"avatar":"https://static001.geekbang.org/account/avatar/00/14/85/2a/376dd985.jpg","nickname":"uccs","note":"","ucode":"93DF5B81AB170E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304758,"discussion_content":"react，一次操作只渲染一次，用jquery操作dom，可能一次操作要同时操作多个dom，每一次操作dom都有可能会触发重排，为什么不觉得性能有问题，因为现在硬件性能过剩，靠人感知肯定是感知不出来的，要用工具去看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599658231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2067161,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/o4jsp3yKTVthd1XfEA0ib1mXYFDULB2uUskUbLrtLbxy0AJFtuJqHAKjDSuDwiciazSAfE6fy2OfffLU8ayXmrWkg/132","nickname":"Jankin","note":"","ucode":"16084255D43B2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293560,"discussion_content":"js里操作DOM，是把每个DOM操作作为单独的宏任务放入消息队列？虚拟DOM里会把DOM操作整合为一个宏任务？这样想是对的嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595581679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2093945,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f3/79/a2bedc1e.jpg","nickname":"J6","note":"","ucode":"3F097CE1FFCA05","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2067161,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/o4jsp3yKTVthd1XfEA0ib1mXYFDULB2uUskUbLrtLbxy0AJFtuJqHAKjDSuDwiciazSAfE6fy2OfffLU8ayXmrWkg/132","nickname":"Jankin","note":"","ucode":"16084255D43B2C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320878,"discussion_content":"DOM操作一般是会生成微任务。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604495956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293560,"ip_address":""},"score":320878,"extra":""}]}]},{"had_liked":false,"id":138188,"user_name":"柒月","can_delete":false,"product_type":"c1","uid":1371240,"ip_address":"","ucode":"839A8F88C376A3","user_header":"https://static001.geekbang.org/account/avatar/00/14/ec/68/06d59613.jpg","comment_is_top":false,"comment_ctime":1570088224,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"44519761184","product_id":100033601,"comment_content":"主要还是解决频繁操作DOM引起页面响应慢的问题。<br>虚拟DOM就是一个JS对象，通过diff算法比较新老DOM树的差别，来达到最小化局部更新的目的。<br>其本质不过是用JS的运算性能的消耗来换取操作DOM的性能消耗。","like_count":9,"discussions":[{"author":{"id":1471963,"avatar":"https://static001.geekbang.org/account/avatar/00/16/75/db/1f2a24bd.jpg","nickname":"老壮","note":"","ucode":"8FD072F0636B8B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385623,"discussion_content":"记住一点：虚拟dom跟性能或者页面相应慢没有半毛关系；mvc模式发展以及生产效率的提升才是虚拟dom大行其道的根本原因","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1627183425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1562907,"avatar":"https://static001.geekbang.org/account/avatar/00/17/d9/1b/096657e3.jpg","nickname":"李玉龙","note":"","ucode":"E10A6BCEA2C204","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320063,"discussion_content":"fragment","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604235050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1782777,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/33/f9/50b76abe.jpg","nickname":"AMIR","note":"","ucode":"65142D9669071B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109804,"discussion_content":"我觉得并没有，虚拟dom比较晚完之后不还是需要使用原生的dom方法来操作？只是对比innerHtml有优势而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577711734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1222546,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a7/92/cd23d2d7.jpg","nickname":"cn.hfuu.zhou","note":"","ucode":"9D61B88E5D1E27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33514,"discussion_content":"能不能举一个例子详细说明一下，虚拟dom怎么就比直接操作dom的效率高一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571130900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177955,"user_name":"小蛋糕","can_delete":false,"product_type":"c1","uid":1807662,"ip_address":"","ucode":"335A6F4301CF22","user_header":"https://static001.geekbang.org/account/avatar/00/1b/95/2e/f8575abb.jpg","comment_is_top":false,"comment_ctime":1581561490,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27351365266","product_id":100033601,"comment_content":"说虚拟 DOM 解决的问题，那一定应该是和 DOM 存在什么问题来进行比较吧？<br><br>DOM 存在的问题：<br><br>- 对 DOM 进行操作时往往会引起重排、重绘<br>- 编写不当的代码操作 DOM 还会引起强制布局和布局抖动<br>- 复杂的页面往往会频繁的操作 DOM<br><br>虚拟 DOM 对此的优势：<br><br>虚拟 DOM 最终当然也会产生重排、重绘等操作，但是由于虚拟 DOM 对 真实 DOM 的预解析和变化搜集的双缓存机制，使得操作 DOM 的频率会明显的降低。<br>操作 DOM 的频率降低同样会使得强制同步布局和布局抖动得到一定的优化。<br><br>这个是我对于虚拟 DOM 的优势的理解，如果有什么不对的，还望指正。<br>","like_count":7,"discussions":[{"author":{"id":1608406,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8a/d6/00cf9218.jpg","nickname":"撒哈拉","note":"","ucode":"2F64B26543D772","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411892,"discussion_content":"和我理解一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636027315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143532,"user_name":"桃翁","can_delete":false,"product_type":"c1","uid":1044036,"ip_address":"","ucode":"CB438AF450DC00","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/44/26ac883e.jpg","comment_is_top":false,"comment_ctime":1571726623,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"27341530399","product_id":100033601,"comment_content":"老师，为什么 React 的 Fiber 不用 async&#47;await 来实现呢？","like_count":6,"discussions":[{"author":{"id":1748640,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","nickname":"穿秋裤的男孩","note":"","ucode":"D0F48C66377893","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241779,"discussion_content":"fiber和async底层应该都是协程（generator）吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587440391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1485254,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoaxy8ibvXITdMcXFfd5O5E7Epq8MG5z1OBhO7MQXTfbcpA0fpcsIxkCHyUZ5ZSrj3spZpAQxEC9GA/132","nickname":"非洲大地我最凶","note":"","ucode":"30CDE0B486AE26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109074,"discussion_content":"活捉一只桃翁？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577667339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1044036,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ee/44/26ac883e.jpg","nickname":"桃翁","note":"","ucode":"CB438AF450DC00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1485254,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoaxy8ibvXITdMcXFfd5O5E7Epq8MG5z1OBhO7MQXTfbcpA0fpcsIxkCHyUZ5ZSrj3spZpAQxEC9GA/132","nickname":"非洲大地我最凶","note":"","ucode":"30CDE0B486AE26","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109924,"discussion_content":"应该是的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577714700,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":109074,"ip_address":""},"score":109924,"extra":""}]},{"author":{"id":1202089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/a9/9abbe7a4.jpg","nickname":"神三元","note":"","ucode":"0FB2E7C0683599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69640,"discussion_content":"太麻烦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575296000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1044036,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ee/44/26ac883e.jpg","nickname":"桃翁","note":"","ucode":"CB438AF450DC00","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1202089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/a9/9abbe7a4.jpg","nickname":"神三元","note":"","ucode":"0FB2E7C0683599","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":107883,"discussion_content":"我觉得肯定不是因为太麻烦，如果用async 肯定会更简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577614356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":69640,"ip_address":""},"score":107883,"extra":""},{"author":{"id":2067291,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8b/5b/51e99f88.jpg","nickname":"sellardoor","note":"","ucode":"7FC1AB789E2C3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1044036,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ee/44/26ac883e.jpg","nickname":"桃翁","note":"","ucode":"CB438AF450DC00","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292212,"discussion_content":"There&#39;s two reasons for this.\n\nGenerators doesn&#39;t just let you yield in the middle of a stack. You have to wrap every single function in a generator. This not only adds a lot of syntactic overhead but also runtime overhead in any existing implementation. It&#39;s fair that the syntax might be more helpful than not, but the perf issue still stands.\n\nThe biggest reason, however, is that generators are stateful. You can&#39;t resume in the middle of it.\n简而言之就是太麻烦","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595143492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":107883,"ip_address":""},"score":292212,"extra":""},{"author":{"id":1253438,"avatar":"https://static001.geekbang.org/account/avatar/00/13/20/3e/e2f1b2af.jpg","nickname":"I WANN BE THAT GUY","note":"","ucode":"2B51E6A5452617","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2067291,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/8b/5b/51e99f88.jpg","nickname":"sellardoor","note":"","ucode":"7FC1AB789E2C3D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368502,"discussion_content":"简而言之就是用generator，就相当于把调度交给操作系统，没办法做到根据ui操作的优先级进行打断，为了能把调度完全掌握在userland ，所以干脆自己重写调度测代码。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1618735903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":292212,"ip_address":""},"score":368502,"extra":""}]}]},{"had_liked":false,"id":138193,"user_name":"隔夜果酱","can_delete":false,"product_type":"c1","uid":1319638,"ip_address":"","ucode":"5AFEB62E832BCB","user_header":"https://static001.geekbang.org/account/avatar/00/14/22/d6/9378f4d5.jpg","comment_is_top":false,"comment_ctime":1570089285,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18749958469","product_id":100033601,"comment_content":"李老师后面会考虑React源码类的专栏么?<br>网上的视频和文章很多都流于表面,或者生搬硬套的进行解释,看的让人头大.<br>如果李老师有精力和兴趣的话,希望可以开专栏为我们指点迷津呀.","like_count":4,"discussions":[{"author":{"id":1598828,"avatar":"https://static001.geekbang.org/account/avatar/00/18/65/6c/5cb98fc3.jpg","nickname":"locke","note":"","ucode":"DD0554D06C7937","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377730,"discussion_content":"支持开个react源码分析课","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622794764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138133,"user_name":"小兵","can_delete":false,"product_type":"c1","uid":1261674,"ip_address":"","ucode":"AA3BA727C25179","user_header":"https://static001.geekbang.org/account/avatar/00/13/40/6a/ab1cf396.jpg","comment_is_top":false,"comment_ctime":1570056986,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18749926170","product_id":100033601,"comment_content":"老师，文中的虚拟Dom收集到足够的变化是什么意思？会不会导致页面的响应变慢？","like_count":4,"discussions":[{"author":{"id":1623567,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/0f/3937645e.jpg","nickname":"NBE01","note":"","ucode":"DF0D22D4495D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28409,"discussion_content":"收集到足够的变化，指的是 批量的一些 操作， 比方说你 在不同的compoent中 在同一时间调用了setState方法，他会将这些方法的最终结果进行收集。 响应变慢，我觉得不用担心，他代码里面有一些 时间上的判断，到 时间了 就会执行flush操作。将这一批次的更改映射到真正的dom上。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570695210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283589,"user_name":"😎","can_delete":false,"product_type":"c1","uid":1795619,"ip_address":"","ucode":"BFA259F61C0EFD","user_header":"","comment_is_top":false,"comment_ctime":1615834547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14500736435","product_id":100033601,"comment_content":"似乎大家都没有提到一点，虚拟dom可以实现跨端，如React Native<br>","like_count":4},{"had_liked":false,"id":208800,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1587440277,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14472342165","product_id":100033601,"comment_content":"读完文章之后，感觉虚拟DOM技术和DOM碎片（createDocumentFragment）很像，都是提供缓存的策略。","like_count":3},{"had_liked":false,"id":207534,"user_name":"Geek_gaoqin","can_delete":false,"product_type":"c1","uid":1646743,"ip_address":"","ucode":"760365FDCE6E27","user_header":"https://static001.geekbang.org/account/avatar/00/19/20/97/919f5e6b.jpg","comment_is_top":false,"comment_ctime":1587103758,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14472005646","product_id":100033601,"comment_content":"老师你的课程太好了，再开个课程讲react angular等框架的知识点吧，以及结合这个浏览器原理再讲讲框架原理和源码分析吧","like_count":3},{"had_liked":false,"id":207264,"user_name":"coco","can_delete":false,"product_type":"c1","uid":1314208,"ip_address":"","ucode":"608D39E9EAD68D","user_header":"https://static001.geekbang.org/account/avatar/00/14/0d/a0/c97ce2fe.jpg","comment_is_top":false,"comment_ctime":1587039623,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10176974215","product_id":100033601,"comment_content":"希望李老师开设vue专栏，很喜欢李老师的专栏，买了不少的，还是最喜欢您的专栏，通俗易懂","like_count":2},{"had_liked":false,"id":225640,"user_name":"james","can_delete":false,"product_type":"c1","uid":1232771,"ip_address":"","ucode":"AC42035106E5B9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/yyibGRYCArsUNBfCAEAibua09Yb9D5AdO8TkCmXymhAepibqmlz0hzg06ggBLxyvXicnjqFVGr7zYF0rQoZ0aXCBAg/132","comment_is_top":false,"comment_ctime":1591803579,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5886770875","product_id":100033601,"comment_content":"由于真实的DOM结构是非常庞大且复杂的，因此可以采用js对象来描述真实的DOM结构，这就是虚拟DOM，并且当数据更新后，需要更新视图，根据新的数据生成一个新的虚拟DOM，然后基于新的虚拟DOM，跟旧的虚拟DOM进行比较，找出更新的部分，改造旧的虚拟DOM，再讲虚拟DOM转化成真实DOM，再一次性插入到视图节点中。这样子通过避免重复操作DOM元素，牺牲js的运算消耗，但是在如今高CPU的计算机处理性能下，这点消耗可以忽略，从而提高视图渲染的性能","like_count":1},{"had_liked":false,"id":138887,"user_name":"淡","can_delete":false,"product_type":"c1","uid":1456392,"ip_address":"","ucode":"6856CA319DE2F0","user_header":"https://static001.geekbang.org/account/avatar/00/16/39/08/09055b47.jpg","comment_is_top":false,"comment_ctime":1570499252,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"5865466548","product_id":100033601,"comment_content":"老师，你好。我有两个小疑问：<br>1.就是说到新算法的时候，使用协程说让出主线程。前面课程里说道线程同一时刻只能有一个协程能执行，这里说的协程如果还属于主线程的话，我理解的依然会卡主线程，如果不属于相当于新开线程来执行diff算法。请问我是不是哪里理解错了？<br>2.就是分析React更新dom，第一步说监听DOM的变化，后面又说React变化的虚拟DOM同步更新到实际DOM，触发DOM的更新。我理解第一步应该是监听虚拟DOM变更函数调用，但是这样由于示例图又不一样了，如果是实际DOM的变化都已经变化了就没后面什么事了吧？","like_count":2,"discussions":[{"author":{"id":1485254,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoaxy8ibvXITdMcXFfd5O5E7Epq8MG5z1OBhO7MQXTfbcpA0fpcsIxkCHyUZ5ZSrj3spZpAQxEC9GA/132","nickname":"非洲大地我最凶","note":"","ucode":"30CDE0B486AE26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109085,"discussion_content":"当前这个协程肯定会卡住，让另一个协程来执行别的任务。但主线程并未被卡住，个人理解，可以去看一下跟async有关的那章","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577667621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1159960,"avatar":"https://static001.geekbang.org/account/avatar/00/11/b3/18/e061e898.jpg","nickname":"AYK","note":"","ucode":"68E8C21A862A7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":29783,"discussion_content":"requestIdleCallback 你要了解一下Fiber是如何调度的，可以了解一下这个浏览器方法","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570783948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190290,"avatar":"https://static001.geekbang.org/account/avatar/00/12/29/92/076e0f61.jpg","nickname":"Silence","note":"","ucode":"5EA66378BE3B18","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26242,"discussion_content":"Stack 只能同步执行，Fiber 可以做调度处理。也就是说，假设现在有个 Fiber 其单链表（Linked List）结构为 A → B → C，当 A 执行到 B 被中断的话，可以之后再次执行 B → C，这对 Stack 的同步处理结构来说是很难做到的。\n参考：https://juejin.im/post/5be969656fb9a049ad76931f","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1570590190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1456392,"avatar":"https://static001.geekbang.org/account/avatar/00/16/39/08/09055b47.jpg","nickname":"淡","note":"","ucode":"6856CA319DE2F0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1190290,"avatar":"https://static001.geekbang.org/account/avatar/00/12/29/92/076e0f61.jpg","nickname":"Silence","note":"","ucode":"5EA66378BE3B18","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":26285,"discussion_content":"好的，谢谢指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570592958,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":26242,"ip_address":""},"score":26285,"extra":""}]},{"author":{"id":1037760,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLIuRQaZX70dsBg6khub2VPM1eQAP9IWRWxgOFed3ia4kXyNJInFRicWJ0ibf2YmLsOvJa1sGygGpmJg/132","nickname":"胖子","note":"","ucode":"E6371346288A87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":220757,"discussion_content":"同问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585923211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1231133,"avatar":"https://static001.geekbang.org/account/avatar/00/12/c9/1d/c7586cfc.jpg","nickname":"Zkerhcy","note":"","ucode":"43A883F6FB6070","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":84503,"discussion_content":"第一个同问，谁能清楚解释下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576499394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138405,"user_name":"宇宙全栈","can_delete":false,"product_type":"c1","uid":1001309,"ip_address":"","ucode":"2E984CA0ECFB85","user_header":"https://static001.geekbang.org/account/avatar/00/0f/47/5d/9afdf648.jpg","comment_is_top":false,"comment_ctime":1570199707,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5865167003","product_id":100033601,"comment_content":"基于 React 和 Redux 构建 MVC 模型的配图中，控制器是不是不能直接改变视图？因为 redux 模型是单向数据流吧","like_count":2},{"had_liked":false,"id":138125,"user_name":"Hurry","can_delete":false,"product_type":"c1","uid":1138560,"ip_address":"","ucode":"12FEE2A50CC667","user_header":"https://static001.geekbang.org/account/avatar/00/11/5f/80/51269d88.jpg","comment_is_top":false,"comment_ctime":1570036126,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5865003422","product_id":100033601,"comment_content":"频繁DOM操作是非常消耗浏览器性能的，虚拟DOM核心还是将批量DOM操作后的变化一次性更新到浏览器。","like_count":1,"discussions":[{"author":{"id":2056440,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/60/f8/659c3799.jpg","nickname":"朱重八","note":"","ucode":"EA15E85C15B752","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300532,"discussion_content":"我觉得你这个说法是不对的，批量更新dom最后还是执行dom操作，直接频繁dom操作的话，浏览器也是会做batch update的优化，虚拟dom的优势并不在于性能，而是屏蔽底层dom操作，提供更干净的开发方式，并且可以移植到其他平台，并且相对操作dom来说构建虚拟dom的性能消耗还不算太大，最终提供了一个还看得过去的性能，提供了更高效的开发模式（更高的可维护性）以及平台的可移植性应该才是虚拟dom的最大优势。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1598160464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1782777,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/33/f9/50b76abe.jpg","nickname":"AMIR","note":"","ucode":"65142D9669071B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109810,"discussion_content":"频繁的dom操作，浏览器也会等到dom操作完成然后统一渲染更新的，前面讲过的，并不是你document.xxx.xxx=xxx,就马上执行这句的，也是等你的js dom操作都完成才统一更新的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577711878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1222546,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a7/92/cd23d2d7.jpg","nickname":"cn.hfuu.zhou","note":"","ucode":"9D61B88E5D1E27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":33516,"discussion_content":"能不能举一个例子详细说明一下，虚拟dom怎么就比直接操作dom的效率高一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571130908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":329717,"user_name":"skyline","can_delete":false,"product_type":"c1","uid":2143862,"ip_address":"","ucode":"7A54BA59F30CB2","user_header":"https://static001.geekbang.org/account/avatar/00/20/b6/76/3d68a0ae.jpg","comment_is_top":false,"comment_ctime":1641498684,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641498684","product_id":100033601,"comment_content":"文中&quot;在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。&quot;这句话我不赞同，虚拟DOM最中也是将对比出不的不同点一次一次调用原生API更新DOM，并不能实现“一次性”应用到真实DOM<br><br>虚拟DOM从来不是为了解决性能问题，而是现代框架为实现mvvm，解放开发人员生产力做的一种折中的方案。<br><br>个人观点","like_count":0},{"had_liked":false,"id":317951,"user_name":"卷不动了","can_delete":false,"product_type":"c1","uid":2789148,"ip_address":"","ucode":"714A9744345188","user_header":"https://static001.geekbang.org/account/avatar/00/2a/8f/1c/e2a5c91e.jpg","comment_is_top":false,"comment_ctime":1635069820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635069820","product_id":100033601,"comment_content":"我理解只要不在页面上插入删除节点或者对dom元素的几何信息进行改变就不会触发重排重绘，就算我使用虚拟dom我在虚拟dom中增加节点依然会触发重排才对,而且我如果在页面上只想改变dom元素中某个文字，我直接操作dom明显来的更快,使用虚拟dom反而要去经过对比计算,效率明显不如前者,虚拟dom主要是提高开发效率的同时提供过得去的性能,在最初,改变dom中的内容需要手动获取dom对元素更改,使用虚拟dom只需要关心数据变化,这样使得开发效率有所提升,并且虚拟dom还可以应用在移动端,如果追求性能虚拟dom应该不是最优选择","like_count":0},{"had_liked":false,"id":311335,"user_name":"乐意","can_delete":false,"product_type":"c1","uid":2047309,"ip_address":"","ucode":"1624D4CA4AEEF4","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3d/4d/dc2da0a2.jpg","comment_is_top":false,"comment_ctime":1631176782,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631176782","product_id":100033601,"comment_content":"在vue中使用document.getElementbyId获得的是虚拟dom还是真实dom呢","like_count":0},{"had_liked":false,"id":309448,"user_name":"ronny","can_delete":false,"product_type":"c1","uid":2071110,"ip_address":"","ucode":"E2D3A70AAC89AA","user_header":"https://static001.geekbang.org/account/avatar/00/1f/9a/46/bb7d948e.jpg","comment_is_top":false,"comment_ctime":1630141080,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1630141080","product_id":100033601,"comment_content":"老师有兴趣讲讲angular源码吗","like_count":0},{"had_liked":false,"id":298750,"user_name":"1830","can_delete":false,"product_type":"c1","uid":1374337,"ip_address":"","ucode":"246FEF7C97F39C","user_header":"https://static001.geekbang.org/account/avatar/00/14/f8/81/bff52f91.jpg","comment_is_top":false,"comment_ctime":1624287665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624287665","product_id":100033601,"comment_content":"MVVM的虚拟dom解决的问题不在于性能，综合而言它也不一定有渲染的性能优势。之所以用最重要的是工作的效率，代码的简洁性易维护，这点我请教过大厂很多大佬，其实结合老师前面说的渲染流程也能想到","like_count":0},{"had_liked":false,"id":292975,"user_name":"General","can_delete":false,"product_type":"c1","uid":1039860,"ip_address":"","ucode":"2247DEBA9422C8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83er04ibpNSFnyiaPrWjPU96q7AZzgAU1Jc1MVwVvfTrqRaR2AWYJ6Z2KXohT8fS5dKSAqa31SNmicJ1mg/132","comment_is_top":false,"comment_ctime":1621133914,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1621133914","product_id":100033601,"comment_content":"React +Redux 的数据流向是单向的，最后一张图有点迷惑，action&#47;reducer 到 view 那个箭头是不画反了？","like_count":0,"discussions":[{"author":{"id":1288733,"avatar":"https://static001.geekbang.org/account/avatar/00/13/aa/1d/b8fdd622.jpg","nickname":"laoergege","note":"","ucode":"559CCF36805A04","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391907,"discussion_content":"老师画错了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630682772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286722,"user_name":"Geek_2014ce","can_delete":false,"product_type":"c1","uid":2136469,"ip_address":"","ucode":"167B4CCDA4D5BD","user_header":"https://static001.geekbang.org/account/avatar/00/20/99/95/1e332315.jpg","comment_is_top":false,"comment_ctime":1617525705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617525705","product_id":100033601,"comment_content":"不太赞同老师说的 “频繁更新DOM引起的性能问题”<br>- 根据前面的微任务章节可知，就算是频繁操作DOM，真正的进行页面的更新也是在微任务里面一次更新的，并不会频繁触发渲染流水线。(除非调用强制布局相关的接口)。<br>- 我也自己写DEMO去测了，for循环里面向一个父元素不断添加子节点。查看performance会发现只有脚本完全执行完了触发了一次渲染流水线。<br>不知道我理解是否有问题，希望老师能给予解答。(&gt;_&lt;)<br>","like_count":0},{"had_liked":false,"id":286519,"user_name":"das parfum","can_delete":false,"product_type":"c1","uid":1233223,"ip_address":"","ucode":"96D49D73F2D13C","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/47/395438c4.jpg","comment_is_top":false,"comment_ctime":1617355148,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617355148","product_id":100033601,"comment_content":"取法乎上","like_count":0},{"had_liked":false,"id":266819,"user_name":"啊哈哈","can_delete":false,"product_type":"c1","uid":1243584,"ip_address":"","ucode":"A8542946C03707","user_header":"https://static001.geekbang.org/account/avatar/00/12/f9/c0/20b4a205.jpg","comment_is_top":false,"comment_ctime":1607497525,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607497525","product_id":100033601,"comment_content":"1. 复杂项目（页面）下，通过虚拟DOM的生成、比对，再批量更新，比频繁操作真实DOM性能消耗更小。当然，虚拟DOM的生成比对都是占内存的，但是相比频发更新，不停的占用主线程，阻塞视图渲染，时间要快，这里实际上是用空间换取时间。<br>2. 虚拟DOM可以实现跨平台。","like_count":0},{"had_liked":false,"id":260993,"user_name":"君自兰芳","can_delete":false,"product_type":"c1","uid":2029706,"ip_address":"","ucode":"780F3AFEEB9B73","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f8/8a/f7e7fd54.jpg","comment_is_top":false,"comment_ctime":1605168787,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1605168787","product_id":100033601,"comment_content":"“在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上”<br><br>有个疑问，这里的“足够的改变”，具体是足够到什么程度？按时间来算？还是按照累积的量来算？","like_count":0,"discussions":[{"author":{"id":1925183,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/N5zF2REeLrydaYZgJKq9Xjang0XKMKdgE4pBgKtdtYe1UDRLAVamzgd2WFkghoI9ZyalCoSOLslxsuZzCwbiaBg/132","nickname":"小猪猪","note":"","ucode":"ECA72490E8BB9B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":354409,"discussion_content":"同问呐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615289339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":235087,"user_name":"Geek_3b5e3c","can_delete":false,"product_type":"c1","uid":2033247,"ip_address":"","ucode":"6157E1626E00C0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pR5LYM0SnUWZialA11lAlcnHH9XUH04cqZ6AibDu2xVJic80o2oJG2jIHPiaiakOqkw4jP5Bo0IAYnLMYHyicztLfnlA/132","comment_is_top":false,"comment_ctime":1594888396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594888396","product_id":100033601,"comment_content":"MVC 那张图是不是有点出入，View 和 Model也可以通信的吧，如果不能通信的话不就是MVP架构了？","like_count":0},{"had_liked":false,"id":229786,"user_name":"静心","can_delete":false,"product_type":"c1","uid":1335457,"ip_address":"","ucode":"EB264FA6519FDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","comment_is_top":false,"comment_ctime":1593145019,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"1593145019","product_id":100033601,"comment_content":"请教老师：新数据发生时，新的虚拟dom树是整个复制旧的dom树？还是只复制修改了的dom树？","like_count":0},{"had_liked":false,"id":220575,"user_name":"张萌","can_delete":false,"product_type":"c1","uid":1377299,"ip_address":"","ucode":"89C08DB3239BE5","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/13/84d35588.jpg","comment_is_top":false,"comment_ctime":1590289430,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590289430","product_id":100033601,"comment_content":"页面有了一定复杂度，想减少计算次数比较难<br>JS 计算速度和 DOM 更新的速度比，不是一个量级<br>vdom 就是用 JS 模拟 DOM 结构，计算出最小的变更，然后操作 DOM","like_count":0},{"had_liked":false,"id":187211,"user_name":"木易丶","can_delete":false,"product_type":"c1","uid":1614256,"ip_address":"","ucode":"8D526162BDE025","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/U23QibvwAbZ1Vc7bDOjiaicknrmzoWN6JsMwgyHU6FnotiarWicI5s6BxtCG4Rkia0akjtTMAzMqeUkajKb8nMwsXolA/132","comment_is_top":false,"comment_ctime":1584061124,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1584061124","product_id":100033601,"comment_content":"老师，您说虚拟dom是一次性对比完后更新，但是我看vue的却是逐层比较，如果是相同dom就直接patch。","like_count":0,"discussions":[{"author":{"id":1567899,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ec/9b/29863411.jpg","nickname":"宅神","note":"","ucode":"D44140A208744F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231874,"discussion_content":"逐层比较是diff算法中的一环，而diff算法是虚拟dom这个一次性对比的一环。不冲突的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586834970,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1614256,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/U23QibvwAbZ1Vc7bDOjiaicknrmzoWN6JsMwgyHU6FnotiarWicI5s6BxtCG4Rkia0akjtTMAzMqeUkajKb8nMwsXolA/132","nickname":"木易丶","note":"","ucode":"8D526162BDE025","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1567899,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ec/9b/29863411.jpg","nickname":"宅神","note":"","ucode":"D44140A208744F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":234583,"discussion_content":"还是不太明白，我觉得vue就是对比虚拟dom的同时更新真实dom，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586966894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":231874,"ip_address":""},"score":234583,"extra":""},{"author":{"id":2143862,"avatar":"https://static001.geekbang.org/account/avatar/00/20/b6/76/3d68a0ae.jpg","nickname":"skyline","note":"","ucode":"7A54BA59F30CB2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1614256,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/U23QibvwAbZ1Vc7bDOjiaicknrmzoWN6JsMwgyHU6FnotiarWicI5s6BxtCG4Rkia0akjtTMAzMqeUkajKb8nMwsXolA/132","nickname":"木易丶","note":"","ucode":"8D526162BDE025","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544388,"discussion_content":"不用觉得，就是","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641499090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":234583,"ip_address":""},"score":544388,"extra":""}]}]},{"had_liked":false,"id":141235,"user_name":"cn.hfuu.zhou","can_delete":false,"product_type":"c1","uid":1222546,"ip_address":"","ucode":"9D61B88E5D1E27","user_header":"https://static001.geekbang.org/account/avatar/00/12/a7/92/cd23d2d7.jpg","comment_is_top":false,"comment_ctime":1571130947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571130947","product_id":100033601,"comment_content":"老师，能不能举一个例子详细说明一下，虚拟dom怎么就比直接操作dom的效率高一些。","like_count":0},{"had_liked":false,"id":140642,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1003156,"ip_address":"","ucode":"4060B4E2EF1D13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/94/0b22b6a2.jpg","comment_is_top":false,"comment_ctime":1571020749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571020749","product_id":100033601,"comment_content":"老师能深入分析一下，MVC  MVP  MVVM这三种架的构演变过程吗？为什么提出这三种架构，主要是解决什么问题，它们之间的区别和联系？网上有很多相关的文章，但是感觉都解释的得不是很清晰。","like_count":0},{"had_liked":false,"id":140623,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1003156,"ip_address":"","ucode":"4060B4E2EF1D13","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/94/0b22b6a2.jpg","comment_is_top":false,"comment_ctime":1571017616,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1571017616","product_id":100033601,"comment_content":"期待老师新的课程！","like_count":0},{"had_liked":false,"id":140212,"user_name":"Angus","can_delete":false,"product_type":"c1","uid":1377467,"ip_address":"","ucode":"7CC3BA1550FB5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/04/bb/5e5c37c1.jpg","comment_is_top":false,"comment_ctime":1570850943,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1570850943","product_id":100033601,"comment_content":"我觉主要是更新收集和更新比对这两个方面让虚拟DOM减少了很多直接操作带来的频繁渲染","like_count":0,"discussions":[{"author":{"id":1782777,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/33/f9/50b76abe.jpg","nickname":"AMIR","note":"","ucode":"65142D9669071B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109806,"discussion_content":"我觉得并没有，虚拟dom比较晚完之后不还是需要使用原生的dom方法来操作？只是对比innerHtml有优势而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577711765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138696,"user_name":"Shine","can_delete":false,"product_type":"c1","uid":1022568,"ip_address":"","ucode":"C8C617B87C63C7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9a/68/92caeed6.jpg","comment_is_top":false,"comment_ctime":1570424423,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1570424423","product_id":100033601,"comment_content":"哪位有没有vdom更新算法介绍的文章推荐","like_count":0,"discussions":[{"author":{"id":1623567,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/0f/3937645e.jpg","nickname":"NBE01","note":"","ucode":"DF0D22D4495D54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":28410,"discussion_content":"直接撸源码！ 那个比啥文章都来的强。。。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570695320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1202089,"avatar":"https://static001.geekbang.org/account/avatar/00/12/57/a9/9abbe7a4.jpg","nickname":"神三元","note":"","ucode":"0FB2E7C0683599","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1623567,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c6/0f/3937645e.jpg","nickname":"NBE01","note":"","ucode":"DF0D22D4495D54","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":69642,"discussion_content":"站着说话不腰疼\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1575296039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":28410,"ip_address":""},"score":69642,"extra":""}]}]}]}