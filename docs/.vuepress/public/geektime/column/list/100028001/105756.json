{"id":105756,"title":"加餐 | 什么是数据的强、弱一致性？","content":"<p>你好，我是刘超。</p><p>在<a href=\"https://time.geekbang.org/column/article/103541\">第17讲</a>讲解并发容器的时候，我提到了“强一致性”和“弱一致性”。很多同学留言表示对这个概念没有了解或者比较模糊，今天这讲加餐就来详解一下。</p><p>说到一致性，其实在系统的很多地方都存在数据一致性的相关问题。除了在并发编程中保证共享变量数据的一致性之外，还有数据库的ACID中的C（Consistency 一致性）、分布式系统的CAP理论中的C（Consistency 一致性）。下面<span class=\"orange\">我们主要讨论的就是“并发编程中共享变量的一致性”。</span></p><p>在并发编程中，Java是通过共享内存来实现共享变量操作的，所以在多线程编程中就会涉及到数据一致性的问题。</p><p>我先通过一个经典的案例来说明下多线程操作共享变量可能出现的问题，假设我们有两个线程（线程1和线程2）分别执行下面的方法，x是共享变量：</p><pre><code>//代码1\npublic class Example {\n    int x = 0;\n    public void count() {\n        x++;                     //1\n        System.out.println(x)//2\n    }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/e1/33/e1dfb18f71c76d1468fa94d43f8ca933.jpg?wh=1058*130\" alt=\"\"></p><p>如果两个线程同时运行，两个线程的变量的值可能会出现以下三种结果：</p><p><img src=\"https://static001.geekbang.org/resource/image/fb/9b/fb45f0c91af1a063d1f2db28dd21c49b.jpg?wh=1066*134\" alt=\"\"></p><h2>Java存储模型</h2><p>2,1和1,2的结果我们很好理解，那为什么会出现以上1,1的结果呢？</p><p>我们知道，Java采用共享内存模型来实现多线程之间的信息交换和数据同步。在解释为什么会出现这样的结果之前，我们先通过下图来简单了解下Java的内存模型（第21讲还会详解），程序在运行时，局部变量将会存放在虚拟机栈中，而共享变量将会被保存在堆内存中。</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/df/8b/dfd02c98d495c4c4ed201ea7fe0e3f8b.jpg?wh=1022*664\" alt=\"\"></p><p>由于局部变量是跟随线程的创建而创建，线程的销毁而销毁，所以存放在栈中，由上图我们可知，Java栈数据不是所有线程共享的，所以不需要关心其数据的一致性。</p><p>共享变量存储在堆内存或方法区中，由上图可知，堆内存和方法区的数据是线程共享的。而堆内存中的共享变量在被不同线程操作时，会被加载到自己的工作内存中，也就是CPU中的高速缓存。</p><p>CPU 缓存可以分为一级缓存（L1）、二级缓存（L2）和三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。当 CPU 要读取一个缓存数据时，首先会从一级缓存中查找；如果没有找到，再从二级缓存中查找；如果还是没有找到，就从三级缓存或内存中查找。</p><p>如果是单核CPU运行多线程，多个线程同时访问进程中的共享数据，CPU 将共享变量加载到高速缓存后，不同线程在访问缓存数据的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。</p><p>如果是多核CPU运行多线程，每个核都有一个 L1缓存，如果多个线程运行在不同的内核上访问共享变量时，每个内核的L1缓存将会缓存一份共享变量。</p><p>假设线程A操作CPU从堆内存中获取一个缓存数据，此时堆内存中的缓存数据值为0，该缓存数据会被加载到L1缓存中，在操作后，缓存数据的值变为1，然后刷新到堆内存中。</p><p>在正好刷新到堆内存中之前，又有另外一个线程B将堆内存中为0的缓存数据加载到了另外一个内核的L1缓存中，此时线程A将堆内存中的数据刷新到了1，而线程B实际拿到的缓存数据的值为0。</p><p>此时，内核缓存中的数据和堆内存中的数据就不一致了，且线程B在刷新缓存到堆内存中的时候也将覆盖线程A中修改的数据。这时就产生了数据不一致的问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/38/05/3835ed3c7df4f859cc77de5d829dab05.jpg?wh=1232*766\" alt=\"\"></p><p>了解完内存模型之后，结合以上解释，我们就可以回过头来看看第一段代码中的运行结果是如何产生的了。看到这里，相信你可以理解图中1,1的运行结果了。</p><p><img src=\"https://static001.geekbang.org/resource/image/dc/2e/dcaf4e9441871ca17f9b263cbd2b082e.jpg?wh=1028*922\" alt=\"\"></p><h2>重排序</h2><p>除此之外，在Java内存模型中，还存在重排序的问题。请看以下代码：</p><pre><code>//代码1\npublic class Example {\n    int x = 0;\n    boolean flag = false;\n    public void writer() {\n        x = 1;                //1\n        flag = true;          //2\n    }\n\n    public void reader() {\n        if (flag) {           //3\n             int r1 = x;      //4\n             System.out.println(r1==x)\n        }\n    }\n}\n</code></pre><p><img src=\"https://static001.geekbang.org/resource/image/ae/a8/ae1dc00bfc5e3a751cc427841d14c9a8.jpg?wh=896*192\" alt=\"\"></p><p>如果两个线程同时运行，线程2中的变量的值可能会出现以下两种可能：</p><p><img src=\"https://static001.geekbang.org/resource/image/ca/d6/ca6a5d4bb77ff67b1d30fcaac37c25d6.jpg?wh=898*130\" alt=\"\"></p><p>现在一起来看看 r1=1  的运行结果，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/0c/33/0c1e6c9a2951b1ba87b32be15708f633.jpg?wh=914*906\" alt=\"\"></p><p>那r1=0又是怎么获取的呢？我们再来看一个时序图：</p><p><img src=\"https://static001.geekbang.org/resource/image/88/17/880cbe050a2f65b1d9b457588f64f117.jpg?wh=966*904\" alt=\"\"></p><p><span class=\"orange\">在不影响运算结果的前提下，编译器有可能会改变顺序代码的指令执行顺序，特别是在一些可以优化的场景。</span></p><p>例如，在以下案例中，编译器为了尽可能地减少寄存器的读取、存储次数，会充分复用寄存器的存储值。如果没有进行重排序优化，正常的执行顺序是步骤1\\2\\3，而在编译期间进行了重排序优化之后，执行的步骤有可能就变成了步骤1/3/2或者2/1/3，这样就能减少一次寄存器的存取次数。</p><pre><code>int x = 1;//步骤1：加载x变量的内存地址到寄存器中，加载1到寄存器中，CPU通过mov指令把1写入到寄存器指定的内存中\nboolean flag = true; //步骤2 加载flag变量的内存地址到寄存器中，加载true到寄存器中，CPU通过mov指令把1写入到寄存器指定的内存中\nint y = x + 1;//步骤3 重新加载x变量的内存地址到寄存器中，加载1到寄存器中，CPU通过mov指令把1写入到寄存器指定的内存中\n</code></pre><p>在 JVM 中，重排序是十分重要的一环，特别是在并发编程中。可 JVM 要是能对它们进行任意排序的话，也可能会给并发编程带来一系列的问题，其中就包括了一致性的问题。</p><h2>Happens-before规则</h2><p>为了解决这个问题，Java提出了Happens-before规则来规范线程的执行顺序：</p><ul>\n<li>程序次序规则：在单线程中，代码的执行是有序的，虽然可能会存在运行指令的重排序，但最终执行的结果和顺序执行的结果是一致的；</li>\n<li>锁定规则：一个锁处于被一个线程锁定占用状态，那么只有当这个线程释放锁之后，其它线程才能再次获取锁操作；</li>\n<li>volatile变量规则：如果一个线程正在写volatile变量，其它线程读取该变量会发生在写入之后；</li>\n<li>线程启动规则：Thread对象的start()方法先行发生于此线程的其它每一个动作；</li>\n<li>线程终结规则：线程中的所有操作都先行发生于对此线程的终止检测；</li>\n<li>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始；</li>\n<li>传递性：如果操作A happens-before 操作B，操作B happens-before操作C，那么操作A happens-before 操作C；</li>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>\n</ul><p><strong>结合这些规则，我们可以将一致性分为以下几个级别：</strong></p><p>严格一致性（强一致性）：所有的读写操作都按照全局时钟下的顺序执行，且任何时刻线程读取到的缓存数据都是一样的，Hashtable就是严格一致性；</p><p><img src=\"https://static001.geekbang.org/resource/image/65/6b/650c9490bad5962cfcdd4bedf3e41f6b.jpg?wh=1644*454\" alt=\"\"></p><p>顺序一致性：多个线程的整体执行可能是无序的，但对于单个线程而言执行是有序的，要保证任何一次读都能读到最近一次写入的数据，volatile可以阻止指令重排序，所以修饰的变量的程序属于顺序一致性；</p><p><img src=\"https://static001.geekbang.org/resource/image/6d/c6/6d70a02e0a4fb51259bd6ffcac0f75c6.jpg?wh=1638*488\" alt=\"\"></p><p>弱一致性：不能保证任何一次读都能读到最近一次写入的数据，但能保证最终可以读到写入的数据，单个写锁+无锁读，就是弱一致性的一种实现。</p><p>今天的加餐到这里就结束了，如有疑问，欢迎留言给我。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起学习。</p><p></p>","comments":[{"had_liked":false,"id":111324,"user_name":"THROW","can_delete":false,"product_type":"c1","uid":1112141,"ip_address":"","ucode":"A3C089A8F5F941","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/4d/4b748ff1.jpg","comment_is_top":false,"comment_ctime":1562545512,"is_pvip":false,"replies":[{"id":"40616","content":"我们知道Node&lt;k,v&gt;以及Node&lt;k,v&gt;的value是volatile修饰的，所以在一个线程对其进行修改后，另一个线程可以马上看到。<br>如果是一个新Node，那么就不能马上看到，虽然Node的数组table被volatile修饰，但是这样只是代表table的引用地址如果被修改，其他线程可以立马看到，并不代表table里的数据被修改立马可以看到。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562576028,"ip_address":"","comment_id":111324,"utype":1}],"discussion_count":5,"race_medal":0,"score":"160476335464","product_id":100028001,"comment_content":"老师您好，都说concurrenthashmap的get是弱一致性，但我不理解啊，volatile 修饰的变量读操作为什么会读不到最新的数据？","like_count":38,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457305,"discussion_content":"我们知道Node&amp;lt;k,v&amp;gt;以及Node&amp;lt;k,v&amp;gt;的value是volatile修饰的，所以在一个线程对其进行修改后，另一个线程可以马上看到。\n如果是一个新Node，那么就不能马上看到，虽然Node的数组table被volatile修饰，但是这样只是代表table的引用地址如果被修改，其他线程可以立马看到，并不代表table里的数据被修改立马可以看到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562576028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1629418,"avatar":"https://static001.geekbang.org/account/avatar/00/18/dc/ea/9115f9bc.jpg","nickname":"yintianwen","note":"","ucode":"B29E9AB9D2F3B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":102447,"discussion_content":"老师您好，之前看过一篇博客，说&#34;变量使用了volatile之后，所有读取操作全部发生在主存中&#34;，这句话难道说的不对吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577346858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2060756,"avatar":"","nickname":"在下蟑螂王","note":"","ucode":"E66A65A327095A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1629418,"avatar":"https://static001.geekbang.org/account/avatar/00/18/dc/ea/9115f9bc.jpg","nickname":"yintianwen","note":"","ucode":"B29E9AB9D2F3B0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333203,"discussion_content":"没毛病啊老铁，不从cpu缓存取了，改成从主存取","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607479159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":102447,"ip_address":""},"score":333203,"extra":""}]},{"author":{"id":1037708,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/8c/c0200a17.jpg","nickname":"M#","note":"","ucode":"1C80F782036173","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40327,"discussion_content":"老师，table里面的数据也是volatile的，value的volatile也无法保证hp吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572165159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1348830,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/SM4fwn9uFicXU8cQ1rNF2LQdKNbZI1FX1jmdwaE2MTrBawbugj4TQKjMKWG0sGbmqQickyARXZFS8NZtobvoWTHA/132","nickname":"td901105","note":"","ucode":"32D42A4F36FA02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1037708,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/d5/8c/c0200a17.jpg","nickname":"M#","note":"","ucode":"1C80F782036173","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91347,"discussion_content":"因为put和get不是原子操作,同时源码中使用的是非volatile的引用,所以不能保证happern before","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576828940,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40327,"ip_address":""},"score":91347,"extra":""}]}]},{"had_liked":false,"id":112271,"user_name":"明翼","can_delete":false,"product_type":"c1","uid":1068361,"ip_address":"","ucode":"E77F86BEB3D5C1","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/49/28e73b9c.jpg","comment_is_top":false,"comment_ctime":1562710961,"is_pvip":false,"replies":[{"id":"40848","content":"平时善于做笔记，除此之外，尝试将自己学到的知识点分享给其他人。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562722281,"ip_address":"","comment_id":112271,"utype":1}],"discussion_count":2,"race_medal":0,"score":"70282187697","product_id":100028001,"comment_content":"早看到就好了😁，老师请教下这么多知识点你是怎么记住的？","like_count":16,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457648,"discussion_content":"平时善于做笔记，除此之外，尝试将自己学到的知识点分享给其他人。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562722281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062848,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ersGSic8ib7OguJv6CJiaXY0s4n9C7Z51sWxTTljklFpq3ZAIWXoFTPV5oLo0GMTkqW5sYJRRnibNqOJQ/132","nickname":"walle斌","note":"","ucode":"0DB3243004951F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591785,"discussion_content":"java并发编程。。。jmm","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666830656,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110836,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1562372072,"is_pvip":false,"replies":[{"id":"40388","content":"也会的，线程安全除了要保证可见性，还需要保证原子性、有序性。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562464605,"ip_address":"","comment_id":110836,"utype":1}],"discussion_count":4,"race_medal":0,"score":"35922110440","product_id":100028001,"comment_content":"老师好，请教一个问题：<br><br>文中举例，数据不一致是多核CPU的高速缓存不一致导致的，是否意味着单核CPU多线程操作就不会发生数据不一致呢","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457082,"discussion_content":"也会的，线程安全除了要保证可见性，还需要保证原子性、有序性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562464605,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1539926,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUBia0Aevb2CyMNPvuzTkVvlcoDpdFELFav5Bcic90wxehZibo0VglM7aRZLMo93Ful7v5TFlKfEYyg/132","nickname":"啊不多","note":"","ucode":"A38DE3C564B748","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":181322,"discussion_content":"文中的例子 在单核CPU下也有可能是 1，1吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582360787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382608,"discussion_content":"单核具体有啥情况会出现数据不一致呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625645508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1759325,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","nickname":"杯莫停","note":"","ucode":"4FA1D5CBBEF702","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1307497,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f3/69/7039d03f.jpg","nickname":"书策稠浊","note":"","ucode":"A29875CE15FDA3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581637,"discussion_content":"文中说了三个问题：CPU缓存引起的可见性问题，JVM优化重排序导致的顺序性问题，还有线程切换导致的原子性问题。这些都有可能导致一致性问题的产生。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658902712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":382608,"ip_address":""},"score":581637,"extra":""}]}]},{"had_liked":false,"id":132436,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568122096,"is_pvip":false,"replies":[{"id":"50647","content":"坚持看英文文档，到最后你就能流利的读任何英文文档说明了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568123846,"ip_address":"","comment_id":132436,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23042958576","product_id":100028001,"comment_content":"数据只要在不同的地方，且存在写操作就可能存在不一致性。不管是各级缓存中还是分布式集群中的某些节点中，都有类似的问题。线程间的数据一致性问题，由操作系统来去保证，分布式系统中的数据一致性问题由分布式协议的实现者去保证，不过确实不好弄，令人头疼。<br>给老师点赞，讲的很棒，不过知识真是太多了，感觉越学越多，买的专栏都学不完，不学是不行的不进则退，如果英语好就占优势了，可以直接学习第一手的学习资料。","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":466936,"discussion_content":"坚持看英文文档，到最后你就能流利的读任何英文文档说明了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568123846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114325,"user_name":"青梅煮酒","can_delete":false,"product_type":"c1","uid":1016591,"ip_address":"","ucode":"40B466AC361609","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/0f/b39a072d.jpg","comment_is_top":false,"comment_ctime":1563274822,"is_pvip":false,"replies":[{"id":"41774","content":"L1\\L2\\L3三个缓存的作用和实现的技术是不一样的，L1的内存大小是非常有限的，所以很多时候在L1获取缓存数据的命中率非常低。为了提高CPU读取的速率，在L1没有命中的缓存，可以进入到L2进行获取，L2的容量要比L1大，但离CPU核心更远。但还是能提高CPU读取缓存数据的速率。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563327277,"ip_address":"","comment_id":114325,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23038111302","product_id":100028001,"comment_content":"老师，请问一下，每核CPU都有自己的L1和L2，那么L1和L2的主要区别是什么呢？为什么不能合到一起呢？","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458608,"discussion_content":"L1\\L2\\L3三个缓存的作用和实现的技术是不一样的，L1的内存大小是非常有限的，所以很多时候在L1获取缓存数据的命中率非常低。为了提高CPU读取的速率，在L1没有命中的缓存，可以进入到L2进行获取，L2的容量要比L1大，但离CPU核心更远。但还是能提高CPU读取缓存数据的速率。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563327277,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110998,"user_name":"Lost In The Echo。","can_delete":false,"product_type":"c1","uid":1211954,"ip_address":"","ucode":"6EC7BF57DA3A15","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/32/e569f729.jpg","comment_is_top":false,"comment_ctime":1562417028,"is_pvip":false,"replies":[{"id":"40383","content":"顺序一致性是指单个线程的执行的顺序性，强一致性则指的是多个线程在全局时钟下的执行的顺序性。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562463759,"ip_address":"","comment_id":110998,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18742286212","product_id":100028001,"comment_content":"老师，请问强一致性和顺序一致性有什么区别吗？","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457166,"discussion_content":"顺序一致性是指单个线程的执行的顺序性，强一致性则指的是多个线程在全局时钟下的执行的顺序性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562463759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110907,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1562386973,"is_pvip":false,"replies":[{"id":"53409","content":"子类会继承父类的private属性，但子类无法直接访问到private属性；<br>子类创建时，不会创建一个父类对象的，只是调用了父类的构造函数初始化而已。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570434583,"ip_address":"","comment_id":110907,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18742256157","product_id":100028001,"comment_content":"老师容我问一个很基础的问题!父类private的属性会被子类继承么?子类创建的时候JVM给子类分配内存的时候，我看书上有说父类的属性会排在子类前面有可能穿插。可是没写是否会给子类分配父类的私有属性内存空间。子类创建的时候，会默认调用父类的无参构造器。这时候就会实例化一个父类对象么?(如果父类没有无参构造器会报错或者需要显示调用父类的有参构造器)。如果每次实力子类对象的时候都会先创建一个父类对象的话，滥用继承。就会浪费很多内存是么?对象头就需要8字节了。","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457120,"discussion_content":"子类会继承父类的private属性，但子类无法直接访问到private属性；\n子类创建时，不会创建一个父类对象的，只是调用了父类的构造函数初始化而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570434583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2664121,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a6/b9/6bdaf8ce.jpg","nickname":"rich_li","note":"","ucode":"B82495DDC942DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407318,"discussion_content":"朋友可以去看下虚拟机的类加载的过程，看了之后可能会对这有更深的理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634979768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":138976,"user_name":"菜菜","can_delete":false,"product_type":"c1","uid":1393550,"ip_address":"","ucode":"2CEBA98DA63362","user_header":"https://static001.geekbang.org/account/avatar/00/15/43/8e/2c1ce77b.jpg","comment_is_top":false,"comment_ctime":1570521738,"is_pvip":false,"replies":[{"id":"54276","content":"获取节点时是通过key值获取，并不一定通过next获取，所以不能代表对应key值中的value是最新的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1570956936,"ip_address":"","comment_id":138976,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10160456330","product_id":100028001,"comment_content":"针对老师对留言1的回复，我想问下老师，Node&lt;k,v&gt;中除了value被volatile修饰了，next也被volatile修饰了呀，这样如果是新增新的Node的话，其他线程也不可以看到吗？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469722,"discussion_content":"获取节点时是通过key值获取，并不一定通过next获取，所以不能代表对应key值中的value是最新的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570956936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135123,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1569033460,"is_pvip":false,"replies":[{"id":"51861","content":"mark","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569051609,"ip_address":"","comment_id":135123,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10158968052","product_id":100028001,"comment_content":"老师可以不可以讲一下threadlocal","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468058,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569051609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111099,"user_name":"云封","can_delete":false,"product_type":"c1","uid":1542521,"ip_address":"","ucode":"51C2F84EEA1944","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/aobibE2ABHn3njdaHBY23hcZcIs71aRahryuUDcLghQqTjmwghEIgKYelBERlNK881MP0oRpWGnrQdscD85dZ9g/132","comment_is_top":false,"comment_ctime":1562472631,"is_pvip":false,"replies":[{"id":"40618","content":"指令重排序不一定是由于共享变量导致的，这块需要结合具体的场景分析。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562576853,"ip_address":"","comment_id":111099,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10152407223","product_id":100028001,"comment_content":"老师，请问下，如果不存在操作共享变量的情况或者把共享产量存在redis中，多线程结果就不会发生由于指令重排而导致结果不一致的情况。","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457228,"discussion_content":"指令重排序不一定是由于共享变量导致的，这块需要结合具体的场景分析。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562576853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272318,"user_name":"InnerPeace","can_delete":false,"product_type":"c1","uid":2303783,"ip_address":"","ucode":"1D8AC69AC63001","user_header":"","comment_is_top":false,"comment_ctime":1610029373,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5904996669","product_id":100028001,"comment_content":"对于顺序一致性有点疑问。如果是单线程，无论是读还是写，都是串行，所以任何一次读都能读到最近一次写，这是显而易见的，为什么叫顺序一致性呢？","like_count":1},{"had_liked":false,"id":213359,"user_name":"GaGi","can_delete":false,"product_type":"c1","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1588394364,"is_pvip":false,"replies":[{"id":"79918","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1589165567,"ip_address":"","comment_id":213359,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5883361660","product_id":100028001,"comment_content":"老师，图中CPU多级缓存图中，L3缓存应该是多个CPU核心共用的","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493757,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589165567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144541,"user_name":"鱼","can_delete":false,"product_type":"c1","uid":1102175,"ip_address":"","ucode":"12D6A533ADD357","user_header":"https://static001.geekbang.org/account/avatar/00/10/d1/5f/d0613359.jpg","comment_is_top":false,"comment_ctime":1571967320,"is_pvip":false,"replies":[{"id":"55859","content":"收到，谢谢提醒","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1572080965,"ip_address":"","comment_id":144541,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866934616","product_id":100028001,"comment_content":"老师，我指出一个错误，时序图中最后flag=true不是false","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471998,"discussion_content":"收到，谢谢提醒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572080965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111140,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1562487179,"is_pvip":false,"replies":[{"id":"40617","content":"cas+volatile可以解决单个变量的强一致性问题。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562576657,"ip_address":"","comment_id":111140,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857454475","product_id":100028001,"comment_content":"老师好volatile+cas是强一致性么?。L1直接刷回主存，L2和L3需要做什么操作么?开头说每一级都是上一级的子集来着。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457247,"discussion_content":"cas+volatile可以解决单个变量的强一致性问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562576657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":111006,"user_name":"东方奇骥","can_delete":false,"product_type":"c1","uid":1354850,"ip_address":"","ucode":"DEE7085F7E55A4","user_header":"https://static001.geekbang.org/account/avatar/00/14/ac/62/37912d51.jpg","comment_is_top":false,"comment_ctime":1562419720,"is_pvip":true,"replies":[{"id":"40382","content":"对的，volatile除了可以保证变量的可见性，可以阻止局部指令重排序。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562463644,"ip_address":"","comment_id":111006,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5857387016","product_id":100028001,"comment_content":"上面例子，flag加volatile修饰，根据happens before中的顺序性选择和volatile的原则，就能保证另一个线程读到写入的值了。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457171,"discussion_content":"对的，volatile除了可以保证变量的可见性，可以阻止局部指令重排序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562463644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":352733,"user_name":"杯莫停","can_delete":false,"product_type":"c1","uid":1759325,"ip_address":"","ucode":"4FA1D5CBBEF702","user_header":"https://static001.geekbang.org/account/avatar/00/1a/d8/5d/07dfb3b5.jpg","comment_is_top":false,"comment_ctime":1658902962,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1658902962","product_id":100028001,"comment_content":"“CPU 缓存可以分为一级缓存（L1）、二级缓存（L2）和三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分” 就是说L1中的数据在L2中也有一份？为什么要这么设计，L2存增量不就好了吗？","like_count":0},{"had_liked":false,"id":347506,"user_name":"Bumblebee","can_delete":false,"product_type":"c1","uid":2051293,"ip_address":"","ucode":"B879C8A511D08D","user_header":"https://static001.geekbang.org/account/avatar/00/1f/4c/dd/c6035349.jpg","comment_is_top":false,"comment_ctime":1654091836,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1654091836","product_id":100028001,"comment_content":"我觉得concurrenthashmap的get是弱一致性，可以这么理解，写操作是加锁的，get操作是无锁的，因此get操作有可能拿到写操作的中间值，因此是弱一致性（尽管volatile保证了可见性）；<br><br><br>希望老师能点评一下，不知道这样理解对不对；","like_count":0},{"had_liked":false,"id":258351,"user_name":"Only now","can_delete":false,"product_type":"c1","uid":1038574,"ip_address":"","ucode":"C617473A03AE27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/d8/ee/6e7c2264.jpg","comment_is_top":false,"comment_ctime":1604394266,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604394266","product_id":100028001,"comment_content":"关于存储模型这一节，通过实验结果很难接受。还请老师解答。<br>在实验中，非volatile共享堆变量，是一个bool值， 使用x86_64机器， Oracle jdk 1.8进行测试。<br><br>extern boolean stop = false;<br>new Thread(()-&gt;{<br>  while(!stop){}<br>  System.out.println(&quot;over&quot;);<br>}).start();<br>System.sleep(100L);<br>stop = true;<br><br>这样一段代码实际上不会停下来。按照三级缓存的这个说法，当内核在进行线程调度时会失效缓存，所以当线程被再次调入执行，它就应该可以看到stop更改的值，因为这个时候缓存已经更换过了。<br>然而事实并不会发现打印输出并停下来。<br><br>另有，缓存一致性协议EMSI应可以同步缓存，实际上也没效果。","like_count":0,"discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412708,"discussion_content":"这里的代码要做写改动 stop要修饰成boolean static。因为要让java把变量扔到linux进程的只读段里去。这样就会因为println里的synchronized 的lock api造成工作线程变量副本被实时刷新。最后代码也就停下来了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636257737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232790,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1594117465,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1594117465","product_id":100028001,"comment_content":"老师好，俩个线程共同执行X共享变量，有种结果是2,1，这个结果是怎么出现的哈？可以帮分析下么？","like_count":0,"discussions":[{"author":{"id":1235750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","nickname":"天使梦泪","note":"","ucode":"782991747DD424","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289631,"discussion_content":"我执行了好几次，结果都是2，2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594168933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202283,"user_name":"will","can_delete":false,"product_type":"c1","uid":1156207,"ip_address":"","ucode":"7A7DBE3E0EEAEB","user_header":"https://static001.geekbang.org/account/avatar/00/11/a4/6f/672a27d4.jpg","comment_is_top":false,"comment_ctime":1585960665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585960665","product_id":100028001,"comment_content":"大概理解了所谓的数据一致性，还需要多复习几遍","like_count":0},{"had_liked":false,"id":199374,"user_name":"10年以后","can_delete":false,"product_type":"c1","uid":1297421,"ip_address":"","ucode":"FE58CA7E5C2AF9","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/0d/89435926.jpg","comment_is_top":false,"comment_ctime":1585487960,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585487960","product_id":100028001,"comment_content":"一致性","like_count":0},{"had_liked":false,"id":149357,"user_name":"考休","can_delete":false,"product_type":"c1","uid":1053955,"ip_address":"","ucode":"968DFC00D6D0CF","user_header":"https://static001.geekbang.org/account/avatar/00/10/15/03/c0fe1dbf.jpg","comment_is_top":false,"comment_ctime":1573201218,"is_pvip":false,"replies":[{"id":"57609","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573383560,"ip_address":"","comment_id":149357,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573201218","product_id":100028001,"comment_content":"由于编译优化，可能会导致执行指令重排序的问题，为此Java内存模型中引入了happen-before规则，即便学习Java开发这么多年，再看这个原则还是有很多晦涩难懂的地方。前人栽树，后人乘凉，感谢设计Java语言的大神们搞出这么牛X的方案，让大部分开发者在并发编程也几乎不必考虑这个重排序问题。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473831,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573383560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129761,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1567241906,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1567241906","product_id":100028001,"comment_content":"专栏值啊，奋起直追，追呀","like_count":0},{"had_liked":false,"id":117184,"user_name":"K","can_delete":false,"product_type":"c1","uid":1118374,"ip_address":"","ucode":"69831D1EFC083C","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/a6/4d2c933e.jpg","comment_is_top":false,"comment_ctime":1563983156,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563983156","product_id":100028001,"comment_content":"老师好，网上的文章一直在说，volatile关键字，有可见性，有序性，不保证原子性。对于可见性是比较清楚的。对于有序性，结合老师刚刚那个图，我理解是单个线程执行的时候，代码肯定是有序执行的。多个线程执行，还是会出现乱序的情况。就像老师图里画的那样，是一个顺序一致性，不是强一致性。另外：希望老师能讲讲volatile的内存屏障，那块来来回回看总是不理解。谢谢老师。","like_count":0},{"had_liked":false,"id":111336,"user_name":"面朝大海","can_delete":false,"product_type":"c1","uid":1520864,"ip_address":"","ucode":"9A03425C0F5E8A","user_header":"https://static001.geekbang.org/account/avatar/00/17/34/e0/daa1d4b2.jpg","comment_is_top":false,"comment_ctime":1562546333,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562546333","product_id":100028001,"comment_content":"int x = 1;&#47;&#47; 步骤 1：加载 x 变量的内存地址到寄存器中，加载 1 到寄存器中，CPU 通过 mov 指令把 1 写入到寄存器指定的内存中<br>boolean flag = true; &#47;&#47; 步骤 2 加载 flag 变量的内存地址到寄存器中，加载 true 到寄存器中，CPU 通过 mov 指令把 1 写入到寄存器指定的内存中<br>int y = x + 1;&#47;&#47; 步骤 3 重新加载 a 变量的内存地址到寄存器中，加载 1 到寄存器中，CPU 通过 mov 指令把 1 写入到寄存器指定的内存中<br>","like_count":0},{"had_liked":false,"id":110967,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1562404019,"is_pvip":false,"replies":[{"id":"40384","content":"这里只是假设，有专门一个指令重排序的例子。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562463876,"ip_address":"","comment_id":110967,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562404019","product_id":100028001,"comment_content":"请问老师，指令重排优化会受多线程影响吗？感觉应该不会出现赋值为true和x=1这两条指令对换位置。因为从单线程来看这没有指令重排的价值，所以感觉不会做重排优化。而如果重排优化会受多线程影响，那么场景1的r1==1应该是赋值为true，然后进入了if逻辑，接着优先执行x=1才导致的r1==1的结果。布尔赋值为true和if判断应该要紧挨着，减少一次寄存器加载该临时变量值。也就是老师那个场景1不会出现。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457149,"discussion_content":"这里只是假设，有专门一个指令重排序的例子。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562463876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110872,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1562381972,"is_pvip":false,"replies":[{"id":"40386","content":"会有重排序问题","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562464190,"ip_address":"","comment_id":110872,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562381972","product_id":100028001,"comment_content":"单核也会有问题的，还有重排序。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457103,"discussion_content":"会有重排序问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562464190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":110834,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1562370720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562370720","product_id":100028001,"comment_content":"点赞666","like_count":0}]}