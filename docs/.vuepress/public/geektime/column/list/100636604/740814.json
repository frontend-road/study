{"id":740814,"title":"第 13 章 实用工具特型","content":"\n<blockquote>\n<p>科学无非就是在自然界的多样性中寻求统一性（或者更确切地说，是在我们经验的多样性中寻求统一性）。用 Coleridge 的话说，诗歌、绘画、艺术，同样是在多样性中寻求统一性。</p>\n<p style=\"text-align: right\">——Jacob Bronowski</p>\n</blockquote>\n<p>&nbsp;</p>\n<p>本章讲解了所谓的 Rust“实用工具”特型，这是标准库中各种特型的“百宝箱”，它们对 Rust 的编写方式有相当大的影响，所以，只有熟悉它们，你才能写出符合 Rust 语言惯例的代码并据此为你的 crate 设计公共接口，让用户认为这些接口是符合 Rust 风格的。Rust 实用工具特型可分为三大类。</p>\n<blockquote>\n<p>语言扩展特型</p>\n</blockquote>\n<p>第 12 章中介绍的运算符重载特型能让你在自己的类型上使用 Rust 的表达式运算符，同样，还有其他几个标准库特型也是 Rust 的扩展点，允许你把自己的类型更紧密地集成进语言中。这类特型包括 <code>Drop</code>、<code>Deref</code> 和 <code>DerefMut</code>，以及转换特型 <code>From</code> 和 <code>Into</code>。我们将在本章中讲解它们。</p>\n<blockquote>\n<p>标记特型</p>\n</blockquote>\n<p>这类特型多用作泛型类型变量的限界，以表达无法以其他方式捕获的约束条件。<code>Sized</code> 和 <code>Copy</code> 就属于这类特型。</p>\n<blockquote>\n<p>公共词汇特型</p>\n</blockquote>\n<p>这类特型不涉及任何编译器魔术，你完全可以在自己的代码中定义其等效特型。之所以定义它们，是为了给常见问题制定一些约定俗成的解决方案。这对 crate 和模块之间的公共接口来说特别有价值：通过减少不必要的变体，让接口更容易理解，也增加了把来自不同 crate 的特性轻易插接在一起的可能性，而且无须样板代码或自定义胶水代码。</p><!-- [[[read_end]]] -->\n<p>这类特型包括 <code>Default</code>、引用借用特型 <code>AsRef</code>、<code>AsMut</code>、<code>Borrow</code> 与 <code>BorrowMut</code>、容错的转换特型 <code>TryFrom</code> 与 <code>TryInto</code>，以及 <code>ToOwned</code> 特型（对 <code>Clone</code> 的泛化）。</p>\n<p>表 13-1 对上述特型进行了汇总。</p>\n<p><strong>表 13-1：实用工具特型汇总表</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>特型</p></th>\n<th><p>描述</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p><code>Drop</code></p></td>\n<td><p>析构器。每当丢弃一个值时，Rust 都要自动运行的清理代码</p></td>\n</tr>\n<tr>\n<td><p><code>Sized</code></p></td>\n<td><p>具有在编译期已知的固定大小类型的标记特型，与之相对的是动态大小类型（如切片）</p></td>\n</tr>\n<tr>\n<td><p><code>Clone</code></p></td>\n<td><p>用来支持克隆值的类型</p></td>\n</tr>\n<tr>\n<td><p><code>Copy</code></p></td>\n<td><p>可以简单地通过对包含值的内存进行逐字节复制以进行克隆的类型的标记特型</p></td>\n</tr>\n<tr>\n<td><p><code>Deref</code> 与 <code>DerefMut</code></p></td>\n<td><p>智能指针类型的特型</p></td>\n</tr>\n<tr>\n<td><p><code>Default</code></p></td>\n<td><p>具有合理“默认值”的类型</p></td>\n</tr>\n<tr>\n<td><p><code>AsRef</code> 与 <code>AsMut</code></p></td>\n<td><p>用于从另一种类型中借入一种引用类型的转换特型</p></td>\n</tr>\n<tr>\n<td><p><code>Borrow</code> 与 <code>BorrowMut</code></p></td>\n<td><p>转换特型，类似 <code>AsRef</code>/<code>AsMut</code>，但能额外保证一致的哈希、排序和相等性</p></td>\n</tr>\n<tr>\n<td><p><code>From</code> 与 <code>Into</code></p></td>\n<td><p>用于将一种类型的值转换为另一种类型的转换特型</p></td>\n</tr>\n<tr>\n<td><p><code>TryFrom</code> 与 <code>TryInto</code></p></td>\n<td><p>用于将一种类型的值转换为另一种类型的转换特型，用于可能失败的转换</p></td>\n</tr>\n<tr>\n<td><p><code>ToOwned</code></p></td>\n<td><p>用于将引用转换为拥有型值的转换特型</p></td>\n</tr>\n</tbody>\n</table>\n<p>还有另一些重要的标准库特型。第 15 章会介绍 <code>Iterator</code> 和 <code>IntoIterator</code>。第 16 章会介绍用于计算哈希值的 <code>Hash</code> 特型。第 19 章会介绍两个用于标记线程安全类型的特型 <code>Send</code> 和 <code>Sync</code>。</p>\n<h2 id=\"nav_point_212\">13.1　<code>Drop</code></h2>\n<p>当一个值的拥有者消失时，Rust 会<strong>丢弃</strong>（drop）该值。丢弃一个值就必须释放该值拥有的任何其他值、堆存储和系统资源。丢弃可能发生在多种情况下：当变量超出作用域时；在表达式语句的末尾；当截断一个向量时，会从其末尾移除元素；等等。</p>\n<p>在大多数情况下，Rust 会自动处理丢弃值的工作。假设你定义了以下类型：</p>\n<pre class=\"code-rows\"><code>struct Appellation {\n    name: String,\n    nicknames: Vec&lt;String&gt;\n}</code></pre>\n<p><code>Appellation</code> 拥有用作字符串内容和向量元素缓冲区的堆存储。每当 <code>Appellation</code> 被丢弃时，Rust 都会负责清理所有这些内容，无须你进行任何进一步的编码。但只要你想，也可以通过实现 <code>std::ops::Drop</code> 特型来自定义 Rust 该如何丢弃此类型的值：</p>\n<pre class=\"code-rows\"><code>trait Drop {\n    fn drop(&amp;mut self);\n}</code></pre>\n<p><code>Drop</code> 的实现类似于 C++ 中的析构函数或其他语言中的终结器。当一个值被丢弃时，如果它实现了 <code>std::ops::Drop</code>，那么 Rust 就会调用它的 <code>drop</code> 方法，然后像往常一样继续丢弃它的字段或元素拥有的任何值。这种对 <code>drop</code> 的隐式调用是调用该方法的唯一途径。如果你试图显式调用该方法，那么 Rust 会将其标记为错误。</p>\n<p>Rust 在丢弃某个值的字段或元素之前会先对值本身调用 <code>Drop::drop</code>，该方法收到的值仍然是已完全初始化的。因此，在 <code>Appellation</code> 类型的 <code>Drop</code> 实现中可以随意使用其字段：</p>\n<pre class=\"code-rows\"><code>impl Drop for Appellation {\n    fn drop(&amp;mut self) {\n        print!(\"Dropping {}\", self.name);\n        if !self.nicknames.is_empty() {\n            print!(\" (AKA {})\", self.nicknames.join(\", \"));\n        }\n        println!(\"\");\n    }\n}</code></pre>\n<p>基于该实现，可以编写以下内容：</p>\n<pre class=\"code-rows\"><code>{\n    let mut a = Appellation {\n        name: \"Zeus\".to_string(),\n        nicknames: vec![\"cloud collector\".to_string(),\n                        \"king of the gods\".to_string()]\n    };\n\n    println!(\"before assignment\");\n    a = Appellation { name: \"Hera\".to_string(), nicknames: vec![] };\n    println!(\"at end of block\");\n}</code></pre>\n<p>当我们将第二个 <code>Appellation</code> 赋值给 <code>a</code> 时，就会丢弃第一个 <code>Appellation</code>，而当我们离开 <code>a</code> 的作用域时，就会丢弃第二个 <code>Appellation</code>。上述代码会打印出以下内容：</p>\n<pre class=\"code-rows\"><code>before assignment\nDropping Zeus (AKA cloud collector, king of the gods)\nat end of block\nDropping Hera</code></pre>\n<p><code>Appellation</code> 的 <code>std::ops::Drop</code> 实现只打印了一条消息，那么它的内存究竟是如何清理的呢？<code>Vec</code> 类型实现了 <code>Drop</code>，它会丢弃自己的每一个元素，然后释放它们占用的分配在堆上的缓冲区。<code>String</code> 在内部使用 <code>Vec&lt;u8&gt;</code> 来保存它的文本，因此 <code>String</code> 不需要自己实现 <code>Drop</code>，它会让 <code>Vec</code> 负责释放这些字符。同样的原则也适用于 <code>Appellation</code> 值：当一个值被丢弃时，最终由 <code>Vec</code> 的 <code>Drop</code> 实现来负责真正释放每个字符串的内容，并释放保存这些向量元素的缓冲区。至于 <code>Appellation</code> 值本身占用的内存，它的拥有者（可能是某个局部变量或某些数据结构）会负责释放。</p>\n<p>如果一个变量的值移动到了别处，以致该变量在超出作用域时正处于未初始化状态，那么 Rust 将不会试图丢弃该变量，因为这里没有需要丢弃的值。</p>\n<p>虽然根据控制流才能判断变量的值是否会移动出去，但这一原则仍然成立。在这种情况下，Rust 会使用一个不可见的标志来跟踪此变量的状态，该标志会指出是否需要丢弃此变量的值：</p>\n<pre class=\"code-rows\"><code>let p;\n{\n    let q = Appellation { name: \"Cardamine hirsuta\".to_string(),\n                          nicknames: vec![\"shotweed\".to_string(),\n                                          \"bittercress\".to_string()] };\n    if complicated_condition() {\n        p = q;\n    }\n}\nprintln!(\"Sproing! What was that?\");</code></pre>\n<p>根据 <code>complicated_condition</code> 返回的是 <code>true</code> 还是 <code>false</code>，<code>p</code> 或 <code>q</code> 中的一个会最终拥有 <code>Appellation</code>，而另一个则会变成未初始化状态。这种差异决定了它是在 <code>println!</code> 之前还是之后丢弃（因为 <code>q</code> 在 <code>println!</code> 之前就离开了作用域，而 <code>p</code> 则在 <code>println!</code> 之后离开的作用域）。虽然一个值可能会从一个地方移动到另一个地方，但 Rust 只会丢弃它一次。</p>\n<p>除非正在定义某个拥有 Rust 不了解的资源类型，通常我们不需要自己实现 <code>std::ops::Drop</code>。例如，在 Unix 系统上，Rust 的标准库在内部使用了以下类型来表示操作系统的文件描述符：</p>\n<pre class=\"code-rows\"><code>struct FileDesc {\n    fd: c_int,\n}</code></pre>\n<p><code>FileDesc</code> 的 <code>fd</code> 字段是当程序完成时应该关闭的文件描述符的编号，<code>c_int</code> 是 <code>i32</code> 的别名。标准库为 <code>FileDesc</code> 实现的 <code>Drop</code> 如下所示：</p>\n<pre class=\"code-rows\"><code>impl Drop for FileDesc {\n    fn drop(&amp;mut self) {\n        let _ = unsafe { libc::close(self.fd) };\n    }\n}</code></pre>\n<p>这里，<code>libc::close</code> 是 C 库中 <code>close</code> 函数的 Rust 名称。Rust 代码只能在 <code>unsafe</code> 块中调用 C 函数，因此在这里使用了一个 <code>unsafe</code> 块。</p>\n<p>如果一个类型实现了 <code>Drop</code>，就不能再实现 <code>Copy</code> 特型了。如果类型是 <code>Copy</code> 类型，就表示简单的逐字节复制足以生成该值的独立副本。但是，对同一份数据多次调用同一个 <code>drop</code> 方法显然是错误的。</p>\n<p>标准库预导入中包含一个丢弃值的函数 <code>drop</code>，但它的定义一点儿也不神奇：</p>\n<pre class=\"code-rows\"><code>fn drop&lt;T&gt;(_x: T) { }</code></pre>\n<p>换句话说，它会按值接受参数，从调用者那里获得所有权，然后什么也不做。当 <code>_x</code> 超出作用域时，Rust 自然会丢弃它的值，这跟对任何其他变量的操作一样。</p>\n<h2 id=\"nav_point_213\">13.2　<code>Sized</code></h2>\n<p><strong>固定大小类型</strong>是指其每个值在内存中都有相同大小的类型。Rust 中的几乎所有类型都是固定大小的，比如每个 <code>u64</code> 占用 8 字节，每个 <code>(f32, f32, f32)</code> 元组占用 12 字节。甚至枚举也是有大小的，也就是说，无论实际存在的是哪个变体，枚举总会占据足够的空间来容纳其最大的变体。尽管 <code>Vec&lt;T&gt;</code> 拥有一个大小可变的堆分配缓冲区，但 <code>Vec</code> 值本身是指向“缓冲区、容量和长度”的指针，因此 <code>Vec&lt;T&gt;</code> 也是一个固定大小类型。</p>\n<p>所有固定大小类型都实现了 <code>std::marker::Sized</code> 特型，该特型没有方法或关联类型。Rust 自动为所有适用的类型实现了 <code>std::marker::Sized</code> 特型，你不能自己实现它。<code>Sized</code> 的唯一用途是作为类型变量的限界：像 <code>T: Sized</code> 这样的限界要求 <code>T</code> 必须是在编译期已知的类型。由于 Rust 语言本身会使用这种类型的特型为具有某些特征的类型打上标记，因此我们将其称为<strong>标记特型</strong>。</p>\n<p>然而，Rust 也有一些<strong>无固定大小类型</strong>，它们的值大小不尽相同。例如，字符串切片类型 <code>str</code>（注意没有 <code>&amp;</code>）就是无固定大小的。字符串字面量 <code>\"diminutive\"</code> 和 <code>\"big\"</code> 是对占用了 10 字节和 3 字节的 <code>str</code> 切片的引用，两者都展示在图 13-1 中。像 <code>[T]</code>（同样没有 <code>&amp;</code>）这样的数组切片类型也是无固定大小的，即像 <code>&amp;[u8]</code> 这样的共享引用可以指向任意大小的 <code>[u8]</code> 切片。因为 <code>str</code> 类型和 <code>[T]</code> 类型都表示不定大小的值集，所以它们是无固定大小类型。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100006/image00858.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 13-1：对无固定大小的值的引用</strong></p>\n<p>Rust 中另一种常见的无固定大小类型是 <code>dyn</code> 类型，它是特型对象的引用目标。正如我们在 11.1.1 节中所解释的那样，特型对象是指向实现了给定特型的某个值的指针。例如，类型 <code>&amp;dyn std::io::Write</code> 和 <code>Box&lt;dyn std::io::Write&gt;</code> 是指向实现了 <code>Write</code> 特型的某个值的指针。引用目标可能是文件、网络套接字，或某种实现了 <code>Write</code> 的自定义类型。由于实现了 <code>Write</code> 的类型集是开放式的，因此 <code>dyn Write</code> 作为一个类型也是无固定大小的，也就是说它的值可以有各种大小。</p>\n<p>Rust 不能将无固定大小的值存储在变量中或将它们作为参数传递。你只能通过像 <code>&amp;str</code> 或 <code>Box&lt;dyn Write&gt;</code> 这样的本身是固定大小的指针来处理它们。如图 13-1 所示，指向无固定大小值的指针始终是一个<strong>胖指针</strong>，宽度为两个机器字：指向切片的指针带有切片的长度，特型对象带有指向方法实现的虚表的指针。</p>\n<p>特型对象和指向切片的指针在结构上很像。这两种类型都缺乏某种在使用它们时必要的信息。换句话说，你无法在不知道其长度的情况下对 <code>[u8]</code> 进行索引，也无法在不知道该对某个值使用 <code>Write</code> 的哪个具体实现的情况下调用 <code>Box&lt;dyn Write&gt;</code> 的方法。对于这两种类型，胖指针都会补齐类型中缺少的信息——它携带着长度或虚表指针。既然欠缺静态信息，那就用动态信息来弥补。</p>\n<p>由于无固定大小类型处处受限，因此大多数泛型类型变量应当被限制为固定大小的 <code>Sized</code> 类型。事实上，鉴于这种情况的普遍性，<code>Sized</code> 已经成为 Rust 中的隐式默认值：如果你写 <code>struct S&lt;T&gt; { ... }</code>，那么 Rust 会将其理解为 <code>struct S&lt;T: Sized&gt; { ... }</code>。如果你不想以这种方式约束 <code>T</code>，就必须将其明确地排除，写成 <code>struct S&lt;T: ?Sized&gt; { ... }</code>。<code>?Sized</code> 语法专用于这种情况，意思是“不要求固定大小的”。如果你写 <code>struct S&lt;T: ?Sized&gt; { b: Box&lt;T&gt; }</code>，那么 Rust 将允许写成 <code>S&lt;str&gt;</code> 和 <code>S&lt;dyn Write&gt;</code>，这样这两个 Box 就变成了胖指针，而不像 <code>S&lt;i32&gt;</code> 和 <code>S&lt;String&gt;</code> 的 Box 那样只是普通指针。</p>\n<p>尽管存在一些限制，但无固定大小类型能让 Rust 的类型系统工作得更顺畅。阅读标准库文档时，你偶尔会遇到类型变量上的 <code>?Sized</code> 限界，这几乎总是表明“给定的类型只能通过指针访问”，并能让其关联的代码与切片对象和特型对象以及普通值一起使用。当类型变量具有 <code>?Sized</code> 限界时，人们认为它的<strong>大小不确定</strong>，既可能是固定大小，也可能不是。</p>\n<p>除了切片对象和特型对象，还有另一种无固定大小类型。结构体类型的最后一个字段（而且只能是最后一个）可以是无固定大小的，并且这样的结构体本身也是无固定大小的。例如，<code>Rc&lt;T&gt;</code> 引用计数指针的内部实现是指向私有类型 <code>RcBox&lt;T&gt;</code> 的指针，后者把引用计数和 <code>T</code> 保存在一起。下面是 <code>RcBox</code> 的简化定义：</p>\n<pre class=\"code-rows\"><code>struct RcBox&lt;T: ?Sized&gt; {\n    ref_count: usize,\n    value: T,\n}</code></pre>\n<p><code>Rc&lt;T&gt;</code> 是引用计数指针，其中的 <code>value</code> 字段是 <code>Rc&lt;T&gt;</code> 对其进行引用计数的 <code>T</code> 类型。<code>Rc&lt;T&gt;</code> 会解引用成指向 <code>value</code> 字段的指针。<code>ref_count</code> 字段会保存其引用计数。</p>\n<p>真正的 <code>RcBox</code> 只是标准库的一个实现细节，无法在外部使用。但假设我们正在使用前面这种定义，那么就可以将此 <code>RcBox</code> 与固定大小类型一起使用，比如 <code>RcBox&lt;String&gt;</code> 的结果是一个固定大小的结构体类型。或者也可以将它与无固定大小类型一起使用，比如 <code>RcBox&lt;dyn std::fmt::Display&gt;</code>（其中 <code>Display</code> 是可以通过 <code>println!</code> 之类的宏进行格式化的类型的特型），结果 <code>RcBox&lt;dyn Display&gt;</code> 就成了无固定大小的结构体类型。</p>\n<p>不能直接构建 <code>RcBox&lt;dyn Display&gt;</code> 值，而应该先创建一个普通的固定大小的 <code>RcBox</code>，并让其 <code>value</code> 类型实现 <code>Display</code>，比如 <code>RcBox&lt;String&gt;</code>。然后 Rust 就会允许你将引用 <code>&amp;RcBox&lt;String&gt;</code> 转换为胖引用 <code>&amp;RcBox&lt;dyn Display&gt;</code>：</p>\n<pre class=\"code-rows\"><code>let boxed_lunch: RcBox&lt;String&gt; = RcBox {\n    ref_count: 1,\n    value: \"lunch\".to_string()\n};\n\nuse std::fmt::Display;\nlet boxed_displayable: &amp;RcBox&lt;dyn Display&gt; = &amp;boxed_lunch;</code></pre>\n<p>在将值传给函数时会发生隐式转换，这样你就可以将 <code>&amp;RcBox&lt;String&gt;</code> 传给需要 <code>&amp;RcBox&lt;dyn Display&gt;</code> 的函数：</p>\n<pre class=\"code-rows\"><code>fn display(boxed: &amp;RcBox&lt;dyn Display&gt;) {\n    println!(\"For your enjoyment: {}\", &amp;boxed.value);\n}\n\ndisplay(&amp;boxed_lunch);</code></pre>\n<p>这将生成以下输出。</p>\n<pre class=\"code-rows\"><code>For your enjoyment: lunch</code></pre>\n<h2 id=\"nav_point_214\">13.3　<code>Clone</code></h2>\n<p><code>std::clone::Clone</code> 特型适用于可复制自身的类型。<code>Clone</code> 定义如下：</p>\n<pre class=\"code-rows\"><code>trait Clone: Sized {\n    fn clone(&amp;self) -&gt; Self;\n    fn clone_from(&amp;mut self, source: &amp;Self) {\n        *self = source.clone()\n    }\n}</code></pre>\n<p><code>clone</code> 方法应该为 <code>self</code> 构造一个独立的副本并返回它。由于此方法的返回类型是 <code>Self</code>，并且函数本来也不可能返回无固定大小的值，因此 <code>Clone</code> 特型也是扩展自 <code>Sized</code> 特型的，进而导致其实现代码中的 <code>Self</code> 类型被限界成了 <code>Sized</code>。</p>\n<p>克隆一个值通常还需要为它拥有的任何值分配副本，因此 <code>clone</code> 无论在时间消耗还是内存占用方面都是相当昂贵的。例如，克隆 <code>Vec&lt;String&gt;</code> 不仅会复制此向量，还会复制它的每个 <code>String</code> 元素。这就是 Rust 不会自动克隆值，而是要求你进行显式方法调用的原因。像 <code>Rc&lt;T&gt;</code> 和 <code>Arc&lt;T&gt;</code> 这样的引用计数指针类型属于例外，即克隆其中任何一个都只会增加引用计数并为你返回一个新指针。</p>\n<p><code>clone_from</code> 方法会把 <code>self</code> 修改成 <code>source</code> 的副本。<code>clone_from</code> 的默认定义只是克隆 <code>source</code>，然后将其转移给 <code>*self</code>。这固然可行，但对于某些类型，有一种更快的方法可以获得同样的效果。假设 <code>s</code> 和 <code>t</code> 都是 <code>String</code>。<code>s = t.clone();</code> 语句必然会克隆 <code>t</code>，丢弃 <code>s</code> 的旧值，然后将克隆后的值转移给 <code>s</code>，这会进行一次堆分配和一次堆释放。但是如果属于原始 <code>s</code> 的堆缓冲区有足够的容量来保存 <code>t</code> 的内容，则不需要分配或释放：可以简单地将 <code>t</code> 的文本复制到 <code>s</code> 的缓冲区并调整长度。在泛型代码中，应该优先使用 <code>clone_from</code>，以便充分利用这种优化。</p>\n<p>如果你的 <code>Clone</code> 实现只需要简单地对类型中的每个字段或元素进行 <code>clone</code>，然后从这些克隆结果中构造一个新值，并且认为 <code>clone_from</code> 的默认定义已经足够好了，那么 Rust 也可以帮你实现：只要在类型定义上方写 <code>#[derive(Clone)]</code> 就可以了。</p>\n<p>标准库中几乎所有能合理复制的类型都实现了 <code>Clone</code>。不仅 <code>bool</code>、<code>i32</code> 等原始类型实现了 <code>Clone</code>，<code>String</code>、<code>Vec&lt;T&gt;</code> 和 <code>HashMap</code> 等容器类型也实现了 <code>Clone</code>。而那些无法合理复制的类型（如 <code>std::sync::Mutex</code>）则没有实现 <code>Clone</code>。像 <code>std::fs::File</code> 这样的类型虽然可以复制，但如果操作系统无法提供必要的资源，则复制可能会失败。这些类型也没有实现 <code>Clone</code>，因为 <code>clone</code> 必须是不会失败的。作为替代，<code>std::fs::File</code> 提供了一个 <code>try_clone</code> 方法，该方法会返回一个 <code>std::io::Result&lt;File&gt;</code> 值，用以报告失败信息。</p>\n<h2 id=\"nav_point_215\">13.4　<code>Copy</code></h2>\n<p>在第 4 章中，我们曾解释说，对于大多数类型，赋值时会移动值，而不是复制它们。移动值可以更简单地跟踪它们所拥有的资源。但在 4.3 节中，我们指出了例外情况：不拥有任何资源的简单类型可以是 <code>Copy</code> 类型，对这些简单类型赋值会创建源的副本，而不会移动值并使源回到未初始化状态。</p>\n<p>当时，我们没有充分解释 <code>Copy</code> 类型到底是什么，现在可以告诉你了：如果一个类型实现了 <code>std::marker::Copy</code> 标记特型，那么它就是 <code>Copy</code> 类型，其定义如下所示：</p>\n<pre class=\"code-rows\"><code>trait Copy: Clone { }</code></pre>\n<p>对于你自己的类型，这当然很容易实现：</p>\n<pre class=\"code-rows\"><code>impl Copy for MyType { }</code></pre>\n<p>但由于 <code>Copy</code> 是一种对语言有着特殊意义的标记特型，因此只有当类型需要一个浅层的逐字节复制时，Rust 才允许它实现 <code>Copy</code>。拥有任何其他资源（比如堆缓冲区或操作系统句柄）的类型都无法实现 <code>Copy</code>。</p>\n<p>任何实现了 <code>Drop</code> 特型的类型都不能是 <code>Copy</code> 类型。Rust 认为如果一个类型需要特殊的清理代码，那么就必然需要特殊的复制代码，因此不能是 <code>Copy</code> 类型。</p>\n<p>与 <code>Clone</code> 一样，可以使用 <code>#[derive(Copy)]</code> 让 Rust 为你派生出 <code>Copy</code> 实现。你会经常看到同时使用 <code>#[derive(Copy, Clone)]</code> 进行派生的代码。</p>\n<p>在允许一个类型成为 <code>Copy</code> 类型之前务必慎重考虑。尽管这样做能让该类型更易于使用，但也对其实现施加了严格的限制。如果复制的开销很高，那么就不适合进行隐式复制。4.3 节曾详细解释过这些因素。</p>\n<h2 id=\"nav_point_216\">13.5　<code>Deref</code> 与 <code>DerefMut</code></h2>\n<p>通过实现 <code>std::ops::Deref</code> 特型和 <code>std::ops::DerefMut</code> 特型，可以指定像 <code>*</code> 和 <code>.</code> 这样的解引用运算符在你的类型上的行为。像 <code>Box&lt;T&gt;</code> 和 <code>Rc&lt;T&gt;</code> 这样的指针类型就实现了这些特型，因此它们可以像 Rust 的内置指针类型那样用。如果你有一个 <code>Box&lt;Complex&gt;</code> 型的值 <code>b</code>，那么 <code>*b</code> 引用的就是 <code>b</code> 指向的 <code>Complex</code>（复数）值，而 <code>b.re</code> 引用的是它的实部。如果上下文对引用目标进行了赋值或借用了可变引用，那么 Rust 就会使用 <code>DerefMut</code>（解可变引用）特型，否则，只要通过 <code>Deref</code> 进行只读访问就够了。</p>\n<p>这两个特型的定义如下所示：</p>\n<pre class=\"code-rows\"><code>trait Deref {\n    type Target: ?Sized;\n    fn deref(&amp;self) -&gt; &amp;Self::Target;\n}\n\ntrait DerefMut: Deref {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target;\n}</code></pre>\n<p><code>deref</code> 方法会接受 <code>&amp;Self</code> 引用并返回 <code>&amp;Self::Target</code> 引用，而 <code>deref_mut</code> 方法会接受 <code>&amp;mut Self</code> 引用并返回 <code>&amp;mut Self::Target</code> 引用。<code>Target</code> 应该是 <code>Self</code> 包含、拥有或引用的资源：对于 <code>Box&lt;Complex&gt;</code>，其 <code>Target</code> 类型是 <code>Complex</code>。请注意 <code>DerefMut</code> 扩展了 <code>Deref</code>：如果可以解引用并修改某些资源，那么当然也可以借入对它的共享引用。由于这些方法会返回与 <code>&amp;self</code> 生命周期相同的引用，因此只要返回的引用还存在，<code>self</code> 就会一直处于已借出状态。</p>\n<p><code>Deref</code> 特型和 <code>DerefMut</code> 特型还扮演着另一个角色。由于 <code>deref</code> 会接受 <code>&amp;Self</code> 引用并返回 <code>&amp;Self::Target</code> 引用，因此 Rust 会利用这一点自动将前一种类型的引用转换为后一种类型的引用。换句话说，如果只要插入一个 <code>deref</code> 调用就能解决类型不匹配问题，那 Rust 就会插入它。实现 <code>DerefMut</code> 也可以为可变引用启用相应的转换。这些叫作<strong>隐式解引用</strong>：一种类型被“转换”成了另一种类型。</p>\n<p>尽管隐式解引用也可以通过显式的方式写出来，但隐式解引用使用起来更方便。</p>\n<ul>\n<li>如果你有一个 <code>Rc&lt;String&gt;</code> 型的值 <code>r</code>，并想对其调用 <code>String::find</code>，就可以简单地写成 <code>r.find('?')</code>，而不用写成 <code>(*r).find('?')</code>：这种方法调用会隐式借入 <code>r</code>，并将 <code>&amp;Rc&lt;String&gt;</code> 转换为 <code>&amp;String</code>，因为 <code>Rc&lt;T&gt;</code> 实现了 <code>Deref&lt;Target=T&gt;</code>。</li>\n<li>你可以对 <code>String</code> 值使用 <code>split_at</code> 之类的方法，虽然 <code>split_at</code> 是在 <code>str</code> 切片类型上定义的方法，但因为 <code>String</code> 实现了 <code>Deref&lt;Target=str&gt;</code>，所以可以这样写。<code>String</code> 不需要重新实现 <code>str</code> 的所有方法，因为可以将 <code>&amp;String</code> 隐式转换为 <code>&amp;str</code>。</li>\n<li>如果你有一个字节向量 <code>v</code> 并且想将它传给需要字节切片 <code>&amp;[u8]</code> 的函数，就可以简单地将 <code>&amp;v</code> 作为参数传递，因为 <code>Vec&lt;T&gt;</code> 实现了 <code>Deref&lt;Target=[T]&gt;</code>。</li>\n</ul>\n<p>在必要的情况下，Rust 会连续应用多个隐式解引用。例如，使用前面提到的隐式转换，你可以将 <code>split_at</code> 直接应用于 <code>Rc&lt;String&gt;</code>，因为 <code>&amp;Rc&lt;String&gt;</code> 解引用成了 <code>&amp;String</code>，后者又解引用成了 <code>&amp;str</code>，而 <code>&amp;str</code> 具有 <code>split_at</code> 方法。</p>\n<p>假设你有以下类型：</p>\n<pre class=\"code-rows\"><code>struct Selector&lt;T&gt; {\n    /// 在这个`Selector`中可用的元素\n    elements: Vec&lt;T&gt;,\n\n    /// `elements`中“当前”（current）元素的索引\n    /// `Selector`的行为类似于指向当前元素的指针\n    current: usize\n}</code></pre>\n<p>要让 <code>Selector</code> 的行为与文档型注释中声明的一致，就必须为该类型实现 <code>Deref</code> 和 <code>DerefMut</code>：</p>\n<pre class=\"code-rows\"><code>use std::ops::;\n\nimpl&lt;T&gt; Deref for Selector&lt;T&gt; {\n    type Target = T;\n    fn deref(&amp;self) -&gt; &amp;T {\n        &amp;self.elements[self.current]\n    }\n}\n\nimpl&lt;T&gt; DerefMut for Selector&lt;T&gt; {\n    fn deref_mut(&amp;mut self) -&gt; &amp;mut T {\n        &amp;mut self.elements[self.current]\n    }\n}</code></pre>\n<p>给定上述实现，可以像下面这样使用 <code>Selector</code>：</p>\n<pre class=\"code-rows\"><code>let mut s = Selector { elements: vec!['x', 'y', 'z'],\n                       current: 2 };\n\n// 因为`Selector`实现了`Deref`，所以可以使用`*`运算符来引用它的当前元素\nassert_eq!(*s, 'z');\n\n// 通过隐式解引用直接在`Selector`上使用`char`的方法断言'z'是字母\nassert!(s.is_alphabetic());\n\n// 通过对此`Selector`的引用目标赋值，把'z'改成了'w'\n*s = 'w';\n\nassert_eq!(s.elements, ['x', 'y', 'w']);</code></pre>\n<p><code>Deref</code> 特型和 <code>DerefMut</code> 特型旨在实现诸如 <code>Box</code>、<code>Rc</code> 和 <code>Arc</code> 之类的智能指针类型，以及其拥有型版本会频繁通过引用来使用的类型（比如 <code>Vec&lt;T&gt;</code> 和 <code>String</code> 就是 <code>[T]</code> 和 <code>str</code> 的拥有型版本）。仅仅为了让 <code>Target</code> 类型的方法能自动通过类型指针使用（就像 C++ 中那样让基类的方法在子类上可见）就为类型实现 <code>Deref</code> 和 <code>DerefMut</code> 是不对的。那样做的话并不总能如预期般工作，并且在出错时可能会让人困惑。</p>\n<p>隐式解引用有一个容易引起混淆的地方需要注意：Rust 会用它们来解决类型冲突，但并不会将其用于满足类型变量的限界。例如，下面的代码能正常工作：</p>\n<pre class=\"code-rows\"><code>let s = Selector { elements: vec![\"good\", \"bad\", \"ugly\"],\n                   current: 2 };\n\nfn show_it(thing: &amp;str) { println!(\"{}\", thing); }\nshow_it(&amp;s);</code></pre>\n<p>在调用 <code>show_it(&amp;s)</code> 时，Rust 发现了一个类型为 <code>&amp;Selector&lt;&amp;str&gt;</code> 的实参（argument）和一个类型为 <code>&amp;str</code> 的形参（parameter），据此找到了这个 <code>Deref&lt;Target=str&gt;</code> 实现，并根据需要将此调用重写成了 <code>show_it(s.deref())</code>。<span class=\"comment-number\">1</span></p>\n\n<p>但是，如果将 <code>show_it</code> 改成泛型函数，Rust 突然就报错了：</p>\n<pre class=\"code-rows\"><code>use std::fmt::Display;\nfn show_it_generic&lt;T: Display&gt;(thing: T) { println!(\"{}\", thing); }\nshow_it_generic(&amp;s);</code></pre>\n<p>Rust 报错说：</p>\n<pre class=\"code-rows\"><code>error: `Selector&lt;&amp;str&gt;` doesn't implement `std::fmt::Display`\n   |\n31 |  show_it_generic(&amp;s);\n   |                  ^^\n   |                  |\n   |                  `Selector&lt;&amp;str&gt;` cannot be formatted with\n   |                  the default formatter\n   |                  help: consider adding dereference here: `&amp;*s`\n   |\nnote: required by a bound in `show_it_generic`\n   |\n30 |  fn show_it_generic&lt;T: Display&gt;(thing: T) { println!(\"{}\", thing); }\n   |                        ^^^^^^^ required by this bound\n   |                                in `show_it_generic`</code></pre>\n<p>这可能会令人困惑：为什么仅仅把函数改成泛型形式就会引入错误呢？<code>Selector&lt;&amp;str&gt;</code> 本身确实没有实现 <code>Display</code>，但它解引用成了 <code>&amp;str</code>，而 <code>&amp;str</code> 实现了 <code>Display</code>。</p>\n<p>由于你要传入一个类型为 <code>&amp;Selector&lt;&amp;str&gt;</code> 的实参并且函数的形参类型为 <code>&amp;T</code>，因此类型变量 <code>T</code> 必然是 <code>Selector&lt;&amp;str&gt;</code>。然后，Rust 会检查这是否满足 <code>T: Display</code> 限界，但因为它不会通过隐式解引用来满足类型变量的限界，所以这个检查失败了。</p>\n<p>要解决此问题，可以使用 <code>as</code> 运算符进行显式转换：</p>\n<pre class=\"code-rows\"><code>show_it_generic(&amp;s as &amp;str);</code></pre>\n<p>或者，正如编译器建议的那样，可以使用 <code>&amp;*</code> 进行强制转换。</p>\n<pre class=\"code-rows\"><code>show_it_generic(&amp;*s);</code></pre>\n<h2 id=\"nav_point_217\">13.6　<code>Default</code></h2>\n<p>显然，某些类型具有合理的默认值：向量或字符串默认为空、数值默认为 0、<code>Option</code> 默认为 <code>None</code>，等等。这样的类型都可以实现 <code>std::default::Default</code> 特型：</p>\n<pre class=\"code-rows\"><code>trait Default {\n    fn default() -&gt; Self;\n}</code></pre>\n<p><code>default</code> 方法只会返回一个 <code>Self</code> 类型的新值。为 <code>String</code> 实现 <code>Default</code> 的代码一目了然：</p>\n<pre class=\"code-rows\"><code>impl Default for String {\n    fn default() -&gt; String {\n        String::new()\n    }\n}</code></pre>\n<p>Rust 的所有集合类型（<code>Vec</code>、<code>HashMap</code>、<code>BinaryHeap</code> 等）都实现了 <code>Default</code>，其 <code>default</code> 方法会返回一个空集合。当你需要构建一些值的集合但又想让调用者来决定具体构建何种集合时，这很有用。例如，<code>Iterator</code> 特型的 <code>partition</code> 方法会将迭代器生成的值分为两个集合，并使用闭包来决定每个值的去向：</p>\n<pre class=\"code-rows\"><code>use std::collections::HashSet;\nlet squares = [4, 9, 16, 25, 36, 49, 64];\nlet (powers_of_two, impure): (HashSet&lt;i32&gt;, HashSet&lt;i32&gt;)\n    = squares.iter().partition(|&amp;n| n &amp; (n-1) == 0);\nassert_eq!(powers_of_two.len(), 3);\nassert_eq!(impure.len(), 4);</code></pre>\n<p>闭包 <code>|&amp;n| n &amp; (n-1) == 0</code> 会使用一些位操作来识别哪些数值是 2 的幂，并且 <code>partition</code> 会使用它来生成两个 <code>HashSet</code>。不过，<code>partition</code> 显然不是专属于 <code>HashSet</code> 的，你可以用它来生成想要的任何种类的集合，只要该集合类型能够实现 <code>Default</code> 以生成一个初始的空集合，并且实现 <code>Extend&lt;T&gt;</code> 以将 <code>T</code> 添加到集合中就可以。<code>String</code> 实现了 <code>Default</code> 和 <code>Extend&lt;char&gt;</code>，所以你可以这样写：</p>\n<pre class=\"code-rows\"><code>let (upper, lower): (String, String)\n    = \"Great Teacher Onizuka\".chars().partition(|&amp;c| c.is_uppercase());\nassert_eq!(upper, \"GTO\");\nassert_eq!(lower, \"reat eacher nizuka\");</code></pre>\n<p><code>Default</code> 的另一个常见用途是为表示大量参数集合的结构体生成默认值，其中大部分参数通常不用更改。例如，<code>glium</code> crate 为强大而复杂的 OpenGL 图形库提供了 Rust 绑定。<code>glium:: DrawParameters</code> 结构体包括 24 个字段，每个字段控制着 OpenGL 应该如何渲染某些图形的不同细节。<code>glium draw</code> 函数需要一个 <code>DrawParameters</code> 结构体作为参数。由于 <code>DrawParameters</code> 已经实现了 <code>Default</code>，因此只需提及想要更改的那些字段即可创建一个可以传给 <code>draw</code> 的结构体：</p>\n<pre class=\"code-rows\"><code>let params = glium::DrawParameters {\n    line_width: Some(0.02),\n    point_size: Some(0.02),\n    .. Default::default()\n};\n\ntarget.draw(..., &amp;params).unwrap();</code></pre>\n<p>这会调用 <code>Default::default()</code> 来创建一个 <code>DrawParameters</code> 值，该值会使用其所有字段的默认值进行初始化，然后使用结构体的 <code>..</code> 语法创建出一个更改了 <code>line_width</code> 字段和 <code>point_size</code> 字段的新值，最后就可以把它传给 <code>target.draw</code> 了。</p>\n<p>如果类型 <code>T</code> 实现了 <code>Default</code>，那么标准库就会自动为 <code>Rc&lt;T&gt;</code>、<code>Arc&lt;T&gt;</code>、<code>Box&lt;T&gt;</code>、<code>Cell&lt;T&gt;</code>、<code>RefCell&lt;T&gt;</code>、<code>Cow&lt;T&gt;</code>、<code>Mutex&lt;T&gt;</code> 和 <code>RwLock&lt;T&gt;</code> 实现 <code>Default</code>。例如，类型 <code>Rc&lt;T&gt;</code> 的默认值就是一个指向类型 <code>T</code> 的默认值的 <code>Rc</code>。</p>\n<p>如果一个元组类型的所有元素类型都实现了 <code>Default</code>，那么该元组类型也同样会实现 <code>Default</code>，这个元组的默认值包含每个元素的默认值。</p>\n<p>Rust 不会为结构体类型隐式实现 <code>Default</code>，但是如果结构体的所有字段都实现了 <code>Default</code>，则可以使用 <code>#[derive(Default)]</code> 为此结构体自动实现 <code>Default</code>。</p>\n<h2 id=\"nav_point_218\">13.7　<code>AsRef</code> 与 <code>AsMut</code></h2>\n<p>如果一个类型实现了 <code>AsRef&lt;T&gt;</code>，那么就意味着你可以高效地从中借入 <code>&amp;T</code>。<code>AsMut</code> 是 <code>AsRef</code> 针对可变引用的对应类型。它们的定义如下所示：</p>\n<pre class=\"code-rows\"><code>trait AsRef&lt;T: ?Sized&gt; {\n    fn as_ref(&amp;self) -&gt; &amp;T;\n}\n\ntrait AsMut&lt;T: ?Sized&gt; {\n    fn as_mut(&amp;mut self) -&gt; &amp;mut T;\n}</code></pre>\n<p>例如，<code>Vec&lt;T&gt;</code> 实现了 <code>AsRef&lt;[T]&gt;</code>，而 <code>String</code> 实现了 <code>AsRef&lt;str&gt;</code>。还可以把 <code>String</code> 的内容借入为字节数组，因此 <code>String</code> 也实现了 <code>AsRef&lt;[u8]&gt;</code>。</p>\n<p><code>AsRef</code> 通常用于让函数更灵活地接受其参数类型。例如，<code>std::fs::File::open</code> 函数的声明如下：</p>\n<pre class=\"code-rows\"><code>fn open&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;File&gt;</code></pre>\n<p><code>open</code> 真正想要的是 <code>&amp;Path</code>，即代表文件系统路径的类型。有了这个函数签名，<code>open</code> 就能接受可以从中借入 <code>&amp;Path</code> 的一切，也就是实现了 <code>AsRef&lt;Path&gt;</code> 的一切。这些类型包括 <code>String</code> 和 <code>str</code>、操作系统接口字符串类型 <code>OsString</code> 和 <code>OsStr</code>，当然还有 <code>PathBuf</code> 和 <code>Path</code>。有关完整列表，请参阅标准库的文档。这样你才能给 <code>open</code> 传入字符串字面量：</p>\n<pre class=\"code-rows\"><code>let dot_emacs = std::fs::File::open(\"/home/jimb/.emacs\")?;</code></pre>\n<p>标准库的所有文件系统访问函数都会以这种方式接受路径参数。对调用者来说，其效果类似于 C++ 中的重载函数，只不过 Rust 采用的是另一种方式来确定可接受的参数类型。</p>\n<p>但这还不是全部。字符串字面量是 <code>&amp;str</code>，实现了 <code>AsRef&lt;Path&gt;</code> 的类型是 <code>str</code>，并没有 <code>&amp;</code>。正如我们在 13.5 节中解释的那样，Rust 不会试图通过隐式解引用来满足类型变量限界，因此就算它们在这里也无济于事。</p>\n<p>幸运的是，标准库包含了其通用实现：</p>\n<pre class=\"code-rows\"><code>impl&lt;'a, T, U&gt; AsRef&lt;U&gt; for &amp;'a T\n    where T: AsRef&lt;U&gt;,\n          T: ?Sized, U: ?Sized\n{\n    fn as_ref(&amp;self) -&gt; &amp;U {\n        (*self).as_ref()\n    }\n}</code></pre>\n<p>换句话说，对于任意类型 <code>T</code> 和 <code>U</code>，只要满足 <code>T: AsRef&lt;U&gt;</code>，就必然满足 <code>&amp;T: AsRef&lt;U&gt;</code>：只需追踪引用并像以前那样继续处理即可。特别是，如果满足 <code>str: AsRef&lt;Path&gt;</code>，那么也会满足 <code>&amp;str: AsRef&lt;Path&gt;</code>。从某种意义上说，这是一种在检查类型变量的 <code>AsRef</code> 限界时获得受限隐式解引用的方法。</p>\n<p>你可能会认为，如果一个类型实现了 <code>AsRef&lt;T&gt;</code>，那么它也应该实现 <code>AsMut&lt;T&gt;</code>。但是，这在某些情况下是不合适的。例如，我们已经提到 <code>String</code> 实现了 <code>AsRef&lt;[u8]&gt;</code>，这是合理的，因为每个 <code>String</code> 肯定都有一个可以作为二进制数据访问的字节缓冲区。但是，<code>String</code> 要进一步保证这些字节是表示 Unicode 文本的一段格式良好的 UTF-8 编码，如果 <code>String</code> 实现了 <code>AsMut&lt;[u8]&gt;</code>，那么就会允许调用者将 <code>String</code> 的字节更改为他们想要的任何内容，这样你就不能再相信 <code>String</code> 一定是格式良好的 UTF-8 了。只有修改给定的 <code>T</code> 肯定不会违反此类型的不变性约束时，实现 <code>AsMut&lt;T&gt;</code> 的类型才有意义。</p>\n<p>尽管 <code>AsRef</code> 和 <code>AsMut</code> 非常简单，但为引用转换提供标准的泛型特型可避免更专用的转换特型数量激增。只要能实现 <code>AsRef&lt;Foo&gt;</code>，就要尽量避免定义自己的 <code>AsFoo</code> 特型。</p>\n<h2 id=\"nav_point_219\">13.8　<code>Borrow</code> 与 <code>BorrowMut</code></h2>\n<p><code>std::borrow::Borrow</code> 特型类似于 <code>AsRef</code>：如果一个类型实现了 <code>Borrow&lt;T&gt;</code>，那么它的 <code>borrow</code> 方法就能高效地从自身借入一个 <code>&amp;T</code>。但是 <code>Borrow</code> 施加了更多限制：只有当 <code>&amp;T</code> 能通过与它借来的值相同的方式进行哈希和比较时，此类型才应实现 <code>Borrow&lt;T&gt;</code>。（Rust 并不强制执行此限制，它只是记述了此特型的意图。）这使得 <code>Borrow</code> 在处理哈希表和树中的键或者处理因为某些原因要进行哈希或比较的值时非常有用。</p>\n<p>这在区分对 <code>String</code> 的借用时很重要，比如 <code>String</code> 实现了 <code>AsRef&lt;str&gt;</code>、<code>AsRef&lt;[u8]&gt;</code> 和 <code>AsRef&lt;Path&gt;</code>，但这 3 种目标类型通常具有不一样的哈希值。只有 <code>&amp;str</code> 切片才能保证像其等效的 <code>String</code> 一样进行哈希，因此 <code>String</code> 只实现了 <code>Borrow&lt;str&gt;</code>。</p>\n<p><code>Borrow</code> 的定义与 <code>AsRef</code> 的定义基本相同，只是名称变了：</p>\n<pre class=\"code-rows\"><code>trait Borrow&lt;Borrowed: ?Sized&gt; {\n    fn borrow(&amp;self) -&gt; &amp;Borrowed;\n}</code></pre>\n<p><code>Borrow</code> 旨在解决具有泛型哈希表和其他关联集合类型的特定情况。假设你有一个 <code>std::collections::HashMap&lt;String, i32&gt;</code>，用于将字符串映射到数值。这个表的键是 <code>String</code>，每个条目都有一个键。在这个表中查找某个条目的方法的签名应该是什么呢？下面是第一次尝试。</p>\n<pre class=\"code-rows\"><code>impl&lt;K, V&gt; HashMap&lt;K, V&gt; where K: Eq + Hash\n{\n    fn get(&amp;self, key: K) -&gt; Option&lt;&amp;V&gt; { ... }\n}</code></pre>\n<p>这很合理：要查找条目，就必须为表提供适当类型的键。但在这里，<code>K</code> 是 <code>String</code>，这种签名会强制你将 <code>String</code> 按值传给对 <code>get</code> 的每次调用，这显然是一种浪费。你真正需要的只是此键的引用：</p>\n<pre class=\"code-rows\"><code>impl&lt;K, V&gt; HashMap&lt;K, V&gt; where K: Eq + Hash\n{\n    fn get(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt; { ... }\n}</code></pre>\n<p>这稍微好一点儿了，但现在你必须将键作为 <code>&amp;String</code> 传递，所以如果想查找常量字符串，就必须像下面这样写。</p>\n<pre class=\"code-rows\"><code>hashtable.get(&amp;\"twenty-two\".to_string())</code></pre>\n<p>这相当荒谬：它会在堆上分配一个 <code>String</code> 缓冲区并将文本复制进去，这样才能将其作为 <code>&amp;String</code> 借用出来，传给 <code>get</code>，然后将其丢弃。</p>\n<p>它应该只要求传入任何可以哈希并与我们的键类型进行比较的类型。例如，<code>&amp;str</code> 就完全够用了。所以下面是最后一次迭代，也正是你在标准库中所看到的：</p>\n<pre class=\"code-rows\"><code>impl&lt;K, V&gt; HashMap&lt;K, V&gt; where K: Eq + Hash\n{\n    fn get&lt;Q: ?Sized&gt;(&amp;self, key: &amp;Q) -&gt; Option&lt;&amp;V&gt;\n        where K: Borrow&lt;Q&gt;,\n              Q: Eq + Hash\n    { ... }\n}</code></pre>\n<p>换句话说，只要可以借入一个条目的键充当 <code>&amp;Q</code>，并且对生成的引用进行哈希和比较的方式与键本身一致，<code>&amp;Q</code> 显然就是可接受的键类型。由于 <code>String</code> 实现了 <code>Borrow&lt;str&gt;</code> 和 <code>Borrow&lt;String&gt;</code>，因此最终版本的 <code>get</code> 允许按需传入 <code>&amp;String</code> 型或 <code>&amp;str</code> 型的 <code>key</code>。</p>\n<p><code>Vec&lt;T&gt;</code> 和 <code>[T; N]</code> 实现了 <code>Borrow&lt;[T]&gt;</code>。每个类似字符串的类型都能借入其相应的切片类型：<code>String</code> 实现了 <code>Borrow&lt;str&gt;</code>、<code>PathBuf</code> 实现了 <code>Borrow&lt;Path&gt;</code>，等等。标准库中所有关联集合类型都使用 <code>Borrow</code> 来决定哪些类型可以传给它们的查找函数。</p>\n<p>标准库中包含一个通用实现，因此每个类型 <code>T</code> 都可以从自身借用：<code>T: Borrow&lt;T&gt;</code>。这确保了在 <code>HashMap&lt;K, V&gt;</code> 中查找条目时 <code>&amp;K</code> 总是可接受的类型。</p>\n<p>为便于使用，每个 <code>&amp;mut T</code> 类型也都实现了 <code>Borrow&lt;T&gt;</code>，它会像往常一样返回一个共享引用 <code>&amp;T</code>。这样你就可以给集合的查找函数传入可变引用，而不必重新借入共享引用，以模拟 Rust 通常会从可变引用到共享引用进行的隐式转换。</p>\n<p><code>BorrowMut</code> 特型则类似于针对可变引用的 <code>Borrow</code>：</p>\n<pre class=\"code-rows\"><code>trait BorrowMut&lt;Borrowed: ?Sized&gt;: Borrow&lt;Borrowed&gt; {\n    fn borrow_mut(&amp;mut self) -&gt; &amp;mut Borrowed;\n}</code></pre>\n<p>刚才讲过的对 <code>Borrow</code> 的要求同样适用于 <code>BorrowMut</code>。</p>\n<h2 id=\"nav_point_220\">13.9　<code>From</code> 与 <code>Into</code></h2>\n<p><code>std::convert::From</code> 特型和 <code>std::convert::Into</code> 特型表示类型转换，这种转换会接受一种类型的值并返回另一种类型的值。<code>AsRef</code> 特型和 <code>AsMut</code> 特型用于从一种类型借入另一种类型的引用，而 <code>From</code> 和 <code>Into</code> 会获取其参数的所有权，对其进行转换，然后将转换结果的所有权返回给调用者。</p>\n<p><code>From</code> 和 <code>Into</code> 的定义是对称的：</p>\n<pre class=\"code-rows\"><code>trait Into&lt;T&gt;: Sized {\n    fn into(self) -&gt; T;\n}\n\ntrait From&lt;T&gt;: Sized {\n    fn from(other: T) -&gt; Self;\n}</code></pre>\n<p>标准库自动实现了从每种类型到自身的简单转换：每种类型 <code>T</code> 都实现了 <code>From&lt;T&gt;</code> 和 <code>Into&lt;T&gt;</code>。</p>\n<p>虽然这两个特型看起来只是为做同一件事提供了两种方式，但其实它们有不同的用途。</p>\n<p>你通常可以使用 <code>Into</code> 来让你的函数在接受参数时更加灵活。如果你写如下代码：</p>\n<pre class=\"code-rows\"><code>use std::net::Ipv4Addr;\n\nfn ping&lt;A&gt;(address: A) -&gt; std::io::Result&lt;bool&gt;\n    where A: Into&lt;Ipv4Addr&gt;\n{\n    let ipv4_address = address.into();\n    ...\n}</code></pre>\n<p>那么 <code>ping</code> 不仅可以接受 <code>Ipv4Addr</code> 作为参数，还可以接受 <code>u32</code> 或 <code>[u8; 4]</code> 数组，因为这些类型都恰好实现了 <code>Into&lt;Ipv4Addr&gt;</code>。（有时将 IPv4 地址视为单个 32 位值或 4 字节数组会很有用。）因为 <code>ping</code> 对 <code>address</code> 的唯一了解就是它要实现 <code>Into&lt;Ipv4Addr&gt;</code>，所以在调用 <code>into</code> 时无须指定想要的是哪种类型。因为只会存在一种有效类型，所以类型推断会替你补全它。</p>\n<p>与 13.7 节中的 <code>AsRef</code> 一样，其效果很像 C++ 中的函数重载。使用之前的 <code>ping</code> 定义，可以进行以下任何调用：</p>\n<pre class=\"code-rows\"><code>println!(\"{:?}\", ping(Ipv4Addr::new(23, 21, 68, 141))); // 传入一个Ipv4Addr\nprintln!(\"{:?}\", ping([66, 146, 219, 98]));             // 传入一个[u8; 4]\nprintln!(\"{:?}\", ping(0xd076eb94_u32));                 // 传入一个u32</code></pre>\n<p>而 <code>From</code> 特型扮演着另一种角色。<code>from</code> 方法会充当泛型构造函数，用于从另一个值生成本类型的实例。例如，虽然 <code>Ipv4Addr</code> 有两个名为 <code>from_array</code> 和 <code>from_u32</code> 的方法，但 <code>From</code> 只是简单地实现了 <code>From&lt;[u8;4]&gt;</code> 和 <code>From&lt;u32&gt;</code>，于是我们就能这样写：</p>\n<pre class=\"code-rows\"><code>let addr1 = Ipv4Addr::from([66, 146, 219, 98]);\nlet addr2 = Ipv4Addr::from(0xd076eb94_u32);</code></pre>\n<p>可以让类型推断找出适用于此的实现。</p>\n<p>给定适当的 <code>From</code> 实现，标准库会自动实现相应的 <code>Into</code> 特型。当你定义自己的类型时，如果它具有某些单参数构造函数，那么就应该将它们写成适当类型的 <code>From&lt;T&gt;</code> 的实现，这样你就会自动获得相应的 <code>Into</code> 实现。</p>\n<p>因为转换方法 <code>from</code> 和 <code>into</code> 会接手它们的参数的所有权，所以此转换可以复用原始值的资源来构造出转换后的值。假设你写如下代码：</p>\n<pre class=\"code-rows\"><code>let text = \"Beautiful Soup\".to_string();\nlet bytes: Vec&lt;u8&gt; = text.into();</code></pre>\n<p><code>String</code> 的 <code>Into&lt;Vec&lt;u8&gt;&gt;</code> 的实现只是获取 <code>String</code> 的堆缓冲区，并在不进行任何更改的情况下将其重新用作所返回向量的元素缓冲区。此转换既不需要分配内存，也不需要复制文本。这是通过移动进行高性能实现的另一个例子。</p>\n<p>这些转换还提供了一种很好的方式来将受限类型的值放宽为更灵活的值，而不会削弱受限类型提供的保证。例如，<code>String</code> 会保证其内容始终是有效的 UTF-8，它的可变方法会受到严格限制，以确保你所做的任何事情都不会引入错误的 UTF-8。但是这个例子有效地将 <code>String</code>“降级”为一个普通字节块，你可以用它做任何喜欢的事情：既可以压缩它，也可以将它与其他非 UTF-8 的二进制数据组合使用。因为 <code>into</code> 会按值接手其参数，所以转换后的 <code>text</code> 就成了未初始化状态，这意味着我们可以自由访问前一个 <code>String</code> 的缓冲区，而不会破坏任何现有 <code>String</code>。</p>\n<p>然而，<code>Into</code> 和 <code>From</code> 契约并不要求这种转换是低开销的。尽管对 <code>AsRef</code> 和 <code>AsMut</code> 的转换可以预期开销极低，但 <code>From</code> 和 <code>Into</code> 的转换可能会分配内存、复制或以其他方式处理值的内容。例如，<code>String</code> 实现了 <code>From&lt;&amp;str&gt;</code>，它会将字符串切片复制到 <code>String</code> 在堆上分配的新缓冲区中。<code>std::collections::BinaryHeap&lt;T&gt;</code> 实现了 <code>From&lt;Vec&lt;T&gt;&gt;</code>，它能根据算法的要求对元素进行比较和重新排序。</p>\n<p>通过在需要时自动将具体错误类型转换为一般错误类型，运算符 <code>?</code> 可以使用 <code>From</code> 和 <code>Into</code> 来帮助清理可能以多种方式失败的函数中的代码。</p>\n<p>假设一个系统需要读取二进制数据并将其中的某些部分从 UTF-8 文本中作为十进制数值转换出来。这意味着要使用 <code>std::str::from_utf8</code> 和 <code>i32</code> 的 <code>FromStr</code> 实现，它们都可以返回不同类型的错误。假设讨论错误处理时使用的是第 7 章中定义的 <code>GenericError</code> 类型和 <code>GenericResult</code> 类型，那么运算符 <code>?</code> 将为我们进行这种转换：</p>\n<pre class=\"code-rows\"><code>type GenericError = Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;;\ntype GenericResult&lt;T&gt; = Result&lt;T, GenericError&gt;;\n\nfn parse_i32_bytes(b: &amp;[u8]) -&gt; GenericResult&lt;i32&gt; {\n        Ok(std::str::from_utf8(b)?.parse::&lt;i32&gt;()?)\n}</code></pre>\n<p>与大多数错误类型一样，<code>Utf8Error</code> 和 <code>ParseIntError</code> 也实现了 <code>Error</code> 特型，标准库为我们提供了 <code>From</code> 的通用实现，用于将任何实现了 <code>Error</code> 的类型转换为 <code>Box&lt;dyn Error&gt;</code> 类型，<code>?</code> 运算符会自动使用这种转换：</p>\n<pre class=\"code-rows\"><code>impl&lt;'a, E: Error + Send + Sync + 'a&gt; From&lt;E&gt;\n  for Box&lt;dyn Error + Send + Sync + 'a&gt; {\n    fn from(err: E) -&gt; Box&lt;dyn Error + Send + Sync + 'a&gt; {\n        Box::new(err)\n    }\n}</code></pre>\n<p>这能把具有两个 <code>match</code> 语句的大函数变成单行函数。</p>\n<p>在 <code>From</code> 和 <code>Into</code> 被加入标准库之前，Rust 代码充满了专用的转换特型和构造方法，每一个都专用于一种类型。为了让你的类型更容易使用，<code>From</code> 和 <code>Into</code> 明确写出了可以遵循的约定，因为你的用户已经熟悉它们了。其他库以及语言自身也可以依赖这些特型，将其作为一种规范化、标准化的方式来对转换进行编码。</p>\n<p><code>From</code> 和 <code>Into</code> 是不会失败的特型——它们的 API 要求这种转换不会失败。不过很遗憾，许多转换远比这复杂得多。例如，像 <code>i64</code> 这样的大整数可以存储比 <code>i32</code> 大得多的数值，如果没有一些额外的信息，那么将像 <code>2_000_000_000_000i64</code> 这样的数值转换成 <code>i32</code> 就没有多大意义。如果进行简单的按位转换，那么其中前 32 位就会被丢弃，通常不会产生我们预期的结果：</p>\n<pre class=\"code-rows\"><code>let huge = 2_000_000_000_000i64;\nlet smaller = huge as i32;\nprintln!(\"{}\", smaller); // -1454759936</code></pre>\n<p>有很多选项可以处理这种情况。根据上下文的不同，“回绕型”转换可能比较合适。另外，像数字信号处理和控制系统这样的应用程序通常会使用“饱和型”转换，它会把比可能的最大值还要大的数值限制为最大值。</p>\n<h2 id=\"nav_point_221\">13.10　<code>TryFrom</code> 与 <code>TryInto</code></h2>\n<p>由于转换的行为方式不够清晰，因此 Rust 没有为 <code>i32</code> 实现 <code>From&lt;i64&gt;</code>，也没有实现任何其他可能丢失信息的数值类型之间的转换，而是为 <code>i32</code> 实现了 <code>TryFrom&lt;i64&gt;</code>。<code>TryFrom</code> 和 <code>TryInto</code> 是 <code>From</code> 和 <code>Into</code> 的容错版“表亲”，这种转换同样是双向的，实现了 <code>TryFrom</code> 也就意味着实现了 <code>TryInto</code>。</p>\n<p><code>TryFrom</code> 和 <code>TryInto</code> 的定义比 <code>From</code> 和 <code>Into</code> 稍微复杂一点儿。</p>\n<pre class=\"code-rows\"><code>pub trait TryFrom&lt;T&gt;: Sized {\n    type Error;\n    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;;\n}\n\npub trait TryInto&lt;T&gt;: Sized {\n    type Error;\n    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;;\n}</code></pre>\n<p><code>try_into()</code> 方法给了我们一个 <code>Result</code>，因此我们可以选择在异常情况下该怎么做，比如处理一个因为太大而无法放入结果类型的数值：</p>\n<pre class=\"code-rows\"><code>// 溢出时饱和，而非回绕\nlet smaller: i32 = huge.try_into().unwrap_or(i32::MAX);</code></pre>\n<p>如果还想处理负数的情况，那么可以使用 <code>Result</code> 的 <code>unwrap_or_else()</code> 方法：</p>\n<pre class=\"code-rows\"><code>let smaller: i32 = huge.try_into().unwrap_or_else(|_|{\n    if huge &gt;= 0 {\n        i32::MAX\n    } else {\n        i32::MIN\n    }\n});</code></pre>\n<p>为你自己的类型实现容错的转换也很容易。<code>Error</code> 类型既可以很简单，也可以很复杂，具体取决于特定应用程序的要求。标准库使用的是一个空结构体，除了发生过错误这一事实之外没有提供任何信息，因为唯一可能的错误就是溢出。另外，更复杂类型之间的转换可能需要返回更多信息：</p>\n<pre class=\"code-rows\"><code>impl TryInto&lt;LinearShift&gt; for Transform {\n    type Error = TransformError;\n\n    fn try_into(self) -&gt; Result&lt;LinearShift, Self::Error&gt; {\n        if !self.normalized() {\n            return Err(TransformError::NotNormalized);\n        }\n        ...\n    }\n}</code></pre>\n<p><code>From</code> 和 <code>Into</code> 可以将类型与简单转换关联起来，而 <code>TryFrom</code> 和 <code>TryInto</code> 通过 <code>Result</code> 提供的富有表现力的错误处理扩展了 <code>From</code> 和 <code>Into</code> 的简单转换。这 4 个特型可以一起使用，在同一个 crate 中关联多个类型。</p>\n<h2 id=\"nav_point_222\">13.11　<code>ToOwned</code></h2>\n<p>给定一个引用，如果此类型实现了 <code>std::clone::Clone</code>，则生成其引用目标的拥有型副本的常用方法是调用 <code>clone</code>。但是当你想克隆一个 <code>&amp;str</code> 或 <code>&amp;[i32]</code> 时该怎么办呢？你想要的可能是 <code>String</code> 或 <code>Vec&lt;i32&gt;</code>，但 <code>Clone</code> 的定义不允许这样做：根据定义，克隆 <code>&amp;T</code> 必须始终返回 <code>T</code> 类型的值，并且 <code>str</code> 和 <code>[u8]</code> 是无固定大小类型，它们甚至都不是函数所能返回的类型。</p>\n<p><code>std::borrow::ToOwned</code> 特型提供了一种稍微宽松的方式来将引用转换为拥有型的值：</p>\n<pre class=\"code-rows\"><code>trait ToOwned {\n    type Owned: Borrow&lt;Self&gt;;\n    fn to_owned(&amp;self) -&gt; Self::Owned;\n}</code></pre>\n<p>与必须精确返回 <code>Self</code> 类型的 <code>clone</code> 不同，<code>to_owned</code> 可以返回任何能让你从中借入 <code>&amp;Self</code> 的类型：<code>Owned</code> 类型必须实现 <code>Borrow&lt;Self&gt;</code>。你可以从 <code>Vec&lt;T&gt;</code> 借入 <code>&amp;[T]</code>，所以只要 <code>T</code> 实现了 <code>Clone</code>，<code>[T]</code> 就能实现 <code>ToOwned&lt;Owned=Vec&lt;T&gt;&gt;</code>，这样就可以将切片的元素复制到向量中了。同样，<code>str</code> 实现了 <code>ToOwned&lt;Owned=String&gt;</code>，<code>Path</code> 实现了 <code>ToOwned&lt;Owned=PathBuf&gt;</code>，等等。</p>\n<h2 id=\"nav_point_223\">13.12　<code>Borrow</code> 与 <code>ToOwned</code> 的实际运用：谦卑 <span class=\"comment-number\">2</span> 的 <code>Cow</code></h2>\n\n<p>要想用好 Rust，就必然涉及对所有权问题的透彻思考，比如函数应该通过引用还是值接受参数。通常你可以任选一种方式，让参数的类型反映你的决定。但在某些情况下，在程序开始运行之前你无法决定是该借用还是该拥有，<code>std::borrow::Cow</code> 类型（用于“写入时克隆”，clone on write 的缩写）提供了一种兼顾两者的方式。</p>\n<p><code>std::borrow::Cow</code> 的定义如下所示：</p>\n<pre class=\"code-rows\"><code>enum Cow&lt;'a, B: ?Sized&gt;\n    where B: ToOwned\n{\n    Borrowed(&amp;'a B),\n    Owned(&lt;B as ToOwned&gt;::Owned),\n}</code></pre>\n<p><code>Cow&lt;B&gt;</code> 要么借入对 <code>B</code> 的共享引用，要么拥有可供借入此类引用的值。由于 <code>Cow</code> 实现了 <code>Deref</code>，因此你可以像对 <code>B</code> 的共享引用一样调用它的方法：如果它是 <code>Owned</code>，就会借入对拥有值的共享引用；如果它是 <code>Borrowed</code>，就会转让自己持有的引用。</p>\n<p>还可以通过调用 <code>Cow</code> 的 <code>to_mut</code> 方法来获取对 <code>Cow</code> 值的可变引用，这个方法会返回 <code>&amp;mut B</code>。如果 <code>Cow</code> 恰好是 <code>Cow::Borrowed</code>，那么 <code>to_mut</code> 只需调用引用的 <code>to_owned</code> 方法来获取其引用目标的副本，将 <code>Cow</code> 更改为 <code>Cow::Owned</code>，并借入对新创建的这个拥有型值的可变引用即可。这就是此类型名称所指的“写入时克隆”行为。</p>\n<p>类似地，<code>Cow</code> 还有一个 <code>into_owned</code> 方法，该方法会在必要时提升对所拥有值的引用并返回此引用，这会将所有权转移给调用者并在此过程中消耗掉 <code>Cow</code>。</p>\n<p><code>Cow</code> 的一个常见用途是返回静态分配的字符串常量或由计算得来的字符串。假设你需要将错误枚举转换为错误消息。大多数变体可以用固定字符串来处理，但有些也需要在消息中包含附加数据。你可以返回一个 <code>Cow&lt;'static, str&gt;</code>：</p>\n<pre class=\"code-rows\"><code>use std::path::PathBuf;\nuse std::borrow::Cow;\nfn describe(error: &amp;Error) -&gt; Cow&lt;'static, str&gt; {\n    match *error {\n        Error::OutOfMemory =&gt; \"out of memory\".into(),\n        Error::StackOverflow =&gt; \"stack overflow\".into(),\n        Error::MachineOnFire =&gt; \"machine on fire\".into(),\n        Error::Unfathomable =&gt; \"machine bewildered\".into(),\n        Error::FileNotFound(ref path) =&gt; {\n            format!(\"file not found: {}\", path.display()).into()\n        }\n    }\n}</code></pre>\n<p>上述代码使用了 <code>Cow</code> 的 <code>Into</code> 实现来构造出值。此 <code>match</code> 语句的大多数分支会返回 <code>Cow::Borrowed</code> 来引用静态分配的字符串。但是当我们得到一个 <code>FileNotFound</code> 变体时，会使用 <code>format!</code> 来构建包含给定文件名的消息。<code>match</code> 语句的这个分支会生成一个 <code>Cow::Owned</code> 值。</p>\n<p>如果 <code>describe</code> 的调用者不打算更改值，就可以直接把此 <code>Cow</code> 看作 <code>&amp;str</code>：</p>\n<pre class=\"code-rows\"><code>println!(\"Disaster has struck: {}\", describe(&amp;error));</code></pre>\n<p>如果调用者确实需要一个拥有型的值，那么也能很容易地生成一个：</p>\n<pre class=\"code-rows\"><code>let mut log: Vec&lt;String&gt; = Vec::new();\n...\nlog.push(describe(&amp;error).into_owned());</code></pre>\n<p>使用 <code>Cow</code>，<code>describe</code> 及其调用者可以把分配的时机推迟到确有必要的时候。</p>\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 12 章 运算符重载","id":740813},"right":{"article_title":"第 14 章 闭包","id":740815}},"comments":[]}