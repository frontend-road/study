{"id":502056,"title":"12｜实战中的TDD：RESTful API的开发框架","content":"<p>你好，我是徐昊。从今天开始，让我们进入实战中的TDD环节。也就是使用TDD的方式，去实现我们工作中常用的技术框架。</p><p>之所以选择常用的技术框架，而不虚构某个业务系统，主要是因为TDD的难点首先在于理解需求，并将需求分解为功能点。虚构的业务系统，难以详尽描述所有的业务假设（功能上、组织上、运营方式上等），不利于你跟随题目自行练习。而使用常用的技术框架，由于你对于大体的功能及其所解决的问题，已经有所了解。我也可以避免无谓的啰嗦。</p><h2>RESTful API的开发框架</h2><p>第一个场景是支撑RESTful API的开发框架，你可以将它想象成mini版本的Dropwizard或者Spring MVC。功能范围包含一个依赖注入容器（Dependency Injection Container/IoC Container）和一个支持RESTful API构建的Web框架。</p><p>我们会以Jakarta EE中的Jakarta Dependency Injection和Jakarta RESTful Web Services 为主要功能参考，并对其适当简化，以完成我们的目标。</p><p>当我们完成全部功能之后，可以通过类似以下的代码实现RESTful API：</p><pre><code>package geektime.tdd.resources;\n    \nimport geektime.tdd.model.Student;\nimport geektime.tdd.model.StudentRepository;\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.GET;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.PathParam;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\nimport java.util.List;\n \n@Path(&quot;/students&quot;)\npublic class StudentsResource {\n  \n    private StudentRepository repository;\n    \n    @Inject\n    public StudentsResource(StudentRepository repository) {\n        this.repository = repository;\n    }\n    \n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    public List&lt;Student&gt; all() {\n        return repository.all();\n    }\n    \n    @GET\n    @Path(&quot;{id}&quot;)\n    @Produces(MediaType.APPLICATION_JSON)\n    public Response findById(@PathParam(&quot;id&quot;) long id) {\n        return repository.findById(id).map(Response::ok)\n                .orElse(Response.status(Response.Status.NOT_FOUND)).build();\n    }\n}\n</code></pre><!-- [[[read_end]]] --><h2>依赖注入容器的大致功能</h2><p>首先让我们从依赖注入容器开始。关于依赖注入的来龙去脉可以参看Martin Fowler在2004年写的文章<a href=\"https://martinfowler.com/articles/injection.html\">《</a><a href=\"https://martinfowler.com/articles/injection.html\">IoC容器与依赖注入模式</a><a href=\"https://martinfowler.com/articles/injection.html\">》</a>。</p><p>Jakarta Dependency Injection的功能主要分为三部分：组件的构造、依赖的选择以及生命周期控制。详细说明如视频中所示：</p><p><video poster=\"https://media001.geekbang.org/ff1517e40ed14874b36e9855bd218606/snapshots/d5171828a2034095ae75b585670fce60-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/171d7b31-1801774f84f-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/9f20aff2990b47ac8c029500b77cf455/3752353439524485aff38e3c8a360e3a-5d21df8f46a953de6c5a40e9245ac638-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>Jakarta Dependency Injection中没有规定而又常用的部分有：配置容器如何配置、容器层级结构以及生命周期回调。详细说明如视频中所示：</p><p><video poster=\"https://media001.geekbang.org/a07bfe8a340440d4bda00519a076785f/snapshots/268b195c048a4b008e6c85c0024ff3e8-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4f8b6be3-18016ad96b3-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/03aa11ee000a4d4a8bc93f81ded2cb23/0e2d86823f9b4bc888623ae442772b30-aed273d12ce3618516cd66aa5acda6cd-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><h2>思考题</h2><p>那么以此为基础，要如何分解功能点呢？请你自行练习。下节课，我会给出我做的分解列表。</p><p>欢迎把你的思考和想法分享在留言区，也欢迎你扫描详情页的二维码加入读者交流群。我们下节课再见！</p>","comments":[{"had_liked":false,"id":343906,"user_name":"🐑","can_delete":false,"product_type":"c1","uid":2189689,"ip_address":"","ucode":"DE34B3B14287D1","user_header":"https://static001.geekbang.org/account/avatar/00/21/69/79/b4132042.jpg","comment_is_top":true,"comment_ctime":1651116023,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"TDD专栏福利大合集：\n\n1、打卡赢好礼（4月23日-5月10日）：正在进行中，学习专栏第1-10讲并在留言区打卡，结束后奖励；\n\n2、代码亲手评（5月底）：预计打卡结束后启动，完成前10讲的打卡，即可提交代码练习作业，徐昊老师会亲自点评；\n\n3、线上带你练：根据专栏更新节奏和老师时间安排确定，徐昊老师会线上带四个同学手把手地改代码，敬请期待！\n\n具体活动介绍见 👉 http:&#47;&#47;gk.link&#47;a&#47;11jPi","like_count":0},{"had_liked":false,"id":342160,"user_name":"Flynn","can_delete":false,"product_type":"c1","uid":1174517,"ip_address":"","ucode":"293321CC198C0C","user_header":"","comment_is_top":false,"comment_ctime":1650075309,"is_pvip":false,"replies":[{"id":125040,"content":"以功能分解来看 粒度有些粗","user_name":"作者回复","user_name_real":"编辑","uid":2537798,"ctime":1650080048,"ip_address":"","comment_id":342160,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"&#47;&#47;TODO 1.注入框架是否注册该对象\n&#47;&#47;TODO 2.constructor注入获取到的对象是期望的\n&#47;&#47;TODO 2.filed注入获取到的对象是期望的\n&#47;&#47;TODO 3.method注入获取到的对象是期望的\n&#47;&#47;TODO 4.同一scope生命周期是同一个对象\n&#47;&#47;TODO 5.不同scope生命周期是不同对象","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563800,"discussion_content":"以功能分解来看 粒度有些粗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650080049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":344613,"user_name":"奇小易","can_delete":false,"product_type":"c1","uid":1171151,"ip_address":"","ucode":"E06B4DFB5352BB","user_header":"https://static001.geekbang.org/account/avatar/00/11/de/cf/ef2e0501.jpg","comment_is_top":false,"comment_ctime":1651670737,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"&gt; 功能梳理\n\n```text\njakarata dependency injection 核心功能\n\nQ: 组件的构造，指的是什么？\n将该组件的实例注入到注入点中。\n注入点的常见配置方式有以下三种。\n1、构造器注入 \n2、字段注入\n3、方法注入\n\nQ: 依赖的选择，指的是什么？\n指当一个组件的实现有多种时，该如何选择哪一个实现作为当前注入点的实例。\n\n这种选择一方面会导致循环依赖的问题，JSR 330提供Provider接口来解耦它们的直接依赖，从而解决该问题。\n另一方面在有不同实现时，可以使用Named注解来标记不同的实现，从而确保实例的选择是符合预期的。\n\nQ: 生命周期的控制，指的是什么？\n指一个组件在容器中从创建，到最终的消亡，这整个过程如何实现。\n其中需要支持单例和多例的组件构造模式。\n\n```\n\n&gt; 任务列表梳理\n\n```text\nTDD工作流程回顾。\n首先要基于业务理解分解出功能点，另一方面需要基于架构愿景分解出功能上下文。\n最终再在每个功能上下文中分解出具体的任务项。\n\n基于上述内容，可知从业务上核心功能点就是组件的构造、依赖的选择、生命周期的控制。\n而对于架构愿景没有很明确的思路，故将功能点作为功能上下文。\n\n此时功能上下文分别是\n组件的构造\n依赖的选择\n生命周期的控制\n\n要将功能上下文分解为任务项，需要思考对外接口以及具体实现方式，最终分解出最小功能单元的测试任务。\n\n&quot;组件的构造&quot;\n1、对外接口：在构造器、方法、字段上添加对应注解即可\n2、实现思路：扫描指定路径下所有Java文件的注解，分别基于不同类型的注入点，来分别进行处理。\n\n构造器注入\nHappy Path:\n如果当前类的构造方法中存在&quot;注入注解&quot;，则在容器中创建它之前，给这个参数实例化后再创建。\n（感觉这步子有点大）\n\nSad Path:\n\n字段注入\n...\n方法注入\n...\n\n```\n\n","like_count":3},{"had_liked":false,"id":341994,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1649944798,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"笔记 https:&#47;&#47;wyyl1.com&#47;post&#47;19&#47;07&#47;\n\n希望留言可以支持 Markdown 格式，这样更容易阅读\n\n## 功能点分解\n\n### happy path\n\n自定义依赖注入的 Annotation\n\n- @Inject：标识这个类可以被容器管理（类似 Spring 的 @Component）\n- @Named：可以设置 String 类型的 tag 做唯一标识\n- @Scope：标识容器创建的对象是单例、多例的标签\n- 支持自定义 Annotation 被容器加入依赖管理（组合 @Inject、@Named、@Scope 实现自定义功能）\n- @Constructor：Constructor 注入标签\n- @Field：Field 注入标签\n- @Method：方法注入标签\n\n将标记的类找到备用\n\n- 扫描项目中所有的类\n- 提取出所有标记了依赖注入标签的类的信息\n  - 类名称\n  - 类的完整路径\n  - 类的所有构造器\n  - 类上的所有 Annotation\n  - 字段上的所有 Annotation\n  - 方法上的所有 Annotation\n- 解析容器支持的自定义 Annotation\n- 将自定义 Annotation 转换为普通的 Annotation\n- 收集容器相关的 Annotation 类的信息\n- 将这些类的信息存储在容器中\n\n代理类\n\n- 通过代理类实现 Provided 解决循环依赖问题\n\n通过容器获取实例\n\n- 根据 Class 在容器中找到对应的类，返回实例\n- 根据 @Named 中的 tag，找到对应的类，返回实例\n- 根据 自定义 Annotation 找到对应的类，返回实例\n- 利用反射注入：Field 实例\n- 利用反射注入：方法参数实例\n  \n### default path\n\n- @Named：默认去类名（首字母小写）\n- @Scope：默认为多例\n\n### sad path\n\n没有匹配到对象\n\n- Class 没有被容器管理\n- @Named 没有匹配的字符串\n- 不同包下，类名一样\n- 多个 @Named 重名\n- 不支持第三方 jar 中类由容器统一管理\n\n单例模式下创建对象需要考虑内存消耗、线程安全的问题","like_count":3},{"had_liked":false,"id":350294,"user_name":"于","can_delete":false,"product_type":"c1","uid":1297723,"ip_address":"","ucode":"46D459C025D30B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKPuKKjuhiaOGQ8kfMmEnMkQAwdZib5NI3EQzn9lAU0ewX8msoqt36T2k7Z9Sh1JUUDCCn6jwBTvgHA/132","comment_is_top":false,"comment_ctime":1656757438,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"用一个一般复杂度的业务系统更有实用价值，更利于大家跟随、模仿","like_count":2},{"had_liked":false,"id":344499,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1651586759,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"請老師指導下go programmer怎麼學、練習這個項目。","like_count":2},{"had_liked":false,"id":366796,"user_name":"leesper","can_delete":false,"product_type":"c1","uid":1351104,"ip_address":"贵州","ucode":"CC76320571BECA","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/c0/cb5341ec.jpg","comment_is_top":false,"comment_ctime":1674264697,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"思考题：因为暂时不存在架构愿景，因此可以把功能点当成功能上下文：组件构造、依赖选择、生命周期管理","like_count":1},{"had_liked":false,"id":344163,"user_name":"霜期飞敛","can_delete":false,"product_type":"c1","uid":1187927,"ip_address":"","ucode":"330EA01719E00A","user_header":"https://static001.geekbang.org/account/avatar/00/12/20/57/22927d52.jpg","comment_is_top":false,"comment_ctime":1651314802,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"\n- 组件的构造\n  - 扫描指定目录的所有类，识别出所有带有注解@Inject的类\n    - sad path：不同包名下的同名class，通过加上包名区分\n  - 解析类的注解元素 @Inject，进行归类，用于后续各个阶段的注入\n    - 构造器\n      - sad path：多个@Inject 注解的构造器，抛出异常\n    - 字段\n    - 方法\n  - 实例的名称\n    - 指定的方式\n      - sad path：指定多个同名实例，抛出异常\n    - default value\n      - 默认自动生成的方式：默认类名（首字母小写）的方式\n      - 如果有多个 class#1  class#2 这样的方式累加\n  - injected constructor\n    - 实例化\n      - 查找已存在的依赖\n      - 通过构造器实例化并注入\n    - sad path：循环依赖\n  - injected field\n    - 实例化\n    - 属性设置\n      - 依赖查找对应的实例\n      - 通过反射实现字段注入\n    - sad path：循环依赖\n  - method field\n    - 实例化\n    - 属性设置\n      - 依赖查找对应的实例\n      - 通过反射调用方法注入\n- dependency selection\n  - cycle dependency\n    - proxy 实现解决循环依赖问题\n    - provider(factory) 延迟加载的循环依赖问题\n  - by tag\n    - by name\n    - by annotation\n  - sad path：\n    - 找不到对应的实例\n      - by name\n      - by annotation type\n    - 找到符合条件的多个实例\n      - 通过 @Primary 来进行优先级划分返回\n      - sad path：没有 @Primary，抛出异常\n- 生命周期控制\n  - @Scope\n    - singleton 单例实现，多次获取Class的实例返回一个实例\n    - prototype 和默认情况相同\n    - default value： prototype\n","like_count":1},{"had_liked":false,"id":342017,"user_name":"davix","can_delete":false,"product_type":"c1","uid":1074465,"ip_address":"","ucode":"CBFB39BAD7938B","user_header":"https://static001.geekbang.org/account/avatar/00/10/65/21/101a7075.jpg","comment_is_top":false,"comment_ctime":1649975164,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100109401,"comment_content":"學這門課最遺憾的是身為go程序員，不知道Java 這些都是啥","like_count":1,"discussions":[{"author":{"id":1724083,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJUCiacuh59wMbq1icuB8U1T7Vpic8FjKFdanvdt9bzClBmYqFUXmtKmh2Zibn9Dic6A8pjdoBiaia1LCrnA/132","nickname":"tdd学徒","note":"","ucode":"CC9C3EAD1B29B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568993,"discussion_content":"As a C++ programmer, I have the same feeling with you. Keep learning!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651286321,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}