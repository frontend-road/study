{"id":301092,"title":"30 | 如何使用Redis实现分布式锁？","content":"<p>你好，我是蒋德钧。</p><p>上节课，我提到，在应对并发问题时，除了原子操作，Redis客户端还可以通过加锁的方式，来控制并发写操作对共享数据的修改，从而保证数据的正确性。</p><p>但是，Redis属于分布式系统，当有多个客户端需要争抢锁时，我们必须要保证，<strong>这把锁不能是某个客户端本地的锁</strong>。否则的话，其它客户端是无法访问这把锁的，当然也就不能获取这把锁了。</p><p>所以，在分布式系统中，当有多个客户端需要获取锁时，我们需要分布式锁。此时，锁是保存在一个共享存储系统中的，可以被多个客户端共享访问和获取。</p><p>Redis本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁。而且Redis的读写性能高，可以应对高并发的锁操作场景。所以，这节课，我就来和你聊聊如何基于Redis实现分布式锁。</p><p>我们日常在写程序的时候，经常会用到单机上的锁，你应该也比较熟悉了。而分布式锁和单机上的锁既有相似性，但也因为分布式锁是用在分布式场景中，所以又具有一些特殊的要求。</p><p>所以，接下来，我就先带你对比下分布式锁和单机上的锁，找出它们的联系与区别，这样就可以加深你对分布式锁的概念和实现要求的理解。</p><h2>单机上的锁和分布式锁的联系与区别</h2><p>我们先来看下单机上的锁。</p><!-- [[[read_end]]] --><p>对于在单机上运行的多线程程序来说，锁本身可以用一个变量表示。</p><ul>\n<li>变量值为0时，表示没有线程获取锁；</li>\n<li>变量值为1时，表示已经有线程获取到锁了。</li>\n</ul><p>我们通常说的线程调用加锁和释放锁的操作，到底是啥意思呢？我来解释一下。实际上，一个线程调用加锁操作，其实就是检查锁变量值是否为0。如果是0，就把锁的变量值设置为1，表示获取到锁，如果不是0，就返回错误信息，表示加锁失败，已经有别的线程获取到锁了。而一个线程调用释放锁操作，其实就是将锁变量的值置为0，以便其它线程可以来获取锁。</p><p>我用一段代码来展示下加锁和释放锁的操作，其中，lock为锁变量。</p><pre><code>acquire_lock(){\n  if lock == 0\n     lock = 1\n     return 1\n  else\n     return 0\n} \n\nrelease_lock(){\n  lock = 0\n  return 1\n}\n</code></pre><p>和单机上的锁类似，分布式锁同样可以<strong>用一个变量来实现</strong>。客户端加锁和释放锁的操作逻辑，也和单机上的加锁和释放锁操作逻辑一致：<strong>加锁时同样需要判断锁变量的值，根据锁变量值来判断能否加锁成功；释放锁时需要把锁变量值设置为0，表明客户端不再持有锁</strong>。</p><p>但是，和线程在单机上操作锁不同的是，在分布式场景下，<strong>锁变量需要由一个共享存储系统来维护</strong>，只有这样，多个客户端才可以通过访问共享存储系统来访问锁变量。相应的，<strong>加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值</strong>。</p><p>这样一来，我们就可以得出实现分布式锁的两个要求。</p><ul>\n<li>要求一：分布式锁的加锁和释放锁的过程，涉及多个操作。所以，在实现分布式锁时，我们需要保证这些锁操作的原子性；</li>\n<li>要求二：共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了。在实现分布式锁时，我们需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。</li>\n</ul><p>好了，知道了具体的要求，接下来，我们就来学习下Redis是怎么实现分布式锁的。</p><p>其实，我们既可以基于单个Redis节点来实现，也可以使用多个Redis节点实现。在这两种情况下，锁的可靠性是不一样的。我们先来看基于单个Redis节点的实现方法。</p><h2>基于单个Redis节点实现分布式锁</h2><p>作为分布式锁实现过程中的共享存储系统，Redis可以使用键值对来保存锁变量，再接收和处理不同客户端发送的加锁和释放锁的操作请求。那么，键值对的键和值具体是怎么定的呢？</p><p>我们要赋予锁变量一个变量名，把这个变量名作为键值对的键，而锁变量的值，则是键值对的值，这样一来，Redis就能保存锁变量了，客户端也就可以通过Redis的命令操作来实现锁操作。</p><p>为了帮助你理解，我画了一张图片，它展示Redis使用键值对保存锁变量，以及两个客户端同时请求加锁的操作过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/45/1d18742c1e5fc88835ec27f1becfc145.jpg?wh=2820*2250\" alt=\"\"></p><p>可以看到，Redis可以使用一个键值对lock_key:0来保存锁变量，其中，键是lock_key，也是锁变量的名称，锁变量的初始值是0。</p><p>我们再来分析下加锁操作。</p><p>在图中，客户端A和C同时请求加锁。因为Redis使用单线程处理请求，所以，即使客户端A和C同时把加锁请求发给了Redis，Redis也会串行处理它们的请求。</p><p>我们假设Redis先处理客户端A的请求，读取lock_key的值，发现lock_key为0，所以，Redis就把lock_key的value置为1，表示已经加锁了。紧接着，Redis处理客户端C的请求，此时，Redis会发现lock_key的值已经为1了，所以就返回加锁失败的信息。</p><p>刚刚说的是加锁的操作，那释放锁该怎么操作呢？其实，释放锁就是直接把锁变量值设置为0。</p><p>我还是借助一张图片来解释一下。这张图片展示了客户端A请求释放锁的过程。当客户端A持有锁时，锁变量lock_key的值为1。客户端A执行释放锁操作后，Redis将lock_key的值置为0，表明已经没有客户端持有锁了。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/82/c7c413b47d42f06f08fce92404f31e82.jpg?wh=3000*2250\" alt=\"\"></p><p>因为加锁包含了三个操作（读取锁变量、判断锁变量值以及把锁变量值设置为1），而这三个操作在执行时需要保证原子性。那怎么保证原子性呢？</p><p>上节课，我们学过，要想保证操作的原子性，有两种通用的方法，分别是使用Redis的单命令操作和使用Lua脚本。那么，在分布式加锁场景下，该怎么应用这两个方法呢？</p><p>我们先来看下，Redis可以用哪些单命令操作实现加锁操作。</p><p>首先是SETNX命令，它用于设置键值对的值。具体来说，就是这个命令在执行时会判断键值对是否存在，如果不存在，就设置键值对的值，如果存在，就不做任何设置。</p><p>举个例子，如果执行下面的命令时，key不存在，那么key会被创建，并且值会被设置为value；如果key已经存在，SETNX不做任何赋值操作。</p><pre><code>SETNX key value\n</code></pre><p>对于释放锁操作来说，我们可以在执行完业务逻辑后，使用DEL命令删除锁变量。不过，你不用担心锁变量被删除后，其他客户端无法请求加锁了。因为SETNX命令在执行时，如果要设置的键值对（也就是锁变量）不存在，SETNX命令会先创建键值对，然后设置它的值。所以，释放锁之后，再有客户端请求加锁时，SETNX命令会创建保存锁变量的键值对，并设置锁变量的值，完成加锁。</p><p>总结来说，我们就可以用SETNX和DEL命令组合来实现加锁和释放锁操作。下面的伪代码示例显示了锁操作的过程，你可以看下。</p><pre><code>// 加锁\nSETNX lock_key 1\n// 业务逻辑\nDO THINGS\n// 释放锁\nDEL lock_key\n</code></pre><p>不过，使用SETNX和DEL命令组合实现分布锁，存在两个潜在的风险。</p><p>第一个风险是，假如某个客户端在执行了SETNX命令、加锁之后，紧接着却在操作共享数据时发生了异常，结果一直没有执行最后的DEL命令释放锁。因此，锁就一直被这个客户端持有，其它客户端无法拿到锁，也无法访问共享数据和执行后续操作，这会给业务应用带来影响。</p><p>针对这个问题，一个有效的解决方法是，<strong>给锁变量设置一个过期时间</strong>。这样一来，即使持有锁的客户端发生了异常，无法主动地释放锁，Redis也会根据锁变量的过期时间，在锁变量过期后，把它删除。其它客户端在锁变量过期后，就可以重新请求加锁，这就不会出现无法加锁的问题了。</p><p>我们再来看第二个风险。如果客户端A执行了SETNX命令加锁后，假设客户端B执行了DEL命令释放锁，此时，客户端A的锁就被误释放了。如果客户端C正好也在申请加锁，就可以成功获得锁，进而开始操作共享数据。这样一来，客户端A和C同时在对共享数据进行操作，数据就会被修改错误，这也是业务层不能接受的。</p><p>为了应对这个问题，我们需要<strong>能区分来自不同客户端的锁操作</strong>，具体咋做呢？其实，我们可以在锁变量的值上想想办法。</p><p>在使用SETNX命令进行加锁的方法中，我们通过把锁变量值设置为1或0，表示是否加锁成功。1和0只有两种状态，无法表示究竟是哪个客户端进行的锁操作。所以，我们在加锁操作时，可以让每个客户端给锁变量设置一个唯一值，这里的唯一值就可以用来标识当前操作的客户端。在释放锁操作时，客户端需要判断，当前锁变量的值是否和自己的唯一标识相等，只有在相等的情况下，才能释放锁。这样一来，就不会出现误释放锁的问题了。</p><p>知道了解决方案，那么，在Redis中，具体是怎么实现的呢？我们再来了解下。</p><p>在查看具体的代码前，我要先带你学习下Redis的SET命令。</p><p>我们刚刚在说SETNX命令的时候提到，对于不存在的键值对，它会先创建再设置值（也就是“不存在即设置”），为了能达到和SETNX命令一样的效果，Redis给SET命令提供了类似的选项NX，用来实现“不存在即设置”。如果使用了NX选项，SET命令只有在键值对不存在时，才会进行设置，否则不做赋值操作。此外，SET命令在执行时还可以带上EX或PX选项，用来设置键值对的过期时间。</p><p>举个例子，执行下面的命令时，只有key不存在时，SET才会创建key，并对key进行赋值。另外，<strong>key的存活时间由seconds或者milliseconds选项值来决定</strong>。</p><pre><code>SET key value [EX seconds | PX milliseconds]  [NX]\n</code></pre><p>有了SET命令的NX和EX/PX选项后，我们就可以用下面的命令来实现加锁操作了。</p><pre><code>// 加锁, unique_value作为客户端唯一性的标识\nSET lock_key unique_value NX PX 10000\n</code></pre><p>其中，unique_value是客户端的唯一标识，可以用一个随机生成的字符串来表示，PX 10000则表示lock_key会在10s后过期，以免客户端在这期间发生异常而无法释放锁。</p><p>因为在加锁操作中，每个客户端都使用了一个唯一标识，所以在释放锁操作时，我们需要判断锁变量的值，是否等于执行释放锁操作的客户端的唯一标识，如下所示：</p><pre><code>//释放锁 比较unique_value是否相等，避免误释放\nif redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then\n    return redis.call(&quot;del&quot;,KEYS[1])\nelse\n    return 0\nend\n</code></pre><p>这是使用Lua脚本（unlock.script）实现的释放锁操作的伪代码，其中，KEYS[1]表示lock_key，ARGV[1]是当前客户端的唯一标识，这两个值都是我们在执行Lua脚本时作为参数传入的。</p><p>最后，我们执行下面的命令，就可以完成锁释放操作了。</p><pre><code>redis-cli  --eval  unlock.script lock_key , unique_value \n</code></pre><p>你可能也注意到了，在释放锁操作中，我们使用了Lua脚本，这是因为，释放锁操作的逻辑也包含了读取锁变量、判断值、删除锁变量的多个操作，而Redis在执行Lua脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p><p>好了，到这里，你了解了如何使用SET命令和Lua脚本在Redis单节点上实现分布式锁。但是，我们现在只用了一个Redis实例来保存锁变量，如果这个Redis实例发生故障宕机了，那么锁变量就没有了。此时，客户端也无法进行锁操作了，这就会影响到业务的正常执行。所以，我们在实现分布式锁时，还需要保证锁的可靠性。那怎么提高呢？这就要提到基于多个Redis节点实现分布式锁的方式了。</p><h2>基于多个Redis节点实现高可靠的分布式锁</h2><p>当我们要实现高可靠的分布式锁时，就不能只依赖单个的命令操作了，我们需要按照一定的步骤和规则进行加解锁操作，否则，就可能会出现锁无法工作的情况。“一定的步骤和规则”是指啥呢？其实就是分布式锁的算法。</p><p>为了避免Redis实例故障而导致的锁无法工作的问题，Redis的开发者Antirez提出了分布式锁算法Redlock。</p><p>Redlock算法的基本思路，是让客户端和多个独立的Redis实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个Redis实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。</p><p>我们来具体看下Redlock算法的执行步骤。Redlock算法的实现需要有N个独立的Redis实例。接下来，我们可以分成3步来完成加锁操作。</p><p><strong>第一步是，客户端获取当前时间。</strong></p><p><strong>第二步是，客户端按顺序依次向N个Redis实例执行加锁操作。</strong></p><p>这里的加锁操作和在单实例上执行的加锁操作一样，使用SET命令，带上NX，EX/PX选项，以及带上客户端的唯一标识。当然，如果某个Redis实例发生故障了，为了保证在这种情况下，Redlock算法能够继续运行，我们需要给加锁操作设置一个超时时间。</p><p>如果客户端在和一个Redis实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个Redis实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。</p><p><strong>第三步是，一旦客户端完成了和所有Redis实例的加锁操作，客户端就要计算整个加锁过程的总耗时。</strong></p><p>客户端只有在满足下面的这两个条件时，才能认为是加锁成功。</p><ul>\n<li>条件一：客户端从超过半数（大于等于 N/2+1）的Redis实例上成功获取到了锁；</li>\n<li>条件二：客户端获取锁的总耗时没有超过锁的有效时间。</li>\n</ul><p>在满足了这两个条件后，我们需要重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁的总耗时。如果锁的有效时间已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p><p>当然，如果客户端在和所有实例执行完加锁操作后，没能同时满足这两个条件，那么，客户端向所有Redis节点发起释放锁的操作。</p><p>在Redlock算法中，释放锁的操作和在单实例上释放锁的操作一样，只要执行释放锁的Lua脚本就可以了。这样一来，只要N个Redis实例中的半数以上实例能正常工作，就能保证分布式锁的正常工作了。</p><p>所以，在实际的业务应用中，如果你想要提升分布式锁的可靠性，就可以通过Redlock算法来实现。</p><h2>小结</h2><p>分布式锁是由共享存储系统维护的变量，多个客户端可以向共享存储系统发送命令进行加锁或释放锁操作。Redis作为一个共享存储系统，可以用来实现分布式锁。</p><p>在基于单个Redis实例实现分布式锁时，对于加锁操作，我们需要满足三个条件。</p><ol>\n<li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用SET命令带上NX选项来实现加锁；</li>\n<li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在SET命令执行时加上EX/PX选项，设置其过期时间；</li>\n<li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用SET命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。</li>\n</ol><p>和加锁类似，释放锁也包含了读取锁变量值、判断锁变量值和删除锁变量三个操作，不过，我们无法使用单个命令来实现，所以，我们可以采用Lua脚本执行释放锁操作，通过Redis原子性地执行Lua脚本，来保证释放锁操作的原子性。</p><p>不过，基于单个Redis实例实现分布式锁时，会面临实例异常或崩溃的情况，这会导致实例无法提供锁操作，正因为此，Redis也提供了Redlock算法，用来实现基于多个实例的分布式锁。这样一来，锁变量由多个实例维护，即使有实例发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。Redlock算法是实现高可靠分布式锁的一种有效解决方案，你可以在实际应用中把它用起来。</p><h2>每课一问</h2><p>按照惯例，我给你提个小问题。这节课，我提到，我们可以使用SET命令带上NX和EX/PX选项进行加锁操作，那么，我想请你再思考一下，我们是否可以用下面的方式来实现加锁操作呢？</p><pre><code>// 加锁\nSETNX lock_key unique_value\nEXPIRE lock_key 10S\n// 业务逻辑\nDO THINGS\n</code></pre><p>欢迎在留言区写下你的思考和答案，我们一起交流讨论。如果你觉得今天的内容对你有所帮助，也欢迎你分享给你的朋友或同事。我们下节课见。</p>","neighbors":{"left":{"article_title":"29 | 无锁的原子操作：Redis如何应对并发访问？","id":299806},"right":{"article_title":"31 | 事务机制：Redis能实现ACID属性吗？","id":301491}},"comments":[{"had_liked":false,"id":257024,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1603814977,"is_pvip":true,"discussion_count":64,"race_medal":0,"score":"1234259428929","product_id":100056701,"comment_content":"是否可以使用 SETNX + EXPIRE 来完成加锁操作？<br><br>不可以这么使用。使用 2 个命令无法保证操作的原子性，在异常情况下，加锁结果会不符合预期。异常情况主要分为以下几种情况：<br><br>1、SETNX 执行成功，执行 EXPIRE 时由于网络问题设置过期失败<br><br>2、SETNX 执行成功，此时 Redis 实例宕机，EXPIRE 没有机会执行<br><br>3、SETNX 执行成功，客户端异常崩溃，EXPIRE 没有机会执行<br><br>如果发生以上情况，并且客户端在释放锁时发生异常，没有正常释放锁，那么这把锁就会一直无法释放，其他线程都无法再获得锁。<br><br>下面说一下关于 Redis 分布式锁可靠性的问题。<br><br>使用单个 Redis 节点（只有一个master）使用分布锁，如果实例宕机，那么无法进行锁操作了。那么采用主从集群模式部署是否可以保证锁的可靠性？<br><br>答案是也很难保证。如果在 master 上加锁成功，此时 master 宕机，由于主从复制是异步的，加锁操作的命令还未同步到 slave，此时主从切换，新 master 节点依旧会丢失该锁，对业务来说相当于锁失效了。<br><br>所以 Redis 作者才提出基于多个 Redis 节点（master节点）的 Redlock 算法，但这个算法涉及的细节很多，作者在提出这个算法时，业界的分布式系统专家还与 Redis 作者发生过一场争论，来评估这个算法的可靠性，争论的细节都是关于异常情况可能导致 Redlock 失效的场景，例如加锁过程中客户端发生了阻塞、机器时钟发生跳跃等等。<br><br>感兴趣的可以看下这篇文章，详细介绍了争论的细节，以及 Redis 分布式锁在各种异常情况是否安全的分析，收益会非常大：http:&#47;&#47;zhangtielei.com&#47;posts&#47;blog-redlock-reasoning.html。<br><br>简单总结，基于 Redis 使用分布锁的注意点：<br><br>1、使用 SET $lock_key $unique_val EX $second NX 命令保证加锁原子性，并为锁设置过期时间<br><br>2、锁的过期时间要提前评估好，要大于操作共享资源的时间<br><br>3、每个线程加锁时设置随机值，释放锁时判断是否和加锁设置的值一致，防止自己的锁被别人释放<br><br>4、释放锁时使用 Lua 脚本，保证操作的原子性<br><br>5、基于多个节点的 Redlock，加锁时超过半数节点操作成功，并且获取锁的耗时没有超过锁的有效时间才算加锁成功<br><br>6、Redlock 释放锁时，要对所有节点释放（即使某个节点加锁失败了），因为加锁时可能发生服务端加锁成功，由于网络问题，给客户端回复网络包失败的情况，所以需要把所有节点可能存的锁都释放掉<br><br>7、使用 Redlock 时要避免机器时钟发生跳跃，需要运维来保证，对运维有一定要求，否则可能会导致 Redlock 失效。例如共 3 个节点，线程 A 操作 2 个节点加锁成功，但其中 1 个节点机器时钟发生跳跃，锁提前过期，线程 B 正好在另外 2 个节点也加锁成功，此时 Redlock 相当于失效了（Redis 作者和分布式系统专家争论的重要点就在这）<br><br>8、如果为了效率，使用基于单个 Redis 节点的分布式锁即可，此方案缺点是允许锁偶尔失效，优点是简单效率高<br><br>9、如果是为了正确性，业务对于结果要求非常严格，建议使用 Redlock，但缺点是使用比较重，部署成本高","like_count":287,"discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378662,"discussion_content":"这里老师漏了一点 就是session timeout处理 在分布式锁的场景中就是：\n一个key过期了 但是代码还没处理完 此时就发生了重复加锁的问题。\n\n通常我们有两种方式处理：\n1. 设置看门狗 也就是redision的处理方式\n2. 设置状态机 由最后的业务层来做代码回溯","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1623327208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":378351,"discussion_content":"关于Redis分布式锁，我写了篇文章，把大家在评论区的各种疑问都讲清楚了，可以看看：《深度剖析：Redis分布式锁到底安全吗？看完这篇文章彻底懂了！》https://mp.weixin.qq.com/s/s8xjm1ZCKIoTGT3DCVA4aw","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1623170592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1106088,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","nickname":"Sic Pavis","note":"","ucode":"48B5F0118347C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":384617,"discussion_content":"文章阅读完了，最大的疑虑就是两个大神没讨论到的。\n就是正常获取到锁后陷入gc，导致锁超时，释放锁的时候发现锁已被其他线程占用。 也就是说可能产生了冲突，分布式锁是失效了的。此时是否有一种稳妥一些的策略处理？\n\n容易想到的办法是回滚，但是复杂业务里能否正常回滚不说，回滚也可能覆盖其他业务数据。希望可以交流一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1626680323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":378351,"ip_address":""},"score":384617,"extra":""},{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1106088,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","nickname":"Sic Pavis","note":"","ucode":"48B5F0118347C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384704,"discussion_content":"文章也提到了，锁不会100%安全，所以敏感业务一般是数据层做兜底，即使锁出问题，也要保证业务正确，一般是数据库使用乐观锁来做。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1626704302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384617,"ip_address":""},"score":384704,"extra":""},{"author":{"id":2748259,"avatar":"","nickname":"Geek_5aebee","note":"","ucode":"E1348EB60A838C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1106088,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","nickname":"Sic Pavis","note":"","ucode":"48B5F0118347C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390808,"discussion_content":"DDIA里面有讲，超时时间要设置远大于GC时间，EX只是作为最后的保底。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1630054756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":384617,"ip_address":""},"score":390808,"extra":""}]},{"author":{"id":1043947,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/eb/88cac7a5.jpg","nickname":"东","note":"","ucode":"0FF5018422CEA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318886,"discussion_content":"大神们之间争论的那两篇博客太精彩了，受益匪浅\nhttp://zhangtielei.com/posts/blog-redlock-reasoning.html","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1603874534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1043947,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ed/eb/88cac7a5.jpg","nickname":"东","note":"","ucode":"0FF5018422CEA9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318926,"discussion_content":"是的，我看了之后受益也很大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603885109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318886,"ip_address":""},"score":318926,"extra":""}]},{"author":{"id":1173894,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e9/86/d34800a4.jpg","nickname":"heyman","note":"","ucode":"92EF9EF1B1B1B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363320,"discussion_content":"“2、锁的过期时间要提前评估好，要大于操作共享资源的时间”。这个面试被问到了，一脸懵逼。问：假如拿到锁之后Java刚好在执行gc，执行了4、5秒，而锁的过期时间是3秒，怎么办？把过期时间延长？感觉没办法解决根本问题啊。课代表有什么idea么？","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1617167760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":8,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1173894,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e9/86/d34800a4.jpg","nickname":"heyman","note":"","ucode":"92EF9EF1B1B1B3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":363358,"discussion_content":"如果是敏感业务，要在业务层做兜底。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617178230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363320,"ip_address":""},"score":363358,"extra":""},{"author":{"id":1173894,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e9/86/d34800a4.jpg","nickname":"heyman","note":"","ucode":"92EF9EF1B1B1B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":363722,"discussion_content":"没太理解你的意思，能不能具体讲讲？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617269661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363358,"ip_address":""},"score":363722,"extra":""},{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1173894,"avatar":"https://static001.geekbang.org/account/avatar/00/11/e9/86/d34800a4.jpg","nickname":"heyman","note":"","ucode":"92EF9EF1B1B1B3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381809,"discussion_content":"可不可以在日志记录下用户id，商品id这些信息，后面再查这些信息去做处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625220943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":363320,"ip_address":""},"score":381809,"extra":""}]},{"author":{"id":1189239,"avatar":"https://static001.geekbang.org/account/avatar/00/12/25/77/f16213e2.jpg","nickname":"阿贱","note":"","ucode":"EF1CBCA128CAEC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340282,"discussion_content":"你好，请问一下，这个setnx是有值就不设值，还是后面的所有逻辑都不执行呀？如果只是不设值，那不还是会往下执行吗？还是说没值的话setnx返回1，有值返回0，根据这样判断后续的操作执不执行从而避免并发吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609943307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1189239,"avatar":"https://static001.geekbang.org/account/avatar/00/12/25/77/f16213e2.jpg","nickname":"阿贱","note":"","ucode":"EF1CBCA128CAEC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":340285,"discussion_content":"根据返回结果，业务自己控制后续逻辑。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609943990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340282,"ip_address":""},"score":340285,"extra":""},{"author":{"id":1189239,"avatar":"https://static001.geekbang.org/account/avatar/00/12/25/77/f16213e2.jpg","nickname":"阿贱","note":"","ucode":"EF1CBCA128CAEC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":340317,"discussion_content":"好的谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609974409,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":340285,"ip_address":""},"score":340317,"extra":""}]},{"author":{"id":1670963,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zGUSFibP0OGFW9a3QSic1DZLr5B4kPoNmt3RibzLNYSOxN3mUZibBMkGHpwcYPFYWJ7v61wsMvyIKzpBuQJWD2hVOg/132","nickname":"九时四","note":"","ucode":"92DCC2DF3DD15C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321744,"discussion_content":"大神你好，我想问个问题：在分布式锁加锁的时候，客户端对锁已经设置了唯一值，这样的话，其他客户端也不会成功修改这个值，分布式锁释放不用Lua脚本是不是也可以？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604628390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1670963,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/zGUSFibP0OGFW9a3QSic1DZLr5B4kPoNmt3RibzLNYSOxN3mUZibBMkGHpwcYPFYWJ7v61wsMvyIKzpBuQJWD2hVOg/132","nickname":"九时四","note":"","ucode":"92DCC2DF3DD15C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324633,"discussion_content":"不用lua脚本做客户端唯一性判断，会被其他客户端误删掉锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605146330,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":321744,"ip_address":""},"score":324633,"extra":""},{"author":{"id":2032032,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/01/a0/07ca2bd2.jpg","nickname":"一路顺风","note":"","ucode":"D46B7F92D65189","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1368038,"avatar":"https://static001.geekbang.org/account/avatar/00/14/df/e6/bd1b3c0b.jpg","nickname":"Jesse","note":"","ucode":"727CA882B84DA0","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":350197,"discussion_content":"意思释放锁为啥要求原子性？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613744071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324633,"ip_address":""},"score":350197,"extra":""},{"author":{"id":2214172,"avatar":"","nickname":"叶盛","note":"","ucode":"370B6BD4D255FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2032032,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/01/a0/07ca2bd2.jpg","nickname":"一路顺风","note":"","ucode":"D46B7F92D65189","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355142,"discussion_content":"如果不具备原子性，那么，如果客户端通过两个线程调用了释放锁的操作，两个线程都读取了变量，可能第一个线程释放了锁，\n然后锁由其他客户端持有，后来第二个线程进入了释放锁的操作，就把别的客户端的锁给释放了。这是我想到的一种可能的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615385719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350197,"ip_address":""},"score":355142,"extra":""}]},{"author":{"id":1415619,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","nickname":"陌兮","note":"","ucode":"00CE47CAECD5CD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553703,"discussion_content":"mark一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646035730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1434066,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","nickname":"今夜秋风和","note":"","ucode":"453C8197FFC81D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366602,"discussion_content":"请问下单机锁情况下，业务常用的方案是设置过期时间后，业务流程执行完成后，finally 中主动释放锁 del，还是等待锁自然过期,另一个客户端进行加锁操作;","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618130493,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1434066,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","nickname":"今夜秋风和","note":"","ucode":"453C8197FFC81D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":366610,"discussion_content":"主动释放锁。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1618132829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366602,"ip_address":""},"score":366610,"extra":""},{"author":{"id":1434066,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","nickname":"今夜秋风和","note":"","ucode":"453C8197FFC81D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":366786,"discussion_content":"好的，感谢感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618190862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366610,"ip_address":""},"score":366786,"extra":""},{"author":{"id":1234273,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d5/61/8ad99e09.jpg","nickname":"刘百万","note":"","ucode":"692E23D070641A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1434066,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e1/d2/42ad2c87.jpg","nickname":"今夜秋风和","note":"","ucode":"453C8197FFC81D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369067,"discussion_content":"应该得主动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618918973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":366602,"ip_address":""},"score":369067,"extra":""}]},{"author":{"id":1104100,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d8/e4/7cc47d20.jpg","nickname":"Alexander","note":"","ucode":"5EF394E93A1715","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339652,"discussion_content":"课代表好，6、Redlock 释放锁时，要对所有节点释放（即使某个节点加锁失败了），这里，如果某个节点释放失败，怎么办呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609753153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2402016,"avatar":"https://static001.geekbang.org/account/avatar/00/24/a6/e0/1e5bdae9.jpg","nickname":"唐极客德","note":"","ucode":"9B5D952DBD6F82","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1104100,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d8/e4/7cc47d20.jpg","nickname":"Alexander","note":"","ucode":"5EF394E93A1715","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343952,"discussion_content":"好像是有过期时间的","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1611217139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339652,"ip_address":""},"score":343952,"extra":""}]},{"author":{"id":2172420,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/r2nR7Zkl5RP7LobsNKJ6wmmtyXrh4alNSAOldx1y1PSeFB1J2I14HE4I0BCgicPhubIOibPZAENzEpHEWTFjMNqg/132","nickname":"董董","note":"","ucode":"C222E275545158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335881,"discussion_content":"课代表，麻烦问下，如果我们部署的是集群环境，那么在使用redLock的时候，就需要搭建多个集群了么，感觉如果这样的话有点鸡肋了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608365714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2172420,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/r2nR7Zkl5RP7LobsNKJ6wmmtyXrh4alNSAOldx1y1PSeFB1J2I14HE4I0BCgicPhubIOibPZAENzEpHEWTFjMNqg/132","nickname":"董董","note":"","ucode":"C222E275545158","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335887,"discussion_content":"最终还是看你业务，是否值得用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608366809,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":335881,"ip_address":""},"score":335887,"extra":""}]},{"author":{"id":2348024,"avatar":"","nickname":"Geek_c3bf02","note":"","ucode":"97C6848DFCA2A0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334153,"discussion_content":"大佬, 请问你觉得ktcd和redis那种更好？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607754567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2341163,"avatar":"https://static001.geekbang.org/account/avatar/00/23/b9/2b/c0f306a5.jpg","nickname":"Geek_a315d7","note":"","ucode":"6F8D9CA9D8844C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333442,"discussion_content":"大神好，有个问题没想明白，麻烦解答下\n\n单机锁的流程是\n1-setnx ex加锁（成功之后继续后面逻辑，失败直接返回）\n2-处理业务\n3-del 锁\n\n不明白锁为啥会被其他线程给删除掉","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607521535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2341163,"avatar":"https://static001.geekbang.org/account/avatar/00/23/b9/2b/c0f306a5.jpg","nickname":"Geek_a315d7","note":"","ucode":"6F8D9CA9D8844C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":333455,"discussion_content":"线程1加锁成功，结果处理业务发生耗时，超过了锁的过期时间，锁自动过期了。\n\n此时线程2进来，加锁成功，开始处理业务，之后线程1处理业务结束了，释放的是线程2的锁，那线程2的锁相当于失效了。","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1607523064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":333442,"ip_address":""},"score":333455,"extra":""},{"author":{"id":2341163,"avatar":"https://static001.geekbang.org/account/avatar/00/23/b9/2b/c0f306a5.jpg","nickname":"Geek_a315d7","note":"","ucode":"6F8D9CA9D8844C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":333727,"discussion_content":"感谢大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607605102,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":333455,"ip_address":""},"score":333727,"extra":""}]},{"author":{"id":1312184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","nickname":"JulyRemember","note":"","ucode":"9E3D5D60D82999","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319509,"discussion_content":"我想问下有遇到过设置了过期时间但是代码没有执行完就失效的情况吗，这种一般可以怎么处理啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604042079,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":8,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1312184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","nickname":"JulyRemember","note":"","ucode":"9E3D5D60D82999","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319584,"discussion_content":"为啥没执行完？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604059284,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319509,"ip_address":""},"score":319584,"extra":""},{"author":{"id":1312184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","nickname":"JulyRemember","note":"","ucode":"9E3D5D60D82999","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":320479,"discussion_content":"比如说项目中有个定时任务和mq消息同时处理，然后业务逻辑有资源争夺所以会加分布式锁来控制，然后定时任务先拿到锁执行，但是业务逻辑比较繁重会导致锁的失效，然后这个时候消息处理那里可能先获取到锁了，类似这种情况，因为有的时候执行时间可能估计的不准确，然后定时任务和消息都处理数据库的话会有插入数据主键冲突的问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604378063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319584,"ip_address":""},"score":320479,"extra":""},{"author":{"id":2105684,"avatar":"https://static001.geekbang.org/account/avatar/00/20/21/54/f172b987.jpg","nickname":"炜","note":"","ucode":"79053A57BCD77A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1312184,"avatar":"https://static001.geekbang.org/account/avatar/00/14/05/b8/8d468842.jpg","nickname":"JulyRemember","note":"","ucode":"9E3D5D60D82999","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326193,"discussion_content":"好像看过有这么个说法，在逻辑处理中每隔一段时间检查锁","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605540952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":320479,"ip_address":""},"score":326193,"extra":""}]},{"author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318965,"discussion_content":"这里说的多个Redis节点 应该指的是独立的几个Redis服务而不是 一个集群中的节点吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603893335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318978,"discussion_content":"是的","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603895408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318965,"ip_address":""},"score":318978,"extra":""},{"author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":319484,"discussion_content":"什么场景下会使用几个独立的Redis服务呢？可以简单说说吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604037513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318978,"ip_address":""},"score":319484,"extra":""},{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319585,"discussion_content":"比如这次讲的Redlock就是这种情况啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604059318,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":319484,"ip_address":""},"score":319585,"extra":""}]},{"author":{"id":2105292,"avatar":"","nickname":"gopher","note":"","ucode":"EF9DAB533A858C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318921,"discussion_content":"总结的挺好，手动点赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603882392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1928373,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/6c/b5/32374f93.jpg","nickname":"可怜大灰狼","note":"","ucode":"6CA9D6D460B967","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318805,"discussion_content":"“如果是为了正确性，业务对于结果要求非常严格，建议使用 Redlock”。说实话，结果要求非常严格，我觉得应该用zk更合适些，而在允许锁偶尔失效情况下用redlock。当然专栏是redis，哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603853730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1008582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","nickname":"林肯","note":"","ucode":"D2C97220230DE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1928373,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/6c/b5/32374f93.jpg","nickname":"可怜大灰狼","note":"","ucode":"6CA9D6D460B967","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":318809,"discussion_content":"zk的并发度较低是个问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603853993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318805,"ip_address":""},"score":318809,"extra":""},{"author":{"id":1928373,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/6c/b5/32374f93.jpg","nickname":"可怜大灰狼","note":"","ucode":"6CA9D6D460B967","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1008582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","nickname":"林肯","note":"","ucode":"D2C97220230DE5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319249,"discussion_content":"首先单机获取锁，获取单机锁以后再获取分布式锁，这样只和集群中机器数有关，我在平时过程中也是够用了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603973111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318809,"ip_address":""},"score":319249,"extra":""},{"author":{"id":1316409,"avatar":"https://static001.geekbang.org/account/avatar/00/14/16/39/eb9078b2.jpg","nickname":"夏华秋实","note":"","ucode":"7233B407BAA14C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1928373,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/6c/b5/32374f93.jpg","nickname":"可怜大灰狼","note":"","ucode":"6CA9D6D460B967","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":334074,"discussion_content":"zk分布式锁也会出现锁失效的情况","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607736374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318805,"ip_address":""},"score":334074,"extra":""}]},{"author":{"id":1739992,"avatar":"","nickname":"地下城勇士","note":"","ucode":"91ACD73D56A9F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318799,"discussion_content":"反倒是想问问，之前的单机版方案，为什么不能用在分布式下，一个节点down了锁会过期失效，后面的节点不能直接拿锁吗？这个不是很懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603851635,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1739992,"avatar":"","nickname":"地下城勇士","note":"","ucode":"91ACD73D56A9F1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318800,"discussion_content":"没太明白你问的，最好详细描述下哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603852082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318799,"ip_address":""},"score":318800,"extra":""}]},{"author":{"id":1033425,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c4/d1/209abdd6.jpg","nickname":"小狼","note":"","ucode":"FEAC7864FC1D20","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318758,"discussion_content":"两个命令写成 Lua 脚本呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603846320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1033425,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c4/d1/209abdd6.jpg","nickname":"小狼","note":"","ucode":"FEAC7864FC1D20","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":318793,"discussion_content":"可以是可以，但是Redis一个SET命令就可以搞定，而且保证原子性，没必要放Lua多此一举了。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1603851080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318758,"ip_address":""},"score":318793,"extra":""}]}]},{"had_liked":false,"id":257194,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1603878011,"is_pvip":true,"discussion_count":8,"race_medal":0,"score":"302251588731","product_id":100056701,"comment_content":"其实分布式锁选择Etcd的话，可能会更好。<br><br>Etcd 支持以下功能，正是依赖这些功能来实现分布式锁的：<br><br>1、Lease 即租约机制（TTL，Time To Live）机制：<br><br>Etcd 可以为存储的 KV 对设置租约，当租约到期，KV 将失效删除；同时也支持续约，即 KeepAlive；<br><br>Redis在这方面很难实现，一般假设通过SETNX设置的时间10S，如果发生网络抖动，万一业务执行超过10S，此时别的线程就能回去到锁；<br><br><br>2、Revision 机制：<br><br>Etcd 每个 key 带有一个 Revision 属性值，每进行一次事务对应的全局 Revision 值都会加一，因此每个 key 对应的 Revision 属性值都是全局唯一的。通过比较 Revision 的大小就可以知道进行写操作的顺序。 在实现分布式锁时，多个程序同时抢锁，根据 Revision 值大小依次获得锁，可以避免 “惊群效应”，实现公平锁；<br><br>Redis很难实现公平锁，而且在某些情况下，也会产生 “惊群效应”；<br> <br><br>3、Prefix 即前缀机制，也称目录机制：<br><br>Etcd 可以根据前缀（目录）获取该目录下所有的 key 及对应的属性（包括 key, value 以及 revision 等）；<br><br>Redis也可以的，使用keys命令或者scan，生产环境一定要使用scan；<br><br><br>4、Watch 机制：<br><br>Etcd Watch 机制支持 Watch 某个固定的 key，也支持 Watch 一个目录（前缀机制），当被 Watch 的 key 或目录发生变化，客户端将收到通知；<br><br>Redis只能通过客户端定时轮训的形式去判断key是否存在；","like_count":70,"discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348855,"discussion_content":"这应该是跟具体的业务场景来选取，不然业务场景简单，并发量低，系统中已经使用了Redis，就可以考虑使用REdis来实现分布式锁了，减少运维的工作量。如果系统复杂 可以考虑其他更可靠的分布式锁机制。只有适合的技术，没有最好的技术。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1612754685,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2194764,"avatar":"","nickname":"K菌无惨","note":"","ucode":"97A532D588FD49","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343980,"discussion_content":"etcd由于要使用到raft算法,所以并发量算太高,但能避免很多由于redis(主从模式)不能提供强一致性导致有可能出现(由于发生了主从切换导致的)多个客户端同时获得锁的问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611223295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2058852,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/6a/64/3d4fccf8.jpg","nickname":"Z_Z","note":"","ucode":"654BE3F3C7DBA4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573086,"discussion_content":"红锁也能续约，redis也有pub/sub机制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653198169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227107,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b9/63/a3b11794.jpg","nickname":"麦抠","note":"","ucode":"875DEA26F38BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545342,"discussion_content":"生产环境一定要使用scan，楼主笔误了..","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641912368,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667714,"avatar":"https://static001.geekbang.org/account/avatar/00/19/72/82/24fb9d18.jpg","nickname":"慕然","note":"","ucode":"8622102560A80F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407913,"discussion_content":"请教一下大佬，上面的这些是从哪里了解到的呢？书还是博客，论文呢？etcd只了解个大概。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635149210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/10/4d2d6e64.jpg","nickname":"劳动维权","note":"","ucode":"1D5CEB96618E01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387936,"discussion_content":"分布式一致性的要求高的场景还是用zookeeper好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628502950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1506574,"avatar":"","nickname":"Geek_1e8830","note":"","ucode":"CD84A5AAAE6872","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348404,"discussion_content":"那为啥不用zk呢，照你这么说，并发量上不去，所以这个玩意还是要看场景，看你是需要高并发还是一致性安全性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612536086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1107550,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e6/5e/62158841.jpg","nickname":"取经人","note":"","ucode":"C3668CA65200DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":332200,"discussion_content":"zk","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607092121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257540,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1604023848,"is_pvip":false,"discussion_count":4,"race_medal":1,"score":"61733565992","product_id":100056701,"comment_content":"配合这篇文章看，效果更佳 https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;2P2-ujcdet9cUycokfyjHQ<br><br>这篇是早晨通勤坐地铁开了一个番茄钟看完的，番茄钟开启学霸模式，将这些学习和读书的app加入白名单，在一个番茄钟周期内就不能打开那些未加入白名单的app，可以防止刷耗精力的app，工作时也经常用，效果不错<br><br>如果自己能总结出来并给别人讲明白，就像课代表一样，每篇文章的留言都非常优秀，每次必看，这个知识点就掌握了，能用到工作实战上，那就锦上添花了","like_count":14,"discussions":[{"author":{"id":1342023,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/47/d9090056.jpg","nickname":"在路边鼓掌的人","note":"","ucode":"BC1388BA330CD5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587641,"discussion_content":"你好，文章失效了，可以再发下吗\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663172599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110492,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f1/dc/05df7333.jpg","nickname":"hu","note":"","ucode":"57A074D5904907","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583911,"discussion_content":"thanks very much","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660484731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2762186,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/25/ca/96734ade.jpg","nickname":"随机漫步的傻瓜","note":"","ucode":"FBEFB27BF45ED4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399606,"discussion_content":"番茄钟确实很好用，如果PC端浏览器的话，推荐一个插件，StayFocusd","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633003626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1768347,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/kJV8ricxYeOzXWIiapOxW5LzXEByn1376olhUAoULLdrIR42LMF8kJBRAI1NEiaLkWvrQ6BrwIOq1U1O0hfnmcnGQ/132","nickname":"诗记","note":"","ucode":"F0D2432B215CA1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388411,"discussion_content":"懂了，番茄钟打钱！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628755328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297143,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1623327218,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"35983065586","product_id":100056701,"comment_content":"这里老师漏了一点 就是session timeout处理 在分布式锁的场景中就是：<br>一个key过期了 但是代码还没处理完 此时就发生了重复加锁的问题。<br><br>通常我们有两种方式处理：<br>1. 设置看门狗 也就是redision的处理方式<br>2. 设置状态机 由最后的业务层来做代码回溯","like_count":8,"discussions":[{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549471,"discussion_content":"看业务处理时间，留些buffer\n通常redis锁并不是强一致锁\n数据库维一键可靠点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644020553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/89/70/f5845602.jpg","nickname":"A梦多啦A","note":"","ucode":"026669D6CACA8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408337,"discussion_content":"看门狗的方案，其实就是给锁续命吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635229740,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1667714,"avatar":"https://static001.geekbang.org/account/avatar/00/19/72/82/24fb9d18.jpg","nickname":"慕然","note":"","ucode":"8622102560A80F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407911,"discussion_content":"大佬，这两种方式可以讲的再具体点么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635148947,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261234,"user_name":"小喵喵","can_delete":false,"product_type":"c1","uid":1062444,"ip_address":"","ucode":"FDBBB2A59DB8B6","user_header":"https://static001.geekbang.org/account/avatar/00/10/36/2c/8bd4be3a.jpg","comment_is_top":false,"comment_ctime":1605247462,"is_pvip":false,"replies":[{"id":"98014","content":"客户端是指向Redis发送读写请求的应用程序。你举的例子中，app的下单请求先是被发送到后端的服务器上，一般来说，服务器上还有业务程序先解析了app的请求，然后再向Redis发送读写请求，在这种情况下，服务器上的业务程序就是Redis的客户端。而app、浏览器算是服务器上业务程序的客户端。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609081013,"ip_address":"","comment_id":261234,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27375051238","product_id":100056701,"comment_content":"请教下老师文章中说的客户端，这个客户端指的是什么？比如浏览器下单，app下单，这个浏览器，app就是客户端吗？","like_count":6,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509429,"discussion_content":"客户端是指向Redis发送读写请求的应用程序。你举的例子中，app的下单请求先是被发送到后端的服务器上，一般来说，服务器上还有业务程序先解析了app的请求，然后再向Redis发送读写请求，在这种情况下，服务器上的业务程序就是Redis的客户端。而app、浏览器算是服务器上业务程序的客户端。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609081013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300583,"user_name":"喰","can_delete":false,"product_type":"c1","uid":2659564,"ip_address":"","ucode":"6133C265D4D63D","user_header":"https://static001.geekbang.org/account/avatar/00/28/94/ec/8db3f04a.jpg","comment_is_top":false,"comment_ctime":1625228946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14510130834","product_id":100056701,"comment_content":"对于给锁设置过期时间，即使再怎么预估也很难保证线程在锁有效时间内完成操作。而且预估时间设置的过大也会影响系统性能，所以可以使用一个守护线程进行续租。","like_count":3},{"had_liked":false,"id":271916,"user_name":"COLDLY","can_delete":false,"product_type":"c1","uid":1248467,"ip_address":"","ucode":"B16257B2D83CC0","user_header":"https://static001.geekbang.org/account/avatar/00/13/0c/d3/0be6ae81.jpg","comment_is_top":false,"comment_ctime":1609861049,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14494762937","product_id":100056701,"comment_content":"老师，请问锁的过期时间怎么设置，会不会因为客户端执行业务操作时耗时太久超过过期时间，导致锁过期被释放了","like_count":3,"discussions":[{"author":{"id":1108132,"avatar":"https://static001.geekbang.org/account/avatar/00/10/e8/a4/0be8a8ca.jpg","nickname":"CAFEBABE","note":"","ucode":"01F6BC01A4EFE4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373433,"discussion_content":"用此方法即可：setIfAbsent(String key, String value, long timeout, TimeUnit unit)\n\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620725906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265642,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1606968019,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14491869907","product_id":100056701,"comment_content":"不可以。这两个命令不是原子的。发生异常的时候，可能会有正常的加锁结果。<br><br>分布式锁:<br>1.唯一性<br>2.原子性<br>3.可重入<br><br>Redlock Redisson zookeeper etcd都是业界常用的分布式锁方案。","like_count":3,"discussions":[{"author":{"id":1797809,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLpuXh4ibibw0eI0r2TEI0FM07QnKjVK8fLiaorX17ia5lpeoBJr383dMeLh7m8CFrfOPYJazDIdbVYdA/132","nickname":"Geek_3094fd","note":"","ucode":"96D4049C54A23D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575000,"discussion_content":"还真没听说 哪家公司在用redlock","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654517666,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257668,"user_name":"漂泊者及其影子","can_delete":false,"product_type":"c1","uid":1119979,"ip_address":"","ucode":"13FE760FE8B111","user_header":"https://static001.geekbang.org/account/avatar/00/11/16/eb/30864e40.jpg","comment_is_top":false,"comment_ctime":1604051339,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"14488953227","product_id":100056701,"comment_content":"<br>&#47;&#47;释放锁 比较unique_value是否相等，避免误释放<br>if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then<br>    return redis.call(&quot;del&quot;,KEYS[1])<br>else<br>    return 0<br>end<br><br>释放锁为什么不能使用delete操作？","like_count":3,"discussions":[{"author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339833,"discussion_content":"如果不通过lua保证原子性,比如这种场景,客户端A先get(key)判断完值相等,准备删除key,这时候key过期,客户端B拿到锁,然后A执行删除key操作,导致B拿到的锁被错误释放","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1609817360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1119979,"avatar":"https://static001.geekbang.org/account/avatar/00/11/16/eb/30864e40.jpg","nickname":"漂泊者及其影子","note":"","ucode":"13FE760FE8B111","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340267,"discussion_content":"确实判断和delete是两个操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609939216,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339833,"ip_address":""},"score":340267,"extra":""},{"author":{"id":2351949,"avatar":"https://static001.geekbang.org/account/avatar/00/23/e3/4d/8a26dbb2.jpg","nickname":"枫中浪子","note":"","ucode":"860BEA32059B37","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357202,"discussion_content":"如果保证原子性，这时key过期，B就拿不到锁了么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615766000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":339833,"ip_address":""},"score":357202,"extra":""},{"author":{"id":2452377,"avatar":"","nickname":"朱庆龙","note":"","ucode":"9E0F5B2AA013AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2351949,"avatar":"https://static001.geekbang.org/account/avatar/00/23/e3/4d/8a26dbb2.jpg","nickname":"枫中浪子","note":"","ucode":"860BEA32059B37","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365479,"discussion_content":"我的想法是：如果保证原子性，得到当前锁变量以及判断是否是自己的锁以及删除该锁变量，这三个步骤是原子性一起执行的，哪怕在我判断成功之后删除锁之前，该key过期了，但是由于redis是单线程执行命令的，此时的redis主线程正在执行该lua脚本，哪怕其他线程向redis发送加锁的指令，也需要等到lua脚本执行完成，key过期那就只是删除操作返回0而已，不会存在误删其他线程的锁的情况，因为其他线程这个时候加不上锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617805090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":357202,"ip_address":""},"score":365479,"extra":""}]},{"author":{"id":1027789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/cd/3bffed26.jpg","nickname":"kitten","note":"","ucode":"E451DE087CB7CE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325542,"discussion_content":"我想了一个可能性，就是锁的时间提前过期了，这个时候你delete，可能把新的锁给解锁了，所以设置一个线程id，保证只释放自己加的锁，如果找不到就跳过不释放锁了。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1605342441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1609530,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/l4nngwyggBGqeMXC0micwO8bM1hSttgQXa1Y5frJSqWa8NibDhia5icwPcHM5wOpV3hfsf0UicDY0ypFqnQ3iarG0T1w/132","nickname":"Trident","note":"","ucode":"53E6788CF33398","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1027789,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ae/cd/3bffed26.jpg","nickname":"kitten","note":"","ucode":"E451DE087CB7CE","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":382909,"discussion_content":"想法一致👌","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625788742,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325542,"ip_address":""},"score":382909,"extra":""}]},{"author":{"id":1508662,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqic8BwOdWJDVBy2H7X7N77ha6mm2kkJOaBqqcSBfphhTYv16KKuhBicN08pAxYmShTJYKMMwrDs6iaw/132","nickname":"Geek_51cc93","note":"","ucode":"DB1588A47E8B32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331678,"discussion_content":"对啊   删除锁的时候，不保证原子性会出什么问题？？？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606929647,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2107375,"avatar":"https://static001.geekbang.org/account/avatar/00/20/27/ef/a7f94eda.jpg","nickname":"Jerry You","note":"","ucode":"679A44B505482F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":327194,"discussion_content":"先要获取在del，那就要求原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605765480,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257525,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1604020996,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"14488922884","product_id":100056701,"comment_content":"是不能把setnx 和 expire 命令分开的，因为无法保证两个操作执行的原子性，可能遇到各种异常，无法满足预期","like_count":3},{"had_liked":false,"id":330597,"user_name":"Geek_lijia","can_delete":false,"product_type":"c1","uid":1818163,"ip_address":"","ucode":"321E594550BDEB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLXDG2ux03bmIyEu9cR1SGX9QnDLJmSpYBg6CcfL6uUiaL90ypGIdmjXaj9uYLaxkQVoKSDeuAiaobQ/132","comment_is_top":false,"comment_ctime":1642064067,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10231998659","product_id":100056701,"comment_content":"关于分布式锁，两个大神的争论，我站Martin这边。<br>https:&#47;&#47;martin.kleppmann.com&#47;2016&#47;02&#47;08&#47;how-to-do-distributed-locking.html <br>http:&#47;&#47;antirez.com&#47;news&#47;101 ","like_count":2},{"had_liked":false,"id":341506,"user_name":"Leo","can_delete":false,"product_type":"c1","uid":2649276,"ip_address":"","ucode":"CEBAD9CDCFC2A3","user_header":"https://static001.geekbang.org/account/avatar/00/28/6c/bc/f751786b.jpg","comment_is_top":false,"comment_ctime":1649665803,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5944633099","product_id":100056701,"comment_content":"课后问题回答：<br>不可以，枷锁和给定过期时间是两个命令非原子性操作，若在加完锁后redis奔溃那么该锁永远也不会有过期时间；<br>所以建议使用指令：set key value ex|px nx；<br><br>另外：redis官方已不推荐使用redlock了！！！","like_count":1,"discussions":[{"author":{"id":1533488,"avatar":"https://static001.geekbang.org/account/avatar/00/17/66/30/c58247a3.jpg","nickname":"🍒","note":"","ucode":"89EC0E5E44F24E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":584746,"discussion_content":"请问redis官方不推荐redlock的原文章能发一下吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661078672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"江苏"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308986,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1629881951,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5924849247","product_id":100056701,"comment_content":"首先回答下这个问题,如果不保证原子性,那么实例宕机了,岂不是没有别人能拿到锁了,这是大问题<br>第二个问题,按照老师说的Redlock,达到半数以上,那么由一个问题,就是出现集群实例宕机一部分,导致其他客户端也达到了获取锁的数量(即在集群半数上加锁成功),那时候怎么办","like_count":1,"discussions":[{"author":{"id":1238374,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e5/66/a90acd8e.jpg","nickname":"薛军","note":"","ucode":"A10D80D2686A1A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571219,"discussion_content":"个人理解超半数应该是所有实例的半数，比如：\n5个实例，获取锁的顺序从1到5；\n线程A在实例123获取了锁；\n实例12挂掉；\n线程B获取锁超半数指5个实例超半数，12超时失败，3已存在，分布锁获取失败。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652144352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":304947,"user_name":"BingoJ","can_delete":false,"product_type":"c1","uid":1298126,"ip_address":"","ucode":"6160CD02AD592B","user_header":"https://static001.geekbang.org/account/avatar/00/13/ce/ce/53392e44.jpg","comment_is_top":false,"comment_ctime":1627715422,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5922682718","product_id":100056701,"comment_content":"目前这把锁还有一个问题，就是不能保证可重入","like_count":1},{"had_liked":false,"id":296771,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1623154734,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5918122030","product_id":100056701,"comment_content":"这节课，我提到，我们可以使用 SET 命令带上 NX 和 EX&#47;PX 选项进行加锁操作，那么，我想请你再思考一下，我们是否可以用下面的方式来实现加锁操作呢？<br><br><br><br>&#47;&#47; 加锁<br>SETNX lock_key unique_value<br>EXPIRE lock_key 10S<br>&#47;&#47; 业务逻辑<br>DO THINGS<br><br>答：非原子操作，所以不能用这种方式。","like_count":1},{"had_liked":false,"id":295948,"user_name":"平凡之路","can_delete":false,"product_type":"c1","uid":1669273,"ip_address":"","ucode":"96CE12339BD5FD","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/99/6060eb2d.jpg","comment_is_top":false,"comment_ctime":1622680377,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5917647673","product_id":100056701,"comment_content":"老师，您好，使用redis集群，使用setnx能保障加锁成功吗？即使一个实例挂了，还有其他实例能读取并加锁吗？","like_count":1,"discussions":[{"author":{"id":1669273,"avatar":"https://static001.geekbang.org/account/avatar/00/19/78/99/6060eb2d.jpg","nickname":"平凡之路","note":"","ucode":"96CE12339BD5FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377503,"discussion_content":"是不是就不需要redlock呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622688212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1749015,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b0/17/451cb87c.jpg","nickname":"加油！","note":"","ucode":"947E97762DB6EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":540613,"discussion_content":"集群下就必须使用redlock了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640096183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1606288,"avatar":"https://static001.geekbang.org/account/avatar/00/18/82/90/295449c4.jpg","nickname":"半生瓜。","note":"","ucode":"6D4CC445230D19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380161,"discussion_content":"你这样是由问题的。最简单的例子：A拿到锁，然后这个redis实例挂了。B同样需要请求锁的实例就会去找下一个redis实例，此时就会判断为获取锁成功，实际上A也还未释放锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624363966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257374,"user_name":"Geek_9a0c9f","can_delete":false,"product_type":"c1","uid":2159835,"ip_address":"","ucode":"2A6078F740881F","user_header":"","comment_is_top":false,"comment_ctime":1603949899,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898917195","product_id":100056701,"comment_content":"python的简单实现:<br>import threading<br>import time<br><br>import redis<br><br>redis_con = redis.StrictRedis(host=&#39;127.0.0.1&#39;, port=6379, db=0)<br><br># redis_con.ttl(&#39;name&#39;)<br>redis_con.set(&quot;global&quot;, 10)<br><br>#守护进程，用来检测时间是否到期，快到期了，就续命<br>def add_time(redis_con, key_name):<br>    while True:<br>        time = redis_con.ttl(key_name)<br>        if time == 1:<br>            print(&quot;=====&quot;)<br>            redis_con.expire(key_name, 2)<br>            print(redis_con.ttl(key_name))<br><br>def test_distribute_lock():<br>    thead_id = str(time.time())<br>    if_has_key = redis_con.setnx(&quot;lock&quot;, thead_id)<br>    try:<br>        if not if_has_key:<br>            print(&quot;等待请稍后重试&quot;)<br>        else:<br>            redis_con.expire(&#39;lock&#39;, 2)<br>            # 开启守护进程<br>            t1 = threading.Thread(target=add_time, args=(redis_con, &#39;lock&#39;))<br>            t1.setDaemon(True)<br>            t1.start()<br>            redis_con.decr(&#39;global&#39;, 1)<br>            time.sleep(2)<br>    except Exception as e:<br>        print(e)<br>    finally:<br>                 # 执行完毕，释放锁，保证每个线程只能删除自己的锁<br>        if str(redis_con.get(&quot;lock&quot;), encoding=&quot;utf-8&quot;) == thead_id:<br>            redis_con.delete(&#39;lock&#39;)<br>        redis_con.close()<br><br>if __name__ == &#39;__main__&#39;:<br>    for i in range(5):<br>        t = threading.Thread(target=test_distribute_lock)<br>        t.start()<br>        t.join()<br>    print(&quot;===&gt;&quot;)","like_count":1},{"had_liked":false,"id":257058,"user_name":"test","can_delete":false,"product_type":"c1","uid":1065849,"ip_address":"","ucode":"9A4973E591DD12","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/79/18073134.jpg","comment_is_top":false,"comment_ctime":1603846381,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5898813677","product_id":100056701,"comment_content":"不能这样做，因为两个命令就不是原子操作了。<br><br>set nx px的时候如果拿到锁的客户端在使用过程中超出了其设置的超时时间，那么就有这把锁同时被两个客户端持有的风险，所以需要在使用过程中不断去更新其过期时间。","like_count":1},{"had_liked":false,"id":360244,"user_name":"Ignite","can_delete":false,"product_type":"c1","uid":2324973,"ip_address":"浙江","ucode":"813754E25AC505","user_header":"https://static001.geekbang.org/account/avatar/00/23/79/ed/b8486f49.jpg","comment_is_top":false,"comment_ctime":1666334667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666334667","product_id":100056701,"comment_content":"https:&#47;&#47;redis.io&#47;docs&#47;reference&#47;patterns&#47;distributed-locks&#47;<br>redis官网分布式锁","like_count":0},{"had_liked":false,"id":355881,"user_name":"Geek_045c20","can_delete":false,"product_type":"c1","uid":2914350,"ip_address":"北京","ucode":"3C446088613422","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/apXvlhZqT7NLxOYz63qZzHebzCMszx3jI56gvRVeq62fX1b3zHy6fao1UknvuqfUkHkbYG0YkOBfvqXmJBxffg/132","comment_is_top":false,"comment_ctime":1661826872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1661826872","product_id":100056701,"comment_content":"客户端为什么不同时向n个redis实例发起加锁请求？必须顺序依次吗","like_count":0},{"had_liked":false,"id":353659,"user_name":"Geek_323a60","can_delete":false,"product_type":"c1","uid":2797976,"ip_address":"四川","ucode":"CDC276EC255411","user_header":"","comment_is_top":false,"comment_ctime":1659665154,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659665154","product_id":100056701,"comment_content":"有一个问题是，当释放分布式锁时，有部分实例释放失败（比如已经加锁的实例故障了），怎么办？这样下次获取分布式锁的时候能够加锁的实例越来越少，最终导致整个分布式锁不可用。","like_count":0},{"had_liked":false,"id":345480,"user_name":"随风wli","can_delete":false,"product_type":"c1","uid":1932930,"ip_address":"","ucode":"655BD9182D7570","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/OEZQyDeZd2oCPZiak19FKQOZI4I21WjLlwUgJzVFxyXsVKbIlpEEEYZcHbA4lYVzFbd3CtmDfZuUictW3ujvKnUQ/132","comment_is_top":false,"comment_ctime":1652321534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1652321534","product_id":100056701,"comment_content":"老师，请教一下，文中说的redis主备切换锁失效问题，如果是分片集群会有这个问题吗？解决办法也是Redlock算法吗","like_count":0},{"had_liked":false,"id":343663,"user_name":"Geek_0bba55","can_delete":false,"product_type":"c1","uid":2088137,"ip_address":"","ucode":"3B647E1EB3C707","user_header":"","comment_is_top":false,"comment_ctime":1650974297,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1650974297","product_id":100056701,"comment_content":"事务代码还没执行完，锁就超时过期了，怎么避免这种情况","like_count":0,"discussions":[{"author":{"id":3026383,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/2d/cf/e2e5dc4c.jpg","nickname":"你也在微信冲浪吗","note":"","ucode":"1B000D69F8BC78","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579590,"discussion_content":"看门狗机制\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657541175,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343091,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1650622059,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650622059","product_id":100056701,"comment_content":"Learning.....","like_count":0},{"had_liked":false,"id":342109,"user_name":"阿昕","can_delete":false,"product_type":"c1","uid":1012906,"ip_address":"","ucode":"F3AD093B68E074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","comment_is_top":false,"comment_ctime":1650016712,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1650016712","product_id":100056701,"comment_content":"存在setnx操作成功，expire失败的风险，此时锁将无法超时释放","like_count":0},{"had_liked":false,"id":334931,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1645187164,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645187164","product_id":100056701,"comment_content":"redis 实现锁的优势是什么？  etcd 也支持了， 是因为redis 性能更高？","like_count":0},{"had_liked":false,"id":334930,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1645187135,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1645187135","product_id":100056701,"comment_content":"主从模式， 如果用 WAIT 指令，也可以用单机版本的方式实现可靠的锁吧？","like_count":0},{"had_liked":false,"id":333038,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1644020678,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644020678","product_id":100056701,"comment_content":"本质上就是原子性加锁，然后防止单点要达到redis集群一半以上有效","like_count":0},{"had_liked":false,"id":323244,"user_name":"InfoQ_小汤","can_delete":false,"product_type":"c1","uid":1739070,"ip_address":"","ucode":"E4C30DB7A9B54C","user_header":"https://static001.geekbang.org/account/avatar/00/1a/89/3e/0dd8e96b.jpg","comment_is_top":false,"comment_ctime":1637800427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637800427","product_id":100056701,"comment_content":"在 Redlock 算法中，释放锁的操作和在单实例上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。这样一来，只要 N 个 Redis 实例中的半数以上实例能正常工作，就能保证分布式锁的正常工作了。<br>————————————-<br>老师可以说下具体删除的情况么？ 是针对已加锁的半数以上redis删除还是分片集群的所有redis","like_count":0},{"had_liked":false,"id":321413,"user_name":"adrian_xia","can_delete":false,"product_type":"c1","uid":1101454,"ip_address":"","ucode":"957C329EAFD31C","user_header":"https://static001.geekbang.org/account/avatar/00/10/ce/8e/204736bb.jpg","comment_is_top":false,"comment_ctime":1636859926,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636859926","product_id":100056701,"comment_content":"也能够实现，会复杂很多<br>需要在value中增加过期时间的标识<br>若是没有释放锁的话，还需要判断value内的时间戳是否过期","like_count":0},{"had_liked":false,"id":318301,"user_name":"A梦多啦A","can_delete":false,"product_type":"c1","uid":1018224,"ip_address":"","ucode":"026669D6CACA8A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/70/f5845602.jpg","comment_is_top":false,"comment_ctime":1635236132,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1635236132","product_id":100056701,"comment_content":"1. 使用set key value px xxx nx可以解决设置键时的原子性。<br><br>2. 使用lua可以解决删除key时的原子性。<br><br>3. 使用redlock可以解决单节点，出现Redis实例宕机的清空。<br><br>4. 这里有个疑问，如何去避免锁超时呢？业务还没处理完，锁就过期了，总不能完全靠给锁设置一个很长的时间把。","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409695,"discussion_content":"可以参考redission的实现，设置一个看门狗，定时续期","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635491606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311114,"user_name":"郑印","can_delete":false,"product_type":"c1","uid":1005282,"ip_address":"","ucode":"181B0FDE5E1532","user_header":"https://static001.geekbang.org/account/avatar/00/0f/56/e2/2dcab30d.jpg","comment_is_top":false,"comment_ctime":1631074259,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1631074259","product_id":100056701,"comment_content":"我理解Redlock 这种算法应该只应用在多实例但非集群（此时是在客户端程序控制分片逻辑）的情况下吧？ 集群本身已经有了高可用的保证，因此按照单节点的加锁方式操作就可以了。请问是否理解正确。","like_count":0,"discussions":[{"author":{"id":2549905,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e8/91/7e69edfe.jpg","nickname":"。。。","note":"","ucode":"37B0B5166EB853","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":406790,"discussion_content":"不是哦，主加锁成功那一瞬间，然后主立刻跪了，但是还没来得及同步从，然后就重新选主出来了，这个锁就丢了。我觉得用这种一致性很难保证的系统搞这种有点蛋疼啊。直接上zk多好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634830193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303179,"user_name":"Geek_frank","can_delete":false,"product_type":"c1","uid":1685433,"ip_address":"","ucode":"534D46C2D1EFF5","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erG6I79WlHDjs51JOff9GBibD4Fh2PhITQMvmh2aTUVzH2BKia1tFLLoQr7VFeZddywwRoZlVUyhDDQ/132","comment_is_top":false,"comment_ctime":1626655219,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1626655219","product_id":100056701,"comment_content":"给分布式锁加过期时间是个很有讲究的东西。因为客户端有可能在获取锁之后释放锁之前而自己的业务逻辑并没有完成。这不是没有可能因为整体业务逻辑处理时间可能收到其它方方面面的影响。而如果业务逻辑没有处理完分布式锁就释放了那么其他业务线程就会获得锁而执行其他的业务。这样有可能使业务错乱，有期是某个时间段这种形象频繁发生的情况会对系统造成很大的伤害。这里需要考虑客户端对锁续期的问题。客户端要拥有对分布式锁自动续期的能力。但也不能无限续期。需要考虑对于锁独占的问题。当续期一定次数后不再续期","like_count":0,"discussions":[{"author":{"id":1010192,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6a/10/4d2d6e64.jpg","nickname":"劳动维权","note":"","ucode":"1D5CEB96618E01","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387938,"discussion_content":"redisson看门狗机制了解一下","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628503267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":297330,"user_name":"talentu","can_delete":false,"product_type":"c1","uid":2108544,"ip_address":"","ucode":"CF3FE739B6FC6C","user_header":"","comment_is_top":false,"comment_ctime":1623463842,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1623463842","product_id":100056701,"comment_content":"文中，因为 Redis 使用单线程处理请求，所以，即使客户端 A 和 C 同时把加锁请求发给了 Redis，Redis 也会串行处理它们的请求。后面又说多个操作要保证原子操作。我想问的是，既然是单线程处理，还要保证啥原子操作。。实在看不懂","like_count":0,"discussions":[{"author":{"id":1606288,"avatar":"https://static001.geekbang.org/account/avatar/00/18/82/90/295449c4.jpg","nickname":"半生瓜。","note":"","ucode":"6D4CC445230D19","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380163,"discussion_content":"对于redis，读（get） 和写（set）都是原子操作。后面指的是利用redis命令原子性的特点，实现分布式锁。简单的理解就是：你读的出来的值是最新的，但不保证读完过了一段时间还是最新的。所以“读“+“判断”+“写”这组合操作是要原子的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624364516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":295947,"user_name":"平凡之路","can_delete":false,"product_type":"c1","uid":1669273,"ip_address":"","ucode":"96CE12339BD5FD","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/99/6060eb2d.jpg","comment_is_top":false,"comment_ctime":1622680182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622680182","product_id":100056701,"comment_content":"老师，您好，使用redis集群，使用setnx能保障加锁成功吗？","like_count":0},{"had_liked":false,"id":292512,"user_name":"CrazyCodes","can_delete":false,"product_type":"c1","uid":1081205,"ip_address":"","ucode":"C9C0E72522EB5B","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/75/551c5d6c.jpg","comment_is_top":false,"comment_ctime":1620867484,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620867484","product_id":100056701,"comment_content":"如何正确统计成功上锁的实例数量呢？","like_count":0},{"had_liked":false,"id":290905,"user_name":"于那山","can_delete":false,"product_type":"c1","uid":1172834,"ip_address":"","ucode":"A790DC5EA0A180","user_header":"https://static001.geekbang.org/account/avatar/00/11/e5/62/15f26d68.jpg","comment_is_top":false,"comment_ctime":1619845542,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619845542","product_id":100056701,"comment_content":"请教个问题：客户端A成功获取锁，锁有效期10秒，正常情况下客户端A执行业务逻辑需要2秒，之后释放锁。异常情况下，客户端A业务处理超过了锁的有效期10秒，此时，锁被自动释放，客户端B成功获取到锁？","like_count":0},{"had_liked":false,"id":290398,"user_name":"老大不小","can_delete":false,"product_type":"c1","uid":1295609,"ip_address":"","ucode":"35BCDD3CB13467","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJRFRX8kNzNet7FibNvtavbVpAwK09AhIhrib9k762qWtH6mre8ickP7hM5mgZC4ytr8NnmIfmAhxMSQ/132","comment_is_top":false,"comment_ctime":1619525668,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619525668","product_id":100056701,"comment_content":"老师，请教下，为什么释放锁要原子性呢？不原子性可以吗？<br>读和修改的时候，此时lock_key不等于0，这个时候即使并发，其他线程也取不到锁。在写回的一瞬间，其他线程读到的也是旧值。<br>整个分析下来，并不会产生业务影响。","like_count":0,"discussions":[{"author":{"id":2064446,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/iaVVR5jJuhnNhZ0dcxiclPOsLYYEfEickmiavJCBbsqVkOeBj1WN1hBQKPTkictv58RcbYPswQURDtUKZ1u5pFbnaPg/132","nickname":"Geek_729ab3","note":"","ucode":"8F9BCDFBF2DEC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":403564,"discussion_content":"我觉得可以考虑这么一种情况，如果读操作后并且正确判断是当前客户端了，可是在这时候客户端阻塞了（没有执行接下来的释放锁操作），由锁到期服务器自动回收锁，这时其余客户端就能申请锁使用了，当被阻塞的客户端能继续运行（执行释放锁操作）就会把其他客户端上的锁给释放掉了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634109778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288956,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1618798582,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618798582","product_id":100056701,"comment_content":"通常所说的setnx命令，并非单指redis的setnx key value这条命令。一般是指redis中对set命令加上nx参数， set这个命令，支持的参数<br>set key value [expiration EX seconds|PX milliseconds] [NX|XX]","like_count":0},{"had_liked":false,"id":288769,"user_name":"户有福","can_delete":false,"product_type":"c1","uid":1481937,"ip_address":"","ucode":"664124BD48E09D","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/d1/ca72f97e.jpg","comment_is_top":false,"comment_ctime":1618662925,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618662925","product_id":100056701,"comment_content":"红锁也是有问题啊，红锁的npc问题还是没有解决","like_count":0},{"had_liked":false,"id":288355,"user_name":"藏锋","can_delete":false,"product_type":"c1","uid":1175246,"ip_address":"","ucode":"D5F811B16725A0","user_header":"https://static001.geekbang.org/account/avatar/00/11/ee/ce/c024a857.jpg","comment_is_top":false,"comment_ctime":1618419174,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618419174","product_id":100056701,"comment_content":"setnx和expire不能分来，必须保证这两个操作的原子性，一旦分开，就有可能出现setnx成功，但是expire失败，这样锁就永远得不到释放。如果并发不高在单机redis能够承受的范围内，还是推荐redis,毕竟无论是开发成本还是运维成本都相对较低一些，如果单机无法承受，可以选择使用etcd分布式锁的方案，无论是从开发成本还是运维成本来说,etcd的分布式锁方案都比redlock要好","like_count":0},{"had_liked":false,"id":287333,"user_name":"朱庆龙","can_delete":false,"product_type":"c1","uid":2452377,"ip_address":"","ucode":"9E0F5B2AA013AF","user_header":"","comment_is_top":false,"comment_ctime":1617886739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617886739","product_id":100056701,"comment_content":"思考题：如果只考虑方法可不可行的话，<br>SETNX lock_key unique_value   <br>EXPIRE lock_key 10S<br>将setnx命令与expire命令放到Lua脚本中执行，也是可以保证原子性的","like_count":0},{"had_liked":false,"id":286294,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1617244103,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1617244103","product_id":100056701,"comment_content":"看完本文，觉得 Redis 其实挺适合用来设置分布式锁的，主要就是因为 Redis 的读写比较快。<br><br>单个 Redis 实例使用 SETNX 配合过期时间加锁，使用 Lua 脚本解锁，应该就能满足普通应用的需要了。<br><br>而 RedLock 其实是在单实例 Redis 锁的基础上，增加了半数以上的限制，有点 quorum 的意思。<br><br>对于课后题，我觉的应该是不行的。<br><br>一方面，对于 SETNX 的返回值没有判断，如果加锁 SETNX 就失败了怎么处理？<br><br>另一方面，过期时间设置为 10s 未必合适，一般来说可能是过长了，也可能太短。<br><br>看完课代表的答案，我知道自己又想歪了。课后题中的加锁代码，主要的问题在于不是原子的，如果客户端执行完 SETNX 后崩溃了，就没有机会执行 EXPIRE 了。<br><br>顺着课代表给出的链接，看了《基于Redis的分布式锁到底安全吗》，其中的分析确实精彩，而且还给出了不少有价值的链接，如果以后有机会做分布式的工作，应该会来重读。其中，关于 RedLock 的争论感觉像是在看高手对决，胜负并不重要。","like_count":0},{"had_liked":false,"id":279424,"user_name":"Just Do IT","can_delete":false,"product_type":"c1","uid":1192724,"ip_address":"","ucode":"1EAD92510FA7BE","user_header":"https://static001.geekbang.org/account/avatar/00/12/33/14/78104f1f.jpg","comment_is_top":false,"comment_ctime":1613784017,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1613784017","product_id":100056701,"comment_content":"释放锁为何要保证原子性？ 此时只有单个线程拿到了锁，不可能出现并发释放的情况吧？","like_count":0,"discussions":[{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356190,"discussion_content":"如果这个线程业务逻辑很耗时，超过了锁的过期时间，此时另外的线程就可以拿到锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615548506,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2128592,"avatar":"","nickname":"Geek_b60d95","note":"","ucode":"AB1889DDB2C088","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368455,"discussion_content":"超过锁的过期时间不就会自动释放吗？这跟释放锁要保证原子性有什么关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618717992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":356190,"ip_address":""},"score":368455,"extra":""},{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":2128592,"avatar":"","nickname":"Geek_b60d95","note":"","ucode":"AB1889DDB2C088","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409706,"discussion_content":"考虑这个流程：线程1检查锁（锁存在且是线程1的锁）-> 锁过期，被线程2拿到并加锁 -> 线程1把线程2的锁释放；；所以这里第一步和第三步要保证原子性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1635493052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":368455,"ip_address":""},"score":409706,"extra":""}]}]},{"had_liked":false,"id":278075,"user_name":"Geek_89e362","can_delete":false,"product_type":"c1","uid":2308075,"ip_address":"","ucode":"E596C2CFE1CFAF","user_header":"","comment_is_top":false,"comment_ctime":1612751291,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612751291","product_id":100056701,"comment_content":"不可以， SETNX lock_key unique_value  和 EXPIRE lock_key 10S 两个操作分开，可能会存在 线程A 调用了 sentnx 命令，就切换到 线程B 执行了 SETNX lock_key unique_value  和 EXPIRE lock_key 10S 操作，虽然 线程B执行 setnx 命令失败，但是 expire 命令会成功，这样可能导致，线程A 还没有执行锁已经过期了，另一个线程又获取了锁。","like_count":0},{"had_liked":false,"id":277835,"user_name":"我的喵","can_delete":false,"product_type":"c1","uid":1736650,"ip_address":"","ucode":"A7435BDBDD2587","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyuuhxu0HH4cIKCClCqx0LTurCCYWmNcFwfTWV5te5afsibp2yuDmC9mibEHx0Xy8QlvqvMWWcAib8g/132","comment_is_top":false,"comment_ctime":1612614063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612614063","product_id":100056701,"comment_content":"对于单实例实现分布式锁时应该还要注意一点：当业务时间执行时间较长导致超出了锁过期时间，这种情况也会引发问题。解决方案就是锁续命","like_count":0},{"had_liked":false,"id":274440,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1611022275,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1611022275","product_id":100056701,"comment_content":"我们可以使用 SET 命令带上 NX 和 EX&#47;PX 选项进行加锁操作，那么，我想请你再思考一下，我们是否可以用下面的方式来实现加锁操作呢？<br>这种方式是非原子性操作，存在加锁后永远不能释放情况，若客户端运行了set后，在没有运行expire前宕机了，这时锁没有过期时间，所以会存在一直释放不了的情况。","like_count":0},{"had_liked":false,"id":271617,"user_name":"小超人","can_delete":false,"product_type":"c1","uid":1411096,"ip_address":"","ucode":"0D8A433F3E3737","user_header":"https://static001.geekbang.org/account/avatar/00/15/88/18/9744d5ec.jpg","comment_is_top":false,"comment_ctime":1609734376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609734376","product_id":100056701,"comment_content":"如果 SETNX 命令和 EXPIRE 命令都能成功执行， 那么大家都欢喜没有什么问题， 但是， 如果 SETNX 命令执行完之后， Redis 客户端崩溃， 那么 lock_key 就一直会被保持(也不会因为超时而自动过期)， 并且没有人工干预下都解不了锁。","like_count":0},{"had_liked":false,"id":268977,"user_name":"谷大羽","can_delete":false,"product_type":"c1","uid":1434140,"ip_address":"","ucode":"D291EECC8DECA5","user_header":"https://static001.geekbang.org/account/avatar/00/15/e2/1c/5e375ad1.jpg","comment_is_top":false,"comment_ctime":1608454737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608454737","product_id":100056701,"comment_content":"不能，两个操作单独执行的时候是原子性操作，但是放在一起就是出现问题，如果SETNX命令执行成功之后，EXPIRE命令执行失败，那这个锁就会死锁","like_count":0},{"had_liked":false,"id":267175,"user_name":"飞机翅膀上","can_delete":false,"product_type":"c1","uid":1515223,"ip_address":"","ucode":"D239DFFECDBF01","user_header":"https://static001.geekbang.org/account/avatar/00/17/1e/d7/7d28a531.jpg","comment_is_top":false,"comment_ctime":1607619764,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1607619764","product_id":100056701,"comment_content":"请问老师可以 set 集合实现分布式锁吗？","like_count":0},{"had_liked":false,"id":265960,"user_name":"Geek_f6a7c7","can_delete":false,"product_type":"c1","uid":2342029,"ip_address":"","ucode":"3927E94C25A552","user_header":"","comment_is_top":false,"comment_ctime":1607076765,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1607076765","product_id":100056701,"comment_content":"老师，RedLock只是多节点加锁，有两个问题，Q1: key经过算法%16384,都会具体到某一个哈希槽，具体到某一个节点，怎么在过半的节点上设置值？Q2: 不管主从集群，还是分片集群都有slave机，数据通过是通过rdb异步发送，肯定有一定的滞后性，高并发的时候又不能全怼到master，查slave又可能没数据还没同步?","like_count":0,"discussions":[{"author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339823,"discussion_content":"redlock是多实例不是多节点","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609816250,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265839,"user_name":"Geek_63b322","can_delete":false,"product_type":"c1","uid":2288904,"ip_address":"","ucode":"59BF3E12C13506","user_header":"","comment_is_top":false,"comment_ctime":1607049081,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1607049081","product_id":100056701,"comment_content":"1.  如果有5个独立的redis实例 r1,r2,r3,r4,r5, 原来客户端a加锁lock, 这时候有r1,r2,r3加锁成功了, 接着执行业务. 这时候, 如果这r1,r2的实例挂了. <br><br>2. 客户端b就去加锁lock, 刚好r4,r5加锁成功了, 这个时候, 是算客户端b加锁成功了还是没有成功呢?","like_count":0,"discussions":[{"author":{"id":1104100,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d8/e4/7cc47d20.jpg","nickname":"Alexander","note":"","ucode":"5EF394E93A1715","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339658,"discussion_content":"好问题，我理解2里面，应该是加锁失败了，集群实例个数是5个，2/5 < 0.5，所以算失败，这种情况集群本身已经不可靠了，应该先恢复集群","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609753607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":265554,"user_name":"Geek_51cc93","can_delete":false,"product_type":"c1","uid":1508662,"ip_address":"","ucode":"DB1588A47E8B32","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqic8BwOdWJDVBy2H7X7N77ha6mm2kkJOaBqqcSBfphhTYv16KKuhBicN08pAxYmShTJYKMMwrDs6iaw/132","comment_is_top":false,"comment_ctime":1606929534,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606929534","product_id":100056701,"comment_content":"删除锁的时候为什么要保证原子性？   不保证不能出什么问题？","like_count":0,"discussions":[{"author":{"id":1477612,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","nickname":"张天屹","note":"","ucode":"8BD6BD6DCF0F4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344481,"discussion_content":"你看上面Lua脚本，主要是判断了是否当前客户端ID，避免删错了锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611475051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263723,"user_name":"cxdhjx","can_delete":false,"product_type":"c1","uid":2292690,"ip_address":"","ucode":"FF13B4B75611C3","user_header":"","comment_is_top":false,"comment_ctime":1606232157,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606232157","product_id":100056701,"comment_content":"如果A客户端使用 SETNX + EXPIRE  完成了加锁，然后A客户端操作共享变量缓慢，一直没有调用释放锁的操作，随着时间推移 ，当超过 EXPIRE  时间后，redis 自动释放 LOCKKEY ,此时 B客户端进来加锁成功，并操作共享变量，这个时候将会导致数据混乱，请问有没有解决方案？","like_count":0,"discussions":[{"author":{"id":2253496,"avatar":"","nickname":"Geek_3d87cb","note":"","ucode":"F09334D60C3BC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339824,"discussion_content":"reddison有watch dog机制,可以实现锁续期","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609816300,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263192,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1606039226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606039226","product_id":100056701,"comment_content":"能否采用“SETNX + EXPIRE”实现分布式锁，就要看异常的发生点，如：Expire设置失败<br>显然在Expire设置失败的情况下，会导致分布式锁无法释放<br><br>","like_count":0},{"had_liked":false,"id":258461,"user_name":"唐朝首都","can_delete":false,"product_type":"c1","uid":1081233,"ip_address":"","ucode":"F72655AE0AE4CA","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/91/962eba1a.jpg","comment_is_top":false,"comment_ctime":1604452234,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604452234","product_id":100056701,"comment_content":"不可以。<br>两个命令之间无法保证原子性，在第二个命令执行时，客户端或者Redis出现问题，均会导致异常情况出现。","like_count":0},{"had_liked":false,"id":258142,"user_name":"liaomars","can_delete":false,"product_type":"c1","uid":2104856,"ip_address":"","ucode":"4FCA97EE9FB57D","user_header":"https://static001.geekbang.org/account/avatar/00/20/1e/18/9d1f1439.jpg","comment_is_top":false,"comment_ctime":1604310521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604310521","product_id":100056701,"comment_content":"不能，因为加锁和设置过期时间是两步操作了，没有满足加锁的原子性操作。","like_count":0},{"had_liked":false,"id":257879,"user_name":"那个谁","can_delete":false,"product_type":"c1","uid":1118325,"ip_address":"","ucode":"43214CAE7062E7","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/75/ff76024c.jpg","comment_is_top":false,"comment_ctime":1604188522,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1604188522","product_id":100056701,"comment_content":"全篇有个疑问，Redis怎么保证锁的过期时间够客户端用，也就是说怎么避免拿到锁后，预设的读写逻辑还没执行完？拿到锁后，每次执行业务逻辑后再重设过期时间？","like_count":0,"discussions":[{"author":{"id":1442588,"avatar":"https://static001.geekbang.org/account/avatar/00/16/03/1c/c9fe6738.jpg","nickname":"Kvicii.Y","note":"","ucode":"446BFA633569EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320872,"discussion_content":"同问，redission有watch dog续租，但是redis原生似乎没有解决方案？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604495219,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257583,"user_name":"xuanyuan","can_delete":false,"product_type":"c1","uid":1113737,"ip_address":"","ucode":"1EC79B9372868F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI2icbib62icXtibTkThtyRksbuJLoTLMts7zook2S30MiaBtbz0f5JskwYicwqXkhpYfvCpuYkcvPTibEaQ/132","comment_is_top":false,"comment_ctime":1604034070,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604034070","product_id":100056701,"comment_content":"实践中有人用redlock么？用redlock一定会导致吞吐量下降，此时与etcd，zk比还有优势么？<br>实践中不同场景下，那种方式用的更多？","like_count":0},{"had_liked":false,"id":257195,"user_name":"小鹿","can_delete":false,"product_type":"c1","uid":1240804,"ip_address":"","ucode":"7357FC99325FCB","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/e4/7f9233d2.jpg","comment_is_top":false,"comment_ctime":1603878314,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603878314","product_id":100056701,"comment_content":"Redlock 里面的redis所有实例是所有master机器吗，如果是的话，同样的key怎么写入到所有master，key哈希完只会写入到一个master上，这点我不太明白。","like_count":0,"discussions":[{"author":{"id":1336009,"avatar":"https://static001.geekbang.org/account/avatar/00/14/62/c9/7da27891.jpg","nickname":"DKSky","note":"","ucode":"69371A81033949","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318983,"discussion_content":"多个独立的redis实例","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603895962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257117,"user_name":"林肯","can_delete":false,"product_type":"c1","uid":1008582,"ip_address":"","ucode":"D2C97220230DE5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","comment_is_top":false,"comment_ctime":1603853766,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1603853766","product_id":100056701,"comment_content":"<br>&#47;&#47; 加锁, unique_value作为客户端唯一性的标识<br>SET lock_key unique_value NX PX 10000<br>每个客户端的key都不一样，那还怎么加锁呢？加锁都本质就是多个客户端操作同一个共享变量啊？","like_count":0,"discussions":[{"author":{"id":2120877,"avatar":"https://static001.geekbang.org/account/avatar/00/20/5c/ad/3934e3cc.jpg","nickname":"新年快乐啊","note":"","ucode":"50811438BFAFA5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320470,"discussion_content":"加锁的key都是一样，只是这个key对应的值不是0和1，而是每个客户端的唯一标识，是这个意思吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604375236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1327973,"avatar":"https://static001.geekbang.org/account/avatar/00/14/43/65/e15e19fe.jpg","nickname":"zeroHumor","note":"","ucode":"C85CDA2786143E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319004,"discussion_content":"这里的lock_key都一样，只是unique_value作为客户端的唯一标识不一样吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603902045,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257111,"user_name":"小狼","can_delete":false,"product_type":"c1","uid":1033425,"ip_address":"","ucode":"FEAC7864FC1D20","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c4/d1/209abdd6.jpg","comment_is_top":false,"comment_ctime":1603852802,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603852802","product_id":100056701,"comment_content":"如果用 Lua 脚本来使用上述两条命令，可以保证原子性操作，进而也就可以通过使用上述两条命令来实现分布式锁；只是，这种方式的调用成本显然比单独的 setnx 命令成本要高","like_count":0},{"had_liked":false,"id":257107,"user_name":"杨逸林","can_delete":false,"product_type":"c1","uid":1167233,"ip_address":"","ucode":"4BF3CF3E2F1AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","comment_is_top":false,"comment_ctime":1603852671,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603852671","product_id":100056701,"comment_content":"针对这个问题，一个有效的解决方法是，给锁变量设置一个过期时间。<br>有一种情况，假如 A 系统获得了锁，设置了过期时间为 5s。假如 A 系统执行了一个比较慢的操作，费时 6s，刚好在 5-6s 之间，有个 B 系统看没有人创建键值对，然后也获得了锁。这种情况怎么办","like_count":0,"discussions":[{"author":{"id":2159835,"avatar":"","nickname":"Geek_9a0c9f","note":"","ucode":"2A6078F740881F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319125,"discussion_content":"可以给A加个守护进程，用于键值续命，如果发现还剩一秒发现A的操作还没执行完，就继续给键值重新设置过期时间。直到执行完毕。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603949293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257083,"user_name":"番茄smd","can_delete":false,"product_type":"c1","uid":2104906,"ip_address":"","ucode":"E9B52E7DC18CEF","user_header":"https://static001.geekbang.org/account/avatar/00/20/1e/4a/6d417808.jpg","comment_is_top":false,"comment_ctime":1603849283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603849283","product_id":100056701,"comment_content":"不知道后面会不会讲解redisson","like_count":0},{"had_liked":false,"id":257070,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1603847423,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603847423","product_id":100056701,"comment_content":"SETNX lock_key unique_value<br>EXPIRE lock_key 10S<br>这是两条命令操作，不能保证原子性了","like_count":0},{"had_liked":false,"id":257054,"user_name":"写点啥呢","can_delete":false,"product_type":"c1","uid":1065272,"ip_address":"","ucode":"C19032CF1C41BA","user_header":"https://static001.geekbang.org/account/avatar/00/10/41/38/4f89095b.jpg","comment_is_top":false,"comment_ctime":1603845941,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603845941","product_id":100056701,"comment_content":"请问老师，redis分布式锁有没有提供加锁失败-&gt;进程挂起-&gt;锁释放唤醒挂起进程的方案，避免SETNX失败后进程自旋。","like_count":0},{"had_liked":false,"id":257048,"user_name":"oops","can_delete":false,"product_type":"c1","uid":1102831,"ip_address":"","ucode":"1DEC23A503F8A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/ef/9c5e695b.jpg","comment_is_top":false,"comment_ctime":1603844972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603844972","product_id":100056701,"comment_content":"不能，2个命令没法保证原子性","like_count":0}]}