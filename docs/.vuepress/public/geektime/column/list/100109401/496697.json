{"id":496697,"title":"05｜TDD中的测试（1）：状态验证为什么是主要的使用方式？","content":"<p>你好，我是徐昊。从这节课开始我们来正式学习测试驱动开发（Test-Driven Development，TDD）。</p><p>通过前面四节课的演示，相信你对测试驱动开发已经有了一定的感性认识。测试作为整个流程的驱动力，无论是在开发还是重构过程中都起到了重要作用。我想你对这一点一定有了比较深刻的印象。那么从今天开始，我们就来学习如何编写测试。</p><h2>测试的基本结构</h2><p>无论使用什么样的测试框架，每个测试都由四个依次执行的阶段组成：初始化（SetUp）、执行测试（Exercise）、验证结果（Verify）和复原（Teardown）。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e2/5b/e29e68c4591eb41469ba0bf57a14d05b.jpg?wh=2258x1247\" alt=\"\"></p><p>需要说明一下的是，测试上下文（Test Context）在很多文献中被称作测试夹具（Test Fixture）。</p><p>夹具是个隐喻，是木工或者其他制造过程中，用以固定待加工工件的器具（上图中，棕色部分看起来是不是“夹”住了待测系统）。当然，这种拿一个生僻概念来隐喻另一个生僻概念的操作，也是很迷了。我要不是因为做吉他学习了木工，也不明白为什么要叫Fixture。抛开这个隐喻，直接称作测试上下文其实就简单易懂多了。</p><p>再多说一句，如果使用<a href=\"https://en.wikipedia.org/wiki/Framework_for_integrated_test\">Fit</a>系自动化测试工具（Fit、Fitness，甚至concordion、selenium），Fixture则表示驱动待测系统的交互接口，也叫Driver。这也是为啥，Selenium后来改叫WebDriver的原因。</p><!-- [[[read_end]]] --><p>言归正传，这四个阶段的主要作用是：</p><ul>\n<li><strong>初始化。</strong>主要是设置测试上下文，从而使待测系统（System Under Test）处于可测试的状态。例如，对于需要操作数据库的后台系统，测试上下文包含了已经灌注测试数据的测试用数据库，并将其与待测系统连接。</li>\n<li><strong>执行测试。</strong>就是按照测试脚本的描述与待测系统互动。例如，按照功能描述，通过API对系统进行相应的操作。</li>\n<li><strong>验证结果。</strong>就是验证待测系统是否处于我们期待的状态中。例如，经过测试，数据库中的业务数据是否发生了期待中的改变。</li>\n<li><strong>复原。</strong>就是将测试上下文、待测系统复原回测试之前的状态，或者消除测试对于待测系统的副作用。例如，删除测试数据中的数据（通常是通过事务回滚）。</li>\n</ul><p>接下来，看一看前四节课演示的测试中，这四步都是如何实现的：</p><h5><video poster=\"https://static001.geekbang.org/resource/image/88/bf/887cd9785160451ba17fce89484e6abf.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/31a7560f-17fa5eb9404-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/67a60446ed6744cc97d5ed8401e16aa4/2cf13f904218489f960934637266830a-1697ba1c28a3f9b5706adfb183a14bb5-sd.m3u8\" type=\"application/x-mpegURL\"></video></h5><p>需要说明的是，在参数解析这个例子中，待测系统是命令行参数解析的Java类库（Java Library），并不涉及数据库、消息中间件、三方服务等进程外组件，也没有进程内三方组件依赖（比如OSGi Runtime、Servlet容器），因而测试上下文相对简单。而对于存在进程外组件或进程内三方组件依赖的场景，<strong>测试上下文的设置将直接影响编写测试的难度，以及维护测试的成本</strong>。</p><p>在测试的四个步骤中，<strong>验证结果是最核心的一步，也是最核心的技术</strong>。验证结果有两种方式：状态验证（State Verification）和行为验证（Behavior Verification）。</p><h2>状态验证</h2><p>状态验证是指在与待测系统交互后，通过比对测试上下文与待测系统的状态变化，判断待测系统是否满足需求的验证方式。在前四节课的演示中，全部测试都采用了状态验证的方式：</p><p><video poster=\"https://static001.geekbang.org/resource/image/88/bf/887cd9785160451ba17fce89484e6abf.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4a2350af-17fa5eb9139-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/3c0f0a4d7e9441d3be9e259830442602/e638a956bdf84853b5f2ec805dd74ba3-23e485db3f6f5c7fab0c8e3c29e4f593-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>状态验证是一种<strong>黑盒验证</strong>，它将<strong>测试上下文与待测系统当作一个整体</strong>。当待测系统不存在内部状态，而通过作用于依赖组件（Depended On Component）达成功能的时候，我们会从依赖组件中获取状态，以验证待测系统。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/02/d9/0231f74e7cc0e10447f50dca7643f7d9.jpg?wh=2247x1227\" alt=\"\"></p><p>让我们回忆一下开篇词中“测试应用”的例子。其中StudentRepository自身不具有内部状态，而是通过EntityManager操纵数据库来完成功能。如果以TDD的方式来构造对于StudentRepository的测试，就会是这样的：</p><p><video poster=\"https://static001.geekbang.org/resource/image/88/bf/887cd9785160451ba17fce89484e6abf.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/644837-17fabec9ebf-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/3b4ffb69d4d64780a12215ecfea3ee6c/153f585705df422db144d1f6fd0f9ddd-14f125530d813582306920b056e87f9c-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>状态验证的一个难点是复原测试上下文，消除因执行测试造成的状态累积。如果待测系统是类库，一般问题不大，重新构造新的对象实例就行了。</p><p>而对于测试环境中存在进程外组件的情况，问题就要复杂一些了。在这种情况下，<strong>增量状态验证</strong>（Delta Verification）是一种有效的手段：</p><p><video poster=\"https://static001.geekbang.org/resource/image/88/bf/887cd9785160451ba17fce89484e6abf.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/4e88cccc-17fa5eb8e43-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/c0969fc04a8047a2bcbaa948971d9202/75f559efb0b24ed080702b84e4211bc6-e0f19b6f89c229780d5dee1eeeaff273-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>当然，在这个例子里，在每一个测试复原时，都使用了“drop-and-create”来清除数据库中的数据，从而消除状态累积。但如果因为种种原因（比如测试数据量很大），使得每次清除测试数据都变得不现实时，就可以使用增量状态验证来降低状态累积的影响。</p><h2>小结</h2><p>今天我们介绍了测试的基本结构，这个结构也叫<strong>四阶段测试（Four-Phase Test）。</strong>四阶段测试作为测试的基本模型，存在于各种测试框架中。而对于四阶段不同的组织方式，也构成了不同的测试编写风格，比如RSpec、ScalaTest等框架提供的BDD风格。不过无论是哪种风格，都不影响我们按照四阶段来理解测试的执行。</p><p>在四阶段中，验证结果是最核心的一步。它主要有状态验证和行为验证两种方式，其中状态验证需要大量使用<strong>断言方法</strong>（Assertation Method）来判断状态。同样，每个框架都提供了大量的断言方法，这里请参看具体框架的文档。</p><p>虽然状态验证是TDD中最重要的验证方法，但在某些情况下，我们仍然需要使用另一种验证方式——行为验证。这个我们将在下节课进行详细讲解。</p><h2>思考题</h2><p>为什么TDD中主要使用状态验证来验证测试的结果？</p><p><strong>编辑来信</strong>：</p><blockquote>\n<p>TDD是一项技能，唯有动手实操、反复练习，才能有所小成。为了帮助你更快地进步，徐昊老师特发起了<strong>“TDD专栏首发·代码评点”</strong>活动。<br>\n<strong>　</strong><br>\n在第一个实战项目结束后，我们会根据你提交的<a href=\"https://jinshuju.net/f/TvdN15\">学习反馈</a>，手动选出其中几位进行代码评点与解疑答惑。而评点的详细内容我们也将制成加餐，展示在专栏里，供其他同学学习与参考。<br>\n<strong>　</strong><br>\n划重点！如果学完第1-10讲再写反馈，将会大大提高你入选的机会！另，此次收集时间截至4月3日零点。所以非常希望你能跟上我们的更新进度，多动手实操，并记录学习体会。<br>\n<strong>　</strong><br>\n最后，希望我们都能好好学习，更上层楼！</p>\n</blockquote>","neighbors":{"left":{"article_title":"04｜TDD演示（4）：实现对于列表参数的支持","id":494604},"right":{"article_title":"06｜TDD中的测试（2）：行为验证为什么应该尽量避免使用？","id":496698}},"comments":[{"had_liked":false,"id":340615,"user_name":"asusual","can_delete":false,"product_type":"c1","uid":2735468,"ip_address":"","ucode":"AF9AA546D3794F","user_header":"https://static001.geekbang.org/account/avatar/00/29/bd/6c/a988846d.jpg","comment_is_top":false,"comment_ctime":1648974038,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10238908630","product_id":100109401,"comment_content":"为什么 TDD 中主要使用状态验证来验证测试的结果？<br>TDD的主要核心在于tasking, tasking后的任务列表一定是一个具体且可验证的的行为。<br>e.g <br>用户可以使用<br>   用户名: some-user<br>   用户密码:some-password<br>成功登录系统<br>输入确定,输出必然确定<br>我们只需要关心测试输入与输出(黑盒测试),也就是说不需要关心如何实现<br>一旦我们切换到行为验证(相当于白盒测试),关注点从验证输入和输出结果转换到验证具体实现行为<br>假设我们需要切换到另外一种实现行为，单元测试也需要重新修改, 有点像“实现驱动测试”,最终导致变更成本提高<br>","like_count":2},{"had_liked":false,"id":341325,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1649521270,"is_pvip":false,"replies":[{"id":"124759","content":"那为什不改进","user_name":"作者回复","comment_id":341325,"uid":"2537798","ip_address":"","utype":1,"ctime":1649551437,"user_name_real":"编辑"}],"discussion_count":2,"race_medal":0,"score":"5944488566","product_id":100109401,"comment_content":"如果SUT使用了外部系统，并且外部系统比较慢，会不会拖慢测试执行的速度，进一步拖慢编码的速度呢","like_count":1,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561090,"discussion_content":"那为什不改进","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1649551437,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1443808,"avatar":"https://static001.geekbang.org/account/avatar/00/16/07/e0/442a012b.jpg","nickname":"hippie","note":"","ucode":"E356AE881C4D8A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572020,"discussion_content":"一般，外部系统的依赖，我们会采用 Mock 的方式来构建","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652544801,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341154,"user_name":"汗香","can_delete":false,"product_type":"c1","uid":1807921,"ip_address":"","ucode":"8F2C8A595F888A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/31/91cc9c3c.jpg","comment_is_top":false,"comment_ctime":1649393662,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5944360958","product_id":100109401,"comment_content":"为什么 TDD 中主要使用状态验证来验证测试的结果？<br><br>如asuaual所说，状态验证更像黑盒，不用关心软件的内部结构，内部结构的改变对外部验证来说是透明的，更利于重构","like_count":1},{"had_liked":false,"id":358114,"user_name":"常文龙","can_delete":false,"product_type":"c1","uid":1204525,"ip_address":"广东","ucode":"4A126159D24766","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/2d/5ca0a3da.jpg","comment_is_top":false,"comment_ctime":1663917322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663917322","product_id":100109401,"comment_content":"在看第一遍的时候比较难理解为什么是状态验证是“黑盒验证”，毕竟示例里都把数据库的数据挖出来看了，还不叫白盒？<br>但仔细品味，把数据库数据挖出来看，是为了看“没有直接输出的输出”，而不是看内部状态，从这个角度看，的确是黑盒验证。","like_count":0},{"had_liked":false,"id":357333,"user_name":"努力努力再努力","can_delete":false,"product_type":"c1","uid":1493907,"ip_address":"广东","ucode":"0C6EEA28FCE8C7","user_header":"https://static001.geekbang.org/account/avatar/00/16/cb/93/4adea49a.jpg","comment_is_top":false,"comment_ctime":1663162008,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1663162008","product_id":100109401,"comment_content":"问题：为什么 TDD 中主要使用状态验证来验证测试的结果？<br>回答：我觉得是，任何事情的执行，注重的都是最终的结果，状态验证也是如此，忽略测试执行（exercise）的过程，专注于最终测试的结果是否与设想的一致。","like_count":0},{"had_liked":false,"id":355936,"user_name":"Geek","can_delete":false,"product_type":"c1","uid":1466335,"ip_address":"北京","ucode":"1B8EB2C26DE4EC","user_header":"https://static001.geekbang.org/account/avatar/00/16/5f/df/3c4881f0.jpg","comment_is_top":false,"comment_ctime":1661861173,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1661861173","product_id":100109401,"comment_content":"请问老师，查询数据库算是状态验证么，我理解也可以说是一个行为。因为数据库也是一种实现，以后可能重构成别的库或者别的表。这样这个case还是会失效","like_count":0},{"had_liked":false,"id":343119,"user_name":"jimson","can_delete":false,"product_type":"c1","uid":1587381,"ip_address":"","ucode":"3973DCFB6358DA","user_header":"https://static001.geekbang.org/account/avatar/00/18/38/b5/3b8eb688.jpg","comment_is_top":false,"comment_ctime":1650639703,"is_pvip":false,"replies":[{"id":"125322","content":"是一个方面 另一方面状态好测","user_name":"作者回复","comment_id":343119,"uid":"2537798","ip_address":"","utype":1,"ctime":1650709077,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1650639703","product_id":100109401,"comment_content":"为什么 TDD 中主要使用状态验证来验证测试的结果？<br><br>因为我们使用的是OOP, 操作的大多数是数据的改变。","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566513,"discussion_content":"是一个方面 另一方面状态好测","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650709077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341324,"user_name":"humor","can_delete":false,"product_type":"c1","uid":1181867,"ip_address":"","ucode":"9B48C4C7BEC92C","user_header":"https://static001.geekbang.org/account/avatar/00/12/08/ab/caec7bca.jpg","comment_is_top":false,"comment_ctime":1649521170,"is_pvip":false,"replies":[{"id":"124758","content":"看下一节","user_name":"作者回复","comment_id":341324,"uid":"2537798","ip_address":"","utype":1,"ctime":1649551402,"user_name_real":"编辑"}],"discussion_count":1,"race_medal":0,"score":"1649521170","product_id":100109401,"comment_content":"因为在TDD刚开始的时候还没有代码实现呢，只能验证最终的结果(状态)","like_count":0,"discussions":[{"author":{"id":2537798,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b9/46/758ecf4a.jpg","nickname":"徐八叉","note":"","ucode":"DA6D1EB08A7396","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561089,"discussion_content":"看下一节","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649551402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340519,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1648879097,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"1648879097","product_id":100109401,"comment_content":"终于追到了第五讲，之前用 RSpec 写过 Ruby 的单元测试，但是没有感觉的状态验证和行为验证的具体差别，估计还是代码写的太少的缘故。<br><br>这一讲其实是前面几讲中相对轻松的一篇，前面课程的视频里面有不少代码示例，我努力完成了一部分，主要是因为自己对于 Java 实在是不够熟练，练习 TDD 的过程中顺便学习了一个 Java 编程。<br><br>同样把提供代码，希望能有帮助 https:&#47;&#47;github.com&#47;escray&#47;TDDCourse&#47;tree&#47;ch05<br><br>有点好奇的是，Java 的这些新特性在日常开发中使用的多么？似乎很多项目还是建立在 Java 1.8 的基础上的，虽然现在已经是 Java 18 了。","like_count":0,"discussions":[{"author":{"id":1433290,"avatar":"https://static001.geekbang.org/account/avatar/00/15/de/ca/73f15fe7.jpg","nickname":"老衲","note":"","ucode":"B02BB107DB51BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580025,"discussion_content":"都是秉承着一个程序员和程序有一个能跑就行的原则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657813029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339780,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1648376545,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648376545","product_id":100109401,"comment_content":"来自学习群的分享<br>有哪些状态验证技术推荐吗？<br>- 做各种fake mountainbike,mock,in men do, test container<br>- 目的就是尽量少做行为验证<br>- **所谓测试策略 就是在保证有效性的同时 尽可能降低测试成本**<br>- 维持测试有效性 有个最小成本<br>- 小过这个 测试就无效了 或者不足以支撑长期演化（重构）<br>- 所以你没办法一直缩短测试时间<br>- 这也是我们讲的 始终使用状态验证 防止测试失效<br>- 在状态验证里 通过stub 偷换fake 降低成本","like_count":0},{"had_liked":false,"id":339717,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1648308161,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648308161","product_id":100109401,"comment_content":"推荐一个比 Selenium 更好用的 Selenide（我没用过，但看书上介绍很厉害）<br>1. 基于 Selenium 的项目<br>2. 提供了优良的测试编写语法，提高了测试的可读性<br>3. 它将 WebDriver 和配置隐藏，同时提供了极大的定制空间<br>4. PhantomJS 是一款无界面浏览器（headless browser），不使用任何 UI 就能工作<br><br>摘自《Java 测试驱动开发》2.9 用户界面测试；7.4.3 Selenium 和 Selenide<br>笔记链接：http:&#47;&#47;wyyl1.com&#47;post&#47;18&#47;02&#47;","like_count":0}]}