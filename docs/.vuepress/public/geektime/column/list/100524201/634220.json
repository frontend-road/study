{"id":634220,"title":"07｜静态链表：用一维数组表达的链表","content":"<p><span class=\"reference\"></span>你好，我是王健伟。</p><p>前面已经聊了很多种链表，今天我们再来聊一聊最后一种链表——“静态链表”。</p><p>有些早期的高级语言，并没有指针这种概念，之前我们探讨的链表实现方法在这些高级语言中并不适用。于是，用<strong>一维数组</strong>代替<strong>指针</strong>来描述单链表的想法应运而生，这种用一维数组描述的链表，就称为<strong>静态链表</strong>。</p><p>之前我们说过，单链表节点之间在内存中并不需要紧密相连地存放，而采用数组存储数据时则需要数据在内存中紧密相连。所以不难想象，静态链表在内存中也需要分配一整块连续的内存空间，如图8所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6a/11/6a90141bcd0bf5c2658yyeefd7aecd11.jpg?wh=2284x1280\" alt=\"\" title=\"图8&nbsp; 用静态链表存储数据（需要分配一整块连续的内存空间）\"></p><p>你会发现，说是内存空间紧密相连，但是链表中的各个节点却是并不需要紧密地连在一起的。</p><p>每个数组元素都是由两个数据域组成：data和cur。其中data用来存储链表中每个节点的数据，cur用来存储链表中后继节点所属的数组元素的下标<span class=\"reference\">（cur也称为<strong>游标</strong>，用来<strong>模拟指针</strong>）</span>。比如图8中存储数据a2的区域就是data域，存储数字6的区域就是cur域。</p><p>注意，如果cur域的值为“末尾<span class=\"reference\">（一个负数作为标记）</span>”，则表示该cur所代表的数组元素是链表中的最后一个节点，比如图8中存储数据a5的节点。下标为0的数组元素可以看成是链表的头节点，其cur域的值<span class=\"reference\">（数字2）</span>用于指示链表第一个数据节点对应的数组下标。所以，数据a1所在的节点，其实就是静态链表的第一个数据节点。</p><!-- [[[read_end]]] --><p>理解之后，我们就来说具体的实现方式了。静态链表的实现代码有很多种，这里我选择一种从代码可读性上比较好理解的实现方法来讲解。在后面的课后思考中，我会让你实现一个稍微复杂点的静态链表。</p><h1>静态链表的类定义、初始化操作</h1><p>还是先说类定义和初始化操作。</p><p>下面是静态链表的类定义、初始化操作的相关实现代码。</p><pre><code class=\"language-plain\">#define MaxSize 201 //静态链表的尺寸，可以根据实际需要设定该值。可用数组下标为0-200\n//节点使用情况枚举标记值\nenum NODEUSE&nbsp;\n{\n\t//这些枚举值都给负值，以免和数组下标（从0开始的正值）冲突\n\te_NOUSE = -1,&nbsp; //未使用（未用）\n\te_LAST&nbsp; = -2&nbsp; &nbsp;//最后一个节点（末尾）\n};\n\n//静态链表中每个节点的定义\ntemplate &lt;typename T&gt; //T代表数据元素的类型\nstruct Node\n{\n\tT&nbsp; &nbsp; &nbsp; &nbsp; data;&nbsp; //元素数据域，存放数据元素\n\tint&nbsp; &nbsp; &nbsp; cur;&nbsp; &nbsp;//游标，记录下个静态链表节点的数组下标\n};\n\t\n//静态链表的定义\ntemplate &lt;typename T&gt;\nclass StaticLinkList\n{\npublic:\n\tStaticLinkList();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //构造函数\n\t~StaticLinkList() {};&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //析构函数\n\npublic:\n\tint&nbsp; findAnIdlePos();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //找到一个空闲位置用于保存数据\n\tbool ListInsert(int i, const T&amp; e);&nbsp; //在第i个位置插入指定元素e\n\tbool ListDelete(int i);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //删除第i个位置的元素\n\t\n\tbool GetElem(int i, T&amp; e);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//获得第i个位置的元素值\n\tint&nbsp; LocateElem(const T&amp; e);&nbsp; &nbsp; &nbsp; &nbsp;//按元素值查找其在静态链表中第一次出现的位置\n\t\n\tvoid DispList();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//输出静态链表中的所有元素\n\tint&nbsp; ListLength();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//获取静态链表的长度\n\tbool Empty();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //判断静态链表是否为空\n\nprivate:\n\tNode&lt;T&gt; m_data[MaxSize]; //保存节点数据的数组\n\tint m_length;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //当前长度，也就是当前保存的数据节点数目\n};\n\t\n//通过构造函数对静态链表进行初始化\ntemplate &lt;typename T&gt;\nStaticLinkList&lt;T&gt;::StaticLinkList()\n{\t\n\tfor (int i = 1; i &lt; MaxSize; ++i) //从下标1开始的节点用于保存实际的数据，这些节点的cur有必要设置值，而头节点其实不用给任何初值\n\t{\n\t\tm_data[i].cur = e_NOUSE; //标记这些节点都没使用\n\t}\n\tm_length = 0; //还未向其中存入任何数据元素\n}\n</code></pre><p>之后，我们在main主函数中，可以加入下面的代码创建一个静态链表对象。</p><pre><code class=\"language-plain\">StaticLinkList&lt;int&gt; slinkobj;\n</code></pre><p>这个时候，所创建的静态链表对象应该如图9所示，静态链表已经创建完毕，只不过这个链表中目前还没有存储任何数据，可以认为是一个空链表。</p><p><img src=\"https://static001.geekbang.org/resource/image/dc/bd/dc7219222fea3yy033aaffea3a79f7bd.jpg?wh=2284x1280\" alt=\"\" title=\"图9&nbsp; 新初始化的静态链表存储数据的情形\"></p><h1>静态链表元素插入操作</h1><p>在指定位置插入元素的操作，可以分为4个核心步骤。</p><ol>\n<li>找到一个空闲位置代表新插入的节点，在其中存入数据元素。</li>\n<li>从头节点开始，找到待插入位置的前一个<span class=\"reference\">（前趋）</span>节点。</li>\n<li>设置新插入节点的cur值以指向前趋节点所指向的节点，设置前趋节点的cur值以指向这个新插入的节点。</li>\n<li>如果新插入的节点是最后一个节点，要设置其cur标记为“末尾”。</li>\n</ol><p>下面是插入操作ListInsert的实现代码<span class=\"reference\">（同时引入辅助函数findAnIdlePos）</span>。</p><pre><code class=\"language-plain\">//在m_data中找到一个空闲位置用于保存数据，若没有找到（静态链表满了），则返回-1\ntemplate &lt;typename T&gt;\nint StaticLinkList&lt;T&gt;::findAnIdlePos()\n{\n\tfor (int i = 1; i &lt; MaxSize; ++i) //因为下标0是头节点，不能用于保存数据，所以循环变量从1开始\n\t{\n\t\tif (m_data[i].cur == e_NOUSE) //未使用\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n//在第iPos个位置（位置编号从1开始）插入指定元素e\ntemplate &lt;typename T&gt;\nbool StaticLinkList&lt;T&gt;::ListInsert(int iPos, const T&amp; e)\n{\n\tif (iPos &lt; 1 || iPos &gt; (m_length + 1))\n\t{\n\t\tcout &lt;&lt; \"元素\" &lt;&lt; e &lt;&lt; \"插入的位置\" &lt;&lt; iPos &lt;&lt; \"不合法，合法的位置是1到\" &lt;&lt; m_length + 1 &lt;&lt; \"之间!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\n\tint iIdx;\n\tif ((iIdx = findAnIdlePos()) == -1) //静态链表满了\n\t{&nbsp;\n\t\tcout &lt;&lt; \"静态链表已满!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\n\t//既然需要在第iPos个位置插入元素，那么肯定要找到第iPos-1个位置。\n\tint iDataCount = 1; //统计静态链表中元素数量\n\tint iIdxPrev;&nbsp; &nbsp; &nbsp; &nbsp;//保存第iPos-1个位置对应的m_data数组的下标\n\n\tif (iPos == 1) //向第一个位置插入元素，要单独处理\n\t{\t\t\t\t\t\t\n\t\tm_data[iIdx].data = e;\n\t\tif (m_length == 0) //空表\n\t\t{\t\t\t\t\t\n\t\t\tm_data[iIdx].cur = e_LAST;\n\t\t}\n\t\telse //非空表\n\t\t{\t\t\t\t\n\t\t\tm_data[iIdx].cur = m_data[0].cur;\n\t\t}\n\t\tm_data[0].cur = iIdx;\n\t}\n\telse\n\t{\t\t\t\n\t\tint iPosCount = 0; //位置计数\n\t\tint tmpcur = m_data[0].cur;\n\n\t\t//前面已经判断过插入位置合法，所以一定可以找到合适的位置，while(true)循环肯定可以正常退出\n\t\twhile (true)&nbsp;\n\t\t{\t\n\t\t\tiPosCount++;\n\t\t\tif (iPosCount &gt;= (iPos - 1)) //找到了第iPos-1个位置\n\t\t\t{\n\t\t\t\tiIdxPrev = tmpcur;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmpcur = m_data[tmpcur].cur;\n\t\t\t\n\t\t} //end while\n\t\t\t\n\t\tint iTmpCurr = m_data[iIdxPrev].cur;\n\t\tm_data[iIdxPrev].cur = iIdx;\n\t\tm_data[iIdx].data = e;\n\t\tm_data[iIdx].cur = iTmpCurr;\n\t}\n\tcout &lt;&lt; \"成功在位置为\" &lt;&lt; iPos &lt;&lt; \"处插入元素\" &lt;&lt; e &lt;&lt; \"!\" &lt;&lt; endl;\n\tm_length++;\t&nbsp; &nbsp;//实际表长+1\n\treturn true;\n}\t\n</code></pre><p>在main主函数中，我们继续加入测试代码。</p><pre><code class=\"language-plain\">slinkobj.ListInsert(1, 12);\t\t\nslinkobj.ListInsert(1, 24);\t\nslinkobj.ListInsert(3, 48);\t\nslinkobj.ListInsert(2, 100);\nslinkobj.ListInsert(5, 190);\nslinkobj.ListInsert(4, 300);\n</code></pre><p>执行上述代码后，静态链表存储数据的情形以及对应的单链表应该如图10所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/f8/2f015635cb7bd5143389d3bb99c024f8.jpg?wh=2478x1280\" alt=\"\" title=\"图10&nbsp; 插入一系列数据后静态链表存储数据的情形以及对应的单链表\"></p><p>执行结果为：</p><p><img src=\"https://static001.geekbang.org/resource/image/2d/8a/2d32421c60ae2bfeeded90e61b9f0f8a.png?wh=1251x274\" alt=\"图片\"></p><h1>静态链表元素显示、获取等操作</h1><p>静态链表元素的显示、获取操作相关的函数一共有三个，分别为DispList、GetElem、LocateElem。取得静态链表长度的是ListLength函数，判断静态链表是否为空的为Empty函数。我们分别看一看。</p><p>首先，输出静态链表中的所有元素。</p><pre><code class=\"language-plain\">//输出静态链表中的所有元素，时间复杂度为O(n)\ntemplate&lt;class T&gt;\nvoid StaticLinkList&lt;T&gt;::DispList()\n{\n\tif (m_length &lt; 1)\n\t{\n\t\t//静态链表为空\n\t\treturn;\n\t}\n\tint tmpcur = m_data[0].cur;\n\twhile (true)\n\t{\n\t\tcout &lt;&lt; m_data[tmpcur].data &lt;&lt; \" \";\n\t\tif ((tmpcur = m_data[tmpcur].cur) == e_LAST)\n\t\t\tbreak;\n\t} //end while\n\tcout &lt;&lt; endl; //换行\t\n}\n</code></pre><p>再来，是按照位置，或按照元素值查找。</p><pre><code class=\"language-plain\">//获得第i个位置的元素值，时间复杂度为O(n)\ntemplate&lt;class T&gt;\nbool StaticLinkList&lt;T&gt;::GetElem(int i, T&amp; e)\n{\t\n\tif (m_length &lt; 1)\n\t{\n\t\t//静态链表为空\n\t\tcout &lt;&lt; \"当前静态链表为空，不能获取任何数据!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\t\n\tif (i &lt; 1 || i &gt; m_length)\n\t{\n\t\tcout &lt;&lt; \"获取元素的位置\" &lt;&lt; i &lt;&lt; \"不合法，合法的位置是1到\" &lt;&lt; m_length &lt;&lt; \"之间!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\tint tmpcur = m_data[0].cur;\n\tint iPos = 0;\n\twhile (true)\n\t{\n\t\tiPos++;\n\t\tif (iPos == i)\n\t\t{\n\t\t\te = m_data[tmpcur].data;\n\t\t\tcout &lt;&lt; \"成功获取位置为\" &lt;&lt; i &lt;&lt; \"的元素，该元素的值为\" &lt;&lt; e &lt;&lt; \"!\" &lt;&lt; endl;\n\t\t\treturn true;\n\t\t}\n\t\ttmpcur = m_data[tmpcur].cur;\n\t}\n\treturn false;\t\t\n}\n\t\n//按元素值查找其在静态链表中第一次出现的位置，时间复杂度为O(n)\ntemplate&lt;class T&gt;\nint StaticLinkList&lt;T&gt;::LocateElem(const T&amp; e)\n{\n\tif (m_length &lt; 1)\n\t{\n\t\t//静态链表为空\n\t\tcout &lt;&lt; \"当前静态链表为空，不能获取任何数据!\" &lt;&lt; endl;\n\t\treturn -1;\n\t}\n\tint tmpcur = m_data[0].cur;\n\tint iPos = 0;\n\twhile (true)\n\t{\n\t\tiPos++;\n\t\tif (m_data[tmpcur].data == e &amp;&amp; m_data[tmpcur].cur != e_NOUSE)\n\t\t{\n\t\t\tcout &lt;&lt; \"值为\" &lt;&lt; e &lt;&lt; \"的元素在静态链表中第一次出现的位置为\" &lt;&lt; iPos &lt;&lt; \"!\" &lt;&lt; endl;\n\t\t\treturn tmpcur;\n\t\t}\n\t\tif (m_data[tmpcur].cur == e_LAST)\n\t\t{\n\t\t\t//这是没找到\n\t\t\tbreak;\n\t\t}\n\t\ttmpcur = m_data[tmpcur].cur;\n\t}\n\tcout &lt;&lt; \"值为\" &lt;&lt; e &lt;&lt; \"的元素在静态链表中没有找到!\" &lt;&lt; endl;\n\treturn -1;  //返回-1表示查找失败\n}\t\n</code></pre><p>最后，是两个其他操作，获取长度以及判断链表是否为空。</p><pre><code class=\"language-plain\">//获取静态链表的长度，时间复杂度为O(1)\ntemplate&lt;class T&gt;\nint  StaticLinkList&lt;T&gt;::ListLength()\n{\n\treturn m_length;\t\t\n}\n\n//判断静态链表是否为空，时间复杂度为O(1)\ntemplate&lt;class T&gt;\nbool StaticLinkList&lt;T&gt;::Empty()\n{\t\t\n\tif (m_length &lt; 1)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\n</code></pre><p>在main主函数中，继续增加代码。</p><pre><code class=\"language-plain\">slinkobj.DispList();\nslinkobj.LocateElem(190);\nslinkobj.LocateElem(24);&nbsp;\nslinkobj.LocateElem(300);\ncout &lt;&lt; \"----------------\" &lt;&lt; endl;\nint eval = 0;\nslinkobj.GetElem(0, eval); //如果GetElem()返回true，则eval中保存着获取到的元素值\nslinkobj.GetElem(1, eval);\nslinkobj.GetElem(3, eval);\nslinkobj.GetElem(6, eval);\n</code></pre><p>新增代码的执行结果为：<br>\n<img src=\"https://static001.geekbang.org/resource/image/8e/6f/8e63bcf177cebbdd44ba33ba3147c36f.jpg?wh=1267x401\" alt=\"图片\"></p><h1>静态链表元素删除操作</h1><p>删除指定位置元素的操作核心步骤我们可以分为3步。</p><ol>\n<li>从头节点开始，找到待删除节点的前一个<span class=\"reference\">（前趋）</span>节点。</li>\n<li>设置前趋节点的cur值等于当前待删除节点的cur值以指向当前节点所指向的节点。</li>\n<li>设置被删除节点的状态为“未用”状态。</li>\n</ol><p>下面是删除操作ListDelete的实现代码。</p><pre><code class=\"language-plain\">//删除第iPos个位置的元素\ntemplate &lt; typename T&gt;\nbool StaticLinkList&lt;T&gt;::ListDelete(int iPos)\n{\n\tif (m_length &lt; 1)\n\t{\n\t\tcout &lt;&lt; \"当前静态链表为空，不能删除任何数据!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\tif (iPos &lt; 1 || iPos &gt; m_length)\n\t{\n\t\tcout &lt;&lt; \"删除的位置\" &lt;&lt; iPos &lt;&lt; \"不合法，合法的位置是1到\" &lt;&lt; m_length &lt;&lt; \"之间!\" &lt;&lt; endl;\n\t\treturn false;\n\t}\n\t\n\tint tmpcur = m_data[0].cur; //第一个数据节点的数组下标\n\tif (iPos == 1) //删除第一个位置元素，要单独处理\n\t{\n\t\tif (m_length != 1)&nbsp;\n\t\t{\t\t\t\t\n\t\t\t//这个静态链表里有多个元素，那么\n\t\t\tm_data[0].cur = m_data[tmpcur].cur; //头节点指向第二个数据节点的数组下标\n\t\t}\n\t\tm_data[tmpcur].cur = e_NOUSE;\n\t\tcout &lt;&lt; \"成功删除位置为\" &lt;&lt; iPos &lt;&lt; \"的元素，该元素的值为\" &lt;&lt; m_data[tmpcur].data &lt;&lt; \"!\" &lt;&lt; endl;\n\t}\n\telse\n\t{\t\t\t\n\t\tint iIdxPrev; //第iPos-1个位置对应的m_data数组的下标\n\t\tint iPosCount = 0; //位置计数\n\t\t\n\t\t//前面已经判断过删除位置合法，所以一定可以找到合适的位置，while(true)循环肯定可以正常退出\n\t\twhile (true)\n\t\t{\n\t\t\tiPosCount++;\n\t\t\tif (iPosCount &gt;= (iPos - 1)) //找到了第i-1个位置\n\t\t\t{\n\t\t\t\tiIdxPrev = tmpcur;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmpcur = m_data[tmpcur].cur;\n\t\t} //end while\n\t\t\n\t\tint iTmpCurr = m_data[iIdxPrev].cur; //当前要删除的这个节点的数组下标\n\t\tm_data[iIdxPrev].cur = m_data[iTmpCurr].cur;//前一个节点的cur指向当前要删除节点的cur\n\t\tm_data[iTmpCurr].cur = e_NOUSE; //标记被删除数据节点的数组下标为未用状态\n\t\tcout &lt;&lt; \"成功删除位置为\" &lt;&lt; iPos &lt;&lt; \"的元素，该元素的值为\" &lt;&lt; m_data[iTmpCurr].data &lt;&lt; \"!\" &lt;&lt; endl;\n\t} //end if (iPos == 1)\n\tm_length--;&nbsp; &nbsp; &nbsp; &nbsp;//实际表长-1\n\treturn true;\n}\n</code></pre><p>在main主函数中，继续增加代码测试。</p><pre><code class=\"language-plain\">cout &lt;&lt; \"----------------\" &lt;&lt; endl;\nslinkobj.ListDelete(1);\nslinkobj.ListDelete(5);\nslinkobj.ListDelete(10);\nslinkobj.DispList();\n</code></pre><p>新增加代码行的执行结果为：</p><p><img src=\"https://static001.geekbang.org/resource/image/ff/8e/ff0dc48a193b356dc7cdb8fa2e63398e.jpg?wh=1208x276\" alt=\"图片\"></p><p>此时，静态链表存储数据的情形应该如图11所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/c3/c73ff6f0c56aa82617a8441beab6a8c3.jpg?wh=2478x1280\" alt=\"\" title=\"图11&nbsp; 删除两个数据后静态链表存储数据的情形\"></p><p>在图11中，删除了两个数据后，原来值为24和190的位置已经被标记为“未用”状态，此时，该位置的数字就没有任何存在的意义了，因为该位置已经是一个未被使用的位置，下次插入新数据时，findAnIdlePos函数会直接找到并使用这些“未用”的位置。</p><p>我们在main主函数中继续增加代码行。</p><pre><code class=\"language-plain\">cout &lt;&lt; \"----------------\" &lt;&lt; endl;\nslinkobj.ListInsert(1, 500);\nslinkobj.ListInsert(3, 600);\nslinkobj.ListInsert(4, 700);\nslinkobj.DispList();\n</code></pre><p>新增加代码行的执行结果为：</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/ff/b3427cf61b8ccbf175b8706a933f41ff.jpeg?wh=1329x264\" alt=\"图片\"></p><p>结合图11，想一想，这个时候的静态链表存储数据的情形如何呢？就留给你思考和亲测吧。</p><h1>小结</h1><p>这节课我们讲解了静态链表。静态链表的实现代码有很多种，非常灵活。</p><p>在今天的讲解中，我们是通过findAnIdlePos函数寻找了一个空闲位置，保存数据的时候，每次也都是从头节点的后继节点开始寻找，这就导致，当链表中数据较多的时候，恐怕会影响效率。</p><p>因此，你也可以采用不同的静态链表实现方式——比如将静态链表中的第一个和最后一个节点作为特殊节点来使用<span class=\"reference\">（不保存数据）</span>。</p><ul>\n<li>第一个节点的cur存放第一个未被使用的节点所对应的数组下标<span class=\"reference\">（这些未被使用的节点可以通过cur串起来，构成一个未被使用的节点链）</span>。</li>\n<li>最后一个节点的cur存放第一个有数据的节点对应的数组下标<span class=\"reference\">（相当于头节点）</span>，该值为0相当于链表为空。</li>\n</ul><p>这样的静态链表实现方式，虽然代码会更加繁琐，但在插入数据的时候可以明显提高寻找空闲节点的效率，时间复杂度会从O(n)变为O(1)。如果你有兴趣，也可以自行实现相关的代码。</p><p>静态链表中，元素的插入和删除操作并不需要移动元素，仅仅是修改游标。所以仍旧具备链表的主要优点——插入和删除节点非常方便，同时，也避免了顺序表要求所有数据元素在内存中必须紧挨在一起的缺点。</p><p>另外，存取数据时，静态链表无法进行随机存取，只能从头节点开始依次向后查找。而且静态链表的大小是固定的，无法扩容，所以静态链表往往比较适合<strong>不支持指针的程序开发语言环境且数据最大容量是固定不变的场合</strong>，目前的应用并不是十分广泛，但其中代码的实现方式，绝对值得我们学习和借鉴。</p><p>最后，我们来总结一下目前为止所讲过的各种数据结构保存数据的特点。</p><ul>\n<li>顺序表：所分配的内存空间连续，其中保存的各个数据节点也紧密相连。</li>\n<li>单<span class=\"reference\">（双）</span>链表、单<span class=\"reference\">（双）</span>循环链表：分配的内存空间不连续<span class=\"reference\">（每个数据节点单独分配内存）</span>，当然链表中的数据节点也就不可能紧密相连。</li>\n<li>静态链表：所分配的内存空间连续，所有的数据节点都会保存在这块内存空间中，但因为引入了游标来寻找各个数据节点，所以静态链表中各个数据节点并不要求紧密相连。</li>\n</ul><h1>归纳思考</h1><p>在小结中，我们提到了一种不同的静态链表实现方式——将静态链表中的第一个和最后一个节点作为特殊节点来使用，你可以尝试自行实现这种静态链表相关的代码。</p><p>欢迎你在留言区和我互动。如果觉得有所收获，也可以把课程分享给更多的朋友一起学习进步。我们下节课见！</p>","neighbors":{"left":{"article_title":"06｜循环链表：如何更方便地寻找数据？","id":633391},"right":{"article_title":"08｜栈：如何实现数据的后进先出？","id":635174}},"comments":[{"had_liked":false,"id":369852,"user_name":"RIVER","can_delete":false,"product_type":"c1","uid":1281334,"ip_address":"湖北","ucode":"6CA37430037899","user_header":"https://static001.geekbang.org/account/avatar/00/13/8d/36/912be6bc.jpg","comment_is_top":false,"comment_ctime":1678061036,"is_pvip":false,"replies":[{"id":134815,"content":"你指的关键词的定义带上（英文）是指哪个，可以举一个例子让老师看看。另外代码中也有一些英文名字、拼写之类的你可以参考。提到阅读英文资料，除非你有明确的任务需求，不然没必要阅读英文资料，因为我们有太多新知识需要学，学每样知识适度就是最好的。","user_name":"作者回复","user_name_real":"编辑","uid":1104356,"ctime":1678075163,"ip_address":"广东","comment_id":369852,"utype":1}],"discussion_count":1,"race_medal":1,"score":2,"product_id":100524201,"comment_content":"老师可不可以把一些关键词的定义带上（英文），便于后续阅读英文资料","like_count":1,"discussions":[{"author":{"id":1104356,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d9/e4/791d0f5e.jpg","nickname":"KuangXiang","note":"","ucode":"BEEB53A49BA695","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607661,"discussion_content":"你指的关键词的定义带上（英文）是指哪个，可以举一个例子让老师看看。另外代码中也有一些英文名字、拼写之类的你可以参考。提到阅读英文资料，除非你有明确的任务需求，不然没必要阅读英文资料，因为我们有太多新知识需要学，学每样知识适度就是最好的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1678075164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392949,"user_name":"Fang","can_delete":false,"product_type":"c1","uid":3540228,"ip_address":"上海","ucode":"6F026565387364","user_header":"https://static001.geekbang.org/account/avatar/00/36/05/04/8deca125.jpg","comment_is_top":false,"comment_ctime":1722262873,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"应用并不是十分广泛","like_count":0}]}