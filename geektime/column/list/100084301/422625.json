{"id":422625,"title":"24 | 从哨兵Leader选举学习Raft协议实现（下）","content":"<p>你好，我是蒋德钧。</p><p></p><p>上节课，我给你介绍了Raft协议的基本流程，以及哨兵实例工作的基本过程。哨兵是通过serverCron函数的周期性执行，进而在serverCron中调用sentinelTimer函数，实现周期性处理哨兵相关的时间事件。而sentinelTimer函数处理的时间事件，就包括了对哨兵监听的每个主节点，它会通过调用sentinelHandleRedisInstance函数，来检查主节点的在线状态，并在主节点客观下线时进行故障切换。</p><p></p><p>另外，我还带你了解了sentinelHandleRedisInstance函数执行过程的前三步操作，分别是重连断连的实例、周期性给实例发送检测命令，检测实例是否主观下线，这也分别对应了sentinelReconnectInstance、sentinelSendPeriodicCommands和sentinelCheckSubjectivelyDown这三个函数，你可以再回顾下。</p><p></p><p>那么，今天这节课，我接着来给你介绍sentinelHandleRedisInstance函数执行过程中的剩余操作，分别是检测主节点是否客观下线、判断是否需要执行故障切换，以及需要故障切换时的哨兵Leader选举的具体过程。</p><!-- [[[read_end]]] --><p></p><p>学完这节课的内容，你就可以对哨兵工作的过程有个全面了解了。并且，你可以掌握如何在代码层面实现Raft协议来完成Leader选举。这样，当你日后在分布式系统中实现分布式共识时，这部分内容就能帮助指导你的代码设计与实现了。</p><p></p><p>接下来，我们先来看下主节点的客观下线判断。</p><p></p><h2>主节点客观下线判断</h2><p>现在我们知道，哨兵在sentinelHandleRedisInstance函数中会<strong>调用sentinelCheckObjectivelyDown函数</strong>（在sentinel.c文件中），来检测主节点是否客观下线。</p><p></p><p>而sentinelCheckObjectivelyDown函数在执行时，除了会检查当前哨兵对主节点主观下线的判断结果，还需要结合监听相同主节点的其他哨兵，对主节点主观下线的判断结果。它把这些判断结果综合起来，才能做出主节点客观下线的最终判断。</p><p></p><p>从代码实现层面来看，在哨兵用来记录主节点信息的<strong>sentinelRedisInstance结构体</strong>中，本身已经用哈希表保存了监听同一主节点的其他哨兵实例，如下所示：</p><pre><code class=\"language-plain\">typedef struct sentinelRedisInstance {\n…\ndict *sentinels;\n…\n}\n</code></pre><p>这样一来，sentinelCheckObjectivelyDown函数通过遍历主节点记录的sentinels哈希表，就可以获取其他哨兵实例对同一主节点主观下线的判断结果。这也是因为，sentinels哈希表中保存的哨兵实例，它们同样使用了sentinelRedisInstance这个结构体，而这个结构体的成员变量flags，会记录哨兵对主节点主观下线的判断结果。</p><p>具体来说，sentinelCheckObjectivelyDown函数会<strong>使用quorum变量，来记录判断主节点为主观下线的哨兵数量</strong>。如果当前哨兵已经判断主节点为主观下线，那么它会先把quorum值置为1。然后，它会依次判断其他哨兵的flags变量，<strong>检查是否设置了SRI_MASTER_DOWN的标记</strong>。如果设置了，它就会把quorum值加1。</p><p>当遍历完sentinels哈希表后，sentinelCheckObjectivelyDown函数会判断quorum值是否大于等于预设定的quorum阈值，这个阈值保存在了主节点的数据结构中，也就是master-&gt;quorum，而这个阈值是在sentinel.conf配置文件中设置的。</p><p>如果实际的quorum值大于等于预设的quorum阈值，sentinelCheckObjectivelyDown函数就判断主节点为客观下线，并<strong>设置变量odown为1，</strong>而这个变量就是用来表示当前哨兵对主节点客观下线的判断结果的。</p><p>这部分的判断逻辑如下代码所示，你可以看下：</p><pre><code class=\"language-plain\">void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {\n…\n//当前主节点已经被当前哨兵判断为主观下线\nif (master-&gt;flags &amp; SRI_S_DOWN) {\n&nbsp;&nbsp; quorum = 1; //当前哨兵将quorum值置为1\n&nbsp; &nbsp;\n&nbsp;&nbsp; di = dictGetIterator(master-&gt;sentinels);\n&nbsp;&nbsp; while((de = dictNext(di)) != NULL) {&nbsp; //遍历监听同一主节点的其他哨兵\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sentinelRedisInstance *ri = dictGetVal(de);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ri-&gt;flags &amp; SRI_MASTER_DOWN) quorum++;\n&nbsp;&nbsp; }\n&nbsp;&nbsp; dictReleaseIterator(di);\n&nbsp;&nbsp; //如果quorum值大于预设的quorum阈值，那么设置odown为1。\n&nbsp;&nbsp; if (quorum &gt;= master-&gt;quorum) odown = 1;\n}\n</code></pre><p>另外，这里我也画了一张图，展示了该判断逻辑，你可以再来回顾下。<br>\n<img src=\"https://static001.geekbang.org/resource/image/c4/8f/c4201b2611c7e6c53604914b29b9418f.jpg?wh=1920x1080\" alt=\"图片\"></p><p>那么，一旦sentinelCheckObjectivelyDown函数判断主节点客观下线了，它就会调用sentinelEvent函数发送+odown事件消息，然后在主节点的flags变量中<strong>设置SRI_O_DOWN标记</strong>，如下所示：</p><pre><code class=\"language-plain\">//判断主节点为客观下线\nif (odown) {\n&nbsp;&nbsp; //如果没有设置SRI_O_DOWN标记\n&nbsp;&nbsp; if ((master-&gt;flags &amp; SRI_O_DOWN) == 0) {\n&nbsp;&nbsp;&nbsp; sentinelEvent(LL_WARNING,\"+odown\",master,\"%@ #quorum %d/%d\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; quorum, master-&gt;quorum); //发送+odown事件消息\n&nbsp;&nbsp; &nbsp;master-&gt;flags |= SRI_O_DOWN;&nbsp; //在主节点的flags中记录SRI_O_DOWN标记\n&nbsp;&nbsp;&nbsp; master-&gt;o_down_since_time = mstime(); //记录判断客观下线的时间\n&nbsp;&nbsp; }\n}\n</code></pre><p>也就是说，<strong>sentinelCheckObjectivelyDown函数是通过遍历监听同一主节点的其他哨兵的flags变量，来判断主节点是否客观下线的。</strong></p><p></p><p>不过，你看完刚才的代码可能会有一个疑问，在上节课学习的sentinelCheckSubjectivelyDown函数中，如果哨兵判断主节点为主观下线，是会在主节点的flags变量中<strong>设置SRI_S_DOWN标记</strong>，如下所示：</p><pre><code class=\"language-plain\">//哨兵已判断主节点为主观下线\n…\n//对应主节点的sentinelRedisInstance结构中flags没有记录主观下线\nif ((ri-&gt;flags &amp; SRI_S_DOWN) == 0) {\n&nbsp; &nbsp;…\n&nbsp;&nbsp; ri-&gt;flags |= SRI_S_DOWN;&nbsp; //在主节点的flags中记录主观下线的标记，\n}\n</code></pre><p>但是，sentinelCheckObjectivelyDown函数，是检查监听同一主节点的其他哨兵flags变量中的SRI_MASTER_DOWN标记，<strong>那么其他哨兵的SRI_MASTER_DOWN标记是如何设置的呢?</strong></p><p></p><p>这就和sentinelAskMasterStateToOtherSentinels函数（在sentinel.c文件中）有关系了，下面，我们来具体了解下这个函数。</p><p></p><h3>sentinelAskMasterStateToOtherSentinels函数</h3><p>sentinelAskMasterStateToOtherSentinels函数的主要目的，是向监听同一主节点的其他哨兵发送is-master-down-by-addr命令，进而询问其他哨兵对主节点的状态判断。</p><p></p><p>它会调用redisAsyncCommand函数（在<a href=\"https://github.com/redis/redis/tree/5.0/deps/hiredis/async.c\">async.c</a>文件中），依次向其他哨兵发送sentinel is-master-down-by-addr命令，同时，它设置了<strong>收到该命令返回结果的处理函数为sentinelReceiveIsMasterDownReply</strong>（在sentinel.c文件中），如下所示：</p><pre><code class=\"language-plain\">void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {\n…\ndi = dictGetIterator(master-&gt;sentinels);\n//遍历监听同一主节点的其他哨兵\nwhile((de = dictNext(di)) != NULL) {\n&nbsp;&nbsp; sentinelRedisInstance *ri = dictGetVal(de);\n&nbsp;&nbsp; …\n&nbsp;&nbsp; //发送sentinel is-master-down-by-addr命令\n&nbsp;&nbsp; retval = redisAsyncCommand(ri-&gt;link-&gt;cc,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sentinelReceiveIsMasterDownReply, ri,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \"%s is-master-down-by-addr %s %s %llu %s\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sentinelInstanceMapCommand(ri,\"SENTINEL\"),\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; master-&gt;addr-&gt;ip, port,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sentinel.current_epoch,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (master-&gt;failover_state &gt; SENTINEL_FAILOVER_STATE_NONE) ?\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sentinel.myid : \"*\");\n}\n…\n}\n</code></pre><p>另外从代码中，我们可以看到，sentinel is-master-down-by-addr命令中还包括主节点IP、主节点端口号、当前纪元（sentinel.current_epoch）和实例ID。下面展示的就是这个命令的格式：</p><pre><code class=\"language-plain\">sentinel is-master-down-by-addr 主节点IP 主节点端口 当前epoch 实例ID\n</code></pre><p>在这其中，哨兵会根据当前主节点所处的状态来设置实例ID。如果主节点已经要开始进行故障切换了，那么，实例ID会被设置为当前哨兵自身的ID，否则就会被设置为*号。</p><p>这里你需要注意的是，主节点的数据结构是使用了<strong>master-&gt;failover_state</strong>来记录故障切换的状态，其初始值为SENTINEL_FAILOVER_STATE_NONE（对应的数值为0），当主节点开始故障切换时，这个状态值就会大于SENTINEL_FAILOVER_STATE_NONE了。</p><p></p><p>好了，在了解了sentinelAskMasterStateToOtherSentinels函数的基本执行过程之后，我们还需要知道：sentinelAskMasterStateToOtherSentinels函数向其他哨兵发出了sentinel is-master-down-by-addr命令后，其他哨兵是如何处理的呢？</p><h3>sentinel is-master-down-by-addr命令的处理</h3><p>其实，哨兵对于sentinel开头的命令，都是在<strong>sentinelCommand函数</strong>（在sentinel.c文件）中进行处理的。sentinelCommand函数会根据sentinel命令后面跟的不同子命令，来执行不同的分支，而is-master-down-by-addr就是一条子命令。</p><p></p><p>在is-master-down-by-addr子命令对应的代码分支中，sentinelCommand函数会根据命令中的主节点IP和端口号，来获取主节点对应的sentinelRedisInstance结构体。</p><p>紧接着，它会判断主节点的flags变量中是否有SRI_S_DOWN和SRI_MASTER标记，也就是说，sentinelCommand函数会检查当前节点是否的确是主节点，以及哨兵是否已经将该节点标记为主观下线了。如果条件符合，那么它会设置<strong>isdown变量</strong>为1，而这个变量表示的就是哨兵对主节点主观下线的判断结果。</p><p></p><p>然后，sentinelCommand函数会把当前哨兵对主节点主观下线的判断结果，返回给发送sentinel命令的哨兵。它返回的结果主要包含三部分内容，分别是<strong>当前哨兵对主节点主观下线的判断结果</strong>、<strong>哨兵Leader的ID</strong>，以及<strong>哨兵Leader所属的纪元</strong>。</p><p></p><p>sentinelCommand函数，对sentinel命令处理的基本过程如下所示：</p><pre><code class=\"language-plain\">void sentinelCommand(client *c) {\n…\n// is-master-down-by-addr子命令对应的分支\nelse if (!strcasecmp(c-&gt;argv[1]-&gt;ptr,\"is-master-down-by-addr\")) {\n…\n//当前哨兵判断主节点为主观下线\nif (!sentinel.tilt &amp;&amp; ri &amp;&amp; (ri-&gt;flags &amp; SRI_S_DOWN) &amp;&amp; (ri-&gt;flags &amp; SRI_MASTER))\n&nbsp;&nbsp; isdown = 1;\n…\naddReplyMultiBulkLen(c,3); //哨兵返回的sentinel命令处理结果中包含三部分内容\naddReply(c, isdown ? shared.cone : shared.czero); //如果哨兵判断主节点为主观下线，第一部分为1，否则为0\naddReplyBulkCString(c, leader ? leader : \"*\"); //第二部分是Leader ID或者是*\naddReplyLongLong(c, (long long)leader_epoch); //第三部分是Leader的纪元\n…}\n…}\n</code></pre><p>你也可以参考下图：<br>\n<img src=\"https://static001.geekbang.org/resource/image/57/fd/573b2cb64005925500d338030f61a1fd.jpg?wh=1920x1080\" alt=\"图片\"></p><p>好了，到这里你就已经知道，哨兵会通过sentinelAskMasterStateToOtherSentinels函数，向监听同一节点的其他哨兵发送sentinel is-master-down-by-addr命令，来获取其他哨兵对主节点主观下线的判断结果。而其他哨兵是使用sentinelCommand函数，来处理sentinel is-master-down-by-addr命令，并在命令处理的返回结果中，包含自己对主节点主观下线的判断结果。</p><p></p><p>不过从刚才的代码中，你也可以看到，在其他哨兵返回的sentinel命令处理结果中，会包含哨兵Leader的信息。其实，这是因为sentinelAskMasterStateToOtherSentinels函数发送的sentinel is-master-down-by-addr命令本身，也可以用来<strong>触发哨兵Leader选举</strong>。这个我稍后会给你介绍。</p><p></p><p>那么，我们再回到前面讲主节点客观下线判断时提出的问题，sentinelCheckObjectivelyDown函数要检查监听同一主节点的其他哨兵flags变量中的SRI_MASTER_DOWN标记，但是，其他哨兵的SRI_MASTER_DOWN标记是如何设置的呢？</p><p></p><p>这实际上是和哨兵在sentinelAskMasterStateToOtherSentinels函数中，向其他哨兵发送sentinel is-master-down-by-addr命令时，设置的<strong>命令结果处理函数sentinelReceiveIsMasterDownReply</strong>有关。</p><p></p><h3>sentinelReceiveIsMasterDownReply函数</h3><p>在sentinelReceiveIsMasterDownReply函数中，它会判断其他哨兵返回的回复结果。回复结果会包含我刚才介绍的三部分内容，分别是当前哨兵对主节点主观下线的判断结果、哨兵Leader的ID，以及哨兵Leader所属的纪元。这个函数会进一步检查，其中第一部分内容“当前哨兵对主节点主观下线的判断结果”是否为1。</p><p>如果是的话，这就表明对应的哨兵已经判断主节点为主观下线了，那么当前哨兵就会把自己记录的对应哨兵的flags，设置为SRI_MASTER_DOWN。</p><p></p><p>下面的代码就展示了sentinelReceiveIsMasterDownReply函数判断其他哨兵回复结果的执行逻辑，你可以看下。</p><pre><code class=\"language-plain\">//r是当前哨兵收到的其他哨兵的命令处理结果\n//如果返回结果包含三部分内容，并且第一，二，三部分内容的类型分别是整数、字符串和整数\nif (r-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; r-&gt;elements == 3 &amp;&amp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;element[0]-&gt;type == REDIS_REPLY_INTEGER &amp;&amp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;element[1]-&gt;type == REDIS_REPLY_STRING &amp;&amp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; r-&gt;element[2]-&gt;type == REDIS_REPLY_INTEGER)\n{\n&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;ri-&gt;last_master_down_reply_time = mstime();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果返回结果第一部分的值为1，则在对应哨兵的flags中设置SRI_MASTER_DOWN标记\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (r-&gt;element[0]-&gt;integer == 1) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ri-&gt;flags |= SRI_MASTER_DOWN;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }\n</code></pre><p>所以到这里，你就可以知道，一个哨兵调用sentinelCheckObjectivelyDown函数，是直接检查其他哨兵的flags是否有SRI_MASTER_DOWN标记，而哨兵又是通过sentinelAskMasterStateToOtherSentinels函数，向其他哨兵发送sentinel is-master-down-by-addr命令，从而询问其他哨兵对主节点主观下线的判断结果的，并且会根据命令回复结果，在结果处理函数sentinelReceiveIsMasterDownReply中，设置其他哨兵的flags为SRI_MASTER_DOWN。下图也展示了这个执行逻辑，你可以再来整体回顾下。</p><p></p><p><img src=\"https://static001.geekbang.org/resource/image/51/7f/51c98fec129byy830c8878466c95337f.jpg?wh=1920x978\" alt=\"图片\"></p><p>那么，掌握了这个执行逻辑后，我们再来看下，哨兵选举是什么时候开始执行的。</p><p></p><h2>哨兵选举</h2><p>这里，为了了解哨兵选举的触发，我们先来复习下在上节课，我讲过的sentinelHandleRedisInstance函数中针对主节点的调用关系，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/27/f7/276ee9fb08acf2405aa24b4658387df7.jpg?wh=1920x1042\" alt=\"图片\"></p><p>从图中可以看到，sentinelHandleRedisInstance会先调用sentinelCheckObjectivelyDown函数，再调用sentinelStartFailoverIfNeeded函数，判断是否要开始故障切换，如果sentinelStartFailoverIfNeeded函数的返回值为<strong>非0值</strong>，那么sentinelAskMasterStateToOtherSentinels函数会被调用。否则的话，sentinelHandleRedisInstance就直接调用sentinelFailoverStateMachine函数，并再次调用sentinelAskMasterStateToOtherSentinels函数。</p><p></p><p>那么，在这个调用关系中，sentinelStartFailoverIfNeeded会判断是否要进行故障切换，它的<strong>判断条件</strong>有三个，分别是：</p><ul>\n<li>主节点的flags已经标记了SRI_O_DOWN；</li>\n<li>当前没有在执行故障切换；</li>\n<li>如果已经开始故障切换，那么开始时间距离当前时间，需要超过sentinel.conf文件中的sentinel failover-timeout配置项的2倍。</li>\n</ul><p></p><p>这三个条件都满足后，sentinelStartFailoverIfNeeded就会调用<strong>sentinelStartFailover函数</strong>，开始启动故障切换，而sentinelStartFailover会将主节点的failover_state设置为SENTINEL_FAILOVER_STATE_WAIT_START，同时在主节点的flags设置SRI_FAILOVER_IN_PROGRESS标记，表示已经开始故障切换，如下所示：</p><pre><code class=\"language-plain\">void sentinelStartFailover(sentinelRedisInstance *master) {\n…\nmaster-&gt;failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;\nmaster-&gt;flags |= SRI_FAILOVER_IN_PROGRESS;\n…\n}\n</code></pre><p>而一旦sentinelStartFailover函数将主节点的failover_state设置为SENTINEL_FAILOVER_STATE_WAIT_START后，接下来，sentinelFailoverStateMachine函数就会执行状态机来完成实际的切换。不过，<strong>在实际切换前，sentinelAskMasterStateToOtherSentinels函数会被调用。</strong></p><p></p><p>看到这个调用关系，你可能会有个疑问：sentinelAskMasterStateToOtherSentinels函数是用来向其他哨兵询问对主节点主观下线的判断结果的，如果sentinelStartFailoverIfNeeded判断要开始执行故障切换，那么为什么还要调用sentinelAskMasterStateToOtherSentinels函数呢？</p><p></p><p>其实，这就和sentinelAskMasterStateToOtherSentinels函数的另一个作用有关了，这个函数除了会用来向其他哨兵询问对主节点状态的判断，它还可以用来<strong>向其他哨兵发起Leader选举</strong>。</p><p></p><p>在刚才给你介绍这个函数时，我提到它会给其他哨兵发送sentinel is-master-down-by-addr命令，这个命令包括主节点IP、主节点端口号、当前纪元（sentinel.current_epoch）和实例ID。其中，如果主节点的failover_state已经不再是SENTINEL_FAILOVER_STATE_NONE，那么实例ID会被设置为当前哨兵的ID。</p><p></p><p>而在sentinel命令处理函数中，如果检测到sentinel命令中的实例ID不为*号，那么就会调用<strong>sentinelVoteLeader函数</strong>来进行Leader选举。</p><pre><code class=\"language-plain\">//当前实例为主节点，并且sentinel命令的实例ID不等于*号\nif (ri &amp;&amp; ri-&gt;flags &amp; SRI_MASTER &amp;&amp; strcasecmp(c-&gt;argv[5]-&gt;ptr,\"*\")) {\n&nbsp;&nbsp; //调用sentinelVoteLeader进行哨兵Leader选举\n&nbsp;&nbsp; leader = sentinelVoteLeader(ri,(uint64_t)req_epoch, c-&gt;argv[5]-&gt;ptr,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;leader_epoch);\n}\n</code></pre><p>下面，我们来具体了解下这个sentinelVoteLeader函数。</p><h3>sentinelVoteLeader函数</h3><p>sentinelVoteLeader函数会实际执行投票逻辑，这里我通过一个例子来给你说明。</p><p></p><p>假设哨兵A判断主节点master客观下线了，它现在向哨兵B发起投票请求，哨兵A的ID是req_runid。那么哨兵B在执行sentinelVoteLeader函数时，这个函数会判断哨兵A的纪元（req_epoch）、哨兵B的纪元（sentinel.current_epoch），以及master记录的Leader的纪元（master-&gt;leader_epoch）。按照Raft协议的定义，哨兵A就是Candidate节点，而哨兵B就是Follower节点。</p><p></p><p>我在上节课给你介绍Raft协议时有提到过，Candidate发起投票都是有轮次记录的，Follower在一轮投票中只能投一票。这里的纪元正是起到了<strong>轮次记录</strong>的作用。而sentinelVoteLeader函数判断纪元也是按照Raft协议的要求，让Follower在一轮中只能投一票。</p><p></p><p>那么，<strong>sentinelVoteLeader函数让哨兵B投票的条件是</strong>：master记录的Leader的纪元小于哨兵A的纪元，同时，哨兵A的纪元要大于或等于哨兵B的纪元。这两个条件保证了哨兵B还没有投过票，否则的话，sentinelVoteLeader函数就直接返回当前master中记录的Leader ID了，这也是哨兵B之前投过票后记录下来的。</p><p></p><p>下面的代码展示了刚才介绍的这部分逻辑，你可以看下。</p><pre><code class=\"language-plain\">if (req_epoch &gt; sentinel.current_epoch) {\n&nbsp;&nbsp; sentinel.current_epoch = req_epoch;\n&nbsp;&nbsp; …\n&nbsp;&nbsp; sentinelEvent(LL_WARNING,\"+new-epoch\",master,\"%llu\",\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (unsigned long long) sentinel.current_epoch);\n}\n&nbsp;\nif (master-&gt;leader_epoch &lt; req_epoch &amp;&amp; sentinel.current_epoch &lt;= req_epoch)\n{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sdsfree(master-&gt;leader);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; master-&gt;leader = sdsnew(req_runid);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; master-&gt;leader_epoch = sentinel.current_epoch;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; …\n}\nreturn master-&gt;leader ? sdsnew(master-&gt;leader) : NULL;\n</code></pre><p>那么现在，你就了解了sentinelVoteLeader函数是如何使用纪元判断来按照Raft协议完成哨兵Leader选举的了。</p><p>接下来，发起投票的哨兵仍然是通过sentinelReceiveIsMasterDownReply函数来处理其他哨兵对Leader投票的返回结果。这个返回结果，就像刚才给你介绍的，它的第二、三部分内容是哨兵Leader的ID，和哨兵Leader所属的纪元。发起投票的哨兵就可以从这个结果中获得其他哨兵对Leader的投票结果了。</p><p>最后，发起投票的哨兵在调用了sentinelAskMasterStateToOtherSentinels函数让其他哨兵投票后，会执行sentinelFailoverStateMachine函数。</p><p>如果主节点开始执行故障切换了，那么，主节点的failover_state，会被设置成SENTINEL_FAILOVER_STATE_WAIT_START。在这种状态下，sentinelFailoverStateMachine函数会调用sentinelFailoverWaitStart函数。而sentinelFailoverWaitStart函数，又会调用sentinelGetLeader函数，来判断发起投票的哨兵是否为哨兵Leader。发起投票的哨兵要想成为Leader，必须满足两个条件：</p><ul>\n<li>一是，获得超过半数的其他哨兵的赞成票</li>\n<li>二是，获得超过预设的quorum阈值的赞成票数。</li>\n</ul><p>这两个条件，也可以从sentinelGetLeader函数中的代码片段看到，如下所示。</p><pre><code class=\"language-plain\">//voters是所有哨兵的个数，max_votes是获得的票数\n&nbsp;voters_quorum = voters/2+1;  //赞成票的数量必须是超过半数以上的哨兵个数\n//如果赞成票数不到半数的哨兵个数或者少于quorum阈值，那么Leader就为NULL\n&nbsp;if (winner &amp;&amp; (max_votes &lt; voters_quorum || max_votes &lt; master-&gt;quorum))\n&nbsp; &nbsp; &nbsp; &nbsp; winner = NULL;\n//确定最终的Leader\nwinner = winner ? sdsnew(winner) : NULL;\n</code></pre><p>下图就展示了刚才介绍的确认哨兵Leader时的调用关系，你可以看下。</p><p><img src=\"https://static001.geekbang.org/resource/image/19/52/192b72d0cf77cfefee8e26952b4f1652.jpg?wh=1920x839\" alt=\"图片\"></p><p>好了，到这里，最终的哨兵Leader就能被确定了。</p><p></p><h2>小结</h2><p>好了，今天这节课的内容就到这里，我们来小结下。</p><p></p><p>今天这节课，我在上节课的基础上，重点给你介绍了哨兵工作过程中的客观下线判断，以及Leader选举。因为这个过程涉及哨兵之间的交互询问，所以并不容易掌握，你需要好好关注以下我提到的重点内容。</p><p></p><p>首先，客观下线的判断涉及三个标记的判断，分别是主节点flags中的SRI_S_DOWN和SRI_O_DOWN，以及哨兵实例flags中的SRI_MASTER_DOWN，我画了下面这张表，展示了这三个标记的设置函数和条件，你可以再整体回顾下。</p><p><img src=\"https://static001.geekbang.org/resource/image/73/1f/738ea2375d2e302bb6742fa825650b1f.jpg?wh=1920x1027\" alt=\"图片\"></p><p>而一旦哨兵判断主节点客观下线了，那么哨兵就会<strong>调用sentinelAskMasterStateToOtherSentinels函数进行哨兵Leader选举</strong>。这里，你需要注意的是，向其他哨兵询问主节点主观下线状态，以及向其他哨兵发起Leader投票，都是通过sentinel is-master-down-by-addr命令实现的，而Redis源码是用了同一个函数sentinelAskMasterStateToOtherSentinels来发送该命令，所以你在阅读源码时，<strong>要注意区分sentinelAskMasterStateToOtherSentinels发送的命令是查询主节点主观下线状态还是进行投票</strong>。</p><p></p><p>最后，哨兵Leader选举的投票是在sentinelVoteLeader函数中完成的，为了符合Raft协议的规定，sentinelVoteLeader函数在执行时主要是要比较哨兵的纪元，以及master记录的Leader纪元，这样才能满足Raft协议对Follower在一轮投票中只能投一票的要求。</p><p>好了，到今天这节课，我们就了解了哨兵Leader选举的过程，你可以看到，虽然哨兵选举的最后执行逻辑就是在一个函数中，但是哨兵选举的触发逻辑是包含在了哨兵的整个工作过程中的，所以我们也需要掌握这个过程中的其他操作，比如主观下线判断、客观下线判断等。</p><p></p><h2>每课一问</h2><p>哨兵在sentinelTimer函数中调用sentinelHandleDictOfRedisInstances函数，对每个主节点都执行sentinelHandleRedisInstance函数，并且还会对主节点的所有从节点也执行sentinelHandleRedisInstance函数，那么，哨兵会判断从节点的主观下线和客观下线吗？</p>","comments":[{"had_liked":false,"id":314112,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1632842867,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"40287548531","product_id":100084301,"comment_content":"1、一个哨兵检测判定主库故障，这个过程是「主观下线」，另外这个哨兵还会向其它哨兵询问（发送 sentinel is-master-down-by-addr 命令），多个哨兵都检测主库故障，数量达到配置的 quorum 值，则判定为「客观下线」<br><br>2、首先判定为客观下线的哨兵，会发起选举，让其它哨兵给自己投票成为「领导者」，成为领导者的条件是，拿到超过「半数」的确认票 + 超过预设的 quorum 阈值的赞成票<br><br>3、投票过程中会比较哨兵和主库的「纪元」（主库纪元 &lt; 发起投票哨兵的纪元 + 发起投票哨兵的纪元 &gt; 其它哨兵的纪元），保证一轮投票中一个哨兵只能投一次票<br><br>课后题：哨兵在 sentinelTimer 函数中调用 sentinelHandleDictOfRedisInstances 函数，对每个主节点都执行 sentinelHandleRedisInstance 函数，并且还会对主节点的所有从节点也执行 sentinelHandleRedisInstance 函数，那么，哨兵会不会判断从节点的主观下线和客观下线？<br><br>sentinelHandleRedisInstance 函数逻辑如下：<br><br>void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {<br>    ...<br><br>    &#47;* Every kind of instance *&#47;<br>    &#47;&#47; 判断主观下线<br>    sentinelCheckSubjectivelyDown(ri);<br><br>    ...<br><br>    &#47;* Only masters *&#47;<br>    if (ri-&gt;flags &amp; SRI_MASTER) {<br>        &#47;&#47; 判断客观下线<br>        sentinelCheckObjectivelyDown(ri);<br>        if (sentinelStartFailoverIfNeeded(ri))<br>            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);<br>        sentinelFailoverStateMachine(ri);<br>        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);<br>    }<br>}<br><br>可以看到，无论主库还是从库，哨兵都判断了「主观下线」，但只有主库才判断「客观下线」和「故障切换」。","like_count":10,"discussions":[{"author":{"id":1519415,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/dr34H3hOMVsibL0XV1iaBWFiaTnYssX8sNjmJDpiaBUVv2X39nFzDjNpe288cKkZfH3P9sVRxZ1lzYZEcRR3vJNYtA/132","nickname":"Benson_Geek","note":"","ucode":"D95B5C2BA09961","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541533,"discussion_content":"大佬，这里这个“主库纪元”是个啥啊。为啥哨兵之间的投票需要涉及到主库的纪元啊？\n不应该就投票时，哨兵本身的epch+1，然后向其他的哨兵发起投票，其他哨兵收到后，直接判断他自己的epoch是否比请求投票的哨兵带过来的epoch值要小，是的话就投给他吗？想不懂为何要用这个什么“主库纪元”啊。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640436331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":314118,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1632848178,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27402651954","product_id":100084301,"comment_content":"首先回到老师的问题：哨兵会判断从节点的主观下线和客观下线吗？<br>答:根据代码，我认为只会判断主观下线，并且在当前实例中，主观下线的slave实例是不能被选举的。<br><br>1、首先我们会发现在sentinelHandleDictOfRedisInstances函数中是存在递归调用的，当发现传入的instances是master的时候会继续对其slaves和sentinels进行递归调用，代码如下：<br>        if (ri-&gt;flags &amp; SRI_MASTER) {<br>            &#47;&#47;对哨兵和slaves都进行判断<br>            sentinelHandleDictOfRedisInstances(ri-&gt;slaves);<br>            sentinelHandleDictOfRedisInstances(ri-&gt;sentinels);<br>            if (ri-&gt;failover_state == SENTINEL_FAILOVER_STATE_UPDATE_CONFIG) {<br>                switch_to_promoted = ri;<br>            }<br>        }<br><br><br>2、但是在调用sentinelHandleRedisInstance中的时候，只有msater才会进行【客观下线】判断，而其他实例只会进行【主观下线】判断<br><br>调用路径如下：<br>    master实例: sentinelHandleRedisInstance -&gt; sentinelCheckSubjectivelyDown -&gt; sentinelCheckObjectivelyDown<br>    其它实例: sentinelHandleRedisInstance -&gt; sentinelCheckSubjectivelyDown<br><br>在sentinelHandleRedisInstance中判断【客观下线】的代码如下所示：<br>        &#47;* Only masters 只有master才执行 *&#47;<br>        if (ri-&gt;flags &amp; SRI_MASTER) {<br>            &#47;&#47;判断客观下线<br>            sentinelCheckObjectivelyDown(ri);<br>            if (sentinelStartFailoverIfNeeded(ri))<br>                sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);<br>            &#47;&#47;调用状态机方法<br>            sentinelFailoverStateMachine(ri);<br>            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);<br>        }<br><br>3、已经被标记了主观下线的slave，在执行sentinelSelectSlave的时候会直接跳过，我理解是在当前投票实例的角度，如果某个slave是主观下线的，它在该实例的投票是不能参选的，当前所处的状态机状态是 SENTINEL_FAILOVER_STATE_SELECT_SLAVE。<br>    代码如下：<br>    while((de = dictNext(di)) != NULL) {<br>        sentinelRedisInstance *slave = dictGetVal(de);<br>        mstime_t info_validity_time;<br>        &#47;&#47;被标记主观下线或者客观下线的直接跳过<br>        if (slave-&gt;flags &amp; (SRI_S_DOWN|SRI_O_DOWN)) continue;<br>        ...........<br>        instance[instances++] = slave;<br>    }<br>    ......<br>    if (instances) {<br>        &#47;&#47;先按照优先级排序<br>        &#47;&#47;如果优先级一样再按照 slave_repl_offset 来进行排序（选延迟最小的）<br>        qsort(instance,instances,sizeof(sentinelRedisInstance*),<br>            compareSlavesForPromotion);<br>        selected = instance[0];<br>    }<br>","like_count":6},{"had_liked":false,"id":346319,"user_name":"e⃰v⃰a⃰n⃰","can_delete":false,"product_type":"c1","uid":2988699,"ip_address":"","ucode":"13A98516756517","user_header":"https://static001.geekbang.org/account/avatar/00/2d/9a/9b/cc08f6b3.jpg","comment_is_top":false,"comment_ctime":1653020947,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1653020947","product_id":100084301,"comment_content":"我想问假如master宕机了，直接在其他的从节点中随机一个做为主节点不就行了吗？为啥还要选举？选举也是随机啊！","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":581566,"discussion_content":"选举是为了达成共识，就像选主席，每个副主席都说选自己，怎么才能统一呢，当然是投票\n或者换句话说，你说的随机取一个做为主节点，那由谁来做这个随机取的动作呢？选出这个“谁”是不是又绕回去了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658841876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1137910,"avatar":"https://static001.geekbang.org/account/avatar/00/11/5c/f6/443808f8.jpg","nickname":"孤独患者","note":"","ucode":"4CDD797F355F99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576965,"discussion_content":"好问题！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655867657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339509,"user_name":"Jian","can_delete":false,"product_type":"c1","uid":1107305,"ip_address":"","ucode":"17ED4919F22DEC","user_header":"https://static001.geekbang.org/account/avatar/00/10/e5/69/719ec5d0.jpg","comment_is_top":false,"comment_ctime":1648144606,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648144606","product_id":100084301,"comment_content":"硬是对了代码看了3遍才看懂：）","like_count":1},{"had_liked":false,"id":327990,"user_name":"Benson_Geek","can_delete":false,"product_type":"c1","uid":1519415,"ip_address":"","ucode":"D95B5C2BA09961","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dr34H3hOMVsibL0XV1iaBWFiaTnYssX8sNjmJDpiaBUVv2X39nFzDjNpe288cKkZfH3P9sVRxZ1lzYZEcRR3vJNYtA/132","comment_is_top":false,"comment_ctime":1640436111,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1640436111","product_id":100084301,"comment_content":"master 记录的 Leader 的纪元（master-&gt;leader_epoch）<br>求问这个到底是什么东西。。。。。。。。。。。。。。。。。。。。。。。。。救命","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":553203,"discussion_content":"1、首先你要知道，sentinel是可以监听多个主服务器的，内部维护了一个masters列表；\n2、sentinel在接收到is-master-down-by-addr命令后会根据命令中的ip端口信息找到对应的master，即找到这次选举是为了给哪个master做的，而这个master结构体中有2个主要字段：leader和leader_epoch，表示这个sentinel节点在对于这个master的故障选举中，已经给master-&gt;leader投过票了，且纪元是master-&gt;leader_epoch\n3、由raft协议可知：在一个纪元内，如果某个follower已经为其他节点投过票，或者请求投票的纪元小于已经投过的纪元（leader_epoch），则不再投票，所以就有文中的“让哨兵 B 投票的条件是：master 记录的 Leader 的纪元小于哨兵 A 的纪元，同时，哨兵 A 的纪元要大于或等于哨兵 B 的纪元。这两个条件保证了哨兵 B 还没有投过票”\n4、如果满足了上面那个条件，则会执行投票，而投票执行的操作正是修改master-&gt;leader和master-&gt;leader_epoch","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1645764508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043475,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ec/13/49e98289.jpg","nickname":"neohope","note":"","ucode":"C0268F6E7E2B6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558103,"discussion_content":"投票的轮次而已","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648093944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2542376,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/28/21a8a29e.jpg","nickname":"夏天","note":"","ucode":"5F224DDAC94DFF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552107,"discussion_content":"理解为版本号吧，纪元翻译的不好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645284602,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}