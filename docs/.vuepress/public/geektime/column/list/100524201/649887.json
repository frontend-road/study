{"id":649887,"title":"29｜最短路径：迪杰斯特拉（Dijkstra）算法与选择最节省时间的行走路线问题","content":"<p>你好，我是王健伟。</p><p>前面我们讲解了用普里姆<span class=\"reference\">（Prim）</span>算法和克鲁斯卡尔<span class=\"reference\">（Kruskal）</span>算法来寻找连通图的最小生成树，从而解决诸如如何修路费用最少这样的问题。这次我和你分享图的第二个实际用途——<strong>最短路径</strong>。那么，什么是最短路径呢？</p><h2>最短路径</h2><p>在带权图中，最短路径指的是图中两个顶点之间经过的边上权值之和最小的路径。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/51/8f76ae30f6a6605f006dbc3f8bec4251.jpg?wh=1333x545\" alt=\"\" title=\"图1 一个有向图（带权值）\"></p><p>在图1中，顶点A到E之间的路径有多条，这里我举几个例子。</p><ul>\n<li>A→B→E，顶点A到E的边上权值之和为122。</li>\n<li>A→D→C→E，顶点A到E的边上权值之和为66。</li>\n<li>A→D→B→E，顶点A到E的边上权值之和为116。</li>\n<li>A→D→C→B→E，顶点A到E的边上权值之和为176。</li>\n<li>A→D→C→F→E，顶点A到E的边上权值之和为71。</li>\n</ul><p>可以看到，A→D→C→E所代表的的路径就是最短路径，权值之和为66。那么对于一个带权有向图，给定一个顶点，如何求得该顶点到其余各个顶点的最短路径呢？其实这个问题也适用于带权无向图，因为带权无向图中的每条边就相当于带权有向图方向相反的两条边。</p><p>如果采用带权的邻接矩阵作为图1中有向图的存储结构，则结果如图2所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e3/ef/e3ce01315591a197f89ec245b1bbabef.jpg?wh=1256x703\" alt=\"\" title=\"图2  图1所示有向图对应的带权邻接矩阵\"></p><h2>迪杰斯特拉（Dijkstra）算法详解</h2><p>荷兰籍的一位计算机科学家、计算机先驱之一迪杰斯特拉提出了一个按路径长度递增的次序产生最短路径的算法，称为迪杰斯特拉算法。以图1为例，我们看一看该算法的实现思路。</p><!-- [[[read_end]]] --><ol>\n<li>设置一个<strong>集合S</strong>用于存放已经找到最短路径的顶点，该集合开始时只包含给定的第一个顶点。这个顶点也叫<strong>源顶点/起始顶点</strong>。我们就是要从该顶点找到其余各个顶点的最短路径。这里先把顶点A保存进去，这预示着从源顶点A开始已经找到了到目标顶点A的最短路径，毕竟本来这两个点就是同一个点。</li>\n</ol><center>S = {A}</center><p>设置一个叫<strong>dist</strong>的数组，元素数量等同于图中顶点数量。该数组用于存放当前起始点到其他各个顶点的<strong>最短距离</strong><span class=\"reference\">（权值最小）</span>，开始时该数组的内容就是图2中源顶点A所在行的值，即{0,22,∞,6,∞,∞}，因为这组数据正好代表源顶点A到其他各个顶点的距离。</p><p>设置一个叫<strong>path</strong>的数组，元素数量等同于图中的顶点数量。该数组用于记录每个顶点在最短路径上的前趋节点，里面的内容需要根据dist中的内容得出， dist中对应下标位置是0或∞，则path对应位置是-1。如果dist中对应下标位置有权值，那么path对应位置是源顶点的下标，所以开始时该数组内容为{-1,0,-1,0,-1,-1}。</p><ol start=\"2\">\n<li>开始计算从源顶点A到<strong>不在集合S中</strong>的顶点的最短路径。</li>\n</ol><p>A→B : 距离=22</p><p>A→C : 距离=∞<span class=\"reference\"> （∞表示A到C之间不直接相连）</span></p><p>A→D : 距离=6</p><p>A→E : 距离=∞</p><p>A→F : 距离=∞</p><p>现在，得到了从顶点A到其他所有顶点的路径长度。我们从其中选出一条最短的路径，即：</p><p><strong>A→D : 距离=6</strong></p><p>并把顶点D也放入到集合S中，表示源顶点A到顶点D的最短路径已找到，如图3：</p><p>S = {A，<strong>D</strong>}</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/0e/2bb97599e42fa9829a7bca40507c6b0e.jpg?wh=1103x597\" alt=\"\" title=\"图3 选择与源顶点A最短的路径A→D\"></p><ol start=\"3\">\n<li>在增加了<strong>D</strong>顶点到集合后，顶点A（<strong>经过顶点D</strong>）到其他所有顶点是不是有更短的路径存在呢？</li>\n</ol><p>这主要得看顶点D到达哪些顶点，根据图2，顶点D对应的行数字是{∞,10,20,0,∞,∞}，这表示顶点D可以到达顶点B、C。<strong>注意这里要求顶点D到达的目标顶点必须不能包含在集合S中</strong>，所以看一下顶点A通过顶点D到达顶点B和到达顶点C的距离：</p><p>A→B : 距离=(6+10)=16<span class=\"reference\">（通过A→D→B路径）</span></p><p>A→C : 距离=(6+20)=26<span class=\"reference\">（通过A→D→C路径）</span></p><p>因为原来的顶点A到达顶点B和顶点C的距离是保存在dist数组的，dist数组当前内容为{0,22,∞,6,∞,∞}。可以看到，原来A→B的距离是22，A→C的距离是∞，而现在A→B和A→C的距离明显变得更小了，所以我们要更新dist数组中源顶点A到达顶点B和顶点C的距离，来保证dist数组中始终保存着源顶点A到其他各个顶点的<strong>最短距离</strong>。更新后dist数组的内容为{0,<strong>16,26</strong>,6,∞,∞}，这表示下面两个情况。</p><ul>\n<li>源顶点A到达顶点B的最短距离为16。</li>\n<li>源顶点A到达顶点C的最短距离为26。</li>\n</ul><p>因为上述找最短路径找到了D顶点<span class=\"reference\">（下标3）</span>，dist数组中有两个位置做了修改，path数组也要在相应位置做修改，即path数组中的内容也从原来的{-1,0,-1,0,-1,-1}更新为{-1,<strong>3,3</strong>,0,-1,-1}，这表示什么呢？</p><ul>\n<li>源顶点A到达顶点B是通过顶点D到达的<span class=\"reference\">（B的上一个顶点是D）</span>。</li>\n<li>源顶点A到达顶点C也是通过顶点D到达的<span class=\"reference\">（C的上一个顶点是D）</span>。</li>\n</ul><ol start=\"4\">\n<li>整理一下源顶点到其他顶点的距离信息：</li>\n</ol><p>A→B : 距离=16<span class=\"reference\">（通过A→D→B路径）</span></p><p>A→C : 距离=26<span class=\"reference\">（通过A→D→C路径）</span></p><p>A→D : 距离=6</p><p>A→E : 距离=∞</p><p>A→F : 距离=∞</p><p>因为顶点D已经在集合S中了，所以A→D这条路径就不考虑了，从其余的4条路径中选出一条最短的路径，注意，这4条路径的弧头顶点还没有找到从源顶点A到它们的最短路径。所以：</p><p><strong>A→B : 距离=16<span class=\"reference\">（通过A→D→B路径）</span></strong></p><p>并把顶点B也放入到集合S中，表示源顶点A到顶点B的最短路径已找到，如图4：</p><p>S = {A，D，<strong>B</strong>}</p><p><img src=\"https://static001.geekbang.org/resource/image/01/89/011d148e7f45d7c013d9076ba713e389.jpg?wh=1093x601\" alt=\"\" title=\"图4 选择与源顶点A最短的路径A→B（A→D→B）\"></p><ol start=\"5\">\n<li>在增加了B顶点到集合后，顶点A（<strong>经过顶点B</strong>）到其他所有顶点是不是有更短的路径存在呢？</li>\n</ol><p>这主要得看顶点B到达哪些顶点。根据图2，顶点B对应的行数字是{∞,0,∞,∞,100,∞}，这表示顶点B可以到达顶点E。<strong>注意这里要求顶点B到达的目标顶点必须不能包含在集合S中</strong><strong>。</strong>所以看一下顶点A通过顶点B到达顶点E的距离：</p><p>A→E : 距离=(6+10+100)=116<span class=\"reference\">（通过A→D→B→E路径）</span></p><p>dist数组当前内容为{0,16,26,6,∞,∞}，更新后dist数组的内容为{0,16,26,6,<strong>116</strong>,∞}，path数组当前的内容为{-1,3,3,0,-1,-1}，更新后path数组的内容为{-1,3,3,0,<strong>1</strong>,-1}。</p><ol start=\"6\">\n<li>整理一下源顶点到其他顶点的距离信息：</li>\n</ol><p>A→B : 距离=16<span class=\"reference\">（通过A→D→B路径）</span></p><p>A→C : 距离=26<span class=\"reference\">（通过A→D→C路径）</span></p><p>A→D : 距离=6</p><p>A→E : 距离=116<span class=\"reference\">（通过A→D→B→E路径）</span></p><p>A→F : 距离=∞</p><p>因为顶点D、B已经在集合S中了，所以A→D、A→B这两条路径就不考虑了，从其余的3条路径中选出一条最短的路径，即：</p><p><strong>A→C : 距离=26<span class=\"reference\">（通过A→D→C路径）</span></strong></p><p>并把顶点C也放入到集合S中，表示源顶点A到顶点C的最短路径已找到，如图5：</p><p>S = {A，D，B，C}</p><p><img src=\"https://static001.geekbang.org/resource/image/08/13/086880442a68e99440675b9c52ba3313.jpg?wh=1099x552\" alt=\"\" title=\"图5 选择与源顶点A最短的路径A→C（A→D→C）\"></p><ol start=\"7\">\n<li>在增加了C顶点到集合后，顶点A（<strong>经过顶点C</strong>）到其他所有顶点是不是有更短的路径存在呢？</li>\n</ol><p>这主要得看顶点C到达哪些顶点，根据图2，顶点C对应的行数字是{∞,50,0,∞,40,10}，这表示顶点C可以到达顶点B、E、F。<strong>注意这里要求顶点C到达的目标顶点必须不能包含在集合S中</strong>，所以只需要看一下顶点A通过顶点C到达顶点E、F的距离：</p><p>A→E : 距离=(6+20+40)=66<span class=\"reference\">（通过A→D→C→E路径）</span></p><p>A→F: 距离=(6+20+10)=36<span class=\"reference\">（通过A→D→C→F路径）</span></p><p>dist数组当前内容为{0,16,26,6,116,∞}，更新后dist数组的内容为{0,16,26,6,<strong>66,36</strong>}，path数组当前的内容为{-1,3,3,0,-1,-1}，更新后path数组的内容为{-1,3,3,0,<strong>2,2</strong>}。</p><ol start=\"8\">\n<li>整理一下源顶点到其他顶点的距离信息：</li>\n</ol><p>A→B : 距离=16<span class=\"reference\">（通过A→D→B路径）</span></p><p>A→C : 距离=26<span class=\"reference\">（通过A→D→C路径）</span></p><p>A→D : 距离=6</p><p>A→E : 距离=66<span class=\"reference\">（通过A→D→C→E路径）</span></p><p>A→F : 距离=36<span class=\"reference\">（通过A→D→C→F路径）</span></p><p>因为顶点D、B、C已经在集合S中了，所以A→D、A→B、A→C这3条路径就不考虑了，从其余的2条路径中选出一条最短的路径，即：</p><p><strong>A→F : 距离=36<span class=\"reference\">（通过A→D→C→F路径）</span></strong></p><p>并把顶点F也放入到集合S中，表示源顶点A到顶点F的最短路径已找到，如图6：</p><p>S = {A，D，B，C，<strong>F</strong>}</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/a6/fe2b3fae01d7b070cfd9864b62812aa6.jpg?wh=1109x551\" alt=\"\" title=\"图6 选择与源顶点A最短的路径A→F（A→D→C→F）\"></p><ol start=\"9\">\n<li>在增加了F顶点到集合后，顶点A（<strong>经过顶点F</strong>）到其他所有顶点是不是有更短的路径存在呢？</li>\n</ol><p>这主要得看顶点F到达哪些顶点，根据图2，顶点F对应的行数字是{∞,∞,∞,65,35,∞}，这表示顶点F可以到达顶点D、E。<strong>注意这里要求顶点F到达的目标顶点必须不能包含在集合S中</strong>，所以只需要看一下顶点A通过顶点F到达顶点E的距离：</p><p>A→E : 距离=(6+20+10+35)=71<span class=\"reference\">（通过A→D→C→F→E路径）</span></p><p>这个距离比原来A→E的距离更远，所以忽略。</p><p>dist数组维持当前内容{0,16,26,6,66,36}，path数组维持当前内容{-1,3,3,0,2,2}。</p><ol start=\"10\">\n<li>整理一下源顶点到其他顶点的距离信息：</li>\n</ol><p>A→B : 距离=16<span class=\"reference\">（通过A→D→B路径）</span></p><p>A→C : 距离=26<span class=\"reference\">（通过A→D→C路径）</span></p><p>A→D : 距离=6</p><p>A→E : 距离=66<span class=\"reference\">（通过A→D→C→E路径）</span></p><p>A→F : 距离=36<span class=\"reference\">（通过A→D→C→F路径）</span></p><p>因为顶点D、B、C、F已经在集合S中了，所以A→D、A→B、A→C、A→F这4条路径就不考虑了，只剩下也只能选择如下路径，即：</p><p><strong>A→E : 距离=66<span class=\"reference\">（通过A→D→C→E路径）</span></strong></p><p>并把顶点E也放入到集合S中，表示源顶点A到顶点E的最短路径已找到，如图7：</p><p>S = {A，D，B，C，F，<strong>E</strong>}</p><p><img src=\"https://static001.geekbang.org/resource/image/9d/e3/9d80928141d997ab1092e5abf1b45ae3.jpg?wh=1137x580\" alt=\"\" title=\"图7 选择与源顶点A最短的路径A→E（A→D→C→E）\"></p><ol start=\"11\">\n<li>在增加了E顶点到集合后，顶点A<strong>（经过顶点E）</strong>到其他所有顶点是不是有更短的路径存在呢？ 没有。因为顶点E没有到达任何其他顶点。</li>\n</ol><p>至此，集合S中已经包含了图中的所有顶点，迪杰斯特拉算法结束。此时：</p><p>dist数组内容为：{0,16,26,6,66,36}</p><p>path数组内容为：{-1,3,3,0,2,2}</p><p>通过上面两个数组的内容，就可以分析出从源顶点A到其他顶点的最短路径。那么我们来看两个更具体的问题。</p><ul>\n<li><strong>如何得到从源顶点A到顶点B的最短路径长度？</strong></li>\n</ul><p>第一就是查找dist数组，查找下标为1（顶点B）的元素值，发现是16，这意味着从顶点A到顶点B的最短路径长度是16。第二就是看path数组以获得从顶点A到顶点B的最短路径“path[1] = 3；path[3]=0；”，因为0代表顶点A即源顶点，找到源顶点之后，就可以得到结果了，以反序将刚刚path数组的结果输出就是最短路径，即0→3，这些数字代表顶点的下标，所以，顶点A到B的最短路径如图8所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/b6/e4/b68dc31ded9f64ebba725d49cc5375e4.jpg?wh=1174x596\" alt=\"\" title=\"图8 源顶点A顶点B的最短路径（A→D→B）\"></p><ul>\n<li><strong>如何查找从源顶点A到顶点E的最短路径长度？</strong></li>\n</ul><p>第一就是查找dist数组，查找下标为4<span class=\"reference\">（顶点E）</span>的元素值，发现是66，这意味着从顶点A到顶点E的最短路径长度是66。第二就是看path数组以获得从顶点A到顶点E的最短路径“path[4] = 2；path[2] = 3；path[3] = 0”，因为0代表顶点A即源顶点，找到源顶点之后，就可以得到结果了，以反序将刚刚path数组的结果输出就是最短路径，即0→3→2，这些数字代表顶点的下标，所以，顶点A到E的最短路径如图9所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/ff/e8881fd4afd7d6290d062e40784422ff.jpg?wh=1056x575\" alt=\"\" title=\"图9 源顶点A顶点E的最短路径（A→D→C→E）\"></p><p>想一想，为什么通过查找path数组就可以找到最短路径呢？这是因为在每次更改dist数组后都会在path数组中记录当前顶点的上一个顶点是谁。所以利用倒推的方式就可以把路径推导出来。</p><p>完整的实现迪杰斯特拉（Dijkstra）算法的类模板相关源码，参见<a href=\"https://gitee.com/jianw_wang/geektime_cpp_dsa/blob/master/31%EF%BD%9C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%9A%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%EF%BC%88Dijkstra%EF%BC%89%E7%AE%97%E6%B3%95%E4%B8%8E%E9%80%89%E6%8B%A9%E6%9C%80%E8%8A%82%E7%9C%81%E6%97%B6%E9%97%B4%E7%9A%84%E8%A1%8C%E8%B5%B0%E8%B7%AF%E7%BA%BF%E9%97%AE%E9%A2%98/MyProject.cpp\">课件</a>中GraphMatrix类模板的定义与实现。这里我们重点看其中的ShortestPath_Dijkstra()成员函数的实现代码。</p><p>main主函数中代码如下：</p><pre><code class=\"language-plain\">GraphMatrix&lt;char&gt; gm;\ngm.InsertVertex('A');\ngm.InsertVertex('B');\ngm.InsertVertex('C');\ngm.InsertVertex('D');\ngm.InsertVertex('E');\ngm.InsertVertex('F');\n//向图中插入边\ngm.InsertEdge('A', 'B', 22); //22代表边的权值\ngm.InsertEdge('A', 'D', 6);\ngm.InsertEdge('B', 'E', 100);\ngm.InsertEdge('C', 'B', 50);\ngm.InsertEdge('C', 'E', 40);\ngm.InsertEdge('C', 'F', 10);\ngm.InsertEdge('D', 'B', 10);\t\ngm.InsertEdge('D', 'C', 20);\t\ngm.InsertEdge('F', 'D', 65);\ngm.InsertEdge('F', 'E', 35);\t\n\n//显示图形\ngm.DispGraph();\t\t\ngm.ShortestPath_Dijkstra('A');\n</code></pre><p>执行结果如下：<br>\n<img src=\"https://static001.geekbang.org/resource/image/82/41/820bc1a83f4b6cea6ca7067dea5da741.jpg?wh=1846x912\" alt=\"\"></p><p>从上述代码不难看到，迪杰斯特拉算法实现中使用的dist数组和前面讲过的普里姆算法中使用的lowcost数据非常类似。在实现代码中，采用了带权的邻接矩阵作为图的存储结构，算法中使用了双重循环，每重循环的循环次数都不会超过顶点数量，所以该算法的时间复杂度为O($|V|^{2}$)。</p><p>迪杰斯特拉算法解决了从某个源顶点到图中其余各顶点的最短路径问题。可能你会问了，是否能够找到图中某个顶点开始到另一个特定顶点的最短路径？</p><p>其实这样做和求某个顶点开始到其他所有顶点最短路径并没有区别，依然要采用迪杰斯特拉算法不断计算从开始顶点到其他<strong>各个</strong>顶点的最短距离，所以时间复杂度仍旧是O($|V|^{2}$)。所以，即便是寻找某两个点之间的最短路径，解决办法仍旧是选择其中一个作为源顶点，然后用迪杰斯特拉算法求出到其余顶点的最短路径，这些路径中肯定包含着到另外一个顶点的最短路径，除非这两个顶点之间不可达。</p><p>图的最短路径求解问题在实际生活中有非常实用的价值，应用广泛。比如城市公交或者城市地铁站都可以看作是一张图，其中的各个站点都可以看作是图中顶点。如果把全国交通图看成是一张图的话，那么各个城市就可以看作是图中的顶点。如图10所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6c/37/6c85cdc3696d502b245c4e4332c2e137.jpg?wh=1087x513\" alt=\"\" title=\"图10 国内城市交通图\"></p><p>在图10中，从一个城市到达另外一个城市有多种走法。</p><ul>\n<li>如果把城市之间的距离作为权值，利用最短路径算法，可以找到从某个城市去到另外一个城市如何走<strong>距离最短</strong>。</li>\n<li>如果把城市之间驱车所花费的时间作为权值，利用最短路径算法，可以找到从某个城市到另外一个城市如何走<strong>最节省时间</strong>。</li>\n<li>如果把城市之间坐车所花费的金钱作为权值，利用最短路径算法，可以求解出如何乘车<strong>花费的金钱最少</strong>。</li>\n</ul><h2>小结</h2><p>这节课我给出一个图来向你详细阐述<strong>最短路径</strong>的概念，然后提出了如何从某个顶点求得到其他各个顶点的最短路径的问题。从而引出了迪杰斯特拉（Dijkstra）算法——专门用来求从某个顶点到其他各个顶点最短路径的算法。</p><p>本节我用大量的篇幅阐述了迪杰斯特拉算法的详细实现过程，我们首先设置集合S来存放已经找到最短路径的顶点、设置dist数组存放当前起始点到其他各个顶点的最短距离、设置path数组记录每个顶点在最短路径上的前趋节点。然后阐述详细的算法步骤。</p><p>充分理解这些算法的实现步骤是后序能够写出迪杰斯特拉算法代码的根本，否则即便是阅读别人实现的迪杰斯特拉算法，也会一头雾水。接着，我带你完成了整个迪杰斯特拉算法的实现代码。</p><p>迪杰斯特拉算法解决了从某个源顶点到其余各顶点的最短路径问题，在实际生活中有非常实用的价值，比如我为你举的几个例子，分别是从某个城市到另一个城市如何走距离最短、如何走最节省时间、如何乘车花费的金钱最少等。你可以举一反三，仔细想想还有哪些实际生活中的问题可以用迪杰斯特拉算法解决呢？</p><h2>课后思考</h2><p>许多城市的地铁线路非常繁杂，以深圳为例，如图11所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/63/aa/63ffac4523ac0137cb047b804ec4fcaa.png?wh=560x368\" alt=\"图片\" title=\"图11 深圳地铁线路图\"></p><p>目前深圳地铁已经开通运营了10几条线路。对于一些行动不便的老人或者残障人士，乘坐地铁时，如果目的地特别远并且要换乘多次地铁才能达到，则经常希望换乘的次数尽可能少。怎样做到呢？</p>","comments":[{"had_liked":false,"id":377798,"user_name":"Yj.yolo","can_delete":false,"product_type":"c1","uid":2814082,"ip_address":"广东","ucode":"0ED1B41F124061","user_header":"https://static001.geekbang.org/account/avatar/00/2a/f0/82/f235d91d.jpg","comment_is_top":false,"comment_ctime":1689232341,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100524201,"comment_content":"【课后思考题】如果希望换乘次数很少，则应该考虑的是节点个数，即将①起始站②可换乘的站③终点站  当作图中的节点，然后考虑起始站到终点站的路径中，节点数更少的路径。将迪杰斯特拉算法中的“距离数组”换成“经过的节点数数组”，同理，按照迪杰斯特拉最短距离比较思想，去维护“节点数组”中的数值。","like_count":0}]}