{"id":669233,"title":"03｜熔断：熔断-恢复-熔断-恢复，抖来抖去怎么办？","content":"<p>你好，我是大明。今天我们继续学习微服务架构，这节课我们讨论一个新的主题：熔断。</p><p>在微服务架构里面，熔断-限流-降级一般是连在一起讨论的，熔断作为微服务架构可用性保障的重要手段之一，是我们必须要掌握的，而且要能够说清楚自己在实践中是怎么利用熔断来提高系统的可用性的。</p><p>所以今天我就来给你梳理一下关于熔断有哪些知识是我们必须要掌握的，另外我还会在这个基础上给你提供一个全方位的熔断面试方案，帮助你在面试中脱颖而出。</p><h2>前置知识</h2><p>熔断在微服务架构里面是指当微服务本身出现问题的时候，它会拒绝新的请求，直到微服务恢复。</p><p><img src=\"https://static001.geekbang.org/resource/image/5c/3f/5cd51264668d564aa59b7c4630e3913f.png?wh=1920x716\" alt=\"图片\"></p><p>看图，你会不会觉得有点困惑？服务端明明返回了错误的响应，怎么还说熔断提高了系统的可用性呢？</p><p>答案就是<strong>熔断可以给服务端恢复的机会</strong>。试想这么一个场景，CPU 使用率已经100%了，服务端因此触发了熔断。那么拒绝了新来的请求之后，服务端的 CPU 使用率就会在一段时间内降到100%以内。</p><p>回到熔断的基本定义上来，我们可以提炼出两个点进一步讨论。</p><ul>\n<li>怎么判断微服务出现了问题？</li>\n<li>怎么知道微服务恢复了？</li>\n</ul><p>接下来我们要讨论的亮点也是围绕这两个方面来进行的。</p><h3>判定服务的健康状态</h3><p>第一个问题，判断微服务是否出现了问题，它有点儿像我们在负载均衡里面讨论的动态算法。本质上也是要求你根据自己的业务来选择一些指标，代表这个服务器的健康程度。比如说一般可以考虑使用响应时间、错误率。</p><!-- [[[read_end]]] --><p>不管选择什么指标，都要考虑两个因素：<strong>一是阈值如何选择；二是超过阈值之后，要不要持续一段时间才触发熔断。</strong></p><p>比如我们把响应时间作为指标，那么响应时间超过多少应该触发熔断呢？这是根据业务来决定的。比如说如果业务对响应时间的要求是在 1s 以内，那么你的阈值就可以设定在 1s，或者稍高一点，留点容错的余地也可以。</p><p>那么如果你的产品经理没跟你说这个业务对响应时间的要求，你就可以根据它的整体响应时间设定一个阈值，原则上阈值应该明显超过正常响应时间。比如你经过一段时间的观测之后，发现这个服务的 99 线是 1s，那么你可以考虑将熔断阈值设定为 1.2s。</p><p><img src=\"https://static001.geekbang.org/resource/image/4a/16/4a67fbc83dd9ab5743b103b4d6d7f016.png?wh=1920x1207\" alt=\"图片\"></p><p>那么是不是响应时间一旦超过了阈值就立刻熔断呢？一般也不是，而是<strong>要求响应时间超过一段时间之后才触发熔断</strong>。这主要是出于两个考虑，一个是响应时间可能是偶发性地突然增长；另外一个则是防止抖动。防止抖动这个问题后面我会和你进一步讨论。</p><p>那么这个“一段时间”究竟有多长，很大程度上就依赖个人经验了。如果时间过短，可能会频繁触发熔断，然后又恢复，再熔断，再恢复……反过来，如果时间过长，那就可能会导致该触发熔断的时候迟迟没有触发。</p><p>你可以根据经验来设定一个值，比如说三十秒或者一分钟。</p><p><img src=\"https://static001.geekbang.org/resource/image/ee/c9/eee791ac63348392cd1ea51d433258c9.png?wh=1920x1027\" alt=\"图片\"></p><p>当然最简单的做法就是超过阈值就直接触发熔断，但是采取这种策略就要更加小心抖动问题。</p><h3>服务恢复正常</h3><p>第二个问题，一个服务熔断之后要考虑恢复。比如说如果我们判断一个服务响应时间过长，进入了熔断状态。那么十分钟过后，已接收的请求已经被处理完了，即服务恢复正常了，那么它就要退出熔断状态，继续接收新请求。</p><p><img src=\"https://static001.geekbang.org/resource/image/a7/2e/a7c20f51242185d023a304e502a0012e.png?wh=1920x1179\" alt=\"图片\"></p><p>因此在触发熔断之后，就要考虑检测服务是否已经恢复正常。</p><p>很可惜，这方面微服务框架都做得比较差。大多数情况下就是触发熔断之后保持一段时间，比如说一分钟，一分钟之后就认为服务已经恢复正常，继续处理新请求。</p><p>不过这里就涉及到我前面多次提到的抖动问题了。所谓<strong>抖动就是服务频繁地在正常-熔断两个状态之间切换</strong>。</p><p>引起抖动的原因是多样的，比如说前面提到的一旦超过阈值就进入熔断状态，或者我们这里说的恢复策略不当也会引起抖动。再比如刚刚我们提到的“一分钟后就认为服务已经恢复正常，继续处理新请求”就容易引发抖动问题。</p><p>你试想一下，如果本身熔断是高并发引起的。那么在一分钟后，并发依旧很高，这时候你一旦直接恢复正常，然后高并发的流量打过来，服务是不是又会触发熔断？</p><p><img src=\"https://static001.geekbang.org/resource/image/73/df/73be149c40be65f2e66d4bbde0d492df.png?wh=1920x1194\" alt=\"图片\"></p><p>而要解决这个抖动问题，就需要在恢复之后控制住流量。比如说按照 10%、20%、30%……逐步递增，而不是立刻恢复 100% 的流量。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/1a/14a54365c9739b664fa35789434a131a.png?wh=1920x651\" alt=\"图片\"></p><p>显然你能够看出来这种做法还是不够好。因为在这种逐步放开流量的措施下，依旧有请求因为熔断不会被处理。那么一个自然的想法就是，<strong>能不能让客户端来控制这个流量？</strong>简单来说就是服务端触发熔断之后，客户端就直接不再请求这个节点了，而是换一个节点。等到恢复了之后，客户端再逐步对这个节点放开流量。</p><p>当然可以，这也是我给出的亮点方案。</p><h2>面试准备</h2><p>这些就是关于熔断你要了解的基础知识，不过如果你想要彻底掌握，还需要把这些知识点和实际工作联系在一起。所以我建议你在面试之前，要弄清楚你所在的公司有没有用熔断来治理微服务。如果有，那么你需要进一步弄清楚下面这些情况。</p><ol>\n<li>你们公司是怎么判断微服务出现故障的？比如说错误率、响应时间等等。</li>\n<li>你们公司是怎么判断微服务已经从故障中恢复过来的？</li>\n<li>在判断微服务已经恢复过来之后，有没有采取什么措施来防止抖动的问题？</li>\n</ol><p>关于熔断最佳的面试策略是把它作为你构建一个高可用微服务架构的一环。例如你在介绍某一个微服务项目的时候可以这样说。</p><blockquote>\n<p>这是一个高可用的微服务系统，为了保证它的可用性，我采取了限流、降级、熔断等措施。</p>\n</blockquote><p>此外，如果面试官问到服务治理以及提高系统可用性的方法之类的问题，你也可以用熔断来回答。又或者面试官问到了限流或者降级，那么你就可以尝试把话题引到熔断上面。此外，如果面试官问到某个服务崩溃了怎么办？这个问题相当于是在问怎么提高可用性防止服务崩溃，以及万一服务真崩溃了你也要有措施防止拖累别的服务，那么熔断就是一个可用的手段。</p><p>如果你现在有时间，在学完这节课的内容之后，就可以尝试在公司内部落地一下熔断，并且可以试试我给你的亮点方案，来加深印象以及对细节的把控。</p><h2>基本思路</h2><p>当面试官问“你有没有用过熔断”或者“怎么保障微服务可用性”的时候，你就可以介绍你使用的熔断。但是要根据我在前置知识里面的提示，你在面试的时候要说清楚什么时候判定服务需要触发熔断，为什么选用这个指标。</p><p>假如说你准备用<strong>响应时间</strong>来作为指标，那么你可以这么回答，关键词是<strong>持续超过阈值</strong>。</p><blockquote>\n<p>为了保障微服务的可用性，我在我的核心服务里面接入了熔断。针对不同的服务，我设计了不同的微服务熔断策略。</p>\n</blockquote><blockquote>\n<p>比如说最简单的熔断策略就是根据响应时间来进行。当响应时间超过阈值一段时间之后就会触发熔断。我一般会根据业务情况来选择这个阈值，例如，如果产品经理要求响应时间是1s，那么我会把阈值设定在1.2s。如果响应时间超过1.2s，并且持续三十秒，就会触发熔断。在触发熔断的情况下，新请求会被拒绝，而已有的请求还是会被继续处理，直到服务恢复正常。</p>\n</blockquote><p>这里面试官就可能有很多种问法，但是我在前置知识里面都讨论到了。虽然他的问题可能千奇百怪，不过万变不离这几问。</p><ol>\n<li>这阈值还可以怎么确定？那么你就回答还可以根据观测到的响应时间数据来确定。</li>\n<li>这个持续三十秒是如何计算出来的？这个问题其实可以坦白回答是基于个人经验，然后你解释一下过长或者过短的弊端就可以了。</li>\n<li>为什么多了0.2s？那么你可以解释是留了余地，防止偶发性的响应时间变长的情况。</li>\n<li>怎么判断服务已经恢复正常了？那么你可以回答等待一段固定的时间，然后尝试逐渐放开流量。</li>\n</ol><p>如果你在实践中根据自己的业务特征选用了一些比较罕见的指标，或者你设计的触发熔断的条件比较有特色，那么也可以用自己的实际方案。</p><p>这里我给你另外一个微创新的方案，关键词是<strong>缓存崩溃</strong>。</p><blockquote>\n<p>我还设计过一个很有趣的熔断方案。我的一个接口并发很高，对缓存的依赖度非常严重。所以我的熔断策略是要是缓存不可用，比如说 Redis 崩溃了，那么我就会触发熔断。这里如果我不熔断的话，请求会因为 Redis 崩溃而全部落到 MySQL 上，基本上会压垮 MySQL。</p>\n</blockquote><blockquote>\n<p>在触发熔断之后，我会额外开启一个线程（如果是Go就换成 Goroutine）持续不断地 ping Redis。如果 Redis 恢复了，那么我就会退出熔断状态，新来的请求就不会被拒绝了。</p>\n</blockquote><p>这里我用 Redis 来作为例子，你可以将 Redis 替换为 MemCache 之类的，甚至你还可以将缓存替换成你业务上任何一个关键的第三方依赖。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/85/4f4211f38c9b7130bf5116270e6fed85.png?wh=1920x1069\" alt=\"图片\"></p><p>这个方案里面我还留了一些可以引导的点。</p><ul>\n<li>缓存问题：在这里我提到了 Redis 失效，这种情况类似于缓存雪崩，那么你很自然地就可以把话题引导到如何处理缓存击穿、穿透、雪崩这些经典问题上。</li>\n<li>高可用 MySQL：我在这里使用的是熔断来保护 MySQL，类似地，你也可以考虑用限流来保护MySQL。</li>\n</ul><p>最后我提到了退出熔断状态，如果面试官了解抖动问题，那么他就肯定会追问“你是一次性放开全部流量吗？”，那么你就可以阐述抖动的问题，然后总结一下。</p><blockquote>\n<p>我这种逐步放开流量的方案其实还是有缺陷的，还有一些更加高级的做法，但是需要负载均衡来配合。</p>\n</blockquote><p>这个总结就是你留下的鱼饵，为了引出下面我给你展示的亮点方案。</p><h2>亮点方案</h2><p>前面的基本思路如果你能答好，差不多也能通过跟熔断有关的面试了，而且有不小的概率能够给面试官留下你技术很不错的印象。但是你还可以进一步展示你在服务治理和服务可用性保证上的独到见解。这就需要用到下面我要给你讲的综合了负载均衡算法和熔断措施的方案了。</p><p>这个方案很简单，在落地的时候也不是很难。</p><p>我在讲抖动与恢复的时候提到，恢复的时候可以逐步放开流量。那么你是否注意到，这个放开流量是在服务端处理的，也就是说服务端还是收到了100%的流量，只不过只有部分流量会被放过去并且被正常处理。</p><p>那么一个自然的想法就是<strong>为什么不直接让客户端来控制这个流量呢？</strong></p><p><img src=\"https://static001.geekbang.org/resource/image/ec/d1/ec05dc00f892bde08a739e2yy3cee3d1.png?wh=1920x1154\" alt=\"图片\"></p><p>进一步结合我在负载均衡里面谈到的根据调用结果来调整负载均衡策略的讨论，是不是可以让客户端也采用这种负载均衡策略？答案是可以的。</p><p>整体流程：</p><ol>\n<li>服务端在触发熔断的时候，会返回一个代表熔断的错误。</li>\n<li>客户端在收到这个错误之后，就会把这个服务端节点暂时挪出可用节点列表。后续所有的新请求都不会再打到这个触发了熔断的服务端节点上了。</li>\n<li>客户端在等待一段时间后，逐步放开流量。</li>\n<li>如果服务端正常处理了新来的请求，那么客户端就加大流量。</li>\n<li>如果服务端再次返回了熔断响应，那么客户端就会再一次将这个节点挪出可用列表。</li>\n<li>如此循环，直到服务端完全恢复正常，客户端也正常发送请求到该服务端节点。</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/bd/68/bd829a2832df33c1c92b8d3165c06968.png?wh=1920x716\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/23/02/230c1329cd5d273fb79cbcc50f8a0002.png?wh=1920x716\" alt=\"图片\"></p><p><img src=\"https://static001.geekbang.org/resource/image/59/cd/59f6be80174afd9cd57d5f4c8b2ea5cd.png?wh=1920x716\" alt=\"图片\"></p><p>那么这里你就可以这样回答，关键词是<strong>负载均衡</strong>。</p><blockquote>\n<p>整体思路是利用负载均衡来控制流量。如果一个服务端节点触发了熔断，那么客户端在做负载均衡的时候就可以将这个节点挪出可用列表，后续请求会发给别的节点。在经过一段时间之后，客户端可以尝试发请求给该节点。如果该节点正确处理了，那客户端就可以加大流量。否则客户端就要再一次等待一段时间。</p>\n</blockquote><p>到这里你还可以自己杠自己一下，就是<strong>万一所有可用节点都触发熔断了，应该怎么办？</strong>你就可以这样来说。</p><blockquote>\n<p>这个方案是需要兜底的，比如说如果因为某些原因数据库出问题，导致某个服务所有的节点都触发了熔断，那么客户端就完全没有可用节点了。不过这个问题本身熔断解决不了，负载均衡也解决不了，只能通过监控告警之后人手工介入处理了。</p>\n</blockquote><h2>面试思路总结</h2><p>这节课我们主要解决的是熔断问题。我们讨论了熔断的基本概念，怎么判定服务是否熔断，以及熔断后如何恢复的问题。其中的难点是抖动的问题，为了防止抖动，我们需要合理判定节点的健康状况，在恢复期间尽可能等待一段时间，然后逐步放开流量。</p><p>最后我给出了一个<strong>综合运用负载均衡和熔断的方案，重点在于客户端控制流量，并根据服务端节点的状况来操作可用节点列表</strong>。你在学习的时候注意把亮点方案和前面学习的负载均衡内容结合在一起，同时我也非常建议你在实际工作中尝试应用一下熔断，让它来保护你的系统，提高系统可用性。</p><p>同样地，我也整理这节课的思维导图，你可以参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/4f/a0/4f5yy2ae950f35d03af485d1b1bbd3a0.png?wh=2875x1996\" alt=\"\"></p><p>除了熔断相关知识，这节课我还希望你学会综合运用各种技术手段来设计精巧的方案。在这里我给出了一个负载均衡+熔断的方案，后续你也可以看到更多这个技巧的应用。</p><p>最后我再强调一下，熔断面试的最好方案是把它作为你<strong>构建高可用微服务</strong>的一环，也就是说，你可以认为前面讨论的负载均衡，还有接下来要讨论的限流、降级、隔离等措施，都是你整个高可用方案的一环。</p><h2>思考题</h2><p>我在负载均衡和熔断两节课里面都提到一个关键点，即如何判定一个服务是否处于健康状态，这方面你有什么自己的思考？欢迎你把你的答案分享在评论区，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":377298,"user_name":"penbox","can_delete":false,"product_type":"c1","uid":1052938,"ip_address":"四川","ucode":"59C4F47ACCB7F2","user_header":"https://static001.geekbang.org/account/avatar/00/10/11/0a/59639f1f.jpg","comment_is_top":false,"comment_ctime":1688288378,"is_pvip":true,"replies":[{"id":137509,"content":"赞！基本上就是靠猜和试探，试探也是固定套路，你已经总结得很对了。\n你考虑得非常深远了。\n这种健康中心的想法应该说之前也有人探讨过，后来就是发现监控做得好，不太需要这么一个健康中心。比如说我们的监控都会采集各个机器的 CPU，内存之类的东西。\n所以现在其实是缺了一个能够综合运用各种监控指标打分的东西，但是一直以来也没有谁研究出来了通用的打分机制——适合各种业务的打分机制。\n早期我还想过，能不能借助 AI 来学习人判断节点是否健康的思路，然后让 AI 来监控、打分、执行容错。还可以进一步整合日志分析、流量预判等，做得非常高级。\n当然，这都是吹牛逼，我稍稍尝试过就放弃了。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688370139,"ip_address":"中国台湾","comment_id":377298,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"在负载均衡和熔断两节课都提到了一个关键点，如何判断一个服务是否处于健康状态，这方面你有什么自己的思考？\n学习了目前这两节课，我感觉服务端节点目前是什么状态，都是靠猜测或试探来得到的。\n在负载均衡算法里面，靠连接数或响应时间来判断服务器权重，这两个指标都是客户端对服务端状态的猜测，并不是服务端的真实情况。动态调整权重里面的成加败减，要反复试探多次，才能把权重调整为正确的服务端状态。  \n在熔断这里，熔断之后到底恢复没有，不管是服务端和客户端都不知道，只能放点流量过去试一试。  \n目前好像还缺少手段来判断服务端当前的真实情况。有没有可能类似注册中心一样，在微服务框架中引入一个”健康中心“。每个服务端根据若干个指标，对自己打一个分，定时上报给健康中心。不管是客户端还是服务端自己，发现不对劲的时候，去健康中心里找到服务端对应的分数，就能直接判断出这个服务端的真实情况。","like_count":11,"discussions":[{"author":{"id":1509191,"avatar":"https://static001.geekbang.org/account/avatar/00/17/07/47/c67ce0ca.jpg","nickname":"水纹","note":"","ucode":"4715B2EC130D55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628252,"discussion_content":"那健康中心如果出问题呢，比如判断节点错误，把健康节点认定为非健康节点，还得保证健康中心的高可用，接下来就是套娃了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1695117734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2002645,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/8e/d5/64d8484c.jpg","nickname":"kalos","note":"","ucode":"4A711F24125E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625630,"discussion_content":"总结：监控、主动上报、探测","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1692001025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"美国","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622510,"discussion_content":"赞！基本上就是靠猜和试探，试探也是固定套路，你已经总结得很对了。\n你考虑得非常深远了。\n这种健康中心的想法应该说之前也有人探讨过，后来就是发现监控做得好，不太需要这么一个健康中心。比如说我们的监控都会采集各个机器的 CPU，内存之类的东西。\n所以现在其实是缺了一个能够综合运用各种监控指标打分的东西，但是一直以来也没有谁研究出来了通用的打分机制——适合各种业务的打分机制。\n早期我还想过，能不能借助 AI 来学习人判断节点是否健康的思路，然后让 AI 来监控、打分、执行容错。还可以进一步整合日志分析、流量预判等，做得非常高级。\n当然，这都是吹牛逼，我稍稍尝试过就放弃了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1688370139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"中国台湾","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377133,"user_name":"Bin","can_delete":false,"product_type":"c1","uid":1538906,"ip_address":"广东","ucode":"E60E755471324B","user_header":"https://static001.geekbang.org/account/avatar/00/17/7b/5a/9cde8618.jpg","comment_is_top":false,"comment_ctime":1687962336,"is_pvip":false,"replies":[{"id":137470,"content":"我愿称你为课代表，总结太强了！\n\nQuestion：其实我在面试的也会有这种困境，毕竟有些业务我确实没有解决过，只是听说过。\n\n这里要分情况讨论：\n1. 面试官问的场景是你确实要解决的，不过你用了 A 方案，但是你面试的时候还回答了 B，C 方案。这种，我一般就是先讲自己的 A 方案，讲完之后看情况，要是面试官觉得 A 不符合口味，就接着讲自己了解的 B 方案和 C 方案。正常来说，在做方案选型的时候，我多半比较过 B 和 C，但是最终选了 A。我只需要讲完 B C 之后讲一下自己当初的决策理由就可以。因为本身我落地的是 A，B 和 C 被我放弃了，问题也不太大。\n2. 如果是这个场景跟我业务没有关系，比如说我的项目经历是支付方向，问我的场景是订单方向，我也就只能把公司的解决方案拿出来说说。问到一些答不出来的细节很正常，毕竟我项目经历又不是这个地方的。不过一般要避免面试官不按套路出牌，也就是最好别让自己陷入这种境地。\n\n你在面试前，可以提前准备一下各种方案，包括如果真落地可能遇到什么问题，又或者你去搜搜业界落地的技术博客，也能回答上来一些细节性的问题。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688108553,"ip_address":"广东","comment_id":377133,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"What : 什么是「熔断」\n在微服务架构里面是指当微服务本身出现问题的时候，它会拒绝新的请求，直到微服务恢复。\n\nWhy：微服务架构为什么要使用「熔断」\n可以给服务端恢复的机会\n个人理解：\n「熔断」机制就是在系统高负载&#47; 服务崩溃的时候，拒绝新的请求。相当于提供给服务&#47;系统一段“喘息”时间，“喘息”时间的意义在于：\n1. 服务端不再接受新请求，服务的负载可以降低下来，防止服务雪崩\n2. 服务端崩溃的情况下，可以重启服恢复务，可以理解为是一种故障转移（failover）手段\n3. 上游服务收到「熔断」信息返回，可以进行兜底方案处理：例如业务补偿、请求转发、同步转异步等\n\nWhen：什么时候进行和结束「熔断」\n微服务本身「出现问题」的时候\n「熔断」的开始和结束时机判断就在于以下问题的判断：\n1. 判断微服务出现问题\n2. 判断微服务恢复服务\n\n「熔断」开启：判断出现问题\n判断健康状态\n1. 选择业务「指标」\n每个微服务实际上都是附带着业务属性（微服务的划分是根据业务的职责和边界来划分）\n所以可以根据业务来选择「指标」来代表微服务的健康状态。\n常见的指标可以是：「响应时间的99线」，「错误率」等\n2. 设置合适的「阈值」\n这也是根据业务来决定的。\n假设我们选择「响应时间」作为指标。\n● 根据业务要求的「指标」阈值设置\n● 观察业务整体的「指标」来设置\n3. 设置持续多长时间才触发「熔断」\n需要持续一段时间之后才触发「熔断」，因为：\n● 防止「指标」 偶发性的突然增长\n● 防止「服务抖动」\n「持续时间」的设置，依赖个人经验\n\n「熔断」结束：判断恢复服务\n现状：大多数是触发「熔断」后保持「一段时间」，就认为服务已经恢复正常，继续处理新请求\n存在的问题：「抖动」\n解决方案：\n1. 「服务端控制流量」：恢复服务之后，比如说10%，20%逐步递增，不是100%恢复流量\n这种做法不够好。依旧有请求因为熔断不会被处理。\n2. 「客户端控制流量」：服务端熔断后，客户端不再请求这个节点，而是换一个节点。恢复之后，客户端逐步放开流量\n\n亮点方案：客户端结合「负载均衡」控制流量，解决「抖动」问题\n\nQuestion\n面试中，经常在你讲完一些场景解决方案之后，面试官就会问你有自己实现吗？或者有没有落地在自己的项目中？如果回答有，面试官就会问遇到过什么问题没有？你回答没有，感觉自己给面试官的感觉又只是停留在理论上，没有实践经验。想问老师，对于类似这些问题，应该怎么去破局呢？","like_count":9,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622331,"discussion_content":"我愿称你为课代表，总结太强了！\n\nQuestion：其实我在面试的也会有这种困境，毕竟有些业务我确实没有解决过，只是听说过。\n\n这里要分情况讨论：\n1. 面试官问的场景是你确实要解决的，不过你用了 A 方案，但是你面试的时候还回答了 B，C 方案。这种，我一般就是先讲自己的 A 方案，讲完之后看情况，要是面试官觉得 A 不符合口味，就接着讲自己了解的 B 方案和 C 方案。正常来说，在做方案选型的时候，我多半比较过 B 和 C，但是最终选了 A。我只需要讲完 B C 之后讲一下自己当初的决策理由就可以。因为本身我落地的是 A，B 和 C 被我放弃了，问题也不太大。\n2. 如果是这个场景跟我业务没有关系，比如说我的项目经历是支付方向，问我的场景是订单方向，我也就只能把公司的解决方案拿出来说说。问到一些答不出来的细节很正常，毕竟我项目经历又不是这个地方的。不过一般要避免面试官不按套路出牌，也就是最好别让自己陷入这种境地。\n\n你在面试前，可以提前准备一下各种方案，包括如果真落地可能遇到什么问题，又或者你去搜搜业界落地的技术博客，也能回答上来一些细节性的问题。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688108553,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377429,"user_name":"小晨","can_delete":false,"product_type":"c1","uid":1477754,"ip_address":"江苏","ucode":"C95BC5211A5741","user_header":"https://static001.geekbang.org/account/avatar/00/16/8c/7a/5ee20222.jpg","comment_is_top":false,"comment_ctime":1688481803,"is_pvip":false,"replies":[{"id":137610,"content":"会！你已经领悟到了面试另外一个可以提及的亮点。正常来说，你后端的节点处理能力是有冗余的，那么一两个节点熔断，这些冗余的处理能力刚好够用。\n\n但是如果你要是大部分节点都已经快要撑不住流量了，那么你这时候一两台机器熔断，就会导致其它节点也撑不住。\n\n所以这种流量的场景，用限流会更好。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688830949,"ip_address":"广东","comment_id":377429,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"是否存在这种场景，通过客户端控制流量，熔断某个服务，将原本应该给这个服务的流量给其他节点，导致其他节点因为流量增加也导致也触发熔断，即原本可能只要熔断一个节点，但因为这个节点熔断了，流量分给了其他节点，其他节点的压力增加，进而触发熔断，造成&quot;雪崩&quot;？","like_count":6,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622943,"discussion_content":"会！你已经领悟到了面试另外一个可以提及的亮点。正常来说，你后端的节点处理能力是有冗余的，那么一两个节点熔断，这些冗余的处理能力刚好够用。\n\n但是如果你要是大部分节点都已经快要撑不住流量了，那么你这时候一两台机器熔断，就会导致其它节点也撑不住。\n\n所以这种流量的场景，用限流会更好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688830949,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376992,"user_name":"Geek_948740","can_delete":false,"product_type":"c1","uid":2323925,"ip_address":"浙江","ucode":"E2CE24AECBF0A3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epRstZOx9oC1zrJuyZqomSYWTsDuXe5W2KSIRXvm8PDEWtICVGQibhiay5ibbEZFibYKopyhQnOYbcYpg/132","comment_is_top":false,"comment_ctime":1687802327,"is_pvip":false,"replies":[{"id":137431,"content":"这里的客户端基本上都是指服务调用中的客户端。比如说 A 调用 B 的接口，那么 A 就是客户端。\n\n整个专栏，基本上都是这种语义，如果是APP 之类的，我一般都会直接说 APP，或者用户。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1687926148,"ip_address":"广东","comment_id":376992,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"同问 这篇文章里的客户端是指什么 app和电脑的话做这些策略成本很高吧","like_count":6,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622114,"discussion_content":"这里的客户端基本上都是指服务调用中的客户端。比如说 A 调用 B 的接口，那么 A 就是客户端。\n\n整个专栏，基本上都是这种语义，如果是APP 之类的，我一般都会直接说 APP，或者用户。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687926148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376744,"user_name":"小手冰凉*^O^*","can_delete":false,"product_type":"c1","uid":1420323,"ip_address":"北京","ucode":"1A69158F6D0F92","user_header":"https://static001.geekbang.org/account/avatar/00/15/ac/23/8eb08fdf.jpg","comment_is_top":false,"comment_ctime":1687311367,"is_pvip":true,"replies":[{"id":137340,"content":"现在的主流是根据错误率来判断要不要熔断，这个错误可以是业务错误，也可以是系统错误（比如中间件本身的错误）。当错误率比较高的时候就会触发熔断。\n我之前就用过这种策略，比较好实现。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1687317919,"ip_address":"广东","comment_id":376744,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"老师好，业界好的熔断方案都是怎么做的呢？","like_count":6,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621564,"discussion_content":"现在的主流是根据错误率来判断要不要熔断，这个错误可以是业务错误，也可以是系统错误（比如中间件本身的错误）。当错误率比较高的时候就会触发熔断。\n我之前就用过这种策略，比较好实现。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1687317919,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2755630,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/0c/2e/791d0f5e.jpg","nickname":"Funny","note":"","ucode":"01127971675E44","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":621599,"discussion_content":"老师，我觉得主流是根据错误率来判断要不要熔断是不准确的，之前Hystrix是基于失败比例进行熔断，目前常用的Sentinel支持‘慢调用比例、异常次数、异常比例’进行熔断","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1687338759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":621564,"ip_address":"广东","group_id":0},"score":621599,"extra":""}]}]},{"had_liked":false,"id":381868,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1352753,"ip_address":"江苏","ucode":"1770CA7050647A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI8qibAw4lRCic1pbnA6yzQU3UqtQm3NqV1bUJ5EiaUnJ24V1yf4rtY7n2Wx7ZVvTemqq5a61ERWrrHA/132","comment_is_top":false,"comment_ctime":1696064179,"is_pvip":false,"replies":[{"id":139226,"content":"可以的。而且网关做这种还更加合适，因为网关知道有多少个节点，也知道每一个节点的负载，调度的灵活性和准确性都很好。唯一的缺陷就是查询经过网关会有性能损耗，并且网关本身容易成为性能和可用性的瓶颈，","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1696923118,"ip_address":"广东","comment_id":381868,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"请教一下大明老师 在亮点一节 是否可以用网关来解决? 由网关（比如kong）不管是检测各个服务节点的主要指标也好 还是服务端主动上报需要熔断信息也好。 如果节点健康就允许开放节点 如果不健康就下架节点保护服务。","like_count":4,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629294,"discussion_content":"可以的。而且网关做这种还更加合适，因为网关知道有多少个节点，也知道每一个节点的负载，调度的灵活性和准确性都很好。唯一的缺陷就是查询经过网关会有性能损耗，并且网关本身容易成为性能和可用性的瓶颈，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696923119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377067,"user_name":"TimJuly","can_delete":false,"product_type":"c1","uid":1065064,"ip_address":"北京","ucode":"56FE7BF7447DEA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eooNCNEO0vhRiagdrCnNW2LWzzV4g5tXJ9KkTu9hegCTx6lBrA06AZ3Uylb2wdKjvtrmZUWkKKHTGA/132","comment_is_top":false,"comment_ctime":1687892378,"is_pvip":false,"replies":[{"id":137425,"content":"严格来说，如果你的异常机制（Go 中的错误机制）设计得好，你是知道的。比如说，你们有严格的错误码机制，每一个业务都有自己的错误码前缀，那么你根据错误码就知道究竟是谁出错了，也就是你能区别是自身、还是下游。\n而如果没有这种机制，你基本上判断不出来是自身，还是下游引起的。这时候对你来说已经不重要了，你直接将自身熔断了就可以。\n而单机故障还是集群故障，你站在调用者角度永远都是认为下游是单机故障。比如说 A 调用 B，如果 A 调不通，它只会认为是它调用的 B 的那个节点崩了，而不会认为 B 整个集群都崩了。\n\n集群故障是需要第三方来监控的。比如说你有 prometheus 监控，你发现所有的节点都各种超时，或者异常很多，这样你才能判定是整个集群都出问题了。\n\n如果你利用的是负载均衡 fail-over 机制，或者你的客户端会给服务端发送心跳，那么服务端所有节点都调不通，也可以认为是集群崩溃了。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1687925964,"ip_address":"广东","comment_id":377067,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"引申一个问题，发现故障时（可能是自身引起，也可能是下游引起），怎么判断是单机故障还是集群故障","like_count":4,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622108,"discussion_content":"严格来说，如果你的异常机制（Go 中的错误机制）设计得好，你是知道的。比如说，你们有严格的错误码机制，每一个业务都有自己的错误码前缀，那么你根据错误码就知道究竟是谁出错了，也就是你能区别是自身、还是下游。\n而如果没有这种机制，你基本上判断不出来是自身，还是下游引起的。这时候对你来说已经不重要了，你直接将自身熔断了就可以。\n而单机故障还是集群故障，你站在调用者角度永远都是认为下游是单机故障。比如说 A 调用 B，如果 A 调不通，它只会认为是它调用的 B 的那个节点崩了，而不会认为 B 整个集群都崩了。\n\n集群故障是需要第三方来监控的。比如说你有 prometheus 监控，你发现所有的节点都各种超时，或者异常很多，这样你才能判定是整个集群都出问题了。\n\n如果你利用的是负载均衡 fail-over 机制，或者你的客户端会给服务端发送心跳，那么服务端所有节点都调不通，也可以认为是集群崩溃了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687925965,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377182,"user_name":"xyu","can_delete":false,"product_type":"c1","uid":1061974,"ip_address":"浙江","ucode":"B048E920E5C917","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/56/fe22bae8.jpg","comment_is_top":false,"comment_ctime":1688030100,"is_pvip":false,"replies":[{"id":137466,"content":"对的！按比例是偷懒的做法，你讲的这是基于反馈的流量恢复，是更加高级的方案。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688107613,"ip_address":"广东","comment_id":377182,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"为什么说客户端利用负载均衡来控制流量相比服务端逐步放开流量是亮点方案？\n我说一下我的理解，不知道对不对：\n从整个系统来看，使用客户端控制流量的方案使得整个系统的可用性更好；客户端通过调用返回情况来调整权重，交互的过程实际上也是一个考察对方恢复情况的过程，然后根据你的恢复情况来加大流量，从而避免服务器又再次陷入熔断；如果使用服务端逐步放开流量的方案，机械地按比例的放开很可能会让服务器再次陷入熔断。","like_count":2,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622326,"discussion_content":"对的！按比例是偷懒的做法，你讲的这是基于反馈的流量恢复，是更加高级的方案。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1688107613,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3051029,"avatar":"https://static001.geekbang.org/account/avatar/00/2e/8e/15/4eaeca40.jpg","nickname":"多看看书吧","note":"","ucode":"A0A6195A31823B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":622800,"discussion_content":"这里的客户端应该不是web而是指的网关，对吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688660563,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":622326,"ip_address":"湖北","group_id":0},"score":622800,"extra":""}]}]},{"had_liked":false,"id":380223,"user_name":"sheep","can_delete":false,"product_type":"c1","uid":2770150,"ip_address":"广东","ucode":"DAC2036F08CE27","user_header":"https://static001.geekbang.org/account/avatar/00/2a/44/e6/2c97171c.jpg","comment_is_top":false,"comment_ctime":1693223749,"is_pvip":false,"replies":[{"id":138545,"content":"1. 35 秒也可以，差个 5 秒又没多大影响。至于 15 秒，看看效果怎样就可以。如果大部分时候 15 秒之后机器都还没恢复过来，那就要调大了。\n2. 不是……现在的熔断，都是服务端直接熔断，根本不通知。你要利用类似于 grpc 的header 的机制，返回一个 Header 给客户端，客户端要配合检查；又或者你返回一个特定的错误码，也要客户端检测。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1693488872,"ip_address":"广东","comment_id":380223,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"有两个问题：\n1. &quot;这个持续三十秒是如何计算出来的？这个问题其实可以坦白回答是基于个人经验，然后你解释一下过长或者过短的弊端就可以了。&quot;，面试官要是问，从哪些经验了解到要怎么设计的呢，15秒或者35秒不行吗，这时候该怎么回答呢\n2. 熔断是服务端去提示客户端的话，现在也就有普遍使用的熔断中间件么，还是说是在服务器代码内实现的呢","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626926,"discussion_content":"1. 35 秒也可以，差个 5 秒又没多大影响。至于 15 秒，看看效果怎样就可以。如果大部分时候 15 秒之后机器都还没恢复过来，那就要调大了。\n2. 不是……现在的熔断，都是服务端直接熔断，根本不通知。你要利用类似于 grpc 的header 的机制，返回一个 Header 给客户端，客户端要配合检查；又或者你返回一个特定的错误码，也要客户端检测。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1693488872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379497,"user_name":"牧童倒拔垂杨柳","can_delete":false,"product_type":"c1","uid":2033337,"ip_address":"河北","ucode":"8621DCB8B65CBB","user_header":"https://static001.geekbang.org/account/avatar/00/1f/06/b9/f9bf6696.jpg","comment_is_top":false,"comment_ctime":1692017960,"is_pvip":false,"replies":[{"id":138253,"content":"是的，熔断也可以这么做。应该说，熔断、限流、降级都可以这么做。推而广之，任何原因导致服务端不可用，或者说有性能问题，都可以在负载均衡里面的将它暂时挪出可用列表。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1692078162,"ip_address":"广东","comment_id":379497,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"在负载均衡和熔断两节课里面都提到一个关键点，即如何判定一个服务是否处于健康状态，这方面你有什么自己的思考？\n        这个关键点是服务端都相对被动，都需要等待客户端或者其他服务来检测状态\n        在负载均衡中，静态负载均衡算法是不考虑服务端的状态的，算法决定选谁就是谁，所以会出现各个服务端节点负载不可控的情况。动态负载均衡算法会去探测服务端状态，最少连接数是看连接数量，最少活跃请求是客户端看有多少请求还没回来，最短响应时间是客户端观察平均最短响应时间，在几种算法中，服务端都相对被动，不能主动做什么\n        在熔断这一课中也是这样，在熔断恢复时，不管是服务端控流量，还是客户端控流量，都是服务端基本都是被动等待\n        所以我在思考是不是可以借鉴负载均衡课程中的亮点方案，在某个服务端节点熔断之后，客户端收到熔断请求，此服务端节点被移出可用列表，此服务端节点在注册中心肯定也是不可用的，那么是不是可以谁都不去探测，等服务端恢复后，主动向注册中心上报自己恢复了。客户端要做的是等待一段时间后，定时向注册中心询问，某个服务端节点是不是恢复了。如果注册中心出问题了，这个时候客户端是一定要根据可用节点列表探测服务端是否可用的，顺带着就可以把触发熔断的服务端节点探测一下","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625689,"discussion_content":"是的，熔断也可以这么做。应该说，熔断、限流、降级都可以这么做。推而广之，任何原因导致服务端不可用，或者说有性能问题，都可以在负载均衡里面的将它暂时挪出可用列表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692078162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378551,"user_name":"浩仔是程序员","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"广东","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1690419156,"is_pvip":false,"replies":[{"id":137945,"content":"应该说……为了避免故障扩散开去，差不多关键业务上去都有熔断。它不仅仅是保护自己，也是保护别人。\n\n另外熔断不可用是指对于当前服务来说，但是熔断之后，整个系统可能还是可以运行的。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1690433086,"ip_address":"广东","comment_id":378551,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"老师，你好。我们系统目前是没有熔断机制的。我在思考，当一个系统需不需要熔断机制时取决于业务允不允许，熔断的时长对业务来说就是不可用，目前来说，我们是通常cpu使用率，内存使用率，上游调用失败或超时率等监控指标进行告警，人工进行恢复。另外，对于一些链路，为了不要上游直接打爆，可以通过消息队列异步去消费。我想问下老师，您具体负责的系统中是什么业务使用了熔断机制","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624312,"discussion_content":"应该说……为了避免故障扩散开去，差不多关键业务上去都有熔断。它不仅仅是保护自己，也是保护别人。\n\n另外熔断不可用是指对于当前服务来说，但是熔断之后，整个系统可能还是可以运行的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690433086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104601,"avatar":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","nickname":"浩仔是程序员","note":"","ucode":"A7E5CF9E1571A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624350,"discussion_content":"嗯嗯，我重新梳理了一下，发现老师说的&#34;熔断&#34;，跟我理解的熔断有电对不起，通常熔断应该是放在客户端才对，老师图里画的是在服务端，老师说的&#34;熔断&#34;更像是服务限流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690463310,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377422,"user_name":"拾掇拾掇","can_delete":false,"product_type":"c1","uid":1051873,"ip_address":"浙江","ucode":"D775F374C2A1D3","user_header":"https://static001.geekbang.org/account/avatar/00/10/0c/e1/f663213e.jpg","comment_is_top":false,"comment_ctime":1688474005,"is_pvip":false,"replies":[{"id":137611,"content":"差不多。不嫌麻烦的话，是可以做得很仔细的，最开始就像你说的，固定放几个请求试探。如果成功就步入下一个状态，比如说 0-100 随机一个数，小于 10 就放过去做试探，也就是 10% 的比例。后面如果收到了正常响应，就加大流量，不然就缩小流量或者退回上一个状态。\n\n说实在的，我也没搞过这么复杂的实现。我就是搞过两步走的，第一阶段放几个请求，后面就是按照比例放。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1688831130,"ip_address":"广东","comment_id":377422,"utype":1}],"discussion_count":1,"race_medal":1,"score":3,"product_id":100551601,"comment_content":"我好奇这个试探性放点流量是怎么放？count计数下几个然后就不放，等待放进去流量的响应情况吗","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622944,"discussion_content":"差不多。不嫌麻烦的话，是可以做得很仔细的，最开始就像你说的，固定放几个请求试探。如果成功就步入下一个状态，比如说 0-100 随机一个数，小于 10 就放过去做试探，也就是 10% 的比例。后面如果收到了正常响应，就加大流量，不然就缩小流量或者退回上一个状态。\n\n说实在的，我也没搞过这么复杂的实现。我就是搞过两步走的，第一阶段放几个请求，后面就是按照比例放。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688831130,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376870,"user_name":"码小呆","can_delete":false,"product_type":"c1","uid":2055809,"ip_address":"广东","ucode":"44532D6ABF9340","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg","comment_is_top":false,"comment_ctime":1687609439,"is_pvip":false,"replies":[{"id":137382,"content":"赞！确实可以的。不过面试的时候你还可以讲讲你们公司有没有什么自动处理告警的机制。因为有些故障是可以通过程序来恢复的。\n不过你们的真的是服务一不通就告警吗？还是说会有考虑一分钟多少次调不通才告警？","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1687697876,"ip_address":"广东","comment_id":376870,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"我们是夜莺,上面写一个监控脚本,定时去请求对应服务的接口,一旦有服务请求不通过,就在群里实现告警,不过,如果公司的项目都上了prometheus ,一旦流量请求出现问题,就直接在企微群发送告警,这样子应该也是可以的","like_count":1,"discussions":[{"author":{"id":2033337,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/06/b9/f9bf6696.jpg","nickname":"牧童倒拔垂杨柳","note":"","ucode":"8621DCB8B65CBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621929,"discussion_content":"一不通就告警，运维不会打人吗？？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1687780870,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2770150,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/44/e6/2c97171c.jpg","nickname":"sheep","note":"","ucode":"DAC2036F08CE27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2033337,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/06/b9/f9bf6696.jpg","nickname":"牧童倒拔垂杨柳","note":"","ucode":"8621DCB8B65CBB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626636,"discussion_content":"运维那边一堆错误日志[狗头]","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693223519,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":621929,"ip_address":"广东","group_id":0},"score":626636,"extra":""}]},{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621848,"discussion_content":"赞！确实可以的。不过面试的时候你还可以讲讲你们公司有没有什么自动处理告警的机制。因为有些故障是可以通过程序来恢复的。\n不过你们的真的是服务一不通就告警吗？还是说会有考虑一分钟多少次调不通才告警？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1687697876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376770,"user_name":"hurrier","can_delete":false,"product_type":"c1","uid":1887312,"ip_address":"广东","ucode":"9B3181A7193C95","user_header":"https://static001.geekbang.org/account/avatar/00/1c/cc/50/5f13250d.jpg","comment_is_top":false,"comment_ctime":1687340421,"is_pvip":false,"replies":[{"id":137352,"content":"第一种思路是按错误类型。这个可以是跟业务相关的，也可以是跟业务没关的。比如说当你发现返回了某一个特定的错误（或者异常），就认为系统本身出了故障，那么就可以触发熔断。\n第二种思路是检测业务关键路径上的依赖。比如说你严重依赖于某一个中间件，例如 Redis，那么当你发现 Redis 连不上，比如说心跳已经 ping 不通了，那么就可以触发熔断（后面学了降级，你就应该考虑应该尽可能先降级）。\n\nQPS 很低的话，你加一个限流会更好，防止突发流量。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1687406766,"ip_address":"广东","comment_id":376770,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"大明老师 如果请求下流qps很低 比如几分钟才请求一次 按错误率、响应时间熔断感觉都不准确，有更好的方案吗","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621639,"discussion_content":"第一种思路是按错误类型。这个可以是跟业务相关的，也可以是跟业务没关的。比如说当你发现返回了某一个特定的错误（或者异常），就认为系统本身出了故障，那么就可以触发熔断。\n第二种思路是检测业务关键路径上的依赖。比如说你严重依赖于某一个中间件，例如 Redis，那么当你发现 Redis 连不上，比如说心跳已经 ping 不通了，那么就可以触发熔断（后面学了降级，你就应该考虑应该尽可能先降级）。\n\nQPS 很低的话，你加一个限流会更好，防止突发流量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687406766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3231352,"avatar":"https://static001.geekbang.org/account/avatar/00/31/4e/78/ee4e12cc.jpg","nickname":"Lum","note":"","ucode":"7EF828425E685A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622774,"discussion_content":"感觉熔断基本是防止微服务调用雪崩吧，几分钟一次的没必要熔断","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688631353,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376756,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1687325370,"is_pvip":false,"replies":[{"id":137348,"content":"1. 首先应该是投入不够。这个东西本身是比较容易解决的，但是大部分微服务框架都没怎么做。微服务框架研发者都倾向于提供一些简单的、通用的策略，所以类似这种确实不怎么做。\n2. 不是人工干预，最常见的做法就是熔断一个固定的时间，然后直接恢复。做得精致一点就是熔断之后，过一段时间，要试探性的放一些流量。如果这些流量被正常处理了，那么加大流量。\n\n总的来说，如果你能为 gRPC 提供根据专栏内容涉及的一些扩展实现，放过去你的 Github 之类的，在面试的时候是可以介绍一下的，这样能够进一步证明你的代码能力。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1687406323,"ip_address":"广东","comment_id":376756,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"请教老师两个问题：\nQ1：服务恢复框架做得不好，是因为这个问题本身难以解决吗？\n文中“很可惜，这方面微服务框架都做得比较差。大多数情况下就是触发熔断之后保持一段时间，比如说一分钟”。 为什么框架做得差？是投入不够？还是说此问题本身难以解决？或者说难以解决是微服务架构本身固有的问题？\nQ2：熔断以后的恢复，业界一般是怎么做的？人工干预吗？","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621635,"discussion_content":"1. 首先应该是投入不够。这个东西本身是比较容易解决的，但是大部分微服务框架都没怎么做。微服务框架研发者都倾向于提供一些简单的、通用的策略，所以类似这种确实不怎么做。\n2. 不是人工干预，最常见的做法就是熔断一个固定的时间，然后直接恢复。做得精致一点就是熔断之后，过一段时间，要试探性的放一些流量。如果这些流量被正常处理了，那么加大流量。\n\n总的来说，如果你能为 gRPC 提供根据专栏内容涉及的一些扩展实现，放过去你的 Github 之类的，在面试的时候是可以介绍一下的，这样能够进一步证明你的代码能力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687406323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389783,"user_name":"黄堃健","can_delete":false,"product_type":"c1","uid":2037522,"ip_address":"广东","ucode":"B4AD5250A41B3A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/YbUxEV3741vKZAiasOXggWucQbmicJwIjg3HDE58oyibYXbSop9QQFqZ7X6OhynDoo6rDHwzK8njSeJjN9hx3pJXg/132","comment_is_top":false,"comment_ctime":1713447338,"is_pvip":false,"replies":[{"id":141980,"content":"所以这就是一个思路，你最终落地要根据实际情况来设计的。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1715230867,"ip_address":"广东","comment_id":389783,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"大明老师，持续超过阈值在线上有时是不可控，因为每个api几乎都改来改去。 一旦一个api发生了变更，你很难控制阈值。 所以可以针对采集cpu的数据可以做到不用为改阈值而烦劳。 ","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644400,"discussion_content":"所以这就是一个思路，你最终落地要根据实际情况来设计的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715230867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389625,"user_name":"黑白之间的影像","can_delete":false,"product_type":"c1","uid":1582283,"ip_address":"河北","ucode":"B7A9FAF1D985F1","user_header":"https://static001.geekbang.org/account/avatar/00/18/24/cb/351f102a.jpg","comment_is_top":false,"comment_ctime":1713100711,"is_pvip":false,"replies":[{"id":141984,"content":"99线一般就是指 99% 的请求满足某个特性。比如说响应时间 99 线，就是指 99% 的响应时间在多少以内。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1715231047,"ip_address":"广东","comment_id":389625,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"99线是什么意思呢？","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644404,"discussion_content":"99线一般就是指 99% 的请求满足某个特性。比如说响应时间 99 线，就是指 99% 的响应时间在多少以内。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715231047,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384468,"user_name":"Geek_8755c4","can_delete":false,"product_type":"c1","uid":3787026,"ip_address":"北京","ucode":"B6B910794289B5","user_header":"","comment_is_top":false,"comment_ctime":1701000724,"is_pvip":false,"replies":[{"id":140349,"content":"因为产品经理决定用户体验，说决定不太准确，但是是产品经理决定一个接口要在多久内返回。\n\n如果你觉得搞笑，应该是你们的产品经理太水了。\n\n我举一个例子，大多数 APP 的首页 API 的响应时间要求都是 50ms，你觉得这个 50ms 是谁提出来的？","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1701847012,"ip_address":"广东","comment_id":384468,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"为什么响应时间是由产品经理来设定的？这不有点搞笑吗？","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633125,"discussion_content":"因为产品经理决定用户体验，说决定不太准确，但是是产品经理决定一个接口要在多久内返回。\n\n如果你觉得搞笑，应该是你们的产品经理太水了。\n\n我举一个例子，大多数 APP 的首页 API 的响应时间要求都是 50ms，你觉得这个 50ms 是谁提出来的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701847013,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":3874436,"avatar":"","nickname":"Geek_933088","note":"","ucode":"D757733C3107D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":641291,"discussion_content":"这么看我这里的产品经理全是水货了🐶, 不考虑交互方式与展示效果，仅设计页面基本布局，部分交互效果还得我跟前端同事一起来设计的，对于功能接口啊，能正常返回结果就行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712476338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":633125,"ip_address":"广东","group_id":0},"score":641291,"extra":""}]}]},{"had_liked":false,"id":382299,"user_name":"3.0的A7","can_delete":false,"product_type":"c1","uid":1211991,"ip_address":"北京","ucode":"23C5F02B45CE39","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/57/8c1051b6.jpg","comment_is_top":false,"comment_ctime":1697017602,"is_pvip":false,"replies":[{"id":139368,"content":"熔断的粒度是你根据自己的实际情况来判定的。\n\n比如说 CPU、内存、网络带宽这种，出了问题应该是整个服务熔断。但是若是我某个接口依赖的数据库出了问题，那么应该是熔断我这个单一接口。这个要灵活设置。不过不是核心接口我都懒得管，只搞全局的熔断。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1697726222,"ip_address":"广东","comment_id":382299,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"-- 你们公司是怎么判断微服务出现故障的？比如说错误率、响应时间等等。\n\n熔断的粒度是服务级别的吗？如果只是单一接口出了故障，难道要熔断整个服务吗？\n","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629871,"discussion_content":"熔断的粒度是你根据自己的实际情况来判定的。\n\n比如说 CPU、内存、网络带宽这种，出了问题应该是整个服务熔断。但是若是我某个接口依赖的数据库出了问题，那么应该是熔断我这个单一接口。这个要灵活设置。不过不是核心接口我都懒得管，只搞全局的熔断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697726222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382292,"user_name":"Geek_680632","can_delete":false,"product_type":"c1","uid":3730160,"ip_address":"浙江","ucode":"9421FB33A0C6A9","user_header":"","comment_is_top":false,"comment_ctime":1697012031,"is_pvip":false,"replies":[{"id":139364,"content":"确实简单处理的话我们就是可以使用心跳。\n\n但是心跳一直有一个缺点，就是心跳只能证明你服务启动成功了，但是无法代表你服务能正常处理请求。比如说服务依赖的第三方崩溃这种，健康检测就无能为力。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1697725876,"ip_address":"广东","comment_id":382292,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"判断一个节点是否在线常见的方案是心跳检测，而判断节点是否处于健康状态使用的是响应时间，因为请求属性不同，在阈值的判断上需要预留一定的空间；\n检测超时之后，会面临两种情况：可恢复异常、不可恢复异常；","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629867,"discussion_content":"确实简单处理的话我们就是可以使用心跳。\n\n但是心跳一直有一个缺点，就是心跳只能证明你服务启动成功了，但是无法代表你服务能正常处理请求。比如说服务依赖的第三方崩溃这种，健康检测就无能为力。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1697725876,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380453,"user_name":"风清扬","can_delete":false,"product_type":"c1","uid":1047043,"ip_address":"广东","ucode":"651F1390B64953","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fa/03/eba78e43.jpg","comment_is_top":false,"comment_ctime":1693626802,"is_pvip":false,"replies":[{"id":138602,"content":"我猜测应该是熔断策略没搞好。不过有自动扩容机制熔断不熔断影响也不是很大了。\n\n你们扩容之后回缩容吗？","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1693896188,"ip_address":"广东","comment_id":380453,"utype":1}],"discussion_count":2,"race_medal":0,"score":4,"product_id":100551601,"comment_content":"我们目前的广告推荐系统中，更多的是监控服务端的机器cpu 内存 连接数等使用情况，当然也对流量波动予以监控，流量突增时相应的模块负载过高，会触发自动扩容，研发侧和运维侧收到告警也会持续关注，当前的广告推荐系统中，并没有引入熔断（之前好像开启过(类似brpc在特定窗口里失败率超过阈值)，后面不知道什么原因关闭了）","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627210,"discussion_content":"我猜测应该是熔断策略没搞好。不过有自动扩容机制熔断不熔断影响也不是很大了。\n\n你们扩容之后回缩容吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693896189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3874436,"avatar":"","nickname":"Geek_933088","note":"","ucode":"D757733C3107D6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":641292,"discussion_content":"扩容过程都是自动化的吗，同问：扩容后是否会缩容？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1712476447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378596,"user_name":"浩仔是程序员","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"广东","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1690464059,"is_pvip":false,"replies":[{"id":137976,"content":"赞！","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1690605364,"ip_address":"广东","comment_id":378596,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100551601,"comment_content":"判断一个服务是否健康，从调用方的调用来说，可以根据调用的错误和超时率，比如可以配置最小的请求量比如30个，错误请求比例比如30%，超时请求比例如何10%，时间滑动窗口的长度比如60秒。另外在熔断恢复，可以配置恢复等待时长比如60秒，探测初始通过比例比如10%，探测每满n个成功恢复比例比如10%。 在实现中，可以通过代理机制结合时间滑动窗口，对请求的成功和失败进行数据的统计。","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624474,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690605364,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378549,"user_name":"浩仔是程序员","can_delete":false,"product_type":"c1","uid":1104601,"ip_address":"广东","ucode":"A7E5CF9E1571A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/d9/f051962f.jpg","comment_is_top":false,"comment_ctime":1690418304,"is_pvip":false,"replies":[{"id":137947,"content":"确实，不是说所有业务都可以熔断。\n监控与告警是肯定得有的。不过我个人感觉缺乏熔断的最主要问题是故障扩散。就是一个系统崩了之后，把其它系统也一并搞崩了，这个是要比较小心的。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1690433378,"ip_address":"广东","comment_id":378549,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100551601,"comment_content":"老师您好，我们系统是没有熔断机制的。我在思考，对于熔断，还应该考虑业务允不允许熔断，目前的话，是通过告警机制有问题","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624314,"discussion_content":"确实，不是说所有业务都可以熔断。\n监控与告警是肯定得有的。不过我个人感觉缺乏熔断的最主要问题是故障扩散。就是一个系统崩了之后，把其它系统也一并搞崩了，这个是要比较小心的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690433378,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378460,"user_name":"Geek_20f6bc","can_delete":false,"product_type":"c1","uid":1703085,"ip_address":"上海","ucode":"AB00FE5F029840","user_header":"","comment_is_top":false,"comment_ctime":1690277604,"is_pvip":false,"replies":[{"id":137952,"content":"你发现了一个盲点。\n熔断、限流和降级，都可以考虑在客户端做，也可以考虑在服务端做，各有缺点。\n客户端做的缺点是，不够准确。比如说你这里 A 熔断了但是没用，因为可能还有 C 继续调用 B。如果此时就是因为 B 有问题，那么很快 C 也会熔断。\n服务端做的缺点就是，服务端始终会收到请求。在你 GC 的例子里面，就只能靠客户端超时控制了，这也是后面我讲超时控制的时候留下的思考题，超时控制是不能仅仅在服务端做的。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1690434370,"ip_address":"广东","comment_id":378460,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100551601,"comment_content":"看完文章,有点疑惑, 平时工作接触的熔断器(Hystrix这种),断路器的逻辑都是在服务调用者(或者叫客户端吧)来处理的,譬如A服务调用B服务的一些接口,A里面有熔断器监控B服务的接口调用情况,如果超时情况很多(或者其他异常),触发断路器, 后续对B接口的调用都直接返回异常或转到fallback处理逻辑.\n但是文章中说熔断逻辑是服务端来处理的,有点奇怪,熔断机制放服务端会有问题吧,\n譬如服务B有异常(碰到一次超长的GC停顿等),站在服务调用者A的角度来看,对B的调用都会超时,自然触发A的熔断器,熔断后续对B的调用, 如果熔断器放B服务, 有什么作用, 调用者的请求还是会打过来, 但是B所有业务线程都没法工作,自然也没办法处理熔断逻辑,所有请求只能傻等么","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":624320,"discussion_content":"你发现了一个盲点。\n熔断、限流和降级，都可以考虑在客户端做，也可以考虑在服务端做，各有缺点。\n客户端做的缺点是，不够准确。比如说你这里 A 熔断了但是没用，因为可能还有 C 继续调用 B。如果此时就是因为 B 有问题，那么很快 C 也会熔断。\n服务端做的缺点就是，服务端始终会收到请求。在你 GC 的例子里面，就只能靠客户端超时控制了，这也是后面我讲超时控制的时候留下的思考题，超时控制是不能仅仅在服务端做的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1690434370,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1247829,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0a/55/e9255528.jpg","nickname":"青芒","note":"","ucode":"5B1FE2A035316F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":638980,"discussion_content":"这样也有问题啊，按照你说的，A 和 C 都调用 B 服务，熔断机制放在 B 服务里，但是假如 B 服务有异常，请求根本发送不过去了，这种的服务端根本走不了熔断机制啊。\n\n我理解熔断还得是放在服务调用方，否则是否需要熔断服务提供方根本不确定啊。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710154901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":624320,"ip_address":"北京","group_id":0},"score":638980,"extra":""}]},{"author":{"id":2074982,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/a9/66/2df6b3fe.jpg","nickname":"滴滴答答","note":"","ucode":"C51B86D507E887","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627255,"discussion_content":"在服务端做熔断会不会还有这样一个问题？服务B确实有问题，但只是某个接口有问题，在服务端做熔断会不会把其它可用的接口也熔断掉了。如果在服务端做熔断时只熔断某个接口，那在客户端采用负载均衡来优化的那种方案就行不通了吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1693928357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":378209,"user_name":"提提","can_delete":false,"product_type":"c1","uid":1198829,"ip_address":"","ucode":"B568BDCB68344A","user_header":"https://static001.geekbang.org/account/avatar/00/12/4a/ed/d1409f9e.jpg","comment_is_top":false,"comment_ctime":1689907378,"is_pvip":false,"replies":[{"id":137814,"content":"HTTP 的话确实没办法，因为本身 HTTP 的负载均衡是在网关或者 DNS 上做的。\n如果你有办法利用 HTTP 走 DNS 拿到候选节点，也可以做，不过一般不这么搞。\nHTTP 你只能指望，提供 HTTP 服务的人会做高可用了","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1689951969,"ip_address":"广东","comment_id":378209,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100551601,"comment_content":"有个问题。如果客户端是发起的 http 请求。没法选节点发请求和移除节点，需要怎么做客户端控制呢？","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623880,"discussion_content":"HTTP 的话确实没办法，因为本身 HTTP 的负载均衡是在网关或者 DNS 上做的。\n如果你有办法利用 HTTP 走 DNS 拿到候选节点，也可以做，不过一般不这么搞。\nHTTP 你只能指望，提供 HTTP 服务的人会做高可用了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689951969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377795,"user_name":"五号特派员","can_delete":false,"product_type":"c1","uid":3653946,"ip_address":"四川","ucode":"D92133F112A20D","user_header":"https://static001.geekbang.org/account/avatar/00/37/c1/3a/880a0932.jpg","comment_is_top":false,"comment_ctime":1689221239,"is_pvip":false,"replies":[{"id":137711,"content":"我有些内容，刷亮点纯粹就是理论上刷的。比如说这节课的抖动内容，其实都不需要有实践，稍微想一下自己的恢复策略就能想到。\n而且，你校招生空谈影响也不大，因为本来校招就没经验，能知道这些东西，有广阔的见识，就已经赢得优势了。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1689424413,"ip_address":"广东","comment_id":377795,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100551601,"comment_content":"请问大明老师，我是校招生，怎么可以在面试的时候应用到课程的内容呢，空谈概念总是觉得不踏实\n","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623408,"discussion_content":"我有些内容，刷亮点纯粹就是理论上刷的。比如说这节课的抖动内容，其实都不需要有实践，稍微想一下自己的恢复策略就能想到。\n而且，你校招生空谈影响也不大，因为本来校招就没经验，能知道这些东西，有广阔的见识，就已经赢得优势了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689424413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376906,"user_name":"我好像一点都不像程序员","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"广东","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/63189817.jpg","comment_is_top":false,"comment_ctime":1687695537,"is_pvip":false,"replies":[{"id":137403,"content":"赞！所以当你掌握了这些之后，你就可以随便设计熔断、限流和降级的算法了。可以尝试自己搞一些有新意的出来，然后在面试中用用。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1687787491,"ip_address":"广东","comment_id":376906,"utype":1}],"discussion_count":3,"race_medal":0,"score":4,"product_id":100551601,"comment_content":"如何判定一个服务是否处于健康状态。以GO语言实现的微服务举例。随便讲几个指标\n1、服务依赖的数据库健康情况\n1.1 数据库的CPU是否处于非高负载情况\n1.2 数据库响应时长是否处于正常响应水平\n1.3 数据库连接是否可以正常使用，无断连情况，sql 或命令语句是否可以正常执行\n\n2. 服务所处环境，pod （或机器）的健康情况\n2.1 CPU是否正常，使用率没有太高\n2.2 磁盘IO是否正常\n2.3 整体负载是否正常\n2.4 内存使用率是否正常\n\n3. 服务本身是否健康\n3.1 gorutine 的数量是否正常\n3.2 服务的内存占用是否正常\n3.3 服务网络情况是否正常\n3.3 服务是否存在Panic\n\n4.服务有没有出现大量报错日志（框架的或者业务上的）\n5.服务的接口APM P99 指标是否正常，响应时长没有突然暴涨\n","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621950,"discussion_content":"赞！所以当你掌握了这些之后，你就可以随便设计熔断、限流和降级的算法了。可以尝试自己搞一些有新意的出来，然后在面试中用用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687787491,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2032505,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/03/79/e6f4efba.jpg","nickname":"Are you Ok❓","note":"","ucode":"1614BEF1D5AE11","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622044,"discussion_content":"这些指标数据是通过什么方式收集的？通过代码？还是第三方工具？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687864618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/63189817.jpg","nickname":"我好像一点都不像程序员","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2032505,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/03/79/e6f4efba.jpg","nickname":"Are you Ok❓","note":"","ucode":"1614BEF1D5AE11","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622067,"discussion_content":"有很多成熟的第三方工具可以用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1687877088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":622044,"ip_address":"广东","group_id":0},"score":622067,"extra":""}]}]},{"had_liked":false,"id":376755,"user_name":"。","can_delete":false,"product_type":"c1","uid":2542495,"ip_address":"北京","ucode":"BC4A57C4AB83F9","user_header":"https://static001.geekbang.org/account/avatar/00/26/cb/9f/272f5efd.jpg","comment_is_top":false,"comment_ctime":1687322256,"is_pvip":false,"replies":[{"id":137383,"content":"这个得我们小编安排，哈哈哈，我尽量写快点","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1687697906,"ip_address":"广东","comment_id":376755,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100551601,"comment_content":"写的很好，可以多更点吗😀","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621849,"discussion_content":"这个得我们小编安排，哈哈哈，我尽量写快点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1687697906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":376747,"user_name":"3.0的A7","can_delete":false,"product_type":"c1","uid":1211991,"ip_address":"北京","ucode":"23C5F02B45CE39","user_header":"https://static001.geekbang.org/account/avatar/00/12/7e/57/8c1051b6.jpg","comment_is_top":false,"comment_ctime":1687314402,"is_pvip":false,"replies":null,"discussion_count":4,"race_medal":0,"score":4,"product_id":100551601,"comment_content":"这里的客户端是指的是网关还是真实发起请求的客户端呢？\n我理解是网关，比如nginx之类\n如果是真实发起请求的客户端，比如移动app、web页面,那这个的开发成本是不是有点大呢？","like_count":2,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622121,"discussion_content":"微服务和微服务间的调用，客户端指RPC的客户端，一般都是内部系统，会引入RPC的SDK，实现起来还是比较容易的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1687932120,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2542495,"avatar":"https://static001.geekbang.org/account/avatar/00/26/cb/9f/272f5efd.jpg","nickname":"。","note":"","ucode":"BC4A57C4AB83F9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":621571,"discussion_content":"应该是网关，nginx","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1687322184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2094925,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/f7/4d/09554c96.jpg","nickname":"iron bo","note":"","ucode":"4BFB1331637AA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628818,"discussion_content":"&#34;木几丶&#34;道友说的 &#34;微服务和微服务间的调用&#34;，就是你自己系统里的服务，都可以是客户端和服务端，当你调用其他服务时，那么你就是客户端，当接收到其他服务的请求时，那么你就是服务端","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1695883236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1006424,"avatar":"","nickname":"Geek_xbye50","note":"","ucode":"0BF3780C247F22","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":623159,"discussion_content":"同问？不一定所有的微服务都是rpc协议呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1689120626,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}