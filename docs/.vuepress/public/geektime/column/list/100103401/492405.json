{"id":492405,"title":"21 | select：到底是在选择什么？","content":"<p>你好，我是朱涛。今天我们来学习Kotlin协程的select。</p><p>select，在目前的Kotlin 1.6当中，仍然是一个<strong>实验性的特性</strong>（Experimental）。但是，考虑到select具有较强的实用性，我决定还是来给你介绍一下它。</p><p>select可以说是软件架构当中非常重要的一个组件，在很多业务场景下，select与Deferred、Channel结合以后，在大大提升程序的响应速度的同时，还可以提高程序的灵活性、扩展性。</p><p>今天这节课，我会从select的<strong>使用角度</strong>着手，带你理解select的核心使用场景，之后也会通过源码帮你进一步分析select API的底层规律。学完这节课以后，你完全可以将select应用到自己的工作当中去。</p><p>好，接下来，我们就一起来学习select吧！</p><h2>select就是选择“更快的结果”</h2><p>由于select的工作机制比较抽象，我们先来假设一个场景，看看select适用于什么样的场景。</p><p>客户端，想要查询一个商品的详情。目前有两个服务：缓存服务，速度快但信息可能是旧的；网络服务，速度慢但信息一定是最新的。</p><p><img src=\"https://static001.geekbang.org/resource/image/50/86/50f7c90d8a01e42834500bb5yy705486.jpg?wh=1576x707\" alt=\"\"></p><p>对于这个场景，如果让我们来实现其中的逻辑的话，我们非常轻松地就能实现类似这样的代码逻辑：</p><!-- [[[read_end]]] --><pre><code class=\"language-plain\">// 代码段1\nfun main() = runBlocking {\n    suspend fun getCacheInfo(productId: String): Product? {\n        delay(100L)\n        return Product(productId, 9.9)\n    }\n\n    suspend fun getNetworkInfo(productId: String): Product? {\n        delay(200L)\n        return Product(productId, 9.8)\n    }\n\n    fun updateUI(product: Product) {\n        println(\"${product.productId}==${product.price}\")\n    }\n\n    val startTime = System.currentTimeMillis()\n\n    val productId = \"xxxId\"\n    // 查询缓存\n    val cacheInfo = getCacheInfo(productId)\n    if (cacheInfo != null) {\n        updateUI(cacheInfo)\n        println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n    }\n\n    // 查询网络\n    val latestInfo = getNetworkInfo(productId)\n    if (latestInfo != null) {\n        updateUI(latestInfo)\n        println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n    }\n}\n\ndata class Product(\n    val productId: String,\n    val price: Double\n)\n\n/*\n输出结果\nxxxId==9.9\nTime cost: 112\nxxxId==9.8\nTime cost: 314\n*/\n</code></pre><p>考虑到缓存服务速度更快，我们自然而然会这么写，先去查询缓存服务，如果查询到了信息，我们就会去更新UI界面。之后去查询网络服务，拿到最新的信息之后，我们再来更新UI界面。也就是这样：</p><ul>\n<li>第一步：查询缓存信息；</li>\n<li>第二步：缓存服务返回信息，更新UI；</li>\n<li>第三步：查询网络服务；</li>\n<li>第四步：网络服务返回信息，更新UI。</li>\n</ul><p>这种做法的好处在于，用户可以第一时间看到商品的信息，虽然它暂时会展示旧的信息，但由于我们同时查询了网络服务，旧缓存信息也马上会被替代成新的信息。这样的做法，可以最大程度保证用户体验。</p><p>不过，以上整个流程都是建立在“缓存服务一定更快”的前提下的，万一我们的缓存服务出了问题，它的速度变慢了，甚至是超时、无响应呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/12/b1/1267b73837eaa9370651e468c1c536b1.jpg?wh=1607x717\" alt=\"\"></p><p>这时候，如果你回过头来分析代码段1的话，你就会发现：程序执行流程会卡在第二步，迟迟无法进行第三步。具体来说，是因为getCacheInfo()它是一个挂起函数，只有这个程序执行成功以后，才可以继续执行后面的任务。你也可以把getCacheInfo()当中的delay时间修改成2000毫秒，去验证一下。</p><pre><code class=\"language-plain\">/*\n执行结果：\nxxxId==9.9\nTime cost: 2013\nxxxId==9.8\nTime cost: 2214\n*/\n</code></pre><p>那么，面对这样的场景，我们其实需要一个可以<strong>灵活选择</strong>的语法：“两个挂起函数同时执行，谁返回的速度更快，我们就选择谁”。这其实就是select的典型使用场景。</p><h2>select和async</h2><p>上面的这个场景，我们可以用async搭配select来使用。async可以实现并发，select则可以选择最快的结果。</p><p>让我们来看看，代码具体该怎么写。</p><pre><code class=\"language-plain\">// 代码段2\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val productId = \"xxxId\"\n    //          1，注意这里\n    //               ↓\n    val product = select&lt;Product?&gt; {\n        // 2，注意这里\n        async { getCacheInfo(productId) }\n            .onAwait { // 3，注意这里\n                it\n            }\n        // 4，注意这里\n        async { getNetworkInfo(productId) }\n            .onAwait {  // 5，注意这里\n                it\n            }\n    }\n\n    if (product != null) {\n        updateUI(product)\n        println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n    }\n}\n\n/*\n输出结果\nxxxId==9.9\nTime cost: 127\n*/\n</code></pre><p>从上面的执行结果，我们可以看到，由于缓存的服务更快，所以，select确实帮我们选择了更快的那个结果。代码中一共有四个注释，我们一起来看看：</p><ul>\n<li>注释1，我们使用select这个高阶函数包裹了两次查询的服务，同时传入了泛型参数Product，代表我们要选择的数据类型是Product。</li>\n<li>注释2，4中，我们使用了async包裹了getCacheInfo()、getNetworkInfo()这两个挂起函数，这是为了让这两个查询实现并发执行。</li>\n<li>注释3，5中，我们使用onAwait{} 将执行结果传给了select{}，而select才能进一步将数据返回给product局部变量。<strong>注意了，这里我们用的onAwait{}，而不是await()。</strong></li>\n</ul><p>现在，假设，我们的缓存服务出现了问题，需要2000毫秒才能返回：</p><pre><code class=\"language-plain\">// 代码段3\nsuspend fun getCacheInfo(productId: String): Product? {\n    // 注意这里\n    delay(2000L)\n    return Product(productId, 9.9)\n}\n\n/*\n输出结果\nxxxId==9.8\nTime cost: 226\n*/\n</code></pre><p>这时候，通过执行结果，我们可以发现，我们的select可以在缓存服务出现问题的时候，灵活选择网络服务的结果。从而避免用户等待太长的时间，得到糟糕的体验。</p><p>不过，你也许发现了，“代码段1”和“代码段2”其实并不是完全等价的。因为在代码段2当中，用户大概率是会展示旧的缓存信息。但实际场景下，我们是需要进一步更新最新信息的。</p><p>其实，在代码段2的基础上，我们也可以轻松实现，只是说，这里我们需要为Product这个数据类增加一个标记。</p><pre><code class=\"language-plain\">// 代码段4\ndata class Product(\n    val productId: String,\n    val price: Double,\n    // 是不是缓存信息\n    val isCache: Boolean = false\n)\n</code></pre><p>然后，我们还需要对代码段2的逻辑进行一些提取：</p><pre><code class=\"language-plain\">// 代码段5\nfun main() = runBlocking {\n    suspend fun getCacheInfo(productId: String): Product? {\n        delay(100L)\n        return Product(productId, 9.9)\n    }\n\n    suspend fun getNetworkInfo(productId: String): Product? {\n        delay(200L)\n        return Product(productId, 9.8)\n    }\n\n    fun updateUI(product: Product) {\n        println(\"${product.productId}==${product.price}\")\n    }\n\n    val startTime = System.currentTimeMillis()\n    val productId = \"xxxId\"\n\n    // 1，缓存和网络，并发执行\n    val cacheDeferred = async { getCacheInfo(productId) }\n    val latestDeferred = async { getNetworkInfo(productId) }\n\n    // 2，在缓存和网络中间，选择最快的结果\n    val product = select&lt;Product?&gt; {\n        cacheDeferred.onAwait {\n                it?.copy(isCache = true)\n            }\n\n        latestDeferred.onAwait {\n                it?.copy(isCache = false)\n            }\n    }\n\n    // 3，更新UI\n    if (product != null) {\n        updateUI(product)\n        println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n    }\n\n    // 4，如果当前结果是缓存，那么再取最新的网络服务结果\n    if (product != null &amp;&amp; product.isCache) {\n        val latest = latestDeferred.await()?: return@runBlocking\n        updateUI(latest)\n        println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n    }\n}\n\n/*\n输出结果：\nxxxId==9.9\nTime cost: 120\nxxxId==9.8\nTime cost: 220\n*/\n</code></pre><p>如果你对比代码段1和代码段5的执行结果，会发现代码段5的总体耗时更短。</p><p>另外在上面的代码中，还有几个注释，我们一个个看：</p><ul>\n<li>首先看注释1，我们将getCacheInfo()、getNetworkInfo()提取到了select的外部，让它们通过async并发执行。如果你还记得第16讲思考题当中的逻辑，你一定可以理解这里的async并发。（如果你忘了，可以回过头去看看。）</li>\n<li>注释2，我们仍然是通过select选择最快的那个结果，接着在注释3这里我们第一时间更新UI界面。</li>\n<li>注释4，我们判断当前的product是不是来自于缓存，如果是的话，我们还需要用最新的信息更新UI。</li>\n</ul><p>然后在这里，假设我们的缓存服务出现了问题，需要2000毫秒才能返回：</p><pre><code class=\"language-plain\">// 代码段6\nsuspend fun getCacheInfo(productId: String): Product? {\n    // 注意这里\n    delay(2000L)\n    return Product(productId, 9.9)\n}\n\n/*\n输出结果\nxxxId==9.8\nTime cost: 224\n*/\n</code></pre><p>可以看到，代码仍然可以正常执行。其实，当前的这个例子很简单，不使用select同样也可以实现。不过，select这样的代码模式的优势在于，<strong>扩展性非常好</strong>。</p><p>下面，我们可以再来假设一下，现在我们有了多个缓存服务。</p><p><img src=\"https://static001.geekbang.org/resource/image/dy/2b/dyydce7b6a709e2725bbffec9726312b.jpg?wh=1550x736\" alt=\"\"></p><p>对于这个问题，我们其实只需要稍微改动一下代码段3就行了。</p><pre><code class=\"language-plain\">// 代码段7\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val productId = \"xxxId\"\n\n    val cacheDeferred = async { getCacheInfo(productId) }\n    // 变化在这里\n    val cacheDeferred2 = async { getCacheInfo2(productId) }\n    val latestDeferred = async { getNetworkInfo(productId) }\n\n    val product = select&lt;Product?&gt; {\n        cacheDeferred.onAwait {\n            it?.copy(isCache = true)\n        }\n\n        // 变化在这里\n        cacheDeferred2.onAwait {\n            it?.copy(isCache = true)\n        }\n\n        latestDeferred.onAwait {\n            it?.copy(isCache = false)\n        }\n    }\n\n    if (product != null) {\n        updateUI(product)\n        println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n    }\n\n    if (product != null &amp;&amp; product.isCache) {\n        val latest = latestDeferred.await() ?: return@runBlocking\n        updateUI(latest)\n        println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n    }\n}\n\n/*\n输出结果\nxxxId==9.9\nTime cost: 125\nxxxId==9.8\nTime cost: 232\n*/\n</code></pre><p>可以看到，当增加一个缓存服务进来的时候，我们的代码只需要做很小的改动，就可以实现。</p><p>所以，总的来说，对比传统的挂起函数串行的执行流程，select这样的代码模式，不仅可以提升程序的整体响应速度，还可以大大提升程序的<strong>灵活性、扩展性</strong>。</p><h2>select和Channel</h2><p>在前面的课程我们提到过，在协程中返回一个内容的时候，我们可以使用挂起函数、async，但如果要返回多个结果的话，就要用Channel和Flow。</p><p>那么，这里我们来看看select和Channel的搭配使用。这里，我们有两个管道，channel1、channel2，它们里面的内容分别是1、2、3；a、b、c，我们通过select，将它们当中的数据收集出来并打印。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/e4/d2d280yy62f88e03522a435b3abyy9e4.gif?wh=1080x608\" alt=\"图片\"></p><p>对于这个问题，如果我们不借助select来实现的话，其实可以大致做到，但结果不会令人满意。</p><pre><code class=\"language-plain\">// 代码段8\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val channel1 = produce {\n        send(1)\n        delay(200L)\n        send(2)\n        delay(200L)\n        send(3)\n        delay(150L)\n    }\n\n    val channel2 = produce {\n        delay(100L)\n        send(\"a\")\n        delay(200L)\n        send(\"b\")\n        delay(200L)\n        send(\"c\")\n    }\n\n    channel1.consumeEach {\n        println(it)\n    }\n\n    channel2.consumeEach {\n        println(it)\n    }\n\n    println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n}\n\n/*\n输出结果\n1\n2\n3\na\nb\nc\nTime cost: 989\n*/\n</code></pre><p>可以看到，通过普通的方式，我们的代码是串行执行的，执行结果并不符合预期。channel1执行完毕以后，才会执行channel2，程序总体的执行时间，也是两者的总和。最关键的是，如果channel1当中如果迟迟没有数据的话，我们的程序会一直卡着不执行。</p><p>当然，以上的问题，我们通过其他方式也可以解决，但最方便的解决方案，还是select。让我们来看看select与Channel搭配后，会带来什么样的好处。</p><pre><code class=\"language-plain\">// 代码段9\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val channel1 = produce {\n        send(\"1\")\n        delay(200L)\n        send(\"2\")\n        delay(200L)\n        send(\"3\")\n        delay(150L)\n    }\n\n    val channel2 = produce {\n        delay(100L)\n        send(\"a\")\n        delay(200L)\n        send(\"b\")\n        delay(200L)\n        send(\"c\")\n    }\n\n    suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; {\n        // 1， 选择channel1\n        channel1.onReceive{\n            it.also { println(it) }\n        }\n        // 2， 选择channel1\n        channel2.onReceive{\n            it.also { println(it) }\n        }\n    }\n\n    repeat(6){// 3， 选择6次结果\n        selectChannel(channel1, channel2)\n    }\n\n    println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n}\n\n/*\n输出结果\n1\na\n2\nb\n3\nc\nTime cost: 540\n*/\n</code></pre><p>从程序的执行结果中，我们可以看到，程序的输出结果符合预期，同时它的执行耗时，也比代码段8要少很多。上面的代码中有几个注释，我们来看看：</p><ul>\n<li>注释1和2，onReceive{} 是Channel在select当中的语法，当Channel当中有数据以后，它就会被回调，通过这个Lambda，我们也可以将结果传出去。</li>\n<li>注释3，这里我们执行了6次select，目的是要把两个管道中的所有数据都消耗掉。管道1有3个数据、管道2有3个数据，所以加起来，我们需要选择6次。</li>\n</ul><p>这时候，假设channel1出了问题，它不再产生数据了，我们看看程序会怎么样执行。</p><pre><code class=\"language-plain\">// 代码段10\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val channel1 = produce&lt;String&gt; {\n        // 变化在这里\n        delay(15000L)\n    }\n\n    val channel2 = produce {\n        delay(100L)\n        send(\"a\")\n        delay(200L)\n        send(\"b\")\n        delay(200L)\n        send(\"c\")\n    }\n\n    suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String = select&lt;String&gt; {\n        channel1.onReceive{\n            it.also { println(it) }\n        }\n        channel2.onReceive{\n            it.also { println(it) }\n        }\n    }\n\n    // 变化在这里\n    repeat(3){\n        selectChannel(channel1, channel2)\n    }\n\n    println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n}\n\n/*\n输出结果\na\nb\nc\nTime cost: 533\n*/\n</code></pre><p>在上面的代码中，我们将channel1当中的send()都删除了，并且，repeat()的次数变成了3次，因为管道里只有三个数据了。</p><p>这时候，我们发现，select也是可以正常执行的。</p><p>不过，我们有时候可能并不清楚每个Channel当中有多少个数据，比如说，这里如果我们还是写repeat(6)的话，程序就会出问题了。</p><pre><code class=\"language-plain\">// 代码段11\n\n// 仅改动这里\nrepeat(6){\n    selectChannel(channel1, channel2)\n}\n/*\n崩溃：\nException in thread \"main\" ClosedReceiveChannelException: Channel was closed\n*/\n</code></pre><p>这时候，你应该就能反应过来了，由于我们的channel2当中只有3个数据，它发送完数据以后就会被关闭，而我们的select是会被调用6次的，所以就会触发上面的ClosedReceiveChannelException异常。</p><p>在19讲当中，我们学过receiveCatching()这个方法，它可以封装Channel的结果，防止出现ClosedReceiveChannelException。类似的，当Channel与select配合的时候，我们可以使用onReceiveCatching{} 这个高阶函数。</p><pre><code class=\"language-plain\">// 代码段12\n\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val channel1 = produce&lt;String&gt; {\n        delay(15000L)\n    }\n\n    val channel2 = produce {\n        delay(100L)\n        send(\"a\")\n        delay(200L)\n        send(\"b\")\n        delay(200L)\n        send(\"c\")\n    }\n\n    suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String =\n        select&lt;String&gt; {\n            channel1.onReceiveCatching {\n                it.getOrNull() ?: \"channel1 is closed!\"\n            }\n            channel2.onReceiveCatching {\n                it.getOrNull() ?: \"channel2 is closed!\"\n            }\n        }\n\n    repeat(6) {\n        val result = selectChannel(channel1, channel2)\n        println(result)\n    }\n\n    println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n}\n\n/*\n输出结果\na\nb\nc\nchannel2 is closed!\nchannel2 is closed!\nchannel2 is closed!\nTime cost: 541\n程序不会立即退出\n*/\n</code></pre><p>这时候，即使我们不知道管道里有多少个数据，我们也不用担心崩溃的问题了。在onReceiveCatching{} 这个高阶函数当中，我们可以使用it.getOrNull()来获取管道里的数据，如果获取的结果是null，就代表管道已经被关闭了。</p><p>不过，上面的代码仍然还有一个问题，那就是，当我们得到所有结果以后，程序不会立即退出，因为我们的channel1一直在delay()。这时候，当我们完成6次repeat()调用以后，我们将channel1、channel2取消即可。</p><pre><code class=\"language-plain\">// 代码段13\n\nfun main() = runBlocking {\n    val startTime = System.currentTimeMillis()\n    val channel1 = produce&lt;String&gt; {\n        delay(15000L)\n    }\n\n    val channel2 = produce {\n        delay(100L)\n        send(\"a\")\n        delay(200L)\n        send(\"b\")\n        delay(200L)\n        send(\"c\")\n    }\n\n    suspend fun selectChannel(channel1: ReceiveChannel&lt;String&gt;, channel2: ReceiveChannel&lt;String&gt;): String =\n        select&lt;String&gt; {\n            channel1.onReceiveCatching {\n                it.getOrNull() ?: \"channel1 is closed!\"\n            }\n            channel2.onReceiveCatching {\n                it.getOrNull() ?: \"channel2 is closed!\"\n            }\n        }\n\n    repeat(6) {\n        val result = selectChannel(channel1, channel2)\n        println(result)\n    }\n\n    // 变化在这里\n    channel1.cancel()\n    channel2.cancel()\n\n    println(\"Time cost: ${System.currentTimeMillis() - startTime}\")\n}\n</code></pre><p>这时候，我们对比一下代码段13和代码段10的话，就会发现程序的执行效率提升的同时，扩展性和灵活性也更好了。</p><blockquote>\n<p>提示：这种将多路数据以非阻塞的方式合并成一路数据的模式，在其他领域也有广泛的应用，比如说操作系统、Java NIO（Non-blocking I/O），等等。如果你能理解这个案例中的代码，相信你对操作系统、NIO之类的技术也会有一个新的认识。</p>\n</blockquote><h2>思考与实战</h2><p>如果你足够细心的话，你会发现，当我们的Deferred、Channel与select配合的时候，它们原本的API会多一个on前缀。</p><pre><code class=\"language-plain\">public interface Deferred : CoroutineContext.Element {\n    public suspend fun join()\n    public suspend fun await(): T\n\n    // select相关  \n    public val onJoin: SelectClause0\n    public val onAwait: SelectClause1&lt;T&gt;\n}\n\npublic interface SendChannel&lt;in E&gt; \n    public suspend fun send(element: E)\n\n    // select相关\n    public val onSend: SelectClause2&lt;E, SendChannel&lt;E&gt;&gt;\n\n}\n\npublic interface ReceiveChannel&lt;out E&gt; {\n    public suspend fun receive(): E\n\n    public suspend fun receiveCatching(): ChannelResult&lt;E&gt;\n    // select相关\n    public val onReceive: SelectClause1&lt;E&gt;\n    public val onReceiveCatching: SelectClause1&lt;ChannelResult&lt;E&gt;&gt;\n}\n</code></pre><p>所以，只要你记住了Deferred、Channel的API，你是不需要额外记忆select的API的，只需要在原本的API的前面加上一个on就行了。</p><p>另外你要注意，当select与Deferred结合使用的时候，当并行的Deferred比较多的时候，你往往需要在得到一个最快的结果以后，去取消其他的Deferred。</p><p>比如说，对于Deferred1、Deferred2、Deferred3、Deferred4、Deferred5，其中Deferred2返回的结果最快，这时候，我们往往会希望取消其他的Deferred，以节省资源。那么在这个时候，我们可以使用类似这样的方式：</p><pre><code class=\"language-plain\">fun main() = runBlocking {\n    suspend fun &lt;T&gt; fastest(vararg deferreds: Deferred&lt;T&gt;): T = select {\n        fun cancelAll() = deferreds.forEach { it.cancel() }\n\n        for (deferred in deferreds) {\n            deferred.onAwait {\n                cancelAll()\n                it\n            }\n        }\n    }\n\n    val deferred1 = async {\n        delay(100L)\n        println(\"done1\")    // 没机会执行\n        \"result1\"\n    }\n\n    val deferred2 = async {\n        delay(50L)\n        println(\"done2\")\n        \"result2\"\n    }\n\n    val deferred3 = async {\n        delay(10000L)\n        println(\"done3\")    // 没机会执行\n        \"result3\"\n    }\n\n    val deferred4 = async {\n        delay(2000L)\n        println(\"done4\")    // 没机会执行\n        \"result4\"\n    }\n\n    val deferred5 = async {\n        delay(14000L)\n        println(\"done5\")    // 没机会执行\n        \"result5\"\n    }\n\n    val result = fastest(deferred1, deferred2, deferred3, deferred4, deferred5)\n    println(result)\n}\n\n/*\n输出结果\ndone2\nresult2\n*/\n</code></pre><p>所以，借助这样的方式，我们不仅可以通过async并发执行协程，也可以借助select得到最快的结果，而且，还可以避免不必要的资源浪费。</p><h2>小结</h2><p>好，这节课的内容就到这儿了，我们来做一个简单的总结。</p><ul>\n<li>select，就是选择“更快的结果”。</li>\n<li>当select与async、Channel搭配以后，我们可以并发执行协程任务，以此大大提升程序的执行效率甚至用户体验，并且还可以改善程序的扩展性、灵活性。</li>\n<li>关于select的API，我们完全不需要去刻意记忆，只需要在Deferred、Channel的API基础上加上on这个前缀即可。</li>\n<li>最后，我们还结合实战，分析了select与async产生太多并发协程的时候，还可以定义一个类似fastest()的方法，去统一取消剩余的协程任务。这样的做法，就可以大大节省计算资源，从而平衡性能与功耗。</li>\n</ul><p><img src=\"https://static001.geekbang.org/resource/image/5c/5b/5c3e1e2b9e00c367e413428d40994f5b.jpg?wh=2000x853\" alt=\"\"></p><p>其实，和Kotlin的Channel一样，select并不是Kotlin独创的概念。select在很多编程语言当中都有类似的实现，比如Go、Rust，等等。在这些计算机语言当中，select的语法可能与Kotlin的不太一样，但背后的核心理念都是“选择更快的结果”。</p><p>所以，只要你掌握了Kotlin的select，今后学习其他编程语言的select，都不再是问题。</p><h2>思考题</h2><p>前面我们已经说过，select的API，只需要在Deferred、Channel原本API的基础上加一个on前缀即可。比如onAwait{}。那么，你有没有觉得它跟我们前面学的onStart{}、onCompletion{} 之类的回调API很像？</p><p>你能从中悟出select的实现原理吗？ 欢迎在留言区说说你的想法，也欢迎你把今天的内容分享给更多的朋友。</p>","neighbors":{"left":{"article_title":"20 | Flow：为什么说Flow是“冷”的？","id":491632},"right":{"article_title":"22 | 并发：协程不需要处理同步吗？","id":493069}},"comments":[{"had_liked":false,"id":337878,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1647105767,"is_pvip":false,"replies":[{"id":"123585","content":"你这么说也是有道理的，协程API有它的优势，但它的门槛太高了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1647235767,"ip_address":"","comment_id":337878,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10237040359","product_id":100103401,"comment_content":"作为一个 Android 开发同学，我感觉协程没 Kotlin 基础语法香。<br>因为在 Android 中，异步任务没那么多，也没什么嵌套，只要稍加封装，用起来也没那么痛。<br>所以协程没想象中的那么实用。","like_count":3,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556162,"discussion_content":"你这么说也是有道理的，协程API有它的优势，但它的门槛太高了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647235767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576579,"discussion_content":"取决于业务场景，复杂的业务场景需要简洁的方案。反过来，各个方案也有适合的业务场景。先学着，后续可能用得上。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1655685722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357072,"user_name":"瞌睡的李先生","can_delete":false,"product_type":"c1","uid":2264685,"ip_address":"浙江","ucode":"88480FAFB4F879","user_header":"https://static001.geekbang.org/account/avatar/00/22/8e/6d/f2354440.jpg","comment_is_top":false,"comment_ctime":1662912102,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1662912102","product_id":100103401,"comment_content":"学过go语言的同学会感觉到这一篇真的特别好理解。学到现在感觉kotlin的协程有种集百家之长的感觉，对于多种语言背景的同学都可以方便地学习上手。","like_count":1},{"had_liked":false,"id":343720,"user_name":"抱紧我的小鲤鱼","can_delete":false,"product_type":"c1","uid":1014603,"ip_address":"","ucode":"139780FB860FA3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/4b/95812b15.jpg","comment_is_top":false,"comment_ctime":1651022816,"is_pvip":true,"replies":[{"id":"125638","content":"其实就是：“多路复用”","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1651245998,"ip_address":"","comment_id":343720,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1651022816","product_id":100103401,"comment_content":"不是很理解select的应用场景","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568886,"discussion_content":"其实就是：“多路复用”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651245999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340509,"user_name":"jim","can_delete":false,"product_type":"c1","uid":1491946,"ip_address":"","ucode":"C12DB0F2B570F6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Urc67zDC8R6dh9U1ZFTF36icXewM1seehvOUYUs4hyWSsFzS5WQc2RcrE1Mzs8qtgib5SM5wFrVh22QcQd0JUUBw/132","comment_is_top":false,"comment_ctime":1648869834,"is_pvip":false,"replies":[{"id":"124597","content":"select当然比单纯的Channel复杂，但需要级联多个Channel的场景下，其他手段一定会比select更复杂~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1649134420,"ip_address":"","comment_id":340509,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648869834","product_id":100103401,"comment_content":"配合Channel使用感觉变复杂了","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560032,"discussion_content":"select当然比单纯的Channel复杂，但需要级联多个Channel的场景下，其他手段一定会比select更复杂~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649134420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339396,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1648074695,"is_pvip":false,"replies":[{"id":"124303","content":"一方面是因为有了combine操作符，另一方面也是因为Flow有多种实现“冷的Flow”，“热的SharedFlow”等等，一个select已经很难兼顾这些实现了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1648522015,"ip_address":"","comment_id":339396,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1648074695","product_id":100103401,"comment_content":"请问老师，是不是flow因为有了combine等操作符就不需要select了?","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558913,"discussion_content":"一方面是因为有了combine操作符，另一方面也是因为Flow有多种实现“冷的Flow”，“热的SharedFlow”等等，一个select已经很难兼顾这些实现了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648522015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337424,"user_name":"better","can_delete":false,"product_type":"c1","uid":1169063,"ip_address":"","ucode":"AF1DB566EBB8A5","user_header":"https://static001.geekbang.org/account/avatar/00/11/d6/a7/ac23f5a6.jpg","comment_is_top":false,"comment_ctime":1646816842,"is_pvip":false,"replies":[{"id":"123329","content":"嗯，差不多是这个流程。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646886099,"ip_address":"","comment_id":337424,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646816842","product_id":100103401,"comment_content":"onXXX 表示回调的多，另外也可以表示会自动执行的方法（看个人习惯）。<br>感觉源代码难读，大概读了一下，发现有个注册回调的地方，当回调执行时，会判断一下 isSelected，如 select 已选择，则后续的就不走了。不知道对不对","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555375,"discussion_content":"嗯，差不多是这个流程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646886099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337333,"user_name":"白乾涛","can_delete":false,"product_type":"c1","uid":1339841,"ip_address":"","ucode":"0C704B0B90C8D7","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/c1/cbc55e06.jpg","comment_is_top":false,"comment_ctime":1646757871,"is_pvip":false,"replies":[{"id":"123334","content":"嗯，大概是这么个意思，但可以讲的更清楚一点哈。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646886486,"ip_address":"","comment_id":337333,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646757871","product_id":100103401,"comment_content":"所有的 onXX 都是回调<br>所有的异步都会用到回调","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555380,"discussion_content":"嗯，大概是这么个意思，但可以讲的更清楚一点哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646886486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337132,"user_name":"L先生","can_delete":false,"product_type":"c1","uid":2879424,"ip_address":"","ucode":"D1E567ED3377CE","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ef/c0/537b3905.jpg","comment_is_top":false,"comment_ctime":1646641856,"is_pvip":false,"replies":[{"id":"123275","content":"很接近了。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646754401,"ip_address":"","comment_id":337132,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1646641856","product_id":100103401,"comment_content":"是不是类似于callback，包了一层，返回出去。内部可能每个包个async，然后谁先出数据就callback出去","like_count":1,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555129,"discussion_content":"很接近了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646754401,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1342000,"avatar":"https://static001.geekbang.org/account/avatar/00/14/7a/30/23fc4089.jpg","nickname":"24隋心所欲","note":"","ucode":"1B8B2789F68C94","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592068,"discussion_content":"回调 callback + 异步 async","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667056091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337110,"user_name":"神秘嘉Bin","can_delete":false,"product_type":"c1","uid":2879116,"ip_address":"","ucode":"6045F09320E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/2b/ee/8c/06f3aef0.jpg","comment_is_top":false,"comment_ctime":1646627951,"is_pvip":false,"replies":[{"id":"123280","content":"思考的方向对了，其实本质上还是注册了回调。","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646755242,"ip_address":"","comment_id":337110,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646627951","product_id":100103401,"comment_content":"是不是利用了onComplete和onStart进行计时，然后返回最快的一个？","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555136,"discussion_content":"思考的方向对了，其实本质上还是注册了回调。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646755242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337103,"user_name":"Renext","can_delete":false,"product_type":"c1","uid":1020838,"ip_address":"","ucode":"3C4418F7E86CD6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/a6/679b3c6b.jpg","comment_is_top":false,"comment_ctime":1646623645,"is_pvip":false,"replies":[{"id":"123277","content":"加油~","user_name":"作者回复","user_name_real":"编辑","uid":"1180670","ctime":1646755160,"ip_address":"","comment_id":337103,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1646623645","product_id":100103401,"comment_content":"学习了","like_count":0,"discussions":[{"author":{"id":1180670,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/fe/0f43ef35.jpg","nickname":"朱涛","note":"","ucode":"5AB5AFE32B8008","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555133,"discussion_content":"加油~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646755160,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}