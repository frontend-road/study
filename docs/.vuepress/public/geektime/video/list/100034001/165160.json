{"id":165160,"title":"97 | Swift中的内存安全性","content":"<p><strong>课件地址</strong></p><p><a href=\"https://gitee.com/geektime-geekbang/swift-course\">https://gitee.com/geektime-geekbang/swift-course</a></p>","comments":[{"had_liked":false,"id":151469,"user_name":"Life is fantastic","can_delete":false,"product_type":"c3","uid":1627686,"ip_address":"","ucode":"CB53002C82F1AA","user_header":"https://static001.geekbang.org/account/avatar/00/18/d6/26/8c06d424.jpg","comment_is_top":false,"comment_ctime":1573725908,"is_pvip":false,"replies":[{"id":59127,"content":"你看的《所有权宣言》这篇文档，只是swift的一个提案，这个提案目前是没有实现的，而且swift未来要不要实现，怎么实现都是未知的。\nswift中本来就可以对类并发访问，要不多线程的作用置于何地。 swift中也提供原子操作的函数，那都是比较底层了，而且针对基本数值类型。但是对类属性访问的原子性不像OC一样有Atomic，你可以自己写getter和setter实现原子操作。  或者你看一下92课《SwiftUI原理探秘》，自己实现一个propertyWrapper来实现一个原子操作的wrapper","user_name":"作者回复","user_name_real":"Geek_f72435","uid":1341726,"ctime":1574318048,"ip_address":"","comment_id":151469,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"我看王巍翻译的官方所有权宣言，里面有独占性的动态强制，说对一个类的并行访问是允许的。那么结合老师视频，我提出假设，“并行的时候可以对内存进行又写又读，这个假设的前提不能在一步长时访问中同时出现，但可以分开读写。相当于原子操作帮我们加了一把锁？所以swift现在没有原子操作需要我们自己加锁。”就是说视频的原理和宣言文档的原理必须结合使用，否则还是会出错。不知道老师如何评价我这个观点。\n\n\n题外话，自己前年打酱油路过看王巍老哥的翻译当时我完全看不懂的，我最近看了stack overflow回到了官方的doc里看了原文，实在翻译加理解头大冥冥中想起了这个翻译。作为过来人我建议有兴趣的同学可以学习张老师的这个视频和Swift文档后尝试去看这篇文档和王巍老哥的翻译，特别是看不懂老哥写的东西可以去看原文，直接生吃估计会吐，不过可以吃个生蟹腿帮助消化。","like_count":1,"discussions":[{"author":{"id":1341726,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLxtKhpmvzx2VB4iajicfJVFmQR3eP3xBpdpQEovpSqUfAOrNImvYwVb7P37ibI0ONziau9sbFEk8oDaA/132","nickname":"elfgate","note":"","ucode":"3C0B5F7C1F664C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474484,"discussion_content":"你看的《所有权宣言》这篇文档，只是swift的一个提案，这个提案目前是没有实现的，而且swift未来要不要实现，怎么实现都是未知的。\nswift中本来就可以对类并发访问，要不多线程的作用置于何地。 swift中也提供原子操作的函数，那都是比较底层了，而且针对基本数值类型。但是对类属性访问的原子性不像OC一样有Atomic，你可以自己写getter和setter实现原子操作。  或者你看一下92课《SwiftUI原理探秘》，自己实现一个propertyWrapper来实现一个原子操作的wrapper","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574313731,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":151546,"user_name":"Life is fantastic","can_delete":false,"product_type":"c3","uid":1627686,"ip_address":"","ucode":"CB53002C82F1AA","user_header":"https://static001.geekbang.org/account/avatar/00/18/d6/26/8c06d424.jpg","comment_is_top":false,"comment_ctime":1573738732,"is_pvip":false,"replies":[{"id":59126,"content":"你看的《所有权宣言》这篇文档，只是swift的一个提案，这个提案目前是没有实现的，而且swift未来要不要实现，怎么实现都是未知的。\n我讲的是现在swift中所具有的内存安全性的知识，你有疑惑或者报错的代码是什么可以share一下，我们具体问题具体分析","user_name":"作者回复","user_name_real":"Geek_f72435","uid":1341726,"ctime":1574317538,"ip_address":"","comment_id":151546,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"我有一个疑惑，强制对整体值使用独占性原则，是不是通过一些@之类的标注代码手动进行强制？因为我测试了代码不管有没有其他计算属性或是静态属性都不会将访问独立开来，都是报错。还有我发现值类型的实例在不是属性的情况下，能将整体值和属性成员间的访问独立开来。因为都是报错，所以那么文档说的特殊情况就不存在了，必定是手动去控制这种强制操作了。那我想问下老师是不是需要手动控制才能作为独立的属性成员处理，和整体值得访问独立开来。","like_count":0,"discussions":[{"author":{"id":1341726,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLxtKhpmvzx2VB4iajicfJVFmQR3eP3xBpdpQEovpSqUfAOrNImvYwVb7P37ibI0ONziau9sbFEk8oDaA/132","nickname":"elfgate","note":"","ucode":"3C0B5F7C1F664C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474525,"discussion_content":"你看的《所有权宣言》这篇文档，只是swift的一个提案，这个提案目前是没有实现的，而且swift未来要不要实现，怎么实现都是未知的。\n我讲的是现在swift中所具有的内存安全性的知识，你有疑惑或者报错的代码是什么可以share一下，我们具体问题具体分析","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574313836,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1627686,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d6/26/8c06d424.jpg","nickname":"Life is fantastic","note":"","ucode":"CB53002C82F1AA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50840,"discussion_content":"我知道特殊情况是什么了哈，是mutating，果然手动强制，一点没毛病，不知庐山真面目，只缘身在此山中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573779399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336697,"user_name":"Null","can_delete":false,"product_type":"c3","uid":1382587,"ip_address":"","ucode":"A7D4DF2A43C7D8","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/bb/9299fab1.jpg","comment_is_top":false,"comment_ctime":1646296054,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"这里发生错误的基本都是值类型，总体就是不能同时访问一块内存，可以简单理解为同一个变量，同一个属性都不可以。基本不会发生memory safety问题了。","like_count":0},{"had_liked":false,"id":151790,"user_name":"Life is fantastic","can_delete":false,"product_type":"c3","uid":1627686,"ip_address":"","ucode":"CB53002C82F1AA","user_header":"https://static001.geekbang.org/account/avatar/00/18/d6/26/8c06d424.jpg","comment_is_top":false,"comment_ctime":1573792608,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100034001,"comment_content":"差不多都理清了，inout mutating都是静态方式限制变量或属性重入的手段，只要代码写的不过分就不会出现内存安全，养成习惯遵守规则就不会失足。","like_count":0}]}