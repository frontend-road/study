{"id":741036,"title":"第 13 章 Linux系统管理技巧(2)","content":"<h2 id=\"nav_point_262\">13.4 Linux的防火墙</h2>\n<p>Linux下的防火墙功能非常丰富，但阿铭在日常的运维工作中，使用防火墙的情况并不多。接下来，阿铭打算把一些常用的知识点介绍给大家。</p>\n<h3 id=\"nav_point_263\">13.4.1 SELinux</h3>\n<p>SELinux是Linux系统特有的安全机制。因为这种机制的限制太多，配置也特别烦琐，所以几乎没有人真正应用它。安装完系统，我们一般都要把SELinux关闭，以免引起不必要的麻烦。临时关闭SELinux的方法为：</p>\n<pre class=\"code-rows\"><code># setenforce 0</code></pre>\n<p>但这仅仅是临时的，要想永久关闭，需要更改配置文件 /etc/selinux/config，需要把<code>SELINUX= enforcing</code>改成<code>SELINUX=disabled</code>，更改后的配置文件如下所示：</p>\n<pre class=\"code-rows\"><code># cat /etc/selinux/config\n\n# This file controls the state of SELinux on the system.\n# SELINUX= can take one of these three values:\n# enforcing - SELinux security policy is enforced.\n# permissive - SELinux prints warnings instead of enforcing.\n# disabled - No SELinux policy is loaded.\nSELINUX=disabled\n# SELINUXTYPE= can take one of three two values:\n# targeted - Targeted processes are protected,\n# minimum - Modification of targeted policy. Only selected processes are protected.\n# mls - Multi Level Security protection.\nSELINUXTYPE=targeted</code></pre>\n<p>更改完该配置文件后，重启系统方可生效。可以使用<code>getenforce</code>命令获得当前SELinux的状态，如下所示：</p>\n<pre class=\"code-rows\"><code># getenforce\nDisabled</code></pre>\n<p>阿铭的SELinux早就关闭了，所以会显示为<code>Disabled</code>，如果还没有关闭则会默认输出<code>enforcing</code>。当使用<code>setenforce 0</code>这个命令后，再执行<code>getenforce</code>命令会输出<code>permissive</code>。</p>\n<h3 id=\"nav_point_264\">13.4.2 netfilter</h3>\n<p>在之前的CentOS版本（比如CentOS 6）中，防火墙为netfilter，从CentOS 7开始，防火墙为firewalld。很多朋友把Linux的防火墙叫作iptables，其实这样叫并不太恰当，iptables仅仅是一个工具。对于CentOS 7或者CentOS 8上的firewalld，阿铭目前在工作中使用得并不多。当然，即使是firewalld，同样也支持之前版本的命令用法，也就是说它是向下兼容的。</p><!-- [[[read_end]]] -->\n<p>关于这一节的内容，阿铭是这样安排的。首先大概讲一下之前版本iptables的常用用法，然后再介绍一下firewalld的一些用法。下面阿铭先教你如何把firewalld关闭，然后开启之前版本的iptables。示例命令如下：</p>\n<pre class=\"code-rows\"><code># systemctl stop firewalld // 关闭firewalld服务\n# systemctl disable firewalld // 禁止firewalld服务开机启动，后面将会详细讲解\nRemoved symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\nRemoved symlink /etc/systemd/system/basic.target.wants/firewalld.service.\n# yum install -y iptables-services // 安装iptables-services，这样就可以使用之前版本的iptables了\n# systemctl enable iptables // 让它开机启动\nCreated symlink from /etc/systemd/system/basic.target.wants/iptables.service to /usr/lib/systemd/system/iptables.service.\n# systemctl start iptables // 启动iptables服务</code></pre>\n<p>到此，咱们就可以使用之前版本的iptables了。CentOS上默认设有iptables规则，这个规则虽然很安全，但对于我们来说不但没有用，还会造成某些影响，所以阿铭建议你先清除规则，然后把清除后的规则保存一下。示例命令如下：</p>\n<pre class=\"code-rows\"><code># iptables -nvL\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target prot opt in out source destination\n 21 1620 ACCEPT all -- * * 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED\n 0 0 ACCEPT icmp -- * * 0.0.0.0/0 0.0.0.0/0\n 0 0 ACCEPT all -- lo * 0.0.0.0/0 0.0.0.0/0\n 0 0 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22\n 0 0 REJECT all -- * * 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target prot opt in out source destination\n 0 0 REJECT all -- * * 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibited\n\nChain OUTPUT (policy ACCEPT 16 packets, 1536 bytes)\n pkts bytes target prot opt in out source destination\n# iptables –F\n# service iptables save\niptables: Saving firewall rules to /etc/sysconfig/iptables:[ OK ]</code></pre>\n<p>上例中，<code>-nvL</code>选项表示查看规则，<code>-F</code>选项表示清除当前规则，但清除只是临时的，重启系统或者重启<code>iptalbes</code>服务后还会加载已经保存的规则，所以需要使用<code>service iptables save</code>保存一下规则。通过上面的命令输出，我们也可以看到，防火墙规则保存在 /etc/sysconfig/iptables中，你可以查看一下这个文件。</p>\n<ol>\n<li><p><strong>netfilter的5个表</strong></p>\n<p><code>filter</code>表主要用于过滤包，是系统预设的表，这个表也是阿铭用得最多的表。该表内建3个链：<code>INPUT</code>、<code>OUTPUT</code>以及<code>FORWARD</code>。<code>INPUT</code>链作用于进入本机的包，<code>OUTPUT</code>链作用于本机送出的包，<code>FORWARD</code>链作用于那些跟本机无关的包。</p>\n<p><code>nat</code>表主要用于网络地址转换，它也有3个链。<code>PREROUTING</code>链的作用是在包刚刚到达防火墙时改变它的目的地址（如果需要的话），<code>OUTPUT</code>链的作用是改变本地产生的包的目的地址，<code>POSTROUTING</code>链的作用是在包即将离开防火墙时改变其源地址。该表阿铭仅偶尔会用到。</p>\n<p><code>mangle</code>表主要用于给数据包做标记，然后根据标记去操作相应的包。这个表阿铭几乎不怎么用，除非你想成为一个高级网络工程师，否则不需要太关注。</p>\n<p><code>raw</code>表可以实现不追踪某些数据包。默认系统的数据包都会被追踪，但追踪势必消耗一定的资源，所以可以用<code>raw</code>表来指定某些端口的包不被追踪。这个表，阿铭从来没用过。</p>\n<p><code>security</code>表在CentOS 6中是没有的，它用于强制访问控制（MAC）的网络规则。可以说这个表阿铭都没有深入研究过，更别说使用了。所以，你暂时不用理会它。<br />&nbsp;</p>\n</li>\n<li><p><strong>netfilter的5个链</strong></p>\n<p>5个链分别为<code>PREROUTING</code>、<code>INPUT</code>、<code>FORWARD</code>、<code>OUTPUT</code>、<code>POSTROUTING</code>。</p>\n<ul>\n<li><strong><code>PREROUTING</code></strong>：数据包进入路由表之前。</li>\n<li><strong><code>INPUT</code></strong>：通过路由表后目的地为本机。</li>\n<li><strong><code>FORWARDING</code></strong>：通过路由表后，目的地不为本机。</li>\n<li><strong><code>OUTPUT</code></strong>：由本机产生，向外转发。</li>\n<li><strong><code>POSTROUTIONG</code></strong>：发送到网卡接口之前。</li>\n</ul>\n<p>具体的数据包流向，可以参考图13-2。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100013/image00424.jpeg\" alt=\"\" width=\"85%\" style=\"width: 85%\" /></p>\n<p><strong>图13-2 数据包流向</strong></p>\n<p>表和链对应的关系图13-3所示。</p>\n<p class=\"p-img\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100013/image00425.jpeg\" alt=\"\" width=\"55%\" style=\"width: 55%\" /></p>\n<p><strong>图13-3 表和链的对应关系</strong><br />&nbsp;</p>\n</li>\n<li><p><strong>iptables基本语法</strong></p>\n<p>iptables是一个非常复杂和功能丰富的工具，所以它的语法也是很有特点的。下面阿铭就给大家介绍几种常用的语法。</p>\n<p>(1) 查看规则以及清除规则，其用法如下：</p>\n<pre class=\"code-rows\"><code># iptables -t nat -nvL\nChain PREROUTING (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target prot opt in out source destination\n\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target prot opt in out source destination\n\nChain POSTROUTING (policy ACCEPT 4 packets, 384 bytes)\n pkts bytes target prot opt in out source destination\n\nChain OUTPUT (policy ACCEPT 4 packets, 384 bytes)\n pkts bytes target prot opt in out source destination</code></pre>\n<p><code>-t</code>选项后面跟表名。<code>-nvL</code>表示查看该表的规则，其中<code>-n</code>表示不针对IP反解析主机名，<code>-L</code>表示列出，<code>-v</code>表示列出更加详细的信息。如果不加<code>-t</code>选项，则打印<code>filter</code>表的相关信息，如下所示：</p>\n<pre class=\"code-rows\"><code># iptables -nvL\nChain INPUT (policy ACCEPT 252 packets, 19329 bytes)\n pkts bytes target prot opt in out source destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target prot opt in out source destination\n\nChain OUTPUT (policy ACCEPT 222 packets, 24340 bytes)\n pkts bytes target prot opt in out source destination</code></pre>\n<p>上例和<code>-t filter</code>打印的信息是一样的。在清除规则的命令中，阿铭用得最多的就是下面两个：</p>\n<pre class=\"code-rows\"><code># iptables -F\n# iptables -Z</code></pre>\n<p>这里<code>-F</code>表示把所有规则全部清除，如果不加<code>-t</code>指定表，则默认只清除<code>filter</code>表的规则。<code>-Z</code>表示把包以及流量计数器置零（这个阿铭认为很有用）。</p>\n<p>(2) 增加/删除一条规则，其用法如下：</p>\n<pre class=\"code-rows\"><code># iptables -A INPUT -s 192.168.72.1 -p tcp --sport 1234 -d 192.168.72.128 --dport 80 -j DROP</code></pre>\n<p>这里没有加<code>-t</code>选项，所以针对的是<code>filter</code>表。这条规则中各个选项的作用如下。</p>\n<ul>\n<li><strong><code>-A/-D</code></strong>：表示增加/删除一条规则。</li>\n<li><strong><code>-I</code></strong>：表示插入一条规则，其实效果跟<code>-A</code>一样。</li>\n<li><strong><code>-p</code></strong>：表示指定协议，可以是<code>tcp</code>、<code>udp</code>或者<code>icmp</code>。</li>\n<li><strong><code>--dport</code></strong>：跟<code>-p</code>一起使用，表示指定目标端口。</li>\n<li><strong><code>--sport</code></strong>：跟<code>-p</code>一起使用，表示指定源端口。</li>\n<li><strong><code>-s</code></strong>：表示指定源IP（可以是一个IP段）。</li>\n<li><strong><code>-d</code></strong>：表示指定目的IP（可以是一个IP段）。</li>\n<li><strong><code>-j</code></strong>：后面跟动作，其中<code>ACCEPT</code>表示允许包，<code>DROP</code>表示丢掉包，<code>REJECT</code>表示拒绝包。</li>\n<li><strong><code>-i</code></strong>：表示指定网卡（不常用，但偶尔能用到）。</li>\n</ul>\n<p>下面阿铭再多举几个例子来帮你理解这些概念：</p>\n<pre class=\"code-rows\"><code># iptables -I INPUT -s 1.1.1.1 -j DROP</code></pre>\n<p>上例表示插入一条规则，把来自1.1.1.1的所有数据包丢掉。下例表示删除刚刚插入的规则：</p>\n<pre class=\"code-rows\"><code># iptables -D INPUT -s 1.1.1.1 -j DROP</code></pre>\n<p>注意删除一条规则时，此规则必须和插入时的规则一致。也就是说，两条iptables命令，除了<code>-I</code>和<code>-D</code>不一样外，其他地方都一样。</p>\n<p>下例表示把来自2.2.2.2并且是使用TCP协议到本机80端口的数据包丢掉：</p>\n<pre class=\"code-rows\"><code># iptables -I INPUT -s 2.2.2.2 -p tcp --dport 80 -j DROP</code></pre>\n<p>注意，<code>--dport/--sport</code>必须和<code>-p</code>选项一起使用，否则会出错。</p>\n<p>下例表示把发送到10.0.1.14的22端口的数据包丢掉：</p>\n<pre class=\"code-rows\"><code># iptables -I OUTPUT -p tcp --dport 22 -d 10.0.1.14 -j DROP</code></pre>\n<p>下例表示把来自192.168.1.0/24这个网段且作用在<code>ens33</code>上的包放行：</p>\n<pre class=\"code-rows\"><code># iptables -A INPUT -s 192.168.1.0/24 -i ens33 -j ACCEPT\n# iptables -nvL |grep '192.168.1.0/24'\n0 0 ACCEPT all -- ens33 * 192.168.1.0/24 0.0.0.0/0</code></pre>\n<p>有时候当服务器上的iptables过多，你想删除某一条规则，但又不容易掌握创建时的规则。其实有一种比较简单的方法，先查看iptables规则，示例命令如下：</p>\n<pre class=\"code-rows\"><code># iptables -nvL --line-numbers\nChain INPUT (policy ACCEPT 309 packets, 23689 bytes)\nnum pkts bytes target prot opt in out source destination\n1 0 0 ACCEPT all -- ens33 * 192.168.1.0/24 0.0.0.0/0</code></pre>\n<p>然后删除某一条规则，使用如下命令：</p>\n<pre class=\"code-rows\"><code># iptables -D INPUT 1</code></pre>\n<p>这里<code>-D</code>后面依次跟链名、规则<code>num</code>。这个<code>num</code>就是查看iptables规则时第1列的值。随后再查看刚才的规则，会发现已经没有了，如下所示：</p>\n<pre class=\"code-rows\"><code># iptables -nvL --line-numbers</code></pre>\n<p>iptables还有一个选项经常用到，即<code>-P</code>（大写）选项，它表示预设策略。其用法如下：</p>\n<pre class=\"code-rows\"><code># iptables -P INPUT DROP</code></pre>\n<p><code>-P</code>后面跟链名，策略内容或为<code>DROP</code>，或为<code>ACCEPT</code>，默认是<code>ACCEPT</code>。注意：如果你在连接远程服务器，千万不要随便执行这个命令，因为一旦输入命令并回车，远程连接就会断开。</p>\n<p>这个策略一旦设定后，只有使用命令<code>iptables -P INPUT ACCEPT</code>才能恢复成原始状态。下面阿铭针对一个小需求介绍一下如何设定iptables规则。</p>\n<p><strong>需求</strong>：只针对<code>filter</code>表，预设策略<code>INPUT</code>链<code>DROP</code>，其他两个链<code>ACCEPT</code>，然后针对192.168.72.0/24开通22端口，对所有网段开放80端口，对所有网段开放21端口。</p>\n<p>这个需求不算复杂，但是因为有多条规则，所以最好写成脚本的形式。脚本内容如下：</p>\n<pre class=\"code-rows\"><code># vi /usr/local/sbin/iptables.sh // 写入如下内容\n#! /bin/bash\n\nipt=\"/usr/sbin/iptables\"\n$ipt -F\n$ipt -P INPUT DROP\n$ipt -P OUTPUT ACCEPT\n$ipt -P FORWARD ACCEPT\n$ipt -A INPUT -s 192.168.72.0/24 -p tcp --dport 22 -j ACCEPT\n$ipt -A INPUT -p tcp --dport 80 -j ACCEPT\n$ipt -A INPUT -p tcp --dport 21 -j ACCEPT</code></pre>\n<p>完成脚本的编写后，直接运行 /bin/bash /usr/local/sbin/iptables.sh即可。如果想开机启动时初始化防火墙规则，则需要在 /etc/rc.d/rc.local中添加一行 /bin/bash /usr/local/sbin/iptables.sh。执行过程如下：</p>\n<pre class=\"code-rows\"><code># sh /usr/local/sbin/iptables.sh\n# iptables -nvL\nChain INPUT (policy DROP 0 packets, 0 bytes)\n pkts bytes target prot opt in out source destination\n 20 1580 ACCEPT tcp -- * * 192.168.72.0/24 0.0.0.0/0 tcp dpt:22\n 0 0 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:80\n 0 0 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:21</code></pre>\n<p>运行脚本后，查看规则就是这样的，这里可以看到阿铭的第一条规则中已经有20个包（第一列）被放行过了。</p>\n<p>关于<code>icmp</code>的包有一个比较常见的应用，如下所示：</p>\n<pre class=\"code-rows\"><code># iptables -I INPUT -p icmp --icmp-type 8 -j DROP</code></pre>\n<p>这里<code>--icmp-type</code>选项要跟<code>-p icmp</code>一起使用，后面指定类型编号。这个8指的是能在本机ping通其他机器，而其他机器不能ping通本机，请牢记。<br />&nbsp;</p>\n</li>\n<li><p><strong><code>nat</code>表的应用</strong></p>\n<p>其实，Linux的iptables功能是十分强大的。阿铭的一位老师曾经这样形容Linux的网络功能：只有想不到，没有做不到！也就是说，只要是你能够想到的关于网络的应用，Linux都能帮你实现。你在日常生活中应该接触过路由器，它的功能就是分享上网。本来一根网线过来（其实只有一个公网IP），通过路由器后，路由器分配一个网段（私网IP），这样连此接路由器的多台PC都能连接因特网，而远端的设备认为你的IP就是那个连接路由器的公网IP。这个路由器的功能其实就是由Linux的iptables实现的，而iptables又是通过<code>nat</code>表作用而实现的。</p>\n<p>在这里，阿铭举一个例子来说明iptables是如何实现这个功能的。假设你的机器上有两块网卡eth0和eth1，其中eth0的IP为10.0.2.68，eth1的IP为192.168.1.1。eth0连接了因特网，但eth1没有连接。现在有另一台机器（192.168.1.2）和eth1是互通的，那么如何设置才能让连接eth1的这台机器连接因特网，和10.0.2.68互通呢？方法很简单，如下所示：</p>\n<pre class=\"code-rows\"><code># echo \"1\" &gt; /proc/sys/net/ipv4/ip_forward\n# iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o eth0 -j MASQUERADE</code></pre>\n<p>这里，第一个命令涉及内核参数相关的配置文件，它的目的是打开路由转发功能，否则无法实现我们的应用。第二个命令则是iptables对<code>nat</code>表做了一个IP转发的操作。<code>-o</code>选项后面跟设备名，表示出口的网卡；<code>MASQUERADE</code>表示伪装。关于<code>nat</code>表，阿铭不想多讲，你只要学会这个路由转发功能即可，其他的东西交给网络工程师去学习吧，毕竟你将来是要做Linux系统工程师的。<br />&nbsp;</p>\n</li>\n<li><p><strong>保存和备份iptables规则</strong></p>\n<p>前面阿铭提到过，咱们设定的防火墙规则只保存在内存中，并没有保存到某一个文件中。也就是说，当系统重启后以前设定的规则就没有了，所以设定好规则后要先保存一下。命令如下：</p>\n<pre class=\"code-rows\"><code># service iptables save\niptables: Saving firewall rules to /etc/sysconfig/iptables:[ ok ]</code></pre>\n<p>它会提示你防火墙规则保存在/etc/sysconfig/iptables文件内，这个文件就是iptables的配置文件。所以日后如果你遇到备份防火墙规则的任务，只要复制一份这个文件的副本即可。</p>\n<p>有时我们需要清除防火墙的所有规则，使用命令<code>iptables -F</code>固然可以，但最好的办法还是停止防火墙服务，如下所示：</p>\n<pre class=\"code-rows\"><code># service iptables stop\nRedirecting to /bin/systemctl stop iptables.service</code></pre>\n<p>这样防火墙就失效了，但是一旦重新设定规则（哪怕只有一条），防火墙服务会自动开启。下面阿铭介绍一个用来备份防火墙规则的命令，如下所示：</p>\n<pre class=\"code-rows\"><code># sh /usr/local/sbin/iptables.sh\n# iptables-save &gt; myipt.rule\n# cat myipt.rule\n# Generated by xtables-save v1.8.2 on Fri Jun 26 15:27:41 2020\n*security\n:INPUT ACCEPT [809:137209]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [682:88704]\nCOMMIT\n# Completed on Fri Jun 26 15:27:41 2020\n# Generated by xtables-save v1.8.2 on Fri Jun 26 15:27:41 2020\n*raw\n:PREROUTING ACCEPT [133:10536]\n:OUTPUT ACCEPT [111:20700]\nCOMMIT\n# Completed on Fri Jun 26 15:27:41 2020\n# Generated by xtables-save v1.8.2 on Fri Jun 26 15:27:41 2020\n*mangle\n:PREROUTING ACCEPT [133:10536]\n:INPUT ACCEPT [133:10536]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [111:20700]\n:POSTROUTING ACCEPT [111:20700]\nCOMMIT\n# Completed on Fri Jun 26 15:27:41 2020\n# Generated by xtables-save v1.8.2 on Fri Jun 26 15:27:41 2020\n*nat\n:PREROUTING ACCEPT [0:0]\n:INPUT ACCEPT [0:0]\n:POSTROUTING ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\nCOMMIT\n# Completed on Fri Jun 26 15:27:41 2020\n# Generated by xtables-save v1.8.2 on Fri Jun 26 15:27:41 2020\n*filter\n:INPUT DROP [108:8568]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [111:20700]\n-A INPUT -s 192.168.72.0/24 -p tcp -m tcp --dport 22 -j ACCEPT\n-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT\n-A INPUT -p tcp -m tcp --dport 21 -j ACCEPT\nCOMMIT\n# Completed on Fri Jun 26 15:27:41 2020</code></pre>\n<p>先执行一下刚才的iptables脚本，使用<code>iptables-save</code>命令重定向到一个文件里。若想要恢复这些规则，使用下面的命令即可：</p>\n<pre class=\"code-rows\"><code># iptables-restore &lt; myipt.rule</code></pre>\n</li>\n</ol>\n<h3 id=\"nav_point_265\">13.4.3 firewalld</h3>\n<p>介绍完了netfilter，阿铭觉得也有必要再说一下firewalld，毕竟这个才是CentOS 8上默认的防火墙。在上一节中，阿铭把firewalld服务给禁掉了，打开了iptables服务，现在再反过来关闭iptables服务，打开firewalld服务。操作如下所示：</p>\n<pre class=\"code-rows\"><code># iptables –P INPUT ACCEPT\n# yum remove -y iptables\n# systemctl enable firewalld\nCreated symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service → /usr/lib/systemd/system/firewalld.service.\nCreated symlink /etc/systemd/system/multi-user.target.wants/firewalld.service → /usr/lib/systemd/system/firewalld.service.\n# systemctl start firewalld</code></pre>\n<p>首先将INPUT链的默认策略设置为ACCEPT，因为前面的实验中有将其设置为DROP。在前面介绍的iptables相关的命令，其实也是可以继续使用的，只不过在CentOS 8中不用那么操作，而是有firewalld自己的命令。</p>\n<p>firewalld有两个基础概念，分别是zone和service，每一个zone里面有不同的iptables规则，默认一共有9个zone，而默认的zone为<code>public</code>。获取系统所有的zone，命令如下所示：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --get-zones\nblock dmz drop external home internal public trusted work</code></pre>\n<p>如下命令可以查看系统默认的zone：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --get-default-zone\npublic</code></pre>\n<p>下面阿铭简单介绍一下上面提到的9个zone。</p>\n<ul>\n<li><strong><code>drop</code>（丢弃）</strong>：任何接收的网络数据包都被丢弃，没有任何回复。仅能有发送出去的网络连接。</li>\n<li><strong><code>block</code>（限制）</strong>：任何接收的网络连接都被 IPv4 的<code>icmp-host-prohibited</code>信息和 IPv6 的<code>icmp6-adm-prohibited</code>信息所拒绝。</li>\n<li><strong><code>public</code>（公共）</strong>：在公共区域内使用，不能相信网络内的其他计算机不会对你的计算机造成危害，只能接收经过选取的连接。</li>\n<li><strong><code>external</code>（外部）</strong>：特别是为路由器启用了伪装功能的外部网。你不能信任来自网络的其他计算，不能相信它们不会对你的计算机造成危害，只能接收经过选择的连接。</li>\n<li><strong><code>dmz</code>（非军事区）</strong>：用于你的非军事区内的计算机，此区域内可公开访问，可以有限地进入你的内部网络，仅仅接收经过选择的连接。</li>\n<li><strong><code>work</code>（工作）</strong>：用于工作区。你可以基本相信网络内的其他计算机不会危害你的计算机。仅仅接收经过选择的连接。</li>\n<li><strong><code>home</code>（家庭）</strong>：用于家庭网络。你可以基本信任网络内的其他计算机不会危害你的计算机。仅仅接收经过选择的连接。</li>\n<li><strong><code>internal</code>（内部）</strong>：用于内部网络。你可以基本上信任网络内的其他计算机不会威胁你的计算机。仅仅接受经过选择的连接。</li>\n<li><strong><code>trusted</code>（信任）</strong>：可接受所有的网络连接。</li>\n</ul>\n<p>对于以上9个zone简单了解即可，阿铭相信你在日常工作中使用它们的机会不会太多。下面介绍几个关于zone的命令：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --set-default-zone=work // 设定默认的zone为work\nsuccess\n# firewall-cmd --get-zone-of-interface=ens33 // 查看指定网卡所在的zone\nWork\n# firewall-cmd --zone=public --add-interface=lo // 给指定网卡设置zone\nsuccess\n# firewall-cmd --zone=dmz --change-interface=lo // 针对网卡更改zone\nsuccess\n# firewall-cmd --zone=dmz --remove-interface=lo // 针对网卡删除zone\nSuccess\n# firewall-cmd --get-active-zones // 查看系统所有网卡所在的zone\nWork\n interfaces: ens33</code></pre>\n<p>阿铭觉得firewalld工具的开发者可能是想简化用户的使用过程，所以提供了这9种zone，这9种zone中，总有一个是适合我们的使用场景的。那到底zone是什么？每一种zone之间到底有什么区别呢？下面阿铭再给大家介绍一个概念——service。其实，之所以有9种zone，是因为每一个zone里面都使用了不同的service，而service就是针对一个服务（端口）做的iptables规则。执行如下命令列出当前系统所有的service：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --get-service\nRH-Satellite-6 amanda-client amanda-k5-client amqp amqps apcupsd audit bacula bacula-client bb bgp bitcoin bitcoin-rpc bitcoin-testnet bitcoin-testnet-rpc bittorrent-lsd ceph ceph-mon cfengine cockpit condor-collector ctdb dhcp dhcpv6 dhcpv6-client distcc dns dns-over-tls docker-registry docker-swarm dropbox-lansync elasticsearch etcd-client etcd-server finger freeipa-4 freeipa-ldap freeipa-ldaps freeipa-replication freeipa-trust ftp ganglia-client ganglia-master git grafana gre high-availability http https imap imaps ipp ipp-client ipsec irc ircs iscsi-target isns jenkins kadmin kdeconnect kerberos kibana klogin kpasswd kprop kshell ldap ldaps libvirt libvirt-tls lightning-network llmnr managesieve matrix mdns memcache minidlna mongodb mosh mountd mqtt mqtt-tls ms-wbt mssql murmur mysql nfs nfs3 nmea-0183 nrpe ntp nut openvpn ovirt-imageio ovirt-storageconsole ovirt-vmconsole plex pmcd pmproxy pmwebapi pmwebapis pop3 pop3s postgresql privoxy prometheus proxy-dhcp ptp pulseaudio puppetmaster quassel radius rdp redis redis-sentinel rpc-bind rsh rsyncd rtsp salt-master samba samba-client samba-dc sane sip sips slp smtp smtp-submission smtps snmp snmptrap spideroak-lansync spotify-sync squid ssdp ssh steam-streaming svdrp svn syncthing syncthing-gui synergy syslog syslog-tls telnet tentacle tftp tftp-client tile38 tinc tor-socks transmission-client upnp-client vdsm vnc-server wbem-http wbem-https wsman wsmans xdmcp xmpp-bosh xmpp-client xmpp-local xmpp-server zabbix-agent zabbix-server</code></pre>\n<p>这些service都是由一个个配置文件定义的，配置文件的模板在 /usr/lib/firewalld/services/目录下，真正生效的配置在 /etc/firewalld/services目录下面（默认为空）：</p>\n<pre class=\"code-rows\"><code># ls /usr/lib/firewalld/services/\namanda-client.xml dhcpv6-client.xml git.xml kpasswd.xml murmur.xml prometheus.xml sip.xml tentacle.xml\namanda-k5-client.xml dhcpv6.xml grafana.xml kprop.xml mysql.xml proxy-dhcp.xml slp.xml tftp-client.xml\namqps.xml dhcp.xml gre.xml kshell.xml nfs3.xml ptp.xml smtp-submission.xml tftp.xml\namqp.xml distcc.xml high-availability.xml ldaps.xml nfs.xml pulseaudio.xml smtps.xml tile38.xml\napcupsd.xml dns-over-tls.xml https.xml ldap.xml nmea-0183.xml puppetmaster.xml smtp.xml tinc.xml\naudit.xml dns.xml http.xml libvirt-tls.xml nrpe.xml quassel.xml snmptrap.xml tor-socks.xml\nbacula-client.xml docker-registry.xml imaps.xml libvirt.xml ntp.xml radius.xml snmp.xml transmission-client.xml\nbacula.xml docker-swarm.xml imap.xml lightning-network.xml nut.xml rdp.xml spideroak-lansync.xml upnp-client.xml\nbb.xml dropbox-lansync.xml ipp-client.xml llmnr.xml openvpn.xml redis-sentinel.xml spotify-sync.xml vdsm.xml\nbgp.xml elasticsearch.xml ipp.xml managesieve.xml ovirt-imageio.xml redis.xml squid.xml vnc-server.xml\nbitcoin-rpc.xml etcd-client.xml ipsec.xml matrix.xml ovirt-storageconsole.xml RH-Satellite-6.xml ssdp.xml wbem-https.xml\nbitcoin-testnet-rpc.xml etcd-server.xml ircs.xml mdns.xml ovirt-vmconsole.xml rpc-bind.xml ssh.xml wbem-http.xml\nbitcoin-testnet.xml finger.xml irc.xml memcache.xml plex.xml rsh.xml steam-streaming.xml wsmans.xml\nbitcoin.xml freeipa-4.xml iscsi-target.xml minidlna.xml pmcd.xml rsyncd.xml svdrp.xml wsman.xml\nbittorrent-lsd.xml freeipa-ldaps.xml isns.xml mongodb.xml pmproxy.xml rtsp.xml svn.xml xdmcp.xml\nceph-mon.xml freeipa-ldap.xml jenkins.xml mosh.xml pmwebapis.xml salt-master.xml syncthing-gui.xml xmpp-bosh.xml\nceph.xml freeipa-replication.xml kadmin.xml mountd.xml pmwebapi.xml samba-client.xml syncthing.xml xmpp-client.xml\ncfengine.xml freeipa-trust.xml kdeconnect.xml mqtt-tls.xml pop3s.xml samba-dc.xml synergy.xml xmpp-local.xml\ncockpit.xml ftp.xml kerberos.xml mqtt.xml pop3.xml samba.xml syslog-tls.xml xmpp-server.xml\ncondor-collector.xml ganglia-client.xml kibana.xml mssql.xml postgresql.xml sane.xml syslog.xml zabbix-agent.xml\nctdb.xml ganglia-master.xml klogin.xml ms-wbt.xml privoxy.xml sips.xml telnet.xml zabbix-server.xml</code></pre>\n<p>阿铭刚刚说过，每个zone里面都有不同的service，那么如何查看一个zone下面有哪些service呢？相关命令如下：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --list-services // 查看当前zone下有哪些service\ncockpit dhcpv6-client ssh\n# firewall-cmd --zone=public --list-services // 查看指定zone下有哪些service</code></pre>\n<p>一个zone下面有某个service，意味着这个service是被信任的。比如，当前zone下面有ssh，那么ssh服务（也就是22）端口是放行的。我们可以给一个zone添加一个service，命令如下：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --zone=public --add-service=http // 把http增加到public zone下面\nsuccess\n# firewall-cmd --zone=public --list-service\ncockpit dhcpv6-client http ssh</code></pre>\n<p>对于每个zone来说，都有自己的配置文件，你可以查看目录/usr/lib/firewalld/zones/下面对应的文件，这些就是zone的配置文件：</p>\n<pre class=\"code-rows\"><code># ls /usr/lib/firewalld/zones/\nblock.xml dmz.xml drop.xml external.xml home.xml internal.xml public.xml trusted.xml work.xml</code></pre>\n<p>刚刚阿铭教给你一个命令，可在一个zone里面增加一个service，但这种方法仅仅在内存中生效，并没有修改配置文件，如果想修改配置文件，需要加一个选项：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --zone=public --add-service=http --permanent\nsuccess</code></pre>\n<p>一旦更改了某个zone的配置文件，则会在/etc/firewalld/zones/目录下面生成对应zone的配置文件（.xml后缀的文件），其实这个目录下面的配置文件才是真正的配置文件。阿铭在上面介绍的目录，可以说是所有zone的模板配置文件。</p>\n<p>下面阿铭举一个实际的例子，帮助你明白zone和service两个概念。需求：假如服务器上配置了一个FTP服务，但端口并非默认的21，而是1121，并且需要在work zone下面放行FTP。具体的做法如下：</p>\n<pre class=\"code-rows\"><code># cp /usr/lib/firewalld/services/ftp.xml /etc/firewalld/services/ // 这个和上面阿铭提到的情况一样，// /usr/lib/firewalld/services/目录下面为所有service的模板配置文件\n# vi /etc/firewalld/services/ftp.xml // 把里面的21改为1121\n# cp /usr/lib/firewalld/zones/work.xml /etc/firewalld/zones/\n# vi /etc/firewalld/zones/work.xml // 在里面增加一行FTP相关的配置，内容如下\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;zone&gt;\n &lt;short&gt;Work&lt;/short&gt;\n &lt;description&gt;For use in work areas. You mostly trust the other computers on networks to not harm your computer. Only selected incoming connections are accepted.&lt;/description&gt;\n &lt;service name=\"ssh\"/&gt;\n &lt;service name=\"ftp\"/&gt;\n &lt;service name=\"dhcpv6-client\"/&gt;\n &lt;service name=\"cockpit\"/&gt;\n&lt;/zone&gt;\n# firewall-cmd --reload // 重新加载</code></pre>\n<p>再来验证一下work zone里面的service是否有FTP：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --zone=work --list-services\ncockpit dhcpv6-client ftp ssh</code></pre>\n<p>上面的方法还是有点啰唆，有没有像上一节中iptables命令那样简单的方式呢？当然有，下面阿铭再给大家找几个典型例子。</p>\n<p>1）放行指定端口的命令如下：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --set-default-zone=public // 将默认zone设置为public\n# firewall-cmd --zone=public --add-port 1000/tcp --permanent // 如果不指定--zone默认就是public，增加tcp的1000端口，增加--permanent是为了让其永久生效，否则重启后就失效了\nsuccess\n# firewall-cmd --reload // 使其规则生效\n# firewall-cmd --list-all // 列出当前具体规则，可以看到刚刚增加的1000端口\npublic (active)\n target: default\n icmp-block-inversion: no\n interfaces: ens33\n sources:\n services: cockpit dhcpv6-client http ssh\n ports: 1000/tcp\n protocols:\n masquerade: no\n forward-ports:\n source-ports:\n icmp-blocks:\n rich rules:</code></pre>\n<p>2）添加多个端口的命令如下：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --add-port 3000-3010/tcp --permanent // 3000-3010指定一个范围\nsuccess\n# firewall-cmd --reload\n# firewall-cmd --list-all |grep ports // 用grep过滤只含有ports字符的行\n ports: 1000/tcp 3000-3010/tcp\n forward-ports:\n source-ports:\n# firewall-cmd --add-port 80/tcp --add-port 8080/tcp --permanent // 如果要增加多个port，那就要写多个--add-port\n# firewall-cmd --reload</code></pre>\n<p>3）删除指定端口的命令如下：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --remove-port 8080/tcp --permanent\nsuccess\n# firewall-cmd --reload\nsuccess\n# firewall-cmd --list-all |grep ports\n ports: 1000/tcp 3000-3010/tcp 80/tcp\n forward-ports:\n source-ports:</code></pre>\n<p>4）针对某个IP开放指定端口的命令如下：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --permanent --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.72.166\" port protocol=\"tcp\" port=\"6379\" accept\"\nsuccess\n# firewall-cmd --reload\nsuccess\n# firewall-cmd --list-all\npublic (active)\n target: default\n icmp-block-inversion: no\n interfaces: ens33\n sources:\n services: cockpit dhcpv6-client http ssh\n ports: 1000/tcp 3000-3010/tcp 80/tcp\n protocols:\n masquerade: no\n forward-ports:\n source-ports:\n icmp-blocks:\n rich rules:\n rule family=\"ipv4\" source address=\"192.168.72.166\" port port=\"6379\" protocol=\"tcp\" accept\n# firewall-cmd --permanent --add-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.0.0/24\" accept\" // 放行指定网段\nsuccess\n# firewall-cmd --reload\nsuccess\n# firewall-cmd --list-all\npublic (active)\n target: default\n icmp-block-inversion: no\n interfaces: ens33\n sources:\n services: cockpit dhcpv6-client http ssh\n ports: 1000/tcp 3000-3010/tcp 80/tcp\n protocols:\n masquerade: no\n forward-ports:\n source-ports:\n icmp-blocks:\n rich rules:\n rule family=\"ipv4\" source address=\"192.168.72.166\" port port=\"6379\" protocol=\"tcp\" accept\n rule family=\"ipv4\" source address=\"192.168.0.0/24\" accept</code></pre>\n<p>5）删除某条规则的命令如下：</p>\n<pre class=\"code-rows\"><code># firewall-cmd --permanent --remove-rich-rule=\"rule family=\"ipv4\" source address=\"192.168.0.0/24\" accept\"\nsuccess\n# firewall-cmd --reload</code></pre>\n<p>关于firewalld，阿铭就介绍这些。这部分内容要是仔细研究还是蛮多的，但阿铭觉得毕竟在工作中使用得并不多，了解这些内容足够了。</p>\n<h2 id=\"nav_point_266\">13.5 Linux系统的任务计划</h2>\n<p>其实大部分系统管理工作都是通过定期自动执行某个脚本来完成的，那么如何定期执行某个脚本呢？这就要借助Linux的cron功能了。这部分内容很重要，请大家牢记！</p>\n<h3 id=\"nav_point_267\">13.5.1 命令<code>crontab</code></h3>\n<p>Linux任务计划功能的操作都是通过<code>crontab</code>命令来完成的，其常用的选项有以下几个。</p>\n<ul>\n<li><strong><code>-u</code></strong>：表示指定某个用户，不加<code>-u</code>选项则为当前用户。</li>\n<li><strong><code>-e</code></strong>：表示制定计划任务。</li>\n<li><strong><code>-l</code></strong>：表示列出计划任务。</li>\n<li><strong><code>-r</code></strong>：表示删除计划任务。</li>\n</ul>\n<p>下面请跟着阿铭来创建第一个任务计划，如下所示：</p>\n<pre class=\"code-rows\"><code># crontab -e\nno crontab for root - using an empty one</code></pre>\n<p>这里使用<code>crontab -e</code>来编写任务计划，这实际上是使用vim工具打开了<code>crontab</code>的配置文件，我们写下如下内容：</p>\n<pre class=\"code-rows\"><code>01 10 05 06 3 echo \"ok\" &gt; /root/cron.log</code></pre>\n<p>这里每个字段的数字分别表示什么呢？从左到右依次为：分、时、日、月、周和命令行。上例表示在6月5日（这一天必须是星期三）的10点01分执行命令：<code>echo \"ok\" &gt; /root/cron.log</code>。</p>\n<p>命令<code>crontab -e</code>实际上是打开了/var/spool/cron/username文件（如果用户是root，则打开的是/var/spool/cron/root）。打开这个文件使用了vim编辑器，所以保存时在命令行模式下输入<code>:wq</code>即可。但是请千万不要直接去编辑那个文件，否则会出错，所以一定要使用命令<code>crontab -e</code>来编辑。</p>\n<p>查看已经设定的任务计划使用<code>crontab -l</code>命令，如下所示：</p>\n<pre class=\"code-rows\"><code># crontab -l\n01 10 05 06 3 echo \"ok\" &gt; /root/cron.log</code></pre>\n<p>删除任务计划要使用<code>crontab -r</code>命令，这个删除选项最好还是少用，因为它会一下子把全部计划都删除掉。如果你想只删除一条计划，可以使用<code>-e</code>选项进入<code>crontab</code>进行编辑。<code>-r</code>选项用法如下所示：</p>\n<pre class=\"code-rows\"><code># crontab -r\n# crontab -l\nno crontab for root</code></pre>\n<h3 id=\"nav_point_268\">13.5.2 cron练习题</h3>\n<p>cron的内容不算太难，但需要你牢固掌握。下面阿铭给出一些练习题，帮助你熟悉cron的应用。</p>\n<p>(1) 每天凌晨1点20分清除/var/log/slow.log这个文件。</p>\n<p>(2) 每周日3点执行/bin/sh /usr/local/sbin/backup.sh。</p>\n<p>(3) 每月14日4点10分执行/bin/sh /usr/local/sbin/backup_month.sh。</p>\n<p>(4) 每隔8小时执行<code>ntpdate time.windows.com</code>。</p>\n<p>(5) 每天的1点、12点和18点执行/bin/sh /usr/local/sbin/test.sh。</p>\n<p>(6) 每天的9点到18点执行/bin/sh /usr/local/sbin/test2.sh。</p>\n<p>下面是以上习题的答案，仅作参考。</p>\n<p>(1) <code>20 1 * * * echo \"\" &gt;/var/log/slow.log</code></p>\n<p>(2) <code>0 3 * * 0 /bin/sh /usr/local/sbin/backup.sh</code></p>\n<p>(3) <code>10 4 14 * * /bin/sh /usr/local/sbin/backup_month.sh</code></p>\n<p>(4) <code>0 */8 * * * ntpdate time.windows.com</code></p>\n<p>(5) <code>0 1,12,18 * * * /bin/sh /usr/local/sbin/test.sh</code></p>\n<p>(6) <code>0 9-18 * * * /bin/sh /usr/local/sbin/test2.sh</code></p>\n<p>练习完上面的题目，你可能会有一些小疑问。这里要简单说明一下，每隔8小时就是用全部小时（0~23）去除以8，结果算出来应该是0、8和16这3个数。当遇到多个数（分钟、小时、月、周）时，则需要用逗号隔开，比如第5题中的<code>1,12,18</code>。时间段是可以用<code>n-m</code>的方式表示的，比如第6题中的<code>9-18</code>。</p>\n<p>设置好了所有的任务计划后，我们需要查看一下<code>crond</code>服务是否已经启动，如下所示：</p>\n<pre class=\"code-rows\"><code># systemctl status crond\n● crond.service - Command Scheduler\n Loaded: loaded (/usr/lib/systemd/system/crond.service; enabled; vendor preset: enabled)\n Active: active (running) since Fri 2020-06-26 15:41:17 CST; 1h 22min ago\n Main PID: 820 (crond)\n Tasks: 1 (limit: 11353)\n Memory: 1.9M\n CGroup: /system.slice/crond.service\n └─820 /usr/sbin/crond -n\n\n6月 26 15:41:17 aminglinux-123 systemd[1]: Started Command Scheduler.\n6月 26 15:41:17 aminglinux-123 crond[820]: (CRON) STARTUP (1.5.2)\n6月 26 15:41:17 aminglinux-123 crond[820]: (CRON) INFO (Syslog will be used instead of sendmail.)\n6月 26 15:41:17 aminglinux-123 crond[820]: (CRON) INFO (RANDOM_DELAY will be scaled with factor 8% if used.)\n6月 26 15:41:17 aminglinux-123 crond[820]: (CRON) INFO (running with inotify support)\n6月 26 16:01:01 aminglinux-123 CROND[2042]: (root) CMD (run-parts /etc/cron.hourly)\n6月 26 17:01:01 aminglinux-123 CROND[4032]: (root) CMD (run-parts /etc/cron.hourly)</code></pre>\n<p>看<code>Active</code>那行，如果是启动状态显示为<code>active(running)</code>，未启动则显示为<code>inactive (dead)</code>。</p>\n<h2 id=\"nav_point_269\">13.6 Linux系统服务管理</h2>\n<p>也许你配置过Windows开机启动的服务，其中有些服务在日常的管理工作中用不到，我们就要把它停止，一来可以节省资源，二来可以减少安全隐患。在Linux上同样也有相关的工具来管理系统的服务。</p>\n<h3 id=\"nav_point_270\">13.6.1 chkconfig服务管理工具</h3>\n<p>CentOS 6上的服务管理工具为chkconfig，Linux系统所有的预设服务都可以通过查看 /etc/init.d/目录得到，如下所示：</p>\n<pre class=\"code-rows\"><code># ls /etc/init.d/\nfunctions README</code></pre>\n<p>只有屈指可数的几个文件，这是因为从CentOS 7起已经不再延续CentOS 6版本的服务管理方案了。但是我们依然可以继续使用<code>chkconfig</code>这个命令。系统的预设服务都可以通过这样的命令实现：<code>service</code>服务名<code>start|stop|restart</code>。这里的服务名就是/etc/init.d/目录下的这些文件了。使用chkconfig启动某服务除了可以使用命令<code>service xxx start</code>外，还可以使用命令<code>/etc/init.d/xxx start</code>。</p>\n<p>我们可以使用命令<code>chkconfig --list</code>列出所有的服务及其每个级别的开启状态，如下所示：</p>\n<pre class=\"code-rows\"><code># chkconfig --list\n\n注：该输出结果只显示 SysV 服务，并不包含原生 systemd 服务。SysV 配置数据可能被原生 systemd 配置覆盖。\n 要列出 systemd 服务，请执行 'systemctl list-unit-files'。查看在具体 target 启用的服务请执行\n 'systemctl list-dependencies [target]'。</code></pre>\n<p>这里也会看到一个提示，它提示我们该命令输出的内容并没有包含CentOS 8的原生systemd服务，而这里仅仅列出来SysV服务。这也是 /etc/init.d/ 目录下面只有一两个启动脚本的根本原因。也就是说，早期CentOS版本（7之前）采用的服务管理都是SysV，而从7开始换成了systemd。</p>\n<p>使用<code>chkconfig</code>命令列出来的服务有7个运行级别（数字0~6），这为系统启动级别（CentOS 7之前版本的用法，而从CentOS 7开始已经不再严格区分级别的概念了）。其中0作为shutdown动作，1作为重启至单用户模式，6为重启。在一般的Linux系统实现中，都使用了2、3、4、5几个级别。在CentOS系统中，2表示无NFS支持的多用户模式，3表示完全多用户模式（也是最常用的级别），4保留给用户自定义，5表示图形登录方式。现在我们只是看到了各服务在每个级别下的开启状态，那么如何去更改某级别下的开启状态呢？相关命令如下：</p>\n<pre class=\"code-rows\"><code># chkconfig --level 3 xxx off</code></pre>\n<p>这里用<code>--level</code>指定级别，后面<code>xxx</code>是服务名，然后是<code>off</code>或者<code>on</code>。选项<code>--level</code>后面还可以指定多个级别，如下所示：</p>\n<pre class=\"code-rows\"><code># chkconfig --level 345 xxx off</code></pre>\n<p>另外还可以省略级别，默认是针对级别2、3、4和5操作的，如下所示：</p>\n<pre class=\"code-rows\"><code># chkconfig xxx on</code></pre>\n<p>chkconfig还有一个功能，就是可以把某个服务加入系统服务或者删除，即可以使用“<code>chkconfig --add</code>服务名”或者“<code>chkconfig --del</code>服务名”这样的形式，并且可以在<code>chkconfig --list</code>的结果中查找到。</p>\n<pre class=\"code-rows\"><code># chkconfig --del xxx\n# chkconfig --add xxx</code></pre>\n<p>这个功能常用于把自定义的启动脚本加入到系统服务当中。关于chkconfig工具，阿铭就先介绍这么多，毕竟systemd才是本书的主角。</p>\n<h3 id=\"nav_point_271\">13.6.2 systemd服务管理</h3>\n<p>上一节阿铭提到过，从CentOS 7开始不使用SysV而改为systemd了，这是因为systemd支持多个服务并发启动，而SysV只能一个一个地启动，这样最终导致的结果是systemd方式启动会快很多。但毕竟阿铭使用CentOS很多年，突然这样一变化还是有点不太习惯，接下来的知识点也会让你觉得systemd有点复杂。我们不妨对比着chkconfig工具来学习一下systemd。首先是列出系统所有的服务，如下所示：</p>\n<pre class=\"code-rows\"><code># systemctl list-units --all --type=service\nUNIT LOAD ACTIVE SUB DESCRIPTION\n atd.service loaded active running Job spooling tools\n auditd.service loaded active running Security Auditing Service\n chronyd.service loaded active running NTP client/server\n● cloud-init-local.service not-found inactive dead cloud-init-local.service\n cpupower.service loaded inactive dead Configure CPU power relat&gt;\n crond.service loaded active running Command Scheduler\n dbus.service loaded active running D-Bus System Message Bus\n● display-manager.service not-found inactive dead display-manager.service\n dnf-makecache.service loaded inactive dead dnf makecache\n dracut-cmdline.service loaded inactive dead dracut cmdline hook\n dracut-initqueue.service loaded inactive dead dracut initqueue hook\n dracut-mount.service loaded inactive dead dracut mount hook\n dracut-pre-mount.service loaded inactive dead dracut pre-mount hook\n dracut-pre-pivot.service loaded inactive dead dracut pre-pivot and clea&gt;\n dracut-pre-trigger.service loaded inactive dead dracut pre-trigger hook\n dracut-pre-udev.service loaded inactive dead dracut pre-udev hook\n dracut-shutdown.service loaded active exited Restore /run/initramfs on&gt;\n ebtables.service loaded inactive dead Ethernet Bridge Filtering&gt;\n emergency.service loaded inactive dead Emergency Shell\n firewalld.service loaded active running firewalld - dynamic firew&gt;\n getty@tty1.service loaded active running Getty on tty1\n import-state.service loaded active exited Import network configurat&gt;\n initrd-cleanup.service loaded inactive dead Cleaning Up and Shutting &gt;\n initrd-parse-etc.service loaded inactive dead Reload Configuration from&gt;\n initrd-switch-root.service loaded inactive dead Switch Root\n initrd-udevadm-cleanup-db.service loaded inactive dead Cleanup udevd DB\n ip6tables.service loaded inactive dead IPv6 firewall with ip6tab&gt;</code></pre>\n<p>太多了，阿铭仅仅列出来一部分。那这些服务对应的启动脚本文件在哪里呢？</p>\n<pre class=\"code-rows\"><code># ls /usr/lib/systemd/system/\narp-ethers.service multi-user.target.wants sysinit.target.wants\natd.service NetworkManager-dispatcher.service sys-kernel-config.mount\nauditd.service NetworkManager.service sys-kernel-debug.mount\nautovt@.service NetworkManager-wait-online.service syslog.socket\nbasic.target network-online.target syslog.target.wants\nbasic.target.wants network-pre.target systemd-ask-password-console.path\nbluetooth.target network.target systemd-ask-password-console.service</code></pre>\n<p>文件同样很多，阿铭仅仅列出来一部分。你会发现这个目录下面的文件有点奇怪，有的是目录，有的是文件，有的以 .service为后缀，有的以 .target为后缀，当然还有其他的格式，这些东西到底是什么？有没有不知所以的感觉？其实阿铭和你一样，有点晕晕的，还是先来看与服务相关的知识点吧，下面是阿铭整理的一些常用命令：</p>\n<pre class=\"code-rows\"><code># systemctl enable crond.service // 让某个服务开机启动（.service可以省略）\n# systemctl disable crond.service // 不让开机启动\n# systemctl status crond.service // 查看服务状态\n# systemctl start crond.service // 启动某个服务\n# systemctl stop crond.service // 停止某个服务\n# systemctl restart crond.service // 重启某个服务\n# systemctl is-enabled crond // 查看某个服务是否开机启动</code></pre>\n<p>其实关于服务的用法还有不少，但阿铭认为有上面这些就够用了。下面再介绍两个概念，等你看完这部分内容，对于上面不知所以的文件就会有些眉目了。我们先来说一个很重要的概念——unit。刚刚阿铭执行命令ls /usr/lib/systemd/system的时候，下面有很多文件，其实可以把它们归类为下面这几大类。</p>\n<ul>\n<li><strong>service</strong>：系统服务。</li>\n<li><strong>target</strong>：多个unit组成的组。</li>\n<li><strong>device</strong>：硬件设备。</li>\n<li><strong>mount</strong>：文件系统挂载点。</li>\n<li><strong>automount</strong>：自动挂载点。</li>\n<li><strong>path</strong>：文件或路径。</li>\n<li><strong>scope</strong>：不是由systemd启动的外部进程。</li>\n<li><strong>slice</strong>：进程组。</li>\n<li><strong>snapshot</strong>：systemd快照。</li>\n<li><strong>socket</strong>：进程间通信的套接字。</li>\n<li><strong>swap</strong>：swap文件。</li>\n<li><strong>timer</strong>：定时器。</li>\n</ul>\n<p>以上每种类型的文件都为一个unit，正是这些unit才组成了系统的各个资源（各个服务、各个设备等）。下面阿铭给大家介绍几个和unit相关的命令：</p>\n<pre class=\"code-rows\"><code># systemctl list-units // 列出正在运行（active）的unit\n# systemctl list-units --all // 列出所有的unit（包括失败的、inactive的）\n# systemctl list-units --all --state=inactive // 列出所有inactive的unit\n# systemctl list-units --all --type=service // 列出所有状态的service\n# systemctl list-units --type=service // 列出状态为active的service\n# systemctl is-active crond.service // 查看某个unit是否active</code></pre>\n<p>关于unit，阿铭不再多解释，毕竟我们平时在工作中几乎用不到它。下面再来看另外一个概念——target。target类似于CentOS 6里面的启动级别，但target支持多个target同时启动。target其实是多个unit的组合，系统启动说白了就是启动多个unit，为了管理方便，就使用target来管理这些unit。查看当前系统的所有 target：</p>\n<pre class=\"code-rows\"><code># systemctl list-unit-files --type=target // 注意和前面命令的区分\nUNIT FILE STATE\nbasic.target static\nbluetooth.target static\ncryptsetup-pre.target static\ncryptsetup.target static\nctrl-alt-del.target disabled\ndefault.target indirect\nemergency.target static\nexit.target disabled\nfinal.target static\ngetty-pre.target static\ngetty.target static\ngraphical.target static\nhalt.target disabled\nhibernate.target static\nhybrid-sleep.target static\ninitrd-fs.target static</code></pre>\n<p>查看一个 target 包含的所有 unit，如下所示：</p>\n<pre class=\"code-rows\"><code># systemctl list-dependencies multi-user.target\nmulti-user.target\n● ├─atd.service\n● ├─auditd.service\n● ├─chronyd.service\n● ├─crond.service\n● ├─dbus.service\n● ├─dnf-makecache.timer\n● ├─firewalld.service\n● ├─irqbalance.service\n● ├─kdump.service\n● ├─NetworkManager.service\n● ├─plymouth-quit-wait.service\n● ├─plymouth-quit.service\n● ├─rsyslog.service\n● ├─sshd.service\n● ├─sssd.service</code></pre>\n<p>因为内容太长，阿铭并没有全部列出来，你可以在自己的CentOS 8上全部列出来，显示效果还是很不错的，它以树形的方式列出来，一目了然。下面还有几个关于target的命令：</p>\n<pre class=\"code-rows\"><code># systemctl get-default // 查看系统默认的target\nmulti-user.target\n# systemctl set-default multi-user.target // 设置默认的target</code></pre>\n<p>上面提到的<code>multi-user.target</code>等同于CentOS 6的运行级别3，其实还有其他几个target对应0~6运行级别，如表13-1所示。</p>\n<p><strong>表13-1 运行级别和target的对比</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>SysV运行级别</p></th>\n<th><p>systemd target</p></th>\n<th><p>备注</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>0</p></td>\n<td><p><code>poweroff.target</code></p></td>\n<td><p>关闭系统</p></td>\n</tr>\n<tr>\n<td><p>1</p></td>\n<td><p><code>rescure.target</code></p></td>\n<td><p>单用户模式</p></td>\n</tr>\n<tr>\n<td><p>2</p></td>\n<td><p><code>multiuser.target</code></p></td>\n<td><p>用户自定义级别，通常识别为级别3</p></td>\n</tr>\n<tr>\n<td><p>3</p></td>\n<td><p><code>multiuser.target</code></p></td>\n<td><p>多用户，无图形</p></td>\n</tr>\n<tr>\n<td><p>4</p></td>\n<td><p><code>multiuser.target</code></p></td>\n<td><p>用户自定义级别，通常识别为级别3</p></td>\n</tr>\n<tr>\n<td><p>5</p></td>\n<td><p><code>graphical.target</code></p></td>\n<td><p>多用户，有图形，比级别3就多了一个图形</p></td>\n</tr>\n<tr>\n<td><p>6</p></td>\n<td><p><code>reboot.target</code></p></td>\n<td><p>重启</p></td>\n</tr>\n</tbody>\n</table>\n<p>介绍完了unit和target，阿铭再带着你一起梳理一下service、unit以及target之间的联系：</p>\n<p>(1) 一个service属于一种unit；</p>\n<p>(2) 多个unit一起组成了一个target；</p>\n<p>(3) 一个target里面包含了多个service，你可以查看文件 /usr/lib/systemd/system/sshd.service里面<code>[install]</code>部分的内容，它就定义了该service属于哪一个target。</p>\n<h2 id=\"nav_point_272\">13.7 Linux下的数据备份工具rsync</h2>\n<p>作为一个系统管理员，数据备份是非常重要的。阿铭有一次没有做好备份策略，结果磁盘坏了，数据全部丢失。所以在以后的系统维护工作中，你一定要时刻牢记给数据做备份。</p>\n<p>在Linux系统下数据备份的工具很多，但阿铭只用一种，那就是<code>rsync</code>，从字面意思上可以理解为remote sync（远程同步）。<code>rsync</code>不仅可以远程同步数据（类似于<code>scp</code>），而且可以本地同步数据（类似于<code>cp</code>），但不同于<code>cp</code>或<code>scp</code>的一点是，它不会覆盖以前的数据（如果数据已经存在），而是先判断已经存在的数据和新数据的差异，只有数据不同时才会把不相同的部分覆盖。如果你的Linux没有<code>rsync</code>命令，请使用命令<code>yum install -y rsync</code>安装。</p>\n<p>下面阿铭先举一个例子，然后再详细讲解<code>rsync</code>的用法：</p>\n<pre class=\"code-rows\"><code># rsync -av /etc/passwd /tmp/1.txt\nsending incremental file list\npasswd\n\nsent 1,205 bytes received 35 bytes 2,480.00 bytes/sec\ntotal size is 1,113 speedup is 0.90</code></pre>\n<p>上例将会把 /etc/passwd同步到 /tmp/ 目录下，并改名为1.txt。如果是远程复制，数据备份就是这样的形式——<code>IP:path</code>，比如192.168.72.128:/root/。具体用法如下：</p>\n<pre class=\"code-rows\"><code># rsync -av /etc/passwd 192.168.72.128:/tmp/1.txt\nThe authenticity of host '192.168.72.128 (192.168.72.128)' can't be established.\nECDSA key fingerprint is SHA256:gFHUJnoZAjOcnG95pt7Zg9iaPZGDiOrbZyssZtRoQhA.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added '192.168.72.128' (ECDSA) to the list of known hosts.\nroot@192.168.72.128's password:\nsending incremental file list\n\nsent 45 bytes received 12 bytes 8.77 bytes/sec\ntotal size is 1,113 speedup is 19.53</code></pre>\n<p>首次连接时会提示是否要继续连接，我们输入<code>yes</code>继续。当建立连接后，需要输入密码。如果手动执行这些操作比较简单，但若是写在脚本中该怎么办呢？这就涉及添加信任关系了，该部分内容稍后会详细介绍。</p>\n<h3 id=\"nav_point_273\">13.7.1 <code>rsync</code>的命令格式</h3>\n<p><code>rsync</code>的命令格式如下：</p>\n<pre class=\"code-rows\"><code>rsync [OPTION]... SRC DEST\nrsync [OPTION]... SRC [USER@]HOST:DEST\nrsync [OPTION]... [USER@]HOST:SRC DEST\nrsync [OPTION]... [USER@]HOST::SRC DEST\nrsync [OPTION]... SRC [USER@]HOST::DEST</code></pre>\n<p>在阿铭前面举的两个例子中，第一个例子为第一种格式，第二个例子为第二种格式。但不同的是，阿铭并没有加<code>user@host</code>，如果不加默认指的是root。第三种格式是从远程目录同步数据到本地。第四种和第五种格式使用了两个冒号，这种格式和其他格式的验证方式不同。</p>\n<h3 id=\"nav_point_274\">13.7.2 <code>rsync</code>常用选项</h3>\n<p><code>rsync</code>命令各选项的含义如下。</p>\n<ul>\n<li><strong><code>-a</code></strong>：这是归档模式，表示以递归方式传输文件，并保持所有属性，它等同于<code>-rlptgoD</code>。<code>-a</code>选项后面可以跟一个<code>--no-OPTION</code>，表示关闭<code>-rlptgoD</code>中的某一个，比如<code>-a--no-l</code>等同于<code>-rptgoD</code>。</li>\n<li><strong><code>-r</code></strong>：表示以递归模式处理子目录。它主要是针对目录来说的，如果单独传一个文件不需要加<code>-r</code>选项，但是传输目录时必须加。</li>\n<li><strong><code>-v</code></strong>：表示打印一些信息，比如文件列表、文件数量等。</li>\n<li><strong><code>-l</code></strong>：表示保留软连接。</li>\n<li><strong><code>-L</code></strong>：表示像对待常规文件一样处理软连接。如果是SRC中有软连接文件，则加上该选项后，将会把软连接指向的目标文件复制到DST。</li>\n<li><strong><code>-p</code></strong>：表示保持文件权限。</li>\n<li><strong><code>-o</code></strong>：表示保持文件属主信息。</li>\n<li><strong><code>-g</code></strong>：表示保持文件属组信息。</li>\n<li><strong><code>-D</code></strong>：表示保持设备文件信息。</li>\n<li><strong><code>-t</code></strong>：表示保持文件时间信息。</li>\n<li><strong><code>--delete</code></strong>：表示删除DST中SRC没有的文件。</li>\n<li><strong><code>--exclude=PATTERN</code></strong>：表示指定排除不需要传输的文件，等号后面跟文件名，可以是万用字符模式（如<code>*.txt</code>）。</li>\n<li><strong><code>--progress</code></strong>：表示在同步的过程中可以看到同步的过程状态，比如统计要同步的文件数量、同步的文件传输速度等。</li>\n<li><strong><code>-u</code></strong>：表示把DST中比SRC还新的文件排除掉，不会覆盖。</li>\n<li><strong><code>-z</code></strong>：加上该选项，将会在传输过程中压缩</li>\n</ul>\n<p>选项虽然多，但阿铭常用的选项也就<code>-a</code>、<code>-v</code>、<code>-z</code>、<code>--delete</code>和<code>--exclude</code>这几个，请牢记它们！下面阿铭将会针对这些选项做一系列小试验。</p>\n<ol>\n<li><p><strong>建立目录和文件</strong></p>\n<p>过程如下所示：</p>\n<pre class=\"code-rows\"><code># mkdir rsync\n# cd rsync\n# mkdir test1\n# cd test1\n# touch 1 2 3 /root/123.txt\n# ln -s /root/123.txt ./123.txt\n# ls -l\n总用量 0\n-rw-r--r-- 1 root root 0 6月 26 17:30 1\nlrwxrwxrwx 1 root root 13 6月 26 17:30 123.txt -&gt; /root/123.txt\n-rw-r--r-- 1 root root 0 6月 26 17:30 2\n-rw-r--r-- 1 root root 0 6月 26 17:30 3\n# cd ..</code></pre>\n<p>阿铭建立这些文件的目的就是为后续试验做一些准备工作。<br />&nbsp;</p>\n</li>\n<li><p><strong>使用<code>-a</code>选项</strong></p>\n<p>首先来看看<code>-a</code>选项的用法，如下所示：</p>\n<pre class=\"code-rows\"><code># rsync -a test1 test2\n# ls test2\ntest1\n# ls test2/test1/\n1 123.txt 2 3</code></pre>\n<p>这里有一个问题，就是本来想把test1目录直接复制成test2目录，可结果<code>rsync</code>却新建了test2目录，然后把test1放到test2当中。为了避免这样的情况发生，可以这样做：</p>\n<pre class=\"code-rows\"><code># rm -rf test2\n# rsync -a test1/ test2/\n# ls -l test2/\n总用量 0\n-rw-r--r-- 1 root root 0 6月 26 17:30 1\nlrwxrwxrwx 1 root root 13 6月 26 17:30 123.txt -&gt; /root/123.txt\n-rw-r--r-- 1 root root 0 6月 26 17:30 2\n-rw-r--r-- 1 root root 0 6月 26 17:30 3</code></pre>\n<p>这里加一个斜杠就好了，所以阿铭建议你在使用<code>rsync</code>备份目录时，要养成加斜杠的习惯。前面已经讲了<code>-a</code>选项等同于<code>-rlptgoD</code>，且<code>-a</code>还可以和<code>--no-OPTIN</code>一并使用。下面再来看看<code>-l</code>选项的作用，如下所示：</p>\n<pre class=\"code-rows\"><code># rm -rf test2\n# rsync -av --no-l test1/ test2/\nsending incremental file list\ncreated directory test2\nskipping non-regular file \"123.txt\"\n./\n1\n2\n3\n\nsent 234 bytes received 144 bytes 756.00 bytes/sec\ntotal size is 13 speedup is 0.03</code></pre>\n<p>上例中使用了<code>-v</code>选项，跳过了非普通文件123.txt。其实123.txt是一个软连接文件，如果不使用<code>-l</code>选项，系统则不理会软连接文件。虽然加<code>-l</code>选项能复制软连接文件，但软连接的目标文件却没有复制。有时我们需要复制软连接文件所指向的目标文件，这又该怎么办呢？<br />&nbsp;</p>\n</li>\n<li><p><strong>使用<code>-L</code>选项</strong></p>\n<p>具体用法如下：</p>\n<pre class=\"code-rows\"><code># rm -rf test2\n# rsync -avL test1/ test2/\nsending incremental file list\ncreated directory test2\n./\n1\n123.txt\n2\n3\n\nsent 265 bytes received 123 bytes 776.00 bytes/sec\ntotal size is 0 speedup is 0.00\n# ls -l test2/\n总用量 0\n-rw-r--r-- 1 root root 0 6月 26 17:30 1\n-rw-r--r-- 1 root root 0 6月 26 17:30 123.txt\n-rw-r--r-- 1 root root 0 6月 26 17:30 2\n-rw-r--r-- 1 root root 0 6月 26 17:30 3</code></pre>\n<p>上例加上<code>-L</code>选项就可以把SRC中软连接的目标文件复制到DST。<br />&nbsp;</p>\n</li>\n<li><p><strong>使用<code>-u</code>选项</strong></p>\n<p>首先查看一下test1/1和test2/1的创建时间（肯定是一样的），然后使用<code>touch</code>修改一下test2/1的创建时间（此时test2/1要比test1/1的创建时间晚一些）。如果不加<code>-u</code>选项，会把test2/1的创建时间变成和test1/1一样，如下所示：</p>\n<pre class=\"code-rows\"><code># ll test1/1 test2/1\n-rw-r--r-- 1 root root 0 6月 26 17:30 test1/1\n-rw-r--r-- 1 root root 0 6月 26 17:30 test2/1</code></pre>\n<p>从上例可以看出二者的创建时间是一样的。下面修改test2/1的创建时间，然后不加<code>-u</code>同步，如下所示：</p>\n<pre class=\"code-rows\"><code># echo \"1111\" &gt; test2/1\n# ll test2/1\n- rw-r--r-- 1 root root 5 6月 26 17:33 test2/1\n# rsync -a test1/1 test2/\n# ll test2/1\n-rw-r--r-- 1 root root 0 6月 26 17:30 test2/1</code></pre>\n<p>这里test2/1的创建时间还是和test1/1一样。下面加上<code>-u</code>选项，如下所示：</p>\n<pre class=\"code-rows\"><code># echo \"1111\" &gt; test2/1\n# ll test2/1\n-rw-r--r-- 1 root root 5 6月 26 17:34 test2/1\n# rsync -avu test1/ test2/\nsending incremental file list\n./\n123.txt -&gt; /root/123.txt\n\nsent 134 bytes received 22 bytes 312.00 bytes/sec\ntotal size is 13 speedup is 0.08\n# ll test1/1 test2/1\n-rw-r--r-- 1 root root 0 6月 26 17:30 test1/1\n-rw-r--r-- 1 root root 5 6月 26 17:34 test2/1</code></pre>\n<p>加上<code>-u</code>选项后，不会再把test1/1同步为test2/1了。<br />&nbsp;</p>\n</li>\n<li><p><strong>使用<code>--delete</code>选项</strong></p>\n<p>首先删除test1/123.txt，如下所示：</p>\n<pre class=\"code-rows\"><code># rm -f test1/123.txt\n# ls test1/\n1 2 3</code></pre>\n<p>然后把test1/目录同步到test2/目录下，如下所示：</p>\n<pre class=\"code-rows\"><code># rsync -av test1/ test2/\nsending incremental file list\n./\n1\n\nsent 130 bytes received 38 bytes 336.00 bytes/sec\ntotal size is 0 speedup is 0.00\n# ls test2/\n1 123.txt 2 3</code></pre>\n<p>上例中，test2/目录并没有删除123.txt。下面加上<code>--delete</code>选项，示例如下：</p>\n<pre class=\"code-rows\"><code># rsync -av --delete test1/ test2/\nsending incremental file list\ndeleting 123.txt\n\nsent 84 bytes received 23 bytes 214.00 bytes/sec\ntotal size is 0 speedup is 0.00\n# ls test2/\n1 2 3</code></pre>\n<p>这里test2/ 目录下的123.txt也被删除了。</p>\n<p>另外还有一种情况，就是如果在DST中增加文件了，而SRC当中没有这些文件，同步时加上<code>--delete</code>选项后同样会删除新增的文件。如下所示：</p>\n<pre class=\"code-rows\"><code># touch test2/4\n# ls test1/\n1 2 3\n# ls test2/\n1 2 3 4\n# rsync -a --delete test1/ test2/\n# ls test1/\n1 2 3\n# ls test2/\n1 2 3</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>使用<code>--exclude</code>选项</strong></p>\n<p>具体用法如下：</p>\n<pre class=\"code-rows\"><code># touch test1/4\n# rsync -a --exclude=\"4\" test1/ test2/\n# ls test1/\n1 2 3 4\n# ls test2/\n1 2 3</code></pre>\n<p>该选项还可以与匹配字符<code>*</code>一起使用，如下所示：</p>\n<pre class=\"code-rows\"><code># touch test1/1.txt test1/2.txt\n# ls test1/\n1 1.txt 2 2.txt 3 4\n# rsync -a --progress --exclude=\"*.txt\" test1/ test2/\nsending incremental file list\n./\n4\n 0 100% 0.00kB/s 0:00:00 (xfr#1, to-chk=0/5)\n# ls test2/\n1 2 3 4</code></pre>\n<p>上例中，阿铭也使用了<code>--progress</code>选项，它主要是用来观察<code>rsync</code>同步过程状态的。</p>\n<p>总而言之，平时你使用<code>rsync</code>同步数据时，使用<code>-a</code>选项基本上就可以达到想要的效果了。当有个别需求时，也会用到<code>--no-OPTION</code>、<code>-u</code>、<code>-L</code>、<code>--delete</code>、<code>--exclude</code>以及<code>--progress</code>等选项。其他选项阿铭都没有介绍，如果在以后的工作中遇到特殊需求，可以查一下<code>rsync</code>的man文档。</p>\n</li>\n</ol>\n<h3 id=\"nav_point_275\">13.7.3 <code>rsync</code>应用实例</h3>\n<p>上面列举了许多小案例，都是为了让大家熟悉<code>rsync</code>各个选项的基本用法。本节正式介绍<code>rsync</code>的实际应用，请大家认真学习。在正式试验前，你需要准备两台Linux机器，因为下面的小案例都是从一台机器复制文件到另一台机器。前面阿铭也带着大家克隆过一台虚拟机，所以把那台克隆的虚拟机打开即可，阿铭的两台机器IP地址分别为192.168.72.128和192.168.72.129。</p>\n<ol>\n<li><p><strong>通过<code>ssh</code>的方式</strong></p>\n<p>在之前介绍的<code>rsync</code>的5种命令格式中，第二种和第三种（一个冒号）就属于通过<code>ssh</code>的方式备份数据。这种方式其实就是让用户登录到远程机器，然后执行<code>rsync</code>的任务：</p>\n<pre class=\"code-rows\"><code># rsync -avL test1/ 192.168.72.129:/tmp/test2/\nThe authenticity of host '192.168.72.129 (192.168.72.129)' can't be established.\nECDSA key fingerprint is SHA256:gFHUJnoZAjOcnG95pt7Zg9iaPZGDiOrbZyssZtRoQhA.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added '192.168.72.129' (ECDSA) to the list of known hosts.\nroot@192.168.72.129's password:\nsending incremental file list\ncreated directory /tmp/test2\n./\n1\n1.txt\n2\n2.txt\n3\n4\n\nsent 377 bytes received 166 bytes 98.73 bytes/sec\ntotal size is 0 speedup is 0.00</code></pre>\n<p>这种方式就是前面介绍的第二种方式了，是通过<code>ssh</code>复制的数据，需要输入192.168.72.129那台机器root用户的密码。</p>\n<p>当然，也可以使用第三种方式复制，如下所示：</p>\n<pre class=\"code-rows\"><code># rsync -avL 192.168.72.129:/tmp/test2/ ./test3/\nroot@192.168.72.129's password:\nreceiving incremental file list\ncreated directory ./test3\n./\n1\n1.txt\n2\n2.txt\n3\n4\n\nsent 141 bytes received 389 bytes 117.78 bytes/sec\ntotal size is 0 speedup is 0.00</code></pre>\n<p>以上两种方式如果写入脚本，做备份麻烦，要输入密码，但我们可以通过密钥（不设立密码）验证。下面阿铭具体介绍一下通过密钥登录远程主机的方法。</p>\n<p>你可以根据3.3.3节，把128机器上的公钥内容放到129机器下的<code>authorized_keys</code>里面，这样128机器登录129机器时不再输入密码，如下所示：</p>\n<pre class=\"code-rows\"><code># ssh 192.168.72.129\nLast login: Fri Jun 26 15:46:33 2020 from 192.168.72.1</code></pre>\n<p>现在不用输入密码也可以登录主机129了。下面先从129主机退出来，再从主机128上执行一下<code>rsync</code>命令试试吧：</p>\n<pre class=\"code-rows\"><code># rsync -avL test1/ 192.168.72.129:/tmp/test4/\nsending incremental file list\ncreated directory /tmp/test4\n./\n1\n1.txt\n2\n2.txt\n3\n4\n\nsent 377 bytes received 166 bytes 362.00 bytes/sec\ntotal size is 0 speedup is 0.00</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>通过后台服务的方式</strong></p>\n<p>这种方式可以理解为：在远程主机上建立一个<code>rsync</code>的服务器，在服务器上配置好<code>rsync</code>的各种应用，然后将本机作为<code>rsync</code>的一个客户端连接远程的<code>rsync</code>服务器。下面阿铭就介绍一下如何配置一台<code>rsync</code>服务器。</p>\n<p>在128主机上建立并配置<code>rsync</code>的配置文件/etc/rsyncd.conf，如下所示（请把你的rsyncd.conf编辑成如下内容）：</p>\n<pre class=\"code-rows\"><code># vim /etc/rsyncd.conf\nport=873\nlog file=/var/log/rsync.log\npid file=/var/run/rsyncd.pid\naddress=192.168.72.128\n\n[test]\npath=/root/rsync\nuse chroot=true\nmax connections=4\nread only=no\nlist=true\nuid=root\ngid=root\nauth users=test\nsecrets file=/etc/rsyncd.passwd\nhosts allow=192.168.72.0/24</code></pre>\n<p>其中配置文件分为两部分：全局配置部分和模块配置部分。全局部分就是几个参数，比如阿铭的rsyncd.conf中的<code>port</code>、<code>log file</code>、<code>pid file</code>和<code>address</code>都属于全局配置；而<code>[test]</code>以下部分就是模块配置部分了。一个配置文件中可以有多个模块，模块名可自定义，格式就像阿铭的rsyncd.conf中的这样。其实模块中的一些参数（如<code>use chroot</code>、<code>max connections</code>、<code>udi</code>、<code>gid</code>、<code>auth users</code>、<code>secrets file</code>以及<code>hosts allow</code>都可以配置成全局参数。当然阿铭并未给出所有的参数，你可以通过命令<code>man rsyncd.conf</code>获得更多信息。</p>\n<p>下面就简单解释一下这些参数的作用。</p>\n<ul>\n<li><strong><code>port</code></strong>：指定在哪个端口启动<code>rsyncd</code>服务，默认是873端口。</li>\n<li><strong><code>log file</code></strong>：指定日志文件。</li>\n<li><strong><code>pid file</code></strong>：指定pid文件，这个文件的作用涉及服务的启动、停止等进程管理操作。</li>\n<li><strong><code>address</code></strong>：指定启动<code>rsyncd</code>服务的IP。假如你的机器有多个IP，就可以指定由其中一个启动<code>rsyncd</code>服务，如果不指定该参数，默认是在全部IP上启动。</li>\n<li><strong><code>[]</code></strong>：指定模块名，里面内容自定义。</li>\n<li><strong><code>path</code></strong>：指定数据存放的路径。</li>\n<li><strong><code>use chroot true|false</code></strong>：表示在传输文件前，首先<code>chroot</code>到<code>path</code>参数所指定的目录下。这样做的原因是实现额外的安全防护，但缺点是需要roots权限，并且不能备份指向外部的符号连接所指向的目录文件。默认情况下<code>chroot</code>值为<code>true</code>，如果你的数据当中有软连接文件，阿铭建议你设置成<code>false</code>。</li>\n<li><strong><code>max connections</code></strong>：指定最大的连接数，默认是<code>0</code>，即没有限制。</li>\n<li><strong><code>read only ture|false</code></strong>：如果为<code>true</code>，则不能上传到该模块指定的路径下。</li>\n<li><strong><code>list</code></strong>：表示当用户查询该服务器上的可用模块时，该模块是否被列出，设定为<code>true</code>则列出，设定为<code>false</code>则隐藏。</li>\n<li><strong><code>uid/gid</code></strong>：指定传输文件时以哪个用户/组的身份传输。</li>\n<li><strong><code>auth users</code></strong>：指定传输时要使用的用户名。</li>\n<li><strong><code>secrets file</code></strong>：指定密码文件，该参数连同上面的参数如果不指定，则不使用密码验证。注意，该密码文件的权限一定要是600。</li>\n<li><strong><code>hosts allow</code></strong>：表示被允许连接该模块的主机，可以是IP或者网段，如果是多个，中间用空格隔开。</li>\n</ul>\n<p>编辑<code>secrets file</code>并保存后要赋予600权限，如果权限不对，则不能完成同步，如下所示：</p>\n<pre class=\"code-rows\"><code># vi /etc/rsyncd.passwd // 写入如下内容\ntest:test123\n# chmod 600 /etc/rsyncd.passwd</code></pre>\n<p>启动<code>rsyncd</code>服务，如下所示：</p>\n<pre class=\"code-rows\"><code># rsync --daemon --config=/etc/rsyncd.conf</code></pre>\n<p>启动后可以查看一下日志，并查看端口是否启动，如下所示：</p>\n<pre class=\"code-rows\"><code># cat /var/log/rsync.log\n2020/06/26 17:43:11 [4680] rsyncd version 3.1.3 starting, listening on port 873\n# netstat -lnp |grep rsync\ntcp 0 0 192.168.72.128:873 0.0.0.0:* LISTEN 4680/rsync</code></pre>\n<p>如果想开机启动<code>rsyncd</code>服务，请把<code>/usr/bin/rsync --daemon --confg=/etc/rsyncd.conf</code>写入 /etc/rc.d/rc.local文件。</p>\n<p>为了不影响实验过程，还需要把两台机器的firewalld服务关闭，并设置为不开机启动，操作过程如下所示：</p>\n<pre class=\"code-rows\"><code># systemctl stop firewalld ; systemctl disable firewalld // 两台机器都执行\nRemoved /etc/systemd/system/multi-user.target.wants/firewalld.service.\nRemoved /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.\n# rsync -avL test@192.168.72.128::test/test1/ /tmp/test5/\nPassword:\nreceiving incremental file list\ncreated directory /tmp/test5\n./\n1\n1.txt\n2\n2.txt\n3\n4\n\nsent 141 bytes received 377 bytes 8.56 bytes/sec\ntotal size is 0 speedup is 0.00</code></pre>\n<p>阿铭刚刚提到了选项<code>use chroot</code>，默认为<code>true</code>。首先在主机128的 /root/rsync/test1/ 目录下创建一个软连接文件，如下所示：</p>\n<pre class=\"code-rows\"><code># ln -s /etc/passwd /root/rsync/test1/test.txt\n# ls -l /root/rsync/test1/test.txt\nlrwxrwxrwx 1 root root 11 6月 26 17:47 /root/rsync/test1/test.txt -&gt; /etc/passwd</code></pre>\n<p>然后再到主机129上执行同步，如下所示：</p>\n<pre class=\"code-rows\"><code># rsync -avL test@192.168.72.128::test/test1/ /tmp/test6/\nPassword:\nreceiving incremental file list\nsymlink has no referent: \"/test1/test.txt\" (in test)\ncreated directory /tmp/test6\n./\n1\n1.txt\n2\n2.txt\n3\n4\n\nsent 141 bytes received 436 bytes 42.74 bytes/sec\ntotal size is 0 speedup is 0.00\nrsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1659) [generator=3.1.3]</code></pre>\n<p>从上例可以看出，如果设置<code>use chroot</code>为<code>true</code>，则同步软连接文件会有问题。下面阿铭把主机128的<code>rsync</code>配置文件修改一下，把<code>true</code>改为<code>false</code>，如下所示：</p>\n<pre class=\"code-rows\"><code># sed -i 's/use chroot=true/use chroot=false/' /etc/rsyncd.conf\n# grep 'use chroot' /etc/rsyncd.conf\nuse chroot=false</code></pre>\n<p>然后再到主机129上再次执行同步，如下所示：</p>\n<pre class=\"code-rows\"><code># rsync -avL test@192.168.72.128::test/test1/ /tmp/test7/\nPassword:\nreceiving incremental file list\ncreated directory /tmp/test7\n./\n1\n1.txt\n2\n2.txt\n3\n4\ntest.txt\n\nsent 160 bytes received 1,556 bytes 137.28 bytes/sec\ntotal size is 1,113 speedup is 0.65</code></pre>\n<p>这样问题就解决了。另外，修改完rsyncd.conf配置文件后不需要重启<code>rsyncd</code>服务，这是<code>rsync</code>的一个特定机制，配置文件是即时生效的。</p>\n<p>上面的例子中，阿铭都有输入密码，这意味着我们还是不能写入脚本中自动执行。其实这种方式可以不用手动输入密码，它有两种实现方式。</p>\n<p>(1) <strong>指定密码文件</strong></p>\n<p>在客户端（即主机129）上编辑一个密码文件：</p>\n<pre class=\"code-rows\"><code># vim /etc/pass</code></pre>\n<p>加入<code>test</code>用户的密码：</p>\n<pre class=\"code-rows\"><code># vim /etc/pass // 写入如下内容\ntest123</code></pre>\n<p>修改密码文件的权限：</p>\n<pre class=\"code-rows\"><code># chmod 600 /etc/pass</code></pre>\n<p>在同步时指定密码文件，就可以省去输入密码的步骤，如下所示：</p>\n<pre class=\"code-rows\"><code># rsync -avL test@192.168.72.128::test/test1/ /tmp/test8/ --password-file=/etc/pass\nreceiving incremental file list\ncreated directory /tmp/test8\n./\n1\n1.txt\n2\n2.txt\n3\n4\ntest.txt\n\nsent 160 bytes received 1,556 bytes 149.22 bytes/sec\ntotal size is 1,113 speedup is 0.65</code></pre>\n<p>(2) <strong>在<code>rsync</code>服务端不指定用户</strong></p>\n<p>在服务端（即主机128）上修改配置文件rsyncd.conf，删除关于认证用户的配置项（<code>auth user</code>和<code>secrets file</code>这两行），如下所示：</p>\n<pre class=\"code-rows\"><code># sed -i 's/auth users/#auth users/;s/secrets file/#secrets file/' /etc/rsyncd.conf</code></pre>\n<p>上例是在<code>auth users</code>和<code>secrets file</code>这两行的最前面加一个<code>#</code>，这表示将这两行作为注释，使其失去意义。在前面阿铭未曾讲过<code>sed</code>的这种用法，它是用分号把两个替换的子命令块替换了。</p>\n<p>然后我们再到客户端主机129上进行测试，如下所示：</p>\n<pre class=\"code-rows\"><code># rsync -avL test@192.168.72.128::test/test1/ /tmp/test9/\nreceiving incremental file list\ncreated directory /tmp/test9\n./\n1\n1.txt\n2\n2.txt\n3\n4\ntest.txt\n\nsent 160 bytes received 1,556 bytes 163.43 bytes/sec\ntotal size is 1,113 speedup is 0.65</code></pre>\n<p>注意，这里不用再加<code>test</code>这个用户了，默认是以<code>root</code>的身份复制的。现在登录时已经不需要输入密码了。</p>\n</li>\n</ol>\n","neighbors":{"left":{"article_title":"第 13 章 Linux系统管理技巧(1)","id":741035},"right":{"article_title":"第 13 章 Linux系统管理技巧(3)","id":741037}},"comments":[{"had_liked":false,"id":386922,"user_name":"learn more","can_delete":false,"product_type":"c1","uid":1128702,"ip_address":"湖南","ucode":"0EF628B2E0F95E","user_header":"https://static001.geekbang.org/account/avatar/00/11/38/fe/04f56d1e.jpg","comment_is_top":false,"comment_ctime":1705903991,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100636611,"comment_content":"是 uid 不是 udi","like_count":0}]}