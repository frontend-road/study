{"id":791160,"title":"28｜异常（下）：处理 finally 子句和 traceback 对象","content":"<p>你好，我是海纳。</p><p>上一节课，我们使用 Python 源码实现了 Exception 类，从而构建起了异常对象的继承体系，同时也实现了异常对象的匹配功能。在这个基础上，我们进一步实现了用于处理异常控制流的几条字节码。</p><p>第一条重要的字节码是 SETUP_FINALLY，它的作用是创建一个 Block，指定了如果在执行 try 语句的过程中发生异常应该跳转到哪里执行。第二条是 CALL_FINALLY，它的作用是如果 try 语句正常结束了，就跳转进 finally 子句执行。这节课，我们就来实现整个异常控制流的最后一条重要的指令，就是 <strong>END_FINALLY</strong>，我们要在 END_FINALLY 中增加恢复异常的逻辑。从而让解释器可以在退出函数栈帧的时候还能正确地维护异常对象。</p><h2>实现 END_FINALLY</h2><p>就像之前分析的，END_FINALLY 的主要作用是结束 finally 子句的执行。根据上节课说的进入 finally 子句的三种情况，我们这里分别做了处理，你可以看一下具体实现。</p><pre><code class=\"language-c++\">void Interpreter::eval_frame() {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp;     case ByteCode::END_FINALLY: {\n                v = POP();\n                long long t = (long long)v();\n                if (t == 0) {\n                    // do nothing.\n                }\n                else if (t &amp; 0x1) {\n                    _frame-&gt;set_pc(t &gt;&gt; 1);\n                }\n                else {\n                    _exception_class = v;\n                    _pending_exception = POP();\n                    _trace_back = POP();\n                    _int_status = IS_EXCEPTION;\n                }\n                break;\n            }\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n</code></pre><!-- [[[read_end]]] --><p>由此可见，END_FINALLY 的实现正好对应了三种情况，第一种情况对应 BEGIN_FINALLY，这个时候栈顶上只有一个数字 0，所以遇到这种情况，就什么都不用做（第 11 到 13 行）。</p><p>第二种情况栈上的值是一个地址，这对应了 CALL_FINALLY，这种情况下，只要把解释器的 pc 值修改为栈上的值就可以了（第14 至 16 行）。</p><p>最后一种是发生异常了，通过 SETUP_FINALLY Block 进入的，这种情况下，当 finally 子句执行完以后，就要从栈上恢复异常状态，进行进一步的处理（第 17 至 22 行）。所谓进一步处理， 指的是有可能更外层还有 except 子句，也有可能引发函数退栈，如果是在主文件中，还有可能直接导致进程退出。</p><p>最后，我们再把一些用于处理异常时的栈状态的字节码补齐，例如：</p><pre><code class=\"language-c++\">            case ByteCode::POP_EXCEPT: {\n                Block b = _frame-&gt;pop_block();\n                assert(b._type == ByteCode::EXCEPT_HANDLER);\n                assert(STACK_LEVEL() &gt;= b._level + 3 &amp;&amp;\n                    STACK_LEVEL() &lt;= b._level + 4);\n                _exception_class = POP();\n                _pending_exception = POP();\n                _trace_back = POP();\n                _int_status = IS_EXCEPTION;\n                break;\n            }\n</code></pre><p>POP_EXCEPT 是明确地知道当前解释器已经发生了异常情况时，在 except 子句或者 finally 子句中用来恢复异常所使用的。所以它的功能只是 END_FINALLY 的一部分。</p><p>到这里，我们就完成了基本的异常处理机制。你可以试着运行一下这节课开始的那个例子，再测试一下异常和 finally 子句的组合是否能够正常执行。</p><p>接下来，我们关注异常处理的最后一个对象，那就是用于回栈的 Traceback 对象。</p><h2>Traceback 对象</h2><p>Traceback 是指发生异常时，用于记录异常栈信息的一种机制。我们用一个例子演示一下。</p><pre><code class=\"language-python\">def foo(a):\n&nbsp; &nbsp; b = a - 1\n&nbsp; &nbsp; bar(a, b)\n\ndef bar(a, b):\n&nbsp; &nbsp; raise Exception(\"something wrong!\")\n\nfoo(1)\n</code></pre><p>使用 Python 执行这个例子，结果是这样的：</p><pre><code class=\"language-plain\">Traceback (most recent call last):\n&nbsp; File \"test_tb.py\", line 8, in &lt;module&gt;\n&nbsp; &nbsp; foo(1)\n&nbsp; File \"test_tb.py\", line 3, in foo\n&nbsp; &nbsp; bar(a, b)\n&nbsp; File \"test_tb.py\", line 6, in bar\n&nbsp; &nbsp; raise Exception(\"something wrong!\")\nException: something wrong!\n</code></pre><p>执行到 bar 函数中的语句时，调用栈是由 <strong>main</strong> 调用了 foo 方法，再由 foo 调用了 bar 方法。</p><p>如果这个时候发生了异常，并且异常没有被 except 语句处理掉，那么就会使用默认的处理方式，也就是退回到上一帧。如果已经退到了最后一帧，就打印 Traceback，并且退出程序。</p><p>我们先从最基本的结构开始实现，首先要实现 Traceback 类型，可以考虑使用 C++ 实现，也可以使用 Python 实现。因为 Traceback 要访问栈帧，从栈帧中获取信息，所以使用 C++ 在虚拟机内部实现会更方便一些。</p><pre><code class=\"language-c++\">class StackElementKlass : public Klass {\nprivate:\n&nbsp; &nbsp; StackElementKlass() {}\n&nbsp; &nbsp; static StackElementKlass* _instance;\n\npublic:\n&nbsp; &nbsp; static StackElementKlass* get_instance();\n\n&nbsp; &nbsp; virtual void print(HiObject* x);\n&nbsp; &nbsp; virtual size_t size();\n&nbsp; &nbsp; virtual void oops_do(OopClosure* f, HiObject* obj);\n};\n\nclass StackElement : public HiObject {\nfriend StackElementKlass;\nprivate:\n&nbsp; &nbsp; HiString*&nbsp; &nbsp;_file_name;\n&nbsp; &nbsp; HiString*&nbsp; &nbsp;_func_name;\n&nbsp; &nbsp; int&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_line_no;\n\npublic:\n&nbsp; &nbsp; StackElement(HiString* fname, HiString* mname, int lineno);\n};\n\nclass TracebackKlass : public Klass {\nprivate:\n&nbsp; &nbsp; TracebackKlass() {}\n&nbsp; &nbsp; static TracebackKlass* _instance;\n\npublic:\n&nbsp; &nbsp; static TracebackKlass* get_instance();\n\n&nbsp; &nbsp; virtual void print(HiObject* x);\n&nbsp; &nbsp; virtual size_t size();\n&nbsp; &nbsp; virtual void oops_do(OopClosure* f, HiObject* obj);\n};\n\nclass Traceback : public HiObject {\nfriend class TracebackKlass;\nprivate:\n&nbsp; &nbsp; HiList*&nbsp; &nbsp;_stack_elements;\n\npublic:\n&nbsp; &nbsp; Traceback();\n\n&nbsp; &nbsp; void record_frame(FrameObject* frame);\n};\n</code></pre><p>与其他继承自 HiObject 的类型相似，Traceback 类型也有自己的 Klass，在 Klass 里增加 GC 接口，实现 print 方法。Traceback 中定义了一个列表 _stack_elements，其中记录着多个 StackElement。而 StackElement 中则存着栈帧的信息。</p><p>在刚刚那个例子中，我们已经观察到了 Traceback 的打印是由多帧组成的，我们把每一帧的信息都存到 StackElement 这个结构中。其中最重要的三个信息就是文件名、函数名和当前行数。可以看到，在 StackElement 中，我们分别加以定义。</p><p>其他地方就不再解释了，创建对象你应该都已经比较熟悉了。在异常处理的过程中，一直跟在 exception_class 后面的 Traceback 对象，终于在这里补齐了。</p><p>如果解释器的状态不是 OK，并且当前栈帧的 block_stack 为空，也就是没有其他的 Block 了，我们就可以离开栈帧了。所以这里可以在处理异常结束的地方增加离开函数栈帧的代码。</p><pre><code class=\"language-c++\">void Interpreter::eval_frame() {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n&nbsp; &nbsp; &nbsp; &nbsp; } // end of switch\n  \n\t\t// handle EXCEPTION with loop stack is not empty\n\t\t...\n  \n&nbsp; &nbsp; &nbsp; &nbsp; // has pending exception and no handler found, unwind stack.\n&nbsp; &nbsp; &nbsp; &nbsp; if (_int_status == IS_EXCEPTION &amp;&amp; _frame-&gt;blocks()-&gt;length() == 0) {\n            _trace_back-&gt;as&lt;Traceback&gt;()-&gt;record_frame(_frame);\n\n            if (_frame-&gt;is_first_frame() ||\n                    _frame-&gt;is_entry_frame())\n                return;\n            leave_frame();\n            goto error_handling;\n        }\n&nbsp; &nbsp; }\n}\n</code></pre><p>第 13 行使用了 Traceback 的 record_frame 方法来记录当前栈帧。你可以看一下它的具体实现。</p><pre><code class=\"language-c++\">void Traceback::record_frame(FrameObject* frame) {\n&nbsp; &nbsp; _stack_elements-&gt;append(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new StackElement(\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frame-&gt;file_name(),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frame-&gt;func_name(),\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frame-&gt;lineno()));\n}\n\nHiString* FrameObject::file_name() {\n&nbsp; &nbsp; return _codes-&gt;_file_name;\n}\n\nHiString* FrameObject::func_name() {\n&nbsp; &nbsp; return _codes-&gt;_co_name;\n}\n\nint FrameObject::lineno() {\n&nbsp; &nbsp; int pc_offset = 0;\n&nbsp; &nbsp; int line_no = _codes-&gt;_lineno;\n\n&nbsp; &nbsp; const char* lnotab = _codes-&gt;_notable-&gt;value();\n&nbsp; &nbsp; int length = _codes-&gt;_notable-&gt;length();\n\n&nbsp; &nbsp; for (int i = 0; i &lt; length; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; pc_offset += lnotab[i++];\n&nbsp; &nbsp; &nbsp; &nbsp; if (pc_offset &gt;= _pc)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return line_no;\n\n&nbsp; &nbsp; &nbsp; &nbsp; line_no += lnotab[i];\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; return line_no;\n}\n</code></pre><p>_stack_elements 是一个列表，它的每一个元素都是一个 StackElement 实例。其中记录了这个栈帧所对应的函数名和文件名，最重要的一个信息是行号。也就是说提示我们问题发生在哪一行。</p><p>行号的信息也存储在 CodeObject 中，我们以前还从来没有使用过。栈帧中只保留了 pc 的信息，它代表的是字节码的位置，而不是源代码的位置。要把字节码位置转换成源代码位置，就要使用 CodeObject 的 lineno 和 notable 来进行转换。</p><p>lineno 代表了这个函数源代码的起始行号，notable 则描述了字节码与源文件的行号对应关系。</p><p>我们来看一个具体的例子。</p><pre><code class=\"language-python\">print(\"hello\")\n\ndef foo():\n&nbsp; &nbsp; a = 1 + 1\n&nbsp; &nbsp; print(a)\n</code></pre><p>通过 show_file 工具查看 foo 方法的字节码。</p><pre><code class=\"language-plain\">&nbsp; &nbsp; &nbsp; code\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;argcount 0\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;nlocals 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;stacksize 2\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;flags 0043\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;code 64017d0074007c008301010064005300\n&nbsp; 4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 (2)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 STORE_FAST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (a)\n\n&nbsp; 5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 LOAD_GLOBAL&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (print)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 6 LOAD_FAST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 (a)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 8 CALL_FUNCTION&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10 POP_TOP\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0 (None)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;14 RETURN_VALUE\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;consts\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; None\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;names ('print',)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;varnames ('a',)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;freevars ()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;cellvars ()\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;filename '/Users/dandan/hinusDocs/gitee/pythonvm/build/htb.py'\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;name 'foo'\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;firstlineno 3\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;lnotab 00010401\n</code></pre><p>注意到 firstlineno 的值是 3 ，这说明 foo 方法是在第 3 行开始被定义的。</p><p>lnotab 每两位是一个独立的数字，每两个数字为一组，代表源代码行号和字节码行号的变化。例如，00010601 可以拆分为 ([00, 01], [06, 01]) 这样的结构。字节码的起始偏移是 0，而源代码的起始行号是 3。[00, 01] 代表了字节码偏移为 0+0 的地方对应的源代码是 3+1，也就是 4。</p><p>第二组，[06, 01] 代表了字节码偏移为 0+6 的地方对应的源代码是 4+1，也就是 5。就是说，在 lnotab 里，并不是直接把字节码偏移与源代码行号的对应关系记录下来，而是记录当源代码行号发生变化时，字节码偏移发生了多少变化。</p><p>明白了这个公式以后，FrameObject 的 lineno 方法也就清楚了。再回过头来看这个方法的实现，我们每次通过不断地改变 pc 偏移量，并且检查当前的 pc 是否落在两次变化之间，来确定当前的 pc 所对应的源代码行号。</p><p>如果在退栈的过程中，一直没有遇到可以处理这个异常的 except 语句，这个异常就会导致栈帧回退到最后一帧。在这里，虚拟机要提供一个默认的实现：打印这个 traceback。</p><pre><code class=\"language-c++\">void Interpreter::run(CodeObject* codes) {\n&nbsp; &nbsp; _frame = new FrameObject(codes);\n&nbsp; &nbsp; _frame-&gt;locals()-&gt;put(ST(name), new HiString(\"__main__\"));\n&nbsp; &nbsp; eval_frame();\n\n&nbsp; &nbsp; if (_int_status == IS_EXCEPTION) {\n&nbsp; &nbsp; &nbsp; &nbsp; _int_status = IS_OK;\n\n&nbsp; &nbsp; &nbsp; &nbsp; _trace_back-&gt;print();\n&nbsp; &nbsp; &nbsp; &nbsp; _pending_exception-&gt;print();\n&nbsp; &nbsp; &nbsp; &nbsp; printf(\"\\n\");\n\n&nbsp; &nbsp; &nbsp; &nbsp; _trace_back = NULL;\n&nbsp; &nbsp; &nbsp; &nbsp; _pending_exception = NULL;\n&nbsp; &nbsp; &nbsp; &nbsp; _exception_class = NULL;\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; destroy_frame();\n}\n\nvoid TracebackKlass::print(HiObject* x) {\n&nbsp; &nbsp; Traceback* tbx = (Traceback*)x;\n\n&nbsp; &nbsp; printf(\"Traceback (most recent call last):\\n\");\n&nbsp; &nbsp; for (int i = tbx-&gt;_stack_elements-&gt;size() - 1; i &gt;= 0; i--) {\n&nbsp; &nbsp; &nbsp; &nbsp; tbx-&gt;_stack_elements-&gt;get(i)-&gt;print();\n&nbsp; &nbsp; }\n}\n\nvoid StackElementKlass::print(HiObject* x) {\n&nbsp; &nbsp; StackElement* xse = (StackElement*)x;\n&nbsp; &nbsp; printf(\"&nbsp; File \\\"\");\n&nbsp; &nbsp; xse-&gt;_file_name-&gt;print();\n&nbsp; &nbsp; printf(\"\\\", line %d,\", xse-&gt;_line_no);\n&nbsp; &nbsp; printf(\" in \");\n&nbsp; &nbsp; xse-&gt;_func_name-&gt;print();\n&nbsp; &nbsp; printf(\"\\n\");\n}\n</code></pre><p>在 run 方法中，如果 eval_frame 结束以后，解释器的状态是 EXCEPTION，那就在这里把它处理掉。具体的动作是把 Traceback 打印出来，将状态改为 OK，并且把所有的异常信息都清空。Traceback 的打印也是比较简单的，只需要把每个栈帧的信息打印出来就可以了。</p><p>到这里，我们就把与异常相关的所有机制全部实现了。</p><h2>总结</h2><p>这节课完成了异常的全部功能以后，我们可以回顾一下异常处理的全部流程。</p><p>首先，解释器在正常执行的情况下，有些语句可能会发生异常，比如除法中遇到除数为 0 的情况会产生 ZeroDivisionError，循环执行到最后一个元素时会产生 StopIteration 异常，访问列表下标越界时会产生 IndexOutOrRangeErrror 等等。</p><p>如果异常发生在 try 语句中，解释器就会通过 SETUP_FINALLY Block 跳转入 except 子句或者 finally 子句执行。这个时候，要把栈上的 Block 状态设置为 EXCEPT_HANDLER，表示解释器正在处理异常对象。在这之前，解释器会把异常对象放入栈上，同时修改异常状态，这样解释器才能顺利执行 except 语句和 finally 语句中的指令。</p><p>最后，当 finally 子句执行完以后，END_FINALLY 会把异常状态全部恢复，以便于解释器带着异常状态退出当前函数栈帧。同时，我们还实现了 Traceback 对象在退栈时记录栈帧。这样异常处理的全部功能才算完成。</p><h2>思考题</h2><p>在现有的条件下，如果让你自己实现自定义类的迭代器，你会如何实现呢？欢迎你把思考结果分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"27｜异常（上）：优雅高效地处理运行时发生的错误","id":790838},"right":{"article_title":"29｜Generator：一种无栈协程的简易实现","id":792430}},"comments":[{"had_liked":false,"id":395603,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1731391749,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0}]}