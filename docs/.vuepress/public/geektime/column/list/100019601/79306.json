{"id":79306,"title":"11 | 组织好代码段，让人对它“一见钟情”","content":"<p>当我们看到一个事物的时候，它的轮廓首先进入视野，给了我们第一印象。如果第一印象没有吸引到我们，那我们就不会集中注意力去关注它，也不会想去认识它。</p><p>我觉得有个俗语非常好地概括了这个认知习惯。这个俗语就是“不起眼”，更通俗一点的说法是“放在人群里认不出来”。</p><p>不管我们愿不愿意，第一印象特别影响我们的判断和心情。我们看到美好的东西，自己也跟着高兴；看到乱糟糟的东西，自己也感觉乱糟糟的。</p><p>代码也是这样的。如果我们看到整齐、清爽的代码，我们就对它有好感，愿意阅读，也愿意改进。 如果代码一团糟，风格混乱，我们就特别想静静地走开，一行都不想看。</p><p>前面的几讲中，我们讨论了注释、声明、格式、注解等编码规范。现在，是时候把这些零散的知识放到一块儿了。这些规范组合在一起，就会让代码既有让人喜悦的轮廓，也有让人清爽的细节。</p><p>这一次，我们将使用大量的例子，从代码文件头部结构、对象结构、类的内部结构、方法的代码结构、限定词的使用以及空行的使用这六大维度，来说明到底该怎么组织一个源代码文件。</p><h2>代码文件头部结构</h2><p>一般来说，一个源代码文件的开始部分包含三项内容。 按照出现顺序，分别为：</p><ol>\n<li>\n<p>版权和许可声明；</p>\n</li>\n<li>\n<p>命名空间（package）；</p>\n</li>\n<li>\n<p>外部依赖（import）。</p>\n</li>\n</ol><!-- [[[read_end]]] --><p>下面就是一个例子。</p><p><img src=\"https://static001.geekbang.org/resource/image/ec/98/ec8f6ca100a22f3e2bf1e266b2cc3798.png?wh=626*616\" alt=\"\"><br>\n在版权部分中，“2003, 2013”中的2003表示的是代码的诞生日期，2013表示的是代码的最近更改日期。需要注意的是，每次代码变更，都要更改代码的最近更改日期。</p><h2>代码文件对象结构</h2><p>紧随着源代码的头部，是对目标类的定义，这一部分包含三个部分。 按照出现顺序，分别为：</p><ol>\n<li>\n<p>类的规范；</p>\n</li>\n<li>\n<p>类的声明；</p>\n</li>\n<li>\n<p>类的属性和方法。</p>\n</li>\n</ol><p>这一部分中，我们需要注意的是，对于公共类，需要使用since标签，标明从哪一个版本开始定义了这个类。 这样的标明，方便我们对类进行版本管理，减少我们进行代码变更时的工作量。</p><p><img src=\"https://static001.geekbang.org/resource/image/31/57/31f6b3e4d01dfed309ba567d68ab4c57.png?wh=620*248\" alt=\"\"><br>\n比如在上面的例子中，如果需要修改Readable，当看到“since 1.5”的标签时，我们就不需要检查Java 1.4的代码了。</p><p>你也许会问，为什么Java 1.4不能使用Readable呢？since标签同样可以给你答案，因为Readable是从Java 1.5开始才有的接口。</p><p>这些问题虽然简单，但是如果没有使用since标签，答案就没有这么直观明显了。</p><h2>类的内部代码结构</h2><p>类的属性和方法，一般是一个代码文件的主要组成部分。类的结构，推荐的编码顺序依次为：</p><ol>\n<li>\n<p>类的属性；</p>\n</li>\n<li>\n<p>构造方法；</p>\n</li>\n<li>\n<p>工厂方法；</p>\n</li>\n<li>\n<p>其他方法。</p>\n</li>\n</ol><p>我摘抄了一段JDK的代码，你看这样是不是更干净整洁？</p><p><img src=\"https://static001.geekbang.org/resource/image/ea/18/ea29c410fa71bd1b8639f3014fab0118.jpg?wh=625*893\" alt=\"\"><br>\n上面的代码案例中没有用到工厂方法，我来讲一下这个。</p><p>类似于构造方法，工厂方法也是用来构造一个类的实例。不同的是，工厂方法有具体的返回值。它可以是静态方法，也可以是实例方法。</p><p>如果是实例方法，工厂方法还可以被子类重写。这是工厂方法和构造方法的另外一个重要的区别。由于工厂方法也扮演着构造类实例的功能，我们一般把它放在构造方法的后面，其他方法的前面。</p><p><img src=\"https://static001.geekbang.org/resource/image/e4/53/e4e61e838d6ac10db8dbab2b8a621053.jpg?wh=626*896\" alt=\"\"></p><h2>方法的代码结构</h2><p>讲完了类的内部代码结构，我们再来讲讲方法的代码结构。一般来说，一个方法需要包含三项内容：</p><ol>\n<li>\n<p>方法的规范；</p>\n</li>\n<li>\n<p>方法的声明；</p>\n</li>\n<li>\n<p>方法的实现。</p>\n</li>\n</ol><p>内部类的内部方法，可以没有第一部分。但对于公开类的公开方法，方法的规范一定不能缺失。 一个典型的规范，应该包含以下十个部分：</p><ol>\n<li>\n<p>方法的简短介绍；</p>\n</li>\n<li>\n<p>方法的详细介绍（可选项）；</p>\n</li>\n<li>\n<p>规范的注意事项 (使用apiNote标签，可选项)；</p>\n</li>\n<li>\n<p>实现方法的要求 (使用implSpec标签，可选项)；</p>\n</li>\n<li>\n<p>实现的注意事项 (使用implNote标签，可选项)；</p>\n</li>\n<li>\n<p>方法参数的描述；</p>\n</li>\n<li>\n<p>返回值的描述；</p>\n</li>\n<li>\n<p>抛出异常的描述：需要注意的是，抛出异常的描述部分，不仅要描述检查型异常，还要描述运行时异常；</p>\n</li>\n<li>\n<p>参考接口索引（可选项）；</p>\n</li>\n<li>\n<p>创始版本（可选项）。</p>\n</li>\n</ol><p>下面的这个例子，也是来自JDK的源代码。你可以清晰地看到，这段代码中的规范是非常典型的。</p><p><img src=\"https://static001.geekbang.org/resource/image/5e/60/5e56601fedf15a44ec604175f1008d60.jpg?wh=621*920\" alt=\"\"><br>\n如果方法的创始版本和它所属类的创始版本一致，方法的创始版本描述可以省略。 要不然，一定要加入方法的创始版本标签。</p><p>像下面这个例子，就添加了创始版本标签。</p><p><img src=\"https://static001.geekbang.org/resource/image/3e/45/3e7e6fb89f1805ab562a8e09506e5a45.png?wh=626*702\" alt=\"\"></p><h2>按顺序使用限定词</h2><p>在声明一个类、方法或者方法属性时，为了更准确地描述和理解声明的适用场景，我们通常要使用修饰性的关键词。这些修饰性的关键词，我们通常称它们是修饰符或者限定词。 一个声明，可以使用多个限定词。</p><p>Java的语法中，限定词的使用顺序没有强制性规定。但是，限定词的使用顺序有一个约定俗成的规则。按照这个规则使用限定词，一般来说，我们最关切的修饰符最先进入我们的视野，和标识符最密切的位置最靠近标识符。使用一致性的顺序，我们就能更快速地理解一个声明。</p><p>限定词推荐使用顺序：</p><ol>\n<li>\n<p>public/private/protected （访问控制限定词，制定访问权限）</p>\n</li>\n<li>\n<p>abstract （抽象类或者抽象方法，具体实现由子类完成）</p>\n</li>\n<li>\n<p>static （静态类、方法或者类属性）</p>\n</li>\n<li>\n<p>final （定义不能被修改的类、方法或者类属性）</p>\n</li>\n<li>\n<p>transient（定义不能被序列化的类属性）</p>\n</li>\n<li>\n<p>volatile（定义使用主内存的变量）</p>\n</li>\n<li>\n<p>default（声明缺省的方法）</p>\n</li>\n<li>\n<p>synchronized（声明同步的方法）</p>\n</li>\n<li>\n<p>native（声明本地的方法，也就是Java以外的语言实现的方法）</p>\n</li>\n<li>\n<p>strictfp（声明使用精确浮点运算）</p>\n</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/4b/ce/4b6a702a1cbbc1f02882b9da0f44d1ce.png?wh=623*248\" alt=\"\"></p><h2>使用空行分割代码块</h2><p>我们之前讲过怎么整理代码，一个重要的原则就是“给代码分块”，通过空格、缩进、空行实现这个目的。</p><p>再来回顾一下空行的作用，空行用于垂直分割，用于分开同级别的不同代码块。</p><p>我们可以使用空行分割如下的代码块：</p><ol>\n<li>\n<p>版权和许可声明代码块；</p>\n</li>\n<li>\n<p>命名空间代码块；</p>\n</li>\n<li>\n<p>外部依赖代码块</p>\n</li>\n<li>\n<p>类的代码块；</p>\n</li>\n<li>\n<p>类的属性与方法之间；</p>\n</li>\n<li>\n<p>类的方法之间；</p>\n</li>\n<li>\n<p>方法实现的信息块之间。</p>\n</li>\n</ol><p><img src=\"https://static001.geekbang.org/resource/image/8e/f3/8ee01400b7a9131bdd717385ded77cf3.png?wh=627*548\" alt=\"\"></p><h2>小结</h2><p>对于软件开发者来说，组织代码是一项基本技能，也是我们需要养成的好习惯。组织代码有许多不同的习惯和策略，我们要学会辨别这些策略中哪些是有效的，哪些是有害的。</p><p>怎么辨别呢？</p><p>和其他技能一样，最快的提升方法是仔细思考一下为什么我们要做出这样的选择，而不是其他的。知其然远远不够，还要知其所以然。</p><p>你可以试着看看你的项目，源代码是按照这种方式组织的吗？哪些部分采用了合理的组织方式，哪些部分还有改进的空间？哪些是值得分享的经验？欢迎你把想法分享在留言区，我们一起来学习。</p><h2>一起来动手</h2><p>下面的这段Java代码，我们已经很熟悉了。前面，我们对它做过很多方面的修改。这一次，我们把前面的修改集中起来。你试着去找到所有可以改进的地方，然后比较一下修改前和修改后的代码。你有什么感受？</p><p>欢迎你把优化的代码公布在讨论区，让我们一起来感受、来欣赏！</p><p>也欢迎点击“<span class=\"orange\">请朋友读</span>”，把这篇文章分享给你的朋友或者同事，一起来体验修改代码的快感。</p><pre><code>import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    /**\n     * Given an array of integers, return indices of the two numbers\n     * such that they add up to a specific target.\n     */\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        throw new IllegalArgumentException(&quot;No two sum solution&quot;);\n    }\n}\n</code></pre><p></p>","neighbors":{"left":{"article_title":"10 | 异常处理都有哪些陷阱？","id":79083},"right":{"article_title":"12丨组织好代码文件，要有“用户思维”","id":79789}},"comments":[{"had_liked":false,"id":63992,"user_name":"老杨同志","can_delete":false,"product_type":"c1","uid":1246199,"ip_address":"","ucode":"3F334F0CFD3DE6","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/f7/3a493bec.jpg","comment_is_top":false,"comment_ctime":1548638032,"is_pvip":false,"replies":[{"id":"22727","content":"改的不错，还有一些小问题，有的我们还没有讲到。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1548703150,"ip_address":"","comment_id":63992,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18728507216","product_id":100019601,"comment_content":"&#47;*<br>\tCopyright (c) 2019 leetcode 算法练习<br>\t给定整形数组和目标值，求数组中那两个元素之和等于目标值<br>\texample : 输入 [2,4,6,7,] target = 10 ;return [4,6]<br>*&#47;<br><br>import java.util.HashMap;<br>import java.util.Map;<br><br>class Solution {<br><br>\t\t&#47;&#47;为了展示属性应该放的位置，强加属性，关键字顺序也是老师推荐的<br>\t\tprivate static final long serialVersionUID = 5454155825314635342L;<br>\t\t<br>\t\t&#47;&#47;只有一个构造方法可以省略，多个构造方法时，空实现换行加注解<br>\t\tpublic Solution(){<br>\t\t\t&#47;&#47;blank 空实现<br>\t\t}<br>\t\t<br>    &#47;**<br>     * Given an array of integers, return indices of the two numbers<br>     * such that they add up to a specific target.<br>     * return int[0] if nums==null or nums.length==0 or result not found.<br>     *&#47;<br>    public int[] twoSum(int[] nums, int target) {<br>    <br>    \t\t&#47;&#47;check 代码块之间空行隔开<br>    \t\tif (nums==null || nums.length==0) {<br>    \t\t\treturn new int[0];&#47;&#47;老师提示返回int[0]避免空指针<br>    \t\t}<br>    \t\t<br>    \t\t&#47;&#47;algorithm begin<br>        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();<br>        for (int i = 0; i &lt; nums.length; i++) {<br>            int complement = target - nums[i];<br>            if (map.containsKey(complement)) {<br>                return new int[] { map.get(complement), i };<br>            }<br>            map.put(nums[i], i);<br>        }<br>        <br>        &#47;&#47;not found<br>        return new int[0];<br>    }<br>}","like_count":4,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437797,"discussion_content":"改的不错，还有一些小问题，有的我们还没有讲到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548703150,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":73796,"user_name":"北风一叶","can_delete":false,"product_type":"c1","uid":1087302,"ip_address":"","ucode":"30310E66341D2A","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/46/fe1f21d8.jpg","comment_is_top":false,"comment_ctime":1552003959,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5846971255","product_id":100019601,"comment_content":"谢谢老师的整理 以后有法可依了","like_count":1},{"had_liked":false,"id":64133,"user_name":"苦行僧","can_delete":false,"product_type":"c1","uid":1055334,"ip_address":"","ucode":"726024A9A9CF44","user_header":"https://static001.geekbang.org/account/avatar/00/10/1a/66/2d9db9ed.jpg","comment_is_top":false,"comment_ctime":1548674692,"is_pvip":false,"replies":[{"id":"22725","content":"嗯，检查工具有反馈，多查到几次问题，慢慢我们就知道怎么规避这些问题了。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1548702976,"ip_address":"","comment_id":64133,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843641988","product_id":100019601,"comment_content":"一般用静态检查工具去发现问题","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437874,"discussion_content":"嗯，检查工具有反馈，多查到几次问题，慢慢我们就知道怎么规避这些问题了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548702976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":64019,"user_name":"Demon.Lee","can_delete":false,"product_type":"c1","uid":1052859,"ip_address":"","ucode":"7F0E5493A8E345","user_header":"https://static001.geekbang.org/account/avatar/00/10/10/bb/f1061601.jpg","comment_is_top":false,"comment_ctime":1548641849,"is_pvip":false,"replies":[{"id":"22648","content":"一般不要求分割。 缩进已经表明了这是下一级代码块。 换行的时候，大都是声明一行写不完，要用两行或者多行。 如果两个代码块视觉分割不清楚，可以多一个空行。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1548651617,"ip_address":"","comment_id":64019,"utype":1}],"discussion_count":1,"race_medal":1,"score":"5843609145","product_id":100019601,"comment_content":"老师，类的声明与方法或属性之间没有强制要求换行分割吧，有些同事喜欢这样干。<br>public class Xxx{<br>&#47;&#47;换行<br>private String xxx;<br>}","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437814,"discussion_content":"一般不要求分割。 缩进已经表明了这是下一级代码块。 换行的时候，大都是声明一行写不完，要用两行或者多行。 如果两个代码块视觉分割不清楚，可以多一个空行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548651617,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":63999,"user_name":"王智","can_delete":false,"product_type":"c1","uid":1079657,"ip_address":"","ucode":"0335277F255F7A","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg","comment_is_top":false,"comment_ctime":1548639079,"is_pvip":false,"replies":[{"id":"22723","content":"找的不错，还有一些问题，我们后面还会讲。","user_name":"作者回复","user_name_real":"范学雷","uid":"1111315","ctime":1548702800,"ip_address":"","comment_id":63999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5843606375","product_id":100019601,"comment_content":"好规范呀,发现自己以前写的代码好多都不规范!!!<br>课后习题在我看来: <br>1. 类没有介绍<br>2.方法前面介绍不全,必要的没写,比如说抛出的异常,参数等等<br>3.方法内没有空行分割,看起来一大片.<br>这就是我的看法,这篇文章的规范有点多,需要好好看一下.<br>加油!!!","like_count":1,"discussions":[{"author":{"id":1111315,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/13/78741b7b.jpg","nickname":"范学雷","note":"","ucode":"D7CBE4A33427BD","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":437801,"discussion_content":"找的不错，还有一些问题，我们后面还会讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1548702800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":322349,"user_name":"进化菌","can_delete":false,"product_type":"c1","uid":1276861,"ip_address":"","ucode":"B30A5F78BB4171","user_header":"https://static001.geekbang.org/account/avatar/00/13/7b/bd/ccb37425.jpg","comment_is_top":false,"comment_ctime":1637312557,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637312557","product_id":100019601,"comment_content":"该留的空行还是得留的，那样更好的展示代码块~","like_count":0},{"had_liked":false,"id":96704,"user_name":"Sisyphus235","can_delete":false,"product_type":"c1","uid":1366359,"ip_address":"","ucode":"829CC4CE0FA96E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ooZCPFY1xgC81h0Eu3vuqbWG5MaBp8RNmvXXGQwupo2LpSOLq0rBlTDRAF1yM6wF09WdeG49rA9dJSVKIUBxnQ/132","comment_is_top":false,"comment_ctime":1558489624,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1558489624","product_id":100019601,"comment_content":"规范的代码结构能提高开发效率，让后续的开发者能够快速理解项目结构和历史情况。代码迭代的时候也能快速找到所需要的信息，以及需要连动迭代的代码","like_count":0}]}