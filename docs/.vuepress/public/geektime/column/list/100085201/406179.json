{"id":406179,"title":"01｜实现一门超简单的语言最快需要多久？","content":"<p>你好，我是宫文学。</p><p>说到实现一门计算机语言，你肯定觉得这是一个庞大又复杂的工程，工作量巨大！</p><p>这个理解，我只能说部分正确。其实，有的时候，实现一门语言的速度也可以很快。比如，当年兰登·艾克（Brendan Eich）只花了10天时间就把JavaScript语言设计出来了。当然，语言跟其他软件一样，也需要不断迭代，至今JS的标准和实现仍在不停的演化。</p><p>如果我说，你也完全可以在这么短的时间内实现一门语言，甚至都不需要那么长时间，你一定会觉得我是在哗众取宠、标题党。</p><p>别急，我再补充说明一下，你马上就会认可我的说法了。这个让你一开始实现的版本，只是为了去探索计算机语言的原理，是高度简化的版本，并不要求马上能实用。你可以把它看做是一个原型系统，仅此而已，实现起来不会太复杂。</p><p>好吧，我知道你肯定还在心里打鼓：再简单的计算机语言，那也是一门语言呀，难度又能低到哪里去？</p><p>这样，先保留你的疑虑，我们进入今天的课程。<strong>今天我就要带你挑战，仅仅只用一节课时间，就实现一门超简洁的语言。</strong>我会暂时忽略很多的技术细节，带你抓住实现一门计算机语言的骨干部分，掌握其核心原理。在这节课中，你会快速获得两个技能：</p><ul>\n<li>如何通过编译器来理解某个程序；</li>\n<li>如何解释执行这个程序。</li>\n</ul><!-- [[[read_end]]] --><p>这两个点，分别是编译时的核心和运行时的核心。理解了这两个知识点，你就大致理解计算机语言是如何工作的了！</p><h2>我们的任务</h2><p>这节课，我们要让下面这个程序运行起来：</p><pre><code class=\"language-plain\">//一个函数的声明，这个函数很简单，只打印\"Hello World!\"\nfunction sayHello(){\n    println(\"Hello World!\");\n}\n//调用刚才声明的函数\nsayHello();\n</code></pre><p>这个程序做了两件事：第一件是声明了一个函数，叫做sayHello；第二件事，就是调用sayHello()函数。运行这个程序的时候，我们期待它会输出“Hello World！”。</p><p>这个程序看上去还挺像那么回事的，但其实为降低难度，我们对JavaScript/TypeScript做了极度的简化：它只支持声明函数和调用函数，在我们的sayHello()函数里，它只能调用函数。你可以调用一个自己声明的函数，如foo，也可以调用语言内置的函数，如示例中的println()。</p><p>这还不够，为了进一步降低难度，我们的编译器是从一个数组里读取程序，而不是读一个文本文件。这个数组的每一个元素是一个单词，分别是function、sayHello、左括号、右括号等等，这些单词，我们叫它Token，它们是程序的最小构成单位。注意，最后一个Token比较特殊，它叫做EOF，有时会记做$，表示程序的结尾。</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/be/7aea783003f9758f40bd3efdd2de48be.jpg?wh=1920x329\" alt=\"图片\" title=\"图1：Token串（图中不同的颜色代表不同类型的Token）\n\"></p><p>好了，现在任务清楚了，那我们开始第一步，解析这个程序。</p><h2>解析这个程序</h2><p>解析，英文叫做Parse，是指读入程序，并形成一个计算机可以理解的数据结构的过程。能够完成解析工作的程序，就叫做解析器（Parser），它是编译器的组成部分之一。</p><p>那么，什么数据结构是计算机能够理解的呢？很简单，其实就是一棵树，这棵树叫做<strong>抽象语法树，英文缩写是AST（Abstract Syntax Tree）</strong>。针对我们的例子，这棵AST是下面的样子：<br>\n<img src=\"https://static001.geekbang.org/resource/image/c3/37/c3109f472253e98057f255f7dbf57c37.jpg?wh=1920x1080\" alt=\"图片\" title=\"图2：示例代码对应的AST\"></p><p>你仔细看一下这棵树，你会发现它跟我们程序想表达的思想是一样的：</p><ul>\n<li>根节点代表了整个程序；</li>\n<li>根节点有两个子节点，分别代表一个函数声明和一个函数调用语句；</li>\n<li>函数声明节点，又包含了两个子节点，一个是函数名称，一个是函数体；</li>\n<li>函数体中又包含一个函数调用语句；</li>\n<li>而函数调用语句呢，则是由函数名称和参数列表构成的；</li>\n<li>……</li>\n</ul><p>通过这样自顶向下的层层分析，你会发现这棵树确实体现了我们原来的程序想表达的意思。其实，这就跟我们自己在阅读文章的时候是一样的，我们的大脑也是把段落分解成句子，再把句子分解成主语、谓语、宾语等一个个语法单元，最终形成一棵树型的结构，我们的大脑是能够理解这种树型结构的。</p><p>总结起来，<strong>解析器的工作，就是要读取一个Token串，然后把它转换成一棵AST</strong>。</p><p>好了，知道了解析的工作目标后，我们就来实现这个解析器吧！</p><p>可是，这怎么下手呢？</p><p>你可以琢磨一下，你的大脑是如何理解这些程序，并且把它们在不知不觉之间转化成一棵树的。我们假设，人类的大脑采用了一种自顶向下的分析方式，也就是把一个大的解析任务逐步分解成小的任务，落实到解析器的实现上也是如此。</p><p>首先，我们的目的是识别Token串的特征，并把它转换成AST。我们暂时忽略细节，假设我们能够成功地完成这个解析，那么把这个解析动作写成代码，就是：</p><pre><code class=\"language-plain\">prog = parseProg()；\n</code></pre><p>我们再具体一点，看看实现parseProg()需要做什么事情。</p><p>parseProg()需要建立程序的子节点，也就是函数声明或者函数调用。我们规定一个程序可以有零到多个函数声明或函数调用。我们把这个语法规则用比较严谨的方法表达出来，是这样的：</p><pre><code class=\"language-plain\">prog = (functionDecl | functionCall)* ;\n</code></pre><p>咦？这个表达方式看上去有点熟悉呀？这个式子的格式叫做EBNF格式（扩展巴科斯范式）。你可以看到，它的左边是一个语法成份的名称，右边说的是这个语法成份是由哪些子成分构成的。这样，整个式子就构成了一条语法规则。</p><p>不过，编译原理的教科书里，有时会用产生式的格式。EBNF格式和产生式是等价的，区别是产生式不允许使用？、*和+号，而是用递归来表示多个元素的重复，用ε来表示不生成任何字符串。如果我们把上述语法规则用产生式来表示的话，相当于下面四条：</p><pre><code class=\"language-plain\">prog -&gt; statement prog\nprog -&gt; ε\nstatement -&gt; functionDecl\nstatement -&gt; functionCall\n</code></pre><p>你马上就能看出来，还是EBNF格式更简洁吧？</p><p>好了，根据这条语法规则，一个程序要么是由函数声明构成的，要么是由函数调用构成的，那么我们就把它们一一解析出来，变成prog的子节点就好了！</p><p>可是，我们如何知道接下来遇到的是函数声明还是函数调用呢？</p><p>有办法！办法就是：试试看！</p><p>什么叫试试看？就是先试试是不是函数声明。如果成功的话，解析器就会返回一棵代表函数声明的子树；如果不成功的话，解析器就会返回null，然后你可以再试试看是不是函数调用。你可能会问：就这么简单？对，就这么简单。</p><p>实现上述逻辑的代码如下：</p><pre><code class=\"language-plain\">parseProg():Prog{\n    let stmts: Statement[] = [];\n    let stmt: Statement|null|void = null;\n    while(true){  //每次循环解析一个语句\n        //尝试一下函数声明\n        stmt = this.parseFunctionDecl();\n        if (stmt != null){\n            stmts.push(stmt);  \n            continue;\n        }\n        \n        //如果前一个尝试不成功，那么再尝试一下函数调用\n        stmt = this.parseFunctionCall();\n        if (stmt != null){\n            stmts.push(stmt);  \n            continue; \n        }\n\n        //如果都没成功，那就结束\n        if (stmt == null){\n            break;\n        }\n    }\n    return new Prog(stmts);\n}\n</code></pre><p>现在我们再往下一层，看看如何解析函数声明。</p><p>函数声明包括function关键字、函数名称、一对括号和函数体。我们依然将它表达成语法规则，是这样的：</p><pre><code class=\"language-plain\">functionDecl: \"function\" Identifier \"(\" \")\"  functionBody; \n</code></pre><p>注意，在这个新的语法规则里，我们发现了“function”、“Identifier”这样的元素，这些元素是不能再展开的，我们把它们叫做终结符。你会发现，终结符都是从Token转化而来的。而像“functionBody”这些用小写字母开头的元素，还可以再继续展开，所以叫做非终结符。</p><p>那这该怎么解析呢？</p><p>还是得挨个去试。先试一下第一个Token是不是“function”，再试下第二个Token是不是一个合法的标识符，接着试第三个Token是不是左括号，依此类推就行了。</p><p>其实，在函数声明的语法规则里，像“function”、“Identifier”这些，都已经是最终的Token了，所以直接把它们从Token串中取出来就行了，其中“Identifier”变成了AST中的函数名称。</p><p>而函数声明中的另一部分，也就是函数体，是一个比较复杂的结构，所以我们将它拆出来单独定义。体现在AST中，它就是函数声明的子节点。这里，我索性把剩余的有关函数体、函数调用的语法规则都写出来。</p><pre><code class=\"language-plain\">functionBody : '{' functionCall* '}' ;\nfunctionCall : Identifier '(' parameterList? ')' ;\nparameterList : StringLiteral (',' StringLiteral)* ;\n</code></pre><p>解析上述语法规则对应的程序如下：</p><pre><code class=\"language-plain\">/**\n     * 解析函数声明\n     * 语法规则：\n     * functionDecl: \"function\" Identifier \"(\" \")\"  functionBody;\n     */\n    parseFunctionDecl():FunctionDecl|null|void{\n        let oldPos:number = this.tokenizer.position();\n        let t:Token = this.tokenizer.next();\n        if (t.kind == TokenKind.Keyword &amp;&amp; t.text == \"function\"){\n            t = this.tokenizer.next();       \n            if (t.kind == TokenKind.Identifier){\n                //读取\"(\"和\")\"\n                let t1 = this.tokenizer.next();\n                if (t1.text==\"(\"){\n                    let t2 = this.tokenizer.next();\n                    if (t2.text==\")\"){\n                        let functionBody = this.parseFunctionBody();\n                        if (functionBody != null){\n                            //如果解析成功，从这里返回\n                            return new FunctionDecl(t.text, functionBody);\n                        }\n                    }\n                    else{\n                        console.log(\"Expecting ')' in FunctionDecl, while we got a \" + t.text);\n                        return;\n                    }\n                }\n                else{\n                    console.log(\"Expecting '(' in FunctionDecl, while we got a \" + t.text);\n                    return;\n                }            \n            }\n        }\n\n        //如果解析不成功，回溯，返回null。\n        this.tokenizer.traceBack(oldPos);\n        return null;\n    }\n\n    /**\n     * 解析函数体\n     * 语法规则：\n     * functionBody : '{' functionCall* '}' ;\n     */\n    parseFunctionBody():FunctionBody|null|void{\n        let oldPos:number = this.tokenizer.position();\n        let stmts:FunctionCall[] = [];\n        let t:Token = this.tokenizer.next();\n        if(t.text == \"{\"){\n            let functionCall = this.parseFunctionCall();\n            while(functionCall != null){  //解析函数体\n                stmts.push(functionCall);\n                functionCall = this.parseFunctionCall();\n            }\n            t = this.tokenizer.next();\n            if (t.text == \"}\"){\n                return new FunctionBody(stmts);\n            }\n            else{\n                console.log(\"Expecting '}' in FunctionBody, while we got a \" + t.text);\n                return;\n            }\n        }\n        else{\n            console.log(\"Expecting '{' in FunctionBody, while we got a \" + t.text);\n            return;\n        }\n        \n        //如果解析不成功，回溯，返回null。\n        this.tokenizer.traceBack(oldPos);\n        return null;\n    }\n\n    /**\n     * 解析函数调用\n     * 语法规则：\n     * functionCall : Identifier '(' parameterList? ')' ;\n     * parameterList : StringLiteral (',' StringLiteral)* ;\n     */\n    parseFunctionCall():FunctionCall|null|void{\n        let oldPos:number = this.tokenizer.position();\n        let params:string[] = [];\n        let t:Token = this.tokenizer.next();\n        if(t.kind == TokenKind.Identifier){\n            let t1:Token = this.tokenizer.next();\n            if (t1.text == \"(\"){\n                let t2:Token = this.tokenizer.next();\n                //循环，读出所有\n                while(t2.text != \")\"){\n                    if (t2.kind == TokenKind.StringLiteral){\n                        params.push(t2.text);\n                    }\n                    else{\n                        console.log(\"Expecting parameter in FunctionCall, while we got a \" + t2.text);\n                        return;  //出错时，就不在错误处回溯了。\n                    }\n                    t2 = this.tokenizer.next();\n                    if (t2.text != \")\"){\n                        if (t2.text == \",\"){\n                            t2 = this.tokenizer.next();\n                        }\n                        else{\n                            console.log(\"Expecting a comma in FunctionCall, while we got a \" + t2.text);\n                            return;\n                        }\n                    }\n                }\n                //消化掉一个分号：;\n                t2 = this.tokenizer.next();\n                if (t2.text == \";\"){\n                    return new FunctionCall(t.text, params);\n                }\n                else{\n                    console.log(\"Expecting a comma in FunctionCall, while we got a \" + t2.text);\n                    return;\n                }\n            }\n        }\n\n        //如果解析不成功，回溯，返回null。\n        this.tokenizer.traceBack(oldPos);\n        return null;\n    }\n}\n</code></pre><p>到这里你会发现，我们做语法分析的思路很简单：</p><ul>\n<li><strong>首先，写出语法规则</strong>，比如说用EBNF格式。</li>\n<li><strong>第二，根据语法规则，分别匹配每个子元素。</strong>如果这个语法规则中用到了另一个语法规则，就像函数声明里用到了函数体，那么我们就需要递归地匹配这条语法规则。这个层层下降的匹配过程，叫做“<strong>递归下降（Recursive Descent）</strong>”，这就是我们刚刚采用的算法，Java、V8等很多编译器也都采用了这个递归下降算法。</li>\n<li><strong>第三，如果一条语法规则可能有多个展开方式</strong>，就像程序里面既可以是函数声明，也可以是函数调用，<strong>那么我们就要依次尝试去匹配</strong>。如果尝试失败，就回退，再去尝试另一个展开方式。</li>\n</ul><p>好了，你也知道了，我们刚才用到的方法就是大名鼎鼎的“递归下降算法”。当然，这是它的初级版本，会存在一些缺陷，这个我们后面会讲。不过，即使是像JDK里的Java编译器、V8的JaveScript编译器、Go语言的编译器这些成熟的编译器，采用的都是递归下降算法，所以你应该足够重视它。</p><h2>做一点简单的语义分析</h2><p>好了，现在我们已经完成了语法分析工作，并形成了AST。但是，在解释执行这个程序之前，我们还要做一点微小的工作：就是<strong>引用消解（Refrence Resolving）</strong>。</p><p>这是什么意思呢？</p><p>在我们的程序中有两处函数调用：一处是println()，我们现在把它看做内置函数就好了，而另一处，是调用我们自定义的函数sayHello()。那么<strong>引用消解，就是把函数的调用和函数的定义关联到一起</strong>，否则，程序就没法正常运行。由于我们目前的语言很简单，所以引用消解工作也很简单，你可以看看下面的参考代码：</p><pre><code class=\"language-plain\">//遍历prog中的所有语句，找到一个名称匹配的函数声明\nprivate findFunctionDecl(prog:Prog, name:string):FunctionDecl|null{\n    for(let x of prog?.stmts){\n        let functionDecl = x as FunctionDecl;\n        if (typeof functionDecl.body === 'object' &amp;&amp; \n            functionDecl.name == name){\n            return functionDecl;\n        }\n    }\n    return null;\n}\n</code></pre><p>引用消解是语义分析过程中必须要做的一项工作，其他更多的语义分析工作我们仍然可以忽略。做完了语义分析以后，AST上增加了一些信息：<br>\n<img src=\"https://static001.geekbang.org/resource/image/31/f0/3136fc4f3d74f607e0edc9454d71e6f0.jpg?wh=1920x1080\" alt=\"图片\" title=\"图3：在AST增加了引用信息，可以找到函数的定义\"><br>\n在上图中，你可以看到对sayHello()函数做调用的AST节点，指向了sayHello的函数声明节点。这样，在解释器里执行sayHello()的时候，就能找到该执行什么代码了！</p><h2>做一个简单的解释器来运行这个程序</h2><p>好了，完成好上面各项准备工作，接下来要实现解释器了。</p><p>解释器怎么运行呢？很简单，自顶向下、深度优先地遍历一下AST就行了。</p><p>具体过程是这样的：<br>\n<img src=\"https://static001.geekbang.org/resource/image/0e/ff/0e90bfdb9ec8fb4dc1866025d72d18ff.jpg?wh=1920x1080\" alt=\"图片\" title=\"图4：通过遍历AST来解释执行程序\"><br>\n第1步，我们要来访问prog节点。</p><p>第2步，接着访问prog的第一个子节点的，但这个子节点是一个函数声明，函数声明是不能直接运行的，所以此时访问这个节点不会产生任何动作。</p><p>第3步，访问prog的第二个子节点。这个子节点是一个函数调用，由于我们已经做了引用消解，我们已经知道这个函数在AST中的位置了。</p><p>第4步，我们要跳到函数定义的位置去执行这个函数，然后在第5步中执行这个函数的函数体。</p><p>第6步，我们再执行函数体的下一级节点，也就是println(“Hello World”)。这实际上是调用一个内置函数，因此我们把“Hello World”作为参数传递给内置函数就行了。</p><p>到此，程序执行完毕，输出了“Hello World”。</p><p>为了加深你的理解，我再举一个例子。</p><p>假如我们的语言现在已经支持表达式了，那么对于2+3*5这样一个表达式，解析器也会自动形成一棵AST。这时，对表达式求值的过程，也就是遍历AST的过程。</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/ae/3cf0eb845e3e03f54b81a14ffe7cc9ae.jpg?wh=1920x917\" alt=\"图片\" title=\"图5：通过遍历AST来计算表达式的值（图中标号，是完全访问完毕一棵子树的顺序）\"></p><h2>课程小结</h2><p>好了，这就是我们今天的全部内容了。虽然我们做了很多的简化，但我们毕竟已经能让一个程序运行起来了。你还可以把示例程序改写一下，比如多写几个自定义的函数，多做几个函数调用，打印出调用过程，等等。</p><p>例如，在下面的示例程序中，我又新声明了一个函数bar，并在bar中调用foo，检验一下多级函数调用是否会正常运行。</p><pre><code class=\"language-plain\">function foo(){\n  println(\"in foo...\");\n}\n\nfunction bar(){\n  println(\"in bar...\");\n  foo();\n}\n\nbar();\n</code></pre><p>你看，虽然我们的程序特性很少，但毕竟能玩起来了。你只要遵守语言的特性，编写出来的任意程序都是能正确执行的，这就是计算机语言最有魅力的地方！而且，你也可以亲手实现。</p><p>我给你把这节课的要点总结一下：</p><ul>\n<li>要实现一门计算机语言，首先要有一个编译器来把程序转化成计算机可理解的数据（这里是AST），然后需要有一个解释器来执行它。</li>\n<li>编译器有很多功能，词法分析功能在这讲被我们故意跳过了。在语法分析部分，我们了解了如何用EBNF格式来表达语法规则，并初步介绍了递归下降算法；在语义分析部分，我们做了函数的引用消解。</li>\n<li>我们当前版本的解释器，是通过遍历AST来运行程序的，方便你理解原理。在后面的课程中，我们会把AST转换成更适合解释执行的中间代码（Intermediate Representation，IR），就像Java的字节码一样，然后我们再实现一个新的解释器。</li>\n</ul><p>这节课我们忽略了很多技术细节，别担心，之后的课程，我们会一一补上这些知识点，让你平滑地学到实现一门语言的所有技能。</p><h2>思考题</h2><p>我们今天的课程就到这里了，我给你布置了两个思考题来巩固下今天学习的内容。</p><p>问题1：在这节课讲述的语法规则中，我们做了一些简化，比如在函数声明的时候，我们并没有管参数。如果加上参数，你会怎样改写一下语法规则呢？另外，我们目前用的还是JavaScript的语法，如果改成TypeScript的语法，带上类型声明，语法规则又会是什么样子呢？你可以练习一下。</p><p>问题2：在今天的课程里，我们的语法分析的算法是“递归下降”算法。不知道你有没有发现，我们的程序里并没有出现函数的递归调用呀，为什么还要说它是递归的呢？</p><p>感谢你和我一起学习，如果你觉得我这节课讲得还不错，也欢迎你把它分享给更多对编程语言感兴趣的朋友。我是宫文学，我们下节课见。</p><h2>资源链接</h2><p><a href=\"https://gitee.com/richard-gong/craft-a-language/blob/master/01/play.ts\">这节课的示例代码在这里！</a></p>","comments":[{"had_liked":false,"id":306380,"user_name":"青玉白露","can_delete":false,"product_type":"c1","uid":2619436,"ip_address":"","ucode":"96FE2D4D2B94A0","user_header":"https://static001.geekbang.org/account/avatar/00/27/f8/2c/92969c48.jpg","comment_is_top":false,"comment_ctime":1628519848,"is_pvip":false,"replies":[{"id":"111000","content":"多谢支持！","user_name":"作者回复","comment_id":306380,"uid":"1543380","ip_address":"","utype":1,"ctime":1628644422,"user_name_real":"宫文学Richard"}],"discussion_count":1,"race_medal":0,"score":"23103356328","product_id":100085201,"comment_content":"这门课我追定了！宫老师加紧更新哈，内容很赞","like_count":5,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524736,"discussion_content":"多谢支持！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628644422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306646,"user_name":"张贺","can_delete":false,"product_type":"c1","uid":1283181,"ip_address":"","ucode":"0254E40FB3EB5F","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/6d/5cd6e8c7.jpg","comment_is_top":false,"comment_ctime":1628655487,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"18808524671","product_id":100085201,"comment_content":"代码中RefResolver中的visitFunctionBody方法不应该return吧","like_count":4,"discussions":[{"author":{"id":1628867,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","nickname":"有学识的兔子","note":"","ucode":"D1D654B1562FC9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388703,"discussion_content":"是应该去掉，函数体可能有多个函数调用，都需要遍历来进行引用消解，只处理一个就返回是不对的。不过demo里函数体内就一个函数调用，所以也不影响demo的展示结果。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628920104,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1074098,"avatar":"https://static001.geekbang.org/account/avatar/00/10/63/b2/9223bc53.jpg","nickname":"Fenix","note":"","ucode":"AA8C1EECDFD405","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391034,"discussion_content":"赞同，\n\nfunction foo(){\n  println(&#34;in foo...&#34;);\n}\n\nfunction bar(){\n  println(&#34;in bar...&#34;);\n  foo();\n}\n\nbar();\n\n但是如果是这个demo的话，就应该把return去掉的。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630238275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":316316,"user_name":"被讨厌的勇气","can_delete":false,"product_type":"c1","uid":1547913,"ip_address":"","ucode":"AE3B3CA27D91A2","user_header":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","comment_is_top":false,"comment_ctime":1634266985,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14519168873","product_id":100085201,"comment_content":"递归思想，在程序中常见的实现是：自己调用自己，即函数调用自身。<br>递归思想的本义是：将一个复杂问题分解成规模较小的几个子问题。从递归思想的角度来看，递归下降算法将语法分析分解为函数声明分析、函数调用分析，且子问题可以进一步分解，所以称之为“递归”。","like_count":3},{"had_liked":false,"id":307518,"user_name":"奋斗的蜗牛","can_delete":false,"product_type":"c1","uid":2326308,"ip_address":"","ucode":"F4324049E3F717","user_header":"https://static001.geekbang.org/account/avatar/00/23/7f/24/ceab0e7b.jpg","comment_is_top":false,"comment_ctime":1629129182,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10219063774","product_id":100085201,"comment_content":"期待后面后端的内容，一直卡在这块，找不到学习的思路，老师水平真高，深入浅出！！","like_count":2},{"had_liked":false,"id":309174,"user_name":"Geek_9a1bc6","can_delete":false,"product_type":"c1","uid":2731718,"ip_address":"","ucode":"0D1FCC50D9D580","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJZa7kzYIicRuA6vXj9J0zVHpJI1mIrxhUZXYu2zLn32egqlOroO2M4qYzSFqhmUibUIicHDCqqsaHkg/132","comment_is_top":false,"comment_ctime":1629968667,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5924935963","product_id":100085201,"comment_content":"代码node命令执行没问题，用tsc命令编译报错： Type &#39;void&#39; is not assignable to type &#39;FunctionCall&#39;. 有没有遇到的童鞋？","like_count":1},{"had_liked":false,"id":308227,"user_name":"Juude","can_delete":false,"product_type":"c1","uid":1183409,"ip_address":"","ucode":"9B793A5952433E","user_header":"https://static001.geekbang.org/account/avatar/00/12/0e/b1/9ec5c110.jpg","comment_is_top":false,"comment_ctime":1629458872,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5924426168","product_id":100085201,"comment_content":"请问代码修改后怎么运行呢","like_count":1},{"had_liked":false,"id":306472,"user_name":"全国第一菜","can_delete":false,"product_type":"c1","uid":1118602,"ip_address":"","ucode":"CBB341155DE21F","user_header":"https://static001.geekbang.org/account/avatar/00/11/11/8a/534b3c2d.jpg","comment_is_top":false,"comment_ctime":1628575069,"is_pvip":false,"replies":[{"id":"110995","content":"谢谢肯定，加油！","user_name":"作者回复","comment_id":306472,"uid":"1543380","ip_address":"","utype":1,"ctime":1628644071,"user_name_real":"宫文学Richard"}],"discussion_count":1,"race_medal":0,"score":"5923542365","product_id":100085201,"comment_content":"偶然间习得宫老师的前两门课，如获至宝，对个人提升显著。今天看到开新课了，第一时间来支持，因为知道自己又要变强了！！加油","like_count":1,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524781,"discussion_content":"谢谢肯定，加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628644071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306466,"user_name":"🇵 🇦 🇳 🇩 🇦","can_delete":false,"product_type":"c1","uid":2623263,"ip_address":"","ucode":"2BD3EEABB860EF","user_header":"https://static001.geekbang.org/account/avatar/00/28/07/1f/fd9e757f.jpg","comment_is_top":false,"comment_ctime":1628572856,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5923540152","product_id":100085201,"comment_content":"太牛了！","like_count":1},{"had_liked":false,"id":359810,"user_name":"blue","can_delete":false,"product_type":"c1","uid":1447292,"ip_address":"广东","ucode":"BC183E857A0B8D","user_header":"https://static001.geekbang.org/account/avatar/00/16/15/7c/2d8d0778.jpg","comment_is_top":false,"comment_ctime":1665927784,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665927784","product_id":100085201,"comment_content":"老师，图5那个AST遍历。 “返回4”是不是有问题，不是应该“返回3”吗","like_count":0},{"had_liked":false,"id":356916,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1662701578,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662701578","product_id":100085201,"comment_content":"ast的深度优先遍历，一般就是用递归的。","like_count":0},{"had_liked":false,"id":353741,"user_name":"功夫熊猫","can_delete":false,"product_type":"c1","uid":2732243,"ip_address":"江苏","ucode":"D124F4FA4E816F","user_header":"https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg","comment_is_top":false,"comment_ctime":1659720446,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1659720446","product_id":100085201,"comment_content":"递归的本质还是将一个复杂的大问题转换为小问题。回朔和动态规划都是也是这个意思。而且一般的递归程序是可以改为用栈或者队列实现的","like_count":0},{"had_liked":false,"id":331840,"user_name":"Geek_9a1bc6","can_delete":false,"product_type":"c1","uid":2731718,"ip_address":"","ucode":"0D1FCC50D9D580","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJZa7kzYIicRuA6vXj9J0zVHpJI1mIrxhUZXYu2zLn32egqlOroO2M4qYzSFqhmUibUIicHDCqqsaHkg/132","comment_is_top":false,"comment_ctime":1642819946,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642819946","product_id":100085201,"comment_content":"这个规则：<br><br>functionDecl: &quot;function&quot; Identifier &quot;(&quot; &quot;)&quot;  functionBody; <br><br>和antlr的g4文件的语法规则是一样的？","like_count":0},{"had_liked":false,"id":307279,"user_name":"五木老祖","can_delete":false,"product_type":"c1","uid":2027798,"ip_address":"","ucode":"92AF53B434C99C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f1/16/9eda1d16.jpg","comment_is_top":false,"comment_ctime":1629000802,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629000802","product_id":100085201,"comment_content":"好像还是没有明白token怎么转换为Ast的。","like_count":0,"discussions":[{"author":{"id":1547913,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9e/89/6e9c05d6.jpg","nickname":"被讨厌的勇气","note":"","ucode":"AE3B3CA27D91A2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":404245,"discussion_content":"AST，抽象语法树，这里的树结构与常见的数据结构树不同。我们常见的数据结构树，所有节点都是同一结构体 node，这 AST 每个节点都是不同的结构体，比如 Prog、FunctionDecl 等","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634267283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307078,"user_name":"haha","can_delete":false,"product_type":"c1","uid":2623098,"ip_address":"","ucode":"E8F99449B78882","user_header":"https://static001.geekbang.org/account/avatar/00/28/06/7a/9a60b72f.jpg","comment_is_top":false,"comment_ctime":1628850999,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1628850999","product_id":100085201,"comment_content":"少println，目前clone下来的代码是不是还不能正常执行？","like_count":0,"discussions":[{"author":{"id":1146704,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7f/50/3e952cfa.jpg","nickname":"青山","note":"","ucode":"8B12013E2A6171","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":401208,"discussion_content":"看作者给的代码 https://gitee.com/richard-gong/craft-a-language/blob/master/01/play.ts ，这个 println 是作为内置函数实现的，里面调用了 console.log()。TS 原生应该是不支持 println 的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633602661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1527329,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoc8sReia18fc3LgNBcL1lQ1OfdcNvSNPichaiccDHxNG4Arx21CjgrZJG2y8KibniaLlbibtOo53qEEnAw/132","nickname":"Hezhen","note":"","ucode":"C8C0AAA23D3302","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400943,"discussion_content":"我也遇到了这个问题，请问怎么解决的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633495258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306872,"user_name":"haha","can_delete":false,"product_type":"c1","uid":2623098,"ip_address":"","ucode":"E8F99449B78882","user_header":"https://static001.geekbang.org/account/avatar/00/28/06/7a/9a60b72f.jpg","comment_is_top":false,"comment_ctime":1628759843,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1628759843","product_id":100085201,"comment_content":"class FunctionCall extends Statement{<br>    name: string;<br>    parameters: string[];<br>    definition: FunctionDecl | null = null; &#47;&#47;指向函数的声明<br>    constructor(name:string, parameters: string[]){<br>        super();<br>        this.name = name;<br>        this.parameters = parameters;<br>    }<br>    public dump(prefix:string){<br>        console.log(prefix+&quot;FunctionCall&quot;+this.name+(this.definition!=null?&quot;,resolved&quot; : &quot;not resolved&quot;));<br>        this.parameters.forEach(x =&gt; console.log(prefix+&quot;\\t&quot;+&quot;Parameter&quot;+x));<br>    }<br>}<br>请问同学们：<br>forEach 中的x代表的是string[]的每一个parameter吗？","like_count":0,"discussions":[{"author":{"id":2623098,"avatar":"https://static001.geekbang.org/account/avatar/00/28/06/7a/9a60b72f.jpg","nickname":"haha","note":"","ucode":"E8F99449B78882","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388937,"discussion_content":"谢谢！我现在是个小白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629074333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1318243,"avatar":"https://static001.geekbang.org/account/avatar/00/14/1d/63/62078f19.jpg","nickname":"张国旗","note":"","ucode":"AF519777AB262E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388624,"discussion_content":"对\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628855722,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306775,"user_name":"有学识的兔子","can_delete":false,"product_type":"c1","uid":1628867,"ip_address":"","ucode":"D1D654B1562FC9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","comment_is_top":false,"comment_ctime":1628697181,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628697181","product_id":100085201,"comment_content":"问题2:层层下降的匹配过程，是“递归下降”。程序中虽然没有递归调用，但有while语句循环调用同一个函数，是不是递归调用一种改写？这样实现自我调用，同时不像递归调用消耗过大的栈空间？","like_count":0},{"had_liked":false,"id":306754,"user_name":"有学识的兔子","can_delete":false,"product_type":"c1","uid":1628867,"ip_address":"","ucode":"D1D654B1562FC9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIicr82CnrdEjibibAvyeKRQHszSzIAqoCWxN0kqC442XcjEae6S9j6NDtKLpg4Da4CUQQeUFUicWqiaDw/132","comment_is_top":false,"comment_ctime":1628690857,"is_pvip":false,"replies":[{"id":"111130","content":"谢谢肯定，一起Fighting！","user_name":"作者回复","comment_id":306754,"uid":"1543380","ip_address":"","utype":1,"ctime":1628762008,"user_name_real":"宫文学Richard"}],"discussion_count":1,"race_medal":0,"score":"1628690857","product_id":100085201,"comment_content":"给宫老师点赞，老师提供出来的课程都是夯实编程能力的知识。工作中功能业务围绕业务展开，基于成熟的框架设计模式做功能开发或局部优化，过程中也隐约感受缺失对编程世界整体了解带来的麻烦。之前也学习了一点点宫老师《编译原理之美》，很庆幸感受这门实战课。Fighting !","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524900,"discussion_content":"谢谢肯定，一起Fighting！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628762008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306576,"user_name":"_______R","can_delete":false,"product_type":"c1","uid":1979948,"ip_address":"","ucode":"419DE0EE06FA66","user_header":"https://static001.geekbang.org/account/avatar/00/1e/36/2c/34bacff9.jpg","comment_is_top":false,"comment_ctime":1628611797,"is_pvip":false,"replies":[{"id":"111035","content":"可以呀。你建一个自己的仓库，可以把链接分享出来！","user_name":"作者回复","comment_id":306576,"uid":"1543380","ip_address":"","utype":1,"ctime":1628652299,"user_name_real":"宫文学Richard"}],"discussion_count":2,"race_medal":0,"score":"1628611797","product_id":100085201,"comment_content":"宫老师，我之前看过一点点 ts，现在主学 go，今天刚把 01 的代码用 go 重写，可以提交到码云上吗","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524816,"discussion_content":"可以呀。你建一个自己的仓库，可以把链接分享出来！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628652299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1979948,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/36/2c/34bacff9.jpg","nickname":"_______R","note":"","ucode":"419DE0EE06FA66","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389163,"discussion_content":"https://gitee.com/Boii/craft-a-language-go，这是仓库地址，如果可以的话我想 fork 您的仓库并新建一个 go 分支","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629163608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306478,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1628578791,"is_pvip":true,"replies":[{"id":"110998","content":"没问题，你可以修改优化一下。<br>事实上，在后面的章节中，这些代码的结构就修改了，变成了直线式的代码，同时增加了语法错误的处理能力。<br>这一节的代码，是为了尽量避免太多功能，尽量避免复杂化。","user_name":"作者回复","comment_id":306478,"uid":"1543380","ip_address":"","utype":1,"ctime":1628644373,"user_name_real":"宫文学Richard"}],"discussion_count":1,"race_medal":0,"score":"1628578791","product_id":100085201,"comment_content":"if嵌套看着脑阔疼，建议扩充token类型，增加一些helper方法：<br><br>```typescript<br>  &#47;**<br>   * 解析函数调用 <br>   * 语法规则:<br>   * functionCall = Identifier &quot;(&quot; parameterList? &quot;)&quot; &quot;;&quot;<br>   * parameterList = StringLiteral (&quot;,&quot; StringLiteral)*<br>   *&#47;<br>  private parseFunctionCall(): FunctionCall | undefined {<br>    if (!this.hasNext(TokenKind.Identifier)) return;<br><br>    const funcName = this.consume(TokenKind.Identifier);<br><br>    this.consume(TokenKind.LParen);<br><br>    const params = [];<br>    if (this.hasNext(TokenKind.StringLiteral)) {<br>      params.push(this.consume(TokenKind.StringLiteral));<br><br>      while (this.hasConsumed(TokenKind.Comma)) {<br>        params.push(this.consume(TokenKind.StringLiteral));<br>      }<br>    }<br><br>    this.consume(TokenKind.RParen);<br><br>    this.consume(TokenKind.Semi);<br><br>    return new FunctionCall(funcName, params);<br>  }<br>}<br>```<br>","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524785,"discussion_content":"没问题，你可以修改优化一下。\n事实上，在后面的章节中，这些代码的结构就修改了，变成了直线式的代码，同时增加了语法错误的处理能力。\n这一节的代码，是为了尽量避免太多功能，尽量避免复杂化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628644373,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306474,"user_name":"千无","can_delete":false,"product_type":"c1","uid":1813715,"ip_address":"","ucode":"C43C9D532AE50A","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ac/d3/3e461046.jpg","comment_is_top":false,"comment_ctime":1628577107,"is_pvip":true,"replies":[{"id":"110993","content":"非常好，这门课就是提倡动手实践的！","user_name":"作者回复","comment_id":306474,"uid":"1543380","ip_address":"","utype":1,"ctime":1628644042,"user_name_real":"宫文学Richard"}],"discussion_count":1,"race_medal":0,"score":"1628577107","product_id":100085201,"comment_content":"很赞，课后习题一定要做，这才是这门课的精髓，实践它掌握它，课就超值","like_count":0,"discussions":[{"author":{"id":1543380,"avatar":"https://static001.geekbang.org/account/avatar/00/17/8c/d4/5972b7cc.jpg","nickname":"宫文学Richard","note":"","ucode":"09EADF0CB62C91","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524783,"discussion_content":"非常好，这门课就是提倡动手实践的！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628644042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}