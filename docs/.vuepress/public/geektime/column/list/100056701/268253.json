{"id":268253,"title":"02 | 数据结构：快速的Redis有哪些慢操作？","content":"<p>你好，我是蒋德钧。</p><p>一提到Redis，我们的脑子里马上就会出现一个词：“快。”但是你有没有想过，Redis的快，到底是快在哪里呢？实际上，这里有一个重要的表现：它接收到一个键值对操作后，能以<strong>微秒级别</strong>的速度找到数据，并快速完成操作。</p><p>数据库这么多，为啥Redis能有这么突出的表现呢？一方面，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。另一方面，这要归功于它的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是Redis快速处理数据的基础。这节课，我就来和你聊聊数据结构。</p><p>说到这儿，你肯定会说：“这个我知道，不就是String（字符串）、List（列表）、Hash（哈希）、Set（集合）和Sorted Set（有序集合）吗？”其实，这些只是Redis键值对中值的数据类型，也就是数据的保存形式。而这里，我们说的数据结构，是要去看看它们的底层实现。</p><p>简单来说，底层数据结构一共有6种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/82/01/8219f7yy651e566d47cc9f661b399f01.jpg?wh=4000*1188\" alt=\"\"></p><p>可以看到，String类型的底层实现只有一种数据结构，也就是简单动态字符串。而List、Hash、Set和Sorted Set这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p><!-- [[[read_end]]] --><p>看到这里，其实有些问题已经值得我们去考虑了：</p><ul>\n<li>这些数据结构都是值的底层实现，键和值本身之间用什么结构组织？</li>\n<li>为什么集合类型有那么多的底层结构，它们都是怎么组织数据的，都很快吗？</li>\n<li>什么是简单动态字符串，和常用的字符串是一回事吗？</li>\n</ul><p>接下来，我就和你聊聊前两个问题。这样，你不仅可以知道Redis“快”的基本原理，还可以借此理解Redis中有哪些潜在的“慢操作”，最大化Redis的性能优势。而关于简单动态字符串，我会在后面的课程中再和你讨论。</p><p>我们先来看看键和值之间是用什么结构组织的。</p><h2>键和值用什么结构组织？</h2><p>为了实现从键到值的快速访问，Redis使用了一个哈希表来保存所有键值对。</p><p>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</p><p>看到这里，你可能会问了：“如果值是集合类型的话，作为数组元素的哈希桶怎么来保存呢？”其实，哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是String，还是集合类型，哈希桶中的元素都是指向它们的指针。</p><p>在下图中，可以看到，哈希桶中的entry元素中保存了<code>*key</code>和<code>*value</code>指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过<code>*value</code>指针被查找到。</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/5f/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg?wh=1773*875\" alt=\"\"></p><p>因为这个哈希表保存了所有的键值对，所以，我也把它称为<strong>全局哈希表</strong>。哈希表的最大好处很明显，就是让我们可以用O(1)的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的entry元素。</p><p>你看，这个查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说，不管哈希表里有10万个键还是100万个键，我们只需要一次计算就能找到相应的键。</p><p>但是，如果你只是了解了哈希表的O(1)复杂度和快速查找特性，那么，当你往Redis中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是<strong>哈希表的冲突问题和rehash可能带来的操作阻塞。</strong></p><h3>为什么哈希表操作变慢了？</h3><p>当你往哈希表中写入更多数据时，哈希冲突是不可避免的问题。这里的哈希冲突，也就是指，两个key的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。</p><p>毕竟，哈希桶的个数通常要少于key的数量，这也就是说，难免会有一些key的哈希值对应到了同一个哈希桶中。</p><p>Redis解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指<strong>同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接</strong>。</p><p>如下图所示：entry1、entry2和entry3都需要保存在哈希桶3中，导致了哈希冲突。此时，entry1元素会通过一个<code>*next</code>指针指向entry2，同样，entry2也会通过<code>*next</code>指针指向entry3。这样一来，即使哈希桶3中的元素有100个，我们也可以通过entry元素中的指针，把它们连起来。这就形成了一个链表，也叫作哈希冲突链。</p><p><img src=\"https://static001.geekbang.org/resource/image/8a/28/8ac4cc6cf94968a502161f85d072e428.jpg?wh=1233*1093\" alt=\"\"></p><p>但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的Redis来说，这是不太能接受的。</p><p>所以，Redis会对哈希表做rehash操作。rehash也就是增加现有的哈希桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。那具体怎么做呢？</p><p>其实，为了使rehash操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2。一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2并没有被分配空间。随着数据逐步增多，Redis开始执行rehash，这个过程分为三步：</p><ol>\n<li>给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍；</li>\n<li>把哈希表1中的数据重新映射并拷贝到哈希表2中；</li>\n<li>释放哈希表1的空间。</li>\n</ol><p>到此，我们就可以从哈希表1切换到哈希表2，用增大的哈希表2保存更多数据，而原来的哈希表1留作下一次rehash扩容备用。</p><p>这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表1中的数据都迁移完，会造成Redis线程阻塞，无法服务其他请求。此时，Redis就无法快速访问数据了。</p><p>为了避免这个问题，Redis采用了<strong>渐进式rehash</strong>。</p><p>简单来说就是在第二步拷贝数据时，Redis仍然正常处理客户端请求，每处理一个请求时，从哈希表1中的第一个索引位置开始，顺带着将这个索引位置上的所有entries拷贝到哈希表2中；等处理下一个请求时，再顺带拷贝哈希表1中的下一个索引位置的entries。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/73/0c/73fb212d0b0928d96a0d7d6ayy76da0c.jpg?wh=1770*1079\" alt=\"\" title=\"渐进式rehash\"></p><p>这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p><p>好了，到这里，你应该就能理解，Redis的键和值是怎么通过哈希表组织的了。对于String类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的O(1)操作复杂度也就是它的复杂度了。</p><p>但是，对于集合类型来说，即使找到哈希桶了，还要在集合中再进一步操作。接下来，我们来看集合类型的操作效率又是怎样的。</p><h2>集合数据操作效率</h2><p>和String类型不同，一个集合类型的值，第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中再增删改查。那么，集合的操作效率和哪些因素相关呢？</p><p>首先，与集合的底层数据结构有关。例如，使用哈希表实现的集合，要比使用链表实现的集合访问效率更高。其次，操作效率和这些操作本身的执行特点有关，比如读写一个元素的操作要比读写所有元素的效率高。</p><p>接下来，我们就分别聊聊集合类型的底层数据结构和操作复杂度。</p><h3>有哪些底层数据结构？</h3><p>刚才，我也和你介绍过，集合类型的底层数据结构主要有5种：整数数组、双向链表、哈希表、压缩列表和跳表。</p><p>其中，哈希表的操作特点我们刚刚已经学过了；整数数组和双向链表也很常见，它们的操作特征都是顺序读写，也就是通过数组下标或者链表的指针逐个元素访问，操作复杂度基本是O(N)，操作效率比较低；压缩列表和跳表我们平时接触得可能不多，但它们也是Redis重要的数据结构，所以我来重点解释一下。</p><p>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段zlbytes、zltail和zllen，分别表示列表长度、列表尾的偏移量和列表中的entry个数；压缩列表在表尾还有一个zlend，表示列表结束。</p><p><img src=\"https://static001.geekbang.org/resource/image/95/a0/9587e483f6ea82f560ff10484aaca4a0.jpg?wh=1583*315\" alt=\"\"></p><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是O(N)了。</p><p>我们再来看下跳表。</p><p>有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳表在链表的基础上，<strong>增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</strong>，如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/b4/1eca7135d38de2yy16681c2bbc4f3fb4.jpg?wh=1878*1126\" alt=\"\" title=\"跳表的快速查找过程\"></p><p>如果我们要在链表中查找33这个元素，只能从头开始遍历链表，查找6次，直到找到33为止。此时，复杂度是O(N)，查找效率很低。</p><p>为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素1作为一级索引，从第三、四个元素中抽取元素11作为一级索引。此时，我们只需要4次查找就能定位到元素33了。</p><p>如果我们还想再快，可以再增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取1、27、100作为二级索引，二级索引指向一级索引。这样，我们只需要3次查找，就能定位到元素33了。</p><p>可以看到，这个查找过程就是在多级索引上跳来跳去，最后定位到元素。这也正好符合“跳”表的叫法。当数据量很大时，跳表的查找复杂度就是O(logN)。</p><p>好了，我们现在可以按照查找的时间复杂度给这些数据结构分下类了：</p><p><img src=\"https://static001.geekbang.org/resource/image/fb/f0/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg?wh=1332*750\" alt=\"\"></p><h3>不同操作的复杂度</h3><p>集合类型的操作类型很多，有读写单个集合元素的，例如HGET、HSET，也有操作多个元素的，例如SADD，还有对整个集合进行遍历操作的，例如SMEMBERS。这么多操作，它们的复杂度也各不相同。而复杂度的高低又是我们选择集合类型的重要依据。</p><p>我总结了一个“四句口诀”，希望能帮助你快速记住集合常见操作的复杂度。这样你在使用过程中，就可以提前规避高复杂度操作了。</p><ul>\n<li>单元素操作是基础；</li>\n<li>范围操作非常耗时；</li>\n<li>统计操作通常高效；</li>\n<li>例外情况只有几个。</li>\n</ul><p>第一，<strong>单元素操作，是指每一种集合类型对单个数据实现的增删改查操作</strong>。例如，Hash类型的HGET、HSET和HDEL，Set类型的SADD、SREM、SRANDMEMBER等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET和HDEL是对哈希表做操作，所以它们的复杂度都是O(1)；Set类型用哈希表作为底层数据结构时，它的SADD、SREM、SRANDMEMBER复杂度也是O(1)。</p><p>这里，有个地方你需要注意一下，集合类型支持同时对多个元素进行增删改查，例如Hash类型的HMGET和HMSET，Set类型的SADD也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET增加M个元素时，复杂度就从O(1)变成O(M)了。</p><p>第二，<strong>范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据</strong>，比如Hash类型的HGETALL和Set类型的SMEMBERS，或者返回一个范围内的部分数据，比如List类型的LRANGE和ZSet类型的ZRANGE。<strong>这类操作的复杂度一般是O(N)，比较耗时，我们应该尽量避免</strong>。</p><p>不过，Redis从2.8版本开始提供了SCAN系列操作（包括HSCAN，SSCAN和ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于HGETALL、SMEMBERS这类操作来说，就避免了一次性返回所有元素而导致的Redis阻塞。</p><p>第三，统计操作，是指<strong>集合类型对集合中所有元素个数的记录</strong>，例如LLEN和SCARD。这类操作复杂度只有O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</p><p>第四，例外情况，是指某些数据结构的特殊记录，例如<strong>压缩列表和双向链表都会记录表头和表尾的偏移量</strong>。这样一来，对于List类型的LPOP、RPOP、LPUSH、RPUSH这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有O(1)，可以实现快速操作。</p><h2>小结</h2><p>这节课，我们学习了Redis的底层数据结构，这既包括了Redis中用来保存每个键和值的全局哈希表结构，也包括了支持集合类型实现的双向链表、压缩列表、整数数组、哈希表和跳表这五大底层结构。</p><p>Redis之所以能快速操作键值对，一方面是因为O(1)复杂度的哈希表被广泛使用，包括String、Hash和Set，它们的操作复杂度基本由哈希表决定，另一方面，Sorted Set也采用了O(logN)复杂度的跳表。不过，集合类型的范围操作，因为要遍历底层数据结构，复杂度通常是O(N)。这里，我的建议是：<strong>用其他命令来替代</strong>，例如可以用SCAN来代替，避免在Redis内部产生费时的全集合遍历操作。</p><p>当然，我们不能忘了复杂度较高的List类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是O(N)。因此，我的建议是：<strong>因地制宜地使用List类型</strong>。例如，既然它的POP/PUSH效率很高，那么就将它主要用于FIFO队列场景，而不是作为一个可以随机读写的集合。</p><p>Redis数据类型丰富，每个类型的操作繁多，我们通常无法一下子记住所有操作的复杂度。所以，最好的办法就是<strong>掌握原理，以不变应万变</strong>。这里，你可以看到，一旦掌握了数据结构基本原理，你可以从原理上推断不同操作的复杂度，即使这个操作你不一定熟悉。这样一来，你不用死记硬背，也能快速合理地做出选择了。</p><h2>每课一问</h2><p>整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么Redis还会把它们作为底层数据结构呢？</p><p>数据结构是了解Redis性能的必修课，如果你身边还有不太清楚数据结构的朋友，欢迎你把今天的内容分享给他/她，期待你在留言区和我交流讨论。</p>","neighbors":{"left":{"article_title":"01 | 基本架构：一个键值数据库包含什么？","id":268262},"right":{"article_title":"03 | 高性能IO模型：为什么单线程Redis能那么快？","id":270474}},"comments":[{"had_liked":false,"id":239388,"user_name":"Kaito","can_delete":false,"product_type":"c1","uid":1020042,"ip_address":"","ucode":"79775FA35A95F2","user_header":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","comment_is_top":false,"comment_ctime":1596521059,"is_pvip":true,"replies":[{"id":"88806","content":"回答的很好！<br><br>我再提个小问题，如果在数组上是随机访问，对CPU高速缓存还友好不？：）","user_name":"作者回复","comment_id":239388,"uid":"1609687","ip_address":"","utype":1,"ctime":1597015873,"user_name_real":"蒋德钧"}],"discussion_count":44,"race_medal":0,"score":"2011641215587","product_id":100056701,"comment_content":"两方面原因：<br><br>1、内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。Redis是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。<br><br>2、数组对CPU高速缓存支持更友好，所以Redis在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。","like_count":469,"discussions":[{"author":{"id":1103041,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/3E7OHAzCGV5CBPwot4aGIGz8YCk9FtVPdhM0riaoWTFYv5Ef6u15ficS2qx74sIFr6hnJoummia7D7lhne1vkRJ6g/132","nickname":"猫猫","note":"","ucode":"8D39D94B03F583","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359738,"discussion_content":"Redis底层的使用数组和压缩链表对数据大小限制在64个字节以下，当大于64个字节会改变存储数据的数据结构，所以随机访问对于CPU高速缓存没啥影响","likes_number":61,"is_delete":false,"is_hidden":false,"ctime":1616255858,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1103041,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/3E7OHAzCGV5CBPwot4aGIGz8YCk9FtVPdhM0riaoWTFYv5Ef6u15ficS2qx74sIFr6hnJoummia7D7lhne1vkRJ6g/132","nickname":"猫猫","note":"","ucode":"8D39D94B03F583","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365354,"discussion_content":"很棒，减少了随机访问对于CPU高速缓存的影响","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1617781963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":359738,"ip_address":""},"score":365354,"extra":""}]},{"author":{"id":2261175,"avatar":"","nickname":"Geek_b8d5c9","note":"","ucode":"505F33B4C0EA31","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318515,"discussion_content":"随机数据要取决于数组的大小，如果大小刚刚符合了缓存行的64字节的话就不怎么消耗性能","likes_number":42,"is_delete":false,"is_hidden":false,"ctime":1603769973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1102291,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/d3/827cdfd5.jpg","nickname":"Kai","note":"","ucode":"BE6985A02BEA7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2261175,"avatar":"","nickname":"Geek_b8d5c9","note":"","ucode":"505F33B4C0EA31","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341076,"discussion_content":"同意，赞","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610285462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":318515,"ip_address":""},"score":341076,"extra":""}]},{"author":{"id":2250622,"avatar":"https://static001.geekbang.org/account/avatar/00/22/57/7e/453a0db7.jpg","nickname":"大梧桐树","note":"","ucode":"1E910FF0194159","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394731,"discussion_content":"从网上摘取的：\n缓存行 (Cache Line) 便是 CPU Cache 中的最小单位，CPU Cache 由若干缓存行组成，一个缓存行的大小通常是 64 字节（这取决于 CPU），并且它有效地引用主内存中的一块地址。\n你正在遍历一个长度为 16 的 long 数组 data[16]，原始数据自然存在于主内存中，访问过程描述如下：\n\n访问 data[0]，CPU core 尝试访问 CPU Cache，未命中。\n\n尝试访问主内存，操作系统一次访问的单位是一个 Cache Line 的大小 — 64 字节，这意味着：既从主内存中获取到了 data[0] 的值，同时将 data[0] ~ data[7] 加入到了 CPU Cache 之中，for free~\n\n访问 data[1]~data[7]，CPU core 尝试访问 CPU Cache，命中直接返回。\n访问 data[8]，CPU core 尝试访问 CPU Cache，未命中。尝试访问主内存。重复步骤 2","likes_number":38,"is_delete":false,"is_hidden":false,"ctime":1632021349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041396,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","nickname":"宙斯","note":"","ucode":"80DF36BAD298AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334544,"discussion_content":"不友好，随机访问会不仅让高速缓存预读缓存数据失效，且来回写入高速缓存预读数据，反而还降低了读的性能。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1607876126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1002581,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/4c/55/879a4443.jpg","nickname":"greensky01","note":"","ucode":"9C1B0EBFC603D1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305722,"discussion_content":"取决于数组的大小吧，如果整块数组都能塞入缓存，那随机访问也不会影响缓存命中。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1600069574,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1782175,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/31/9f/55052f1e.jpg","nickname":"你是猪嘛","note":"","ucode":"CB78CA5137CE9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387861,"discussion_content":"CPU缓存行的大小是64字节，和Redis使用数组和压缩列表要求的一致，对Redis影响不大","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1628476307,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1411096,"avatar":"https://static001.geekbang.org/account/avatar/00/15/88/18/9744d5ec.jpg","nickname":"小超人","note":"","ucode":"0D8A433F3E3737","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":339189,"discussion_content":"数组的随机访问， 如果命令 CPU 的缓存那还算是友好的； 如果没有命中缓存， 那是不友好的并且还会浪费 cpu 预加载的操作。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1609557844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2056483,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/61/23/c8d86dc3.jpg","nickname":"不曾离去♚","note":"","ucode":"2D4678651CCD59","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":320502,"discussion_content":"CPU 的高速缓存依据是局部性原理，随机访问可能会降低","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1604384713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308011,"discussion_content":"随机访问对cpu可能没有那么友好了，cpu缓存是以缓存行组成的，每个缓存行通常是64字节。如果随机访问，可能就用不到加载到缓存的缓存行数据了，这时候就会将目标数据以及其相近的数据自动加载进缓存。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1600826097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254656,"avatar":"https://static001.geekbang.org/account/avatar/00/13/25/00/3afbab43.jpg","nickname":"88591","note":"","ucode":"04CE3E46455185","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":392345,"discussion_content":"数据量小的时候，比如小于64B，数组的内存空间比链表更少，少一些链表指针的存储，数据量小的情况，O（n）与O（1）查询时间可以忽略不计。还有缓存行的加持数据效率更高了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1630977365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2184325,"avatar":"https://static001.geekbang.org/account/avatar/00/21/54/85/ab5148ce.jpg","nickname":"duckman","note":"","ucode":"0184C26C4B6C1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306645,"discussion_content":"还是友好的，这里数组都比较小，长度都是2的倍数，也是为了对齐高速缓存","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1600339570,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503090,"discussion_content":"回答的很好！\n\n我再提个小问题，如果在数组上是随机访问，对CPU高速缓存还友好不？：）","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597015873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":3,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1000441,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/43/f9/723ee153.jpg","nickname":"wessonwang","note":"","ucode":"A9BA5E3A3F278E","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":534281,"discussion_content":"取决于数组大小了，如果数据空间小于CPU L1 cache，还是友好的；否则就不友好了，涉及cache line 淘汰和更新了。","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1638154825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":503090,"ip_address":""},"score":534281,"extra":""}]},{"author":{"id":1030544,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b9/90/abb7bfe3.jpg","nickname":"A 付李珏","note":"","ucode":"970D6EF916D6B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302553,"discussion_content":"压缩列表不支持随机访问，如果随机访问，是不是类似于链表的随机访问，在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598952923,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299507,"discussion_content":"针对老师这个小问题，数组不就是随机访问佳吗？求解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597719187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":7,"child_discussions":[{"author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301075,"discussion_content":"数组随机访问佳指的是当你使用数组下标进行随机访问时，时间复杂度是O(1)，但是对于Redis的k-v来说，要拿数组的元素去进行比较，这个比较只能逐个比较查找，因此就是O(n)了。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1598402483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299507,"ip_address":""},"score":301075,"extra":""},{"author":{"id":1116257,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/61/9e0f8b8d.jpg","nickname":"金鑫","note":"","ucode":"8AA30E8DD736FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304412,"discussion_content":"看了一遍还是没看懂...","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1599568278,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301075,"ip_address":""},"score":304412,"extra":""},{"author":{"id":2052521,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/51/a9/741b5ad9.jpg","nickname":"FD","note":"","ucode":"ED396BD322489E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1116257,"avatar":"https://static001.geekbang.org/account/avatar/00/11/08/61/9e0f8b8d.jpg","nickname":"金鑫","note":"","ucode":"8AA30E8DD736FB","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309270,"discussion_content":"你要访问a[i]肯定是随机访问。你要知道那个数组的第几个元素等于i，就得从第一个元素开始比较了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1601249055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304412,"ip_address":""},"score":309270,"extra":""}]},{"author":{"id":2055809,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/5e/81/82709d6e.jpg","nickname":"码小呆","note":"","ucode":"44532D6ABF9340","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573492,"discussion_content":"学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653465758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569281,"discussion_content":"压缩列表转换阈值设定就是一个缓存行 可见一个缓存行内的数据 可以一次灌入cpu多级缓存。虽然三级缓存普遍是在总线一侧 但这个数量级对于民用领域其实无感。\n\n再谈谈整形数组 set里面通常是两类数据 一类是int或是一个标准机器字 另一类是string。string类型因为天生无法确定其字节数 所以只能退化到hash来表示。但是int数组可以使用局部性原理来做适当加速。 \n比方说 仍然以一个缓存行来说 64 byte / 4 = 16. 我们可以在设计时 以16个为单位来设计我们的set","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651393117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227366,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ba/66/7d9f45e7.jpg","nickname":"太空牛仔","note":"","ucode":"0205635C3854AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544957,"discussion_content":"链表的内存利用率没有数组高？我觉得只是因为cpu缓存友好的原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641791003,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2455765,"avatar":"https://static001.geekbang.org/account/avatar/00/25/78/d5/256d9a90.jpg","nickname":"丶","note":"","ucode":"E58127DDC683B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375228,"discussion_content":"老哥，我想问一下，数组对cpu的高速缓存更加友好是什么意思？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621520578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":6,"child_discussions":[{"author":{"id":1236971,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/eb/0e741729.jpg","nickname":"holyman","note":"","ucode":"65C02E95ED211C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2455765,"avatar":"https://static001.geekbang.org/account/avatar/00/25/78/d5/256d9a90.jpg","nickname":"丶","note":"","ucode":"E58127DDC683B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375282,"discussion_content":"1. 数组是一段连续的内存空间  2. 局部性原理","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1621562390,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375228,"ip_address":""},"score":375282,"extra":""},{"author":{"id":2082118,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/P1y2k6dcoAWtlXkMcKFGeAmykTKCOKEicKsN0TX4eT6icibATfqnlsDyjicfjvo1zAa9lAS4ZGkSEGjeUUUmy9Qofg/132","nickname":"xyy_Li","note":"","ucode":"81A647AB5F757A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1236971,"avatar":"https://static001.geekbang.org/account/avatar/00/12/df/eb/0e741729.jpg","nickname":"holyman","note":"","ucode":"65C02E95ED211C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386203,"discussion_content":"数组为什么会比链表占用的空间小啊。链表存储不用连续的内存这样可以用上零碎的内存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627466040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":375282,"ip_address":""},"score":386203,"extra":""},{"author":{"id":1473744,"avatar":"https://static001.geekbang.org/account/avatar/00/16/7c/d0/eec67c84.jpg","nickname":"Noah","note":"","ucode":"30748FB1FFB4AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2082118,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/P1y2k6dcoAWtlXkMcKFGeAmykTKCOKEicKsN0TX4eT6icibATfqnlsDyjicfjvo1zAa9lAS4ZGkSEGjeUUUmy9Qofg/132","nickname":"xyy_Li","note":"","ucode":"81A647AB5F757A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387391,"discussion_content":"额外的指针会占据内存空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628148080,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":386203,"ip_address":""},"score":387391,"extra":""}]},{"author":{"id":1114058,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ff/ca/f14f3df1.jpg","nickname":"水梦星光","note":"","ucode":"35F87B69E15CAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351444,"discussion_content":"随机会造成CPU高速缓存整个缓存行失效，命中率极度降低","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614267524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1180553,"avatar":"https://static001.geekbang.org/account/avatar/00/12/03/89/e1621a01.jpg","nickname":"zhangtnty","note":"","ucode":"3C9A14BD7CF432","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302685,"discussion_content":"如果数组排序 CPU缓存还可行，不排序并随机访问则缓存会差很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599009236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1388092,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2e/3c/eae43616.jpg","nickname":"sid","note":"","ucode":"3D1F9169A19D29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300802,"discussion_content":"造成的内存碎片也更少吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598268309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1781893,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/30/85/14c2f16c.jpg","nickname":"石小","note":"","ucode":"4258C686F289A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300378,"discussion_content":"那就没那么友好了，因为缓存行可能失效","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598070957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1029749,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b6/75/32c19395.jpg","nickname":"土豆白菜","note":"","ucode":"D1551C729D33E0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298022,"discussion_content":"兄弟 你真棒","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597146609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296858,"discussion_content":"一种数据类型和基础数据结构的关系是固定的，还是说是可变化的，这种转化过程又是基于什么样的原则去实现的呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596689147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":297053,"discussion_content":"看文章里的图，一种大类型对应下面多种数据结构的实现。转换规则是基于一个key的数据大小和元素个数，配置文件中可配。","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1596762346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296858,"ip_address":""},"score":297053,"extra":""},{"author":{"id":1101483,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ce/ab/e9d7811f.jpg","nickname":"shawn","note":"","ucode":"9AF400BBF2E264","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":542139,"discussion_content":"这种数据结构的改变，对性能影响大不大？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640670662,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297053,"ip_address":""},"score":542139,"extra":""}]},{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296430,"discussion_content":"那这种底层数据结构的转换过程，是否会影响到redis的读写性能呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596540846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":4,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1020042,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/8a/288f9f94.jpg","nickname":"Kaito","note":"","ucode":"79775FA35A95F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296452,"discussion_content":"因为都是在内存中操作，而且转换的阈值并不高，所以性能不会受到影响。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1596545725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296430,"ip_address":""},"score":296452,"extra":""}]}]},{"had_liked":false,"id":243864,"user_name":"注定非凡","can_delete":false,"product_type":"c1","uid":1113597,"ip_address":"","ucode":"80673056E131B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","comment_is_top":false,"comment_ctime":1598316077,"is_pvip":true,"discussion_count":23,"race_medal":0,"score":"1878499024429","product_id":100056701,"comment_content":"一，作者讲了什么？<br>    1，Redis的底层数据结构<br><br>二，作者是怎么把这事给讲明白的？<br>    1，讲了Redis的数据结构：数据的保存形式与底层数据结构<br>    2，由数据结构的异同点，引出数据操作的快慢原因<br>    <br>三，为了讲明白，作者讲了哪些要点？有哪些亮点？<br>    1，亮点1：string，list，set，hast,sortset都只是数据的保存形式，底层的数据结构是：简单动态字符串，双向链表，压缩列表，哈希表，跳表，整数数组<br>    2，亮点2：Redis使用了一个哈希表保存所有的键值对<br>    3，要点1：五种数据形式的底层实现<br>            a，string：简单动态字符串<br>            b，list：双向链表，压缩列表<br>            c，hash：压缩列表，哈希表<br>            d，Sorted Set：压缩列表，跳表<br>            e，set：哈希表，整数数组<br>    4，要点2：List ,hash，set ,sorted set被统称为集合类型，一个键对应了一个集合的数据<br>    5，要点3：集合类型的键和值之间的结构组织<br>            a：Redis使用一个哈希表保存所有键值对，一个哈希表实则是一个数组，数组的每个元素称为哈希桶。<br>            b：哈希桶中的元素保存的不是值的本身，而是指向具体值的指针<br>    6，要点4：哈希冲突解决<br>            a：Redis的hash表是全局的，所以当写入大量的key时，将会带来哈希冲突，已经rehash可能带来的操作阻塞<br>            b：Redis解决hash冲突的方式，是链式哈希：同一个哈希桶中的多个元素用一个链表来保存<br>            c：当哈希冲突链过长时，Redis会对hash表进行rehash操作。rehash就是增加现有的hash桶数量，分散entry元素。<br>    7，要点5：rehash机制<br>            a：为了使rehash操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2，起始时hash2没有分配空间<br>            b：随着数据增多，Redis执行分三步执行rehash;<br>                1，给hash2分配更大的内存空间，如是hash1的两倍<br>                2，把hash1中的数据重新映射并拷贝到哈希表2中<br>                3，释放hash1的空间<br>    8，要点6：渐进式rehash<br>            a：由于步骤2重新映射非常耗时，会阻塞redis<br>            b：讲集中迁移数据，改成每处理一个请求时，就从hash1中的第一个索引位置，顺带将这个索引位置上的所有entries拷贝到hash2中。<br>    9，要点7 ：压缩列表，跳表的特点<br>            a：压缩列表类似于一个数组，不同的是:压缩列表在表头有三个字段zlbytes,zltail和zllen分别表示长度，列表尾的偏移量和列表中的entry的个数，压缩列表尾部还有一个zlend，表示列表结束<br>                所以压缩列表定位第一个和最后一个是O(1),但其他就是O(n)<br>            b：跳表：是在链表的基础上增加了多级索引，通过索引的几次跳转，实现数据快速定位<br><br>四，对于作者所讲，我有哪些发散性思考？<br><br>五，在将来的哪些场景中，我能够用到它？<br><br>六，评论区收获<br>    1，数组和压缩列表可以提升内存利用率，因为他们的数据结构紧凑<br>    2，数组对CPU高速缓存支持友好，当数据元素超过阈值时，会转为hash和跳表，保证查询效率","like_count":438,"discussions":[{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312318,"discussion_content":"rehash讲得不对，redis为了减少阻塞，用的是渐进式rehash，为了使用scan命令，扩容时用的是高位加法排序。\nlist用的是压缩列表和快速列表，快速列表是把压缩列表作为元素的双向链表。\n可能作者觉得这一部分太简单了，没细讲。但是我觉得这一部分其实蛮重要的，最好找本书详细看看。","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1602661323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1113597,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fd/fd/326be9bb.jpg","nickname":"注定非凡","note":"","ucode":"80673056E131B7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312388,"discussion_content":"嗯嗯，多谢指点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602675242,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312318,"ip_address":""},"score":312388,"extra":""},{"author":{"id":1029532,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/GicvRPEGZhqEqRU5wUiaZLT7lXFpzHZ9Y0knJsM7Pq66AhDmDfrQJLQNXcBG8ib9utIibkO4NVeUrFP3R9tvZD7b8A/132","nickname":"海贼王","note":"","ucode":"959C274A5E0E8B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326560,"discussion_content":"有没有推荐的书","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605617299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312318,"ip_address":""},"score":326560,"extra":""},{"author":{"id":1277081,"avatar":"https://static001.geekbang.org/account/avatar/00/13/7c/99/4dac6ce6.jpg","nickname":"lakeslove","note":"","ucode":"65E14D29D3C981","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1029532,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/GicvRPEGZhqEqRU5wUiaZLT7lXFpzHZ9Y0knJsM7Pq66AhDmDfrQJLQNXcBG8ib9utIibkO4NVeUrFP3R9tvZD7b8A/132","nickname":"海贼王","note":"","ucode":"959C274A5E0E8B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":326899,"discussion_content":"redis深度历险","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605695959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":326560,"ip_address":""},"score":326899,"extra":""}]},{"author":{"id":1275195,"avatar":"https://static001.geekbang.org/account/avatar/00/13/75/3b/81347305.jpg","nickname":"。。。","note":"","ucode":"5DF06A3AC179DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306925,"discussion_content":"笔记太多等于没有笔记","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1600419489,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1998835,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/7f/f3/010d9634.jpg","nickname":"Owen Zhang","note":"","ucode":"48D2063B87AD8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1275195,"avatar":"https://static001.geekbang.org/account/avatar/00/13/75/3b/81347305.jpg","nickname":"。。。","note":"","ucode":"5DF06A3AC179DD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308056,"discussion_content":"佛系 佛系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600832900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306925,"ip_address":""},"score":308056,"extra":""},{"author":{"id":1444122,"avatar":"https://static001.geekbang.org/account/avatar/00/16/09/1a/e0f95684.jpg","nickname":"空空","note":"","ucode":"8F6EFE5A6F6F64","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1275195,"avatar":"https://static001.geekbang.org/account/avatar/00/13/75/3b/81347305.jpg","nickname":"。。。","note":"","ucode":"5DF06A3AC179DD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310166,"discussion_content":"只能说干货太多了，兄弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601652051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":306925,"ip_address":""},"score":310166,"extra":""}]},{"author":{"id":2377406,"avatar":"","nickname":"杨毅","note":"","ucode":"189923D892549F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341829,"discussion_content":"兄弟， 挺狠啊","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1610532993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2144915,"avatar":"https://static001.geekbang.org/account/avatar/00/20/ba/93/7d58263a.jpg","nickname":"梦之光","note":"","ucode":"2E808240409BDD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391241,"discussion_content":"最强课代表，求学应有的态度","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1630370450,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2739957,"avatar":"","nickname":"Geek_39299b","note":"","ucode":"908C2FC4DECD33","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389666,"discussion_content":"非凡哥 刚从kafka 那里就见到你了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629370337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2392576,"avatar":"https://static001.geekbang.org/account/avatar/00/24/82/00/07d9534a.jpg","nickname":"Twilight","note":"","ucode":"B0C50F97EB8745","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380685,"discussion_content":"课代表👍","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1624632716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1534892,"avatar":"https://static001.geekbang.org/account/avatar/00/17/6b/ac/514dd75b.jpg","nickname":"java劝退师首席大弟子","note":"","ucode":"3FEDCCE50FC184","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365556,"discussion_content":"班长","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617841944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155586,"avatar":"https://static001.geekbang.org/account/avatar/00/11/a2/02/a44d512e.jpg","nickname":"zzzzz","note":"","ucode":"FB12EF8B8C3888","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548098,"discussion_content":"顿时觉得不看评论的话损失惨重","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643028517,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2113750,"avatar":"https://static001.geekbang.org/account/avatar/00/20/40/d6/5bd03463.jpg","nickname":"Mr.L","note":"","ucode":"052D6042B25CD4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":412797,"discussion_content":"最强课代表，6666","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636292386,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1458200,"avatar":"https://static001.geekbang.org/account/avatar/00/16/40/18/cc3804e2.jpg","nickname":"沈洪彬","note":"","ucode":"F9911236D0BA1C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387100,"discussion_content":"词穷，只能用NB形容","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627984763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1193708,"avatar":"https://static001.geekbang.org/account/avatar/00/12/36/ec/ca162d6b.jpg","nickname":"sam3125C","note":"","ucode":"D725AEF2A1F47C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370947,"discussion_content":"建议思维导图一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619589775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253310,"avatar":"https://static001.geekbang.org/account/avatar/00/13/1f/be/551454e0.jpg","nickname":"zxy","note":"","ucode":"FFAA3F6667305D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358911,"discussion_content":"到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616074424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031038,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bb/7e/32734996.jpg","nickname":"得志","note":"","ucode":"673B8BA8958E1C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321250,"discussion_content":"总结到位","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604553692,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1025239,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","nickname":"Aliliin","note":"","ucode":"61F9A09BB6650F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311766,"discussion_content":"大佬太厉害了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602485369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1478744,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqUFIdvPmg4icaph0XhzzQUiaLDHuStPozANRWhZAjA5gA916CBpshsqVuDVWH0fpW7icb7zUo0EL6VA/132","nickname":"Geek_4f0226","note":"","ucode":"5B15CC8482C99D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310815,"discussion_content":"非常棒，看了一半没看懂，看留言正好有个概括，加深理解。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602056356,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1192724,"avatar":"https://static001.geekbang.org/account/avatar/00/12/33/14/78104f1f.jpg","nickname":"Just Do IT","note":"","ucode":"1EAD92510FA7BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309964,"discussion_content":"太好了  支持","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601543852,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242768,"user_name":"我的黄金时代","can_delete":false,"product_type":"c1","uid":1062070,"ip_address":"","ucode":"D7825B45B372F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","comment_is_top":false,"comment_ctime":1597836547,"is_pvip":false,"discussion_count":7,"race_medal":0,"score":"435389533443","product_id":100056701,"comment_content":"来自互联网 ：因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。<br>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。","like_count":101,"discussions":[{"author":{"id":2853618,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/8a/f2/6c6f7886.jpg","nickname":"。。","note":"","ucode":"A52A6043D27D87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576000,"discussion_content":"对于渐进式这块，不太理解，它不会造成两个哈希表数据不一致吗，例如新增操作，如果直接在 ht[1] 中新增，可能会导致 ht[0]、ht[1] 中数据不一致（ht[1] 中新增了一个跟 ht[0] 相同的 key 的数据），所以新增操作是不是应该先在 ht[0] 中找，如果有的话删除、或者修改 key，然后再在 ht[1] 中新增呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655221051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2172420,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/r2nR7Zkl5RP7LobsNKJ6wmmtyXrh4alNSAOldx1y1PSeFB1J2I14HE4I0BCgicPhubIOibPZAENzEpHEWTFjMNqg/132","nickname":"董董","note":"","ucode":"C222E275545158","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":539811,"discussion_content":"查找的请求会将数据迁移到hash2中么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1639846343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1272026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/da/5bcb83b1.jpg","nickname":"白晨","note":"","ucode":"6D6171B8ECEDDD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2172420,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/r2nR7Zkl5RP7LobsNKJ6wmmtyXrh4alNSAOldx1y1PSeFB1J2I14HE4I0BCgicPhubIOibPZAENzEpHEWTFjMNqg/132","nickname":"董董","note":"","ucode":"C222E275545158","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544824,"discussion_content":"应该不会了吧，这样不是很乱？插入的时候才会做这个操作吧，因为插入才会导致数据量变大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641725234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":539811,"ip_address":""},"score":544824,"extra":""}]},{"author":{"id":1221664,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a4/20/dd6f568c.jpg","nickname":"红糖白糖","note":"","ucode":"C6415C57AD6FF4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536655,"discussion_content":"nice","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638841979,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2544946,"avatar":"","nickname":"Geek_e74c15","note":"","ucode":"DC678F5A987D9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376242,"discussion_content":"完美解答了我的疑虑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622035462,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2109853,"avatar":"","nickname":"beifengzhishen001","note":"","ucode":"77D42B7DD9E754","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368748,"discussion_content":"很好的回答了我的疑惑，我还在想一个桶本来已经rehash了再有新增的entry该怎么办","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618822634,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438422,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/jgEicJMDKtww4iayMAw247KHwX2N4g5xoGrW5pjVsgJhpibFgs79uVibjOTVuo1ia17XHyHzlk4xvJSP2OCE0AD14xg/132","nickname":"Geek_8b8d3d","note":"","ucode":"9E308F95A5F748","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":367162,"discussion_content":"完美的解答了我的疑问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618280763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243733,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1598259956,"is_pvip":false,"replies":[{"id":"89862","content":"渐进式rehash执行时，除了根据键值对的操作来进行数据迁移，Redis本身还会有一个定时任务在执行rehash，如果没有键值对操作时，这个定时任务会周期性地（例如每100ms一次）搬移一些数据到新的哈希表中，这样可以缩短整个rehash的过程。","user_name":"作者回复","comment_id":243733,"uid":"1609687","ip_address":"","utype":1,"ctime":1598400358,"user_name_real":"蒋德钧"}],"discussion_count":8,"race_medal":0,"score":"396735251188","product_id":100056701,"comment_content":"同问  老师  如果渐进式哈希操作  如果有一个value操作很长时间段都没被查到  那渐进式哈希会持续非常长的时间吗   还是会在空闲的时候  也给挪到扩容的hash表里面","like_count":92,"discussions":[{"author":{"id":1333763,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5a/03/a8398985.jpg","nickname":"王文博","note":"","ucode":"E79E90B9547DD1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312456,"discussion_content":"不管key哈希到哪个entry上 渐进式哈希都是从entry0开始依次把 entry同步到新哈希表，同步哪个entry跟key所在entry没有关系","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1602689180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1024726,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a2/d6/97370dfc.jpg","nickname":"onno","note":"","ucode":"FB7E829037DA10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1333763,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5a/03/a8398985.jpg","nickname":"王文博","note":"","ucode":"E79E90B9547DD1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398141,"discussion_content":"我记得也是这样，每次进行rehash会有一个index从0开始进行数据迁移，每次操作都会进行迁移，从index位置开启，index递增，直到把ht[1]迁移完","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1632743888,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312456,"ip_address":""},"score":398141,"extra":""},{"author":{"id":1024726,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a2/d6/97370dfc.jpg","nickname":"onno","note":"","ucode":"FB7E829037DA10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1333763,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5a/03/a8398985.jpg","nickname":"王文博","note":"","ucode":"E79E90B9547DD1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":398142,"discussion_content":"说错了，把ht[0]迁移完，然后把h[1]变成h[0]","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1632743950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312456,"ip_address":""},"score":398142,"extra":""},{"author":{"id":1227366,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ba/66/7d9f45e7.jpg","nickname":"太空牛仔","note":"","ucode":"0205635C3854AF","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1333763,"avatar":"https://static001.geekbang.org/account/avatar/00/14/5a/03/a8398985.jpg","nickname":"王文博","note":"","ucode":"E79E90B9547DD1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":544958,"discussion_content":"根本没看人家在问啥","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641791128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":312456,"ip_address":""},"score":544958,"extra":""}]},{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504377,"discussion_content":"渐进式rehash执行时，除了根据键值对的操作来进行数据迁移，Redis本身还会有一个定时任务在执行rehash，如果没有键值对操作时，这个定时任务会周期性地（例如每100ms一次）搬移一些数据到新的哈希表中，这样可以缩短整个rehash的过程。","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1598400358,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/dc/37dac825.jpg","nickname":"阿豪","note":"","ucode":"AF3CB1CE262CEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414316,"discussion_content":"有个问题，rehash过程中还有写入的数据会怎么处理","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636719280,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2911084,"avatar":"https://static001.geekbang.org/account/avatar/00/2c/6b/6c/3e80afaf.jpg","nickname":"HappyHasson","note":"","ucode":"B84CC43E349CFA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1099484,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c6/dc/37dac825.jpg","nickname":"阿豪","note":"","ucode":"AF3CB1CE262CEA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552333,"discussion_content":"写操作只写新hash结构就是hash[1]，读是双读","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645417686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":414316,"ip_address":""},"score":552333,"extra":""}]},{"author":{"id":1129317,"avatar":"https://static001.geekbang.org/account/avatar/00/11/3b/65/203298ce.jpg","nickname":"小名叫大明","note":"","ucode":"4804D68A396B40","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318735,"discussion_content":"补充知识","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603820226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239160,"user_name":"不能扮演天使","can_delete":false,"product_type":"c1","uid":1046172,"ip_address":"","ucode":"9922330BFF7FFB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f6/9c/b457a937.jpg","comment_is_top":false,"comment_ctime":1596449723,"is_pvip":false,"replies":[{"id":"88618","content":"赞！所以不同的设计选择都是有背后的考虑。","user_name":"作者回复","comment_id":239160,"uid":"1609687","ip_address":"","utype":1,"ctime":1596726041,"user_name_real":"蒋德钧"}],"discussion_count":5,"race_medal":0,"score":"302244160443","product_id":100056701,"comment_content":"Redis的List底层使用压缩列表本质上是将所有元素紧挨着存储，所以分配的是一块连续的内存空间，虽然数据结构本身没有时间复杂度的优势，但是这样节省空间而且也能避免一些内存碎片；","like_count":70,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503002,"discussion_content":"赞！所以不同的设计选择都是有背后的考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596726041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2419770,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ec/3a/75bc138d.jpg","nickname":"Saitama","note":"","ucode":"94735DA32C22B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343753,"discussion_content":"List元素少的时候用压缩列表，元素多的时候用链表，是这样吗","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1611147146,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1649057,"avatar":"https://static001.geekbang.org/account/avatar/00/19/29/a1/41607383.jpg","nickname":"hello","note":"","ucode":"4F42DAA5DB5C38","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2419770,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ec/3a/75bc138d.jpg","nickname":"Saitama","note":"","ucode":"94735DA32C22B1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369675,"discussion_content":"我也有同样的疑问，既然各种集合操作都有两种类型的数据结构，那么他们在什么时候相互切换呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619111854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343753,"ip_address":""},"score":369675,"extra":""}]},{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372606,"discussion_content":"因为按照一个cache line加载进cpu cache 按照当代cpu指令周期来看随机遍历的花销可以忽略不计。但是当一个缓存行无法加载完ziplist时 因为redis内部hash存储的是指针 也就是逻辑成环 所以cpu加载开销就无法忽视。此时只能转别的数据结构来解决 比方说skiplist","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1620391729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1879262,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ac/de/68f35320.jpg","nickname":"小来子","note":"","ucode":"4EDAF31E43B211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334411,"discussion_content":"所以 文章不提这点就离谱\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1607842425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239855,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1596678382,"is_pvip":false,"replies":[{"id":"88808","content":"看得非常仔细，赞一个！<br><br>zset有个ZSCORE的操作，用于返回单个集合member的分数，它的操作复杂度是O(1)，这就是收益于你这看到的hash table。这个hash table保存了集合元素和相应的分数，所以做ZSCORE操作时，直接查这个表就可以，复杂度就降为O(1)了。<br><br>而跳表主要服务范围操作，提供O(logN)的复杂度。","user_name":"作者回复","comment_id":239855,"uid":"1609687","ip_address":"","utype":1,"ctime":1597016459,"user_name_real":"蒋德钧"}],"discussion_count":4,"race_medal":1,"score":"220640010478","product_id":100056701,"comment_content":"请问老师关于zset的问题，您在文中提到Sorted Set内部实现数据结构是跳表和压缩列表。但是我从zset代码看到这样的注释<br>The elements are added to a hash table mapping Redis objects to scores. At the same time the elements are added to a skip list mapping scores to Redis objects <br>按照注释应该还有hash table来额外存储数据吧，这样在zset里查找单个元素，可以从O(logN)降低为O(1)。不知道我理解的是否正确？","like_count":51,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503249,"discussion_content":"看得非常仔细，赞一个！\n\nzset有个ZSCORE的操作，用于返回单个集合member的分数，它的操作复杂度是O(1)，这就是收益于你这看到的hash table。这个hash table保存了集合元素和相应的分数，所以做ZSCORE操作时，直接查这个表就可以，复杂度就降为O(1)了。\n\n而跳表主要服务范围操作，提供O(logN)的复杂度。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597016459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024726,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a2/d6/97370dfc.jpg","nickname":"onno","note":"","ucode":"FB7E829037DA10","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":537030,"discussion_content":"。。。主要是在源码解析课程里也没有把dict挂到sorted set里，其实这个还是挺重要的，因为有时候面试会问这个问题，一般会回答跳表或者压缩链表。然后会问你如果是跳表的话,zscore时间复杂度是多少，如果不知道这个，会掉入陷阱里","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1638936860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1645430,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKiauonyMORA2s43W7mogGDH4WYjW0gBJtYmUa9icTB6aMPGqibicEKlLoQmLKLWEctwHzthbTZkKR20w/132","nickname":"Spring4J","note":"","ucode":"06F056085A2564","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549365,"discussion_content":"照这个注释，应该是同时使用两个数据结构各自保存了一份数据。哈希表保存member跟score的对应关系，跳表保存score跟member的对应关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643891604,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316682,"avatar":"https://static001.geekbang.org/account/avatar/00/14/17/4a/d8fd5563.jpg","nickname":"记忆","note":"","ucode":"503DBE662BF544","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305704,"discussion_content":"我也有这个疑问，感觉老师应该把图画的更细一点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600063925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267701,"user_name":"宙斯","can_delete":false,"product_type":"c1","uid":2041396,"ip_address":"","ucode":"80DF36BAD298AD","user_header":"https://static001.geekbang.org/account/avatar/00/1f/26/34/891dd45b.jpg","comment_is_top":false,"comment_ctime":1607876973,"is_pvip":true,"replies":[{"id":"97904","content":"这个全局是指Redis数据库中的所有key和value，是由一个哈希表来索引的。通过在这个哈希表中查询key，就可以找到对应的value。然后根据value的具体类型（例如Hash，Set，List等），再通过value的底层数据结构来读取具体的value数据，例如List通过双向链表来读取数据。","user_name":"作者回复","comment_id":267701,"uid":"1609687","ip_address":"","utype":1,"ctime":1608974880,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"108982059373","product_id":100056701,"comment_content":"老师你好，hash表是全局的，这里的全局怎样理解？是‘存放key的数组全局只有一个‘是这样理解吗？","like_count":25,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511716,"discussion_content":"这个全局是指Redis数据库中的所有key和value，是由一个哈希表来索引的。通过在这个哈希表中查询key，就可以找到对应的value。然后根据value的具体类型（例如Hash，Set，List等），再通过value的底层数据结构来读取具体的value数据，例如List通过双向链表来读取数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608974880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239167,"user_name":"刘忽悠","can_delete":false,"product_type":"c1","uid":1252173,"ip_address":"","ucode":"095DE3A8D3F450","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/4d/2cc44d9a.jpg","comment_is_top":false,"comment_ctime":1596450946,"is_pvip":true,"replies":[{"id":"88619","content":"dict的渐进式rehash是为了避免扩容时的整体拷贝，这会给内存带来较大压力。<br><br>SDS我们后面还会再聊：）","user_name":"作者回复","comment_id":239167,"uid":"1609687","ip_address":"","utype":1,"ctime":1596726209,"user_name_real":"蒋德钧"}],"discussion_count":2,"race_medal":0,"score":"91790764162","product_id":100056701,"comment_content":"redis底层的数据压缩搞的很细致，像sds，根据字节长度划分的很细致，另外采用的c99特性的动态数组，对短字符串进行一次性的内存分配；跳表设计的也很秀，简单明了，进行范围查询很方便；dict的扩容没细看，但是看了一下数据结构，应该是为了避免发生扩容的时候出现整体copy；<br>个人觉得老师应该把sds，dict等具体数据结构的源码也贴上","like_count":21,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503006,"discussion_content":"dict的渐进式rehash是为了避免扩容时的整体拷贝，这会给内存带来较大压力。\n\nSDS我们后面还会再聊：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596726209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296428,"discussion_content":"之前看过《Redis设计与实现》这本书，对底层实现做了源码级的介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596540549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239505,"user_name":"米 虫","can_delete":false,"product_type":"c1","uid":1073087,"ip_address":"","ucode":"6F35AA8BB8195B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/bf/4bd3eb4b.jpg","comment_is_top":false,"comment_ctime":1596551457,"is_pvip":false,"replies":[{"id":"88567","content":"我们后面的课程会涉及这个过程，再耐心等等哈","user_name":"作者回复","comment_id":239505,"uid":"1609687","ip_address":"","utype":1,"ctime":1596674615,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"78905962785","product_id":100056701,"comment_content":"要是加餐中来一偏，一个redis指令的执行过程，那大局观就更深刻了。","like_count":18,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503122,"discussion_content":"我们后面的课程会涉及这个过程，再耐心等等哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596674615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241368,"user_name":"牛牛","can_delete":false,"product_type":"c1","uid":1194626,"ip_address":"","ucode":"CFCE68B4F92209","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg","comment_is_top":false,"comment_ctime":1597280726,"is_pvip":false,"discussion_count":11,"race_medal":0,"score":"61726822870","product_id":100056701,"comment_content":"老师、早安, <br>今天的问题 @Kaito 同学回答的很好、尝试回答下: 数组上随机访问是否对cpu缓存友好 ?<br><br>数组对cpu缓存友好的原因是: cpu预读取一个cache line大小的数据, 数组数据排列紧凑、相同大小空间保存的元素更多, 访问下一个元素时、恰好已经在cpu缓存了. 如果是随机访问、就不能充分利用cpu缓存了, 拿int元素举例: 一个元素4byte, CacheLine 假设64byte, 可以预读取 16个挨着的元素, 如果下次随机访问的元素不在这16个元素里、就需要重新从内存读取了.<br><br><br>想请教几个问题:<br><br>1. rehash是将访问元素所在索引位置上的所有entries都 copy 到 hash表2 ?<br>   如果有索引位置一直没访问到、它会一直留着 hash表1 中 ？<br>   如果是, 再次rehash时这部分没被挪走的索引位置怎么处理 ?<br>   如果不是、那什么时候(时机)触发这部分位置的rehash呢 ?<br><br>2. rehash过程中、内存占用会多于原所占内存的2倍 ?<br>   (ht2的内存是ht1的2倍, 原ht1的空间还未释放)<br>   我记得redis设计实现上说 ht2的内存会与ht1实际使用的键值对的数量有关, 扩容好像是 &gt;= ht1.used * 2 的第一个 2^n; 缩容好像是 &gt;= ht1.used 的第一个 2^n<br>   <br>3. rehash完成之后, hash表1 留作下次rehash备用、但会把占用的内存释放掉, 这么理解对不 ？<br><br>4. rehash时 为什么是 `复制`, 而不是 `移动`, 这个是有什么考虑吗 ？<br>   我的理解: 移动需要释放原空间, 每个元素都单独释放会导致大量的碎片内存、多次释放也比一次释放效率更低. 不知道是不是考虑错了~~~<br>   ","like_count":14,"discussions":[{"author":{"id":2062818,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7UJwSjHWKYOwnAYjjiaNBob396XaIqmttnHKuM7ahBu19QCn1mNicrg24nKgzA2kttP8tpV466anzMjMxq8Sx3Lw/132","nickname":"Solokat","note":"","ucode":"56BAA66C408D73","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300485,"discussion_content":"试着回答：\n首先，全局哈希表的扩容，是指表本身的扩容，并不涉及表中指向的数据扩容（数据占大量内存空间）。\n\nrehash的过程中，其实并没有发生数据的copy，而是移动，因为所有的操作都是指针。例如，原来在全局哈希表1的哈希桶1的数据（ENTRY），移动的时候，只需通过新的hash计算，然后将其地址赋给全局哈希表2的相应哈希桶，例如哈希桶5，即可，\n\n故，问题2，不会占用原来内存的2倍。当然哈希桶的总大小，即全局哈希表2的大小，会是原来全局哈希表1的2倍。\n\n问题4，所以不采用复制的方式。\n\n问题3，rehash完成后，全局哈希表没有指向任何元素，则释放内存空间。但全局哈希表头仍存在。\n\n问题1，渐进式rehash主要是把一次性rehash的工作分散到多次的数据处理过程中。当从全局哈希表1 rehash到全局哈希表2 的过程中，所有的添加改动均会只发生在表2. 渐渐的表1 中的数据就会被全部移动到表2中。（会不会出现有些从不被访问的在表1的数据，还不是非常清楚，也许需要看看源码。）\n\n注：以上回答，并未经过源码的校对，如果不正确，请大神指正！谢谢！","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1598145787,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1194626,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/82/1ff83a38.jpg","nickname":"牛牛","note":"","ucode":"CFCE68B4F92209","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2062818,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7UJwSjHWKYOwnAYjjiaNBob396XaIqmttnHKuM7ahBu19QCn1mNicrg24nKgzA2kttP8tpV466anzMjMxq8Sx3Lw/132","nickname":"Solokat","note":"","ucode":"56BAA66C408D73","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":300498,"discussion_content":"听起来蛮有道理的🌹、不过我也不知道对不对～、等有时间翻翻代码、感谢啊～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598150189,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300485,"ip_address":""},"score":300498,"extra":""},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2062818,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7UJwSjHWKYOwnAYjjiaNBob396XaIqmttnHKuM7ahBu19QCn1mNicrg24nKgzA2kttP8tpV466anzMjMxq8Sx3Lw/132","nickname":"Solokat","note":"","ucode":"56BAA66C408D73","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":303016,"discussion_content":"渐进式hash是以桶为单位进行迁移，为的是不长期阻塞（redis是单线程）；优先迁移被访问桶应该是局部性原则（可能近期还会被访问），迁移完一个桶，旧的会置空，没访问的时候迁移没有停下来，直到迁移完毕","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599114565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300485,"ip_address":""},"score":303016,"extra":""},{"author":{"id":3197360,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKYmUib5xavd98HzH0mFnicrwWqJlyuu1pe1CdQ6tehpJPIFbNeKPtZVnZ1160WuibZQUGSI9KCpmVOg/132","nickname":"Geek_62d5df","note":"","ucode":"BCACE763B4789A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2062818,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/7UJwSjHWKYOwnAYjjiaNBob396XaIqmttnHKuM7ahBu19QCn1mNicrg24nKgzA2kttP8tpV466anzMjMxq8Sx3Lw/132","nickname":"Solokat","note":"","ucode":"56BAA66C408D73","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":590043,"discussion_content":"当从全局哈希表1 rehash到全局哈希表2 的过程中，所有的添加改动均会只发生在表2. 渐渐的表1 中的数据就会被全部移动到表2中,\n对这个有点疑问，如果在迁移了一半的过程中进行更新造作，表二没有怎么办","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665486135,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300485,"ip_address":"北京"},"score":590043,"extra":""}]},{"author":{"id":1896868,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f1/a4/79c36b87.jpg","nickname":"流云","note":"","ucode":"26C5A9166EC6D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301375,"discussion_content":"3. rehash完成后，ht[0]的内存空间会被释放，然后ht[0]=ht[1]","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598508541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1461984,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK6xwUp8JiaFNPNSlNxubQlTgcxl02Yc1eiaOzvj75Wob9AYVdsYwAapowkkicenhV0Y02dW2yibPicHDg/132","nickname":"Geek_96685a","note":"","ucode":"8480A5D41C6C2B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585792,"discussion_content":"仔细看看文章内容，就知道了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661828771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2797976,"avatar":"","nickname":"Geek_323a60","note":"","ucode":"CDC276EC255411","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577455,"discussion_content":"我觉得你可能理解错了。从老师的描述中看，渐进式rehash并不是移动的请求的索引位置。而是从第一个索引位置开始每请求一次移动一个索引位置的entries，一直到最后一个索引位置。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656125827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2082118,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/P1y2k6dcoAWtlXkMcKFGeAmykTKCOKEicKsN0TX4eT6icibATfqnlsDyjicfjvo1zAa9lAS4ZGkSEGjeUUUmy9Qofg/132","nickname":"xyy_Li","note":"","ucode":"81A647AB5F757A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548379,"discussion_content":"这里的迁移和访问的key是不一样的吧，迁移只会从旧的hash数组的index=0处可以迁移，只到迁移完成。 即使不被访问也可以被迁移到啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643168083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301079,"discussion_content":"想了下，做个猜测，如果rehash后存在未被访问并且没有被设置过期时间的key，那原先的全局hash表就不会被释放，不过这个占用的空间即使不回收相较于整个内存来说应该也比较小，等下次rehash时，再操作一番，哈哈，盲猜一波，真存在这样的key，Redis也没办法，或者这样的数据就默认为冷key，直接清除掉😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598403374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1078833,"avatar":"https://static001.geekbang.org/account/avatar/00/10/76/31/c84a9f39.jpg","nickname":"雷健雄","note":"","ucode":"BFCD014B1754F1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368670,"discussion_content":"老师有说redis自身会周期性（例如每100ms）的rehash的，在这里会处理冷key吧，是否清除要看淘汰策略的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618798331,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301079,"ip_address":""},"score":368670,"extra":""}]},{"author":{"id":1287774,"avatar":"https://static001.geekbang.org/account/avatar/00/13/a6/5e/b05254a6.jpg","nickname":"Mhy","note":"","ucode":"DE19BCAD1F856E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299301,"discussion_content":"我也想问这些呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597649759,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239776,"user_name":"dingjiayi","can_delete":false,"product_type":"c1","uid":1485477,"ip_address":"","ucode":"DAE189F6FB1B55","user_header":"https://static001.geekbang.org/account/avatar/00/16/aa/a5/194613c1.jpg","comment_is_top":false,"comment_ctime":1596639062,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"57431213910","product_id":100056701,"comment_content":"老师好，请问 rehash 期间，新的 操作请求（增删改查）到达，redis 是如何处理的？","like_count":13,"discussions":[{"author":{"id":1007254,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","nickname":"莫名","note":"","ucode":"E28F2602BA25DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297911,"discussion_content":"在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。\n\n另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。","likes_number":34,"is_delete":false,"is_hidden":false,"ctime":1597110273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020629,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","nickname":"yeek","note":"","ucode":"A1C71023113CB9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1007254,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","nickname":"莫名","note":"","ucode":"E28F2602BA25DD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298045,"discussion_content":"提问：这样渐进式rehash是否要很久才能完成","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597155845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297911,"ip_address":""},"score":298045,"extra":""},{"author":{"id":2264685,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/6d/f2354440.jpg","nickname":"瞌睡的李先生","note":"","ucode":"88480FAFB4F879","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":1007254,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/96/a03175bc.jpg","nickname":"莫名","note":"","ucode":"E28F2602BA25DD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337960,"discussion_content":"应该是redis设计与实现这本书里讲的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609137391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":297911,"ip_address":""},"score":337960,"extra":""},{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1020629,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","nickname":"yeek","note":"","ucode":"A1C71023113CB9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345687,"discussion_content":"rehash 还有周期性的操作进行迁移数据.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611760677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298045,"ip_address":""},"score":345687,"extra":""}]},{"author":{"id":1509619,"avatar":"http://thirdwx.qlogo.cn/mmopen/uqaRIfRCAhJ6t1z92XYEzadRGelHJUZ5mXrausmIK72hVYYYFeQaOWmhmWt3e5863fOavRcibM5mREpObRUT0gH94QcnWoaYq/132","nickname":"坚持","note":"","ucode":"7385D8E981CC95","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297166,"discussion_content":"我理解如果是新增请求都会走hash[2]表，如果是其他请求会先请求hash[1]表看是否命中，如未命中在请求hash[2]表","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596790831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303013,"discussion_content":"每一步rehash结束，都要增加索引值，并且把旧表中已经迁移完毕的bucket置为空指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599113600,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239956,"user_name":"QFY","can_delete":false,"product_type":"c1","uid":1144134,"ip_address":"","ucode":"5EAA14772BA908","user_header":"https://static001.geekbang.org/account/avatar/00/11/75/46/815e56c8.jpg","comment_is_top":false,"comment_ctime":1596701056,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"35956439424","product_id":100056701,"comment_content":"老师，关于rehash那里有两个问题：<br>1.redis切换全局hash表是否是在将原有hash表的全部内容拷贝完成后切换<br>2.如果在rehash过程中，已拷贝过的位置后面又有新的冲突值过来了该怎么办","like_count":8,"discussions":[{"author":{"id":1691331,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ce/c3/688b8bf9.jpg","nickname":"是我！","note":"","ucode":"0B474014D620F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550492,"discussion_content":"在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个key的话， 程序会先在 ht[0] 里面进行查找， 如果没找到则会到 ht[1] 里面进行查找，。\n\n另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644568197,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1441606,"avatar":"https://static001.geekbang.org/account/avatar/00/15/ff/46/7e4039ea.jpg","nickname":"伟平","note":"","ucode":"2D3E55238FC8B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":307253,"discussion_content":"切换后, 才接受新的请求吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1600570623,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1581390,"avatar":"https://static001.geekbang.org/account/avatar/00/18/21/4e/363b1e65.jpg","nickname":"Andrew胖虎","note":"","ucode":"ED70A22E7DF733","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342460,"discussion_content":"1，二级指针\n2，二进制反转\n\n看源码比较清楚点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610687282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1883237,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/bc/65/dd69df20.jpg","nickname":"弭宝辰🥎","note":"","ucode":"E96F60EF9FAB03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303091,"discussion_content":"可以参考concurrentHash的扩容过程","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599138887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299496,"discussion_content":"我也想知道","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597717800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1393004,"avatar":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","nickname":"叶子。","note":"","ucode":"3EF2CC36F0D09A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337984,"discussion_content":"rehash过程中对于哈希表的delete/find/update操作会在h[0]&amp;h[1]生效, 比如find命令会依次在h[0]上查找,没有查找到则到h[1]上查找\n\n对于put操作则只会在h[1]上生效","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609143973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299496,"ip_address":""},"score":337984,"extra":""}]}]},{"had_liked":false,"id":239499,"user_name":"哦吼掉了","can_delete":false,"product_type":"c1","uid":1232599,"ip_address":"","ucode":"1F89B1BA1EEF52","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/d7/8168e1bf.jpg","comment_is_top":false,"comment_ctime":1596549952,"is_pvip":true,"replies":[{"id":"88954","content":"一个对象保存到哈希桶时，实际是要用它的hash值对哈希桶个数取模的，所以rehash时，桶个数发生了变化，那么对象的存储位置也会有所变化。<br><br>跳表的查找通过不同层的指针来跳转，指针比较多时，类似于二分查找了。","user_name":"作者回复","comment_id":239499,"uid":"1609687","ip_address":"","utype":1,"ctime":1597103490,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"35956288320","product_id":100056701,"comment_content":"小问题:<br>1.rehash的时候为啥存储位置会发生变化？一个对象的hashCode始终是一样的。  还是说rehash是对槽进行取模 <br>2.跳表找元素没太看明白，是二分查找么？怎么感觉找33那个元素不止3次<br>课后一问:<br>因为数组占用内存连续，不需要随机读取。同时碎片化问题也不需要考虑。<br><br>希望得到老师的解答，谢谢","like_count":8,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503119,"discussion_content":"一个对象保存到哈希桶时，实际是要用它的hash值对哈希桶个数取模的，所以rehash时，桶个数发生了变化，那么对象的存储位置也会有所变化。\n\n跳表的查找通过不同层的指针来跳转，指针比较多时，类似于二分查找了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597103490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239259,"user_name":"曾轼麟","can_delete":false,"product_type":"c1","uid":1451391,"ip_address":"","ucode":"D418371AC11270","user_header":"https://static001.geekbang.org/account/avatar/00/16/25/7f/473d5a77.jpg","comment_is_top":false,"comment_ctime":1596468599,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35956206967","product_id":100056701,"comment_content":"intset 和 ziplist 如果直接使用确实是时间复杂度上不是很高效，但是结合Redis的使用场景，大部分Redis的数据都是零散碎片化的，通过这两种数据结构可以提高内存利用率，但是为了防止过度使用这两种数据结构Redis其实都设有阈值或者搭配使用的，例如：ziplist是和quicklist一起使用的，在quicklist中ziplist是一个个节点，而且quicklist为每个节点的大小都设置有阈值避免单个节点过大，从而导致性能下降","like_count":8},{"had_liked":false,"id":239171,"user_name":"刘忽悠","can_delete":false,"product_type":"c1","uid":1252173,"ip_address":"","ucode":"095DE3A8D3F450","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/4d/2cc44d9a.jpg","comment_is_top":false,"comment_ctime":1596451317,"is_pvip":true,"replies":[{"id":"88621","content":"提个小问题哈，如果压缩列表也是随机跳着访问，对CPU缓存还友好不？","user_name":"作者回复","comment_id":239171,"uid":"1609687","ip_address":"","utype":1,"ctime":1596726668,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"35956189685","product_id":100056701,"comment_content":"至于问题答案，采用压缩列表或者是整数集合，都是数据量比较小的情况，所以一次能够分配到足够大的内存，而压缩列表和整数集合本身的数据结构也是线性的，对cpu的缓存更友好一些，所以真正的执行的时间因为高速缓存的关系，速度更快","like_count":8,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503008,"discussion_content":"提个小问题哈，如果压缩列表也是随机跳着访问，对CPU缓存还友好不？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596726668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241025,"user_name":"游弋云端","can_delete":false,"product_type":"c1","uid":1208637,"ip_address":"","ucode":"A960E8F5AA25B9","user_header":"https://static001.geekbang.org/account/avatar/00/12/71/3d/da8dc880.jpg","comment_is_top":false,"comment_ctime":1597154396,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"27366958172","product_id":100056701,"comment_content":"Redis 采用了渐进式 rehash，那么什么时候进行新的全局Hash表的切换呢？当旧的Hash表格的负载因子达到一定值的时候？","like_count":6,"discussions":[{"author":{"id":1896868,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f1/a4/79c36b87.jpg","nickname":"流云","note":"","ucode":"26C5A9166EC6D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301376,"discussion_content":"全局的hash会在服务器定时器里rehash，单次100个step，超过1毫秒则返回","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598508677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2107618,"avatar":"https://static001.geekbang.org/account/avatar/00/20/28/e2/fbf76ae6.jpg","nickname":"迷迷徒","note":"","ucode":"5B65708B7E2DC1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1896868,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f1/a4/79c36b87.jpg","nickname":"流云","note":"","ucode":"26C5A9166EC6D8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302173,"discussion_content":"有个疑问 为什么渐进式rehash要在每次请求的时候搬迁一个entry，而不是定时的去搬迁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598811939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301376,"ip_address":""},"score":302173,"extra":""},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2107618,"avatar":"https://static001.geekbang.org/account/avatar/00/20/28/e2/fbf76ae6.jpg","nickname":"迷迷徒","note":"","ucode":"5B65708B7E2DC1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337987,"discussion_content":"好问题 .有定时的线程去搬家的 ,因为有些key是低频的.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609144359,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":302173,"ip_address":""},"score":337987,"extra":""}]}]},{"had_liked":false,"id":240155,"user_name":"Nemo","can_delete":false,"product_type":"c1","uid":1657039,"ip_address":"","ucode":"2B11D18D6FA2AE","user_header":"https://static001.geekbang.org/account/avatar/00/19/48/cf/8c88e6c0.jpg","comment_is_top":false,"comment_ctime":1596771602,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"27366575378","product_id":100056701,"comment_content":"各种数据结构访问和修改的时间复杂度：https:&#47;&#47;www.bigocheatsheet.com&#47;","like_count":6,"discussions":[{"author":{"id":2052670,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/52/3e/f74da7bd.jpg","nickname":"初学者","note":"","ucode":"5E404009761B90","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":376977,"discussion_content":"干货","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622447346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273816,"user_name":"二哥不再迷茫","can_delete":false,"product_type":"c1","uid":1043199,"ip_address":"","ucode":"D02D489F546A09","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ea/ff/d1eb00e3.jpg","comment_is_top":false,"comment_ctime":1610686590,"is_pvip":true,"discussion_count":2,"race_medal":0,"score":"23085523070","product_id":100056701,"comment_content":"跳表快速查询33过程中疑问，<br>一级索引， <br>1， 在一级索引中比较1\b和33的大小，1小于33，<br>2，继续比较11和33的大小，11比33小，<br>3，继续比较27和33的大小， 27比33小，<br>4，继续比较50和33的大小，50比33大，<br>5，从33位置进入底层数据，比较33和33大小，相等，找到33.<br>5次比较大小，应该是5次查找到33吧。<br>同理二级索引需要5次查找到33。<br>不是应该这样吗？老师","like_count":5,"discussions":[{"author":{"id":2797976,"avatar":"","nickname":"Geek_323a60","note":"","ucode":"CDC276EC255411","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577456,"discussion_content":"不要在意这些细节，明白老师说的意思就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656125981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365360,"discussion_content":"我也这样认为，感觉这个例子没有体现出二级索引的作用，数据量再大些才能体现\n不过展示了二分查找的含义","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617783163,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242177,"user_name":"Lywane","can_delete":false,"product_type":"c1","uid":1446512,"ip_address":"","ucode":"2B0027AA069CE9","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","comment_is_top":false,"comment_ctime":1597629521,"is_pvip":false,"replies":[{"id":"89449","content":"是的，哈希表这个结构，整个数据库空间用它来保存键值对，同时HASH类型的键值对也用它作为底层结构。所以，rehash也是两种情况下都有的。","user_name":"作者回复","comment_id":242177,"uid":"1609687","ip_address":"","utype":1,"ctime":1597680076,"user_name_real":"蒋德钧"}],"discussion_count":1,"race_medal":0,"score":"23072466001","product_id":100056701,"comment_content":"rehash不仅全局有，单独的值为HASH类型的数据也会有吧","like_count":5,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503944,"discussion_content":"是的，哈希表这个结构，整个数据库空间用它来保存键值对，同时HASH类型的键值对也用它作为底层结构。所以，rehash也是两种情况下都有的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597680076,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240595,"user_name":"陈靖","can_delete":false,"product_type":"c1","uid":1147418,"ip_address":"","ucode":"8C9596A54DB5C8","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/1a/64ec25ff.jpg","comment_is_top":false,"comment_ctime":1596989931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23071826411","product_id":100056701,"comment_content":"老师的项目，是要把这些数据结构全部撸一遍吗？","like_count":5},{"had_liked":false,"id":275871,"user_name":"马以","can_delete":false,"product_type":"c1","uid":1344431,"ip_address":"","ucode":"3FEA06CA14DE28","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/af/1cb42cd3.jpg","comment_is_top":false,"comment_ctime":1611710339,"is_pvip":false,"replies":[{"id":"100460","content":"Redis设计rehash时已经考虑到这种情况了，在 rehash 被触发后，Redis会按一定频率（例如每 100ms&#47; 次）执行rehash 操作。所以即使没有收到新请求，Redis 也会定时执行一次 rehash 操作，就不会造成你说的rehash永远完不成的情况了。<br><br>后面可以看下咱们专栏的第10讲，即第一次答疑，里面也有解释。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1612143534,"ip_address":"","comment_id":275871,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18791579523","product_id":100056701,"comment_content":"有个问题，在渐进式rehash的时候，如果有一个hash桶的位置一直没有被访问到，是不是这个rehash动作就永远完成不了了？那么也就意味着系统永远要保留两份全局hash表？","like_count":4,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":514511,"discussion_content":"Redis设计rehash时已经考虑到这种情况了，在 rehash 被触发后，Redis会按一定频率（例如每 100ms/ 次）执行rehash 操作。所以即使没有收到新请求，Redis 也会定时执行一次 rehash 操作，就不会造成你说的rehash永远完不成的情况了。\n\n后面可以看下咱们专栏的第10讲，即第一次答疑，里面也有解释。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612143534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241999,"user_name":"x","can_delete":false,"product_type":"c1","uid":1234454,"ip_address":"","ucode":"AB74494440A008","user_header":"https://static001.geekbang.org/account/avatar/00/12/d6/16/43b4814c.jpg","comment_is_top":false,"comment_ctime":1597555660,"is_pvip":false,"replies":[{"id":"89346","content":"我记得Golang里面的map扩容，好像是每次迁2个buckets，也是有key进行增、删或改时进行迁移。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1597591591,"ip_address":"","comment_id":241999,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18777424844","product_id":100056701,"comment_content":"redis的hash扩容跟golang中的map其实扩容机制竟然都是&quot;渐进式扩容&quot;！","like_count":4,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503898,"discussion_content":"我记得Golang里面的map扩容，好像是每次迁2个buckets，也是有key进行增、删或改时进行迁移。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597591591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241034,"user_name":"yeek","can_delete":false,"product_type":"c1","uid":1020629,"ip_address":"","ucode":"A1C71023113CB9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/d5/699384a0.jpg","comment_is_top":false,"comment_ctime":1597156759,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"18777025943","product_id":100056701,"comment_content":"渐进式 rehash操作，从 ht0 到 ht1 ，当ht1中的hash冲突也变大了，此时需要rehash，但是ht0 中还有数据没有迁移，此时redis如何操作？","like_count":4,"discussions":[{"author":{"id":1346215,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","nickname":"William","note":"","ucode":"55F5D9DEE485B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345688,"discussion_content":"mark","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611760837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337985,"discussion_content":"哈希表有个变量: rehashidx ,初始化为0 , rehash过程会自增,完成rehash时会变成-1\n\n所以rehash并不是无脑的,满足前置条件才能触发\n1.负载因子 哈希表非空数量/哈希表容量\n2.rehashidx=-1","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1609144218,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1388092,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2e/3c/eae43616.jpg","nickname":"sid","note":"","ucode":"3D1F9169A19D29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300806,"discussion_content":"盲生 你发现了华点。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598268806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1671478,"avatar":"https://static001.geekbang.org/account/avatar/00/19/81/36/cde8e128.jpg","nickname":"Ryan","note":"","ucode":"9F072C06D11C1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":329300,"discussion_content":"/* 根据相关触发条件扩展字典 */\nstatic int _dictExpandIfNeeded(dict *d) \n{ \n    if (dictIsRehashing(d)) return DICT_OK;  // 如果正在进行Rehash，则直接返回\n    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);  // 如果ht[0]字典为空，则创建并初始化ht[0]  \n    /* (ht[0].used/ht[0].size)>=1前提下，\n       当满足dict_can_resize=1或ht[0].used/t[0].size>5时，便对字典进行扩展 */\n    if (d->ht[0].used >= d->ht[0].size &amp;&amp; \n        (dict_can_resize || \n         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio)) \n    { \n        return dictExpand(d, d->ht[0].used*2);   // 扩展字典为原来的2倍\n    } \n    return DICT_OK; \n}\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606362760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239192,"user_name":"小氘","can_delete":false,"product_type":"c1","uid":1622109,"ip_address":"","ucode":"DA55B9A02D9EE0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","comment_is_top":false,"comment_ctime":1596455964,"is_pvip":false,"replies":[{"id":"88620","content":"点个赞！这位同学虽然没有用过redis，但是根据计算机系统的一些原理进行分析，很棒！这也是我们掌握原理的用途。<br><br>我再给你提个小问题，可以考虑下，虽然内存空间连续，但如果访问本身是随机的，粒度大小不一，还能利用CPU缓存不？","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1596726520,"ip_address":"","comment_id":239192,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18776325148","product_id":100056701,"comment_content":"我是没有用过redis的小白，尝试回答课后思考题。<br>数组这种基本数据结构的两个特点：1 连续的内存空间分布，符合程序的局部性原理，可以利用cpu高速缓存；2 根据数组下标随机访问元素的时间复杂度是O(1)。如果实现上可以利用这两个特点，那还是有它的存在价值。","like_count":5,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503016,"discussion_content":"点个赞！这位同学虽然没有用过redis，但是根据计算机系统的一些原理进行分析，很棒！这也是我们掌握原理的用途。\n\n我再给你提个小问题，可以考虑下，虽然内存空间连续，但如果访问本身是随机的，粒度大小不一，还能利用CPU缓存不？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596726520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1622109,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erPMtAfnQdpx1yOZQ2ic7icqUs3tvibEjUXQMUXKiaakyuIho6k6vmdl46nrdWjXIjPIRg9Pmco00tR5w/132","nickname":"小氘","note":"","ucode":"DA55B9A02D9EE0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297426,"discussion_content":"”虽然内存空间连续，但如果访问本身是随机的，粒度大小不一，还能利用CPU缓存不？“\n\n我觉得访问随机对CPU缓存不友好，CPU Cache Line是64字节，如果下一个随机访问到的元素不在此Cache Line中，那就要从内存中读入缓存。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1596935560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292697,"user_name":"阿基米德","can_delete":false,"product_type":"c1","uid":1304804,"ip_address":"","ucode":"065D6529C12B81","user_header":"https://static001.geekbang.org/account/avatar/00/13/e8/e4/c9dd6058.jpg","comment_is_top":false,"comment_ctime":1620925149,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14505827037","product_id":100056701,"comment_content":"在使用redis时，经常会被问到大key问题，关于大key问题想了解一下，什么样的情况才能叫大key，他在哪些场景下才会有问题？如果有一集合的数据有100w个数据，但在使用时只做查询操作，这个场景的数据还能被叫做大key吗","like_count":3,"discussions":[{"author":{"id":2299058,"avatar":"https://static001.geekbang.org/account/avatar/00/23/14/b2/acd16363.jpg","nickname":"春风和煦","note":"","ucode":"02AB1473A969E3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":386695,"discussion_content":"我的理解，使用客户端，访问大key，不仅仅是占用带宽，而且会阻塞redis提供服务的线程","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1627732048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289065,"user_name":"good boby","can_delete":false,"product_type":"c1","uid":2387358,"ip_address":"","ucode":"1471E2E499412C","user_header":"https://static001.geekbang.org/account/avatar/00/24/6d/9e/6a82a5ea.jpg","comment_is_top":false,"comment_ctime":1618839233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14503741121","product_id":100056701,"comment_content":"任何优秀的框架或中间件都离不开对于基础IT技术掌握，例如大学数据结构、操作系统原理、计算机网络等。例如redis中的List、Hash、set、zset其所解决问题的场景和问题，本质上还是对应基础数据结构本身罢了！扎实的计算机基础有助于在了解、使用、精通技术上事半功倍。例如redis中hash底层数据结构为压缩表、hash表，为什么少量数据适合压缩表？大数据量使用hash？其实从hash本质上是解决哪种问题即可，hash最大优势是查询速度、修改数据，那么redis合理利用此数据结构的本质也逃脱不了此范围。所以，当我看见此结构，可以快速掌握其精髓，redis奇妙的应用了压缩表（压缩表查询需要全表扫描），在不太影响具体查询性能的同时，也兼顾了内存空间考虑。如果你对hash表掌握更深的话，可以思考一下redis采用的这种hash结构是否有优化空间？此问题就留给你来进一步思考…","like_count":3},{"had_liked":false,"id":244229,"user_name":"成辉","can_delete":false,"product_type":"c1","uid":1398853,"ip_address":"","ucode":"4E2DD20D989D57","user_header":"https://static001.geekbang.org/account/avatar/00/15/58/45/721545cc.jpg","comment_is_top":false,"comment_ctime":1598435410,"is_pvip":false,"replies":[{"id":"89957","content":"即使有了哈希桶，仍然会有键值对的哈希值取模结果是相同的，所以会落在同一个哈希桶中，这就会发送哈希冲突了，在哈希桶中用冲突链表来保存也是为了解决这个问题。<br><br>你说的哈希桶末尾是指哈希冲突链的末尾么？还是指所有哈希桶的末尾？<br><br>如果是前者，操作复杂度和链表插入复杂度相同，不过一般哈希冲突链的长度不会太长，也避免了过高的复杂度。<br><br>如果是后者，Redis的哈希桶个数是固定的（除非做rehash扩容），只能往哈希桶中插入数据。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1598486672,"ip_address":"","comment_id":244229,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14483337298","product_id":100056701,"comment_content":" hash桶不是已经避免的一定程度上的hash冲突吗？hash冲突链难道是用来解决，hash桶中还有hash碰撞的情况？那假如hash桶冲突了，为啥不在hash桶末尾添加元素，这样操作的复杂度也是O（1）","like_count":3,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504527,"discussion_content":"即使有了哈希桶，仍然会有键值对的哈希值取模结果是相同的，所以会落在同一个哈希桶中，这就会发送哈希冲突了，在哈希桶中用冲突链表来保存也是为了解决这个问题。\n\n你说的哈希桶末尾是指哈希冲突链的末尾么？还是指所有哈希桶的末尾？\n\n如果是前者，操作复杂度和链表插入复杂度相同，不过一般哈希冲突链的长度不会太长，也避免了过高的复杂度。\n\n如果是后者，Redis的哈希桶个数是固定的（除非做rehash扩容），只能往哈希桶中插入数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598486672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1031038,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/bb/7e/32734996.jpg","nickname":"得志","note":"","ucode":"673B8BA8958E1C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":321246,"discussion_content":"我们经常把数据lpush，当value不断变大，速度会变慢，一般一个key最好存多大的数据比较好？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604552975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240785,"user_name":"dingjiayi","can_delete":false,"product_type":"c1","uid":1485477,"ip_address":"","ucode":"DAE189F6FB1B55","user_header":"https://static001.geekbang.org/account/avatar/00/16/aa/a5/194613c1.jpg","comment_is_top":false,"comment_ctime":1597063896,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"14481965784","product_id":100056701,"comment_content":"我觉得 rehash 部分的 “拷贝”一次，改为 &quot;移动&quot; 更好<br>","like_count":3,"discussions":[{"author":{"id":1991215,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/62/2f/8b8a06bc.jpg","nickname":"康康","note":"","ucode":"DF6B5798F8C0C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582929,"discussion_content":"复制：从1-&gt;2 位置不变,h1、h2都存在 ；移动：从1&gt;2 ，位置变动，h1不存在，h2存在。 所以这里 应该是 复制且移动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659784928,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1928441,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/cfNtHoAbHvia1O0jIopiafYbnppEPiawgicKa8vdI2FxMMEdqORB4VLzkYTuGJGA7HibustnU0hDTOD7YSDAWuxhmrg/132","nickname":"Geek_299a34","note":"","ucode":"79AECE06F08E87","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304639,"discussion_content":"王争老师在散列表那一章用的词是“搬移”，因此你的移动我认为是正确的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599632930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1062070,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","nickname":"我的黄金时代","note":"","ucode":"D7825B45B372F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299349,"discussion_content":"如果是移动的话，新的key是在hash1还是hash2上去查找呢，我的理解是copy更为合适。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597665914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1485477,"avatar":"https://static001.geekbang.org/account/avatar/00/16/aa/a5/194613c1.jpg","nickname":"dingjiayi","note":"","ucode":"DAE189F6FB1B55","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1062070,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","nickname":"我的黄金时代","note":"","ucode":"D7825B45B372F4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299634,"discussion_content":"copy 的语义是，key h1,h2 同时存在\n实际源码中，rehash 过程，key 移动到 h2, key 就不在h1 了\n\n我是在过程中，有“rehash 过程中，如果读写请求到达，redis 处理”疑问\n如果是拷贝，那么读在h1, h2 都行\n但是我看到很多人回复都是 移动后，就在h2 了\n我就去看了源码这部分，发现 不是拷贝语义","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1597756095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299349,"ip_address":""},"score":299634,"extra":""}]}]},{"had_liked":false,"id":239468,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1596541543,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"14481443431","product_id":100056701,"comment_content":"问题：渐进式rehash依赖新的请求，如果接下来没有接收到新请求，rehash就不进行了吧？","like_count":3,"discussions":[{"author":{"id":1046338,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f7/42/eb46c66a.jpg","nickname":"keaper","note":"","ucode":"1718EAC00925ED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296463,"discussion_content":"对于全局哈希表来说，配置参数&#34;activerehashing yes/no&#34;可以控制是否定时进行rehash","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1596548466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2107375,"avatar":"https://static001.geekbang.org/account/avatar/00/20/27/ef/a7f94eda.jpg","nickname":"Jerry You","note":"","ucode":"679A44B505482F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296578,"discussion_content":"redis都没有请求，rehash的意义在哪？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596592934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2107375,"avatar":"https://static001.geekbang.org/account/avatar/00/20/27/ef/a7f94eda.jpg","nickname":"Jerry You","note":"","ucode":"679A44B505482F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296733,"discussion_content":"嗯，也是，不响应请求的Redis也就没啥用处","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596635289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296578,"ip_address":""},"score":296733,"extra":""},{"author":{"id":1062070,"avatar":"https://static001.geekbang.org/account/avatar/00/10/34/b6/0feb574b.jpg","nickname":"我的黄金时代","note":"","ucode":"D7825B45B372F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299853,"discussion_content":"这个只是操作辅助rehash，还有一个定时辅助rehash(serverCron)也会协助rehash的操作","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1597839402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296733,"ip_address":""},"score":299853,"extra":""}]},{"author":{"id":1144333,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/0d/781aa509.jpg","nickname":"路飞桑","note":"","ucode":"2EA3B61395FBA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296555,"discussion_content":"这我也有这个疑问❓渐进式rehash的过程中会占用2倍的内存空间吗？毕竟多了一个dict。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596588614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1388092,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2e/3c/eae43616.jpg","nickname":"sid","note":"","ucode":"3D1F9169A19D29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1144333,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/0d/781aa509.jpg","nickname":"路飞桑","note":"","ucode":"2EA3B61395FBA7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300804,"discussion_content":"会的，但是占用的内存不会翻倍，因为dict里面保存的只是具体对象的指针而已，这点内存开销，换来redis高效的读写性能，很划算。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1598268676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296555,"ip_address":""},"score":300804,"extra":""}]},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":532496,"discussion_content":"有兜底线程接管rehash工作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637629730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"user_type\":1}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1896868,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f1/a4/79c36b87.jpg","nickname":"流云","note":"","ucode":"26C5A9166EC6D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301377,"discussion_content":"rehash的扩容是增加2倍slot空间，内存消耗在slot上，slot保存的是指针","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598508760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289625,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1619101607,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10209036199","product_id":100056701,"comment_content":"这个数据结构图画得太棒了！","like_count":2},{"had_liked":false,"id":284041,"user_name":"Geek_adf04b","can_delete":false,"product_type":"c1","uid":2032790,"ip_address":"","ucode":"CD709E278D979B","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/9o4qQVZB2FjiaDxwLYZhL3E7HpvRIvETvZKGtF7Wiasc3jNIvTODQ6utnbQFQDYzzicqfwGM2MjNOblIBLLUmWFMQ/132","comment_is_top":false,"comment_ctime":1616048003,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10205982595","product_id":100056701,"comment_content":"渐进式rehash详细步骤：<br>1、为ht【1】分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。<br>2、在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。<br>3、在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增1.<br>4、随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设置为-1，表示rehash操作已完成。<br>渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。<br>--------来自《redis设计与实现》","like_count":2},{"had_liked":false,"id":282685,"user_name":"努逗斯","can_delete":false,"product_type":"c1","uid":2334507,"ip_address":"","ucode":"C6C722E99F5168","user_header":"https://static001.geekbang.org/account/avatar/00/23/9f/2b/57b71f70.jpg","comment_is_top":false,"comment_ctime":1615364931,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10205299523","product_id":100056701,"comment_content":"rehash过程包含两部分：serverCron（每100ms执行一次），每步rehash 100个桶。CURD时，rehash 1个桶。<br>dictRehash每次增量rehash n个桶（dictRehash的参数n表示桶的个数），由于在自动调整大小时已设置好了ht[1]的大小，因此rehash的主要过程就是遍历ht[0]的各个桶，取得key，然后将该key按ht[1]的桶的大小重新rehash，并将相应的dictEntry从ht[0]移动到ht[1]。在rehash完后，会将ht[0]指向ht[1]，然后将ht[1]清空。<br>最后，简单介绍下在rehash进行时，元素插入、查找、删除的过程（没有rehash时，所有的增删查改都指向ht[0]）。<br>插入会直接插入到ht[1]中。查找、删除会查找两个表ht[0]、ht[1]。<br>参考链接(含源码)：http:&#47;&#47;www.petermao.com&#47;redis&#47;75.html<br>","like_count":2},{"had_liked":false,"id":269490,"user_name":"爱因诗贤","can_delete":false,"product_type":"c1","uid":1528379,"ip_address":"","ucode":"150C439B87CED1","user_header":"https://static001.geekbang.org/account/avatar/00/17/52/3b/7a2610a6.jpg","comment_is_top":false,"comment_ctime":1608685635,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"10198620227","product_id":100056701,"comment_content":"为什么解决哈希冲突的entries要采用链表呢，为什么不使用红黑树来解决哈希冲突呢？这样就不需要rehash操作依然很快了","like_count":2,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337989,"discussion_content":"应该是理解有问题 , rehash目的是为了提升哈希表本身的性能问题而不是entry\n\n随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。\n\n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1609144804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1528379,"avatar":"https://static001.geekbang.org/account/avatar/00/17/52/3b/7a2610a6.jpg","nickname":"爱因诗贤","note":"","ucode":"150C439B87CED1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391101,"discussion_content":"扩容的目的本质不就是为了从概率上减少哈希冲突导致的链表太长","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630296281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":337989,"ip_address":""},"score":391101,"extra":""}]},{"author":{"id":1513948,"avatar":"https://static001.geekbang.org/account/avatar/00/17/19/dc/9d3ed421.jpg","nickname":"monchickey","note":"","ucode":"D7B670444F62B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":399999,"discussion_content":"我们理想中hash表的查找的复杂度应该为O(1)，挂红黑树也是可以的，java中就是这么做的，但是如果无限加下去红黑树会越来越大，导致实际的复杂度退化为O(logN)，这样其实就失去了hash表的作用，所以可以挂红黑树，但是当数组空间接近变满的时候还是要重新扩容，让整体复杂度回归到O(1)，无论用链表还是红黑树都是个过渡的过程，只能缓解不能解决冲突问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1633137830,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365363,"discussion_content":"红黑树插入，旋转操作时间复杂度为O(logN)","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617783459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1248827,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0e/3b/42288ae6.jpg","nickname":"./+-@YOU","note":"","ucode":"14CCC17DDFFDB6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":358112,"discussion_content":"个人觉得，如果不rehash的话，维护红黑树插入的时候时间复杂度较高。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615911676,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260672,"user_name":"zhuhaow","can_delete":false,"product_type":"c1","uid":1935680,"ip_address":"","ucode":"BC98038FD6F78A","user_header":"","comment_is_top":false,"comment_ctime":1605081208,"is_pvip":false,"replies":[{"id":"98048","content":"Redis是在3.2版本后采用quicklist作为List的底层数据结构了，不过quicklist是把ziplist和linkedlist结合起来了，quicklist由一系列节点像链表一样链接组成，每个节点会指向一个实际保存数据的ziplist。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609113497,"ip_address":"","comment_id":260672,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10195015800","product_id":100056701,"comment_content":"老师，弱弱的请教下，list 的实现出了 quicklist 还有 ziplist 的吗？<br>我在 t_list.c 的 pushGenericCommand 方法中，只看到了 createQuicklistObject() 没看到 ziplist 的创建呢","like_count":2,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509258,"discussion_content":"Redis是在3.2版本后采用quicklist作为List的底层数据结构了，不过quicklist是把ziplist和linkedlist结合起来了，quicklist由一系列节点像链表一样链接组成，每个节点会指向一个实际保存数据的ziplist。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609113497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257944,"user_name":"虚竹","can_delete":false,"product_type":"c1","uid":1691109,"ip_address":"","ucode":"8D8C96C793724E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJIocn8OMjfSGqyeSJEV3ID2rquLR0S6xo0ibdNYQgzicib6L6VlqWjhgxOqD2iaicX1KhbWXWCsmBTskA/132","comment_is_top":false,"comment_ctime":1604219826,"is_pvip":false,"replies":[{"id":"98037","content":"对于新写的数据来说，会直接写到全局哈希表2中，全局哈希表1中的数据是只减不增了。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609112255,"ip_address":"","comment_id":257944,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10194154418","product_id":100056701,"comment_content":"老师好，请教下，渐进式rehash过程中，接到客户端写入数据请求，是2个全局哈希表都会写入数据吗？","like_count":2,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508503,"discussion_content":"对于新写的数据来说，会直接写到全局哈希表2中，全局哈希表1中的数据是只减不增了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609112255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242767,"user_name":"吕","can_delete":false,"product_type":"c1","uid":1210890,"ip_address":"","ucode":"8F08E2CB81C4C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/7a/0a/0ce5c232.jpg","comment_is_top":false,"comment_ctime":1597836173,"is_pvip":false,"replies":[{"id":"89529","content":"是的，Redis的list和intset结构体里面增加了length的成员变量，用来记录元素的总个数。<br><br>感兴趣的话，可以看下Redis源码的adlist.h和intset.h里面对list和intset结构体的定义 ：）","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1597854615,"ip_address":"","comment_id":242767,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10187770765","product_id":100056701,"comment_content":"文中说双向链表和整数数组都记录了元素的总个数，但就我平时接触的双向链表和数组，里面并没有记录元素(数组中实际存在的，不是说初始定义时指定的个数)的总个数，redis是对这两个数据结构做了改进了么？","like_count":2,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504093,"discussion_content":"是的，Redis的list和intset结构体里面增加了length的成员变量，用来记录元素的总个数。\n\n感兴趣的话，可以看下Redis源码的adlist.h和intset.h里面对list和intset结构体的定义 ：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597854615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365361,"discussion_content":"java的数组，自带length属性\n集合，包含size()方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617783212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241741,"user_name":"Geek_c37e49","can_delete":false,"product_type":"c1","uid":1844885,"ip_address":"","ucode":"BCE0AD860241C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo6waC1mF0VmQibDjnJLEgFnmEUSNJozibaUeYZkpQaqicVcXxGZ3kKtnY5XF0iblxT4oiam7ucuJ1bqgg/132","comment_is_top":false,"comment_ctime":1597405979,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"10187340571","product_id":100056701,"comment_content":"我是小白一个<br>读写一篇有两个疑问<br>1、以前了解数据结构的时候学习的都是数组的访问时间复杂度应该是O(1)，不知道这篇文章里面的O(n)是咋来的？<br>2、每次学习哈希表扩容的时候，大家都是讲的首先2倍的扩容。请问这个是经验值还是逻辑推理值呢？","like_count":2,"discussions":[{"author":{"id":2131639,"avatar":"","nickname":"Geek_175bc2","note":"","ucode":"D8D6F17C8D6B1D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299727,"discussion_content":"跟hashcode映射到桶的位置用位运算代替取模有关吧，hashcode&amp;桶的个数-1 当桶的个数为2的整数次幂等式成立","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597800357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019725,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","nickname":"学个球","note":"","ucode":"7343F3C0CA981D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299083,"discussion_content":"1. 数组的 O(1) 实际上说的是 根据下标访问数组元素是 O(1)。但我们面临一个待查找的元素时，因为我们不知道这个元素是在数组的哪个位置，也就是不知道这个元素存储的下标，所以无法 O(1) 直接定位到。\n2. 这个应该需要具体场景具体分析。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597558567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1513948,"avatar":"https://static001.geekbang.org/account/avatar/00/17/19/dc/9d3ed421.jpg","nickname":"monchickey","note":"","ucode":"D7B670444F62B3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400002,"discussion_content":"我们看那个整数数组部分是set的底层结构，set一方面指向了哈希表，一方面指向了整数数组，如果数组是用作哈希表的底层存储，那么直接得到下标复杂度是O(1)，但是如果仅仅存储一些数据，要去查找，必须要遍历复杂度就是O(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633138050,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1497883,"avatar":"https://static001.geekbang.org/account/avatar/00/16/db/1b/f9dc85a8.jpg","nickname":"一枝铅笔不寂寞","note":"","ucode":"6F3DA15C2C4C60","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369104,"discussion_content":"论查找复杂度与随机访问复杂度区别","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618929464,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111389,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f5/5d/cc191bf8.jpg","nickname":"红鲤鱼与绿鲤鱼与驴💭","note":"","ucode":"3F95880F8F6F63","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349028,"discussion_content":"数组下标访问某个元素 是 o1的 但是 查找指定的值时 是需要遍历数组的 这也就是on","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612855007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1155646,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKotsBr2icbYNYlRSlicGUD1H7lulSTQUAiclsEz9gnG5kCW9qeDwdYtlRMXic3V6sj9UrfKLPJnQojag/132","nickname":"ppd0705","note":"","ucode":"EB63D4E3FD1E9A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301835,"discussion_content":"我对这个O(n)复杂度也感到困惑，按下标访问应该是O(1)的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598675746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241423,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1597289932,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10187224524","product_id":100056701,"comment_content":"想提几个问题：<br>1 redis 在接受了一个键值数据是怎么一步步存储的？<br>2 是把键和值 做哈希运算 得到哈希值 然后按一定规律 放入哈希桶？<br>3 一个哈希桶 可以存储多个键值对 ，那么这多对数据又是如何 存储和查找的？","like_count":2,"discussions":[{"author":{"id":1388092,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2e/3c/eae43616.jpg","nickname":"sid","note":"","ucode":"3D1F9169A19D29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300805,"discussion_content":"建议康康HASH算法是用来干嘛的。学JAVA的话，可以看看HashMap的相关分析文章，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598268774,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240172,"user_name":"菜鸟葫芦娃","can_delete":false,"product_type":"c1","uid":1701051,"ip_address":"","ucode":"B402A23D3F1381","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK28icgzo9R0rT9h0Q7iaYkJQtCPa0oriaDfFdaQMUibnnH7BW2CU9yKwDUvou63AmoGGIPgZJDyjMRJA/132","comment_is_top":false,"comment_ctime":1596777592,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10186712184","product_id":100056701,"comment_content":"读了这篇文章很有收获,不仅了解了Redis的底层数据结构,还通过课后作业思考把内存等知识串联起来。","like_count":2},{"had_liked":false,"id":239677,"user_name":"那么丶神秘美丽","can_delete":false,"product_type":"c1","uid":1388334,"ip_address":"","ucode":"58B6F2182E946B","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLhxLmNxIbicllknrM46np5h2jpTZt1COP6X3aica1cbgsge5woIJP70HG3hMFyBmTRHn3zj9jXrdPg/132","comment_is_top":false,"comment_ctime":1596613221,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10186547813","product_id":100056701,"comment_content":"引用---简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。<br>提问---渐进式 rehash的时候，数据是同时存在于哈希表1和哈希表2吗？这时候，我要查找数据，如何处理了？<br>","like_count":2,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337988,"discussion_content":"会同时存在 , 哈希表中有个变量计数器rehashidx标识rehash状态.\n\nredis会同时持有两个哈希表h[0]--旧 ,&amp;h[1]--新 ,find时会先从h[0]查找,找不到则继续从h[1]找 , rehash完成时h[1]重命名为h[0] ,h[0]销毁并重新初始化一个空白得h[1]出来 . ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609144522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239463,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1596540049,"is_pvip":false,"replies":[{"id":"88799","content":"是的，跳表的元素需要是有序的，元素在插入时需要保序。<br><br>跳表本身类似于基于链表实现了二分查找。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1596987051,"ip_address":"","comment_id":239463,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10186474641","product_id":100056701,"comment_content":"老师，您好，以查找33为例的“跳表的快速查找过程”，需要元素有序吧？<br>看着类似二分查找","like_count":2,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503108,"discussion_content":"是的，跳表的元素需要是有序的，元素在插入时需要保序。\n\n跳表本身类似于基于链表实现了二分查找。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596987051,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1073087,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/bf/4bd3eb4b.jpg","nickname":"米 虫","note":"","ucode":"6F35AA8BB8195B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296472,"discussion_content":"他就是有序的，所以了有序集合。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1596551294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342166,"user_name":"吾","can_delete":false,"product_type":"c1","uid":2442000,"ip_address":"","ucode":"518DCF772B93AC","user_header":"https://static001.geekbang.org/account/avatar/00/25/43/10/402beda9.jpg","comment_is_top":false,"comment_ctime":1650079782,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5945047078","product_id":100056701,"comment_content":"劝某些人，不会写笔记就不要写笔记，要么写私密笔记。","like_count":1},{"had_liked":false,"id":288577,"user_name":"jzdayz","can_delete":false,"product_type":"c1","uid":1259280,"ip_address":"","ucode":"E84C0DFC53BE8A","user_header":"https://static001.geekbang.org/account/avatar/00/13/37/10/a8aa9acb.jpg","comment_is_top":false,"comment_ctime":1618543721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5913511017","product_id":100056701,"comment_content":"这个渐进式rehash是指每次请求打进来才会移动数据吗？<br>比如：<br>有16个hash曹，有4条数据，需要扩容为32个hash曹，只有这4条数据都被访问才会进行rehash？那如果此时移动了两条数据，那这16个hash表1空间是没别释放的吗？那会不出出现数据量特别大的情况下，有些数据始终没访问到，那hash1和hash2是都存在，hash1的空间无法释放？","like_count":1},{"had_liked":false,"id":279410,"user_name":"Wang Junling","can_delete":false,"product_type":"c1","uid":2441811,"ip_address":"","ucode":"A5A67DB1904ED3","user_header":"https://static001.geekbang.org/account/avatar/00/25/42/53/577009a5.jpg","comment_is_top":false,"comment_ctime":1613755341,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5908722637","product_id":100056701,"comment_content":"我可以这样理解吗？<br>1、hash中存放的是索引指针（在hash中value实际存放的是一个指针，指向数据点）。我可以理解hash是一个索引表吗？<br>2、如果hash是一个索引表。那跳表、压缩都是索引表。原始存入的val是怎么存储的呢？大佬们可以给我讲一下存储过程吗？","like_count":1,"discussions":[{"author":{"id":1886331,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/c8/7b/153181d7.jpg","nickname":"夜辉","note":"","ucode":"9421385F51FF9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365362,"discussion_content":"全局索引表\n先创建存入的val，再将指针放入全局索引表桶中对应的位置","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1617783311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277629,"user_name":"Geek_aef208","can_delete":false,"product_type":"c1","uid":2113273,"ip_address":"","ucode":"9FA1CAAFA27DCF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/p83UpvULG4E9MbCfmia1Ocdf4yHnBWhRyhRkvYia3E5DoQ9JopHSEWsSxPJwvV9yYKcHiasA1SUQdw3c9ph1WZaibg/132","comment_is_top":false,"comment_ctime":1612496980,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5907464276","product_id":100056701,"comment_content":"老师好，我有一个问题想请教下：<br>采用延时rehash方法，将表1的记录迁移到表2，这个方法避免了一次性迁移导致的阻塞。但如果表1中有至少1个记录一直没有访问，会不会导致表1和表2的迁移一直没有最终完成。这样的话，当表2也出现容量问题时，就不能以表1=表2*2的方式进行扩容了。这样不就会出问题吗？<br>是不是当表1的遗留entries少于一定的阈值时，就会一次性将表1的entries迁移到表2，从而主动完成rehash工作？","like_count":1},{"had_liked":false,"id":270245,"user_name":"hz","can_delete":false,"product_type":"c1","uid":1002250,"ip_address":"","ucode":"8BF6ACDCC7D61C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/0a/4bb137d9.jpg","comment_is_top":false,"comment_ctime":1609002989,"is_pvip":false,"replies":[{"id":"98122","content":"渐进式rehash在设计时已经考虑到这个问题，所以除了在key被访问时进行rehash，Redis还会按照每秒10次的频率执行定时任务，定时任务中就包含了 rehash 操作。<br><br>所以，即使某个键一直没有被访问，Redis 也会定时执行一次 rehash 操作，同时，每次执行时长不会超过 1ms，以免对其他任务造成影响。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609165738,"ip_address":"","comment_id":270245,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5903970285","product_id":100056701,"comment_content":"老师，渐进式rehash的过程会不会出现hash[0]中的某个键一直不被访问到，导致rehash很久不完成。如果此时hash[1]中的负载因子又已经超过5了，会出现什么情况。","like_count":1,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512568,"discussion_content":"渐进式rehash在设计时已经考虑到这个问题，所以除了在key被访问时进行rehash，Redis还会按照每秒10次的频率执行定时任务，定时任务中就包含了 rehash 操作。\n\n所以，即使某个键一直没有被访问，Redis 也会定时执行一次 rehash 操作，同时，每次执行时长不会超过 1ms，以免对其他任务造成影响。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609165738,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337990,"discussion_content":"1. 不会,redis有后台线程定时做rehash\n2.即使h[1]负载因子超过5也不会触发rehash,需等待此次rehash完成","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609145015,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253551,"user_name":"LovePeace","can_delete":false,"product_type":"c1","uid":1010319,"ip_address":"","ucode":"5BA5B11FAF953E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/8f/5b224f54.jpg","comment_is_top":false,"comment_ctime":1602773989,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5897741285","product_id":100056701,"comment_content":"请教老师 当hash表进行渐进式扩容时 数据分布在两个buckets中 这个时候来get查找数据是怎么定位到数据在是哪个buckets中的呢？不会是一个查不到再去查另外一个吧？","like_count":1},{"had_liked":false,"id":249634,"user_name":"萧","can_delete":false,"product_type":"c1","uid":1229143,"ip_address":"","ucode":"0C2239867AFF5F","user_header":"https://static001.geekbang.org/account/avatar/00/12/c1/57/27de274f.jpg","comment_is_top":false,"comment_ctime":1600736777,"is_pvip":true,"discussion_count":0,"race_medal":5,"score":"5895704073","product_id":100056701,"comment_content":"- 最外层存储：全局哈希表：：使用链式解决冲突；同样有哈希因子，扩容两倍，渐进式扩容；<br>    - 第二层数据：String、List、Hash、Sorted Set、Set<br><br>- 底层数据结构：6种<br>    - 动态字符串<br>    - 双向链表<br>    - 压缩列表：列表长度、列表尾偏移量、列表元素个数、表尾标识符；快速定位第一和最后一个元素<br>    - 哈希表<br>    - 跳表<br>    - 整数数组<br><br>- 不同的操作复杂度<br>    - 单元数操作是基础，基本很快<br>    - 范围操作非常耗时，需要遍历扫描，SCAN可以渐进式遍历，有一定的缓解<br>    - 统计操作通常搞笑，对元素个数进行了统计存储<br>    - 例外情况只有几个，压缩列表和双向链表操作头尾很快","like_count":1},{"had_liked":false,"id":248853,"user_name":"蛋炒饭加鸡蛋","can_delete":false,"product_type":"c1","uid":1628398,"ip_address":"","ucode":"C75E27B9FB3336","user_header":"https://static001.geekbang.org/account/avatar/00/18/d8/ee/17f220b6.jpg","comment_is_top":false,"comment_ctime":1600335084,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5895302380","product_id":100056701,"comment_content":"老师讲的太好了，思路清晰，感觉又是极客时间的一门神课。","like_count":1},{"had_liked":false,"id":242423,"user_name":"叶子。","can_delete":false,"product_type":"c1","uid":1393004,"ip_address":"","ucode":"3EF2CC36F0D09A","user_header":"https://static001.geekbang.org/account/avatar/00/15/41/6c/687c5dfb.jpg","comment_is_top":false,"comment_ctime":1597718140,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5892685436","product_id":100056701,"comment_content":"老师可否详细讲讲压缩列表的内部结构，压缩的含义是什么？","like_count":1,"discussions":[{"author":{"id":1879262,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/ac/de/68f35320.jpg","nickname":"小来子","note":"","ucode":"4EDAF31E43B211","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334410,"discussion_content":"这个作者\n闭口不谈  看书吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607842023,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239896,"user_name":"红鲤鱼与绿鲤鱼与驴baci","can_delete":false,"product_type":"c1","uid":1199902,"ip_address":"","ucode":"CB7D8A522D665E","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/1e/cb8ddbe9.jpg","comment_is_top":false,"comment_ctime":1596686713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5891654009","product_id":100056701,"comment_content":"分享一个很实用的命令 在cli 终端执行 debug object key  会显示出来这个key 的底层数据结构（encoding）<br>127.0.0.1:7000&gt; set a a<br>OK<br>127.0.0.1:7000&gt;  debug object a<br>Value at:0x7fb257329e88 refcount:1 encoding:embstr serializedlength:2 lru:2850820 lru_seconds_idle:17<br>127.0.0.1:7000&gt;","like_count":1},{"had_liked":false,"id":239853,"user_name":"🐾","can_delete":false,"product_type":"c1","uid":1087256,"ip_address":"","ucode":"D0AD0260351C31","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/18/a5218104.jpg","comment_is_top":false,"comment_ctime":1596678055,"is_pvip":false,"replies":[{"id":"88651","content":"后面课程会讲的，一起学习交流：）","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1596767179,"ip_address":"","comment_id":239853,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5891645351","product_id":100056701,"comment_content":"读完这篇文章，才发现用了这么多久的Redis，从来都没有真正去关注和学习它的底层东西，醍醐灌顶～<br>专栏后面还会讲到 bitmap、hyperloglog、streams 这三个值类型的使用吗？不知道实际使用场景是怎么样的<br>","like_count":1,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503248,"discussion_content":"后面课程会讲的，一起学习交流：）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596767179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239660,"user_name":"努力努力再努力","can_delete":false,"product_type":"c1","uid":1450822,"ip_address":"","ucode":"1F14391D73E972","user_header":"https://static001.geekbang.org/account/avatar/00/16/23/46/db5212bc.jpg","comment_is_top":false,"comment_ctime":1596608996,"is_pvip":false,"replies":[{"id":"88798","content":"是的，redis中的键和值都是用对象来表示的，具体就是用redisObject这个结构来保存的。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1596985903,"ip_address":"","comment_id":239660,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5891576292","product_id":100056701,"comment_content":"老师好，redis中的所有数据结构都是用redisObject存放的吧？","like_count":1,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503179,"discussion_content":"是的，redis中的键和值都是用对象来表示的，具体就是用redisObject这个结构来保存的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596985903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359978,"user_name":"唐龙","can_delete":false,"product_type":"c1","uid":1471657,"ip_address":"浙江","ucode":"87A10AE04F2037","user_header":"https://static001.geekbang.org/account/avatar/00/16/74/a9/5eb3ebc6.jpg","comment_is_top":false,"comment_ctime":1666094826,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666094826","product_id":100056701,"comment_content":"redis中有一个全局变量叫rehashindex。正常情况下它的值是-1，表示当前并不处在rehash过程中。<br>一旦发现需要扩容，就会将其修改为0。同时也要准备好新表的哈希桶。<br>哈希桶其实就是一个指针数组，数组的每一项存有链表的头节点地址。<br>rehashindex表示的含义是，旧表哈希桶中下标小于此值对应的链表上的数据已经迁移完毕了。此时rehashindex的值是0，也就是没有任何一条数据被迁移。<br>每一次接收到客户端一条新的命令时，就会将rehashindex指向的链表的每一个entry都rehash到新表中。同时将rehashindex的值增加一。如果它等于旧表的哈希桶的大小，就认为数据迁移完毕，置为-1。<br>----------<br>如果是一条查询命令，按照旧表的尺寸计算完hash以后和rehashindex比较大小。hash大于等于rehashindex，数据没被迁移还在旧表，直接查询返回数据，hash小于rehashindex，数据已经被迁移到了新表，需要按照新表的尺寸再计算一次hash，最后从新表中取数据。<br>如果是增删改命令，先按照上述思路判断旧表对应的桶下标，大于等于rehashindex就在覆盖或操作的同时把对应的entry迁移到新表（当然也有可能不存在对应的key，省掉一步操作）。否则就直接写入到新表。<br>----------<br>这块我一开始也没搞懂，评论区也有小伙伴理解错了，我猜可能是下面这句话搞的鬼：<br>&gt; 每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中<br>其中的“这个索引位置”与当前查询的数据没有任何关系。<br>----------<br>虽然不确定，但应该没啥大问题了吧，另外：<br>&gt; 渐进式rehash执行时，除了根据键值对的操作来进行数据迁移，Redis本身还会有一个定时任务在执行rehash，如果没有键值对操作时，这个定时任务会周期性地（例如每100ms一次）搬移一些数据到新的哈希表中，这样可以缩短整个rehash的过程。","like_count":0},{"had_liked":false,"id":357106,"user_name":"环蛇","can_delete":false,"product_type":"c1","uid":2773218,"ip_address":"加拿大","ucode":"6C6CF295EF2407","user_header":"","comment_is_top":false,"comment_ctime":1662960350,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1662960350","product_id":100056701,"comment_content":"redis这块设计没有坑点，数据模型和底层的数据结构，对用户来说可以做到“所及即所得”","like_count":0},{"had_liked":false,"id":355029,"user_name":"北极之北","can_delete":false,"product_type":"c1","uid":1177812,"ip_address":"四川","ucode":"D435CE10A8A5F0","user_header":"https://static001.geekbang.org/account/avatar/00/11/f8/d4/3ab5c816.jpg","comment_is_top":false,"comment_ctime":1660986408,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660986408","product_id":100056701,"comment_content":"彻底搞懂Redis，从此Redis不在迷路","like_count":0},{"had_liked":false,"id":354919,"user_name":"EZVIK","can_delete":false,"product_type":"c1","uid":1306984,"ip_address":"广东","ucode":"5184ED4B875299","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ7AafYooguHrSXy9fUhjx7SzwEdgWS425reZ1IpuJaq6RrEicqtx13qk0dnQWB7ObwIlWdAOpv1g/132","comment_is_top":false,"comment_ctime":1660880804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660880804","product_id":100056701,"comment_content":"当 Rehash 拷贝了 Index 1 的Entrys 到 哈希表2 时， 如果这时候有请求新增了 key 到 index 1 的桶里面， 这样不会出现数据不一致吗？","like_count":0},{"had_liked":false,"id":354781,"user_name":"Geek_045c20","can_delete":false,"product_type":"c1","uid":2914350,"ip_address":"北京","ucode":"3C446088613422","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/apXvlhZqT7NLxOYz63qZzHebzCMszx3jI56gvRVeq62fX1b3zHy6fao1UknvuqfUkHkbYG0YkOBfvqXmJBxffg/132","comment_is_top":false,"comment_ctime":1660786080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660786080","product_id":100056701,"comment_content":"1:redis rehash的条件是啥 链表长度超过多少进行扩容？<br>2:每次扩容都需要一个两倍大小的内存空间，这种方式是不是消耗巨大内存？","like_count":0},{"had_liked":false,"id":354494,"user_name":"NULL","can_delete":false,"product_type":"c1","uid":1191550,"ip_address":"山东","ucode":"2A323DD05352BC","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/7e/ebc28e10.jpg","comment_is_top":false,"comment_ctime":1660462760,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660462760","product_id":100056701,"comment_content":"&quot;整数数组和双向链表也很常见，它们的操作特征都是顺序读写，也就是通过数组下标或者链表的指针逐个元素访问，操作复杂度基本是 O(N)，操作效率比较低；&quot;<br><br>这里不太准确, 数组通过下标访问的时间复杂度度是O(1), 通过遍历访问的时间复杂度是O(N)","like_count":0},{"had_liked":false,"id":353433,"user_name":"Geek_9b658a","can_delete":false,"product_type":"c1","uid":2166275,"ip_address":"北京","ucode":"8F9F6D7451CB00","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJ2M4ibZuVAJwOOJiaXYBqH4zZ8KMzicPshV5H9YLYHXHxf0CftIuAkY1cXW7KBfhlpUTUyU5DE7pic1Q/132","comment_is_top":false,"comment_ctime":1659433766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1659433766","product_id":100056701,"comment_content":"您好，我有个问题。就是跳表一级索引的例子，为什么跳到了27(比33小)之后不继续往下跳了，比如说跳到50之后再往回查找，因为数据不是连续的也没法判断27离目标值近还是50离目标值近","like_count":0},{"had_liked":false,"id":351911,"user_name":"Geek_1ae99c","can_delete":false,"product_type":"c1","uid":3051748,"ip_address":"","ucode":"07457D1C3664DD","user_header":"","comment_is_top":false,"comment_ctime":1658286674,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658286674","product_id":100056701,"comment_content":"渐进式解决了线程阻塞的问题，那并发下需要进行更新和拷贝动作遇到一起了，redis是怎么保证数据一致性的","like_count":0},{"had_liked":false,"id":351907,"user_name":"Geek_1ae99c","can_delete":false,"product_type":"c1","uid":3051748,"ip_address":"","ucode":"07457D1C3664DD","user_header":"","comment_is_top":false,"comment_ctime":1658285737,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658285737","product_id":100056701,"comment_content":"拷贝的过程 同一个桶的entry列表会做拆分？这个拆分的规则是什么?我看没有讲到，有点不明白","like_count":0},{"had_liked":false,"id":351552,"user_name":"going","can_delete":false,"product_type":"c1","uid":2313353,"ip_address":"","ucode":"3AA83F9B07BE8B","user_header":"https://static001.geekbang.org/account/avatar/00/23/4c/89/82a3ee04.jpg","comment_is_top":false,"comment_ctime":1657885363,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657885363","product_id":100056701,"comment_content":"能够在随机访问提供优势","like_count":0},{"had_liked":false,"id":350334,"user_name":"弱水穿云天","can_delete":false,"product_type":"c1","uid":1190060,"ip_address":"","ucode":"80DC528A23ED7E","user_header":"https://static001.geekbang.org/account/avatar/00/12/28/ac/37a2a265.jpg","comment_is_top":false,"comment_ctime":1656824733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1656824733","product_id":100056701,"comment_content":"mark，非常好","like_count":0},{"had_liked":false,"id":349639,"user_name":"骑车上天空","can_delete":false,"product_type":"c1","uid":2756576,"ip_address":"","ucode":"364365E2721122","user_header":"https://static001.geekbang.org/account/avatar/00/2a/0f/e0/b53a7701.jpg","comment_is_top":false,"comment_ctime":1656169863,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1656169863","product_id":100056701,"comment_content":"rehash的时候，是等客户端请求处理完再拷贝数据，还是边处理请求，边拷贝数据？","like_count":0},{"had_liked":false,"id":349044,"user_name":"岳羊羊","can_delete":false,"product_type":"c1","uid":1984370,"ip_address":"","ucode":"DD68A1076C4657","user_header":"https://static001.geekbang.org/account/avatar/00/1e/47/72/e250bb02.jpg","comment_is_top":false,"comment_ctime":1655690630,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655690630","product_id":100056701,"comment_content":"有一个疑问，在rehash过程中，以图中例子的场景举例，如果当完成第一次数据拷贝后的状态下，如果有数据访问，这时redis在进行哈希计算的时候，是会根据哈希表一来计算还是会同时计算两个哈希表的哈希值呢？","like_count":0},{"had_liked":false,"id":348625,"user_name":"。。","can_delete":false,"product_type":"c1","uid":2853618,"ip_address":"","ucode":"A52A6043D27D87","user_header":"https://static001.geekbang.org/account/avatar/00/2b/8a/f2/6c6f7886.jpg","comment_is_top":false,"comment_ctime":1655262075,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655262075","product_id":100056701,"comment_content":"对于渐进式这块，不太理解，它不会造成两个哈希表数据不一致吗，例如新增操作，如果直接在 ht[1] 中新增，可能会导致 ht[0]、ht[1] 中数据不一致（ht[1] 中新增了一个跟 ht[0] 相同的 key 的数据），所以新增操作是不是应该先在 ht[0] 中找，如果有的话删除、或者修改 key，然后再在 ht[1] 中新增呢？","like_count":0},{"had_liked":false,"id":347541,"user_name":"孤独患者","can_delete":false,"product_type":"c1","uid":1137910,"ip_address":"","ucode":"4CDD797F355F99","user_header":"https://static001.geekbang.org/account/avatar/00/11/5c/f6/443808f8.jpg","comment_is_top":false,"comment_ctime":1654138913,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1654138913","product_id":100056701,"comment_content":"请教一个问题，什么时候会触发rehash，根据单个哈希桶中链表的长度吗？","like_count":0},{"had_liked":false,"id":345303,"user_name":"Holy","can_delete":false,"product_type":"c1","uid":1450982,"ip_address":"","ucode":"B039B0AB117396","user_header":"https://static001.geekbang.org/account/avatar/00/16/23/e6/12b3d2bf.jpg","comment_is_top":false,"comment_ctime":1652181211,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1652181211","product_id":100056701,"comment_content":"节省空间，在数据量不大的情况下 查询性能没那么明显","like_count":0},{"had_liked":false,"id":344244,"user_name":"凯文小猪","can_delete":false,"product_type":"c1","uid":1980201,"ip_address":"","ucode":"36D8AD0229547F","user_header":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","comment_is_top":false,"comment_ctime":1651393256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1651393256","product_id":100056701,"comment_content":"压缩列表转换阈值设定就是一个缓存行 可见一个缓存行内的数据 可以一次灌入cpu多级缓存。虽然三级缓存普遍是在总线一侧 但这个数量级对于民用领域其实无感。<br><br>再谈谈整形数组 set里面通常是两类数据 一类是int或是一个标准机器字 另一类是string。string类型因为天生无法确定其字节数 所以只能退化到hash来表示。但是int数组可以使用局部性原理来做适当加速。 <br>比方说 仍然以一个缓存行来说 64 byte &#47; 4 = 16. 我们可以在设计时 以16个为单位来设计我们的set","like_count":0},{"had_liked":false,"id":342358,"user_name":"Lotus","can_delete":false,"product_type":"c1","uid":1588679,"ip_address":"","ucode":"FDE1A67C0E6636","user_header":"https://static001.geekbang.org/account/avatar/00/18/3d/c7/47f89975.jpg","comment_is_top":false,"comment_ctime":1650206387,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650206387","product_id":100056701,"comment_content":"对于压缩列表，在 redis 5.0 版本中做了重新设计，使用一个新的数据结构 listpack 用于解决在压缩列表出现的 【连锁更新】","like_count":0},{"had_liked":false,"id":339597,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1648213032,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1648213032","product_id":100056701,"comment_content":"数组元素少的时候数组从空间及查询时间要比hash快。<br>","like_count":0},{"had_liked":false,"id":338340,"user_name":"imagpie","can_delete":false,"product_type":"c1","uid":2905751,"ip_address":"","ucode":"2F3016147AB007","user_header":"https://static001.geekbang.org/account/avatar/00/2c/56/97/f2d31fc0.jpg","comment_is_top":false,"comment_ctime":1647432215,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1647432215","product_id":100056701,"comment_content":"sorted set的底层实现的数据结构是不是有问题，如果只是压缩列表和跳表是如何保证的元素不重复呢","like_count":0},{"had_liked":false,"id":337772,"user_name":"imagpie","can_delete":false,"product_type":"c1","uid":2905751,"ip_address":"","ucode":"2F3016147AB007","user_header":"https://static001.geekbang.org/account/avatar/00/2c/56/97/f2d31fc0.jpg","comment_is_top":false,"comment_ctime":1647054569,"is_pvip":false,"discussion_count":0,"race_medal":2,"score":"1647054569","product_id":100056701,"comment_content":"老师您好，我有一个问题不是很理解，就是Sorted Set的底层数据结构是压缩列表和跳表，那它是如何保证的元素不重复的这个特定呢，是不是还要有一个额外的结构保证它的一个数据不重复的特性","like_count":0},{"had_liked":false,"id":336722,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1646312865,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646312865","product_id":100056701,"comment_content":"评论真的很精彩～～·","like_count":0},{"had_liked":false,"id":336721,"user_name":"William Ning","can_delete":false,"product_type":"c1","uid":1592279,"ip_address":"","ucode":"4DB8D05E69E5F3","user_header":"https://static001.geekbang.org/account/avatar/00/18/4b/d7/f46c6dfd.jpg","comment_is_top":false,"comment_ctime":1646312647,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1646312647","product_id":100056701,"comment_content":"网上查到：<br>dict，又称字典(dictionary)或映射(map)，是集合的一种；这种集合中每个元素都是KV键值对。<br>字典dict在各编程语言中都有体现，面向对象的编程语言如C++、Java中都称其为Map。","like_count":0},{"had_liked":false,"id":333324,"user_name":"数学汤家凤","can_delete":false,"product_type":"c1","uid":2029485,"ip_address":"","ucode":"DE84E777C384AD","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","comment_is_top":false,"comment_ctime":1644289340,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1644289340","product_id":100056701,"comment_content":"看了一下 redis6 的源码，list 好像不用 双向链表 和 压缩列表 了，改为用一个叫做快表（quick list）的数据结构","like_count":0},{"had_liked":false,"id":331608,"user_name":"佳正","can_delete":false,"product_type":"c1","uid":1181211,"ip_address":"","ucode":"86EFD9ABA56438","user_header":"https://static001.geekbang.org/account/avatar/00/12/06/1b/9485c290.jpg","comment_is_top":false,"comment_ctime":1642669444,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1642669444","product_id":100056701,"comment_content":"老师你好，我想了解一下 Redis 的 rehash 过程中，极端情况下 h1 在未完成 rehash 的情况下 hash 冲突严重需要再次 rehash，redis 是如何处理的呢？","like_count":0},{"had_liked":false,"id":331108,"user_name":"日月星辰","can_delete":false,"product_type":"c1","uid":1796332,"ip_address":"","ucode":"4E9F48153B2D8B","user_header":"https://static001.geekbang.org/account/avatar/00/1b/68/ec/eb0ebbb6.jpg","comment_is_top":false,"comment_ctime":1642427382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642427382","product_id":100056701,"comment_content":"跳表二级索引怎么只需要 3 次查找，就能定位到元素 33 了。","like_count":0},{"had_liked":false,"id":330540,"user_name":"鱼","can_delete":false,"product_type":"c1","uid":1487584,"ip_address":"","ucode":"89EC9CE3AD0281","user_header":"https://static001.geekbang.org/account/avatar/00/16/b2/e0/d856f5a4.jpg","comment_is_top":false,"comment_ctime":1642035912,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642035912","product_id":100056701,"comment_content":"这个渐进式Rehash的机制感觉是参考了操作系统的fork机制，全局Hash表有些像虚拟内存的页表，只不过fork需要阻塞复制一下这个页表，渐进式rehash似乎没这个问题。当子进程需要修改内存数据时，产生写保护中断，拷贝原来的物理页（这里是Bucket）到新的物理页上进行操作。","like_count":0},{"had_liked":false,"id":325946,"user_name":"The way","can_delete":false,"product_type":"c1","uid":2629052,"ip_address":"","ucode":"12A59C0798A2FF","user_header":"https://static001.geekbang.org/account/avatar/00/28/1d/bc/11b8722f.jpg","comment_is_top":false,"comment_ctime":1639274239,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639274239","product_id":100056701,"comment_content":"没太明白，数组和压缩列表的区别，可否理解为java中的list和数组，相对于数组，list只是对于count统计以及头尾数据取值时更快。","like_count":0},{"had_liked":false,"id":325660,"user_name":"宇智波鼬","can_delete":false,"product_type":"c1","uid":2415037,"ip_address":"","ucode":"893886790C7D86","user_header":"https://static001.geekbang.org/account/avatar/00/24/d9/bd/d65fa667.jpg","comment_is_top":false,"comment_ctime":1639065295,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639065295","product_id":100056701,"comment_content":"请问为何双向链表没有很大的时间复杂度优势 也会被采用呢","like_count":0},{"had_liked":false,"id":324658,"user_name":"Aprelude","can_delete":false,"product_type":"c1","uid":1658796,"ip_address":"","ucode":"840D3F7A35AEEF","user_header":"https://static001.geekbang.org/account/avatar/00/19/4f/ac/80439ba7.jpg","comment_is_top":false,"comment_ctime":1638529990,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638529990","product_id":100056701,"comment_content":"如果Redis存了很多数据，那不是这个数组会很长吗 内存有那么大的连续空间吗","like_count":0},{"had_liked":false,"id":324262,"user_name":"Yipsen","can_delete":false,"product_type":"c1","uid":2856313,"ip_address":"","ucode":"F0ECE8C12AF105","user_header":"","comment_is_top":false,"comment_ctime":1638351425,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1638351425","product_id":100056701,"comment_content":"查询快（连续内存），内存利用率高（连续碎片少）","like_count":0},{"had_liked":false,"id":323763,"user_name":"wessonwang","can_delete":false,"product_type":"c1","uid":1000441,"ip_address":"","ucode":"A9BA5E3A3F278E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/f9/723ee153.jpg","comment_is_top":false,"comment_ctime":1638154614,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1638154614","product_id":100056701,"comment_content":"整数数组、压缩列表的使用场景是 集合数据量较小时才使用，避免了链表、哈希等结构中节点存储大量的内存引用，减小内存使用。","like_count":0},{"had_liked":false,"id":323143,"user_name":"马志远","can_delete":false,"product_type":"c1","uid":1480892,"ip_address":"","ucode":"AAD8875343E5FC","user_header":"https://static001.geekbang.org/account/avatar/00/16/98/bc/6d5affd3.jpg","comment_is_top":false,"comment_ctime":1637743365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637743365","product_id":100056701,"comment_content":"1.内存--存储介质<br>2.数据结构--存储方式执行速度(数据结构和算法的时间复杂度的优化)<br>3.单线程的--CPU的并发缓解<br>4.网络模型epoll--网络(多路复用)<br>(CPU 和 存储 和 网络)","like_count":0},{"had_liked":false,"id":322209,"user_name":"tyy","can_delete":false,"product_type":"c1","uid":1302149,"ip_address":"","ucode":"C3B436E6562744","user_header":"https://static001.geekbang.org/account/avatar/00/13/de/85/da98e390.jpg","comment_is_top":false,"comment_ctime":1637237506,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637237506","product_id":100056701,"comment_content":"有个问题 这个哈希通的hash值怎么可能会冲突呢，使用的时候，设置redis值 key坑定是不一样的啊","like_count":0},{"had_liked":false,"id":320754,"user_name":"御道而行","can_delete":false,"product_type":"c1","uid":1232128,"ip_address":"","ucode":"2348E2B6B1EB40","user_header":"https://static001.geekbang.org/account/avatar/00/12/cd/00/32cca560.jpg","comment_is_top":false,"comment_ctime":1636504924,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636504924","product_id":100056701,"comment_content":"在Rehash的过程中，是哈希表1、哈希表2还是两个同时对外提供查询服务呢？从哈希表1复制到哈希表2的过程中如果不逐步释放复制的元素，是不是意味着在Rehash将要结束的时候，内存使用量是Rehash之前的两倍？Rehash结束的时候，释放了空间内存量就降下来了？<br>感觉这样不太合理...应该不是这样吧？","like_count":0},{"had_liked":false,"id":318839,"user_name":"Awarker","can_delete":false,"product_type":"c1","uid":2571577,"ip_address":"","ucode":"AEE3DB8EF133D1","user_header":"https://static001.geekbang.org/account/avatar/00/27/3d/39/e93e342e.jpg","comment_is_top":false,"comment_ctime":1635466452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635466452","product_id":100056701,"comment_content":"我想问下除了string其它数据类型都对应了两种底层数据实现，那他是什么时候选择用哪一种的呢，比如说list，他什么时候选择用双向链表，什么时候用压缩列表勒","like_count":0},{"had_liked":false,"id":317867,"user_name":"受超凡","can_delete":false,"product_type":"c1","uid":2678558,"ip_address":"","ucode":"A2A160D483BBB0","user_header":"","comment_is_top":false,"comment_ctime":1634999226,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634999226","product_id":100056701,"comment_content":"什么条件才会触发rehash呢？","like_count":0},{"had_liked":false,"id":317856,"user_name":"Geek_749c02","can_delete":false,"product_type":"c1","uid":2298310,"ip_address":"","ucode":"254C202A187579","user_header":"","comment_is_top":false,"comment_ctime":1634996211,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1634996211","product_id":100056701,"comment_content":"ziplist有它的用处，在集合元素个数在512(默认值)以内时，即使是都遍历一遍，也不会太耗时，所以可以用这种内存紧凑的数据结构，无伤大雅。<br>只有当元素个数很多的时候，遍历一遍集合这个操作的耗时数据就没那么好看了，单个工作线程去执行这个请求，可能会阻塞其他的客户端请求的及时响应","like_count":0},{"had_liked":false,"id":313920,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1632741453,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632741453","product_id":100056701,"comment_content":"redis为什么快？<br>第一，redis的数据储存在内存上，由于CPU和内存直连，所以数据存取速度很快<br>第二，redis的索引底层数据结构是哈希表，通过key定位value的时间复杂度为O(1)<br>第三，在不同的业务应用场景下，redis的value的底层数据结构的数据操作效率很高。哈希表查询时间复杂度O(1)、跳表查询时间复杂度O(logN)，压缩列表、双向链表、整数数组的时间复杂度为O(N)。<br><br>redis最终的数据操作复杂度取决于底层数据结构和操作本身的复杂度。具体来讲就是操作本身的复杂度乘以底层数据结构增删改善的复杂度。<br><br>操作本身的复杂度：<br>单元素操作是基础，等同于底层数据结构增删改善的复杂度<br>范围操作非常耗时，因为需要遍历查询数据底层数据结构<br>统计操作通常高效，因为数据类型中一般会记录数据的统计信息<br>例外情况只有几个，压缩列表和双向链表都会记录表头和表尾的偏移量，所以在头尾进行增删改查效率很高，时间复杂度为O(1)。<br><br>整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？<br>整数数组和压缩列表都是非常紧凑的数据结构，空间利用率高，CPU的局部性原理对于连续空间支持度好。","like_count":0},{"had_liked":false,"id":313767,"user_name":"孤鸿傲雪Geek_79dd4b","can_delete":false,"product_type":"c1","uid":1582649,"ip_address":"","ucode":"C0C3286D9E08D0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dLrfSKs4kCPyBVTKSkHcEPx3iaRoQGvj2ejyxydZODIMquOz1tape8gOX8FlWuRS5Ysibia3RQfZ8wjPJWmeW6Czg/132","comment_is_top":false,"comment_ctime":1632655211,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1632655211","product_id":100056701,"comment_content":"压缩列表查找的时间复杂度应该是o(1)吧，数组查找哇。","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400087,"discussion_content":"只是类似于数组，他没有下标","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633161975,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":312761,"user_name":"猪小擎","can_delete":false,"product_type":"c1","uid":1370959,"ip_address":"","ucode":"D9552746AE3327","user_header":"https://static001.geekbang.org/account/avatar/00/14/eb/4f/6a97b1cd.jpg","comment_is_top":false,"comment_ctime":1631971844,"is_pvip":true,"discussion_count":1,"race_medal":1,"score":"1631971844","product_id":100056701,"comment_content":"第三课了，还没有看到讲源码，这个课是讲源码的吗？zlbytes，zllen，这些也没有在源码里搜索到，是结果在最新的redis里已经改掉了吗？","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400088,"discussion_content":"出门左拐，《redis源码剖析与实战》","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633162025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":310357,"user_name":"TerryGoForIt","can_delete":false,"product_type":"c1","uid":1020644,"ip_address":"","ucode":"701B0E72F15AB5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/e4/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1630630698,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630630698","product_id":100056701,"comment_content":"有序数组的操作效率应该比跳表要高吧，为什么redis里不用数组替代跳表呢？是因为在添加删除元素的时候，内存消耗比较大么","like_count":0},{"had_liked":false,"id":310275,"user_name":"威","can_delete":false,"product_type":"c1","uid":1068542,"ip_address":"","ucode":"C921CDCB22B9A3","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/fe/882eaf0f.jpg","comment_is_top":false,"comment_ctime":1630575518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630575518","product_id":100056701,"comment_content":"老师你好，最近在看redis 6.0的源码，发现List底层已经不用ziplist了，都采用了quicklist来实现，不知道是否正确呢","like_count":0},{"had_liked":false,"id":310054,"user_name":"Lee","can_delete":false,"product_type":"c1","uid":1344535,"ip_address":"","ucode":"6B8D59A0B1A1A9","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqOn7k48KXia5rf0eXpzv2EGtqGibz3eNb8QnL8X72uia0g1rBwzXef4dV2JEdz3r4bu9GC1FLIeic4UA/132","comment_is_top":false,"comment_ctime":1630472671,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1630472671","product_id":100056701,"comment_content":"请问一下，如何能确定hash表1中渐进式拷贝已经完成，能切换到新的hash表2？","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400091,"discussion_content":"表1空了就算完成了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633162755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":309732,"user_name":"自由","can_delete":false,"product_type":"c1","uid":2576960,"ip_address":"","ucode":"4E3B53D29D86CA","user_header":"https://static001.geekbang.org/account/avatar/00/27/52/40/db9b0eb2.jpg","comment_is_top":false,"comment_ctime":1630315534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630315534","product_id":100056701,"comment_content":"整数数组可能存在部分内存浪费，因为数组中所有元素大小，需要以最大的元素为主，例如 20kb，此时存储的数据小于 20kb 时，就造成了内存的浪费。","like_count":0},{"had_liked":false,"id":309668,"user_name":"自由","can_delete":false,"product_type":"c1","uid":2576960,"ip_address":"","ucode":"4E3B53D29D86CA","user_header":"https://static001.geekbang.org/account/avatar/00/27/52/40/db9b0eb2.jpg","comment_is_top":false,"comment_ctime":1630295312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1630295312","product_id":100056701,"comment_content":"请问全局哈希表中，一个 key 不是对应一个哈希桶吗，为什么 key 的数量会大于哈希桶？<br>是指的 key 会不断新增，在未扩容的前提下，哈希桶数量是固定的，这种情况下会出现  key 的数量会大于哈希桶吗？","like_count":0},{"had_liked":false,"id":308286,"user_name":"彭文达","can_delete":false,"product_type":"c1","uid":1801058,"ip_address":"","ucode":"8DCC27EC5AF263","user_header":"https://static001.geekbang.org/account/avatar/00/1b/7b/62/ec94cee4.jpg","comment_is_top":false,"comment_ctime":1629517567,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1629517567","product_id":100056701,"comment_content":"跳表的地方感觉有问题，一级索引的情况下首先是1-&gt; 11-&gt;27-&gt;50-&gt;27-&gt;33，上面为啥50之后可以直接跳到下一层的27，我猜想应该保存了上一个节点的数据，发现当前节点大于要找的数据，就通过保存的上个节点往下沉去找，所以我觉得一共是6次查询节点，数据量大才能体现出跳表的优势","like_count":0,"discussions":[{"author":{"id":1812727,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/a8/f7/de277dee.jpg","nickname":"chuck115","note":"","ucode":"253A8BB5867A2D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411456,"discussion_content":"我也有这个疑问，后来这么理解的，他把移动当前节点算作一次访问，获取当前节点的下个元素的值没有算作一次访问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635933125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":307089,"user_name":"andy","can_delete":false,"product_type":"c1","uid":1154153,"ip_address":"","ucode":"66FA6DABD5BD3B","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/69/d16ea710.jpg","comment_is_top":false,"comment_ctime":1628855026,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1628855026","product_id":100056701,"comment_content":"list   双向链表  压缩列表<br>hash  压缩列表  哈希表<br>set  哈希表  整数数组<br>sortset  压缩列表  跳表<br>string  简单字符串<br><br>key  value  键值对采用哈希表<br>会出现哈希冲突，当冲突后引入了哈希冲突链  冲突越来越多后  查询效率变低  引入了hash  refresh  <br>refresh原理是建更多的桶让冲突分布到不同的桶中  全局哈希表1，全局哈希表2<br>refresh的时候  将表2扩大一倍 然后表1复制到表2  表二变为主  这是如果数据多会发生阻塞  又引入了渐进式refresh  伴随着数据读取每次将读取到的数据所在的hash桶  复制到表2<br><br>压缩列表，比数组多了三个字段可以直接计算出第一个和最后一个元素。<br>跳表  引入了二级索引<br><br><br>问题 <br>1 哈希冲突的时候  哈希值都一样，怎么放到不同的桶中<br>2 渐进式refresh  表一表二何时切换。查询是两个表都查？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391161,"discussion_content":"1.hash值一样肯定是放到一个桶里面去了 2.dictExpand的时候切换的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630323720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306899,"user_name":"Six Days","can_delete":false,"product_type":"c1","uid":1322463,"ip_address":"","ucode":"8587F2EEFFFD11","user_header":"https://static001.geekbang.org/account/avatar/00/14/2d/df/4949b250.jpg","comment_is_top":false,"comment_ctime":1628767346,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1628767346","product_id":100056701,"comment_content":"当rehash 的时候，是不是同样的key全部迁移到对应的t桶里面，而不是打散到分开存储到新的hash表里。例如渐进hash的时候，第一次拷贝和第二次拷贝 entry3 是不是应该还是在桶1里面，而不是在桶5里面？ ","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391162,"discussion_content":"你的问题是老的一个桶里面的所有key整体移到新的一个相同桶里面？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630323905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305910,"user_name":"托马斯赵四","can_delete":false,"product_type":"c1","uid":2712653,"ip_address":"","ucode":"F9FA980A9F8A1C","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/kBKTRyV4wnhV4YN9iaFgKYIJ4451n0zIiazFumcSpCXdEDhdexgc8PQdrDEmy4BCOUgsUlibicEwQlGo6K5Nibv7SEg/132","comment_is_top":false,"comment_ctime":1628228245,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628228245","product_id":100056701,"comment_content":"扩容的原理是不是也是这样的呢","like_count":0},{"had_liked":false,"id":305567,"user_name":"死磕二郎","can_delete":false,"product_type":"c1","uid":2124811,"ip_address":"","ucode":"FB466E1056EB6F","user_header":"","comment_is_top":false,"comment_ctime":1628048587,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1628048587","product_id":100056701,"comment_content":"数组访问的时间复杂度是O(1)，压缩列表类似数组，但是书上说压缩列表访问的时间复杂度时O(n)，这怎么解释呢","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391163,"discussion_content":"那是知道数组下标了去访问，只知道数组里面的具体值要求匹配就不是了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630323976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":305035,"user_name":"走路顺拐","can_delete":false,"product_type":"c1","uid":1987040,"ip_address":"","ucode":"82D19A53DCB14E","user_header":"","comment_is_top":false,"comment_ctime":1627785917,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627785917","product_id":100056701,"comment_content":"就 没明白  整数数据与压缩列表区别","like_count":0},{"had_liked":false,"id":305022,"user_name":"Geek_6580e3","can_delete":false,"product_type":"c1","uid":2071189,"ip_address":"","ucode":"EBA5D606A268A5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKrAnvnf7bm30wuzkns2eLt15libqTv5ardAAQZNx67NuHPzib0kVXaFHGHE7IE19IiargjtWJgC9D9g/132","comment_is_top":false,"comment_ctime":1627782055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627782055","product_id":100056701,"comment_content":"整型数组的随机访问是O（1），这边要顺序访问O（n）是什么原因","like_count":0},{"had_liked":false,"id":303489,"user_name":"小贩2","can_delete":false,"product_type":"c1","uid":2310596,"ip_address":"","ucode":"B25492AEE9FF6D","user_header":"https://static001.geekbang.org/account/avatar/00/23/41/c4/fc77e3ad.jpg","comment_is_top":false,"comment_ctime":1626829365,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626829365","product_id":100056701,"comment_content":"请问为啥没有quicklist这个数据结构？","like_count":0},{"had_liked":false,"id":303373,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1626758529,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1626758529","product_id":100056701,"comment_content":"毕竟整数数组在创建的时候,往往会在内存中分配一个连续的大空间,在进行遍历的时候,CPU可以将其大量读入CPU缓存,避免了内存地址多次查找映射","like_count":0},{"had_liked":false,"id":300997,"user_name":"冰点","can_delete":false,"product_type":"c1","uid":2070530,"ip_address":"","ucode":"06DCC1FF869988","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/ZrPfqw4AbHd2F4VzplicZiatLg4AgibVhEVZH4qQoia9fx9MVG4IiaWjFlibXVibFibnmTfhibyBmG40NgeJAZey7j0ZvFg/132","comment_is_top":false,"comment_ctime":1625479735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625479735","product_id":100056701,"comment_content":"我用 object  encoding  查看存储编码发现字符串类型的存储编码有的时候是embstr 有的时候是int","like_count":0},{"had_liked":false,"id":300678,"user_name":"生之欢愉，时间同行","can_delete":false,"product_type":"c1","uid":1419468,"ip_address":"","ucode":"A95FA52F464A05","user_header":"https://static001.geekbang.org/account/avatar/00/15/a8/cc/ebebfd03.jpg","comment_is_top":false,"comment_ctime":1625302124,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1625302124","product_id":100056701,"comment_content":"老师，在看到rehash的过程时，有一个疑问请教一下，如果以一个key请求过来了，Redis时如何处理的？难道是先在hash表1上对应的哈希桶查找一遍，没有找到以后再去哈希表2上查找吗？如果rehash以后，请求量降低了，Redis会一直保持两个哈希表都有数据吗？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391165,"discussion_content":"数据不会俩表都有的，rehash过程不是拷贝是移动","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630324178,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2457595,"avatar":"","nickname":"Geek_0586b4","note":"","ucode":"8D8FE06BE26083","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390364,"discussion_content":"老师有在评论区回答过\nrehash的时候，会有个默认线程周期性搬移数据到新的哈希表\n有查找请求的话会在哈希表1查，没有就会查哈希表2\n哈希表2数据会一直增加 哈希表1数据一直会减少直到变空，有个参数rehashidxx变-1似乎rehash就结束了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629800381,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300533,"user_name":"if...else...","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1625208535,"is_pvip":false,"discussion_count":0,"race_medal":4,"score":"1625208535","product_id":100056701,"comment_content":"学习了","like_count":0},{"had_liked":false,"id":298297,"user_name":"家乐","can_delete":false,"product_type":"c1","uid":1301941,"ip_address":"","ucode":"94F8720B59F221","user_header":"https://wx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEJia90ErsTQtNDNeyTWNwWjicERicXj72b4xgbvru2IkUdrLxrgJb5lCrTaiaW2iaX3mOYiaV8vYo3voWlg/132","comment_is_top":false,"comment_ctime":1624005549,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624005549","product_id":100056701,"comment_content":"真的受益良多。虽然没有把整理内容贴出来，看老师和各位同学的发言和评论，很受益！感谢！极客的课程都是精品。","like_count":0},{"had_liked":false,"id":297721,"user_name":"Ivan.Qi","can_delete":false,"product_type":"c1","uid":1099170,"ip_address":"","ucode":"36F46A4D1F0EAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/a2/4ece341b.jpg","comment_is_top":false,"comment_ctime":1623746612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623746612","product_id":100056701,"comment_content":"Redis2 和 Redis5数据结构<br>https:&#47;&#47;github.com&#47;Ivanqi&#47;RedisDataStructure<br>","like_count":0},{"had_liked":false,"id":296605,"user_name":"呵呵哒","can_delete":false,"product_type":"c1","uid":2234743,"ip_address":"","ucode":"CEC8B421BB564A","user_header":"https://static001.geekbang.org/account/avatar/00/22/19/77/3ca9f42d.jpg","comment_is_top":false,"comment_ctime":1623060011,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1623060011","product_id":100056701,"comment_content":"老师，redis的Hash数据类型如果采用压缩列表的数据结构进行存储数据，那查找单一数据的时间复杂度不也是o(n)吗？<br>","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391167,"discussion_content":"使用压缩列表也是有前提的，数量少而且长度也不大，超过阀值还是会用hash来构建。时间复杂度提升了，但是因为压缩列表是连续的内存分配，内存利用率高，对cpu缓存友好的，加上数据量少，一定程度上提升性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630324405,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294704,"user_name":"Geek1185","can_delete":false,"product_type":"c1","uid":2028954,"ip_address":"","ucode":"47BEE492EF4C1A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f5/9a/63dc81a2.jpg","comment_is_top":false,"comment_ctime":1622050308,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1622050308","product_id":100056701,"comment_content":"请问下老师，redis底层整个作为全局哈希表的实现和它的value作为哈希表实现原理上一样的吗","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391168,"discussion_content":"一样","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630324421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293238,"user_name":"大力水手Jerry","can_delete":false,"product_type":"c1","uid":1227840,"ip_address":"","ucode":"E4A6C71E275DB5","user_header":"https://static001.geekbang.org/account/avatar/00/12/bc/40/2279cfb5.jpg","comment_is_top":false,"comment_ctime":1621300593,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621300593","product_id":100056701,"comment_content":"每课一问：时间复杂度的确没有优势，但在N很小（即键对应的值的容量）的情况下，操作该值的耗时并不比低时间复杂度的数据结构和算法高，比如时间复杂度为N和LogN的情况下，在N&lt;5时两者相差无几，但如算上数据装载的前置时间，时间复杂度为N的数据结构和算法往往更快。更重要的是，具有更小的空间复杂度，而键值对是非常多的情况下，一方面能省下很多空间，另一方面紧凑的数据结构对CPU计算更友好。<br>","like_count":0},{"had_liked":false,"id":293034,"user_name":"持#樞","can_delete":false,"product_type":"c1","uid":1475876,"ip_address":"","ucode":"2974D70A62A406","user_header":"https://static001.geekbang.org/account/avatar/00/16/85/24/98d00055.jpg","comment_is_top":false,"comment_ctime":1621163446,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1621163446","product_id":100056701,"comment_content":"如果rehash的时候断电 ，还能恢复吗~~~渐进式rehash会同步到日志吗","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391169,"discussion_content":"内存数据库断电了，数据都没了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630324492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291508,"user_name":"南荣牧歌","can_delete":false,"product_type":"c1","uid":1765050,"ip_address":"","ucode":"2DFD9B50955C5A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ee/ba/ac07d5a4.jpg","comment_is_top":false,"comment_ctime":1620312483,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1620312483","product_id":100056701,"comment_content":"哈希桶和哈希槽有什么区别呢？哈希桶初始化默认是多少呢？","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400094,"discussion_content":"没什么区别叫法不同，默认4，每次rehash扩容2倍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633163453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291431,"user_name":"南荣牧歌","can_delete":false,"product_type":"c1","uid":1765050,"ip_address":"","ucode":"2DFD9B50955C5A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ee/ba/ac07d5a4.jpg","comment_is_top":false,"comment_ctime":1620285486,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1620285486","product_id":100056701,"comment_content":"有一个问题，渐进式rehash的过程中，是不是不到以后一个哈希桶，没有完成rehash，就不会使用新的哈希表，另外触发新一次的整体rehash的时机是什么？","like_count":0,"discussions":[{"author":{"id":2420294,"avatar":"https://static001.geekbang.org/account/avatar/00/24/ee/46/7d65ae37.jpg","nickname":"木几丶","note":"","ucode":"FFDB958DA64F8C","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400096,"discussion_content":"第一个问题没看懂\nrehash时机是：节点总数>=字典大小&amp;&amp;没有aof rdb进程在跑，或者节点总数>字典大小*5；可以参考redis源码 dict.c  _dictExpandIfNeeded函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633163715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291421,"user_name":"南荣牧歌","can_delete":false,"product_type":"c1","uid":1765050,"ip_address":"","ucode":"2DFD9B50955C5A","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ee/ba/ac07d5a4.jpg","comment_is_top":false,"comment_ctime":1620283711,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620283711","product_id":100056701,"comment_content":"这篇文章讲的真好，很全面，系统","like_count":0},{"had_liked":false,"id":290597,"user_name":"CrazyCodes","can_delete":false,"product_type":"c1","uid":1081205,"ip_address":"","ucode":"C9C0E72522EB5B","user_header":"https://static001.geekbang.org/account/avatar/00/10/7f/75/551c5d6c.jpg","comment_is_top":false,"comment_ctime":1619656817,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619656817","product_id":100056701,"comment_content":"Rehash时，要更改hash算法的规则吧。否则挪过去还是那样","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391171,"discussion_content":"hash值不变，变得是取模的桶数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630324607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290396,"user_name":"Ryze","can_delete":false,"product_type":"c1","uid":2597183,"ip_address":"","ucode":"5722BE46530760","user_header":"https://static001.geekbang.org/account/avatar/00/27/a1/3f/4465c544.jpg","comment_is_top":false,"comment_ctime":1619525264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619525264","product_id":100056701,"comment_content":"是不是在范围查找上，数组和压缩列表更有优势呢","like_count":0},{"had_liked":false,"id":289989,"user_name":"思维决定未来","can_delete":false,"product_type":"c1","uid":1412891,"ip_address":"","ucode":"88CC245B3C6E2D","user_header":"","comment_is_top":false,"comment_ctime":1619311872,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1619311872","product_id":100056701,"comment_content":"两个问题，1. 第一个图里面哈希桶里面的键写的*key，是不是说明键也是存的指针，如果是的话，怎么找到键指针呢？2.当出现哈希冲突的时候，多个值存在同一个哈希桶，但是键哈希都一样，怎么知道值是哪个呢？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391173,"discussion_content":"*key和*value都是指针而且都属于一个dictht对象。rehash一次最少也是一个桶不区分里面多个值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630324791,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289468,"user_name":"skaleto","can_delete":false,"product_type":"c1","uid":1103123,"ip_address":"","ucode":"BF99A5C2D8EB5F","user_header":"https://static001.geekbang.org/account/avatar/00/10/d5/13/83982734.jpg","comment_is_top":false,"comment_ctime":1619025457,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619025457","product_id":100056701,"comment_content":"空间换时间","like_count":0},{"had_liked":false,"id":289264,"user_name":"suntj","can_delete":false,"product_type":"c1","uid":2312457,"ip_address":"","ucode":"4A0A9F7619E765","user_header":"https://static001.geekbang.org/account/avatar/00/23/49/09/bc54d395.jpg","comment_is_top":false,"comment_ctime":1618960318,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1618960318","product_id":100056701,"comment_content":"rehash时，怎么判断是否复制完entry，下次请求直接使用哈希表2","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391174,"discussion_content":"rehash时都是先查表2的。判断一个桶迁移完靠当前处理entry的next指针，指针为空则处理完","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630324973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288405,"user_name":"小睡睡","can_delete":false,"product_type":"c1","uid":1102838,"ip_address":"","ucode":"049091D752DE29","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/f6/d9ecf4ea.jpg","comment_is_top":false,"comment_ctime":1618457479,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1618457479","product_id":100056701,"comment_content":"请问  hash桶中存的是key的指针  和值的指针  那怎么比对是不是要寻找的那个key呢？  每一个比对都是根据指针去寻址吗？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391177,"discussion_content":"key计算hash值后定位到具体的桶，桶里面的链表就需要挨个比对指针寻址后的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630325092,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287952,"user_name":"del","can_delete":false,"product_type":"c1","uid":1198870,"ip_address":"","ucode":"96C732A55B3837","user_header":"https://static001.geekbang.org/account/avatar/00/12/4b/16/e78d527e.jpg","comment_is_top":false,"comment_ctime":1618233627,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1618233627","product_id":100056701,"comment_content":"哈希冲突那地方没看太懂。如果KEY+VALUE 计算成哈希值会有重复冲突 然后用链表来解决冲突 那既然计算哈希已经冲突了 怎么知道链表哈希中 哪个是对应的当前KEY+VALUE呢","like_count":0,"discussions":[{"author":{"id":1199438,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4d/4e/5a20fe28.jpg","nickname":"c","note":"","ucode":"E1E383485EBF77","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":368895,"discussion_content":"key+value计算出来的hash相等，那需要进行二次判断吧，如果确认了key和value完全相等，那么可以复用之前的节点，没必要新增啊，否则增加新的节点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618876567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":287930,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1618220952,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618220952","product_id":100056701,"comment_content":"每一种数据结构都有它使用的特定情况：<br>如果数据不多，压缩列表和整数数组的优势是在空间上比较紧凑，这样就不会出现内存碎片，对内存的利用率比较高，查找复杂度也不会很高。所以收益是最大的。随着数据量的增大两者查找所用的性能就会降低，这个时候使用哈希表和跳表性能会比较好一点。","like_count":0},{"had_liked":false,"id":287888,"user_name":"keep_it_real","can_delete":false,"product_type":"c1","uid":2055554,"ip_address":"","ucode":"F5057CAF752FF3","user_header":"https://static001.geekbang.org/account/avatar/00/1f/5d/82/81b2ba91.jpg","comment_is_top":false,"comment_ctime":1618208497,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618208497","product_id":100056701,"comment_content":"老师“如果你只是了解了哈希表的 O(1) 复杂度和快速查找特性”这句话我觉得是不对的，数组查找的时间复杂度是O(n)的,因为查找某个元素需要遍历数组，通过index随机访问的时间复杂度是O(1)。我觉得您的意思应该是“随机访问”。","like_count":0},{"had_liked":false,"id":287450,"user_name":"郑家豪","can_delete":false,"product_type":"c1","uid":1864366,"ip_address":"","ucode":"8389742F41782E","user_header":"https://static001.geekbang.org/account/avatar/00/1c/72/ae/87ab63f6.jpg","comment_is_top":false,"comment_ctime":1617956501,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617956501","product_id":100056701,"comment_content":"hash查询的方式是通过key进行hash计算，得到一个hash值，通过这个值在全局hash里找到key对应entry，再在entry里找到key对应的内存空间指针得到值，流程是这样的么？","like_count":0},{"had_liked":false,"id":287392,"user_name":"Kuls","can_delete":false,"product_type":"c1","uid":1424048,"ip_address":"","ucode":"F80C5E17B30E53","user_header":"https://static001.geekbang.org/account/avatar/00/15/ba/b0/5e49cd49.jpg","comment_is_top":false,"comment_ctime":1617929914,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617929914","product_id":100056701,"comment_content":"老师可以解释一下吗？<br><br>如果在数组上是随机访问，对CPU高速缓存还友好不？","like_count":0},{"had_liked":false,"id":286880,"user_name":"而立斋","can_delete":false,"product_type":"c1","uid":1087258,"ip_address":"","ucode":"5FED6E9E148195","user_header":"https://static001.geekbang.org/account/avatar/00/10/97/1a/389eab84.jpg","comment_is_top":false,"comment_ctime":1617667491,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617667491","product_id":100056701,"comment_content":"其实所谓不同的数据结构都是在基础结构之上的封装，为了能够方便在特定场景下使用而提供的官方解决方案。<br><br>整数数组的底层实现为数组,这个数组以有序、无重复的方式保存集合元素,在有需要时,程序会根据新添加元素的类型,改变这个数组的类型。<br><br>压缩列表是为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型(sequential)数据结构","like_count":0},{"had_liked":false,"id":286337,"user_name":"河东练狮吼","can_delete":false,"product_type":"c1","uid":1306487,"ip_address":"","ucode":"E6CD2BC01CAD7A","user_header":"https://static001.geekbang.org/account/avatar/00/13/ef/77/d2a3f88b.jpg","comment_is_top":false,"comment_ctime":1617260663,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1617260663","product_id":100056701,"comment_content":"老师，我有一个疑问？文中提到，redis在做rehash过程中，通过复制算法，将原哈希表中的数据，rehash到扩容后的哈希表中，为了不影响redis的正常请求，会在每次请求过程中，拷贝一个哈希桶中的Entries。我的问题就是：拷贝过程中，新的写请求数据是写入到hash1原表中，还是扩容后的hash2表中？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391183,"discussion_content":"hash2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630325222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285476,"user_name":"Michael","can_delete":false,"product_type":"c1","uid":1274787,"ip_address":"","ucode":"C233DF1D224EC1","user_header":"https://static001.geekbang.org/account/avatar/00/13/73/a3/2b077607.jpg","comment_is_top":false,"comment_ctime":1616832119,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1616832119","product_id":100056701,"comment_content":"老师，你好！我有两个问题：<br>1、scan操作在单机、主从、哨兵、集群模式下都是可以的吗？之前我们在开发业务代码中涉及遍历操作时，发现scan操作在集群模式下不支持，单机模式下是支持的；在非单机模式线下如何遍历操作 ？<br>2、List的底层采用的是双向列表还是压缩列表？","like_count":0},{"had_liked":false,"id":284837,"user_name":"Tom","can_delete":false,"product_type":"c1","uid":1908926,"ip_address":"","ucode":"0BA98E780BB34C","user_header":"https://static001.geekbang.org/account/avatar/00/1d/20/be/bf6a570f.jpg","comment_is_top":false,"comment_ctime":1616492518,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616492518","product_id":100056701,"comment_content":"老师，请问在rehash 操作过程中，是如何保证对外提供正常服务的？比如此时有对key的新增，更新，查询或删除操作。","like_count":0},{"had_liked":false,"id":284344,"user_name":"ppingfann","can_delete":false,"product_type":"c1","uid":1242999,"ip_address":"","ucode":"38DE7D2F6D22E4","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo435IStLENgI45dWOow9gPDh8RcqvuCOLp30XqLJK3wqmwO7QKRLx8sMg9eucMKnJdjwickrAQMBw/132","comment_is_top":false,"comment_ctime":1616204083,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616204083","product_id":100056701,"comment_content":"老师你好，我想问一下，集合类型的数据都是有两种底层的数据结构，那么Redis到底使用这两种哪种数据结构实现的呢？还是说两种数据结构都会同时存在呢？","like_count":0},{"had_liked":false,"id":283632,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1615860823,"is_pvip":true,"discussion_count":0,"race_medal":2,"score":"1615860823","product_id":100056701,"comment_content":"Redis 的快（微妙级）一是因为内存，而是因为数据结构。<br><br>Redis → 哈希表&#47;哈希桶 → 指针<br><br>采用两个全局哈希表，来提高 rehash 的效率，应该算是以空间换时间了；然后用通过渐进式哈希，拉长了 rehash 的时间，或者说降低了频率，分散了拷贝处理。<br><br>看到这里感觉和 Elasticsearch 中的一些处理思路上有些相近的地方，发现瓶颈、找到方法、解决问题。Redis 和 Elasticsearch 似乎在底层技术上都没有什么特别的创新，但是在工程应用上的优化做的非常好。<br><br>回到隔壁重读了《17 | 跳表：为什么Redis一定要用跳表来实现有序集合？》<br><br>Redis 中有序跳表的核心操作是插入、删除、查找一个数据，迭代输出有序序列，按照区间查找数据。其中插入、删除、查找一个数据，迭代输出有序序列用红黑树也可以完成，但是区间查找数据还是跳表的效率更高。另外，感觉跳表更容易理解和代码实现。<br><br>大部分单元素操作和统计操作只有 O(1) 的时间复杂度，这个是否就是 Redis 崛起的关键？<br><br>集合类型的范围操作，最好使用 SCAN，避免全集合遍历；<br>复杂度较高的 List 类型，POP&#47;PUSH 效率很高，主要用于 FIFO 队列，而不是随机读写；<br><br>对于课后题目，整数数组应该是在应用中使用的比较多的一种，所以值得单独拿出来作为底层数据结构；而压缩列表可能是为了节约存储空间考虑，内存虽然一直在降价，但是仍然不便宜。<br><br>留言里面 @樱花落花 提到的使用压缩列表可以减少内存碎片，确实是之前没有考虑到的。<br><br>有点好奇，为什么这一篇的留言特别多？","like_count":0},{"had_liked":false,"id":283365,"user_name":"UnKnown","can_delete":false,"product_type":"c1","uid":2310053,"ip_address":"","ucode":"6E0A77E5276843","user_header":"https://static001.geekbang.org/account/avatar/00/23/3f/a5/7da6f7c4.jpg","comment_is_top":false,"comment_ctime":1615729507,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615729507","product_id":100056701,"comment_content":"在rehash 的过程中如果有put 操作，那么是先put到表2上，然后copy表1对应位置的entry，还是先copy表1对应数据到表2，然后再put到表2","like_count":0},{"had_liked":false,"id":283247,"user_name":"喃寻","can_delete":false,"product_type":"c1","uid":1565085,"ip_address":"","ucode":"E31B3660726671","user_header":"https://static001.geekbang.org/account/avatar/00/17/e1/9d/3ec0adec.jpg","comment_is_top":false,"comment_ctime":1615643219,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1615643219","product_id":100056701,"comment_content":"Redis全局哈希表的长度默认是多少?","like_count":0},{"had_liked":false,"id":283134,"user_name":"梁聪明","can_delete":false,"product_type":"c1","uid":2053611,"ip_address":"","ucode":"712FAD6E071585","user_header":"https://static001.geekbang.org/account/avatar/00/1f/55/eb/a441eda8.jpg","comment_is_top":false,"comment_ctime":1615565802,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615565802","product_id":100056701,"comment_content":"卑微提问：全局哈希表的rehash有一个小疑问<br>如果哈希表2空间不足时需要rehash，请问还是扩容2倍吗？<br>如果扩容那是直接扩容哈希表1吗？","like_count":0},{"had_liked":false,"id":282869,"user_name":"阿牛","can_delete":false,"product_type":"c1","uid":1073236,"ip_address":"","ucode":"DC8C189FCF3289","user_header":"https://static001.geekbang.org/account/avatar/00/10/60/54/b3eb605b.jpg","comment_is_top":false,"comment_ctime":1615448189,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1615448189","product_id":100056701,"comment_content":"【每日打卡】<br>一、通过数据类型操作的“快”与“慢”来映射Redis的底层数据结构，<br>二、数据类型与数据结构的关系<br>1、string：简单动态字符串<br>2、list：双向链表，压缩列表<br>3、hash：压缩列表，哈希表<br>4、Sorted Set：压缩列表，跳表<br>5、set：哈希表，整数数组<br>整数数组、双向链表：分配连续的内存空间，顺序读写，逐个访问，复杂度为O(N)。<br>压缩列表：压缩列表在表头有三个字段zlbytes,zltail和zllen分别表示长度，列表尾的偏移量和列表中的entry的个数，压缩列表尾部还有一个zlend，表示列表结束。头尾操作复杂度为O(1)，其他节点为O(N)。<br>跳表：是在链表的基础上增加了多级索引，通过索引的几次跳转，实现数据快速定位。<br>三、哈希：<br>1、哈希桶的概念；Redis使用一个哈希表保存所有键值对，一个哈希表实则是一个数组，数组的每个元素称为哈希桶。哈希桶中的元素保存的不是值的本身，而是指向具体值的指针。<br>2、一个哈希值中存储多个元素是通过链式哈希的方式，其复杂度是O(N)<br>3、当哈希冲突链过长时会触发Rehash操作，Rehash通过哈希表1、哈希表2（哈希表1的2倍）拷贝映射的方式实现扩容；<br>四、操作复杂度：<br>• 单元素操作是基础；<br>• 范围操作非常耗时；<br>• 统计操作通常高效；<br>• 例外情况只有几个；<br>五、交流区汇总：<br>1、渐进式Rehash：有定时同步机制解决数据不同步问题；删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行，但是添加操作只会在哈希1中；<br>2、由于CPU预读机制的原理，可以将连续的数据读取至cache中，提高连续读取性能；","like_count":0},{"had_liked":false,"id":282032,"user_name":"陌兮","can_delete":false,"product_type":"c1","uid":1415619,"ip_address":"","ucode":"00CE47CAECD5CD","user_header":"https://static001.geekbang.org/account/avatar/00/15/99/c3/e4f408d4.jpg","comment_is_top":false,"comment_ctime":1615022510,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1615022510","product_id":100056701,"comment_content":"看的真是激动人心，停不下来啊","like_count":0},{"had_liked":false,"id":281802,"user_name":"何磊","can_delete":false,"product_type":"c1","uid":1047604,"ip_address":"","ucode":"78934C3ED4A342","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/34/c733b116.jpg","comment_is_top":false,"comment_ctime":1614908255,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614908255","product_id":100056701,"comment_content":"在rehash环节的介绍中我有两个疑问：<br>1. rehash过程中如果hash表1有新的元素插入，此时hash表2也是做同步插入吗？<br>2. 渐进式hash怎么标记rehash过程完成的？以及完成后hash表1是直接free内存吗？","like_count":0},{"had_liked":false,"id":280486,"user_name":"Geek_d00e85","can_delete":false,"product_type":"c1","uid":2455225,"ip_address":"","ucode":"79A2D95C1D5FB1","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJXib1Wiaj6KKtwwJR6ZhNjh26pIWYCe0MUZIIz7gmAAicW8gKaRn2ibNUSr7APVF3fRGBmzWITQnBt8w/132","comment_is_top":false,"comment_ctime":1614232461,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614232461","product_id":100056701,"comment_content":"之所以保留链表和压缩里诶包，还是因为这两类、压缩列表方便插入、也方便寻找头一个、最后一个值，而且适合模拟队列、栈。","like_count":0},{"had_liked":false,"id":279471,"user_name":"pippin","can_delete":false,"product_type":"c1","uid":1784022,"ip_address":"","ucode":"F7619FCE24D481","user_header":"","comment_is_top":false,"comment_ctime":1613795071,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613795071","product_id":100056701,"comment_content":"想问两个问题，1、我看很多文章写的是redis的字典类型的扩容机制是则ht[1]的大小为第一个大于等于等于ht[0].used*2的2^n；而这文章写的是原数组的两倍。2、等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：这句话是不是指的在执行rehash的定时任务","like_count":0},{"had_liked":false,"id":279299,"user_name":"pippin","can_delete":false,"product_type":"c1","uid":1784022,"ip_address":"","ucode":"F7619FCE24D481","user_header":"","comment_is_top":false,"comment_ctime":1613712755,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613712755","product_id":100056701,"comment_content":"还是不是很理解，为什么压缩列表和整数数组的查询复杂度是O(N)，数组的查询复杂度不是O(1)的吗","like_count":0},{"had_liked":false,"id":279263,"user_name":"loma","can_delete":false,"product_type":"c1","uid":2298937,"ip_address":"","ucode":"C5CFC3F0D06000","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoCl6Nxf9oW9tBOaJlH7JqNIiabF8eqMqK1uRhwabXBU3j6kyjVpI2fjm5nZKoZTUA7Cpicb7ajSkrA/132","comment_is_top":false,"comment_ctime":1613699486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613699486","product_id":100056701,"comment_content":"整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它们作为底层数据结构呢？  &gt; 时间复杂度没优势 但是在空间复杂度上有优势    同时  数组可以做到有序     也是业务上常用的一种数据结构","like_count":0},{"had_liked":false,"id":278676,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1613191839,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613191839","product_id":100056701,"comment_content":"文中关于渐进式 rehash 的描述用了“拷贝”来说明，让我自己误以为哈希表 1 中的数据拷贝到表 2 后，哈希表 1 中的刚拷贝的数据还在，所以就产生了后续到达的请求修改了对应的值要怎么处理表 1 和 表 2 中相同数据的疑问？最后在《Redis 设计与实现》中发现渐进式 rehash 后，哈希表 1 中对应索引位置的值会被设置为 NULL。<br>最后想说的是文中的描述是不是改成 “迁移” 至哈希表 2 会比较合适些？","like_count":0},{"had_liked":false,"id":278532,"user_name":"kls","can_delete":false,"product_type":"c1","uid":1446570,"ip_address":"","ucode":"9DC31790DD6924","user_header":"https://static001.geekbang.org/account/avatar/00/16/12/aa/83a3cd03.jpg","comment_is_top":false,"comment_ctime":1613025543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613025543","product_id":100056701,"comment_content":"跳表的查找路径也没说，只说了经过几次就能找到，这让人摸不着头脑，还得去看看跳表是如何找到元素的","like_count":0},{"had_liked":false,"id":277488,"user_name":"code","can_delete":false,"product_type":"c1","uid":2044794,"ip_address":"","ucode":"E434CDBE1EA414","user_header":"https://static001.geekbang.org/account/avatar/00/1f/33/7a/7c64d1e4.jpg","comment_is_top":false,"comment_ctime":1612429508,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612429508","product_id":100056701,"comment_content":"老师，请问为什么是Hash表2先扩容再把Hash表1中的数据迁移过去？而不是直接在Hash表1中扩容？","like_count":0},{"had_liked":false,"id":277039,"user_name":"小可","can_delete":false,"product_type":"c1","uid":1006735,"ip_address":"","ucode":"8834AF621FA67D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/8f/551b5624.jpg","comment_is_top":false,"comment_ctime":1612243565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1612243565","product_id":100056701,"comment_content":"重学哈希表，新学压缩列表，越是底层，就越是基础知识，掌握原理，以不变应万变，挺清晰的赞！","like_count":0},{"had_liked":false,"id":276731,"user_name":"hht-luck","can_delete":false,"product_type":"c1","uid":1901527,"ip_address":"","ucode":"9F2EAD5D973F56","user_header":"","comment_is_top":false,"comment_ctime":1612093279,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1612093279","product_id":100056701,"comment_content":"渐进式rehash理解：每次处理一个hash1处理一个请求，就把当前请求复制到hash2中新的哈希桶，并且复制当前hash1匹配的哈希桶中的值到hash2中，这样理解对吗？","like_count":0,"discussions":[{"author":{"id":1123146,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/4a/c608bdf6.jpg","nickname":"三石","note":"","ucode":"734DCECABC3BEC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391186,"discussion_content":"是按照reshashidx递增依次来迁移的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630325599,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":275431,"user_name":"Sic Pavis","can_delete":false,"product_type":"c1","uid":1106088,"ip_address":"","ucode":"48B5F0118347C8","user_header":"https://static001.geekbang.org/account/avatar/00/10/e0/a8/4e739cf6.jpg","comment_is_top":false,"comment_ctime":1611538749,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611538749","product_id":100056701,"comment_content":"渐进式hash那里，每次请求会附带一个桶的数据转移。<br>问题1:是读请求才触发还是所有请求都触发？<br>问题2:如果是所有请求都触发，写请求时，操作逻辑是否是先执行桶数据转移，再在两个哈希表上应用数据写入？而且考虑到哈希表2上可能还没有对应的数据，如果出现数据不存在的异常还要忽略掉","like_count":0},{"had_liked":false,"id":274458,"user_name":"田鹏原","can_delete":false,"product_type":"c1","uid":1114957,"ip_address":"","ucode":"8BC100F01ED11C","user_header":"https://static001.geekbang.org/account/avatar/00/11/03/4d/dd9c2e96.jpg","comment_is_top":false,"comment_ctime":1611027227,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611027227","product_id":100056701,"comment_content":"老师,渐进式rehash过程,有命令的key索引下的数据才会被迁移. 如果有一直用不到的key且没有设置过期时间,会使得整个rehash一直在进行中么. 还是会有其他线程也在进行rehash,不光依靠文中提到的方式","like_count":0},{"had_liked":false,"id":272889,"user_name":"CityAnimal","can_delete":false,"product_type":"c1","uid":1139902,"ip_address":"","ucode":"206491F70572AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/64/be/12c37d15.jpg","comment_is_top":false,"comment_ctime":1610347467,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1610347467","product_id":100056701,"comment_content":"笔记打卡<br>    * [ ] 底层数据结构<br>        * [ ] 简单动态字符串<br>        * [ ] 双向链表<br>        * [ ] 压缩链表<br>        * [ ] 哈希表<br>        * [ ] 跳表<br>        * [ ] 整数数组<br>    * [ ] 全局哈希表<br>        * [ ] Redis 使用了一个哈希表来保存所有键值对<br>        * [ ] 风险点<br>            * [ ] 哈希冲突<br>                * [ ] 方案：链式哈希<br>            * [ ] rehash<br>                * [ ] Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2<br>                * [ ] 流程<br>                    * [ ] 给哈希表 2 分配更大的空间<br>                    * [ ] 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中<br>                    * [ ] 释放哈希表 1 的空间<br>                * [ ] 优化：渐进式 rehash<br>    * [ ] 集合数据操作效率<br>        * [ ] 底层数据结构<br>            * [ ] 哈希表- O(1)<br>            * [ ] 整数数组&amp;amp;双向链表- O(N)<br>            * [ ] 压缩链表<br>                * [ ] 结构 [zlbytes|ztail|zlen|...entries...|zlend]<br>                * [ ] 复杂度：<br>                    * [ ] 第一个&#47;最后一个- O(1)<br>                    * [ ] 中间-O(N)<br>            * [ ] 跳表- O(logN)<br>        * [ ] 操作复杂度<br>            * [ ] 单元素操作是基础<br>            * [ ] 范围操作非常耗时<br>                * [ ] Redis 2.8 开始提供了 SCAN 系列操作的渐进式遍历<br>            * [ ] 统计操作通常高效<br>            * [ ] 例外情况只有几个<br>                * [ ] 某些数据结构的特殊记录<br>                    * [ ] 压缩列表和双向链表都会记录表头和表尾的偏移量","like_count":0},{"had_liked":false,"id":267998,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1608024663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608024663","product_id":100056701,"comment_content":"rehash 过程中，如何提供读服务？<br><br>例如，在处理第一个请求时，将第一个哈希桶的元素，迁移到了哈希表 2。<br>紧接着下一个请求是 get key，该 key 的 hash1(key)，刚好是哈希表 1 的第一个哈希桶，但是数据已经迁到哈希表 2 了。<br><br>因此有个标记，记录着哈希表 1 哪些哈希桶已经完成迁移，如果 hash1(key) 落在已迁移的记录里，则再执行 hash2(key)，从哈希表 2 取数据。<br><br>哈希表 1 完成迁移后，释放哈希表 1 的空间，和释放已迁移桶的标记空间。<br><br>是这样么老师，谢谢！！<br><br>----<br><br>hash1()：表示哈希表 1 的 hash 函数。<br>hash2()：表示哈希表 2 的 hash 函数。","like_count":0},{"had_liked":false,"id":267992,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1608022769,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1608022769","product_id":100056701,"comment_content":"有几个概念不知道理解得正确不：<br>哈希桶是数组的坑位，其保存的是 entry 对象的指针。<br>而 entry 对象的数据结构包含 *key 和 *value 指针。","like_count":0,"discussions":[{"author":{"id":1102245,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d1/a5/2bbedc3b.jpg","nickname":"over","note":"","ucode":"FE272AC19842D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375117,"discussion_content":"为什么还需要entry对象的指针呢？直接存下key和value的指针不就可以了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621488619,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267723,"user_name":"Tulane","can_delete":false,"product_type":"c1","uid":1242467,"ip_address":"","ucode":"E1F5108B9E738F","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/63/53639bb7.jpg","comment_is_top":false,"comment_ctime":1607906524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607906524","product_id":100056701,"comment_content":"老师，rehash渐进式，那已经复制过去的键链，后面有了新的改动，是怎么处理呢。 在最终确认无变化时，需要阻塞么","like_count":0},{"had_liked":false,"id":267565,"user_name":"取经人","can_delete":false,"product_type":"c1","uid":1107550,"ip_address":"","ucode":"C3668CA65200DF","user_header":"https://static001.geekbang.org/account/avatar/00/10/e6/5e/62158841.jpg","comment_is_top":false,"comment_ctime":1607829205,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607829205","product_id":100056701,"comment_content":"渐进式的rehash懂意思但有疑问，比如说什么时候才能把新替换旧，hash的进度怎么看，如果要是有些数据永远不放怎呢，","like_count":0},{"had_liked":false,"id":266438,"user_name":"李藤","can_delete":false,"product_type":"c1","uid":2247142,"ip_address":"","ucode":"8553B1CDDD7DC6","user_header":"https://static001.geekbang.org/account/avatar/00/22/49/e6/dccb1686.jpg","comment_is_top":false,"comment_ctime":1607340785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607340785","product_id":100056701,"comment_content":"不知道我有没有理解错：如果在rehash的过程中，过来的第一请求就访问索引中最后一个key，那是不是在这一个请求中就会把rehash的过程都做完，就不是渐进式rehash了？","like_count":0},{"had_liked":false,"id":265802,"user_name":"蚝不鱿鱼","can_delete":false,"product_type":"c1","uid":1428043,"ip_address":"","ucode":"5DB98E406F1D3E","user_header":"https://static001.geekbang.org/account/avatar/00/15/ca/4b/c1ace3aa.jpg","comment_is_top":false,"comment_ctime":1607040233,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607040233","product_id":100056701,"comment_content":"默认两个哈希表解决哈希冲突带来的单桶链表过长问题的方法真的很赞","like_count":0},{"had_liked":false,"id":265525,"user_name":"Benny","can_delete":false,"product_type":"c1","uid":1254655,"ip_address":"","ucode":"062648FD8743BF","user_header":"https://static001.geekbang.org/account/avatar/00/13/24/ff/4647e8a5.jpg","comment_is_top":false,"comment_ctime":1606921220,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606921220","product_id":100056701,"comment_content":"老师，图里是不是标错了，zset应该使用了hash和skiplist两种数据结构吧","like_count":0},{"had_liked":false,"id":265368,"user_name":"Guo","can_delete":false,"product_type":"c1","uid":1653037,"ip_address":"","ucode":"D4CDD1D5378E3F","user_header":"https://static001.geekbang.org/account/avatar/00/19/39/2d/78c11698.jpg","comment_is_top":false,"comment_ctime":1606879147,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606879147","product_id":100056701,"comment_content":"intset的查找复杂度是O(logn)，redis的整数数组是有序结构，实现search的时候用的二分查找","like_count":0,"discussions":[{"author":{"id":1762252,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/e3/cc/0947ff0b.jpg","nickname":"nestle","note":"","ucode":"469800BED81B54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":560321,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649257860,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":264379,"user_name":"郭纯","can_delete":false,"product_type":"c1","uid":1314521,"ip_address":"","ucode":"2613860B4642C4","user_header":"https://static001.geekbang.org/account/avatar/00/14/0e/d9/e61ce097.jpg","comment_is_top":false,"comment_ctime":1606450695,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606450695","product_id":100056701,"comment_content":"数组在内存分配是线性的. 我们通过数组的内存➕下标可以达到 o(1) 访问复杂度","like_count":0},{"had_liked":false,"id":264353,"user_name":"朱嫑膘","can_delete":false,"product_type":"c1","uid":1112401,"ip_address":"","ucode":"CC7C3CF5558B67","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/51/0bd5006f.jpg","comment_is_top":false,"comment_ctime":1606445638,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606445638","product_id":100056701,"comment_content":"整数数组根据下标访问应该是O(1)吧，为什么是O(n)呢？","like_count":0},{"had_liked":false,"id":263764,"user_name":"吴宇晨","can_delete":false,"product_type":"c1","uid":1199968,"ip_address":"","ucode":"F8F45B7067DF6D","user_header":"https://static001.geekbang.org/account/avatar/00/12/4f/60/049a20e9.jpg","comment_is_top":false,"comment_ctime":1606264063,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606264063","product_id":100056701,"comment_content":"有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。  老师，这句话是不是写错了，结合前面的内容是指压缩列表吧","like_count":0},{"had_liked":false,"id":263605,"user_name":"BertGeek","can_delete":false,"product_type":"c1","uid":1452799,"ip_address":"","ucode":"8E1D72C9F9778C","user_header":"https://static001.geekbang.org/account/avatar/00/16/2a/ff/a9d72102.jpg","comment_is_top":false,"comment_ctime":1606195831,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1606195831","product_id":100056701,"comment_content":"辛苦了老师<br>总结一些问题，请老师解答，非常感谢！<br>1. 渐进式rehash过程中，接到客户端写入数据请求，是2个全局哈希表都会写入数据, 还是只写到h2中<br><br>2. 当hash表进行渐进式扩容时 数据分布在两个buckets中，此时get查找数据是依次找h1，h1不存在，在找h2么<br> <br> <br>3. 如果某个hash slot一直没有被访问到，那它是如何被迁移到另一张hash表中的？<br><br>4. hash表中的渐近式的rehash，新增操作，在hash表1进行还是在hash表2上进行？<br><br>5. rehash数据拷贝后，客户端如何感知到哪个表找？","like_count":0,"discussions":[{"author":{"id":1020719,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/2f/1e193dcc.jpg","nickname":"有生之年","note":"","ucode":"B713335DE9D37F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340299,"discussion_content":"1. 直接会写到h2\n2. 是的，先找h1，再找h2\n3. Redis server会有定时任务执行rehash\n4和5两个问题，感觉和1、2是一样的啊.. ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609947360,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":263365,"user_name":"一格状语","can_delete":false,"product_type":"c1","uid":1622696,"ip_address":"","ucode":"EBA9ED5F97416D","user_header":"https://static001.geekbang.org/account/avatar/00/18/c2/a8/f3f8f5d2.jpg","comment_is_top":false,"comment_ctime":1606117382,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1606117382","product_id":100056701,"comment_content":"最喜欢这种有好图的课！！！","like_count":0},{"had_liked":false,"id":262468,"user_name":"Gary","can_delete":false,"product_type":"c1","uid":1326526,"ip_address":"","ucode":"B34CAEF98A58F9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKcGyxWSib0Cr63mCQmxTLGaTicibPmYficlsPSAHqPp25Ang5R1m7Kn1qsniaOb1eTT8c1ib8Ixk5ibqvLg/132","comment_is_top":false,"comment_ctime":1605747282,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605747282","product_id":100056701,"comment_content":"rehash是直接copy吗，不应该重新按照新的hash桶长度重新计算hash，放到合适位置吗","like_count":0},{"had_liked":false,"id":261712,"user_name":"Eric","can_delete":false,"product_type":"c1","uid":1053498,"ip_address":"","ucode":"59752A51A382A6","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/3a/b0454322.jpg","comment_is_top":false,"comment_ctime":1605501733,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605501733","product_id":100056701,"comment_content":"问个小问题，渐进式rehash执行时，是否要额外同步维护一个迁移记录，而且在迁移过程中，有数据更新怎么办？","like_count":0},{"had_liked":false,"id":261539,"user_name":"书木子谢明","can_delete":false,"product_type":"c1","uid":1259879,"ip_address":"","ucode":"3090C080A570BE","user_header":"https://static001.geekbang.org/account/avatar/00/13/39/67/743128f7.jpg","comment_is_top":false,"comment_ctime":1605410231,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605410231","product_id":100056701,"comment_content":"请教：“对于 String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 O(1) 操作复杂度也就是它的复杂度了。”：存在哈希冲突情况下，string类型在找到哈希桶之后也要遍历找到对应的entry吧，那为什么是O1的操作速度呢？redis的rehash完全避免了哈希冲突？","like_count":0},{"had_liked":false,"id":261428,"user_name":"星夜","can_delete":false,"product_type":"c1","uid":2290371,"ip_address":"","ucode":"08F116D90F79CC","user_header":"https://static001.geekbang.org/account/avatar/00/22/f2/c3/5345b358.jpg","comment_is_top":false,"comment_ctime":1605332927,"is_pvip":false,"replies":[{"id":"98058","content":"从Redis 3.2版本开始，List的底层数据结构是quicklist，quicklist里面是把linkedlist和ziplist结合在一起使用了。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609114239,"ip_address":"","comment_id":261428,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1605332927","product_id":100056701,"comment_content":"List的底层数据结构，新版本的redis应该只有ziplist一种了吧？","like_count":0,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509483,"discussion_content":"从Redis 3.2版本开始，List的底层数据结构是quicklist，quicklist里面是把linkedlist和ziplist结合在一起使用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609114239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261169,"user_name":"Xiao","can_delete":false,"product_type":"c1","uid":1179212,"ip_address":"","ucode":"71FFCCEEDE09E1","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/4c/46eb517a.jpg","comment_is_top":false,"comment_ctime":1605232976,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1605232976","product_id":100056701,"comment_content":"rehash的时候，需要给hash2分配更大的内存，如果此时内存不够了呢","like_count":0},{"had_liked":false,"id":261166,"user_name":"Tank","can_delete":false,"product_type":"c1","uid":2262986,"ip_address":"","ucode":"A7108E83D2D199","user_header":"https://static001.geekbang.org/account/avatar/00/22/87/ca/00cc5a1a.jpg","comment_is_top":false,"comment_ctime":1605232301,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605232301","product_id":100056701,"comment_content":"redis的hash类型数据结构和rehash机制是不是跟Java中的hashmap一个道理","like_count":0},{"had_liked":false,"id":261030,"user_name":"undefined","can_delete":false,"product_type":"c1","uid":2275808,"ip_address":"","ucode":"953AF612BBF0F7","user_header":"https://static001.geekbang.org/account/avatar/00/22/b9/e0/47f8c89e.jpg","comment_is_top":false,"comment_ctime":1605175340,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605175340","product_id":100056701,"comment_content":"全局哈希如何区分不同数据类型?字符串类型的Key如果哈希冲突怎么解决？以及在冲突下怎么保证时间复杂度O(1)?","like_count":0},{"had_liked":false,"id":260298,"user_name":"出卖灵魂的教练Kerry","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1604979474,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1604979474","product_id":100056701,"comment_content":"涨知识了","like_count":0},{"had_liked":false,"id":260271,"user_name":"Hurt","can_delete":false,"product_type":"c1","uid":1050946,"ip_address":"","ucode":"DCE7428CCF08EF","user_header":"https://static001.geekbang.org/account/avatar/00/10/09/42/1f762b72.jpg","comment_is_top":false,"comment_ctime":1604973872,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604973872","product_id":100056701,"comment_content":"老师 整数数组的访问为什么是On的呢 不是O1吗？ 这和数组有什么区别呢","like_count":0},{"had_liked":false,"id":260245,"user_name":"Bug? Feature!","can_delete":false,"product_type":"c1","uid":1164531,"ip_address":"","ucode":"F8FA8A0094FBA0","user_header":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","comment_is_top":false,"comment_ctime":1604969868,"is_pvip":false,"replies":[{"id":"98017","content":"是的，原理很重要，掌握原理，以不变应万变。对于Redis数据类型和操作来说，原理就是数据结构的知识。","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1609081564,"ip_address":"","comment_id":260245,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604969868","product_id":100056701,"comment_content":"给老师点个赞，Redis 数据类型丰富，每个类型的操作繁多，我们通常无法一下子记住所有操作的复杂度。所以，最好的办法就是掌握原理，以不变应万变。一旦掌握了数据结构基本原理，我们就可以从原理上推断不同操作的复杂度，即使这个操作我们不一定熟悉。这样一来，我们不用死记硬背，也能快速合理地做出选择了。","like_count":0,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509142,"discussion_content":"是的，原理很重要，掌握原理，以不变应万变。对于Redis数据类型和操作来说，原理就是数据结构的知识。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609081564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":259357,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1604712556,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604712556","product_id":100056701,"comment_content":"lrange 提供了设置查询的size，这样和scan命令使用哪个性能更优","like_count":0},{"had_liked":false,"id":258633,"user_name":"hao","can_delete":false,"product_type":"c1","uid":1148845,"ip_address":"","ucode":"997F2B57E2F556","user_header":"https://static001.geekbang.org/account/avatar/00/11/87/ad/50a85a04.jpg","comment_is_top":false,"comment_ctime":1604512654,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604512654","product_id":100056701,"comment_content":"1，以空间换时间<br>2，以时间换空间","like_count":0},{"had_liked":false,"id":258302,"user_name":"ronaldo","can_delete":false,"product_type":"c1","uid":2222937,"ip_address":"","ucode":"824AE89F4C58BB","user_header":"","comment_is_top":false,"comment_ctime":1604376142,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1604376142","product_id":100056701,"comment_content":"有了压缩列表，跳表 、还需要整形数组么？ 有人回答一下使用场景么？","like_count":0,"discussions":[{"author":{"id":1682027,"avatar":"https://static001.geekbang.org/account/avatar/00/19/aa/6b/ab9a072a.jpg","nickname":"对与错","note":"","ucode":"EF55733E3BD78B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325745,"discussion_content":"自我理解，整数数组在根据下标的随机访问特性上肯定是优于压缩列表的，前者的时间复杂度是O(1)，后者如果操作的非头尾元素就是O(n)，同时整数数组和压缩列表相对于其他数据结构来说肯定是更节省内存空间的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605421292,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257547,"user_name":"阿Q看世界","can_delete":false,"product_type":"c1","uid":2015747,"ip_address":"","ucode":"D393FF2960566D","user_header":"https://static001.geekbang.org/account/avatar/00/1e/c2/03/4811e937.jpg","comment_is_top":false,"comment_ctime":1604025399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604025399","product_id":100056701,"comment_content":"这课讲得很不错，谢谢老师，再配合自己在看的《Redis 5设计与源码分析》，就非常明白了!","like_count":0},{"had_liked":false,"id":257133,"user_name":"helloxiaomin","can_delete":false,"product_type":"c1","uid":1187293,"ip_address":"","ucode":"607CAEA41B8B9A","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/dd/95cdb4d8.jpg","comment_is_top":false,"comment_ctime":1603856256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603856256","product_id":100056701,"comment_content":"蒋老师好，有两个疑问请教一下：<br>1）我理解rehash扩容时，怎么会造成客户端的阻塞呢？难道扩容线程和响应客户端线程是同一个？<br>2）关于压缩列表的具体实现原理是什么？<br>谢谢！","like_count":0},{"had_liked":false,"id":256873,"user_name":"Geek_b8d5c9","can_delete":false,"product_type":"c1","uid":2261175,"ip_address":"","ucode":"505F33B4C0EA31","user_header":"","comment_is_top":false,"comment_ctime":1603770283,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603770283","product_id":100056701,"comment_content":"老师 我很好奇，难道跳表都是存有序的数字码？我上班redis一般都用来存热点数据了 差不多都是一些对象字符串，这又怎么保证跳表存有序数字的原则呢 老师求翻求解。","like_count":0},{"had_liked":false,"id":256326,"user_name":"明月几时","can_delete":false,"product_type":"c1","uid":1675716,"ip_address":"","ucode":"E46C844EAB2CD0","user_header":"https://static001.geekbang.org/account/avatar/00/19/91/c4/bcdcda65.jpg","comment_is_top":false,"comment_ctime":1603599508,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603599508","product_id":100056701,"comment_content":"这节课，学习了 Redis 的底层数据结构，这既包括了 Redis 中用来保存每个键和值的全局哈希表结构，也包括了支持集合类型实现的双向链表、压缩列表、整数数组、哈希表和跳表这五大底层结构。","like_count":0},{"had_liked":false,"id":256199,"user_name":"明月几时","can_delete":false,"product_type":"c1","uid":1675716,"ip_address":"","ucode":"E46C844EAB2CD0","user_header":"https://static001.geekbang.org/account/avatar/00/19/91/c4/bcdcda65.jpg","comment_is_top":false,"comment_ctime":1603551456,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1603551456","product_id":100056701,"comment_content":"intset 和 ziplist 如果直接使用确实是时间复杂度上不是很高效，但是结合Redis的使用场景，大部分Redis的数据都是零散碎片化的，通过这两种数据结构可以提高内存利用率，但是为了防止过度使用这两种数据结构Redis其实都设有阈值或者搭配使用的，例如：ziplist是和quicklist一起使用的，在quicklist中ziplist是一个个节点，而且quicklist为每个节点的大小都设置有阈值避免单个节点过大，从而导致性能下降","like_count":0},{"had_liked":false,"id":255394,"user_name":"猿飞日斩","can_delete":false,"product_type":"c1","uid":1668982,"ip_address":"","ucode":"9ABF88EAD3965C","user_header":"https://static001.geekbang.org/account/avatar/00/19/77/76/56740001.jpg","comment_is_top":false,"comment_ctime":1603334426,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1603334426","product_id":100056701,"comment_content":"整数数组和压缩列表都是紧凑型数据结构，文中List，Hash，Sorted Set等集合类型都使用了压缩列表，为什么Set集合没有使用压缩列表呢？","like_count":0,"discussions":[{"author":{"id":1682027,"avatar":"https://static001.geekbang.org/account/avatar/00/19/aa/6b/ab9a072a.jpg","nickname":"对与错","note":"","ucode":"EF55733E3BD78B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325746,"discussion_content":"自我理解,Set集合更多的是随机操作，整数数组在下标的随机访问特性上面更优","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605421380,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":255036,"user_name":"我能走多远","can_delete":false,"product_type":"c1","uid":1240465,"ip_address":"","ucode":"07DF5D5DADFA3C","user_header":"https://static001.geekbang.org/account/avatar/00/12/ed/91/1d332031.jpg","comment_is_top":false,"comment_ctime":1603255308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603255308","product_id":100056701,"comment_content":"老师讲的太好了。有没有更深入讲解及内存分布，压缩原理","like_count":0},{"had_liked":false,"id":253549,"user_name":"LovePeace","can_delete":false,"product_type":"c1","uid":1010319,"ip_address":"","ucode":"5BA5B11FAF953E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/8f/5b224f54.jpg","comment_is_top":false,"comment_ctime":1602773793,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602773793","product_id":100056701,"comment_content":"请教一下 文章中提到的&quot;当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了 &quot;，既然redis有使用渐进式rehash那什么还会变慢呢？","like_count":0},{"had_liked":false,"id":252779,"user_name":"Aliliin","can_delete":false,"product_type":"c1","uid":1025239,"ip_address":"","ucode":"61F9A09BB6650F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a4/d7/5d2bfaa7.jpg","comment_is_top":false,"comment_ctime":1602485099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602485099","product_id":100056701,"comment_content":"从硬盘的存储数据原理来说，应该是为了数据存储的顺序存储选择的。<br>","like_count":0},{"had_liked":false,"id":251818,"user_name":"龙猫","can_delete":false,"product_type":"c1","uid":1112490,"ip_address":"","ucode":"FD726CC969EF9C","user_header":"https://static001.geekbang.org/account/avatar/00/10/f9/aa/3e80212e.jpg","comment_is_top":false,"comment_ctime":1601887704,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601887704","product_id":100056701,"comment_content":"使用数组保证了内存的连续性、压缩列表节省了内存空间，两个基础数据结构都是为了省内存","like_count":0},{"had_liked":false,"id":251524,"user_name":"小白","can_delete":false,"product_type":"c1","uid":1395913,"ip_address":"","ucode":"31371AF6336B9F","user_header":"https://static001.geekbang.org/account/avatar/00/15/4c/c9/ae464069.jpg","comment_is_top":false,"comment_ctime":1601642189,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601642189","product_id":100056701,"comment_content":"我觉得蒋老师讲得太好了，虽然我自己觉得马马虎虎会用redis，也知道一些redis的底层原理，听完老师的每一堂课，都感觉收获颇丰！感谢蒋老师带来这么好的课，同时期待蒋老师带给我们更多的课程！给老师点一个赞！！！","like_count":0},{"had_liked":false,"id":251154,"user_name":"ayu","can_delete":false,"product_type":"c1","uid":1496036,"ip_address":"","ucode":"B841E06228B9D6","user_header":"https://static001.geekbang.org/account/avatar/00/16/d3/e4/5a75f0a5.jpg","comment_is_top":false,"comment_ctime":1601382650,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601382650","product_id":100056701,"comment_content":"老师，渐进式hash过程中，如果某个hash slot一直没有被访问到，那它是如何被迁移到另一张hash表中的？","like_count":0},{"had_liked":false,"id":251146,"user_name":"学个球","can_delete":false,"product_type":"c1","uid":1019725,"ip_address":"","ucode":"7343F3C0CA981D","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8f/4d/65fb45e6.jpg","comment_is_top":false,"comment_ctime":1601378488,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1601378488","product_id":100056701,"comment_content":"可能有一点疑问就是后续的修改请求要怎么处理？<br>猜测一下，增删改查都优先从表 B 中进行，B 中如果有就正常处理，这个应该没有什么疑问。如果 B 表中没有，在 A 中找，直接在 A 处理或者拷贝到 B 后进行处理。  ","like_count":0},{"had_liked":false,"id":248989,"user_name":"JackLei","can_delete":false,"product_type":"c1","uid":1099989,"ip_address":"","ucode":"01128A61A9E80F","user_header":"https://static001.geekbang.org/account/avatar/00/10/c8/d5/e88c1805.jpg","comment_is_top":false,"comment_ctime":1600395710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600395710","product_id":100056701,"comment_content":"渐进式 rehash过程中，如果通过一个key去查找一个val，在哈希表1没有找到，会继续去哈希表2再查找一次么？","like_count":0},{"had_liked":false,"id":248615,"user_name":"yinzhiping","can_delete":false,"product_type":"c1","uid":2114235,"ip_address":"","ucode":"71C74CE6F62FF8","user_header":"","comment_is_top":false,"comment_ctime":1600241885,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600241885","product_id":100056701,"comment_content":"关于“Redis 采用了渐进式 rehash”，文章说的是每次请求的时候的copy一条数据，那如果没有请求，是不是就不会继续rehash操作了呢？<br>","like_count":0},{"had_liked":false,"id":248504,"user_name":"上学威龙007","can_delete":false,"product_type":"c1","uid":2116689,"ip_address":"","ucode":"B24D8A2E7D01F8","user_header":"https://static001.geekbang.org/account/avatar/00/20/4c/51/61003d76.jpg","comment_is_top":false,"comment_ctime":1600184519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600184519","product_id":100056701,"comment_content":"rehash，过程中分为辅助rehash和定时rehash<br>辅助 rehash,表示在增删改查的执行中，会帮助执行一次数据的copy<br>定时rehash，表示当redis空闲时，会定时检测是否存在需要帮助的rehash，如果存在就帮助执行一次数据的copy，防止2个hash表的长期同时使用。<br>在rehash的过程中个，删改查的命令都是同时执行，例如在表1中，查询不到，则到表2中查询。除了新增的操作只在表2中执行，其他会类似，先执行表1，执行不到再到表2中执行。","like_count":0},{"had_liked":false,"id":248409,"user_name":"Geek_5aae47","can_delete":false,"product_type":"c1","uid":2176180,"ip_address":"","ucode":"2E6D974EE836E6","user_header":"","comment_is_top":false,"comment_ctime":1600152773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1600152773","product_id":100056701,"comment_content":"老师，其他的都理解了，就是这个set类型的为什么底层会有整数数组这种数据结构？","like_count":0},{"had_liked":false,"id":248395,"user_name":"何磊","can_delete":false,"product_type":"c1","uid":1047604,"ip_address":"","ucode":"78934C3ED4A342","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/34/c733b116.jpg","comment_is_top":false,"comment_ctime":1600147329,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1600147329","product_id":100056701,"comment_content":"对于rehash有个疑问，<br>如果要把hash1上的全部搬到hash2上；依靠每次触发对应key后，搬移对应的entry过去；这里有一个问题，可能某些key一直没有机会被访问到，那么hash1到hash2的搬迁工作，一直无法完成，这个redis有做什么特殊处理吗？<br><br>而且这个一直无法rehash完成还有个问题，如果hash2要rehash会hash1上的时候，hash1上还有老的数据，而实际上此时hash1扩容后，算出的hash值应该发生了变化。","like_count":0,"discussions":[{"author":{"id":2256240,"avatar":"https://static001.geekbang.org/account/avatar/00/22/6d/70/befc74a8.jpg","nickname":"椿","note":"","ucode":"85145045EF119B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":316671,"discussion_content":"应该还有其他机制。。比如一段时间搬移一些从未访问过的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603438313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":247315,"user_name":"人在江湖飘","can_delete":false,"product_type":"c1","uid":1130934,"ip_address":"","ucode":"FF0D992B5EFCDE","user_header":"https://static001.geekbang.org/account/avatar/00/11/41/b6/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1599656859,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599656859","product_id":100056701,"comment_content":"老师，Redis是扩容的时候采用渐进式的rehash，如果我有个key对应的hash key，一直没有访问，那这个时候，Redis又是怎么做的呢？","like_count":0,"discussions":[{"author":{"id":1058015,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/df/645f8087.jpg","nickname":"Yayu","note":"","ucode":"5E7842458D8229","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335210,"discussion_content":"rehash 过程中，有专属定时任务在默默进行着元素搬移工作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608121213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":246881,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1599521185,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599521185","product_id":100056701,"comment_content":"redis全局hash表有默认大小吗？能否设置？另外rehash的阈值是多少？能否设置","like_count":0,"discussions":[{"author":{"id":1442605,"avatar":"https://static001.geekbang.org/account/avatar/00/16/03/2d/404627dc.jpg","nickname":"Anryg Zhun","note":"","ucode":"76DF8560BA9D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325808,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605437074,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245829,"user_name":"海云台","can_delete":false,"product_type":"c1","uid":1596926,"ip_address":"","ucode":"E213EB82007AE5","user_header":"https://static001.geekbang.org/account/avatar/00/18/5d/fe/721a62e9.jpg","comment_is_top":false,"comment_ctime":1599066311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1599066311","product_id":100056701,"comment_content":"请问下，全局hash表的初始大小是可以设置的，默认是多少呢，我的想法是，如果业务数据量稳定，是否也会有预分配空间的一个逻辑处理，尽量避免扩缩容量带来的部分性能损耗","like_count":0},{"had_liked":false,"id":245428,"user_name":"Jasper","can_delete":false,"product_type":"c1","uid":1202174,"ip_address":"","ucode":"A07ABF45D39089","user_header":"https://static001.geekbang.org/account/avatar/00/12/57/fe/beab006d.jpg","comment_is_top":false,"comment_ctime":1598942534,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598942534","product_id":100056701,"comment_content":"刚学完数据结构，再来听这节课，就轻松多了。","like_count":0},{"had_liked":false,"id":245340,"user_name":"Hector","can_delete":false,"product_type":"c1","uid":1496889,"ip_address":"","ucode":"110CAF87ADDC01","user_header":"https://static001.geekbang.org/account/avatar/00/16/d7/39/6698b6a9.jpg","comment_is_top":false,"comment_ctime":1598919708,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598919708","product_id":100056701,"comment_content":"哈希表就是个大大的备胎，走一波原谅色","like_count":0},{"had_liked":false,"id":243716,"user_name":"学友的情书","can_delete":false,"product_type":"c1","uid":1273991,"ip_address":"","ucode":"260960EF2B7241","user_header":"https://static001.geekbang.org/account/avatar/00/13/70/87/f60f5cf9.jpg","comment_is_top":false,"comment_ctime":1598255716,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1598255716","product_id":100056701,"comment_content":"老师你好，有个小疑问。在rehash的时候，这时候有两个hash表，若有一个客户端请求需要查数据，这时候是否是在旧的hash表中先查找数据，当查找不到时，这时候才会去新的hash表查找数据。","like_count":0},{"had_liked":false,"id":243646,"user_name":"Geek_0cf59c","can_delete":false,"product_type":"c1","uid":2113137,"ip_address":"","ucode":"BD9E77E46B0249","user_header":"","comment_is_top":false,"comment_ctime":1598239191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598239191","product_id":100056701,"comment_content":"我认为最根本的原因还是Redis是内存数据库，所有的操作都在内存上完成。数组和压缩列表所分配的是连续的内存空间，能节约内存。虽然时间复杂度高，但是例外的情况只有几个，像list类型的 LPOP、RPOP、LPUSH、RPUSH 时间复杂度都是O(1)，所以在使用时还是要选择合适的类型。文中所说：因地制宜地使用 List 类型。例如，既然它的 POP&#47;PUSH 效率很高，那么就将它主要用于 FIFO 队列场景，而不是作为一个可以随机读写的集合。","like_count":0},{"had_liked":false,"id":243484,"user_name":"第四范式","can_delete":false,"product_type":"c1","uid":1663762,"ip_address":"","ucode":"61ECDC7C834CAF","user_header":"https://static001.geekbang.org/account/avatar/00/19/63/12/5a22fcc7.jpg","comment_is_top":false,"comment_ctime":1598151661,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598151661","product_id":100056701,"comment_content":"链表最新的结构是快表吧。","like_count":0},{"had_liked":false,"id":243437,"user_name":"V","can_delete":false,"product_type":"c1","uid":1060726,"ip_address":"","ucode":"7CA43B0FBFFA68","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/76/a382a707.jpg","comment_is_top":false,"comment_ctime":1598107120,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1598107120","product_id":100056701,"comment_content":"渐进式 rehash 是通过每次请求顺便迁移的！那么请问如果在一定时间内没有请求那就不迁移数据了？<br><br>再假设在迁移过程中第一个元素迁移之后，这时客户端又put一个k v 刚好落在已经迁移完成的哈希桶中！ redis是如何处理的？又是如何保证能顺利迁移完，最后释放哈希1表！<br><br>还望老师指点！🤝","like_count":0,"discussions":[{"author":{"id":2080899,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c0/83/ca1c44d5.jpg","nickname":"west","note":"","ucode":"B42BF349E55900","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334901,"discussion_content":"redis会有定时事件，会在定时事件中进行rehash操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608022845,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308017,"discussion_content":"Rehash时，新增元素不会写入旧的哈希表了，会直接写入新的哈希表里面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600826657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243420,"user_name":"阿卧","can_delete":false,"product_type":"c1","uid":1229566,"ip_address":"","ucode":"68C0CC25E57707","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/fe/038a076e.jpg","comment_is_top":false,"comment_ctime":1598101929,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1598101929","product_id":100056701,"comment_content":"1. 节省内存空间：redis的的string、列表等类型在数据量较小的情况下使用压缩列表，目的是为了尽量节省内存空间<br>","like_count":0},{"had_liked":false,"id":242834,"user_name":"吕","can_delete":false,"product_type":"c1","uid":1210890,"ip_address":"","ucode":"8F08E2CB81C4C3","user_header":"https://static001.geekbang.org/account/avatar/00/12/7a/0a/0ce5c232.jpg","comment_is_top":false,"comment_ctime":1597850479,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1597850479","product_id":100056701,"comment_content":"hash表中的渐近式的rehash，对于新增的操作，实在hash表一进行还是在hash表二上进行？是不是新增操作，只在表二上进行，然后查找的时候，如果表一找不到，就再找表二？","like_count":0,"discussions":[{"author":{"id":2080899,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c0/83/ca1c44d5.jpg","nickname":"west","note":"","ucode":"B42BF349E55900","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334909,"discussion_content":"dict在rehash过程中，Add操作之前，先在ht1上查找，如找到更新ht1，未找到在ht2上查找，找到更新，未找到直接新加","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608024792,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2080899,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/c0/83/ca1c44d5.jpg","nickname":"west","note":"","ucode":"B42BF349E55900","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334906,"discussion_content":"dict在rehash过程中，新增是在ht2中进行，查找是先查找ht1，找不到再找ht2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608023725,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242178,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1597629804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597629804","product_id":100056701,"comment_content":"在小数据量的情况下，提高内存使用率。<br>同时数组和压缩列表的访问效率在小数据的时候并不低。","like_count":0},{"had_liked":false,"id":241959,"user_name":"小学生","can_delete":false,"product_type":"c1","uid":1166994,"ip_address":"","ucode":"6EF88756389547","user_header":"https://static001.geekbang.org/account/avatar/00/11/ce/92/f53c41ee.jpg","comment_is_top":false,"comment_ctime":1597540707,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597540707","product_id":100056701,"comment_content":"蒋老师您好，redis哈希冲突链过大，导致查询耗时长，于是采用了rehash机制，而这个操作，让我想起来Java7 到Java8 中，hashMap 底层到链表结构优化，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)，为什么redis没有考虑到这个？","like_count":0,"discussions":[{"author":{"id":1896868,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f1/a4/79c36b87.jpg","nickname":"流云","note":"","ucode":"26C5A9166EC6D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301479,"discussion_content":"这个问题问的很好","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598535505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241953,"user_name":"王益新","can_delete":false,"product_type":"c1","uid":1115160,"ip_address":"","ucode":"459CC11CB1DF1F","user_header":"https://static001.geekbang.org/account/avatar/00/11/04/18/d5cb509f.jpg","comment_is_top":false,"comment_ctime":1597536337,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597536337","product_id":100056701,"comment_content":"渐进式 rehash 执行期间的增删改查“”操作哈希表操作应该咋处理？<br><br>增：直接加到哈希表2中，<br>删、改、查：先尝试处理表1，再尝试处理表2<br><br>我的理解正确吗？","like_count":0},{"had_liked":false,"id":241947,"user_name":"Dream.","can_delete":false,"product_type":"c1","uid":1187286,"ip_address":"","ucode":"49B94CE5BA0D21","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/d6/76fe5259.jpg","comment_is_top":false,"comment_ctime":1597513508,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597513508","product_id":100056701,"comment_content":"提问：全局hash表的hash桶的默认大小是多少？这个可以通过配置调整吗？<br><br>执行rehash的阈值是多少？文中仅提到当存在一定数量的hash冲突时会执行rehash。<br><br>最近做接口压力测试，发现redis这一块成了性能瓶颈（接口对redis有读有写，采用的是hash结构）。redis连接池设的3000，但是在6000并发下，redis的响应时间却超过了3s（服务器资源完全够用，仅用了不到10%）<br><br>看见rehash这个操作，觉得既然全局hash表会进行rehash，那么hash结构应该也会，现在怀疑是因为hset的时候进行rehash导致响应时间变慢了。全局or非全局的hash表有一个明确的rehash阈值吗？","like_count":0,"discussions":[{"author":{"id":1065863,"avatar":"https://static001.geekbang.org/account/avatar/00/10/43/87/24eb68cf.jpg","nickname":"dermanyuan","note":"","ucode":"3227437F62C5B8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299126,"discussion_content":"rehash采用渐进式扩容，扩容对性能影响不会太大。当时的网络IO、获取连接时间这些数据多少呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597569880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241895,"user_name":"Geek_Lin","can_delete":false,"product_type":"c1","uid":2120990,"ip_address":"","ucode":"3C887B8E6FF3B9","user_header":"","comment_is_top":false,"comment_ctime":1597490579,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597490579","product_id":100056701,"comment_content":"y有个疑问：整数数组那里的时间复杂度O(n)应该是添加或者移除的吧，查找的话应该还是O(1)","like_count":0},{"had_liked":false,"id":241429,"user_name":"夜空中最亮的星","can_delete":false,"product_type":"c1","uid":1267566,"ip_address":"","ucode":"ADC3E7B6789955","user_header":"https://static001.geekbang.org/account/avatar/00/13/57/6e/b6795c44.jpg","comment_is_top":false,"comment_ctime":1597291225,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597291225","product_id":100056701,"comment_content":"“一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。”<br>问题：一个哈希桶  保存了 一对 键值数据，还是多对？<br>       数组元素 就是 键值对 原始数据？<br>       数组下标是 键值对 哈希值 ？查找的时候是通过 下标 定位数据？ ","like_count":0},{"had_liked":false,"id":241163,"user_name":"Mr.蜜","can_delete":false,"product_type":"c1","uid":1035257,"ip_address":"","ucode":"C911B81198B3F5","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cb/f9/75d08ccf.jpg","comment_is_top":false,"comment_ctime":1597205972,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597205972","product_id":100056701,"comment_content":"既然老师说到skip list，那么我想问问老师，zset在从zip list转到skip list的时候，规则是什么？skip list的默认深度是多少？skip list在插入和删除操作时，关于建立跳转链表的规则和复杂度是什么？","like_count":0},{"had_liked":false,"id":240928,"user_name":"Anthony","can_delete":false,"product_type":"c1","uid":1309908,"ip_address":"","ucode":"9E0C98A9123365","user_header":"https://static001.geekbang.org/account/avatar/00/13/fc/d4/743d3f02.jpg","comment_is_top":false,"comment_ctime":1597123186,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1597123186","product_id":100056701,"comment_content":"老师，你问中说的双向链表也能在O（1）时间复杂度的情况下返回长度，我理解的应该是O（n）,不知道是哪里有问题呢？<br>","like_count":0,"discussions":[{"author":{"id":1446512,"avatar":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","nickname":"Lywane","note":"","ucode":"2B0027AA069CE9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298653,"discussion_content":"长度单独记录了，直接取即可","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597371572,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1844885,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo6waC1mF0VmQibDjnJLEgFnmEUSNJozibaUeYZkpQaqicVcXxGZ3kKtnY5XF0iblxT4oiam7ucuJ1bqgg/132","nickname":"Geek_c37e49","note":"","ucode":"BCE0AD860241C7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1446512,"avatar":"https://static001.geekbang.org/account/avatar/00/16/12/70/10faf04b.jpg","nickname":"Lywane","note":"","ucode":"2B0027AA069CE9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298809,"discussion_content":"记录在哪里呢？尾节点吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597406038,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298653,"ip_address":""},"score":298809,"extra":""},{"author":{"id":1309908,"avatar":"https://static001.geekbang.org/account/avatar/00/13/fc/d4/743d3f02.jpg","nickname":"Anthony","note":"","ucode":"9E0C98A9123365","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1844885,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo6waC1mF0VmQibDjnJLEgFnmEUSNJozibaUeYZkpQaqicVcXxGZ3kKtnY5XF0iblxT4oiam7ucuJ1bqgg/132","nickname":"Geek_c37e49","note":"","ucode":"BCE0AD860241C7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299548,"discussion_content":"看了redis源码，redis是优化了链表这个这个数据结构，维护了一个结构体，有链表头指针，链表尾指针，和链表长度。所以时间复杂度是O(1)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597733264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298809,"ip_address":""},"score":299548,"extra":""}]}]},{"had_liked":false,"id":240803,"user_name":"前方的灯有点弱","can_delete":false,"product_type":"c1","uid":2058455,"ip_address":"","ucode":"5CEDBCF3DDC991","user_header":"https://static001.geekbang.org/account/avatar/00/1f/68/d7/29025f1f.jpg","comment_is_top":false,"comment_ctime":1597068557,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597068557","product_id":100056701,"comment_content":"虽然不太明白，但是学到了很多，超值","like_count":0},{"had_liked":false,"id":240775,"user_name":"Geek_33c084","can_delete":false,"product_type":"c1","uid":1753056,"ip_address":"","ucode":"32F92FE46C4381","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIIDUnsfAibxPYXkLW0COHStXqD9jgUP9LCqpxeOL76ahZ4kDVIbwtLfedm8paGVsXLfuRuu2ccQ2w/132","comment_is_top":false,"comment_ctime":1597061169,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1597061169","product_id":100056701,"comment_content":"HGETALL  这个操作是获取单个hash值的所有数据，不是O(N)吧，这不是相当于是单元素操作吗？HMGET才是范围查找吧？","like_count":0,"discussions":[{"author":{"id":1956940,"avatar":"","nickname":"李岩","note":"","ucode":"BED3905C9707C0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":308182,"discussion_content":"我理解的是HGETALL是获取所有的entry,然后再遍历去查找各个值，所以是O(N)，而HMGET是计算出hash值后，直接获取一个，所以是单元素操作","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600864847,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240769,"user_name":"MClink","can_delete":false,"product_type":"c1","uid":1435733,"ip_address":"","ucode":"F479190923355C","user_header":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","comment_is_top":false,"comment_ctime":1597058552,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1597058552","product_id":100056701,"comment_content":"rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突<br>哈希函数一旦确定了，对于确定的key ,得到的 value 也一定是确定的，所以桶变多了，哈希函数没有变的话应该也是没用的吧，老师您说，rehash 是增加桶的数量，用来存放已经冲突的元素，Redis 是用什么方式知道这个冲突的元素应该放在哪个桶中的，是不是冲突的元素会另外起一个数组和哈希函数来存储呢？也就是说冲突的元素可能需要不止一次的哈希计算。","like_count":0},{"had_liked":false,"id":240372,"user_name":"xcoder","can_delete":false,"product_type":"c1","uid":1207135,"ip_address":"","ucode":"2C70ED36B4AC8E","user_header":"https://static001.geekbang.org/account/avatar/00/12/6b/5f/cec1e980.jpg","comment_is_top":false,"comment_ctime":1596878830,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596878830","product_id":100056701,"comment_content":"如果说hash桶1中存放了entry1、entry2、entry3的3个键值对，是因为他们的键的hash计算结果值都相同所以都落在了相同的hash桶中，它们之间通过哈希冲突链互相连接。那么再来entry4、entry5、entry6它们的键的hash计算结果值也是和hash桶1对应，但是hash桶1不够用了无法存放entry4、entry5、entry6，rehash的意思是不是就是创建另外一个与hash桶1的hash值相同的hash桶2来存放entry4、entry5、entry6吗？也就是说rehash是当一个hash桶的冲突链中元素太多了，为了性能再创建其他具有同样hash值的hash桶来存放具有相同hash值的键吗？请指点，不太确定我这样的理解是否正确！","like_count":0,"discussions":[{"author":{"id":1207135,"avatar":"https://static001.geekbang.org/account/avatar/00/12/6b/5f/cec1e980.jpg","nickname":"xcoder","note":"","ucode":"2C70ED36B4AC8E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303081,"discussion_content":"哎这就是哈希表的数据结构啊！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599132813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240365,"user_name":"第四范式","can_delete":false,"product_type":"c1","uid":1663762,"ip_address":"","ucode":"61ECDC7C834CAF","user_header":"https://static001.geekbang.org/account/avatar/00/19/63/12/5a22fcc7.jpg","comment_is_top":false,"comment_ctime":1596877788,"is_pvip":false,"replies":[{"id":"88809","content":"加油，欢迎学习交流！","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1597016516,"ip_address":"","comment_id":240365,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1596877788","product_id":100056701,"comment_content":"最近在撸redis源码。看了之后。再看老师的博客。和下面的讨论区。真的是受启发很大。感谢老师。","like_count":0,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503418,"discussion_content":"加油，欢迎学习交流！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597016516,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298028,"discussion_content":"老师博客地址是多少啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597149483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240313,"user_name":"Geek_351cba","can_delete":false,"product_type":"c1","uid":1615196,"ip_address":"","ucode":"6E06DE3F5D67A8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIgyJnqj4CXmyU1l15tNjkvr0fcicic3FDeNT8pxTojA6CuY01rIuT89fb6IjuwAbc42JuXl0tdzj8Q/132","comment_is_top":false,"comment_ctime":1596857668,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596857668","product_id":100056701,"comment_content":"数组下标的时间复杂度读取元素的操作应该是 O(1)吧，写入要O(n)","like_count":0,"discussions":[{"author":{"id":1304739,"avatar":"https://static001.geekbang.org/account/avatar/00/13/e8/a3/d3023e78.jpg","nickname":"眯着眼睛喝咖啡","note":"","ucode":"0B31EB45A80CC8","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298154,"discussion_content":"下标读取是O(1)，但是如果按照数值查询就需要遍历数组了，这个时候就成O(n)了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597205793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240225,"user_name":"起个啥名字比较好","can_delete":false,"product_type":"c1","uid":1170139,"ip_address":"","ucode":"1975CDABB01620","user_header":"https://static001.geekbang.org/account/avatar/00/11/da/db/1a51fe24.jpg","comment_is_top":false,"comment_ctime":1596793985,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1596793985","product_id":100056701,"comment_content":"请问一下，string那里，找到哈希桶就直接找到string了，这个没看懂，一个哈希桶里面只有一个value吗？不是多个entry吗？","like_count":0,"discussions":[{"author":{"id":1539926,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIUBia0Aevb2CyMNPvuzTkVvlcoDpdFELFav5Bcic90wxehZibo0VglM7aRZLMo93Ful7v5TFlKfEYyg/132","nickname":"啊不多","note":"","ucode":"A38DE3C564B748","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297813,"discussion_content":"我也有相同的疑问， string 也有可能是链式的结构的吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597065265,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297782,"discussion_content":"哈希桶存的是指针，指向对应的资源","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597055083,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240201,"user_name":"低调","can_delete":false,"product_type":"c1","uid":1124982,"ip_address":"","ucode":"7D29B371BE9A46","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/76/36fdddb3.jpg","comment_is_top":false,"comment_ctime":1596787044,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596787044","product_id":100056701,"comment_content":"什么时候用哈希冲突链，什么时候rehash","like_count":0},{"had_liked":false,"id":240164,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1596774094,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596774094","product_id":100056701,"comment_content":"第一次听说压缩列表，学到了","like_count":0},{"had_liked":false,"id":240128,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1596768318,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596768318","product_id":100056701,"comment_content":"我现在理解的整数数组和压缩列表，存在的意义是为了做统计用的，不知道是这样吗？","like_count":0},{"had_liked":false,"id":240108,"user_name":"努力努力再努力","can_delete":false,"product_type":"c1","uid":1450822,"ip_address":"","ucode":"1F14391D73E972","user_header":"https://static001.geekbang.org/account/avatar/00/16/23/46/db5212bc.jpg","comment_is_top":false,"comment_ctime":1596763312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596763312","product_id":100056701,"comment_content":"老师问一个问题，看了redis底层的encoding，如果zset在小数据量的情况下，会使用encoding是ziplist，那么这种情况下，ziplist如何保持有序的？不太理解，这个encoding是ziplist，表示的应该就是用ziplist存放所有的数据吧，那么它在小数据量的情况下排序是怎么实现的？","like_count":0},{"had_liked":false,"id":240032,"user_name":"Geek_72b9a7","can_delete":false,"product_type":"c1","uid":2105175,"ip_address":"","ucode":"4C26B79F9F15A9","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/40ab8h1zbSUZmzxARyicDuXECYwtQNDd9jxAbys5LMnVLJMmibTCHd1icrRZMnMSvTJ27UdITA0439hAaVIxcOkGQ/132","comment_is_top":false,"comment_ctime":1596722595,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596722595","product_id":100056701,"comment_content":"蒋老师您好，阅读完这一节收获很大。这里有一个疑问？文中提到当写入数据量很大的时候会rehash.  我们从哪里能看到redis在做rehash. ？渐近式的rehash如果某个桶的冲突较多的话，会影响某次的rehash效率吗？感谢。","like_count":0},{"had_liked":false,"id":239955,"user_name":"QFY","can_delete":false,"product_type":"c1","uid":1144134,"ip_address":"","ucode":"5EAA14772BA908","user_header":"https://static001.geekbang.org/account/avatar/00/11/75/46/815e56c8.jpg","comment_is_top":false,"comment_ctime":1596701034,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596701034","product_id":100056701,"comment_content":"老师，关于rehash那里有两个问题：<br>1.redis切换全局hash表是否是在将原有hash表的全部内容拷贝完成后切换<br>2.如果在rehash过程中，已拷贝过的位置后面又有新的冲突值过来了该怎么办","like_count":0,"discussions":[{"author":{"id":1896868,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/f1/a4/79c36b87.jpg","nickname":"流云","note":"","ucode":"26C5A9166EC6D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301480,"discussion_content":"在rehash过程中，新值是插入到新表，老表的数据拷贝完成后会释放老表的内存，然后新表地址赋给老表","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598535708,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239948,"user_name":"果冻姑娘","can_delete":false,"product_type":"c1","uid":1535792,"ip_address":"","ucode":"DBF5CE70259EF5","user_header":"https://static001.geekbang.org/account/avatar/00/17/6f/30/59be76c0.jpg","comment_is_top":false,"comment_ctime":1596699821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596699821","product_id":100056701,"comment_content":"老师， rehash 的过程，redis 对于 写操作 是如何处理的呀","like_count":0},{"had_liked":false,"id":239816,"user_name":"盟讯","can_delete":false,"product_type":"c1","uid":1590262,"ip_address":"","ucode":"EE057FC9ADEF91","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ZLhicyPutHBNOfYrtwOT4K7D7MvORg3HJlm9HicVj6Zjzp9Cib0JnddrTNVoxFxiautXUgYNBXD6XEVyXK9eP87Y4g/132","comment_is_top":false,"comment_ctime":1596671548,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596671548","product_id":100056701,"comment_content":"老师讲的鞭策入里，知其然而知其所以然。老师问一下，这个渐进式rehash是每读一个索引就迁移一个，要是冷数据，没有读或者很久才读会不会丢失数据。","like_count":0},{"had_liked":false,"id":239787,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1596640490,"is_pvip":true,"discussion_count":2,"race_medal":1,"score":"1596640490","product_id":100056701,"comment_content":"渐进式 rehash ，是不是 hash1 有多少个 hash 桶，就得处理多少个请求才能 rehash 结束？ 在 rehash 过程中新增的数据，应该是直接保存到 hash2上吧","like_count":0,"discussions":[{"author":{"id":2700925,"avatar":"https://static001.geekbang.org/account/avatar/00/29/36/7d/eab0d26a.jpg","nickname":"丹尼尔-雪碧","note":"","ucode":"F098396F4B7500","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552176,"discussion_content":"一方面是redis每接受一次请求，就会把哈希表1中的一个哈希slot的所有entries搬到哈希2对应哈希slot上;另一方面，也有个定时任务进行搬运","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645337945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123262,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/be/81bd6a7b.jpg","nickname":"knife","note":"","ucode":"55EBB099BC5CBB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296908,"discussion_content":"我印象里源码还有个定时任务去迁移的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596702420,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239784,"user_name":"一步","can_delete":false,"product_type":"c1","uid":1005391,"ip_address":"","ucode":"73CEA468CE70C3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/57/4f/6fb51ff1.jpg","comment_is_top":false,"comment_ctime":1596640047,"is_pvip":true,"discussion_count":3,"race_medal":1,"score":"1596640047","product_id":100056701,"comment_content":"redis 利用 hash 数据结构来保存键值对， 每个 hash 桶中保存着entry 的 key 和 value 的指针， 这里有个问题是 在 redis 中所有的 key 都是 string ， 为什么不直接使用 key 呢？ 还是增加一次寻找，使用 key的指针？","like_count":0,"discussions":[{"author":{"id":2308075,"avatar":"","nickname":"Geek_89e362","note":"","ucode":"E596C2CFE1CFAF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":345963,"discussion_content":"使用 hash 可以快速计算数组的下标，然后O(1) 的情况下定位到，如果直接保存key,那么就只能遍历数组查找了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611824090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1010819,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/6c/83/48e528cb.jpg","nickname":"Luke","note":"","ucode":"8368A63185356D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300310,"discussion_content":"为了避免大的字符串key占用太多内存空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598019059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1435733,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/55/92f82281.jpg","nickname":"MClink","note":"","ucode":"F479190923355C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296982,"discussion_content":"也许是为了方便某一天进行key  类型的拓展埋下的伏笔","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596721548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239748,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1596631939,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1596631939","product_id":100056701,"comment_content":"全局Hash表1 满了后 再来了新的PUT请求，是直接将新的数据PUT到全局Hash表2 吗？此时查询的话也是先查1 再查找2这种顺序吗？","like_count":0},{"had_liked":false,"id":239737,"user_name":"u","can_delete":false,"product_type":"c1","uid":1140276,"ip_address":"","ucode":"88FA7BA089807C","user_header":"https://static001.geekbang.org/account/avatar/00/11/66/34/0508d9e4.jpg","comment_is_top":false,"comment_ctime":1596629194,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596629194","product_id":100056701,"comment_content":"今天发工资了，买买买！！！","like_count":0},{"had_liked":false,"id":239668,"user_name":"蓝魔丶","can_delete":false,"product_type":"c1","uid":1219438,"ip_address":"","ucode":"2AE4359E263558","user_header":"https://static001.geekbang.org/account/avatar/00/12/9b/6e/edd2da0c.jpg","comment_is_top":false,"comment_ctime":1596611133,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596611133","product_id":100056701,"comment_content":"老师，既然list，hash，set这些集合类型都有两种底层数据结构，那在什么情况下选择第一种，在什么情况下选择第二种，redis是怎么设计并考虑的？","like_count":0},{"had_liked":false,"id":239635,"user_name":"张晗_Jeremy","can_delete":false,"product_type":"c1","uid":1956890,"ip_address":"","ucode":"47C427BB55210B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/dc/1a/04f212f6.jpg","comment_is_top":false,"comment_ctime":1596601036,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596601036","product_id":100056701,"comment_content":"在Rehash过程中，从表1复制到表2可以理解，但映射是什么意思呢？","like_count":0,"discussions":[{"author":{"id":1131678,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/9e/f17a163d.jpg","nickname":"chenzt","note":"","ucode":"7BF7502CB83210","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298338,"discussion_content":"不是把表1不变的复制到表2，是对表1 数据重新hash取模 映射到表2新的位置","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597251046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239592,"user_name":"al-byte","can_delete":false,"product_type":"c1","uid":1466744,"ip_address":"","ucode":"D0298A02E9259D","user_header":"https://static001.geekbang.org/account/avatar/00/16/61/78/e7aa4e04.jpg","comment_is_top":false,"comment_ctime":1596592749,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596592749","product_id":100056701,"comment_content":"键值存储redis用了两个hash表，在发生rehash时候数据是从一个hash表搬移到另外一个hash同时清除清除搬运的hash桶数据吗？另外查询元素是如何做的老师这里没说，毕竟数据分在两个hash表中了，希望老师解答一下","like_count":0,"discussions":[{"author":{"id":1144333,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/0d/781aa509.jpg","nickname":"路飞桑","note":"","ucode":"2EA3B61395FBA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296614,"discussion_content":"hash表中保存的是dictEntity对象，搬移过程中会将原来hash表中对应位置保存的值设置为null；\n查询会先在第一个hash表中查询，查询不到再到两一个hash表中查询","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1596603467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239589,"user_name":"Jerry You","can_delete":false,"product_type":"c1","uid":2107375,"ip_address":"","ucode":"679A44B505482F","user_header":"https://static001.geekbang.org/account/avatar/00/20/27/ef/a7f94eda.jpg","comment_is_top":false,"comment_ctime":1596592194,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596592194","product_id":100056701,"comment_content":"渐进式rehash，如果遇到put请求应该是直接落到哈希表2中，哈希表1只读不可写，直到所有数据都复制完，然后释放空间么？","like_count":0,"discussions":[{"author":{"id":1144333,"avatar":"https://static001.geekbang.org/account/avatar/00/11/76/0d/781aa509.jpg","nickname":"路飞桑","note":"","ucode":"2EA3B61395FBA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296617,"discussion_content":"每次渐进式rehash后都会检查是否完成了，完成后会将原来的hash表空间释放","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596603752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239467,"user_name":"yyl","can_delete":false,"product_type":"c1","uid":1170843,"ip_address":"","ucode":"1741DACDFCA9AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","comment_is_top":false,"comment_ctime":1596541073,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596541073","product_id":100056701,"comment_content":"每课一答：整数数组和压缩列表是地址空间连续的线性存储结构，适用于较小的数据量场景；该场景下相比其他数据结构更加节省内存空间","like_count":0,"discussions":[{"author":{"id":1170843,"avatar":"https://static001.geekbang.org/account/avatar/00/11/dd/9b/0bc44a78.jpg","nickname":"yyl","note":"","ucode":"1741DACDFCA9AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301921,"discussion_content":"该解答并未明显指出整数数组与压缩列表的优势","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598709000,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239310,"user_name":"🐻🐻","can_delete":false,"product_type":"c1","uid":1027203,"ip_address":"","ucode":"424120B74390CC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ac/83/4c1a18de.jpg","comment_is_top":false,"comment_ctime":1596501546,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1596501546","product_id":100056701,"comment_content":"有一个疑问: <br>List 压缩列表 LPOP 时, 是O(1)吗 ？ 因为压缩列表实际上还是加上了一些附加信息的数组，在数组起始位置增加元素， 是需要搬移元素的<br><br>请老师解答一下，对底层代码的实现有兴趣","like_count":0,"discussions":[{"author":{"id":2107375,"avatar":"https://static001.geekbang.org/account/avatar/00/20/27/ef/a7f94eda.jpg","nickname":"Jerry You","note":"","ucode":"679A44B505482F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296579,"discussion_content":"链表需要搬移什么元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596593040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239217,"user_name":"杨逸林","can_delete":false,"product_type":"c1","uid":1167233,"ip_address":"","ucode":"4BF3CF3E2F1AC7","user_header":"https://static001.geekbang.org/account/avatar/00/11/cf/81/96f656ef.jpg","comment_is_top":false,"comment_ctime":1596461089,"is_pvip":false,"replies":[{"id":"88644","content":"集合类型的数据也有些复杂度高的操作，咱们也要关注起来","user_name":"作者回复","user_name_real":"蒋德钧","uid":"1609687","ctime":1596763859,"ip_address":"","comment_id":239217,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596461089","product_id":100056701,"comment_content":"我以为是 keys 这种，慢操作，原来是针对底层数据结构讲解的“慢”操作。","like_count":0,"discussions":[{"author":{"id":1609687,"avatar":"https://static001.geekbang.org/account/avatar/00/18/8f/d7/fb60129d.jpg","nickname":"蒋德钧","note":"","ucode":"833985C2C37C0A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503025,"discussion_content":"集合类型的数据也有些复杂度高的操作，咱们也要关注起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596763859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}