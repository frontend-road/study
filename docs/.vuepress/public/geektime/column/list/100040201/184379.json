{"id":184379,"title":"18 | 反应式编程框架设计：如何使程序调用不阻塞等待，立即响应？","content":"<p>我们在专栏<a href=\"https://time.geekbang.org/column/article/166581\">第1篇</a>就讨论了为什么在高并发的情况下，程序会崩溃。主要原因是，在高并发的情况下，有大量用户请求需要程序计算处理，而目前的处理方式是，为每个用户请求分配一个线程，当程序内部因为访问数据库等原因造成线程阻塞时，线程无法释放去处理其他请求，这样就会造成请求堆积，不断消耗资源，最终导致程序崩溃。</p><p><img src=\"https://static001.geekbang.org/resource/image/02/c3/02d5af37b36b083b4eea6e44e54988c3.png?wh=1366*360\" alt=\"\"></p><p>这是传统的Web应用程序运行期的线程特性。对于一个高并发的应用系统来说，总是同时有很多个用户请求到达系统的Web容器。Web容器为每个请求分配一个线程进行处理，线程在处理过程中，如果遇到访问数据库或者远程服务等操作，就会进入阻塞状态，这个时候，如果数据库或者远程服务响应延迟，就会出现程序内的线程无法释放的情况，而外部的请求不断进来，导致计算机资源被快速消耗，最终程序崩溃。</p><p>那么有没有不阻塞线程的编程方法呢？</p><h2>反应式编程</h2><p>答案就是反应式编程。反应式编程本质上是一种异步编程方案，在多线程（协程）、异步方法调用、异步I/O访问等技术基础之上，提供了一整套与异步调用相匹配的编程模型，从而实现程序调用非阻塞、即时响应等特性，即开发出一个反应式的系统，以应对编程领域越来越高的并发处理需求。</p><p>人们还提出了一个反应式宣言，认为反应式系统应该具备如下特质：</p><!-- [[[read_end]]] --><p><strong>即时响应</strong>，应用的调用者可以即时得到响应，无需等到整个应用程序执行完毕。也就是说应用调用是非阻塞的。</p><p><strong>回弹性</strong>，当应用程序部分功能失效的时候，应用系统本身能够进行自我修复，保证正常运行，保证响应，不会出现系统崩溃和宕机的情况。</p><p><strong>弹性</strong>，系统能够对应用负载压力做出响应，能够自动伸缩以适应应用负载压力，根据压力自动调整自身的处理能力，或者根据自身的处理能力，调整进入系统中的访问请求数量。</p><p><strong>消息驱动</strong>，功能模块之间，服务之间，通过消息进行驱动，完成服务的流程。</p><p>目前主流的反应式编程框架有RxJava、Reactor等，它们的主要特点是基于<strong>观察者设计模式</strong>的异步编程方案，编程模型采用函数式编程。</p><p>观察者模式和函数式编程有自己的优势，但是反应式编程并不是必须用观察者模式和函数式编程。Flower就是一个纯消息驱动，完全异步，支持命令式编程的反应式编程框架。</p><p>下面我们就看看Flower如何实现异步无阻塞的调用，以及Flower这个框架设计使用了什么样的设计原则与模式。</p><h2>反应式编程框架Flower的基本原理</h2><p>一个使用Flower框架开发的典型Web应用的线程特性如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/cc/d32ecc606278266b20a956f3767635cc.png?wh=1352*344\" alt=\"\"></p><p>当并发用户到达应用服务器的时候，Web容器线程不需要执行应用程序代码，它只是将用户的HTTP请求变为请求对象，将请求对象异步交给Flower框架的Service去处理，自身立刻就返回。因为容器线程不做太多的工作，所以只需极少的容器线程就可以满足高并发的用户请求，用户的请求不会被阻塞，不会因为容器线程不够而无法处理。相比传统的阻塞式编程，Web容器线程要完成全部的请求处理操作，直到返回响应结果才能释放线程；<strong>使用Flower框架只需要极少的容器线程就可以处理较<strong><strong>多</strong></strong>的并发用户请求，而且容器线程不会阻塞。</strong></p><p>用户请求交给基于Flower框架开发的业务Service对象以后，Service之间依然是使用异步消息通讯的方式进行调用，不会直接进行阻塞式的调用。一\b个Service完成业务逻辑处理计算以后，会返回一个处理结果，这个结果以消息的方式异步发送给它的下一个Service。</p><p>传统编程模型的Service之间如果进行调用，如我们在专栏第一篇讨论的那样，被调用的Service在返回之前，调用的Service方法只能阻塞等待。而Flower的Service之间使用了AKKA Actor进行消息通信，调用者的Service发送调用消息后，不需要等待被调用者返回结果，就可以处理自己的下一个消息了。事实上，这些Service可以复用同一个线程去处理自己的消息，也就是说，<strong>只需要有限的几个线程就可以完成大量的Service处理和消息传输，这些线程不会阻塞等待。</strong></p><p>我们刚才提到，通常Web应用主要的线程阻塞，是因为数据库的访问导致的线程阻塞。Flower支持异步数据库驱动，用户请求数据库的时候，将请求提交给异步数据库驱动，立刻就返回，不会阻塞当前线程，异步数据库访问连接远程的数据库，进行真正的数据库操作，得到结果以后，将结果以异步回调的方式发送给Flower的Service进行进一步的处理，<strong>这个时候依然不会有线程被阻塞。</strong></p><p>也就是说，使用Flower开发的系统，在一个典型的Web应用中，几乎没有任何地方会被阻塞，所有的线程都可以被不断地复用，<strong>有限的线程就可以完成大量的并发用户请求，从而大大地提高了系统的吞吐能力和响应时间</strong>，同时，由于线程不会被阻塞，<strong>应用就不会因为并发量太大或者数据库处理缓慢而宕机，从而提高了系统的可用性。</strong></p><p>Flower框架实现异步无阻塞，一方面是利用了Web容器的异步特性，主要是Servlet3.0以后提供的AsyncContext，快速释放容器线程；另一方面是利用了异步的数据库驱动以及异步的网络通信，主要是HttpAsyncClient等异步通信组件。而Flower框架内，核心的应用代码之间的异步无阻塞调用，则是利用了Akka 的Actor模型实现。</p><p>Akka Actor的异步消息驱动实现如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/10/25/1045f11aa3ffafb552619872161b6725.jpg?wh=755*228\" alt=\"\"></p><p>一个Actor向另一个Actor进行通讯的时候，当前Actor就是一个消息的发送者sender，当它想要向另一个Actor进行通讯的时候，就需要获得另一个Actor的ActorRef，也就是一个引用，通过引用进行消息通信。而ActorRef收到消息以后，会将这个消息放入到目标Actor的Mailbox里面去，然后就立即返回了。</p><p>也就是说一个Actor向另一个Actor发送消息的时候，不需要另一个Actor去真正地处理这个消息，只需要将消息发送到目标Actor的Mailbox里面就可以了。自己不会被阻塞，可以继续执行自己的操作，而目标Actor检查自己的Mailbox中是否有消息，如果有消息，Actor则会在从Mailbox里面去获取消息，对消息进行异步的处理，而所有的Actor会共享线程，这些线程不会有任何的阻塞。</p><h2>反应式编程框架Flower的设计方法</h2><p>但是直接使用Actor进行编程有很多不便，Flower框架对Actor进行了封装，开发者只需要编写一些细粒度的Service，这些Service会被包装在Actor里面，进行异步通信。</p><p>Flower Service例子如下：</p><pre><code>public class ServiceA implements Service&lt;Message2&gt; {\n  @Override\n  public Object process(Message2 message) {\n    return message.getAge() + 1;\n  }\n}\n</code></pre><p>每个Service都需要实现框架的Service接口的process方法，process方法的输入参数就是前一个Service process方法的返回值，这样只需要将Service编排成一个流程，Service的返回值就会变成Actor的一个消息，被发送给下一个Service，从而实现Service的异步通信。</p><p>Service的流程编排有两种方式，一种方式是编程实现，如下：</p><pre><code>getServiceFlow().buildFlow(&quot;ServiceA&quot;, &quot;ServiceB&quot;);\n\n</code></pre><p>表示ServiceA的返回值将作为消息发送给ServiceB，成为ServiceB的输入值，这样两个Service就可以合作完成一些更复杂的业务逻辑。</p><p>Flower还支持可视化的Service流程编排，像下面这张图一样编辑流程定义文件，就可以开发一个异步业务处理流程。</p><p><img src=\"https://static001.geekbang.org/resource/image/22/85/221c5366834d24bbad8a9e0ab1441785.png?wh=603*343\" alt=\"\"></p><p>那么这个Flower框架是如何实现的呢？</p><p>Flower框架的设计也是基于前面专栏讨论过的<a href=\"https://time.geekbang.org/column/article/179282\">依赖倒置原则</a>。所有应用开发者实现的Service类都需要包装在Actor里面进行异步调用，但是Actor不会依赖开发者实现的Service类，开发者也不会依赖Actor类，他们共同依赖一个Service接口，这个接口是框架提供的，如上面例子所示。</p><p>Actor与Service的依赖倒置关系如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/55/97/557b2bb561c44c2309aa96a06f7c9797.png?wh=894*430\" alt=\"\"></p><p>每个Actor都依赖一个Service接口，而具体的Service实现类，比如MyService，则实现这个Service接口。在运行期实例化Actor的时候，这个接口被注入具体的Service实现类，比如MyService。在Flower中，调用MyService对象，其实就是给包装MyService对象的Actor发消息，Actor收到消息，执行自己的onReceive方法，在这个方法里，Actor调用MyService的process方法，并将onReceive收到的Message对象当做process的输入参数传入。</p><p>process处理完成后，返回一个Object对象。Actor会根据编排好的流程，获取MyService在流程中的下一个Service对应的Actor，即nextServiceActor，将process返回的Object对象当做消息发送给这个nextServiceActor。这样，Service之间就根据编排好的流程，异步、无阻塞地调用执行起来了。</p><h2>反应式编程框架Flower的落地效果</h2><p>Flower框架在部分项目中落地应用，应用效果较为显著，一方面，Flower可以显著提高系统的性能。这是某个C#开发的系统使用Flower重构后的TPS性能比较，使用Flower开发的系统TPS差不多是原来C#系统的两倍。</p><p><img src=\"https://static001.geekbang.org/resource/image/d8/00/d8e8f1a444e69356f8dc45d517428c00.png?wh=834*536\" alt=\"\"></p><p>另一方面，Flower对系统可用性也有较大提升，目前常见互联网应用架构如下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/bd/a9/bdcb25e0ca9a3ba7686a28f4287dada9.png?wh=818*308\" alt=\"\"></p><p>用户请求通过网关服务器调用微服务完成处理，那么当有某个微服务连接的数据库查询执行较慢时，如图中服务1，那么按照传统的线程阻塞模型，就会导致服务1的线程都被阻塞在这个慢查询的数据库操作上。同样的，网关线程也会阻塞在调用这个延迟比较厉害的服务1上。</p><p>最终的效果就是，网关所有的线程都被阻塞，即使是不调用服务1的用户请求也无法处理，最后整个系统失去响应，应用宕机。使用阻塞式编程，实际的压测效果如下，当服务1响应延迟，出错率大幅飙升的时候，通过网关调用正常的服务2的出错率也非常高。</p><p><img src=\"https://static001.geekbang.org/resource/image/77/f7/777cc6b37a94f2a7f93c107187c68af7.png?wh=2248*198\" alt=\"\"></p><p>使用Flower开发的网关，实际压测效果如下，同样服务1响应延迟，出错率极高的情况下，通过Flower网关调用服务2完全不受影响。</p><p><img src=\"https://static001.geekbang.org/resource/image/97/8b/97923d96fb3b59159ed70c5457412d8b.png?wh=2248*182\" alt=\"\"></p><h2>小结</h2><p>事实上，Flower不仅是一个反应式Web编程框架，还是反应式的微服务框架。也就是说，Flower的Service可以远程部署到一个Service容器里面，就像我们现在常用的微服务架构一样。Flower会提供一个独立的Flower容器，用于启动一些Service，这些Service在启动了以后，会向注册中心进行注册，而且应用程序可以将这些分布式的Service进行流程编排，得到一个分布式非阻塞的微服务系统。整体架构和主流的微服务架构很像，主要的区别就是Flower的服务是异步的，通过流程编排的方式进行服务调用，而不是通过接口依赖的方式进行调用。</p><p>你可以点击<a href=\"https://github.com/zhihuili/flower\">这里</a>进入Flower框架的源代码地址，欢迎你参与Flower开发，也欢迎将Flower应用到你的系统开发中。你对Flower有什么疑问，也欢迎与我交流。</p><h2>思考题</h2><p>反应式编程虽然能带来性能和可用性方面的提升，但是也带来一些问题，你觉得反应式编程可能存在的问题有哪些？应该如何应对？你是否愿意在工作实践中尝试反应式编程？</p><p>欢迎你在评论区写下你的思考，也欢迎把这篇文章分享给你的朋友或者同事，一起交流。</p>","neighbors":{"left":{"article_title":"17 | 设计模式应用：编程框架中的设计模式","id":183371},"right":{"article_title":"19 | 组件设计原则：组件的边界在哪里？","id":185043}},"comments":[{"had_liked":false,"id":169784,"user_name":"Paul Shan","can_delete":false,"product_type":"c1","uid":1593140,"ip_address":"","ucode":"32D99989028284","user_header":"","comment_is_top":false,"comment_ctime":1578446394,"is_pvip":false,"replies":[{"id":"65989","content":"👍","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1578532139,"ip_address":"","comment_id":169784,"utype":1}],"discussion_count":2,"race_medal":0,"score":"143312367162","product_id":100040201,"comment_content":"高并发系统，传统解决方案的弊端在于调度的单元是线程，当IO操作时，线程做无谓地等待，相应的CPU资源白白浪费，线程数目多到一定程度，系统就会被压垮。<br><br>反应式编程的第一个目标即时响应，就是异步非阻塞的，遇到IO操作就返回，通过回调函数来取结果。<br>反应式系统第二个目标回弹性，系统有一定的自我修复功能，个人以为这和反应式编程的本质没太大关系，系统自我修复和错误处理是任何系统都想要的功能，和反应式编程关系不大，这里可能和微服务的关系更大，不知道老师如何看这个问题。<br>反应式系统第三个目标是弹性，反应式编程在数据的请求和回调存在间隙，系统需要合理安排资源，让这个间隙全局而言最小。<br>反应式编程第四个目标是消息驱动，反应式编程在数据请求和消费解耦了，需要用另外的机制串起来，消息驱动就是其中一种串法。<br><br>反应式编程通过分离数据请求和数据消费以达到有效利用CPU和IO资源，提高并发的目的。我个人以为反应式编程是编程的未来，因为异步才是数据流转的本质。传统操作系统成型的时候CPU只有一颗，那时同步编程思想是主流。现在多核系统已经是主流，异步编程更为高效。<br><br>反应式编程本身的问题就是得学一种新的编程范式，像rxjava学习曲线还是挺陡峭的。反应式编程拆分了请求数据和消费数据，通过消息来驱动可能带来数据的多次拷贝，函数式编程尤其强调数据的不可更改，只好通过拷贝来解决，本质上是一种用空间换时间的策略，会消耗更多的内存。异步编程调错总归有些麻烦，这也是成本之一。<br>","like_count":34,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480719,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578532139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2418763,"avatar":"https://static001.geekbang.org/account/avatar/00/24/e8/4b/8ddf36b0.jpg","nickname":"程同学","note":"","ucode":"622B71D5A2DA5E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343642,"discussion_content":"处理请求的资源是线程，面对大量请求，传统的解决方案是给每个请求申请线程资源，而反应式编程的思路是线程复用。\n\n就像CPU复用技术，单核CPU也可以同时处理多个请求","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611120395,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167527,"user_name":"草原上的奔跑","can_delete":false,"product_type":"c1","uid":1120348,"ip_address":"","ucode":"D69C617F767736","user_header":"https://static001.geekbang.org/account/avatar/00/11/18/5c/1a58e8f6.jpg","comment_is_top":false,"comment_ctime":1577848583,"is_pvip":false,"replies":[{"id":"65032","content":"异步难调试主要是因为异步的代码执行在不同的线程上，导致没有统一的调用栈，异常的时候不知道哪里出错的。Flower通过流程编排的方式管理异步方法代码，出错的时候可以通过流程定位异常，对调试定位有帮助。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1577862116,"ip_address":"","comment_id":167527,"utype":1}],"discussion_count":2,"race_medal":0,"score":"91772161799","product_id":100040201,"comment_content":"异步的调用一般比较难调试，运行正常的时候性能好、可用性高，但出问题后debug比较困难，不知道李老师你们是如何处理的","like_count":22,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479891,"discussion_content":"异步难调试主要是因为异步的代码执行在不同的线程上，导致没有统一的调用栈，异常的时候不知道哪里出错的。Flower通过流程编排的方式管理异步方法代码，出错的时候可以通过流程定位异常，对调试定位有帮助。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577862116,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254493,"avatar":"https://static001.geekbang.org/account/avatar/00/13/24/5d/65e61dcb.jpg","nickname":"听雨","note":"","ucode":"252754F9FCFF0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387931,"discussion_content":"可以试试idea的多线程调试功能","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628502112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181028,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1582461997,"is_pvip":false,"replies":[{"id":"70252","content":"<br>1 不是放入线程池中，是放入队列中，等待线程执行，这样就只需要较少的线程，执行大量的操作，减少线程启动和调度，性能更好<br>2 对于IO操作，非阻塞意味着不会不会阻塞线程，避免线程资源浪费，性能更好<br>3 性能不只是响应时间或者处理速度，异步操作也许不能降低响应时间，但是可以处理更多请求，也是提升性能，具体参考高性能一篇专栏<br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1582513064,"ip_address":"","comment_id":181028,"utype":1}],"discussion_count":2,"race_medal":0,"score":"35942200365","product_id":100040201,"comment_content":"请教一下老师，我理解的异步非阻塞调用其实就是将耗时操作放到了另外的线程池中，这个感觉对性能上没有多大提升啊，比如我了解到的reactor","like_count":9,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484891,"discussion_content":"\n1 不是放入线程池中，是放入队列中，等待线程执行，这样就只需要较少的线程，执行大量的操作，减少线程启动和调度，性能更好\n2 对于IO操作，非阻塞意味着不会不会阻塞线程，避免线程资源浪费，性能更好\n3 性能不只是响应时间或者处理速度，异步操作也许不能降低响应时间，但是可以处理更多请求，也是提升性能，具体参考高性能一篇专栏\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582513064,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541209,"discussion_content":"从资源的优化配置的角度去想。假设总资源是一定的，让耗时的服务占用更多的资源，同时让它缓慢地去执行队列。快速的服务不等待慢速的服务，这样减少了线程阻塞的时间，总的资源利用率提高了，处理的请求数提高了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640292657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230318,"user_name":"Jagger Chen","can_delete":false,"product_type":"c1","uid":1993603,"ip_address":"","ucode":"7C6ACBCF32ED12","user_header":"https://static001.geekbang.org/account/avatar/00/1e/6b/83/5fb44cd0.jpg","comment_is_top":false,"comment_ctime":1593346382,"is_pvip":false,"replies":[{"id":"85788","content":"即时响应的目的是为了不阻塞调用端线程，提高处理能力。<br>调用端为什么需要得到计算结果，为了下一步计算？那被调用者把自己的计算结果传递给自己的下一个被调用者就可以了。<br><br>你可以看下Flower的web开发demo，http response不是Controller返回的，而是计算出客户端结果的那个service调用web.print返回的。这样在计算过程中，可以随时返回response，而不用等到全部处理完在返回。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1594003111,"ip_address":"","comment_id":230318,"utype":1}],"discussion_count":4,"race_medal":0,"score":"23068182862","product_id":100040201,"comment_content":"老师您好，关于即时响应，如果程序还没计算出结果，响应什么给调用端呢？","like_count":6,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499837,"discussion_content":"即时响应的目的是为了不阻塞调用端线程，提高处理能力。\n调用端为什么需要得到计算结果，为了下一步计算？那被调用者把自己的计算结果传递给自己的下一个被调用者就可以了。\n\n你可以看下Flower的web开发demo，http response不是Controller返回的，而是计算出客户端结果的那个service调用web.print返回的。这样在计算过程中，可以随时返回response，而不用等到全部处理完在返回。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594003111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":541210,"discussion_content":"不是任何类型的请求都可以异步解决的。适合的，比如银行转账请求，服务器收到请求后，将一个临时的通知先返回给用户，告知用户“请求正在处理中”。在后台，原本的请求会在一个一个服务中排队执行，完全执行后，再另外通知给用户执行结果。有些请求需要即使反馈结果，比如游戏操作，就必须同步了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640292957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2088626,"avatar":"","nickname":"志江","note":"","ucode":"8A07D53769B3C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309602,"discussion_content":"这么返回的话他怎么知道响应给谁呢?因为此时的响应不是当时的那个请求线程了啊, 还是没法给串起来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601364549,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1018061,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/88/cd/2c3808ce.jpg","nickname":"Yangjing","note":"","ucode":"D88DFD4958D07C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":2088626,"avatar":"","nickname":"志江","note":"","ucode":"8A07D53769B3C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558508,"discussion_content":"个人理解：响应给回调的方法（那个线程执行的并不重要）；如果是响应给API请求，就是输出到请求对应的socket中","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648356508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309602,"ip_address":""},"score":558508,"extra":""}]}]},{"had_liked":false,"id":202660,"user_name":"lofaith","can_delete":false,"product_type":"c1","uid":1322553,"ip_address":"","ucode":"5DF6922BBF1AD5","user_header":"https://static001.geekbang.org/account/avatar/00/14/2e/39/7682b49e.jpg","comment_is_top":false,"comment_ctime":1586047962,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18765917146","product_id":100040201,"comment_content":"老师，那nodejs是不是更适合做这种事情","like_count":4,"discussions":[{"author":{"id":1070298,"avatar":"https://static001.geekbang.org/account/avatar/00/10/54/da/e2e5ddf7.jpg","nickname":"2102","note":"","ucode":"A67068F2A3157E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":569541,"discussion_content":"nodejs是回调式编程，应该说目标一致，实现不同","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651475536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1102490,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d2/9a/d56bb650.jpg","nickname":"多多","note":"","ucode":"DA5AF8146AEF82","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299294,"discussion_content":"哈哈，我觉得nodejs天生就是这么支持的。我们大数据处理以nodejs为主。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597647131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1104850,"avatar":"https://static001.geekbang.org/account/avatar/00/10/db/d2/e29f8834.jpg","nickname":"lidashuang","note":"","ucode":"560ABE8032760E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289912,"discussion_content":"actor更像erlang","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594266043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167502,"user_name":"老男孩","can_delete":false,"product_type":"c1","uid":1134514,"ip_address":"","ucode":"CEC6D47412F620","user_header":"https://static001.geekbang.org/account/avatar/00/11/4f/b2/1e8b5616.jpg","comment_is_top":false,"comment_ctime":1577845438,"is_pvip":false,"replies":[{"id":"65033","content":"新年快乐。异步数据库驱动还是有一些的，但是因为业界用的不多，所以都不怎么维护。反应式编程的大气候还是没起来。<br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1577862555,"ip_address":"","comment_id":167502,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18757714622","product_id":100040201,"comment_content":"李老师和专栏的朋友们新年快乐！哈哈！又一年了。虽然我还在现实的苟且中徘徊，但依然算是不忘初心吧。用一句现在很流行的话就是，愿大家只争朝夕，不负韶华。之前研究了一下spring的webflux发现目前异步编程在数据库驱动这块对关系型数据库的支持不太好，比如myspl。还有诺诺的问一下，mailbox是不是一个内存队列？不知道flower能不能支持用第三方的消息队列来替换mailbox的工作？还有actor里边是不是用到模板设计模式了？","like_count":4,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479885,"discussion_content":"新年快乐。异步数据库驱动还是有一些的，但是因为业界用的不多，所以都不怎么维护。反应式编程的大气候还是没起来。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577862555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172463,"user_name":"诗泽","can_delete":false,"product_type":"c1","uid":1031865,"ip_address":"","ucode":"F28BE01C3FD12F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/b9/f2481c2c.jpg","comment_is_top":false,"comment_ctime":1579181458,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14464083346","product_id":100040201,"comment_content":"感觉这个还是要看场景，从用户侧来看一些用户操作之后是需要同步等结果回来，比如搜索，不能点击搜索之后过一会再来看结果。另外，异步数据库驱动听上去很腻害的样子，可惜这部分没展开讲","like_count":3},{"had_liked":false,"id":182066,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1582702179,"is_pvip":false,"replies":[{"id":"70489","content":"Flower中没有调用，也就没有回调。<br>服务经过编排后，由框架异步执行服务。<br>一个服务执行完，他的结果不是返回给他的上一个服务，而是发送给他的下一个服务。<br><br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1582708535,"ip_address":"","comment_id":182066,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10172636771","product_id":100040201,"comment_content":"老师，回调函数由谁来执行呢？比如线程1异步调用某方法，由线程2执行方法，那线程2执行完之后谁来执行回调函数呢","like_count":3,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485213,"discussion_content":"Flower中没有调用，也就没有回调。\n服务经过编排后，由框架异步执行服务。\n一个服务执行完，他的结果不是返回给他的上一个服务，而是发送给他的下一个服务。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582708535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173347,"user_name":"麋鹿在泛舟","can_delete":false,"product_type":"c1","uid":1121975,"ip_address":"","ucode":"1379CADA08688E","user_header":"https://static001.geekbang.org/account/avatar/00/11/1e/b7/b20ab184.jpg","comment_is_top":false,"comment_ctime":1579508771,"is_pvip":true,"replies":[{"id":"67240","content":"阻塞基本上都是IO阻塞，使用异步IO即可，如文中所述。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1579569262,"ip_address":"","comment_id":173347,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10169443363","product_id":100040201,"comment_content":"“反应式实践其实更多落地就是在前端，发送请求后就不管了，然后等到异步响应到达后异步更新页面。”<br>所以对于后端系统来说，怎么应对阻塞呢？","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482044,"discussion_content":"阻塞基本上都是IO阻塞，使用异步IO即可，如文中所述。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579569262,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169613,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1578389348,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10168323940","product_id":100040201,"comment_content":"学习到了","like_count":2},{"had_liked":false,"id":167740,"user_name":"鹏酱","can_delete":false,"product_type":"c1","uid":1528879,"ip_address":"","ucode":"CA87B7CFD1BF7A","user_header":"https://static001.geekbang.org/account/avatar/00/17/54/2f/429c568d.jpg","comment_is_top":false,"comment_ctime":1577926464,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10167861056","product_id":100040201,"comment_content":"最终一致性和结果查询，处理方法是，补偿机制和定时查询","like_count":2},{"had_liked":false,"id":280099,"user_name":"def","can_delete":false,"product_type":"c1","uid":1263977,"ip_address":"","ucode":"39BDBEA0560C13","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/69/c0fcf4e8.jpg","comment_is_top":false,"comment_ctime":1614079940,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5909047236","product_id":100040201,"comment_content":"在使用Spring webflux进行异步编程实践的过程中发现一个主要问题就是难以调试和跟踪定位问题。目前的解决方案是构建分布式链路追踪系统，给每一个全局请求都加上一个全局traceId，然后请求在各微服务中的流转还有跟踪的spanId","like_count":2},{"had_liked":false,"id":269817,"user_name":"托尼斯威特","can_delete":false,"product_type":"c1","uid":1729060,"ip_address":"","ucode":"98A1035527292E","user_header":"https://static001.geekbang.org/account/avatar/00/1a/62/24/07e2507c.jpg","comment_is_top":false,"comment_ctime":1608795426,"is_pvip":false,"replies":[{"id":"97858","content":"在actor里给sender发消息，把处理结果发送过去","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1608861118,"ip_address":"","comment_id":269817,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903762722","product_id":100040201,"comment_content":"请问一个细节: &quot;Actor 则会在从 Mailbox 里面去获取消息，对消息进行异步的处理&quot;. 消息的处理结果如何返回给Sender呢? Sender如果不靠回调函数, 又是如何知道怎么处理返回来的结果的呢? ","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512404,"discussion_content":"在actor里给sender发消息，把处理结果发送过去","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608861118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250382,"user_name":"escray","can_delete":false,"product_type":"c1","uid":1020525,"ip_address":"","ucode":"1F4204930E47C4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/92/6d/becd841a.jpg","comment_is_top":false,"comment_ctime":1601043556,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"5896010852","product_id":100040201,"comment_content":"不明觉厉。<br><br>老师现身说法，作为架构师必须有一个属于自己的开源框架加持。<br><br>能够看明白老师描述的 Flower 框架的基本原理，但是因为对于 AKKA 基本上上无知，感觉缺少一些背景知识。<br><br>浏览了一下 Github 上的那篇论文《下一代的反应式编程框架研究与实现》，虽然没有细看，但是感觉讲的还是挺清楚的。<br><br>注意到一个细节，已经不仅仅是“反应式编程框架”而是一个“反应式微服务框架”，强调了“微服务”。","like_count":1},{"had_liked":false,"id":231190,"user_name":"moony320","can_delete":false,"product_type":"c1","uid":1028917,"ip_address":"","ucode":"56E5DD71293EB3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b3/35/526c033a.jpg","comment_is_top":false,"comment_ctime":1593605056,"is_pvip":false,"replies":[{"id":"85784","content":"需要异步通信，包括异步数据库。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1594002308,"ip_address":"","comment_id":231190,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5888572352","product_id":100040201,"comment_content":"线程不是瓶颈后，connection就变成下一个瓶颈了","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500194,"discussion_content":"需要异步通信，包括异步数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594002308,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2063114,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/7b/0a/b65e1fae.jpg","nickname":"不要挑战自己的智商","note":"","ucode":"4910FF07C35DC5","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293124,"discussion_content":"关系型数据库 比如mysql 怎么异步呢？最终数据库的读写速度成为了瓶颈 不是吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595439174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230316,"user_name":"Jagger Chen","can_delete":false,"product_type":"c1","uid":1993603,"ip_address":"","ucode":"7C6ACBCF32ED12","user_header":"https://static001.geekbang.org/account/avatar/00/1e/6b/83/5fb44cd0.jpg","comment_is_top":false,"comment_ctime":1593346217,"is_pvip":false,"replies":[{"id":"85790","content":"消息驱动的反应式框架，比如flower，可以通过消息传递状态。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1594003424,"ip_address":"","comment_id":230316,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5888313513","product_id":100040201,"comment_content":"老师您好，同步编程中使用 ThreadLocal 来跨类传递状态，在响应式编程模型中如何做呢？这个算不算是一个弊端？","like_count":2,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499836,"discussion_content":"消息驱动的反应式框架，比如flower，可以通过消息传递状态。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594003424,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170473,"user_name":"饭饭","can_delete":false,"product_type":"c1","uid":1097426,"ip_address":"","ucode":"EF6F6B5F6839F3","user_header":"https://static001.geekbang.org/account/avatar/00/10/be/d2/1400c368.jpg","comment_is_top":false,"comment_ctime":1578618891,"is_pvip":false,"replies":[{"id":"66084","content":"编程模型不同，我们认为Flower编程模型更加友好，事实如何，我们将来再看。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1578622399,"ip_address":"","comment_id":170473,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873586187","product_id":100040201,"comment_content":"这样流程编排的为什么不用akka stream?有什么考虑嘛？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480993,"discussion_content":"编程模型不同，我们认为Flower编程模型更加友好，事实如何，我们将来再看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578622399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":168356,"user_name":"你的美","can_delete":false,"product_type":"c1","uid":1529298,"ip_address":"","ucode":"71B97BDBA3CDC3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/iacfiaRC2Vze9eEaVibAFkngm4nmA0DwoibC3kHj6pCOQ87VDa955kK3kavnrDnibmfeIFd4G6Ab2fDkNrbUapL8ibAQ/132","comment_is_top":false,"comment_ctime":1578054189,"is_pvip":false,"replies":[{"id":"65456","content":"购买以后可以一直看的","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1578198853,"ip_address":"","comment_id":168356,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5873021485","product_id":100040201,"comment_content":"老师这篇文章我一时还掌握不了，课程学完后，以后多久就不能打开看了呢？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480202,"discussion_content":"购买以后可以一直看的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578198853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167607,"user_name":"七七的首席铲屎官","can_delete":false,"product_type":"c1","uid":1350773,"ip_address":"","ucode":"28D7A1AE62C070","user_header":"https://static001.geekbang.org/account/avatar/00/14/9c/75/b9683f39.jpg","comment_is_top":false,"comment_ctime":1577875595,"is_pvip":false,"replies":[{"id":"65107","content":"反应式实践其实更多落地就是在前端，发送请求后就不管了，然后等到异步响应到达后异步更新页面。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1577932871,"ip_address":"","comment_id":167607,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5872842891","product_id":100040201,"comment_content":"老师您好 对响应式我有一点困惑 响应式通过异步消息来减少同步造成的时间等待 但是在实际实践的时候对于需要同步的需求要怎么实现呢 比如在页面对某个字段进行更新时响应式接口无法立即得到最终的结果 对于更新失败的情况怎么在前端展示呢？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479916,"discussion_content":"反应式实践其实更多落地就是在前端，发送请求后就不管了，然后等到异步响应到达后异步更新页面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577932871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167577,"user_name":"a、","can_delete":false,"product_type":"c1","uid":1532404,"ip_address":"","ucode":"590FE8DB111492","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","comment_is_top":false,"comment_ctime":1577866395,"is_pvip":false,"replies":[{"id":"65109","content":"背后的运行原理一致，但是编程模型有很大区别，Flower是基于流程进行编程的，更符合开发者的思维习惯。","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1577932952,"ip_address":"","comment_id":167577,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5872833691","product_id":100040201,"comment_content":"老师，我目前使用的play框架也是基于akka做异步调用的，你觉得play框架和flower框架有哪些区别？","like_count":1,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479903,"discussion_content":"背后的运行原理一致，但是编程模型有很大区别，Flower是基于流程进行编程的，更符合开发者的思维习惯。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577932952,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1532404,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIvUlicgrWtibbDzwhLw5cQrDSy2JuE1mVvmXq11KQIwpLicgDuWfpp9asE0VCN6HhibPDWn7wBc2lfmA/132","nickname":"a、","note":"","ucode":"590FE8DB111492","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":113809,"discussion_content":"好的，谢谢老师，我去研究下flower","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577934231,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":303754,"user_name":"geek_arong2048","can_delete":false,"product_type":"c1","uid":1518310,"ip_address":"","ucode":"AB575BE100E4A9","user_header":"https://static001.geekbang.org/account/avatar/00/17/2a/e6/c788257f.jpg","comment_is_top":false,"comment_ctime":1626963400,"is_pvip":false,"replies":[{"id":"110064","content":"我们的建议是不要以任何方式获取处理结果，而是让处理结果向后面的service流动，直到计算出最终的结果，由这个计算出最终结果的service完成输出（如果是http，有这个service进行response.print）。<br><br>","user_name":"作者回复","user_name_real":"李智慧","uid":"1007349","ctime":1627291290,"ip_address":"","comment_id":303754,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1626963400","product_id":100040201,"comment_content":"关于反应式设计如何取得响应的一些理解：<br>1、提交请求后，Server立即返回一个JobID，请求方通过Cornjob去轮训这个JobID拉取执行结果<br>2、提交请求后，新增Http&#47;MQ&#47;RPC服务作为输出源，Server执行完成之后向指定输出源发起回调<br><br>何时采用反应式设计：<br>不能够短时间内获取到结果的服务（数据下载处理、Hive离线数据拉取、过ML模型等），是异步处理的一种方式","like_count":0,"discussions":[{"author":{"id":1007349,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5e/f5/018907ac.jpg","nickname":"李智慧","note":"","ucode":"8C9980C438AFD1","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":523811,"discussion_content":"我们的建议是不要以任何方式获取处理结果，而是让处理结果向后面的service流动，直到计算出最终的结果，由这个计算出最终结果的service完成输出（如果是http，有这个service进行response.print）。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627291290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286674,"user_name":"Geek_3b1096","can_delete":false,"product_type":"c1","uid":1549364,"ip_address":"","ucode":"A6BD92B79B3632","user_header":"","comment_is_top":false,"comment_ctime":1617471341,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1617471341","product_id":100040201,"comment_content":"谢谢老师","like_count":0},{"had_liked":false,"id":222873,"user_name":"oliver","can_delete":false,"product_type":"c1","uid":1505929,"ip_address":"","ucode":"980EBABF71AFBC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLOMFSAg7ZEtwgdqTZMhjvdlOcRbHWTzDCBJMqdzpIqxQIRuE2aHianHHFibv1bGfAjnzmBpSJxx9MA/132","comment_is_top":false,"comment_ctime":1590935602,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1590935602","product_id":100040201,"comment_content":"flower跟netty有什么区别呢？不都是异步非阻塞的吗？","like_count":0},{"had_liked":false,"id":212793,"user_name":"landon30","can_delete":false,"product_type":"c1","uid":1068170,"ip_address":"","ucode":"AD3120D5BF8892","user_header":"https://static001.geekbang.org/account/avatar/00/10/4c/8a/d75626ec.jpg","comment_is_top":false,"comment_ctime":1588211911,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588211911","product_id":100040201,"comment_content":"李老师，考虑过vert. x框架吗？","like_count":0},{"had_liked":false,"id":173390,"user_name":"InfoQ_e077cb303519","can_delete":false,"product_type":"c1","uid":1390669,"ip_address":"","ucode":"2CCA309DB2EF46","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLAK6F4BFT5ewhJEeZrjmRx5HxP8tvnNpJcpLlotHiadp0s6aL3d7LfMHEuQP6tibu80wUy8micVu4oQ/132","comment_is_top":false,"comment_ctime":1579519703,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579519703","product_id":100040201,"comment_content":"老师我想问下，基于事件编程跟反应式编程类似吗，基于事件编程的原理大概是什么","like_count":0}]}