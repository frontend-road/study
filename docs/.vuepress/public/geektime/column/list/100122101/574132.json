{"id":574132,"title":"03 | 如何通过部分应用和柯里化让函数具象化？","content":"<p>你好，我是石川。</p><p>在前面两节课里，我说过函数式编程的核心就是把数据作为输入，通过算法进行计算，最后输出结果。同时我也提到，在函数式+响应式编程中，面对未知、动态和不可控时，可以通过纯函数和不可变等手段减少副作用、增加确定性，及时地适应和调整。</p><p>那么现在你来想想，<strong>在输入、计算和输出这个过程中，什么地方是最难控制的呢？</strong>对，就是输入。因为它来自外界，而计算是在相对封闭的环境中，至于输出只是一个结果。</p><p>所以今天这节课，我们就来说说输入的控制。</p><h2>部分应用和柯里化</h2><p>在前面课程里也讲过，函数的输入来自参数，其中包括了函数定义时的<strong>形参</strong>和实际执行时的<strong>实参</strong>。另外，我们也通过React.js中的props和state以及JavaScript中的对象和闭包，具体了解了如何通过不可变，做到对<strong>运行时的未知</strong>状态变化的管理。</p><p>那今天，我们就从另外一个角度理解下对编程时“未知”的处理，即如果我们在编写一个函数时，需要传入多个实参，其中一部分实参是先明确的，另一部分是后明确的，那么该如何处理呢？</p><p>其实就是<strong>部分应用（partial application）和柯里化（currying）</strong>。下面我们就一起来看看函数式编程中，如何突破在调用点（call-site）传参的限制，做到部分传参和后续执行。</p><!-- [[[read_end]]] --><h3>通过部分应用延迟实参传入</h3><p>我们知道，函数式编程重在声明式和可读性，而且强调每个函数尽量解决一个单一问题。假设有一个orderEventHandler函数，它比较抽象，因此缺少可读性；又或者假设下面这个函数需要url、data和callback三个参数的输入，才能执行，我们预先知道它的url，却不知道它的data和callback。这时该怎么办呢？</p><pre><code class=\"language-javascript\">function orderEventHandler(url,data,callback) {\n&nbsp; &nbsp; // ..\n}\n</code></pre><p>要解决这些问题，我们就可以通过部分应用。下面是它的一个执行流程图。</p><p><img src=\"https://static001.geekbang.org/resource/image/9c/21/9ce5cf8b2fca3c234e1f5e7cb0b20221.jpg?wh=1920x1106\" alt=\"图片\"></p><p>也就是说，我们可以通过orderEventHandler函数，具象出一个专门的fetchOrder函数。通过这种方式，我们就提前预置了已知参数url，减少了后面需要传入的参数数量，同时也增加了代码的可读性。</p><pre><code class=\"language-javascript\">function fetchOrder(data,cb) {\n&nbsp; &nbsp; orderEventHandler( \"http://some.api/order\", data, cb );\n}\n</code></pre><p>可是如果我们想进一步具象化，预制一些参数怎么办？比如下面的getCurrentOrder，如果我们想把前面fetchOrder里的data，也内置成order: CURRENT_ORDER_ID，这样会大量增加代码结构的复杂性。</p><pre><code class=\"language-javascript\">function getCurrentOrder(cb) {\n&nbsp; &nbsp; getCurrentOrder( { order: CURRENT_ORDER_ID }, cb );\n}\n</code></pre><p>所以在函数式编程中，我们通常会使用部分应用。它所做的就是<strong>抽象一个partial工具</strong>，在先预制部分参数的情况下，后续再传入剩余的参数值。如以下代码所示：</p><pre><code class=\"language-javascript\">var fetchOrder = partial( orderEventHandler, \"http://some.api/order\" );\nvar getCurrentOrder = partial( fetchOrder, { order: CURRENT_ORDER_ID } );\n</code></pre><p>partial工具可以借助我们在上节课提到过的<strong>闭包</strong>，以及ES6中引入的<strong>…延展操作符</strong>（spread operator）这两个函数式编程中的利器来实现。</p><p>我先来说一下延展操作符，它的强大之处就是可以在函数调用或数组构造时，将数组表达式或者string在语法层面展开。在这里，我们可以用它来处理预置的和后置的实参。而闭包在这里再次发挥了记忆的功能，它会记住前置的参数，并在下一次收到后置的参数时，可以和前面记住的前置参数一起执行。</p><pre><code class=\"language-javascript\">var partial =\n    (fn,...presetArgs) =&gt;\n        (...laterArgs) =&gt;\n            fn( ...presetArgs, ...laterArgs );\n</code></pre><p>除此之外，我们在上一讲里提到的bind也可以起到类似的作用。但 <strong>bind通常是在面向对象中用来绑定this的</strong>，用作部分应用的话会相对比较奇怪，因为这里我们不绑定this，所以第一个参数我们会设置为null。</p><p>当然，这么用确实不会有什么问题，但是一般来说，为了不混淆bind的使用场景，我们最好还是用自己定义的partial工具。</p><pre><code class=\"language-javascript\">var fetchOrder = httpEvntHandler.bind( null, \"http://some.api/order\" );\n</code></pre><h3>通过柯里化每次传一个参数</h3><p>我们接着来看看柯里化。</p><p>可以看到，在下面的例子中，我们把之前的httpEventHandler做了柯里化处理之后，就不需要一次输入3个参数了，而是每次只传入一个参数。第一次，我们传入了url来获取订单；之后，我们传入了当前订单的id；最后，我们获得了当前订单后，传入一个订单修改的参数来做相关修改。</p><pre><code class=\"language-javascript\">var curriedOrderEvntHandler = curry( orderEventHandler );\n\nvar fetchOrder = curriedHttpEvntHandler( \"http://some.api/order\" );\n\nvar getCurrentOrder = fetchOrder( { order: CURRENT_ORDER_ID } );\n\ngetCurrentOrder( function editOrder(order){ /* .. */ } );\n</code></pre><p>你同样可以来看一下它的一个执行流程图，看看柯里化是如何实现的。</p><p><img src=\"https://static001.geekbang.org/resource/image/35/93/354314fbf00495bbbd02b04b2bacf693.jpg?wh=1920x665\" alt=\"图片\"></p><p>实际上，和部分应用类似，这里我们<strong>也用到了闭包和…延展操作符</strong>。</p><p>在柯里化中，延展操作符可以在函数调用链中起到承上启下的作用。当然，市面上实现部分应用和柯里化的方式有很多，这里我选了一个“可读性”比较高的。因为和部分应用一样，它有效说明了参数前后的关系。</p><pre><code class=\"language-javascript\">function curry(fn,arity = fn.length) {\n    return (function nextCurried(prevArgs){\n        return function curried(nextArg){\n            var args = [ ...prevArgs, nextArg ];\n            if (args.length &gt;= arity) {\n                return fn( ...args );\n            }\n            else {\n                return nextCurried( args );\n            }\n        };\n    })( [] );\n}\n</code></pre><p>好了，通过部分应用和柯里化的例子，我们能够发现<strong>函数式编程处理未知</strong>的能力。但这里我还想强调一点，这个未知，跟我们说的应用在运行时的未知是不同的。这里的未知指的是编程时的未知，比如有些参数是我们提前知道的，而有一些是后面加入的。</p><p>要知道，一个普通的函数通常是在调用点执行时传入参数的，而通过部分应用和柯里化，我们做到了可以先传入部分已知参数，再在之后的某个时间传入部分参数，这样从时间和空间上，就将一个函数分开了。</p><p>而这样做除了一些实际的好处，比如处理未知，让函数从抽象变具体、让具体的函数每次只专心做好一件事、减少参数数量之外，还有一个更抽象的好处，就是<strong>体现了函数式底层的声明式思想</strong>。</p><p>在这里，我们让代码变得更可读。</p><h2>还有哪些常用的参数处理工具？</h2><p>在函数式编程中，我们把参数的数量叫做 <strong>arity</strong>。从上面的例子中，我们可以看到，部分应用可以减少每次函数调用时需要传入的参数，而柯里化更是把函数调用时需要传入的参数数量，降到了1。它们实际上都起到了<strong>控制参数数量</strong>的作用。</p><p>而在函数式编程中，其实还有很多可以帮助我们处理参数输入的工具。下面，我们就通过unary、constant和identity这几个简单的例子来一起看看。</p><p><img src=\"https://static001.geekbang.org/resource/image/e7/5c/e70e2bbb764b2934d6b4ea379fc8465c.jpg?wh=1920x596\" alt=\"图片\"></p><h3>改造接口unary</h3><p>我们先来看看改造函数的工具。其中，最简单的工具就是一元参数（unary）了，它的作用是把一个接收多个参数的函数，变成一个只接收一个参数的函数。其实现也很简单：</p><pre><code class=\"language-javascript\">function unary(fn) {\n&nbsp; &nbsp; return function oneArg(arg){\n&nbsp; &nbsp; &nbsp; &nbsp; return fn( arg );\n&nbsp; &nbsp; };\n}\n</code></pre><p>你可能会问它有什么用？我来举个例子。</p><p>当你想通过parseInt，把一组字符串通过map来映射成整数，但是parseInt会接收两个参数，而如果你直接输入parseInt的话，那么“2”就会成为它的第二个参数，这肯定不是你期待的结果吧。</p><p>所以这时候，unary就派上用场了，它可以让parseInt只接收一个参数，从而就可以正确地打出你想要的结果。</p><pre><code class=\"language-javascript\">[\"1\",\"2\",\"3\",\"4\",\"5\"].map( unary( parseInt ) ); // [1,2,3,4,5]\n</code></pre><p>看到这里，聪明的你可能会问：除了一元，会不会有二元、三元？答案是有的。二元就是binary，或是函数式中的“黑话”dyadic；三元就是tenary。顾名思义，它们分别代表的就是把一个函数的参数数量控制在2个和3个。</p><h3>改造参数constant</h3><p>如果你用过JavaScript promise的话，应该对then不陌生。从函数签名的角度来看，它只接收函数，而不接收其他值类型作为参数。比如下面例子中，34这个值就是不能被接收的。</p><pre><code class=\"language-javascript\">promise1.then( action1 ).then( 34 ).then( action3 );\n</code></pre><p>这里你可能会问，<strong>什么是函数签名？</strong>函数签名一般包含了参数及其类型返回值，还有类型可能引发或传回的异常，以及相关的方法在面向对象中的可用性信息（如关键字public、static或prototype）。你可以看到在C或C++中，会有类似这样的签名，如下所示：</p><pre><code class=\"language-c++\">// C\nint main (int arga, char *argb[]) {}\n\n// C++\nint main (int argc, char **argv) {/** ... **/ }\n</code></pre><p>而在JavaScript当中，基于它“放荡不羁”的特性，就没有那么多条条框框了，甚至连命名函数本身都不是必须的，就更不用说签名了。那么遇到then这种情况怎么办呢？</p><p>在这种情况下，我们其实可以编写一个只返回值的constant函数，这样就解决了接收的问题。由此也能看出，JavaScript在面对各种条条框框的时候，总是上有政策下有对策。</p><pre><code class=\"language-javascript\">function constant(v) {\n&nbsp; &nbsp; return function value(){\n&nbsp; &nbsp; &nbsp; &nbsp; return v;\n&nbsp; &nbsp; };\n}\n</code></pre><p>然后，我们就可以把值包装在constant函数里，通过这样的方式，就可以把值作为函数参数传入了。</p><pre><code class=\"language-javascript\">promise1.then( action1 ).then( constant( 34 ) ).then( action3 );\n</code></pre><h3>不做改造identity</h3><p>还有一个函数式编程中常用的工具，也就是identity，它既不改变函数，也不改变参数。它的功能就是输入一个值，返回一个同样的值。你可能会觉着，这有啥用？</p><pre><code class=\"language-javascript\">function identity(v) {\n&nbsp; &nbsp; return v;\n}\n</code></pre><p>其实它的作用也很多。比如在下面的例子中，它可以作为<strong>断言</strong>（predicate）， 来过滤掉空值。在函数式编程中，断言是一个可以用来做判断条件的函数，在这个例子里，identity就作为判断一个值是否为空的断言。</p><pre><code class=\"language-javascript\">var words = \"&nbsp; &nbsp;hello world&nbsp; \".split( /\\s|\\b/ );\nwords; // ['', '', '', 'hello', 'world', '', '']\n\nwords.filter( identity ); // ['hello', 'world']\n</code></pre><p>当然，identity的功能也不止于此，它也可以用来<strong>做默认的转化工具</strong>。比如以下例子中，我们创建了一个transLogger函数，可以传入一个实际的数据和相关的lower功能函数，来将文字转化成小写。</p><pre><code class=\"language-javascript\">function transLogger (msg,formatFn = identity) {\n&nbsp; &nbsp; msg = formatFn( msg );\n&nbsp; &nbsp; console.log( msg );\n}\n\nfunction lower(txt) {\n&nbsp; &nbsp; return txt.toLowerCase();\n}\n\ntransLogger( \"Hello World\" );&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Hello World\ntransLogger( \"Hello World\", lower );&nbsp; &nbsp; &nbsp;// hello world\n</code></pre><p>除了以上这些工具以外，还有更复杂一些的工具来解决参数问题。比如在讲部分应用和柯里化的时候，提到它在给我们带来一些灵活性的同时，也仍然会有一些限制，即<strong>参数的顺序问题</strong>，我们必须按照一个顺序来执行。而有些三方库提供的一些工具，就可以将参数倒排或重新排序。</p><p>重新排序的方式有很多，可以通过解构（destructure），从数组和对象参数中提取值，对变量进行赋值时重新排序；或通过延展操作符把一个对象中的一组值，“延展”成单独的参数来处理；又或者通过 .toString() 和正则表达式解析函数中的参数做处理。</p><p>但是，有时我们<strong>在灵活变通中也要适度</strong>，不能让它一不小心变成了“奇技淫巧”，所以对于类似“重新排序”这样的技巧，在课程中我就不展开了，感兴趣的话你可以在延伸阅读部分去深入了解。</p><h2>总结</h2><p>通过今天这节课，我们能看到在面对未知、动态和不可控时，函数式编程很重要的一点就是<strong>控制好输入</strong>。</p><p>在课程里，我们一起重点了解了函数的输入中的参数，知道部分应用和柯里化，可以让代码更好地处理编程中的未知，让函数从抽象变具体，让具体的函数每次只专心做好一件事，以及可以在减少参数的数量之外，还能够增加可读性。</p><p>另外，我们也学习了更多“个子小，功能大”的工具，我们不仅可以通过这些工具，比如unary和constant来改造函数和参数，从而解决适配问题；同时，哪怕是看上去似乎只是在“透传”值的identity，实际上都可以用于断言和转化。而这样做的好处，就是可以尽量提高接口的适应性和适配性，增加过滤和转化的能力，以及增加代码的可读性。</p><h2>思考题</h2><p>今天我们主要学习了柯里化，而与它相反的就是反柯里化（uncurry），那么你知道反柯里化的用途和实现吗？</p><p>欢迎在留言区分享你的答案，也欢迎你把今天的内容分享给更多的朋友。</p><h2>延伸阅读</h2><ul>\n<li><a href=\"https://www.csdn.net/tags/Mtjakg2sMTMxMjctYmxvZwO0O0OO0O0O.html\">JS 函数签名</a></li>\n<li><a href=\"https://blog.csdn.net/helena1993/article/details/124149052\">C/C++ 函数签名与名字修饰（符号修饰）</a></li>\n<li><a href=\"https://blog.csdn.net/zyh2525246/article/details/116799638\">JS 中的结构</a></li>\n<li><a href=\"https://github.com/getify/Functional-Light-JS/blob/master/manuscript/README.md/#table-of-contents\">Functional Light JS</a></li>\n<li><a href=\"https://learning.oreilly.com/library/view/javascript-patterns/9781449399115/\">JavaScript Patterns - Chapter 4 Functions</a></li>\n</ul>","neighbors":{"left":{"article_title":"02 | 如何通过闭包对象管理程序中状态的变化？","id":573307},"right":{"article_title":"04 | 如何通过组合、管道和reducer让函数抽象化？","id":574783}},"comments":[{"had_liked":false,"id":358444,"user_name":"L","can_delete":false,"product_type":"c1","uid":3139235,"ip_address":"北京","ucode":"ED355151EA9FF8","user_header":"https://static001.geekbang.org/account/avatar/00/2f/e6/a3/e7e97896.jpg","comment_is_top":false,"comment_ctime":1664328687,"is_pvip":false,"replies":[{"id":"130490","content":"是的，谢谢你的细心，这里有个勘误，getOrder应该都统一成fetchOrder。","user_name":"作者回复","user_name_real":"编辑","uid":"2785919","ctime":1664682597,"ip_address":"北京","comment_id":358444,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10254263279","product_id":100122101,"comment_content":"<br>var curriedOrderEvntHandler = curry( orderEventHandler );<br><br>var fetchOrder = curriedHttpEvntHandler( &quot;http:&#47;&#47;some.api&#47;order&quot; );<br><br>var getCurrentOrder = getOrder( { order: CURRENT_ORDER_ID } );<br><br>getCurrentOrder( function editOrder(order){ &#47;* .. *&#47; } );<br>这里是否也有问题 为什么前后的函数对不上呢","like_count":2,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589305,"discussion_content":"是的，谢谢你的细心，这里有个勘误，getOrder应该都统一成fetchOrder。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664682597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358443,"user_name":"L","can_delete":false,"product_type":"c1","uid":3139235,"ip_address":"北京","ucode":"ED355151EA9FF8","user_header":"https://static001.geekbang.org/account/avatar/00/2f/e6/a3/e7e97896.jpg","comment_is_top":false,"comment_ctime":1664328357,"is_pvip":false,"replies":[{"id":"130491","content":"是的，谢谢你的细心，这里有个勘误，getOrder应该都统一成fetchOrder。","user_name":"作者回复","user_name_real":"编辑","uid":"2785919","ctime":1664682601,"ip_address":"北京","comment_id":358443,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10254262949","product_id":100122101,"comment_content":"<br>function getCurrentOrder(cb) {<br>    getCurrentOrder( { order: CURRENT_ORDER_ID }, cb );<br>    (fetchOrder)<br>}<br>可是如果我们想进一步具象化，预制一些参数怎么办？比如下面的 getCurrentOrder，如果我们想把前面 getOrder  (fetchOrder)    里的 data，也内置成 order: CURRENT_ORDER_ID，这样会大量增加代码结构的复杂性。<br>这两个地方是不是错了  应该都是fetchOrder<br>","like_count":2,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589306,"discussion_content":"是的，谢谢你的细心，这里有个勘误，getOrder应该都统一成fetchOrder。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664682601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358533,"user_name":"Sunny","can_delete":false,"product_type":"c1","uid":1667101,"ip_address":"北京","ucode":"EED137B5B96EA3","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/1d/c59e0b59.jpg","comment_is_top":false,"comment_ctime":1664415284,"is_pvip":false,"replies":[{"id":"130621","content":"谢谢指正，我查了一下，你的拼写是正确的","user_name":"作者回复","user_name_real":"编辑","uid":"2785919","ctime":1665308652,"ip_address":"北京","comment_id":358533,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5959382580","product_id":100122101,"comment_content":"看下这个单词 tenary 是否少了一个 &quot;r&quot;，正确的是 ternary? ","like_count":1,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589783,"discussion_content":"谢谢指正，我查了一下，你的拼写是正确的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665308653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358399,"user_name":"Saul","can_delete":false,"product_type":"c1","uid":3183916,"ip_address":"北京","ucode":"E1CC134F8A2138","user_header":"https://static001.geekbang.org/account/avatar/00/30/95/2c/b2ebf34d.jpg","comment_is_top":false,"comment_ctime":1664270385,"is_pvip":false,"replies":[{"id":"130635","content":"原先的orderEventHandler函数有3个参数，url, data 和 callback。<br>function orderEventHandler(url,data,callback) {}<br><br>第一行把orderEventHandler做了柯里化，之后可以每次只传一个参数。<br>第二行是在柯里化后的curriedHttpEvntHandler中传入了第一个url实参。","user_name":"作者回复","user_name_real":"编辑","uid":"2785919","ctime":1665324142,"ip_address":"北京","comment_id":358399,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5959237681","product_id":100122101,"comment_content":"<br>var curriedOrderEvntHandler = curry( orderEventHandler );<br><br>var fetchOrder = curriedHttpEvntHandler( &quot;http:&#47;&#47;some.api&#47;order&quot; );<br><br>var getCurrentOrder = getOrder( { order: CURRENT_ORDER_ID } );<br><br>getCurrentOrder( function editOrder(order){ &#47;* .. *&#47; } );<br><br>--------------------------------------------------------------------------<br>第二行我怎么看不懂","like_count":1,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":589815,"discussion_content":"原先的orderEventHandler函数有3个参数，url, data 和 callback。\nfunction orderEventHandler(url,data,callback) {}\n\n第一行把orderEventHandler做了柯里化，之后可以每次只传一个参数。\n第二行是在柯里化后的curriedHttpEvntHandler中传入了第一个url实参。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665324143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359786,"user_name":"Geek_fcdf7b","can_delete":false,"product_type":"c1","uid":2115742,"ip_address":"北京","ucode":"55A2DBA5C6DF79","user_header":"https://static001.geekbang.org/account/avatar/00/20/48/9e/9bbaa97d.jpg","comment_is_top":false,"comment_ctime":1665898091,"is_pvip":false,"replies":[{"id":"131020","content":"因为嵌套封装可以减少来自外部值的副作用。","user_name":"作者回复","user_name_real":"编辑","uid":"2785919","ctime":1666321046,"ip_address":"北京","comment_id":359786,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1665898091","product_id":100122101,"comment_content":"<br>function constant(v) {<br>    return function value(){<br>        return v;<br>    };<br>}<br>这个函数为啥不直接返回v，而要在里面还要多包一层呢。为啥不是像这样：<br><br>function constant(v) {<br>    return v;<br>}","like_count":0,"discussions":[{"author":{"id":2785919,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/82/7f/c22de3a3.jpg","nickname":"石川","note":"","ucode":"99E480A265E25F","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591139,"discussion_content":"因为嵌套封装可以减少来自外部值的副作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666321046,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1862271,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/nvWeOicPyIbAVkQnt4omOibkzZpG3AxSKy5CH1LicumpucX8hp4gZVSicKm1wnua6uuCRbHdXibh4FQLqLskqtoKiagg/132","nickname":"hsiang271828","note":"","ucode":"5453512A953D0A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591613,"discussion_content":"这里是把值变为函数，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666704771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2336708,"avatar":"https://static001.geekbang.org/account/avatar/00/23/a7/c4/bedc49d3.jpg","nickname":"哎呦，不错哦","note":"","ucode":"DC599711D2CC69","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590879,"discussion_content":"这样返回的就是一个值而不是一个函数","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666148391,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358582,"user_name":"Guit","can_delete":false,"product_type":"c1","uid":2115605,"ip_address":"北京","ucode":"70012D16C9117D","user_header":"https://static001.geekbang.org/account/avatar/00/20/48/15/63cc2633.jpg","comment_is_top":false,"comment_ctime":1664442726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664442726","product_id":100122101,"comment_content":"const currying = (fn) =&gt; {<br>  const l = fn.length<br>  return function curried(...prevArgs) {<br>    if (l === prevArgs.length) {<br>      return fn(...prevArgs)<br>    }<br>    return (...nextArg) =&gt; curried(...nextArg, ...prevArgs)<br>  }<br>}<br><br>","like_count":1},{"had_liked":false,"id":358442,"user_name":"L","can_delete":false,"product_type":"c1","uid":3139235,"ip_address":"陕西","ucode":"ED355151EA9FF8","user_header":"https://static001.geekbang.org/account/avatar/00/2f/e6/a3/e7e97896.jpg","comment_is_top":false,"comment_ctime":1664328264,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664328264","product_id":100122101,"comment_content":"<br>可是如果我们想进一步具象化，预制一些参数怎么办？比如下面的 getCurrentOrder，如果我们想把前面 getOrder 里的 data，也内置成 order: CURRENT_ORDER_ID，这样会大量增加代码结构的复杂性。","like_count":0},{"had_liked":false,"id":358386,"user_name":"向上","can_delete":false,"product_type":"c1","uid":1465483,"ip_address":"浙江","ucode":"914DF6837E85AB","user_header":"https://static001.geekbang.org/account/avatar/00/16/5c/8b/a9df379f.jpg","comment_is_top":false,"comment_ctime":1664262967,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664262967","product_id":100122101,"comment_content":"function getCurrentOrder(cb) { getCurrentOrder( { order: CURRENT_ORDER_ID }, cb );}<br>这里内部函数是否应该用fetchOrder","like_count":0},{"had_liked":false,"id":358279,"user_name":"灯火阑珊","can_delete":false,"product_type":"c1","uid":1289991,"ip_address":"湖北","ucode":"D07A1D2101B9A9","user_header":"https://static001.geekbang.org/account/avatar/00/13/af/07/a32e3f4e.jpg","comment_is_top":false,"comment_ctime":1664165435,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1664165435","product_id":100122101,"comment_content":"equational reasoning","like_count":0}]}