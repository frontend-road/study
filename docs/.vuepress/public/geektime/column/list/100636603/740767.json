{"id":740767,"title":"第 5 章 非原始值的响应式方案(3)","content":"<h2 id=\"nav_point_56\">5.8　代理 <code>Set</code> 和 <code>Map</code></h2>\n<p>从本节开始，我们将介绍集合类型数据的响应式方案。集合类型包括 <code>Map</code>/<code>Set</code> 以及 <code>WeakMap</code>/<code>WeakSet</code>。使用 <code>Proxy</code> 代理集合类型的数据不同于代理普通对象，因为集合类型数据的操作与普通对象存在很大的不同。下面总结了 <code>Set</code> 和 <code>Map</code> 这两个数据类型的原型属性和方法。</p>\n<p><code>Set</code> 类型的原型属性和方法如下。</p>\n<ul>\n<li><code>size</code>：返回集合中元素的数量。</li>\n<li><code>add(value)</code>：向集合中添加给定的值。</li>\n<li><code>clear()</code>：清空集合。</li>\n<li><code>delete(value)</code>：从集合中删除给定的值。</li>\n<li><code>has(value)</code>：判断集合中是否存在给定的值。</li>\n<li><code>keys()</code>：返回一个迭代器对象。可用于 <code>for...of</code> 循环，迭代器对象产生的值为集合中的元素值。</li>\n<li><code>values()</code>：对于 <code>Set</code> 集合类型来说，<code>keys()</code> 与 <code>values()</code> 等价。</li>\n<li><code>entries()</code>：返回一个迭代器对象。迭代过程中为集合中的每一个元素产生一个数组值 <code>[value, value]</code>。</li>\n<li><code>forEach(callback[, thisArg])</code>：<code>forEach</code> 函数会遍历集合中的所有元素，并对每一个元素调用 <code>callback</code> 函数。<code>forEach</code> 函数接收可选的第二个参数 <code>thisArg</code>，用于指定 <code>callback</code> 函数执行时的 <code>this</code> 值。</li>\n</ul>\n<p><code>Map</code> 类型的原型属性和方法如下。</p>\n<ul>\n<li><code>size</code>：返回 <code>Map</code> 数据中的键值对数量。</li>\n<li><code>clear()</code>：清空 <code>Map</code>。</li>\n<li><code>delete(key)</code>：删除指定 <code>key</code> 的键值对。</li>\n<li><code>has(key)</code>：判断 <code>Map</code> 中是否存在指定 <code>key</code> 的键值对。</li>\n<li><code>get(key)</code>：读取指定 <code>key</code> 对应的值。</li>\n<li><code>set(key, value)</code>：为 <code>Map</code> 设置新的键值对。</li>\n<li><code>keys()</code>：返回一个迭代器对象。迭代过程中会产生键值对的 <code>key</code> 值。</li>\n<li><code>values()</code>：返回一个迭代器对象。迭代过程中会产生键值对的 <code>value</code> 值。</li>\n<li><code>entries()</code>：返回一个迭代器对象。迭代过程中会产生由 <code>[key, value]</code> 组成的数组值。</li>\n<li><code>forEach(callback[, thisArg])</code>：<code>forEach</code> 函数会遍历 <code>Map</code> 数据的所有键值对，并对每一个键值对调用 <code>callback</code> 函数。<code>forEach</code> 函数接收可选的第二个参数 <code>thisArg</code>，用于指定 <code>callback</code> 函数执行时的 <code>this</code> 值。</li>\n</ul>\n<p>观察上述列表可以发现，<code>Map</code> 和 <code>Set</code> 这两个数据类型的操作方法相似。它们之间最大的不同体现在，<code>Set</code> 类型使用 <code>add(value)</code> 方法添加元素，而 <code>Map</code> 类型使用 <code>set(key, value)</code> 方法设置键值对，并且 <code>Map</code> 类型可以使用 <code>get(key)</code> 方法读取相应的值。既然两者如此相似，那么是不是意味着我们可以用相同的处理办法来实现对它们的代理呢？没错，接下来，我们就深入探讨如何实现对 <code>Set</code> 和 <code>Map</code> 类型数据的代理。</p>\n<h3 id=\"nav_point_57\">5.8.1　如何代理 <code>Set</code> 和 <code>Map</code></h3>\n<p>前文讲到，<code>Set</code> 和 <code>Map</code> 类型的数据有特定的属性和方法用来操作自身。这一点与普通对象不同，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> // 普通对象的读取和设置操作\n const obj = { foo: 1 }\n obj.foo // 读取属性\n obj.foo = 2 // 设置属性\n<p>// 用 get/set 方法操作 Map 数据<br />\nconst map = new Map()<br />\nmap.set(‘key’, 1) // 设置数据<br />\nmap.get(‘key’) // 读取数据<br />\n</code></pre></p>\n<p>正是因为这些差异的存在，我们不能像代理普通对象那样代理 <code>Set</code> 和 <code>Map</code> 类型的数据。但整体思路不变，即当读取操作发生时，应该调用 <code>track</code> 函数建立响应联系；当设置操作发生时，应该调用 <code>trigger</code> 函数触发响应，例如：</p>\n<pre class=\"code-rows\"><code> const proxy = reactive(new Map([['key', 1]]))\n<p>effect(() =&gt; {<br />\nconsole.log(proxy.get(‘key’)) // 读取键为 key 的值<br />\n})</p>\n<p>proxy.set(‘key’, 2) // 修改键为 key 的值，应该触发响应<br />\n</code></pre></p>\n<p>当然，这段代码展示的效果是我们最终要实现的目标。但在动手实现之前，我们有必要先了解关于使用 <code>Proxy</code> 代理 <code>Set</code> 或 <code>Map</code> 类型数据的注意事项。</p><!-- [[[read_end]]] -->\n<p>先来看一段代码，如下：</p>\n<pre class=\"code-rows\"><code> const s = new Set([1, 2, 3])\n const p = new Proxy(s, {})\n<p>console.log(p.size) // 报错 TypeError: Method get Set.prototype.size called on incompatible receiver<br />\n</code></pre></p>\n<p>在这段代码中，我们首先定义了一个 <code>Set</code> 类型的数据 <code>s</code>，接着为它创建一个代理对象 <code>p</code>。由于代理的目标对象是 <code>Set</code> 类型，因此我们可以通过读取它的 <code>p.size</code> 属性获取元素的数量。但不幸的是，我们得到了一个错误。错误信息的大意是“在不兼容的 <code>receiver</code> 上调用了 <code>get Set.prototype.size</code> 方法”。由此我们大概能猜到，<code>size</code> 属性应该是一个访问器属性，所以它作为方法被调用了。通过查阅规范可以证实这一点，如图 5-11 所示。</p>\n<p class=\"pic\"><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00521.jpeg\" alt=\"{%}\" /></p>\n<p class=\"ebook-image-title\"><strong>图 5-11　<code>Set.prototype.size</code> 属性的定义</strong></p>\n<p>图 5-11 所描述的内容如下。</p>\n<p><code>Set.prototype.size</code> 是一个访问器属性，它的 <code>set</code> 访问器函数是 <code>undefined</code>，它的 <code>get</code> 访问器函数会执行以下步骤。</p>\n<blockquote>\n<p>1. 让 <code>S</code> 的值为 <code>this</code>。</p>\n<p>2. 执行 <code>? RequireInternalSlot(S, [[SetData]])</code>。</p>\n<p>3. 让 <code>entries</code> 的值为 <code>List</code>，即 <code>S.[[SetData]]</code>。</p>\n<p>4. 让 <code>count 的</code> 值为 <code>0</code>。</p>\n<p>5. 对于 <code>entries 中</code> 的每个元素 <code>e</code>，执行：</p>\n<p>a. 如果 <code>e</code> 不是空的，则将 <code>count</code> 设置为 <code>count + 1</code>。</p>\n<p>6. 返回 <code><img img src=\"https://static001.geekbang.org/files/resource/ebook/100005/image00520.gif\" alt=\"\\mathbb\" inline-img=\"true\" />(count)</code>。</p>\n</blockquote>\n<p>由此可知，<code>Set.prototype.size</code> 是一个访问器属性。这里的关键点在第 1 步和第 2 步。根据第 1 步的描述：让 <code>S</code> 的值为 <code>this</code>。这里的 <code>this</code> 是谁呢？由于我们是通过代理对象 <code>p</code> 来访问 <code>size</code> 属性的，所以 <code>this</code> 就是代理对象 <code>p</code>。接着在第 2 步中，调用抽象方法 <code>RequireInternalSlot(S, [[SetData]])</code> 来检查 <code>S</code> 是否存在内部槽 <code>[[SetData]]</code>。很显然，代理对象 <code>S</code> 不存在 <code>[[SetData]]</code> 这个内部槽，于是会抛出一个错误，也就是前面例子中得到的错误。</p>\n<p>为了修复这个问题，我们需要修正访问器属性的 <code>getter</code> 函数执行时的 <code>this</code> 指向，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const s = new Set([1, 2, 3])\n const p = new Proxy(s, {\n     get(target, key, receiver) {\n       if (key === 'size') {\n         // 如果读取的是 size 属性\n         // 通过指定第三个参数 receiver 为原始对象 target 从而修复问题\n         return Reflect.get(target, key, target)\n       }\n       // 读取其他属性的默认行为\n       return Reflect.get(target, key, receiver)\n     }\n })\n<p>console.log(s.size) // 3<br />\n</code></pre></p>\n<p>在上面这段代码中，我们在创建代理对象时增加了 <code>get</code> 拦截函数。然后检查读取的属性名称是不是 <code>size</code>，如果是，则在调用 <code>Reflect.get</code> 函数时指定第三个参数为原始 <code>Set</code> 对象，这样访问器属性 <code>size</code> 的 <code>getter</code> 函数在执行时，其 <code>this</code> 指向的就是原始 <code>Set</code> 对象而非代理对象了。由于原始 <code>Set</code> 对象上存在 <code>[[SetData]]</code> 内部槽，因此程序得以正确运行。</p>\n<p>接着，我们再来尝试从 <code>Set</code> 中删除数据，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const s = new Set([1, 2, 3])\n const p = new Proxy(s, {\n     get(target, key, receiver) {\n       if (key === 'size') {\n         return Reflect.get(target, key, target)\n       }\n       // 读取其他属性的默认行为\n       return Reflect.get(target, key, receiver)\n     }\n   }\n )\n<p>// 调用 delete 方法删除值为 1 的元素<br />\n// 会得到错误 TypeError: Method Set.prototype.delete called on incompatible receiver [object Object]<br />\np.delete(1)<br />\n</code></pre></p>\n<p>可以看到，调用 <code>p.delete</code> 方法时会得到一个错误，这个错误与前文讲解的访问 <code>p.size</code> 属性时发生的错误非常相似。为了搞清楚问题的原因，我们需要详细分析当调用 <code>p.delete(1)</code> 方法时都发生了什么。</p>\n<p>实际上，访问 <code>p.size</code> 与访问 <code>p.delete</code> 是不同的。这是因为 <code>size</code> 是属性，是一个访问器属性，而 <code>delete</code> 是一个方法。当访问 <code>p.size</code> 时，访问器属性的 <code>getter</code> 函数会立即执行，此时我们可以通过修改 <code>receiver</code> 来改变 <code>getter</code> 函数的 <code>this</code> 的指向。而当访问 <code>p.delete</code> 时，<code>delete</code> 方法并没有执行，真正使其执行的语句是 <code>p.delete(1)</code> 这句函数调用。因此，无论怎么修改 <code>receiver</code>，<code>delete</code> 方法执行时的 <code>this</code> 都会指向代理对象 <code>p</code>，而不会指向原始 <code>Set</code> 对象。想要修复这个问题也不难，只需要把 <code>delete</code> 方法与原始数据对象绑定即可，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> const s = new Set([1, 2, 3])\n const p = new Proxy(s, {\n     get(target, key, receiver) {\n       if (key === 'size') {\n         return Reflect.get(target, key, target)\n       }\n       // 将方法与原始数据对象 target 绑定后返回\n       return target[key].bind(target)\n     }\n   }\n )\n<p>// 调用 delete 方法删除值为 1 的元素，正确执行<br />\np.delete(1)<br />\n</code></pre></p>\n<p>在上面这段代码中，我们使用 <code>target[key].bind(target)</code> 代替了 <code>Reflect.get(target, key, receiver)</code>。可以看到，我们使用 <code>bind</code> 函数将用于操作数据的方法与原始数据对象 <code>target</code> 做了绑定。这样当 <code>p.delete(1)</code> 语句执行时，<code>delete</code> 函数的 <code>this</code> 总是指向原始数据对象而非代理对象，于是代码能够正确执行。</p>\n<p>最后，为了后续讲解方便以及代码的可扩展性，我们将 <code>new Proxy</code> 也封装到前文介绍的 <code>createReactive</code> 函数中：</p>\n<pre class=\"code-rows\"><code> const reactiveMap = new Map()\n // reactive 函数与之前相比没有变化\n function reactive(obj) {\n<p>const existionProxy = reactiveMap.get(obj)<br />\nif (existionProxy) return existionProxy<br />\nconst proxy = createReactive(obj)</p>\n<p>reactiveMap.set(obj, proxy)</p>\n<p>return proxy<br />\n}<br />\n// 在 createReactive 里封装用于代理 Set/Map 类型数据的逻辑<br />\nfunction createReactive(obj, isShallow = false, isReadonly = false) {<br />\nreturn new Proxy(obj, {<br />\nget(target, key, receiver) {<br />\nif (key === ‘size’) {<br />\nreturn Reflect.get(target, key, target)<br />\n}</p>\n<pre><code>   return target[key].bind(target)\n }\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>这样，我们就可以很简单地创建代理数据了：</p>\n<pre class=\"code-rows\"><code> const p = reactive(new Set([1, 2, 3]))\n console.log(p.size) // 3\n</code></pre>\n<h3 id=\"nav_point_58\">5.8.2　建立响应联系</h3>\n<p>了解了为 <code>Set</code> 和 <code>Map</code> 类型数据创建代理时的注意事项之后，我们就可以着手实现 <code>Set</code> 类型数据的响应式方案了。其实思路并不复杂，以下面的代码为例：</p>\n<pre class=\"code-rows\"><code> const p = reactive(new Set([1, 2, 3]))\n<p>effect(() =&gt; {<br />\n// 在副作用函数内访问 size 属性<br />\nconsole.log(p.size)<br />\n})<br />\n// 添加值为 1 的元素，应该触发响应<br />\np.add(1)<br />\n</code></pre></p>\n<p>这段代码展示了响应式 <code>Set</code> 类型数据的工作方式。首先，在副作用函数内访问了 <code>p.size</code> 属性；接着，调用 <code>p.add</code> 函数向集合中添加数据。由于这个行为会间接改变集合的 <code>size</code> 属性值，所以我们期望副作用函数会重新执行。为了实现这个目标，我们需要在访问 <code>size</code> 属性时调用 <code>track</code> 函数进行依赖追踪，然后在 <code>add</code> 方法执行时调用 <code>trigger</code> 函数触发响应。下面的代码展示了如何进行依赖追踪：</p>\n<pre class=\"code-rows\"><code> function createReactive(obj, isShallow = false, isReadonly = false) {\n   return new Proxy(obj, {\n     get(target, key, receiver) {\n       if (key === 'size') {\n         // 调用 track 函数建立响应联系\n         track(target, ITERATE_KEY)\n         return Reflect.get(target, key, target)\n       }\n<pre><code>   return target[key].bind(target)\n }\n</code></pre>\n<p>})<br />\n}<br />\n</code></pre></p>\n<p>可以看到，当读取 <code>size</code> 属性时，只需要调用 <code>track</code> 函数建立响应联系即可。这里需要注意的是，响应联系需要建立在 <code>ITERATE_KEY</code> 与副作用函数之间，这是因为任何新增、删除操作都会影响 <code>size</code> 属性。接着，我们来看如何触发响应。当调用 <code>add</code> 方法向集合中添加新元素时，应该怎么触发响应呢？很显然，这需要我们实现一个自定义的 <code>add</code> 方法才行，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> // 定义一个对象，将自定义的 add 方法定义到该对象下\n const mutableInstrumentations = {\n   add(key) {/* ... */}\n }\n<p>function createReactive(obj, isShallow = false, isReadonly = false) {<br />\nreturn new Proxy(obj, {<br />\nget(target, key, receiver) {<br />\n// 如果读取的是 raw 属性，则返回原始数据对象 target<br />\nif (key === ‘raw’) return target<br />\nif (key === ‘size’) {<br />\ntrack(target, ITERATE_KEY)<br />\nreturn Reflect.get(target, key, target)<br />\n}<br />\n// 返回定义在 mutableInstrumentations 对象下的方法<br />\nreturn mutableInstrumentations[key]<br />\n}<br />\n})<br />\n}<br />\n</code></pre></p>\n<p>首先，定义一个对象 <code>mutableInstrumentations</code>，我们会将所有自定义实现的方法都定义到该对象下，例如 <code>mutableInstrumentations.add</code> 方法。然后，在 <code>get</code> 拦截函数内返回定义在 <code>mutableInstrumentations</code> 对象中的方法。这样，当通过 <code>p.add</code> 获取方法时，得到的就是我们自定义的 <code>mutableInstrumentations.add</code> 方法了。有了自定义实现的方法后，就可以在其中调用 <code>trigger</code> 函数触发响应了：</p>\n<pre class=\"code-rows\"><code> // 定义一个对象，将自定义的 add 方法定义到该对象下\n const mutableInstrumentations = {\n   add(key) {\n     // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象\n     const target = this.raw\n     // 通过原始数据对象执行 add 方法添加具体的值，\n     // 注意，这里不再需要 .bind 了，因为是直接通过 target 调用并执行的\n     const res = target.add(key)\n     // 调用 trigger 函数触发响应，并指定操作类型为 ADD\n     trigger(target, key, 'ADD')\n     // 返回操作结果\n     return res\n   }\n }\n</code></pre>\n<p>如上面的代码所示，自定义的 <code>add</code> 函数内的 <code>this</code> 仍然指向代理对象，所以需要通过 <code>this.raw</code> 获取原始数据对象。有了原始数据对象后，就可以通过它调用 <code>target.add</code> 方法，这样就不再需要 <code>.bind</code> 绑定了。待添加操作完成后，调用 <code>trigger</code> 函数触发响应。需要注意的是，我们指定了操作类型为 <code>ADD</code>，这一点很重要。还记得 <code>trigger</code> 函数的实现吗？我们来回顾一下，如下面的代码片段所示：</p>\n<pre class=\"code-rows\"><code> function trigger(target, key, type, newVal) {\n   const depsMap = bucket.get(target)\n   if (!depsMap) return\n   const effects = depsMap.get(key)\n<p>// 省略无关内容</p>\n<p>// 当操作类型 type 为 ADD 时，会取出与 ITERATE_KEY 相关联的副作用函数并执行<br />\nif (type === ‘ADD’ || type === ‘DELETE’) {<br />\nconst iterateEffects = depsMap.get(ITERATE_KEY)<br />\niterateEffects &amp;&amp; iterateEffects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})<br />\n}</p>\n<p>effectsToRun.forEach(effectFn =&gt; {<br />\nif (effectFn.options.scheduler) {<br />\neffectFn.options.scheduler(effectFn)<br />\n} else {<br />\neffectFn()<br />\n}<br />\n})<br />\n}<br />\n</code></pre></p>\n<p>当操作类型是 <code>ADD</code> 或 <code>DELETE</code> 时，会取出与 <code>ITERATE_KEY</code> 相关联的副作用函数并执行，这样就可以触发通过访问 <code>size</code> 属性所收集的副作用函数来执行了。</p>\n<p>当然，如果调用 <code>add</code> 方法添加的元素已经存在于 <code>Set</code> 集合中了，就不再需要触发响应了，这样做对性能更加友好，因此，我们可以对代码做如下优化：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   add(key) {\n     const target = this.raw\n     // 先判断值是否已经存在\n     const hadKey = target.has(key)\n     // 只有在值不存在的情况下，才需要触发响应\n     const res = target.add(key)\n     if (!hadKey) {\n       trigger(target, key, 'ADD')\n     }\n     return res\n   }\n }\n</code></pre>\n<p>在上面这段代码中，我们先调用 <code>target.has</code> 方法判断值是否已经存在，只有在值不存在的情况下才需要触发响应。</p>\n<p>在此基础上，我们可以按照类似的思路轻松地实现 <code>delete</code> 方法：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   delete(key) {\n     const target = this.raw\n     const hadKey = target.has(key)\n     const res = target.delete(key)\n     // 当要删除的元素确实存在时，才触发响应\n     if (hadKey) {\n       trigger(target, key, 'DELETE')\n     }\n     return res\n   }\n }\n</code></pre>\n<p>如上面的代码所示，与 <code>add</code> 方法的区别在于，<code>delete</code> 方法只有在要删除的元素确实在集合中存在时，才需要触发响应，这一点恰好与 <code>add</code> 方法相反。</p>\n<h3 id=\"nav_point_59\">5.8.3　避免污染原始数据</h3>\n<p>本节中我们借助 <code>Map</code> 类型数据的 <code>set</code> 和 <code>get</code> 这两个方法来讲解什么是“避免污染原始数据”及其原因。</p>\n<p><code>Map</code> 数据类型拥有 <code>get</code> 和 <code>set</code> 这两个方法，当调用 <code>get</code> 方法读取数据时，需要调用 <code>track</code> 函数追踪依赖建立响应联系；当调用 <code>set</code> 方法设置数据时，需要调用 <code>trigger</code> 方法触发响应。如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const p = reactive(new Map([['key', 1]]))\n<p>effect(() =&gt; {<br />\nconsole.log(p.get(‘key’))<br />\n})</p>\n<p>p.set(‘key’, 2) // 触发响应<br />\n</code></pre></p>\n<p>其实想要实现上面这段代码所展示的功能并不难，因为我们已经有了实现 <code>add</code>、<code>delete</code> 等方法的经验。下面是 <code>get</code> 方法的具体实现：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   get(key) {\n     // 获取原始对象\n     const target = this.raw\n     // 判断读取的 key 是否存在\n     const had = target.has(key)\n     // 追踪依赖，建立响应联系\n     track(target, key)\n    // 如果存在，则返回结果。这里要注意的是，如果得到的结果 res 仍然是可代理的数据，\n    // 则要返回使用 reactive 包装后的响应式数据\n     if (had) {\n       const res = target.get(key)\n       return typeof res === 'object' ? reactive(res) : res\n     }\n   }\n }\n</code></pre>\n<p>如上面的代码及注释所示，整体思路非常清晰。这里有一点需要注意，在非浅响应的情况下，如果得到的数据仍然可以被代理，那么要调用 <code>reactive(res)</code> 将数据转换成响应式数据后返回。在浅响应模式下，就不需要这一步了。由于前文讲解过如何实现浅响应，因此这里不再详细讨论。</p>\n<p>接着，我们来讨论 <code>set</code> 方法的实现。简单来说，当 <code>set</code> 方法被调用时，需要调用 <code>trigger</code> 方法触发响应。只不过在触发响应的时候，需要区分操作的类型是 <code>SET</code> 还是 <code>ADD</code>，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   set(key, value) {\n     const target = this.raw\n     const had = target.has(key)\n     // 获取旧值\n     const oldValue = target.get(key)\n     // 设置新值\n     target.set(key, value)\n     // 如果不存在，则说明是 ADD 类型的操作，意味着新增\n     if (!had) {\n       trigger(target, key, 'ADD')\n     } else if (oldValue !== value || (oldValue === oldValue &amp;&amp; value === value)) {\n       // 如果不存在，并且值变了，则是 SET 类型的操作，意味着修改\n       trigger(target, key, 'SET')\n     }\n   }\n }\n</code></pre>\n<p>这段代码的关键点在于，我们需要判断设置的 <code>key</code> 是否存在，以便区分不同的操作类型。我们知道，对于 <code>SET</code> 类型和 <code>ADD</code> 类型的操作来说，它们最终触发的副作用函数是不同的。因为 <code>ADD</code> 类型的操作会对数据的 <code>size</code> 属性产生影响，所以任何依赖 <code>size</code> 属性的副作用函数都需要在 <code>ADD</code> 类型的操作发生时重新执行。</p>\n<p>上面给出的 <code>set</code> 函数的实现能够正常工作，但它仍然存在问题，即 <code>set</code> 方法会污染原始数据。这是什么意思呢？来看下面的代码：</p>\n<pre class=\"code-rows\"><code> // 原始 Map 对象 m\n const m = new Map()\n // p1 是 m 的代理对象\n const p1 = reactive(m)\n // p2 是另外一个代理对象\n const p2 = reactive(new Map())\n // 为 p1 设置一个键值对，值是代理对象 p2\n p1.set('p2', p2)\n<p>effect(() =&gt; {<br />\n// 注意，这里我们通过原始数据 m 访问 p2<br />\nconsole.log(m.get(‘p2’).size)<br />\n})<br />\n// 注意，这里我们通过原始数据 m 为 p2 设置一个键值对 foo --&gt; 1<br />\nm.get(‘p2’).set(‘foo’, 1)<br />\n</code></pre></p>\n<p>在这段代码中，我们首先创建了一个原始 <code>Map</code> 对象 <code>m</code>，<code>p1</code> 是对象 <code>m</code> 的代理对象，接着创建另外一个代理对象 <code>p2</code>，并将其作为值设置给 <code>p1</code>，即 <code>p1.set('p2', p2)</code>。接下来问题出现了，在副作用函数中，我们通过原始数据 <code>m</code> 来读取数据值，然后又通过原始数据 <code>m</code> 设置数据值，此时发现副作用函数重新执行了。这其实不是我们所期望的行为，因为原始数据不应该具有响应式数据的能力，否则就意味着用户既可以操作原始数据，又能够操作响应式数据，这样一来代码就乱套了。</p>\n<p>那么，导致问题的原因是什么呢？其实很简单，观察我们前面实现的 <code>set</code> 方法：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   set(key, value) {\n     const target = this.raw\n     const had = target.has(key)\n     const oldValue = target.get(key)\n     // 我们把 value 原封不动地设置到原始数据上\n     target.set(key, value)\n     if (!had) {\n       trigger(target, key, 'ADD')\n     } else if (oldValue !== value || (oldValue === oldValue &amp;&amp; value === value)) {\n       trigger(target, key, 'SET')\n     }\n   }\n }\n</code></pre>\n<p>在 <code>set</code> 方法内，我们把 <code>value</code> 原样设置到了原始数据 <code>target</code> 上。如果 <code>value</code> 是响应式数据，就意味着设置到原始对象上的也是响应式数据，我们把<strong>响应式数据设置到原始数据上的行为称为数据污染</strong>。</p>\n<p>要解决数据污染也不难，只需要在调用 <code>target.set</code> 函数设置值之前对值进行检查即可：只要发现即将要设置的值是响应式数据，那么就通过 <code>raw</code> 属性获取原始数据，再把原始数据设置到 <code>target</code> 上，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   set(key, value) {\n     const target = this.raw\n     const had = target.has(key)\n<pre><code> const oldValue = target.get(key)\n // 获取原始数据，由于 value 本身可能已经是原始数据，所以此时 value.raw 不存在，则直接使用 value\n const rawValue = value.raw || value\n target.set(key, rawValue)\n\n if (!had) {\n   trigger(target, key, 'ADD')\n } else if (oldValue !== value || (oldValue === oldValue &amp;amp;&amp;amp; value === value)) {\n   trigger(target, key, 'SET')\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>现在的实现已经不会造成数据污染了。不过，细心观察上面的代码，会发现新的问题。我们一直使用 <code>raw</code> 属性来访问原始数据是有缺陷的，因为它可能与用户自定义的 <code>raw</code> 属性冲突，所以在一个严谨的实现中，我们需要使用唯一的标识来作为访问原始数据的键，例如使用 <code>Symbol</code> 类型来代替。</p>\n<p>本节中，我们通过 <code>Map</code> 类型数据的 <code>set</code> 方法讲解了关于避免污染原始数据的问题。其实除了 <code>set</code> 方法需要避免污染原始数据之外，<code>Set</code> 类型的 <code>add</code> 方法、普通对象的写值操作，还有为数组添加元素的方法等，都需要做类似的处理。</p>\n<h3 id=\"nav_point_60\">5.8.4　处理 <code>forEach</code></h3>\n<p>集合类型的 <code>forEach</code> 方法类似于数组的 <code>forEach</code> 方法，我们先来看看它是如何工作的：</p>\n<pre class=\"code-rows\"><code> const m = new Map([\n   [{ key: 1 }, { value: 1 }]\n ])\n<p>effect(() =&gt; {<br />\nm.forEach(function (value, key, m) {<br />\nconsole.log(value) // { value: 1 }<br />\nconsole.log(key) // { key: 1 }<br />\n})<br />\n})<br />\n</code></pre></p>\n<p>以 <code>Map</code> 为例，<code>forEach</code> 方法接收一个回调函数作为参数，该回调函数会在 <code>Map</code> 的每个键值对上被调用。回调函数接收三个参数，分别是值、键以及原始 <code>Map</code> 对象。如上面的代码所示，我们可以使用 <code>forEach</code> 方法遍历 <code>Map</code> 数据的每一组键值对。</p>\n<p>遍历操作只与键值对的数量有关，因此任何会修改 <code>Map</code> 对象键值对数量的操作都应该触发副作用函数重新执行，例如 <code>delete</code> 和 <code>add</code> 方法等。所以当 <code>forEach</code> 函数被调用时，我们应该让副作用函数与 <code>ITERATE_KEY</code> 建立响应联系，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   forEach(callback) {\n     // 取得原始数据对象\n     const target = this.raw\n     // 与 ITERATE_KEY 建立响应联系\n     track(target, ITERATE_KEY)\n     // 通过原始数据对象调用 forEach 方法，并把 callback 传递过去\n     target.forEach(callback)\n   }\n }\n</code></pre>\n<p>这样我们就实现了对 <code>forEach</code> 操作的追踪，可以使用下面的代码进行测试：</p>\n<pre class=\"code-rows\"><code> const p = reactive(new Map([\n   [{ key: 1 }, { value: 1 }]\n ]))\n<p>effect(() =&gt; {<br />\np.forEach(function (value, key) {<br />\nconsole.log(value) // { value: 1 }<br />\nconsole.log(key) // { key: 1 }<br />\n})<br />\n})</p>\n<p>// 能够触发响应<br />\np.set({ key: 2 }, { value: 2 })<br />\n</code></pre></p>\n<p>可以发现，这段代码能够按照预期工作。然而，上面给出的 <code>forEach</code> 函数仍然存在缺陷，我们在自定义实现的 <code>forEach</code> 方法内，通过原始数据对象调用了原生的 <code>forEach</code> 方法，即</p>\n<pre class=\"code-rows\"><code> // 通过原始数据对象调用 forEach 方法，并把 callback 传递过去\n target.forEach(callback)\n</code></pre>\n<p>这意味着，传递给 <code>callback</code> 回调函数的参数将是非响应式数据。这导致下面的代码不能按预期工作：</p>\n<pre class=\"code-rows\"><code> const key = { key: 1 }\n const value = new Set([1, 2, 3])\n const p = reactive(new Map([\n   [key, value]\n ]))\n<p>effect(() =&gt; {<br />\np.forEach(function (value, key) {<br />\nconsole.log(value.size) // 3<br />\n})<br />\n})</p>\n<p>p.get(key).delete(1)<br />\n</code></pre></p>\n<p>在上面这段代码中，响应式数据 <code>p</code> 有一个键值对，其中键是普通对象 <code>{ key: 1 }</code>，值是 <code>Set</code> 类型的原始数据 <code>new Set([1, 2, 3])</code>。接着，我们在副作用函数中使用 <code>forEach</code> 方法遍历 <code>p</code>，并在回调函数中访问 <code>value.size</code>。最后，我们尝试删除 <code>Set</code> 类型数据中值为 <code>1</code> 的元素，却发现没能触发副作用函数重新执行。导致问题的原因就是上面曾提到的，当通过 <code>value.size</code> 访问 <code>size</code> 属性时，这里的 <code>value</code> 是原始数据对象，即 <code>new Set([1, 2, 3])</code>，而非响应式数据对象，因此无法建立响应联系。但这其实不符合直觉，因为 <code>reactive</code> 本身是深响应，<code>forEach</code> 方法的回调函数所接收到的参数也应该是响应式数据才对。为了解决这个问题，我们需要对现有实现做一些修改，如下面的代码所示：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   forEach(callback) {\n     // wrap 函数用来把可代理的值转换为响应式数据\n     const wrap = (val) =&gt; typeof val === 'object' ? reactive(val) : val\n     const target = this.raw\n     track(target, ITERATE_KEY)\n     // 通过 target 调用原始 forEach 方法进行遍历\n     target.forEach((v, k) =&gt; {\n       // 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传给 callback，这样就实现了深响应\n       callback(wrap(v), wrap(k), this)\n     })\n   }\n }\n</code></pre>\n<p>其实思路很简单，既然 <code>callback</code> 函数的参数不是响应式的，那就将它转换成响应式的。所以在上面的代码中，我们又对 <code>callback</code> 函数的参数做了一层包装，即把传递给 <code>callback</code> 函数的参数包装成响应式的。此时，如果再次尝试运行前文给出的例子，会发现它能够按预期工作了。</p>\n<p>最后，出于严谨性，我们还需要做一些补充。因为 <code>forEach</code> 函数除了接收 <code>callback</code> 作为参数之外，它还接收第二个参数，该参数可以用来指定 <code>callback</code> 函数执行时的 <code>this</code> 值。更加完善的实现如下所示：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   // 接收第二个参数\n   forEach(callback, thisArg) {\n     const wrap = (val) =&gt; typeof val === 'object' ? reactive(val) : val\n     const target = this.raw\n     track(target, ITERATE_KEY)\n<pre><code> target.forEach((v, k) =&amp;gt; {\n   // 通过 .call 调用 callback，并传递 thisArg\n   callback.call(thisArg, wrap(v), wrap(k), this)\n })\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>至此，我们的工作仍然没有完成。现在我们知道，无论是使用 <code>for...in</code> 循环遍历一个对象，还是使用 <code>forEach</code> 循环遍历一个集合，它们的响应联系都是建立在 <code>ITERATE_KEY</code> 与副作用函数之间的。然而，使用 <code>for...in</code> 来遍历对象与使用 <code>forEach</code> 遍历集合之间存在本质的不同。具体体现在，当使用 <code>for...in</code> 循环遍历对象时，它只关心对象的键，而不关心对象的值，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> effect(() =&gt; {\n   for (const key in obj) {\n     console.log(key)\n   }\n })\n</code></pre>\n<p>只有当新增、删除对象的 <code>key</code> 时，才需要重新执行副作用函数。所以我们在 <code>trigger</code> 函数内判断操作类型是否是 <code>ADD</code> 或 <code>DELETE</code>，进而知道是否需要触发那些与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行。对于 <code>SET</code> 类型的操作来说，因为它不会改变一个对象的键的数量，所以当 <code>SET</code> 类型的操作发生时，不需要触发副作用函数重新执行。</p>\n<p>但这个规则不适用于 <code>Map</code> 类型的 <code>forEach</code> 遍历，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> const p = reactive(new Map([\n   ['key', 1]\n ]))\n<p>effect(() =&gt; {<br />\np.forEach(function (value, key) {<br />\n// forEach 循环不仅关心集合的键，还关心集合的值<br />\nconsole.log(value) // 1<br />\n})<br />\n})</p>\n<p>p.set(‘key’, 2) // 即使操作类型是 SET，也应该触发响应<br />\n</code></pre></p>\n<p>当使用 <code>forEach</code> 遍历 <code>Map</code> 类型的数据时，它既关心键，又关心值。这意味着，当调用 <code>p.set('key', 2)</code> 修改值的时候，也应该触发副作用函数重新执行，即使它的操作类型是 <code>SET</code>。因此，我们应该修改 <code>trigger</code> 函数的代码来弥补这个缺陷：</p>\n<pre class=\"code-rows\"><code> function trigger(target, key, type, newVal) {\n   console.log('trigger', key)\n   const depsMap = bucket.get(target)\n   if (!depsMap) return\n   const effects = depsMap.get(key)\n<p>const effectsToRun = new Set()<br />\neffects &amp;&amp; effects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})</p>\n<p>if (<br />\ntype === ‘ADD’ ||<br />\ntype === ‘DELETE’ ||<br />\n// 如果操作类型是 SET，并且目标对象是 Map 类型的数据，<br />\n// 也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行<br />\n(<br />\ntype === ‘SET’ &amp;&amp;<br />\nObject.prototype.toString.call(target) === ‘[object Map]’<br />\n)<br />\n) {<br />\nconst iterateEffects = depsMap.get(ITERATE_KEY)<br />\niterateEffects &amp;&amp; iterateEffects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})<br />\n}</p>\n<p>// 省略部分内容</p>\n<p>effectsToRun.forEach(effectFn =&gt; {<br />\nif (effectFn.options.scheduler) {<br />\neffectFn.options.scheduler(effectFn)<br />\n} else {<br />\neffectFn()<br />\n}<br />\n})<br />\n}<br />\n</code></pre></p>\n<p>如上面的代码所示，我们增加了一个判断条件：如果操作的目标对象是 <code>Map</code> 类型的，则 <code>SET</code> 类型的操作也应该触发那些与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行。</p>\n<h3 id=\"nav_point_61\">5.8.5　迭代器方法</h3>\n<p>接下来，我们讨论关于集合类型的迭代器方法，实际上前面讲解如何拦截 <code>for...of</code> 循环遍历数组的时候介绍过迭代器的相关知识。集合类型有三个迭代器方法：</p>\n<ul>\n<li><code>entries</code></li>\n<li><code>keys</code></li>\n<li><code>values</code></li>\n</ul>\n<p>调用这些方法会得到相应的迭代器，并且可以使用 <code>for...of</code> 进行循环迭代，例如：</p>\n<pre class=\"code-rows\"><code> const m = new Map([\n   ['key1', 'value1'],\n   ['key2', 'value2']\n ])\n<p>for (const [key, value] of m.entries()) {<br />\nconsole.log(key, value)<br />\n}<br />\n// 输出：<br />\n// key1 value1<br />\n// key2 value2<br />\n</code></pre></p>\n<p>另外，由于 <code>Map</code> 或 <code>Set</code> 类型本身部署了 <code>Symbol.iterator</code> 方法，因此它们可以使用 <code>for...of</code> 进行迭代：</p>\n<pre class=\"code-rows\"><code> for (const [key, value] of m) {\n   console.log(key, value)\n }\n // 输出：\n // key1 value1\n // key2 value2\n</code></pre>\n<p>当然，我们也可以调用迭代器函数取得迭代器对象后，手动调用迭代器对象的 <code>next</code> 方法获取对应的值：</p>\n<pre class=\"code-rows\"><code> const itr = m[Symbol.iterator]()\n console.log(itr.next())  // { value: ['key1', 'value1'], done: false }\n console.log(itr.next())  // { value: ['key2', 'value2'], done: false }\n console.log(itr.next())  // { value: undefined, done: true }\n</code></pre>\n<p>实际上，<code>m[Symbol.iterator]</code> 与 <code>m.entries</code> 是等价的：</p>\n<pre class=\"code-rows\"><code> console.log(m[Symbol.iterator] === m.entries) // true\n</code></pre>\n<p>这就是为什么上例中使用 <code>for...of</code> 循环迭代 <code>m.entries</code> 和 <code>m</code> 会得到同样的结果。</p>\n<p>理解了这些内容后，我们就可以尝试实现对迭代器方法的代理了。不过在这之前，不妨做一些尝试，看看会发生什么，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> const p = reactive(new Map([\n   ['key1', 'value1'],\n   ['key2', 'value2']\n ]))\n<p>effect(() =&gt; {<br />\n// TypeError: p is not iterable<br />\nfor (const [key, value] of p) {<br />\nconsole.log(key, value)<br />\n}<br />\n})</p>\n<p>p.set(‘key3’, ‘value3’)<br />\n</code></pre></p>\n<p>在这段代码中，我们首先创建一个代理对象 <code>p</code>，接着尝试使用 <code>for...of</code> 循环遍历它，却得到了一个错误：“<code>p</code> 是不可迭代的”。我们知道一个对象能否迭代，取决于该对象是否实现了迭代协议，如果一个对象正确地实现了 <code>Symbol.iterator</code> 方法，那么它就是可迭代的。很显然，代理对象 <code>p</code> 没有实现 <code>Symbol.iterator</code> 方法，因此我们得到了上面的错误。</p>\n<p>但实际上，当我们使用 <code>for...of</code> 循环迭代一个代理对象时，内部会试图从代理对象 <code>p</code> 上读取 <code>p[Symbol.iterator]</code> 属性，这个操作会触发 <code>get</code> 拦截函数，所以我们仍然可以把 <code>Symbol.iterator</code> 方法的实现放到 <code>mutableInstrumentations</code> 中，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   [Symbol.iterator]() {\n     // 获取原始数据对象 target\n     const target = this.raw\n     // 获取原始迭代器方法\n     const itr = target[Symbol.iterator]()\n     // 将其返回\n     return itr\n   }\n }\n</code></pre>\n<p>实现很简单，不过是把原始的迭代器对象返回而已，这样就能够使用 <code>for...of</code> 循环迭代代理对象 <code>p</code> 了，然而事情不可能这么简单。在 5.8.4 节中讲解 <code>forEach</code> 方法时我们提到过，传递给 <code>callback</code> 的参数是包装后的响应式数据，如：</p>\n<pre class=\"code-rows\"><code> p.forEach((value, key) =&gt; {\n   // value 和 key 如果可以被代理，那么它们就是代理对象，即响应式数据\n })\n</code></pre>\n<p>同理，使用 <code>for...of</code> 循环迭代集合时，如果迭代产生的值也是可以被代理的，那么也应该将其包装成响应式数据，例如：</p>\n<pre class=\"code-rows\"><code> for (const [key, value] of p) {\n   // 期望 key 和 value 是响应式数据\n }\n</code></pre>\n<p>因此，我们需要修改代码：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   [Symbol.iterator]() {\n     // 获取原始数据对象 target\n     const target = this.raw\n     // 获取原始迭代器方法\n     const itr = target[Symbol.iterator]()\n<pre><code> const wrap = (val) =&amp;gt; typeof val === 'object' &amp;amp;&amp;amp; val !== null ? reactive(val) : val\n\n // 返回自定义的迭代器\n return {\n   next() {\n     // 调用原始迭代器的 next 方法获取 value 和 done\n     const { value, done } = itr.next()\n     return {\n       // 如果 value 不是 undefined，则对其进行包裹\n       value: value ? [wrap(value[0]), wrap(value[1])] : value,\n       done\n     }\n   }\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>如以上代码所示，为了实现对 <code>key</code> 和 <code>value</code> 的包装，我们需要自定义实现的迭代器，在其中调用原始迭代器获取值 <code>value</code> 以及代表是否结束的 <code>done</code>。如果值 <code>value</code> 不为 <code>undefined</code>，则对其进行包装，最后返回包装后的代理对象，这样当使用 <code>for...of</code> 循环进行迭代时，得到的值就会是响应式数据了。</p>\n<p>最后，为了追踪 <code>for...of</code> 对数据的迭代操作，我们还需要调用 <code>track</code> 函数，让副作用函数与 <code>ITERATE_KEY</code> 建立联系：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   [Symbol.iterator]() {\n     const target = this.raw\n     const itr = target[Symbol.iterator]()\n<pre><code> const wrap = (val) =&amp;gt; typeof val === 'object' &amp;amp;&amp;amp; val !== null ? reactive(val) : val\n\n // 调用 track 函数建立响应联系\n track(target, ITERATE_KEY)\n\n return {\n   next() {\n     const { value, done } = itr.next()\n     return {\n       value: value ? [wrap(value[0]), wrap(value[1])] : value,\n       done\n     }\n   }\n }\n</code></pre>\n<p>}<br />\n}<br />\n</code></pre></p>\n<p>由于迭代操作与集合中元素的数量有关，所以只要集合的 <code>size</code> 发生变化，就应该触发迭代操作重新执行。因此，我们在调用 <code>track</code> 函数时让 <code>ITERATE_KEY</code> 与副作用函数建立联系。完成这一步后，集合的响应式数据功能就相对完整了，我们可以通过如下代码测试一下：</p>\n<pre class=\"code-rows\"><code> const p = reactive(new Map([\n   ['key1', 'value1'],\n   ['key2', 'value2']\n ]))\n<p>effect(() =&gt; {<br />\nfor (const [key, value] of p) {<br />\nconsole.log(key, value)<br />\n}<br />\n})</p>\n<p>p.set(‘key3’, ‘value3’) // 能够触发响应<br />\n</code></pre></p>\n<p>前面我们说过，由于 <code>p.entries</code> 与 <code>p[Symbol.iterator]</code> 等价，所以我们可以使用同样的代码来实现对 <code>p.entries</code> 函数的拦截，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   // 共用 iterationMethod 方法\n   [Symbol.iterator]: iterationMethod,\n   entries: iterationMethod\n }\n // 抽离为独立的函数，便于复用\n function iterationMethod() {\n   const target = this.raw\n   const itr = target[Symbol.iterator]()\n<p>const wrap = (val) =&gt; typeof val === ‘object’ ? reactive(val) : val</p>\n<p>track(target, ITERATE_KEY)</p>\n<p>return {<br />\nnext() {<br />\nconst { value, done } = itr.next()<br />\nreturn {<br />\nvalue: value ? [wrap(value[0]), wrap(value[1])] : value,<br />\ndone<br />\n}<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>但当你尝试运行代码使用 <code>for...of</code> 进行迭代时，会得到一个错误：</p>\n<pre class=\"code-rows\"><code> // TypeError: p.entries is not a function or its return value is not iterable\n for (const [key, value] of p.entries()) {\n   console.log(key, value)\n }\n</code></pre>\n<p>错误的大意是 <code>p.entries</code> 的返回值不是一个可迭代对象。很显然，<code>p.entries</code> 函数的返回值是一个对象，该对象带有 <code>next</code> 方法，但不具有 <code>Symbol.iterator</code> 方法，因此它确实不是一个可迭代对象。这里是经常出错的地方，大家切勿把可迭代协议与迭代器协议搞混。可迭代协议指的是一个对象实现了 <code>Symbol.iterator</code> 方法，而迭代器协议指的是一个对象实现了 <code>next</code> 方法。但一个对象可以同时实现可迭代协议和迭代器协议，例如：</p>\n<pre class=\"code-rows\"><code> const obj = {\n   // 迭代器协议\n   next() {\n     // ...\n   }\n   // 可迭代协议\n   [Symbol.iterator]() {\n     return this\n   }\n }\n</code></pre>\n<p>所以解决问题的方法也自然而然地出现了：</p>\n<pre class=\"code-rows\"><code> // 抽离为独立的函数，便于复用\n function iterationMethod() {\n   const target = this.raw\n   const itr = target[Symbol.iterator]()\n<p>const wrap = (val) =&gt; typeof val === ‘object’ ? reactive(val) : val</p>\n<p>track(target, ITERATE_KEY)</p>\n<p>return {<br />\nnext() {<br />\nconst { value, done } = itr.next()<br />\nreturn {<br />\nvalue: value ? [wrap(value[0]), wrap(value[1])] : value,<br />\ndone<br />\n}<br />\n}<br />\n// 实现可迭代协议<br />\n<a href=\"\">Symbol.iterator</a> {<br />\nreturn this<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>现在一切都能正常工作了。</p>\n<h3 id=\"nav_point_62\">5.8.6　<code>values</code> 与 <code>keys</code> 方法</h3>\n<p><code>values</code> 方法的实现与 <code>entries</code> 方法类似，不同的是，当使用 <code>for...of</code> 迭代 <code>values</code> 时，得到的仅仅是 <code>Map</code> 数据的值，而非键值对：</p>\n<pre class=\"code-rows\"><code> for (const value of p.values()) {\n   console.log(value)\n }\n</code></pre>\n<p><code>values</code> 方法的实现如下：</p>\n<pre class=\"code-rows\"><code> const mutableInstrumentations = {\n   // 共用 iterationMethod 方法\n   [Symbol.iterator]: iterationMethod,\n   entries: iterationMethod,\n   values: valuesIterationMethod\n }\n<p>function valuesIterationMethod() {<br />\n// 获取原始数据对象 target<br />\nconst target = this.raw<br />\n// 通过 target.values 获取原始迭代器方法<br />\nconst itr = target.values()</p>\n<p>const wrap = (val) =&gt; typeof val === ‘object’ ? reactive(val) : val</p>\n<p>track(target, ITERATE_KEY)</p>\n<p>// 将其返回<br />\nreturn {<br />\nnext() {<br />\nconst { value, done } = itr.next()<br />\nreturn {<br />\n// value 是值，而非键值对，所以只需要包裹 value 即可<br />\nvalue: wrap(value),<br />\ndone<br />\n}<br />\n},<br />\n<a href=\"\">Symbol.iterator</a> {<br />\nreturn this<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>其中，<code>valuesIterationMethod</code> 与 <code>iterationMethod</code> 这两个方法有两点区别：</p>\n<ul>\n<li><code>iterationMethod</code> 通过 <code>target[Symbol.iterator]</code> 获取迭代器对象，而 <code>valuesIterationMethod</code> 通过 <code>target.values</code> 获取迭代器对象；</li>\n<li><code>iterationMethod</code> 处理的是键值对，即 <code>[wrap(value[0]), wrap(value[1])]</code>，而 <code>valuesIterationMethod</code> 只处理值，即 <code>wrap(value)</code>。</li>\n</ul>\n<p>由于它们的大部分逻辑相同，所以我们可以将它们封装到一个可复用的函数中。但为了便于理解，这里仍然将它们设计为两个独立的函数来实现。</p>\n<p><code>keys</code> 方法与 <code>values</code> 方法非常类似，不同点在于，前者处理的是键而非值。因此，我们只需要修改 <code>valuesIterationMethod</code> 方法中的一行代码，即可实现对 <code>keys</code> 方法的代理。把下面这句代码：</p>\n<pre class=\"code-rows\"><code> const itr = target.values()\n</code></pre>\n<p>替换成：</p>\n<pre class=\"code-rows\"><code> const itr = target.keys()\n</code></pre>\n<p>这么做的确能够达到目的，但如果我们尝试运行如下测试用例，就会发现存在缺陷：</p>\n<pre class=\"code-rows\"><code> const p = reactive(new Map([\n   ['key1', 'value1'],\n   ['key2', 'value2']\n ]))\n<p>effect(() =&gt; {<br />\nfor (const value of p.keys()) {<br />\nconsole.log(value) // key1 key2<br />\n}<br />\n})</p>\n<p>p.set(‘key2’, ‘value3’) // 这是一个 SET 类型的操作，它修改了 key2 的值<br />\n</code></pre></p>\n<p>在上面这段代码中，我们使用 <code>for...of</code> 循环来遍历 <code>p.keys</code>，然后调用 <code>p.set('key2', 'value3')</code> 修改键为 <code>key2</code> 的值。在这个过程中，<code>Map</code> 类型数据的所有键都没有发生变化，仍然是 <code>key1</code> 和 <code>key2</code>，所以在理想情况下，副作用函数不应该执行。但如果你尝试运行上例，会发现副作用函数仍然重新执行了。</p>\n<p>这是因为，我们对 <code>Map</code> 类型的数据进行了特殊处理。前文提到，即使操作类型为 <code>SET</code>，也会触发那些与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行，<code>trigger</code> 函数的代码可以证明这一点：</p>\n<pre class=\"code-rows\"><code> function trigger(target, key, type, newVal) {\n   // 省略其他代码\n<p>if (<br />\ntype === ‘ADD’ ||<br />\ntype === ‘DELETE’ ||<br />\n// 即使是 SET 类型的操作，也会触发那些与 ITERATE_KEY 相关联的副作用函数重新执行<br />\n(<br />\ntype === ‘SET’ &amp;&amp;<br />\nObject.prototype.toString.call(target) === ‘[object Map]’<br />\n)<br />\n) {<br />\nconst iterateEffects = depsMap.get(ITERATE_KEY)<br />\niterateEffects &amp;&amp; iterateEffects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})<br />\n}</p>\n<p>// 省略其他代码<br />\n}<br />\n</code></pre></p>\n<p>这对于 <code>values</code> 或 <code>entries</code> 等方法来说是必需的，但对于 <code>keys</code> 方法来说则没有必要，因为 <code>keys</code> 方法只关心 <code>Map</code> 类型数据的键的变化，而不关心值的变化。</p>\n<p>解决办法很简单，如以下代码所示：</p>\n<pre class=\"code-rows\"><code> const MAP_KEY_ITERATE_KEY = Symbol()\n<p>function keysIterationMethod() {<br />\n// 获取原始数据对象 target<br />\nconst target = this.raw<br />\n// 获取原始迭代器方法<br />\nconst itr = target.keys()</p>\n<p>const wrap = (val) =&gt; typeof val === ‘object’ ? reactive(val) : val</p>\n<p>// 调用 track 函数追踪依赖，在副作用函数与 MAP_KEY_ITERATE_KEY 之间建立响应联系<br />\ntrack(target, MAP_KEY_ITERATE_KEY)</p>\n<p>// 将其返回<br />\nreturn {<br />\nnext() {<br />\nconst { value, done } = itr.next()<br />\nreturn {<br />\nvalue: wrap(value),<br />\ndone<br />\n}<br />\n},<br />\n<a href=\"\">Symbol.iterator</a> {<br />\nreturn this<br />\n}<br />\n}<br />\n}<br />\n</code></pre></p>\n<p>在上面这段代码中，当调用 <code>track</code> 函数追踪依赖时，我们使用 <code>MAP_KEY_ITERATE_KEY</code> 代替了 <code>ITERATE_KEY</code>。其中 <code>MAP_KEY_ITERATE_KEY</code> 与 <code>ITERATE_KEY</code> 类似，是一个新的 <code>Symbol</code> 类型，用来作为抽象的键。这样就实现了依赖收集的分离，即 <code>values</code> 和 <code>entries</code> 等方法仍然依赖 <code>ITERATE_KEY</code>，而 <code>keys</code> 方法则依赖 <code>MAP_KEY_ITERATE_KEY</code>。当 <code>SET</code> 类型的操作只会触发与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行时，自然就会忽略那些与 <code>MAP_KEY_ITERATE_KEY</code> 相关联的副作用函数。但当 <code>ADD</code> 和 <code>DELETE</code> 类型的操作发生时，除了触发与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行之外，还需要触发与 <code>MAP_KEY_ITERATE_KEY</code> 相关联的副作用函数重新执行，因此我们需要修改 <code>trigger</code> 函数的代码，如下所示：</p>\n<pre class=\"code-rows\"><code> function trigger(target, key, type, newVal) {\n   // 省略其他代码\n<p>if (<br />\n// 操作类型为 ADD 或 DELETE<br />\n(type === ‘ADD’ || type === ‘DELETE’) &amp;&amp;<br />\n// 并且是 Map 类型的数据<br />\nObject.prototype.toString.call(target) === ‘[object Map]’<br />\n) {<br />\n// 则取出那些与 MAP_KEY_ITERATE_KEY 相关联的副作用函数并执行<br />\nconst iterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)<br />\niterateEffects &amp;&amp; iterateEffects.forEach(effectFn =&gt; {<br />\nif (effectFn !== activeEffect) {<br />\neffectsToRun.add(effectFn)<br />\n}<br />\n})<br />\n}</p>\n<p>// 省略其他代码<br />\n}<br />\n</code></pre></p>\n<p>这样，就能够避免不必要的更新了：</p>\n<pre class=\"code-rows\"><code> const p = reactive(new Map([\n   ['key1', 'value1'],\n   ['key2', 'value2']\n ]))\n<p>effect(() =&gt; {<br />\nfor (const value of p.keys()) {<br />\nconsole.log(value)<br />\n}<br />\n})</p>\n<p>p.set(‘key2’, ‘value3’) // 不会触发响应<br />\np.set(‘key3’, ‘value3’) // 能够触发响应<br />\n</code></pre></p>\n<h2 id=\"nav_point_63\">5.9　总结</h2>\n<p>在本章中，我们首先介绍了 <code>Proxy</code> 与 <code>Reflect</code>。Vue.js 3 的响应式数据是基于 <code>Proxy</code> 实现的，<code>Proxy</code> 可以为其他对象创建一个代理对象。所谓代理，指的是对一个对象<strong>基本语义</strong>的代理。它允许我们<strong>拦截</strong>并<strong>重新定义</strong>对一个对象的基本操作。在实现代理的过程中，我们遇到了访问器属性的 <code>this</code> 指向问题，这需要使用 <code>Reflect.*</code> 方法并指定正确的 <code>receiver</code> 来解决。</p>\n<p>然后我们详细讨论了 JavaScript 中对象的概念，以及 <code>Proxy</code> 的工作原理。在 ECMAScript 规范中，JavaScript 中有两种对象，其中一种叫作常规对象，另一种叫作异质对象。满足以下三点要求的对象就是常规对象：</p>\n<ul>\n<li>对于表 5-1 给出的内部方法，必须使用规范 10.1.x 节给出的定义实现；</li>\n<li>对于内部方法 <code>[[Call]]</code>，必须使用规范 10.2.1 节给出的定义实现；</li>\n<li>对于内部方法 <code>[[Construct]]</code>，必须使用规范 10.2.2 节给出的定义实现。</li>\n</ul>\n<p>而所有不符合这三点要求的对象都是异质对象。一个对象是函数还是其他对象，是由部署在该对象上的内部方法和内部槽决定的。</p>\n<p>接着，我们讨论了关于对象 <code>Object</code> 的代理。代理对象的本质，就是查阅规范并找到可拦截的基本操作的方法。有一些操作并不是基本操作，而是复合操作，这需要我们查阅规范了解它们都依赖哪些基本操作，从而通过基本操作的拦截方法间接地处理复合操作。我们还详细分析了添加、修改、删除属性对 <code>for...in</code> 操作的影响，其中添加和删除属性都会影响 <code>for...in</code> 循环的执行次数，所以当这些操作发生时，需要触发与 <code>ITERATE_KEY</code> 相关联的副作用函数重新执行。而修改属性值则不影响 <code>for...in</code> 循环的执行次数，因此无须处理。我们还讨论了如何合理地触发副作用函数重新执行，包括对 <code>NaN</code> 的处理，以及访问原型链上的属性导致的副作用函数重新执行两次的问题。对于 <code>NaN</code>，我们主要注意的是 <code>NaN === NaN</code> 永远等于 <code>false</code>。对于原型链属性问题，需要我们查阅规范定位问题的原因。由此可见，想要基于 <code>Proxy</code> 实现一个相对完善的响应系统，免不了去了解 ECMAScript 规范。</p>\n<p>而后，我们讨论了深响应与浅响应，以及深只读与浅只读。这里的深和浅指的是对象的层级，浅响应（或只读）代表仅代理一个对象的第一层属性，即只有对象的第一层属性值是响应（或只读）的。深响应（或只读）则恰恰相反，为了实现深响应（或只读），我们需要在返回属性值之前，对值做一层包装，将其包装为响应式（或只读）数据后再返回。</p>\n<p>之后，我们讨论了关于数组的代理。数组是一个异质对象，因为数组对象部署的内部方法 <code>[[DefineOwnProperty]]</code> 不同于常规对象。通过索引为数组设置新的元素，可能会隐式地改变数组 <code>length</code> 属性的值。对应地，修改数组 <code>length</code> 属性的值，也可能会间接影响数组中的已有元素。所以在触发响应的时候需要额外注意。我们还讨论了如何拦截 <code>for...in</code> 和 <code>for...of</code> 对数组的遍历操作。使用 <code>for...in</code> 循环遍历数组与遍历普通对象区别不大，唯一需要注意的是，当追踪 <code>for...in</code> 操作时，应该使用数组的 <code>length</code> 作为追踪的 <code>key</code>。<code>for...of</code> 基于迭代协议工作，数组内建了 <code>Symbol.iterator</code> 方法。根据规范的 23.1.5.1 节可知，数组迭代器执行时，会读取数组的 <code>length</code> 属性或数组的索引。因此，我们不需要做其他额外的处理，就能够实现对 <code>for...of</code> 迭代的响应式支持。</p>\n<p>我们还讨论了数组的查找方法。如 <code>includes</code>、<code>indexOf</code> 以及 <code>lastIndexOf</code> 等。对于数组元素的查找，需要注意的一点是，用户既可能使用代理对象进行查找，也可能使用原始对象进行查找。为了支持这两种形式，我们需要重写数组的查找方法。原理很简单，当用户使用这些方法查找元素时，我们可以先去代理对象中查找，如果找不到，再去原始数组中查找。</p>\n<p>我们还介绍了会隐式修改数组长度的原型方法，即 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code> 以及 <code>splice</code> 等方法。调用这些方法会间接地读取和设置数组的 <code>length</code> 属性，因此，在不同的副作用函数内对同一个数组执行上述方法，会导致多个副作用函数之间循环调用，最终导致调用栈溢出。为了解决这个问题，我们使用一个标记变量 <code>shouldTrack</code> 来代表是否允许进行追踪，然后重写了上述这些方法，目的是，当这些方法间接读取 <code>length</code> 属性值时，我们会先将 <code>shouldTrack</code> 的值设置为 <code>false</code>，即禁止追踪。这样就可以断开 <code>length</code> 属性与副作用函数之间的响应联系，从而避免循环调用导致的调用栈溢出。</p>\n<p>最后，我们讨论了关于集合类型数据的响应式方案。集合类型指 <code>Set</code>、<code>Map</code>、<code>WeakSet</code> 以及 <code>WeakMap</code>。我们讨论了使用 <code>Proxy</code> 为集合类型创建代理对象的一些注意事项。集合类型不同于普通对象，它有特定的数据操作方法。当使用 <code>Proxy</code> 代理集合类型的数据时要格外注意，例如，集合类型的 <code>size</code> 属性是一个访问器属性，当通过代理对象访问 <code>size</code> 属性时，由于代理对象本身并没有部署 <code>[[SetData]]</code> 这样的内部槽，所以会发生错误。另外，通过代理对象执行集合类型的操作方法时，要注意这些方法执行时的 <code>this</code> 指向，我们需要在 <code>get</code> 拦截函数内通过 <code>.bind</code> 函数为这些方法绑定正确的 <code>this</code> 值。我们还讨论了集合类型响应式数据的实现。我们需要通过“重写”集合方法的方式来实现自定义的能力，当 <code>Set</code> 集合的 <code>add</code> 方法执行时，需要调用 <code>trigger</code> 函数触发响应。我们也讨论了关于“数据污染”的问题。数据污染指的是不小心将响应式数据添加到原始数据中，它导致用户可以通过原始数据执行响应式相关操作，这不是我们所期望的。为了避免这类问题发生，我们通过响应式数据对象的 <code>raw</code> 属性来访问对应的原始数据对象，后续操作使用原始数据对象就可以了。我们还讨论了关于集合类型的遍历，即 <code>forEach</code> 方法。集合的 <code>forEach</code> 方法与对象的 <code>for...in</code> 遍历类似，最大的不同体现在，当使用 <code>for...in</code> 遍历对象时，我们只关心对象的键是否变化，而不关心值；但使用 <code>forEach</code> 遍历集合时，我们既关心键的变化，也关心值的变化。</p>\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"第 5 章 非原始值的响应式方案(2)","id":740765},"right":{"article_title":"第 6 章 原始值的响应式方案","id":740768}},"comments":[]}