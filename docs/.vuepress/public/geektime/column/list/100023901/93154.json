{"id":93154,"title":"29 | Copy-on-Write模式：不是延时策略的COW","content":"<p>在上一篇文章中我们讲到Java里String这个类在实现replace()方法的时候，并没有更改原字符串里面value[]数组的内容，而是创建了一个新字符串，这种方法在解决不可变对象的修改问题时经常用到。如果你深入地思考这个方法，你会发现它本质上是一种<strong>Copy-on-Write方法</strong>。所谓Copy-on-Write，经常被缩写为COW或者CoW，顾名思义就是<strong>写时复制</strong>。</p><p>不可变对象的写操作往往都是使用Copy-on-Write方法解决的，当然Copy-on-Write的应用领域并不局限于Immutability模式。下面我们先简单介绍一下Copy-on-Write的应用领域，让你对它有个更全面的认识。</p><h2>Copy-on-Write模式的应用领域</h2><p>我们前面在<a href=\"https://time.geekbang.org/column/article/90201\">《20 | 并发容器：都有哪些“坑”需要我们填？》</a>中介绍过CopyOnWriteArrayList和CopyOnWriteArraySet这两个Copy-on-Write容器，它们背后的设计思想就是Copy-on-Write；通过Copy-on-Write这两个容器实现的读操作是无锁的，由于无锁，所以将读操作的性能发挥到了极致。</p><p>除了Java这个领域，Copy-on-Write在操作系统领域也有广泛的应用。</p><!-- [[[read_end]]] --><p>我第一次接触Copy-on-Write其实就是在操作系统领域。类Unix的操作系统中创建进程的API是fork()，传统的fork()函数会创建父进程的一个完整副本，例如父进程的地址空间现在用到了1G的内存，那么fork()子进程的时候要复制父进程整个进程的地址空间（占有1G内存）给子进程，这个过程是很耗时的。而Linux中的fork()函数就聪明得多了，fork()子进程的时候，并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间；只用在父进程或者子进程需要写入的时候才会复制地址空间，从而使父子进程拥有各自的地址空间。</p><p>本质上来讲，父子进程的地址空间以及数据都是要隔离的，使用Copy-on-Write更多地体现的是一种<strong>延时策略，只有在真正需要复制的时候才复制，而不是提前复制好</strong>，同时Copy-on-Write还支持按需复制，所以Copy-on-Write在操作系统领域是能够提升性能的。相比较而言，Java提供的Copy-on-Write容器，由于在修改的同时会复制整个容器，所以在提升读操作性能的同时，是以内存复制为代价的。这里你会发现，同样是应用Copy-on-Write，不同的场景，对性能的影响是不同的。</p><p>在操作系统领域，除了创建进程用到了Copy-on-Write，很多文件系统也同样用到了，例如Btrfs (B-Tree File System)、aufs（advanced multi-layered unification filesystem）等。</p><p>除了上面我们说的Java领域、操作系统领域，很多其他领域也都能看到Copy-on-Write的身影：Docker容器镜像的设计是Copy-on-Write，甚至分布式源码管理系统Git背后的设计思想都有Copy-on-Write……</p><p>不过，<strong>Copy-on-Write最大的应用领域还是在函数式编程领域</strong>。函数式编程的基础是不可变性（Immutability），所以函数式编程里面所有的修改操作都需要Copy-on-Write来解决。你或许会有疑问，“所有数据的修改都需要复制一份，性能是不是会成为瓶颈呢？”你的担忧是有道理的，之所以函数式编程早年间没有兴起，性能绝对拖了后腿。但是随着硬件性能的提升，性能问题已经慢慢变得可以接受了。而且，Copy-on-Write也远不像Java里的CopyOnWriteArrayList那样笨：整个数组都复制一遍。Copy-on-Write也是可以按需复制的，如果你感兴趣可以参考<span class=\"orange\">Purely Functional Data Structures</span>这本书，里面描述了各种具备不变性的数据结构的实现。</p><p>CopyOnWriteArrayList和CopyOnWriteArraySet这两个Copy-on-Write容器在修改的时候会复制整个数组，所以如果容器经常被修改或者这个数组本身就非常大的时候，是不建议使用的。反之，如果是修改非常少、数组数量也不大，并且对读性能要求苛刻的场景，使用Copy-on-Write容器效果就非常好了。下面我们结合一个真实的案例来讲解一下。</p><h2>一个真实案例</h2><p>我曾经写过一个RPC框架，有点类似Dubbo，服务提供方是多实例分布式部署的，所以服务的客户端在调用RPC的时候，会选定一个服务实例来调用，这个选定的过程本质上就是在做负载均衡，而做负载均衡的前提是客户端要有全部的路由信息。例如在下图中，A服务的提供方有3个实例，分别是192.168.1.1、192.168.1.2和192.168.1.3，客户端在调用目标服务A前，首先需要做的是负载均衡，也就是从这3个实例中选出1个来，然后再通过RPC把请求发送选中的目标实例。</p><p><img src=\"https://static001.geekbang.org/resource/image/71/1e/713c0fb87154ee6fbb58f71b274b661e.png?wh=1142*510\" alt=\"\"></p><center><span class=\"reference\">RPC路由关系图</span></center><p>RPC框架的一个核心任务就是维护服务的路由关系，我们可以把服务的路由关系简化成下图所示的路由表。当服务提供方上线或者下线的时候，就需要更新客户端的这张路由表。</p><p><img src=\"https://static001.geekbang.org/resource/image/dc/60/dca6c365d689f2316ca34de613b3fd60.png?wh=1142*493\" alt=\"\"></p><p>我们首先来分析一下如何用程序来实现。每次RPC调用都需要通过负载均衡器来计算目标服务的IP和端口号，而负载均衡器需要通过路由表获取接口的所有路由信息，也就是说，每次RPC调用都需要访问路由表，所以访问路由表这个操作的性能要求是很高的。不过路由表对数据的一致性要求并不高，一个服务提供方从上线到反馈到客户端的路由表里，即便有5秒钟，很多时候也都是能接受的（5秒钟，对于以纳秒作为时钟周期的CPU来说，那何止是一万年，所以路由表对一致性的要求并不高）。而且路由表是典型的读多写少类问题，写操作的量相比于读操作，可谓是沧海一粟，少得可怜。</p><p>通过以上分析，你会发现一些关键词：对读的性能要求很高，读多写少，弱一致性。它们综合在一起，你会想到什么呢？CopyOnWriteArrayList和CopyOnWriteArraySet天生就适用这种场景啊。所以下面的示例代码中，RouteTable这个类内部我们通过<code>ConcurrentHashMap&lt;String, CopyOnWriteArraySet&lt;Router&gt;&gt;</code>这个数据结构来描述路由表，ConcurrentHashMap的Key是接口名，Value是路由集合，这个路由集合我们用是CopyOnWriteArraySet。</p><p>下面我们再来思考Router该如何设计，服务提供方的每一次上线、下线都会更新路由信息，这时候你有两种选择。一种是通过更新Router的一个状态位来标识，如果这样做，那么所有访问该状态位的地方都需要同步访问，这样很影响性能。另外一种就是采用Immutability模式，每次上线、下线都创建新的Router对象或者删除对应的Router对象。由于上线、下线的频率很低，所以后者是最好的选择。</p><p>Router的实现代码如下所示，是一种典型Immutability模式的实现，需要你注意的是我们重写了equals方法，这样CopyOnWriteArraySet的add()和remove()方法才能正常工作。</p><pre><code>//路由信息\npublic final class Router{\n  private final String  ip;\n  private final Integer port;\n  private final String  iface;\n  //构造函数\n  public Router(String ip, \n      Integer port, String iface){\n    this.ip = ip;\n    this.port = port;\n    this.iface = iface;\n  }\n  //重写equals方法\n  public boolean equals(Object obj){\n    if (obj instanceof Router) {\n      Router r = (Router)obj;\n      return iface.equals(r.iface) &amp;&amp;\n             ip.equals(r.ip) &amp;&amp;\n             port.equals(r.port);\n    }\n    return false;\n  }\n  public int hashCode() {\n    //省略hashCode相关代码\n  }\n}\n//路由表信息\npublic class RouterTable {\n  //Key:接口名\n  //Value:路由集合\n  ConcurrentHashMap&lt;String, CopyOnWriteArraySet&lt;Router&gt;&gt; \n    rt = new ConcurrentHashMap&lt;&gt;();\n  //根据接口名获取路由表\n  public Set&lt;Router&gt; get(String iface){\n    return rt.get(iface);\n  }\n  //删除路由\n  public void remove(Router router) {\n    Set&lt;Router&gt; set=rt.get(router.iface);\n    if (set != null) {\n      set.remove(router);\n    }\n  }\n  //增加路由\n  public void add(Router router) {\n    Set&lt;Router&gt; set = rt.computeIfAbsent(\n      route.iface, r -&gt; \n        new CopyOnWriteArraySet&lt;&gt;());\n    set.add(router);\n  }\n}\n</code></pre><h2>总结</h2><p>目前Copy-on-Write在Java并发编程领域知名度不是很高，很多人都在无意中把它忽视了，但其实Copy-on-Write才是最简单的并发解决方案。它是如此简单，以至于Java中的基本数据类型String、Integer、Long等都是基于Copy-on-Write方案实现的。</p><p>Copy-on-Write是一项非常通用的技术方案，在很多领域都有着广泛的应用。不过，它也有缺点的，那就是消耗内存，每次修改都需要复制一个新的对象出来，好在随着自动垃圾回收（GC）算法的成熟以及硬件的发展，这种内存消耗已经渐渐可以接受了。所以在实际工作中，如果写操作非常少，那你就可以尝试用一下Copy-on-Write，效果还是不错的。</p><h2>课后思考</h2><p>Java提供了CopyOnWriteArrayList，为什么没有提供CopyOnWriteLinkedList呢？</p><p>欢迎在留言区与我分享你的想法，也欢迎你在留言区记录你的思考过程。感谢阅读，如果你觉得这篇文章对你有帮助的话，也欢迎把它分享给更多的朋友。</p><p></p>","neighbors":{"left":{"article_title":"28 | Immutability模式：如何利用不变性解决并发问题？","id":92856},"right":{"article_title":"30 | 线程本地存储模式：没有共享，就没有伤害","id":93745}},"comments":[{"had_liked":false,"id":91215,"user_name":"GeekAmI","can_delete":false,"product_type":"c1","uid":1005030,"ip_address":"","ucode":"232C0B6DFB9F56","user_header":"https://static001.geekbang.org/account/avatar/00/0f/55/e6/87197b10.jpg","comment_is_top":false,"comment_ctime":1556932908,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"607147321644","product_id":100023901,"comment_content":"CopyOnWriteLinkedList的链表结构读取效率比较低，就违背了读多写少的设计初衷。","like_count":142,"discussions":[{"author":{"id":1135604,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","nickname":"bin.chen","note":"","ucode":"5BA49358AB8A1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280656,"discussion_content":"读取操作效率是相对的；链表读取不一定慢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1591587193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1655940,"avatar":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","nickname":"呆瓜","note":"","ucode":"C98C7B224D0640","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135604,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","nickname":"bin.chen","note":"","ucode":"5BA49358AB8A1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343444,"discussion_content":"数组存储在连续内存,连续内存更有利于CPU加载和缓存,特点是增删慢,读取快;\n链表数据结构存储在分散内存,特点是增删快,读取慢;\n链表结构的设计初衷就是用于增删频繁,读取少的场景;\nCopyOnWrite使用场景:要求读取性能高,读取多,修改少;\n二者设计理念相违背,所以存在CopyOnWriteArrayList,而不存在CopyOnWriteLinkedList","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1611046992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280656,"ip_address":""},"score":343444,"extra":""},{"author":{"id":1920896,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/4f/80/19f946ba.jpg","nickname":"Zain","note":"","ucode":"03EDF7B1BE9CF8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1135604,"avatar":"https://static001.geekbang.org/account/avatar/00/11/53/f4/e277325d.jpg","nickname":"bin.chen","note":"","ucode":"5BA49358AB8A1A","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377315,"discussion_content":"链表如果都读存储的头结点或者尾结点也是直接访问，所以不能一刀切","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622601694,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":280656,"ip_address":""},"score":377315,"extra":""}]},{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":8654,"discussion_content":"对于CopyOnWriteLinkedList的复制操作比较耗时。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1568032972,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1698557,"avatar":"https://static001.geekbang.org/account/avatar/00/19/ea/fd/89d3d0b5.jpg","nickname":"王昊哲","note":"","ucode":"AA2F4499BF6865","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63946,"discussion_content":"有点问题吧，链表是随机读取效率比不上数组，单独的读取，两边都是o(n),不是这个原因吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574924621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1370932,"avatar":"https://static001.geekbang.org/account/avatar/00/14/eb/34/9756d116.jpg","nickname":"一路向北","note":"","ucode":"B688B1C748D019","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370111,"discussion_content":"厉害了我的哥..>,<","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619279632,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13428,"discussion_content":"有见解，学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568653063,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1388546,"avatar":"https://static001.geekbang.org/account/avatar/00/15/30/02/fd0d4849.jpg","nickname":"西  流","note":"","ucode":"0E9BB51AEC2515","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":136,"discussion_content":"有见解哈哈👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561157747,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91474,"user_name":"假行僧","can_delete":false,"product_type":"c1","uid":1107161,"ip_address":"","ucode":"5D87225B067A20","user_header":"https://static001.geekbang.org/account/avatar/00/10/e4/d9/d74e4c61.jpg","comment_is_top":false,"comment_ctime":1557042217,"is_pvip":false,"replies":[{"id":"34447","content":"👍","user_name":"作者回复","comment_id":91474,"uid":"1269969","ip_address":"","utype":1,"ctime":1558359603,"user_name_real":"王宝令"}],"discussion_count":14,"race_medal":0,"score":"525543052329","product_id":100023901,"comment_content":"没有提供CopyOnWriteLinkedList是因为linkedlist的数据结构关系分散到每一个节点里面，对每一个节点的修改都存在竟态条件，需要同步才能保证一致性。arraylist就不一样，数组天然的拥有前驱后继的结构关系，对列表的增删，因为是copy on wirte，所以只需要cas操作数组对象就能够保证线程安全，效率上也能接受，更重要的是避免锁竞争带来的上下文切换消耗。有一点需要注意的是CopyOnWriteArrayList在使用上有数据不完整的时间窗口，要不要考虑需要根据具体场景定夺","like_count":123,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":448925,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558359603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1512642,"avatar":"https://static001.geekbang.org/account/avatar/00/17/14/c2/46ebe3a0.jpg","nickname":"侧耳倾听","note":"","ucode":"5BF2A2440B54F0","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243170,"discussion_content":"他所说的静态条件应该是数组自身具有不可变性，一旦创建不可修改。所以只需要保证对某一索引的值变更时互斥就可以了。但是链表自身结构可变，list提供了addall和clear等方法，如果对某一节点的值进行变更时，你首先需要保证链表的不可变，就需要加互斥锁","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1587526271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264431,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4b/2f/2f73fd52.jpg","nickname":"水滴s","note":"","ucode":"1C684514B54B6F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":81208,"discussion_content":"既然是copeonwrite，为什么会存在修改链表节点而导致竞态条件这种情况呢？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1576232211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1369447,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e5/67/16322a5d.jpg","nickname":"cky.宇","note":"","ucode":"93A3EAD9D50A5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1264431,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4b/2f/2f73fd52.jpg","nickname":"水滴s","note":"","ucode":"1C684514B54B6F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":82019,"discussion_content":"是的，我也没明白，COW的源数据相当于是只读的，copy时不会出现源数据被修改的情况，按理说是不会出现竞态条件。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576310674,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":81208,"ip_address":""},"score":82019,"extra":""}]},{"author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13430,"discussion_content":"有见解，学习学习","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568653196,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1339724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","nickname":"静水流深","note":"","ucode":"644F05EFBD2E7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1111870,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTK2Az5uTh9ZGVA7yQCj1BXtXuicPRkvJicA97AoN9xX3bnPcUYglTMXJeZeoVbPQeJA7ICvQhR3KQ0w/132","nickname":"日不落帝国","note":"","ucode":"6A11ABBD8AC438","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":21219,"discussion_content":"那里都有你，哈哈","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1569455048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":13430,"ip_address":""},"score":21219,"extra":""},{"author":{"id":1018620,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8a/fc/d1dd57dd.jpg","nickname":"ipofss","note":"","ucode":"DE3061C9259F9E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1339724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","nickname":"静水流深","note":"","ucode":"644F05EFBD2E7B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40538,"discussion_content":"还真是，哪里都有日不落帝国，😆","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572231775,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":21219,"ip_address":""},"score":40538,"extra":""}]},{"author":{"id":1116063,"avatar":"https://static001.geekbang.org/account/avatar/00/11/07/9f/31a32631.jpg","nickname":"勿闻轩外香","note":"","ucode":"D31BF163B7DFC0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411772,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636000999,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1565085,"avatar":"https://static001.geekbang.org/account/avatar/00/17/e1/9d/3ec0adec.jpg","nickname":"喃寻","note":"","ucode":"E31B3660726671","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":344864,"discussion_content":"厉害，学习了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611591142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2029485,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/f7/ad/4fd4d867.jpg","nickname":"数学汤家凤","note":"","ucode":"DE84E777C384AD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289846,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594225814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281615,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591777383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1331828,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/IZKGetBZDuMEa2VwwtesTELvLORIyV749ItgfAqNPv30n4zEv71wuGNr1aNVIVltG0icvH53DHDuqPuzNpiauWAg/132","nickname":"Geek_bb89c3","note":"","ucode":"0F97B5B0F2DDD6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186603,"discussion_content":"cow中在修改的时候都是加锁的，同一时刻只有一个线程能够修改。这里的竞态条件是怎么出现的呢？@假行僧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582697651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1008582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","nickname":"林肯","note":"","ucode":"D2C97220230DE5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":35095,"discussion_content":"请教下，为什么会有数据不完整的时间窗口？难道是异步拷贝的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571235565,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1008582,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/63/c6/d6ea3df3.jpg","nickname":"林肯","note":"","ucode":"D2C97220230DE5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369368,"discussion_content":"读和写不是同一个内存地址，写完后要把原来的引用指向写后的内存地址，在这期间读的都是没有修改后的值，就是这段时间窗口","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1619013147,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":35095,"ip_address":""},"score":369368,"extra":""}]}]},{"had_liked":false,"id":137430,"user_name":"Sharry","can_delete":false,"product_type":"c1","uid":1239293,"ip_address":"","ucode":"045DDB864659F6","user_header":"https://static001.geekbang.org/account/avatar/00/12/e8/fd/035f4c94.jpg","comment_is_top":false,"comment_ctime":1569739575,"is_pvip":false,"replies":[{"id":"52826","content":"👍","user_name":"作者回复","comment_id":137430,"uid":"1269969","ip_address":"","utype":1,"ctime":1569756976,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"246382875447","product_id":100023901,"comment_content":"我对课后的思考是这样的, ArrayList 是用是数组实现的, 在内存上时一块连续的区域, 拷贝时效率比较高, 时间复杂度为 O(1)<br><br>LinkedList 是链表实现, 其数据是通过指针串联起来的, 并非一块连续的区域, 拷贝时必须要进行遍历操作, 效率比较低, 时间复杂度是 O(n)","like_count":58,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":469088,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569756976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91978,"user_name":"Knight²º¹⁸","can_delete":false,"product_type":"c1","uid":1089754,"ip_address":"","ucode":"BDCB830B6A730F","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/da/4f50f1b2.jpg","comment_is_top":false,"comment_ctime":1557147424,"is_pvip":false,"discussion_count":5,"race_medal":0,"score":"203420610336","product_id":100023901,"comment_content":"很多童鞋提到了链表copy的代价，个人觉得这并不是最根本的原因。首先数组无论的新增还是删除copy是避免不了的，因此我们采用copy on write的方式在保证代价相当的前提下保证了并发的安全问题，何乐而不为呢。其次是链表的新增删除压根就不需要复制，就算是在并发场景下采用锁的方式性能损耗都不大，因此也就没必要采用copy的方式了，更何况链表的操作可以采用分段锁、节点锁。所以没有CopyOnWriteLinkedList的主要原因是没有这个必要。","like_count":48,"discussions":[{"author":{"id":1655940,"avatar":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","nickname":"呆瓜","note":"","ucode":"C98C7B224D0640","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343445,"discussion_content":"数组存储在连续内存,连续内存更有利于CPU加载和缓存,特点是增删慢,读取快;\n链表数据结构存储在分散内存,特点是增删快,读取慢;\n链表结构的设计初衷就是用于增删频繁,读取少的场景;\nCopyOnWrite使用场景:要求读取性能高,读取多,修改少;\n二者设计理念相违背,所以存在CopyOnWriteArrayList,而不存在CopyOnWriteLinkedList","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611047149,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299961,"discussion_content":"读多写少才考虑使用cow，读多写少就不该选linkedlist","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597889347,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1660321,"avatar":"","nickname":"Geek_57ffb6","note":"","ucode":"EAD6E6148BE65D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334804,"discussion_content":"正解，我觉得没大家说的那么复杂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607995153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":299961,"ip_address":""},"score":334804,"extra":""}]},{"author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":277994,"discussion_content":"读性能要求高时，LinkedList不如基于数组实现的ArrayList，所以即使实现了Copy-On-Write意义也不大，没有适用场景","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591142313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1179028,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fd/94/0247f945.jpg","nickname":"咸鱼","note":"","ucode":"5E79636DE48155","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369372,"discussion_content":"如果从后往前全量读都是o(n)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619013446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":277994,"ip_address":""},"score":369372,"extra":""}]}]},{"had_liked":false,"id":92430,"user_name":"好牙","can_delete":false,"product_type":"c1","uid":1117320,"ip_address":"","ucode":"F36A824C1AB19A","user_header":"","comment_is_top":false,"comment_ctime":1557273682,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"78866685010","product_id":100023901,"comment_content":"1.链表本身适合于顺序读和写多的场景，和cop读多写少是违背的。<br>2.链表可以锁节点，力度已经很小了。<br>3.链表整体复制的性能比数组差太多。","like_count":19},{"had_liked":false,"id":91219,"user_name":"Corner","can_delete":false,"product_type":"c1","uid":1446316,"ip_address":"","ucode":"7862D593172536","user_header":"https://static001.geekbang.org/account/avatar/00/16/11/ac/9cc5e692.jpg","comment_is_top":false,"comment_ctime":1556935085,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"65981444525","product_id":100023901,"comment_content":"数组的拷贝效率应该比链表高，一维数组是连续分配内存的，所以可以直接复制内存块就能完成拷贝。但是链表元素之间是通过引用建立连接的，所以要遍历整个链表才能完成拷贝。","like_count":15},{"had_liked":false,"id":91806,"user_name":"夏天","can_delete":false,"product_type":"c1","uid":1285986,"ip_address":"","ucode":"F29D56F9265751","user_header":"https://static001.geekbang.org/account/avatar/00/13/9f/62/960eecc3.jpg","comment_is_top":false,"comment_ctime":1557112569,"is_pvip":false,"replies":[{"id":"34452","content":"必须加，还有指令重排问题","user_name":"作者回复","comment_id":91806,"uid":"1269969","ip_address":"","utype":1,"ctime":1558361934,"user_name_real":"王宝令"}],"discussion_count":6,"race_medal":0,"score":"57391687417","product_id":100023901,"comment_content":"王老师，问一个单例模式的问题： 在双重检查加锁的单例模式中 需不需要加 volatile 关键字修饰？ 自己的理解：是需要。但是我在考虑其中的锁是不是存在happen before规则，不用加volatile也能保证可见性？","like_count":13,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449038,"discussion_content":"必须加，还有指令重排问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558361934,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304387,"discussion_content":"主要是new()操作会发生指令重排，不能保证有序性， 会出现操作null地址","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599558059,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1547667,"avatar":"https://static001.geekbang.org/account/avatar/00/17/9d/93/4159edaa.jpg","nickname":"朴素柠檬c","note":"","ucode":"2D4CBB70D801B1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1730576,"avatar":"","nickname":"27","note":"","ucode":"B5D7A54EA47206","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":326458,"discussion_content":"其实就是了解对象new()的三个过程，不是原子性的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605598560,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":304387,"ip_address":""},"score":326458,"extra":""}]},{"author":{"id":1818343,"avatar":"","nickname":"刘同青","note":"","ucode":"84B62DF8BC61FB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281617,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591777571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1013160,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/75/a8/dfe4cade.jpg","nickname":"电光火石","note":"","ucode":"3AD33BB4AA940F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":172146,"discussion_content":"是不是jdk5之后就不要了，jvm已经做了优化，不会发生逃逸","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581771441,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351066,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/9a/7f064a9f.jpg","nickname":"龙行秀","note":"","ucode":"2DA088D199EA9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":521,"discussion_content":"得看syn的锁对象，有一种写法是锁整个类感觉就不用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1561638690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":93430,"user_name":"刘鹏","can_delete":false,"product_type":"c1","uid":1524765,"ip_address":"","ucode":"48A831C5D2031C","user_header":"https://static001.geekbang.org/account/avatar/00/17/44/1d/833b3890.jpg","comment_is_top":false,"comment_ctime":1557469469,"is_pvip":false,"replies":[{"id":"33503","content":"rpc的客户端和服务提供端会建立一个长连接，定时发心跳，并不完全依赖注册中心的数据。很多rpc的服务端提供了手动下线功能，能解决你说的这个问题","user_name":"作者回复","comment_id":93430,"uid":"1269969","ip_address":"","utype":1,"ctime":1557643492,"user_name_real":"王宝令"}],"discussion_count":2,"race_medal":0,"score":"27327273245","product_id":100023901,"comment_content":"服务下线了，如果数据不一致，会不会有请求发到下线了的服务器","like_count":6,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449629,"discussion_content":"rpc的客户端和服务提供端会建立一个长连接，定时发心跳，并不完全依赖注册中心的数据。很多rpc的服务端提供了手动下线功能，能解决你说的这个问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557643492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1580185,"avatar":"https://static001.geekbang.org/account/avatar/00/18/1c/99/5e1a2118.jpg","nickname":"mylife","note":"","ucode":"D802160BFB29FC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591690,"discussion_content":"个人理解：客户端有重试功能，就算分配的已经下线，会重试选择另外的节点","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666768319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":137143,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1569635219,"is_pvip":true,"replies":[{"id":"52705","content":"👍","user_name":"作者回复","comment_id":137143,"uid":"1269969","ip_address":"","utype":1,"ctime":1569666993,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"23044471699","product_id":100023901,"comment_content":"主要是ArrayList的数据存储是数组，复制可能只需要移动一个内存页或者多个连续的内存空间就可以，而且数组在复制的时候是知道数据集的大小的(动态扩容后也还是数组，只是预先申请了一些未来使用的空间)，而LinkdList底层实现为使用Node&lt;?&gt;链表，存储位置分散且大小不可控，如果使用COW可能会适得其反。这应该也是一种用空间换时间的策略吧。这么来看，除非事先限定了数据的存储区域，不然用COW还是数组方便些吧。","like_count":5,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468956,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569666993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241612,"user_name":"与路同飞","can_delete":false,"product_type":"c1","uid":1138821,"ip_address":"","ucode":"2985F1440A1962","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","comment_is_top":false,"comment_ctime":1597370836,"is_pvip":true,"replies":[{"id":"89238","content":"👍🏻","user_name":"作者回复","comment_id":241612,"uid":"1269969","ip_address":"","utype":1,"ctime":1597413552,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"18777240020","product_id":100023901,"comment_content":"redis中的快照rdb复制也是基于COW的","like_count":4,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503789,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597413552,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91284,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1556964157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18736833341","product_id":100023901,"comment_content":"一种是通过更新 Router 的一个状态位来标识，如果这样做，那么所有访问该状态位的地方都需要同步访问，这样很影响性能。<br><br>老师好，这句话的意思没怎么看懂，我理解的是route如果下线后更新状态标识，所以每次调用的时候都需要遍历所以route节点，判断每个节点的状态来判断是否下线，所以比较消耗性能的意思吗？所以改成方法二只要下线即删除改route节点，调用的时候不需要判断，只要路由表查到即算都是上线状态。<br><br>","like_count":4},{"had_liked":false,"id":136515,"user_name":"静水流深","can_delete":false,"product_type":"c1","uid":1339724,"ip_address":"","ucode":"644F05EFBD2E7B","user_header":"https://static001.geekbang.org/account/avatar/00/14/71/4c/2cefec07.jpg","comment_is_top":false,"comment_ctime":1569462306,"is_pvip":false,"replies":[{"id":"52325","content":"😂","user_name":"作者回复","comment_id":136515,"uid":"1269969","ip_address":"","utype":1,"ctime":1569464226,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"10159396898","product_id":100023901,"comment_content":"大师好不容易写了个CopyOnWriteArrayList，再写一个CopyOnWriteLinkedList 他觉得没必要。他也累：）<br><br>","like_count":3,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468678,"discussion_content":"😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569464226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91967,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1557145971,"is_pvip":false,"replies":[{"id":"34439","content":"都有","user_name":"作者回复","comment_id":91967,"uid":"1269969","ip_address":"","utype":1,"ctime":1558358974,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"10147080563","product_id":100023901,"comment_content":"上一篇说包装类型、String 是享元模式，这篇说是Copy-on-Write，是两种模式都有吗？","like_count":2,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449098,"discussion_content":"都有","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558358974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91213,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1556931400,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10146865992","product_id":100023901,"comment_content":"LinkedList 在复制时，因为其包含前后节点地址，每个节点需要去创建，成本比较高，所以很少或者没有写时复制的Linked 结构吧","like_count":2},{"had_liked":false,"id":274524,"user_name":"呆瓜","can_delete":false,"product_type":"c1","uid":1655940,"ip_address":"","ucode":"C98C7B224D0640","user_header":"https://static001.geekbang.org/account/avatar/00/19/44/84/4da14994.jpg","comment_is_top":false,"comment_ctime":1611047004,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5906014300","product_id":100023901,"comment_content":"数组存储在连续内存,连续内存更有利于CPU加载和缓存,特点是增删慢,读取快;<br>链表数据结构存储在分散内存,特点是增删快,读取慢;<br>链表结构的设计初衷就是用于增删频繁,读取少的场景;<br>CopyOnWrite使用场景:要求读取性能高,读取多,修改少;<br>二者设计理念相违背,所以存在CopyOnWriteArrayList,而不存在CopyOnWriteLinkedList","like_count":1},{"had_liked":false,"id":195518,"user_name":"Mr.wang","can_delete":false,"product_type":"c1","uid":1224805,"ip_address":"","ucode":"86F341A5316BBC","user_header":"https://static001.geekbang.org/account/avatar/00/12/b0/65/90387745.jpg","comment_is_top":false,"comment_ctime":1585193203,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"5880160499","product_id":100023901,"comment_content":"ArrayList和LinkedList的区别就是ArrayList底层的数据结构是数组实现，而LinkedList的底层是双端链表实现。两者适宜使用的场景是，ArrayList多用于查询，而LinkedList多用于增加和删除的场景中，CopyAndWrite的使用场景主要是查询大于新增和删除的场景。","like_count":1},{"had_liked":false,"id":166082,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1577378197,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5872345493","product_id":100023901,"comment_content":"老师好，请问：如案例，正常情况下一个服务提供方应该提供多个接口，是对应多个Router对象？所以一个服务提供方上&#47;下线，应该会循环调用多次add&#47;remove方法？","like_count":1},{"had_liked":false,"id":141000,"user_name":"1620","can_delete":false,"product_type":"c1","uid":1104310,"ip_address":"","ucode":"C9222A5CE4723C","user_header":"https://static001.geekbang.org/account/avatar/00/10/d9/b6/4c498c17.jpg","comment_is_top":false,"comment_ctime":1571102080,"is_pvip":false,"replies":[{"id":"54568","content":"👍","user_name":"作者回复","comment_id":141000,"uid":"1269969","ip_address":"","utype":1,"ctime":1571113155,"user_name_real":"王宝令"}],"discussion_count":1,"race_medal":0,"score":"5866069376","product_id":100023901,"comment_content":"数组在内存地址是连续的，天然适合copy，链表是分散的。","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470647,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571113155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":101035,"user_name":"六维","can_delete":false,"product_type":"c1","uid":1022887,"ip_address":"","ucode":"EB1C15AC06A8DF","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/a7/440aff07.jpg","comment_is_top":false,"comment_ctime":1559703800,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5854671096","product_id":100023901,"comment_content":"Copy-on-Write方案是适合读多写少的场景，而LinkedList读取的性能不高，这个应该是没有提供CopyOnWriteLinkedList的主要原因。<br>","like_count":1},{"had_liked":false,"id":95421,"user_name":"污名侦探","can_delete":false,"product_type":"c1","uid":1049154,"ip_address":"","ucode":"D9C4D175E5EF7B","user_header":"https://static001.geekbang.org/account/avatar/00/10/02/42/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1558055021,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5853022317","product_id":100023901,"comment_content":" 首先CopyOnWriteLinkedList 可以做分段锁，并且性能很高。其次，复制性能没有数组来的快。","like_count":1},{"had_liked":false,"id":95199,"user_name":"Vincent","can_delete":false,"product_type":"c1","uid":1135159,"ip_address":"","ucode":"CD8B84A57A6A0C","user_header":"https://static001.geekbang.org/account/avatar/00/11/52/37/13b4c8aa.jpg","comment_is_top":false,"comment_ctime":1557983097,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5852950393","product_id":100023901,"comment_content":"既然读多写少，说明数据结构变更频率很少。那么数组结构适合这个场景，链表是适合写多的场景","like_count":1},{"had_liked":false,"id":93966,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1557678948,"is_pvip":false,"replies":[{"id":"33664","content":"感谢捧场😂","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1557756338,"ip_address":"","comment_id":93966,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5852646244","product_id":100023901,"comment_content":"Sting Long … 居然可以和CoW、Lock联系起来!<br><br>跟着老师默默修行!<br><br>希望这个专栏永远不要停!<br>能希望能一直看到老师写的专栏!","like_count":1,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449848,"discussion_content":"感谢捧场😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1557756338,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91380,"user_name":"周治慧","can_delete":false,"product_type":"c1","uid":1335293,"ip_address":"","ucode":"7D56C4E66BEE17","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","comment_is_top":false,"comment_ctime":1557019783,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5851987079","product_id":100023901,"comment_content":"本质就是数组查询块增删慢，链表增删块查询慢。copyandwrite本质就是读多写少即查询多增删少的一个过程所以数组更加合适","like_count":1},{"had_liked":false,"id":344397,"user_name":"客舟听雨来coding","can_delete":false,"product_type":"c1","uid":1026219,"ip_address":"","ucode":"753F4B779CC416","user_header":"https://static001.geekbang.org/account/avatar/00/0f/a8/ab/5d25cd32.jpg","comment_is_top":false,"comment_ctime":1651506945,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1651506945","product_id":100023901,"comment_content":"1、链表回收容易出现内存碎片，数组不那么容易；cow会导致频繁回收链表占有的内存空间，容易出现很多内存碎片。<br><br>2、链表读性能差，数组读性能高；cow模式是用于对读性能要求高的场景，不适合。","like_count":0},{"had_liked":false,"id":312607,"user_name":"cake","can_delete":false,"product_type":"c1","uid":1966533,"ip_address":"","ucode":"55A7FC6CC1204C","user_header":"https://static001.geekbang.org/account/avatar/00/1e/01/c5/b48d25da.jpg","comment_is_top":false,"comment_ctime":1631889544,"is_pvip":false,"replies":[{"id":"113649","content":"这里真不是因为延迟原因而采用的，更多处于一致性原因","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1632745299,"ip_address":"","comment_id":312607,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1631889544","product_id":100023901,"comment_content":"不是延时策略的COW 老师请问下这个标题怎么 理解呢， cow不就是延时策略么","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":527045,"discussion_content":"这里真不是因为延迟原因而采用的，更多处于一致性原因","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632745299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":300625,"user_name":"王成","can_delete":false,"product_type":"c1","uid":1441460,"ip_address":"","ucode":"29765BBCD3B8B2","user_header":"https://static001.geekbang.org/account/avatar/00/15/fe/b4/6902ac00.jpg","comment_is_top":false,"comment_ctime":1625278015,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1625278015","product_id":100023901,"comment_content":"看到大家的评论，突然想起最近工作中的一个问题，需要一个容器，支持并发，写多，有一个清空操作并返回所有值<br>发现好像可以完美的使用基于链表设计的容器","like_count":0},{"had_liked":false,"id":291575,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1620371561,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620371561","product_id":100023901,"comment_content":"CopyOnWriteLinkedList是链表结构的，链表的特性，增删快查询慢。<br>而Copy-on-Write的场景是读多写少，也就是查询快的，所以arrayList数组结构比较适合","like_count":0},{"had_liked":false,"id":284215,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1616124046,"is_pvip":true,"replies":[{"id":"103114","content":"👍🏻","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1616156587,"ip_address":"","comment_id":284215,"utype":1}],"discussion_count":1,"race_medal":2,"score":"1616124046","product_id":100023901,"comment_content":"Redis 的 bgsave 过程也采用了 COW 模式：子进程生成 rdb 快照的过程中，如果主进程修改了某份数据，那么这份数据会生成一份副本，子进程会把这个副本写入 rdb 快照中。这样基于 COW 模式，保证了Redis 在生成 rdb 快照的过程中仍然能够提供写服务。","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517271,"discussion_content":"👍🏻","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616156587,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283160,"user_name":"俺能学个啥","can_delete":false,"product_type":"c1","uid":1026742,"ip_address":"","ucode":"30740C5B58774C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/aa/b6/46a5bbf3.jpg","comment_is_top":false,"comment_ctime":1615601252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615601252","product_id":100023901,"comment_content":"选用链表的前提就是考虑读少写多的场景，而COW是为了应对读多写少，二者理念相违背","like_count":0},{"had_liked":false,"id":272242,"user_name":"prepared","can_delete":false,"product_type":"c1","uid":1194853,"ip_address":"","ucode":"00E54A5C7CDCBE","user_header":"https://static001.geekbang.org/account/avatar/00/12/3b/65/3a4fc8cf.jpg","comment_is_top":false,"comment_ctime":1610003011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610003011","product_id":100023901,"comment_content":"为什么没有提供 CopyOnWriteLinkedList ？<br>因为要适用 读多写少的 场景，读取性能要求高。<br>而链表读取的性能不高，无法随机读取","like_count":0},{"had_liked":false,"id":269427,"user_name":"worm","can_delete":false,"product_type":"c1","uid":1504178,"ip_address":"","ucode":"9B4F745BC44740","user_header":"https://static001.geekbang.org/account/avatar/00/16/f3/b2/1ce2ae4d.jpg","comment_is_top":false,"comment_ctime":1608642544,"is_pvip":false,"replies":[{"id":"98587","content":" CopyOnWriteArraySet在修改的时候会自动复制","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1609844716,"ip_address":"","comment_id":269427,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608642544","product_id":100023901,"comment_content":"增加路由的那个方法感觉好像有问题，每次都会new CopyOnWriteArraySet,但是没有把原来CopyOnWriteArraySet里的值复制进去，只是单独增加了一个新router啊，还是我理解有误","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512269,"discussion_content":" CopyOnWriteArraySet在修改的时候会自动复制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609844716,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":253751,"user_name":"夜涛","can_delete":false,"product_type":"c1","uid":1507783,"ip_address":"","ucode":"672CC53663710B","user_header":"https://static001.geekbang.org/account/avatar/00/17/01/c7/549b5616.jpg","comment_is_top":false,"comment_ctime":1602853192,"is_pvip":true,"replies":[{"id":"92724","content":"������������","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1602910916,"ip_address":"","comment_id":253751,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1602853192","product_id":100023901,"comment_content":"LinkedList分配的内存不连续，读写操作性能不高，ArrayList复制一次复制一个地址块，那么LinkedList就要复制N个，还要一个个去找，不适合并发场景","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":507166,"discussion_content":"������������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602910916,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":250338,"user_name":"与路同飞","can_delete":false,"product_type":"c1","uid":1138821,"ip_address":"","ucode":"2985F1440A1962","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/85/f72f1d94.jpg","comment_is_top":false,"comment_ctime":1601030004,"is_pvip":true,"replies":[{"id":"92658","content":"因为读更快吧","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1602845844,"ip_address":"","comment_id":250338,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1601030004","product_id":100023901,"comment_content":"老师好。好多开源项目这样写。我知道是基于COW，Map&lt;String, Object&gt; newMap = new HashMap&lt;&gt;(oldMap.size() + 1);<br>newMap.putAll(oldMap);<br>oldMap = newMap。但是为啥不用concurrentHashMap呢","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506190,"discussion_content":"因为读更快吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602845844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234804,"user_name":"THROW","can_delete":false,"product_type":"c1","uid":1112141,"ip_address":"","ucode":"A3C089A8F5F941","user_header":"https://static001.geekbang.org/account/avatar/00/10/f8/4d/4b748ff1.jpg","comment_is_top":false,"comment_ctime":1594799837,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1594799837","product_id":100023901,"comment_content":"Router的例子，如果线程A先读取了Set&lt;Router&gt;的大小并进行遍历，这时线程B remove了一个元素，那线程A不是就报数组下标越界异常了？","like_count":0},{"had_liked":false,"id":224252,"user_name":"sky","can_delete":false,"product_type":"c1","uid":1008071,"ip_address":"","ucode":"9FE5F43055D3AB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/61/c7/b64ac05e.jpg","comment_is_top":false,"comment_ctime":1591323843,"is_pvip":false,"replies":[{"id":"82610","content":"路由表有遍历操作，不仅仅是读期中一个元素","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1591414444,"ip_address":"","comment_id":224252,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1591323843","product_id":100023901,"comment_content":"有个疑问，对于路由表场景，实时性要求不高，那么用普通的hashset 是会有并发写的问题么？如果是只对写加个锁是不是就可以了，也不用复制元素，读不加锁，性能会差么？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497413,"discussion_content":"路由表有遍历操作，不仅仅是读期中一个元素","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591414444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214446,"user_name":"man1s","can_delete":false,"product_type":"c1","uid":1466953,"ip_address":"","ucode":"FFDB6B52F65A1B","user_header":"https://static001.geekbang.org/account/avatar/00/16/62/49/6332c99b.jpg","comment_is_top":false,"comment_ctime":1588750991,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588750991","product_id":100023901,"comment_content":"好多的资料上说cow都只说副本怎么出来的，可是这个副本修改后会不会merge到原数据上，比如当子进程kill之后","like_count":0},{"had_liked":false,"id":204292,"user_name":"女巫在寒江","can_delete":false,"product_type":"c1","uid":1013180,"ip_address":"","ucode":"B3707072224C1C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/75/bc/664bbdf7.jpg","comment_is_top":false,"comment_ctime":1586360634,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1586360634","product_id":100023901,"comment_content":"CopyOnWrite大多是用于读多写少，对读性能要求比较高的场景；CopyOnWriteArrayList可以满足随机读取，最好的时间复杂度为O(1)，  CopyOnWriteLinkedList则需遍历才能读取，时间复杂度为O(n)","like_count":0},{"had_liked":false,"id":200651,"user_name":"厉害了我的国","can_delete":false,"product_type":"c1","uid":1052191,"ip_address":"","ucode":"CD0A54A1B998AA","user_header":"https://static001.geekbang.org/account/avatar/00/10/0e/1f/d0472177.jpg","comment_is_top":false,"comment_ctime":1585629322,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585629322","product_id":100023901,"comment_content":"链表不连续，底层拷贝慢","like_count":0},{"had_liked":false,"id":176434,"user_name":"三年过后","can_delete":false,"product_type":"c1","uid":1283157,"ip_address":"","ucode":"5E9106C5F11BED","user_header":"https://static001.geekbang.org/account/avatar/00/13/94/55/afc64956.jpg","comment_is_top":false,"comment_ctime":1581060252,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581060252","product_id":100023901,"comment_content":"CopyOnWriteLinkedList 显然底层是通过链表实现。链表存储的数据结构是零散的，对于cpu缓存是不友好的，在读多写少的场景下，影响读性能的容器集合，也就没有开放的意义。","like_count":0},{"had_liked":false,"id":163809,"user_name":"LoveDlei","can_delete":false,"product_type":"c1","uid":1102916,"ip_address":"","ucode":"68065848DF518B","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/44/ec084136.jpg","comment_is_top":false,"comment_ctime":1576805521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576805521","product_id":100023901,"comment_content":"COW思想是否可以在多线程下不使用锁保证hashmap线程安全？","like_count":0},{"had_liked":false,"id":159453,"user_name":"亮","can_delete":false,"product_type":"c1","uid":1031695,"ip_address":"","ucode":"4F8B9F5ABA2D52","user_header":"https://static001.geekbang.org/account/avatar/00/0f/be/0f/82db5e65.jpg","comment_is_top":false,"comment_ctime":1575626641,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1575626641","product_id":100023901,"comment_content":"请问下，RouterTable这个类，线程安全吗？感觉remove方法不安全","like_count":0,"discussions":[{"author":{"id":1335293,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKR3ibELhjgVicCNShZCBwvaDxibnzibggG4wUzVkS2mkDxUBZyIs87nDEdJ7PiahJBVoZcuhQ84RxAziag/132","nickname":"周治慧","note":"","ucode":"7D56C4E66BEE17","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161011,"discussion_content":"这个地方写的是有问题的,add和remove都是线程不安全的,remove并发下就空指针异常了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580862848,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149106,"user_name":"Joker","can_delete":false,"product_type":"c1","uid":1156592,"ip_address":"","ucode":"126AF848001A1E","user_header":"https://static001.geekbang.org/account/avatar/00/11/a5/f0/8648c464.jpg","comment_is_top":false,"comment_ctime":1573142010,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1573142010","product_id":100023901,"comment_content":"举个例子，如果我们需要进行一次增加，比如在某个位置增加某给值。<br>如果是数组的话，我们需要进行数据搬移操作，这无疑需要涉及到整个数组别的位置的操作，如果你是在第一个位置插入，那么就要搬移整个数组了。<br>这样一来但凡有插入操作，要么锁住整个数组；要么用COW策略。显然，锁住整个数组，效率就很低了，因为连读都需要获取锁才行。那么就要继续用COW了，起码读的时候不用锁。<br>那么如果是链表的话，只需要知道前后节点就行了，不会涉及链表别的位置的节点搬移等操作。所以可以用节点锁，或者分段锁就行了。用不着COW来搞定。","like_count":0},{"had_liked":false,"id":104036,"user_name":"Jxin","can_delete":false,"product_type":"c1","uid":1251111,"ip_address":"","ucode":"4C03928388C413","user_header":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","comment_is_top":false,"comment_ctime":1560597522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1560597522","product_id":100023901,"comment_content":"前者一块大内存，后者一堆小内存。复制时申请内存的次数差距悬殊。另外后者元素的剔除通常伴随内存的回收。老链表实例的回收会伴随大量内存块的回收操作。一句话，成本太高，干脆不要。","like_count":0},{"had_liked":false,"id":95042,"user_name":"Geek_bbbda3","can_delete":false,"product_type":"c1","uid":1504651,"ip_address":"","ucode":"737394CE472C21","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKNDKOCoZvCqoYVM1t97Q77QPLmRBGvOLYzFsh8073RicycoIuwGrIsCXpAFEyVBOxcyE3Ih1mr6Vw/132","comment_is_top":false,"comment_ctime":1557963756,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557963756","product_id":100023901,"comment_content":"链表读操作时间复杂度高，用copy on write 也解决不了这个问题，天生不适合读多场景。","like_count":0},{"had_liked":false,"id":93967,"user_name":"多襄丸","can_delete":false,"product_type":"c1","uid":1074310,"ip_address":"","ucode":"1AA1497C5A293C","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/86/f5a9403a.jpg","comment_is_top":false,"comment_ctime":1557679029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557679029","product_id":100023901,"comment_content":"COWLibkedList 违背了 读多写少 读高效的初衷了哇","like_count":0},{"had_liked":false,"id":93429,"user_name":"刘鹏","can_delete":false,"product_type":"c1","uid":1524765,"ip_address":"","ucode":"48A831C5D2031C","user_header":"https://static001.geekbang.org/account/avatar/00/17/44/1d/833b3890.jpg","comment_is_top":false,"comment_ctime":1557469355,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557469355","product_id":100023901,"comment_content":"一种策略","like_count":0},{"had_liked":false,"id":92528,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1557292385,"is_pvip":false,"replies":[{"id":"34440","content":"好像没这么简单","user_name":"作者回复","user_name_real":"王宝令","uid":"1269969","ctime":1558359001,"ip_address":"","comment_id":92528,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1557292385","product_id":100023901,"comment_content":"请问一下老师copyonwrite如果与volatile结合使用是不是就可以实现强一致性了？","like_count":0,"discussions":[{"author":{"id":1269969,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/d1/8efa89ab.jpg","nickname":"王宝令","note":"","ucode":"4FE19F5BC32FCA","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":449302,"discussion_content":"好像没这么简单","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1558359001,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":91601,"user_name":"张天屹","can_delete":false,"product_type":"c1","uid":1477612,"ip_address":"","ucode":"8BD6BD6DCF0F4F","user_header":"https://static001.geekbang.org/account/avatar/00/16/8b/ec/dc03f5ad.jpg","comment_is_top":false,"comment_ctime":1557058903,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557058903","product_id":100023901,"comment_content":"写时复制用空间换时间，如果频繁写则会新建很多数组对象。数组结构写慢读快，链表结写快读慢。适用于CopyOnWrite的读多写少场景肯定就不适合链表结构了。","like_count":0},{"had_liked":false,"id":91398,"user_name":"Mr.Wood","can_delete":false,"product_type":"c1","uid":1482206,"ip_address":"","ucode":"348E13CFCEDC3D","user_header":"https://static001.geekbang.org/account/avatar/00/16/9d/de/1b946a63.jpg","comment_is_top":false,"comment_ctime":1557025254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1557025254","product_id":100023901,"comment_content":"数组结构在内存中是连续的，而链表结构是非连续的。写操作的速度不可同日而语","like_count":0},{"had_liked":false,"id":91385,"user_name":"木卫六","can_delete":false,"product_type":"c1","uid":1199495,"ip_address":"","ucode":"D113DF578C5BF5","user_header":"https://static001.geekbang.org/account/avatar/00/12/4d/87/57236a2d.jpg","comment_is_top":false,"comment_ctime":1557021069,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1557021069","product_id":100023901,"comment_content":"linkedlist应用场景是写多读少的，copyonwritelinkedlist会有很多问题：<br>需要全部一个个遍历，而不是复制一整块内存，复制性能低下；<br>头节点以后的节点在替换头节点指针时不可控，出现数据不更新的情况，可能就需要锁机制来解决<br>","like_count":0},{"had_liked":false,"id":91311,"user_name":"ban","can_delete":false,"product_type":"c1","uid":1034204,"ip_address":"","ucode":"E523CE97E48266","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c7/dc/9408c8c2.jpg","comment_is_top":false,"comment_ctime":1556975720,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556975720","product_id":100023901,"comment_content":"老师，这是路由表，上下线由该route节点自己处理的吗，比如说routeA节点上线，自己调用RouteTable.add(routeA)添加，routeA下线自己调用RouteTable.remove(routeA)，这样吗？","like_count":0},{"had_liked":false,"id":91253,"user_name":"晓杰","can_delete":false,"product_type":"c1","uid":1441546,"ip_address":"","ucode":"1174C88EEBF8A6","user_header":"https://static001.geekbang.org/account/avatar/00/15/ff/0a/12faa44e.jpg","comment_is_top":false,"comment_ctime":1556954269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556954269","product_id":100023901,"comment_content":"LinkedList本身适用于写多读少的场景，而copy-on-write模式适用于读多写少的场景，两者适用场景相反。","like_count":0},{"had_liked":false,"id":91252,"user_name":"君哥聊技术","can_delete":false,"product_type":"c1","uid":1325816,"ip_address":"","ucode":"2C9A22BCE4C79E","user_header":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","comment_is_top":false,"comment_ctime":1556953269,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556953269","product_id":100023901,"comment_content":"    数组在操作系统占用一块连续的内存空间，拷贝时只要寻找一块相同大小的内存空间进行复制，程序中用system.arraycopy就可以<br>     链表的存储空间是不连续的，需要依次遍历链表中每一个节点，进行拷贝，效率低下","like_count":0},{"had_liked":false,"id":91206,"user_name":"袁阳","can_delete":false,"product_type":"c1","uid":1329594,"ip_address":"","ucode":"B397F760CDC53A","user_header":"https://static001.geekbang.org/account/avatar/00/14/49/ba/02742d56.jpg","comment_is_top":false,"comment_ctime":1556928647,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1556928647","product_id":100023901,"comment_content":"思考题:<br>如果列表数据很多，CopyonwritelinkedList 相对于CopyonwriteArrayList来说，在复制的时候需要多次的new 链表节点，内存的分配次数比后者多很多。<br>一是分配内存需要时间，二是大量分配内存容易让jvm产生gc，导致stop the world。<br>总的来说，就是数据量比较大的时候，前者性能比较差","like_count":0}]}