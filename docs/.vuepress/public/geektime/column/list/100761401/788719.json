{"id":788719,"title":"24｜标记和回收：完成对象的搬移以整理内存","content":"<p>你好，我是海纳。</p><p>第 22 课我给你介绍了垃圾回收的基本算法原理，第23课我们通过修改代码实现了在堆中分配虚拟机对象的功能，从而把所有的对象都放置在堆里。</p><p>然而，这些工作实际上只完成了垃圾回收器一半的工作。除了可以分配空间，垃圾回收器还有一个重要功能是回收空间。复制算法是通过把存活对象搬到幸存者空间（Survivor Space）来实现空间回收功能的。所以这一节课，我们就重点实现<strong>搬移存活对象</strong>的功能。</p><h2>搬移对象</h2><p>最适合完成搬移对象功能的结构就是<strong>访问者模式</strong>。我们定义一个 ScavengeOopClosure 类，它在访问每一个堆内的对象时，就可以完成对象的搬移和指针修改。</p><pre><code class=\"language-c++\">// [memory/heap.cpp]\nvoid Heap::copy_live_objects() {\n    ScavengeOopClosure(eden, survivor, metaspace).scavenge();\n}\n\n// [memory/oopClosure.hpp]\nclass OopClosure {\npublic:\n    virtual void do_oop(HiObject** obj) = 0;\n\n    virtual void do_array_list(ArrayList&lt;Klass*&gt;** alist) = 0;\n    virtual void do_array_list(ArrayList&lt;HiObject*&gt;** alist) = 0;\n    virtual void do_array_list(ArrayList&lt;HiString*&gt;** alist) = 0;\n\n    virtual void do_map(Map&lt;HiObject*, HiObject*&gt;** amap) = 0;\n    virtual void do_raw_mem(char** mem, int length) = 0;\n    virtual void do_klass(Klass** k) = 0;\n};\n\nclass ScavengeOopClosure : public OopClosure {\nprivate:\n    Space* _from;\n    Space* _to;\n    Space* _meta;\n\n    Stack&lt;HiObject*&gt;* _oop_stack;\n\n    HiObject* copy_and_push(HiObject* obj);\n\npublic:\n    ScavengeOopClosure(Space* from, Space* to, Space* meta);\n    virtual ~ScavengeOopClosure();\n\n    virtual void do_oop(HiObject** oop);\n\n    virtual void do_array_list(ArrayList&lt;Klass*&gt;** alist);\n    virtual void do_array_list(ArrayList&lt;HiObject*&gt;** alist);\n    virtual void do_array_list(ArrayList&lt;HiString*&gt;** alist);\n\n    template &lt;typename T&gt;\n    void do_array_list_nv(ArrayList&lt;T&gt;** alist);\n\n    virtual void do_map(Map&lt;HiObject*, HiObject*&gt;** amap);\n    virtual void do_raw_mem(char** mem, int length);\n    // CAUTION : we do not move Klass, because they locate at MetaSpace.\n    virtual void do_klass(Klass** k);\n\n    void scavenge();\n    void process_roots();\n};\n</code></pre><!-- [[[read_end]]] --><p>这段代码定义了 ScavengeOopClosure 和它的父类 OopClosure。我们来回忆一下访问者模式，OopClosure 是访问者的接口类，所以里面定义的方法都是纯虚方法。</p><p>ScavengeOopClosure 是访问者的具体实现类，针对不同的被访问者提供了具体的访问方法。如果对象是 HiObject，就使用 do_oop 进行访问，如果对象是 Map，就使用 do_map  进行访问。</p><p>当然，具体实现类不仅仅是 ScavengeOopClosure 这一种，我们也可以通过继承 OopClosure 实现其他的 GC 算法，例如标记清除和标记压缩等。</p><p>ScavengeOopClosure 中的 _from 指针和 _to 指针，在第 22 课我们分析算法理论的时候就已经介绍过了，它们本质上只是 survivor space 和 eden space 的别名。_meta 就是 MetaSpace。</p><p>_oop_stack 是为了实现非递归的深度优先搜索而引入的。注意它的类型是 Stack，而没有使用已知的 ArrayList，或者是 HiList。</p><p>之前 Frame 对象中的操作数栈，我们就是使用了 HiList，为什么这里还要再实现一个 Stack 呢？因为无论是 HiList 还是 ArrayList，它们都是在堆里分配的，当 GC 在执行的时候，很难保证堆中的对象不受影响。所以，最简单的做法是 GC 需要使用的数据结构在堆外创建，<strong>保证在 GC 进行的过程中不在堆内分配空间。</strong></p><p>Stack 的实现也非常简单，接口只有 push、pop 等几个，数量不多，没有动态扩展容量、查找等其他功能。当然，在一个真实场景中运行的虚拟机，栈结构动态扩容的功能是必备的，作为示例，这里我们就只提供一个最简实现。你可以看一下具体的实现代码。</p><pre><code class=\"language-c++\">template&lt;typename V&gt;\nclass Stack {\nprivate:\n    V* vector;\n    int _capacity;\n    int _length;\n\npublic:\n    Stack(int n = 16) {\n        _capacity = n;\n        vector = new V[n];\n        _length = 0;\n    }\n\n    ~Stack() {\n        delete[] vector;\n        _capacity = 0;\n        _length = 0;\n    }\n\n    void push(V v);\n\n    V pop() {\n        return vector[--_length];\n    }\n\n    V top() {\n        return vector[_length - 1];\n    }\n\n    V peek(int index) {\n        return vector[_length - index - 1];\n    }\n\n    int capacity() {\n        return _capacity;\n    }\n\n    int length() {\n        return _length;\n    }\n\n    bool empty() {\n        return _length == 0;\n    }\n\n    void copy(const Stack&lt;V&gt;* stack);\n\n    void oops_do(OopClosure* f);\n};\n</code></pre><p>scavenge 方法是整个 GC 算法的入口，是开始的地方。这个方法分两步，第一步是处理根集合。第二步是以根集合为起始，遍历整个堆中的所有存活对象。我们先来讨论一下如何处理根集合。</p><h2>处理根集合（roots）</h2><p>根集合 roots 是所有不在堆里指向堆内对象的引用的集合。</p><pre><code class=\"language-c++\">void ScavengeOopClosure::scavenge() {\n&nbsp; &nbsp; // step 1, mark roots\n&nbsp; &nbsp; process_roots();\n\n&nbsp; &nbsp; // step2, process all objects;\n&nbsp; &nbsp; while (!_oop_stack-&gt;empty()) {\n&nbsp; &nbsp; &nbsp; &nbsp; _oop_stack-&gt;pop()-&gt;oops_do(this);\n&nbsp; &nbsp; }\n}\n</code></pre><p>到目前为止，有哪些引用是 roots 里的呢？</p><p>首先，Universe 中的 HiTrue、HiFalse 等全局对象指针肯定属于 roots，同理，StringTable 中定义的字符串也可以看做是全局对象，它们也是 roots 集合中的。</p><p>另外，最重要根引用位于程序栈上，也就是 Interpreter 中使用的 Frame 对象，其中记录的局部变量表、全局变量表、操作数栈等，都有可能是一个普通的 HiObject 对象的引用，这些都属于 roots 集合。</p><pre><code class=\"language-c++\">void ScavengeOopClosure::process_roots() {\n&nbsp; &nbsp; Universe::oops_do(this);\n&nbsp; &nbsp; Interpreter::get_instance()-&gt;oops_do(this);\n&nbsp; &nbsp; StringTable::get_instance()-&gt;oops_do(this);\n}\n\n// [runtime/universe]\nclass Universe {\npublic:\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; static CodeObject* main_code;\n};\n\nCodeObject* Universe::main_code = NULL;\n\nvoid Universe::oops_do(OopClosure* closure) {\n&nbsp; &nbsp; closure-&gt;do_oop((HiObject**)&amp;HiTrue);\n&nbsp; &nbsp; closure-&gt;do_oop((HiObject**)&amp;HiFalse);\n&nbsp; &nbsp; closure-&gt;do_oop((HiObject**)&amp;HiNone);\n\n&nbsp; &nbsp; closure-&gt;do_oop((HiObject**)&amp;main_code);\n&nbsp; &nbsp; closure-&gt;do_array_list(&amp;klasses);\n}\n\n// [main.cpp]\nint main(int argc, char** argv) {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; Universe::genesis();\n&nbsp; &nbsp; BufferedInputStream stream(argv[1]);\n&nbsp; &nbsp; BinaryFileParser parser(&amp;stream);\n&nbsp; &nbsp; Universe::main_code = parser.parse();\n&nbsp; &nbsp; Universe::heap-&gt;gc();\n\n&nbsp; &nbsp; Interpreter::get_instance()-&gt;run(Universe::main_code);\n\n&nbsp; &nbsp; return 0;\n}\n</code></pre><p>我们先来分析 Universe 的 oops_do 方法。</p><p>第一个需要注意的点是 CodeObject。我们知道 CodeObject 也继承自 HiObject，为了能让回收器正确地维护它，可以在 Universe 类里把它引用起来。就像代码里展示的那样，在 Universe 中增加声明和定义，在 main 方法里增加初始化。</p><p>第二，Universe 的 oops_do 是典型的访问者模式的实现，它接受一个访问者基类类型的对象作为参数，然后对自己所引用的每一个对象，都调用访问者的访问方法，也就是 do_XXX 方法。</p><p>访问者模式的优点再一次展现得淋漓尽致，访问者对于被访问者的内部结构完全不必知情，访问动作的具体实现完全由被访问者决定。由于 Universe 对自己引用了哪些对象十分清楚，所以在 oops_do 中，它分别对这些对象调用了相应类型的 do_XXX 方法。</p><p>搞清楚了这个基本的结构，我们再来分析 do_XXX 方法是如何实现的。你看一下我给出的代码。</p><pre><code class=\"language-c++\">void ScavengeOopClosure::do_oop(HiObject** oop) {\n&nbsp; &nbsp; if (oop == NULL || *oop == NULL)\n&nbsp; &nbsp; &nbsp; &nbsp; return;\n\n&nbsp; &nbsp; // this oop has been handled, since it may be\n&nbsp; &nbsp; // refered by Klass\n&nbsp; &nbsp; if(!_from-&gt;has_obj((char*)*oop))\n&nbsp; &nbsp; &nbsp; &nbsp; return;\n\n&nbsp; &nbsp; (*oop) = copy_and_push(*oop);\n}\n\nHiObject* ScavengeOopClosure::copy_and_push(HiObject* obj) {\n&nbsp; &nbsp; char* target = obj-&gt;new_address();\n&nbsp; &nbsp; if (target) {\n&nbsp; &nbsp; &nbsp; &nbsp; return (HiObject*)target;\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; // copy\n&nbsp; &nbsp; size_t size = obj-&gt;size();\n&nbsp; &nbsp; target = (char*)_to-&gt;allocate(size);\n&nbsp; &nbsp; memcpy(target, obj, size);\n&nbsp; &nbsp; obj-&gt;set_new_address(target);\n&nbsp; &nbsp;&nbsp;\n&nbsp; &nbsp; // push\n&nbsp; &nbsp; _oop_stack-&gt;push((HiObject*)target);\n\n&nbsp; &nbsp; return (HiObject*)target;\n}\n</code></pre><p>do_oop 的逻辑除了一些必要的检查之外，就是调用了 copy_and_push 方法。并且把这次调用的返回值更新到 (*oop) 的位置去。</p><p>如图所示，图中展示了对象 A 从 eden 空间复制到 survivor 空间以后，(*oop) 处的指针将会指向新空间中的对象 A’。</p><p><img src=\"https://static001.geekbang.org/resource/image/84/d2/84e537f2afd291719daea44f11f8dfd2.png?wh=1918x810\" alt=\"图片\"></p><p>copy_and_push 这个方法主要做了三件事情。</p><p>第一，检查该对象是否已经被搬到 to 空间中了，如果已经被搬的话，那么老的位置就会留下 forwarding 指针。如果 forwarding 不为空，那就直接返回 forwarding 指针。</p><p>第二，如果该对象没有被搬到 to 空间中，就进行复制操作（第 20 至第 23 行），先取得要搬移对象的大小，然后在 to 空间中申请这样一块内存，再使用 memcpy 把对象从 from 空间搬到 to 空间中，最后把新的地址留在老的对象上。</p><p>第三，就是把这个已经搬移完的对象放到 _oop_stack 中。在深度优先搜索算法里，人们经常使用三种不同的颜色表示三种类型的结点，如果完全未被访问，就使用白色表示；如果自己已经被处理完，但是它对其他对象的引用还未被处理，就使用灰色表示，代表尚未扩展；如果自己已经被复制，并且它对其他对象的所有引用也被处理完，就使用黑色表示。</p><p>显然，在 _oop_stack 里的对象就是刚刚提到的灰色对象。</p><p>这段代码中使用了 HiObject 的 size 和 new_address 方法，我们来看下它们的具体实现。</p><pre><code class=\"language-c++\">class HiObject {\nprivate:\n&nbsp; &nbsp; long&nbsp; &nbsp; _mark_word;\n&nbsp; &nbsp; Klass*&nbsp; _klass;\n&nbsp; &nbsp; HiDict* _obj_dict;\n\npublic:\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; // interfaces for GC.\n&nbsp; &nbsp; void oops_do(OopClosure* closure);\n&nbsp; &nbsp; size_t size();\n&nbsp; &nbsp; char* new_address();\n&nbsp; &nbsp; void set_new_address(char* addr);\n};\n\nchar* HiObject::new_address() {\n&nbsp; &nbsp; if ((_mark_word &amp; 0x2) == 0x2)\n&nbsp; &nbsp; &nbsp; &nbsp; return (char*)(_mark_word &amp; ((long)-8));\n\n&nbsp; &nbsp; return NULL;\n}\n\nvoid HiObject::set_new_address(char* addr) {\n&nbsp; &nbsp; if (!addr)\n&nbsp; &nbsp; &nbsp; &nbsp; return;\n\n&nbsp; &nbsp; _mark_word = ((long)addr) | 0x2;\n}\n\nsize_t HiObject::size() {\n&nbsp; &nbsp; return klass()-&gt;size();\n}\n</code></pre><p>请注意，我们在 HiObject 中增加了一个名为 _mark_word 的属性，而且把它放在了 HiObject 定义的开始位置，也就是偏移为 0 的位置。</p><p>在 HiObject 中添加一个域，意味着它的所有子类就都有这个域了，所以对于整型、字符串、列表、字典等类型，它们也可以使用 copy_and_push 这个方法进行复制回收。</p><p>set_new_address 方法（第 23 至 27 行）中，并没有直接把新的地址赋值给 _mark_word，而是把地址与 2 做了二进制或运算以后，再赋值。这样做是为了区分 forwarding 指针。在实现堆的时候，我们强调了对齐的问题，当时提到对齐可以保证每个对象都是 8 字节对齐的，这就决定了指向它们的指针的低 3 位就一定是 0，所以这里把从低位开始的第 2 位，置为 1 用来表示当前对象已经被搬移到了新地址。</p><p>同样的道理，在 new_address 方法中，如果发现了当前的 forwarding 不为空，就需要把这个指针的低 3 位重新置为 0，也就是和 -8 进行与操作。只有这样才能拿到新空间中相应对象的正确地址。</p><p>在代码的最后，实现了 size 方法，这个方法必须得正确实现，然后复制才能正确执行。与 HiObject 上定义的 add、sub、print 等操作类似，我们把这个明显需要多态实现的方法转移到 klass 里去了。你可以看一下相应的代码。</p><pre><code class=\"language-c++\">class Klass {\npublic:\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; virtual size_t size();\n};\n\nsize_t IntegerKlass::size() {\n&nbsp; &nbsp; return sizeof(HiInteger);\n}\n\nsize_t DictKlass::size() {\n&nbsp; &nbsp; return sizeof(HiDict);\n}\n....\n</code></pre><p>在 Klass 里定义虚方法 size，然后为每一个可能被复制的类型实现它的 size 方法就可以了。这个动作很简单，但比较烦琐，因为要为所有的类型添加 size 方法。一旦某个类型没有实现，那么在执行垃圾回收的过程中，它就不能被正确地复制。</p><p>到这里，复制一个对象，并设置它的 forwarding 指针的工作就全部完成了。这些对象对其他对象的引用还没有被处理，所以它们都在 _oop_stack 中等待进一步处理。</p><p>我们再回到 process_roots 方法中来，Universe 已经处理完了，接着就要处理 Interpreter。我们看一下 Interpreter 的 oops_do 的实现。</p><pre><code class=\"language-c++\">void Interpreter::oops_do(OopClosure* f) {\n&nbsp; &nbsp; f-&gt;do_oop((HiObject**)&amp;_builtins);\n&nbsp; &nbsp; f-&gt;do_oop((HiObject**)&amp;_ret_value);\n\n&nbsp; &nbsp; if (_frame)\n&nbsp; &nbsp; &nbsp; &nbsp; _frame-&gt;oops_do(f);\n}\n\nvoid FrameObject::oops_do(OopClosure* f) {\n&nbsp; &nbsp; f-&gt;do_oop((HiObject**)&amp;_stack);\n&nbsp; &nbsp; f-&gt;do_oop((HiObject**)&amp;_consts);\n&nbsp; &nbsp; f-&gt;do_oop((HiObject**)&amp;_names);\n\n&nbsp; &nbsp; f-&gt;do_oop((HiObject**)&amp;_locals);\n&nbsp; &nbsp; f-&gt;do_oop((HiObject**)&amp;_globals);\n&nbsp; &nbsp; f-&gt;do_oop((HiObject**)&amp;_closure);\n&nbsp; &nbsp; f-&gt;do_oop((HiObject**)&amp;_fast_locals);\n\n&nbsp; &nbsp; f-&gt;do_oop((HiObject**)&amp;_codes);\n\n&nbsp; &nbsp; if (_sender)\n&nbsp; &nbsp; &nbsp; &nbsp; _sender-&gt;oops_do(f);\n}\n\n</code></pre><p>在 Interpreter 的实例中，只有三个指向对象的引用，所以它的 oops_do 方法里就对这三个对象分别进行访问。</p><p>有一个地方是需要特别注意的，就是 <strong>FrameObject</strong>，虽然命名上它是一个 Object，但实际上它并没有继承自 HiObject。所以我们不必复制这个对象，也就是没有使用 f-&gt;do_oop 这种方式去访问 _frame。</p><p>frame 对象的引用情况下图所示，可以看到，frame 对象的 sender 并不指向堆内，但 globals、locals 等都是指向堆内的。所以，只需要直接调用 FrameObject 的 oops_do 方法即可。</p><p><img src=\"https://static001.geekbang.org/resource/image/21/e8/21592b07e25ebf61c429b7a969a273e8.png?wh=2058x784\" alt=\"图片\"></p><p>在 FrameObject 的 oops_do 方法中，OopClosure 对 FrameObject 的所有引用进行访问。当访问到 _sender 的时候，和第一次访问 FrameObject 一样，不必再使用 do_oop 进行访问，而是直接调用 _sender 的 oops_do 方法。</p><p>当 process_roots 结束以后，根对象就全部复制完了，由于它们的引用还没有完全访问完，所以它们都会被存储在 _oop_stack 中，等待被进一步处理。</p><h2>处理普通对象</h2><p>scavenge 方法的第二步，就是不断地从 _oop_stack 中取出对象，然后调用这个对象的 _oops_do 方法。</p><p>注意，由于这些对象自身是已经复制完了的，所以我们就不能再调用 OopClosure 的 do_oop 方法了，而是像程序中展示的那样，直接调用对象的 _oops_do 方法。</p><p>在 scavenge 方法中，调用 HiObject 的 _oops_do 方法时，我们不需要去管这个对象的实际类型是什么，它的实际类型会在 _oops_do 方法执行的时候自动决定。</p><pre><code class=\"language-c++\">void HiObject::oops_do(OopClosure* closure) {\n&nbsp; &nbsp; // object does not know who to visit, klass knows\n&nbsp; &nbsp; closure-&gt;do_oop((HiObject**)&amp;_obj_dict);\n&nbsp; &nbsp; klass()-&gt;oops_do(closure, this);\n}\n</code></pre><p>HiObject 的 oops_do 方法先访问了 _obj_dict，因为这是所有 HiObject 都具有的属性，所以放在 HiObject 的 oops_do 方法中是最合适的。</p><p>然后，就像注释所说，我们转而调用对象所对应的 klass 的 oops_do 方法。在不同的类型中，分别执行不同的逻辑。我们以字符串类型为例看一看。</p><pre><code class=\"language-c++\">class HiString : public HiObject {\nprivate:\n&nbsp; &nbsp; char* _value;\n&nbsp; &nbsp; int&nbsp; &nbsp;_length;\n\npublic:\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; char** value_address()&nbsp; { return &amp;_value; }\n};\n\nvoid StringKlass::oops_do(OopClosure* closure, HiObject* obj) {\n    HiString* str_obj = obj-&gt;as&lt;HiString&gt;();\n    closure-&gt;do_raw_mem(str_obj-&gt;value_address(), str_obj-&gt;length());\n}\n</code></pre><p>字符串类型有两个属性，一个是代表长度的整型，这个值已经随着字符串对象一起复制到 to 空间中了。现在所要做的，只是把代表字符串内容的 char 类型的数组也复制到 to 空间中。</p><p>对于普通的字符串数组，我们是使用 do_raw_mem 方法进行复制的。</p><pre><code class=\"language-c++\">void ScavengeOopClosure::do_raw_mem(char** mem, int length) {\n&nbsp; &nbsp; if (*mem == NULL)\n&nbsp; &nbsp; &nbsp; &nbsp; return;\n\n&nbsp; &nbsp; char* target = (char*)_to-&gt;allocate(length);\n&nbsp; &nbsp; memcpy(target, (*mem), length);\n&nbsp; &nbsp; (*mem) = target;\n}\n</code></pre><p>do_raw_mem 的逻辑仅仅是在 to 空间中分配一块内存，然后把 from 空间中的内容复制到 to 空间中。再修改引用的内容，让它指向 to 空间中的地址即可。</p><p>其它的虚拟机内建对象，如 HiInteger、HiTypeObject、HiDict 等，实现思路和 HiString 十分相似，我们就不再展开演示了，你可以自己实现。</p><h3>处理列表</h3><p>在 ScavengeOopClosure 中比较有难度的是用于访问 ArrayList 的方法，也就是 do_array_list 方法。它的难点在于，ArrayList 是一个泛型类，所以对它的访问必须十分小心。我们来看一个具体的场景。</p><pre><code class=\"language-c++\">void ScavengeOopClosure::do_array_list(ArrayList&lt;Klass*&gt;** alist) {\n&nbsp; &nbsp; do_array_list_nv&lt;Klass*&gt;(alist);\n}\n\nvoid ScavengeOopClosure::do_array_list(ArrayList&lt;HiObject*&gt;** alist) {\n&nbsp; &nbsp; do_array_list_nv&lt;HiObject*&gt;(alist);\n}\n\nvoid ScavengeOopClosure::do_array_list(ArrayList&lt;char&gt;** alist) {\n&nbsp; &nbsp; do_array_list_nv&lt;char&gt;(alist);\n}\n\ntemplate &lt;typename T&gt;\nvoid ScavengeOopClosure::do_array_list_nv(ArrayList&lt;T&gt;** alist) {\n&nbsp; &nbsp; if (alist == NULL || *alist == NULL)\n&nbsp; &nbsp; &nbsp; &nbsp; return;\n\n&nbsp; &nbsp; assert(_from-&gt;has_obj((char*)*alist));\n\n&nbsp; &nbsp; size_t size = sizeof(ArrayList&lt;T&gt;);\n&nbsp; &nbsp; char* target = (char*)_to-&gt;allocate(size);\n&nbsp; &nbsp; memcpy(target, (*alist), size);\n&nbsp; &nbsp; (*(char**)alist) = target;\n&nbsp; &nbsp; (*alist)-&gt;oops_do(this);\n}\n</code></pre><p>在这个场景下，<code>ArrayList&lt;Klass&gt;</code> 和 <code>ArrayList&lt;HiObject&gt;</code> 这两种类型的处理逻辑其实是一样的。所以最好办法是把 do_array_list 方法实现为泛型方法。但是由于<strong>C++ 中的虚方法不可以是模板方法</strong>，所以这里我采用一点小技巧做了一次转换。</p><p>首先，我们引入了 do_array_list_nv 这个泛型方法。它是一个非虚方法，结尾处的 nv 代表 non-virtual，表明这是一个非虚方法。处理对象的具体逻辑就在这个方法中实现。而处理 HiOjbect 列表和 Klass 列表的方法，则手动进行重载。这样就可以解决虚方法不可以是模板方法的问题。</p><p>do_array_list 的逻辑和 do_raw_mem 的逻辑很相似，都是在 to 空间中申请一块内存，把对象从 from 空间复制到 to 空间，并更新引用处的指针。</p><p>ArrayList 不是 HiObject，所以就没有 forwarding 机制，由于 ArrayList 基本都是作为 HiObject 对象的内部属性，只会被一个对象所引用，所以这也不会有什么问题。</p><p>do_array_list 的最后，还要调用 ArrayList 的 oops_do 方法，把 ArrayList 里所引用的对象全部拷贝到 to 空间中去。</p><pre><code class=\"language-c++\">template &lt;&gt;\nvoid ArrayList&lt;Klass*&gt;::oops_do(OopClosure* closure) {\n&nbsp; &nbsp; closure-&gt;do_raw_mem((char**)(&amp;_array),&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _length * sizeof(Klass*));\n\n&nbsp; &nbsp; for (int i = 0; i &lt; size(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; closure-&gt;do_klass((Klass**)&amp;_array[i]);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return;\n}\n\ntemplate &lt;&gt;\nvoid ArrayList&lt;HiObject*&gt;::oops_do(OopClosure* closure) {\n&nbsp; &nbsp; closure-&gt;do_raw_mem((char**)(&amp;_array),&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _length * sizeof(HiObject*));\n\n&nbsp; &nbsp; for (int i = 0; i &lt; size(); i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; closure-&gt;do_oop((HiObject**)&amp;_array[i]);\n&nbsp; &nbsp; }\n}\n</code></pre><p>在 ArrayList 中，我们除了要把数组通过 do_raw_mem 复制到 to 空间，还要再遍历数组 _array，把其中的元素都访问一遍。</p><p>需要注意的是，由于 ArrayList 类本身是一个模板类，元素类型是 Klass 指针与元素类型是 HiObject 指针，所使用的方法是不一样的（注意比较第 7 行和第 18 行）。所以我们必须使用<strong>模板偏特化</strong>的技巧来实现这两个方法。这已经是我们第二次使用模板偏特化来处理类型不相同的时候不同逻辑了，上一次是在第 15 课处理字典的遍历问题时使用的。</p><p>针对列表的垃圾回收改造完成以后，我们再来看字典的。</p><h3>处理map</h3><p>字典中所使用的 Map 类型和 ArrayList 的道理是一样的，而且更简单，因为我们只用到了一种实例的 Map，那就是 <code>Map&lt;HiObject*, HiObject*&gt;</code>。</p><pre><code class=\"language-c++\">// [memory/oopClosure.cpp]\nvoid ScavengeOopClosure::do_map(Map&lt;HiObject*, HiObject*&gt;** amap) {\n&nbsp; &nbsp; if (amap == NULL || *amap == NULL)\n&nbsp; &nbsp; &nbsp; &nbsp; return;\n\n&nbsp; &nbsp; assert(_from-&gt;has_obj((char*)*amap));\n\n&nbsp; &nbsp; size_t size = sizeof(Map&lt;HiObject*, HiObject*&gt;);\n&nbsp; &nbsp; char* target = (char*)_to-&gt;allocate(size);\n&nbsp; &nbsp; memcpy(target, (*amap), size);\n&nbsp; &nbsp; (*(char**)amap) = target;\n&nbsp; &nbsp; (*amap)-&gt;oops_do(this);\n}\n\n// [util/map.cpp]\ntemplate &lt;typename K, typename V&gt;\nvoid Map&lt;K, V&gt;::oops_do(OopClosure* closure) {\n&nbsp; &nbsp; closure-&gt;do_raw_mem((char**)(&amp;_entries),&nbsp;\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _length * sizeof(MapEntry&lt;K, V&gt;));\n&nbsp; &nbsp; for (int i = 0; i &lt; _size; i++) {\n&nbsp; &nbsp; &nbsp; &nbsp; closure-&gt;do_oop(&amp;(_entries[i]._k));\n&nbsp; &nbsp; &nbsp; &nbsp; closure-&gt;do_oop(&amp;(_entries[i]._v));\n&nbsp; &nbsp; }\n}\n</code></pre><p>这段代码的逻辑相对比较简单，你可以自己研究一下，这里就不再讲解了。</p><p>除此之外，还有处理 Klass 相关的实现，这里留给你自己动手实现，你可以拿它来练手。</p><h2>处理虚拟机栈帧中的引用</h2><p>如果在虚拟机栈帧里（即 C++ 代码所创建的栈帧）引用了堆中的对象，在这个对象的生命周期中发生了垃圾回收，这个对象的引用就没办法被正确维护。我们来看一个例子。</p><pre><code class=\"language-plain\">void FrameObject::initialize(FunctionObject* func,\n        HiList* args, HiList* kwargs) {\n    // .....\n    // 处理闭包中的cell vars\n    HiList* cells = _codes-&gt;_cell_vars;\n    if (cells &amp;&amp; cells-&gt;length() &gt; 0) {\n        _closure = HiList::new_instance();\n\n        for (int i = 0; i &lt; cells-&gt;length(); i++) {\n            _closure-&gt;append(nullptr);\n        }\n    }\n    // ...\n}\n</code></pre><p>当程序执行到第 7 行的时候，cells 变量所对应的指针会出现在 initialize 函数的栈帧，并且指向堆中。如果这时堆的空间不足以再创建一个列表，就会发生垃圾回收。</p><p>可是，由于垃圾回收器并不知道堆上还有这样一个指针，所以在进行对象搬移的时候，就会遗漏，这就是<strong>活跃对象的漏标</strong>。当垃圾回收结束以后，再访问 cells 变量的时候就会发生严重的错误，因为 cells 所指向的位置已经被垃圾回收器清空了。</p><p>为了解决这个问题，我们就需要使用一种机制，把生命周期会跨越垃圾回收的指针变量记录下来，并通知垃圾回收器及时正确地维护这个指针。为此，我们引入了 Handle 类型，以双向链表的方式把所有的指针变量记录下来。你可以看一下Handle 的定义。</p><pre><code class=\"language-c++\">class LinkedList {\nfriend class HandleMark;\nprivate:\n    LinkedList* _next;\n    LinkedList* _prev;\n\npublic:\n    LinkedList();\n\n    virtual void oops_do(OopClosure* f) = 0;\n};\n\ntemplate &lt;typename T&gt;\nclass Handle : public LinkedList {\nprotected:\n    T _value;\n\npublic:\n    Handle(T t);\n    Handle(const Handle&lt;T&gt;&amp; t);\n    ~Handle();\n\n    virtual void oops_do(OopClosure* f);\n    T operator -&gt;();\n    T operator ()() { return _value; }\n    operator T()    { return _value; }\n    void operator =(T v)  { _value = v; }\n    void operator =(Handle&lt;T&gt;&amp; v)  { _value = v(); }\n    bool operator ==(Handle&lt;T&gt;&amp; v) { return _value == v(); }\n    bool operator ==(T v)         { return _value == v; }\n    bool operator !=(Handle&lt;T&gt;&amp; v) { return _value != v(); }\n    bool operator !=(T v)         { return _value != v; }\n};\n\nclass HandleMark {\nprivate:\n    static HandleMark* instance;\n    LinkedList* _head;\n\npublic:\n    HandleMark();\n\n    static HandleMark* get_instance();\n    void oops_do(OopClosure* f);\n    LinkedList* head()           { return _head; }\n    void set_head(LinkedList* x);\n    void del_handle(LinkedList* x);\n};\n</code></pre><p>其中，Handle 的定义看上去很像一个智能指针，支持括号操作符、箭头号操作符等等。</p><p>在它的构造函数里，会把自己添加到 HandleMark 的 _head 变量所记录的双向链表中。你可以看一下它的具体实现。</p><pre><code class=\"language-c++\">void HandleMark::set_head(LinkedList* node) {\n    if (_head) {\n        _head-&gt;_prev = node;\n    }\n    node-&gt;_next = _head;\n    _head = node;\n}\n\nvoid HandleMark::del_handle(LinkedList* node) {\n    LinkedList* prev = node-&gt;_prev;\n    LinkedList* next = node-&gt;_next;\n\n    if (prev) {\n        prev-&gt;_next = next;\n    }\n\n    if (next) {\n        next-&gt;_prev = prev;\n    }\n\n    if (_head == node) {\n        _head = next;\n    }\n}\n\ntemplate&lt;typename T&gt;\nHandle&lt;T&gt;::Handle(T t) : LinkedList() {\n    _value = t;\n    HandleMark::get_instance()-&gt;set_head(this);\n}\n\ntemplate&lt;typename T&gt;\nHandle&lt;T&gt;::Handle(const Handle&lt;T&gt;&amp; t) : LinkedList() {\n    _value = t._value;\n    HandleMark::get_instance()-&gt;set_head(this);\n}\n\ntemplate&lt;typename T&gt;\nHandle&lt;T&gt;::~Handle() {\n    _value = 0x0;\n    HandleMark::get_instance()-&gt;del_handle(this);\n}\n</code></pre><p>set_head 方法的作用是把一个新的结点加入到链表中，而且每次都是添加到链表的头上。del_handle 方法则用于从双向链表中删除一个结点。这是非常常见的双向链表操作。</p><p>在 Handle 的构造函数（第 26 至 30 行）和复制构造函数（第 32 至 36 行）中，会把自己添加到双向链表。而析构函数（第 38 至 42 行）则负责从链表中删除。</p><p>最后，再通过 HandleMark 遍历链表里的所有元素，让垃圾回收器可以正确地维护 Handle 中所记录的指针。</p><pre><code class=\"language-c++\">void HandleMark::oops_do(OopClosure* f) {\n    LinkedList* cur = _head;\n    while (cur) {\n        cur-&gt;oops_do(f);\n        cur = cur-&gt;_next;\n    }\n}\n</code></pre><p>通过这种方式，虚拟机栈帧的引用就都可以被正确地维护了。最后，可以通过以下用例来测试我们这个 GC 算法的可靠性，你可以调整一下堆的大小，然后观察这个程序的输出情况以及性能变化情况。</p><pre><code class=\"language-python\">i = 0\n\nwhile i &lt; 2147482647:\n&nbsp; &nbsp; i = i + 1\n&nbsp; &nbsp; if i % 1000000 == 0:\n&nbsp; &nbsp; &nbsp; &nbsp; print i\n</code></pre><p>到这里，我们就为虚拟机实现好了 GC。这个复制算法是比较基础的，自动内存管理还有很多优秀的算法，你可以尽情地尝试实现。我们使用访问者模式构建的这一套 GC 的框架，未来扩展非常方便。</p><h2>总结</h2><p>第 23 课我们介绍了复制算法的基本步骤，这一节课就聚焦于代码实现。实现复制算法主要主要有四步。</p><ol>\n<li>处理根集合。把 Universe、FrameObject 中的引用做为根，对它们所引用的对象都进行搬移，并且把这些对象放入栈中。</li>\n<li>对栈中的对象进行非递归的深度优先遍历，从而把所有的活跃对象都搬移到新空间中去。</li>\n<li>使用 forwarding 指针解决多个对象引用同一个对象的情况。</li>\n<li>使用 Handle 记录虚拟机栈帧上的引用。</li>\n</ol><p>完成了这些步骤，垃圾回收的功能就基本完备了。</p><h2>思考题</h2><p>请你从代码实现的层面比较复制算法和引用计数法各自的优劣，欢迎你把你总结出的内容分享到评论区，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>","comments":[{"had_liked":false,"id":395525,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1731063321,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"学习打卡","like_count":0},{"had_liked":false,"id":394491,"user_name":"Geek_66a783","can_delete":false,"product_type":"c1","uid":3882146,"ip_address":"浙江","ucode":"26C66C3EACAE16","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pkjW8zleOmmWAbAMPkshJSFnDcN6d06DrYDeSIibmic2SW05Flv3ic5kLhzcHukia1Y1Ktm4OXdzYsicCnINiaCOeqQQ/132","comment_is_top":false,"comment_ctime":1726934722,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"我认为class LinkedList还可以进行进一步的抽象封装（类似于Linux kernel中提供的struct list_head），这样后续虚拟机中如果还需要添加其他基于链表的功能，就非常方便省事了。\n\n以下是我的实现：\n\n#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n\nclass LinkedList {\nprivate:\n    LinkedList* _prev;\n    LinkedList* _next;\npublic:\n    LinkedList() {\n        _prev = _next = this;\n    }\n    ~LinkedList() = default;\n    void insert_between(LinkedList* prev, LinkedList* next) {\n        assert(prev != nullptr);\n        assert(next != nullptr);\n        prev-&gt;_next = this;\n        next-&gt;_prev = this;\n        this-&gt;_prev = prev;\n        this-&gt;_next = next;\n    }\n    void add_before(LinkedList* other) {\n        assert(other != nullptr);\n        assert(other-&gt;_prev != nullptr);\n        insert_between(other-&gt;_prev, other);\n    }\n    void add_after(LinkedList* other) {\n        assert(other != nullptr);\n        assert(other-&gt;_next != nullptr);\n        insert_between(other, other-&gt;_next);\n    }\n    void del() {\n        assert(_prev != nullptr);\n        assert(_next != nullptr);\n        _prev-&gt;_next = this-&gt;_next;\n        _next-&gt;_prev = this-&gt;_prev;\n    }\n    inline LinkedList* next() {\n        return _next;\n    }\n    inline LinkedList* prev() {\n        return _prev;\n    }\n    template&lt;class T&gt;\n    inline T as() {\n        return static_cast&lt;T&gt;(this);\n    }\n};\n\nclass MyNode : public LinkedList {\npublic:\n    int value;\n    MyNode(int v) : value(v) {}\n\n};\n\nint main() {\n    LinkedList head;\n    for (int i = 0; i &lt; 10; ++i) {\n        MyNode* cur_node = new MyNode(i);\n        cur_node-&gt;as&lt;LinkedList*&gt;()-&gt;add_before(&amp;head);\n    }\n\n    LinkedList* cur = &amp;head;\n    while ((cur = cur-&gt;next()) != &amp;head) {\n        MyNode* cur_node = cur-&gt;as&lt;MyNode*&gt;();\n        std::cout &lt;&lt; cur_node-&gt;value &lt;&lt; std::endl;\n    }\n\n    cur = head.prev();\n    while (cur != &amp;head) {\n        MyNode* cur_node = cur-&gt;as&lt;MyNode*&gt;();\n        std::cout &lt;&lt; cur_node-&gt;value &lt;&lt; std::endl;\n        cur = cur-&gt;prev();\n        delete cur_node;\n    }\n}","like_count":0},{"had_liked":false,"id":394483,"user_name":"Geek_66a783","can_delete":false,"product_type":"c1","uid":3882146,"ip_address":"浙江","ucode":"26C66C3EACAE16","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pkjW8zleOmmWAbAMPkshJSFnDcN6d06DrYDeSIibmic2SW05Flv3ic5kLhzcHukia1Y1Ktm4OXdzYsicCnINiaCOeqQQ/132","comment_is_top":false,"comment_ctime":1726921560,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"直接把Universe 中的 HiTrue、HiFalse还有stringtable中的字符串常量在分配内存的时候直接放到meta区，会不会更合理？","like_count":0},{"had_liked":false,"id":394463,"user_name":"Geek_66a783","can_delete":false,"product_type":"c1","uid":3882146,"ip_address":"浙江","ucode":"26C66C3EACAE16","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/pkjW8zleOmmWAbAMPkshJSFnDcN6d06DrYDeSIibmic2SW05Flv3ic5kLhzcHukia1Y1Ktm4OXdzYsicCnINiaCOeqQQ/132","comment_is_top":false,"comment_ctime":1726851175,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"如果在python虚拟机中也引入v8那样的small integer的概念，应该就能从根本上避免文章中最后一个测试代码那样的频繁gc了吧","like_count":0}]}