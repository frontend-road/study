{"id":299494,"title":"11 | 召回层：如何快速又准确地筛选掉不相关物品？","content":"<p>你好，我是王喆。今天，我们来一起学习推荐系统中非常重要的一个模块，召回层。</p><p>为了弄清楚召回层是什么，我们先试着解决一下这个问题：<strong>如果你是一名快手的推荐工程师，你的任务是从500万个候选短视频中，为一名用户推荐10个他最感兴趣的。你会怎么做？</strong></p><p>我想最直接最暴力的做法，就是对这500万个短视频挨个打分、排序，取出得分最高的10个推荐给用户。如果这个打分的算法非常靠谱的话，我们肯定能够选出用户最感兴趣的Top 10视频。但这个过程会涉及一个非常棘手的工程问题：如果利用比较复杂的推荐模型，特别是深度学习推荐模型，对500万个短视频打分，这个过程是非常消耗计算资源的。</p><p>而且你要知道，这还只是计算了一个用户的推荐结果，在工业级的线上服务中，每秒可是有几十万甚至上百万的用户同时请求服务器，逐个候选视频打分产生的计算量，是任何集群都承受不了的。</p><p>那<strong>在推荐物品候选集规模非常大的时候，我们该如何快速又准确地筛选掉不相关物品，从而节约排序时所消耗的计算资源呢？</strong>这其实就是推荐系统召回层要解决的问题。今天，我就从三个召回层技术方案入手，带你一起来解决这个问题。</p><h2>召回层和排序层的功能特点</h2><p>在前面的课程中我提到过学习推荐系统的一个主要原则，那就是“深入细节，不忘整体”。对于召回层，我们也应该清楚它在推荐系统架构中的位置。</p><!-- [[[read_end]]] --><p>从技术架构的角度来说，“召回层”处于推荐系统的<strong>线上服务模块</strong>之中，推荐服务器从数据库或内存中拿到所有候选物品集合后，会依次经过召回层、排序层、再排序层（也被称为补充算法层），才能够产生用户最终看到的推荐列表。既然线上服务需要这么多“层”才能产生最终的结果，不同层之间的功能特点有什么区别呢？</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/6b/b1fd054eb2bbe0ec1237fc316byye66b.jpeg?wh=1920*1080\" alt=\"\" title=\"图1 推荐系统的召回和排序阶段及其特点\"></p><p>其实从这节课开头的问题出发，你应该已经对召回层和排序层的功能特点有了初步的认识，召回层就是要<strong>快速</strong>、准确地过滤出相关物品，缩小候选集，排序层则要以提升推荐效果为目标，作出精准的推荐列表排序。</p><p>再详细一点说，我们可以从候选集规模、模型复杂程度、特征数量、处理速度、排序精度等几个角度来对比召回层和排序层的特点：</p><p><img src=\"https://static001.geekbang.org/resource/image/55/7e/5535a3d83534byy54ab201e865ec4a7e.jpeg?wh=1920*386\" alt=\"\" title=\"图2 召回层和排序层的特点\"></p><p>需要注意的是，在我们设计召回层时，计算速度和召回率其实是两个矛盾的指标。怎么理解呢？比如说，为了提高计算速度，我们需要使召回策略尽量简单，而为了提高召回率或者说召回精度，让召回策略尽量把用户感兴趣的物品囊括在内，这又要求召回策略不能过于简单，否则召回物品就无法满足排序模型的要求。</p><p>推荐工程师们就是在这样的矛盾中逐渐做出新的尝试，推动着召回层的设计方案不断向前发展。下面，我们就详细学习一下三个主要的召回方法，以及它们基于SparrowRecSys的代码实现。</p><h2>如何理解“单策略召回”方法？</h2><p>你会发现，今天我多次提到一个关键字，快。那怎么才能让召回层“快”起来呢？我们知道，排序层慢的原因是模型复杂，算法计算量大，那我们能不能反其道而行之，用一些简单直观的策略来实现召回层呢？当然是可以的，这就是所谓的<strong>单策略召回</strong>。</p><p><strong>单策略召回指的是，通过制定一条规则或者利用一个简单模型来快速地召回可能的相关物品。</strong> 这里的规则其实就是用户可能感兴趣的物品的特点，我们拿SparrowRecSys里面的电影推荐为例。在推荐电影的时候，我们首先要想到用户可能会喜欢什么电影。按照经验来说，很有可能是这三类，分别是大众口碑好的、近期非常火热的，以及跟我之前喜欢的电影风格类似的。</p><p>基于其中任何一条，我们都可以快速实现一个单策略召回层。比如在SparrowRecSys中，我就制定了这样一条召回策略：如果用户对电影A的评分较高，比如超过4分，那么我们就将与A风格相同，并且平均评分在前50的电影召回，放入排序候选集中。</p><p>基于这条规则，我实现了如下的召回层：</p><pre><code>//详见SimilarMovieFlow class\npublic static List&lt;Movie&gt; candidateGenerator(Movie movie){\n    ArrayList&lt;Movie&gt; candidates = new ArrayList&lt;&gt;();\n    //使用HashMap去重\n    HashMap&lt;Integer, Movie&gt; candidateMap = new HashMap&lt;&gt;();\n    //电影movie包含多个风格标签\n    for (String genre : movie.getGenres()){\n        //召回策略的实现\n        List&lt;Movie&gt; oneCandidates = DataManager.getInstance().getMoviesByGenre(genre, 100, &quot;rating&quot;); \n        for (Movie candidate : oneCandidates){\n            candidateMap.put(candidate.getMovieId(), candidate);\n        }\n    }\n    //去掉movie本身\n    if (candidateMap.containsKey(movie.getMovieId())){\n        candidateMap.remove(movie.getMovieId());\n    }\n    //最终的候选集\n    return new ArrayList&lt;&gt;(candidateMap.values());\n}\n</code></pre><p>单策略召回是非常简单直观的，正因为简单，所以它的计算速度一定是非常快的。但我想你应该也发现了其中的问题，就是它有很强的局限性。因为大多数时候用户的兴趣是非常多元的，他们不仅喜欢自己感兴趣的，也喜欢热门的，当然很多时候也喜欢新上映的。这时候，单一策略就难以满足用户的潜在需求了，那有没有更全面的召回策略呢？</p><h2>如何理解“多路召回”方法</h2><p>为了让召回的结果更加全面，多路召回方法应运而生了。</p><p><strong>所谓“多路召回策略”，就是指采用不同的策略、特征或简单模型，分别召回一部分候选集，然后把候选集混合在一起供后续排序模型使用的策略。</strong></p><p>其中，各简单策略保证候选集的快速召回，从不同角度设计的策略又能保证召回率接近理想的状态，不至于损害排序效果。所以，多路召回策略是在计算速度和召回率之间进行权衡的结果。</p><p>这里，我们还是以电影推荐为例来做进一步的解释。下面是我给出的电影推荐中常用的多路召回策略，包括热门电影、风格类型、高分评价、最新上映以及朋友喜欢等等。除此之外，我们也可以把一些推断速度比较快的简单模型（比如逻辑回归，协同过滤等）生成的推荐结果放入多路召回层中，形成综合性更好的候选集。具体的操作过程就是，我们分别执行这些策略，让每个策略选取Top K个物品，最后混合多个Top K物品，就形成了最终的多路召回候选集。整个过程就如下所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/c6/e6/c6cdccbb76a85f9d1bbda5c0e030dee6.jpeg?wh=1920*1080\" alt=\"\" title=\"图3 常见的多路召回策略\"></p><p>在SparrowRecsys中，我们就实现了由风格类型、高分评价、最新上映，这三路召回策略组成的多路召回方法，具体代码如下：</p><pre><code>public static List&lt;Movie&gt; multipleRetrievalCandidates(List&lt;Movie&gt; userHistory){\n    HashSet&lt;String&gt; genres = new HashSet&lt;&gt;();\n    //根据用户看过的电影，统计用户喜欢的电影风格\n    for (Movie movie : userHistory){\n        genres.addAll(movie.getGenres());\n    }\n    //根据用户喜欢的风格召回电影候选集\n    HashMap&lt;Integer, Movie&gt; candidateMap = new HashMap&lt;&gt;();\n    for (String genre : genres){\n        List&lt;Movie&gt; oneCandidates = DataManager.getInstance().getMoviesByGenre(genre, 20, &quot;rating&quot;);\n        for (Movie candidate : oneCandidates){\n            candidateMap.put(candidate.getMovieId(), candidate);\n        }\n    }\n    //召回所有电影中排名最高的100部电影\n    List&lt;Movie&gt; highRatingCandidates = DataManager.getInstance().getMovies(100, &quot;rating&quot;);\n    for (Movie candidate : highRatingCandidates){\n        candidateMap.put(candidate.getMovieId(), candidate);\n    }\n    //召回最新上映的100部电影\n    List&lt;Movie&gt; latestCandidates = DataManager.getInstance().getMovies(100, &quot;releaseYear&quot;);\n    for (Movie candidate : latestCandidates){\n        candidateMap.put(candidate.getMovieId(), candidate);\n    }\n    //去除用户已经观看过的电影\n    for (Movie movie : userHistory){\n        candidateMap.remove(movie.getMovieId());\n    }\n    //形成最终的候选集\n    return new ArrayList&lt;&gt;(candidateMap.values());\n}\n</code></pre><p>在实现的过程中，为了进一步优化召回效率，我们还可以通过多线程并行、建立标签/特征索引、建立常用召回集缓存等方法来进一步完善它。</p><p>不过，多路召回策略虽然能够比较全面地照顾到不同的召回方法，但也存在一些缺点。比如，在确定每一路的召回物品数量时，往往需要大量的人工参与和调整，具体的数值需要经过大量线上AB测试来决定。此外，因为策略之间的信息和数据是割裂的，所以我们很难综合考虑不同策略对一个物品的影响。</p><p>那么，是否存在一个综合性强且计算速度也能满足需求的召回方法呢？</p><h2>基于Embedding的召回方法</h2><p>在<a href=\"https://time.geekbang.org/column/article/295300\">第5讲</a>和<a href=\"https://time.geekbang.org/column/article/295939\">第6讲</a>中，我们已经介绍了多种离线生成物品Embedding的方案。事实上，利用物品和用户Embedding相似性来构建召回层，是深度学习推荐系统中非常经典的技术方案。我们可以把它的优势总结为三方面。</p><p>一方面，多路召回中使用的“兴趣标签”“热门度”“流行趋势”“物品属性”等信息都可以作为Embedding方法中的附加信息（Side Information），融合进最终的Embedding向量中 。因此，在利用Embedding召回的过程中，我们就相当于考虑到了多路召回的多种策略。</p><p>另一方面，Embedding召回的评分具有连续性。我们知道，多路召回中不同召回策略产生的相似度、热度等分值不具备可比性，所以我们无法据此来决定每个召回策略放回候选集的大小。但是，Embedding召回却可以把Embedding间的相似度作为唯一的判断标准，因此它可以随意限定召回的候选集大小。</p><p>最后，在线上服务的过程中，Embedding相似性的计算也相对简单和直接。通过简单的点积或余弦相似度的运算就能够得到相似度得分，便于线上的快速召回。</p><p>在SparrowRecsys中，我们也实现了基于Embedding的召回方法。我具体代码放在下面，你可以参考一下。</p><pre><code>public static List&lt;Movie&gt; retrievalCandidatesByEmbedding(User user){\n    if (null == user){\n        return null;\n    }\n    //获取用户embedding向量\n    double[] userEmbedding = DataManager.getInstance().getUserEmbedding(user.getUserId(), &quot;item2vec&quot;);\n    if (null == userEmbedding){\n        return null;\n    }\n    //获取所有影片候选集(这里取评分排名前10000的影片作为全部候选集)\n    List&lt;Movie&gt; allCandidates = DataManager.getInstance().getMovies(10000, &quot;rating&quot;);\n    HashMap&lt;Movie,Double&gt; movieScoreMap = new HashMap&lt;&gt;();\n    //逐一获取电影embedding，并计算与用户embedding的相似度\n    for (Movie candidate : allCandidates){\n        double[] itemEmbedding = DataManager.getInstance().getItemEmbedding(candidate.getMovieId(), &quot;item2vec&quot;);\n        double similarity = calculateEmbeddingSimilarity(userEmbedding, itemEmbedding);\n        movieScoreMap.put(candidate, similarity);\n    }\n   \n    List&lt;Map.Entry&lt;Movie,Double&gt;&gt; movieScoreList = new ArrayList&lt;&gt;(movieScoreMap.entrySet());\n    //按照用户-电影embedding相似度进行候选电影集排序\n    movieScoreList.sort(Map.Entry.comparingByValue());\n\n\n    //生成并返回最终的候选集\n    List&lt;Movie&gt; candidates = new ArrayList&lt;&gt;();\n    for (Map.Entry&lt;Movie,Double&gt; movieScoreEntry : movieScoreList){\n        candidates.add(movieScoreEntry.getKey());\n    }\n    return candidates.subList(0, Math.min(candidates.size(), size));\n}\n\n</code></pre><p>这里，我再带你简单梳理一下整体的实现思路。总的来说，我们通过三步生成了最终的候选集。第一步，我们获取用户的Embedding。第二步，我们获取所有物品的候选集，并且逐一获取物品的Embedding，计算物品Embedding和用户Embedding的相似度。第三步，我们根据相似度排序，返回规定大小的候选集。</p><p>在这三步之中，最主要的时间开销在第二步，虽然它的时间复杂度是线性的，但当物品集过大时（比如达到了百万以上的规模），线性的运算也可能造成很大的时间开销。那有没有什么方法能进一步缩小Embedding召回层的运算时间呢？这个问题我们留到下节课来讨论。</p><h2>小结</h2><p>今天，我们一起讨论了推荐系统中召回层的功能特点和实现方法。并且重点讲解了单策略召回、多路召回，以及深度学习推荐系统中常用的基于Embedding的召回。</p><p>为了方便你对比它们之间的技术特点，我总结了一张表格放在了下面，你可以看一看。</p><p><img src=\"https://static001.geekbang.org/resource/image/2f/80/2fc1eyyefd964f7b65715de6f896c480.jpeg?wh=1920*888\" alt=\"\"></p><p>总的来说，关于召回层的重要内容，我总结成了<strong>一个特点，三个方案</strong>。</p><p>特点就是召回层的功能特点：召回层要快速准确地过滤出相关物品，缩小候选集。三个方案指的是实现召回层的三个技术方案：简单快速的单策略召回、业界主流的多路召回、深度学习推荐系统中最常用的Embedding召回。</p><p>这三种方法基本囊括了现在业界推荐系统的主流召回方法，希望通过这节课的学习，你能掌握这一关键模块的实现方法。</p><p>相信你也一定发现了，召回层技术的发展是循序渐进的，因此我希望你不仅能够学会应用它们，更能够站在前人的技术基础上，进一步推进它的发展，这也是工程师这份职业最大的魅力。</p><h2>课后思考</h2><ol>\n<li>你能根据我今天讲的内容在SparrowRecsys中实现一个多线程版本的多路召回策略吗？</li>\n<li>你觉得对于Embedding召回来说，我们怎么做才能提升计算Embedding相似度的速度？</li>\n</ol><p>你理解的召回层也是这样吗？欢迎把你的思考和答案写在留言区。如果有收获，我也希望你能把这节课分享给你的朋友们。</p>","neighbors":{"left":{"article_title":"10 | 存储模块：如何用Redis解决推荐系统特征的存储问题？","id":299326},"right":{"article_title":"12 | 局部敏感哈希：如何在常数时间内搜索Embedding最近邻？","id":301739}},"comments":[{"had_liked":false,"id":264149,"user_name":"邓生","can_delete":false,"product_type":"c1","uid":2151666,"ip_address":"","ucode":"9A6A95784C0166","user_header":"https://static001.geekbang.org/account/avatar/00/20/d4/f2/979e5346.jpg","comment_is_top":false,"comment_ctime":1606361793,"is_pvip":false,"replies":[{"id":"95802","content":"因为这里user的embedding是通过把历史观看物品进行average得到的，所以他们在一个向量空间内，可以直接进行相似度计算。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1606376484,"ip_address":"","comment_id":264149,"utype":1}],"discussion_count":5,"race_medal":0,"score":"194879890113","product_id":100060801,"comment_content":"关于使用embedding进行召回，其实我搞不懂为什么是用户和物品的embedding计算相似度，不应该是物品跟物品进行相似度计算，用户跟用户之间进行相似度计算吗？为什么物品和人之间可以直接进行embedding相似度计算，这在逻辑上想不通。","like_count":46,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510439,"discussion_content":"因为这里user的embedding是通过把历史观看物品进行average得到的，所以他们在一个向量空间内，可以直接进行相似度计算。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1606376484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1175537,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ef/f1/8b06801a.jpg","nickname":"哇哈哈","note":"","ucode":"47453D1C96A1DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":587913,"discussion_content":"我反过来不理解物品的embedding怎么生成的😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663393093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":510439,"ip_address":"上海"},"score":587913,"extra":""},{"author":{"id":1175537,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ef/f1/8b06801a.jpg","nickname":"哇哈哈","note":"","ucode":"47453D1C96A1DD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":587914,"discussion_content":"用户embedding是通过商品浏览历史生成的，商品embedding通过什么来生成呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663393624,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":510439,"ip_address":"上海"},"score":587914,"extra":""}]},{"author":{"id":1529270,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epW1MiaFR2RTu5YTIBLzZLVm8GJNphfRltWWgRPnKMQJsrpvCXZQa5K0U9jozbfLNWKkTSPlSNkiaSg/132","nickname":"kakaymi","note":"","ucode":"FC675F3796FECF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390924,"discussion_content":"那如果如果是一个新人，没有看过什么电影，或者是只看过1-2部少量的电影，用户的embedding有没有影响?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630144230,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2151666,"avatar":"https://static001.geekbang.org/account/avatar/00/20/d4/f2/979e5346.jpg","nickname":"邓生","note":"","ucode":"9A6A95784C0166","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338279,"discussion_content":"懂了，谢谢老师。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609230839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257132,"user_name":"Geek_63ee39","can_delete":false,"product_type":"c1","uid":2202096,"ip_address":"","ucode":"A41379ADD76480","user_header":"https://static001.geekbang.org/account/avatar/00/21/99/f0/ba3c0208.jpg","comment_is_top":false,"comment_ctime":1603856236,"is_pvip":false,"replies":[{"id":"93589","content":"生产环境中一般不使用第一种方法。第二种方法可以参考阿里的EGES，大致的思路是把这些原始特征作为输入向量，用隐层的输出作为物品的embedding。<br><br>有兴趣的话可以阅读下面的论文原文。<br><br> https:&#47;&#47;github.com&#47;wzhe06&#47;Reco-papers&#47;blob&#47;master&#47;Embedding&#47;%5BAlibaba%20Embedding%5D%20Billion-scale%20Commodity%20Embedding%20for%20E-commerce%20Recommendation%20in%20Alibaba%20%28Alibaba%202018%29.pdf<br><br>","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1603861157,"ip_address":"","comment_id":257132,"utype":1}],"discussion_count":1,"race_medal":0,"score":"130452875116","product_id":100060801,"comment_content":"请教老师一个问题，文中提到: “多路召回中使用的“兴趣标签”“热门度”“流行趋势”“物品属性”等信息都可以作为 Embedding 方法中的附加信息（Side information），融合进最终的 Embedding 向量中”<br><br>我想有两种实现方式: <br>1. 对于用户高评分（大于3.5）的电影序列，通过item2vec得到每个物品的embedding向量（假设长度为10），并在向量第11位添加物品的兴趣标签，第12位添加物品热门度，依次类推。<br>2. 不采用item2vec，而是其他某种方式将物品所有维度的信息（包括“兴趣标签”“热门度”“流行趋势”“物品属性”等）统一地进行embedding。<br><br>对于第一种方式，每一个维度的附加信息权重相同，这是否合理?另外对于电影类型这种类别型特征，采用multi-hot编码附加到embedding向量后面，是否合理。<br>对于第二种方式，我还不知道怎样实现。<br><br>请问老师，实际生产中较好的实现方式是怎样的呢？","like_count":31,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508235,"discussion_content":"生产环境中一般不使用第一种方法。第二种方法可以参考阿里的EGES，大致的思路是把这些原始特征作为输入向量，用隐层的输出作为物品的embedding。\n\n有兴趣的话可以阅读下面的论文原文。\n\n https://github.com/wzhe06/Reco-papers/blob/master/Embedding/%5BAlibaba%20Embedding%5D%20Billion-scale%20Commodity%20Embedding%20for%20E-commerce%20Recommendation%20in%20Alibaba%20%28Alibaba%202018%29.pdf\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603861157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260955,"user_name":"gallup","can_delete":false,"product_type":"c1","uid":1369593,"ip_address":"","ucode":"EF40558811E74F","user_header":"https://static001.geekbang.org/account/avatar/00/14/e5/f9/f0d056be.jpg","comment_is_top":false,"comment_ctime":1605161570,"is_pvip":false,"replies":[{"id":"94776","content":"在系统延迟允许的情况下，其实k取的越大越好。<br><br>一般来说，如果最后的推荐结果需要n条，k取5-10n是比较合适的。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1605196427,"ip_address":"","comment_id":260955,"utype":1}],"discussion_count":2,"race_medal":0,"score":"108979343970","product_id":100060801,"comment_content":"请问老师，多路召回中，topk除了根据经验值确定，业界通用的是怎么确定k得大小呢","like_count":26,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509335,"discussion_content":"在系统延迟允许的情况下，其实k取的越大越好。\n\n一般来说，如果最后的推荐结果需要n条，k取5-10n是比较合适的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605196427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1057843,"avatar":"https://static001.geekbang.org/account/avatar/00/10/24/33/bcf37f50.jpg","nickname":"阿甘","note":"","ucode":"BC93175B70E05D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357782,"discussion_content":"多路召回一般都有一个融合策略在后面，也是要不断优化调整的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615865333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257378,"user_name":"萬里長空","can_delete":false,"product_type":"c1","uid":2199552,"ip_address":"","ucode":"54343639CA8397","user_header":"https://static001.geekbang.org/account/avatar/00/21/90/00/cfc2b463.jpg","comment_is_top":false,"comment_ctime":1603951749,"is_pvip":false,"replies":[{"id":"93753","content":"非常好的业界实践的问题。其实方法无非是我们提到过的几种。<br><br>1、把商品embedding进行预训练，再跟其他side information特征一起输入EGES。<br>2、像你说的hash方法<br>3、商品的聚类后输入，比如非常类似的商品，可以用一个商品id替代，当作一个商品来处理。这个方法airbnb embedding的论文讲的非常好。<br>","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1604017859,"ip_address":"","comment_id":257378,"utype":1}],"discussion_count":1,"race_medal":0,"score":"96093232261","product_id":100060801,"comment_content":"老师,关于EGES的训练,试了下,由于电商领域商品维度非常大,即使hash后也很大,这导致训练非常慢,这个一般怎么解决啊?","like_count":23,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508315,"discussion_content":"非常好的业界实践的问题。其实方法无非是我们提到过的几种。\n\n1、把商品embedding进行预训练，再跟其他side information特征一起输入EGES。\n2、像你说的hash方法\n3、商品的聚类后输入，比如非常类似的商品，可以用一个商品id替代，当作一个商品来处理。这个方法airbnb embedding的论文讲的非常好。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604017859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262111,"user_name":"Jerome","can_delete":false,"product_type":"c1","uid":1132334,"ip_address":"","ucode":"776E365B44F316","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/2e/50b79874.jpg","comment_is_top":false,"comment_ctime":1605614916,"is_pvip":false,"replies":[{"id":"95117","content":"这是最常用最简单的user embedding生成方法。之前我们说过embedding之间是可以进行运算的。所以用用户喜欢的物品的embedding平均去代表这个用户是非常直观且实用的。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1605664114,"ip_address":"","comment_id":262111,"utype":1}],"discussion_count":4,"race_medal":0,"score":"53145222468","product_id":100060801,"comment_content":"请问下老师，在生成用户embedding的过程中我看你的逻辑是将该用户所有观看电影的embedding通过拉链进行叠加后最终生成，请问这种方法有什么根据吗或者说是原理呢，还是说这个是基于经验呢？","like_count":13,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509696,"discussion_content":"这是最常用最简单的user embedding生成方法。之前我们说过embedding之间是可以进行运算的。所以用用户喜欢的物品的embedding平均去代表这个用户是非常直观且实用的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605664114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1923875,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/5b/23/a1bb7ef9.jpg","nickname":"danielwpz","note":"","ucode":"9B926555DD6726","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347869,"discussion_content":"我看代码好像没有看到取平均值这个操作呀，只是把emb的各个维度加和了一下。请问有没有同学说一下怎么取的平均值呢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1612345734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2414687,"avatar":"","nickname":"Geek_f30bcb","note":"","ucode":"69996919542668","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343022,"discussion_content":"如果我喜欢恐怖片，也喜欢喜剧片，但是embemding向量平均之后，是否就成了我喜欢喜剧恐怖片，但是这样的影片很奇怪啊。  ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1610923496,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2454131,"avatar":"https://static001.geekbang.org/account/avatar/00/25/72/73/d707c8be.jpg","nickname":"MutouMan","note":"","ucode":"E2E78C6EE25E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2414687,"avatar":"","nickname":"Geek_f30bcb","note":"","ucode":"69996919542668","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371383,"discussion_content":"应该还是看这个影片类型的侧重，话说回来以取很多港片就是喜剧鬼片","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619751788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":343022,"ip_address":""},"score":371383,"extra":""}]}]},{"had_liked":false,"id":307209,"user_name":"Geek_seven","can_delete":false,"product_type":"c1","uid":1545696,"ip_address":"","ucode":"4DA58A44F89286","user_header":"","comment_is_top":false,"comment_ctime":1628936724,"is_pvip":false,"replies":[{"id":"111278","content":"后者","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1629068248,"ip_address":"","comment_id":307209,"utype":1}],"discussion_count":2,"race_medal":0,"score":"44578609684","product_id":100060801,"comment_content":"请问老师，在业界中，通常的做法是会将embedding召回替换掉多路召回，还是会将embedding召回作为多路召回中一路召回呢？谢谢~","like_count":11,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525078,"discussion_content":"后者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629068248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048329,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ff/09/e0c39733.jpg","nickname":"Jayliud","note":"","ucode":"0274FC2607B1BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400996,"discussion_content":"为啥是后者呢？如果耗时都差不多的情况下，用一个大的embedding替换所有的多路更合理呀。\n\n还是说用一个embedding去做的话，没法利用多线程并行优势而且单次请求会变慢。\n\n亦或者有些召回技术上没法通过embedding来实现呢？非常感谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633516806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260427,"user_name":"王宁","can_delete":false,"product_type":"c1","uid":2204534,"ip_address":"","ucode":"8A7E1A787945DC","user_header":"https://static001.geekbang.org/account/avatar/00/21/a3/76/a81e3fbe.jpg","comment_is_top":false,"comment_ctime":1605002134,"is_pvip":false,"replies":[{"id":"94631","content":"是的，one-hot特征肯定会让embedding matrix很大，但就是这样使用的，因为我们就是想求解每一个维度上对应item的embedding。<br><br>这也就是为什么说embedding层是神经网络中最耗时的部分的原因。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1605079214,"ip_address":"","comment_id":260427,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40259707798","product_id":100060801,"comment_content":"老师，你好，我看了您推荐给其他同学的阿里的EGES算法的论文，那个论文里面的EGES模型图的最底层是Sparse feature，论文中是说这一层是比较倾向于用one- hot编码的，不管side information的one-hot编码，一般item的数量会很多很多，对item本身的向量表示直接用one-hot的话，那embedding matrix是不是会很大，这样是合适的吗？我不确定自己是不是看懂了，希望老师可以帮我解答一下，谢谢老师！","like_count":10,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509188,"discussion_content":"是的，one-hot特征肯定会让embedding matrix很大，但就是这样使用的，因为我们就是想求解每一个维度上对应item的embedding。\n\n这也就是为什么说embedding层是神经网络中最耗时的部分的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605079214,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257483,"user_name":"Geek_e0d66a","can_delete":false,"product_type":"c1","uid":1809935,"ip_address":"","ucode":"5078900C9CF936","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/l3RGUX8aLnPLmsQsra0yU5d8m7Se5jdVpaC3bkb99FuY11BPQNAsH4MPXbZjCTia9VVwn8lnBnKLkdfSiabOgxKg/132","comment_is_top":false,"comment_ctime":1603986185,"is_pvip":false,"replies":[{"id":"93748","content":"这是个好问题。简单的做法是把兴趣标签转换成multihot向量，然后就可以计算出用户和物品的相似度了。<br><br>复杂一点也可以计算每个兴趣标签的tfidf，为标签分配权重后，再转换成multihot向量。<br><br>如果标签有多层，也不妨碍把多层标签全部放到multihot向量中，高层标签的权重可以适当降低。这也是思路之一。<br><br>希望你自己也能有类似的思考。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1604017403,"ip_address":"","comment_id":257483,"utype":1}],"discussion_count":5,"race_medal":0,"score":"35963724553","product_id":100060801,"comment_content":"请问老师，如果基于兴趣标签做召回，同一个物品，有多个标签，而用户也计算了出了多个兴趣标签，那么怎么做用户的多兴趣标签与物品的最优匹配呢？还有物品的标签有多层，那么怎么利用上一层的标签呢？","like_count":9,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508347,"discussion_content":"这是个好问题。简单的做法是把兴趣标签转换成multihot向量，然后就可以计算出用户和物品的相似度了。\n\n复杂一点也可以计算每个兴趣标签的tfidf，为标签分配权重后，再转换成multihot向量。\n\n如果标签有多层，也不妨碍把多层标签全部放到multihot向量中，高层标签的权重可以适当降低。这也是思路之一。\n\n希望你自己也能有类似的思考。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604017403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087792,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erUKWZy1fBBcJncWRNh9M3TkjThqgsIIpmGOTCyg2IN80IDf3COkeWyTLHliczAppIkfBgCJTsUn1g/132","nickname":"马龙流","note":"","ucode":"16F9CE022297FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325446,"discussion_content":"简单对标签做个倒排是不是也可以","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1605321313,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2280216,"avatar":"https://static001.geekbang.org/account/avatar/00/22/cb/18/0139e086.jpg","nickname":"骚动","note":"","ucode":"EBEBF417C866D4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":351144,"discussion_content":"转成multihot后直接和emb计算相似吗？这两者能直接计算吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614165376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2454131,"avatar":"https://static001.geekbang.org/account/avatar/00/25/72/73/d707c8be.jpg","nickname":"MutouMan","note":"","ucode":"E2E78C6EE25E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2280216,"avatar":"https://static001.geekbang.org/account/avatar/00/22/cb/18/0139e086.jpg","nickname":"骚动","note":"","ucode":"EBEBF417C866D4","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":371385,"discussion_content":"不用余弦吧，直接矩阵乘法就可以了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619751982,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":351144,"ip_address":""},"score":371385,"extra":""}]},{"author":{"id":2405529,"avatar":"https://static001.geekbang.org/account/avatar/00/24/b4/99/79a21147.jpg","nickname":"轩","note":"","ucode":"454CC1A0734A4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":340314,"discussion_content":"我过去的做法是铺平所有标签当作一层，高层级标签系数乘0.6，再高一层乘0.36系数，完全拍脑袋拍出来的，囧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609962210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257460,"user_name":"Geek_63ee39","can_delete":false,"product_type":"c1","uid":2202096,"ip_address":"","ucode":"A41379ADD76480","user_header":"https://static001.geekbang.org/account/avatar/00/21/99/f0/ba3c0208.jpg","comment_is_top":false,"comment_ctime":1603978833,"is_pvip":false,"replies":[{"id":"93750","content":"基本就是这样的思路，生产环境中要做好线程池的维护和一些参数的调优。<br><br>可以的话欢迎提交多线程版本的pull request到SparrowRecsys项目","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1604017481,"ip_address":"","comment_id":257460,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35963717201","product_id":100060801,"comment_content":"课后思考1：<br>1. 在类SimilarMovieProcess中实例化一个线程池ThreadPoolExecutor作为静态成员变量<br>2. 方法multipleRetrievalCandidates中的候选集candidateMap使用ConcurrentHashMap替代HashMap<br>3. 风格类型、高分评价、最新上映三种召回的过程使用线程池实例（共三个线程）去执行<br>4. 判断三个线程执行完后返回结果<br><br>不知道这种方式有没有不足？","like_count":9,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508340,"discussion_content":"基本就是这样的思路，生产环境中要做好线程池的维护和一些参数的调优。\n\n可以的话欢迎提交多线程版本的pull request到SparrowRecsys项目","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604017481,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258070,"user_name":"大钰儿","can_delete":false,"product_type":"c1","uid":1193551,"ip_address":"","ucode":"3E632100FAC52B","user_header":"https://static001.geekbang.org/account/avatar/00/12/36/4f/455ec47f.jpg","comment_is_top":false,"comment_ctime":1604285754,"is_pvip":false,"replies":[{"id":"94055","content":"这还是冷启动问题，我之前有过类似的回复，可以参考。<br><br>另外其实我不建议如此多的新item还采用embedding的方案，没有必要，可以考虑在重排层加入这些新鲜的item。用一些基本的特征参与重排，简单模型虽然传统，但在特殊的场景下也经常采用。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1604365859,"ip_address":"","comment_id":258070,"utype":1}],"discussion_count":1,"race_medal":0,"score":"27374089530","product_id":100060801,"comment_content":"如果新item特别多(每秒可能几十到上百）对item展示的实时性要求较高（小于五分钟就需要曝光）这些item的embedding该如何更新呢？","like_count":7,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508547,"discussion_content":"这还是冷启动问题，我之前有过类似的回复，可以参考。\n\n另外其实我不建议如此多的新item还采用embedding的方案，没有必要，可以考虑在重排层加入这些新鲜的item。用一些基本的特征参与重排，简单模型虽然传统，但在特殊的场景下也经常采用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604365859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257353,"user_name":"那时刻","can_delete":false,"product_type":"c1","uid":1150927,"ip_address":"","ucode":"B0D150856C3A4A","user_header":"https://static001.geekbang.org/account/avatar/00/11/8f/cf/890f82d6.jpg","comment_is_top":false,"comment_ctime":1603943819,"is_pvip":false,"replies":[{"id":"93754","content":"一般是把他们作为特征输入模型参与训练，让模型去决定他们的权重。模型的输出就是embedding向量。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1604017902,"ip_address":"","comment_id":257353,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18783813003","product_id":100060801,"comment_content":"请问老师，多路召回中使用的“兴趣标签”“热门度”“流行趋势”“物品属性”等信息都可以作为 Embedding 方法中的附加信息，这些附加信息可以设置各自权重么？","like_count":4,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508306,"discussion_content":"一般是把他们作为特征输入模型参与训练，让模型去决定他们的权重。模型的输出就是embedding向量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604017902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257340,"user_name":"Four y","can_delete":false,"product_type":"c1","uid":1608789,"ip_address":"","ucode":"816C50CA85E3AE","user_header":"https://static001.geekbang.org/account/avatar/00/18/8c/55/cac3dbcc.jpg","comment_is_top":false,"comment_ctime":1603941447,"is_pvip":false,"replies":[{"id":"93755","content":"哈哈，非常好的点，TopK显然是时间复杂度更优的选择。可以提交一个pull request到项目中吗？集体的力量显然比我大多了。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1604018004,"ip_address":"","comment_id":257340,"utype":1}],"discussion_count":2,"race_medal":0,"score":"18783810631","product_id":100060801,"comment_content":"老师，我看到您的实现中召回层在对所有的电影做了相似度计算后进行了排序，再选出Topk给排序层.<br>这里为什么是这样操作呢？我想，对于召回层我们不可以直接对结果进行Topk算法吗？<br>如果是用排序的话，那么主要的计算量不就在第三步而不是第二步了吗？<br><br>","like_count":4,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508301,"discussion_content":"哈哈，非常好的点，TopK显然是时间复杂度更优的选择。可以提交一个pull request到项目中吗？集体的力量显然比我大多了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604018004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809935,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/l3RGUX8aLnPLmsQsra0yU5d8m7Se5jdVpaC3bkb99FuY11BPQNAsH4MPXbZjCTia9VVwn8lnBnKLkdfSiabOgxKg/132","nickname":"Geek_e0d66a","note":"","ucode":"5078900C9CF936","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319331,"discussion_content":"召回层计算了相似度后，如果数量还是很多，会做一次粗排，减少候选集数量，那就只能排一次序，截断","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603985944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":258428,"user_name":"小匚","can_delete":false,"product_type":"c1","uid":1611663,"ip_address":"","ucode":"78E800B23C457A","user_header":"https://static001.geekbang.org/account/avatar/00/18/97/8f/ccce7df1.jpg","comment_is_top":false,"comment_ctime":1604422535,"is_pvip":false,"replies":[{"id":"94120","content":"是这样。理论上可以用任何深度学习模型来生成，只要输出是一个向量。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1604464513,"ip_address":"","comment_id":258428,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14489324423","product_id":100060801,"comment_content":"老师这种Embedding特征的方法是不是叫表征学习了？也可以用深度学习的模型来输出这个Embedding","like_count":3,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508651,"discussion_content":"是这样。理论上可以用任何深度学习模型来生成，只要输出是一个向量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1604464513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":308691,"user_name":"Van","can_delete":false,"product_type":"c1","uid":2726010,"ip_address":"","ucode":"5D88FC2DD9B868","user_header":"","comment_is_top":false,"comment_ctime":1629743191,"is_pvip":false,"replies":[{"id":"111749","content":"他们本质上其实没有太大区别，u2i召回可以认为是i2i召回的一个聚合，因为user emb往往是通过TA交互的items生成的。一般来说肯定是u2i的召回效果会好一些。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1629764399,"ip_address":"","comment_id":308691,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10219677783","product_id":100060801,"comment_content":"老师您好。基于您讲的Embedding的召回方法 我又做了一些额外的研究，看到业界目前有两类方法：<br>1. i2i召回 比如用咱们前面讲item2vec得到item的embedding然后去做召回<br>2. u2i召回 用咱们后面讲的比如双塔模型同时得到user和item的embdding然后直接做内积找近似<br>想知道这两种方法哪种更好一些（个人猜测u2i）？最近我们组想要做这个 不知道老师您更建议从哪个模型开始着手（e.g. youtube的DNN）？ （我知道一定是因数据和公司情况而异的 但想从老师的经验出发了解一下如果想做召回 从哪个模型开始 是比较好的）谢谢老师！","like_count":3,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":525592,"discussion_content":"他们本质上其实没有太大区别，u2i召回可以认为是i2i召回的一个聚合，因为user emb往往是通过TA交互的items生成的。一般来说肯定是u2i的召回效果会好一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629764399,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267797,"user_name":"陈威洋","can_delete":false,"product_type":"c1","uid":2264679,"ip_address":"","ucode":"DCF84B4D3A7354","user_header":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","comment_is_top":false,"comment_ctime":1607934824,"is_pvip":false,"replies":[{"id":"97266","content":"要的，这是工作中非常重要的组成部分，后续有专门讲AB测试的课程，推荐继续学习。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1607935567,"ip_address":"","comment_id":267797,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10197869416","product_id":100060801,"comment_content":"老师，您好！我是推荐系统小白，请问作为推荐系统工程师，要认真做好AB测试吗？","like_count":3,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511747,"discussion_content":"要的，这是工作中非常重要的组成部分，后续有专门讲AB测试的课程，推荐继续学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607935567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2264679,"avatar":"https://static001.geekbang.org/account/avatar/00/22/8e/67/afb412fb.jpg","nickname":"陈威洋","note":"","ucode":"DCF84B4D3A7354","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":334693,"discussion_content":"非常感谢老师的回复，随时准备好学习。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607938573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":266452,"user_name":"Ethan","can_delete":false,"product_type":"c1","uid":1691430,"ip_address":"","ucode":"18372730643F6F","user_header":"https://static001.geekbang.org/account/avatar/00/19/cf/26/1120f7fd.jpg","comment_is_top":false,"comment_ctime":1607343533,"is_pvip":false,"replies":[{"id":"96798","content":"建议先往下学，把所有代码都熟悉了，会更好的熟悉项目的整体架构。之后有问题还可以留言提问。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1607390733,"ip_address":"","comment_id":266452,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10197278125","product_id":100060801,"comment_content":"请问老师，系列中哪些部分是排序层？以及召回和排序两步如何打通？没有看到相关内容，有点迷糊","like_count":2,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511272,"discussion_content":"建议先往下学，把所有代码都熟悉了，会更好的熟悉项目的整体架构。之后有问题还可以留言提问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607390733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":257052,"user_name":"浣熊当家","can_delete":false,"product_type":"c1","uid":1952248,"ip_address":"","ucode":"939F06050423E4","user_header":"https://static001.geekbang.org/account/avatar/00/1d/c9/f8/72955ef9.jpg","comment_is_top":false,"comment_ctime":1603845558,"is_pvip":false,"replies":[{"id":"93590","content":"要善用IDE的搜索功能，我在项目中函数名跟文中的都是一致的，不可能找不到。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1603861258,"ip_address":"","comment_id":257052,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10193780150","product_id":100060801,"comment_content":"还是得麻烦问一下老师，文中的三段代码可以在Maven项目的哪个模块下找到？ 我没找到有关于retriveval相关名字的模块","like_count":2,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":508201,"discussion_content":"要善用IDE的搜索功能，我在项目中函数名跟文中的都是一致的，不可能找不到。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603861258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1952248,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/c9/f8/72955ef9.jpg","nickname":"浣熊当家","note":"","ucode":"939F06050423E4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319013,"discussion_content":"哦！原来是有搜索功能的！谢谢老师提醒！谢谢韩同学！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1603906829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2206403,"avatar":"https://static001.geekbang.org/account/avatar/00/21/aa/c3/718b0d96.jpg","nickname":"韩旭东","note":"","ucode":"10E19FE2B7F4FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":318761,"discussion_content":"recprocess/similarymoviepreocess","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603846521,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311733,"user_name":"ulysses","can_delete":false,"product_type":"c1","uid":1527771,"ip_address":"","ucode":"EB617C1E586CA7","user_header":"https://static001.geekbang.org/account/avatar/00/17/4f/db/3d589d18.jpg","comment_is_top":false,"comment_ctime":1631433516,"is_pvip":false,"replies":[{"id":"113098","content":"线上用哪种召回方法自己尝试就可以了。目前的整个流程只是为给出一个示例","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1631662559,"ip_address":"","comment_id":311733,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5926400812","product_id":100060801,"comment_content":"老师你好，请问一下你这个算法召回的模型的结果应该没有应用在这个线上的project吧？因为我并没有找到调用SimilarMovieProcess 这个class 的方法。可以解释一下吗？","like_count":1,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526722,"discussion_content":"线上用哪种召回方法自己尝试就可以了。目前的整个流程只是为给出一个示例","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631662559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1527771,"avatar":"https://static001.geekbang.org/account/avatar/00/17/4f/db/3d589d18.jpg","nickname":"ulysses","note":"","ucode":"EB617C1E586CA7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393991,"discussion_content":"好的。了解，我发现了project里面直接用的是训练好的embedding的方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631680810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291617,"user_name":"郭翊麟","can_delete":false,"product_type":"c1","uid":2438072,"ip_address":"","ucode":"BA37CAE065CF30","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/FydBiarFhvwAxkA2fL3IpEGcd31xAfo8WicAgxreCSbPgo0IdcHkAwZQDZDiaeAJg7u2UKqSEmzr8Mopf9lFY1IEw/132","comment_is_top":false,"comment_ctime":1620386357,"is_pvip":false,"replies":[{"id":"105680","content":"哦，这两种方法其实都可以，不要过多解读。这只是一份示例代码，具体的效果大家要自己去验证去探索。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1620582484,"ip_address":"","comment_id":291617,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5915353653","product_id":100060801,"comment_content":"王老师您好  阅读这一节的源码是发现 您在文中写的 etrievalCandidatesByEmbedding(User user) 方法 并没有找到   取而代之的是 retrievalCandidatesByEmbedding(Movie movie, int size)  按我理解 一个是针对 user Embedding计算 movie的相似度  一个是针对 当前movie Embedding 计算与movie的相似度   替换对象的原因是工程上的考虑 还是单纯的 用user Embedding效果不好呢？ 感谢老师的解答啦！！！","like_count":2,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519524,"discussion_content":"哦，这两种方法其实都可以，不要过多解读。这只是一份示例代码，具体的效果大家要自己去验证去探索。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620582484,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":273676,"user_name":"静秋","can_delete":false,"product_type":"c1","uid":2411884,"ip_address":"","ucode":"6BEB5E03C8CB01","user_header":"https://static001.geekbang.org/account/avatar/00/24/cd/6c/9ab927b1.jpg","comment_is_top":false,"comment_ctime":1610646533,"is_pvip":false,"replies":[{"id":"99143","content":"问题有点不清楚。感觉是要问如何提高label人工标注效率的问题。<br><br>一般是用一些半监督的方法，或者一些规则先自动标注一些明显的样本，如果拿不定的再人工标注。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1610668006,"ip_address":"","comment_id":273676,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5905613829","product_id":100060801,"comment_content":"标注数据的时候label可能会比较稀疏，如何通过快速删选来降低标注的成本和工作量？请老师有啥好的建议吗？","like_count":1,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513737,"discussion_content":"问题有点不清楚。感觉是要问如何提高label人工标注效率的问题。\n\n一般是用一些半监督的方法，或者一些规则先自动标注一些明显的样本，如果拿不定的再人工标注。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610668006,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271969,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1629141,"ip_address":"","ucode":"8AC3F3AB9BB6BF","user_header":"","comment_is_top":false,"comment_ctime":1609898507,"is_pvip":false,"replies":[{"id":"98612","content":"理解没错，用户评论过的电影emb的加和。具体的语法可以查一下scala的语法","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1609914936,"ip_address":"","comment_id":271969,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5904865803","product_id":100060801,"comment_content":"不太理解， userEmb.csv 数据生成的思路？用户观看过的电影的Emb的聚合？不理解下面代码思路 ","like_count":1,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":513105,"discussion_content":"理解没错，用户评论过的电影emb的加和。具体的语法可以查一下scala的语法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609914936,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269327,"user_name":"卓别林先森","can_delete":false,"product_type":"c1","uid":2198724,"ip_address":"","ucode":"253A52EF861BF3","user_header":"https://static001.geekbang.org/account/avatar/00/21/8c/c4/aba3ee31.jpg","comment_is_top":false,"comment_ctime":1608614174,"is_pvip":false,"replies":[{"id":"97720","content":"可以往后参考模型评估篇的内容。真实业界评估中，我其实不推荐单独评价召回算法，而是把召回算法和其他模块在一起做整体评估，更准确一些。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1608666043,"ip_address":"","comment_id":269327,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5903581470","product_id":100060801,"comment_content":"王老师您好，了解这些召回层的算法后，能说下目前业界生产中是如何评价每个召回算法的指标吗？类似于排序算法中的auc，recall,ctr的指标来之类的指标。谢谢！","like_count":1,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512237,"discussion_content":"可以往后参考模型评估篇的内容。真实业界评估中，我其实不推荐单独评价召回算法，而是把召回算法和其他模块在一起做整体评估，更准确一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608666043,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321766,"user_name":"江月","can_delete":false,"product_type":"c1","uid":2537453,"ip_address":"","ucode":"DFF3CA78F26706","user_header":"https://static001.geekbang.org/account/avatar/00/26/b7/ed/a61ad95d.jpg","comment_is_top":false,"comment_ctime":1637034904,"is_pvip":false,"replies":[{"id":"117065","content":"基本上就是反馈控制那一套东西，反馈周期和延迟问题最重要。","user_name":"作者回复","user_name_real":"编辑","uid":"1662192","ctime":1637366646,"ip_address":"","comment_id":321766,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1637034904","product_id":100060801,"comment_content":"请问老师，如果想动态调每一路召回配额，实验指标如时长完播率，和各路召回配额没有明显的相关性，这样要怎么确定每一路的配额向上调还是向下调，试过用高斯采样，感觉像是盲猜，时好时坏","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":531626,"discussion_content":"基本上就是反馈控制那一套东西，反馈周期和延迟问题最重要。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637366646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321366,"user_name":"Geek_b2c562","can_delete":false,"product_type":"c1","uid":2839327,"ip_address":"","ucode":"5612BFDED82CBE","user_header":"","comment_is_top":false,"comment_ctime":1636814040,"is_pvip":false,"replies":[{"id":"116812","content":"引入side infromation可以参考阿里的EGES的方案","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1637024944,"ip_address":"","comment_id":321366,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636814040","product_id":100060801,"comment_content":"多路召回中使用的“兴趣标签”“热门度”“流行趋势”“物品属性”如何作为 Embedding 方法中的附加信息？前面讲的图模型和item2vec貌似不能支持","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530280,"discussion_content":"引入side infromation可以参考阿里的EGES的方案","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637024944,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321365,"user_name":"Geek_b2c562","can_delete":false,"product_type":"c1","uid":2839327,"ip_address":"","ucode":"5612BFDED82CBE","user_header":"","comment_is_top":false,"comment_ctime":1636813624,"is_pvip":false,"replies":[{"id":"116811","content":"基于物品的embedding生成user embedding，或者用双塔模型同时生成user emb和item emb","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1637024871,"ip_address":"","comment_id":321365,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1636813624","product_id":100060801,"comment_content":"请问老师，item2vec是算的物品的特征，是物品的空间向量，怎样和用户item2vec联系上的呢？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530279,"discussion_content":"基于物品的embedding生成user embedding，或者用双塔模型同时生成user emb和item emb","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1637024871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":320706,"user_name":"江月","can_delete":false,"product_type":"c1","uid":2537453,"ip_address":"","ucode":"DFF3CA78F26706","user_header":"https://static001.geekbang.org/account/avatar/00/26/b7/ed/a61ad95d.jpg","comment_is_top":false,"comment_ctime":1636462514,"is_pvip":false,"replies":[{"id":"116410","content":"也不用说是强化学习吧，说白了就是一个反馈控制。控制好数据链路的反馈周期，做到尽快调整，肯定是有收益的。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1636572748,"ip_address":"","comment_id":320706,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1636462514","product_id":100060801,"comment_content":"多路召回确定一个大概的配额过后通过强化学习的方法调整配额会有更好的效果吗","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":530089,"discussion_content":"也不用说是强化学习吧，说白了就是一个反馈控制。控制好数据链路的反馈周期，做到尽快调整，肯定是有收益的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636572748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2537453,"avatar":"https://static001.geekbang.org/account/avatar/00/26/b7/ed/a61ad95d.jpg","nickname":"江月","note":"","ucode":"DFF3CA78F26706","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":414966,"discussion_content":"实验指标如时长，和各路召回配额没有明显的相关性，这样要怎么确定每一路的配额向上调还是向下调，试过用高斯采样，感觉像是盲猜，时好时坏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1636947244,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311773,"user_name":"sky","can_delete":false,"product_type":"c1","uid":2325199,"ip_address":"","ucode":"C7BA135845E1FF","user_header":"https://static001.geekbang.org/account/avatar/00/23/7a/cf/c42dd74e.jpg","comment_is_top":false,"comment_ctime":1631455758,"is_pvip":false,"replies":[{"id":"113097","content":"输入是原始的特征，embedding都是训练出来的。<br><br>召回和排序的区别在于模型的复杂度，不在于用不用embedding","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1631662486,"ip_address":"","comment_id":311773,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1631455758","product_id":100060801,"comment_content":"王老师，看到这里，我有个疑问：推荐系统的输入到底是什么呢？感觉召回排序都用的是 Embedding ，没啥区别啊","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526736,"discussion_content":"输入是原始的特征，embedding都是训练出来的。\n\n召回和排序的区别在于模型的复杂度，不在于用不用embedding","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631662486,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2325199,"avatar":"https://static001.geekbang.org/account/avatar/00/23/7a/cf/c42dd74e.jpg","nickname":"sky","note":"","ucode":"C7BA135845E1FF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":395118,"discussion_content":"多谢王老师解答，我再消化一下","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1632233959,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":311669,"user_name":"sky","can_delete":false,"product_type":"c1","uid":2325199,"ip_address":"","ucode":"C7BA135845E1FF","user_header":"https://static001.geekbang.org/account/avatar/00/23/7a/cf/c42dd74e.jpg","comment_is_top":false,"comment_ctime":1631374331,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631374331","product_id":100060801,"comment_content":"这里的召回是怎么触发的呢，或者输入是什么呢","like_count":0},{"had_liked":false,"id":310274,"user_name":"WJing","can_delete":false,"product_type":"c1","uid":2735592,"ip_address":"","ucode":"391A148418523B","user_header":"","comment_is_top":false,"comment_ctime":1630575291,"is_pvip":false,"replies":[{"id":"112487","content":"当然可以","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1630692525,"ip_address":"","comment_id":310274,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1630575291","product_id":100060801,"comment_content":"请教老师一个问题，在矩阵分解里面的latent factors可不可以也理解为是embedding的雏形？<br>\\\\hat{r}_{ui} = p^u * q^i ","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":526180,"discussion_content":"当然可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630692525,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306929,"user_name":"Van","can_delete":false,"product_type":"c1","uid":2726010,"ip_address":"","ucode":"5D88FC2DD9B868","user_header":"","comment_is_top":false,"comment_ctime":1628779595,"is_pvip":false,"replies":[{"id":"111237","content":"召回策略的最好测试方法就是跟排序策略一同测试。否则无法确定真实的效果。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1628921243,"ip_address":"","comment_id":306929,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628779595","product_id":100060801,"comment_content":"想问老师 如何去评价每个召回策略的好坏呢？假设对于每一个用户我们只有他对于列表的click数据 单纯的precision&#47;recall似乎不太能区别。我能想到的是线上ab testing。不知道线下还有什么好的方法吗？谢谢老师","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524979,"discussion_content":"召回策略的最好测试方法就是跟排序策略一同测试。否则无法确定真实的效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628921243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":306537,"user_name":"胡景方","can_delete":false,"product_type":"c1","uid":2719584,"ip_address":"","ucode":"67371485F96D70","user_header":"https://static001.geekbang.org/account/avatar/00/29/7f/60/9d7bae85.jpg","comment_is_top":false,"comment_ctime":1628600343,"is_pvip":false,"replies":[{"id":"111048","content":"在线。有大量方案可以解决延迟问题。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1628659729,"ip_address":"","comment_id":306537,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1628600343","product_id":100060801,"comment_content":"召回是在线的还是离线的？实时在线工程在处理召回大量数据集时会不会特别慢，导致在线工程响应时间很长从而不能高效返回推荐列表给到客户？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":524806,"discussion_content":"在线。有大量方案可以解决延迟问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628659729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":293611,"user_name":"Geek_c7d6ff","can_delete":false,"product_type":"c1","uid":2613759,"ip_address":"","ucode":"481FB1C5972154","user_header":"","comment_is_top":false,"comment_ctime":1621464026,"is_pvip":false,"replies":[{"id":"106652","content":"想法很好，特别是第一个我觉得有可行性，也可以参考下一讲的内容。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1621703974,"ip_address":"","comment_id":293611,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1621464026","product_id":100060801,"comment_content":"提升计算 Embedding 相似度：<br>1. 是不是可以先对所有item的向量进行clustering，然后先计算user距离每个centroid的距离，选择比较接近的cluster。<br>2. 不太需要sorting吧，用quick select选择top-K是不是更快一些？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":520288,"discussion_content":"想法很好，特别是第一个我觉得有可行性，也可以参考下一讲的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621703974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":291269,"user_name":"无名扫地僧","can_delete":false,"product_type":"c1","uid":1744260,"ip_address":"","ucode":"9520E1D78CA19A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/gch7eaGnpZBju8mVcUmiaV5YgCvA1EzsjJibDCzF9tVgiclmFEJl5nsMicwdh26iaXpPHCJfiaav73IK40a6cVjVO05g/132","comment_is_top":false,"comment_ctime":1620177852,"is_pvip":true,"replies":[{"id":"105685","content":"问题意思不是特别清楚，试着答一下。<br><br>其实召回层和排序层的划分并不是特别清楚，如果你认为这个模型的latency很低，可以高效的对大批候选物品打分，完全可以放在召回层，如果比较费计算资源，latency也很高，当然放在排序层好一些。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1620582995,"ip_address":"","comment_id":291269,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1620177852","product_id":100060801,"comment_content":"老師您好，<br>想請問這樣的做法是否適當，訓練一個月使用者的瀏覽行為模型，<br>像這種模型只能推薦出這一個月使用者瀏覽過的商品物件，<br>商品可以數百萬種，瀏覽的商品可以只有幾十萬種，<br>請問老師像這樣的模型應該是在召回層還是排序層呢?","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":519424,"discussion_content":"问题意思不是特别清楚，试着答一下。\n\n其实召回层和排序层的划分并不是特别清楚，如果你认为这个模型的latency很低，可以高效的对大批候选物品打分，完全可以放在召回层，如果比较费计算资源，latency也很高，当然放在排序层好一些。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620582995,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290780,"user_name":"MutouMan","can_delete":false,"product_type":"c1","uid":2454131,"ip_address":"","ucode":"E2E78C6EE25E80","user_header":"https://static001.geekbang.org/account/avatar/00/25/72/73/d707c8be.jpg","comment_is_top":false,"comment_ctime":1619751311,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619751311","product_id":100060801,"comment_content":"Multiprocessing 或者分布式计算，这完全符合map reduce的用法","like_count":0},{"had_liked":false,"id":288704,"user_name":"Geek_3c29c3","can_delete":false,"product_type":"c1","uid":2203358,"ip_address":"","ucode":"3D2E73AB1D08FA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLaoiaerNMy7eoSA5yfibPNhta51jkhPTTL1dD1HGlnjaGnFQ6Uzbbce82Kpnic3g1JlD7rtm41Y83PA/132","comment_is_top":false,"comment_ctime":1618632981,"is_pvip":false,"replies":[{"id":"104861","content":"这有什么听说不听说的。不进行负采样和进行负采样的做法当然都存在，只靠听说自己不思考为什么这么做，那还怎么做事情。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1618773937,"ip_address":"","comment_id":288704,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618632981","product_id":100060801,"comment_content":"可是最近看到有些说召回的负样本要选取全量的物料采样负样本，而排序只是曝光未点击的作为负样本。<br>---------------------------------------------------历史留言<br>老师，请问召回我在网上看到有的正负样本的选取方法和排序不同：<br>1、涉及到选取正负样本的召回算法肯定是有监督的吧，一般都有啥啊？感觉你这里讲的都是无监督的呢。<br>2、正负样本的判定和排序具体有什么区别，有相关trick的好文章或者老师的见解可以学习的吗？<br><br>作者回复: 1. 当然可有通过构建轻量级的模型来做召回层，这样的方式肯定是有监督的。<br>2. 本质上不应该有区别，甚至现在越来越多把召回层当作一个轻量级的排序层。","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518714,"discussion_content":"这有什么听说不听说的。不进行负采样和进行负采样的做法当然都存在，只靠听说自己不思考为什么这么做，那还怎么做事情。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618773937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288103,"user_name":"Geek_3c29c3","can_delete":false,"product_type":"c1","uid":2203358,"ip_address":"","ucode":"3D2E73AB1D08FA","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLaoiaerNMy7eoSA5yfibPNhta51jkhPTTL1dD1HGlnjaGnFQ6Uzbbce82Kpnic3g1JlD7rtm41Y83PA/132","comment_is_top":false,"comment_ctime":1618301306,"is_pvip":false,"replies":[{"id":"104768","content":"1. 当然可有通过构建轻量级的模型来做召回层，这样的方式肯定是有监督的。<br>2. 本质上不应该有区别，甚至现在越来越多把召回层当作一个轻量级的排序层。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1618632282,"ip_address":"","comment_id":288103,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1618301306","product_id":100060801,"comment_content":"老师，请问召回我在网上看到有的正负样本的选取方法和排序不同：<br>1、涉及到选取正负样本的召回算法肯定是有监督的吧，一般都有啥啊？感觉你这里讲的都是无监督的呢。<br>2、正负样本的判定和排序具体有什么区别，有相关trick的好文章或者老师的见解可以学习的吗？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":518518,"discussion_content":"1. 当然可有通过构建轻量级的模型来做召回层，这样的方式肯定是有监督的。\n2. 本质上不应该有区别，甚至现在越来越多把召回层当作一个轻量级的排序层。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618632282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":281435,"user_name":"Alan","can_delete":false,"product_type":"c1","uid":2115316,"ip_address":"","ucode":"591A28E310A8F5","user_header":"https://static001.geekbang.org/account/avatar/00/20/46/f4/93b1275b.jpg","comment_is_top":false,"comment_ctime":1614750079,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614750079","product_id":100060801,"comment_content":"1、答：以音乐推荐系统为例类：音乐标签、音乐热门、音乐Topic、协同过滤、音乐编曲作者等多路的TOP N<br>2、答：那就是一章的局部敏感哈希多桶策略   的内容。个人喜欢基于余弦相似度的夹脚作为“近邻”判断标准。","like_count":0},{"had_liked":false,"id":280715,"user_name":"icode","can_delete":false,"product_type":"c1","uid":1247145,"ip_address":"","ucode":"F711C3A3EF3775","user_header":"https://static001.geekbang.org/account/avatar/00/13/07/a9/8544f545.jpg","comment_is_top":false,"comment_ctime":1614325706,"is_pvip":false,"replies":[{"id":"101934","content":"如果还没学习到推荐模型篇的话，建议再往后学习。有大量模型是同时生成item和user embedding的，特别典型的是双塔模型。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1614390239,"ip_address":"","comment_id":280715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1614325706","product_id":100060801,"comment_content":"老师，在此之前的课程获取embedding是通过序列化的item或者随机游走的item来生成训练样本 从而获取item对应的embedding，我理解这都是item单侧的生成embedding方式，所以最终生成的embedding通过计算余弦距离等方式来计算item之间的相似度；在本节课中讲解的是召回层，那么需要考虑到user和item的对应的embedding的相似性，请问采用何种方式训练可以让user侧的embedding和item侧的embedding有可比性呢？ 有什么paper推荐呢？谢谢老师解答","like_count":1,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516190,"discussion_content":"如果还没学习到推荐模型篇的话，建议再往后学习。有大量模型是同时生成item和user embedding的，特别典型的是双塔模型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614390239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279052,"user_name":"RobinHood","can_delete":false,"product_type":"c1","uid":2443984,"ip_address":"","ucode":"23A1DCCBF60F6C","user_header":"https://static001.geekbang.org/account/avatar/00/25/4a/d0/a7fd4750.jpg","comment_is_top":false,"comment_ctime":1613572942,"is_pvip":false,"replies":[{"id":"101705","content":"其实都可以。这个完全看你工程上的需求和选择。两者当然各有好处。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1614046114,"ip_address":"","comment_id":279052,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613572942","product_id":100060801,"comment_content":"老师，您好。本例中所讲的召回全都是实时召回吗？实际的工业生产环境中是不是离线召回和实时召回都包含呢？比如说在前一天的晚上凌晨会提前召回生成第二天排序要用的候选集。","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515611,"discussion_content":"其实都可以。这个完全看你工程上的需求和选择。两者当然各有好处。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614046114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271970,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1629141,"ip_address":"","ucode":"8AC3F3AB9BB6BF","user_header":"","comment_is_top":false,"comment_ctime":1609898547,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609898547","product_id":100060801,"comment_content":"userEmb = user._2.foldRight[Array[Float]](userEmb)((row, newEmb) =&gt; {<br>          val movieId = row.getAs[String](&quot;movieId&quot;)<br>          val movieEmb = word2VecModel.getVectors.get(movieId)<br>          if(movieEmb.isDefined){<br>            newEmb.zip(movieEmb.get).map { case (x, y) =&gt; x + y }<br>          }else{<br>            newEmb<br>          }<br>        }) <br>不理解上面的思路","like_count":0},{"had_liked":false,"id":270843,"user_name":"Macielyoung","can_delete":false,"product_type":"c1","uid":2298734,"ip_address":"","ucode":"DC33AC43B0B5BA","user_header":"https://static001.geekbang.org/account/avatar/00/23/13/6e/f1e23980.jpg","comment_is_top":false,"comment_ctime":1609299211,"is_pvip":false,"replies":[{"id":"98283","content":"有点这个意思，接着往后学习，相信你会得到答案。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1609355066,"ip_address":"","comment_id":270843,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1609299211","product_id":100060801,"comment_content":"对于提升计算Embedding相似度的速度这块，我想是不是通过分治法来做，每一部分处理一小部分数据集，选出Top k，合并再去计算求出Top k，有点像大数排序的问题。","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512765,"discussion_content":"有点这个意思，接着往后学习，相信你会得到答案。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609355066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270728,"user_name":"邓生","can_delete":false,"product_type":"c1","uid":2151666,"ip_address":"","ucode":"9A6A95784C0166","user_header":"https://static001.geekbang.org/account/avatar/00/20/d4/f2/979e5346.jpg","comment_is_top":false,"comment_ctime":1609230315,"is_pvip":false,"replies":[{"id":"98280","content":"是的，由于这里的user emb是通过average 历史行为item emb得到的，所以他们在一个向量空间","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1609354945,"ip_address":"","comment_id":270728,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1609230315","product_id":100060801,"comment_content":"请问老师，我不是很理解为什么电影Embedding和用户Embedding可以直接计算相似度，它们之间有可比性吗？是处于同一个向量空间吗？原因","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512732,"discussion_content":"是的，由于这里的user emb是通过average 历史行为item emb得到的，所以他们在一个向量空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609354945,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270446,"user_name":"tiger","can_delete":false,"product_type":"c1","uid":2298602,"ip_address":"","ucode":"43F70BE0B83B1C","user_header":"https://static001.geekbang.org/account/avatar/00/23/12/ea/79effe93.jpg","comment_is_top":false,"comment_ctime":1609129792,"is_pvip":false,"replies":[{"id":"98141","content":"物品详情页的相似物品并没有用到user embedding，像你说的，就利用item embedding的相似度取topk得到的。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1609200221,"ip_address":"","comment_id":270446,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1609129792","product_id":100060801,"comment_content":"老师您好，在SparrowRecsys中，我并没有登录，但是我点击电影，也会有相似推荐，但是我看里面说要用用户的embedding和物品的embedding。我的理解不应该实现物品相似推荐就直接用物品和物品之间的embedding去计算相似度，然后取出topK？这样做可以吗？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512629,"discussion_content":"物品详情页的相似物品并没有用到user embedding，像你说的，就利用item embedding的相似度取topk得到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609200221,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269563,"user_name":"Capricornus","can_delete":false,"product_type":"c1","uid":2371321,"ip_address":"","ucode":"B7B15C58653860","user_header":"https://static001.geekbang.org/account/avatar/00/24/2e/f9/c0a6232c.jpg","comment_is_top":false,"comment_ctime":1608701740,"is_pvip":false,"replies":[{"id":"97759","content":"再往下学一学，看看推荐模型篇能不能给你一些启发。还有问题的话再留言讨论。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1608714182,"ip_address":"","comment_id":269563,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608701740","product_id":100060801,"comment_content":"老师，针对冷启动问题和用户自定义标签，特别是用户自定义标签，怎么把用户自定义的标签兴趣联系起来，作出合适的兴趣推荐啊？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":512323,"discussion_content":"再往下学一学，看看推荐模型篇能不能给你一些启发。还有问题的话再留言讨论。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608714182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267882,"user_name":"Geek_033ad5","can_delete":false,"product_type":"c1","uid":1739445,"ip_address":"","ucode":"F06909971DA28F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dliaGpsxSic6Km3NGL5A3FVOBuQ9qiaUZ1ewCSNPaxxqHBPQ66rc19bRKA9EDy3H1P1wfSMPF4CuTx7X7GPs57CRQ/132","comment_is_top":false,"comment_ctime":1607961827,"is_pvip":false,"replies":[{"id":"97282","content":"你觉得可以吗？想听听你的思考","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1607992905,"ip_address":"","comment_id":267882,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1607961827","product_id":100060801,"comment_content":"还想请教下，矩阵分解产生的用户物品embedding是否可以跟序列产生拼接，一起作为输入使用？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511773,"discussion_content":"你觉得可以吗？想听听你的思考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607992905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1739445,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/dliaGpsxSic6Km3NGL5A3FVOBuQ9qiaUZ1ewCSNPaxxqHBPQ66rc19bRKA9EDy3H1P1wfSMPF4CuTx7X7GPs57CRQ/132","nickname":"Geek_033ad5","note":"","ucode":"F06909971DA28F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335073,"discussion_content":"我想既然矩阵分解是通过用户物品的评分矩阵而来，其隐语义概念也表示了不同用户和物品间的异同信息，那应该可以作为用户和物品的附加信息输入一起训练，不知道这样理解对不对","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608085041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267881,"user_name":"Geek_033ad5","can_delete":false,"product_type":"c1","uid":1739445,"ip_address":"","ucode":"F06909971DA28F","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/dliaGpsxSic6Km3NGL5A3FVOBuQ9qiaUZ1ewCSNPaxxqHBPQ66rc19bRKA9EDy3H1P1wfSMPF4CuTx7X7GPs57CRQ/132","comment_is_top":false,"comment_ctime":1607961538,"is_pvip":false,"replies":[{"id":"97283","content":"这是一个比较差的问题。不够准确，没有重点，没有意义。在学习了两种方法的细节之后，你自己完全可以解答这个问题，希望大家今后不要问这类问题。","user_name":"作者回复","user_name_real":"王喆","uid":"1662192","ctime":1607993060,"ip_address":"","comment_id":267881,"utype":1}],"discussion_count":4,"race_medal":0,"score":"1607961538","product_id":100060801,"comment_content":"请问，矩阵分解也可以产生用户和物品的embedding，跟这种通过序列生成的方法相比如何呢？","like_count":0,"discussions":[{"author":{"id":1662192,"avatar":"https://static001.geekbang.org/account/avatar/00/19/5c/f0/46214d29.jpg","nickname":"王喆","note":"","ucode":"2EDC616F905F3F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511772,"discussion_content":"这是一个比较差的问题。不够准确，没有重点，没有意义。在学习了两种方法的细节之后，你自己完全可以解答这个问题，希望大家今后不要问这类问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607993060,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2403705,"avatar":"","nickname":"Wa","note":"","ucode":"96E28E50FCA96C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":342202,"discussion_content":"可以读原paper《Item2Vec: Neural Item Embedding for Collaborative Filtering》，里面有与svd全面的比较","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1610613812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1944884,"avatar":"","nickname":"AstrHan","note":"","ucode":"14C5F3323A472D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":337798,"discussion_content":"我想到的一点是SVD对冷门的数据很不友好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609078213,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1739445,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/dliaGpsxSic6Km3NGL5A3FVOBuQ9qiaUZ1ewCSNPaxxqHBPQ66rc19bRKA9EDy3H1P1wfSMPF4CuTx7X7GPs57CRQ/132","nickname":"Geek_033ad5","note":"","ucode":"F06909971DA28F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335075,"discussion_content":"应该是我没有表达好，我想了解的是有没有在生产环境中的真实指标来对比过这两个算法的优劣，因为矩阵分解也是比较经典的算法，但现在生产好像更流行DEEPWALK等算法，所以我想是不是有指标说明后者确实要优于前者","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608085320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}