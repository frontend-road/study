{"id":782504,"title":"20｜创建对象：支持对象创建和访问属性以完成基本对象系统","content":"<p>你好，我是海纳。</p><p>上一节课，我们通过 class 关键字定义了类型对象。同时，第 18 课也讲过可以通过 list、dict、str 等类型对象来创建实例。自定义类型对象也应该与内建类型对象具有同样的功能，开发者应该可以像函数一样调用类型对象，创建类型实例。</p><p>这一节课，我们就来实现这个功能。</p><h2>通过自定义类型创建实例</h2><p>下面这个例子展示了如何像函数一样调用类型对象来创建对应的实例。</p><pre><code class=\"language-c++\">class A(object):\n    value = 1\n\na = A()\nprint(a.value)\n</code></pre><p>这个字节码和之前通过 list、int 等创建实例时的字节码是相同的，都是生成了 CALL_FUNCTION 指令，这里我就不再重复了。</p><p>ListKlass 里已经实现了 allocate_instance 方法，用来创建新的列表对象。和它差不多，我们也可以在 Klass 中实现这个方法，从而让普通的自定义类型对象也可以创建实例。你可以看一下对应的代码。</p><pre><code class=\"language-c++\">HiObject* Klass::allocate_instance(HiList* args) {\n&nbsp; &nbsp; HiObject* inst = new HiObject();\n&nbsp; &nbsp; inst-&gt;set_klass(this);\n&nbsp; &nbsp; return inst;\n}\n</code></pre><p>Klass 在创建实例的时候，只要把实例对象的 klass 指针指向自己就完成了最简单的创建对象功能。增加了这个方法以后，刚刚那个例子就能正确执行了。</p><!-- [[[read_end]]] --><h2>动态设置对象属性</h2><p>自定义类型的对象和内建类型的对象不一样，它可以动态添加属性，而内建类型对象是不行的。你可以看一下我给出的这个例子。</p><pre><code class=\"language-python\">class A(object):\n&nbsp; &nbsp; value = 1\n\na = A()\nprint(a.value)\n\n#this is OK\na.field = \"hello\"\n#&nbsp; 44 LOAD_CONST&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 ('hello')\n#&nbsp; 47 LOAD_NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 (a)\n#&nbsp; 50 STORE_ATTR&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4 (field)\nprint(a.field)\n\n# this is wrong\n#lst = []\n#lst.field = \"hello\"\n\nb = A()\n# this is wrong, too\n#print(b.field)\n</code></pre><p>这段代码展示了如何为对象 a 设置一个它本来没有属性，因为对象 a 是由自定义类型 A 实例化而得到的（第 8 行）。这一行代码所对应的字节码我以注释的形式写在里面了，其中出现了一个新的字节码：<strong>STORE_ATTR</strong>。它的作用是把 a 的 field 属性设置成字符串hello。</p><p>请注意，这个字节码仅仅修改 a 这一个对象，它不会对类型 A 起作用。也就是说，在修改对象 a 以后，代码再通过 A 创建另外一个对象 b， b 不会出现 field 这个属性（第 20 行）。这也就提示了我们，需要在对象上添加一个属性字典，用来记录这些动态添加的属性。</p><pre><code class=\"language-c++\">class HiObject {\nprivate:\n&nbsp; &nbsp; Klass*&nbsp; _klass;\n&nbsp; &nbsp; HiDict* _obj_dict;\n...\n};\n</code></pre><p>我们在 HiObject 的定义里添加 _obj_dict，之后就可以实现 STORE_ATTR 这条字节码了。</p><pre><code class=\"language-c++\">// [runtime/interpreter.cpp]\nvoid Interpreter::eval_frame() {\n&nbsp; &nbsp; while (_frame-&gt;has_more_codes()) {\n\t&nbsp; &nbsp; unsigned char op_code = _frame-&gt;get_op_code();\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; switch (op_code) {\n\t\t...\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; case ByteCode::STORE_ATTR:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; v = _frame-&gt;_names-&gt;get(op_arg);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; w = POP();\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u-&gt;setattr(v, w);\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;\n&nbsp; &nbsp; &nbsp; &nbsp; ...\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; }\n}\n\n// [object/hiObject.cpp]\nHiObject* HiObject::setattr(HiObject* x, HiObject* y) {\n    return klass()-&gt;setattr(this, x, y);\n}\n\n// [object/klass.cpp]\n// setattr for normal object.\nHiObject* Klass::setattr(HiObject* obj, HiObject* x, HiObject* y) {\n    obj-&gt;obj_dict()-&gt;put(x, y);\n    return Universe::HiNone;\n}\n</code></pre><p>对于普通对象，setattr 方法的实现比较简单，只需要把 key 和 value 放到属性字典里就可以了。但是 TypeOjbect 的做法有些不一样。因为 TypeObject 代表的是一个类型，对它进行设置就应该放到代表类型的 Klass 的 klass_dict 里去，这样才能保证所有的实例都可以通过访问自己的 Klass 来获取类型中定义的属性，比如例子里 class A 的 value 属性。所以我们可以来实现 TypeObject 的 setattr 方法，你可以看一下对应的代码。</p><pre><code class=\"language-c++\">HiObject* TypeKlass::setattr(HiObject* obj, HiObject* x, HiObject* y) {\n    obj-&gt;as&lt;HiTypeObject&gt;()-&gt;own_klass()-&gt;klass_dict()-&gt;put(x, y);\n    return Universe::HiNone;\n}\n</code></pre><p>这段代码的作用是在 TypeObject 对应的 own_klass 中修改类的属性，这就保证了设置 TypeObject 属性的时候，修改的是类属性。</p><p>同时，getattr 方法也要做相应地修改。</p><pre><code class=\"language-c++\">// [object/hiObject.cpp]\nHiObject* HiObject::getattr(HiObject* x) {\n&nbsp; &nbsp; return klass()-&gt;getattr(this, x);\n}\n\n// [object/klass.cpp]\n// getattr for normal object.\n// a = A()\n// a.b = 1\nHiObject* Klass::getattr(HiObject* x, HiObject* y) {\n    if (x-&gt;obj_dict()-&gt;has_key(y)) {\n        return x-&gt;obj_dict()-&gt;get(y);\n    }\n\n    HiObject* result = _klass_dict-&gt;get(y);\n    // Only klass attribute needs bind.\n    if (!MethodObject::is_method(result) &amp;&amp;\n        MethodObject::is_function(result)) {\n        result = new MethodObject(result-&gt;as&lt;FunctionObject&gt;(), x);\n    }\n\n    return result;\n}\n</code></pre><p>getattr 方法要先从对象的属性字典里查找（第 11 至 13 行），如果找不到结果，再从类属性字典里查找（第 15 行）。</p><p>在实现 LOAD_METHOD 指令的时候，我们讲过 Python 语言中方法和函数的区别。如果从 klass 的 dict 里找到的目标对象是一个函数的话，要把函数与调用对象绑定在一起，合成一个 MethodObject（第 17 至 20 行）。</p><p>如果一个函数没有绑定对象，我们就叫它 unbound function，如果绑定了对象，它就是一个方法，我们叫它 bound method。</p><p>接下来我们通过测试用例来体验一下它们的不同，先看 bound method。</p><pre><code class=\"language-c++\">class A(object):\n&nbsp; &nbsp; pass\n\na = A()\nlst = []\nlst.append(2)\nprint(lst)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # [2,]\na.foo = lst.append\na.foo(3)\nprint(lst)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; # [2, 3]\n</code></pre><p>在这段代码里，获取列表的 append 方法的时候会得到一个与 lst 对象相绑定的方法对象（第 8 行）。然后程序把它设置为对象 a 的 foo 属性。</p><p>通过 a 的 foo 属性再去访问这个方法对象时（第 9 行），尽管看上去程序是通过 a 对象进行调用的，但是这里获取到的方法对象绑定的目标对象还是 lst。所以这次方法调用的结果仍然是向 lst 对象中添加数字 3。</p><p>接下来我们再看 unbound function 的例子。</p><pre><code class=\"language-python\">class A(object):\n&nbsp; &nbsp; pass\n\na = A()\na.value = 1\nb = A()\nb.value = 2\n\ndef func(self, s):\n&nbsp; &nbsp; print(self.value)\n\na.bar = func\nA.bar = func\n\na.bar(a, \"hello\")\nb.bar(\"world\")\n</code></pre><p>func 是一个函数对象，把它设置为 a 对象的 bar 属性（第 12 行）。经过 a.bar 调用时，由于这个属性是设置在 a 对象上的，所以在查找的过程并不会发生绑定（第 15 行）。在传参的时候，就必须传两个参数，显式地将 a 作为实参的第一位传递到函数里。</p><p>如果 func 这个函数对象设置为类型 A 的属性（第 13 行），调用的时候就会发生绑定，将对象 b 与 func 函数绑定为一个方法（第 16 行），调用时就不必再显式地将 b 作为参数，b 会被隐式地传递到函数中。</p><p>到这里，在对象上设置属性的功能就全部完成了。接下来，我们就可以在初始化方法里设置对象属性了。</p><h2>初始化方法</h2><p>在前边的例子中，我们在定义类的时候，都没有显式地定义 <code>__init__</code> 方法。</p><p>如果我们显式地定义了 <code>__init__</code> 方法，在创建对象的时候，Python 虚拟机就默认会调用 <code>__init__</code> 方法。很多人按照C++的习惯把这个方法叫做构造方法，但我们这里还是采用 Python 社区的名称，称之为<strong>初始化方法</strong>。</p><p>在上一节课，internal_exec 函数中通过 call_virtual 实现了执行 CodeObject 的功能。这里的初始化方法也是由 C++ 代码调用 Python 代码，所以我们也使用 call_virtual 来达成同样的目标。</p><pre><code class=\"language-c++\">// [runtime/stringTable.cpp]\nStringTable::StringTable() {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; init_str = new HiString(\"__init__\");\n}\n\n// [object/klass.cpp]\nHiObject* Klass::allocate_instance(HiList* args) {\n&nbsp; &nbsp; HiObject* inst = new HiObject();\n&nbsp; &nbsp; inst-&gt;set_klass(this);\n&nbsp; &nbsp; HiObject* constructor = inst-&gt;getattr(ST(init));\n&nbsp; &nbsp; if (constructor != Universe::HiNone) {\n&nbsp; &nbsp; &nbsp; &nbsp; Interpreter::get_instance()-&gt;call_virtual(constructor, args);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return inst;\n}\n</code></pre><p>在创建对象的时候，先创建一个 HiObject（第 9 行），然后设置它的 klass（第 10 行），再去新创建的对象上查找 <code>__init__</code> 方法并执行（第 11 至 14 行）。</p><p>这里我们使用对象的 getattr 去查找，是为了自动地将对象与初始化方法绑定起来。</p><p>完成了这些修改，这个测试用例就可以正确执行了。</p><pre><code class=\"language-c++\">class Vector(object):\n&nbsp; &nbsp; def __init__(self, x, y, z):\n&nbsp; &nbsp; &nbsp; &nbsp; self.x = x\n&nbsp; &nbsp; &nbsp; &nbsp; self.y = y\n&nbsp; &nbsp; &nbsp; &nbsp; self.z = z\n\n&nbsp; &nbsp; def say(self):\n&nbsp; &nbsp; &nbsp; &nbsp; print(self.x)\n&nbsp; &nbsp; &nbsp; &nbsp; print(self.y)\n&nbsp; &nbsp; &nbsp; &nbsp; print(self.z)\n\na = Vector(1, 2, 3)\nb = Vector(4, 5, 6)\n\na.say()\nb.say()\n</code></pre><p>对象的初始化和普通的属性访问，方法调用的功能已经全部实现了。下面我们来研究 Python 3 中非常不容易理解的一个特性：元类。我们先从 type 对象开始分析。</p><h2>再论 type 对象</h2><p>你可能已经发现了，Python 3 虚拟机中的 type 符号和我们的 type 符号是不同的。你可以看一下Python 3 中执行 print(type) 的结果。</p><pre><code class=\"language-c++\">&gt;&gt;&gt; print(type)\n&lt;class 'type'&gt;\n</code></pre><p>而我们的虚拟机中现在还不能打印出有用的信息，因为 type 指向的是一个函数，用于打印对象类型。</p><p>从刚刚的结果中可以看到，type 实际上是一个<strong>类型对象</strong>，对应到我们的虚拟机中就是 TypeObject，而不应该是一个 FunctionObject。</p><p>但是同时，type 又可以像函数一样被调用，而且它有两种用法。第一种是接受一个参数，返回参数的类型，例如：</p><pre><code class=\"language-python\">&gt;&gt;&gt; type(1)\n&lt;class 'int'&gt;\n</code></pre><p>这种用法我们已经实现过了，只不过当时是把 type 作为一个内建函数来实现的。</p><p>第二种用法是接受三个参数，用于定义一种新的类型，例如：</p><pre><code class=\"language-python\">&gt;&gt;&gt; attrs = {\"value\" : 1}\n&gt;&gt;&gt; A = type(\"A\", (object,), attrs)\n&gt;&gt;&gt; A\n&lt;class '__main__.A'&gt;\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.value\n1\n</code></pre><p>这种写法和使用 class 关键字定义一个名为 A 的类是完全等价的。type 接受的第一个参数是类名称，第二个参数是父类列表，第三个参数是类的属性定义。</p><p>本质上，Python 中的 type 关键字应该是 TypeKlass 所对应的 TypeObject，用来代表 type 这种类型。这里我们可以把调用虚拟机对象统一到 HiObject 的 call 方法，然后由各自对应的 Klass 来决定具体应该做什么事情。所以我们先做一次重构，把除了 FunctionObject 之外的调用路径全部归到 call 方法里。</p><pre><code class=\"language-c++\">void Interpreter::build_frame(HiObject* callable, HiList* args, HiList* kwargs) {\n&nbsp; &nbsp; if (MethodObject::is_method(callable)) {\n&nbsp; &nbsp; &nbsp; &nbsp; //...\n&nbsp; &nbsp; }\n&nbsp; &nbsp; else if (callable-&gt;klass() == FunctionKlass::get_instance()) {\n&nbsp; &nbsp; &nbsp; &nbsp; //...\n&nbsp; &nbsp; }\n&nbsp; &nbsp; else { // 除了函数对象之外，全部统一在这里处理\n&nbsp; &nbsp; &nbsp; &nbsp; PUSH(callable-&gt;call(args, nullptr));\n&nbsp; &nbsp; }\n}\n\n// vm/object/hiObject.cpp\nHiObject* HiObject::call(HiList* args, HiDict* kwargs) {\n&nbsp; &nbsp; return klass()-&gt;call(this, args, kwargs);\n}\n</code></pre><p>Interpreter 中的 build_frame 是处理 CALL_FUNCTION 指令的方法。在这个方法里除了函数对象之外，其他的所有对象都使用这个对象的 call 方法来处理（第 8 至 10 行）。</p><p>在 HiObject  的 call 方法，则进一步调用对象相应的 klass 中的 call 方法来执行具体的逻辑（第 14 至16 行）。</p><p>接下来我们就可以实现 TypeKlass 的 call 方法了。你看一下我给出的代码。</p><pre><code class=\"language-c++\">HiObject* TypeKlass::call(HiObject* x, HiList* args, HiDict* kwargs) {\n&nbsp; &nbsp; // The type object.\n&nbsp; &nbsp; HiTypeObject* to = x-&gt;as&lt;HiTypeObject&gt;();\n&nbsp; &nbsp; if (to-&gt;klass() != to-&gt;own_klass()) {\n&nbsp; &nbsp; &nbsp; &nbsp; return to-&gt;own_klass()-&gt;allocate_instance(args);\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; if (args-&gt;length() == 1) {\n&nbsp; &nbsp; &nbsp; &nbsp; return type_of(args, nullptr);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; else if (args-&gt;length() == 3) {\n&nbsp; &nbsp; &nbsp; &nbsp; HiString* name = args-&gt;get(0)-&gt;as&lt;HiString&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; HiList* supers = args-&gt;get(1)-&gt;as&lt;HiList&gt;();\n&nbsp; &nbsp; &nbsp; &nbsp; HiDict* attrs&nbsp; = args-&gt;get(2)-&gt;as&lt;HiDict&gt;();\n\n&nbsp; &nbsp; &nbsp; &nbsp; HiTypeObject* inst = new HiTypeObject();\n&nbsp; &nbsp; &nbsp; &nbsp; inst-&gt;set_klass(this);\n&nbsp; &nbsp; &nbsp; &nbsp; inst-&gt;set_own_klass(new Klass());\n&nbsp; &nbsp; &nbsp; &nbsp; if (supers-&gt;length() &gt; 0) {\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inst-&gt;own_klass()-&gt;set_super(supers-&gt;get(0)-&gt;as&lt;HiTypeObject&gt;()-&gt;own_klass());\n&nbsp; &nbsp; &nbsp; &nbsp; }\n&nbsp; &nbsp; &nbsp; &nbsp; inst-&gt;own_klass()-&gt;set_klass_dict(attrs);\n\n&nbsp; &nbsp; &nbsp; &nbsp; return inst;\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; return nullptr;\n}\n</code></pre><p>请注意，调用 list、int、dict 等 TypeObject 的时候，也会走到 TypeKlass 的 call 方法里，因为这些对象的 _klass 属性都是 TypeKlass。对它们进行调用，实际上是为了创建对象。</p><p>在 call 方法开始的地方，我们就做了一个判断，确定当前参数 x 是不是 TypeKlass 的 TypeObject （或者说就是 type 类型）。如果不是的话，就说明 x 是一个普通的类型对象，只需要转而调用它的 own_klass 的 allocate_instance 来创建对象就可以了（第 4 至 6 行）。</p><p>如果是 type 类型，那么就根据参数的个数来决定要调用什么函数进行处理。如果参数的个数为 1，那就返回参数类型（第 8 至 10 行）。如果参数个数为 3，就创建新的类型（第 11 至 24 行）。</p><p>创建新类型的逻辑和 build_class 函数非常像，所以这里我就不再过多解释了。而作为普通自定义对象的 Klass 类，它的 allocate_instance 要注意在创建对象以后，还要检查类型里是否定义了 <code>__init__</code> 方法。如果定义了，就需要进一步调用这个方法来初始化一个对象。</p><pre><code class=\"language-c++\">HiObject* Klass::allocate_instance(HiList* args) {\n&nbsp; &nbsp; HiObject* inst = new HiObject();\n&nbsp; &nbsp; inst-&gt;set_klass(this);\n&nbsp; &nbsp; if (_klass_dict-&gt;has_key(ST(init))) {\n&nbsp; &nbsp; &nbsp; &nbsp; Interpreter::get_instance()-&gt;call_virtual(_klass_dict-&gt;get(ST(init)), args);\n&nbsp; &nbsp; }\n&nbsp; &nbsp; return inst;\n}\n</code></pre><p>type 类型还有更多的高级用法，比如用于创建元类等。这会涉及类型的继承体系，所以我们会在整个课程的最后再来实现这个功能。到此为止， type 类型的重构工作就可以告一段落了。</p><p>你应该注意到了，<code>__init__</code> 方法的开始和结尾处都有两个下划线，代表它是一个特殊函数，只在特定的时机起作用。接下来，我们研究另一类特殊函数，它们可以用于实现操作的重载功能。</p><h2>特殊函数和操作符重载</h2><p>很多语言都有操作符重载的概念，比如在 C++ 中，我们可以这样实现操作符重载。</p><pre><code class=\"language-c++\">class Int {\nprivate:\n&nbsp; &nbsp; &nbsp; &nbsp; int _value;\npublic:\n&nbsp; &nbsp; Int(int v) : _value(v) {}\n&nbsp; &nbsp; int value() {\n&nbsp; &nbsp; &nbsp; &nbsp; return _value;\n&nbsp; &nbsp; }&nbsp; &nbsp;\n\n&nbsp; &nbsp; Int operator + (Int&amp; t) {\n&nbsp; &nbsp; &nbsp; &nbsp; return Int(_value + t.value());\n&nbsp; &nbsp; }\n};\n\nint main() {\n&nbsp; &nbsp; Int a(1);\n&nbsp; &nbsp; Int b(2);\n&nbsp; &nbsp; Int c = a + b;\n&nbsp; &nbsp; printf(\"%d\\n\", c.value());&nbsp; // 3\n&nbsp; &nbsp; return 0;\n}\n</code></pre><p>这段代码先为 Int 类型重载了加法操作符（第 10 至 12 行），然后在 main 函数中使用加法操作符进行运算（第 18 行）。可见操作符重载可以让 Int 类型的加法运算表现得像普通整数。</p><p>Python 中也有像 C++ 一样的操作符重载的功能，那就是可以通过在类型里定义一个特殊函数来实现。比如，通过在类型里添加 <code>__add__</code> 方法，可以让 Python 对象支持加法运算。你可以参考我给出的这个例子。</p><pre><code class=\"language-python\">class A(object):\n&nbsp; &nbsp; def __init__(self, v):\n&nbsp; &nbsp; &nbsp; &nbsp; self.value = v\n\n&nbsp; &nbsp; def __add__(self, a):\n&nbsp; &nbsp; &nbsp; &nbsp; print \"executing operator +\"\n&nbsp; &nbsp; &nbsp; &nbsp; return A(self.value + a.value)\n\na = A(1)\nb = A(2)\nc = a + b&nbsp; &nbsp; &nbsp; &nbsp;# executing operator +\nprint(a.value)&nbsp; &nbsp;# 1\nprint(b.value)&nbsp; &nbsp;# 2\nprint(c.value)&nbsp; &nbsp;# 3\n</code></pre><p>我使用注释的形式把代码的执行结果标记出来。如果使用 show_file 查看这段代码的字节码，就会发现加法运算会被翻译成 BINARY_ADD（第 11 行）。实际上，对于  BINARY_ADD 指令，虚拟机的真实动作是把对象 b 作为参数，调用对象 a 的 <code>__add__</code> 方法。</p><p>字节码 BINARY_ADD 原本的实现是调用了 HiObject 的 add 方法，然后再分派到这个对象所对应的 klass 上，调用 klass的 add 方法。比如，整数对象就会调用 IntegerKlass 的 add 方法，字符串对象就会调用 StringKlass 的 add 方法。</p><p>自定义类型的 klass 就是 Klass 类，所以我们可以在 Klass 类里增加调用 <code>__add__</code> 方法的逻辑。</p><pre><code class=\"language-c++\">// [runtime/stringTable.cpp]\nStringTable::StringTable() {\n&nbsp; &nbsp; ...\n&nbsp; &nbsp; add_str&nbsp; = new HiString(\"__add__\");\n}\n\n// [object/klass.cpp]\n#define ST(x) StringTable::get_instance()-&gt;STR(x)\n#define STR(x) x##_str\n\nHiObject* Klass::add(HiObject* lhs, HiObject* rhs) {\n&nbsp; &nbsp; ObjList args = new ArrayList&lt;HiObject*&gt;();\n&nbsp; &nbsp; args-&gt;add(rhs);\n&nbsp; &nbsp; return find_and_call(lhs, args, ST(add));\n}\n\nHiObject* Klass::find_and_call(HiObject* lhs, ObjList args, HiObject* func_name) {\n&nbsp; &nbsp; HiObject* func = lhs-&gt;getattr(func_name);\n&nbsp; &nbsp; if (func != Universe::HiNone) {\n&nbsp; &nbsp; &nbsp; &nbsp; return Interpreter::get_instance()-&gt;call_virtual(func, args);\n&nbsp; &nbsp; }\n\n&nbsp; &nbsp; printf(\"class \");\n&nbsp; &nbsp; lhs-&gt;klass()-&gt;name()-&gt;print();\n&nbsp; &nbsp; printf(\" Error : unsupport operation for class \");\n&nbsp; &nbsp; assert(false);\n&nbsp; &nbsp; return Universe::HiNone;\n}\n</code></pre><p>为了使代码更简洁，这里我们使用了宏来代替某些字符输入（第 8 行和第 9 行）。使用 C++ 编程尽量不要使用宏，因为宏带来的问题难以调试。这里我们只用宏来减少简单代码的输入。<strong>STR 宏里使用了一个宏的技巧：双井号代表字符串的拼接</strong>，所以 STR(add) 就会被替换成 add_str。</p><p>Klass 类里， add 方法的逻辑是在对象 lhs 上查找 <code>__add__</code> 方法，然后调用就可以了（第 17 至 27 行）。从虚拟机中调用 Python 代码，使用 call_virtual 就可以实现。代码的最后是出错以后的处理，打印错误信息并退出（第 23 至 27 行）。</p><p>支持了加法操作，我们还可以继续支持其他类型的运算符，比如减法、乘法、与操作等，你可以看一下这些操作所对应的方法定义。</p><p><img src=\"https://static001.geekbang.org/resource/image/73/2b/737d8d43111c257720ea89875586692b.png?wh=1856x2300\" alt=\"图片\"></p><p>这部分我们只实现了加法的操作符重载，表中的操作符，不论是一元操作符还是二元操作符，实现都与 add 操作十分相似，这里就不再展开了，留给你自己实现吧。</p><h2>总结</h2><p>这节课我们重点实现了通过类型来创建对象的功能。</p><p>实现的整体逻辑链是这样的：</p><ol>\n<li>HiTypeObject 的 own_klass 是类型对象所代表的真正类型。所以对 HiTypeObject 执行 CALL_FUNCTION 指令时，实际上就是要使用 own_klass 来创建一个新的对象。</li>\n<li>创建新对象以后，要检查相对应的类型是否定义了  <code>__init__</code> 这个特殊的函数，如果定义了的话，就需要再调用这个函数初始化对象。</li>\n<li>初始化对象一般就要在对象上设置属性。而且对象属性的类属性完全不相同，即使是同名的属性也不会造成覆盖。这就要求每个自定义对象都有一个自己的专属属性字典。<br>\n完成了这些工作以后，自定义类型的功能就基本完成了。</li>\n</ol><p>这节课的第二部分我们重构了 type 对象，把它从 FunctionObject 变成了 TypeObject，并且统一了对象的 call 方法，引入了 <code>__call__</code> 这个特殊方法。</p><p>第三部分我们介绍了更多的特殊方法，尤其是与操作符重载相关的特殊方法。在原有的对象体系里增加特殊方法是比较容易的，我们使用加法操作符说明了这一点。</p><h2>思考题</h2><p>操作符重载是一个重要的语法特性，但也有很多语言选择不实现它。你知道它有哪些缺点吗？欢迎你把你的想法分享到评论区，也欢迎你把这节课的内容分享给其他朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"19｜自定义类型：面向对象编程的基础设施","id":782495},"right":{"article_title":"21｜继承和多态：完善面向对象编程的两大特征","id":785249}},"comments":[{"had_liked":false,"id":396237,"user_name":"冯某","can_delete":false,"product_type":"c1","uid":3889476,"ip_address":"上海","ucode":"7E78ECA53DF453","user_header":"https://static001.geekbang.org/account/avatar/00/3b/59/44/727b90a8.jpg","comment_is_top":false,"comment_ctime":1733721510,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"记录一下","like_count":0},{"had_liked":false,"id":395416,"user_name":"ifelse","can_delete":false,"product_type":"c1","uid":2550743,"ip_address":"浙江","ucode":"D0565908C99695","user_header":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","comment_is_top":false,"comment_ctime":1730703062,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":3,"score":2,"product_id":100761401,"comment_content":"操作符重载\n优点：增加代码可读性，提高复用度。\n缺点：增加理解难度，潜在可能错误。","like_count":0},{"had_liked":false,"id":393580,"user_name":"骨汤鸡蛋面","can_delete":false,"product_type":"c1","uid":1050002,"ip_address":"上海","ucode":"2AC141A523E710","user_header":"https://static001.geekbang.org/account/avatar/00/10/05/92/b609f7e3.jpg","comment_is_top":false,"comment_ctime":1724241839,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100761401,"comment_content":"老师，最近学习python元类的概念很懵逼， 可否结合python对象的创建过程介绍下python元类呢？","like_count":0}]}