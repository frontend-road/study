{"id":108582,"title":"25 | 内存持续上升，我该如何排查问题？","content":"<p>你好，我是刘超。</p><p>我想你肯定遇到过内存溢出，或是内存使用率过高的问题。碰到内存持续上升的情况，其实我们很难从业务日志中查看到具体的问题，<span class=\"orange\">那么面对多个进程以及大量业务线程，我们该如何精准地找到背后的原因呢？</span></p><h2>常用的监控和诊断内存工具</h2><p>工欲善其事，必先利其器。平时排查内存性能瓶颈时，我们往往需要用到一些Linux命令行或者JDK工具来辅助我们监测系统或者虚拟机内存的使用情况，下面我就来介绍几种好用且常用的工具。</p><h3>Linux命令行工具之top命令</h3><p>top命令是我们在Linux下最常用的命令之一，它可以实时显示正在执行进程的CPU使用率、内存使用率以及系统负载等信息。其中上半部分显示的是系统的统计信息，下半部分显示的是进程的使用率统计信息。</p><p><img src=\"https://static001.geekbang.org/resource/image/36/49/3633095ed54d1ef22fc08310497d6b49.jpg?wh=1778*660\" alt=\"\"></p><p>除了简单的top之外，我们还可以通过top -Hp pid查看具体线程使用系统资源情况：</p><p><img src=\"https://static001.geekbang.org/resource/image/1e/47/1e4429a9785ae4e6c0884655ee8b5747.jpg?wh=1630*780\" alt=\"\"></p><h3>Linux命令行工具之vmstat命令</h3><p>vmstat是一款指定采样周期和次数的功能性监测工具，我们可以看到，它不仅可以统计内存的使用情况，还可以观测到CPU的使用率、swap的使用情况。但vmstat一般很少用来查看内存的使用情况，而是经常被用来观察进程的上下文切换。</p><p><img src=\"https://static001.geekbang.org/resource/image/31/62/31a79622cdcadda4e9003b075378dc62.jpg?wh=1488*178\" alt=\"\"></p><ul>\n<li>r：等待运行的进程数；</li>\n<li>b：处于非中断睡眠状态的进程数；</li>\n<li>swpd：虚拟内存使用情况；</li>\n<li>free：空闲的内存；</li>\n<li>buff：用来作为缓冲的内存数；</li>\n<li>si：从磁盘交换到内存的交换页数量；</li>\n<li>so：从内存交换到磁盘的交换页数量；</li>\n<li>bi：发送到块设备的块数；</li>\n<li>bo：从块设备接收到的块数；</li>\n<li>in：每秒中断数；</li>\n<li>cs：每秒上下文切换次数；</li>\n<li>us：用户CPU使用时间；</li>\n<li>sy：内核CPU系统使用时间；</li>\n<li>id：空闲时间；</li>\n<li>wa：等待I/O时间；</li>\n<li>st：运行虚拟机窃取的时间。</li>\n</ul><!-- [[[read_end]]] --><h3>Linux命令行工具之pidstat命令</h3><p>pidstat是Sysstat中的一个组件，也是一款功能强大的性能监测工具，我们可以通过命令：yum install sysstat安装该监控组件。之前的top和vmstat两个命令都是监测进程的内存、CPU以及I/O使用情况，而pidstat命令则是深入到线程级别。</p><p>通过pidstat -help命令，我们可以查看到有以下几个常用的参数来监测线程的性能：</p><p><img src=\"https://static001.geekbang.org/resource/image/90/46/90d26ef49ad94510062ac3f36727a346.jpg?wh=1440*178\" alt=\"\"></p><p>常用参数：</p><ul>\n<li>-u：默认的参数，显示各个进程的cpu使用情况；</li>\n<li>-r：显示各个进程的内存使用情况；</li>\n<li>-d：显示各个进程的I/O使用情况；</li>\n<li>-w：显示每个进程的上下文切换情况；</li>\n<li>-p：指定进程号；</li>\n<li>-t：显示进程中线程的统计信息。</li>\n</ul><p>我们可以通过相关命令（例如ps或jps）查询到相关进程ID，再运行以下命令来监测该进程的内存使用情况：</p><p><img src=\"https://static001.geekbang.org/resource/image/18/61/184df3ee5ab0a920f506b3daa6250a61.jpg?wh=1562*460\" alt=\"\"></p><p>其中pidstat的参数-p用于指定进程ID，-r表示监控内存的使用情况，1表示每秒的意思，3则表示采样次数。</p><p>其中显示的几个关键指标的含义是：</p><ul>\n<li>Minflt/s：任务每秒发生的次要错误，不需要从磁盘中加载页；</li>\n<li>Majflt/s：任务每秒发生的主要错误，需要从磁盘中加载页；</li>\n<li>VSZ：虚拟地址大小，虚拟内存使用KB；</li>\n<li>RSS：常驻集合大小，非交换区内存使用KB。</li>\n</ul><p>如果我们需要继续查看该进程下的线程内存使用率，则在后面添加-t指令即可：</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/72/3c9072c659a91b5f83cbc1a112ddcc72.jpg?wh=1574*694\" alt=\"\"></p><p>我们知道，Java是基于JVM上运行的，大部分内存都是在JVM的用户内存中创建的，所以除了通过以上Linux命令来监控整个服务器内存的使用情况之外，我们更需要知道JVM中的内存使用情况。JDK中就自带了很多命令工具可以监测到JVM的内存分配以及使用情况。</p><h3>JDK工具之jstat命令</h3><p>jstat可以监测Java应用程序的实时运行情况，包括堆内存信息以及垃圾回收信息。我们可以运行jstat -help查看一些关键参数信息：</p><p><img src=\"https://static001.geekbang.org/resource/image/42/e8/42880a93eb63ae6854a7920e73a751e8.jpg?wh=1550*610\" alt=\"\"></p><p>再通过jstat -option查看jstat有哪些操作：</p><p><img src=\"https://static001.geekbang.org/resource/image/7a/7d/7af697d9cfd6002a49063ab2464d5f7d.jpg?wh=1506*386\" alt=\"\"></p><ul>\n<li>-class：显示ClassLoad的相关信息；</li>\n<li>-compiler：显示JIT编译的相关信息；</li>\n<li>-gc：显示和gc相关的堆信息；</li>\n<li>-gccapacity：显示各个代的容量以及使用情况；</li>\n<li>-gcmetacapacity：显示Metaspace的大小；</li>\n<li>-gcnew：显示新生代信息；</li>\n<li>-gcnewcapacity：显示新生代大小和使用情况；</li>\n<li>-gcold：显示老年代和永久代的信息；</li>\n<li>-gcoldcapacity ：显示老年代的大小；</li>\n<li>-gcutil：显示垃圾收集信息；</li>\n<li>-gccause：显示垃圾回收的相关信息（通-gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因；</li>\n<li>-printcompilation：输出JIT编译的方法信息。</li>\n</ul><p>它的功能比较多，在这里我例举一个常用功能，如何使用jstat查看堆内存的使用情况。我们可以用jstat -gc pid查看：</p><p><img src=\"https://static001.geekbang.org/resource/image/e5/68/e59188982cf5b75243a8c333bfead068.jpg?wh=2464*128\" alt=\"\"></p><ul>\n<li>S0C：年轻代中To Survivor的容量（单位KB）；</li>\n<li>S1C：年轻代中From Survivor的容量（单位KB）；</li>\n<li>S0U：年轻代中To Survivor目前已使用空间（单位KB）；</li>\n<li>S1U：年轻代中From Survivor目前已使用空间（单位KB）；</li>\n<li>EC：年轻代中Eden的容量（单位KB）；</li>\n<li>EU：年轻代中Eden目前已使用空间（单位KB）；</li>\n<li>OC：Old代的容量（单位KB）；</li>\n<li>OU：Old代目前已使用空间（单位KB）；</li>\n<li>MC：Metaspace的容量（单位KB）；</li>\n<li>MU：Metaspace目前已使用空间（单位KB）；</li>\n<li>YGC：从应用程序启动到采样时年轻代中gc次数；</li>\n<li>YGCT：从应用程序启动到采样时年轻代中gc所用时间(s)；</li>\n<li>FGC：从应用程序启动到采样时old代（全gc）gc次数；</li>\n<li>FGCT：从应用程序启动到采样时old代（全gc）gc所用时间(s)；</li>\n<li>GCT：从应用程序启动到采样时gc用的总时间(s)。</li>\n</ul><h3>JDK工具之jstack命令</h3><p>这个工具在模块三的<a href=\"https://time.geekbang.org/column/article/105234\">答疑课堂</a>中介绍过，它是一种线程堆栈分析工具，最常用的功能就是使用 jstack pid 命令查看线程的堆栈信息，通常会结合top -Hp pid 或 pidstat -p pid -t一起查看具体线程的状态，也经常用来排查一些死锁的异常。</p><p><img src=\"https://static001.geekbang.org/resource/image/28/88/2869503e8d5460e36b3fd3e1a52a8888.jpg?wh=2328*414\" alt=\"\"></p><p>每个线程堆栈的信息中，都可以查看到线程ID、线程的状态（wait、sleep、running 等状态）以及是否持有锁等。</p><h3>JDK工具之jmap命令</h3><p>在<a href=\"https://time.geekbang.org/column/article/108139\">第23讲</a>中我们使用过jmap查看堆内存初始化配置信息以及堆内存的使用情况。那么除了这个功能，我们其实还可以使用jmap输出堆内存中的对象信息，包括产生了哪些对象，对象数量多少等。</p><p>我们可以用jmap来查看堆内存初始化配置信息以及堆内存的使用情况：</p><p><img src=\"https://static001.geekbang.org/resource/image/80/3f/808870b42f5f6525d79f70fd287a293f.jpg?wh=1206*1304\" alt=\"\"></p><p>我们可以使用jmap -histo[:live] pid查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象：</p><p><img src=\"https://static001.geekbang.org/resource/image/74/7b/74f42fa2b48ceaff869472f6061c1c7b.jpg?wh=1516*1028\" alt=\"\"></p><p>我们可以通过jmap命令把堆内存的使用情况dump到文件中：</p><p><img src=\"https://static001.geekbang.org/resource/image/f3/17/f3c17fd9bb436599fb48cf151ee7ba17.jpg?wh=1310*144\" alt=\"\"></p><p>我们可以将文件下载下来，使用 <a href=\"http://www.eclipse.org/mat/\">MAT</a> 工具打开文件进行分析：</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/43/3cc14844625cebcc1cdb836e5ccbfc43.jpg?wh=1492*1384\" alt=\"\"></p><p>下面我们用一个实战案例来综合使用下刚刚介绍的几种工具，具体操作一下如何分析一个内存泄漏问题。</p><h2>实战演练</h2><p>我们平时遇到的内存溢出问题一般分为两种，一种是由于大峰值下没有限流，瞬间创建大量对象而导致的内存溢出；另一种则是由于内存泄漏而导致的内存溢出。</p><p>使用限流，我们一般就可以解决第一种内存溢出问题，但其实很多时候，内存溢出往往是内存泄漏导致的，这种问题就是程序的BUG，我们需要及时找到问题代码。</p><p><strong>下面我模拟了一个内存泄漏导致的内存溢出案例，我们来实践一下。</strong></p><p>我们知道，ThreadLocal的作用是提供线程的私有变量，这种变量可以在一个线程的整个生命周期中传递，可以减少一个线程在多个函数或类中创建公共变量来传递信息，避免了复杂度。但在使用时，如果ThreadLocal使用不恰当，就可能导致内存泄漏。</p><p>这个案例的场景就是ThreadLocal，下面我们模拟对每个线程设置一个本地变量。运行以下代码，系统一会儿就发送了内存溢出异常：</p><pre><code>    @RequestMapping(value = &quot;/test0&quot;)\n    public String test0(HttpServletRequest request) {\n        ThreadLocal&lt;Byte[]&gt; localVariable = new ThreadLocal&lt;Byte[]&gt;();\n        localVariable.set(new Byte[4096*1024]);// 为线程添加变量\n        return &quot;success&quot;;\n    }\n</code></pre><p>在启动应用程序之前，我们可以通过HeapDumpOnOutOfMemoryError和HeapDumpPath这两个参数开启堆内存异常日志，通过以下命令启动应用程序：</p><pre><code>java -jar -Xms1000m -Xmx4000m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof  -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/tmp/heapTest.log heapTest-0.0.1-SNAPSHOT.jar\n</code></pre><p>首先，请求test0链接10000次，这个时候我们请求test0的接口报异常了。</p><p><img src=\"https://static001.geekbang.org/resource/image/60/dc/60ab8d7847a55a9bcf84d17ecd11ebdc.jpg?wh=2350*574\" alt=\"\"></p><p>通过日志，我们很好分辨这是一个内存溢出异常。我们首先通过Linux系统命令查看进程在整个系统中内存的使用率是多少，最简单就是top命令了。</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/37/d2ad570e1fff2a64a1924c2852f93e37.jpg?wh=1494*886\" alt=\"\"></p><p>从top命令查看进程的内存使用情况，可以发现在机器只有8G内存且只分配了4G内存给Java进程的情况下，Java进程内存使用率已经达到了55%，再通过top -Hp pid查看具体线程占用系统资源情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/6f/a7/6fdea40b5ff4f2f0744e019c3bef79a7.jpg?wh=1614*924\" alt=\"\"></p><p>再通过jstack pid查看具体线程的堆栈信息，可以发现该线程一直处于 TIMED_WAITING 状态，此时CPU使用率和负载并没有出现异常，我们可以排除死锁或I/O阻塞的异常问题了。</p><p><img src=\"https://static001.geekbang.org/resource/image/4b/87/4bfb58d626f988260e016a2bdf0e8687.jpg?wh=2330*386\" alt=\"\"></p><p>我们再通过jmap查看堆内存的使用情况，可以发现，老年代的使用率几乎快占满了，而且内存一直得不到释放：</p><p><img src=\"https://static001.geekbang.org/resource/image/fe/71/feb358259ea8b3ed2b67e868c101d271.jpg?wh=1350*1304\" alt=\"\"></p><p>通过以上堆内存的情况，我们基本可以判断系统发生了内存泄漏。下面我们就需要找到具体是什么对象一直无法回收，什么原因导致了内存泄漏。</p><p>我们需要查看具体的堆内存对象，看看是哪个对象占用了堆内存，可以通过jmap查看存活对象的数量：</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/d9/c5b89deb306a2c470e606fa9c49dd0d9.jpg?wh=1634*776\" alt=\"\"></p><p>Byte对象占用内存明显异常，说明代码中Byte对象存在内存泄漏，我们在启动时，已经设置了dump文件，通过MAT打开dump的内存日志文件，我们可以发现MAT已经提示了byte内存异常：</p><p><img src=\"https://static001.geekbang.org/resource/image/4c/63/4ceb91714afa77b54d1112a0e1f0c863.jpg?wh=1492*1376\" alt=\"\"></p><p>再点击进入到Histogram页面，可以查看到对象数量排序，我们可以看到Byte[]数组排在了第一位，选中对象后右击选择with incomming reference功能，可以查看到具体哪个对象引用了这个对象。</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/91/5a651a2f52dfed72712543f7680de091.jpg?wh=1486*1380\" alt=\"\"></p><p>在这里我们就可以很明显地查看到是ThreadLocal这块的代码出现了问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/a2/2bed3871097249d64ccf4c79d68109a2.jpg?wh=1498*1380\" alt=\"\"></p><h2>总结</h2><p>在一些比较简单的业务场景下，排查系统性能问题相对来说简单，且容易找到具体原因。但在一些复杂的业务场景下，或是一些开源框架下的源码问题，相对来说就很难排查了，<span class=\"orange\">有时候通过工具只能猜测到可能是某些地方出现了问题，而实际排查则要结合源码做具体分析。</span></p><p>可以说没有捷径，排查线上的性能问题本身就不是一件很简单的事情，除了将今天介绍的这些工具融会贯通，还需要我们不断地去累积经验，真正做到性能调优。</p><h2>思考题</h2><p>除了以上我讲到的那些排查内存性能瓶颈的工具之外，你知道要在代码中对JVM的内存进行监控，常用的方法是什么？</p><p>期待在留言区看到你的分享。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","neighbors":{"left":{"article_title":"24 | 如何优化JVM内存分配？","id":108139},"right":{"article_title":"26 | 答疑课堂：模块四热点问题解答","id":109201}},"comments":[{"had_liked":false,"id":114989,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1563444388,"is_pvip":false,"replies":[{"id":"42351","content":"赞！","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563760025,"ip_address":"","comment_id":114989,"utype":1}],"discussion_count":10,"race_medal":1,"score":"383815533732","product_id":100028001,"comment_content":"放两篇自己在工作中排查JVM问题的两篇文章【非广告，纯技术文】<br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;ji_8NhN4NnEHrfAlA9X_ag<br><br>https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;IPi3xiordGh-zcSSRie6nA","like_count":90,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458917,"discussion_content":"赞！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563760025,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1308783,"avatar":"https://static001.geekbang.org/account/avatar/00/13/f8/6f/080973cf.jpg","nickname":"Edward","note":"","ucode":"10FAADF92D05F4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":335391,"discussion_content":"mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608181315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2157237,"avatar":"https://static001.geekbang.org/account/avatar/00/20/ea/b5/f99c1ad3.jpg","nickname":"宸菡","note":"","ucode":"8F6B15B3070963","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":306775,"discussion_content":"感谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1600387693,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302826,"discussion_content":"图全部看不清，干嘛写在微信里","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599039465,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/44/0b/642c6f7b.jpg","nickname":"周莎莎","note":"","ucode":"393A904F5A0A3B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":114606,"discussion_content":"应用在docker中，怎么排查呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577975089,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1274220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyyEahkmw06SxQDbpST6m5TcbBlnJMVP4zXFQjIRvyfIrT80RRiaHoBiaBq2bddUUEiaXIz8hkooCIw/132","nickname":"13524265609","note":"","ucode":"441F3A2A4D6146","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37635,"discussion_content":"如果dump文件太大，加载不了，该如何分析呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571649524,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1004698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","nickname":"每天晒白牙","note":"","ucode":"A1B102CD933DEA","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":1274220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyyEahkmw06SxQDbpST6m5TcbBlnJMVP4zXFQjIRvyfIrT80RRiaHoBiaBq2bddUUEiaXIz8hkooCIw/132","nickname":"13524265609","note":"","ucode":"441F3A2A4D6146","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":37918,"discussion_content":"你是说已经把dump下载了，但因为太大加载不了吗？这种我一般重启电脑，把其他应用都关了。给分析dump文件的软件留出足够的内存，如果还不行，我还没有好办法","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1571700914,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37635,"ip_address":""},"score":37918,"extra":""},{"author":{"id":2664121,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a6/b9/6bdaf8ce.jpg","nickname":"rich_li","note":"","ucode":"B82495DDC942DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1274220,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKyyEahkmw06SxQDbpST6m5TcbBlnJMVP4zXFQjIRvyfIrT80RRiaHoBiaBq2bddUUEiaXIz8hkooCIw/132","nickname":"13524265609","note":"","ucode":"441F3A2A4D6146","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":408085,"discussion_content":"加载不来，那不就是内存不够了，把其他应用占内存关了，实在不行就加内存条，目前开发机基本都是16起步了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635173629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":37635,"ip_address":""},"score":408085,"extra":""}]},{"author":{"id":1198816,"avatar":"https://static001.geekbang.org/account/avatar/00/12/4a/e0/eff34583.jpg","nickname":"马超","note":"","ucode":"FAFF55DC5DD15C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":4509,"discussion_content":"貌似用的xflush","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565504240,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1259218,"avatar":"https://static001.geekbang.org/account/avatar/00/13/36/d2/c7357723.jpg","nickname":"发条橙子 。","note":"","ucode":"ED076F4534FFED","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":3107,"discussion_content":"Mark了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564193275,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115062,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1563464378,"is_pvip":false,"replies":[{"id":"42077","content":"我们知道，ThreadLocal是基于ThreadLocalMap实现的，这个Map的Entry继承了WeakReference，而Entry对象中的key使用了WeakReference封装，也就是说Entry中的key是一个弱引用类型，而弱引用类型只能存活在下次GC之前。<br><br>如果一个线程调用ThreadLocal的set设置变量，当前ThreadLocalMap则新增一条记录，此时ThreadLocal实例没有外部强引用，当发生一次垃圾回收，此时key值被回收，而value值依然存在内存中，由于当前线程一直存在，所以value值将一直被引用。.<br><br>这些被垃圾回收掉的key就存在一条引用链的关系一直存在：Thread --&gt; ThreadLocalMap--&gt;Entry--&gt;Value，这条引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。<br><br>我们只需要在使用完该key值之后，通过remove方法remove掉，就可以防止内存泄漏了。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563513651,"ip_address":"","comment_id":115062,"utype":1}],"discussion_count":11,"race_medal":0,"score":"302211175098","product_id":100028001,"comment_content":"老师是否可以讲下如何避免threadLocal内存泄漏呢","like_count":71,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458951,"discussion_content":"我们知道，ThreadLocal是基于ThreadLocalMap实现的，这个Map的Entry继承了WeakReference，而Entry对象中的key使用了WeakReference封装，也就是说Entry中的key是一个弱引用类型，而弱引用类型只能存活在下次GC之前。\n\n如果一个线程调用ThreadLocal的set设置变量，当前ThreadLocalMap则新增一条记录，此时ThreadLocal实例没有外部强引用，当发生一次垃圾回收，此时key值被回收，而value值依然存在内存中，由于当前线程一直存在，所以value值将一直被引用。.\n\n这些被垃圾回收掉的key就存在一条引用链的关系一直存在：Thread --&amp;gt; ThreadLocalMap--&amp;gt;Entry--&amp;gt;Value，这条引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。\n\n我们只需要在使用完该key值之后，通过remove方法remove掉，就可以防止内存泄漏了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563513651,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1369447,"avatar":"https://static001.geekbang.org/account/avatar/00/14/e5/67/16322a5d.jpg","nickname":"cky.宇","note":"","ucode":"93A3EAD9D50A5F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51561,"discussion_content":"一般是在用线程池的情况下，会重复使用同一个线程，线程的key被回收了，value由于线程没结束造成value一直被引用造成内存泄漏。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1573898950,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1676060,"avatar":"https://static001.geekbang.org/account/avatar/00/19/93/1c/206b3d9f.jpg","nickname":"小智","note":"","ucode":"3B6AE5E0E12D6A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311407,"discussion_content":"使用局部变量了，就没必要使用threadlocal了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602330595,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1125511,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2c/87/9a3d80dc.jpg","nickname":"昨夜的柠檬","note":"","ucode":"C5829C29FB3E34","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40310,"discussion_content":"老师，正常情况ThreadLocal都应该会有外部强引用啊，不会被回收，什么情况下才会出现null被回收？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572158927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1125511,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2c/87/9a3d80dc.jpg","nickname":"昨夜的柠檬","note":"","ucode":"C5829C29FB3E34","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73959,"discussion_content":"如果ThreadLocal是全局的，有外部强引用，是不会回收的；而如果ThreadLocal实例作为一个局部变量，方法结束了，就会被回收","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1575617366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":40310,"ip_address":""},"score":73959,"extra":""},{"author":{"id":1181650,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/d2/0d7ee298.jpg","nickname":"惘 闻","note":"","ucode":"C5909F034BF072","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":338274,"discussion_content":"老师说的这个全局是什么意思呀，在类中作为成员变量吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609229642,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73959,"ip_address":""},"score":338274,"extra":""}]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":9898,"discussion_content":"我们的项目中用的多，不过到目前为止还未曾遇见因其导致的内存泄露问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568240482,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":73965,"discussion_content":"只有ThreadLocal实例在使用完后立即被置为null或者回收掉的情况下（一般ThreadLocal实例都是全局的，不会出现这种情况），且使用了线程池，会出现内存泄漏问题。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1575617732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":9898,"ip_address":""},"score":73965,"extra":""},{"author":{"id":1108761,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/19/76b0b98c.jpg","nickname":"torres","note":"","ucode":"34DABCFC7B74EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":359887,"discussion_content":"老师，请问一下，前面半句我理解，为什么且使用线程池才会有内存泄露的问题？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616317984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":73965,"ip_address":""},"score":359887,"extra":""},{"author":{"id":1053772,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/4c/c581813b.jpg","nickname":"中学生","note":"","ucode":"C9B9FB6DBFC628","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1108761,"avatar":"https://static001.geekbang.org/account/avatar/00/10/eb/19/76b0b98c.jpg","nickname":"torres","note":"","ucode":"34DABCFC7B74EA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":380850,"discussion_content":"线程被复用，ThreadLocalMap也就不会被回收。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1624726933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":359887,"ip_address":""},"score":380850,"extra":""}]}]},{"had_liked":false,"id":115020,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1563454751,"is_pvip":false,"replies":[{"id":"42079","content":"内存泄漏是指不再使用的对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。例如，我们之前在第3讲中聊到的在Java6中substring方法可能会导致内存泄漏情况发生。当调用substring方法时会调用new string构造函数，此时会复用原来字符串的char数组，而如果我们仅仅是用substring获取一小段字符，而原本string字符串非常大的情况下，substring的对象如果一直被引用，由于substring的里面的char数组仍然指向原字符串，此时string字符串也无法回收，从而导致内存泄露。<br><br>内存溢出则是发生了OutOfMemoryException，内存溢出的情况有很多，例如堆内存空间不足，栈空间不足，以及方法区空间不足都会发生内存溢出异常。<br><br>内存泄漏与内存溢出的关系：内存泄漏很容易导致内存溢出，但内存溢出不一定是内存泄漏导致的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563513720,"ip_address":"","comment_id":115020,"utype":1}],"discussion_count":2,"race_medal":0,"score":"139002408223","product_id":100028001,"comment_content":"请问一下老师内存泄露和内存溢出具体有啥区别，有点不太理解内存泄露的概念。","like_count":33,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458931,"discussion_content":"内存泄漏是指不再使用的对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。例如，我们之前在第3讲中聊到的在Java6中substring方法可能会导致内存泄漏情况发生。当调用substring方法时会调用new string构造函数，此时会复用原来字符串的char数组，而如果我们仅仅是用substring获取一小段字符，而原本string字符串非常大的情况下，substring的对象如果一直被引用，由于substring的里面的char数组仍然指向原字符串，此时string字符串也无法回收，从而导致内存泄露。\n\n内存溢出则是发生了OutOfMemoryException，内存溢出的情况有很多，例如堆内存空间不足，栈空间不足，以及方法区空间不足都会发生内存溢出异常。\n\n内存泄漏与内存溢出的关系：内存泄漏很容易导致内存溢出，但内存溢出不一定是内存泄漏导致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563513720,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1669273,"avatar":"https://static001.geekbang.org/account/avatar/00/19/78/99/6060eb2d.jpg","nickname":"平凡之路","note":"","ucode":"96CE12339BD5FD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":63920,"discussion_content":"老师解开多年的疑惑，赞","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574922056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":135248,"user_name":"怪盗キッド","can_delete":false,"product_type":"c1","uid":1048065,"ip_address":"","ucode":"D96BC268F5FB6C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/01/3f3ae95e.jpg","comment_is_top":false,"comment_ctime":1569084077,"is_pvip":false,"replies":[{"id":"53069","content":"👍","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569981184,"ip_address":"","comment_id":135248,"utype":1}],"discussion_count":2,"race_medal":0,"score":"74583528109","product_id":100028001,"comment_content":"我开源了一个 Java 性能监控工具，就是用 JDK 自带的接口实现的。<br>GitHub 地址：https:&#47;&#47;github.com&#47;LinShunKang&#47;MyPerf4J","like_count":18,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468111,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569981184,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2060756,"avatar":"","nickname":"在下蟑螂王","note":"","ucode":"E66A65A327095A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":331563,"discussion_content":"Mark","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606901585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120469,"user_name":"刘天若Warner","can_delete":false,"product_type":"c1","uid":1216848,"ip_address":"","ucode":"032639CD670DA3","user_header":"https://static001.geekbang.org/account/avatar/00/12/91/50/e576a068.jpg","comment_is_top":false,"comment_ctime":1564909163,"is_pvip":false,"replies":[{"id":"44503","content":"正常情况下，如果一个线程set之后，该线程销毁了，然后key值由于弱引用刚好遇到一次GC，被回收了，此时value已经出现内存泄漏。而threadlocal为了解决这个问题，在后面的线程进行set时，会把之前key值为null的value清空掉，所以就不会出现大量内存泄漏了。<br><br>所以我们要模拟的就是，在后面进来的线程set之前，保证之前的线程还没有销毁，之前的key value就会保持，这样我们能模拟出大量value内存泄漏的情况出现。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1565059926,"ip_address":"","comment_id":120469,"utype":1}],"discussion_count":3,"race_medal":0,"score":"48809549419","product_id":100028001,"comment_content":"老师，为什么线程要sleep一下，看了注释还是不理解，求告知","like_count":12,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461347,"discussion_content":"正常情况下，如果一个线程set之后，该线程销毁了，然后key值由于弱引用刚好遇到一次GC，被回收了，此时value已经出现内存泄漏。而threadlocal为了解决这个问题，在后面的线程进行set时，会把之前key值为null的value清空掉，所以就不会出现大量内存泄漏了。\n\n所以我们要模拟的就是，在后面进来的线程set之前，保证之前的线程还没有销毁，之前的key value就会保持，这样我们能模拟出大量value内存泄漏的情况出现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1565059926,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2548016,"avatar":"https://static001.geekbang.org/account/avatar/00/26/e1/30/56151c95.jpg","nickname":"徐大雷","note":"","ucode":"4D6F0D4C58CE93","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":411061,"discussion_content":"没看到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635840342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":371220,"discussion_content":"在哪 sleep？文章好像没看到","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619686576,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":119227,"user_name":"CRann","can_delete":false,"product_type":"c1","uid":1542500,"ip_address":"","ucode":"45D569C9778BDA","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqWicx6gYmNqGYC8V9xo31w9hjsJrZB1fogG6ibBc0KObo2q3n1xndl6BcriahzHKnGvWy3sgCxVlH1w/132","comment_is_top":false,"comment_ctime":1564539584,"is_pvip":false,"replies":[{"id":"44003","content":"截图截错了，自己操作的时候记得输入正确的pid就好了。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1564713345,"ip_address":"","comment_id":119227,"utype":1}],"discussion_count":1,"race_medal":0,"score":"40219245248","product_id":100028001,"comment_content":"老师，刚看案例top命令后java的pid是1444，可是为什么后来查线程信息变成top -Hd 1593了？","like_count":10,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":460793,"discussion_content":"截图截错了，自己操作的时候记得输入正确的pid就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564713345,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145005,"user_name":"昨夜的柠檬","can_delete":false,"product_type":"c1","uid":1125511,"ip_address":"","ucode":"C5829C29FB3E34","user_header":"https://static001.geekbang.org/account/avatar/00/11/2c/87/9a3d80dc.jpg","comment_is_top":false,"comment_ctime":1572158307,"is_pvip":false,"replies":[{"id":"56518","content":"正确的写法是在set之后，记得在finally里面remove掉。<br><br>try{<br>  localthread.set(&quot;test&quot;);<br>}finally{<br>   localthread.remove(&quot;test&quot;);<br>}","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1572519072,"ip_address":"","comment_id":145005,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31636929379","product_id":100028001,"comment_content":"实际项目中很多都是这样的，老师正确的写法应该是怎样的？","like_count":8,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472208,"discussion_content":"正确的写法是在set之后，记得在finally里面remove掉。\n\ntry{\n  localthread.set(&amp;quot;test&amp;quot;);\n}finally{\n   localthread.remove(&amp;quot;test&amp;quot;);\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572519072,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":158396,"user_name":"殿小二","can_delete":false,"product_type":"c1","uid":1284986,"ip_address":"","ucode":"E979673B257C24","user_header":"https://static001.geekbang.org/account/avatar/00/13/9b/7a/58327b6d.jpg","comment_is_top":false,"comment_ctime":1575363940,"is_pvip":false,"replies":[{"id":"60867","content":"是的，后面线程的set只是在当前线程的ThreadLocalMap上进行操作，不能清空其他线程ThreadLocalMap上已经泄漏的value值。这里指的是同一个线程，ThreadLocal实例没有外部强引用的情况下被回收了，此时key值会被回收，下一次在相同线程下set，value值会被清掉。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1575547704,"ip_address":"","comment_id":158396,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23050200420","product_id":100028001,"comment_content":"老师 &quot;而threadlocal为了解决这个问题，在后面的线程进行set时，会把之前key值为null的value清空掉，所以就不会出现大量内存泄漏了。&quot;  后面的线程set的时候也只会在自己持有的ThreadLocalMap上进行操作吧,没有所谓的清空 key为null的value的值吧","like_count":6,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476705,"discussion_content":"是的，后面线程的set只是在当前线程的ThreadLocalMap上进行操作，不能清空其他线程ThreadLocalMap上已经泄漏的value值。这里指的是同一个线程，ThreadLocal实例没有外部强引用的情况下被回收了，此时key值会被回收，下一次在相同线程下set，value值会被清掉。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575547704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153901,"user_name":"偏偏喜欢你","can_delete":false,"product_type":"c1","uid":1101985,"ip_address":"","ucode":"76D9E22B263D6B","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/a1/07027529.jpg","comment_is_top":false,"comment_ctime":1574328285,"is_pvip":false,"replies":[{"id":"59446","content":"这两个都是基础数据类型数组，例如char[]是String的基础数据类型，byte[]则是数据传输字节流的基础数据类型，排在第一二是比较常见的，我们需要再看看大小，如果异常大，那就是该基础数据类型之上的某个引用类型的问题。可以通过工具再展开树看看封装基础数据类型的引用类型是什么。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1574579648,"ip_address":"","comment_id":153901,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18754197469","product_id":100028001,"comment_content":"老是您好最近看到项目有报内存溢出，发现是byte[]的问题，但是在Histogram 下看到排在第一位的是char[]数组，排第二的是byte[]<br>我是去排查char[]呢还是byte[]","like_count":5,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475314,"discussion_content":"这两个都是基础数据类型数组，例如char[]是String的基础数据类型，byte[]则是数据传输字节流的基础数据类型，排在第一二是比较常见的，我们需要再看看大小，如果异常大，那就是该基础数据类型之上的某个引用类型的问题。可以通过工具再展开树看看封装基础数据类型的引用类型是什么。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574579648,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":216810,"user_name":"Bruce","can_delete":false,"product_type":"c1","uid":1106929,"ip_address":"","ucode":"B2F562F717BD3C","user_header":"https://static001.geekbang.org/account/avatar/00/10/e3/f1/346bd356.jpg","comment_is_top":false,"comment_ctime":1589347765,"is_pvip":false,"replies":[{"id":"80536","content":"只能查看运行时的数据，如果需要历史数据，可以在JVM启动参数中加入dump日志参数，启动长时间JVM日志监控：<br>启动OOM监控日志：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=&#47;tmp&#47;heapdump.hprof <br>启动GC日志：-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:&#47;tmp&#47;heapTest.log","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1589616697,"ip_address":"","comment_id":216810,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14474249653","product_id":100028001,"comment_content":"问下老师，jmap和jstack命令能查历史的数据，譬如想查昨天的？","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494953,"discussion_content":"只能查看运行时的数据，如果需要历史数据，可以在JVM启动参数中加入dump日志参数，启动长时间JVM日志监控：\n启动OOM监控日志：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof \n启动GC日志：-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/tmp/heapTest.log","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589616697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174495,"user_name":"Alex","can_delete":false,"product_type":"c1","uid":1102045,"ip_address":"","ucode":"37E663FC4B85E2","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/dd/a4df05d4.jpg","comment_is_top":false,"comment_ctime":1580233119,"is_pvip":false,"replies":[{"id":"69018","content":"由于代码比较少，这篇没有提交到github上，麻烦自己建个项目，拷贝下文章中的代码上去就好了。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1581507546,"ip_address":"","comment_id":174495,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14465135007","product_id":100028001,"comment_content":"老师好，不好意思，想问一下，本门课程案例代码的git地址在哪里？我没有找到","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482417,"discussion_content":"由于代码比较少，这篇没有提交到github上，麻烦自己建个项目，拷贝下文章中的代码上去就好了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581507546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":120807,"user_name":"星星滴蓝天","can_delete":false,"product_type":"c1","uid":1465990,"ip_address":"","ucode":"2F2F56F93AD828","user_header":"https://static001.geekbang.org/account/avatar/00/16/5e/86/40877404.jpg","comment_is_top":false,"comment_ctime":1564998722,"is_pvip":false,"replies":[{"id":"51396","content":"可以通过ManagementFactory中的RuntimeMXBean实时获取JVM对应的值","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1568725413,"ip_address":"","comment_id":120807,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14449900610","product_id":100028001,"comment_content":"代码中对jvm监控常用方法是啥？我翻了翻留言，没有人问这个问题的","like_count":4,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":461489,"discussion_content":"可以通过ManagementFactory中的RuntimeMXBean实时获取JVM对应的值","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568725413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200437,"user_name":"vvip","can_delete":false,"product_type":"c1","uid":1094047,"ip_address":"","ucode":"A027AA12766B0F","user_header":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqk1XbuxMP8OPv1QUEOg1IR2bCWaBcr19Z8KiaSg2fnHs7PicmJRtD7ibdEK4As692g3xtTdajjWWdXw/132","comment_is_top":false,"comment_ctime":1585583696,"is_pvip":false,"replies":[{"id":"75243","content":"有性能损耗","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1585741454,"ip_address":"","comment_id":200437,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10175518288","product_id":100028001,"comment_content":"老师，请问JVM上始终开启HeapDumpOnOutOfMemoryError这个参数，会影响性能吗？","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490027,"discussion_content":"有性能损耗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585741454,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149533,"user_name":"丁奇老师的粉丝","can_delete":false,"product_type":"c1","uid":1208265,"ip_address":"","ucode":"6341E0D78CF998","user_header":"https://static001.geekbang.org/account/avatar/00/12/6f/c9/22022094.jpg","comment_is_top":false,"comment_ctime":1573268317,"is_pvip":false,"replies":[{"id":"57604","content":"如果没有设置年轻代与老年代的比例，默认分配给年轻代最大比例为60%，而且默认会先触发young gc，所以你说的这种情况比较少见，检查是否长时间存活的对象太多导致的。<br><br>这种情况优化设置参数已经没有很明显的作用了，建议先查找内存爆满的原因。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1573381099,"ip_address":"","comment_id":149533,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10163202909","product_id":100028001,"comment_content":"老师您好，看了您的课程收货颇丰！谢谢<br>现在有个问题想咨询下<br><br>前提：jdk7u24  xms8g xmx8g g1垃圾回收<br>现象：<br>堆内存使用量从2G一直到6.3G都没有young gc  和 full gc<br><br>当堆内存使用量到了7G的时候直接进行了full gc<br>并且周期性重复上面的full gc<br>查看GC日志  eden区回收前高达6.3G<br><br>请问老师。现在该如何调优呢","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473893,"discussion_content":"如果没有设置年轻代与老年代的比例，默认分配给年轻代最大比例为60%，而且默认会先触发young gc，所以你说的这种情况比较少见，检查是否长时间存活的对象太多导致的。\n\n这种情况优化设置参数已经没有很明显的作用了，建议先查找内存爆满的原因。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573381099,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":290686,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1619686961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5914654257","product_id":100028001,"comment_content":"老师，请问一下，文章是二次修改过么？评论区有些关键字如：sleep，test0，test1。<br>我在文章只看到 test0 方法。另两个都没找到。<br>谢谢！","like_count":1},{"had_liked":false,"id":267107,"user_name":"静静聆听","can_delete":false,"product_type":"c1","uid":1263932,"ip_address":"","ucode":"0A8600CB928EFE","user_header":"https://static001.geekbang.org/account/avatar/00/13/49/3c/5d54c510.jpg","comment_is_top":false,"comment_ctime":1607598879,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5902566175","product_id":100028001,"comment_content":"treadLocal会随着线程被回收而消失的，不会一直存在，极端情况才会内存泄漏","like_count":2,"discussions":[{"author":{"id":2324073,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ziaicqaAJT18CS3xlPgGmLyicMkYiarDhSR9I79DnIjxpnETjOoHe9DM7wmC0icdw1XzwPDKF4TEFuqRicqSgyFtTtBQ/132","nickname":"Geek_c57a51","note":"","ucode":"843AE20C5610BD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338103,"discussion_content":"使用线程池的情况下，线程一般都不会回收","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609171929,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":129681,"user_name":"Feng","can_delete":false,"product_type":"c1","uid":1015205,"ip_address":"","ucode":"42DB60B7BF69D0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7d/a5/930c9103.jpg","comment_is_top":false,"comment_ctime":1567218636,"is_pvip":false,"replies":[{"id":"48620","content":"之前的代码已经优化了，所以去掉了test1，重写写了test0方法，两个方法对于大家来说不是很好理解","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567425145,"ip_address":"","comment_id":129681,"utype":1}],"discussion_count":1,"race_medal":4,"score":"5862185932","product_id":100028001,"comment_content":"没看到有test1啊。。。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465600,"discussion_content":"之前的代码已经优化了，所以去掉了test1，重写写了test0方法，两个方法对于大家来说不是很好理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567425145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":126338,"user_name":"WolvesLeader","can_delete":false,"product_type":"c1","uid":1103839,"ip_address":"","ucode":"33610E19CA2E96","user_header":"https://static001.geekbang.org/account/avatar/00/10/d7/df/fc0a6709.jpg","comment_is_top":false,"comment_ctime":1566367548,"is_pvip":false,"replies":[{"id":"46829","content":"一个就够了，已修正","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1566437097,"ip_address":"","comment_id":126338,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5861334844","product_id":100028001,"comment_content":"java -jar -Xms1000m -Xmx4000m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=&#47;tmp&#47;heapdump.hprof -Xms1g -Xmx1g -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:&#47;tmp&#47;heapTest.log heapTest-0.0.1-SNAPSHOT.jar<br>配置了2个-Xms和-Xmx，为啥要配置2个","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":463944,"discussion_content":"一个就够了，已修正","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1566437097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114903,"user_name":"拒绝","can_delete":false,"product_type":"c1","uid":1335155,"ip_address":"","ucode":"CB0264C4D3FE17","user_header":"https://static001.geekbang.org/account/avatar/00/14/5f/73/bb3dc468.jpg","comment_is_top":false,"comment_ctime":1563429847,"is_pvip":false,"replies":[{"id":"42038","content":"内存泄露导致有大量对象无法回收，占满了堆内存情况下，就会导致内存溢出。我在这里加了一个test1只是为了创建更多的对象，从而更容易发生内存溢出。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563493365,"ip_address":"","comment_id":114903,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858397143","product_id":100028001,"comment_content":"我用ab测试，设置请求数量一万，请求test0，内存就溢出，；还没请求到test1,？","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458876,"discussion_content":"内存泄露导致有大量对象无法回收，占满了堆内存情况下，就会导致内存溢出。我在这里加了一个test1只是为了创建更多的对象，从而更容易发生内存溢出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563493365,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114788,"user_name":"恰饭哒","can_delete":false,"product_type":"c1","uid":1014023,"ip_address":"","ucode":"0395069A050057","user_header":"https://static001.geekbang.org/account/avatar/00/0f/79/07/2f418316.jpg","comment_is_top":false,"comment_ctime":1563408273,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5858375569","product_id":100028001,"comment_content":"老师太棒了，是我一直想总结而不知道怎么总结的一篇文章","like_count":1},{"had_liked":false,"id":114787,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1563408220,"is_pvip":false,"replies":[{"id":"41929","content":"平时仅仅某些内存泄漏，一般不会导致内存溢出。<br>所以在这里，test0请求方法中ThreadLocal为内存泄漏，而test1是一个触发内存溢出的条件，小请求量时没有问题，当请求量比较大时，就出现内存溢出情况了。<br><br>","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563421488,"ip_address":"","comment_id":114787,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5858375516","product_id":100028001,"comment_content":"能否讲下这个测试用例是怎么设计的，为什么跑1w次AB两个方法，在1G的堆内存下会发生OOM","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458814,"discussion_content":"平时仅仅某些内存泄漏，一般不会导致内存溢出。\n所以在这里，test0请求方法中ThreadLocal为内存泄漏，而test1是一个触发内存溢出的条件，小请求量时没有问题，当请求量比较大时，就出现内存溢出情况了。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563421488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330376,"user_name":"L","can_delete":false,"product_type":"c1","uid":2890361,"ip_address":"","ucode":"C519F89E4A5F67","user_header":"https://static001.geekbang.org/account/avatar/00/2c/1a/79/ebdabcd4.jpg","comment_is_top":false,"comment_ctime":1641957906,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1641957906","product_id":100028001,"comment_content":"老师生产环境下，都是运维掌握着服务器，也不会给我操作，更不会给我dump，因为一个堆日志文件很大，导出要好半天，运维不会干这个事情的。所以有什么更好的方式来解决生产的内存溢出问题吗。公司给的中间件监控仅仅只能看到内存变化曲线，没有任何线程堆栈信息","like_count":0},{"had_liked":false,"id":322329,"user_name":"小麦","can_delete":false,"product_type":"c1","uid":1618709,"ip_address":"","ucode":"2C800B598A2CDE","user_header":"https://static001.geekbang.org/account/avatar/00/18/b3/15/30822e33.jpg","comment_is_top":false,"comment_ctime":1637304654,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1637304654","product_id":100028001,"comment_content":"Linux性能工具的这部分内容和《实战 JAVA 虚拟机》的 6.1 节完全一样","like_count":0},{"had_liked":false,"id":297747,"user_name":"麦德漂","can_delete":false,"product_type":"c1","uid":2088674,"ip_address":"","ucode":"18CF51FAF94949","user_header":"https://static001.geekbang.org/account/avatar/00/1f/de/e2/b42256d2.jpg","comment_is_top":false,"comment_ctime":1623758477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623758477","product_id":100028001,"comment_content":"threadlocal用完必须释放，其实很多对象引用就是因为没有及时释放，导致内存泄漏，数据异常。","like_count":0},{"had_liked":false,"id":294318,"user_name":"补心","can_delete":false,"product_type":"c1","uid":1124789,"ip_address":"","ucode":"9DB51E8A6C4B62","user_header":"https://static001.geekbang.org/account/avatar/00/11/29/b5/2b477ed4.jpg","comment_is_top":false,"comment_ctime":1621897117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1621897117","product_id":100028001,"comment_content":"老师问一下，threadlocal操作，对于tomcat这种应用服务器来说，开始的线程数是有限的，我们用threadlocal 存储对象就算不remove是不是可以理解，第二个相同线程来的时候，会把上一个线程变量的一个清空呢，这样的话threadlocal里面存储的最大数其实就是我们应用服务器开启的线程数，是不是可以这样理解","like_count":0},{"had_liked":false,"id":288264,"user_name":"兔子","can_delete":false,"product_type":"c1","uid":1022286,"ip_address":"","ucode":"327C5142FD0940","user_header":"https://static001.geekbang.org/account/avatar/00/0f/99/4e/0146807f.jpg","comment_is_top":false,"comment_ctime":1618384766,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618384766","product_id":100028001,"comment_content":"老师，我这边有个问题，通过jvisualvm和jmc查看程序内存都在控制范围内，但是通过系统资源管理器查看内存从最开始的500M慢慢增长到1.5G，非持续线性增长，通过jvisualvm查看堆内存大小从未超过750M，使用的堆大小也在250M到450M之间，metaspace也稳定在100M，现在不知道如何定位那部分被消耗的内存在什么地方？<br>具体程序情况如下：<br>1、程序中有调用opencv的库进行图片处理<br>2、程序通过exe4j进行服务打包处理<br>3、JDK版本1.8<br>4、下面是程序启动参数配置<br>-Xms512m<br>-Xmx750m<br>-XX:PermSize=128m<br>-XX:MaxPermSize=200m","like_count":0},{"had_liked":false,"id":273242,"user_name":"false℃","can_delete":false,"product_type":"c1","uid":1307277,"ip_address":"","ucode":"17E987C05CA2D0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f2/8d/2a9764e3.jpg","comment_is_top":false,"comment_ctime":1610506447,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1610506447","product_id":100028001,"comment_content":"在生产上有这样一个问题，通过top查看Linux系统使用,发现Java进程占比达到了百分七八十，查看gc日志，堆内存占用不够大几百m，那剩下的内存用到哪了呢","like_count":0},{"had_liked":false,"id":228476,"user_name":"wkq2786130","can_delete":false,"product_type":"c1","uid":1256821,"ip_address":"","ucode":"0F3A9DF9928C67","user_header":"https://static001.geekbang.org/account/avatar/00/13/2d/75/e7c29de4.jpg","comment_is_top":false,"comment_ctime":1592707184,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1592707184","product_id":100028001,"comment_content":"1. 系统监控，监控容器的CPU 内存 IO 情况<br>2. JVM监控，监控JVM CPU 堆内存 非堆内存 线程数<br>3. 方法监控，方法使用的内存过多报警","like_count":0,"discussions":[{"author":{"id":1537865,"avatar":"https://static001.geekbang.org/account/avatar/00/17/77/49/445eea2d.jpg","nickname":"SochiLee","note":"","ucode":"47596594EDF4D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352951,"discussion_content":"请教，“3.方法监控，方法使用的内存过多报警”，如何实现呀？思路是什么？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614922041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161265,"user_name":"John","can_delete":false,"product_type":"c1","uid":1123654,"ip_address":"","ucode":"D113AD2F837A92","user_header":"https://static001.geekbang.org/account/avatar/00/11/25/46/7a9ede98.jpg","comment_is_top":false,"comment_ctime":1576159921,"is_pvip":false,"replies":[{"id":"61976","content":"通过jamp将内存使用情况dump出来，分析下内存中的对象分布情况，一般MAT会直接给出问题对象的。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1576669282,"ip_address":"","comment_id":161265,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576159921","product_id":100028001,"comment_content":"老师请教一下，在jmap分析后，确认不存在堆内存泄露的前提下，top显示的mem依然一直站在高位，从jstack也没有看出有异常的线程问题，这种情况下能怎么进行问题定位？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477670,"discussion_content":"通过jamp将内存使用情况dump出来，分析下内存中的对象分布情况，一般MAT会直接给出问题对象的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576669282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":132798,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568241111,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1568241111","product_id":100028001,"comment_content":"老师请问OS是怎么监控每个进程的资源使用情况的？直接在内存中收集到相关的数据？<br>其他监控工具的工作原理是是什么？是借助OS的API获取相关监控信息还是自己有做了什么拿到了监控进程的运行数据？","like_count":0},{"had_liked":false,"id":115061,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1563464251,"is_pvip":false,"replies":[{"id":"42037","content":"tesr0是内存泄露，test1则是正常的分配堆内存，这里test1只是模拟在内存溢出的情况下，如果有大量对象创建的情况下，很容易导致内存溢出。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563493101,"ip_address":"","comment_id":115061,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1563464251","product_id":100028001,"comment_content":"同理不明白为什么这里test0，test1方法会内存泄漏，请老师自己讲下","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458950,"discussion_content":"tesr0是内存泄露，test1则是正常的分配堆内存，这里test1只是模拟在内存溢出的情况下，如果有大量对象创建的情况下，很容易导致内存溢出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563493101,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364034,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","nickname":"我已经设置了昵称","note":"","ucode":"ED672C5EBDBDC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2366,"discussion_content":"明白","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563519797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115036,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1563458824,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563458824","product_id":100028001,"comment_content":"学到了很多，感谢感谢","like_count":0},{"had_liked":false,"id":114798,"user_name":"撒旦的堕落","can_delete":false,"product_type":"c1","uid":1116864,"ip_address":"","ucode":"15F6AA41EE556F","user_header":"https://static001.geekbang.org/account/avatar/00/11/0a/c0/401c240e.jpg","comment_is_top":false,"comment_ctime":1563410191,"is_pvip":false,"replies":[{"id":"42078","content":"如果发生GC的情况下，threadlocalmap产生的占用内存对象就不止400m，也就是说发生内存溢出的情况下。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563513702,"ip_address":"","comment_id":114798,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563410191","product_id":100028001,"comment_content":"老师  这段代码有点不解的地方 test0使用线程池 所以线程一直存活  而每个线程的threadlocalmap中 含有4m的内存 没法释放 100个线程 才400m被占用 而test1方法使用的是局部变量 方法执行后内存就会被回收  4g的内存为啥就溢出了","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458818,"discussion_content":"如果发生GC的情况下，threadlocalmap产生的占用内存对象就不止400m，也就是说发生内存溢出的情况下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563513702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114785,"user_name":"csyangchsh","can_delete":false,"product_type":"c1","uid":1002939,"ip_address":"","ucode":"8604F5C839710B","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/bb/abb7bfe3.jpg","comment_is_top":false,"comment_ctime":1563407578,"is_pvip":false,"replies":[{"id":"42041","content":"对的，也要关注string byte类型的对象大小是不是异常。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563493597,"ip_address":"","comment_id":114785,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563407578","product_id":100028001,"comment_content":"分析垃圾回收日志，内存占用呈上涨趋势。另外对象年龄分布也是一个指征，如果使用visualvm，可以查看generation count。或者取垃圾回收前后的class histogram进行比较，看哪个类的实例增多了，不过要注意string，byte数组等通常排在最前面。所以要关注自己写的类，是不是排在前10几位。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458813,"discussion_content":"对的，也要关注string byte类型的对象大小是不是异常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563493597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":114778,"user_name":"yihang","can_delete":false,"product_type":"c1","uid":1012361,"ip_address":"","ucode":"A5506F085D1793","user_header":"https://static001.geekbang.org/account/avatar/00/0f/72/89/1a83120a.jpg","comment_is_top":false,"comment_ctime":1563406567,"is_pvip":false,"replies":[{"id":"41928","content":"test1只是一个添加内存对象的方法，仅仅是作为触发条件，如果threadLocal的对象不及时回收，test1请求量大了，就会导致内存溢出。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563421169,"ip_address":"","comment_id":114778,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1563406567","product_id":100028001,"comment_content":"没太看懂test1方法，该方法内并没有使用之前的线程池和threadlocal对象啊？另外其中的创建的对象（都是局部的）<br>应该在方法执行完毕可以标记为回收啊？怎么调用它会出问题呢","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458811,"discussion_content":"test1只是一个添加内存对象的方法，仅仅是作为触发条件，如果threadLocal的对象不及时回收，test1请求量大了，就会导致内存溢出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563421169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}