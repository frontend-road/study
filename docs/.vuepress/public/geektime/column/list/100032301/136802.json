{"id":136802,"title":"23 | RocketMQ客户端如何在集群中找到正确的节点？","content":"<p>你好，我是李玥。</p><p>我们在《<a href=\"https://time.geekbang.org/column/article/135120\">21 | RocketMQ Producer源码分析：消息生产的实现过程</a>》这节课中，讲解RocketMQ的生产者启动流程时提到过，生产者只要配置一个接入地址，就可以访问整个集群，并不需要客户端配置每个Broker的地址。RocketMQ会自动根据要访问的主题名称和队列序号，找到对应的Broker地址。如果Broker发生宕机，客户端还会自动切换到新的Broker节点上，这些对于用户代码来说都是透明的。</p><p>这些功能都是由NameServer协调Broker和客户端共同实现的，其中NameServer的作用是最关键的。</p><p>展开来讲，不仅仅是RocketMQ，任何一个弹性分布式集群，都需要一个类似于NameServer服务，来帮助访问集群的客户端寻找集群中的节点，这个服务一般称为NamingService。比如，像Dubbo这种RPC框架，它的注册中心就承担了NamingService的职责。在Flink中，则是JobManager承担了NamingService的职责。</p><p>也就是说，这种使用NamingService服务来协调集群的设计，在分布式集群的架构设计中，是一种非常通用的方法。你在学习这节课之后，不仅要掌握RocketMQ的NameServer是如何实现的，还要能总结出通用的NamingService的设计思想，并能应用于其他分布式系统的设计中。</p><!-- [[[read_end]]] --><p>这节课，我们一起来分析一下NameServer的源代码，看一下NameServer是如何协调集群中众多的Broker和客户端的。</p><h2>NameServer是如何提供服务的？</h2><p>在RocketMQ中，NameServer是一个独立的进程，为Broker、生产者和消费者提供服务。NameServer最主要的功能就是，为客户端提供寻址服务，协助客户端找到主题对应的Broker地址。此外，NameServer还负责监控每个Broker的存活状态。</p><p>NameServer支持只部署一个节点，也支持部署多个节点组成一个集群，这样可以避免单点故障。在集群模式下，NameServer各节点之间是不需要任何通信的，也不会通过任何方式互相感知，每个节点都可以独立提供全部服务。</p><p>我们一起通过这个图来看一下，在RocketMQ集群中，NameServer是如何配合Broker、生产者和消费者一起工作的。这个图来自<a href=\"https://github.com/apache/rocketmq/tree/master/docs\">RocketMQ的官方文档</a>。</p><p><img src=\"https://static001.geekbang.org/resource/image/53/5e/53baeb70d388de042f7347d137b9d35e.jpeg?wh=2208*916\" alt=\"\"></p><p>每个Broker都需要和所有的NameServer节点进行通信。当Broker保存的Topic信息发生变化的时候，它会主动通知所有的NameServer更新路由信息，为了保证数据一致性，Broker还会定时给所有的NameServer节点上报路由信息。这个上报路由信息的RPC请求，也同时起到Broker与NameServer之间的心跳作用，NameServer依靠这个心跳来确定Broker的健康状态。</p><p>因为每个NameServer节点都可以独立提供完整的服务，所以，对于客户端来说，包括生产者和消费者，只需要选择任意一个NameServer节点来查询路由信息就可以了。客户端在生产或消费某个主题的消息之前，会先从NameServer上查询这个主题的路由信息，然后根据路由信息获取到当前主题和队列对应的Broker物理地址，再连接到Broker节点上进行生产或消费。</p><p>如果NameServer检测到与Broker的连接中断了，NameServer会认为这个Broker不再能提供服务。NameServer会立即把这个Broker从路由信息中移除掉，避免客户端连接到一个不可用的Broker上去。而客户端在与Broker通信失败之后，会重新去NameServer上拉取路由信息，然后连接到其他Broker上继续生产或消费消息，这样就实现了自动切换失效Broker的功能。</p><p>此外，NameServer还提供一个类似Redis的KV读写服务，这个不是主要的流程，我们不展开讲。</p><p>接下来我带你一起分析NameServer的源代码，看一下这些服务都是如何实现的。</p><h2>NameServer的总体结构</h2><p>由于NameServer的结构非常简单，排除KV读写相关的类之后，一共只有6个类，这里面直接给出这6个类的说明：</p><ul>\n<li><strong>NamesrvStartup</strong>：程序入口。</li>\n<li><strong>NamesrvController</strong>：NameServer的总控制器，负责所有服务的生命周期管理。</li>\n<li><strong>RouteInfoManager</strong>：NameServer最核心的实现类，负责保存和管理集群路由信息。</li>\n<li><strong>BrokerHousekeepingService</strong>：监控Broker连接状态的代理类。</li>\n<li><strong>DefaultRequestProcessor</strong>：负责处理客户端和Broker发送过来的RPC请求的处理器。</li>\n<li><strong>ClusterTestRequestProcessor</strong>：用于测试的请求处理器。</li>\n</ul><p>RouteInfoManager这个类中保存了所有的路由信息，这些路由信息都是保存在内存中，并且没有持久化的。在代码中，这些路由信息保存在RouteInfoManager的几个成员变量中：</p><pre><code>public class BrokerData implements Comparable&lt;BrokerData&gt; {\n  // ...\n  private final HashMap&lt;String/* topic */, List&lt;QueueData&gt;&gt; topicQueueTable;\n  private final HashMap&lt;String/* brokerName */, BrokerData&gt; brokerAddrTable;\n  private final HashMap&lt;String/* clusterName */, Set&lt;String/* brokerName */&gt;&gt; clusterAddrTable;\n  private final HashMap&lt;String/* brokerAddr */, BrokerLiveInfo&gt; brokerLiveTable;\n  private final HashMap&lt;String/* brokerAddr */, List&lt;String&gt;/* Filter Server */&gt; filterServerTable;\n  // ...\n}\n</code></pre><p>以上代码中的这5个Map对象，保存了集群所有的Broker和主题的路由信息。</p><p>topicQueueTable保存的是主题和队列信息，其中每个队列信息对应的类QueueData中，还保存了brokerName。需要注意的是，这个brokerName并不真正是某个Broker的物理地址，它对应的一组Broker节点，包括一个主节点和若干个从节点。</p><p>brokerAddrTable中保存了集群中每个brokerName对应Broker信息，每个Broker信息用一个BrokerData对象表示：</p><pre><code>public class BrokerData implements Comparable&lt;BrokerData&gt; {\n    private String cluster;\n    private String brokerName;\n    private HashMap&lt;Long/* brokerId */, String/* broker address */&gt; brokerAddrs;\n    // ...\n}\n</code></pre><p>BrokerData中保存了集群名称cluster，brokerName和一个保存Broker物理地址的Map：brokerAddrs，它的Key是BrokerID，Value就是这个BrokerID对应的Broker的物理地址。</p><p>下面这三个map相对没那么重要，简单说明如下：</p><ul>\n<li>brokerLiveTable中，保存了每个Broker当前的动态信息，包括心跳更新时间，路由数据版本等等。</li>\n<li>clusterAddrTable中，保存的是集群名称与BrokerName的对应关系。</li>\n<li>filterServerTable中，保存了每个Broker对应的消息过滤服务的地址，用于服务端消息过滤。</li>\n</ul><p>可以看到，在NameServer的RouteInfoManager中，主要的路由信息就是由topicQueueTable和brokerAddrTable这两个Map来保存的。</p><p>在了解了总体结构和数据结构之后，我们再来看一下实现的流程。</p><h2>NameServer如何处理Broker注册的路由信息？</h2><p>首先来看一下，NameServer是如何处理Broker注册的路由信息的。</p><p>NameServer处理Broker和客户端所有RPC请求的入口方法是：“DefaultRequestProcessor#processRequest”，其中处理Broker注册请求的代码如下：</p><pre><code>public class DefaultRequestProcessor implements NettyRequestProcessor {\n    // ...\n    @Override\n    public RemotingCommand processRequest(ChannelHandlerContext ctx,\n        RemotingCommand request) throws RemotingCommandException {\n        // ...\n        switch (request.getCode()) {\n            // ...\n            case RequestCode.REGISTER_BROKER:\n                Version brokerVersion = MQVersion.value2Version(request.getVersion());\n                if (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) {\n                    return this.registerBrokerWithFilterServer(ctx, request);\n                } else {\n                    return this.registerBroker(ctx, request);\n                }\n            // ...\n            default:\n                break;\n        }\n        return null;\n    }\n    // ...\n}\n</code></pre><p>这是一个非常典型的处理Request的路由分发器，根据request.getCode()来分发请求到对应的处理器中。Broker发给NameServer注册请求的Code为REGISTER_BROKER，在代码中根据Broker的版本号不同，分别有两个不同的处理实现方法：“registerBrokerWithFilterServer”和\"registerBroker\"。这两个方法实现的流程是差不多的，实际上都是调用了\"RouteInfoManager#registerBroker\"方法，我们直接看这个方法的代码：</p><pre><code>public RegisterBrokerResult registerBroker(\n    final String clusterName,\n    final String brokerAddr,\n    final String brokerName,\n    final long brokerId,\n    final String haServerAddr,\n    final TopicConfigSerializeWrapper topicConfigWrapper,\n    final List&lt;String&gt; filterServerList,\n    final Channel channel) {\n    RegisterBrokerResult result = new RegisterBrokerResult();\n    try {\n        try {\n            // 加写锁，防止并发修改数据\n            this.lock.writeLock().lockInterruptibly();\n\n            // 更新clusterAddrTable\n            Set&lt;String&gt; brokerNames = this.clusterAddrTable.get(clusterName);\n            if (null == brokerNames) {\n                brokerNames = new HashSet&lt;String&gt;();\n                this.clusterAddrTable.put(clusterName, brokerNames);\n            }\n            brokerNames.add(brokerName);\n\n            // 更新brokerAddrTable\n            boolean registerFirst = false;\n\n            BrokerData brokerData = this.brokerAddrTable.get(brokerName);\n            if (null == brokerData) {\n                registerFirst = true; // 标识需要先注册\n                brokerData = new BrokerData(clusterName, brokerName, new HashMap&lt;Long, String&gt;());\n                this.brokerAddrTable.put(brokerName, brokerData);\n            }\n            Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();\n            // 更新brokerAddrTable中的brokerData\n            Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();\n            while (it.hasNext()) {\n                Entry&lt;Long, String&gt; item = it.next();\n                if (null != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) {\n                    it.remove();\n                }\n            }\n\n            // 如果是新注册的Master Broker，或者Broker中的路由信息变了，需要更新topicQueueTable\n            String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);\n            registerFirst = registerFirst || (null == oldAddr);\n\n            if (null != topicConfigWrapper\n                &amp;&amp; MixAll.MASTER_ID == brokerId) {\n                if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())\n                    || registerFirst) {\n                    ConcurrentMap&lt;String, TopicConfig&gt; tcTable =\n                        topicConfigWrapper.getTopicConfigTable();\n                    if (tcTable != null) {\n                        for (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) {\n                            this.createAndUpdateQueueData(brokerName, entry.getValue());\n                        }\n                    }\n                }\n            }\n\n            // 更新brokerLiveTable\n            BrokerLiveInfo prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr,\n                new BrokerLiveInfo(\n                    System.currentTimeMillis(),\n                    topicConfigWrapper.getDataVersion(),\n                    channel,\n                    haServerAddr));\n            if (null == prevBrokerLiveInfo) {\n                log.info(&quot;new broker registered, {} HAServer: {}&quot;, brokerAddr, haServerAddr);\n            }\n\n            // 更新filterServerTable\n            if (filterServerList != null) {\n                if (filterServerList.isEmpty()) {\n                    this.filterServerTable.remove(brokerAddr);\n                } else {\n                    this.filterServerTable.put(brokerAddr, filterServerList);\n                }\n            }\n\n            // 如果是Slave Broker，需要在返回的信息中带上master的相关信息\n            if (MixAll.MASTER_ID != brokerId) {\n                String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);\n                if (masterAddr != null) {\n                    BrokerLiveInfo brokerLiveInfo = this.brokerLiveTable.get(masterAddr);\n                    if (brokerLiveInfo != null) {\n                        result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());\n                        result.setMasterAddr(masterAddr);\n                    }\n                }\n            }\n        } finally {\n            // 释放写锁\n            this.lock.writeLock().unlock();\n        }\n    } catch (Exception e) {\n        log.error(&quot;registerBroker Exception&quot;, e);\n    }\n\n    return result;\n}\n</code></pre><p>上面这段代码比较长，但总体结构很简单，就是根据Broker请求过来的路由信息，依次对比并更新clusterAddrTable、brokerAddrTable、topicQueueTable、brokerLiveTable和filterServerTable这5个保存集群信息和路由信息的Map对象中的数据。</p><p>另外，在RouteInfoManager中，这5个Map作为一个整体资源，使用了一个读写锁来做并发控制，避免并发更新和更新过程中读到不一致的数据问题。这个读写锁的使用方法，和我们在之前的课程《<a href=\"https://time.geekbang.org/column/article/129333\">17 | 如何正确使用锁保护共享数据，协调异步线程？</a>》中讲到的方法是一样的。</p><h2>客户端如何寻找Broker？</h2><p>下面我们来看一下，NameServer如何帮助客户端来找到对应的Broker。对于客户端来说，无论是生产者还是消费者，通过主题来寻找Broker的流程是一样的，使用的也是同一份实现。客户端在启动后，会启动一个定时器，定期从NameServer上拉取相关主题的路由信息，然后缓存在本地内存中，在需要的时候使用。每个主题的路由信息用一个TopicRouteData对象来表示：</p><pre><code>public class TopicRouteData extends RemotingSerializable {\n    // ...\n    private List&lt;QueueData&gt; queueDatas;\n    private List&lt;BrokerData&gt; brokerDatas;\n    // ...\n}\n</code></pre><p>其中，queueDatas保存了主题中的所有队列信息，brokerDatas中保存了主题相关的所有Broker信息。客户端选定了队列后，可以在对应的QueueData中找到对应的BrokerName，然后用这个BrokerName找到对应的BrokerData对象，最终找到对应的Master Broker的物理地址。这部分代码在org.apache.rocketmq.client.impl.factory.MQClientInstance这个类中，你可以自行查看。</p><p>下面我们看一下在NameServer中，是如何实现根据主题来查询TopicRouteData的。</p><p>NameServer处理客户端请求和处理Broker请求的流程是一样的，都是通过路由分发器将请求分发的对应的处理方法中，我们直接看具体的实现方法RouteInfoManager#pickupTopicRouteData：</p><pre><code>public TopicRouteData pickupTopicRouteData(final String topic) {\n\n    // 初始化返回数据topicRouteData\n    TopicRouteData topicRouteData = new TopicRouteData();\n    boolean foundQueueData = false;\n    boolean foundBrokerData = false;\n    Set&lt;String&gt; brokerNameSet = new HashSet&lt;String&gt;();\n    List&lt;BrokerData&gt; brokerDataList = new LinkedList&lt;BrokerData&gt;();\n    topicRouteData.setBrokerDatas(brokerDataList);\n\n    HashMap&lt;String, List&lt;String&gt;&gt; filterServerMap = new HashMap&lt;String, List&lt;String&gt;&gt;();\n    topicRouteData.setFilterServerTable(filterServerMap);\n\n    try {\n        try {\n\n            // 加读锁\n            this.lock.readLock().lockInterruptibly();\n\n            //先获取主题对应的队列信息\n            List&lt;QueueData&gt; queueDataList = this.topicQueueTable.get(topic);\n            if (queueDataList != null) {\n\n                // 把队列信息返回值中\n                topicRouteData.setQueueDatas(queueDataList);\n                foundQueueData = true;\n\n                // 遍历队列，找出相关的所有BrokerName\n                Iterator&lt;QueueData&gt; it = queueDataList.iterator();\n                while (it.hasNext()) {\n                    QueueData qd = it.next();\n                    brokerNameSet.add(qd.getBrokerName());\n                }\n\n                // 遍历这些BrokerName，找到对应的BrokerData，并写入返回结果中\n                for (String brokerName : brokerNameSet) {\n                    BrokerData brokerData = this.brokerAddrTable.get(brokerName);\n                    if (null != brokerData) {\n                        BrokerData brokerDataClone = new BrokerData(brokerData.getCluster(), brokerData.getBrokerName(), (HashMap&lt;Long, String&gt;) brokerData\n                            .getBrokerAddrs().clone());\n                        brokerDataList.add(brokerDataClone);\n                        foundBrokerData = true;\n                        for (final String brokerAddr : brokerDataClone.getBrokerAddrs().values()) {\n                            List&lt;String&gt; filterServerList = this.filterServerTable.get(brokerAddr);\n                            filterServerMap.put(brokerAddr, filterServerList);\n                        }\n                    }\n                }\n            }\n        } finally {\n            // 释放读锁\n            this.lock.readLock().unlock();\n        }\n    } catch (Exception e) {\n        log.error(&quot;pickupTopicRouteData Exception&quot;, e);\n    }\n\n    log.debug(&quot;pickupTopicRouteData {} {}&quot;, topic, topicRouteData);\n\n    if (foundBrokerData &amp;&amp; foundQueueData) {\n        return topicRouteData;\n    }\n\n    return null;\n}\n</code></pre><p>这个方法的实现流程是这样的：</p><ol>\n<li>初始化返回的topicRouteData后，\b获取读锁。</li>\n<li>在topicQueueTable中获取主题对应的队列信息，并写入返回结果中。</li>\n<li>遍历队列，找出相关的所有BrokerName。</li>\n<li>遍历这些BrokerName，从brokerAddrTable中找到对应的BrokerData，并写入返回结果中。</li>\n<li>释放读锁并返回结果。</li>\n</ol><h2>小结</h2><p>这节课我们一起分析了RocketMQ NameServer的源代码，NameServer在集群中起到的一个核心作用就是，为客户端提供路由信息，帮助客户端找到对应的Broker。</p><p>每个NameServer节点上都保存了集群所有Broker的路由信息，可以独立提供服务。Broker会与所有NameServer节点建立长连接，定期上报Broker的路由信息。客户端会选择连接某一个NameServer节点，定期获取订阅主题的路由信息，用于Broker寻址。</p><p>NameServer的所有核心功能都是在RouteInfoManager这个类中实现的，这类中使用了几个Map来在内存中保存集群中所有Broker的路由信息。</p><p>我们还一起分析了RouteInfoManager中的两个比较关键的方法：注册Broker路由信息的方法registerBroker，以及查询Broker路由信息的方法pickupTopicRouteData。</p><p>建议你仔细读一下这两个方法的代码，结合保存路由信息的几个Map的数据结构，体会一下RocketMQ NameServer这种简洁的设计。</p><p>把以上的这些NameServer的设计和实现方法抽象一下，我们就可以总结出通用的NamingService的设计思想。</p><p>NamingService负责保存集群内所有节点的路由信息，NamingService本身也是一个小集群，由多个NamingService节点组成。这里我们所说的“路由信息”也是一种通用的抽象，含义是：“客户端需要访问的某个特定服务在哪个节点上”。</p><p>集群中的节点主动连接NamingService服务，注册自身的路由信息。给客户端提供路由寻址服务的方式可以有两种，一种是客户端直接连接NamingService服务查询路由信息，另一种是，客户端连接集群内任意节点查询路由信息，节点再从自身的缓存或者从NamingService上进行查询。</p><p>掌握了以上这些NamingService的设计方法，将会非常有助于你理解其他分布式系统的架构，当然，你也可以把这些方法应用到分布式系统的设计中去。</p><h2>思考题</h2><p>今天的思考题是这样的，在RocketMQ的NameServer集群中，各节点之间不需要互相通信，每个节点都可以独立的提供服务。课后请你想一想，这种独特的集群架构有什么优势，又有什么不足？欢迎在评论区留言写下你的想法。</p><p>感谢阅读，如果你觉得这篇文章对你有一些启发，也欢迎把它分享给你的朋友。</p><p></p>","neighbors":{"left":{"article_title":"22 | Kafka和RocketMQ的消息复制实现的差异点在哪？","id":136030},"right":{"article_title":"24 | Kafka的协调服务ZooKeeper：实现分布式系统的“瑞士军刀”","id":137655}},"comments":[{"had_liked":false,"id":133823,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1568680445,"is_pvip":false,"replies":[{"id":51342,"content":"这个我在之前的课程中讲到过，首先需要先看一下是消费慢还是生产慢，如果是生产慢，一般需要扩容Producer的节点数量，如果是消费慢，需要扩容队列数和Consumer数量。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568684374,"ip_address":"","comment_id":133823,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"线上环境突发消息延迟2个小时，该如何尽快解决？以及后期如何避免这类问题？说说你的思路和经验！","like_count":14},{"had_liked":false,"id":134751,"user_name":"康师傅","can_delete":false,"product_type":"c1","uid":1154203,"ip_address":"","ucode":"7D71E93E8B41AA","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/9b/eec0d41f.jpg","comment_is_top":false,"comment_ctime":1568908579,"is_pvip":false,"replies":[{"id":51727,"content":"理论上是可以的，但权衡工作量来说，最好还是换一个MQ吧。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568943002,"ip_address":"","comment_id":134751,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"对于rocketmq和kafka而言，都有自己的“注册中心”，但对于rabbitmq而言，它的集群允许你连接到集群中的任何一台进行生产消费，即便队列master所在节点并不是你连接的这台，rabbitmq内部会帮你进行中转，但这会有一个很大的弊端，就是节点间会有较大的流量并且不可控，并且整体的性能会受影响\n\n想请问下，这种时候，是否有较好的优化方式？\n想到的一个办法是，自行做一个NameServer，按队列进行注册分流，生产者消费者先与NameServer交互得到真实的节点ip，然后直接连接到队列master所在节点进行生产消费","like_count":9,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467517,"discussion_content":"这个我在之前的课程中讲到过，首先需要先看一下是消费慢还是生产慢，如果是生产慢，一般需要扩容Producer的节点数量，如果是消费慢，需要扩容队列数和Consumer数量。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568684374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014573,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","nickname":"SharpBB","note":"","ucode":"D30C5B798B8E8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574217,"discussion_content":"消费慢的情况可以看看消费代码有没有问题 可以考虑使用批量消费","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653906294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144586,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1571973457,"is_pvip":false,"replies":[{"id":55894,"content":"一是查一下每个分区入队速度是不是均匀，另外在消费者加一个消费监控（记录每次消费的时延）看一下消费速度是不是有问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572141180,"ip_address":"","comment_id":144586,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，我们生产环境。同一个group，多台机器消费同一个topic消息，遇到了某几个实例消费的分区延迟特别高，导致消息堆积的情况。但另外几个实例消费的分区并没有堆积。这通过扩容consumer也没法解决。而且很难排查，有什么好的方式吗","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467887,"discussion_content":"理论上是可以的，但权衡工作量来说，最好还是换一个MQ吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568943002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152225,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1573921254,"is_pvip":false,"replies":[{"id":58721,"content":"是的，RocketMQ的NameServer数据是以Broker上的为准，并且是从Broker上同步过来的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574123821,"ip_address":"","comment_id":152225,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"请问下老师，如果 nameserver 有节点重启了或是新加了一个节点，恢复内存中的路由数据过程是通过 broker 的心跳上报路由信息重新注册一遍吗？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474759,"discussion_content":"是的，RocketMQ的NameServer数据是以Broker上的为准，并且是从Broker上同步过来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574123821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134431,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1568823425,"is_pvip":true,"replies":[{"id":51550,"content":"主题和队列是分散到所有Broker节点上的，每个Broker只保存自己负责的那部分主题和队列信息。并且实际上在集群中，元数据最终是以Broker上保存的信息为准的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568856446,"ip_address":"","comment_id":134431,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"NamingService集群有点像去中心化的结构设计，每个节点保存所有数据，很好的保证了节点的可用性，但每个节点之间不互相通信，很难确保节点间的数据一致性。想问下老师主题(和其中队列)在broker节点的分布情况是怎样的","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467744,"discussion_content":"主题和队列是分散到所有Broker节点上的，每个Broker只保存自己负责的那部分主题和队列信息。并且实际上在集群中，元数据最终是以Broker上保存的信息为准的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053914,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/da/0a012c26.jpg","nickname":"孤帆","note":"","ucode":"8CC9AAF28944EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192394,"discussion_content":"主题和队列是分散在各个broker节点上的，不好理解啊。\n\n那么一条消息只落盘一次吗？我看 rocketmq 有2m2s部署方式，这时候一个topic的msg应该是在2master上均匀分布，而每个slave各自复制自己master的数据。不知道我这样理解是否正确？\n\n这样理解也有问题，相当于2个master只是用于“数据”的分片，那么分片的维度是什么呢？topic？queue？hash(topic + queue)?\n\n所以，这样想，2 master 2 slave 的部署方式是否有用？只是为了分片而已，解决的是消息量大的问题，如果实在是太大，不妨再用一套 1 master n slave 的实例即可呀。\n\n那么，1 master 1 slave 的部署方式，生产 和 消费 对于 broker 有要求吗？对比 MySQL，master for write, slave for read，但是 RocketMQ 则不是这么单纯的read/write，RocketMQ的consumer成功消费消息后，是需要修改 queue 的消费记录信息的，即消费也是写，只是与生产写的数据不一样。\n\n这样推论，mq 的 master 和 slave 之间应该是数据复制存储，master 负责消息数据写入，生产时master主动同步各个slave消息，slave负责消息消费记录修改，消费是slave主动同步master和各个slave消费消息。\n\n感觉还是不合理~ don&#39;t make sense","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583073559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133821,"user_name":"Stalary","can_delete":false,"product_type":"c1","uid":1101749,"ip_address":"","ucode":"F69AFF7C958D31","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/b5/d1ec6a7d.jpg","comment_is_top":false,"comment_ctime":1568679855,"is_pvip":false,"replies":[{"id":51339,"content":"这又是一个设计选择而已，NameServer只是负责存储一下元数据，数据量不大，处理请求的TPS也不高，所以没必要启动很多个NameServer，所以并不会存在你说的很多个NameServer的情况。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568684169,"ip_address":"","comment_id":133821,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，我想问一下，如果起了很多个NameServer，都保持长连接的话是不是开销会较大呢，为什么没有采用订阅发布的模式去更新broker呢，是因为即时性吗","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467516,"discussion_content":"这又是一个设计选择而已，NameServer只是负责存储一下元数据，数据量不大，处理请求的TPS也不高，所以没必要启动很多个NameServer，所以并不会存在你说的很多个NameServer的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568684169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215966,"user_name":"Yippee","can_delete":false,"product_type":"c1","uid":1417224,"ip_address":"","ucode":"AC4F7F6457AA5D","user_header":"https://static001.geekbang.org/account/avatar/00/15/a0/08/065b3cf5.jpg","comment_is_top":false,"comment_ctime":1589160350,"is_pvip":false,"replies":[{"id":79948,"content":"我们使用当前最新的 release 版本 release-4.5.1 进行分析，使用 Git 在 GitHub 上直接下载源码到本地：\n\ngit clone git@github.com:apache&#47;rocketmq.git\ncd rocketmq\ngit checkout release-4.5.1","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589171733,"ip_address":"","comment_id":215966,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"想问下老师文中讲的代码是基于 RocketMQ 的哪个版本啊，我在 4.5.1 和 4.7.0 中找不到 RouteInfoManager 等类","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494627,"discussion_content":"我们使用当前最新的 release 版本 release-4.5.1 进行分析，使用 Git 在 GitHub 上直接下载源码到本地：\n\ngit clone git@github.com:apache/rocketmq.git\ncd rocketmq\ngit checkout release-4.5.1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589171733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214589,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1588769428,"is_pvip":false,"replies":[{"id":79933,"content":"所以一般生产环境都使用多个NameServer节点来避免单点故障。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589170547,"ip_address":"","comment_id":214589,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师你好，有个疑问就是如果客户端链接的那个nameserver不可用了怎么办呢，如果broker也恰好有变动，那这些客户端是不是也都不可用了。且无法自动恢复","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494627,"discussion_content":"我们使用当前最新的 release 版本 release-4.5.1 进行分析，使用 Git 在 GitHub 上直接下载源码到本地：\n\ngit clone git@github.com:apache/rocketmq.git\ncd rocketmq\ngit checkout release-4.5.1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589171733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179118,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1581922839,"is_pvip":false,"replies":[{"id":69995,"content":"是的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582246797,"ip_address":"","comment_id":179118,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"假如其中一台NameServer挂了，客户端会自动切换到其他的吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494130,"discussion_content":"所以一般生产环境都使用多个NameServer节点来避免单点故障。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589170547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144589,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1571973586,"is_pvip":false,"replies":[{"id":55895,"content":"挂了也不影响集群正常使用，尽快修复就好了","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572141357,"ip_address":"","comment_id":144589,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"nameServer本身某几个实例挂了，会怎么处理呢","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472018,"discussion_content":"挂了也不影响集群正常使用，尽快修复就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572141357,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133823,"user_name":"业余草","can_delete":false,"product_type":"c1","uid":1126538,"ip_address":"","ucode":"99BDC1E629049D","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/8a/b5ca7286.jpg","comment_is_top":false,"comment_ctime":1568680445,"is_pvip":false,"replies":[{"id":51342,"content":"这个我在之前的课程中讲到过，首先需要先看一下是消费慢还是生产慢，如果是生产慢，一般需要扩容Producer的节点数量，如果是消费慢，需要扩容队列数和Consumer数量。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568684374,"ip_address":"","comment_id":133823,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"线上环境突发消息延迟2个小时，该如何尽快解决？以及后期如何避免这类问题？说说你的思路和经验！","like_count":14,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467517,"discussion_content":"这个我在之前的课程中讲到过，首先需要先看一下是消费慢还是生产慢，如果是生产慢，一般需要扩容Producer的节点数量，如果是消费慢，需要扩容队列数和Consumer数量。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568684374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2014573,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/bd/6d/7010f98e.jpg","nickname":"SharpBB","note":"","ucode":"D30C5B798B8E8C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574217,"discussion_content":"消费慢的情况可以看看消费代码有没有问题 可以考虑使用批量消费","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653906294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134751,"user_name":"康师傅","can_delete":false,"product_type":"c1","uid":1154203,"ip_address":"","ucode":"7D71E93E8B41AA","user_header":"https://static001.geekbang.org/account/avatar/00/11/9c/9b/eec0d41f.jpg","comment_is_top":false,"comment_ctime":1568908579,"is_pvip":false,"replies":[{"id":51727,"content":"理论上是可以的，但权衡工作量来说，最好还是换一个MQ吧。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568943002,"ip_address":"","comment_id":134751,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"对于rocketmq和kafka而言，都有自己的“注册中心”，但对于rabbitmq而言，它的集群允许你连接到集群中的任何一台进行生产消费，即便队列master所在节点并不是你连接的这台，rabbitmq内部会帮你进行中转，但这会有一个很大的弊端，就是节点间会有较大的流量并且不可控，并且整体的性能会受影响\n\n想请问下，这种时候，是否有较好的优化方式？\n想到的一个办法是，自行做一个NameServer，按队列进行注册分流，生产者消费者先与NameServer交互得到真实的节点ip，然后直接连接到队列master所在节点进行生产消费","like_count":9,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467887,"discussion_content":"理论上是可以的，但权衡工作量来说，最好还是换一个MQ吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568943002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144586,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1571973457,"is_pvip":false,"replies":[{"id":55894,"content":"一是查一下每个分区入队速度是不是均匀，另外在消费者加一个消费监控（记录每次消费的时延）看一下消费速度是不是有问题。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572141180,"ip_address":"","comment_id":144586,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，我们生产环境。同一个group，多台机器消费同一个topic消息，遇到了某几个实例消费的分区延迟特别高，导致消息堆积的情况。但另外几个实例消费的分区并没有堆积。这通过扩容consumer也没法解决。而且很难排查，有什么好的方式吗","like_count":8,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472017,"discussion_content":"一是查一下每个分区入队速度是不是均匀，另外在消费者加一个消费监控（记录每次消费的时延）看一下消费速度是不是有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572141180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152225,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1573921254,"is_pvip":false,"replies":[{"id":58721,"content":"是的，RocketMQ的NameServer数据是以Broker上的为准，并且是从Broker上同步过来的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1574123821,"ip_address":"","comment_id":152225,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"请问下老师，如果 nameserver 有节点重启了或是新加了一个节点，恢复内存中的路由数据过程是通过 broker 的心跳上报路由信息重新注册一遍吗？","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472017,"discussion_content":"一是查一下每个分区入队速度是不是均匀，另外在消费者加一个消费监控（记录每次消费的时延）看一下消费速度是不是有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572141180,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134431,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1568823425,"is_pvip":true,"replies":[{"id":51550,"content":"主题和队列是分散到所有Broker节点上的，每个Broker只保存自己负责的那部分主题和队列信息。并且实际上在集群中，元数据最终是以Broker上保存的信息为准的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568856446,"ip_address":"","comment_id":134431,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"NamingService集群有点像去中心化的结构设计，每个节点保存所有数据，很好的保证了节点的可用性，但每个节点之间不互相通信，很难确保节点间的数据一致性。想问下老师主题(和其中队列)在broker节点的分布情况是怎样的","like_count":3,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474759,"discussion_content":"是的，RocketMQ的NameServer数据是以Broker上的为准，并且是从Broker上同步过来的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574123821,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":133821,"user_name":"Stalary","can_delete":false,"product_type":"c1","uid":1101749,"ip_address":"","ucode":"F69AFF7C958D31","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/b5/d1ec6a7d.jpg","comment_is_top":false,"comment_ctime":1568679855,"is_pvip":false,"replies":[{"id":51339,"content":"这又是一个设计选择而已，NameServer只是负责存储一下元数据，数据量不大，处理请求的TPS也不高，所以没必要启动很多个NameServer，所以并不会存在你说的很多个NameServer的情况。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1568684169,"ip_address":"","comment_id":133821,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师，我想问一下，如果起了很多个NameServer，都保持长连接的话是不是开销会较大呢，为什么没有采用订阅发布的模式去更新broker呢，是因为即时性吗","like_count":2,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467744,"discussion_content":"主题和队列是分散到所有Broker节点上的，每个Broker只保存自己负责的那部分主题和队列信息。并且实际上在集群中，元数据最终是以Broker上保存的信息为准的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568856446,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053914,"avatar":"https://static001.geekbang.org/account/avatar/00/10/14/da/0a012c26.jpg","nickname":"孤帆","note":"","ucode":"8CC9AAF28944EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":192394,"discussion_content":"主题和队列是分散在各个broker节点上的，不好理解啊。\n\n那么一条消息只落盘一次吗？我看 rocketmq 有2m2s部署方式，这时候一个topic的msg应该是在2master上均匀分布，而每个slave各自复制自己master的数据。不知道我这样理解是否正确？\n\n这样理解也有问题，相当于2个master只是用于“数据”的分片，那么分片的维度是什么呢？topic？queue？hash(topic + queue)?\n\n所以，这样想，2 master 2 slave 的部署方式是否有用？只是为了分片而已，解决的是消息量大的问题，如果实在是太大，不妨再用一套 1 master n slave 的实例即可呀。\n\n那么，1 master 1 slave 的部署方式，生产 和 消费 对于 broker 有要求吗？对比 MySQL，master for write, slave for read，但是 RocketMQ 则不是这么单纯的read/write，RocketMQ的consumer成功消费消息后，是需要修改 queue 的消费记录信息的，即消费也是写，只是与生产写的数据不一样。\n\n这样推论，mq 的 master 和 slave 之间应该是数据复制存储，master 负责消息数据写入，生产时master主动同步各个slave消息，slave负责消息消费记录修改，消费是slave主动同步master和各个slave消费消息。\n\n感觉还是不合理~ don&#39;t make sense","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583073559,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215966,"user_name":"Yippee","can_delete":false,"product_type":"c1","uid":1417224,"ip_address":"","ucode":"AC4F7F6457AA5D","user_header":"https://static001.geekbang.org/account/avatar/00/15/a0/08/065b3cf5.jpg","comment_is_top":false,"comment_ctime":1589160350,"is_pvip":false,"replies":[{"id":79948,"content":"我们使用当前最新的 release 版本 release-4.5.1 进行分析，使用 Git 在 GitHub 上直接下载源码到本地：\n\ngit clone git@github.com:apache&#47;rocketmq.git\ncd rocketmq\ngit checkout release-4.5.1","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589171733,"ip_address":"","comment_id":215966,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"想问下老师文中讲的代码是基于 RocketMQ 的哪个版本啊，我在 4.5.1 和 4.7.0 中找不到 RouteInfoManager 等类","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":467516,"discussion_content":"这又是一个设计选择而已，NameServer只是负责存储一下元数据，数据量不大，处理请求的TPS也不高，所以没必要启动很多个NameServer，所以并不会存在你说的很多个NameServer的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1568684169,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214589,"user_name":"丁小明","can_delete":false,"product_type":"c1","uid":1207622,"ip_address":"","ucode":"CC23857B8D75D5","user_header":"https://static001.geekbang.org/account/avatar/00/12/6d/46/e16291f8.jpg","comment_is_top":false,"comment_ctime":1588769428,"is_pvip":false,"replies":[{"id":79933,"content":"所以一般生产环境都使用多个NameServer节点来避免单点故障。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1589170547,"ip_address":"","comment_id":214589,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"老师你好，有个疑问就是如果客户端链接的那个nameserver不可用了怎么办呢，如果broker也恰好有变动，那这些客户端是不是也都不可用了。且无法自动恢复","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494130,"discussion_content":"所以一般生产环境都使用多个NameServer节点来避免单点故障。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589170547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179118,"user_name":"fomy","can_delete":false,"product_type":"c1","uid":1125834,"ip_address":"","ucode":"CD87EA03B1F327","user_header":"https://static001.geekbang.org/account/avatar/00/11/2d/ca/02b0e397.jpg","comment_is_top":false,"comment_ctime":1581922839,"is_pvip":false,"replies":[{"id":69995,"content":"是的。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1582246797,"ip_address":"","comment_id":179118,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"假如其中一台NameServer挂了，客户端会自动切换到其他的吗？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484096,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582246797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144589,"user_name":"我已经设置了昵称","can_delete":false,"product_type":"c1","uid":1364034,"ip_address":"","ucode":"ED672C5EBDBDC4","user_header":"https://static001.geekbang.org/account/avatar/00/14/d0/42/6fd01fb9.jpg","comment_is_top":false,"comment_ctime":1571973586,"is_pvip":false,"replies":[{"id":55895,"content":"挂了也不影响集群正常使用，尽快修复就好了","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1572141357,"ip_address":"","comment_id":144589,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100032301,"comment_content":"nameServer本身某几个实例挂了，会怎么处理呢","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484096,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582246797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140125,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1570836086,"is_pvip":false,"replies":[{"id":54192,"content":"实际上，RocketMQ的路由数据是以Broker为准的，所以不会存在数据不一致的情况。由于NameServer与Broker有心跳机制，在这种发生网络隔离情况下，每个NameServer上就只有它可以连通的那些Broker的路由数据了。这也符合实际情况。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1570843095,"ip_address":"","comment_id":140125,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"请问一下老师，如果namingServer集群的各节点在多机房部署，如果一个机房与所有broker的通信中断了，那这个节点的namingServer上的信息就与其他namingServer不一致了，出现这种情况怎么办？","like_count":0},{"had_liked":false,"id":134969,"user_name":"益军","can_delete":false,"product_type":"c1","uid":1002317,"ip_address":"","ucode":"5629FA62A01F25","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/4d/0239bc19.jpg","comment_is_top":false,"comment_ctime":1568964389,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"优点:  nameserver本身设计为无状态，实现简单，\n缺点: broker客户端通信成本复杂，适合在客户端环境完全可控的情况下设计。namesrv 一致性无法保证，需要定时幂等性心跳保持最终一致性。","like_count":29,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470260,"discussion_content":"实际上，RocketMQ的路由数据是以Broker为准的，所以不会存在数据不一致的情况。由于NameServer与Broker有心跳机制，在这种发生网络隔离情况下，每个NameServer上就只有它可以连通的那些Broker的路由数据了。这也符合实际情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570843095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2278966,"avatar":"https://static001.geekbang.org/account/avatar/00/22/c6/36/70f2083c.jpg","nickname":"open！？","note":"","ucode":"53E6D336DB7F22","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582281,"discussion_content":"如果某一个NameServer与所有的broker都断开了，这时也应该和所有的客户端断开把 ，相当于NameServer下线了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659346672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1614410,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","nickname":"老杨在努力","note":"","ucode":"AA541B3BAD53A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47570,"discussion_content":"WL的意思应该是：所有Broker都和这个机房的NameServer失去连接，这时，这个NameServer的路由信息及不是最新的，这时如果客户端去连接，拿到的数据有可能就是旧的，这个情况下怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573368907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152226,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1573921913,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"优点：实现简单，集群节点平等，比较容易的水平扩展节点数量提供高可用性。路由数据读写都是内存，QPS比较高。\n缺点：每个 broker 需要与所有 nameserver 节点心跳通信，通信成本较大，无法保证强一致性。","like_count":8},{"had_liked":false,"id":134355,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1568812392,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"    老师最近的课都是在啃代码且非常整体性：学习上是越来越辛苦了，总要翻阅和梳理知识才能明白题目可能的问题。\n    节点之间不互相通信其实减少了网络开销以及相互的等待确认的过程从而节约了时间,不会互相影响互相继承：换个角度来思考这个问题其实就像是我们用虚拟化一样，RocketMQ的这种NameServer就像是docker&#47;Kubernetes，各自出了问题不会影响其它的docker&#47;K8。\n   优势就是减少了节点之间的通信以及等待的代价，不足就是出了问题如何发现以及通知系统&#47;服务端。等待老师对于这个问题的答案的公布：等待明天老师继续的分享，谢谢。","like_count":2},{"had_liked":false,"id":133829,"user_name":"糖醋🏀","can_delete":false,"product_type":"c1","uid":1118333,"ip_address":"","ucode":"E6FD12D630B439","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/7d/a9b5d5f0.jpg","comment_is_top":false,"comment_ctime":1568681171,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"nnameserver各个节点独立不通信，是ap的思路。\n各个节点总是可用，但是节点之间不通信，有可能由于网络原因，某个节点的路由信息可能会不一致。\n客户端拉去所有节点的路由信息，可以弥补某个节点路由信息不一致的情况。","like_count":2},{"had_liked":false,"id":248142,"user_name":"亚林","can_delete":false,"product_type":"c1","uid":1018972,"ip_address":"","ucode":"4A5A6D24314B79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","comment_is_top":false,"comment_ctime":1600043916,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"牺牲一致性，提高可用性","like_count":1},{"had_liked":false,"id":383793,"user_name":"大毛","can_delete":false,"product_type":"c1","uid":1899599,"ip_address":"北京","ucode":"93B18287F06706","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","comment_is_top":false,"comment_ctime":1699640894,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"优势：\n1 - 每个节点都是独立的，不需要考虑类似主从同步这种问题，实现起来比较简单。\n劣势：\n1 - 数据一致性的保证比较弱，每个节点的数据取决于 Brocker 上报的数据是否成功被 NameServer 正确处理。如果某次数据上报对一个节点成功，另一个节点失败，会导致这两个节点的数据不一致。\n2 - 会消耗更多的资源，每个 Brocker 需要和每个 NameServer 进行通信。在超大规模集群下，可能这种通信本身就成为瓶颈","like_count":0},{"had_liked":false,"id":367550,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"上海","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1675317086,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"NameServer是单独存在的服务吗，像Kafka和Zookpeer？RocketMQ好像没有Zookpeer，它是怎么做的？","like_count":0},{"had_liked":false,"id":354074,"user_name":"莫名其妙的人","can_delete":false,"product_type":"c1","uid":2913151,"ip_address":"广东","ucode":"357BBFD602C160","user_header":"https://static001.geekbang.org/account/avatar/00/2c/73/7f/9088256b.jpg","comment_is_top":false,"comment_ctime":1660058957,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"文章没有提到客户端与哪个NameServer节点通信，看了一些网上说法，应该是客户端只需要链接NameServer集群地址，然后产生一个随机数取模（失败则轮训即可）。这种随机选择策略不会产生一些不均衡吗？为什么不适用负载均衡，动态路由等方式呢？\n","like_count":0},{"had_liked":false,"id":279095,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1613619384,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"1.越简单的设计,健壮性越好,越单一的功能,性能越好,这样设计必然提供了更高的性能\n2,但是容易出现无法保证一致性的问题,但是我想,可能RMQ也不在乎","like_count":0,"discussions":[{"author":{"id":1178465,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fb/61/1394e631.jpg","nickname":"木子华","note":"","ucode":"350B0BF4E52845","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24478,"discussion_content":"益军大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570154206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":140125,"user_name":"WL","can_delete":false,"product_type":"c1","uid":1173771,"ip_address":"","ucode":"6277DCD776B87E","user_header":"https://static001.geekbang.org/account/avatar/00/11/e9/0b/1171ac71.jpg","comment_is_top":false,"comment_ctime":1570836086,"is_pvip":false,"replies":[{"id":54192,"content":"实际上，RocketMQ的路由数据是以Broker为准的，所以不会存在数据不一致的情况。由于NameServer与Broker有心跳机制，在这种发生网络隔离情况下，每个NameServer上就只有它可以连通的那些Broker的路由数据了。这也符合实际情况。","user_name":"作者回复","user_name_real":"李玥","uid":1501046,"ctime":1570843095,"ip_address":"","comment_id":140125,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"请问一下老师，如果namingServer集群的各节点在多机房部署，如果一个机房与所有broker的通信中断了，那这个节点的namingServer上的信息就与其他namingServer不一致了，出现这种情况怎么办？","like_count":0,"discussions":[{"author":{"id":1501046,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e7/76/79c1f23a.jpg","nickname":"李玥","note":"","ucode":"B19E91EE248591","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":470260,"discussion_content":"实际上，RocketMQ的路由数据是以Broker为准的，所以不会存在数据不一致的情况。由于NameServer与Broker有心跳机制，在这种发生网络隔离情况下，每个NameServer上就只有它可以连通的那些Broker的路由数据了。这也符合实际情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570843095,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2278966,"avatar":"https://static001.geekbang.org/account/avatar/00/22/c6/36/70f2083c.jpg","nickname":"open！？","note":"","ucode":"53E6D336DB7F22","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582281,"discussion_content":"如果某一个NameServer与所有的broker都断开了，这时也应该和所有的客户端断开把 ，相当于NameServer下线了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659346672,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"浙江","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1614410,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLM5CXZWgJuUXXbia0Gs8Th9wiacxAmibNd1qEMu1xkvUz7GEiaVUQMUfYF8SErPtrHWGuNwoSFrPgAdQ/132","nickname":"老杨在努力","note":"","ucode":"AA541B3BAD53A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":47570,"discussion_content":"WL的意思应该是：所有Broker都和这个机房的NameServer失去连接，这时，这个NameServer的路由信息及不是最新的，这时如果客户端去连接，拿到的数据有可能就是旧的，这个情况下怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573368907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":134969,"user_name":"益军","can_delete":false,"product_type":"c1","uid":1002317,"ip_address":"","ucode":"5629FA62A01F25","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4b/4d/0239bc19.jpg","comment_is_top":false,"comment_ctime":1568964389,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"优点:  nameserver本身设计为无状态，实现简单，\n缺点: broker客户端通信成本复杂，适合在客户端环境完全可控的情况下设计。namesrv 一致性无法保证，需要定时幂等性心跳保持最终一致性。","like_count":29,"discussions":[{"author":{"id":1178465,"avatar":"https://static001.geekbang.org/account/avatar/00/11/fb/61/1394e631.jpg","nickname":"木子华","note":"","ucode":"350B0BF4E52845","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":24478,"discussion_content":"益军大佬","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1570154206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152226,"user_name":"饭粒","can_delete":false,"product_type":"c1","uid":1153455,"ip_address":"","ucode":"4C3220B0D43997","user_header":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","comment_is_top":false,"comment_ctime":1573921913,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"优点：实现简单，集群节点平等，比较容易的水平扩展节点数量提供高可用性。路由数据读写都是内存，QPS比较高。\n缺点：每个 broker 需要与所有 nameserver 节点心跳通信，通信成本较大，无法保证强一致性。","like_count":8},{"had_liked":false,"id":134355,"user_name":"leslie","can_delete":false,"product_type":"c1","uid":1324255,"ip_address":"","ucode":"798E7C1CC98CC2","user_header":"https://static001.geekbang.org/account/avatar/00/14/34/df/64e3d533.jpg","comment_is_top":false,"comment_ctime":1568812392,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"    老师最近的课都是在啃代码且非常整体性：学习上是越来越辛苦了，总要翻阅和梳理知识才能明白题目可能的问题。\n    节点之间不互相通信其实减少了网络开销以及相互的等待确认的过程从而节约了时间,不会互相影响互相继承：换个角度来思考这个问题其实就像是我们用虚拟化一样，RocketMQ的这种NameServer就像是docker&#47;Kubernetes，各自出了问题不会影响其它的docker&#47;K8。\n   优势就是减少了节点之间的通信以及等待的代价，不足就是出了问题如何发现以及通知系统&#47;服务端。等待老师对于这个问题的答案的公布：等待明天老师继续的分享，谢谢。","like_count":2},{"had_liked":false,"id":133829,"user_name":"糖醋🏀","can_delete":false,"product_type":"c1","uid":1118333,"ip_address":"","ucode":"E6FD12D630B439","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/7d/a9b5d5f0.jpg","comment_is_top":false,"comment_ctime":1568681171,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"nnameserver各个节点独立不通信，是ap的思路。\n各个节点总是可用，但是节点之间不通信，有可能由于网络原因，某个节点的路由信息可能会不一致。\n客户端拉去所有节点的路由信息，可以弥补某个节点路由信息不一致的情况。","like_count":2},{"had_liked":false,"id":248142,"user_name":"亚林","can_delete":false,"product_type":"c1","uid":1018972,"ip_address":"","ucode":"4A5A6D24314B79","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8c/5c/3f164f66.jpg","comment_is_top":false,"comment_ctime":1600043916,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"牺牲一致性，提高可用性","like_count":1},{"had_liked":false,"id":383793,"user_name":"大毛","can_delete":false,"product_type":"c1","uid":1899599,"ip_address":"北京","ucode":"93B18287F06706","user_header":"https://static001.geekbang.org/account/avatar/00/1c/fc/4f/0a452c94.jpg","comment_is_top":false,"comment_ctime":1699640894,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"优势：\n1 - 每个节点都是独立的，不需要考虑类似主从同步这种问题，实现起来比较简单。\n劣势：\n1 - 数据一致性的保证比较弱，每个节点的数据取决于 Brocker 上报的数据是否成功被 NameServer 正确处理。如果某次数据上报对一个节点成功，另一个节点失败，会导致这两个节点的数据不一致。\n2 - 会消耗更多的资源，每个 Brocker 需要和每个 NameServer 进行通信。在超大规模集群下，可能这种通信本身就成为瓶颈","like_count":0},{"had_liked":false,"id":367550,"user_name":"谁都会变","can_delete":false,"product_type":"c1","uid":1195017,"ip_address":"上海","ucode":"9965748F7EBB57","user_header":"https://static001.geekbang.org/account/avatar/00/12/3c/09/b7f0eac6.jpg","comment_is_top":false,"comment_ctime":1675317086,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"NameServer是单独存在的服务吗，像Kafka和Zookpeer？RocketMQ好像没有Zookpeer，它是怎么做的？","like_count":0},{"had_liked":false,"id":354074,"user_name":"莫名其妙的人","can_delete":false,"product_type":"c1","uid":2913151,"ip_address":"广东","ucode":"357BBFD602C160","user_header":"https://static001.geekbang.org/account/avatar/00/2c/73/7f/9088256b.jpg","comment_is_top":false,"comment_ctime":1660058957,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"文章没有提到客户端与哪个NameServer节点通信，看了一些网上说法，应该是客户端只需要链接NameServer集群地址，然后产生一个随机数取模（失败则轮训即可）。这种随机选择策略不会产生一些不均衡吗？为什么不适用负载均衡，动态路由等方式呢？\n","like_count":0},{"had_liked":false,"id":279095,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1613619384,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":3,"product_id":100032301,"comment_content":"1.越简单的设计,健壮性越好,越单一的功能,性能越好,这样设计必然提供了更高的性能\n2,但是容易出现无法保证一致性的问题,但是我想,可能RMQ也不在乎","like_count":0},{"had_liked":false,"id":266574,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1607397864,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":" rocketmq 如何在集群中找到正确的节点。\n \n 核心是利用的NameServer 和broker 联合实现的。\n 1 每个broker 都和全部的NameServer 进行通信。\n 2 当broker 上Topic信息发生改变的时候，会通知所有的NameServer 更新路由信息，同时broker 也会定时把信息\n   上报到所有的NameServer节点。这个就起到了NameServer对broker 进行健康检测的作用。\n3  每台NameServer 都能单独提供服务。当NameServer 和broker 之间的通信断掉，消费者会重新去NameServer上拉\n  取别的broker 信息，这样就起到了自动切换失效Broker的作用。   ","like_count":0},{"had_liked":false,"id":249080,"user_name":"信大捷安","can_delete":false,"product_type":"c1","uid":1748552,"ip_address":"","ucode":"096797EEB7A14E","user_header":"","comment_is_top":false,"comment_ctime":1600422353,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"看了留言中，nameServer可以做一个集群，topic是散列在nameServer集群中的一个服务中，那么是如何保证topic正确的散列的其中的一个nameServer中的，很好奇？","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360746,"discussion_content":"首先理解是nameSever无状态的，每个topic的信息会通过各个broker上报给nameSever聚合出topic的全部属性给到客户端。客户连接时会自动relance拿到topic的meaage queue","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616511103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146688,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":1595382,"ip_address":"","ucode":"A77322C4E07B2D","user_header":"https://static001.geekbang.org/account/avatar/00/18/57/f6/2c7ac1ad.jpg","comment_is_top":false,"comment_ctime":1572605299,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"优点是性能高，Broker只需关心单个节点，而不需要关注集群状态，客户端只需要和一个NameServer打交道，不用关心集群状态。\n缺点是不能保证一致性","like_count":0},{"had_liked":false,"id":144639,"user_name":"微笑","can_delete":false,"product_type":"c1","uid":1363834,"ip_address":"","ucode":"6E8E2964D0191F","user_header":"https://static001.geekbang.org/account/avatar/00/14/cf/7a/51951b07.jpg","comment_is_top":false,"comment_ctime":1571988196,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"nameserver服务感觉跟注册中心有点像","like_count":0},{"had_liked":false,"id":144403,"user_name":"柳俊波","can_delete":false,"product_type":"c1","uid":1102786,"ip_address":"","ucode":"9337313A1744A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/c2/4d485226.jpg","comment_is_top":false,"comment_ctime":1571912184,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"优点：\n1:Nameserver高可用，节点之间无状态，减少节点同步逻辑，非常轻量级。\n缺点：\n1:牺牲了一致性。两个nameserver数据不一致，导致消息数据倾斜","like_count":0},{"had_liked":false,"id":137471,"user_name":"姑射仙人","can_delete":false,"product_type":"c1","uid":1008517,"ip_address":"","ucode":"3EFC1F3E592165","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","comment_is_top":false,"comment_ctime":1569748889,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"还有个缺点是NameService不支持写扩展，增加服务节点无法水平扩展，让我想起了zookeeper。不知道理解是否正确。","like_count":0},{"had_liked":false,"id":133875,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1568689390,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"多个NameServer独立对外提供服务是一种用冗余的路由注册来换维持集群式的NameServer间数据一致性和高可用性的方式，集群部署不可避免需要在数据一致性和高可用性间平衡，这会给程序设计、编码和后溪维护带来很大的代价，因为路由信息本就不会太多，所以选择了前者。\n不过我更偏向于后者，单节点独立提供服务肯定会出现某个节点请求当前的NameServer找不到对应的正常Broker的情况，因为NameServer不能保证保存了完整的Broker集群拓扑。路由发现算法虽然会导致一些时间的服务不可用，但在Broker集群体量很大的时候，肯定比独立NameServer好点。当然目前也可以考虑部署RocketMQ集群，让每个独立的NameServer服务部分区域的Broker的设计思路吧","like_count":0},{"had_liked":false,"id":133857,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1568685003,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"这整个就是一个微服务架构","like_count":0},{"had_liked":false,"id":266574,"user_name":"prader26","can_delete":false,"product_type":"c1","uid":1433707,"ip_address":"","ucode":"5EFFFC374ADECE","user_header":"https://static001.geekbang.org/account/avatar/00/15/e0/6b/f61d7466.jpg","comment_is_top":false,"comment_ctime":1607397864,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":" rocketmq 如何在集群中找到正确的节点。\n \n 核心是利用的NameServer 和broker 联合实现的。\n 1 每个broker 都和全部的NameServer 进行通信。\n 2 当broker 上Topic信息发生改变的时候，会通知所有的NameServer 更新路由信息，同时broker 也会定时把信息\n   上报到所有的NameServer节点。这个就起到了NameServer对broker 进行健康检测的作用。\n3  每台NameServer 都能单独提供服务。当NameServer 和broker 之间的通信断掉，消费者会重新去NameServer上拉\n  取别的broker 信息，这样就起到了自动切换失效Broker的作用。   ","like_count":0},{"had_liked":false,"id":249080,"user_name":"信大捷安","can_delete":false,"product_type":"c1","uid":1748552,"ip_address":"","ucode":"096797EEB7A14E","user_header":"","comment_is_top":false,"comment_ctime":1600422353,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"看了留言中，nameServer可以做一个集群，topic是散列在nameServer集群中的一个服务中，那么是如何保证topic正确的散列的其中的一个nameServer中的，很好奇？","like_count":0,"discussions":[{"author":{"id":1066508,"avatar":"https://static001.geekbang.org/account/avatar/00/10/46/0c/773ba2f3.jpg","nickname":"下个目标45k","note":"","ucode":"193BA8C3AA9A61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360746,"discussion_content":"首先理解是nameSever无状态的，每个topic的信息会通过各个broker上报给nameSever聚合出topic的全部属性给到客户端。客户连接时会自动relance拿到topic的meaage queue","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616511103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146688,"user_name":"Peter","can_delete":false,"product_type":"c1","uid":1595382,"ip_address":"","ucode":"A77322C4E07B2D","user_header":"https://static001.geekbang.org/account/avatar/00/18/57/f6/2c7ac1ad.jpg","comment_is_top":false,"comment_ctime":1572605299,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"优点是性能高，Broker只需关心单个节点，而不需要关注集群状态，客户端只需要和一个NameServer打交道，不用关心集群状态。\n缺点是不能保证一致性","like_count":0},{"had_liked":false,"id":144639,"user_name":"微笑","can_delete":false,"product_type":"c1","uid":1363834,"ip_address":"","ucode":"6E8E2964D0191F","user_header":"https://static001.geekbang.org/account/avatar/00/14/cf/7a/51951b07.jpg","comment_is_top":false,"comment_ctime":1571988196,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"nameserver服务感觉跟注册中心有点像","like_count":0},{"had_liked":false,"id":144403,"user_name":"柳俊波","can_delete":false,"product_type":"c1","uid":1102786,"ip_address":"","ucode":"9337313A1744A4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d3/c2/4d485226.jpg","comment_is_top":false,"comment_ctime":1571912184,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"优点：\n1:Nameserver高可用，节点之间无状态，减少节点同步逻辑，非常轻量级。\n缺点：\n1:牺牲了一致性。两个nameserver数据不一致，导致消息数据倾斜","like_count":0},{"had_liked":false,"id":137471,"user_name":"姑射仙人","can_delete":false,"product_type":"c1","uid":1008517,"ip_address":"","ucode":"3EFC1F3E592165","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","comment_is_top":false,"comment_ctime":1569748889,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"还有个缺点是NameService不支持写扩展，增加服务节点无法水平扩展，让我想起了zookeeper。不知道理解是否正确。","like_count":0},{"had_liked":false,"id":133875,"user_name":"DFighting","can_delete":false,"product_type":"c1","uid":1233193,"ip_address":"","ucode":"F3BA2426FF8582","user_header":"https://static001.geekbang.org/account/avatar/00/12/d1/29/1b1234ed.jpg","comment_is_top":false,"comment_ctime":1568689390,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"多个NameServer独立对外提供服务是一种用冗余的路由注册来换维持集群式的NameServer间数据一致性和高可用性的方式，集群部署不可避免需要在数据一致性和高可用性间平衡，这会给程序设计、编码和后溪维护带来很大的代价，因为路由信息本就不会太多，所以选择了前者。\n不过我更偏向于后者，单节点独立提供服务肯定会出现某个节点请求当前的NameServer找不到对应的正常Broker的情况，因为NameServer不能保证保存了完整的Broker集群拓扑。路由发现算法虽然会导致一些时间的服务不可用，但在Broker集群体量很大的时候，肯定比独立NameServer好点。当然目前也可以考虑部署RocketMQ集群，让每个独立的NameServer服务部分区域的Broker的设计思路吧","like_count":0},{"had_liked":false,"id":133857,"user_name":"有铭","can_delete":false,"product_type":"c1","uid":1046302,"ip_address":"","ucode":"2C7CB36CA5C04C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/3XbCueYYVWTiclv8T5tFpwiblOxLphvSZxL4ujMdqVMibZnOiaFK2C5nKRGv407iaAsrI0CDICYVQJtiaITzkjfjbvrQ/132","comment_is_top":false,"comment_ctime":1568685003,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100032301,"comment_content":"这整个就是一个微服务架构","like_count":0}]}