{"id":237950,"title":"加餐 | ZAB协议（三）：如何处理读写请求？","content":"<p>你好，我是韩健！</p><p>你应该有这样的体会，如果你想了解一个网络服务，执行的第一个功能肯定是写操作，然后才执行读操作。比如，你要了解ZooKeeper，那么肯定会在zkCli.sh命令行中执行写操作（比如“create /geekbang 123”）写入数据，然后再是读操作（比如“get /geekbang”）查询数据。这样一来，你才会直观地理解ZooKeeper是如何使用的了。</p><p>在我看来，任何网络服务最重要的功能就是处理读写请求，因为我们访问网络服务本质上都是在执行读写操作，ZooKeeper也不例外。<strong>而且对ZooKeeper而言，这些功能更为重要，因为在ZooKeeper中，如何处理写请求，关乎着操作的顺序性，而操作的顺序性会影响节点的创建；如何处理读请求，关乎着一致性，它们又影响着客户端是否会读到旧数据。</strong></p><p>接下来，我会从ZooKeeper系统的角度，全面地分析整个读写请求的流程，帮助你更加全面、透彻地理解读写请求背后的原理。</p><p>你肯定知道，在ZooKeeper中，写请求是必须在领导者上处理，如果跟随者接收到了写请求，它需要将写请求转发给领导者，当写请求对应的提案被复制到大多数节点上时，领导者会提交提案，并通知跟随者提交提案。而读请求可以在任何节点上处理，也就是说，ZooKeeper实现的是最终一致性。</p><!-- [[[read_end]]] --><p>对你来说，理解了如何处理读写请求，不仅能理解读写这个最重要功能的核心原理，还能更好地理解ZooKeeper的性能和一致性。这样一来，当你在实际场景中安装部署ZooKeeper的时候，就能游刃有余地做资源规划了。比如，如果读请求比较多，你可以增加节点，配置5节点集群，而不是常见的3节点集群。</p><p>话不多说，我们进入今天的内容，一起探究ZooKeeper处理读写请求的背后原理和代码实现。</p><h2>ZooKeeper处理读写请求的原理</h2><p>其实，我在<a href=\"https://time.geekbang.org/column/article/229975\">15讲</a>演示“如何实现操作顺序性”时，就已经介绍了ZooKeeper是如何处理读写请求的了。所以在这里我就不啰嗦了，只是在此基础上，再补充几点。</p><p>首先，在ZooKeeper中，与领导者“失联”的节点，是不能处理读写请求的。比如，如果一个跟随者与领导者的连接发生了读超时，设置了自己的状态为LOOKING，那么此时它既不能转发写请求给领导者处理，也不能处理读请求，只有当它“找到”领导者后，才能处理读写请求。</p><p>举个例子：当发生分区故障了，C与A（领导者）、B网络不通了，那么C将设置自己的状态为LOOKING，此时在C节点上既不能执行读操作，也不能执行写操作。<br>\n<img src=\"https://static001.geekbang.org/resource/image/22/ad/22dfaa624590885c4b8406deb445afad.jpg?wh=1142*456\" alt=\"\"></p><p>其次，当大多数节点进入到广播阶段的时候，领导者才能提交提案，因为提案提交，需要来自大多数节点的确认。</p><p>最后，写请求只能在领导者节点上处理，所以ZooKeeper集群写性能约等于单机。而读请求是可以在所有的节点上处理的，所以，读性能是能水平扩展的。也就是说，你可以通过分集群的方式来突破写性能的限制，并通过增加更多节点，来扩展集群的读性能。</p><p>熟悉了ZooKeeper处理读写请求的过程和原理后，相信你应该好奇这些功能在ZooKeeper代码中是如何实现的呢？</p><h2>ZooKeeper代码是如何实现读写操作的呢？</h2><h3>如何实现写操作？</h3><p>我先来说一说写操作，在ZooKeeper代码中，处理写请求的核心流程就像下图一样（为了帮你更好的理解这部分内容，我来演示一下复杂的情况，也就是跟随者接收到写请求的情况）。</p><p><img src=\"https://static001.geekbang.org/resource/image/c7/8a/c77c241713b154673e15083fd063428a.jpg?wh=1142*948\" alt=\"\"></p><p>接下来，咱们一起走一遍核心代码的流程，加深一下印象。</p><p>1.跟随者在FollowerRequestProcessor.processRequest()中接收到写请求。具体来说，写请求是系统在ZooKeeperServer.submitRequestNow()中发给跟随者的。</p><pre><code>firstProcessor.processRequest(si);\n</code></pre><p>而firstProcessor，是在FollowerZooKeeperServer.setupRequestProcessors()中创建的。</p><pre><code>protected void setupRequestProcessors() {\n  // 创建finalProcessor，提交提案或响应查询     \n  RequestProcessor finalProcessor = new FinalRequestProcessor(this);\n  // 创建commitProcessor，处理提案提交或读请求\n  commitProcessor = new CommitProcessor(finalProcessor,   Long.toString(getServerId()), true, getZooKeeperServerListener());\n  commitProcessor.start();\n  // 创建firstProcessor，接收发给跟随者的请求\n  firstProcessor = new FollowerRequestProcessor(this, commitProcessor);\n  ((FollowerRequestProcessor) firstProcessor).start();\n  // 创建syncProcessor，将提案持久化存储，并返回确认响应给领导者\n  syncProcessor = new SyncRequestProcessor(this, new SendAckRequestProcessor(getFollower()));\n  syncProcessor.start();\n}\n</code></pre><p>需要你注意的是，跟随者节点和领导者节点的firstProcessor是不同的，这样当firstProcessor在ZooKeeperServer.submitRequestNow()中被调用时，就分别进入了跟随者和领导者的代码流程。另外，setupRequestProcessors()创建了2条处理链，就像下图的样子。</p><p><img src=\"https://static001.geekbang.org/resource/image/d5/e7/d5dfec8e64a2d3cb6f905421d5e918e7.jpg?wh=1142*593\" alt=\"\"></p><p>其中，处理链1是核心处理链，最终实现了提案提交和读请求对应的数据响应。处理链2实现了提案持久化存储，并返回确认响应给领导者。</p><p>2.跟随者在FollowerRequestProcessor.run()中将写请求转发给领导者。</p><pre><code>// 调用learner.request()将请求发送给领导者\nzks.getFollower().request(request);\n</code></pre><p>3.领导者在LeaderRequestProcessor.processRequest()中接收写请求，并最终调用pRequest()创建事务（也就是提案），并持久化存储。</p><pre><code>// 创建事务\npRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);\n......\n// 分配事务标识符\nrequest.zxid = zks.getZxid();\n// 调用ProposalRequestProcessor.processRequest()处理写请求，并将事务持久化存储\nnextProcessor.processRequest(request);\n</code></pre><p>在这里，需要你注意的是，写请求也是在ZooKeeperServer.submitRequestNow()中发给领导者的。</p><pre><code>firstProcessor.processRequest(si);\n</code></pre><p>而firstProcessor，是在LeaderZooKeeperServer.setupRequestProcessors()中创建的。</p><pre><code>protected void setupRequestProcessors() {\n  // 创建finalProcessor，最终提交提案和响应查询\n  RequestProcessor finalProcessor = new FinalRequestProcessor(this);\n  // 创建toBeAppliedProcessor，存储可提交的提案，并在提交提案后，从toBeApplied队列移除已提交的\n  RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());\n  // 创建commitProcessor，处理提案提交或读请求      \n  commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());\n  commitProcessor.start();\n  // 创建proposalProcessor，按照顺序广播提案给跟随者\n  ProposalRequestProcessor proposalProcessor = new ProposalRequestProcessor(this, commitProcessor);\n        proposalProcessor.initialize();\n  // 创建prepRequestProcessor，根据请求创建提案      \n  prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);\n  prepRequestProcessor.start();\n  // 创建firstProcessor，接收发给领导者的请求\n  firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);\n  ......\n}\n</code></pre><p>需要你注意的是，与跟随者类似，setupRequestProcessors()给领导者也创建了2条处理链（其中处理链2是在创建proposalRequestProcessor时创建的）。</p><p><img src=\"https://static001.geekbang.org/resource/image/f7/83/f780e2d141a766579ba20c3b3d0a2283.jpg?wh=1142*901\" alt=\"\"></p><p>其中，处理链1是核心处理链，最终实现了写请求处理（创建提案、广播提案、提交提案）和读请求对应的数据响应。处理链2实现了提案持久化存储，并返回确认响应给领导者自己。</p><p>4.领导者在ProposalRequestProcessor.processRequest()中，调用propose()将提案广播给集群所有节点。</p><pre><code>zks.getLeader().propose(request);\n</code></pre><p>5.跟随者在Follower.processPacket()中接收到提案，持久化存储，并返回确认响应给领导者。</p><pre><code>// 接收、持久化、返回确认响应给领导者\nfzk.logRequest(hdr, txn, digest);\n</code></pre><p>6.当领导者接收到大多数节点的确认响应（Leader.processAck()）后，最终在CommitProcessor.tryToCommit()提交提案，并广播COMMIT消息给跟随者。</p><pre><code>// 通知跟随者提交\ncommit(zxid);\n// 自己提交\nzk.commitProcessor.commit(p.request);\n</code></pre><p>7.当跟随者接收到COMMIT消息后，在FollowerZooKeeperServer.commit()中提交提案，如果最初的写请求是自己接收到的，返回成功响应给客户端。</p><pre><code>// 必须顺序提交\nlong firstElementZxid = pendingTxns.element().zxid;\nif (firstElementZxid != zxid) {\n  LOG.error(&quot;Committing zxid 0x&quot; + Long.toHexString(zxid)\n            + &quot; but next pending txn 0x&quot; + \n            Long.toHexString(firstElementZxid));\n  ServiceUtils.requestSystemExit(ExitCode.UNMATCHED_TXN_COMMIT.getValue());\n}\n// 将准备提交的提案从pendingTxns队列移除\nRequest request = pendingTxns.remove();\nrequest.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);\n// 最终调用FinalRequestProcessor.processRequest()提交提案，并如果最初的写请求是自己接收到的，返回成功响应给客户端\ncommitProcessor.commit(request);\n</code></pre><p>这样，ZooKeeper就完成了写请求的处理。你要特别注意一下，在分布式系统中，消息或者核心信息的持久化存储很关键，也很重要，因为这是保证集群能稳定运行的关键。</p><p>当然了，写入数据，最终还是为了后续的数据读取，那么在ZooKeeper中，是如何实现读操作的呢？</p><h3>如何实现读操作？</h3><p>相比写操作，读操作的处理要简单很多，因为接收到读请求的节点，只需要查询本地数据，然后响应数据给客户端就可以了。读操作的核心代码流程，如图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/f4/6d/f405d2a81f374e6e63b49c469506f26d.jpg?wh=1142*652\" alt=\"\"></p><p>咱们一起走一遍核心代码的流程，加深一下印象。</p><p>1.跟随者在FollowerRequestProcessor.processRequest()中接收到读请求。</p><p>2.跟随者在FinalRequestProcessor.processRequest()中查询本地数据，也就是dataTree中的数据。</p><pre><code>// 处理读请求\ncase OpCode.getData: {\n  ......\n  // 查询本地dataTree中的数据\n  rsp = handleGetDataRequest(getDataRequest, cnxn, request.authInfo);\n  ......\n  break;\n}\n</code></pre><p>3.然后跟随者响应查询到数据给客户端。</p><pre><code>case OpCode.getData : {\n  ......\n  // 响应查询到的数据给客户端\n  cnxn.sendResponse(hdr, rsp, &quot;response&quot;, path, stat, opCode);\n  break;\n}\n</code></pre><p>你看，这样ZooKeeper就完成读操作的处理。在这里，我想补充一点，你可以dataTree理解为Raft的状态机，提交的数据，最终存放在dataTree中。</p><h2>内容小结</h2><p>本节课我主要带你了解了ZooKeeper处理读写请求的过程，以及ZooKeeper的代码实现和核心流程。我希望你明确这样几个重点。</p><p>1.与领导者“失联”的跟随者（比如发生分区故障时），是既不能处理写请求，也不能处理读请求的。</p><p>2.在ZooKeeper中，写请求只能在领导者节点上处理，读请求可以在所有节点上处理，实现的是最终一致性。</p><p>因为本讲是ZAB协议的最后一讲，为了帮你后续学习本课程没有提到的内容，我想补充几点。</p><p>首先，ZAB的术语众多，而且有些术语表达的是同一个含义，这些术语有些在文档中出现，有些在代码中出现。而你只有准确理解术语，才能更好地理解ZAB协议的原理，所以，我补充一些内容。</p><ul>\n<li>提案（Proposal）：进行共识协商的基本单元，你可以理解为操作（Operation）或指令（Command），常出现在文档中。</li>\n<li>事务（Transaction）：也是指提案，常出现在代码中。比如，pRequest2Txn()将接收到的请求转换为事务；再比如，未提交提案会持久化存储在事务日志中。在这里需要你注意的是，这个术语很容易引起误解，因为它不是指更广泛被接受的含义，具有ACID特性的操作序列。</li>\n</ul><p>其次，在我看来，Raft算法和ZAB协议很类似，比如主备模式（也就是领导者、跟随者模型）、日志必须是连续的、以领导者的日志为准来实现日志一致等等。那为什么它们会比较类似呢？</p><p><strong>我的看法是，“英雄所见略同”。</strong>比如ZAB协议要实现操作的顺序性，而Raft的设计目标，不仅仅是操作的顺序性，而是线性一致性，这两个目标，都决定了它们不能允许日志不连续，要按照顺序提交日志，那么，它们就要通过上面的方法实现日志的顺序性，并保证达成共识（也就是提交）后的日志不会再改变。</p><p>最后，我想就ZAB和Raft做个对比，来具体说说ZAB和Raft的异同。既然我们要做对比，那么首先要定义对比标准，我是这么考虑的：你应该有这样的体会，同一个功能，不同的同学实现的代码都会不一样（比如数据结构、代码逻辑），所以过于细节的比较，尤其是偏系统实现方面的，意义不大（比如跟随者是否转发写请求到领导者，不仅意义不大，而且这是ZAB和Raft都没有约定的，是集群系统需要考虑的），我们可以从核心原理上做对比。</p><ul>\n<li>\n<p>领导者选举：ZAB采用的“见贤思齐、相互推荐”的快速领导者选举（Fast Leader Election），Raft采用的是“一张选票、先到先得”的自定义算法。在我看来，Raft的领导者选举，需要通讯的消息数更少，选举也更快。</p>\n</li>\n<li>\n<p>日志复制：Raft和ZAB相同，都是以领导者的日志为准来实现日志一致，而且日志必须是连续的，也必须按照顺序提交。</p>\n</li>\n<li>\n<p>读操作和一致性：ZAB的设计目标是操作的顺序性，在ZooKeeper中默认实现的是最终一致性，读操作可以在任何节点上执行；而Raft的设计目标是强一致性（也就是线性一致性），所以Raft更灵活，Raft系统既可以提供强一致性，也可以提供最终一致性。</p>\n</li>\n<li>\n<p>写操作：Raft和ZAB相同，写操作都必须在领导者节点上处理。</p>\n</li>\n<li>\n<p>成员变更：Raft和ZAB都支持成员变更，其中ZAB以动态配置（dynamic configuration）的方式实现的。那么当你在节点变更时，不需要重启机器，集群是一直运行的，服务也不会中断。</p>\n</li>\n<li>\n<p>其他：相比ZAB，Raft的设计更为简洁，比如Raft没有引入类似ZAB的成员发现和数据同步阶段，而是当节点发起选举时，递增任期编号，在选举结束后，广播心跳，直接建立领导者关系，然后向各节点同步日志，来实现数据副本的一致性。<strong>在我看来，ZAB的成员发现，可以和领导者选举合到一起，类似Raft，在领导者选举结束后，直接建立领导者关系，而不是再引入一个新的阶段；数据同步阶段，是一个冗余的设计，可以去除的，因为ZAB不是必须要先实现数据副本的一致性，才可以处理写请求，而且这个设计是没有额外的意义和价值的。</strong></p>\n</li>\n</ul><p>另外，ZAB和ZooKeeper强耦合，你无法在实际系统中独立使用；而Raft的实现（比如Hashicorp Raft）是可以独立使用的，编程友好。</p><h2>课堂思考</h2><p>我提到ZooKeeper提供的是最终一致性，读操作可以在任何节点上执行。那么如果读操作访问的是备份节点，为什么无法保证每次都能读到最新的数据呢？欢迎在留言区分享你的看法，与我一同讨论。</p><p>最后，感谢你的阅读，如果这节课让你有所收获，也欢迎你将它分享给更多的朋友。</p>","comments":[{"had_liked":false,"id":219398,"user_name":"zyz","can_delete":false,"product_type":"c1","uid":1019339,"ip_address":"","ucode":"0092F8C0FFA375","user_header":"","comment_is_top":false,"comment_ctime":1590022354,"is_pvip":false,"replies":[{"id":"81681","content":"加一颗星:)","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1590534807,"ip_address":"","comment_id":219398,"utype":1}],"discussion_count":5,"race_medal":0,"score":"31654793426","product_id":100046101,"comment_content":"Zookeeper通过Leader来主导写操作，保证了顺序一致性。当一半以上的节点返回已写入，就返回客户端已写入，但是这时候只是部分节点写入，有的节点可能还没有同步上数据，所以读取备份节点可能不是最新的。同时Zookeeper的单一视图特征，保证客户端看到的数据不会比在之前服务器上所看到的更老。","like_count":7,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495797,"discussion_content":"加一颗星:)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590534807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123163,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","nickname":"悟空聊架构","note":"","ucode":"C2F482A0CF8AF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557769,"discussion_content":"这里有点问题吧？返回客户端，这个时候其实 所有备份节点都是旧的数据，只有主节点发送 commit 消息后，备份节点才会进行 commit，将数据存到 znode 数据结构中。不是说过半后，那些返回 ack 的备份节点就已经 commit 了，而是需要等到主节点向所有备份节点发送 commit 后才会将事务日志中的数据存到内存里面，这样客户端就可以读到最新数据了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647958816,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1076487,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIKoEicqUZTJly55qoUXRmK4wia7YbnibsMncJaO6tKgKAQNJRfpMsibvfeiaukIibsCsuaic8QjQ3gOoTGA/132","nickname":"张可夫斯基","note":"","ucode":"3B8DF6D98583F2","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554418,"discussion_content":"只从主节点读可以读到最新数据吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646370677,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211429,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7c/25/7d9a2538.jpg","nickname":"蚂蚁","note":"","ucode":"B3FEFB399536DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309310,"discussion_content":"请教一下，单一视图是什么意思啊？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601256320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1019339,"avatar":"","nickname":"zyz","note":"","ucode":"0092F8C0FFA375","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1211429,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7c/25/7d9a2538.jpg","nickname":"蚂蚁","note":"","ucode":"B3FEFB399536DF","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309725,"discussion_content":"当集群节点数据没有完全同步，有的是新的，有的是旧的。能读到最新的肯定没有问题，而旧节点服务会拒绝客户端的连接，通过比较zxid的值来判断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601426992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309310,"ip_address":""},"score":309725,"extra":""}]}]},{"had_liked":false,"id":219196,"user_name":"zyz","can_delete":false,"product_type":"c1","uid":1019339,"ip_address":"","ucode":"0092F8C0FFA375","user_header":"","comment_is_top":false,"comment_ctime":1589964940,"is_pvip":false,"replies":[{"id":"81007","content":"加一颗星:)，感谢反馈，采用dynamic configuration进行成员变更，不需要重启的，已修正。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1590001682,"ip_address":"","comment_id":219196,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18769834124","product_id":100046101,"comment_content":"老师！Zookeeper版本3.5.0开始支持dynamic configuration，成员变更的时候，不需要重启了吧","like_count":4,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495711,"discussion_content":"加一颗星:)，感谢反馈，采用dynamic configuration进行成员变更，不需要重启的，已修正。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590001682,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":270271,"user_name":"王伟建","can_delete":false,"product_type":"c1","uid":1019576,"ip_address":"","ucode":"320CC5B6CE063F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/b8/31671fba.jpg","comment_is_top":false,"comment_ctime":1609042881,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"14493944769","product_id":100046101,"comment_content":"老师有几个问题不太理解：<br>1.zk的写请求是领导者节点的两阶段提交，说写请求是强一致性，是说这个两阶段过程未完成之前不允许其他操作，所以说他是强一致性吗？<br>2.zk的读只能提供顺序一致性，也就是说他可能读到旧的版本的数据，那为什么还要把zk归为CP类型的系统呢？CAP里的C 不应该是强一致性吗，说到底感觉还是对这个一致性没理解透，就之前的理解来说，我认为C是指每次读取的数据都是最近一次写入的数据，而不是过期的数据。希望老师能讲解一下这块儿。<br>3.利用zk来实现分布式锁，多个服务同时去拿锁时，如果zk提供的读不是强一致性，那么会不会读到旧的锁信息？这块儿是怎么保证每个服务拿到的都是最新的数据，实现上来说是靠sync读吗？","like_count":3,"discussions":[{"author":{"id":1046714,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","nickname":"约书亚","note":"","ucode":"81EA27ADD9EC1A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349808,"discussion_content":"1. 强一致性是指线性一致性，线性一致性的特性之一是对于观察者来说，所有的读和写都看起来像是在一个单调递增的时间上串行推进，所以确实满足你说的要求。但这里讨论的主要是另一个特性：所有的读总能返回最近的写操作的值，就是你在第2问里提到的。\n2. CAP本来现在也不常作为判断依据了，更多是培训机构和公众号还提一提，可以搜搜Martin Kleppmann的文章。另外硬说zookeeper和raft在读的一致性上不一样其实有点尬。\n3. 是有这种情况，但不会出现两个session同时获取锁的情况就算问题不大。而且只要读都在同一个follower就是顺序一致性。这时如果用sync确实会更好一些。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1613560998,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1204168,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5f/c8/13aa8aa9.jpg","nickname":"night","note":"","ucode":"03B3C955092C03","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":349103,"discussion_content":"1. 强一致是指整个 zk 服务集群的 leader 和多数节点，对数据的写表现出一致的。而非串行执行。\n2. zk 提供的是最终一致，非强一致。\n3. 用 zk 做分布式锁的实现，通常是 create node，而非 get node。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1612885258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1513825,"avatar":"https://static001.geekbang.org/account/avatar/00/17/19/61/119cbde2.jpg","nickname":"Dolly","note":"","ucode":"CC74978F393055","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343024,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610928890,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":245842,"user_name":"路人","can_delete":false,"product_type":"c1","uid":1084291,"ip_address":"","ucode":"55FF703DE772D7","user_header":"https://static001.geekbang.org/account/avatar/00/10/8b/83/d2afc837.jpg","comment_is_top":false,"comment_ctime":1599092601,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10189027193","product_id":100046101,"comment_content":"写我看用的是2pc，2pc中有些如果只有部分commit成功，zookeeper会怎么处理呢？是有什么补偿机制么？","like_count":2,"discussions":[{"author":{"id":1123163,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","nickname":"悟空聊架构","note":"","ucode":"C2F482A0CF8AF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557772,"discussion_content":"好问题，如果部分节点 commit 成功，其他节点没有成功，是进行 retry 呢，还是直接忽略呢？如果 retry 需要 retry 多少次呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647958889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":339178,"user_name":"悟空聊架构","can_delete":false,"product_type":"c1","uid":1123163,"ip_address":"","ucode":"C2F482A0CF8AF1","user_header":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","comment_is_top":false,"comment_ctime":1647958647,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647958647","product_id":100046101,"comment_content":"课后题：我提到 ZooKeeper 提供的是最终一致性，读操作可以在任何节点上执行。那么如果读操作访问的是备份节点，为什么无法保证每次都能读到最新的数据呢？<br><br>回答：因为主节点发送 commit 消息给所有备份节点时，备份节点执行 commit 的时机不一定都是同步完成的，只有当 commit 之后，客户端读取的数据才是最新的，比如备份节点 B 先commit，客户端 1 连接的是 备份节点 B，那么客户端 1 肯定读到的是最新的，但是如果客户端连接的是备份节点 C，但是节点 C     还没有收到 commit 消息或者收到了，还没来得及 commit，客户端就发起请求了，这个时候读到的就是旧数据。但是过了短暂时间后，所有备份节点都 commit 了，这个时候任何客户端都可以读到最新的一致性数据了，这个就是最终一致性。<br>补充：这里 commit 操作就是将数据 放到 znode 内存数据结构上，这样客户端就可以读到最新的数据了。","like_count":0},{"had_liked":false,"id":330570,"user_name":"阿kai(aeo","can_delete":false,"product_type":"c1","uid":1147682,"ip_address":"","ucode":"6B1D650D9BFA4C","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/22/c3dae274.jpg","comment_is_top":false,"comment_ctime":1642048139,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1642048139","product_id":100046101,"comment_content":"为什么觉得代码顺序是反的呢？比如下面这段FinalRequestProcessor怎么是首先创建的呢?<br><br>RequestProcessor finalProcessor = new FinalRequestProcessor(this);            &#47;&#47; 创建finalProcessor，最终提交提案和响应查询<br>  &#47;&#47; 创建toBeAppliedProcessor，存储可提交的提案，并在提交提案后，从toBeApplied队列移除已提交的<br>  RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());<br>  &#47;&#47; 创建commitProcessor，处理提案提交或读请求      <br>  commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());<br>  commitProcessor.start();<br>  &#47;&#47; 创建proposalProcessor，按照顺序广播提案给跟随者<br>  ProposalRequestProcessor proposalProcessor = new ProposalRequestProcessor(this, commitProcessor);<br>  proposalProcessor.initialize();<br>  &#47;&#47; 创建prepRequestProcessor，根据请求创建提案      <br>  prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);<br>  prepRequestProcessor.start();<br>  &#47;&#47; 创建firstProcessor，接收发给领导者的请求<br>  firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);<br>","like_count":0},{"had_liked":false,"id":282681,"user_name":"姑射仙人","can_delete":false,"product_type":"c1","uid":1008517,"ip_address":"","ucode":"3EFC1F3E592165","user_header":"https://static001.geekbang.org/account/avatar/00/0f/63/85/1dc41622.jpg","comment_is_top":false,"comment_ctime":1615363562,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1615363562","product_id":100046101,"comment_content":"老师，那么Zookeeper是CP呢，还是AP呢？读是最终一致，那么我理解是AP。但之前读的一篇文章，说Zookeeper不适合作为注册中心，说Zookeeper是CP，AP更适合作为注册中心，因为是读多写少，不要求马上能看到新的实例更新。 至于同步机制，Zookeeper也是支持增量更新，这样看来完全没有问题。麻烦老师指点下。","like_count":0,"discussions":[{"author":{"id":2580056,"avatar":"","nickname":"Geek_e0e75f","note":"","ucode":"EAD2C6178DAB45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":393722,"discussion_content":"你别误导人家了，zk是最终一致性好吧，人家官网都写了，zk不会保证强一致性，你如果非要强一致性的话，那么就需要在读数据之前叫你的节点同步一下数据再读，这个是在官网中写明了的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1631580339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123163,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","nickname":"悟空聊架构","note":"","ucode":"C2F482A0CF8AF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557778,"discussion_content":"Zookeeper 是顺序一致性，不是说的 CP 和 AP，如果要保证强一致性，需要手动执行 sync 方法。可以作为注册中心的，主节点只有一个，负责写和读，基于内存的数据结构，可以满足每秒上万 QPS。多个备份节点负责读，可以满足几万的 QPS 读，还可以通过 Observer 节点线性扩展 读 QPS。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647959118,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1083395,"avatar":"https://static001.geekbang.org/account/avatar/00/10/88/03/805c8e0e.jpg","nickname":"追忆似水年华","note":"","ucode":"FB6C3EDC6988B6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":359828,"discussion_content":"zookeeper是CP模型，当出现网络分区，是不能提供服务的，不可读写","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616297712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":278942,"user_name":"渔夫","can_delete":false,"product_type":"c1","uid":1246157,"ip_address":"","ucode":"43C267E01220F7","user_header":"https://static001.geekbang.org/account/avatar/00/13/03/cd/264f6a1c.jpg","comment_is_top":false,"comment_ctime":1613475694,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1613475694","product_id":100046101,"comment_content":"韩老师，想问下分布式集群模式下，FollowerZooKeeperServer.setupRequestProcessors方法是如何被调用的呢，找了好久找不到。不像standolone模式那么好找","like_count":0},{"had_liked":false,"id":271613,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1609732841,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1609732841","product_id":100046101,"comment_content":"老师，请问zk的最终一致性是以提升读的效率为目标的嘛，写的速率和强一致性的算法差不多吧？","like_count":0,"discussions":[{"author":{"id":1123163,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","nickname":"悟空聊架构","note":"","ucode":"C2F482A0CF8AF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557782,"discussion_content":"写的速率不一样，强一致性速度更慢，需要等待所有 follower 的 commit 都成功才能进行下一次的 commit。但是 Zookeeper 只需要发送 commit 消息就可以了，不用保证所有 follower 都成功才能进行下一次 commit。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647959281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243003,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1597915769,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597915769","product_id":100046101,"comment_content":"虽然领导者向着大部分的跟随者节点发送了commit请求,但是并不会等待跟随者响应完成写入再返回客户端,而是直接发送了一个完成消息给接收到客户端请求的节点,这就导致,客户端去读取的时候,可能读取到的节点是没有数据生效的节点,所以没法保证每次都读到最新的数据","like_count":0},{"had_liked":false,"id":241882,"user_name":"Kvicii.Y","can_delete":false,"product_type":"c1","uid":1442588,"ip_address":"","ucode":"446BFA633569EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/1c/c9fe6738.jpg","comment_is_top":false,"comment_ctime":1597486117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1597486117","product_id":100046101,"comment_content":"Raft的强一致性是体现在读写都由领导者完成；ZAB的最终一致性是读写可以由领导者也可由Follower或Observer转发完成，如果ZAB想要实现强一致性，似乎也是可以通过sync API完成的吧","like_count":0},{"had_liked":false,"id":232796,"user_name":"爱德华","can_delete":false,"product_type":"c1","uid":1853638,"ip_address":"","ucode":"800E6A9490D90F","user_header":"https://static001.geekbang.org/account/avatar/00/1c/48/c6/3c8d9a0c.jpg","comment_is_top":false,"comment_ctime":1594120501,"is_pvip":false,"replies":[{"id":"88053","content":"加一颗星:)，第二个说法，在文中我没有搜到，如果方便，帮忙补充下哈。如果第二个说法去掉“第一阶段”和“就”，那么这两个说法，在我看来，都是正确的，一个侧重代码实现，一个侧重算法原理，就像同样是一棵树，生物学家和文学家的描述是不同的。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1596138453,"ip_address":"","comment_id":232796,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1594120501","product_id":100046101,"comment_content":"老师，在说处理写请求的时候好像有点问题。本文中所说的是leader要在第二阶段（commit）后才会返回给客户端成功。但是在前几讲中，好像是说zab在第一阶段，收到大多数响应后就返回给客户端成功。那么这两个说法哪个正确呢？","like_count":0,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500770,"discussion_content":"加一颗星:)，第二个说法，在文中我没有搜到，如果方便，帮忙补充下哈。如果第二个说法去掉“第一阶段”和“就”，那么这两个说法，在我看来，都是正确的，一个侧重代码实现，一个侧重算法原理，就像同样是一棵树，生物学家和文学家的描述是不同的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596138453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1853638,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/48/c6/3c8d9a0c.jpg","nickname":"爱德华","note":"","ucode":"800E6A9490D90F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":289774,"discussion_content":"我靠，我记错了，第一阶段获得多数票留给客户端返回成功的是raft😢😢","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594210091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231285,"user_name":"Kvicii.Y","can_delete":false,"product_type":"c1","uid":1442588,"ip_address":"","ucode":"446BFA633569EA","user_header":"https://static001.geekbang.org/account/avatar/00/16/03/1c/c9fe6738.jpg","comment_is_top":false,"comment_ctime":1593630394,"is_pvip":false,"replies":[{"id":"87649","content":"加一颗星:)，是的","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1595756328,"ip_address":"","comment_id":231285,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593630394","product_id":100046101,"comment_content":"领导者CommitProcessor.tryToCommit() 提交提案的方法似乎在3.6.0在Leader类中","like_count":0,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500238,"discussion_content":"加一颗星:)，是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595756328,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":228614,"user_name":"Dovelol","can_delete":false,"product_type":"c1","uid":1253384,"ip_address":"","ucode":"9B5DDF7720F307","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/08/bc06bc69.jpg","comment_is_top":false,"comment_ctime":1592752504,"is_pvip":false,"replies":[{"id":"88045","content":"加一颗星:)，性能是相对，相比原子提交协议（比如2PC），共识算法的性能要高些。阻塞属于异常情况，在实际场景中，如果代码本身没有缺陷，在绝大多数时候，系统都是正常运行的，不存在阻塞的，也不会影响到写的性能。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1596134520,"ip_address":"","comment_id":228614,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1592752504","product_id":100046101,"comment_content":"老师好，想问下zab协议处理写请求要这么多步骤，那还能保证性能吗？如果其中某一小步骤延迟或阻塞都会影响写的性能把。","like_count":0,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499104,"discussion_content":"加一颗星:)，性能是相对，相比原子提交协议（比如2PC），共识算法的性能要高些。阻塞属于异常情况，在实际场景中，如果代码本身没有缺陷，在绝大多数时候，系统都是正常运行的，不存在阻塞的，也不会影响到写的性能。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596134520,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221353,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1082132,"ip_address":"","ucode":"483350A630625E","user_header":"https://static001.geekbang.org/account/avatar/00/10/83/14/099742ae.jpg","comment_is_top":false,"comment_ctime":1590480550,"is_pvip":false,"replies":[{"id":"88037","content":"加一颗星:)，绝大多数时候，业务对数据的新旧是没那么敏感的。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1596129254,"ip_address":"","comment_id":221353,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590480550","product_id":100046101,"comment_content":"你好，既然 zk 只能保证最终一致性，那么在分布式系统中，如 kafka、hbase 等，用 zk 做元数据管理岂不是有问题","like_count":0,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496435,"discussion_content":"加一颗星:)，绝大多数时候，业务对数据的新旧是没那么敏感的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596129254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1123163,"avatar":"https://static001.geekbang.org/account/avatar/00/11/23/5b/983408b9.jpg","nickname":"悟空聊架构","note":"","ucode":"C2F482A0CF8AF1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557783,"discussion_content":"这是一个设计取舍的问题，要求强一致性，就需要牺牲性能，那这些元数据管理是否真的需要强一致性？如果可以容忍短暂时间的不一致，是否可以接受？可以从这些方面来考虑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647959447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219242,"user_name":"DY-杨","can_delete":false,"product_type":"c1","uid":1105546,"ip_address":"","ucode":"C84C0250F1A053","user_header":"https://static001.geekbang.org/account/avatar/00/10/de/8a/8b4d7dbd.jpg","comment_is_top":false,"comment_ctime":1589974089,"is_pvip":false,"replies":[{"id":"81004","content":"加一颗星:)，算法和工程实现之间存在差异，对于Paxos而言，差异就更大了，缺少工程实现的必须细节，这也是为什么大家现在主要选择了raft的原因。故障恢复，是ZAB定义的，Raft没有定义这个阶段。问题1：若使用paxos，需要自己权衡，可以使用它的提到的方法，新领导者通过prepare阶段来发现之前选定的值，也可以自己设计，需要整体考虑。问题2：联合共识，是Raft中处理成员变更的一种方法。","user_name":"作者回复","user_name_real":"hanj4096","uid":"1642497","ctime":1589989732,"ip_address":"","comment_id":219242,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1589974089","product_id":100046101,"comment_content":"老师，咨询下。paxos算法从您讲解下来好像仅是对某个提案达成共识。没有看到故障恢复或日志恢复的过程啊。反倒zab和raft有。那您知道用这种共识算法的软件是自研的日志恢复吗?另外联合共识算法是什么呢。","like_count":0,"discussions":[{"author":{"id":1642497,"avatar":"https://static001.geekbang.org/account/avatar/00/19/10/01/750740a8.jpg","nickname":"hanj4096","note":"","ucode":"481047E40315AA","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495732,"discussion_content":"加一颗星:)，算法和工程实现之间存在差异，对于Paxos而言，差异就更大了，缺少工程实现的必须细节，这也是为什么大家现在主要选择了raft的原因。故障恢复，是ZAB定义的，Raft没有定义这个阶段。问题1：若使用paxos，需要自己权衡，可以使用它的提到的方法，新领导者通过prepare阶段来发现之前选定的值，也可以自己设计，需要整体考虑。问题2：联合共识，是Raft中处理成员变更的一种方法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589989732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}