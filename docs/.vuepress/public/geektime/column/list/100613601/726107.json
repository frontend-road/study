{"id":726107,"title":"34｜工具：学会使用从内存分析到性能测试等各种常用工具","content":"<p>你好, 我是康杨。</p><p>作为Java开发者，熟练掌握各种常用工具是提高开发效率和代码质量的关键。在Java生态系统中，有很多优秀的工具可以帮助我们进行内存分析、性能测试、代码审计、测试等等。这些工具的定位和价值各不相同，但是它们都可以让我们更加高效地开发和维护Java应用程序。</p><p>这节课我们主要聊内存分析工具和性能测试工具，我选择了目前使用非常广泛的两个工具：MAT（Memory Analyzer Tool）和JMeter。下面我们聊聊MAT和JMeter的使用方法和技巧，帮助你更好地掌握这些工具，提高开发效率和代码质量。</p><h2>内存分析工具：MAT</h2><p>内存泄漏和不良的内存管理是影响Java应用性能的常见因素。如何捕捉并修复这个隐形的Bug呢？</p><p>这就要用到MAT了，一个功能强大的Java内存分析利器。它可以帮助我们深入挖掘Java应用程序的内存泄漏、频繁地垃圾回收、内存占用过高等问题。通过分析Java进程的内存快照，我们可以更加高效地定位和解决Java应用程序的内存问题，提高应用程序的稳定性和性能。</p><h4>安装MAT</h4><p>接下来我们安装MAT，快速体验起来。首先确保你有Java运行环境和IntelliJ IDEA。然后前往<a href=\"https://www.eclipse.org/mat/\">官网</a>下载MAT，再根据操作系统的指导完成安装。</p><!-- [[[read_end]]] --><h4>使用MAT</h4><ol>\n<li>导入堆转储文件</li>\n</ol><p>在开始使用MAT之前，需要先导入Java应用程序的堆转储文件。堆转储文件通常可以通过JConsole、VisualVM或其他内存分析工具生成。导入堆转储文件的方法：选择 File &gt; Import/Export，然后选择 Open heap dump。浏览并选择堆转储文件，点击 Open。</p><ol start=\"2\">\n<li>查看内存分析报告</li>\n</ol><p>导入堆转储文件后，MAT将自动生成内存分析报告。在报告窗口中，你可以查看以下内容：</p><ul>\n<li>内存泄漏：MAT会识别出潜在的内存泄漏对象。</li>\n<li>垃圾回收：MAT会显示垃圾回收事件及其相关信息。</li>\n<li>类加载：MAT会显示类加载事件及其相关信息。</li>\n</ul><ol start=\"3\">\n<li>通过MAT发现问题</li>\n</ol><p>在查看内存分析报告时，同样你也需要关注这几点。</p><ul>\n<li>内存泄漏：检查泄漏对象及其原因，比如异常、循环引用等。</li>\n<li>垃圾回收：观察垃圾回收频率、时间和回收的垃圾对象。</li>\n<li>类加载：检查类加载的时间、加载的类及其资源。</li>\n</ul><h4>MAT 应用案例</h4><p>我将通过两个实际的案例，介绍如何使用MAT发现问题并解决问题。这些案例涵盖了不同的场景，展示MAT在各种情况下的用途。</p><p><strong>案例1：使用MAT检测内存泄漏</strong></p><p>在这个案例中，我们将分析一个简单的Java应用程序，这个程序创建了一个线程池来执行任务，但随着时间的推移，内存泄漏问题逐渐显现。</p><pre><code class=\"language-java\">public class MemoryLeakExample {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n        for (int i = 0; i &lt; 100; i++) {\n            final int taskId = i;\n            executorService.submit(() -&gt; {\n                // 执行任务\n            });\n        }\n        executorService.shutdown();\n    }\n}\n</code></pre><p>通过MAT分析上述代码产生的堆转储文件，我们可以发现它存在<strong>内存泄漏</strong>的问题。在代码中，我们创建了一个固定大小的线程池，并提交了100个任务。由于线程池的大小为10，所以最多只能执行10个任务。剩下的90个任务将等待执行，而这些任务的上下文（如局部变量、对象引用等）将一直保留在内存中，导致内存泄漏。</p><p>针对上述问题，我们可以采取下面2个措施来解决。</p><ul>\n<li>调整线程池大小：根据实际需求，合理调整线程池的大小。例如，可以将线程池的大小调整为100，以确保所有任务都能被及时执行。</li>\n<li>使用有界队列：为了防止线程池里的任务过多，可以使用有界队列来限制线程池中的任务数量。当线程池中的任务数量达到队列的最大容量时，新提交的任务将等待执行。这样可以避免因线程池大小不足而导致的内存泄漏问题。</li>\n</ul><p>修改后的代码示例：</p><pre><code class=\"language-java\">public class MemoryLeakExample {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(100);\n        for (int i = 0; i &lt; 100; i++) {\n            final int taskId = i;\n            executorService.submit(() -&gt; {\n                // 执行任务\n            });\n        }\n        executorService.shutdown();\n    }\n}\n</code></pre><p><strong>案例2：使用MAT检测大对象持久化</strong></p><p>这个案例是分析一个Java应用程序，这个程序使用JDBC连接到数据库并执行查询。然而，在某些情况下，查询结果可能包含大量数据，导致内存泄漏。</p><pre><code class=\"language-java\">public class DatabaseLeakExample {\n    public static void main(String[] args) {\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"username\", \"password\");\n             Statement statement = connection.createStatement()) {\n            ResultSet resultSet = statement.executeQuery(\"SELECT * FROM large_table\");\n            while (resultSet.next()) {\n                // 处理查询结果\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>通过MAT分析上述代码产生的堆转储文件，可以发现<strong>大对象持久化</strong>的问题。在代码中，执行了一个查询，这个查询返回大量数据。由于Java中的ResultSet对象是可迭代的，所以会把它所有的数据加载到内存中。如果查询结果包含大量数据，就可能导致内存泄漏。</p><p>针对上述问题，可以采取下面2个措施来解决。</p><ul>\n<li>分页查询：为了减少内存泄漏的风险，可以使用分页查询来获取查询结果。这样，可以在每次迭代时只加载部分数据，而不是将所有数据加载到内存中。</li>\n<li>使用流式处理：如果可能的话，可以使用Stream API来处理查询结果，而不是使用传统的迭代方法。这样可以避免将整个结果集加载到内存中。</li>\n</ul><p>我们使用分页查询修改一下代码，然后看一下。</p><pre><code class=\"language-java\">public class DatabaseLeakExample {\n    public static void main(String[] args) {\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"username\", \"password\");\n             Statement statement = connection.createStatement()) {\n            ResultSet resultSet = statement.executeQuery(\"SELECT * FROM large_table LIMIT 10\");\n            int currentPage = 1;\n            while (resultSet.next()) {\n                // 处理查询结果\n                currentPage++;\n                if (currentPage % 10 == 0) {\n                    resultSet.close();\n                    statement.close();\n                    connection.close();\n                    resultSet = statement.executeQuery(\"SELECT * FROM large_table LIMIT 10 OFFSET \" + currentPage * 10);\n                }\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>我们再使用流式处理修改一下，你看看修改后的代码示例。</p><pre><code class=\"language-java\">import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.Statement;\nimport java.util.stream.Stream;\n\npublic class DatabaseLeakExample {\n    public static void main(String[] args) {\n        try (Connection connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\", \"username\", \"password\");\n             Statement statement = connection.createStatement()) {\n            ResultSet resultSet = statement.executeQuery(\"SELECT * FROM large_table\");\n            Stream&lt;Object[]&gt; stream = Stream.of(resultSet);\n            stream.forEach(result -&gt; {\n                // 处理查询结果\n            });\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre><p>MAT是一个强大的工具，可以帮助我们在Java应用程序中识别内存泄漏、大对象持久化等问题。通过熟练掌握MAT的使用，可以更好地优化代码，提高程序性能。</p><h3>性能测试工具：<strong>JMeter</strong></h3><p>性能测试，已经不仅仅是优化的后话了，特别是在今天，它已经成为了软件开发中不可或缺的一部分。Apache JMeter也不只是一个工具，而是测试性能的利器。它可以帮助我们测试Java应用程序的响应时间、吞吐量和压力测试等性能指标。</p><p>JMeter支持多种协议和协议的测试，并提供了丰富的测试报告和可视化工具，来帮助我们分析应用程序的性能瓶颈。使用JMeter可以让我们更加高效地测试Java应用程序的性能，并提前发现性能问题，保证用户体验。</p><h4><strong>安装JMeter</strong></h4><p>你先去Apache JMeter的<a href=\"http://jmeter.apache.org/\">官网</a>下载最新版本的JMeter。然后解压下载的文件，无需复杂安装，它直接是可以执行的程序。</p><h4>JMeter初体验</h4><pre><code class=\"language-java\">@RestController\npublic class LoginController {\n&nbsp;\n@GetMapping(\"/login\")\npublic String login(@RequestParam String username, @RequestParam String password) {\n // 模拟登录耗时操作\n try {\n  Thread.sleep(1000);\n } catch (InterruptedException e) {\n  e.printStackTrace();\n }\n  return \"Welcome, \" + username + \"!\";\n }\n}\n</code></pre><p>这段代码定义了一个登录的接口，每次请求都会休眠1秒钟，模拟实际操作的耗时。</p><h4>创建JMeter测试计划</h4><p>现在我们的小程序准备好了，那就开始设置JMeter吧！</p><ol>\n<li>\n<p>添加线程组：在测试计划内右键 &gt; 新建 &gt; 线程组Threads(Group)，这里的线程组相当于模拟的用户数量。</p>\n</li>\n<li>\n<p>配置线程属性：</p>\n</li>\n</ol><ul>\n<li>线程数（Number of Threads）：比如设置为100，代表同时模拟100个用户。</li>\n<li>循环次数（Loop Count）：比如设置为10，每个用户会进行10次登录尝试。</li>\n</ul><ol start=\"3\">\n<li>\n<p>添加HTTP请求：在线程组内右键 &gt; 新建 &gt; 取样器 &gt; HTTP请求，在这里设置你的请求信息，比如请求路径、方法和参数。</p>\n</li>\n<li>\n<p>添加报告监听器：在线程组内右键 &gt; 新建 &gt; 监听器 &gt; 聚合报告，这样设置之后测试结果就会实时显示在这里了。</p>\n</li>\n</ol><p>设置好之后就可以跑测试了，点击JMeter工具栏上的绿色三角开始测试。</p><h4>通过测试结果发现问题</h4><ol>\n<li>查看响应时间：看看平均响应时间是多少，是否在可接受范围内。</li>\n<li>查看成功率：所有请求中有多少是成功的，失败了是什么原因</li>\n<li>错误分析：通过查看请求的具体错误信息，来分析可能的问题所在。</li>\n</ol><p>设想一下，如果平均响应时间特别长或者失败率特别高，那可能就是我们的性能瓶颈了。有可能是数据库连接池设置得不合理，也有可能是某些代码的运算效率太低。</p><h4>如何解决问题？</h4><p>根据JMeter的测试结果去审查你的代码。如果是数据库的问题，就调整数据库连接池配置，比如增加最大连接数。如果的确是代码问题，就需要进行性能优化，比如缓存计算结果，或者是异步处理。</p><h2>重点回顾</h2><p>Java生态系统中有很多优秀的工具，如内存分析工具MAT和性能测试工具JMeter，它们可以帮助我们深入挖掘Java应用程序的内存泄漏、频繁的垃圾回收、内存占用过高等问题，以及测试应用程序的响应时间、吞吐量和压力测试等性能指标。</p><p>通过熟练掌握这些工具的使用，我们可以更加高效地开发和维护Java应用程序，提高应用程序的性能。</p><h2>思考题</h2><p>好了，学完这节课之后，希望你也可以梳理下你日常使用的工具，尝试利用这些工具去发现系统中潜在的问题点，并进行优化。欢迎你把你常用的工具以及发现的问题分享出来，同时也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见！</p>","neighbors":{"left":{"article_title":"33｜环境：基于GraalVM的JVM云原生环境搭建","id":725307},"right":{"article_title":"35｜实现：基于JDK 17、Spring Boot 3、Spring 6打造云原生Java应用","id":726863}},"comments":[{"had_liked":false,"id":384220,"user_name":"on","can_delete":false,"product_type":"c1","uid":2869085,"ip_address":"广东","ucode":"D0B59D9F0FC209","user_header":"https://static001.geekbang.org/account/avatar/00/2b/c7/5d/40bdba38.jpg","comment_is_top":false,"comment_ctime":1700548981,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"使用流式处理：如果可能的话，可以使用 Stream API 来处理查询结果，而不是使用传统的迭代方法。这样可以避免将整个结果集加载到内存中。\n\njava stream api还有这个作用呢？不在内存中的话，那查出来的db数据在哪里？","like_count":0},{"had_liked":false,"id":384219,"user_name":"on","can_delete":false,"product_type":"c1","uid":2869085,"ip_address":"广东","ucode":"D0B59D9F0FC209","user_header":"https://static001.geekbang.org/account/avatar/00/2b/c7/5d/40bdba38.jpg","comment_is_top":false,"comment_ctime":1700548920,"is_pvip":true,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"使用流式处理：如果可能的话，可以使用 Stream API 来处理查询结果，而不是使用传统的迭代方法。这样可以避免将整个结果集加载到内存中。","like_count":0},{"had_liked":false,"id":383959,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"北京","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1700020669,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":2,"product_id":100613601,"comment_content":"请教老师几个问题啊：\nQ1：MAT和JMeter可以用来测试安卓吗？\nQ2：MAT的案例1，main函数很快执行完，然后退出，线程还有用吗？\nQ3：MAT的数据库案例，try后面应该有{吧，现在直接跟(，感觉是个笔误啊。","like_count":0,"discussions":[{"author":{"id":1335457,"avatar":"https://static001.geekbang.org/account/avatar/00/14/60/a1/45ffdca3.jpg","nickname":"静心","note":"","ucode":"EB264FA6519FDA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":636830,"discussion_content":"我看到的你提的问题都没有回答呀！你自己查资料了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1707104969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山西","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}