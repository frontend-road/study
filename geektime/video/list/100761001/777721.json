{"id":777721,"title":"17｜作为表达式类型的联合与交叉","content":"","comments":[{"had_liked":false,"id":396248,"user_name":"郑俊毅","can_delete":false,"product_type":"c3","uid":3022939,"ip_address":"重庆","ucode":"12C9ADC4A29ECD","user_header":"","comment_is_top":false,"comment_ctime":1733753265,"is_pvip":false,"replies":[{"id":143856,"content":"这个问题其实比较扯~~ 而且TypeScript在几乎所有与string | number类型相关的处理中，都需要小心。\n\n因为对象的索引签名中有个潜规则，即“数字索引是字符串索引的子集”，因此几乎在所有有关这两个类型的计算都需要“特殊对待”。因为这个计算结果“有可能需要”在后续运算作为签名使用。\n\n所以我们直观上觉得string &amp; number的结果是never，——因为这两个类型、以及boolean都是primitive type——但它们却通常是用“string &amp; number”这个未求值的表达式参与到后续计算中的。并且带来了非常非常多特例。\n\n只能在使用中多留意了。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1733897586,"ip_address":"江苏","comment_id":396248,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"type B = {a:string} &amp; {a:boolean}\n&#47;&#47; type B = never\ntype B1 = B[&quot;a&quot;]\n&#47;&#47; type B1 = never\ntype B2 = keyof B\n&#47;&#47; type B2 = string | number | symbol\n\n\ntype C = {a:string} &amp; {a:number}\n&#47;&#47; type C = {a:never}\ntype C1 =  C[&quot;a&quot;]\n&#47;&#47; type C1 = never\ntype C2 = keyof C\n&#47;&#47; type C2 = &quot;a&quot;\n\n\nnumber 和 boolean为什么会得到不太一样的结果呢？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654968,"discussion_content":"这个问题其实比较扯~~ 而且TypeScript在几乎所有与string | number类型相关的处理中，都需要小心。\n\n因为对象的索引签名中有个潜规则，即“数字索引是字符串索引的子集”，因此几乎在所有有关这两个类型的计算都需要“特殊对待”。因为这个计算结果“有可能需要”在后续运算作为签名使用。\n\n所以我们直观上觉得string &amp; number的结果是never，——因为这两个类型、以及boolean都是primitive type——但它们却通常是用“string &amp; number”这个未求值的表达式参与到后续计算中的。并且带来了非常非常多特例。\n\n只能在使用中多留意了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1733897586,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":393164,"user_name":"Geek_aeb936","can_delete":false,"product_type":"c3","uid":3887128,"ip_address":"日本","ucode":"863338D4895F25","user_header":"","comment_is_top":false,"comment_ctime":1723026146,"is_pvip":false,"replies":[{"id":142804,"content":"“不见了”的原因，其实是收敛到了never的结果。这个问题跟留言中 Zps 同学的问题是同一个问题。所以……答案也是一样的……这个无解。\n\n回头我整理一下关于这个问题的思考，单另发一篇文章吧。","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1723098686,"ip_address":"江苏","comment_id":393164,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"老师请问下 接口和接口的交叉 以及 接口与对象的交叉结果是不一样？\n\ninterface T1 {\n    a: string;\n    c: number;\n}\n\ninterface T2 {\n    a: number;\n    b: boolean;\n}\n\n&#47;*\ntype T12 = {\n    a: never;\n    c: number;\n    b: boolean;\n}\n*&#47;\ntype T12 = Omit&lt;T1 &amp; T2, never&gt;;\n\n&#47;&#47; type T13 = never\ntype T13 = T1 &amp; { a: boolean };\n\nT13这里 交叉   接口T1 的    c: number; 不见了","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649286,"discussion_content":"“不见了”的原因，其实是收敛到了never的结果。这个问题跟留言中 Zps 同学的问题是同一个问题。所以……答案也是一样的……这个无解。\n\n回头我整理一下关于这个问题的思考，单另发一篇文章吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1723098686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":3887128,"avatar":"","nickname":"Geek_aeb936","note":"","ucode":"863338D4895F25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":649338,"discussion_content":"感谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1723180312,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":649286,"ip_address":"日本","group_id":0},"score":649338,"extra":""}]}]},{"had_liked":false,"id":393146,"user_name":"Zps","can_delete":false,"product_type":"c3","uid":1480675,"ip_address":"北京","ucode":"B97FC6D500E3B5","user_header":"https://static001.geekbang.org/account/avatar/00/16/97/e3/8b217315.jpg","comment_is_top":false,"comment_ctime":1722992296,"is_pvip":false,"replies":[{"id":142797,"content":"这是一个无解的题，它事实上与交叉运算“是否更积极地向never收敛”有关，某些情况下，积极的收敛（向never求值）会导致TTT的结果，另一些时候则不会。而且，这个过程没有太明确的原则。\n\n在我们的课程中，只是强调：交叉运算可以有求值结果，但求值计算不一定会发生。说的是计算的非必然性，但对交叉结果是否“更积极地”的处理为never，是绕开了的。这既没有官方资料，也没有规则……","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1723015266,"ip_address":"江苏","comment_id":393146,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"interface T2 {\n  a: string;\n  b: string;\n}\n\ntype TT = T2 &amp; { a: number };\ntype TTT = T2 &amp; { a: boolean };\n为什么TT不是nerver  TTT是never呢","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":649231,"discussion_content":"这是一个无解的题，它事实上与交叉运算“是否更积极地向never收敛”有关，某些情况下，积极的收敛（向never求值）会导致TTT的结果，另一些时候则不会。而且，这个过程没有太明确的原则。\n\n在我们的课程中，只是强调：交叉运算可以有求值结果，但求值计算不一定会发生。说的是计算的非必然性，但对交叉结果是否“更积极地”的处理为never，是绕开了的。这既没有官方资料，也没有规则……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1723015266,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391059,"user_name":"Jack Q","can_delete":false,"product_type":"c3","uid":1160078,"ip_address":"广东","ucode":"A7DBC311884FFA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b3/8e/1c564eb2.jpg","comment_is_top":false,"comment_ctime":1717175622,"is_pvip":false,"replies":[{"id":142243,"content":"惰性求值的确是很令人着迷的现象。不过没有办法，既没有资料，也没有稳定的手段来研究它。\n\n我不确定“具体哪些”keyof X会导致惰性，或者反之不会。就目前来说我也没有找到太明确的规则，更加重要的是，这些规则还可能随将来版本的更新而变化。所以多数情况下这种现象不值得依赖，甚至应该尽力规避。\n\n还有一个问题在于，很多时候，所谓“惰性”更可能是TypeScript“显示类型信息”的一种表面现象，也就是它是“字面上的”，而不是真的惰性求值。这就更加无从证起。关于这一点，还是之前所说过的：第25讲还会有一个review，……","user_name":"作者回复","user_name_real":"编辑","uid":1521669,"ctime":1717489318,"ip_address":"江苏","comment_id":391059,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100761001,"comment_content":"interface A {\n  a: string;\n}\n\ninterface B {\n  a: string;\n  b: boolean;\n}\n\ntype B1 = {\n  a: string;\n  b: boolean;\n}\n\ntype B2 = B;\n\ninterface C {\n  a: string;\n  c: number;\n}\n\n&#47;&#47; &amp; (交叉会不断的向never 方向收敛)\ntype AB = A &amp; B;\ntype KAB = keyof AB;\n\ntype ABS0 = AB &amp; string; &#47;&#47; 因为无法得到更具体的类型, 所以延迟求值 \ntype ABS0IsNever =  never extends ABS0 ? ABS0 extends never ? true : false : false;&#47;&#47; false (ABS0 不是never)\nconst abs0 = Object.assign(&quot;1&quot; as string, {\n  a: &#39;1&#39;,\n  b: true\n});\ntype TABS0 = typeof abs0;\ntype ABS0IsTABS0 =  ABS0 extends TABS0 ? TABS0 extends ABS0 ?  true : false : false;&#47;&#47; true\n\ntype ABS1 = AB | string; &#47;&#47; 求值发生了延迟\n\n&#47;&#47; ｜ (联合 会不断的向any 方向合并)\ntype D  = A;\ntype E = B;\n\ntype DE = D | E;&#47;&#47; 求值发生了延迟;当联合类型无法完成求值，惰性求值就无法得到具体结果，依然会是一个联合类型\n\ntype KDE = keyof DE; &#47;&#47; keyof DE 等同于keyof D &amp; keyof E;\ntype KDE1 = keyof D &amp; keyof E;\ntype DE1 = DE | { a: boolean };&#47;&#47; 求值发生了延迟\ntype DE2 = DE &amp; { a: boolean };&#47;&#47; 等同于 D &amp; { a: boolean } | E &amp; { a: boolean } -&gt; never | never -&gt; never\n\ntype DE3 = DE1[&#39;a&#39;]; &#47;&#47; 等同于 DE[&#39;a&#39;] | { a: number }[&#39;a&#39;] -&gt; D[&#39;a&#39;] | E[&#39;a&#39;] | { a: number }[&#39;a&#39;]\n\n\n&#47;&#47; 问题1：KAB 此处求值发生了延迟， KBC 却立即求值的原因是？ \n&#47;&#47; 根据现象，我自己的猜想是: \n&#47;&#47; KAB 发生交叉后 它的类型等同于 具名的单类型 interface B, KBC 交叉后 它的类型 没有对应的 具名单类型存在, 所以立即求值\ntype BC = B &amp; C;\ntype KBC = keyof BC;\n&#47;&#47; 猜测证明：\ntype AB0 = A &amp; {\n  a: string;\n  b: boolean;\n};\ntype AB1 = A &amp; B1;\ntype AB2 = A &amp; B2;\n\ntype KAB0 = keyof AB0;&#47;&#47; &quot;a&quot; | &quot;b&quot;; 立即求值; AB0 中 &amp; 的右侧类型是一个 匿名的对象类型 ，没有对应的具名单类型存在\ntype KAB1 = keyof AB1;&#47;&#47; keyof B1; 求值发生了延迟; AB1 中 &amp; 的右侧类型是一个 匿名的对象类型的类型别名,类型推导到了别名\ntype KAB2 = keyof AB2;&#47;&#47; keyof B; 求值发生了延迟; AB2 中 &amp; 的右侧类型是一个 接口类型的类型别名, 类型推导到了别名的来源","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646167,"discussion_content":"惰性求值的确是很令人着迷的现象。不过没有办法，既没有资料，也没有稳定的手段来研究它。\n\n我不确定“具体哪些”keyof X会导致惰性，或者反之不会。就目前来说我也没有找到太明确的规则，更加重要的是，这些规则还可能随将来版本的更新而变化。所以多数情况下这种现象不值得依赖，甚至应该尽力规避。\n\n还有一个问题在于，很多时候，所谓“惰性”更可能是TypeScript“显示类型信息”的一种表面现象，也就是它是“字面上的”，而不是真的惰性求值。这就更加无从证起。关于这一点，还是之前所说过的：第25讲还会有一个review，……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717489319,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]}]}