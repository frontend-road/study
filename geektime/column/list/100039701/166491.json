{"id":166491,"title":"04 | export default function() {}：你无法导出一个匿名函数表达式","content":"<p>你好，我是周爱民，欢迎回到我的专栏。</p><p>今天我要讲述的内容是从ECMAScript 6开始在JavaScript中出现的<strong>模块技术</strong>，这对许多JavaScript开发者来说都是比较陌生的。</p><p>一方面在于它出现得较晚，另一方面，则是因为在普遍使用的Node.js环境带有自己内置的模块加载技术。因此，ECMAScript 6模块需要通过特定的命令行参数才能开启，它的应用一直以来也就不够广泛。</p><p>导致这种现象的根本原因在于<strong>ECMAScript 6模块是静态装配的</strong>，而传统的Node.js模块却是动态加载的。因而两种模块的实现效果与处理逻辑都大相径庭，Node.js无法在短期内提供有效的手段帮助开发者将既有代码迁移到新的模块规范下。</p><p>总结起来，确实是这些更为现实的原因阻碍了ECMAScript 6模块技术的推广，而非是ECMAScript 6模块是否成熟，或者设计得好与不好。</p><p>不过即使如此，ECMAScript 6模块仍然在JavaScript的一些大型应用库、包，或者对新规范更友好的项目中得到了不错的运用和不俗的反响，尤其是在使用转译器（例如Babel）的项目中，开发者通常是首选ECMAScript 6模块语法的。</p><p>因此ECMAScript 6模块也有着非常好的应用环境与前景。</p><!-- [[[read_end]]] --><h2>导出的内容</h2><p>上一讲我提到过有且仅有六种声明语法，而本质上export也就只能导出这六种声明语法所声明的标识符，并且在导出时将它们统一称为“名字”。</p><p>在语言设计中，所谓“标识符”与“名字”是有语义差别的，export将之称为名字，就意味着这是一个标识符的子集。类似的其它子集也是存在的，例如“保留字是标识符名，但不能用作标识符（A reserved word is an IdentifierName that cannot be used as an Identifier）”。</p><p>在JavaScript语言的设计上，除了那些预设的标点符号（例如大括号、运算符之类），以及部分的保留字和关键字之外，事实上用户代码可以书写的只有三种东西。这包括：</p><ul>\n<li>标识符：（通常是）一个<strong>名字</strong>；</li>\n<li>字面量：表明由它的字面含义所决定的一个<strong>值</strong>；</li>\n<li>模板：一个可计算结果的字符串<strong>值</strong>。</li>\n</ul><p>所以，如果在这个层面上解构一份你所书写的JavaScript代码，那么你所能书写/声明的，就一定只有“名字和值”。</p><p>这个结论是非常非常关键的。为什么呢？因为export事实上就只能导出“名字和值”。然而一旦它能导出“名字和值”，也就意味着它能导出一个模块中的“全部内容”，因为如上所面所讲的：</p><p>“名字和值”正是你所书写的代码的全部。</p><h2>我的代码去哪儿了呢？</h2><p>你是不是一刹那之间觉得自己的代码都白写了。:)</p><p>确实是的，真的是白写了。不过，我在前面讲的都是纯粹的“语言设计”，在语言设计层面上来讲，代码就是文本，是没有应用逻辑的。而你所写的代码绝大多数都是应用逻辑，当去除掉这些应用逻辑之后，那些剩下的死气沉沉的、纯粹的符号，才是语言层面的所谓“代码文本”。</p><p>去掉了执行逻辑所表达的那些行为、动作、结果和用户操作的代码，就是静态代码了。而事实上，ECMAScript 6中的模块就是用来理解你的程序中的那些静态代码的，也就是那些没有任何生气的字符和符号。因此它也就只能理解上面所谓的6种声明，以及它们声明出来的那些“名字和值”。</p><p>再无其它。</p><h2>解析export</h2><p>所以，将所有export语法分类，其实也就只有两个大类。如下：</p><pre><code>// 导出“（声明的）名字”\nexport &lt;let/const/var&gt; x ...;\nexport function x() ...\nexport class x ...\nexport {x, y, z, ...};\n\n\n// 导出“（重命名的）名字”\nexport { x as y, ...};\nexport { x as default, ... };\n\n\n// 导出“（其它模块的）名字”\nexport ... from ...;\n\n\n// 导出“值”\nexport default &lt;expression\n</code></pre><p>关于导出声明的、重命名的和其它模块的名字这三种情况，其实都比较容易理解，就是形成一个名字表，让外部模块能够查看就可以了。</p><p>但是对于最后这种形式，也就是“（导出）值”的形式，事实上是非常特殊的。因为如同我在上面所讲过的，要导出一个模块的全部内容就必须导出“（全部的）名字和值”，然而纯粹的值没有名字，于是也就没法访问了，所以这就与“导出点什么东西”的概念矛盾了。</p><p>因为这个东西要是没名字，也就连“自己是什么”都说不清楚，也就什么也不是了。</p><p>所以ECMAScript 6模块约定了一个称为\"default\"的名字，用于来导出当前模块中的一个“值”。显然的，由于所谓“值”是表达式的运算结果，所以这里的语法形式就是：</p><pre><code>export default &lt;expression&gt;;\n</code></pre><p>其中的“_expression”_就是用于求值的，以便得到一个结果（Result）并导出成为缺省的名字“default”。这里有两个便利的情况，一个是在JavaScript中，一般的字面量也是值、也是单值表达式，因此导出这样一个字面量也是合法的：</p><pre><code>export default 2;  // as state of the module, etc.\nexport default &quot;some messages&quot;; // data or information\n...\n</code></pre><p>第二个便利的情况，是因为JavaScript中对象也是字面量、也是值、也是单值表达式。而对象成员可以组合其它任何数据，所以通过上述的语法几乎可以导出当前模块中全部的“值”（亦即是任何可以导出的数据）。例如：</p><pre><code>var varName = 100;\nexport default {\n  varName,  // 直接导出名字\n  propName: 123,  // 导出值\n  funcName: function() { }, // 导出函数\n  foo() { // 或导出与主对象相关联的方法\n     // method\n  }\n}\n</code></pre><p>所以，事实上<code>export default ...</code>虽然简单，却是对“导出名字”的非常必要的补充。这样一来，用户既可以导出那些有名字的数据，也可以导出那些没有名字的数据，即一个模块中所有的数据都可以被导出了。</p><p>那么接下来，就要讲到标题中的这个语法了：</p><pre><code>export default function() {}\n</code></pre><p>你知道在这个语法中export到底导出了什么吗？是名字？还是值？</p><h2>导出语句的处理逻辑</h2><p>在讨论这个问题之前，你得先思考一个更关键的问题：“export如何导出名字”。这个问题的关键之处在于，如果只是导出一个名字，那么它其实在“某个名字表”中做一个登记项就可以了。并且JavaScript中也的确是这样处理的。但是实际使用的时候，这个名字还是要绑定一个具体的值才是可以使用的。因此，一个export也必须理解为这样两个步骤：</p><ol>\n<li>导出一个名字</li>\n<li>为上述名字绑定一个值</li>\n</ol><p>这两个步骤其实与使用“var x = 100”来声明一个变量的过程是一致的。因此以如下代码为例（注意六种声明在名字处理上是类似的），</p><pre><code>export var x = 100;\n</code></pre><p>在导出的时候，其实是先在“某个名字表”中登记一个“名字x”就可以了。这个过程也就是JavaScript在模块装载之前对export所做的全部工作。不过如果是从另一端（亦即是import语句）的角度看过来，那么就会多出来一个步骤。import语句会（例如<code>import {x} from ...</code>）：</p><ol>\n<li>（与export类似）按照语法在当前模块中声明名字，例如上面的<code>x</code>；</li>\n<li>添加一个当前模块对目标模块的依赖项。</li>\n</ol><p>有了上述的第二步操作，JavaScript就可以依据所有它能在静态文本中发现的<code>import</code>语句来形成模块依赖树，最后就可以找到这个模块依赖树最顶端的根模块，并尝试加载之。</p><p>所以关键的是，在“模块export/import”语法中 ，JavaScript是依赖import来形成依赖树的，与export无关。但是直到目前为止（我的意思是直到找到所有导入和导出的名字，并完成所有模块的装配的现在为止），没有任何一行用户的JavaScript代码是被执行过的。至于原因，从本讲的最开始我就讲过了：这个export/import过程中，源代码只被理解为静态的、没有逻辑的“代码文本”。那么既然“没有逻辑”，又怎么可能执行类似于：</p><pre><code>export default &lt;expression&gt;;\n</code></pre><p>中的“<em>expression</em>”呢？要知道所谓表达式，就是程序的计算逻辑啊。</p><p>所以，这里先得出了第一个关键结论：</p><p><span class=\"orange\">在处理export/import语句的全程，没有表达式被执行！</span></p><h2>导出名字与导出值的差异</h2><p>现在，假如：</p><pre><code>export default &lt;expression&gt;;\n</code></pre><p>中的“expression”在导入导出中完全不起作用（不执行），那么这行语句又能做什么呢？事实上，这行语句与直接“导出一个名字”并没有任何区别。它与这样的语法相同：</p><pre><code>export var x = 100;\n</code></pre><p>它们都只是导出一个名字，只是前者导出的是“default”这个特殊名字，而后者导出的是一个变量名“x”。它们都是确定的、符合语法规则的标识符，也可以表示为一个字符串的字面文本。它们的作用也完全一致：就是在前面所说的“某个名字表”中添加“一个登记项”而已。</p><p>所以，导出名字与导出值本质上并没有差异，在静态装配的阶段，它们都只是表达为一个名字而已。</p><p>然后，也正是如同<code>var x = 100;</code>在执行阶段需要有一个将“值100”绑定给“变量x（的引用）”的过程一样，这个<code>export default ...;</code>语句也需要有完全相同的一个过程来将它后面的表达式（<em>expression</em>）的结果绑定给“default”这个名字。如果不这么做，那么“<em>export default</em>”在语义上的就无法实现导出名字“<em>default</em>”了——在静态装配阶段，名字“default”只是被初始化为一个“单次绑定的、未初始化的标识符”。</p><p>所以现在你就可以在语义上模拟这样一个过程，即：</p><pre><code>export default function() {}\n\n// 类似于如下代码\n//（但并不在当前模块中声明名字&quot;default&quot;）\nexport var default = function() {}\n\n</code></pre><p>你可以进一步地模拟JavaScript后续的装配过程。这个过程其实非常简单：</p><ul>\n<li>找到并遍历模块依赖树的所有模块（这个树是排序的），然后</li>\n<li>执行这些模块最顶层的代码（<em>Top Level Module Evaluation</em>）。</li>\n</ul><p>在执行到上述<code>var default ....</code>（或类似对应的<code>export default ...</code>）语句时，执行后面的表达式，并将执行结果（Result）绑定给左侧的那个变量就可以了。如此，直到所有模块的顶层代码都执行完毕，那么所有的导出名字和它们的值也都必然是绑定完成了的。</p><p>同样，由于import的名字与export的名字只是一个映射关系，所以import的名字（所对应的值）也就初始化完成了。</p><p>再确切地说（这是第二个关键结论）：</p><p><span class=\"orange\">所谓模块的装配过程，就是执行一次顶层代码而已。</span></p><h2>匿名函数表达式的执行结果</h2><p>接下来讨论语句中的<code>... function() {}</code>这个匿名函数表达式。</p><p>按照JavaScript的约定，匿名函数表达式可以理解为一个函数的“字面量（值）”。理解“字面量值”这个说法是很有意义的，因为它意味着它没有名字。你可不要在心中暗骂哦，这绝不是废话。</p><p>“字面量（值）没有名字”就意味着执行这个“单值表达式”不会在当前作用域中产生一个名字，即使这个函数是具名的，也必然是如此。所以，这才带来了JavaScript中的经典示例，即：具名函数作为表达式时，名字在块级作用域中无意义。例如：</p><pre><code>// 具名函数作为表达式\nvar x1 = function x2() {\n  ...\n}\n  \n// 具名函数（声明）\nfunction x3() {\n  ...\n}\n</code></pre><p>上面的例子中，x1~3都是具有不同的语义的。其中，x2是不会在当前作用域（示例中是全局）中登记为名字的。而现在，就这一讲的主题来说，在使用下面的语法：</p><pre><code>export default function() { }\nexport default function x() { }\n</code></pre><p>导出一个匿名函数，或者一个具名的函数的时候，这两种情况下是不同的。但无论它是否具名，它们都是不可能在当前作用域中绑定给<code>default</code>这个名字，作为这个名字对应的值的。</p><p>这段处理逻辑被添加在语法：</p><blockquote>\n<p><em>ExportDeclaration</em>: <strong>export</strong>  <strong>default</strong>  <em>AnonymousFunctionDefinition</em>;</p>\n</blockquote><blockquote>\n<p>NOTE: ECMAScript是将这里导出的对象称为_Expression_/<em>AssignmentExpression</em>，这里所谓_AnonymousFunctionDefinition_则是其中_AssignmentExpression_的一个具体实例。</p>\n</blockquote><p>的执行（<em>Evaluation</em>）处理过程中。也就是说当执行这行声明时，如果后面的表达式是匿名函数声明，那么它将强制在当前作用域中登记为“<strong><em><em>default</em></em></strong>”这样一个特殊的名字，并且在执行时绑定该匿名函数。所以，尽管语义上我们需要将它登记为类似<code>var default ...</code>所声明的名字“<strong><em>default</em></strong>”，但事实上它被处理成了一个不可访问的中间名字，然后影射给该模块的“某个名字表”。</p><p>不过需要注意的是，这是一个<strong>匿名函数定义</strong>（<em>AnonymousFunctionDefinition</em>），而不是一个匿名函数表达式（<em>Anonymous FunctionExpression</em>）。一般函数的语句则被称为声明（或更严谨地称为宣告，<em>Function Declarations</em>）。而所谓<strong>匿名函数定义</strong>，其本身是表述为：</p><blockquote>\n<p><em>aName</em> = <strong><em>FunctionExpression</em></strong></p>\n</blockquote><p>或类似于此的语法风格的。它可以用在一般的赋值表达式、变量声明的右操作数，以及对象声明的成员初始值等等位置。在这些位置上，该函数表达式总是被关联给一个名字。一方面，这种关联不是严格意义上的“名字-&gt;值”的绑定语义；另一方面，当该函数关联给名字（<code>aName</code>）时，JavaScript又会反向地处理该函数（作为对象<code>f</code>）的属性<code>f.name</code>，使该名字指向<code>aName</code>。</p><p>所以，在本讲中的“export default function() {}”，在严格意义上来说（这是第三个关键结论）：</p><p><span class=\"orange\">它并不是导出了一个匿名函数表达式，而是导出了一个匿名函数定义（Anonymous  Function  Definition）。</span></p><p>因此，该匿名函数初始化时才会绑定给它左侧的名字“<strong><em>default</em></strong>”，这会导致<code>import f from ...</code>之后访问<code>f.name</code>值会得到“<strong><em>default</em></strong>”这个名字。</p><p>类似的，你使用下面的代码也会得到这个“<strong><em>default</em></strong>”：</p><pre><code>var obj = {\n  &quot;default&quot;: function() {}\n};\nconsole.log(obj.default.name); // &quot;default&quot;\n</code></pre><h2>知识补充</h2><p>关于export，还可以有一些补充的知识点。</p><ul>\n<li><code>export ...</code>语句通常是按它的词法声明来创建的标识符的，例如<code>export var x = ...</code>就意味着在当前模块环境中创建的是一个变量，并可以修改等等。但是当它被导入时，在<code>import</code>语句所在的模块中却是一个常量，因此总是不可写的。</li>\n<li>由于<code>export default ...</code>没有显式地约定名字“default（或<em>default</em>）”应该按<code>let/const/var</code>的哪一种来创建，因此JavaScript缺省将它创建成一个普通的变量（var），但即使是在当前模块环境中，它事实上也是不可写的，因为你无法访问一个命名为“<em>default</em>”的变量——它不是一个合法的标识符。</li>\n<li>所谓匿名函数，仅仅是当它直接作为操作数（而不是具有上述“匿名函数定义”的语法结构）时，才是真正匿名的，例如：</li>\n</ul><pre><code>console.log((function(){}).name);  // &quot;&quot;\n</code></pre><ul>\n<li>由于类表达式（包括匿名类表达式）在本质上就是函数，因此它作为default导出时的性质与上面所讨论的是一致的。</li>\n<li>导出项（的名字）总是作为词法声明被声明在当前模块作用域中的，这意味着它不可删除，且不可重复导出。亦即是说即使是用<code>var x...</code>来声明，这个<code>x</code>也是在_lexicalNames_中，而不是在_varNames_中。</li>\n<li>所谓“某个名字表”，对于export来说是模块的导出表，对于import来说就是名字空间（名字空间是用户代码可以操作的组件，它映射自内部的模块导入名字表）。不过，如果用户代码不使用“import * as …”的语法来创建这个名字空间，那么该名字表就只存在于JavaScript的词法分析过程中，而不会（或并不必要）创建它在运行期的实例。这也是我一直用“某个名字表”来称呼它的原因，它并不总是以实体形式存在的。</li>\n<li>上述名字表简化了ECMAScript中对导入导出记录（<em>ImportEntry/ExportEntry Record Fields</em>）的理解。因此如果你试图了解更多，建议你阅读ECMAScript的具体章节。</li>\n<li>没有模块会导出（传统意义上的）main()，因为ECMAScript为了维护模块的静态语义，而把执行过程及其入口的定义丢回给了引擎或宿主本身。</li>\n</ul><h2>思考题</h2><p>本讲的内容中，你需要重点复习三个关键结论的得出过程。这对于之前几讲中所讨论的内容会是很好的回顾。</p><p>除此之外，建议你思考如下问题：</p><ul>\n<li>为什么在import语句中会出现“变量提升”的效果？</li>\n</ul><p>如果你并不了解什么是“变量提升”，不用担心，下一讲中我会再次提到它。</p>","comments":[{"had_liked":false,"id":152543,"user_name":"weineel","can_delete":false,"product_type":"c1","uid":1049741,"ip_address":"","ucode":"6DC6EF4F256A53","user_header":"https://static001.geekbang.org/account/avatar/00/10/04/8d/005c2ff3.jpg","comment_is_top":false,"comment_ctime":1574041368,"is_pvip":true,"replies":[{"id":"58610","content":"Yes! 满分答案👍","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574042547,"ip_address":"","comment_id":152543,"utype":1}],"discussion_count":1,"race_medal":2,"score":"203437504280","product_id":100039701,"comment_content":"ESModule 根据 import 构建依赖树，所以在代码运行前名字就是已经存在于上下文，然后在运行模块最顶层代码，给名字绑定值，就出现了‘变量提升’的效果。","like_count":48,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474852,"discussion_content":"Yes! 满分答案👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574042547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":154125,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1574383250,"is_pvip":false,"replies":[{"id":"59196","content":"对哒！赞+2","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574400222,"ip_address":"","comment_id":154125,"utype":1}],"discussion_count":1,"race_medal":0,"score":"57408958098","product_id":100039701,"comment_content":"hello 老师好，感谢老师之前的回答，有醍醐灌顶之效。<br><br>下面是读完这篇文章和下面评论之后的观点，不知是否有误，望指正，一如既往的感谢：）<br><br>1.<br><br>function a() {} &#47;&#47; 函数声明，在六种声明内<br><br>function () {} &#47;&#47; 报错，以function 开头应该是声明，但是又没有名字<br><br>(function() {}) &#47;&#47; 函数表达式（这是一个正真的匿名函数(function() {}).name 为 “”），即使是具名函数（function a() {}），当前作用域也找不到a，因为这不是声明<br><br>var a = function() {} &#47;&#47; 函数定义，这里的function() {} 也是表达式，只是赋给了变量a，所以有了区别，也有了名字a.name为a，称作函数定义<br><br>var b = function c() {} &#47;&#47; 函数定义，函数function c() {} 也是表达式，只是赋值给了变量b，但是b.name却为c，和上面存在的区别，但也是函数定义<br><br>2.<br><br>导出的是&quot;名字&quot;，我理解为名字就像一个绳子，后面拴的牛是会变的。这就是为什么import {a} from &#39;..&#47;a.js&#39; 这个a会变，虽然当前模块不能赋值给a。","like_count":14,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475381,"discussion_content":"对哒！赞+2","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574400222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152556,"user_name":"万籁无声","can_delete":false,"product_type":"c1","uid":1234060,"ip_address":"","ucode":"DADA76C558A65B","user_header":"","comment_is_top":false,"comment_ctime":1574042711,"is_pvip":false,"replies":[{"id":"58616","content":"正好，刚写完“Y”同学的留言，你不妨看看，应该正好能回答你的疑问。<br><br>（万恶的极客时间没有提供分留言链接的功能，产品同学要打手板心5次 🤔）","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574043646,"ip_address":"","comment_id":152556,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48818682967","product_id":100039701,"comment_content":"感觉没有抓住主题思想在表达什么，可能是我层次太低了","like_count":12,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474856,"discussion_content":"正好，刚写完“Y”同学的留言，你不妨看看，应该正好能回答你的疑问。\n\n（万恶的极客时间没有提供分留言链接的功能，产品同学要打手板心5次 🤔）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574043646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152544,"user_name":"Y","can_delete":false,"product_type":"c1","uid":1555967,"ip_address":"","ucode":"4AA6170E230C0C","user_header":"https://static001.geekbang.org/account/avatar/00/17/bd/ff/f4f2ae6a.jpg","comment_is_top":false,"comment_ctime":1574041429,"is_pvip":false,"replies":[{"id":"58615","content":"是的。不过，这算是题解。中心还是模块装载执行和标识符绑定全过程来着😄<br>标识符和值绑定是“声明”语法处理的核心，而六种声明是js静态语法的核心。而静态语法，也就是这一整篇“语言如何构建”的核心了🤓","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574043346,"ip_address":"","comment_id":152544,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48818681685","product_id":100039701,"comment_content":"老师，关于这边文章的中心，我能总结成这个意思吗。<br>export default function(){}。这个语法本身没有任何的问题。但是他看似导出一个匿名函数表达式。其实他真正导出的是一个具有名字的函数，名字的default。","like_count":12,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474853,"discussion_content":"是的。不过，这算是题解。中心还是模块装载执行和标识符绑定全过程来着😄\n标识符和值绑定是“声明”语法处理的核心，而六种声明是js静态语法的核心。而静态语法，也就是这一整篇“语言如何构建”的核心了🤓","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574043346,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152663,"user_name":"许童童","can_delete":false,"product_type":"c1","uid":1003005,"ip_address":"","ucode":"4B799C0C6BC678","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4d/fd/0aa0e39f.jpg","comment_is_top":false,"comment_ctime":1574058826,"is_pvip":false,"replies":[{"id":"58671","content":"😃👍","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574073119,"ip_address":"","comment_id":152663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"44523731786","product_id":100039701,"comment_content":"为什么在 import 语句中会出现“变量提升”的效果？<br>如老师所说，在代码真正被执行前，会先进行模块的装配过程，也就是执行一次顶层代码。所以如果import了一个模块，就会先执行模块内部的顶层代码，看起来的现象就是“变量提升”了。","like_count":10,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474889,"discussion_content":"😃👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574073119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193471,"user_name":"🇧🇪 Hazard🇦🇷","can_delete":false,"product_type":"c1","uid":1361489,"ip_address":"","ucode":"E2C44FAFDFAA88","user_header":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","comment_is_top":false,"comment_ctime":1584897974,"is_pvip":false,"replies":[{"id":"73730","content":"验证这个映射关系很简单。<br><br>B模块中export一个let变量，然后在A模块中import它为x。然后你尝试在A模块中x++，你会发现提示为常量不可写。<br><br>所以A、B两个模块中的名字其实并不是同一个变量，它们名字相同（或者不同），但A模块中只是通过一个（类似于别名的）映射来指向B模块中的名字。<br><br>映射是通过创建一个专用的数据结构来实现的，访问该结构就跳到目标数据，但每个操作都有特定的限制（例如上面的只读）。——这整体上有些类似于属性中的get&#47;setter的机制，但并不是用属性描述符来做到的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1584930779,"ip_address":"","comment_id":193471,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31649669046","product_id":100039701,"comment_content":"老师，有一句话不太明白。<br>&quot; import 的名字与 export 的名字只是一个映射关系 &quot;。<br><br>export 一个变量，比如 count，如果设一个定时器执行，每次count都加 1；<br>import { count }， 这个count也会每次都改变。这就是所说的映射关系吗？<br><br>这个映射关系是怎么做到的？","like_count":8,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488564,"discussion_content":"验证这个映射关系很简单。\n\nB模块中export一个let变量，然后在A模块中import它为x。然后你尝试在A模块中x++，你会发现提示为常量不可写。\n\n所以A、B两个模块中的名字其实并不是同一个变量，它们名字相同（或者不同），但A模块中只是通过一个（类似于别名的）映射来指向B模块中的名字。\n\n映射是通过创建一个专用的数据结构来实现的，访问该结构就跳到目标数据，但每个操作都有特定的限制（例如上面的只读）。——这整体上有些类似于属性中的get/setter的机制，但并不是用属性描述符来做到的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584930779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153200,"user_name":"Marvin","can_delete":false,"product_type":"c1","uid":1096381,"ip_address":"","ucode":"443BD8B20285A9","user_header":"https://static001.geekbang.org/account/avatar/00/10/ba/bd/6f2f078c.jpg","comment_is_top":false,"comment_ctime":1574179405,"is_pvip":false,"replies":[{"id":"58930","content":"有点特殊，但就处理逻辑（以及目的）上来说，也并不算是特例。<br><br>其实“函数定义（Function Definition）”这个概念出现得比较奇怪。<br><br>仔细分析一下就明白了，你想，“函数声明（Function Declaration）”是静态语义的，它在执行期的结果是empty，所以它必须是具名的才能导出，因为“声明（6种）”的目的都是具名，而export原则上只能“导出一个名字”。所以，由于“函数定义（Function Definition）”没有名字，所以它不能按函数声明来处理。<br><br>然后，由于“函数表达式（Function Expression）”是动态语义的，有执行语义（也就是执行结果返回不是empty），得到一个运行期概念上的“闭包”。但这并不是最关键处，最关键的地方在于函数表达式没名字——即使是具名的函数表达式，它的名字也只能闭包内有影响。由于它没有名字一个可供导出的名字，所以也不能直接直接用作export的对象。<br><br>那么到底在概念上该怎么说这个东西呢？ECMAScript在这里就加了这么一层概念，叫“函数声明（Function Declaration）”，一方面它是有静态语义的，它声明了某个东西；另一方面，它的名字又是迟绑定的，需要到了执行期根据“name = FunctionExpression”中的`name`来确认。<br><br>在这种情况下，其实“函数定义（Function Definition）”就是“函数表达式”的一层概念封装：它又有在外层（或被关联的对象）中的名字，它又是表达式；它的执行结果又是闭包，又是实例。<br><br>所以箭头函数看起来是特例，但用在导出语法的“这个位置”时，概念上却仍然是“封装了一层的‘箭头函数表达式’”，仍然还是“函数定义”。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574221601,"ip_address":"","comment_id":153200,"utype":1}],"discussion_count":4,"race_medal":0,"score":"23049015885","product_id":100039701,"comment_content":"export default v=&gt;v 这种，箭头函数是特例吗？","like_count":6,"discussions":[{"author":{"id":1293057,"avatar":"https://static001.geekbang.org/account/avatar/00/13/bb/01/568ac2d6.jpg","nickname":"K4SHIFZ","note":"","ucode":"BFB49AAC0E4C74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229419,"discussion_content":"那么到底在概念上该怎么说这个东西呢？ECMAScript在这里就加了这么一层概念，叫“函数声明（Function Declaration）”，一方面它是有静态语义的，它声明了某个东西；另一方面，它的名字又是迟绑定的，需要到了执行期根据“name = FunctionExpression”中的`name`来确认。\n\n这里是笔误了吗？说的是函数定义吧？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586646177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475079,"discussion_content":"有点特殊，但就处理逻辑（以及目的）上来说，也并不算是特例。\n\n其实“函数定义（Function Definition）”这个概念出现得比较奇怪。\n\n仔细分析一下就明白了，你想，“函数声明（Function Declaration）”是静态语义的，它在执行期的结果是empty，所以它必须是具名的才能导出，因为“声明（6种）”的目的都是具名，而export原则上只能“导出一个名字”。所以，由于“函数定义（Function Definition）”没有名字，所以它不能按函数声明来处理。\n\n然后，由于“函数表达式（Function Expression）”是动态语义的，有执行语义（也就是执行结果返回不是empty），得到一个运行期概念上的“闭包”。但这并不是最关键处，最关键的地方在于函数表达式没名字——即使是具名的函数表达式，它的名字也只能闭包内有影响。由于它没有名字一个可供导出的名字，所以也不能直接直接用作export的对象。\n\n那么到底在概念上该怎么说这个东西呢？ECMAScript在这里就加了这么一层概念，叫“函数声明（Function Declaration）”，一方面它是有静态语义的，它声明了某个东西；另一方面，它的名字又是迟绑定的，需要到了执行期根据“name = FunctionExpression”中的`name`来确认。\n\n在这种情况下，其实“函数定义（Function Definition）”就是“函数表达式”的一层概念封装：它又有在外层（或被关联的对象）中的名字，它又是表达式；它的执行结果又是闭包，又是实例。\n\n所以箭头函数看起来是特例，但用在导出语法的“这个位置”时，概念上却仍然是“封装了一层的‘箭头函数表达式’”，仍然还是“函数定义”。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574221601,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096381,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ba/bd/6f2f078c.jpg","nickname":"Marvin","note":"","ucode":"443BD8B20285A9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60158,"discussion_content":"很受启发。我在做babel的ast解释器的时候，确实遇到declaration和expression两种节点。现在意识到，ast中有functionDeclaration和functionExpression，却没有arrowFunctionDeclararion，大概箭头函数天生只有expresstion一种表达。另外有种感觉，就是function具名声明时，与var的行为特征几乎是一致的，可以等同视为一种变量声明方式；而当function在var的右侧时，function就只是一个表达式而已，而且这种方式越来越多被采用，基本把“function声明”方式替代了。我之前偏爱用function声明函数，是因为在ie早期版本乃至chrome早期版本中，functionExpression是没有name的。后来也是偶然发现var变量名会传递给functionExp作为name，也是一个小惊喜。感谢您的耐心解答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574697831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1096381,"avatar":"https://static001.geekbang.org/account/avatar/00/10/ba/bd/6f2f078c.jpg","nickname":"Marvin","note":"","ucode":"443BD8B20285A9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":65437,"discussion_content":"确实，现在将function用在var的右侧是更常见的。在tc39也好，在社区也好，一直来说都有js的两派，一种喜欢将一切搞成动态的，所以就有了var x = function...，另一派习惯将一切搞成静态的，例如function x() ...这样的声明。这两种也都很有历史渊源，也都有很明确的应用场景，所以很难讲对错。但是就6种声明来说，它决定了javascript首先是静态的，其次才是动态的，这个语法和引擎的处理顺序来确保的。babel事实上也主要是工作在静态层面上，所以对这些抽象概念要敏感得多，实际到了js的执行层面，这里的差别就很少了。因为说到底，就是个作用域中的名字是不是被覆盖的问题，这在实用中，有太多的方式来映射了，在概念层面动手脚，反倒不是太有效果。\n还有，我也习惯用function x() ...声明的形式。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575002931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60158,"ip_address":""},"score":65437,"extra":""}]}]},{"had_liked":false,"id":152933,"user_name":"leslee","can_delete":false,"product_type":"c1","uid":1384326,"ip_address":"","ucode":"DB1CBF9F8D16BF","user_header":"https://static001.geekbang.org/account/avatar/00/15/1f/86/3a7eeac4.jpg","comment_is_top":false,"comment_ctime":1574125635,"is_pvip":false,"replies":[{"id":"58766","content":"这是因为类似于：<br><br>obj = {<br>  f: function() {<br>  },<br>  ...<br>}<br><br>这样位置中的匿名函数，在ECMAScript中都是称为“匿名函数定义”，而不是“匿名函数表达式”。所有在语法上记为“x = functionExpression”的，在处理上都与一般表达式有不同，这是一个非常非常小的细节，但在引擎层面，加入了好大一段逻辑呢。<br><br>真正的匿名函数表达式，是下面这样的：<br>&gt; (1 + function() {})<br><br>就是：把它直接用在一个表达式计算过程中，而不是把它用来赋值（或绑定，或引用）给另一个东西。这种情况下，它才是按匿名函数表达式来处理的。<br><br>这几讲都是讲JavaScript的静态语言特性的，所以“词法分析以及对应的引擎处理”是要点，在词法分析阶段，关键在于“不能为它（函数、函数表达式、函数定义等等）创建闭包”。因为在静态处理阶段，还没有“闭包”这个概念，所以好多东西处理起来跟我们平常的理解不同，这就是根由了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574132286,"ip_address":"","comment_id":152933,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23048962115","product_id":100039701,"comment_content":"第三个结论推导过程的中间语法定义的引用那里(markdown &#39;&gt;&#39; 符号表示的引用)读得不是很通顺, 有点迷....","like_count":6,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474993,"discussion_content":"这是因为类似于：\n\nobj = {\n  f: function() {\n  },\n  ...\n}\n\n这样位置中的匿名函数，在ECMAScript中都是称为“匿名函数定义”，而不是“匿名函数表达式”。所有在语法上记为“x = functionExpression”的，在处理上都与一般表达式有不同，这是一个非常非常小的细节，但在引擎层面，加入了好大一段逻辑呢。\n\n真正的匿名函数表达式，是下面这样的：\n&amp;gt; (1 + function() {})\n\n就是：把它直接用在一个表达式计算过程中，而不是把它用来赋值（或绑定，或引用）给另一个东西。这种情况下，它才是按匿名函数表达式来处理的。\n\n这几讲都是讲JavaScript的静态语言特性的，所以“词法分析以及对应的引擎处理”是要点，在词法分析阶段，关键在于“不能为它（函数、函数表达式、函数定义等等）创建闭包”。因为在静态处理阶段，还没有“闭包”这个概念，所以好多东西处理起来跟我们平常的理解不同，这就是根由了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574132286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161663,"user_name":"leslee","can_delete":false,"product_type":"c1","uid":1384326,"ip_address":"","ucode":"DB1CBF9F8D16BF","user_header":"https://static001.geekbang.org/account/avatar/00/15/1f/86/3a7eeac4.jpg","comment_is_top":false,"comment_ctime":1576289919,"is_pvip":false,"replies":[{"id":"61612","content":"Yes. 这样理解没错。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576340788,"ip_address":"","comment_id":161663,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18756159103","product_id":100039701,"comment_content":"是否可以理解为，一个具有了名字的函数表达式就可以称为函数定义","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477802,"discussion_content":"Yes. 这样理解没错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576340788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243242,"user_name":"Geek_885849","can_delete":false,"product_type":"c1","uid":1740861,"ip_address":"","ucode":"2054C0DD8D4A64","user_header":"","comment_is_top":false,"comment_ctime":1598002380,"is_pvip":false,"replies":[{"id":"90343","content":"关于这个问题，在《JavaScript语言精髓与编程实践》的第“5.5.2.4 函数表达式的特殊性”中专门有讲过，主要是因为“函数名作为标识符所声明的位置”所导致的。<br><br>具体来说，如果是函数声明，那么函数名是声明在它“所在”上下文的，因此它是否能“重新声明”取决于它所在的（外部的）上下文的严格模式状态。例如：<br><br>```<br>function foo() {<br>  function f() {<br>    &quot;use strict&quot;;<br>    f = 1;  &#47;&#47; 可重写，因为`f`声明在foo()中<br>  }<br>  f()<br>  console.log(typeof f); &#47;&#47; number<br>}<br><br>foo()<br>```<br><br>为了在函数表达式中达成类似的效果（语言的一致性），所以函数表达式中这个函数名，也不是声明在函数体（以及由函数体所决定的闭包）中的。它采用了“双层作用域”的特殊构造，也就是函数名声明在外部作用域中（outerScope），而闭包的parent再指向这个outerScope。——函数的&quot;use strict&quot;只影响到函数自己的闭包。<br><br>所以回到你的例子，<br>```<br>&quot;use strict&quot;;<br>      (function a() {<br>        const a = 2;<br>        console.log(a);<br>      })();<br>```<br>由于是函数表达式，所以`a()`作为名字其实是声明在一个outerScope中的——没错，这个scope也是strict模式的。接下来函数body中声明了`count a`，这个名字所在的作用域（闭包）中并没有`a`这个名字，所以无论其外部，或者内部是否是严格模式，这个名字`a`都是可以创建的。<br><br>与此不同的是，函数参数是声明在闭包中的，所以它表现得跟函数名不同：如果函数参数中有名字a，那么上例中的`const a`就无法声明了。这同样也证明了函数名`a()`需要一个outerScope的重要性，因为历史中下面这样的代码“总是”合法的（无论是函数声明还是函数表达式）：<br><br>```<br>function a(a) {<br>  ...<br>}<br>```","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1599018580,"ip_address":"","comment_id":243242,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14482904268","product_id":100039701,"comment_content":"&quot;use strict&quot;;<br>      (function a() {<br>        const a = 2;<br>        console.log(a);<br>      })();<br>老师您好,这个函数名a 不是已经作为函数内部的标识符了吗,为什么还可以重新声明呢?","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504238,"discussion_content":"关于这个问题，在《JavaScript语言精髓与编程实践》的第“5.5.2.4 函数表达式的特殊性”中专门有讲过，主要是因为“函数名作为标识符所声明的位置”所导致的。\n\n具体来说，如果是函数声明，那么函数名是声明在它“所在”上下文的，因此它是否能“重新声明”取决于它所在的（外部的）上下文的严格模式状态。例如：\n\n```\nfunction foo() {\n  function f() {\n    &amp;quot;use strict&amp;quot;;\n    f = 1;  // 可重写，因为`f`声明在foo()中\n  }\n  f()\n  console.log(typeof f); // number\n}\n\nfoo()\n```\n\n为了在函数表达式中达成类似的效果（语言的一致性），所以函数表达式中这个函数名，也不是声明在函数体（以及由函数体所决定的闭包）中的。它采用了“双层作用域”的特殊构造，也就是函数名声明在外部作用域中（outerScope），而闭包的parent再指向这个outerScope。——函数的&amp;quot;use strict&amp;quot;只影响到函数自己的闭包。\n\n所以回到你的例子，\n```\n&amp;quot;use strict&amp;quot;;\n      (function a() {\n        const a = 2;\n        console.log(a);\n      })();\n```\n由于是函数表达式，所以`a()`作为名字其实是声明在一个outerScope中的——没错，这个scope也是strict模式的。接下来函数body中声明了`count a`，这个名字所在的作用域（闭包）中并没有`a`这个名字，所以无论其外部，或者内部是否是严格模式，这个名字`a`都是可以创建的。\n\n与此不同的是，函数参数是声明在闭包中的，所以它表现得跟函数名不同：如果函数参数中有名字a，那么上例中的`const a`就无法声明了。这同样也证明了函数名`a()`需要一个outerScope的重要性，因为历史中下面这样的代码“总是”合法的（无论是函数声明还是函数表达式）：\n\n```\nfunction a(a) {\n  ...\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599018580,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1338736,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6d/70/25ba4287.jpg","nickname":"明月","note":"","ucode":"D6586156BF09CF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":542363,"discussion_content":"老师，您这句话---‘那么函数名是声明在它“所在”上下文的，因此它是否能“重新声明”取决于它所在的（外部的）上下文的严格模式状态。’是不是就意味着如果函数所在的上下文时严格模式，那么函数声明就无法重写了，但是我尝试了如下代码，f 在严格模式下依然是能够被重写的。\nfunction foo() {\n  &#34;use strict&#34;;\n  function f() {\n     // 可重写，因为`f`声明在foo()中\n  }\n  f = 1;\n  console.log(typeof f); // number\n}\nfoo();","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640740641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":504238,"ip_address":""},"score":542363,"extra":""}]}]},{"had_liked":false,"id":180610,"user_name":"七月有风","can_delete":false,"product_type":"c1","uid":1439990,"ip_address":"","ucode":"B3F82397347C5B","user_header":"https://static001.geekbang.org/account/avatar/00/15/f8/f6/3e2db176.jpg","comment_is_top":false,"comment_ctime":1582349908,"is_pvip":false,"replies":[{"id":"70105","content":"nodejs中，是在require()函数执行过程中来执行模块的顶层代码的。<br>nodejs模块被封装在一个函数中（亦即是作为一个函数的函数体），由require()在加载完指定模块的文本代码之后，用普通的调用函数的方法调用，从而实现模块装载的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1582375889,"ip_address":"","comment_id":180610,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14467251796","product_id":100039701,"comment_content":"ECMAScript 6 模块是静态装配的，而传统的 Node.js 模块却是动态加载的。是不是说node是在执行阶段才会执行模块的顶层代码。","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484732,"discussion_content":"nodejs中，是在require()函数执行过程中来执行模块的顶层代码的。\nnodejs模块被封装在一个函数中（亦即是作为一个函数的函数体），由require()在加载完指定模块的文本代码之后，用普通的调用函数的方法调用，从而实现模块装载的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582375889,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":163345,"user_name":"晓小东","can_delete":false,"product_type":"c1","uid":1194643,"ip_address":"","ucode":"93F9462EAAA63C","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/93/d7be8a1a.jpg","comment_is_top":false,"comment_ctime":1576706939,"is_pvip":true,"replies":[{"id":"62117","content":"关于这个问题，其实还挺好玩儿的，因为它涉及到`execute_context.VariableEnvironment`这个东西怎么用的问题。<br><br>首先，其实词法环境(LexicalEnvironment)与变量环境(VariableEnvironment)并没有一个所谓优先级的问题。在实现上，它们之间是一个使用env.outer来衔接起来的链，所以所谓查找顺序，本质上就是二者谁在链的外层的问题。——然而，从实际实现的角度上，二者并不需要强调谁在外层，这种关系不是必须的（它们只需要衔接在一起就可以了）。<br><br>除了在函数或全局初始化需要一个表来指示“哪些东西是var和函数名”之外，事实上区分var&#47;let&#47;const之间的必要性是不大的。并且即使是在这种情况下，引擎也并不需要VariableEnvironment这个东东的参与，因为在它们初始化时，引擎是可以访问来自源代码的ParserNode的。也就是说，它可以直接访问原始的信息，而不必依赖VariableEnvironment这个列表。<br><br>VariableEnvironment这个东西，以及LexicalEnvironment，它们都是给运行期的上下文用的，也只在运行期才有意义。——更进一步的，只有对全局和函数，在它们的执行期才有意义（对函数来说，是它被调用的时候）。<br><br>为什么呢？就目前而言，VariableEnvironment其实只在一种情况下被用到。——就是当全局或函数内出现eval(&#39;var x...&#39;)这样的代码的时候。因为只有在这种情况下，在相应的变量环境中，才会需要执行上下文去访问变量环境列表，并动态地向中间插入一个新的名字。由于事实上var变量只能全局和函数有用，所以四种执行上下文（Global&#47;Function&#47;Module&#47;Eval）中，虽然都有这两个成员，但其实Module.VariableEnvironment是没有用的，而Eval.VariableEnvironment受限于是否是在严格模式（当处在非严格模式时，它指向外层的——例如函数的VariableEnvironment；当处在严格模式时，它将自己创建一个，以隔离开对外部环境的影响）。<br><br>所以，本质上你来看VariableEnvironment这个东西的时候，不是要去“检查”它有什么样的优先级，而是直接看到“它有什么用，它怎么用”。再一次强调，对于单向链表访问来说，所谓“优先级”就是谁在链尾的问题；但即使如此，它对VariableEnvironment的使用来说也没有什么意义，因为VariableEnvironment归ExecuteContext使用，而ExecuteContext根本不care这个顺序。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576725309,"ip_address":"","comment_id":163345,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14461608827","product_id":100039701,"comment_content":"老师，我又来了，怕您看不到我的问题，接上一个问题，函数声明标识符不应该放入词法环境用中，本来我想函数声明标识符放入词法环境，来验证函数声明提升优先级高于var ，因为标识符的查找先从词法环境中查找，再到变量环境，再到上级作用域，从而实现声明的优先级。老师对于函数声明的优先级，你怎么看。","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478359,"discussion_content":"关于这个问题，其实还挺好玩儿的，因为它涉及到`execute_context.VariableEnvironment`这个东西怎么用的问题。\n\n首先，其实词法环境(LexicalEnvironment)与变量环境(VariableEnvironment)并没有一个所谓优先级的问题。在实现上，它们之间是一个使用env.outer来衔接起来的链，所以所谓查找顺序，本质上就是二者谁在链的外层的问题。——然而，从实际实现的角度上，二者并不需要强调谁在外层，这种关系不是必须的（它们只需要衔接在一起就可以了）。\n\n除了在函数或全局初始化需要一个表来指示“哪些东西是var和函数名”之外，事实上区分var/let/const之间的必要性是不大的。并且即使是在这种情况下，引擎也并不需要VariableEnvironment这个东东的参与，因为在它们初始化时，引擎是可以访问来自源代码的ParserNode的。也就是说，它可以直接访问原始的信息，而不必依赖VariableEnvironment这个列表。\n\nVariableEnvironment这个东西，以及LexicalEnvironment，它们都是给运行期的上下文用的，也只在运行期才有意义。——更进一步的，只有对全局和函数，在它们的执行期才有意义（对函数来说，是它被调用的时候）。\n\n为什么呢？就目前而言，VariableEnvironment其实只在一种情况下被用到。——就是当全局或函数内出现eval(&amp;#39;var x...&amp;#39;)这样的代码的时候。因为只有在这种情况下，在相应的变量环境中，才会需要执行上下文去访问变量环境列表，并动态地向中间插入一个新的名字。由于事实上var变量只能全局和函数有用，所以四种执行上下文（Global/Function/Module/Eval）中，虽然都有这两个成员，但其实Module.VariableEnvironment是没有用的，而Eval.VariableEnvironment受限于是否是在严格模式（当处在非严格模式时，它指向外层的——例如函数的VariableEnvironment；当处在严格模式时，它将自己创建一个，以隔离开对外部环境的影响）。\n\n所以，本质上你来看VariableEnvironment这个东西的时候，不是要去“检查”它有什么样的优先级，而是直接看到“它有什么用，它怎么用”。再一次强调，对于单向链表访问来说，所谓“优先级”就是谁在链尾的问题；但即使如此，它对VariableEnvironment的使用来说也没有什么意义，因为VariableEnvironment归ExecuteContext使用，而ExecuteContext根本不care这个顺序。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576725309,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156951,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1574999910,"is_pvip":false,"replies":[{"id":"60437","content":"是的。这个“执行期”在用户代码之前。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575224362,"ip_address":"","comment_id":156951,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14459901798","product_id":100039701,"comment_content":"可以这样理解吗？<br>静态解析期：export只导出名字到某个名字表，import从名字表获取映射关系。<br>执行期：执行代码，为名字赋值。","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476282,"discussion_content":"是的。这个“执行期”在用户代码之前。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575224362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156947,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1574999695,"is_pvip":false,"replies":[{"id":"60435","content":"```<br>&#47;&#47; t.mjs<br>console.log(&quot;here =&gt;&quot;, typeof f);<br>import f from &#39;.&#47;f.mjs&#39;;<br><br>&#47;&#47; f.mjs<br>export default function() {}<br>console.log(&#39;NOW&#39;);<br><br>&#47;&#47; test<br>&gt; node --experimental-modules t.mjs<br>NOW<br>here =&gt; function<br>```<br><br>想想，<br> 1. 为什么`here`为什么是function呢？import语句还没有到呢。<br> 2. 为什么`NOW`在`here`之前？这是哪个时候的执行过程？","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575224337,"ip_address":"","comment_id":156947,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14459901583","product_id":100039701,"comment_content":"所谓模块的装配过程，就是执行一次顶层代码而已。<br><br>这边的顶层代码是指什么呢？模块装配不是在静态解析期进行的吗？为什么还会执行代码？还是这边指的执行并不是一般意义上的执行呢？","like_count":4,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476280,"discussion_content":"```\n// t.mjs\nconsole.log(&amp;quot;here =&amp;gt;&amp;quot;, typeof f);\nimport f from &amp;#39;./f.mjs&amp;#39;;\n\n// f.mjs\nexport default function() {}\nconsole.log(&amp;#39;NOW&amp;#39;);\n\n// test\n&amp;gt; node --experimental-modules t.mjs\nNOW\nhere =&amp;gt; function\n```\n\n想想，\n 1. 为什么`here`为什么是function呢？import语句还没有到呢。\n 2. 为什么`NOW`在`here`之前？这是哪个时候的执行过程？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575224337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1042089,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e6/a9/b459efb7.jpg","nickname":"如故","note":"","ucode":"F6895792309942","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350089,"discussion_content":"相当于把f.mjs中的内容放到了t.mjs的最顶层，然后再执行吗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613703913,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":286404,"user_name":"zxcv","can_delete":false,"product_type":"c1","uid":1508413,"ip_address":"","ucode":"6E2A780768892C","user_header":"https://static001.geekbang.org/account/avatar/00/17/04/3d/a3bc7751.jpg","comment_is_top":false,"comment_ctime":1617282181,"is_pvip":false,"replies":[{"id":"104026","content":"这部分在ECMAScript里面就是这么讲述的，那段E文是取自ECMAScript的原文。关于这些概念，你可以看ECMAScript的相关内容，有些中文的可以看，在这里：<br>https:&#47;&#47;www.w3.org&#47;html&#47;ig&#47;zh&#47;wiki&#47;ES5<br><br>有些内容是在后面会介绍到，比如这些概念为什么要这么讲。第5讲后面的加餐，以及第11讲后的加餐都很重要。不过，不用着急，慢慢学到那些章节，就明白了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1617295452,"ip_address":"","comment_id":286404,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10207216773","product_id":100039701,"comment_content":"在语言设计中，所谓“标识符”与“名字”是有语义差别的，export 将之称为名字，就意味着这是一个标识符的子集。类似的其它子集也是存在的，例如“保留字是标识符名，但不能用作标识符（A reserved word is an IdentifierName that cannot be used as an Identifier）”。<br><br>看不懂哇～","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517972,"discussion_content":"这部分在ECMAScript里面就是这么讲述的，那段E文是取自ECMAScript的原文。关于这些概念，你可以看ECMAScript的相关内容，有些中文的可以看，在这里：\nhttps://www.w3.org/html/ig/zh/wiki/ES5\n\n有些内容是在后面会介绍到，比如这些概念为什么要这么讲。第5讲后面的加餐，以及第11讲后的加餐都很重要。不过，不用着急，慢慢学到那些章节，就明白了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617295452,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241774,"user_name":"李李","can_delete":false,"product_type":"c1","uid":1452061,"ip_address":"","ucode":"B576BE1AFA7386","user_header":"https://static001.geekbang.org/account/avatar/00/16/28/1d/5d6a0500.jpg","comment_is_top":false,"comment_ctime":1597417830,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10187352422","product_id":100039701,"comment_content":"我认为知识点讲解是要深入浅出, 好难接受这种风格。   所以的知识点都事无巨细看似很全但是没有重点。  看着难受....","like_count":3},{"had_liked":false,"id":230394,"user_name":"孜孜","can_delete":false,"product_type":"c1","uid":1018203,"ip_address":"","ucode":"7EF4FB644357CE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/89/5b/d8f78c1e.jpg","comment_is_top":false,"comment_ctime":1593360126,"is_pvip":true,"replies":[{"id":"85052","content":"是的。<br><br>另外，在设计上这符合“谁创建谁负责”的原则。对于export出来的x，所有的importer只能读；如果source发布x的写行为，那么应该另外export一个写方法出来。这类似于在对象中使用get&#47;setter来访问属性，其设计原则和风格是一致的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1593399859,"ip_address":"","comment_id":230394,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10183294718","product_id":100039701,"comment_content":"是不是因为“import语句所在的模块中却是一个常量”，这样才能保证无论多少个import，它们始终都是指向的是export那个变量？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499864,"discussion_content":"是的。\n\n另外，在设计上这符合“谁创建谁负责”的原则。对于export出来的x，所有的importer只能读；如果source发布x的写行为，那么应该另外export一个写方法出来。这类似于在对象中使用get/setter来访问属性，其设计原则和风格是一致的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593399859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180341,"user_name":"Gamehu","can_delete":false,"product_type":"c1","uid":1013894,"ip_address":"","ucode":"C494BA1A00ADBA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/78/86/d5019bb0.jpg","comment_is_top":false,"comment_ctime":1582261744,"is_pvip":false,"replies":[{"id":"70019","content":"你写得有点不通顺，我只能试着答复你了。<br><br>export default会导致当前模块在命名空间中有一个特殊的名字，这个名字被记为`*default*`。由于它不符合命名规则，所以用户代码中既不可能使用，也不能声明出来。这样处理，是当“缺省导出”的名字有唯一性。<br><br>在使用`import xx from ...`的语法时，`xx`与模块的命名空间中的`*default*`其实创建了一个映射。这个映射在引擎内部也就是一次访问的跳转，这个是基于“引用（规范类型）”来实现的。<br><br>你说它是“重命名了default”，宽泛地来说，是对的。因为基本上这与“重命名”的效果很接近。但，本质上来说，“名字访问”是一次跳转，而“（对名字空间中的）映射访问”其实是二次跳转。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1582267438,"ip_address":"","comment_id":180341,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10172196336","product_id":100039701,"comment_content":"所以当都是export default...，以default为名字，但是import xx from ...，其实xx是import 重命名了default是么？不然就没法使用了","like_count":3,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484617,"discussion_content":"你写得有点不通顺，我只能试着答复你了。\n\nexport default会导致当前模块在命名空间中有一个特殊的名字，这个名字被记为`*default*`。由于它不符合命名规则，所以用户代码中既不可能使用，也不能声明出来。这样处理，是当“缺省导出”的名字有唯一性。\n\n在使用`import xx from ...`的语法时，`xx`与模块的命名空间中的`*default*`其实创建了一个映射。这个映射在引擎内部也就是一次访问的跳转，这个是基于“引用（规范类型）”来实现的。\n\n你说它是“重命名了default”，宽泛地来说，是对的。因为基本上这与“重命名”的效果很接近。但，本质上来说，“名字访问”是一次跳转，而“（对名字空间中的）映射访问”其实是二次跳转。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582267438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156481,"user_name":"海绵薇薇","can_delete":false,"product_type":"c1","uid":1601296,"ip_address":"","ucode":"37C7CC2EB81909","user_header":"https://static001.geekbang.org/account/avatar/00/18/6f/10/bfbf81dc.jpg","comment_is_top":false,"comment_ctime":1574901345,"is_pvip":false,"replies":[{"id":"60102","content":"是的。这样没问题。除了缺一咪咪的严谨之外，你的理解是对的。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574909241,"ip_address":"","comment_id":156481,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10164835937","product_id":100039701,"comment_content":"Hello 老师好：）<br><br>函数定义<br><br>var a = function foo() {<br><br>\tconsole.log(foo)<br><br>}<br><br>当前上下文没有标识符foo，但是foo函数内却可以拿到该标识符，所以foo这个标识符应该是声明了，但是不在当前作用域，那么可以简单理解为<br><br>var a = eval(&#39;\\<br>    let foo;\\<br>    foo = function (){\\<br>        console.log(foo)\\<br>    }\\<br>&#39;)<br><br>可以这么理解吗？","like_count":2,"discussions":[{"author":{"id":1659901,"avatar":"https://static001.geekbang.org/account/avatar/00/19/53/fd/db2cac71.jpg","nickname":"红白十万一只","note":"","ucode":"7170636C924D93","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185644,"discussion_content":"var a = function foo() {\n   console.log(foo)\n}\n里面能访问到foo是因为，在foo()这个函数表达式会生成一个辅助变量(只读的)用于保存这个表达式。\n这个只读变量介于全局作用域与foo表达式作用域之间，foo.VO->辅助变量->global","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582637407,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282372,"user_name":"柠柚不加冰","can_delete":false,"product_type":"c1","uid":1666250,"ip_address":"","ucode":"34E67E6C832266","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/EK8FZ09JfUIvohJYwkco846n5DeBHyggeWFlO7ZTicjYZgDuibDG7bZkX4wDdz1yzq7IIvXd7g19ibzouT0GfxkVA/132","comment_is_top":false,"comment_ctime":1615208719,"is_pvip":false,"replies":[{"id":"102539","content":"没有本质上的区别。最终都是处理成了default导出。<br>但是还是有细节上的差异。比如第二种写法中，这个函数其实是有名字的——不是“具名函数”，但它确实有一个称为&#39;f&#39;的名字，这是由赋值语句导致的。例如：<br>&gt; console.log(f.name)<br><br>而你的第一种写法中，函数的这个f.name是无值的。比如：<br>&gt; import x from &#39;source_module.js&#39;;<br>&gt; console.log(x.name)<br>x在这里是通过一个（在js引擎的模块处理机制中的）隐藏的中间引用来访问到原来导出的匿名函数的，而那个函数在source_module.js中没有被const&#47;var&#47;let等赋值过，因此也就没有名字（nodejs中会给它赋一个&quot;default&quot;字符串来作为名字）。<br><br>最后补充一点，在第2种写法中，如果是使用的var或let来声明 f ...，那么你有机会在source_module.js中修改变量值。而像第1种写法那样直接使用export default ...，就没有机会再修改了。<br><br>两种写法都挺好的，也许使用const  f的形式，会给你修改代码时带来一点灵活性吧。就我的使用来说，我是习惯用第一种的，简单就很好。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1615221186,"ip_address":"","comment_id":282372,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5910176015","product_id":100039701,"comment_content":"老师，问一下<br>export default ()=&gt;{……XXX};<br>和<br>const f = ()=&gt;{……XXX};<br>export default f;<br>这两种方式有没有本质区别呢？还有就是在webpack打包后这两种写法的打包后的产物是一样的吗？<br>我在umi官网的Fast Refresh章节看到是推荐用const存一下的写法，这个只是为了开发阶段的模块热替换有保持组件状态的功能，还是说有其他影响？平常开发中推荐用哪一种方式呢？","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516720,"discussion_content":"没有本质上的区别。最终都是处理成了default导出。\n但是还是有细节上的差异。比如第二种写法中，这个函数其实是有名字的——不是“具名函数”，但它确实有一个称为&amp;#39;f&amp;#39;的名字，这是由赋值语句导致的。例如：\n&amp;gt; console.log(f.name)\n\n而你的第一种写法中，函数的这个f.name是无值的。比如：\n&amp;gt; import x from &amp;#39;source_module.js&amp;#39;;\n&amp;gt; console.log(x.name)\nx在这里是通过一个（在js引擎的模块处理机制中的）隐藏的中间引用来访问到原来导出的匿名函数的，而那个函数在source_module.js中没有被const/var/let等赋值过，因此也就没有名字（nodejs中会给它赋一个&amp;quot;default&amp;quot;字符串来作为名字）。\n\n最后补充一点，在第2种写法中，如果是使用的var或let来声明 f ...，那么你有机会在source_module.js中修改变量值。而像第1种写法那样直接使用export default ...，就没有机会再修改了。\n\n两种写法都挺好的，也许使用const  f的形式，会给你修改代码时带来一点灵活性吧。就我的使用来说，我是习惯用第一种的，简单就很好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615221186,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280769,"user_name":"何嘉辉","can_delete":false,"product_type":"c1","uid":2013626,"ip_address":"","ucode":"74CC4CB733599A","user_header":"https://static001.geekbang.org/account/avatar/00/1e/b9/ba/20714875.jpg","comment_is_top":false,"comment_ctime":1614353307,"is_pvip":false,"replies":[{"id":"102081","content":"这个事情，能整整写上好几讲课程了。不过网上相关的文章也挺多，你只是把太多的信息弄乱了，不知道从哪里起头看而已。<br><br>首先，nodejs是支持esmodule规范的，它要求文件用.mjs作扩展名，并且在nodejs的命令行上使用--experimental-modules参数来启动。例如：<br>```<br>&gt; node --experimental-modules 1.mjs<br>```<br><br>这样就可以装载1.mjs，里面可以使用import&#47;export这些es6中的语句了。<br><br>nodejs缺省时（亦即是传统的nodejs方案）是采用commonjs规范的，也就是在.js文件中用require()来加载其它的模块文件。这些模块文件中并不能使用import&#47;export。在nodejs中，如果一个文件“被作为”模块文件装载，那么它就能使用module.exports来向外部宣告（导出）自己的变量或对象等等。<br><br>接下来还需要理解一件事情，就是nodejs其实是对v8引擎的一个封装，真正执行.js或.mjs代码的其实是v8引擎。——这一点我想你很早就知道了。所以，真正实现ecmascript的esmodule规范的是v8引擎，并且事实上ecmascript也只约定了这样一个模块规范。——那么，commonjs的模块，亦即是所谓的require()装载和module.exports这个导出表，又是谁实现的呢？<br><br>关键点就在这里：require()等等与commonjs模块规范相关的，都是nodejs实现的；而.mjs以及import&#47;export等关键字相关的，都是v8引擎按ecmascript实现的。<br><br>接下来说一下所谓的装配过程，由于v8引擎比nodejs要更早（更内核），所以v8引擎所实现的es6 modules以及import&#47;export都是静态装配的，这个过程早于nodejs执行第一行.js&#47;.mjs代码。而nodejs实现的commonjs模块以及它的装载代码，其实是在v8静态加载和代码分析之后，才会执行的。并且，它事实上是在你的（用户的）.js代码之前包裹（wrap）了一层函数，用于“模拟”一个模块环境，进而实现模块的动态装载。这些细节藏得非常深，用户代码很少能感知到它们的存在。不过，要想触摸到这一点也并不难，下面有两行代码，将它保存到文件t.js中：<br><br>```<br>&#47;&#47; save as t.js, try to get nodejs wrap function<br>console.log(arguments[0] === exports);  &#47;&#47; true<br>console.log(arguments.callee.toString()); &#47;&#47; the source code of wrap function<br>```<br><br>然后用命令行执行一下：<br>```<br>&gt; node t.js<br>...<br>```<br><br>Ok...你就看到这个nodejs如何将t.js包裹到一个函数里，然后作为一个“commonjs模块”装载进来的了。而所谓的require()、exports或module对象等等，都是通过函数参数传进来、进而变成了当前（模块的）上下文中可以使用的函数或对象名了。<br><br>而当你理解了这一切，再来看webpack&#47;babel所实现的es6 export&#47;import，其实也就很透彻了。因为采用的技术与上面的一模一样，只不过所实现的wrap function或相关的转换代码要更复杂一些罢了。了解这一点也并不难，在这里（https:&#47;&#47;es6console.com&#47;）去写一行import&#47;export代码，例如：<br>```<br>import { f } from &quot;.&#47;a.js&quot;<br>export var x = 100;<br>```<br><br>然后按下&quot;Transform&quot;按钮，就可以看见它转换后的babel代码，这些基本上就是全部的实现技术和过程了。当然，babel做得更多、非常多的代码，然而确实没有什么新东西了。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1614606849,"ip_address":"","comment_id":280769,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5909320603","product_id":100039701,"comment_content":"老师，我自己搞得有点混淆，帮我看看<br>node,js 自带的<br>commonjs 规范  <br>module.exports 与 require，它的原理是怎样的，与 esmodule 运行过程是否不一样；<br><br>然后前端webpack babel来实现的 es6 export import ,又是怎么回事呢，装配过程是否如课上说的一样，在代码真正被执行前，会先进行模块的装配过程，执行一次顶层代码这样吗？<br>nodejs 与浏览器装配过程的区别是怎样的呢？<br><br>以前面试题提到 import 是在编译时，require 是在运行时，这两者又有什么关系呢","like_count":2,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516203,"discussion_content":"这个事情，能整整写上好几讲课程了。不过网上相关的文章也挺多，你只是把太多的信息弄乱了，不知道从哪里起头看而已。\n\n首先，nodejs是支持esmodule规范的，它要求文件用.mjs作扩展名，并且在nodejs的命令行上使用--experimental-modules参数来启动。例如：\n```\n&amp;gt; node --experimental-modules 1.mjs\n```\n\n这样就可以装载1.mjs，里面可以使用import/export这些es6中的语句了。\n\nnodejs缺省时（亦即是传统的nodejs方案）是采用commonjs规范的，也就是在.js文件中用require()来加载其它的模块文件。这些模块文件中并不能使用import/export。在nodejs中，如果一个文件“被作为”模块文件装载，那么它就能使用module.exports来向外部宣告（导出）自己的变量或对象等等。\n\n接下来还需要理解一件事情，就是nodejs其实是对v8引擎的一个封装，真正执行.js或.mjs代码的其实是v8引擎。——这一点我想你很早就知道了。所以，真正实现ecmascript的esmodule规范的是v8引擎，并且事实上ecmascript也只约定了这样一个模块规范。——那么，commonjs的模块，亦即是所谓的require()装载和module.exports这个导出表，又是谁实现的呢？\n\n关键点就在这里：require()等等与commonjs模块规范相关的，都是nodejs实现的；而.mjs以及import/export等关键字相关的，都是v8引擎按ecmascript实现的。\n\n接下来说一下所谓的装配过程，由于v8引擎比nodejs要更早（更内核），所以v8引擎所实现的es6 modules以及import/export都是静态装配的，这个过程早于nodejs执行第一行.js/.mjs代码。而nodejs实现的commonjs模块以及它的装载代码，其实是在v8静态加载和代码分析之后，才会执行的。并且，它事实上是在你的（用户的）.js代码之前包裹（wrap）了一层函数，用于“模拟”一个模块环境，进而实现模块的动态装载。这些细节藏得非常深，用户代码很少能感知到它们的存在。不过，要想触摸到这一点也并不难，下面有两行代码，将它保存到文件t.js中：\n\n```\n// save as t.js, try to get nodejs wrap function\nconsole.log(arguments[0] === exports);  // true\nconsole.log(arguments.callee.toString()); // the source code of wrap function\n```\n\n然后用命令行执行一下：\n```\n&amp;gt; node t.js\n...\n```\n\nOk...你就看到这个nodejs如何将t.js包裹到一个函数里，然后作为一个“commonjs模块”装载进来的了。而所谓的require()、exports或module对象等等，都是通过函数参数传进来、进而变成了当前（模块的）上下文中可以使用的函数或对象名了。\n\n而当你理解了这一切，再来看webpack/babel所实现的es6 export/import，其实也就很透彻了。因为采用的技术与上面的一模一样，只不过所实现的wrap function或相关的转换代码要更复杂一些罢了。了解这一点也并不难，在这里（https://es6console.com/）去写一行import/export代码，例如：\n```\nimport { f } from &amp;quot;./a.js&amp;quot;\nexport var x = 100;\n```\n\n然后按下&amp;quot;Transform&amp;quot;按钮，就可以看见它转换后的babel代码，这些基本上就是全部的实现技术和过程了。当然，babel做得更多、非常多的代码，然而确实没有什么新东西了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614606849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267300,"user_name":"龙眼","can_delete":false,"product_type":"c1","uid":1383962,"ip_address":"","ucode":"8549009E822429","user_header":"https://static001.geekbang.org/account/avatar/00/15/1e/1a/e748832f.jpg","comment_is_top":false,"comment_ctime":1607674119,"is_pvip":false,"replies":[{"id":"97163","content":"这里有两个问题。第一个是内部的模块表登记的名字事实上是“*default*”，也就是带一对儿“*”号，不过因为排版的缘故，课程里漏掉了这个字符。<br><br>第二个问题是，因为在ECMAScript规范中，函数表达式“执行”的结果是一个闭包，也就是一个实时运算的结果，而闭包是不能被“导出（export）”的。在语言上，必须导出一个函数实例（function instance），而在运行过程中再将它创建成闭包（一个或多个）。因此，出于概念上的必要性，ECMAScript约定在export语句中导出的是“函数声明”，而不是“函数表达式”。两个东西在代码上的写法是一样的，但概念不同，实际的内部行为也是有差异的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1607821505,"ip_address":"","comment_id":267300,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5902641415","product_id":100039701,"comment_content":"我的理解就是，export default function(){}，你导出的不是function() {}，而是名为default的函数。","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511587,"discussion_content":"这里有两个问题。第一个是内部的模块表登记的名字事实上是“*default*”，也就是带一对儿“*”号，不过因为排版的缘故，课程里漏掉了这个字符。\n\n第二个问题是，因为在ECMAScript规范中，函数表达式“执行”的结果是一个闭包，也就是一个实时运算的结果，而闭包是不能被“导出（export）”的。在语言上，必须导出一个函数实例（function instance），而在运行过程中再将它创建成闭包（一个或多个）。因此，出于概念上的必要性，ECMAScript约定在export语句中导出的是“函数声明”，而不是“函数表达式”。两个东西在代码上的写法是一样的，但概念不同，实际的内部行为也是有差异的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1607821505,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":252959,"user_name":"随波逐狼","can_delete":false,"product_type":"c1","uid":1965362,"ip_address":"","ucode":"C4DB7B6C734B25","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fd/32/b905ea74.jpg","comment_is_top":false,"comment_ctime":1602549066,"is_pvip":false,"replies":[{"id":"92572","content":"这里应该是编辑将原文的markdown转成网页时出的问题。强制在当前作用域中登记的“特殊的名字”是“*default*”，前后各有一个`*`字符，这是`var default`这样的语句声明不出来的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1602746243,"ip_address":"","comment_id":252959,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5897516362","product_id":100039701,"comment_content":"导出一个匿名函数，或者一个具名的函数的时候，这两种情况下是不同的。但无论它是否具名，它们都是不可能在当前作用域中绑定给default这个名字，作为这个名字对应的值的。<br>这段处理逻辑被添加在语法：<br>ExportDeclaration: export  default  AnonymousFunctionDefinition;<br>NOTE: ECMAScript 是将这里导出的对象称为 _Expression_&#47;AssignmentExpression，这里所谓 _AnonymousFunctionDefinition_ 则是其中 _AssignmentExpression_ 的一个具体实例。<br>的执行（Evaluation）处理过程中。也就是说当执行这行声明时，如果后面的表达式是匿名函数声明，那么它将强制在当前作用域中登记为“default”这样一个特殊的名字，并且在执行时绑定该匿名函数。所以，尽管语义上我们需要将它登记为类似var default ...所声明的名字“default”，但事实上它被处理成了一个不可访问的中间名字，然后影射给该模块的“某个名字表”。这段话是否矛盾了？上面说不可能在当前作用域绑定，下面说又可以给他绑定，啥情况？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":506927,"discussion_content":"这里应该是编辑将原文的markdown转成网页时出的问题。强制在当前作用域中登记的“特殊的名字”是“*default*”，前后各有一个`*`字符，这是`var default`这样的语句声明不出来的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602746243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":215255,"user_name":"HoSalt","can_delete":false,"product_type":"c1","uid":1156074,"ip_address":"","ucode":"610B03E2A002D1","user_header":"https://static001.geekbang.org/account/avatar/00/11/a3/ea/53333dd5.jpg","comment_is_top":false,"comment_ctime":1588942147,"is_pvip":false,"replies":[{"id":"79734","content":"export影响的是Module loader的语法分析，而不是当前的执行上下文（以及词法环境）。<br>import是Module loader在语法分析阶段对当前模块的（静态的）词法环境进行影响的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1588995690,"ip_address":"","comment_id":215255,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5883909443","product_id":100039701,"comment_content":"「导出“（其它模块的）名字”<br>export ... from ...;」<br>老师，导出其它模块的形式，为什么在当前模块无法使用这个变量?","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494373,"discussion_content":"export影响的是Module loader的语法分析，而不是当前的执行上下文（以及词法环境）。\nimport是Module loader在语法分析阶段对当前模块的（静态的）词法环境进行影响的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588995690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156945,"user_name":"穿秋裤的男孩","can_delete":false,"product_type":"c1","uid":1748640,"ip_address":"","ucode":"D0F48C66377893","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","comment_is_top":false,"comment_ctime":1574999562,"is_pvip":false,"replies":[{"id":"60438","content":"不知道你的引擎的情况，我这里显示会是default。<br><br>```<br>&#47;&#47; f.mjs<br>export default function() {}<br><br>&#47;&#47; t.mjs<br>import f from &#39;.&#47;f.mjs&#39;;<br>console.log(f.name);<br><br>&#47;&#47; test<br>&gt; node --experimental-modules t.mjs<br>default<br>```<br>","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1575224538,"ip_address":"","comment_id":156945,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5869966858","product_id":100039701,"comment_content":"老师，下面这句话我不是很懂，希望给解惑：<br><br>------<br>因此，该匿名函数初始化时才会绑定给它左侧的名字“default”，这会导致import f from ...之后访问f.name值会得到“default”这个名字。<br>------<br>根据这句话我实际运行了下代码，如下：<br>&#47;&#47; a.js<br>export default function() {};<br><br>&#47;&#47; b.js<br>import a from &#39;.&#47;a.js&#39;;<br>console.log(a.name); &#47;&#47; 打印为空字符串“”;<br><br>&#47;&#47; 疑惑点<br>按照您的解释，这边不是应该打印default吗？很奇怪","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476278,"discussion_content":"不知道你的引擎的情况，我这里显示会是default。\n\n```\n// f.mjs\nexport default function() {}\n\n// t.mjs\nimport f from &amp;#39;./f.mjs&amp;#39;;\nconsole.log(f.name);\n\n// test\n&amp;gt; node --experimental-modules t.mjs\ndefault\n```\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575224538,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1748640,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/ae/a0/707350ef.jpg","nickname":"穿秋裤的男孩","note":"","ucode":"D0F48C66377893","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":68968,"discussion_content":"我这边是在谷歌浏览器中执行的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575248661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342677,"user_name":"波哥","can_delete":false,"product_type":"c1","uid":1998183,"ip_address":"","ucode":"373D587C2BD8AB","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIoYNYqumlObe08Gjq5PoHKn1gnKhoajZ1sc9AQ3xdJuXhnnLQ9HwPxTFSDo8G7YdL2Pk1rkiaibbNg/132","comment_is_top":false,"comment_ctime":1650416619,"is_pvip":false,"replies":[{"id":"125282","content":"1. 标识符的产生和声明是在词法分析阶段。但绑定不是。<br><br>2. 标识符——亦即是名字是在环境（块作用域在运行环境中的映像）创建时被登记到环境中的，这时它称为“未初始化的（uninitialized）”。<br><br>3. let&#47;const声明的名字是在“执行到”声明语句所在的代码位置时，才执行“绑定”这个操作的，亦即是说它们的“声明”在执行期的语义——或执行效果——就是绑定。一个名字绑定了值，才称为“初始化的（initialized）”。<br><br>4. var声明的名字是在环境创建时就初始绑定了一个undefined值，所以它与let&#47;const不同，它在环境创建完、登记了名字之后就立即绑定了值（initialized mutable binding）。var声明的名字在“执行到声明语句之前”就可以访问的原因也在于此。<br><br>5. “创建和初始化环境”发生在执行期——不是在词法分析阶段。但是它是在第一行用户代码之前发生的。","user_name":"作者回复","user_name_real":"编辑","uid":"1521669","ctime":1650557737,"ip_address":"","comment_id":342677,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1650416619","product_id":100039701,"comment_content":"周老师，我有个疑问，标识符的产生和声明是在词法分析阶段，而值的绑定是在代码运行阶段嘛？还是，两个过程都在词法分析阶段？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565945,"discussion_content":"1. 标识符的产生和声明是在词法分析阶段。但绑定不是。\n\n2. 标识符——亦即是名字是在环境（块作用域在运行环境中的映像）创建时被登记到环境中的，这时它称为“未初始化的（uninitialized）”。\n\n3. let/const声明的名字是在“执行到”声明语句所在的代码位置时，才执行“绑定”这个操作的，亦即是说它们的“声明”在执行期的语义——或执行效果——就是绑定。一个名字绑定了值，才称为“初始化的（initialized）”。\n\n4. var声明的名字是在环境创建时就初始绑定了一个undefined值，所以它与let/const不同，它在环境创建完、登记了名字之后就立即绑定了值（initialized mutable binding）。var声明的名字在“执行到声明语句之前”就可以访问的原因也在于此。\n\n5. “创建和初始化环境”发生在执行期——不是在词法分析阶段。但是它是在第一行用户代码之前发生的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650557737,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":285974,"user_name":"周星星","can_delete":false,"product_type":"c1","uid":1387107,"ip_address":"","ucode":"DCDC36580EA643","user_header":"https://static001.geekbang.org/account/avatar/00/15/2a/63/4d06890c.jpg","comment_is_top":false,"comment_ctime":1617090688,"is_pvip":false,"replies":[{"id":"103905","content":"这个是课程中排版错误导致的误会。匿名函数定义在内部被声明的名字是`*default*`，注意前后有个`*`号，这个被极客时间课程排版给吞掉了，所以……<br><br>由于这个名字是不合JS的命名规范的，因此它也不会被显示出来。当使用import来导入这个函数时，也会在它作为一个导入变量时被赋予一个函数名（function.name），因此不必过分在意这个名字的使用。<br><br>这一段主要是说明匿名函数定义会用一个“特殊的（不合命名规范的）”名字被登记——它需要一个登记名字，而又不与其它被导出的名字潜在冲突。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1617247573,"ip_address":"","comment_id":285974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1617090688","product_id":100039701,"comment_content":"因此，该匿名函数初始化时才会绑定给它左侧的名字“default”，这会导致import f from ...之后访问f.name值会得到“default”这个名字。<br><br>在导出匿名函数定义，我没有在导入的js中打印出来 &#39;default&#39;，而是空字符串，老师，这里是为什么啊，有其他同学遇到过吗","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":517837,"discussion_content":"这个是课程中排版错误导致的误会。匿名函数定义在内部被声明的名字是`*default*`，注意前后有个`*`号，这个被极客时间课程排版给吞掉了，所以……\n\n由于这个名字是不合JS的命名规范的，因此它也不会被显示出来。当使用import来导入这个函数时，也会在它作为一个导入变量时被赋予一个函数名（function.name），因此不必过分在意这个名字的使用。\n\n这一段主要是说明匿名函数定义会用一个“特殊的（不合命名规范的）”名字被登记——它需要一个登记名字，而又不与其它被导出的名字潜在冲突。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617247573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":283080,"user_name":"Wise","can_delete":false,"product_type":"c1","uid":1689268,"ip_address":"","ucode":"A1915E54C26948","user_header":"https://static001.geekbang.org/account/avatar/00/19/c6/b4/e80a4fc8.jpg","comment_is_top":false,"comment_ctime":1615540494,"is_pvip":false,"replies":[{"id":"102746","content":"Oh...<br><br>又读了一下上下文，这么说起来是容易有误会哈。你说的没错，确实只有6种声明的情况。仅对于这一行export {x, y, z ...}来说，注释中的意思是指：<br><br>&#47;&#47; 导出“（已经声明的）名字”","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1615651996,"ip_address":"","comment_id":283080,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1615540494","product_id":100039701,"comment_content":"老师：export {x, y, z, ...}; 为什么归为导出声明的名字， 声明语句不就有那六种情况吗？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":516928,"discussion_content":"Oh...\n\n又读了一下上下文，这么说起来是容易有误会哈。你说的没错，确实只有6种声明的情况。仅对于这一行export {x, y, z ...}来说，注释中的意思是指：\n\n// 导出“（已经声明的）名字”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615651996,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":282371,"user_name":"柠柚不加冰","can_delete":false,"product_type":"c1","uid":1666250,"ip_address":"","ucode":"34E67E6C832266","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/EK8FZ09JfUIvohJYwkco846n5DeBHyggeWFlO7ZTicjYZgDuibDG7bZkX4wDdz1yzq7IIvXd7g19ibzouT0GfxkVA/132","comment_is_top":false,"comment_ctime":1615208208,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615208208","product_id":100039701,"comment_content":"老师，那export default ()=&gt;{……XXX}和","like_count":0},{"had_liked":false,"id":231208,"user_name":"Sixty","can_delete":false,"product_type":"c1","uid":1390756,"ip_address":"","ucode":"F8C7FB86C50608","user_header":"https://static001.geekbang.org/account/avatar/00/15/38/a4/608e86ff.jpg","comment_is_top":false,"comment_ctime":1593608588,"is_pvip":false,"replies":[{"id":"85381","content":"关于顶层代码，你看一看这一讲的其它同学留言和回复，有大致讲到。<br>至于第2个问题，你学到第11~12讲的时候，会有一个完整的回顾来解释之。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1593634139,"ip_address":"","comment_id":231208,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593608588","product_id":100039701,"comment_content":"请问老师，何为顶层代码何为非顶层代码啊？它们分别在什么时候被执行呢？一段js代码被v8引擎执行这个过程中到底做了些什么事情呢？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500202,"discussion_content":"关于顶层代码，你看一看这一讲的其它同学留言和回复，有大致讲到。\n至于第2个问题，你学到第11~12讲的时候，会有一个完整的回顾来解释之。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593634139,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211976,"user_name":"香瓜","can_delete":false,"product_type":"c1","uid":1749354,"ip_address":"","ucode":"0C728853739313","user_header":"https://static001.geekbang.org/account/avatar/00/1a/b1/6a/7bd83c94.jpg","comment_is_top":false,"comment_ctime":1588041951,"is_pvip":false,"replies":[{"id":"78773","content":"是的。其实我真讲的是语言，而不仅仅是JavaScript","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1588044981,"ip_address":"","comment_id":211976,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588041951","product_id":100039701,"comment_content":"老师，是站在语言的角度来讲解的吗？就是老师刚开始说的，学会学习一门语言的通路，而不仅仅是javascript","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493403,"discussion_content":"是的。其实我真讲的是语言，而不仅仅是JavaScript","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588044981,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186238,"user_name":"会飞小超人","can_delete":false,"product_type":"c1","uid":1132845,"ip_address":"","ucode":"04558BEAF5DD17","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/2d/fd085556.jpg","comment_is_top":false,"comment_ctime":1583806147,"is_pvip":false,"replies":[{"id":"72013","content":"这个是正常的export语法呀，它导出x,y,z等等这些“已经声明过”的名字。语法说明在这里：<br>https:&#47;&#47;tc39.es&#47;ecma262&#47;#prod-NamedExports<br><br>不过，导出不是“声明&#47;声明语句”，导入才是。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1583852984,"ip_address":"","comment_id":186238,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583806147","product_id":100039701,"comment_content":"&#47;&#47; 导出“（声明的）名字”<br>export x ...;<br>export function x() ...<br>export class x ...<br>export {x, y, z, ...};<br><br>老师，我不太理解为什么最后一句话export{x,y,z,...}也是声明呢？","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486688,"discussion_content":"这个是正常的export语法呀，它导出x,y,z等等这些“已经声明过”的名字。语法说明在这里：\nhttps://tc39.es/ecma262/#prod-NamedExports\n\n不过，导出不是“声明/声明语句”，导入才是。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583852984,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":162994,"user_name":"晓小东","can_delete":false,"product_type":"c1","uid":1194643,"ip_address":"","ucode":"93F9462EAAA63C","user_header":"https://static001.geekbang.org/account/avatar/00/12/3a/93/d7be8a1a.jpg","comment_is_top":false,"comment_ctime":1576638562,"is_pvip":true,"replies":[{"id":"61930","content":"他这个写法是错误的。细节上有不少错误~ :(<br><br>ECMAScript确实比较难读（是真的难），我也许今后会出一个专题来讲这个……但这个真不保证呵，因为想了解这个的人太少太少了。<br><br>关于你的第一个问题，你打开ECMAScript规范，查找一下VariableEnvironment这个关键词，看一下它在哪些地方用的，怎么用的，就可以明白了。——之所以这么讲，是因为它只有24处，很少，通读一下也没什么，反倒有利于你熟悉文档。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1576648678,"ip_address":"","comment_id":162994,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1576638562","product_id":100039701,"comment_content":"1. 老师问你一个问题， 我在看别人博客发现函数声明怎么放入的词法环境中（multiply 标识）不是说函数声明 是varDecls， 应该放入 VariableEnvironment， 在执行上下文创建中， 如下：（是正确的的吗）<br>2. 怎么解读ECMA规范（整理架构比如目录结构）， 本来想查阅文档来验证， 但不知所措，后期可不可以教教我们怎么翻阅ECMA规范文档， 来查阅某个东西。<br><br>GlobalExectionContext = {<br><br>  ThisBinding: &lt;Global Object&gt;,<br><br>  LexicalEnvironment: {  <br>    EnvironmentRecord: {  <br>      Type: &quot;Object&quot;,  <br>      &#47;&#47; 标识符绑定在这里  <br>      a: &lt; uninitialized &gt;,  <br>      b: &lt; uninitialized &gt;,  <br>      multiply: &lt; func &gt;  <br>    }  <br>    outer: &lt;null&gt;  <br>  },<br><br>  VariableEnvironment: {  <br>    EnvironmentRecord: {  <br>      Type: &quot;Object&quot;,  <br>      &#47;&#47; 标识符绑定在这里  <br>      c: undefined,  <br>    }  <br>    outer: &lt;null&gt;  <br>  }  <br>}","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478204,"discussion_content":"他这个写法是错误的。细节上有不少错误~ :(\n\nECMAScript确实比较难读（是真的难），我也许今后会出一个专题来讲这个……但这个真不保证呵，因为想了解这个的人太少太少了。\n\n关于你的第一个问题，你打开ECMAScript规范，查找一下VariableEnvironment这个关键词，看一下它在哪些地方用的，怎么用的，就可以明白了。——之所以这么讲，是因为它只有24处，很少，通读一下也没什么，反倒有利于你熟悉文档。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576648678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1194643,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/93/d7be8a1a.jpg","nickname":"晓小东","note":"","ucode":"93F9462EAAA63C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":88347,"discussion_content":"谢谢老师，本来我想函数声明标识符放入词法环境，来验证函数声明提升优先级高于var ，因为标识符的查找先从词法环境中查找，再到变量环境，再到上级作用域，从而实现声明的优先级。老师对于函数声明的优先级，你怎么看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576706607,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153395,"user_name":"陆昱嘉","can_delete":false,"product_type":"c1","uid":1389114,"ip_address":"","ucode":"A5E26B3F9A5A8C","user_header":"https://static001.geekbang.org/account/avatar/00/15/32/3a/ead5611e.jpg","comment_is_top":false,"comment_ctime":1574229799,"is_pvip":false,"replies":[{"id":"59078","content":"这个问题请参考一下在评论区给Marvin的回复就好了。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574304467,"ip_address":"","comment_id":153395,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574229799","product_id":100039701,"comment_content":"“声明（6种）”的目的都是具名，“函数声明（Function Declaration）”必须是具名的才能导出。<br>既然这样，不就是这个函数声明function(){}具名导出给default这个名了吗？<br>现在又说<br>“它并不是导出了一个匿名函数表达式，而是导出了一个匿名函数定义。”<br>不是函数表达式理解，为什么非说导出“函数定义”而不是“函数声明”呢？<br>函数声明，函数表达式，和函数定义之间的区别联系是什么，搞晕了。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475149,"discussion_content":"这个问题请参考一下在评论区给Marvin的回复就好了。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574304467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152868,"user_name":"westfall","can_delete":false,"product_type":"c1","uid":1632773,"ip_address":"","ucode":"F3F5CB7DF695FC","user_header":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","comment_is_top":false,"comment_ctime":1574091836,"is_pvip":false,"replies":[{"id":"58764","content":"第一个也不是“（具名）函数表达式”。因为如果它是表达式（expression），那么它的执行结果就是一个实例，而实例是无法导出的。只有它是一个“函数定义”，它才能在“静态语法分析之后、代码执行之前”被导出。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574131710,"ip_address":"","comment_id":152868,"utype":1}],"discussion_count":7,"race_medal":0,"score":"1574091836","product_id":100039701,"comment_content":"export default function x() { }<br>导出一个具名函数表达式<br>export default function() { }<br>不是导出一个匿名函数表达式，而是一个匿名函数定义","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474969,"discussion_content":"第一个也不是“（具名）函数表达式”。因为如果它是表达式（expression），那么它的执行结果就是一个实例，而实例是无法导出的。只有它是一个“函数定义”，它才能在“静态语法分析之后、代码执行之前”被导出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574131710,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1632773,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","nickname":"westfall","note":"","ucode":"F3F5CB7DF695FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53120,"discussion_content":"那这两行的区别就只有一个函数名是 x， 一个是 default 吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574135090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1632773,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","nickname":"westfall","note":"","ucode":"F3F5CB7DF695FC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54611,"discussion_content":"其实执行的结果两个的函数名都是default~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574304800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53120,"ip_address":""},"score":54611,"extra":""},{"author":{"id":1632773,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","nickname":"westfall","note":"","ucode":"F3F5CB7DF695FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":54653,"discussion_content":"那么它们的区别是什么呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574307925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54611,"ip_address":""},"score":54653,"extra":""},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1632773,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","nickname":"westfall","note":"","ucode":"F3F5CB7DF695FC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55408,"discussion_content":"在第一个函数内能访问到名字~ 这可能是唯一区别了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574359082,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54653,"ip_address":""},"score":55408,"extra":""}]}]},{"had_liked":false,"id":152834,"user_name":"Wiggle Wiggle","can_delete":false,"product_type":"c1","uid":1036052,"ip_address":"","ucode":"EFE746551BA998","user_header":"https://static001.geekbang.org/account/avatar/00/0f/cf/14/384258ba.jpg","comment_is_top":false,"comment_ctime":1574085751,"is_pvip":false,"replies":[{"id":"58765","content":"这个细述起来有点复杂，因为有好些细节的地方都能被称为“顶层的（代码）”。简而言之，你把一个.js文件中所有在全局的声明语句去掉，剩下的就是顶层代码了。<br><br>顶层这个概念其实挺重要的，因为tc39现在有一份提案在推，就是top-level await。这个在引擎实现的层面上，以及应用的层面上都挺关键的。","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574131877,"ip_address":"","comment_id":152834,"utype":1}],"discussion_count":6,"race_medal":0,"score":"1574085751","product_id":100039701,"comment_content":"文中多次出现“最顶层代码”，那什么是最顶层代码呢？","like_count":1,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474957,"discussion_content":"这个细述起来有点复杂，因为有好些细节的地方都能被称为“顶层的（代码）”。简而言之，你把一个.js文件中所有在全局的声明语句去掉，剩下的就是顶层代码了。\n\n顶层这个概念其实挺重要的，因为tc39现在有一份提案在推，就是top-level await。这个在引擎实现的层面上，以及应用的层面上都挺关键的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574131877,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1632773,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","nickname":"westfall","note":"","ucode":"F3F5CB7DF695FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52877,"discussion_content":"我的理解是，比如，a文件依赖了b文件，b文件依赖了c文件，c文件没有依赖，那c文件就是顶层代码。c文件会先执行，c文件执行完了，b文件变成了顶层代码，以此类推","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574089597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1632773,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","nickname":"westfall","note":"","ucode":"F3F5CB7DF695FC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54616,"discussion_content":"不是这个意思。所有的文件模块的最外层（非函数和非声明的部分）都是顶层。在一个函数内部（以及其它块作用域的语句）中，这个规则也是可用的，就是块中的除了子级函数和子级块之外的，都是顶层……\n\n因为JavaScript要扫描所谓的“顶层”，来查找那些变量声明和词法声明之间的冲突关系。以及要把子函数声明放到函数的varDecls中。——所以，其实“顶层”这个东西，以及它怎么计算其实还是挺复杂的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574304992,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":52877,"ip_address":""},"score":54616,"extra":""},{"author":{"id":1632773,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","nickname":"westfall","note":"","ucode":"F3F5CB7DF695FC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":54647,"discussion_content":"感谢指正。感觉你的文笔风格跟作者挺像的，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574307761,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54616,"ip_address":""},"score":54647,"extra":""},{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1632773,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ea/05/b164dc15.jpg","nickname":"westfall","note":"","ucode":"F3F5CB7DF695FC","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55405,"discussion_content":"你应该相信感觉🤣","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574358954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54647,"ip_address":""},"score":55405,"extra":""}]}]},{"had_liked":false,"id":152797,"user_name":"可可","can_delete":false,"product_type":"c1","uid":1219666,"ip_address":"","ucode":"FD9516F133E134","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q3auHgzwzM7lTQQeIDIXrU4u1wsydv5tWaaz4JDwVmHeibOWpw05QDSk57rBJFEQRPiavywZjiafSdYTjk0hFWUGw/132","comment_is_top":false,"comment_ctime":1574081564,"is_pvip":false,"replies":[{"id":"58760","content":"呵呵，其实真讲JavaScript的地方并不特别的多。就好象讲数据结构总需要一门基础语言一样，那个基础语言其实不重要，重要的是数据结构。<br>除了简单的语法和一些惯例之外，这门课真在讲“JavaScipt怎么用”的地方并不多。^^.","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574131398,"ip_address":"","comment_id":152797,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574081564","product_id":100039701,"comment_content":"没有JavaScript基础的人表示，听起来很吃力啊，估计要先学学JavaScript，然后在多读几遍本专栏才行。","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474941,"discussion_content":"呵呵，其实真讲JavaScript的地方并不特别的多。就好象讲数据结构总需要一门基础语言一样，那个基础语言其实不重要，重要的是数据结构。\n除了简单的语法和一些惯例之外，这门课真在讲“JavaScipt怎么用”的地方并不多。^^.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574131398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1386753,"avatar":"https://static001.geekbang.org/account/avatar/00/15/29/01/20caec2f.jpg","nickname":"Yeon","note":"","ucode":"ED3549F94EB36E","race_medal":0,"user_type":4,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53081,"discussion_content":"说的是啊，专栏简介里也说了，得有编程经验而且必须接触过JavaScript才行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574129750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152759,"user_name":"2102","can_delete":false,"product_type":"c1","uid":1070298,"ip_address":"","ucode":"A67068F2A3157E","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/da/e2e5ddf7.jpg","comment_is_top":false,"comment_ctime":1574076232,"is_pvip":false,"replies":[{"id":"58759","content":"“并没有执行表达式”<br>+1","user_name":"作者回复","user_name_real":"Aiming","uid":"1521669","ctime":1574131306,"ip_address":"","comment_id":152759,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574076232","product_id":100039701,"comment_content":"说白了export就是将代码导出，并没有执行表达式。js中执行是要加()","like_count":0,"discussions":[{"author":{"id":1521669,"avatar":"https://static001.geekbang.org/account/avatar/00/17/38/05/7beecd5d.jpg","nickname":"Aiming","note":"","ucode":"66292B32F9960A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474928,"discussion_content":"“并没有执行表达式”\n+1","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574131306,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1361489,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c6/51/44791c01.jpg","nickname":"🇧🇪 Hazard🇦🇷","note":"","ucode":"E2C44FAFDFAA88","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":239148,"discussion_content":"请问，最后说  js中执行是要加() 是什么意思，不加 () 到了执行阶段不都要执行吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587278532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}