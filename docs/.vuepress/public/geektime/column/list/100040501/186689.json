{"id":186689,"title":"19 | thread和future：领略异步中的未来","content":"<p>你好，我是吴咏炜。</p><p>编译期的烧脑我们先告个段落，今天我们开始讲一个全新的话题——并发（concurrency）。</p><h2>为什么要使用并发编程？</h2><p>在本世纪初之前，大部分开发人员不常需要关心并发编程；用到的时候，也多半只是在单处理器上执行一些后台任务而已。只有少数为昂贵的工作站或服务器进行开发的程序员，才会需要为并发性能而烦恼。原因无他，程序员们享受着摩尔定律带来的免费性能提升，而高速的 Intel 单 CPU 是性价比最高的系统架构，可到了 2003 年左右，大家骤然发现，“免费午餐”已经结束了 <span class=\"orange\">[1]</span>。主频的提升停滞了：在 2001 年，Intel 已经有了主频 2.0 GHz 的 CPU，而 18 年后，我现在正在使用的电脑，主频也仍然只是 2.5 GHz，虽然从单核变成了四核。服务器、台式机、笔记本、移动设备的处理器都转向了多核，计算要求则从单线程变成了多线程甚至异构——不仅要使用 CPU，还得使用 GPU。</p><p>如果你不熟悉进程和线程的话，我们就先来简单介绍一下它们的关系。我们编译完执行的 C++ 程序，那在操作系统看来就是一个进程了。而每个进程里可以有一个或多个线程：</p><ul>\n<li>每个进程有自己的独立地址空间，不与其他进程分享；一个进程里可以有多个线程，彼此共享同一个地址空间。</li>\n<li>堆内存、文件、套接字等资源都归进程管理，同一个进程里的多个线程可以共享使用。每个进程占用的内存和其他资源，会在进程退出或被杀死时返回给操作系统。</li>\n<li>并发应用开发可以用多进程或多线程的方式。多线程由于可以共享资源，效率较高；反之，多进程（默认）不共享地址空间和资源，开发较为麻烦，在需要共享数据时效率也较低。但多进程安全性较好，在某一个进程出问题时，其他进程一般不受影响；而在多线程的情况下，一个线程执行了非法操作会导致整个进程退出。</li>\n</ul><!-- [[[read_end]]] --><p>我们讲 C++ 里的并发，主要讲的就是多线程。它对开发人员的挑战是全方位的。从纯逻辑的角度，并发的思维模式就比单线程更为困难。在其之上，我们还得加上：</p><ul>\n<li>编译器和处理器的重排问题</li>\n<li>原子操作和数据竞争</li>\n<li>互斥锁和死锁问题</li>\n<li>无锁算法</li>\n<li>条件变量</li>\n<li>信号量</li>\n<li>……</li>\n</ul><p>即使对于专家，并发编程都是困难的，上面列举的也只是部分难点而已。对于并发的基本挑战，Herb Sutter 在他的 Effective Concurrency 专栏给出了一个较为全面的概述 <span class=\"orange\">[2]</span>。要对 C++ 的并发编程有全面的了解，则可以阅读曼宁出版的 <em>C++ Concurrency in Action</em>（有中文版，但翻译口碑不好）<span class=\"orange\">[3]</span>。而我们今天主要要介绍的，则是并发编程的基本概念，包括传统的多线程开发，以及高层抽象 future（姑且译为未来量）的用法。</p><h2>基于 thread 的多线程开发</h2><p>我们先来看一个使用 <code>thread</code> 线程类 <span class=\"orange\">[4]</span> 的简单例子：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nmutex output_lock;\n\nvoid func(const char* name)\n{\n  this_thread::sleep_for(100ms);\n  lock_guard&lt;mutex&gt; guard{\n    output_lock};\n  cout &lt;&lt; \"I am thread \" &lt;&lt; name\n       &lt;&lt; '\\n';\n}\n\nint main()\n{\n  thread t1{func, \"A\"};\n  thread t2{func, \"B\"};\n  t1.join();\n  t2.join();\n}\n</code></pre><p>这是某次执行的结果：</p><blockquote>\n<p><code>I am thread B</code><br>\n<code>I am thread A</code></p>\n</blockquote><p><strong>一个平台细节：</strong>在 Linux 上编译线程相关的代码都需要加上 <code>-pthread</code> 命令行参数。Windows 和 macOS 上则不需要。</p><p>代码是相当直截了当的，执行了下列操作：</p><ol>\n<li>传递参数，起两个线程</li>\n<li>两个线程分别休眠 100 毫秒</li>\n<li>使用互斥量（mutex）锁定 <code>cout</code> ，然后输出一行信息</li>\n<li>主线程等待这两个线程退出后程序结束</li>\n</ol><p>以下几个地方可能需要稍加留意一下：</p><ul>\n<li><code>thread</code> 的构造函数的第一个参数是函数（对象），后面跟的是这个函数所需的参数。</li>\n<li><code>thread</code> 要求在析构之前要么 <code>join</code>（阻塞直到线程退出），要么 <code>detach</code>（放弃对线程的管理），否则程序会异常退出。</li>\n<li><code>sleep_for</code> 是 <code>this_thread</code> 名空间下的一个自由函数，表示当前线程休眠指定的时间。</li>\n<li>如果没有 <code>output_lock</code> 的同步，输出通常会交错到一起。</li>\n</ul><p>建议你自己运行一下，并尝试删除 <code>lock_guard</code> 和 <code>join</code> 的后果。</p><p><code>thread</code> 不能在析构时自动 <code>join</code> 有点不那么自然，这可以算是一个缺陷吧。在 C++20 的 <code>jthread</code> <span class=\"orange\">[5]</span> 到来之前，我们只能自己小小封装一下了。比如：</p><pre><code class=\"language-c++\">class scoped_thread {\npublic:\n  template &lt;typename... Arg&gt;\n  scoped_thread(Arg&amp;&amp;... arg)\n    : thread_(\n        std::forward&lt;Arg&gt;(arg)...)\n  {}\n  scoped_thread(\n    scoped_thread&amp;&amp; other)\n    : thread_(\n        std::move(other.thread_))\n  {}\n  scoped_thread(\n    const scoped_thread&amp;) = delete;\n  ~scoped_thread()\n  {\n    if (thread_.joinable()) {\n      thread_.join();\n    }\n  }\n\nprivate:\n  thread thread_;\n};\n</code></pre><p>这个实现里有下面几点需要注意：</p><ol>\n<li>我们使用了可变模板和完美转发来构造 <code>thread</code> 对象。</li>\n<li><code>thread</code> 不能拷贝，但可以移动；我们也类似地实现了移动构造函数。</li>\n<li>只有 joinable（已经 <code>join</code> 的、已经 <code>detach</code> 的或者空的线程对象都不满足 joinable）的 <code>thread</code> 才可以对其调用 <code>join</code> 成员函数，否则会引发异常。</li>\n</ol><p>使用这个 <code>scoped_thread</code> 类的话，我们就可以把我们的 <code>main</code> 函数改写成：</p><pre><code class=\"language-c++\">int main()\n{\n  scoped_thread t1{func, \"A\"};\n  scoped_thread t2{func, \"B\"};\n}\n</code></pre><p>这虽然是个微不足道的小例子，但我们已经可以发现：</p><ul>\n<li>执行顺序不可预期，或者说不具有决定性。</li>\n<li>如果没有互斥量的帮助，我们连完整地输出一整行信息都成问题。</li>\n</ul><p>我们下面就来讨论一下互斥量。</p><h3>mutex</h3><p>互斥量的基本语义是，一个互斥量只能被一个线程锁定，用来保护某个代码块在同一时间只能被一个线程执行。在前面那个多线程的例子里，我们就需要限制同时只有一个线程在使用 <code>cout</code>，否则输出就会错乱。</p><p>目前的 C++ 标准中，事实上提供了不止一个互斥量类。我们先看最简单、也最常用的 <code>mutex</code> 类 <span class=\"orange\">[6]</span>。<code>mutex</code> 只可默认构造，不可拷贝（或移动），不可赋值，主要提供的方法是：</p><ul>\n<li><code>lock</code>：锁定，锁已经被其他线程获得时则阻塞执行</li>\n<li><code>try_lock</code>：尝试锁定，获得锁返回 <code>true</code>，在锁被其他线程获得时返回 <code>false</code></li>\n<li><code>unlock</code>：解除锁定（只允许在已获得锁时调用）</li>\n</ul><p>你可能会想到，如果一个线程已经锁定了某个互斥量，再次锁定会发生什么？对于 <code>mutex</code>，回答是危险的未定义行为。你不应该这么做。如果有特殊需要可能在同一线程对同一个互斥量多次加锁，就需要用到递归锁 <code>recursive_mutex</code> 了 <span class=\"orange\">[7]</span>。除了允许同一线程可以无阻塞地多次加锁外（也必须有对应数量的解锁操作），<code>recursive_mutex</code> 的其他行为和 <code>mutex</code> 一致。</p><p>除了 <code>mutex</code> 和 <code>recursive_mutex</code>，C++ 标准库还提供了：</p><ul>\n<li><code>timed_mutex</code>：允许锁定超时的互斥量</li>\n<li><code>recursive_timed_mutex</code>：允许锁定超时的递归互斥量</li>\n<li><code>shared_mutex</code>：允许共享和独占两种获得方式的互斥量</li>\n<li><code>shared_timed_mutex</code>：允许共享和独占两种获得方式的、允许锁定超时的互斥量</li>\n</ul><p>这些我们就不做讲解了，需要的请自行查看参考资料 <span class=\"orange\">[8]</span>。另外，&lt;mutex&gt; 头文件中也定义了锁的 RAII 包装类，如我们上面用过的 <code>lock_guard</code>。为了避免手动加锁、解锁的麻烦，以及在有异常或出错返回时发生漏解锁，我们一般应当使用 <code>lock_guard</code>，而不是手工调用互斥量的 <code>lock</code> 和 <code>unlock</code> 方法。C++ 里另外还有 <code>unique_lock</code>（C++11）和 <code>scoped_lock</code>（C++17），提供了更多的功能，你在有更复杂的需求时应该检查一下它们是否合用。</p><h3>执行任务，返回数据</h3><p>如果我们要在某个线程执行一些后台任务，然后取回结果，我们该怎么做呢？</p><p>比较传统的做法是使用信号量或者条件变量。由于 C++17 还不支持信号量，我们要模拟传统的做法，只能用条件变量了。由于我的重点并不是传统的做法，条件变量 <span class=\"orange\">[9]</span> 我就不展开讲了，而只是展示一下示例的代码。</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;condition_variable&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\nclass scoped_thread {\n  … // 定义同上，略\n};\n\nvoid work(condition_variable&amp; cv,\n          mutex&amp; cv_mut,\n          bool&amp; result_ready,\n          int&amp; result)\n{\n  // 假装我们计算了很久\n  this_thread::sleep_for(2s);\n  result = 42;\n  {\n    unique_lock lock{cv_mut};\n    result_ready = true;\n  }\n  cv.notify_one();\n}\n\nint main()\n{\n  condition_variable cv;\n  mutex cv_mut;\n  bool result_ready = false;\n  int result;\n\n  scoped_thread th{\n    work, ref(cv), ref(cv_mut),\n    ref(result_ready), ref(result)};\n  // 干一些其他事\n  cout &lt;&lt; \"I am waiting now\\n\";\n  unique_lock lock{cv_mut};\n  cv.wait(lock, [&amp;] {\n    return result_ready;\n  });\n  cout &lt;&lt; \"Answer: \" &lt;&lt; result\n       &lt;&lt; '\\n';\n}\n</code></pre><p>可以看到，为了这个小小的“计算”，我们居然需要定义 6 个变量：线程、条件变量、互斥量、单一锁、结果状态变量和结果变量。我们也需要用 <code>ref</code> 模板来告诉 <code>thread</code> 的构造函数，我们需要引用，因为 <code>thread</code> 默认复制或移动所有的参数作为线程函数的参数。这种复杂性并非逻辑上的复杂性，而只是实现导致的，不是我们希望的写代码的方式。</p><p>下面，我们就看看更高层的抽象，未来量 <code>future</code> <span class=\"orange\">[10]</span>，可以如何为我们简化代码。</p><h2>future</h2><p>我们先把上面的代码直接翻译成使用 <code>async</code> <span class=\"orange\">[11]</span>（它会返回一个 <code>future</code>）：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nusing namespace std;\n\nint work()\n{\n  // 假装我们计算了很久\n  this_thread::sleep_for(2s);\n  return 42;\n}\n\nint main()\n{\n  auto fut = async(launch::async, work);\n  // 干一些其他事\n  cout &lt;&lt; \"I am waiting now\\n\";\n  cout &lt;&lt; \"Answer: \" &lt;&lt; fut.get()\n       &lt;&lt; '\\n';\n}\n</code></pre><p>完全同样的结果，代码大大简化，变量减到了只剩一个未来量，还不赖吧？</p><p>我们稍稍分析一下：</p><ul>\n<li><code>work</code> 函数现在不需要考虑条件变量之类的实现细节了，专心干好自己的计算活、老老实实返回结果就可以了。</li>\n<li>调用 <code>async</code> 可以获得一个未来量，<code>launch::async</code> 是运行策略，告诉函数模板 <code>async</code> 应当在新线程里异步调用目标函数。在一些老版本的 GCC 里，不指定运行策略，默认不会起新线程。</li>\n<li><code>async</code> 函数模板可以根据参数来推导出返回类型，在我们的例子里，返回类型是 <code>future&lt;int&gt;</code>。</li>\n<li>在未来量上调用 <code>get</code> 成员函数可以获得其结果。这个结果可以是返回值，也可以是异常，即，如果 <code>work</code> 抛出了异常，那 <code>main</code> 里在执行 <code>fut.get()</code> 时也会得到同样的异常，需要有相应的异常处理代码程序才能正常工作。</li>\n</ul><p>这里有两个要点，从代码里看不出来，我特别说明一下：</p><ol>\n<li>一个 <code>future</code> 上只能调用一次 <code>get</code> 函数，第二次调用为未定义行为，通常导致程序崩溃（对于值类型的结果，<code>get</code> 会以移动的方式来返回）。</li>\n<li>这样一来，自然一个 <code>future</code> 是不能直接在多个线程里用的。</li>\n</ol><p>需要的话，上面两个问题是可以解决的。你可以直接拿 <code>future</code> 来移动构造一个 <code>shared_future</code> <span class=\"orange\">[12]</span>，或者调用 <code>future</code> 的 <code>share</code> 方法来生成一个 <code>shared_future</code>，这样结果就可以在多个线程里使用。此外，对于非 <code>void</code>、非引用的返回结果类型，<code>shared_future</code> 的 <code>get</code> 永远给我们一个 <code>const</code> 引用，这样的设计也就允许我们多次调用 <code>get</code> 了。</p><h3>promise</h3><p>我们上面用 <code>async</code> 函数生成了未来量，但这不是唯一的方式。另外有一种常用的方式是 <code>promise</code> <span class=\"orange\">[13]</span>，我称之为“承诺量”。我们同样看一眼上面的例子用 <code>promise</code> 该怎么写：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\nclass scoped_thread {\n  … // 定义同上，略\n};\n\nvoid work(promise&lt;int&gt; prom)\n{\n  // 假装我们计算了很久\n  this_thread::sleep_for(2s);\n  prom.set_value(42);\n}\n\nint main()\n{\n  promise&lt;int&gt; prom;\n  auto fut = prom.get_future();\n  scoped_thread th{work,\n                   move(prom)};\n  // 干一些其他事\n  cout &lt;&lt; \"I am waiting now\\n\";\n  cout &lt;&lt; \"Answer: \" &lt;&lt; fut.get()\n       &lt;&lt; '\\n';\n}\n</code></pre><p><code>promise</code> 和 <code>future</code> 在这里成对出现，可以看作是一个一次性管道：有人需要兑现承诺，往 <code>promise</code> 里放东西（<code>set_value</code>）；有人就像收期货一样，到时间去 <code>future</code>（写到这里想到，期货英文不就是 future 么，是不是该翻译成期货量呢？😝）里拿（<code>get</code>）就行了。我们把 <code>prom</code> 移动给新线程，这样老线程就完全不需要管理它的生命周期了。</p><p>就这个例子而言，使用 <code>promise</code> 没有 <code>async</code> 方便，但可以看到，这是一种非常灵活的方式，你不需要在一个函数结束的时候才去设置 <code>future</code> 的值。仍然需要注意的是，一组 <code>promise</code> 和 <code>future</code> 只能使用一次，既不能重复设，也不能重复取。</p><p><code>promise</code> 和 <code>future</code> 还有个有趣的用法是使用 <code>void</code> 类型模板参数。这种情况下，两个线程之间不是传递参数，而是进行同步：当一个线程在一个 <code>future&lt;void&gt;</code> 上等待时（使用 <code>get()</code> 或 <code>wait()</code>），另外一个线程可以通过调用 <code>promise&lt;void&gt;</code> 上的 <code>set_value()</code> 让其结束等待、继续往下执行。有兴趣的话，你可以自己试一下，我就不给例子了。</p><h3>packaged_task</h3><p>我们最后要讲的一种 <code>future</code> 的用法是打包任务 <code>packaged_task</code> <span class=\"orange\">[14]</span>，我们同样给出完成相同功能的示例，让你方便对比一下：</p><pre><code class=\"language-c++\">#include &lt;chrono&gt;\n#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\nclass scoped_thread {\n  … // 定义同上，略\n};\n\nint work()\n{\n  // 假装我们计算了很久\n  this_thread::sleep_for(2s);\n  return 42;\n}\n\nint main()\n{\n  packaged_task&lt;int()&gt; task{work};\n  auto fut = task.get_future();\n  scoped_thread th{move(task)};\n  // 干一些其他事\n  this_thread::sleep_for(1s);\n  cout &lt;&lt; \"I am waiting now\\n\";\n  cout &lt;&lt; \"Answer: \" &lt;&lt; fut.get()\n       &lt;&lt; '\\n';\n}\n</code></pre><p>打包任务里打包的是一个函数，模板参数就是一个函数类型。跟 <code>thread</code>、<code>future</code>、<code>promise</code> 一样，<code>packaged_task</code> 只能移动，不能复制。它是个函数对象，可以像正常函数一样被执行，也可以传递给 <code>thread</code> 在新线程中执行。它的特别地方，自然也是你可以从它得到一个未来量了。通过这个未来量，你可以得到这个打包任务的返回值，或者，至少知道这个打包任务已经执行结束了。</p><h2>内容小结</h2><p>今天我们看了一下并发编程的原因、难点，以及 C++ 里的进行多线程计算的基本类，包括线程、互斥量、未来量等。这些对象的使用已经可以初步展现并发编程的困难，但更麻烦的事情还在后头呢……</p><h2>课后思考</h2><p>请试验一下文中的代码，并思考一下，并发编程中哪些情况下会发生死锁？</p><p>如果有任何问题或想法，欢迎留言与我分享。</p><h2><span class=\"reference\">参考资料</span></h2><p><span class=\"reference\">[1] Herb Sutter, “The free lunch is over”. <a href=\"http://www.gotw.ca/publications/concurrency-ddj.htm\">http://www.gotw.ca/publications/concurrency-ddj.htm</a> </span></p><p><span class=\"reference\">[2] Herb Sutter, “Effective concurrency”. <a href=\"https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-use-an-active-object-instead-of-a-mutex/\">https://herbsutter.com/2010/09/24/effective-concurrency-know-when-to-use-an-active-object-instead-of-a-mutex/</a> </span></p><p><span class=\"reference\">[3] Anthony Williams, <em>C++ Concurrency in Action</em> (2nd ed.). Manning, 2019, <a href=\"https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition\">https://www.manning.com/books/c-plus-plus-concurrency-in-action-second-edition</a> </span></p><p><span class=\"reference\">[4] cppreference.com, “std::thread”. <a href=\"https://en.cppreference.com/w/cpp/thread/thread\">https://en.cppreference.com/w/cpp/thread/thread</a> </span></p><p><span class=\"reference\">[4a] cppreference.com, “std::thread”. <a href=\"https://zh.cppreference.com/w/cpp/thread/thread\">https://zh.cppreference.com/w/cpp/thread/thread</a> </span></p><p><span class=\"reference\">[5] cppreference.com, “std::jthread”. <a href=\"https://en.cppreference.com/w/cpp/thread/jthread\">https://en.cppreference.com/w/cpp/thread/jthread</a> </span></p><p><span class=\"reference\">[6] cppreference.com, “std::mutex”. <a href=\"https://en.cppreference.com/w/cpp/thread/mutex\">https://en.cppreference.com/w/cpp/thread/mutex</a> </span></p><p><span class=\"reference\">[6a] cppreference.com, “std::mutex”. <a href=\"https://zh.cppreference.com/w/cpp/thread/mutex\">https://zh.cppreference.com/w/cpp/thread/mutex</a> </span></p><p><span class=\"reference\">[7] cppreference.com, “std::recursive_mutex”. <a href=\"https://en.cppreference.com/w/cpp/thread/recursive_mutex\">https://en.cppreference.com/w/cpp/thread/recursive_mutex</a> </span></p><p><span class=\"reference\">[7a] cppreference.com, “std::recursive_mutex”. <a href=\"https://zh.cppreference.com/w/cpp/thread/recursive_mutex\">https://zh.cppreference.com/w/cpp/thread/recursive_mutex</a> </span></p><p><span class=\"reference\">[8] cppreference.com, “Standard library header &lt;mutex&gt;”. <a href=\"https://en.cppreference.com/w/cpp/header/mutex\">https://en.cppreference.com/w/cpp/header/mutex</a> </span></p><p><span class=\"reference\">[8a] cppreference.com, “标准库头文件 &lt;mutex&gt;”. <a href=\"https://zh.cppreference.com/w/cpp/header/mutex\">https://zh.cppreference.com/w/cpp/header/mutex</a> </span></p><p><span class=\"reference\">[9] cppreference.com, “std::recursive_mutex”. <a href=\"https://en.cppreference.com/w/cpp/thread/condition_variable\">https://en.cppreference.com/w/cpp/thread/condition_variable</a> </span></p><p><span class=\"reference\">[9a] cppreference.com, “std::recursive_mutex”. <a href=\"https://zh.cppreference.com/w/cpp/thread/condition_variable\">https://zh.cppreference.com/w/cpp/thread/condition_variable</a> </span></p><p><span class=\"reference\">[10] cppreference.com, “std::future”. <a href=\"https://en.cppreference.com/w/cpp/thread/future\">https://en.cppreference.com/w/cpp/thread/future</a> </span></p><p><span class=\"reference\">[10a] cppreference.com, “std::future”. <a href=\"https://zh.cppreference.com/w/cpp/thread/future\">https://zh.cppreference.com/w/cpp/thread/future</a> </span></p><p><span class=\"reference\">[11] cppreference.com, “std::async”. <a href=\"https://en.cppreference.com/w/cpp/thread/async\">https://en.cppreference.com/w/cpp/thread/async</a> </span></p><p><span class=\"reference\">[11a] cppreference.com, “std::async”. <a href=\"https://zh.cppreference.com/w/cpp/thread/async\">https://zh.cppreference.com/w/cpp/thread/async</a> </span></p><p><span class=\"reference\">[12] cppreference.com, “std::shared_future”. <a href=\"https://en.cppreference.com/w/cpp/thread/shared_future\">https://en.cppreference.com/w/cpp/thread/shared_future</a> </span></p><p><span class=\"reference\">[12a] cppreference.com, “std::shared_future”. <a href=\"https://en.cppreference.com/w/cpp/thread/shared_future\">https://en.cppreference.com/w/cpp/thread/shared_future</a> </span></p><p><span class=\"reference\">[13] cppreference.com, “std::promise”. <a href=\"https://en.cppreference.com/w/cpp/thread/promise\">https://en.cppreference.com/w/cpp/thread/promise</a> </span></p><p><span class=\"reference\">[13a] cppreference.com, “std::promise”. <a href=\"https://zh.cppreference.com/w/cpp/thread/promise\">https://zh.cppreference.com/w/cpp/thread/promise</a> </span></p><p><span class=\"reference\">[14] cppreference.com, “std::packaged_task”. <a href=\"https://en.cppreference.com/w/cpp/thread/packaged_task\">https://en.cppreference.com/w/cpp/thread/packaged_task</a> </span></p><p><span class=\"reference\">[14a] cppreference.com, “std::packaged_task”. <a href=\"https://zh.cppreference.com/w/cpp/thread/packaged_task\">https://zh.cppreference.com/w/cpp/thread/packaged_task</a> </span></p>","comments":[{"had_liked":false,"id":169773,"user_name":"李公子胜治","can_delete":false,"product_type":"c1","uid":1455420,"ip_address":"","ucode":"7D48D78D289935","user_header":"https://static001.geekbang.org/account/avatar/00/16/35/3c/9800b0ba.jpg","comment_is_top":false,"comment_ctime":1578445372,"is_pvip":false,"replies":[{"id":65898,"content":"少写这么多代码，还没有优越性？\n\n新功能很多是用来提高程序员的工作效率的。而且，脑子摆脱了底层细节，就更有空去思考更高层的抽象了。否则开发里到处是羁绊，只看到这个不能做，那个很麻烦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578459614,"ip_address":"","comment_id":169773,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"作者大大，你好，我在effective modern c++这本书上面看到，作者告诫我们平时写代码时，首先基于任务而不是线程，但是如果我们使用async时，实际上async还是为我们创建了一个新线程，还是没有体会到async比thread的优越性，难道仅仅是可以调用get()，获取async后的执行结果吗？","like_count":26},{"had_liked":false,"id":170050,"user_name":"YouCompleteMe","can_delete":false,"product_type":"c1","uid":1232859,"ip_address":"","ucode":"89B5A75DA85E0A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","comment_is_top":false,"comment_ctime":1578498127,"is_pvip":false,"replies":[{"id":65993,"content":"一定是要多用，形成“肌肉记忆”才行。光读不用是真会忘的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578534211,"ip_address":"","comment_id":170050,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"当时看&lt;The C++ Programming&gt;下册关于多线程的时候，还写了一些demo，现在看到future&#47;async这些类，一点想不起来怎么用的-_-","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480822,"discussion_content":"一定是要多用，形成“肌肉记忆”才行。光读不用是真会忘的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578534211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045455,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","nickname":"Milittle","note":"","ucode":"80E566639A8ABB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206906,"discussion_content":"这个多线程我看了很多遍 可以说可以用一用了 \n最起码知道六种内存序 和原子性的知识了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584453261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206163,"user_name":"风临","can_delete":false,"product_type":"c1","uid":1257795,"ip_address":"","ucode":"DC11D6EAF4DDAA","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/43/2f70125c.jpg","comment_is_top":false,"comment_ctime":1586799247,"is_pvip":false,"replies":[{"id":77094,"content":"极客时间当然是会挑老师的啦😄。我和极客时间都很爱惜自己的名声，不好好写对不起读者，也对不起自己。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586861217,"ip_address":"","comment_id":206163,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师教得很棒，学之前一头雾水，学之后醍醐灌顶，真是很享受。其实网上的教程很多，但是鱼龙混杂，自身没有经验的话，很难去分清多种方法的优劣，很可能片面甚至误导。所以跟着老师说真的很安心，因为质量很高，既全面又能让人看清楚趋势和方向","like_count":9,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491699,"discussion_content":"极客时间当然是会挑老师的啦😄。我和极客时间都很爱惜自己的名声，不好好写对不起读者，也对不起自己。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586861217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184685,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1583381930,"is_pvip":false,"replies":[{"id":71433,"content":"是的，那时就阻塞等待了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583395119,"ip_address":"","comment_id":184685,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"future执行get函数的时候，如果此时还没生成结果，是否get就阻塞了，直到有返回值为止呢？","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491699,"discussion_content":"极客时间当然是会挑老师的啦😄。我和极客时间都很爱惜自己的名声，不好好写对不起读者，也对不起自己。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586861217,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183110,"user_name":"皮皮侠","can_delete":false,"product_type":"c1","uid":1258402,"ip_address":"","ucode":"04205990C1DE1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","comment_is_top":false,"comment_ctime":1582954925,"is_pvip":false,"replies":[{"id":70850,"content":"理解满分！😁","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582967808,"ip_address":"","comment_id":183110,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"模板部分终于看完了，玩过lamda和一些traits。跟着老师学了好多新东西，新思维，尤其是对编译期计算。对一些以前模糊的理论有了新的认识。这几篇以后肯定要回头继续把玩的。另外，我想老师花了这么多心血来写一些14、17、20的新特性，应该是希望让C++既能写出性能高的代码，也易于使用，简练，更适合上层业务逻辑，用心良苦。\n蟹蟹老师的分享；）","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486096,"discussion_content":"是的，那时就阻塞等待了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583395119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":362326,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"江苏","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1668416752,"is_pvip":false,"replies":[{"id":131949,"content":"盲生，你发现了一个华点。\n\n这个问题提得非常好。这里是我搞错了。future 和 shared_future 具有不同的接口。对于值对象类型，future&lt;Obj&gt;::get() 的返回值就是 Obj，是移动出来的。而 shared_future&lt;Obj&gt;::get() 的返回值是 const Obj&amp;，就是可以多次读取的……\n\n我回头看看文本怎么修正一下。谢谢🙏。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1669006894,"ip_address":"江苏","comment_id":362326,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师你好，想请问下shared_future，原文说“要么调用 future 的 share 方法来生成一个 shared_future，结果就可以在多个线程里用了——当然，每个 shared_future 上仍然还是只能调用一次 get 函数”。\n意思是，async 返回的 future 作为共享资源被多个线程使用时，每个线程通过 future 的 share 方法获取到 shared_future，然后每个线程就可以调用get函数了，是这样吗？\n另外，我在 MSVC 下测试，async 返回的 future，future.share() 得到 shared_future，shared_future 多次调用它的 get 方法也没有问题.","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485561,"discussion_content":"理解满分！😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582967808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203897,"user_name":"even","can_delete":false,"product_type":"c1","uid":1249431,"ip_address":"","ucode":"C976CFB2A0EBBF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Cwkic25ndkExxY3HvVjAaYKVzFRicv2X6TE2sjdqTBBmqeh7X8crIQe3SHPichvcayOCqI3PJ88yVuMNlD8VvkE3A/132","comment_is_top":false,"comment_ctime":1586303176,"is_pvip":false,"replies":[{"id":76294,"content":"对的，练习非常重要。要能够自然地自己写出现代C++代码了，才算学会了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586345237,"ip_address":"","comment_id":203897,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师的课适合几度回味，多看几次，跟着敲代码，试着运行，慢慢的领会C++新特性，希望以后能够用上","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490995,"discussion_content":"对的，练习非常重要。要能够自然地自己写出现代C++代码了，才算学会了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586345237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290321,"discussion_content":"第一遍也只能是大概浏览下内容，找盲点，第二、第三、第四遍挑重点和难点学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594429168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217979,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1589685552,"is_pvip":false,"replies":[{"id":80762,"content":"有热情就好。要持之以恒，把肉痛转变成为阅读的动力。😜","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589807582,"ip_address":"","comment_id":217979,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看到作者推荐，买了一本 《c++ concurrency in action》 ，33.79美刀，肉痛。慢慢读完它。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495313,"discussion_content":"有热情就好。要持之以恒，把肉痛转变成为阅读的动力。😜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589807582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120997,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","nickname":"favorlm","note":"","ucode":"CFD52127AA6E1D","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653591,"discussion_content":"读完了吗，兄弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731260948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2875594,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","nickname":"孙新","note":"","ucode":"A80038A479B943","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561967,"discussion_content":"中文版我前年买的，看的一头雾水。中文版89，原版可真贵。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649754645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170363,"user_name":"王大为","can_delete":false,"product_type":"c1","uid":1248950,"ip_address":"","ucode":"E182E280C82431","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/b6/37b19725.jpg","comment_is_top":false,"comment_ctime":1578580137,"is_pvip":false,"replies":[{"id":66083,"content":"那是Google的偏好。除非你为Google的项目贡献代码，理它干嘛？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578621474,"ip_address":"","comment_id":170363,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"最近用google的cpplint工具扫描了我的代码，但cpplint报告说不允许包含c++11的thread头文件，请问这个是出于什么目的呢？\n\ncpplint. py --verbose=5 my_cpp_file\noutput : &lt;thread&gt; is an unapproved c++11 header\n\n我看了一下cpplint脚本，里面确实对mutex thread chrono等头文件做了限制。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495313,"discussion_content":"有热情就好。要持之以恒，把肉痛转变成为阅读的动力。😜","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589807582,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1120997,"avatar":"https://static001.geekbang.org/account/avatar/00/11/1a/e5/6899701e.jpg","nickname":"favorlm","note":"","ucode":"CFD52127AA6E1D","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653591,"discussion_content":"读完了吗，兄弟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731260948,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"山东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2875594,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","nickname":"孙新","note":"","ucode":"A80038A479B943","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":561967,"discussion_content":"中文版我前年买的，看的一头雾水。中文版89，原版可真贵。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1649754645,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356113,"user_name":"当初莫相识","can_delete":false,"product_type":"c1","uid":2768765,"ip_address":"上海","ucode":"313917BB360D48","user_header":"https://static001.geekbang.org/account/avatar/00/2a/3f/7d/f624fa69.jpg","comment_is_top":false,"comment_ctime":1661993618,"is_pvip":false,"replies":[{"id":129781,"content":"析构时join，然后销毁thread成员变量是对的。\n\n但不是析构时启动线程。thread在构造时就启动线程了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1662369869,"ip_address":"上海","comment_id":356113,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"每次看线程都有新的收获，也有新的疑问。scoped_thread在析构函数时join，析构函数会等join完毕后销毁thread成员变量，对吗？\n  scoped_thread th{work, ref(cv),\n                   ref(result)};\n  &#47;&#47; 干一些其他事\n  cout &lt;&lt; &quot;I am waiting now\\n&quot;;\n  unique_lock lock{cv_mut};\n  cv.wait(lock);\n  cout &lt;&lt; &quot;Answer: &quot; &lt;&lt; result\n       &lt;&lt; &#39;\\n&#39;;\n}\nmain()函数里，我理解为scoped_thread直到｝才会执行析构启动线程，而cv.wait又一直在阻塞，所以不会运行到｝。虽然知道程序能得到预期结果，但逻辑上不理解，希望老师能解答我的困惑","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480955,"discussion_content":"那是Google的偏好。除非你为Google的项目贡献代码，理它干嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578621474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1057703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/23/a7/3f084b33.jpg","nickname":"lanpay","note":"","ucode":"15BE115858BEBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129774,"discussion_content":"跟google内部一些库有名称冲突吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578737258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1057703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/23/a7/3f084b33.jpg","nickname":"lanpay","note":"","ucode":"15BE115858BEBD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174463,"discussion_content":"不是。不同名空间，不会冲突。就是Google的代码用自己的内部库，不用std::thread。\n\n内部工具开源出来，缺省设定不让用标准库，Google做得不够地道。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581920193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":129774,"ip_address":"","group_id":0},"score":174463,"extra":""}]}]},{"had_liked":false,"id":169773,"user_name":"李公子胜治","can_delete":false,"product_type":"c1","uid":1455420,"ip_address":"","ucode":"7D48D78D289935","user_header":"https://static001.geekbang.org/account/avatar/00/16/35/3c/9800b0ba.jpg","comment_is_top":false,"comment_ctime":1578445372,"is_pvip":false,"replies":[{"id":65898,"content":"少写这么多代码，还没有优越性？\n\n新功能很多是用来提高程序员的工作效率的。而且，脑子摆脱了底层细节，就更有空去思考更高层的抽象了。否则开发里到处是羁绊，只看到这个不能做，那个很麻烦。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578459614,"ip_address":"","comment_id":169773,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"作者大大，你好，我在effective modern c++这本书上面看到，作者告诫我们平时写代码时，首先基于任务而不是线程，但是如果我们使用async时，实际上async还是为我们创建了一个新线程，还是没有体会到async比thread的优越性，难道仅仅是可以调用get()，获取async后的执行结果吗？","like_count":26,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480714,"discussion_content":"少写这么多代码，还没有优越性？\n\n新功能很多是用来提高程序员的工作效率的。而且，脑子摆脱了底层细节，就更有空去思考更高层的抽象了。否则开发里到处是羁绊，只看到这个不能做，那个很麻烦。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578459614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170050,"user_name":"YouCompleteMe","can_delete":false,"product_type":"c1","uid":1232859,"ip_address":"","ucode":"89B5A75DA85E0A","user_header":"https://static001.geekbang.org/account/avatar/00/12/cf/db/9693d08f.jpg","comment_is_top":false,"comment_ctime":1578498127,"is_pvip":false,"replies":[{"id":65993,"content":"一定是要多用，形成“肌肉记忆”才行。光读不用是真会忘的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578534211,"ip_address":"","comment_id":170050,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"当时看&lt;The C++ Programming&gt;下册关于多线程的时候，还写了一些demo，现在看到future&#47;async这些类，一点想不起来怎么用的-_-","like_count":10,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480714,"discussion_content":"少写这么多代码，还没有优越性？\n\n新功能很多是用来提高程序员的工作效率的。而且，脑子摆脱了底层细节，就更有空去思考更高层的抽象了。否则开发里到处是羁绊，只看到这个不能做，那个很麻烦。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1578459614,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":206163,"user_name":"风临","can_delete":false,"product_type":"c1","uid":1257795,"ip_address":"","ucode":"DC11D6EAF4DDAA","user_header":"https://static001.geekbang.org/account/avatar/00/13/31/43/2f70125c.jpg","comment_is_top":false,"comment_ctime":1586799247,"is_pvip":false,"replies":[{"id":77094,"content":"极客时间当然是会挑老师的啦😄。我和极客时间都很爱惜自己的名声，不好好写对不起读者，也对不起自己。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586861217,"ip_address":"","comment_id":206163,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师教得很棒，学之前一头雾水，学之后醍醐灌顶，真是很享受。其实网上的教程很多，但是鱼龙混杂，自身没有经验的话，很难去分清多种方法的优劣，很可能片面甚至误导。所以跟着老师说真的很安心，因为质量很高，既全面又能让人看清楚趋势和方向","like_count":9,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480822,"discussion_content":"一定是要多用，形成“肌肉记忆”才行。光读不用是真会忘的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578534211,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045455,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f3/cf/851dab01.jpg","nickname":"Milittle","note":"","ucode":"80E566639A8ABB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206906,"discussion_content":"这个多线程我看了很多遍 可以说可以用一用了 \n最起码知道六种内存序 和原子性的知识了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584453261,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184685,"user_name":"刘丹","can_delete":false,"product_type":"c1","uid":1081922,"ip_address":"","ucode":"66594D1C957E15","user_header":"https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg","comment_is_top":false,"comment_ctime":1583381930,"is_pvip":false,"replies":[{"id":71433,"content":"是的，那时就阻塞等待了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1583395119,"ip_address":"","comment_id":184685,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"future执行get函数的时候，如果此时还没生成结果，是否get就阻塞了，直到有返回值为止呢？","like_count":6,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486096,"discussion_content":"是的，那时就阻塞等待了。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583395119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183110,"user_name":"皮皮侠","can_delete":false,"product_type":"c1","uid":1258402,"ip_address":"","ucode":"04205990C1DE1F","user_header":"https://static001.geekbang.org/account/avatar/00/13/33/a2/6c0ffc15.jpg","comment_is_top":false,"comment_ctime":1582954925,"is_pvip":false,"replies":[{"id":70850,"content":"理解满分！😁","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1582967808,"ip_address":"","comment_id":183110,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"模板部分终于看完了，玩过lamda和一些traits。跟着老师学了好多新东西，新思维，尤其是对编译期计算。对一些以前模糊的理论有了新的认识。这几篇以后肯定要回头继续把玩的。另外，我想老师花了这么多心血来写一些14、17、20的新特性，应该是希望让C++既能写出性能高的代码，也易于使用，简练，更适合上层业务逻辑，用心良苦。\n蟹蟹老师的分享；）","like_count":3,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485561,"discussion_content":"理解满分！😁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582967808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":362326,"user_name":"怪兽","can_delete":false,"product_type":"c1","uid":1324007,"ip_address":"江苏","ucode":"3342C55CB83B08","user_header":"https://static001.geekbang.org/account/avatar/00/14/33/e7/145be2f9.jpg","comment_is_top":false,"comment_ctime":1668416752,"is_pvip":false,"replies":[{"id":131949,"content":"盲生，你发现了一个华点。\n\n这个问题提得非常好。这里是我搞错了。future 和 shared_future 具有不同的接口。对于值对象类型，future&lt;Obj&gt;::get() 的返回值就是 Obj，是移动出来的。而 shared_future&lt;Obj&gt;::get() 的返回值是 const Obj&amp;，就是可以多次读取的……\n\n我回头看看文本怎么修正一下。谢谢🙏。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1669006894,"ip_address":"江苏","comment_id":362326,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"老师你好，想请问下shared_future，原文说“要么调用 future 的 share 方法来生成一个 shared_future，结果就可以在多个线程里用了——当然，每个 shared_future 上仍然还是只能调用一次 get 函数”。\n意思是，async 返回的 future 作为共享资源被多个线程使用时，每个线程通过 future 的 share 方法获取到 shared_future，然后每个线程就可以调用get函数了，是这样吗？\n另外，我在 MSVC 下测试，async 返回的 future，future.share() 得到 shared_future，shared_future 多次调用它的 get 方法也没有问题.","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594342,"discussion_content":"盲生，你发现了一个华点。\n\n这个问题提得非常好。这里是我搞错了。future 和 shared_future 具有不同的接口。对于值对象类型，future&lt;Obj&gt;::get() 的返回值就是 Obj，是移动出来的。而 shared_future&lt;Obj&gt;::get() 的返回值是 const Obj&amp;，就是可以多次读取的……\n\n我回头看看文本怎么修正一下。谢谢🙏。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1669006894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203897,"user_name":"even","can_delete":false,"product_type":"c1","uid":1249431,"ip_address":"","ucode":"C976CFB2A0EBBF","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Cwkic25ndkExxY3HvVjAaYKVzFRicv2X6TE2sjdqTBBmqeh7X8crIQe3SHPichvcayOCqI3PJ88yVuMNlD8VvkE3A/132","comment_is_top":false,"comment_ctime":1586303176,"is_pvip":false,"replies":[{"id":76294,"content":"对的，练习非常重要。要能够自然地自己写出现代C++代码了，才算学会了。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1586345237,"ip_address":"","comment_id":203897,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"吴老师的课适合几度回味，多看几次，跟着敲代码，试着运行，慢慢的领会C++新特性，希望以后能够用上","like_count":2,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594342,"discussion_content":"盲生，你发现了一个华点。\n\n这个问题提得非常好。这里是我搞错了。future 和 shared_future 具有不同的接口。对于值对象类型，future&lt;Obj&gt;::get() 的返回值就是 Obj，是移动出来的。而 shared_future&lt;Obj&gt;::get() 的返回值是 const Obj&amp;，就是可以多次读取的……\n\n我回头看看文本怎么修正一下。谢谢🙏。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1669006894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"江苏","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":217979,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1589685552,"is_pvip":false,"replies":[{"id":80762,"content":"有热情就好。要持之以恒，把肉痛转变成为阅读的动力。😜","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1589807582,"ip_address":"","comment_id":217979,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"看到作者推荐，买了一本 《c++ concurrency in action》 ，33.79美刀，肉痛。慢慢读完它。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490995,"discussion_content":"对的，练习非常重要。要能够自然地自己写出现代C++代码了，才算学会了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586345237,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1055296,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1a/40/f10493ef.jpg","nickname":"中山浪子","note":"","ucode":"25D0F8462473D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290321,"discussion_content":"第一遍也只能是大概浏览下内容，找盲点，第二、第三、第四遍挑重点和难点学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594429168,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170363,"user_name":"王大为","can_delete":false,"product_type":"c1","uid":1248950,"ip_address":"","ucode":"E182E280C82431","user_header":"https://static001.geekbang.org/account/avatar/00/13/0e/b6/37b19725.jpg","comment_is_top":false,"comment_ctime":1578580137,"is_pvip":false,"replies":[{"id":66083,"content":"那是Google的偏好。除非你为Google的项目贡献代码，理它干嘛？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578621474,"ip_address":"","comment_id":170363,"utype":1}],"discussion_count":3,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"最近用google的cpplint工具扫描了我的代码，但cpplint报告说不允许包含c++11的thread头文件，请问这个是出于什么目的呢？\n\ncpplint. py --verbose=5 my_cpp_file\noutput : &lt;thread&gt; is an unapproved c++11 header\n\n我看了一下cpplint脚本，里面确实对mutex thread chrono等头文件做了限制。","like_count":1,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480955,"discussion_content":"那是Google的偏好。除非你为Google的项目贡献代码，理它干嘛？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578621474,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1057703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/23/a7/3f084b33.jpg","nickname":"lanpay","note":"","ucode":"15BE115858BEBD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129774,"discussion_content":"跟google内部一些库有名称冲突吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578737258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1057703,"avatar":"https://static001.geekbang.org/account/avatar/00/10/23/a7/3f084b33.jpg","nickname":"lanpay","note":"","ucode":"15BE115858BEBD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174463,"discussion_content":"不是。不同名空间，不会冲突。就是Google的代码用自己的内部库，不用std::thread。\n\n内部工具开源出来，缺省设定不让用标准库，Google做得不够地道。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581920193,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":129774,"ip_address":"","group_id":0},"score":174463,"extra":""}]}]},{"had_liked":false,"id":356113,"user_name":"当初莫相识","can_delete":false,"product_type":"c1","uid":2768765,"ip_address":"上海","ucode":"313917BB360D48","user_header":"https://static001.geekbang.org/account/avatar/00/2a/3f/7d/f624fa69.jpg","comment_is_top":false,"comment_ctime":1661993618,"is_pvip":false,"replies":[{"id":129781,"content":"析构时join，然后销毁thread成员变量是对的。\n\n但不是析构时启动线程。thread在构造时就启动线程了。","user_name":"作者回复","user_name_real":"编辑","uid":1645639,"ctime":1662369869,"ip_address":"上海","comment_id":356113,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100040501,"comment_content":"每次看线程都有新的收获，也有新的疑问。scoped_thread在析构函数时join，析构函数会等join完毕后销毁thread成员变量，对吗？\n  scoped_thread th{work, ref(cv),\n                   ref(result)};\n  &#47;&#47; 干一些其他事\n  cout &lt;&lt; &quot;I am waiting now\\n&quot;;\n  unique_lock lock{cv_mut};\n  cv.wait(lock);\n  cout &lt;&lt; &quot;Answer: &quot; &lt;&lt; result\n       &lt;&lt; &#39;\\n&#39;;\n}\nmain()函数里，我理解为scoped_thread直到｝才会执行析构启动线程，而cv.wait又一直在阻塞，所以不会运行到｝。虽然知道程序能得到预期结果，但逻辑上不理解，希望老师能解答我的困惑","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":586600,"discussion_content":"析构时join，然后销毁thread成员变量是对的。\n\n但不是析构时启动线程。thread在构造时就启动线程了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662369869,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239685,"user_name":"青鸟飞鱼","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1596615819,"is_pvip":false,"replies":[{"id":88520,"content":"没看出具体意义。如果你希望在wait那句后有可能退出，在那儿检查 m_isRun 不就行了？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596623256,"ip_address":"","comment_id":239685,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，你好，关于条件变量应该如何退出呢？\n比如说:\nvoid f()\n{\n    while(m_isRun)\n    { \n       std::unique_lock&lt;std::mutex&gt; dataLock(m_mtx);\n       while(m_list.empty())\n       {\n           m_cond. wait(dataLock);\n        }\n        ……\n    }\n}\n线程函数如上面所写，这个线程如何安全退出呢？","like_count":0},{"had_liked":false,"id":238556,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1596197768,"is_pvip":false,"replies":[{"id":88131,"content":"async 也不是真正的异步，而是封装的多线程。\n\nC++20 都没有提供完整的异步支持，因为 I&#47;O 方面的异步没有标准化。看看 Boost.Asio 吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596210974,"ip_address":"","comment_id":238556,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，异步的例子都是基于async的。那如果不用这个特性，在cpp98上应该只有下面这个方法了吧\n1. Callback\n2.多线程+Callback\n\n但是这两个都有个问题，callback也是会阻塞的。如果有A B C D四个流程，B C D分别依赖于前一个的输出，这种callback就会调用栈太深，容易爆栈。\n\n最近对异步编程模式产生了些疑问，应该怎么解决？\n\n尤其高并发的情况下，阻塞的时候线程不被调度，这不就相当于cpu会飙升。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502787,"discussion_content":"async 也不是真正的异步，而是封装的多线程。\n\nC++20 都没有提供完整的异步支持，因为 I/O 方面的异步没有标准化。看看 Boost.Asio 吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596210974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2215488,"avatar":"https://static001.geekbang.org/account/avatar/00/21/ce/40/2efaf627.jpg","nickname":"田洋","note":"","ucode":"730046BEEA504F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338551,"discussion_content":"C++20有了coroutine，是不是就可以有真正的单线程异步了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609311174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229371,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1592979116,"is_pvip":false,"replies":[{"id":84752,"content":"抱歉，我看来这是很自然的设计，并非坑，也是 future 的文档里明确说明的行为。\n\n如果你只是想单纯的运行一下，不需要去拿任何结果，为什么不用 thread([]() {…}).detach() 呢？\n\n但我也不会这样写。对我来说，多线程的设计里，任何一个线程都应该被 join。“发射后不管”才是一个会带来很多坑的做法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1593093355,"ip_address":"","comment_id":229371,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"std::async 有个比较大的坑，如果把返回的 future 绑定到变量 ， 调用 std::sync 的线程仍然会阻塞到里面的任务执行完，即使绑定了，在出绑的变量出作用域时析构时会阻塞\n很多时候只是想单纯的异步运行一下，不阻塞当前的线程，这种情况使用 std::sync 就会掉坑里了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502787,"discussion_content":"async 也不是真正的异步，而是封装的多线程。\n\nC++20 都没有提供完整的异步支持，因为 I/O 方面的异步没有标准化。看看 Boost.Asio 吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596210974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2215488,"avatar":"https://static001.geekbang.org/account/avatar/00/21/ce/40/2efaf627.jpg","nickname":"田洋","note":"","ucode":"730046BEEA504F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338551,"discussion_content":"C++20有了coroutine，是不是就可以有真正的单线程异步了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609311174,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226484,"user_name":"HaHa","can_delete":false,"product_type":"c1","uid":2018562,"ip_address":"","ucode":"61C345390484F8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/cd/02/26993bee.jpg","comment_is_top":false,"comment_ctime":1592119760,"is_pvip":false,"replies":[{"id":83421,"content":"如果你使用了 launch::async 策略的话，是这样的。\n\n不过，实现有可能使用内存池来降低开销。按目前查到的资料，至少 MSVC 是使用内存池的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1592153259,"ip_address":"","comment_id":226484,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"请问使用async时是每次都要启动一个线程吗，那大量使用会频繁创建线程？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498260,"discussion_content":"如果你使用了 launch::async 策略的话，是这样的。\n\n不过，实现有可能使用内存池来降低开销。按目前查到的资料，至少 MSVC 是使用内存池的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592153259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219800,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1590103956,"is_pvip":false,"replies":[{"id":81298,"content":"future？在很大程度上可以替代之前的用法。但高层的抽象通常不能完全替代底层的抽象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590214314,"ip_address":"","comment_id":219800,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"最近写了一些多线程程序练手，突然想到有了 feature 这一套东西，是不是应该完全抛弃之前的条件变量同步那一套呢？尝试写一个基于cpp17特性的线程池，想到上面的问题。望解答。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495944,"discussion_content":"future？在很大程度上可以替代之前的用法。但高层的抽象通常不能完全替代底层的抽象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590214314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200633,"user_name":"湖海散人","can_delete":false,"product_type":"c1","uid":1096781,"ip_address":"","ucode":"74C0C825D74CC1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","comment_is_top":false,"comment_ctime":1585626639,"is_pvip":false,"replies":[{"id":75158,"content":"1. 看第 9 讲，自定义字面量。\n\n2. 线程间本来就是共享内存的，不需要管道之类的东西。只需要状态同步就可以。Python 的协程在 C++ 里的对应物见第 30 讲。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585661961,"ip_address":"","comment_id":200633,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"请教老师几个问题：\n1. sleep_for函数中的参数数字后面的&quot;ms&quot;, &quot;s&quot;是C++的什么特性呀，我用C++11编译不过，用C++17正常\n2. 对于async，future的用法，是怎么拿到另一个线程的返回值的？ 是future内部使用了管道？这个async和future和python里面的协程很像","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495944,"discussion_content":"future？在很大程度上可以替代之前的用法。但高层的抽象通常不能完全替代底层的抽象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590214314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195575,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1585198478,"is_pvip":false,"replies":[{"id":74463,"content":"三十讲来讲C++，不浓缩不行啊……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585316342,"ip_address":"","comment_id":195575,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"在系列完结以后才开始阅读。最初买专栏以为自己能看懂，结果直接懵逼了。现在终于写了一些c++代码，才发现这系列都是浓缩的精华，每次读都有新收获啊","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490082,"discussion_content":"1. 看第 9 讲，自定义字面量。\n\n2. 线程间本来就是共享内存的，不需要管道之类的东西。只需要状态同步就可以。Python 的协程在 C++ 里的对应物见第 30 讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585661961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191212,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1584754980,"is_pvip":false,"replies":[{"id":73562,"content":"不太理解这个问题。不过，同一个进程中的多个线程共享相同的地址空间，所以，也许对你这个问题的回答是“是”。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584875597,"ip_address":"","comment_id":191212,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，线程的虚拟内存大小都一样大吗？😂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488131,"discussion_content":"不太理解这个问题。不过，同一个进程中的多个线程共享相同的地址空间，所以，也许对你这个问题的回答是“是”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584875597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212181,"discussion_content":"那线程自己的独立栈空间的大小呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584943781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212250,"discussion_content":"仍然是同一个地址空间。理论上另外一个线程可以来破坏你的栈。不过，栈本身是独立的，增长也是独立控制的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584950579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":212181,"ip_address":"","group_id":0},"score":212250,"extra":""}]}]},{"had_liked":false,"id":170632,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1578647269,"is_pvip":false,"replies":[{"id":66140,"content":"编译期编程确实是 C++ 里比较好玩的部分，但也容易被滥用，还容易把新手全吓跑……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578668056,"ip_address":"","comment_id":170632,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"普大喜奔！\n🍾🍾🎉🎉🎊🎊\n模板章节终于结束了！\n其实我还没学够呢（真心）\n\n其实死锁这玩意太容易出现了。描述一个比较经典的场景，A,B两个线程，a,b两个资源，两个线程都要用两个资源。\nA线程先用资源a，锁住资源a；\nB线程先用资源b，锁住资源b；\nA线程还需要资源b，但是不能放开资源a，因为没用完；\nB线程还需要资源a，但是也不能放开资源b，因为没用完；\nA线程占着a不放还想用b，B线程占着b不放还想用a；\nA说，你先给我用b，我用完b，我肯定ab一起放；\nB说，为啥你不给我用a，我用完a，我肯定ab一起放；\n任务管理器说：你们都死吧。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488131,"discussion_content":"不太理解这个问题。不过，同一个进程中的多个线程共享相同的地址空间，所以，也许对你这个问题的回答是“是”。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584875597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212181,"discussion_content":"那线程自己的独立栈空间的大小呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584943781,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":1236047,"avatar":"","nickname":"晚风·和煦","note":"","ucode":"0B1DB8F437A4B2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212250,"discussion_content":"仍然是同一个地址空间。理论上另外一个线程可以来破坏你的栈。不过，栈本身是独立的，增长也是独立控制的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584950579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":212181,"ip_address":"","group_id":0},"score":212250,"extra":""}]}]},{"had_liked":false,"id":169762,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1578443669,"is_pvip":false,"replies":[{"id":65897,"content":"future的设计原则我不熟。我是挺希望跟promise联用能复用，真当成管道。但目前不支持。也许以后可以。并发方面，C++的标准机制还缺不少东西的，同步只用标准库的话很难。不过C++20会加不少新东西。\n\n用词方面的相同应该和语言实现是否用C++没关系。并发方面有很多前沿的文献，标准术语应该早就有不少了吧。而且，标准的Python实现，CPython，是纯C写的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578459435,"ip_address":"","comment_id":169762,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"烧脑的编译期内容终于结束了。每天在工作之余烧一会儿，还没烧透呢，就结束了。是该庆幸还是该解脱呢？\n\n感觉编译期编程就是C++中的理论物理，需要纸和笔，然后适应一大堆符号。\n\nfeature只能使用一次，是为了避免多次使用带来的循环获取锁从而导致死锁么？\n\n\n读书的时候先学的就是C++，并且为其微妙的语义而着迷，可以工作中很少用到它。接触future, promise, async是从Python和JavaScript开始的。虽然这三种语言互补相同，可是在异步或者并发上，用的关键词竟然都是一样的，真是聪明的脑袋都是类似的，愚笨的脑袋各有不同啊。\n\n这个巧合也许因为Python和JavaScript底层都是用c&#47;c++实现的？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481048,"discussion_content":"编译期编程确实是 C++ 里比较好玩的部分，但也容易被滥用，还容易把新手全吓跑……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578668056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239685,"user_name":"青鸟飞鱼","can_delete":false,"product_type":"c1","uid":1807943,"ip_address":"","ucode":"8C64517DA556FE","user_header":"https://static001.geekbang.org/account/avatar/00/1b/96/47/93838ff7.jpg","comment_is_top":false,"comment_ctime":1596615819,"is_pvip":false,"replies":[{"id":88520,"content":"没看出具体意义。如果你希望在wait那句后有可能退出，在那儿检查 m_isRun 不就行了？","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596623256,"ip_address":"","comment_id":239685,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，你好，关于条件变量应该如何退出呢？\n比如说:\nvoid f()\n{\n    while(m_isRun)\n    { \n       std::unique_lock&lt;std::mutex&gt; dataLock(m_mtx);\n       while(m_list.empty())\n       {\n           m_cond. wait(dataLock);\n        }\n        ……\n    }\n}\n线程函数如上面所写，这个线程如何安全退出呢？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503185,"discussion_content":"没看出具体意义。如果你希望在wait那句后有可能退出，在那儿检查 m_isRun 不就行了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596623256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":238556,"user_name":"范闲","can_delete":false,"product_type":"c1","uid":1073125,"ip_address":"","ucode":"F21FD7DF6BA53C","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/e5/54325854.jpg","comment_is_top":false,"comment_ctime":1596197768,"is_pvip":false,"replies":[{"id":88131,"content":"async 也不是真正的异步，而是封装的多线程。\n\nC++20 都没有提供完整的异步支持，因为 I&#47;O 方面的异步没有标准化。看看 Boost.Asio 吧。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1596210974,"ip_address":"","comment_id":238556,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，异步的例子都是基于async的。那如果不用这个特性，在cpp98上应该只有下面这个方法了吧\n1. Callback\n2.多线程+Callback\n\n但是这两个都有个问题，callback也是会阻塞的。如果有A B C D四个流程，B C D分别依赖于前一个的输出，这种callback就会调用栈太深，容易爆栈。\n\n最近对异步编程模式产生了些疑问，应该怎么解决？\n\n尤其高并发的情况下，阻塞的时候线程不被调度，这不就相当于cpu会飙升。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503185,"discussion_content":"没看出具体意义。如果你希望在wait那句后有可能退出，在那儿检查 m_isRun 不就行了？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596623256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229371,"user_name":"幻境之桥","can_delete":false,"product_type":"c1","uid":1061517,"ip_address":"","ucode":"F9F4DD94CB554E","user_header":"https://static001.geekbang.org/account/avatar/00/10/32/8d/91cd624b.jpg","comment_is_top":false,"comment_ctime":1592979116,"is_pvip":false,"replies":[{"id":84752,"content":"抱歉，我看来这是很自然的设计，并非坑，也是 future 的文档里明确说明的行为。\n\n如果你只是想单纯的运行一下，不需要去拿任何结果，为什么不用 thread([]() {…}).detach() 呢？\n\n但我也不会这样写。对我来说，多线程的设计里，任何一个线程都应该被 join。“发射后不管”才是一个会带来很多坑的做法。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1593093355,"ip_address":"","comment_id":229371,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"std::async 有个比较大的坑，如果把返回的 future 绑定到变量 ， 调用 std::sync 的线程仍然会阻塞到里面的任务执行完，即使绑定了，在出绑的变量出作用域时析构时会阻塞\n很多时候只是想单纯的异步运行一下，不阻塞当前的线程，这种情况使用 std::sync 就会掉坑里了","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499458,"discussion_content":"抱歉，我看来这是很自然的设计，并非坑，也是 future 的文档里明确说明的行为。\n\n如果你只是想单纯的运行一下，不需要去拿任何结果，为什么不用 thread([]() {…}).detach() 呢？\n\n但我也不会这样写。对我来说，多线程的设计里，任何一个线程都应该被 join。“发射后不管”才是一个会带来很多坑的做法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593093355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732221,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6e/7d/0485232b.jpg","nickname":"瓜农","note":"","ucode":"CF6B8E5B74BCA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574360,"discussion_content":"老师，用线程池是不是更好？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653995234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226484,"user_name":"HaHa","can_delete":false,"product_type":"c1","uid":2018562,"ip_address":"","ucode":"61C345390484F8","user_header":"https://static001.geekbang.org/account/avatar/00/1e/cd/02/26993bee.jpg","comment_is_top":false,"comment_ctime":1592119760,"is_pvip":false,"replies":[{"id":83421,"content":"如果你使用了 launch::async 策略的话，是这样的。\n\n不过，实现有可能使用内存池来降低开销。按目前查到的资料，至少 MSVC 是使用内存池的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1592153259,"ip_address":"","comment_id":226484,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"请问使用async时是每次都要启动一个线程吗，那大量使用会频繁创建线程？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499458,"discussion_content":"抱歉，我看来这是很自然的设计，并非坑，也是 future 的文档里明确说明的行为。\n\n如果你只是想单纯的运行一下，不需要去拿任何结果，为什么不用 thread([]() {…}).detach() 呢？\n\n但我也不会这样写。对我来说，多线程的设计里，任何一个线程都应该被 join。“发射后不管”才是一个会带来很多坑的做法。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593093355,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1732221,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/6e/7d/0485232b.jpg","nickname":"瓜农","note":"","ucode":"CF6B8E5B74BCA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574360,"discussion_content":"老师，用线程池是不是更好？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653995234,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219800,"user_name":"西加加","can_delete":false,"product_type":"c1","uid":1144416,"ip_address":"","ucode":"727238758A7F3D","user_header":"https://static001.geekbang.org/account/avatar/00/11/76/60/8ea658a9.jpg","comment_is_top":false,"comment_ctime":1590103956,"is_pvip":false,"replies":[{"id":81298,"content":"future？在很大程度上可以替代之前的用法。但高层的抽象通常不能完全替代底层的抽象。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1590214314,"ip_address":"","comment_id":219800,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"最近写了一些多线程程序练手，突然想到有了 feature 这一套东西，是不是应该完全抛弃之前的条件变量同步那一套呢？尝试写一个基于cpp17特性的线程池，想到上面的问题。望解答。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":498260,"discussion_content":"如果你使用了 launch::async 策略的话，是这样的。\n\n不过，实现有可能使用内存池来降低开销。按目前查到的资料，至少 MSVC 是使用内存池的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592153259,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":200633,"user_name":"湖海散人","can_delete":false,"product_type":"c1","uid":1096781,"ip_address":"","ucode":"74C0C825D74CC1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJe0esddRVdG689MicU5zMibMtkyLpYkX4MtiamKP8eFf7KUoMlfU7ficrciakyVS06jHVdskYT67JKtdg/132","comment_is_top":false,"comment_ctime":1585626639,"is_pvip":false,"replies":[{"id":75158,"content":"1. 看第 9 讲，自定义字面量。\n\n2. 线程间本来就是共享内存的，不需要管道之类的东西。只需要状态同步就可以。Python 的协程在 C++ 里的对应物见第 30 讲。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585661961,"ip_address":"","comment_id":200633,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"请教老师几个问题：\n1. sleep_for函数中的参数数字后面的&quot;ms&quot;, &quot;s&quot;是C++的什么特性呀，我用C++11编译不过，用C++17正常\n2. 对于async，future的用法，是怎么拿到另一个线程的返回值的？ 是future内部使用了管道？这个async和future和python里面的协程很像","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490082,"discussion_content":"1. 看第 9 讲，自定义字面量。\n\n2. 线程间本来就是共享内存的，不需要管道之类的东西。只需要状态同步就可以。Python 的协程在 C++ 里的对应物见第 30 讲。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585661961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195575,"user_name":"徐洲更","can_delete":false,"product_type":"c1","uid":1314643,"ip_address":"","ucode":"F8A323CB732D05","user_header":"https://static001.geekbang.org/account/avatar/00/14/0f/53/92a50f01.jpg","comment_is_top":false,"comment_ctime":1585198478,"is_pvip":false,"replies":[{"id":74463,"content":"三十讲来讲C++，不浓缩不行啊……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1585316342,"ip_address":"","comment_id":195575,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"在系列完结以后才开始阅读。最初买专栏以为自己能看懂，结果直接懵逼了。现在终于写了一些c++代码，才发现这系列都是浓缩的精华，每次读都有新收获啊","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489114,"discussion_content":"三十讲来讲C++，不浓缩不行啊……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585316342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":191212,"user_name":"晚风·和煦","can_delete":false,"product_type":"c1","uid":1236047,"ip_address":"","ucode":"0B1DB8F437A4B2","user_header":"","comment_is_top":false,"comment_ctime":1584754980,"is_pvip":false,"replies":[{"id":73562,"content":"不太理解这个问题。不过，同一个进程中的多个线程共享相同的地址空间，所以，也许对你这个问题的回答是“是”。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1584875597,"ip_address":"","comment_id":191212,"utype":1}],"discussion_count":3,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"老师，线程的虚拟内存大小都一样大吗？😂","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489114,"discussion_content":"三十讲来讲C++，不浓缩不行啊……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585316342,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":170632,"user_name":"三味","can_delete":false,"product_type":"c1","uid":1362403,"ip_address":"","ucode":"A580F715D1CC96","user_header":"https://static001.geekbang.org/account/avatar/00/14/c9/e3/28c16afa.jpg","comment_is_top":false,"comment_ctime":1578647269,"is_pvip":false,"replies":[{"id":66140,"content":"编译期编程确实是 C++ 里比较好玩的部分，但也容易被滥用，还容易把新手全吓跑……","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578668056,"ip_address":"","comment_id":170632,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"普大喜奔！\n🍾🍾🎉🎉🎊🎊\n模板章节终于结束了！\n其实我还没学够呢（真心）\n\n其实死锁这玩意太容易出现了。描述一个比较经典的场景，A,B两个线程，a,b两个资源，两个线程都要用两个资源。\nA线程先用资源a，锁住资源a；\nB线程先用资源b，锁住资源b；\nA线程还需要资源b，但是不能放开资源a，因为没用完；\nB线程还需要资源a，但是也不能放开资源b，因为没用完；\nA线程占着a不放还想用b，B线程占着b不放还想用a；\nA说，你先给我用b，我用完b，我肯定ab一起放；\nB说，为啥你不给我用a，我用完a，我肯定ab一起放；\n任务管理器说：你们都死吧。","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481048,"discussion_content":"编译期编程确实是 C++ 里比较好玩的部分，但也容易被滥用，还容易把新手全吓跑……","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578668056,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":169762,"user_name":"tt","can_delete":false,"product_type":"c1","uid":1489957,"ip_address":"","ucode":"7753B79AD5A9AC","user_header":"https://static001.geekbang.org/account/avatar/00/16/bc/25/1c92a90c.jpg","comment_is_top":false,"comment_ctime":1578443669,"is_pvip":false,"replies":[{"id":65897,"content":"future的设计原则我不熟。我是挺希望跟promise联用能复用，真当成管道。但目前不支持。也许以后可以。并发方面，C++的标准机制还缺不少东西的，同步只用标准库的话很难。不过C++20会加不少新东西。\n\n用词方面的相同应该和语言实现是否用C++没关系。并发方面有很多前沿的文献，标准术语应该早就有不少了吧。而且，标准的Python实现，CPython，是纯C写的。","user_name":"作者回复","user_name_real":"吴咏炜","uid":1645639,"ctime":1578459435,"ip_address":"","comment_id":169762,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100040501,"comment_content":"烧脑的编译期内容终于结束了。每天在工作之余烧一会儿，还没烧透呢，就结束了。是该庆幸还是该解脱呢？\n\n感觉编译期编程就是C++中的理论物理，需要纸和笔，然后适应一大堆符号。\n\nfeature只能使用一次，是为了避免多次使用带来的循环获取锁从而导致死锁么？\n\n\n读书的时候先学的就是C++，并且为其微妙的语义而着迷，可以工作中很少用到它。接触future, promise, async是从Python和JavaScript开始的。虽然这三种语言互补相同，可是在异步或者并发上，用的关键词竟然都是一样的，真是聪明的脑袋都是类似的，愚笨的脑袋各有不同啊。\n\n这个巧合也许因为Python和JavaScript底层都是用c&#47;c++实现的？","like_count":0,"discussions":[{"author":{"id":1645639,"avatar":"https://static001.geekbang.org/account/avatar/00/19/1c/47/53c48284.jpg","nickname":"吴咏炜","note":"","ucode":"8C24C10AEC779F","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480710,"discussion_content":"future的设计原则我不熟。我是挺希望跟promise联用能复用，真当成管道。但目前不支持。也许以后可以。并发方面，C++的标准机制还缺不少东西的，同步只用标准库的话很难。不过C++20会加不少新东西。\n\n用词方面的相同应该和语言实现是否用C++没关系。并发方面有很多前沿的文献，标准术语应该早就有不少了吧。而且，标准的Python实现，CPython，是纯C写的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578459435,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241704,"user_name":"道隐","can_delete":false,"product_type":"c1","uid":1065747,"ip_address":"","ucode":"DACA3DF0BEFF06","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/13/0b203112.jpg","comment_is_top":false,"comment_ctime":1597395389,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"第一个例子WSL上实测始终是A B, VS2015上体现出随机。感觉WSL是个伪多线程的环境","like_count":0},{"had_liked":false,"id":169768,"user_name":"舍得","can_delete":false,"product_type":"c1","uid":1147685,"ip_address":"","ucode":"2146A08D2D79B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/25/10dac87c.jpg","comment_is_top":false,"comment_ctime":1578444566,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"nice","like_count":0},{"had_liked":false,"id":241704,"user_name":"道隐","can_delete":false,"product_type":"c1","uid":1065747,"ip_address":"","ucode":"DACA3DF0BEFF06","user_header":"https://static001.geekbang.org/account/avatar/00/10/43/13/0b203112.jpg","comment_is_top":false,"comment_ctime":1597395389,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"第一个例子WSL上实测始终是A B, VS2015上体现出随机。感觉WSL是个伪多线程的环境","like_count":0},{"had_liked":false,"id":169768,"user_name":"舍得","can_delete":false,"product_type":"c1","uid":1147685,"ip_address":"","ucode":"2146A08D2D79B6","user_header":"https://static001.geekbang.org/account/avatar/00/11/83/25/10dac87c.jpg","comment_is_top":false,"comment_ctime":1578444566,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":4,"product_id":100040501,"comment_content":"nice","like_count":0}]}