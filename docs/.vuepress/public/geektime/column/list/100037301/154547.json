{"id":154547,"title":"05 | 聚合和聚合根：怎样设计聚合？","content":"<p>你好，我是欧创新。今天我们来学习聚合（Aggregate）和聚合根（AggregateRoot）。</p><p>我们先回顾下上一讲，在事件风暴中，我们会根据一些业务操作和行为找出实体（Entity）或值对象（ValueObject），进而将业务关联紧密的实体和值对象进行组合，构成聚合，再根据业务语义将多个聚合划定到同一个限界上下文（Bounded Context）中，并在限界上下文内完成领域建模。</p><p>那你知道为什么要在限界上下文和实体之间增加聚合和聚合根这两个概念吗？它们的作用是什么？怎么设计聚合？这就是我们这一讲重点要关注的问题。</p><h2>聚合</h2><p>在DDD中，实体和值对象是很基础的领域对象。实体一般对应业务对象，它具有业务属性和业务行为；而值对象主要是属性集合，对实体的状态和特征进行描述。但实体和值对象都只是个体化的对象，它们的行为表现出来的是个体的能力。</p><p><strong>那聚合在其中起什么作用呢？</strong></p><p>举个例子。社会是由一个个的个体组成的，象征着我们每一个人。随着社会的发展，慢慢出现了社团、机构、部门等组织，我们开始从个人变成了组织的一员，大家可以协同一致的工作，朝着一个最大的目标前进，发挥出更大的力量。</p><p><span class=\"orange\">领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。</span></p><!-- [[[read_end]]] --><p>你可以这么理解，聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。</p><p>聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。按照这种方式设计出来的微服务很自然就是“高内聚、低耦合”的。</p><p>聚合在DDD分层架构里属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。聚合内实体以充血模型实现个体业务能力，以及业务逻辑的高内聚。跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现。比如有的业务场景需要同一个聚合的A和B两个实体来共同完成，我们就可以将这段业务逻辑用领域服务来实现；而有的业务逻辑需要聚合C和聚合D中的两个服务共同完成，这时你就可以用应用服务来组合这两个服务。</p><h2>聚合根</h2><p>聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。</p><p>传统数据模型中的每一个实体都是对等的，如果任由实体进行无控制地调用和数据修改，很可能会导致实体之间数据逻辑的不一致。而如果采用锁的方式则会增加软件的复杂度，也会降低系统的性能。</p><p><span class=\"orange\">如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。</span></p><p>首先它作为实体本身，拥有实体的属性和业务行为，实现自身的业务逻辑。</p><p>其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。</p><p>最后在聚合之间，它还是聚合对外的接口人，以聚合根ID关联的方式接受外部任务和请求，在上下文内实现聚合之间的业务协同。也就是说，聚合之间通过聚合根ID关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。</p><h2>怎样设计聚合？</h2><p>DDD领域建模通常采用事件风暴，它通常采用用例分析、场景分析和用户旅程分析等方法，通过头脑风暴列出所有可能的业务行为和事件，然后找出产生这些行为的领域对象，并梳理领域对象之间的关系，找出聚合根，找出与聚合根业务紧密关联的实体和值对象，再将聚合根、实体和值对象组合，构建聚合。</p><p>下面我们以保险的投保业务场景为例，看一下聚合的构建过程主要都包括哪些步骤。</p><p><img src=\"https://static001.geekbang.org/resource/image/d4/dc/d4975de95bc31f954d11yyaee32a65dc.png?wh=1582*864\" alt=\"\"></p><p><strong>第 1 步：</strong>采用事件风暴，根据业务行为，梳理出在投保过程中发生这些行为的所有的实体和值对象，比如投保单、标的、客户、被保人等等。</p><p><strong>第 2 步：</strong>从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体是否是聚合根，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一ID？是否可以创建或修改其它对象？是否有专门的模块来管这个实体。图中的聚合根分别是投保单和客户实体。</p><p><strong>第 3 步：</strong>根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值对象。构建出 1 个包含聚合根（唯一）、多个实体和值对象的对象集合，这个集合就是聚合。在图中我们构建了客户和投保这两个聚合。</p><p><strong>第 4 步：</strong>在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。这里我需要说明一下：投保人和被保人的数据，是通过关联客户ID从客户聚合中获取的，在投保聚合里它们是投保单的值对象，这些值对象的数据是客户的冗余数据，即使未来客户聚合的数据发生了变更，也不会影响投保单的值对象数据。从图中我们还可以看出实体之间的引用关系，比如在投保聚合里投保单聚合根引用了报价单实体，报价单实体则引用了报价规则子实体。</p><p><strong>第 5 步：</strong>多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。</p><p>这就是一个聚合诞生的完整过程了。</p><h2>聚合的一些设计原则</h2><p>我们不妨先看一下《实现领域驱动设计》一书中对聚合设计原则的描述，原文是有点不太好理解的，我来给你解释一下。</p><p><strong>1. 在一致性边界内建模真正的不变条件。</strong>聚合用来封装真正的不变性，而不是简单地将对象组合在一起。聚合内有一套不变的业务规则，各实体和值对象按照统一的业务规则运行，实现对象数据的一致性，边界之外的任何东西都与该聚合无关，这就是聚合能实现业务高内聚的原因。</p><p><strong>2. 设计小聚合。</strong>如果聚合设计得过大，聚合会因为包含过多的实体，导致实体之间的管理过于复杂，高频操作时会出现并发冲突或者数据库锁，最终导致系统可用性变差。而小聚合设计则可以降低由于业务过大导致聚合重构的可能性，让领域模型更能适应业务的变化。</p><p><strong>3. 通过唯一标识引用其它聚合。</strong>聚合之间是通过关联外部聚合根ID的方式引用，而不是直接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。</p><p><strong>4. 在边界之外使用最终一致性。</strong>聚合内数据强一致性，而聚合之间数据最终一致性。在一次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应采用领域事件的方式异步修改相关的聚合，实现聚合之间的解耦（相关内容我会在领域事件部分详解）。</p><p><strong>5. 通过应用层实现跨聚合的服务调用。</strong>为实现微服务内聚合之间的解耦，以及未来以聚合为单位的微服务组合和拆分，应避免跨聚合的领域服务调用和跨聚合的数据库表关联。</p><p>上面的这些原则是DDD的一些通用的设计原则，还是那句话：“适合自己的才是最好的。”在系统设计过程时，你一定要考虑项目的具体情况，如果面临使用的便利性、高性能要求、技术能力缺失和全局事务管理等影响因素，这些原则也并不是不能突破的，总之一切以解决实际问题为出发点。</p><h2>总结</h2><p><a href=\"https://time.geekbang.org/column/article/152677\">[第04讲]</a> 和 [第05讲] 的内容，其实是有强关联的。我们不妨在这里总结下聚合、聚合根、实体和值对象它们之间的联系和区别。</p><p><strong>聚合的特点：</strong>高内聚、低耦合，它是领域模型中最底层的边界，可以作为拆分微服务的最小单位，但我不建议你对微服务过度拆分。但在对性能有极致要求的场景中，聚合可以独立作为一个微服务，以满足版本的高频发布和极致的弹性伸缩能力。</p><p>一个微服务可以包含多个聚合，聚合之间的边界是微服务内天然的逻辑边界。有了这个逻辑边界，在微服务架构演进时就可以以聚合为单位进行拆分和组合了，微服务的架构演进也就不再是一件难事了。</p><p><strong>聚合根的特点：</strong>聚合根是实体，有实体的特点，具有全局唯一标识，有独立的生命周期。一个聚合只有一个聚合根，聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调，聚合根与聚合根之间通过ID关联的方式实现聚合之间的协同。</p><p><strong>实体的特点：</strong>有ID标识，通过ID判断相等性，ID在聚合内唯一即可。状态可变，它依附于聚合根，其生命周期由聚合根管理。实体一般会持久化，但与数据库持久化对象不一定是一对一的关系。实体可以引用聚合内的聚合根、实体和值对象。</p><p><strong>值对象的特点：</strong>无ID，不可变，无生命周期，用完即扔。值对象之间通过属性值判断相等性。它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征。值对象尽量只引用值对象。</p><h2>思考题</h2><p>请你结合公司的某个业务场景，试试能分析出哪些聚合？</p><p>欢迎留言和我分享你的思考，你也可以把今天所学分享给身边的朋友，邀请他加入探讨，共同进阶。</p><p><img src=\"https://static001.geekbang.org/resource/image/7b/33/7b1a917aff0ec923b78a54e81ed90733.jpg?wh=1110*659\" alt=\"unpreview\"></p>","neighbors":{"left":{"article_title":"04 | 实体和值对象：从领域模型的基础单元看系统设计","id":152677},"right":{"article_title":"06 | 领域事件：解耦微服务的关键","id":155444}},"comments":[{"had_liked":false,"id":144035,"user_name":"南山","can_delete":false,"product_type":"c1","uid":1119593,"ip_address":"","ucode":"94656FE4A6C378","user_header":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","comment_is_top":true,"comment_ctime":1571829814,"is_pvip":true,"replies":[{"id":"55627","content":"我先理解一下你说的业务场景哈。不知道理解的对不对？不对的地方请你指出。由于不好展示事件风暴的过程，我就口述吧。<br>你描述的业务场景主要包括这两个部分吧。<br>流程一：创建任务<br>1、根据任务规则获取任务基础数据，生成任务。（产生任务已创建事件，领域对象包括：任务生成的基础数据、数据过滤规则、任务、任务类型）    <br>2、自动将任务分配给销售。（销售的数据应该来源于其他系统，这个过程实际上是一个给任务赋值的过程，领域对象包括：销售）<br>3、销售领取任务。（给任务分配销售）<br>这个过程领域对象包括：基础数据、数据过滤规则、任务、任务类型、销售。<br>命令有：创建任务，给任务分配销售。<br>领域事件有：任务已创建。<br><br>流程二、任务执行<br>1、销售查询并获取任务，执行任务。（不清楚你说的字段在这个过程是什么含义，是查询时勾选类型吗）<br>2、任务执行完成后，记录执行结果，产生任务执行日志。（产生任务执行日志已创建事件，领域对象有：任务、任务日志）<br>3、统计日志。这一块不清楚你的业务逻辑和流程。<br>因为有统计日志，是不是就会去查询任务的执行日志，如果是这样的话，任务日志就需要设计为实体，跟任务关联，这里任务是聚合根。<br>这个阶段的领域对象有：任务和任务执行日志。<br>命令有：查询任务，生成任务执行日志。<br>领域事件有：执行任务日志已创建。<br><br>结合这两个流程，我们整体来分析一下。<br>领域对象包括：基础数据、数据过滤规则、任务、销售、任务类型、任务执行日志。<br>由于销售人员数据来源于第三方，以值的形式存储在任务中，因此我们可以将它设计为任务的值对象。<br>任务执行日志依附于任务，但是由于它后续要做查询和统计分析，因此将它设计为被任务引用的实体。<br>任务类型是任务的值对象<br>其它的基础数据、数据过滤规则这两个领域对象很独立，你可以理解他们是独立的实体，或者说一个实体就是一个聚合。<br>但是这样设计在代码目录设计时会显得比较单薄，一个聚合会有一个仓储和聚合自己的代码目录结构。因此我们可以将这两个实体可以直接放在任务的聚合里，但是他们的生命周期不受任务这个聚合根管理。<br>这样的话，我们就可以只建立一个任务聚合。这个聚合的聚合根是任务。它引用的实体包括任务执行日志，任务的值对象有：销售、任务类型。还有两个独立实体：基础数据和数据过滤规则。<br>说明一下：<br>在不少的数据统计和计算场景中，有很多实体之间相互独立，只参与计算和统计分析，但是这类场景中业务内聚性又很高，你找不出管理这些实体的聚合根。我称这种业务模型是非典型领域模型。虽然有些方面（比如聚合根）不符合DDD的一些原则，但是我们也可以按照DDD方法来完成设计。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571882701,"ip_address":"","comment_id":144035,"utype":1}],"discussion_count":6,"race_medal":0,"score":"9.2233725495276995e+18","product_id":100037301,"comment_content":"老师，麻烦有空帮忙看一下<br>场景：电销<br>根据任务类型的属性创建具体的定期执行任务，调度器把到点的任务放到执行器里去执行。执行完了等待下一次执行，对任务生成的明细可以填写沟通记录（第三方服务）但是本服务要提供此字段查询<br>过程中记录统计日志。每个任务类型在查询他的任务时查询和列表展示字段集合都不一样<br>任务执行过程：从数据源获取数据 -&gt; 根据任务配置的过滤规则过滤 -&gt; 生成任务明细（有过期时间） -&gt; 1.自动分配给销售&#47;2.销售主动去领单，过程中生成任务执行日志，统计日志<br><br>领域对象：任务类型、任务、任务明细、日志、过滤规则、字段、销售、<br>聚合A：聚合根-任务，任务明细-实体，值对象：日志、任务类型、销售<br>聚合B：聚合根-过滤规则，<br>聚合C：聚合根-字段，值对象，展示字段属性定义集合、查询字段属性定义集合<br><br>问题：<br>  1.一个聚合中，允不允许只有一个实体和一些属性值？<br>  2.是否合理？不合理该怎么设计呢？<br>  3.任务是根据任务类型创建出来的，聚合A是不是不合理？或者实体的初始化可不可以依赖它的值对象呢？<br>  4.任务类型决定它可以进行哪些过滤，实际创建任务时才会真正选择使用哪些过滤规则，过滤规则算什么呢？能作为一个独立的聚合吗？<br>  5.字段也是同样的，并且字段是没有一个生命周期的，这种情况下是不是作为值对象更合理？ 但是聚合A和B都用到了字段，值对象能在多个聚合公用吗？","like_count":120,"discussions":[{"author":{"id":1705156,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/04/c4/ef4bd241.jpg","nickname":"Geek_a91670","note":"","ucode":"6CAA9FF890F8EA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":40624,"discussion_content":"真的要给欧老师点赞,可读性那么欠佳的问题都能梳理得那么有条理,赞一个","likes_number":19,"is_delete":false,"is_hidden":false,"ctime":1572245739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471788,"discussion_content":"我先理解一下你说的业务场景哈。不知道理解的对不对？不对的地方请你指出。由于不好展示事件风暴的过程，我就口述吧。\n你描述的业务场景主要包括这两个部分吧。\n流程一：创建任务\n1、根据任务规则获取任务基础数据，生成任务。（产生任务已创建事件，领域对象包括：任务生成的基础数据、数据过滤规则、任务、任务类型）    \n2、自动将任务分配给销售。（销售的数据应该来源于其他系统，这个过程实际上是一个给任务赋值的过程，领域对象包括：销售）\n3、销售领取任务。（给任务分配销售）\n这个过程领域对象包括：基础数据、数据过滤规则、任务、任务类型、销售。\n命令有：创建任务，给任务分配销售。\n领域事件有：任务已创建。\n\n流程二、任务执行\n1、销售查询并获取任务，执行任务。（不清楚你说的字段在这个过程是什么含义，是查询时勾选类型吗）\n2、任务执行完成后，记录执行结果，产生任务执行日志。（产生任务执行日志已创建事件，领域对象有：任务、任务日志）\n3、统计日志。这一块不清楚你的业务逻辑和流程。\n因为有统计日志，是不是就会去查询任务的执行日志，如果是这样的话，任务日志就需要设计为实体，跟任务关联，这里任务是聚合根。\n这个阶段的领域对象有：任务和任务执行日志。\n命令有：查询任务，生成任务执行日志。\n领域事件有：执行任务日志已创建。\n\n结合这两个流程，我们整体来分析一下。\n领域对象包括：基础数据、数据过滤规则、任务、销售、任务类型、任务执行日志。\n由于销售人员数据来源于第三方，以值的形式存储在任务中，因此我们可以将它设计为任务的值对象。\n任务执行日志依附于任务，但是由于它后续要做查询和统计分析，因此将它设计为被任务引用的实体。\n任务类型是任务的值对象\n其它的基础数据、数据过滤规则这两个领域对象很独立，你可以理解他们是独立的实体，或者说一个实体就是一个聚合。\n但是这样设计在代码目录设计时会显得比较单薄，一个聚合会有一个仓储和聚合自己的代码目录结构。因此我们可以将这两个实体可以直接放在任务的聚合里，但是他们的生命周期不受任务这个聚合根管理。\n这样的话，我们就可以只建立一个任务聚合。这个聚合的聚合根是任务。它引用的实体包括任务执行日志，任务的值对象有：销售、任务类型。还有两个独立实体：基础数据和数据过滤规则。\n说明一下：\n在不少的数据统计和计算场景中，有很多实体之间相互独立，只参与计算和统计分析，但是这类场景中业务内聚性又很高，你找不出管理这些实体的聚合根。我称这种业务模型是非典型领域模型。虽然有些方面（比如聚合根）不符合DDD的一些原则，但是我们也可以按照DDD方法来完成设计。","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1571882701,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1264687,"avatar":"https://static001.geekbang.org/account/avatar/00/13/4c/2f/3ec98bc1.jpg","nickname":"平衡的红果","note":"","ucode":"FC06861D00B9B1","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":311124,"discussion_content":"因此我们可以将这两个实体可以直接放在任务的聚合里，但是他们的生命周期不受任务这个聚合根管理。这句话怎么理解？聚合根里面的实体的生命周期可以和聚合根不一致吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602230439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39128,"discussion_content":"我在基于DDD的微服务设计中，微服务的功能和架构演进是以聚合为单位来演进的。所以为了代码重构方便，我将一个聚合的所有功能和代码，包括仓储服务都放在一个聚合的目录下。如果微服务需要做功能重构，只需要对聚合的代码做整体搬迁就可以了，微服务重构的速度会很快。如果一个实体一个仓储，在代码目录结构里就显得有点单薄了。如果它与聚合都属于同一个业务域，我建议将它们放在一个聚合内。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571894772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1119593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","nickname":"南山","note":"","ucode":"94656FE4A6C378","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":39318,"discussion_content":"我现在还不是太清楚仓储的功能范围不是太明确，现在的服务中吧实体的增删改查以及实体中值对象的查询大部分都放在了仓储中，并且方法的粒度比较细，所以单个实体的仓储代码量都不少了，感觉这样的实现不合理，违背了一些ddd的设计的理论，比如值对象应该通过实体来获取，实体应该通过聚合根来获取。\n但是感觉通过聚合根导航路径长的话会不会代码比较啰嗦？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571911735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":39128,"ip_address":""},"score":39318,"extra":""}]},{"author":{"id":1119593,"avatar":"https://static001.geekbang.org/account/avatar/00/11/15/69/187b9968.jpg","nickname":"南山","note":"","ucode":"94656FE4A6C378","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39096,"discussion_content":"给老师点赞，理解基本都是我想描述的。\n就跟老师结尾说的一样，也是因为自己对ddd理解的不是很清楚，觉得现在的这个服务只是借鉴了ddd的部分思想。\n还有一个问题，一个聚合一个仓储，如果实体功能和属性比较多，这个仓储的代码会不会很多，一个实体一个仓储会有什么问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571890323,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146196,"user_name":"胖虎","can_delete":false,"product_type":"c1","uid":1189627,"ip_address":"","ucode":"16834595992FD2","user_header":"https://static001.geekbang.org/account/avatar/00/12/26/fb/5a19b53e.jpg","comment_is_top":false,"comment_ctime":1572452789,"is_pvip":false,"replies":[{"id":"56451","content":"电商里面比较典型的几个聚合根，比如：库存、商品、订单等等。<br>以订单为例，订单在聚合里是聚合根，与订单关联的有订单明细和收货地址。订单明细包括商品ID,商品名称，价格以及数量等信息，由于订单明细是多个，它是一个集合，它被设计为实体，被订单引用。而订单只有一个收货地址，这个收货地址的值来源于你个人中心维护的收货地址，收货地址只能被整体替换，所以它被设计为值对象。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572485528,"ip_address":"","comment_id":146196,"utype":1}],"discussion_count":6,"race_medal":0,"score":"151896308149","product_id":100037301,"comment_content":"老师，能用电商的例子说一下聚合根的使用场景嘛","like_count":36,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472748,"discussion_content":"电商里面比较典型的几个聚合根，比如：库存、商品、订单等等。\n以订单为例，订单在聚合里是聚合根，与订单关联的有订单明细和收货地址。订单明细包括商品ID,商品名称，价格以及数量等信息，由于订单明细是多个，它是一个集合，它被设计为实体，被订单引用。而订单只有一个收货地址，这个收货地址的值来源于你个人中心维护的收货地址，收货地址只能被整体替换，所以它被设计为值对象。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1572485528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46062,"discussion_content":"个人感觉还是值对象比较好，存ID的话，个人中心的地址修改后，订单就不知道往哪里发了。你可以采用属性嵌入的方式。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573116528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1096652,"avatar":"https://static001.geekbang.org/account/avatar/00/10/bb/cc/fac12364.jpg","nickname":"xxx","note":"","ucode":"E79CEA70430449","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385508,"discussion_content":"订单明细是订单行的集合。那么订单行看起来就是值对象了，因为它脱离了订单就没有意义。值对象的集合，简单存储就是一个字段放json，如果集合很大，就可以用表关联的方式。所以持久化方式可以灵活选择。妙啊！如果采用数据建模的方式，订单明细和订单行就是一对多，显然是2个表，万万是不会想到采用json方式的！","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1627102294,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":44767,"discussion_content":"觉得适合值对象的情况很少，根据收货地址会统计，还要根据收获地分仓库，这个地址是存值好呢还是地址的id好呢？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1572964767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1194551,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/37/06440c7f.jpg","nickname":"fish","note":"","ucode":"ABA0945C8B9615","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1149022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","nickname":"scmath","note":"","ucode":"641023BB246C29","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":218035,"discussion_content":"个人理解:订单中的收货地址可以设计成值对象(非大对象)，这也是可以被查询的，他跟订单实在一个数据表中，","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585616048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":44767,"ip_address":""},"score":218035,"extra":""},{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1194551,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3a/37/06440c7f.jpg","nickname":"fish","note":"","ucode":"ABA0945C8B9615","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543321,"discussion_content":"对 这样也方便查询 只是另外一种存储方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641088750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":218035,"ip_address":""},"score":543321,"extra":""}]}]},{"had_liked":false,"id":144429,"user_name":"渊虹","can_delete":false,"product_type":"c1","uid":1197459,"ip_address":"","ucode":"A041AD241B8E3F","user_header":"https://static001.geekbang.org/account/avatar/00/12/45/93/6ad60b12.jpg","comment_is_top":false,"comment_ctime":1571920071,"is_pvip":false,"replies":[{"id":"55677","content":" 被保人这个值对象以属性嵌入的方式嵌入保单聚合根中，查询客户保单时你不需要到客户聚合去查询客户信息了，直接根据客户信息在投保聚合查保单就可以了，当然这个客户信息不只是ID。<br>说明一下：这个跨聚合引用是在生成保单的时候，通过客户聚合根查询获取的客户信息，从客户聚合获取客户信息后，客户的信息就作为值对象的值嵌入到了保单实体中。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571923567,"ip_address":"","comment_id":144429,"utype":1}],"discussion_count":12,"race_medal":0,"score":"96061200583","product_id":100037301,"comment_content":"老师，有个问题不明白，麻烦解惑。投保聚合和客户聚合中，投保人和被保人跨聚合引用到客户的id，需求是查询以客户s为被保人的保单。就需要跨过聚合根，直接访问被保人这个值对象。这个是不是和只能通过聚合根访问聚合内其他对象的理论不一致","like_count":22,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471935,"discussion_content":" 被保人这个值对象以属性嵌入的方式嵌入保单聚合根中，查询客户保单时你不需要到客户聚合去查询客户信息了，直接根据客户信息在投保聚合查保单就可以了，当然这个客户信息不只是ID。\n说明一下：这个跨聚合引用是在生成保单的时候，通过客户聚合根查询获取的客户信息，从客户聚合获取客户信息后，客户的信息就作为值对象的值嵌入到了保单实体中。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571923567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1476241,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqX7O1xyVk4Fc5mSBGVzUmIontscickprsTWaGEd3DsGg2J428KQIIm0TIkGnGRiakrqKkqa5jsyP4Q/132","nickname":"Geek_b1a865","note":"","ucode":"998358CAD3525F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":54667,"discussion_content":"如果客户信息变化了，那保单中的客户值对象数据会不会就不正确了","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1574308546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1461799,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/N1bKtOjxbbIzQsDJB4NO44ib1qCaLF7ibeibKjK4hmlIpllMh0JsxjHGXr4EVahtNDQnrzw7mPNJQ2sfmrbtaqJLA/132","nickname":"dormi330","note":"","ucode":"E00521B33D59B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1476241,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqX7O1xyVk4Fc5mSBGVzUmIontscickprsTWaGEd3DsGg2J428KQIIm0TIkGnGRiakrqKkqa5jsyP4Q/132","nickname":"Geek_b1a865","note":"","ucode":"998358CAD3525F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":127153,"discussion_content":"我觉得保单只记录当时的客户快照信息，后续的客户信息变更是不应该反过来影响保单","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1578568881,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54667,"ip_address":""},"score":127153,"extra":""},{"author":{"id":1001694,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/48/de/d9a88304.jpg","nickname":"CHEN川","note":"","ucode":"4B4D11141A68B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1476241,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqX7O1xyVk4Fc5mSBGVzUmIontscickprsTWaGEd3DsGg2J428KQIIm0TIkGnGRiakrqKkqa5jsyP4Q/132","nickname":"Geek_b1a865","note":"","ucode":"998358CAD3525F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350835,"discussion_content":"我觉得保险其实是比较特殊的业务，因为投保人和被保人的信息基本是实名信息，不太可能会变化，所以在保险业务里，客户作为值对象保存在保单里面没有任何问题。\n\n而在一般的场景中，解决的办法其实有很多，比如，我们可以从前端层面解决，在根据客户查询保单时，不要直接使用用户名来查询，而是在前端使用下拉选项，先查询对应的用户信息即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614048113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54667,"ip_address":""},"score":350835,"extra":""},{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1476241,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqX7O1xyVk4Fc5mSBGVzUmIontscickprsTWaGEd3DsGg2J428KQIIm0TIkGnGRiakrqKkqa5jsyP4Q/132","nickname":"Geek_b1a865","note":"","ucode":"998358CAD3525F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353725,"discussion_content":"类似身份证号升位都需要手工确认，这时候是不是会修改原始保单信息？还是添加一条更新记录？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615196698,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":54667,"ip_address":""},"score":353725,"extra":""}]},{"author":{"id":1017181,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","nickname":"程序袁帅","note":"","ucode":"C281CA64EC91A7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":159575,"discussion_content":"作者补充的很好，只是没有解答提问者的问题，我补充一下我的理解：\n\n在文中的图中，被保人只是投保单聚合根的一个值对象，如果要查询s的客户对应的被保人信息，通过投保单聚合根去查询即可。从技术视角分析，数据库如果有一个投保单的表，那么被保人的信息只是这张表的几个column，所以还是通过查询投保单来查询。综合分析下来，其实没有绕过投保单聚合根。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1580708989,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1017181,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/85/5d/ec94b66d.jpg","nickname":"程序袁帅","note":"","ucode":"C281CA64EC91A7","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353723,"discussion_content":"明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615196568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":159575,"ip_address":""},"score":353723,"extra":""}]},{"author":{"id":1437715,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f0/13/e5d0355a.jpg","nickname":"杨志远","note":"","ucode":"24F0BF091EDCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293899,"discussion_content":"根据老师的解释，客户信息是在生成保单时，通过客户领域的聚合根查询到的，将查询到的客户信息作为值对象，填充到保单实体，生成保单实体对象。后续查询客户信息，可直接根据保单查询，无需再查客户聚合","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595722389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1399663,"avatar":"https://static001.geekbang.org/account/avatar/00/15/5b/6f/113e24e6.jpg","nickname":"阿信","note":"","ucode":"CC7B15CE63264B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":221637,"discussion_content":"我的理解：通过聚合根访问聚合内的对象，这个是描述跨聚合访问的场景。如A聚合访问B聚合，通过B聚合根对象访问。渊虹描述的问题，是在同一个聚合内做数据范围，并没有跨聚合。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586017161,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1162081,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bb/61/2c2f5024.jpg","nickname":"haijian.yang","note":"","ucode":"E3D13ABA2CA347","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211909,"discussion_content":"客户快照信息，就跟你在淘宝下单的商品快照一个意思。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584892403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1126396,"avatar":"https://static001.geekbang.org/account/avatar/00/11/2f/fc/246d2976.jpg","nickname":"丁丁","note":"","ucode":"585D7CBACA1B92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124851,"discussion_content":"不能算不正确，保单那时的状态，客户就是叫那个名字，这个其实是非常合理的。如果业务上需要同步，我理解应该用事件异步同步。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1578453768,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2411361,"avatar":"","nickname":"齐斌","note":"","ucode":"1BFCD51E2F27BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341320,"discussion_content":"被保人，投保人都可能是团体或者个人，如果都作为值对象，比如json方式存储到投保单表里面，那么搜索的时候，如果只根据投保人姓名或被保人姓名，感觉没有办法有效搜索啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610376071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145566,"user_name":"stg609","can_delete":false,"product_type":"c1","uid":1073025,"ip_address":"","ucode":"FB70A75A891BB8","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/81/1c614f4a.jpg","comment_is_top":false,"comment_ctime":1572316839,"is_pvip":false,"replies":[{"id":"56179","content":"非常感谢！<br>首先你说的外界，要明确一下，这个外界是微服务内，不同的层之间？还是指微服务之间，也就是微服务外部调用。<br>如果是在微服务内，不同层之间的话，由于运行在同一个微服务内，实体是可以被其它高层服务获取的，这时实体以DO对象的形式，存在于应用层和领域层，你可以使用DO对象的方法。但是不建议将实体的方法编排放在应用层，而是在领域层封装成领域服务后暴露给应用层。<br>如果这个外界是微服务之间的话，你需要将实体DO数据转换为DTO对象后，才能被外界使用，这时，外界是不能调用实体的方法的，因此可以隐藏实体核心业务逻辑的实现方式。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572318206,"ip_address":"","comment_id":145566,"utype":1}],"discussion_count":1,"race_medal":0,"score":"87471662759","product_id":100037301,"comment_content":"首先，几乎每个留言都会评论！必须给个大大的赞！<br><br>其次，我有3个疑问，<br>1. 聚合中可能会有实体，那允不允许直接把实体类型作为属性的类型或返回值暴露给外界？<br>2. 如果允许，那外界就可以直接获取其中的实体，然后调用者可以直接使用实体中的一些相关方法？这样似乎就违反了聚合很的设计？<br>3. 如果不允许，那外界如果需要得到某个实体的数据，要怎么操作？封装成 DTO 吗？<br><br>比如: Aggregate a 中包含一个b属性，b是一个实体。b 中包含操作该实体的方法 M。那外界调用a.b 就会直接获取到 b 这个实体，然后可以直接调用 M 方法。","like_count":20,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472468,"discussion_content":"非常感谢！\n首先你说的外界，要明确一下，这个外界是微服务内，不同的层之间？还是指微服务之间，也就是微服务外部调用。\n如果是在微服务内，不同层之间的话，由于运行在同一个微服务内，实体是可以被其它高层服务获取的，这时实体以DO对象的形式，存在于应用层和领域层，你可以使用DO对象的方法。但是不建议将实体的方法编排放在应用层，而是在领域层封装成领域服务后暴露给应用层。\n如果这个外界是微服务之间的话，你需要将实体DO数据转换为DTO对象后，才能被外界使用，这时，外界是不能调用实体的方法的，因此可以隐藏实体核心业务逻辑的实现方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572318206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143793,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1571793226,"is_pvip":true,"replies":[{"id":"55515","content":"说到充血模型，就离不开贫血模型。<br>先说一下贫血模型吧，贫血模型是指使用的领域对象中只有setter和getter方法，所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。<br>而充血模型将大多数业务逻辑放在领域实体中实现，实体本身包含了属性和它的业务行为，它在领域模型中就是一个具有业务行为和逻辑的基本业务单元。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571797507,"ip_address":"","comment_id":143793,"utype":1}],"discussion_count":5,"race_medal":0,"score":"57406368074","product_id":100037301,"comment_content":"什么是充血模型","like_count":13,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471689,"discussion_content":"说到充血模型，就离不开贫血模型。\n先说一下贫血模型吧，贫血模型是指使用的领域对象中只有setter和getter方法，所有的业务逻辑都不包含在领域对象中而是放在业务逻辑层。\n而充血模型将大多数业务逻辑放在领域实体中实现，实体本身包含了属性和它的业务行为，它在领域模型中就是一个具有业务行为和逻辑的基本业务单元。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571797507,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488038,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b4/a6/b6fa2562.jpg","nickname":"渠梁","note":"","ucode":"DC86BDEC63C9BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555278,"discussion_content":"还是没太理解，充血模型除了基本属性外还有一些业务行为的话，而这个业务行为涉及多个实体的话，那不就违背单一职责原则了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646831800,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2089155,"avatar":"","nickname":"昌南一枝花","note":"","ucode":"66118BEFFDC9BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296175,"discussion_content":"网上说，DO只有getter、setter方法的叫失血模型，贫血模型DO允许有业务逻辑(比如校验、计算等)但不能直接调用DAO；充血模型则是DO可以调用DAO，老师怎么看？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596464476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39045,"discussion_content":"在DDD中持久化是通过仓储实现来实现的。实体通过调用仓储接口来实现持久化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571884447,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1237302,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e1/36/452106af.jpg","nickname":"m5jun","note":"","ucode":"CA51419232644B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38894,"discussion_content":"错不对吧，充血模型怎么可能关键持久化操作？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571844655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148600,"user_name":"美美","can_delete":false,"product_type":"c1","uid":1148422,"ip_address":"","ucode":"44CC95C45AF345","user_header":"https://static001.geekbang.org/account/avatar/00/11/86/06/72b01bb7.jpg","comment_is_top":false,"comment_ctime":1573036724,"is_pvip":false,"replies":[{"id":"57228","content":"后面会有建模方法的介绍。<br>你可以试着从用户旅程入手，根据流程看看会发生哪些领域事件，再找找是哪些命令触发这些领域事件的。梳理的差不多的时候，你就找找这些命令都是哪些实体的行为，这样就可以找出好多实体。根据实体可以找出聚合根，再根据聚合根找出关联的实体和值对象。这样聚合就找到了，然后对聚合划分限界上下文。这样就可以设计微服务了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573044257,"ip_address":"","comment_id":148600,"utype":1}],"discussion_count":2,"race_medal":0,"score":"53112644276","product_id":100037301,"comment_content":"老师，想请教一下<br>我们的场景是：商家后台上，商家可以进行门店管理，收银pos机相关的设置，营业相关的设置<br>背景：商家后台已经存在，且商家基础系统、门店基础信息、pos相关信息，数据模型已经存在，各调用方是直接访问数据库的<br>目标：将商家、门店的基础信息，经营设置信息，抽象出来形成商家域   统一对外提供能力<br><br>想通过DDD的思想来进行建模，感觉无从下手，麻烦老师提供点思路","like_count":12,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473548,"discussion_content":"后面会有建模方法的介绍。\n你可以试着从用户旅程入手，根据流程看看会发生哪些领域事件，再找找是哪些命令触发这些领域事件的。梳理的差不多的时候，你就找找这些命令都是哪些实体的行为，这样就可以找出好多实体。根据实体可以找出聚合根，再根据聚合根找出关联的实体和值对象。这样聚合就找到了，然后对聚合划分限界上下文。这样就可以设计微服务了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573044257,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":353727,"discussion_content":"这是类似外卖商家驻店吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615196825,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144030,"user_name":"密码123456","can_delete":false,"product_type":"c1","uid":1126593,"ip_address":"","ucode":"9889463CC0EA71","user_header":"https://static001.geekbang.org/account/avatar/00/11/30/c1/2dde6700.jpg","comment_is_top":false,"comment_ctime":1571828084,"is_pvip":false,"replies":[{"id":"55628","content":"类比的不错。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571882733,"ip_address":"","comment_id":144030,"utype":1}],"discussion_count":1,"race_medal":0,"score":"48816468340","product_id":100037301,"comment_content":"聚合。用界限上下文把细粒度的实体圈起来当做一个组织，选出组织的董事长。一个组织和另外一个组织交流的时候，只需要通过一个董事长，能够了解该组织的全部非隐私信息","like_count":12,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471784,"discussion_content":"类比的不错。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571882733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145709,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572349510,"is_pvip":false,"replies":[{"id":"56295","content":"两个出发点不一样，聚合根主要是从实体关联的角度，关注数据一致性。领域服务主要组合的是实体业务行为。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572397152,"ip_address":"","comment_id":145709,"utype":1}],"discussion_count":1,"race_medal":0,"score":"35932087878","product_id":100037301,"comment_content":"跨多个实体的业务逻辑通过领域服务来实现。<br>其次它作为聚合的管理者，在聚合内部负责协调实体和值对象按照固定的业务规则协同完成共同的业务逻辑。<br>怎么感觉 聚合根做的事情和领域服务一样？","like_count":9,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472540,"discussion_content":"两个出发点不一样，聚合根主要是从实体关联的角度，关注数据一致性。领域服务主要组合的是实体业务行为。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572397152,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241677,"user_name":"Geek_7c4953","can_delete":false,"product_type":"c1","uid":1809168,"ip_address":"","ucode":"359745D4725D4F","user_header":"","comment_is_top":false,"comment_ctime":1597388907,"is_pvip":false,"replies":[{"id":"89380","content":"我感觉收藏应该也是一个独立聚合，收藏会有聚合根，它会引用用户ID和课程ID这两个值对象。这样可以对用户和课程独立管理和维护，保证用户聚合和课程聚合的领域逻辑稳定。用户登录时，获取用户ID，然后将用户ID值对象作为查询条件从收藏聚合获取收藏记录，再通过收藏记录关联的课程ID从课程聚合获取课程的详细数据。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597633153,"ip_address":"","comment_id":241677,"utype":1}],"discussion_count":3,"race_medal":0,"score":"27367192683","product_id":100037301,"comment_content":"老师，对于关联两个聚合根的一种关系，应该划分到哪个聚合？<br>比如：<br>用户聚合根和课程聚合根。<br>用户收藏了一门课程，收藏这个操作关联了用户和课程，同时生成了一条收藏记录。<br>那么收藏记录是值对象还是实体，应该归于哪个聚合根？<br>如果作为实体，它似乎不需要ID去标识，因为一个用户ID，一个课程ID就可以标识这样一条记录。<br>如果作为值对象，又感觉不合适，因为我的感觉（仅仅是感觉）多值的值对象不应该能无限增长，但收藏这个操作是不可能限制数量的。","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503810,"discussion_content":"我感觉收藏应该也是一个独立聚合，收藏会有聚合根，它会引用用户ID和课程ID这两个值对象。这样可以对用户和课程独立管理和维护，保证用户聚合和课程聚合的领域逻辑稳定。用户登录时，获取用户ID，然后将用户ID值对象作为查询条件从收藏聚合获取收藏记录，再通过收藏记录关联的课程ID从课程聚合获取课程的详细数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597633153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2028945,"avatar":"","nickname":"Geek5198","note":"","ucode":"2BEBE6A39D9A0E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357867,"discussion_content":"老师这个思路不错，但是否可以推广呢？\n比如商品领域中，有商品子域、和品牌子域，商品聚合的聚合根是商品实体，品牌聚合的聚合根是品牌实体，商品和品牌的关系应该归属到哪一个聚合里呢？ 也是需要搞出一个独立的聚合，比如商品品牌关系聚合这样吗？ 类似的场景特别多，再比如类目聚合的聚合根是类目实体，那商品和类目的关系，又需要一个商品和类目关系聚合嘛","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615884851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1228290,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/02/43202976.jpg","nickname":"w 🍍","note":"","ucode":"F2386C971EC58B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2028945,"avatar":"","nickname":"Geek5198","note":"","ucode":"2BEBE6A39D9A0E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564241,"discussion_content":"我觉得关联关系是一种双向关系，本身是不能单独做为聚合的，而是要和实体一起，且双方都可以保存。 比如对于商品聚合，它有一个“相关的品牌列表”值对象，对于品牌列表，它有一个“相关的商品列表”值对象。 因为对于外界来说，a商品-b品牌关联是没意义的，外界需要知道a商品的品牌，或者b品牌的商品。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650198376,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":357867,"ip_address":""},"score":564241,"extra":""}]}]},{"had_liked":false,"id":143938,"user_name":"蜗牛慢慢爬","can_delete":false,"product_type":"c1","uid":1666095,"ip_address":"","ucode":"6591A58A582BE0","user_header":"https://static001.geekbang.org/account/avatar/00/19/6c/2f/8086c22a.jpg","comment_is_top":false,"comment_ctime":1571810172,"is_pvip":false,"replies":[{"id":"55555","content":"基础篇主要讲解DDD的基础概念和设计理念，所以相对抽象一些。后面会有中台业务建模和微服务设计案例，比较好理解。敬请期待。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571820657,"ip_address":"","comment_id":143938,"utype":1}],"discussion_count":2,"race_medal":0,"score":"27341613948","product_id":100037301,"comment_content":"听了这么多节课，总结一下还是太抽象了","like_count":6,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471750,"discussion_content":"基础篇主要讲解DDD的基础概念和设计理念，所以相对抽象一些。后面会有中台业务建模和微服务设计案例，比较好理解。敬请期待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571820657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1158795,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ae/8b/43ce01ca.jpg","nickname":"ezekiel","note":"","ucode":"AB4AB6FA8612D8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389926,"discussion_content":"概念结合适当的例子，更方便理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629516764,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":229167,"user_name":"","can_delete":false,"product_type":"c1","uid":1924055,"ip_address":"","ucode":"","user_header":"","comment_is_top":false,"comment_ctime":1592913994,"is_pvip":false,"replies":[{"id":"84650","content":"感谢哈，帮忙多推荐哦。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1592985273,"ip_address":"","comment_id":229167,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23067750474","product_id":100037301,"comment_content":"欧老师的课程，都是高级工程师和架构师级别的人购买，受众少，讲这么好，销量却不高，可惜了。","like_count":5,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499360,"discussion_content":"感谢哈，帮忙多推荐哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592985273,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":195348,"user_name":"winzheng","can_delete":false,"product_type":"c1","uid":1808505,"ip_address":"","ucode":"D78074036BB85D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJaPyAQvQx7BpTFjmEyDkQXLEcL2lEGjsoookic3Z25SJY0omzNUA3xCKt2F0hBqbxZMmrXX9v4TWQ/132","comment_is_top":false,"comment_ctime":1585182474,"is_pvip":false,"replies":[{"id":"74277","content":"它们的新增和修改是在客户的聚合里面。在投保单聚合里面它们就是值对象，它们的数据来源于客户聚合，不允许在投保单聚合单独修改，只可整体替换。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585193760,"ip_address":"","comment_id":195348,"utype":1}],"discussion_count":5,"race_medal":0,"score":"18765051658","product_id":100037301,"comment_content":"老师，投保人和被保人为什么被识别为值对象？他们是客户，具备实体的特征。","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489039,"discussion_content":"它们的新增和修改是在客户的聚合里面。在投保单聚合里面它们就是值对象，它们的数据来源于客户聚合，不允许在投保单聚合单独修改，只可整体替换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585193760,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2041034,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/24/ca/c60e9e46.jpg","nickname":"可缓缓归矣","note":"","ucode":"0B68F00EF7A92C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":286845,"discussion_content":"意思是如果客户信息变更了，就需要更新保单中的投保人信息和被保人信息？其次投保人和被保人的数据在保单中是以json数据的形式存储嘛？\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593309255,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2300345,"avatar":"","nickname":"Geek_1f2986","note":"","ucode":"9B5E9EE31EC632","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2041034,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/24/ca/c60e9e46.jpg","nickname":"可缓缓归矣","note":"","ucode":"0B68F00EF7A92C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":325185,"discussion_content":"同想问，客户信息变更了，保单中的投保人信息和被保人信息也要更新吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605251004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":286845,"ip_address":""},"score":325185,"extra":""},{"author":{"id":1435845,"avatar":"https://static001.geekbang.org/account/avatar/00/15/e8/c5/8bdb0bba.jpg","nickname":"DarKnight","note":"","ucode":"B04AFD03768827","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2300345,"avatar":"","nickname":"Geek_1f2986","note":"","ucode":"9B5E9EE31EC632","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":328975,"discussion_content":"在投保聚合内，投保人和被保人信息被设计为值对象，可以理解为属性数据冗余，在客户聚合内客户信息被更新了，对于其他聚合内存在的值对象（数据冗余），理应由领域事件来异步更新吧。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1606290369,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":325185,"ip_address":""},"score":328975,"extra":""}]},{"author":{"id":1808505,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJaPyAQvQx7BpTFjmEyDkQXLEcL2lEGjsoookic3Z25SJY0omzNUA3xCKt2F0hBqbxZMmrXX9v4TWQ/132","nickname":"winzheng","note":"","ucode":"D78074036BB85D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214954,"discussion_content":"谢谢，明白了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585266311,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146506,"user_name":"祥敏","can_delete":false,"product_type":"c1","uid":1205328,"ip_address":"","ucode":"466BFA980D9A37","user_header":"https://static001.geekbang.org/account/avatar/00/12/64/50/a54f0907.jpg","comment_is_top":false,"comment_ctime":1572561704,"is_pvip":false,"replies":[{"id":"56584","content":"如果数据一致性没什么问题，那就选择自己最合适的方式去做吧。但是一定要记住，边界要清晰，聚合之间的服务和数据不要耦合，耦合度太高，以后领域模型和微服务演进就很难。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572570590,"ip_address":"","comment_id":146506,"utype":1}],"discussion_count":3,"race_medal":0,"score":"18752430888","product_id":100037301,"comment_content":"您好，第四讲和第五讲都在讲述微服务内部的拆分与设计，是关系紧密的两讲，反复听了有三四遍略有收获和疑问。<br><br>从业务顺延的角度拆分，聚合、聚合根、实体、值对象这四个概念很好的模拟了业务的世界，就像面向对象所讲的一切皆对象，对象与对象之间的关系（聚合）。<br><br>疑惑有两点：持久化和实体之间关系的灵活性。<br><br>持久化（以关系型数据库为例）：聚合内部强一致性，聚合之间最终一致性。聚合是由多个遵循一定规则的实体组成，实体的描述由值对象组成，这样的问题在于聚合、实体、值对象和数据库之间的对应关系不够直接，同时事务管理也比非DDD的方式复杂，如果严格遵循DDD的原则去做，可能会在对象-&gt;数据库这个关节会有较多的问题要解决。<br><br>实体之间的关系：跨聚合之间实体不能直接发生关系，这个是否会不够灵活，实践中是否会引发一些问题？<br>","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472892,"discussion_content":"如果数据一致性没什么问题，那就选择自己最合适的方式去做吧。但是一定要记住，边界要清晰，聚合之间的服务和数据不要耦合，耦合度太高，以后领域模型和微服务演进就很难。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572570590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1253652,"avatar":"https://static001.geekbang.org/account/avatar/00/13/21/14/423a821f.jpg","nickname":"Steven","note":"","ucode":"3FE64459842015","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536221,"discussion_content":"减少耦合，为了未来的微服务划分留出空间？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638717663,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2089155,"avatar":"","nickname":"昌南一枝花","note":"","ucode":"66118BEFFDC9BF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296178,"discussion_content":"Martinflow是不是想按聚合拆分微服务？所以有聚合相关的各种原则","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596464799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":262453,"user_name":"马里奥的马里奥","can_delete":false,"product_type":"c1","uid":1048423,"ip_address":"","ucode":"6848D9E82B58E3","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/67/6ffe3a52.jpg","comment_is_top":false,"comment_ctime":1605744014,"is_pvip":false,"replies":[{"id":"95253","content":"在投保单聚合内，报价单属于被投保单聚合根引用的实体对象，如果其它聚合需要查看报价单实体的数据，则需要通过投保单ID查询到投保聚合根后，再找到报价单实体，然后访问报价单实体的数据。<br>而如果将报价设计为独立聚合的话，那么报价单就是报价聚合的聚合根。这样在投保单聚合将报价单设计为值对象可能会更合适一些，投保单聚合中的报价单值对象来源于报价单聚合。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605755534,"ip_address":"","comment_id":262453,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14490645902","product_id":100037301,"comment_content":"文中提到“聚合之间通过聚合根 ID 关联引用，如果需要访问其它聚合的实体，就要先访问聚合根，再导航到聚合内部实体，外部对象不能直接访问聚合内实体。”，但是在画的图中，投保单聚合根依赖报价单实体，那不就违反了只能通过聚合根访问实体吗？我想知道投保单是通过什么方式来访问报价单实体的。","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509838,"discussion_content":"在投保单聚合内，报价单属于被投保单聚合根引用的实体对象，如果其它聚合需要查看报价单实体的数据，则需要通过投保单ID查询到投保聚合根后，再找到报价单实体，然后访问报价单实体的数据。\n而如果将报价设计为独立聚合的话，那么报价单就是报价聚合的聚合根。这样在投保单聚合将报价单设计为值对象可能会更合适一些，投保单聚合中的报价单值对象来源于报价单聚合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605755534,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2693038,"avatar":"https://static001.geekbang.org/account/avatar/00/29/17/ae/f365efb0.jpg","nickname":"Quentin J.","note":"","ucode":"50B980CBE6EBA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":385511,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1627106476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244113,"user_name":"静心","can_delete":false,"product_type":"c1","uid":1335457,"ip_address":"","ucode":"EB264FA6519FDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","comment_is_top":false,"comment_ctime":1598404709,"is_pvip":true,"replies":[{"id":"89887","content":"在DDD的领域模型中聚合是一个逻辑边界概念，聚合本身没有业务逻辑实现相关的代码。聚合的业务逻辑是由聚合内的聚合根、实体、值对象和领域服务等来实现的。聚合没有ID，它不是实体，所以它没有class，就跟企业里面的部门一样，它只是一个组织名称上的概念，在部门内部的人员才是实体，部门内的若干人员一起构成聚合。每个聚合内有一个聚合根，多个实体、值对象和领域服务等领域对象，它们共同完成聚合的业务逻辑。<br>不清楚您说的文章列表所在的场景是什么样的？是查询后的文章清单结果吗？如果是查询列表结果的话，这个不是领域模型的概念。<br>在DDD中领域模型可以理解为在某一上下文边界内，由若干业务实体、行为或者由若干业务实体或行为组合而成，完成某个单一职责业务能力的对象组合。我们可以在领域模型内定义对象的依赖和组合关系。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1598424336,"ip_address":"","comment_id":244113,"utype":1}],"discussion_count":2,"race_medal":5,"score":"14483306597","product_id":100037301,"comment_content":"关于聚合和聚合根还是没完全理解，请教老师：<br>既然聚合和聚合根都是实体且具有全局唯一ID，那么聚合和聚合根应该在代码层放置在domain的entity目录下，且应该对应一个class。<br>按照聚合与聚合根的规则，那么聚合与聚合内实体的关系应该是一种组合关系。<br>但现实中还会有一种实体间的关系，这种集合与集合中的实体不是组合关系，而是一种列表和列表中元素的关系，如，文章列表与文章的关系，这种关系下，文章列表是没有唯一ID的。那么，想请教老师，对于这种关系，DDD中是如何表述的？文章列表是作为一个实体类存在好呢？还是把列表做成一个文章实体的方法好呢？<br>","like_count":4,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504487,"discussion_content":"在DDD的领域模型中聚合是一个逻辑边界概念，聚合本身没有业务逻辑实现相关的代码。聚合的业务逻辑是由聚合内的聚合根、实体、值对象和领域服务等来实现的。聚合没有ID，它不是实体，所以它没有class，就跟企业里面的部门一样，它只是一个组织名称上的概念，在部门内部的人员才是实体，部门内的若干人员一起构成聚合。每个聚合内有一个聚合根，多个实体、值对象和领域服务等领域对象，它们共同完成聚合的业务逻辑。\n不清楚您说的文章列表所在的场景是什么样的？是查询后的文章清单结果吗？如果是查询列表结果的话，这个不是领域模型的概念。\n在DDD中领域模型可以理解为在某一上下文边界内，由若干业务实体、行为或者由若干业务实体或行为组合而成，完成某个单一职责业务能力的对象组合。我们可以在领域模型内定义对象的依赖和组合关系。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598424336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1335457,"avatar":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","nickname":"静心","note":"","ucode":"EB264FA6519FDA","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301172,"discussion_content":"好的，感谢老师的耐心认真的回答，我说的是查询后的文章结果列表。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598432609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185235,"user_name":"勤快的懒洋洋","can_delete":false,"product_type":"c1","uid":1270265,"ip_address":"","ucode":"DBCEE8283B54F5","user_header":"https://static001.geekbang.org/account/avatar/00/13/61/f9/c94bb871.jpg","comment_is_top":false,"comment_ctime":1583541611,"is_pvip":false,"replies":[{"id":"71817","content":"仓储接口可以由实体方法调用（一般是聚合根），也可以由领域服务或应用服务调用。仓储一般是用于新增和修改数据，新增和修改数据通常有聚合根来统一管理，可以放在聚合根的方法里面，也可以用聚合内的领域服务来统一管理，通常对于实体较多的复杂的聚合，写入数据库前的DO到PO的转换或者PO到DO的实体数据初始化由工厂服务来统一管理。复杂查询一般不放在聚合内部，可以通过应用服务直接调用仓储查询接口来实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583721210,"ip_address":"","comment_id":185235,"utype":1}],"discussion_count":3,"race_medal":0,"score":"14468443499","product_id":100037301,"comment_content":"聚合里直接调用仓储吗，还是由应用服务层调用，为什么","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486301,"discussion_content":"仓储接口可以由实体方法调用（一般是聚合根），也可以由领域服务或应用服务调用。仓储一般是用于新增和修改数据，新增和修改数据通常有聚合根来统一管理，可以放在聚合根的方法里面，也可以用聚合内的领域服务来统一管理，通常对于实体较多的复杂的聚合，写入数据库前的DO到PO的转换或者PO到DO的实体数据初始化由工厂服务来统一管理。复杂查询一般不放在聚合内部，可以通过应用服务直接调用仓储查询接口来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583721210,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1128056,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/78/810b8dca.jpg","nickname":"钟","note":"","ucode":"687A6444808D8B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":540813,"discussion_content":"您好 如果应用服务直接调用仓储 那不就是实体直接暴露了吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640175410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":486301,"ip_address":""},"score":540813,"extra":""},{"author":{"id":1228290,"avatar":"https://static001.geekbang.org/account/avatar/00/12/be/02/43202976.jpg","nickname":"w 🍍","note":"","ucode":"F2386C971EC58B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1128056,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/78/810b8dca.jpg","nickname":"钟","note":"","ucode":"687A6444808D8B","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":564243,"discussion_content":"仓储可以直接返回DTO吧 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650198732,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":540813,"ip_address":""},"score":564243,"extra":""}]}]},{"had_liked":false,"id":172598,"user_name":"Jie","can_delete":false,"product_type":"c1","uid":1045078,"ip_address":"","ucode":"AB94041E548FEB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f2/56/c39046c0.jpg","comment_is_top":false,"comment_ctime":1579230887,"is_pvip":false,"replies":[{"id":"66936","content":"谢谢！","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579241155,"ip_address":"","comment_id":172598,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14464132775","product_id":100037301,"comment_content":"2天里一口气把01-05都看了，不仅仅是文字本身，留言回复都大大补充了专利内容，必须给这么认真的老师点个赞","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481788,"discussion_content":"谢谢！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579241155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143847,"user_name":"睁眼看世界","can_delete":false,"product_type":"c1","uid":1206388,"ip_address":"","ucode":"F94CF34BC5B2AC","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/74/461b202d.jpg","comment_is_top":false,"comment_ctime":1571798918,"is_pvip":false,"replies":[{"id":"55525","content":"你好，事件风暴会有专门的一节介绍。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571803917,"ip_address":"","comment_id":143847,"utype":1}],"discussion_count":2,"race_medal":0,"score":"14456700806","product_id":100037301,"comment_content":"老师，就基础篇。我的理解是基于事件风暴（头脑风暴）定义出实体与值对象，并能识别出根对象，进而得到聚合，并清晰领域边界、松耦合。从而达到服务化确定服务的边界！但是这其中事件风暴如何组织进行是否有策略或者说工具技术。如果团队成员就事件风暴无法达成共识，如何进一步推进？","like_count":3,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471723,"discussion_content":"你好，事件风暴会有专门的一节介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571803917,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391446,"discussion_content":"good question","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630466862,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":325780,"user_name":"周大仙","can_delete":false,"product_type":"c1","uid":2865215,"ip_address":"","ucode":"4C165FF97D7AF4","user_header":"","comment_is_top":false,"comment_ctime":1639128334,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10229062926","product_id":100037301,"comment_content":"老师，我已经将基础篇的5讲都已经看过了，我在第五章总结一下所有问题，一并发问，麻烦老师有空看看。<br>场景：用户 与 地址<br>代码：按ddd原则设置<br>----==== 华丽的分割线 ====----<br>public class person {<br>    public Interger id;<br>    public String name;<br>    ...<br>    public Address address;<br>    &#47;&#47; 其它方法<br>}<br>public class Address {<br>    public String province;<br>    public String city;<br>    ...<br>}<br>----==== 华丽的分割线 ====----<br>问题1：引述“第05篇的聚合节点”，...，值对象主要是属性集合，对实体的状态和特征进行描述。但实体和值对象都只是<br>       个体化的对象，它们的行为表现出来的是个体的能力。<br>       以上述代码为例，对实体的状态和特征进行描述，结合代码如何理解这句话。<br>问题2：若完全按照DDD的说话，数据表的设计应设计成单表，且在特殊场景中，如“第4篇”的“案例2”，以序列化对象的形<br>       式存储。若我现在的需求是查出某个省或市等的人员有多少，是否应按范式对数据库进行设计，若是，在程序输出<br>       person实体给其他程序使用时，是否应由代码查询 person 与 address的持续数据，最后组成ddd所说的person对<br>       象并包含address值对象会好点，若是，那我们是否应一开始就应该按照数据库范式设计，以避免将来业务需要变<br>       更，需要改动数据库表的结构和代码才能实现新需要。<br>问题3：引述“第01篇”的“战略设计”和“战术设计”以及“三步来划定领域模型和微服务的边界法”，<br>       如果我没理解错的话，三步法与“战略设计”、“战术设计”不能对应该上，甚至在实践中可以忽略“战略”和“战术”的<br>       概念。因为三步法中的，第一步是输出领域实体等领域对象，第二步是输出聚合对像，第三步是根据语义将多个聚<br>       合组成领域模型。综合所述，三步法是一种自下而上的实践方法，而“战略”应该是一种更高维度的自上而下的方<br>       法，“第01篇”中未给出自上而下的实践方法。不知道我有没有理解对呢？<br>问题4：引述“第02篇”桃树分解领域过程，再结合第01篇”的“战略设计”概念，我觉得分解桃树是一个自上而的分解领域过<br>       程，符合“战略设计”的概念，但在实际应用中即难以应用，因为“桃树”是一个成型的产品，几乎不需要维护，所以<br>       能够自上而下去分解领导，但现实中我们的应用是不稳定的经常变动，以上述&quot;persion&quot;和&quot;address&quot;为例，一开始<br>       我们可以单表的形式，去编写实体代码，只需要符合，从用户中查出他们的地址信息。后来需求改变，需要查出某<br>       个省或市的所有用户，这时候我们就得再编写一个Address带唯一id的实体，并且影响到Person，因此我觉得自上<br>       而下地划分领域难以应用在实际开发中，并且在设计时应该要考虑到以后应用的变化，尽量使用范例设计数据表，<br>       用程序处理值对象，不知道我这样的理解对不对？<br>问题5：假设，以“persion”和“address”为例，在某些特定的场景下，我是否可以把它分成person领域和address领域，<br>       person包含address值对象，address包含person值对象，老师请问一下我的理解对吗？<br>       还有就是再极端一点的情况，假设person是在db1，而address在db2，然后person是基于spring cloud开发的，<br>       是一个独立的服务，同样address也是，那这时候老师是建立在各个微服务中采用多数据源的方法查person和<br>       address的持续数据呢？还是通过feign跨服务查询自己实体所需要的值对象呢？<br><br>在此，先谢谢老师的解答，学生不胜感激<br>       ","like_count":2,"discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543333,"discussion_content":"我觉得问题2和问题4应该是同一个问题 我理解是这样的 聚合根存在目的是解决数据不一致性的问题 既然是查询也就不存在数据不一致性的问题 也就是说可以通过范式来设计表 但也是需要考虑到查询 这种情况应该是设置为实体","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641093885,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":280025,"user_name":"CHEN川","can_delete":false,"product_type":"c1","uid":1001694,"ip_address":"","ucode":"4B4D11141A68B9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/de/d9a88304.jpg","comment_is_top":false,"comment_ctime":1614058771,"is_pvip":false,"replies":[{"id":"101753","content":"是的。<br>在值对象设计时，可以适当的采用数据冗余的方式。数据冗余后，在当前聚合就可以获取部分值对象的关键数据，这样在需要查询值对象数据时，就不必进行跨微服务调用了，既可以减少微服务之间的调用频率，也可以实现故障隔离。只有当需要获取明细数据时，才通过聚合根ID去其它微服务获取。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1614132298,"ip_address":"","comment_id":280025,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10203993363","product_id":100037301,"comment_content":"聚合的设计步骤和设计原则特别有指导价值，在设计聚合时，不是将有关系的实体和值对象作简单的组合，最好能够找到实体和值对象运行的业务规则；换种说话，在判断聚合设计是否合理时，看看能否在聚合中找到这样一套业务业务规则。作者在评论中给了一个很简单的例子：「关于订单和商品的不变性，其实里面是有一个重要的规则，也就是订单总金额一定会是所有商品数量乘以价格后的总和，商品是依附于订单存在的。」<br><br>在实际操作过程中，有特别多的人关注聚合根中的值对象到底要不要冗余多余的属性信息，比如保单中的投保人和被保人，是只指存储客户编号呢，还是存储一个客户对象，如果是前一种，如何根据投保人名称来查询保单呢？其实这两种方式都可以，解决查询问题的方法也很多，只要你不只是盯着数据库来思考。比如，只存储了客户编号如何解决查询问题？只要在前端用下拉控件选择客户来代替输入客户名称即可；如果保存了客户名称如何在客户信息更新后同步到其他对象中呢？既可以使用定时任务刷新，也可以使用消息广播的方式来同步更新客户信息。","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515959,"discussion_content":"是的。\n在值对象设计时，可以适当的采用数据冗余的方式。数据冗余后，在当前聚合就可以获取部分值对象的关键数据，这样在需要查询值对象数据时，就不必进行跨微服务调用了，既可以减少微服务之间的调用频率，也可以实现故障隔离。只有当需要获取明细数据时，才通过聚合根ID去其它微服务获取。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1614132298,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":190113,"user_name":"迎波扬帆","can_delete":false,"product_type":"c1","uid":1795341,"ip_address":"","ucode":"D015FBAE853ABC","user_header":"https://static001.geekbang.org/account/avatar/00/1b/65/0d/eab13441.jpg","comment_is_top":false,"comment_ctime":1584603784,"is_pvip":false,"replies":[{"id":"73177","content":"出现这种情况，可能就是聚合划分的不合理。<br>DDD是从业务边界出发，先建立领域模型，领域模型本身就有领域对象，这些对象在领域模型的聚合内是强关联的，只要设计好了，就不会出现跨库调用的情况。<br>当然有些复杂的业务查询，可能会跨领域模型或者聚合来进行统计和查询。对于这种情况，你可以现将需要统计的数据进行汇集和关联，通过数据中台或CQRS读写分离的方式来处理。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584615937,"ip_address":"","comment_id":190113,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10174538376","product_id":100037301,"comment_content":"想起曾经的坑，为某个微服务业务划分数据库后，业务逻辑发现要跨数据库去join另一个表","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487891,"discussion_content":"出现这种情况，可能就是聚合划分的不合理。\nDDD是从业务边界出发，先建立领域模型，领域模型本身就有领域对象，这些对象在领域模型的聚合内是强关联的，只要设计好了，就不会出现跨库调用的情况。\n当然有些复杂的业务查询，可能会跨领域模型或者聚合来进行统计和查询。对于这种情况，你可以现将需要统计的数据进行汇集和关联，通过数据中台或CQRS读写分离的方式来处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584615937,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187231,"user_name":"千城","can_delete":false,"product_type":"c1","uid":1850369,"ip_address":"","ucode":"346A133059977D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/3c/01/29008d6a.jpg","comment_is_top":false,"comment_ctime":1584066016,"is_pvip":false,"replies":[{"id":"72545","content":"聚合是逻辑概念，没有实现的代码逻辑，通过他内部的领域对象来实现聚合内的业务逻辑。聚合根本质上是实体，所以它的代码和数据库逻辑跟实体一样，不过它会管理聚合内其它的实体对象什么周期，聚合根如果被删除了，其它实体也就不存在了。聚合根肯定会有实体表对应的，代码上是有类，但持久化对象跟DO实体不一定是一一对应的。<br>你可以看下加餐内容，你们有详细的代码，你还可以从github上下全量代码。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1584284212,"ip_address":"","comment_id":187231,"utype":1}],"discussion_count":3,"race_medal":0,"score":"10174000608","product_id":100037301,"comment_content":"老师，你这一节讲得有些抽象。聚合和聚合根举例能否对应到代码层和数据库层？我的理解是聚合是一种组织关系，将不同的实体和值对象聚合到领域内或者更细的子域内。但是聚合根作为实体，是不是对应有个数据库表？代码上有个类？然后它是什么样子的？  老师能否再举例详说一下？ 谢谢！","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":487037,"discussion_content":"聚合是逻辑概念，没有实现的代码逻辑，通过他内部的领域对象来实现聚合内的业务逻辑。聚合根本质上是实体，所以它的代码和数据库逻辑跟实体一样，不过它会管理聚合内其它的实体对象什么周期，聚合根如果被删除了，其它实体也就不存在了。聚合根肯定会有实体表对应的，代码上是有类，但持久化对象跟DO实体不一定是一一对应的。\n你可以看下加餐内容，你们有详细的代码，你还可以从github上下全量代码。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584284212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048106,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/2a/19e36c9a.jpg","nickname":"池谷湧","note":"","ucode":"2BD8260754BABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232181,"discussion_content":"聚合根如果删除了，其它实体也就不存在了。因此如果其它实体是否应该在这个聚合中以实体还是值对象方式存在，是不是可以以此做判断依据？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586859644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1850369,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/3c/01/29008d6a.jpg","nickname":"千城","note":"","ucode":"346A133059977D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209923,"discussion_content":"好的  我先学习一下您的代码  有疑问再请教  谢谢欧老师！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584690362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":146732,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1572623016,"is_pvip":false,"replies":[{"id":"56731","content":"它是通过仓储实现的。<br>由于领域模型中的DO实体与数据模型中的PO不一定一一对应，所以聚合里的实体在持久化时，会有一个DO到PO的转换过程。仓储持久化的组织者是聚合根。具体的实现你可以用MyBatis等组件，目前来讲现在的几个主流持久化组件，在仓储实现持久化方面使用起来还不是特别的顺手。<br>在某些不强调数据一致性的聚合中，个人感觉你可以突破聚合根，按照你习惯的方式去完成数据持久化。<br><br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572665751,"ip_address":"","comment_id":146732,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10162557608","product_id":100037301,"comment_content":"一个聚合可能对应一堆实体及值对象，一个聚合对应一个仓储也即数据持久化单元。那如何实现聚合到持久化单元呢","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473000,"discussion_content":"它是通过仓储实现的。\n由于领域模型中的DO实体与数据模型中的PO不一定一一对应，所以聚合里的实体在持久化时，会有一个DO到PO的转换过程。仓储持久化的组织者是聚合根。具体的实现你可以用MyBatis等组件，目前来讲现在的几个主流持久化组件，在仓储实现持久化方面使用起来还不是特别的顺手。\n在某些不强调数据一致性的聚合中，个人感觉你可以突破聚合根，按照你习惯的方式去完成数据持久化。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572665751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143940,"user_name":"TH","can_delete":false,"product_type":"c1","uid":1053413,"ip_address":"","ucode":"C5EA20546DC09C","user_header":"https://static001.geekbang.org/account/avatar/00/10/12/e5/592d9324.jpg","comment_is_top":false,"comment_ctime":1571810809,"is_pvip":true,"replies":[{"id":"55554","content":"是的，在一个聚合内是由聚合根来管理和协调所有实体和值对象的生命周期的，所以在一个聚合内可以保证数据的一致性。<br>由于多个聚合运行在同一个微服务内，在应用层我们是可以拿到其它聚合的聚合根的DO对象的，拿到聚合根后你就可以通过聚合根引用聚合的内部实体和值对象。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571820541,"ip_address":"","comment_id":143940,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10161745401","product_id":100037301,"comment_content":"在别处看到，持久化只能由聚合根来进行，并且由于聚合是用来保持聚合内部的数据一致性，因此持久化时应当持久化整个聚合。<br><br>另外还有一个疑问，在与外部聚合协同时只能通过外部聚合根的ID，这个具体是怎么实现的呢？如果当前聚合不持有外部聚合根实体，要怎么使用它的业务功能呢？通过外部聚合根暴露REST API吗？如果是一个单体应用怎么做到不直接调用外部聚合根呢？","like_count":2,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471752,"discussion_content":"是的，在一个聚合内是由聚合根来管理和协调所有实体和值对象的生命周期的，所以在一个聚合内可以保证数据的一致性。\n由于多个聚合运行在同一个微服务内，在应用层我们是可以拿到其它聚合的聚合根的DO对象的，拿到聚合根后你就可以通过聚合根引用聚合的内部实体和值对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571820541,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":324997,"user_name":"红不棱登","can_delete":false,"product_type":"c1","uid":1671073,"ip_address":"","ucode":"9C9BAABD81E6A8","user_header":"https://static001.geekbang.org/account/avatar/00/19/7f/a1/f96eec6d.jpg","comment_is_top":false,"comment_ctime":1638775775,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5933743071","product_id":100037301,"comment_content":"一个聚合对应一个仓储，一个仓储可以对应多张表？","like_count":1},{"had_liked":false,"id":295247,"user_name":"马文龙","can_delete":false,"product_type":"c1","uid":1068432,"ip_address":"","ucode":"679B0F0AB402C7","user_header":"https://static001.geekbang.org/account/avatar/00/10/4d/90/25b6f544.jpg","comment_is_top":false,"comment_ctime":1622330547,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5917297843","product_id":100037301,"comment_content":"通过唯一标识引用其它聚合。聚合之间是通过关联外部聚合根 ID 的方式引用，而不是直接对象引用的方式。 这个用代码怎么实现？","like_count":1},{"had_liked":false,"id":265953,"user_name":"波锅","can_delete":false,"product_type":"c1","uid":2306289,"ip_address":"","ucode":"139559B32EACD4","user_header":"https://static001.geekbang.org/account/avatar/00/23/30/f1/62f0388c.jpg","comment_is_top":false,"comment_ctime":1607075156,"is_pvip":false,"replies":[{"id":"97303","content":"聚合之间是通过引用聚合根ID的方式，而不是通过直接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。这样设计也是为了聚合的解耦。当领域模型随着业务需求发生变化，微服务内需要进行聚合拆分时，原来领域模型和微服务内聚合根之间对象引用的方式，就会变成跨微服务的调用，跨微服务后这种对象引用就会失效，在微服务架构演进时就需要比较大的代码调整。<br>采用聚合根ID引用的方式，也就是聚合根B可以引用聚合根A的ID，在进行跨聚合访问是，可以将聚合根ID作为服务参数，在应用层进行跨聚合的领域服务调用。如果微服务需要拆分聚合，如果聚合被分别拆分到了两个不同的微服务中，这种代码的改动量就会小很多，聚合的边界也会清晰很多。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608019933,"ip_address":"","comment_id":265953,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5902042452","product_id":100037301,"comment_content":"老师，聚合根与聚合根之间通过 ID 关联的方式实现聚合之间的协同， 这个如何理解？ 这里的聚合根ID是不是就是实体ID？<br>聚合根与聚合根之间的协同，不应该是在聚合根A的应用层调用聚合根B的接口吗？根据ID关联协同具体是？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511106,"discussion_content":"聚合之间是通过引用聚合根ID的方式，而不是通过直接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也会增加聚合之间的耦合度。这样设计也是为了聚合的解耦。当领域模型随着业务需求发生变化，微服务内需要进行聚合拆分时，原来领域模型和微服务内聚合根之间对象引用的方式，就会变成跨微服务的调用，跨微服务后这种对象引用就会失效，在微服务架构演进时就需要比较大的代码调整。\n采用聚合根ID引用的方式，也就是聚合根B可以引用聚合根A的ID，在进行跨聚合访问是，可以将聚合根ID作为服务参数，在应用层进行跨聚合的领域服务调用。如果微服务需要拆分聚合，如果聚合被分别拆分到了两个不同的微服务中，这种代码的改动量就会小很多，聚合的边界也会清晰很多。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608019933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":261903,"user_name":"瀚囧","can_delete":false,"product_type":"c1","uid":2286912,"ip_address":"","ucode":"030FD0A2EF482F","user_header":"","comment_is_top":false,"comment_ctime":1605574496,"is_pvip":false,"replies":[{"id":"95257","content":"建议在不同的领域各自定义。第一，同一个类型的值对象可能在不同的领域会要求不同的属性集。第二，共用就会产生耦合，不利于架构演进。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605756561,"ip_address":"","comment_id":261903,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5900541792","product_id":100037301,"comment_content":"老师，订单和退款，订单作为一个领域，退款作为一个领域，他们都有支付人值对象，这个支付人值对象是共用的吗，还是不同领域有各自不同定义，这样同一个值对象会被定义两次。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509660,"discussion_content":"建议在不同的领域各自定义。第一，同一个类型的值对象可能在不同的领域会要求不同的属性集。第二，共用就会产生耦合，不利于架构演进。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605756561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":243945,"user_name":"静心","can_delete":false,"product_type":"c1","uid":1335457,"ip_address":"","ucode":"EB264FA6519FDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","comment_is_top":false,"comment_ctime":1598335972,"is_pvip":true,"replies":[{"id":"89871","content":"聚合是一个目录结构，这个结构内包含聚合内所有的实体、聚合根、值对象以及领域服务等类。聚合根类跟实体类一样，是一个充血模型的类。这一块后面的章节有详细介绍。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1598407428,"ip_address":"","comment_id":243945,"utype":1}],"discussion_count":2,"race_medal":5,"score":"5893303268","product_id":100037301,"comment_content":"请教老师，聚合和聚合根体现在代码中，应该是一个类文件目录呢？还是一个类？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504439,"discussion_content":"聚合是一个目录结构，这个结构内包含聚合内所有的实体、聚合根、值对象以及领域服务等类。聚合根类跟实体类一样，是一个充血模型的类。这一块后面的章节有详细介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598407428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1335457,"avatar":"https://static001.geekbang.org/account/avatar/00/14/60/a1/8f003697.jpg","nickname":"静心","note":"","ucode":"EB264FA6519FDA","race_medal":5,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301111,"discussion_content":"清晰多了，多谢老师的回复。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598410327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":241656,"user_name":"Geek_7c4953","can_delete":false,"product_type":"c1","uid":1809168,"ip_address":"","ucode":"359745D4725D4F","user_header":"","comment_is_top":false,"comment_ctime":1597383242,"is_pvip":false,"replies":[{"id":"89381","content":"理论上，聚合根方法和领域服务都可以组合同一个聚合的多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，只作为实体实现与聚合根自身行为相关的业务逻辑，而将跨多个实体的复杂领域逻辑统一放在领域服务中实现。当然，简单聚合的跨多个实体的领域逻辑，可以考虑在聚合根的方法中实现。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597633333,"ip_address":"","comment_id":241656,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5892350538","product_id":100037301,"comment_content":"比如有的业务场景需要同一个聚合的 A 和 B 两个实体来共同完成，我们就可以将这段业务逻辑用领域服务来实现。<br>这句话有点不理解。<br>如果是一个聚合内的两个实体，那么他们应该都是直接或间接被聚合根引用，那么对于这两个实体共同参与的业务，为什么不是作为这个聚合根实体的行为，而是在外部又建立领域服务呢？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503805,"discussion_content":"理论上，聚合根方法和领域服务都可以组合同一个聚合的多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，只作为实体实现与聚合根自身行为相关的业务逻辑，而将跨多个实体的复杂领域逻辑统一放在领域服务中实现。当然，简单聚合的跨多个实体的领域逻辑，可以考虑在聚合根的方法中实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597633333,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670730,"avatar":"","nickname":"Geek_0a4616","note":"","ucode":"9C37ED61ECCAC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379227,"discussion_content":"我理解 领域服务和聚合根在行为放置方面是互补的关系","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623760299,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1670730,"avatar":"","nickname":"Geek_0a4616","note":"","ucode":"9C37ED61ECCAC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":379226,"discussion_content":"聚合根本身也是一个实体，如果把行为放在聚合根这个实体内可能不合适？比如包含了两个实体对象的行为，不确定放在哪里，这个时候才适合放在领域服务内","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623760249,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":240457,"user_name":"wall.e","can_delete":false,"product_type":"c1","uid":2002255,"ip_address":"","ucode":"5331B5FC503254","user_header":"https://static001.geekbang.org/account/avatar/00/1e/8d/4f/29e96220.jpg","comment_is_top":false,"comment_ctime":1596937771,"is_pvip":true,"replies":[{"id":"88805","content":"基本差不多，都是为了组合多个实体来完成逻辑处理。不过为了方便管理，可以将所有的跨多实体的领域服务独立出来成为一个类，只涉及聚合根自己的业务行为放在聚合根方法里面。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597015772,"ip_address":"","comment_id":240457,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5891905067","product_id":100037301,"comment_content":"聚合根提供的方法是不是就是领域服务呢？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":503451,"discussion_content":"基本差不多，都是为了组合多个实体来完成逻辑处理。不过为了方便管理，可以将所有的跨多实体的领域服务独立出来成为一个类，只涉及聚合根自己的业务行为放在聚合根方法里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597015772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":234200,"user_name":"AlphaGao","can_delete":false,"product_type":"c1","uid":1111183,"ip_address":"","ucode":"862000415389FE","user_header":"https://static001.geekbang.org/account/avatar/00/10/f4/8f/06bd9544.jpg","comment_is_top":false,"comment_ctime":1594618282,"is_pvip":false,"replies":[{"id":"86442","content":"领域服务和应用服务在实现事务上还是有一些差异的。<br>由于领域服务组合的实体在同一个聚合内，数据之间具有强关联，在仓储实现的时候都是强一致性，通过数据库本身的逻辑就可以实现数据一致性。<br>应用服务在实现跨聚合的领域服务事务的时候，一般都建议采用数据最终一致性。如果不采用数据最终一致性，则需要采用事务机制，确保多个聚合在提交数据时的数据强一致性。<br>应用服务直接调用仓储的情况，主要应用于不需要实现领域逻辑的查询之类的操作。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1594628829,"ip_address":"","comment_id":234200,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5889585578","product_id":100037301,"comment_content":"欧老师你好，有一点疑惑，领域服务和应用服务在实现事务上有什么区别吗？<br>应用服务是聚了多个领域服务，这种情况下该如何回滚数据呢，文中也提到，领域服务和应用服务，都可以直接操纵仓储层，这种是合理的吗","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501315,"discussion_content":"领域服务和应用服务在实现事务上还是有一些差异的。\n由于领域服务组合的实体在同一个聚合内，数据之间具有强关联，在仓储实现的时候都是强一致性，通过数据库本身的逻辑就可以实现数据一致性。\n应用服务在实现跨聚合的领域服务事务的时候，一般都建议采用数据最终一致性。如果不采用数据最终一致性，则需要采用事务机制，确保多个聚合在提交数据时的数据强一致性。\n应用服务直接调用仓储的情况，主要应用于不需要实现领域逻辑的查询之类的操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594628829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1111183,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f4/8f/06bd9544.jpg","nickname":"AlphaGao","note":"","ucode":"862000415389FE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290866,"discussion_content":"非常感谢🙏","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594629597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232114,"user_name":"川川","can_delete":false,"product_type":"c1","uid":1382517,"ip_address":"","ucode":"DA092CAC7F294D","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/75/68487e89.jpg","comment_is_top":false,"comment_ctime":1593858462,"is_pvip":false,"replies":[{"id":"85820","content":"领域服务主要用于组合同一个聚合的多个实体的方法。如果领域服务用于跨聚合的实体组合的话，就会带来聚合的高度耦合。应用服务主要用于组合不同聚合的领域服务，来完成跨聚合的服务协调，并通过用户接口层的Facade接口对外暴露。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1594025155,"ip_address":"","comment_id":232114,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5888825758","product_id":100037301,"comment_content":"这里跨聚合逻辑处理使用使用领域服务是否更为合理，  我理解的应用服务通过接口来暴露系统的全部功能，  并且协调领域服务， 它应该是很薄的一层<br>","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500516,"discussion_content":"领域服务主要用于组合同一个聚合的多个实体的方法。如果领域服务用于跨聚合的实体组合的话，就会带来聚合的高度耦合。应用服务主要用于组合不同聚合的领域服务，来完成跨聚合的服务协调，并通过用户接口层的Facade接口对外暴露。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594025155,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232112,"user_name":"川川","can_delete":false,"product_type":"c1","uid":1382517,"ip_address":"","ucode":"DA092CAC7F294D","user_header":"https://static001.geekbang.org/account/avatar/00/15/18/75/68487e89.jpg","comment_is_top":false,"comment_ctime":1593857569,"is_pvip":false,"replies":[{"id":"85821","content":"一般微服务的拆分标准是限界上下文，不建议按照聚合拆分，除非有特殊考虑。微服务内聚合的数据一般采用最终一致性，在后面的领域事件那一章有介绍。<br>应用服务属于微服务内应用层的服务，主要用于处理不同聚合之间的服务协调。<br>","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1594025350,"ip_address":"","comment_id":232112,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5888824865","product_id":100037301,"comment_content":"老师请问一下<br>1. 既然一个微服务包含了多个聚合，   那会不会导致微服务过多解决数据一致性的难度加大； 之前在看限界上下文的时候有讲到一个限界上下文就对应一个微服务，那是不是应该以限界上下文作为微服务拆分的标准<br><br>2.老师在文章里面提到了应用服务是用来处理聚合的业务逻辑，   想问下应用服务和这里讲的微服务的的关系是什么","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500514,"discussion_content":"一般微服务的拆分标准是限界上下文，不建议按照聚合拆分，除非有特殊考虑。微服务内聚合的数据一般采用最终一致性，在后面的领域事件那一章有介绍。\n应用服务属于微服务内应用层的服务，主要用于处理不同聚合之间的服务协调。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594025350,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223766,"user_name":"珅珅君","can_delete":false,"product_type":"c1","uid":1069646,"ip_address":"","ucode":"3700048634C565","user_header":"https://static001.geekbang.org/account/avatar/00/10/52/4e/5150a2ee.jpg","comment_is_top":false,"comment_ctime":1591176582,"is_pvip":false,"replies":[{"id":"82489","content":"聚合内的实体也是通过仓储来完成持久化的，但是在DDD中不建议直接对某一个数据库表进行直接修改，因为聚合内部如果有业务规则的话，会导致数据不一致的情况发生，因此在数据修改时需按照相应的规则进行操作，比如修改订单的商品明细时，你不可以直接去改商品明细表，而是要将这笔交易作为一个整体，按照聚合内的业务规则来进行修改。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591256188,"ip_address":"","comment_id":223766,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5886143878","product_id":100037301,"comment_content":"你好，我想请问下 聚合根内实体的CRUD如何处理？如果是聚合根的话，CRUD是通过仓储来处理的可以理解，但是如果是被聚合的内部实体，他没有仓储，他的CRUD在何处处理呢？<br>比如我只是修改了一条明细，不会对聚合根产生影响的情况下，如果在持久化时只保存该明细，","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497234,"discussion_content":"聚合内的实体也是通过仓储来完成持久化的，但是在DDD中不建议直接对某一个数据库表进行直接修改，因为聚合内部如果有业务规则的话，会导致数据不一致的情况发生，因此在数据修改时需按照相应的规则进行操作，比如修改订单的商品明细时，你不可以直接去改商品明细表，而是要将这笔交易作为一个整体，按照聚合内的业务规则来进行修改。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591256188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2329181,"avatar":"https://static001.geekbang.org/account/avatar/00/23/8a/5d/9f146e48.jpg","nickname":"Monday","note":"","ucode":"33C597731B7AFA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409306,"discussion_content":"将这笔交易作为一个整体修改表示没听懂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635414866,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203468,"user_name":"成章","can_delete":false,"product_type":"c1","uid":1929644,"ip_address":"","ucode":"82D6E87A79A7B0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/71/ac/c87546f5.jpg","comment_is_top":false,"comment_ctime":1586216929,"is_pvip":false,"replies":[{"id":"76057","content":"你这种情况在微服务设计里应该很常见，尤其对于有流程上下游关系的微服务，比如a、b是上游微服务或聚合的数据，c是下游的微服务，c需要用到上游的数据。这种情况就不要用传参的方式了，你可以将a、b设计为c的值对象，a、b数据的生命周期管理由上游微服务维护。c只能引用ab的值对象。当ab发生变化的时候，会通过领域事件异步发送到c。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586223479,"ip_address":"","comment_id":203468,"utype":1}],"discussion_count":5,"race_medal":0,"score":"5881184225","product_id":100037301,"comment_content":"老师我在实践过程中还是会有这种例子，a，b，c三个字段，a和b都是c的取值来源。但是a和b，又分属于不同领域，都有一定粒度。<br>这个用参数传递不能解决。因为有的交易修改a，有的交易修改b。再修改a的交易中，b所在领域可以完全不经过。那么我去计算c的时候就获取不到b。<br>而我们采取的方法是c所在领域里聚合了b字段，作为一个值对象加载。<br>但这样一来，拆分微服务时这几个必然不能拆开了。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490871,"discussion_content":"你这种情况在微服务设计里应该很常见，尤其对于有流程上下游关系的微服务，比如a、b是上游微服务或聚合的数据，c是下游的微服务，c需要用到上游的数据。这种情况就不要用传参的方式了，你可以将a、b设计为c的值对象，a、b数据的生命周期管理由上游微服务维护。c只能引用ab的值对象。当ab发生变化的时候，会通过领域事件异步发送到c。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586223479,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":238906,"discussion_content":"是这样的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587259363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1929644,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/71/ac/c87546f5.jpg","nickname":"成章","note":"","ucode":"82D6E87A79A7B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":223632,"discussion_content":"那这个时候加载c聚合就需要有a，b值对象数据了。如果不通过仓储间互相调用，或者仓储实现互相调用。就无法获取到a，b的值对象了。要不然就是a，b值对象的加载逻辑在c仓储再写一遍，但这又犯了代码不复用的问题。这点好像没人提过。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586241188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1048106,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/2a/19e36c9a.jpg","nickname":"池谷湧","note":"","ucode":"2BD8260754BABA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1929644,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/71/ac/c87546f5.jpg","nickname":"成章","note":"","ucode":"82D6E87A79A7B0","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232177,"discussion_content":"我的理解是，在a、b的修改动作完成后，发布一个事件到消息队列里，c消费事件更新c里的a、b值对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586859134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":223632,"ip_address":""},"score":232177,"extra":""},{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1048106,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/2a/19e36c9a.jpg","nickname":"池谷湧","note":"","ucode":"2BD8260754BABA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543346,"discussion_content":"那是怎么更新呢 如果更新的话就应该先拿到聚合根吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641098398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":232177,"ip_address":""},"score":543346,"extra":""}]}]},{"had_liked":false,"id":181203,"user_name":"谭方敏","can_delete":false,"product_type":"c1","uid":1710960,"ip_address":"","ucode":"728DC7ECB7C902","user_header":"https://static001.geekbang.org/account/avatar/00/1a/1b/70/547042ee.jpg","comment_is_top":false,"comment_ctime":1582516479,"is_pvip":false,"replies":[{"id":"70379","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582621049,"ip_address":"","comment_id":181203,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877483775","product_id":100037301,"comment_content":"聚合是实体和值对象的集合，聚合根则是聚合内部的管理者，实体就是最基础的业务逻辑单元，而值是业务属性集合。<br>它们在领域事件中按照实体&#47;值对象-聚合根-聚合的先后顺序抽茧剥丝出来的，<br>聚合之间访问要借助聚合根，并且聚合对应于唯一的持久化对象。","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484957,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582621049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":156829,"user_name":"Geek_88604f","can_delete":false,"product_type":"c1","uid":1501234,"ip_address":"","ucode":"33DD1318E53814","user_header":"","comment_is_top":false,"comment_ctime":1574986512,"is_pvip":false,"replies":[{"id":"60358","content":"生活中是这样哈。聚合根的主要目标是为了保证聚合内的业务规则和数据一致性。其实你也可以通过聚合A的聚合根来使用聚合B的数据的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575166730,"ip_address":"","comment_id":156829,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5869953808","product_id":100037301,"comment_content":"聚合A的对象a需要访问聚合B的对象b，需要经过聚合B的聚合根，这个很容易理解。疑问的地方是对象a为什么没有经过自己的聚合根呢？这个不符合常识，举个例子，a和b分别是团队A和B的成员，a要和b配合完成某个事务，a要和b的主管协商，同时a还要和自己的主管协商，不然自己的主管不认可怎么办，白干了！","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476245,"discussion_content":"生活中是这样哈。聚合根的主要目标是为了保证聚合内的业务规则和数据一致性。其实你也可以通过聚合A的聚合根来使用聚合B的数据的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575166730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143977,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1571819161,"is_pvip":false,"replies":[{"id":"55556","content":"因为微服务的架构演进，会有功能和代码的拆分和重构的过程。而一般来讲聚合的内聚性很高，聚合内的功能相对稳定，我们可以聚合功能和代码为单位在不同的微服务之间进行功能和代码的重构。<br>如果聚合之间代码和业务边界不清晰，聚合之间数据和服务可以随便访问，就会因为耦合度过高，代码很难剥离，最后微服务架构演进时又要在走一遍从单体拆分微服务的过程。后面的章节我会专门讲微服务架构的演进。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571821206,"ip_address":"","comment_id":143977,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5866786457","product_id":100037301,"comment_content":"       “一个微服务可以包含多个聚合，聚合之间的边界是微服务内天然的逻辑边界。有了这个逻辑边界，在微服务架构演进时就可以以聚合为单位进行拆分和组合了，微服务的架构演进也就不再是一件难事了“<br>          目前我们在微服务内部，对聚合的要求降低了。也就是说一个微服务内部的数据结构是随便互相访问的，实体也是贫血的模型。主要是考虑：服务层已经分为微服务层，聚合服务层（BFF层）了，微服务之间通过消息来解耦；如果微服务内部再分层，引入领域事件，感觉有点儿太复杂了。不知道这样合适不合适？","like_count":1,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471766,"discussion_content":"因为微服务的架构演进，会有功能和代码的拆分和重构的过程。而一般来讲聚合的内聚性很高，聚合内的功能相对稳定，我们可以聚合功能和代码为单位在不同的微服务之间进行功能和代码的重构。\n如果聚合之间代码和业务边界不清晰，聚合之间数据和服务可以随便访问，就会因为耦合度过高，代码很难剥离，最后微服务架构演进时又要在走一遍从单体拆分微服务的过程。后面的章节我会专门讲微服务架构的演进。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571821206,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":354302,"user_name":"杨迪","can_delete":false,"product_type":"c1","uid":1138700,"ip_address":"上海","ucode":"7499998692000C","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/0c/1230e604.jpg","comment_is_top":false,"comment_ctime":1660270483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1660270483","product_id":100037301,"comment_content":"有个疑问，聚合a持有的聚合b的id，但是b内部有多少个实体，怎么导航到b的某个实体呢？","like_count":0},{"had_liked":false,"id":352188,"user_name":"ub8","can_delete":false,"product_type":"c1","uid":1481811,"ip_address":"","ucode":"0D937C3EAEB781","user_header":"https://static001.geekbang.org/account/avatar/00/16/9c/53/ade0afb0.jpg","comment_is_top":false,"comment_ctime":1658450378,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1658450378","product_id":100037301,"comment_content":"图里面 “地址”竟然成了实体，上一节讲地址这样由属性决定无唯一标识的数据体不是值对象吗","like_count":0},{"had_liked":false,"id":351264,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1657641823,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1657641823","product_id":100037301,"comment_content":"限界上下文包含多个聚合<br>聚合就是一个团队，包含了实体和值对象。而实体中要选出一个领头人负责团队各项一致性事务，这个领头人就是聚合根。<br>交易订单有主子，主订单就是聚合根。这个划分是否合理？<br>","like_count":0},{"had_liked":false,"id":348468,"user_name":"苏籍","can_delete":false,"product_type":"c1","uid":1396252,"ip_address":"","ucode":"4FA289E084B789","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erYNBIwAj3KdIXaXbeMBUjTMz31zAToHIJSdo7oQk8bfsibwViaLobVQ8miatwBlC5spLS9kVCzHMjUA/132","comment_is_top":false,"comment_ctime":1655121026,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655121026","product_id":100037301,"comment_content":"看了两遍，仍然有一个困惑，想请老师解答一下：<br>对于领域服务中的实体属性的变更 一定要通过聚合根进行持久化操作吗<br>比如我一个领域服务 只操作聚合中 两个实体，我也要通过聚合根查出所有10个实体，然后再通过聚合根更新这10个实体吗","like_count":0},{"had_liked":false,"id":348465,"user_name":"苏籍","can_delete":false,"product_type":"c1","uid":1396252,"ip_address":"","ucode":"4FA289E084B789","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erYNBIwAj3KdIXaXbeMBUjTMz31zAToHIJSdo7oQk8bfsibwViaLobVQ8miatwBlC5spLS9kVCzHMjUA/132","comment_is_top":false,"comment_ctime":1655120875,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1655120875","product_id":100037301,"comment_content":"看了两遍，但是仍然有个困惑想请老师解答<br>对于领域服务中实体属性的变更一定要走聚合根进行更新吗","like_count":0},{"had_liked":false,"id":343618,"user_name":"Siu","can_delete":false,"product_type":"c1","uid":1057413,"ip_address":"","ucode":"457557F4918BF2","user_header":"https://static001.geekbang.org/account/avatar/00/10/22/85/3c3da0d5.jpg","comment_is_top":false,"comment_ctime":1650956935,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1650956935","product_id":100037301,"comment_content":"我记得在限界上下文那一节，划分限界上下文时有“投保”、“保单管理”，应该是两个微服务；这一节中聚合构建过程又把保单放在投保中描述，那投保这个业务是一个微服务吗<br>","like_count":0},{"had_liked":false,"id":339554,"user_name":"Luke","can_delete":false,"product_type":"c1","uid":1004462,"ip_address":"","ucode":"8F7DE6E7B3D74F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/53/ae/a08024b2.jpg","comment_is_top":false,"comment_ctime":1648184360,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1648184360","product_id":100037301,"comment_content":"按照设计原则，如果我们把聚合理解为「一致性边界」，那么是否可以理解为数据库事务不应该跨聚合产生呢? 发现一些分层规范倾向于将「事务」限定在 Application 层，我理解应该不是指数据库事务吧，是不是理解为对最终一致性负责的业务逻辑更合适呢? 这个问题其实困扰我好长时间，再次复习您的文章，还是对此有所疑问，您是怎么做的呢","like_count":0},{"had_liked":false,"id":339091,"user_name":"Self-devourer","can_delete":false,"product_type":"c1","uid":1179187,"ip_address":"","ucode":"DB453751F3927E","user_header":"https://static001.geekbang.org/account/avatar/00/11/fe/33/4031f9c2.jpg","comment_is_top":false,"comment_ctime":1647914151,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1647914151","product_id":100037301,"comment_content":"老师,我这边在ddd落地的时候遇到点问题,麻烦有时间帮解答下哈<br>业务场景是告警监控<br>一个监控器里包含数据匹配器,告警规则,以及告警行为<br>根据匹配器可以筛选出N个监控对象,每个监控对象有自己的状态(是否告警)这些告警状态还会有查询的需求.<br>这边设计的是将告警作为一个限界上下文,聚合根是监控器, 监控器包含数据匹配器,告警规则,告警行为(这些都是值对象)<br>但是监控对象这里 我就不太清楚它的定位是什么,也不知道该如何设计它. 是应该把它划分到单独的聚合里,还是划分到监控器聚合里呢?","like_count":0},{"had_liked":false,"id":338096,"user_name":"撇撇","can_delete":false,"product_type":"c1","uid":1010786,"ip_address":"","ucode":"938305F9F3F19C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6c/62/cbb91635.jpg","comment_is_top":false,"comment_ctime":1647278478,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1647278478","product_id":100037301,"comment_content":"所以如果说事件风暴是发散的过程，那聚合就是收敛吗？","like_count":0},{"had_liked":false,"id":336502,"user_name":"jenix","can_delete":false,"product_type":"c1","uid":2914487,"ip_address":"","ucode":"BBC46634FA93BC","user_header":"https://static001.geekbang.org/account/avatar/00/2c/78/b7/55a18e2f.jpg","comment_is_top":false,"comment_ctime":1646191438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646191438","product_id":100037301,"comment_content":"老师，聚合根的代码形态能展示一下吗？","like_count":0},{"had_liked":false,"id":335643,"user_name":"Geek_02e28e","can_delete":false,"product_type":"c1","uid":1325777,"ip_address":"","ucode":"170B5F9B1B8358","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/1a4orZQgenzVuicWSGSZRsN8EVHbaQk3VmnVdSvDLtBZLLY9iaNSVH2Z3gfZ2oHMpJAEpgcING6z08urrkLeJ9rw/132","comment_is_top":false,"comment_ctime":1645611055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645611055","product_id":100037301,"comment_content":"“在一致性边界内建模真正的不变条件”，有没有具体的例子呢？","like_count":0},{"had_liked":false,"id":334854,"user_name":"jenix","can_delete":false,"product_type":"c1","uid":2914487,"ip_address":"","ucode":"BBC46634FA93BC","user_header":"https://static001.geekbang.org/account/avatar/00/2c/78/b7/55a18e2f.jpg","comment_is_top":false,"comment_ctime":1645156055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645156055","product_id":100037301,"comment_content":"“聚合在 DDD 分层架构里属于领域层，领域层包含了多个聚合，共同实现核心业务逻辑。聚合内实体以充血模型实现个体业务能力，以及业务逻辑的高内聚。跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现。比如有的业务场景需要同一个聚合的 A 和 B 两个实体来共同完成，我们就可以将这段业务逻辑用领域服务来实现；而有的业务逻辑需要聚合 C 和聚合 D 中的两个服务共同完成，这时你就可以用应用服务来组合这两个服务” ，老师，这个地方我觉得表达有些模糊，至少我看起来是比较蒙的，“比如有的业务场景需要同一个聚合的 A 和 B 两个实体来共同完成，”这句话的意思是，一个业务场景需要实体A和实体B同时来完成业务逻辑操作？","like_count":0},{"had_liked":false,"id":334625,"user_name":"先听","can_delete":false,"product_type":"c1","uid":1151409,"ip_address":"","ucode":"82D8DA7A2FEB4B","user_header":"https://static001.geekbang.org/account/avatar/00/11/91/b1/fb117c21.jpg","comment_is_top":false,"comment_ctime":1645022246,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1645022246","product_id":100037301,"comment_content":"请问老师：<br>有时候不同聚合会利用到相同或类似的实体或者值对象。这种情况下 实体以及值对象一般是设计成“可以被多个聚合利用”呢 还是“不同集合单独定义自己的实体与值对象”呢？","like_count":0},{"had_liked":false,"id":334509,"user_name":"倔强小德普","can_delete":false,"product_type":"c1","uid":1180884,"ip_address":"","ucode":"4795B744BDDBDD","user_header":"https://static001.geekbang.org/account/avatar/00/12/04/d4/7173785e.jpg","comment_is_top":false,"comment_ctime":1644981524,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644981524","product_id":100037301,"comment_content":"如何理解实体和聚合根，我们实践中 一般只有一个实体和多个值对象，这样看来实体和聚合根是一对一的，是不是这两者是等同的","like_count":0},{"had_liked":false,"id":328656,"user_name":"青禾qingh","can_delete":false,"product_type":"c1","uid":1651441,"ip_address":"","ucode":"453FC435B03790","user_header":"https://static001.geekbang.org/account/avatar/00/19/32/f1/fd24d52b.jpg","comment_is_top":false,"comment_ctime":1640828726,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640828726","product_id":100037301,"comment_content":"领域服务和应用服务的区别是","like_count":0},{"had_liked":false,"id":326741,"user_name":"Kevin","can_delete":false,"product_type":"c1","uid":1796510,"ip_address":"","ucode":"C23E3390995D95","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKo5jCPQW87sFySwXiaLxibak0qQYuFRTyy8RlNsO9JDyxBk1AYDrsphRskxzXPLPOW8ibWicWlRAnzwg/132","comment_is_top":false,"comment_ctime":1639651235,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639651235","product_id":100037301,"comment_content":"所以简单的理解起来 聚合即使dao层，聚合根就是service？","like_count":0},{"had_liked":false,"id":325560,"user_name":"徐李","can_delete":false,"product_type":"c1","uid":1213325,"ip_address":"","ucode":"41550F6CA1E112","user_header":"https://static001.geekbang.org/account/avatar/00/12/83/8d/03cac826.jpg","comment_is_top":false,"comment_ctime":1639020803,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1639020803","product_id":100037301,"comment_content":"到这一章将聚合和聚合根，就感觉稍微有点晦涩了，不是那么易懂，可能抽象的没有具体例子，不是很好理解。聚合是一定实体和值对象的集合，怎么判断这里的“一定”？就是他们的业务是强关联的，不同的业务的就是在不同的聚合。一个聚合内部，大家的可以互相调用，在聚合外部，就不能互相访问聚合内部的方法，只能通过聚合根，聚合根可以理解为一个聚合的唯一标识，最重要的那个实体，具有唯一性，那这里的聚合根的id 和这个最核心的实体的id 是否可以是同一个？ 其他聚合要访问是通过这个聚合根来统一调度和修改。<br><br>最后映射到战术实现的角度，一个聚合可以对应一个微服务，那这里可能粒度过细，也可以一个微服务对应多个聚合，按照项目实际情况来判断。","like_count":0},{"had_liked":false,"id":315239,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1633763149,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633763149","product_id":100037301,"comment_content":"聚合是把一组用于解决特定业务场景问题的实体和值对象聚在一起，通过协作配合来完成业务逻辑。<br>聚合根就是能够把所有聚合内实体联合在一起的核心实体。每个聚合内只能有一个聚合根，聚合根具有全局唯一标识，聚合与聚合之间通过 聚合根ID 关联的方式实现聚合之间的协同。<br>实体在聚合之内，被聚合根管理，在实体中可以引用聚合内的聚合根、其他实体、值对象。<br>值对象核心是值，没有操作，无生命周期，用完即仍。","like_count":0},{"had_liked":false,"id":313905,"user_name":"ZK","can_delete":false,"product_type":"c1","uid":1720229,"ip_address":"","ucode":"D17CA63492C086","user_header":"https://static001.geekbang.org/account/avatar/00/1a/3f/a5/1d05f7da.jpg","comment_is_top":false,"comment_ctime":1632733130,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1632733130","product_id":100037301,"comment_content":"“投保人和被保人的数据，是通过关联客户 ID 从客户聚合中获取的，在投保聚合里它们是投保单的值对象，这些值对象的数据是客户的冗余数据，即使未来客户聚合的数据发生了变更，也不会影响投保单的值对象数据” 想请问一下老师，客户聚合数据的改变不应该实时同步给投保单的客户数据吗，为什么投保单的客户信息值对象数据不变？这样通过投保单获取到的客户信息岂不是与真实客户信息不符？从而导致了数据的不一致。","like_count":0},{"had_liked":false,"id":312792,"user_name":"paulmin","can_delete":false,"product_type":"c1","uid":1707838,"ip_address":"","ucode":"6AAB20AB369E90","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/AcJM5WNhE062TQAsIE8KTxTsZMTHJHCm4LCfsjBPibZ6iaGRamfZqIRFcLXLVfAQobeCIgA9o5wiaRCKa0dNbic1iag/132","comment_is_top":false,"comment_ctime":1632022477,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1632022477","product_id":100037301,"comment_content":"聚合用来封装真正的不变性，而不是简单地将对象组合在一起。聚合内有一套不变的业务规则，各实体和值对象按照统一的业务规则运行，实现对象数据的一致性，边界之外的任何东西都与该聚合无关，这就是聚合能实现业务高内聚的原因。<br>老师， 这个没看懂。能举个例子吗","like_count":0},{"had_liked":false,"id":308357,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1629552837,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1629552837","product_id":100037301,"comment_content":"支付单(正向，逆向)，支付合约单，结算单(商家到平台抽佣)<br>赔付单<br>交易订单<br>逆向退款单","like_count":0},{"had_liked":false,"id":308331,"user_name":"Geek_b1688e","can_delete":false,"product_type":"c1","uid":2742536,"ip_address":"","ucode":"84C9B9C1DE7E16","user_header":"","comment_is_top":false,"comment_ctime":1629538314,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1629538314","product_id":100037301,"comment_content":"如何按照领域去拆分，每个领域对应一套数据表，当领域变多的时候，会导致表也增加，那最后事件通知会变多，会不会对系统造成很大的负担。 麻烦老师看下。","like_count":0},{"had_liked":false,"id":304868,"user_name":"宫志伟","can_delete":false,"product_type":"c1","uid":1586774,"ip_address":"","ucode":"54639F9B6255FF","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/56/b3161eec.jpg","comment_is_top":false,"comment_ctime":1627648515,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1627648515","product_id":100037301,"comment_content":"您好，报价规则为什么是实体？按照文中对实体和值对象的定义，报价规则的属性变化，这个报价规则就是另外一个规则了，它应该是一个值对象才对，而不是一个实体。","like_count":0},{"had_liked":false,"id":299533,"user_name":"Simple","can_delete":false,"product_type":"c1","uid":1121301,"ip_address":"","ucode":"2F69FD2662A47A","user_header":"https://static001.geekbang.org/account/avatar/00/11/1c/15/f9ebf7e4.jpg","comment_is_top":false,"comment_ctime":1624696883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1624696883","product_id":100037301,"comment_content":"值对象，无ID我感觉描述不是十分恰当，我说下自己得想法：实体在某些地方可能是值对象，值对象也可能会是实体，也就是带ID得对象不一定就是实体仍然还可以当成值对象来处理，所以有无ID不是硬性条件，但是实体一定是有ID得。","like_count":0},{"had_liked":false,"id":297886,"user_name":"木木","can_delete":false,"product_type":"c1","uid":1256984,"ip_address":"","ucode":"E37D015EFDF3B3","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/RRQerM7wWWB23jYmINBltjAC92XeTSoeuBF8icIvMt5e5yic2eVuPAPK5UuqAOwdiaq6QyzeFPUKnr93ovs9I0IoQ/132","comment_is_top":false,"comment_ctime":1623832056,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623832056","product_id":100037301,"comment_content":"老师您好，想问下，如过数据库表很少，但是业务很复杂(应用层逻辑比较多)，需要很多外部门协作的业务类型，该怎么划分领域，如何设计聚合和实体呢？一个实体可以没有数据库表来与之对应吗？","like_count":0},{"had_liked":false,"id":297149,"user_name":"天马行空","can_delete":false,"product_type":"c1","uid":1740810,"ip_address":"","ucode":"5B019ABAFD1716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/90/0a/4d161db0.jpg","comment_is_top":false,"comment_ctime":1623329129,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1623329129","product_id":100037301,"comment_content":"之前我的项目是传统的面向服务设计的架构，是典型的数据驱动设计，技术架构已经过渡到微服务框架的时代，整体微服务拆分的确没有过实战的经验，开篇的6节课已经对微服务的设计领域驱动有所了解，清晰了微服务的设计方法准则。","like_count":0},{"had_liked":false,"id":296472,"user_name":"唐江","can_delete":false,"product_type":"c1","uid":1878120,"ip_address":"","ucode":"867C9808CF7760","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJpJXWFP3dNle88WnTkRTsEQkPJmOhepibiaTfhEtMRrbdg5EAWm4EzurA61oKxvCK2ZjMmy1QvmChw/132","comment_is_top":false,"comment_ctime":1622990444,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622990444","product_id":100037301,"comment_content":"老师问一下，两个聚合之间的值对象可以相互使用吗？ 我看LeavePO 的applicantType属性，引用了Person聚合中的PersonType值对象。","like_count":0},{"had_liked":false,"id":296123,"user_name":"秋天的透明雨🌧️","can_delete":false,"product_type":"c1","uid":1110437,"ip_address":"","ucode":"9363B49BFA6C14","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/a5/6cc9f728.jpg","comment_is_top":false,"comment_ctime":1622770865,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1622770865","product_id":100037301,"comment_content":"老师在回复问题中提到&quot;复杂查询一般不放在聚合内部，可以通过应用服务直接调用仓储查询接口来实现。&quot;，不是特别理解，什么场景需要这样处理？为什么要这么处理？<br><br>我先尝试理解一下：<br>1. 这里的复杂查询指需要跨多个聚合，查询各个聚合内的实体后，再组合成目标实体对象<br>2. 应用服务通过组合调用每个聚合内领域服务，同样可以完成该复杂查询，但是会多次访问数据库<br>3. 可以在仓储服务中提供跨聚合实体表的关联查询接口，然后应用服务直接调用该仓储服务接口完成查询，因为需要关联多个实体表，查询语句可能会比较复杂，但只需要访问一次数据库，性能可能会好一些<br><br>以上理解不知是否准确，求解惑，谢谢老师。","like_count":0},{"had_liked":false,"id":291487,"user_name":"黎明","can_delete":false,"product_type":"c1","uid":1193769,"ip_address":"","ucode":"3B57564F844EA5","user_header":"https://static001.geekbang.org/account/avatar/00/12/37/29/6f79782e.jpg","comment_is_top":false,"comment_ctime":1620305339,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620305339","product_id":100037301,"comment_content":"老师，支付行业中的支付渠道、订单、对账、结算、账户、商户等怎么设计聚合","like_count":0},{"had_liked":false,"id":285266,"user_name":"michael","can_delete":false,"product_type":"c1","uid":2381579,"ip_address":"","ucode":"9336BA1709A359","user_header":"","comment_is_top":false,"comment_ctime":1616717979,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1616717979","product_id":100037301,"comment_content":"欧老师，有两句话不太理解，请赐教。<br>“实体可以引用聚合内的聚合根、实体和值对象。”我理解实体本身就是被聚合根引用的，为什么他还会引用聚合内的聚合根呢？<br>值对象引用值对象是一个什么场景，值对象本身应该就是引用过来了一些属性吧","like_count":0},{"had_liked":false,"id":283684,"user_name":"Geek5198","can_delete":false,"product_type":"c1","uid":2028945,"ip_address":"","ucode":"2BEBE6A39D9A0E","user_header":"","comment_is_top":false,"comment_ctime":1615884947,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615884947","product_id":100037301,"comment_content":"欧老师请教下，在商品领域中，有商品子域、和品牌子域，其中商品聚合的聚合根是商品实体，品牌聚合的聚合根是品牌实体，商品和品牌的关系（包含商品id和品牌id）应该归属到哪一个聚合里呢？ 也是需要搞出一个独立的聚合，比如商品品牌挂靠聚合这样吗？ 类似的场景特别多，再比如类目聚合的聚合根是类目实体，那商品和类目的关系，又需要一个商品和类目关联聚合嘛","like_count":0},{"had_liked":false,"id":283624,"user_name":"sommir","can_delete":false,"product_type":"c1","uid":1372641,"ip_address":"","ucode":"805D63B3731D40","user_header":"https://static001.geekbang.org/account/avatar/00/14/f1/e1/e396d499.jpg","comment_is_top":false,"comment_ctime":1615859713,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1615859713","product_id":100037301,"comment_content":"老师你好！我这边在做用户权限设计的时候，碰到点问题。在权限这块，有角色，门户权限，菜单权限，组件权限。<br>如果从配置角色权限关系的角度上，我认为角色是聚合根，菜单，组件是此聚合内的实体。<br>但是如果是从修改权限本体，比如新增修改门户下菜单，新增修改门户下的组件，这个角度上又觉得门户应该作为聚合根，菜单和组件作为实体。<br>这种情况下聚合应该怎么设计呢？","like_count":0},{"had_liked":false,"id":279422,"user_name":"Salina","can_delete":false,"product_type":"c1","uid":1092515,"ip_address":"","ucode":"9626E76C98C2FF","user_header":"https://static001.geekbang.org/account/avatar/00/10/ab/a3/ffe2ced7.jpg","comment_is_top":false,"comment_ctime":1613782879,"is_pvip":false,"replies":[{"id":"101525","content":"是的。这是一个比较小的场景，投保和客户分别属于不同的聚合，如果放在企业整个业务域来看，它们分别属于客户和投保限界上下文，所以客户和投保会被分别拆分到不同限界上下文对应的微服务，在我后面章节的案例中会讲到企业级子域和限界上下文的划分。<br>在客户限界上下文内，在客户聚合完成客户聚合根增删改查等生命周期的维护，而在多个渠道进行投保时，需通过客户聚合完成客户聚合根实体的增加和修改。在投保聚合你可以引用客户ID值对象，需要获取客户详细信息时，可以通过客户ID查询客户聚合中的数据。当然你也可以将客户必需的多个属性整体设计为投保人或被保人等值对象，它们被投保单聚合根引用，它们的数据值来源于客户子域的客户聚合。这样通过值对象数据冗余的方式，可以降低微服务之间的服务调用和数据耦合。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1613805410,"ip_address":"","comment_id":279422,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1613782879","product_id":100037301,"comment_content":"老师，我也是做保险的，我做的是人寿保险。<br>我们的寿险核心业务拆出了：投保、核保、保全、理赔、续期、产品、保单、客户这些子域（每个子域都是一个独立应用，可以理解为一个服务中心——我们的服务粒度比较粗）。<br><br>在这节课您讲了投保场景的例子，我对例子的理解是：在投保子域中，构建了投保、客户两个聚合，我的疑问是：投保子域的客户聚合与客户子域中的客户聚合，服务职能上是不是一种重复，是不是违反了服务重用和共享的原则？<br>补充一下我们在实际业务中的场景：<br>投保子域接收微信、app、银行等前端的投保请求，这请求中含有客户信息。投保服务中心要判断客户是不是新客户（由客户服务中心提供这个能力），如果是老客户将客户中心获取客户ID作为当前投保单客户实体的ID（类似合并客户），如果是新客户则要根据信息创建一个新客户实体。<br><br>以上场景，涉及的服务职责应该如何分布——投保服务中心的客户聚合应该具备什么职责？客户服务中心应该提供什么职责？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515733,"discussion_content":"是的。这是一个比较小的场景，投保和客户分别属于不同的聚合，如果放在企业整个业务域来看，它们分别属于客户和投保限界上下文，所以客户和投保会被分别拆分到不同限界上下文对应的微服务，在我后面章节的案例中会讲到企业级子域和限界上下文的划分。\n在客户限界上下文内，在客户聚合完成客户聚合根增删改查等生命周期的维护，而在多个渠道进行投保时，需通过客户聚合完成客户聚合根实体的增加和修改。在投保聚合你可以引用客户ID值对象，需要获取客户详细信息时，可以通过客户ID查询客户聚合中的数据。当然你也可以将客户必需的多个属性整体设计为投保人或被保人等值对象，它们被投保单聚合根引用，它们的数据值来源于客户子域的客户聚合。这样通过值对象数据冗余的方式，可以降低微服务之间的服务调用和数据耦合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613805410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":277417,"user_name":"停三秒","can_delete":false,"product_type":"c1","uid":1442497,"ip_address":"","ucode":"C9D8F39F24672E","user_header":"https://static001.geekbang.org/account/avatar/00/16/02/c1/80e68043.jpg","comment_is_top":false,"comment_ctime":1612407961,"is_pvip":false,"replies":[{"id":"101035","content":"是的，聚合根没了后，它里面的实体也就不存在了。其它实体的创建和数据初始化都是通过聚合根来完成的，对于复杂的聚合数据初始化，可以通过工厂模式来统一处理。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1612851993,"ip_address":"","comment_id":277417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1612407961","product_id":100037301,"comment_content":"聚合根的生命周期决定了当前聚合内其他实体的生命周期么","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":515046,"discussion_content":"是的，聚合根没了后，它里面的实体也就不存在了。其它实体的创建和数据初始化都是通过聚合根来完成的，对于复杂的聚合数据初始化，可以通过工厂模式来统一处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612851993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274826,"user_name":"dongdong5820","can_delete":false,"product_type":"c1","uid":1438157,"ip_address":"","ucode":"272431574E123E","user_header":"https://static001.geekbang.org/account/avatar/00/15/f1/cd/210d3c74.jpg","comment_is_top":false,"comment_ctime":1611191693,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1611191693","product_id":100037301,"comment_content":"总结：事件风暴中，我们会根据一些业务操作和行为找出实体(Entity)和值对象(ValueObject)，进而将业务关联紧密的实体和值对象进行组合，构成聚合。再根据业务语义将多个聚合划定到同一个限界上下文(Bounded Context)中，并在限界上下文内完成领域建模。","like_count":0},{"had_liked":false,"id":268598,"user_name":"cash","can_delete":false,"product_type":"c1","uid":1089607,"ip_address":"","ucode":"16C33E7182855B","user_header":"https://static001.geekbang.org/account/avatar/00/10/a0/47/36207f72.jpg","comment_is_top":false,"comment_ctime":1608268354,"is_pvip":true,"replies":[{"id":"97834","content":"您说的这种业务场景，平台账号应该在其他电商平台进行维护吧。在会员注册这种场景下，应该会有会员聚合，而平台账号应该是以值对象的形式存在的。个人感觉设计一个会员聚合就可以了，平台账号值对象的属性集根据业务需要来定。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608793993,"ip_address":"","comment_id":268598,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1608268354","product_id":100037301,"comment_content":"欧老师好<br>我们现在有一个场景是会员注册，会员会通过不同的电商平台账号进行注册，在会员注册内部会对不同平台账号注册进行处理。在这个场景中我是否可以以会员，平台账号分别做为聚合根呢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511985,"discussion_content":"您说的这种业务场景，平台账号应该在其他电商平台进行维护吧。在会员注册这种场景下，应该会有会员聚合，而平台账号应该是以值对象的形式存在的。个人感觉设计一个会员聚合就可以了，平台账号值对象的属性集根据业务需要来定。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608793993,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":267250,"user_name":"¥D","can_delete":false,"product_type":"c1","uid":1382185,"ip_address":"","ucode":"1D221F10CAA172","user_header":"https://static001.geekbang.org/account/avatar/00/15/17/29/e8702443.jpg","comment_is_top":false,"comment_ctime":1607659832,"is_pvip":true,"replies":[{"id":"97836","content":"你说的这种征信不通过的投保单是不是暂存单的概念？个人感觉你不必再建一个投保申请的聚合。<br>其实投保暂存单属于投保单生命周期过程中的某一个中间状态，我们可以给投保单增加一个状态属性。如果查询出来的投保单暂存单需要变成正式的投保单，则需要满足投保单聚合的业务规则，比如说符合征信相关规则要求，才可以通过投保单聚合的业务规则来改变这个投保单的状态，从投保暂存单变成真正的投保单。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1608795416,"ip_address":"","comment_id":267250,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1607659832","product_id":100037301,"comment_content":"老师你好，我有个问题。<br>在实践中，总是发现查询一个聚合信息与创建聚合当下所需要的信息是不一样的。比如在创建一个投保单的时候，可能需要从其他领域获取投保人的征信，然后根据业务规则来判断是否允许创建投保单，为了数据统计和业务方的查询，这些信息也需要存根。但是如果保单创建成功了，后续查询保单信息的时候，创建时的投保人征信信息是不需要的。业务规则复杂的话，类似的场景可能非常多。<br>我的想法是，这种情况下除了投保单聚合，还需要一个投保申请的聚合，聚合根是投保申请记录。<br>问题是当投保申请满足业务规则之后，就要通过投保申请聚合转换重构一个投保单聚合，如果值对象比较多的话，整个转换过程也很繁琐，两个聚合中也会存在概念相近或者概念一样只是类名不一样的值对象。<br>请问老师这个思路是否有问题？应该怎么解决这种问题？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":511565,"discussion_content":"你说的这种征信不通过的投保单是不是暂存单的概念？个人感觉你不必再建一个投保申请的聚合。\n其实投保暂存单属于投保单生命周期过程中的某一个中间状态，我们可以给投保单增加一个状态属性。如果查询出来的投保单暂存单需要变成正式的投保单，则需要满足投保单聚合的业务规则，比如说符合征信相关规则要求，才可以通过投保单聚合的业务规则来改变这个投保单的状态，从投保暂存单变成真正的投保单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608795416,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260684,"user_name":"于途","can_delete":false,"product_type":"c1","uid":1669343,"ip_address":"","ucode":"70300C6CCCEAF1","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/df/424bdc4a.jpg","comment_is_top":false,"comment_ctime":1605082675,"is_pvip":true,"discussion_count":0,"race_medal":1,"score":"1605082675","product_id":100037301,"comment_content":"在对性能有极致要求的场景中，聚合可以独立作为一个微服务，以满足版本的高频发布和极致的弹性伸缩能力。","like_count":0},{"had_liked":false,"id":260106,"user_name":"Geek_31f071","can_delete":false,"product_type":"c1","uid":2007506,"ip_address":"","ucode":"CE9AC435366A26","user_header":"","comment_is_top":false,"comment_ctime":1604924615,"is_pvip":false,"replies":[{"id":"94662","content":"我一直在，可以随时提问的。<br>核心域是放在整个企业业务领域来考虑的，从而确定对不同的业务领域进行资源分配和投入，所以不要在普通的项目中纠结哪个子域是核心域。<br>在进行聚合设计时，有两种情况需要考虑：<br>第一类情况是，需要考虑哪些实体或者对象需要进行生命周期管理，然后将这些有关联的对象可以设计为一个聚合，在你所述业务领域中有用户、企业、职位和简历等，它们几个是可以独立进行生命周期管理（比如CRUD)的；<br>第二类是对于某些场景需要将多个不同聚合的数据（主要是值对象类型）进行归拢后形成的聚合，比应聘聚合，它会将企业ID、应聘或企业用户ID、简历ID等信息汇集到应聘聚合根，形成应聘聚合。<br>企业用户可以通过他的企业ID找到对应的应聘聚合根，然后找到应聘聚合根引用的简历ID找到简历，查看完简历后，就可以对应聘实体标记为合格和不合格。当然这一系列的操作都是在应用层的应用服务中完成的，它需要组合多个不同聚合的领域服务来完成。<br>关注简历是一个动作，不是实体，个人认为这是用户的行为，放在用户聚合可能会更合适一些。在用户聚合，用户聚合根可以引用关注简历实体，在执行关注简历操作时，你可以先通过应聘聚合根找到简历ID，然后将用户聚合根与简历ID建立引用关系，在用户聚合完成关注简历的业务逻辑操作。这个操作也需要在应用服务中组合应聘聚合查找简历ID领域服务和用户聚合关注简历领域服务两个服务组合来完成。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1605082641,"ip_address":"","comment_id":260106,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1604924615","product_id":100037301,"comment_content":"老师，对DDD研究的比较晚，刚发现您的教程，不知道现在咨询还是否能收到您的回复，我这里有些疑问想咨询一下：<br>业务领域：招聘行业<br>子领域可以大致划分为：职位、简历、用户（招聘用户、求职用户）、IM消息、企业（招聘方所属公司）<br>这些比较明确的大类是可以区分的，但是在细节每个人的理解却是不一致，比如：<br>1、招聘行业比较注重的是职位与简历，还会有一些商业产品（用以变现），感觉都是核心域，但感觉核心域又不可能那么多？<br>2、求职用户可以拿简历应聘职位，招聘用户可以对应聘记录设置合适或者不合适。这个用例我们目前是专门有个应聘的聚合（微服务），聚合根是应聘id，他是单独的一个领域还是属于职位或者简历领域呢？<br>3、招聘方可以关注简历、下载简历，如果关注简历、下载简历分别都是一个聚合的话，功能又太小，不能成为一个微服务，这些功能又应该属于哪个领域呢？<br>4、问题3中的关注简历，涉及到两个聚合根—用户和简历，属于哪个领域都感觉说得过去，但是又觉得比较牵强。目前做法是放在简历的领域中，因为关注简历的主要关注点是简历。<br>麻烦老师有时间帮忙解答下。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":509109,"discussion_content":"我一直在，可以随时提问的。\n核心域是放在整个企业业务领域来考虑的，从而确定对不同的业务领域进行资源分配和投入，所以不要在普通的项目中纠结哪个子域是核心域。\n在进行聚合设计时，有两种情况需要考虑：\n第一类情况是，需要考虑哪些实体或者对象需要进行生命周期管理，然后将这些有关联的对象可以设计为一个聚合，在你所述业务领域中有用户、企业、职位和简历等，它们几个是可以独立进行生命周期管理（比如CRUD)的；\n第二类是对于某些场景需要将多个不同聚合的数据（主要是值对象类型）进行归拢后形成的聚合，比应聘聚合，它会将企业ID、应聘或企业用户ID、简历ID等信息汇集到应聘聚合根，形成应聘聚合。\n企业用户可以通过他的企业ID找到对应的应聘聚合根，然后找到应聘聚合根引用的简历ID找到简历，查看完简历后，就可以对应聘实体标记为合格和不合格。当然这一系列的操作都是在应用层的应用服务中完成的，它需要组合多个不同聚合的领域服务来完成。\n关注简历是一个动作，不是实体，个人认为这是用户的行为，放在用户聚合可能会更合适一些。在用户聚合，用户聚合根可以引用关注简历实体，在执行关注简历操作时，你可以先通过应聘聚合根找到简历ID，然后将用户聚合根与简历ID建立引用关系，在用户聚合完成关注简历的业务逻辑操作。这个操作也需要在应用服务中组合应聘聚合查找简历ID领域服务和用户聚合关注简历领域服务两个服务组合来完成。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605082641,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":244645,"user_name":"¥D","can_delete":false,"product_type":"c1","uid":1382185,"ip_address":"","ucode":"1D221F10CAA172","user_header":"https://static001.geekbang.org/account/avatar/00/15/17/29/e8702443.jpg","comment_is_top":false,"comment_ctime":1598602957,"is_pvip":true,"replies":[{"id":"90661","content":"你说的优惠类型，可以理解为规则类型的配置信息，这类信息大多只提供查询服务，其生命周期可以采用数据导入方式，也可以从前端界面完成配置。对于这类数据，如果规则种类较多，但是规则与规则之间其实并无关联的情况，为了便于管理，我们可以将多个规则类的配置数据实体放在一个聚合中管理，主要提供规则的查询功能。<br>对于“一个客户每年只能享受一次投保优惠”，这类操作应该在客户聚合中，比如可以为客户聚合根建立一个享受投保优惠记录的实体或值对象。客户享受到优惠记录后，修改客户聚合中优惠记录实体或值对象数据。当客户投保保费优惠时，可以先从客户聚合的基本信息中获取优惠记录历史数据，然后判断是否可以享受优惠。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1599465878,"ip_address":"","comment_id":244645,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1598602957","product_id":100037301,"comment_content":"老师你好，有个场景想咨询一下。<br>还是课文中的投保单例子。假如有个需求，客户投保可以享受优惠。<br>1、投保优惠有两种类型，一种是按百分比优惠，一种是固定金额优惠。<br>2、优惠类型需要事先配置，配置有三个层级，城市默认配置、区域默认配置、客户指定配置。优先级是，先取客户指定的打折优惠，如果没有配置客户指定的优惠类型，就按照客户所在区域的优惠配置，如果还是没有，就按照客户所在城市的优惠配置。<br>3、一个客户每年只能享受一次投保优惠。<br><br>针对这样一个需求，应该怎样设计聚合呢？<br>盼老师解惑～","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504652,"discussion_content":"你说的优惠类型，可以理解为规则类型的配置信息，这类信息大多只提供查询服务，其生命周期可以采用数据导入方式，也可以从前端界面完成配置。对于这类数据，如果规则种类较多，但是规则与规则之间其实并无关联的情况，为了便于管理，我们可以将多个规则类的配置数据实体放在一个聚合中管理，主要提供规则的查询功能。\n对于“一个客户每年只能享受一次投保优惠”，这类操作应该在客户聚合中，比如可以为客户聚合根建立一个享受投保优惠记录的实体或值对象。客户享受到优惠记录后，修改客户聚合中优惠记录实体或值对象数据。当客户投保保费优惠时，可以先从客户聚合的基本信息中获取优惠记录历史数据，然后判断是否可以享受优惠。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599465878,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":242730,"user_name":"InfoQ_78c0e0eb4ec4","can_delete":false,"product_type":"c1","uid":2124931,"ip_address":"","ucode":"4E34ABC1C0F165","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/HH3sNZEjjic9M92fZnmvFDxDGQqFibAiciaeJUO6O8tQtflNdtt0O1CI0BbeKHHZ3qVQHujkJJQU5c0qyYiaWWgpXOg/132","comment_is_top":false,"comment_ctime":1597825184,"is_pvip":false,"replies":[{"id":"89553","content":"我感觉你这个规则应该是与商品或客户信息相关的，属于配置类的实体。当客户选择商品形成订单时，可提供赠送商品类规则的查询服务。<br>为了方便规则配置管理，建议你将这类配置数据实体单独放在一个独立的聚合里面，聚合内没有聚合根，聚合内实体相互独立，独立提供规则数据查询服务。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1597887616,"ip_address":"","comment_id":242730,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1597825184","product_id":100037301,"comment_content":"老师好！请问一个问题，在电商场景中，订单是分购买商品数量和赠送商品数量，这个规则是随着不同客户有所改变的，请问这个不确定的规则应该放在聚合中吗？如果不是，应该放在哪里？谢谢！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504083,"discussion_content":"我感觉你这个规则应该是与商品或客户信息相关的，属于配置类的实体。当客户选择商品形成订单时，可提供赠送商品类规则的查询服务。\n为了方便规则配置管理，建议你将这类配置数据实体单独放在一个独立的聚合里面，聚合内没有聚合根，聚合内实体相互独立，独立提供规则数据查询服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597887616,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2124931,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/HH3sNZEjjic9M92fZnmvFDxDGQqFibAiciaeJUO6O8tQtflNdtt0O1CI0BbeKHHZ3qVQHujkJJQU5c0qyYiaWWgpXOg/132","nickname":"InfoQ_78c0e0eb4ec4","note":"","ucode":"4E34ABC1C0F165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":302655,"discussion_content":"谢谢老师的指点!","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598999030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239097,"user_name":"Geek_697c69","can_delete":false,"product_type":"c1","uid":2015691,"ip_address":"","ucode":"B0580747571A3F","user_header":"","comment_is_top":false,"comment_ctime":1596434612,"is_pvip":false,"replies":[{"id":"88555","content":"是的。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1596672987,"ip_address":"","comment_id":239097,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1596434612","product_id":100037301,"comment_content":"战略设计，采用事件风暴的方法，进行领域故事分析，确定领域对象（实体、值对象、聚合、聚合根、实体关系、聚合关系、领域事件）及边界上下文。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":502977,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596672987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":233423,"user_name":"白雨轩","can_delete":false,"product_type":"c1","uid":1123492,"ip_address":"","ucode":"ACCFAFD777427F","user_header":"https://static001.geekbang.org/account/avatar/00/11/24/a4/fdcde25d.jpg","comment_is_top":false,"comment_ctime":1594311732,"is_pvip":false,"replies":[{"id":"86141","content":"你说得对。为了简单起见，没有将报价单单独放在其它聚合里面，报价单自身会有ID的，同时报价规则配置实体会有独立的聚合，有自己的ID。在这里报价单关联的报价规则设计为值对象可能会更好一些，报价单关联的是报价规则配置实体的ID。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1594337543,"ip_address":"","comment_id":233423,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1594311732","product_id":100037301,"comment_content":"「保费」和「报价规则」是实体，我的理解是在「报价单」为聚合的这个边界内他们是可以改的，我的【问题】是，这两者的实体key是什么呢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501018,"discussion_content":"你说得对。为了简单起见，没有将报价单单独放在其它聚合里面，报价单自身会有ID的，同时报价规则配置实体会有独立的聚合，有自己的ID。在这里报价单关联的报价规则设计为值对象可能会更好一些，报价单关联的是报价规则配置实体的ID。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594337543,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":230543,"user_name":"谢作作的男人","can_delete":false,"product_type":"c1","uid":1909094,"ip_address":"","ucode":"4F220EA8AEBFB9","user_header":"https://static001.geekbang.org/account/avatar/00/1d/21/66/85f247e2.jpg","comment_is_top":false,"comment_ctime":1593413778,"is_pvip":false,"replies":[{"id":"85213","content":"后面有一个完整的代码示例。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1593496325,"ip_address":"","comment_id":230543,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1593413778","product_id":100037301,"comment_content":"show me the code","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":499929,"discussion_content":"后面有一个完整的代码示例。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593496325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":223186,"user_name":"周卡卡","can_delete":false,"product_type":"c1","uid":1704302,"ip_address":"","ucode":"E34B7AEB6BDA84","user_header":"https://static001.geekbang.org/account/avatar/00/1a/01/6e/4775d90b.jpg","comment_is_top":false,"comment_ctime":1591017171,"is_pvip":false,"replies":[{"id":"82484","content":"聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，它只作为实体实现与聚合根自身行为相关的业务逻辑。而将跨多个实体的复杂的领域逻辑放在领域服务中实现。当然，简单聚合的跨实体的领域逻辑，可以考虑在聚合根的方法中实现。","user_name":"作者回复","user_name_real":"欧创新","uid":"1316268","ctime":1591255727,"ip_address":"","comment_id":223186,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1591017171","product_id":100037301,"comment_content":"老师，聚合和领域服务如何区分?都是包含实体的行为","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497045,"discussion_content":"聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，它只作为实体实现与聚合根自身行为相关的业务逻辑。而将跨多个实体的复杂的领域逻辑放在领域服务中实现。当然，简单聚合的跨实体的领域逻辑，可以考虑在聚合根的方法中实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591255727,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543349,"discussion_content":"老师 帮看看周卡卡同学的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641099513,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":497045,"ip_address":""},"score":543349,"extra":""}]},{"author":{"id":1704302,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/01/6e/4775d90b.jpg","nickname":"周卡卡","note":"","ucode":"E34B7AEB6BDA84","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":279010,"discussion_content":"如果跨多个实体的业务逻辑非常复杂，这些实现逻辑可以写在领域服务里，避免聚合根过于臃肿，但是这种情况下，又很容易出现传统的面向数据库编程中各种service导致的业务逻辑四散的问题，无非就是前者在ddd里叫domainService..这样的话，ddd的初衷我理解是通过领域模型(聚合 实体)就能直白的表的出业务，若是存在大量的领域服务，我们的领域模型体现不出业务的表达。。矛盾呀。。老师给个建议","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591272657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":220408,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1590236829,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1590236829","product_id":100037301,"comment_content":"电商交易中：<br>会员聚合，商品聚合，订单聚合(交易)等<br>会员聚合的聚合根是：会员<br>商品聚合的聚合根是：商品<br>聚合是：为了完成一个或多个特定业务目标的实体与值对象的集合<br>聚合的拆分本质是要符合高内聚低耦合原则<br>聚合间通过聚合根来进行关联","like_count":0},{"had_liked":false,"id":219994,"user_name":"Che Kwas","can_delete":false,"product_type":"c1","uid":1048095,"ip_address":"","ucode":"4CDF9CA041859C","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fe/1f/6a3f2abb.jpg","comment_is_top":false,"comment_ctime":1590132839,"is_pvip":false,"replies":[{"id":"81211","content":"1、一个聚合对应一个仓储，仓储是一种设计模式，不是数据库哈。一般一个微服务内的多个聚合是共享一个数据库的。<br>2、理论上，聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，它只作为实体实现与聚合根自身行为相关的业务逻辑。而将跨多个实体的复杂的领域逻辑放在领域服务中实现。当然，简单聚合的跨实体的领域逻辑，可以考虑在聚合根的方法中实现。 ","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590139629,"ip_address":"","comment_id":219994,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1590132839","product_id":100037301,"comment_content":"老师好，有两个疑问请教一下：<br>（1）一个聚合对应一个仓库（DB）？那一个服务由多个微服务组成，一个微服务又有多个DB，会不会导致DB过多？<br>（2）领域服务 和 聚合根 的职责有什么区别？感觉都是组织一个聚合内的多个实体&#47;值对象的逻辑。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":496018,"discussion_content":"1、一个聚合对应一个仓储，仓储是一种设计模式，不是数据库哈。一般一个微服务内的多个聚合是共享一个数据库的。\n2、理论上，聚合根方法和领域服务都可以组合多个实体对象完成复杂的领域逻辑。但为了避免聚合根的业务逻辑过于复杂，避免聚合根类代码量过于庞大，我个人建议聚合根除了承担它的聚合管理职能外，它只作为实体实现与聚合根自身行为相关的业务逻辑。而将跨多个实体的复杂的领域逻辑放在领域服务中实现。当然，简单聚合的跨实体的领域逻辑，可以考虑在聚合根的方法中实现。 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590139629,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1048095,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/fe/1f/6a3f2abb.jpg","nickname":"Che Kwas","note":"","ucode":"4CDF9CA041859C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271457,"discussion_content":"嗯嗯，明白了，多谢老师这么详细的回答～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590140880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219642,"user_name":"jun","can_delete":false,"product_type":"c1","uid":1899314,"ip_address":"","ucode":"3A9633CA1FE72E","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/LalJD9ruYQI5zVM1GOCe4PjunIbbeeMiacFHC4TAj0DBVeialKt3vRCLs9dxn1vYXvfp8pgcyaeEQkh1nde1JoBQ/132","comment_is_top":false,"comment_ctime":1590054459,"is_pvip":false,"replies":[{"id":"81144","content":"应该值对象比较好，要记录业务的快照数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1590099100,"ip_address":"","comment_id":219642,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1590054459","product_id":100037301,"comment_content":"有个疑问望老师解惑：电商里面的订单是聚合根，那么订单明细是实体，但明细中的商品属于另外一个业务领域，那么明细中的商品是以值对象存储好了，还是ID形式存储好了？<br>尝试自己分析一下：1、如果使用ID方式保存，那么商品删除后，会存在某些业务异常，所以感觉以值对象存储较好；","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495888,"discussion_content":"应该值对象比较好，要记录业务的快照数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590099100,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":214812,"user_name":"开心小毛","can_delete":false,"product_type":"c1","uid":1023762,"ip_address":"","ucode":"9D57A2773759F3","user_header":"","comment_is_top":false,"comment_ctime":1588822930,"is_pvip":false,"replies":[{"id":"80288","content":"DDD分层架构对三层架构的业务逻辑层进行了更清晰的划分，改善了三层架构核心业务逻辑混乱，代码改动相互影响大的问题。DDD分层架构将三层架构业务逻辑层的业务逻辑，拆分到了应用层和领域层，分别以应用服务和领域服务等形式存在。应用服务实现服务的组合和编排，领域服务完成核心领域逻辑，应用服务可以快速响应前端业务和流程的变化，而领域层则更加专注于领域模型和实现领域逻辑。<br>DDD更强调面向对象的设计方法，每个实体要有自己的业务行为，然后不同实体的行为可以组合为领域服务，多个领域服务组合为应用服务。大概就是这样一个逐层封装的关系。封装的好处就是依赖性的降低和可维护性的提高。<br>聚合是一个相对封闭的代码和执行空间，可以实现实体和聚合的完整逻辑，所以一般不会跨请求。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1589425765,"ip_address":"","comment_id":214812,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1588822930","product_id":100037301,"comment_content":"想请问老师一个问题：聚合内实体为什么得是充血模型呢？这样会不会让代码变得有状态。<br><br>如果采用贫血实现实体，再把其相关的方法加入到实现聚合的数据仓库中 （singleton），并通过参数把贫血的实体传入方法， 这样所有的逻辑都可以是stateless。<br><br>充血模型的实体对象的生命周期会跨请求么，这样会不会很耗内存。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494208,"discussion_content":"DDD分层架构对三层架构的业务逻辑层进行了更清晰的划分，改善了三层架构核心业务逻辑混乱，代码改动相互影响大的问题。DDD分层架构将三层架构业务逻辑层的业务逻辑，拆分到了应用层和领域层，分别以应用服务和领域服务等形式存在。应用服务实现服务的组合和编排，领域服务完成核心领域逻辑，应用服务可以快速响应前端业务和流程的变化，而领域层则更加专注于领域模型和实现领域逻辑。\nDDD更强调面向对象的设计方法，每个实体要有自己的业务行为，然后不同实体的行为可以组合为领域服务，多个领域服务组合为应用服务。大概就是这样一个逐层封装的关系。封装的好处就是依赖性的降低和可维护性的提高。\n聚合是一个相对封闭的代码和执行空间，可以实现实体和聚合的完整逻辑，所以一般不会跨请求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589425765,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":212905,"user_name":"hugeo","can_delete":false,"product_type":"c1","uid":1042824,"ip_address":"","ucode":"438F289EDD21CD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/88/941e488a.jpg","comment_is_top":false,"comment_ctime":1588236932,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1588236932","product_id":100037301,"comment_content":"老师讲解得很棒！<br><br>风控聚合设计练习：<br><br>背景，订单生成后到达风控，风控判断风险（可能需要用户确认和人工审核，涉及状态变更），如果用户修改了收货地址要重新过风控，重新生成风控单，风控客服可以给订单添加备注（注意是添加在订单上，第一次过风控的备注在第二次过风控时也要可以看到）<br><br>1. 事件风暴<br>订单  风控单  风控状态变更记录  消息发送记录(验证码，token等)  订单备注<br><br>2. 挑选聚合根<br>风控单<br>订单<br><br>3. 构建聚合<br>风控单：状态变更记录实体，消息发送记录实体，订单值对象<br>订单：订单备注实体","like_count":0},{"had_liked":false,"id":207893,"user_name":"耿冲","can_delete":false,"product_type":"c1","uid":1218152,"ip_address":"","ucode":"9D71F88C867C52","user_header":"https://static001.geekbang.org/account/avatar/00/12/96/68/9e531985.jpg","comment_is_top":false,"comment_ctime":1587209236,"is_pvip":false,"replies":[{"id":"77638","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1587251339,"ip_address":"","comment_id":207893,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1587209236","product_id":100037301,"comment_content":"帖子，评论，点赞组成一个聚合；帖子是一个实体，同时也是一个聚合根；评论，点赞是实体；评论人，点赞人是值对象。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492272,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587251339,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":204725,"user_name":"峰","can_delete":false,"product_type":"c1","uid":1390326,"ip_address":"","ucode":"527BB65559F0B0","user_header":"https://static001.geekbang.org/account/avatar/00/15/36/f6/d65b7302.jpg","comment_is_top":false,"comment_ctime":1586446043,"is_pvip":false,"replies":[{"id":"76557","content":"可以这么理解。这里面某些聚合内的实体可能会是其他聚合的值对象。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586488392,"ip_address":"","comment_id":204725,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586446043","product_id":100037301,"comment_content":"请问老师，我在设计身份与访问上下文中，有 菜单、权限、角色、账号，这四个分别都是聚合，都是聚合根，这样理解是对的吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491270,"discussion_content":"可以这么理解。这里面某些聚合内的实体可能会是其他聚合的值对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586488392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203974,"user_name":"新新","can_delete":false,"product_type":"c1","uid":1113354,"ip_address":"","ucode":"9308705EA0F014","user_header":"https://static001.geekbang.org/account/avatar/00/10/fd/0a/14948043.jpg","comment_is_top":false,"comment_ctime":1586314527,"is_pvip":false,"replies":[{"id":"76280","content":"理解的没问题。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586329497,"ip_address":"","comment_id":203974,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586314527","product_id":100037301,"comment_content":"又学了两节课，对实体、值对象、聚合、聚合根有了一些理解，欧老师看对不对：<br>1、实体和值对象是从哪里来的？是通过事件风暴讨论出来的，如果没有经过事件风暴的讨论，就定义实体和值对象，相当于纸上谈兵，从数据库设计反过来讨论实体和值对象有点像缘木求鱼，方向反了。<br>2、实体和值对象的共同点：都是业务上的概念，在边界上下文内语义是明确的没有歧义的，是领域模型到代码实现的桥梁。<br>3、区别：<br>    1）实体有id，里面的属性可以修改，id代表了这个实体；<br>    2）值对象没有id，属性的值就代表了这个值对象的，属性值变了就是另外一个值对象了；<br>    3）实体里可以包含值对象，把值对象当做实体的一个属性，而值对象不能包含实体；<br>    4）实体有生命周期，是连续的，是一条线，而值对象是一次性的，是个点。<br>4、举个栗子：基本每个系统都有用户管理，假设在这个系统里用户管理是个子域，在这个子域里通过事件风暴形成用户实体、角色实体、权限值对象，将用户、角色、权限聚合为用户聚合，用户实体作为聚合根，所有用户操作封装在用户聚合内，将用户聚合和组织聚合封装为一个用户管理边界上下文，用户管理边界上下文与用户管理子域重合，可以将用户管理作为一个微服务，或将用户聚合作为一个微服务。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":491024,"discussion_content":"理解的没问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586329497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":203087,"user_name":"xuzw","can_delete":false,"product_type":"c1","uid":1272270,"ip_address":"","ucode":"03D5A5BAAB52A4","user_header":"https://static001.geekbang.org/account/avatar/00/13/69/ce/269dd147.jpg","comment_is_top":false,"comment_ctime":1586138120,"is_pvip":false,"replies":[{"id":"76064","content":"建议你看一下第7节和加餐里的内容。里面有代码和它们的区别的介绍。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586223943,"ip_address":"","comment_id":203087,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586138120","product_id":100037301,"comment_content":"老师，请问领域服务与应用服务有什么区别，在代码形态两者的差别在哪。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490758,"discussion_content":"建议你看一下第7节和加餐里的内容。里面有代码和它们的区别的介绍。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586223943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202627,"user_name":"阿信","can_delete":false,"product_type":"c1","uid":1399663,"ip_address":"","ucode":"CC7B15CE63264B","user_header":"https://static001.geekbang.org/account/avatar/00/15/5b/6f/113e24e6.jpg","comment_is_top":false,"comment_ctime":1586017725,"is_pvip":false,"replies":[{"id":"75725","content":"理解没有问题。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1586040849,"ip_address":"","comment_id":202627,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1586017725","product_id":100037301,"comment_content":"欧老师，你好，我对聚合、聚合根的理解，不知道是否正确？<br><br>聚合：提供一个完整业务功能的单位。或者说，完成一个完整业务需求的一些有强关联关系的实体和值对象的组合，就是聚合。至于聚合的大小，根据业务场景以及团队情况来具体分析，一般情况下是建议设计小聚合。<br>聚合根：实体，具有全局唯一性。聚合中最核心的实体，所有其他的实体、值对象都是直接或者间接依存于他，是对他的描述or扩展；<br><br>第2节作者举了一个例子，桃树的细胞，我的理解，它是提供一个完整职能的最小单位，可以理解为一个聚合。（记得细胞是生命体活动的基本单位）","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490635,"discussion_content":"理解没有问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586040849,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197558,"user_name":"吴贤龙","can_delete":false,"product_type":"c1","uid":1220566,"ip_address":"","ucode":"45085FE86D6030","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","comment_is_top":false,"comment_ctime":1585385181,"is_pvip":false,"replies":[{"id":"74603","content":"订单下不是还有商品明细吗？放到商品明细实体里就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585389091,"ip_address":"","comment_id":197558,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1585385181","product_id":100037301,"comment_content":"老师，请教个问题，比如订单聚合，如果下单时，同一个商品购买了2个，那么设计这个订单项实体的时候，是给订单聚合添加两个订单项呢，还是给订单项实体设计个数量属性？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489546,"discussion_content":"订单下不是还有商品明细吗？放到商品明细实体里就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585389091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":216428,"discussion_content":"一个实体，商品实体应该是有数量和价格属性的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585449561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1220566,"avatar":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","nickname":"吴贤龙","note":"","ucode":"45085FE86D6030","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":215894,"discussion_content":"老师，再细问一次，放到商品明细实体里的话，一次购买两个相同的商品，是在明细实体添加两个相同的实体呢，还是只加一个实体，只是这个实体有个数量的属性？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585395402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197478,"user_name":"吴贤龙","can_delete":false,"product_type":"c1","uid":1220566,"ip_address":"","ucode":"45085FE86D6030","user_header":"https://static001.geekbang.org/account/avatar/00/12/9f/d6/f66133b4.jpg","comment_is_top":false,"comment_ctime":1585381050,"is_pvip":false,"replies":[{"id":"74617","content":"在设计的时候尽量减少频繁的提交操作，在一笔业务交易中尽量将所有修改内容放在一个数据库事务中提交。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585396315,"ip_address":"","comment_id":197478,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585381050","product_id":100037301,"comment_content":"老师，有什么好的办法和建议，可以有效避免一个情况，就是我只是改变聚合中一个实体的一个属性，导致要保存整个聚合","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489529,"discussion_content":"在设计的时候尽量减少频繁的提交操作，在一笔业务交易中尽量将所有修改内容放在一个数据库事务中提交。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585396315,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":196490,"user_name":"deem","can_delete":false,"product_type":"c1","uid":1936901,"ip_address":"","ucode":"3DBAAB685E0014","user_header":"","comment_is_top":false,"comment_ctime":1585285524,"is_pvip":false,"replies":[{"id":"74432","content":"如果限界上下文里只有一个聚合，那他们俩的边界就是一样的。限界上下文包含一到多个聚合，这些聚合在一样的语义环境下，也就是在一个限界上下文内。聚合和限界上下文都可以独立为微服务，但聚合是领域模型里面可独立为微服务的最小单元。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585291497,"ip_address":"","comment_id":196490,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585285524","product_id":100037301,"comment_content":"老师 希望能帮忙看下这个问题<br>限界上下文  跟聚合之间的关系<br>聚合是属于限界上下文的么？<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489314,"discussion_content":"如果限界上下文里只有一个聚合，那他们俩的边界就是一样的。限界上下文包含一到多个聚合，这些聚合在一样的语义环境下，也就是在一个限界上下文内。聚合和限界上下文都可以独立为微服务，但聚合是领域模型里面可独立为微服务的最小单元。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585291497,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":194728,"user_name":"成章","can_delete":false,"product_type":"c1","uid":1929644,"ip_address":"","ucode":"82D6E87A79A7B0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/71/ac/c87546f5.jpg","comment_is_top":false,"comment_ctime":1585100048,"is_pvip":false,"replies":[{"id":"74209","content":"一个聚合一个仓储，你这种情况其实在应用层就可以做到。应用服务主要用来进行聚合之间的协调，当b聚合在进行数据写入的时候，它的值对象的数据也是可以通应用服务调用a的领域服务写入a聚合的，因为涉及到同时修改两个聚合的数据，要做好事务或者采用事件总线异步化处理。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1585146728,"ip_address":"","comment_id":194728,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1585100048","product_id":100037301,"comment_content":"我看过一些ddd的资料，经常有说仓储是针对聚合根而存在的。但是我在实践过程中会遇到a聚合的一个用来判断的值对象和b聚合里的其实是一个东西，所以构造a聚合时需要调用b聚合的仓储构造出这个值对象，不然从数据表转换为值对象我就得写两遍。请问这种做法正常吗?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488882,"discussion_content":"一个聚合一个仓储，你这种情况其实在应用层就可以做到。应用服务主要用来进行聚合之间的协调，当b聚合在进行数据写入的时候，它的值对象的数据也是可以通应用服务调用a的领域服务写入a聚合的，因为涉及到同时修改两个聚合的数据，要做好事务或者采用事件总线异步化处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585146728,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185236,"user_name":"勤快的懒洋洋","can_delete":false,"product_type":"c1","uid":1270265,"ip_address":"","ucode":"DBCEE8283B54F5","user_header":"https://static001.geekbang.org/account/avatar/00/13/61/f9/c94bb871.jpg","comment_is_top":false,"comment_ctime":1583541977,"is_pvip":false,"replies":[{"id":"71816","content":"这个要看你的业务模型。从你的场景来看通知方式感觉像是一个实体的属性，不是实体肯定就不是聚合根了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583720341,"ip_address":"","comment_id":185236,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583541977","product_id":100037301,"comment_content":"老师请教一下，比如用户注册的时候会初始化他的通知方式(手机，邮箱)，通知方式在注册后可以单独修改，那么通知方式是独立的聚合根吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486302,"discussion_content":"这个要看你的业务模型。从你的场景来看通知方式感觉像是一个实体的属性，不是实体肯定就不是聚合根了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583720341,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185016,"user_name":"Geek_d38f30","can_delete":false,"product_type":"c1","uid":1512147,"ip_address":"","ucode":"955D6480731336","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/ib1aca6ibMC3bcTZeVdTFalyyhdvy4DLQ7s4WBTWaw95k8IJNTUkZ5VwfB9rYwxVz3PAz4chBJhWcyMHib9KdEEnQ/132","comment_is_top":false,"comment_ctime":1583466015,"is_pvip":false,"replies":[{"id":"71822","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583722041,"ip_address":"","comment_id":185016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583466015","product_id":100037301,"comment_content":"聚合由聚合根，实体，值对象组成<br>聚合根有实体的特性，关联对象能通过聚合根ID,找到到聚合根。关联对象的字段都要包含聚合根的ID<br>实体有唯一id，能通过id查询<br>值对象，无 ID，不可变，无生命周期，用完即扔。【不可重用，就记录值】<br>值对象之间通过属性值判断相等性。【无id,肯定要通过值判断相等性】<br>它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征。<br>值对象尽量只引用值对象。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486215,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583722041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184899,"user_name":"姚俊","can_delete":false,"product_type":"c1","uid":1364873,"ip_address":"","ucode":"2ABE42AC97B528","user_header":"https://static001.geekbang.org/account/avatar/00/14/d3/89/6f5c09bc.jpg","comment_is_top":false,"comment_ctime":1583427564,"is_pvip":false,"replies":[{"id":"71469","content":"这里的请假是实体的概念，不是动作。<br>登录在另外的权限微服务内，属于已有的微服务，这里登录是login的动作，不是实体，所以应该设计为服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583459291,"ip_address":"","comment_id":184899,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1583427564","product_id":100037301,"comment_content":"老师你好，后面看了您给的demo，有些疑问希望回复。比如，请假这个业务被设计成了聚合根，组织了其他实体和值对象之间的协作，但是请假实际上在一般理解下来是一个用户的动作<br>那么很自然的想到了登录，一般意义上这是账户发起的一个动作，比如权限管理系统有，菜单，角色，账户，用户实体，那么登录应该被设计成一个聚合，账户为聚合根呢？还是一个单独的领域服务？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486163,"discussion_content":"这里的请假是实体的概念，不是动作。\n登录在另外的权限微服务内，属于已有的微服务，这里登录是login的动作，不是实体，所以应该设计为服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583459291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":204449,"discussion_content":"聚合根的设计主要是看实体之间的关系，其实主要是看实体之间引用的关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584174548,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1364873,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d3/89/6f5c09bc.jpg","nickname":"姚俊","note":"","ucode":"2ABE42AC97B528","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198045,"discussion_content":"好的，感谢老师回复，那么还有个问题想和您探讨，对于业务的描述，一般是用户登录系统，然后需要请假，所以要填写请假单。\n按照这样的描述，是不是可以分析为，登录，请假都是一个动作，但是经过更深入的业务，发现，登录是一个单纯的动作，没有需要事务一致性的地方，但是请假虽然是动作，但是业务场景下是有实体关联的，并且需要有事务控制的，所以可以作为一个聚合根？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583466188,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184705,"user_name":"nssk","can_delete":false,"product_type":"c1","uid":1007266,"ip_address":"","ucode":"5839E5186900C6","user_header":"","comment_is_top":false,"comment_ctime":1583386936,"is_pvip":false,"replies":[{"id":"71432","content":"聚合是逻辑概念，它内部各个对象的逻辑就是这个聚合的逻辑。值对象很少有业务逻辑，一般只有查询的逻辑。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583390453,"ip_address":"","comment_id":184705,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583386936","product_id":100037301,"comment_content":"充血模型可以理解。只是一直有个没太想明白的地方，聚合和值对象里面是否可以有业务逻辑？这点老师能不能说明一下","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486102,"discussion_content":"聚合是逻辑概念，它内部各个对象的逻辑就是这个聚合的逻辑。值对象很少有业务逻辑，一般只有查询的逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583390453,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183560,"user_name":"克制的民工","can_delete":false,"product_type":"c1","uid":1886437,"ip_address":"","ucode":"48E0231F469DA5","user_header":"https://static001.geekbang.org/account/avatar/00/1c/c8/e5/c0e8c78d.jpg","comment_is_top":false,"comment_ctime":1583066865,"is_pvip":false,"replies":[{"id":"71056","content":"理论上是这样的，但是建议为复杂的聚合单独建一个领域服务类，把聚合的所有的领域服务放一起，聚合根只实现自己的业务行为，聚合内数据的初始化放在工厂服务里实现。简单的聚合可以灵活选择。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583072771,"ip_address":"","comment_id":183560,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583066865","product_id":100037301,"comment_content":"“跨多个实体的业务逻辑通过领域服务来实现，跨多个聚合的业务逻辑通过应用服务来实现“，那么聚合根就是领域服务吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485714,"discussion_content":"理论上是这样的，但是建议为复杂的聚合单独建一个领域服务类，把聚合的所有的领域服务放一起，聚合根只实现自己的业务行为，聚合内数据的初始化放在工厂服务里实现。简单的聚合可以灵活选择。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583072771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183557,"user_name":"克制的民工","can_delete":false,"product_type":"c1","uid":1886437,"ip_address":"","ucode":"48E0231F469DA5","user_header":"https://static001.geekbang.org/account/avatar/00/1c/c8/e5/c0e8c78d.jpg","comment_is_top":false,"comment_ctime":1583065568,"is_pvip":false,"replies":[{"id":"71057","content":"聚合根是一个特殊的实体。既有管理实体的功能，本身也是实体。它的方法可以充当领域服务，但是聚合根的方法不建议太复杂，复杂的聚合根逻辑会过于复杂，可以为每一个聚合单独建一个聚合领域服务类，里面实现集合所有的领域服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1583072980,"ip_address":"","comment_id":183557,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583065568","product_id":100037301,"comment_content":"请教一下，聚合根负责协同一个聚合内的实体和值对象实现领域服务，那么聚合根感觉既是领域服务又是实体吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485713,"discussion_content":"聚合根是一个特殊的实体。既有管理实体的功能，本身也是实体。它的方法可以充当领域服务，但是聚合根的方法不建议太复杂，复杂的聚合根逻辑会过于复杂，可以为每一个聚合单独建一个聚合领域服务类，里面实现集合所有的领域服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583072980,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181843,"user_name":"Geek_Jamy","can_delete":false,"product_type":"c1","uid":1791651,"ip_address":"","ucode":"021F9DD422ED84","user_header":"https://static001.geekbang.org/account/avatar/00/1b/56/a3/c15280b3.jpg","comment_is_top":false,"comment_ctime":1582643024,"is_pvip":false,"replies":[{"id":"70570","content":"原子服务是指的什么呢？是服务吗？如果是服务的话，当然应该有的，比如领域服务，应用服务等等。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582767778,"ip_address":"","comment_id":181843,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582643024","product_id":100037301,"comment_content":"老师，一个微服务内部还能有其他的原子服务吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485140,"discussion_content":"原子服务是指的什么呢？是服务吗？如果是服务的话，当然应该有的，比如领域服务，应用服务等等。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582767778,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180417,"user_name":"Avril","can_delete":false,"product_type":"c1","uid":1228452,"ip_address":"","ucode":"E6E60A26B72076","user_header":"https://static001.geekbang.org/account/avatar/00/12/be/a4/32866c50.jpg","comment_is_top":false,"comment_ctime":1582277210,"is_pvip":false,"replies":[{"id":"70619","content":"创建聚合应优先分析功能单元，也就是业务单一性，然后根据实体之间的依赖关系找出聚合根，所有的实体都被聚合根直接或者间接引用，根据这些实体创建聚合。其实有的时候，业务上的这种创建关系，只是业务逻辑上的先后顺序关系，在设计时，它们在两个不同的聚合，然后它们可以通过聚合根ID来实现聚合之间的引用和数据访问。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582782394,"ip_address":"","comment_id":180417,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582277210","product_id":100037301,"comment_content":"欧老师，你好，在实践DDD的时候，聚合和聚合根分析不清楚，麻烦帮忙看下。<br>对象的依赖关系如下（所有关系都是1对多，比如1个应用对应多个实验，1个实验可以有多个分层流量）：<br>\t&lt;-- 实验 &lt;-- 分层实验 &lt;-- 策略(xx类型用户使用xx流量分桶)<br>应用 \t <br>\t&lt;-- 分层流量 &lt;-- 流量分桶<br>\t<br>业务：<br>1. 应用可以床架实验、分层实验、策略<br>2. 应用可以创建分层流量、流量分桶<br>3. 启动实验，用户进来，根据配置的策略，找到流量分桶，返回分桶相关的数据<br>其中，上面的每个对象都会对应数据库的一张表。<br><br>上面如何设计聚合，聚合根比较合适，<br>(1) 是否可以创建或修改其它对象？<br>按照聚合根这个特定，是否应该以 应用 为聚合根，所有其它对象都在这个聚合里面？但这样，聚合里的实体太多<br>(2) 按照 聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。 这个理解，是不是一个聚合只对应一个xxxDao？<br>(3) 想问下，上面的例子，应该怎么设计聚合比较合适？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484656,"discussion_content":"创建聚合应优先分析功能单元，也就是业务单一性，然后根据实体之间的依赖关系找出聚合根，所有的实体都被聚合根直接或者间接引用，根据这些实体创建聚合。其实有的时候，业务上的这种创建关系，只是业务逻辑上的先后顺序关系，在设计时，它们在两个不同的聚合，然后它们可以通过聚合根ID来实现聚合之间的引用和数据访问。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582782394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180016,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1582166057,"is_pvip":false,"replies":[{"id":"69909","content":"用户和角色可以设计为两个聚合的。角色应该不止一个实体吧，用户聚合根通过角色ID访问角色中的数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1582178195,"ip_address":"","comment_id":180016,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582166057","product_id":100037301,"comment_content":"老师好，请问如果是一个后台类型的网站，用户有角色的属性。如果设计为用户聚合和角色聚合，角色聚合就仅仅有角色一个实体，而且用户和角色经常一起使用，比如登录时的权限 用户列表的展示 个人中心的展示。如果设计成在一个用户聚合内，那就有两个可独立存在的唯一标识了。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484493,"discussion_content":"用户和角色可以设计为两个聚合的。角色应该不止一个实体吧，用户聚合根通过角色ID访问角色中的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582178195,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178702,"user_name":"小谢同学","can_delete":false,"product_type":"c1","uid":1032544,"ip_address":"","ucode":"E809E6BC470631","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/60/fc3689d0.jpg","comment_is_top":false,"comment_ctime":1581780796,"is_pvip":false,"replies":[{"id":"69373","content":"跨微服务是通过应用层访问的，你可以直接访问另一个微服务的应用服务，由应用服务去调用聚合的领域服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581821730,"ip_address":"","comment_id":178702,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581780796","product_id":100037301,"comment_content":"请问跨微服务去引用聚合该如何实现呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483931,"discussion_content":"跨微服务是通过应用层访问的，你可以直接访问另一个微服务的应用服务，由应用服务去调用聚合的领域服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581821730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178493,"user_name":"小谢同学","can_delete":false,"product_type":"c1","uid":1032544,"ip_address":"","ucode":"E809E6BC470631","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/60/fc3689d0.jpg","comment_is_top":false,"comment_ctime":1581706674,"is_pvip":false,"replies":[{"id":"69237","content":"对，客户的聚合可能在客户中心的微服务里，投保在投保微服务里面。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581730660,"ip_address":"","comment_id":178493,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581706674","product_id":100037301,"comment_content":"图例中的投保聚合与客户聚合，在实际场景中应该不属于同一个领域模型吧","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483848,"discussion_content":"对，客户的聚合可能在客户中心的微服务里，投保在投保微服务里面。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581730660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178082,"user_name":"不懂","can_delete":false,"product_type":"c1","uid":1008254,"ip_address":"","ucode":"5543064281C2E7","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLNHMuJw6PpMiayXuE0wmEQ3guJwDcb6ysbicfvkQOUFhGXCX28RU59a4ABwrzFrcZibzTI6xwur8GYw/132","comment_is_top":false,"comment_ctime":1581583893,"is_pvip":false,"replies":[{"id":"69097","content":"订单和商品应该是两个不同的聚合吧。<br>数据库PO设计时，在订单聚合中会有订单的商品明细，订单商品明细实体中会有商品ID和订单ID。<br>DO设计时，一个订单会关联多个订单明细组合的list。<br><br>","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581598285,"ip_address":"","comment_id":178082,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1581583893","product_id":100037301,"comment_content":"老师，您好！请教一个关于数据库设计和领域设计关联的问题：<br>场景：在交易系统中，订单会有若干个商品，在数据库设计的时候，可以设计一张mapping表，将订单ID和商品ID进行绑定，这张表也会有自己的一个主键ID。在代码设计层面，订单作为一个聚合，关联了若干商品信息，那么请问：这张mapping表的ID应该放在哪里呢？<br>又或者说，可能表结构就不应该这么设计？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483661,"discussion_content":"订单和商品应该是两个不同的聚合吧。\n数据库PO设计时，在订单聚合中会有订单的商品明细，订单商品明细实体中会有商品ID和订单ID。\nDO设计时，一个订单会关联多个订单明细组合的list。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581598285,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176211,"user_name":"herry","can_delete":false,"product_type":"c1","uid":1314057,"ip_address":"","ucode":"81F4A983F41FFC","user_header":"https://static001.geekbang.org/account/avatar/00/14/0d/09/54dac89c.jpg","comment_is_top":false,"comment_ctime":1580989560,"is_pvip":false,"replies":[{"id":"68993","content":"关于订单和商品的不变性，其实里面是有一个重要的规则，也就是订单总金额一定会是所有商品数量乘以价格后的总和，商品是依附于订单存在的。这就是订单里面的不变性规则。<br>贴子和回复各自的生命周期是独立的。一个帖子可以没有回复。帖子和回复可以通过ID关联，也就是聚合之间的聚合根ID关联。帖子删了后，回复还是可以存在的，所以它们可以是两个不同的聚合。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581494039,"ip_address":"","comment_id":176211,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1580989560","product_id":100037301,"comment_content":"老师你好，<br>聚合有一个重要特证叫做不变性：聚合内有一套不变的业务规则，各实体和值对象按照统一的业务规则运行，实现对象数据的一致性<br><br>这里对不变性有疑问，感觉比较抽象。<br><br>用独立性来分析聚合的话：<br><br>拿贴子和回复来说，贴子和回复是可以独立存在的，所以这两个不是聚合<br><br>一个订单和它的商品行不能独立存在，这里一个订单是聚合，订单头是一个聚合根，关联了订单行<br><br>这两种情况下的不变性该怎么分析呢？<br><br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":483049,"discussion_content":"关于订单和商品的不变性，其实里面是有一个重要的规则，也就是订单总金额一定会是所有商品数量乘以价格后的总和，商品是依附于订单存在的。这就是订单里面的不变性规则。\n贴子和回复各自的生命周期是独立的。一个帖子可以没有回复。帖子和回复可以通过ID关联，也就是聚合之间的聚合根ID关联。帖子删了后，回复还是可以存在的，所以它们可以是两个不同的聚合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581494039,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543351,"discussion_content":"老师您举的这个例子 只是在商品和订单里面 那是不是所有的都存在这个不变性规则呢 也就是说不能通过个体的性质来推广到所有吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641100295,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":483049,"ip_address":""},"score":543351,"extra":""},{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":543352,"discussion_content":"如果有这么一套不变性的规则 怎么针对业务场景去找出来呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641100362,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":483049,"ip_address":""},"score":543352,"extra":""}]}]},{"had_liked":false,"id":175996,"user_name":"小谢同学","can_delete":false,"product_type":"c1","uid":1032544,"ip_address":"","ucode":"E809E6BC470631","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/60/fc3689d0.jpg","comment_is_top":false,"comment_ctime":1580906741,"is_pvip":false,"replies":[{"id":"68996","content":"聚合在微服务内实际上是一个功能集合的代码目录。它本身是一个逻辑概念，表示范围。正在这个代码目录内有聚合的实体，方法，领域服务等等。<br>微服务内的聚合数量是根据限界上下文来定义的，限界上下文里有多少个聚合，微服务就会有多少个聚合。<br>当然如果你还没有微服务运维的条件，比如Devops、CI&#47;CD等自动化工具，在业务域内保留限界上下文边界，不拆分多个微服务也是可以的，后面可以根据需要随时将多个聚合为拆分微服务。但是还是不建议放过多的聚合。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1581494743,"ip_address":"","comment_id":175996,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580906741","product_id":100037301,"comment_content":"请问老师聚合在微服务中以什么形态存在？另外对于一个微服务内的聚合数量是否有一些建议参考？谢谢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482988,"discussion_content":"聚合在微服务内实际上是一个功能集合的代码目录。它本身是一个逻辑概念，表示范围。正在这个代码目录内有聚合的实体，方法，领域服务等等。\n微服务内的聚合数量是根据限界上下文来定义的，限界上下文里有多少个聚合，微服务就会有多少个聚合。\n当然如果你还没有微服务运维的条件，比如Devops、CI/CD等自动化工具，在业务域内保留限界上下文边界，不拆分多个微服务也是可以的，后面可以根据需要随时将多个聚合为拆分微服务。但是还是不建议放过多的聚合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581494743,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174916,"user_name":"莫离","can_delete":false,"product_type":"c1","uid":1099426,"ip_address":"","ucode":"DB820A7284CC36","user_header":"https://static001.geekbang.org/account/avatar/00/10/c6/a2/11c99f7f.jpg","comment_is_top":false,"comment_ctime":1580458194,"is_pvip":false,"replies":[{"id":"67999","content":"聚合应该比模块还要小一些，它是一个比较小的功能集合，聚合内的对象可以独立完成聚合的逻辑，它也是可以独立部署为微服务的最小单位。领域模型里面可以包括多个聚合，一个聚合会有一个聚合根。所以一个领域模型至少有一个聚合根。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1580546714,"ip_address":"","comment_id":174916,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1580458194","product_id":100037301,"comment_content":"感觉一个聚合对应的就是传统架构里面的一个模块，这样理解对吗？想问下领域和聚合根应该是一对一的，是吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482564,"discussion_content":"聚合应该比模块还要小一些，它是一个比较小的功能集合，聚合内的对象可以独立完成聚合的逻辑，它也是可以独立部署为微服务的最小单位。领域模型里面可以包括多个聚合，一个聚合会有一个聚合根。所以一个领域模型至少有一个聚合根。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580546714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":174911,"user_name":"兆哲","can_delete":false,"product_type":"c1","uid":1269847,"ip_address":"","ucode":"1DAEA37570CB45","user_header":"https://static001.geekbang.org/account/avatar/00/13/60/57/70930a43.jpg","comment_is_top":false,"comment_ctime":1580455330,"is_pvip":false,"replies":[{"id":"68000","content":"在设计的时候要实体采用充血模型，让实体要有业务行为，也就是实体通过自身的实体类方法来实现实体的业务逻辑，采用面向对象的设计方法。多个实体组合的业务逻辑用领域服务来实现。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1580546966,"ip_address":"","comment_id":174911,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1580455330","product_id":100037301,"comment_content":"老师 看到这里 感觉聚合很像是领域服务，但是差别在于，领域服务没有聚合根，不知道这样理解对吗？<br>还有就是平时的业务场景发现，好像类型订单，之类的实体都是贫血模型，天生没有业务方法，不知道怎么应用DDD进行建模。希望老师能给一点提示。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482562,"discussion_content":"在设计的时候要实体采用充血模型，让实体要有业务行为，也就是实体通过自身的实体类方法来实现实体的业务逻辑，采用面向对象的设计方法。多个实体组合的业务逻辑用领域服务来实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580546966,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1269847,"avatar":"https://static001.geekbang.org/account/avatar/00/13/60/57/70930a43.jpg","nickname":"兆哲","note":"","ucode":"1DAEA37570CB45","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163794,"discussion_content":"明白了 还有老师，我发现现在团队的难点是一直保持数据库表和对象之间的映射关系的开发方式，所以一直没办法真正落地创建领域对象。 您有什么建议可以给我们吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581093483,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173697,"user_name":"很ok的火龙果","can_delete":false,"product_type":"c1","uid":1813273,"ip_address":"","ucode":"64D58FF8487F0D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ab/19/69e9f0fb.jpg","comment_is_top":false,"comment_ctime":1579662719,"is_pvip":false,"replies":[{"id":"67322","content":"账户在账户聚合内是聚合根。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579669522,"ip_address":"","comment_id":173697,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579662719","product_id":100037301,"comment_content":"“是否有独立的生命周期？是否有全局唯一 ID？是否可以创建或修改其它对象？是否有专门的模块来管这个实体。图中的聚合根分别是投保单和客户实体。”    ——— 账户也有唯一ID，也可以创建并修改其他对象，账户我理解应该也需要专门的模块管理吧，为啥“账户”不是聚合根呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482172,"discussion_content":"账户在账户聚合内是聚合根。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579669522,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":173694,"user_name":"很ok的火龙果","can_delete":false,"product_type":"c1","uid":1813273,"ip_address":"","ucode":"64D58FF8487F0D","user_header":"https://static001.geekbang.org/account/avatar/00/1b/ab/19/69e9f0fb.jpg","comment_is_top":false,"comment_ctime":1579662572,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1579662572","product_id":100037301,"comment_content":"“是否有独立的生命周期？是否有全局唯一 ID？是否可以创建或修改其它对象？是否有专门的模块来管这个实体。图中的聚合根分别是投保单和客户实体。”","like_count":0},{"had_liked":false,"id":172892,"user_name":"深山小书童","can_delete":false,"product_type":"c1","uid":1079593,"ip_address":"","ucode":"6B5DD3B3D84534","user_header":"https://static001.geekbang.org/account/avatar/00/10/79/29/a90cf777.jpg","comment_is_top":false,"comment_ctime":1579353706,"is_pvip":true,"replies":[{"id":"67071","content":"系统中应该会有一个聚合维护用户信息。另外，在处理角色关系时，如果有角色关系聚合，用户是作为角色关系的值对象存在的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579397343,"ip_address":"","comment_id":172892,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579353706","product_id":100037301,"comment_content":"老师你好，在用户权限系统中，用户和角色关系表在概念上是属于值对象吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481892,"discussion_content":"系统中应该会有一个聚合维护用户信息。另外，在处理角色关系时，如果有角色关系聚合，用户是作为角色关系的值对象存在的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579397343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":172669,"user_name":"小谢同学","can_delete":false,"product_type":"c1","uid":1032544,"ip_address":"","ucode":"E809E6BC470631","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c1/60/fc3689d0.jpg","comment_is_top":false,"comment_ctime":1579248809,"is_pvip":false,"replies":[{"id":"66981","content":"投保中的客户数据是作为客户投保时的一个快照数据，客户聚合修改的时候不会改变投保中的客户的冗余数据的，这时会数据不一致，但这种不一致也是一种正确的业务，它记录的是投保那一刻的真实数据。如果需要修改保单的客户数据需要走批改流程，来整体更新保单中的客户数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579252108,"ip_address":"","comment_id":172669,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1579248809","product_id":100037301,"comment_content":"请问老师，图示中的这个投保业务，当客户聚合中的数据发生变化后，是否会同步到投保单聚合中的值对象？文中提到是作为冗余数据存在，不会影响投保单聚合中的数据？也就是不一致？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481813,"discussion_content":"投保中的客户数据是作为客户投保时的一个快照数据，客户聚合修改的时候不会改变投保中的客户的冗余数据的，这时会数据不一致，但这种不一致也是一种正确的业务，它记录的是投保那一刻的真实数据。如果需要修改保单的客户数据需要走批改流程，来整体更新保单中的客户数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579252108,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":171674,"user_name":"logan","can_delete":false,"product_type":"c1","uid":1767668,"ip_address":"","ucode":"E79E750D3DFAB9","user_header":"https://static001.geekbang.org/account/avatar/00/1a/f8/f4/b0345597.jpg","comment_is_top":false,"comment_ctime":1578989634,"is_pvip":false,"replies":[{"id":"66976","content":"我感觉将帖子和回复独立为聚合根，主要考虑的还是帖子和回复的生命周期是否有依赖关系的问题。聚合根会管理聚合内的所有实体和值对象，以保证聚合内数据的一致性。操作过程中，我们可以对回复进行任意修改或者删除，不依赖于帖子，他们之间也不会产生数据或规则不一致的问题。但是两个聚合根之间确实是有ID关联。帖子和回复两个聚合之间可以通过帖子ID进行数据引用和查询。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1579250148,"ip_address":"","comment_id":171674,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1578989634","product_id":100037301,"comment_content":"老师我想请教一下帖子和回复为什么都是独立的聚合根，回复的生命周期不是依赖于帖子吗？没有帖子的话就不会有回复啊，可以理解为回复没有独立的生命周期吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":481465,"discussion_content":"我感觉将帖子和回复独立为聚合根，主要考虑的还是帖子和回复的生命周期是否有依赖关系的问题。聚合根会管理聚合内的所有实体和值对象，以保证聚合内数据的一致性。操作过程中，我们可以对回复进行任意修改或者删除，不依赖于帖子，他们之间也不会产生数据或规则不一致的问题。但是两个聚合根之间确实是有ID关联。帖子和回复两个聚合之间可以通过帖子ID进行数据引用和查询。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1579250148,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":167955,"user_name":"鱼客","can_delete":false,"product_type":"c1","uid":1070928,"ip_address":"","ucode":"5233FF41D88638","user_header":"https://static001.geekbang.org/account/avatar/00/10/57/50/82097d59.jpg","comment_is_top":false,"comment_ctime":1577969101,"is_pvip":false,"replies":[{"id":"65307","content":"可以设计三个DTO。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1578032597,"ip_address":"","comment_id":167955,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1577969101","product_id":100037301,"comment_content":"一个订单，顾客刚下单的时候它就是一个普通的订单，信息展现在分销商那里的，分销商加了点信息送到供应商那里，商品名称与价格等属性都有改变，这算是一个订单聚合呢。。 还是要分成2个呢。。订单在顾客端、分销商端、供应商端展示的属性均不同，这是3个DTO么？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480068,"discussion_content":"可以设计三个DTO。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578032597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166621,"user_name":"shitao","can_delete":false,"product_type":"c1","uid":1067270,"ip_address":"","ucode":"9F4D71D4F34B61","user_header":"https://static001.geekbang.org/account/avatar/00/10/49/06/b90049f4.jpg","comment_is_top":false,"comment_ctime":1577522305,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1577522305","product_id":100037301,"comment_content":"就绩效系统而言，可以拆分出：绩效文档聚合，目标聚合，打分聚合，参与绩效考评的人员聚合。值对象是考核项目","like_count":0},{"had_liked":false,"id":165925,"user_name":"张小俊","can_delete":false,"product_type":"c1","uid":1485185,"ip_address":"","ucode":"42B37D50B321B9","user_header":"https://static001.geekbang.org/account/avatar/00/16/a9/81/385b09dd.jpg","comment_is_top":false,"comment_ctime":1577345609,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1577345609","product_id":100037301,"comment_content":"写的好一般","like_count":0},{"had_liked":false,"id":163633,"user_name":"james.d","can_delete":false,"product_type":"c1","uid":1087225,"ip_address":"","ucode":"CEE241856AF3B7","user_header":"https://static001.geekbang.org/account/avatar/00/10/96/f9/3f976c91.jpg","comment_is_top":false,"comment_ctime":1576757751,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1576757751","product_id":100037301,"comment_content":"聚合的设计反映了对业务的理解，聚合根作为业务的入口，具有很高的业务价值。一个稳定的聚合才能支撑业务的长期发展。","like_count":0},{"had_liked":false,"id":163367,"user_name":"大卫高","can_delete":false,"product_type":"c1","uid":1088716,"ip_address":"","ucode":"0B12DF6AF08E7D","user_header":"https://static001.geekbang.org/account/avatar/00/10/9c/cc/b640e578.jpg","comment_is_top":false,"comment_ctime":1576714438,"is_pvip":false,"replies":[{"id":"62106","content":"这两个ID应该是统一的。但在领域逻辑实现的时候，实际是以实体的ID来进行比较的。实体DO的ID数据来源于数据库PO对象的ID。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576717615,"ip_address":"","comment_id":163367,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576714438","product_id":100037301,"comment_content":"老师，我在现在项目中已经开始逐渐使用 DDD了，但有个问题一直比较困惑，这里提到的聚合和实体的ID，到底应该直接使用数据库生成的主键还是自己定义业务唯一ID，如果使用业务唯一ID的话，那在实体相等性比较的时候又会同时涉及数据库ID和业务ID。请解惑","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478367,"discussion_content":"这两个ID应该是统一的。但在领域逻辑实现的时候，实际是以实体的ID来进行比较的。实体DO的ID数据来源于数据库PO对象的ID。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576717615,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":161198,"user_name":"给心来块冰块","can_delete":false,"product_type":"c1","uid":1063689,"ip_address":"","ucode":"7AFB56581782A2","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/09/2cf074a7.jpg","comment_is_top":false,"comment_ctime":1576143732,"is_pvip":true,"replies":[{"id":"61484","content":"建议结合事件风暴和设计过程，多看几遍会有收获的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1576194066,"ip_address":"","comment_id":161198,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1576143732","product_id":100037301,"comment_content":"一天看完，还懵懵的","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":477639,"discussion_content":"建议结合事件风暴和设计过程，多看几遍会有收获的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1576194066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":157482,"user_name":"Geek_88604f","can_delete":false,"product_type":"c1","uid":1501234,"ip_address":"","ucode":"33DD1318E53814","user_header":"","comment_is_top":false,"comment_ctime":1575173401,"is_pvip":false,"replies":[{"id":"60467","content":"主要还是为了解耦，持久化时是以聚合为单位进行持久化。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1575253058,"ip_address":"","comment_id":157482,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1575173401","product_id":100037301,"comment_content":"聚合之间是通过关联外部聚合根 ID 的方式引用，而不是直接对象引用的方式。这两者有什么区别呢，老师？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":476442,"discussion_content":"主要还是为了解耦，持久化时是以聚合为单位进行持久化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575253058,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1338086,"avatar":"https://static001.geekbang.org/account/avatar/00/14/6a/e6/92257004.jpg","nickname":"徐超越","note":"","ucode":"D2587A1CB6C15C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":127606,"discussion_content":"微服务之间用ID容易交互，而微服务之间的关系就是聚合根之间的关系，这样想就能体会到用ID的妙了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578582054,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":153843,"user_name":"Geek_aa8017","can_delete":false,"product_type":"c1","uid":1748911,"ip_address":"","ucode":"286195887103C2","user_header":"","comment_is_top":false,"comment_ctime":1574316303,"is_pvip":false,"replies":[{"id":"59133","content":"看你的领域服务放在在聚合根类内还是单独设计一个领域服务类，领域服务类内实现所有的领域服务。两者都可以。第一种方式调聚合根内的方法，第二种方式调领域服务类内的方法。他们都可以实现领域服务。但我建议你用第二种方法，这样边界和定位相对比较清晰。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574324017,"ip_address":"","comment_id":153843,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1574316303","product_id":100037301,"comment_content":"老师，一个聚合可以有实体和领域服务，应用层调用聚合是调用聚合根还是领域服务呢","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475294,"discussion_content":"看你的领域服务放在在聚合根类内还是单独设计一个领域服务类，领域服务类内实现所有的领域服务。两者都可以。第一种方式调聚合根内的方法，第二种方式调领域服务类内的方法。他们都可以实现领域服务。但我建议你用第二种方法，这样边界和定位相对比较清晰。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574324017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":152651,"user_name":"八百","can_delete":false,"product_type":"c1","uid":1253530,"ip_address":"","ucode":"79F1F79ADF5A00","user_header":"https://static001.geekbang.org/account/avatar/00/13/20/9a/3b1c65fd.jpg","comment_is_top":false,"comment_ctime":1574056688,"is_pvip":false,"replies":[{"id":"58667","content":"1、外部调用通过应用服务。<br>2、放应用层和放领域层所需要的参数的应该差异不大吧。前一个领域服务处理后，参数传给第二个领域服务而已。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1574072911,"ip_address":"","comment_id":152651,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1574056688","product_id":100037301,"comment_content":"1、如果保费与报价规则一对多(保费的计算由多个规则计算得到，不是仅一个规则)，现在有2种类型规则：vip打七折、已消费年保费大于1千元减200，  但是如果判断vip和已消费的年保费依赖外部系统的rpc接口，那么外部系统的调用能放在投保单这个聚合的规则实体中吗，因为我好像看到外部系统的调用，应该放在四层结构的应用层中<br>2、如果采用应用层调用外部系统的接口，那么是否是vip，和已消费年保费，是当做参数  传递到 领域层的投保单聚合中吗？如果是这样的，如果规则类型很多，需要传递的参数是否太多了","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474886,"discussion_content":"1、外部调用通过应用服务。\n2、放应用层和放领域层所需要的参数的应该差异不大吧。前一个领域服务处理后，参数传给第二个领域服务而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574072911,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501234,"avatar":"","nickname":"Geek_88604f","note":"","ucode":"33DD1318E53814","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":72147,"discussion_content":"对外部系统的调用放在应用层还是聚合中，这里面有什么权衡？感觉从业务的完整性上来看放在聚合中比较合适啊。毕竟存储也算外部系统吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1575471020,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":150512,"user_name":"Benjamn","can_delete":false,"product_type":"c1","uid":1306703,"ip_address":"","ucode":"5DCD2D90F5D3AC","user_header":"https://wx.qlogo.cn/mmopen/vi_32/hfiatPIQkm18DdAGphc5onlAIbdXbpt3uRBG8SBwU5QicLIkTI3Z8nReAwjyNbnjOQqCc5M38fWcHpmma8dyk8lQ/132","comment_is_top":false,"comment_ctime":1573547978,"is_pvip":false,"replies":[{"id":"57885","content":"谢谢提醒。后面章节在讲案例的时候，会有具体的分析过程。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573552822,"ip_address":"","comment_id":150512,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573547978","product_id":100037301,"comment_content":"这篇文章从光听，到看文字，起码看了5,6遍（很多同学反映比较抽象，我也感觉是这样的）。希望欧老师以后可以直接从案例入手，通过详细解析一个案例，从而逐步带出对“领域”、“实体”、“值对象”、“聚合”还有“聚合根”的解释和含义，这样对于我们初学者来说 可能会更加容易理解：）","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474184,"discussion_content":"谢谢提醒。后面章节在讲案例的时候，会有具体的分析过程。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573552822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149153,"user_name":"xj_zh","can_delete":false,"product_type":"c1","uid":1214755,"ip_address":"","ucode":"190609F7AE67CC","user_header":"https://static001.geekbang.org/account/avatar/00/12/89/23/73569bd7.jpg","comment_is_top":false,"comment_ctime":1573171027,"is_pvip":false,"replies":[{"id":"57341","content":"这个用户只是传输过程中的DTO的数据。不是领域模型中DO对象。是实体还是值对象要看DO的属性和特征。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573174654,"ip_address":"","comment_id":149153,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573171027","product_id":100037301,"comment_content":"欧老师，你好，有两个问题想问一下。<br><br>1. 添加用户<br><br>从客户端传过来用户基础信息，这些内容是没有id标识的，是属于值对象范畴吗？<br><br>2. 更新用户信息<br><br>更新的时候会从客户端传过来用户id标识，和要更新的用户信息，那么这个对象属于实体对象吗？<br><br>应该怎么区分这两者之间的关系。谢谢！","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473752,"discussion_content":"这个用户只是传输过程中的DTO的数据。不是领域模型中DO对象。是实体还是值对象要看DO的属性和特征。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573174654,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":149129,"user_name":"甜甜圈","can_delete":false,"product_type":"c1","uid":1019996,"ip_address":"","ucode":"9E873B7C8E2867","user_header":"https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLK5P6nyJGWpZWhh9xT03G5jAOa0iavdoz6hpNX1y9BxjeHy19zAW8iaLFib3aJD2hngLAQCRrkiahEew/132","comment_is_top":false,"comment_ctime":1573160194,"is_pvip":false,"replies":[{"id":"57326","content":"通过应用服务来调用。主要是为了避免泄露领域逻辑。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573169706,"ip_address":"","comment_id":149129,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573160194","product_id":100037301,"comment_content":"老师，聚合内的领域服务，是直接可以被应用层调用还是需要通过聚合根类定义的方法来调用？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473746,"discussion_content":"通过应用服务来调用。主要是为了避免泄露领域逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573169706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148926,"user_name":"骆驼1089","can_delete":false,"product_type":"c1","uid":1046421,"ip_address":"","ucode":"6E2EA2955BF204","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f7/95/42e16e49.jpg","comment_is_top":false,"comment_ctime":1573112162,"is_pvip":false,"replies":[{"id":"57304","content":"应该没错。你是指哪个地方有问题呢？","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573117547,"ip_address":"","comment_id":148926,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1573112162","product_id":100037301,"comment_content":"老师，这篇文章里面的关于 实体 和 值对象的 标识，是标注错了吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473670,"discussion_content":"应该没错。你是指哪个地方有问题呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573117547,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1046421,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f7/95/42e16e49.jpg","nickname":"骆驼1089","note":"","ucode":"6E2EA2955BF204","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":46289,"discussion_content":"哈哈😄，是我自己没有描述清楚，是图片里面关于 实体 和值对象 的颜色小圈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573138608,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":148388,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1573001162,"is_pvip":false,"replies":[{"id":"57131","content":"为什么要尽量避免跨聚合的领域服务调用和数据库表关联呢？我是这么考虑的，保持聚合之间的松耦合，如果出现领域服务或者数据表之间的关联，聚合之间就会产生耦合。如果以后聚合需要拆分到其它微服务，这个过程就很复杂了。通过唯一标识引用，你看可以通过应用服务来实现。在微服务演进过程中，聚合的重组，只需要在应用层做解耦就可以了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1573007974,"ip_address":"","comment_id":148388,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1573001162","product_id":100037301,"comment_content":"“应避免跨聚合的领域服务调用和跨聚合的数据库表关联”与“通过唯一标识引用其它聚合”是不是有冲突呢？我认为在表中应该存储领域之间的关联ID","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473479,"discussion_content":"为什么要尽量避免跨聚合的领域服务调用和数据库表关联呢？我是这么考虑的，保持聚合之间的松耦合，如果出现领域服务或者数据表之间的关联，聚合之间就会产生耦合。如果以后聚合需要拆分到其它微服务，这个过程就很复杂了。通过唯一标识引用，你看可以通过应用服务来实现。在微服务演进过程中，聚合的重组，只需要在应用层做解耦就可以了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573007974,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147055,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1572778319,"is_pvip":false,"replies":[{"id":"56800","content":"不是。聚合包括若干实体，值对象以及领域服务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572823709,"ip_address":"","comment_id":147055,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572778319","product_id":100037301,"comment_content":"一个聚合就可以是一个领域服务吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473120,"discussion_content":"不是。聚合包括若干实体，值对象以及领域服务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572823709,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1100064,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","nickname":"zj","note":"","ucode":"E3329CCF694AC2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42953,"discussion_content":"老师解释的很细心，再问下哈，不同聚合之间，如果一个聚合的数据修改，应该有可能导致其他的聚合的数据改变吧？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572834853,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147053,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1572778281,"is_pvip":false,"replies":[{"id":"56801","content":"跨聚合同时修改多个聚合数据，需要做事务控制，以保证数据一致性。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572823807,"ip_address":"","comment_id":147053,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572778281","product_id":100037301,"comment_content":"如果在同一个上下文的两个聚合，我理解就能在同一个事务操作吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473118,"discussion_content":"跨聚合同时修改多个聚合数据，需要做事务控制，以保证数据一致性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572823807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":147051,"user_name":"zj","can_delete":false,"product_type":"c1","uid":1100064,"ip_address":"","ucode":"E3329CCF694AC2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c9/20/e4f1b17c.jpg","comment_is_top":false,"comment_ctime":1572778061,"is_pvip":false,"replies":[{"id":"56802","content":"它们在同一个业务语义下共同完成特定的业务。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572823894,"ip_address":"","comment_id":147051,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572778061","product_id":100037301,"comment_content":"多个聚合限定在同一个有限上下文，这个有啥用呢<br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":473117,"discussion_content":"它们在同一个业务语义下共同完成特定的业务。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572823894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145970,"user_name":"熊瑞","can_delete":false,"product_type":"c1","uid":1031533,"ip_address":"","ucode":"5977D34E95EB19","user_header":"https://static001.geekbang.org/account/avatar/00/0f/bd/6d/7266c83e.jpg","comment_is_top":false,"comment_ctime":1572409774,"is_pvip":false,"replies":[{"id":"56348","content":"跨多聚合的一般都是应用服务。<br>不理解你说的同一个领域概念，又涉及到两个聚合，是什么意思哈？<br>在同一个限界上下文内就说明他们就是在同一个领域模型中呢。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572419679,"ip_address":"","comment_id":145970,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572409774","product_id":100037301,"comment_content":"老师，请教您个问题，如果跨聚合的操作，放到应用服务中。我们知道，大部分的聚合，其实是单一实体，一部分的业务逻辑，是需要多个聚合参与的，如果这个业务逻辑是一个领域概念，我们一般是放到领域服务里的。<br>所以这个地方我很迷惑，如果再一个边界上下文中，有一个业务逻辑，涉及到两个聚合操作，同时它又是一个领域概念，我到底是放在领域服务，还是应用服务呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472650,"discussion_content":"跨多聚合的一般都是应用服务。\n不理解你说的同一个领域概念，又涉及到两个聚合，是什么意思哈？\n在同一个限界上下文内就说明他们就是在同一个领域模型中呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572419679,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145909,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572401252,"is_pvip":false,"replies":[{"id":"56316","content":"聚合本身就是业务独立的，从垂直调用的角度来看，对调用链的长度会有一些影响，但是不大。这种场景一个聚合独立为微服务后，在版本发布以及弹性伸缩方面就更容易了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572404610,"ip_address":"","comment_id":145909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572401252","product_id":100037301,"comment_content":"但在对性能有极致要求的场景中，聚合可以独立作为一个微服务，以满足版本的高频发布和极致的弹性伸缩能力。<br>拆分的越小，服务的调用链越长，不是性能更差吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472626,"discussion_content":"聚合本身就是业务独立的，从垂直调用的角度来看，对调用链的长度会有一些影响，但是不大。这种场景一个聚合独立为微服务后，在版本发布以及弹性伸缩方面就更容易了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572404610,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145722,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572352393,"is_pvip":false,"replies":[{"id":"56277","content":"先谈一下设计吧。如果有这么上百个明细，那订单明细应该设计为订单的关联实体了。<br>这个需要结合你的场景和需求，如果只查看订单，查出订单就可以了。如果需要查看所有的订单明细，查出订单引用的所有明细就可以了。有了实体的关联，你可以根据需要来获取数据。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572392388,"ip_address":"","comment_id":145722,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572352393","product_id":100037301,"comment_content":"例如，订单和订单明细是一个聚合，订单是聚合根。如果订单明细有几百个明细，我查询一个订单需要带出这么多明细吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472545,"discussion_content":"先谈一下设计吧。如果有这么上百个明细，那订单明细应该设计为订单的关联实体了。\n这个需要结合你的场景和需求，如果只查看订单，查出订单就可以了。如果需要查看所有的订单明细，查出订单引用的所有明细就可以了。有了实体的关联，你可以根据需要来获取数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572392388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145720,"user_name":"张迪","can_delete":false,"product_type":"c1","uid":1104835,"ip_address":"","ucode":"6A5D44999A0FEA","user_header":"https://static001.geekbang.org/account/avatar/00/10/db/c3/e11adfe8.jpg","comment_is_top":false,"comment_ctime":1572351840,"is_pvip":false,"replies":[{"id":"56278","content":"最好把姓名冗余过去，这样记录的是出单那一刻的客户的真实数据。客户基本信息修改后不会修改保单中的客户数据。如果要修改保单的客户冗余数据也是可以的，可以用新的客户数据做整体替换。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572392590,"ip_address":"","comment_id":145720,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1572351840","product_id":100037301,"comment_content":"被保人和投保人 就是客户的ID。需不需要把 客户的名称也 冗余过去？ <br>一般姓名不会随意修改，但是也存在姓名更改的情况，<br>但是 如果 姓名被修改的话，还需要在同步修改 投保单吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472544,"discussion_content":"最好把姓名冗余过去，这样记录的是出单那一刻的客户的真实数据。客户基本信息修改后不会修改保单中的客户数据。如果要修改保单的客户冗余数据也是可以的，可以用新的客户数据做整体替换。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572392590,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205151,"avatar":"https://static001.geekbang.org/account/avatar/00/12/63/9f/a6edd37e.jpg","nickname":"天涯海峰","note":"","ucode":"56BF04C20AF39D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":41205,"discussion_content":"一般情况，承保以后，要修改姓名就成为批单了。投保单是不变的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572363336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145635,"user_name":"逍遥法外","can_delete":false,"product_type":"c1","uid":1103533,"ip_address":"","ucode":"75458730192696","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/ad/52df3832.jpg","comment_is_top":false,"comment_ctime":1572335027,"is_pvip":false,"replies":[{"id":"56231","content":"是的。需要慢慢思考和沉淀，理解了你就能灵活运用了。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572339392,"ip_address":"","comment_id":145635,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572335027","product_id":100037301,"comment_content":"这个课真难，得慢慢思考专心啃","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472501,"discussion_content":"是的。需要慢慢思考和沉淀，理解了你就能灵活运用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572339392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":145289,"user_name":"Geek_a91670","can_delete":false,"product_type":"c1","uid":1705156,"ip_address":"","ucode":"6CAA9FF890F8EA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/04/c4/ef4bd241.jpg","comment_is_top":false,"comment_ctime":1572245992,"is_pvip":false,"replies":[{"id":"56051","content":"在同一个微服务内，一般不会出现一个实体同时出现在多个聚合的这种情况。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572257606,"ip_address":"","comment_id":145289,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572245992","product_id":100037301,"comment_content":"老师:一个实体能出现在多个聚合内吗?","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472320,"discussion_content":"在同一个微服务内，一般不会出现一个实体同时出现在多个聚合的这种情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572257606,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144937,"user_name":"墨名次","can_delete":false,"product_type":"c1","uid":1330267,"ip_address":"","ucode":"926EDC57291C09","user_header":"https://static001.geekbang.org/account/avatar/00/14/4c/5b/5499d6e6.jpg","comment_is_top":false,"comment_ctime":1572105446,"is_pvip":false,"replies":[{"id":"55891","content":"值对象可以整体替换，但不能对里面的属性数据做局部修改。你可以这么理解，值对象是一个字段，但不同的是值对象里面还有有很多其它属性。数据库里面你可修改的最小单元是字段，你不可以对这个字段的具备修改，你只能整体修改字段的内容。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572137111,"ip_address":"","comment_id":144937,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572105446","product_id":100037301,"comment_content":"老师，有个问题不明白：值对象的不可变指的是什么？拿上一章的Person跟Address来说，Address是值对象，对于Address来说，它的不可变指的是它的属性名称不可变？还是属性值不可变？或者是它里面的属于数量不可变？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472175,"discussion_content":"值对象可以整体替换，但不能对里面的属性数据做局部修改。你可以这么理解，值对象是一个字段，但不同的是值对象里面还有有很多其它属性。数据库里面你可修改的最小单元是字段，你不可以对这个字段的具备修改，你只能整体修改字段的内容。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572137111,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144931,"user_name":"liuchangit","can_delete":false,"product_type":"c1","uid":1209215,"ip_address":"","ucode":"340AC5EE9522D0","user_header":"https://static001.geekbang.org/account/avatar/00/12/73/7f/5cc5ac12.jpg","comment_is_top":false,"comment_ctime":1572100873,"is_pvip":false,"replies":[{"id":"55892","content":"据我所知，现在的java框架对orm支持得不够好。而nosql的方式可能支持的更好一些。所以这一块的设计尽量结合自己的技术和业务场景，如果不会在聚合内产生数据不一致的情况，在技术不具备的时候，咱们没必要为了DDD而做DDD。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572137389,"ip_address":"","comment_id":144931,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572100873","product_id":100037301,"comment_content":"领域驱动设计里介绍，只为聚合根提供repository，想问下老师，在一个聚合内所有实体和值对象的存取（如文中投保单聚合内的对象），都由这个repository来负责数据库交互吗？感觉常见的orm框架似乎都做不到这一点。在DDD实践中，这个问题一般怎么解决呢？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472172,"discussion_content":"据我所知，现在的java框架对orm支持得不够好。而nosql的方式可能支持的更好一些。所以这一块的设计尽量结合自己的技术和业务场景，如果不会在聚合内产生数据不一致的情况，在技术不具备的时候，咱们没必要为了DDD而做DDD。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572137389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144715,"user_name":"清涧飞鸟","can_delete":false,"product_type":"c1","uid":1706683,"ip_address":"","ucode":"15F3B5FD4D7822","user_header":"https://static001.geekbang.org/account/avatar/00/1a/0a/bb/2f3b6af3.jpg","comment_is_top":false,"comment_ctime":1572006849,"is_pvip":false,"replies":[{"id":"55777","content":"限界上下文如果被被设计为一个微服务的话，它的代码就是一个微服务发布包。理论上一个限界上下文就可以设计为一个微服务，但它还受其它外部因素限制，比如技术异构，团队沟通成本，版本发布频率，性能等因素。<br>聚会根就是一个实体。不过它是一个具有管理功能的特殊实体。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1572011713,"ip_address":"","comment_id":144715,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1572006849","product_id":100037301,"comment_content":"老师，我有两个问题：<br>1界限上下文代码中的体现是个包？<br>2聚合根可以是一个具体的实体吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472080,"discussion_content":"限界上下文如果被被设计为一个微服务的话，它的代码就是一个微服务发布包。理论上一个限界上下文就可以设计为一个微服务，但它还受其它外部因素限制，比如技术异构，团队沟通成本，版本发布频率，性能等因素。\n聚会根就是一个实体。不过它是一个具有管理功能的特殊实体。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572011713,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144591,"user_name":"夙梦流尘","can_delete":false,"product_type":"c1","uid":1477260,"ip_address":"","ucode":"D7E84D3B588BD6","user_header":"https://static001.geekbang.org/account/avatar/00/16/8a/8c/07dd8832.jpg","comment_is_top":false,"comment_ctime":1571973907,"is_pvip":false,"replies":[{"id":"55732","content":"应用服务是在聚合之上的，它不是单独属于某个聚合的。在应用服务内聚合根可以引用其它聚合的聚合根，读取或者修改其它聚合的实体。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571980500,"ip_address":"","comment_id":144591,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571973907","product_id":100037301,"comment_content":"A聚合的applicationService可以load B聚合，使用B聚合的值对象吗","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":472020,"discussion_content":"应用服务是在聚合之上的，它不是单独属于某个聚合的。在应用服务内聚合根可以引用其它聚合的聚合根，读取或者修改其它聚合的实体。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571980500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144487,"user_name":"心浮天空","can_delete":false,"product_type":"c1","uid":1051609,"ip_address":"","ucode":"3B2D0E6CC51EE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/0b/d9/3328dd12.jpg","comment_is_top":false,"comment_ctime":1571938500,"is_pvip":true,"replies":[{"id":"55702","content":"1、聚合根主要协调聚合内的实体和值对象，通过引用的方式是从数据的角度来保证数据的一致性。而领域服务主要是从业务行为，通过实体属性和实体方法来进行业务逻辑的组合和编排，多个实体协作完成复杂的业务逻辑。<br>2、客户信息修改后，是不能影响保单中的客户数据的，这个客户数据是跟单数据，不会随着客户实体数据的变更而变化。举个收货地址的例子，你在维护你个人中心的多个收货地址后，不会修改已经发货的订单上的地址一样的。除非你提出变更收货地址。<br>3、一般来说应用层不应该有自己的实体对象，它引用领域层的对象，不实现复杂的业务逻辑。通过对不同聚合的领域服务组合和编排，实现跨聚合的业务协作。<br>4、在微服务内只有一个应用层。在微服务内尽量避免聚合之间的直接交互。聚合之间的交互都通过应用层。如果设计时将某个聚合放在了不合适的限界上下文内，以后在聚合拆分和合并时，由于聚合之间耦合度低，微服务的演进也就容易的多。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571966752,"ip_address":"","comment_id":144487,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1571938500","product_id":100037301,"comment_content":"本章理解：<br>聚合是将领域中一组协作关系密切的实体和值对象组织在一起并找出聚合根的过程，换句话说，聚合根就是聚合过程的产物。聚合根是这一组实体和值对象的管理入口，由聚合根通过组织实体和值对象的关系来完成实际业务，而聚合根的业务行为可以看作是最小的事务单元，在这个事务单元内，要求数据的强一致性，不同聚合根之间的协作只能通过应用层协作并且不要求强一致性，只要可以做到最终一致性即可。<br>有以下几个疑问:<br>1. 聚合根完成多个实体和值对象之间的协作和在领域服务中完成多个实体之间的协作有什么区别？<br>2. 本人对保单业务不清楚，所以假设一个场景。保单和客户是两个聚合根，假设一个客户可以投保多份保单，客户信息在报单中以值对象的形式存在，值对象的内容有客户名称，联系方式，住址信息。当客户更换联系方式是，保单中的客户信息以什么方式出发更新？此时设涉及到多个聚合根的协作，自己多个聚合根实体的更新操作，这部分功能应该写在具体什么位置？<br>3. 多个聚合根的行为上升到应用层时，是分散开（每个聚合根对应一个应用层对象），还是合在一起(在一个应用层对象用)？我觉得分开实现比较好，因为后期将不同的聚合拆成不同的服务会更容易。<br>4. 聚合根间的协作，应该是直接在领域服务层用引用另一个聚合根对象，还是在应用层引用聚合根对象，或者是在应用层引用另一个应用层？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471968,"discussion_content":"1、聚合根主要协调聚合内的实体和值对象，通过引用的方式是从数据的角度来保证数据的一致性。而领域服务主要是从业务行为，通过实体属性和实体方法来进行业务逻辑的组合和编排，多个实体协作完成复杂的业务逻辑。\n2、客户信息修改后，是不能影响保单中的客户数据的，这个客户数据是跟单数据，不会随着客户实体数据的变更而变化。举个收货地址的例子，你在维护你个人中心的多个收货地址后，不会修改已经发货的订单上的地址一样的。除非你提出变更收货地址。\n3、一般来说应用层不应该有自己的实体对象，它引用领域层的对象，不实现复杂的业务逻辑。通过对不同聚合的领域服务组合和编排，实现跨聚合的业务协作。\n4、在微服务内只有一个应用层。在微服务内尽量避免聚合之间的直接交互。聚合之间的交互都通过应用层。如果设计时将某个聚合放在了不合适的限界上下文内，以后在聚合拆分和合并时，由于聚合之间耦合度低，微服务的演进也就容易的多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571966752,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1142335,"avatar":"https://static001.geekbang.org/account/avatar/00/11/6e/3f/49e5079f.jpg","nickname":"楞伽山人","note":"","ucode":"5859C06DAC790D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543353,"discussion_content":"老师 我觉得心浮天空这里第3点您这边回答的不是很理解 可以再解释一下吗 他说的是一一对应的关系 还是放在一起统一对外 如果后面要做拆分的话 被拆分出去的服务原来是DO的方式在应用层被调用 现在是以DTO的方式被调用呢？ ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1641102290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144387,"user_name":"约书亚","can_delete":false,"product_type":"c1","uid":1046714,"ip_address":"","ucode":"81EA27ADD9EC1A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f8/ba/14e05601.jpg","comment_is_top":false,"comment_ctime":1571908136,"is_pvip":false,"replies":[{"id":"55685","content":"是的，感觉现在JAVA的ORM框架还不是强大。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571926281,"ip_address":"","comment_id":144387,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571908136","product_id":100037301,"comment_content":"这一节解决了我长久的很多困惑，谢谢。比如一致性&#47;不变性这点，在不基于DDD做设计时，一直在思考，在多个实体之上时长会存在一个约束，可这个约束应该放在哪里来保证呢？现在有答案了。<br>问题：是不是要想实现聚合根，在代码实现时就对orm框架的选型有一定要求了，比如怎么也要满足延迟加载，更新追踪这些特性，而一些轻量级的sql框架则不能使用了，因为一般的团队不可能自己实现一套这些复杂的特性吧？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471916,"discussion_content":"是的，感觉现在JAVA的ORM框架还不是强大。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571926281,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144268,"user_name":"江河顺水","can_delete":false,"product_type":"c1","uid":1240807,"ip_address":"","ucode":"8FE80FB71DD63E","user_header":"https://static001.geekbang.org/account/avatar/00/12/ee/e7/450fe9eb.jpg","comment_is_top":false,"comment_ctime":1571884607,"is_pvip":false,"replies":[{"id":"55642","content":"是的。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571887091,"ip_address":"","comment_id":144268,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571884607","product_id":100037301,"comment_content":"个人总结：聚合指的是能让实体和值对象共同协作的组织，作用是确保实体和值对象通过完成业务逻辑时保证数据一致性。聚合根是聚合内的“管理者”，负责业务规则的指定与协同。产生聚合的过程一般是，事件风暴-&gt;领域对象 -&gt;实体、值对象-&gt;聚合根-&gt;聚合。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471868,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571887091,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144266,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1571884491,"is_pvip":false,"replies":[{"id":"55655","content":"聚合还是需要的，在后面的代码目录结构了，我对聚合专门设计了一个目录结构，主要目的是起到功能和代码聚合的作用，以后微服务架构演进就相对方便。<br>至于聚合根，如果聚合内数据规则简单，不会产生数据不一致的情况。如果通过聚合根会影响到使用的便利性，比如性能效率等，我个人觉得也可以不设计聚合根，采用传统的设计方法也是没有关系的。一切以解决问题为基本要求，不要为了DDD而做DDD。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571894385,"ip_address":"","comment_id":144266,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571884491","product_id":100037301,"comment_content":"以下情况是不是不太适合用聚合？<br>1、虽然有相对明确的父子关系，但是子表的数据量很大。在orm框架里面虽然有延迟加载，但是根据聚合根的要求，子表的数据难免都要缓存，这种情况下占用系统内存会很大，对于部分操作来说性能也会比较差。<br>2、虽然有明确的父子关系，但是对子表的操作比较频繁或者某种程度上是脱离父表而比较独立的。比如我之前看到的过一个关于发帖和帖子回复之间的例子，有人说不太适合把帖子和帖子的回复做为聚合。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471866,"discussion_content":"聚合还是需要的，在后面的代码目录结构了，我对聚合专门设计了一个目录结构，主要目的是起到功能和代码聚合的作用，以后微服务架构演进就相对方便。\n至于聚合根，如果聚合内数据规则简单，不会产生数据不一致的情况。如果通过聚合根会影响到使用的便利性，比如性能效率等，我个人觉得也可以不设计聚合根，采用传统的设计方法也是没有关系的。一切以解决问题为基本要求，不要为了DDD而做DDD。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571894385,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":144264,"user_name":"锦鲤","can_delete":false,"product_type":"c1","uid":1343717,"ip_address":"","ucode":"B9F1495E39F00A","user_header":"https://static001.geekbang.org/account/avatar/00/14/80/e5/251d89b5.jpg","comment_is_top":false,"comment_ctime":1571884447,"is_pvip":false,"replies":[{"id":"55643","content":"应用服务主要做服务组合和编排，领域服务实现多个实体的核心业务逻辑。这一块在后面的章节他们是主角，会有详细介绍。请耐心等待。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571887256,"ip_address":"","comment_id":144264,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571884447","product_id":100037301,"comment_content":"老师你好，领域服务和应用服务是怎么定义的？分别有什么区别？从文中看，两者的区别是否是服务粒度的不同？另外，结合微服务的实践，这两种服务在微服务中是怎么设计的？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471865,"discussion_content":"应用服务主要做服务组合和编排，领域服务实现多个实体的核心业务逻辑。这一块在后面的章节他们是主角，会有详细介绍。请耐心等待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571887256,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143950,"user_name":"杨杰","can_delete":false,"product_type":"c1","uid":1131823,"ip_address":"","ucode":"74817EA9499843","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","comment_is_top":false,"comment_ctime":1571812806,"is_pvip":false,"replies":[{"id":"55548","content":"聚合也别太小了，一个实体设计成一个聚合，就没啥意义了。还是要考虑业务内聚性，尽量实现实体的归类。以后微服务的架构演进还要以聚合为单位来演进呢。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571820066,"ip_address":"","comment_id":143950,"utype":1}],"discussion_count":3,"race_medal":0,"score":"1571812806","product_id":100037301,"comment_content":"“”设计小聚合”，我的理解就是对于那些可聚合也可以不聚合的，那么就不要聚合。","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471758,"discussion_content":"聚合也别太小了，一个实体设计成一个聚合，就没啥意义了。还是要考虑业务内聚性，尽量实现实体的归类。以后微服务的架构演进还要以聚合为单位来演进呢。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571820066,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":39052,"discussion_content":"是的，但聚合还是有必要的。但是是否需要通过聚合根来管理聚合内的实体，需要结合场景来分析。如果聚合内部的规则不复杂，聚合内数据能保证一致性，而业务场景中由于各种条件限制，如果不适合通过聚合根来管理，是可以突破这些条条框框的，传统的设计方式能解决当然也是可以用的，咱们不是为了做DDD而做DDD，要能解决实际问题。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1571885644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131823,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/2f/b0b0dd74.jpg","nickname":"杨杰","note":"","ucode":"74817EA9499843","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":38724,"discussion_content":"以下情况是不是不太适合用聚合？\n1、虽然有明确的父子关系，但是子表的数据量很大。在orm框架里面虽然有延迟加载，但是根据聚合根的要求，子表的数据都难免要缓存，这种情况下占用系统内存会很大。\n2、虽然有明确的父子关系，但是对子表的操作比较频繁或者某种程度上是脱离父表而比较独立的。比如我之前看到的过一个关于发帖和帖子回复之间的例子，有人说不太适合把帖子和帖子的回复做为聚合。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571824016,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143946,"user_name":"切糕","can_delete":false,"product_type":"c1","uid":1185409,"ip_address":"","ucode":"DCD3C14CAC4ED3","user_header":"https://static001.geekbang.org/account/avatar/00/12/16/81/77f84354.jpg","comment_is_top":false,"comment_ctime":1571811689,"is_pvip":false,"replies":[{"id":"55550","content":"后面章节中的设计会详细到包名，类名和服务等这些微服务代码目录结构。请耐心等待哈。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571820179,"ip_address":"","comment_id":143946,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571811689","product_id":100037301,"comment_content":"个人总结：实体是项目业务所关注的对象，值对象是用来补充描述实体，这些基本的对象是整个DDD项目的基本元素，如果直接修改实体或值对象，可能会影响项目其他的业务逻辑，所以根据DDD的聚合，通过分割原则，将相应的实体和值按照聚合的方式进行分割成一个个独立的聚合，每一个聚合都依附于聚合根。<br>个人建议：老师讲的很透彻，感谢老师的经验分享。因为我们没有接触过DDD设计的项目，对如何具体操作没有概念，例如包命名、类命名规则，值对象规则等，希望老师能在github建一个DDD的项目，这能帮助我们对DDD概念理解的落地，当然我们会star的😁。<br><br>","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471755,"discussion_content":"后面章节中的设计会详细到包名，类名和服务等这些微服务代码目录结构。请耐心等待哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571820179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":143813,"user_name":"乘风","can_delete":false,"product_type":"c1","uid":1310814,"ip_address":"","ucode":"51C1BCC1701BDA","user_header":"https://static001.geekbang.org/account/avatar/00/14/00/5e/73dd7bf6.jpg","comment_is_top":false,"comment_ctime":1571794769,"is_pvip":false,"replies":[{"id":"55517","content":"应该是电商领域下的三个不同的子域。<br>你可以对这三个子域进行事件风暴，找出实体和聚合，划分限界上下文，建立领域模型，完成微服务设计。","user_name":"作者回复","user_name_real":"渔","uid":"1316268","ctime":1571797675,"ip_address":"","comment_id":143813,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1571794769","product_id":100037301,"comment_content":"一直疑惑，订单，商品，库存该怎么划分？分属三个领域吗？","like_count":0,"discussions":[{"author":{"id":1316268,"avatar":"https://static001.geekbang.org/account/avatar/00/14/15/ac/ba1f2494.jpg","nickname":"欧创新","note":"","ucode":"1F5AF0A327197A","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":471700,"discussion_content":"应该是电商领域下的三个不同的子域。\n你可以对这三个子域进行事件风暴，找出实体和聚合，划分限界上下文，建立领域模型，完成微服务设计。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1571797675,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}