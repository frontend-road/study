{"id":483364,"title":"06 | 事件触发：各类 eBPF 程序的触发机制及其应用场景","content":"<p>你好，我是倪朋飞。</p><p>上一讲，我带你一起梳理了 eBPF 程序跟内核交互的基本方法。一个完整的 eBPF 程序通常包含用户态和内核态两部分：用户态程序通过 BPF 系统调用，完成 eBPF 程序的加载、事件挂载以及映射创建和更新，而内核态中的 eBPF 程序则需要通过 BPF 辅助函数完成所需的任务。</p><p>在上一讲中我也提到，并不是所有的辅助函数都可以在 eBPF 程序中随意使用，不同类型的 eBPF 程序所支持的辅助函数是不同的。那么，eBPF 程序都有哪些类型，而不同类型的 eBPF 程序又有哪些独特的应用场景呢？今天，我就带你一起来看看。</p><h2>eBPF 程序可以分成几类？</h2><p>eBPF 程序类型决定了一个 eBPF 程序可以挂载的事件类型和事件参数，这也就意味着，内核中不同事件会触发不同类型的 eBPF 程序。</p><p>根据内核头文件 <a href=\"https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L908\">include/uapi/linux/bpf.h</a> 中  <code>bpf_prog_type</code> 的定义，Linux 内核 v5.13 已经支持 30 种不同类型的 eBPF 程序（注意，&nbsp;<code>BPF_PROG_TYPE_UNSPEC</code>表示未定义）：</p><pre><code class=\"language-c++\">enum bpf_prog_type {\n\tBPF_PROG_TYPE_UNSPEC, /* Reserve 0 as invalid program type */\n\tBPF_PROG_TYPE_SOCKET_FILTER,\n\tBPF_PROG_TYPE_KPROBE,\n\tBPF_PROG_TYPE_SCHED_CLS,\n\tBPF_PROG_TYPE_SCHED_ACT,\n\tBPF_PROG_TYPE_TRACEPOINT,\n\tBPF_PROG_TYPE_XDP,\n\tBPF_PROG_TYPE_PERF_EVENT,\n\tBPF_PROG_TYPE_CGROUP_SKB,\n\tBPF_PROG_TYPE_CGROUP_SOCK,\n\tBPF_PROG_TYPE_LWT_IN,\n\tBPF_PROG_TYPE_LWT_OUT,\n\tBPF_PROG_TYPE_LWT_XMIT,\n\tBPF_PROG_TYPE_SOCK_OPS,\n\tBPF_PROG_TYPE_SK_SKB,\n\tBPF_PROG_TYPE_CGROUP_DEVICE,\n\tBPF_PROG_TYPE_SK_MSG,\n\tBPF_PROG_TYPE_RAW_TRACEPOINT,\n\tBPF_PROG_TYPE_CGROUP_SOCK_ADDR,\n\tBPF_PROG_TYPE_LWT_SEG6LOCAL,\n\tBPF_PROG_TYPE_LIRC_MODE2,\n\tBPF_PROG_TYPE_SK_REUSEPORT,\n\tBPF_PROG_TYPE_FLOW_DISSECTOR,\n\tBPF_PROG_TYPE_CGROUP_SYSCTL,\n\tBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE,\n\tBPF_PROG_TYPE_CGROUP_SOCKOPT,\n\tBPF_PROG_TYPE_TRACING,\n\tBPF_PROG_TYPE_STRUCT_OPS,\n\tBPF_PROG_TYPE_EXT,\n\tBPF_PROG_TYPE_LSM,\n\tBPF_PROG_TYPE_SK_LOOKUP,\n};\n</code></pre><!-- [[[read_end]]] --><p>对于具体的内核来说，因为不同内核的版本和编译配置选项不同，一个内核并不会支持所有的程序类型。你可以在命令行中执行下面的命令，来查询当前系统支持的程序类型：</p><pre><code class=\"language-plain\">bpftool feature probe | grep program_type\n</code></pre><p>执行后，你会得到如下的输出：</p><pre><code class=\"language-plain\">eBPF program_type socket_filter is available\neBPF program_type kprobe is available\neBPF program_type sched_cls is available\neBPF program_type sched_act is available\neBPF program_type tracepoint is available\neBPF program_type xdp is available\neBPF program_type perf_event is available\n...\neBPF program_type ext is NOT available\neBPF program_type lsm is NOT available\neBPF program_type sk_lookup is available\n</code></pre><p>在这些输出中，你可以看到当前内核支持 kprobe、xdp、perf_event 等程序类型，而不支持 ext、lsm 等程序类型。</p><p>根据具体功能和应用场景的不同，这些程序类型大致可以划分为三类：</p><ul>\n<li>第一类是跟踪，即从内核和程序的运行状态中提取跟踪信息，来了解当前系统正在发生什么。</li>\n<li>第二类是网络，即对网络数据包进行过滤和处理，以便了解和控制网络数据包的收发过程。</li>\n<li>第三类是除跟踪和网络之外的其他类型，包括安全控制、BPF 扩展等等。</li>\n</ul><p>接下来，我就带你一起分别看看，每一类 eBPF 程序都有哪些具体的类型，以及这些不同类型的程序都是由哪些事件触发执行的。</p><h2>跟踪类 eBPF 程序</h2><p>先看第一类，也就是跟踪类 eBPF 程序。</p><p><strong>跟踪类 eBPF 程序主要用于从系统中提取跟踪信息，进而为监控、排错、性能优化等提供数据支撑。</strong>比如，我们前几讲中的 Hello World 示例就是一个 <code>BPF_PROG_TYPE_KPROBE</code> 类型的跟踪程序，它的目的是跟踪内核函数是否被某个进程调用了。</p><p>为了方便你查询，我把常见的跟踪类 BPF 程序的主要功能以及使用限制整理成了一个表格，你可以在需要时参考。</p><p><img src=\"https://static001.geekbang.org/resource/image/04/38/042fe319b51yy6bc153ce0f877f54a38.jpg?wh=1920x1098\" alt=\"图片\"></p><p>这其中，KPROBE、TRACEPOINT 以及 PERF_EVENT 都是最常用的 eBPF 程序类型，大量应用于监控跟踪、性能优化以及调试排错等场景中。我们前几讲中提到的 <a href=\"https://github.com/iovisor/bcc\">BCC</a>工具集，其中包含的绝大部分工具也都属于这个类型。</p><h2>网络类 eBPF 程序</h2><p>看完跟踪类 eBPF 程序，我们再来看看网络类 eBPF 程序。</p><p><strong>网络类 eBPF 程序主要用于对网络数据包进行过滤和处理，进而实现网络的观测、过滤、流量控制以及性能优化等各种丰富的功能。</strong>根据事件触发位置的不同，网络类 eBPF 程序又可以分为 XDP（eXpress Data Path，高速数据路径）程序、TC（Traffic Control，流量控制）程序、套接字程序以及 cgroup 程序，下面我们来分别看看。</p><h3><strong>XDP 程序</strong></h3><p>XDP 程序的类型定义为 <code>BPF_PROG_TYPE_XDP</code>，它在<strong>网络驱动程序刚刚收到数据包时</strong>触发执行。由于无需通过繁杂的内核网络协议栈，XDP 程序可用来实现高性能的网络处理方案，常用于 DDoS 防御、防火墙、4 层负载均衡等场景。</p><p>你需要注意，XDP 程序并不是绕过了内核协议栈，它只是在内核协议栈之前处理数据包，而处理过的数据包还可以正常通过内核协议栈继续处理。你可以通过下面的图片（图片来自 <a href=\"https://www.iovisor.org/technology/xdp\">iovisor.org</a>）加深对&nbsp;XDP 相对内核协议栈位置的理解：</p><p><img src=\"https://static001.geekbang.org/resource/image/3b/31/3b77fea948d6264bfb4b4c266526dd31.png?wh=768x420\" alt=\"图片\" title=\"XDP概览\"></p><p>根据网卡和网卡驱动是否原生支持 XDP 程序，XDP 运行模式可以分为下面这三种：</p><ul>\n<li>通用模式。它不需要网卡和网卡驱动的支持，XDP 程序像常规的网络协议栈一样运行在内核中，性能相对较差，一般用于测试；</li>\n<li>原生模式。它需要网卡驱动程序的支持，XDP 程序在网卡驱动程序的早期路径运行；</li>\n<li>卸载模式。它需要网卡固件支持 XDP 卸载，XDP 程序直接运行在网卡上，而不再需要消耗主机的 CPU 资源，具有最好的性能。</li>\n</ul><p>无论哪种模式，XDP 程序在处理过网络包之后，都需要根据 eBPF 程序执行结果，决定数据包的去处。这些执行结果对应以下 5 种 XDP 程序结果码：</p><p><img src=\"https://static001.geekbang.org/resource/image/a2/a7/a2cayy9f21129590a91ca07604b070a7.jpg?wh=1920x1237\" alt=\"图片\"></p><p>通常来说，XDP 程序通过 <code>ip link</code> 命令加载到具体的网卡上，加载格式为：</p><pre><code class=\"language-bash\"># eth1 为网卡名\n# xdpgeneric 设置运行模式为通用模式\n# xdp-example.o 为编译后的 XDP 字节码\nsudo ip link set dev eth1 xdpgeneric object xdp-example.o\n</code></pre><p>而卸载 XDP 程序也是通过 <code>ip link</code> 命令，具体参数如下：</p><pre><code class=\"language-plain\">sudo ip link set veth1 xdpgeneric off\n</code></pre><p>除了 <code>ip link</code>之外， BCC 也提供了方便的库函数，让我们可以在同一个程序中管理 XDP 程序的生命周期：</p><pre><code class=\"language-python\">from bcc import BPF\n\n# 编译XDP程序\nb = BPF(src_file=\"xdp-example.c\")\nfn = b.load_func(\"xdp-example\", BPF.XDP)\n\n# 加载XDP程序到eth0网卡\ndevice = \"eth0\"\nb.attach_xdp(device, fn, 0)\n\n# 其他处理逻辑\n...\n\n# 卸载XDP程序\nb.remove_xdp(device)\n</code></pre><h3><strong>TC 程序</strong></h3><p>TC 程序的类型定义为 <code>BPF_PROG_TYPE_SCHED_CLS</code> 和 <code>BPF_PROG_TYPE_SCHED_ACT</code>，分别作为 <a href=\"https://tldp.org/HOWTO/Traffic-Control-HOWTO/index.html\">Linux 流量控制</a> 的分类器和执行器。Linux 流量控制通过网卡队列、排队规则、分类器、过滤器以及执行器等，实现了对网络流量的整形调度和带宽控制。</p><p>下图（图片来自 <a href=\"http://linux-ip.net/articles/Traffic-Control-HOWTO/\">linux-ip.net</a>）展示了&nbsp;HTB（Hierarchical Token Bucket，层级令牌桶）流量控制的工作原理：</p><p><img src=\"https://static001.geekbang.org/resource/image/3c/69/3c445830476ed2f32d71e99309b26369.png?wh=1369x1049\" alt=\"图片\" title=\"HTB 流量控制\"></p><p>由于 Linux 流量控制并非本课程的重点，这里我就不过多展开了。如果你对它还不熟悉，可以参考&nbsp;<a href=\"https://tldp.org/HOWTO/Traffic-Control-HOWTO/index.html\">官方文档</a>&nbsp;进行学习。</p><p>得益于内核 v4.4 引入的 <a href=\"https://docs.cilium.io/en/v1.8/bpf/#tc-traffic-control\">direct-action</a> 模式，TC 程序可以直接在一个程序内完成分类和执行的动作，而无需再调用其他的 TC 排队规则和分类器，具体如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/31/d5/31ecf04f2477bd4765be9544a62deed5.jpg?wh=1920x888\" alt=\"图片\" title=\"TC eBPF 程序与网络协议栈的关系\"></p><p>同 XDP 程序相比，TC 程序可以<strong>直接获取内核解析后的网络报文数据结构</strong><code>sk_buff</code>（XDP 则是 <code>xdp_buff</code>），并且可<strong>在网卡的接收和发送两个方向上执行</strong>（XDP 则只能用于接收）。下面我们来具体看看&nbsp;TC 程序的执行位置：</p><ul>\n<li>对于接收的网络包，TC 程序在网卡接收（GRO）之后、协议栈处理（包括 IP 层处理和 iptables 等）之前执行；</li>\n<li>对于发送的网络包，TC 程序在协议栈处理（包括 IP 层处理和 iptables 等）之后、数据包发送到网卡队列（GSO）之前执行。</li>\n</ul><p>除此之外，由于 TC 运行在内核协议栈中，不需要网卡驱动程序做任何改动，因而可以挂载到任意类型的网卡设备（包括容器等使用的虚拟网卡）上。</p><p>同 XDP 程序一样，TC eBPF 程序也可以通过 Linux 命令行工具来加载到网卡上，不过相应的工具要换成 <code>tc</code>。你可以通过下面的命令，分别加载接收和发送方向的 eBPF 程序：</p><pre><code class=\"language-bash\"># 创建 clsact 类型的排队规则\nsudo tc qdisc add dev eth0 clsact\n\n# 加载接收方向的 eBPF 程序\nsudo tc filter add dev eth0 ingress bpf da obj tc-example.o sec ingress\n\n# 加载发送方向的 eBPF 程序\nsudo tc filter add dev eth0 egress bpf da obj tc-example.o sec egress\n</code></pre><h3><strong>套接字程序</strong></h3><p>套接字程序用于过滤、观测或重定向套接字网络包，具体的种类也比较丰富。根据类型的不同，套接字 eBPF 程序可以挂载到套接字（socket）、控制组（cgroup ）以及网络命名空间（netns）等各个位置。你可以根据具体的应用场景，选择一个或组合多个类型的 eBPF 程序，去控制套接字的网络包收发过程。</p><p>这里，我把常见的套接字程序类型，以及它们的应用场景和挂载方法整理成了一个表格，你可以在需要时参考：</p><p><img src=\"https://static001.geekbang.org/resource/image/0e/44/0e57bf041262114198fd29e1e5c04044.jpg?wh=1920x1566\" alt=\"图片\"></p><h3><strong>cgroup 程序</strong></h3><p>cgroup 程序用于<strong>对 cgroup 内所有进程的网络过滤、套接字选项以及转发等进行动态控制</strong>，它最典型的应用场景是对容器中运行的多个进程进行网络控制。</p><p>cgroup 程序的种类比较丰富，我也帮你整理了一个表格，方便你在需要时查询：</p><p><img src=\"https://static001.geekbang.org/resource/image/c3/52/c37b8849096311726e734e8549fd9452.jpg?wh=1920x1216\" alt=\"图片\"></p><p>这些类型的 BPF 程序都可以通过 BPF 系统调用的 <code>BPF_PROG_ATTACH</code> 命令来进行挂载，并设置<a href=\"https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L942\">挂载类型</a>为匹配的 <code>BPF_CGROUP_xxx</code> 类型。比如，在挂载 <code>BPF_PROG_TYPE_CGROUP_DEVICE</code> 类型的 BPF 程序时，需要设置 <code>bpf_attach_type</code> 为 <code>BPF_CGROUP_DEVICE</code>：</p><pre><code class=\"language-c++\">union bpf_attr attr = {};\nattr.target_fd = target_fd;            // cgroup文件描述符\nattr.attach_bpf_fd = prog_fd;          // BPF程序文件描述符\nattr.attach_type = BPF_CGROUP_DEVICE;  // 挂载类型为BPF_CGROUP_DEVICE\n\nif (bpf(BPF_PROG_ATTACH, &amp;attr, sizeof(attr)) &lt; 0) {\n  return -errno;\n}\n\n...\n</code></pre><p>注意，这几类网络 eBPF 程序是在不同的事件触发时执行的，因此，在实际应用中我们通常可以把多个类型的 eBPF 程序结合起来，一起使用，来实现复杂的网络控制功能。比如，最流行的 Kubernetes 网络方案 Cilium 就大量使用了 XDP、TC 和套接字 eBPF 程序，如下图（图片来自 Cilium <a href=\"https://docs.cilium.io/en/v1.11/concepts/ebpf/lifeofapacket/\">官方文档</a>，图中黄色部分即为 Cilium eBPF 程序）所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/45/13/452c809d6e3335fb933a8f991eedf113.png?wh=1454x714\" alt=\"图片\" title=\"Cilium eBPF 数据面\"></p><h2>其他类 eBPF 程序</h2><p>除了上面的跟踪和网络 eBPF 程序之外，Linux 内核还支持很多其他的类型。这些类型的 eBPF 程序虽然不太常用，但在需要的时候也可以帮你解决很多特定的问题。</p><p>我将这些无法划分到网络和跟踪的 eBPF 程序都归为其他类，并帮你整理了一个表格：</p><p><img src=\"https://static001.geekbang.org/resource/image/93/f2/93ae17801e82579e07937e5f1595a0f2.jpg?wh=1920x1332\" alt=\"图片\"></p><p>这个表格列出了一些不太常用的 eBPF 程序类型，你可以先大致浏览下，在需要的时候再去深入了解。</p><h2>小结</h2><p>今天，我带你一起梳理了 eBPF 程序的主要类型，以及不同类型 eBPF 程序的应用场景。</p><p>根据具体功能和应用场景的不同，我们可以把 eBPF 程序分为跟踪、网络和其他三类：</p><ul>\n<li>跟踪类 eBPF 程序主要用于从系统中提取跟踪信息，进而为监控、排错、性能优化等提供数据支撑；</li>\n<li>网络类 eBPF 程序主要用于对网络数据包进行过滤和处理，进而实现网络的观测、过滤、流量控制以及性能优化等；</li>\n<li>其他类则包含了跟踪和网络之外的其他&nbsp;eBPF&nbsp;程序类型，如安全控制、BPF 扩展等。</li>\n</ul><p>虽然每个 eBPF 程序都有特定的类型和触发事件，但这并不意味着它们都是完全独立的。通过 BPF 映射提供的状态共享机制，各种不同类型的 eBPF 程序完全可以相互配合，不仅可以绕过单个 eBPF 程序指令数量的限制，还可以实现更为复杂的控制逻辑。</p><h2>思考题</h2><p>最后，我想邀请你来聊一聊：</p><ol>\n<li>你是怎么理解 eBPF 程序类型的呢？</li>\n<li>如果让你来重新设计类似于 Cilium 的网络方案，你会如何选择 eBPF 程序类型呢？</li>\n</ol><p>期待你在留言区和我讨论，也欢迎把这节课分享给你的同事、朋友。让我们一起在实战中演练，在交流中进步。</p>","neighbors":{"left":{"article_title":"05 | 编程接口：eBPF 程序是怎么跟内核进行交互的？","id":482459},"right":{"article_title":"07 | 内核跟踪（上）：如何查询内核中的跟踪点？","id":484207}},"comments":[{"had_liked":false,"id":332746,"user_name":"YF","can_delete":false,"product_type":"c1","uid":2806937,"ip_address":"","ucode":"ED2534DA57C49A","user_header":"https://static001.geekbang.org/account/avatar/00/2a/d4/99/594e35c2.jpg","comment_is_top":false,"comment_ctime":1643541177,"is_pvip":false,"replies":[{"id":"121662","content":"👍非常棒！","user_name":"作者回复","user_name_real":"编辑","uid":"1001282","ctime":1643812187,"ip_address":"","comment_id":332746,"utype":1}],"discussion_count":1,"race_medal":0,"score":"31708312249","product_id":100104501,"comment_content":"你是怎么理解 eBPF 程序类型的呢？<br><br>eBPF 对应与内核的事件类型，犹如订阅同类消息事件，内核发现对应的事件，则通知订阅者处理。","like_count":7,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549293,"discussion_content":"👍非常棒！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643812187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":333715,"user_name":"阿立","can_delete":false,"product_type":"c1","uid":1345286,"ip_address":"","ucode":"4AE3B0360A2F9C","user_header":"https://static001.geekbang.org/account/avatar/00/14/87/06/bedf7932.jpg","comment_is_top":false,"comment_ctime":1644482560,"is_pvip":false,"replies":[{"id":"122037","content":"都是网络包事件钩子，当然也是网络处理流程中的一部分。XDP和TC其实有些类似，但TC总是在内核中执行，而XDP可以卸载到网卡硬件，从而获得更好的性能。","user_name":"作者回复","user_name_real":"编辑","uid":"1001282","ctime":1644732052,"ip_address":"","comment_id":333715,"utype":1}],"discussion_count":3,"race_medal":0,"score":"23119319040","product_id":100104501,"comment_content":"作者大佬，xdp是一个内核网络处理模块，还是网络包进入协议栈之前的事件钩子点呢？ tc呢？","like_count":5,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":550790,"discussion_content":"都是网络包事件钩子，当然也是网络处理流程中的一部分。XDP和TC其实有些类似，但TC总是在内核中执行，而XDP可以卸载到网卡硬件，从而获得更好的性能。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1644732052,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1340382,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJSOibgpMRJhsdzccmnzD6tvlcuybnytDyLibVnw6DcCRb1srMehLExtrjDIT0TB7j2hyzurtRQNpQA/132","nickname":"人从众","note":"","ucode":"099648810213C3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":553788,"discussion_content":"&#34;卸载到网卡硬件&#34;怎样理解？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646094903,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":550790,"ip_address":""},"score":553788,"extra":""},{"author":{"id":2074244,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/KP50Y6ecpjQw9BtpUKoSYPVemhy2PKECndqSqCTvvFbUrEgn9AbOMwJrialqxiac7j2zlFakzqTguDgHSG7iaAx2Q/132","nickname":"andy6689","note":"","ucode":"C11F2C9071A2B3","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1340382,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJSOibgpMRJhsdzccmnzD6tvlcuybnytDyLibVnw6DcCRb1srMehLExtrjDIT0TB7j2hyzurtRQNpQA/132","nickname":"人从众","note":"","ucode":"099648810213C3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590366,"discussion_content":"就是到网卡上独立执行，不依赖主机cpu","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665708909,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":553788,"ip_address":"广东"},"score":590366,"extra":""}]}]},{"had_liked":false,"id":335517,"user_name":"于競","can_delete":false,"product_type":"c1","uid":1219827,"ip_address":"","ucode":"4A74417B0727A4","user_header":"https://static001.geekbang.org/account/avatar/00/12/9c/f3/e01dfe3a.jpg","comment_is_top":false,"comment_ctime":1645549708,"is_pvip":true,"replies":[{"id":"122625","content":"嗯嗯 可以的。但实际上只是流量复制的话，并不需要eBPF，无论是网络硬件还是OVS、TC等已有的Linux工具早就支持流量复制了。","user_name":"作者回复","user_name_real":"编辑","uid":"1001282","ctime":1645614872,"ip_address":"","comment_id":335517,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14530451596","product_id":100104501,"comment_content":"看了上面介绍的网络类型的eBPF程序，好奇可不可以用来开发流量复制工具呢","like_count":3,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552856,"discussion_content":"嗯嗯 可以的。但实际上只是流量复制的话，并不需要eBPF，无论是网络硬件还是OVS、TC等已有的Linux工具早就支持流量复制了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645614872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":341794,"user_name":"彬","can_delete":false,"product_type":"c1","uid":2323422,"ip_address":"","ucode":"77ED556AC1C01D","user_header":"https://static001.geekbang.org/account/avatar/00/23/73/de/0e1eda4d.jpg","comment_is_top":false,"comment_ctime":1649834734,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5944802030","product_id":100104501,"comment_content":"老师后续会有更全的环境搭建吗？比如升级内核，如果不能直接apt安装bcc等需要采取源码编译等情况，如何在本地环境中编译然后发布到生产环境等情况讲解或者资料","like_count":1},{"had_liked":false,"id":340021,"user_name":"asdf100","can_delete":false,"product_type":"c1","uid":1043738,"ip_address":"","ucode":"39D8D71453E575","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ed/1a/ce7f7d54.jpg","comment_is_top":false,"comment_ctime":1648543432,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5943510728","product_id":100104501,"comment_content":"怎么知道网卡是否支持XDP？","like_count":1,"discussions":[{"author":{"id":1309377,"avatar":"","nickname":"mxmkeep","note":"","ucode":"7068125FE98AB1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587076,"discussion_content":"https://prototype-kernel.readthedocs.io/en/latest/networking/XDP/implementation/drivers.html\n看这里是否能回答你的问题","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662740389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337738,"user_name":"任智杰byte","can_delete":false,"product_type":"c1","uid":1413409,"ip_address":"","ucode":"5591FB2A5D1CE9","user_header":"https://static001.geekbang.org/account/avatar/00/15/91/21/d38d8391.jpg","comment_is_top":false,"comment_ctime":1646998729,"is_pvip":false,"replies":[{"id":"123551","content":"增加新的类型就需要修改内核源码了","user_name":"作者回复","user_name_real":"编辑","uid":"1001282","ctime":1647166024,"ip_address":"","comment_id":337738,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5941966025","product_id":100104501,"comment_content":"如何扩展程序类型呢？","like_count":1,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":556024,"discussion_content":"增加新的类型就需要修改内核源码了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647166024,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":332575,"user_name":"不了峰","can_delete":false,"product_type":"c1","uid":1013424,"ip_address":"","ucode":"E23B96D6A3D4EC","user_header":"https://static001.geekbang.org/account/avatar/00/0f/76/b0/14fec62f.jpg","comment_is_top":false,"comment_ctime":1643352862,"is_pvip":false,"replies":[{"id":"121562","content":"加油！","user_name":"作者回复","user_name_real":"编辑","uid":"1001282","ctime":1643460840,"ip_address":"","comment_id":332575,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5938320158","product_id":100104501,"comment_content":"打卡","like_count":1,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548959,"discussion_content":"加油！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643460840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":360799,"user_name":"tj.•","can_delete":false,"product_type":"c1","uid":1470635,"ip_address":"广东","ucode":"078D80A68491E8","user_header":"https://static001.geekbang.org/account/avatar/00/16/70/ab/7a7399a7.jpg","comment_is_top":false,"comment_ctime":1666859773,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1666859773","product_id":100104501,"comment_content":"老师，使用cilium代替iptables之后，pod访问一个service ip，是在哪个hook做DNAT成endpoint pod ip的？","like_count":0},{"had_liked":false,"id":351313,"user_name":"Lime","can_delete":false,"product_type":"c1","uid":2915194,"ip_address":"","ucode":"0F06DCA27EB787","user_header":"https://static001.geekbang.org/account/avatar/00/2c/7b/7a/70c904e9.jpg","comment_is_top":false,"comment_ctime":1657693299,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657693299","product_id":100104501,"comment_content":"ePBF有没有办法修改内核传进来的参数","like_count":0},{"had_liked":false,"id":344375,"user_name":"一","can_delete":false,"product_type":"c1","uid":2994528,"ip_address":"","ucode":"3279A52DC22C89","user_header":"https://static001.geekbang.org/account/avatar/00/2d/b1/60/23c03681.jpg","comment_is_top":false,"comment_ctime":1651499565,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1651499565","product_id":100104501,"comment_content":"老师，我想问一下，比如我想在系统弹窗时插装，怎么找到系统弹窗这个hook点呢，比如SEC（“uprobe&#47;这个地方应该填什么呢，或者说在哪里有这个uprobe下面hook点的列表呢”）","like_count":0,"discussions":[{"author":{"id":1183408,"avatar":"https://static001.geekbang.org/account/avatar/00/12/0e/b0/ebf0afc3.jpg","nickname":"小术","note":"","ucode":"D73BB46F2BA736","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577242,"discussion_content":"bpftrace -l &#34;uprobe:&lt;library_path&gt;*&#34; 可以列出某个动态库的 uprobe hook 点，但具体这个逻辑在哪个可执行文件/动态库里面，需要自己分析。就好比做手术，智能手术刀可以告诉你哪些地方可以动刀，但具体到哪个病需要在哪个位置动，需要医生自己判断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655982337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338758,"user_name":"火火寻","can_delete":false,"product_type":"c1","uid":1120541,"ip_address":"","ucode":"B6DC003A5D89AF","user_header":"https://static001.geekbang.org/account/avatar/00/11/19/1d/d2b6e006.jpg","comment_is_top":false,"comment_ctime":1647702318,"is_pvip":false,"replies":[{"id":"123961","content":"这个可能直接用dubbo会比ebpf要更简单。ebpf虽然也可以用，但毕竟运行在内核中，实现复杂度会高一些","user_name":"作者回复","user_name_real":"编辑","uid":"1001282","ctime":1647959204,"ip_address":"","comment_id":338758,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1647702318","product_id":100104501,"comment_content":"老师，问下，如果想要做业务层的流量控制，比如dubbo请求部分黑名单不让进来，使用哪种合适？<br>","like_count":0,"discussions":[{"author":{"id":1001282,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/42/5b55bd1a.jpg","nickname":"倪朋飞","note":"","ucode":"F0FAC195CDE7AC","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557780,"discussion_content":"这个可能直接用dubbo会比ebpf要更简单。ebpf虽然也可以用，但毕竟运行在内核中，实现复杂度会高一些","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647959204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}