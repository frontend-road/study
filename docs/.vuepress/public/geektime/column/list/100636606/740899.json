{"id":740899,"title":"附录 C 通过 Spring Native 打包本地镜像","content":"\n<p>在云原生应用越来越广泛的今天，大家对服务提出了很多新的要求。以前的服务只要跑起来，就长时间运行，启动慢一点、占用资源多一点都不是问题。在弹性伸缩，按量计费的云平台下，平时保持最小实例数，甚至 0 实例，请求到来后快速拉起一个新的服务实例，这就要求系统要能快速启动，必须是毫秒级；如果按 CPU 与内存的用量来计费，那服务占用的内存就要尽可能少，要在尽可能短的时间内达到性能峰值……</p>\n<p>面对这些新挑战，Quarkus 和 Micronaut 这样的后起之秀 <span class=\"comment-number\">1</span> 都能轻装上阵，直接面向云原生应用提供支持，而运行在传统 JVM 上的 Spring 系统多少有些力不从心，好在 Spring 家族也给出了自己的解决方案——Spring Native。</p>\n\n<h2 id=\"nav_point_268\">C.1　GraalVM 与 Spring Native</h2>\n<p>在开始介绍 Spring Native 之前，先让我们来了解一下 GraalVM，无论 Spring Native，还是 Quarkus，都需要依托于 GraalVM 来实现一些特定的功能。</p>\n<h3 id=\"nav_point_269\">C.1.1　GraalVM 简介</h3>\n<p>GraalVM 是 Oracle 开发的一款高性能 JDK 发行版 <span class=\"comment-number\">2</span>，官网上罗列了它的几个重要特性。</p><!-- [[[read_end]]] -->\n\n<ul>\n<li>高性能，GraalVM 提供了经过优化的 Graal 编译器，这是一款 JIT（Just in Time）编译器，可以生成更快、更精简、占用资源更少的代码。</li>\n<li>AOT（Ahead of Time）本地镜像编译，事先把 Java 应用编译为本地镜像，做到启动迅速，无须预热就能达到性能峰值。</li>\n<li>多语言支持，能够轻松地支持多种语言，不仅能为 Java 应用提速，还支持基于 JVM 的其他语言，例如 Ruby 和 Python<span class=\"comment-number\">3</span>。</li>\n<li>高级工具，提供了包含调试、监控、编译等多种工具。</li>\n</ul>\n\n<p>GraalVM 本地镜像是个利器，虽然好处很多，但受限于其静态特性，也带来了一些不变与局限，例如：</p>\n<ul>\n<li>无法进行动态类加载，需要在编译期间提供大量的类信息（例如 <code>Class.forName()</code> 和 <code>ServiceLoader.load()</code> 中的类），而且这些类都需要进行额外配置才能编译到镜像里；</li>\n<li>运行过程中的反射内容，需要在编译时用配置明确下来；</li>\n<li>动态代理的类信息，有一部分可以自动推断，但仍有不少情况需要事先在编译时进行配置；</li>\n<li><code>invokedynamic</code> 的使用会受到限制，类似 Lambda 表达式这样的内容仍能继续使用，但在运行时会引入不确定性的功能则无法支持。</li>\n</ul>\n<p>上面还只是罗列了一部分问题，在下文中，我们会用 GraalVM 来生成一个静态的本地镜像，届时大家就会看到我们在有了 Spring Native 的帮助后，仍然需要进行不少编译时配置和代码调整才能顺利让程序运行起来。总之，一切的好处都是有代价的。</p>\n<h3 id=\"nav_point_270\">C.1.2　Spring Native 简介</h3>\n<p>Spring Framework 中大量使用了动态代理技术，尤其是 AOP 增强的部分，都是由 JDK 动态代理或者 CGLIB 代码增强来实现的。而在工程中用到的各种类库也同样存在有悖“静态”原则的地方，没有底层框架的加持，完全依靠人来进行编译期的配置将是一个巨大的工程。特别是 Spring 发展了这么多年，有着复杂的生态，生态内的成员之间彼此交错，虽然 Spring Framework 从 5.3 版本开始对 GraalVM 提供了较为完整的支持，但要让一个 Spring 工程“静态化”还是很困难。</p>\n<p>出于上述原因，Spring Native<span class=\"comment-number\">4</span> 项目诞生了，它的目的就是为那些想通过 GraalVM 将 Spring 应用编译为本地镜像的项目提供支持。它由多个模块构成，主要包括：</p>\n\n<ul>\n<li>spring-native 与 spring-native-configuration，Spring Native 的相关依赖与配置；</li>\n<li>spring-aot、spring-aot-test、spring-aot-maven-plugin 与 spring-aot-gradle-plugin，AOT 生成相关的基础设施与插件；</li>\n<li>spring-native-tools，一些编译过程中会用到的工具组合。</li>\n</ul>\n<p>Spring Native 为大家处理了很多繁琐的工作，而这些内容会随着实际使用的框架版本和 GraalVM 版本发生变化，因此 Spring Native 的版本会与 Spring Boot（与其底层的 Spring Framework）和 GraalVM 版本强相关，以本附录中将用到的 0.11.5 为例，它与其他框架及相关内容的对应及版本关系如表 C-1 所示。</p>\n<p><strong>表 C-1　Spring Native 与其他框架及相关内容的对应及版本关系</strong></p>\n<table width=\"90%\" border=\"1\">\n<thead>\n<tr>\n<th><p>内容</p></th>\n<th><p>版本</p></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><p>Spring Native</p></td>\n<td><p>0.11.5</p></td>\n</tr>\n<tr>\n<td><p>Java</p></td>\n<td><p>11 与 17</p></td>\n</tr>\n<tr>\n<td><p>GraalVM</p></td>\n<td><p>22.0.0</p></td>\n</tr>\n<tr>\n<td><p>Spring Boot</p></td>\n<td><p>2.6.7</p></td>\n</tr>\n<tr>\n<td><p>Spring Cloud<span class=\"comment-number\">5</span></p></td>\n<td><p>2021.0.1</p></td>\n</tr>\n</tbody>\n</table>\n\n<p>在 Spring Native 的帮助下，原先遥不可及的目标，变得跳一跳就能得到了。接下来，让我们继续用第 10 章的 binarytea-jwt-auth 作为例子 <span class=\"comment-number\">6</span>，演示一下如何将一个相对复杂的 Spring 工程编译为本地镜像。<span class=\"comment-number\">7</span></p>\n\n\n<blockquote>\n<p><strong>请注意</strong>　这里要再次强调一下，虽然有 Spring Native，但这并不代表将一个已有的 Spring 项目编译为本地镜像就很容易。这个过程中不仅需要调整依赖组件的版本，还有可能要调整代码，有时还不得不放弃一些功能。如果一个工程跑得好好的，没有非用 GraalVM 本地镜像不可的理由，那还是让它维持现状吧。</p>\n</blockquote>\n<h2 id=\"nav_point_271\">C.2　编译打包本地镜像</h2>\n<p>要将一个 Spring 项目编译打包为 GraalVM 本地镜像，整体上分为三个步骤：</p>\n<p>(1) 前期的环境准备，主要是安装 GraalVM 相关的内容；</p>\n<p>(2) 调整 Maven 或者 Gradle 编译打包的配置；</p>\n<p>(3) 根据打包产物执行的情况调整代码 <span class=\"comment-number\">8</span>。</p>\n\n<p>下面我们会详细拆解这三个步骤，仔细看看每步都要做些什么事情。</p>\n<h3 id=\"nav_point_272\">C.2.1　准备工作</h3>\n<p>这里的准备主要是指准备编译打包的环境，也就是安装符合版本要求的 GraalVM。在 macOS 下可以使用 SDKMAN，Windows 环境则从官网下载安装包即可。下面是 SDKMAN 的安装命令，先用 <code>sdk list java</code> 找到合适的 GraalVM 版本，例如这里就是 22.0.0.2.r11-grl<span class=\"comment-number\">9</span>，然后执行如下命令安装：</p>\n\n<pre class=\"code-rows\"><code>▸ sdk install java 22.0.0.2.r11-grl</code></pre>\n<p>随后将 Java 切换到刚才安装的 GraalVM，或者直接将它作为默认的 Java 环境，然后用 <code>gu</code> 命令安装 native-image 工具。具体命令如下：</p>\n<pre class=\"code-rows\"><code>▸ sdk use java 22.0.0.2.r11-grl\n\nUsing java version 22.0.0.2.r11-grl in this shell.\n\n▸ gu install native-image\nDownloading: Release index file from oca.opensource.oracle.com\nDownloading: Component catalog for GraalVM Enterprise Edition 22.0.0 on jdk11 from oca.opensource.oracle.com\nDownloading: Component catalog for GraalVM Enterprise Edition 22.0.0.1 on jdk11 from oca.opensource.oracle.com\nDownloading: Component catalog from www.graalvm.org\nProcessing Component: Native Image\nDownloading: Component native-image: Native Image from github.com\nInstalling new component: Native Image (org.graalvm.native-image, version 22.0.0.2)</code></pre>\n<h3 id=\"nav_point_273\">C.2.2　调整编译打包配置</h3>\n<p>现在来调整 Maven 配置。前面介绍过，我们这里使用 Spring Native 0.11.5 需要搭配 Spring Boot 2.6.7，因此需要更换 <code>&lt;parent/&gt;</code> 里 spring-boot-starter-parent 的版本，将它调整为 2.6.7，并在依赖中增加 Spring Native 的依赖，具体如代码示例 C-1 所示。Spring Boot 2.6.7 里 Jackson JSON 的版本升级到了 2.13.2，所以还需要同步调整 jackson-datatype-joda-money 和 jackson-datatype-hibernate5 的版本，此处就不再赘述了。</p>\n<blockquote>\n<p><strong>代码示例 C-1</strong>　调整 Spring Boot 版本并增加 Spring Native 依赖</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.6.7&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.experimental&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-native&lt;/artifactId&gt;\n            &lt;version&gt;0.11.5&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 省略其他内容 --&gt;\n    &lt;/dependencies&gt;\n    &lt;!-- 省略其他内容 --&gt;\n&lt;/project&gt;</code></pre>\n<p>在 Maven 构建的插件部分，需要增加两个插件，具体如代码示例 C-2 所示。</p>\n<ul>\n<li>spring-aot-maven-plugin，增加 AOT 相关能力的支持。</li>\n<li>hibernate-enhance-maven-plugin，在工程中使用了 Hibernate，它会引入一些字节码增强，通过这个插件可以实现构建时的字节码增强，而非运行时。</li>\n</ul>\n<blockquote>\n<p><strong>代码示例 C-2</strong>　增加两个构建项目的插件</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.springframework.experimental&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-aot-maven-plugin&lt;/artifactId&gt;\n            &lt;version&gt;0.11.5&lt;/version&gt;\n            &lt;executions&gt;\n                &lt;execution&gt;\n                    &lt;id&gt;generate&lt;/id&gt;\n                    &lt;goals&gt;\n                        &lt;goal&gt;generate&lt;/goal&gt;\n                    &lt;/goals&gt;\n                &lt;/execution&gt;\n            &lt;/executions&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.hibernate.orm.tooling&lt;/groupId&gt;\n            &lt;artifactId&gt;hibernate-enhance-maven-plugin&lt;/artifactId&gt;\n            &lt;version&gt;$&lt;/version&gt;\n            &lt;executions&gt;\n                &lt;execution&gt;\n                    &lt;configuration&gt;\n                        &lt;failOnError&gt;true&lt;/failOnError&gt;\n                        &lt;enableLazyInitialization&gt;true&lt;/enableLazyInitialization&gt;\n                        &lt;enableDirtyTracking&gt;true&lt;/enableDirtyTracking&gt;\n                        &lt;enableAssociationManagement&gt;true&lt;/enableAssociationManagement&gt;\n                        &lt;enableExtendedEnhancement&gt;false&lt;/enableExtendedEnhancement&gt;\n                    &lt;/configuration&gt;\n                    &lt;goals&gt;\n                        &lt;goal&gt;enhance&lt;/goal&gt;\n                    &lt;/goals&gt;\n                &lt;/execution&gt;\n            &lt;/executions&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;</code></pre>\n<p>这里用到的一些 Spring 依赖和插件可能还未发布到公共 Maven 仓库，所以我们还需要额外添加 Spring 的仓库，可以增加代码示例 C-3 中的配置。</p>\n<blockquote>\n<p><strong>代码示例 C-3</strong>　额外增加 Spring 的 Maven 仓库</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;repositories&gt;\n    &lt;repository&gt;\n        &lt;id&gt;spring-release&lt;/id&gt;\n        &lt;name&gt;Spring release&lt;/name&gt;\n        &lt;url&gt;https://repo.spring.io/release&lt;/url&gt;\n    &lt;/repository&gt;\n&lt;/repositories&gt;\n&lt;pluginRepositories&gt;\n    &lt;pluginRepository&gt;\n        &lt;id&gt;spring-release&lt;/id&gt;\n        &lt;name&gt;Spring release&lt;/name&gt;\n        &lt;url&gt;https://repo.spring.io/release&lt;/url&gt;\n    &lt;/pluginRepository&gt;\n&lt;/pluginRepositories&gt;</code></pre>\n<p>最后一步，增加 GraalVM 构建本地镜像的构建动作。spring-boot-maven-plugin 本身在构建过程中会创建 Fat Jar，为了加以区分，我们增加一个 <code>native</code>Profile，把 native-maven-plugin 配置在这个 Profile 里。同时，为 spring-boot-maven-plugin 配置 <code>classifier</code>，它的值为 <code>exec</code>。具体如代码示例 C-4 所示。</p>\n<blockquote>\n<p><strong>代码示例 C-4</strong>　增加编译本地镜像的 Maven Profile</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;profiles&gt;\n    &lt;profile&gt;\n        &lt;id&gt;native&lt;/id&gt;\n        &lt;build&gt;\n            &lt;plugins&gt;\n                &lt;plugin&gt;\n                    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;\n                    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;\n                    &lt;version&gt;0.9.11&lt;/version&gt;\n                    &lt;extensions&gt;true&lt;/extensions&gt;\n                    &lt;executions&gt;\n                        &lt;execution&gt;\n                            &lt;id&gt;build-native&lt;/id&gt;\n                            &lt;goals&gt;\n                                &lt;goal&gt;build&lt;/goal&gt;\n                            &lt;/goals&gt;\n                            &lt;phase&gt;package&lt;/phase&gt;\n                        &lt;/execution&gt;\n                        &lt;execution&gt;\n                            &lt;id&gt;test-native&lt;/id&gt;\n                            &lt;goals&gt;\n                                &lt;goal&gt;test&lt;/goal&gt;\n                            &lt;/goals&gt;\n                            &lt;phase&gt;test&lt;/phase&gt;\n                        &lt;/execution&gt;\n                    &lt;/executions&gt;\n                &lt;/plugin&gt;\n                &lt;!-- Avoid a clash between Spring Boot repackaging and native-maven-plugin --&gt;\n                &lt;plugin&gt;\n                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n                    &lt;configuration&gt;\n                        &lt;classifier&gt;exec&lt;/classifier&gt;\n                    &lt;/configuration&gt;\n                &lt;/plugin&gt;\n            &lt;/plugins&gt;\n        &lt;/build&gt;\n        &lt;pluginRepositories&gt;\n        &lt;!-- 此处省略，内容同前文Spring的pluginRepositories --&gt;\n        &lt;/pluginRepositories&gt;\n    &lt;/profile&gt;\n&lt;/profiles&gt;</code></pre>\n<p>完成上述 pom.xml 调整后，就能执行下面的 Maven 命令进行构建了，其中的 <code>-P</code> 参数指定了具体使用的 Profile，这里跳过了测试。</p>\n<pre class=\"code-rows\"><code>▸ mvn -Pnative -DskipTests clean package</code></pre>\n<p>执行过程中，可以观察到如下输出（分为 7 个步骤，内容为部分截取）：</p>\n<pre class=\"code-rows\"><code>GraalVM Native Image: Generating 'binarytea' (executable)...\n\n[1/7] Initializing...                                                                     (9.9s @ 0.40GB)\n[2/7] Performing analysis... [************]                                              (99.6s @ 6.96GB)\n  27,820 (94.62%) of 29,401 classes reachable\n  47,951 (74.49%) of 64,373 fields reachable\n 145,804 (67.90%) of 214,724 methods reachable\n\n\n   1,572 classes,   975 fields, and 8,529 methods registered for reflection\n      69 classes,    91 fields, and    55 methods registered for JNI access\n[3/7] Building universe...                                                                (9.8s @ 5.70GB)\n[4/7] Parsing methods...      [****]                                                     (14.6s @ 3.51GB)\n[5/7] Inlining methods...     [*****]                                                    (16.2s @ 4.36GB)\n[6/7] Compiling methods...    [********]                                                 (61.5s @ 6.08GB)\n[7/7] Creating image...                                                                  (13.1s @ 6.19GB)\n  59.22MB (45.37%) for code area:   95,488 compilation units\n  60.22MB (46.13%) for image heap:  19,281 classes and 623,707 objects\n  11.09MB ( 8.50%) for other data\n 130.53MB in total\n\nFinished generating 'binarytea' in 3m 56s.</code></pre>\n<p>相比传统的 Fat Jar，本地镜像的构建可谓相当耗时，以此处使用的 BinaryTea 工程为例，在 M1 芯片 16G 内存的 MacBook Pro 上需要大概 4 分钟。<span class=\"comment-number\">10</span> 构建后的产物名为 binarytea，大小在 120MB 左右，是个可执行文件。虽然构建能够成功，但构建的产物并不能正确运行，还需要根据错误提示信息进一步修改。</p>\n\n<h3 id=\"nav_point_274\">C.2.3　修改代码</h3>\n<p>不出所料，BinaryTea 工程无法在不变动代码的情况下编译为正确的本地镜像，遇到的问题总结如下。</p>\n<ul>\n<li>依赖的类库中存在动态加载类的情况，而且数量不少，Jadira UserType、JWT 和 Joda Money 都有。</li>\n<li>Spring Security 中有代码使用了反射机制获取属性。</li>\n<li>Java 配置类中的 <code>@Bean</code> 方法本来使用了 CGLIB 字节码增强，现在等于变成了 <code>@Configuration(proxyBeanMethods=false)</code>，配置需要调整。<span class=\"comment-number\">11</span></li>\n<li>有些注解需要动态代理增强，但构建时并未正确识别，需要提供一些配置。</li>\n</ul>\n\n<p>针对这些问题，让我们看看怎样逐一解决。</p>\n<ol>\n<li><p><strong>解决类加载和反射问题</strong></p>\n<p>Jadira UserType 里使用了 <code>ServiceLoader.load()</code> 来加载类的情况，数量多到已经不想用 <code>@TypeHint</code> 来配置的地步了。考虑到我们其实只用了处理 <code>Money</code> 类的 <code>PersistentMoneyMinorAmount</code>，可以去掉 <code>usertype.core</code> 这个依赖，自己编写一个简单的 <code>UserType</code> 类就行了，如代码示例 C-5 所示。</p>\n<blockquote>\n<p><strong>代码示例 C-5</strong>　处理 <code>Money</code> 类型转换的 Hibernate <code>UserType</code> 类代码片段</p>\n</blockquote>\n<pre class=\"code-rows\"><code>public class MoneyType implements UserType {\n    @Override\n    public int[] sqlTypes() {\n        return new int[] { Types.BIGINT };\n    }\n\n    @Override\n    public Class returnedClass() {\n        return Money.class;\n    }\n\n    @Override\n    public Object nullSafeGet(ResultSet rs, String[] names,\n        SharedSessionContractImplementor session, Object owner) throws HibernateException, SQLException {\n        Long val = rs.getLong(names[0]);\n        return Money.ofMinor(CurrencyUnit.of(\"CNY\"), val);\n    }\n\n    @Override\n    public void nullSafeSet(PreparedStatement st, Object value, int index, SharedSessionContractImplementor-\nsession) throws HibernateException, SQLException {\n        if (null == value) {\n            st.setNull(index, Types.BIGINT);\n        } else {\n            st.setLong(index, ((Money) value).getAmountMinorLong());\n        }\n    }\n    // 省略其他代码\n}</code></pre>\n<p>随后，把原本配置了 <code>PersistentMoneyMinorAmount</code> 的地方调整为 <code>MoneyType</code>。以 <code>Amount</code> 类为例，可以改为代码示例 C-6 那样，<code>MenuItem</code> 类的调整也是类似的。</p>\n<blockquote>\n<p><strong>代码示例 C-6</strong>　使用 <code>MoneyType</code> 代替 <code>PersistentMoneyMinorAmount</code></p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Builder\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Embeddable\npublic class Amount {\n    @Column(name = \"amount_discount\")\n    private int discount;\n\n    @Column(name = \"amount_total\")\n    @Type(type = \"learning.spring.binarytea.support.MoneyType\")\n    private Money totalAmount;\n\n    @Column(name = \"amount_pay\")\n    @Type(type = \"learning.spring.binarytea.support.MoneyType\")\n    private Money payAmount;\n}</code></pre>\n<p>JodaMoney 通过 <code>Class.forName()</code> 加载了 <code>DefaultCurrencyUnitDataProvider</code> 类，还读取了 CurrencyData.csv 和 CountryData.csv 两个资源文件，可以用 <code>@TypeHint</code> 和 <code>@ResourceHint</code> 在 Java 配置类中添加提示，告诉 GraalVM 的插件把这些内容打包进镜像。JWT 也有类似的问题，有 5 个类是用 <code>Class.forName()</code> 加载的，在 pom.xml 中我们把 jjwt-impl 和 jjwt-jackson 声明为运行时才需要的，现在编译时就需要了，因此需要去掉 <code>&lt;scope&gt;runtime&lt;/scope&gt;</code> 的配置。Spring Security 会通过反射读取 <code>AuthenticationManagerBuilder</code> 中的属性，也许要进行声明，<code>@TypeHint</code> 里的 <code>access</code> 可以指定访问类型，<code>TypeAccess.DECLARED_FIELDS</code> 就是允许访问所有声明了的属性。我们把上述所有提示信息集中到一个配置类里，具体如代码示例 C-7 所示。</p>\n<blockquote>\n<p><strong>代码示例 C-7</strong>　用于配置 Spring Native 注解的 <code>HintConfig</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@TypeHints({\n    @TypeHint(types = MoneyType.class),\n    // JWT\n    @TypeHint(types = DefaultJwtParserBuilder.class),\n    @TypeHint(types = DefaultJwtBuilder.class),\n    @TypeHint(types = DefaultClaims.class),\n    @TypeHint(types = DefaultHeader.class),\n    @TypeHint(types = DefaultJwsHeader.class),\n    // Joda Money\n    @TypeHint(typeNames = \"org.joda.money.DefaultCurrencyUnitDataProvider\"),\n    // Spring\n    @TypeHint(types = AuthenticationManagerBuilder.class, access = TypeAccess.DECLARED_FIELDS)\n})\n@ResourcesHints({\n    @ResourceHint(patterns = \"org/joda/money/CurrencyData.csv\"),\n    @ResourceHint(patterns = \"org/joda/money/CountryData.csv\"),\n})\npublic class HintConfig {\n}</code></pre>\n<p>运行过程中，我们还会发现 <code>MenuService</code> 类的 <code>getByNameAndSize()</code> 在 <code>@Cacheable</code> 注解里配置了 SpEL 表达式，其中的 <code>#root.methodName</code> 无法正常解析，这里我们就把这个方法的 <code>@Cacheable</code> 缓存去掉。如果在项目里没有用 SpEL 表达式，可以告诉 spring-aot-maven-plugin，去掉相应的 SpEL 支持。类似地，还有一些其他配置，如表 C-2 所示。</p>\n<p><strong>表 C-2　spring-aot-maven-plugin 的一些配置</strong></p>\n<table class=\"table table-bordered table-striped table-condensed\" width=\"90%\" border=\"1\"><tr><th>配置项</th><th>默认值</th><th>说明</th></tr><tr><td><code>removeXmlSupport</code></td><td><code>true</code></td><td>去除工程中的 XML 支持</td></tr><tr><td><code>removeSpelSupport</code></td><td><code>false</code></td><td>去除工程中的 SpEL 支持</td></tr><tr><td><code>removeYamlSupport</code></td><td><code>false</code></td><td>去除工程中的 YAML 支持</td></tr><tr><td><code>removeJmxSupport</code></td><td><code>true</code></td><td>去除工程中的 JMX 支持</td></tr><tr><td><code>verify</code></td><td><code>true</code></td><td>是否执行自动验证，确保应用能兼容本地镜像</td></tr></table>\n\n<p>在具体使用时，可以在 <code>&lt;plugin/&gt;</code> 中增加下面的配置：</p>\n<pre class=\"code-rows\"><code>&lt;configuration&gt;\n    &lt;removeSpelSupport&gt;true&lt;/removeSpelSupport&gt;\n&lt;/configuration&gt;</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>调整 Java 配置类</strong></p>\n<p>在 BinaryTea 中需要调整的 Java 配置类主要是 Spring Security 相关的 <code>WebSecurityConfiguration</code>。原先其中的很多 Bean 引用都是通过方法调用实现的，在 CGLIB 的帮助下，多次调用方法实际只会执行一次，但现在调用一次就执行一次，尤其是 <code>userDetailsService()</code> 还会往数据库里插入记录，第二次执行就会违反唯一性约束。为此，我们可以尽可能将 Bean 配置从 <code>WebSecurityConfiguration</code> 中移出去，用 <code>@Autowired</code> 将 Spring 上下文里的 Bean 注入进来。同时，在定义 Bean 的时候把依赖变为传参，可以将 <code>WebSecurityConfiguration</code> 里的 <code>loginController</code>、<code>jwtPreAuthenticatedAuthenticationProvider</code>、<code>persistentTokenRepository</code> 和 <code>userDetailsService</code> Bean 定义移到 <code>BinaryTeaApplication</code> 里，具体如代码示例 C-8 所示。</p>\n<blockquote>\n<p><strong>代码示例 C-8</strong>　增加了 Bean 定义的 <code>BinaryTeaApplication</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@SpringBootApplication\n@EnableCaching\npublic class BinaryTeaApplication {\n    // 省略原先已存在的方法\n\n    @Bean(\"/login\")\n    public UrlFilenameViewController loginController() {\n        UrlFilenameViewController controller = new UrlFilenameViewController();\n        controller.setSupportedMethods(HttpMethod.GET.name());\n        controller.setSuffix(\".html\");\n        return controller;\n    }\n\n    @Bean\n    public PreAuthenticatedAuthenticationProvider jwtPreAuthenticatedAuthenticationProvider(ObjectProvider\n&lt;DataSource&gt; dataSources,\n                     UserDetailsService userDetailsService) {\n        PreAuthenticatedAuthenticationProvider provider = new PreAuthenticatedAuthenticationProvider();\n        provider.setPreAuthenticatedUserDetailsService(\n            new UserDetailsByNameServiceWrapper&lt;&gt;(userDetailsService));\n        return provider;\n    }\n\n    @Bean\n    public PersistentTokenRepository persistentTokenRepository(ObjectProvider&lt;DataSource&gt; dataSources) {\n        JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();\n        tokenRepository.setDataSource(dataSources.getIfAvailable());\n        tokenRepository.setCreateTableOnStartup(false);\n        return tokenRepository;\n    }\n\n    @Bean\n    public UserDetailsService userDetailsService(ObjectProvider&lt;DataSource&gt; dataSources) {\n        RoleBasedJdbcUserDetailsManager userDetailsManager = new RoleBasedJdbcUserDetailsManager();\n        userDetailsManager.setDataSource(dataSources.getIfAvailable());\n        UserDetails manager = User.builder()\n            .username(\"HanMeimei\")\n            .password(\"$2a$10$iAty2GrJu9WfpksIen6qX.vczLmXlp.1q1OHBxWEX8BIldtwxHl3u\")\n            .roles(\"MANAGER\")\n            .build();\n        userDetailsManager.createUser(manager);\n        return userDetailsManager;\n    }\n}</code></pre>\n<p><code>WebSecurityConfiguration</code> 里也要做对应的调整。用 <code>@Autowired</code> 注入其他地方声明的 Bean，<code>authenticationManagerBean()</code> 内部调用了父类的方法，所以不能移出去。<code>jwtAuthenticationFilter()</code> 又依赖了 <code>authenticationManagerBean()</code>，所以也要保留。<code>jwtAuthenticationFilter()</code> 在 <code>configure (HttpSecurity http)</code> 里又被调用了一次，那次等于不是依赖 Bean 的，因此里面的 <code>@Autowired</code> 注解没有生效。为了避免执行中缺少 <code>JwtTokenHelper</code>，抛出 <code>NullPointerException</code>，为 <code>JwtAuthenticationFilter</code> 增加 <code>setJwtTokenHelper()</code> 方法，手动将 <code>jwtTokenHelper</code> 注入进去。具体如代码示例 C-9 所示。</p>\n<blockquote>\n<p><strong>代码示例 C-9</strong>　调整后的 <code>WebSecurityConfiguration</code> 类</p>\n</blockquote>\n<pre class=\"code-rows\"><code>@Configuration\n@EnableWebSecurity\n@EnableGlobalMethodSecurity(securedEnabled = true,\n                            prePostEnabled = true,\n                            jsr250Enabled = true)\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    @Autowired\n    private UserDetailsService userDetailsService;\n    @Autowired\n    private PersistentTokenRepository persistentTokenRepository;\n    @Autowired\n    private PreAuthenticatedAuthenticationProvider jwtPreAuthenticatedAuthenticationProvider;\n    @Autowired\n    private JwtTokenHelper jwtTokenHelper;\n\n    @Bean\n    public JwtAuthenticationFilter jwtAuthenticationFilter() throws Exception {\n        JwtAuthenticationFilter filter = new JwtAuthenticationFilter();\n        filter.setJwtTokenHelper(jwtTokenHelper); // 手动注入依赖\n        filter.setAuthenticationManager(authenticationManagerBean());\n        return filter;\n    }\n\n    @Override\n    protected void configure(AuthenticationManagerBuilder auth) throws Exception {\n        auth.authenticationProvider(jwtPreAuthenticatedAuthenticationProvider).userDetailsService\n(userDetailsService);\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        // 这部分代码可以参考示例文件，此处省略\n    }\n    // 省略其他代码\n}</code></pre>\n<p>&nbsp;</p>\n</li>\n<li><p><strong>配置动态代理类型</strong></p>\n<p>在 BinaryTea 工程运行过程中，我们在日志中看到了不少类似下面这样的信息：</p>\n<pre class=\"code-rows\"><code>INFO 9628 --- [main] o.s.core.annotation.MergedAnnotation : Failed to introspect annotations on public\njava.util.Optional learning.spring.binarytea.controller.MenuController.createByForm(learning.spring.\nbinarytea.controller.request.NewMenuItemForm,org.springframework.validation.BindingResult,javax.servlet.\nhttp.HttpServletResponse): com.oracle.svm.core.jdk.UnsupportedFeatureError: Proxy class defined by\ninterfaces [interface org.springframework.web.bind.annotation.PostMapping, interface org.springframework.\ncore.annotation.SynthesizedAnnotation] not found. Generating proxy classes at runtime is not supported.\nProxy classes need to be defined at image build time by specifying the list of interfaces that they\nimplement. To define proxy classes use -H:DynamicProxyConfigurationFiles=&lt;comma-separated-config-files&gt;\nand -H:DynamicProxyConfigurationResources=&lt;comma-separated-config-resources&gt; options.</code></pre>\n<p>大意是不支持在运行时生成代理类，可以在构建时将代理类的信息定义好，用 <code>-H:DynamicProxyConfigurationFiles</code> 从文件中读取配置信息，或者用 <code>-H:DynamicProxyConfigurationResources</code> 从 CLASSPATH 资源中读取配置信息。我们可以在 resources 中新增一个 dynamic-proxy.json 文件，内容如代码示例 C-10 所示。里面的内容是一个 JSON 数组，数组中的每个元素都是一个代理类涉及的接口，接口的顺序要和上面日志中的接口顺序一致。</p>\n<blockquote>\n<p><strong>代码示例 C-10</strong>　dynamic-proxy.json 文件的内容</p>\n</blockquote>\n<pre class=\"code-rows\"><code>[\n    { \"interfaces\": [ \"org.springframework.web.bind.annotation.PostMapping\", \"org.springframework.core.\nannotation.SynthesizedAnnotation\" ] },\n    { \"interfaces\": [ \"org.springframework.web.bind.annotation.GetMapping\", \"org.springframework.core.\nannotation.SynthesizedAnnotation\" ] },\n    { \"interfaces\": [ \"org.springframework.boot.autoconfigure.web.servlet.ConditionalOnMissingFilterBean\",\n\"org.springframework.core.annotation.SynthesizedAnnotation\" ] }\n]</code></pre>\n<p>随后，调整 pom.xml 中 native-maven-plugin 插件的配置，增加构建参数，具体如代码示例 C-11 所示。</p>\n<blockquote>\n<p><strong>代码示例 C-11</strong>　调整 native-maven-plugin</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;\n    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;0.9.11&lt;/version&gt;\n    &lt;!-- 省略部分内容 --&gt;\n    &lt;configuration&gt;\n        &lt;buildArgs&gt;\n            &lt;buildArg&gt;-H:DynamicProxyConfigurationResources=dynamic-proxy.json&lt;/buildArg&gt;\n        &lt;/buildArgs&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;</code></pre>\n</li>\n</ol>\n<h3 id=\"nav_point_275\">C.2.4　其他优化</h3>\n<p>在解决问题之余，我们还可以做一些优化，让生成的本地镜像跑得更快，占用资源更少，例如：</p>\n<ul>\n<li>可以用 tomcat-embed-programmatic 来代替 tomcat-embed-core 和 tomcat-embed-websocket；<span class=\"comment-number\">12</span></li>\n<li>如果不用 Micrometer 来输出度量信息，可以从 spring-boot-starter-actuator 中去掉 Micrometer 的依赖；</li>\n<li>如前文提到的，去除不必要的 SpEL、XML 和 YAML 支持，但前提是明确自己确实不需要。<span class=\"comment-number\">13</span></li>\n</ul>\n\n\n<p>这些优化都放在 pom.xml 中（前两个都是对依赖的调整），具体如代码示例 C-12 所示。</p>\n<blockquote>\n<p><strong>代码示例 C-12</strong>　对依赖的一些优化</p>\n</blockquote>\n<pre class=\"code-rows\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;\n            &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;\n            &lt;artifactId&gt;tomcat-embed-websocket&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.tomcat.experimental&lt;/groupId&gt;\n    &lt;artifactId&gt;tomcat-embed-programmatic&lt;/artifactId&gt;\n    &lt;version&gt;$&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;io.micrometer&lt;/groupId&gt;\n            &lt;artifactId&gt;micrometer-core&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;</code></pre>\n<p>在完成了上述所有改动后，我们可以重新构建项目的本地镜像，然后通过浏览器访问 Web 界面，或者用 Customer 工程访问 REST 服务，系统应该能正常响应。</p>\n<p>对比一下现在使用的本地镜像与传统的 Fat Jar，在启动日志里找到 <code>Started BinaryTeaApplication in XXX seconds</code> 那行，两者有着天壤之别。本地镜像启动仅需 0.434 秒，也就是 434 毫秒，内存占用大约在 94MB。而用 java -jar 方式运行 Fat Jar，启动需要 3.544 秒，内存占用大约是 577MB，大约<strong>分别是前者的 8 倍与 6 倍</strong>。<span class=\"comment-number\">14</span> 可见 Spring Native 与 GraalVM 还是为我们的二进制奶茶店项目带来了很大的性能提升的，无论是否运行在容器中，这种提升都是很可观的。</p>\n\n\n<br style=\"page-break-after:always\" />","neighbors":{"left":{"article_title":"附录 B 将应用程序打包为 Docker 镜像","id":740898},"right":{"article_title":"后记","id":740900}},"comments":[]}