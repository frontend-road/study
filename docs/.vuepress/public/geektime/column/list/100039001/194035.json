{"id":194035,"title":"41 | 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？","content":"<p>从今天开始，我们正式进入到设计模式的学习。我们知道，经典的设计模式有23种。其中，常用的并不是很多。据我的工作经验来看，常用的可能都不到一半。如果随便抓一个程序员，让他说一说最熟悉的3种设计模式，那其中肯定会包含今天要讲的单例模式。</p><p>网上有很多讲解单例模式的文章，但大部分都侧重讲解，如何来实现一个线程安全的单例。我今天也会讲到各种单例的实现方法，但是，这并不是我们专栏学习的重点，我重点还是希望带你搞清楚下面这样几个问题（第一个问题会在今天讲解，后面三个问题放到下一节课中讲解）。</p><ul>\n<li>为什么要使用单例？</li>\n<li>单例存在哪些问题？</li>\n<li>单例与静态类的区别？</li>\n<li>有何替代的解决方案？</li>\n</ul><p>话不多说，让我们带着这些问题，正式开始今天的学习吧！</p><h2>为什么要使用单例？</h2><p><strong>单例设计模式</strong>（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><p>对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来我通过两个实战案例来讲解。</p><h3>实战案例一：处理资源访问冲突</h3><p>我们先来看第一个例子。在这个例子中，我们自定义实现了一个往文件中打印日志的Logger类。具体的代码实现如下所示：</p><!-- [[[read_end]]] --><pre><code>public class Logger {\n  private FileWriter writer;\n  \n  public Logger() {\n    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    writer.write(message);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  private Logger logger = new Logger();\n  \n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    logger.log(username + &quot; logined!&quot;);\n  }\n}\n\npublic class OrderController {\n  private Logger logger = new Logger();\n  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    logger.log(&quot;Created an order: &quot; + order.toString());\n  }\n}\n</code></pre><p>看完代码之后，先别着急看我下面的讲解，你可以先思考一下，这段代码存在什么问题。</p><p>在上面的代码中，我们注意到，所有的日志都写入到同一个文件/Users/wangzheng/log.txt中。在UserController和OrderController中，我们分别创建两个Logger对象。在Web容器的Servlet多线程环境下，如果两个Servlet线程同时分别执行login()和create()两个函数，并且同时写日志到log.txt文件中，那就有可能存在日志信息互相覆盖的情况。</p><p>为什么会出现互相覆盖呢？我们可以这么类比着理解。在多线程环境下，如果两个线程同时给同一个共享变量加1，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加了2，而是只加了1。同理，这里的log.txt文件也是竞争资源，两个线程同时往里面写数据，就有可能存在互相覆盖的情况。</p><p><img src=\"https://static001.geekbang.org/resource/image/2b/c2/2b0e6141d10399430c59169af4edc3c2.jpg?wh=3743*1496\" alt=\"\"></p><p>那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：给log()函数加互斥锁（Java中可以通过synchronized的关键字），同一时刻只允许一个线程调用执行log()函数。具体的代码实现如下所示：</p><pre><code>public class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(this) {\n      writer.write(mesasge);\n    }\n  }\n}\n</code></pre><p>不过，你仔细想想，这真的能解决多线程写入日志时互相覆盖的问题吗？答案是否定的。这是因为，这种锁是一个对象级别的锁，一个对象在不同的线程下同时调用log()函数，会被强制要求顺序执行。但是，不同的对象之间并不共享同一把锁。在不同的线程下，通过不同的对象调用执行log()函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题。</p><p><img src=\"https://static001.geekbang.org/resource/image/20/29/203eb5070c3820b48500d4ab95732f29.jpg?wh=2323*1807\" alt=\"\"></p><p>我这里稍微补充一下，在刚刚的讲解和给出的代码中，我故意“隐瞒”了一个事实：我们给log()函数加不加对象级别的锁，其实都没有关系。因为FileWriter本身就是线程安全的，它的内部实现中本身就加了对象级别的锁，因此，在外层调用write()函数的时候，再加对象级别的锁实际上是多此一举。因为不同的Logger对象不共享FileWriter对象，所以，FileWriter对象级别的锁也解决不了数据写入互相覆盖的问题。</p><p>那我们该怎么解决这个问题呢？实际上，要想解决这个问题也不难，我们只需要把对象级别的锁，换成类级别的锁就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用log()函数，而导致的日志覆盖问题。具体的代码实现如下所示：</p><pre><code>public class Logger {\n  private FileWriter writer;\n\n  public Logger() {\n    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public void log(String message) {\n    synchronized(Logger.class) { // 类级别的锁\n      writer.write(mesasge);\n    }\n  }\n}\n</code></pre><p>除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，分布式锁是最常听到的一种解决方案。不过，实现一个安全可靠、无bug、高性能的分布式锁，并不是件容易的事情。除此之外，并发队列（比如Java中的BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。</p><p>相对于这两种解决方案，单例模式的解决思路就简单一些了。单例模式相对于之前类级别锁的好处是，不用创建那么多Logger对象，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p><p>我们将Logger设计成一个单例类，程序中只允许创建一个Logger对象，所有的线程共享使用的这一个Logger对象，共享一个FileWriter对象，而FileWriter本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。</p><p>按照这个设计思路，我们实现了Logger单例类。具体代码如下所示：</p><pre><code>public class Logger {\n  private FileWriter writer;\n  private static final Logger instance = new Logger();\n\n  private Logger() {\n    File file = new File(&quot;/Users/wangzheng/log.txt&quot;);\n    writer = new FileWriter(file, true); //true表示追加写入\n  }\n  \n  public static Logger getInstance() {\n    return instance;\n  }\n  \n  public void log(String message) {\n    writer.write(mesasge);\n  }\n}\n\n// Logger类的应用示例：\npublic class UserController {\n  public void login(String username, String password) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(username + &quot; logined!&quot;);\n  }\n}\n\npublic class OrderController {  \n  public void create(OrderVo order) {\n    // ...省略业务逻辑代码...\n    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());\n  }\n}\n</code></pre><h3>实战案例二：表示全局唯一类</h3><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。</p><p>比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。</p><p>再比如，唯一递增ID号码生成器（<a href=\"https://time.geekbang.org/column/article/190979\">第34讲</a>中我们讲的是唯一ID生成器，这里讲的是唯一递增ID生成器），如果程序中有两个对象，那就会存在生成重复ID的情况，所以，我们应该将ID生成器类设计为单例。</p><pre><code>import java.util.concurrent.atomic.AtomicLong;\npublic class IdGenerator {\n  // AtomicLong是一个Java并发库中提供的一个原子变量类型,\n  // 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，\n  // 比如下面会用到的incrementAndGet().\n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n\n// IdGenerator使用举例\nlong id = IdGenerator.getInstance().getId();\n</code></pre><p>实际上，今天讲到的两个代码实例（Logger、IdGenerator），设计的都并不优雅，还存在一些问题。至于有什么问题以及如何改造，今天我暂时卖个关子，下一节课我会详细讲解。</p><h2>如何实现一个单例？</h2><p>尽管介绍如何实现一个单例模式的文章已经有很多了，但为了保证内容的完整性，我这里还是简单介绍一下几种经典实现方式。概括起来，要实现一个单例，我们需要关注的点无外乎下面几个：</p><ul>\n<li>构造函数需要是private访问权限的，这样才能避免外部通过new创建实例；</li>\n<li>考虑对象创建时的线程安全问题；</li>\n<li>考虑是否支持延迟加载；</li>\n<li>考虑getInstance()性能是否高（是否加锁）。</li>\n</ul><p>如果你对这块已经很熟悉了，你可以当作复习。注意，下面的几种单例实现方式是针对Java语言语法的，如果你熟悉的是其他语言，不妨对比Java的这几种实现方式，自己试着总结一下，利用你熟悉的语言，该如何实现。</p><h3>1.饿汉式</h3><p>饿汉式的实现方式比较简单。在类加载的时候，instance静态实例就已经创建并初始化好了，所以，instance实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加载（在真正用到IdGenerator的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p><pre><code>public class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static final IdGenerator instance = new IdGenerator();\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n</code></pre><p>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并不认同这样的观点。</p><p>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</p><p>如果实例占用资源多，按照fail-fast的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如Java中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p><h3>2.懒汉式</h3><p>有饿汉式，对应的，就有懒汉式。懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p><pre><code>public class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static synchronized IdGenerator getInstance() {\n    if (instance == null) {\n      instance = new IdGenerator();\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n</code></pre><p>不过懒汉式的缺点也很明显，我们给getInstance()这个方法加了一把大锁（synchronzed），导致这个函数的并发度很低。量化一下的话，并发度是1，也就相当于串行操作了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈，这种实现方式就不可取了。</p><h3>3.双重检测</h3><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。</p><p>在这种实现方式中，只要instance被创建之后，即便再调用getInstance()函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p><pre><code>public class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() {}\n  public static IdGenerator getInstance() {\n    if (instance == null) {\n      synchronized(IdGenerator.class) { // 此处为类级别的锁\n        if (instance == null) {\n          instance = new IdGenerator();\n        }\n      }\n    }\n    return instance;\n  }\n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n</code></pre><p>网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致IdGenerator对象被new出来，并且赋值给instance之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。</p><p>要解决这个问题，我们需要给instance成员变量加上volatile关键字，禁止指令重排序才行。实际上，只有很低版本的Java才会有这个问题。我们现在用的高版本的Java已经在JDK内部实现中解决了这个问题（解决的方法很简单，只要把对象new操作和初始化操作设计为原子操作，就自然能禁止重排序）。关于这点的详细解释，跟特定语言有关，我就不展开讲了，感兴趣的同学可以自行研究一下。</p><h3>4.静态内部类</h3><p>我们再来看一种比双重检测更加简单的实现方法，那就是利用Java的静态内部类。它有点类似饿汉式，但又能做到了延迟加载。具体是怎么做到的呢？我们先来看它的代码实现。</p><pre><code>public class IdGenerator { \n  private AtomicLong id = new AtomicLong(0);\n  private IdGenerator() {}\n\n  private static class SingletonHolder{\n    private static final IdGenerator instance = new IdGenerator();\n  }\n  \n  public static IdGenerator getInstance() {\n    return SingletonHolder.instance;\n  }\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n</code></pre><p>SingletonHolder 是一个静态内部类，当外部类IdGenerator被加载的时候，并不会创建SingletonHolder实例对象。只有当调用getInstance()方法时，SingletonHolder才会被加载，这个时候才会创建instance。instance的唯一性、创建过程的线程安全性，都由JVM来保证。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><h3>5.枚举</h3><p>最后，我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：</p><pre><code>public enum IdGenerator {\n  INSTANCE;\n  private AtomicLong id = new AtomicLong(0);\n \n  public long getId() { \n    return id.incrementAndGet();\n  }\n}\n</code></pre><h2>重点回顾</h2><p>好了，今天的内容到此就讲完了。我们来总结回顾一下，你需要掌握的重点内容。</p><p><strong>1.单例的定义</strong></p><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><p><strong>2.单例的用处</strong></p><p>从业务概念上，有些数据在系统中只应该保存一份，就比较适合设计为单例类。比如，系统的配置信息类。除此之外，我们还可以使用单例解决资源访问冲突的问题。</p><p><strong>3.单例的实现</strong></p><p>单例有下面几种经典的实现方式。</p><ul>\n<li>饿汉式</li>\n</ul><p>饿汉式的实现方式，在类加载的期间，就已经将instance静态实例初始化好了，所以，instance实例的创建是线程安全的。不过，这样的实现方式不支持延迟加载实例。</p><ul>\n<li>懒汉式</li>\n</ul><p>懒汉式相对于饿汉式的优势是支持延迟加载。这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁的调用会产生性能瓶颈。</p><ul>\n<li>双重检测</li>\n</ul><p>双重检测实现方式既支持延迟加载、又支持高并发的单例实现方式。只要instance被创建之后，再调用getInstance()函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。</p><ul>\n<li>静态内部类</li>\n</ul><p>利用Java的静态内部类来实现单例。这种实现方式，既支持延迟加载，也支持高并发，实现起来也比双重检测简单。</p><ul>\n<li>枚举</li>\n</ul><p>最简单的实现方式，基于枚举类型的单例实现。这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。</p><h2>课堂讨论</h2><ol>\n<li>在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？</li>\n<li>在第一个实战案例中，除了我们讲到的类级别锁、分布式锁、并发队列、单例模式等解决方案之外，实际上还有一种非常简单的解决日志互相覆盖问题的方法，你想到了吗？</li>\n</ol><p>可以在留言区说一说，和同学一起交流和分享。如果有收获，也欢迎你把这篇文章分享给你的朋友。</p>","neighbors":{"left":{"article_title":"40 | 运用学过的设计原则和思想完善之前讲的性能计数器项目（下）","id":193555},"right":{"article_title":"42 | 单例模式（中）：我为什么不推荐使用单例模式？又有何替代方案？","id":194068}},"comments":[{"had_liked":false,"id":175875,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":true,"comment_ctime":1580875805,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"9.2233733226308997e+18","product_id":100039001,"comment_content":"这真的是看过的关于讲单例的最好的文章","like_count":300,"discussions":[{"author":{"id":1575571,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","nickname":"Eric","note":"","ucode":"7EB511C384BD7B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":60868,"discussion_content":"谁说的继承是毫无保留？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1574761113,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1217230,"avatar":"https://static001.geekbang.org/account/avatar/00/12/92/ce/9d24cb2c.jpg","nickname":"小学一年级","note":"","ucode":"59B9805D7C2D92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1575571,"avatar":"https://static001.geekbang.org/account/avatar/00/18/0a/93/a189ec16.jpg","nickname":"Eric","note":"","ucode":"7EB511C384BD7B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61239,"discussion_content":"是的，私有属性不能被继承","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574776109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":60868,"ip_address":""},"score":61239,"extra":""},{"author":{"id":2015438,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/c0/ce/eb1b4ae1.jpg","nickname":"可圈可丶","note":"","ucode":"EB527E176EDE91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1217230,"avatar":"https://static001.geekbang.org/account/avatar/00/12/92/ce/9d24cb2c.jpg","nickname":"小学一年级","note":"","ucode":"59B9805D7C2D92","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287573,"discussion_content":"错，继承就是毫无保留。子类的确不能访问父类的private属性和方法，但是Oracle官方文档明确说明了，子类会继承父类的一切，包括private属性和方法，只是不能不能访问","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1593484241,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":61239,"ip_address":""},"score":287573,"extra":""},{"author":{"id":1076100,"avatar":"https://static001.geekbang.org/account/avatar/00/10/6b/84/d1e6eac9.jpg","nickname":"sun","note":"","ucode":"0358B9288D4018","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1217230,"avatar":"https://static001.geekbang.org/account/avatar/00/12/92/ce/9d24cb2c.jpg","nickname":"小学一年级","note":"","ucode":"59B9805D7C2D92","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294811,"discussion_content":"继承其实是继承所有,只不过被约束了, 子类在初始化的时候,会为父类的私有变量分配内存空间","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1596007271,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":61239,"ip_address":""},"score":294811,"extra":""}]},{"author":{"id":1625651,"avatar":"https://static001.geekbang.org/account/avatar/00/18/ce/33/09498236.jpg","nickname":"Geek_1b6022","note":"","ucode":"EBDDEF36DE58DF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":51424,"discussion_content":"兄弟，考不考虑写小说？","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573869887,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2646147,"avatar":"","nickname":"Geek_814a71","note":"","ucode":"95FCEB5F80F72F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377196,"discussion_content":"奥特曼变身有点东西啊，让我想到了迪迦的红色，迪迦的蓝色形态","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1622544678,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1337340,"avatar":"https://static001.geekbang.org/account/avatar/00/14/67/fc/e4ee44b7.jpg","nickname":"B","note":"","ucode":"542EE1046B116B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":110920,"discussion_content":"由道到术？是不是反了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1577765894,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156383,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/OokHAy1fSOhBwwbbzud7seB5MEk4JezcGCS4Tzia7iaLOibCKgrj6PCN2b17bVAb224ygdLgjWVMnZsH18ibNoSTVA/132","nickname":"澜奏","note":"","ucode":"8682168E18B068","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":61020,"discussion_content":"兄弟，你这个有点萌萌哒了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574769804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52512,"discussion_content":"理解独到！ ","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574058248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2791307,"avatar":"","nickname":"Geek6444","note":"","ucode":"D06CCF0EC1CAC4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400315,"discussion_content":"高人往往能把复杂的事情用平常人都能听懂的方式说出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633231871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2402804,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/ia09eNhQrdiarpkkjquBc4WMADuEqSJEBgjiaOM9Cdsp5jORM36k3GO1cGJWkGgkCB1qPwpibXK8gNibiaOrMibtYQYVg/132","nickname":"Geek_427070","note":"","ucode":"8BBD98625AF249","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":360976,"discussion_content":"你在说啥？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1616572042,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2026729,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/hh0DgEGDicER5svooZUPEFUNiaQibbFYVCSZeUcUlIawBiaOKwA0nqnWbmc23cPdevtEODTibqpQ5yUsG57s3jWl0nQ/132","nickname":"Geek_51f16a","note":"","ucode":"44FDD7C940207E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356436,"discussion_content":"比比瞎","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615599327,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1240321,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ed/01/997432f3.jpg","nickname":"喜笑延开","note":"","ucode":"DBF645D2129460","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":347144,"discussion_content":"NB","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612163908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026832,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ab/10/b812ff3e.jpg","nickname":"Hesher","note":"","ucode":"99AB8B1704CB7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297885,"discussion_content":"什么鬼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597101780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1134517,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4f/b5/e0bb3efe.jpg","nickname":"晗晗","note":"","ucode":"93C812E7E5AA75","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":287870,"discussion_content":"哈哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593574490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1488356,"avatar":"https://static001.geekbang.org/account/avatar/00/16/b5/e4/e6faf686.jpg","nickname":"握了个大蚂蚱","note":"","ucode":"AD34AD4FA37371","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284100,"discussion_content":"泥在说什么飞机","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592445228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268481,"discussion_content":"快把他抬走","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589788855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1298790,"avatar":"https://static001.geekbang.org/account/avatar/00/13/d1/66/db125960.jpg","nickname":"urbane","note":"","ucode":"F2BA3E97327003","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":55074,"discussion_content":"瞎比比","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574337639,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1028961,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/b3/61/e08899fe.jpg","nickname":"Jimmy","note":"","ucode":"A3DEB98CDD03B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53942,"discussion_content":"不要瞎理解","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574239110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1122963,"avatar":"https://static001.geekbang.org/account/avatar/00/11/22/93/d02d1d3d.jpg","nickname":"树树树树树华","note":"","ucode":"0A24FF3AE00A4C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53486,"discussion_content":"天呐，我看一眼就感觉懂了！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574171893,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1027189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/75/002720a4.jpg","nickname":"mylikey","note":"","ucode":"8558D33CBEA3C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":53407,"discussion_content":"大佬们，为啥多态是奥特曼变身？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574166272,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1346309,"avatar":"https://static001.geekbang.org/account/avatar/00/14/8b/05/3315b855.jpg","nickname":"Neuject","note":"","ucode":"4DCFF6CDC4186E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1027189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ac/75/002720a4.jpg","nickname":"mylikey","note":"","ucode":"8558D33CBEA3C1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":91134,"discussion_content":"一个“变身”的执行，可以根据本质变身成不同的奥特曼。奥特曼就是接口，各种迪加奥特曼啊雷欧奥特曼啊啥的都是继承了这个接口的类，执行相同的内容可以产生多种状态，即多态性","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1576812182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":53407,"ip_address":""},"score":91134,"extra":""}]}]},{"had_liked":false,"id":175903,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1580883219,"is_pvip":false,"discussion_count":41,"race_medal":0,"score":"469732318483","product_id":100039001,"comment_content":"争哥新年好， 有个问题想请教一下，单例的实现中看到过一种实现方式，包括在spring源码中有类似的实现 ，代码如下 <br> 1. public  class Singleton {<br>    private static volatile Singleton instance=null; <br>    private Singleton() {<br>    } <br><br>    public static Singleton getInstance() {&#47;&#47;  <br>        Singleton temp=instance;  &#47;&#47;  为什么要用局部变量来接收<br>        if (null == temp) { <br>            synchronized (Singleton.class) { <br>                temp=instance;<br>                if (null == temp) { <br>                    temp=new Singleton(); <br>                    instance=temp;<br>                }<br>            }<br>        }<br>        return instance; <br>    }<br>}<br><br>spring源码  如   ReactiveAdapterRegistry。 <br>JDK 源码 如 AbstractQueuedSynchronizer。<br>很多地方 都有用 局部变量 来接收 静态的成员变量， 请问下 这么写有什么性能上的优化点吗？<br>jcu 包下面类似的用法太多。想弄明白为什么要这样写<br>2. 看jdk 官方的文档（JMM）有说明 指令重排发生的地方有很多 ，编译器，及时编译，CPU在硬件层面的优化，看spring 比较新的代码也使用volatile来修饰，你说的new 关键字和初始化 作为原子操作 可以说一下 大概的jdk版本吗","like_count":110,"discussions":[{"author":{"id":1242602,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f5/ea/5f046856.jpg","nickname":"Dale","note":"","ucode":"AD19A33FE5EEDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387112,"discussion_content":"感觉“封装隐藏属性，抽象隐藏方法”不太合理，感觉“封装控制访问，抽象隐藏实现”可能更贴切","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1627992128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1150022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8c/46/dbf8eb8a.jpg","nickname":"kelly","note":"","ucode":"B1DFA3D7340869","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278207,"discussion_content":"瞎理解别误人子弟，封装难道不能隐藏方法？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1591161510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1075033,"avatar":"https://static001.geekbang.org/account/avatar/00/10/67/59/017b5726.jpg","nickname":"猫切切切切切","note":"","ucode":"F350BA1B7FFDC4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1150022,"avatar":"https://static001.geekbang.org/account/avatar/00/11/8c/46/dbf8eb8a.jpg","nickname":"kelly","note":"","ucode":"B1DFA3D7340869","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":280239,"discussion_content":"只是提出个人看法接收批评，并不打算接收子弟","likes_number":16,"is_delete":false,"is_hidden":false,"ctime":1591516839,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":278207,"ip_address":""},"score":280239,"extra":""}]},{"author":{"id":2929950,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/8udden1kRL4giajiaeIWZFQExRq3w9QLEicx3UUf3col1JiaxKLWM5oy4ch1yqH8XjVGL4iaLRKYHPe2WJyy1WP1ELg/132","nickname":"Geek_2a844d","note":"","ucode":"99F34F8A700308","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554373,"discussion_content":"不错😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646359640,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1623117,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c4/4d/85014aab.jpg","nickname":"一叉树","note":"","ucode":"BFC984403ACD1F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":338649,"discussion_content":"非常精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1609330871,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2153943,"avatar":"https://static001.geekbang.org/account/avatar/00/20/dd/d7/885e4ce3.jpg","nickname":"Am0xil","note":"","ucode":"CE2A04F9FF9FE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336714,"discussion_content":"表示赞同，以我粗浅的理解，封装本身就是为了保护类中的重要属性在程序中不被随意修改，而必须要通过定义的set方法。实在看不懂评论区的有些人，筷子本身就是用来吃饭的，他非要问，筷子为啥不能用来夹其他东西","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1608685621,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268485,"discussion_content":"好的\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589789109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1181647,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","nickname":"L.","note":"","ucode":"46A2F679C094E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229624,"discussion_content":"精辟","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586675159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1007385,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/5f/19/70d74403.jpg","nickname":"王志祥","note":"","ucode":"F3D2CBDA07E143","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1181647,"avatar":"https://static001.geekbang.org/account/avatar/00/12/07/cf/b0d6fe74.jpg","nickname":"L.","note":"","ucode":"46A2F679C094E8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":231767,"discussion_content":"同意楼上","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586828536,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":229624,"ip_address":""},"score":231767,"extra":""}]}]},{"had_liked":false,"id":239282,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1596478430,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"169100202974","product_id":100039001,"comment_content":"懒汉式还是饿汉式更好我觉得需要看具体的场景。对于那些短生命周期的应用，如客户端应用来说，启动是频繁发生的，如果启动时导致了一堆饿汉初始化，会给用户带来不好的体验，如果把初始化往后延，将初始化分散在未来的各个时间点，即使某个懒汉初始化时间较长，用户也几乎无感知。而对于生命周期较长的应用，长痛不如短痛，启动时耗点时，保证后面的使用流畅也是可取的。","like_count":40,"discussions":[{"author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50294,"discussion_content":"C 结构体的封装，和没封装一样。没有访问权限的支持，在哪里都可以直接修改。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573700143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1514660,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1c/a4/202dde43.jpg","nickname":"猴精鸭","note":"","ucode":"7513DC4138E031","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1193874,"avatar":"https://static001.geekbang.org/account/avatar/00/12/37/92/961ba560.jpg","nickname":"授人以🐟，不如授人以渔","note":"","ucode":"BD53829E924B66","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":347804,"discussion_content":"c头文件只声明结构体，结构体的定义放到源文件中就是封装了，对外只提供头文件，调用者不知道结构体里有什么，只能通过函数进行使用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1612327335,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":50294,"ip_address":""},"score":347804,"extra":""}]},{"author":{"id":1444483,"avatar":"https://static001.geekbang.org/account/avatar/00/16/0a/83/f916f903.jpg","nickname":"风","note":"","ucode":"E1CE0825AAF805","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300961,"discussion_content":"C的结构体，不叫封装，它“只装不封”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598343555,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175931,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1580887376,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"139019840848","product_id":100039001,"comment_content":"简单的方法：创建一个静态私有的filewritter，多线程或者多个Logger对象共享一个filewritter。","like_count":33,"discussions":[{"author":{"id":1319369,"avatar":"https://static001.geekbang.org/account/avatar/00/14/21/c9/2b1e5326.jpg","nickname":"俞俊001","note":"","ucode":"B6D3F5448D4138","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129579,"discussion_content":"第五点有点疑问。JavaScript 天然通过duck type支持多态。你的说法是强行用Java这种基于类的多态来描述JavaScript。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578715469,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177178,"user_name":"xindoo","can_delete":false,"product_type":"c1","uid":1101718,"ip_address":"","ucode":"AEAF3208E644BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","comment_is_top":false,"comment_ctime":1581315510,"is_pvip":true,"discussion_count":40,"race_medal":0,"score":"96070596022","product_id":100039001,"comment_content":"为什么高版本的jdk单例不再需要volatile修饰，求详细参考资料，感谢🙏","like_count":22,"discussions":[{"author":{"id":1750549,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/b6/15/e2cfd10d.jpg","nickname":"ImYours°","note":"","ucode":"51F653129034C9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":388071,"discussion_content":"嘿，你他娘的还真是个人才","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628580660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1576240,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlibCGekRp9bxJ3dGfOWghhNVdF771ejzwqKnicKFBpmGuutwNGF3HGZz7KEEz2mdvPckibReRsVtDw/132","nickname":"Geek_e6159b","note":"","ucode":"0684569F9B114D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301404,"discussion_content":"琦玉，大兄弟。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598516336,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1018696,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/8b/48/e2279b0e.jpg","nickname":"绵阳米粉儿真好吃","note":"","ucode":"F82499FD76B5EF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253481,"discussion_content":"看到这条评论莫名想笑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588237956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":209431,"user_name":"夏目","can_delete":false,"product_type":"c1","uid":1212750,"ip_address":"","ucode":"67C075A01CF4D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","comment_is_top":false,"comment_ctime":1587548324,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"74601992356","product_id":100039001,"comment_content":"枚举模式的单例还可以防止序列化和反序列化生成新的实例<br>","like_count":17,"discussions":[{"author":{"id":1337016,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/b8/ece79234.jpg","nickname":"王智","note":"","ucode":"37D2AD591C1AEC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":534790,"discussion_content":"“反序列化破坏单例”啥实际场景会发生？能举个例子吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638277683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2608306,"avatar":"https://static001.geekbang.org/account/avatar/00/27/cc/b2/b9410d7b.jpg","nickname":"亚洲颜值的半壁江山","note":"","ucode":"FC30B96CDE9AA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1337016,"avatar":"https://static001.geekbang.org/account/avatar/00/14/66/b8/ece79234.jpg","nickname":"王智","note":"","ucode":"37D2AD591C1AEC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":548718,"discussion_content":"https://segmentfault.com/a/1190000024575275","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643339856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":534790,"ip_address":""},"score":548718,"extra":""}]},{"author":{"id":1547153,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epRGOxOySWV1kuWaBIgPpdasJk7Ho1fje79NGwp2yKnOrSTECYXSPibvfZ3usicxakneUE0bMiaLQt2A/132","nickname":"Geek_1c5783","note":"","ucode":"CD6CDB455E34A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":348710,"discussion_content":"序列化反序列化破坏单例模式，应该如何防范","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1612686305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1622448,"avatar":"https://static001.geekbang.org/account/avatar/00/18/c1/b0/b52d9ade.jpg","nickname":"苏彧","note":"","ucode":"C016B28DF7449C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1547153,"avatar":"https://wx.qlogo.cn/mmopen/vi_32/DYAIOgq83epRGOxOySWV1kuWaBIgPpdasJk7Ho1fje79NGwp2yKnOrSTECYXSPibvfZ3usicxakneUE0bMiaLQt2A/132","nickname":"Geek_1c5783","note":"","ucode":"CD6CDB455E34A5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":391113,"discussion_content":"用枚举方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1630298688,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":348710,"ip_address":""},"score":391113,"extra":""}]}]},{"had_liked":false,"id":175904,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1580883235,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"66005392675","product_id":100039001,"comment_content":"Singleton指仅仅被实例化一次的类. Singleton通常被用来代表本质上唯一的系统组件, 如窗口管理器或文件系统.<br><br>-- &lt;Effective Java&gt;  p14<br><br>课堂讨论:<br><br>1. 在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？<br><br>   Android SDK中的AccessibilityManager应用了懒汉式单例模式.<br><br>   <br><br>2. 在第一个实战案例中，除了我们讲到的类级别锁、分布式锁、并发队列、单例模式等解决方案之外，实际上还有一种非常简单的解决日志互相覆盖问题的方法，你想到了吗？<br><br>​    将FileWriter的声明用static修饰, 即可解决日志相互覆盖的问题. 原理: 被声明为static的成员变量由类的所有实例所共享, 所以Logger类的所有实例都是通过同一FileWriter写入日志到文件. ","like_count":15},{"had_liked":false,"id":205983,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1586767724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35946506092","product_id":100039001,"comment_content":"90年代的论文的确说了因为JVM的优化和多核CPU会对指令进行reordering，volatile才能解决双检锁问题：http:&#47;&#47;www.cs.umd.edu&#47;~pugh&#47;java&#47;memoryModel&#47;DoubleCheckedLocking.html","like_count":8},{"had_liked":false,"id":203928,"user_name":"Murrre","can_delete":false,"product_type":"c1","uid":1685995,"ip_address":"","ucode":"49644059B512BE","user_header":"https://static001.geekbang.org/account/avatar/00/19/b9/eb/6bdab896.jpg","comment_is_top":false,"comment_ctime":1586308177,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35946046545","product_id":100039001,"comment_content":"争哥讲得真好,不过有一点也有疑问.<br>----------------------<br>只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。<br>---------------<br>这个在google百度都没找到,争哥能提供一下相关资料吗","like_count":8,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474823,"discussion_content":"从你的描述来看，有点类似的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574855183,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2875594,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/e0/ca/adfaa551.jpg","nickname":"孙新","note":"","ucode":"A80038A479B943","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579702,"discussion_content":"c++的模板让c++变成了另外一门语言","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657621963,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2054357,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/58/d5/6688e2a0.jpg","nickname":"hey","note":"","ucode":"ECD6D0EC04E50B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":400754,"discussion_content":"别这样，C++的template和Java的interface类似，B和C类似于继承了相同父类的子类，它们之间也自然没有继承关系。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1633412918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178628,"user_name":"techwro","can_delete":false,"product_type":"c1","uid":1113744,"ip_address":"","ucode":"7AF2B319F0AE1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","comment_is_top":false,"comment_ctime":1581762646,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"31646533718","product_id":100039001,"comment_content":"争哥，求“只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序”这一说法的出处。","like_count":7,"discussions":[{"author":{"id":1802610,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/81/72/e6dbf6f3.jpg","nickname":"Roc","note":"","ucode":"0D71BD87E3DD54","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":252271,"discussion_content":"我的理解是没必要把抽象狭义化和实体化；抽象体现在多个方面：在函数中，抽象意味着隐藏实现细节；在类的构建中，抽象意味着抽取个体的共性，定义泛指的通用的类。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1588146683,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1162461,"avatar":"https://static001.geekbang.org/account/avatar/00/11/bc/dd/c9413f59.jpg","nickname":"铿然","note":"","ucode":"D529242EC2E2EA","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1802610,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/81/72/e6dbf6f3.jpg","nickname":"Roc","note":"","ucode":"0D71BD87E3DD54","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":256279,"discussion_content":"不错，确实可以这么说，好比设计模型，有L0视图，L1视图，越底层越抽象，这些并不是因为共性抽象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588468125,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":252271,"ip_address":""},"score":256279,"extra":""}]},{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":109156,"discussion_content":"我之前也是这么理解的，学习后有点模糊。\n现在是这么理解的：主要是抽象共性行为，顺便隐藏了方法实现，减少其他细节信息干扰。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1577670793,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1209336,"avatar":"https://static001.geekbang.org/account/avatar/00/12/73/f8/dbd2fa50.jpg","nickname":"晓杉","note":"","ucode":"19E634BB61A165","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":129486,"discussion_content":"抽象就是为了隐藏细节，你提供SDK给别人开发，你不想把实现细节打包进去，抽象就起到了重要作用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578707750,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1679661,"avatar":"https://static001.geekbang.org/account/avatar/00/19/a1/2d/599e9051.jpg","nickname":"CycleGAN","note":"","ucode":"9FD04813911A02","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52245,"discussion_content":"我也觉得","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574007883,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1206751,"avatar":"https://static001.geekbang.org/account/avatar/00/12/69/df/2dca1305.jpg","nickname":"Healtheon","note":"","ucode":"B564B1FC4456E8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50827,"discussion_content":"你的感觉是错的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573778445,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1205294,"avatar":"https://static001.geekbang.org/account/avatar/00/12/64/2e/e70a317a.jpg","nickname":"学好习，做好人","note":"","ucode":"C991643DB458E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":50575,"discussion_content":"感觉模板模式是对抽象或者说Java中的抽象类运用最好的例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573735408,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202966,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586094599,"is_pvip":false,"replies":[{"id":"89276","content":"着急吃-》饿汉式<br>不着急吃-》懒汉式","user_name":"作者回复","comment_id":202966,"uid":"1190123","ip_address":"","utype":1,"ctime":1597454733,"user_name_real":"王争"}],"discussion_count":3,"race_medal":1,"score":"27355898375","product_id":100039001,"comment_content":"饿汉式和懒汉式的名字为什么这么起呀？可以解释一下吗？","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474262,"discussion_content":"我个人觉得duck typing过于灵活了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574333795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180696,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582366366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27352170142","product_id":100039001,"comment_content":"设计模式_41:<br># 作业<br>1. Java中有很多使用单例模式，比如`java.lang.Runtime`类，这么设计的原因是，同一个进程中只需要一个实例。<br>2. 使用同一个`writer`，比如用`static`修饰。<br><br># 感想<br><br>1. 初学Java的时候，老师讲构造函数的第二节，先是讲了`private`修饰构造函数后如何获取对象的问题，后来引出了单例模式，感激老师的循序渐进。<br><br>2. 今天的题目虽然是“双重加锁并没有好多少”，但文章中并没有解释，我猜后文中一定会分析，但也逃不过对于饿汉式的思考: 不能延时加载导致了饿汉式在更多时间地占用了资源，但占用资源少并不是软件工程的唯一追求，更好地完成业务才是第一要务，呼应之前的内容，有时候用空间(资源)换时间也很好的策略。","like_count":6},{"had_liked":false,"id":175860,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1580872052,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"27350675828","product_id":100039001,"comment_content":"打卡<br><br>看过Eventbus 的源码，写法是典型的双重锁检验方式，但是构造方法是public 的<br><br>看源码解释，这是因为EventBus可能有多条总线，订阅者注册到不同线上的 EventBus，通过不同的实例来发送数据，不同的 EventBus 是相互隔离开的，订阅者都只会收到注册到该线上事件。<br><br>但是按照单例定义他又不属于单例，感觉很有疑问","like_count":6,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474244,"discussion_content":"理论上讲这是一种hack的方法 不推荐使用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49465,"discussion_content":"我觉得一般业务不会可以使用反射，毕竟代码是自己控制的，当我们要改变源码中的逻辑，源码没有提供访问方法的时候可以考虑用反射，或者自己去编写框架的时候，不过因为反射性能损耗，运行时注解代替反射使用的更多","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1573604145,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1396951,"avatar":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","nickname":"辣么大","note":"","ucode":"AB308B6DCA0108","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":49504,"discussion_content":"Awesome explanation! It is very inspiring! Reflection mechnism is very useful, it can be used in serialization, ioc and so on. Thanks!","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1573606293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":49465,"ip_address":""},"score":49504,"extra":""}]}]},{"had_liked":false,"id":188753,"user_name":"大头","can_delete":false,"product_type":"c1","uid":1315367,"ip_address":"","ucode":"C1FB2C8A0FB0C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/27/32746bbf.jpg","comment_is_top":false,"comment_ctime":1584411926,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"23059248406","product_id":100039001,"comment_content":"枚举实现单例的最佳实践。代码简洁，由jvm保证线程安全和单一实例。还可以有效防止序列化和反序列化造成多个实例和利用反射创建多个实例的情况","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":478805,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577949734,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176201,"user_name":"zs阿帅","can_delete":false,"product_type":"c1","uid":1141173,"ip_address":"","ucode":"07A54AE7F1CAFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/b5/1e1731cc.jpg","comment_is_top":false,"comment_ctime":1580987173,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"23055823653","product_id":100039001,"comment_content":"争哥，如果服务是多个实例跑，日志那个单例模式会导致覆盖吗？","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504607,"discussion_content":"������，谢谢姐","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598835649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225529,"user_name":"星之所在","can_delete":false,"product_type":"c1","uid":1247574,"ip_address":"","ucode":"03ADB0ADD5FC27","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/56/2628852c.jpg","comment_is_top":false,"comment_ctime":1591777974,"is_pvip":false,"replies":[{"id":"83999","content":"静态变量没法替代单例啊。单例是类本身不允许多个实例。但是静态变量，我可以定义多个啊，这个怎么解决呢？","user_name":"作者回复","comment_id":225529,"uid":"1190123","ip_address":"","utype":1,"ctime":1592526562,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"18771647158","product_id":100039001,"comment_content":"争哥我想细问下，我用一个静态变量也可以实现单例的效果，为啥还要用单例设计模式？是为了代码后续扩展性，还是静态变量用多了影响整个代码？","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":475041,"discussion_content":"后面章节会讲到 别急","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574385771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179398,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1581996241,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"18761865425","product_id":100039001,"comment_content":"为什么说支持懒加载的双重检测不比饿汉式更优？<br><br>因为饿汉式在类加载的时候, 就将实例资源确定好了.<br>如果放到懒加载中,实例占用的资源很多,可能导致响应时间过长, 也可能导致(OOM),,根据fail-fast最好事早知道问题,最好提前就暴露出问题.<br>","like_count":4,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474788,"discussion_content":"透明的意思不就是不知道细节吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574040109,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1131957,"avatar":"https://static001.geekbang.org/account/avatar/00/11/45/b5/c3cfb198.jpg","nickname":"王振华 程序员","note":"","ucode":"31BB337642B882","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":59713,"discussion_content":"还是我看书太少了，原来对外透明的意思是：外部调用者可以顺利的得到自己想要的任何功能，完全意识不到内部细节的存在，是看不到或者说也不需要看到内部的细节。\n我却望文生义地以为透明的意思是既然是透明的，那就什么都能看清楚了，哈哈。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1574693187,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176003,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1580908774,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"18760777958","product_id":100039001,"comment_content":"写了篇总结，还讨论了单例模式中序列化和反序列化的问题。https:&#47;&#47;github.com&#47;gdhucoder&#47;DesignPattern&#47;blob&#47;master&#47;021_SingletonPattern.md","like_count":4,"discussions":[{"author":{"id":1138766,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/4e/1c654d86.jpg","nickname":"Omooo","note":"","ucode":"FFADFDC72EC847","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300244,"discussion_content":"好家伙！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597998153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175841,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1580868305,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"18760737489","product_id":100039001,"comment_content":"1.JDK中 java.lang.Runtime是单例实现的，该类用于管理应用程序运行期间的各种信息，比如memory和processor信息，所以从该类的用途可以知道该类必须是单例的。<br>2. 使用多个文件，每new一个实例就使用一个新文件，这样就没有文件覆盖问题了。","like_count":4},{"had_liked":false,"id":239221,"user_name":"L","can_delete":false,"product_type":"c1","uid":1357311,"ip_address":"","ucode":"5B847B2378854E","user_header":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","comment_is_top":false,"comment_ctime":1596461957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14481363845","product_id":100039001,"comment_content":"为什么高版本的jdk单例不再需要volatile修饰，求详细参考资料，感谢������<br><br>new操作 和 初始化操作 设计为原子操作，自然就不存在 指令重排了！    求详细参考资料，感谢������","like_count":3},{"had_liked":false,"id":214138,"user_name":"_Walker","can_delete":false,"product_type":"c1","uid":1173734,"ip_address":"","ucode":"85321A885786D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/e6/3fce0137.jpg","comment_is_top":false,"comment_ctime":1588665025,"is_pvip":false,"replies":[{"id":"86381","content":"不是重点,你自己研究研究吧😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594602856,"ip_address":"","comment_id":214138,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14473566913","product_id":100039001,"comment_content":"最后枚举那个解释有些含糊其辞呀😂要是能详细解释一下就好了","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474600,"discussion_content":"感觉还是一种数据驱动或者db驱动的设计思维方式。实际上，对于一些复杂业务逻辑的开发，db中数据的读和存只是很小的一部分。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573786156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193930,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1584986224,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14469888112","product_id":100039001,"comment_content":"争哥好，我也写过基本上一致的文章，再细一点可以介绍枚举为什么是effective java里最推荐的单例。关于这块的内容在深入理解java虚拟机，java并发编程的艺术，设计模式之禅等几本书里差不多都总结过。唯一的疑问，哪个版本的jdk能禁止初始化23步骤的重排序？在我印象里还是double lock需要volatile关键字的，最早是在方腾飞那本书看到的，求解","like_count":3},{"had_liked":false,"id":175864,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1580872656,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14465774544","product_id":100039001,"comment_content":"第一个问题，在我的项目中缓存类的节点设置为单例模式，还有加载全局配置文件的类，也设置为了单例模式。<br>第二个问题，我是用消息队列实现的日志收集。","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":474389,"discussion_content":"😄 马上会讲到 如何用抽象类模拟接口","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1573690531,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175844,"user_name":"🤤🤤","can_delete":false,"product_type":"c1","uid":1396597,"ip_address":"","ucode":"D10673DC29F634","user_header":"https://static001.geekbang.org/account/avatar/00/15/4f/75/8ee12b92.jpg","comment_is_top":false,"comment_ctime":1580869397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14465771285","product_id":100039001,"comment_content":"这篇非常棒，🔨","like_count":3},{"had_liked":false,"id":276435,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1611921154,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10201855746","product_id":100039001,"comment_content":"当然PHP们，也需要讨论下吧！哈哈哈<br>&lt;?php<br>&#47;&#47;创建步骤：<br>&#47;&#47;1：静态变量 Instance<br>&#47;&#47;2: 防止new，初始方法必须使用 Private<br>&#47;&#47;3: 防止克隆 将__clone()方式可见范围 private<br><br><br>class Singleton {<br>    &#47;&#47;创建静态私有变量保存该类对象<br>    static $instance = null;<br><br>    static $count = 0;<br>    &#47;&#47; 防止使用new直接创建对象<br>    private function __construct()<br>    {}<br><br>    &#47;&#47;防止被克隆<br>    private function __clone()<br>    {}<br><br><br>    public static function getInstance() {<br>        if(!self::$instance instanceof self) {<br>            echo &quot;第&quot;.++self::$count.&quot;次创建:\\r\\n&quot;;<br>            self::$instance = new self();<br>        }<br>        return self::$instance;<br>    }<br><br>    public function testEcho () {<br>        echo &quot;echo hello worlds\\r\\n&quot;;<br>    }<br>}<br><br>$instance = Singleton::getInstance();<br>$instance-&gt;testEcho();<br>$instance1 = Singleton::getInstance();<br>$instance2 = Singleton::getInstance();<br><br>","like_count":2,"discussions":[{"author":{"id":1220617,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a0/09/4af6ff52.jpg","nickname":"Six","note":"","ucode":"E297BB638B2BD9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":214559,"discussion_content":"兄弟，这样做是有好处的，方便扩展和复用(这个复用就是定义一个接受Animal参数的方法或者类)，好好理解下作者多态中举的例子","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585208131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1087243,"avatar":"https://static001.geekbang.org/account/avatar/00/10/97/0b/a943bcb3.jpg","nickname":"zhou","note":"","ucode":"E1CE8575B3F106","race_medal":3,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":52894,"discussion_content":"你想想Spring的依赖注入，你根本不用考虑接口怎么实现的，你调用只用使用接口调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1574090806,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177867,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1581517937,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"10171452529","product_id":100039001,"comment_content":"总感觉枚举的实现方式没理解透彻，是不是这个本章例子比较特殊啊。<br>如果要返回的单例对象就是SingletonEnum对象，怎么用枚举的方式实现呢？求code。","like_count":2,"discussions":[{"author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179971,"discussion_content":"枚举本质就是static的，即在java的运行时环境中没有枚举的概念，枚举只停留在编译阶段，换句话说，枚举类在经过编译之后是以static的方式存在的，所以，枚举方法可以理解为静态方法，多一种创建单例的方法","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582267247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394542,"discussion_content":"枚举类，编译后，就是一个final修饰的类，而里边的方法，自然都是同一个对象在调用，所以就实现了单例效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631931704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118242,"avatar":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","nickname":"改名不换人","note":"","ucode":"7E25577829FA0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263056,"discussion_content":"个人理解，返回单例对象的目的就是要调用这个对象的方法，所以Enum.INSTANCE.getId()就是我们要做的事儿.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589167661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054178,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/e2/c21553c4.jpg","nickname":"HYM","note":"","ucode":"4E82D9A285DAFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175968,"discussion_content":"enum SingletonEnum{INSTANCE}=====>调用：SingletonEnum.INSTANCE","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582010121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175830,"user_name":"Summer  空城","can_delete":false,"product_type":"c1","uid":1337146,"ip_address":"","ucode":"6BDBB70FB6F709","user_header":"https://static001.geekbang.org/account/avatar/00/14/67/3a/0dd9ea02.jpg","comment_is_top":false,"comment_ctime":1580865241,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10170799833","product_id":100039001,"comment_content":"王老师这篇讲解的非常棒，赞！","like_count":2},{"had_liked":false,"id":319158,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1635646739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5930614035","product_id":100039001,"comment_content":"1、为什么要使用单例？<br>\t实战案例一：处理资源冲突-类级别锁 分布式锁 并发队列 单例模式<br>\t实战案例二：表示全局唯一类-从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。<br>2、如何实现一个单例？<br>\t1. 饿汉式-类加载时创建instance 静态实例，线程安全，不支持延迟加载<br>\t2. 懒汉式-使用时创建实例，公有方法加大锁synchronzed，并发度低，频繁使用实例会有性能瓶颈<br>\t3. 双重检测-既支持延迟加载、又支持高并发，公有方法内synchronzed设为类级别锁<br>\t\t\t\t-低版本JDK会因为指令重排序出问题，instance 成员变量加上 volatile 关键字，禁止指令重排序才行，高版本JDk已解决（不知哪个版本，方法是对象new和初始化设计为原子操作）<br>\t4. 静态内部类-类似饿汉式，但又能做到了延迟加载<br>\t\t\t\t-外部类加载时并不会创建内部类实例，只有调用getInstance()才会加载<br>\t5. 枚举-最简单的实现方式","like_count":1},{"had_liked":false,"id":314640,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1633272279,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5928239575","product_id":100039001,"comment_content":"业务类基本都是单例模式，防止重复创建，节省资源","like_count":1},{"had_liked":false,"id":296300,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","comment_is_top":false,"comment_ctime":1622890640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5917857936","product_id":100039001,"comment_content":"不错,有些微信公众号以技术文章开始,却以八卦杂文结束,可悲!","like_count":1},{"had_liked":false,"id":241872,"user_name":"Promise°","can_delete":false,"product_type":"c1","uid":1139384,"ip_address":"","ucode":"0BFDBDAD852D6D","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/b8/bb9657c6.jpg","comment_is_top":false,"comment_ctime":1597480121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892447417","product_id":100039001,"comment_content":"在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？<br>单例的:springmvc 多例的:status2<br>springmvc的参数都是在方法参数上面的所以是单例即可 用多例的话没必要也影响性能的开销<br>status2的参数是在类上面的 所以必须是多例的 不然的话并发的情况下获取到的数据 就会不一致","like_count":1},{"had_liked":false,"id":234271,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1594632530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889599826","product_id":100039001,"comment_content":"<br>单例模式相对于类级别锁的好处是，不用创建那么多 Logger 对象(只用再开始的时候创建一次，类似饿汉，其它的地方就可以直接通过别名来拿)，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。<br>单例的注意的地方<br>1.函数要是private ，省的其它人去new 出来<br>2.考虑创建时候的线程安全问题<br>3.考虑是否要延迟加载<br>4.考虑getInstance()的时候是否特别耗内存。<br><br>饿汉的好处：在类加载的时候就已经创建了对象，所以是线程安全的(不会导致a创建一下，b创建一下)。缺点也是这个。<br>如果是实例化时间较长，则还是建议用饿汉，因为是将这些操作提前到程序启动加载类的时候就执行，而不是像懒汉一样把这个重的操作放到用的时候才执行。<br>有问题要早点暴露(fail-fast原则) 早发现，早修复。<br><br>懒汉的好处:用的时候才加载，避免掉创建一些没用的对象。<br>缺点是 你每次准备实例化的时候 为了线程安全，都应该加把锁，确保判空和new 是在同一个操作里面。因为考虑了线程安全，所以每次加锁放锁都要消耗资源，，如果大量调用，性能可能有点问题。其实就是不支持高并发<br> if (instance == null) {      <br>instance = new IdGenerator();    <br>}<br><br>双重检测其实很简单，就是先判断有没有被实例化，如果有，在加锁再判断一次然后实例化。当然缺点就是多了层判断，消耗了内存(虽然看起来消耗小，但是堆起来就多了，不过因为对象只会生成一次，也不会消耗很多)<br><br>&#47;&#47; 先判断有没有<br>if (instance == null) {<br>   synchronized (IdGenerator.class) { &#47;&#47; 没有的话直接对类加锁<br>      &#47;&#47;  <br>      if (instance == null) {&#47;&#47; 再判断有没有，原子操作<br>         instance = new IdGenerator();<br>      }<br>   }<br>}<br><br><br>静态内部类实现的原理，就是调用静态的方法来final赋值，因为是静态方法的静态内部类，所以只会在调用这个静态方法的时候才创建，因为静态方法只会执行一次。。。。<br><br>private static class SingletonHolder {<br>   private static final IdGenerator instance = new IdGenerator();<br>}<br><br><br><br>枚举类型实现单例：<br>根据不同的枚举入参，获取不同的实例对象<br>public class SimpleTest {<br>   public static void main (String[] args) {<br>      SimpleTest instanceInstance = EnumTest.INSTANCE.getTask(EnumTest.INSTANCE);<br>      System.out.println(&quot;&quot;);<br>   }<br>   <br>   private enum EnumTest {<br>      INSTANCE() {<br>         @Override<br>         public SimpleTest getTask (Object o) {<br>            return new SimpleTest();<br>         }<br>      }, WDDTEST() {<br>         @Override<br>         public SimpleTest getTask (Object o) {<br>            &#47;&#47; 另一种生成<br>            return new SimpleTest();<br>         }<br>      };<br>      <br>      public SimpleTest getTask (Object o) {<br>         return null;<br>      }<br>      <br>   }<br>   <br>}<br><br>针对静态内部类和枚举类型的，因为是直接调用某个类然后赋值给引用，只生成一个对象，不用考虑线程安全的问题，所以不用先判断是不是null。<br><br>","like_count":1},{"had_liked":false,"id":233850,"user_name":"skying","can_delete":false,"product_type":"c1","uid":1041865,"ip_address":"","ucode":"E7CFF50AB64BB1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","comment_is_top":false,"comment_ctime":1594477829,"is_pvip":true,"replies":[{"id":"86363","content":"比较难模拟出来的，因为毕竟要并发极端情况下（有竞争的情况下，就像我画的那张图一样）才会发生覆盖的情况。我的样例都在文章里了。","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594598886,"ip_address":"","comment_id":233850,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5889445125","product_id":100039001,"comment_content":"争哥，你好！<br>我这边想模拟出 你文章中 的Logger类写入文件会重复的场景。<br>但没复现出来，<br>不知道你这边有 样例代码没有。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501187,"discussion_content":"比较难模拟出来的，因为毕竟要并发极端情况下（有竞争的情况下，就像我画的那张图一样）才会发生覆盖的情况。我的样例都在文章里了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594598886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1222119,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/e7/815acbf7.jpg","nickname":"warm_day","note":"","ucode":"3CD078E809497C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579945,"discussion_content":"太难模拟了，根本没法模拟出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657782695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225690,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591835427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886802723","product_id":100039001,"comment_content":"synchronized(this) 对象级别锁、synchronized(loger.class) 类级别锁。","like_count":1},{"had_liked":false,"id":224861,"user_name":"西柚","can_delete":false,"product_type":"c1","uid":1306889,"ip_address":"","ucode":"3DDC5D0972DAB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/09/a597fe8d.jpg","comment_is_top":false,"comment_ctime":1591578657,"is_pvip":false,"replies":[{"id":"84001","content":"信小争哥就对了","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1592526807,"ip_address":"","comment_id":224861,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5886545953","product_id":100039001,"comment_content":"老师讲的太好了，逻辑清晰、缜密。思考问题的方式非常值得学习~","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497634,"discussion_content":"信小争哥就对了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592526807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219370,"user_name":"somenzz","can_delete":false,"product_type":"c1","uid":1187197,"ip_address":"","ucode":"EA59A170DF8910","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","comment_is_top":false,"comment_ctime":1590019748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884987044","product_id":100039001,"comment_content":"Python实现单例类：<br><br>class Single(object):<br>    _instance = None<br>    def __new__(cls, *args, **kw):<br>        if cls._instance is None:<br>            cls._instance = object.__new__(cls, *args, **kw)<br>        return cls._instance<br>    def __init__(self):<br>        pass<br><br>single1 = Single()<br>single2 = Single()<br>print(id(single1) == id(single2)) # True<br><br>","like_count":1},{"had_liked":false,"id":191969,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1584806606,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879773902","product_id":100039001,"comment_content":"一直对Java的枚举类型不清楚","like_count":1,"discussions":[{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394543,"discussion_content":"枚举就是一个语法糖，编译后，其实就是一个final修饰的class类，提供了一些默认方法，具体可以通过javap -verbose  XXEnum.class  查看旧明白了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631931820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178619,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1581760308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876727604","product_id":100039001,"comment_content":"1、java.lang.reflect.Proxy类。因为代理是通用的类代理，对所有类进行增强，一个实例就够了。<br>java.lang.Runtime类，每个Java应用程序都有一个Runtime类的实例，该实例允许该应用程序与应用程序运行所在的环境进行交互。一个java应用程序对应一个环境。所以设计成单例<br>2、使用将FileWriter对象作为静态成员变量来使用。<br><br>老师没讲到序列化和反射可以破坏单例的情况。有兴趣可以研究下","like_count":1},{"had_liked":false,"id":176969,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1581238522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876205818","product_id":100039001,"comment_content":"打卡<br>1、单例模式的定义：<br>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。<br>2、单例的用途：<br>1）处理资源访问冲突问题<br>2）处理数据在系统中只应保存一份<br>3、如何实现一个单例类<br>1）饿汉模式<br>类加载时，instance实例已经创建好；<br>2）懒汉模式<br>延迟加载，但是getInstance需要加锁，导致并发度很低<br>public static synchronized IdGenerator getInstance() { <br>if (instance == null) {<br>instance = new IdGenerator(); <br>} <br>return instance;<br> }<br>3）双重检测<br>只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。<br>（支持延迟加载、支持高并发）<br>public static IdGenerator getInstance() {<br> if (instance == null) { <br>synchronized(IdGenerator.class) { &#47;&#47; 此处为类级别的锁 <br>if (instance == null) {<br> instance = new IdGenerator(); <br>} <br>} <br>} <br>return instance;<br> }<br>4）静态内部类<br>insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。<br>private static class SingletonHolder{ <br>private static final IdGenerator instance = new IdGenerator(); <br>} <br>public static IdGenerator getInstance() {<br>return SingletonHolder.instance;<br> }<br>5）枚举<br><br>","like_count":1},{"had_liked":false,"id":176353,"user_name":"天天向上卡索","can_delete":false,"product_type":"c1","uid":1009850,"ip_address":"","ucode":"E3724C3B39BD3F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/68/ba/c0cf8bf3.jpg","comment_is_top":false,"comment_ctime":1581040739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876008035","product_id":100039001,"comment_content":"之前做WP开发的时候用到的硬件如Camera大多是单例，之前看微软的源码有的单例使用并发字典来实现的","like_count":1},{"had_liked":false,"id":176167,"user_name":"沈康","can_delete":false,"product_type":"c1","uid":1611025,"ip_address":"","ucode":"02AFA50738AB8E","user_header":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","comment_is_top":false,"comment_ctime":1580977448,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5875944744","product_id":100039001,"comment_content":"1、java bean大部分都是单例吧，例如我们的service bean，单例也是为了复用类和资源共享吧，但是要注意单例需要无状态，有状态的则要考虑线程安全问题<br>2、如果线程安全的话，共享一个类就可以了，依赖注入","like_count":1,"discussions":[{"author":{"id":1501385,"avatar":"https://static001.geekbang.org/account/avatar/00/16/e8/c9/59bcd490.jpg","nickname":"听水的湖","note":"","ucode":"B1759F90165D81","race_medal":0,"user_type":8,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":522018,"discussion_content":"你好，专栏是图文+音频哦，没有视频。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1623919851,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":1}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175820,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1580839344,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5875806640","product_id":100039001,"comment_content":"不同线程的日志写到不同的文件，就不用担心线程安全了。例如用线程id做日志后缀。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510006,"discussion_content":"嗯呢 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357831,"user_name":"Fitch Kuma","can_delete":false,"product_type":"c1","uid":1318028,"ip_address":"广东","ucode":"9783C3D4873020","user_header":"https://static001.geekbang.org/account/avatar/00/14/1c/8c/3af20a8e.jpg","comment_is_top":false,"comment_ctime":1663668764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663668764","product_id":100039001,"comment_content":"请问这个课程有配套的代码仓库么？","like_count":0},{"had_liked":false,"id":351428,"user_name":"warm_day","can_delete":false,"product_type":"c1","uid":1222119,"ip_address":"","ucode":"3CD078E809497C","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/e7/815acbf7.jpg","comment_is_top":false,"comment_ctime":1657782735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657782735","product_id":100039001,"comment_content":"模拟ogger多线程下写入覆盖问题，太难模拟了，模拟不出来","like_count":0},{"had_liked":false,"id":347036,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1653635901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653635901","product_id":100039001,"comment_content":"说到日志这一块，slf4j这块其实是最后放到一个队列里面去，这种其实也能做到一个不会被覆盖的一个问题。","like_count":0},{"had_liked":false,"id":344187,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1651332381,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1651332381","product_id":100039001,"comment_content":"单例模式模式有作用呢？","like_count":0},{"had_liked":false,"id":336967,"user_name":"疯狂的石头","can_delete":false,"product_type":"c1","uid":1763900,"ip_address":"","ucode":"65CE6EB494FDCA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ea/3c/24cb4bde.jpg","comment_is_top":false,"comment_ctime":1646495543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646495543","product_id":100039001,"comment_content":"怎么看不到评论","like_count":0},{"had_liked":false,"id":334505,"user_name":"℡ __ 柚稚","can_delete":false,"product_type":"c1","uid":1740282,"ip_address":"","ucode":"07A8CBFC563C5E","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8d/fa/93e48f3b.jpg","comment_is_top":false,"comment_ctime":1644980102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644980102","product_id":100039001,"comment_content":"争哥，我有个疑问，上面id生成的类使用单例保证id唯一，现实中一个服务基本都会在多台机器上部署多个实例，这样的话单例的作用是不是就失效了","like_count":0},{"had_liked":false,"id":328504,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1640756540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640756540","product_id":100039001,"comment_content":"枚举是提前加载还是延后加载？","like_count":0},{"had_liked":false,"id":326860,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1639724785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639724785","product_id":100039001,"comment_content":"问题二. 系统级别 OS_APPEND","like_count":0},{"had_liked":false,"id":312662,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1631932945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631932945","product_id":100039001,"comment_content":"看完本文有三点收获：<br>1.单例模式有多种实现方式，每种方式各有优缺点，时间与内存的权衡，要求快（饿汉模式），内存比较宝贵，那就采用懒汉模式。不同方式，有基本实现和改进后实现方式。<br>2.线程安全保证方面，需要添加对象锁，以及volatile关键字<br>3.以上准则，其本质是JVM的原理导致：比如基于类的加载机制，静态内部类实现方式才行得通。<br>  volatile在JVM层面的语义保证了禁止指令优化重排，synchronized关键字对应的jvm指令监控，才保证了锁的实现，枚举类编译后是一个final修饰的class，才让看似奇怪的枚举也可以实现单例。","like_count":0},{"had_liked":false,"id":307003,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1628822519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628822519","product_id":100039001,"comment_content":"&#47;**<br> * 单例模式懒汉式实现<br> *&#47;<br>class Singleton {<br>private:<br>    Singleton() {} &#47;&#47;构造函数私有<br>public:<br>    static Singleton&amp; getInstance() {<br>        static Singleton instance;<br>        return instance;<br>    }<br>};<br><br>c++11后是线程安全的，C++11规定了local static在多线程条件下的初始化行为，要求编译器保证了内部静态变量的线程安全性。<br><br>那争哥，在c++11后，这种懒汉式的实现方式是不是更好呢？","like_count":0},{"had_liked":false,"id":306995,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1628820692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628820692","product_id":100039001,"comment_content":"c++ iostream设置为单例，因为io资源只有一份","like_count":0},{"had_liked":false,"id":305063,"user_name":"乔帆 Kayla","can_delete":false,"product_type":"c1","uid":1883514,"ip_address":"","ucode":"81944832230BC4","user_header":"https://static001.geekbang.org/account/avatar/00/1c/bd/7a/37df606b.jpg","comment_is_top":false,"comment_ctime":1627797555,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1627797555","product_id":100039001,"comment_content":"双重检测的代码中，变量instance没有使用final修饰，是因为volatile不可以修饰使用final的实例变量或静态变量吗？","like_count":0,"discussions":[{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394548,"discussion_content":"final修饰的变量，必须初始化，而这里是在调用getInstance方法才初始化，所以不能加final，代码贴进去，就报红了，编译都通不过","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631932226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292672,"user_name":"Nacol","can_delete":false,"product_type":"c1","uid":1609735,"ip_address":"","ucode":"B645ECB9540B95","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/07/41d19261.jpg","comment_is_top":false,"comment_ctime":1620917210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620917210","product_id":100039001,"comment_content":"争哥，<br>Java 自然实现了枚举的单例模式，<br>但是我在 JDK1.8 下排查 GC 问题的时候，<br>使用 jmap -histo pid 命令 dump 下了堆内存，<br>发现其中一个枚举的数量是 89个，请帮忙解惑。<br>","like_count":0},{"had_liked":false,"id":292247,"user_name":"cccy七里十一","can_delete":false,"product_type":"c1","uid":1963604,"ip_address":"","ucode":"38858D844ECC72","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f6/54/bf649b32.jpg","comment_is_top":false,"comment_ctime":1620737996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620737996","product_id":100039001,"comment_content":"ma两个要后续了解的内容：<br>1. 静态内部类相关<br>2.枚举","like_count":0},{"had_liked":false,"id":289066,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1940562,"ip_address":"","ucode":"67C86E09BA6E4B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9c/52/dc770378.jpg","comment_is_top":false,"comment_ctime":1618840184,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1618840184","product_id":100039001,"comment_content":"很少写代码，惭愧。就想问一下，在java里实现单例类典型的关键字是private static final，对吗？","like_count":0,"discussions":[{"author":{"id":1079657,"avatar":"https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg","nickname":"王智","note":"","ucode":"0335277F255F7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390305,"discussion_content":"理解每一个关键字的含义就好：static表示类成员变量，final表示的是对象本身不可变","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629770954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288047,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1618280692,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618280692","product_id":100039001,"comment_content":"1、Java jdk中的Runtime类设计为单例，每个应用应该只有一个运行时对象<br>2、由于FileWriter内部实现了对象级别的线程安全，只需所有Logger对象共用一个FileWriter对象即可，private static final FileWriter writer = new FileWriter(file, true);","like_count":0},{"had_liked":false,"id":281694,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1614849521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614849521","product_id":100039001,"comment_content":"在php语言中，是单线程模式的，不需要考虑线程安全的问题","like_count":0},{"had_liked":false,"id":271499,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1609667402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609667402","product_id":100039001,"comment_content":"单例模式:懒汉式，饿汉式，双重检测，静态内部类，以及枚举方式。","like_count":0},{"had_liked":false,"id":271376,"user_name":"乐多🙉","can_delete":false,"product_type":"c1","uid":2346451,"ip_address":"","ucode":"AE515FFF1CA582","user_header":"https://static001.geekbang.org/account/avatar/00/23/cd/d3/7e4d80e8.jpg","comment_is_top":false,"comment_ctime":1609583054,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1609583054","product_id":100039001,"comment_content":"public class DCSingleton {<br>    private static DCSingleton dCSingleton;<br><br>    private DCSingleton() {<br>    }<br><br>    public static DCSingleton getInstance() {<br>        if (null == dCSingleton) {<br>            synchronized (DCSingleton.class) {<br>                if (null == dCSingleton) {<br>                    &#47;&#47;todo 不懂这样是否是原子操作<br>                    AtomicReference&lt;DCSingleton&gt; atomicReference = new AtomicReference&lt;DCSingleton&gt;();<br>                    atomicReference.set(new DCSingleton());<br>                    dCSingleton = atomicReference.get();<br>                }<br>            }<br>        }<br>        return dCSingleton;<br>    }<br>}<br><br>&#47;&#47;todo 不懂这样是否是原子操作<br>&#47;&#47;todo 不懂这样是否是原子操作<br>&#47;&#47;todo 不懂这样是否是原子操作<br>","like_count":0,"discussions":[{"author":{"id":1336634,"avatar":"https://static001.geekbang.org/account/avatar/00/14/65/3a/bc801fb2.jpg","nickname":"mqray","note":"","ucode":"15664507AD7033","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343247,"discussion_content":"还是规范命名比较好 不然容易被喷\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610973291,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2398990,"avatar":"https://static001.geekbang.org/account/avatar/00/24/9b/0e/405ea9c0.jpg","nickname":"忘忘不念。","note":"","ucode":"E365644F14802E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":341230,"discussion_content":"基于双重检测模式使用Atomic类引用实现的单例模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1610357264,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271217,"user_name":"daiwf","can_delete":false,"product_type":"c1","uid":1793425,"ip_address":"","ucode":"2C78451F5488BD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5d/91/9b6fb4ad.jpg","comment_is_top":false,"comment_ctime":1609475961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609475961","product_id":100039001,"comment_content":"大佬就是大佬，让我很清晰的理解了单例模式！看这系列的教程就如同看一本武功秘籍。我已经迫不及待继续修炼了。","like_count":0},{"had_liked":false,"id":270709,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1609225585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609225585","product_id":100039001,"comment_content":"这里说一下延迟加载这个东西，其实就是真正用的时候再去加载对应的对象，而不是一开始就加载上去。<br>原因：内存有限，对象过大，都会导致直接加载的话，对内存有影响或者影响效率<br>解决：啥时候用我再加载，那啥时候用呢，那就是getInstance()的时候，去new一个对象出来","like_count":0},{"had_liked":false,"id":268083,"user_name":"海鸟","can_delete":false,"product_type":"c1","uid":1028311,"ip_address":"","ucode":"EBAF85D1EFFAAB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b0/d7/22ce0046.jpg","comment_is_top":false,"comment_ctime":1608047029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608047029","product_id":100039001,"comment_content":"我记得 Linux 下多进程（线程）操作同一个文件，如果用 append mode 写的话，不会相互覆盖吧","like_count":0},{"had_liked":false,"id":266611,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1607414705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607414705","product_id":100039001,"comment_content":"打完：用java实现了文中代码案例。","like_count":0},{"had_liked":false,"id":264094,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1606352189,"is_pvip":true,"replies":[{"id":"96082","content":"嗯嗯 ������","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1606700667,"ip_address":"","comment_id":264094,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1606352189","product_id":100039001,"comment_content":"1. Spring中的一些连接工厂类，Service类都默认是单例模式 这些对象是一般消耗资源或者类似于工具类没有共享变量竞争问题。<br>2. FileWritter设计成 static final的可以使用jvm类加载特性解决竞争问题。但是可测试性变差","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":510419,"discussion_content":"嗯嗯 ������","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1606700667,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260586,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1300285,"ip_address":"","ucode":"A99C9C890F95E4","user_header":"https://static001.geekbang.org/account/avatar/00/13/d7/3d/a076faf1.jpg","comment_is_top":false,"comment_ctime":1605065883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605065883","product_id":100039001,"comment_content":"public class IdGenerator {<br>    private static volatile IdGenerator instance;<br><br>    public static IdGenerator getInstance() {<br>        &#47;**<br>         * 1.使用局部变量localRef将减少访问volatile变量的次数，也就减少了访问主存的次数，提升性能<br>         * 如果不使用localRef，那么当不为null的时候将不得不访问volatile变量两次，一次是在检查null，另一次是在方法返回时；<br>         *&#47;<br>        IdGenerator localRef = instance;<br>        if (null == localRef) {<br>            synchronized (IdGenerator.class) {<br>                &#47;**<br>                 * 2.在获得锁后，刷新局部变量为最新值，因为此时volatile变量可能已经更改<br>                 *&#47;<br>                localRef = instance;<br>                if (null == localRef) {<br>                    instance = localRef = new IdGenerator();<br>                }<br>            }<br>        }<br>        &#47;**<br>         * 3.在方法返回时访问volatile变量<br>         *&#47;<br>        return localRef;<br>    }<br>}<br><br>参考链接：<br>https:&#47;&#47;www.javacodemonk.com&#47;threadsafe-singleton-design-pattern-java-806ad7e6","like_count":0},{"had_liked":false,"id":257384,"user_name":"天马行空","can_delete":false,"product_type":"c1","uid":1740810,"ip_address":"","ucode":"5B019ABAFD1716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/90/0a/4d161db0.jpg","comment_is_top":false,"comment_ctime":1603952669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603952669","product_id":100039001,"comment_content":"每一章的内容都是精华所在，争哥造诣很高啊","like_count":0},{"had_liked":false,"id":254762,"user_name":"Charles | 姜海龙","can_delete":false,"product_type":"c1","uid":1178235,"ip_address":"","ucode":"17BA74D1684184","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7b/f89a398b.jpg","comment_is_top":false,"comment_ctime":1603183055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603183055","product_id":100039001,"comment_content":"日记：1.单列模式----一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。","like_count":0},{"had_liked":false,"id":247355,"user_name":"Evan","can_delete":false,"product_type":"c1","uid":1344281,"ip_address":"","ucode":"B877ABD0CF4661","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","comment_is_top":false,"comment_ctime":1599666840,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1599666840","product_id":100039001,"comment_content":"五个方式创建单例，最近就是枚举，静态也非常简单。类型加载也是单例，连接器之类是单例模式<br><br>另外关于CPU指令重排的问题，王宝令讲得很清楚，不知道目前JVM是否已经优化过了？","like_count":0},{"had_liked":false,"id":238281,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1596110312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596110312","product_id":100039001,"comment_content":"打卡41","like_count":0},{"had_liked":false,"id":237505,"user_name":"Geek_9e4d78","can_delete":false,"product_type":"c1","uid":2083243,"ip_address":"","ucode":"F4FFBC06B1ABA3","user_header":"","comment_is_top":false,"comment_ctime":1595848973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595848973","product_id":100039001,"comment_content":"<br>双重检查锁那里有个bug，单例引用应该用volatile修饰，否则在并发时，某个请求会去到一个没有实例化完的对象","like_count":0},{"had_liked":false,"id":235505,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1595067124,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595067124","product_id":100039001,"comment_content":"在unity里做项目用到的第一个设计模式就是单例模式，各种全局性质的manager，比如负责统计比分胜负的gameManager， 负责玩家信息和控制的playermanager&#47;controller， unity编程的特性导致类已经在场景里实例化为组件，但是代码里仍然有先判断 Instance==null然后再return currentObject为instance，所以应该能划归到双重检测模式吧。<br>","like_count":1},{"had_liked":false,"id":231822,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1593779961,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593779961","product_id":100039001,"comment_content":"【设计模式39】20200703<br>今天开始讲单例模式了，和网上讲单例最大的区别是从三个方面讲了单例模式：为什么使用单例模式？怎么实现？实现有哪些问题？怎么优化？这里重点要清楚什么场景使用？一定是全剧唯一的实例才使用。另外单例模式最常会遇到的问题是双重检查锁会有问题？主要问题在于无法应对高并发的场景，那么最简单的方法自然是加锁但是加锁因为指令重排序也会有问题，但是对于jdk8之后的版本是没有这个问题的，因为只需要把创建和加载变为一个原子操作即可。但是实现总归不够优雅，匿名内部类和枚举是更简洁的实现，看过jdk源码的应该知道实现方式是枚举。","like_count":0},{"had_liked":false,"id":231448,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1593678803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593678803","product_id":100039001,"comment_content":"细节注意点：单例解决冲突问题的时候，还得依赖比如FileWriter 是对象级别线程安全的","like_count":0},{"had_liked":false,"id":231105,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1593583939,"is_pvip":false,"replies":[{"id":"86254","content":"我建议你去看下极客的并发专栏😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594388254,"ip_address":"","comment_id":231105,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1593583939","product_id":100039001,"comment_content":"其实有一点不太理解，希望老师解答。<br>双层检查，加volatile，根据java内存模型，volatile保证的是可见性，也就是说，给变量赋值的操作，会被另一线程看到，这样，另一线程拿到的还是地址，这时候，内存一定初始化完成了吗？<br>是不是可以理解为，这个volatile 的写操作 happen-before 与后续的读操作，就相当于是，从语言层面考虑，而不是指令层面的。<br>如果从指令层面考虑，这个new操作，会有三条指令，赋值完成就相当与写操作完成，对象还没初始化完成，这时候别的线程读到还没初始化的地址值会报空指针异常；<br>如果从语言层面考虑，这个new语句，相当于写操作完成，就代表这个操作对应的所有指令都完成了，所以后续能读到已经初始化的值。<br>这个happen-before规则是从语言层面考虑还是指令层面？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493410,"discussion_content":"kitty也可以是一个子类呀 不一定是实例","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588129770,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1478055,"avatar":"https://static001.geekbang.org/account/avatar/00/16/8d/a7/2176bbc5.jpg","nickname":"Giacomo","note":"","ucode":"BE5B1E68BCDBB3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":271811,"discussion_content":"不是啊，我这里的kitty是一只猫的名字。\n而且，如果说想表达子类的关系我们会说，\na Kitty is a Cat\n或者\nKitty is Cat","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590197567,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226506,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1592124710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592124710","product_id":100039001,"comment_content":"static 修饰writer，解决并发问题","like_count":0},{"had_liked":false,"id":225688,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591835254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591835254","product_id":100039001,"comment_content":"对象级别、类级别，对象锁、类锁！","like_count":0},{"had_liked":false,"id":225596,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1591797747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591797747","product_id":100039001,"comment_content":"这是什么意思？相当于文件引用？？ FileWriter  writer？？<br><br>文件句柄也是一种资源，不能随便浪费）","like_count":0},{"had_liked":false,"id":218787,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1589875376,"is_pvip":false,"replies":[{"id":"86257","content":"好像jdk5之后就解决了，我有点记不清了😂","user_name":"作者回复","user_name_real":"王争","uid":"1190123","ctime":1594388592,"ip_address":"","comment_id":218787,"utype":1}],"discussion_count":7,"race_medal":0,"score":"1589875376","product_id":100039001,"comment_content":"我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。<br><br>老师，请问是哪个版本解决了这个问题呢?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492667,"discussion_content":"嗯嗯 你说的没错 有些资料会区分 静态和动态 静态是重载","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588129957,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":218698,"user_name":"荒川之主","can_delete":false,"product_type":"c1","uid":2000330,"ip_address":"","ucode":"12724B4B37BEB5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/85/ca/e6003d08.jpg","comment_is_top":false,"comment_ctime":1589856338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589856338","product_id":100039001,"comment_content":"对单例的总结非常全面！","like_count":0},{"had_liked":false,"id":216012,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1589167721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589167721","product_id":100039001,"comment_content":"专栏内容和评论 质量齐飞！！收获满满~ ","like_count":0},{"had_liked":false,"id":206500,"user_name":"👅","can_delete":false,"product_type":"c1","uid":1335335,"ip_address":"","ucode":"3A3198E899DC6A","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/27/fcc46413.jpg","comment_is_top":false,"comment_ctime":1586870476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586870476","product_id":100039001,"comment_content":"第一个问题，安卓中的application类是单例的，因为它需要承载承载整个App的生命周期。<br>第二个问题，我自己只想到了队列。","like_count":0},{"had_liked":false,"id":205786,"user_name":"王      慈","can_delete":false,"product_type":"c1","uid":1298139,"ip_address":"","ucode":"EACC3D086674D8","user_header":"https://static001.geekbang.org/account/avatar/00/13/ce/db/bb1821b3.jpg","comment_is_top":false,"comment_ctime":1586739445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586739445","product_id":100039001,"comment_content":"第一反应最简单的办法不应该是依赖注入嘛。。。","like_count":0},{"had_liked":false,"id":204451,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1586401921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586401921","product_id":100039001,"comment_content":"单例模式： 一个类只能被实例化一次。<br><br>作用：解决有些数据只需要一份，不需要多份。<br><br><br>前端最多人用的 VUE 框架，里面有一个 vuex 数据管理，实例化 vuex 的时候，就用到了单例模式，因为只能实例化一个 vuex,通过 vuex 来管理组件的数据。如果不适用单例模式，会导致创建多个 vuex 实例，数据混乱，就起不到管理数据的功能了<br>","like_count":0},{"had_liked":false,"id":200456,"user_name":"SunshineBoy","can_delete":false,"product_type":"c1","uid":1160644,"ip_address":"","ucode":"FC54CD1815CCBA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/c4/9148b40d.jpg","comment_is_top":false,"comment_ctime":1585587861,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585587861","product_id":100039001,"comment_content":"filewritter有个参数 true表示追加写入，false表示等待，如果加一个CAS操作，是不是也可以避免覆盖？","like_count":0},{"had_liked":false,"id":199642,"user_name":"@%初%@","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1585493051,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1585493051","product_id":100039001,"comment_content":"上述的单例实现还是存在问题，如果利用反射技术，是可以创建两个不同的对象，，，解决方法就是在私有化构造器里面加判断，若对象已经不为空了，就抛个异常。。。。。","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268079,"discussion_content":"所以推荐使用最后一种枚举的方式实现单例。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589726413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198684,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585463821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585463821","product_id":100039001,"comment_content":"我理解那个静态内部类应该就是利用了静态内部类的延迟加载以及一个静态对象只会初始化一份的Jvm保证来同时达到饿汉不加锁和懒汉延迟初始化的优势的","like_count":0},{"had_liked":false,"id":198681,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585463681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585463681","product_id":100039001,"comment_content":"静态内部类跟枚举类型属于知识盲点，回去翻书去","like_count":0},{"had_liked":false,"id":198485,"user_name":"Bruce","can_delete":false,"product_type":"c1","uid":1876764,"ip_address":"","ucode":"BAD602A7270306","user_header":"https://static001.geekbang.org/account/avatar/00/1c/a3/1c/f947dd97.jpg","comment_is_top":false,"comment_ctime":1585453372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585453372","product_id":100039001,"comment_content":"打卡，终于搞明白了什么是单例","like_count":0},{"had_liked":false,"id":198146,"user_name":"zhangchao","can_delete":false,"product_type":"c1","uid":1508339,"ip_address":"","ucode":"E665D153A85DE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/f3/0bd094ad.jpg","comment_is_top":false,"comment_ctime":1585412140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585412140","product_id":100039001,"comment_content":"单例也不简单啊","like_count":0},{"had_liked":false,"id":187365,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1584091708,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584091708","product_id":100039001,"comment_content":"静态内部类：<br>public class IdGenerator { private AtomicLong id = new AtomicLong(0); private IdGenerator() {} private static class SingletonHolder{ private static final IdGenerator instance = new IdGenerator(); } public static IdGenerator getInstance() { return SingletonHolder.instance; } public long getId() { return id.incrementAndGet(); }}<br><br><br><br><br>如果把这行private static final IdGenerator instance = new IdGenerator();中的final去掉，就不是线程安全了吧？？","like_count":0,"discussions":[{"author":{"id":1602420,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/74/3bf4b74e.jpg","nickname":"阿德","note":"","ucode":"186D5E19E3CB6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281179,"discussion_content":"我觉得去掉final没有问题呀，因为是private，所以除了自己和外部类，没有谁能够修改了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591687418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187262,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1584070195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584070195","product_id":100039001,"comment_content":"对象级别锁和类级别锁：<br><br>对象级别的锁：在一个对象下，不同的线程访问该对象的某个方法，会强制按照顺序执行。<br>类别的锁：在类下的所有对象下，不同的线程访问该对象的某个方法，会强制按照顺序执行。","like_count":0},{"had_liked":false,"id":187261,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1584070165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584070165","product_id":100039001,"comment_content":"1.mysql 数据库连接 单利<br><br>2.没想到<br><br>","like_count":0},{"had_liked":false,"id":186776,"user_name":"麦芽科技学堂","can_delete":false,"product_type":"c1","uid":1742968,"ip_address":"","ucode":"A90DDE4B6696BE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/98/78/6459e29e.jpg","comment_is_top":false,"comment_ctime":1583921804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583921804","product_id":100039001,"comment_content":"枚举类的单例模式没看懂，应该怎么用呢","like_count":0},{"had_liked":false,"id":186563,"user_name":"耿耿","can_delete":false,"product_type":"c1","uid":1817461,"ip_address":"","ucode":"37084BB64BAA94","user_header":"https://static001.geekbang.org/account/avatar/00/1b/bb/75/a62eca9b.jpg","comment_is_top":false,"comment_ctime":1583884473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583884473","product_id":100039001,"comment_content":"1、.NET类库中存在单例模式的实现类，不过该类不是公开的，该类具体存在于System.dll程序集，命名空间为System；<br>2、生产者消费者","like_count":0},{"had_liked":false,"id":185955,"user_name":"一区","can_delete":false,"product_type":"c1","uid":1793770,"ip_address":"","ucode":"B5142A6276E490","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a2mRI7BYncHCL6QWfibe7g7MWc70fSsqQibu7o9PcHjicYwo5dSnAoUN75HDDRz4GXWJdpWw59yJsMwFv3t7zSiaJQ/132","comment_is_top":false,"comment_ctime":1583730861,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583730861","product_id":100039001,"comment_content":"老师好，请问关于高版本java已经优化解决了指令重排的问题这个咨询，是在哪里看到的啊？","like_count":0,"discussions":[{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206847,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584449644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185664,"user_name":"否极泰来","can_delete":false,"product_type":"c1","uid":1439355,"ip_address":"","ucode":"C249173266251A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","comment_is_top":false,"comment_ctime":1583658257,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1583658257","product_id":100039001,"comment_content":"实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。<br>大神这个我有个疑惑<br>因为之前看jvm的视频说到了这块可能会出现指令重排序，自己也跑了下demo发现确实会出现，我当时是jdk8的版本，就是想知道下jdk那个版本实现了呀，有没有帖子我去看看，学习学习以后面试的时候好装个A_C","like_count":0},{"had_liked":false,"id":185074,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583478383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583478383","product_id":100039001,"comment_content":"1.常见的Spring中的拦 截器,对于拦 截器来说,必须是全局唯一的,没有必要对一个请求进行多次拦截,如果多次拦 截的话,可能造成两次处理,导致得到的数据不符合实际<br>2.对于日志覆盖问题,首先说最简单的,可以在类中声明一个static的FileWriter,在类加载的时候,就能拿到这个对象,但是,在实际开发中,对于这样的一个需求,肯定还是采用对消息队列的方式来进行解耦,做到性能上的进一步调优,而且保证了异步刷库,不会出现覆盖问题","like_count":0},{"had_liked":false,"id":184692,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1583383106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583383106","product_id":100039001,"comment_content":"有一些组件可以重用或必须重用的时候，就可以设计成单例了。例如Spring项目里大部分的bean都可以理解成单例。","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":482362,"discussion_content":"生物没学好，你就当它会爬所以叫爬行动物吧😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580174485,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1086157,"avatar":"https://static001.geekbang.org/account/avatar/00/10/92/cd/d39e568c.jpg","nickname":"felix","note":"","ucode":"DF514D0BB9B508","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":154728,"discussion_content":"got it","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580178062,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184080,"user_name":"beslet","can_delete":false,"product_type":"c1","uid":1334377,"ip_address":"","ucode":"6A95C896558C11","user_header":"https://static001.geekbang.org/account/avatar/00/14/5c/69/1a4fa7d9.jpg","comment_is_top":false,"comment_ctime":1583219376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583219376","product_id":100039001,"comment_content":"看了jdk5-13的版本特性更新列表，没有发现有new操作优化为原子操作的特性，求问是哪个版本更新的","like_count":0},{"had_liked":false,"id":184043,"user_name":"李跃爱学习","can_delete":false,"product_type":"c1","uid":1347792,"ip_address":"","ucode":"F25C038C86324A","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/d0/48037ba6.jpg","comment_is_top":false,"comment_ctime":1583210665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583210665","product_id":100039001,"comment_content":"静态内部类代码有点问题<br>private static final IdGenerator instance = new IdGenerator();<br>这个如果是private，SingletonHolder.instance;就访问不到，应该用public吧","like_count":0},{"had_liked":false,"id":183804,"user_name":"Frode","can_delete":false,"product_type":"c1","uid":1503064,"ip_address":"","ucode":"B7B8DBF9980EA1","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/58/d05ec302.jpg","comment_is_top":false,"comment_ctime":1583137620,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583137620","product_id":100039001,"comment_content":"<br>public class Logger {<br>  private FileWriter writer;<br>  private static final Logger instance = new Logger();<br><br>  private Logger() {<br>    File file = new File(&quot;&#47;Users&#47;wangzheng&#47;log.txt&quot;);<br>    writer = new FileWriter(file, true); &#47;&#47;true表示追加写入<br>  }<br>  <br>  public static Logger getInstance() {<br>    return instance;<br>  }<br>  <br>  public void log(String message) {<br>    writer.write(mesasge);<br>  }<br>}<br><br>&#47;&#47; Logger类的应用示例：<br>public class UserController {<br>  public void login(String username, String password) {<br>    &#47;&#47; ...省略业务逻辑代码...<br>    Logger.getInstance().log(username + &quot; logined!&quot;);<br>  }<br>}<br><br>public class OrderController {<br>  private Logger logger = new Logger();----------------------------这句话应该是多余的吧？<br>  <br>  public void create(OrderVo order) {<br>    &#47;&#47; ...省略业务逻辑代码...<br>    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());<br>  }<br>}","like_count":0},{"had_liked":false,"id":181881,"user_name":"August","can_delete":false,"product_type":"c1","uid":1747702,"ip_address":"","ucode":"21794846E0E510","user_header":"https://static001.geekbang.org/account/avatar/00/1a/aa/f6/66cc1bcb.jpg","comment_is_top":false,"comment_ctime":1582657552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582657552","product_id":100039001,"comment_content":"获益匪浅，又加深了对单例的理解","like_count":0},{"had_liked":false,"id":181657,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1582606396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582606396","product_id":100039001,"comment_content":"1.在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？<br>答：Android开发中，ActivityManager，ApplicationContext都是单例的<br>原因：1.全局唯一对象<br>2.在第一个实战案例中，除了我们讲到的类级别锁、分布式锁、并发队列、单例模式等解决方案之外，实际上还有一种非常简单的解决日志互相覆盖问题的方法，你想到了吗？<br>答：用全局变量实现","like_count":0},{"had_liked":false,"id":180965,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1582450044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582450044","product_id":100039001,"comment_content":"1. java.lang.reflect.Proxy是单例的，<br>2. 文件分开，每个log都用自己的文件？","like_count":0},{"had_liked":false,"id":179998,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1582162438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582162438","product_id":100039001,"comment_content":"ID生成器是否也可以算作解决资源冲突的单例模式应用？","like_count":0},{"had_liked":false,"id":179774,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1582096642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582096642","product_id":100039001,"comment_content":"思考题: 日志对象用全局变量保存即可. 毕竟你的文件名等配置都一模一样, 所以只要一个对象即可, 其他所有的依赖日志对象的类不管创建出多少个对象, 里面依赖的都是同一个日志对象.","like_count":0},{"had_liked":false,"id":179740,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1582086587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582086587","product_id":100039001,"comment_content":"从来都知道单例模式，看了这篇之后发现，从来也没有知道过单例模式。","like_count":0},{"had_liked":false,"id":179469,"user_name":"xindoo","can_delete":false,"product_type":"c1","uid":1101718,"ip_address":"","ucode":"AEAF3208E644BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","comment_is_top":false,"comment_ctime":1582010770,"is_pvip":true,"discussion_count":7,"race_medal":0,"score":"1582010770","product_id":100039001,"comment_content":"我思考了下，觉得双重检测的实现里仍然需要加volatile关键词，理由如下：<br>new是原子操作，不会出现有线程使用一个未初始化完的对象，所以用volatile解决指令重排序就没啥必要了。但是还有变量可见性的问题，如果一个线程new出一个对象，赋值的时候引用只写到了cpu cache里 没有更新到主存里，其它的线程看到的还是null，所以还是会去执行new，所以不加volatile可能会导致实际new出多个对象。<br>争哥看我理解的对不对？ ","like_count":0},{"had_liked":false,"id":179080,"user_name":"gogo","can_delete":false,"product_type":"c1","uid":1003104,"ip_address":"","ucode":"E8F0F3B000020A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","comment_is_top":false,"comment_ctime":1581910361,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1581910361","product_id":100039001,"comment_content":"请教一个问题，老师讲到恶汉式单例时，提到占用内存多，没太了解，不是只有调用getInstance()方法才会触发这个对象初始化的吗？为什么会说提前初始化呢","like_count":0,"discussions":[{"author":{"id":1784511,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3a/bf/fea3aa00.jpg","nickname":"Ezreal","note":"","ucode":"8C7107E6AD521D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185131,"discussion_content":"是的华生你发现了盲点。所以想要饿汉式提前生效，应该使用spring这种框架来管路这个对象，服务启动的时候就能初始化这个类了。不然跟懒汉式区别不大","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582597087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278245,"discussion_content":"饿汉式的单例(IdGenerator)，在加载这个类的时候就已经 初始化了(private static final IdGenerator instance = new IdGenerator();)\n所以在使用getInstance()方法是。instance 早就创建了好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591164751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186214,"discussion_content":"静态对象在项目启动的时候会进行初始化，而这里的饿汉式就是静态对象，如果静态对象有很多会在项目启动的时候就分配了空间，如果没有用到就造成了内存浪费占用内存多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582646986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178925,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1581856399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581856399","product_id":100039001,"comment_content":"有个问题。枚举单例，是不是不支持延迟加载？？欢迎大家来讨论","like_count":0},{"had_liked":false,"id":178681,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1581778230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581778230","product_id":100039001,"comment_content":"感谢分享<br>1. 猛地还真想不起来，看了下表，Calendar 目测是单例，实践了下还真是，原因:emmmm 说实话我个人觉得是没必要， 然后我点进去看了下代码，觉得逻辑真复杂。感谢JDK 提供了单例。。<br>2. Logger.log() 编程static 方法，业务代码直接 Logger.log(&quot;XXOO&quot;); ","like_count":0},{"had_liked":false,"id":178421,"user_name":"Zexho","can_delete":false,"product_type":"c1","uid":1430343,"ip_address":"","ucode":"ADEB6624E29893","user_header":"https://static001.geekbang.org/account/avatar/00/15/d3/47/25ec564c.jpg","comment_is_top":false,"comment_ctime":1581686129,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581686129","product_id":100039001,"comment_content":"用读写锁来解决文件的写入覆盖问题是否可以呢？","like_count":0,"discussions":[{"author":{"id":2415448,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","nickname":"二饼","note":"","ucode":"48120565D135F7","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574960,"discussion_content":"个人感觉，用读写锁理论上是可行，但是分情况，比如案例一这种写出日志会频繁访问内存的，用读写锁可能会出现性能瓶颈，而案例二关注点更多的放在获取生成的id上面，因此可以用读写锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654496779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177770,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1581495778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581495778","product_id":100039001,"comment_content":"争哥的这篇单例的讲解, 是我见过的讲解的最清晰的一篇, 之前从来不知道单例还有静态内部类和枚举的实现.<br>在个人项目中, 加载资源配置是单例的, 用消息队列解决日志互相覆盖的问题","like_count":0},{"had_liked":false,"id":177673,"user_name":"123456","can_delete":false,"product_type":"c1","uid":1485820,"ip_address":"","ucode":"9F7C4F3E4416BE","user_header":"https://static001.geekbang.org/account/avatar/00/16/ab/fc/38ccd186.jpg","comment_is_top":false,"comment_ctime":1581471641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581471641","product_id":100039001,"comment_content":"双重检测的高低版本能否具体指明下","like_count":0},{"had_liked":false,"id":177577,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1581427789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581427789","product_id":100039001,"comment_content":"问题2，不同日志名就好了吧，哈哈","like_count":0},{"had_liked":false,"id":177263,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1581335191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581335191","product_id":100039001,"comment_content":"单列模式：<br>饿汉式：预加载，占内存。<br>懒汉式：延迟加载，效率低。<br>实现方式：<br>1. 私有化构造器，提供公共的创建方法。<br>2. 内部类方式。<br>3.枚举方式。","like_count":0},{"had_liked":false,"id":177129,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1581299080,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581299080","product_id":100039001,"comment_content":"为何在讲本文中实战一<br>ublic class OrderController {  private Logger logger = new Logger();    public void create(OrderVo order) {    &#47;&#47; ...省略业务逻辑代码...    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());  }}<br>还有一行这个代码？private Logger logger = new Logger(); ","like_count":0,"discussions":[{"author":{"id":1177602,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","nickname":"Treasure","note":"","ucode":"4211ECEB347C3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168260,"discussion_content":"应该是复制粘贴忘记删除了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581566170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177099,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1581267816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581267816","product_id":100039001,"comment_content":"我想到的其他解决日志互相覆盖问题的方法：<br>1. 配合数据库使用。数据库自己做了处理，就不需要自己考虑覆盖问题了。缺点是日志系统理论上不应该用上数据库，会导致扩展性不好。<br>2. 每个线程创建一个日志文件，间隔一段时间将多个日志文件进行合并为大的日志文件。缺点是线程多的时候比较消耗资源。<br>3. 将日志信息发送出去，比如通过 http 请求，让一个单线程的服务接收并记录日志。这种实现有点像消息队列了。","like_count":0},{"had_liked":false,"id":176172,"user_name":"东流","can_delete":false,"product_type":"c1","uid":1738147,"ip_address":"","ucode":"2715BC6E87BD83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/a3/7e078442.jpg","comment_is_top":false,"comment_ctime":1580979011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580979011","product_id":100039001,"comment_content":"1.在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？<br>java 中的打印类，System.out,（我猜的）；原因则是用起来方便<br><br>在第一个实战案例中，除了我们讲到的类级别锁、分布式锁、并发队列、单例模式等解决方案之外，实际上还有一种非常简单的解决日志互相覆盖问题的方法，你想到了吗？<br>没","like_count":0},{"had_liked":false,"id":176035,"user_name":"小猴子吹泡泡","can_delete":false,"product_type":"c1","uid":1122941,"ip_address":"","ucode":"A5F214E388E41F","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/7d/b093ca1e.jpg","comment_is_top":false,"comment_ctime":1580916427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580916427","product_id":100039001,"comment_content":"如果要实现序列化反序列化的单例模式，要增加一个readResolve()方法，代码如下：<br>protected Object readResolve() throws ObjectStreamException {<br>    return instance;<br>}","like_count":0},{"had_liked":false,"id":176030,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1580914261,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580914261","product_id":100039001,"comment_content":"第一个问题：Spring框架中，大部分的组件都是单例的；<br>第二个问题：将不同业务的日志拆开，并将Logger对象用static关键词修饰","like_count":0},{"had_liked":false,"id":176028,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1580914207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580914207","product_id":100039001,"comment_content":"1. 目前能想到的类库中使用了单例模式的有连接池、java.lang.Runtime#getRuntime，Hibernate的SessionFactory、Configuration，这么设计的的原因是维持全局唯一，还存在这些类的实例可能会占用很多内存，或者实例的初始化过程比较冗长。<br>2. 写日志的例子中还可使用JDK1.4 提供的FileLock来解决资源竞争问题，其他更简单的方式想不到。","like_count":0},{"had_liked":false,"id":175979,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1580898295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580898295","product_id":100039001,"comment_content":"MDC，在日记上下文中记录线程信息以区分日记","like_count":0},{"had_liked":false,"id":175899,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1580881844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580881844","product_id":100039001,"comment_content":"iOS中UIApplication类是单例,因为它执行的都是应用级别的操作,设计成单例更安全.","like_count":0},{"had_liked":false,"id":175890,"user_name":"丿淡忘","can_delete":false,"product_type":"c1","uid":1139645,"ip_address":"","ucode":"604AE01961A026","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/bd/80f587ad.jpg","comment_is_top":false,"comment_ctime":1580880194,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1580880194","product_id":100039001,"comment_content":"直接将日志写入到数据库？？？","like_count":0},{"had_liked":false,"id":175871,"user_name":"zs阿帅","can_delete":false,"product_type":"c1","uid":1141173,"ip_address":"","ucode":"07A54AE7F1CAFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/b5/1e1731cc.jpg","comment_is_top":false,"comment_ctime":1580874273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580874273","product_id":100039001,"comment_content":"以前从来不知道还有静态内部类和枚举方式实现单例，学到了","like_count":0},{"had_liked":false,"id":175837,"user_name":"黄海峰","can_delete":false,"product_type":"c1","uid":1275357,"ip_address":"","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1580867486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580867486","product_id":100039001,"comment_content":"文件锁？","like_count":0},{"had_liked":false,"id":175875,"user_name":"aof","can_delete":false,"product_type":"c1","uid":1062864,"ip_address":"","ucode":"5815D63C4926BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/37/d0/26975fba.jpg","comment_is_top":true,"comment_ctime":1580875805,"is_pvip":false,"discussion_count":13,"race_medal":0,"score":"9.2233733226308997e+18","product_id":100039001,"comment_content":"这真的是看过的关于讲单例的最好的文章","like_count":300,"discussions":[{"author":{"id":1258251,"avatar":"https://static001.geekbang.org/account/avatar/00/13/33/0b/fd18c8ab.jpg","nickname":"大胖子呀、","note":"","ucode":"4BADF8096254BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":202339,"discussion_content":"争哥这个置顶操作就很骚了，hiahiahia","likes_number":13,"is_delete":false,"is_hidden":false,"ctime":1583898736,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1208393,"avatar":"https://static001.geekbang.org/account/avatar/00/12/70/49/d7690979.jpg","nickname":"tommyCmd","note":"","ucode":"4ADBB1FA44668D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":260037,"discussion_content":"感觉终于单例模式知识点终于不用死记硬背了","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1588842579,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2277251,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/83/c83be5a3.jpg","nickname":"eHackyd","note":"","ucode":"E6E7994FBDF0A5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568657,"discussion_content":"舔狗","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1651194680,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2083243,"avatar":"","nickname":"Geek_9e4d78","note":"","ucode":"F4FFBC06B1ABA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294283,"discussion_content":"双重检查锁那里有个bug，单例引用应该用volatile修饰，否则在并发时，某个请求会去到一个没有实例化完的对象","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595848943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1497221,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d8/85/f31e8841.jpg","nickname":"大魔王or","note":"","ucode":"2E3DFD4E90FF6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2083243,"avatar":"","nickname":"Geek_9e4d78","note":"","ucode":"F4FFBC06B1ABA3","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":298947,"discussion_content":"老师讲了，高版本的JVM内部解决了这个问题，仔细看括号里的内容","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1597486927,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":294283,"ip_address":""},"score":298947,"extra":""},{"author":{"id":1955317,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/d5/f5/2ee8cf75.jpg","nickname":"王同学","note":"","ucode":"EAFCC3D47F6FFB","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1497221,"avatar":"https://static001.geekbang.org/account/avatar/00/16/d8/85/f31e8841.jpg","nickname":"大魔王or","note":"","ucode":"2E3DFD4E90FF6B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":324158,"discussion_content":"怎么解决的，有官方的依据吗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605062735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":298947,"ip_address":""},"score":324158,"extra":""},{"author":{"id":2071327,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/9b/1f/9f3379d3.jpg","nickname":"Geek_7f21d2","note":"","ucode":"12204FDAD951BE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1955317,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/d5/f5/2ee8cf75.jpg","nickname":"王同学","note":"","ucode":"EAFCC3D47F6FFB","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":325565,"discussion_content":"老师不是说了 new对象的时候保证初始化三步是原子性的就解决了 要考证的话下个源码自己撸","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1605349983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":324158,"ip_address":""},"score":325565,"extra":""}]},{"author":{"id":1173753,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo435IStLENgDxYPDykxxE9CP6Tye3xPQ584UeNqW21pU62ic6vibrGpNjKVbhulVehVG5IGvicSTaZg/132","nickname":"alex","note":"","ucode":"C7572007957F1E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":208878,"discussion_content":"没有之一","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584586583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1138766,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/4e/1c654d86.jpg","nickname":"Omooo","note":"","ucode":"FFADFDC72EC847","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300239,"discussion_content":"真实！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597997397,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1097416,"avatar":"https://static001.geekbang.org/account/avatar/00/10/be/c8/7c5f324f.jpg","nickname":"港岛妹夫","note":"","ucode":"9F6AAA29B60D8F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294176,"discussion_content":"确实是, 而且几分钟看完, 解决了之前所有的困惑.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595819142,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1586908,"avatar":"https://static001.geekbang.org/account/avatar/00/18/36/dc/97369381.jpg","nickname":"张钟强","note":"","ucode":"EE0D5CAEDBBAC8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226081,"discussion_content":"这操作，太骚了。。。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586419573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175903,"user_name":"Douglas","can_delete":false,"product_type":"c1","uid":1073027,"ip_address":"","ucode":"CFDE3D76B9DAE6","user_header":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","comment_is_top":false,"comment_ctime":1580883219,"is_pvip":false,"discussion_count":41,"race_medal":0,"score":"469732318483","product_id":100039001,"comment_content":"争哥新年好， 有个问题想请教一下，单例的实现中看到过一种实现方式，包括在spring源码中有类似的实现 ，代码如下 <br> 1. public  class Singleton {<br>    private static volatile Singleton instance=null; <br>    private Singleton() {<br>    } <br><br>    public static Singleton getInstance() {&#47;&#47;  <br>        Singleton temp=instance;  &#47;&#47;  为什么要用局部变量来接收<br>        if (null == temp) { <br>            synchronized (Singleton.class) { <br>                temp=instance;<br>                if (null == temp) { <br>                    temp=new Singleton(); <br>                    instance=temp;<br>                }<br>            }<br>        }<br>        return instance; <br>    }<br>}<br><br>spring源码  如   ReactiveAdapterRegistry。 <br>JDK 源码 如 AbstractQueuedSynchronizer。<br>很多地方 都有用 局部变量 来接收 静态的成员变量， 请问下 这么写有什么性能上的优化点吗？<br>jcu 包下面类似的用法太多。想弄明白为什么要这样写<br>2. 看jdk 官方的文档（JMM）有说明 指令重排发生的地方有很多 ，编译器，及时编译，CPU在硬件层面的优化，看spring 比较新的代码也使用volatile来修饰，你说的new 关键字和初始化 作为原子操作 可以说一下 大概的jdk版本吗","like_count":110,"discussions":[{"author":{"id":1242819,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f6/c3/926f2da9.jpg","nickname":"Paradise丶朽木","note":"","ucode":"4E4B8DCC216FAA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":196939,"discussion_content":"Using localRef, we are reducing the access of volatile variable to just one for positive usecase. If we do not use localRef, then we would have to access volatile variable twice - once for checking null and then at method return time. \nAccessing volatile memory is quite an expensive affair because it involves reaching out to main memory.\n参考链接：https://www.javacodemonk.com/threadsafe-singleton-design-pattern-java-806ad7e6","likes_number":123,"is_delete":false,"is_hidden":false,"ctime":1583386956,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":14,"child_discussions":[{"author":{"id":1231549,"avatar":"https://static001.geekbang.org/account/avatar/00/12/ca/bd/a51ae4b2.jpg","nickname":"吃饭饭","note":"","ucode":"95CFA07CDA2957","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242819,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f6/c3/926f2da9.jpg","nickname":"Paradise丶朽木","note":"","ucode":"4E4B8DCC216FAA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295368,"discussion_content":"厉害啊，解决了一个困惑","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596176749,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":196939,"ip_address":""},"score":295368,"extra":""},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242819,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f6/c3/926f2da9.jpg","nickname":"Paradise丶朽木","note":"","ucode":"4E4B8DCC216FAA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296273,"discussion_content":"厉害了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596501166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":196939,"ip_address":""},"score":296273,"extra":""},{"author":{"id":1131128,"avatar":"https://static001.geekbang.org/account/avatar/00/11/42/78/7ba89c75.jpg","nickname":"RedDevil","note":"","ucode":"F8F5DC209BB3B9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1242819,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f6/c3/926f2da9.jpg","nickname":"Paradise丶朽木","note":"","ucode":"4E4B8DCC216FAA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312551,"discussion_content":"大神","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602731987,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":196939,"ip_address":""},"score":312551,"extra":""}]},{"author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161343,"discussion_content":"不是局部变量来接受静态变量，而是你这个静态变量有了 volatile 关键字，需要从主存同步，修改又要同步到主存，消耗了io，而局部变量和主存无关，只要最后一次同步到主存上去就好了","likes_number":56,"is_delete":false,"is_hidden":false,"ctime":1580891305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1241770,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f2/aa/32fc0d54.jpg","nickname":"失火的夏天","note":"","ucode":"10C6E66EB2A65F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163147,"discussion_content":"volatile 修饰不走寄存器内存，每次操作都是直接访问的内存，性能较差。","likes_number":10,"is_delete":false,"is_hidden":false,"ctime":1581053088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":161343,"ip_address":""},"score":163147,"extra":""},{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1251111,"avatar":"https://static001.geekbang.org/account/avatar/00/13/17/27/ec30d30a.jpg","nickname":"Jxin","note":"","ucode":"4C03928388C413","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164144,"discussion_content":"虽然jvm是基于栈结构实现的,但是最终也是会经过转换调用到寄存器的.","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581156366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163147,"ip_address":""},"score":164144,"extra":""}]},{"author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178981,"discussion_content":"因为volatile修饰的静态变量访问比较慢，如果不用局部变量则getInstance需要多次访问instance变量，使用局部变量可以有一定的性能提升。","likes_number":50,"is_delete":false,"is_hidden":false,"ctime":1582205564,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":5,"child_discussions":[{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":241980,"discussion_content":"厉害","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587453695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":178981,"ip_address":""},"score":241980,"extra":""},{"author":{"id":1138766,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/4e/1c654d86.jpg","nickname":"Omooo","note":"","ucode":"FFADFDC72EC847","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300241,"discussion_content":"牛批","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597997758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":178981,"ip_address":""},"score":300241,"extra":""},{"author":{"id":1691669,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d0/15/5851180d.jpg","nickname":"一个无趣的俗人","note":"","ucode":"25435088B10CA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377272,"discussion_content":"牛逼","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622566473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":178981,"ip_address":""},"score":377272,"extra":""}]},{"author":{"id":1099216,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/d0/cf6bbe55.jpg","nickname":"CALL ME","note":"","ucode":"2A5BE26EAC9716","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301352,"discussion_content":"最后应该return temp吧","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1598499041,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1143536,"avatar":"https://static001.geekbang.org/account/avatar/00/11/72/f0/abb7bfe3.jpg","nickname":"Mcnulty","note":"","ucode":"3DD71D84B58A16","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1099216,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/d0/cf6bbe55.jpg","nickname":"CALL ME","note":"","ucode":"2A5BE26EAC9716","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":304295,"discussion_content":"对的，最后应该是return temp。这样在instance!=null时，传统双检锁会访问2次主存；现在利用局部变量只需要访问1次主存，性能更好。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1599540490,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301352,"ip_address":""},"score":304295,"extra":""},{"author":{"id":2283490,"avatar":"https://static001.geekbang.org/account/avatar/00/22/d7/e2/5e5cc8f3.jpg","nickname":"Molyt","note":"","ucode":"9CCF7A18B2C547","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1099216,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c5/d0/cf6bbe55.jpg","nickname":"CALL ME","note":"","ucode":"2A5BE26EAC9716","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405487,"discussion_content":"如果第一次为空，就走if里面的temp赋值后，再赋值给instance，第二次进来instance不为空，return instance应该没错吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634570325,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301352,"ip_address":""},"score":405487,"extra":""}]},{"author":{"id":1134288,"avatar":"https://static001.geekbang.org/account/avatar/00/11/4e/d0/d8a5f720.jpg","nickname":"Ken张云忠","note":"","ucode":"D0BAC9FC17DE2B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163946,"discussion_content":"这是双重检测方式的优化写法，volatile带有读写屏障指令，可以有效防止指令重排序，确保数据最终可以刷入主存中。","likes_number":6,"is_delete":false,"is_hidden":false,"ctime":1581130288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2225926,"avatar":"","nickname":"Geek_eaff30","note":"","ucode":"751D26C18D13C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":356834,"discussion_content":"刚看到前面说的双重检测一直有个疑惑，先判断为null，然后再加锁，这时候如果是在高并发的情况下，是不是会有可能出现new了两个不同的实例，我觉得层主你发的这个就可以避免这种问题，在锁里面再去判断一次instance是否初始化","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1615687670,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1325816,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","nickname":"君哥聊技术","note":"","ucode":"2C9A22BCE4C79E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":163166,"discussion_content":"\n争哥说的是不是类似这种的  \nAtomicReference<Singleton> INSTANCE = new AtomicReference<Singleton>()\npublic static Singleton getInstance() {\n        for (;;) {\n            Singleton singleton = INSTANCE.get();\n            if (null != singleton) {\n                return singleton;\n            }\n\n            singleton = new Singleton();\n            if (INSTANCE.compareAndSet(null, singleton)) {\n                return singleton;\n            }\n        }","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581056730,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1325816,"avatar":"https://static001.geekbang.org/account/avatar/00/14/3a/f8/c1a939e7.jpg","nickname":"君哥聊技术","note":"","ucode":"2C9A22BCE4C79E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":213825,"discussion_content":"这个方式会有多个实例被创建，比如第一次请求全都进来就直接new 了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1585125533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":163166,"ip_address":""},"score":213825,"extra":""},{"author":{"id":1644104,"avatar":"https://static001.geekbang.org/account/avatar/00/19/16/48/09493874.jpg","nickname":"茶没喝完","note":"","ucode":"D72D88C42A1258","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1073027,"avatar":"https://static001.geekbang.org/account/avatar/00/10/5f/83/bb728e53.jpg","nickname":"Douglas","note":"","ucode":"CFDE3D76B9DAE6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":405997,"discussion_content":"对的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634690077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":213825,"ip_address":""},"score":405997,"extra":""}]},{"author":{"id":1097836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","nickname":"随心而至","note":"","ucode":"31866865255101","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350173,"discussion_content":"记住加volatile等同于从主存里面获取值，不是CPU寄存器。可以看看https://www.jianshu.com/p/aa6a9a7035a9","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613733154,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2436755,"avatar":"https://static001.geekbang.org/account/avatar/00/25/2e/93/81e3e4ca.jpg","nickname":"ฅSlekฅ","note":"","ucode":"B732C672B3D301","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1097836,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c0/6c/29be1864.jpg","nickname":"随心而至","note":"","ucode":"31866865255101","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":409347,"discussion_content":"补充一下：多个线程在多核CPU上跑，每个CPU都包含自己独有的缓存（解决读写效率的问题）。volatile的目的就是让CPU缓存中的数据&#34;强行&#34;刷新到内存中，从而保证各个线程都能够看到数据的变化(即保证&#34;可见性&#34;)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1635422846,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":350173,"ip_address":""},"score":409347,"extra":""}]},{"author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296276,"discussion_content":"应该不是多次访问主存，每次都会赋值给临时变量的时候都要访问主存，应该是保证temp=new Singleton();再怎么重排序也不存在线程安全问题","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596501857,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":2683430,"avatar":"https://static001.geekbang.org/account/avatar/00/28/f2/26/a8ac6b42.jpg","nickname":"听风有信","note":"","ucode":"2CCB467114FF5C","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1937062,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/8e/a6/c3286b61.jpg","nickname":"Java垒墙工程师","note":"","ucode":"E76AE44A9C76AE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554998,"discussion_content":"为啥不会","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646714119,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296276,"ip_address":""},"score":554998,"extra":""}]},{"author":{"id":1924882,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aXnFBB3XD3lwB3jf1A0PQqT66aJy4yycbRupJI3ia2CUFMuLsvYthM41TDopIIjL8kz7k2xE5vrAtQggQ6Jt8Zw/132","nickname":"付磊","note":"","ucode":"719BD0B72FF2AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583681,"discussion_content":"哦哦，我理解了，热评第一分享的链接中说的是对的，他所谓的不临时变量需要两次访问主存，指的是实例已经初始化好的情况。如果是未初始化，那么不用临时变量需要访问三次主存(两次判断一次返回)","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660288803,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1924882,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/aXnFBB3XD3lwB3jf1A0PQqT66aJy4yycbRupJI3ia2CUFMuLsvYthM41TDopIIjL8kz7k2xE5vrAtQggQ6Jt8Zw/132","nickname":"付磊","note":"","ucode":"719BD0B72FF2AF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":583677,"discussion_content":"用临时变量应该是可以减少访问主存数据的问题，但是我个人感觉上面说的包括第一热评分享的链接是不是都有问题,如果不用临时变量,两个判空+返回总共三次访问主存,如果用临时变量，那么判空不会访问主存，但是有两次赋值操作，不过返回的是临时变量，因此这里只需要访问2次主存，比不用临时变量要少一次才对。 不知道我说的对不对，反正上面好几个人说的都有冲突，大家伙颇有人云亦云的感觉,如果我理解有误欢迎大家指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1660288252,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海"},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2986618,"avatar":"https://static001.geekbang.org/account/avatar/00/2d/92/7a/0c2317ab.jpg","nickname":"江湖骗子","note":"","ucode":"5BE77FD50E35AC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":576412,"discussion_content":"AbstractQueuedSynchronizer中并没有使用单例模式吧?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1655531941,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1261052,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3d/fc/f81d7847.jpg","nickname":"BATMAN","note":"","ucode":"414137A1074E62","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":355373,"discussion_content":"为什么使用volatile修饰变量，可以看下JMM内存模型这本书，JMM是在硬件架构上抽象出来的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615425557,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1515149,"avatar":"https://static001.geekbang.org/account/avatar/00/17/1e/8d/5b242931.jpg","nickname":"Fish","note":"","ucode":"C20719F8B0F7C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":295469,"discussion_content":"在同步代码块內临时变量好像没减少对静态变量的读写次数 ，不明白好处在哪？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596201117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":3,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239282,"user_name":"写代码的","can_delete":false,"product_type":"c1","uid":2085090,"ip_address":"","ucode":"F58186409A3D65","user_header":"https://static001.geekbang.org/account/avatar/00/1f/d0/e2/1d00c079.jpg","comment_is_top":false,"comment_ctime":1596478430,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"169100202974","product_id":100039001,"comment_content":"懒汉式还是饿汉式更好我觉得需要看具体的场景。对于那些短生命周期的应用，如客户端应用来说，启动是频繁发生的，如果启动时导致了一堆饿汉初始化，会给用户带来不好的体验，如果把初始化往后延，将初始化分散在未来的各个时间点，即使某个懒汉初始化时间较长，用户也几乎无感知。而对于生命周期较长的应用，长痛不如短痛，启动时耗点时，保证后面的使用流畅也是可取的。","like_count":40,"discussions":[{"author":{"id":1115702,"avatar":"https://static001.geekbang.org/account/avatar/00/11/06/36/d288bcc7.jpg","nickname":"张诚","note":"","ucode":"F623703194769B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":591058,"discussion_content":"分场景去看待问题，这个思考过程我需要学习","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1666254270,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175931,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1580887376,"is_pvip":true,"discussion_count":3,"race_medal":0,"score":"139019840848","product_id":100039001,"comment_content":"简单的方法：创建一个静态私有的filewritter，多线程或者多个Logger对象共享一个filewritter。","like_count":33,"discussions":[{"author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":226629,"discussion_content":"在读取日志写入位置之前要实现互斥","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1586437822,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1958147,"avatar":"https://static001.geekbang.org/account/avatar/00/1d/e1/03/f937e673.jpg","nickname":"🍀","note":"","ucode":"60E0AC2A55B63B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309282,"discussion_content":"多个Logger共享同一个Filewritter为什么能保证日志不会被覆盖呢，多个线程同时进入Logger中去写日志会出现被覆盖，你的意思是用静态私有filewritter对象作为synchronized锁吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601253158,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":226629,"ip_address":""},"score":309282,"extra":""},{"author":{"id":1167825,"avatar":"https://static001.geekbang.org/account/avatar/00/11/d1/d1/62f74aa7.jpg","nickname":"自在飞","note":"","ucode":"A2712148DA06E0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1554995,"avatar":"https://static001.geekbang.org/account/avatar/00/17/ba/33/2d83d174.jpg","nickname":"时光守护者-基兰","note":"","ucode":"F0B0887B1979D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":336384,"discussion_content":"这是从“多个logger对象公用一个FileWriter对象”来考虑的，而且FileWriter.write()在写数据时，其内部实现上已经通过synchronized加了锁做了同步操作","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1608561048,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":309282,"ip_address":""},"score":336384,"extra":""}]}]},{"had_liked":false,"id":177178,"user_name":"xindoo","can_delete":false,"product_type":"c1","uid":1101718,"ip_address":"","ucode":"AEAF3208E644BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","comment_is_top":false,"comment_ctime":1581315510,"is_pvip":true,"discussion_count":40,"race_medal":0,"score":"96070596022","product_id":100039001,"comment_content":"为什么高版本的jdk单例不再需要volatile修饰，求详细参考资料，感谢🙏","like_count":22},{"had_liked":false,"id":209431,"user_name":"夏目","can_delete":false,"product_type":"c1","uid":1212750,"ip_address":"","ucode":"67C075A01CF4D2","user_header":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","comment_is_top":false,"comment_ctime":1587548324,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"74601992356","product_id":100039001,"comment_content":"枚举模式的单例还可以防止序列化和反序列化生成新的实例<br>","like_count":17,"discussions":[{"author":{"id":1635702,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f5/76/55e594ab.jpg","nickname":"Lu丶","note":"","ucode":"94075890AEF66B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":415018,"discussion_content":"然后让你做个算法题，冷静一下","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1636964962,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2557373,"avatar":"https://static001.geekbang.org/account/avatar/00/27/05/bd/ec91213b.jpg","nickname":"亭书浅墨丶","note":"","ucode":"AD63D4E5B51B92","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1635702,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f5/76/55e594ab.jpg","nickname":"Lu丶","note":"","ucode":"94075890AEF66B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485419,"discussion_content":"讨厌～","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1637056569,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":415018,"ip_address":""},"score":485419,"extra":"{\"user_type\":1}"},{"author":{"id":1203255,"avatar":"https://static001.geekbang.org/account/avatar/00/12/5c/37/de2649c3.jpg","nickname":"麦田守望者","note":"","ucode":"F4F0CCB787A420","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1635702,"avatar":"https://static001.geekbang.org/account/avatar/00/18/f5/76/55e594ab.jpg","nickname":"Lu丶","note":"","ucode":"94075890AEF66B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":578908,"discussion_content":"哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657087440,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":415018,"ip_address":""},"score":578908,"extra":""}]},{"author":{"id":1247277,"avatar":"https://static001.geekbang.org/account/avatar/00/13/08/2d/fb0831a9.jpg","nickname":"拉环","note":"","ucode":"5F81F2746CEF61","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294560,"discussion_content":"手动滑稽 把面试官讲到都跟不上你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595928144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175904,"user_name":"守拙","can_delete":false,"product_type":"c1","uid":1738326,"ip_address":"","ucode":"F594B2DA3F6D4F","user_header":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","comment_is_top":false,"comment_ctime":1580883235,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"66005392675","product_id":100039001,"comment_content":"Singleton指仅仅被实例化一次的类. Singleton通常被用来代表本质上唯一的系统组件, 如窗口管理器或文件系统.<br><br>-- &lt;Effective Java&gt;  p14<br><br>课堂讨论:<br><br>1. 在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？<br><br>   Android SDK中的AccessibilityManager应用了懒汉式单例模式.<br><br>   <br><br>2. 在第一个实战案例中，除了我们讲到的类级别锁、分布式锁、并发队列、单例模式等解决方案之外，实际上还有一种非常简单的解决日志互相覆盖问题的方法，你想到了吗？<br><br>​    将FileWriter的声明用static修饰, 即可解决日志相互覆盖的问题. 原理: 被声明为static的成员变量由类的所有实例所共享, 所以Logger类的所有实例都是通过同一FileWriter写入日志到文件. ","like_count":15,"discussions":[{"author":{"id":1015483,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7e/bb/947c329a.jpg","nickname":"程序员小跃","note":"","ucode":"25BB96E0791A60","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315922,"discussion_content":"就是这样，有时候面试官，也是抱着学习的心态去面试的，他懂的不一定比你多","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1603336908,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1612910,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9c/6e/01b4d5d2.jpg","nickname":"liupan","note":"","ucode":"C6C7C48BCCAE12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387952,"discussion_content":"不，本来就有新手面试官么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628507508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":205983,"user_name":"肖臧","can_delete":false,"product_type":"c1","uid":1047733,"ip_address":"","ucode":"4FAC9FF54DD6A0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fc/b5/ac717737.jpg","comment_is_top":false,"comment_ctime":1586767724,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"35946506092","product_id":100039001,"comment_content":"90年代的论文的确说了因为JVM的优化和多核CPU会对指令进行reordering，volatile才能解决双检锁问题：http:&#47;&#47;www.cs.umd.edu&#47;~pugh&#47;java&#47;memoryModel&#47;DoubleCheckedLocking.html","like_count":8},{"had_liked":false,"id":203928,"user_name":"Murrre","can_delete":false,"product_type":"c1","uid":1685995,"ip_address":"","ucode":"49644059B512BE","user_header":"https://static001.geekbang.org/account/avatar/00/19/b9/eb/6bdab896.jpg","comment_is_top":false,"comment_ctime":1586308177,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"35946046545","product_id":100039001,"comment_content":"争哥讲得真好,不过有一点也有疑问.<br>----------------------<br>只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。<br>---------------<br>这个在google百度都没找到,争哥能提供一下相关资料吗","like_count":8,"discussions":[{"author":{"id":2526391,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/fcftgBsticCicEEkuzB0GTkHIocX62YVTSvnhR1c94sccj42lVaYXrmcZyhzUI3l9NcvuN1rXLhXt2eBrZZ0Tw7A/132","nickname":"idiot","note":"","ucode":"D7A6E980B530B4","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":542834,"discussion_content":"“我们要把面试当做一场与未来同事的技术讨论，在讨论的过程中去感受候选人的技术实力。”","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1640857305,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178628,"user_name":"techwro","can_delete":false,"product_type":"c1","uid":1113744,"ip_address":"","ucode":"7AF2B319F0AE1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","comment_is_top":false,"comment_ctime":1581762646,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"31646533718","product_id":100039001,"comment_content":"争哥，求“只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序”这一说法的出处。","like_count":7,"discussions":[{"author":{"id":1738326,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/86/56/509535da.jpg","nickname":"守拙","note":"","ucode":"F594B2DA3F6D4F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300262,"discussion_content":"手写单例最容易, 丢个enum给他, 3行代码.","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598003393,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":202966,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1586094599,"is_pvip":false,"replies":[{"id":"89276","content":"着急吃-》饿汉式<br>不着急吃-》懒汉式","user_name":"作者回复","comment_id":202966,"uid":"1190123","ip_address":"","utype":1,"ctime":1597454733,"user_name_real":"王争"}],"discussion_count":3,"race_medal":1,"score":"27355898375","product_id":100039001,"comment_content":"饿汉式和懒汉式的名字为什么这么起呀？可以解释一下吗？","like_count":6,"discussions":[{"author":{"id":1866485,"avatar":"https://static001.geekbang.org/account/avatar/00/1c/7a/f5/54a5084b.jpg","nickname":"简单猫","note":"","ucode":"EA027D4C344E25","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":265239,"discussion_content":"饿汉 大饼先挂你脖子上，想吃就吃。\n懒汉 饿了说一声(要用的时候) 再给你饼 省的饼挂身上浪费力气(资源)","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589380855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":490719,"discussion_content":"着急吃-》饿汉式\n不着急吃-》懒汉式","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597454733,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1324863,"avatar":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","nickname":"KK","note":"","ucode":"FFC31A3FE3A285","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":299904,"discussion_content":"got it","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597850905,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":180696,"user_name":"李小四","can_delete":false,"product_type":"c1","uid":1112747,"ip_address":"","ucode":"2A766BE16B276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/fa/ab/0d39e745.jpg","comment_is_top":false,"comment_ctime":1582366366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"27352170142","product_id":100039001,"comment_content":"设计模式_41:<br># 作业<br>1. Java中有很多使用单例模式，比如`java.lang.Runtime`类，这么设计的原因是，同一个进程中只需要一个实例。<br>2. 使用同一个`writer`，比如用`static`修饰。<br><br># 感想<br><br>1. 初学Java的时候，老师讲构造函数的第二节，先是讲了`private`修饰构造函数后如何获取对象的问题，后来引出了单例模式，感激老师的循序渐进。<br><br>2. 今天的题目虽然是“双重加锁并没有好多少”，但文章中并没有解释，我猜后文中一定会分析，但也逃不过对于饿汉式的思考: 不能延时加载导致了饿汉式在更多时间地占用了资源，但占用资源少并不是软件工程的唯一追求，更好地完成业务才是第一要务，呼应之前的内容，有时候用空间(资源)换时间也很好的策略。","like_count":6},{"had_liked":false,"id":175860,"user_name":"黄林晴","can_delete":false,"product_type":"c1","uid":1362631,"ip_address":"","ucode":"B15C38AECDA88F","user_header":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","comment_is_top":false,"comment_ctime":1580872052,"is_pvip":false,"discussion_count":8,"race_medal":0,"score":"27350675828","product_id":100039001,"comment_content":"打卡<br><br>看过Eventbus 的源码，写法是典型的双重锁检验方式，但是构造方法是public 的<br><br>看源码解释，这是因为EventBus可能有多条总线，订阅者注册到不同线上的 EventBus，通过不同的实例来发送数据，不同的 EventBus 是相互隔离开的，订阅者都只会收到注册到该线上事件。<br><br>但是按照单例定义他又不属于单例，感觉很有疑问","like_count":6,"discussions":[{"author":{"id":1236024,"avatar":"","nickname":"我睡觉不磨牙","note":"","ucode":"16DFDE5C649160","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200657,"discussion_content":"多数情况下可能只需要一个EventBus实例，框架为避免只需要一个EventBus的开发者因为误操作 创建多个实例，所以采用单例提供一个默认的。用单例模式只是为了提供这一个默认的实例，并不代表EventBus类在系统中只能有一个实例。  只是个人理解","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1583711110,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243540,"discussion_content":"我咋没看到双重锁检测😳","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587548243,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":4,"child_discussions":[{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":243566,"discussion_content":"源码中的getDefault方法","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587549706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243540,"ip_address":""},"score":243566,"extra":""},{"author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244550,"discussion_content":"com.google.common.eventbus这个包下面的EventBus类吗，没看到这个方法，我是guava 23.0","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587611714,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":243566,"ip_address":""},"score":244550,"extra":""},{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1212750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/81/4e/d71092f4.jpg","nickname":"夏目","note":"","ucode":"67C075A01CF4D2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":244698,"discussion_content":"我说的eventbus是android中使用的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587622403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":244550,"ip_address":""},"score":244698,"extra":""}]},{"author":{"id":1359893,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c0/15/be72b945.jpg","nickname":"端点星好运","note":"","ucode":"AA48B23A1C4317","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161198,"discussion_content":"多例？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580875499,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1362631,"avatar":"https://static001.geekbang.org/account/avatar/00/14/ca/c7/00e544c2.jpg","nickname":"黄林晴","note":"","ucode":"B15C38AECDA88F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359893,"avatar":"https://static001.geekbang.org/account/avatar/00/14/c0/15/be72b945.jpg","nickname":"端点星好运","note":"","ucode":"AA48B23A1C4317","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":161229,"discussion_content":"源码写的是单例","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580878815,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":161198,"ip_address":""},"score":161229,"extra":""}]}]},{"had_liked":false,"id":188753,"user_name":"大头","can_delete":false,"product_type":"c1","uid":1315367,"ip_address":"","ucode":"C1FB2C8A0FB0C0","user_header":"https://static001.geekbang.org/account/avatar/00/14/12/27/32746bbf.jpg","comment_is_top":false,"comment_ctime":1584411926,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"23059248406","product_id":100039001,"comment_content":"枚举实现单例的最佳实践。代码简洁，由jvm保证线程安全和单一实例。还可以有效防止序列化和反序列化造成多个实例和利用反射创建多个实例的情况","like_count":5,"discussions":[{"author":{"id":1015754,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7f/ca/ea85bfdd.jpg","nickname":"helloworld","note":"","ucode":"00DF2FEC58D2E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282201,"discussion_content":"这么好的老铁称之为程序破坏者，哈哈","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591922028,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176201,"user_name":"zs阿帅","can_delete":false,"product_type":"c1","uid":1141173,"ip_address":"","ucode":"07A54AE7F1CAFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/b5/1e1731cc.jpg","comment_is_top":false,"comment_ctime":1580987173,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"23055823653","product_id":100039001,"comment_content":"争哥，如果服务是多个实例跑，日志那个单例模式会导致覆盖吗？","like_count":5,"discussions":[{"author":{"id":1016905,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/84/49/47d48fd0.jpg","nickname":"观弈道人","note":"","ucode":"F3BB619A33C605","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":194761,"discussion_content":"没见过多台机器共享一个日志文件的，不是找事情嘛","likes_number":11,"is_delete":false,"is_hidden":false,"ctime":1583242151,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1606474,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotQ0pwrCZctLQ8IfRphIwqVSUISxncqlG4XbvSGvicMYYrRLEzSLHGc6IMKCziaDjJgQ444n9EqnoA/132","nickname":"ilovepeace","note":"","ucode":"F6E8F0429A7987","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165914,"discussion_content":"刚看完单例下篇，如果你的日志文件在一个公共目录，可以利用集群单例方式处理。但是我觉得通常做法一般还是集群中各个实例维护自己的日志，然后统一收集查看即可。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1581341133,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1241576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/f1/e8/d2e88567.jpg","nickname":"ssrsdzry","note":"","ucode":"89BCFA6A1997E5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1606474,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotQ0pwrCZctLQ8IfRphIwqVSUISxncqlG4XbvSGvicMYYrRLEzSLHGc6IMKCziaDjJgQ444n9EqnoA/132","nickname":"ilovepeace","note":"","ucode":"F6E8F0429A7987","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":200621,"discussion_content":"+1，我见过的方式是每台机器生成自己的日志文件，文件名包含service名称+机器名称+日期。最后所有机器的日志会被发送到一台存放历史日志的机器上。存放一个月或者其他时间之后会被删除。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583691282,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165914,"ip_address":""},"score":200621,"extra":""}]},{"author":{"id":2122580,"avatar":"","nickname":"Geek_ddf6a8","note":"","ucode":"873A8920AF06B2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301093,"discussion_content":"加类锁、单例方式都会覆盖同一个文件，而分布式锁如果多实例共用可以做到不会。docker如果采用k8s等编排，有多实例但没挂载目录情况下，各实例的目录空间是独立的，不会覆盖  如果多实例的日志文件挂载到同一个宿主机的相同目录下，是会被覆盖的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1598405726,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1606474,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotQ0pwrCZctLQ8IfRphIwqVSUISxncqlG4XbvSGvicMYYrRLEzSLHGc6IMKCziaDjJgQ444n9EqnoA/132","nickname":"ilovepeace","note":"","ucode":"F6E8F0429A7987","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":165877,"discussion_content":"如果类似docker的实例，实际上相当于多台机器，写的日志应该在不同的实例目录下了吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581338983,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1525958,"avatar":"","nickname":"一只雪狼","note":"","ucode":"5E986C16C6B1AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1606474,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotQ0pwrCZctLQ8IfRphIwqVSUISxncqlG4XbvSGvicMYYrRLEzSLHGc6IMKCziaDjJgQ444n9EqnoA/132","nickname":"ilovepeace","note":"","ucode":"F6E8F0429A7987","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":236023,"discussion_content":"如果docker挂了hostpath进去，用了同一个路径同一个文件名字也会覆盖的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587052179,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":165877,"ip_address":""},"score":236023,"extra":""}]}]},{"had_liked":false,"id":225529,"user_name":"星之所在","can_delete":false,"product_type":"c1","uid":1247574,"ip_address":"","ucode":"03ADB0ADD5FC27","user_header":"https://static001.geekbang.org/account/avatar/00/13/09/56/2628852c.jpg","comment_is_top":false,"comment_ctime":1591777974,"is_pvip":false,"replies":[{"id":"83999","content":"静态变量没法替代单例啊。单例是类本身不允许多个实例。但是静态变量，我可以定义多个啊，这个怎么解决呢？","user_name":"作者回复","comment_id":225529,"uid":"1190123","ip_address":"","utype":1,"ctime":1592526562,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"18771647158","product_id":100039001,"comment_content":"争哥我想细问下，我用一个静态变量也可以实现单例的效果，为啥还要用单例设计模式？是为了代码后续扩展性，还是静态变量用多了影响整个代码？","like_count":5,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497882,"discussion_content":"静态变量没法替代单例啊。单例是类本身不允许多个实例。但是静态变量，我可以定义多个啊，这个怎么解决呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592526562,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179398,"user_name":"William","can_delete":false,"product_type":"c1","uid":1346215,"ip_address":"","ucode":"55F5D9DEE485B1","user_header":"https://static001.geekbang.org/account/avatar/00/14/8a/a7/674c1864.jpg","comment_is_top":false,"comment_ctime":1581996241,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"18761865425","product_id":100039001,"comment_content":"为什么说支持懒加载的双重检测不比饿汉式更优？<br><br>因为饿汉式在类加载的时候, 就将实例资源确定好了.<br>如果放到懒加载中,实例占用的资源很多,可能导致响应时间过长, 也可能导致(OOM),,根据fail-fast最好事早知道问题,最好提前就暴露出问题.<br>","like_count":4,"discussions":[{"author":{"id":2678074,"avatar":"https://static001.geekbang.org/account/avatar/00/28/dd/3a/92726fb6.jpg","nickname":"Geek_f0f0bc","note":"","ucode":"A754BEC95E2BC6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390337,"discussion_content":"空间换时间 ，大家基本都能接受 ，而且 说实在话内存也不会耗费很多 ，并且大部分场景最后单例类都会用到，最后都是要为其分配内存的，所以更倾向于饿汉模式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629788875,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":176003,"user_name":"辣么大","can_delete":false,"product_type":"c1","uid":1396951,"ip_address":"","ucode":"AB308B6DCA0108","user_header":"https://static001.geekbang.org/account/avatar/00/15/50/d7/f82ed283.jpg","comment_is_top":false,"comment_ctime":1580908774,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"18760777958","product_id":100039001,"comment_content":"写了篇总结，还讨论了单例模式中序列化和反序列化的问题。https:&#47;&#47;github.com&#47;gdhucoder&#47;DesignPattern&#47;blob&#47;master&#47;021_SingletonPattern.md","like_count":4,"discussions":[{"author":{"id":1138766,"avatar":"https://static001.geekbang.org/account/avatar/00/11/60/4e/1c654d86.jpg","nickname":"Omooo","note":"","ucode":"FFADFDC72EC847","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300244,"discussion_content":"好家伙！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1597998153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175841,"user_name":"小晏子","can_delete":false,"product_type":"c1","uid":1132337,"ip_address":"","ucode":"3AAA6FB5ACB6AE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/31/f35367c8.jpg","comment_is_top":false,"comment_ctime":1580868305,"is_pvip":false,"discussion_count":1,"race_medal":1,"score":"18760737489","product_id":100039001,"comment_content":"1.JDK中 java.lang.Runtime是单例实现的，该类用于管理应用程序运行期间的各种信息，比如memory和processor信息，所以从该类的用途可以知道该类必须是单例的。<br>2. 使用多个文件，每new一个实例就使用一个新文件，这样就没有文件覆盖问题了。","like_count":4,"discussions":[{"author":{"id":1459006,"avatar":"https://static001.geekbang.org/account/avatar/00/16/43/3e/960d12cb.jpg","nickname":"DY","note":"","ucode":"55536A524A99B4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":290949,"discussion_content":"那么多需要打印日志的类， 你需要new 多少个文件啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594647468,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":239221,"user_name":"L","can_delete":false,"product_type":"c1","uid":1357311,"ip_address":"","ucode":"5B847B2378854E","user_header":"https://static001.geekbang.org/account/avatar/00/14/b5/ff/d1f205b0.jpg","comment_is_top":false,"comment_ctime":1596461957,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14481363845","product_id":100039001,"comment_content":"为什么高版本的jdk单例不再需要volatile修饰，求详细参考资料，感谢������<br><br>new操作 和 初始化操作 设计为原子操作，自然就不存在 指令重排了！    求详细参考资料，感谢������","like_count":3},{"had_liked":false,"id":214138,"user_name":"_Walker","can_delete":false,"product_type":"c1","uid":1173734,"ip_address":"","ucode":"85321A885786D5","user_header":"https://static001.geekbang.org/account/avatar/00/11/e8/e6/3fce0137.jpg","comment_is_top":false,"comment_ctime":1588665025,"is_pvip":false,"replies":[{"id":"86381","content":"不是重点,你自己研究研究吧😂","user_name":"作者回复","comment_id":214138,"uid":"1190123","ip_address":"","utype":1,"ctime":1594602856,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"14473566913","product_id":100039001,"comment_content":"最后枚举那个解释有些含糊其辞呀😂要是能详细解释一下就好了","like_count":3,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":493965,"discussion_content":"不是重点,你自己研究研究吧😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594602856,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":193930,"user_name":"zhengyu.nie","can_delete":false,"product_type":"c1","uid":1541669,"ip_address":"","ucode":"FFE0377D323E46","user_header":"https://static001.geekbang.org/account/avatar/00/17/86/25/25ded6c3.jpg","comment_is_top":false,"comment_ctime":1584986224,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"14469888112","product_id":100039001,"comment_content":"争哥好，我也写过基本上一致的文章，再细一点可以介绍枚举为什么是effective java里最推荐的单例。关于这块的内容在深入理解java虚拟机，java并发编程的艺术，设计模式之禅等几本书里差不多都总结过。唯一的疑问，哪个版本的jdk能禁止初始化23步骤的重排序？在我印象里还是double lock需要volatile关键字的，最早是在方腾飞那本书看到的，求解","like_count":3},{"had_liked":false,"id":175864,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1580872656,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"14465774544","product_id":100039001,"comment_content":"第一个问题，在我的项目中缓存类的节点设置为单例模式，还有加载全局配置文件的类，也设置为了单例模式。<br>第二个问题，我是用消息队列实现的日志收集。","like_count":3,"discussions":[{"author":{"id":1691669,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d0/15/5851180d.jpg","nickname":"一个无趣的俗人","note":"","ucode":"25435088B10CA2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377273,"discussion_content":"虽然可行，但不够简单。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622566697,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1147453,"avatar":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","nickname":"忆水寒","note":"","ucode":"E3F86BD8AA8903","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1691669,"avatar":"https://static001.geekbang.org/account/avatar/00/19/d0/15/5851180d.jpg","nickname":"一个无趣的俗人","note":"","ucode":"25435088B10CA2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":377907,"discussion_content":"嗯，方法很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1622958192,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":377273,"ip_address":""},"score":377907,"extra":""}]}]},{"had_liked":false,"id":175844,"user_name":"🤤🤤","can_delete":false,"product_type":"c1","uid":1396597,"ip_address":"","ucode":"D10673DC29F634","user_header":"https://static001.geekbang.org/account/avatar/00/15/4f/75/8ee12b92.jpg","comment_is_top":false,"comment_ctime":1580869397,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14465771285","product_id":100039001,"comment_content":"这篇非常棒，🔨","like_count":3},{"had_liked":false,"id":276435,"user_name":"Gabriel","can_delete":false,"product_type":"c1","uid":1437358,"ip_address":"","ucode":"714772A93E93DC","user_header":"https://static001.geekbang.org/account/avatar/00/15/ee/ae/855b7e6e.jpg","comment_is_top":false,"comment_ctime":1611921154,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10201855746","product_id":100039001,"comment_content":"当然PHP们，也需要讨论下吧！哈哈哈<br>&lt;?php<br>&#47;&#47;创建步骤：<br>&#47;&#47;1：静态变量 Instance<br>&#47;&#47;2: 防止new，初始方法必须使用 Private<br>&#47;&#47;3: 防止克隆 将__clone()方式可见范围 private<br><br><br>class Singleton {<br>    &#47;&#47;创建静态私有变量保存该类对象<br>    static $instance = null;<br><br>    static $count = 0;<br>    &#47;&#47; 防止使用new直接创建对象<br>    private function __construct()<br>    {}<br><br>    &#47;&#47;防止被克隆<br>    private function __clone()<br>    {}<br><br><br>    public static function getInstance() {<br>        if(!self::$instance instanceof self) {<br>            echo &quot;第&quot;.++self::$count.&quot;次创建:\\r\\n&quot;;<br>            self::$instance = new self();<br>        }<br>        return self::$instance;<br>    }<br><br>    public function testEcho () {<br>        echo &quot;echo hello worlds\\r\\n&quot;;<br>    }<br>}<br><br>$instance = Singleton::getInstance();<br>$instance-&gt;testEcho();<br>$instance1 = Singleton::getInstance();<br>$instance2 = Singleton::getInstance();<br><br>","like_count":2,"discussions":[{"author":{"id":1388018,"avatar":"https://static001.geekbang.org/account/avatar/00/15/2d/f2/07b94d3c.jpg","nickname":"养成好习惯","note":"","ucode":"7919C9592E2B2C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":568952,"discussion_content":"php属于静态方式","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651280071,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177867,"user_name":"Monday","can_delete":false,"product_type":"c1","uid":1250907,"ip_address":"","ucode":"77B9BACC783598","user_header":"https://static001.geekbang.org/account/avatar/00/13/16/5b/83a35681.jpg","comment_is_top":false,"comment_ctime":1581517937,"is_pvip":false,"discussion_count":4,"race_medal":0,"score":"10171452529","product_id":100039001,"comment_content":"总感觉枚举的实现方式没理解透彻，是不是这个本章例子比较特殊啊。<br>如果要返回的单例对象就是SingletonEnum对象，怎么用枚举的方式实现呢？求code。","like_count":2,"discussions":[{"author":{"id":1683130,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLWIUF31dicT1YBTxWNX0uvbMxl15UwdlwFicGhNo0DsQ7CbM6k16EQxK7bwSMcicLGMdYto4jGPTvrg/132","nickname":"乾坤瞬间","note":"","ucode":"15BDCF29CBF8EB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":179971,"discussion_content":"枚举本质就是static的，即在java的运行时环境中没有枚举的概念，枚举只停留在编译阶段，换句话说，枚举类在经过编译之后是以static的方式存在的，所以，枚举方法可以理解为静态方法，多一种创建单例的方法","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1582267247,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394542,"discussion_content":"枚举类，编译后，就是一个final修饰的类，而里边的方法，自然都是同一个对象在调用，所以就实现了单例效果。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631931704,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1118242,"avatar":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","nickname":"改名不换人","note":"","ucode":"7E25577829FA0F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263056,"discussion_content":"个人理解，返回单例对象的目的就是要调用这个对象的方法，所以Enum.INSTANCE.getId()就是我们要做的事儿.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589167661,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1054178,"avatar":"https://static001.geekbang.org/account/avatar/00/10/15/e2/c21553c4.jpg","nickname":"HYM","note":"","ucode":"4E82D9A285DAFF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":175968,"discussion_content":"enum SingletonEnum{INSTANCE}=====>调用：SingletonEnum.INSTANCE","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582010121,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175830,"user_name":"Summer  空城","can_delete":false,"product_type":"c1","uid":1337146,"ip_address":"","ucode":"6BDBB70FB6F709","user_header":"https://static001.geekbang.org/account/avatar/00/14/67/3a/0dd9ea02.jpg","comment_is_top":false,"comment_ctime":1580865241,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"10170799833","product_id":100039001,"comment_content":"王老师这篇讲解的非常棒，赞！","like_count":2},{"had_liked":false,"id":319158,"user_name":"charmsongo","can_delete":false,"product_type":"c1","uid":1609051,"ip_address":"","ucode":"4FBEE716E93A1A","user_header":"https://static001.geekbang.org/account/avatar/00/18/8d/5b/383a49e4.jpg","comment_is_top":false,"comment_ctime":1635646739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5930614035","product_id":100039001,"comment_content":"1、为什么要使用单例？<br>\t实战案例一：处理资源冲突-类级别锁 分布式锁 并发队列 单例模式<br>\t实战案例二：表示全局唯一类-从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类。<br>2、如何实现一个单例？<br>\t1. 饿汉式-类加载时创建instance 静态实例，线程安全，不支持延迟加载<br>\t2. 懒汉式-使用时创建实例，公有方法加大锁synchronzed，并发度低，频繁使用实例会有性能瓶颈<br>\t3. 双重检测-既支持延迟加载、又支持高并发，公有方法内synchronzed设为类级别锁<br>\t\t\t\t-低版本JDK会因为指令重排序出问题，instance 成员变量加上 volatile 关键字，禁止指令重排序才行，高版本JDk已解决（不知哪个版本，方法是对象new和初始化设计为原子操作）<br>\t4. 静态内部类-类似饿汉式，但又能做到了延迟加载<br>\t\t\t\t-外部类加载时并不会创建内部类实例，只有调用getInstance()才会加载<br>\t5. 枚举-最简单的实现方式","like_count":1},{"had_liked":false,"id":314640,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1633272279,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5928239575","product_id":100039001,"comment_content":"业务类基本都是单例模式，防止重复创建，节省资源","like_count":1},{"had_liked":false,"id":296300,"user_name":"北极的大企鹅","can_delete":false,"product_type":"c1","uid":1045577,"ip_address":"","ucode":"8935346D08E109","user_header":"https://static001.geekbang.org/account/avatar/00/0f/f4/49/2add4f6b.jpg","comment_is_top":false,"comment_ctime":1622890640,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5917857936","product_id":100039001,"comment_content":"不错,有些微信公众号以技术文章开始,却以八卦杂文结束,可悲!","like_count":1},{"had_liked":false,"id":241872,"user_name":"Promise°","can_delete":false,"product_type":"c1","uid":1139384,"ip_address":"","ucode":"0BFDBDAD852D6D","user_header":"https://static001.geekbang.org/account/avatar/00/11/62/b8/bb9657c6.jpg","comment_is_top":false,"comment_ctime":1597480121,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5892447417","product_id":100039001,"comment_content":"在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？<br>单例的:springmvc 多例的:status2<br>springmvc的参数都是在方法参数上面的所以是单例即可 用多例的话没必要也影响性能的开销<br>status2的参数是在类上面的 所以必须是多例的 不然的话并发的情况下获取到的数据 就会不一致","like_count":1},{"had_liked":false,"id":234271,"user_name":"冬渐暖","can_delete":false,"product_type":"c1","uid":1586800,"ip_address":"","ucode":"907E41AAE9A36C","user_header":"https://static001.geekbang.org/account/avatar/00/18/36/70/00122b24.jpg","comment_is_top":false,"comment_ctime":1594632530,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5889599826","product_id":100039001,"comment_content":"<br>单例模式相对于类级别锁的好处是，不用创建那么多 Logger 对象(只用再开始的时候创建一次，类似饿汉，其它的地方就可以直接通过别名来拿)，一方面节省内存空间，另一方面节省系统文件句柄（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。<br>单例的注意的地方<br>1.函数要是private ，省的其它人去new 出来<br>2.考虑创建时候的线程安全问题<br>3.考虑是否要延迟加载<br>4.考虑getInstance()的时候是否特别耗内存。<br><br>饿汉的好处：在类加载的时候就已经创建了对象，所以是线程安全的(不会导致a创建一下，b创建一下)。缺点也是这个。<br>如果是实例化时间较长，则还是建议用饿汉，因为是将这些操作提前到程序启动加载类的时候就执行，而不是像懒汉一样把这个重的操作放到用的时候才执行。<br>有问题要早点暴露(fail-fast原则) 早发现，早修复。<br><br>懒汉的好处:用的时候才加载，避免掉创建一些没用的对象。<br>缺点是 你每次准备实例化的时候 为了线程安全，都应该加把锁，确保判空和new 是在同一个操作里面。因为考虑了线程安全，所以每次加锁放锁都要消耗资源，，如果大量调用，性能可能有点问题。其实就是不支持高并发<br> if (instance == null) {      <br>instance = new IdGenerator();    <br>}<br><br>双重检测其实很简单，就是先判断有没有被实例化，如果有，在加锁再判断一次然后实例化。当然缺点就是多了层判断，消耗了内存(虽然看起来消耗小，但是堆起来就多了，不过因为对象只会生成一次，也不会消耗很多)<br><br>&#47;&#47; 先判断有没有<br>if (instance == null) {<br>   synchronized (IdGenerator.class) { &#47;&#47; 没有的话直接对类加锁<br>      &#47;&#47;  <br>      if (instance == null) {&#47;&#47; 再判断有没有，原子操作<br>         instance = new IdGenerator();<br>      }<br>   }<br>}<br><br><br>静态内部类实现的原理，就是调用静态的方法来final赋值，因为是静态方法的静态内部类，所以只会在调用这个静态方法的时候才创建，因为静态方法只会执行一次。。。。<br><br>private static class SingletonHolder {<br>   private static final IdGenerator instance = new IdGenerator();<br>}<br><br><br><br>枚举类型实现单例：<br>根据不同的枚举入参，获取不同的实例对象<br>public class SimpleTest {<br>   public static void main (String[] args) {<br>      SimpleTest instanceInstance = EnumTest.INSTANCE.getTask(EnumTest.INSTANCE);<br>      System.out.println(&quot;&quot;);<br>   }<br>   <br>   private enum EnumTest {<br>      INSTANCE() {<br>         @Override<br>         public SimpleTest getTask (Object o) {<br>            return new SimpleTest();<br>         }<br>      }, WDDTEST() {<br>         @Override<br>         public SimpleTest getTask (Object o) {<br>            &#47;&#47; 另一种生成<br>            return new SimpleTest();<br>         }<br>      };<br>      <br>      public SimpleTest getTask (Object o) {<br>         return null;<br>      }<br>      <br>   }<br>   <br>}<br><br>针对静态内部类和枚举类型的，因为是直接调用某个类然后赋值给引用，只生成一个对象，不用考虑线程安全的问题，所以不用先判断是不是null。<br><br>","like_count":1},{"had_liked":false,"id":233850,"user_name":"skying","can_delete":false,"product_type":"c1","uid":1041865,"ip_address":"","ucode":"E7CFF50AB64BB1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e5/c9/1061582b.jpg","comment_is_top":false,"comment_ctime":1594477829,"is_pvip":true,"replies":[{"id":"86363","content":"比较难模拟出来的，因为毕竟要并发极端情况下（有竞争的情况下，就像我画的那张图一样）才会发生覆盖的情况。我的样例都在文章里了。","user_name":"作者回复","comment_id":233850,"uid":"1190123","ip_address":"","utype":1,"ctime":1594598886,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"5889445125","product_id":100039001,"comment_content":"争哥，你好！<br>我这边想模拟出 你文章中 的Logger类写入文件会重复的场景。<br>但没复现出来，<br>不知道你这边有 样例代码没有。","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501187,"discussion_content":"比较难模拟出来的，因为毕竟要并发极端情况下（有竞争的情况下，就像我画的那张图一样）才会发生覆盖的情况。我的样例都在文章里了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594598886,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1222119,"avatar":"https://static001.geekbang.org/account/avatar/00/12/a5/e7/815acbf7.jpg","nickname":"warm_day","note":"","ucode":"3CD078E809497C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579945,"discussion_content":"太难模拟了，根本没法模拟出来","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1657782695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":225690,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591835427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5886802723","product_id":100039001,"comment_content":"synchronized(this) 对象级别锁、synchronized(loger.class) 类级别锁。","like_count":1},{"had_liked":false,"id":224861,"user_name":"西柚","can_delete":false,"product_type":"c1","uid":1306889,"ip_address":"","ucode":"3DDC5D0972DAB0","user_header":"https://static001.geekbang.org/account/avatar/00/13/f1/09/a597fe8d.jpg","comment_is_top":false,"comment_ctime":1591578657,"is_pvip":false,"replies":[{"id":"84001","content":"信小争哥就对了","user_name":"作者回复","comment_id":224861,"uid":"1190123","ip_address":"","utype":1,"ctime":1592526807,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"5886545953","product_id":100039001,"comment_content":"老师讲的太好了，逻辑清晰、缜密。思考问题的方式非常值得学习~","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":497634,"discussion_content":"信小争哥就对了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592526807,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":219370,"user_name":"somenzz","can_delete":false,"product_type":"c1","uid":1187197,"ip_address":"","ucode":"EA59A170DF8910","user_header":"https://static001.geekbang.org/account/avatar/00/12/1d/7d/368df396.jpg","comment_is_top":false,"comment_ctime":1590019748,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5884987044","product_id":100039001,"comment_content":"Python实现单例类：<br><br>class Single(object):<br>    _instance = None<br>    def __new__(cls, *args, **kw):<br>        if cls._instance is None:<br>            cls._instance = object.__new__(cls, *args, **kw)<br>        return cls._instance<br>    def __init__(self):<br>        pass<br><br>single1 = Single()<br>single2 = Single()<br>print(id(single1) == id(single2)) # True<br><br>","like_count":1},{"had_liked":false,"id":191969,"user_name":"张三","can_delete":false,"product_type":"c1","uid":1004092,"ip_address":"","ucode":"1155528FAE1546","user_header":"https://static001.geekbang.org/account/avatar/00/0f/52/3c/d6fcb93a.jpg","comment_is_top":false,"comment_ctime":1584806606,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5879773902","product_id":100039001,"comment_content":"一直对Java的枚举类型不清楚","like_count":1,"discussions":[{"author":{"id":1529210,"avatar":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","nickname":"freesocean","note":"","ucode":"CAD4C80CF569D3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394543,"discussion_content":"枚举就是一个语法糖，编译后，其实就是一个final修饰的class类，提供了一些默认方法，具体可以通过javap -verbose  XXEnum.class  查看旧明白了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1631931820,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178619,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1581760308,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876727604","product_id":100039001,"comment_content":"1、java.lang.reflect.Proxy类。因为代理是通用的类代理，对所有类进行增强，一个实例就够了。<br>java.lang.Runtime类，每个Java应用程序都有一个Runtime类的实例，该实例允许该应用程序与应用程序运行所在的环境进行交互。一个java应用程序对应一个环境。所以设计成单例<br>2、使用将FileWriter对象作为静态成员变量来使用。<br><br>老师没讲到序列化和反射可以破坏单例的情况。有兴趣可以研究下","like_count":1},{"had_liked":false,"id":176969,"user_name":"相逢是缘","can_delete":false,"product_type":"c1","uid":1060730,"ip_address":"","ucode":"CB299F53A95654","user_header":"https://static001.geekbang.org/account/avatar/00/10/2f/7a/ab6c811c.jpg","comment_is_top":false,"comment_ctime":1581238522,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876205818","product_id":100039001,"comment_content":"打卡<br>1、单例模式的定义：<br>一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。<br>2、单例的用途：<br>1）处理资源访问冲突问题<br>2）处理数据在系统中只应保存一份<br>3、如何实现一个单例类<br>1）饿汉模式<br>类加载时，instance实例已经创建好；<br>2）懒汉模式<br>延迟加载，但是getInstance需要加锁，导致并发度很低<br>public static synchronized IdGenerator getInstance() { <br>if (instance == null) {<br>instance = new IdGenerator(); <br>} <br>return instance;<br> }<br>3）双重检测<br>只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。<br>（支持延迟加载、支持高并发）<br>public static IdGenerator getInstance() {<br> if (instance == null) { <br>synchronized(IdGenerator.class) { &#47;&#47; 此处为类级别的锁 <br>if (instance == null) {<br> instance = new IdGenerator(); <br>} <br>} <br>} <br>return instance;<br> }<br>4）静态内部类<br>insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。<br>private static class SingletonHolder{ <br>private static final IdGenerator instance = new IdGenerator(); <br>} <br>public static IdGenerator getInstance() {<br>return SingletonHolder.instance;<br> }<br>5）枚举<br><br>","like_count":1},{"had_liked":false,"id":176353,"user_name":"天天向上卡索","can_delete":false,"product_type":"c1","uid":1009850,"ip_address":"","ucode":"E3724C3B39BD3F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/68/ba/c0cf8bf3.jpg","comment_is_top":false,"comment_ctime":1581040739,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5876008035","product_id":100039001,"comment_content":"之前做WP开发的时候用到的硬件如Camera大多是单例，之前看微软的源码有的单例使用并发字典来实现的","like_count":1},{"had_liked":false,"id":176167,"user_name":"沈康","can_delete":false,"product_type":"c1","uid":1611025,"ip_address":"","ucode":"02AFA50738AB8E","user_header":"https://static001.geekbang.org/account/avatar/00/18/95/11/eb431e52.jpg","comment_is_top":false,"comment_ctime":1580977448,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5875944744","product_id":100039001,"comment_content":"1、java bean大部分都是单例吧，例如我们的service bean，单例也是为了复用类和资源共享吧，但是要注意单例需要无状态，有状态的则要考虑线程安全问题<br>2、如果线程安全的话，共享一个类就可以了，依赖注入","like_count":1,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504516,"discussion_content":"是的，核心是人的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598834208,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1232973,"avatar":"https://static001.geekbang.org/account/avatar/00/12/d0/4d/2116c1a4.jpg","nickname":"Bravery168","note":"","ucode":"DB08AEFBD6DF2B","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":384798,"discussion_content":"人和公司组织制度，两者都有很大的影响。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626756795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2550743,"avatar":"https://static001.geekbang.org/account/avatar/00/26/eb/d7/90391376.jpg","nickname":"if...else...","note":"","ucode":"D0565908C99695","race_medal":4,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":381695,"discussion_content":"我就是小公司的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625189755,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2277321,"avatar":"https://static001.geekbang.org/account/avatar/00/22/bf/c9/7f23f3ec.jpg","nickname":"momo","note":"","ucode":"00DB6D76B7B25A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343356,"discussion_content":"沧浪之水浊兮","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1611021004,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":175820,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1580839344,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5875806640","product_id":100039001,"comment_content":"不同线程的日志写到不同的文件，就不用担心线程安全了。例如用线程id做日志后缀。","like_count":1,"discussions":[{"author":{"id":2324017,"avatar":"","nickname":"Geek_92a994","note":"","ucode":"D573E3260C0446","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370657,"discussion_content":"有加班工资没","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619497655,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357831,"user_name":"Fitch Kuma","can_delete":false,"product_type":"c1","uid":1318028,"ip_address":"广东","ucode":"9783C3D4873020","user_header":"https://static001.geekbang.org/account/avatar/00/14/1c/8c/3af20a8e.jpg","comment_is_top":false,"comment_ctime":1663668764,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1663668764","product_id":100039001,"comment_content":"请问这个课程有配套的代码仓库么？","like_count":0},{"had_liked":false,"id":351428,"user_name":"warm_day","can_delete":false,"product_type":"c1","uid":1222119,"ip_address":"","ucode":"3CD078E809497C","user_header":"https://static001.geekbang.org/account/avatar/00/12/a5/e7/815acbf7.jpg","comment_is_top":false,"comment_ctime":1657782735,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1657782735","product_id":100039001,"comment_content":"模拟ogger多线程下写入覆盖问题，太难模拟了，模拟不出来","like_count":0},{"had_liked":false,"id":347036,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1653635901,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1653635901","product_id":100039001,"comment_content":"说到日志这一块，slf4j这块其实是最后放到一个队列里面去，这种其实也能做到一个不会被覆盖的一个问题。","like_count":0},{"had_liked":false,"id":344187,"user_name":"KK","can_delete":false,"product_type":"c1","uid":1324863,"ip_address":"","ucode":"FFC31A3FE3A285","user_header":"https://static001.geekbang.org/account/avatar/00/14/37/3f/a9127a73.jpg","comment_is_top":false,"comment_ctime":1651332381,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1651332381","product_id":100039001,"comment_content":"单例模式模式有作用呢？","like_count":0},{"had_liked":false,"id":336967,"user_name":"疯狂的石头","can_delete":false,"product_type":"c1","uid":1763900,"ip_address":"","ucode":"65CE6EB494FDCA","user_header":"https://static001.geekbang.org/account/avatar/00/1a/ea/3c/24cb4bde.jpg","comment_is_top":false,"comment_ctime":1646495543,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646495543","product_id":100039001,"comment_content":"怎么看不到评论","like_count":0},{"had_liked":false,"id":334505,"user_name":"℡ __ 柚稚","can_delete":false,"product_type":"c1","uid":1740282,"ip_address":"","ucode":"07A8CBFC563C5E","user_header":"https://static001.geekbang.org/account/avatar/00/1a/8d/fa/93e48f3b.jpg","comment_is_top":false,"comment_ctime":1644980102,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1644980102","product_id":100039001,"comment_content":"争哥，我有个疑问，上面id生成的类使用单例保证id唯一，现实中一个服务基本都会在多台机器上部署多个实例，这样的话单例的作用是不是就失效了","like_count":0},{"had_liked":false,"id":328504,"user_name":"江南一笑","can_delete":false,"product_type":"c1","uid":2234620,"ip_address":"","ucode":"E38938A1178827","user_header":"https://static001.geekbang.org/account/avatar/00/22/18/fc/4f92ee4e.jpg","comment_is_top":false,"comment_ctime":1640756540,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1640756540","product_id":100039001,"comment_content":"枚举是提前加载还是延后加载？","like_count":0},{"had_liked":false,"id":326860,"user_name":"MrVito","can_delete":false,"product_type":"c1","uid":1252169,"ip_address":"","ucode":"716FF6F8871706","user_header":"https://static001.geekbang.org/account/avatar/00/13/1b/49/ddefc656.jpg","comment_is_top":false,"comment_ctime":1639724785,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1639724785","product_id":100039001,"comment_content":"问题二. 系统级别 OS_APPEND","like_count":0},{"had_liked":false,"id":312662,"user_name":"freesocean","can_delete":false,"product_type":"c1","uid":1529210,"ip_address":"","ucode":"CAD4C80CF569D3","user_header":"https://static001.geekbang.org/account/avatar/00/17/55/7a/d44df1d6.jpg","comment_is_top":false,"comment_ctime":1631932945,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1631932945","product_id":100039001,"comment_content":"看完本文有三点收获：<br>1.单例模式有多种实现方式，每种方式各有优缺点，时间与内存的权衡，要求快（饿汉模式），内存比较宝贵，那就采用懒汉模式。不同方式，有基本实现和改进后实现方式。<br>2.线程安全保证方面，需要添加对象锁，以及volatile关键字<br>3.以上准则，其本质是JVM的原理导致：比如基于类的加载机制，静态内部类实现方式才行得通。<br>  volatile在JVM层面的语义保证了禁止指令优化重排，synchronized关键字对应的jvm指令监控，才保证了锁的实现，枚举类编译后是一个final修饰的class，才让看似奇怪的枚举也可以实现单例。","like_count":0},{"had_liked":false,"id":307003,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1628822519,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628822519","product_id":100039001,"comment_content":"&#47;**<br> * 单例模式懒汉式实现<br> *&#47;<br>class Singleton {<br>private:<br>    Singleton() {} &#47;&#47;构造函数私有<br>public:<br>    static Singleton&amp; getInstance() {<br>        static Singleton instance;<br>        return instance;<br>    }<br>};<br><br>c++11后是线程安全的，C++11规定了local static在多线程条件下的初始化行为，要求编译器保证了内部静态变量的线程安全性。<br><br>那争哥，在c++11后，这种懒汉式的实现方式是不是更好呢？","like_count":0},{"had_liked":false,"id":306995,"user_name":"Geek_842f07","can_delete":false,"product_type":"c1","uid":2698987,"ip_address":"","ucode":"ED772AF755FE7E","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/WP4Ge8ABcINFkccKaNYKibicFnI0JAoojBBAUGrichNeRAgzm5RGbHG7GqYrFX3ELEzenuEbicQHJy2HZ72RxSOuMA/132","comment_is_top":false,"comment_ctime":1628820692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1628820692","product_id":100039001,"comment_content":"c++ iostream设置为单例，因为io资源只有一份","like_count":0},{"had_liked":false,"id":305063,"user_name":"乔帆 Kayla","can_delete":false,"product_type":"c1","uid":1883514,"ip_address":"","ucode":"81944832230BC4","user_header":"https://static001.geekbang.org/account/avatar/00/1c/bd/7a/37df606b.jpg","comment_is_top":false,"comment_ctime":1627797555,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1627797555","product_id":100039001,"comment_content":"双重检测的代码中，变量instance没有使用final修饰，是因为volatile不可以修饰使用final的实例变量或静态变量吗？","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":501192,"discussion_content":"有的也比较水，多包涵哈，整体有收获、大部分有收获就值！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594598691,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":292672,"user_name":"Nacol","can_delete":false,"product_type":"c1","uid":1609735,"ip_address":"","ucode":"B645ECB9540B95","user_header":"https://static001.geekbang.org/account/avatar/00/18/90/07/41d19261.jpg","comment_is_top":false,"comment_ctime":1620917210,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620917210","product_id":100039001,"comment_content":"争哥，<br>Java 自然实现了枚举的单例模式，<br>但是我在 JDK1.8 下排查 GC 问题的时候，<br>使用 jmap -histo pid 命令 dump 下了堆内存，<br>发现其中一个枚举的数量是 89个，请帮忙解惑。<br>","like_count":0},{"had_liked":false,"id":292247,"user_name":"cccy七里十一","can_delete":false,"product_type":"c1","uid":1963604,"ip_address":"","ucode":"38858D844ECC72","user_header":"https://static001.geekbang.org/account/avatar/00/1d/f6/54/bf649b32.jpg","comment_is_top":false,"comment_ctime":1620737996,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620737996","product_id":100039001,"comment_content":"ma两个要后续了解的内容：<br>1. 静态内部类相关<br>2.枚举","like_count":0},{"had_liked":false,"id":289066,"user_name":"yang","can_delete":false,"product_type":"c1","uid":1940562,"ip_address":"","ucode":"67C86E09BA6E4B","user_header":"https://static001.geekbang.org/account/avatar/00/1d/9c/52/dc770378.jpg","comment_is_top":false,"comment_ctime":1618840184,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1618840184","product_id":100039001,"comment_content":"很少写代码，惭愧。就想问一下，在java里实现单例类典型的关键字是private static final，对吗？","like_count":0,"discussions":[{"author":{"id":1079657,"avatar":"https://static001.geekbang.org/account/avatar/00/10/79/69/5960a2af.jpg","nickname":"王智","note":"","ucode":"0335277F255F7A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390305,"discussion_content":"理解每一个关键字的含义就好：static表示类成员变量，final表示的是对象本身不可变","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629770954,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":288047,"user_name":"Better me","can_delete":false,"product_type":"c1","uid":1261959,"ip_address":"","ucode":"CADF08D357489A","user_header":"https://static001.geekbang.org/account/avatar/00/13/41/87/46d7e1c2.jpg","comment_is_top":false,"comment_ctime":1618280692,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1618280692","product_id":100039001,"comment_content":"1、Java jdk中的Runtime类设计为单例，每个应用应该只有一个运行时对象<br>2、由于FileWriter内部实现了对象级别的线程安全，只需所有Logger对象共用一个FileWriter对象即可，private static final FileWriter writer = new FileWriter(file, true);","like_count":0},{"had_liked":false,"id":281694,"user_name":"微末凡尘","can_delete":false,"product_type":"c1","uid":1099525,"ip_address":"","ucode":"25EDFD0914D0F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c7/05/19c5c255.jpg","comment_is_top":false,"comment_ctime":1614849521,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1614849521","product_id":100039001,"comment_content":"在php语言中，是单线程模式的，不需要考虑线程安全的问题","like_count":0},{"had_liked":false,"id":271499,"user_name":"慎独明强","can_delete":false,"product_type":"c1","uid":1965699,"ip_address":"","ucode":"DC2F7F2C0C8F60","user_header":"https://static001.geekbang.org/account/avatar/00/1d/fe/83/df562574.jpg","comment_is_top":false,"comment_ctime":1609667402,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609667402","product_id":100039001,"comment_content":"单例模式:懒汉式，饿汉式，双重检测，静态内部类，以及枚举方式。","like_count":0,"discussions":[{"author":{"id":2396269,"avatar":"https://static001.geekbang.org/account/avatar/00/24/90/6d/705f3874.jpg","nickname":"大雄","note":"","ucode":"BABD97EBBB1394","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":343403,"discussion_content":"同 在准备是不是要跑路 感觉接手这种代码一点意义也没有，更不可能给你重构的机会","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1611033724,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271376,"user_name":"乐多🙉","can_delete":false,"product_type":"c1","uid":2346451,"ip_address":"","ucode":"AE515FFF1CA582","user_header":"https://static001.geekbang.org/account/avatar/00/23/cd/d3/7e4d80e8.jpg","comment_is_top":false,"comment_ctime":1609583054,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1609583054","product_id":100039001,"comment_content":"public class DCSingleton {<br>    private static DCSingleton dCSingleton;<br><br>    private DCSingleton() {<br>    }<br><br>    public static DCSingleton getInstance() {<br>        if (null == dCSingleton) {<br>            synchronized (DCSingleton.class) {<br>                if (null == dCSingleton) {<br>                    &#47;&#47;todo 不懂这样是否是原子操作<br>                    AtomicReference&lt;DCSingleton&gt; atomicReference = new AtomicReference&lt;DCSingleton&gt;();<br>                    atomicReference.set(new DCSingleton());<br>                    dCSingleton = atomicReference.get();<br>                }<br>            }<br>        }<br>        return dCSingleton;<br>    }<br>}<br><br>&#47;&#47;todo 不懂这样是否是原子操作<br>&#47;&#47;todo 不懂这样是否是原子操作<br>&#47;&#47;todo 不懂这样是否是原子操作<br>","like_count":0,"discussions":[{"author":{"id":2820671,"avatar":"","nickname":"require","note":"","ucode":"3AA3DCE0CD73E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543016,"discussion_content":"到时候你还在不在都难说了，就当是给下个人留下惊喜了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1640933086,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":271217,"user_name":"daiwf","can_delete":false,"product_type":"c1","uid":1793425,"ip_address":"","ucode":"2C78451F5488BD","user_header":"https://static001.geekbang.org/account/avatar/00/1b/5d/91/9b6fb4ad.jpg","comment_is_top":false,"comment_ctime":1609475961,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609475961","product_id":100039001,"comment_content":"大佬就是大佬，让我很清晰的理解了单例模式！看这系列的教程就如同看一本武功秘籍。我已经迫不及待继续修炼了。","like_count":0},{"had_liked":false,"id":270709,"user_name":"靠人品去赢","can_delete":false,"product_type":"c1","uid":1301286,"ip_address":"","ucode":"7A20F9EBE847E1","user_header":"https://static001.geekbang.org/account/avatar/00/13/db/26/54f2c164.jpg","comment_is_top":false,"comment_ctime":1609225585,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1609225585","product_id":100039001,"comment_content":"这里说一下延迟加载这个东西，其实就是真正用的时候再去加载对应的对象，而不是一开始就加载上去。<br>原因：内存有限，对象过大，都会导致直接加载的话，对内存有影响或者影响效率<br>解决：啥时候用我再加载，那啥时候用呢，那就是getInstance()的时候，去new一个对象出来","like_count":0},{"had_liked":false,"id":268083,"user_name":"海鸟","can_delete":false,"product_type":"c1","uid":1028311,"ip_address":"","ucode":"EBAF85D1EFFAAB","user_header":"https://static001.geekbang.org/account/avatar/00/0f/b0/d7/22ce0046.jpg","comment_is_top":false,"comment_ctime":1608047029,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608047029","product_id":100039001,"comment_content":"我记得 Linux 下多进程（线程）操作同一个文件，如果用 append mode 写的话，不会相互覆盖吧","like_count":0},{"had_liked":false,"id":266611,"user_name":"淤白","can_delete":false,"product_type":"c1","uid":1206503,"ip_address":"","ucode":"D1E65DC40DAF68","user_header":"https://static001.geekbang.org/account/avatar/00/12/68/e7/ee47d0e2.jpg","comment_is_top":false,"comment_ctime":1607414705,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1607414705","product_id":100039001,"comment_content":"打完：用java实现了文中代码案例。","like_count":0},{"had_liked":false,"id":264094,"user_name":"David","can_delete":false,"product_type":"c1","uid":1021825,"ip_address":"","ucode":"22CBBC13FC97A9","user_header":"https://static001.geekbang.org/account/avatar/00/0f/97/81/e1eaf621.jpg","comment_is_top":false,"comment_ctime":1606352189,"is_pvip":true,"replies":[{"id":"96082","content":"嗯嗯 ������","user_name":"作者回复","comment_id":264094,"uid":"1190123","ip_address":"","utype":1,"ctime":1606700667,"user_name_real":"王争"}],"discussion_count":1,"race_medal":0,"score":"1606352189","product_id":100039001,"comment_content":"1. Spring中的一些连接工厂类，Service类都默认是单例模式 这些对象是一般消耗资源或者类似于工具类没有共享变量竞争问题。<br>2. FileWritter设计成 static final的可以使用jvm类加载特性解决竞争问题。但是可测试性变差","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":504730,"discussion_content":"感觉也没啥技巧，先把核心业务理顺，边整理边输出，把不清楚的也记下来，慢慢记下来的所有问题都搞清楚，基本上就搞清楚的差不多了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598833757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":260586,"user_name":"蜗牛","can_delete":false,"product_type":"c1","uid":1300285,"ip_address":"","ucode":"A99C9C890F95E4","user_header":"https://static001.geekbang.org/account/avatar/00/13/d7/3d/a076faf1.jpg","comment_is_top":false,"comment_ctime":1605065883,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605065883","product_id":100039001,"comment_content":"public class IdGenerator {<br>    private static volatile IdGenerator instance;<br><br>    public static IdGenerator getInstance() {<br>        &#47;**<br>         * 1.使用局部变量localRef将减少访问volatile变量的次数，也就减少了访问主存的次数，提升性能<br>         * 如果不使用localRef，那么当不为null的时候将不得不访问volatile变量两次，一次是在检查null，另一次是在方法返回时；<br>         *&#47;<br>        IdGenerator localRef = instance;<br>        if (null == localRef) {<br>            synchronized (IdGenerator.class) {<br>                &#47;**<br>                 * 2.在获得锁后，刷新局部变量为最新值，因为此时volatile变量可能已经更改<br>                 *&#47;<br>                localRef = instance;<br>                if (null == localRef) {<br>                    instance = localRef = new IdGenerator();<br>                }<br>            }<br>        }<br>        &#47;**<br>         * 3.在方法返回时访问volatile变量<br>         *&#47;<br>        return localRef;<br>    }<br>}<br><br>参考链接：<br>https:&#47;&#47;www.javacodemonk.com&#47;threadsafe-singleton-design-pattern-java-806ad7e6","like_count":0},{"had_liked":false,"id":257384,"user_name":"天马行空","can_delete":false,"product_type":"c1","uid":1740810,"ip_address":"","ucode":"5B019ABAFD1716","user_header":"https://static001.geekbang.org/account/avatar/00/1a/90/0a/4d161db0.jpg","comment_is_top":false,"comment_ctime":1603952669,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603952669","product_id":100039001,"comment_content":"每一章的内容都是精华所在，争哥造诣很高啊","like_count":0},{"had_liked":false,"id":254762,"user_name":"Charles | 姜海龙","can_delete":false,"product_type":"c1","uid":1178235,"ip_address":"","ucode":"17BA74D1684184","user_header":"https://static001.geekbang.org/account/avatar/00/11/fa/7b/f89a398b.jpg","comment_is_top":false,"comment_ctime":1603183055,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603183055","product_id":100039001,"comment_content":"日记：1.单列模式----一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。","like_count":0},{"had_liked":false,"id":247355,"user_name":"Evan","can_delete":false,"product_type":"c1","uid":1344281,"ip_address":"","ucode":"B877ABD0CF4661","user_header":"https://static001.geekbang.org/account/avatar/00/14/83/19/0a3fe8c1.jpg","comment_is_top":false,"comment_ctime":1599666840,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1599666840","product_id":100039001,"comment_content":"五个方式创建单例，最近就是枚举，静态也非常简单。类型加载也是单例，连接器之类是单例模式<br><br>另外关于CPU指令重排的问题，王宝令讲得很清楚，不知道目前JVM是否已经优化过了？","like_count":0},{"had_liked":false,"id":238281,"user_name":"o0oi1i","can_delete":false,"product_type":"c1","uid":1132312,"ip_address":"","ucode":"D1F6AD4AAEAFBE","user_header":"https://static001.geekbang.org/account/avatar/00/11/47/18/293cd24d.jpg","comment_is_top":false,"comment_ctime":1596110312,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1596110312","product_id":100039001,"comment_content":"打卡41","like_count":0},{"had_liked":false,"id":237505,"user_name":"Geek_9e4d78","can_delete":false,"product_type":"c1","uid":2083243,"ip_address":"","ucode":"F4FFBC06B1ABA3","user_header":"","comment_is_top":false,"comment_ctime":1595848973,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1595848973","product_id":100039001,"comment_content":"<br>双重检查锁那里有个bug，单例引用应该用volatile修饰，否则在并发时，某个请求会去到一个没有实例化完的对象","like_count":0},{"had_liked":false,"id":235505,"user_name":"大方方","can_delete":false,"product_type":"c1","uid":1354013,"ip_address":"","ucode":"621AD8F1485753","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/6cyOoRd2dROgiblAJkW6RLhUyH1wwU0NNibIIuV930eQ9TiaNT41K61kBSVkvYoDYg7mJtuEoCQY1awBmV0WW6BFg/132","comment_is_top":false,"comment_ctime":1595067124,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1595067124","product_id":100039001,"comment_content":"在unity里做项目用到的第一个设计模式就是单例模式，各种全局性质的manager，比如负责统计比分胜负的gameManager， 负责玩家信息和控制的playermanager&#47;controller， unity编程的特性导致类已经在场景里实例化为组件，但是代码里仍然有先判断 Instance==null然后再return currentObject为instance，所以应该能划归到双重检测模式吧。<br>","like_count":1,"discussions":[{"author":{"id":2068684,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eotIianb3beTzsGIte6BZxlIhEwc2ryrNBGxZy8ibKbfibVJyUS8d3ZxybAdfJwHPm13ydPC4VJP7Lbw/132","nickname":"taku","note":"","ucode":"B22DA9A4A9DC91","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":383390,"discussion_content":"整理以前写过wiki，直接在md上附上连接即可---我就是这么干的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1626076762,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231822,"user_name":"未来小娃","can_delete":false,"product_type":"c1","uid":1047329,"ip_address":"","ucode":"477D166EBB6B70","user_header":"https://static001.geekbang.org/account/avatar/00/0f/fb/21/d017438c.jpg","comment_is_top":false,"comment_ctime":1593779961,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1593779961","product_id":100039001,"comment_content":"【设计模式39】20200703<br>今天开始讲单例模式了，和网上讲单例最大的区别是从三个方面讲了单例模式：为什么使用单例模式？怎么实现？实现有哪些问题？怎么优化？这里重点要清楚什么场景使用？一定是全剧唯一的实例才使用。另外单例模式最常会遇到的问题是双重检查锁会有问题？主要问题在于无法应对高并发的场景，那么最简单的方法自然是加锁但是加锁因为指令重排序也会有问题，但是对于jdk8之后的版本是没有这个问题的，因为只需要把创建和加载变为一个原子操作即可。但是实现总归不够优雅，匿名内部类和枚举是更简洁的实现，看过jdk源码的应该知道实现方式是枚举。","like_count":0},{"had_liked":false,"id":231448,"user_name":"蹦哒","can_delete":false,"product_type":"c1","uid":1458931,"ip_address":"","ucode":"56591A657DE7C7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83epcs6PibsP9vEXv4EibUw3bhQPUK04zRTOvfrvF08TwM67xPb1LBh2uRENHQwo2VqYfC5GhJmM7icxHA/132","comment_is_top":false,"comment_ctime":1593678803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593678803","product_id":100039001,"comment_content":"细节注意点：单例解决冲突问题的时候，还得依赖比如FileWriter 是对象级别线程安全的","like_count":0},{"had_liked":false,"id":231105,"user_name":"西门吹牛","can_delete":false,"product_type":"c1","uid":1508990,"ip_address":"","ucode":"E5D3624DDE1E83","user_header":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","comment_is_top":false,"comment_ctime":1593583939,"is_pvip":false,"replies":[{"id":"86254","content":"我建议你去看下极客的并发专栏😂","user_name":"作者回复","comment_id":231105,"uid":"1190123","ip_address":"","utype":1,"ctime":1594388254,"user_name_real":"王争"}],"discussion_count":2,"race_medal":0,"score":"1593583939","product_id":100039001,"comment_content":"其实有一点不太理解，希望老师解答。<br>双层检查，加volatile，根据java内存模型，volatile保证的是可见性，也就是说，给变量赋值的操作，会被另一线程看到，这样，另一线程拿到的还是地址，这时候，内存一定初始化完成了吗？<br>是不是可以理解为，这个volatile 的写操作 happen-before 与后续的读操作，就相当于是，从语言层面考虑，而不是指令层面的。<br>如果从指令层面考虑，这个new操作，会有三条指令，赋值完成就相当与写操作完成，对象还没初始化完成，这时候别的线程读到还没初始化的地址值会报空指针异常；<br>如果从语言层面考虑，这个new语句，相当于写操作完成，就代表这个操作对应的所有指令都完成了，所以后续能读到已经初始化的值。<br>这个happen-before规则是从语言层面考虑还是指令层面？<br>","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":500160,"discussion_content":"我建议你去看下极客的并发专栏😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594388254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291116,"discussion_content":"有一点要十分明确，工作内存将数据回写到主内存中，是Java层面的操作，而指令重排是cpu等底层的硬件操作。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594710813,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":226506,"user_name":"Leon Wong","can_delete":false,"product_type":"c1","uid":1073650,"ip_address":"","ucode":"B49B327367CF9E","user_header":"https://static001.geekbang.org/account/avatar/00/10/61/f2/ca989d6f.jpg","comment_is_top":false,"comment_ctime":1592124710,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592124710","product_id":100039001,"comment_content":"static 修饰writer，解决并发问题","like_count":0},{"had_liked":false,"id":225688,"user_name":"scmath","can_delete":false,"product_type":"c1","uid":1149022,"ip_address":"","ucode":"641023BB246C29","user_header":"https://static001.geekbang.org/account/avatar/00/11/88/5e/7c76f422.jpg","comment_is_top":false,"comment_ctime":1591835254,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591835254","product_id":100039001,"comment_content":"对象级别、类级别，对象锁、类锁！","like_count":0},{"had_liked":false,"id":225596,"user_name":"张三丰","can_delete":false,"product_type":"c1","uid":1155275,"ip_address":"","ucode":"3A6215A40B3B21","user_header":"https://static001.geekbang.org/account/avatar/00/11/a0/cb/aab3b3e7.jpg","comment_is_top":false,"comment_ctime":1591797747,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1591797747","product_id":100039001,"comment_content":"这是什么意思？相当于文件引用？？ FileWriter  writer？？<br><br>文件句柄也是一种资源，不能随便浪费）","like_count":0},{"had_liked":false,"id":218787,"user_name":"子夜2104","can_delete":false,"product_type":"c1","uid":1070286,"ip_address":"","ucode":"C4FF54AEA6002F","user_header":"https://static001.geekbang.org/account/avatar/00/10/54/ce/92029d2f.jpg","comment_is_top":false,"comment_ctime":1589875376,"is_pvip":false,"replies":[{"id":"86257","content":"好像jdk5之后就解决了，我有点记不清了😂","user_name":"作者回复","comment_id":218787,"uid":"1190123","ip_address":"","utype":1,"ctime":1594388592,"user_name_real":"王争"}],"discussion_count":7,"race_medal":0,"score":"1589875376","product_id":100039001,"comment_content":"我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。<br><br>老师，请问是哪个版本解决了这个问题呢?","like_count":0,"discussions":[{"author":{"id":1190123,"avatar":"https://static001.geekbang.org/account/avatar/00/12/28/eb/af064421.jpg","nickname":"王争","note":"","ucode":"2B611BE0E0EDD4","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":495573,"discussion_content":"好像jdk5之后就解决了，我有点记不清了😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1594388592,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":291117,"discussion_content":"糟了，估计争哥搞错了，jdk1.5后才实现了volatile禁止指令重排特性","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1594710969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1613052,"avatar":"https://static001.geekbang.org/account/avatar/00/18/9c/fc/0aa200b5.jpg","nickname":"Java课代表","note":"","ucode":"F17E4A1807FB12","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292480,"discussion_content":"有可能记错了，我也是为了这个问题深挖留言区","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595240695,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291117,"ip_address":""},"score":292480,"extra":""},{"author":{"id":1113744,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","nickname":"techwro","note":"","ucode":"7AF2B319F0AE1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809802,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/8a/a2d34896.jpg","nickname":"一元(wx:abley1874)","note":"","ucode":"5E7A33642FC767","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301494,"discussion_content":"我怀疑是的，之前问了争哥也没回我","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598540508,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":291117,"ip_address":""},"score":301494,"extra":""}]},{"author":{"id":1112183,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/77/a6d34ca5.jpg","nickname":"jackie","note":"","ucode":"01A4B7839CFABD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":300922,"discussion_content":"挖了评论区，在找是jdk哪个版本解决这个问题~","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598320131,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1113744,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","nickname":"techwro","note":"","ucode":"7AF2B319F0AE1B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1112183,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/77/a6d34ca5.jpg","nickname":"jackie","note":"","ucode":"01A4B7839CFABD","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":301493,"discussion_content":"老哥搞清楚了吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1598540461,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":300922,"ip_address":""},"score":301493,"extra":""},{"author":{"id":1112183,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f8/77/a6d34ca5.jpg","nickname":"jackie","note":"","ucode":"01A4B7839CFABD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1113744,"avatar":"https://static001.geekbang.org/account/avatar/00/10/fe/90/19ef108d.jpg","nickname":"techwro","note":"","ucode":"7AF2B319F0AE1B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":310350,"discussion_content":"应该是记错了，jdk1.5后才实现了volatile禁止指令重排特性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1601792032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":301493,"ip_address":""},"score":310350,"extra":""}]}]},{"had_liked":false,"id":218698,"user_name":"荒川之主","can_delete":false,"product_type":"c1","uid":2000330,"ip_address":"","ucode":"12724B4B37BEB5","user_header":"https://static001.geekbang.org/account/avatar/00/1e/85/ca/e6003d08.jpg","comment_is_top":false,"comment_ctime":1589856338,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589856338","product_id":100039001,"comment_content":"对单例的总结非常全面！","like_count":0},{"had_liked":false,"id":216012,"user_name":"改名不换人","can_delete":false,"product_type":"c1","uid":1118242,"ip_address":"","ucode":"7E25577829FA0F","user_header":"https://static001.geekbang.org/account/avatar/00/11/10/22/910f705c.jpg","comment_is_top":false,"comment_ctime":1589167721,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1589167721","product_id":100039001,"comment_content":"专栏内容和评论 质量齐飞！！收获满满~ ","like_count":0},{"had_liked":false,"id":206500,"user_name":"👅","can_delete":false,"product_type":"c1","uid":1335335,"ip_address":"","ucode":"3A3198E899DC6A","user_header":"https://static001.geekbang.org/account/avatar/00/14/60/27/fcc46413.jpg","comment_is_top":false,"comment_ctime":1586870476,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586870476","product_id":100039001,"comment_content":"第一个问题，安卓中的application类是单例的，因为它需要承载承载整个App的生命周期。<br>第二个问题，我自己只想到了队列。","like_count":0},{"had_liked":false,"id":205786,"user_name":"王      慈","can_delete":false,"product_type":"c1","uid":1298139,"ip_address":"","ucode":"EACC3D086674D8","user_header":"https://static001.geekbang.org/account/avatar/00/13/ce/db/bb1821b3.jpg","comment_is_top":false,"comment_ctime":1586739445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586739445","product_id":100039001,"comment_content":"第一反应最简单的办法不应该是依赖注入嘛。。。","like_count":0},{"had_liked":false,"id":204451,"user_name":"墨鱼","can_delete":false,"product_type":"c1","uid":1022720,"ip_address":"","ucode":"8FB5E4DCB8A024","user_header":"https://static001.geekbang.org/account/avatar/00/0f/9b/00/654be3f7.jpg","comment_is_top":false,"comment_ctime":1586401921,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1586401921","product_id":100039001,"comment_content":"单例模式： 一个类只能被实例化一次。<br><br>作用：解决有些数据只需要一份，不需要多份。<br><br><br>前端最多人用的 VUE 框架，里面有一个 vuex 数据管理，实例化 vuex 的时候，就用到了单例模式，因为只能实例化一个 vuex,通过 vuex 来管理组件的数据。如果不适用单例模式，会导致创建多个 vuex 实例，数据混乱，就起不到管理数据的功能了<br>","like_count":0},{"had_liked":false,"id":200456,"user_name":"SunshineBoy","can_delete":false,"product_type":"c1","uid":1160644,"ip_address":"","ucode":"FC54CD1815CCBA","user_header":"https://static001.geekbang.org/account/avatar/00/11/b5/c4/9148b40d.jpg","comment_is_top":false,"comment_ctime":1585587861,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1585587861","product_id":100039001,"comment_content":"filewritter有个参数 true表示追加写入，false表示等待，如果加一个CAS操作，是不是也可以避免覆盖？","like_count":0},{"had_liked":false,"id":199642,"user_name":"@%初%@","can_delete":false,"product_type":"c1","uid":1053509,"ip_address":"","ucode":"2B8A6134675ED7","user_header":"https://static001.geekbang.org/account/avatar/00/10/13/45/16c60da2.jpg","comment_is_top":false,"comment_ctime":1585493051,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"1585493051","product_id":100039001,"comment_content":"上述的单例实现还是存在问题，如果利用反射技术，是可以创建两个不同的对象，，，解决方法就是在私有化构造器里面加判断，若对象已经不为空了，就抛个异常。。。。。","like_count":0,"discussions":[{"author":{"id":1577580,"avatar":"https://static001.geekbang.org/account/avatar/00/18/12/6c/61a598e9.jpg","nickname":"苏暮沉觞","note":"","ucode":"532B816D4EF47B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":268079,"discussion_content":"所以推荐使用最后一种枚举的方式实现单例。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1589726413,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":198684,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585463821,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585463821","product_id":100039001,"comment_content":"我理解那个静态内部类应该就是利用了静态内部类的延迟加载以及一个静态对象只会初始化一份的Jvm保证来同时达到饿汉不加锁和懒汉延迟初始化的优势的","like_count":0},{"had_liked":false,"id":198681,"user_name":"白杨","can_delete":false,"product_type":"c1","uid":1743868,"ip_address":"","ucode":"B56DD94706F80B","user_header":"https://static001.geekbang.org/account/avatar/00/1a/9b/fc/a3abbe53.jpg","comment_is_top":false,"comment_ctime":1585463681,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585463681","product_id":100039001,"comment_content":"静态内部类跟枚举类型属于知识盲点，回去翻书去","like_count":0},{"had_liked":false,"id":198485,"user_name":"Bruce","can_delete":false,"product_type":"c1","uid":1876764,"ip_address":"","ucode":"BAD602A7270306","user_header":"https://static001.geekbang.org/account/avatar/00/1c/a3/1c/f947dd97.jpg","comment_is_top":false,"comment_ctime":1585453372,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585453372","product_id":100039001,"comment_content":"打卡，终于搞明白了什么是单例","like_count":0},{"had_liked":false,"id":198146,"user_name":"zhangchao","can_delete":false,"product_type":"c1","uid":1508339,"ip_address":"","ucode":"E665D153A85DE0","user_header":"https://static001.geekbang.org/account/avatar/00/17/03/f3/0bd094ad.jpg","comment_is_top":false,"comment_ctime":1585412140,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1585412140","product_id":100039001,"comment_content":"单例也不简单啊","like_count":0},{"had_liked":false,"id":187365,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1584091708,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1584091708","product_id":100039001,"comment_content":"静态内部类：<br>public class IdGenerator { private AtomicLong id = new AtomicLong(0); private IdGenerator() {} private static class SingletonHolder{ private static final IdGenerator instance = new IdGenerator(); } public static IdGenerator getInstance() { return SingletonHolder.instance; } public long getId() { return id.incrementAndGet(); }}<br><br><br><br><br>如果把这行private static final IdGenerator instance = new IdGenerator();中的final去掉，就不是线程安全了吧？？","like_count":0,"discussions":[{"author":{"id":1602420,"avatar":"https://static001.geekbang.org/account/avatar/00/18/73/74/3bf4b74e.jpg","nickname":"阿德","note":"","ucode":"186D5E19E3CB6E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":281179,"discussion_content":"我觉得去掉final没有问题呀，因为是private，所以除了自己和外部类，没有谁能够修改了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591687418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":187262,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1584070195,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584070195","product_id":100039001,"comment_content":"对象级别锁和类级别锁：<br><br>对象级别的锁：在一个对象下，不同的线程访问该对象的某个方法，会强制按照顺序执行。<br>类别的锁：在类下的所有对象下，不同的线程访问该对象的某个方法，会强制按照顺序执行。","like_count":0},{"had_liked":false,"id":187261,"user_name":"M","can_delete":false,"product_type":"c1","uid":1810576,"ip_address":"","ucode":"06F26E1D62E9C9","user_header":"https://wx.qlogo.cn/mmopen/vi_32/eLNeJNaEkwGSK7xvtamMibVLMy2MpbIqX3iaEhT7JtSnTRMRTwZ2j4HX7WAapiashbiaBDVriaXKSP0Oeic6ZAEVEXag/132","comment_is_top":false,"comment_ctime":1584070165,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1584070165","product_id":100039001,"comment_content":"1.mysql 数据库连接 单利<br><br>2.没想到<br><br>","like_count":0},{"had_liked":false,"id":186776,"user_name":"麦芽科技学堂","can_delete":false,"product_type":"c1","uid":1742968,"ip_address":"","ucode":"A90DDE4B6696BE","user_header":"https://static001.geekbang.org/account/avatar/00/1a/98/78/6459e29e.jpg","comment_is_top":false,"comment_ctime":1583921804,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583921804","product_id":100039001,"comment_content":"枚举类的单例模式没看懂，应该怎么用呢","like_count":0},{"had_liked":false,"id":186563,"user_name":"耿耿","can_delete":false,"product_type":"c1","uid":1817461,"ip_address":"","ucode":"37084BB64BAA94","user_header":"https://static001.geekbang.org/account/avatar/00/1b/bb/75/a62eca9b.jpg","comment_is_top":false,"comment_ctime":1583884473,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583884473","product_id":100039001,"comment_content":"1、.NET类库中存在单例模式的实现类，不过该类不是公开的，该类具体存在于System.dll程序集，命名空间为System；<br>2、生产者消费者","like_count":0},{"had_liked":false,"id":185955,"user_name":"一区","can_delete":false,"product_type":"c1","uid":1793770,"ip_address":"","ucode":"B5142A6276E490","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/a2mRI7BYncHCL6QWfibe7g7MWc70fSsqQibu7o9PcHjicYwo5dSnAoUN75HDDRz4GXWJdpWw59yJsMwFv3t7zSiaJQ/132","comment_is_top":false,"comment_ctime":1583730861,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1583730861","product_id":100039001,"comment_content":"老师好，请问关于高版本java已经优化解决了指令重排的问题这个咨询，是在哪里看到的啊？","like_count":0,"discussions":[{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206847,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584449644,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185664,"user_name":"否极泰来","can_delete":false,"product_type":"c1","uid":1439355,"ip_address":"","ucode":"C249173266251A","user_header":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","comment_is_top":false,"comment_ctime":1583658257,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1583658257","product_id":100039001,"comment_content":"实际上，只有很低版本的 Java 才会有这个问题。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）。<br>大神这个我有个疑惑<br>因为之前看jvm的视频说到了这块可能会出现指令重排序，自己也跑了下demo发现确实会出现，我当时是jdk8的版本，就是想知道下jdk那个版本实现了呀，有没有帖子我去看看，学习学习以后面试的时候好装个A_C","like_count":0,"discussions":[{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":206850,"discussion_content":"老哥，能分享下demo测试代码吗。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584449895,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1439355,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f6/7b/b6abcbbe.jpg","nickname":"否极泰来","note":"","ucode":"C249173266251A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":257343,"discussion_content":"百度一下吧，网上很多这种代码的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588560633,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":206850,"ip_address":""},"score":257343,"extra":""}]}]},{"had_liked":false,"id":185074,"user_name":"Heaven","can_delete":false,"product_type":"c1","uid":1694207,"ip_address":"","ucode":"FA33FBCC66C911","user_header":"https://static001.geekbang.org/account/avatar/00/19/d9/ff/b23018a6.jpg","comment_is_top":false,"comment_ctime":1583478383,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583478383","product_id":100039001,"comment_content":"1.常见的Spring中的拦 截器,对于拦 截器来说,必须是全局唯一的,没有必要对一个请求进行多次拦截,如果多次拦 截的话,可能造成两次处理,导致得到的数据不符合实际<br>2.对于日志覆盖问题,首先说最简单的,可以在类中声明一个static的FileWriter,在类加载的时候,就能拿到这个对象,但是,在实际开发中,对于这样的一个需求,肯定还是采用对消息队列的方式来进行解耦,做到性能上的进一步调优,而且保证了异步刷库,不会出现覆盖问题","like_count":0},{"had_liked":false,"id":184692,"user_name":"小文同学","can_delete":false,"product_type":"c1","uid":1001893,"ip_address":"","ucode":"48F2AEB989C12A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/a5/e4c1c2d4.jpg","comment_is_top":false,"comment_ctime":1583383106,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583383106","product_id":100039001,"comment_content":"有一些组件可以重用或必须重用的时候，就可以设计成单例了。例如Spring项目里大部分的bean都可以理解成单例。","like_count":0},{"had_liked":false,"id":184080,"user_name":"beslet","can_delete":false,"product_type":"c1","uid":1334377,"ip_address":"","ucode":"6A95C896558C11","user_header":"https://static001.geekbang.org/account/avatar/00/14/5c/69/1a4fa7d9.jpg","comment_is_top":false,"comment_ctime":1583219376,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583219376","product_id":100039001,"comment_content":"看了jdk5-13的版本特性更新列表，没有发现有new操作优化为原子操作的特性，求问是哪个版本更新的","like_count":0},{"had_liked":false,"id":184043,"user_name":"李跃爱学习","can_delete":false,"product_type":"c1","uid":1347792,"ip_address":"","ucode":"F25C038C86324A","user_header":"https://static001.geekbang.org/account/avatar/00/14/90/d0/48037ba6.jpg","comment_is_top":false,"comment_ctime":1583210665,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1583210665","product_id":100039001,"comment_content":"静态内部类代码有点问题<br>private static final IdGenerator instance = new IdGenerator();<br>这个如果是private，SingletonHolder.instance;就访问不到，应该用public吧","like_count":0},{"had_liked":false,"id":183804,"user_name":"Frode","can_delete":false,"product_type":"c1","uid":1503064,"ip_address":"","ucode":"B7B8DBF9980EA1","user_header":"https://static001.geekbang.org/account/avatar/00/16/ef/58/d05ec302.jpg","comment_is_top":false,"comment_ctime":1583137620,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1583137620","product_id":100039001,"comment_content":"<br>public class Logger {<br>  private FileWriter writer;<br>  private static final Logger instance = new Logger();<br><br>  private Logger() {<br>    File file = new File(&quot;&#47;Users&#47;wangzheng&#47;log.txt&quot;);<br>    writer = new FileWriter(file, true); &#47;&#47;true表示追加写入<br>  }<br>  <br>  public static Logger getInstance() {<br>    return instance;<br>  }<br>  <br>  public void log(String message) {<br>    writer.write(mesasge);<br>  }<br>}<br><br>&#47;&#47; Logger类的应用示例：<br>public class UserController {<br>  public void login(String username, String password) {<br>    &#47;&#47; ...省略业务逻辑代码...<br>    Logger.getInstance().log(username + &quot; logined!&quot;);<br>  }<br>}<br><br>public class OrderController {<br>  private Logger logger = new Logger();----------------------------这句话应该是多余的吧？<br>  <br>  public void create(OrderVo order) {<br>    &#47;&#47; ...省略业务逻辑代码...<br>    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());<br>  }<br>}","like_count":0},{"had_liked":false,"id":181881,"user_name":"August","can_delete":false,"product_type":"c1","uid":1747702,"ip_address":"","ucode":"21794846E0E510","user_header":"https://static001.geekbang.org/account/avatar/00/1a/aa/f6/66cc1bcb.jpg","comment_is_top":false,"comment_ctime":1582657552,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582657552","product_id":100039001,"comment_content":"获益匪浅，又加深了对单例的理解","like_count":0},{"had_liked":false,"id":181657,"user_name":"程晓擘","can_delete":false,"product_type":"c1","uid":1328354,"ip_address":"","ucode":"96986D5AE2B96C","user_header":"https://static001.geekbang.org/account/avatar/00/14/44/e2/763526e9.jpg","comment_is_top":false,"comment_ctime":1582606396,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582606396","product_id":100039001,"comment_content":"1.在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？<br>答：Android开发中，ActivityManager，ApplicationContext都是单例的<br>原因：1.全局唯一对象<br>2.在第一个实战案例中，除了我们讲到的类级别锁、分布式锁、并发队列、单例模式等解决方案之外，实际上还有一种非常简单的解决日志互相覆盖问题的方法，你想到了吗？<br>答：用全局变量实现","like_count":0},{"had_liked":false,"id":180965,"user_name":"DullBird","can_delete":false,"product_type":"c1","uid":1110494,"ip_address":"","ucode":"80E2FD5F9687CB","user_header":"https://static001.geekbang.org/account/avatar/00/10/f1/de/3ebcbb3f.jpg","comment_is_top":false,"comment_ctime":1582450044,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582450044","product_id":100039001,"comment_content":"1. java.lang.reflect.Proxy是单例的，<br>2. 文件分开，每个log都用自己的文件？","like_count":0},{"had_liked":false,"id":179998,"user_name":"teddytyy","can_delete":false,"product_type":"c1","uid":1268738,"ip_address":"","ucode":"E1569D81A4154E","user_header":"https://static001.geekbang.org/account/avatar/00/13/5c/02/e7af1750.jpg","comment_is_top":false,"comment_ctime":1582162438,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582162438","product_id":100039001,"comment_content":"ID生成器是否也可以算作解决资源冲突的单例模式应用？","like_count":0},{"had_liked":false,"id":179774,"user_name":"岁月","can_delete":false,"product_type":"c1","uid":1337598,"ip_address":"","ucode":"29A2A2BC3C4FE4","user_header":"https://static001.geekbang.org/account/avatar/00/14/68/fe/1353168d.jpg","comment_is_top":false,"comment_ctime":1582096642,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582096642","product_id":100039001,"comment_content":"思考题: 日志对象用全局变量保存即可. 毕竟你的文件名等配置都一模一样, 所以只要一个对象即可, 其他所有的依赖日志对象的类不管创建出多少个对象, 里面依赖的都是同一个日志对象.","like_count":0},{"had_liked":false,"id":179740,"user_name":"连边","can_delete":false,"product_type":"c1","uid":1391748,"ip_address":"","ucode":"54B5DA38449728","user_header":"https://static001.geekbang.org/account/avatar/00/15/3c/84/608f679b.jpg","comment_is_top":false,"comment_ctime":1582086587,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582086587","product_id":100039001,"comment_content":"从来都知道单例模式，看了这篇之后发现，从来也没有知道过单例模式。","like_count":0},{"had_liked":false,"id":179469,"user_name":"xindoo","can_delete":false,"product_type":"c1","uid":1101718,"ip_address":"","ucode":"AEAF3208E644BC","user_header":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","comment_is_top":false,"comment_ctime":1582010770,"is_pvip":true,"discussion_count":7,"race_medal":0,"score":"1582010770","product_id":100039001,"comment_content":"我思考了下，觉得双重检测的实现里仍然需要加volatile关键词，理由如下：<br>new是原子操作，不会出现有线程使用一个未初始化完的对象，所以用volatile解决指令重排序就没啥必要了。但是还有变量可见性的问题，如果一个线程new出一个对象，赋值的时候引用只写到了cpu cache里 没有更新到主存里，其它的线程看到的还是null，所以还是会去执行new，所以不加volatile可能会导致实际new出多个对象。<br>争哥看我理解的对不对？ ","like_count":0,"discussions":[{"author":{"id":1249781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","nickname":"宁锟","note":"","ucode":"815FC9A9EBB109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177130,"discussion_content":"一个new操作分为3个子操作，1.分配内存空间，获得一个指向该空间的引用objRef 2.调用构造器初始化objRef引用指向的实例 3 将objRef引用赋值给实例变量Instance \nJIT编译器会将子操作3相应的指令重排到子操作2相应的指令前，这就导致其他线程看到instance实例变量的时候，虽然不为null，但并未初始化","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1582080215,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1249781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","nickname":"宁锟","note":"","ucode":"815FC9A9EBB109","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177564,"discussion_content":"按争哥的意思，高版本的jdk不会将2 3重排，但是我目前没找到相关资料","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582114702,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177130,"ip_address":""},"score":177564,"extra":""},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":278252,"discussion_content":"想知道是JDK 哪个版本\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591164933,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177564,"ip_address":""},"score":278252,"extra":""}]},{"author":{"id":1249781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","nickname":"宁锟","note":"","ucode":"815FC9A9EBB109","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177140,"discussion_content":"加锁已经能够保证可见性，不存在重复实例化的情况","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582080767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1101718,"avatar":"https://static001.geekbang.org/account/avatar/00/10/cf/96/251c0cee.jpg","nickname":"xindoo","note":"","ucode":"AEAF3208E644BC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1249781,"avatar":"https://static001.geekbang.org/account/avatar/00/13/11/f5/039f003d.jpg","nickname":"宁锟","note":"","ucode":"815FC9A9EBB109","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":177484,"discussion_content":"忘记这茬了，理解了，那按争哥的意思，确实不需要加volatile","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582110880,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":177140,"ip_address":""},"score":177484,"extra":""}]},{"author":{"id":2415448,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","nickname":"二饼","note":"","ucode":"48120565D135F7","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574957,"discussion_content":"这里使用的是synchronized（同步锁），不能放置指令重排（volatile），但是可以保证可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654496134,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1020390,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/91/e6/03582dee.jpg","nickname":"牧名","note":"","ucode":"193F0F33E1AB47","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":178968,"discussion_content":"锁能保证可见性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582205286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":179080,"user_name":"gogo","can_delete":false,"product_type":"c1","uid":1003104,"ip_address":"","ucode":"E8F0F3B000020A","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4e/60/0d5aa340.jpg","comment_is_top":false,"comment_ctime":1581910361,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1581910361","product_id":100039001,"comment_content":"请教一个问题，老师讲到恶汉式单例时，提到占用内存多，没太了解，不是只有调用getInstance()方法才会触发这个对象初始化的吗？为什么会说提前初始化呢","like_count":0,"discussions":[{"author":{"id":1784511,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/3a/bf/fea3aa00.jpg","nickname":"Ezreal","note":"","ucode":"8C7107E6AD521D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185131,"discussion_content":"是的华生你发现了盲点。所以想要饿汉式提前生效，应该使用spring这种框架来管路这个对象，服务启动的时候就能初始化这个类了。不然跟懒汉式区别不大","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582597087,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1314724,"avatar":"https://static001.geekbang.org/account/avatar/00/14/0f/a4/0b49469f.jpg","nickname":"木子00","note":"","ucode":"8F78CA722EB29B","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":278245,"discussion_content":"饿汉式的单例(IdGenerator)，在加载这个类的时候就已经 初始化了(private static final IdGenerator instance = new IdGenerator();)\n所以在使用getInstance()方法是。instance 早就创建了好。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1591164751,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1784022,"avatar":"","nickname":"pippin","note":"","ucode":"F7619FCE24D481","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186214,"discussion_content":"静态对象在项目启动的时候会进行初始化，而这里的饿汉式就是静态对象，如果静态对象有很多会在项目启动的时候就分配了空间，如果没有用到就造成了内存浪费占用内存多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582646986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":178925,"user_name":"FIGNT","can_delete":false,"product_type":"c1","uid":1540988,"ip_address":"","ucode":"D9DB185AE9E67C","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKZ16iaIia0029oI1Qh5NicibpbTiaBAaCOPYXoLplKHr6uQ2rSVxPZanBvpMcL2NuhwKQYCFnaHP5tedQ/132","comment_is_top":false,"comment_ctime":1581856399,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581856399","product_id":100039001,"comment_content":"有个问题。枚举单例，是不是不支持延迟加载？？欢迎大家来讨论","like_count":0},{"had_liked":false,"id":178681,"user_name":"桂城老托尼","can_delete":false,"product_type":"c1","uid":1306032,"ip_address":"","ucode":"139E4B8EE88B79","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJcxSpNMqwqyicMvdOSr9ic0p1ABiauHnv7g7YQVSJuoHPoQbYDu3YzdpgmSAk2KricUBQ5yibWBWIq75w/132","comment_is_top":false,"comment_ctime":1581778230,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581778230","product_id":100039001,"comment_content":"感谢分享<br>1. 猛地还真想不起来，看了下表，Calendar 目测是单例，实践了下还真是，原因:emmmm 说实话我个人觉得是没必要， 然后我点进去看了下代码，觉得逻辑真复杂。感谢JDK 提供了单例。。<br>2. Logger.log() 编程static 方法，业务代码直接 Logger.log(&quot;XXOO&quot;); ","like_count":0},{"had_liked":false,"id":178421,"user_name":"Zexho","can_delete":false,"product_type":"c1","uid":1430343,"ip_address":"","ucode":"ADEB6624E29893","user_header":"https://static001.geekbang.org/account/avatar/00/15/d3/47/25ec564c.jpg","comment_is_top":false,"comment_ctime":1581686129,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581686129","product_id":100039001,"comment_content":"用读写锁来解决文件的写入覆盖问题是否可以呢？","like_count":0,"discussions":[{"author":{"id":2415448,"avatar":"https://static001.geekbang.org/account/avatar/00/24/db/58/a7a0a85b.jpg","nickname":"二饼","note":"","ucode":"48120565D135F7","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574960,"discussion_content":"个人感觉，用读写锁理论上是可行，但是分情况，比如案例一这种写出日志会频繁访问内存的，用读写锁可能会出现性能瓶颈，而案例二关注点更多的放在获取生成的id上面，因此可以用读写锁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1654496779,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177770,"user_name":"L🚲🐱","can_delete":false,"product_type":"c1","uid":1577856,"ip_address":"","ucode":"08A012739614DE","user_header":"https://static001.geekbang.org/account/avatar/00/18/13/80/2c9da1b1.jpg","comment_is_top":false,"comment_ctime":1581495778,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581495778","product_id":100039001,"comment_content":"争哥的这篇单例的讲解, 是我见过的讲解的最清晰的一篇, 之前从来不知道单例还有静态内部类和枚举的实现.<br>在个人项目中, 加载资源配置是单例的, 用消息队列解决日志互相覆盖的问题","like_count":0},{"had_liked":false,"id":177673,"user_name":"123456","can_delete":false,"product_type":"c1","uid":1485820,"ip_address":"","ucode":"9F7C4F3E4416BE","user_header":"https://static001.geekbang.org/account/avatar/00/16/ab/fc/38ccd186.jpg","comment_is_top":false,"comment_ctime":1581471641,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581471641","product_id":100039001,"comment_content":"双重检测的高低版本能否具体指明下","like_count":0},{"had_liked":false,"id":177577,"user_name":"hanazawakana","can_delete":false,"product_type":"c1","uid":1251721,"ip_address":"","ucode":"E0F6FACBFE7D15","user_header":"https://static001.geekbang.org/account/avatar/00/13/19/89/20488013.jpg","comment_is_top":false,"comment_ctime":1581427789,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581427789","product_id":100039001,"comment_content":"问题2，不同日志名就好了吧，哈哈","like_count":0},{"had_liked":false,"id":177263,"user_name":"不似旧日","can_delete":false,"product_type":"c1","uid":1161271,"ip_address":"","ucode":"DF4C5E3AB9570C","user_header":"https://static001.geekbang.org/account/avatar/00/11/b8/37/98991aeb.jpg","comment_is_top":false,"comment_ctime":1581335191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581335191","product_id":100039001,"comment_content":"单列模式：<br>饿汉式：预加载，占内存。<br>懒汉式：延迟加载，效率低。<br>实现方式：<br>1. 私有化构造器，提供公共的创建方法。<br>2. 内部类方式。<br>3.枚举方式。","like_count":0},{"had_liked":false,"id":177129,"user_name":"传说中的成大大","can_delete":false,"product_type":"c1","uid":1236766,"ip_address":"","ucode":"103543D6E706BF","user_header":"https://static001.geekbang.org/account/avatar/00/12/df/1e/cea897e8.jpg","comment_is_top":false,"comment_ctime":1581299080,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1581299080","product_id":100039001,"comment_content":"为何在讲本文中实战一<br>ublic class OrderController {  private Logger logger = new Logger();    public void create(OrderVo order) {    &#47;&#47; ...省略业务逻辑代码...    Logger.getInstance().log(&quot;Created a order: &quot; + order.toString());  }}<br>还有一行这个代码？private Logger logger = new Logger(); ","like_count":0,"discussions":[{"author":{"id":1177602,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f8/02/a02d127d.jpg","nickname":"Treasure","note":"","ucode":"4211ECEB347C3D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":168260,"discussion_content":"应该是复制粘贴忘记删除了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581566170,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":177099,"user_name":"前端西瓜哥","can_delete":false,"product_type":"c1","uid":1248576,"ip_address":"","ucode":"150130C34CD1C1","user_header":"https://static001.geekbang.org/account/avatar/00/13/0d/40/f70e5653.jpg","comment_is_top":false,"comment_ctime":1581267816,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1581267816","product_id":100039001,"comment_content":"我想到的其他解决日志互相覆盖问题的方法：<br>1. 配合数据库使用。数据库自己做了处理，就不需要自己考虑覆盖问题了。缺点是日志系统理论上不应该用上数据库，会导致扩展性不好。<br>2. 每个线程创建一个日志文件，间隔一段时间将多个日志文件进行合并为大的日志文件。缺点是线程多的时候比较消耗资源。<br>3. 将日志信息发送出去，比如通过 http 请求，让一个单线程的服务接收并记录日志。这种实现有点像消息队列了。","like_count":0},{"had_liked":false,"id":176172,"user_name":"东流","can_delete":false,"product_type":"c1","uid":1738147,"ip_address":"","ucode":"2715BC6E87BD83","user_header":"https://static001.geekbang.org/account/avatar/00/1a/85/a3/7e078442.jpg","comment_is_top":false,"comment_ctime":1580979011,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580979011","product_id":100039001,"comment_content":"1.在你所熟悉的编程语言的类库中，有哪些类是单例类？又为什么要设计成单例类呢？<br>java 中的打印类，System.out,（我猜的）；原因则是用起来方便<br><br>在第一个实战案例中，除了我们讲到的类级别锁、分布式锁、并发队列、单例模式等解决方案之外，实际上还有一种非常简单的解决日志互相覆盖问题的方法，你想到了吗？<br>没","like_count":0},{"had_liked":false,"id":176035,"user_name":"小猴子吹泡泡","can_delete":false,"product_type":"c1","uid":1122941,"ip_address":"","ucode":"A5F214E388E41F","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/7d/b093ca1e.jpg","comment_is_top":false,"comment_ctime":1580916427,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580916427","product_id":100039001,"comment_content":"如果要实现序列化反序列化的单例模式，要增加一个readResolve()方法，代码如下：<br>protected Object readResolve() throws ObjectStreamException {<br>    return instance;<br>}","like_count":0},{"had_liked":false,"id":176030,"user_name":"javaadu","can_delete":false,"product_type":"c1","uid":1000519,"ip_address":"","ucode":"8C0B140F1C8992","user_header":"https://static001.geekbang.org/account/avatar/00/0f/44/47/3ddb94d0.jpg","comment_is_top":false,"comment_ctime":1580914261,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1580914261","product_id":100039001,"comment_content":"第一个问题：Spring框架中，大部分的组件都是单例的；<br>第二个问题：将不同业务的日志拆开，并将Logger对象用static关键词修饰","like_count":0},{"had_liked":false,"id":176028,"user_name":"Frank","can_delete":false,"product_type":"c1","uid":1018370,"ip_address":"","ucode":"7A488CC6FE15E7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8a/02/828938c9.jpg","comment_is_top":false,"comment_ctime":1580914207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580914207","product_id":100039001,"comment_content":"1. 目前能想到的类库中使用了单例模式的有连接池、java.lang.Runtime#getRuntime，Hibernate的SessionFactory、Configuration，这么设计的的原因是维持全局唯一，还存在这些类的实例可能会占用很多内存，或者实例的初始化过程比较冗长。<br>2. 写日志的例子中还可使用JDK1.4 提供的FileLock来解决资源竞争问题，其他更简单的方式想不到。","like_count":0},{"had_liked":false,"id":175979,"user_name":"松花皮蛋me","can_delete":false,"product_type":"c1","uid":1000054,"ip_address":"","ucode":"B0846CEEF6B0D1","user_header":"https://static001.geekbang.org/account/avatar/00/0f/42/76/256bbd43.jpg","comment_is_top":false,"comment_ctime":1580898295,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580898295","product_id":100039001,"comment_content":"MDC，在日记上下文中记录线程信息以区分日记","like_count":0},{"had_liked":false,"id":175899,"user_name":"Eden Ma","can_delete":false,"product_type":"c1","uid":1457408,"ip_address":"","ucode":"755312F0D154F9","user_header":"https://static001.geekbang.org/account/avatar/00/16/3d/00/7daa7403.jpg","comment_is_top":false,"comment_ctime":1580881844,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580881844","product_id":100039001,"comment_content":"iOS中UIApplication类是单例,因为它执行的都是应用级别的操作,设计成单例更安全.","like_count":0},{"had_liked":false,"id":175890,"user_name":"丿淡忘","can_delete":false,"product_type":"c1","uid":1139645,"ip_address":"","ucode":"604AE01961A026","user_header":"https://static001.geekbang.org/account/avatar/00/11/63/bd/80f587ad.jpg","comment_is_top":false,"comment_ctime":1580880194,"is_pvip":false,"discussion_count":0,"race_medal":1,"score":"1580880194","product_id":100039001,"comment_content":"直接将日志写入到数据库？？？","like_count":0},{"had_liked":false,"id":175871,"user_name":"zs阿帅","can_delete":false,"product_type":"c1","uid":1141173,"ip_address":"","ucode":"07A54AE7F1CAFF","user_header":"https://static001.geekbang.org/account/avatar/00/11/69/b5/1e1731cc.jpg","comment_is_top":false,"comment_ctime":1580874273,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580874273","product_id":100039001,"comment_content":"以前从来不知道还有静态内部类和枚举方式实现单例，学到了","like_count":0},{"had_liked":false,"id":175837,"user_name":"黄海峰","can_delete":false,"product_type":"c1","uid":1275357,"ip_address":"","ucode":"E9340719BC96B2","user_header":"https://static001.geekbang.org/account/avatar/00/13/75/dd/9ead6e69.jpg","comment_is_top":false,"comment_ctime":1580867486,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1580867486","product_id":100039001,"comment_content":"文件锁？","like_count":0}]}