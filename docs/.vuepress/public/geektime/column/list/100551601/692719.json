{"id":692719,"title":"33｜缓存模式：缓存模式能不能解决缓存一致性问题？","content":"<p>你好，我是大明。今天我们来学习缓存的另外一个热点——缓存模式。</p><p>缓存模式在面试中属于高频问题，但是大部分人的回答都会有两个缺陷：一个是不够完整，也就是只知道一部分缓存模式；另外一个是不够深入，也就是只能泛泛而谈。尤其是有些面试官会故意问你怎么用缓存模式来解决一致性问题，你就有可能上当。</p><p>那么这节课我就带你深入分析每一个缓存模式，并且讨论它的优缺点以及在数据一致性方面的表现。</p><p>让我们直接从面试准备开始。</p><h2>面试准备</h2><p>缓存模式你首先要确保自己能够记住这些模式，其次要在公司内部收集一些信息。</p><ul>\n<li>你们公司有没有使用缓存模式，使用了哪些，有没有遇到过缓存一致性的问题，最终是如何解决的？</li>\n<li>你的业务中使用了缓存之后，你是如何更新缓存和数据库中的数据的？有没有一致性问题？</li>\n</ul><p>缓存模式用得好可以有效缓解数据一致性的问题，也可以用于解决缓存穿透、击穿和雪崩的问题。这两个话题我们课程后面会进一步讨论，你要结合在一起理解。</p><p>为了便于你理解，我们用一个简化模型来解释缓存模式，也就是你的系统里面有缓存和数据库，你读写数据都要操作这两者。</p><h2>基本思路</h2><p>在最开始面试的时候，你可以在自我介绍的时候提起缓存模式的话题。</p><blockquote>\n<p>我对缓存模式有比较深刻的理解，平时会用缓存模式来解决很多问题，比如说缓存穿透、雪崩和击穿。</p>\n</blockquote><!-- [[[read_end]]] --><p>在这段话里面，你还提到了缓存穿透、雪崩和击穿，这一部分内容我们后面会学习。在后续面试过程中，面试官就会直接问，你了解哪些缓存模式或者用过哪些缓存模式。你就可以这么回答：</p><blockquote>\n<p>缓存模式有 Cache Aside、Read Through、Write Through、Write Back、Singleflight。除此之外，我还用过删除缓存和延迟双删。</p>\n</blockquote><p>严格意义上来说，删除缓存、延迟双删不能算是缓存模式，但是在面试中还是很常见的，所以你可以顺便提一下。</p><h3>Cache Aside</h3><p>Cache Aside 我个人认为都很难说是一种缓存模式，毕竟我们什么也不做的时候，就是 Cache Aside。这个模式，就是把缓存看作一个独立的数据源。当写入的时候，业务方来控制写入顺序。</p><p><img src=\"https://static001.geekbang.org/resource/image/21/8c/21b770802b9a125200ff212ef23ebb8c.png?wh=2512x1392\" alt=\"\"></p><p>当读取的时候，也是由业务方来控制。</p><p><img src=\"https://static001.geekbang.org/resource/image/c5/61/c5ffd743dafdd7e0338ca85957d25061.png?wh=1920x1082\" alt=\"图片\"></p><p>你先简单介绍读写的基本操作。</p><blockquote>\n<p>Cache Aside 是最基本的缓存模式，在这个模式下，业务代码就是把缓存看成是和数据库一样的独立的数据源，然后业务代码控制怎么写入缓存，怎么写入数据库。一般来说，都是优先写入数据库的。</p>\n</blockquote><p>最后一句你提到了优先写入数据库，那么面试官就会追问为什么要先写入数据库。</p><blockquote>\n<p>先写数据库是因为大多数业务场景下数据都是以数据库为准的，也就是说如果写入数据库成功了，就可以认为这个操作成功了。即便写入缓存失败，但是缓存本身会有过期时间，那么它过期之后重新加载，数据就会恢复一致。</p>\n</blockquote><p>最后你要加一句总结。</p><blockquote>\n<p>不管是先写数据库还是先写缓存，Cache Aside 都不能解决数据一致性问题。</p>\n</blockquote><p>这一句总结很重要，你可以看下面的图，如果面试官追问为什么都不能解决，或者有什么不一致的场景，你按照图里面的内容来回答就可以。</p><p><img src=\"https://static001.geekbang.org/resource/image/5y/46/5yy88978b6eae00aa3eee64eacdda546.png?wh=1920x932\" alt=\"图片\"></p><p>我教你一个简单的记忆方法，就是你注意观察图里的线程2，它一定是后面才开始执行，但是最先结束的。</p><h3>Read Through</h3><p>这个缓存模式也叫做读穿透。它的核心是当缓存里面没有数据的时候，缓存会代替你去数据库里面把数据加载出来，并且缓存起来。</p><p><img src=\"https://static001.geekbang.org/resource/image/53/65/53519ca2ee9f7fd41c71a7489847ea65.png?wh=1920x1080\" alt=\"图片\"></p><p>而写入的时候，就和 Cache Aside 一样。</p><blockquote>\n<p>Read Through 也是一个很常用的缓存模式。Read Through 是指在读缓存的时候，如果缓存未命中，那么缓存会代替业务代码去数据库中加载数据。<br>\n&nbsp;<br>\n这种模式有两个异步变种，一种是异步写回缓存，一种是完全异步加载数据，然后写回缓存。当然，不管是什么变种，Read Through 都不能解决缓存一致性的问题。</p>\n</blockquote><p>你可以注意到，Read Through 只管了读的部分，而写的部分是完全没有管的，所以它的写过程和 Cache Aside 是一样的。因此，它一样有缓存一致性的问题。要是面试官追问，你就用 Cache Aside 中的分析来回答。</p><p>最后我们提到异步加载数据，也就是为了引出亮点。</p><h4>亮点：异步方案</h4><p>Read Through 模式在发现缓存里面没有数据的时候，加载数据、缓存起来这两个步骤是可以考虑异步执行的。所以你可以先回答第一个变种。</p><blockquote>\n<p>缓存可以在从数据库加载了数据之后，立刻把数据返回给业务代码，然后开启一个线程异步更新缓存。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/11/3f/111b230fd2fb2266d2720688895ca23f.png?wh=1920x1080\" alt=\"图片\"></p><p>既然缓存数据这个步骤可以异步，那么从数据库中加载数据也完全可以异步。</p><blockquote>\n<p>第二个变种是直接让整个加载和回写缓存的过程都异步执行。也就是说，如果缓存未命中，那么就直接返回一个错误或者默认值，然后缓存异步地去数据库中加载，并且回写缓存。和第一个变种比起来，这种变种的缺陷是业务方在当次调用中只能拿到错误或者默认值。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/30/85/3072d2d4916551a9fe58a9f747086985.png?wh=1920x1080\" alt=\"图片\"></p><p>然后你可以总结一下什么场景可以使用这两个变种。</p><blockquote>\n<p>如果业务方对响应时间的要求非常苛刻，那么就可以考虑使用变种二。代价就是业务方会收到错误响应或者默认值。而变种一其实收益很小，只有在缓存操作很慢的时候才会考虑。比如说缓存大对象，又或者要把一个大对象序列化之后再存储到缓存里面。</p>\n</blockquote><p>如果你在实践中用过这些变种，那么你就可以用自己的实际业务来举例子。</p><h3>Write Through</h3><p>这个也叫做写穿透，是指当业务方写入数据的时候，只需要写入缓存。缓存会代替业务方去更新数据库。</p><p><img src=\"https://static001.geekbang.org/resource/image/81/b6/811e6fd221d070654b4bdbe93e68d5b6.png?wh=1920x1079\" alt=\"图片\"></p><p>Write Through 读数据的步骤就跟 Cache Aside 是一样的。</p><blockquote>\n<p>Write Through 就是在写入数据的时候，只写入缓存，然后缓存会代替我们的去更新数据库。但是，Write Through 没有要求先写数据库还是先写缓存，不过一般也是先写数据库。<br>\n&nbsp;<br>\n其次，Write Through 也没有讨论如果缓存中原本没有数据，那么写入数据的时候，要不要更新缓存。一般来说，如果预计写入的数据很快就会读到，那么就要刷新缓存中的数据。<br>\n&nbsp;<br>\nWrite Through 也有对应的异步变种方案。当然，这些变种也都没有解决缓存一致性的问题。</p>\n</blockquote><p>在刚刚的回答中，你提到了写入顺序的问题，那么面试官就可能追问写入一致性的问题。显然，Write Through 也没有解决一致性的问题，你同样可以参考 Cache Aside 中的分析。</p><h4>亮点：异步方案</h4><p>类似地，Write Through 也是可以考虑异步的。也就是在写入缓存之后，缓存立刻返回结果。</p><p><img src=\"https://static001.geekbang.org/resource/image/5a/90/5aa8d273fa2b86033a4932400ecd9090.png?wh=1920x931\" alt=\"图片\"></p><p>但这种模式是有可能丢数据的，也就是当业务代码收到成功响应之后，缓存崩溃了，那么数据其实并没有写入到数据库中。</p><p>另外一个比较可行的变种是同步写入到数据库中，但是会异步刷新缓存。</p><p><img src=\"https://static001.geekbang.org/resource/image/b1/7f/b13c2f58dd835e540b2d62bbe01db27f.png?wh=1920x959\" alt=\"图片\"></p><blockquote>\n<p>在缓存收到写请求之后，可以直接返回成功响应，然后异步写入数据库和刷新缓存。但是这种方案比较危险，存在数据丢失的风险。<br>\n&nbsp;<br>\n缓存也可以考虑只写入数据库，然后返回成功响应，后面可以异步刷新缓存。基本上前者很少用，要用也是用一个和它很像的 Write Back 方案。变种二则适合用于缓存写入操作且代价高昂的场景。比如说前面提到的，写入大对象或者需要序列化大对象再写入缓存。</p>\n</blockquote><h3>Write Back</h3><p>Write Back 这个模式的特色非常鲜明。在这个模式下，当你写入数据的时候，你只是写到了缓存。当缓存过期的时候，才会被刷新到数据库。</p><p><img src=\"https://static001.geekbang.org/resource/image/08/33/08e535458fab38d17d8a99f3c1bee033.png?wh=1920x981\" alt=\"图片\"></p><blockquote>\n<p>Write Back 模式是指我们在更新数据的时候，只把数据更新到缓存中就返回。后续会有一个组件监听缓存中过期的 key，在过期的时候将数据刷新到数据库中。显然，只是监听过期 key 的话还是会有问题，比如说关闭缓存的时候还是需要把缓存中的数据全部刷新到数据库里。</p>\n</blockquote><p>但是你应该也注意到了，如果数据还在缓存中的时候，缓存突然崩溃了，那数据就直接丢了。</p><blockquote>\n<p>Write Back 有一个硬伤，就是如果缓存突然宕机，那么还没有刷新到数据库的数据就彻底丢失了。这也限制了 Write Back 模式在现实中的应用。不过要是缓存能够做到高可用，也就不容易崩溃，也可以考虑使用。</p>\n</blockquote><p>到这里，你还可以进一步刷亮点，深入讨论 Write Back 和数据一致性的问题。所以你可以稍微总结一下。</p><blockquote>\n<p>Write Back 最大的优点是排除数据丢失这一点，它能解决数据一致性的问题。</p>\n</blockquote><h3>亮点：能否解决数据一致性问题</h3><p>这里你要分成两种情况来讨论，使用本地缓存还是使用 Redis 这种缓存。你可以肯定的是，如果使用的是本地缓存，那么 Write Back 也会有不一致的问题，毕竟你的数据缓存在多个节点上。但是如果你用的是 Redis，那么在不考虑缓存丢失的情况下，你就可以做到数据一致性了。</p><p>这个稍微有点绕，为了让面试官理解，你要一步步引导。</p><blockquote>\n<p>首先，在使用 Redis 更新数据的时候业务代码只更新缓存，所以对于业务方来说必然是一致的。也就是说，虽然数据库的数据和缓存的数据不一致，但是对于业务方来说，它只能读写到缓存的数据，对业务方来说，数据是一致的。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/21/1e/21cf7ae8a34b49aeba7dbea44d9d891e.png?wh=1920x981\" alt=\"图片\"></p><p>这是第一个前提，也就是写操作不会带来不一致的问题。紧接着你要解释读操作。</p><blockquote>\n<p>当业务方读数据的时候，如果缓存没有数据，就要去数据库里面加载。这个时候，就有可能产生不一致的问题。比如说，数据库中 a=3，读出来之后还没写到缓存里面。这个时候来了一个写请求，在缓存中写入了 a = 4。如果这时候读请求回写缓存，就会用数据库里的老数据覆盖缓存中的新数据。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/c9/a2/c92102d20b64a2a1fcfc44de9e79cda2.png?wh=1920x981\" alt=\"图片\"></p><p>紧接着补充解决方案。</p><blockquote>\n<p>解决这个问题的思路也很简单，当读请求回写的时候，使用 SETNX 命令。也就是说，只有当缓存中没有数据的时候，才会回写数据。而如果回写失败了，那么读请求会再从缓存中读取到数据。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/72/dc/7268e0e75e5b75cfe1082f4b9aed9cdc.png?wh=1920x1080\" alt=\"图片\"></p><p>最后你一锤定音，总结一下。</p><blockquote>\n<p>因此Write Back 除了有数据丢失的问题，在缓存一致性的表现上，比其他模式要好。</p>\n</blockquote><p>这句话其实有一点强词夺理，所以你要酌情使用。如果你觉得说 Write Back 解决了一致性问题有点夸张，你可以说 Write Back 极大地缓解了数据不一致的问题。</p><p>激进的观点会让你留下深刻的印象，但是如果面试官不认同就可能否定你。保守的观点没有风险，但是也没有对应的收益。</p><h3>Refresh Ahead</h3><p><img src=\"https://static001.geekbang.org/resource/image/2b/1b/2b9d1638e9ab6822907ef020d211ce1b.png?wh=1920x1079\" alt=\"图片\"></p><blockquote>\n<p>Refresh Ahead 是指利用 CDC（Capture Data Change）接口异步刷新缓存的模式。这种模式在实践中也很常见，比如说利用 Canal 来监听数据库的 binlog，然后 Canal 刷新 Redis。这种模式也有缓存一致性的问题，也是出在缓存未命中的读请求和写请求上。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/a8/d3/a81a425b4628222a3c8db446734409d3.png?wh=1920x1080\" alt=\"图片\"></p><p>实际上，这个缓存一致性问题是可以解决的，也就是参考 Write Back 里面的策略。</p><blockquote>\n<p>如果读请求在回写缓存的时候，使用了 SETNX 命令，那么就没有什么大的不一致问题了。唯一的不一致就是数据写入到了数据库，但是还没刷新到缓存的那段时间。</p>\n</blockquote><h3>Singleflight</h3><p>Singleflight 主要是为了控制住加载数据的并发量。</p><p><img src=\"https://static001.geekbang.org/resource/image/6b/fb/6b66435e6ef218d636db7825fb620cfb.png?wh=1920x1080\" alt=\"图片\"></p><p>你先简单介绍 Singleflight 的原理，再补充它的优缺点。</p><blockquote>\n<p>Singleflight 模式是指当缓存未命中的时候，访问同一个 key 的线程或者协程中只有一个会去真的加载数据，其他都在原地等待。<br>\n&nbsp;<br>\n这个模式最大的优点就是可以减轻访问数据库的并发量。比如说如果同一时刻有 100 个线程要访问 key1，那么最终也只会有 1 个线程去数据库中加载数据。这个模式的缺点是如果并发量不高，那么基本没有效果。所以热点之类的数据就很适合用这个模式。</p>\n</blockquote><h3>删除缓存</h3><p>这算是在业务中比较常见的用法，也就是在更新数据的时候先更新数据库，然后将缓存删除。</p><p><img src=\"https://static001.geekbang.org/resource/image/fd/yy/fd58f546688edb5daf82c3be0b24e2yy.png?wh=1920x1088\" alt=\"图片\"></p><p>删除缓存本身没有规定必须是业务代码来删除缓存，所以实际上也可以结合 Write Through 模式，让缓存去更新数据库，然后缓存自己删除自己的数据。</p><p><img src=\"https://static001.geekbang.org/resource/image/80/23/806bde52b8242874ab713e708ce69823.png?wh=1920x1088\" alt=\"图片\"></p><p>这个模式依旧没有解决数据一致性的问题，但是它的一致性问题不是源自两个线程同时更新数据，而是源自一个线程更新数据，一个线程缓存未命中回查数据库。</p><p><img src=\"https://static001.geekbang.org/resource/image/cf/3e/cfa81ee750af2f83e5a4890ebf96f83e.png?wh=1920x1079\" alt=\"图片\"></p><p>你在回答的时候要注意答出这一点。</p><blockquote>\n<p>删除是最常用的更新缓存的模式，它是指在更新数据库之后，直接删除缓存。这种做法可以是业务代码来控制删除操作，也可以结合 Write Through 使用。而且删除缓存之后会使缓存命中率下降，也算是一个隐患。如果偶尔出现写频繁的场景，导致缓存一直被删除，那么就会使性能显著下降。缓存未命中回查数据库叠加写操作，数据库压力会很大。<br>\n&nbsp;<br>\n删除缓存和别的模式一样，也有一致性问题。但是它的一致性问题是出在读线程缓存未命中和写线程冲突的情况下。</p>\n</blockquote><p>然后你补充一句总结。</p><blockquote>\n<p>为了避免这种缓存不一致的问题，又有了延迟双删模式。</p>\n</blockquote><h3>延迟双删</h3><p>从名字上你大概就能知道延迟双删是有两次删除操作的。</p><p><img src=\"https://static001.geekbang.org/resource/image/63/2f/6304cf03bf54b4031fbf56df45c9e32f.png?wh=1920x1082\" alt=\"图片\"></p><blockquote>\n<p>延迟双删类似于删除缓存的做法，它在第一次删除操作之后设定一个定时器，在一段时间之后再次执行删除。</p>\n</blockquote><p>紧接着你解释一下第二次删除的动机。</p><blockquote>\n<p>第二次删除就是为了避开删除缓存中的读写导致数据不一致的场景。</p>\n</blockquote><p><img src=\"https://static001.geekbang.org/resource/image/3a/a7/3a09a23b76a1830e2e4f3065fefc58a7.png?wh=1920x1079\" alt=\"图片\"></p><p>那么是不是就不会有数据不一致的问题了？从理论上来说是可能的。第一个不一致出现在上图写入 a = 3 到第二次删缓存之间，还有一种不一致的可能如下图。</p><p><img src=\"https://static001.geekbang.org/resource/image/14/48/1425611e8af4fe88a15065505c648848.png?wh=1920x1079\" alt=\"图片\"></p><p>但是这种可能性只是存在理论中，因为两次删除的时间间隔很长，不至于出现图片里的这种情况。所以你补充说明一下就可以了。</p><blockquote>\n<p>在这种形态之下，只需要考虑在回写缓存和第二次删除之间，数据可能不一致的问题。</p>\n</blockquote><p>紧接着再次说明这种模式的缺点。</p><blockquote>\n<p>延迟双删因为存在两次删除，所以实际上缓存命中率下降的问题更加严重。</p>\n</blockquote><h3>选用什么模式？</h3><p>我觉得到这一步你已经非常困惑了，万一面试官问你应该使用哪个模式要怎么回答呢？坦白说，任何一种缓存模式都有各自的缺陷，所以你实际上选哪个都有好处，也都有问题。面试的时候你就可以根据自己的偏好来选择，只要分析清楚优劣，并解释清楚数据一致性问题就可以了。</p><p>如果你确实需要一个标准答案，那么你就回答延迟双删。</p><blockquote>\n<p>这么多模式里面，我比较喜欢延迟双删，因为它的一致性问题不是很严重。虽然会降低缓存的命中率，但是我们的业务并发也没有特别高，写请求是很少的。命中率降低一点点是完全可以接受的。</p>\n</blockquote><h2>亮点方案：用装饰器模式实现缓存模式</h2><p>这个亮点你可以考虑是否要使用，我建议你在实践中落地之后再拿去面试。但是你不需要把所有的模式都实现一遍，实现一下你项目中用到的就可以。</p><p>前面的缓存模式中，除了 Refresh Ahead 和 Cache Aside，其他的模式都可以使用装饰器模式来实现。我举一个使用缓存模式中 Read Through 模式的例子。你可以参考我给出的伪代码。</p><pre><code class=\"language-go\">type Cache interface {\n  Get(key string) any\n  Set(key string, val any)\n}\n\ntype ReadThroughCache struct {\n  c Cache\n  fn func(key string) any\n}\n\nfunc (r *ReadThroughCache) Get(key string) any {\n    val := r.c.Get(key)\n    if val == nil {\n      val = r.fn(key)\n      r.c.Set(key, val)\n    }\n    return val\n}\n</code></pre><p>你抓住关键词装饰器模式来描述这个解决方案。</p><blockquote>\n<p>我在我们公司利用装饰器模式，无侵入式地实现了其中的大部分模式。以 Read Through 为例，装饰器模式只需要在已有的缓存实现的基础上，为 Get 方法添加一个缓存中没有找到就去加载数据的额外逻辑就可以。</p>\n</blockquote><p>而且，如果你平时在公司的项目经历比较平淡，那么你完全可以在公司内部定义一个统一的 Cache 接口，提供基于 Redis 和本地内存的实现，同时提供这些缓存模式的实现，那么也算是一个比较有特色的项目了。</p><p>你就可以这样介绍你的项目。</p><blockquote>\n<p>我在公司里面因为经常用到缓存，也经常使用缓存模式，所以我抽象了一个缓存接口，提供了基于 Redis 和本地内存的实现。在这个基础上，我还用装饰器模式实现了大部分缓存模式。对于开发者来说，他们只要会初始化装饰器就可以应用这个缓存模式。</p>\n</blockquote><p>后续你就可以和面试官讨论每一个缓存模式的细节。Beego 的缓存模块中有类似的实现，你可以参考。</p><h2>面试思路总结</h2><p>这一节课我带你学习了缓存模式，包括 Cache Aside、Read Through、Write Through、Write Back、Refresh Ahead 和 Singleflight几种。此外还有删除缓存和延迟双删，这两个虽然不叫缓存模式，但是面试中可以提一提。</p><p>缓存模式数量众多，但是你都需要记住，尤其是每一种缓存模式下，什么情况下会出现数据不一致的问题。此外，我建议你实践一下这些缓存模式，比如说你可以参考我给出的代码用装饰器模式来实现它们。</p><p><img src=\"https://static001.geekbang.org/resource/image/13/9e/13622c46d28b80d8d8c7722633e0a49e.png?wh=3150x2969\" alt=\"\"></p><h2>思考题</h2><p>最后请你来思考两个问题。</p><ol>\n<li>缓存模式那么多，你用过哪些？有没有遇到过缓存一致性的问题？</li>\n<li>假如说现在你用了 singleflight 模式，那么落到数据库上的查询数量会跟什么因素有关？</li>\n</ol><p>欢迎你把思考后的结果分享到评论区，也欢迎你把这节课的内容分享给需要的朋友，我们下节课再见。</p>","neighbors":{"left":{"article_title":"32｜缓存淘汰策略：怎么淘汰缓存命中率才不会下降？","id":692691},"right":{"article_title":"34｜缓存一致性问题：高并发服务如何保证缓存一致性？","id":696599}},"comments":[{"had_liked":false,"id":385953,"user_name":"一弦一柱思华年","can_delete":false,"product_type":"c1","uid":3720570,"ip_address":"广东","ucode":"36F8086A275AA7","user_header":"https://static001.geekbang.org/account/avatar/00/38/c5/7a/c03cb56e.jpg","comment_is_top":false,"comment_ctime":1703730482,"is_pvip":false,"replies":[{"id":140746,"content":"对。本身这些缓存模式都差不多。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1704188807,"ip_address":"广东","comment_id":385953,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"其实readThrough&#47;writeThrough只不过是在cache aside基础上将一些操作封装成一个函数了，但本质上没啥区别。可以这么理解吗","like_count":5,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634905,"discussion_content":"对。本身这些缓存模式都差不多。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704188808,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380572,"user_name":"peter","can_delete":false,"product_type":"c1","uid":1058183,"ip_address":"河南","ucode":"261C3FC001DE2D","user_header":"https://static001.geekbang.org/account/avatar/00/10/25/87/f3a69d1b.jpg","comment_is_top":false,"comment_ctime":1693832038,"is_pvip":false,"replies":[{"id":138636,"content":"啊啊，画图事务，我联系小编改改！","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1694182466,"ip_address":"广东","comment_id":380572,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"请教老师两个问题:\nQ1：Cache Aside的第一个图，写入数据库的时候，为什么缓存返回OK？\nQ2：SingleFlight模式，谁来控制线程？根据什么来选择一个访问的线程？","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627486,"discussion_content":"啊啊，画图事务，我联系小编改改！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694182466,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1282698,"avatar":"https://static001.geekbang.org/account/avatar/00/13/92/8a/17d1ef40.jpg","nickname":"cafe babe","note":"","ucode":"A29D4F89824A65","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627463,"discussion_content":"Q2: SingleFlight 不是就缓存击穿时加个分布式锁的解决方案 或者 Guava Cache 的更新锁定机制...","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694170510,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380567,"user_name":"itschenxiang","can_delete":false,"product_type":"c1","uid":1519547,"ip_address":"广东","ucode":"7D90194AC52435","user_header":"https://static001.geekbang.org/account/avatar/00/17/2f/bb/f663ac5a.jpg","comment_is_top":false,"comment_ctime":1693826452,"is_pvip":false,"replies":[{"id":138635,"content":"我不觉得，Aside 这里面包含了一定要删除缓存。\n\n个人认为，Aside 强调的是，我缓存也是作为一个独立的数据源。","user_name":"作者回复","user_name_real":"作者","uid":1176655,"ctime":1694182432,"ip_address":"广东","comment_id":380567,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"Cache Aside有文中这种广义的定义吗？facebook论文和网上提到的Cache Aside策略都非常具体：更新时，先更新DB，再删除缓存。","like_count":1,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627485,"discussion_content":"我不觉得，Aside 这里面包含了一定要删除缓存。\n\n个人认为，Aside 强调的是，我缓存也是作为一个独立的数据源。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694182432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2818819,"avatar":"https://static001.geekbang.org/account/avatar/00/2b/03/03/d610f362.jpg","nickname":"@","note":"","ucode":"1C6A78AB249D6B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646152,"discussion_content":"先更新数据库，再update缓存是不是有很大的问题？                 因为如果是单独的数据源，那是不是就是一个分布式事务场景了？    ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717469320,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390086,"user_name":"瀚海","can_delete":false,"product_type":"c1","uid":2062203,"ip_address":"上海","ucode":"E64C22F3F6D285","user_header":"https://static001.geekbang.org/account/avatar/00/1f/77/7b/338c4617.jpg","comment_is_top":false,"comment_ctime":1714309085,"is_pvip":false,"replies":[{"id":141968,"content":"偶尔会用用。实际上没有你想的那么复杂，真正的难点就一个：当redis 集群整个崩溃之后，你要有能力找回数据。或者说通过别的方式来补偿。\n\n而排查问题，你同样可以查询 redis。\n\n而报表问题也不大，也就是落后一点点数据而已。如果你是那种每天生成的报表，你完全可以等 write back 回写之后再生成。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1715230267,"ip_address":"广东","comment_id":390086,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"write back 方案，业务代码里有人这样用过吗       感觉这方案只应存在理论中，真的这样写，数据维护会变得极其麻烦      经常排查问题或是做报表都是以数据库数据为准的，这个方案最新的数据是在缓存中，想要定位问题，估计会难到几乎不可能","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644388,"discussion_content":"偶尔会用用。实际上没有你想的那么复杂，真正的难点就一个：当redis 集群整个崩溃之后，你要有能力找回数据。或者说通过别的方式来补偿。\n\n而排查问题，你同样可以查询 redis。\n\n而报表问题也不大，也就是落后一点点数据而已。如果你是那种每天生成的报表，你完全可以等 write back 回写之后再生成。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715230267,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":385368,"user_name":"NullPointerException","can_delete":false,"product_type":"c1","uid":1672137,"ip_address":"上海","ucode":"CE823125E9985F","user_header":"https://static001.geekbang.org/account/avatar/00/19/83/c9/0b25d9eb.jpg","comment_is_top":false,"comment_ctime":1702522851,"is_pvip":false,"replies":[{"id":140760,"content":"有。你更新缓存成功了，但是数据库事务提交失败了，怎么办？","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1704189502,"ip_address":"广东","comment_id":385368,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"write through 我看网上更新缓存和数据库是在一个事务中，这样应该没有一致性问题吧？","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":634919,"discussion_content":"有。你更新缓存成功了，但是数据库事务提交失败了，怎么办？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1704189503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2047756,"avatar":"","nickname":"Geek_622404","note":"","ucode":"0A059B22A5EFD0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":654327,"discussion_content":"在事务中先更新数据库在更新缓存的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1732457578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":384349,"user_name":"Geek_fef55b","can_delete":false,"product_type":"c1","uid":3780199,"ip_address":"北京","ucode":"48E9DE44CE965B","user_header":"","comment_is_top":false,"comment_ctime":1700725211,"is_pvip":false,"replies":[{"id":140350,"content":"调用一下 DB 就可以。如果你想设计良好的，你可能需要有一个 Store(key, val) 的接口，然后这个接口的实现就是 DB 插入到数据库。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1701847055,"ip_address":"广东","comment_id":384349,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"老师，请问一下，在Write Through模式中让缓存自己去更新数据库这个操作，是如何实现的呀？","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":633126,"discussion_content":"调用一下 DB 就可以。如果你想设计良好的，你可能需要有一个 Store(key, val) 的接口，然后这个接口的实现就是 DB 插入到数据库。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1701847055,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382144,"user_name":"锅菌鱼","can_delete":false,"product_type":"c1","uid":1131961,"ip_address":"广东","ucode":"82EC0452ED0E38","user_header":"https://static001.geekbang.org/account/avatar/00/11/45/b9/3db96ade.jpg","comment_is_top":false,"comment_ctime":1696767510,"is_pvip":false,"replies":[{"id":139218,"content":"这个在 GO 里面有一个自带的，还是很好用的。在 JAVA 那边的话，得找找开源框架，我几年没写 JAVA，已经不太记得了。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1696922500,"ip_address":"广东","comment_id":382144,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"老师，分布式Singleflight的有什么最佳实践的实现方案吗","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629286,"discussion_content":"这个在 GO 里面有一个自带的，还是很好用的。在 JAVA 那边的话，得找找开源框架，我几年没写 JAVA，已经不太记得了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696922500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1195258,"avatar":"https://static001.geekbang.org/account/avatar/00/12/3c/fa/e2990931.jpg","nickname":"文敦复","note":"","ucode":"B8F4A6BD5D7805","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":629323,"discussion_content":"Java的缓存框架caffeine实现单机下的Singleflight，使用带function的方法就行了：` V get( K key, Function mappingFunction); ` 其内部将mappingFunction封装成了CompletableFuture，并且将这个future缓存在asyncCache中，当缓存没有，需要查第三方时，会通过key去拿之前生成的future（如果没有会创建的），当key对应的第一个也是唯一的future完成时，get到的就是结果啦。具体代码在：`com.github.benmanes.caffeine.cache.LocalAsyncCache.AbstractCacheView#get`。如果要在分布式情况下做Singleflight，感觉可以用MQ来互相通知？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1696928925,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"四川","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":381119,"user_name":"Geek8004","can_delete":false,"product_type":"c1","uid":2328971,"ip_address":"中国香港","ucode":"B3828F6414BDB0","user_header":"","comment_is_top":false,"comment_ctime":1694693420,"is_pvip":false,"replies":[{"id":138850,"content":"这个是为了避免一台实例有多个线程去抢分布式锁。就好比，你高三这一个年级有十个班。现在有一种比赛，如果你说任何人都可以报名参加，那么就是十个班的所有学生一起去抢夺金牌。\n引入 singleflight 的意思就是，你每个班先自己内部比一比，选出一个，那么在整个年级上，就是十个人在抢夺金牌。","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1694781352,"ip_address":"广东","comment_id":381119,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"Singleflight为啥之歌模式要加分布式锁呀,redis不是单线程的吗,那我理解这种读的写的请求会在等待队列里面排队呀","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628036,"discussion_content":"这个是为了避免一台实例有多个线程去抢分布式锁。就好比，你高三这一个年级有十个班。现在有一种比赛，如果你说任何人都可以报名参加，那么就是十个班的所有学生一起去抢夺金牌。\n引入 singleflight 的意思就是，你每个班先自己内部比一比，选出一个，那么在整个年级上，就是十个人在抢夺金牌。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694781352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380926,"user_name":"Geek8004","can_delete":false,"product_type":"c1","uid":2328971,"ip_address":"日本","ucode":"B3828F6414BDB0","user_header":"","comment_is_top":false,"comment_ctime":1694446669,"is_pvip":false,"replies":[{"id":138856,"content":"你的缓存中间件帮你封装，我在 Beego 的 Cache 里面让我的小伙伴实现了。你可以去看看","user_name":"作者回复","user_name_real":"编辑","uid":1176655,"ctime":1694782067,"ip_address":"广东","comment_id":380926,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"让缓存去更新数据库，然后缓存自己删除自己的数据. 这个怎么实现的,没这么玩儿过. 缓存里面没有菜做的空间呀,一般都是业务里面才能写代码,发指令吗? redis怎么更新db? 监听相关事件? 还是怎么地.  老师求指点","like_count":0,"discussions":[{"author":{"id":1176655,"avatar":"https://static001.geekbang.org/account/avatar/00/11/f4/4f/aa916c8c.jpg","nickname":"邓小明","note":"","ucode":"02243D1F7492A6","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":628042,"discussion_content":"你的缓存中间件帮你封装，我在 Beego 的 Cache 里面让我的小伙伴实现了。你可以去看看","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694782067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":394468,"user_name":"Acloud","can_delete":false,"product_type":"c1","uid":2438891,"ip_address":"广东","ucode":"58D3289661C85E","user_header":"https://static001.geekbang.org/account/avatar/00/25/36/eb/d9e0fd38.jpg","comment_is_top":false,"comment_ctime":1726889627,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100551601,"comment_content":"学习总结：缓存模式：cache aside 、write through、read through、write back、singlefight；删缓存、延迟双删\n其中除来write_back，延迟双删，其余都有缓存一致性问题；write_back如果使用本地缓存也会有缓存一致性问题","like_count":0},{"had_liked":false,"id":392637,"user_name":"Geek5198","can_delete":false,"product_type":"c1","uid":2028945,"ip_address":"北京","ucode":"2BEBE6A39D9A0E","user_header":"","comment_is_top":false,"comment_ctime":1721372269,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"setnx解决缓存一致性问题，好像还是有点问题。\n例如：\n1.读请求，缓存未命中\n2.读数据库a=3\n3.写请求 a=4\n4.读请求，回写缓存a=3\n5.异步刷新缓存a=4。\n由于第5步使用setnx命令，而缓存中已经有a=3了，因此第5步失败。此时怎么弄？\n","like_count":0,"discussions":[{"author":{"id":1145759,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7b/9f/c5ad6512.jpg","nickname":"zero","note":"","ucode":"D8A22815D8987C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":650891,"discussion_content":"是第4步的时候，setnx，不是第5步的时候","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1725804166,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"福建","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":389269,"user_name":"Geek_d","can_delete":false,"product_type":"c1","uid":1809310,"ip_address":"广东","ucode":"4263F04D791BF1","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIOHnzdDDhw7bguYh6v0GYiaenmYnlN1Dg6jyX2ficfkYRO3SXDzddShfzJPEuEbJ4hdLItXBq0YGMA/132","comment_is_top":false,"comment_ctime":1711989748,"is_pvip":false,"replies":null,"discussion_count":2,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"没理解，cache aside 线程1 更新缓存为啥为滞后于线程2，按道理线程1先进来是会优先于线程2处理完缓存的，哪位大佬帮忙解惑一下","like_count":0,"discussions":[{"author":{"id":3601364,"avatar":"https://static001.geekbang.org/account/avatar/00/36/f3/d4/86a99ae0.jpg","nickname":"哆啦a喵","note":"","ucode":"AE5E51BB43753D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644775,"discussion_content":"而且你的数据库也是跑在服务器上的，那就更不可控了\n\n这里说到底还是写mysql和写缓存这是两个操作，他们不是原子的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715511227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3601364,"avatar":"https://static001.geekbang.org/account/avatar/00/36/f3/d4/86a99ae0.jpg","nickname":"哆啦a喵","note":"","ucode":"AE5E51BB43753D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644773,"discussion_content":"因为这里的线程操作都是网络操作，所以时间是不可控，举个直观的例子，跨机房的场景下，如果线程1是跨机房请求，线程2是同一个机房请求，线程1操作完数据库之后，网络返回的时间就可能很长，长到线程2的同机房请求已经完成了数据库更新和缓存更新，这时线程1再去更新数据库就有问题了。\n\n其实跨机房看着还是一个可以去优化的场景，但实际上算是两台不同的实例，可能因为自身性能的问题，都有可能出现请求时间不一致的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715511040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":388568,"user_name":"shikamaru","can_delete":false,"product_type":"c1","uid":3787155,"ip_address":"四川","ucode":"19260049B7F498","user_header":"https://static001.geekbang.org/account/avatar/00/39/c9/93/13c7d9aa.jpg","comment_is_top":false,"comment_ctime":1710405705,"is_pvip":false,"replies":null,"discussion_count":1,"race_medal":0,"score":3,"product_id":100551601,"comment_content":"老师，“Write Through 没有要求先写数据库还是先写缓存，不过一般也是先写数据库”这句存疑，Read&#47;Write Through 读写都是先操作cache才对呀，不然不符合“Read&#47;Write Through”的字面意思","like_count":0,"discussions":[{"author":{"id":3601364,"avatar":"https://static001.geekbang.org/account/avatar/00/36/f3/d4/86a99ae0.jpg","nickname":"哆啦a喵","note":"","ucode":"AE5E51BB43753D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":644777,"discussion_content":"我理解这里的缓存模式，只是对缓存中间件的封装，也就是我们自己用代码写一个新的缓存Client，操作缓存中间件的时候在我们的代码里去做这些缓存模式要做的事情。\n\n那我理解其实在任何情况下，我们都不应该出现sql数据库存储错误数据，缓存数据正确的情况，除非一些极端case和业务场景。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1715511660,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]}]}