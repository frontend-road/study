{"id":478192,"title":"34｜并发：如何使用共享变量？","content":"<p>你好，我是Tony Bai。</p><p>在前面的讲解中，我们学习了Go的并发实现方案，知道了Go基于Tony Hoare的<strong>CSP并发模型</strong>理论，实现了Goroutine、channel等并发原语。</p><p>并且，Go语言之父Rob Pike还有一句经典名言：“不要通过共享内存来通信，应该通过通信来共享内存（Don’t communicate by sharing memory, share memory by communicating）”，这就奠定了Go应用并发设计的主流风格：<strong>使用channel进行不同Goroutine间的通信</strong>。</p><p>不过，Go也并没有彻底放弃基于共享内存的并发模型，而是在提供CSP并发模型原语的同时，还通过标准库的sync包，提供了针对传统的、基于共享内存并发模型的低级同步原语，包括：互斥锁（sync.Mutex）、读写锁（sync.RWMutex）、条件变量（sync.Cond）等，并通过atomic包提供了原子操作原语等等。显然，基于共享内存的并发模型在Go语言中依然有它的“用武之地”。</p><p>所以，在并发的最后一讲，我们就围绕sync包中的几个同步结构与对应的方法，聊聊基于共享内存的并发模型在Go中的应用。</p><p>我们先来看看在哪些场景下，我们需要用到sync包提供的低级同步原语。</p><!-- [[[read_end]]] --><h2>sync包低级同步原语可以用在哪？</h2><p>这里我要先强调一句，一般情况下，我建议你优先使用CSP并发模型进行并发程序设计。但是在下面一些场景中，我们依然需要sync包提供的低级同步原语。</p><p><strong>首先是需要高性能的临界区（critical section）同步机制场景。</strong></p><p>在Go中，channel并发原语也可以用于对数据对象访问的同步，我们可以把channel看成是一种高级的同步原语，它自身的实现也是建构在低级同步原语之上的。也正因为如此，channel自身的性能与低级同步原语相比要略微逊色，开销要更大。</p><p>这里，关于sync.Mutex和channel各自实现的临界区同步机制，我做了一个简单的性能基准测试对比，通过对比结果，我们可以很容易看出两者的性能差异：</p><pre><code class=\"language-plain\">var cs = 0 // 模拟临界区要保护的数据\nvar mu sync.Mutex\nvar c = make(chan struct{}, 1)\n\nfunc criticalSectionSyncByMutex() {\n    mu.Lock()\n    cs++\n    mu.Unlock()\n}\n\nfunc criticalSectionSyncByChan() {\n    c &lt;- struct{}{}\n    cs++\n    &lt;-c\n}\n\nfunc BenchmarkCriticalSectionSyncByMutex(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        criticalSectionSyncByMutex()\n    }\n}\n\nfunc BenchmarkCriticalSectionSyncByMutexInParallel(b *testing.B) {\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            criticalSectionSyncByMutex()\n        }\n    })\n}\n\nfunc BenchmarkCriticalSectionSyncByChan(b *testing.B) {\n    for n := 0; n &lt; b.N; n++ {\n        criticalSectionSyncByChan()\n    }\n}\n\nfunc BenchmarkCriticalSectionSyncByChanInParallel(b *testing.B) {\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            criticalSectionSyncByChan()\n        }\n    })\n}\n</code></pre><p>运行这个对比测试（Go 1.17），我们得到：</p><pre><code class=\"language-plain\">$go test -bench .\ngoos: darwin\ngoarch: amd64\n... ...\nBenchmarkCriticalSectionSyncByMutex-8             \t88083549\t        13.64 ns/op\nBenchmarkCriticalSectionSyncByMutexInParallel-8   \t22337848\t        55.29 ns/op\nBenchmarkCriticalSectionSyncByChan-8              \t28172056\t        42.48 ns/op\nBenchmarkCriticalSectionSyncByChanInParallel-8    \t 5722972\t       208.1 ns/op\nPASS\n</code></pre><p>通过这个对比实验，我们可以看到，无论是在单Goroutine情况下，还是在并发测试情况下，<code>sync.Mutex</code>实现的同步机制的性能，都要比channel实现的高出三倍多。</p><p>因此，通常在需要高性能的临界区（critical section）同步机制的情况下，sync包提供的低级同步原语更为适合。</p><p><strong>第二种就是在不想转移结构体对象所有权，但又要保证结构体内部状态数据的同步访问的场景。</strong></p><p>基于channel的并发设计，有一个特点：在Goroutine间通过channel转移数据对象的所有权。所以，只有拥有数据对象所有权（从channel接收到该数据）的Goroutine才可以对该数据对象进行状态变更。</p><p>如果你的设计中没有转移结构体对象所有权，但又要保证结构体内部状态数据在多个Goroutine之间同步访问，那么你可以使用sync包提供的低级同步原语来实现，比如最常用的<code>sync.Mutex</code>。</p><p>了解了这些应用场景之后，接着我们就来看看如何使用sync包中的各个同步结构，不过在使用之前，我们需要先看看一个sync包中同步原语使用的注意事项。</p><h2>sync包中同步原语使用的注意事项</h2><p>在sync包的注释中（在<code>$GOROOT/src/sync/mutex.go</code>文件的头部注释），我们看到这样一行说明：</p><pre><code class=\"language-plain\">// Values containing the types defined in this package should not be copied.\n</code></pre><p>翻译过来就是：“不应复制那些包含了此包中类型的值”。</p><p>在sync包的其他源文件中，我们同样看到类似的一些注释：</p><pre><code class=\"language-plain\">\n// $GOROOT/src/sync/mutex.go\n// A Mutex must not be copied after first use. （禁止复制首次使用后的Mutex）\n\n// $GOROOT/src/sync/rwmutex.go\n// A RWMutex must not be copied after first use.（禁止复制首次使用后的RWMutex）\n\n// $GOROOT/src/sync/cond.go\n// A Cond must not be copied after first use.（禁止复制首次使用后的Cond）\n... ...\n</code></pre><p>那么，为什么首次使用Mutex等sync包中定义的结构类型后，我们不应该再对它们进行复制操作呢？我们以Mutex这个同步原语为例，看看它的实现是怎样的。</p><p>Go标准库中sync.Mutex的定义是这样的：</p><pre><code class=\"language-plain\">// $GOROOT/src/sync/mutex.go\ntype Mutex struct {\n    state int32\n    sema  uint32\n}\n</code></pre><p>我们看到，Mutex的定义非常简单，由两个整型字段state和sema组成：</p><ul>\n<li>state：表示当前互斥锁的状态；</li>\n<li>sema：用于控制锁状态的信号量。</li>\n</ul><p>初始情况下，Mutex的实例处于<strong>Unlocked</strong>状态（state和sema均为0）。对Mutex实例的复制也就是两个整型字段的复制。一旦发生复制，原变量与副本就是两个单独的内存块，各自发挥同步作用，互相就没有了关联。</p><p>如果发生复制后，你仍然认为原变量与副本保护的是同一个数据对象，那可就大错特错了。我们来看一个例子：</p><pre><code class=\"language-plain\"> func main() {\n     var wg sync.WaitGroup\n     i := 0\n     var mu sync.Mutex // 负责对i的同步访问\n \n     wg.Add(1)\n     // g1\n     go func(mu1 sync.Mutex) {\n         mu1.Lock()\n         i = 10\n         time.Sleep(10 * time.Second)\n         fmt.Printf(\"g1: i = %d\\n\", i)\n         mu1.Unlock()\n         wg.Done()\n     }(mu)\n \n     time.Sleep(time.Second)\n \n     mu.Lock()\n     i = 1\n     fmt.Printf(\"g0: i = %d\\n\", i)\n     mu.Unlock()\n \n     wg.Wait()\n }\n</code></pre><p>在这个例子中，我们使用一个sync.Mutex类型变量mu来同步对整型变量i的访问。我们创建一个新Goroutine：g1，g1通过函数参数得到mu的一份拷贝mu1，然后g1会通过mu1来同步对整型变量i的访问。</p><p>那么，g0通过mu和g1通过mu的拷贝mu1，是否能实现对同一个变量i的同步访问呢？我们来看看运行这个示例的运行结果：</p><pre><code class=\"language-plain\">g0: i = 1\ng1: i = 1\n</code></pre><p>从结果来看，这个程序并没有实现对i的同步访问，第9行g1对mu1的加锁操作，并没能阻塞第19行g0对mu的加锁。于是，g1刚刚将i赋值为10后，g0就又将i赋值为1了。</p><p>出现这种结果的原因就是我们前面分析的情况，一旦Mutex类型变量被拷贝，原变量与副本就各自发挥作用，互相没有关联了。甚至，如果拷贝的时机不对，比如在一个mutex处于locked的状态时对它进行了拷贝，就会对副本进行加锁操作，将导致加锁的Goroutine永远阻塞下去。</p><p>通过前面这个例子，我们可以很直观地看到：如果对使用过的、sync包中的类型的示例进行复制，并使用了复制后得到的副本，将导致不可预期的结果。所以，在使用sync包中的类型的时候，我们推荐通过<strong>闭包</strong>方式，或者是<strong>传递类型实例（或包裹该类型的类型实例）的地址（指针）</strong>的方式进行。这就是使用sync包时最值得我们注意的事项。</p><p>接下来，我们就来逐个分析日常使用较多的sync包中同步原语。我们先来看看互斥锁与读写锁。</p><h2>互斥锁（Mutex）还是读写锁（RWMutex）？</h2><p>sync包提供了两种用于临界区同步的原语：互斥锁（Mutex）和读写锁（RWMutex）。它们都是零值可用的数据类型，也就是不需要显式初始化就可以使用，并且使用方法都比较简单。在上面的示例中，我们已经看到了Mutex的应用方法，这里再总结一下：</p><pre><code class=\"language-plain\">var mu sync.Mutex\nmu.Lock()   // 加锁\ndoSomething()\nmu.Unlock() // 解锁\n</code></pre><p>一旦某个Goroutine调用的Mutex执行Lock操作成功，它将成功持有这把互斥锁。这个时候，如果有其他Goroutine执行Lock操作，就会阻塞在这把互斥锁上，直到持有这把锁的Goroutine调用Unlock释放掉这把锁后，才会抢到这把锁的持有权并进入临界区。</p><p>由此，我们也可以得到使用互斥锁的两个原则：</p><ul>\n<li><strong>尽量减少在锁中的操作</strong>。这可以减少其他因Goroutine阻塞而带来的损耗与延迟。</li>\n<li><strong>一定要记得调用Unlock解锁</strong>。忘记解锁会导致程序局部死锁，甚至是整个程序死锁，会导致严重的后果。同时，我们也可以结合第23讲学习到的defer，优雅地执行解锁操作。</li>\n</ul><p>读写锁与互斥锁用法大致相同，只不过多了一组加读锁和解读锁的方法：</p><pre><code class=\"language-plain\">var rwmu sync.RWMutex\nrwmu.RLock()   //加读锁\nreadSomething()\nrwmu.RUnlock() //解读锁\nrwmu.Lock()    //加写锁\nchangeSomething()\nrwmu.Unlock()  //解写锁\n</code></pre><p>写锁与Mutex的行为十分类似，一旦某Goroutine持有写锁，其他Goroutine无论是尝试加读锁，还是加写锁，都会被阻塞在写锁上。</p><p>但读锁就宽松多了，一旦某个Goroutine持有读锁，它不会阻塞其他尝试加读锁的Goroutine，但加写锁的Goroutine依然会被阻塞住。</p><p>通常，<strong>互斥锁（Mutex）是临时区同步原语的首选</strong>，它常被用来对结构体对象的内部状态、缓存等进行保护，是使用最为广泛的临界区同步原语。相比之下，读写锁的应用就没那么广泛了，只活跃于它擅长的场景下。</p><p>那读写锁（RWMutex）究竟擅长在哪种场景下呢？我们先来看一组基准测试：</p><pre><code class=\"language-plain\">var cs1 = 0 // 模拟临界区要保护的数据\nvar mu1 sync.Mutex\n\nvar cs2 = 0 // 模拟临界区要保护的数据\nvar mu2 sync.RWMutex\n\nfunc BenchmarkWriteSyncByMutex(b *testing.B) {\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            mu1.Lock()\n            cs1++\n            mu1.Unlock()\n        }\n    })\n}\n\nfunc BenchmarkReadSyncByMutex(b *testing.B) {\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            mu1.Lock()\n            _ = cs1\n            mu1.Unlock()\n        }\n    })\n}\n\nfunc BenchmarkReadSyncByRWMutex(b *testing.B) {\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            mu2.RLock()\n            _ = cs2\n            mu2.RUnlock()\n        }\n    })\n}\n\nfunc BenchmarkWriteSyncByRWMutex(b *testing.B) {\n    b.RunParallel(func(pb *testing.PB) {\n        for pb.Next() {\n            mu2.Lock()\n            cs2++\n            mu2.Unlock()\n        }\n    })\n}\n</code></pre><p>这些基准测试都是并发测试，度量的是Mutex、RWMutex在并发下的读写性能。我们分别在cpu=2、8、16、32的情况下运行这个并发性能测试，测试结果如下：</p><pre><code class=\"language-plain\">goos: darwin\ngoarch: amd64\n... ...\nBenchmarkWriteSyncByMutex-2     \t73423770\t        16.12 ns/op\nBenchmarkReadSyncByMutex-2      \t84031135\t        15.08 ns/op\nBenchmarkReadSyncByRWMutex-2    \t37182219\t        31.87 ns/op\nBenchmarkWriteSyncByRWMutex-2   \t40727782\t        29.08 ns/op\n\nBenchmarkWriteSyncByMutex-8     \t22153354\t        56.39 ns/op\nBenchmarkReadSyncByMutex-8      \t24164278\t        51.12 ns/op\nBenchmarkReadSyncByRWMutex-8    \t38589122\t        31.17 ns/op\nBenchmarkWriteSyncByRWMutex-8   \t18482208\t        65.27 ns/op\n\nBenchmarkWriteSyncByMutex-16      \t20672842\t        62.94 ns/op\nBenchmarkReadSyncByMutex-16       \t19247158\t        62.94 ns/op\nBenchmarkReadSyncByRWMutex-16     \t29978614\t        39.98 ns/op\nBenchmarkWriteSyncByRWMutex-16    \t16095952\t        78.19 ns/op\n\nBenchmarkWriteSyncByMutex-32      \t20539290\t        60.20 ns/op\nBenchmarkReadSyncByMutex-32       \t18807060\t        72.61 ns/op\nBenchmarkReadSyncByRWMutex-32     \t29772936\t        40.45 ns/op\nBenchmarkWriteSyncByRWMutex-32    \t13320544\t        86.53 ns/op\n</code></pre><p>通过测试结果对比，我们得到了一些结论：</p><ul>\n<li>并发量较小的情况下，Mutex性能最好；随着并发量增大，Mutex的竞争激烈，导致加锁和解锁性能下降；</li>\n<li>RWMutex的读锁性能并没有随着并发量的增大，而发生较大变化，性能始终恒定在40ns左右；</li>\n<li>在并发量较大的情况下，RWMutex的写锁性能和Mutex、RWMutex读锁相比，是最差的，并且随着并发量增大，RWMutex写锁性能有继续下降趋势。</li>\n</ul><p>由此，我们就可以看出，<strong>读写锁适合应用在具有一定并发量且读多写少的场合</strong>。在大量并发读的情况下，多个Goroutine可以同时持有读锁，从而减少在锁竞争中等待的时间。</p><p>而互斥锁，即便是读请求的场合，同一时刻也只能有一个Goroutine持有锁，其他Goroutine只能阻塞在加锁操作上等待被调度。</p><p>接下来，我们继续看条件变量sync.Cond。</p><h2>条件变量</h2><p><code>sync.Cond</code>是传统的条件变量原语概念在Go语言中的实现。我们可以把一个条件变量理解为一个容器，这个容器中存放着一个或一组等待着某个条件成立的Goroutine。当条件成立后，这些处于等待状态的Goroutine将得到通知，并被唤醒继续进行后续的工作。这与百米飞人大战赛场上，各位运动员等待裁判员的发令枪声的情形十分类似。</p><p>条件变量是同步原语的一种，如果没有条件变量，开发人员可能需要在Goroutine中通过连续轮询的方式，检查某条件是否为真，这种连续轮询非常消耗资源，因为Goroutine在这个过程中是处于活动状态的，但它的工作又没有进展。</p><p>这里我们先看一个用<code>sync.Mutex</code> 实现对条件轮询等待的例子：</p><pre><code class=\"language-go\">type signal struct{}\n\nvar ready bool\n\nfunc worker(i int) {\n\tfmt.Printf(\"worker %d: is working...\\n\", i)\n\ttime.Sleep(1 * time.Second)\n\tfmt.Printf(\"worker %d: works done\\n\", i)\n}\n\nfunc spawnGroup(f func(i int), num int, mu *sync.Mutex) &lt;-chan signal {\n\tc := make(chan signal)\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i &lt; num; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tfor {\n\t\t\t\tmu.Lock()\n\t\t\t\tif !ready {\n\t\t\t\t\tmu.Unlock()\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tmu.Unlock()\n\t\t\t\tfmt.Printf(\"worker %d: start to work...\\n\", i)\n\t\t\t\tf(i)\n\t\t\t\twg.Done()\n\t\t\t\treturn\n\t\t\t}\n\t\t}(i + 1)\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tc &lt;- signal(struct{}{})\n\t}()\n\treturn c\n}\n\nfunc main() {\n\tfmt.Println(\"start a group of workers...\")\n\tmu := &amp;sync.Mutex{}\n\tc := spawnGroup(worker, 5, mu)\n\n\ttime.Sleep(5 * time.Second) // 模拟ready前的准备工作\n\tfmt.Println(\"the group of workers start to work...\")\n\n\tmu.Lock()\n\tready = true\n\tmu.Unlock()\n\n\t&lt;-c\n\tfmt.Println(\"the group of workers work done!\")\n}\n</code></pre><p>就像前面提到的，轮询的方式开销大，轮询间隔设置的不同，条件检查的及时性也会受到影响。<br>\n<code>sync.Cond</code>为Goroutine在这个场景下提供了另一种可选的、资源消耗更小、使用体验更佳的同步方式。使用条件变量原语，我们可以在实现相同目标的同时，避免对条件的轮询。</p><p>我们用<code>sync.Cond</code>对上面的例子进行改造，改造后的代码如下：</p><pre><code class=\"language-plain\">type signal struct{}\n\nvar ready bool\n\nfunc worker(i int) {\n\tfmt.Printf(\"worker %d: is working...\\n\", i)\n\ttime.Sleep(1 * time.Second)\n\tfmt.Printf(\"worker %d: works done\\n\", i)\n}\n\nfunc spawnGroup(f func(i int), num int, groupSignal *sync.Cond) &lt;-chan signal {\n\tc := make(chan signal)\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i &lt; num; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tgroupSignal.L.Lock()\n\t\t\tfor !ready {\n\t\t\t\tgroupSignal.Wait()\n\t\t\t}\n\t\t\tgroupSignal.L.Unlock()\n\t\t\tfmt.Printf(\"worker %d: start to work...\\n\", i)\n\t\t\tf(i)\n\t\t\twg.Done()\n\t\t}(i + 1)\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tc &lt;- signal(struct{}{})\n\t}()\n\treturn c\n}\n\nfunc main() {\n\tfmt.Println(\"start a group of workers...\")\n\tgroupSignal := sync.NewCond(&amp;sync.Mutex{})\n\tc := spawnGroup(worker, 5, groupSignal)\n\n\ttime.Sleep(5 * time.Second) // 模拟ready前的准备工作\n\tfmt.Println(\"the group of workers start to work...\")\n\n\tgroupSignal.L.Lock()\n\tready = true\n\tgroupSignal.Broadcast()\n\tgroupSignal.L.Unlock()\n\n\t&lt;-c\n\tfmt.Println(\"the group of workers work done!\")\n}\n</code></pre><p>我们运行这个示例程序，得到：</p><pre><code class=\"language-plain\">start a group of workers...\nthe group of workers start to work...\nworker 2: start to work...\nworker 2: is working...\nworker 3: start to work...\nworker 3: is working...\nworker 1: start to work...\nworker 1: is working...\nworker 4: start to work...\nworker 5: start to work...\nworker 5: is working...\nworker 4: is working...\nworker 4: works done\nworker 2: works done\nworker 3: works done\nworker 1: works done\nworker 5: works done\nthe group of workers work done!\n</code></pre><p>我们看到，<code>sync.Cond</code>实例的初始化，需要一个满足实现了<code>sync.Locker</code>接口的类型实例，通常我们使用<code>sync.Mutex</code>。</p><p>条件变量需要这个互斥锁来同步临界区，保护用作条件的数据。加锁后，各个等待条件成立的Goroutine判断条件是否成立，如果不成立，则调用<code>sync.Cond</code>的Wait方法进入等待状态。Wait方法在Goroutine挂起前会进行Unlock操作。</p><p>当main goroutine将<code>ready</code>置为true，并调用<code>sync.Cond</code>的Broadcast方法后，各个阻塞的Goroutine将被唤醒，并从Wait方法中返回。Wait方法返回前，Wait方法会再次加锁让Goroutine进入临界区。接下来Goroutine会再次对条件数据进行判定，如果条件成立，就会解锁并进入下一个工作阶段；如果条件依旧不成立，那么会再次进入循环体，并调用Wait方法挂起等待。</p><p>和<code>sync.Mutex</code> 、<code>sync.RWMutex</code>等相比，<code>sync.Cond</code> 应用的场景更为有限，只有在需要“等待某个条件成立”的场景下，Cond才有用武之地。</p><p>其实，面向CSP并发模型的channel原语和面向传统共享内存并发模型的sync包提供的原语，已经能够满足Go语言应用并发设计中99.9%的并发同步需求了。而剩余那0.1%的需求，我们可以使用Go标准库提供的atomic包来实现。</p><h2>原子操作（atomic operations）</h2><p>atomic包是Go语言给用户提供的原子操作原语的相关接口。原子操作（atomic operations）是相对于普通指令操作而言的。</p><p>我们以一个整型变量自增的语句为例说明一下：</p><pre><code class=\"language-plain\">var a int\na++\n</code></pre><p>a++这行语句需要3条普通机器指令来完成变量a的自增：</p><ul>\n<li>LOAD：将变量从内存加载到CPU寄存器；</li>\n<li>ADD：执行加法指令；</li>\n<li>STORE：将结果存储回原内存地址中。</li>\n</ul><p>这3条普通指令在执行过程中是可以被中断的。而原子操作的指令是不可中断的，它就好比一个事务，要么不执行，一旦执行就一次性全部执行完毕，中间不可分割。也正因为如此，原子操作也可以被用于共享数据的并发同步。</p><p>原子操作由底层硬件直接提供支持，是一种硬件实现的指令级的“事务”，因此相对于操作系统层面和Go运行时层面提供的同步技术而言，它更为原始。</p><p>atomic包封装了CPU实现的部分原子操作指令，为用户层提供体验良好的原子操作函数，因此atomic包中提供的原语更接近硬件底层，也更为低级，它也常被用于实现更为高级的并发同步技术，比如channel和sync包中的同步原语。</p><p>我们以atomic.SwapInt64函数在x86_64平台上的实现为例，看看这个函数的实现方法：</p><pre><code class=\"language-go\">// $GOROOT/src/sync/atomic/doc.go\nfunc SwapInt64(addr *int64, new int64) (old int64)\n\n// $GOROOT/src/sync/atomic/asm.s\n\nTEXT ·SwapInt64(SB),NOSPLIT,$0\n        JMP     runtime∕internal∕atomic·Xchg64(SB)\n\n// $GOROOT/src/runtime/internal/atomic/asm_amd64.s\nTEXT runtime∕internal∕atomic·Xchg64(SB), NOSPLIT, $0-24\n        MOVQ    ptr+0(FP), BX\n        MOVQ    new+8(FP), AX\n        XCHGQ   AX, 0(BX)\n        MOVQ    AX, ret+16(FP)\n        RET\n\n</code></pre><p>从函数SwapInt64的实现中，我们可以看到：它基本就是对x86_64 CPU实现的原子操作指令<code>XCHGQ</code>的直接封装。</p><p>原子操作的特性，让atomic包也可以被用作对共享数据的并发同步，那么和更为高级的channel以及sync包中原语相比，我们究竟该怎么选择呢？</p><p>我们先来看看atomic包提供了哪些能力。</p><p>atomic包提供了两大类原子操作接口，一类是针对整型变量的，包括有符号整型、无符号整型以及对应的指针类型；另外一类是针对自定义类型的。因此，第一类原子操作接口的存在让atomic包天然适合去实现某一个共享整型变量的并发同步。</p><p>我们再看一个例子：</p><pre><code class=\"language-go\">var n1 int64\n\nfunc addSyncByAtomic(delta int64) int64 {\n\treturn atomic.AddInt64(&amp;n1, delta)\n}\n\nfunc readSyncByAtomic() int64 {\n\treturn atomic.LoadInt64(&amp;n1)\n}\n\nvar n2 int64\nvar rwmu sync.RWMutex\n\nfunc addSyncByRWMutex(delta int64) {\n\trwmu.Lock()\n\tn2 += delta\n\trwmu.Unlock()\n}\n\nfunc readSyncByRWMutex() int64 {\n\tvar n int64\n\trwmu.RLock()\n\tn = n2\n\trwmu.RUnlock()\n\treturn n\n}\n\nfunc BenchmarkAddSyncByAtomic(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\taddSyncByAtomic(1)\n\t\t}\n\t})\n}\n\nfunc BenchmarkReadSyncByAtomic(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\treadSyncByAtomic()\n\t\t}\n\t})\n}\n\nfunc BenchmarkAddSyncByRWMutex(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\taddSyncByRWMutex(1)\n\t\t}\n\t})\n}\n\nfunc BenchmarkReadSyncByRWMutex(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\treadSyncByRWMutex()\n\t\t}\n\t})\n}\n\n</code></pre><p>我们分别在cpu=2、 8、16、32的情况下运行上述性能基准测试，得到结果如下：</p><pre><code class=\"language-go\">goos: darwin\ngoarch: amd64\n... ...\nBenchmarkAddSyncByAtomic-2     \t75426774\t        17.69 ns/op\nBenchmarkReadSyncByAtomic-2    \t1000000000\t         0.7437 ns/op\nBenchmarkAddSyncByRWMutex-2    \t39041671\t        30.16 ns/op\nBenchmarkReadSyncByRWMutex-2   \t41325093\t        28.48 ns/op\n\nBenchmarkAddSyncByAtomic-8     \t77497987\t        15.25 ns/op\nBenchmarkReadSyncByAtomic-8    \t1000000000\t         0.2395 ns/op\nBenchmarkAddSyncByRWMutex-8    \t17702034\t        67.16 ns/op\nBenchmarkReadSyncByRWMutex-8   \t29966182\t        40.37 ns/op\n\nBenchmarkAddSyncByAtomic-16      \t57727968\t        20.39 ns/op\nBenchmarkReadSyncByAtomic-16     \t1000000000\t         0.2536 ns/op\nBenchmarkAddSyncByRWMutex-16     \t15029635\t        78.61 ns/op\nBenchmarkReadSyncByRWMutex-16    \t29722464\t        40.28 ns/op\n\nBenchmarkAddSyncByAtomic-32      \t58010497\t        20.40 ns/op\nBenchmarkReadSyncByAtomic-32     \t1000000000\t         0.2402 ns/op\nBenchmarkAddSyncByRWMutex-32     \t11748312\t        93.15 ns/op\nBenchmarkReadSyncByRWMutex-32    \t29845912\t        40.54 ns/op\n</code></pre><p>通过这个运行结果，我们可以得出一些结论：</p><ul>\n<li>读写锁的性能随着并发量增大的情况，与前面讲解的sync.RWMutex一致；</li>\n<li>利用原子操作的无锁并发写的性能，随着并发量增大几乎保持恒定；</li>\n<li>利用原子操作的无锁并发读的性能，随着并发量增大有持续提升的趋势，并且性能是读锁的约200倍。</li>\n</ul><p>通过这些结论，我们大致可以看到atomic原子操作的特性：随着并发量提升，使用atomic实现的<strong>共享变量</strong>的并发读写性能表现更为稳定，尤其是原子读操作，和sync包中的读写锁原语比起来，atomic表现出了更好的伸缩性和高性能。</p><p>由此，我们也可以看出atomic包更适合<strong>一些对性能十分敏感、并发量较大且读多写少的场合</strong>。</p><p>不过，atomic原子操作可用来同步的范围有比较大限制，只能同步一个整型变量或自定义类型变量。如果我们要对一个复杂的临界区数据进行同步，那么首选的依旧是sync包中的原语。</p><h2>小结</h2><p>好了，今天的课讲到这里就结束了，现在我们一起来回顾一下吧。</p><p>虽然Go推荐基于通信来共享内存的并发设计风格，但Go并没有彻底抛弃对基于共享内存并发模型的支持，Go通过标准库的sync包以及atomic包提供了低级同步原语。这些原语有着它们自己的应用场景。</p><p>如果我们考虑使用低级同步原语，一般都是因为低级同步原语可以提供<strong>更佳的性能表现</strong>，性能基准测试结果告诉我们，使用低级同步原语的性能可以高出channel许多倍。在性能敏感的场景下，我们依然离不开这些低级同步原语。</p><p>在使用sync包提供的同步原语之前，我们一定要牢记这些原语使用的注意事项：<strong>不要复制首次使用后的Mutex/RWMutex/Cond等</strong>。一旦复制，你将很大可能得到意料之外的运行结果。</p><p>sync包中的低级同步原语各有各的擅长领域，你可以记住：</p><ul>\n<li>在具有一定并发量且读多写少的场合使用RWMutex；</li>\n<li>在需要“等待某个条件成立”的场景下使用Cond；</li>\n<li>当你不确定使用什么原语时，那就使用Mutex吧。</li>\n</ul><p>如果你对同步的性能有极致要求，且并发量较大，读多写少，那么可以考虑一下atomic包提供的原子操作函数。</p><h2>思考题</h2><p>使用基于共享内存的并发模型时，最令人头疼的可能就是“死锁”问题的存在了。你了解死锁的产生条件么？能编写一个程序模拟一下死锁的发生么？</p><p>欢迎你把这节课分享给更多对Go并发感兴趣的朋友。我是Tony Bai，我们下节课见。</p>","neighbors":{"left":{"article_title":"33｜并发：小channel中蕴含大智慧","id":477365},"right":{"article_title":"35｜即学即练：如何实现一个轻量级线程池？","id":479171}},"comments":[{"had_liked":false,"id":330679,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1642119526,"is_pvip":false,"replies":[{"id":"121575","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1643512303,"ip_address":"","comment_id":330679,"utype":1}],"discussion_count":6,"race_medal":2,"score":"36001857894","product_id":100093501,"comment_content":"连续三节课都是需要花费 30 分钟才能阅读完，即使是复习也要超过 20 分钟，这几节的内容真的好充实。","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549005,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643512303,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2699840,"avatar":"https://static001.geekbang.org/account/avatar/00/29/32/40/d56f476c.jpg","nickname":"ibin","note":"","ucode":"766942C36B8E27","race_medal":1,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546024,"discussion_content":"我看了一天，是我效率太差了吗？","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642132488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1320487,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","nickname":"罗杰","note":"","ucode":"96BAFAA147341F","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":2699840,"avatar":"https://static001.geekbang.org/account/avatar/00/29/32/40/d56f476c.jpg","nickname":"ibin","note":"","ucode":"766942C36B8E27","race_medal":1,"user_type":1,"is_pvip":true},"discussion":{"id":546115,"discussion_content":"要知道我用 Go 已经开发了三年，还有近十年的编程经验","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1642163969,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546024,"ip_address":""},"score":546115,"extra":""},{"author":{"id":2809224,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/dd/88/92f8e582.jpg","nickname":"zz","note":"","ucode":"94E8990BF3E3C8","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1320487,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","nickname":"罗杰","note":"","ucode":"96BAFAA147341F","race_medal":2,"user_type":1,"is_pvip":false},"discussion":{"id":548259,"discussion_content":"很多后面实际应用层面的都看不懂，感觉缺了很多前置知识，得去先实践一下才行","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643103467,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546115,"ip_address":""},"score":548259,"extra":""},{"author":{"id":1320487,"avatar":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","nickname":"罗杰","note":"","ucode":"96BAFAA147341F","race_medal":2,"user_type":1,"is_pvip":false},"reply_author":{"id":2809224,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/dd/88/92f8e582.jpg","nickname":"zz","note":"","ucode":"94E8990BF3E3C8","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548268,"discussion_content":"这块内容本来就不容易理解，看不明白很正常。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643106017,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":548259,"ip_address":""},"score":548268,"extra":""}]},{"author":{"id":1248326,"avatar":"https://static001.geekbang.org/account/avatar/00/13/0c/46/dfe32cf4.jpg","nickname":"多选参数","note":"","ucode":"B2294D80AB075F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567696,"discussion_content":"我也看了快一天，里面的代码都敲了一遍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650977057,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330918,"user_name":"步比天下","can_delete":false,"product_type":"c1","uid":2295138,"ip_address":"","ucode":"120CC75E183441","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoibQLsjsrjiasFUaPdjib95Jk4y3ZMD6zXyEud7bCvibrjrPia3RCib0zTD7MahQJ41icOicIWXfbq8JpnGQ/132","comment_is_top":false,"comment_ctime":1642298705,"is_pvip":false,"replies":[{"id":"121535","content":"临界区其实就是一个代码片段。但这个代码片段中有共享的数据，这些数据不支持多个goroutine的并发访问，只能通过像channel、锁等机制同步各个goroutine的访问。同一时间，只能有一个goroutine访问这段代码，修改或读取这段代码所共享的数据。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1643441765,"ip_address":"","comment_id":330918,"utype":1}],"discussion_count":4,"race_medal":0,"score":"31707069777","product_id":100093501,"comment_content":"老师，我想问个低级的问题，什么是临界区啊，不太懂","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548896,"discussion_content":"临界区其实就是一个代码片段。但这个代码片段中有共享的数据，这些数据不支持多个goroutine的并发访问，只能通过像channel、锁等机制同步各个goroutine的访问。同一时间，只能有一个goroutine访问这段代码，修改或读取这段代码所共享的数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643441766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026593,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/aa/21/6c3ba9af.jpg","nickname":"lfn","note":"","ucode":"2E1558C6A12A89","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547325,"discussion_content":"临界区是一段可能产生竞态条件的代码","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1642613029,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1627670,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d6/16/107f0d04.jpg","nickname":"山青","note":"","ucode":"904AE3C23D3B92","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546369,"discussion_content":"就是很多goruntine都要访问的资源吧 我这么理解的 \n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642306141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1756505,"avatar":"https://static001.geekbang.org/account/avatar/00/1a/cd/59/493b8eab.jpg","nickname":"细心点","note":"","ucode":"F4D0EF8C71718E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":590431,"discussion_content":"我感觉 这个问题很高级…","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1665734943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330825,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","comment_is_top":false,"comment_ctime":1642184091,"is_pvip":false,"replies":[{"id":"121588","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1643522258,"ip_address":"","comment_id":330825,"utype":1}],"discussion_count":4,"race_medal":0,"score":"27411987867","product_id":100093501,"comment_content":"思考题：<br>死锁产生的 4 个必要条件：1) 不可剥夺；2) 请求与保持；3) 循环等待；4) 互斥。<br><br>以下模块程序会发生死锁，报 fatal error: all goroutines are asleep - deadlock!<br><br>func op1(mu1, mu2 *sync.Mutex, wg *sync.WaitGroup) {<br>\tmu1.Lock()<br>\ttime.Sleep(1 * time.Second)<br>\tmu2.Lock()<br>\tprintln(&quot;op1: do something...&quot;)<br>\tmu2.Unlock()<br>\tmu1.Unlock()<br>\twg.Done()<br>}<br><br>func op2(mu1, mu2 *sync.Mutex, wg *sync.WaitGroup) {<br>\tmu2.Lock()<br>\ttime.Sleep(2 * time.Second)<br>\tmu1.Lock()<br>\tprintln(&quot;op2: do something...&quot;)<br>\tmu1.Unlock()<br>\tmu2.Unlock()<br>\twg.Done()<br>}<br><br>func TestDeadLock(t *testing.T) {<br>\tvar mu1 sync.Mutex<br>\tvar mu2 sync.Mutex<br><br>\tvar wg sync.WaitGroup<br>\twg.Add(2)<br>\tgo op1(&amp;mu1, &amp;mu2, &amp;wg)<br>\tgo op2(&amp;mu1, &amp;mu2, &amp;wg)<br>\twg.Wait()<br>}","like_count":6,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549029,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643522258,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547474,"discussion_content":"同学，我在我的m1 Mac上面，运行这段程序，并没有报：“fatal error: all goroutines are asleep - deadlock!” 这个错误，而是程序一直阻塞着。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642688554,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547495,"discussion_content":"我用我的 Windows 11 版安装的 Goland 又试了下，是会报死锁哦。\n另外我还在官方的 Playground 上（https://go.dev/play/）也试了，也是一样报死锁！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642698067,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547474,"ip_address":""},"score":547495,"extra":""},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547578,"discussion_content":"试了下 Mac 上的确阻塞着，比较奇怪，希望有人能解惑。\n但是这个其实还是死锁的，goroutine-1 持有 mu1 锁，goroutine-2 持有 mu2 锁，然后 goroutine-1 又申请 mu2 锁，然后 goroutine-2 又申请 mu1 锁，导致相互获取不到锁，引发“死锁”问题。\n未报 all goroutines are asleep 可能是还有其他 goroutine 未阻塞，go 监控到并不是所有协程都 asleep 了，所以还没有报 fatal error!\n将 TestDeadLock 更换使用 main 函数的方式，就可以报“fatal error: all goroutines are asleep - deadlock!” 这个错误了！\n这个哥们的问题感觉和这个有点像：https://stackoverflow.com/questions/61821676/why-does-go-test-with-blocked-channel-not-reporting-deadlock","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642755283,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547474,"ip_address":""},"score":547578,"extra":""}]}]},{"had_liked":false,"id":331156,"user_name":"aoe","can_delete":false,"product_type":"c1","uid":1121758,"ip_address":"","ucode":"1C6201EDB4E954","user_header":"https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg","comment_is_top":false,"comment_ctime":1642468656,"is_pvip":false,"replies":[{"id":"121593","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1643525153,"ip_address":"","comment_id":331156,"utype":1}],"discussion_count":1,"race_medal":0,"score":"18822337840","product_id":100093501,"comment_content":"读到这里，明白了 Go 的并发不是万能的！<br>1. Go 基于 Tony Hoare 的 CSP 并发模型理论，实现了 Goroutine、channel 等并发原语；<br>2. 使用低级同步原语（标准库的 sync 包以及 atomic 包提供了低级同步原语：Mutex&#47;RWMutex&#47;Cond 等）的性能可以高出 channel 许多倍<br>3. 有锁的地方就有江湖，高并发下的性能主要拼的是算法，没有一门语言有压倒性优势","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549036,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643525153,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343522,"user_name":"Geek_62c21a","can_delete":false,"product_type":"c1","uid":2155223,"ip_address":"","ucode":"5F10926178A3DC","user_header":"https://static001.geekbang.org/account/avatar/00/20/e2/d7/8e2e0579.jpg","comment_is_top":false,"comment_ctime":1650890571,"is_pvip":true,"replies":[{"id":"125444","content":"1. 可以的。<br>2. 虽然Broadcast的参考文档也提到了：It is allowed but not required for the caller to hold c.L during the call. 对于例子来说两种写法都是ok的。但条件变量的测试条件表达式，比如本例子中的ready最好是始终在lock的保护下的。所以这里我建议用了第一种。否则在复杂的场景下，一旦unlock，条件变量测试表达式 就不受控了。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1651026093,"ip_address":"","comment_id":343522,"utype":1}],"discussion_count":1,"race_medal":0,"score":"14535792459","product_id":100093501,"comment_content":"老师，有两个问题请教您<br>1，wg.Done() 是不是在函数开始的地方写成 defer wg.Done() 会好点呢？<br>2，条件变量 broadcast 的时候，以下两种写法有区别吗？<br>第一种：<br>groupSignal.L.Lock() <br>ready = true <br>groupSignal.Broadcast()<br>groupSignal.L.Unlock()<br>第二种：<br>groupSignal.L.Lock() <br>ready = true <br>groupSignal.L.Unlock()<br>groupSignal.Broadcast()","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":567907,"discussion_content":"1. 可以的。\n2. 虽然Broadcast的参考文档也提到了：It is allowed but not required for the caller to hold c.L during the call. 对于例子来说两种写法都是ok的。但条件变量的测试条件表达式，比如本例子中的ready最好是始终在lock的保护下的。所以这里我建议用了第一种。否则在复杂的场景下，一旦unlock，条件变量测试表达式 就不受控了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1651026093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330824,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","comment_is_top":false,"comment_ctime":1642182651,"is_pvip":false,"replies":[{"id":"120910","content":"没有。Go团队认为递归锁或可重入锁是一个bad idea，所以不支持。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1642412990,"ip_address":"","comment_id":330824,"utype":1}],"discussion_count":9,"race_medal":0,"score":"10232117243","product_id":100093501,"comment_content":"老师，Go 中没有可重入的锁吗？","like_count":3,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546749,"discussion_content":"没有。Go团队认为递归锁或可重入锁是一个bad idea，所以不支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642412990,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546775,"discussion_content":"好的，谢谢老师解答","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642422014,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546749,"ip_address":""},"score":546775,"extra":""}]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547471,"discussion_content":"同学，这里的可重入锁怎么理解？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642686349,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547494,"discussion_content":"就是同一个线程它可以重复获取同一把锁多次，当然，获取了多少次，就要解锁多少次。\n例如 Java 中的 synchronized，假设有如下程序：\npublic synchronized void doSomething() { doOtherthing(); }\npublic synchronized void doOtherthing() { doAnotherthing(); }\npublic synchronized void doAnotherthing() {...}\n当线程 1 获取到方法所在类的对象的锁，去调用 doSomething() 方法，doSomething() 方法中又调用了 doOtherthing() 方法，而调用 doOtherthing() 方法需要获取同一把对象锁，如果不是可重入的，这里就会死锁了（自己锁死自己），同理 doOtherthing() 方法中调用 doAnotherthing() 方法也是一样的道理，而这里可重入的话，对于同一个线程 1，它可以多次获取这把锁（3次），方法调用返回时，解锁 3 次，从而完全释放掉这把锁，供下一个线程再次获取。\n另外，Java 中的 ReentrantLock 也是可重入锁（从名字上就可以看出来）。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1642697646,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547471,"ip_address":""},"score":547494,"extra":""},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547656,"discussion_content":"谢谢回答。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642780844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":547494,"ip_address":""},"score":547656,"extra":""}]},{"author":{"id":1102656,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d3/40/0067d6db.jpg","nickname":"AKA三皮","note":"","ucode":"D3BC5C60025E9D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546633,"discussion_content":"可重入锁的前提是知道哪个goroutine持有了这把锁，go标准库是不支持的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642382363,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1102656,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d3/40/0067d6db.jpg","nickname":"AKA三皮","note":"","ucode":"D3BC5C60025E9D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546774,"discussion_content":"不知道后面会不会支持😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642421971,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546633,"ip_address":""},"score":546774,"extra":""}]},{"author":{"id":1627670,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d6/16/107f0d04.jpg","nickname":"山青","note":"","ucode":"904AE3C23D3B92","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546370,"discussion_content":"有的  基于mutex实现的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642306162,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1627670,"avatar":"https://static001.geekbang.org/account/avatar/00/18/d6/16/107f0d04.jpg","nickname":"山青","note":"","ucode":"904AE3C23D3B92","race_medal":0,"user_type":1,"is_pvip":true},"discussion":{"id":546394,"discussion_content":"不是标准库？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642308106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546370,"ip_address":""},"score":546394,"extra":""}]}]},{"had_liked":false,"id":347042,"user_name":"非梧桐不止","can_delete":false,"product_type":"c1","uid":1803283,"ip_address":"","ucode":"F70A5D19D86742","user_header":"https://static001.geekbang.org/account/avatar/00/1b/84/13/9570f522.jpg","comment_is_top":false,"comment_ctime":1653638324,"is_pvip":true,"replies":[{"id":"126637","content":"多数情况下，对性能没有那么高要求，采用基于csp模型的并发设计是主流。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1653897741,"ip_address":"","comment_id":347042,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5948605620","product_id":100093501,"comment_content":"老师，既然共享内存的性能比channel好，为什么Go倡导用通信去共享内存呢？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574201,"discussion_content":"多数情况下，对性能没有那么高要求，采用基于csp模型的并发设计是主流。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653897741,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331776,"user_name":"文经","can_delete":false,"product_type":"c1","uid":1072346,"ip_address":"","ucode":"2C059BD2A4276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/da/0a8bc27b.jpg","comment_is_top":false,"comment_ctime":1642756576,"is_pvip":true,"replies":[{"id":"121526","content":"你的想法没错。但条件变量的性能我还真没有和channel对比过，介绍条件变量只是为了给大家“科普”一下它的存在和适合的场景。说实话，条件变量使用的很少。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1643426584,"ip_address":"","comment_id":331776,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937723872","product_id":100093501,"comment_content":"白老师，我觉得条件变量的例子完全可以用channel来实现，代码逻辑还会更简单一些。<br>使用条件变量，跟Mutex一样，是基于性能的考虑吗？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548866,"discussion_content":"你的想法没错。但条件变量的性能我还真没有和channel对比过，介绍条件变量只是为了给大家“科普”一下它的存在和适合的场景。说实话，条件变量使用的很少。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643426584,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331657,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1642689126,"is_pvip":false,"replies":[{"id":"121599","content":"1. 当原mutex出于加锁状态时被copy，copy后的mutex本身就是加锁状态，后者被使用时就会被阻塞。<br>2. 记得之前的某讲里提到过<br>3. 路径的确不对，应该是$GOROOT&#47;src&#47;runtime&#47;internal&#47;atomic&#47;asm_amd64.s ,后续让编辑老师更新一下。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1643537097,"ip_address":"","comment_id":331657,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5937656422","product_id":100093501,"comment_content":"关于Go的并发，内容挺多的。专门讲Go并发编程的书籍都有不少。大白老师这里带领我们通俗易懂地入门了。另有几个小问题。<br><br>1. 文中说：“甚至，如果拷贝的时机不对，比如在一个 mutex 处于 locked 的状态时对它进行了拷贝，就会对副本进行加锁操作，将导致加锁的 Goroutine 永远阻塞下去。”  这里不是互不相关吗？ 为什么还会对副本加锁呢？<br><br>2. 另外，好像也没讲到空结构体在channel中传递的好处？ <br><br>3.  $GOROOT&#47;src&#47;runtime&#47;internal&#47;asm_amd64.s 这个文件未找到（Mac Book 上面）。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549057,"discussion_content":"1. 当原mutex出于加锁状态时被copy，copy后的mutex本身就是加锁状态，后者被使用时就会被阻塞。\n2. 记得之前的某讲里提到过\n3. 路径的确不对，应该是$GOROOT/src/runtime/internal/atomic/asm_amd64.s ,后续让编辑老师更新一下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643537097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330823,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","comment_is_top":false,"comment_ctime":1642182411,"is_pvip":false,"replies":[{"id":"120913","content":"好问题👍！虽然都在sync包中，但sync.WaitGroup,Map，Pool层级更high一些，是基于Mutex、RWMutex和Cond这三个基本原语之上实现的机制。考虑到篇幅，这里focus Mutex、RWMutex和Cond这几个基本的原语结构了。至于“sync.WaitGroup 就没有说到，直接就使用上了”， 一是用起来很简单，二是有些时候不得不用，没有可替代手段😁。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1642413844,"ip_address":"","comment_id":330823,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5937149707","product_id":100093501,"comment_content":"老师，sync 包中还有其他的一些同步原语，后面会继续说下吗？比如前面课程和本节课中都有使用到的 sync.WaitGroup 就没有说到，直接就使用上了，另外还有 sync.Map，sync.Pool 等。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546754,"discussion_content":"好问题👍！虽然都在sync包中，但sync.WaitGroup,Map，Pool层级更high一些，是基于Mutex、RWMutex和Cond这三个基本原语之上实现的机制。考虑到篇幅，这里focus Mutex、RWMutex和Cond这几个基本的原语结构了。至于“sync.WaitGroup 就没有说到，直接就使用上了”， 一是用起来很简单，二是有些时候不得不用，没有可替代手段😁。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642413844,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546776,"discussion_content":"好的，那可能得后续自己在其他地方补习一下了。还有个Context 好像也挺重要的，和那个Channel一起讲就好了。😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642422117,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546754,"ip_address":""},"score":546776,"extra":""},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":546777,"discussion_content":"并发这个东西，的确感觉只有3节课程难以全部说完，都可以单独的的拎出来专做一门专栏课了，不知道这个专栏课结束后，老师有没有想法就这个“Go 并发”再开一个加强版专栏讲讲呢？😂","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1642422302,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546754,"ip_address":""},"score":546777,"extra":""},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/e24e181e.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547469,"discussion_content":"哈哈哈，同学好想法哦。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642686288,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546777,"ip_address":""},"score":547469,"extra":""}]}]},{"had_liked":false,"id":358036,"user_name":"冯仁彬","can_delete":false,"product_type":"c1","uid":2960877,"ip_address":"辽宁","ucode":"6E5CA08BC6366B","user_header":"","comment_is_top":false,"comment_ctime":1663839855,"is_pvip":false,"replies":[{"id":"130366","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1664112935,"ip_address":"辽宁","comment_id":358036,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1663839855","product_id":100093501,"comment_content":"以下代码会产生死锁:<br>func main() {<br>\tvar mu1 sync.Mutex<br>\tvar mu2 sync.Mutex<br>\tmu1.Lock()<br>\tgo func() {<br>\t\tmu2.Lock()<br>\t\tmu1.Lock()<br>\t\tmu1.Unlock()<br>\t\tmu2.Unlock()<br>\t\tfmt.Println(&quot;fun&quot;)<br>\t}()<br><br>\ttime.Sleep(2 * time.Second)<br>\tmu2.Lock()<br>\tmu2.Unlock()<br>\tmu1.Unlock()<br><br>\tfmt.Println(&quot;main&quot;)<br>}","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588789,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664112935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356941,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"北京","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1662713609,"is_pvip":true,"replies":[{"id":"129898","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1662780209,"ip_address":"北京","comment_id":356941,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1662713609","product_id":100093501,"comment_content":"并发这几节课需要多看几遍，老师讲解的太棒了！充实。<br>空结构体在channel中传递的好处，可以参考这篇文章关于空结构体的应用场景：https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;zbYIdB0HlYwYSQRXFFpqSg","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587086,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662780209,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京"},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":340279,"user_name":"tianbingJ","can_delete":false,"product_type":"c1","uid":2163653,"ip_address":"","ucode":"666141CAD8260F","user_header":"https://static001.geekbang.org/account/avatar/00/21/03/c5/600fd645.jpg","comment_is_top":false,"comment_ctime":1648716706,"is_pvip":true,"replies":[{"id":"124467","content":"在并发的情况下，采用直接读取x的方式读取到的不一定是x的最新值。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1648804603,"ip_address":"","comment_id":340279,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1648716706","product_id":100093501,"comment_content":"请问老师，atomic.LoadInt64(&amp;x)  和直接读取x的区别是什么？ 这里怎么体现atomic呢？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":559522,"discussion_content":"在并发的情况下，采用直接读取x的方式读取到的不一定是x的最新值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648804603,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2163653,"avatar":"https://static001.geekbang.org/account/avatar/00/21/03/c5/600fd645.jpg","nickname":"tianbingJ","note":"","ucode":"666141CAD8260F","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":559525,"discussion_content":"了解了，可见性问题哈，类似于volatile","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1648805222,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":559522,"ip_address":""},"score":559525,"extra":""}]}]},{"had_liked":false,"id":333154,"user_name":"singularity of space time","can_delete":false,"product_type":"c1","uid":2816371,"ip_address":"","ucode":"14502507C9F2D7","user_header":"https://static001.geekbang.org/account/avatar/00/2a/f9/73/01eafd3c.jpg","comment_is_top":false,"comment_ctime":1644140103,"is_pvip":true,"replies":[{"id":"121808","content":"Go中没有volatile。但go给出了自己的memory model，https:&#47;&#47;go.dev&#47;ref&#47;mem 这个也许能回答你的问题。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1644292103,"ip_address":"","comment_id":333154,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1644140103","product_id":100093501,"comment_content":"老师，请问一下Go在没有volatile的情况下如何保证共享变量在不同Goroutine的可见性？如果可见性不能保证的话，那么CAS的正确性应该也不能保证吧？还是说CAS内部的实现已经保证了可见性呢？","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549912,"discussion_content":"Go中没有volatile。但go给出了自己的memory model，https://go.dev/ref/mem 这个也许能回答你的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644292103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":2816371,"avatar":"https://static001.geekbang.org/account/avatar/00/2a/f9/73/01eafd3c.jpg","nickname":"singularity of space time","note":"","ucode":"14502507C9F2D7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":549913,"discussion_content":"谢谢老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644292254,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":549912,"ip_address":""},"score":549913,"extra":""}]}]},{"had_liked":false,"id":331775,"user_name":"文经","can_delete":false,"product_type":"c1","uid":1072346,"ip_address":"","ucode":"2C059BD2A4276B","user_header":"https://static001.geekbang.org/account/avatar/00/10/5c/da/0a8bc27b.jpg","comment_is_top":false,"comment_ctime":1642755789,"is_pvip":true,"replies":[{"id":"121605","content":"你说的没错，无论整型变量和自定义类型变量，atomic的操作实质上针对的都是字长长度的指针。但我说的复杂临界区，还有另外一个情况，那就是在锁内部有着对数据的更为复杂的判断与操作，而不仅仅是+n,-n,或cas。","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1643538425,"ip_address":"","comment_id":331775,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1642755789","product_id":100093501,"comment_content":"白老师：<br>“atomic 原子操作可用来同步的范围有比较大限制，只能同步一个整型变量或自定义类型变量。如果我们要对一个复杂的临界区数据进行同步，那么首选的依旧是 sync 包中的原语。”<br>这里说的整型变量和自定义类型变量，是不是可以理解为一个字长的大小。在64位cpu上就是8个字节。因为CPU通过数据总线，一次从内存中最多只能获取一个字长的信息。所以atomic的限制也是一个字长。","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549063,"discussion_content":"你说的没错，无论整型变量和自定义类型变量，atomic的操作实质上针对的都是字长长度的指针。但我说的复杂临界区，还有另外一个情况，那就是在锁内部有着对数据的更为复杂的判断与操作，而不仅仅是+n,-n,或cas。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643538425,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330861,"user_name":"BinyGo","can_delete":false,"product_type":"c1","uid":2639381,"ip_address":"","ucode":"182ADA4532C98B","user_header":"https://static001.geekbang.org/account/avatar/00/28/46/15/0f215f66.jpg","comment_is_top":false,"comment_ctime":1642230610,"is_pvip":true,"replies":[{"id":"121586","content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":"1026224","ctime":1643521630,"ip_address":"","comment_id":330861,"utype":1}],"discussion_count":1,"race_medal":3,"score":"1642230610","product_id":100093501,"comment_content":"并发每篇都干货满满，3刷4刷都还没完全消化完，加油~","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549027,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643521630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}