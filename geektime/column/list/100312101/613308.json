{"id":613308,"title":"04｜泛化调用：三步教你搭建通用的泛化调用框架","content":"<p>你好，我是何辉。我们继续探索Dubbo框架的第三道特色风味，泛化调用。</p><p>提到调用，我想你肯定不陌生，前面我们也学习过同步调用、异步调用，核心是为了解决数据端到端传输的调用问题。那今天要学习的新型调用技能——泛化调用到底是什么？又能解决哪些实际问题呢？话不多说，我们马上开始。</p><p>我们都知道，页面与后台的交互调用流程一般是，页面发起HTTP请求，首先到达Web服务器，然后由Web服务器向后端各系统发起调用：</p><p><img src=\"https://static001.geekbang.org/resource/image/8f/3a/8ffdeecf6aa6d402cd629cc7391a843a.jpg?wh=1920x823\" alt=\"图片\"></p><p>假设这是一次查询用户信息的请求，核心逻辑完全在后端系统，你一般在Web服务器会怎么写呢？</p><p>这个简单，你自信秀出了代码：</p><pre><code class=\"language-java\">@RestController\npublic class UserController {\n    // 响应码为成功时的值\n    public static final String SUCC = \"000000\";\n    \n    // 定义访问下游查询用户服务的字段\n    @DubboReference\n    private UserQueryFacade userQueryFacade;\n    \n    // 定义URL地址\n    @PostMapping(\"/queryUserInfo\")\n    public String queryUserInfo(@RequestBody QueryUserInfoReq req){\n        // 将入参的req转为下游方法的入参对象，并发起远程调用\n        QueryUserInfoResp resp = \n                userQueryFacade.queryUserInfo(convertReq(req));\n        \n        // 判断响应对象的响应码，不是成功的话，则组装失败响应\n        if(!SUCC.equals(resp.getRespCode())){\n            return RespUtils.fail(resp);\n        }\n        \n        // 如果响应码为成功的话，则组装成功响应\n        return RespUtils.ok(resp);\n    }\n}\n</code></pre><!-- [[[read_end]]] --><p>在 UserController 控制器中，定义了一个查询用户信息的URL地址，接着在 queryUserInfo 方法中，将 HTTP的请求参数对象转换为下游接口的入参对象，然后调用下游接口发起远程调用，最后针对响应码做判断，并包装下游对象返回给前端。</p><p>代码逻辑非常简单，这样的查询用户请求在日常开发中我们也写过不少了，那对于这样的功能，你能总结出开发流程步骤么？</p><p>给个小提示，可以分析一下 queryUserInfo 的实现体逻辑，如果不确定也可以试着再写几个类似的功能，就能很顺利地总结出来了。</p><p>开发流程步骤就是：</p><ol>\n<li>定义&nbsp;URL&nbsp;地址给前端</li>\n<li>新建&nbsp;Controller&nbsp;控制器</li>\n<li>新增一个方法</li>\n<li>方法上添加处理请求的注解</li>\n<li>定义访问下游服务的变量</li>\n<li>发起远程调用</li>\n<li>判断响应成功或者失败</li>\n<li>将结果包装后传给前端</li>\n</ol><p>在总结开发步骤的同时，不知道你有没有发现一条惊人的规律：queryUserInfo 在 UserController 中没有实质性的业务逻辑。Web服务器只是编写代码把数据做了下包装，然后给到下游系统，等收到下游系统返回的内容后，啥也不做直接返回给前端，也就是说，<strong>Web服务器其实是在做一些透传性质的事情。</strong></p><p>而且这里我们只是写了一个接口，如果现在有十几个的运营页面，大约五十个请求接口，每个请求的核心逻辑都在后端系统，你预估一下，在Web服务器中写Java代码大概要写多久？</p><p>这样的需求量，我们掐指一算，每个接口假设编码加自测需要2小时，50个接口按10小时一天来算，10天才能写完，前提是下游系统都把接口提供好，如果下游没有按时提供接口，耗时想想都头皮发麻，这开发效率属实有点低下了。</p><p>那对于透传性质的Web服务器开发，有没有更好的方式来提效呢？</p><h3>反射调用</h3><p>你可能会说这还不简单，可以把一些相似的代码用一个小方法包装起来，减少代码修改量。那该减少哪些代码呢？</p><p>乍一看你可能没有思路，那我们换个问题：如果要写一个类似功能，你会怎么写呢，要改动哪些位置？</p><p>现在你一定很有把握了吧，是时候让CV大法发挥威力了，日常面对需求，在整体流程中每一步都蜻蜓点水地改一点点，三下五除二就把代码改完了。那我们结合刚才总结的开发流程8大步，看看改动点都有哪些：</p><ul>\n<li>流程1（定义&nbsp;URL&nbsp;地址给前端），将 /queryUserInfo重新定义为一个新路径。</li>\n<li>流程2（新建&nbsp;Controller&nbsp;控制器），将 UserQueryFacade userQueryFacade 字段定义为新的接口字段。</li>\n<li>流程3（新增一个方法），将 queryUserInfo 方法名改成了新的方法名。</li>\n<li>流程6（发起远程调用），修改了 convertReq 方法中的字段映射逻辑，并修改了 userQueryFacade.queryUserInfo 调用形式为新的接口调用。</li>\n</ul><p>来挨个分析哪些改动是可以提炼的。</p><ul>\n<li>改动点一：每次新加功能都新增了一个Controller控制器，可以省去吗？</li>\n</ul><p>仔细想想，其实，也可以不新增。</p><p>既然可以不新增的话，为什么我们又每次都新增呢？很多人的第一想法是别人都是这么新增的，那我们也就依葫芦画瓢新增了。</p><p>那为什么大家都会新增呢，是为了和其他类不一样么？没错，相信你也意识到了，一般之所以新增控制器，主要是在做代码归类、功能归类而已，易于理解和维护。</p><ul>\n<li>改动点二：userQueryFacade 字段的定义，可以省去么？</li>\n</ul><p>字段的定义，如果省去，就得去Spring容器中拿，这倒是小事，但省去后 @DubboReference 注解就不好做了，这个暂时不能省。</p><ul>\n<li>改动点三：/queryUserInfo 这个路径可以省么？</li>\n</ul><p>这个问题你肯定很自信，没法省，省了的话用户都不知道请求什么路径了，得保留。</p><p>第四步有2个改动点，我们先看第一个。</p><ul>\n<li>改动点四：convertReq 这个方法的逻辑可以省么？</li>\n</ul><p>convertReq 方法就是个转换入参字段为下游入参字段的映射关系，所以可以省，但是前提是入参字段和下游字段得一样，这样就能简单粗暴地先将 req 序列化为 String，再将 String 反序列化为下游入参对象。</p><p>好再看第二个。</p><ul>\n<li>改动点五：userQueryFacade.queryUserInfo 这个调用可以省么？</li>\n</ul><p>这得结合改动点二，因为 userQueryFacade 字段定义不能省去，想要逻辑通用，我们顶多可以把 userQueryFacade 对象和 queryUserInfo 传到公用方法里去。<strong>那有了对象和方法名，怎么调用到对象的方法上呢？</strong></p><p>这不是正常的调用方式，联想下已学的 Java 基础知识，看看哪个知识点可以在知道对象和方法名的时候发起调用的。没错就是“反射”，反射的时候记得设置 setAccessible(true)，以避免无访问权限。</p><p>好，我们小结一下哪些代码是可以省的：</p><p><img src=\"https://static001.geekbang.org/resource/image/1c/dc/1c9bc13e9fdde8889254589a680ef3dc.jpg?wh=1920x823\" alt=\"图片\"></p><p>大致有三块，节省控制器的创建、convertReq转换逻辑通用化处理、userQueryFacade.queryUserInfo调用方式。</p><p>修改后的代码就是这个样子：</p><pre><code class=\"language-java\">@RestController\npublic class UserController {\n    // 响应码为成功时的值\n    public static final String SUCC = \"000000\";\n    \n    // 定义访问下游查询用户服务的字段\n    @DubboReference\n    private UserQueryFacade userQueryFacade;\n    \n    // 定义URL地址\n    @PostMapping(\"/queryUserInfo\")\n    public String queryUserInfo(@RequestBody QueryUserInfoReq req){\n        // 调用公共方法\n        return commonInvoke(userQueryFacade, \"queryUserInfo\", req);\n    }\n    \n    /**\n     * &lt;h2&gt;模拟公共的远程调用方法.&lt;/h2&gt;\n     *\n     * @param reqObj：下游的接口的实例对象，即通过 @DubboReference 得到的对象。\n     * @param mtdName：下游接口的方法名。\n     * @param reqParams：需要请求到下游的数据。\n     * @return 直接结果数据。\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     */\n    public static String commonInvoke(Object reqObj, String mtdName, Object reqParams) throws InvocationTargetException, IllegalAccessException {\n        // 通过反射找到 reqObj(例：userQueryFacade) 中的 mtdName(例：queryUserInfo) 方法\n        Method reqMethod = ReflectionUtils.findMethod(reqObj.getClass(), mtdName);\n        // 并设置查找出来的方法可被访问\n        ReflectionUtils.makeAccessible(reqMethod);\n        \n        // 通过序列化工具将 reqParams 序列化为字符串格式\n        String reqParamsStr = JSON.toJSONString(reqParams);\n        // 然后再将 reqParamsStr 反序列化为下游对象格式，并反射调用 invoke 方法\n        Object resp =  reqMethod.invoke(reqObj, JSON.parseObject(reqParamsStr, reqMethod.getParameterTypes()[0]));\n        \n        // 判断响应对象的响应码，不是成功的话，则组装失败响应\n        if(resp == null || !SUCC.equals(OgnlUtils.getValue(resp, \"respCode\"))){\n            return RespUtils.fail(resp);\n        }\n        // 如果响应码为成功的话，则组装成功响应\n        return RespUtils.ok(resp);\n    }\n}\n</code></pre><p>代码大大改善了 queryUserInfo 的实现逻辑，并且提炼出了一个 commonInvoke 通用的方法，其中主要做了4件事情：</p><ul>\n<li>通过反射功能找到下游接口的 method 对象；</li>\n<li>通过先序列化，再反序列化，将HTTP入参转为下游接口入参对象；</li>\n<li>通过 method.invoke 反射发起真正的远程调用，并拿到响应对象；</li>\n<li>通过 Ognl 表达式语言从响应对象取出 respCode 响应码做判断，并做最终返回。</li>\n</ul><p>这样精简后，我们发现 queryUserInfo 的实现逻辑确实简单多了，节省代码的同时，还提炼了公共方法，的确可以节省不少开发工作量。</p><p>可是，queryUserInfo 的内部逻辑是精简了，仍然得定义好多 queryUserInfo 这样的方法、请求URL地址、下游接口字段，这些是否也能省略呢？</p><p>单纯靠现有的反射调用方式无法进一步精简了，我们需要考虑定制一种更新型的调用方式。</p><h3>泛化调用</h3><p>如何创建一种新型调用呢？这个方向说起来简单，做起来还是比较困难的，但作为未来技术精英的你，思考与不思考是两码事，思考了也许会有意想不到的新发现，不思考就是原地踏步了。虽然创建一种新型调用暂时没有什么头绪，但是我们还是可以先解决眼前的一些问题。</p><p>前面也提到需要定义好多请求URL地址，<strong>那URL地址能不能精简呢？</strong>这可能是新突破口。</p><p>想精简URL地址，首先要理解为什么要在Controller里面设置URL这个东西？在Controller里面设置URL就是为了能让前端调用到。</p><p>其次，URL一般写在像@PostMapping、@GetMapping 这样的注解中，那URL是怎么被访问通的呢？</p><p>考虑到@PostMapping、@GetMapping 是 Spring 体系中的，我们可以在 Spring 框架中尝试找答案，看官方文档中URL的定义规则，果不其然，在 <a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-requestmapping-uri-templates\">Spring Web MVC -&gt; Annotated Controllers -&gt; URI patterns</a> 路径下我们找到了解释。</p><p>核心就是 RequestMappingHandlerMapping 的&nbsp;initHandlerMethods 方法里面的URL注册器，请求链接被URL注册器匹配成功了，就可以被访问通。</p><p>所以，我们可以使用类似这种 <code>/projects/{project}/versions</code> 占位符形式的URL，利用 RequestMappingHandlerMapping 中的URL注册器去匹配。如果可以<strong>把一些变化的因子放到URL占位符中，精简URL的概率就非常大了</strong>。</p><p>好思路有了，我们再回看 commonInvoke 这个核心方法看看如何修改：</p><pre><code class=\"language-java\">/**\n * &lt;h2&gt;模拟公共的远程调用方法.&lt;/h2&gt;\n *\n * @param reqObj：下游的接口的实例对象，即通过 @DubboReference 得到的对象。\n * @param mtdName：下游接口的方法名。\n * @param reqParams：需要请求到下游的数据。\n * @return 直接结果数据。\n * @throws InvocationTargetException\n * @throws IllegalAccessException\n */\npublic static String commonInvoke(Object reqObj, \n                                  String mtdName, \n                                  Object reqParams) throws InvocationTargetException, IllegalAccessException {                               \n}\n</code></pre><p>这个方法有3个参数是变化的：</p><ul>\n<li>reqObj，下游接口对象，如果能想办法处理掉 @DubboReference 修饰接口的功能，这个估计也可以省略掉，但首先得拿到对象，而要拿到对象就得先知道是哪个类。所以对象的全类名可以考虑放到URL路径上作为变量。</li>\n<li>mtdName，下游接口的方法名，可以考虑放到URL路径上作为变量。</li>\n<li>reqParams，请求业务参数，按照对象接收的话得定义很多对象和字段，如果按照String接收的话貌似可行。</li>\n</ul><p>我们先尝试修改一下：</p><pre><code class=\"language-java\">@RestController\npublic class CommonController {\n    // 响应码为成功时的值\n    public static final String SUCC = \"000000\";\n    \n    // 定义URL地址\n    @PostMapping(\"/gateway/{className}/{mtdName}/request\")\n    public String commonRequest(@PathVariable String className,\n                                @PathVariable String mtdName,\n                                @RequestBody String reqBody){\n        // 将入参的req转为下游方法的入参对象，并发起远程调用\n        return commonInvoke(className, mtdName, reqBody);\n    }\n    \n    /**\n     * &lt;h2&gt;模拟公共的远程调用方法.&lt;/h2&gt;\n     *\n     * @param className：下游的接口归属方法的全类名。\n     * @param mtdName：下游接口的方法名。\n     * @param reqParamsStr：需要请求到下游的数据。\n     * @return 直接返回下游的整个对象。\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     */\n    public static String commonInvoke(String className, \n                                      String mtdName, \n                                      String reqParamsStr) throws InvocationTargetException, IllegalAccessException, ClassNotFoundException {\n        // 试图从类加载器中通过类名获取类信息对象\n        Class&lt;?&gt; clz = CommonController.class.getClassLoader().loadClass(className);\n        // 然后试图通过类信息对象想办法获取到该类对应的实例对象\n        Object reqObj = tryFindBean(clz.getClass());\n        \n        // 通过反射找到 reqObj(例：userQueryFacade) 中的 mtdName(例：queryUserInfo) 方法\n        Method reqMethod = ReflectionUtils.findMethod(clz, mtdName);\n        // 并设置查找出来的方法可被访问\n        ReflectionUtils.makeAccessible(reqMethod);\n        \n        // 将 reqParamsStr 反序列化为下游对象格式，并反射调用 invoke 方法\n        Object resp =  reqMethod.invoke(reqObj, JSON.parseObject(reqParamsStr, reqMethod.getParameterTypes()[0]));\n        \n        // 判断响应对象的响应码，不是成功的话，则组装失败响应\n        if(!SUCC.equals(OgnlUtils.getValue(resp, \"respCode\"))){\n            return RespUtils.fail(resp);\n        }\n        // 如果响应码为成功的话，则组装成功响应\n        return RespUtils.ok(resp);\n    }\n}\n</code></pre><p>因为可以通过占位符来精简URL，我们对代码做了4个调整：</p><ul>\n<li>重新定义了一个公用控制器 CommonController；</li>\n<li>定义了统一的URL路径 <code>/gateway/{className}/{mtdName}/request</code>，将 className、mtdName 做成请求路径的占位符；</li>\n<li>修改了请求业务参数的格式定义，由对象转为String；</li>\n<li>commonInvoke 核心实现逻辑中，利用类加载器找到 className 对应的类信息，然后想办法找到 className 对应的实例对象。</li>\n</ul><p>但这段代码有一个重要的核心逻辑还没解决，<strong>tryFindBean，我们该通过什么样的办法拿到下游接口的实例对象呢？或者说，该怎么仿照 @DubboReference 注解，拿到下游接口的实例对象呢？</strong></p><p>虽然不知道 @DubboReference 注解是怎么做到的，但是我们起码能明白一点，只要通过 @DubboReference 修饰的字段就能拿到实例对象，那接下来就是需要一点耐心的环节了，顺着 @DubboReference 注解的核心实现逻辑探索一下源码：</p><p><img src=\"https://static001.geekbang.org/resource/image/e8/ff/e88f53ba25bb35dfa02c1a38b87158ff.jpg?wh=1920x1764\" alt=\"图片\"></p><p>最终，我们会发现是通过 ReferenceConfig#get 方法创建了代理对象。你也可以参考我录制的这段视频，探寻答案：</p><p><video poster=\"https://media001.geekbang.org/c957f5cc9a904e85ac12a8fbdd57ffd3/snapshots/fd8900ad6ba34a548450d1e6fcd1fd20-00005.jpg\" preload=\"none\" controls=\"\"><source src=\"https://media001.geekbang.org/customerTrans/7e27d07d27d407ebcc195a0e78395f55/5293a2ce-1850e8bb8a6-0000-0000-01d-dbacd.mp4\" type=\"video/mp4\"><source src=\" https://media001.geekbang.org/e5cf80ffb7cb4d479f75490113cfd5c3/7c730c6c85f14495b171ffa58dcc20a9-5a91e3098c0829ddc4e8b5c2581e4e14-sd.m3u8\" type=\"application/x-mpegURL\"></video></p><p>这句代码不就是我们平常写Java代码拿到下游接口代理对象的方式么。原来核心的解决方案就在眼前，一个不起眼的 @DubboReference 注解的核心实现逻辑，就是我们最普通的拿到接口代理对象的逻辑。</p><p>那接下来，你知道该怎么继续改造了么？</p><h2>编码实现</h2><p>经过一番源码探索后，最难解决的 tryFindBean 逻辑也有了头绪。我们找到了 ReferenceConfig 这个核心类，接下来要做的就是拿到 referenceConfig#get 返回的泛化对象GenericService，然后调用 GenericService#$invoke 方法进行远程调用。</p><p>看下GenericService#$invoke 方法的定义：</p><pre><code class=\"language-java\">public interface GenericService {\n    /**\n     * Generic invocation\n     *\n     * @param method         Method name, e.g. findPerson. If there are overridden methods, parameter info is\n     *                       required, e.g. findPerson(java.lang.String)\n     * @param parameterTypes Parameter types\n     * @param args           Arguments\n     * @return invocation return value\n     * @throws GenericException potential exception thrown from the invocation\n     */\n    Object $invoke(String method, String[] parameterTypes, Object[] args) throws GenericException;\n}\n</code></pre><p>可以从源码中看到，GenericService#$invoke 方法除了需要下游接口方法名、下游请求参数外，还需要一个下游的方法入参类名。</p><p>既然 $invoke 方法这么定义了，那我们可以把方法入参的类名也定义为变量。虽然源码这里是接收一个数组，但只传一个一般也能解决绝大部分问题，所以这里，我们就先按照只有一个方法入参类名来定义URL接口。</p><p>按思路来调整代码：</p><pre><code class=\"language-java\">@RestController\npublic class CommonController {\n    // 响应码为成功时的值\n    public static final String SUCC = \"000000\";\n    \n    // 定义URL地址\n    @PostMapping(\"/gateway/{className}/{mtdName}/{parameterTypeName}/request\")\n    public String commonRequest(@PathVariable String className,\n                                @PathVariable String mtdName,\n                                @PathVariable String parameterTypeName,\n                                @RequestBody String reqBody){\n        // 将入参的req转为下游方法的入参对象，并发起远程调用\n        return commonInvoke(className, parameterTypeName, mtdName, reqBody);\n    }\n    \n    /**\n     * &lt;h2&gt;模拟公共的远程调用方法.&lt;/h2&gt;\n     *\n     * @param className：下游的接口归属方法的全类名。\n     * @param mtdName：下游接口的方法名。\n     * @param parameterTypeName：下游接口的方法入参的全类名。\n     * @param reqParamsStr：需要请求到下游的数据。\n     * @return 直接返回下游的整个对象。\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     */\n    public static String commonInvoke(String className,\n                                      String mtdName,\n                                      String parameterTypeName,\n                                      String reqParamsStr) {\n        // 然后试图通过类信息对象想办法获取到该类对应的实例对象\n        ReferenceConfig&lt;GenericService&gt; referenceConfig = createReferenceConfig(className);\n        \n        // 远程调用\n        GenericService genericService = referenceConfig.get();\n        Object resp = genericService.$invoke(\n                mtdName,\n                new String[]{parameterTypeName},\n                new Object[]{JSON.parseObject(reqParamsStr, Map.class)});\n        \n        // 判断响应对象的响应码，不是成功的话，则组装失败响应\n        if(!SUCC.equals(OgnlUtils.getValue(resp, \"respCode\"))){\n            return RespUtils.fail(resp);\n        }\n        \n        // 如果响应码为成功的话，则组装成功响应\n        return RespUtils.ok(resp);\n    }\n    \n    private static ReferenceConfig&lt;GenericService&gt; createReferenceConfig(String className) {\n        DubboBootstrap dubboBootstrap = DubboBootstrap.getInstance();\n        \n        // 设置应用服务名称\n        ApplicationConfig applicationConfig = new ApplicationConfig();\n        applicationConfig.setName(dubboBootstrap.getApplicationModel().getApplicationName());\n        \n        // 设置注册中心的地址\n        String address = dubboBootstrap.getConfigManager().getRegistries().iterator().next().getAddress();\n        RegistryConfig registryConfig = new RegistryConfig(address);\n        ReferenceConfig&lt;GenericService&gt; referenceConfig = new ReferenceConfig&lt;&gt;();\n        referenceConfig.setApplication(applicationConfig);\n        referenceConfig.setRegistry(registryConfig);\n        referenceConfig.setInterface(className);\n        \n        // 设置泛化调用形式\n        referenceConfig.setGeneric(\"true\");\n        // 设置默认超时时间5秒\n        referenceConfig.setTimeout(5 * 1000);\n        return referenceConfig;\n    }\n}\n</code></pre><p>代码中主要解决了怎么找到接口代理对象的核心逻辑问题，关键步骤是：</p><ul>\n<li>URL地址增加了一个方法参数类名的维度，意味着通过类名、方法名、方法参数类名可以访问后台的提供者；</li>\n<li>通过接口类名来创建 ReferenceConfig 对象，并设置 generic = true 的核心属性；</li>\n<li>通过 referenceConfig.get 方法得到 genericService 泛化对象；</li>\n<li>将方法名、方法参数类名、业务请求参数传入泛化对象的 $invoke 方法中进行远程Dubbo调用，并返回响应对象；</li>\n<li>通过 Ognl 表达式语言从响应对象取出 respCode 响应码判断并做最终返回。</li>\n</ul><p>到这里我们今天的学习任务就大功告成了，把枯燥无味的代码用泛化调用形式改善了一番，发起的请求，先经过“泛化调用”，然后调往各个提供方系统，这样发起的请求根本不需要感知提供方的存在，只需要按照既定的“泛化调用”形式发起调用就可以了。</p><p><img src=\"https://static001.geekbang.org/resource/image/61/be/619dd16a9590a59efd0c2bbabb0b60be.jpg?wh=1920x823\" alt=\"图片\"></p><p>通俗地讲，泛化可以理解为采用一种统一的方式来发起对任何服务方法的调用，至少我们知道是一种接口调用的方式，只是这种方式有一个比较独特的名字而已。</p><h2>泛化调用的应用</h2><p>学习了泛化调用，想必你已经可以很娴熟地封装自己的通用网关了，在我们日常开发中，哪些应用场景可以考虑泛化调用呢？</p><p>第一，透传式调用，发起方只是想调用提供者拿到结果，没有过多的业务逻辑诉求，即使有，也是拿到结果后再继续做分发处理。</p><p>第二，代理服务，所有的请求都会经过代理服务器，而代理服务器不会感知任何业务逻辑，只是一个通道，接收数据-&gt;发起调用-&gt;返回结果，调用流程非常简单纯粹。</p><p>第三，前端网关，有些内网环境的运营页面，对URL的格式没有那么严格的讲究，页面的功能都是和后端服务一对一的操作，非常简单直接。</p><h2>总结</h2><p>今天，我们从Web服务器一段常见的代码调用开始，用反射调用和泛化调用两种调用方案做了不同尝试，核心仍然是希望简化开发人员代码编写，提升功能通用性。</p><p>反射调用方案，只需要通过接口对象、方法名、入参对象就可以完成远程调用，但仍然无法规避多个URL、多个控制器方法、多个下游接口字段等的定义。</p><p>接着在Spring官方文档的指导下，我们根据占位符的概念，重新设计URL格式，把调用下游的接口类名、方法名利用占位符的方式定义到URL中。但简化URL后，又遇到了如何获取下游接口对象的难题，我们从 @DubboReference 的实现逻辑中挖出了 ReferenceConfig 核心关键类。</p><p>最后通过泛化调用，提炼出通过接口类名、接口方法名、接口方法参数类名、业务请求参数四个维度完成了最终方案落地。</p><p>这里也总结一下泛化调用的三部曲：</p><ul>\n<li>接口类名、接口方法名、接口方法参数类名、业务请求参数，四个维度的数据不能少。</li>\n<li>根据接口类名创建 ReferenceConfig 对象，设置 generic = true 属性，调用 referenceConfig.get 拿到 genericService 泛化对象。</li>\n<li>传入接口方法名、接口方法参数类名、业务请求参数，调用 genericService.$invoke 方法拿到响应对象，并通过 Ognl 表达式语言判断响应成功或失败，然后完成数据最终返回。</li>\n</ul><p>泛化调用的应用场景主要有3类，透传式调用、代理服务、前端网关。</p><h3>思考题</h3><p>你已经学会了使用泛化调用，并且也掌握了泛化调用的三部曲，基本上可以利用 CommonController 的代码调用流程来设计一套属于自己的通用型网关了，你觉得 CommonController 这段代码还有哪些地方可以改善吗？</p><p>欢迎留言参与讨论，如果有收获也欢迎分享给身边的朋友，说不定就帮他解决了一个问题，我们下一讲见。</p><h3>03思考题参考</h3><p>上一期的问题是研读RpcContext类，说说 SERVER_LOCAL、CLIENT_ATTACHMENT、SERVER_ATTACHMENT、SERVICE_CONTEXT 这几个属性的生命周期。</p><p>SERVER_LOCAL 作用于 Provider 侧，在 org.apache.dubbo.rpc.RpcContext.RestoreContext#restore 中被设置进去，即在线程切换将父线程的信息拷贝至子线程时被调用，然而却又在 Provider 转为 Consumer 角色时被清除数据。</p><p>CLIENT_ATTACHMENT 在源码中是这么描述的：</p><pre><code class=\"language-markdown\">ClientAttachment is using to pass attachments to next hop as a consumer. ( A --&gt; B , in A side)\n</code></pre><p>CLIENT_ATTACHMENT 用于将附属信息作为 Consumer 传递到下一跳 Provider，在 Provider 和 Consumer 的 Filter 中的 org.apache.dubbo.rpc.BaseFilter.Listener#onResponse、org.apache.dubbo.rpc.BaseFilter.Listener#onError 方法都会被清除数据。<br>\nSERVER_ATTACHMENT 在源码中是这么描述的：</p><pre><code class=\"language-markdown\">ServerAttachment is using to fetch attachments from previous hop as a provider. ( A --&gt; B , in B side)\n</code></pre><p>SERVER_ATTACHMENT 作为 Provider 侧用于接收上一跳 Consumer 的发来附属信息，在 Provider 和 Consumer 的 Filter 中的 org.apache.dubbo.rpc.BaseFilter.Listener#onResponse、org.apache.dubbo.rpc.BaseFilter.Listener#onError 方法都会被清除数据。<br>\nSERVICE_CONTEXT 在源码中是这么描述的：</p><pre><code class=\"language-markdown\">ServerContext is using to return some attachments back to client as a provider. ( A &lt;-- B , in B side)\n</code></pre><p>SERVICE_CONTEXT 用于将附属信息作为 Provider 返回给 Consumer，在 Provider 侧的 org.apache.dubbo.rpc.filter.ContextFilter#onResponse、org.apache.dubbo.rpc.filter.ContextFilter#onError 方法都会被清除数据。</p>","comments":[{"had_liked":false,"id":365057,"user_name":"熊悟空的凶","can_delete":false,"product_type":"c1","uid":1933459,"ip_address":"广东","ucode":"5FA9498BDA92C0","user_header":"https://static001.geekbang.org/account/avatar/00/1d/80/93/dde3d5f0.jpg","comment_is_top":false,"comment_ctime":1672044181,"is_pvip":false,"replies":[{"id":132928,"content":"你好，熊悟空的凶：认真学，肯定没问题的，这门课程是多年来玩转Dubbo的结晶，希望可以给你带来益处。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1672051545,"ip_address":"广东","comment_id":365057,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师讲的很认真，图文结合、还配合了视频，希望老师能把我领进dubbo的大门。学习dubbo源码，看来离不开spring的一些基础","like_count":3,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597593,"discussion_content":"你好，熊悟空的凶：认真学，肯定没问题的，这门课程是多年来玩转Dubbo的结晶，希望可以给你带来益处。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1672051545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369736,"user_name":"public","can_delete":false,"product_type":"c1","uid":2768731,"ip_address":"广东","ucode":"EF597BADCC526B","user_header":"","comment_is_top":false,"comment_ctime":1677852765,"is_pvip":true,"replies":[{"id":134832,"content":"你好，王应发：我上面的例子，body 入参就是一个 String 字符串呢，至于这个字符串是一个类似 &quot;12345&quot; 还是 {&quot;abc&quot;:&quot;12345&quot;} 形式的 json 字符串，我没有定死呀，主要看服务端怎么解析这个 body 字符串而已～","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1678115872,"ip_address":"广东","comment_id":369736,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"老师您好，生产中各种接口丰富多样，我觉得作为网关你不能强制要求接口提供者的入参只有一个参数哇，在你上面的例子里有没有优雅的方式能实现呢","like_count":1,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607777,"discussion_content":"你好，王应发：我上面的例子，body 入参就是一个 String 字符串呢，至于这个字符串是一个类似 &#34;12345&#34; 还是 {&#34;abc&#34;:&#34;12345&#34;} 形式的 json 字符串，我没有定死呀，主要看服务端怎么解析这个 body 字符串而已～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678115872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368202,"user_name":"Geek_5a425f","can_delete":false,"product_type":"c1","uid":3523198,"ip_address":"北京","ucode":"B1EB3CA5030AF9","user_header":"","comment_is_top":false,"comment_ctime":1676001870,"is_pvip":false,"replies":[{"id":134075,"content":"你好，Geek_5a425f：是的，你说的非常正确。ReferenceConfig实例很重，确实需要缓存处理。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1676020907,"ip_address":"广东","comment_id":368202,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"思考题：\n工作时候实践过Dubbo 的泛化调用，对于ReferenceConfig来说是可以进行缓存的（ReferenceConfig实例很重）。\n感兴趣可以看下官方文档：https:&#47;&#47;cn.dubbo.apache.org&#47;zh-cn&#47;docs&#47;advanced&#47;reference-config-cache&#47;","like_count":1,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603230,"discussion_content":"你好，Geek_5a425f：是的，你说的非常正确。ReferenceConfig实例很重，确实需要缓存处理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676020907,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":367417,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"北京","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1675223437,"is_pvip":false,"replies":[{"id":133844,"content":"你好，张申傲：感谢真诚的肯定赞赏，对你有帮助，我就非常开心啦😄","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1675305317,"ip_address":"广东","comment_id":367417,"utype":1}],"discussion_count":1,"race_medal":2,"score":2,"product_id":100312101,"comment_content":"老师的课程一步步推导下来，思路非常清晰~","like_count":1,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601574,"discussion_content":"你好，张申傲：感谢真诚的肯定赞赏，对你有帮助，我就非常开心啦😄","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675305317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366251,"user_name":"Geek_895efd","can_delete":false,"product_type":"c1","uid":1567905,"ip_address":"浙江","ucode":"F72CF7D056C572","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL2N4mhzsvvUG8Wew1uvTHs531fsW5LfgWkv4782VtwRuMf0qicRPxWtKgIzxyFSNVKJ09FN5vcVjg/132","comment_is_top":false,"comment_ctime":1673510105,"is_pvip":false,"replies":[{"id":133481,"content":"你好，Geek_895efd：可以看官网学习的，也可以去刷刷Dubbo视频快速脑海过一把留个印象，然后再来细学一下。主要看你自己习惯哪种学习方式～","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1673581591,"ip_address":"广东","comment_id":366251,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"前面的学习还顺利，这一节就感觉有点吃力了，自己了解和使用dubbo有限，基础不牢。请问老师，dubbo基础的学习直接看官方文档吗","like_count":1,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599552,"discussion_content":"你好，Geek_895efd：可以看官网学习的，也可以去刷刷Dubbo视频快速脑海过一把留个印象，然后再来细学一下。主要看你自己习惯哪种学习方式～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673581591,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":380786,"user_name":"Z_Z","can_delete":false,"product_type":"c1","uid":2058852,"ip_address":"广东","ucode":"654BE3F3C7DBA4","user_header":"https://static001.geekbang.org/account/avatar/00/1f/6a/64/3d4fccf8.jpg","comment_is_top":false,"comment_ctime":1694153174,"is_pvip":false,"replies":[{"id":138651,"content":"你好，Z_Z：你说泛化是反射么？实质不是的，生成了代理对应哦","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1694236105,"ip_address":"湖南","comment_id":380786,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"反射做接口，高并发下性能会很差吧","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":627524,"discussion_content":"你好，Z_Z：你说泛化是反射么？实质不是的，生成了代理对应哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1694236106,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373889,"user_name":"墨","can_delete":false,"product_type":"c1","uid":3225870,"ip_address":"浙江","ucode":"F453C0B6A4A41F","user_header":"https://static001.geekbang.org/account/avatar/00/31/39/0e/cbf33210.jpg","comment_is_top":false,"comment_ctime":1683293050,"is_pvip":false,"replies":[{"id":137073,"content":"你好，墨：回答的挺好的，赞～","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1685617802,"ip_address":"广东","comment_id":373889,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"思考题：controller 调用dubbo rpc方法时是有很多特性配置的，比如timeout、retries的，可以作为controller url提供配置给业务使用","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":619924,"discussion_content":"你好，墨：回答的挺好的，赞～","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1685617802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368108,"user_name":"舟嘿呀","can_delete":false,"product_type":"c1","uid":1399933,"ip_address":"浙江","ucode":"B83445E3F3D990","user_header":"https://static001.geekbang.org/account/avatar/00/15/5c/7d/9e39c86d.jpg","comment_is_top":false,"comment_ctime":1675910809,"is_pvip":false,"replies":[{"id":134072,"content":"你好，舟嘿呀：泛化调用就是从注册中心拿到提供方的IP列表，然后负载均衡发起网络RPC调用。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1676018297,"ip_address":"广东","comment_id":368108,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"有个问题，这里走泛化调用是走网络的rpc还是本地调用","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603224,"discussion_content":"你好，舟嘿呀：泛化调用就是从注册中心拿到提供方的IP列表，然后负载均衡发起网络RPC调用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676018297,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3523198,"avatar":"","nickname":"Geek_5a425f","note":"","ucode":"B1EB3CA5030AF9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":603174,"discussion_content":"走网络 RPC，只是把之前调用提供方Dubbo接口需要的那些内容（调哪个类、哪个方法，参数类型、参数内容），通过参数传递过去，而不是像之前XXFacade.xxMethodd(req)这种方式。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676002202,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366572,"user_name":"阿昕","can_delete":false,"product_type":"c1","uid":1012906,"ip_address":"浙江","ucode":"F3AD093B68E074","user_header":"https://static001.geekbang.org/account/avatar/00/0f/74/aa/178a6797.jpg","comment_is_top":false,"comment_ctime":1673937815,"is_pvip":false,"replies":[{"id":133572,"content":"你好，阿昕：文稿里实现的方案是在消费方还未与提供方发生交互时就需要知道方法入参类名，这种提前感知方法入参类名是不需要代码代价的。\n\n而你所说的需要从dubbo接口定义中获取，也不是不可以，但是得制定规范，一个接口中的方法不能被重载，这样的话，可以考虑在提供方进行一定的拦截根据“接口类名+方法名”找到对应的提供方 invoker 对象进行调用，也是可以的，只是需要代码改造而已。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1673958977,"ip_address":"湖南","comment_id":366572,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"思考题，从内部测试网关的使用角度考虑，parameterTypeName参数略显繁琐，是否能从dubbo的接口定义中获取呢？","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":600049,"discussion_content":"你好，阿昕：文稿里实现的方案是在消费方还未与提供方发生交互时就需要知道方法入参类名，这种提前感知方法入参类名是不需要代码代价的。\n\n而你所说的需要从dubbo接口定义中获取，也不是不可以，但是得制定规范，一个接口中的方法不能被重载，这样的话，可以考虑在提供方进行一定的拦截根据“接口类名+方法名”找到对应的提供方 invoker 对象进行调用，也是可以的，只是需要代码改造而已。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673958978,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"湖南","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":366044,"user_name":"梦想注定丶孤独","can_delete":false,"product_type":"c1","uid":1222688,"ip_address":"广东","ucode":"0E51E368DE53F2","user_header":"https://static001.geekbang.org/account/avatar/00/12/a8/20/6798446a.jpg","comment_is_top":false,"comment_ctime":1673341777,"is_pvip":false,"replies":[{"id":133365,"content":"你好，梦想注定丶孤独：是可以作为构建中台的坚实基础的。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1673352973,"ip_address":"广东","comment_id":366044,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100312101,"comment_content":"泛化调用是为了后续中台搭建打基础吗","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599146,"discussion_content":"你好，梦想注定丶孤独：是可以作为构建中台的坚实基础的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673352973,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365999,"user_name":"斯瓦辛武Roy","can_delete":false,"product_type":"c1","uid":2087578,"ip_address":"广东","ucode":"0A6AE232481B86","user_header":"https://static001.geekbang.org/account/avatar/00/1f/da/9a/ed524797.jpg","comment_is_top":false,"comment_ctime":1673294557,"is_pvip":false,"replies":[{"id":133337,"content":"你好，斯瓦辛武Roy：样例代码工程中的 dubbo-15-generic-json-consumer 是一个简单的泛化调用例子，你可以参考学习下。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1673325343,"ip_address":"广东","comment_id":365999,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100312101,"comment_content":"能提供一个CommonController的接口调用demo么","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":599080,"discussion_content":"你好，斯瓦辛武Roy：样例代码工程中的 dubbo-15-generic-json-consumer 是一个简单的泛化调用例子，你可以参考学习下。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1673325343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365605,"user_name":"张洋","can_delete":false,"product_type":"c1","uid":1182914,"ip_address":"广东","ucode":"549BE5DEEF8417","user_header":"https://static001.geekbang.org/account/avatar/00/12/0c/c2/bad34a50.jpg","comment_is_top":false,"comment_ctime":1672820537,"is_pvip":false,"replies":[{"id":133171,"content":"你好，张洋：你的直觉是对的，小打小闹可以这么玩，若正式放到对公产线玩的话，最好映射一下。我也在“05 点点直连”中进行的相应的解答，有兴趣可以去看看。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1672831314,"ip_address":"广东","comment_id":365605,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100312101,"comment_content":"作为一个网关的话，个人总是觉得将类名，方法名作为请求参数传递过来有点奇怪，可不可以做一个路径映射，通过访问的路径找到对应的类和要调用的方法来进行处理。","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":598451,"discussion_content":"你好，张洋：你的直觉是对的，小打小闹可以这么玩，若正式放到对公产线玩的话，最好映射一下。我也在“05 点点直连”中进行的相应的解答，有兴趣可以去看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672831314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":365130,"user_name":"万里晴空","can_delete":false,"product_type":"c1","uid":1102030,"ip_address":"广东","ucode":"D189F67E82BAB4","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/ce/42018f4f.jpg","comment_is_top":false,"comment_ctime":1672136249,"is_pvip":false,"replies":[{"id":132967,"content":"你好，万里晴空：这个是需要有一点 Dubbo 的基础知识的，不过也没关系你可以看看【https:&#47;&#47;gitee.com&#47;ylimhhmily&#47;GeekDubbo3Tutorial】代码中的【dubbo-15-generic-bean-consumer、dubbo-15-generic-byte-consumer、dubbo-15-generic-json-consumer】三个关于 ReferenceConfig 的使用案例，希望会对你有一定的帮助。","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1672193103,"ip_address":"广东","comment_id":365130,"utype":1}],"discussion_count":2,"race_medal":0,"score":3,"product_id":100312101,"comment_content":"从@DubboReference实现逻辑引申出泛化调用，还是不明白怎么知道要用哪个类的哪个方法来实现？如用ReferenceConfig等","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597715,"discussion_content":"你好，万里晴空：这个是需要有一点 Dubbo 的基础知识的，不过也没关系你可以看看【https://gitee.com/ylimhhmily/GeekDubbo3Tutorial】代码中的【dubbo-15-generic-bean-consumer、dubbo-15-generic-byte-consumer、dubbo-15-generic-json-consumer】三个关于 ReferenceConfig 的使用案例，希望会对你有一定的帮助。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1672193103,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1102030,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/ce/42018f4f.jpg","nickname":"万里晴空","note":"","ucode":"D189F67E82BAB4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":598612,"discussion_content":"嗯嗯，好","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672961343,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":597715,"ip_address":"湖北","group_id":0},"score":598612,"extra":""}]}]},{"had_liked":false,"id":365117,"user_name":"肖立智","can_delete":false,"product_type":"c1","uid":2277773,"ip_address":"广东","ucode":"9DAF54CB38DB72","user_header":"","comment_is_top":false,"comment_ctime":1672126812,"is_pvip":false,"replies":[{"id":132954,"content":"\n你好，肖立智：你的第1点考虑的非常有亮点。\n\n针对第1点，可以考虑采用 SimpleReferenceCache#getCache 相关的方法缓存引用实例对象。\n\n针对第2点，这是一种异步方式的特性支持，有当然更好，没有的话大多数场景也能够支持，也还好。\n","user_name":"作者回复","user_name_real":"编辑","uid":1364525,"ctime":1672188492,"ip_address":"广东","comment_id":365117,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100312101,"comment_content":"思考题：\n1、将对应referenceConfig和referenceConfig.get()服务，创建成功后缓存起来，不用重复创建。\n2、将接口改成异步","like_count":0,"discussions":[{"author":{"id":1364525,"avatar":"https://static001.geekbang.org/account/avatar/00/14/d2/2d/d303cfe0.jpg","nickname":"HMILYYLIMH","note":"","ucode":"9355AB4A1A1B97","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":597696,"discussion_content":"\n你好，肖立智：你的第1点考虑的非常有亮点。\n\n针对第1点，可以考虑采用 SimpleReferenceCache#getCache 相关的方法缓存引用实例对象。\n\n针对第2点，这是一种异步方式的特性支持，有当然更好，没有的话大多数场景也能够支持，也还好。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1672188492,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}