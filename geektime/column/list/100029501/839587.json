{"id":839587,"title":"加餐05｜SQL实战：新能源车企的数据查询与优化","content":"<p>你好，我是陈博士。今天我们来探讨一下新能源汽车企业的实时车况监控业务的数据查询与优化。</p><p>随着新能源汽车市场的迅速扩张，实时车况监控成为了确保车辆安全运行的关键环节。通过查询，我们可以即时掌握每辆车的健康状态，包括电池性能、电机效率以及潜在故障，这有助于车企提前做出维护决策。</p><p></p><p>针对该场景，我整理了6张数据表以及对应的查询问题。针对这些查询问题，你可以了解到这些SQL该如何撰写。</p><h2><strong>数据表</strong></h2><ul>\n<li>\n<p>车辆基础信息表 vehicle_base_info<br>\n<img src=\"https://static001.geekbang.org/resource/image/62/4b/622f7184aabb3f68ebb432ba05365e4b.jpg?wh=2100x1396\" alt=\"\"></p>\n</li>\n<li>\n<p>实时位置信息表 vehicle_location<br>\n<img src=\"https://static001.geekbang.org/resource/image/4c/8e/4cb8b6e7dee4a97ede32213e25ef818e.jpg?wh=2106x1278\" alt=\"\"></p>\n</li>\n<li>\n<p>电池状态表 battery_status<br>\n<img src=\"https://static001.geekbang.org/resource/image/88/92/88698f485c5a4d965a8788bea26c5e92.jpg?wh=2106x1510\" alt=\"\"></p>\n</li>\n<li>\n<p>电机状态表 motor_status<br>\n<img src=\"https://static001.geekbang.org/resource/image/84/9a/849b662cb13a3c796a477fd173f8439a.jpg?wh=2110x1286\" alt=\"\"></p>\n</li>\n<li>\n<p>故障告警表&nbsp;vehicle_alarm<br>\n<img src=\"https://static001.geekbang.org/resource/image/60/5c/606b2ffae5fd2429a80d60a0e894865c.jpg?wh=2108x1364\" alt=\"\"></p>\n</li>\n</ul><p></p><ul>\n<li>行驶状态表 driving_status<br>\n<img src=\"https://static001.geekbang.org/resource/image/07/d4/07fd97cdd809198eecb6cab181099dd4.jpg?wh=2114x1620\" alt=\"\"></li>\n</ul><h2><strong>问题设定</strong></h2><p>我从车辆实时监控查询、电池健康状态分析、故障分析统计、行驶里程统计、性能监控预警、驾驶行为分析、地理分布分析、SOC 变化趋势分析、车辆综合性能评估等维度设置了一些常见的查询问题，一起来看一下。</p><h3><strong>车辆实时监控查询</strong></h3><p>查询指定车辆最近5分钟的实时状态，包括位置、电量、速度等信息。</p><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; v.vin,\n&nbsp; &nbsp; v.model_name,\n&nbsp; &nbsp; d.car_status,\n&nbsp; &nbsp; l.speed,\n&nbsp; &nbsp; l.latitude,\n&nbsp; &nbsp; l.longitude,\n&nbsp; &nbsp; b.soc as battery_level,\n&nbsp; &nbsp; b.voltage as battery_voltage,\n&nbsp; &nbsp; m.motor_speed,\n&nbsp; &nbsp; m.motor_temperature,\n&nbsp; &nbsp; l.collect_time\nFROM vehicle_base_info v\nLEFT JOIN vehicle_location l ON v.vehicle_id = l.vehicle_id\nLEFT JOIN battery_status b ON v.vehicle_id = b.vehicle_id\nLEFT JOIN motor_status m ON v.vehicle_id = m.vehicle_id\nLEFT JOIN driving_status d ON v.vehicle_id = d.vehicle_id\nWHERE v.vehicle_id = 'VH00000001'\nAND l.collect_time &gt;= DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 5 MINUTE), '%Y-%m-%d %H:%i:%s.%f')\nORDER BY l.collect_time DESC\nLIMIT 1;\n&nbsp;\n// 说明： DATE_FORMAT 函数用于格式化日期和时间数据，使其按照指定的格式输出。在这个SQL查询中，DATE_FORMAT 与 DATE_SUB 结合使用来计算过去5分钟的时间点。\n</code></pre><!-- [[[read_end]]] --><h3><strong>电池健康状态分析</strong></h3><p>找出所有电池温度异常或电压异常的车辆。</p><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; v.model_name,\n&nbsp; &nbsp; COUNT(DISTINCT v.vehicle_id) as vehicle_count,\n&nbsp; &nbsp; AVG(b.soc) as avg_soc,\n&nbsp; &nbsp; MIN(b.min_cell_voltage) as min_cell_voltage,\n&nbsp; &nbsp; MAX(b.max_temperature) as max_temperature,\n&nbsp; &nbsp; COUNT(DISTINCT CASE WHEN b.max_temperature &gt; 40 THEN v.vehicle_id END) as high_temp_vehicles,\n&nbsp; &nbsp; COUNT(DISTINCT CASE WHEN b.min_cell_voltage &lt; 3.0 THEN v.vehicle_id END) as low_voltage_vehicles\nFROM vehicle_base_info v\nJOIN battery_status b ON v.vehicle_id = b.vehicle_id\nWHERE b.collect_time &gt;= DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 24 HOUR), '%Y-%m-%d %H:%i:%s.%f')\nGROUP BY v.model_name\nHAVING max_temperature &gt; 40 OR min_cell_voltage &lt; 3.0;\n&nbsp;\n// 说明： 使用 JOIN 连接车辆和电池状态表，通过 HAVING 子句筛选出过去24小时内电池温度超过40℃或最低单体电压低于3.0V的车辆，并统计异常情况。\n</code></pre><h3><strong>故障分析统计</strong></h3><p>统计过去7天内各类故障的发生频率和影响车辆数。</p><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; alarm_module,\n&nbsp; &nbsp; alarm_level,\n&nbsp; &nbsp; COUNT(*) as alarm_count,\n&nbsp; &nbsp; COUNT(DISTINCT vehicle_id) as affected_vehicles,\n&nbsp; &nbsp; MIN(start_time) as first_occurrence,\n&nbsp; &nbsp; MAX(start_time) as last_occurrence,\n&nbsp; &nbsp; SUM(CASE WHEN status = 1 THEN 1 ELSE 0 END) as active_alarms\nFROM vehicle_alarm\nWHERE start_time &gt;= DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 7 DAY), '%Y-%m-%d %H:%i:%s.%f')\nGROUP BY alarm_module, alarm_level\nORDER BY alarm_count DESC;\n&nbsp;\n// 说明： 使用 GROUP BY 按故障模块和等级分类，统计过去7天内各类故障的发生次数、影响的车辆数及活跃告警，并通过 ORDER BY 按发生频率排序。\n&nbsp;\nSUM(CASE WHEN status = 1 THEN 1 ELSE 0 END) 是一种常用的SQL技巧，用于条件聚合。这段代码的作用是统计那些 status 字段值为1（即告警持续中的情况）的记录数量。\n</code></pre><h3><strong>行驶里程统计</strong></h3><p>统计各车型的里程信息，包括平均里程和最高里程。</p><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; v.model_name,\n&nbsp; &nbsp; COUNT(DISTINCT v.vehicle_id) as vehicle_count,\n&nbsp; &nbsp; AVG(d.mileage) as avg_mileage,\n&nbsp; &nbsp; MAX(d.mileage) as max_mileage,\n&nbsp; &nbsp; MIN(d.mileage) as min_mileage,\n&nbsp; &nbsp; STDDEV(d.mileage) as mileage_stddev\nFROM vehicle_base_info v\nJOIN driving_status d ON v.vehicle_id = d.vehicle_id\nGROUP BY v.model_name\nORDER BY avg_mileage DESC;\n&nbsp;\n// 说明： 使用 JOIN 连接车辆基础信息和行驶状态表，通过 GROUP BY 按车型统计里程信息，包括平均、最高、最低里程及标准差，并按平均里程降序排列。\n</code></pre><h3><strong>性能监控预警</strong></h3><p>查找所有存在潜在性能问题的车辆（温度过高、电量过低等）。</p><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; v.vehicle_id,\n&nbsp; &nbsp; v.vin,\n&nbsp; &nbsp; v.model_name,\n&nbsp; &nbsp; m.motor_temperature,\n&nbsp; &nbsp; b.soc,\n&nbsp; &nbsp; b.max_temperature as battery_temp,\n&nbsp; &nbsp; d.car_status,\n&nbsp; &nbsp; CASE\n&nbsp; &nbsp; &nbsp; &nbsp; WHEN m.motor_temperature &gt; 80 THEN '电机温度过高'\n&nbsp; &nbsp; &nbsp; &nbsp; WHEN b.max_temperature &gt; 40 THEN '电池温度过高'\n&nbsp; &nbsp; &nbsp; &nbsp; WHEN b.soc &lt; 20 THEN '电量低'\n&nbsp; &nbsp; &nbsp; &nbsp; WHEN d.car_status = 3 THEN '车辆故障'\n&nbsp; &nbsp; &nbsp; &nbsp; ELSE '正常'\n&nbsp; &nbsp; END as warning_type\nFROM vehicle_base_info v\nJOIN motor_status m ON v.vehicle_id = m.vehicle_id\nJOIN battery_status b ON v.vehicle_id = b.vehicle_id\nJOIN driving_status d ON v.vehicle_id = d.vehicle_id\nWHERE m.motor_temperature &gt; 80\n&nbsp; &nbsp;OR b.max_temperature &gt; 40\n&nbsp; &nbsp;OR b.soc &lt; 20\n&nbsp; &nbsp;OR d.car_status = 3;\n&nbsp;\n// 说明： 使用 JOIN 连接多表，通过 CASE 语句识别潜在性能问题（如温度过高、电量低等），并筛选出存在问题的车辆，提供详细的警告类型。\n</code></pre><h3><strong>驾驶行为分析</strong></h3><p>分析不同驾驶模式下的用车特征。</p><pre><code class=\"language-plain\">SELECT\n&nbsp;&nbsp;&nbsp;&nbsp;v.model_name,\n&nbsp;&nbsp;&nbsp;&nbsp;d.driving_mode,\n&nbsp;&nbsp;&nbsp;&nbsp;COUNT(*) as mode_usage_count,\n&nbsp;&nbsp;&nbsp;&nbsp;AVG(d.accelerator_pedal) as avg_accelerator,\n&nbsp;&nbsp;&nbsp;&nbsp;AVG(d.brake_pedal) as avg_brake,\n&nbsp;&nbsp;&nbsp;&nbsp;AVG(l.speed) as avg_speed,\n&nbsp;&nbsp;&nbsp;&nbsp;MAX(l.speed) as max_speed,\n&nbsp;&nbsp;&nbsp;&nbsp;AVG(b.soc) as avg_battery_level\nFROM vehicle_base_info v\nJOIN driving_status d ON v.vehicle_id = d.vehicle_id\nJOIN vehicle_location l ON v.vehicle_id = l.vehicle_id\nJOIN battery_status b ON v.vehicle_id = b.vehicle_id\nGROUP BY v.model_name, d.driving_mode\nORDER BY v.model_name, d.driving_mode;\n&nbsp;\n// 说明：使用 JOIN 连接多表，按车型和驾驶模式分组，统计各模式下的使用频率及平均加速、刹车、速度和电量等特征，分析不同驾驶模式的用车行为。\n</code></pre><h3><strong>地理分布分析</strong></h3><p>分析车辆的地理分布密度。</p><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; ROUND(latitude, 2) as lat_region,\n&nbsp; &nbsp; ROUND(longitude, 2) as lon_region,\n&nbsp; &nbsp; COUNT(DISTINCT vehicle_id) as vehicle_count,\n&nbsp; &nbsp; AVG(speed) as avg_speed,\n&nbsp; &nbsp; COUNT(*) as location_records\nFROM vehicle_location\nWHERE collect_time &gt;= DATE_FORMAT(DATE_SUB(NOW(), INTERVAL 1 HOUR), '%Y-%m-%d %H:%i:%s.%f')\nGROUP BY ROUND(latitude, 2), ROUND(longitude, 2)\nHAVING vehicle_count &gt; 1\nORDER BY vehicle_count DESC;\n&nbsp;\n// 说明：通过 ROUND 函数将经纬度四舍五入，按地理区域分组，统计每区域内车辆数量和平均速度，筛选出车辆密度较高的区域，并按密度降序排列。\n</code></pre><h3><strong>SOC 变化趋势分析</strong></h3><p>分析电量快速下降的情况。</p><pre><code class=\"language-plain\">WITH soc_changes AS (\n&nbsp; &nbsp; SELECT\n&nbsp; &nbsp; &nbsp; &nbsp; vehicle_id,\n&nbsp; &nbsp; &nbsp; &nbsp; collect_time,\n&nbsp; &nbsp; &nbsp; &nbsp; soc,\n&nbsp; &nbsp; &nbsp; &nbsp; LAG(soc) OVER (PARTITION BY vehicle_id ORDER BY collect_time) as prev_soc,\n&nbsp; &nbsp; &nbsp; &nbsp; LAG(collect_time) OVER (PARTITION BY vehicle_id ORDER BY collect_time) as prev_time\n&nbsp; &nbsp; FROM battery_status\n)\nSELECT\n&nbsp; &nbsp; v.vin,\n&nbsp; &nbsp; v.model_name,\n&nbsp; &nbsp; s.vehicle_id,\n&nbsp; &nbsp; s.collect_time,\n&nbsp; &nbsp; s.soc,\n&nbsp; &nbsp; s.prev_soc,\n&nbsp; &nbsp; s.soc - s.prev_soc as soc_drop,\n&nbsp; &nbsp; TIMESTAMPDIFF(MINUTE, s.prev_time, s.collect_time) as minutes_elapsed\nFROM soc_changes s\nJOIN vehicle_base_info v ON s.vehicle_id = v.vehicle_id\nWHERE s.prev_soc IS NOT NULL\n&nbsp; AND (s.soc - s.prev_soc) &lt; -10 &nbsp;-- 找出SOC快速下降的情况\nORDER BY s.collect_time DESC;\n&nbsp;\n// 说明：使用 LAG 窗口函数获取前一次的电量和时间，计算电量变化和时间差，筛选出电量快速下降（如降幅超过10%）的情况，并按采集时间降序排列。\n</code></pre><h3><strong>综合性能评估</strong></h3><p>对车辆进行综合性能评分。</p><pre><code class=\"language-plain\">SELECT\n&nbsp; &nbsp; v.vehicle_id,\n&nbsp; &nbsp; v.vin,\n&nbsp; &nbsp; v.model_name,\n&nbsp; &nbsp; AVG(b.soc) as avg_soc,\n&nbsp; &nbsp; MAX(l.speed) as max_speed,\n&nbsp; &nbsp; AVG(m.motor_temperature) as avg_motor_temp,\n&nbsp; &nbsp; COUNT(DISTINCT a.id) as alarm_count,\n&nbsp; &nbsp; AVG(d.mileage) as avg_mileage,\n&nbsp; &nbsp; CASE\n&nbsp; &nbsp; &nbsp; &nbsp; WHEN COUNT(DISTINCT a.id) = 0 AND AVG(b.soc) &gt; 50 THEN 'A'\n&nbsp; &nbsp; &nbsp; &nbsp; WHEN COUNT(DISTINCT a.id) &lt; 3 AND AVG(b.soc) &gt; 30 THEN 'B'\n&nbsp; &nbsp; &nbsp; &nbsp; ELSE 'C'\n&nbsp; &nbsp; END as performance_grade\nFROM vehicle_base_info v\nLEFT JOIN battery_status b ON v.vehicle_id = b.vehicle_id\nLEFT JOIN vehicle_location l ON v.vehicle_id = l.vehicle_id\nLEFT JOIN motor_status m ON v.vehicle_id = m.vehicle_id\nLEFT JOIN vehicle_alarm a ON v.vehicle_id = a.vehicle_id\nLEFT JOIN driving_status d ON v.vehicle_id = d.vehicle_id\nGROUP BY v.vehicle_id, v.vin, v.model_name\nORDER BY performance_grade, avg_soc DESC;\n&nbsp;\n// 说明：通过多表 LEFT JOIN 获取车辆的电量、速度、电机温度、告警次数和里程等数据，使用 CASE 语句综合评估并给出性能评分，按评分和平均电量排序。\n</code></pre><p>如果你是新能源汽车行业的从业人员，这节课将对你非常有帮助。期待你的转发，我们下节课再见！</p>","comments":[]}