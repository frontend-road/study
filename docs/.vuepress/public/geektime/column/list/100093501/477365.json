{"id":477365,"title":"33｜并发：小channel中蕴含大智慧","content":"<p>你好，我是Tony Bai。</p><p>通过上两节课的学习，我们知道了Go语言实现了基于CSP（Communicating Sequential Processes）理论的并发方案。</p><p>Go语言的CSP模型的实现包含两个主要组成部分：一个是Goroutine，它是Go应用并发设计的基本构建与执行单元；另一个就是channel，它在并发模型中扮演着重要的角色。channel既可以用来实现Goroutine间的通信，还可以实现Goroutine间的同步。它就好比Go并发设计这门“武功”的秘籍口诀，可以说，学会在Go并发设计时灵活运用channel，才能说真正掌握了Go并发设计的真谛。</p><p>所以，在这一讲中，我们就来系统学习channel这一并发原语的基础语法与常见使用方法。</p><h2>作为一等公民的channel</h2><p>Go对并发的原生支持可不是仅仅停留在口号上的，Go在语法层面将并发原语channel作为一等公民对待。在前面的<a href=\"https://time.geekbang.org/column/article/460666\">第21讲</a>中我们已经学过“一等公民”这个概念了，如果你记不太清了可以回去复习一下。</p><p>那channel作为一等公民意味着什么呢？</p><p>这意味着我们可以<strong>像使用普通变量那样使用channel</strong>，比如，定义channel类型变量、给channel变量赋值、将channel作为参数传递给函数/方法、将channel作为返回值从函数/方法中返回，甚至将channel发送到其他channel中。这就大大简化了channel原语的使用，提升了我们开发者在做并发设计和实现时的体验。</p><!-- [[[read_end]]] --><h3>创建channel</h3><p>和切片、结构体、map等一样，channel也是一种复合数据类型。也就是说，我们在声明一个channel类型变量时，必须给出其具体的元素类型，比如下面的代码这样：</p><pre><code class=\"language-plain\">var ch chan int\n</code></pre><p>这句代码里，我们声明了一个元素为int类型的channel类型变量ch。</p><p>如果channel类型变量在声明时没有被赋予初值，那么它的默认值为nil。并且，和其他复合数据类型支持使用复合类型字面值作为变量初始值不同，为channel类型变量赋初值的唯一方法就是使用 <strong>make</strong> 这个Go预定义的函数，比如下面代码：</p><pre><code class=\"language-plain\">ch1 := make(chan int)   \nch2 := make(chan int, 5) \n</code></pre><p>这里，我们声明了两个元素类型为int的channel类型变量ch1和ch2，并给这两个变量赋了初值。但我们看到，两个变量的赋初值操作使用的make调用的形式有所不同。</p><p>第一行我们通过 <code>make(chan T)</code>创建的、元素类型为T的channel类型，是<strong>无缓冲channel</strong>，而第二行中通过带有capacity参数的<code>make(chan T, capacity)</code>创建的元素类型为T、缓冲区长度为capacity的channel类型，是<strong>带缓冲channel</strong>。</p><p>这两种类型的变量关于发送（send）与接收（receive）的特性是不同的，我们接下来就基于这两种类型的channel，看看channel类型变量如何进行发送和接收数据元素。</p><h3>发送与接收</h3><p>Go提供了<code>&lt;-</code>操作符用于对channel类型变量进行发送与接收操作：</p><pre><code class=\"language-plain\">ch1 &lt;- 13    // 将整型字面值13发送到无缓冲channel类型变量ch1中\nn := &lt;- ch1  // 从无缓冲channel类型变量ch1中接收一个整型值存储到整型变量n中\nch2 &lt;- 17    // 将整型字面值17发送到带缓冲channel类型变量ch2中\nm := &lt;- ch2  // 从带缓冲channel类型变量ch2中接收一个整型值存储到整型变量m中\n</code></pre><p>这里我要提醒你一句，在理解channel的发送与接收操作时，你一定要始终牢记：<strong>channel是用于Goroutine间通信的</strong>，所以绝大多数对channel的读写都被分别放在了不同的Goroutine中。</p><p>现在，我们先来看看无缓冲channel类型变量（如ch1）的发送与接收。</p><p>由于无缓冲channel的运行时层实现不带有缓冲区，所以Goroutine对无缓冲channel的接收和发送操作是同步的。也就是说，对同一个无缓冲channel，只有对它进行接收操作的Goroutine和对它进行发送操作的Goroutine都存在的情况下，通信才能得以进行，否则单方面的操作会让对应的Goroutine陷入挂起状态，比如下面示例代码：</p><pre><code class=\"language-plain\">func main() {\n    ch1 := make(chan int)\n    ch1 &lt;- 13 // fatal error: all goroutines are asleep - deadlock!\n    n := &lt;-ch1\n    println(n)\n}\n</code></pre><p>在这个示例中，我们创建了一个无缓冲的channel类型变量ch1，对ch1的读写都放在了一个Goroutine中。</p><p>运行这个示例，我们就会得到fatal error，提示我们所有Goroutine都处于休眠状态，程序处于死锁状态。要想解除这种错误状态，我们只需要将接收操作，或者发送操作放到另外一个Goroutine中就可以了，比如下面代码：</p><pre><code class=\"language-plain\">func main() {\n    ch1 := make(chan int)\n    go func() {\n        ch1 &lt;- 13 // 将发送操作放入一个新goroutine中执行\n    }()\n    n := &lt;-ch1\n    println(n)\n}\n</code></pre><p>由此，我们可以得出结论：<strong>对无缓冲channel类型的发送与接收操作，一定要放在两个不同的Goroutine中进行，否则会导致deadlock</strong>。</p><p>接下来，我们再来看看带缓冲channel的发送与接收操作。</p><p>和无缓冲channel相反，带缓冲channel的运行时层实现带有缓冲区，因此，对带缓冲channel的发送操作在缓冲区未满、接收操作在缓冲区非空的情况下是<strong>异步</strong>的（发送或接收不需要阻塞等待）。</p><p>也就是说，对一个带缓冲channel来说，在缓冲区未满的情况下，对它进行发送操作的Goroutine并不会阻塞挂起；在缓冲区有数据的情况下，对它进行接收操作的Goroutine也不会阻塞挂起。</p><p>但当缓冲区满了的情况下，对它进行发送操作的Goroutine就会阻塞挂起；当缓冲区为空的情况下，对它进行接收操作的Goroutine也会阻塞挂起。</p><p>如果光看文字还不是很好理解，你可以再看看下面几个关于带缓冲channel的操作的例子：</p><pre><code class=\"language-plain\">ch2 := make(chan int, 1)\nn := &lt;-ch2 // 由于此时ch2的缓冲区中无数据，因此对其进行接收操作将导致goroutine挂起\n\nch3 := make(chan int, 1)\nch3 &lt;- 17  // 向ch3发送一个整型数17\nch3 &lt;- 27  // 由于此时ch3中缓冲区已满，再向ch3发送数据也将导致goroutine挂起\n</code></pre><p>也正是因为带缓冲channel与无缓冲channel在发送与接收行为上的差异，在具体使用上，它们有各自的“用武之地”，这个我们等会再细说，现在我们先继续把channel的基本语法讲完。</p><p>使用操作符<code>&lt;-</code>，我们还可以声明<strong>只发送channel类型</strong>（send-only）和<strong>只接收channel类型</strong>（recv-only），我们接着看下面这个例子：</p><pre><code class=\"language-plain\">ch1 := make(chan&lt;- int, 1) // 只发送channel类型\nch2 := make(&lt;-chan int, 1) // 只接收channel类型\n\n&lt;-ch1       // invalid operation: &lt;-ch1 (receive from send-only type chan&lt;- int)\nch2 &lt;- 13   // invalid operation: ch2 &lt;- 13 (send to receive-only type &lt;-chan int)\n</code></pre><p>你可以从这个例子中看到，试图从一个只发送channel类型变量中接收数据，或者向一个只接收channel类型发送数据，都会导致编译错误。通常只发送channel类型和只接收channel类型，会被用作函数的参数类型或返回值，用于限制对channel内的操作，或者是明确可对channel进行的操作的类型，比如下面这个例子：</p><pre><code class=\"language-plain\">func produce(ch chan&lt;- int) {\n    for i := 0; i &lt; 10; i++ {\n        ch &lt;- i + 1\n        time.Sleep(time.Second)\n    }\n    close(ch)\n}\n\nfunc consume(ch &lt;-chan int) {\n    for n := range ch {\n        println(n)\n    }\n}\n\nfunc main() {\n    ch := make(chan int, 5)\n    var wg sync.WaitGroup\n    wg.Add(2)\n    go func() {\n        produce(ch)\n        wg.Done()\n    }()\n\n    go func() {\n        consume(ch)\n        wg.Done()\n    }()\n\n    wg.Wait()\n}\n</code></pre><p>在这个例子中，我们启动了两个Goroutine，分别代表生产者（produce）与消费者（consume）。生产者只能向channel中发送数据，我们使用 <code>chan&lt;- int</code> 作为produce函数的参数类型；消费者只能从channel中接收数据，我们使用<code>&lt;-chan int</code> 作为consume函数的参数类型。</p><p>在消费者函数consume中，我们使用了for range循环语句来从channel中接收数据，for range会阻塞在对channel的接收操作上，直到channel中有数据可接收或channel被关闭，才会继续向下执行。channel被关闭后，for range循环也就结束了。</p><h3>关闭channel</h3><p>在上面的例子中，produce函数在发送完数据后，调用Go内置的close函数关闭了channel。channel关闭后，所有等待从这个channel接收数据的操作都将返回。</p><p>这里我们继续看一下采用不同接收语法形式的语句，在channel被关闭后的返回值的情况：</p><pre><code class=\"language-plain\">n := &lt;- ch      // 当ch被关闭后，n将被赋值为ch元素类型的零值\nm, ok := &lt;-ch   // 当ch被关闭后，m将被赋值为ch元素类型的零值, ok值为false\nfor v := range ch { // 当ch被关闭后，for range循环结束\n    ... ...\n}\n</code></pre><p>我们看到，通过“comma, ok”惯用法或for range语句，我们可以准确地判定channel是否被关闭。而单纯采用 <code>n := &lt;-ch</code> 形式的语句，我们就无法判定从ch返回的元素类型零值，究竟是不是因为channel被关闭后才返回的。</p><p>另外，从前面produce的示例程序中，我们也可以看到，channel是在produce函数中被关闭的，这也是channel的一个使用惯例，那就是<strong>发送端负责关闭channel</strong>。</p><p>这里为什么要在发送端关闭channel呢？</p><p>这是因为发送端没有像接受端那样的、可以安全判断channel是否被关闭了的方法。同时，一旦向一个已经关闭的channel执行发送操作，这个操作就会引发panic，比如下面这个示例：</p><pre><code class=\"language-plain\">ch := make(chan int, 5)\nclose(ch)\nch &lt;- 13 // panic: send on closed channel\n</code></pre><h3>select</h3><p>当涉及同时对多个channel进行操作时，我们会结合Go为CSP并发模型提供的另外一个原语 <strong>select</strong>，一起使用。</p><p>通过select，我们可以同时在多个channel上进行发送/接收操作：</p><pre><code class=\"language-plain\">select {\ncase x := &lt;-ch1:     // 从channel ch1接收数据\n\t... ...\n\ncase y, ok := &lt;-ch2: // 从channel ch2接收数据，并根据ok值判断ch2是否已经关闭\n\t... ...\n\ncase ch3 &lt;- z:       // 将z值发送到channel ch3中:\n\t... ...\n\ndefault:             // 当上面case中的channel通信均无法实施时，执行该默认分支\n}\n</code></pre><p>当select语句中没有default分支，而且所有case中的channel操作都阻塞了的时候，整个select语句都将被阻塞，直到某一个case上的channel变成可发送，或者某个case上的channel变成可接收，select语句才可以继续进行下去。关于select语句的妙用，我们在后面还会细讲，这里我们先简单了解它的基本语法。</p><p>看到这里你应该能感受到，channel和select两种原语的操作都十分简单，它们都遵循了Go语言<strong>“追求简单”</strong>的设计哲学，但它们却为Go并发程序带来了强大的表达能力。学习了这些基础用法后，接下来我们再深一层，看看Go并发原语channel的一些惯用法。同样地，这里我们也分成无缓冲channel和带缓冲channel两种情况来分析。</p><h2>无缓冲channel的惯用法</h2><p>无缓冲channel兼具通信和同步特性，在并发程序中应用颇为广泛。现在我们来看看几个无缓冲channel的典型应用：</p><h3>第一种用法：用作信号传递</h3><p>无缓冲channel用作信号传递的时候，有两种情况，分别是1对1通知信号和1对n通知信号。我们先来分析下1对1通知信号这种情况。</p><p>我们直接来看具体的例子：</p><pre><code class=\"language-plain\">type signal struct{}\n\nfunc worker() {\n    println(\"worker is working...\")\n    time.Sleep(1 * time.Second)\n}\n\nfunc spawn(f func()) &lt;-chan signal {\n    c := make(chan signal)\n    go func() {\n        println(\"worker start to work...\")\n        f()\n        c &lt;- signal{}\n    }()\n    return c\n}\n\nfunc main() {\n    println(\"start a worker...\")\n    c := spawn(worker)\n    &lt;-c\n    fmt.Println(\"worker work done!\")\n}\n</code></pre><p>在这个例子中，spawn函数返回的channel，被用于承载新Goroutine退出的<strong>“通知信号”</strong>，这个信号专门用作通知main goroutine。main goroutine在调用spawn函数后一直阻塞在对这个“通知信号”的接收动作上。</p><p>我们来运行一下这个例子：</p><pre><code class=\"language-plain\">start a worker...\nworker start to work...\nworker is working...\nworker work done!\n</code></pre><p>有些时候，无缓冲channel还被用来实现<strong>1对n的信号通知</strong>机制。这样的信号通知机制，常被用于协调多个Goroutine一起工作，比如下面的例子：</p><pre><code class=\"language-plain\">func worker(i int) {\n    fmt.Printf(\"worker %d: is working...\\n\", i)\n    time.Sleep(1 * time.Second)\n    fmt.Printf(\"worker %d: works done\\n\", i)\n}\n\ntype signal struct{}\nfunc spawnGroup(f func(i int), num int, groupSignal &lt;-chan signal) &lt;-chan signal {\n    c := make(chan signal)\n    var wg sync.WaitGroup\n\n    for i := 0; i &lt; num; i++ {\n        wg.Add(1)\n        go func(i int) {\n            &lt;-groupSignal\n            fmt.Printf(\"worker %d: start to work...\\n\", i)\n            f(i)\n            wg.Done()\n        }(i + 1)\n    }\n\n    go func() {\n        wg.Wait()\n        c &lt;- signal{}\n    }()\n    return c\n}\n\nfunc main() {\n    fmt.Println(\"start a group of workers...\")\n    groupSignal := make(chan signal)\n    c := spawnGroup(worker, 5, groupSignal)\n    time.Sleep(5 * time.Second)\n    fmt.Println(\"the group of workers start to work...\")\n    close(groupSignal)\n    &lt;-c\n    fmt.Println(\"the group of workers work done!\")\n}\n</code></pre><p>这个例子中，main goroutine创建了一组5个worker goroutine，这些Goroutine启动后会阻塞在名为groupSignal的无缓冲channel上。main goroutine通过<code>close(groupSignal)</code>向所有worker goroutine广播“开始工作”的信号，收到groupSignal后，所有worker goroutine会<strong>“同时”</strong>开始工作，就像起跑线上的运动员听到了裁判员发出的起跑信号枪声。</p><p>这个例子的运行结果如下：</p><pre><code class=\"language-plain\">start a group of workers...\nthe group of workers start to work...\nworker 3: start to work...\nworker 3: is working...\nworker 4: start to work...\nworker 4: is working...\nworker 1: start to work...\nworker 1: is working...\nworker 5: start to work...\nworker 5: is working...\nworker 2: start to work...\nworker 2: is working...\nworker 3: works done\nworker 4: works done\nworker 5: works done\nworker 1: works done\nworker 2: works done\nthe group of workers work done!\n</code></pre><p>我们可以看到，关闭一个无缓冲channel会让所有阻塞在这个channel上的接收操作返回，从而实现了一种1对n的<strong>“广播”</strong>机制。</p><h3>第二种用法：用于替代锁机制</h3><p>无缓冲channel具有同步特性，这让它在某些场合可以替代锁，让我们的程序更加清晰，可读性也更好。我们可以对比下两个方案，直观地感受一下。</p><p>首先我们看一个传统的、基于“共享内存”+“互斥锁”的Goroutine安全的计数器的实现：</p><pre><code class=\"language-plain\">type counter struct {\n    sync.Mutex\n    i int\n}\n\nvar cter counter\n\nfunc Increase() int {\n    cter.Lock()\n    defer cter.Unlock()\n    cter.i++\n    return cter.i\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n\n    for i := 0; i &lt; 10; i++ {\n        wg.Add(1)\n        go func(i int) {\n            v := Increase()\n            fmt.Printf(\"goroutine-%d: current counter value is %d\\n\", i, v)\n            wg.Done()\n        }(i)\n    }\n\n    wg.Wait()\n}\n</code></pre><p>在这个示例中，我们使用了一个带有互斥锁保护的全局变量作为计数器，所有要操作计数器的Goroutine共享这个全局变量，并在互斥锁的同步下对计数器进行自增操作。</p><p>接下来我们再看更符合Go设计惯例的实现，也就是使用无缓冲channel替代锁后的实现：</p><pre><code class=\"language-plain\">type counter struct {\n    c chan int\n    i int\n}\n\nfunc NewCounter() *counter {\n    cter := &amp;counter{\n        c: make(chan int),\n    }\n    go func() {\n        for {\n            cter.i++\n            cter.c &lt;- cter.i\n        }\n    }()\n    return cter\n}\n\nfunc (cter *counter) Increase() int {\n    return &lt;-cter.c\n}\n\nfunc main() {\n    cter := NewCounter()\n    var wg sync.WaitGroup\n    for i := 0; i &lt; 10; i++ {\n        wg.Add(1)\n        go func(i int) {\n            v := cter.Increase()\n            fmt.Printf(\"goroutine-%d: current counter value is %d\\n\", i, v)\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}\n</code></pre><p>在这个实现中，我们将计数器操作全部交给一个独立的Goroutine去处理，并通过无缓冲channel的同步阻塞特性，实现了计数器的控制。这样其他Goroutine通过Increase函数试图增加计数器值的动作，实质上就转化为了一次无缓冲channel的接收动作。</p><p>这种并发设计逻辑更符合Go语言所倡导的<strong>“不要通过共享内存来通信，而是通过通信来共享内存”</strong>的原则。</p><p>运行这个示例，我们可以得出与互斥锁方案相同的结果：</p><pre><code class=\"language-plain\">goroutine-9: current counter value is 10\ngoroutine-0: current counter value is 1\ngoroutine-6: current counter value is 7\ngoroutine-2: current counter value is 3\ngoroutine-8: current counter value is 9\ngoroutine-4: current counter value is 5\ngoroutine-5: current counter value is 6\ngoroutine-1: current counter value is 2\ngoroutine-7: current counter value is 8\ngoroutine-3: current counter value is 4\n</code></pre><h2>带缓冲channel的惯用法</h2><p>带缓冲的channel与无缓冲的channel的最大不同之处，就在于它的<strong>异步性</strong>。也就是说，对一个带缓冲channel，在缓冲区未满的情况下，对它进行发送操作的Goroutine不会阻塞挂起；在缓冲区有数据的情况下，对它进行接收操作的Goroutine也不会阻塞挂起。</p><p>这种特性让带缓冲的channel有着与无缓冲channel不同的应用场合。接下来我们一个个来分析。</p><h3>第一种用法：用作消息队列</h3><p>channel经常被Go初学者视为在多个Goroutine之间通信的消息队列，这是因为，channel的原生特性与我们认知中的消息队列十分相似，包括Goroutine安全、有FIFO（first-in, first out）保证等。</p><p>其实，和无缓冲channel更多用于信号/事件管道相比，可自行设置容量、异步收发的带缓冲channel更适合被用作为消息队列，并且，带缓冲channel在数据收发的性能上要明显好于无缓冲channel。</p><p>我们可以通过对channel读写的基本测试来印证这一点。下面是一些关于无缓冲channel和带缓冲channel收发性能测试的结果（Go 1.17, MacBook Pro 8核）。基准测试的代码比较多，我就不全部贴出来了，你可以到<a href=\"https://github.com/bigwhite/publication/tree/master/column/timegeek/go-first-course/33/go-channel-operation-benchmark\">这里</a>下载。</p><ul>\n<li><strong>单接收单发送性能的基准测试</strong><br>\n我们先来看看针对一个channel只有一个发送Goroutine和一个接收Goroutine的情况，两种channel的收发性能比对数据：</li>\n</ul><pre><code class=\"language-plain\">// 无缓冲channel\n// go-channel-operation-benchmark/unbuffered-chan\n\n$go test -bench . one_to_one_test.go\ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkUnbufferedChan1To1Send-8   \t 6037778\t       199.7 ns/op\nBenchmarkUnbufferedChan1To1Recv-8   \t 6286850\t       194.5 ns/op\nPASS\nok  \tcommand-line-arguments\t2.833s\n\n// 带缓冲channel\n// go-channel-operation-benchmark/buffered-chan\n\n$go test -bench . one_to_one_cap_10_test.go\ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkBufferedChan1To1SendCap10-8   \t17089879\t        66.16 ns/op\nBenchmarkBufferedChan1To1RecvCap10-8   \t18043450\t        65.57 ns/op\nPASS\nok  \tcommand-line-arguments\t2.460s\n</code></pre><p>然后我们将channel的缓存由10改为100，再看看带缓冲channel的1对1基准测试结果：</p><pre><code class=\"language-plain\">$go test -bench . one_to_one_cap_100_test.go\ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkBufferedChan1To1SendCap100-8   \t23089318\t        53.06 ns/op\nBenchmarkBufferedChan1To1RecvCap100-8   \t23474095\t        51.33 ns/op\nPASS\nok  \tcommand-line-arguments\t2.542s\n</code></pre><ul>\n<li><strong>多接收多发送性能基准测试</strong><br>\n我们再来看看，针对一个channel有多个发送Goroutine和多个接收Goroutine的情况，两种channel的收发性能比对数据（这里建立10个发送Goroutine和10个接收Goroutine）：</li>\n</ul><pre><code class=\"language-plain\">// 无缓冲channel\n// go-channel-operation-benchmark/unbuffered-chan\n\n$go test -bench .  multi_to_multi_test.go \ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkUnbufferedChanNToNSend-8   \t  293930\t      3779 ns/op\nBenchmarkUnbufferedChanNToNRecv-8   \t  280904\t      4190 ns/op\nPASS\nok  \tcommand-line-arguments\t2.387s\n\n// 带缓冲channel\n// go-channel-operation-benchmark/buffered-chan\n\n$go test -bench . multi_to_multi_cap_10_test.go \ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkBufferedChanNToNSendCap10-8   \t  736540\t      1609 ns/op\nBenchmarkBufferedChanNToNRecvCap10-8   \t  795416\t      1616 ns/op\nPASS\nok  \tcommand-line-arguments\t2.514s\n</code></pre><p>这里我们也将channel的缓存由10改为100后，看看带缓冲channel的多对多基准测试结果：</p><pre><code class=\"language-plain\">$go test -bench . multi_to_multi_cap_100_test.go \ngoos: darwin\ngoarch: amd64\ncpu: Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz\nBenchmarkBufferedChanNToNSendCap100-8   \t 1236453\t       966.4 ns/op\nBenchmarkBufferedChanNToNRecvCap100-8   \t 1279766\t       969.4 ns/op\nPASS\nok  \tcommand-line-arguments\t4.309s\n</code></pre><p>综合前面这些结果数据，我们可以得出几个初步结论：</p><ul>\n<li>无论是1收1发还是多收多发，带缓冲channel的收发性能都要好于无缓冲channel；</li>\n<li>对于带缓冲channel而言，发送与接收的Goroutine数量越多，收发性能会有所下降；</li>\n<li>对于带缓冲channel而言，选择适当容量会在一定程度上提升收发性能。</li>\n</ul><p>不过你要注意的是，Go支持channel的初衷是将它作为Goroutine间的通信手段，它并不是专门用于消息队列场景的。如果你的项目需要专业消息队列的功能特性，比如支持优先级、支持权重、支持离线持久化等，那么channel就不合适了，可以使用第三方的专业的消息队列实现。</p><h3>第二种用法：用作计数信号量（counting semaphore）</h3><p>Go并发设计的一个惯用法，就是将带缓冲channel用作计数信号量（counting semaphore）。带缓冲channel中的当前数据个数代表的是，当前同时处于活动状态（处理业务）的Goroutine的数量，而带缓冲channel的容量（capacity），就代表了允许同时处于活动状态的Goroutine的最大数量。向带缓冲channel的一个发送操作表示获取一个信号量，而从channel的一个接收操作则表示释放一个信号量。</p><p>这里我们来看一个将带缓冲channel用作计数信号量的例子：</p><pre><code class=\"language-plain\">var active = make(chan struct{}, 3)\nvar jobs = make(chan int, 10)\n\nfunc main() {\n    go func() {\n        for i := 0; i &lt; 8; i++ {\n            jobs &lt;- (i + 1)\n        }\n        close(jobs)\n    }()\n\n    var wg sync.WaitGroup\n\n    for j := range jobs {\n        wg.Add(1)\n        go func(j int) {\n            active &lt;- struct{}{}\n            log.Printf(\"handle job: %d\\n\", j)\n            time.Sleep(2 * time.Second)\n            &lt;-active\n            wg.Done()\n        }(j)\n    }\n    wg.Wait()\n}\n</code></pre><p>我们看到，这个示例创建了一组Goroutine来处理job，同一时间允许最多3个Goroutine处于活动状态。</p><p>为了达成这一目标，我们看到这个示例使用了一个容量（capacity）为3的带缓冲channel: <strong>active</strong> 作为计数信号量，这意味着允许同时处于<strong>活动状态</strong>的最大Goroutine数量为3。</p><p>我们运行一下这个示例：</p><pre><code class=\"language-plain\">2022/01/02 10:08:55 handle job: 1\n2022/01/02 10:08:55 handle job: 4\n2022/01/02 10:08:55 handle job: 8\n2022/01/02 10:08:57 handle job: 5\n2022/01/02 10:08:57 handle job: 7\n2022/01/02 10:08:57 handle job: 6\n2022/01/02 10:08:59 handle job: 3\n2022/01/02 10:08:59 handle job: 2\n</code></pre><p>从示例运行结果中的时间戳中，我们可以看到，虽然我们创建了很多Goroutine，但由于计数信号量的存在，同一时间内处于活动状态（正在处理job）的Goroutine的数量最多为3个。</p><h3>len(channel)的应用</h3><p><strong>len</strong>是Go语言的一个内置函数，它支持接收数组、切片、map、字符串和channel类型的参数，并返回对应类型的“长度”，也就是一个整型值。</p><p>针对channel ch的类型不同，len(ch)有如下两种语义：</p><ul>\n<li>当ch为无缓冲channel时，len(ch)总是返回0；</li>\n<li>当ch为带缓冲channel时，len(ch)返回当前channel ch中尚未被读取的元素个数。</li>\n</ul><p>这样一来，针对带缓冲channel的len调用似乎才是有意义的。那我们是否可以使用len函数来实现带缓冲channel的“判满”、“判有”和“判空”逻辑呢？就像下面示例中伪代码这样：</p><pre><code class=\"language-plain\">var ch chan T = make(chan T, capacity)\n\n// 判空\nif len(ch) == 0 {\n    // 此时channel ch空了?\n}\n\n// 判有\nif len(ch) &gt; 0 {\n    // 此时channel ch中有数据?\n}\n\n// 判满\nif len(ch) == cap(ch) {\n    // 此时channel ch满了?\n}\n</code></pre><p>你可以看到，我在上面代码注释的“空了”、“有数据”和“满了”的后面都<strong>打上了问号</strong><strong>。</strong>这是为什么呢？</p><p>这是因为，channel原语用于多个Goroutine间的通信，一旦多个Goroutine共同对channel进行收发操作，len(channel)就会在多个Goroutine间形成“竞态”。单纯地依靠len(channel)来判断channel中元素状态，是不能保证在后续对channel的收发时channel状态是不变的。</p><p>我们以判空为例看看：</p><p><img src=\"https://static001.geekbang.org/resource/image/39/9a/39b77d5624701d2df79ff0b8865d339a.jpg?wh=1920x1047\" alt=\"图片\"></p><p>从上图可以看到，Goroutine1使用len(channel)判空后，就会尝试从channel中接收数据。但在它真正从channel读数据之前，另外一个Goroutine2已经将数据读了出去，所以，Goroutine1后面的<strong>读取就会阻塞在channel上</strong>，导致后面逻辑的失效。</p><p>因此，<strong>为了不阻塞在channel上</strong>，常见的方法是将“判空与读取”放在一个“事务”中，将“判满与写入”放在一个“事务”中，而这类“事务”我们可以通过select实现。我们来看下面示例：</p><pre><code class=\"language-plain\">func producer(c chan&lt;- int) {\n    var i int = 1\n    for {\n        time.Sleep(2 * time.Second)\n        ok := trySend(c, i)\n        if ok {\n            fmt.Printf(\"[producer]: send [%d] to channel\\n\", i)\n            i++\n            continue\n        }\n        fmt.Printf(\"[producer]: try send [%d], but channel is full\\n\", i)\n    }\n}\n\nfunc tryRecv(c &lt;-chan int) (int, bool) {\n    select {\n    case i := &lt;-c:\n        return i, true\n\n    default:\n        return 0, false\n    }\n}\n\nfunc trySend(c chan&lt;- int, i int) bool {\n    select {\n    case c &lt;- i:\n        return true\n    default:\n        return false\n    }\n}\n\nfunc consumer(c &lt;-chan int) {\n    for {\n        i, ok := tryRecv(c)\n        if !ok {\n            fmt.Println(\"[consumer]: try to recv from channel, but the channel is empty\")\n            time.Sleep(1 * time.Second)\n            continue\n        }\n        fmt.Printf(\"[consumer]: recv [%d] from channel\\n\", i)\n        if i &gt;= 3 {\n            fmt.Println(\"[consumer]: exit\")\n            return\n        }\n    }\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n    c := make(chan int, 3)\n    wg.Add(2)\n    go func() {\n        producer(c)\n        wg.Done()\n    }()\n\n    go func() {\n        consumer(c)\n        wg.Done()\n    }()\n\n    wg.Wait()\n}\n</code></pre><p>我们看到，由于用到了select原语的default分支语义，当channel空的时候，tryRecv不会阻塞；当channel满的时候，trySend也不会阻塞。</p><p>这个示例的运行结果也证明了这一点，无论是使用tryRecv的consumer还是使用trySend的producer都不会阻塞：</p><pre><code class=\"language-plain\">[consumer]: try to recv from channel, but the channel is empty\n[consumer]: try to recv from channel, but the channel is empty\n[producer]: send [1] to channel\n[consumer]: recv [1] from channel\n[consumer]: try to recv from channel, but the channel is empty\n[consumer]: try to recv from channel, but the channel is empty\n[producer]: send [2] to channel\n[consumer]: recv [2] from channel\n[consumer]: try to recv from channel, but the channel is empty\n[consumer]: try to recv from channel, but the channel is empty\n[producer]: send [3] to channel\n[consumer]: recv [3] from channel\n[consumer]: exit\n[producer]: send [4] to channel\n[producer]: send [5] to channel\n[producer]: send [6] to channel\n[producer]: try send [7], but channel is full\n[producer]: try send [7], but channel is full\n[producer]: try send [7], but channel is full\n... ...\n</code></pre><p>这种方法适用于大多数场合，但是这种方法有一个“问题”，那就是它改变了channel的状态，会让channel接收了一个元素或发送一个元素到channel。</p><p>有些时候我们不想这么做，我们想在不改变channel状态的前提下，单纯地侦测channel的状态，而又不会因channel满或空阻塞在channel上。但很遗憾，目前没有一种方法可以在实现这样的功能的同时，适用于所有场合。</p><p>但是在特定的场景下，我们可以用len(channel)来实现。比如下面这两种场景：</p><p><img src=\"https://static001.geekbang.org/resource/image/b3/37/b31d081fcced758b8f99c938a0b75237.jpg?wh=1920x1047\" alt=\"图片\"></p><p>上图中的情景(a)是一个“多发送单接收”的场景，也就是有多个发送者，但<strong>有且只有一个接收者</strong>。在这样的场景下，我们可以在接收goroutine中使用 <code>len(channel)是否大于0</code>来判断是否channel中有数据需要接收。</p><p>而情景(b)呢，是一个“多接收单发送”的场景，也就是有多个接收者，但<strong>有且只有一个发送者</strong>。在这样的场景下，我们可以在发送Goroutine中使用 <code>len(channel)是否小于 cap(channel)</code>来判断是否可以执行向channel的发送操作。</p><h2>nil channel的妙用</h2><p>如果一个channel类型变量的值为nil，我们称它为 <strong>nil channel</strong>。nil channel有一个特性，那就是对nil channel的读写都会发生阻塞。比如下面示例代码：</p><pre><code class=\"language-plain\">func main() {\n\tvar c chan int\n\t&lt;-c //阻塞\n}\n\n或者：\n\nfunc main() {\n\tvar c chan int\n\tc&lt;-1  //阻塞\n}\n</code></pre><p>你会看到，无论上面的哪段代码被执行，main goroutine都会阻塞在对nil channel的操作上。</p><p>不过，nil channel的这个特性可不是一无是处，有些时候应用nil channel的这个特性可以得到事半功倍的效果。我们来看一个例子：</p><pre><code class=\"language-plain\">func main() {\n    ch1, ch2 := make(chan int), make(chan int)\n    go func() {\n        time.Sleep(time.Second * 5)\n        ch1 &lt;- 5\n        close(ch1)\n    }()\n\n    go func() {\n        time.Sleep(time.Second * 7)\n        ch2 &lt;- 7\n        close(ch2)\n    }()\n\n    var ok1, ok2 bool\n    for {\n        select {\n        case x := &lt;-ch1:\n            ok1 = true\n            fmt.Println(x)\n        case x := &lt;-ch2:\n            ok2 = true\n            fmt.Println(x)\n        }\n\n        if ok1 &amp;&amp; ok2 {\n            break\n        }\n    }\n    fmt.Println(\"program end\")\n}\n</code></pre><p>在这个示例中，我们期望程序在接收完ch1和ch2两个channel上的数据后就退出。但实际的运行情况却是这样的：</p><pre><code class=\"language-plain\">5\n0\n0\n0\n... ... //循环输出0\n7\nprogram end\n</code></pre><p>我们原本期望上面这个在依次输出5和7两个数字后退出，但实际运行的输出结果却是在输出5之后，程序输出了许多的0值，之后才输出7并退出。</p><p>这是怎么回事呢？我们简单分析一下这段代码的运行过程：</p><ul>\n<li>前5s，select一直处于阻塞状态；</li>\n<li>第5s，ch1返回一个5后被close，select语句的 <code>case x := &lt;-ch1</code> 这个分支被选出执行，程序输出5，并回到for循环并重新select；</li>\n<li>由于ch1被关闭，从一个已关闭的channel接收数据将永远不会被阻塞，于是新一轮select又把 <code>case x := &lt;-ch1</code>这个分支选出并执行。由于ch1处于关闭状态，从这个channel获取数据，我们会得到这个channel对应类型的零值，这里就是0。于是程序再次输出0；程序按这个逻辑循环执行，一直输出0值；</li>\n<li>2s后，ch2被写入了一个数值7。这样在某一轮select的过程中，分支 <code>case x := &lt;-ch2</code>被选中得以执行，程序输出7之后满足退出条件，于是程序终止。</li>\n</ul><p>那我们可以怎么改进一下这个程序，让它能按照我们的预期输出呢？</p><p>是时候让nil channel登场了！用nil channel改进后的示例代码是这样的：</p><pre><code class=\"language-plain\">func main() {\n    ch1, ch2 := make(chan int), make(chan int)\n    go func() {\n        time.Sleep(time.Second * 5)\n        ch1 &lt;- 5\n        close(ch1)\n    }()\n\n    go func() {\n        time.Sleep(time.Second * 7)\n        ch2 &lt;- 7\n        close(ch2)\n    }()\n\n    for {\n        select {\n        case x, ok := &lt;-ch1:\n            if !ok {\n                ch1 = nil\n            } else {\n                fmt.Println(x)\n            }\n        case x, ok := &lt;-ch2:\n            if !ok {\n                ch2 = nil\n            } else {\n                fmt.Println(x)\n            }\n        }\n        if ch1 == nil &amp;&amp; ch2 == nil {\n            break\n        }\n    }\n    fmt.Println(\"program end\")\n}\n</code></pre><p>这里，改进后的示例程序的最关键的一个变化，就是在判断ch1或ch2被关闭后，显式地将ch1或ch2置为nil。</p><p>而我们前面已经知道了，<strong>对一个nil channel执行获取操作，这个操作将阻塞</strong>。于是，这里已经被置为nil的c1或c2的分支，将再也不会被select选中执行。</p><p>改进后的示例的运行结果如下，与我们预期相符：</p><pre><code class=\"language-plain\">5\n7\nprogram end\n</code></pre><h2>与select结合使用的一些惯用法</h2><p>channel和select的结合使用能形成强大的表达能力，我们在前面的例子中已经或多或少见识过了。这里我再强调几种channel与select结合的惯用法。</p><h3>第一种用法：利用default分支避免阻塞</h3><p>select语句的default分支的语义，就是在其他非default分支因通信未就绪，而无法被选择的时候执行的，这就给default分支赋予了一种“避免阻塞”的特性。</p><p>其实在前面的<strong>“len(channel)的应用”</strong>小节的例子中，我们就已经用到了“利用default分支”实现的 <code>trySend</code> 和 <code>tryRecv</code> 两个函数：</p><pre><code class=\"language-plain\">func tryRecv(c &lt;-chan int) (int, bool) {\n\tselect {\n\tcase i := &lt;-c:\n\t\treturn i, true\n\n\tdefault: // channel为空\n\t\treturn 0, false\n\t}\n}\n\nfunc trySend(c chan&lt;- int, i int) bool {\n\tselect {\n\tcase c &lt;- i:\n\t\treturn true\n\tdefault: // channel满了\n\t\treturn false\n\t}\n}\n</code></pre><p>而且，无论是无缓冲channel还是带缓冲channel，这两个函数都能适用，并且不会阻塞在空channel或元素个数已经达到容量的channel上。</p><p>在Go标准库中，这个惯用法也有应用，比如：</p><pre><code class=\"language-plain\">// $GOROOT/src/time/sleep.go\nfunc sendTime(c interface{}, seq uintptr) {\n    // 无阻塞的向c发送当前时间\n    select {\n    case c.(chan Time) &lt;- Now():\n    default:\n    }\n}\n</code></pre><h3>第二种用法：实现超时机制</h3><p>带超时机制的select，是Go中常见的一种select和channel的组合用法。通过超时事件，我们既可以避免长期陷入某种操作的等待中，也可以做一些异常处理工作。</p><p>比如，下面示例代码实现了一次具有30s超时的select：</p><pre><code class=\"language-plain\">func worker() {\n\tselect {\n\tcase &lt;-c:\n\t     // ... do some stuff\n\tcase &lt;-time.After(30 *time.Second):\n\t    return\n\t}\n}\n</code></pre><p>不过，在应用带有超时机制的select时，我们要特别注意 <strong>timer使用后的释放</strong>，尤其在大量创建timer的时候。</p><p>Go语言标准库提供的timer实际上是由Go运行时自行维护的，而不是操作系统级的定时器资源，它的使用代价要比操作系统级的低许多。但即便如此，作为time.Timer的使用者，我们也要尽量减少在使用Timer时给Go运行时和Go垃圾回收带来的压力，要及时调用timer的Stop方法回收Timer资源。</p><h3>第三种用法：实现心跳机制</h3><p>结合time包的Ticker，我们可以实现带有心跳机制的select。这种机制让我们可以在监听channel的同时，执行一些<strong>周期性的任务</strong>，比如下面这段代码：</p><pre><code class=\"language-plain\">func worker() {\n\theartbeat := time.NewTicker(30 * time.Second)\n\tdefer heartbeat.Stop()\n\tfor {\n\t\tselect {\n\t\tcase &lt;-c:\n\t\t\t// ... do some stuff\n\t\tcase &lt;- heartbeat.C:\n\t\t\t//... do heartbeat stuff\n\t\t}\n\t}\n}\n</code></pre><p>这里我们使用time.NewTicker，创建了一个Ticker类型实例heartbeat。这个实例包含一个channel类型的字段C，这个字段会按一定时间间隔持续产生事件，就像“心跳”一样。这样for循环在channel c无数据接收时，会每隔特定时间完成一次迭代，然后回到for循环进行下一次迭代。</p><p>和timer一样，我们在使用完ticker之后，也不要忘记调用它的Stop方法，避免心跳事件在ticker的channel（上面示例中的heartbeat.C）中持续产生。</p><h2>小结</h2><p>好了，今天的课讲到这里就结束了，现在我们一起来回顾一下吧。</p><p>在这一讲中，我们系统学习了Go CSP并发方案中除Goroutine之外的另一个重要组成部分：channel。Go为了原生支持并发，把channel视作一等公民身份，这就大幅提升了开发人员使用channel进行并发设计和实现的体验。</p><p>通过预定义函数make，我们可以创建两类channel：无缓冲channel与带缓冲的channel。这两类channel具有不同的收发特性，可以适用于不同的应用场合：无缓冲channel兼具通信与同步特性，常用于作为信号通知或替代同步锁；而带缓冲channel的异步性，让它更适合用来实现基于内存的消息队列、计数信号量等。</p><p>此外，你也要牢记值为nil的channel的阻塞特性，有些时候它也能帮上大忙。而面对已关闭的channel你也一定要小心，尤其要避免向已关闭的channel发送数据，那会导致panic。</p><p>最后，select是Go为了支持同时操作多个channel，而引入的另外一个并发原语，select与channel有几种常用的固定搭配，你也要好好掌握和理解。</p><h2>思考题</h2><p>channel作为Go并发设计的重要组成部分，需要你掌握的细节非常多。而且，channel的应用模式也非常多，我们这一讲仅挑了几个常见的模式做了讲解。在日常开发中你还见过哪些实用的channel使用模式呢？欢迎在留言区分享。</p><p>如果你觉得有收获，也欢迎你把这节课分享给更多对Go并发感兴趣的朋友。我是Tony Bai，我们下节课见。</p>","comments":[{"had_liked":false,"id":342010,"user_name":"peison","can_delete":false,"product_type":"c1","uid":1142893,"ip_address":"","ucode":"C467A3E0133EA2","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/6d/11ea66f0.jpg","comment_is_top":false,"comment_ctime":1649952382,"is_pvip":false,"replies":[{"id":125021,"content":"好问题！\nchannel内部数据是排队的，即便被close，依然可以从closed channel中读取到尚未被消费的元素，直到没有可读的元素为止，才真正会变成closed状态。没数据后，如果再读就会得到元素类型的零值了, 对于没数据且closed状态的channel，for range会终止。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1650013753,"ip_address":"","comment_id":342010,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请问计数信号量的例子中，因为jobs的容量是10，这里执行的循环不会导致阻塞，close(jobs) 应该会被执行到，那么下面的for range为什么不会终止，而可以继续运行？\ngo func() {\n\t\tfor i := 0; i &lt; 8; i++ {\n\t\t\tjobs &lt;- (i + 1)\n\t\t}\n\t\tclose(jobs) \n\t}()","like_count":24},{"had_liked":false,"id":335115,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1645341970,"is_pvip":false,"replies":[{"id":122607,"content":"channel一旦没有人引用了，就会被gc掉，不关闭也ok。但是如果有goroutine一直在读channel，那么channel一直存在，不会关闭。直到程序退出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1645604443,"ip_address":"","comment_id":335115,"utype":1}],"discussion_count":1,"race_medal":2,"score":2,"product_id":100093501,"comment_content":"这节课信息量有点大，需要多看几遍好好消化。请问老师一个问题：如果程序中没有手动 close channel，那么 channel 会在什么时候关闭呢？是否需要借助 defer 去释放 channel 资源呢？","like_count":13,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563515,"discussion_content":"好问题！\nchannel内部数据是排队的，即便被close，依然可以从closed channel中读取到尚未被消费的元素，直到没有可读的元素为止，才真正会变成closed状态。没数据后，如果再读就会得到元素类型的零值了, 对于没数据且closed状态的channel，for range会终止。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1650013753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1357603,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b7/23/ea83d6eb.jpg","nickname":"-.-","note":"","ucode":"3CDC606BDFDD80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":622677,"discussion_content":"试了一下把close去掉，没有得到零值，而是报错：fatal error: all goroutines are asleep - deadlock! 这是为什么呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688538143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":563515,"ip_address":"北京","group_id":0},"score":622677,"extra":""},{"author":{"id":1149221,"avatar":"https://static001.geekbang.org/account/avatar/00/11/89/25/02f1b5ec.jpg","nickname":"柳丁烧麦","note":"","ucode":"87F3F998277970","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1357603,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b7/23/ea83d6eb.jpg","nickname":"-.-","note":"","ucode":"3CDC606BDFDD80","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626250,"discussion_content":"没有close，for j := range jobs 在接收完jobs中所有数据后进入阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692690394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":622677,"ip_address":"中国香港","group_id":0},"score":626250,"extra":""}]},{"author":{"id":1650378,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","nickname":"菠萝吹雪—Code","note":"","ucode":"A5B2FC661EE17D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587015,"discussion_content":"疑问解决了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662687191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1805408,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/8c/60/58b6c39e.jpg","nickname":"zzy","note":"","ucode":"3D7EC623EB8204","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582107,"discussion_content":"正想提出这疑问的，发现已有解答了^_^","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659237398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3794407,"avatar":"","nickname":"Geek_3d0fe8","note":"","ucode":"E75EACDA00E7A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":638869,"discussion_content":"关闭的channel还是能读出来元素的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710050831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330387,"user_name":"ibin","can_delete":false,"product_type":"c1","uid":2699840,"ip_address":"","ucode":"766942C36B8E27","user_header":"https://static001.geekbang.org/account/avatar/00/29/32/40/d56f476c.jpg","comment_is_top":false,"comment_ctime":1641961680,"is_pvip":false,"replies":[{"id":121540,"content":"close一个channel后，所有阻塞在这个channel接收操作的goroutine都会收到通知，这是Go语言的channel语义就这么定义的。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1643442687,"ip_address":"","comment_id":330387,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"白老师，你好，下面这段可以模拟close(groupSignal)\nfor i := 0;i &lt; 5; i++ {\n\t\tgroupSignal&lt;-signal(struct{}{})\n}\n为什么close(groupSignal) 可以给每个groupSignal都发送了{}","like_count":10,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552819,"discussion_content":"channel一旦没有人引用了，就会被gc掉，不关闭也ok。但是如果有goroutine一直在读channel，那么channel一直存在，不会关闭。直到程序退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645604444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338582,"user_name":"木木","can_delete":false,"product_type":"c1","uid":2704565,"ip_address":"","ucode":"86820F26A27308","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/b5/7eba5a0e.jpg","comment_is_top":false,"comment_ctime":1647576224,"is_pvip":false,"replies":[{"id":123861,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1647812431,"ip_address":"","comment_id":338582,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"go的并发原语选择真的是非常精炼：简洁又强大，一个ch就负责了线程通信、同步的多种功能；一个select又实现了对阻塞、非阻塞的控制以及事件循环模式。","like_count":8,"discussions":[{"author":{"id":2903068,"avatar":"","nickname":"Geek_05d654","note":"","ucode":"D10FB87A0A62A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564562,"discussion_content":"close一个channel后，由于关闭的channel被读取不会阻塞，会返回零值，所有阻塞读该channel 的 goroutine 都可以读到零值，不再阻塞，继续执行后面的逻辑；建议可以看看 context 源码，里面的父级取消就是这么通知的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1650279088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045910,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","nickname":"Aeins","note":"","ucode":"D5BF220767541D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574468,"discussion_content":"1. channel 关闭后将不再阻塞\n2. 从关闭的 channel 读数据，将返回 channel 元素类型的零值","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1654072438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548904,"discussion_content":"close一个channel后，所有阻塞在这个channel接收操作的goroutine都会收到通知，这是Go语言的channel语义就这么定义的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643442687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546568,"discussion_content":"我的理解是这5个Goroutine都从groupSignal 这个channel中接收数据（&lt;-groupSignal），而close(groupSignal) 关闭groupSignal 这个channel后，5个Goroutine此时不在阻塞在接收操作那一行了，开始往下执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642340627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346081,"user_name":"airmy丶","can_delete":false,"product_type":"c1","uid":1299673,"ip_address":"","ucode":"41959C9F5B4B65","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/d9/c3296187.jpg","comment_is_top":false,"comment_ctime":1652806046,"is_pvip":false,"replies":[{"id":126373,"content":"Wait方法的语义就是等待例子中for循环创建的所有子goroutine，直到每个子goroutine都调用完wg.Done才返回。如果不再一个新goroutine执行，wg.Wait就会阻塞住main goroutine，这也将导致后续所有goroutine都阻塞住，然后go运行时检测到所有goroutine都阻塞住了，于是报错退出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1653057488,"ip_address":"","comment_id":346081,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请问下老师: 为什么 &quot;1 对 n 的信号通知机制&quot; 这个例子中，wg.Wait() 一定需要新起一个协程执行呢？而且在本地测试确实只能在新的协程中执行才不会报错，否则会报出: goroutine x [chan receive] 这样的错误。","like_count":6,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572937,"discussion_content":"Wait方法的语义就是等待例子中for循环创建的所有子goroutine，直到每个子goroutine都调用完wg.Done才返回。如果不再一个新goroutine执行，wg.Wait就会阻塞住main goroutine，这也将导致后续所有goroutine都阻塞住，然后go运行时检测到所有goroutine都阻塞住了，于是报错退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653057488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045910,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","nickname":"Aeins","note":"","ucode":"D5BF220767541D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574471,"discussion_content":"这个还真容易出错。\n根本原因在于 Go 检测到所有 goroutine 都会因阻塞。如果再起一个不会阻塞的 goroutine，就不会报错。\n\n就这个示例而言，\nc := spawnGroup(worker, 5, groupSignal)\n有返回值，导致不能用 go 语句起新的 goroutine\n\n此时 wg.Wait() 如果不在独立的 goroutine 中调用，会导致其和 main 在一个 goroutine 中，阻止了 main 函数中 spawnGroup 语句后面代码的执行，即, close(groupSignal) 得不到执行，进而导致所有的 goroutine 阻塞 \n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1654073389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342776,"user_name":"瓜牛","can_delete":false,"product_type":"c1","uid":2273620,"ip_address":"","ucode":"5EB7D2F4400A70","user_header":"https://static001.geekbang.org/account/avatar/00/22/b1/54/6d663b95.jpg","comment_is_top":false,"comment_ctime":1650456796,"is_pvip":false,"replies":[{"id":125291,"content":"首先明确一点:channel如果不close，也不会存在资源泄露的问题。\n\n是否需要close channel完全看需要。\n\n至于如何知道何时需要，看文中对close channel的语义的描述，以及如何基于这种语义的一些妙用。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1650596976,"ip_address":"","comment_id":342776,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"为啥有时需要手动调用close关闭channel，有时又不需要？","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":572937,"discussion_content":"Wait方法的语义就是等待例子中for循环创建的所有子goroutine，直到每个子goroutine都调用完wg.Done才返回。如果不再一个新goroutine执行，wg.Wait就会阻塞住main goroutine，这也将导致后续所有goroutine都阻塞住，然后go运行时检测到所有goroutine都阻塞住了，于是报错退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1653057488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045910,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","nickname":"Aeins","note":"","ucode":"D5BF220767541D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574471,"discussion_content":"这个还真容易出错。\n根本原因在于 Go 检测到所有 goroutine 都会因阻塞。如果再起一个不会阻塞的 goroutine，就不会报错。\n\n就这个示例而言，\nc := spawnGroup(worker, 5, groupSignal)\n有返回值，导致不能用 go 语句起新的 goroutine\n\n此时 wg.Wait() 如果不在独立的 goroutine 中调用，会导致其和 main 在一个 goroutine 中，阻止了 main 函数中 spawnGroup 语句后面代码的执行，即, close(groupSignal) 得不到执行，进而导致所有的 goroutine 阻塞 \n","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1654073389,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369863,"user_name":"怎么睡才能做这种梦","can_delete":false,"product_type":"c1","uid":3050745,"ip_address":"湖北","ucode":"81A7B6EF124E90","user_header":"https://static001.geekbang.org/account/avatar/00/2e/8c/f9/e1dab0ca.jpg","comment_is_top":false,"comment_ctime":1678071770,"is_pvip":false,"replies":[{"id":134824,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1678092714,"ip_address":"北京","comment_id":369863,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"另外，select 语句中，如果有多个 case 同时都没有阻塞的话，会随机选择一个 case ","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566085,"discussion_content":"首先明确一点:channel如果不close，也不会存在资源泄露的问题。\n\n是否需要close channel完全看需要。\n\n至于如何知道何时需要，看文中对close channel的语义的描述，以及如何基于这种语义的一些妙用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650596976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110662,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg","nickname":"Hank_Yan","note":"","ucode":"86899B561C502B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592054,"discussion_content":"不close的，都return到主goroutine里面了。程序结束就没了。\n另外，老师也在其他留言回答了，没有引用会gc掉，不用担心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667049540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":362821,"user_name":"Unknown element","can_delete":false,"product_type":"c1","uid":2028277,"ip_address":"北京","ucode":"34A129800D0238","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","comment_is_top":false,"comment_ctime":1668937522,"is_pvip":false,"replies":[{"id":131966,"content":"如果channel中的元素大小为0，那就不需要额外分配缓存(buf)；\n如果元素类型中不含有指针，那么buf就和hchan一起分配(将来也和hchan一起释放)，减少一次heap mem分配。GC只扫描hchan就ok了。\n如果元素类型包含指针，那么hchan和hchan.buf单独分配内存，GC分别扫描hchan和buf中的元素。\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669019963,"ip_address":"北京","comment_id":362821,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师我看makechan的源码发现分配内存的时候分了3种情况：\n1. 缓冲区大小=0 \n2. 元素类型不是指针 \n3. 元素类型包含指针\n我想问下为什么2和3要分成两种情况呢？我看区别好像是调用 mallocgc 时第二个参数不一样，但是mallocgc 的源码我就看不懂了。。。希望老师可以简单解释下 谢谢老师~","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594375,"discussion_content":"如果channel中的元素大小为0，那就不需要额外分配缓存(buf)；\n如果元素类型中不含有指针，那么buf就和hchan一起分配(将来也和hchan一起释放)，减少一次heap mem分配。GC只扫描hchan就ok了。\n如果元素类型包含指针，那么hchan和hchan.buf单独分配内存，GC分别扫描hchan和buf中的元素。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669019964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351916,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1658289810,"is_pvip":false,"replies":[{"id":128099,"content":"由于箭头都是向左的，即&lt;-，所以我区分只发送和只接收型的channel的tip是以 chan这个关键字为中心，将chan关键字看成一个“管子”。当&lt;-在chan的右边，即chan &lt;- 好似向管子里写，这样就是只发送型。当&lt;-在chan的左边，即&lt;- chan ，好似从管子里取，这样就是只接收型。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1658402093,"ip_address":"","comment_id":351916,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"感觉只发送channel和只接收channel类型定义符号，交换一下更好理解，也更形象吧\n\nmake(chan&lt;- int, 1) 这个代表只接收\nmake(&lt;-chan int, 1) 这个代表只发送","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580916,"discussion_content":"由于箭头都是向左的，即&lt;-，所以我区分只发送和只接收型的channel的tip是以 chan这个关键字为中心，将chan关键字看成一个“管子”。当&lt;-在chan的右边，即chan &lt;- 好似向管子里写，这样就是只发送型。当&lt;-在chan的左边，即&lt;- chan ，好似从管子里取，这样就是只接收型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658402093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","nickname":"每天晒白牙","note":"","ucode":"A1B102CD933DEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580624,"discussion_content":"理解错了\n只发送代表的是只能往channel中发送\n只接收代表的是只能从channel中接收\n所以还是很形象的，我理解错了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658299799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330344,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1641939997,"is_pvip":false,"replies":[{"id":120549,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642050812,"ip_address":"","comment_id":330344,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"这节课比较绕，要静下心好好学习","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545792,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642050812,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342010,"user_name":"peison","can_delete":false,"product_type":"c1","uid":1142893,"ip_address":"","ucode":"C467A3E0133EA2","user_header":"https://static001.geekbang.org/account/avatar/00/11/70/6d/11ea66f0.jpg","comment_is_top":false,"comment_ctime":1649952382,"is_pvip":false,"replies":[{"id":125021,"content":"好问题！\nchannel内部数据是排队的，即便被close，依然可以从closed channel中读取到尚未被消费的元素，直到没有可读的元素为止，才真正会变成closed状态。没数据后，如果再读就会得到元素类型的零值了, 对于没数据且closed状态的channel，for range会终止。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1650013753,"ip_address":"","comment_id":342010,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请问计数信号量的例子中，因为jobs的容量是10，这里执行的循环不会导致阻塞，close(jobs) 应该会被执行到，那么下面的for range为什么不会终止，而可以继续运行？\ngo func() {\n\t\tfor i := 0; i &lt; 8; i++ {\n\t\t\tjobs &lt;- (i + 1)\n\t\t}\n\t\tclose(jobs) \n\t}()","like_count":24,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":563515,"discussion_content":"好问题！\nchannel内部数据是排队的，即便被close，依然可以从closed channel中读取到尚未被消费的元素，直到没有可读的元素为止，才真正会变成closed状态。没数据后，如果再读就会得到元素类型的零值了, 对于没数据且closed状态的channel，for range会终止。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1650013753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":1357603,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b7/23/ea83d6eb.jpg","nickname":"-.-","note":"","ucode":"3CDC606BDFDD80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":622677,"discussion_content":"试了一下把close去掉，没有得到零值，而是报错：fatal error: all goroutines are asleep - deadlock! 这是为什么呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688538143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":563515,"ip_address":"北京","group_id":0},"score":622677,"extra":""},{"author":{"id":1149221,"avatar":"https://static001.geekbang.org/account/avatar/00/11/89/25/02f1b5ec.jpg","nickname":"柳丁烧麦","note":"","ucode":"87F3F998277970","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1357603,"avatar":"https://static001.geekbang.org/account/avatar/00/14/b7/23/ea83d6eb.jpg","nickname":"-.-","note":"","ucode":"3CDC606BDFDD80","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":626250,"discussion_content":"没有close，for j := range jobs 在接收完jobs中所有数据后进入阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692690394,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":622677,"ip_address":"中国香港","group_id":0},"score":626250,"extra":""}]},{"author":{"id":1650378,"avatar":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","nickname":"菠萝吹雪—Code","note":"","ucode":"A5B2FC661EE17D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587015,"discussion_content":"疑问解决了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1662687191,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"河南","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1805408,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/8c/60/58b6c39e.jpg","nickname":"zzy","note":"","ucode":"3D7EC623EB8204","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582107,"discussion_content":"正想提出这疑问的，发现已有解答了^_^","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1659237398,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":3794407,"avatar":"","nickname":"Geek_3d0fe8","note":"","ucode":"E75EACDA00E7A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":638869,"discussion_content":"关闭的channel还是能读出来元素的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1710050831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"广东","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335115,"user_name":"张申傲","can_delete":false,"product_type":"c1","uid":1182372,"ip_address":"","ucode":"22D46BC529BA8A","user_header":"https://static001.geekbang.org/account/avatar/00/12/0a/a4/828a431f.jpg","comment_is_top":false,"comment_ctime":1645341970,"is_pvip":false,"replies":[{"id":122607,"content":"channel一旦没有人引用了，就会被gc掉，不关闭也ok。但是如果有goroutine一直在读channel，那么channel一直存在，不会关闭。直到程序退出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1645604443,"ip_address":"","comment_id":335115,"utype":1}],"discussion_count":1,"race_medal":2,"score":2,"product_id":100093501,"comment_content":"这节课信息量有点大，需要多看几遍好好消化。请问老师一个问题：如果程序中没有手动 close channel，那么 channel 会在什么时候关闭呢？是否需要借助 defer 去释放 channel 资源呢？","like_count":13,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552819,"discussion_content":"channel一旦没有人引用了，就会被gc掉，不关闭也ok。但是如果有goroutine一直在读channel，那么channel一直存在，不会关闭。直到程序退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645604444,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330387,"user_name":"ibin","can_delete":false,"product_type":"c1","uid":2699840,"ip_address":"","ucode":"766942C36B8E27","user_header":"https://static001.geekbang.org/account/avatar/00/29/32/40/d56f476c.jpg","comment_is_top":false,"comment_ctime":1641961680,"is_pvip":false,"replies":[{"id":121540,"content":"close一个channel后，所有阻塞在这个channel接收操作的goroutine都会收到通知，这是Go语言的channel语义就这么定义的。","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1643442687,"ip_address":"","comment_id":330387,"utype":1}],"discussion_count":4,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"白老师，你好，下面这段可以模拟close(groupSignal)\nfor i := 0;i &lt; 5; i++ {\n\t\tgroupSignal&lt;-signal(struct{}{})\n}\n为什么close(groupSignal) 可以给每个groupSignal都发送了{}","like_count":10,"discussions":[{"author":{"id":2903068,"avatar":"","nickname":"Geek_05d654","note":"","ucode":"D10FB87A0A62A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":564562,"discussion_content":"close一个channel后，由于关闭的channel被读取不会阻塞，会返回零值，所有阻塞读该channel 的 goroutine 都可以读到零值，不再阻塞，继续执行后面的逻辑；建议可以看看 context 源码，里面的父级取消就是这么通知的","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1650279088,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1045910,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f5/96/0cf9f3c7.jpg","nickname":"Aeins","note":"","ucode":"D5BF220767541D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":574468,"discussion_content":"1. channel 关闭后将不再阻塞\n2. 从关闭的 channel 读数据，将返回 channel 元素类型的零值","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1654072438,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548904,"discussion_content":"close一个channel后，所有阻塞在这个channel接收操作的goroutine都会收到通知，这是Go语言的channel语义就这么定义的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1643442687,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1351076,"avatar":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","nickname":"lesserror","note":"","ucode":"25A54D1165FCF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546568,"discussion_content":"我的理解是这5个Goroutine都从groupSignal 这个channel中接收数据（&lt;-groupSignal），而close(groupSignal) 关闭groupSignal 这个channel后，5个Goroutine此时不在阻塞在接收操作那一行了，开始往下执行。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642340627,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":338582,"user_name":"木木","can_delete":false,"product_type":"c1","uid":2704565,"ip_address":"","ucode":"86820F26A27308","user_header":"https://static001.geekbang.org/account/avatar/00/29/44/b5/7eba5a0e.jpg","comment_is_top":false,"comment_ctime":1647576224,"is_pvip":false,"replies":[{"id":123861,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1647812431,"ip_address":"","comment_id":338582,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"go的并发原语选择真的是非常精炼：简洁又强大，一个ch就负责了线程通信、同步的多种功能；一个select又实现了对阻塞、非阻塞的控制以及事件循环模式。","like_count":8,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557438,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647812431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":346081,"user_name":"airmy丶","can_delete":false,"product_type":"c1","uid":1299673,"ip_address":"","ucode":"41959C9F5B4B65","user_header":"https://static001.geekbang.org/account/avatar/00/13/d4/d9/c3296187.jpg","comment_is_top":false,"comment_ctime":1652806046,"is_pvip":false,"replies":[{"id":126373,"content":"Wait方法的语义就是等待例子中for循环创建的所有子goroutine，直到每个子goroutine都调用完wg.Done才返回。如果不再一个新goroutine执行，wg.Wait就会阻塞住main goroutine，这也将导致后续所有goroutine都阻塞住，然后go运行时检测到所有goroutine都阻塞住了，于是报错退出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1653057488,"ip_address":"","comment_id":346081,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"请问下老师: 为什么 &quot;1 对 n 的信号通知机制&quot; 这个例子中，wg.Wait() 一定需要新起一个协程执行呢？而且在本地测试确实只能在新的协程中执行才不会报错，否则会报出: goroutine x [chan receive] 这样的错误。","like_count":6,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557438,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647812431,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342776,"user_name":"瓜牛","can_delete":false,"product_type":"c1","uid":2273620,"ip_address":"","ucode":"5EB7D2F4400A70","user_header":"https://static001.geekbang.org/account/avatar/00/22/b1/54/6d663b95.jpg","comment_is_top":false,"comment_ctime":1650456796,"is_pvip":false,"replies":[{"id":125291,"content":"首先明确一点:channel如果不close，也不会存在资源泄露的问题。\n\n是否需要close channel完全看需要。\n\n至于如何知道何时需要，看文中对close channel的语义的描述，以及如何基于这种语义的一些妙用。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1650596976,"ip_address":"","comment_id":342776,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"为啥有时需要手动调用close关闭channel，有时又不需要？","like_count":5,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566085,"discussion_content":"首先明确一点:channel如果不close，也不会存在资源泄露的问题。\n\n是否需要close channel完全看需要。\n\n至于如何知道何时需要，看文中对close channel的语义的描述，以及如何基于这种语义的一些妙用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650596976,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1110662,"avatar":"https://static001.geekbang.org/account/avatar/00/10/f2/86/d689f77e.jpg","nickname":"Hank_Yan","note":"","ucode":"86899B561C502B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":592054,"discussion_content":"不close的，都return到主goroutine里面了。程序结束就没了。\n另外，老师也在其他留言回答了，没有引用会gc掉，不用担心。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1667049540,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369863,"user_name":"怎么睡才能做这种梦","can_delete":false,"product_type":"c1","uid":3050745,"ip_address":"湖北","ucode":"81A7B6EF124E90","user_header":"https://static001.geekbang.org/account/avatar/00/2e/8c/f9/e1dab0ca.jpg","comment_is_top":false,"comment_ctime":1678071770,"is_pvip":false,"replies":[{"id":134824,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1678092714,"ip_address":"北京","comment_id":369863,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"另外，select 语句中，如果有多个 case 同时都没有阻塞的话，会随机选择一个 case ","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607693,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678092715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":362821,"user_name":"Unknown element","can_delete":false,"product_type":"c1","uid":2028277,"ip_address":"北京","ucode":"34A129800D0238","user_header":"https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg","comment_is_top":false,"comment_ctime":1668937522,"is_pvip":false,"replies":[{"id":131966,"content":"如果channel中的元素大小为0，那就不需要额外分配缓存(buf)；\n如果元素类型中不含有指针，那么buf就和hchan一起分配(将来也和hchan一起释放)，减少一次heap mem分配。GC只扫描hchan就ok了。\n如果元素类型包含指针，那么hchan和hchan.buf单独分配内存，GC分别扫描hchan和buf中的元素。\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669019963,"ip_address":"北京","comment_id":362821,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"老师我看makechan的源码发现分配内存的时候分了3种情况：\n1. 缓冲区大小=0 \n2. 元素类型不是指针 \n3. 元素类型包含指针\n我想问下为什么2和3要分成两种情况呢？我看区别好像是调用 mallocgc 时第二个参数不一样，但是mallocgc 的源码我就看不懂了。。。希望老师可以简单解释下 谢谢老师~","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":607693,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678092715,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351916,"user_name":"每天晒白牙","can_delete":false,"product_type":"c1","uid":1004698,"ip_address":"","ucode":"A1B102CD933DEA","user_header":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","comment_is_top":false,"comment_ctime":1658289810,"is_pvip":false,"replies":[{"id":128099,"content":"由于箭头都是向左的，即&lt;-，所以我区分只发送和只接收型的channel的tip是以 chan这个关键字为中心，将chan关键字看成一个“管子”。当&lt;-在chan的右边，即chan &lt;- 好似向管子里写，这样就是只发送型。当&lt;-在chan的左边，即&lt;- chan ，好似从管子里取，这样就是只接收型。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1658402093,"ip_address":"","comment_id":351916,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"感觉只发送channel和只接收channel类型定义符号，交换一下更好理解，也更形象吧\n\nmake(chan&lt;- int, 1) 这个代表只接收\nmake(&lt;-chan int, 1) 这个代表只发送","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594375,"discussion_content":"如果channel中的元素大小为0，那就不需要额外分配缓存(buf)；\n如果元素类型中不含有指针，那么buf就和hchan一起分配(将来也和hchan一起释放)，减少一次heap mem分配。GC只扫描hchan就ok了。\n如果元素类型包含指针，那么hchan和hchan.buf单独分配内存，GC分别扫描hchan和buf中的元素。\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669019964,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330344,"user_name":"罗杰","can_delete":false,"product_type":"c1","uid":1320487,"ip_address":"","ucode":"96BAFAA147341F","user_header":"https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg","comment_is_top":false,"comment_ctime":1641939997,"is_pvip":false,"replies":[{"id":120549,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642050812,"ip_address":"","comment_id":330344,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100093501,"comment_content":"这节课比较绕，要静下心好好学习","like_count":4,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580916,"discussion_content":"由于箭头都是向左的，即&lt;-，所以我区分只发送和只接收型的channel的tip是以 chan这个关键字为中心，将chan关键字看成一个“管子”。当&lt;-在chan的右边，即chan &lt;- 好似向管子里写，这样就是只发送型。当&lt;-在chan的左边，即&lt;- chan ，好似从管子里取，这样就是只接收型。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658402093,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1004698,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg","nickname":"每天晒白牙","note":"","ucode":"A1B102CD933DEA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580624,"discussion_content":"理解错了\n只发送代表的是只能往channel中发送\n只接收代表的是只能从channel中接收\n所以还是很形象的，我理解错了","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1658299799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377236,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"广东","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1688110077,"is_pvip":false,"replies":[{"id":137491,"content":"1. “直到 channel 中有数据可接收或 channel 被关闭循环” -&gt; “直到 channel 中有数据可接收或 channel 被关闭”，稍后让编辑老师改一下。\n2. Goroutine安全：可以用在多个goroutine并发读写访问的场合，不会导致程序出错。\n3. 数据竞态：存在多个goroutine并发读写某块数据的情况。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1688286276,"ip_address":"辽宁","comment_id":377236,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"Tony bai 老师：\n\n1. 文中：“直到 channel 中有数据可接收或 channel 被关闭循环”，这里的 channel 被关闭循环该怎么理解呢？\n\n2. 文中的提到的“Goroutine 安全”，又该如何理解呢？\n\n3. 还有能不能通俗的解释一下“竞态” 这个概念呀？","like_count":2},{"had_liked":false,"id":370418,"user_name":"Geek_640f2c","can_delete":false,"product_type":"c1","uid":2110585,"ip_address":"北京","ucode":"176EEFFF27723A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfxYdHJ3NNnOzBFu2N6oNPXhfMRibh3nMjneJLN6WCfVStQKLaJNVehUDmcpsj1mIfFegiauToaxbQ/132","comment_is_top":false,"comment_ctime":1678798255,"is_pvip":false,"replies":[{"id":135118,"content":"goroutine-9: current counter value is 10\ngoroutine-5: current counter value is 5\ngoroutine-6: current counter value is 3\ngoroutine-4: current counter value is 4\ngoroutine-8: current counter value is 7\ngoroutine-7: current counter value is 6\ngoroutine-1: current counter value is 1\ngoroutine-3: current counter value is 8\ngoroutine-2: current counter value is 9\ngoroutine-0: current counter value is 2\n11\n\n是像这样的么？当10个goroutine执行完后，cter.i变成了11。如果你偶尔会输出10，那问题可能就是main goroutine与counter那个goroutine调度顺序上的问题了。\n\n先调度的main goroutine时，citer.i尚未来得及+1，输出10。否则输出11。不过我在go.dev&#47;play上执行若干次都是11。\n\nhttps:&#47;&#47;go.dev&#47;play&#47;p&#47;G-9krGOhfl7","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1678858631,"ip_address":"北京","comment_id":370418,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"白老师，请问您一个问题\n无缓冲的 channel 替代锁那一节，我在 main 的代码中最后输出了 cter.i，但输出结果有时是10，有时却是11，这是什么原因呢？\nmain代码如下：\nfunc main() {\n\tcter := NewCounter()\n\tvar wg sync.WaitGroup\n\tfor i := 0; i &lt; 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tcter.Increase()\n\t\t\tfmt.Printf(&quot;goroutine-%d: current counter value is %d\\n&quot;, i, v)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n\tprintln(cter.i)\n}","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622444,"discussion_content":"1. “直到 channel 中有数据可接收或 channel 被关闭循环” -&gt; “直到 channel 中有数据可接收或 channel 被关闭”，稍后让编辑老师改一下。\n2. Goroutine安全：可以用在多个goroutine并发读写访问的场合，不会导致程序出错。\n3. 数据竞态：存在多个goroutine并发读写某块数据的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688286276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369228,"user_name":"Ppppppp","can_delete":false,"product_type":"c1","uid":3294642,"ip_address":"江苏","ucode":"5AD679CC53B6D1","user_header":"https://static001.geekbang.org/account/avatar/00/32/45/b2/24dee83c.jpg","comment_is_top":false,"comment_ctime":1677246410,"is_pvip":false,"replies":[{"id":134613,"content":"pop效果？for range就是从channel逐一读取元素的一种“语法糖”，没有for range，只能如下方式写：\n\nfor {\n     v, ok := &lt;-c\n     if !ok {\n        break\n     }\n\n     &#47;&#47; do something with v\n}","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1677494918,"ip_address":"北京","comment_id":369228,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"for range对于channel会产生pop的效果吗？感觉好像跟对待slice和map不太一样。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609174,"discussion_content":"goroutine-9: current counter value is 10\ngoroutine-5: current counter value is 5\ngoroutine-6: current counter value is 3\ngoroutine-4: current counter value is 4\ngoroutine-8: current counter value is 7\ngoroutine-7: current counter value is 6\ngoroutine-1: current counter value is 1\ngoroutine-3: current counter value is 8\ngoroutine-2: current counter value is 9\ngoroutine-0: current counter value is 2\n11\n\n是像这样的么？当10个goroutine执行完后，cter.i变成了11。如果你偶尔会输出10，那问题可能就是main goroutine与counter那个goroutine调度顺序上的问题了。\n\n先调度的main goroutine时，citer.i尚未来得及+1，输出10。否则输出11。不过我在go.dev/play上执行若干次都是11。\n\nhttps://go.dev/play/p/G-9krGOhfl7","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678858631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368892,"user_name":"怎么睡才能做这种梦","can_delete":false,"product_type":"c1","uid":3050745,"ip_address":"湖北","ucode":"81A7B6EF124E90","user_header":"https://static001.geekbang.org/account/avatar/00/2e/8c/f9/e1dab0ca.jpg","comment_is_top":false,"comment_ctime":1676871485,"is_pvip":false,"replies":[{"id":134367,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1676959426,"ip_address":"北京","comment_id":368892,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"满满的干货呀，感谢白老，希望老师能出进阶专栏，我一定买","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606920,"discussion_content":"pop效果？for range就是从channel逐一读取元素的一种“语法糖”，没有for range，只能如下方式写：\n\nfor {\n     v, ok := &lt;-c\n     if !ok {\n        break\n     }\n\n     // do something with v\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677494918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363226,"user_name":"knightjdq","can_delete":false,"product_type":"c1","uid":1000390,"ip_address":"辽宁","ucode":"D5F9D6CA648259","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/c6/0ba36190.jpg","comment_is_top":false,"comment_ctime":1669376598,"is_pvip":false,"replies":[{"id":132081,"content":"这里仅是示例，NewCounter中新创建的goroutine(也就是你所说的“死循环”goroutine)的生命周期是在Newcounter中创建，随进程结束而结束的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669490782,"ip_address":"辽宁","comment_id":363226,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"白老师好：请教下用于替代锁机制中的代码，十分感谢!\nfunc NewCounter() *counter {\n\tcter := &amp;counter{\n\t\tc: make(chan int),\n\t}\n\tgo func() {\n\t\tfor {\n\t\t\tcter.i++\n\t\t\tcter.c &lt;- cter.i\n\t\t}\n\t}()\n\treturn cter\n}\n这里的死循环，i++写入channel后阻塞，Increase函数来读取，for循环到9后，不再读取，channel阻塞，那死循环的groutine呢？在counter对象销毁后就停止执行了是么？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606130,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676959426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351353,"user_name":"小虎","can_delete":false,"product_type":"c1","uid":1064304,"ip_address":"","ucode":"1B4CDE911C7B52","user_header":"https://static001.geekbang.org/account/avatar/00/10/3d/70/3d8aa6fc.jpg","comment_is_top":false,"comment_ctime":1657718168,"is_pvip":false,"replies":[{"id":127869,"content":"这个示例要共享的内存是“counter结构中的i”，而不是i的外围结构counter。cter.Increase是改变共享内存的方法，里面可以采用共享内存的方式，比如通过lock进行同步，也可以通过通信的方式，比如基于channel.","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1658018961,"ip_address":"","comment_id":351353,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"“无缓冲 channel 替代锁”这个示例说到“这种并发设计逻辑更符合 Go 语言所倡导的“不要通过共享内存来通信，而是通过通信来共享内存”的原则。”，没太想明白为什么符合这个原则，goroutine 中调用了cter.Increase()，这不是共享了cter这个变量吗？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580219,"discussion_content":"这个示例要共享的内存是“counter结构中的i”，而不是i的外围结构counter。cter.Increase是改变共享内存的方法，里面可以采用共享内存的方式，比如通过lock进行同步，也可以通过通信的方式，比如基于channel.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658018961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335036,"user_name":"郑泽洲","can_delete":false,"product_type":"c1","uid":1447496,"ip_address":"","ucode":"EA1B540A040875","user_header":"https://static001.geekbang.org/account/avatar/00/16/16/48/01567df1.jpg","comment_is_top":false,"comment_ctime":1645262849,"is_pvip":false,"replies":[{"id":122524,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1645539157,"ip_address":"","comment_id":335036,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"这节课需要反复读，举的例子和示例代码都非常好，值得深入思考，只要思考到位，对channel认识就能加深一步👍🏻","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580219,"discussion_content":"这个示例要共享的内存是“counter结构中的i”，而不是i的外围结构counter。cter.Increase是改变共享内存的方法，里面可以采用共享内存的方式，比如通过lock进行同步，也可以通过通信的方式，比如基于channel.","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658018961,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331552,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1642649800,"is_pvip":false,"replies":[{"id":121275,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642914817,"ip_address":"","comment_id":331552,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"太干了，看了几天才看完， 面面俱到了， 各种坑也指点出来了。\n收获非常大， 从瞎用channel，到现在 心里有底，知道该怎么用channel了。\n非常感谢老师，老师讲的太赞了。\n","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547861,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642914818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330985,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1642340019,"is_pvip":false,"replies":[{"id":121591,"content":"1. 👍\n2. 是的。main goroutine更关注&quot;worker&quot; goroutine的状态，所以只等待了worker goroutine的退出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643524797,"ip_address":"","comment_id":330985,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"channel是Go并发设计的核心之一，要反复阅读理解。大白老师这里总结的很不错。有以下疑问，麻烦解答。\n\n1. 无缓冲 channel 的惯用法 -&gt; 第一种用法：用作信号传递 。下面的示例代码： c &lt;- signal(struct{}{}) 改成 c &lt;- signal{}  会不会更好一些呢？\n\n2. 无缓冲channel替代锁那里。计数器操作全部交给一个独立的 Goroutine 去处理。我的理解是这个Goroutine 其实最后还是处于阻塞的状态下。最后主 Goroutine 结束运行了。这个Goroutine 不得不退出了，这么理解对吗？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549033,"discussion_content":"1. 👍\n2. 是的。main goroutine更关注&#34;worker&#34; goroutine的状态，所以只等待了worker goroutine的退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643524797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330622,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1642073143,"is_pvip":false,"replies":[{"id":121580,"content":"trySend或tryRecv有两个分支，当返回False时，说明channel满或channel为空。但另外一个执行分支可能会修改channel，即向channel中成功发送一个元素或从channel中成功读取一个元素。文中接着也提到“有些时候我们不想这么做，我们想在不改变 channel 状态的前提下，单纯地侦测 channel 的状态，而又不会因 channel 满或空阻塞在 channel 上”。但trySend和tryRecv不能完全满足这种需求。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643520930,"ip_address":"","comment_id":330622,"utype":1}],"discussion_count":5,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"请教下，文章中说到“select 这种判空或判满的方法适用于大多数场合，但是这种方法有一个“问题”，那就是它改变了 channel 的状态，会让 channel 接收了一个元素或发送一个元素到 channel。”，怎样理解这句话？为什么“会让 channel 接收了一个元素或发送一个元素到 channel”呢？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549033,"discussion_content":"1. 👍\n2. 是的。main goroutine更关注&#34;worker&#34; goroutine的状态，所以只等待了worker goroutine的退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643524797,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":377236,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"广东","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1688110077,"is_pvip":false,"replies":[{"id":137491,"content":"1. “直到 channel 中有数据可接收或 channel 被关闭循环” -&gt; “直到 channel 中有数据可接收或 channel 被关闭”，稍后让编辑老师改一下。\n2. Goroutine安全：可以用在多个goroutine并发读写访问的场合，不会导致程序出错。\n3. 数据竞态：存在多个goroutine并发读写某块数据的情况。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1688286276,"ip_address":"辽宁","comment_id":377236,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"Tony bai 老师：\n\n1. 文中：“直到 channel 中有数据可接收或 channel 被关闭循环”，这里的 channel 被关闭循环该怎么理解呢？\n\n2. 文中的提到的“Goroutine 安全”，又该如何理解呢？\n\n3. 还有能不能通俗的解释一下“竞态” 这个概念呀？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":622444,"discussion_content":"1. “直到 channel 中有数据可接收或 channel 被关闭循环” -&gt; “直到 channel 中有数据可接收或 channel 被关闭”，稍后让编辑老师改一下。\n2. Goroutine安全：可以用在多个goroutine并发读写访问的场合，不会导致程序出错。\n3. 数据竞态：存在多个goroutine并发读写某块数据的情况。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1688286276,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":370418,"user_name":"Geek_640f2c","can_delete":false,"product_type":"c1","uid":2110585,"ip_address":"北京","ucode":"176EEFFF27723A","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKfxYdHJ3NNnOzBFu2N6oNPXhfMRibh3nMjneJLN6WCfVStQKLaJNVehUDmcpsj1mIfFegiauToaxbQ/132","comment_is_top":false,"comment_ctime":1678798255,"is_pvip":false,"replies":[{"id":135118,"content":"goroutine-9: current counter value is 10\ngoroutine-5: current counter value is 5\ngoroutine-6: current counter value is 3\ngoroutine-4: current counter value is 4\ngoroutine-8: current counter value is 7\ngoroutine-7: current counter value is 6\ngoroutine-1: current counter value is 1\ngoroutine-3: current counter value is 8\ngoroutine-2: current counter value is 9\ngoroutine-0: current counter value is 2\n11\n\n是像这样的么？当10个goroutine执行完后，cter.i变成了11。如果你偶尔会输出10，那问题可能就是main goroutine与counter那个goroutine调度顺序上的问题了。\n\n先调度的main goroutine时，citer.i尚未来得及+1，输出10。否则输出11。不过我在go.dev&#47;play上执行若干次都是11。\n\nhttps:&#47;&#47;go.dev&#47;play&#47;p&#47;G-9krGOhfl7","user_name":"作者回复","user_name_real":"作者","uid":1026224,"ctime":1678858631,"ip_address":"北京","comment_id":370418,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"白老师，请问您一个问题\n无缓冲的 channel 替代锁那一节，我在 main 的代码中最后输出了 cter.i，但输出结果有时是10，有时却是11，这是什么原因呢？\nmain代码如下：\nfunc main() {\n\tcter := NewCounter()\n\tvar wg sync.WaitGroup\n\tfor i := 0; i &lt; 10; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tcter.Increase()\n\t\t\tfmt.Printf(&quot;goroutine-%d: current counter value is %d\\n&quot;, i, v)\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\twg.Wait()\n\tprintln(cter.i)\n}","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":609174,"discussion_content":"goroutine-9: current counter value is 10\ngoroutine-5: current counter value is 5\ngoroutine-6: current counter value is 3\ngoroutine-4: current counter value is 4\ngoroutine-8: current counter value is 7\ngoroutine-7: current counter value is 6\ngoroutine-1: current counter value is 1\ngoroutine-3: current counter value is 8\ngoroutine-2: current counter value is 9\ngoroutine-0: current counter value is 2\n11\n\n是像这样的么？当10个goroutine执行完后，cter.i变成了11。如果你偶尔会输出10，那问题可能就是main goroutine与counter那个goroutine调度顺序上的问题了。\n\n先调度的main goroutine时，citer.i尚未来得及+1，输出10。否则输出11。不过我在go.dev/play上执行若干次都是11。\n\nhttps://go.dev/play/p/G-9krGOhfl7","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1678858631,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":369228,"user_name":"Ppppppp","can_delete":false,"product_type":"c1","uid":3294642,"ip_address":"江苏","ucode":"5AD679CC53B6D1","user_header":"https://static001.geekbang.org/account/avatar/00/32/45/b2/24dee83c.jpg","comment_is_top":false,"comment_ctime":1677246410,"is_pvip":false,"replies":[{"id":134613,"content":"pop效果？for range就是从channel逐一读取元素的一种“语法糖”，没有for range，只能如下方式写：\n\nfor {\n     v, ok := &lt;-c\n     if !ok {\n        break\n     }\n\n     &#47;&#47; do something with v\n}","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1677494918,"ip_address":"北京","comment_id":369228,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"for range对于channel会产生pop的效果吗？感觉好像跟对待slice和map不太一样。","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606920,"discussion_content":"pop效果？for range就是从channel逐一读取元素的一种“语法糖”，没有for range，只能如下方式写：\n\nfor {\n     v, ok := &lt;-c\n     if !ok {\n        break\n     }\n\n     // do something with v\n}","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1677494918,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":368892,"user_name":"怎么睡才能做这种梦","can_delete":false,"product_type":"c1","uid":3050745,"ip_address":"湖北","ucode":"81A7B6EF124E90","user_header":"https://static001.geekbang.org/account/avatar/00/2e/8c/f9/e1dab0ca.jpg","comment_is_top":false,"comment_ctime":1676871485,"is_pvip":false,"replies":[{"id":134367,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1676959426,"ip_address":"北京","comment_id":368892,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"满满的干货呀，感谢白老，希望老师能出进阶专栏，我一定买","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":606130,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676959426,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":363226,"user_name":"knightjdq","can_delete":false,"product_type":"c1","uid":1000390,"ip_address":"辽宁","ucode":"D5F9D6CA648259","user_header":"https://static001.geekbang.org/account/avatar/00/0f/43/c6/0ba36190.jpg","comment_is_top":false,"comment_ctime":1669376598,"is_pvip":false,"replies":[{"id":132081,"content":"这里仅是示例，NewCounter中新创建的goroutine(也就是你所说的“死循环”goroutine)的生命周期是在Newcounter中创建，随进程结束而结束的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1669490782,"ip_address":"辽宁","comment_id":363226,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"白老师好：请教下用于替代锁机制中的代码，十分感谢!\nfunc NewCounter() *counter {\n\tcter := &amp;counter{\n\t\tc: make(chan int),\n\t}\n\tgo func() {\n\t\tfor {\n\t\t\tcter.i++\n\t\t\tcter.c &lt;- cter.i\n\t\t}\n\t}()\n\treturn cter\n}\n这里的死循环，i++写入channel后阻塞，Increase函数来读取，for循环到9后，不再读取，channel阻塞，那死循环的groutine呢？在counter对象销毁后就停止执行了是么？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594863,"discussion_content":"这里仅是示例，NewCounter中新创建的goroutine(也就是你所说的“死循环”goroutine)的生命周期是在Newcounter中创建，随进程结束而结束的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669490782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351353,"user_name":"小虎","can_delete":false,"product_type":"c1","uid":1064304,"ip_address":"","ucode":"1B4CDE911C7B52","user_header":"https://static001.geekbang.org/account/avatar/00/10/3d/70/3d8aa6fc.jpg","comment_is_top":false,"comment_ctime":1657718168,"is_pvip":false,"replies":[{"id":127869,"content":"这个示例要共享的内存是“counter结构中的i”，而不是i的外围结构counter。cter.Increase是改变共享内存的方法，里面可以采用共享内存的方式，比如通过lock进行同步，也可以通过通信的方式，比如基于channel.","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1658018961,"ip_address":"","comment_id":351353,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"“无缓冲 channel 替代锁”这个示例说到“这种并发设计逻辑更符合 Go 语言所倡导的“不要通过共享内存来通信，而是通过通信来共享内存”的原则。”，没太想明白为什么符合这个原则，goroutine 中调用了cter.Increase()，这不是共享了cter这个变量吗？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":594863,"discussion_content":"这里仅是示例，NewCounter中新创建的goroutine(也就是你所说的“死循环”goroutine)的生命周期是在Newcounter中创建，随进程结束而结束的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1669490782,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":335036,"user_name":"郑泽洲","can_delete":false,"product_type":"c1","uid":1447496,"ip_address":"","ucode":"EA1B540A040875","user_header":"https://static001.geekbang.org/account/avatar/00/16/16/48/01567df1.jpg","comment_is_top":false,"comment_ctime":1645262849,"is_pvip":false,"replies":[{"id":122524,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1645539157,"ip_address":"","comment_id":335036,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"这节课需要反复读，举的例子和示例代码都非常好，值得深入思考，只要思考到位，对channel认识就能加深一步👍🏻","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552658,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645539157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":331552,"user_name":"return","can_delete":false,"product_type":"c1","uid":1135528,"ip_address":"","ucode":"42B8A3380DF04B","user_header":"https://static001.geekbang.org/account/avatar/00/11/53/a8/abc96f70.jpg","comment_is_top":false,"comment_ctime":1642649800,"is_pvip":false,"replies":[{"id":121275,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642914817,"ip_address":"","comment_id":331552,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"太干了，看了几天才看完， 面面俱到了， 各种坑也指点出来了。\n收获非常大， 从瞎用channel，到现在 心里有底，知道该怎么用channel了。\n非常感谢老师，老师讲的太赞了。\n","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552658,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645539157,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330985,"user_name":"lesserror","can_delete":false,"product_type":"c1","uid":1351076,"ip_address":"","ucode":"25A54D1165FCF6","user_header":"https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg","comment_is_top":false,"comment_ctime":1642340019,"is_pvip":false,"replies":[{"id":121591,"content":"1. 👍\n2. 是的。main goroutine更关注&quot;worker&quot; goroutine的状态，所以只等待了worker goroutine的退出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643524797,"ip_address":"","comment_id":330985,"utype":1}],"discussion_count":1,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"channel是Go并发设计的核心之一，要反复阅读理解。大白老师这里总结的很不错。有以下疑问，麻烦解答。\n\n1. 无缓冲 channel 的惯用法 -&gt; 第一种用法：用作信号传递 。下面的示例代码： c &lt;- signal(struct{}{}) 改成 c &lt;- signal{}  会不会更好一些呢？\n\n2. 无缓冲channel替代锁那里。计数器操作全部交给一个独立的 Goroutine 去处理。我的理解是这个Goroutine 其实最后还是处于阻塞的状态下。最后主 Goroutine 结束运行了。这个Goroutine 不得不退出了，这么理解对吗？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":547861,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642914818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330622,"user_name":"Calvin","can_delete":false,"product_type":"c1","uid":1603004,"ip_address":"","ucode":"0EEF5B207623B5","user_header":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","comment_is_top":false,"comment_ctime":1642073143,"is_pvip":false,"replies":[{"id":121580,"content":"trySend或tryRecv有两个分支，当返回False时，说明channel满或channel为空。但另外一个执行分支可能会修改channel，即向channel中成功发送一个元素或从channel中成功读取一个元素。文中接着也提到“有些时候我们不想这么做，我们想在不改变 channel 状态的前提下，单纯地侦测 channel 的状态，而又不会因 channel 满或空阻塞在 channel 上”。但trySend和tryRecv不能完全满足这种需求。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643520930,"ip_address":"","comment_id":330622,"utype":1}],"discussion_count":5,"race_medal":0,"score":3,"product_id":100093501,"comment_content":"请教下，文章中说到“select 这种判空或判满的方法适用于大多数场合，但是这种方法有一个“问题”，那就是它改变了 channel 的状态，会让 channel 接收了一个元素或发送一个元素到 channel。”，怎样理解这句话？为什么“会让 channel 接收了一个元素或发送一个元素到 channel”呢？","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549021,"discussion_content":"trySend或tryRecv有两个分支，当返回False时，说明channel满或channel为空。但另外一个执行分支可能会修改channel，即向channel中成功发送一个元素或从channel中成功读取一个元素。文中接着也提到“有些时候我们不想这么做，我们想在不改变 channel 状态的前提下，单纯地侦测 channel 的状态，而又不会因 channel 满或空阻塞在 channel 上”。但trySend和tryRecv不能完全满足这种需求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643520930,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546006,"discussion_content":"这段话的意思是为了引出这里的下一段话，这里的场景必须在channel上收发数据，不然无法做到判空","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642127421,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546112,"discussion_content":"不发送或者接收元素，直接让它走到default不就行了吗？为什么说一定会让channel接收了一个元素或发送了一个元素到channel？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642162872,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546006,"ip_address":"","group_id":0},"score":546112,"extra":""},{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546117,"discussion_content":"拿trySend举例，走default是表示channel里满了，是select自动选择的而不是我让它走default，利用这种机制实现判满，一旦seelct选了发送数据就是表示channel未满，此时判断出了channel未满并且发送数据构成了一个“事务”","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642165253,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546112,"ip_address":"","group_id":0},"score":546117,"extra":""},{"author":{"id":1603004,"avatar":"https://static001.geekbang.org/account/avatar/00/18/75/bc/89d88775.jpg","nickname":"Calvin","note":"","ucode":"0EEF5B207623B5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546162,"discussion_content":"谢谢，有点明了了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642184226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546117,"ip_address":"","group_id":0},"score":546162,"extra":""}]}]},{"had_liked":false,"id":330368,"user_name":"0mfg","can_delete":false,"product_type":"c1","uid":1393948,"ip_address":"","ucode":"D83530DB25D25A","user_header":"","comment_is_top":false,"comment_ctime":1641954001,"is_pvip":false,"replies":[{"id":120547,"content":"main goroutine在执行ch &lt;-13时就阻塞住了。还没执行到创建下面那个goroutine呢。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642050772,"ip_address":"","comment_id":330368,"utype":1}],"discussion_count":5,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"白老师好，请教个问题。对于无缓冲通道的结论，“对无缓冲 channel 类型的发送与接收操作，一定要放在两个不同的 Goroutine 中进行，否则会导致 deadlock。” 尝试了如下写法，发送在主goroutine，接收在新goroutine发现还是deadlock，请问具体原因是啥？谢谢\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main()  {\n\tch := make(chan int)\n\tch &lt;- 13\n\tgo func() {\n\t\tn := &lt;- ch\n\t\tfmt.Println(n)\n\t}()\n}","like_count":2},{"had_liked":false,"id":374128,"user_name":"天天有吃的","can_delete":false,"product_type":"c1","uid":1604355,"ip_address":"广东","ucode":"6267FE8E68DEE5","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/03/03583011.jpg","comment_is_top":false,"comment_ctime":1683623852,"is_pvip":false,"replies":[{"id":136657,"content":"别气馁，多看几遍💪。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1683711314,"ip_address":"北京","comment_id":374128,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"直接看，确实有点看不懂...","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617617,"discussion_content":"别气馁，多看几遍💪。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683711314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373520,"user_name":"陈鹤","can_delete":false,"product_type":"c1","uid":1962657,"ip_address":"上海","ucode":"08E781342831CE","user_header":"","comment_is_top":false,"comment_ctime":1682594959,"is_pvip":false,"replies":[{"id":136420,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1682651578,"ip_address":"北京","comment_id":373520,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"这节课信息量巨大，被各种应用场景的奇思妙想震惊到了！个人觉得是本教程偏向应用最重要的一个章节，示例丰富，可以直接当模板应用，常看常新！","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616226,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682651578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364397,"user_name":"momo","can_delete":false,"product_type":"c1","uid":2201076,"ip_address":"辽宁","ucode":"7567CCCB0547E1","user_header":"https://static001.geekbang.org/account/avatar/00/21/95/f4/06442207.jpg","comment_is_top":false,"comment_ctime":1670922910,"is_pvip":false,"replies":[{"id":132519,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1671141097,"ip_address":"辽宁","comment_id":364397,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"狂赞","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596622,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671141097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358030,"user_name":"fengruichao","can_delete":false,"product_type":"c1","uid":1060405,"ip_address":"辽宁","ucode":"B41431137A585C","user_header":"https://static001.geekbang.org/account/avatar/00/10/2e/35/c12029fd.jpg","comment_is_top":false,"comment_ctime":1663837377,"is_pvip":false,"replies":[{"id":130367,"content":"ch1 &lt;- 1这一行将整个程序阻塞住了，下面的goroutine根本就没有得到创建的机会。go runtime检测到没有可以运行的用户goroutine了，所以报错！","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1664113286,"ip_address":"辽宁","comment_id":358030,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"func test1() {\n\tch1 := make(chan int)\n\tch1 &lt;- 1\n\tgo func() {\n\t\tfmt.Println(&lt;-ch1)\n\t}()\n}\n\n为什么把接收操作放在Goroutine会报fatal error: all goroutines are asleep - deadlock!,而把发送操作放到Goroutine中就不会报错","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588792,"discussion_content":"ch1 &lt;- 1这一行将整个程序阻塞住了，下面的goroutine根本就没有得到创建的机会。go runtime检测到没有可以运行的用户goroutine了，所以报错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664113286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357586,"user_name":"Jay","can_delete":false,"product_type":"c1","uid":1070670,"ip_address":"北京","ucode":"ED9970F7E66080","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/4e/9291fac0.jpg","comment_is_top":false,"comment_ctime":1663425285,"is_pvip":false,"replies":[{"id":130232,"content":"select会等待啊。但如果没有外面的for循环，只会等待一次啊。然后就继续向下执行，就退出worker函数了。这里代码的目的就是循环定时等待。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1663641031,"ip_address":"北京","comment_id":357586,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"\nfunc worker() {\n  heartbeat := time.NewTicker(30 * time.Second)\n  defer heartbeat.Stop()\n  for {\n    select {\n    case &lt;-c:\n      &#47;&#47; ... do some stuff\n    case &lt;- heartbeat.C:\n      &#47;&#47;... do heartbeat stuff\n    }\n  }\n}\n\n老师，最后这段代码我没太明白，select如果没有default的话，不可发送和不可接受都会处于阻塞，状态，select本身不是会一直等待吗（select本身看起来像是个循环等待啊），外面的for循环有什么意义呢","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588271,"discussion_content":"select会等待啊。但如果没有外面的for循环，只会等待一次啊。然后就继续向下执行，就退出worker函数了。这里代码的目的就是循环定时等待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663641031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357236,"user_name":"Jack Xin","can_delete":false,"product_type":"c1","uid":1425444,"ip_address":"北京","ucode":"BEC98A1F437239","user_header":"https://static001.geekbang.org/account/avatar/00/15/c0/24/01699070.jpg","comment_is_top":false,"comment_ctime":1663081403,"is_pvip":false,"replies":[{"id":130027,"content":"你是说 输出的顺序和文章中不一致。\n\n这个没问题。这个例子演示的是如何基于channel实现计数器，保证每个goroutine拿到的计数值都是不同的。输出顺序与goroutine调度顺序有关。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1663136463,"ip_address":"北京","comment_id":357236,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"白老师，想问您一个问题，关于无缓冲chan 的第二种用法：替换锁机制。我复制里面的例子在我的Mac上运行得到的是下面的结果，跟您的不一样，不是v=i+1的关系，想了半天也不知道为什么，我用的1.18版本的go，\ngoroutine-0: current counter value is 1\ngoroutine-1: current counter value is 9\ngoroutine-9: current counter value is 3\ngoroutine-5: current counter value is 4\ngoroutine-6: current counter value is 5\ngoroutine-7: current counter value is 6\ngoroutine-8: current counter value is 7\ngoroutine-2: current counter value is 8\ngoroutine-4: current counter value is 2\ngoroutine-3: current counter value is 10","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587540,"discussion_content":"你是说 输出的顺序和文章中不一致。\n\n这个没问题。这个例子演示的是如何基于channel实现计数器，保证每个goroutine拿到的计数值都是不同的。输出顺序与goroutine调度顺序有关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663136463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356891,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"北京","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1662687305,"is_pvip":false,"replies":[{"id":129885,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1662701488,"ip_address":"北京","comment_id":356891,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"这节课解决了我很多疑惑，代码自己敲了一遍，一行一行分析，有感觉了。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587032,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662701488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353175,"user_name":"zzy","can_delete":false,"product_type":"c1","uid":1805408,"ip_address":"北京","ucode":"3D7EC623EB8204","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8c/60/58b6c39e.jpg","comment_is_top":false,"comment_ctime":1659236128,"is_pvip":false,"replies":[{"id":128456,"content":"1对n的信号通知使用的是channel的关闭机制。close groupSignal后，所有处于从groupSignal recv的goroutine都会从对groupSignal的recv中返回。不会阻塞。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1659403584,"ip_address":"北京","comment_id":353175,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"在 1 对 n 的信号通知 的代码中，并没有看到向groupSingal中发送值，接收端不是应该一直阻塞吗？感觉没法走下去","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582340,"discussion_content":"1对n的信号通知使用的是channel的关闭机制。close groupSignal后，所有处于从groupSignal recv的goroutine都会从对groupSignal的recv中返回。不会阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659403585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351804,"user_name":"fgr_SHU","can_delete":false,"product_type":"c1","uid":1664919,"ip_address":"","ucode":"67A391AE754CBF","user_header":"https://static001.geekbang.org/account/avatar/00/19/67/97/96e3f59b.jpg","comment_is_top":false,"comment_ctime":1658201604,"is_pvip":false,"replies":[{"id":128096,"content":"不确定，具有随机性。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1658401686,"ip_address":"","comment_id":351804,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"2s 后，ch2 被写入了一个数值 7。这样在某一轮 select 的过程中，分支case x := &lt;-ch2被选中得以执行，程序输出 7 之后满足退出条件，于是程序终止\n\n具体是哪一轮呢？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":580913,"discussion_content":"不确定，具有随机性。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1658401686,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330368,"user_name":"0mfg","can_delete":false,"product_type":"c1","uid":1393948,"ip_address":"","ucode":"D83530DB25D25A","user_header":"","comment_is_top":false,"comment_ctime":1641954001,"is_pvip":false,"replies":[{"id":120547,"content":"main goroutine在执行ch &lt;-13时就阻塞住了。还没执行到创建下面那个goroutine呢。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642050772,"ip_address":"","comment_id":330368,"utype":1}],"discussion_count":5,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"白老师好，请教个问题。对于无缓冲通道的结论，“对无缓冲 channel 类型的发送与接收操作，一定要放在两个不同的 Goroutine 中进行，否则会导致 deadlock。” 尝试了如下写法，发送在主goroutine，接收在新goroutine发现还是deadlock，请问具体原因是啥？谢谢\n\npackage main\n\nimport &quot;fmt&quot;\n\nfunc main()  {\n\tch := make(chan int)\n\tch &lt;- 13\n\tgo func() {\n\t\tn := &lt;- ch\n\t\tfmt.Println(n)\n\t}()\n}","like_count":2,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545790,"discussion_content":"main goroutine在执行ch &lt;-13时就阻塞住了。还没执行到创建下面那个goroutine呢。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642050772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1393948,"avatar":"","nickname":"0mfg","note":"","ucode":"D83530DB25D25A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545799,"discussion_content":"谢谢白老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642053388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545790,"ip_address":"","group_id":0},"score":545799,"extra":""}]},{"author":{"id":2699840,"avatar":"https://static001.geekbang.org/account/avatar/00/29/32/40/d56f476c.jpg","nickname":"ibin","note":"","ucode":"766942C36B8E27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545444,"discussion_content":"13发送给ch 已经阻塞了，不会向下运行了吧。。将go func 提到上面，并且在main最后加上time.Sleep 就可以，，，","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641959225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604314,"discussion_content":"```\npackage main\n\nimport (\n\t&#34;fmt&#34;\n)\n\nfunc main() {\n\tch := make(chan int)\n\tgo func() {\n\t\tfmt.Println(&#34;=&gt; func()&#34;)\n\t\tn := &lt;-ch\n\t\tfmt.Println(n)\n\t\tfmt.Println(&#34;&lt;- func()&#34;)\n\t}()\n\tfmt.Println(&#34;=&gt; ch &lt;- 13&#34;)\n\tch &lt;- 13\n\tfmt.Println(&#34;&lt;- ch &lt;- 13&#34;)\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676360143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501818,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ea/7a/d857723d.jpg","nickname":"Vfeelit","note":"","ucode":"F3FF2B069F347F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555087,"discussion_content":"13入 主协程堵塞 这个时候只有一个协程并且堵塞了 那就算死锁了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646741037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":374128,"user_name":"天天有吃的","can_delete":false,"product_type":"c1","uid":1604355,"ip_address":"广东","ucode":"6267FE8E68DEE5","user_header":"https://static001.geekbang.org/account/avatar/00/18/7b/03/03583011.jpg","comment_is_top":false,"comment_ctime":1683623852,"is_pvip":false,"replies":[{"id":136657,"content":"别气馁，多看几遍💪。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1683711314,"ip_address":"北京","comment_id":374128,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"直接看，确实有点看不懂...","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545790,"discussion_content":"main goroutine在执行ch &lt;-13时就阻塞住了。还没执行到创建下面那个goroutine呢。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1642050772,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1393948,"avatar":"","nickname":"0mfg","note":"","ucode":"D83530DB25D25A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":545799,"discussion_content":"谢谢白老师","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642053388,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":545790,"ip_address":"","group_id":0},"score":545799,"extra":""}]},{"author":{"id":2699840,"avatar":"https://static001.geekbang.org/account/avatar/00/29/32/40/d56f476c.jpg","nickname":"ibin","note":"","ucode":"766942C36B8E27","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545444,"discussion_content":"13发送给ch 已经阻塞了，不会向下运行了吧。。将go func 提到上面，并且在main最后加上time.Sleep 就可以，，，","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1641959225,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1479120,"avatar":"https://static001.geekbang.org/account/avatar/00/16/91/d0/35bc62b1.jpg","nickname":"无咎","note":"","ucode":"B9759B5646F3AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":604314,"discussion_content":"```\npackage main\n\nimport (\n\t&#34;fmt&#34;\n)\n\nfunc main() {\n\tch := make(chan int)\n\tgo func() {\n\t\tfmt.Println(&#34;=&gt; func()&#34;)\n\t\tn := &lt;-ch\n\t\tfmt.Println(n)\n\t\tfmt.Println(&#34;&lt;- func()&#34;)\n\t}()\n\tfmt.Println(&#34;=&gt; ch &lt;- 13&#34;)\n\tch &lt;- 13\n\tfmt.Println(&#34;&lt;- ch &lt;- 13&#34;)\n}\n```","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1676360143,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1501818,"avatar":"https://static001.geekbang.org/account/avatar/00/16/ea/7a/d857723d.jpg","nickname":"Vfeelit","note":"","ucode":"F3FF2B069F347F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555087,"discussion_content":"13入 主协程堵塞 这个时候只有一个协程并且堵塞了 那就算死锁了吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646741037,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":373520,"user_name":"陈鹤","can_delete":false,"product_type":"c1","uid":1962657,"ip_address":"上海","ucode":"08E781342831CE","user_header":"","comment_is_top":false,"comment_ctime":1682594959,"is_pvip":false,"replies":[{"id":136420,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1682651578,"ip_address":"北京","comment_id":373520,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"这节课信息量巨大，被各种应用场景的奇思妙想震惊到了！个人觉得是本教程偏向应用最重要的一个章节，示例丰富，可以直接当模板应用，常看常新！","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":617617,"discussion_content":"别气馁，多看几遍💪。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1683711314,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":364397,"user_name":"momo","can_delete":false,"product_type":"c1","uid":2201076,"ip_address":"辽宁","ucode":"7567CCCB0547E1","user_header":"https://static001.geekbang.org/account/avatar/00/21/95/f4/06442207.jpg","comment_is_top":false,"comment_ctime":1670922910,"is_pvip":false,"replies":[{"id":132519,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1671141097,"ip_address":"辽宁","comment_id":364397,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"狂赞","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":616226,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1682651578,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":358030,"user_name":"fengruichao","can_delete":false,"product_type":"c1","uid":1060405,"ip_address":"辽宁","ucode":"B41431137A585C","user_header":"https://static001.geekbang.org/account/avatar/00/10/2e/35/c12029fd.jpg","comment_is_top":false,"comment_ctime":1663837377,"is_pvip":false,"replies":[{"id":130367,"content":"ch1 &lt;- 1这一行将整个程序阻塞住了，下面的goroutine根本就没有得到创建的机会。go runtime检测到没有可以运行的用户goroutine了，所以报错！","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1664113286,"ip_address":"辽宁","comment_id":358030,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"func test1() {\n\tch1 := make(chan int)\n\tch1 &lt;- 1\n\tgo func() {\n\t\tfmt.Println(&lt;-ch1)\n\t}()\n}\n\n为什么把接收操作放在Goroutine会报fatal error: all goroutines are asleep - deadlock!,而把发送操作放到Goroutine中就不会报错","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":596622,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1671141097,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357586,"user_name":"Jay","can_delete":false,"product_type":"c1","uid":1070670,"ip_address":"北京","ucode":"ED9970F7E66080","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/4e/9291fac0.jpg","comment_is_top":false,"comment_ctime":1663425285,"is_pvip":false,"replies":[{"id":130232,"content":"select会等待啊。但如果没有外面的for循环，只会等待一次啊。然后就继续向下执行，就退出worker函数了。这里代码的目的就是循环定时等待。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1663641031,"ip_address":"北京","comment_id":357586,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"\nfunc worker() {\n  heartbeat := time.NewTicker(30 * time.Second)\n  defer heartbeat.Stop()\n  for {\n    select {\n    case &lt;-c:\n      &#47;&#47; ... do some stuff\n    case &lt;- heartbeat.C:\n      &#47;&#47;... do heartbeat stuff\n    }\n  }\n}\n\n老师，最后这段代码我没太明白，select如果没有default的话，不可发送和不可接受都会处于阻塞，状态，select本身不是会一直等待吗（select本身看起来像是个循环等待啊），外面的for循环有什么意义呢","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588792,"discussion_content":"ch1 &lt;- 1这一行将整个程序阻塞住了，下面的goroutine根本就没有得到创建的机会。go runtime检测到没有可以运行的用户goroutine了，所以报错！","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1664113286,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":357236,"user_name":"Jack Xin","can_delete":false,"product_type":"c1","uid":1425444,"ip_address":"北京","ucode":"BEC98A1F437239","user_header":"https://static001.geekbang.org/account/avatar/00/15/c0/24/01699070.jpg","comment_is_top":false,"comment_ctime":1663081403,"is_pvip":false,"replies":[{"id":130027,"content":"你是说 输出的顺序和文章中不一致。\n\n这个没问题。这个例子演示的是如何基于channel实现计数器，保证每个goroutine拿到的计数值都是不同的。输出顺序与goroutine调度顺序有关。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1663136463,"ip_address":"北京","comment_id":357236,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"白老师，想问您一个问题，关于无缓冲chan 的第二种用法：替换锁机制。我复制里面的例子在我的Mac上运行得到的是下面的结果，跟您的不一样，不是v=i+1的关系，想了半天也不知道为什么，我用的1.18版本的go，\ngoroutine-0: current counter value is 1\ngoroutine-1: current counter value is 9\ngoroutine-9: current counter value is 3\ngoroutine-5: current counter value is 4\ngoroutine-6: current counter value is 5\ngoroutine-7: current counter value is 6\ngoroutine-8: current counter value is 7\ngoroutine-2: current counter value is 8\ngoroutine-4: current counter value is 2\ngoroutine-3: current counter value is 10","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":588271,"discussion_content":"select会等待啊。但如果没有外面的for循环，只会等待一次啊。然后就继续向下执行，就退出worker函数了。这里代码的目的就是循环定时等待。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663641031,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":356891,"user_name":"菠萝吹雪—Code","can_delete":false,"product_type":"c1","uid":1650378,"ip_address":"北京","ucode":"A5B2FC661EE17D","user_header":"https://static001.geekbang.org/account/avatar/00/19/2e/ca/469f7266.jpg","comment_is_top":false,"comment_ctime":1662687305,"is_pvip":false,"replies":[{"id":129885,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1662701488,"ip_address":"北京","comment_id":356891,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"这节课解决了我很多疑惑，代码自己敲了一遍，一行一行分析，有感觉了。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587540,"discussion_content":"你是说 输出的顺序和文章中不一致。\n\n这个没问题。这个例子演示的是如何基于channel实现计数器，保证每个goroutine拿到的计数值都是不同的。输出顺序与goroutine调度顺序有关。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1663136463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":353175,"user_name":"zzy","can_delete":false,"product_type":"c1","uid":1805408,"ip_address":"北京","ucode":"3D7EC623EB8204","user_header":"https://static001.geekbang.org/account/avatar/00/1b/8c/60/58b6c39e.jpg","comment_is_top":false,"comment_ctime":1659236128,"is_pvip":false,"replies":[{"id":128456,"content":"1对n的信号通知使用的是channel的关闭机制。close groupSignal后，所有处于从groupSignal recv的goroutine都会从对groupSignal的recv中返回。不会阻塞。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1659403584,"ip_address":"北京","comment_id":353175,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"在 1 对 n 的信号通知 的代码中，并没有看到向groupSingal中发送值，接收端不是应该一直阻塞吗？感觉没法走下去","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":587032,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1662701488,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":351804,"user_name":"fgr_SHU","can_delete":false,"product_type":"c1","uid":1664919,"ip_address":"","ucode":"67A391AE754CBF","user_header":"https://static001.geekbang.org/account/avatar/00/19/67/97/96e3f59b.jpg","comment_is_top":false,"comment_ctime":1658201604,"is_pvip":false,"replies":[{"id":128096,"content":"不确定，具有随机性。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1658401686,"ip_address":"","comment_id":351804,"utype":1}],"discussion_count":1,"race_medal":0,"score":4,"product_id":100093501,"comment_content":"2s 后，ch2 被写入了一个数值 7。这样在某一轮 select 的过程中，分支case x := &lt;-ch2被选中得以执行，程序输出 7 之后满足退出条件，于是程序终止\n\n具体是哪一轮呢？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":582340,"discussion_content":"1对n的信号通知使用的是channel的关闭机制。close groupSignal后，所有处于从groupSignal recv的goroutine都会从对groupSignal的recv中返回。不会阻塞。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1659403585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350847,"user_name":"Geek_a6104e","can_delete":false,"product_type":"c1","uid":1711967,"ip_address":"","ucode":"29A56792216DC8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/GJXKh8OG00U5ial64plAIibbIuwkzhPc8uYic9Hibl8SbqvhnS2JImHgCD4JGvTktiaVnCjHQWbA5wicaxRUN5aTEWnQ/132","comment_is_top":false,"comment_ctime":1657256524,"is_pvip":false,"replies":[{"id":127672,"content":"程序的目的是不让go运行时将已经关闭的channel再次选出，使用comma, ok虽然可以在ok=false不打印，但是select会多次选择该closed channel，不符合我们的原意。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1657406366,"ip_address":"","comment_id":350847,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"我们原本期望上面这个在依次输出 5 和 7 两个数字后退出，但实际运行的输出结果却是在输出 5 之后，程序输出了许多的 0 值，之后才输出 7 并退出。 使用comma,ok语句接收通道ch的值 如果ok为true才打印 这种方式也行 不需要使用nil的channel","like_count":1},{"had_liked":false,"id":348036,"user_name":"五彩斑斓的輝","can_delete":false,"product_type":"c1","uid":2885173,"ip_address":"","ucode":"43F11424417E06","user_header":"https://static001.geekbang.org/account/avatar/00/2c/06/35/82915b9b.jpg","comment_is_top":false,"comment_ctime":1654681781,"is_pvip":false,"replies":[{"id":126850,"content":"大致是：在多个阻塞在channel上收的goroutine中选一个出来恢复running，然后这个goroutine就会将channel中数据读出来了。其他goroutine还在blocking中。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654760837,"ip_address":"","comment_id":348036,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"白老师，想问问go runtime是如何保证在一发多收的情况下，收到的不会相同的？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575340,"discussion_content":"大致是：在多个阻塞在channel上收的goroutine中选一个出来恢复running，然后这个goroutine就会将channel中数据读出来了。其他goroutine还在blocking中。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654760837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345278,"user_name":"0mfg","can_delete":false,"product_type":"c1","uid":1393948,"ip_address":"","ucode":"D83530DB25D25A","user_header":"","comment_is_top":false,"comment_ctime":1652169275,"is_pvip":false,"replies":[{"id":126053,"content":"你说的没错，需要type signal struct{}先定义 。例子之间具有相似性，这块没贴出来。\n\n另外c &lt;- signal(struct{}{}) 直接用c &lt;- signal{}就行了。\n\n稍后让编辑老师帮忙改一下，感谢指出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1652189030,"ip_address":"","comment_id":345278,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"白老师好，1 对 n 的信号通知的示例代码中，signal是不是没有定义，应该和1对1的信号通知示例代码一样type signal struct{}先定义吧，但是如果先定义的话，c &lt;- signal(struct{}{})这句goland又提示重复的类型转换了，请教一下老师原本写教程时的想法哈，谢谢","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":575340,"discussion_content":"大致是：在多个阻塞在channel上收的goroutine中选一个出来恢复running，然后这个goroutine就会将channel中数据读出来了。其他goroutine还在blocking中。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1654760837,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":343016,"user_name":"wu526","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1650595314,"is_pvip":false,"replies":[{"id":125295,"content":"嗯，用在“队列场景”中，要评估channel作为queue的收发性能，肯定是用收或发在单位时间内的次数来衡量的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1650602406,"ip_address":"","comment_id":343016,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"百老师，在本文中的带缓冲 channel 当作消息队列处理部分，给定的性能测试代码中，func init() {\n\tc1 = make(chan string)\n\tfor i := 0; i &lt; 10; i++ {\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t&lt;-c1 &#47;&#47; read\n\t\t\t}\n\t\t}()\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tc1 &lt;- &quot;hello&quot;  &#47;&#47; send\n\t\t\t}\n\t\t}()\n\t}\n\n\tc2 = make(chan string)\n\tfor i := 0; i &lt; 10; i++ {\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tc2 &lt;- &quot;hello&quot;\n\t\t\t}\n\t\t}()\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t&lt;-c2\n\t\t\t}\n\t\t}()\n\t}\n}\nchannel c1 其实一致处在接收和发送数据中，在做性能测试的时候，其实是通过后面的send 函数调用来发送值，用这个发送动作来进行性能测试。我这么理解正确吗？希望能得到老师的回复，谢谢白老师。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566102,"discussion_content":"嗯，用在“队列场景”中，要评估channel作为queue的收发性能，肯定是用收或发在单位时间内的次数来衡量的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650602406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":342796,"user_name":"Geek_7jzyrf","can_delete":false,"product_type":"c1","uid":1780608,"ip_address":"","ucode":"604202E40E9AA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pibibkbticCqnwDJkluy5QAWibesJ7vxLbQIG5sewicnjyjYFD9S4Oq9XYxxmjWTQTtFaNeYN6MpXwNAqfe8vUib21PA/132","comment_is_top":false,"comment_ctime":1650465372,"is_pvip":false,"replies":[{"id":125270,"content":"别急，慢慢来，💪","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1650549190,"ip_address":"","comment_id":342796,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"看不懂了，得慢慢啃才行😂","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":566102,"discussion_content":"嗯，用在“队列场景”中，要评估channel作为queue的收发性能，肯定是用收或发在单位时间内的次数来衡量的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650602406,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337529,"user_name":"Noya","can_delete":false,"product_type":"c1","uid":1519230,"ip_address":"","ucode":"52EEB72E80BAF8","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/7e/a15b477c.jpg","comment_is_top":false,"comment_ctime":1646881152,"is_pvip":false,"replies":[{"id":123364,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646946906,"ip_address":"","comment_id":337529,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"赞","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555510,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646946906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336621,"user_name":"小戈","can_delete":false,"product_type":"c1","uid":2067081,"ip_address":"","ucode":"3E52228E93E0F8","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8a/89/8940ea1e.jpg","comment_is_top":false,"comment_ctime":1646260949,"is_pvip":false,"replies":[{"id":123107,"content":"不用goroutine，spawn将阻塞在c &lt;- signal{}上。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646471986,"ip_address":"","comment_id":336621,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"第一种用法为什么要用协程，很顺序执行什么区别？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554575,"discussion_content":"不用goroutine，spawn将阻塞在c &lt;- signal{}上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646471986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334419,"user_name":"ming","can_delete":false,"product_type":"c1","uid":2316097,"ip_address":"","ucode":"AD183B7E1010A8","user_header":"https://static001.geekbang.org/account/avatar/00/23/57/41/886a9d74.jpg","comment_is_top":false,"comment_ctime":1644928000,"is_pvip":true,"replies":[{"id":122590,"content":"waitgroup顾名思义，用来等待一组goroutine退出的。waitgroup在sync包中属于相对简单且场景固定的，你看go官方的例子就很容易理解。 https:&#47;&#47;pkg.go.dev&#47;sync#WaitGroup","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1645597177,"ip_address":"","comment_id":334419,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"老师可以讲一下sync.WaitGroup的用法吗？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":554575,"discussion_content":"不用goroutine，spawn将阻塞在c &lt;- signal{}上。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646471986,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330466,"user_name":"Ransang","can_delete":false,"product_type":"c1","uid":1133041,"ip_address":"","ucode":"DB67566A627DF2","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/f1/bd61dbb1.jpg","comment_is_top":false,"comment_ctime":1641986912,"is_pvip":false,"replies":[{"id":121545,"content":"嗯，有什么问题可以具体一点。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643443090,"ip_address":"","comment_id":330466,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"这里为什么要在发送端关闭 channel 呢？\n这是因为发送端没有像接受端那样的、可以安全判断 channel 是否被关闭了的方法。\n\n这里表述是不是有问题呀","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552792,"discussion_content":"waitgroup顾名思义，用来等待一组goroutine退出的。waitgroup在sync包中属于相对简单且场景固定的，你看go官方的例子就很容易理解。 https://pkg.go.dev/sync#WaitGroup","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645597177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330456,"user_name":"Julien","can_delete":false,"product_type":"c1","uid":1204568,"ip_address":"","ucode":"2A3F0CF46B4034","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/58/7b078879.jpg","comment_is_top":false,"comment_ctime":1641983216,"is_pvip":false,"replies":[{"id":121543,"content":"就是在NewCounter被调用时，启动的goroutine啊。那个goroutine是一个for无限循环，会一直存在，直到程序退出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643443002,"ip_address":"","comment_id":330456,"utype":1}],"discussion_count":3,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"请问一下老师，“无缓冲 channel 替代锁后的实现”那个例子，NewCounter函数里的go func是什么时候执行的啊？看到NewCounter只调用了一次。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548910,"discussion_content":"嗯，有什么问题可以具体一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643443090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2175116,"avatar":"https://static001.geekbang.org/account/avatar/00/21/30/8c/6c86eaac.jpg","nickname":"LiWZ","note":"","ucode":"18406E7E3BA475","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546273,"discussion_content":"接收端可以通过第二个返回值ok来判断channel是否被关闭，但是发送端发送的话就会直接Panic。发送端肯定不能用接收的方式判断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642261729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":350847,"user_name":"Geek_a6104e","can_delete":false,"product_type":"c1","uid":1711967,"ip_address":"","ucode":"29A56792216DC8","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/GJXKh8OG00U5ial64plAIibbIuwkzhPc8uYic9Hibl8SbqvhnS2JImHgCD4JGvTktiaVnCjHQWbA5wicaxRUN5aTEWnQ/132","comment_is_top":false,"comment_ctime":1657256524,"is_pvip":false,"replies":[{"id":127672,"content":"程序的目的是不让go运行时将已经关闭的channel再次选出，使用comma, ok虽然可以在ok=false不打印，但是select会多次选择该closed channel，不符合我们的原意。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1657406366,"ip_address":"","comment_id":350847,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"我们原本期望上面这个在依次输出 5 和 7 两个数字后退出，但实际运行的输出结果却是在输出 5 之后，程序输出了许多的 0 值，之后才输出 7 并退出。 使用comma,ok语句接收通道ch的值 如果ok为true才打印 这种方式也行 不需要使用nil的channel","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579376,"discussion_content":"程序的目的是不让go运行时将已经关闭的channel再次选出，使用comma, ok虽然可以在ok=false不打印，但是select会多次选择该closed channel，不符合我们的原意。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657406366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":348036,"user_name":"五彩斑斓的輝","can_delete":false,"product_type":"c1","uid":2885173,"ip_address":"","ucode":"43F11424417E06","user_header":"https://static001.geekbang.org/account/avatar/00/2c/06/35/82915b9b.jpg","comment_is_top":false,"comment_ctime":1654681781,"is_pvip":false,"replies":[{"id":126850,"content":"大致是：在多个阻塞在channel上收的goroutine中选一个出来恢复running，然后这个goroutine就会将channel中数据读出来了。其他goroutine还在blocking中。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1654760837,"ip_address":"","comment_id":348036,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"白老师，想问问go runtime是如何保证在一发多收的情况下，收到的不会相同的？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579376,"discussion_content":"程序的目的是不让go运行时将已经关闭的channel再次选出，使用comma, ok虽然可以在ok=false不打印，但是select会多次选择该closed channel，不符合我们的原意。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657406366,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":345278,"user_name":"0mfg","can_delete":false,"product_type":"c1","uid":1393948,"ip_address":"","ucode":"D83530DB25D25A","user_header":"","comment_is_top":false,"comment_ctime":1652169275,"is_pvip":false,"replies":[{"id":126053,"content":"你说的没错，需要type signal struct{}先定义 。例子之间具有相似性，这块没贴出来。\n\n另外c &lt;- signal(struct{}{}) 直接用c &lt;- signal{}就行了。\n\n稍后让编辑老师帮忙改一下，感谢指出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1652189030,"ip_address":"","comment_id":345278,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"白老师好，1 对 n 的信号通知的示例代码中，signal是不是没有定义，应该和1对1的信号通知示例代码一样type signal struct{}先定义吧，但是如果先定义的话，c &lt;- signal(struct{}{})这句goland又提示重复的类型转换了，请教一下老师原本写教程时的想法哈，谢谢","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571379,"discussion_content":"你说的没错，需要type signal struct{}先定义 。例子之间具有相似性，这块没贴出来。\n\n另外c &lt;- signal(struct{}{}) 直接用c &lt;- signal{}就行了。\n\n稍后让编辑老师帮忙改一下，感谢指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652189030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1393948,"avatar":"","nickname":"0mfg","note":"","ucode":"D83530DB25D25A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":571394,"discussion_content":"感谢白老师指导，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652192712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":571379,"ip_address":"","group_id":0},"score":571394,"extra":""}]}]},{"had_liked":false,"id":343016,"user_name":"wu526","can_delete":false,"product_type":"c1","uid":1022129,"ip_address":"","ucode":"69282EB175B48E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/98/b1/f89a84d0.jpg","comment_is_top":false,"comment_ctime":1650595314,"is_pvip":false,"replies":[{"id":125295,"content":"嗯，用在“队列场景”中，要评估channel作为queue的收发性能，肯定是用收或发在单位时间内的次数来衡量的。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1650602406,"ip_address":"","comment_id":343016,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"百老师，在本文中的带缓冲 channel 当作消息队列处理部分，给定的性能测试代码中，func init() {\n\tc1 = make(chan string)\n\tfor i := 0; i &lt; 10; i++ {\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t&lt;-c1 &#47;&#47; read\n\t\t\t}\n\t\t}()\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tc1 &lt;- &quot;hello&quot;  &#47;&#47; send\n\t\t\t}\n\t\t}()\n\t}\n\n\tc2 = make(chan string)\n\tfor i := 0; i &lt; 10; i++ {\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tc2 &lt;- &quot;hello&quot;\n\t\t\t}\n\t\t}()\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\t&lt;-c2\n\t\t\t}\n\t\t}()\n\t}\n}\nchannel c1 其实一致处在接收和发送数据中，在做性能测试的时候，其实是通过后面的send 函数调用来发送值，用这个发送动作来进行性能测试。我这么理解正确吗？希望能得到老师的回复，谢谢白老师。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":571379,"discussion_content":"你说的没错，需要type signal struct{}先定义 。例子之间具有相似性，这块没贴出来。\n\n另外c &lt;- signal(struct{}{}) 直接用c &lt;- signal{}就行了。\n\n稍后让编辑老师帮忙改一下，感谢指出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652189030,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":1,"child_discussions":[{"author":{"id":1393948,"avatar":"","nickname":"0mfg","note":"","ucode":"D83530DB25D25A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":571394,"discussion_content":"感谢白老师指导，谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1652192712,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":571379,"ip_address":"","group_id":0},"score":571394,"extra":""}]}]},{"had_liked":false,"id":342796,"user_name":"Geek_7jzyrf","can_delete":false,"product_type":"c1","uid":1780608,"ip_address":"","ucode":"604202E40E9AA5","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/pibibkbticCqnwDJkluy5QAWibesJ7vxLbQIG5sewicnjyjYFD9S4Oq9XYxxmjWTQTtFaNeYN6MpXwNAqfe8vUib21PA/132","comment_is_top":false,"comment_ctime":1650465372,"is_pvip":false,"replies":[{"id":125270,"content":"别急，慢慢来，💪","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1650549190,"ip_address":"","comment_id":342796,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"看不懂了，得慢慢啃才行😂","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565850,"discussion_content":"别急，慢慢来，💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650549190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":337529,"user_name":"Noya","can_delete":false,"product_type":"c1","uid":1519230,"ip_address":"","ucode":"52EEB72E80BAF8","user_header":"https://static001.geekbang.org/account/avatar/00/17/2e/7e/a15b477c.jpg","comment_is_top":false,"comment_ctime":1646881152,"is_pvip":false,"replies":[{"id":123364,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646946906,"ip_address":"","comment_id":337529,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"赞","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":565850,"discussion_content":"别急，慢慢来，💪","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1650549190,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":336621,"user_name":"小戈","can_delete":false,"product_type":"c1","uid":2067081,"ip_address":"","ucode":"3E52228E93E0F8","user_header":"https://static001.geekbang.org/account/avatar/00/1f/8a/89/8940ea1e.jpg","comment_is_top":false,"comment_ctime":1646260949,"is_pvip":false,"replies":[{"id":123107,"content":"不用goroutine，spawn将阻塞在c &lt;- signal{}上。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1646471986,"ip_address":"","comment_id":336621,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"第一种用法为什么要用协程，很顺序执行什么区别？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":555510,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1646946906,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":334419,"user_name":"ming","can_delete":false,"product_type":"c1","uid":2316097,"ip_address":"","ucode":"AD183B7E1010A8","user_header":"https://static001.geekbang.org/account/avatar/00/23/57/41/886a9d74.jpg","comment_is_top":false,"comment_ctime":1644928000,"is_pvip":true,"replies":[{"id":122590,"content":"waitgroup顾名思义，用来等待一组goroutine退出的。waitgroup在sync包中属于相对简单且场景固定的，你看go官方的例子就很容易理解。 https:&#47;&#47;pkg.go.dev&#47;sync#WaitGroup","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1645597177,"ip_address":"","comment_id":334419,"utype":1}],"discussion_count":1,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"老师可以讲一下sync.WaitGroup的用法吗？","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":552792,"discussion_content":"waitgroup顾名思义，用来等待一组goroutine退出的。waitgroup在sync包中属于相对简单且场景固定的，你看go官方的例子就很容易理解。 https://pkg.go.dev/sync#WaitGroup","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645597177,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330466,"user_name":"Ransang","can_delete":false,"product_type":"c1","uid":1133041,"ip_address":"","ucode":"DB67566A627DF2","user_header":"https://static001.geekbang.org/account/avatar/00/11/49/f1/bd61dbb1.jpg","comment_is_top":false,"comment_ctime":1641986912,"is_pvip":false,"replies":[{"id":121545,"content":"嗯，有什么问题可以具体一点。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643443090,"ip_address":"","comment_id":330466,"utype":1}],"discussion_count":2,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"这里为什么要在发送端关闭 channel 呢？\n这是因为发送端没有像接受端那样的、可以安全判断 channel 是否被关闭了的方法。\n\n这里表述是不是有问题呀","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548910,"discussion_content":"嗯，有什么问题可以具体一点。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643443090,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2175116,"avatar":"https://static001.geekbang.org/account/avatar/00/21/30/8c/6c86eaac.jpg","nickname":"LiWZ","note":"","ucode":"18406E7E3BA475","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546273,"discussion_content":"接收端可以通过第二个返回值ok来判断channel是否被关闭，但是发送端发送的话就会直接Panic。发送端肯定不能用接收的方式判断。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642261729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330456,"user_name":"Julien","can_delete":false,"product_type":"c1","uid":1204568,"ip_address":"","ucode":"2A3F0CF46B4034","user_header":"https://static001.geekbang.org/account/avatar/00/12/61/58/7b078879.jpg","comment_is_top":false,"comment_ctime":1641983216,"is_pvip":false,"replies":[{"id":121543,"content":"就是在NewCounter被调用时，启动的goroutine啊。那个goroutine是一个for无限循环，会一直存在，直到程序退出。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643443002,"ip_address":"","comment_id":330456,"utype":1}],"discussion_count":3,"race_medal":0,"score":5,"product_id":100093501,"comment_content":"请问一下老师，“无缓冲 channel 替代锁后的实现”那个例子，NewCounter函数里的go func是什么时候执行的啊？看到NewCounter只调用了一次。","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548908,"discussion_content":"就是在NewCounter被调用时，启动的goroutine啊。那个goroutine是一个for无限循环，会一直存在，直到程序退出。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643443002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":546011,"discussion_content":"调用NewCounter的时候就执行了啊，每次+1往channel里发送没人收就暂时阻塞住，然后下面起了10个go func接收","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1642128141,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1232111,"avatar":"https://static001.geekbang.org/account/avatar/00/12/cc/ef/644afce7.jpg","nickname":"王旭","note":"","ucode":"635A50B2BBC2D0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1019939,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/90/23/5c74e9b7.jpg","nickname":"$侯","note":"","ucode":"488B1BD3924E7E","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":601492,"discussion_content":"简洁明了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1675240289,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":546011,"ip_address":"广东","group_id":0},"score":601492,"extra":""}]}]},{"had_liked":false,"id":330370,"user_name":"用0和1改变自己","can_delete":false,"product_type":"c1","uid":1527530,"ip_address":"","ucode":"42B8F6ECF6BDD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/lfMbV8RibrhFxjILg4550cZiaay64mTh5Zibon64TiaicC8jDMEK7VaXOkllHSpS582Jl1SUHm6Jib2AticVlHibiaBvUOA/132","comment_is_top":false,"comment_ctime":1641954741,"is_pvip":false,"replies":[{"id":121539,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643442336,"ip_address":"","comment_id":330370,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"赞，对channel的认知更进一步","like_count":1},{"had_liked":false,"id":330365,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1641952819,"is_pvip":true,"replies":[{"id":120548,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642050789,"ip_address":"","comment_id":330365,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"谢谢老师。总结得非常好。虽然学了很久go，但是没看到总结得如此好的","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548901,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643442337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330355,"user_name":"王哲","can_delete":false,"product_type":"c1","uid":1097315,"ip_address":"","ucode":"72FE449A06BD1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/be/63/ad364db5.jpg","comment_is_top":false,"comment_ctime":1641949113,"is_pvip":false,"replies":[{"id":121537,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643441838,"ip_address":"","comment_id":330355,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"厉害了，清晰易懂！","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545791,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642050789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383549,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"广东","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1699257881,"is_pvip":false,"replies":[{"id":139784,"content":"这种承载计数工作的goroutine我称之为&quot;detached goroutine&quot;，因为它的生命周期可以与程序的生命周期一致：程序启动，它启动；程序停止，它也随之退出，并且不需要创建它的main groutine对它有任何“牵挂”，它也不会造成任何资源“泄露”。在我眼中，这是一个好的设计。如果所有goroutine在生命周期内既能很好的完成分内工作，又无需parent goroutine对其进行维护，这是多好的事情啊。但实际开发中，很多goroutine是要和其parent goroutine发生“耦合”的，这就是一些quit&#47;done channel以及context.Context存在的原因，会导致较为复杂的结构。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1699322988,"ip_address":"北京","comment_id":383549,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"老师关于使用channel 制作计数器，这里又个问题。如果在实际生产中main制作计数器后，没有结束，还有其他功能， 那么 \nfunc NewCounter() *counter { cter := &amp;counter{ c: make(chan int), } go func() { for { cter.i++ cter.c &lt;- cter.i } }() return cter}\n这个goroutine会被无限挂起，那这样是否符合工程规范呢？ 如果不符合的话， 具体怎么处理如果只是简单关闭chan的话，向一个已经关闭的chan写入数据会造成excetption的","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548899,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643441838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382781,"user_name":"jasen","can_delete":false,"product_type":"c1","uid":2595680,"ip_address":"广东","ucode":"E0B7A5F82E247F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLq1w2nAUjZRccn8HJONc7WguHVPY5egD7DjNVDtQdoyicaycyQOPRj939ZnxRqkd4dPEATAicgUJAA/132","comment_is_top":false,"comment_ctime":1698046123,"is_pvip":true,"replies":[{"id":139399,"content":"想必你之前用过c&#47;c++等静态的、without gc的语言吧。go是带gc的语言，go在编译代码时会对每个变量做逃逸分析(escape analysis)。如果发现一个变量已经逃逸，便分配在堆(heap)上，而不是栈(stack)上了。上面的test函数中的变量a就是如此。编译器分析后，发现变量a已经逃逸，便会将a分配在heap上，这样main函数解引用test返回的c值时不会出现非法内存访问的问题。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1698068533,"ip_address":"辽宁","comment_id":382781,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"老师，函数内部返回指向局部变量的指针，有点不理解为什么会是正常的：\nfunc test() *int {\n    a := 1\n    return &amp;a\n}\n\nfunc main() {\n    b := test()\n    *b = 2\n    c := test()\n    fmt.Println(&quot;Hello world!&quot;, b, *b, &amp;c, *c)\n}\n函数内部的变量属于栈上，函数返回之后空间应该就非法了，有点不理解，忘老师解惑","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630055,"discussion_content":"想必你之前用过c/c++等静态的、without gc的语言吧。go是带gc的语言，go在编译代码时会对每个变量做逃逸分析(escape analysis)。如果发现一个变量已经逃逸，便分配在堆(heap)上，而不是栈(stack)上了。上面的test函数中的变量a就是如此。编译器分析后，发现变量a已经逃逸，便会将a分配在heap上，这样main函数解引用test返回的c值时不会出现非法内存访问的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698068533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379686,"user_name":"Tal.Huang","can_delete":false,"product_type":"c1","uid":1070729,"ip_address":"广东","ucode":"9486C855060FAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/89/30c2f416.jpg","comment_is_top":false,"comment_ctime":1692284729,"is_pvip":false,"replies":[{"id":138321,"content":"我执行了一下上述代码：\n\ngoroutine-9: current counter value is 1\ngoroutine-0: current counter value is 2\ngoroutine-1: current counter value is 3\ngoroutine-2: current counter value is 4\ngoroutine-3: current counter value is 5\ngoroutine-4: current counter value is 6\ngoroutine-5: current counter value is 7\ngoroutine-6: current counter value is 8\ngoroutine-7: current counter value is 9\ngoroutine-8: current counter value is 10\n\nProgram exited.\n\n这个有问题么？你说的变成11是什么意思？\n\n执行10次后，cter.i的确变成11了，因为其初始值为1。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1692352756,"ip_address":"美国","comment_id":379686,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"type counter struct {\n    c chan int\n    i int\n}\n\nfunc NewCounter() *counter {\n    cter := &amp;counter{\n        c: make(chan int),\n    }\n    go func() {\n        for {\n            cter.i++\n            cter.c &lt;- cter.i\n        }\n    }()\n    return cter\n}\n\nfunc (cter *counter) Increase() int {\n    return &lt;-cter.c\n}\n\nfunc main() {\n    cter := NewCounter()\n    var wg sync.WaitGroup\n    for i := 0; i &lt; 10; i++ {\n        wg.Add(1)\n        go func(i int) {\n            v := cter.Increase()\n            fmt.Printf(&quot;goroutine-%d: current counter value is %d\\n&quot;, i, v)\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}\n\n这个使用无缓冲 channel 替代锁后的实现 最后cter.i 变成11 了 和之前的例子结果cter.i 是10 结果不一样\n这个有办法解决吗？ 老师","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":625958,"discussion_content":"我执行了一下上述代码：\n\ngoroutine-9: current counter value is 1\ngoroutine-0: current counter value is 2\ngoroutine-1: current counter value is 3\ngoroutine-2: current counter value is 4\ngoroutine-3: current counter value is 5\ngoroutine-4: current counter value is 6\ngoroutine-5: current counter value is 7\ngoroutine-6: current counter value is 8\ngoroutine-7: current counter value is 9\ngoroutine-8: current counter value is 10\n\nProgram exited.\n\n这个有问题么？你说的变成11是什么意思？\n\n执行10次后，cter.i的确变成11了，因为其初始值为1。\n\n","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1692352756,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"美国","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330370,"user_name":"用0和1改变自己","can_delete":false,"product_type":"c1","uid":1527530,"ip_address":"","ucode":"42B8F6ECF6BDD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/lfMbV8RibrhFxjILg4550cZiaay64mTh5Zibon64TiaicC8jDMEK7VaXOkllHSpS582Jl1SUHm6Jib2AticVlHibiaBvUOA/132","comment_is_top":false,"comment_ctime":1641954741,"is_pvip":false,"replies":[{"id":121539,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643442336,"ip_address":"","comment_id":330370,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"赞，对channel的认知更进一步","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548901,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643442337,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330365,"user_name":"bearlu","can_delete":false,"product_type":"c1","uid":1030862,"ip_address":"","ucode":"14F260C8B24E27","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ba/ce/fd45714f.jpg","comment_is_top":false,"comment_ctime":1641952819,"is_pvip":true,"replies":[{"id":120548,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1642050789,"ip_address":"","comment_id":330365,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"谢谢老师。总结得非常好。虽然学了很久go，但是没看到总结得如此好的","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":545791,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1642050789,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":330355,"user_name":"王哲","can_delete":false,"product_type":"c1","uid":1097315,"ip_address":"","ucode":"72FE449A06BD1B","user_header":"https://static001.geekbang.org/account/avatar/00/10/be/63/ad364db5.jpg","comment_is_top":false,"comment_ctime":1641949113,"is_pvip":false,"replies":[{"id":121537,"content":"👍","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1643441838,"ip_address":"","comment_id":330355,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"厉害了，清晰易懂！","like_count":1,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":548899,"discussion_content":"👍","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1643441838,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":383549,"user_name":"爱吃胡萝卜","can_delete":false,"product_type":"c1","uid":1459413,"ip_address":"广东","ucode":"35FCF84D1E04C5","user_header":"https://static001.geekbang.org/account/avatar/00/16/44/d5/ca522e83.jpg","comment_is_top":false,"comment_ctime":1699257881,"is_pvip":false,"replies":[{"id":139784,"content":"这种承载计数工作的goroutine我称之为&quot;detached goroutine&quot;，因为它的生命周期可以与程序的生命周期一致：程序启动，它启动；程序停止，它也随之退出，并且不需要创建它的main groutine对它有任何“牵挂”，它也不会造成任何资源“泄露”。在我眼中，这是一个好的设计。如果所有goroutine在生命周期内既能很好的完成分内工作，又无需parent goroutine对其进行维护，这是多好的事情啊。但实际开发中，很多goroutine是要和其parent goroutine发生“耦合”的，这就是一些quit&#47;done channel以及context.Context存在的原因，会导致较为复杂的结构。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1699322988,"ip_address":"北京","comment_id":383549,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"老师关于使用channel 制作计数器，这里又个问题。如果在实际生产中main制作计数器后，没有结束，还有其他功能， 那么 \nfunc NewCounter() *counter { cter := &amp;counter{ c: make(chan int), } go func() { for { cter.i++ cter.c &lt;- cter.i } }() return cter}\n这个goroutine会被无限挂起，那这样是否符合工程规范呢？ 如果不符合的话， 具体怎么处理如果只是简单关闭chan的话，向一个已经关闭的chan写入数据会造成excetption的","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631119,"discussion_content":"这种承载计数工作的goroutine我称之为&#34;detached goroutine&#34;，因为它的生命周期可以与程序的生命周期一致：程序启动，它启动；程序停止，它也随之退出，并且不需要创建它的main groutine对它有任何“牵挂”，它也不会造成任何资源“泄露”。在我眼中，这是一个好的设计。如果所有goroutine在生命周期内既能很好的完成分内工作，又无需parent goroutine对其进行维护，这是多好的事情啊。但实际开发中，很多goroutine是要和其parent goroutine发生“耦合”的，这就是一些quit/done channel以及context.Context存在的原因，会导致较为复杂的结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699322988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":382781,"user_name":"jasen","can_delete":false,"product_type":"c1","uid":2595680,"ip_address":"广东","ucode":"E0B7A5F82E247F","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLq1w2nAUjZRccn8HJONc7WguHVPY5egD7DjNVDtQdoyicaycyQOPRj939ZnxRqkd4dPEATAicgUJAA/132","comment_is_top":false,"comment_ctime":1698046123,"is_pvip":true,"replies":[{"id":139399,"content":"想必你之前用过c&#47;c++等静态的、without gc的语言吧。go是带gc的语言，go在编译代码时会对每个变量做逃逸分析(escape analysis)。如果发现一个变量已经逃逸，便分配在堆(heap)上，而不是栈(stack)上了。上面的test函数中的变量a就是如此。编译器分析后，发现变量a已经逃逸，便会将a分配在heap上，这样main函数解引用test返回的c值时不会出现非法内存访问的问题。","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1698068533,"ip_address":"辽宁","comment_id":382781,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"老师，函数内部返回指向局部变量的指针，有点不理解为什么会是正常的：\nfunc test() *int {\n    a := 1\n    return &amp;a\n}\n\nfunc main() {\n    b := test()\n    *b = 2\n    c := test()\n    fmt.Println(&quot;Hello world!&quot;, b, *b, &amp;c, *c)\n}\n函数内部的变量属于栈上，函数返回之后空间应该就非法了，有点不理解，忘老师解惑","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":631119,"discussion_content":"这种承载计数工作的goroutine我称之为&#34;detached goroutine&#34;，因为它的生命周期可以与程序的生命周期一致：程序启动，它启动；程序停止，它也随之退出，并且不需要创建它的main groutine对它有任何“牵挂”，它也不会造成任何资源“泄露”。在我眼中，这是一个好的设计。如果所有goroutine在生命周期内既能很好的完成分内工作，又无需parent goroutine对其进行维护，这是多好的事情啊。但实际开发中，很多goroutine是要和其parent goroutine发生“耦合”的，这就是一些quit/done channel以及context.Context存在的原因，会导致较为复杂的结构。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1699322988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"北京","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":379686,"user_name":"Tal.Huang","can_delete":false,"product_type":"c1","uid":1070729,"ip_address":"广东","ucode":"9486C855060FAA","user_header":"https://static001.geekbang.org/account/avatar/00/10/56/89/30c2f416.jpg","comment_is_top":false,"comment_ctime":1692284729,"is_pvip":false,"replies":[{"id":138321,"content":"我执行了一下上述代码：\n\ngoroutine-9: current counter value is 1\ngoroutine-0: current counter value is 2\ngoroutine-1: current counter value is 3\ngoroutine-2: current counter value is 4\ngoroutine-3: current counter value is 5\ngoroutine-4: current counter value is 6\ngoroutine-5: current counter value is 7\ngoroutine-6: current counter value is 8\ngoroutine-7: current counter value is 9\ngoroutine-8: current counter value is 10\n\nProgram exited.\n\n这个有问题么？你说的变成11是什么意思？\n\n执行10次后，cter.i的确变成11了，因为其初始值为1。\n\n","user_name":"作者回复","user_name_real":"编辑","uid":1026224,"ctime":1692352756,"ip_address":"美国","comment_id":379686,"utype":1}],"discussion_count":1,"race_medal":0,"score":6,"product_id":100093501,"comment_content":"type counter struct {\n    c chan int\n    i int\n}\n\nfunc NewCounter() *counter {\n    cter := &amp;counter{\n        c: make(chan int),\n    }\n    go func() {\n        for {\n            cter.i++\n            cter.c &lt;- cter.i\n        }\n    }()\n    return cter\n}\n\nfunc (cter *counter) Increase() int {\n    return &lt;-cter.c\n}\n\nfunc main() {\n    cter := NewCounter()\n    var wg sync.WaitGroup\n    for i := 0; i &lt; 10; i++ {\n        wg.Add(1)\n        go func(i int) {\n            v := cter.Increase()\n            fmt.Printf(&quot;goroutine-%d: current counter value is %d\\n&quot;, i, v)\n            wg.Done()\n        }(i)\n    }\n    wg.Wait()\n}\n\n这个使用无缓冲 channel 替代锁后的实现 最后cter.i 变成11 了 和之前的例子结果cter.i 是10 结果不一样\n这个有办法解决吗？ 老师","like_count":0,"discussions":[{"author":{"id":1026224,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/a8/b0/6f87ab08.jpg","nickname":"Tony Bai","note":"","ucode":"B6B08985F6FA89","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":630055,"discussion_content":"想必你之前用过c/c++等静态的、without gc的语言吧。go是带gc的语言，go在编译代码时会对每个变量做逃逸分析(escape analysis)。如果发现一个变量已经逃逸，便分配在堆(heap)上，而不是栈(stack)上了。上面的test函数中的变量a就是如此。编译器分析后，发现变量a已经逃逸，便会将a分配在heap上，这样main函数解引用test返回的c值时不会出现非法内存访问的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1698068533,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"辽宁","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}