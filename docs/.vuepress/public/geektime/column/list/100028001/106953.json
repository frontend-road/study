{"id":106953,"title":"22 | 深入JVM即时编译器JIT，优化Java编译","content":"<p>你好，我是刘超。</p><p>说到编译，我猜你一定会想到 .java文件被编译成 .class文件的过程，这个编译我们一般称为前端编译。Java的编译和运行过程非常复杂，除了前端编译，还有运行时编译。由于机器无法直接运行Java生成的字节码，所以在运行时，JIT或解释器会将字节码转换成机器码，这个过程就叫运行时编译。</p><p>类文件在运行时被进一步编译，它们可以变成高度优化的机器代码，由于C/C++编译器的所有优化都是在编译期间完成的，运行期间的性能监控仅作为基础的优化措施则无法进行，例如，调用频率预测、分支频率预测、裁剪未被选择的分支等，而Java在运行时的再次编译，就可以进行基础的优化措施。因此，JIT编译器可以说是JVM中运行时编译最重要的部分之一。</p><p>然而许多Java开发人员对JIT编译器的了解并不多，不深挖其工作原理，也不深究如何检测应用程序的即时编译情况，线上发生问题后很难做到从容应对。<span class=\"orange\">今天我们就来学习运行时编译如何实现对Java代码的优化。</span></p><h2>类编译加载执行过程</h2><p>在这之前，我们先了解下Java从编译到运行的整个过程，为后面的学习打下基础。请看下图：</p><p><img src=\"https://static001.geekbang.org/resource/image/8d/17/8d4ec9c73ec37d69adb105aa7d052717.jpg?wh=2172*410\" alt=\"\"></p><h3>类编译</h3><p>在编写好代码之后，我们需要将 .java文件编译成 .class文件，才能在虚拟机上正常运行代码。文件的编译通常是由JDK中自带的Javac工具完成，一个简单的 .java文件，我们可以通过javac命令来生成 .class文件。</p><!-- [[[read_end]]] --><p>下面我们通过javap（ <a href=\"https://time.geekbang.org/column/article/101244\">第12讲</a> 讲过如何使用javap反编译命令行）反编译来看看一个class文件结构中主要包含了哪些信息：</p><p><img src=\"https://static001.geekbang.org/resource/image/60/7e/605dbbcfbbfcc09143d7d9e7fed5ac7e.png?wh=1197*2671\" alt=\"\"></p><p>看似一个简单的命令执行，前期编译的过程其实是非常复杂的，包括词法分析、填充符号表、注解处理、语义分析以及生成class文件，这个过程我们不用过多关注。只要从上图中知道，<span class=\"orange\">编译后的字节码文件主要包括常量池和方法表集合这两部分</span>就可以了。</p><p>常量池主要记录的是类文件中出现的字面量以及符号引用。字面常量包括字符串常量（例如String str=“abc”，其中\"abc\"就是常量），声明为final的属性以及一些基本类型（例如，范围在-127-128之间的整型）的属性。符号引用包括类和接口的全限定名、类引用、方法引用以及成员变量引用（例如String str=“abc”，其中str就是成员变量引用）等。</p><p>方法表集合中主要包含一些方法的字节码、方法访问权限（public、protect、prviate等）、方法名索引（与常量池中的方法引用对应）、描述符索引、JVM执行指令以及属性集合等。</p><h3>类加载</h3><p>当一个类被创建实例或者被其它对象引用时，虚拟机在没有加载过该类的情况下，会通过类加载器将字节码文件加载到内存中。</p><p>不同的实现类由不同的类加载器加载，JDK中的本地方法类一般由根加载器（Bootstrp loader）加载进来，JDK中内部实现的扩展类一般由扩展加载器（ExtClassLoader ）实现加载，而程序中的类文件则由系统加载器（AppClassLoader ）实现加载。</p><p>在类加载后，class类文件中的常量池信息以及其它数据会被保存到JVM内存的方法区中。</p><h3>类连接</h3><p>类在加载进来之后，会进行连接、初始化，最后才会被使用。在连接过程中，又包括验证、准备和解析三个部分。</p><p><strong>验证：</strong>验证类符合Java规范和JVM规范，在保证符合规范的前提下，避免危害虚拟机安全。</p><p><strong>准备：</strong>为类的静态变量分配内存，初始化为系统的初始值。对于final static修饰的变量，直接赋值为用户的定义值。例如，private final static int value=123，会在准备阶段分配内存，并初始化值为123，而如果是 private static int value=123，这个阶段value的值仍然为0。</p><p><strong>解析：</strong>将符号引用转为直接引用的过程。我们知道，在编译时，Java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。类结构文件的常量池中存储了符号引用，包括类和接口的全限定名、类引用、方法引用以及成员变量引用等。如果要使用这些类和方法，就需要把它们转化为JVM可以直接获取的内存地址或指针，即直接引用。</p><h3>类初始化</h3><p>类初始化阶段是类加载过程的最后阶段，在这个阶段中，JVM首先将执行构造器&lt;clinit&gt;方法，编译器会在将 .java 文件编译成 .class 文件时，收集所有类初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 &lt;clinit&gt;() 方法。</p><p>初始化类的静态变量和静态代码块为用户自定义的值，初始化的顺序和Java源码从上到下的顺序一致。例如：</p><pre><code>private static int i=1；\nstatic{\n  i=0;\n}\npublic static void main(String [] args){\n  System.out.println(i);\n}\n\n</code></pre><p>此时运行结果为：</p><pre><code>0\n</code></pre><p>再来看看以下代码：</p><pre><code>static{\n  i=0;\n}\nprivate static int i=1；\npublic static void main(String [] args){\n  System.out.println(i);\n}\n</code></pre><p>此时运行结果为：</p><pre><code>1\n</code></pre><p>子类初始化时会首先调用父类的 &lt;clinit&gt;() 方法，再执行子类的&lt;clinit&gt;() 方法，运行以下代码：</p><pre><code>public class Parent{\n  public static String parentStr= &quot;parent static string&quot;;\n  static{\n    System.out.println(&quot;parent static fields&quot;);\n    System.out.println(parentStr);\n  }\n  public Parent(){\n    System.out.println(&quot;parent instance initialization&quot;);\n }\n}\n\npublic class Sub extends Parent{\n  public static String subStr= &quot;sub static string&quot;;\n  static{\n    System.out.println(&quot;sub static fields&quot;);\n    System.out.println(subStr);\n  }\n\n  public Sub(){\n    System.out.println(&quot;sub instance initialization&quot;);\n  }\n \n  public static void main(String[] args){\n    System.out.println(&quot;sub main&quot;);\n    new Sub();\n }\n}\n</code></pre><p>运行结果：</p><pre><code>parent static fields\nparent static string\nsub static fields\nsub static string\nsub main\nparent instance initialization\nsub instance initialization\n</code></pre><p>JVM 会保证 &lt;clinit&gt;() 方法的线程安全，保证同一时间只有一个线程执行。</p><p>JVM在初始化执行代码时，如果实例化一个新对象，会调用&lt;init&gt;方法对实例变量进行初始化，并执行对应的构造方法内的代码。</p><h2>即时编译</h2><p>初始化完成后，类在调用执行过程中，执行引擎会把字节码转为机器码，然后在操作系统中才能执行。<span class=\"orange\">在字节码转换为机器码的过程中，虚拟机中还存在着一道编译，那就是即时编译。</span></p><p>最初，虚拟机中的字节码是由解释器（ Interpreter ）完成编译的，当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为“热点代码”。</p><p>为了提高热点代码的执行效率，在运行时，即时编译器（JIT）会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后保存到内存中。</p><h3>即时编译器类型</h3><p>在HotSpot虚拟机中，内置了两个JIT，分别为C1编译器和C2编译器，这两个编译器的编译过程是不一样的。</p><p>C1编译器是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序，例如，GUI应用对界面启动速度就有一定要求。</p><p>C2编译器是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序。根据各自的适配性，这两种即时编译也被称为Client Compiler和Server Compiler。</p><p>在Java7之前，需要根据程序的特性来选择对应的JIT，虚拟机默认采用解释器和其中一个编译器配合工作。</p><p>Java7引入了分层编译，这种方式综合了C1的启动性能优势和C2的峰值性能优势，我们也可以通过参数 “-client”“-server” 强制指定虚拟机的即时编译模式。<strong>分层编译将JVM的执行状态分为了5个层次：</strong></p><ul>\n<li>第0层：程序解释执行，默认开启性能监控功能（Profiling），如果不开启，可触发第二层编译；</li>\n<li>第1层：可称为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，不开启Profiling；</li>\n<li>第2层：也称为C1编译，开启Profiling，仅执行带方法调用次数和循环回边执行次数profiling的C1编译；</li>\n<li>第3层：也称为C1编译，执行所有带Profiling的C1编译；</li>\n<li>第4层：可称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li>\n</ul><p>在Java8中，默认开启分层编译，-client和-server的设置已经是无效的了。如果只想开启C2，可以关闭分层编译（-XX:-TieredCompilation），如果只想用C1，可以在打开分层编译的同时，使用参数：-XX:TieredStopAtLevel=1。</p><p>除了这种默认的混合编译模式，我们还可以使用“-Xint”参数强制虚拟机运行于只有解释器的编译模式下，这时JIT完全不介入工作；我们还可以使用参数“-Xcomp”强制虚拟机运行于只有JIT的编译模式下。</p><p>通过 java -version 命令行可以直接查看到当前系统使用的编译模式。如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/6e/11/6ea0938770cccc1b17c46f7b37d20711.jpg?wh=1222*650\" alt=\"\"></p><h3>热点探测</h3><p>在HotSpot虚拟机中的热点探测是JIT优化的条件，热点探测是基于计数器的热点探测，采用这种方法的虚拟机会为每个方法建立计数器统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法” 。</p><p>虚拟机为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p><p><strong>方法调用计数器：</strong>用于统计方法被调用的次数，方法调用计数器的默认阈值在C1模式下是1500次，在C2模式在是10000次，可通过-XX: CompileThreshold来设定；而在分层编译的情况下，-XX: CompileThreshold指定的阈值将失效，此时将会根据当前待编译的方法数以及编译线程数来动态调整。当方法计数器和回边计数器之和超过方法计数器阈值时，就会触发JIT编译器。</p><p><strong>回边计数器：</strong>用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge），该值用于计算是否触发C1编译的阈值，在不开启分层编译的情况下，C1默认为13995，C2默认为10700，可通过-XX: OnStackReplacePercentage=N来设置；而在分层编译的情况下，-XX: OnStackReplacePercentage指定的阈值同样会失效，此时将根据当前待编译的方法数以及编译线程数来动态调整。</p><p>建立回边计数器的主要目的是为了触发OSR（On StackReplacement）编译，即栈上编译。在一些循环周期比较长的代码段中，当循环达到回边计数器阈值时，JVM会认为这段是热点代码，JIT编译器就会将这段代码编译成机器语言并缓存，在该循环时间段内，会直接将执行代码替换，执行缓存的机器语言。</p><h3>编译优化技术</h3><p>JIT编译运用了一些经典的编译优化技术来实现代码的优化，即通过一些例行检查优化，可以智能地编译出运行时的最优性能代码。今天我们主要来学习以下两种优化手段：</p><p><strong>1.方法内联</strong></p><p>调用一个方法通常要经历压栈和出栈。调用方法是将程序执行顺序转移到存储该方法的内存地址，将方法的内容执行完后，再返回到执行该方法前的位置。</p><p>这种执行操作要求在执行前保护现场并记忆执行的地址，执行后要恢复现场，并按原来保存的地址继续执行。 因此，方法调用会产生一定的时间和空间方面的开销。</p><p>那么对于那些方法体代码不是很大，又频繁调用的方法来说，这个时间和空间的消耗会很大。<span class=\"orange\">方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。</span></p><p>例如以下方法：</p><pre><code>private int add1(int x1, int x2, int x3, int x4) {\n    return add2(x1, x2) + add2(x3, x4);\n}\nprivate int add2(int x1, int x2) {\n    return x1 + x2;\n}\n</code></pre><p>最终会被优化为：</p><pre><code>private int add1(int x1, int x2, int x3, int x4) {\n    return x1 + x2+ x3 + x4;\n}\n</code></pre><p>JVM会自动识别热点方法，并对它们使用方法内联进行优化。我们可以通过-XX:CompileThreshold来设置热点方法的阈值。但要强调一点，热点方法不一定会被JVM做内联优化，如果这个方法体太大了，JVM将不执行内联操作。而方法体的大小阈值，我们也可以通过参数设置来优化：</p><ul>\n<li>经常执行的方法，默认情况下，方法体大小小于325字节的都会进行内联，我们可以通过-XX:MaxFreqInlineSize=N来设置大小值；</li>\n<li>不是经常执行的方法，默认情况下，方法大小小于35字节才会进行内联，我们也可以通过-XX:MaxInlineSize=N来重置大小值。</li>\n</ul><p>之后我们就可以通过配置JVM参数来查看到方法被内联的情况：</p><pre><code>-XX:+PrintCompilation //在控制台打印编译过程信息\n-XX:+UnlockDiagnosticVMOptions //解锁对JVM进行诊断的选项参数。默认是关闭的，开启后支持一些特定参数对JVM进行诊断\n-XX:+PrintInlining //将内联方法打印出来\n</code></pre><p>当我们设置VM参数：-XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining之后，运行以下代码：</p><pre><code>\tpublic static void main(String[] args) {\n\t\tfor(int i=0; i&lt;1000000; i++) {//方法调用计数器的默认阈值在C1模式下是1500次，在C2模式在是10000次，我们循环遍历超过需要阈值\n\t\t\tadd1(1,2,3,4);\n\t\t}\n\t}\n</code></pre><p>我们可以看到运行结果中，显示了方法内联的日志：</p><p><img src=\"https://static001.geekbang.org/resource/image/ed/80/eda343938d9fa4ebb6b3331ae7b62680.jpg?wh=1612*212\" alt=\"\"></p><p>热点方法的优化可以有效提高系统性能，一般我们可以通过以下几种方式来提高方法内联：</p><ul>\n<li>通过设置JVM参数来减小热点阈值或增加方法体阈值，以便更多的方法可以进行内联，但这种方法意味着需要占用更多地内存；</li>\n<li>在编程中，避免在一个方法中写大量代码，习惯使用小方法体；</li>\n<li>尽量使用final、private、static关键字修饰方法，编码方法因为继承，会需要额外的类型检查。</li>\n</ul><p>2.逃逸分析</p><p>逃逸分析（Escape Analysis）是判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。</p><p><strong>栈上分配</strong></p><p>我们知道，在Java中默认创建一个对象是在堆中分配内存的，而当堆内存中的对象不再使用时，则需要通过垃圾回收机制回收，这个过程相对分配在栈中的对象的创建和销毁来说，更消耗时间和性能。这个时候，逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上。</p><p>以下是通过循环获取学生年龄的案例，方法中创建一个学生对象，我们现在通过案例来看看打开逃逸分析和关闭逃逸分析后，堆内存对象创建的数量对比。</p><pre><code>public static void main(String[] args) {\n    for (int i = 0; i &lt; 200000 ; i++) {\n    \tgetAge();\n    }\n}\n\npublic static int getAge(){\n\tStudent person = new Student(&quot;小明&quot;,18,30);   \n    return person.getAge();\n}\n\nstatic class Student {\n    private String name;\n    private int age;\n   \n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n}\n</code></pre><p>然后，我们分别设置VM参数：Xmx1000m -Xms1000m -XX:-DoEscapeAnalysis -XX:+PrintGC以及 -Xmx1000m -Xms1000m -XX:+DoEscapeAnalysis -XX:+PrintGC，通过之前讲过的VisualVM工具，查看堆中创建的对象数量。</p><p>然而，运行结果却没有达到我们想要的优化效果，也许你怀疑是JDK版本的问题，然而我分别在1.6~1.8版本都测试过了，效果还是一样的：</p><p>（-server -Xmx1000m -Xms1000m -XX:-DoEscapeAnalysis -XX:+PrintGC）</p><p><img src=\"https://static001.geekbang.org/resource/image/83/a5/8313c788b71e4df16b29a98bb4b63ca5.jpg?wh=2368*1240\" alt=\"\"></p><p>（-server -Xmx1000m -Xms1000m -XX:+DoEscapeAnalysis -XX:+PrintGC）</p><p><img src=\"https://static001.geekbang.org/resource/image/25/63/259bd540cca1120813146cebbebef763.jpg?wh=2370*1254\" alt=\"\"></p><p><span class=\"orange\">这其实是因为HotSpot虚拟机目前的实现导致栈上分配实现比较复杂，</span>可以说，在HotSpot中暂时没有实现这项优化。随着即时编译器的发展与逃逸分析技术的逐渐成熟，相信不久的将来HotSpot也会实现这项优化功能。</p><p><strong>  锁消除</strong></p><p>在非线程安全的情况下，尽量不要使用线程安全容器，比如StringBuffer。由于StringBuffer中的append方法被Synchronized关键字修饰，会使用到锁，从而导致性能下降。</p><p>但实际上，在以下代码测试中，StringBuffer和StringBuilder的性能基本没什么区别。这是因为在局部方法中创建的对象只能被当前线程访问，无法被其它线程访问，这个变量的读写肯定不会有竞争，这个时候JIT编译会对这个对象的方法锁进行锁消除。</p><pre><code>     public static String getString(String s1, String s2) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(s1);\n        sb.append(s2);\n        return sb.toString();\n    }\n</code></pre><p><strong>标量替换</strong></p><p>逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。这种编译优化就叫做标量替换。</p><p>我们用以下代码验证：</p><pre><code>   public void foo() {\n        TestInfo info = new TestInfo();\n        info.id = 1;\n        info.count = 99;\n          ...//to do something\n    }\n</code></pre><p>逃逸分析后，代码会被优化为：</p><pre><code>   \n   public void foo() {\n        id = 1;\n        count = 99;\n        ...//to do something\n    }\n</code></pre><p>我们可以通过设置JVM参数来开关逃逸分析，还可以单独开关同步消除和标量替换，在JDK1.8中JVM是默认开启这些操作的。</p><pre><code>-XX:+DoEscapeAnalysis开启逃逸分析（jdk1.8默认开启，其它版本未测试）\n-XX:-DoEscapeAnalysis 关闭逃逸分析\n\n-XX:+EliminateLocks开启锁消除（jdk1.8默认开启，其它版本未测试）\n-XX:-EliminateLocks 关闭锁消除\n\n-XX:+EliminateAllocations开启标量替换（jdk1.8默认开启，其它版本未测试）\n-XX:-EliminateAllocations 关闭就可以了\n</code></pre><h2>总结</h2><p>今天我们主要了解了JKD1.8以及之前的类的编译和加载过程，Java源程序是通过Javac编译器编译成 .class文件，其中文件中包含的代码格式我们称之为Java字节码（bytecode）。</p><p>这种代码格式无法直接运行，但可以被不同平台JVM中的Interpreter解释执行。由于Interpreter的效率低下，JVM中的JIT会在运行时有选择性地将运行次数较多的方法编译成二进制代码，直接运行在底层硬件上。</p><p>在Java8之前，HotSpot集成了两个JIT，用C1和C2来完成JVM中的即时编译。虽然JIT优化了代码，但收集监控信息会消耗运行时的性能，且编译过程会占用程序的运行时间。</p><p>到了Java9，AOT编译器被引入。和JIT不同，AOT是在程序运行前进行的静态编译，这样就可以避免运行时的编译消耗和内存消耗，且 .class文件通过AOT编译器是可以编译成 .so的二进制文件的。</p><p>到了Java10，一个新的JIT编译器Graal被引入。Graal 是一个以 Java 为主要编程语言、面向 Java bytecode 的编译器。与用 C++  实现的 C1 和 C2 相比，它的模块化更加明显，也更容易维护。Graal 既可以作为动态编译器，在运行时编译热点方法；也可以作为静态编译器，实现 AOT 编译。</p><h2>思考题</h2><p><span class=\"orange\">我们知道Class.forName和ClassLoader.loadClass都能加载类，你知道这两者在加载类时的区别吗？</span></p><p>期待在留言区看到你的见解。也欢迎你点击“请朋友读”，把今天的内容分享给身边的朋友，邀请他一起讨论。</p><p></p>","comments":[{"had_liked":false,"id":112683,"user_name":"nightmare","can_delete":false,"product_type":"c1","uid":1056314,"ip_address":"","ucode":"EF2E51C2122A86","user_header":"https://static001.geekbang.org/account/avatar/00/10/1e/3a/5b21c01c.jpg","comment_is_top":false,"comment_ctime":1562806582,"is_pvip":false,"replies":[{"id":"41158","content":"回答非常详细","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562899459,"ip_address":"","comment_id":112683,"utype":1}],"discussion_count":3,"race_medal":0,"score":"199131302198","product_id":100028001,"comment_content":"Class•forName有重载方法可以指定是否需要初始化，而默认的方法初始化设置为true这会初始化类执行链接和初始化操作，而ClasaLoader是有类加载器的loadClass方法加载，传入的是false只会执行链接操作，而不会执行初始化操作","like_count":47,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457855,"discussion_content":"回答非常详细","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562899459,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227252,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b9/f4/cc519a9f.jpg","nickname":"お金💪","note":"","ucode":"210C44553ABFDF","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":365070,"discussion_content":"loadClass 的描述应该错了。传入 false 只会加载，不会执行链接。两者最大区别就是 forName 可以执行初始化操作，loadClass 不可以执行初始化操作。","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1617701227,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1537865,"avatar":"https://static001.geekbang.org/account/avatar/00/17/77/49/445eea2d.jpg","nickname":"SochiLee","note":"","ucode":"47596594EDF4D7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":352034,"discussion_content":"loadClass(name, false)其中的false意思是不会执行链接操作吧？","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1614580352,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112989,"user_name":"QQ怪","can_delete":false,"product_type":"c1","uid":1211223,"ip_address":"","ucode":"1A39B8433D9208","user_header":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","comment_is_top":false,"comment_ctime":1562861351,"is_pvip":false,"replies":[{"id":"41159","content":"这次内容确实有点多，慢慢消化。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562899571,"ip_address":"","comment_id":112989,"utype":1}],"discussion_count":2,"race_medal":0,"score":"108937043751","product_id":100028001,"comment_content":"看老师这篇分享花了1个小时，分享的干货很多，回答下老师的问题：<br>不同点：<br>1）Class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块，还会执行给静态变量赋值的静态方法。<br>2）classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。","like_count":26,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457998,"discussion_content":"这次内容确实有点多，慢慢消化。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562899571,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2060756,"avatar":"","nickname":"在下蟑螂王","note":"","ucode":"E66A65A327095A","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293320,"discussion_content":"the same as i","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595503463,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113441,"user_name":"-W.LI-","can_delete":false,"product_type":"c1","uid":1210699,"ip_address":"","ucode":"3556786538664F","user_header":"https://static001.geekbang.org/account/avatar/00/12/79/4b/740f91ca.jpg","comment_is_top":false,"comment_ctime":1563010920,"is_pvip":false,"replies":[{"id":"41378","content":"W.LI同学解释的很透彻，赞一个。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563092402,"ip_address":"","comment_id":113441,"utype":1}],"discussion_count":2,"race_medal":0,"score":"61692553064","product_id":100028001,"comment_content":"这其实是因为由于 HotSpot 虚拟机目前的实现导致栈上分配实现比较复杂。<br>栈上分配影响:<br>1.java只有值传递，跨方法的局部变量在栈上分配的话，在现有栈实现上会影响栈的回收。<br>2.栈属于线程所有，实现栈上分配，会消耗更多的内存。让java的多线程更吃内存。<br>3.如果实现栈上分配，还需要GC作用会弱化很多吧。<br>4.基类型栈上分配+引用类型堆分配-&gt;全栈上分配。这么实现的话hotspot感觉全推翻了。<br>老师好有理解的不对的请指出谢谢","like_count":15,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458225,"discussion_content":"W.LI同学解释的很透彻，赞一个。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563092402,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2199562,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/OwZuBRbVUky4jTX41JrU5NKh2EFicicYibsTvMWQA6WV9JeGJBRribEyxqxhYFCRrX153J9lxe9KMd8V6AHgaaGm9Q/132","nickname":"neoro","note":"","ucode":"55F033008DA063","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":309939,"discussion_content":"除了第二点，其他点没有说服力。栈上分配的前提是对象没有逃逸。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1601534164,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":115542,"user_name":"张德","can_delete":false,"product_type":"c1","uid":1101929,"ip_address":"","ucode":"31FE63E8725EFC","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","comment_is_top":false,"comment_ctime":1563615349,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"31628386421","product_id":100028001,"comment_content":"刘老师您好  听完这篇课程想起了以前去阿里面试一个面试官问到的问题  问题大概是 OSGI各个容器之间的类加载器是怎么进行隔离的  刘老师懂不懂  能不能回答一下  谢谢","like_count":8,"discussions":[{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7231,"discussion_content":"这个建议你去看。极客时间 tomacat 那门课里如何打破双亲委派模型那几章，讲的十分详细","likes_number":4,"is_delete":false,"is_hidden":false,"ctime":1567426293,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1101929,"avatar":"https://static001.geekbang.org/account/avatar/00/10/d0/69/5dbdc245.jpg","nickname":"张德","note":"","ucode":"31FE63E8725EFC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":7594,"discussion_content":"牛逼牛逼了  那个我早就买了 一直没时间细看 谢谢你","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567581126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":7231,"ip_address":""},"score":7594,"extra":""}]}]},{"had_liked":false,"id":214769,"user_name":"lobby","can_delete":false,"product_type":"c1","uid":1181960,"ip_address":"","ucode":"8D81722BE36AD4","user_header":"https://static001.geekbang.org/account/avatar/00/12/09/08/f3547e77.jpg","comment_is_top":false,"comment_ctime":1588816663,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10178751255","product_id":100028001,"comment_content":"看了另外一个专栏的jvm虚拟机的，再看编译这块没那么吃力了，这个文章有个总结性的作用挺好的","like_count":2},{"had_liked":false,"id":183529,"user_name":"大俊stan","can_delete":false,"product_type":"c1","uid":1125370,"ip_address":"","ucode":"BD0CB5FC790DDB","user_header":"https://static001.geekbang.org/account/avatar/00/11/2b/fa/1cde88d4.jpg","comment_is_top":false,"comment_ctime":1583059534,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10172994126","product_id":100028001,"comment_content":"老师花一章想把这些技术全部讲明白也是很难的","like_count":2},{"had_liked":false,"id":169531,"user_name":"天信","can_delete":false,"product_type":"c1","uid":1232463,"ip_address":"","ucode":"4961959C9F19E9","user_header":"https://static001.geekbang.org/account/avatar/00/12/ce/4f/6afbb99a.jpg","comment_is_top":false,"comment_ctime":1578372396,"is_pvip":false,"replies":[{"id":"65922","content":"一般情况下我们不会去调整这些参数，JVM默认值就已经可以满足大多数服务了，使用默认值即可。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1578483268,"ip_address":"","comment_id":169531,"utype":1}],"discussion_count":2,"race_medal":0,"score":"10168306988","product_id":100028001,"comment_content":"很困惑线上服务的时候如何去调整这些参数达到最优解，比如调整 ComplieThrehold 大小或者其它参数，以及调整后到如何计算收益呢","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":480599,"discussion_content":"一般情况下我们不会去调整这些参数，JVM默认值就已经可以满足大多数服务了，使用默认值即可。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578483268,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2664121,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a6/b9/6bdaf8ce.jpg","nickname":"rich_li","note":"","ucode":"B82495DDC942DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407322,"discussion_content":"一般是不会调的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634981239,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":166932,"user_name":"天天向上","can_delete":false,"product_type":"c1","uid":1242455,"ip_address":"","ucode":"0CCCA6F4DCC480","user_header":"https://static001.geekbang.org/account/avatar/00/12/f5/57/ce10fb1b.jpg","comment_is_top":false,"comment_ctime":1577632906,"is_pvip":false,"replies":[{"id":"65039","content":"使用方法时间非常短，所以在栈上的数据也就很快被释放掉了","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1577871831,"ip_address":"","comment_id":166932,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10167567498","product_id":100028001,"comment_content":"文中讲到：逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上。然而我们的程序大多数对象都是只在方法中使用的啊，那栈就得需要很大的空间了啊？？","like_count":3,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":479684,"discussion_content":"使用方法时间非常短，所以在栈上的数据也就很快被释放掉了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1577871831,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":136275,"user_name":"SDL","can_delete":false,"product_type":"c1","uid":1438734,"ip_address":"","ucode":"AC46F5A8B4B704","user_header":"https://static001.geekbang.org/account/avatar/00/15/f4/0e/e200dd34.jpg","comment_is_top":false,"comment_ctime":1569401830,"is_pvip":false,"replies":[{"id":"52247","content":"springboot jar启动文件下，在启动时设置JVM参数就好了，java -xx（jvm参数）-jar xxx.jar","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1569414115,"ip_address":"","comment_id":136275,"utype":1}],"discussion_count":1,"race_medal":0,"score":"10159336422","product_id":100028001,"comment_content":"差了很多文章 还是没能找到在哪设置这些参数呢 望老师告知一下小白","like_count":2,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":468536,"discussion_content":"springboot jar启动文件下，在启动时设置JVM参数就好了，java -xx（jvm参数）-jar xxx.jar","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569414115,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":184494,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1583328620,"is_pvip":false,"replies":[{"id":"72183","content":"class文件是字节码，再JIT 或解释器会将字节码转换成机器码","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1584016077,"ip_address":"","comment_id":184494,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5878295916","product_id":100028001,"comment_content":"老师，Javap反编译的内容是生成class文件的中间过程么（在变成二进制文件前的汇编）","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486034,"discussion_content":"class文件是字节码，再JIT 或解释器会将字节码转换成机器码","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584016077,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1225224,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","nickname":"尔冬橙","note":"","ucode":"0B013A49BC18DA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203236,"discussion_content":"class文件是不可读的，javap 之后就可读了，这是什么原理。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584016545,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181262,"user_name":"deepz","can_delete":false,"product_type":"c1","uid":1570088,"ip_address":"","ucode":"4BD23A44CDB384","user_header":"https://static001.geekbang.org/account/avatar/00/17/f5/28/898a6947.jpg","comment_is_top":false,"comment_ctime":1582528769,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5877496065","product_id":100028001,"comment_content":"干货满满 太干了！  给老师敬礼哈哈哈~ 慢慢消化希望都能成为自己的~","like_count":1},{"had_liked":false,"id":291886,"user_name":"知易","can_delete":false,"product_type":"c1","uid":1246882,"ip_address":"","ucode":"BD3E3F0F0A40EF","user_header":"https://static001.geekbang.org/account/avatar/00/13/06/a2/350c4af0.jpg","comment_is_top":false,"comment_ctime":1620572375,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1620572375","product_id":100028001,"comment_content":"牛啊牛啊，干货满满。来得晚了点，但是在补课的路上了","like_count":0},{"had_liked":false,"id":290403,"user_name":"null","can_delete":false,"product_type":"c1","uid":1024294,"ip_address":"","ucode":"F9039EFED6B55D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","comment_is_top":false,"comment_ctime":1619527353,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1619527353","product_id":100028001,"comment_content":"javac 将 .java 文件编译成 .class 文件，即字节码文件。<br>interpreter 解释执行 .class 文件，JVM 层面的执行。<br>JIT 将 .class 文件编译为机器码，直接通过硬件执行。<br><br>是这样么，老师。谢谢","like_count":0},{"had_liked":false,"id":289395,"user_name":"Jecy-8","can_delete":false,"product_type":"c1","uid":1016276,"ip_address":"","ucode":"2AE1575B9E63A6","user_header":"https://static001.geekbang.org/account/avatar/00/0f/81/d4/e92abeb4.jpg","comment_is_top":false,"comment_ctime":1618996240,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1618996240","product_id":100028001,"comment_content":"干货满满，谢谢老师","like_count":0},{"had_liked":false,"id":274188,"user_name":"hiwon","can_delete":false,"product_type":"c1","uid":1193449,"ip_address":"","ucode":"BE509F375644B0","user_header":"https://static001.geekbang.org/account/avatar/00/12/35/e9/9280de62.jpg","comment_is_top":false,"comment_ctime":1610896172,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1610896172","product_id":100028001,"comment_content":"你好，请问一下单例模式的double check变量一定要加volatile来确保指令重排问题？在类的创建到初始化是原子操作？","like_count":0,"discussions":[{"author":{"id":2664121,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a6/b9/6bdaf8ce.jpg","nickname":"rich_li","note":"","ucode":"B82495DDC942DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407325,"discussion_content":"关于第二个疑问，我认为是的。这其实是一个类加载的过程，C++层理论上会保证这一个过程的原子性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634981814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2664121,"avatar":"https://static001.geekbang.org/account/avatar/00/28/a6/b9/6bdaf8ce.jpg","nickname":"rich_li","note":"","ucode":"B82495DDC942DC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":407324,"discussion_content":"需要的，volatile是禁止重排序，而 synchronied 只是保证了有序性","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1634981472,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":272046,"user_name":"Simba","can_delete":false,"product_type":"c1","uid":1017422,"ip_address":"","ucode":"44CE85BE1B5AB7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/86/4e/98dac64b.jpg","comment_is_top":false,"comment_ctime":1609917199,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1609917199","product_id":100028001,"comment_content":"老师，请教一下。逃逸分析那断代码如何用VisualVM抓到堆中创建的对象数量，我在执行的时候代码一瞬间就执行完了，VisualVM软件中也没有抓取到任何内存快照信息 ～  <br>我的开发环境是MAC系统，IDEA + visualvm launcher （插件）","like_count":0,"discussions":[{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370767,"discussion_content":"不要让代码退出试试，比如 sleep，countdownlatch。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619527428,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":269591,"user_name":"shen","can_delete":false,"product_type":"c1","uid":1215066,"ip_address":"","ucode":"AE5737B0C7DC4F","user_header":"https://static001.geekbang.org/account/avatar/00/12/8a/5a/b67a82e3.jpg","comment_is_top":false,"comment_ctime":1608708673,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608708673","product_id":100028001,"comment_content":"避免在一个方法中写大量代码，习惯使用小方法体；如果大方法没有办法内联而已，但是内联的目的不就是为了变为一个大方法吗？如果从程序性能优化的角度好像没太大关系吧","like_count":0},{"had_liked":false,"id":257950,"user_name":"溯雪","can_delete":false,"product_type":"c1","uid":1174371,"ip_address":"","ucode":"E819E5454BF216","user_header":"https://static001.geekbang.org/account/avatar/00/11/eb/63/09e7f442.jpg","comment_is_top":false,"comment_ctime":1604221213,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1604221213","product_id":100028001,"comment_content":"“由于 Interpreter 的效率低下，JVM 中的 JIT 会在运行时有选择性地将运行次数较多的方法编译成二进制代码，直接运行在底层硬件上。” 老师，我想请教个比较小白的问题，为什么JIT不把所有代码都编译到底层硬件上，而是只编译热点代码呢？如果某个系统对性能要求比较高，在内存资源充足、不关心初始化时长的场景下，把所有代码编译到底层硬件是否可行？","like_count":0},{"had_liked":false,"id":244817,"user_name":"好孩子","can_delete":false,"product_type":"c1","uid":1120022,"ip_address":"","ucode":"B7DBE8820FC6CE","user_header":"https://static001.geekbang.org/account/avatar/00/11/17/16/afff9a38.jpg","comment_is_top":false,"comment_ctime":1598689674,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1598689674","product_id":100028001,"comment_content":"为什么我测试的Class.forName和ClassLoader效果一样，都会执行静态代码块？","like_count":1,"discussions":[{"author":{"id":1619438,"avatar":"https://static001.geekbang.org/account/avatar/00/18/b5/ee/f56aebe6.jpg","nickname":"猩猩","note":"","ucode":"748E447BA89B03","race_medal":1,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":577387,"discussion_content":"过去两年了，测试代码不要在加载测试类中，仅供参考","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1656061542,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":231386,"user_name":"不可言喻的2","can_delete":false,"product_type":"c1","uid":1371438,"ip_address":"","ucode":"D734DE670D6AF6","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkdQpT1UAl2wjADkrc1fGy9ks9FQZnxC4P5VyABwatlWrr8AciaAr8RxA7p89CYlxlCqcdSbbmKeg/132","comment_is_top":false,"comment_ctime":1593661531,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1593661531","product_id":100028001,"comment_content":"之前用jdk1.8试过逃逸分析，测试过开启逃逸分析和不开启创建1000W对象时间差距很大，为嘛老师说虚拟机目前还没实现呢","like_count":0},{"had_liked":false,"id":156526,"user_name":"平凡之路","can_delete":false,"product_type":"c1","uid":1669273,"ip_address":"","ucode":"96CE12339BD5FD","user_header":"https://static001.geekbang.org/account/avatar/00/19/78/99/6060eb2d.jpg","comment_is_top":false,"comment_ctime":1574906316,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1574906316","product_id":100028001,"comment_content":"学习了很多","like_count":0},{"had_liked":false,"id":132522,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1568160990,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1568160990","product_id":100028001,"comment_content":"太干了，需要多点时间消化。老师这些知识，怎么持久化到脑袋里的，感觉自己脑袋里的知识都是分配在堆上的，很想放在MySQL数据库里。","like_count":0,"discussions":[{"author":{"id":1016276,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/81/d4/e92abeb4.jpg","nickname":"Jecy-8","note":"","ucode":"2AE1575B9E63A6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":369285,"discussion_content":"哈哈哈，同感","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1618996279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1371438,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJkdQpT1UAl2wjADkrc1fGy9ks9FQZnxC4P5VyABwatlWrr8AciaAr8RxA7p89CYlxlCqcdSbbmKeg/132","nickname":"不可言喻的2","note":"","ucode":"D734DE670D6AF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":288142,"discussion_content":"我是栈上分配的，很快就释放掉了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1593660684,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1357623,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJJmBKrLvqOIXDDbj3ocEIJzqsQx2e5VLDBSX6LmofYtprWwKaVAmHUqU2z3mjREHX8n9eLLiavlPg/132","nickname":"wg1993","note":"","ucode":"D5112FEFDB1DF7","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":42866,"discussion_content":"过段时间自动回收😂","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1572793019,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":130322,"user_name":"尔冬橙","can_delete":false,"product_type":"c1","uid":1225224,"ip_address":"","ucode":"0B013A49BC18DA","user_header":"https://static001.geekbang.org/account/avatar/00/12/b2/08/92f42622.jpg","comment_is_top":false,"comment_ctime":1567425657,"is_pvip":false,"replies":[{"id":"49185","content":"是非线程安全，有时候非线程安全使用线程安全容器反而增加了性能开销","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1567598597,"ip_address":"","comment_id":130322,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1567425657","product_id":100028001,"comment_content":"在非线程安全的情况下，尽量不要使用线程安全容器？这句话是不是线程安全的情况下？","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":465905,"discussion_content":"是非线程安全，有时候非线程安全使用线程安全容器反而增加了性能开销","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1567598597,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1438734,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f4/0e/e200dd34.jpg","nickname":"SDL","note":"","ucode":"AC46F5A8B4B704","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":20923,"discussion_content":"有点疑惑 非线程安全时不是得保证线程安全才去使用线程安全容器吗？然后又不建议使用？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1569397002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":116565,"user_name":"王龙飞","can_delete":false,"product_type":"c1","uid":1117966,"ip_address":"","ucode":"CE563902B27A9C","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/0e/98820fde.jpg","comment_is_top":false,"comment_ctime":1563871432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563871432","product_id":100028001,"comment_content":"看了三遍,干货满满,老师辛苦","like_count":0},{"had_liked":false,"id":113934,"user_name":"梁中华","can_delete":false,"product_type":"c1","uid":1006789,"ip_address":"","ucode":"52FE40242CBAD0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/5c/c5/1231d633.jpg","comment_is_top":false,"comment_ctime":1563188865,"is_pvip":true,"replies":[{"id":"41620","content":"目前的资料来看，最新的JVM暂时没有实现。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563244943,"ip_address":"","comment_id":113934,"utype":1}],"discussion_count":1,"race_medal":1,"score":"1563188865","product_id":100028001,"comment_content":"据一些书上说，因为默写原因Hotspot JVM并没有实现逃逸分析的优化，不知道最新的JVM有没有实现这条优化。","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458444,"discussion_content":"目前的资料来看，最新的JVM暂时没有实现。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563244943,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113535,"user_name":"王世林","can_delete":false,"product_type":"c1","uid":1076155,"ip_address":"","ucode":"2BB56D0FD71417","user_header":"https://static001.geekbang.org/account/avatar/00/10/6b/bb/10aaf123.jpg","comment_is_top":false,"comment_ctime":1563071692,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1563071692","product_id":100028001,"comment_content":"class.forNam实现也调用ClassLoader. 不过class.forName有static静态代码块，在类初始化的过程中执行了静态代码块中的代码，例如jdbc的实现需要加载数据库驱动，在静态代码块中向DriveManager注册自己.Spring直接用的Classloader","like_count":0},{"had_liked":false,"id":113237,"user_name":"bro.","can_delete":false,"product_type":"c1","uid":1124948,"ip_address":"","ucode":"D65283CD869804","user_header":"https://static001.geekbang.org/account/avatar/00/11/2a/54/c9990105.jpg","comment_is_top":false,"comment_ctime":1562922134,"is_pvip":false,"replies":[{"id":"41792","content":"是的","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563330007,"ip_address":"","comment_id":113237,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562922134","product_id":100028001,"comment_content":"逃逸分析跟标量替换在JDK 6u23以上版本都是默认开启状态的","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458124,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563330007,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":113192,"user_name":"Wendy","can_delete":false,"product_type":"c1","uid":1308653,"ip_address":"","ucode":"398DDC96B178F7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/0PT9LxT8D6micyk0YbPuGQElQIeSax7puBBTXJDicJDhUHNibrbJPjEPJBRklVmcKG1PB7YV8JNh0BpsJjSicfibT5A/132","comment_is_top":false,"comment_ctime":1562911883,"is_pvip":false,"replies":[{"id":"41803","content":"你好 Wendy，平台暂时不支持我们加个人微信，有问题可以在这里沟通，或通过github中的邮箱沟通。感谢你的支持。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1563333794,"ip_address":"","comment_id":113192,"utype":1}],"discussion_count":2,"race_medal":0,"score":"1562911883","product_id":100028001,"comment_content":"你好，刘兄！方便加下你微信吗？方便沟通","like_count":0,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":458102,"discussion_content":"你好 Wendy，平台暂时不支持我们加个人微信，有问题可以在这里沟通，或通过github中的邮箱沟通。感谢你的支持。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563333794,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1164531,"avatar":"https://static001.geekbang.org/account/avatar/00/11/c4/f3/92f654f1.jpg","nickname":"Bug? Feature!","note":"","ucode":"F8FA8A0094FBA0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1999,"discussion_content":"估计不行哈哈。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1563173902,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112685,"user_name":"undifined","can_delete":false,"product_type":"c1","uid":1068920,"ip_address":"","ucode":"449CB4CD2DC089","user_header":"https://static001.geekbang.org/account/avatar/00/10/4f/78/c3d8ecb0.jpg","comment_is_top":false,"comment_ctime":1562806801,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"1562806801","product_id":100028001,"comment_content":"老师 这段代码没有懂<br><br>static{<br>  i=0;<br>}<br>private static int i=1；<br>public static void main(String [] args){<br>  System.out.println(i);<br>}<br><br>static代码块在类加载的时候执行，按照书写顺序，此时 i 还没有被声明，是怎么赋值的","like_count":0,"discussions":[{"author":{"id":1024294,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaELZPnUAiajaR5C25EDLWeJURggyiaOP5GGPe2qlwpQcm5e3ybib8OsP4tvddFDLVRSNNGL5I3SFPJHsA/132","nickname":"null","note":"","ucode":"F9039EFED6B55D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":370769,"discussion_content":"1. 在准备阶段，静态变量已经分配了内存，且初始化了系统的初始值（不是用户设置的值）。\n2. 在最后的初始化阶段，静态变量和静态代码块，被初始化为用户设置的值。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1619527719,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1529493,"avatar":"https://static001.geekbang.org/account/avatar/00/17/56/95/5df05070.jpg","nickname":"Geek_Jack","note":"","ucode":"80F5D4262E4774","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":2966,"discussion_content":"已经被分配内存了，只是没初始化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1564066577,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1211223,"avatar":"https://static001.geekbang.org/account/avatar/00/12/7b/57/a9b04544.jpg","nickname":"QQ怪","note":"","ucode":"1A39B8433D9208","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1744,"discussion_content":"你试下是可以通过编译的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562861122,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112680,"user_name":"Liam","can_delete":false,"product_type":"c1","uid":1094597,"ip_address":"","ucode":"1D15D3B64F2606","user_header":"https://static001.geekbang.org/account/avatar/00/10/b3/c5/7fc124e2.jpg","comment_is_top":false,"comment_ctime":1562806295,"is_pvip":false,"replies":[{"id":"41157","content":"目前hotspot虚拟机暂时不支持栈上分配对象。","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562899418,"ip_address":"","comment_id":112680,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562806295","product_id":100028001,"comment_content":"栈上分配这里，对局部变量对象的大小是否有要求，毕竟栈的内存比较小","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457853,"discussion_content":"目前hotspot虚拟机暂时不支持栈上分配对象。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562899418,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":112650,"user_name":"我又不乱来","can_delete":false,"product_type":"c1","uid":1221356,"ip_address":"","ucode":"737405E2339A8D","user_header":"https://static001.geekbang.org/account/avatar/00/12/a2/ec/205fd50c.jpg","comment_is_top":false,"comment_ctime":1562801794,"is_pvip":false,"replies":[{"id":"41155","content":"正确","user_name":"作者回复","user_name_real":"刘超","uid":"1228576","ctime":1562899316,"ip_address":"","comment_id":112650,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1562801794","product_id":100028001,"comment_content":"Class.forName加载类的时候会对类进行初始化，如静态代码块，ClassLoader 不会做初始化。spring做类加载的时候应该用的是ClassLoader把。超哥。","like_count":1,"discussions":[{"author":{"id":1228576,"avatar":"https://static001.geekbang.org/account/avatar/00/12/bf/20/19d42715.jpg","nickname":"刘超","note":"","ucode":"CD56F93596E818","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":457836,"discussion_content":"正确","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562899316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}