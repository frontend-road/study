{"id":776589,"title":"02｜OpenAI Assistants中的线程和Run状态解析","content":"<p>你好，我是黄佳，欢迎来到启程篇的第二节课。</p><p>在上节课中，我们介绍了如何使用OpenAI的Playground创建一个Assistant，并通过Python程序检索并调用它完成一个简单的订单总价计算任务。今天，我们将继续深入探讨OpenAI Assistant中两个重要的概念：Thread（线程）和Run（运行），以及它们的生命周期和各种状态。</p><p>OpenAI Assistants的技术架构中总共有4个值得一提的对象，分别是：Assistant、Thread、Run和Message，其基本操作步骤如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/28/bf/2801d4e3c087093fe6da67a0b12ba3bf.jpg?wh=1417x927\" alt=\"\"></p><p>这些对象中，Assisant和Message不言自明，无须解释。那么，如何理解Thread和Run呢？</p><h2>究竟什么是 Thread 和 Run?</h2><p>在OpenAI Assistant的设计中，Thread代表了Assistant和用户之间的一次完整对话会话。它存储了Assistant和用户之间来回的Messages（消息），并自动处理上下文截断，以适应模型的上下文长度限制。</p><p>其实这就像是你在网页上和ChatGPT等任何语言模型的一个<strong>聊天页面</strong>，这个会话过程中，背后的Thread帮你记住之前的聊天上下文，并且在你输入的信息过长时会提醒你。</p><!-- [[[read_end]]] --><p>而Run则表示在一个Thread上调用Assistant的过程。Assistant会根据其配置以及Thread中的Messages，通过调用模型和工具来执行任务。在Run的过程中，Assistant也会向Thread中添加新的Messages。</p><p>其实这就像是你在网页上和ChatGPT等任何语言模型的一次<strong>互动过程</strong>。</p><h3>Assistant、Thread 和 Run 的交互过程</h3><p>Assistant、Thread和Run这三个核心概念之间的关系和交互过程如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/1d/fa/1db9eb555b2665a4d6ab8141ae254efa.jpg?wh=1360x453\" alt=\"\"></p><p>在这个示例中，一个名为 “Personal finance bot” 的Assistant被配置用于提供退休规划方面的建议。当用户向这个Assistant发送一条消息 “How much should I contribute to my retirement plan?” 时，就会创建一个新的Thread，用于处理这个关于退休规划的对话。</p><p>为了回答用户的问题，系统会在这个Thread上启动一个新的Run。在Run的执行过程中，Assistant分两步生成回复：</p><ul>\n<li>首先，使用代码解释器（code interpreter）工具计算出一个建议的缴费金额。</li>\n<li>然后，基于计算结果生成一条回复消息，例如 “You should contribute $478 per year…”。</li>\n</ul><p>最后，Assistant生成的回复消息会添加到Thread中，发送给用户。</p><p>这样，Assistant、Thread和Run，以及Message协同工作，共同完成一次<strong>人机对话</strong>。</p><p>此外，请你注意，在上一课中，我们创建线程的时候并没有指明助手的ID，因此，可以认为OpenAI 的线程和助手是彼此独立的。在OpenAI 的 API 设计中，创建和管理线程来维持一个连贯的对话流程，而助手则是在这些线程中提供回答和交互的实体。助手负责处理具体的请求，而线程则更多关注于对话的组织和管理。</p><p>也就是说，一个线程中可以有多个助手；同时，一个助手可以有多个线程。<strong>这种设计增加了系统的灵活性和应用场景的广度。</strong>比如在一个复杂的对话系统中，不同的助手可能专注于处理不同类型的任务或问题。例如，一个助手可能专门处理与天气相关的查询，而另一个助手则处理旅游建议。在同一个对话线程中，根据用户的不同问题，系统可以将请求路由到不同的助手进行处理。</p><h3>Thread 的上下文和生命周期管理</h3><p>创建Thread时，可以指定一组初始的Messages。之后我们可以不断地向Thread中添加新的Messages，这代表用户与Assistant的持续对话。</p><p>值得注意的是，Thread会自动管理上下文窗口，以确保它不超过模型的上下文长度限制。当Thread中Messages的总长度超过模型的上下文窗口时，Thread会在其内部用GPT模型对上下文做总结，并尝试尽可能多地包含最新的Messages，而丢弃最早的Messages。</p><p>线程创建之后，就会一直在那里等待你的消息，并和你对话。你此时可能会有疑问，如果我们创建了一系列重复的空的新线程，如何删除它呢？线程什么时候停止呢? 它会一直等着我来访问么？它过一段时间之后会不会自动消亡呢？</p><p>其实，旧的线程可以通过 API client.beta.threads.delete(thread_id) 来清理，不过，前提是你必须要知道线程的ID。</p><p>对于 assistants、run和message，你都可以通过list API来获取你所创建的所有对象的列表。</p><ul>\n<li>client.beta.assistants.list</li>\n<li>client.beta.threads.runs.list</li>\n<li>client.beta.threads.messages.list</li>\n</ul><p>但是你会发现，OpenAI目前并<strong>没有</strong>为我们提供线程的列表API。因此，当你没有记录下之前创建的线程，你就没有办法删除它。</p><p>我发现有人在论坛上提出了是否可以通过API列出当前的线程，以便管理。</p><p></p><p><img src=\"https://static001.geekbang.org/resource/image/2f/21/2fe97dafe6445ab2cc58ffbbf6e1de21.png?wh=944x416\" alt=\"图片\" title=\"关于线程生存周期和如何获取线程列表的讨论\"></p><p></p><p>OpenAI的开发团队表示他们了解这一需求，说Playground中最初是有这个功能的，但是由于担心线程会对组织内的任何人开放（考虑到大型企业对OpenAI访问权限设置较为宽松），所以他们移除了这一功能。这个问题已经被记录为一个待处理事项，团队希望在未来几周内能够分享更多信息。同时，他们建议不要使用尚未公开的端点（endpoints，也就是提问者提到的获取线程列表的API功能）。</p><p>当我发现自己重复创建了很多线程的时候，也在OpenAI的论坛中发了一个帖子，询问当我删除自己创建的助手时（可以在Playground或者用API删除Assistants），这些线程会不会跟着被清理掉。很快就得到了论坛leader的回复。但是他也不是100%肯定（其实现在想想，我觉得答案是No，因为Thread和Assistant是彼此独立存在的）。根据他的回答，60天后没有动静的线程，会被系统自动清理掉。</p><p><img src=\"https://static001.geekbang.org/resource/image/41/99/415b8a82eb75c32c8fa4f376c1349999.png?wh=944x535\" alt=\"图片\" title=\"我询问删除助手时，线程会不会跟着被清理掉\"></p><p>虽然创建了线程，但是没有Token的传输，应该不会产生费用的。所以，要删光你的活动线程似乎并不容易，暂时就这样吧，不要强迫症了。我想，开着的线程应该不会浪费过多资源吧，只要你没有循环地频繁在线程中发送和接收消息就好。</p><p></p><h2>Run 的生命周期和状态</h2><p>当我们在一个Thread上创建一个新的Run时，Assistant就开始根据Thread中的上下文Messages来执行任务。在这个过程中，Run会经历下图所示的多个状态。</p><p><img src=\"https://static001.geekbang.org/resource/image/a4/59/a4f3734bdf5fa2acbdbc3909472c1659.jpg?wh=1360x453\" alt=\"\"></p><p>对于这些状态，我列表解释如下。</p><p><img src=\"https://static001.geekbang.org/resource/image/a6/ea/a6671862c0b39a58185f192006d91eea.jpg?wh=1675x1954\" alt=\"\"></p><p>在Run创建后，也就是Thread开始运行对话交互之后，为了及时获取Run的最新状态，我们需要定期检索Run对象，以观察Run的状态变化。每次检索时，可以通过查看Run的status字段来确定应用程序接下来应该执行的操作。</p><h2>通过实战分析 Run 的状态流转</h2><p>好了，有了上面的理论做基础，我们现在就可以开始分析上一讲中，我们的Run究竟经历了那些状态，从出生到消亡，它的状态是怎样流转的。</p><h3>最简单的状态流转</h3><p>我们先来看一个最简单的状态变化的情况。此处的示例仍然调用上一节课中创建的同一个Assistant，但是，问题比较简单，Assistant能够智能的发现，不需要进行Function Call，因此会直接回答。</p><p>简单调用Assistant的程序代码如下：</p><pre><code class=\"language-plain\"># 导入OpenAI库,并创建OpenAI客户端\nfrom dotenv import load_dotenv\nload_dotenv()\nfrom openai import OpenAI\n\nclient = OpenAI()\n\n# 检索您之前创建的Assistant\nassistant_id = \"asst_aT4hurwd35eSave7qrt2t6eJ\" &nbsp;# 你自己的助手ID\nassistant = client.beta.assistants.retrieve(assistant_id)\nprint(assistant)\n\n# 创建一个新的Thread\nthread = client.beta.threads.create()\nprint(thread)\n\n# 向Thread添加用户的消息\nmessage = client.beta.threads.messages.create(\n&nbsp; &nbsp; thread_id=thread.id,\n&nbsp; &nbsp; role=\"user\",\n&nbsp; &nbsp; content=\"你好,请问你能做什么。\"\n)\nprint(message)\n\n# 运行Assistant来处理Thread\nrun = client.beta.threads.runs.create(\n&nbsp; &nbsp; thread_id=thread.id,\n&nbsp; &nbsp; assistant_id=assistant.id\n)\nprint(\"读取Run的状态\", run)\n\nimport time\n# 定义一个轮询的函数\ndef poll_run_status(client, thread_id, run_id, interval=10):\n&nbsp; &nbsp; while True:\n&nbsp; &nbsp; &nbsp; &nbsp; run = client.beta.threads.runs.retrieve(thread_id=thread_id, run_id=run_id)\n&nbsp; &nbsp; &nbsp; &nbsp; print(f\"Run的轮询信息:\\n{run}\\n\")\n&nbsp; &nbsp; &nbsp; &nbsp; if run.status in ['requires_action', 'completed']:\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return run\n&nbsp; &nbsp; &nbsp; &nbsp; time.sleep(interval) &nbsp;# 等待后再次检查\n\n# 轮询以检查Run的状态\nrun = poll_run_status(client, thread.id, run.id)\n\n\n\n# 获取Assistant在Thread中的回应\nmessages = client.beta.threads.messages.list(\n&nbsp; &nbsp; thread_id=thread.id\n)\nprint(\"全部的message\", messages)\n\n# 输出Assistant的最终回应\nprint('下面打印最终的Assistant回应:')\nfor message in messages.data:\n&nbsp; &nbsp; if message.role == \"assistant\":\n&nbsp; &nbsp; &nbsp; &nbsp; print(f\"{message.content}\\n\")\n</code></pre><p>在这里，我们定义了poll_run_status 函数，用来轮询检查 Assistant 在处理 Thread 过程中的状态，并定期输出当前Run的状态。这个函数的主要作用是在调用 Assistant 处理 Thread 后，持续检查 Assistant 处理的状态，直到处理完成或需要采取进一步行动为止。</p><p>这个程序的输出如下：</p><pre><code class=\"language-plain\">Assistant(id='asst_aT4hurwd35eSave7qrt2t6eJ', created_at=1711126020, description=None, file_ids=[], instructions='可以帮助客户计算当前购物车的商品总价', metadata={}, model='gpt-4-1106-preview', name='订单价格计算器', object='assistant', tools=[ToolFunction(function=FunctionDefinition(name='calculate_order_total', description='根据多个商品类型和数量计算订单总价', parameters={'type': 'object', 'properties': {'items': {'type': 'array', 'items': {'type': 'object', 'properties': {'item_type': {'type': 'string', 'description': '商品类型,例如:书籍,文具,电子产品'}, 'quantity': {'type': 'integer', 'description': '商品数量'}}, 'required': ['item_type', 'quantity']}}}, 'required': ['items']}), type='function')])\nThread(id='thread_1709dA8z7mQxnXP3U3QSnQiW', created_at=1712030293, metadata={}, object='thread')\nThreadMessage(id='msg_nPRj7cttfIEoXgmmAuGaJMdV', assistant_id=None, content=[MessageContentText(text=Text(annotations=[], value='你好,请问你能做什么。'), type='text')], created_at=1712030293, file_ids=[], metadata={}, object='thread.message', role='user', run_id=None, thread_id='thread_1709dA8z7mQxnXP3U3QSnQiW')\n读取Run的状态 Run(id='run_8XqQ2w5cO5H3te3GdeQxSrfB', assistant_id='asst_aT4hurwd35eSave7qrt2t6eJ', cancelled_at=None, completed_at=None, created_at=1712030293, expires_at=1712030893, failed_at=None, file_ids=[], instructions='可以帮助客户计算当前购物车的商品总价', last_error=None, metadata={}, model='gpt-4-1106-preview', object='thread.run', required_action=None, started_at=None, status='queued', thread_id='thread_1709dA8z7mQxnXP3U3QSnQiW', tools=[ToolAssistantToolsFunction(function=FunctionDefinition(name='calculate_order_total', description='根据多个商品类型和数量计算订单总价', parameters={'type': 'object', 'properties': {'items': {'type': 'array', 'items': {'type': 'object', 'properties': {'item_type': {'type': 'string', 'description': '商品类型,例如:书籍,文具,电子产品'}, 'quantity': {'type': 'integer', 'description': '商品数量'}}, 'required': ['item_type', 'quantity']}}}, 'required': ['items']}), type='function')], usage=None, temperature=1.0)\nRun的轮询信息:\nRun(id='run_8XqQ2w5cO5H3te3GdeQxSrfB', assistant_id='asst_aT4hurwd35eSave7qrt2t6eJ', cancelled_at=None, completed_at=None, created_at=1712030293, expires_at=1712030893, failed_at=None, file_ids=[], instructions='可以帮助客户计算当前购物车的商品总价', last_error=None, metadata={}, model='gpt-4-1106-preview', object='thread.run', required_action=None, started_at=1712030294, status='in_progress', thread_id='thread_1709dA8z7mQxnXP3U3QSnQiW', tools=[ToolAssistantToolsFunction(function=FunctionDefinition(name='calculate_order_total', description='根据多个商品类型和数量 计算订单总价', parameters={'type': 'object', 'properties': {'items': {'type': 'array', 'items': {'type': 'object', 'properties': {'item_type': {'type': 'string', 'description': '商品类型,例如:书籍,文具,电子产品'}, 'quantity': {'type': 'integer', 'description': '商品数量'}}, 'required': ['item_type', 'quantity']}}}, 'required': ['items']}), type='function')], usage=None, temperature=1.0)\n\nRun的轮询信息:\nRun(id='run_8XqQ2w5cO5H3te3GdeQxSrfB', assistant_id='asst_aT4hurwd35eSave7qrt2t6eJ', cancelled_at=None, completed_at=None, created_at=1712030293, expires_at=1712030893, failed_at=None, file_ids=[], instructions='可以帮助客户计算当前购物车的商品总价', last_error=None, metadata={}, model='gpt-4-1106-preview', object='thread.run', required_action=None, started_at=1712030294, status='in_progress', thread_id='thread_1709dA8z7mQxnXP3U3QSnQiW', tools=[ToolAssistantToolsFunction(function=FunctionDefinition(name='calculate_order_total', description='根据多个商品类型和数量\n计算订单总价', parameters={'type': 'object', 'properties': {'items': {'type': 'array', 'items': {'type': 'object', 'properties': {'item_type': {'type': 'string', 'description': '商品类型,例如:书籍,文具,电子产品'}, 'quantity': {'type': 'integer', 'description': '商品数量'}}, 'required': ['item_type', 'quantity']}}}, 'required': ['items']}), type='function')], usage=None, temperature=1.0)\n\nRun的轮询信息:\nRun(id='run_8XqQ2w5cO5H3te3GdeQxSrfB', assistant_id='asst_aT4hurwd35eSave7qrt2t6eJ', cancelled_at=None, completed_at=None, created_at=1712030293, expires_at=1712030893, failed_at=None, file_ids=[], instructions='可以帮助客户计算当前购物车的商品总价', last_error=None, metadata={}, model='gpt-4-1106-preview', object='thread.run', required_action=None, started_at=1712030294, status='in_progress', thread_id='thread_1709dA8z7mQxnXP3U3QSnQiW', tools=[ToolAssistantToolsFunction(function=FunctionDefinition(name='calculate_order_total', description='根据多个商品类型和数量 计算订单总价', parameters={'type': 'object', 'properties': {'items': {'type': 'array', 'items': {'type': 'object', 'properties': {'item_type': {'type': 'string', 'description': '商品类型,例如:书籍,文具,电子产品'}, 'quantity': {'type': 'integer', 'description': '商品数量'}}, 'required': ['item_type', 'quantity']}}}, 'required': ['items']}), type='function')], usage=None, temperature=1.0)\n\nRun的轮询信息:\nRun(id='run_8XqQ2w5cO5H3te3GdeQxSrfB', assistant_id='asst_aT4hurwd35eSave7qrt2t6eJ', cancelled_at=None, completed_at=1712030317, created_at=1712030293, expires_at=None, failed_at=None, file_ids=[], instructions='可以帮助客户计算当前购物车的商品总价', last_error=None, metadata={}, model='gpt-4-1106-preview', object='thread.run', required_action=None, started_at=1712030294, status='completed', thread_id='thread_1709dA8z7mQxnXP3U3QSnQiW', tools=[ToolAssistantToolsFunction(function=FunctionDefinition(name='calculate_order_total', description='根据多个商品类型和数量计 算订单总价', parameters={'type': 'object', 'properties': {'items': {'type': 'array', 'items': {'type': 'object', 'properties': {'item_type': {'type': 'string', 'description': '商品类型,例如:书籍,文具,电子产品'}, 'quantity': {'type': 'integer', 'description': '商品数量'}}, 'required': ['item_type', 'quantity']}}}, 'required': ['items']}), type='function')], usage=Usage(completion_tokens=340, prompt_tokens=327, total_tokens=667), temperature=1.0)&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\n\n全部的message SyncCursorPage[ThreadMessage](data=[ThreadMessage(id='msg_1x5L8QTIhw2drlG6gCJhytIh', assistant_id='asst_aT4hurwd35eSave7qrt2t6eJ', content=[MessageContentText(text=Text(annotations=[], value='你好！我是一个人工智能助手，可以帮你完成许多任务。以下是我可以提供帮助的一些范例：\\n\\n1. 回答问题：我能提供关于各种主题的信息，从简单的 事实问题到更复杂的解释和建议。\\n2. 解决问题：我可以帮助你解决数学问题、提供编程指导或帮你理解复杂的概念。\\n3. 数据分析：我可以帮你分析数据，提供统计信息或进行预测分析。\\n4. 文字处理：我可以帮你校对文本、生成内容或翻译成不同的语 言。\\n5. 计算与转换：我可以执行各种类型的计算，比如货币转换、单位转换、日期计算等。\\n6. 生活帮助：我能帮你规划日程、设置提醒或者提供生活小贴士。\\n7. 购物助手：我可以帮你计算购物车的商品总价、比较产品价格或提供购物建议。\\n\\n还有 很多其他的功能和服务。如果你有具体的需求或问题，随时告诉我，我会尽力协助你。'), type='text')], created_at=1712030296, file_ids=[], metadata={}, object='thread.message', role='assistant', run_id='run_8XqQ2w5cO5H3te3GdeQxSrfB', thread_id='thread_1709dA8z7mQxnXP3U3QSnQiW'), ThreadMessage(id='msg_nPRj7cttfIEoXgmmAuGaJMdV', assistant_id=None, content=[MessageContentText(text=Text(annotations=[], value='你好,请问你能做什么。'), type='text')], created_at=1712030293, file_ids=[], metadata={}, object='thread.message', role='user', run_id=None, thread_id='thread_1709dA8z7mQxnXP3U3QSnQiW')], object='list', first_id='msg_1x5L8QTIhw2drlG6gCJhytIh', last_id='msg_nPRj7cttfIEoXgmmAuGaJMdV', has_more=False)\n下面打印最终的Assistant回应:\n[MessageContentText(text=Text(annotations=[], value='你好！我是一个人工智能助手，可以帮你完成许多任务。以下是我可 以提供帮助的一些范例：\\n\\n1. 回答问题：我能提供关于各种主题的信息，从简单的事实问题到更复杂的解释和建议。\\n2. 解决问题：我可以帮助你解决数学问题、提供编程指导或帮你理解复杂的概念。\\n3. 数据分析：我可以帮你分析数据，提供统计信息 或进行预测分析。\\n4. 文字处理：我可以帮你校对文本、生成内容或翻译成不同的语言。\\n5. 计算与转换：我可以执行各种类型的计算，比如货币转换、单位转换、日期计算等。\\n6. 生活帮助：我能帮你规划日程、设置提醒或者提供生活小贴士。\\n7. 购物助手：我可以帮你计算购物车的商品总价、比较产品价格或提供购物建议。\\n\\n还有很多其他的功能和服务。如果你有具体的需求或问题，随时告诉我，我会尽力协助你。'), type='text')]\n</code></pre><p>这个输出内容很多，又有点不好理解，所以我给你总结成了下面的列表。</p><p><img src=\"https://static001.geekbang.org/resource/image/4d/83/4d4a478284b2af88e4b64d65c3709f83.jpg?wh=1816x1134\" alt=\"图片\"></p><p>通过这个表格，我们可以清晰地看到整个对话过程中，Assistant、Thread、Message和Run这几个关键对象的状态变化。其中，Run的状态变化最为关键，体现了Assistant处理用户请求的完整生命周期，从 “queued” 到 “in_progress”，最后到 “completed”。整体流程正如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/01/54/017b829869fd3eb7e1ea2ecd31fece54.jpg?wh=1788x754\" alt=\"\"></p><p>这就是不调用Function时，Run状态变化的最简示例。</p><h3>加入了 Function Call 之后的状态流转</h3><p>以上，是最简单的流程。你可能已经意识到了，上一讲中，我们的示例中Run的状态比上面复杂多了。这是因为，我们当时的对话“你好，我购买了一本书和一个电子产品，请帮我计算一下订单总价”，成功地激活了Assistant的功能调用服务（Function Tool），从而进一步<strong>触发了Run的requires_action状态</strong>。</p><p>此时，如果你使用自定义的poll_run_status函数来取代上一讲中的create_and_poll API，你就会发现，Run经过了queue和in_progress两个状态之后，是进入了requires_action这个新状态，等待函数的本地调用，当然本地调用结束之后，必须<strong>再通过submit_tool_outputs提交给Assistant，Run状态才变为 “completed”，Assistant 处理过程才结束</strong>。</p><p>如果你持续地把Run的status打印出来，总结成列表的形式，就会如下表所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/85/11/85e7eff68fd8424100d8e0a522c06d11.jpg?wh=1404x1368\" alt=\"图片\"></p><p>通过这个表格，我们可以清晰地看到整个对话过程中，Assistant、Thread、Message和Run这几个关键对象的状态变化。其中，Run的状态变化最为关键，体现了Assistant处理用户请求的完整生命周期。正如下图所示。</p><p><img src=\"https://static001.geekbang.org/resource/image/d3/2b/d358ccdcda13b3b18ce7f00ce11d602b.jpg?wh=1695x745\" alt=\"\"></p><p>与上一个例子相比，这个例子中Run的状态出现了 “requires_action”（需要操作），表明Assistant在处理过程中需要调用外部函数。我们可以看到，在读取函数元数据信息、动态调用函数并获得结果后，Run的状态才变为 “completed”（已完成）。这展示了函数调用在Assistant处理过程中的重要作用。</p><h2>总结时刻</h2><p>这节课，我带着你深入探讨了OpenAI Assistant中Thread和Run的概念，以及它们的生命周期管理和状态转换。了解这些内容可以帮助我们更好地使用OpenAI的Assistants API构建强大的AI应用。</p><p>这几个重要概念列表如下：</p><p><img src=\"https://static001.geekbang.org/resource/image/ed/f1/ed60d6e017fa13d24c978be1ab5c58f1.jpg?wh=1668x808\" alt=\"图片\"></p><p>在下节课中，我们将继续学习Assistant的其他重要功能，如代码解释器（Code interpreter）和文件检索（File search）等工具的使用。敬请期待！</p><h2>思考题</h2><ol>\n<li>我们自定义的函数 poll_run_status() 和 client.beta.threads.runs.create_and_poll() 这个API有何异同？为何这一课中，我们选择使用自定义的函数poll_run_status()？</li>\n<li>观察程序中每一个Run的输出，说一说，Run的生命周期大概有多长？在本课的两个示例中，Run在什么情况下可能会进入Expired状态？</li>\n<li>调整程序代码，尝试通过client.beta.threads.runs.cancel这个API来取消正在进行的Run，使Run进入cancelled状态。</li>\n</ol><p>期待你的思考，欢迎在评论区与我交流。如果今天的内容让你有所收获，也欢迎你把这节课转发给有需要的朋友！我们下节课再见！</p>","neighbors":{"left":{"article_title":"01｜用OpenAI Assistants的Function进行订单管理","id":775791},"right":{"article_title":"03｜用Assistants中的Code interpreter做数据分析","id":777441}},"comments":[{"had_liked":false,"id":390976,"user_name":"王轲","can_delete":false,"product_type":"c1","uid":1444126,"ip_address":"上海","ucode":"65065BFFC409F5","user_header":"https://static001.geekbang.org/account/avatar/00/16/09/1e/fc5144ff.jpg","comment_is_top":false,"comment_ctime":1716947213,"is_pvip":false,"replies":[{"id":142221,"content":"嗯嗯，谢谢，很好的建议。的确，线程这个词通常会让人联想起操作系统中的概念。我也和ChatGPT讨论了一下（毕竟这是OpenAI自家的产品）—— ChatGPT认为，可以翻译为“会话线程”或者“对话线程”。我觉得“对话线程”是一个折衷方案。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1717081123,"ip_address":"新加坡","comment_id":390976,"utype":1}],"discussion_count":2,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"我觉得Thread此处不应该翻译成线程，线程这个词容易让人和操作系统的线程产生错误联想。应该取这个解释:[countable] (computing计算机) a series of connected messages on email, social media, etc. that have been sent by different people（互联网留言板上帖子的）系列相关信息，链式消息","like_count":1,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645999,"discussion_content":"嗯嗯，谢谢，很好的建议。的确，线程这个词通常会让人联想起操作系统中的概念。我也和ChatGPT讨论了一下（毕竟这是OpenAI自家的产品）—— ChatGPT认为，可以翻译为“会话线程”或者“对话线程”。我觉得“对话线程”是一个折衷方案。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1717081123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043757,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83erdmsQ1lvSIk6GR6CcicQjKwXicxEJIELxfhX7J1kky08myb1UrscfFLg6nDHTwUFRAeosTKDX7WxpA/132","nickname":"拉德姆","note":"","ucode":"A813EDA3984385","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":647045,"discussion_content":"这个thread像是邮件里的说法，我理解就是会话","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1719334900,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"上海","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390804,"user_name":"🇾.🇨.","can_delete":false,"product_type":"c1","uid":3600600,"ip_address":"英国","ucode":"C033E961553EA3","user_header":"https://static001.geekbang.org/account/avatar/00/36/f0/d8/c344594a.jpg","comment_is_top":false,"comment_ctime":1716348618,"is_pvip":false,"replies":[{"id":142136,"content":"啊，是吗，对不起让同学感觉收获较小。我个人认为 OpenAI 的 Assistants API的设计，为我们搭建起来了一个Agent雏形，未来的Agent，就是这个架构和功能。因此，我们还是了解一下。这4课讲完了之后，那么后续内容就只需要有API Key就可以了，Azure上的也可以了。\n","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1716453762,"ip_address":"新加坡","comment_id":390804,"utype":1}],"discussion_count":6,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"感觉最近两节课收获很小啊，我有OpenAI，但是是Azure上的，根本用不了Assistant。兄弟们国内还是走虚拟卡服务商订阅openai吗？","like_count":1,"discussions":[{"author":{"id":1145377,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","nickname":"熊出没","note":"","ucode":"6E39230CC87808","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645843,"discussion_content":"感觉自己冲动买课了 这个Assistant因为openai的限制在国内用不起来 第一步都跨不出去","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1716885766,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"湖北","group_id":0},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2477104,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTICAILuSqtnARmMmomT7ic85ITviaiaJlowficJ4XH1pkh1syt1EFtOTvrMht2yOWxlW710AicaAf1EXEg/132","nickname":"yision97","note":"","ucode":"F771F37CBC422D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1145377,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","nickname":"熊出没","note":"","ucode":"6E39230CC87808","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645956,"discussion_content":"是啊，折腾了半天，好不容易弄得美国卡也被openAI ban了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717037795,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645843,"ip_address":"四川","group_id":0},"score":645956,"extra":""},{"author":{"id":3600600,"avatar":"https://static001.geekbang.org/account/avatar/00/36/f0/d8/c344594a.jpg","nickname":"🇾.🇨.","note":"","ucode":"C033E961553EA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1145377,"avatar":"https://static001.geekbang.org/account/avatar/00/11/7a/21/a33cc944.jpg","nickname":"熊出没","note":"","ucode":"6E39230CC87808","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646020,"discussion_content":"最近azure更新playground了，新版的playground也支持assistants了，可以试试注册一个海外的azure账户，申请免费的额度看看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717133575,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645843,"ip_address":"上海","group_id":0},"score":646020,"extra":""}]},{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645628,"discussion_content":"啊，是吗，对不起让同学感觉收获较小。我个人认为 OpenAI 的 Assistants API的设计，为我们搭建起来了一个Agent雏形，未来的Agent，就是这个架构和功能。因此，我们还是了解一下。这4课讲完了之后，那么后续内容就只需要有API Key就可以了，Azure上的也可以了。\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1716453763,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":1,"child_discussions":[{"author":{"id":3600600,"avatar":"https://static001.geekbang.org/account/avatar/00/36/f0/d8/c344594a.jpg","nickname":"🇾.🇨.","note":"","ucode":"C033E961553EA3","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":646019,"discussion_content":"最近azure好像更新playground，新版的playground也支持assistants了，这下可以试试了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717133528,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":645628,"ip_address":"上海","group_id":0},"score":646019,"extra":""}]},{"author":{"id":1027564,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/ad/ec/406130f3.jpg","nickname":"coderlee","note":"","ucode":"09569C08693514","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":653986,"discussion_content":"我倒是感觉还好啊，openai用虚拟卡充值就好了，还挺方便的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1731636739,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":"美国","group_id":0},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":391239,"user_name":"Geek_a15a44","can_delete":false,"product_type":"c1","uid":3644315,"ip_address":"北京","ucode":"96E04EF1A33789","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/VR5VwSsY8uGQKkeibUy5rGbvChLMh936xYDNCUGAszqulibIy94PVGpL9jqEtZI61thGceeLibr1ev7yUlGmOFD7Q/132","comment_is_top":false,"comment_ctime":1717676170,"is_pvip":false,"replies":[{"id":142303,"content":"好问题，我没想过这个事，我丢给OpenAI论坛了，关注一下，会有人回答的https:&#47;&#47;community.openai.com&#47;t&#47;can-i-call-2-functions-continuously-in-assistants-api&#47;808850","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1717952427,"ip_address":"新加坡","comment_id":391239,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"大佬你好，请问assistant可以根据用户query连续调用两个函数吗，是否会连续两次出现requires_action状态呢？","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":646421,"discussion_content":"好问题，我没想过这个事，我丢给OpenAI论坛了，关注一下，会有人回答的https://community.openai.com/t/can-i-call-2-functions-continuously-in-assistants-api/808850","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1717952427,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":390822,"user_name":"qinsi","can_delete":false,"product_type":"c1","uid":1667175,"ip_address":"上海","ucode":"090D9C4068FF12","user_header":"https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg","comment_is_top":false,"comment_ctime":1716382638,"is_pvip":true,"replies":[{"id":142140,"content":"谢谢同学的补充，有vector store的线程就要小心了。","user_name":"作者回复","user_name_real":"编辑","uid":1809833,"ctime":1716454002,"ip_address":"新加坡","comment_id":390822,"utype":1}],"discussion_count":1,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"u1s1, assistants还在beta, 一直在变化, 所以课程内容可能需要持续更新. 比如课上提到的thread列表, 前一阵出了个project页面, 可以分不同的project管理thread. 另外不活跃的thread也不是说不会扣费, 因为前一阵出了vector store, 可以attach到thread上用于rag什么的. 就算thread里没有新token产生, vector store还是会默认扣费7天.","like_count":0,"discussions":[{"author":{"id":1809833,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/9d/a9/4602808f.jpg","nickname":"黄佳","note":"","ucode":"8EC41D2EAB0E3C","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":645632,"discussion_content":"谢谢同学的补充，有vector store的线程就要小心了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1716454002,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":"新加坡","group_id":0},"score":2,"extra":"{\"reply\":true,\"user_type\":2,\"source\":0}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":392638,"user_name":"极客酱酱","can_delete":false,"product_type":"c1","uid":2934665,"ip_address":"四川","ucode":"18CDC1DB754D58","user_header":"https://static001.geekbang.org/account/avatar/00/2c/c7/89/16437396.jpg","comment_is_top":false,"comment_ctime":1721373572,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"1. 相同：都是通过循环轮询当前run的状态 不同：终止轮询条件和轮询间隔\n2. 根据run的created_at和expires_at字段得知run的生命周期默认时600s，即10分钟\n3. # 定义一个轮询run状态的函数\ndef poll_run_status(thread_id, run_id: str, interval=3):\n    while True:\n        run = client.beta.threads.runs.retrieve(\n            run_id=run_id,\n            thread_id=thread_id,\n        )\n        print(f&#39;Run的状态: {run.status}&#39;)\n        print(f&#39;Run的轮询信息: \\n{run}\\n&#39;)\n        if run.status in [&#39;require_action&#39;, &#39;completed&#39;, &#39;cancelled&#39;]:\n            return run\n        if run.status == &#39;in_progress&#39;:\n            client.beta.threads.runs.cancel(run_id=run_id, thread_id=thread_id)\n        time.sleep(interval)","like_count":1},{"had_liked":false,"id":395668,"user_name":"coderlee","can_delete":false,"product_type":"c1","uid":1027564,"ip_address":"美国","ucode":"09569C08693514","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ad/ec/406130f3.jpg","comment_is_top":false,"comment_ctime":1731639457,"is_pvip":false,"replies":null,"discussion_count":0,"race_medal":0,"score":2,"product_id":100764201,"comment_content":"Q1: \n1）create_and_poll相当于先cerate，再执行poll_run_status\n2）poll_run_status中，判断跳出循环的run.status是requires_action和completed；create_and_poll中跳出循环的run.status增加了cancelled, failed,expired,incomplete的判断。\n3）个人理解，课程中使用自定义函数poll_run_status，一个是让大家理解api（手戳create_and_poll），一个是更方便的去展示run的生命周期\nQ2：\n1）生命周期应该是从Thread被run开始，从queued状态，直到completed&#47;failed&#47;expired&#47;cancelled的一整个过程。\n2）当run执行过程中超出时间未响应就会过期。（个人理解类似于http请求的超时时间）\nQ3：\n有手就行","like_count":0}]}