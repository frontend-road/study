{"id":6282,"title":"58 | 性能设计篇之“缓存”","content":"<p>你好，我是陈皓，网名左耳朵耗子。</p>\n<p>前面分享了《分布式系统设计模式》系列文章的前两部分——弹力设计篇和管理设计篇。今天开始这一系列的最后一部分内容——性能设计篇，主题为《性能设计篇之“缓存”》。</p>\n<p>基本上来说，在分布式系统中最耗性能的地方就是最后端的数据库了。一般来说，只要小心维护好，数据库四种操作（select、update、insert和delete）中的三个写操作insert、update和delete不太会出现性能问题（insert一般不会有性能问题，update和delete一般会有主键，所以也不会太慢）。除非索引建得太多，而数据库里的数据又太多，这三个操作才会变慢。</p>\n<p>绝大多数情况下，select是出现性能问题最大的地方。一方面，select会有很多像join、group、order、like等这样丰富的语义，而这些语义是非常耗性能的；另一方面，大多数应用都是读多写少，所以加剧了慢查询的问题。</p>\n<p>分布式系统中远程调用也会消耗很多资源，因为网络开销会导致整体的响应时间下降。为了挽救这样的性能开销，在业务允许的情况（不需要太实时的数据）下，使用缓存是非常必要的事情。</p>\n<p>从另一个方面说，缓存在今天的移动互联网中是必不可少的一部分，因为网络质量不一定永远是最好的，所以前端也会为所有的API加上缓存。不然，网络不通畅的时候，没有数据，前端都不知道怎么展示UI了。既然因为移动互联网的网络质量而导致我们必须容忍数据的不实时性，那么，从业务上来说，在大多数情况下是可以使用缓存的。</p>\n<p>缓存是提高性能最好的方式，一般来说，缓存有以下三种模式。</p>\n<h1>Cache Aside 更新模式</h1>\n<p>这是最常用的设计模式了，其具体逻辑如下。</p>\n<ul>\n<li><strong>失效</strong>：应用程序先从Cache取数据，如果没有得到，则从数据库中取数据，成功后，放到缓存中。</li>\n<li><strong>命中</strong>：应用程序从Cache中取数据，取到后返回。</li>\n<li><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/0a/d4/0a39fbce98c0d43e15b56b0ed09099d4.png?wh=625*195\" alt=\"\" /></p>\n<p><img src=\"https://static001.geekbang.org/resource/image/e0/94/e0ecbc94d474f7bd0c8eb53dfd8bde94.png?wh=625*191\" alt=\"\" /></p>\n<p>这是标准的设计模式，包括Facebook的论文《<a href=\"https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf\">Scaling Memcache at Facebook</a>》中也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《<a href=\"https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend\">Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?</a>》，主要是怕两个并发的写操作导致脏数据。</p>\n<!-- [[[read_end]]] -->\n<p>那么，是不是这个Cache Aside就不会有并发问题了？不是的。比如，一个是读操作，但是没有命中缓存，就会到数据库中取数据。而此时来了一个写操作，写完数据库后，让缓存失效，然后之前的那个读操作再把老的数据放进去，所以会造成脏数据。</p>\n<p>这个案例理论上会出现，但实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且有一个并发的写操作。实际上数据库的写操作会比读操作慢得多，而且还要锁表，读操作必须在写操作前进入数据库操作，又要晚于写操作更新缓存，所有这些条件都具备的概率并不大。</p>\n<p><strong>所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命地降低并发时脏数据的概率。而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置好过期时间。</strong></p>\n<h1>Read/Write Through 更新模式</h1>\n<p>我们可以看到，在上面的Cache Aside套路中，应用代码需要维护两个数据存储，一个是缓存（cache），一个是数据库（repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</p>\n<h2>Read Through</h2>\n<p>Read Through套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>\n<h2>Write Through</h2>\n<p>Write Through套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由Cache自己更新数据库（这是一个同步操作）。</p>\n<p>下图来自Wikipedia的Cache词条。其中的Memory，你可以理解为就是我们例子里的数据库。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/93/9a/933ed3ddb7d56735a0db5101f86d9a9a.png?wh=902*1216\" alt=\"\" /></p>\n<h1>Write Behind Caching 更新模式</h1>\n<p>Write Behind又叫Write Back。一些了解Linux操作系统内核的同学对write back应该非常熟悉，这不就是Linux文件系统的page cache算法吗？是的，你看基础知识全都是相通的。所以，基础很重要，我已经说过不止一次了。</p>\n<p>Write Back套路就是，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛）。因为异步，Write Back还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>\n<p>但其带来的问题是，数据不是强一致性的，而且可能会丢失（我们知道Unix/Linux非正常关机会导致数据丢失，就是因为这个事）。在软件设计上，我们基本上不可能做出一个没有缺陷的设计，就像算法设计中的时间换空间、空间换时间一个道理。有时候，强一致性和高性能，高可用和高性能是有冲突的。软件设计从来都是trade-off（取舍）。</p>\n<p>另外，Write Back实现逻辑比较复杂，因为它需要track有哪些数据是被更新了的，需要刷到持久层上。操作系统的Write Back会在仅当这个Cache需要失效的时候，才会把它真正持久起来。比如，内存不够了，或是进程退出了等情况，这又叫lazy write。</p>\n<p>在Wikipedia上有一张Write Back的流程图，基本逻辑可以在下图中看到。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/6f/fd/6f7a59b05ddcb343f75ae2069b2a7efd.png?wh=1014*1292\" alt=\"\" /></p>\n<h1>缓存设计的重点</h1>\n<p>缓存更新的模式基本如前面所说，不过这还没完，缓存已经成为高并发高性能架构的一个关键组件了。现在，很多公司都在用Redis来搭建他们的缓存系统。一方面是因为Redis的数据结构比较丰富。另一方面，我们不能在Service内放Local Cache，一是每台机器的内存不够大，二是我们的Service有多个实例，负载均衡器会把请求随机分布到不同的实例。缓存需要在所有的Service 实例上都建好，这让我们的Service有了状态，更难管理了。</p>\n<p>所以，在分布式架构下，一般都需要一个外部的缓存集群。关于这个缓存集群，你需要保证的是内存要足够大，网络带宽也要好，因为缓存本质上是个内存和IO密集型的应用。</p>\n<p>另外，如果需要内存很大，那么你还要动用数据分片技术来把不同的缓存分布到不同的机器上。这样，可以保证我们的缓存集群可以不断地scale下去。关于数据分片的事，我会在后面讲述。</p>\n<p>缓存的好坏要看命中率。缓存的命中率高说明缓存有效，一般来说命中率到80%以上就算很高了。当然，有的网络为了追求更高的性能，要做到95%以上，甚至可能会把数据库里的数据几乎全部装进缓存中。这当然是不必要的，也是没有效率的，因为通常来说，热点数据只会是少数。</p>\n<p>另外，缓存是通过牺牲强一致性来提高性能的，这世上任何事情都不是免费的，所以并不是所有的业务都适合用缓存，这需要在设计的时候仔细调研好需求。使用缓存提高性能，就是会有数据更新的延迟。</p>\n<p>缓存数据的时间周期也需要好好设计，太长太短都不好，过期期限不宜太短，因为可能导致应用程序不断从数据存储检索数据并将其添加到缓存。同样，过期期限不宜太长，因为这会导致一些没人访问的数据还在内存中不过期，而浪费内存。</p>\n<p>使用缓存的时候，一般会使用LRU策略。也就是说，当内存不够需要有数据被清出内存时，会找最不活跃的数据清除。所谓最不活跃的意思是最长时间没有被访问过了。所以，开启LRU策略会让缓存在每个数据访问的时候把其调到前面，而要淘汰数据时，就从最后面开始淘汰。</p>\n<p>于是，对于LRU的缓存系统来说，其需要在key-value这样的非顺序的数据结构中维护一个顺序的数据结构，并在读缓存时，需要改变被访问数据在顺序结构中的排位。于是，我们的LRU在读写时都需要加锁（除非是单线程无并发），因此LRU可能会导致更慢的缓存存取的时间。这点要小心。</p>\n<p>最后，我们的世界是比较复杂的，很多网站都会被爬虫爬，要小心这些爬虫。因为这些爬虫可能会爬到一些很古老的数据，而程序会把这些数据加入到缓存中去，而导致缓存中那些真实的热点数据被挤出去（因为机器的速度足够快）。对此，一般来说，我们需要有一个爬虫保护机制，或是我们引导这些人去使用我们提供的外部API。在那边，我们可以有针对性地做多租户的缓存系统（也就是说，把用户和第三方开发者的缓存系统分离开来）。</p>\n<h1>小结</h1>\n<p>好了，我们来总结一下今天分享的主要内容。首先，缓存是为了加速数据访问，在数据库之上添加的一层机制。然后，我讲了几种典型的缓存模式，包括Cache Aside、Read/Write Through和Write Behind Caching以及它们各自的优缺点。</p>\n<p>最后，我介绍了缓存设计的重点，除了性能之外，在分布式架构下和公网环境下，对缓存集群、一致性、LRU的锁竞争、爬虫等多方面都需要考虑。下节课，我们讲述异步处理。希望对你有帮助。</p>\n<p>也欢迎你分享一下你接触到的缓存方式有哪些？怎样权衡一致性和缓存的效率？</p>\n<p>文末给出了《分布式系统设计模式》系列文章的目录，希望你能在这个列表里找到自己感兴趣的内容。</p>\n<ul>\n<li>弹力设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/3912\">认识故障和弹力设计</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/3917\">隔离设计Bulkheads</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/3926\">异步通讯设计Asynchronous</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4050\">幂等性设计Idempotency</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4086\">服务的状态State</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4087\">补偿事务Compensating Transaction</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4121\">重试设计Retry</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4241\">熔断设计Circuit Breaker</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4245\">限流设计Throttle</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4252\">降级设计degradation</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/4253\">弹力设计总结</a></li>\n</ul>\n</li>\n<li>管理设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/5175\">分布式锁Distributed Lock</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5819\">配置中心Configuration Management</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5909\">边车模式Sidecar</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/5920\">服务网格Service Mesh</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/6086\">网关模式Gateway</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/6283\">部署升级策略</a></li>\n</ul>\n</li>\n<li>性能设计篇\n<ul>\n<li><a href=\"https://time.geekbang.org/column/article/6282\">缓存Cache</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7036\">异步处理Asynchronous</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7045\">数据库扩展</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7047\">秒杀Flash Sales</a></li>\n<li><a href=\"https://time.geekbang.org/column/article/7086\">边缘计算Edge Computing</a></li>\n</ul>\n</li>\n</ul>\n","comments":[{"had_liked":false,"id":8210,"user_name":"翎逸","can_delete":false,"product_type":"c1","uid":1066302,"ip_address":"","ucode":"51037B3CD3770E","user_header":"https://static001.geekbang.org/account/avatar/00/10/45/3e/821754d5.jpg","comment_is_top":false,"comment_ctime":1525967890,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"160439757842","product_id":100002201,"comment_content":"感觉更多的是不是应该说下缓存的监控，雪崩，缓存和数据库的一致性，以及热点缓存处理等一些场景的处理，这样会觉得更深入一些","like_count":38,"discussions":[{"author":{"id":1307793,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo5WaRd8ibAozKXvIGWXKDq1CdxLhkdnRyyTKcgMDYaFDAaKqg2IpETOC3RacYoggGOhFMeMGicRXxA/132","nickname":"天机老人","note":"","ucode":"B553FBBF9DD41B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":5773,"discussion_content":"分布式这块的文章看下来，感觉不值专栏的价格！！！重要的，难点都不讨论","likes_number":7,"is_delete":false,"is_hidden":false,"ctime":1566462573,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1603271,"avatar":"","nickname":"Geek_f3a3d1","note":"","ucode":"E15FA1C3AB3174","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1307793,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo5WaRd8ibAozKXvIGWXKDq1CdxLhkdnRyyTKcgMDYaFDAaKqg2IpETOC3RacYoggGOhFMeMGicRXxA/132","nickname":"天机老人","note":"","ucode":"B553FBBF9DD41B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":123585,"discussion_content":"瞎说什么大实话。感觉在堆砌。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578405585,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5773,"ip_address":""},"score":123585,"extra":""},{"author":{"id":2446418,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/zdK3dSkFwicZHtx5CLAKFJRORRibq2YqvHOP0tySLxVx0X1oD9AJanan2wia2hHaswgxdrCzEEGyVgFTVZ8sElTzQ/132","nickname":"Geek_fbfc4f","note":"","ucode":"7010B242A3F474","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1307793,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eo5WaRd8ibAozKXvIGWXKDq1CdxLhkdnRyyTKcgMDYaFDAaKqg2IpETOC3RacYoggGOhFMeMGicRXxA/132","nickname":"天机老人","note":"","ucode":"B553FBBF9DD41B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":374514,"discussion_content":"我新用户买的，当做故事看看吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621226568,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":5773,"ip_address":""},"score":374514,"extra":""}]},{"author":{"id":1503506,"avatar":"https://static001.geekbang.org/account/avatar/00/16/f1/12/7dac30d6.jpg","nickname":"你为啥那么牛","note":"","ucode":"1ABC604A54A8F6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":319672,"discussion_content":"说这些有什么意义呢，都是造出来的名词","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1604075112,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1520703,"avatar":"https://static001.geekbang.org/account/avatar/00/17/34/3f/53aca22e.jpg","nickname":"ken","note":"","ucode":"DCAFD1DD5C6A0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394458,"discussion_content":"其实光看这个专栏是不可能把这些相关内容都讲到的，很多基本还是一个引子。而你提到的这些东西在redis书中都有提到。所以还是要多个地方资源互补来看。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631889840,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1033628,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c5/9c/c91fead4.jpg","nickname":"Garkett","note":"","ucode":"00CC7375E80578","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312901,"discussion_content":"感觉没说到实际有用的干货，一味讲概念真的没啥收获。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1602850246,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":211204,"user_name":"顾海","can_delete":false,"product_type":"c1","uid":1103602,"ip_address":"","ucode":"13F4E0A21975CE","user_header":"https://static001.geekbang.org/account/avatar/00/10/d6/f2/0601a60e.jpg","comment_is_top":false,"comment_ctime":1587914603,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"40242620267","product_id":100002201,"comment_content":"这篇文章偏科普，除此之外，我的总结<br>1.某些场景下,LocalCache比较有效，可以解决远程缓存热点数据问题。另外，可以通过多副本缓存解决热点数据的读问题，例如redis cluster的多多机制。<br>2.更新数据和(删除)更新缓存的先后顺序问题:一般是先更新数据库，再去操作缓存。缓存操作失败时可以通过重试操作缓存以实现最终一致性。如果是先操作缓存，再处理数据库，很有可能导致缓存中的是脏数据，而且不能实现最终一致性。<br>3.并发更新缓存时，存在旧数据覆盖新数据的可能。可以通过CAS机制比较缓存中的数据与待放去缓存的数据的版本，如果缓存中的数据比较新，则放弃本次的缓存操作。<br>4.缓存穿透，缓存雪崩问题","like_count":10,"discussions":[{"author":{"id":1043401,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/c9/b1b233cf.jpg","nickname":"小伟","note":"","ucode":"B631E56A112BDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297626,"discussion_content":"为了防止雪崩，在DB层会有有一层流控和降级手段，优先服务优质流量。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596988236,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8164,"user_name":"Black","can_delete":false,"product_type":"c1","uid":1074283,"ip_address":"","ucode":"BC3970032207F4","user_header":"https://static001.geekbang.org/account/avatar/00/10/64/6b/149a507a.jpg","comment_is_top":false,"comment_ctime":1525934334,"is_pvip":false,"replies":[{"id":"2394","content":"是的。这是为了整个系列的完整。","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1525963172,"ip_address":"","comment_id":8164,"utype":1}],"discussion_count":1,"race_medal":0,"score":"23000770814","product_id":100002201,"comment_content":"这篇的内容有大部分是跟之前博客上的一篇 缓存更新的套路 重复了","like_count":5,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417608,"discussion_content":"是的。这是为了整个系列的完整。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525963172,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8427,"user_name":"river","can_delete":false,"product_type":"c1","uid":1020724,"ip_address":"","ucode":"F86F0207C605B0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/34/c81f139f.jpg","comment_is_top":false,"comment_ctime":1526207840,"is_pvip":false,"replies":[{"id":"2520","content":"怎么会呢？","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1526275931,"ip_address":"","comment_id":8427,"utype":1}],"discussion_count":9,"race_medal":0,"score":"18706077024","product_id":100002201,"comment_content":"Cache aside 更新数据库 然后失效缓存，在读很高的情况下，会不会相当于缓存被击穿？","like_count":4,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417714,"discussion_content":"怎么会呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1526275931,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1975601,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/j4IFCUlYs4a6m6xmtQEEx70kOw59nzI4yciccagrqyydWGw5ibBSUeCSeun3tibZyKPUwRs8H828PictbHQCL7WsbQ/132","nickname":"Geek_ad84ed","note":"","ucode":"A35F36B17A907B","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":293824,"discussion_content":"会有一些加锁的机制防止这种高并发时缓存击穿的情况，保证只会有一个请求加载数据，其他请求等待数据加载到缓存后直接从缓存读","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1595682802,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1520703,"avatar":"https://static001.geekbang.org/account/avatar/00/17/34/3f/53aca22e.jpg","nickname":"ken","note":"","ucode":"DCAFD1DD5C6A0C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1975601,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/j4IFCUlYs4a6m6xmtQEEx70kOw59nzI4yciccagrqyydWGw5ibBSUeCSeun3tibZyKPUwRs8H828PictbHQCL7WsbQ/132","nickname":"Geek_ad84ed","note":"","ucode":"A35F36B17A907B","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":394464,"discussion_content":"如果要加锁的话，很多这样的业务逻辑都采用加锁的方式肯定不合适吧？我感觉用cache aside的方式，是会存在缓存击穿的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1631890229,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":293824,"ip_address":""},"score":394464,"extra":""}]},{"author":{"id":1015189,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7d/95/dd73022c.jpg","nickname":"我是曾经那个少年","note":"","ucode":"9F02F7FF147D14","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":579325,"discussion_content":"其实这种缓存击破   大家真的再生产环境中问到过？感觉都是一些面试题目。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1657353636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1095173,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b6/05/bb034c2c.jpg","nickname":"伟程","note":"","ucode":"E62433F24C14A1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":174484,"discussion_content":"哈哈哈读完一次就会把数据load到缓存了，不会被击穿的","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1581922316,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1020724,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/93/34/c81f139f.jpg","nickname":"river","note":"","ucode":"F86F0207C605B0","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1095173,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b6/05/bb034c2c.jpg","nickname":"伟程","note":"","ucode":"E62433F24C14A1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":209857,"discussion_content":"读很高的情况下这个第一次可能很多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584682423,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":174484,"ip_address":""},"score":209857,"extra":""},{"author":{"id":1033096,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","nickname":"如来神掌","note":"","ucode":"45E20FF935BD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1095173,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b6/05/bb034c2c.jpg","nickname":"伟程","note":"","ucode":"E62433F24C14A1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294732,"discussion_content":"该数据没有人查询过 ，第一次就大并发的访问。（冷门数据）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1595984758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":174484,"ip_address":""},"score":294732,"extra":""},{"author":{"id":1033096,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","nickname":"如来神掌","note":"","ucode":"45E20FF935BD2F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1095173,"avatar":"https://static001.geekbang.org/account/avatar/00/10/b6/05/bb034c2c.jpg","nickname":"伟程","note":"","ucode":"E62433F24C14A1","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":294733,"discussion_content":"还有一种情况: \n\n添加到了缓存，reids有设置数据失效的时间 ，这条数据刚好失效，大并发访问（热点数据）\n\n","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1595984854,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":174484,"ip_address":""},"score":294733,"extra":""}]},{"author":{"id":1153455,"avatar":"https://static001.geekbang.org/account/avatar/00/11/99/af/d29273e2.jpg","nickname":"饭粒","note":"","ucode":"4C3220B0D43997","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":536873,"discussion_content":"加锁或者用信号量工具限制热门Key的访问线程数。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638885657,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8121,"user_name":"W_T","can_delete":false,"product_type":"c1","uid":1044071,"ip_address":"","ucode":"1A78F28537E138","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/67/c146c144.jpg","comment_is_top":false,"comment_ctime":1525914664,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"18705783848","product_id":100002201,"comment_content":"Read&#47;Write Through 模式中对数据库的操作一定要交给交给缓存代理么，如果是这样就会带来两个问题：<br>1. 需要在缓存服务中实现数据库操作的代码，我从来没有这么做过，也不清楚目前主流缓存是否支持这样的操作。<br>2. 缓存服务与数据库之间建立了依赖。<br>我在工作中更常见的做法是由应用服务操作缓存以及数据库，这样的话感觉就跟前面的cache aside模式很像了。<br>可能是我对Read&#47;Write Through模式理解不深，说错的地方还请老师指正<br>","like_count":4,"discussions":[{"author":{"id":1033621,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eoh6rMNGKHZe7OLnd0sNTZAIMlG5UD5l4hj0ibQUXU1N9zqHx2uPnhuJevN40pDyCs5vfDVkgsETZQ/132","nickname":"0x7c00","note":"","ucode":"D2E5992E994290","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":253340,"discussion_content":"数据库的读写操作可以注入到缓存代理里面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1588227771,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053485,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/2d/ad1bfe92.jpg","nickname":"江湖中人","note":"","ucode":"9E464AE9CC62EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124680,"discussion_content":"无需改造缓存服务器，可以在自己的应用中实现 Read/Write Through模式。比如在应用中创建一个Manager，这个Manager 依赖数据库和缓存，然后在Manager中实现 Read/Write Through 的逻辑。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578447400,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1457246,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVZRHorm7z67yJxOCpYWJESPfhia00RDg4oicvPuyCwTKln2BFRMiahOKz9z22RnnEmickA64bHdB7pA/132","nickname":"土豆小小","note":"","ucode":"5621EEDE50EA48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1053485,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/2d/ad1bfe92.jpg","nickname":"江湖中人","note":"","ucode":"9E464AE9CC62EE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246981,"discussion_content":"那其实也是需要手动维护两个数据存储，各自不想关，只不过是在缓存的操作里面操作了数据库吧。那前两个策略的区别就在于清理操作的实现位置？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587793511,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":124680,"ip_address":""},"score":246981,"extra":""}]}]},{"had_liked":false,"id":170749,"user_name":"知行合一","can_delete":false,"product_type":"c1","uid":1521486,"ip_address":"","ucode":"2B8E634FC4CFB7","user_header":"https://static001.geekbang.org/account/avatar/00/17/37/4e/5c3153b2.jpg","comment_is_top":false,"comment_ctime":1578705366,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"14463607254","product_id":100002201,"comment_content":"三大缓存设计模式，cache aside，read&#47;write through，write behind cache；缓存是以空间换时间，牺牲了强一致性，带来高性能和可用性。缓存分片希望也能分析分析","like_count":3},{"had_liked":false,"id":49059,"user_name":"shawn","can_delete":false,"product_type":"c1","uid":1010221,"ip_address":"","ucode":"8F6A8C7920996E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/6a/2d/ec4ed8ce.jpg","comment_is_top":false,"comment_ctime":1544596425,"is_pvip":false,"discussion_count":6,"race_medal":0,"score":"14429498313","product_id":100002201,"comment_content":"你好，我看了“架构之路”的公众号，<br>https:&#47;&#47;mp.weixin.qq.com&#47;s?__biz=MjM5ODYxMDA5OQ==&amp;mid=404202261&amp;idx=1&amp;sn=1b8254ba5013952923bdc21e0579108e&amp;scene=21#wechat_redirect<br><br>这里说了大部分场景是建议 先 “缓存失效 -&gt; 再更新数据”。<br><br>比如：先写数据再淘汰缓存会有如下情况：<br>“假设先写数据库，再淘汰缓存：第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致【如上图：db中是新数据，cache中是旧数据】。”<br><br>我想听听你的看法。","like_count":3,"discussions":[{"author":{"id":1244283,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fc/7b/adfef198.jpg","nickname":"一位不愿透漏姓名的足球名宿","note":"","ucode":"2A67AD14C1F436","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350355,"discussion_content":"缓存失效 -> 再更新数据  我理解我们一般场景大多数读多写少，如果采用这种方式，有大概率被其他读线程抢先吧脏数据写到缓存中","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1613821748,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043401,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/c9/b1b233cf.jpg","nickname":"小伟","note":"","ucode":"B631E56A112BDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297623,"discussion_content":"“缓存失效 -> 再更新数据”： 如果写缓存成功，更新数据库失败，那么结果算成功还是失败呢？如果算成功，那么后面数据可能会丢；A: 如果算失败，那么别人会在TTL内读到脏数据；\n\n&#34;更新数数据库 -> 缓存失效&#34;: 如果写数据库成功，但是写缓存失败，一般会返回成功（以数据库数据为准），那么在TTL内缓存里数据还是上一版本的数据，这个在业务场景下，要比上面A处更能被接受（用户可能以为是数据延迟而已）；\n\n综上所述，皓叔讲的是对的，个人理解。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1596988008,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1053485,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/2d/ad1bfe92.jpg","nickname":"江湖中人","note":"","ucode":"9E464AE9CC62EE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":124761,"discussion_content":"先写库再失效缓存会出现你说的这种情况，但概率会比较低吧（个人觉得失效缓存操作失败的概率会比较低）。这种情况，只能靠 缓存过期 或 被LRU算法淘汰 来更新缓存了。\n\n如果先失效缓存再更新库数据，也会有问题：若在失效缓存完成，但更新库数据成功之前，有其他线程来读数据，则会读到库中的旧数据，并将其放入缓存。这样缓存中的就是旧数据了。\n\n你给的链接里，通过在应用中进行改造，倒是解决了 先失效缓存再更新库数据 会出现的问题。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578449935,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":3,"child_discussions":[{"author":{"id":1073487,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/4f/e0b71e72.jpg","nickname":"我是谁","note":"","ucode":"D6C67E29D62EA9","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1053485,"avatar":"https://static001.geekbang.org/account/avatar/00/10/13/2d/ad1bfe92.jpg","nickname":"江湖中人","note":"","ucode":"9E464AE9CC62EE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":158797,"discussion_content":"先写数据库，再失效缓存。如果缓存失效失败，数据库回滚就行了吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1580627372,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":124761,"ip_address":""},"score":158797,"extra":""},{"author":{"id":1244283,"avatar":"https://static001.geekbang.org/account/avatar/00/12/fc/7b/adfef198.jpg","nickname":"一位不愿透漏姓名的足球名宿","note":"","ucode":"2A67AD14C1F436","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1073487,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/4f/e0b71e72.jpg","nickname":"我是谁","note":"","ucode":"D6C67E29D62EA9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":350354,"discussion_content":"这样事务不就被拉长了么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1613821476,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":158797,"ip_address":""},"score":350354,"extra":""},{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1073487,"avatar":"https://static001.geekbang.org/account/avatar/00/10/61/4f/e0b71e72.jpg","nickname":"我是谁","note":"","ucode":"D6C67E29D62EA9","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389112,"discussion_content":"失效缓存失败时，可以通过MQ来重试，成功为止","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1629123649,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":158797,"ip_address":""},"score":389112,"extra":""}]}]},{"had_liked":false,"id":11108,"user_name":"冰糕不冰","can_delete":false,"product_type":"c1","uid":1134761,"ip_address":"","ucode":"B754FE464BA426","user_header":"https://static001.geekbang.org/account/avatar/00/11/50/a9/3f8c7418.jpg","comment_is_top":false,"comment_ctime":1527851690,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"14412753578","product_id":100002201,"comment_content":"皓哥，对于很多需要统计的数据或者筛选条件复杂的怎么利用缓存了？  ","like_count":3,"discussions":[{"author":{"id":1043401,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/c9/b1b233cf.jpg","nickname":"小伟","note":"","ucode":"B631E56A112BDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297625,"discussion_content":"你的问题没有说明清楚，现在遇到什么问题，瓶颈是什么？业务需求是怎样的。\n\n没有这些，别人也只能从大面上回答你问题，是吧。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596988123,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":237829,"user_name":"如来神掌","can_delete":false,"product_type":"c1","uid":1033096,"ip_address":"","ucode":"45E20FF935BD2F","user_header":"https://static001.geekbang.org/account/avatar/00/0f/c3/88/d16816a8.jpg","comment_is_top":false,"comment_ctime":1595983938,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10185918530","product_id":100002201,"comment_content":"Cache Aside 的方式就挺好，简单好用，脏数据发生的可能性还非常小","like_count":2},{"had_liked":false,"id":171461,"user_name":"dfuru","can_delete":false,"product_type":"c1","uid":1138771,"ip_address":"","ucode":"E256C99CA42511","user_header":"https://static001.geekbang.org/account/avatar/00/11/60/53/7d669cd7.jpg","comment_is_top":false,"comment_ctime":1578926311,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"10168860903","product_id":100002201,"comment_content":"LRU 的锁竞争,  有没有什么解决方法？谢谢","like_count":2,"discussions":[{"author":{"id":1285055,"avatar":"https://static001.geekbang.org/account/avatar/00/13/9b/bf/a76eadff.jpg","nickname":"小嘟嘟","note":"","ucode":"1584DD1402502D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549705,"discussion_content":"分段锁","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644216920,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1043401,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/c9/b1b233cf.jpg","nickname":"小伟","note":"","ucode":"B631E56A112BDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297622,"discussion_content":"分而治之","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596987735,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":221707,"user_name":"Scarlett","can_delete":false,"product_type":"c1","uid":1369071,"ip_address":"","ucode":"D519A28CE1F828","user_header":"https://static001.geekbang.org/account/avatar/00/14/e3/ef/01cf3c83.jpg","comment_is_top":false,"comment_ctime":1590571113,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5885538409","product_id":100002201,"comment_content":"理论和实践（业务使用分布式缓存常见问题及解决方案）结合起来会比较好吧。","like_count":1},{"had_liked":false,"id":212174,"user_name":"simonren","can_delete":false,"product_type":"c1","uid":1974906,"ip_address":"","ucode":"DFB59C705310C2","user_header":"","comment_is_top":false,"comment_ctime":1588070820,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5883038116","product_id":100002201,"comment_content":"首先，缓存是为了加速数据访问，在数据库之上添加的一层机制。几种典型的缓存模式，包括 Cache Aside、Read&#47;Write Through 和 Write Behind Caching 以及它们各自的优缺点。<br>缓存设计的重点，除了性能之外，在分布式架构下和公网环境下，对缓存集群、一致性、LRU 的锁竞争、爬虫等多方面都需要考虑。","like_count":1},{"had_liked":false,"id":211650,"user_name":"45℃仰望幸福","can_delete":false,"product_type":"c1","uid":1447045,"ip_address":"","ucode":"5B759A9C568305","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/m9qlj6C9n3eI9N21vavIKH1rC4rSS9icUySw8gFqlovaKON3cOnkLh8JpQopLQy6cTiczcAP7yiajqVh7picKR1dgQ/132","comment_is_top":false,"comment_ctime":1587992483,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882959779","product_id":100002201,"comment_content":"缓存系统，就是一个哈希表。只是通常哈希表的场景都是在本机，把哈希表放到远程的机器上，本机通过网络访问（增删查改）哈希表，就成了现在的缓存系统了。<br>我们还可以尝试强化这个哈希表，比如支持存储各种类型的数据；存储有价值数据的哈希表时，需要定时备份这个哈希表；访问的频率太大了，需要将数据分散到多个远程的哈希表中；远程的哈希表节点多了，又该如何管理他们等等。所以缓存系统只是哈希表的一种延伸，它只是一种数据结构的应用。比如Redis。<br>","like_count":1},{"had_liked":false,"id":172172,"user_name":"Richie","can_delete":false,"product_type":"c1","uid":1019588,"ip_address":"","ucode":"12314EF0347693","user_header":"https://static001.geekbang.org/account/avatar/00/0f/8e/c4/8d1150f3.jpg","comment_is_top":false,"comment_ctime":1579101117,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5874068413","product_id":100002201,"comment_content":"如果对比 Cache Aside 和 Read &#47; Write Through 两者的流程图，会发现查询的时候基本是一样的，只有更新操作有点差别。但其实他们最大的区别不是在查询和更新流程上，而是前者需要在应用中去管理缓存的命中、失效和更新，而后者则由后端存储去控制命中、失效和更新策略，对应用来说更简单了。<br><br>当然简单也是有代价的，这就意味着所有的数据都会被缓存了，而且都是按照相同的缓存策略。当然也可以通过暴露参数给应用去提供更多的灵活性，但这样事情就变得复杂了。","like_count":1},{"had_liked":false,"id":112390,"user_name":"陈华","can_delete":false,"product_type":"c1","uid":1082730,"ip_address":"","ucode":"3AF9E8EB39E507","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtS26SJpSF7JLu9pusGsy1Qln0NdQg1eV2YKOJxpX2QXaBuuyXMqZY3fm0rhzKwsqN5aa6CVNOQQ/132","comment_is_top":false,"comment_ctime":1562727899,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5857695195","product_id":100002201,"comment_content":"大家缓存一般怎么用的啊。 我这里有一个疑问。<br><br>比如我有一个组织机构表， 然后我有好几个针对组织机构表的查询方法， 然后我spring boot 直接对这些方法进行缓存。<br><br>那么问题是：一旦我更新了某个机构的信息。 我想这个时候应该对上述多个方法的缓存都做失效处理。<br>大家一般是怎么做的啊？，<br>首先spring boot 的cache是自动根据所有参数信息来生成的key， 我更新机构信息的时候，都不知道应该让那些key失效。还有即使知道了这些key的信息， 那程序上我得一直维护一个  缓存keys 和 update 方法之间的映射？那不得在所有缓存和需要更新的方法加一层aop，动态维护这个映射关系？,","like_count":1,"discussions":[{"author":{"id":1383886,"avatar":"https://static001.geekbang.org/account/avatar/00/15/1d/ce/1fa20222.jpg","nickname":"九千胜","note":"","ucode":"0178674B6135E6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":133145,"discussion_content":"缓存的规则可以自己制定，更新的时候可以先更新库，更新成功则再更新缓存信息。或者触发更新检测，让程序只检查结果，一致则不动，不一致则重新缓存数据。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1578930810,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8524,"user_name":"river","can_delete":false,"product_type":"c1","uid":1020724,"ip_address":"","ucode":"F86F0207C605B0","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/34/c81f139f.jpg","comment_is_top":false,"comment_ctime":1526298160,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"5821265456","product_id":100002201,"comment_content":"Cache aside 更新数据库 然后失效缓存。失效时读不到缓存，不是会打到数据库的流量很高？","like_count":1,"discussions":[{"author":{"id":1014665,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/7b/89/34f2cbcc.jpg","nickname":"杨宇","note":"","ucode":"EB74DF6E269F03","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":389114,"discussion_content":"反之，如果更新数据库再更新缓存：一来缓存可能来自多张表 需要查询组装，二来并发更新时可能后写旧值，三来该缓存不一定是热数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1629123939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1227107,"avatar":"https://static001.geekbang.org/account/avatar/00/12/b9/63/a3b11794.jpg","nickname":"麦抠","note":"","ucode":"875DEA26F38BAB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":164339,"discussion_content":"我也觉得","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1581169855,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8281,"user_name":"FF","can_delete":false,"product_type":"c1","uid":1001615,"ip_address":"","ucode":"26349F32B406D7","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/8f/7ecd4eed.jpg","comment_is_top":false,"comment_ctime":1526042944,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"5821010240","product_id":100002201,"comment_content":"write through 这种模式，如果没有命中缓存更新数据库后返回，后面缓存谁来更新？这种更新想想好像很复杂","like_count":1,"discussions":[{"author":{"id":1043401,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/eb/c9/b1b233cf.jpg","nickname":"小伟","note":"","ucode":"B631E56A112BDC","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297628,"discussion_content":"HI，FF，文章流程图里就有read的情况（分命中和不命中两种情况），仔细阅读哦","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596988383,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":321734,"user_name":"花下眠","can_delete":false,"product_type":"c1","uid":1183854,"ip_address":"","ucode":"F14C138BF7AEA7","user_header":"https://static001.geekbang.org/account/avatar/00/12/10/6e/a21968a9.jpg","comment_is_top":false,"comment_ctime":1637028415,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1637028415","product_id":100002201,"comment_content":"本文收获：<br>1、缓存更新模式，常用Cache Aside,有并发缺陷<br>2、LRU算法可以借助队列实现<br>3、防止爬虫","like_count":0},{"had_liked":false,"id":320943,"user_name":"方勇(gopher)","can_delete":false,"product_type":"c1","uid":1290625,"ip_address":"","ucode":"D199911C4CFEF5","user_header":"https://static001.geekbang.org/account/avatar/00/13/b1/81/13f23d1e.jpg","comment_is_top":false,"comment_ctime":1636592250,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1636592250","product_id":100002201,"comment_content":"爬虫确实是个风险，降低了缓存命中率，有时候还会穿透缓存","like_count":0},{"had_liked":false,"id":224220,"user_name":"piboye","can_delete":false,"product_type":"c1","uid":1066752,"ip_address":"","ucode":"7CFD8712857A85","user_header":"https://static001.geekbang.org/account/avatar/00/10/47/00/3202bdf0.jpg","comment_is_top":false,"comment_ctime":1591319242,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1591319242","product_id":100002201,"comment_content":"lru不一定要锁，可以无锁实现","like_count":0},{"had_liked":false,"id":211379,"user_name":"刘欣洲","can_delete":false,"product_type":"c1","uid":1020871,"ip_address":"","ucode":"767B7D80D01623","user_header":"https://static001.geekbang.org/account/avatar/00/0f/93/c7/1640226d.jpg","comment_is_top":false,"comment_ctime":1587955203,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587955203","product_id":100002201,"comment_content":"缓存用好了很关键，老师讲的很好","like_count":0},{"had_liked":false,"id":210616,"user_name":"土豆小小","can_delete":false,"product_type":"c1","uid":1457246,"ip_address":"","ucode":"5621EEDE50EA48","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVZRHorm7z67yJxOCpYWJESPfhia00RDg4oicvPuyCwTKln2BFRMiahOKz9z22RnnEmickA64bHdB7pA/132","comment_is_top":false,"comment_ctime":1587796567,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587796567","product_id":100002201,"comment_content":"Write its previous data back to the lower memory看不懂，所以一个字段是有两个数据吗（previous data和现在data）？，读操作中把previous data放入硬盘，再放入内存，意味着使用的旧数据吗？写操作中过程差不多，最后的阶段是对内存的数据是两个备份是吗？","like_count":0},{"had_liked":false,"id":210597,"user_name":"土豆小小","can_delete":false,"product_type":"c1","uid":1457246,"ip_address":"","ucode":"5621EEDE50EA48","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVZRHorm7z67yJxOCpYWJESPfhia00RDg4oicvPuyCwTKln2BFRMiahOKz9z22RnnEmickA64bHdB7pA/132","comment_is_top":false,"comment_ctime":1587794155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1587794155","product_id":100002201,"comment_content":"Write Through的操作。我的理解是这里数据库找到直接返回，下一次操作相同缓存的就是Read Through了，在读的时候再从数据库放入缓存中。这里的话感觉针对很多已经下载但是没有第二次使用的资源时，可以减少一次从数据库到内存的复制，不知道理解的对不对","like_count":0},{"had_liked":false,"id":169244,"user_name":"文刂 氵共 超","can_delete":false,"product_type":"c1","uid":1282813,"ip_address":"","ucode":"C2CE1512D23012","user_header":"https://static001.geekbang.org/account/avatar/00/13/92/fd/6b0e58fe.jpg","comment_is_top":false,"comment_ctime":1578300565,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1578300565","product_id":100002201,"comment_content":"坚持学习，学习笔记 https:&#47;&#47;mubu.com&#47;colla&#47;o4SSnpN4B0","like_count":0},{"had_liked":false,"id":112388,"user_name":"陈华","can_delete":false,"product_type":"c1","uid":1082730,"ip_address":"","ucode":"3AF9E8EB39E507","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKtS26SJpSF7JLu9pusGsy1Qln0NdQg1eV2YKOJxpX2QXaBuuyXMqZY3fm0rhzKwsqN5aa6CVNOQQ/132","comment_is_top":false,"comment_ctime":1562727649,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1562727649","product_id":100002201,"comment_content":"大家缓存一般怎么用的啊。 我这里有一个疑问。<br><br>比如我有一个组织机构表， 然后我又好几个正对组织机构表的查询方法， 然后我spring boot 直接对这些方法进行缓存。<br><br>那么问题是：一旦我更新了某个机构的信息。 我想这个时候应该对上述多个方法的缓存都做失效处理。<br>关键是怎么做啊？，<br>首先spring boot 的cache是自动根据所有参数信息来生成的key， 我更新机构信息的时候，都不知道应该让那些key失效。还有即使知道了这些key的信息， 那程序上我得一直维护一个  缓存keys 和 update 方法之间的映射？,","like_count":0},{"had_liked":false,"id":109807,"user_name":"黄绳霖","can_delete":false,"product_type":"c1","uid":1129633,"ip_address":"","ucode":"380272F59D9507","user_header":"https://static001.geekbang.org/account/avatar/00/11/3c/a1/a45fef84.jpg","comment_is_top":false,"comment_ctime":1562116013,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1562116013","product_id":100002201,"comment_content":"Read&#47;Write Through怎么避免并发造成的脏数据，难道要在数据服务上加锁吗？","like_count":0},{"had_liked":false,"id":103536,"user_name":"edisonhuang","can_delete":false,"product_type":"c1","uid":1530167,"ip_address":"","ucode":"BB2F639A779F96","user_header":"https://static001.geekbang.org/account/avatar/00/17/59/37/bd2de0a4.jpg","comment_is_top":false,"comment_ctime":1560471987,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1560471987","product_id":100002201,"comment_content":"缓存是一个提高系统性能的关键模块，通常一个系统的性能瓶颈会出现在数据库，而数据库增删改查的操作里，涉及到写的操作是带来性能瓶颈的地方。通常大多数的系统操作都是读多写少，写的过程因为要保证数据的一致性，因此在写的过程需要加锁，没有缓存会带来异能的极大损耗。<br>缓存的实现分三种方式，cache aside，read write through，write back。缓存的替换算法一般是LRU替换算法，lru在存取过程中要加锁。","like_count":0,"discussions":[{"author":{"id":1457246,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVZRHorm7z67yJxOCpYWJESPfhia00RDg4oicvPuyCwTKln2BFRMiahOKz9z22RnnEmickA64bHdB7pA/132","nickname":"土豆小小","note":"","ucode":"5621EEDE50EA48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246993,"discussion_content":"数据库也可以使用LRU，可以加一个维度磁盘容量","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587794326,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":22573,"user_name":"~L.yy、","can_delete":false,"product_type":"c1","uid":1042650,"ip_address":"","ucode":"BD48129B83C4D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e8/da/f794db0f.jpg","comment_is_top":false,"comment_ctime":1535799307,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1535799307","product_id":100002201,"comment_content":"数据在本地做了缓存，这些数据由下游的一组服务提供，当缓存过期时，将会穿透到下游去取数据。若下游的服务出现波动，将导致缓存的更新时间变长，在这个区间里的请求将全部会穿透，可能会导致服务过载。请问下老师有没有好的方式优化下这个场景","like_count":0,"discussions":[{"author":{"id":1457246,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVZRHorm7z67yJxOCpYWJESPfhia00RDg4oicvPuyCwTKln2BFRMiahOKz9z22RnnEmickA64bHdB7pA/132","nickname":"土豆小小","note":"","ucode":"5621EEDE50EA48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246994,"discussion_content":"我看过一篇文章是：1.Lock 第一人查DB，做缓存，剩余人二次查询缓存","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587794439,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":11033,"user_name":"A圆规","can_delete":false,"product_type":"c1","uid":1145315,"ip_address":"","ucode":"EBDDB592EA1BE4","user_header":"https://static001.geekbang.org/account/avatar/00/11/79/e3/9c84f86e.jpg","comment_is_top":false,"comment_ctime":1527811162,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1527811162","product_id":100002201,"comment_content":"Cache aside 需要处理并发读问题，缓存失效时多个读会打到数据库","like_count":0,"discussions":[{"author":{"id":1457246,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLVZRHorm7z67yJxOCpYWJESPfhia00RDg4oicvPuyCwTKln2BFRMiahOKz9z22RnnEmickA64bHdB7pA/132","nickname":"土豆小小","note":"","ucode":"5621EEDE50EA48","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":246995,"discussion_content":"所以多读的时候为什么要并发呢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587794503,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":8113,"user_name":"坤","can_delete":false,"product_type":"c1","uid":1042732,"ip_address":"","ucode":"40FBEA76DF32FD","user_header":"https://static001.geekbang.org/account/avatar/00/0f/e9/2c/21ba186e.jpg","comment_is_top":false,"comment_ctime":1525913476,"is_pvip":false,"replies":[{"id":"2377","content":"建数据索引服务","user_name":"作者回复","user_name_real":"左耳朵","uid":"1001269","ctime":1525940026,"ip_address":"","comment_id":8113,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1525913476","product_id":100002201,"comment_content":"陈皓老师好，redis 分片热点问题，有没有什么好的解决方案？","like_count":0,"discussions":[{"author":{"id":1001269,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/47/35/89726f5f.jpg","nickname":"左耳朵","note":"","ucode":"8A4741D677702E","race_medal":0,"user_type":2,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":417586,"discussion_content":"建数据索引服务","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1525940026,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}