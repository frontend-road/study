{"id":202779,"title":"03 | 序列化：对象怎么在网络中传输？","content":"<p>你好，我是何小锋。上一讲我讲解了在RPC框架中，如何设计可扩展的、向后兼容的协议，其关键点就是利用好Header中的扩展字段以及Payload中的扩展字段，通过扩展字段向后兼容。</p><p>那么承接上一讲的一个重点，今天我会讲解下RPC框架中的序列化。要知道，在不同的场景下合理地选择序列化方式，对提升RPC框架整体的稳定性和性能是至关重要的。</p><h2>为什么需要序列化？</h2><p>首先，我们得知道什么是序列化与反序列化。</p><p>我们先回顾下<a href=\"https://time.geekbang.org/column/article/199650\">[第 01 讲]</a> 介绍过的RPC原理的内容，在描述RPC通信流程的时候我说过：</p><p>网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象。对象是不能直接在网络中传输的，所以我们需要提前把它转成可传输的二进制，并且要求转换算法是可逆的，这个过程我们一般叫做“序列化”。 这时，服务提供方就可以正确地从二进制数据中分割出不同的请求，同时根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象，这个过程我们称之为“反序列化”。</p><p>这两个过程如下图所示：</p><p><img src=\"https://static001.geekbang.org/resource/image/d2/04/d215d279ef8bfbe84286e81174b4e704.jpg\" alt=\"\" title=\"序列化与反序列化\"></p><p><strong>总结来说，</strong>序列化就是将对象转换成二进制数据的过程，而反序列就是反过来将二进制转换为对象的过程。</p><p>那么RPC框架为什么需要序列化呢？还是请你回想下RPC的通信流程：</p><!-- [[[read_end]]] --><p><img src=\"https://static001.geekbang.org/resource/image/82/59/826a6da653c4093f3dc3f0a833915259.jpg\" alt=\"\" title=\"RPC通信流程图\"></p><p>不妨借用个例子帮助你理解，比如发快递，我们要发一个需要自行组装的物件。发件人发之前，会把物件拆开装箱，这就好比序列化；这时候快递员来了，不能磕碰呀，那就要打包，这就好比将序列化后的数据进行编码，封装成一个固定格式的协议；过了两天，收件人收到包裹了，就会拆箱将物件拼接好，这就好比是协议解码和反序列化。</p><p>所以现在你清楚了吗？因为网络传输的数据必须是二进制数据，所以在RPC调用中，对入参对象与返回值对象进行序列化与反序列化是一个必须的过程。</p><h2>有哪些常用的序列化？</h2><p>那这么看来，你会不会觉得这个过程很简单呢？实则不然，很复杂。我们可以先看看都有哪些常用的序列化，下面我来简单地介绍下几种常用的序列化方式。</p><h3>JDK原生序列化</h3><p>如果你会使用Java语言开发，那么你一定知道JDK原生的序列化，下面是JDK序列化的一个例子：</p><pre><code>import java.io.*;\n\npublic class Student implements Serializable {\n    //学号\n    private int no;\n    //姓名\n    private String name;\n\n    public int getNo() {\n        return no;\n    }\n\n    public void setNo(int no) {\n        this.no = no;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return &quot;Student{&quot; +\n                &quot;no=&quot; + no +\n                &quot;, name='&quot; + name + '\\'' +\n                '}';\n    }\n\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        String home = System.getProperty(&quot;user.home&quot;);\n        String basePath = home + &quot;/Desktop&quot;;\n        FileOutputStream fos = new FileOutputStream(basePath + &quot;student.dat&quot;);\n        Student student = new Student();\n        student.setNo(100);\n        student.setName(&quot;TEST_STUDENT&quot;);\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(student);\n        oos.flush();\n        oos.close();\n\n        FileInputStream fis = new FileInputStream(basePath + &quot;student.dat&quot;);\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        Student deStudent = (Student) ois.readObject();\n        ois.close();\n\n        System.out.println(deStudent);\n\n    }\n}\n</code></pre><p>我们可以看到，JDK自带的序列化机制对使用者而言是非常简单的。序列化具体的实现是由ObjectOutputStream完成的，而反序列化的具体实现是由ObjectInputStream完成的。</p><p>那么JDK的序列化过程是怎样完成的呢？我们看下下面这张图：</p><p><img src=\"https://static001.geekbang.org/resource/image/7e/9f/7e2616937e3bc5323faf3ba4c09d739f.jpg\" alt=\"\" title=\"ObjectOutputStream序列化过程图\"></p><p>序列化过程就是在读取对象数据的时候，不断加入一些特殊分隔符，这些特殊分隔符用于在反序列化过程中截断用。</p><ul>\n<li>头部数据用来声明序列化协议、序列化版本，用于高低版本向后兼容</li>\n<li>对象数据主要包括类名、签名、属性名、属性类型及属性值，当然还有开头结尾等数据，除了属性值属于真正的对象值，其他都是为了反序列化用的元数据</li>\n<li>存在对象引用、继承的情况下，就是递归遍历“写对象”逻辑</li>\n</ul><p><strong>实际上任何一种序列化框架，核心思想就是设计一种序列化协议</strong>，将对象的类型、属性类型、属性值一一按照固定的格式写到二进制字节流中来完成序列化，再按照固定的格式一一读出对象的类型、属性类型、属性值，通过这些信息重新创建出一个新的对象，来完成反序列化。</p><h3>JSON</h3><p>JSON可能是我们最熟悉的一种序列化格式了，JSON是典型的Key-Value方式，没有数据类型，是一种文本型序列化框架，JSON的具体格式和特性，网上相关的资料非常多，这里就不再介绍了。</p><p>他在应用上还是很广泛的，无论是前台Web用Ajax调用、用磁盘存储文本类型的数据，还是基于HTTP协议的RPC框架通信，都会选择JSON格式。</p><p>但用JSON进行序列化有这样两个问题，你需要格外注意：</p><ul>\n<li>JSON进行序列化的额外空间开销比较大，对于大数据量服务这意味着需要巨大的内存和磁盘开销；</li>\n<li>JSON没有类型，但像Java这种强类型语言，需要通过反射统一解决，所以性能不会太好。</li>\n</ul><p>所以如果RPC框架选用JSON序列化，服务提供者与服务调用者之间传输的数据量要相对较小，否则将严重影响性能。</p><h3>Hessian</h3><p>Hessian是动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架。Hessian协议要比JDK、JSON更加紧凑，性能上要比JDK、JSON序列化高效很多，而且生成的字节数也更小。</p><p>使用代码示例如下：</p><pre><code>Student student = new Student();\nstudent.setNo(101);\nstudent.setName(&quot;HESSIAN&quot;);\n\n//把student对象转化为byte数组\nByteArrayOutputStream bos = new ByteArrayOutputStream();\nHessian2Output output = new Hessian2Output(bos);\noutput.writeObject(student);\noutput.flushBuffer();\nbyte[] data = bos.toByteArray();\nbos.close();\n\n//把刚才序列化出来的byte数组转化为student对象\nByteArrayInputStream bis = new ByteArrayInputStream(data);\nHessian2Input input = new Hessian2Input(bis);\nStudent deStudent = (Student) input.readObject();\ninput.close();\n\nSystem.out.println(deStudent);\n</code></pre><p>相对于JDK、JSON，由于Hessian更加高效，生成的字节数更小，有非常好的兼容性和稳定性，所以Hessian更加适合作为RPC框架远程通信的序列化协议。</p><p>但Hessian本身也有问题，官方版本对Java里面一些常见对象的类型不支持，比如：</p><ul>\n<li>Linked系列，LinkedHashMap、LinkedHashSet等，但是可以通过扩展CollectionDeserializer类修复；</li>\n<li>Locale类，可以通过扩展ContextSerializerFactory类修复；</li>\n<li>Byte/Short反序列化的时候变成Integer。</li>\n</ul><p>以上这些情况，你在实践时需要格外注意。</p><h3>Protobuf</h3><p>Protobuf  是 Google 公司内部的混合语言数据标准，是一种轻便、高效的结构化数据存储格式，可以用于结构化数据序列化，支持Java、Python、C++、Go等语言。Protobuf使用的时候需要定义IDL（Interface description language），然后使用不同语言的IDL编译器，生成序列化工具类，它的优点是：</p><ul>\n<li>序列化后体积相比 JSON、Hessian小很多；</li>\n<li>IDL能清晰地描述语义，所以足以帮助并保证应用程序之间的类型不会丢失，无需类似 XML 解析器；</li>\n<li>序列化反序列化速度很快，不需要通过反射获取类型；</li>\n<li>消息格式升级和兼容性不错，可以做到向后兼容。</li>\n</ul><p>使用代码示例如下：</p><pre><code>/**\n *\n * // IDl 文件格式\n * synax = &quot;proto3&quot;;\n * option java_package = &quot;com.test&quot;;\n * option java_outer_classname = &quot;StudentProtobuf&quot;;\n *\n * message StudentMsg {\n * //序号\n * int32 no = 1;\n * //姓名\n * string name = 2;\n * }\n * \n */\n \nStudentProtobuf.StudentMsg.Builder builder = StudentProtobuf.StudentMsg.newBuilder();\nbuilder.setNo(103);\nbuilder.setName(&quot;protobuf&quot;);\n\n//把student对象转化为byte数组\nStudentProtobuf.StudentMsg msg = builder.build();\nbyte[] data = msg.toByteArray();\n\n//把刚才序列化出来的byte数组转化为student对象\nStudentProtobuf.StudentMsg deStudent = StudentProtobuf.StudentMsg.parseFrom(data);\n\nSystem.out.println(deStudent);\n</code></pre><p>Protobuf  非常高效，但是对于具有反射和动态能力的语言来说，这样用起来很费劲，这一点就不如Hessian，比如用Java的话，这个预编译过程不是必须的，可以考虑使用Protostuff。</p><p>Protostuff不需要依赖IDL文件，可以直接对Java领域对象进行反/序列化操作，在效率上跟Protobuf差不多，生成的二进制格式和Protobuf是完全相同的，可以说是一个Java版本的Protobuf序列化框架。但在使用过程中，我遇到过一些不支持的情况，也同步给你：</p><ul>\n<li>不支持null；</li>\n<li>ProtoStuff不支持单纯的Map、List集合对象，需要包在对象里面。</li>\n</ul><h2>RPC框架中如何选择序列化？</h2><p>我刚刚简单地介绍了几种最常见的序列化协议，其实远不止这几种，还有 Message pack、kryo等。那么面对这么多的序列化协议，在RPC框架中我们该如何选择呢？</p><p>首先你可能想到的是性能和效率，不错，这的确是一个非常值得参考的因素。我刚才讲过，序列化与反序列化过程是RPC调用的一个必须过程，那么序列化与反序列化的性能和效率势必将直接关系到RPC框架整体的性能和效率。</p><p>那除了这点，你还想到了什么？</p><p>对，还有空间开销，也就是序列化之后的二进制数据的体积大小。序列化后的字节数据体积越小，网络传输的数据量就越小，传输数据的速度也就越快，由于RPC是远程调用，那么网络传输的速度将直接关系到请求响应的耗时。</p><p>现在请你再想想，还有什么因素可以影响到我们的选择？</p><p>没错，就是序列化协议的通用性和兼容性。在RPC的运营中，序列化问题恐怕是我碰到的和解答过的最多的问题了，经常有业务会向我反馈这个问题，比如某个类型为集合类的入参服务调用者不能解析了，服务提供方将入参类加一个属性之后服务调用方不能正常调用，升级了RPC版本后发起调用时报序列化异常了…</p><p>在序列化的选择上，与序列化协议的效率、性能、序列化协议后的体积相比，其通用性和兼容性的优先级会更高，因为他是会直接关系到服务调用的稳定性和可用率的，对于服务的性能来说，服务的可靠性显然更加重要。我们更加看重这种序列化协议在版本升级后的兼容性是否很好，是否支持更多的对象类型，是否是跨平台、跨语言的，是否有很多人已经用过并且踩过了很多的坑，其次我们才会去考虑性能、效率和空间开销。</p><p>还有一点我要特别强调。除了序列化协议的通用性和兼容性，序列化协议的安全性也是非常重要的一个参考因素，甚至应该放在第一位去考虑。以JDK原生序列化为例，它就存在漏洞。如果序列化存在安全漏洞，那么线上的服务就很可能被入侵。</p><p><img src=\"https://static001.geekbang.org/resource/image/b4/a5/b42e44968c3fdcdfe2acf96377f5b2a5.jpg\" alt=\"\"></p><p>综合上面几个参考因素，现在我们再来总结一下这几个序列化协议。</p><p>我们首选的还是Hessian与Protobuf，因为他们在性能、时间开销、空间开销、通用性、兼容性和安全性上，都满足了我们的要求。其中Hessian在使用上更加方便，在对象的兼容性上更好；Protobuf则更加高效，通用性上更有优势。</p><h2>RPC框架在使用时要注意哪些问题？</h2><p>了解了在RPC框架中如何选择序列化，那么我们在使用过程中需要注意哪些序列化上的问题呢？</p><p>我刚才讲过，在RPC的运营中，我遇到的最多的问题就是序列化问题了，除了早期RPC框架本身出现的问题以外，大多数问题都是使用方使用不正确导致的，接下来我们就盘点下这些高频出现的人为问题。</p><p><strong>对象构造得过于复杂：</strong>属性很多，并且存在多层的嵌套，比如A对象关联B对象，B对象又聚合C对象，C对象又关联聚合很多其他对象，对象依赖关系过于复杂。序列化框架在序列化与反序列化对象时，对象越复杂就越浪费性能，消耗CPU，这会严重影响RPC框架整体的性能；另外，对象越复杂，在序列化与反序列化的过程中，出现问题的概率就越高。</p><p><strong>对象过于庞大：</strong>我经常遇到业务过来咨询，为啥他们的RPC请求经常超时，排查后发现他们的入参对象非常得大，比如为一个大List或者大Map，序列化之后字节长度达到了上兆字节。这种情况同样会严重地浪费了性能、CPU，并且序列化一个如此大的对象是很耗费时间的，这肯定会直接影响到请求的耗时。</p><p><strong>使用序列化框架不支持的类作为入参类：</strong>比如Hessian框架，他天然是不支持LinkedHashMap、LinkedHashSet等，而且大多数情况下最好不要使用第三方集合类，如Guava中的集合类，很多开源的序列化框架都是优先支持编程语言原生的对象。因此如果入参是集合类，应尽量选用原生的、最为常用的集合类，如HashMap、ArrayList。</p><p><strong>对象有复杂的继承关系：</strong>大多数序列化框架在序列化对象时都会将对象的属性一一进行序列化，当有继承关系时，会不停地寻找父类，遍历属性。就像问题1一样，对象关系越复杂，就越浪费性能，同时又很容易出现序列化上的问题。</p><p>在RPC框架的使用过程中，我们要尽量构建简单的对象作为入参和返回值对象，避免上述问题。</p><h2>总结</h2><p>今天我们深入学习了什么是序列化，并介绍了如JDK原生序列化、JSON、Hessian以及Protobuf等几种常见的序列化方式。</p><p>除了这些基础知识之外，我们重点讲解了在RPC框架中如何去选择序列化协议，我们有这样几个很重要的参考因素，优先级从高到低依次是安全性、通用性和兼容性，之后我们会再考虑序列化框架的性能、效率和空间开销。</p><p>这归根结底还是因为服务调用的稳定性与可靠性，要比服务的性能与响应耗时更加重要。另外对于RPC调用来说，整体调用上，最为耗时、最消耗性能的操作大多都是服务提供者执行业务逻辑的操作，这时序列化的开销对于服务整体的开销来说影响相对较小。</p><p>在使用RPC框架的过程中，我们构造入参、返回值对象，主要记住以下几点：</p><ol>\n<li>对象要尽量简单，没有太多的依赖关系，属性不要太多，尽量高内聚；</li>\n<li>入参对象与返回值对象体积不要太大，更不要传太大的集合；</li>\n<li>尽量使用简单的、常用的、开发语言原生的对象，尤其是集合类；</li>\n<li>对象不要有复杂的继承关系，最好不要有父子类的情况。</li>\n</ol><p>实际上，虽然RPC框架可以让我们发起远程调用就像调用本地一样，但在RPC框架的传输过程中，入参与返回值的根本作用就是用来传递信息的，为了提高RPC调用整体的性能和稳定性，我们的入参与返回值对象要构造得尽量简单，这很重要。</p><h2>课后思考</h2><p>RPC框架在序列化框架的选型上，你认为还需要考虑哪些因素？你还知道哪些优秀的序列化框架，它们又是否适合在RPC调用中使用？</p><p>欢迎留言和我分享你的答案和经验，也欢迎你把文章分享给你的朋友，邀请他加入学习。我们下节课再见！</p>","neighbors":{"left":{"article_title":"02 | 协议：怎么设计可扩展且向后兼容的协议？","id":199651},"right":{"article_title":"04 | 网络通信：RPC框架在网络通信上更倾向于哪种网络IO模型？","id":204696}},"comments":[{"had_liked":false,"id":181405,"user_name":"蚂蚁内推+v","can_delete":false,"product_type":"c1","uid":1050508,"ip_address":"","ucode":"24B10AEE54B3FD","user_header":"https://static001.geekbang.org/account/avatar/00/10/07/8c/0d886dcc.jpg","comment_is_top":false,"comment_ctime":1582536194,"is_pvip":false,"replies":[{"id":"70303","content":"前几天刚看到最新发布的版本已经改进支持了，原来序列化对象数组空元素有问题。","user_name":"作者回复","comment_id":181405,"uid":"1541007","ip_address":"","utype":1,"ctime":1582542767,"user_name_real":"何小锋"}],"discussion_count":3,"race_medal":0,"score":"173381228034","product_id":100046201,"comment_content":"Protostuff对象属性，以及容器内元素都支持null吧，请问老师说的不支持是指在什么场景？","like_count":41,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484991,"discussion_content":"前几天刚看到最新发布的版本已经改进支持了，原来序列化对象数组空元素有问题。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582542767,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1099706,"avatar":"https://static001.geekbang.org/account/avatar/00/10/c7/ba/4c449be2.jpg","nickname":"zhaozp","note":"","ucode":"BF390F5ED762CD","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":303550,"discussion_content":"o","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1599295558,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1003956,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/51/b4/0d402ae8.jpg","nickname":"南桥畂翊","note":"","ucode":"A97C49A6309A42","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":232370,"discussion_content":"mark  大佬看你每天都在学习，加个好友一起交流下吧","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1586867783,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181483,"user_name":"楼下小黑哥","can_delete":false,"product_type":"c1","uid":1014680,"ip_address":"","ucode":"453B099B0EE52E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7b/98/8f1aecf4.jpg","comment_is_top":false,"comment_ctime":1582549518,"is_pvip":false,"replies":[{"id":"70552","content":"是的。根据场景选择","user_name":"作者回复","comment_id":181483,"uid":"1541007","ip_address":"","utype":1,"ctime":1582763873,"user_name_real":"何小锋"}],"discussion_count":5,"race_medal":0,"score":"108956731918","product_id":100046201,"comment_content":"我觉得可读性是否也该考虑。<br>总结下序列化协议可以分为两类<br>1.文本类序列化方式，如 xml，json。优点就是可读性好，构造方便，调试也简单。不过缺点也明显，传输体积大，性能差。<br>2.二进制类学序列化方式，如 Hessian，Protobuf，优点性能好。<br>查了下，其他序列化方式还有 Thrift，Avro。","like_count":26,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485011,"discussion_content":"是的。根据场景选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582763873,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1218501,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","nickname":"罗峰","note":"","ucode":"5F3D6AF8F28322","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":372749,"discussion_content":"能给我扫盲下吗？最后不都是二进制传输吗？文本类有啥必要性","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1620450561,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":2036705,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/13/e1/6939ae4f.jpg","nickname":"knight劉先生","note":"","ucode":"CEE9BFC8D3D969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1218501,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","nickname":"罗峰","note":"","ucode":"5F3D6AF8F28322","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373288,"discussion_content":"同问","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620691532,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372749,"ip_address":""},"score":373288,"extra":""},{"author":{"id":1817756,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/bc/9c/11b19ef6.jpg","nickname":"几里瓜拉","note":"","ucode":"EB2AC52C78847D","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1218501,"avatar":"https://static001.geekbang.org/account/avatar/00/12/97/c5/84491beb.jpg","nickname":"罗峰","note":"","ucode":"5F3D6AF8F28322","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":558510,"discussion_content":"为了通用性，兼容性，跨平台性吧","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1648357518,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":372749,"ip_address":""},"score":558510,"extra":""}]},{"author":{"id":1674552,"avatar":"","nickname":"Geek_1d7447","note":"","ucode":"F95C1FBA3191AB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":229898,"discussion_content":"为啥说JSON序列化体积大，它不就是以key value形式么","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1586698317,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181790,"user_name":"小豆角","can_delete":false,"product_type":"c1","uid":1187321,"ip_address":"","ucode":"93FBADEB249C46","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tuvQ44WvwibibVoAdUSia3EdXP4fR3nyJUhLWUmVxl3jibMuVb8uZViaRsy5nAyzicBN06VA/132","comment_is_top":false,"comment_ctime":1582634636,"is_pvip":false,"replies":[{"id":"70557","content":"可以","user_name":"作者回复","comment_id":181790,"uid":"1541007","ip_address":"","utype":1,"ctime":1582764220,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"70302111372","product_id":100046201,"comment_content":"如果要传输的数据只有一个字节，也不需要序列化了。凡是离开内存需要传输或者持久化的数据，都要先进行序列化。数据离开内存，进行io的时候，就应该学习序列化的概念了。序列化就是流化，数据转成字节流。这样认为对吗","like_count":16,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485121,"discussion_content":"可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582764220,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192121,"user_name":"NEVER SETTLE","can_delete":false,"product_type":"c1","uid":1101894,"ip_address":"","ucode":"9C86BDAFDBF768","user_header":"https://static001.geekbang.org/account/avatar/00/10/d0/46/1a9229b3.jpg","comment_is_top":false,"comment_ctime":1584839702,"is_pvip":false,"replies":[{"id":"73818","content":"序列化一般用在协议里面的payload里面","user_name":"作者回复","comment_id":192121,"uid":"1541007","ip_address":"","utype":1,"ctime":1585006159,"user_name_real":"何小锋"}],"discussion_count":3,"race_medal":0,"score":"61714381846","product_id":100046201,"comment_content":"老师，我感觉这节将的序列化与反序列化，与上一节的协议很类似。可以说 protobuf既是序列化方式，也是协议。","like_count":14,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488331,"discussion_content":"序列化一般用在协议里面的payload里面","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585006159,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1041680,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/e5/10/0a94311f.jpg","nickname":"joker","note":"","ucode":"DA1FD164B64083","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266280,"discussion_content":"协议和(反)序列化的关系，前者是蓝图，后者是实现蓝图。protobuf的.proto文件就是协议，但同时它还提供了把.proto编译成可传输二进制的(反)序列化工具","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1589500611,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1589246,"avatar":"https://static001.geekbang.org/account/avatar/00/18/3f/fe/35d1afbd.jpg","nickname":"阿鸡","note":"","ucode":"F181422D4EB444","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":573095,"discussion_content":"协议是有多层的。TCP也算是协议，IP也算是协议。每个协议都有自己的协议头。应用层也有自己的协议（也就是上一节课说的可扩展的向后兼容的协议），而这节讲的序列化其实主要是指的用户在应用层自己设计的协议中的载荷的序列化，也就是你平常要调哪个接口、接口的入参Query，VO，这些东西的序列化。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1653204226,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181560,"user_name":"陈国林","can_delete":false,"product_type":"c1","uid":1438037,"ip_address":"","ucode":"83D12F3E79F197","user_header":"https://static001.geekbang.org/account/avatar/00/15/f1/55/8ac4f169.jpg","comment_is_top":false,"comment_ctime":1582559647,"is_pvip":false,"replies":[{"id":"70548","content":"所有的网络传输都是二进制，应用看见的是json是因为收到经过了反序列化","user_name":"作者回复","comment_id":181560,"uid":"1541007","ip_address":"","utype":1,"ctime":1582763618,"user_name_real":"何小锋"}],"discussion_count":9,"race_medal":0,"score":"61712101791","product_id":100046201,"comment_content":"老师你好，请教一个问题。【如果RPC框架基于HTTP协议，并且使用JSON做为序列化协议。那么业务请求数据在网络传输的过程中是JSON格式还是二进制格式呢？或者说 OSI 7层网络模型是否会自动进行一些数据的序列化？】 谢谢~","like_count":15,"discussions":[{"author":{"id":1886399,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKo0Uz1C0OCvc2XJibOkdB0PWDEOBao3DRHic8Y7nnyZ80rV4l0UBolYzcAPDLmBWZsOWGDs3aetWLQ/132","nickname":"steve_lhf","note":"","ucode":"F0829E642B7624","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186084,"discussion_content":"无论基于哪种序列化协议 网络传输过程都是二进制 这是由现在世界上传输设备的实现原理决定的 二进制被解码后 相应长度的协议体根据序列化协议反序列化为数据（你这里是JSON）","likes_number":5,"is_delete":false,"is_hidden":false,"ctime":1582645049,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1438037,"avatar":"https://static001.geekbang.org/account/avatar/00/15/f1/55/8ac4f169.jpg","nickname":"陈国林","note":"","ucode":"83D12F3E79F197","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1886399,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKo0Uz1C0OCvc2XJibOkdB0PWDEOBao3DRHic8Y7nnyZ80rV4l0UBolYzcAPDLmBWZsOWGDs3aetWLQ/132","nickname":"steve_lhf","note":"","ucode":"F0829E642B7624","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186635,"discussion_content":"感谢 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582701500,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186084,"ip_address":""},"score":186635,"extra":""},{"author":{"id":2435220,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLI2N2EugEticCbM9faL1L8XVibPKXNv6KvPBwgHwgTsyWaxp6hkBDJC6lQ1ialCsWxq5ZOOItwO4GibA/132","nickname":"silly-q","note":"","ucode":"7006C23FDA9192","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1886399,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKo0Uz1C0OCvc2XJibOkdB0PWDEOBao3DRHic8Y7nnyZ80rV4l0UBolYzcAPDLmBWZsOWGDs3aetWLQ/132","nickname":"steve_lhf","note":"","ucode":"F0829E642B7624","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":375472,"discussion_content":"请教下，【反序列化】不是将json转为对象吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1621676182,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186084,"ip_address":""},"score":375472,"extra":""}]},{"author":{"id":2163923,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/tmKD96dzOPORx0UbbIocwUR0NO4ApBIIJZ0foOibLq2xkLgV2gficxRMreycHMErXHTQpJHDFWiablxjfhWzXRntg/132","nickname":"Geek_04789d","note":"","ucode":"9341B8934455C1","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":543899,"discussion_content":"序列化只是为了让接收方能够识别你传授过来的是啥对象和二进制本身没有关系，网络传输的时候调用socket，会负责和tcp打交道，将数据转换为二进制（像protobuf,hessian数据已经是二机制的啦，就不需要转换啦），你理解socket是干啥的，你就明白，序列化本身和二机制木有啥关系，序列化更像是一种协议，双方按照协议来理解你传输过来的对象","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1641350032,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485033,"discussion_content":"所有的网络传输都是二进制，应用看见的是json是因为收到经过了反序列化","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582763618,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":2,"child_discussions":[{"author":{"id":2653715,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","nickname":"陈阳","note":"","ucode":"C8E676C967D23A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":552243,"discussion_content":"json应该是二进制字节数组经过编码为可见的json格式字符串， json字符串再序列化为对象， 这里的序列化应该是指json》对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645367817,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":485033,"ip_address":""},"score":552243,"extra":""},{"author":{"id":2653715,"avatar":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","nickname":"陈阳","note":"","ucode":"C8E676C967D23A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":552244,"discussion_content":"不知道说的对不对","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1645367832,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":485033,"ip_address":""},"score":552244,"extra":""}]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387630,"discussion_content":"内存对象 -> json -> 010101 -> json -> 内存对象 ;到底是哪步是 序列化 法序列化?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628309432,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1261360,"avatar":"https://static001.geekbang.org/account/avatar/00/13/3f/30/23f6b413.jpg","nickname":"五十九秒","note":"","ucode":"1F34F62193CFF6","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":390179,"discussion_content":"我目前的理解是对象->json是序列化，json->010101是根据字符集对json进行编码。","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1629704228,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":387630,"ip_address":""},"score":390179,"extra":""}]}]},{"had_liked":false,"id":181562,"user_name":"Sephiroth","can_delete":false,"product_type":"c1","uid":1205786,"ip_address":"","ucode":"AE4C296C17AC46","user_header":"https://static001.geekbang.org/account/avatar/00/12/66/1a/585a76ef.jpg","comment_is_top":false,"comment_ctime":1582559701,"is_pvip":false,"replies":[{"id":"70547","content":"也是有名的rpc和序列化","user_name":"作者回复","comment_id":181562,"uid":"1541007","ip_address":"","utype":1,"ctime":1582763546,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"40237265365","product_id":100046201,"comment_content":"为什么没有说thrift呢？","like_count":9,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485035,"discussion_content":"也是有名的rpc和序列化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582763546,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181840,"user_name":"雨霖铃声声慢","can_delete":false,"product_type":"c1","uid":1052607,"ip_address":"","ucode":"656D98310C6DA3","user_header":"https://static001.geekbang.org/account/avatar/00/10/0f/bf/ee93c4cf.jpg","comment_is_top":false,"comment_ctime":1582642884,"is_pvip":false,"replies":[{"id":"70556","content":"跨语言需求越来越多","user_name":"作者回复","comment_id":181840,"uid":"1541007","ip_address":"","utype":1,"ctime":1582764144,"user_name_real":"何小锋"}],"discussion_count":2,"race_medal":0,"score":"35942381252","product_id":100046201,"comment_content":"我感觉要序列化框架选型的时候也要考虑语言兼容性，比如有些应用是多语言的，那么就要考虑能够兼容多种语言的序列化框架， 比如protobuf就可以编译成Java、python、C++、C#、Go等代码，然后就可以直接使用，不需要再写其他代码，自带有解析的代码。<br>Kryo也是一种非常成熟的序列化实现，它的性能在各个方面都比hessian2要优秀些，但是Kryo不是线程安全，因此当希望使用Kryo构建的工具类时候，需要在实例化的时候注意线程安全的问题。","like_count":9,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485139,"discussion_content":"跨语言需求越来越多","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582764144,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009422,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/0e/c77ad9b1.jpg","nickname":"eason2017","note":"","ucode":"E070BA624FA490","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":205788,"discussion_content":"因为后端服务的语言也是很丰富的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1584342953,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192717,"user_name":"来","can_delete":false,"product_type":"c1","uid":1048433,"ip_address":"","ucode":"2612C1D888ED03","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ff/71/c492b7fa.jpg","comment_is_top":false,"comment_ctime":1584869375,"is_pvip":true,"replies":[{"id":"73751","content":"是的。","user_name":"作者回复","comment_id":192717,"uid":"1541007","ip_address":"","utype":1,"ctime":1584942040,"user_name_real":"何小锋"}],"discussion_count":2,"race_medal":0,"score":"31649640447","product_id":100046201,"comment_content":"关于如何选择序列化协议：<br>1、常见的序列化协议有JDK、Hession、Protobuf、JSON、XML；<br>2、序列化协议的选择指标为序列化性能、序列化后数据大小、协议本身兼容性(协议版本上下兼容性，跨语言兼容性)、安全性。<br>这几种协议对比如下：<br>1、JSON、XML，可读性好，但是性能较差，序列化后占用空间大，序列化后数据无类型，需要反射才能获取对象类型；<br>2、JDK通过InputStream、OutputSteeam来序列化、反序列化，性能也比较差；<br>3、Hession、Protobuf性能都比较好，Hession对象兼容性更好，Protobuf更加高效。RPC框架一般选用这两种的比较多。<br><br>","like_count":7,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488444,"discussion_content":"是的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584942040,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2036705,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/13/e1/6939ae4f.jpg","nickname":"knight劉先生","note":"","ucode":"CEE9BFC8D3D969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373289,"discussion_content":"大佬有用过thriftrpc？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620691744,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181552,"user_name":"Jackey","can_delete":false,"product_type":"c1","uid":1063751,"ip_address":"","ucode":"125DE81993FEDD","user_header":"https://static001.geekbang.org/account/avatar/00/10/3b/47/f6c772a1.jpg","comment_is_top":false,"comment_ctime":1582558251,"is_pvip":false,"replies":[{"id":"70549","content":"很精简","user_name":"作者回复","comment_id":181552,"uid":"1541007","ip_address":"","utype":1,"ctime":1582763690,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"31647329323","product_id":100046201,"comment_content":"想到了Redis使用的RESP，在做序列化时也是会增加很多冗余的字符，但它胜在实现简单、可读性强易于理解","like_count":7,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485029,"discussion_content":"很精简","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582763690,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":294012,"user_name":"学习学习学习学习学习学习学习","can_delete":false,"product_type":"c1","uid":1243322,"ip_address":"","ucode":"FBEF1575658620","user_header":"https://static001.geekbang.org/account/avatar/00/12/f8/ba/37c24a08.jpg","comment_is_top":false,"comment_ctime":1621677848,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"23096514328","product_id":100046201,"comment_content":"**常用的序列化方式**<br><br>- JDK原生序列化<br>    - 序列化过程就是在读取对象数据时，不断的加入特殊分隔符，这些分隔符用于在反序列化时，截断使用<br>    - 头部数据用来声明序列化协议、序列化版本，用于高低版本向后兼容<br>    - 对象数据主要包括类名、签名、属性名、属性类型及属性值，当然还有开头结尾等数据，除了属性值属于真正的对象值，其他都是为了反序列化用的元数据<br>    - 存在对象引用、继承的情况下，就是递归遍历“写对象”逻辑<br>- JSON序列化<br>    - JSON 进行序列化的额外空间开销比较大，对于大数据量服务这意味着需要巨大的内存和磁盘开销<br>    - JSON 没有类型，但像 Java 这种强类型语言，需要通过反射统一解决，所以性能不会太好。<br>- Hessian<br>    - Hessian 是动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架。Hessian 协议要比 JDK、JSON 更加紧凑，性能上要比 JDK、JSON 序列化高效很多，而且生成的字节数也更小。<br>    - 但是Hessian对于某些常见的对象类型不支持<br>- Protobuf<br>    - Protobuf 使用的时候需要定义 IDL（Interface description language），然后使用不同语言的 IDL 编译器，生成序列化工具类<br>    - 优点如下：<br>        - 序列化后体积相比 JSON、Hessian 小很多<br>        - IDL 能清晰地描述语义，所以足以帮助并保证应用程序之间的类型不会丢失<br>        - 序列化反序列化速度很快，不需要通过反射获取类型<br>        - 消息格式升级和兼容性不错，可以做到向后兼容。<br>    - 缺点：<br>        - 不支持NULL<br>        - Protobuf 不支持单纯的 Map、List 集合对象，需要包在对象里面。<br><br>**序列化协议的选择**<br><br>- 序列化协议的通用性与兼容性<br><br>- 性能效率<br>- 空间开销，也就是序列化后的二进制数据的体积大小<br>- 序列化协议的安全性<br><br>**序列化框架的注意点**<br><br>- 对象构造的过于复杂<br>    - 对象构造的越复杂，越浪费性能<br>    - 对象越复杂，出现问题的概率就越高<br>- 对象过于庞大<br>    - 序列化后的直接长度过长会严重的浪费性能，并且传入如此大的对象，很消耗时间<br>- 使用序列化协议不支持的类型作为入参类<br>- 对象有复杂的继承关系<br>    - 当有继承关系时，需要不同的寻找父类，遍历属性","like_count":6},{"had_liked":false,"id":210297,"user_name":"JavaShare","can_delete":false,"product_type":"c1","uid":1856802,"ip_address":"","ucode":"E4B867B6ABF6F8","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/yia5fvc6xTzm6bwUrHdX8CWkwhj6tmVeZZd6AWNw5QVlicLa2dAP4xButFEqBtf1uH9tAtnBcvhiasV4u4uW6PtiaA/132","comment_is_top":false,"comment_ctime":1587716451,"is_pvip":false,"replies":[{"id":"78546","content":"最明显的就是你说的数据包大，因为字符相对二进制更占空间","user_name":"作者回复","comment_id":210297,"uid":"1541007","ip_address":"","utype":1,"ctime":1587950410,"user_name_real":"何小锋"}],"discussion_count":4,"race_medal":0,"score":"23062552931","product_id":100046201,"comment_content":"为什么JSON的额外开销大呢？是因为存在大量的换行吗","like_count":6,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":492995,"discussion_content":"最明显的就是你说的数据包大，因为字符相对二进制更占空间","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1587950410,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":3,"child_discussions":[{"author":{"id":1127990,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/36/0a202717.jpg","nickname":"吉姆餐厅ak","note":"","ucode":"D6A784D3FAFC4D","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"discussion":{"id":535594,"discussion_content":"这么解释不太合适。json最终还是会编码为二进制。所以，都是二进制传输，为啥json占用内存？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1638493535,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":492995,"ip_address":""},"score":535594,"extra":""},{"author":{"id":2435535,"avatar":"https://static001.geekbang.org/account/avatar/00/25/29/cf/db5be02a.jpg","nickname":"漆黑的小白","note":"","ucode":"C8FF1577C6FBDC","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1127990,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/36/0a202717.jpg","nickname":"吉姆餐厅ak","note":"","ucode":"D6A784D3FAFC4D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549614,"discussion_content":"比如protobuf传递null的策略就是压根不传这个字段，传递数字也是抛去了二进制后前面占位的0，总之机器能读懂就行；而json是表意的，为了让人看懂，多了很多有的没的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644137829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":535594,"ip_address":""},"score":549614,"extra":""},{"author":{"id":1309681,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKvNozkiaiao1IyuCzEIMPiaNicB1hgEcad3X4DS6IAq5lnOiagf2690Q7Q1RmyBN89gNqYHeHHtY2RcqQ/132","nickname":"墨龙","note":"","ucode":"8C63C5D18E0877","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1127990,"avatar":"https://static001.geekbang.org/account/avatar/00/11/36/36/0a202717.jpg","nickname":"吉姆餐厅ak","note":"","ucode":"D6A784D3FAFC4D","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":585412,"discussion_content":"json协议本身的语法没那么紧凑是一方面。另一方面，任何一段json的任何一个值都是字符类型啊，即使想要表示一个字段是或者否的两种状态，比如&#34;i&#34;:1 ，其中的1也占用一个字节长度。而极限情况理想协议是不是只要一个bit就能表示了呢。（何况每一个引号、冒号、逗号、大括号都是字符至少占1byte）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1661515248,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":535594,"ip_address":"北京"},"score":585412,"extra":""}]}]},{"had_liked":false,"id":193993,"user_name":"南桥畂翊","can_delete":false,"product_type":"c1","uid":1003956,"ip_address":"","ucode":"A97C49A6309A42","user_header":"https://static001.geekbang.org/account/avatar/00/0f/51/b4/0d402ae8.jpg","comment_is_top":false,"comment_ctime":1585012129,"is_pvip":false,"replies":[{"id":"74070","content":"JSON与XML适合在http服务中使用。","user_name":"作者回复","comment_id":193993,"uid":"1541007","ip_address":"","utype":1,"ctime":1585097609,"user_name_real":"何小锋"}],"discussion_count":2,"race_medal":0,"score":"23059848609","product_id":100046201,"comment_content":"JSON&#47;XML不好吗？<br><br>好，再没有一种序列化方案能像JSON和XML一样流行，自由、方便，拥有强大的表达力和跨平台能力。是通用数据传输格式的默认首选。不过随着数据量的增加和性能要求的提升，这种自由与通用带来的性能问题也不容忽视。<br><br>JSON和XML使用字符串表示所有的数据，对于非字符数据来说，字面量表达会占用很多额外的存储空间，并且会严重受到数值大小和精度的影响。 一个32位浮点数 1234.5678 在内存中占用 4 bytes 空间，如果存储为 utf8 ，则需要占用 9 bytes空间，在JS这样使用utf16表达字符串的环境中，需要占用 18 bytes空间。 使用正则表达式进行数据解析，在面对非字符数据时显得十分低效，不仅要耗费大量的运算解析数据结构，还要将字面量转换成对应的数据类型。<br><br>在面对海量数据时，这种格式本身就能够成为整个系统的IO与计算瓶颈，甚至直接overflow。","like_count":5,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488720,"discussion_content":"JSON与XML适合在http服务中使用。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585097609,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1799719,"avatar":"https://static001.geekbang.org/account/avatar/00/1b/76/27/aa2743e7.jpg","nickname":"小南风","note":"","ucode":"249B070497C815","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":273233,"discussion_content":"这个回答太好了。json 处理非字符数据很低效的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1590420588,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181749,"user_name":"忆水寒","can_delete":false,"product_type":"c1","uid":1147453,"ip_address":"","ucode":"E3F86BD8AA8903","user_header":"https://static001.geekbang.org/account/avatar/00/11/82/3d/356fc3d6.jpg","comment_is_top":false,"comment_ctime":1582627747,"is_pvip":false,"replies":[{"id":"70554","content":"一般的场景不用压缩，在数据包大的情况下考虑","user_name":"作者回复","comment_id":181749,"uid":"1541007","ip_address":"","utype":1,"ctime":1582764061,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"14467529635","product_id":100046201,"comment_content":"既要考虑序列化&#47;反序列化的高效性 也要考虑压缩的性能，也要考虑平台的兼容性。当然了，将元素进行二进制编码也是可以传输的。","like_count":3,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485105,"discussion_content":"一般的场景不用压缩，在数据包大的情况下考虑","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582764061,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181729,"user_name":"阿卧","can_delete":false,"product_type":"c1","uid":1229566,"ip_address":"","ucode":"68C0CC25E57707","user_header":"https://static001.geekbang.org/account/avatar/00/12/c2/fe/038a076e.jpg","comment_is_top":false,"comment_ctime":1582625178,"is_pvip":false,"replies":[{"id":"70553","content":"需要改造一下就行。内部协议支持，在序列化的时候没有设置类型，当成了普通map。把类型带上就ok。","user_name":"作者回复","comment_id":181729,"uid":"1541007","ip_address":"","utype":1,"ctime":1582764022,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"14467527066","product_id":100046201,"comment_content":"1. 在不是太在意性能的场景下，考虑其可读性。目前json序列化用的比较多。<br>老师，为什么hessian不支持linkedhashmap这样的对象啊？","like_count":3,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485098,"discussion_content":"需要改造一下就行。内部协议支持，在序列化的时候没有设置类型，当成了普通map。把类型带上就ok。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582764022,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181157,"user_name":"盘胧","can_delete":false,"product_type":"c1","uid":1650748,"ip_address":"","ucode":"5386CC4C92ECC2","user_header":"https://static001.geekbang.org/account/avatar/00/19/30/3c/0668d6ae.jpg","comment_is_top":false,"comment_ctime":1582508910,"is_pvip":false,"replies":[{"id":"70304","content":"会嵌套序列化","user_name":"作者回复","comment_id":181157,"uid":"1541007","ip_address":"","utype":1,"ctime":1582542827,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"14467410798","product_id":100046201,"comment_content":"请问如果对象类继承关系比较简单，使用组合后，这个类里组合的其他类对象实例也需要连续被序列化么？","like_count":3,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484942,"discussion_content":"会嵌套序列化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582542827,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":232993,"user_name":"见南山","can_delete":false,"product_type":"c1","uid":1118111,"ip_address":"","ucode":"6A8BB82B7573CA","user_header":"https://static001.geekbang.org/account/avatar/00/11/0f/9f/f4b06bd5.jpg","comment_is_top":false,"comment_ctime":1594185155,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"10184119747","product_id":100046201,"comment_content":"常见的序列化协议有：xml json  protobuf  jdk等<br>xml和json可读性好，序列化后空间大，性能差，而且json序列化后无类型，需要反射获取对象类型。而protobuf则是可读性差点，序列化后占用空间小，性能好，不需要反序列化获取属性类型等优点。对性能要求高的原则protobuf比较好点","like_count":2},{"had_liked":false,"id":200087,"user_name":"Bern","can_delete":false,"product_type":"c1","uid":1765806,"ip_address":"","ucode":"5A979552D5800D","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLlxr0eX6ZPlpiaUkH8SXoNibmOK9MJz2ZDYq5y57UfFHBu6dDc5VxKic1rAPiawLBVdSMl8y1Mwtp9Yg/132","comment_is_top":false,"comment_ctime":1585541706,"is_pvip":false,"replies":[{"id":"74940","content":"加油","user_name":"作者回复","comment_id":200087,"uid":"1541007","ip_address":"","utype":1,"ctime":1585569901,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"10175476298","product_id":100046201,"comment_content":"受益匪浅","like_count":2,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489938,"discussion_content":"加油","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585569901,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":192786,"user_name":"冰河时代","can_delete":false,"product_type":"c1","uid":1098504,"ip_address":"","ucode":"F4375FB7CE4FD4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/08/28c327d0.jpg","comment_is_top":false,"comment_ctime":1584872836,"is_pvip":false,"replies":[{"id":"73749","content":"服务提供者会根据请求消息中的序列化标识自动匹配，选择那种序列化方式是有消费者决定的。","user_name":"作者回复","comment_id":192786,"uid":"1541007","ip_address":"","utype":1,"ctime":1584941988,"user_name_real":"何小锋"}],"discussion_count":1,"race_medal":0,"score":"10174807428","product_id":100046201,"comment_content":"序列化方式为什么是在消费者配置的","like_count":2,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":488461,"discussion_content":"服务提供者会根据请求消息中的序列化标识自动匹配，选择那种序列化方式是有消费者决定的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584941988,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":279776,"user_name":"thomas","can_delete":false,"product_type":"c1","uid":1016777,"ip_address":"","ucode":"9AB945308F1B50","user_header":"https://static001.geekbang.org/account/avatar/00/0f/83/c9/5d03981a.jpg","comment_is_top":false,"comment_ctime":1613961449,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"5908928745","product_id":100046201,"comment_content":"请问protobuffer的安全性是指什么？ 一般应用场景都是内部服务直接的调用","like_count":1},{"had_liked":false,"id":215968,"user_name":"钱","can_delete":false,"product_type":"c1","uid":1009652,"ip_address":"","ucode":"2C92A243A463D4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","comment_is_top":false,"comment_ctime":1589160903,"is_pvip":false,"replies":[{"id":"80446","content":"序列化就是把对象转二进制，不同类型再加一个分隔符","user_name":"作者回复","comment_id":215968,"uid":"1541007","ip_address":"","utype":1,"ctime":1589500804,"user_name_real":"何小锋"}],"discussion_count":2,"race_medal":0,"score":"5884128199","product_id":100046201,"comment_content":"1：RPC 框架在序列化框架的选型上，你认为还需要考虑哪些因素？<br>基本上如老师所说的因素都需要考虑，如果还有，那就是易用性、代码可读性、协议可扩展性、跨语言兼容性、健壮性不过相对于，安全、效率、性能这些都是锦上添花类型的非刚需，刚需还是安全＋效率＋性能<br><br>2：你还知道哪些优秀的序列化框架，它们又是否适合在 RPC 调用中使用？<br>THRIFT这个也很知名<br><br>如果老师能顺带讲一下序列化框架的原理就好了，这块内容才是真正重要的，专栏里的这些非常容易获得和理解，不过背后特性的支撑点是不容易的，这块能讲一下就好了。当然，自己也能看的！","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":494628,"discussion_content":"序列化就是把对象转二进制，不同类型再加一个分隔符","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589500804,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1009652,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/67/f4/9a1feb59.jpg","nickname":"钱","note":"","ucode":"2C92A243A463D4","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":266358,"discussion_content":"我是指序列化的原理，怎么把对象和二进制互转？有不同框架，且性能差距很大，所以，原理应该不一样，猜测比较复杂。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589505290,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":197857,"user_name":"Geek_95d287","can_delete":false,"product_type":"c1","uid":1928897,"ip_address":"","ucode":"6DCA311AB06740","user_header":"","comment_is_top":false,"comment_ctime":1585401043,"is_pvip":false,"replies":[{"id":"75099","content":"像java在jvm层就屏蔽了","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1585641814,"ip_address":"","comment_id":197857,"utype":1}],"discussion_count":3,"race_medal":0,"score":"5880368339","product_id":100046201,"comment_content":"何老师，您好，请教序列化对象后在网络上传输如何兼顾大小端问题？多谢","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":489606,"discussion_content":"像java在jvm层就屏蔽了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585641814,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387633,"discussion_content":"大小端 是 哪个 字节序 大小端的吗?","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1628309780,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1928897,"avatar":"","nickname":"Geek_95d287","note":"","ucode":"6DCA311AB06740","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":219068,"discussion_content":"何老师，您好，请教序列化对象后在网络上传输如何兼顾大小端问题？多谢\n作者回复: 像java在jvm层就屏蔽了\n请问c++有方法处理嘛？多谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1585730583,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":189510,"user_name":"冰河时代","can_delete":false,"product_type":"c1","uid":1098504,"ip_address":"","ucode":"F4375FB7CE4FD4","user_header":"https://static001.geekbang.org/account/avatar/00/10/c3/08/28c327d0.jpg","comment_is_top":false,"comment_ctime":1584523803,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5879491099","product_id":100046201,"comment_content":".序列化方式Hessian，Protobuf，为什么序列化效率高呢？","like_count":1},{"had_liked":false,"id":185776,"user_name":"魔术师","can_delete":false,"product_type":"c1","uid":1879192,"ip_address":"","ucode":"36D9E8ABF310F3","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eqv55obzKRZh0icQ6N4EHCb0BR0gJIk3BLlNoXIXaLJWyXqxCCV3a6BsAkghOmPUyBGG8ibObBeOkJQ/132","comment_is_top":false,"comment_ctime":1583678099,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5878645395","product_id":100046201,"comment_content":"ICE应该是比较通用和成熟的，就是技术门槛比较高","like_count":1},{"had_liked":false,"id":184511,"user_name":"Tesla","can_delete":false,"product_type":"c1","uid":1500742,"ip_address":"","ucode":"98629AFD9861EE","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKUcSLVV6ia3dibe7qvTu8Vic1PVs2EibxoUdx930MC7j2Q9A6s4eibMDZlcicMFY0D0icd3RrDorMChu0zw/132","comment_is_top":false,"comment_ctime":1583331741,"is_pvip":false,"replies":[{"id":"71850","content":"说的如果json数据存储在磁盘上，json字节数相对其他数据都偏大","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1583733753,"ip_address":"","comment_id":184511,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5878299037","product_id":100046201,"comment_content":"老师好，json需要内存去解析能理解，但为什么json序列化还需要磁盘开销啊。json序列化的二进制数据在体量比其他序列化方法小一些吧，可以减少带宽和流量","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486043,"discussion_content":"说的如果json数据存储在磁盘上，json字节数相对其他数据都偏大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583733753,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183152,"user_name":"kevin","can_delete":false,"product_type":"c1","uid":1199192,"ip_address":"","ucode":"918EFC033B1630","user_header":"https://static001.geekbang.org/account/avatar/00/12/4c/58/25152fa9.jpg","comment_is_top":false,"comment_ctime":1582962776,"is_pvip":false,"replies":[{"id":"71851","content":"是的","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1583733818,"ip_address":"","comment_id":183152,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5877930072","product_id":100046201,"comment_content":"序列化就是将对象转换成二进制流在网络上传输，反序列化就是将收到的二进制流解析成对象供应用使用","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485576,"discussion_content":"是的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583733818,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2690172,"avatar":"","nickname":"Geek_设计模式之美","note":"","ucode":"59263416E65594","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":387634,"discussion_content":"内存对象 -> json -> 010101 -> json -> 内存对象 ;到底是哪步是 序列化 法序列化?","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1628309829,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182909,"user_name":"胡图","can_delete":false,"product_type":"c1","uid":1647357,"ip_address":"","ucode":"6D43BD2BE81E38","user_header":"https://static001.geekbang.org/account/avatar/00/19/22/fd/f45d56e9.jpg","comment_is_top":false,"comment_ctime":1582887830,"is_pvip":false,"replies":[{"id":"71856","content":"可控的数据结构还是可以尝试的","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1583734129,"ip_address":"","comment_id":182909,"utype":1}],"discussion_count":1,"race_medal":0,"score":"5877855126","product_id":100046201,"comment_content":"protostuff不好用，实体类新增属性的时候要求放最后，或者加Tag注解，发版过程中导致接口完全不可用","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485501,"discussion_content":"可控的数据结构还是可以尝试的","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583734129,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181529,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1582555363,"is_pvip":false,"replies":[{"id":"70550","content":"protobuf只是序列化，不能确保。","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1582763799,"ip_address":"","comment_id":181529,"utype":1}],"discussion_count":4,"race_medal":0,"score":"5877522659","product_id":100046201,"comment_content":"IDL文件我们最早大概是在2000年左右，用来解耦Java和Corba的，它的问题是每次改动后的版本控制比较麻烦，因为Java端和Corba端要拿相同版本的IDL才能编过。<br>Protobuf里是如何让收发两端都拿到同一版本的IDL呢？<br>","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485022,"discussion_content":"protobuf只是序列化，不能确保。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582763799,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1116272,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIu1n1DhUGGKTjelrQaLYOSVK2rsFeia0G8ASTIftib5PTOx4pTqdnfwb0NiaEFGRgS661nINyZx9sUg/132","nickname":"Zzz","note":"","ucode":"4AA47797F48315","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211947,"discussion_content":"就是因为我们有允许调用方和服务方有不同版本IDL的需要，才会反复提到向下兼容。使用PB时本来就不要求版本相同。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584897375,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":2,"child_discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1116272,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIu1n1DhUGGKTjelrQaLYOSVK2rsFeia0G8ASTIftib5PTOx4pTqdnfwb0NiaEFGRgS661nINyZx9sUg/132","nickname":"Zzz","note":"","ucode":"4AA47797F48315","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211980,"discussion_content":"谢谢你的见解。\n我理解的不一致是指相同message在不同IDL中有不同的定义，而不是新增删不同的message。\n我只是有点好奇，短期不一致是同步的副作用，而何种场景对长期不一致的IDL文件有诉求。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584921668,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211947,"ip_address":""},"score":211980,"extra":""},{"author":{"id":1116272,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIu1n1DhUGGKTjelrQaLYOSVK2rsFeia0G8ASTIftib5PTOx4pTqdnfwb0NiaEFGRgS661nINyZx9sUg/132","nickname":"Zzz","note":"","ucode":"4AA47797F48315","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":212029,"discussion_content":"不清楚你说的message具体定义是什么。如果你说的定义不同是指相同的二进制数据被解析成不同名称或类型的变量，那这是使用不当造成的bug，短期的不一致都是难以接受的。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584926757,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":211980,"ip_address":""},"score":212029,"extra":""}]}]},{"had_liked":false,"id":181123,"user_name":"艾斯曼","can_delete":false,"product_type":"c1","uid":1001772,"ip_address":"","ucode":"B73FA6A2530138","user_header":"https://static001.geekbang.org/account/avatar/00/0f/49/2c/a2a948b6.jpg","comment_is_top":false,"comment_ctime":1582496809,"is_pvip":false,"replies":[{"id":"70302","content":"是的，rpc也在不断发展","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1582542630,"ip_address":"","comment_id":181123,"utype":1}],"discussion_count":2,"race_medal":0,"score":"5877464105","product_id":100046201,"comment_content":"还有thrift框架，它和grpc差不多。最早的rpc还有基于xml的，这个就更差了，不过早期确实好有用。","like_count":1,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":484927,"discussion_content":"是的，rpc也在不断发展","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582542630,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2036705,"avatar":"https://static001.geekbang.org/account/avatar/00/1f/13/e1/6939ae4f.jpg","nickname":"knight劉先生","note":"","ucode":"CEE9BFC8D3D969","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":373290,"discussion_content":"看讨论，大厂grpc貌似用的比较多，thriftrpc性能要好，怎么选择呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1620691867,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":359153,"user_name":"hillwater","can_delete":false,"product_type":"c1","uid":2826205,"ip_address":"上海","ucode":"FB16D5FCE8C7E6","user_header":"","comment_is_top":false,"comment_ctime":1665290736,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665290736","product_id":100046201,"comment_content":"听说hession协议存在安全漏洞","like_count":0},{"had_liked":false,"id":359149,"user_name":"hillwater","can_delete":false,"product_type":"c1","uid":2826205,"ip_address":"上海","ucode":"FB16D5FCE8C7E6","user_header":"","comment_is_top":false,"comment_ctime":1665290080,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1665290080","product_id":100046201,"comment_content":"以前碰到一个bug，父类和子类含有相同的字段，序列化后只剩下一个了，再反序列化，父类字段有值，子类为null。解决办法是删除子类的重复字段","like_count":0},{"had_liked":false,"id":319951,"user_name":"陈阳","can_delete":false,"product_type":"c1","uid":2653715,"ip_address":"","ucode":"C8E676C967D23A","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKib3vNM6TPT1umvR3TictnLurJPKuQq4iblH5upgBB3kHL9hoN3Pgh3MaR2rjz6fWgMiaDpicd8R5wsAQ/132","comment_is_top":false,"comment_ctime":1636016367,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1636016367","product_id":100046201,"comment_content":"老师，对象再内存中存在形式就是二进制的吧， 序列化是为了兼容各种系统，语言，而将对象转成一种特殊的字符格式，传输的时候将转化后的字符文本以二进制的形式传输， 序列化好像并不是为了转成二进制数据， 因为数据都是二进制的 ","like_count":0},{"had_liked":false,"id":318766,"user_name":"余先生嗨全天哈最幸福的人","can_delete":false,"product_type":"c1","uid":1389093,"ip_address":"","ucode":"4C14996F71717F","user_header":"https://static001.geekbang.org/account/avatar/00/15/32/25/9584d3b7.jpg","comment_is_top":false,"comment_ctime":1635418191,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1635418191","product_id":100046201,"comment_content":"其实对象简单这个说起来很简单，但是当遇到业务场景复杂的时候，很难保持简单。","like_count":0},{"had_liked":false,"id":315366,"user_name":"俯瞰风景.","can_delete":false,"product_type":"c1","uid":1044166,"ip_address":"","ucode":"A6DB68B7B84AEE","user_header":"https://static001.geekbang.org/account/avatar/00/0f/ee/c6/bebcbcf0.jpg","comment_is_top":false,"comment_ctime":1633862452,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1633862452","product_id":100046201,"comment_content":"由于rpc框架要解决远程调用的问题，所以需要对对象数据进行序列化，对二进制数据进行反序列化，其中要应用到序列化框架，要根据实际需求选择合适的序列化框架，一般情况下的考虑优先级是：安全性》通用性》兼容性》性能》效率》空间开销。<br><br>虽然 RPC 框架可以让我们发起远程调用就像调用本地一样，但在 RPC 框架的传输过程中，入参与返回值的根本作用就是用来传递信息的，为了提高 RPC 调用整体的性能和稳定性，我们的入参与返回值对象要构造得尽量简单。<br><br>使用序列化框架时，为了获得更好的序列化性能，有以下几个注意点：<br>  1、对象要尽量简单，没有太多的依赖关系，属性不要太多，尽量高内聚；<br>  2、入参对象与返回值对象体积不要太大，更不要传太大的集合；<br>  3、尽量使用简单的、常用的、开发语言原生的对象，尤其是集合类；<br>  4、对象不要有复杂的继承关系，最好不要有父子类的情况。","like_count":0},{"had_liked":false,"id":292934,"user_name":"Geek_b52974","can_delete":false,"product_type":"c1","uid":1298252,"ip_address":"","ucode":"59884399646620","user_header":"","comment_is_top":false,"comment_ctime":1621087887,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1621087887","product_id":100046201,"comment_content":"思考了一下 protobuf 升級定義的流程<br>假如要新增一個屬性刪除一個required 屬性<br>1. 新增的屬性要設為 optional<br>2. 刪除的屬性也要設為 optional<br>這樣才可以做到向前向後相容","like_count":0},{"had_liked":false,"id":292095,"user_name":"knight劉先生","can_delete":false,"product_type":"c1","uid":2036705,"ip_address":"","ucode":"CEE9BFC8D3D969","user_header":"https://static001.geekbang.org/account/avatar/00/1f/13/e1/6939ae4f.jpg","comment_is_top":false,"comment_ctime":1620691666,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1620691666","product_id":100046201,"comment_content":"thriftrpc与grpc，目前公司内测thriftrpc性能要好，grpc性能要差点，使用的Python语言，请问下现在很多大厂用grpc，有大厂用thriftrpc吗？这两个一般怎么选？","like_count":0,"discussions":[{"author":{"id":1074734,"avatar":"https://static001.geekbang.org/account/avatar/00/10/66/2e/527b73c9.jpg","nickname":"骑着🚀看银河","note":"","ucode":"8706A99A89F0CE","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557534,"discussion_content":"thrift美团  字节 都在用","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647854859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":2231238,"avatar":"https://static001.geekbang.org/account/avatar/00/22/0b/c6/eacd1efd.jpg","nickname":"好好学习","note":"","ucode":"6DE79FE79CDCBB","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":382442,"discussion_content":"吃透原理，上层实现对于我们来说只是工具","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1625572939,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":289570,"user_name":"chai","can_delete":false,"product_type":"c1","uid":1202222,"ip_address":"","ucode":"C686EB1B1EBAB6","user_header":"https://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83ep66fdwo3ebSicKjf0iacAx4C2tZOthDDD4bSJqib1iauFBK6EoMSWUBp4UbbN2BQlib7mFR3hQD6MUwew/132","comment_is_top":false,"comment_ctime":1619084137,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1619084137","product_id":100046201,"comment_content":"可读性","like_count":0},{"had_liked":false,"id":269753,"user_name":"活到一百岁","can_delete":false,"product_type":"c1","uid":1367033,"ip_address":"","ucode":"6A50B0956C025E","user_header":"https://static001.geekbang.org/account/avatar/00/14/db/f9/87656f2b.jpg","comment_is_top":false,"comment_ctime":1608777594,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1608777594","product_id":100046201,"comment_content":"老师好，现实中确实可能出现大list，大map的场景，对于此类较大的数据类型，应该怎样做序列化呢？还是只能传raw data？","like_count":0},{"had_liked":false,"id":257469,"user_name":"To  be  me","can_delete":false,"product_type":"c1","uid":2229725,"ip_address":"","ucode":"A38EE5C38BAE60","user_header":"https://static001.geekbang.org/account/avatar/00/22/05/dd/63f56982.jpg","comment_is_top":false,"comment_ctime":1603980853,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603980853","product_id":100046201,"comment_content":"json属于文本类序列化方式，那json序列化之后，还是要转成字节放到网络上传输，那与将对象转化为普通字符串之后变成字节放到哇网络上传输有什么区别呢？","like_count":0},{"had_liked":false,"id":253745,"user_name":"奋斗","can_delete":false,"product_type":"c1","uid":2047392,"ip_address":"","ucode":"C84C2D030ACA51","user_header":"https://static001.geekbang.org/account/avatar/00/1f/3d/a0/acf6b165.jpg","comment_is_top":false,"comment_ctime":1602850612,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1602850612","product_id":100046201,"comment_content":"老师你好，我想问下一个学 C++ 的适合这门课程吗？ 我看你讲的例子都用的是 Java","like_count":0},{"had_liked":false,"id":246987,"user_name":"J.Smile","can_delete":false,"product_type":"c1","uid":1336475,"ip_address":"","ucode":"C4D98DFDBF7584","user_header":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","comment_is_top":false,"comment_ctime":1599550667,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"1599550667","product_id":100046201,"comment_content":"文中图里的协议编码和协议解码是什么东东？没有介绍一下","like_count":0,"discussions":[{"author":{"id":1336475,"avatar":"https://static001.geekbang.org/account/avatar/00/14/64/9b/0b578b08.jpg","nickname":"J.Smile","note":"","ucode":"C4D98DFDBF7584","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":312591,"discussion_content":"RPC架构层次：\n♻️序列化框架：作用是将方法调用时传入的发送数据从对象转为二进制，序列化一般用在协议里面的payload里面，如jdk、msgpack、protobuf、json、hessian等，推荐首选的还是 Hessian 与 Protobuf。\n♻️编解码框架：编解码是对网络传输消息进行处理，把二进制的数据(payload)进一步封装（或者拆解）为rpc的协议(消息头+消息体)。\n♻️协议：包括协议头和协议体，是网络传输数据格式的约定，作用将发送的数据按照一定的规约进行序列化为二进制流，有http/tcp/ftp等协议，grpc就是基于http的协议。\n♻️Proxy：作用是让RPC框架根据调用的服务接口提前生成动态代理实现类，实现类似本地的调用感觉。\n♻️负载均衡框架：结合服务注册中心实现服务端列表的路由选择和调用，如restTemplate、ribbon、feignClient等。\n♻️熔断降级框架：实现调用过程中的熔断保护和降级函数。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1602741746,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":186260,"user_name":"此鱼不得水","can_delete":false,"product_type":"c1","uid":1257453,"ip_address":"","ucode":"95268E823FB4D2","user_header":"https://static001.geekbang.org/account/avatar/00/13/2f/ed/a87bb8fa.jpg","comment_is_top":false,"comment_ctime":1583810823,"is_pvip":false,"replies":[{"id":"72567","content":"protostuff虽然好，尽量用在可控的数据结构","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1584285769,"ip_address":"","comment_id":186260,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1583810823","product_id":100046201,"comment_content":"protostuff我们之前遇到一个坑，在进行序列化和反序列化后，空List会变成null。","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":486695,"discussion_content":"protostuff虽然好，尽量用在可控的数据结构","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584285769,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":183060,"user_name":"凹凸","can_delete":false,"product_type":"c1","uid":1198112,"ip_address":"","ucode":"D6F0EBDC8F2588","user_header":"https://static001.geekbang.org/account/avatar/00/12/48/20/f1898740.jpg","comment_is_top":false,"comment_ctime":1582945472,"is_pvip":false,"replies":[{"id":"71624","content":"可以考虑加上压缩","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1583622033,"ip_address":"","comment_id":183060,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582945472","product_id":100046201,"comment_content":"现在我们平台自研的RPC是json序列化的，就像老师说的，更多的性能问题还是服务提供方的服务是否是高性能的，但是有存量业务，有那种但业务场景有大对象的传输，要么拆分业务要么可以考虑流式传递数据","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485552,"discussion_content":"可以考虑加上压缩","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583622033,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182418,"user_name":"cricket1981","can_delete":false,"product_type":"c1","uid":1001715,"ip_address":"","ucode":"758262F5958DA4","user_header":"https://static001.geekbang.org/account/avatar/00/0f/48/f3/f1034ffd.jpg","comment_is_top":false,"comment_ctime":1582784072,"is_pvip":false,"replies":[{"id":"71590","content":"序列化这块目前确实没有最完美的，hessian的鲁棒性还可以","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1583574786,"ip_address":"","comment_id":182418,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582784072","product_id":100046201,"comment_content":"有哪些rpc协议是支持继承关系的？我使用kafka消息用的是avro协议，可惜它天然不支持继承关系","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485332,"discussion_content":"序列化这块目前确实没有最完美的，hessian的鲁棒性还可以","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583574786,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":182331,"user_name":"Reason","can_delete":false,"product_type":"c1","uid":1878898,"ip_address":"","ucode":"C2A8D67BC6F94D","user_header":"https://static001.geekbang.org/account/avatar/00/1c/ab/72/c3a5eff3.jpg","comment_is_top":false,"comment_ctime":1582769621,"is_pvip":false,"replies":[{"id":"71640","content":"确实存在有不兼容的数据","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1583627951,"ip_address":"","comment_id":182331,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582769621","product_id":100046201,"comment_content":"1. RPC 框架在序列化框架的选型上，你认为还需要考虑哪些因素？<br>我觉得还需要考虑序列化框架的跨语言兼容性，比如ProtoStuff序列化后是否可以在C++中以Protobuf的序列化协议进行反序列化。<br>2. 优秀的序列化框架还有？<br>thrift序列化协议，在thrift框架中使用；kryo序列化协议。<br>3. 另外有两个问题请教下老师，麻烦您指教啦<br>（1）ProtoStuff序列化对象封装的Map后的二进制流，能否用ProtoBuf-Java框架正常反序列化呢？我试了下好像有不兼容问题，Map的key、value均为String<br>（2）Protostuff支持proto3吗？","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485307,"discussion_content":"确实存在有不兼容的数据","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1583627951,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181751,"user_name":"旺财勇士","can_delete":false,"product_type":"c1","uid":1800068,"ip_address":"","ucode":"EB87A0D17C8F98","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTI7y20jxxAnsdGLuUDjicibsgaMGO0PQg7WNTrNCzqmibtrsibpjJJHs6LK0FTWKs8icJickMJPkM7Tia2UA/132","comment_is_top":false,"comment_ctime":1582628256,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1582628256","product_id":100046201,"comment_content":"课程非常棒，就是更新有点慢","like_count":0},{"had_liked":false,"id":181537,"user_name":"小伟","can_delete":false,"product_type":"c1","uid":1359701,"ip_address":"","ucode":"124953423491E2","user_header":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","comment_is_top":false,"comment_ctime":1582555866,"is_pvip":false,"replies":[{"id":"70513","content":"网络传输的数据都是二进制","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1582720128,"ip_address":"","comment_id":181537,"utype":1}],"discussion_count":8,"race_medal":0,"score":"1582555866","product_id":100046201,"comment_content":"何老师，为何数据在网络传输时一定要是二进制？<br>我想主要还是兼容、高效的考虑吧。","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485026,"discussion_content":"网络传输的数据都是二进制","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582720128,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1886399,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKo0Uz1C0OCvc2XJibOkdB0PWDEOBao3DRHic8Y7nnyZ80rV4l0UBolYzcAPDLmBWZsOWGDs3aetWLQ/132","nickname":"steve_lhf","note":"","ucode":"F0829E642B7624","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186088,"discussion_content":"这是现代计算机的实现原理决定的 推荐你看一本很薄的书《编码的奥秘》你就懂了","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1582645114,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1359701,"avatar":"https://static001.geekbang.org/account/avatar/00/14/bf/55/198c6104.jpg","nickname":"小伟","note":"","ucode":"124953423491E2","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1886399,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKo0Uz1C0OCvc2XJibOkdB0PWDEOBao3DRHic8Y7nnyZ80rV4l0UBolYzcAPDLmBWZsOWGDs3aetWLQ/132","nickname":"steve_lhf","note":"","ucode":"F0829E642B7624","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186938,"discussion_content":"谢谢","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582721788,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186088,"ip_address":""},"score":186938,"extra":""}]},{"author":{"id":1605134,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7e/0e/b828909c.jpg","nickname":"益","note":"","ucode":"80B610EAE2EFCE","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":186378,"discussion_content":"没记错的话，物理网络传输的信号是电磁波／光信号，都是模拟信号，到了两端需要通过调制解调器转换成0和1信号，简单说非0 1信号没办法在物理线路上传播的。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1582679126,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1272026,"avatar":"https://static001.geekbang.org/account/avatar/00/13/68/da/5bcb83b1.jpg","nickname":"白晨","note":"","ucode":"6D6171B8ECEDDD","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":1605134,"avatar":"https://static001.geekbang.org/account/avatar/00/18/7e/0e/b828909c.jpg","nickname":"益","note":"","ucode":"80B610EAE2EFCE","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":557766,"discussion_content":"老哥，这属于哪块的内容呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1647958457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":186378,"ip_address":""},"score":557766,"extra":""}]},{"author":{"id":1180731,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/3b/96d0eef1.jpg","nickname":"gaspar","note":"","ucode":"073115380E5751","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":203594,"discussion_content":"对象在内存也是二进制格式吧，网络传输也是二进制，那为何还需要所谓的序列化呢？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584059065,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1116272,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIu1n1DhUGGKTjelrQaLYOSVK2rsFeia0G8ASTIftib5PTOx4pTqdnfwb0NiaEFGRgS661nINyZx9sUg/132","nickname":"Zzz","note":"","ucode":"4AA47797F48315","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1180731,"avatar":"https://static001.geekbang.org/account/avatar/00/12/04/3b/96d0eef1.jpg","nickname":"gaspar","note":"","ucode":"073115380E5751","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":211948,"discussion_content":"计算机一切都是二进制，如果你能够把整个计算机运行环境和上下文传输过去当然没问题。要在一个进程中使用数据除了数据具体值本身，还有元数据。可不是复制一段内存就可以直接用了。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1584897898,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":203594,"ip_address":""},"score":211948,"extra":""}]},{"author":{"id":1386315,"avatar":"https://static001.geekbang.org/account/avatar/00/15/27/4b/e49c82d0.jpg","nickname":"Rover","note":"","ucode":"7575EC91F45B99","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":185360,"discussion_content":"我想还是计算机只认识0和1吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582620156,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181452,"user_name":"鱼_XueTr","can_delete":false,"product_type":"c1","uid":1506691,"ip_address":"","ucode":"A164D2540F251D","user_header":"https://static001.geekbang.org/account/avatar/00/16/fd/83/b432b125.jpg","comment_is_top":false,"comment_ctime":1582542884,"is_pvip":false,"replies":[{"id":"70544","content":"它也是一种序列化","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1582763457,"ip_address":"","comment_id":181452,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582542884","product_id":100046201,"comment_content":"flatbuffer算么？","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485003,"discussion_content":"它也是一种序列化","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582763457,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":181433,"user_name":"小兜","can_delete":false,"product_type":"c1","uid":1122861,"ip_address":"","ucode":"147F96339BDB81","user_header":"https://static001.geekbang.org/account/avatar/00/11/22/2d/b3b9aaf4.jpg","comment_is_top":false,"comment_ctime":1582539825,"is_pvip":false,"replies":[{"id":"70298","content":"根据实际情况选择","user_name":"作者回复","user_name_real":"何小锋","uid":"1541007","ctime":1582542458,"ip_address":"","comment_id":181433,"utype":1}],"discussion_count":1,"race_medal":0,"score":"1582539825","product_id":100046201,"comment_content":"在序列化框架的选择上，由于用于数据传输所以还需要考虑稳定性。Thrift也会用于rpc的序列化。","like_count":0,"discussions":[{"author":{"id":1541007,"avatar":"https://static001.geekbang.org/account/avatar/00/17/83/8f/8471d633.jpg","nickname":"何小锋","note":"","ucode":"E9B3B4A1B75D8B","race_medal":0,"user_type":2,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":485000,"discussion_content":"根据实际情况选择","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1582542458,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":true,"parent_id":0,"ip_address":""},"score":2,"extra":"{\"reply\":true,\"user_type\":2}","child_discussion_number":0,"child_discussions":[]}]}]}