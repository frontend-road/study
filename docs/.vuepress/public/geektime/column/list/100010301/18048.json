{"id":18048,"title":"23 | 逃逸分析","content":"<p>我们知道，Java中<code>Iterable</code>对象的foreach循环遍历是一个语法糖，Java编译器会将该语法糖编译为调用<code>Iterable</code>对象的<code>iterator</code>方法，并用所返回的<code>Iterator</code>对象的<code>hasNext</code>以及<code>next</code>方法，来完成遍历。</p>\n<pre><code>public void forEach(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f) {\n  for (Object obj : list) {\n    f.accept(obj);\n  }\n}\n</code></pre>\n<p>举个例子，上面的Java代码将使用foreach循环来遍历一个<code>ArrayList</code>对象，其等价的代码如下所示：</p>\n<pre><code>public void forEach(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f) {\n  Iterator&lt;Object&gt; iter = list.iterator();\n  while (iter.hasNext()) {\n    Object obj = iter.next();\n    f.accept(obj);\n  }\n}\n</code></pre>\n<p>这里我也列举了所涉及的<code>ArrayList</code>代码。我们可以看到，<code>ArrayList.iterator</code>方法将创建一个<code>ArrayList$Itr</code>实例。</p>\n<pre><code>public class ArrayList ... {\n  public Iterator&lt;E&gt; iterator() {\n    return new Itr();\n  }\n  private class Itr implements Iterator&lt;E&gt; {\n    int cursor;       // index of next element to return\n    int lastRet = -1; // index of last element returned; -1 if no such\n    int expectedModCount = modCount;\n    ...\n    public boolean hasNext() {\n      return cursor != size;\n    }\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public E next() {\n      checkForComodification();\n      int i = cursor;\n      if (i &gt;= size)\n        throw new NoSuchElementException();\n      Object[] elementData = ArrayList.this.elementData;\n      if (i &gt;= elementData.length)\n        throw new ConcurrentModificationException();\n      cursor = i + 1;\n      return (E) elementData[lastRet = i];\n    }\n    ...\n    final void checkForComodification() {\n      if (modCount != expectedModCount)\n        throw new ConcurrentModificationException();\n    }\n  }\n}\n</code></pre>\n<p>因此，有同学认为我们应当避免在热点代码中使用foreach循环，并且直接使用基于<code>ArrayList.size</code>以及<code>ArrayList.get</code>的循环方式（如下所示），以减少对Java堆的压力。</p>\n<pre><code>public void forEach(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f) {\n  for (int i = 0; i &lt; list.size(); i++) {\n    f.accept(list.get(i));\n  }\n}\n</code></pre>\n<p>实际上，Java虚拟机中的即时编译器可以将<code>ArrayList.iterator</code>方法中的实例创建操作给优化掉。不过，这需要方法内联以及逃逸分析的协作。</p>\n<p>在前面几篇中我们已经深入学习了方法内联，今天我便来介绍一下逃逸分析。</p><!-- [[[read_end]]] -->\n<h2>逃逸分析</h2>\n<p>逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”（出处参见[1]）。</p>\n<p>在Java虚拟机的即时编译语境下，逃逸分析将判断<strong>新建</strong>的对象是否<strong>逃逸</strong>。即时编译器判断对象是否逃逸的依据，一是对象是否被存入堆中（静态字段或者堆中对象的实例字段），二是对象是否被传入未知代码中。</p>\n<p>前者很好理解：一旦对象被存入堆中，其他线程便能获得该对象的引用。即时编译器也因此无法追踪所有使用该对象的代码位置。</p>\n<p>关于后者，由于Java虚拟机的即时编译器是以方法为单位的，对于方法中未被内联的方法调用，即时编译器会将其当成未知代码，毕竟它无法确认该方法调用会不会将调用者或所传入的参数存储至堆中。因此，我们可以认为方法调用的调用者以及参数是逃逸的。</p>\n<p>通常来说，即时编译器里的逃逸分析是放在方法内联之后的，以便消除这些“未知代码”入口。</p>\n<p>回到文章开头的例子。理想情况下，即时编译器能够内联对<code>ArrayList$Itr</code>构造器的调用，对<code>hasNext</code>以及<code>next</code>方法的调用，以及当内联了<code>Itr.next</code>方法后，对<code>checkForComodification</code>方法的调用。</p>\n<p>如果这些方法调用均能够被内联，那么结果将近似于下面这段伪代码：</p>\n<pre><code>public void forEach(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f) {\n  Itr iter = new Itr; // 注意这里是new指令\n  iter.cursor = 0;\n  iter.lastRet = -1;\n  iter.expectedModCount = list.modCount;\n  while (iter.cursor &lt; list.size) {\n    if (list.modCount != iter.expectedModCount)\n      throw new ConcurrentModificationException();\n    int i = iter.cursor;\n    if (i &gt;= list.size)\n      throw new NoSuchElementException();\n    Object[] elementData = list.elementData;\n    if (i &gt;= elementData.length)\n      throw new ConcurrentModificationException();\n    iter.cursor = i + 1;\n    iter.lastRet = i;\n    Object obj = elementData[i];\n    f.accept(obj);\n  }\n}\n</code></pre>\n<p>可以看到，这段代码所新建的<code>ArrayList$Itr</code>实例既没有被存入任何字段之中，也没有作为任何方法调用的调用者或者参数。因此，逃逸分析将断定该实例不逃逸。</p>\n<h2>基于逃逸分析的优化</h2>\n<p>即时编译器可以根据逃逸分析的结果进行诸如锁消除、栈上分配以及标量替换的优化。</p>\n<p>我们先来看一下锁消除。如果即时编译器能够证明锁对象不逃逸，那么对该锁对象的加锁、解锁操作没有意义。这是因为其他线程并不能获得该锁对象，因此也不可能对其进行加锁。在这种情况下，即时编译器可以消除对该不逃逸锁对象的加锁、解锁操作。</p>\n<p>实际上，传统编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于Java虚拟机即时编译的限制，上述条件被强化为证明锁对象不逃逸出当前编译的方法。</p>\n<p>在介绍Java内存模型时，我曾提过<code>synchronized (new Object()) {}</code>会被完全优化掉。这正是因为基于逃逸分析的锁消除。由于其他线程不能获得该锁对象，因此也无法基于该锁对象构造两个线程之间的happens-before规则。</p>\n<p><code>synchronized (escapedObject) {}</code>则不然。由于其他线程可能会对逃逸了的对象<code>escapedObject</code>进行加锁操作，从而构造了两个线程之间的happens-before关系。因此即时编译器至少需要为这段代码生成一条刷新缓存的内存屏障指令。</p>\n<p>不过，基于逃逸分析的锁消除实际上并不多见。一般来说，开发人员不会直接对方法中新构造的对象进行加锁。事实上，逃逸分析的结果更多被用于将新建对象操作转换成栈上分配或者标量替换。</p>\n<p>我们知道，Java虚拟机中对象都是在堆上分配的，而堆上的内容对任何线程都是可见的。与此同时，Java虚拟机需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。</p>\n<p>如果逃逸分析能够证明某些新建的对象不逃逸，那么Java虚拟机完全可以将其分配至栈上，并且在new语句所在的方法退出时，通过弹出当前方法的栈桢来自动回收所分配的内存空间。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。</p>\n<p>不过，由于实现起来需要更改大量假设了“对象只能堆分配”的代码，因此HotSpot虚拟机<strong>并没有</strong>采用栈上分配，而是使用了标量替换这么一项技术。</p>\n<p>所谓的标量，就是仅能存储一个值的变量，比如Java代码中的局部变量。与之相反，聚合量则可能同时存储多个值，其中一个典型的例子便是Java对象。</p>\n<p>标量替换这项优化技术，可以看成将原本对对象的字段的访问，替换为一个个局部变量的访问。举例来说，前面经过内联之后的forEach代码可以被转换为如下代码：</p>\n<pre><code>public void forEach(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f) {\n  // Itr iter = new Itr; // 经过标量替换后该分配无意义，可以被优化掉\n  int cursor = 0;     // 标量替换\n  int lastRet = -1;   // 标量替换\n  int expectedModCount = list.modCount; // 标量替换\n  while (cursor &lt; list.size) {\n    if (list.modCount != expectedModCount)\n      throw new ConcurrentModificationException();\n    int i = cursor;\n    if (i &gt;= list.size)\n      throw new NoSuchElementException();\n    Object[] elementData = list.elementData;\n    if (i &gt;= elementData.length)\n      throw new ConcurrentModificationException();\n    cursor = i + 1;\n    lastRet = i;\n    Object obj = elementData[i];\n    f.accept(obj);\n  }\n}\n</code></pre>\n<p>可以看到，原本需要在内存中连续分布的对象，现已被拆散为一个个单独的字段<code>cursor</code>，<code>lastRet</code>，以及<code>expectedModCount</code>。这些字段既可以存储在栈上，也可以直接存储在寄存器中。而该对象的对象头信息则直接消失了，不再被保存至内存之中。</p>\n<p>由于该对象没有被实际分配，因此和栈上分配一样，它同样可以减轻垃圾回收的压力。与栈上分配相比，它对字段的内存连续性不做要求，而且，这些字段甚至可以直接在寄存器中维护，无须浪费任何内存空间。</p>\n<h2>部分逃逸分析</h2>\n<p>C2的逃逸分析与控制流无关，相对来说比较简单。Graal则引入了一个与控制流有关的逃逸分析，名为部分逃逸分析（partial escape analysis）[2]。它解决了所新建的实例仅在部分程序路径中逃逸的情况。</p>\n<p>举个例子，在下面这段代码中，新建实例只会在进入if-then分支时逃逸。（对<code>hashCode</code>方法的调用是一个HotSpot intrinsic，将被替换为一个无法内联的本地方法调用。）</p>\n<pre><code>public static void bar(boolean cond) {\n  Object foo = new Object();\n  if (cond) {\n    foo.hashCode();\n  }\n}\n// 可以手工优化为：\npublic static void bar(boolean cond) {\n  if (cond) {\n    Object foo = new Object();\n    foo.hashCode();\n  }\n}\n</code></pre>\n<p>假设if语句的条件成立的可能性只有1%，那么在99%的情况下，程序没有必要新建对象。其手工优化的版本正是部分逃逸分析想要自动达到的成果。</p>\n<p>部分逃逸分析将根据控制流信息，判断出新建对象仅在部分分支中逃逸，并且将对象的新建操作推延至对象逃逸的分支中。这将使得原本因对象逃逸而无法避免的新建对象操作，不再出现在只执行if-else分支的程序路径之中。</p>\n<p>综上，与C2所使用的逃逸分析相比，Graal所使用的部分逃逸分析能够优化更多的情况，不过它编译时间也更长一些。</p>\n<h2>总结与实践</h2>\n<p>今天我介绍了Java虚拟机中即时编译器的逃逸分析，以及基于逃逸分析的优化。</p>\n<p>在Java虚拟机的即时编译语境下，逃逸分析将判断新建的对象是否会逃逸。即时编译器判断对象逃逸的依据有两个：一是看对象是否被存入堆中，二是看对象是否作为方法调用的调用者或者参数。</p>\n<p>即时编译器会根据逃逸分析的结果进行优化，如锁消除以及标量替换。后者指的是将原本连续分配的对象拆散为一个个单独的字段，分布在栈上或者寄存器中。</p>\n<p>部分逃逸分析是一种附带了控制流信息的逃逸分析。它将判断新建对象真正逃逸的分支，并且支持将新建操作推延至逃逸分支。</p>\n<hr />\n<p>今天的实践环节有两项内容。</p>\n<p>第一项内容，我们来验证一下<code>ArrayList.iterator</code>中的新建对象能否被逃逸分析所优化。运行下述代码并观察GC的情况。你可以通过虚拟机参数<code>-XX:-DoEscapeAnalysis</code>来关闭默认开启的逃逸分析。</p>\n<pre><code>// Run with\n// java -XX:+PrintGC -XX:+DoEscapeAnalysis EscapeTest\nimport java.util.ArrayList;\nimport java.util.function.Consumer;\n\npublic class EscapeTest {\n\n  public static void forEach(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f) {\n    for (Object obj : list) {\n      f.accept(obj);\n    }\n  }\n\n  public static void main(String[] args) {\n    ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; 100; i++) {\n      list.add(i);\n    }\n    for (int i = 0; i &lt; 400_000_000; i++) {\n      forEach(list, obj -&gt; {});\n    }\n  }\n}\n\n</code></pre>\n<p>第二项内容，我们来看一看部分逃逸分析的效果。你需要使用附带Graal编译器的Java版本，如Java 10，来运行下述代码，并且观察GC的情况。你可以通过虚拟机参数<code>-XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler</code>来启用Graal。</p>\n<pre><code>// Run with\n// java -Xlog:gc Foo\n// java -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler -Xlog:gc Foo\npublic class Foo {\n  long placeHolder0;\n  long placeHolder1;\n  long placeHolder2;\n  long placeHolder3;\n  long placeHolder4;\n  long placeHolder5;\n  long placeHolder6;\n  long placeHolder7;\n  long placeHolder8;\n  long placeHolder9;\n  long placeHoldera;\n  long placeHolderb;\n  long placeHolderc;\n  long placeHolderd;\n  long placeHoldere;\n  long placeHolderf;\n  public static void bar(boolean condition) {\n    Foo foo = new Foo();\n    if (condition) {\n      foo.hashCode();\n    }\n  }\n  public static void main(String[] args) {\n    for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {\n      bar(i % 100 == 0);\n    }\n  }\n}\n</code></pre>\n<p>[1] <a href=\"https://zh.wikipedia.org/wiki/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90\">https://zh.wikipedia.org/wiki/逃逸分析</a><br />\n[2] <a href=\"http://www.ssw.uni-linz.ac.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf\">http://www.ssw.uni-linz.ac.at/Research/Papers/Stadler14/Stadler2014-CGO-PEA.pdf</a></p>\n<p></p>\n","neighbors":{"left":{"article_title":"22 | HotSpot虚拟机的intrinsic","id":18046},"right":{"article_title":"24 | 字段访问相关优化","id":39683}},"comments":[{"had_liked":false,"id":23882,"user_name":"魏春河","can_delete":false,"product_type":"c1","uid":1117048,"ip_address":"","ucode":"DDD2998C157639","user_header":"https://static001.geekbang.org/account/avatar/00/11/0b/78/22410c47.jpg","comment_is_top":false,"comment_ctime":1536713414,"is_pvip":false,"discussion_count":9,"race_medal":1,"score":"96025993926","product_id":100010301,"comment_content":"怎么看出来对象是否放入堆中？不是所有的对象都在堆中吗","like_count":22,"discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292571,"discussion_content":"正常情况对象都是放在堆中，但是经过逃逸分析后，如果是不可逃逸对象，那么会把在堆上创建的对象的，优化到用标量来替换，或者直接存在栈上，因为堆上的对象是共享的，而栈上的线程私有的，这样就可以节省垃圾回收的成本，同时栈上的数据，入栈出栈就是相当于对象的创建和回收过程。","likes_number":9,"is_delete":false,"is_hidden":false,"ctime":1595256473,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1297630,"avatar":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","nickname":"剑八","note":"","ucode":"0A09F41DB8A4E7","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282958,"discussion_content":"理解是如果被编绎器优化了，一个方法内new的对象，如果证明是非逃逸的，就可能不会在堆上分配对象了，直接使用标量替换或栈上分配","likes_number":3,"is_delete":false,"is_hidden":false,"ctime":1592128758,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1254968,"avatar":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","nickname":"Darren","note":"","ucode":"CCD2B2C492BE9A","race_medal":0,"user_type":1,"is_pvip":true},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":198509,"discussion_content":"目前栈上分配的优化的机制在HotSpot虚拟机还未暂时实现","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1583506374,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1238619,"avatar":"https://static001.geekbang.org/account/avatar/00/12/e6/5b/07e1a8e3.jpg","nickname":"Tsundere","note":"","ucode":"3A8CED0747BF32","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":297814,"discussion_content":"我感觉是这个意思：\n目前我们别的书上看来的.java文件里面new 对象的写法是在堆上分配内存的，其实对JVM而言，编译器在将class文件编译执行时，会进行逃逸分析，然后才来创建内存（内存的分配是晚于逃逸分析的）。\n个人感觉HotSpot为了兼容之前的SDK，不会做一层栈分配技术。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1597065403,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284563,"discussion_content":"目前为止（包括以后，我不感觉这个东西会改掉），java所有对象还是再堆上，只不过如果对象通过了逃逸分析。会把对象拆开成一个个局部变量，实际上创建的对象会减少，但是如果对象创建出来，依旧在堆中。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1592556859,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1156061,"avatar":"","nickname":"未设置","note":"","ucode":"CC6C355BCABE98","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":135121,"discussion_content":"应该是对象的引用出现在堆中，这样就会被堆中的其他对象发现和使用","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1579070706,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1126946,"avatar":"https://static001.geekbang.org/account/avatar/00/11/32/22/abb7bfe3.jpg","nickname":"kebishuai","note":"","ucode":"955655E3D2C06C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":357154,"discussion_content":"方法内创建的对象是线程私有的，是不会分配到堆中的，堆是线程共享的，这种情况被视作对象不会逃逸。","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1615736212,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1980201,"avatar":"https://static001.geekbang.org/account/avatar/00/1e/37/29/b3af57a7.jpg","nickname":"凯文小猪","note":"","ucode":"36D8AD0229547F","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1126946,"avatar":"https://static001.geekbang.org/account/avatar/00/11/32/22/abb7bfe3.jpg","nickname":"kebishuai","note":"","ucode":"955655E3D2C06C","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":362725,"discussion_content":"方法内对象仍然要走一遍new invokespecial流程 只不过栈指针是存留在栈上 这些就是gc root。逃逸分析是说 如果判定对象不逃逸 那么就把堆上对象这个事免了 直接在栈上用标量指向就好了","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1617019194,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":357154,"ip_address":""},"score":362725,"extra":""}]},{"author":{"id":1023225,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/9c/f9/2a2be193.jpg","nickname":"GL€","note":"","ucode":"3CA0D6D8C4A1CA","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":315631,"discussion_content":"不过，由于实现起来需要更改大量假设了“对象只能堆分配”的代码，因此 HotSpot 虚拟机并没有采用栈上分配，而是使用了标量替换这么一项技术。这个说法于hotspot的版本有关系吗？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1603294994,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":185182,"user_name":"Darren","can_delete":false,"product_type":"c1","uid":1254968,"ip_address":"","ucode":"CCD2B2C492BE9A","user_header":"https://static001.geekbang.org/account/avatar/00/13/26/38/ef063dc2.jpg","comment_is_top":false,"comment_ctime":1583506773,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"48828147029","product_id":100010301,"comment_content":"逃逸分析的主要优化点是：栈上分配，标量替换，同步消除。其中同步消除比较少，栈上分配在HotSpot中暂未实现，主要是标量替换。<br>逃逸分析的缺点是：分析过程比较耗费性能或者分析完毕后发现非逃逸的对象很少。<br>逃逸程度：不逃逸，方法逃逸，线程逃逸；其中栈上分配不支持线程逃逸，标量替换不支持方法逃逸。","like_count":11,"discussions":[{"author":{"id":1055577,"avatar":"https://static001.geekbang.org/account/avatar/00/10/1b/59/6eb40da0.jpg","nickname":"freedom","note":"","ucode":"073F6EF58C0F26","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":305173,"discussion_content":"背课文呢啊","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1599807892,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":274841,"user_name":"八九","can_delete":false,"product_type":"c1","uid":1191617,"ip_address":"","ucode":"B996A884BFA474","user_header":"https://static001.geekbang.org/account/avatar/00/12/2e/c1/0fcd29ab.jpg","comment_is_top":false,"comment_ctime":1611194207,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"18791063391","product_id":100010301,"comment_content":"看完老师的讲解，我又看了下面的这个文章，感觉好像更理解了一些。<br>逃逸分析<br>逃逸分析并不是直接的优化手段，而是一个代码分析，通过动态分析对象的作用域，为其它优化手段如栈上分配、标量替换和同步消除等提供依据，发生逃逸行为的情况有两种：方法逃逸和线程逃逸。<br>1、方法逃逸：当一个对象在方法中定义之后，作为参数传递到其它方法中；<br>2、线程逃逸：如类变量或实例变量，可能被其它线程访问到；<br><br>如果不存在逃逸行为，则可以对该对象进行如下优化：同步消除、标量替换和栈上分配。<br><br>同步消除<br>线程同步本身比较耗，如果确定一个对象不会逃逸出线程，无法被其它线程访问到，那该对象的读写就不会存在竞争，则可以消除对该对象的同步锁，通过-XX:+EliminateLocks可以开启同步消除。<br><br>标量替换<br>1、标量是指不可分割的量，如java中基本数据类型和reference类型，相对的一个数据可以继续分解，称为聚合量；<br>2、如果把一个对象拆散，将其成员变量恢复到基本类型来访问就叫做标量替换；<br>3、如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是在栈上创建若干个成员变量；<br>通过-XX:+EliminateAllocations可以开启标量替换， -XX:+PrintEliminateAllocations查看标量替换情况。<br><br>栈上分配<br>故名思议就是在栈上分配对象，其实目前Hotspot并没有实现真正意义上的栈上分配，实际上是标量替换。<br>......<br>链接：https:&#47;&#47;www.jianshu.com&#47;p&#47;20bd2e9b1f03","like_count":5},{"had_liked":false,"id":114811,"user_name":"乘风","can_delete":false,"product_type":"c1","uid":1115724,"ip_address":"","ucode":"0420C5535DACB7","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLwSoTjHPX5tm4whBSfoZLX6toZxrZGUaLABQywKNf4MDc9toK3QSV7Z99ATcGicFCysoleQ5ISzmw/132","comment_is_top":false,"comment_ctime":1563411338,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"18743280522","product_id":100010301,"comment_content":"看了此篇后有一些疑惑：<br>\t1.为什么对象存入到堆中就无法追踪其代码位置？ 当基于全局的优化确定对象的作用域限定在方法内部，其引用不会发生逃逸，这样的对象虽然存在堆中但其引用作用域固定，不会发生方法逃逸。<br>\t2.逃逸分析的判断依据是对象是否存入到堆中，而后文又讲到HotSpot并没有采用栈上分配，那不是意味着对象是一定分配在堆中吗？<br>\t","like_count":4,"discussions":[{"author":{"id":1179565,"avatar":"https://static001.geekbang.org/account/avatar/00/11/ff/ad/5020a8c5.jpg","nickname":"Farewell丶","note":"","ucode":"A0D69893C5375C","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":13886,"discussion_content":"在新建对象时进行分析，如果不需要存入堆中，则进行标量替换。","likes_number":1,"is_delete":false,"is_hidden":false,"ctime":1568711636,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23905,"user_name":"李二木","can_delete":false,"product_type":"c1","uid":1103091,"ip_address":"","ucode":"30E03BB84ADB27","user_header":"https://static001.geekbang.org/account/avatar/00/10/d4/f3/129d6dfe.jpg","comment_is_top":false,"comment_ctime":1536716139,"is_pvip":true,"discussion_count":1,"race_medal":0,"score":"10126650731","product_id":100010301,"comment_content":"本章介绍逃逸分析的优化作用，那么它有什么不足的地方吗？","like_count":2,"discussions":[{"author":{"id":1046662,"avatar":"https://static001.geekbang.org/account/avatar/00/0f/f8/86/ff190109.jpg","nickname":"jiangwq。","note":"","ucode":"B6D7021D476F74","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":263945,"discussion_content":"逃逸分析本身会有性能消耗","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1589269823,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23890,"user_name":"Scott","can_delete":false,"product_type":"c1","uid":1014800,"ip_address":"","ucode":"7E57FDCB5E5D49","user_header":"https://static001.geekbang.org/account/avatar/00/0f/7c/10/165cb374.jpg","comment_is_top":false,"comment_ctime":1536714629,"is_pvip":false,"discussion_count":1,"race_medal":0,"score":"10126649221","product_id":100010301,"comment_content":"你好，我翻了一下R大关于escape analysis的一篇知乎回答，里面提到C2可以对不逸出当前线程的锁做消除，这个过程是怎样的？","like_count":2,"discussions":[{"author":{"id":1508990,"avatar":"https://static001.geekbang.org/account/avatar/00/17/06/7e/735968e2.jpg","nickname":"西门吹牛","note":"","ucode":"E5D3624DDE1E83","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":292575,"discussion_content":"也就是说没加加锁解锁的操作了，如果是不逃逸的锁对象，那么也就无并发问题，无所谓加锁解锁了，因为加锁解锁需要涉及对象头的锁标记位更改，而不逃逸的对象直接用标量替换，也就没有了对象头","likes_number":2,"is_delete":false,"is_hidden":false,"ctime":1595256653,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":207529,"user_name":"GaGi","can_delete":false,"product_type":"c1","uid":1099053,"ip_address":"","ucode":"CC8D22E1DD8CA2","user_header":"https://static001.geekbang.org/account/avatar/00/10/c5/2d/1eebfc3c.jpg","comment_is_top":false,"comment_ctime":1587102653,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5882069949","product_id":100010301,"comment_content":"对于如何判断对象是逃逸的，我的理解是这样：<br>1、对象如果在堆中，其他线程是可以获取到这个对象的引用，这时如果很多地方引用到这个对象，那么就会导致即时编译器无法追踪所有使用该对象的代码位置；<br>2、关于第二点，文中说的比较清晰，就是对象如果是作为调用者调用一个未知方法&#47;作为参数传入未知方法，这时就可以认为是逃逸的；<br><br>对于上面这两点，应该是连带的；也就是说先满足对象是在堆中存储，并且对象有涉及到未知代码中就认为是逃逸的；不知道理解正不正确，如果理解不正确，麻烦老师纠正下","like_count":1},{"had_liked":false,"id":108256,"user_name":"9700","can_delete":false,"product_type":"c1","uid":1086842,"ip_address":"","ucode":"69F75713BAAFFB","user_header":"https://static001.geekbang.org/account/avatar/00/10/95/7a/ee2207f8.jpg","comment_is_top":false,"comment_ctime":1561706045,"is_pvip":false,"discussion_count":3,"race_medal":0,"score":"5856673341","product_id":100010301,"comment_content":"为啥hashCode方法不能内联，22节介绍的native方法，只要被标注了intrinsic，都会被直接内联的啊。","like_count":1,"discussions":[{"author":{"id":1447739,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eou1BMETumU21ZI4yiaLenOMSibzkAgkw944npIpsJRicmdicxlVQcgibyoQ00rdGk9Htp1j0dM5CP2Fibw/132","nickname":"寥若晨星","note":"","ucode":"2E87E43687DE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549894,"discussion_content":"因为hashCode方法可以被用户重写，内联意义不大","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644288669,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1332132,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKmRZWNsg7pibje6duXAqUOM43E6YUwdEa77NuRYDJnMsKcCTcpVyLnN8cVpDZ1ibTFiac31FgeP521g/132","nickname":"lolo。","note":"","ucode":"8D4555FBC1C382","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":1809,"discussion_content":"请问你是怎样分析出hashCode方法没被内联的？","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1562921392,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1460942,"avatar":"https://static001.geekbang.org/account/avatar/00/16/4a/ce/affe4307.jpg","nickname":"叫啥不行","note":"","ucode":"A84B9B6594BF35","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":1332132,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKmRZWNsg7pibje6duXAqUOM43E6YUwdEa77NuRYDJnMsKcCTcpVyLnN8cVpDZ1ibTFiac31FgeP521g/132","nickname":"lolo。","note":"","ucode":"8D4555FBC1C382","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":284565,"discussion_content":"因为上面文章里面写的 对hashCode方法的调用是一个 HotSpot intrinsic，将被替换为一个无法内联的本地方法调用。）","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592557204,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":1809,"ip_address":""},"score":284565,"extra":""}]}]},{"had_liked":false,"id":23929,"user_name":"倔强","can_delete":false,"product_type":"c1","uid":1177878,"ip_address":"","ucode":"849B0BA1AC7E29","user_header":"https://static001.geekbang.org/account/avatar/00/11/f9/16/99a7045d.jpg","comment_is_top":false,"comment_ctime":1536722147,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5831689443","product_id":100010301,"comment_content":"老师讲的非常好，对jvm的了解更加深入了一些","like_count":1},{"had_liked":false,"id":23889,"user_name":"四阿哥","can_delete":false,"product_type":"c1","uid":1104580,"ip_address":"","ucode":"3296E89174D370","user_header":"https://static001.geekbang.org/account/avatar/00/10/da/c4/270db3ad.jpg","comment_is_top":false,"comment_ctime":1536714490,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"5831681786","product_id":100010301,"comment_content":"老师讲的很有帮助，陈列原理，结合事例，有理有据，逻辑清晰，层次鲜明","like_count":1},{"had_liked":false,"id":337408,"user_name":"cv0cv0","can_delete":false,"product_type":"c1","uid":1360093,"ip_address":"","ucode":"93FF9277F03FD0","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTLEIsgI4ub1VOKWtVOfouAzSqx8Yt8ibQEsAnwNJsJHmuJzzpQqG79HullvYwpic8hgiclgON2GwXSjw/132","comment_is_top":false,"comment_ctime":1646809841,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1646809841","product_id":100010301,"comment_content":"Graal 是作者写的吗？","like_count":0},{"had_liked":false,"id":260982,"user_name":"xzy","can_delete":false,"product_type":"c1","uid":1002095,"ip_address":"","ucode":"1A44368083A19E","user_header":"https://static001.geekbang.org/account/avatar/00/0f/4a/6f/e36b3908.jpg","comment_is_top":false,"comment_ctime":1605166445,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1605166445","product_id":100010301,"comment_content":"最后的结果还是：所有对象都在堆里面","like_count":1},{"had_liked":false,"id":254866,"user_name":"Geek_03a866","can_delete":false,"product_type":"c1","uid":2129795,"ip_address":"","ucode":"204DC1D0C5F2FC","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/hQ01GRPRFNTfBWX1Gmz0cqXZxbyJqHmORNJuE8yIqCbg1fXjvaWOGoatVo3Pbib5ZHCEqYFhSHhCVA8zr2Q2WuA/132","comment_is_top":false,"comment_ctime":1603201981,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1603201981","product_id":100010301,"comment_content":"逃逸分析将优化，线程本地存储，方法，栈帧，垃圾回收讲清楚了","like_count":0},{"had_liked":false,"id":228826,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1592818574,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592818574","product_id":100010301,"comment_content":"老师好，课后的第一个问题，从垃圾回收怎么看出是否发生了逃逸优化？","like_count":0},{"had_liked":false,"id":228819,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1592817157,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592817157","product_id":100010301,"comment_content":"老师好，怎么查看逃逸分析的效果？","like_count":0},{"had_liked":false,"id":228812,"user_name":"天使梦泪","can_delete":false,"product_type":"c1","uid":1235750,"ip_address":"","ucode":"782991747DD424","user_header":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","comment_is_top":false,"comment_ctime":1592816185,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1592816185","product_id":100010301,"comment_content":"1.不会发生逃逸吧，没有对list做改变","like_count":0},{"had_liked":false,"id":226526,"user_name":"剑八","can_delete":false,"product_type":"c1","uid":1297630,"ip_address":"","ucode":"0A09F41DB8A4E7","user_header":"https://static001.geekbang.org/account/avatar/00/13/cc/de/e28c01e1.jpg","comment_is_top":false,"comment_ctime":1592128593,"is_pvip":true,"discussion_count":0,"race_medal":0,"score":"1592128593","product_id":100010301,"comment_content":"逃逸指的是对象是否可能被多个线程访问<br>而分析对象是否逃逸的目的，最终是希望找出哪些对象是非逃逸的，我们针对非逃逸的对象可以做些优化。<br>如：锁消除，栈上替换，标量替换。<br>栈上替换和标量替换都是针对非逃逸对象，将原本需要在堆中新建对象的消耗（含后面的垃圾回收）给消除掉，通过将对象用标量替换掉来达到对于对象操作的目的。","like_count":0},{"had_liked":false,"id":127847,"user_name":"寥若晨星","can_delete":false,"product_type":"c1","uid":1447739,"ip_address":"","ucode":"2E87E43687DE72","user_header":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eou1BMETumU21ZI4yiaLenOMSibzkAgkw944npIpsJRicmdicxlVQcgibyoQ00rdGk9Htp1j0dM5CP2Fibw/132","comment_is_top":false,"comment_ctime":1566799946,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1566799946","product_id":100010301,"comment_content":"同问，“一是看对象是否被存入堆中”，所有对象不是都分配在堆中吗？","like_count":0,"discussions":[{"author":{"id":2051209,"avatar":"","nickname":"Geek_c76203","note":"","ucode":"68891B74EC0E80","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":296116,"discussion_content":"基本类型和引用类型的指针，都分配在栈上吧","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1596455279,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":1,"child_discussions":[{"author":{"id":1447739,"avatar":"http://thirdwx.qlogo.cn/mmopen/vi_32/DYAIOgq83eou1BMETumU21ZI4yiaLenOMSibzkAgkw944npIpsJRicmdicxlVQcgibyoQ00rdGk9Htp1j0dM5CP2Fibw/132","nickname":"寥若晨星","note":"","ucode":"2E87E43687DE72","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":2051209,"avatar":"","nickname":"Geek_c76203","note":"","ucode":"68891B74EC0E80","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":549896,"discussion_content":"这里说的是对象","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1644288729,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":296116,"ip_address":""},"score":549896,"extra":""}]}]},{"had_liked":false,"id":27843,"user_name":"小橙橙","can_delete":false,"product_type":"c1","uid":1054923,"ip_address":"","ucode":"4F467210A15F66","user_header":"https://static001.geekbang.org/account/avatar/00/10/18/cb/edb5a0a0.jpg","comment_is_top":false,"comment_ctime":1537954268,"is_pvip":false,"discussion_count":2,"race_medal":0,"score":"1537954268","product_id":100010301,"comment_content":"第一个示例，加了jvm参数，控制台什么内容都没有打印出来，jdk是1.8","like_count":0,"discussions":[{"author":{"id":1235750,"avatar":"https://static001.geekbang.org/account/avatar/00/12/db/26/3c8d68fb.jpg","nickname":"天使梦泪","note":"","ucode":"782991747DD424","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":285375,"discussion_content":"加上这个参数，-XX:+PrintGC  我的控制台就打印了GC信息 ","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592819422,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]},{"author":{"id":1415623,"avatar":"https://static001.geekbang.org/account/avatar/00/15/99/c7/93e90296.jpg","nickname":"文若","note":"","ucode":"691E79889202D5","race_medal":0,"user_type":1,"is_pvip":false},"reply_author":{"id":0,"avatar":"","nickname":"","note":"","ucode":"","race_medal":0,"user_type":1,"is_pvip":false},"discussion":{"id":282721,"discussion_content":"obj->{} 被逃逸分析优化掉了，每次for循环都会将其优化掉，所以不触发gc","likes_number":0,"is_delete":false,"is_hidden":false,"ctime":1592056515,"is_liked":false,"can_delete":false,"is_complain":false,"is_top":false,"parent_id":0,"ip_address":""},"score":2,"extra":"","child_discussion_number":0,"child_discussions":[]}]},{"had_liked":false,"id":23852,"user_name":"idiandian","can_delete":false,"product_type":"c1","uid":1157765,"ip_address":"","ucode":"D9259B018C2281","user_header":"https://static001.geekbang.org/account/avatar/00/11/aa/85/b9946d11.jpg","comment_is_top":false,"comment_ctime":1536706432,"is_pvip":false,"discussion_count":0,"race_medal":0,"score":"1536706432","product_id":100010301,"comment_content":"锁消除的概念很有意思","like_count":0}]}